# 内存，第二部分：实现内存分配器

## 内存分配器教程

内存分配器需要跟踪哪些字节当前已分配，哪些可供使用。本页介绍了构建分配器的实现和概念细节，即实现`malloc`和`free`的实际代码。

## 这个页面讨论了块的链接 - 我应该为它们分配内存吗？

尽管在概念上我们考虑创建链接列表和块列表，但我们不需要“malloc 内存”来创建它们！相反，我们将整数和指针写入我们已经控制的内存中，以便以后可以一致地从一个地址跳到下一个地址。这些内部信息代表了一些开销。因此，即使我们从系统请求了 1024 KB 的连续内存，我们也无法将所有内存提供给运行的程序。

## 块思考

我们可以将我们的堆内存看作是一个块的列表，其中每个块都是已分配或未分配的。我们不是存储一个显式的指针列表，而是存储关于块大小的信息*作为块的一部分*。因此，在概念上，有一个空闲块的列表，但它是隐式的，即以每个块的大小信息的形式存储。

我们可以通过添加块的大小来从一个块导航到下一个块。例如，如果您有一个指向块起始位置的指针`p`，那么`next_block`将在`((char *)p) + *(size_t *) p`，如果您将块的大小以字节存储。将`char *`强制转换为确保指针算术是以字节计算的。将`size_t *`强制转换为确保在`p`处读取的内存是一个大小值，如果`p`是`void *`或`char *`类型，则必须。

调用程序永远不会看到这些值；它们是内存分配器实现的内部值。

例如，假设您的分配器被要求保留 80 字节（`malloc(80)`）并需要 8 字节的内部头数据。分配器需要找到至少 88 字节的未分配空间。在更新堆数据后，它将返回一个指向该块的指针。但是，返回的指针并不指向块的起始位置，因为那里存储着内部大小数据！相反，我们将返回块的起始位置+8 字节。在实现中，记住指针算术取决于类型。例如，`p += 8`添加的是`8 * sizeof(p)`，而不一定是 8 字节！

## 实现 malloc

最简单的实现使用首次适配：从第一个块开始，假设存在，迭代直到找到表示足够大小的未分配空间的块，或者我们已经检查了所有的块。

如果找不到合适的块，现在是调用` sbrk()`的时候了，以充分扩展堆的大小。一个快速的实现可能会显著地扩展它，这样我们在不久的将来就不需要再请求更多的堆内存。

当找到一个空闲块时，它可能比我们需要的空间大。如果是这样，我们将在我们的隐式列表中创建两个条目。第一个条目是已分配的块，第二个条目是剩余的空间。

有两种简单的方法可以确定块是否正在使用或可用。第一种是将其存储为头信息中的一个字节，以及大小的最低位编码为 1！因此，块大小信息将仅限于偶数值：

```cpp
// Assumes p is a reasonable pointer type, e.g. 'size_t *'.
isallocated = (*p) & 1;
realsize = (*p) & ~1;  // mask out the lowest bit 
```

## 对齐和向上取整的考虑

许多体系结构希望多字节原语对齐到 2^n 的某个倍数。例如，通常要求 4 字节类型对齐到 4 字节边界（64 位系统上的 8 字节类型对齐到 8 字节边界）。如果多字节原语未存储在合理的边界上（例如从奇数地址开始），则性能可能会受到显着影响，因为可能需要两个内存读取请求而不是一个。在某些体系结构上，惩罚甚至更大-程序将因[总线错误](http://en.wikipedia.org/wiki/Bus_error#Unaligned_access)而崩溃。

由于`malloc`不知道用户将如何使用分配的内存（双精度数组？字符数组？），因此返回给程序的指针需要对最坏情况进行对齐，这取决于体系结构。

根据 glibc 文档，glibc `malloc`使用以下启发式方法：“malloc 给您的块保证对齐，以便它可以容纳任何类型的数据。在 GNU 系统上，大多数系统的地址始终是 8 的倍数，在 64 位系统上是 16 的倍数。”

例如，如果您需要计算需要多少个 16 字节单位，请不要忘记四舍五入-

```cpp
int s = (requested_bytes + tag_overhead_bytes + 15) / 16 
```

附加的常数确保不完整的单元被四舍五入。请注意，实际代码更有可能使用符号大小，例如`sizeof(x) - 1`，而不是编码数值常数 15。

[如果您有进一步兴趣，这是一篇关于内存对齐的好文章](http://www.ibm.com/developerworks/library/pa-dalign/)

## 关于内部碎片的说明

内部碎片发生在您提供的块大于其分配大小时。假设我们有一个大小为 16B 的空闲块（不包括元数据）。如果它们分配了 7 个字节，您可能希望将其四舍五入为 16B 并返回整个块。

当您实现合并和分割时（下一节），情况会变得非常阴险。如果您两者都不实现，那么您可能会为 7B 的分配返回一个大小为 64B 的块！这种分配会产生*大量*的开销，而我们正试图避免这种情况。

## 实施释放

当调用`free`时，我们需要重新应用偏移量以返回到块的“真实”起始位置（记住我们没有给用户指向块实际起始位置的指针？），即我们存储大小信息的位置。

一个天真的实现只会将块标记为未使用。如果我们将块分配状态存储在最低大小位中，那么我们只需要清除该位：

```cpp
*p = (*p) & ~1; // Clear lowest bit 
```

然而，我们还有更多的工作要做：如果当前块和下一个块（如果存在）都是空闲的，我们需要将这些块合并成一个单一的块。同样，我们也需要检查前一个块。如果存在并表示未分配的内存，那么我们需要将这些块合并成一个单一的大块。

为了能够将一个空闲块与前一个空闲块合并，我们还需要找到前一个块，因此我们也将块的大小存储在块的末尾。这些被称为“边界标记”（参考 Knuth73）。由于块是连续的，一个块的末尾就紧邻着下一个块的开始。因此，当前块（除了第一个块）可以向后查找几个字节以查找前一个块的大小。有了这些信息，您现在可以向后跳转了！

## 性能

有了上述描述，就可以构建一个内存分配器。它的主要优势是简单性 - 至少与其他分配器相比是简单的！分配内存是最坏情况下的线性时间操作（搜索链表以找到足够大的空闲块），而释放是常数时间（最多只需要将 3 个块合并成一个块）。使用这个分配器，可以尝试不同的放置策略。例如，可以从上次释放块的位置开始搜索，或者从上次分配的位置开始搜索。如果您存储块的指针，您需要非常小心，确保它们始终保持有效（例如，在合并块或其他更改堆结构的 malloc 或 free 调用时）。

## 显式空闲列表分配器

通过实现一个显式的双向链表可以实现更好的性能。在这种情况下，我们可以立即遍历到下一个空闲块和上一个空闲块。这可以减半搜索时间，因为链表只包括未分配的块。

第二个优势是我们现在对链表的排序有一定的控制。例如，当一个块被释放时，我们可以选择将其插入到链表的开头，而不总是在其邻居之间。这将在下面讨论。

我们在哪里存储链表的指针？一个简单的技巧是意识到块本身没有被使用，并将下一个和上一个指针存储为块的一部分（尽管现在你必须确保空闲块始终足够大，以容纳两个指针）。

我们仍然需要实现边界标签（即使用大小的隐式列表），以便我们可以正确地释放块并将它们与它们的两个邻居合并。因此，显式空闲列表需要更多的代码和复杂性。

使用显式链表，使用快速简单的“查找第一个”算法来查找第一个足够大的链接。然而，由于链接顺序可以被修改，这对应于不同的放置策略。例如，如果链接从大到小维护，那么这将产生“最坏适合”放置策略。

### 显式链表插入策略

新释放的块可以轻松地插入到两个可能的位置：在开头或按地址顺序（通过使用边界标签首先找到邻居）。

在开头插入会创建一个 LIFO（后进先出）策略：最近释放的空间将被重复使用。研究表明，碎片化比使用地址顺序更严重。

按地址顺序插入（“按地址顺序策略”）插入释放的块，以便以递增的地址顺序访问块。这种策略需要更多的时间来释放块，因为必须使用边界标签（大小数据）来找到下一个和上一个未分配的块。然而，碎片化较少。

## 案例研究：Buddy Allocator（分离列表的一个示例）

分离的分配器是将堆分成由不同子分配器处理的不同区域的分配器，这取决于分配请求的大小。大小被分组为类（例如，2 的幂），每个大小由不同的子分配器处理，每个大小维护其自己的空闲列表。

这种类型的一个众所周知的分配器是伙伴分配器。我们将讨论二进制伙伴分配器，它将分配分成 2^n（n = 1, 2, 3，...）倍一些基本单位字节数的块，但也存在其他类型（例如，斐波那契分割 - 你能看出为什么它被命名了吗？）。基本概念很简单：如果没有大小为 2^n 的空闲块，就转到下一个级别并窃取该块并将其分成两个。如果两个相邻的相同大小的块变为未分配状态，则它们可以合并成一个两倍大小的单个大块。

伙伴分配器之所以快速，是因为可以从释放的块的地址计算出要合并的相邻块，而不是遍历大小标签。最终的性能通常需要少量的汇编代码来使用专门的 CPU 指令来找到最低的非零位。

伙伴分配器的主要缺点是它们受到*内部碎片*的影响，因为分配被舍入到最近的块大小。例如，68 字节的分配将需要一个 128 字节的块。

### 进一步阅读和参考资料

+   参见[软件技术和理论计算机科学基础 1999 年会议论文集](http://books.google.com/books?id=0uHME7EfjQEC&lpg=PP1&pg=PA85#v=onepage&q&f=false)（Google 图书，第 85 页）

+   UIUC 讲座幻灯片（[pptx](https://subversion.ews.illinois.edu/svn/sp17-cs241/_shared/wikifiles/CS241-05-ThanksForTheMemorySlides.pptx)）（[pdf](https://subversion.ews.illinois.edu/svn/sp17-cs241/_shared/wikifiles/CS241-05-ThanksForTheMemorySlides.pdf)）和

+   [维基百科的伙伴内存分配页面](http://en.wikipedia.org/wiki/Buddy_memory_allocation)

## 其他分配器

有许多其他分配方案。例如[SLUB](http://en.wikipedia.org/wiki/SLUB_%28software%29)（维基百科）- Linux 内核内部使用的三种分配器之一。
