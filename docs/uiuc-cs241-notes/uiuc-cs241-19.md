# 进程复习问题

## 主题

+   正确使用 fork、exec 和 waitpid

+   使用带有路径的 exec

+   理解 fork、exec 和 waitpid 的作用。例如，如何使用它们的返回值。

+   SIGKILL 与 SIGSTOP 与 SIGINT。

+   按下 CTRL-C 时发送了什么信号？

+   从 shell 或 kill POSIX 调用使用 kill。

+   进程内存隔离。

+   进程内存布局（堆在哪里，栈等；无效的内存地址）。

+   什么是 fork 炸弹、僵尸进程和孤儿进程？如何创建/删除它们。

+   getpid 与 getppid

+   如何使用 WAIT 退出状态宏 WIFEXITED 等。

## 问题/练习

+   带有 p 和不带 p 的 execs 有什么区别？操作系统是什么？

+   如何将命令行参数传递给`execl*`？`execv*`呢？按照惯例，第一个命令行参数应该是什么？

+   如何知道`exec`或`fork`失败了？

+   传递给 wait 的`int *status`指针是什么？wait 何时失败？

+   `SIGKILL`、`SIGSTOP`、`SIGCONT`、`SIGINT`之间有哪些区别？默认行为是什么？哪些可以设置信号处理程序？

+   按下`CTRL-C`时发送了什么信号？

+   我的终端锚定在 PID = 1337，并且刚刚变得无响应。给我写一个终端命令和 C 代码，向其发送`SIGQUIT`。

+   一个进程能否通过正常手段改变另一个进程的内存？为什么？

+   堆、栈、数据和文本段在哪里？哪些段可以写入？无效的内存地址是什么？

+   用 C 语言编写一个 fork 炸弹（请不要运行它）。

+   什么是孤儿进程？它如何变成僵尸进程？如何成为一个好的父进程？

+   当父母告诉你不能做某事时，你是不是很讨厌？给我写一个程序，向你的父进程发送`SIGSTOP`。

+   编写一个 fork exec 等待可执行文件的函数，并使用等待宏告诉我进程是否正常退出或被信号中断。如果进程正常退出，则打印返回值。如果不是，则打印导致进程终止的信号编号。
