# 文件，第一部分：处理文件

## 两种类型的文件

在 Linux 上，有两种文件抽象。第一种是 Linux 的`fd`级别抽象，这意味着你可以使用

+   `打开`

+   `读`

+   `写`

+   `关闭`

+   `lseek`

+   `fcntl` ...

等等。Linux 接口非常强大和富有表现力，但有时我们需要可移植性（例如，如果我们在为 Mac 或 Windows 编写代码）。这就是 C 的抽象发挥作用的地方。在不同的操作系统上，C 使用低级函数来创建一个文件的包装器，你可以在任何地方使用，这意味着 Linux 上的 C 使用上述调用。C 有以下几种

+   `fopen`

+   `fread`或`fgetc/fgets`或`fscanf`

+   `fwrite`或`fprintf`

+   `fclose`

+   `fflush`

但你无法获得 Linux 通过系统调用给你的表达能力，你可以在它们之间进行转换，使用`int fileno(FILE* stream)`和`FILE* fdopen(int fd...)`。

另一个重要的方面要注意的是 C 文件是**缓冲的**，这意味着它们的内容可能不会立即被写入。你可以通过 C 选项来改变这一点。

## 我怎么知道文件有多大？

对于小于 long 的大小的文件，使用 fseek 和 ftell 是一种简单的方法来实现这一点：

移动到文件的末尾并找出当前位置。

```cpp
fseek(f, 0, SEEK_END);
long pos = ftell(f);
```

这告诉我们文件中的当前位置，以字节为单位 - 即文件的长度！

`fseek`也可以用来设置绝对位置。

```cpp
fseek(f, 0, SEEK_SET); // Move to the start of the file 
fseek(f, posn, SEEK_SET);  // Move to 'posn' in the file.
```

所有父进程或子进程中的未来读写操作都将遵守这个位置。请注意，从文件中写入或读取将改变当前位置。

查看 fseek 和 ftell 的 man 页面以获取更多信息。

## 但尽量不要这样做

**注意：这在通常情况下是不推荐的，因为 C 语言有一个怪癖**。这个怪癖是 long 只需要**4 个字节**大，这意味着 ftell 能返回的最大大小略小于 2GB（而我们现在知道我们的文件可能是数百 GB 甚至分布式文件系统上的 TB）。我们应该怎么办呢？使用`stat`！我们将在后面的部分介绍 stat，但这里有一些代码可以告诉你文件的大小

```cpp
struct stat buf;
if(stat(filename, &buf) != -1){
    return -1;
}
return (ssize_t)buf.st_size;
```

buf.st_size 的类型是 off_t，对于*极大*的文件来说足够大。

## 如果子进程使用`fclose`或`close`关闭文件流会发生什么？

关闭文件流对每个进程都是独特的。其他进程可以继续使用自己的文件句柄。记住，当创建一个子进程时，甚至文件的相对位置也会被复制过去。

## 文件的 mmap 怎么样？

mmap 的一个常见用途是将文件映射到内存。这并不意味着文件会立即被 malloc 到内存中。以下面的代码为例。

```cpp
int fd = open(...); //File is 2 Pages
char* addr = mmap(..fd..);
addr[0] = 'l'; 
```

内核可能会说：“好的，我看到你想要将文件映射到内存中，所以我将在你的地址空间中保留一些文件长度的空间”。这意味着当你写入 addr[0]时，实际上是在文件的第一个字节上写入。内核实际上也可以进行一些优化。它可能一次只加载一页，因为如果文件有 1024 页；你可能只访问 3 或 4 页，这样加载整个文件就是浪费时间（这就是为什么页面错误是如此强大的原因！它们让操作系统控制你使用文件的程度）。

## 对于每个 mmap

记住，一旦你完成了`mmap`，你需要`munmap`告诉操作系统你不再使用分配的页面，这样操作系统可以将它写回磁盘，并在以后需要 malloc 时将地址还给你。
