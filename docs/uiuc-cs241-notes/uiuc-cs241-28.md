# Pthreads，第三部分：并行问题（奖励）

## 概述

下一节将讨论当 pthread 发生冲突时会发生什么，但如果每个线程做的事情完全不同，没有重叠呢？

我们找到了最大加速并行问题吗？

## 尴尬的并行问题

并行算法的研究在过去几年里迅速发展。一个尴尬的并行问题是指需要很少的工作就可以转换为并行的问题。其中很多问题都涉及一些同步概念，但并非总是如此。你已经知道一个可并行化的算法，归并排序！

```cpp
void merge_sort(int *arr, size_t len){
     if(len > 1){
     //Mergesort the left half
     //Mergesort the right half
     //Merge the two halves
     }
```

有了对线程的新理解，你只需要为左半部分创建一个线程，为右半部分创建一个线程。鉴于你的 CPU 有多个真实核心，你将看到与[Amdahl's Law](https://en.wikipedia.org/wiki/Amdahl's_law)相符的加速。时间复杂度分析在这里也变得有趣。并行算法的运行时间为 O(log^3(n))（因为我们假设有很多核心）。

然而在实践中，我们通常会做两个改变。一是，一旦数组变得足够小，我们就会放弃并行归并排序算法，转而使用快速排序或其他在小数组上运行快速的算法（某种缓存一致性）。另一件我们知道的事情是，CPU 并不拥有无限的核心。为了解决这个问题，我们通常会保留一个工作池。

## 工作池

我们知道 CPU 的核心数量是有限的。很多时候我们会启动一些线程，并在它们空闲时给它们任务。

## 另一个问题，Parallel Map

假设我们想要对整个数组应用一个函数，一次处理一个元素。

```cpp
int *map(int (*func)(int), int *arr, size_t len){
    int *ret = malloc(len*sizeof(*arr));
    for(size_t i = 0; i < len; ++i) 
        ret[i] = func(arr[i]);
    return ret;
}
```

由于没有任何元素依赖于其他元素，你会如何并行化这个问题？你认为在线程之间如何分配工作最好？

## 调度

有几种方法可以分解工作。

+   静态调度：将问题分解成固定大小的块（预先确定的），并让每个线程处理其中的每个块。当每个子问题花费的时间大致相同时，这种方法效果很好，因为没有额外的开销。你只需要编写一个循环，并将 map 函数分配给每个子数组。

+   动态调度：当一个新问题可用时，让一个线程处理它。当你不知道调度需要多长时间时，这是很有用的。

+   引导调度：这是上述两种方法的混合，具有各自的优点和权衡。你可以从静态调度开始，如果需要的话慢慢转向动态调度。

+   运行时调度：你完全不知道问题需要多长时间。与其自己决定，不如让程序决定该做什么！

[来源](https://software.intel.com/en-us/articles/openmp-loop-scheduling)，但不需要记住。

## 一些缺点

你不会立即看到加速，因为缓存一致性和调度额外的线程等原因。

## 其他问题

从[Wikipedia](https://en.wikipedia.org/wiki/Embarrassingly_parallel)

+   在 Web 服务器上为多个用户提供静态文件。

+   曼德勃罗集、Perlin 噪声和类似的图像，其中每个点都是独立计算的。

+   计算机图形的渲染。在计算机动画中，每一帧可能是独立渲染的（参见并行渲染）。

+   在密码学中的暴力搜索。值得注意的现实世界例子包括 distributed.net 和加密货币中使用的工作证明系统。

+   生物信息学中用于多个查询的 BLAST 搜索（但不适用于单个大查询）[9]

+   大规模人脸识别系统将数千个任意获取的人脸（例如，通过闭路电视的安全或监控视频）与同样大量的先前存储的人脸（例如，罪犯库或类似的观察名单）进行比较。

+   比较许多独立场景的计算机模拟，例如气候模型。

+   进化计算元启发式，如遗传算法。

+   数值天气预报的集合计算。

+   粒子物理中的事件模拟和重建。

+   Marching squares 算法

+   二次筛和数域筛的筛选步骤。

+   随机森林机器学习技术中的树生长步骤。

+   离散傅立叶变换，其中每个谐波都是独立计算的。
