# 调度，第一部分：调度进程

## 考虑调度。

[CPU 调度](https://en.wikipedia.org/wiki/Scheduling_(computing))是有效地选择要在系统 CPU 核心上运行的进程的问题。在繁忙的系统中，准备运行的进程将比 CPU 核心多，因此系统内核必须评估应该调度哪些进程在 CPU 上运行，以及应该将哪些进程放在就绪队列中以便稍后执行。

多线程和多 CPU 核心的额外复杂性被认为是对这个初始阐述的干扰，因此在这里被忽略。

对于非母语的人来说，另一个需要注意的是“时间”一词的双重含义：单词“时间”可以在时钟和经过的持续时间上下文中使用。例如，“第一个进程的到达时间是上午 9:00。”和“算法的运行时间为 3 秒。”

## 调度如何衡量，哪种调度程序最好？

调度影响系统的性能，特别是系统的延迟和吞吐量。吞吐量可以通过系统值来衡量，例如 I/O 吞吐量-每秒写入的字节数，或者每单位时间可以完成的小进程数量，或者使用更高级的抽象，例如每分钟处理的客户记录数量。延迟可以通过响应时间（进程开始发送响应之前的经过时间）或等待时间或周转时间（完成任务所经过的时间）来衡量。不同的调度程序提供不同的优化权衡，可能适用于所需的使用-并非所有可能的环境和目标都有最佳的调度程序。例如，“最短作业优先”将最小化所有作业的总等待时间，但在交互（UI）环境中，最好是最小化响应时间（以牺牲一些吞吐量），而 FCFS 似乎直观公平且易于实现，但受到车队效应的影响。

## 到达时间是什么？

进程首次到达就绪队列并准备开始执行的时间。如果 CPU 空闲，到达时间也将是执行的开始时间。

## 什么是抢占？

没有抢占，进程将运行，直到无法再利用 CPU。例如，以下条件将从 CPU 中移除进程，并使 CPU 可供其他进程调度：进程因信号终止，被阻塞等待并发原语，或正常退出。因此，一旦进程被调度，即使另一个具有较高优先级（例如更短的作业）的进程出现在就绪队列上，它也将继续运行。

通过抢占，如果就绪队列中添加了一个更可取的进程，现有进程可能会立即被移除。例如，假设在 t=0 时，使用最短作业优先调度程序有两个进程（P1 P2），执行时间分别为 10 和 20 毫秒。P1 被调度。P1 立即创建一个新的进程 P3，执行时间为 5 毫秒，将其添加到就绪队列。如果没有抢占，P3 将在 10 毫秒后运行（在 P1 完成后）。有了抢占，P1 将立即从 CPU 中驱逐，并放回就绪队列，CPU 将执行 P3。

## 哪些调度程序会导致饥饿？

任何使用优先级形式的调度程序都可能导致饥饿，因为较早的进程可能永远不会被调度运行（分配 CPU）。例如，使用 SJF，如果系统继续有许多短作业要调度，较长的作业可能永远不会被调度。这一切取决于调度程序的类型。

## 为什么进程（或线程）会被放置在就绪队列上？

当进程能够使用 CPU 时，进程将被放置在就绪队列上。一些例子包括：

+   进程被阻塞等待存储或套接字的“读”完成，现在数据可用。

+   一个新进程已经创建并准备好开始。

+   一个进程线程被阻塞在同步原语（条件变量、信号量、互斥锁）上，但现在可以继续。

+   一个进程被阻塞，等待系统调用完成，但已经传递了一个信号，信号处理程序需要运行。

考虑线程时可以生成类似的例子。

## 效率的度量

`开始时间`是进程的挂钟开始时间（CPU 开始处理它）`结束时间`是进程的结束挂钟（CPU 完成进程）`运行时间`是所需的 CPU 时间总量`到达时间`是进程进入调度程序的时间（CPU 可能不开始处理它）

## 什么是“周转时间”？

从进程到达到结束的总时间。

`周转时间=结束时间-到达时间`

## 什么是“响应时间”？

从进程到达到 CPU 实际开始处理它所需的总延迟（时间）。

`响应时间=开始时间-到达时间`

## 什么是“等待时间”？

等待时间是*总*等待时间，即进程在就绪队列上的总时间。一个常见的错误是认为它只是在就绪队列中的初始等待时间。

如果一个不进行 I/O 的 CPU 密集型进程需要 7 分钟的 CPU 时间才能完成，但需要 9 分钟的挂钟时间才能完成，我们可以得出结论，它在就绪队列中等待了 2 分钟。在这 2 分钟内，进程准备好运行，但没有分配 CPU。作业等待的时间是 2 分钟，无论作业等待的时间是什么时候。

`等待时间=（结束时间-到达时间）-运行时间`

## 什么是车队效应？

“车队效应是指 I/O 密集型进程不断积压，等待占用 CPU 的 CPU 密集型进程。这导致 I/O 性能不佳，即使对于 CPU 需求很小的进程也是如此。”

假设 CPU 当前被分配给一个 CPU 密集型任务，并且有一组 I/O 密集型进程在就绪队列中。这些进程只需要很少的 CPU 时间，但它们无法继续进行，因为它们正在等待 CPU 密集型任务从处理器中移除。这些进程会饿死，直到 CPU 绑定的进程释放 CPU。但 CPU 很少会被释放（例如，在 FCFS 调度程序的情况下，我们必须等到进程因 I/O 请求而被阻塞）。I/O 密集型进程现在可以满足它们的 CPU 需求，因为它们的 CPU 需求很小，而 CPU 又被分配给 CPU 密集型进程。因此，整个系统的 I/O 性能会因所有进程的 CPU 需求饥饿而受到间接影响。

这种效应通常在 FCFS 调度程序的情况下讨论，但是循环调度程序也可能出现长时间量的车队效应。

## Linux 调度

截至 2016 年 2 月，Linux 默认使用*完全公平调度程序*进行 CPU 调度，使用 I/O 调度的“BFQ”进行预算公平调度。适当的调度对吞吐量和延迟有重大影响。延迟对交互式和软实时应用程序特别重要，例如音频和视频流。有关更多信息，请参见此处的讨论和比较基准[[`lkml.org/lkml/2014/5/27/314`](https://lkml.org/lkml/2014/5/27/314)]。

这是 CFS 的调度方式

+   CPU 使用进程的虚拟运行时间（运行时间/优先级值）和睡眠公平性（如果进程正在等待某些东西，当它完成等待时给它 CPU）创建红黑树。

+   （优先级值是内核给予某些进程优先级的方式，值越低，优先级越高）

+   内核根据此度量选择最低的度量，并安排该进程作为下一个运行，将其从队列中移除。由于红黑树是自平衡的，此操作保证为$O(log(n))$（选择最小进程是相同的运行时间）

尽管它被称为公平调度器，但存在相当多的问题。

+   被调度的进程组可能负载不平衡，因此调度器会大致分配负载。当另一个 CPU 空闲时，它只能查看组调度的平均负载，而不是单独的核心。因此，只要平均负载正常，空闲的 CPU 可能不会接手一个长时间运行的 CPU 的工作。

+   如果一组进程在非相邻的核心上运行，那么就会出现问题。如果两个核心的距离超过一个跳跃，负载平衡算法甚至不会考虑那个核心。这意味着如果一个 CPU 空闲，而另一个 CPU 的工作量超过一个跳跃的距离，它不会接手这个工作（可能已经修复）。

+   线程在一组核心上休眠后，醒来时只能在它休眠的核心上被调度。如果这些核心现在很忙，那么就会出现问题。
