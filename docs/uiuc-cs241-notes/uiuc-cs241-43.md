# 死锁，第三部分：餐桌上的哲学家

## 背景故事

![](img/c17a56237998885b1dd4cd23e86f4c90.jpg)

所以你的哲学家们围坐在桌子周围，都想吃点意大利面（或者其他什么），他们真的很饿。每个哲学家本质上都是一样的，这意味着每个哲学家都有相同的指令集，基于其他哲学家，也就是说你不能让每个偶数哲学家做一件事，每个奇数哲学家做另一件事。

## 失败的解决方案

## 左右死锁

我们该怎么办？让我们尝试一个简单的解决方案

```cpp
void* philosopher(void* forks){
     info phil_info = forks;
     pthread_mutex_t* left_fork = phil_info->left_fork;
     pthread_mutex_t* right_fork = phil_info->right_fork;
     while(phil_info->simulation){
          pthread_mutex_lock(left_fork);
          pthread_mutex_lock(right_fork);
          eat(left_fork, right_fork);
          pthread_mutex_unlock(left_fork);
          pthread_mutex_unlock(right_fork);
     }
}
```

但是这会遇到一个问题！如果每个人都拿起他们的左手叉子，正在等待他们的右手叉子呢？我们已经死锁了程序。重要的是要注意，死锁并不总是发生，而且这个解决方案死锁的概率随着哲学家的数量增加而降低。真正重要的是，最终这个解决方案会死锁，让线程挨饿，这是不好的。

## Trylock？更像是活锁

所以现在你在考虑打破柯夫曼条件之一。我们有

+   互斥

+   没有抢占

+   持有并等待

+   循环等待

嗯，我们不能让两个哲学家同时使用一个叉子，互斥被排除在外。在我们当前的简单模型中，我们不能让哲学家一旦拿到互斥锁就放开它，所以我们现在就排除这个解决方案——关于这个解决方案有一些注释在页面底部。让我们打破持有并等待！

```cpp
void* philosopher(void* forks){
     info phil_info = forks;
     pthread_mutex_t* left_fork = phil_info->left_fork;
     pthread_mutex_t* right_fork = phil_info->right_fork;
     while(phil_info->simulation){
          pthread_mutex_lock(left_fork);
          int failed = pthread_mutex_trylock(right_fork);
          if(!failed){
               eat(left_fork, right_fork);
               pthread_mutex_unlock(right_fork);
          }
          pthread_mutex_unlock(left_fork);
     }
}
```

现在我们的哲学家拿起左边的叉子，试图抓住右边的叉子。如果右边的叉子可用，他们就吃。如果不可用，他们放下左边的叉子再试一次。没有死锁！

但是，有一个问题。如果所有的哲学家同时拿起他们的左手，试图抓住他们的右手，放下他们的左手，再拿起他们的左手，试图抓住他们的右手……我们现在活锁了我们的解决方案！我们可怜的哲学家们仍然饿着，所以让我们给他们一些合适的解决方案。

## 可行的解决方案

## 仲裁者（天真和高级）。

天真的仲裁者解决方案是有一个仲裁者（例如一个互斥锁）。让每个哲学家请求仲裁者的许可来吃饭。这个解决方案一次只允许一个哲学家吃饭。当他们吃完后，另一个哲学家可以请求吃饭的许可。

这可以防止死锁，因为没有循环等待！没有哲学家需要等待其他哲学家。

高级仲裁者解决方案是实现一个类，确定哲学家的叉子是否在仲裁者的控制下。如果是，他们把叉子给哲学家，让他吃，然后拿回叉子。这有一个额外的好处，就是能够让多个哲学家同时吃饭。

### 问题：

+   这些解决方案很慢

+   他们有一个单一的故障点，仲裁者使其成为一个瓶颈

+   仲裁者在第二个解决方案中也需要公平，并且能够确定死锁

+   在实际系统中，仲裁者倾向于重复地将叉子交给刚刚吃过的哲学家，因为进程调度

## 离开桌子（Stallings 的解决方案）

为什么第一个解决方案会死锁？嗯，有 n 个哲学家和 n 根筷子。如果桌子上只有 1 个哲学家怎么办？我们会死锁吗？不会。

2 个哲学家怎么样？3 个？……你可以看出这是怎么回事。Stallings 的解决方案是从桌子上移除哲学家，直到死锁不可能发生——想想桌子上的哲学家的魔数是多少。在实际系统中，通过信号量来实现这一点，并让一定数量的哲学家通过。

### 问题：

+   解决方案需要大量的上下文切换，这对 CPU 来说非常昂贵

+   你需要提前知道资源的数量，以便只让那么多的哲学家

+   再次优先考虑那些已经吃过的进程。

## 部分排序（Dijkstra 的解决方案）

这是 Dijkstra 的解决方案（他是在考试中提出这个问题的人）。为什么第一个解决方案会死锁？Dijkstra 认为最后一个拿起他左边叉子的哲学家（导致解决方案死锁）应该拿起他的右边叉子。他通过给叉子编号 1..n，并告诉每个哲学家拿起他较小编号的叉子来实现这一点。

让我们再次运行死锁条件。每个人都试图先拿起他们较小编号的叉子。哲学家 1 拿到叉子 1，哲学家 2 拿到叉子 2，依此类推，直到我们到达哲学家 n。他们必须在叉子 1 和 n 之间做出选择。叉子 1 已经被哲学家 1 拿起，所以他们不能拿起那个叉子，这意味着他不会拿起叉子 n。我们打破了循环等待！这意味着死锁是不可能的。

### 问题：

+   哲学家在抓取任何资源之前需要知道资源的集合顺序。

+   您需要为所有资源定义一个偏序。

+   优先考虑已经吃过饭的哲学家。

## 高级解决方案

还有许多更高级的解决方案，非穷尽列表包括

+   干净/脏叉子（钱德拉/米斯拉解决方案）

+   演员模型（其他消息传递模型）

+   超级仲裁者（复杂的管道）
