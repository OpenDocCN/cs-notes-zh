# 教堂数（续）星期二，二月二十一日

现在我们可以定义自然数加法 — 一个简单的想法是得到两个编码数字 `m` 和 `n`，然后从 `x` 开始，通过将它用作函数，在结果上应用 `n` 次 `f`，然后以相同的方式在结果上再应用 `m` 次 `f`：

```
(define + (lambda (m n) (lambda (f x) (m f (n f x)))))
```

或等价地：

```
(define + (lambda (m n f x) (m f (n f x))))
```

另一个想法是使用 `add1` 并使用 `add1` 将 `n` 增加 `m`：

```
(define + (lambda (m n) (m add1 n)))(->nat (+ 4 5))
```

我们也可以很容易地定义 `m` 和 `n` 的乘法 — 从加法开始 — `(lambda (x) (+ n x))` 是一个期望 `x` 并返回 `(+ x n)` 的函数 — 这是一个增量 `n` 的函数。但由于所有函数和应用都是柯里化的，这实际上与 `(lambda (x) ((+ n) x))` 相同，这与 `(+ n)` 相同。现在，我们要做的是将此操作重复 `m` 次在零上，这将零加 `n` `m` 次，结果为 `m` * `n`。因此，定义是：

```
(define * (lambda (m n) (m (+ n) 0)))(->nat (* 4 5))(->nat (+ 4 (* (+ 2 5) 5)))
```

另一种方法是考虑

```
(lambda (x) (n f x))
```

对于某个编码数字 `n` 和一个函数 `f` — 这个函数就像 `f`^`n`（f 自己与自己组合 n 次）。但请记住，这只是简写形式

```
(lambda (x) ((n f) x))
```

我们知道 `(lambda (x) (foo x))` 就像 `foo`（如果它是一个函数），所以这等价于

```
(n f)
```

因此 `(n f)` 是 `f`^`n`，以相同的方式 `(m g)` 是 `g`^`m` — 如果我们将 `(n f)` 用于 `g`，我们得到 `(m (n f))`，这是 `f` 的 n 次自组合，自组合 m 次。换句话说，`(m (n f))` 是一个类似于 `f` 的 `m`*`n` 次应用的函数，因此我们可以将乘法定义为：

```
(define * (lambda (m n) (lambda (f) (m (n f)))))
```

这与之相同

```
(define * (lambda (m n f) (m (n f))))
```

相同的原理可以用来定义指数（但现在我们必须注意顺序，因为指数不是可交换的）：

```
(define ^ (lambda (m n) (n (* m) 1)))(->nat (^ 3 4))
```

这里也有一个类似的替代方案 —

+   教堂数 `m` 是 m-自组合函数，

+   而 `(1 m)` 就像 `m`^`1`，与 `m` 相同（`1`=`identity`）

+   而 `(2 m)` 就像 `m`^`2` — 它接受一个函数 `f`，自我组合 `m` 次，然后将结果再自我组合 `m` 次 — 总共 `f`^`(m*m)`

+   而 `(3 m)` 类似于 `f`^`(m*m*m)`

+   因此 `(n m)` 是 `f`^`(m^n)`（注意第一个 `^` 是自组合，第二个是数学上的指数）

+   因此，`(n m)` 是一个返回输入函数的 `m`^`n` 自组合的函数，这意味着 `(n m)` 是 `m`^`n` 的教堂数，因此我们得到：

    (define ^ (lambda (m n) (n m)))

这基本上是说任何编码数字 `n` 也是 `?`^`n` 运算。

所有这些都不是太复杂的事情 — 但到目前为止我们所做的一切都是以各种方式编写增加其输入的函数。`sub1` 呢？为此，我们需要做更多的工作 — 我们需要编码布尔值。
