# 变量突变星期二，2 月 28 日

> PLAI §12 和 PLAI §13（不同之处：向语言添加盒��）
> 
> PLAI §14（这就是我们所做的）

我们现在的代码通过*改变*绑定来实现递归，为了使这成为可能，我们让环境为所有绑定保存盒子，因此现在所有的绑定都是可变的。我们可以利用这一点为我们的求值器添加更多功能，通过允许更改任何变量 — 我们可以添加一个`set!`形式：

```
{set! <id> <FLANG>}
```

给评估器，它将修改变量的值。要实现这个功能，我们只需要使用`lookup`来检索一些盒子，然后评估表达式并将结果放入该盒子中。实际的实现留作家庭作业。

这里需要考虑的一件事是 — 我们语言中的所有表达式都会求值为某个值，问题是`set!`表达式的值应该是什么？有三个明显的选择：

1.  返回一些虚假值，

1.  返回被分配的值，

1.  返回之前在盒子中的值。

这些中的每一个都有自己的优势 — 例如，C 使用第二个选项来`chain`赋值（例如，`x = y = 0`）并允许副作用在期望表达式的地方发生（例如，`while (x = x-1) ...`）。

第三种情况在你可能会使用被覆盖的旧值的情况下很有用 — 例如，如果 C 有这种行为，你可以使用类似以下方式从链表中`pop`一个值：

```
first(l = rest(l));
```

因为`first`的参数将是`l`的旧值，在它变为其`rest`之前。你也可以在单个表达式中交换两个变量：`x = y = x`。

（请注意，当使用选项（2）时，表达式`x = x + 1`的含义等同于 C 的`++x`，而当使用选项（3）时，则等同于`x++`。）

Racket 选择第一个选项，在我们的语言中我们也会这样做。这里的优势是你不会得到折扣，因此在没有明显选择的情况下，你必须明确指出你想要返回的值。这会导致更健壮的程序，因为你不会有其他程序员依赖于你没有计划的代码特性。

无论如何，引入突变的修改很小，但对我们的语言有巨大影响：对 Racket 是真的，对 FLANG 也是真的。我们已经看到突变如何影响我们使用的语言子集，在我们的 FLANG 扩展中，这种影响甚至更强烈：因为*任何*变量都可以改变（不需要显式的`box`值）。换句话说，一个绑定并不总是相同的 — 它可以因为`set!`表达式的结果而改变。当然，我们可以使用盒子扩展我们的语言（使用 Racket 盒子来实现 FLANG 盒子），但那会更加冗长。

> 请注意，Racket 确实有一个`set!`形式，此外，结构体中的字段可以被修改。然而，我们目前并没有使用这些。至少目前还没有。
