# 尾调用

通常你应该知道什么是尾调用，但这里是对这个主题的快速回顾。如果在调用时没有“记住”的上下文，那么函数调用被称为处于尾位置。非常粗略地说，这意味着不嵌套在另一个调用的参数表达式中的函数调用是尾调用。这个定义取决于上下文，例如，在一个表达式中

```
(if (huh?)  (foo (add1 (* x 3)))  (foo (/ x 2)))
```

两个对`foo`的调用都是尾调用，但它们是*这个*表达式的尾调用，因此适用于*这个*上下文。可能这段代码是在另一个调用内部，如

```
(blah (if (huh?)        (foo (add1 (* x 3)))        (foo (/ x 2)))      something-else)
```

而`foo`调用现在不在尾位置。所有 Scheme 实现包括 Racket 在尾调用方面的主要特点是处于函数尾位置的调用被称为“消除”。这意味着如果我们在一个`f`函数中，并且我们即将在尾位置调用`g`，因此`g`返回的任何东西也将是`f`的结果，那么当 Racket 调用`g`时，它不会保留`f`的上下文 — 它不会记住它需要“返回”到`f`，而是直接返回给它的调用者。换句话说，当你考虑函数调用的传统实现为堆栈上的帧时，Racket 会在可以的时候摆脱一个堆栈帧。

通过使用 DrRacket 的 stepper 来逐步执行函数调用，可以另一种方式来看待这个问题。Stepper 通常是一种替代性调试器，它不是可视化堆栈帧，而是组装一个表示这些帧的表达式。现在，在尾调用的情况下，在这样的表示中没有空间来保留调用 — 而事实是，在 Racket 中这是完全可以的，因为这些调用不会保存在调用堆栈中。

请注意，这个特性有几个名称：

+   “尾递归”。这是一个常见的方式来指代*仅*将尾递归函数优化为循环的更有限的优化。在具有尾调用作为特性的语言中，这太有限了，因为它们还优化了互相递归的情况，或者任何尾调用的情况。

+   “尾调用优化”。在一些语言或更具体地说在一些编译器中，你会听到这个术语。当尾调用被认为只是一种“优化”时，这是可以接受的 — 但在 Racket（以及 Scheme）的情况下，它不仅仅是一种优化：它是一个*语言特性*，你可以依赖它。例如，像`(define (loop) (loop))`这样的尾递归函数 *必须* 作为一个无限循环运行，而不仅仅是在编译器认为需要优化为一个循环时。

+   “尾调用消除”。这是迄今为止这个特性最常见的正确名称：它不仅仅是递归，也不是一种优化。

### 何时应该使用尾调用？

通常，了解尾调用的人们会尝试*始终*使用它们。这并不总是一个好主意。在考虑使用哪种风格时，你通常应该意识到其中的权衡。要记住的主要事情是，尾调用消除是一种有助于减少*空间*使用（栈空间）的属性——通常将其从线性空间减少到常数空间。这显然可以加快速度，但通常加速只是一个常数因子，因为无论如何你都需要做相同数量的迭代，所以你只是减少了在空间分配上花费的时间。

这里有一个我们见过的例子：

```
(define (list-length-1 list)  (if (null? list)    0    (+ 1 (list-length-1 (rest list)))));; versus(define (list-length-helper list len)  (if (null? list)    len    (list-length-helper (rest list) (+ len 1))))(define (list-length-2 list)  (list-length-helper list 0))
```

在这种情况下，第一个（递归）版本消耗的空间与列表的长度成线性关系，而第二个版本只需要常数空间。但是，如果仅考虑渐近运行时间，它们都是 O（length（l））。

第二个例子是`map`的简单实现：

```
(define (map-1 f l)  (if (null? l) l (cons (f (first l)) (map-1 f (rest l)))));; versus(define (map-helper f l acc)  (if (null? l)    (reverse acc)    (map-helper f (rest l) (cons (f (first l)) acc))))(define (map-2 f l)  (map-helper f l '()))
```

在这种情况下，渐近空间和运行时消耗都是相同的。在递归情况下，我们对栈空间有一个常数因子，而在迭代情况下（尾调用版本），我们也有一个类似的因子用于累积反转列表。在这种情况下，最好保留第一个版本，因为代码更简单。事实上，Racket 的栈空间管理可以使第一个版本运行速度比第二个版本更快，因此将其优化为第二个版本是没有用的。
