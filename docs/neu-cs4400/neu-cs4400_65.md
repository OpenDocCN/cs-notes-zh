# 玩具语言星期二，2 月 28 日

> 不在 PLAI 中

一个快速的提示：从现在开始，我们将使用我们语言的一个变体 —— 它将改变语法，看起来有点像 Racket，并且我们将使用 Racket 值来表示我们语言中的值，使用 Racket 函数来表示我们语言中的内置函数。

主要亮点：

+   函数参数和局部 `bind` 表单中可以有多个绑定 —— 名称必须是不同的。

+   现在有一些关键字像 `bind` 这样的关键字以特殊的方式解析。其他形式被视为函数应用，这意味着没有特殊的解析规则（和 AST 条目）用于算术函数。它们现在是全局环境中的绑定，并且与所有绑定一样处理。例如，`*` 是一个表达式，它求值为*原始*乘法函数，`{bind {{+ *}} {+ 2 3}}` 求值为 `6`。

+   由于原始函数和用户绑定函数现在的函数应用是相同的，所以不再需要 `call` 关键字。请注意，解析器的函数调用部分必须是最后的，因为它只应用于输入不是其他已知形式的情况。

+   注意使用 `make-untyped-list-function`：它是一个库函数（包含在课程语言中），可以将一些已知的 Racket 函数转换为一个函数，该函数消耗一个*任何* Racket 值的列表，并返回将给定的 Racket 函数应用于这些值的结果。例如：

    ```
    (define add (make-untyped-list-function +))(add (list 1 2 3 4))
    ```

    求值为 `10`。

+   这个的另一个重要方面是它的类型 —— 在前面的例子中，`add` 的类型是`(List -> Any)`，因此生成的函数可以消耗*任何*输入值。如果它得到一个坏值，它将抛出一个适当的错误。这是一个技巧：它基本上意味着生成的 `add` 函数具有非常通用的类型（只需要一个列表），因此错误可以在运行时抛出。然而，在这种情况下，一个更好的解决方案不会让这些运行时错误消失，因为我们正在实现的语言不是静态类型的。

+   这样做的好处是我们可以通过让这些函数动态检查输入值来避免更冗长的代码的麻烦，因此我们可以在 `VAL` 中使用一个 `RktV` 变体来包装任何 Racket 值。（否则我们需要为不同类型需要不同的包装器，并实现这些动态检查。）

以下是完整的实现。

```
▶#lang pl;;; ----------------------------------------------------------------;;; Syntax#| The BNF:   <TOY> ::= <num>           | <id>           | { bind {{ <id> <TOY> } ... } <TOY> }           | { fun { <id> ... } <TOY> }           | { if <TOY> <TOY> <TOY> }           | { <TOY> <TOY> ... }|#;; A matching abstract syntax tree datatype:(define-type TOY  [Num  Number]  [Id   Symbol]  [Bind (Listof Symbol) (Listof TOY) TOY]  [Fun  (Listof Symbol) TOY]  [Call TOY (Listof TOY)]  [If   TOY TOY TOY])(: unique-list? : (Listof Any) -> Boolean);; Tests whether a list is unique, guards Bind and Fun values.(define (unique-list? xs)  (or (null? xs)      (and (not (member (first xs) (rest xs)))           (unique-list? (rest xs)))))(: parse-sexpr : Sexpr -> TOY);; parses s-expressions into TOYs(define (parse-sexpr sexpr)  (match sexpr    [(number: n)    (Num n)]    [(symbol: name) (Id name)]    [(cons 'bind more)     (match sexpr       [(list 'bind (list (list (symbol: names) (sexpr: nameds))                          ...)          body)        (if (unique-list? names)          (Bind names (map parse-sexpr nameds) (parse-sexpr body))          (error 'parse-sexpr "duplicate `bind' names: ~s"                 names))]       [else (error 'parse-sexpr "bad `bind' syntax in ~s" sexpr)])]    [(cons 'fun more)     (match sexpr       [(list 'fun (list (symbol: names) ...) body)        (if (unique-list? names)          (Fun names (parse-sexpr body))          (error 'parse-sexpr "duplicate `fun' names: ~s" names))]       [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]    [(cons 'if more)     (match sexpr       [(list 'if cond then else)        (If (parse-sexpr cond)            (parse-sexpr then)            (parse-sexpr else))]       [else (error 'parse-sexpr "bad `if' syntax in ~s" sexpr)])]    [(list fun args ...) ; other lists are applications     (Call (parse-sexpr fun)           (map parse-sexpr args))]    [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))(: parse : String -> TOY);; Parses a string containing an TOY expression to a TOY AST.(define (parse str)  (parse-sexpr (string->sexpr str)));;; ----------------------------------------------------------------;;; Values and environments(define-type ENV  [EmptyEnv]  [FrameEnv FRAME ENV]);; a frame is an association list of names and values.(define-type FRAME = (Listof (List Symbol VAL)))(define-type VAL  [RktV  Any]  [FunV  (Listof Symbol) TOY ENV]  [PrimV ((Listof VAL) -> VAL)])(: extend : (Listof Symbol) (Listof VAL) ENV -> ENV);; extends an environment with a new frame.(define (extend names values env)  (if (= (length names) (length values))    (FrameEnv (map (lambda ([name : Symbol] [val : VAL])                     (list name val))                   names values)              env)    (error 'extend "arity mismatch for names: ~s" names)))(: lookup : Symbol ENV -> VAL);; lookup a symbol in an environment, frame by frame,;; return its value or throw an error if it isn't bound(define (lookup name env)  (cases env    [(EmptyEnv) (error 'lookup "no binding for ~s" name)]    [(FrameEnv frame rest)     (let ([cell (assq name frame)])       (if cell         (second cell)         (lookup name rest)))]))(: unwrap-rktv : VAL -> Any);; helper for `racket-func->prim-val': unwrap a RktV wrapper in;; preparation to be sent to the primitive function(define (unwrap-rktv x)  (cases x    [(RktV v) v]    [else (error 'racket-func "bad input: ~s" x)]))(: racket-func->prim-val : Function -> VAL);; converts a racket function to a primitive evaluator function;; which is a PrimV holding a ((Listof VAL) -> VAL) function.;; (the resulting function will use the list function as is,;; and it is the list function's responsibility to throw an error;; if it's given a bad number of arguments or bad input types.)(define (racket-func->prim-val racket-func)  (define list-func (make-untyped-list-function racket-func))  (PrimV (lambda (args)           (RktV (list-func (map unwrap-rktv args))))));; The global environment has a few primitives:(: global-environment : ENV)(define global-environment  (FrameEnv (list (list '+ (racket-func->prim-val +))                  (list '- (racket-func->prim-val -))                  (list '* (racket-func->prim-val *))                  (list '/ (racket-func->prim-val /))                  (list '< (racket-func->prim-val <))                  (list '> (racket-func->prim-val >))                  (list '= (racket-func->prim-val =))                  ;; values                  (list 'true  (RktV #t))                  (list 'false (RktV #f)))            (EmptyEnv)));;; ----------------------------------------------------------------;;; Evaluation(: eval : TOY ENV -> VAL);; evaluates TOY expressions.(define (eval expr env)  ;; convenient helper  (: eval* : TOY -> VAL)  (define (eval* expr) (eval expr env))  (cases expr    [(Num n)   (RktV n)]    [(Id name) (lookup name env)]    [(Bind names exprs bound-body)     (eval bound-body (extend names (map eval* exprs) env))]    [(Fun names bound-body)     (FunV names bound-body env)]    [(Call fun-expr arg-exprs)     (let ([fval (eval* fun-expr)]           [arg-vals (map eval* arg-exprs)])       (cases fval         [(PrimV proc) (proc arg-vals)]         [(FunV names body fun-env)          (eval body (extend names arg-vals fun-env))]         [else (error 'eval "function call with a non-function: ~s"                      fval)]))]    [(If cond-expr then-expr else-expr)     (eval* (if (cases (eval* cond-expr)                  [(RktV v) v] ; Racket value => use as boolean                  [else #t])   ; other values are always true              then-expr              else-expr))]))(: run : String -> Any);; evaluate a TOY program contained in a string(define (run str)  (let ([result (eval (parse str) global-environment)])    (cases result      [(RktV v) v]      [else (error 'run "evaluation returned a bad value: ~s"                   result)])));;; ----------------------------------------------------------------;;; Tests(test (run "{{fun {x} {+ x 1}} 4}")      => 5)(test (run "{bind {{add3 {fun {x} {+ x 3}}}} {add3 1}}")      => 4)(test (run "{bind {{add3 {fun {x} {+ x 3}}}                   {add1 {fun {x} {+ x 1}}}}              {bind {{x 3}} {add1 {add3 x}}}}")      => 7)(test (run "{bind {{identity {fun {x} x}}                   {foo {fun {x} {+ x 1}}}}              {{identity foo} 123}}")      => 124)(test (run "{bind {{x 3}}              {bind {{f {fun {y} {+ x y}}}}                {bind {{x 5}}                  {f 4}}}}")      => 7)(test (run "{{{fun {x} {x 1}}              {fun {x} {fun {y} {+ x y}}}}             123}")      => 124);; More tests for complete coverage(test (run "{bind x 5 x}")      =error> "bad `bind' syntax")(test (run "{fun x x}")         =error> "bad `fun' syntax")(test (run "{if x}")            =error> "bad `if' syntax")(test (run "{}")                =error> "bad syntax")(test (run "{bind {{x 5} {x 5}} x}") =error> "duplicate*bind*names")(test (run "{fun {x x} x}")     =error> "duplicate*fun*names")(test (run "{+ x 1}")           =error> "no binding for")(test (run "{+ 1 {fun {x} x}}") =error> "bad input")(test (run "{+ 1 {fun {x} x}}") =error> "bad input")(test (run "{1 2}")             =error> "with a non-function")(test (run "{{fun {x} x}}")     =error> "arity mismatch")(test (run "{if {< 4 5} 6 7}")  => 6)(test (run "{if {< 5 4} 6 7}")  => 7)(test (run "{if + 6 7}")        => 6)(test (run "{fun {x} x}")       =error> "returned a bad value");;; ----------------------------------------------------------------
```
