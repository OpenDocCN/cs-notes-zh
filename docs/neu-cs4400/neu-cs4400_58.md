# 方框和突变星期二，2 月 21 日

为了实际实现一个循环结构，我们现在将使用*副作用*，使用一种支持突变的新型 Racket 值：方框。方框值是用`box`构造器构建的：

```
(define my-thing (box 7))
```

值是通过`unbox`函数检索的，

```
(* 6 (unbox my-thing))
```

最后，值可以通过`set-box!`函数更改。

```
(set-box! my-thing 17)(* 6 (unbox my-thing))
```

需要注意的一件重要事情是，`set-box!`很像`display`等，它返回一个值，该值不会在 Racket REPL 中打印出来，因为使用`set-box!`的结果没有意义，它是因为生成的副作用而调用的。（像 C 这样的语言会模糊返回值和副作用之间的区别，它的赋值语句与此有关。）

作为一个旁注，我们现在有两种副作用：状态的变异，和 I/O（至少是输出部分）。（实际上，还有无限循环，可以看作是另一种形式的副作用。）这意味着我们现在处于一个完全不同的世界，现在很多新事物都变得有意义了。以下是一些你应该知道的事情：

+   我们从未在函数主体中使用多个表达式，因为这没有意义，但现在有了。要评估一系列 Racket 表达式，你将它们包装在一个`begin`表达式中。

+   在大多数地方，你实际上并不需要使用`begin`——这些地方被称为*隐式*的`begin`：函数的主体（或任何 lambda 表达式）、`let`的主体（以及`let`的相关内容）、`cond`、`match`和`cases`子句中的结果位置等等。一个常见的使用`begin`的地方是在`if`表达式中（当存在多个表达式时，有些人更喜欢使用`cond`）。

+   在结尾没有`else`的`cond`是有意义的，如果你只是用它来进行副作用的话。

+   `if`可以得到一个在条件为真时执行的单个表达式（否则使用未指定的值），但我们的语言（以及默认的 Racket 语言）总是禁止这样做——对于一个单边的`if`，有方便的特殊形式：`when`和`unless`，它们可以有任意数量的表达式（它们有一个隐式的`begin`）。它们有一个明显的优势，即更明确地表示“这里的代码进行了一些副作用”。

+   有一个称为`for-each`的函数，它与`map`完全相同，只是它不收集结果列表，仅用于执行副作用。

当任何一个这些东西被使用时（在 Racket 或其他语言中），你可以确定涉及到了副作用，因为否则它们就没有任何意义。此外，任何以`!`（“bang”）结尾的名称都用于标记改变状态的函数（通常是仅改变状态的函数）。

那么我们如何创建一个循环呢？简单，方框可以有任何值，并且它们可以放在其他值中，所以我们可以这样做：

```
#lang pl untyped(define foo (list 1 (box 3)))(set-box! (second foo) foo)
```

我们得到了一个循环值。（注意它是如何打印的。）并且具有类型：

```
#lang pl(: foo : (List Number (Boxof Any)))(define foo (list 1 (box 3)))(set-box! (second foo) foo)
```
