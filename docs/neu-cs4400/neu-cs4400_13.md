# 语义（=评估）Tuesday, January 17th

> PLAI §2

回到 BNF——现在，意义。

这些 BNF 规范的一个重要特性：我们可以使用推导来指定*含义*（在我们的上下文中，含义是“运行”程序（或“解释”，“编译”，但我们将使用“评估”））。例如：

```
<AE> ::= <num>         ; <AE> evaluates to the number       | <AE1> + <AE2> ; <AE> evaluates to the sum of evaluating                       ;      <AE1> and <AE2>       | <AE1> - <AE2> ; ... the subtraction of <AE2> from <AE1>                               (... roughly!)
```

为了稍微正式一些：

```
a. eval(<num>) = <num> ;*** special rule: translate syntax to valueb. eval(<AE1> + <AE2>) = eval(<AE1>) + eval(<AE2>)c. eval(<AE1> - <AE2>) = eval(<AE1>) - eval(<AE2>)
```

注意两个`+`和`-`的完全不同的角色。事实上，写成这样可能更正确：

```
a. eval("<num>") = <num>b. eval("<AE1> + <AE2>") = eval("<AE1>") + eval("<AE2>")c. eval("<AE1> - <AE2>") = eval("<AE1>") - eval("<AE2>")
```

甚至使用一个标记来表示这些字符串中的元占位符：

```
a. eval("$<num>") = <num>b. eval("$<AE1> + $<AE2>") = eval("$<AE1>") + eval("$<AE2>")c. eval("$<AE1> - $<AE2>") = eval("$<AE1>") - eval("$<AE2>")
```

但我们将避免假装我们正在做那种字符串操作。（例如，这将需要说明返回`<num>`代表什么（涉及`string->number`），右侧的片段表示我们需要将这些指定为子字符串操作。）

注意我们的 BNF 规范中存在类似的非正式性，在这些规范中，我们假设`<foo>`指的是某个终端或非终端。在需要更正式规范的文本中（例如，在 RFC 规范中），BNF 的每个文字部分通常都是双引号括起来的，所以我们会得到

```
<AE> ::= <num> | <AE1> "+" <AE2> | <AE1> "-" <AE2>
```

`eval(X)`的另一种流行符号是`[[X]]`：

```
a. [[<num>]] = <num>b. [[<AE1> + <AE2>]] = [[<AE1>]] + [[<AE2>]]c. [[<AE1> - <AE2>]] = [[<AE1>]] - [[<AE2>]]
```

这个定义有问题吗？歧义：

```
eval(1 - 2 + 3) = ?
```

根据表达式的解析方式，我们可以得到`2`或`-4`的结果：

```
eval(1 - 2 + 3) = eval(1 - 2) + eval(3)          [b]                = eval(1) - eval(2) + eval(3)    [c]                = 1 - 2 + 3                      [a,a,a]                = 2eval(1 - 2 + 3) = eval(1) - eval(2 + 3)          [c]                = eval(1) - (eval(2) + eval(3))  [a]                = 1 - (2 + 3)                    [a,a,a]                = -4
```

再次，要非常注意混淆的微妙之处，这些微妙之处非常重要：我们只需要在一个子表达式的一侧加括号，为什么？——当我们写：

```
eval(1 - 2 + 3) = ... = 1 - 2 + 3
```

我们有两个表达式，但一个代表*输入语法*，另一个代表真正的数学表达式。

在计算机实现的情况下，左侧的语法（像往常一样）是 AE 语法，右侧的实际表达式是我们用来实现 AE 语言的任何语言中的表达式。

正如我们之前所说，歧义直到实际解析树很重要才成为问题。对于`eval`来说，这绝对很重要，因此我们不能使得可能以多种方式推导出任何语法，否则我们的评估将是非确定性的。

* * *

快速练习：

我们可以类似地为`<digit>`s 和然后`<num>`s 定义一个意义：

```
<NUM> ::= <digit> | <digit> <NUM>eval(0) = 0eval(1) = 1eval(2) = 2...eval(9) = 9eval(<digit>) = <digit>eval(<digit> <NUM>) = 10*eval(<digit>) + eval(<NUM>)
```

这正是我们想要的吗？——取决于我们实际想要什么…

+   首先，这段代码有一个错误——有一个类似 BNF 的推导

    ```
    <NUM> ::= <digit> | <digit> <NUM>
    ```

    是无歧义的，但很难解析数字。我们得到：

    ```
     eval(123) = 10*eval(1) + eval(23)           = 10*1 + 10*eval(2) + eval(3)           = 10*1 + 10*2 + 3           = 33
    ```

    改变最后一个规则的顺序效果更好：

    ```
    <NUM> ::= <digit> | <NUM> <digit>
    ```

    然后：

    ```
    eval(<NUM> <digit>) = 10*eval(<NUM>) + eval(<digit>)
    ```

+   作为具体例子，看看如何使其与`107`配合使用，这说明了组合性的重要性。

+   免费东西的例子看起来微不足道：如果我们以这种方式定义数字的含义，它总是有效吗？想象一个不提供大数的平均语言，当数字太大时，上述规则会失败。在 Racket 中，我们碰巧使用整数表示法来表示整数的语法，两者都是无限的。但是如果我们想在 C 中编写一个 Racket 编译器，或者在 Racket 中编写一个 C 编译器呢？在一个 C 编译器中编写 C 编译器，其中编译器在 64 位机器上运行，结果需要在 32 位机器上运行，会怎么样？

## 旁注：组合性星期二，1 月 17 日

例如

```
<NUM> ::= <digit> | <NUM> <digit>
```

成为一种更容易编写求值器的语言，引导我们到一个重要的概念——组合性。这个定义更容易编写一个求值器，因为结果语言是组合的：表达式的含义——例如`123`——由其两部分的含义组成，在这个 BNF 中是`12`和`3`。具体来说，`<NUM> <digit>`的评估是第一个的评估乘以 10，加上第二个的评估。在`<digit> <NUM>`的情况下，这更加困难——这样一个数字的含义不仅取决于两部分的*含义*，还取决于`<NUM>`的*语法*：

```
eval(<digit> <NUM>) =  eval(<digit>) * 10^length(<NUM>) + eval(<NUM>)
```

在这种情况下，这是可以容忍的，因为表达式的含义仍然由其部分构成——但是命令式编程（当你使用副作用时）要复杂得多，因为它不是组合的（至少不是在明显的意义上）。这与函数式编程相比，函数式编程中，表达式的含义是其子表达式的含义的组合。例如，在函数式程序中，每个子表达式都有一定的含义，所有这些子表达式组成了包含它们的表达式的含义——但在命令式程序中，我们可以有代码的一部分是`x++`——这本身没有意义，至少不是以直接方式为整个程序的含义做出贡献的意义。

(实际上，我们可以为这种表达式定义一个明确定义的含义：从一个`x`是某个值 N 的容器的世界，到一个相同容器具有不同值 N+1 的世界。你现在可能能看出这会使事情变得更加复杂。在直觉层面上——如果我们看一个函数式程序的随机部分，我们可以知道它的含义，因此建立整个代码的含义是容易的，但在命令式程序中，一个随机部分的含义几乎是无用的。)
