# Church 数周二，2 月 14 日

到目前为止，似乎在这种语言中无法做任何有用的事情，因为我们只有函数和应用。我们知道如何编写恒等函数，但其他值呢？例如，您能写出计算为零的代码吗？

> 零是什么？我只知道如何写函数！
> 
> （图灵机程序员：“什么是函数？ — 我只知道如何写 0 和 1！”）

因此，我们首先需要能够将数字*编码*为函数。对于零，我们将使用一个简单返回其第二个值的两个参数的函数：

```
(define 0 (lambda (f) (lambda (x) x)))
```

或者，更简洁地说

```
(define 0 (lambda (f x) x))
```

这是已知为*Church 数*的编码的第一步：将自然数编码为函数。数字零被编码为一个接受函数和第二个值的函数，并在参数上零次应用函数（这实际上是上述定义在做什么）。根据这个观点，数字一将是一个两个参数的函数，将第一个参数应用于第二个一次：

```
(define 1 (lambda (f x) (f x)))
```

请注意，`1`就像恒等函数一样（只要您给它一个函数作为其第一个输入，但这在 Schlac 中始终如此）。列表中的下一个数字是二 — 它将第一个参数应用于第二个参数两次：

```
(define 2 (lambda (f x) (f (f x))))
```

我们可以继续这样做，但我们真正想要的是执行任意算术的方法。为此的第一个要求是一个`add1`函数，它将其输入（一个编码的自然数）增加一。为此，我们编写一个期望编码数字的函数：

```
(define add1 (lambda (n) ...))
```

这个函数预期返回一个编码的数字，它总是一个关于`f`和`x`的函数：

```
(define add1 (lambda (n) (lambda (f x) ...)))
```

现在，在主体中，我们需要将`f`应用于`x` n+1 次 — 但请记住，`n`是一个函数，将对其第一个参数在其第二个参数上进行`n`次应用：

```
(define add1 (lambda (n) (lambda (f x) ... (n f x) ...)))
```

现在我们只需再次应用`f`，得到`add1`的这个定义：

```
(define add1 (lambda (n) (lambda (f x) (f (n f x)))))
```

使用这个，我们可以定义一些有用的数字：

```
(define 1 (add1 0))(define 2 (add1 1))(define 3 (add1 2))(define 4 (add1 3))(define 5 (add1 4))
```

理论上这一切都很好，但我们如何确保它是正确的呢？好吧，Schlac 有一些额外的特殊形式，将 Church 数转换为 Racket 数。要尝试我们的定义，我们使用`->nat`（读作：转换为自然数）：

```
(->nat 0)(->nat 5)(->nat (add1 (add1 5)))
```

现在，您可以验证恒等函数确实与数字 1 相同：

```
(->nat identity)
```

我们甚至可以编写一个测试用例，因为 Schlac 包含`test`特殊形式，但我们必须小心 — 首先，我们不能测试函数是否相等（为什么？），所以我们必须使用`->nat`，但

```
(test (->nat (add1 (add1 5))) => 7)
```

将不起作用，因为`7`未定义。为了克服这一点，Schlac 为原始 Racket 值提供了一个`后门` — 只需使用引号：

```
(test (->nat (add1 (add1 5))) => '7)
```
