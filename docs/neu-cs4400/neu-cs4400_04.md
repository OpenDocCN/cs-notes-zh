# Racket 简介星期二，1 月 10 日

Racket 语法：类似于其他基于 S 表达式的语言。

提醒：括号可以与 C 等函数调用的括号进行比较 — 它们总是表示应用了某个函数。这就是为什么`(+ (1) (2))`不起作用的原因：如果你使用 C 语法，那就是`+(1(), 2())`，但`1`不是一个函数，所以`1()`是一个错误。

*语法*和*语义*之间的一个重要区别。一个好的思考方式是，存储在某个文件中的*字符串*`42`（两个 ASCII 值）与存储在内存中的*数字*`42`（以某种表示形式）之间的区别。你也可以继续上面的例子：“*谋杀*”没有错 — 它只是一个词，但*谋杀*是会让你入狱的事情。Racket 使用的求值函数实际上是一个接受一段语法并返回（或执行）其语义的函数。

* * *

`define`表达式用于创建新的绑定，不要试图使用它们来改变值。例如，你不应该尝试写类似`(define x (+ x 1))`的东西来模仿`x = x+1`。这不会起作用。

* * *

Racket 内置了两个布尔值：`#t`（真）和`#f`（假）。它们可以在`if`语句中使用，例如：

```
(if (< 2 3) 10 20)  -->  10
```

因为`(< 2 3)`评估为`#t`。事实上，*任何*值除了`#f`都被认为是真的，所以：

```
(if 0 1 2)        -->  1  ; all of these are "truthy"(if "false" 1 2)  -->  1(if "" 1 2)       -->  1(if null 1 2)     -->  1(if #t 1 2)       -->  1  ; including the true value(if #f 1 2)       -->  2  ; the only false value(if #false 1 2)   -->  2  ; another way to write it(if false 1 2)    -->  2  ; also false since it's bound to #f
```

* * *

注意：Racket 是一种*函数式*语言 — 所以*一切*都有一个值。

这意味着表达式

```
(if test consequent)
```

当`test`评估为`#f`时没有意义。这与 Pascal/C 不同，那里的语句会执行一些操作（副作用），比如打印或赋值 — 如果测试为假，那么`if`语句就什么也不做… 然而，Racket 必须返回一些值 — 它可以决定简单地返回`#f`（或某个未指定的值）作为

```
(if #f something)
```

一些实现可能会这样做，但 Racket 会声明它为语法错误。（正如我们将在未来看到的，Racket 有一个更方便的`when`，具有更清晰的意图。）

* * *

嗯，*几乎*所有东西都是一个值…

有一些东西是 Racket 语法的一部分 — 例如`if`和`define`是特殊形式，它们没有值！稍后会详细介绍更多。

（总结���与其他语言相比，有更多的东西具有值。）

* * *

`cond`用于`if` … `else if` … `else if` … `else` …序列。问题在于嵌套的`if`很不方便。例如，

```
(define (digit-num n)  (if (<= n 9)    1    (if (<= n 99)      2      (if (<= n 999)        3        (if (<= n 9999)          4          "a lot")))))
```

在 C/Java/其他语言中，你会写：

```
function digit_num(n) {  if (n <= 9)         return 1;  else if (n <= 99)   return 2;  else if (n <= 999)  return 3;  else if (n <= 9999) return 4;  else return "a lot";}
```

（旁边的问题：为什么 Racket 中没有`return`语句？）

但试图强迫 Racket 代码看起来相似：

```
(define (digit-num n)  (if (<= n 9)    1  (if (<= n 99)    2  (if (<= n 999)    3  (if (<= n 9999)    4    "a lot")))))
```

不仅仅是品味问题 — 缩进规则是有原因的，主要原因是你可以一眼看出程序的结构，而在上面的代码中这不再成立。（这样的代码将受到惩罚！）

因此，我们可以使用 Racket 的`cond`语句，像这样：

```
(define (digit-num n)  (cond [(<= n 9)    1]        [(<= n 99)   2]        [(<= n 999)  3]        [(<= n 9999) 4]        [else        "a lot"]))
```

注意`else`是`cond`形式使用的关键字——你应该总是使用一个`else`子句（出于类似于`if`的原因，在那里避免额外的表达式评估，并且当我们使用类型语言时，我们将需要它）。另请注意，方括号被 DrRacket 读取为圆括号，它只会确保括号配对匹配。我们使用这个来使代码更易读——具体来说，上面使用`[]`与常规使用`()`之间有一个重大区别。你能看出来是什么吗？

`cond`的一般结构：

```
(cond [test-1 expr-1]      [test-2 expr-2]      ...      [test-n expr-n]      [else   else-expr])
```

* * *

使用`if`表达式和递归函数的示例：

```
(define (fact n)  (if (zero? n)    1    (* n (fact (- n 1)))))
```

使用这个来展示不同的工具，特别是：

+   无法使用的特殊对象

+   语法检查器

+   步进器

+   提交工具（安装、注册和提交）

将其转换为尾递归形式的示例：

```
(define (helper n acc)  (if (zero? n)    acc    (helper (- n 1) (* acc n))))(define (fact n)  (helper n 1))
```

* * *

有关作业提交的附加说明：

+   每个函数都应以清晰的文档开头：包括一个目的声明和其类型。

+   根据需要记录函数，并按照上述指南和样式指南进行。

+   在函数之后，总是有几个测试案例——它们应该涵盖你的完整代码（确保包括可能的边界情况）。后来，我们将转而通过它的“公共接口”测试整个文件，而不是测试每个函数。
