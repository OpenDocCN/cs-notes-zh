# 德布鲁因索引星期二，1 月 24 日

整个故事都围绕着名称展开，具体来说，名称捕获是应该始终避免的问题（它是编程语言头疼的主要源泉之一）。

但名称是我们唯一可以使用绑定的方式吗？

还有至少一种替代方式：注意我们使用名称的唯一目的是用于引用。我们并不真的在乎名称是什么，当我们考虑这两个 WAE 表达式时，这是非常明显的：

```
{with {x 5} {+ x x}}{with {y 5} {+ y y}}
```

或者两个 Racket 函数定义：

```
(define (foo x) (list x x))(define (foo y) (list y y))
```

这两者都展示了一对我们在某种意义上应该视为相等的表达式（这被称为“α等价”）。我们关心的唯一事情是变量指向的位置：绑定结构是唯一重要的事情。换句话说，只要 DrRacket 在我们使用“检查语法”时产生相同的箭头，我们就认为程序是相同的，不管名称选择如何（对于参数名称和局部名称而言，全局名称如上面的 `foo` 不在此列）。

另一种替代方法是利用这个原则：如果我们关心的只是箭头的去向，那么只需摆脱名称… 不是通过名称引用绑定，而是指定我们想要引用的周围作用域。例如，而不是：

```
{with {x 5} {with {y 6} {+ x y}}}
```

我们可以使用一个新的“引用”语法 — `[N]` — 并使用这个语法代替上述的：

```
{with 5 {with 6 {+ [1] [0]}}}
```

因此，对于 `[N]` 的规则是 — `[0]` 是在当前作用域中绑定的值，`[1]` 是下一个作用域中的值等等。

当然，为了进行这种翻译，我们必须知道精确的作用域规则。两个更复杂的例子：

```
{with {x 5} {+ x {with {y 6} {+ x y}}}}
```

is translated to:

```
{with 5 {+ [0] {with 6 {+ [1] [0]}}}}
```

（注意 `x` 如何根据它在原始代码中出现的位置而作为不同的引用。）更微妙的是：

```
{with {x 5} {with {y {+ x 1}} {+ x y}}}
```

is translated to:

```
{with 5 {with {+ [0] 1} {+ [1] [0]}}}
```

因为内部的 `with` 没有自己的命名表达式在其作用域中，所以命名表达式立即在外部 `with` 的作用域中。

这被称为“德布鲁因索引”：我们不使用标识符的名称，而是使用周围绑定上下文的索引。正如上面的例子所示，其主要缺点在于对人类来说不方便。具体来说，同一标识符使用不同的数字进行引用，这使得理解某些代码在做什么变得困难。

然而，几乎所有的编译器都使用这种方法来生成编译后的代码（考虑一下栈指针）。例如，GCC 编译此代码：

```
{  int x = 5;  {    int y = x + 1;    return x + y;  }}
```

转换为：

```
subl $8, %espmovl $5, -4(%ebp)   ; int x = 5movl -4(%ebp), %eaxincl %eaxmovl %eax, -8(%ebp) ; int y = %eaxmovl -8(%ebp), %eaxaddl -4(%ebp), %eax
```
