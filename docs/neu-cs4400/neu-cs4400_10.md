# BNF，语法，AE 语言

回到课程的主题：我们想要研究编程语言，并且我们想要*使用*一种编程语言来做到这一点。

设计语言的第一步是规定语言。为此我们使用 BNF（巴科斯-诺尔形式）。例如，这是一个简单算术语言的定义：

```
<AE> ::= <num>       | <AE> + <AE>       | <AE> - <AE>
```

解释不同的部分。具体来说，这是具有解析的低级（具体）语法定义的混合体。

我们使用这个来推导某种语言中的表达式。我们从`<AE>`开始，它应该是这些中的一个：

+   一个数字`<num>`

+   一个`<AE>`，文本“`+`”，和另一个`<AE>`

+   相同的但是有“`-`”

`<num>` 是一个终结符：当我们在推导中到达它时，我们就完成了。`<AE>` 是一个非终结符：当我们到达它时，我们必须继续其中的一个选项。应该清楚的是，“`+`”和“`-`”是我们期望在输入中找到的东西 —— 因为它们没有被包裹在`<>`中。

我们可以指定`<num>`是什么（将其转换为`<NUM>`非终结符）：

```
<AE> ::= <NUM>       | <AE> + <AE>       | <AE> - <AE><NUM> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9        | <NUM> <NUM>
```

但我们没有 —— 为什么？因为在 Racket 中我们有数字作为原语，我们想要使用 Racket 来实现我们的语言。这样会方便很多，并且我们会得到免费的东西，比如浮点数、有理数等等。

要正式使用 BNF，例如，证明`1-2+3`是一个有效的`<AE>`表达式，我们首先对规则进行标记：

```
<AE> ::= <num>        (1)       | <AE> + <AE>  (2)       | <AE> - <AE>  (3)
```

然后我们可以使用它们作为每个推导步骤的正式理由：

```
<AE><AE> + <AE>         ; (2)<AE> + <num>        ; (1)<AE> - <AE> + <num> ; (3)<AE> - <AE> + 3     ; (num)<num> - <AE> + 3    ; (1)<num> - <num> + 3   ; (1)1 - <num> + 3       ; (num)1 - 2 + 3           ; (num)
```

这将是做这件事情的一种方式。或者，我们可以使用树来可视化推导，用节点上使用的规则。

这些规范存在歧义：一个表达式可以通过多种方式推导。甚至一个数字的小语法也是模糊的 —— 像`123`这样的数字可以通过两种方式推导，结果看起来不同的树。现在这种歧义并不是一个“真正”的问题，但很快就会成为一个问题。我们想要消除这种歧义，使得推导所有表达式都有一个单一（=确定性）的方式。

解决这个问题有一种标准方法 —— 我们向定义中添加另一个非终结符，并确保每个规则只能继续到其备选项之一。例如，这是我们可以对数字做的：

```
<NUM>   ::= <DIGIT> | <DIGIT> <NUM><DIGIT> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

类似的解决方案可以应用于`<AE>` BNF — 我们要么限制推导的方式，要么提出新的非终结符来强制确定性推导树。

作为限制推导的示例，我们看一下当前的语法：

```
<AE> ::= <num>       | <AE> + <AE>       | <AE> - <AE>
```

而不是允许操作两侧都是`<AE>`，我们强制其中一个是数字：

```
<AE> ::= <num>       | <num> + <AE>       | <num> - <AE>
```

现在只有一种方式来推导任何表达式，它总是将操作与右边关联起来：像`1+2+3`这样的表达式只能推导为`1+(2+3)`。要将其改为左关联，我们会使用这个：

```
<AE> ::= <num>       | <AE> + <num>       | <AE> - <num>
```

但是如果我们想要强制优先级呢？假设我们的 AE 语法有加法和乘法：

```
<AE> ::= <num>       | <AE> + <AE>       | <AE> * <AE>
```

我们可以像上面那样做同样的事情并添加新的非终结符 —— 比如一个“因子”：

```
<AE>   ::= <num>         | <AE> + <AE>         | <PROD><PROD> ::= <num>         | <PROD> * <PROD>
```

现在，我们必须将任何 AE 表达式解析为乘法的加法（或数字）。首先，注意如果 `<AE>` 变为 `<PROD>`，而 `<PROD>` 变为 `<num>`，那么 `<AE>` 不需要变为 `<num>`，因此这是相同的语法：

```
<AE>   ::= <AE> + <AE>         | <PROD><PROD> ::= <num>         | <PROD> * <PROD>
```

现在，如果我们仍然想要能够将加法相乘，我们可以强制它们出现在括号中：

```
<AE>   ::= <AE> + <AE>         | <PROD><PROD> ::= <num>         | <PROD> * <PROD>         | ( <AE> )
```

接下来，注意 `<AE>` 对于加法仍然存在歧义，可以通过强制加法的左侧是因子来解决：

```
<AE>   ::= <PROD> + <AE>         | <PROD><PROD> ::= <num>         | <PROD> * <PROD>         | ( <AE> )
```

我们仍然存在对乘法的歧义，所以我们做同样的事情，并为“原子”添加另一个非终端：

```
<AE>   ::= <PROD> + <AE>         | <PROD><PROD> ::= <ATOM> * <PROD>         | <ATOM><ATOM> ::= <num>         | ( <AE> )
```

你可以尝试推导几个表达式以确信推导现在始终是确定性的。

但正如你所见，这恰恰是我们想要避免的化妆品 — 它会导致我们可能感兴趣但与编程语言原理无关的东西。当我们拥有一个真正的语言而不是这样一个微小的语言时，情况也会变得更加糟糕。

是否有一个好的解决方案？ — 答案就在我们眼前：做像 Racket 一样 — 总是使用完全括号表达式：

```
<AE> ::= <num>       | ( <AE> + <AE> )       | ( <AE> - <AE> )
```

为了避免将 Racket 代码与我们语言中的代码混淆，我们还将括号改为花括号：

```
<AE> ::= <num>       | { <AE> + <AE> }       | { <AE> - <AE> }
```

但在 Racket 中 *一切* 都有一个值 — 包括那些 `+` 和 `-`，这使得这种情况极为方便，可以用未来可能具有比 2 更多或更少参数以及将这些算术运算符视为普通函数的操作。在我们的玩具语言中，最初我们不会这样做（即，`+` 和 `-` 是二阶运算符：它们不能被用作值）。但由于我们以后会涉及到这一点，我们将采用 Racket 的解决方案，并使用完全括号的前缀表示法：

```
<AE> ::= <num>       | { + <AE> <AE> }       | { - <AE> <AE> }
```

（记住，在某种意义上，Racket 代码是以一种已解析的语法形式书写的…）
