# 绑定和替换

现在我们来到一个重要的概念：替换。

即使在我们简单的语言中，我们也会遇到重复的表达式。例如，如果我们想要计算某个表达式的平方：

```
{* {+ 4 2} {+ 4 2}}
```

我们为什么要摆脱重复的子表达式？

+   它引入了冗余的计算。在这个例子中，我们希望避免第二次计算相同的子表达式。

+   它使计算比没有重复时更加复杂。与上面的进行比较：

    ```
    with x = {+ 4 2},  {* x x}
    ```

+   这与编程中一个我们已经讨论过的基本事实有关：复制信息总是一件坏事。除了其他坏后果外，它甚至可能导致如果我们不复制代码就不会发生的错误。一个玩具例子是在一个表达式中“修复”一个数字，却忘记修复对应的数字：

    ```
    {* {+ 4 2} {+ 4 1}}
    ```

    现实世界的例子涉及更多的代码，这使得这种错误非常难以发现，但它们仍然遵循相同的原则。

+   这给了我们更多的表达能力 — 我们不只是说我们想要将两个表达式相乘，这两个表达式恰好都是`{+ 4 2}`，我们说我们将`{+ 4 2}`表达式与*自身*相乘。它允许我们表达两个值的相等，以及使用两个恰好相同的值。

因此，避免冗余的常规方法是引入一个标识符。即使在说话时，我们可能会说：“让 x 等于 4 加 2，将 x 乘以 x”。

（这些通常被称为“变量”，但我们将尽量避免使用这个名字：如果标识符不变呢？）

为了实现这一点，我们在我们的语言中引入了一个新的形式：

```
{with {x {+ 4 2}}  {* x x}}
```

我们希望能够将这个简化为：

```
{* 6 6}
```

通过在`with`的主体子表达式中用 6 替换`x`。

一个稍微复杂的例子：

```
{with {x {+ 4 2}}  {with {y {* x x}}    {+ y y}}}[add]  = {with {x 6} {with {y {* x x}} {+ y y}}}[subst]= {with {y {* 6 6}} {+ y y}}[mul]  = {with {y 36} {+ y y}}[subst]= {+ 36 36}[add]  = 72
```
