- en: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P3：L0- 搜索算法 2 (广度优先搜索，贪心搜索，A＊算法) - ShowMeAI
    - BV1AQ4y1y7wy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: else instead，but depth-first search is just one of，the possible search options
    that we。could use it turns out that there's，another algorithm called breadth-first。search
    which behaves very similarly to，depth-first search，with one difference instead
    of always。exploring the deepest node in the search，tree the way the depth-first
    search does。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: breadth-first search is always going to，explore the shallowest node in the。frontier
    so what does that mean well it，means that instead of using a stack。which depth-first
    search or DFS used，where the most recent item added to the。frontier is the one
    we'll explore next，in breadth-first search or BFS will。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: instead use a queue where a queue is a，first in first out data type where the。very
    first thing we add to the frontier，is the first one we'll explore and they。effectively
    form a line or a queue，where the earlier you arrive in the。frontier the earlier
    you get explored I，said what would that mean for the same。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: exact problem finding a path from A to E。![](img/1885304785061450828b076e969d139d_1.png)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: will we start with a same as before then，we'll go ahead and have explored a
    and。say where can we get to from a well from，a we can get to B same as before。from
    B same as before we can get to C，and D so C and D get added to the。frontier this
    time though we added C to，the frontier with for D so we'll explore。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: C first so C gets explored and from C，where can we get to well we can get to
    e。so e gets added to the frontier but，because D was explored before E we'll。look
    at D next so we'll explore D and，say where can we get to from D we can。get to
    F and only then we say alright，now we can get to e and so what。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: breadth-first search or BFS did is we，started here we looked at both C and D。and
    then we looked at e effectively，we're looking at things one away from。the initial
    state then two away from the，initial State and only then things that。are three
    away from the initial State，unlike depth-first search which just。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1885304785061450828b076e969d139d_3.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: went as deep as possible into the search，tree until it hit a dead end and then。ultimately
    had to back up so these now，are two different search algorithms that。we could
    apply in order to try and solve，a problem and let's take a look at how。these would
    actually work in practice，with something like maze solving for。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: example so here's an example of a maze，these empty cells represent places where。our
    agent can move them these darkened，gray cells represent walls that the。agent can't
    pass through and ultimately，our agent our AI is going to try to find。a way to
    get from position a to position，B via some sequence of actions where。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: those actions are left right up and down，what will depth-first search do in
    this。![](img/1885304785061450828b076e969d139d_5.png)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: case well depth-first search，will just follow one path if it reaches。a fork
    in the road where it has multiple，different options depth-first search is。just
    in this case going to choose one it，wasn't a real preference but it's going。to
    keep following one until it hits a，dead end and when it hits a dead end。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，深度优先搜索将只沿着一条路径前进，如果它到达一个岔路口，有多个不同的选项，深度优先搜索在这种情况下将选择其中一条，它并没有真正的偏好，但它将继续跟随这条路径，直到遇到死胡同，当它到达死胡同时。
- en: depth-first search effectively goes back，to the last decision point and tries
    the。other path fully exhausting this entire，path and when it realizes that okay
    the，goal is not here。it turns his attention to this path it，goes as deep as possible
    when it hits a。dead end it backs up and then tries this，other path keeps going
    as deep as。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索有效地回到最后的决策点，尝试另一条路径，完全耗尽这整条路径，当它意识到目标不在这里时，它将注意力转向这条路径，它会尽可能深入，当它遇到死胡同时，它会退回，然后尝试这条另一条路径，继续深入。
- en: possible down one particular path and，when it realizes that's a dead end。then
    it'll back up and then ultimately，find its way to the goal and maybe you。got lucky
    and maybe you made a different，choice earlier on but ultimately this is。how depth-first
    search is going to work，it's going to keep following until it，end。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可能沿着某条特定路径向下，当它意识到这是个死胡同时，它会退回去，最终找到通向目标的道路，也许你运气不错，也许你之前做了不同的选择，但最终这就是深度优先搜索的工作方式，它会一直跟随直到结束。
- en: it backs up and looks for a different，solution and so one thing you might。reasonably
    ask is is this algorithm，always going to work will it always。actually find a way
    to get from the，initial state to the goal and it turns。out that as long as our
    maze is finite，as long as they're only finitely many。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它会退回并寻找不同的解决方案，因此你可能合理地问，这个算法是否总是会工作，是否总是能够找到从初始状态到目标的路径，结果是只要我们的迷宫是有限的，只要方块数量是有限的。
- en: spaces where we can travel then yes，depth-first search is going to find a。solution
    because eventually it'll just，explore everything if the maze happens。to be infinite
    and there's an infinite，state space which does exist in certain。types of problems
    then it's a slightly，different story but as long as our maze。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以在可以移动的空间中，那么是的，深度优先搜索将找到解决方案，因为最终它将探索一切，如果迷宫恰好是无限的，并且存在无限状态空间，在某些类型的问题中确实存在，那么情况会稍微不同，但只要我们的迷宫。
- en: has finitely many squares we're going to，find a solution，the next question though
    that we want to。ask is is it going to be a good solution，is it the optimal solution
    that we can。find and the answer there is not，necessarily and let's take a look
    at an。example of that in this maze for example，we're again trying to find our
    way from。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有有限的方块，我们将要找到一个解决方案，但下一个问题是，是否会是一个好的解决方案，是我们能找到的最优解，答案并不一定，让我们看一下这个迷宫的例子，我们又在试图找到从。
- en: A to B and you notice here there are，multiple possible solutions we could go。this
    way or we could go up in order to，make our way from A to B now if we're。lucky
    depth-first search we'll choose，this way and get to beam but there's no。reason
    necessarily why depth-first，search would choose between going up or。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从A到B，你会注意到这里有多个可能的解决方案，我们可以沿这条路走，或者向上走以从A到B，现在如果我们运气好，深度优先搜索会选择这条路，顺利到达B，但并没有理由说明深度优先搜索会选择上走还是。
- en: going to the right it's sort of an，arbitrary decision point because both。are
    going to be added to the frontier，and ultimately if we get unlucky。depth-first
    search might choose to，explore this path first because it's。just a random choice
    at this point，it'll explore explore explore and it'll。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 向右移动这是一种任意的决策点，因为两者都会被添加到边界，最终如果我们运气不好，深度优先搜索可能会选择先探索这条路径，因为此时它只是一个随机选择，它会不断探索。
- en: eventually find the goal this particular，path when in actuality there was a。better
    path there was a more optimal，solution that used fewer steps assuming。![](img/1885304785061450828b076e969d139d_7.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终找到目标的这条特定路径，其实是有更好的路径存在，存在一个更优的解决方案，使用更少的步骤假设！[](img/1885304785061450828b076e969d139d_7.png)
- en: we're measuring the cost of a solution，based on the number of steps that we。need
    to take so depth-first search if。![](img/1885304785061450828b076e969d139d_9.png)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据需要采取的步骤数量来衡量解决方案的成本，因此深度优先搜索如果。![](img/1885304785061450828b076e969d139d_9.png)
- en: we're unlucky might end up not finding，the best solution when a better solution。![](img/1885304785061450828b076e969d139d_11.png)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运气不好，可能最终找不到最佳解决方案，而更好的解决方案。![](img/1885304785061450828b076e969d139d_11.png)
- en: is available，so if that's DFS depth-first search how。![](img/1885304785061450828b076e969d139d_13.png)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是可用的，所以如果这是深度优先搜索（DFS），那么。![](img/1885304785061450828b076e969d139d_13.png)
- en: does BFS or breadth first search compare，how would it work in this particular。situation
    well the algorithm is going to，look very different visually in terms of。how BFS
    explores because BFS looks at，shallower nodes first the idea is going。to be BFS
    will first look at all of the，nodes that are one away from the initial。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）如何比较，在这个特定的情况下它将如何工作，算法在视觉上将会有很大的不同，因为BFS首先查看较浅的节点，想法是BFS将首先查看离初始节点一步远的所有节点。
- en: State look here and look here for，example just that the two nodes that are。immediately
    next to this initial state，then it will explore nodes that are two。away looking
    at this state and that，state for example then it'll explore。nodes that are three
    away this state in，that state whereas depth-first search。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 状态查看这里和这里，例如就像是这两个节点。紧挨着这个初始状态，那么它将探索离这个状态两步远的节点，查看这个状态和那个状态，例如，然后它将探索离这个状态三步远的节点，而深度优先搜索（DFS）。
- en: just picked one path and kept following，it breadth-first search on the other。hand
    is taking the option of exploring，all of the possible paths。kind of at the same
    time bouncing back，between them looking deeper and deeper。at each one but making
    sure to explore，the shallower ones or the ones that are。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只选择了一条路径并继续，另一方面，广度优先搜索则选择了探索所有可能的路径。几乎同时在它们之间反弹，深入探索每一条路径，但确保探索较浅的路径或较近的路径。
- en: closer to the initial state earlier so，we'll keep following this pattern。looking
    at things that are far away，looking at things that are five away。looking at things
    that are six away，until eventually we make our way to the。goal and in this case
    it's true we had，to explore some states that ultimately。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更接近初始状态，所以我们将继续遵循这个模式，查看远处的事物，查看五步远的事物，查看六步远的事物，直到最终到达目标，在这种情况下，确实我们必须探索一些最终。
- en: didn't lead us anywhere but the paths，that we found to the goal was the。optimal
    path this is the shortest way，that we could get to the goal and so。![](img/1885304785061450828b076e969d139d_15.png)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没有带我们到任何地方，但我们找到的通往目标的路径是最优路径，这是我们到达目标的最短方式，因此。![](img/1885304785061450828b076e969d139d_15.png)
- en: what might happen then in a larger maze，well let's take a look at something
    like。this and how breadth-first search is，going to behave well breadth-first。search
    again will just keep following，the states until it receives a decision。point it
    could go either left or right，and while DFS just picked one and kept。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的迷宫中可能发生什么，嗯，让我们看看这样的情况，广度优先搜索将如何表现，广度优先搜索再次会继续跟随状态，直到它收到一个决策点，它可以向左或向右，而深度优先搜索则选择一个并继续。
- en: following that until it hit a dead end，BFS on the other hand will explore both。it'll
    say look at this node then this，node and will look at this node then。that node
    so on and so forth and when it，hits a decision point here rather than。pick one
    left or two right and explore，that path it'll again explore both。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一直跟随直到它遇到死胡同，另一方面，BFS将探索两个节点，它会查看这个节点，然后这个节点，并查看这个节点，然后那个节点，依此类推，当它在这里遇到一个决策点时，而不是选择左边一个或右边两个并探索那条路径，它将再次探索两个。
- en: alternating between them going deeper，and deeper we'll explore here and then。maybe
    here and here and then keep going，explore here and slowly make our way you。can
    visually see further and further out，once we get to this decision point we'll。explore
    both up and down until，ultimately we make our way to the，and what you'll notice
    is yes。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 交替在它们之间，越来越深入，我们将在这里探索，然后也许在这里和这里，然后继续前进，慢慢探索这里，你可以在视觉上看到越来越远，一旦我们到达这个决策点，我们将向上和向下探索，直到最终我们到达，并且你会注意到是的。
- en: breadth-first search did find our way，from A to B by following this particular。path
    but it needed to explore a lot of，states in order to do so and so we see。some
    trade-offs here between DFS and BFS，that in DFS there may be some cases。where
    there is some memory savings as，compared to a breadth-first approach。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）确实找到了我们的路径，从A到B，遵循这个特定的路径，但它需要探索许多状态才能做到这一点，因此我们看到DFS和BFS之间有一些权衡，在DFS中，可能有些情况下与广度优先方法相比会节省内存。
- en: where breadth-first search in this case，had to explore a lot of states but maybe。that
    won't always be the case so now，let's actually turn our attention to。some code
    and look at the code that we，could actually write in order to。implement something
    like depth-first，search or breadth-first search in the。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，广度优先搜索必须探索很多状态，但这可能并不总是这样，所以现在，让我们实际上将注意力转向一些代码，看看我们可以实际编写的代码，以实现深度优先搜索或广度优先搜索。
- en: context of solving a maze for example so，I'll go ahead and go into my terminal。and
    what I have here inside of maze pipe，is an implementation of the same idea of。maze
    solving I've defined a class called，node that in this case is keeping track。of
    the state the parent in other words，the state before the state and the。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解决迷宫的上下文，例如，所以我将前往我的终端，而我在迷宫管道内部拥有的是相同的迷宫求解思想的实现，我定义了一个名为节点的类，在这种情况下，它跟踪状态、父状态，换句话说，状态之前的状态和。
- en: action in this case we're not keeping，track of the path cost because we can。calculate
    the cost of a path at the end，after we found our way from the initial。state to
    the goal in addition to this，I've defined a class called a stack。frontier and
    if unfamiliar with a class，a class is a way for me to define a way。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有跟踪路径成本，因为我们可以在找到从初始状态到目标的路径后计算路径成本。此外，我定义了一个名为栈的类前沿，如果不熟悉类，类是我定义一种方式的方式。
- en: to generate objects in Python it refers，to an idea of object-oriented。programming
    where the idea here is that，I would like to create an object that is。able to store
    all of my frontier data，and I would like to have functions。otherwise known as
    methods on that，object that I can use to manipulate the。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中生成对象，它指的是面向对象编程的理念，这里的想法是我想创建一个能够存储我所有前沿数据的对象，我希望在该对象上有可以用来操纵的函数，通常称为方法。
- en: object and so what's going on here if，unfamiliar with the syntax is I have a。function
    that initially creates a，frontier that I'm going to represent。using a list and
    initially my frontier，is represented by the empty list there's。nothing in my frontier
    to begin with I，have an add function that adds something。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对象中的方法，所以如果你对语法不熟悉，这里发生的事情是我有一个函数，最初创建一个前沿，我将使用列表来表示，最初我的前沿用空列表表示，开始时前沿中没有任何东西，我有一个添加函数可以添加某物。
- en: to the frontier as by appending it to，the end of the list I have a function。that
    checks if the frontier contains a，particular state I have an empty，empty。if the
    frontier is empty that just means，the length of the frontier is 0 and then。I have
    a function for removing something，from the frontier I can't remove。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其附加到列表的末尾，我有一个函数。该函数检查前沿是否包含特定状态，我有一个空的，如果前沿为空，那就意味着，前沿的长度为0，然后。我有一个从前沿中移除某物的函数，我不能从前沿中移除。
- en: something from the frontier if the，frontier is empty so I check for that，first。but
    otherwise if the frontier isn't，empty recall that I'm implementing this。frontier
    as a stack a last in first out，data structure which means the last。thing I add
    to the frontier in other，words the last thing in the list is the。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前沿为空，我不能从前沿中移除某物，所以我首先检查这一点。但是如果前沿不为空，请记住，我将前沿实现为一个栈，即后进先出数据结构，这意味着我最后添加到前沿的。
- en: item that I should remove from this，frontier so what you'll see here is I。have
    removed the last item of a list and，if you index into a Python list with。negative
    one that gets you the last item，in the list since zero is the first item。negative
    one kind of wraps around and，gets you to the last item in the list so。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该从这个前沿中移除的项目，所以你会看到我已移除列表的最后一个项目，如果你用负一索引Python列表，这会得到列表中的最后一个项目，因为零是第一个项目，负一则可以循环到列表的最后一个项目。
- en: we give that the node we call that node，we update the frontier here on line
    28。to say go ahead and remove that node，that you just removed from the frontier。and
    then we return the node as a result，so this class here effectively。implements
    the idea of a frontier it，gives me a way to add something to a。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给该节点，我们称其为节点，我们在第28行更新前沿，以说继续移除你刚刚从前沿中移除的节点，然后我们将节点作为结果返回，所以这个类实际上实现了前沿的理念，它给了我一种将某物添加到一个。
- en: frontier and a way to remove something，from the frontier as a stack I've also。just
    for good measure implemented an，alternative version of the same thing。called a
    queue frontier which in，parentheses you'll see here it inherits。from a stack frontier
    meaning it's going，to do all the same things that the stack。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前沿和从前沿中移除某物的方法是栈，我还为好措施实现了同一事物的替代版本，称为队列前沿，括号中你会看到它继承自栈前沿，意味着它将执行栈所做的所有操作。
- en: frontier did except the way we remove a，node from the frontier is going to be。slightly
    different instead of removing，from the end of the list the way we。would in a stack
    were instead going to，remove from the beginning of the list。self dot frontier
    0 will get me the，first node in the frontier the first one。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前沿是这样的，除了我们从前沿移除节点的方式会稍微不同，我们将从列表的开头移除，而不是从栈中通常从末尾移除。`self.frontier[0]`将为我获取前沿中的第一个节点。
- en: that was added and that is going to be，the one that we returned in the case
    of。a queue then under here I have a，definition of a class called Mae ism。this
    is going to handle the process of，taking a sequence a maze-like text file。and
    figuring out how to solve it so it，will take as input a text file that。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 被添加的那个将是我们在队列中的返回项。接下来，我有一个名为`Mae ism`的类定义。这将处理获取一个序列，类似迷宫的文本文件并找出如何解决它，因此它将以文本文件作为输入。
- en: looks something like this for example，where we see hash marks that are here。representing
    walls and I have the，character a representing the starting，position and the character
    B。representing the ending position and you，can take a look at the code for parsing。this
    text file right now that's the less，interesting part the more interesting。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，结果看起来像这样，其中我们看到代表墙壁的哈希标记。我有字符`A`表示起始位置，字符`B`表示结束位置，你可以查看解析这个文本文件的代码。现在这部分不太有趣，更有趣的是。
- en: part is this solve function here where，the solve function is going to figure。out
    how to actually get from point A to，point B and here we see an。implementation
    of the exact same idea we，saw from a moment ago we're going to，keep track。how
    many states we've explored just so，we can report that data later but I。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是解决函数，这个函数将弄清楚如何从点A到点B。在这里，我们看到的实现与刚才看到的完全相同，我们将跟踪探索的状态数量，以便稍后报告这些数据。
- en: start with a node that represents just，the start state and I start with a。frontier
    that in this case is a stack，frontier and given that I'm treating my。frontier
    as a stack you might imagine，that the algorithm I'm using here is now。depth-first
    search because depth-first，search or DFS uses a stack as its data。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从表示起始状态的节点开始，我以栈前沿开始。在这种情况下，考虑到我将前沿视为栈，你可能想象我在这里使用的算法是深度优先搜索，因为深度优先搜索或DFS使用栈作为其数据。
- en: structure and initially this frontier is，just going to contain the start State
    we。initialize an explored set that，initially is empty there's nothing we've。explored
    so far and now here's our loop，that notion of repeating something again。and again
    first we check at the，frontiers empty by calling that empty。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结构，最初这个前沿将仅包含起始状态。我们初始化一个探索集合，最初为空，我们还没有探索过任何东西，现在这是我们的循环，重复某事的概念。
- en: function that we saw the implementation，of a moment to go and if the frontier
    is。indeed empty we'll go ahead and raise an，exception or a Python error to say
    sorry。there is no solution to this problem，otherwise we'll go ahead and remove
    a。node from the frontier as by calling，frontier dot remove it and update the。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的功能的实现，如果前沿确实为空，我们将抛出一个异常或Python错误，表示抱歉，这个问题没有解决方案。否则，我们将继续从前沿移除一个节点，通过调用`frontier.remove()`来更新状态。
- en: number of states we've explored because，now we've explored one additional state。so
    we say self dot numb explored a plus，equals 1 adding 1 to the number of，states
    we've explored。once we remove a node from the frontier，recall that the next step
    is to see。whether or not it's the goal the goal，test and in the case of the maze
    the。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索的状态数量，因为现在我们探索了一个额外的状态。所以我们说`self.numb_explored += 1`，将1添加到我们探索的状态数量中。一旦我们从前沿移除一个节点，请记住，下一步是检查它是否是目标，进行目标测试，在迷宫的情况下。
- en: goal is pretty easy I check to see，whether the state of the node is equal。to
    the goal initially when I set up the，maze I set up this value called goal。which
    is a property of the maze so I can，just check to see if the node is。actually the
    goal and if it is the goal，then what I want to do is backtrack my。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 检查目标是相对简单的。我会查看节点的状态是否等于目标。在我设置迷宫时，我设定了一个叫做目标的值，这是迷宫的一个属性，因此我可以检查节点是否实际是目标。
- en: way towards figuring out what actions I，took in order to get to this goal and。how
    do I do that well recall that every，node stores its parent the node that。came
    before it that we use to get to，this node and also the action used in。order to
    get there so I can create this，loop where I'm constantly just looking。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我逐步搞清楚为了达到这个目标我采取了什么行动。如何做到这一点呢？回想一下，每个节点存储它的父节点，即到达此节点所经过的节点，以及为此使用的动作。因此，我可以创建一个循环，持续查看。
- en: at the parent of every node and keeping，track for all of the parents what action。I
    took to get from the parent to this，current node so this loop is going to。keep
    repeating this process of looking，through all of the parent nodes until we。get
    back to the initial state which has，an apparent where node dot parent is。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每个节点的父节点，并记录所有父节点之间的动作，以便从父节点到当前节点。因此，这个循环将持续查找所有父节点，直到我们回到初始状态，其父节点`node
    dot parent`等于None。
- en: going to be equal to none as I do so I'm，going to be building up the list。all
    of the actions that I'm following，and a list of all the cells that are。part of
    this solution but I'll reverse，them because when I build it up going。from the
    goal back to the initial state，and building the sequence of actions。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我将构建出我所遵循的所有动作的列表，以及所有属于这个解决方案的单元格的列表，但我会反转它们，因为我是在从目标返回到初始状态时构建动作序列。
- en: from the goal to the initial state but I，want to reverse them in order to get
    the。sequence of actions from the initial，state to the goal and that is ultimately。going
    to be the solution so all of that，happens if the current state is equal to。the
    goal and otherwise if it's not the，goal well then I'll go ahead and add。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从目标到初始状态，但我想反转它们以获得从初始状态到目标的动作序列，这最终将是解决方案。因此，所有这些发生在当前状态等于目标时，否则如果它不是目标。
- en: this state to the explored set to say，I've explored the state now no need to。go
    back to it if I come across it in the，future and then this logic here。implements
    the idea of adding neighbors，to the frontier I'm saying look at all。of my neighbors
    and I implemented a，function called neighbors that you can。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个状态添加到已探索集合中，表示我已经探索了这个状态，未来如果再遇到就不需要再回去，然后这段逻辑实现了将邻居添加到边界的想法。我会查看我的所有邻居，并实现一个叫做邻居的函数。
- en: take a look at and for each of those，neighbors I'm gonna check is the state。already
    in the frontier is the state，already in the explored set and if it's。not in either
    of those then I'll go，ahead and add this new child node this。new node to the frontier
    so there's a，fair amount of syntax here but the key。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看每一个邻居，我会检查这个状态是否已经在边界内，或者是否已经在已探索集合中。如果不在这两个集合中，我将添加这个新子节点到边界中，因此这里有相当多的语法，但关键是。
- en: here is not to understand all the。![](img/1885304785061450828b076e969d139d_17.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点不是要理解所有内容。![](img/1885304785061450828b076e969d139d_17.png)
- en: nuances of the syntax so feel free to，take a closer look at this file on your。own
    to get a sense for how it is working，but the key is to see how this is an。implementation
    of the same pseudo code，the same idea that we were describing a。moment ago on
    the screen when we were，looking at the steps that we might。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 语法的细微差别，所以请随意仔细查看这个文件，了解它的工作原理。但关键是看到这是同样伪代码的实现，正如我们在屏幕上描述的那样，当时我们查看了可能的步骤。
- en: follow in order to solve this kind of，search problem so now let's actually see。this
    in action I'll go ahead and run，maze spy on maze one dot text for。example and
    what we'll see is here we，have a printout of what the maze。initially looked like
    and then here down，below is after we've solved it we had to。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种搜索问题，我们现在来看看实际操作。我将运行`maze spy on maze one dot text`作为示例，下面是迷宫最初的打印输出，之后是解决后的结果。
- en: explore eleven states in order to do it，and we found a path from A to B and
    in。this program I just happened to generate。![](img/1885304785061450828b076e969d139d_19.png)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 探索了11个状态才能做到这一点，我们找到了一条从A到B的路径，而在这个程序中我刚好生成了。![](img/1885304785061450828b076e969d139d_19.png)
- en: well，so I can open up maze dot PNG which is，generated by this program that shows
    you。where in dark the darker color here are，the walls red is the initial state
    green。as the goal and yellow is the path that，was followed we found a path from
    the。![](img/1885304785061450828b076e969d139d_21.png)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我可以打开由这个程序生成的 maze dot PNG，它向你展示了。黑暗中的位置，较深的颜色是墙，红色是初始状态，绿色是目标，黄色是经过的路径，我们找到了一条从。![](img/1885304785061450828b076e969d139d_21.png)
- en: initial state to the goal but now let's，take a look at a more sophisticated
    maze。to see what might happen instead let's，look now at maze to dot text we're
    now。here we have a much larger maze again，A，to point B but now you'll imagine
    that。depth-first search might not be so lucky，it might not get the goal on the
    first。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态到目标，但现在让我们看看一个更复杂的迷宫。看看可能会发生什么，接下来我们看 maze to dot text，我们现在。这里有一个更大的迷宫，从A到B，但现在你会想象深度优先搜索可能不会那么幸运，可能不会在第一次就找到目标。
- en: try you might have to follow one path，then backtrack and explore something。![](img/1885304785061450828b076e969d139d_23.png)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，你可能需要沿着一条路径，然后回溯并探索其他东西。![](img/1885304785061450828b076e969d139d_23.png)
- en: this，we run Python maze da pie of maze two，texts this time trying on this other。maze
    and now depth-first search is able，to find a solution here as indicated by。![](img/1885304785061450828b076e969d139d_25.png)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个，我们运行Python maze da pie of maze two，文本这次尝试另一个迷宫，现在深度优先搜索能够在这里找到解决方案，如所示。![](img/1885304785061450828b076e969d139d_25.png)
- en: the Stars is a way to get from A to B，and we can represent this visually by。opening
    up this maze here's what that，maze looks like and highlighted in。yellow is the
    path that was found from，the initial state to the goal but how。many states do
    we have to explore before，we found that path well recall that in。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 星星是一种从A到B的方式，我们可以通过打开这个迷宫以视觉方式表示。这个迷宫看起来是这样的，黄色高亮的是从初始状态到目标找到的路径，但我们必须探索多少个状态才能找到这条路径呢？回想一下在。
- en: my program I was keeping track of the。![](img/1885304785061450828b076e969d139d_27.png)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我的程序一直在跟踪这个。![](img/1885304785061450828b076e969d139d_27.png)
- en: number of states that we've explored so，far and so I can go back to the terminal。and
    see that all right in order to solve，this problem we had to explore 399。![](img/1885304785061450828b076e969d139d_29.png)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探索的状态数量，所以我可以回到终端，看看，好的，为了解决这个问题，我们必须探索399个状态。![](img/1885304785061450828b076e969d139d_29.png)
- en: different states and in fact if I make，one small modification with the program。and
    tell the program at the end when we，output this image I added an argument。![](img/1885304785061450828b076e969d139d_31.png)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的状态，事实上，如果我对程序做一个小的修改，并告诉程序在最后当我们输出这个图像时，我添加了一个参数。![](img/1885304785061450828b076e969d139d_31.png)
- en: called a show explored and if I set show，explored equal to true and rerun this。![](img/1885304785061450828b076e969d139d_33.png)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 称为 show explored，如果我将 show explored 设置为 true 并重新运行这个。![](img/1885304785061450828b076e969d139d_33.png)
- en: program Python may stop i running it on，maze 2 and then I open the maze and
    what。![](img/1885304785061450828b076e969d139d_35.png)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序Python可能停止运行在 maze 2 上，然后我打开迷宫，结果是。![](img/1885304785061450828b076e969d139d_35.png)
- en: you'll see here is highlighted in red，are all of the states that had to be。explored
    to get from the initial state，to the goal depth-first search or DFS。didn't find
    its way to the goal right，away it made a choice to first explore。this direction
    and when it explored this，direction it had to follow every。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这里用红色高亮的是所有必须探索的状态，以便从初始状态到达目标，深度优先搜索（DFS）。没有立即找到目标，它选择首先探索这个方向，当它探索这个方向时，它必须遵循每一个。
- en: conceivable path all the way to the very，end even this long and winding one
    in。order to realize that you know what，that's a dead end and instead the。program
    needed to backtrack after going，this direction it must have gone this。direction
    it got lucky here by just not，choosing this path but it got unlucky。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的路径一直到最后，甚至这个长而曲折的路径。为了意识到，你知道，这是死胡同，程序需要在走这个方向后回溯，它一定是走了这个方向，幸运的是没有选择这条路径，但也不幸地。
- en: here exploring this direction exploring，a bunch of states that didn't need to。and
    then likewise exploring all of this，top part of the graph when it probably。didn't
    need to do that either so all in，all depth-first search here really not。performing
    optimally or in probably，exploring more seats than it needs to it。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里探索了这个方向，探索了一堆不必要的状态，接着又探索了图的上半部分，实际上也没有必要这样做。因此，总的来说，深度优先搜索并没有表现得很理想，可能探索了更多的状态。
- en: finds an optimal solution the best path，to the goal but the number of excites。needed
    to explore in order to do so the，number of steps I had to take that was，much higher。so
    let's compare how would breadth-first，search or BFS do one this exact same。maze
    instead and in order to do so it's，a very easy change the algorithm for DFS。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个最优解决方案是通往目标的最佳路径，但为此需要探索的状态数量，以及我必须采取的步骤数量，都要高得多。所以让我们比较一下，如果宽度优先搜索（BFS）在这个完全相同的迷宫中会怎么做。
- en: and BFS is identical with the exception，of what data structure we use to。represent
    the frontier then in DFS I，used a stack frontier last in first out。whereas in
    BFS I'm going to use aq，frontier first in first out，we're the first thing I add
    to the。frontier is the first thing that I。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DFS和BFS的算法是相同的，唯一的区别是我们用什么数据结构来表示前沿。在DFS中，我使用的是后进先出（LIFO）的栈作为前沿，而在BFS中，我使用的是先进先出（FIFO）的队列，首先加入前沿的就是第一个被探索的。
- en: '![](img/1885304785061450828b076e969d139d_37.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1885304785061450828b076e969d139d_37.png)'
- en: remove so I'll go back to the terminal，rerun this program on the same maze and。now
    you'll see that the number of states，we had to explore was only 77 as。![](img/1885304785061450828b076e969d139d_39.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这些后，我将返回终端，在同一个迷宫上重新运行这个程序，现在你会看到我们需要探索的状态数量只有77……。![](img/1885304785061450828b076e969d139d_39.png)
- en: compared to almost 400 when we used，depth-first search and we can see。![](img/1885304785061450828b076e969d139d_41.png)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当我们使用深度优先搜索时，几乎有400个状态，而我们可以看到……。![](img/1885304785061450828b076e969d139d_41.png)
- en: exactly why we can see what happened if，we open up maze dot PNG now and take
    a。look again yellow highlight is the，solution that breadth-first search found。which
    incidentally is the same solution，the depth-first search found they're。both finding
    the best solution but，notice all the white unexplored cells。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以看到，如果我们打开maze.png，重新查看时，黄色高亮部分是宽度优先搜索找到的解决方案，巧合的是，它也是深度优先搜索找到的解决方案。它们都找到了最佳解决方案，但注意所有未探索的白色单元格。
- en: there was much fewer states that needed，to be explored in order to make our
    way。to the gold because breadth-first search，operates a little more shallowly
    it's。exploring things that are close to the，initial state without exploring things。that
    are further away so if the goal is，not too far away then breadth-first。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了到达金子，所需探索的状态大大减少，因为宽度优先搜索（BFS）操作得较为浅显，它在探索离初始状态较近的东西，而不去探索更远的东西。所以如果目标不太远，那么宽度优先搜索……。
- en: search can actually behave quite，effectively and on a maze that looks a。little
    something like this now in this，case both BFS and DFS ended up finding。the same
    solution but that won't always，be the case and in fact let's take a。look at one
    more example for instance，maze 3 texts in maze 3 text notice that。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索实际上可以非常有效地在一个迷宫中进行，就像这样。在这个例子中，BFS和DFS最终找到了相同的解决方案，但这并不总是如此。实际上，让我们再看一个例子，例如迷宫3。
- en: here there are multiple ways that you，could get from A to B it's a relatively。small
    maze but let's look at what，happens if I use and I'll go ahead and。![](img/1885304785061450828b076e969d139d_43.png)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在迷宫3中，你可以从A到B有多种方式，这是一个相对较小的迷宫，但让我们看看如果我使用……。![](img/1885304785061450828b076e969d139d_43.png)
- en: turn off show explored so we just see，the solution if I use BFS breadth-first。search
    to solve a maze three texts well。![](img/1885304785061450828b076e969d139d_45.png)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭显示已探索状态，这样我们只看到解决方案。如果我使用BFS来解决迷宫3……。![](img/1885304785061450828b076e969d139d_45.png)
- en: then we find a solution and if I open up，the mazey here is the solution that
    we。found it is the optimal one with just，four steps we can get from the initial。state
    to what the goal happens，to be but what happens if we tried to。![](img/1885304785061450828b076e969d139d_47.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们找到一个解决方案，如果我打开迷宫，这里就是我们找到的解决方案，它是最优的，只需四步就能从初始状态到达目标。但如果我们尝试……。![](img/1885304785061450828b076e969d139d_47.png)
- en: use depth-first search or DFS instead，well again I'll go back up to my cue。frontier
    where cue frontier means that，we're using breadth-first search and。![](img/1885304785061450828b076e969d139d_49.png)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用深度优先搜索或DFS，然而我会再次回到我的队列边界，队列边界意味着我们正在使用广度优先搜索。![](img/1885304785061450828b076e969d139d_49.png)
- en: I'll change it to a stack frontier which，means that now we'll be using。depth-first
    search I'll rerun Python，maybe I am and now you'll see that we。![](img/1885304785061450828b076e969d139d_51.png)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把它改为栈边界，这意味着现在我们将使用深度优先搜索，我会重新运行Python，也许我会，现在你会看到我们。![](img/1885304785061450828b076e969d139d_51.png)
- en: find the solution but it is not the，optimal solution this instead is what。our
    algorithm finds and maybe，depth-first search would have found the。solution it's
    possible but it's not，guaranteed that if we just happen to be。unlucky if the we
    choose this state，instead of that state then depth-first。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 找到了解决方案，但这并不是**最优**解决方案，这反而是我们的算法所找到的，也许深度优先搜索能找到解决方案，这有可能，但并不**保证**如果我们正好选择了这个状态，而不是那个状态，那么深度优先搜索就会这样。
- en: search might find a longer route to get，from the initial state to the goal so
    we。do see some trade-offs here where，depth-first search might not find the。optimal
    solution so at that point it，seems like breadth first search is。pretty good is
    that the best we can do，where it's going to find us the optimal。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索可能找到一条更长的路径，从初始状态到目标，所以我们在这里看到一些权衡，深度优先搜索可能找不到**最优**解决方案，因此到那个时候，看起来广度优先搜索是相当不错的，这是否是我们能做的**最好**的选择，它将找到**最优**解。
- en: solution and we don't have to worry，about situations where we might end up。finding
    a longer path to the solution，than what actually exists where the goal。is far
    away from the initial State and，we might have to take lots of steps in。![](img/1885304785061450828b076e969d139d_53.png)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案，我们不必担心可能会找到一条比实际存在的解决方案更长的路径的情况，目标距离初始状态很远，我们可能需要走很多步才能到达。![](img/1885304785061450828b076e969d139d_53.png)
- en: order to get from the initial state to，the goal what ended up happening is that。this
    algorithm BFS ended up exploring，basically the entire graph having to go。through
    the entire maze in order to find，its way from the initial state to the，goal State。![](img/1885304785061450828b076e969d139d_55.png)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从初始状态到达目标，最后发生的事情是这个算法广度优先搜索基本上探索了整个图，必须通过整个迷宫才能找到从初始状态到目标状态的路径。![](img/1885304785061450828b076e969d139d_55.png)
- en: what we ultimately like is for our，algorithm to be a little bit more。intelligent
    and now what would it mean，for our algorithm to be a little bit。more intelligent
    in this case well let's，look back to where breadth-first search。might have been
    able to make a different，decision and consider human intuition in。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**最终**希望的是我们的算法更智能，那么在这种情况下，什么是使我们的算法更智能呢？让我们回顾一下广度优先搜索可能能够做出不同决策的地方，并考虑人类直觉。
- en: this process as well like what might a，human do when solving this maze that
    is。different than what BFS ultimately chose，to do well the very first decision
    point。the BFS made was right here when it made，it five steps and ended up in a
    position。where it had a fork in the road it could，either go left or it could go
    right in。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程就像人类在解决迷宫时可能做的那样，这与广度优先搜索**最终**选择的方式不同，广度优先搜索的第一个决策点正是在这里，它进行了五步，最后到达了一个分岔路口，可以选择左转或右转。
- en: these initial couple steps there was no，choice there was only one action that。could
    be taken from each of those states，and so the search algorithm did the only。thing
    that any search algorithm could do，which is keep following that state after。the
    next day but this，point is where things get a little bit。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最初的几步中没有选择，每个状态只能采取一个动作，因此搜索算法做了唯一能做的事情，就是继续跟随那个状态直到下一个状态，但这一点是事情变得有些不同的时候。
- en: interesting depth-first search that very，first search algorithm we looked at。chose
    to say let's pick one path and，exhaust that path see if anything that。way has
    the goal and if not then let's，try the other way Brett first search，you know what。let's
    explore things that are shallow，close to us first look left and right。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，深度优先搜索这个我们看到的第一种搜索算法选择了一条路径并穷尽那条路径，看看那条路上是否有目标，如果没有，那么就尝试另一条路。广度优先搜索，你知道的，让我们先探索那些浅层的、靠近我们的东西，先看看左右。
- en: then back left and back right someone，and so forth alternating between our。options
    in the hopes of finding，something nearby but ultimately what。made a human doom
    if confronted with a，situation like this of go left or go。![](img/1885304785061450828b076e969d139d_57.png)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后左转再右转，交替我们的选择，希望能找到附近的东西，但最终使人类陷入困境的原因是当面临这样的选择：往左还是往。![](img/1885304785061450828b076e969d139d_57.png)
- en: right well a human might visually see，that all right I'm trying to get to。state
    B which is way up there，and going right just feels like it's。closer to the goal
    like it feels like，going right should be better than going。left because I'm making
    progress towards。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，视觉上可能会看到，我正试图到达B状态，B在那里，往右走似乎更接近目标，感觉上往右走应该比往左走更好，因为我正在朝目标迈进。
- en: '![](img/1885304785061450828b076e969d139d_59.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1885304785061450828b076e969d139d_59.png)'
- en: getting to that goal now of course there，are a couple of assumptions that I'm。making
    here I'm making the assumption，that we can represent this grid as like。a two dimensional
    grid where I know the，coordinates of everything I know that a。is in coordinates
    0 0 and B is in some，other coordinate pair and I know what。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了达到这个目标，我在这里做了一些假设，我假设我们可以将这个网格表示为一个二维网格，我知道所有的坐标，我知道A在坐标(0, 0)，B在其他坐标对上。
- en: coordinate I'm at now so I can calculate，that yeah going this way。that is closer
    to the goal and that，might be a reasonable assumption for。some types of search
    problems but maybe，not in others but for now we'll go ahead。and assume that that
    I know what my，current coordinate pair is and I know。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以计算出是的，往这个方向走更接近目标，这可能是某些类型搜索问题的合理假设，但在其他情况下可能不是。不过，现在我们假设我知道我当前的坐标对。
- en: the coordinate XY of the goal that I'm，trying to get to and in this situation。I'd
    like an algorithm that is a little，bit more intelligent that somehow know。is that
    I should be making progress，towards the goal and this is probably。the way to do
    that because in a maze，moving in the coordinate direction of。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在这种情况下有一个稍微更聪明的算法，它能够知道我应该朝目标前进。这可能是这样做的方式，因为在迷宫中，沿坐标方向移动。
- en: the goal is usually though not always a，good thing and so here we draw a。distinction
    between two different types，of search algorithms uninformed search。and informed
    search uninformed search，algorithms are algorithms like DFS and。BFS the two algorithms
    that we just，looked at which are search strategies。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目标通常，虽然并不总是，是一个好事，所以在这里我们区分两种不同类型的搜索算法：无信息搜索和有信息搜索。无信息搜索算法是像DFS和BFS这样的算法，这两种算法都是我们刚刚看到的搜索策略。
- en: that don't use any problem specific，knowledge to be able to solve the。problem
    DFS and BFS didn't really care，about the structure of the maze or。anything about
    the way that a maze is in，order to solve the problem they just。look at the actions
    available and choose，from those actions，and it doesn't matter whether it's a。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用任何特定于问题的知识来解决问题，DFS和BFS并不在意迷宫的结构或迷宫的任何情况。它们只是查看可用的动作，并从这些动作中选择，而不管当前位置。
- en: maze or some other problem the solution，or the way that it tries to solve the。problem
    is really fundamentally going to，be the same what we're going to take a。look at
    now is an improvement upon，uninformed search we're going to take a。look at informed
    search informed search，are going to be search strategies that。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是迷宫还是其他问题，解决方案或它试图解决问题的方法在根本上都是相同的。我们现在要看看的是对无信息搜索的改进，我们将看看有信息搜索。有信息搜索将是搜索策略。
- en: use knowledge specific to the problem to，be able to better find a solution and
    in。the case of a maze this like problem，specific knowledge is something like if。I'm
    in a square that is geographically，closer to the goal that is better than。being
    in a square that is geographically，further away and this is something we。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 利用特定于问题的知识来更好地找到解决方案，在迷宫这个问题中，特定知识是如果我在一个地理上更靠近目标的方格中，这比在一个地理上更远的方格中要好。
- en: can only know by thinking about this，problem and reasoning about what。knowledge
    might be helpful for our AI，agent to know a little something about。there are a
    number of different types of，informed search specifically first we're。going to
    look at a particular type of，search algorithm called greedy。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: best-first search greedy best-first，search often abbreviated G BFS is a。search
    algorithm that instead of，expanding the deepest nodes like DFS or。the shallowest
    node like BFS this，algorithm is always going to expand the。node that it thinks
    is closest to the，goal now the search algorithm isn't。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: going to know for sure whether it is the，closest thing to the goal because if
    we。knew what was closest to the goal all，the time then we would already have a。solution
    like the knowledge of what is，close to the goal we could just follow。those steps
    in order to get from the，initial position to the solution but if。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: we don't know the solution meaning we，don't know exactly what's closest to the。goal
    instead we can use an estimate of，what's closest to the goal otherwise。known as
    a heuristic just some way of，estimating whether or not we're close to。![](img/1885304785061450828b076e969d139d_61.png)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: the goal and we'll do so using a，heuristic function conventionally called。H
    of n that takes a status input and，returns our estimate of how close we are。to
    the goal so what might this heuristic，function actually look like in the case。of
    a maze solving algorithm where we're，trying to solve a maze what is the。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1885304785061450828b076e969d139d_63.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: heuristic look like well the heuristic，needs to answer a question like between。these
    two cells C and D which one is，better which one would I rather be in if。I'm trying
    to find my way to the goal，well any human could probably look at。this and tell
    you you know what D looks，like it's better even if the maze is a。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: convoluted and you haven't thought about，all the walls D is probably better
    and。![](img/1885304785061450828b076e969d139d_65.png)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: why is the better well because if you，ignore the walls let's just pretend the。walls
    don't exist for a moment and relax，the problem so to speak D just in terms。of
    like coordinate pairs is closer to，this goal it's fewer steps that I would。![](img/1885304785061450828b076e969d139d_67.png)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: need to take to get to the goal as，compared to C even if you ignore the。walls
    if you just know the XY coordinate，of C and the XY coordinate of the goal。and
    likewise you know the XY coordinate，of D you can calculate the D just。geographically
    ignoring the walls looks，like it's better and so this is the。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: heuristic function that we're going to，use and in something called the。Manhattan
    distance one specific type of，heuristic where the heuristic is how。many squares
    are vertically and，horizontally and then left to right so。not allowing myself
    to go diagonally，just either up or right or left or down。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: how many steps do I need to take to get，from each of these cells to the goal。well
    as it turns out D is much closer，there are fewer steps it only needs to。take six
    steps in order to get to that，goal again here ignoring the walls we've。relaxed
    the problem a little bit we're，just concerned with if you do the math。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要多少步才能从这些单元格到达目标。事实证明，D更近，只需要六步就能到达目标，这里忽略墙壁，我们稍微放宽了问题，我们只关心数学运算。
- en: to subtract the X values from each other，and the Y values from each other and。what
    is our estimate of how far we are，away we can estimate the D is closer to。the
    goal than C is and so now we have an，approach we have a way of picking which。node
    to remove from the frontier and at，each stage in our algorithm we're going。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要从每个X值中减去彼此，再从每个Y值中减去彼此。我们估计我们离目标有多远，D比C更接近目标，所以现在我们有了一种选择要从前沿移除哪个节点的方法，在我们算法的每个阶段，我们都会进行。
- en: to remove a node from the frontier we're，going to explore the node if it has
    the。smallest value for this heuristic，function if it has the smallest。Manhattan
    distance to the goal and so，what would this actually look like well。let me first
    label this graph label this，maze with a number representing the。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从前沿移除一个节点时，我们将探索具有此启发式函数最小值的节点，如果它到目标的曼哈顿距离最小。那么，这实际上会是什么样子呢？让我先给这个图标标上标签，把这个迷宫标记为。
- en: value of this heuristic function the。![](img/1885304785061450828b076e969d139d_69.png)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启发式函数的值。![](img/1885304785061450828b076e969d139d_69.png)
- en: value of the Manhattan distance from any，of these cells so from this cell for。example
    we're one away from the goal，from this cell we're two away from the。goal three
    away four away and here were，five away because we have to go one to。the right
    and then four up from，somewhere like here the Manhattan。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何这些单元格的曼哈顿距离值来看。例如，从这个单元格，我们距离目标是1，从这个单元格，我们距离目标是2，3，4，而这里是5，因为我们需要向右走一步，然后从这里向上走四步，曼哈顿距离。
- en: distance is two we're only two squares，though in fact，we're gonna have to take
    a longer path。but we don't know that yet the heuristic。![](img/1885304785061450828b076e969d139d_71.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 距离是2，实际上我们将不得不走更长的路径，但我们还不知道，启发式。![](img/1885304785061450828b076e969d139d_71.png)
- en: is just some easy way to estimate how，far we are away from the goal and maybe。our
    heuristic is overly optimistic it，thinks that yeah we're only two steps。away when
    in practice when you consider，the walls it might be more steps so the。important
    thing here is that the，heuristic isn't a guarantee of how many。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是一种简单的方法来估算我们离目标有多远，也许我们的启发式过于乐观，它认为我们只需两步，而实际上考虑到墙壁时可能需要更多步骤。因此，重要的是启发式并不能保证。
- en: steps it's going to take it is a，estimating it's an attempt at trying to。approximate
    and it does seem generally，the case that the squares that look。closer to the goal
    have smaller values，for the heuristic function then squares。that are further away
    so now using，greedy best-first search what might this。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤的估计是一种尝试去逼近，通常情况下，看起来离目标更近的方格具有更小的启发式函数值，而远离目标的方格则更大。因此，使用贪心最佳优先搜索，这可能是什么呢？
- en: algorithm actually do well again for，these first five steps there's not much。of
    a choice we started this initial，state a and we say all right we have to。explore
    these five states but now we，have a decision point now we have a。choice between
    going left and going，right and before when DFS and BFS would。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 算法表现得很好，对于这前五步，我们没有太多选择，我们从初始状态A开始，表示我们必须探索这五个状态，但现在我们有了一个决策点，我们可以选择向左或向右。
- en: just pick arbitrarily because it just，depends on the order you throw these two。nodes
    into the frontier and we didn't，specify what order you put them into the。frontier
    only the order you take them，out here we can look at 13 and 11 and，say that all
    right。this square is a distance of 11 away，from the goal according to our heuristic。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随便选择，因为这只是取决于你把这两个节点放入前沿的顺序，而我们没有指定你将它们放入前沿的顺序，只是取出它们的顺序。我们可以看看13和11，发现这个方格离目标的距离是11，根据我们的启发式。
- en: according to our estimate and this one，we estimate to be 13 away from the goal。so
    between those two options between，these two choices I'd rather have the 11。I'd
    rather be 11 steps away from the，goal so I'll go to the right we're able。to make
    an informed decision because we，know a little something more about this。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的估计，这个估计我们认为距离目标是13。所以在这两个选项之间，我宁愿选择11。我宁愿距离目标有11步，所以我会向右走，我们能够做出明智的决定，因为我们对这个有更多了解。
- en: problem so then we keep following 10 9 8，between the two 7s we don't really
    have。much of a way to know between those so，then we do just have to make an。arbitrary
    choice and you know what maybe，we choose wrong but that's ok because。now we can
    still say all right let's try，this 7 we say 7 6 we have to make this。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个问题是，我们继续跟随10、9、8，在两个7之间，我们没有太多方法来了解，所以我们必须做一个任意的选择，也许我们选择错了，但没关系，因为我们仍然可以说，好吧，让我们试试这个7，我们说7、6，我们必须做出这个选择。
- en: choice even though it increases the，value of the heuristic function but now。we
    have another decision point between 6，and 8 and between those two and really。we're
    also considering this 13 but，that's much higher between 6 8 and 13。well the six
    is the smallest value so，we'd rather take the 6 we're able to。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这增加了启发式函数的值，但现在我们在6和8之间有另一个决策点，而在这两个值之间，我们还在考虑13，但这在6、8和13之间要高得多。好吧，6是最小的值，所以我们更愿意选择6。
- en: make an informed decision that going，this way to the right is probably better。going
    down so we turn this way we go to，five and now we find a decision point。where
    we'll actually make a decision，that we might not want to make but。there's unfortunately
    not too much of，Oya around this we see four and six four。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 做出明智的决定，选择向右走可能比向下走要好。因此我们转向这条路，走到5，现在我们发现一个决策点，我们实际上可能不想做出这个决策，但不幸的是，在这里没有太多的选择，我们看到4和6，4。
- en: looks closer to the goal right it's，going up and the goal is further up so。we
    end up taking that route which，ultimately leads us to a dead end but。that's okay
    because we can still say all，right now let's try the six and now。follow this route
    that will ultimately，lead us to the goal and so this now is。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更接近目标，它在上升，而目标在更高的地方。所以我们最终选择了那条路线，尽管最终导致我们走进了死胡同，但没关系，因为我们仍然可以说，好吧，现在让我们试试6，然后跟随这条路线，最终带我们到达目标。
- en: how greedy best-first search might try，to approach this problem by saying。whenever
    we have a decision between，multiple nodes that we could explore。let's explore
    the node that has the，smallest value of h of n this heuristic。function that is
    estimating how far I，have to go and it just so happens that。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪最佳优先搜索可能会通过说，每当我们在多个节点之间做决策时，让我们探索h(n)值最小的节点来接近这个问题。这个启发式函数是估算我需要走多远，而正好是这样。
- en: in this case we end up doing better in，terms of the number of states we needed。to
    explore then BFS needed to BFS，explored all of this section and all of。that section
    but we were able to，eliminate that by taking advantage of。this heuristic this
    knowledge about how，close we are to the goal or some。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在需要探索的状态数量上做得更好，比起BFS所需的数量。BFS探索了整个这个区域和那个区域，但我们通过利用这个启发式，即关于我们离目标有多近的知识，能够消除那些。
- en: estimate of that idea so this seems much，better so wouldn't we always prefer
    an。algorithm like this over an algorithm，like breadth-first search well maybe
    one。thing to take into consideration is that，we need to come up with a good heuristic。how
    good the heuristic ism is going to，affect how good this algorithm is and。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的估计看起来好多了，所以我们难道不总是更倾向于使用这样的算法而不是广度优先搜索这样的算法吗？也许需要考虑的一件事是，我们需要提出一个好的启发式。启发式的好坏将影响这个算法的表现。
- en: coming up with a good heuristic can，oftentimes be challenging but the other。thing
    to consider is to ask the question，just as we did with the prior two。algorithms
    is this algorithm optimal，will it always find the shortest path。from the initial
    state to the goal and，to answer that question let's take a。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个好的启发式方法往往是具有挑战性的，但另一个需要考虑的问题是，像我们之前两种算法一样，问这个算法是否最优，它是否总是能找到从初始状态到目标的最短路径。为了解答这个问题，我们来看看。
- en: look at this example for a moment take a，look at this example again we're trying。to
    get from A to B and again I've，labeled each of the cells with their。Manhattan
    distance from the goal the，number of squares up and to the right。you would need
    to travel in order to get，from that Square to the goal and let's。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时看看这个例子。我们尝试从A到B，并且我已标注每个单元格与目标的曼哈顿距离，也就是你需要从该格到目标旅行的平方数。
- en: think about would greedy best-first，search that always picks the smallest。number
    end up finding the optimal，solution what is the shortest solution。and would this
    algorithm find it and the，important thing to realize is that right。here is the
    decision，we're estimated to be 12 away from the，goal and we have two choices we
    can go。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想，贪婪最佳优先搜索总是选择最小数字，是否能找到最优解？什么是最短的解决方案？这个算法会找到吗？重要的是要意识到，在这里我们估计离目标有12步，我们有两个选择。
- en: to the left which we estimate to be 13，away from the goal or we can go up where。we
    estimate it to be 11 away from the，goal and between those two greedy。best-first
    search is going to say the 11，looks better than the 13 and in doing so。greedy
    best-first search will end up，finding this path to the goal but it。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们估计离目标有13步，或者我们可以向上走，估计离目标有11步。在这两者之间，贪婪最佳优先搜索会说11看起来比13更好，因此贪婪最佳优先搜索最终会找到这条通往目标的路径。
- en: turns out this path is not optimal there，is a way to get to the goal using fewer。steps
    and it's actually this way this，way that ultimately involved fewer steps。even
    though it meant at this moment，choosing the worst option between the。two or what
    we estimated to be the worst，option based on the heuristics and so。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这条路径并不最优，有一种方法可以用更少的步骤到达目标，而实际上就是这条路，尽管此时选择了两个中我们估计为最差的选项。
- en: this is what we mean by this is a greedy，algorithm it's making the best decision。locally
    at this decision point it looks，like it's better to go here than it is。to go to
    the 13 but in the big picture，it's not necessarily optimal that it。might find
    a solution when in actuality，there was a better solution available so。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的贪婪算法，它在此决策点上做出了最佳决定。看起来在这里比去13更好，但从大局来看，这不一定是最优的。它可能会找到一个解决方案，而实际上还有更好的解决方案。
- en: we want like we would like some way to，solve this problem we like the idea of。this
    heuristic of being able to estimate，the path the distance between us and the。goal
    and that helps us to be able to，make better decisions and to eliminate。having
    to search through entire parts of，this state space but we would like to。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一种解决这个问题的方法，我们喜欢这种能够估计我们与目标之间距离的启发式，这帮助我们做出更好的决策，消除搜索整个状态空间的需要。
- en: modify the algorithm so that we can，achieve optimality so that it can be。optimal
    and what is the way to do this，what is the intuition here well let's。take a look
    at this problem in this，initial problem greedy best-first search。found us this
    solution here this long，path and the reason why it wasn't great。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望修改算法，以实现最优性，使其能够是最优的。那么实现这一点的方法是什么？直觉是什么？让我们看看这个初始问题，贪婪最佳优先搜索给我们找到了这个长路径，原因在于它并不理想。
- en: is because yes the heuristic numbers，went down pretty low but later on they。started
    to build back up they built back，8 9 10 11 all the way up to 12 in this。case and
    so how might we go about trying，to improve this algorithm well one thing。that
    we might realize is that you know，if we go all the way through this。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为启发式数字下降得很低，但后来又开始回升，回升到8、9、10、11，直到12。那么我们该如何改进这个算法呢？我们可能意识到，如果我们一直走下去。
- en: algorithm through this path and we end，up going to the 12 and we've had to take。this
    many steps like who knows how many，steps that is just to get to this 12 we。could
    have also as an alternative taking，much fewer steps just six steps and，more。12
    so it looks like it's not as good but，it required far fewer steps and it only。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这条路径，最终我们走到12，花费了很多步，谁知道那有多少步，只是为了到达这个12。作为替代，我们可以选择只需六步，就能更快到达12，所以看起来不太好，但确实需要的步骤少得多。
- en: took six steps to get to this 13 versus，many more steps to get to this 12 and。while
    greedy best-first search says oh，well 12 is better than 13 so pick the 12。we might
    more intelligently say I'd，rather be somewhere that heuristic aliy。looks like
    it takes slightly longer if I，can get there much more quickly and。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了到达这个13我花了六步，而到达这个12则需要更多的步骤。虽然贪婪的最佳优先搜索说哦，12比13更好，所以选择12，但我们可能会更智能地说，如果我能更快到达一个看似需要稍长时间的地方，我宁愿选择后者。
- en: we're going to encode that idea this，general idea into a more formal。algorithm
    known as a star search a star，search is going to solve this problem by。instead
    of just considering the，heuristic also considering how long it。![](img/1885304785061450828b076e969d139d_73.png)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个总体思路编码成一个更正式的算法，称为A*搜索。A*搜索将通过不仅考虑启发式，还考虑到达目标的时间来解决这个问题。
- en: took us to get to any particular state，so the distinction is greedy best-first。search
    if I am in a state right now the，only thing I care about is what is the。estimated
    distance the heuristic value，between me and the goal whereas a-star。search will
    take into consideration two，pieces of information you know take into。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我到达任何特定状态所需的步数，因此区分在于贪婪的最佳优先搜索。如果我现在在一个状态中，我唯一关心的是我与目标之间的估计距离，即启发式值，而A*搜索将考虑两条信息。
- en: consideration how far do I estimate I am，from the goal but also how far did
    I。have to travel in order to get here，because that is relevant to so we'll。search
    algorithms by expanding the node，with the lowest value of G of n plus h。of n H
    of n is that same heuristic that，we were talking about a moment ago。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我估计自己离目标有多远，同时也考虑我为了到达这里还需走多远，因为这与我们将要使用的搜索算法相关，它通过扩展具有最低G(n)+h(n)值的节点来进行。H(n)就是我们刚才提到的那个启发式。
- en: that's going to vary based on the，problem but G of n is going to be the。cost
    to reach the node how many steps I，had to take in this case to get to my。current
    position so what is that search，algorithm look like in practice well。let's take
    a look again we've got the，same maze and again I've labeled them。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据问题而有所不同，但G(n)将是到达节点的成本，也就是在这种情况下到达我当前位置所需的步数。那么这个搜索算法在实际中看起来是什么样的呢？让我们再看一下，我们有相同的迷宫，我已经标记好了它们。
- en: with their Manhattan distance this value，is the H of n value the heuristic。estimate
    of how far each of these，squares is away from the goal but now as。we begin to
    explore states we care not，just about this heuristic value but also。about G of
    n the number of steps I had，to take in order to get there and I care。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的曼哈顿距离，这个值是H(n)值，即对每个方格距离目标的启发式估计，但现在当我们开始探索状态时，我们不仅关心这个启发式值，还关心G(n)，我到达那里所需的步数。
- en: about summing those two numbers together，so what does that look like on this
    very。first step I have taken one step and now，I am estimated to be sixteen steps
    away。from the goal so the total value here is，seventeen then I take one more step
    I've。now taken two steps and I estimate，myself to be fifteen away from the goal。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，需要将这两个数字相加。那么在这第一步中，假设我已经走了一步，现在我估计距离目标还有16步。因此这里的总值是17。然后我再走一步，我现在走了两步，估计自己距离目标还有15步。
- en: again a total value of 17 now I've taken，three steps and I'm estimated to be
    14。away from the goal so on and so forth，four steps some estimate of thirteen。five
    steps estimate of twelve and now，here's a decision point I could either。be six
    steps away from the goal with the，heuristic of thirteen for a total of 19。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总值仍然是17，现在我已经走了三步，估计距离目标还有14步，依此类推，四步时估计为13，五步时估计为12，现在这是一个决策点，我可能距离目标六步，启发式值为13，总共为19。
- en: or I could be six steps away from the，goal with the heuristic of eleven with。an
    estimate of seventeen for the total，so between 19 and 17 I'd rather take the。17
    the six plus eleven so so far no，different than what we saw before we're。still
    taking this option because it，appears to be better and I keep taking。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我可能距离目标还有六步，启发式值为11，总估计为17。因此在19和17之间，我宁愿选择17，也就是6加11。到目前为止与之前没有什么不同，我们仍然选择这个选项，因为它看起来更好，我继续选择。
- en: this option because it appears to be，better but it's right about here that。things
    get a little bit different now I，could be fifteen steps away from the。goal with
    an estimated distance of six，so 15 plus six total value of 21。alternatively I
    could be six steps away，from the goal because this is five steps。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项看起来更好，但在这里事情变得有点不同。我可能距离目标有十五步，估计距离为六，所以15加6，总值为21。或者我可能距离目标有六步，因为这是五步。
- en: away so this is six steps away with a，total value of thirteen as my estimate，so
    six plus thirteen。that's nineteen so here we would，evaluate G of n plus H of n
    to be。nineteen six plus thirteen whereas here，we would be 15 plus six or 21 and
    so the。intuition is 19 less than twenty-one，pickier but the idea is ultimately
    I'd。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里距离目标有六步，总值为十三，作为我的估计，所以六加十三是十九。在这里，我们会评估G(n)加H(n)为十九，六加十三，而这里是15加六或21，因此直觉上是19小于21，但最终的想法是我。
- en: rather be having taken fewer steps get，to a thirteen then having taken fifteen。steps
    and be at a six because it means，I've had to take more steps in order to。get there
    maybe there's a better path，this way so instead we'll explore this。route now if
    we go one more this is，seven steps plus 14 is twenty-one so。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在减少步数的情况下，走到十三步比走到六步要好，因为这意味着我为了到达那里必须走更多的步数，可能有更好的路径。因此我们现在将探索这条路线，如果我们再走一步，这是七步加14是二十一。
- en: between those two it's sort of a toss-up，we might end up exploring that one。anyways
    but after that as these numbers，start to get bigger in the heuristic。values and
    these heuristic values start，to get smaller you'll find that will。actually keep
    exploring down this path，and you can do the math to see that at。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两者之间，结果有点难以预测，我们可能会最终探索那个。不管怎样，随着这些数字在启发式中的增大，启发式值开始变小，你会发现实际上会继续沿着这条路径探索，你可以计算一下。
- en: every decision point a star search is，going to make a choice based on the sum。of
    how many steps it took me to get to，my current position and then how far I。estimate
    I am from the goal so what we，did have to explore some of these states，fact。an
    optimal solution it did find us the，quickest possible way to get from the。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个决策点，A*搜索将基于我到达当前位置所需的步数之和，以及我估计离目标有多远来做出选择。因此我们必须探索一些状态，实际上找到的最佳解决方案是我们从中获取的最快方法。
- en: initial state to the goal and it turns，out that a star is an optimal search。algorithm
    under certain conditions so，the conditions are H of n my heuristic。needs to be
    admissible what does it mean，for a heuristic to be admissible well a。heuristic
    is admissible if it never，overestimates the true cost H of n。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从初始状态到目标，事实证明A*是一个在某些条件下的最佳搜索算法。这些条件是H(n)，我的启发式需要是可接纳的。启发式可接纳意味着它永远不会高估真实成本H(n)。
- en: always needs to either get you exactly，right in terms of how far away I am or。it
    needs to underestimate so we saw an，example from before where the heuristic。value
    was much smaller than the actual，cost it would take that's totally fine。but the
    heuristic value should never，overestimate it should never think that。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总是需要在我离目标有多远上，要么精确到位，要么低估。所以我们之前看到的例子中，启发式值远小于实际成本，这是完全可以的，但启发式值绝不能高估，绝不能认为。
- en: I'm further away from the goal than I，actually am and meanwhile to make a。stronger
    statement H of n also needs to，be consistent and what does it mean for。it to be
    consistent mathematically it，means that for every node which we'll。call n + successor
    the node after me，that I'll call n prime where it takes a。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我离目标实际上更远，而与此同时，H(n)也需要一致性。那么在数学上，一致性意味着对于每个节点，我们称之为n+后继，即我之后的节点，我称之为n'，在此步骤的成本为C。
- en: cost of C to make that step the，heuristic value of n needs to be less。than or
    equal to the heuristic value of，n prime plus the cost so it's a lot of。math but
    in words what that ultimately，means is that if I am here at this state。right now
    the heuristic value from me to，the goal shouldn't be more than the。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: n的启发式值需要小于或等于n'的启发式值加上成本，因此这有很多数学，但用言语来说，这最终意味着如果我现在在这个状态，离目标的启发式值不应该超过。
- en: heuristic value of my successor the next，place I could go to plus however a
    lot。much it would cost me to just make that，step from one step to the next step
    and。so this is just making sure that my，heuristic is consistent between all of。these
    steps that I might take so as long，as this is true then a star search is。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我接替者的启发式价值，接下来我可以去的地方，以及这将花费我多少。仅仅从一步迈向下一步，所以这只是确保我的启发式在我可能采取的所有步骤之间是一致的，只要这一点成立，那么A*搜索就是。
- en: going to find me an optimal solution and，this is where much of the challenge
    of。solving these search problems can，sometimes come in that a star search is。an
    algorithm that is known and you could，write the code fairly easily but it's。choosing
    the heuristic that can be the，interesting challenge the better the。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我找到一个最优解决方案，这也是解决这些搜索问题的挑战所在。有时，A*搜索是一个已知算法，你可以相对容易地编写代码，但选择启发式可能是有趣的挑战，启发式越好。
- en: heuristic is the better I'll be able to，solve the problem in the fewer states。that
    I'll have to explore and I need to，make sure that the heuristic satisfies。these
    particular constraints so all in，all these are some of the examples of。search
    algorithms that might work and，certainly there are many more than just。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式越好，我就能在更少的状态中解决问题。我需要确保启发式满足这些特定约束，所以总的来说，这些是一些可能有效的搜索算法，当然还有许多其他算法。
- en: this a star for example does have a，tendency to use quite a bit of memory。so
    there are alternative approaches to a，star that ultimately use less memory。than
    this version of a star happens to，use and there are other search。algorithms that
    are optimized for other，cases as well but now so far we've only。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，A*确实有使用大量内存的倾向。因此，存在替代方法，最终使用比此版本A*更少的内存，还有其他搜索算法也针对其他情况进行了优化，但到目前为止我们只讨论了。
- en: been looking at search algorithms where，there's one agent like I am trying to。find
    a solution to a problem I am trying，to navigate my way through a maze I am。trying
    to solve a 15 puzzle I am trying。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在研究搜索算法，其中有一个代理，比如我正在尝试寻找一个问题的解决方案，我正在试图通过迷宫导航，我正在尝试解决15拼图，我正在尝试。
