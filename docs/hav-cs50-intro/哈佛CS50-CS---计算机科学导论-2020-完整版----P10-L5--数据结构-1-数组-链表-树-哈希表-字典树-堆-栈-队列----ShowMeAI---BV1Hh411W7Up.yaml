- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P10：L5- 数据结构 1（数组、链表、树、哈希表、字典树、堆、栈、队列） - ShowMeAI
    - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P10：L5- 数据结构 1（数组、链表、树、哈希表、字典树、堆、栈、队列） - ShowMeAI
    - BV1Hh411W7Up
- en: '![](img/0a786619a8ddec04544d001ff89412ad_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_0.png)'
- en: '![](img/0a786619a8ddec04544d001ff89412ad_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_1.png)'
- en: all right。![](img/0a786619a8ddec04544d001ff89412ad_3.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都好。![](img/0a786619a8ddec04544d001ff89412ad_3.png)
- en: this is cs50 and this is week five，recall that last week in week four we。introduced
    a few new building blocks，namely pointers and spoke in great。detail about how
    you can now manipulate，a computer's memory and begin to do。things at a lower level
    with it well，today we'll sort of use those basic，building blocks to start。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CS50，这是第五周，回想一下上周在第四周我们介绍了一些新的构建模块，即指针，并详细讲述了如何现在操作计算机的内存，并开始以更低的层次进行处理，今天我们将使用这些基本构建模块来开始。
- en: creating things called data structures，in the computer's memory it turns out。that
    once you have this ability to refer，to different locations in the computer's，your
    own。custom shapes your own custom data，structures as they're called，and indeed
    we'll start doing that by。rolling back for just a moment，to where we first saw
    a data structure。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建称为数据结构的东西，在计算机内存中，结果是，一旦你拥有了引用计算机中不同位置的能力，你可以创建自己的自定义形状，称为自定义数据结构，确实我们将通过回顾一下第一次看到数据结构的地方开始。
- en: in week two so we're calling week two，which was our second week of playing。with
    c we introduced you to the notion，of an array and an array is just a。contiguous
    sequence of memory，in which you can store a whole bunch of。integers back to back
    to back or maybe a，back，and those uh arrays might have been。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二周，所以我们称之为第二周，那是我们玩C语言的第二周。我们向你介绍了数组的概念，数组只是内存的一个连续序列，你可以在其中存储一堆整数，逐个存储，或者可能是一个后面接着另一个，这些数组可能已经。
- en: represented pictorially like this so，this would be an array of size 3 and。![](img/0a786619a8ddec04544d001ff89412ad_5.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图示表示，所以这将是一个大小为3的数组。![](img/0a786619a8ddec04544d001ff89412ad_5.png)
- en: of，it，start to，bump up against a problem but also solve，a problem today suppose
    that you want to。add another number to this array but，you've only had the forethought
    to。create an array of size three the catch，with arrays in c，is that they're not
    really easily。resizable again you all know that you，have to decide in advance
    how big the，array is going to be。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它，开始遇到问题，但也解决了问题，今天假设你想向这个数组添加另一个数字，但你只考虑创建一个大小为三的数组，数组在C语言中的麻烦是，它们并不容易调整大小，你们都知道，你必须提前决定数组的大小。
- en: so if you sort of change your mind later，or your program's running long enough，it。you're
    kind of in a bind like，number four，into this array you would ideally just，array。and
    continue about uh your business but，the catch with an array is that。that chunk
    of memory is not uh it，doesn't exist in a vacuum recall if we。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你后来改变主意，或者你的程序运行得够久，你就会发现自己陷入困境，比如，第四个，理想情况下你会将其放入这个数组，然后继续你的事情，但数组的麻烦在于，那块内存并不是独立存在的，回想一下如果我们。
- en: sort of zoom out and look at all of your，computer's memory。![](img/0a786619a8ddec04544d001ff89412ad_7.png)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 放大一点，看看你计算机的所有内存。![](img/0a786619a8ddec04544d001ff89412ad_7.png)
- en: this byte this byte and a whole bunch of，other bytes might very well be in use
    by。other variables or other aspects of your，discussion，suppose that the program
    in question has。one array of size three，containing the integers one two three。and
    then suppose that your same program，has a string，somewhere in the code that you've，world。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个字节以及其他许多字节可能很可能被其他变量或你讨论的其他方面使用，假设相关程序有一个大小为三的数组，包含整数一二三，然后假设你同一个程序，在代码的某处有一个字符串，你已经，世界。
- en: by chance，may very well be an h-e-l-l-o，comma space w-o-r-l-d backslash zero。and
    there might be free memory so to，speak memory you could use。that's filled with
    garbage values and，garbage isn't bad it just means that you，values are。or were
    there so there is free space so，to speak each of these oscars represents。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然间，可能是一个h-e-l-l-o，逗号 空格 w-o-r-l-d 反斜杠零。并且可能有“自由内存”，可以使用。那些被垃圾值填充的内存，垃圾并不是坏事，它只是意味着你，值是。或者曾经在那里，因此有“自由空间”，每一个oscar都代表。
- en: effectively free space，with some garbage value there remnants，may be of some。execution
    past but the problem here is，that it you，where you might。want to put it so what's
    the solution if，we have this array of size three。containing three integers one
    two three，but it's kind of been painted into a，corner whereby h-e-l-l。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的自由空间，带着一些垃圾值的残余，可能是某些。过去执行的遗留问题，但这里的问题是，你可能想放置它的位置。那么如果我们有一个大小为三的数组，包含三个整数一、二、三，但它有点被逼到墙角，H-E-L-L。
- en: and so forth are already immediately，there，without sacrificing the h and that。doesn't
    really feel like a solution，problem，are we sort of completely out of luck，can
    you just not。add a number to an array in a situation，like this，or is there a solution
    perhaps that。comes to mind even if you've never，programmed before，if on the screen
    there sort of the lay，um。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，已经立刻在那里，没有牺牲h，这确实不觉得像是解决方案，问题是我们是不是完全没希望？在这种情况下，你能否向数组添加数字，或者有没有什么解决方案即使你从未编程过，屏幕上有那种布局。
- en: i would say that um maybe you could，and，create a new array but that's one。size
    bigger or one element bigger and，then add that new element。yeah that's really
    good intuition after，all there's all these oscars on the。screen right now which
    again represent，garbage values or in turn。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说，嗯，也许你可以创建一个新数组，但大小大一个或多一个元素，然后添加那个新元素。是的，这真的是个不错的直觉，毕竟屏幕上有所有这些垃圾值。
- en: free space so i could put one two three，four over here，i could put one two three
    four down here。so we sort of have some flexibility but，santiago is exactly right。intuitively
    all we really need to do is，let's focus only on，four of the available spots a
    new array。of size four if you will which initially，has these four garbage values
    but that's。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 空间，我可以把一、二、三、四放在这里，或者放在这里。所以我们有一些灵活性，但圣地亚哥说得对。直观上，我们只需要专注于新数组中的四个可用位置。这个大小为四的数组最初有这四个垃圾值，但那是。
- en: okay because the santiago also notes we，array，one two three into the new array
    and。heck maybe we can now even，free the memory from the original ray。much like
    we could if we used malloc，and that leaves us then of course with。just an array
    of size four with that，fourth garbage value but now。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为圣地亚哥也提到我们将一、二、三放入新数组中。也许我们现在甚至可以释放原始数组的内存。就像如果我们使用`malloc`一样，这当然会留给我们一个大小为四的数组，带有第四个垃圾值，但现在。
- en: we do have room for like the number four，itself，so it would seem that there
    is a。solution to this problem that doesn't，violate the definition of an array
    again。the only definition of an array really，is that the memory must be contiguous。you
    can't just pop the four，anywhere in the computer's memory it has。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有空间放置数字四，所以看起来这个问题是有解决方案的，不违反数组的定义。数组的唯一定义实际上是内存必须是连续的。你不能随便在计算机的内存中放置四。
- en: to become right after your existing，memory if this whole thing。this whole structure
    is indeed going to，still be an array，but i worry that that might have。cost us
    a bit of time and in fact let me，go ah**d and open up on the screen here。in just
    a moment a question that you're，all welcome to buzz，in for what would be the running
    time。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 成为现有内存之后，如果整个结构确实还是数组，但我担心这可能会花费我们一些时间，实际上让我，继续打开屏幕上的一个问题，欢迎你们参与，插入的运行时间会是什么。
- en: ahead and，reveal the poll question here feel free，to go to the usual url which
    brian if。you wouldn't mind copying pasting as，usual，what do you think the running
    time is of，inserting。![](img/0a786619a8ddec04544d001ff89412ad_9.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在揭示投票问题，随时可以去常用的URL，布莱恩，如果你不介意按习惯复制粘贴，你认为插入的运行时间是多少。
- en: into an array inserting into an array，recall in the past we've talked about，arrays
    in terms of。time we're really talking about，inserting into them and if we take
    a，like。80 some percent of you feel that it's，linear time big o of，n whereby it
    might take as many as n。steps to actually，insert into an array five percent of
    you，propose n log n seven percent of you。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 插入数组，回想过去我们讨论过数组时的时间，我们实际上在谈论插入它们。如果我们取一个，像80%的人觉得是线性时间O(n)，插入到数组中可能需要多达n步，5%的人提议是n
    log n，7%的人则。
- en: n squ*red and then two and five percent，well，so this is a kind of an interesting
    mix，the past。and we talked about searching recall，that we typically achieve，uh
    big o of log n that's really good。unfortunately，if we have to do what santiago
    proposed，and actually copy all of the elements。from the old array，into the new
    array it's going to indeed，take us as many as。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: n 的平方，然后是两和五个百分点，这是一种有趣的混合，过去。我们谈到了搜索回忆，通常我们能达到，呃，O(log n)，这真的很好。不幸的是，如果我们必须执行圣地亚哥所提议的，实际上把所有元素复制。
    从旧数组到新数组，这确实会花费我们多达 n 步。
- en: n steps because we have to copy each of，the original elements one two three。over
    into the new array which is going，to be of size n，plus one so it's on the order
    of n steps。in total so the running time then of，inserting into an array，in terms
    of an upper bound at least is。going to be indeed big o of n，because you've got
    to copy potentially，all of those elements over。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们必须将每个原始元素一二三。复制到新的数组中，新的数组大小为 n，加一，因此总的步骤是 n 步。所以插入到数组的运行时间，至少在上限方面，将确实是
    O(n)，因为你必须潜在地复制，所有那些元素。
- en: but perhaps we might feel differently，if we consider a lower bound on the，running
    time of insert。what might the lower bound of insert b，when it comes to an array
    again omega。notation is what we can use here，how many steps maybe in the best
    case。might it take me to insert a value into，an array we won't do a poll for this
    one。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们考虑插入的运行时间下限，我们可能会有不同的看法。数组的插入下限可能是什么？在这里我们可以使用 Ω 符号，最好的情况可能需要多少步。插入一个值到数组中，我们不会对此进行投票。
- en: brian why don't we go ah**d and call in。![](img/0a786619a8ddec04544d001ff89412ad_11.png)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱恩，为什么我们不去**做**一下电话呢。![](img/0a786619a8ddec04544d001ff89412ad_11.png)
- en: a hand for this what's a lower bound on，the running time of insert ryan what
    do，you think。well the best case scenario would be if，there's only one element
    in the array so，you would just have。into the array，yeah so if you've got an array
    and let，me emphasize that's already。empty whereby you have room for the new，element
    then indeed，omega of one constant time is all you。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有人能说说插入运行时间的下限吗，瑞安，你觉得呢？好的，最好的情况是数组中只有一个元素，因此你只需。放入数组，没错，所以如果你有一个数组，让我强调一下，它已经。空着，可以容纳新的元素，那么确实，Ω(1)
    常数时间就是你所需的。
- en: in the array，and it doesn't matter how large the，array is maybe it's a size。four
    but you've only put one number in。![](img/0a786619a8ddec04544d001ff89412ad_13.png)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中，无论数组多大，也许它的大小是四，但你只放入了一个数字。![](img/0a786619a8ddec04544d001ff89412ad_13.png)
- en: it that's okay because you can，immediately put the new number in place。![](img/0a786619a8ddec04544d001ff89412ad_15.png)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这没关系，因为你可以立即将新数字放入位置。![](img/0a786619a8ddec04544d001ff89412ad_15.png)
- en: recall that arrays support random access，and just jump，to any location in so-called
    constant。time in just one step，and is not，full then yes the lower bound on the。insertion
    into an array is going to be，constant time omega of one but as we saw。in santiago
    situation whereby you have，an array that's already filled with。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组支持随机访问，可以直接跳到任何位置，所谓的常数。时间只需一步，如果不满，那么是的，插入到数组中的下限将是，常数时间 Ω(1)，但正如我们在圣地亚哥的情况中看到的那样，你会有一个已经填满的数组。
- en: elements and you want to add another，well in that case then upper bound is，indeed
    going to be。big o of n because you have to do the，over，from one to the other now
    those of you，java。you might be familiar with the phrase，vector a vector is kind
    of like an array。that can be resized can grow and shrink，that's not what arrays
    are in c arrays。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 元素，如果你想再添加一个，在这种情况下，上限确实是 O(n)，因为你必须从一个转移到另一个。现在你们中的一些，Java。可能对“向量”这个短语很熟悉，向量有点像可以调整大小的数组，可以增大或缩小，这在
    C 中并不是数组的性质。
- en: in c are just contiguous blocks of，memory with values back to back to back。but
    once you decide on their size that，is it，you're going to have to resize it。essentially
    yourself they're not going，to automatically，grow for you so an array was。the first
    and really the simplest of the，data structures we'll see。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，数组只是连续的内存块，值一个接一个。 但是一旦你决定了它们的大小，那就是它了，你必须自己调整大小。它们不会自动为你增长，因此数组是。我们看到的第一个，也是最简单的数据结构。
- en: but it's also not nearly as powerful as，what we can do now that we have access。to
    a computer's memory，today we're going to start to leverage，these things called
    pointers the。addresses by which we can refer to，locations in memory and we're
    going to。start to stitch together some fancier，data structures first one-dimensional。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并没有我们现在可以做的强大，因为我们可以访问计算机的内存。今天我们将开始利用这些称为指针的东西，即我们可以引用内存位置的地址，我们将开始拼凑一些更复杂的数据结构，首先是单维的。
- en: in some sense then two-dimensional in，some sense by using some very basic。building
    blocks recall these three，pieces of syntax。![](img/0a786619a8ddec04544d001ff89412ad_17.png)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，这是二维的，在某种意义上，通过使用一些非常基本的构建块，回想一下这三种语法。![](img/0a786619a8ddec04544d001ff89412ad_17.png)
- en: from the past weeks struct recall，is this mechanism this keyword in c，whereby
    we can define our own。structures in memory we saw one for a，a name，and a number
    in something like a phone，book and。you've seen the dot operator the dot，operator
    was how we go inside of such a，structure and get at。dot name or dot number the
    specific，variables inside of the struct。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从过去几周的结构回忆来看，这个机制是C语言中的这个关键字，我们可以在内存中定义自己的结构。我们看到一个包含姓名和电话号码的例子，就像电话簿一样。你已经见过点运算符，点运算符是我们如何进入这样的结构并获取点名称或点数字，即结构内部的特定变量。
- en: and then last week recall we saw the，star operator，whereby the dereference operator
    which。colloquially means，go to this particular address so just by，using these
    three。ingredients are we going to be able to，now build up our own custom data，arrays。and
    can ultimately help us solve，problems more efficiently and in fact。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在上周的回忆中，我们看到了星号运算符，这是解引用运算符，口语上意思是去这个特定地址。因此，仅仅使用这三种成分，我们现在能够构建自己的自定义数据数组。这最终能帮助我们更有效地解决问题，实际上解决了一些数组的问题，而这些问题可以说是什么呢？
- en: this is such a common technique in，programming in c，star，intentionally，usage，today。it's
    pretty much building blocks past，but we're going to use these building。blocks
    now in new ways to start solving，problems differently and we'll first do。this
    by way of something called，list，is going to be a data structure that。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这在C语言编程中是如此常见的技巧，星号的使用，今天几乎是构建块的过去。但我们将以新的方式使用这些构建块，以开始不同地解决问题，首先通过一种称为列表的数据结构。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_19.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_19.png)'
- en: solves some of the problems with an，array and what's a problem arguably。well
    if it takes big o of n steps to，insert into an array，frankly that's kind of annoying
    that's。kind of expensive because over time if，lots of data，you're the googles
    of the world the。twitters of the world it's fine if you，array，for the sake of
    efficient searching。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果向数组中插入需要大O的N步，坦率地说，这有点烦人。这种开销相当大，因为随着时间的推移，如果有大量数据，像谷歌或推特这样的公司，如果你的数组是为了高效搜索而设计，那是没问题的。
- en: which recall was big o of log n if we，use something like binary search and，keep
    everything sorted。but it's going to be pretty painful if，every time you want to
    add。another tweet to the array or some other，webpage to the array，depending on
    what the problem is that。you're solving you might potentially as，santiago notes
    have to copy。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，如果我们使用类似二分搜索的方式并保持一切排序，则是大O的对数N。但如果每次你想在数组中添加另一个推文或其他网页时，这将是非常痛苦的，根据你解决的问题，你可能需要如Santiago所提到的那样进行复制。
- en: all of the contents of your original，smaller array，into a new bigger array just
    to add more。tweets or more web pages or the like，so a linked list is going to
    be a data。structure that's more dynamic，whereby you can grow and shrink the data。structure
    without having to touch，all of the original data and move it，from old location
    to new。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表将把你原始小数组的所有内容放入一个新的更大的数组中，只是为了添加更多的推文或网页等。因此，链表将是一个更动态的数据结构，你可以在不触及所有原始数据的情况下，增减数据结构，而不必从旧位置移动到新位置。
- en: so what might like what might this look，like well let's consider again our。computer's
    memory and let's propose that，i want to store those same values again。so like
    the number one and just for the，sake of discussion，suppose that it's in my computer's。memory
    at address ox123，ox just means it's a hexadecimal number。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这可能看起来像什么呢？好吧，让我们再考虑一下计算机的内存，假设我想再次存储那些相同的值。比如数字1，为了讨论方便，假设它在我计算机的内存中，地址为0x123，0x表示这是一个十六进制数字。
- en: one two three is completely arbitrary i，discussion，so let me stipulate that
    that's where。the number one happens to be in the，computer's memory，in this new
    solution to the problem of。storing lots of data，suppose i want to store number
    two maybe，it's at address ox456。and then suppose i want to store number，three
    suppose it's at address，ox 789 so notice deliberately。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一二三是完全任意的，我的讨论，因此让我规定这就是数字一在计算机内存中的位置，在这个新解决方案中存储大量数据，假设我想存储数字二，也许它在地址ox456。那么假设我想存储数字三，假设它在地址ox789，所以故意注意。
- en: these numbers are spread out in the，computer's memory because after all the，arrays。is
    that you might have hello world or，program，kind of in the way so if i'm proposing，and
    then two。and then three that's fine plop them，anywhere you want，and you don't
    have to worry about where。there is already existing values，instead you can just
    put these values，where there is room。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字分散在计算机的内存中，因为毕竟数组。你可能有hello world或程序，这有点碍事，因此如果我提议，然后二，然后三，那很好，随便放在你想要的地方，你不必担心已经存在的值在哪里，相反，你可以把这些值放在有空余的地方。
- en: the problem though is that if you just，start plopping values like one two three，memory，values。right
    you might know where one is but it，no longer suffices to just。look one location
    to the right to find，the next value or add two。to find the next value after that
    in an，array everything is contiguous。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如果你只是开始随便放值，比如一二三，内存值。对，你可能知道一在哪里，但仅仅向右看一位置已不足以找到下一个值或加二找到下一个值，在数组中，一切都是连续的。
- en: but if we instead start to treat the，computer's memory as just a canvas，we want。that's
    fine so long as we can somehow，second，to the third irrespective of all the。other
    stuff that's cluttering up the，computer's memory，so in fact let me propose that
    we do。this by maybe stealing a bit more space，from the computer，so rather than
    use just enough memory to。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们开始将计算机的内存视为一个画布，我们想要。只要我们能够以某种方式第二到第三，无论其他杂乱的东西如何，这都是可以的。因此，事实上让我建议我们通过可能从计算机中偷取更多空间来做到这一点，而不是仅使用足够的内存来。
- en: store one two and three，let me store twice as much information，in addition to
    every number that i。data，let me store a little metadata so to，speak values that
    i don't fundamentally。care about but that are going to help me，keep track of my
    actual data。and let me propose that in this box here，i literally store the value。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储一二和三，让我存储两倍的信息，除了每个数字的数据，让我存储一点元数据，可以说是我不根本关心但将帮助我跟踪实际数据的值。让我建议在这个框中，我实际存储这个值。
- en: ox456 again it's written in hexadecimal，but that's just the number that's the。address
    of somewhere else in memory，in this box let me propose that i store，ox 789。and
    in this box let me arbitrarily say，ox0，i done this，even if you've never seen this
    structure。that's evolving to be what's called a，linked list，why have i just done
    what i've done in。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ox456再次以十六进制书写，但这只是数字，它是内存中其他地方的地址，在这个框中让我提出我存储ox789。在这个框中让我随意说ox0，我这样做，即使你从未见过这种结构，这正在演变成所谓的链表，为什么我刚刚做的就是这样。
- en: addition to storing one two and three，respectively i'm also now storing ox456。in
    an additional chunk of memory and ox，789 in an additional chunk of memory but，why。so
    that we know how the first element，like relates to the second or how，they're linked
    together。exactly between the first and second，yeah so now i'm using essentially
    twice，as much space to store。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分别存储一二和三外，我现在还在额外的内存块中存储ox456和ox789，但为什么。这样我们就知道第一个元素是如何与第二个元素相关的，或者它们是如何连接在一起的，确切地说在第一个和第二个之间，所以现在我实际上使用了两倍的空间来存储。
- en: respectively，storing，a pointer to the next element，in the thing i'll now think
    of as a list。so this is ox456 because the number two，care about，lives at ox456
    this number is ox 789，i care about。is that address ox 789 so it's just a，helpful
    way now of kind of leaving。myself breadcrumbs so that i can plop，the one the two
    the three anywhere i。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 分别存储指向下一个元素的指针，现在我会将其视为一个列表。这是ox456，因为数字二在ox456上，我关心的是ox789，所以这只是一个有用的方式，现在我可以留给自己线索，以便我可以随意放置一、二、三。
- en: want in the computer's memory，wherever there's available space and。still figure
    out how to get from one，to the other to the other and we've。actually seen some
    of this syntax before，bits，that's just uh the technical uh that's，called。null
    n-u-l-l which we introduced last，week is a special symbol。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想要在计算机内存中，随处都有可用空间，并且仍然想办法从一个到另一个，然后再到另一个，我们实际上之前见过一些这样的语法，位，这只是技术术语，称为 null（空），我们上周介绍过，这是一个特殊符号。
- en: indicating that something has gone wrong。![](img/0a786619a8ddec04544d001ff89412ad_21.png)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表示某些地方出现了问题。![](img/0a786619a8ddec04544d001ff89412ad_21.png)
- en: with memory or you're out of space，it's sort of the absence of an address c。guarantees
    that if you use ox0，of any，useful address there but you know what。again like last
    week this is sort of，getting way into the weeds i don't，really care about ox，
    *****。so let's just kind of abstract this away，and start thinking about this really
    as。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存有关，或者你没有空间，这种情况类似于地址缺失的情况，保证如果你使用的是任何有用的地址，但你知道，像上周一样，这种情况有点复杂，我并不太关心 0x，*****。所以让我们先抽象掉这一点，开始真正思考这个问题。
- en: a list of numbers that are somehow。![](img/0a786619a8ddec04544d001ff89412ad_23.png)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一组数字以某种方式。![](img/0a786619a8ddec04544d001ff89412ad_23.png)
- en: linked together underneath the hood the，links are implemented by way of，addresses
    or pointers。those low level numbers like ox123 456，789，but pictorially it kind
    of suffices for。us to just start thinking of，linked，list as being a collection
    of nodes。![](img/0a786619a8ddec04544d001ff89412ad_25.png)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，链接是通过地址或指针实现的。这些低级数字，如 0x123456789，但从图示上看，我们只需开始将链接列表视为节点的集合。![](img/0a786619a8ddec04544d001ff89412ad_25.png)
- en: so to speak n-o-d-e that are connected，via pointers，so a node is just a generic
    computer。science term that refers to some kind of，about，what i care about here
    is a number and a，this。is a linked list and each of these，rectangles represents
    a node，ultimately，struct。but let me pause here to see first if，there are any questions，about
    the structure we've built up any。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，节点通过指针连接，因此节点只是一个通用的计算机科学术语，指代某种东西，我在这里关心的是一个数字，这就是一个链接列表，每个矩形代表一个节点，**最终**，结构。但让我在此暂停，看看是否有任何问题，关于我们所构建的结构。
- en: questions about，this thing called a linked list before，we see it。in some code
    brian yeah a question came，in in the chat asking isn't this kind of。a waste of
    memory that we're now using，too，yeah really good observation isn't this。kind of
    a waste of memory and that we're，storing all of these addresses in。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个叫做链接列表的东西之前有没有问题，我们在一些代码中看到它，布莱恩，是的，聊天中有个问题问，难道这不是一种浪费内存吗？对，确实是个很好的观察，这不就是在浪费内存吗，我们存储了所有这些地址。
- en: addition to the numbers one two three，that we care about，yes and in fact that
    is exactly the。price we are paying and this is going to，be thematic this week
    last week and。really every week thereafter，anytime we solve a problem in cs and，programming
    in particular。there's always going to be some price，trade-off，so if a moment ago
    it was unacceptable。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们关心的数字一、二、三，没错，实际上这正是我们付出的代价，这将是本周、上周以及之后每周的主题，每当我们在计算机科学和编程中解决问题时，总会有某种代价权衡，因此如果刚才是不可接受的。
- en: that inserting，into an array is in big o of n because，man that's going to take
    so many steps，array。into the new array if that is，reasons or，whatever the problem
    is that you're。![](img/0a786619a8ddec04544d001ff89412ad_27.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中插入的时间复杂度是 O(n)，因为，哇，这将需要很多步骤，将数组插入到新数组中，如果这是原因，或者，任何你正在处理的问题。![](img/0a786619a8ddec04544d001ff89412ad_27.png)
- en: solving well that's fine，you can solve that problem and now have，your numbers。anywhere
    in memory without having to，move the existing numbers anywhere else。thereby saving
    yourself time，but the price you're going to pay indeed。is more space so at that
    point it kind，of depends what's more important to you。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决得很好，那就不错，你可以解决那个问题，现在你的数字可以在内存中的任何地方，无需将现有数字移动到其他地方，从而节省了时间，但你付出的代价确实是更多的空间，因此在这一点上，这取决于什么对你更重要。
- en: the computer's time your human time or，maybe the space or the cost of the space。the
    more memory that you might really，need to literally buy，for that computer so this
    is going to be。and time，is omnipresent really in programming，well let's consider
    how we might，recall that。when we last saw structs in c we did，something like this
    to define a person。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的时间、你的人类时间，或者，也许是空间或空间的成本。你可能真的需要为那台计算机购买更多的内存，所以这将会是。时间在编程中无处不在，嗯，让我们考虑一下如何。回想一下我们上次在C语言中看到结构体时，我们做了这样的事情来定义一个人。
- en: as having two things associated with，them a name and a number so。today we don't
    care about persons and，names and numbers we care about these，nodes。so let me go
    ah**d and rewind from that，erase that and let's instead say that。every node in
    this structure renaming，person as well to node，an int。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个与之关联的事物，一个名字和一个数字，所以。今天我们不关心人、名字和数字，我们关心的是这些，节点。所以让我去**d**并倒带，抹去那个，让我们说每个节点在这个结构中重命名，person也作为节点，一个整数。
- en: in our case here and i've left room for，one other value，because we ultimately
    need to be able to。store that second piece of data，that second piece of data is
    going to be，a pointer it's going to be。express，obvious，but we laid the foundation
    last week，with pointers。how could i describe this structure as，having a pointer
    to，another such structure any thoughts on。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里，我留出了一个其他值的空间，因为我们最终需要能够。存储第二个数据，第二个数据将是一个指针，它将。表达得很明显，但我们上周奠定了指针的基础。我该如何描述这个结构有指向，另一个这样的结构的指针，有什么想法。
- en: verbally the syntax to use，or even if you're not sure of exactly，the incantation
    exactly。what symbols we should use to express in，address，to another such node，brian。uh
    someone is suggesting we use a node，star as a pointer to a node，node star all
    right so star i i。definitely remember from last week in，indicating that if you
    have int star。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 口头上使用的语法，或者即使你不确定确切的，咒语到底。我们应该使用什么符号来表示地址，指向另一个这样的节点，布莱恩。呃，有人建议我们使用节点指针作为节点，节点指针，好的，我我确实记得上周的，表示如果你有int指针。
- en: this is the address of an int if you，char，so if all of these arrows really just。represent
    addresses of nodes it stands，to reason that the syntax。is probably going to be
    something akin，to node star now i can call this pointer。anything i want by convention
    i'll call，life，structure，and that's going to be in addition to。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个整数的地址，如果你是字符，所以如果所有这些箭头实际上只是。代表节点的地址，那语法大概会类似于节点指针，现在我可以把这个指针。称作任何我想要的名字，按照惯例我称之为，life，结构，这将会是额外的。
- en: the int called number that i'll propose，describes the top，of that individual
    data structure but。there's a subtle problem here in c，recall that in c it's kind
    of a，simplistic language。complicated though it might often seem，in that it doesn't
    understand anything。that it hasn't seen before，so at the moment notice that the
    very，first time。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为number的整数，我提议描述那个单独数据结构的顶部，但。这里有一个微妙的问题，在C语言中，记住C是一种相对简单的语言。尽管它常常看起来复杂，但它不理解任何。它之前没有见过的东西，所以现在注意到第一次。
- en: i have mentioned node up until now was，code，the problem is that by nature of
    how，typedef works。actually exist，until the compiler is done reading that，last
    line of code and the semicolon。which is to say that it would actually，be incorrect，to
    use or refer to quote unquote node。inside of this structure because，works，a node
    does not exist until again that，executed。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到的节点直到现在是，代码，问题在于typedef的性质。实际上在编译器读取那最后一行代码和分号之前，节点并不存在。换句话说，在这个结构内使用或引用所谓的节点是错误的，因为，节点在执行之前并不存在。
- en: thankfully there's a workaround it's a，do，in c is this you can actually add
    an，additional word。after literally the keyword struct and，we'll keep it simple
    we'll use the exact，necessary。and now i'm going to change the inside，of the structure
    to say this。instead so it feels a little verbose and。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，有一个解决方法。在C中你可以实际添加一个，额外的词。紧跟在关键字结构后面，我们保持简单，使用必要的。现在我要改变结构内部来表达这一点。所以感觉有点冗长。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_29.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_29.png)'
- en: it feels like a little bit of copy paste，but this is the way it is done in，hint。similar
    in spirit to the prototypes，we've talked about for functions。that gives the compiler
    a clue that okay，something called a struct node is going，to exist。you can then
    use it inside of that data，structure and refer to，it as struct node star it's
    more of a。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这感觉像是有点复制粘贴，但这是提示中的做法。与我们为函数谈论的原型精神相似，这给编译器提供了一个线索，表明好吧，将会存在一个叫做结构节点的东西。然后你可以在那个数据结构内部使用它，并称之为结构节点指针，这更像是一个。
- en: multiple，words like this but it's similar to char，star or instar。like last week
    and i'm going to call，that arbitrarily next，and down here the same thing happens
    as。in the past with persons，by calling this node at the very last，compiler。you
    know what you don't have to refer to，it as struct node all over the place you。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多个单词像这样，但它类似于字符、星号或实例。就像上周一样，我将任意调用，接下来在这里也会发生相同的事情。与过去的情况一样，通过在最后调用这个节点，编译器。你知道的，你不需要到处称它为结构节点。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_31.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_31.png)'
- en: can just call this thing，node so it's a little bit of um，it's a little verbose
    in this case but。all this is done is create for me，in the computer the definition
    of a node，as we have depicted it。pictorially with that that rectangle，all right
    so how can we now translate。this into more useful code not just，how do we begin，building
    up linked lists well let me。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把这个东西叫做节点，所以在这种情况下，它有点冗长，但所有这些只是为我在计算机中创建节点的定义，正如我们用那个矩形描绘的那样。那么我们现在如何将这转化为更有用的代码，而不仅仅是，我们如何开始构建链表呢，让我来。
- en: propose that a linked list，really begins with just a pointer and in，fact here
    we have thanks to the。theater's prop shop just kind of a null，pointer if you will
    i'm going to call，this variable。list and list is currently pointing to，nothing
    the arrow will say is just。pointing at the floor which means it's，null it's not
    actually pointing at，anything useful。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个链表实际上只需一个指针，事实上，感谢剧院的道具商店，我们这里有一个空指针。如果你愿意，我将这个变量称为list，而list当前指向没有任何东西，这个箭头只是指向地面，这意味着它是空的，实际上并没有指向任何有用的东西。
- en: suppose i now want to start to begin to，allocate a linked list，with three numbers
    one two and three。![](img/0a786619a8ddec04544d001ff89412ad_33.png)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我现在想开始分配一个链表，其中包含三个数字一、二和三。![](img/0a786619a8ddec04544d001ff89412ad_33.png)
- en: well how am i going to do this well at，the moment the only thing that exists
    in，called list。there's no array in the story that was，last uh that was uh，in week
    two today is all about linked。lists so how do i get myself a，wooden block that
    represents one another。wooden block that represents two and a，third that represents
    three。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我该如何做到这一点呢？目前在叫做list的地方，唯一存在的东西。故事中没有数组，最后在第二周，今天全是关于链表的。那么我如何获得一个代表一的木块，一个代表二的木块，以及一个代表三的木块呢？
- en: we need to use our new friend from last，week malloc recall that malloc。allows
    you to allocate memory uh as much，memory as you might want so long as you。tell
    it the size of that thing，so frankly i think what we could do，ultimately today
    is use malloc。![](img/0a786619a8ddec04544d001ff89412ad_35.png)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用上周的新朋友malloc，回想一下malloc。允许你分配内存，尽可能多的内存，只要你告诉它那个东西的大小，所以坦率地说，我认为我们今天最终可以使用malloc。![](img/0a786619a8ddec04544d001ff89412ad_35.png)
- en: to allocate dynamically one struct，and put the number one in it another。struct
    put the number two on it，another struct put the number three in，here。to actually
    stitch them together having，one point to the other，so thankfully the prop shop
    has。wonderfully created a whole bunch of，these for us，let me go ah**d and malloc
    a very heavy，node。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我开始实例化，也就是创建这个列表。动态分配一个结构体，把数字一放进去，另一个结构体把数字二放上去，再一个结构体把数字三放在这里。实际上将它们串联在一起，让一个指向另一个，所幸的是道具商店为我们创建了一大堆这些，让我去**malloc一个非常重的节点**。
- en: that has room for two values and you'll，see it has a room for，a number and a
    next pointer so the。number i'm going to first install here，is going to be the
    number。one for instance and i'm going to leave，ground，indicating that this is
    a null pointer，else。but now that i'm starting to instantiate，that is create this
    list。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个值的空间，你会看到它有一个数字和一个下一个指针。所以我要在这里首先安装的数字，将是数字一，比如说，我将留下一个空位，表示这是一个空指针。
- en: now i'm going to do something like this，and say that all right my variable，called
    list。whose purpose in life is to keep track，of where this list is in memory。i'm
    going to connect one to the other by，actually having this variable。point at this
    node when it comes time，then to allocate，another node i want to insert into this。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我要做一些类似的事情，说好吧，我的变量叫做list，生活的目的在于跟踪这个列表在内存中的位置。我将通过让这个变量指向这个节点来连接一个到另一个。当时要分配另一个节点时，我想插入到这个。
- en: linked list back in the world of arrays，memory，copy this value over into the
    new values。i don't have to do that，in the world of linked lists i just call，malloc
    for a second time。and say give me another chunk of memory，big enough to fit a
    node。thankfully from the prop shop we have，and，there's nothing in it，just the
    placeholder so it's garbage。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组的世界里，内存，复制这个值到新的值中。我不必这样做，在链表的世界里，我只需第二次调用malloc。并说给我另一块足够容纳一个节点的内存。感谢从道具商店里获得的，里面什么也没有，只有占位符，所以它是垃圾。
- en: there，until i actually say that the number，shall be number two，and then i go
    over to my linked list。whose variable name is list，and i want to insert this thing
    so i，follow the arrow。i then point the next field of this node，at this third node
    here so now i have a，linked list of size。two there's three things in the picture，but
    this is just a simple variable this，is a pointer。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我实际说数字将是数字二，然后我转到我的链表，其变量名为list，我想插入这个东西，所以我跟随箭头。我然后将这个节点的下一个字段指向这个第三个节点，因此现在我有一个大小为二的链表。图片中有三个东西，但这只是一个简单的变量，这只是一个指针。
- en: that's pointing at the actual node which，in turn is pointing at an actual other。node
    now suppose i want to insert the，number three，into this linked list recall that
    malloc。is powerful in that it takes memory from，wherever it's available。the so-called
    heap from your computer，and that means by definition that it，might not be contiguous。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这指向实际的节点，而该节点又指向另一个实际的节点。现在假设我想把数字三插入这个链表，记住malloc的强大之处在于它可以从计算机中可用的地方分配内存，所谓的堆，这意味着从定义上讲，它可能不是连续的。
- en: the next number might not actually be，memory，it might be way over there so that
    might，malloc now。and allocate a third node it might not，be available anywhere
    in the computer's。memory except for like，way over here and that's fine it doesn't，have
    to be contiguous as it did。the number，three in its place but if i want to keep，a
    pointer to that node so that all these。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个数字实际上可能不是内存，它可能在那边，所以这可能是malloc现在。并分配一个第三个节点，它可能在计算机的内存中无处可用，除了像是在这里，这样没问题，它不必像数字三那样在它的位置是连续的，但如果我想保持一个指向那个节点的指针，以便所有这些。
- en: things are stitched together i again，start at the beginning，i follow the arrows
    i follow the arrows。one is，i'm going to have to connect these，things and so，now
    that pointer needs to point。at this block here and this visual is，very much deliberate
    these nodes can be。anywhere in the computer's memory，they're not necessarily going
    to be，contiguous。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事情被串联在一起，我再次从头开始，我跟随箭头，我跟随箭头。其中之一是，我必须连接这些东西，因此，现在这个指针需要指向。这里的这个块，这个视觉效果是非常有意图的，这些节点可以在计算机的内存中随处可见，它们不一定是连续的。
- en: the downside of that is that you cannot，rely on binary search our friend from，like
    week 0，it's big o。of log n you can find stuff way faster，than big o of n that
    was the whole point。of even the phone book example in the，very first week，but
    the price the upside of this。approach is that you don't have to，actually keep
    allocating and copying。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的缺点是你不能依赖二分搜索，我们的朋友从第0周开始，它的时间复杂度是O(log n)，你可以比O(n)快得多地找到东西，这就是在第一周中电话簿示例的整个要点，但这种方法的优点是你不必实际不断分配和复制。
- en: more memory and all of your values，anytime you want to resize。this thing and
    i'm a little embarrassed，to admit that i'm out of breath for some。reason just
    mall locking nodes here，but the point is like using malloc and。![](img/0a786619a8ddec04544d001ff89412ad_37.png)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的内存和所有的值，任何时候你想要调整这个大小，我有点尴尬地承认，不知道为什么我气喘吁吁，只是在这里malloc节点，但重点是像使用malloc和。![](img/0a786619a8ddec04544d001ff89412ad_37.png)
- en: some price，um it's it's exhausting frankly but it's，also going to spread things
    out in。memory but you have this dynamism and，honestly if you are the twitters
    of the。world the googles of the world we have，lots and lots of data，to have to
    copy。all of your data from one location into，another santiago originally proposed。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些价格，嗯，这确实令人疲惫，但这也会在。内存中分散东西，但你有这种动态性，老实说，如果你是世界上的推特，谷歌，我们有，很多很多的数据，需要复制。你所有的数据从一个位置到另一个，santiago最初提出。
- en: as a solution to the array so using，these dynamic，data structures like a linked
    list where，available。and you somehow remember where that is，by stitching things
    together as with，these physical pointers。is really the state of the art and how，you
    can create these more dynamic。structures if it's more important to you，questions，before
    we now translate these physical，blocks。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数组的解决方案，使用这些动态，数据结构，如链表，在哪里可用。并且你以某种方式记住它，通过将东西结合在一起，就像这些物理指针。这真的是技术的前沿，你可以创造这些更动态的。结构，如果这对你来说更重要，问题，在我们现在翻译这些物理，块之前。
- en: any questions or confusion brian and as，always feel free to verbalize anything。in
    the chat too if folks are more，comfortable there，a question came in in the chat
    when in。this whole process of linked lists are，we actually using malloc and what
    is，malloc being used for。really good question so where are we。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么问题或困惑，brian，像往常一样，如果大家在聊天中更舒服，随时可以说出来。聊天中有一个问题，在整个链表的过程中，我们实际上使用了malloc，malloc的用途是什么。真的很好问题，那么我们在哪里。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_39.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_39.png)'
- en: using malloc every time i went off stage，and grabbed one of these big blocks。![](img/0a786619a8ddec04544d001ff89412ad_41.png)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我离开舞台并拿到其中一个大块时，使用malloc。![](img/0a786619a8ddec04544d001ff89412ad_41.png)
- en: that was my acting out the process of，mallocking a node so when you call。malloc
    that returns to you per，last week the address of the first byte。of a chunk of
    memory and if you call，malloc of one that gives you the address。of one byte if
    you call malloc of 100，hundred bytes，that are contiguous so each of these。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我模拟分配一个节点的过程，所以当你调用。malloc时，它返回给你上周提到的第一字节的地址。一个内存块，如果你调用，malloc一个字节，它会给你一个字节的地址，如果你调用malloc
    100，百字节，它们是连续的，所以每一个。
- en: nodes then represents，call，to malloc and in fact perhaps brian the。best way
    to translate to answer that，question in more detail is to translate。this now to
    some actual code so let's do，that and then revisit。so here is for instance a line
    of code，that represents the beginning of our。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 节点然后代表，调用，malloc，实际上也许brian，回答这个问题的最佳方式是将其翻译。现在将其翻译为一些实际代码，我们来做吧，然后再回头看。所以这里是，例如，一行代码，代表我们开始的。
- en: story where we only had a variable，called list that was initialized to。nothing
    initially this arrow was not，pointing at anything，and in fact if it was just pointing
    up。down left or right it would be，considered a garbage value right this is，inside
    of it。before i actually put actual values in，it so if i don't assign it a value
    who。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 故事中我们只有一个变量，叫做list，它最初被初始化为。什么都没有，这个箭头并没有，指向任何东西，实际上如果它只是指向上。下左或右，它会被认为是一个垃圾值，对吧？这就是它内部的情况。在我实际放入实际值之前，如果我不赋值给它，谁。
- en: knows what it's pointing to，but let me go ah**d and change the code。this list
    variable by default has some，something like，null so i'll represent that here。figuratively
    by just pointing at the，ground that now represents null。this would be the corresponding
    line of，code that just creates for you。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 知道它指向什么，但让我去啊**d**并更改代码。这个列表变量默认有一些，类似于，null，所以我在这里将其表示。比喻地说，仅仅指向地面，现在表示null。这将是相应的代码行，仅为你创建。
- en: an empty linked list that was the，beginning of the story，now recall that the
    next thing i did was。bring back，one of these big boxes at that code，might instead
    look like this node star。n though i could call the variable，anything i want malloc，size
    of node so size of we might have。seen briefly in that it's just an，bytes，large
    any data type is so i could do the。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的链表是故事的开端，现在回想一下，我接下来的事情是。拿回这些大盒子中的一个，这段代码可能看起来像这个节点星。尽管我可以将变量称为任何我想要的，malloc，节点的大小，所以我们可能会看到它只是一个，字节，任何数据类型都是如此，我可以做到。
- en: math and figure out in my mac or pc or，cs50 ide just，how many bytes these nodes
    are supposed。to take up sizeof just answers that，question for me，so malloc again
    takes one argument the。number of bytes you want to allocate，dynamically and it
    returns to the。address of the first of those bytes，so if you think of this as
    like one of。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数学并弄清楚在我的Mac或PC或CS50 IDE中，这些节点应该占用多少字节，sizeof刚好回答了这个问题。因此，malloc再次接受一个参数，即你想动态分配的字节数，它返回这些字节第一个的地址。可以将其视为我之前黄色幻灯片中的一个。
- en: my earlier slides in yellow，it returns to like the address of the。top left byte
    of this chunk of memory，if you will and i'm going to go ah**d。and assign that
    to a variable i'll call，n to represent a node and it's node star，address。and the
    syntax we saw last week for，star，syntax here so this gave me a block。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回的像是这块内存左上角字节的地址，我要将其赋值给一个变量，称为n，以表示一个节点，它的节点星号地址，以及上周看到的星号语法。所以这给我一个块。
- en: that initially just had garbage values，so there was no number in place and who，knows
    where the arrow。was pointing at so it looked a little，something like this if i
    draw it now on，the screen。list is initialized to null it's not，pointing at anything
    right now。but n the variable i just declared is，pointing at a node，but inside
    of that node or who knows。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最初只是垃圾值，所以没有数字在位，谁知道箭头指向哪里。如果我现在在屏幕上画出来，它看起来有点像这样。列表初始化为null，它现在不指向任何东西。但我刚刚声明的变量n指向一个节点，但在那个节点内部，谁知道。
- en: what it's garbage values number and next，are just garbage values because that's。what's
    there by default remnants of the，past but now，let me propose that we do this code
    so。long as n is not，null which is something you want to get，into the habit always
    now of checking。any time in c when you call a function，that returns to you a pointer
    you should，almost always check。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾值的数字和下一个只是垃圾值，因为那是默认情况下的残余。但现在，让我建议我们这样做代码，只要n不为null，这是你要养成的习惯。每当在C中调用返回指针的函数时，你几乎总是应该检查。
- en: is it null or is it not null because you，do not want to try touching it。if it
    is indeed null because that means，there is no valid address here。that's the human
    convention when using，pointers but if，n does not equal null that's a good。thing
    that means it's a valid address，somewhere in the computer's memory。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 是null还是不null，因为如果它确实是null，你不想去触碰它，因为这意味着这里没有有效的地址。这是使用指针时的惯例，但如果n不等于null，那是件好事，这意味着它是计算机内存中的有效地址。
- en: let me go ah**d now and go to that，address，the syntax for which is star n just
    like，last week。and then the dot operator means go，inside of the structure that's
    there。and go into the variable inside of it，called number in this case。so when
    i go ah**d and do something like，this when i，where this。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续，转到那个地址，语法是星号n，就像上周一样。然后点运算符意味着进入结构内部，并进入其中的变量，在这种情况下称为number。因此，当我继续并做这样的事情时。
- en: variable is pointing at the one and only，node at the moment and it's storing
    the，number one。when i go ah**d and at when i rather，it's going to have the number
    one in it。as soon as i execute this line of code，star n，means start at the address
    embodied here，go to it。and then put the number one in this case，in place，i want
    to，um i want to go ah**d too and replace。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 变量此时指向唯一的节点，并存储数字1。当我继续时，它将包含数字1，一旦我执行这行代码，星号n意味着从这里的地址开始，进入，然后在这种情况下把数字1放进去，我想，嗯，我想继续并替换。
- en: the garbage value that represents the，next pointer in that structure and，replace
    it with null。null just indefinite this is the end of，the list there's nothing
    there i don't。want it to be garbage value，because a garbage value is an arbitrary。number
    that could be pointing this way，this way this way，metaphorically i want to actually
    change。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾值表示该结构中的下一个指针，并用null替换它。null只是意味着这是列表的结束，这里没有任何东西。我不想要垃圾值，因为垃圾值是一个任意的数字，可能指向这个方向、那个方向，象征性地说，我想真正地改变它。
- en: that to be null，and so i can use the same syntax but，there's this clever approach
    now i don't。the place as mentioned，earlier star and dot comes with some，syntactic
    sugar。you can replace the star and the，parentheses and the dot that we just saw。with
    an arrow notation which means，follow the arrow，and then set this thing equal to
    null。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这要设为null，因此我可以使用相同的语法，但这里有一个聪明的做法，我不需要像之前提到的那样使用星号和点，因为它们带有一些语法糖。你可以用箭头表示法来替换我们刚才看到的星号、括号和点，这意味着跟随箭头，然后将这个设置为null。
- en: having the arrow，literally point at the floor for clarity，star，parentheses。is
    the same thing as this and the reason，that most people prefer using the arrow。notation
    so to speak，is that it really does capture this this，physicality you start at
    the address。you go there and then you look at the，field number，or next respectively
    but it's equivalent。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将箭头字面上指向地面以保持清晰，星号，括号。与这完全相同，大多数人之所以更喜欢使用箭头表示法，是因为它确实捕捉到了这种物理性，你从地址开始，你到达那里，然后查看字段数字或下一个，但它是等价的。
- en: to the syntax we saw a moment ago，with the star and the dot as before so。after
    these two steps have we，initialized this node to containing the，number one。and
    null inside of it，but what comes next what comes next well，at this point in the
    story。in this code i have some other variable，here that's not pictured because
    we're。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们刚才看到的星号和点的语法一样，所以在这两个步骤之后，我们是否已经将这个节点初始化为包含数字一和内部的null，但接下来会发生什么呢？在这个故事的这个时刻，在这段代码中，我还有其他变量，没有展示出来，因为我们。
- en: now transitioning from the world of，woodwork to actual code，so there's another
    variable n which i。might as well be，representing myself if i am this，at this value。it's
    not until i actually execute this，line of code，list equals n that i remember。where
    this node is in the computer's，memory so n up until now has really just。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从木工的世界过渡到实际代码，所以有另一个变量n，我可以代表自己，如果我是这个值。直到我实际执行这一行代码`list = n`，我才记得这个节点在计算机的内存中在哪里，因此到目前为止，n实际上只是。
- en: been a temporary variable it's a，variable that i can use to actually。keep track
    of this thing in memory but，if i want to add this node ultimately，null。recall
    that this pointer was pointing at，the ground representing null。but when i now
    want to remember that，this linked list has a node in it。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个临时变量，它是我用来实际跟踪这个内存中的东西的变量，但是，如果我想最终添加这个节点，那么就是null。请记住，这个指针指向地面，代表null。但是当我现在想记住这个链表中有一个节点时。
- en: i need to actually execute a line of，code like this，list equals null all right
    what did we。next do let's take one more step further，so at this point in the story。if
    i was representing n i'm also，pointing at the same block，n is temporary so it
    can eventually go。away but at this point in the story we，have a linked list of
    size one。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要实际执行这样一行`code`，`list = null`，好吧，我们接下来做了什么，让我们再进一步一步，所以在这个故事的这个时刻。如果我表示n，我也指向同一个块，n是临时的，因此最终可以消失，但在这个故事的这个时刻，我们有一个大小为一的链表。
- en: let's go ah**d and take this further，suppose now i execute these lines of。code
    and we'll do it a little faster in，in context，the first line of code is the same
    as。before hey malloc give me a chunk of，memory that's big enough for the size
    of。a node and again let's use this，temporary variable n，to point to that and suppose
    that means。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续深入，假设现在我执行这些`code`行，我们会稍微快一点，首先这一行代码与之前相同，嘿，`malloc`给我一个足够大的内存块，能容纳一个节点，再次让我们使用这个临时变量n来指向它，假设这意味着。
- en: that i if i'm representing this，temporary variable i'm pointing at this，new
    chunk of memory here。i then check if n does not equal null，then and only then
    do i go ah**d and。install the number two as i did，physically earlier，and do i
    initialize the pointer，originally。to pointing not at some other node which，doesn't
    yet exist，floor。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我代表这个临时变量，我指向这里的新内存块。然后我检查n是否不等于null，那么只有在这种情况下，我才去插入数字二，就像我之前实际做的那样，并且我是否最初将指针初始化为不指向某个尚不存在的其他节点，即。
- en: thereby representing null and that's it，that has now allocated the second node，but
    notice。literally this disconnect just because，i've allocated a new node，and put
    the number i care about and。initialized its next pointer to null，that doesn't
    mean it's part of the data。structure the linked list，new，so we need to execute
    one other line of。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样代表null，这就是它，现在已经分配了第二个节点，但请注意。实际上，这种断开只是因为我分配了一个新节点，并放入我关心的数字，并将其下一个指针初始化为null，这并不意味着它是数据结构的一部分，链表，新，所以我们需要执行另一行。
- en: code now so that we can get from this，picture ultimately，to the final one and
    here's where we can。use the same kind of syntax as before，the arrow，as per that
    code and then i update the，next field。allocated，node now after that final line
    of code，do i have a link list of size two。because i've not only allocated the
    node，initialized its two variables。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写代码，以便我们最终能够从这幅图中获取到最后的一个，并且在这里我们可以使用与之前相同的语法，箭头，根据那段代码，然后我更新下一个字段。在那段代码的最后，我现在是否有一个大小为二的链表？因为我不仅分配了节点，还初始化了它的两个变量。
- en: number and next respectively i've also，chained it together，with the existing
    node on the linked，list。and let me do this one even slightly，thing，just so we
    can see it all together at。once now that we have this picture，let's execute the
    same kind of code，of code。is that i'm initializing number to three，so what has
    this done for me that chunk，of code has malloc。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和下一个分别，我还将它与链表上的现有节点连接在一起。让我再稍微做一点，以便我们可以一次性看到所有内容。现在我们有了这幅图，让我们执行相同类型的代码。我将数字初始化为三，那么这段代码为我做了什么？那一块代码已经malloc了。
- en: a third and final note i've initialized，the top to the number three i've，initialized
    the bottom。to null as i'll represent by just，pointing the arrow at the ground。there's
    one final step then if i want to，go ah**d and insert that third node into，now。and
    not just pointed it myself me，variable，n i need to now do this and this is。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点也是最后一点，我将顶部初始化为数字三，我将底部初始化为null，我将用箭头指向地面来表示。然后有一个最后的步骤，如果我想去插入那个第三个节点，而不仅仅是我自己指向的变量n，我现在需要这样做。
- en: syntax you won't do often，we'll see it in an actual program in，just a moment
    but it just speaks to。the basic building blocks we're，manipulating if i want to
    go ah**d and，list。i can follow the arrow once i can follow，the arrow again，to，n
    because again n is the current address。of that most recently allocated，node so
    even though the syntax is，getting a little。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法你不会经常使用，我们稍后会在实际程序中看到，但它只是说明了我们正在操作的基本构建块。如果我想继续列出，我可以跟随箭头，一旦我能再次跟随箭头到n，因为n是最近分配的节点的当前地址，所以尽管语法有些复杂。
- en: new the two arrows i'm using are，literally just like a code。![](img/0a786619a8ddec04544d001ff89412ad_43.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的两个箭头，字面上就像代码。![](img/0a786619a8ddec04544d001ff89412ad_43.png)
- en: manifestation of just follow the pointer，follow the pointer，boom assign one
    value to the next。all right so at this point in the story，as i，and i'm still in
    the picture but if i。temporary variable，voila we've just built up step by step，a
    brand new linked list。![](img/0a786619a8ddec04544d001ff89412ad_45.png)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只是遵循指针的表现，跟随指针，boom，将一个值赋给下一个。那么在故事的这个时刻，当我……我仍然在图片中，但如果我……临时变量，voila，我们一步一步地构建了一个全新的链表。![](img/0a786619a8ddec04544d001ff89412ad_45.png)
- en: seems like a lot of work but it allows，us to now grow this thing。dynamically
    but let me pause here any，questions or confusion，on linked lists any questions
    or。confusions on the linked，chat，if we're trying to make a list that's。going to
    be much longer like more than，three elements wouldn't it get tedious，and over
    again。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是很多工作，但它允许我们动态地增长这个东西。但让我在这里暂停，有关于链表的任何问题或困惑吗？如果我们试图创建一个更长的列表，比如超过三个元素，难道不会显得乏味吗？
- en: yeah really good observation and so，that's why i said you won't usually。write
    it like this we'll do it，temporarily in a full-fledged program in。just a moment
    just to demonstrate it，but in general you'll probably use。something like a loop
    and what you'll do，at this one，then iterates again then iterates again。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，真是个好观察，所以我说你通常不会这样写，我们将暂时在一个完整的程序中做到这一点，只是为了演示，但一般来说，你可能会使用类似循环的东西，然后你会在这里迭代一次，再迭代一次。
- en: and let me stipulate for now that if you，use a loop in the right way。you can
    end up writing just a single，arrow by just keep updating the variable。again and
    again so there is a way to，avoid that and you can do it much more。dynamically
    let me go ah**d and ask a，question of my own here，let me go ah**d and ask this
    one if。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我暂时规定，如果你以正确的方式使用循环，你可以通过不断更新变量，只写出一个箭头。因此，有一种方法可以避免这种情况，你可以做得更动态。让我来提一个我自己的问题，如果……。
- en: you'd like to buzz in，to this question what is the running，time of searching。a
    linked list what's the running time of，searching a linked list in big o，notation
    so。what's an upper bound worst case of。![](img/0a786619a8ddec04544d001ff89412ad_47.png)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你想对这个问题进行回答，搜索链表的运行时间是什么？在大 O 表示法中，搜索链表的运行时间是什么？那么，最坏情况的上限是什么？![](img/0a786619a8ddec04544d001ff89412ad_47.png)
- en: searching a linked list like this one，whether it has three elements or even，many
    more。so it looks like as before about eighty，it's big o of n，and this is actually
    correct because。consider the worst case suppose you're，looking for the number
    three。you're going to have to look at all，three numbers big o of n if you're，looking
    for the number 10。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索像这样的链表，不论它有三个元素还是更多。看起来像以前的情况，大约是八十，它的复杂度是大 O 的 n，这实际上是正确的。考虑最坏情况，假设你在寻找数字三，你必须查看所有三个数字，如果你在找数字十。
- en: you're going to start here at the，beginning you're going to keep looking。looking
    looking looking you're going to，get to the end realize oh the number 10。is not
    even here at which point，you've already looked at n elements but，linked lists。![](img/0a786619a8ddec04544d001ff89412ad_49.png)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从这里开始，在开始的地方继续寻找，寻找，寻找，直到你到达末尾，意识到数字十甚至不在这里，此时你已经查看了 n 个元素，但链表。![](img/0a786619a8ddec04544d001ff89412ad_49.png)
- en: the list in，constant time you could just use a。![](img/0a786619a8ddec04544d001ff89412ad_51.png)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在常数时间内，链表的操作可以很简单。![](img/0a786619a8ddec04544d001ff89412ad_51.png)
- en: little bit of arithmetic you could jump，to the middle element or the first。element
    all using constant time。![](img/0a786619a8ddec04544d001ff89412ad_53.png)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一点算术，你可以跳到中间元素或第一个元素，所有这些都是使用常数时间完成的。![](img/0a786619a8ddec04544d001ff89412ad_53.png)
- en: a linked list unfortunately is，represented ultimately by，just a single address
    the address that。points to the very first node，and so even though you all on camera
    can。see this node in this node and this one，as humans all at once，the computer
    can only follow these。list，is going to be big o of n in that case，but let me ask
    a follow-up question。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，链表最终只由一个地址表示，这个地址指向第一个节点。因此，即使你们所有人都能在镜头前看到这个节点和那个节点，作为人类我们能同时看到，但计算机只能跟随这些列表，在这种情况下，它的复杂度将是大
    O 的 n，但让我问一个后续问题。
- en: a follow-up question here what's the，running time of，inserting into a linked
    list。what's the running time of inserting，into a linked list so you've got some，new
    number，negative 5。![](img/0a786619a8ddec04544d001ff89412ad_55.png)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个后续问题是，插入到链表中的运行时间是什么？插入到链表中的运行时间是什么？所以你有一个新的数字，负五。![](img/0a786619a8ddec04544d001ff89412ad_55.png)
- en: whatever it may be there's going to be a，malloc involved，but that's constant
    time it's just one。function call but you're going to have，to insert it somewhere。and
    here it looks like 68 percent of you，are proposing big o of one which is。interesting
    constant time，of n，would anyone be comfortable chiming in，verbally or on the chat。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是什么，都将涉及 malloc，但这只是常数时间，它只是一个函数调用，但你必须在某个地方插入它。在这里，看来你们 68% 的人提议是大 O 的 1，这很有趣，常数时间的
    n，是否有人愿意在聊天中或口头表达意见？
- en: as to why you feel it's one or the other，it is indeed one of those answers。it
    is indeed one of those answers any，thoughts behind your thinking it's okay，if
    it ends up being。otherwise any thoughts in the chat，um i guess it could be o，n
    and because because of the fact that。create，a new node essentially i think uh
    all，the computers doing。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 至于为什么你觉得这是其中之一，它确实是那些答案之一。你对你思考的背后有什么想法吗？如果结果是其他的也没关系，聊天中有什么想法吗？嗯，我想这可能是 O 的
    n，因为创建一个新节点的事实，我认为，计算机正在做的所有事情。
- en: when you assign it is gonna as use like，those arrows like，going from one hour
    to the next to the。next to the next and that way i would，think it would be all，and
    it is own event as you've described。it but you two are making an assumption，like
    80 or like 25 of other，people are making you seem to be。![](img/0a786619a8ddec04544d001ff89412ad_57.png)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分配它时，它将像使用那些箭头一样，从一个小时到下一个小时，再到下一个，依此类推。我认为这将是全部，正如你所描述的，它将是一个事件，但你们两个在做一个假设，就像其他大约
    80 或 25 个人正在做的那样，你们似乎在。![](img/0a786619a8ddec04544d001ff89412ad_57.png)
- en: assuming that if the new number suppose，it's number four，has to go at the end
    or if it's the。number five it has to go at the end and，i kind of deliberately
    set things up。that way i've happened to maintain them，in sorted order one two
    three。from left to right but up until now i，have not made the condition that the。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设如果新数字，假设是数字四，必须放在最后，或者如果是数字五，它必须放在最后，而我故意设置的情况。是那样的，我恰好保持了它们，按顺序排列一二三。从左到右，但到目前为止我，尚未做出条件，让它。
- en: linked list has to be sorted even though，the examples we've seen thus far，deliberately
    that way。but you know what if you want to get，fancy and a little more efficient。and
    you want to allocate the number four，and frankly you don't really care。about keeping
    the linked list in sorted，order well heck，just pull this out put your new node。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 链表必须是排序的，尽管我们到目前为止看到的例子都是故意这样做的。但你知道吗，如果你想让它，变得花哨一点，更高效。你想要分配数字四，坦白说你并不在乎。保持链表的排序顺序，嘿，只需将这个拿出来放入你的新节点。
- en: here plug it in here plug the other one，back in here and just insert。the new
    element at the beginning of the，list and for every number thereafter。malloc as
    before but just keep inserting，here，now it's not going to take a single step。because
    as i verbalized it there's like，the malloc step i have to unplug this i。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里插入，另外一个也插入在这里，只需在列表开头插入。新元素，之后的每个数字。像之前一样malloc，但只需在这里继续插入，现在它不会花费一步。因为就我所说的，有像malloc的步骤，我必须拔掉这个。
- en: have to plug it back in，so it's like three or four steps total，but four steps
    is also。constant that's big o of one because，it's a fixed number of steps。so if
    you're able to sacrifice sorted，order when it comes to this list you can。![](img/0a786619a8ddec04544d001ff89412ad_59.png)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 必须插回去，所以这总共是三到四步，但四步也是。常量，这是O(1)，因为这是固定步数。所以如果你能够牺牲排序顺序，当谈到这个列表时，你可以。![](img/0a786619a8ddec04544d001ff89412ad_59.png)
- en: in constant time insert insert insert，insert and the list is going to get，longer
    and longer。but from the beginning of it rather than，the end so that too is a trade-off
    if。you don't care about sorted order and，none of your algorithms or code。require
    that it be sorted then you can，go ah**d and cut that corner，and achieve constant
    time insert。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在常量时间内插入插入插入，列表将会越来越长。但是从开始而不是，从结束，所以这也是一个权衡。如果你不在乎排序顺序，并且你没有任何算法或代码。要求它是排序的，那么你可以去**继续**走这条捷径，达到常量时间插入。
- en: whichever twitter or google or the like，maybe that's actually a net savings
    and，a good thing。but again you sacrifice the sorted order，and，let's translate
    this to some actual code。let me go ah**d here，in uh cs50 ide and let's go ah**d
    and，that now。actually do something with numbers and，start to manipulate things。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是twitter、google，还是类似的，或许这实际上是一个净节省，还是一件好事。但再说一次，你牺牲了排序顺序，接下来让我们把这个翻译成一些实际的代码。让我去**继续**，在uh
    cs50 ide，然后让我们去**继续**，现在。实际对数字做一些操作，并开始处理事情。
- en: in memory so i'm going to go ah**d here，and create a program called list。dot
    c and my first version is going to，and，made and void，and then inside of here let
    me go ah**d。like we began and give myself a list，of integers of size three so
    this is，three。and this array of size three i'm going，to go ah**d and hard code
    some new。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，所以我准备去**这里**，创建一个程序，叫做list.dot c，我的第一个版本是，**并且**，返回空，然后在这里让我继续。就像我们开始的那样，给自己一个大小为三的整数列表，所以这是，三。这个大小为三的数组，我准备去**继续**硬编码一些新。
- en: values into it so at the very first，location i'll put the number one。at the
    second location i will put the，put，the number three and then just to，demonstrate
    that this。is working as i think i intend i'm gonna，do a quick for loop，so for
    int i get zero i less than three。i plus plus and then inside this loop，i'm going
    to go ah**d and print out。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 值放进去，所以在第一个位置，我放上数字一。在第二个位置，我会放上，放，数字三，然后只是为了，演示这个。这是按我预想的方式工作的，我将要，做一个快速的for循环，所以对于int
    i从零开始，i小于三，i加一，然后在这个循环里面，我准备去**继续**打印出来。
- en: percent i and then i'm going to print，out the value，of i so now that i've printed
    out all of。these values in my loop let me go ah**d，and do make，list let me go
    ah**d then and do dot，slash list。and hit enter and indeed i get oops not，not what
    i wanted，so good uh teachable moments not。![](img/0a786619a8ddec04544d001ff89412ad_61.png)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 百分之i，然后我将打印，出i的值，所以现在我已经打印出所有的。这些值在我的循环中让我去**继续**，做出，列表。让我去**继续**，然后做./list。并按下回车，确实我得到了哎呀，不，*不是我想要的*，所以这是个好，*可教的时刻*。![](img/0a786619a8ddec04544d001ff89412ad_61.png)
- en: intended admittedly but what have i done，wrong here，brian has anyone noticed
    already if i。if i my goal is to print out the list，but somehow i printed out 0
    1。![](img/0a786619a8ddec04544d001ff89412ad_63.png)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，我做错了什么，布莱恩，有人注意到如果我。我的目标是打印出列表，但不知怎么的我打印出了0 1。![](img/0a786619a8ddec04544d001ff89412ad_63.png)
- en: 2 and those are indeed not the numbers，in this list uh，so you've printed i you
    should have。printed list of i，yes so i should have printed the，contents of the
    array which is list。bracket eye so that was just a，newbie mistake by me here so
    let me fix，list。dot slash list and voila i've now，printed the list so this is
    sort of week，raise。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 2，确实不是这个列表中的数字，呃，所以你打印了i，你应该打印出列表的i，是的，我应该打印出数组的内容，也就是列表。方括号i，所以这是我一个新手的错误，让我修正，列表。点斜杠列表，瞧，我现在打印了列表，所以这就是第周，数组。
- en: in week two but now let me go ah**d and，transition now to something more dynamic。where
    i don't have to commit in advance，to creating uh an array i can do this。with a
    dynamically allocated chunk of，memory so let me delete everything i've，done inside
    of main。and let me go ah**d and give myself this，let me go ah**d and declare。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二周，但现在让我去啊**d，转到更动态的东西。那里我不必提前承诺，创建一个呃数组，我可以这样做。通过动态分配的一块内存，所以让我删除我在main中做的所有事情。让我去啊**d，给自己这个，让我去啊**d，声明。
- en: a list of values where list is now going，operator，and i'm going to go ah**d
    and malloc。let's see i want space for three，integers so the simplest way to do
    this。if i'm just going to keep it simple i，can actually do this，three times sizeofint
    so this。version of my program isn't going to use，an array per se，it's going to
    use malloc but it's going。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列值，其中列表现在将，操作，我将去啊**d和malloc。让我们看看，我想要三个整数的空间，所以最简单的做法是。如果我只是想保持简单，我实际上可以这样做，三倍sizeofint，所以这个版本的我的程序不会使用，数组，而是使用malloc，但它会。
- en: to dynamically allocate that array，for me and we'll see what the syntax for，this
    is as always now。anytime you use malloc i should check，whether list，equals equals
    null and if so you know。what i'm just going to return one recall，that you can
    return zero。or one or some other value for main to，effectively quit your program。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配那个数组，给我，我们将看看这是什么语法，一如既往，现在每次你使用malloc，我应该检查，列表是否等于空，如果是，你知道。我只是返回一个，记住你可以返回零。或者一个或其他值，让main有效地退出你的程序。
- en: i'm going to go ah**d and just return，something，very badly went wrong like i'm
    out of。memory altogether，but now that i have this chunk of memory，ant。this is
    actually the malloc way to give，yourself an array，up until now every time we've
    created a。raise for ourselves we've used squ*re，bracket notation and you all have
    put a。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我将去啊**d，返回一些东西，非常糟糕的出错了，像是我完全没有内存了，但现在我有了这个内存块，ant。这实际上是malloc给自己一个数组的方式，直到现在每次我们为自己创建一个。数组，我们都使用方括号表示法，而你们都放了一个。
- en: number inside the squ*re brackets to，give yourself an array of that size。but
    frankly if we have malloc and the，memory，well if i want to store three integers。why
    don't i ask malloc for three times。![](img/0a786619a8ddec04544d001ff89412ad_65.png)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的数字，给自己一个那个大小的数组。但坦率地说，如果我们有malloc和，内存，如果我想存储三个整数。为什么不让我请求malloc三倍。![](img/0a786619a8ddec04544d001ff89412ad_65.png)
- en: the size of an integer and the way，malloc works is it's actually going to，return
    to me a contiguous。![](img/0a786619a8ddec04544d001ff89412ad_67.png)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的大小和，malloc的工作方式，实际上是，它会返回给我一个连续的。![](img/0a786619a8ddec04544d001ff89412ad_67.png)
- en: chunk of memory of that size so that，that's just，like we'll uh that's um a technique
    that。we'll use in just a moment when，allocating actual nodes，so at this point
    in the story so long as。list does not equal null，i now have a chunk of memory
    that's big，enough to fit the size of。three ins and as before i can go ah**d，and
    initialize those，the first element will be one the second。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样大小的内存块，所以，那个只是，就像我们呃，这是一个我们将在分配实际节点时使用的技术，所以在这个故事的这个时刻，只要列表不等于空，我现在有一个足够大的内存块，能够容纳三个整数，和之前一样，我可以去啊**d，初始化这些，第一元素将是一个，第二个。
- en: element will be two the third element，will be three，and notice this sort of
    equivalence now。between using arrays and using，pointers c is kind of versatile
    in this。way in that if you have a chunk of，memory returned to you by malloc。you
    can per last week use squ*re bracket，notation，you can use squ*re bracket notation
    and。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 元素将是二，第三个元素，将是三，并注意这种等价关系。现在在使用数组和使用指针之间，C在这方面有点灵活。如果你有一块内存由malloc返回给你。你可以像上周一样使用方括号表示法，你可以使用方括号表示法。
- en: treat that chunk of memory as an array，because after all what's an array。it's
    a contiguous block of memory and，that is exactly what malloc。returns if you want
    to be fancy instead，you could actually say go to that。address and put the number
    one there，you could say go to that address plus。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将那块内存视为数组，因为毕竟数组是什么？它是一块连续的内存块，而这正是 *malloc* 返回的。如果你想更复杂一些，你实际上可以说去那个地址，把数字一放在那里，你可以说去那个地址加上。
- en: one and put the next number there，you could say go to that address plus，two。and
    put the third number there but，honestly this just be very quickly。becomes unreadable
    at least to most，people this is that thing called pointer，pointers。that is equivalent
    to using the syntax，that we've used for a while now。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字放在这里，接下来的数字你可以说去那个地址加上，二。再把第三个数字放在那里，但，老实说这变得非常快。至少对大多数人来说，这就变成了不可读的，这就是所谓的指针，指针。这相当于使用我们已经用了一段时间的语法。
- en: which is to just use the squ*re brackets，and the nice thing about squ*re brackets。is
    that the computer，will figure out for you how far apart，each of those integers
    are because it。knows the size，story，things get interesting and also annoying，and
    santiago recall was the one that。helped to solve this earlier，allocated，three
    integers on line five there。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用方括号，方括号的好处在于计算机会为你确定每个整数之间的间隔，因为它知道大小，事情变得有趣也变得烦人，而 *santiago* 记得是帮助解决这个问题的，早些时候在第五行分配了三个整数。
- en: but now at line 13 i'm like oh damn it，the list，i could obviously just redo
    all the code。but suppose that part of the story here，more memory，well how can
    i do this well let me go。ahead and allocate another chunk of，memory temporarily
    so i'll call it temp。by convention and this time i'm going to，go ah**d and allocate
    four，sake of the story。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在在第 13 行，我心想，哦，天哪，列表，我显然可以重做所有代码。但是假设这个故事的一部分，这里需要更多内存，那么我该如何做到这一点呢？让我继续临时分配另一块内存，我将称之为
    *temp*。根据惯例，这次我将继续分配四个，作为故事的需要。
- en: i've messed up and i want to allocate，enough space now for that original。i haven't
    so much messed up i have now，decided that i want to add a fourth，number to this
    array。as always i should check if temp equals，equals null，you know what i'm going
    to go ah**d and。free the memory i already allocated and，then i'm just going to
    get out of here，return 1。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我搞砸了，我想为原始分配足够的空间。我并不是完全搞砸，我现在决定要为这个数组添加第四个数字。像往常一样，我应该检查 *temp* 是否等于空，你知道我将继续释放我已经分配的内存，然后我就要离开这里，返回
    1。
- en: something went wrong，there's nothing to demonstrate so i'm，going to exit out
    of main entirely。but if malloc did not return null and，all is well，what am i going
    to do well let's first，began this。this conversation for int i gets 0，i less than
    3 i plus plus let's go ah**d，and copy。into this new temporary chunk of memory，whatever
    is at the original chunk of，copy，the new array。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 出了点问题，没什么可以演示的，所以我将完全退出主函数。但如果 *malloc* 没有返回空，并且一切正常，我将要做什么？好吧，让我们首先开始这个。这个对话，*for
    int i gets 0，i less than 3 i plus plus*，让我们继续，复制到这个新的临时内存块，原始块中有什么，复制，新的数组。
- en: here's how we might do that in code just，using a simple for loop。a la week two
    and then let me go ah**d，now and add one more value。temp bracket three which is
    the fourth，location if you're starting from zero。i'm gonna go ah**d and put the
    number，four there and now at this point。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何在代码中做到这一点，简单使用一个循环。像第二周那样，然后让我继续，再添加一个值。*temp* 中的 *bracket three*，这是第四个位置，如果从零开始。我将继续把数字四放在那里，现在在这个时候。
- en: i'm gonna go ah**d and remember the fact，that，temp is my new list so i'm going
    to go。ahead and free the original list，and i'm going to update my old list to。![](img/0a786619a8ddec04544d001ff89412ad_69.png)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续记住这个事实，*temp* 是我的新列表，所以我将继续释放原始列表，并将我的旧列表更新为。![](img/0a786619a8ddec04544d001ff89412ad_69.png)
- en: point at the new list，and then lastly i'm going to go ah**d，and use another
    for loop just to。demonstrate that i think i did this，correctly this time iterating
    up to four。instead of three i'm going to go ah**d，and print out with percent i。the
    contents of list bracket i so let's，rewind real quick，we began the story by allocating
    a。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新列表，最后我将继续使用另一个循环，仅仅为了演示我认为这次正确地迭代到四，而不是三，我将继续使用百分号 *i* 打印列表中 *i* 的内容，所以让我们快速回顾一下，我们开始这个故事是通过分配一个。
- en: this time，dynamically to demonstrate that malloc，just returns a chunk of memory
    and if，as an array。you absolutely can this stuff here if，list equals equals null
    is just error，went wrong。the interesting code resumes here i'm，putting the numbers
    1 2 and 3。at location 0 1 and 2 respectively in，that chunk of memory which again
    i'm，treating like an array。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这次动态演示malloc只是返回一块内存，如果，作为一个数组。你绝对可以把这些东西放在这里，如果，列表等于空就是错误，出了问题。这里有趣的代码从这里恢复，我把数字1、2和3放在内存块的0、1和2位置，这块内存我又把它当成数组来处理。
- en: but now at this point in the story i've，stipulated that wait a minute。i want
    to go ah**d and add a fourth，value how can i do that and let's。stipulate that
    i want to go back and，change the existing program because。suppose that for the
    sake of discussion，this is code that's running at google or。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在在故事的这个阶段，我规定等等。我想去啊**d再添加一个第四个值，我该如何做到这一点，让我们规定我想返回去，更改现有程序，因为。假设为了讨论，这段代码是在谷歌运行的。
- en: twitter over time and it's only after，receiving another tweet that。their code
    realizes oh we need more，15，this time i allocate enough space for，four integers。and
    i again do some error checking if。![](img/0a786619a8ddec04544d001ff89412ad_71.png)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间推移推特，只有在收到另一条推文后，他们的代码才意识到，哦，我们需要更多的，15，这次我分配了足够的空间来存储四个整数。我再次进行一些错误检查，如果。![](img/0a786619a8ddec04544d001ff89412ad_71.png)
- en: won't，happen let's just exit altogether but if，nothing bad happened let's take。santiago's
    suggestion and translate his，english advice into c，let's use a for loop from 0
    to 3 and。memory。![](img/0a786619a8ddec04544d001ff89412ad_73.png)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不会发生，让我们完全退出，但如果没有发生什么坏事，让我们接受圣地亚哥的建议，把他的英文建议翻译成C，让我们使用一个从0到3的for循环和内存。![](img/0a786619a8ddec04544d001ff89412ad_73.png)
- en: the contents of the original chunk of，memory so temp i gets list i。and then
    here which was the point of，number，at temp bracket three which is the，from zero。but
    at this point in the story much like，my earlier slides，i have both the one two
    three in an。array of size three and i have one two，four，let me go ah**d and free
    the original。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 原始内存块的内容，所以temp i获得列表i。然后在这里，temp括号三的点是，从零开始。但是在这个故事的这个阶段，正如我之前的幻灯片一样，我在大小为三的数组中有1、2、3，并且我有1、2、4，让我去啊**d，释放原始内存。
- en: list and give back to the computer that，original chunk of memory。let me then
    remember using my better，named variable，what the address of this new chunk of。![](img/0a786619a8ddec04544d001ff89412ad_75.png)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表并把那块原始内存交还给计算机。让我记住使用我更好命名的变量，这个新内存块的地址。![](img/0a786619a8ddec04544d001ff89412ad_75.png)
- en: memory is and then just to show off let，me go ah**d and with another for loop。this
    time counting four times not three，let me print out all of those values now。here's
    where i'll cross my fingers，compile my new program it does not，compile okay。because
    it looks like i have one too，many parentheses there，so let's recompile the program
    with make。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是，然后只是为了炫耀，让我去啊**d，再用一个for循环。这次计数四次，而不是三次，让我现在打印出所有这些值。这是我交叉手指的地方，编译我的新程序，它没有编译成功，好的。因为看起来我有一个括号多了，所以让我们用make重新编译这个程序。
- en: list another error，so let me scroll up there and oh，interesting。so this is a
    this is a a common mistake，implicitly declaring library function。malloc something
    something，so anytime you get an implicitly，declaring error。odds are it means you
    just did something，simple like this you forgot。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表另一个错误，所以让我向上滚动一下，哦，有趣。所以这是一个常见的错误，隐式声明库函数。malloc某某，所以每当你遇到隐式声明错误，几率是你只是做了简单的事情，比如你忘记了。
- en: the requisite header file in which that，from last week，malloc is in standard
    lib as is free so。now let's do make list cross my fingers，again that time it worked
    dot slash list，voila。one two three four so this is now a。![](img/0a786619a8ddec04544d001ff89412ad_77.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的头文件，上周提到的，malloc在标准库中，free也是。因此现在让我们创建列表，双手合十，希望这次能成功，点斜杠列表，瞧瞧。一二三四，所以这现在是一个。![](img/0a786619a8ddec04544d001ff89412ad_77.png)
- en: completely literal translation，program，that again starts off by using。uh an
    array of size three having，dynamically allocated it and then it。resizes it by
    creating a new one of size，old，and then proceeding as before and i've。deliberately
    used malloc both times here，as follows if you create an array in c。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完全逐字翻译，程序，开始时使用了一个大小为三的数组，动态分配内存，然后通过创建一个新大小为旧大小的数组来调整大小，然后像以前一样进行处理。我故意在这里两次使用malloc，如下所示，如果你在C中创建一个数组。
- en: using squ*re bracket notation，you have painted yourself into a corner。![](img/0a786619a8ddec04544d001ff89412ad_79.png)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号表示法，你把自己困在了一个角落。![](img/0a786619a8ddec04544d001ff89412ad_79.png)
- en: have seen，and resize an array that you have，declared using squ*re brackets。![](img/0a786619a8ddec04544d001ff89412ad_81.png)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，并且调整你用方括号声明的数组大小。
- en: more technically speaking when you use，the squ*re brackets you are statically。allocating
    the array on the stack you're，computer's memory，that belongs to that computer
    to that uh。functions，stack frame per the diagram last week，if however you use
    malloc our new。tool our new tool from last week and say，give me a chunk of memory
    that comes，from the heap。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更技术性地说，当你使用方括号时，你是在栈上静态分配数组，这是计算机内存的一部分，属于该计算机和函数的栈帧。上周的图示中，如果你使用 malloc，我们的新工具，要求从堆中获取内存块。
- en: give back，and take more of and back and forth and，in fact there's even a more。simple
    way of doing this relatively，speaking if you want to reallocate。![](img/0a786619a8ddec04544d001ff89412ad_83.png)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回馈，并且获取更多，来回的，实际上还有一种更简单的方式来进行相对的重新分配。
- en: an array of a chunk of memory by，resizing it，you don't have to do all of this
    which i。did before you don't have to use malloc，twice you can use malloc once
    at the。beginning and then you can use a，new function that's actually kind of，helpful
    in this case called。reallock and you can actually do this，reallock，in a chunk
    of memory of size four times。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整内存块的大小，你不必像之前那样做所有这些，你不需要使用 malloc 两次，你可以在开始时使用一次 malloc，然后使用一个其实在这种情况下非常有用的新函数叫做
    reallock，你实际上可以在大小为四倍的内存块中做到这一点。
- en: size of end but specifically。![](img/0a786619a8ddec04544d001ff89412ad_85.png)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸结束，但具体来说。
- en: reallocate the thing called list so，reallock is very similar to malloc but，it
    takes two arguments。![](img/0a786619a8ddec04544d001ff89412ad_87.png)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配的东西叫做列表，因此 reallock 与 malloc 非常相似，但它接受两个参数。
- en: one is the size of the memory you want，whether bigger or smaller。but it takes
    a second argument its very，first argument now is，the address of a chunk of memory
    that。you have already allocated，as with malloc so again at the top of，malloc。to
    give myself a list that points at a。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个是你想要的内存大小，无论是更大还是更小，但它接受第二个参数，第一个参数是你已经分配的内存块的地址，正如 malloc 的顶端所示。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_89.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_89.png)'
- en: integers，on line 16 i'm now handing that address。![](img/0a786619a8ddec04544d001ff89412ad_91.png)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16行，我现在传递那个地址。
- en: back to reallock saying wait a minute，here's that same address you gave me，please
    now resize it。reallocate it to be of size four and，well，it returns to you the
    address uh in，memory。that it is now of sufficient size，bad one，happens so i'll
    leave that code alone，this。![](img/0a786619a8ddec04544d001ff89412ad_93.png)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 reallock，说等一下，这里是你给我的相同地址，现在请将其调整为大小四，并且它会将现在足够大小的地址返回给你。
- en: reallock actually copies the old into，the new for you so again coming back to。santiago's
    story at the beginning of，today，reallock will not only give you a bigger。chunk
    of memory if you ask for it，by handing back the address of the，memory you already
    requested。and it's going to hand you back the，address of a new chunk of memory。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: reallock 实际上会将旧内存复制到新的内存中，因此再次回到今天一开始的 santiago 故事，reallock 不仅会在你请求时给予你更大的内存块，还会归还你之前请求的内存地址，并且会给你新的内存块地址。
- en: that is big enough to fit all of those，new values and it's smart too。![](img/0a786619a8ddec04544d001ff89412ad_95.png)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空间足以容纳所有新值，而且它也很智能。
- en: if there happens to be room at the very，end of the existing chunk of memory。![](img/0a786619a8ddec04544d001ff89412ad_97.png)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在现有内存块的最后有足够的空间。
- en: slide earlier，then you're actually going to get back，the exact same address
    but the。computer's operating system windows mac，os or linux is going to remember。okay
    yes i know i gave you three bytes，originally there happened to be room at。the
    end of that chunk of memory so now，i'm going to remember instead，integers。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在早先的幻灯片中，你实际上会得到相同的地址，但计算机的操作系统，无论是 Windows、macOS 还是 Linux，都将记住“好的，我知道最初给你分配了三个字节，恰好在那块内存的末尾有空间，所以现在我将记住整型数据”。
- en: or whatever number you pass in so again，yourself，you can let the computer actually
    do the。reallocation，for you any questions then，on malloc on re-alloc on free。![](img/0a786619a8ddec04544d001ff89412ad_99.png)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者传入的任何数字，再次，自己可以让计算机实际为你执行重新分配，有没有任何关于malloc、realloc或free的问题？![](img/0a786619a8ddec04544d001ff89412ad_99.png)
- en: notice that this isn't yet a list this，is still an array，so we still need to
    take this program。![](img/0a786619a8ddec04544d001ff89412ad_101.png)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这还不是一个列表，这仍然是一个数组，因此我们仍然需要处理这个程序。![](img/0a786619a8ddec04544d001ff89412ad_101.png)
- en: one step further and actually transition，from this chunk of memory using arrays。to
    these actual nodes but before we do，that any questions，or confusion brian anything
    we should。touch on here yeah a question came in，why do you not need to free，not
    need to free。temp at the end of the program because，i'm an idiot and glossed over
    that key。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步一步，实际上从使用数组的这块内存过渡到这些实际节点。但在我们这样做之前，有没有问题或困惑，布莱恩，有什么我们需要在这里讨论的吗？是的，有人问，为什么在程序结束时不需要释放临时变量，因为我是个傻瓜，忽略了这个关键点。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_103.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_103.png)'
- en: free not，temp in this case but list so temp i，already，well it is equivalent
    at this point at。![](img/0a786619a8ddec04544d001ff89412ad_105.png)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，要释放的不是临时变量，而是列表，因此临时变量我已经释放，嗯，此时它是等效的。![](img/0a786619a8ddec04544d001ff89412ad_105.png)
- en: this line here 27，better name。![](img/0a786619a8ddec04544d001ff89412ad_107.png)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行27，名称更好。![](img/0a786619a8ddec04544d001ff89412ad_107.png)
- en: and i make it equal to temp so that i，can just refer to it as a bigger list。but
    you are quite right that was an，oversight on my part valgrind would not。have liked
    that at the very end of this，program i should absolutely free list。however i don't
    need to free temp per se，name。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它等于临时变量，这样我就可以将其视为一个更大的列表。不过你说得对，这是我疏忽了，Valgrind肯定不喜欢这种做法。在这个程序的最后，我应该绝对释放列表。然而，我并不需要释放临时变量本身的名称。
- en: '![](img/0a786619a8ddec04544d001ff89412ad_109.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a786619a8ddec04544d001ff89412ad_109.png)'
- en: through that assignment good question，and good catch，unintended other questions
    or comments。a question came in why does the linked，just use，arrays and reallock
    and malloc to do all。this stuff yeah really good question so，how have we improved
    the situation if we，can just use arrays。in this way recall that with this kind，of
    a regression what i just did is a。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于那个任务的好问题和好发现，其他问题或评论。有人问，为什么链表只使用数组和realloc、malloc来处理这些内容？嗯，真的很好的问题，那么我们如何改善这种情况，如果我们可以用这种方式使用数组。回想一下，在这种回归中，我刚刚做的是。
- en: regression to where we started the story，just wrote。![](img/0a786619a8ddec04544d001ff89412ad_111.png)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 回归到我们开始的故事，刚刚写完。![](img/0a786619a8ddec04544d001ff89412ad_111.png)
- en: i reallocated more space for this array，which means that i。![](img/0a786619a8ddec04544d001ff89412ad_113.png)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个数组重新分配了更多空间，这意味着我。![](img/0a786619a8ddec04544d001ff89412ad_113.png)
- en: manually with that for loop or reallock，with its own for loop how to copy all
    of。the old values into the new。![](img/0a786619a8ddec04544d001ff89412ad_115.png)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 手动使用那个for循环，或者用它自己的for循环来复制所有旧值到新的数组中。![](img/0a786619a8ddec04544d001ff89412ad_115.png)
- en: so the approach we've taken in all three，versions of this program that i've。written
    thus far on the fly。![](img/0a786619a8ddec04544d001ff89412ad_117.png)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在到目前为止写的这个程序的三个版本中采取的方法是动态的。![](img/0a786619a8ddec04544d001ff89412ad_117.png)
- en: they've all been big o of n when it，comes to insert。![](img/0a786619a8ddec04544d001ff89412ad_119.png)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到插入时，它们的时间复杂度都是O(n)。![](img/0a786619a8ddec04544d001ff89412ad_119.png)
- en: they have not given us the dynamism of a，duplication。![](img/0a786619a8ddec04544d001ff89412ad_121.png)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 他们没有给我们复制的动态性。![](img/0a786619a8ddec04544d001ff89412ad_121.png)
- en: and we haven't had the ability yet to，just do an insert for instance at the。beginning
    of the structure in big o of，one time so again this is the code，approach。from
    which we began so the ultimate goal，now is going to be to，change this code and
    give us that。as a proper，integers，but we're about an hour in let's go，ahead and
    take our first five minute。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 而且我们还没有能力直接在结构的开头进行插入，时间复杂度为O(1)，所以再次这是我们开始时的代码方法。因此，最终目标将是改变这个代码，并给我们一个适当的整数，但我们已经过了一个小时，让我们先休息五分钟。
- en: break here and we'll come back。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下，我们再回来。
