- en: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P13：L3- 优化算法 3 (回溯搜索等) - ShowMeAI - BV1AQ4y1y7wy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P13：L3- 优化算法 3 (回溯搜索等) - ShowMeAI - BV1AQ4y1y7wy
- en: domain satisfy the unary constraints，where things get a little bit more。interesting
    is when we consider，different types of consistency something。like Arc consistency
    for example an arc，consistency refers to when all of the。values in a variables
    domain satisfy the，variables binary constraints so when。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 域满足一元约束，当我们考虑不同类型的一致性时，事情变得有趣，比如弧一致性。弧一致性指的是当变量域中的所有值满足变量的二元约束时。
- en: we're looking at trying to make a are，consistent we're no longer just。considering
    the unary constraints that，are involve a we're trying to consider。all of the binary
    constraints that，involve a as well so any edge that。connects a to another variable
    inside of，that constraint graph that we were。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在努力使一个一致性，我们不再只是考虑涉及 a 的一元约束，而是尝试考虑所有涉及 a 的二元约束。因此，任何连接 a 与约束图中另一个变量的边。
- en: taking a look at before put a little bit，more formally arc consistency and arc。really
    is just another word for like an，edge that connects two of these nodes。inside
    of our constraint graph we can，define our consistency a little more。precisely
    like this in order to make，some variable X are consistent with。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，弧一致性其实是连接约束图中两个节点的边。我们可以更准确地定义我们的一致性，以便使某个变量 X 与其他变量一致。
- en: respect to some other variable Y we need，to remove any element from X's domain
    to。make sure that every choice for X every，choice in X's domain has a possible。choice
    for Y so put another way if I，have a variable X and I want to make X。and are consistent
    then I'm going to，look at all of the possible values that。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于某个其他变量 Y，我们需要从 X 的域中移除任何元素，以确保 X 的每一个选择，在 X 的域中都有一个可能的 Y 的选择。换句话说，如果我有一个变量
    X，想让 X 和 Y 一致，那么我要查看所有可能的值。
- en: X can take on and make sure that for all，of those possible values there is still。some
    choice that I can make for Y if，there's some arc between x and y to make。sure
    that Y has a possible option that I，can choose as well so let's look at an。example
    of that going back to this，example but from a form we enforced node。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: X 可以接受所有可能的值，并确保对于 Y 仍然存在一些选择，如果 x 和 y 之间存在某个弧，以确保 Y 也有我可以选择的可能选项，所以让我们看一个例子，回到我们强制节点的这个例子。
- en: consistency already by saying that a can，only be on Tuesday or Wednesday because。we
    knew that a could not be on Monday，and we also said that bees only domain。only
    consists of Wednesday because we，know that B does not equal Tuesday and，also be
    the。equal Monday so now let's begin to，consider our consistency let's try and。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性已经通过说 A 只能是星期二或星期三来确定，因为我们知道 A 不能是星期一，而且我们也说 B 的域只包含星期三，因为我们知道 B 不等于星期二，且
    B 也不等于星期一。那么现在让我们开始考虑我们的相容性。
- en: make a are consistent with B and what，that means is to make a are consistent。with
    respect to B means that for any，choice we make in a is domain there is。some choice
    we can make in B is no main，that is going to be consistent and we。can try them
    for a we can choose Tuesday，as a possible value for a if I choose。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使 A 对 B 一致，这意味着对于 A 的域中的任何选择，B 的域中都有某个选择可以保持一致。我们可以选择星期二作为 A 的一个可能值。
- en: Tuesday for a is there a value for B，that satisfies the binary constraint。well
    yes B Wednesday would satisfy this，constraint that a does not equal B。because
    Tuesday does not equal Wednesday，however if we chose Wednesday for a well。then
    there is no choice in B's domain，that satisfies this binary constraint。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 A 选择星期二，那么是否存在满足二元约束的 B 的值？是的，B 为星期三可以满足 A 不等于 B 的约束，因为星期二不等于星期三。然而，如果我们选择星期三作为
    A 的值，那么在 B 的域中没有满足此二元约束的选择。
- en: there is no way I can choose something，for B that satisfies a does not equal
    B。because I know B must be Wednesday and，so if ever I run into a situation like。this
    where I see that here is a possible，value for a such that there is no choice。of
    value for B that satisfies the binary，constraint well then this is not art。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我无法为 B 选择一个满足 a 不等于 B 的选项，因为我知道 B 必须是星期三，因此如果我遇到这样的情况，看到 a 有一个可能的值，而 B 的值没有满足二元约束的选择，那么这就不是一致性。
- en: consistent and to make it art consistent，I would need to take Wednesday and。remove
    it from a is domain because，Wednesday was not going to be a possible。choice I
    can make for a because it，wasn't consistent with this binary。constraint for beet
    there was no way I，could choose Wednesday for a and and。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其一致，并使其保持一致，我需要将星期三移出A的领域，因为星期三对A来说不是一个可能的选择，因为它与这个二元约束不一致，我无法选择星期三作为A的选择。
- en: still have an available solution by，choosing something for B as well so here。now
    I've been able to enforce arc，consistency and in doing so I've。actually solved
    this entire problem that，given these constraints where a and B。can have exams
    on either Monday or，Tuesday or Wednesday the only solution。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以通过为B选择某种东西来找到可用的解决方案，所以在这里。我已经能够执行弧一致性，通过这样做，我实际上解决了整个问题，考虑到这些约束，A和B可以在星期一、星期二或星期三考试，唯一的解决方案。
- en: that it would appear is that A's exam，must be on Tuesday and B's exam must be。on
    Wednesday and that is the only option。![](img/fd50d22d8798c784a4db25b4815b1d56_1.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来A的考试必须在星期二，B的考试必须在星期三，这是唯一的选择。![](img/fd50d22d8798c784a4db25b4815b1d56_1.png)
- en: available to me so if we want to apply，our consistency to a larger graph not。just
    looking at one particular pair of，our consistency there are ways we can do。that
    too and we can begin to formalize，what the pseudocode would look like for。trying
    to write an algorithm that，enforces our consistency and we'll start。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将一致性应用于一个更大的图，不仅仅关注一对变量，也有其他方法可以实现这一点，我们可以开始正式化伪代码，以尝试编写一个强制我们一致性的算法。
- en: by defining the function called revise。![](img/fd50d22d8798c784a4db25b4815b1d56_3.png)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个名为revise的函数。![](img/fd50d22d8798c784a4db25b4815b1d56_3.png)
- en: revise is going to take as input a CSP，otherwise known as a constraint。satisfaction
    problem and also two，variables x and y and what revise is，going to do。it is going
    to make X Ark consistent，with respect to Y meaning remove。anything from X's domain
    that doesn't，allow for a possible option for y how。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: revise函数将作为输入一个CSP（约束满足问题）以及两个变量x和y，revise的作用是使X对Y的弧一致，意味着从X的领域中移除不允许Y的可能选项的任何东西。
- en: does this work well we'll go ahead and，first keep track of whether or not we've。made
    a revision revised is ultimately，going to return true or false。it'll return true
    in the event that we，did make a revision to X's domain it'll。return false if we
    didn't make any，change to X's domain and we'll see in a。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否有效，我们会首先跟踪是否进行了修订，revise最终将返回true或false。如果我们对X的领域进行了修订，它将返回true，如果没有对X的领域进行任何更改，它将返回false，我们将在一个。
- en: moment why that's going to be helpful，but we start by saying revised equals。![](img/fd50d22d8798c784a4db25b4815b1d56_5.png)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们开始了解这将如何有帮助，但我们先说revise等于。![](img/fd50d22d8798c784a4db25b4815b1d56_5.png)
- en: false we haven't made any change in this，then we'll say all right let's go ahead。![](img/fd50d22d8798c784a4db25b4815b1d56_7.png)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有进行任何更改，那么我们会说好的，继续。![](img/fd50d22d8798c784a4db25b4815b1d56_7.png)
- en: and loop over all of the possible values，in X's domain so loop over X's domain。for
    each little X in X's domain I want，to make sure that for each of those。choices
    I have some available choice in，Y that satisfies the binary constraints。that are
    defined inside of my CSP inside，of my constraint satisfaction problem so。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并循环遍历X的领域中的所有可能值，因此遍历X的领域。对于X领域中的每个小X，我想确保对于每个选择，我在Y中有一些可用的选择，满足定义在我的CSP中的二元约束。
- en: if ever it's the case that there is no，value Y in y's domain that satisfies
    the。constraint for x and y well if that's，the case that means that this value
    X。shouldn't be in X's domain so we'll go。![](img/fd50d22d8798c784a4db25b4815b1d56_9.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Y的领域中没有值满足X和Y的约束，那就意味着这个值X不应该在X的领域中，我们将会去。![](img/fd50d22d8798c784a4db25b4815b1d56_9.png)
- en: ahead and delete X from X's domain and，all set revives equal to true because
    I。did change X's domain I changed X's，domain by removing little X and I。removed
    little X because it wasn't art，consistent there was no way I could。choose a value
    for y that would satisfy，this XY constraint so in this case we'll。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接着从X的领域中删除X，并将revise设为true，因为我确实更改了X的领域，移除了小X，因为它不一致，无法为Y选择一个满足XY约束的值，所以在这种情况下我们将。
- en: go ahead and set revised equal true and，we'll do this again and again for every。value
    in X's domain sometimes it might，be fine in other cases it might not。allow for
    a possible choice for y in，which case we need to remove this value。from X's domain
    and at the end we just，return revised to indicate whether or。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修订设置为真，我们将对X的领域中的每个值反复执行这个过程，有时这可能是可以的，但在其他情况下，它可能不允许Y的可能选择，在这种情况下，我们需要从X的领域中移除这个值，最后我们只需返回修订以指示是否。
- en: not we actually made a change so this，function then this revised function is。effectively
    an implementation of what，you saw me do graphically a moment ago。and it makes
    one variable X are，consistent with another variable in this。case Y but generally
    speaking when we，want to enforce our consistency will。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们进行了更改，所以这个函数，修订函数，实际上是你刚才看到的图形实现，它使得一个变量X与另一个变量Y保持一致，但一般来说，当我们希望强制一致性时。
- en: often want to enforce our consistency，not just for a single arc but for the。entire
    constraint satisfaction problem，and it turns out there's an algorithm to。do that
    as well and that algorithm is，known as，see three ac3 takes a constraint。satisfaction
    problem and it enforces art，consistency across the entire problem。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常想要强制一致性，不仅仅是为了一个单一的弧，而是为了整个约束满足问题，事实证明，还有一个算法可以做到这一点，这个算法被称为ac3，ac3处理一个约束满足问题，并在整个问题上强制弧的一致性。
- en: how does it do that well it's going to，basically maintain a queue or basically。just
    a line of all of the arcs than it，needs to make consistent and overtime we。might
    remove things from that queue as，we begin dealing with art consistency。and we
    might need to add things to that，queue as well if there are more things。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何做到这一点的呢？它基本上会维护一个队列，或者说是一条需要保持一致的所有弧的线，随着时间推移，我们可能会从那个队列中移除一些东西，因为我们开始处理弧的一致性，也可能需要向那个队列中添加一些东西，如果有更多的东西。
- en: we need to make are consistent so we'll，go ahead and start with a queue that。contains
    all of the arcs in the，constraint satisfaction problem all of。the edges that connect
    to nodes that，have some sort of binary constraint。![](img/fd50d22d8798c784a4db25b4815b1d56_11.png)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让它们保持一致，所以我们将开始一个包含约束满足问题中所有弧的队列，所有连接到具有某种二元约束的节点的边。![](img/fd50d22d8798c784a4db25b4815b1d56_11.png)
- en: between them and now as long as the，queue is not empty there is work to be。done
    the queue is all of the things that，we need to make are consistent so as。long
    as the queue is not empty there's，still things we have to do what do we。have to
    do well we'll start by D queuing，from the queue remove something from the。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 只要队列不为空，就还有工作要做。队列中的所有内容都是我们需要保持一致的东西，所以只要队列不为空，我们还有事情要做。我们需要做什么呢？我们将首先从队列中去掉一个元素，移除队列中的某个东西。
- en: queue and strictly speaking it doesn't，need to be a queue but a queue is a。traditional
    way of doing this，well DQ from the queue and that will，give us an arc x and y
    these two。variables where I would like to make X，are consistent with Y so how
    do we make。X are consistent with Y well we can go，ahead and just use that revised
    function。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 队列，严格来说，它不需要是一个队列，但队列是一个传统的做法，好的，从队列中去掉（DQ），这将给我们一个弧x和y，这两个变量我希望让X与Y保持一致。那么我们如何让X与Y保持一致呢？我们可以继续使用刚才提到的修订函数。
- en: that we talked about a moment ago，we called the revise function passing as。input
    the constraint satisfaction，problem and also these variables x and y。because I
    want to make X are consistent，with Y in other words remove any values。from X's
    domain that don't leave an，available option for Y and recall what。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为修订函数，输入是约束满足问题，以及这些变量x和y。因为我希望让X与Y保持一致，换句话说，去掉X的领域中不留下Y可用选项的值，回想一下。
- en: does revise return well it returns true，if we actually made a change if we。removed
    something from X's domain，because there wasn't an available option。for Y for example
    and it returns false，if we didn't make any change to X's。domain at all and it
    turns out if revise，returns false if we didn't make any。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 修订返回什么呢？如果我们实际上进行了更改，它返回真，如果我们从X的领域中移除了一些东西，因为没有Y的可用选项，例如，它返回假，如果我们没有对X的领域进行任何更改，结果是如果修订返回假，我们就没有进行任何。
- en: changes well then there's not a whole，lot more work to be done here for this。arc
    we can just move ahead to the next，arc that's in the queue but if we did。make
    a change if we did reduce X's，domain by removing values from X's。domain well then
    what we might realize，is that this creates potential problems。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变化不大，那么这里不需要做太多的工作，我们可以直接进入队列中的下一个弧线，但如果我们确实做了变化，减少了X的域，移除了X域中的值，那么我们可能意识到这会造成潜在的问题。
- en: later on that it might mean that some，arc that was are consistent with X that。node
    might no longer be our consist，with ex because while there used to be。an option
    that we could choose for X now，there might not be because now we might。have removed
    something from X that was，necessary for some other arc to be art。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 后来这可能意味着某个与X的节点一致的弧线可能不再与X一致，因为我们曾经有一个选项可以选择X，现在可能没有，因为我们可能移除了X的一些内容，这对某些其他弧线的艺术保持是必要的。
- en: consistent and so if ever we did revise，X's domain we're going to need to add。some
    things to the queue some additional，we do that，well first thing we want to check
    is to。make sure that X's domain is not 0 if X，is domain is 0 that means there
    are no。available options for X at all and that，means that there's no way you can
    solve。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们确实修订了X的域，我们需要向队列中添加一些额外的内容，首先我们想检查的是确保X的域不为0，如果X的域为0，意味着X没有可用的选项，这意味着无法解决。
- en: the constraint satisfaction problem if，we've removed everything from X's domain。we'll
    go ahead and just return false，here to indicate there's no way to solve。the problem
    because there's nothing left，in X's domain but otherwise if there are。things left
    in X's domain but fewer，things than before well then what we'll。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从X的域中移除了所有元素，我们将返回false，表示没有办法解决问题，因为X的域中没有剩余的内容，但如果X的域中还有东西，但比之前少，那么我们将。
- en: do is we'll loop over each variable Z，that is in all of X's and neighbors。except
    for y y we already handled but，we'll consider all of X as other's。neighbors and
    ask ourselves all right，will that arc from each of those Z's to。X that arc might
    no longer be our，consistent because well for each a Z。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是遍历每个变量Z，这些变量在所有X及其邻居中，除了我们已经处理过的y，我们将把X视为其他邻居，并问自己，"好吧，从这些Z到X的弧线可能不再是**一致的**，因为对于每个Z"。
- en: there might have been a possible option，we could choose for X to correspond
    with。each of these possible values now there，might not be because we removed some。elements
    from X's domain and so what，we'll do here is we'll go ahead and end。Q adding something
    to the Q this arc Z X，for all of those neighbors Z so we need。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一个选项，我们可以选择让X对应于每个可能的值，但现在可能没有，因为我们从X的域中移除了某些元素，因此我们在这里要做的是继续向Q添加一些内容，这条弧Z到X，对于所有这些邻居Z。
- en: to add back some arcs to the Q in order，to continue to enforce our consistency。at
    the very end if we make it through，all this process then we can return true。but
    this now is a c3 this algorithm for，enforcing arc consistency on a。constraint
    satisfaction problem and the，big idea is really just keep track of。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一些弧线添加回Q，以继续保持一致性，最后如果我们顺利完成了这个过程，我们就可以返回true。但这现在是一个c3算法，用于在约束满足问题上强制执行弧线一致性，主要思想就是**跟踪**一致性。
- en: all of the arcs that we Knight might，need to make art consistent make it art。consistent
    by calling the revise，function and if we did revise it then。there are some new
    arcs that might need，to be added to the queue in order to。make sure that everything
    is still are，consistent even after we've removed some。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们骑士可能需要使所有的弧线保持一致，以便将其称为艺术，通过调用修订功能，如果我们进行了修订，那么可能有一些新的弧线需要添加到队列中，以确保即使在删除了一些之后，一切仍然是**一致的**。
- en: of the elements from a particular，variables of domain so what then would。happen
    if we try to enforce arc，consistency on a graph like this on a。graph where each
    of these variables has，a domain of Monday Tuesday and Wednesday。well it turns
    out that by enforcing art，consistency on this graph well it can。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个特定变量的域中的元素，如果我们尝试在这样的图上强制执行弧线一致性，即每个变量的域是星期一、星期二和星期三，结果发现，通过在这个图上强制执行弧线一致性。
- en: solve some types of problems nothing，actually changes here for any particular。art
    just considering two variables，there's always a way for me to just for。any of
    the choices I make for one of，them make a choice for the other one。because there
    are three options and I，just need the two to be different from。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解决某些类型的问题这里实际上没有任何变化，对于任何特定的约束，只要考虑两个变量，我总有一种方法可以为我做出的选择之一做出另一种选择，因为有三种选择，我只需要确保两个是不同的。
- en: each other so this is actually quite，easy to just take an arc and just。declare
    that it is aren't consistent，because if I pick you know Monday for D。then I just
    pick something that isn't，Monday for B in art consistency we only。consider consistency
    between a binary，constraint between two nodes and and。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 彼此之间实际上很容易只需取一个弧并声明它不一致，因为如果我选择星期一作为D，然后为B选择一个不是星期一的东西，在弧一致性中我们只考虑两个节点之间的二元约束的一致性。
- en: we're not really considering all of the，rest of the nodes yet so just using
    a c3。the enforcement of art consistency that，can sometimes have the effect of。reducing
    domains to make it easier to，find solutions but it will not always。actually solve
    the problem we might，still need to somehow search to try and。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上还没有考虑所有其他节点，所以仅使用C3约束的一致性执行有时会产生缩小域的效果，从而使得找到解决方案更容易，但并不总能解决问题，我们可能仍然需要以某种方式搜索以尝试满足条件。
- en: find a solution and we can use classical，traditional search algorithms to try
    to。do so you'll recall that a search，problem generally consists of these。parts
    we have some initial State some，actions a transition model that takes me。from
    one state to another state a goal，test to tell me have I satisfied my。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，搜索问题通常由这些部分组成：一些初始状态，一些行动，一个过渡模型将我从一个状态转移到另一个状态，一个目标测试来告诉我是否满足我的要求。
- en: objective correctly and then some path，cost function because in the case of。like
    maze solving I was trying to get to，my goal as quickly as possible so you。could
    formulate a CSP or a constraint，satisfaction problem as one of these。types of
    search problems the initial，state will just be an empty assignment。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目标正确，然后某些路径、成本函数因为在这种情况下。像迷宫求解，我试图尽快到达我的目标，所以你可以将一个约束满足问题（CSP）或约束满足问题表述为这些搜索问题之一，初始状态将只是一个空的赋值。
- en: where an assignment is just a way for me，to assign any particular variable to
    any。particular value so if an empty，assignment is no variables are assigned。to
    any values yet then the action I can，take is adding some new variable equals。value
    pair to that assignment saying for，this assignment let me add a new value。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值只是我将任何特定变量分配给任何特定值的一种方式，因此如果一个空的赋值没有变量被分配给任何值，那么我可以采取的行动是向该赋值中添加一些新的变量等于值的对，表示对于这个赋值，让我添加一个新值。
- en: for this variable then the transition，model just defines what happens when you。take
    that action you get a new，assignment that has that variable equal。to that value
    inside of it the goal test，is just checking to make sure all the。variables have
    been assigned and making，sure all the constraints have been。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个变量，过渡模型只是定义了当你采取该行动时会发生什么，你会得到一个新的赋值，该赋值中包含该变量等于那个值，目标测试只是检查确保所有变量都已被赋值，并确保所有约束已被满足。
- en: satisfied and the path cost function I'm，sort of irrelevant I don't really care。about
    what the path really is I just，care about finding some assignment that。actually
    satisfies all of the，constraints so really all the paths have。the same cost I
    don't really care about。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 路径成本函数我有点无关紧要，我并不在意路径的具体形式，我只关心找到一个实际上满足所有约束的赋值，因此实际上所有路径的成本都是相同的，我并不关心。
- en: '![](img/fd50d22d8798c784a4db25b4815b1d56_13.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd50d22d8798c784a4db25b4815b1d56_13.png)'
- en: the path to the goal I just care about，the solution itself much as we've talked。about
    now before the problem here though，is that if we just implement this naive。search
    algorithm just by implementing，like breadth-first search or depth-first。search
    this is going to be very very，inefficient and there are ways we can。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我只关心到达目标的路径，实际上我们之前谈过的问题是，如果我们仅仅通过实现简单的搜索算法，如广度优先搜索或深度优先搜索来实现，这将是非常非常低效的，还有其他方法我们可以找到解决方案，并可以使用经典的传统搜索算法来尝试实现。
- en: take advantage of efficiencies in the，structure of a constraint satisfaction。problem
    itself and one of the key ideas，is that we can really just order these。variables
    and and it doesn't matter what，order we assign variables in the。assignment a equals
    2 and then B equals，8 is identical to the assignment of B。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 利用约束满足问题本身结构中的效率，而一个关键理念是我们真的可以对这些变量进行排序，且赋值的顺序并不重要。赋值a等于2，然后B等于8与B的赋值是相同的。
- en: equals 8 and then a equals 2 switching，the order doesn't really change anything。about
    the fundamental nature of that，assignment and so there are some ways。that we can
    try and revise this idea of，a search algorithm to apply it。specifically for a
    problem like a，constraint satisfaction problem and it。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 等式为8，然后a等于2的切换，顺序并不会改变任何东西。关于这一基本性质，赋值存在一些方式。我们可以尝试修订这个想法，运用搜索算法来专门应用于像约束满足问题这样的一个问题。
- en: turns out the search algorithm will，generally use when talking about。constraint
    satisfaction problems if，something known as backtracking search。and the big idea
    of backtracking search，is we'll go ahead and make assignments。to from variables
    to values them and if，ever we get stuck we arrive at a place。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，谈到约束满足问题时，搜索算法通常会使用称为回溯搜索的东西。回溯搜索的核心理念是，我们将继续对变量与其值进行赋值，如果我们遇到阻碍，就会到达一个地方。
- en: where there is no way we can make any，forward progress while still preserving。the
    constraints that we need to enforce，we'll go ahead and backtrack and try。![](img/fd50d22d8798c784a4db25b4815b1d56_15.png)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们无法取得任何进展的情况下，同时仍然保持需要强制执行的约束，我们将继续回溯并尝试。![](img/fd50d22d8798c784a4db25b4815b1d56_15.png)
- en: something else instead so the very basic，sketch of what backtracking search
    looks。like is it looks like this function，called backtrack that takes as input
    an。assignment and a constraint satisfaction，problem so initially we don't have
    any。assigned variables someone would begin，backtracking search this assignment
    is。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种东西，因此回溯搜索的基本草图是这样的，类似于一个叫回溯的函数，接受赋值和约束满足问题作为输入。因此最初我们没有任何分配的变量，某人将开始进行回溯搜索，这个赋值是。
- en: just going to be the empty assignment，with no variables inside of it but we'll。see
    later this is going to be a，recursive function so backtrack takes as。input the
    assignment and the problem if，the assignment is complete meaning all。of the variables
    have been assigned we，just return that assignment that of。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将会是空的赋值，里面没有变量，但我们稍后会看到这是一个递归函数，因此回溯函数的输入是赋值和问题。如果赋值已完成，意味着所有变量都已被分配，我们只需返回该赋值。
- en: course won't be true initially because，we start with an empty assignment but。over
    time we might add things to that，assignment so if ever the assignment。actually
    is complete then we're done，then just go ahead and return that。assignment but
    otherwise there is some，work to be done I said what we'll need。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这并不成立，因为我们以空的赋值开始，但随着时间的推移，我们可能会向该赋值中添加内容。因此，如果赋值实际上已完成，那么我们就完成了，接下来只需返回该赋值；否则，还有一些工作要做，我说我们需要。
- en: to do is select an unassigned variable，for this particular problem。need to take
    the problem look at the，variables that have already been。assigned and pick a variable
    that has，not yet been assigned and I'll go ahead。and take that variable and then
    I need，to consider all of the values in that。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要做的是选择一个未分配的变量，针对这个特定问题。需要查看已经被分配的变量，并选择一个尚未被分配的变量，然后我会继续使用该变量，接下来我需要考虑该变量的所有值。
- en: variables domain so we'll go ahead and，call this domain values function we'll。talk
    a little more about that later that，takes a variable and just gives me back。an
    ordered list of all of the values in，its domain so I've taken a random。unselected
    variable I'm going to loop，over all of the possible values and the。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的领域，因此我们将继续调用这个领域值函数，稍后我们会详细讨论，它接受一个变量并返回其领域中所有值的有序列表。所以我选择了一个随机的未选择变量，将循环遍历所有可能的值。
- en: idea is let me just try all of these，values as possible values for the。variable
    so if the value is consistent，with the assignment so far it doesn't。violate any
    of the constraints well then，let's go ahead and add variable equals。value to the
    assignment because it's so，far consistent and now let's recursively。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是让我尝试所有这些值作为变量的可能值，因此如果该值与到目前为止的赋值一致，不违反任何约束，那么我们就继续将变量等于值添加到赋值中，因为到目前为止是一致的，现在让我们递归进行。
- en: call backtrack to try and make the rest，of the assignments also consistent so。we'll
    go ahead and call backtrack on，this new assignment that I've added this。new variable
    equals value to and now I，recursively call backtrack and see what。the result is
    and if the result isn't a，failure well then let me just return。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回调回溯以尝试使其余的分配也保持一致。所以我们将继续对我添加的新分配调用回溯，这个新变量等于值2，现在我递归地调用回溯，看看结果是什么，如果结果不是失败，那么让我返回。
- en: that result and otherwise what else，could happen well if it turns out the。result
    was a failure well then that，means this value was probably a bad。choice for this
    particular variable，because when I assign this variable。equal to that value eventually
    down the，road I ran into a situation where I。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那个结果，否则还有什么可能发生呢？如果结果是失败，那就意味着这个值可能是这个特定变量的一个糟糕选择，因为当我将这个变量等于那个值时，最终我遇到了一个情况。
- en: violated constraints it was nothing more，like a doom so now I'll remove variable。equals
    value from the assignment，effectively backtracking say all right。that value didn't
    work let's try another，value instead and then at the very end。if we were never
    able to return a，complete assignment we'll just go ahead。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 违反约束条件，它没有什么更多的意义，只是注定失败。因此，现在我将从分配中移除变量等于值，有效地进行回溯，说明，好的，这个值不行，让我们尝试另一个值，然后在最后，如果我们从未能够返回完整的分配，我们就继续。
- en: and return failure because that means，that none of the values worked for this。particular
    variable this know is the，idea for backtracking search to take。each of the variables
    that try values，for them and recursively try。backtracking search see if we can
    make，progress and if ever we run into a dead。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 返回失败，因为这意味着没有任何值适用于这个特定变量，这是回溯搜索的理念，尝试每个变量的值并递归地尝试回溯搜索，看看我们能否取得进展，如果我们遇到死胡同。
- en: end we run into a situation where there，is no possible value we can choose that。satisfies
    the constraints we return，failure and that propagates up and。eventually we make
    a different choice by，going back and trying something else。instead so let's put
    this algorithm into，practice it's actually try and use back。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们遇到了一个情况，即没有可能的值可以选择，满足约束条件，我们返回失败，并且这个失败向上传播，最终我们通过回退尝试其他选择。因此，让我们将这个算法付诸实践，实际上就是尝试使用回溯。
- en: search to solve this problem now where I，need to figure out how to assign each
    of。these courses to an exam slot on Monday，or Tuesday or Wednesday。in such a way
    that it satisfies these，constraints that each of these edges。mean those two classes
    cannot have an，exam on the same day so I can start by。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要解决这个问题，我需要弄清楚如何将这些课程分配到周一、周二或周三的考试时段，以满足这些约束条件，这些边意味着这两门课程不能在同一天考试，所以我可以开始。
- en: just like starting at a node doesn't，really matter which I start with but in。this
    case we'll just start with a and，I'll ask a question like all right let。me loop
    over the values from the domain，and maybe in this case I'll just start。with Monday
    and say all right let's go，ahead and assign a to Monday we'll just。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从某个节点开始并不重要我选择哪个，但在这种情况下，我们将从A开始，并且我会问一个问题，比如，好吧，让我循环遍历域中的值，也许在这种情况下，我将从周一开始，并说，好的，让我们将A分配给周一。
- en: go and order Monday Tuesday Wednesday，and now let's consider a node B all。right
    so I've made an assignment to a so，I recursively call backtrack with this。new
    part of the assignment now I'm，looking to pick another on assigned。variable like
    B and I'll say all right，maybe I'll start with Monday because。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照顺序考虑节点B，所以我已经对A进行了分配，我递归调用回溯并查看这个新的分配部分，现在我希望选择另一个未分配的变量，比如B，我会说，好吧，也许我从周一开始。
- en: that's the very first value in B is，domain and I ask all right doesn't。Monday
    violate any constraints and it，turns out yes it does it violates this。constraint
    here between a and B because，a and B are now both on Monday and that。doesn't work
    because B can't be on the，same day as a so that doesn't work so we。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是B的域中的第一个值，我问，好吧，周一是否违反任何约束条件，结果是，是的，它确实违反了这个约束，因为A和B现在都在周一，这不行，因为B不能和A在同一天。
- en: might instead try Tuesday try the next，value in B's domain and is that。consistent
    with the assignment so far，well yeah be Tuesday a Monday that is。consistent so
    far because they're not on，the same day so that's good now we can。recursively
    call backtrack try again，pick another unassigned variable。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能尝试周二，尝试B的下一个值，这与目前的赋值一致吗？嗯，是的，周二与周一一致，因为它们不在同一天，这很好。现在我们可以递归调用回溯，再次尝试，选择另一个未分配的变量。
- en: something like D and say alright let's，go through its possible values is Monday。consistent
    with this assignment well yes，it is B and D are on different days。Monday versus
    Tuesday and a and B are，also on different days Monday versus。Tuesday so that's
    fine so far too well，go ahead and try again maybe we'll go to。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于D，我说好的，让我们看看它的可能值，周一与这个赋值一致吗？嗯，是的，B和D在不同的日子，周一对比周二，A和B也在不同的日子，周一对比周二，所以这也很好。接下来我们可以再试一下，也许我们会去。
- en: this variable here e say can we make，that consistent let's go through the。possible
    values we've recursively called，backtrack we might start with Monday and。say all
    right that's not consistent，because D and E now have exams on the。same day so
    we might try Tuesday instead，going to the next one ask is that。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量e说，我们能使其一致吗？让我们看看可能的值，我们已经递归调用了回溯，我们可以从周一开始，好的，这不一致，因为D和E现在在同一天有考试，所以我们可能尝试周二，继续下一个，问这是否。
- en: consistent well no it's not because b，and e those have exams on the same day。and
    so we try all right is Wednesday，consistent and it turns out all right。yes it
    is Wednesday is consistent，because D and E now have exams on。different days B
    and E now have exams on，different days all seems to be well so。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性，不，这不是，因为B和E在同一天有考试。所以我们尝试，好的，周三一致吗？结果显示，好的，是的，周三一致，因为D和E现在在不同的日子，B和E现在在不同的日子，一切似乎都很好。
- en: far I recursively call backtrack select，another unassigned variable we'll say，let's
    try the。values that si could take on let's start，with Monday and it turns out
    that's not。consistent because now a and C both have，exams on the same day so I
    tried to z'。day and say that's not consistent either，because B and C now have
    exams on the。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我递归调用回溯，选择另一个未分配的变量，我们可以尝试si可能取的值，从周一开始，结果显示这不一致，因为现在A和C都有考试在同一天，所以我尝试了z'，说这也不一致，因为B和C现在在同一天有考试。
- en: same day and then I say alright let's go，ahead and try Wednesday but that's
    not。consistent either because C and eeeh，each have exams on the same day too so。now
    we've gone through all the possible，values for C Monday Tuesday and。Wednesday
    and none of them are，consistent there is no way we can have a。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同一天，然后我说好的，继续尝试周三，但这也不一致，因为C和eee也在同一天有考试。所以现在我们已经遍历了C的所有可能值，周一、周二和周三，但没有一个一致，我们无法有一个。
- en: consistent assignment backtrack in this，case we'll return to failure and so
    then。we'd say all right we have to backtrack，back here well now for e we've tried
    all。of Monday Tuesday and Wednesday and none，of those work because Wednesday which。seemed
    to work turned out to be a，failure so that means there's no。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性赋值回溯在这种情况下，我们将返回失败，因此我们会说，好的，我们必须在这里回溯。现在对于e，我们已经尝试过周一、周二和周三，但没有一个有效，因为周三看似有效，结果却是失败，这意味着没有。
- en: possible way we can assign e so that's a，failure too we have to go back up to
    D。which means that Monday assignment to D，that must be wrong we must try something。else
    so we can try right what if D is 2，what if instead of Monday we try to x'。day
    Tuesday it turns out is not，consistent because B and D now have an。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是我们可以给e赋值的可能方式，这也是一个失败，我们必须回到D，这意味着对D的周一赋值一定是错误的，我们必须尝试别的东西。那么我们可以尝试，假设D是2，如果我们尝试下一个值周二，结果显示这也不一致，因为B和D现在有。
- en: exam on the same day but Wednesday as it，turns out works and now we can begin
    to。mix them forward progress again we go，back to E and say all right which of。these
    values works Monday turns out to，work by not violating any constraints。then we
    go up to C now Monday doesn't，work as a violate the constraint，violates two actually。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同一天的考试，但结果周三有效，现在我们可以开始进行前向推进。我们回到E，说好的，哪一个值有效，周一结果有效，没有违反任何约束。然后我们回到C，周一不行，因为它违反了约束，实际上违反了两个。
- en: Tuesday doesn't work as a violate to，constraint as well but Wednesday does。work
    then we can go to the next variable，F and say all right does Monday work。we'll
    know what violates a constraint，but Tuesday does work and then finally。we can
    look at the last variable G，recursively calling backtrack one more。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 星期二也不行，违反了约束，但星期三可行。那么我们可以查看下一个变量F，问星期一是否可行。我们会知道哪个违反了约束，但星期二是可行的，然后最终我们可以查看最后一个变量G，再次递归调用回溯。
- en: time Monday is inconsistent that，violates a constraint Tuesday also。violates
    a constraint but Wednesday that，doesn't violate a constraint and so now。at this
    point we recursively call，backtrack one last time we now have a。satisfactory assignment
    of all of the，variables and at this point we can say。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 时间星期一是不一致的，这违反了约束条件；星期二也违反了一个约束，但星期三则没有违反约束，因此现在我们可以说。在这一点上，我们递归调用，最后一次回溯，我们现在有了一个令人满意的所有变量的分配。
- en: that we are now done we have now been，able to successfully assign a variable。or
    a value to each one of these，variables in such a way that we're not。violating
    any constraints we're gonna go，ahead and have classes a and E ax have。their exams
    on Monday classes B and F，can have their exams on Tuesday and，classes C D and。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了，我们已经能够成功为每个变量分配一个值，以一种不违反任何约束的方式，我们将继续进行类A和E的考试在星期一，类B和F可以在星期二考试，类C和D则是。
- en: gee can have their exams on Wednesday，and there's no violated constraints that。might
    come up there so that was a，graphical look at how this might work。let's now take
    a look at some code we，could use to actually try and solve this。problem as well
    so here I'll go ahead。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，学生们可以在星期三进行考试，没有违反的约束可能会出现，因此这是一个图形化的方式来看这可能如何运作。现在让我们看一些可以实际用来解决这个问题的代码，所以我会继续。
- en: '![](img/fd50d22d8798c784a4db25b4815b1d56_17.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd50d22d8798c784a4db25b4815b1d56_17.png)'
- en: and go into the scheduling directory，we're here now we'll start by looking at。schedule
    0 PI we're here I define a list，of variables，ABCD efg those are all the different。classes
    then underneath that I define my，list of constraints so constraint a and。B that
    is a constraint because they，can't be on the same day and likewise a。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 进入调度目录，我们现在在这里，我们将开始查看schedule 0 PI。我定义了一组变量，A、B、C、D、E、F、G，这些是所有不同的班级。然后在下面，我定义了我的约束列表，比如约束A和B，因为它们不能在同一天，类似地A和C，B和C等等，强制执行这些相同的约束。
- en: and C B and C so on and so forth，enforcing those exact same constraints。and
    here then is what the backtracking，function might look like first if the。assignment
    is complete if I've made an，assignment of every variable to a value。go ahead and
    just return that assignment，then we'll select an unassigned variable。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是回溯函数的样子，首先如果分配已完成，如果我已将每个变量分配给一个值，就继续返回该分配，然后选择一个未分配的变量。
- en: from that assignment then for each of，the possible values in the domain Monday。Tuesday
    Wednesday let's go ahead and，create a new assignment that assigns the。variable
    to that value I'll call this，consistent function which I'll show you。in a moment
    that just checks to make，sure this new assignment is consistent。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个分配开始，对于星期一、星期二、星期三领域中的每一个可能值，让我们创建一个新的分配，将变量分配给该值。我会称之为一致性函数，稍后我会向你展示，这个函数只会检查这个新的分配是否一致。
- en: but if it is consistent we'll go ahead，and call backtrack to go ahead and。continue
    trying to run backtracking，search and as long as the result is not。none meaning
    it wasn't a failure we can，go ahead and return that result but if。we make it through
    all the values and，nothing works then it is a failure。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它是一致的，我们将继续调用回溯，继续尝试运行回溯搜索，只要结果不是None，意味着不是失败，我们就可以返回该结果。但如果我们遍历了所有值，没有任何效果，那就是失败。
- en: there's no solution we go ahead and，return none here what are these。functions
    do select unassigned variable，it's just going to choose a variable not。yet assigned
    so it's going to loop over，all the variables and if it's not。already assigned
    we'll go ahead and just，return that variable and what does the。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 没有解决方案，我们继续返回None。这些函数做什么？选择未分配的变量，它只是选择一个尚未分配的变量，所以它会遍历所有变量，如果它尚未分配，我们将返回该变量。
- en: consistent function do well the，consistent function goes through all the。constraints
    and if we have a situation，where we've assigned both of those。values to variables
    but they are the，same well then that is a violation of。the constraint in which
    case we'll，return false but if nothing is。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性函数运行良好，一致性函数会遍历所有约束，如果我们在分配了这两个变量的值但它们相同的情况下，那么这就是对约束的违反，在这种情况下我们将返回 false，但如果没有。
- en: inconsistent then the assignment is，consistent and we'll return true and。then
    all the program does is it calls，empty，dictionary that has no variable assigned。![](img/fd50d22d8798c784a4db25b4815b1d56_19.png)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的情况下，该分配是一致的，我们将返回 true，然后程序所做的就是调用一个空字典，该字典没有变量被赋值。![](img/fd50d22d8798c784a4db25b4815b1d56_19.png)
- en: to no values yet save that inside a，solution and then print out dot solution。so
    by running this now I can run Python，schedule 0 PI and what I get as a result。of
    that is an assignment of all these，variables to values and turns out we。sign a
    to Monday is we would expect be，it a Tuesday C to Wednesday and exactly。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有值，将其保存在解决方案中，然后打印出 dot 解决方案。因此通过现在运行这个，我可以运行 Python，调度 0 PI，而我得到的结果是所有这些变量到值的分配，结果我们分配给星期一的是我们预期的星期二，C
    分配给星期三，正好。
- en: the same type of thing we were talking，about before an assignment of each of。these
    variables to values that doesn't。![](img/fd50d22d8798c784a4db25b4815b1d56_21.png)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过的相同类型的东西，每个这些变量到值的赋值都不会。![](img/fd50d22d8798c784a4db25b4815b1d56_21.png)
- en: violate any constraints and I had to do，a fair amount of work in order to。implement
    this idea myself I had to，write the BACtrack function that went。ahead and went
    through this process of，recursively trying to do this。backtracking search but
    it turns out the，constraint satisfaction problems are so。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 违反任何约束，我必须做相当多的工作来实现这个想法，我必须编写 BACtrack 函数，它会递归地进行回溯搜索，但事实证明，约束满足问题是如此。
- en: popular that there exist many libraries，that already implement this type of
    idea。again as with before the specific，library is not as important as the fact。that
    libraries do exist this is just one，example of a Python constraint library。where
    now rather than having to do all，the work from scratch inside of schedule。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种想法非常流行，已经存在许多库实现了这种类型的想法。同样，像之前一样，特定的库并不重要，重要的是库确实存在，这只是一个 Python 约束库的例子，现在不必从头开始完成所有工作。
- en: 1 dot pi i'm just taking advantage of a，library that implements a lot of these。ideas
    already so here i create a new，problem add variables to it with。particular domains
    i add a whole bunch，of these individual constraints where i。call add constraint
    and pass in a，function describing what the constraint。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 1 dot pi 我只是利用一个已经实现了很多这些想法的库，因此我在这里创建了一个新问题，并添加了特定领域的变量，我添加了一整堆这些单独的约束，我称之为添加约束，并传入描述约束的函数。
- en: is and the constraint basically says the，function that takes two variables x
    and。y and makes sure that X is not equal to，Y enforcing the idea that these two。classes
    cannot have exams on the same，day and then for any constraint。satisfaction problem
    I can call get，solutions to get all the solutions to。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 约束基本上是说，这个函数接受两个变量 x 和 y，并确保 X 不等于 Y，强制这两个班级不能在同一天进行考试，然后对于任何约束满足问题，我可以调用获取解决方案来获得所有解决方案。
- en: that problem and then for each of those。![](img/fd50d22d8798c784a4db25b4815b1d56_23.png)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那个问题，然后对于每一个！[](img/fd50d22d8798c784a4db25b4815b1d56_23.png)
- en: solutions print out what that solution，happens to be and if I run Python。![](img/fd50d22d8798c784a4db25b4815b1d56_25.png)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案打印出该解决方案是什么，如果我运行 Python。![](img/fd50d22d8798c784a4db25b4815b1d56_25.png)
- en: schedule 1 dot PI and I see they're，actually a number of different solutions。![](img/fd50d22d8798c784a4db25b4815b1d56_27.png)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 调度 1 dot PI，我看到实际上有许多不同的解决方案。![](img/fd50d22d8798c784a4db25b4815b1d56_27.png)
- en: that can be used to solve the problem，there in fact 6 different solutions。assignments
    of variables to values that，will give me a satisfactory answer to。![](img/fd50d22d8798c784a4db25b4815b1d56_29.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来解决问题，实际上有 6 种不同的变量赋值方案，可以给我一个令人满意的答案。![](img/fd50d22d8798c784a4db25b4815b1d56_29.png)
- en: this constraint satisfaction problem so，this then was an implementation of a。very
    basic backtracking search method，where really we just went through each。of the
    variables picked one that wasn't，assigned tried the possible values the。variable
    could take on and then if it，was what if it worked if it didn't。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个约束满足问题的实现，实际上这是一个非常基本的回溯搜索方法，我们只需逐个变量，选择一个未分配的，尝试该变量可以取的可能值，然后判断如果成功，若不成功则回溯。
- en: violate any constraints then，kept trying other variables and if ever。we hit
    a dead end we had to backtrack，but ultimately we might be able to be a。little
    bit more intelligent about how we，do this in order to improve the。efficiency of
    how we solve these sorts，of problems and one thing we might。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果违反任何约束条件，我们会继续尝试其他变量，如果遇到死胡同，我们就得回溯，但**最终**我们可能会更聪明地解决这些问题，从而提高解决这类问题的效率。
- en: '![](img/fd50d22d8798c784a4db25b4815b1d56_31.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd50d22d8798c784a4db25b4815b1d56_31.png)'
- en: imagine trying to do is going back to，this idea of inference using the。knowledge
    we know to be able to draw，conclusions in order to make the rest of。the problem-solving
    process a little bit，easier and let's now go back to where we。got stuck in this
    problem the first time，when we were solving this constraint。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们要回到推理的想法，利用我们已知的知识来得出结论，以便让后续的问题解决过程更容易。现在让我们回到第一次遇到困难的地方，即在解决这个约束时。
- en: satisfaction problem we dealt with B and，then we went on to D and we went ahead。and
    just assigned D to Monday because，that seemed to work with the assignment。so far
    it didn't violate any constraints，but it turned out that later on that。choice
    turned out to be a bad one that，that choice wasn't consistent with the。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决了B的满足问题，然后转向D，并将D分配给星期一，因为这似乎与之前的分配一致。到目前为止并没有违反任何约束，但后来发现这个选择实际上是错误的。
- en: rest of the values that we could take on，here and the question is is there。anything
    we could do to avoid getting，into a situation like this avoid trying。to go down
    a path that's ultimately not，going to lead anywhere by taking。advantage of knowledge
    that we have，initially and it turns out we do have。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以采用其余的值，问题是我们能否避免陷入这样的境地，避免走上一条**最终**不会通往任何地方的路径，通过利用我们已有的知识，结果证明我们确实拥有这些知识。
- en: that kind of knowledge we can look at，just the structure of this graph so far。and
    we can say that right now C's domain，for example contains values Monday，Tuesday
    and Wednesday。and based on those values we can say，that this graph is not arc
    consistent。recall that art consistency is all about，making sure that for every
    possible。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看这个图的结构，目前C的范围包含星期一、星期二和星期三。基于这些值，我们可以说这个图不是弧一致的。回想一下，弧一致性是确保每个可能的情况都能满足。
- en: value for a particular node that there，is some other value that we are able
    to。choose and as we can see here Monday and，Tuesday are not going to be possible。values
    that we can choose for C they're，not going to be consistent with a node，like B
    for example。because b is equal to tuesday which，means that c cannot be Tuesday
    and。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定节点的值，确实还有其他值可以选择。从这里我们可以看到，星期一和星期二并不是C可以选择的可能值，它们与B这样的节点不一致，因为B等于星期二，这意味着C不能是星期二。
- en: because a is equal to Monday see also，cannot be Monday so using that。information
    by making C are consistent，with a and B we could remove Monday and。Tuesday from
    C's domain and just leave C，with Wednesday for example and if we。continued to
    try and enforce our，consistency we'd see there are some。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为a等于星期一，所以C也不能是星期一。通过保持C与a和B的一致性，我们可以将星期一和星期二从C的范围中移除，只留下例如星期三。如果我们继续强制保持一致性，就会发现有些值可以被选取。
- en: other conclusions we can draw as well we，see that B is only option is Tuesday
    and。C's only option is Wednesday and so if，we want to make Yi are consistent well。II
    can't be Tuesday because that，wouldn't be our consistent with。b & e cant be wednesday
    because that，wouldn't be are consistent with c so we。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出其他结论，我们看到B的唯一选项是星期二，而C的唯一选项是星期三。因此，如果我们希望使Yi保持一致，那么II不能是星期二，因为这与B不一致；E不能是星期三，因为这与C不一致。
- en: can go ahead and say e and just set that，equal to monday for example and then
    we。can begin to do this process again and，again that in order to make d are。consistent
    with b and e then d would，have to be wednesday that's the only。possible option
    and likewise we can make，the same judgments for F and G as well。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们可以直接说e等于星期一，然后我们可以开始再次执行这个过程。为了使d与b和e保持一致，d必须是星期三，这是唯一的选项，同样，我们也可以对F和G做出相同的判断。
- en: and it turns out without having to do，any additional search just by enforcing。our
    consistency we were able to actually，figure out what the assignment of all。the
    variables should be without needing，to backtrack at all and the way we did。that
    is by interleaving this search，process and the inference step by this。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，实际上我们能够在不进行任何额外搜索的情况下，通过强制保持一致性，找出所有变量的分配，而无需回溯。我们这样做的方法是通过交错的搜索过程和推理步骤。
- en: step of trying to enforce our，consistency and the algorithm to do this。is often
    called just the maintaining our，consistency algorithm which just。enforces our
    consistency every time we，make a new assignment of a value to an。existing variable
    so sometimes we can，enforce our consistency using that ac3。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 强制我们**一致性**的步骤，通常称为维护我们一致性的算法，它每次我们向现有变量分配一个新值时，都会强制我们的**一致性**。有时我们可以使用那个ac3来强制我们的**一致性**。
- en: algorithm at the very beginning of the，problem before we even begin searching。in
    order to limit the domain and the，variables in order to make it easier to。search
    but we can also take advantage of，the interleaving of enforcing our。consistency
    with search such that every，time in the search process we make a new。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在问题的开始阶段，即在我们开始搜索之前，就会被调用，以限制变量的域，从而使搜索更容易。我们还可以利用强制我们的**一致性**与搜索的交错，使得在搜索过程中每当我们进行新的分配时。
- en: assignment we go ahead and enforce our，consistency as well to make sure that。we're
    just eliminating possible values，from domains whenever possible and how。do we
    do this well this is really，equivalent to just every time we make a。new assignment
    to a variable X we'll go，ahead and call our ac3 algorithm this。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续强制我们的**一致性**，以确保每当可能时，我们只是从域中消除可能的值。我们是怎么做到的呢？实际上，这相当于每次我们对变量X做出新的分配时，我们都会调用我们的ac3算法。
- en: algorithm that enforces our consistency，on a constraint satisfaction problem
    and。we go ahead and call that starting it，with a Q not of all of the arcs which
    we。did originally but just of all of the，arcs that we want to make are consistent。with
    X this thing that we have just made，an assignment to so all arcs YX where Y。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在约束满足问题上强制我们的**一致性**。我们开始时使用的不是所有的弧，而只是我们希望与我们刚刚分配的X保持一致的所有弧。
- en: is a neighbor of X something that shares，a constraint with X for example and
    by。maintaining our consistency in the，backtracking search process we can。ultimately
    make our search process a，little bit more efficient and so this is。the revised
    version of this backtrack，function same as before the changes here。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: X的邻居是与X共享约束的某个东西，通过在回溯搜索过程中保持我们的**一致性**，我们最终可以使我们的搜索过程更加高效。这是这个回溯函数的修订版，和之前一样，只是这里有所变化。
- en: highlighted in yellow every time we add，a new variable equals value to our，assignment。we'll
    go ahead and run this inference，procedure which might do a number of。different
    things but one thing it could，do is call the maintaining our。consistency algorithm
    to make sure we're，able to enforce our consistency on the。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们向我们的分配中添加一个新的变量等于值时，我们都会运行这个推理过程。这个过程可能会做很多不同的事情，但它可能会调用维护我们一致性的算法，以确保我们能够强制我们的**一致性**。
- en: problem and we might be able to draw new，inferences as a result of that process。get
    new guarantees of this variable，needs to be equal to that value for。example that
    might happen one time it，might happen many times and so long as。those inferences
    are not a failure as，long as they don't lead to a situation。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会引入新的推论，并由此产生新的保证，例如这个变量必须等于那个值。这可能一次发生，也可能发生多次，只要这些推论没有失败，只要它们不导致某种情况。
- en: where there is no possible way to make，forward progress well then we can go。ahead
    and add those inferences there's，new knowledge that new pieces of。knowledge I
    know about what variables，should be assigned to what values I can。add those to
    the assignment in order to，more quickly make forward progress by。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有可能的前进进展的情况下，那么我们可以继续添加那些推理，有新的知识，我知道关于哪些变量应该分配给什么值的新知识，我可以将这些添加到分配中，以便更快地前进。
- en: taking advantage of information that I，can just a deuce information I know。based
    on the rest of the structure of，the constraint satisfaction problem and。the only
    other change I'll need to make，now is if it turns out this value。doesn't work
    well then down here I'll go，ahead and need to remove not only。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我所能获取的信息，我知道的信息是基于约束满足问题的其余结构，唯一需要做的变化是，如果发现这个值效果不好，那么我在这里需要去除的不仅仅是变量。
- en: variable equals value but also any of，those inferences that I made remove that。from
    the assignment as well and so here，then we're often able to solve the。problem
    by backtracking less and we，might originally have needed to just by。taking advantage
    of the fact that every，time we make a new assignment of one。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 变量等于值，但我做出的任何推理也会从分配中去除，因此在这里，我们通常能够通过更少的回溯来解决问题，可能我们最初需要的只是利用每次进行新分配的事实。
- en: variable to one value that might reduce，the domains of other variables as well。and
    we can use that information to begin，to more quickly draw conclusions in。order
    to try and solve the problem more，efficiently as well and it turns out。there are
    other heuristics we can use to，try and improve the efficiency of our。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可能将一个值降低其他变量的域。我们可以利用这些信息开始更快地得出结论，以更高效地解决问题，结果发现我们还有其他启发式方法可以用来提高我们的效率。
- en: search process as well and it really，boils down to a couple of these。functions
    that I've talked about but we，haven't really talked about how they're。working
    and one of them is this function，here select unassigned variable where。we're selecting
    some variable in the，constraint satisfaction problem that has。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索过程也一样，实际上归结为我谈到的几个函数，但我们还没有真正讨论它们是如何工作的，其中一个是这个函数，选择未分配变量，我们在约束满足问题中选择某个变量。
- en: not yet been assigned so far I've sort，of just been selecting variables random。just
    like picking one variable and went，on to find a variable in order to decide。alright
    this is the variable that we're，going to assign next and then going from。there
    but it turns out that by being a，little bit intelligent by following。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只是随机选择变量，就像挑选一个变量，然后决定好，这是我们将要分配的变量，然后从那里出发，但事实证明，通过稍微聪明一点，跟随。
- en: certain heuristics we might be able to，make the search process much more。efficient
    just by choosing very，carefully which variable we should。explore next so some
    of those heuristics，include the，minimum remaining values or MRV。heuristic which
    generally says that if I，have a choice between which variable I。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 某些启发式方法可以通过仔细选择下一个要探索的变量，使搜索过程变得更加高效，其中一些启发式方法包括最小剩余值（MRV）启发式，它通常表示如果我在选择变量时。
- en: should select I should select the，variable with the smallest domain the。variable
    that has the fewest number of，remaining values left with the idea。being if there
    are only two remaining，values left well I may as well like。prune one of them very
    quickly in order，to get to the other because one of those。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该选择具有最小域的变量，也就是剩余值最少的变量，想法是如果只剩下两个值，那我也许应该很快剪掉一个以便得到另一个，因为其中一个。
- en: two has got to be the solution if a，solution does exist，sometimes minimum remaining
    values might。not give a conclusive result if all the，nodes have the same number
    of remaining。values for example and in that case，another heuristic that can be
    helpful to。look at is the degree heuristic the，degree of a node is the number
    of nodes。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在解决方案，两个必须是解决方案，有时最小剩余值可能。不会给出一个明确的结果，例如，当所有节点的剩余值相同，在这种情况下，另一个可以有帮助的启发式方法是度启发式，节点的度是节点的数量。
- en: that are attached to that node the，number of nodes that are constrained by。that
    particular node and if you imagine，which variable should I choose should I。choose
    a variable that has a high degree，that is connected to a lot of different。things
    or a variable with a low degree，that is not connected to a lot of。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到与该节点相连的节点数，如果你想象一下，我应该选择哪个变量，是选择一个连接许多事物的高连接度变量，还是选择一个连接较少事物的低连接度变量。
- en: different things well it can often make，sense to choose the variable that has。the
    highest degree that is connected to，the most other nodes as the thing you。would
    search first why is that the case，well it's because by choosing a variable。with
    a high degree and that is，immediately going to constrain the rest。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 选择与最多其他节点连接的变量通常是有意义的，作为你首先搜索的对象，为什么会这样呢？因为选择一个高连接度的变量将立即限制其他变量的选择。
- en: of the variables more and it's more，likely to be able to eliminate large。sections
    of the state space that you，don't need to search through at all so。what could
    this actually look like let's，go back to this search problem here in。this particular
    case I've made an，assignment here I've made an assignment。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那这实际上可能是什么样子，让我们回到这个搜索问题，在这个特定情况下，我在这里做了一个赋值。
- en: here and the question is what should I，look at next，and according to the minimum
    remaining。values heuristic what I should choose is，the variable that has the fewest。remaining
    possible values and in this，case that's this node here node C that。only has one
    variable left in this，domain which in this case is Wednesday。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是我接下来应该看什么，根据最小剩余值启发式，我应该选择剩余可能值最少的变量，在这种情况下，就是这个节点C，它在这个域中只剩下一个变量，即星期三。
- en: which is a variable read very reasonable，choice of a next assignment to make。because
    I know it's the only option for，example I know that the only possible。option for
    C is Wednesday so I may as，well make that assignment and then。potentially explore
    him the rest of the，space after that but meanwhile at the。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常合理的下一个赋值选择，因为我知道这是唯一的选项，例如我知道C的唯一可能选项是星期三，因此我不妨做这个赋值，然后可能探索其余空间，但与此同时在变量的数量更多的情况下，更有可能消除你根本不需要搜索的大部分状态空间。
- en: very start of the problem when I didn't，have any knowledge of what nodes should。have
    what values yet I still had to pick，what node should be the first one that I。try
    and assign a value to and I，arbitrarily just chose the one in the，more Intel。about
    that we can look at this，particular graph all of them have。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题开始时，我对哪些节点应该拥有哪些值并没有任何知识，但我仍然必须选择第一个我尝试赋值的节点，我任意选择了一个在更多信息之上的节点。
- en: domains of the same size domain of size，3 some minimum reigning values it。doesn't
    really help us there but we，might notice that node e has the highest。degree it
    is connected to the most，things and so perhaps it makes sense to。begin our search
    rather than starting at，node a at the very top start with the。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相同大小域的大小为3的最小剩余值并没有帮助，但我们可能注意到节点E具有最高的连接度，它与最多的事物相连，因此或许从节点E开始搜索比从最顶端的节点A开始更有意义。
- en: node with the highest degree start by，searching from node e because from there。that's
    going to much more easily allow，us to enforce the constraints that are。near by
    eliminating large portions of，the search space that I might not need。to search
    through and in fact by，starting with e we can immediately then。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从具有最高连接度的节点开始，首先从节点E进行搜索，因为从那里更容易施加约束，消除我可能不需要搜索的大部分搜索空间，实际上从E开始，我们可以立即。
- en: assign other variables and following，that we can actually assign the rest of。the
    variables without needing to do any，backtracking at all even if I'm not。using
    this inference procedure just by，starting with a node that has a higher。degree
    that it's going to very quickly，restrict the possible values that other。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实际分配其余的变量，而不需要进行任何回溯，即使我不使用这个推理过程，只需从一个度数较高的节点开始，这将很快限制其他可能值的选择。
- en: nodes can take on so that then is how we，can go about selecting an unassigned。variable
    in a particular order rather，than randomly picking a variable if。we're a little
    bit intelligent about how，we choose it we can make our search。process much much
    more efficient by，making sure we don't have to search。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何选择一个未分配变量的特定顺序，而不是随机选择一个变量。如果我们聪明地选择变量，我们可以通过确保不需要搜索来使搜索过程更高效。
- en: through portions of the search space，that ultimately aren't going to matter。the
    other variable we haven't really，talked about the other function here is。this
    domain values function this domain，values function that takes a variable。and gives
    me back a sequence of all of，the values inside of that variables。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 穿越搜索空间的部分，最终不会影响我们尚未真正讨论的其他变量，这个领域值函数是针对一个变量，返回该变量所有值的序列。
- en: domain the naive way to approach it is，what we did before which is just go in。order
    go Monday then Tuesday then，Wednesday but the problem is that going。in that order
    might not be the most，efficient order to search in that。sometimes it might be
    more efficient to，choose values that are likely to be。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从领域来看，天真的方法是我们之前所做的，按顺序进行，周一、周二再到周三，但问题是，这种顺序可能不是搜索的最有效顺序，有时选择更有可能有效的值会更高效。
- en: solutions first and then go to other，values now how do you assess whether a。value
    is likelier to lead to a solution，or less likely to lead to a solution。well one
    thing you can take a look at is，how many constraints get added how many。things
    get removed from domains as you，make this new assignment of a variable。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案优先，然后再考虑其他值。现在，你如何评估一个值更可能导致解决方案，或不太可能导致解决方案呢？你可以观察添加了多少约束，在你为变量赋予新值时，从领域中去除了多少东西。
- en: to this particular value and the，heuristic we can use here is the least。constraining
    value heuristic which is，the idea that we should return variables。in order based
    on the number of choices，that are ruled out for neighboring。values and I want
    to start with the，least constraining value the。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这个特定值，我们可以使用的启发式方法是**最少约束值启发式**，即我们应该根据相邻值排除的选择数量，以顺序返回变量。
- en: value that rules out the leap fewest，possible options and the idea there is。that
    if all I care about doing is，finding a solution if I start with a。value that rules
    out a lot of other，choices I'm ruling out a lot of。possibilities that maybe is
    going to，make it less likely that this particular。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 价值排除最少可能选项的想法是，如果我关心的仅仅是找到一个解决方案，如果我从一个排除很多其他选择的值开始，我就排除了很多可能性，这可能使得该特定节点能够采取的情况变得更不可能。
- en: choice leads to a solution whereas on，the other hand if I have a variable and。I
    start by choosing a value that doesn't，rule out very much well then I still。have
    a lot of space where there might be，a solution that I could ultimately find。and
    this might seem a little bit，counterintuitive and a little bit at。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 选择会导致一个解决方案，而另一方面，如果我有一个变量，并且我开始选择一个不会排除太多的值，那么我仍然有很大的空间，可能会有一个我最终可以找到的解决方案。
- en: odds with what we were talking about，before where I said when you're picking。a
    variable you should pick the variable，that is going to have the fewest。possible
    values remaining but here I，want to pick the value for the variable。that is the
    least constraining but the，general idea is that when I am picking a。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前所谈论的相悖，我提到当你选择一个变量时，应该选择剩余可能值最少的变量，但在这里，我想选择那个最少约束的变量的值，基本思想是当我在选择一个变量时。
- en: variable I would like to prune large，portions of the search space by just。choosing
    a variable that is going to，allow me to quickly eliminate possible。options and
    whereas here within a，particular variable as I'm considering。values of that variable
    could take on I，would like to just find a solution and。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望通过选择一个变量来修剪搜索空间的大部分，从而快速消除可能的选项，而在考虑该变量可能取值时，我只想找到解决方案。
- en: so what I want to do is ultimately，choose a value that still leaves open。the
    possibility of me finding a solution，to be as likely as possible by not。ruling
    out many options I leave open the，possibility that I can still find a。solution
    without needing to go back，later and backtrack so an example of。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要做的，**最终**是选择一个仍然保留开放可能性的值。以便我找到解决方案的可能性尽可能高，**不**排除许多选项。我保留开放的可能性，仍然可以找到解决方案，而不需要在**后来**回溯，因此一个例子是。
- en: that might be in this particular，situation here if I'm trying to choose a。variable
    for a value for node see here，that C is equal to either Tuesday or。Wednesday we
    know it can't be Monday，because it conflicts with this domain。here where we already
    know that a is，Monday so C must be Tuesday or Wednesday。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我试图为节点C选择一个值，这里C可以是星期二或星期三，我们知道它不能是星期一，因为它与这里的领域发生冲突，我们已经知道A是星期一，所以C必须是星期二或星期三。
- en: and the question is should I try to x'，day first or should I try Wednesday。first
    and if I try to x' day what gets，ruled out well one option gets ruled out。here
    a second option gets rolled out，here and a third option gets rolled out。here so
    choosing Tuesday would rule out，three possible options and what about。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我应该先尝试星期X还是先尝试星期三。如果我尝试星期X，会排除什么呢？这里会排除一个选项，第二个选项会被排除，第三个选项也会被排除。因此选择星期二会排除三个可能的选项，那可能的选项又会如何呢？
- en: choosing Wednesday well choosing，Wednesday would rule out one option here。and
    it would rule out one option there，and so I have two choices，I can choose Tuesday
    that rules out。three options or Wednesday that rules，out two options，and according
    to the least constraining。value heuristic what I should probably，one，that rules
    out the fewest number of。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 选择星期三，这会排除这里的一个选项，同时排除那里一个选项，因此我有两个选择，我可以选择星期二，这会排除三个选项，或者选择星期三，这会排除两个选项。根据最不约束值启发式，我应该选择那个排除最少选项的。
- en: possible options leaving open as many，chances as possible for me to eventually。find
    the solution inside of the state，space and ultimately if you continue。this process
    we will find a solution an，assignment of variables to values that。allows us to
    give each of these exams，each of these classes in exam date that。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 留下尽可能多的机会让我最终在状态空间中找到解决方案，**最终**如果你继续这个过程，我们将找到一个解决方案，一个变量与值的赋值，使我们能够给每一门考试、每一门课程设定考试日期。
- en: doesn't conflict with anyone that，happens to be enrolled in two classes at。the
    same time so the big takeaway now，with all of this is that there are a。number
    of different ways we can，formulate a problem the ways we've。looked at today are
    we can formulate a，problem as a local search problem a。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不与任何同时注册两门课程的人发生冲突，因此现在的主要收获是，我们可以用多种不同的方式来表述一个问题。我们今天看过的方式是，我们可以将问题表述为局部搜索问题。
- en: problem where we're looking at a current，node and moving to a neighbor based
    on。whether that neighbor is better or worse，than the current node that we are。looking
    at we looked at formulating，problems as linear programs we're just。by putting
    things in terms of equations，and constraints were able to solve。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们观察当前节点并根据该邻居是否比我们正在观察的当前节点更好或更糟的情况下，移动到邻居。我们看到了将问题表述为线性程序，通过将事物以方程和约束的形式表达，我们能够解决。
- en: problems a little bit more efficiently，and we saw formulating a problem as a。constraint
    satisfaction problem creating，this graph of all of the constraints。that connect
    to variables that have some。![](img/fd50d22d8798c784a4db25b4815b1d56_33.png)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让问题解决得更高效一点，我们看到将问题表述为约束满足问题，创建一个所有约束的图，这些约束与有某种关系的变量相连。![](img/fd50d22d8798c784a4db25b4815b1d56_33.png)
- en: constraint between them and using that，information to be able to figure out。what
    the solution should be and so the，takeaway of all of this now is that if。we have
    some problem in artificial，intelligence if we would like to use AI。to be able
    to solve them whether that's，trying to figure out where hospitals。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 约束之间，并利用这些信息来确定解决方案应该是什么。因此现在的收获是，如果我们在人工智能中遇到一些问题，如果我们希望使用人工智能来解决它们，不论是试图找出医院的位置。
- en: should be or trying to solve the，Traveling Salesman problem trying to。optimize
    productions and costs and，whatnot or trying to figure out how to。satisfy certain
    constraints whether，that's in a Sudoku puzzle or whether。that's in trying to figure
    out how to，schedule exams for a university or any。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是或者试图解决旅行推销员问题，试图优化生产和成本，以及其他问题，或者试图找出如何满足某些约束，无论是数独难题还是如何安排大学的考试等。
- en: number of a wide variety of types of，problems if we can formulate that。problem
    as one of these sorts of，problems then we can use these known。algorithms these
    algorithms for，enforcing art consistency and。backtracking search these hill climbing，and
    simulated annealing algorithms these。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 各种类型问题的数量，如果我们能够将这个问题表述为这些类型的问题之一，那么我们就可以使用这些已知的算法，这些算法用于强制艺术一致性和回溯搜索，以及这些爬山算法和模拟退火算法。
- en: simplex algorithms and interior point，algorithms that can be used to solve。linear
    programs that we can use those，techniques to begin to solve a whole。wide variety
    of problems all in this，world of optimization inside of。artificial intelligence
    this was an，introduction to artificial intelligence。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯形算法和内点算法可以用来解决线性规划，我们可以利用这些技术开始解决各种各样的问题，这一切都在人工智能的优化领域内，这是一段关于人工智能的介绍。
- en: with Python for today we will see you。![](img/fd50d22d8798c784a4db25b4815b1d56_35.png)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们将使用Python来看看你们好！![](img/fd50d22d8798c784a4db25b4815b1d56_35.png)
