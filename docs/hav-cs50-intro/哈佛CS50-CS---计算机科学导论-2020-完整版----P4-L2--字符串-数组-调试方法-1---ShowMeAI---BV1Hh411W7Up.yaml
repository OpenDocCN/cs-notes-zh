- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P4：L2- 字符串、数组、调试方法 1 - ShowMeAI - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论（2020·完整版） - P4：L2- 字符串、数组、调试方法 1 - ShowMeAI - BV1Hh411W7Up
- en: '![](img/8108029379785de9f1a769f3c0516d9f_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_0.png)'
- en: '![](img/8108029379785de9f1a769f3c0516d9f_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_1.png)'
- en: all right，so this is cs50 and this is week two。![](img/8108029379785de9f1a769f3c0516d9f_3.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里是 CS50，这是第二周。![](img/8108029379785de9f1a769f3c0516d9f_3.png)
- en: where and we're gonna dive in a little，more deeply to see this new language。and
    we're also gonna take a look back at，week so that you can，better understand some
    of the features。of c and some of the，the steps you've been taking to make，your
    code work so we'll。peel back some of the layers of，abstraction from last week
    so that you，better understand really。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地探讨这个新语言，并回顾一下上周的内容，以便你更好地理解 C 语言的一些特性，以及你所采取的一些步骤来让你的代码工作。所以我们将逐层剥离上周的抽象，以便你更好地理解真正的。
- en: what's going on underneath the hood of，the computer so of course。last week we
    began with perhaps the most，canonical of programs in c。the most canonical of programs
    you can，write pretty much in any language which，world。but recall that before we're
    actually，running this program we have to convert。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 了解计算机内部正在发生的事情，所以当然，上周我们以 C 语言中可能最经典的程序开始。你几乎可以用任何语言编写的最经典的程序是 hello world。但请记住，在我们实际上运行这个程序之前，我们必须进行转换。
- en: it into the language that computers，themselves speak which we defined last。week
    is binary zeros and ones，otherwise known as machine language in。in this context
    so we have to go somehow，from this source code。to something more like this machine
    code，the zeros and ones that the computer，actually understands。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 它将源代码转换为计算机自身所理解的语言，上周我们定义为二进制的零和一，亦称为机器语言。因此，我们必须以某种方式从这个源代码转化为更像这样机器代码的形式，也就是计算机实际理解的零和一。
- en: now you may recall too that we，command was called，hello，could we make a program
    called hello and。make was a little fancy，it assumed that if you want to make a，program
    called hello。it would look for a file called hello。c，that just happens automatically
    for you。and the end result of course was an，additional file called hello，current。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们命令叫做 hello，我们能不能创建一个叫 hello 的程序，而 make 则有点高级，它假设如果你想创建一个叫 hello 的程序，它会自动查找一个叫
    hello.c 的文件。这一切都会自动为你完成，最终的结果当然是一个名为 hello 的额外文件。
- en: directory so you could then do dot slash，hello and be on your way。but it turns
    out that make is actually，automating a more，specific set of steps for us that
    we'll。see a little more closely now instead so，on the screen here is exactly the
    same。code that we wrote last week to say，quite simply hello world，hello。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以执行 dot slash hello 然后继续前进。但结果显示，make 实际上是在为我们自动化一组更具体的步骤，我们现在将更仔细地看看。因此，屏幕上显示的正是我们上周写的代码，它简单地说
    hello world，hello。
- en: or make mario or make cash or may credit，any of the problems that you might
    have。tackled more recently，you see some cryptic output on the，messages。but even
    when all is well you see this，white text which is indicative of all，having been
    well。and last week we just kind of ignored，something like，dot slash hello but
    today let's actually。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者制作马里奥，或者制作现金，或者处理最近可能遇到的任何问题，你会看到一些神秘的输出信息。但即使一切正常，你也会看到这段白色文本，表明一切都很好。而上周我们基本上忽略了像
    dot slash hello 这样的内容，但今天我们来实际。
- en: better understand what it is that we've，been turning a blind eye to so that，less
    that you don't。understand the entirety of with respect，to what's going on on your
    screen。so again if i do ls here we'll see not，only hello。c，but also the executable
    program called。hello that i actually created via make，but look at this output
    there's some。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解我们一直视而不见的内容，以便让你了解屏幕上发生的事情。所以再次，如果我在这里执行 ls，我们不仅会看到 hello.c，还会看到我通过 make
    实际创建的可执行程序 hello，但看看这个输出，有一些。
- en: mention of something called clang here，and then there's a lot of other words
    or。cryptic phrases something，in computer speak here that has all of，these hyphens
    in front。of them and it turns out that what make，us doing for us is it's automating。execution
    of a command more specifically，called clang，clang is actually the compiler that
    we，program。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到了一个叫做 clang 的东西，还有很多其他计算机术语，包含了一些前面带有破折号的神秘短语。结果显示，clang 其实是在自动化执行一个命令，更具体地说，是一个叫
    clang 的编译器。
- en: that converts source code to machine，code we've actually been using clang，this
    whole time。but notice that clang requires a bit，more sophistication you have to。understand
    a bit more about what's going，on in order to use it，so let me go ah**d and remove
    the。program called hello i'm going to use，time，i'm going to confirm by hitting
    y and if。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码转换为机器代码，我们实际上一直在使用`clang`。但请注意，`clang`需要更多的专业知识，你必须对发生的事情有更多的了解才能使用它。所以让我去掉名为`hello`的程序，我将使用`time`，通过输入`y`来确认。
- en: i type ls again now hello。c is the only，file that remains，well temporarily let
    me take away the。ability to use make，and let's now use clang directly clang，is
    another program。installed in cs50 ide it's a very，popular compiler that you can
    download。onto your own macs and pcs as well，but to run it is a little different
    i'm。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在再次输入`ls`，你好。`c`是唯一剩下的文件，暂时让我去掉使用`make`的能力，现在我们直接使用`clang`，`clang`是另一个程序。它安装在cs50
    ide中，是一个非常流行的编译器，你也可以下载到自己的Mac和PC上，不过运行它稍微有点不同。
- en: going to go ah**d and say clang，and then the name of the file that i，want to
    compile，hello。c being this one i'm going to go，ahead and hit enter，and now nothing
    happens seemingly but，already。when nothing bad seems to happen that，implicitly
    tends to mean that something。good happened your program，compiled successfully
    but curiously if i，type ls now。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我将去输入`clang`，然后是我想要编译的文件的名称，`hello.c`就是这个文件。接下来我将按回车，现在似乎什么都没有发生，但实际上。当看起来没有发生坏事时，这通常意味着发生了一些好事，你的程序编译成功了，但奇怪的是，如果我现在输入`ls`。
- en: you don't see the program hello you see，this weird file name called，a dot out
    and this is actually a。historical remnant years ago when humans，code，the default
    file name that every program，was given was。that in a moment，but this is kind of
    a stupid name for a，what it does。so it turns out that programs like clang，can
    be configured，at the command line the command line。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有看到程序`hello`，你看到的是这个奇怪的文件名`a.out`，实际上这是一个历史遗留问题，很多年前人们编写代码时，每个程序被赋予的默认文件名是那个，这有点愚蠢，因为它并没有说明其功能。因此，像`clang`这样的程序可以在命令行中进行配置。
- en: again refers to the blinking prompt，where you can type commands，so indeed i'm
    going to go ah**d and。remove this file now rm，space a dot out and then confirm
    with y。and now i'm back to where i began with，just hello。c，and let me go ah**d
    now and do something。a little different i'm going to do clang，dash o hello and
    then，the word hello。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提到闪烁的提示符，在那里你可以输入命令，所以确实我将去删除这个文件，`rm`，空格，点，输出，然后确认输入`y`。现在我回到了最开始的状态，只有`hello.c`，接下来让我去做一些不同的事情，我将输入`clang
    -o hello`，然后是单词`hello`。
- en: c and what i'm doing here，is actually providing what we're going，argument。so
    these commands like make and rm，sometimes can just be run all by，word and hit
    enter。but very often we've seen that they take，inputs in some sense you type，make
    hello you type rm hello。and the second word hello in those cases，is kind of an
    input to the command。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`，我在这里做的是提供我们正在进行的参数。因此这些命令像`make`和`rm`，有时可以直接通过输入单词并按回车来运行。但我们经常看到它们在某种意义上需要输入，你输入`make
    hello`，你输入`rm hello`。在这些情况下，第二个单词`hello`可以算作命令的输入。'
- en: otherwise now known as a command line，argument it's an，input to the command
    so here we have。more command line，arguments we've got the word clang which，is
    the compiler we're about to run。notation for，output so please output the following，word，hello。c，so
    long story short this command now。more verbose though it is，is saying run clang
    output a file called，hello。c。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 否则现在称为命令行参数，它是命令的输入，所以在这里我们有更多的命令行参数，我们有单词`clang`，这是我们即将运行的编译器。输出的符号，请输出以下单词，`hello.c`。所以长话短说，这个命令现在虽然更冗长，但它是在说运行`clang`，输出一个名为`hello.c`的文件。
- en: and take as input sorry run clang，output a file called hello and take as，input
    a file called，hello。c so when i run this command after，hitting enter nothing again
    seems to，happen but if i type ls。i don't see that stupid default file，name of
    a。out。![](img/8108029379785de9f1a769f3c0516d9f_5.png)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其作为输入，抱歉，运行`clang`，输出一个名为`hello`的文件，并将输入文件称为`hello.c`。所以当我运行这个命令后，按下回车，似乎又什么都没有发生，但如果我输入`ls`。我没有看到那个愚蠢的默认文件名`a.out`。![](img/8108029379785de9f1a769f3c0516d9f_5.png)
- en: how，ultimately clang is helping me compile，my code it's kind of automating all
    of，those processes。but recall that that's not the only type，of program we ran
    last week。or wrote last week we rather took code，like this and began to enhance
    it with，hello world。actually involved prompting the user for，input using cs50's
    getstring function，name。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，clang 是如何帮助我编译我的代码的，它在自动化所有这些过程。但请记住，这并不是我们上周运行或编写的唯一类型的程序，我们实际上是像这样写代码，然后用
    hello world 加强它，实际上涉及到使用 cs50 的 getstring 函数来提示用户输入名字。
- en: but recall that we also had to add，cs50。h at the top of the file。![](img/8108029379785de9f1a769f3c0516d9f_7.png)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，我们也必须在文件顶部添加 cs50.h。![](img/8108029379785de9f1a769f3c0516d9f_7.png)
- en: so let me go ah**d and do that let me go，ahead and remove hello。because that's
    now the old version let，here，and go into my hello。c file，include cs50。h now get
    myself a string，called name but we could call it，anything call the function getstring
    and。ask what's。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我继续做吧，**让我去**，把 hello 去掉，因为现在是旧版本，让我们去我的 hello.c 文件，包含 cs50.h，现在给自己一个字符串，叫做
    name，但我们可以叫任何东西，调用函数 getstring，问是什么。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_9.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_9.png)'
- en: your name question mark with a space at，the very end just to create a gap。and
    then down here instead of printing，out hello world always，let me print out hello
    percent s which。is a placeholder recall，and output the person's name so last，week
    the way we compiled this program。was just make hello，no different from now but
    this week，make，only because it's sort of automating。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的名字？在最后加一个空格，只是为了创造一个间隙。然后在这里，不再打印 hello world，让我打印 hello %s，这是一个占位符，回想一下，并输出这个人的名字，所以上周我们编译这个程序的方式就是
    make hello，现在没有区别，但这一周，make 只是因为它有点自动化。
- en: steps for me that i now want to，understand in more detail，i could compile this
    program again with。clang dash o hello，same，idea of passing in three arguments
    dash，o hello and hello。c。but the catch now is that i'm actually，going to see one
    of these red。![](img/8108029379785de9f1a769f3c0516d9f_11.png)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想更详细地理解这些步骤，我可以再次编译这个程序，使用 clang -o hello，传递三个参数的相同想法 -o hello 和 hello.c。但关键是，我实际上会看到这些红色的。![](img/8108029379785de9f1a769f3c0516d9f_11.png)
- en: error messages and let's consider what，this is actually saying there's still，here。but
    notice as always we're going to see，familiar so，undefined reference to get string
    i。don't yet know what an undefined，reference is necessarily，i don't know what
    a linker command is。but i at least recognize there's，something going on with getstring。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息，让我们考虑这实际上在说什么，仍然在这里。但注意，像往常一样，我们会看到熟悉的，因此，未定义的引用到 getstring，我尚未知道未定义的引用是什么，我不知道链接命令是什么，但我至少意识到
    getstring 出现了一些问题。
- en: and there's a reason for this it turns，out that when using a library whether，it's
    cs50s library or。others as well it's sometimes not，file，at the top of your own
    code sometimes，computer。where to find the zeros and ones，function like，getstring
    so the header file like cs50。h。just tells the compiler that the，function exists，but
    there's a second mechanism that up。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这样做是有原因的，事实证明，当使用一个库，无论是 cs50 的库还是其他库，有时并不是在你自己代码的顶部有文件，而是计算机在哪里找到零和一的功能，比如
    getstring，所以像 cs50.h 的头文件。只是告诉编译器这个函数存在，但还有第二种机制。
- en: until now has been automated for us，that tells the computer where to find。the
    actual zeros and ones that，file，so with that said i'm going to need to。actually
    add another command line，argument to this command，and instead of doing clang dash
    o hello。hello。c，i'm going to additionally and admittedly，cryptically do dash。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一直为我们自动化，这告诉计算机在哪里找到实际的零和一的文件，因此，话虽如此，我需要实际添加另一个命令行参数到这个命令中，而不是做 clang
    -o hello hello.c，我还将附加并承认地做 -。
- en: l cs50 at the end of this command which，quite simply refers to，link in the cs50
    library so link is a。![](img/8108029379785de9f1a769f3c0516d9f_13.png)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: l cs50 在这个命令的最后，这很简单，指的是链接 cs50 库，因此链接是一个。![](img/8108029379785de9f1a769f3c0516d9f_13.png)
- en: term of art that we'll see what it means，in more detail in just a moment。but
    this additional final command line，argument tells clang，you already know that
    a function like。getstring exists，dash lcs50 means when compiling hello。c，make
    sure to incorporate all of the。machine code from cs50s library，into your program
    as well in short it's。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一种艺术术语，我们稍后将更详细地看到它的含义。但这个额外的最终命令行参数告诉 clang，你已经知道像 getstring 这样的函数存在，-lcs50
    意味着在编译 hello.c 时，确保将 cs50 库中的所有机器代码也包含到你的程序中，简而言之，它是。
- en: something you have to do when you use，certain libraries，so now when i hit enter
    all seems to be。i type ls，i see hello and voila i can do dot slash，hello type
    in my name david。and voila hello david so why didn't we，do all of this last week
    and frankly。we've made no fundamental progress all，we've done is reveal，what's
    going on underneath the hood but。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用某些库时，你必须做某些事情，所以现在当我按下回车时，一切似乎都很正常。我输入`ls`，看到hello，哇，我可以执行`./hello`，输入我的名字大卫。哇，hello大卫，那么我们为什么不在上周做所有这些，坦白说。我们没有取得任何实质性的进展，所有我们做的只是揭示了底层的运作情况，但。
- en: i'll claim that frankly compiling your，code by typing out all of these。verbose
    command line arguments just gets，tedious quickly and so computer，specifically。what's
    happening，ultimately with make is that all of this，typed，make hello last week
    and henceforth。well，command，some of which we haven't even talked，beginning，i recognize
    hello。c。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我声称坦白地说，输入所有这些冗长的命令行参数来编译你的代码会迅速变得乏味，因此计算机，具体来说，最终通过`make`发生的事情是，所有这些，输入的`make
    hello`上周及以后。好吧，命令，其中一些我们甚至没有提到，最开始，我识别`hello.c`。
- en: here i recognize dash l cs50 here，but notice there's a bunch of other。stuff
    as well not only the dash oh hello，but also dash lm which refers to a math。library
    dash l crypt which refers to a，cryptography or an encryption library。in short
    we the staff have，pre-configured make，to just make sure that when you compile。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我识别`-l cs50`，但请注意还有许多其他东西，不仅是`-o hello`，还有`-lm`，它指的是一个数学库，`-lcrypt`，它指的是一个加密库。简而言之，我们的工作人员已经预配置了`make`，确保当你编译。
- en: your code all of the requisite，available to you。![](img/8108029379785de9f1a769f3c0516d9f_15.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码时，所有必需的库都会可用。![](img/8108029379785de9f1a769f3c0516d9f_15.png)
- en: without having to worry about all of，henceforth，you can certainly compile your
    code in。this way using clang directly，or you can come back full circle to，make
    hello。but there's a reason we run make hello，manually，tends to just get tedious
    quickly and so。indeed what we've done here is，compile our code and compiling means。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无需担心所有后续步骤，你当然可以通过直接使用clang编译你的代码，或者你可以回到`make hello`。但我们手动运行`make hello`是有原因的，这通常会变得乏味，因此。确实我们在这里所做的是，编译我们的代码，而编译意味着。
- en: going from source code to machine code，but today，we reveal that there's a little
    more。indeed going on underneath the hood this，linking that i referred to。and a
    couple of other steps as well so，it turns out when you compile your code。from
    source code to machine code there's，a few more steps，that are ultimately involved
    and when we。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码到机器代码，但今天，我们揭示了在底层有更多的确在发生。确实，链接以及其他几个步骤也在进行，所以，事实证明，当你从源代码编译到机器代码时，实际上还有一些其他步骤最终涉及到，当我们。
- en: say compiling we actually mean these，four steps and we're not going to dwell。on
    these kinds of low level details but，it's perhaps enlightening just to see。a brief
    tour of what's going on when you，start with your source code。and end up trying
    to produce machine，one，that the computer is doing for you when。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说编译时，我们实际上是指这四个步骤，我们不会过多探讨这些低级细节，但看看。当你从源代码开始，最终试图生成机器代码时，了解发生了什么，或许是有启发性的。
- en: you compile your code，so step one takes your own source code，that looks a little
    something like this。and it pre-processes your code top to，bottom left to right，and
    to pre-process your code essentially。means that it looks for any lines that，start
    with a hash symbol，so hash include cs50。h。includes standardio。h and what the，preprocessing
    step does is it's kind of，like a find and replace。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你编译你的代码，第一步是处理你自己的源代码，它看起来大概像这样。然后它从上到下，从左到右预处理你的代码，预处理你的代码本质上意味着它寻找任何以井号开头的行，所以`#include
    cs50.h`。包括`<stdio.h>`，而预处理步骤的作用就像是一种查找和替换。
- en: it notices oh here's a hash include line，let me go ah**d，and copy the contents
    of that file，cs50。h。into your own code similarly when i，encounter hash include，standardio。h
    let me the so-called。preprocessor，open that file standardio。h and copy，paste the
    contents of that file。so that what's in the file now looks，more like this，so this
    is happening automatically you。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它注意到哦，这里有一行`#include`，让我去啊，复制那个文件的内容，`cs50.h`。进入你的代码，类似地，当我遇到`#include <stdio.h>`时，让我这个所谓的预处理器，打开那个文件`<stdio.h>`并复制，粘贴那个文件的内容。所以文件中的内容现在看起来，更像这样，这一切都是自动发生的。
- en: never have to do this manually，step，of these，lines of code that tend to go at
    the top，of your file。does anyone perceive what the，preprocessor is doing for me
    and，and why why do i write code that has。these hash symbols，like uh why do i write
    code that has，and，include standardio。h but this。![](img/8108029379785de9f1a769f3c0516d9f_17.png)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从未需要手动执行这一过程，这些通常放在文件顶部的代码行。有没有人意识到预处理器在为我做什么，以及我为什么写的代码会有这些井号，像呃，为什么我写的代码会有，和，include
    standardio.h，但这个。![](img/8108029379785de9f1a769f3c0516d9f_17.png)
- en: preprocessor apparently is automatically，replacing those lines with the actual。contents
    of those files what are these，things here，uh is it defining all the functions
    for。you using your code otherwise the，computer wouldn't know what to do，exactly
    it's defining all of the。functions in my code so the computer，we ran into that。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器显然是自动执行的，替换那些行，替换为这些文件的实际内容。这些东西是什么呢，呃，它是为你使用的代码定义所有函数，否则计算机就不知道该怎么做，确切地说，它是在我的代码中定义所有函数，所以我们遇到了这个问题。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_19.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_19.png)'
- en: sort of annoying bug last week whereby i，called，i think get positive int and
    recall that。bottom of my，file the compiler was kind of dumb in，that it didn't
    realize that it existed。because it was implemented all the way，at the bottom of
    my file。so to jack's point by putting a mention，of this，function a hint if you
    will at the very。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上周有个令人烦恼的错误，我调用了，我想是get positive int，记得在我文件的底部，编译器有点傻，它没有意识到它存在，因为它是在我文件的底部实现的。所以为了杰克的观点，通过在最上面放置这个函数的提及，如果你愿意的话。
- en: top it's like training the compiler，to know in advance that i don't know how。it's
    implemented yet but i know，getstring is going to exist i don't know，printf。is
    going to exist so these header files，week，essentially contain all of the，prototypes。that
    is all of the hints for all the，functions that exist in the library，from the top，exist。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是在训练编译器，让它提前知道，我不知道它是怎么实现的，但我知道，getstring会存在，我不知道，printf会存在，所以这些头文件，实际上包含了所有的原型，也就是所有函数在库中存在的所有提示。
- en: so the preprocessor just saves us the，trouble of having to copy and paste all。of
    these prototypes if you will all of，these hints，ourselves so what happens after
    that。step there what comes next well there，there might，very well be other contents
    in those，only in there。is the prototype so now compiling，actually has a more precise
    meaning that，we'll define today，this c。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以预处理器只是在省去我们复制粘贴所有这些原型的麻烦，如果你愿意的话，所有这些提示，我们自己完成。那么在那一步之后会发生什么呢？接下来会发生什么呢，可能在那些文件中还有其他内容，仅在这里是原型，所以现在编译实际上有了更准确的定义，我们今天要定义的C。
- en: here，to another type of source code here now，this is probably going to be the
    most。cryptic stuff we ever see and this is，not code you need to understand。but
    what's on the screen here is what's，called assembly code，so long story short there's
    a lot of。specifically，there's a lot of different types of uh，cpus in the world。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种源代码，这可能是我们见过的最难懂的东西，这不是你需要理解的代码，但屏幕上显示的是所谓的汇编代码，长话短说，世界上有很多种不同类型的，呃，CPU。
- en: central processing units the brains of a。![](img/8108029379785de9f1a769f3c0516d9f_21.png)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 中央处理单元是大脑。![](img/8108029379785de9f1a769f3c0516d9f_21.png)
- en: computer and a cpu，understands certain commands and those，commands tend to be
    expressed in this。language called，assembly code now i honestly don't。![](img/8108029379785de9f1a769f3c0516d9f_23.png)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机和CPU理解某些命令，而这些命令往往用这种叫做汇编代码的语言表达，现在我老实说并不。![](img/8108029379785de9f1a769f3c0516d9f_23.png)
- en: really understand most of this myself，it's certainly been a while even since
    i，i highlight。a few operative characters here notice，that there's mention of main。getstring
    and printf so this is sort of，like a lower level，printf。in a different language
    called assembly，so you write the c code，the computer though converts it to a。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己也很难理解大部分内容，确实已经有一段时间了，甚至我强调了几个操作字符，注意到提到了main，getstring和printf，所以这有点像在另一种叫汇编的语言中的低级printf，所以你写C代码，计算机则将其转换为。
- en: more computer friendly。![](img/8108029379785de9f1a769f3c0516d9f_25.png)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更友好的计算机。![](img/8108029379785de9f1a769f3c0516d9f_25.png)
- en: called assembly code and decades ago，humans wrote this stuff humans wrote，assembly
    code。but nowadays we have c and nowadays we，have languages like python more on
    that。in a few weeks that are just more，user-friendly even if it didn't feel，like
    that this past week。assembly code is a little closer to what，the computer itself
    understands。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为汇编代码，几十年前，人类编写了这些东西，人类编写了汇编代码。但如今我们有 C，如今我们还有像 Python 这样的语言，更多的用户友好，尽管在过去的一周里你可能没有感觉到。汇编代码更接近计算机本身所理解的内容。
- en: but there's still another step there's，the step called assembling and again
    all。of this is happening when you simply run，make and in turn this command clang
    to。assemble your code means to take this，assembly code and，and ones，so you write
    the source code the。compiler assembles it into assembly code，then it compiles
    it into assembly code。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一步，那就是组装步骤，再次强调，所有这一切发生在你简单地运行 `make` 时，而这个命令 `clang` 组装你的代码，意味着将这个汇编代码转化为零和一，所以你编写源代码，编译器将其组装成汇编代码，然后将其编译成汇编代码。
- en: then it assembles it into，zeros and ones，but there's actually one final step
    just。because your code that you wrote has，been converted into zeros and ones。it
    still needs to be linked in with the，zeros and ones that cs50 wrote and that。the
    designers of the c，language wrote years ago when，case。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将其组装成零和一，但实际上还有最后一步。因为你编写的代码已经转换成了零和一，但它仍然需要与 `cs50` 编写的零和一以及多年前 C 语言设计者编写的零和一进行链接。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_27.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_27.png)'
- en: and the printf function in their case so，like this，that's not only including
    the prototypes。for functions like getstring and printf，at the very top，these lines
    here in yellow are what are。ultimately converted into，uh zeros and ones we now
    have to combine，ones from，ago。![](img/8108029379785de9f1a769f3c0516d9f_29.png)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们的情况下，`printf` 函数也是如此，就像这样，这不仅包括原型。对于像 `getstring` 和 `printf` 这样的函数，最顶部的这些黄色行就是最终转换成的，呃，零和一，我们现在必须将其组合，从很久以前的，。
- en: and even a file called standardio。c，which the designers of c。wrote years ago
    and technically it might，the hood，but there's really three files that are，program。the
    first i just claimed once it's uh，one it's it's pre-processed and compiled，and
    assembled。it's then in this form of all zeros and，ones somewhere on the cs50 ide
    there's a。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有一个名为 `stdio.c` 的文件，C 的设计者多年前编写的，技术上来说可能在幕后，但实际上有三个文件在运行。第一个我刚刚声明过的，它的确经过预处理、编译和组装。它此时以全零和一的形式存在于
    `cs50 ide` 的某处。
- en: whole bunch of zeros and ones，representing cs50。c，somewhere in cs50 ide there's
    another。file representing the zeros and ones for，standardio。c，so this final fourth
    step aka linking。just takes all of my zeros and ones all，of cs50 zeros and ones
    all of printf。zeros and ones and links them all，together into one，big blob if
    you will that collectively。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一大堆零和一，表示 `cs50.c`，在 `cs50 ide` 的某处还有另一个文件，表示 `stdio.c` 的零和一，所以这个最后的第四步，也就是链接，正好将我所有的零和一、所有的
    `cs50` 的零和一、所有的 `printf` 的零和一全部连接成一个，庞大的整体。
- en: represent your program hello so my god，like that's quite a mouthful。and so many
    steps and none of the steps，have i described，are really germane to you implementing。mario's
    pyramid or，cash or credit because what we've really，been doing over the past week
    is taking。all four of these fairly low level，sophisticated concepts，and if you
    will abstracting them away so。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表示你的程序 `hello`，我的天，这听起来真复杂。有这么多步骤，而我描述的所有步骤，对你实现 `mario` 的金字塔或 `cash` 或 `credit`
    并没有真正的相关性，因为过去一周我们所做的，实际上是将这四个相对低级的复杂概念抽象出来。
- en: that we just refer to this whole process，as compiling so even though yes，four
    steps。what a programmer typically does when，saying compiling，is there just with
    a wave of the hand，details。but it's stan but it is the case that，there's multiple
    steps happening。underneath the hood and this is what，make an intern clang are
    doing for you，automating this process。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称整个过程为编译，所以即使是四个步骤。程序员通常在说编译时，只是轻描淡写地提及细节。但确实存在多个步骤在幕后进行，而这就是，实习生 `clang`
    为你做的，自动化这个过程。
- en: of going from source code to assembly，code to machine code，and then linking
    it all together with。any libraries you might have used so no，longer take for granted
    what's happening。hopefully that offers you a glimpse，a bit more of what's actually
    happening。when you compile your own code，well let me pause there because that's，quite
    a mouthful。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码到汇编代码再到机器代码，然后将其与任何可能使用的库链接在一起，所以不再把发生的事情视为理所当然。希望这能让你更清楚，当你编译自己的代码时，实际上发生了什么。让我在这里停一下，因为这实在太复杂了。
- en: and see if there's any questions on，pre-processing，compiling or assembling，or
    linking aka compiling。and again we won't dwell at this low，level we'll tend to
    now just abstract，that okay。yes there's those steps but what's，really important
    is the whole process，step，at the top。um is that information contained within，the
    ide or，where do we are there files saved。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 看看关于预处理、编译、汇编或链接的任何问题，别名编译。我们不会停留在这个低层次，我们现在会倾向于抽象出来。是的，这些步骤是存在的，但真正重要的是整个过程，顶部的步骤，信息是否包含在
    ide 中，或者我们那些文件存在哪里。
- en: somewhere in that id like where it's，getting all this information from。yeah
    really good question where all，these files coming from so yes when you。are using
    cs50 ide or frankly if you're，using your own mac，or your own pc and you have。pre-installed
    a compiler into your mac，or pc just like we have into cs50 ide。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我想知道的是这些信息来自哪里。是的，真的很好奇这些文件从何而来，所以当你使用 cs50 ide，或者坦率地说，如果你在自己的 Mac 或 PC 上，且已经预装了编译器，就像我们在
    cs50 ide 中一样。
- en: what you get is a whole bunch of dot h，files somewhere，on the computer system
    you might also。have a whole bunch of dot c，files or compiled versions there of。somewhere
    on the system so yes when you，download and install，a compiler you are getting
    all of these。libraries added for you，and we pre-installed an additional，library
    called cs50s library that。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的是一大堆 .h 文件，可能还有一大堆 .c 文件或其编译版本，存放在系统的某个地方。所以是的，当你下载并安装编译器时，你获得了所有这些库，我们预装了一个额外的库，称为
    cs50s 库。
- en: additionally comes with its own dot。![](img/8108029379785de9f1a769f3c0516d9f_31.png)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还带有自己的点。![](img/8108029379785de9f1a769f3c0516d9f_31.png)
- en: h file and its own machine code as well，so all of those files are somewhere
    in。cs50 ide or equivalently in your own mac，or pc if you're working locally。and
    the compiler clang in this case just，knows how to find that，because one of the
    steps involved in。installing your own compiler is making，sure it's configured
    to know。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: h 文件及其自己的机器代码也在，所以所有这些文件都在 cs50 ide 中，或者如果你在本地工作，也在你的 Mac 或 PC 上，而编译器 clang
    则知道如何找到它，因为安装自己编译器的一个步骤是确保它配置为知道。
- en: per sophia's question where all those，files are，uh uh uh basically i'm sorry
    if i'm。![](img/8108029379785de9f1a769f3c0516d9f_33.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于索非亚的问题，这些文件到底在哪里，呃呃呃，抱歉如果我。![](img/8108029379785de9f1a769f3c0516d9f_33.png)
- en: mispronouncing it，basley um sure so uh whenever we're，uh compiling hello for
    example is the。uh compiler also compiling for example，cs50 or does cs50 already
    exist in，machine code somewhere。beneath yeah really good question too so，i was
    kind of skirting this part of。sophia's question because，technically speaking probably
    cs50。c，is not installed on the system and。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 发音错误，基本上，呃，所以每当我们在编译 hello 时，比如说，编译器是否也在编译 cs50，还是 cs50 已经存在于某个机器代码中。是的，这也是一个非常好的问题，所以我有点避开了索非亚问题的这部分，因为从技术上讲，可能
    cs50.c 并没有安装在系统中。
- en: technically standard io。c，is probably not installed in the system。y it just
    doesn't need to be it would be，kind of inefficient that is slow。if every time
    you compiled your own，program you had additionally compiled，and so forth。![](img/8108029379785de9f1a769f3c0516d9f_35.png)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，标准 io.c 可能并没有安装在系统中，y 它其实不需要这样做，如果每次你编译自己的程序时，还需要另外编译，这会显得有点低效。![](img/8108029379785de9f1a769f3c0516d9f_35.png)
- en: so it actually stands to reason that，what computers typically do is they，pre-compile。![](img/8108029379785de9f1a769f3c0516d9f_37.png)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以实际上可以推断出，计算机通常所做的就是预编译。![](img/8108029379785de9f1a769f3c0516d9f_37.png)
- en: all of those library files for you so，that more efficiently they can just be。linked
    in and you don't have to keep。![](img/8108029379785de9f1a769f3c0516d9f_39.png)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库文件对你来说都是可用的，以便更高效地链接，而你不必一直保持。![](img/8108029379785de9f1a769f3c0516d9f_39.png)
- en: pre-processing compiling and assembling，third-party code you only perform those。steps
    on your own code and then link，the case，uh it's all done in advance iris。yeah
    um when we like replace the header，files with prototypes，are we only replacing
    it with the。prototypes that get used or，like are all the prototypes technically。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理、编译和汇编，第三方代码你只对自己的代码执行这些步骤，然后链接，嗯，所有事情都是提前完成的。是的，当我们像替换头文件时，是否只用被使用的原型，或者说所有原型技术上都在呢？
- en: like substitutes yeah so i was kind of，my，dot dot there's a whole lot of other。stuff
    in those files you're getting the，entire contents of those files。even if the only
    thing you need is the。![](img/8108029379785de9f1a769f3c0516d9f_41.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像替代品是的，所以我有点，我，等等，在那些文件里还有很多其他东西，你得到的是这些文件的全部内容，即使你需要的只有这部分。
- en: prototype，but and this is why i alluded to the，fact too that technically there
    probably，would be。so much stuff in it there's probably not。![](img/8108029379785de9f1a769f3c0516d9f_43.png)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 原型，但这就是为什么我提到技术上可能会有那么多东西在里面，可能没有那么多。
- en: just one standardio。h file with，everything in it there's probably some。smaller
    files that get magically。![](img/8108029379785de9f1a769f3c0516d9f_45.png)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个标准的`stdio.h`文件，里面包含所有内容，可能有一些较小的文件神奇地。
- en: included as well，but yes there are as many there are many，more lines of code
    in those files。but that's okay once your computer，your compiler is only going
    to use the。lines that it actually cares about，said，this past week undoubtedly
    was a bit。frustrating in some ways because you，probably ran into problems you
    ran into。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 包括在内，不过是的，确实有很多行代码在那些文件里。但没关系，一旦你的计算机，你的编译器只会使用它实际上关心的行，过去一周无疑在某些方面有点令人沮丧，因为你可能遇到了一些问题。
- en: bugs mistakes in your own code，you probably saw one or more yellow or，struggled
    a little bit。just to get your code to compile and，again that's normal that will
    go away，c。let's say 20 percent of the time i still，have a compilation error let
    alone，logical errors。in my own code so this is just part of，the experience of，writing
    code humans make mistakes in all。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的错误，可能你看到一个或多个黄色提示，或者有点挣扎才能让代码编译通过，再次，这很正常，这种情况会消失。假设我仍然有20%的时间遇到编译错误，更不用说我代码中的逻辑错误了，这只是编写代码过程的一部分，人类在所有方面都会犯错误。
- en: forms of life and that's ever more true，in the context of code，where again per
    our first two weeks。precision is important as is correctness，and it's hard sometimes。to
    achieve both of those goals so let's，consider now，how you might be more empowered
    to debug。your own code that is find，problems in your own code and this word，actually
    has some etymology。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 生命形式，而在代码的背景下，这一点更为真实，正如我们前两周提到的，精确度和正确性都很重要，有时很难同时达到这两个目标。所以现在让我们考虑一下，如何让你更有能力调试自己的代码，也就是发现你自己代码中的问题，而这个词实际上有一些词源。
- en: this isn't necessarily the first bug but，pictured here，uh from the research
    notebook of uh。grace hopper a famous computer scientist，who had discovered that
    there were some。problems with the harvard mark，ii computer a very famous computer，nowadays
    that actually。lives over soon in the new engineering，science center，the computer
    was having problems and。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一定是第一个错误，但在这里的图片，来自著名计算机科学家格蕾丝·霍普的研究笔记，她发现哈佛马克二号计算机有一些问题，这是一台非常著名的计算机，现在它实际上位于新工程科学中心，计算机出现了问题。
- en: sure enough when the engineers took a，look inside of this，big mainframe computer
    there was。actually a bug，pictured here and taped to grace，hopper's notebook so
    this wasn't，bug。but it is a very well known example of，an actual bug in an actual
    computer。nowadays we speak a little more，mistake，in one's program and we did give
    you a，few tools last week。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，当工程师们查看这个大型主机计算机时，里面实际上有一个错误，图片在这里，贴在格蕾丝·霍普的笔记本上，所以这不是个错误。但这是一个众所周知的实际计算机中的错误的例子。如今我们更倾向于称之为程序中的“错误”，我们上周确实给你提供了一些工具。
- en: for troubleshooting bugs help50 allows，you to better understand some of the。cryptic
    error messages and that's just，because the staff wrote this program。that analyzed
    the problem you're having，and we try to translate it to just more，human friendly
    speak。we saw a tool called style 50 which，helps you not with your correctness。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故障排除，`help50`可以帮助你更好地理解一些晦涩的错误信息，这只是因为工作人员编写了这个程序来分析你遇到的问题，我们试图将其翻译为更易于理解的语言。我们看到一个叫做`style50`的工具，它帮助你解决你的正确性问题。
- en: but just with the aesthetics of your，code helping you better indent things。and
    add white space that is blank lines。![](img/8108029379785de9f1a769f3c0516d9f_47.png)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅是通过你的代码的美观，帮助你更好地缩进和添加空白行。![](img/8108029379785de9f1a769f3c0516d9f_47.png)
- en: or space characters so it's a little，more user friendly to the human to read。and
    then check 50 which of course the，staff write so that we can give you。immediate
    feedback on whether or not，your code is correct per，the problem sets or the lab。specification
    but there's some other，tools that you should have in your，today。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或空格字符，这样对于人类来说更易读。然后检查50，当然是工作人员编写的，这样我们可以立即反馈你的代码是否正确，根据问题集或实验室规范，但还有一些其他工具你今天应该具备。
- en: and one frankly is sort of this，universal debugging tool，just called in the
    context of c printf。so printf of course is just this，function that prints stuff
    out onto the。screen but that in and of itself is a，wonderfully powerful tool by
    which you。can chase down problems in your code，and even after we leave c in a
    few weeks。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，这是一种通用的调试工具，叫做c语言中的printf。因此printf当然就是这个函数，它将内容打印到屏幕上，但这本身就是一个强大的工具，通过它你可以追踪代码中的问题，即使在几周后我们离开c语言。
- en: and introduce python in other languages，almost every programming language out。there
    has some form of printf maybe it's，called print maybe it's called。![](img/8108029379785de9f1a769f3c0516d9f_49.png)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并介绍python和其他语言，几乎所有的编程语言都有某种形式的printf，也许它叫print，或许它叫。![](img/8108029379785de9f1a769f3c0516d9f_49.png)
- en: say as it was in scratch but some，ability to display，information or present
    information to a。human so let's try to use this，primitive this notion of printf
    to chase。down a bug in one's code so let me go，ahead and deliberately write。![](img/8108029379785de9f1a769f3c0516d9f_51.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在scratch中一样，但有某种能力来展示信息或向人类呈现信息，所以让我们尝试使用这个原始的printf概念来追踪代码中的错误，让我继续故意编写。![](img/8108029379785de9f1a769f3c0516d9f_51.png)
- en: a buggy program i'm going to even call，the file，buggy0。c and at the top of this
    file i'm。going to go ah**d and include，standardio。h no need for the cs50，library
    for this one。and then i'm going to do int main void，which we saw last week and
    we'll explain，in more detail today。and then i'm going to give myself a，print out，oh
    i don't know like 10 hashes on the。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有问题的程序，我甚至将这个文件命名为buggy0.c，在这个文件的顶部，我将继续包含stdio.h，这个不需要cs50库。然后我将做int main
    void，我们上周见过，并将在今天详细解释。然后我将给自己打印出，哦，我不知道，比如10个哈希在。
- en: screen so i want to print like a，vertical column，kind of like one of those screenshots。from
    super mario brothers not a pyramid，just a single column of hashes。and 10 of them
    so i'm going to do，something like int i equals 0 because i。feel like i learned
    in class that i，generally should start counting from 0。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上我想打印出一个垂直列，像是超级马里奥兄弟中的一个截图，不是金字塔，只是一列哈希，总共10个，因此我将做一些类似于int i等于0，因为我觉得我在课上学到通常应该从0开始计数。
- en: then i'm going to have my condition in，this for loop and i want to do this 10。times
    so i'm going to do it less than or，equal to 10 then i'm going to go ah**d。and
    have my increment，which quite simply can be expressed as i，plus plus and then
    inside this loop。i'm just going to go ah**d and print out，a single hash followed
    by。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将有我的条件在这个for循环中，我想做10次，所以我将其设为小于或等于10，然后我将继续。我的递增，可以简单地表示为i加1，然后在这个循环内部，我将继续打印出一个单一的哈希，后面跟着。
- en: a new line i'm going to save the program，i'm going to compile it with，mean no。you
    don't have to use clang manually in，this way it's a lot simpler，command，buggy。zero
    and make will take care of the，process of invoking，clang for you i'm going to
    go ah**d and。run it seems to be compiling，successfully so no need for help，fact
    if i run。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 新的一行，我将保存程序，编译它，意思是你不必手动使用clang，以这种方式更简单，命令，buggy zero，make会为你处理调用clang的过程，我将继续运行，似乎编译成功，所以不需要帮助，事实上如果我运行。
- en: style 50 on this buggy zero i don't have，any comments yet but at least it looks，with
    that。but let me add that comment and do print，goal，and now let me go ah**d and
    run this dot。slash buggy zero。![](img/8108029379785de9f1a769f3c0516d9f_53.png)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: style 50在这个有问题的buggy zero上，我还没有任何评论，但至少看起来还不错，**就是这样**。但是让我添加那个评论并进行打印，目标，现在让我继续运行这个dot。slash
    buggy zero。![](img/8108029379785de9f1a769f3c0516d9f_53.png)
- en: '*****，*****。![](img/8108029379785de9f1a769f3c0516d9f_55.png)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*****，*****。![](img/8108029379785de9f1a769f3c0516d9f_55.png)'
- en: i think all right so it's a stupid bug，and maybe it's jumped out obviously to。some
    of you but maybe it's a little more，subtle to others of you。but where do you begin
    suppose i were to，run check 50 and check。50 were to say nope you printed out 11，hashes
    instead of 10，but my code looks right to me at least。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我想，好吧，这真是个愚蠢的错误，可能对你们中的一些人来说显而易见，但对其他一些人来说可能更微妙。但你从哪里开始呢？假设我运行 check 50，check
    50 会说不，你打印出了 11 个哈希而不是 10 个，但我觉得我的代码看起来是对的。
- en: at first glance well how can i go about，debugging this or solving this well。again
    printf is your friend，if you want to understand more about，temporarily。print more
    information to the screen not，that we want in the final version not。that your
    tf wants to see，but that you the programmer can，temporarily see so。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我该如何调试或解决这个问题呢。再次强调，printf 是你的朋友，如果你想要了解更多信息，临时打印更多信息到屏幕上，不是我们希望在最终版本中看到的，也不是你的
    tf 想要看到的，但你作为程序员可以暂时看到。
- en: before i print this hash let me print，something a little more pedantic，like
    this i is now percent。know，value of i，at this point before i print that hash，the
    value of i。so i'm using percent i as a placeholder。![](img/8108029379785de9f1a769f3c0516d9f_57.png)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我打印这个哈希之前，让我打印一些更严谨的东西，比如说 i 现在是百分比。知道，在我打印这个哈希之前，i 的值。所以我使用百分比 i 作为占位符。![](img/8108029379785de9f1a769f3c0516d9f_57.png)
- en: i'm plugging in the value of the，variable i，i'm going to save my code now i'm
    going。to recompile it with make buggy zero，and i'm going to rerun it now and let
    me。go ah**d and increase the size of my，output，and i'm going to go ah**d and run
    dot，slash buggy zero。enter okay so now i see not only my，output some，diagnostic
    output if you will some。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在插入变量 i 的值，我现在要保存我的代码，然后用 `make buggy zero` 重新编译它，我现在要重新运行它，让我去**增加我的输出**的大小，然后我将去**运行
    dot，slash buggy zero**。输入好吧，现在我不仅可以看到我的输出，还有一些诊断输出，如果你愿意的话。
- en: debugging output and it's just more，pedantically telling me i，is now zero i
    is now one i is now two。dot dot dot i is now nine，that i，is 10 but i'm not loving
    the fact that，if i started at 0。and printed a hash and i'm hitting 10，and printing
    another hash well obviously。there's my problem so it might not have，been all that
    much more obvious than。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 调试输出更是更加严谨地告诉我，i 现在是零，i 现在是一，i 现在是二。点点点 i 现在是九，i 是十，但我不喜欢的是，如果我从 0 开始，并打印一个哈希，然后我达到
    10，并打印另一个哈希，那么显然这就是我的问题，所以这可能并没有比之前更明显。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_59.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_59.png)'
- en: looking at the code itself，but by using printf you can just be a，on。so if now
    i see okay well if i start at，0 i have to go up to 10。i could change my code to
    do this to be，and go from 1，through 10 but again programmer。convention would be
    to go from 0，up to 10 so i think i'm good now and in，this，make buggy 0。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码本身，但通过使用 printf，你可以更清楚地看到。所以如果现在我看到，好吧，如果我从 0 开始，我必须上升到 10。我可以更改我的代码，使其从
    1 到 10，但再次，程序员的惯例是从 0 到 10，所以我觉得我现在很好，在这个，make buggy 0。
- en: let me go ah**d and，increase the size of the window。![](img/8108029379785de9f1a769f3c0516d9f_61.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我去**增加窗口的大小**。![](img/8108029379785de9f1a769f3c0516d9f_61.png)
- en: again just so i can temporarily see this，and do dot slash buggy，zero okay i
    start now at zero one。![](img/8108029379785de9f1a769f3c0516d9f_63.png)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次只是为了让我暂时看到这一点，执行 dot slash buggy，zero 好吧，我现在从零开始。![](img/8108029379785de9f1a769f3c0516d9f_63.png)
- en: two dot dot dot now i stop at nine and，again，i don't need this in the final
    output。![](img/8108029379785de9f1a769f3c0516d9f_65.png)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点点点，现在我停在九，另外，我不需要这个在最终输出中。![](img/8108029379785de9f1a769f3c0516d9f_65.png)
- en: and i'm going to go ah**d and delete，this now as temporary output。but again
    having those instincts if you，don't quite understand why your code is。compiling
    but not running properly，and you want to better see what the，computer is clearly
    seeing。its mind's eye use printf to just tell，yourself what the value of some
    variable，or variables are。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在要去**删除**这个作为临时输出的内容。但是，如果你对为什么你的代码编译但运行不正常没有完全理解，并且想更好地看到计算机在清晰地看到的内容，使用
    printf 来告诉自己某个变量或变量的值是什么。
- en: anywhere in your code that you want to，see a little more detail。all right let
    me pause for just a moment，to see if there's any questions on this。technique of
    just using printf，to begin to debug your code and to see，the values of variables。no
    all right well let me propose，an even more powerful tool that。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中任何你想要看到更多细节的地方。好吧，让我暂停一下，看看有没有关于这个使用 printf 的技术来开始调试你的代码以及查看变量值的问题。没有，好吧，那让我建议一个更强大的工具。
- en: admittedly takes a little getting used，lessons，uh trust me if you will that
    if you，hour。so this week learning the following tool，you will save yourself。hours
    plural maybe even tens of hours，over the course of the next many weeks。because
    this tool can help you，code so，this tool we're going to add to the list。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这需要一点时间适应，呃，相信我，如果你能做到的话，这周学习这个工具，你会节省自己数小时，可能甚至数十个小时，随着接下来几周的学习，因为这个工具可以帮助你编写代码，所以这个工具我们要加入到列表中。
- en: today is called debug 50。and while this one does end with 50，implying that it's
    a cs50 tool。it's built on top of an industry。![](img/8108029379785de9f1a769f3c0516d9f_67.png)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 今天称之为 debug 50。虽然这个工具的名字以 50 结尾，暗示它是一个 cs50 工具，但它是建立在行业基础之上的。![](img/8108029379785de9f1a769f3c0516d9f_67.png)
- en: standard tool known as gdb，the gnu debugger that's a standard tool。that a lot
    of different computer systems，use to provide you with the ability。to debug your
    code in a more，sophisticated way than just，using printf alone so let's go ah**d
    and。do this let me go back to the buggy，version of this program，which recall had
    me going from 0 through。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个称为 gdb 的标准工具，GNU 调试器，这是一个标准工具，很多不同的计算机系统使用它，提供一种比单纯使用 printf 更复杂的调试代码的能力。所以让我们继续，回到这个程序的有错误版本，记得让我从
    0 开始。
- en: 10 which was too many steps，a moment ago i proposed that we just use，printf
    to see the value of i。![](img/8108029379785de9f1a769f3c0516d9f_69.png)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 10 步骤太多了，刚才我提议我们只用 printf 来查看 i 的值。![](img/8108029379785de9f1a769f3c0516d9f_69.png)
- en: but frankly the bigger our programs get，the more complicated they get。the more
    output they need to have on the，screen it's just going to get。very messy quickly
    if you're printing，out stuff that shouldn't be there right，think back to mario。mario's
    pyramid is this sort of，quickly get，pyramid，if you're co-mingling that pyramid
    with，well。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但坦率地说，我们的程序越大，变得越复杂。它们需要在屏幕上有更多输出，如果你输出了不该出现的内容，情况很快就会变得混乱。想想马里奥。马里奥的金字塔就是这种快速生成的金字塔，如果你把那个金字塔和其他东西混在一起。
- en: so debug 50 and in turn a debugger in，any language is a tool that allows you，to
    run your code。step by step and look inside of，variables，computer，while your program
    is running right now。pretty much every program we run，takes like a split second
    to run that's。way too fast for me the human to wrap my，mind around what's going
    on。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 debug 50 以及任何语言中的调试器都是一种工具，让你可以逐步运行代码并查看变量，计算机在你程序运行时的状态。几乎每个程序运行都需要短短的时间，这对于我这样的人类来说太快，无法理解发生了什么。
- en: step by step a debugger allows you to，run your program but，much more slowly
    step by step so you can。see what's going on，so i'm going to go ah**d now and run，debug
    50，dot slash hello so no sorry。debug 50 dot slash buggy zero，so i write debug
    50 first a space and。then dot slash in the name of the，program that's already
    compiled。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步调试器让你运行程序，但速度慢得多，逐步进行，这样你可以看到发生了什么。所以我现在将运行 debug 50，点斜杠 hello，不，抱歉，debug
    50 点斜杠 buggy zero，所以我先写 debug 50，一个空格，然后点斜杠和程序的名称，这个程序已经编译好了。
- en: that i want to debug so i'm going to go，ahead and hit enter，and notice that
    oh it was smart it。noticed that i changed my code and i did，a moment ago i reverted
    it back to the。buggy version so let me fix this，make buggy zero all right no errors
    now。let me go ah**d and run debug 50 again，and if you haven't noticed this already。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我想调试，所以我会继续按 Enter，注意到哦，它很聪明，注意到我更改了代码，我刚才把它恢复到了有错误的版本，所以让我修复这个，让有错误的版本为零。好吧，现在没有错误。让我再运行
    debug 50，如果你还没有注意到这一点。
- en: sometimes i seem to type crazy fast i'm，not necessarily typing that。fast i'm
    going through my history in，cs50 ide，using your arrow keys up and down you。can
    scroll back in time，for all of the commands you've typed，even days。and this will
    just start to save you，knit up，and now i don't have to bother typing。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我似乎打字速度非常快，但我并不一定在那么快地打字，我正在查看 cs50 ide 中的历史记录，使用你的箭头键上下，你可以回溯所有你输入的命令，甚至是几天前的命令。这将开始节省你大量时间，现在我不需要再烦恼输入整个命令。
- en: this whole command again it's a helpful，way to just save time。i'm going to go
    ah**d now and hit enter，and now notice，this error message i haven't set any。breakpoints
    set at least one break point，by clicking to the left of a line number。and then
    rerun debug 50。well what's going on here well debug 50。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个节省时间的好方法。我现在将继续按 Enter，注意这个错误信息：我还没有设置任何断点，至少设置一个断点，点击行号左侧，然后重新运行 debug
    50。那么这里发生了什么呢？debug 50。
- en: needs me to tell the computer in advance，at what line i want to break。into and
    step through step by step so，i can do that i'm going to go to the。side of the
    file here as it says，and you know what the first interesting。file uh first interesting
    line is this，one here line six，so i clicked in the so-called gutter the。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要提前告诉计算机我想在哪一行断点，以逐步执行，所以我将去文件的侧面，如它所示的那样。第一个有趣的文件，第一个有趣的行就是这里的第六行，所以我在所谓的“水沟”里点击了左侧的第六行，自动在这里放置了一个红点，像个停车标志。
- en: left-hand side of the screen，on line six and that automatically put a，red dot
    there like a stop sign。now one last time i'm going to go ah**d，and run debug 50，now
    notice。this fancy new panel opens up on the，right hand side and it's going to
    look a。little cryptic at first but let's，consider what has changed on the screen。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后一次我将继续并运行调试器，注意，这个新的面板在右侧打开，起初看起来有点神秘，但让我们考虑一下屏幕上发生了什么变化。
- en: notice now that highlighted in this sort，of off-yellow color，is line six and
    that's because what。debug 50 is doing is it's running my，program but it has paused，execution
    on line six so it's done。everything from line one through five，but now it's waiting
    for me on line six。![](img/8108029379785de9f1a769f3c0516d9f_71.png)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注意到突出显示的这个淡黄色，正是第六行。这是因为调试器正在运行我的程序，但在第六行暂停了执行，所以它完成了第一到第五行的所有内容，但现在在第六行等待我。![](img/8108029379785de9f1a769f3c0516d9f_71.png)
- en: and what's interesting over here，is this let me zoom in on this window。over
    here and there's a lot going on，here admittedly，but let's focus for just a moment
    not on。watch expressions，not on call stack but only on local，called，i whose initial
    value is zero and it's。of type int，now this is kind of interesting because，here，i
    can click on this step over line and。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，这让我可以放大这个窗口，虽然这里有很多内容，但让我们暂时关注局部变量`i`，它的初始值是零，类型为`int`。这很有趣，因为我可以点击这个逐步执行的行。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_73.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_73.png)'
- en: start to step，through my code line by line so let me，go ah**d and zoom out。let
    me go ah**d and click step over and，highlighting，it moves down to the next line
    but。notice if i zoom in again up here，the value of i has not changed now let。me
    go ah**d and step over again，and notice the yellow highlighting，doubles back that
    makes sense。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 开始逐行调试我的代码，所以让我继续并放大。让我继续并点击“逐步执行”，突出显示移动到下一行，但如果我再次放大，`i`的值没有改变。现在让我继续并再次执行，注意到黄色突出显示再次返回，这很合理。
- en: because i'm in a loop so it should be，going back and forth back and forth。but
    what next happens in a loop every，time you go back to the beginning of the。loop
    remember that your incrementation，happens like the i plus plus。so watch now closely
    in the top right。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在一个循环中，所以它应该来回反复。但在循环中，每次回到循环的开头时，请记住你的递增是通过`i++`来实现的。所以现在请在右上角仔细观察。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_75.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_75.png)'
- en: hand corner when i click step over now，debugger，has just been changed to one
    so i didn't。have to use printf i didn't have to mess，up the output of my screen。![](img/8108029379785de9f1a769f3c0516d9f_77.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我点击“逐步执行”时，调试器的右下角刚刚更改为一个，所以我不需要使用`printf`，也不必搞乱我屏幕的输出。![](img/8108029379785de9f1a769f3c0516d9f_77.png)
- en: i can literally see in this gui this，hand side，what the value of i is now if
    i just。start clicking a little more quickly，notice that as the loop is executing，again
    and again。the value of i keeps getting updated and，you know what i bet。even though
    we started at 0 if i do this，enough times，i will see that the value is 10 now，bottom。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在这个图形界面的右侧直观地看到`i`的值。如果我开始点击得更快一点，注意到在循环执行时，`i`的值会不断更新。你知道吗，我打赌，即使我们从0开始，如果我多次这样做，我会看到最终值是10。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_79.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_79.png)'
- en: that i saw，so i haven't gotten any new information，here but notice i've gotten。unperturbed
    information i've not messily，and sort of sloppily printed out all of。these printf
    statements on the screen，i'm just kind of watching a little more。methodically
    what's happening to the，state of my variable，over on the the top right there all。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有获得任何新信息，但注意我获得了未受干扰的信息，我没有混乱且马虎地在屏幕上打印所有这些`printf`语句，我只是更有条理地观察我的变量状态，在右上方。
- en: right let me pause here too，to see if there's any questions on what，this debugger
    does。again you compile your code you run，debug 50，on your code but only after
    setting a。so-called break point，where you decide in advance where do you，want
    to pause execution of your code。even though here i did it pretty much at，the beginning
    of my program for bigger。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我在这里暂停一下，看看关于这个调试器有没有问题。再次提醒，你编译代码，运行`debug 50`在你的代码上，但仅在设置一个所谓的断点之后，你提前决定在哪里暂停代码的执行。尽管在这里我几乎是在程序的开头做的，但对于较大的程序，能够在代码的中间暂停是非常方便的。
- en: programs it's going to be super，convenient to be able to pause like，halfway
    through your code。and not have to go through the whole，uh yeah uh about the debugger
    uh-huh。uh what's the difference between step，over and step into and step。out and
    really good question let me come，back to that in just a moment because。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，关于调试器的内容，嗯，`step over`和`step into`、`step out`之间的区别是什么，真是个好问题，让我稍后再回来讨论。
- en: we'll do one other example where step，into and step out actually our germain。but
    before we do that any other，questions about debug 50，before we reveal what step
    into and step。over do for us，as well，all right well let's take peter's，now。and
    get out of the debugger and honestly，i don't see an obvious way to get out of。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做另一个例子，其中`step into`和`step out`实际上很重要。但在此之前，有没有其他关于`debug 50`的问题，在我们揭示`step
    into`和`step over`为我们做了什么之前，好的，那么让我们来看一下彼得的，现在，退出调试器，老实说，我没有看到明显的退出方式。
- en: the debugger at the moment，too pretty much，any time you lose control of a program。because
    the debugger is running and，you've lost，interest in it or maybe last week you。wrote
    a program that has an infinite，going，ctrl c will break out of that program。but
    let's now write quickly another。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时调试器，几乎在你失去程序控制的任何时候。因为调试器正在运行，而你对它失去了兴趣，或者也许上周你写的程序有一个无限循环，按`ctrl c`将中断该程序。但现在我们快速写另一个。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_81.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_81.png)'
- en: program that this time has a second，function and we'll see one。other feature
    of the debugger today i'm，now，called buggy1。c again it's going to be。deliberately
    flawed，but i'm going to first going to go ah**d，and include cs50。h this time。and
    i'm going to include standardio。h，i'm going to do int main void。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序这次有一个第二个函数，我们今天将看到调试器的另一个特性，我现在称之为`buggy1.c`。它将故意有缺陷，但我首先要继续，包含`cs50.h`这次。我还将包含`standardio.h`，我将写`int
    main void`。
- en: and i'm going to go ah**d and do the，i，and i'm going to try to get a negative。int
    by calling a function called。![](img/8108029379785de9f1a769f3c0516d9f_83.png)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续进行，去调用一个名为`getnegativeint`的函数，试图获得一个负整数。![](img/8108029379785de9f1a769f3c0516d9f_83.png)
- en: getnegativeint，and then quite simply i'm going to print，out this value percent
    i。backslash n i semicolon now there's only，one problem，get negative int does not
    exist so like。positive in，this week i'll implement get negative，at first，now get
    negative int as the name implies。though we only spent，brief time on this last
    week recall that。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我会简单地打印这个值，百分号i，反斜杠n分号。现在只有一个问题，`get negative int`并不存在，所以像本周的`positive`一样，我会先实现`get
    negative`。如其名所示，尽管我们上周只花了简短的时间来讨论这一点。
- en: you can specify the output of a function，a custom function that you wrote by。putting
    its so-called return value first，on this line and then you can put the，int。and
    then in parentheses you can put the，input，you can literally write the word void。which
    is a term of art that just means，nothing goes here i'm going to go ah**d。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将你编写的自定义函数的输出，所谓的返回值放在这一行的第一部分来指定函数的输出，然后你可以放`int`，在括号中放输入，你可以字面上写出“void”这个词，这是一个专业术语，意思就是这里什么都不放。我要继续进行。
- en: now and implement get negative int and，frankly i think it's going to be pretty。similar
    to last week but my memory is a，little hazy so again，it will be deliberately flawed
    but i'm。called n，then i'm going to do the following i'm，going to set n。equal to
    get int and i'm just going to，explicitly ask the user for。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实现`get negative int`，坦白说，我认为这会与上周非常相似，但我的记忆有点模糊，所以再次，它会故意有缺陷。首先我将设置`n`等于`get
    int`，然后我会明确地询问用户。
- en: negative integer followed by a space，and then i'm going to keep doing this，while
    n is less than zero。and then at the very last line i'm going，to return，n so again
    i claim that this function。will get me a negative in，from the user and it's going
    to keep。doing it again and again until the user，cooperates however，there is a
    bug and there's a couple of。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 负整数后面跟着一个空格，然后我将继续这样做，直到 n 小于零。然后在最后一行我将返回，n。所以我再次声称这个函数会从用户那里获取一个负数，并且会不断重复，直到用户合作。然而，这里有一个错误，还有几个。
- en: bugs in fact，right now let me go ah**d and make a，deliberate mistake make buggy。![](img/8108029379785de9f1a769f3c0516d9f_85.png)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 错误，事实上，现在让我去**d**并故意犯一个错误，make buggy。![](img/8108029379785de9f1a769f3c0516d9f_85.png)
- en: one enter and i see a whole bunch of，errors here，i could use help 50 on this
    but based on。last week does anyone recall what the，error here might be，get negative。int
    is invalid in c99 so i don't know，function，is something you're going to start
    to。![](img/8108029379785de9f1a769f3c0516d9f_87.png)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个，我看到一堆错误，我可以在这上面使用帮助 50，但基于上周，有人记得这里可能是什么错误吗，get negative。int 在 c99 中无效，所以我不知道，函数，是你将开始看到的东西。![](img/8108029379785de9f1a769f3c0516d9f_87.png)
- en: see more often if you make this mistake，anyone recall what this means and what。the
    fix is without resorting to，help 50 yeah。![](img/8108029379785de9f1a769f3c0516d9f_89.png)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你犯这个错误，你会更频繁地看到，有人记得这意味着什么，以及修复是什么，而不借助于帮助 50 吗？是的。![](img/8108029379785de9f1a769f3c0516d9f_89.png)
- en: jasmine what do you think，uh so basically since you declared it。after you already
    used it in your code，it doesn't know what to read that ads。when it's processing
    it so you have to，move like the first line。above when you actually start the code，perfect
    and this is the。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine，你觉得怎么样，呃，基本上因为你在代码中已经使用了它后才声明它，所以它在处理时不知道该读取什么。因此你需要，把第一行移动到你实际开始代码的上方，完美，这就是那个函数的原型。
- en: only time i will claim that copy paste，is acceptable and，encouraged i'm going
    to copy the very。first line only of that function，and as javascript proposed i'm
    going to。paste it at the very top of the file，thereby giving myself a hint otherwise，known
    as a prototype。so i'll even label it as such to remind，myself why it's there uh。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我唯一会声称复制粘贴是可接受并且鼓励的情况是，我将复制那个函数的第一行，正如 JavaScript 提出的，我将把它粘贴到文件的最上面，从而给自己一个提示，通常称之为原型。所以我甚至会标记它，以提醒自己它在那里是为什么。
- en: prototype of that function and here i'm，gonna go ah**d and get，negative integer
    from user，written。so i now have this prototype at the very，top of my file which
    i think will indeed。get rid of this error let me，do a make buggy one again now
    i see that，it now。dot slash buggy one let me go ah**d and，input a negative integer
    negative one。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我要去**d**并从用户那里获取负整数，写下。所以我现在在文件的最上面有这个原型，我认为这确实会消除这个错误。让我再做一次 make buggy one，现在我看到，点斜杠
    buggy one 让我去**d**并输入一个负整数负一。
- en: hmm negative two negative three i feel，like the function should be happy with。this
    and it's obviously not so there's a，control c，to get out of my program because
    like。otherwise it would run potentially，forever and now i'm going to use debug，50。but
    debug 50 just got really，interesting to peter's question earlier。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，负二负三，我觉得这个函数应该会满意。这显然不是，所以我需要使用控制 C，退出我的程序，因为否则它可能会永远运行，现在我要使用调试 50。但调试 50
    现在对彼得之前的问题变得非常有趣。
- en: because now i have things i can step，main，there's this other function now called。get
    negative in so let's see，what happens now let me go ah**d and set，a breakpoint
    on like the first。interesting line of code line 10 and，it's interesting only in
    the sense that。everything else is kind of boilerplate，at this point you just have
    to do it。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在我有东西可以逐步调试，主函数，还有另一个函数叫做。get negative，所以让我们看看，现在发生什么，让我去**d**并在像第10行的第一个有趣的代码行上设置一个断点，这有趣仅仅是因为，其他的都是模板代码，在这个时候你只需要这样做。
- en: to get your program started i'm going to，now go down here and i'm going to do，debug
    50。dot slash buggy one and in a moment it's，going to open up that sidebar。![](img/8108029379785de9f1a769f3c0516d9f_91.png)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动你的程序，我现在要下去做，调试 50。点斜杠 buggy one，稍后它会打开那个侧边栏。![](img/8108029379785de9f1a769f3c0516d9f_91.png)
- en: and i'm going to focus now not only on，local variables，like i did before notice
    that i is again。equal to zero here by default，but i'm also going to reveal this
    mo，option here call stack。so call stack is a fancy way of，referring to，all of
    the functions that your program。at this point in time，has executed and not yet
    returned from，so right now there's only one thing on。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将不仅关注局部变量，就像之前一样，注意到i在这里再次默认为零，但我也会显示这个mo选项，这里是调用栈。因此，调用栈是一个华丽的方式，指的是你程序在这一时刻执行而尚未返回的所有函数，所以现在只有一件事在。
- en: the call stack because the only function，that is currently。![](img/8108029379785de9f1a769f3c0516d9f_93.png)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调用栈，因为当前唯一的函数是。![](img/8108029379785de9f1a769f3c0516d9f_93.png)
- en: executing is of course main because why，i set a break point at line 10 which
    is。by definition inside of main，like，lines 10 and 11 frankly they look pretty。correct
    right it's hard at this point to，have screwed up lines 10 and 11。except syntactically
    because i'm getting，a negative inch i'm storing it in i。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行当然是主要的，因为我在第10行设置了一个断点，这显然是在main内部。就像第10行和第11行，坦率地说，它们看起来相当正确，对吧？在这一点上，很难搞砸第10行和第11行，除了语法方面，因为我得到了一个负的整数，我把它存储在i中。
- en: and then i'm printing out the value of i，on those two lines，but what if instead
    i'm curious that，bug。logically it's got to be in there，wrote，notice this time
    instead of clicking，step over。let me go ah**d and click on step into，which is
    one of the buttons peter。alluded to and when i click step，rabbit hole，and debug
    50 jumps into the function。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我在这两行上打印出i的值，但如果相反，我对那个bug感到好奇。从逻辑上说，它肯定在里面，写道，注意这次而不是点击步过。让我去啊**d并点击进入，这也是彼得提到的按钮之一。当我点击步骤，兔子洞，调试50跳入了函数。
- en: get negative ant and it focuses on the，first interesting line of code so。do
    in and of itself really isn't that，interesting n isn't that interesting，even yet。the
    first juicy line of code seems to be，line 19 and that's why the debugger has。jumped
    to that line now，n equals getint feels pretty。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 获取负整数，它关注第一行有趣的代码。因此，做本身并没有那么有趣，n 也没那么有趣，甚至到现在。第一行有趣的代码似乎是第19行，这就是为什么调试器跳到了那一行，现在n等于getint，感觉相当。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_95.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_95.png)'
- en: correct it's hard to misuse getint but，notice now on the right hand side，now
    see，negative ant。![](img/8108029379785de9f1a769f3c0516d9f_97.png)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地说，错误地使用getint是很难的，但现在注意到右侧，看到，负整数。![](img/8108029379785de9f1a769f3c0516d9f_97.png)
- en: and a stack it's like a stack of trays，in a cafeteria the first tray at the，bottom
    is like main。the second tray on the stack in the，cafeteria is now，get negative
    int and what's cool about。this is that notice that，right now i can see my local
    variables n。and that's indeed the variable i used so，i no longer see i，i see n
    because i'm into the get。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 栈就像自助餐厅的托盘堆，最底层的第一个托盘就像main。自助餐厅的堆中第二个托盘现在是get负整数，而这很酷的是，注意到现在我可以看到我的局部变量n。这确实是我使用的变量，因此我不再看到i，而是看到n，因为我进入了get。
- en: negative int function，again，and again after typing in a number let，me type in
    negative one here。now notice on the top right of the，n，equals negative one i'm
    going to now go，ahead and click step。over and i think i'm going to end up in，line
    22。if the human has typed in a negative。integer like negative 1，obviously that's
    negative let's proceed，to line 22，over。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 负整数函数，一次又一次，在输入一个数字后，让我输入负一。现在注意到右上角的n等于负一，我现在要继续点击步过，我想我会停在第22行。如果人类输入了一个负整数，比如负一，显然这是负数，让我们继续到第22行，步过。
- en: it actually seems to be going back，to the do loop again and again and again，integers。so
    my logic then should be well okay if，n is negative one，but my loop is still running
    like what。should your logical takeaway here be，if n is negative one and that is
    by。definition a negative integer，could be your，diagnostic conclusion if the debugger
    is。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎确实不断回到do循环，整数。因此，我的逻辑应该是，如果n是负一，但我的循环仍然在运行，那么你逻辑上的结论应该是什么呢？如果n是负一，而这在定义上是负整数，这可能是你的诊断结论，如果调试器。
- en: essentially revealing this hint to you，n is negative one but the loop is still，going
    omar。um either the condition is wrong maybe，some sort of boolean logic。could be
    flawed perfect so obviously，either the condition is wrong or there's。something
    wrong with my boolean logic，and boolean logic just refers to true or，false so
    somewhere。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这向你透露了这个提示，n是负一，但循环仍在进行，奥马尔。嗯，条件可能是错误的，也许某种布尔逻辑有缺陷。显然，要么条件错误，要么我的布尔逻辑有问题，而布尔逻辑只是指真或假，所以在某处。
- en: i'm saying true instead of false or i'm，saying false instead of true。and frankly
    the only place where i have，again and again，must logically be on line 21。so even
    if。you're not quite sure how to fix it yet，just by deduction you should realize。that
    okay negative 1 is what's in the，variable but that's not good enough the。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我说的是true而不是false，或者我说的是false而不是true。坦率地说，唯一必须在21行的地方，我一再强调。所以即使你还不太确定怎么修复它，仅仅通过推理你应该意识到，负1在变量中，但这还不够。
- en: loop is still going i must have screwed，up the loop and indeed。let me just now
    call it out line 21 is，indeed the source of the bug。so we've isolated it out of
    23 lines，we've at least found the one line where，i know the。the solution has to
    be what's the，solution how do i fix the logic now。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 循环仍然在继续，我一定是搞砸了循环，确实让我现在指出，第21行确实是bug的源头。因此我们已经将其孤立出来，在23行中，我们至少找到了我知道的那一行。解决方案是什么，如何修复逻辑现在。
- en: thanks to the debugger having sort of，led me，down this road how do i fix，line
    21 here what's the fix。would you propose yeah jacob，you would have to change it
    from while n，than zero，i want to say n。greater than zero and i think slight，clarification
    i think i want to include。0 here because 0 is not negative and if，i want a negative
    n，i think what i'm probably going to want。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了调试器的引导，我来到了这条路，我该如何修复，第二十一行呢？你会提议的修复是什么？是的，雅各布，你需要将它从“当n小于零”改为“当n大于零”，我想稍微澄清一下，我想在这里包括0，因为0不是负数，如果，我想要一个负的n，我认为我可能想说的是。
- en: to say is while n is greater than or，equal to 0，keep doing the loop so i very。![](img/8108029379785de9f1a769f3c0516d9f_99.png)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当n大于或等于0时，继续执行循环，因此我很。![](img/8108029379785de9f1a769f3c0516d9f_99.png)
- en: understandably sort of just inverted the，logic no big deal i'm thinking negatives。and
    i did less than but，the fix is easy the point is the，debugger led you to this
    point now those。of you who have programmed before，probably saw the bug jumping
    out at you，before。probably would sometime would have，figured out what the bug
    was because out。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以理解的是，我只是颠倒了逻辑，没什么大不了，我在考虑负数，而我用了小于，但，修复很简单，重点是调试器让你到了这一点。现在那些之前编程的人，可能在你面前看到了bug，可能有时候会，搞清楚bug是什么。
- en: of 23 lines it's got to be，one of those but as our programs get，more sophisticated
    and。we start writing more lines of code，debug 50，and debuggers in general will
    be your。friend and i realize that，this is easier said than done because at。first
    when using a debugger you're going，to feel like ah this is just i'm just，going
    to use printf。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在23行的代码中，这一定是其中之一，但随着我们的程序变得，越来越复杂，我们开始编写更多行代码，调试50，以及调试器通常会是你的。朋友，我意识到这说起来容易，但实际上当你第一次使用调试器时，你会觉得啊，我只是，想用printf。
- en: i'm just going to sort of fight through，curve，you will gain back that time and
    more。by just using a debugger as your first，instinct when chasing down。problems
    like this alright so that's it，kit，in addition to printf but debug 50 is。hands
    down the more powerful of the two，now some of you have wondered over the，this
    little。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我会努力克服这个困难，通过使用调试器作为你的第一反应，追踪类似问题，你会获得那段时间的回报以及更多。因此，这就是，kit，除了printf之外，调试50无疑是两者中更强大的工具。现在你们中的一些人可能好奇这只。
- en: rubber duck here and there actually is a，reason for this too and there's one。final
    debugging technique that in，all seriousness we'll introduce you。today too known
    as rubber duck debugging，and you can google this there's a whole。wikipedia article
    about it，and this is kind of a thing in computer。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 橡皮鸭的原因，这也有原因，还有一个最后的调试技术，严肃地说，我们今天会介绍给你，也被称为橡皮鸭调试，你可以去谷歌搜索，这里有整篇的维基百科文章，这是计算机领域的一种现象。
- en: science circles for computer scientists，on their desk，and the point here is
    that sometimes。when trying to understand，what is wrong in your code it helps to，world。we
    would just talk to our our colleague，or our partner on some project。and just in
    hearing yourself vocalize，what it is your code，is supposed to do very often that。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 科学圈内的计算机科学家，他们的桌上，关键是有时在试图理解，代码中出了什么问题时，交流是有帮助的。我们会和我们的同事，或我们项目上的合作伙伴交谈。仅仅听到自己表达出代码应该做什么，往往能带来很大帮助。
- en: proverbial light bulb goes off and，i got it，just because you heard yourself
    speaking。illogically when you intended something，actual logical，colleagues or。partners
    or friends with whom we're，working on a project with and we don't。often have family
    members or friends who，want to hear about our code。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的“灵光乍现”，我明白了，仅仅因为你听到自己说话。逻辑不通时，你本来想表达一些，实际的逻辑，和我们正在合作的同事或。伙伴，或朋友，我们并不。常有家人或朋友想听我们讲代码。
- en: of all things and so a wonderful proxy，for that conversant，partner would be
    literally a rubber duck。and so here in healthier times we would，be giving all
    of you rubber ducks uh。here on stage we brought a larger one，for us all to share，if
    you've noticed in some of the wide。shots on camera there's a duck who's，been watching
    this whole time so that。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事情中，一个绝妙的代理，实际上可以是一个橡皮鸭。因此在更健康的时代，我们会，给你们每人一只橡皮鸭。我们在舞台上带来了一个大号的，供大家共享，如果你注意到在一些广角。镜头中，有一只鸭子一直在看着这一切。
- en: anytime i screw up i literally have，someone i can sort of，talk to if non-verbally
    in this case but。we can't emphasize enough that in，addition to printf in addition
    to the。more sophisticated debug 50 talking，through your problems with code。is
    a wonderfully valuable thing and if，your friends or family are willing to，writing。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我出错时，我实际上有一个人可以，和我对话，虽然在这种情况下是非语言的。但我们不能强调，在printf的基础上，以及。更复杂的调试50，与你的代码问题进行讨论。是非常有价值的事情，如果，你的朋友或家人愿意，写下来。
- en: and some bug you're trying to solve，great but in the absence of that talk to。a
    stuffed animal in your room，talk to an actual rubber duck if you，it's just a wonderful。compelling
    habit to get into because，just in hearing yourself vocalize what，you think is
    logical。at you，instead all right so with that said，that's been a lot let's go
    ah**d here。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在解决某个bug，太好了，但如果没有，就和你房间里的。毛绒玩具谈谈，和一只真正的橡皮鸭谈谈，这真是一个美妙的。习惯，因为，听到自己表达出，认为合理的想法。好吧，那么，话说到这里，已经说了很多，让我们继续。
- en: and take a five minute break give，everyone a bit of a breather and when we。come
    back we'll take a look now at some，of the more powerful features of c。now that
    we can trust that we can solve，any problems with all of these new tools。all right
    we are back so let's take a，look underneath the，hood so to speak of a computer
    because。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后休息五分钟，让每个人都喘口气，当我们。回来时，我们将看看现在的一些，更强大的C语言特性。现在我们可以相信，我们可以解决，所有这些新工具的问题。好的，我们回来了，让我们来看看，计算机底层的，机制。
- en: as fancy as these devices are and as，powerful as they seem，they're relatively
    simple in their，do。and let's reveal as much by way of last，c，supports different
    data types so we saw，to recap。we had all of these well it turns out，that each
    of these data types。is defined on a typical computer system，is taking up a fixed
    amount。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备再复杂，它们似乎再强大，实际上它们在其。工作上是相对简单的。让我们通过最后一部分揭示尽可能多的，C语言支持不同的数据类型，回顾一下。我们发现，结果是，这些数据类型。被定义在典型计算机系统上，占据固定的量。
- en: of space and it depends on the computer，whether it's mac or pc or old or new。just
    how much space is used typically by，these data types but on cs50 ide。the sizes
    of all of these types are as，follows a bull，true or false uses just one byte now。that's
    actually a little wasteful，because one byte is eight bits and。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 空间，这取决于计算机，是否是Mac或PC，旧或新。通常这些数据类型使用的空间，但在CS50 IDE中。所有这些类型的大小如下，布尔值，真或假只需一个字节。现在，这实际上有点浪费，因为一个字节是八位。
- en: gosh like for a bool you should only，need one bit you can't work at the，single
    bit level。easily in c and so we just typically，spend one whole bite on a bull。char
    is going to be one bite as well and，that might sound familiar because last。week
    when we talked about ascii，we proposed that the total number of。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，对于布尔值你只需要，一位，不能轻松在C语言中以单个位级进行操作。因此，我们通常，花费一个完整的字节来表示布尔值。字符也是一个字节，这听起来可能熟悉，因为上周我们谈到ascii时，提出了总数。
- en: possible characters you can represent，with a char was 256，because of eight bits
    and two to the。eighth power so one，no matter what，then there were all of these
    other data。types there was float which is a real，number with a decimal point that
    happens，to use four bytes。a double is also a real number with a，decimal point
    but it uses eight bytes。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的字符可以表示，字符是256，因为八位和二的。八次方，所以一个，不管怎样，还有其他的数据。类型，浮点数是一个带有小数点的实数，使用四个字节。双精度数也是一个带小数点的实数，但它使用八个字节。
- en: which gives you even more precision you，can have more significant digits，we've
    used a bunch。those are four bytes typically a long is，twice as big and that just
    allows you to。represent an even bigger number and some，of you might have done
    that exactly。on credit when storing a whole credit，card number strings for now。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这给你提供了更高的精度，你可以有更多的有效数字，我们使用了一些。通常来说，四个字节的长整型是双倍的，这就允许你表示更大的数字，你们中的一些人可能已经在信用卡存储整个信用卡号码时做到了这一点。
- en: are a variable number of bytes it could，be a short string of text a long string。of
    text a whole paragraph，so that's going to vary so we'll come，back to this notion
    of string。next time but today focus on just these，primitive types if you will。and
    here is a picture of what is inside，of your computer so this is a piece of。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 字节的数量是可变的，可以是短字符串、长字符串，或者一整段文本，因此这一点会有所不同，稍后我们将回到字符串的概念上，但今天我们关注的是这些原始类型，这里是你计算机内部的一张图片，所以这是一块。
- en: '![](img/8108029379785de9f1a769f3c0516d9f_101.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8108029379785de9f1a769f3c0516d9f_101.png)'
- en: memory or ram random access memory and，it might be a little smaller it might
    be。a little bigger depending on whether，like，are stored，while they're running
    and it's where。files are stored when they are open，so typically if you save install，programs
    or save files。those are saved on what's generally，called your hard drive or hard
    disk or。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 内存或RAM（随机访问存储器），它可能会稍微小一点，也可能会稍微大一点，这取决于正在运行的内容，以及文件在打开时存储的位置，因此通常情况下，如果你保存安装程序或保存文件，这些文件会保存在通常称为硬盘或硬盘驱动器的地方。
- en: solid state disk or cd or some other，physical medium and that the upside of，electricity。to
    store your data long term ram is，different it's volatile so to speak。but it's
    much faster than a hard disk or，a solid state disk even it's much faster。because
    it's purely electronic and，indeed there are no moving parts。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 固态硬盘或CD或其他某种物理介质，而电力的好处在于能够长期存储数据，而RAM是不同的，可以说是易失性的，但它比硬盘或固态硬盘快得多，甚至比它们快得多，因为它是纯电子的，确实没有任何活动部件。
- en: it's purely electronic as pictured here，and so with ram，you have the ability
    to open files and。run programs more quickly because when，you double-click a program
    to run it。or you open a file in order to view or，edit it it's stored temporarily。in
    ram and long story short if your，battery laptops，if your laptop battery has ever
    died or。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它是纯电子的，如这里所示，因此通过RAM，你可以更快地打开文件和运行程序，因为当你双击一个程序运行时，或者打开一个文件以查看或编辑时，它会临时存储在RAM中。长话短说，如果你的笔记本电脑电池，或者你的笔记本电脑电池曾经死过。
- en: phone dies，the reason that you and i tend to lose，data the paragraph that you
    just wrote。in the essay that you hadn't yet saved，is because ram memory is volatile。that
    is it requires electricity to，continue powering it，focus on。ram not so much long-term
    disk space yet，because when you're running a program in。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 手机死机的原因是，你我通常会丢失数据，刚刚写的那段文字，尤其是你尚未保存的论文，因为RAM内存是易失性的，也就是说它需要电力来继续供电，专注于RAM，而不是那么关注长期磁盘空间，因为当你在运行一个程序时。
- en: c it is indeed by definition，running in your computer's memory but。the funny
    thing about something as，simple as this picture，is that each of these black rectangles。is
    kind of a chip and in those chips are，stored all of the zeros and ones the，week
    zero。so let's focus it on and just zoom in on，just one of these chips。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实按定义在你计算机的内存中运行，但有趣的是，像这样简单的图片，每个黑色矩形实际上是一个芯片，在这些芯片中存储着所有的零和一，周围是零。因此，让我们专注于并放大其中一个芯片。
- en: now it stands to reason that i don't，know how big this this stick of ram is，maybe
    it's one gigabyte。a billion bytes maybe it's four，bigger，physically，by this hardware
    so if we zoom in。further let me propose that all right i，don't know how many bytes
    are here but。if there's some number of bytes whether，or more，it stands to reason
    that we could just。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以推断，我不知道这根RAM棒的大小，可能是1GB，一亿字节，可能是4GB，物理上更大，由这硬件决定，所以如果我们再进一步放大，让我假设，我不知道这里有多少字节，但如果有一些字节，无论是多还是少，可以推断出我们可以简单地。
- en: number all of these bytes we could sort，of think of this physical。device this
    memory as just being a grid，top to bottom left to right and each of。the squ*res
    i've just overlaid on this，physical device，might represent an individual bite
    and。again in reality maybe there's more of，them maybe there's fewer of them but
    it，there are。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些字节编号，我们可以把这个物理设备，这个内存视为一个从上到下、从左到右的网格，每一个我在这个物理设备上叠加的方格，可能代表一个独立的字节。再次说明，实际上可能有更多，或者更少，但确实有。
- en: we can think of each of these as having，a location like this is the first bite。second
    bite third bite and so forth，well what does it mean then for a char，to take up
    one byte。that means that if your computer's，memory is running a program maybe
    that。you wrote or i wrote that's using a char，variable somewhere in it the char
    you're。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把每个字节想象成一个位置，就像这是第一口，第二口，第三口，等等。那么，一个字符占用一个字节是什么意思呢？这意味着如果你的计算机内存正在运行一个程序，可能是你写的或我写的，它在某个地方使用了一个字符变量。
- en: storing in that variable may very well，be stored in the top left-hand corner。physically
    of this piece of ram maybe，it's there maybe it's elsewhere but it's。just one physical
    squ*re，if you're storing something like an int，which takes up four bytes well
    that。frankly might take up，all four squ*res along the top there or，somewhere else
    if you're using a long。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在那个变量中的值可能会存储在这块 RAM 的左上角，可能就在那，也可能在别处，但这只是一个物理的方格。如果你存储的是像 int 这样占用四个字节的东西，老实说，它可能会占用顶部的所有四个方格，或者在别处，如果你使用的是长整型。
- en: that's going to take up twice as much，space so representing an even bigger。number
    in your computer's memory，is going to require that you use all of，the zeros and
    ones。comprising these eight bytes instead，but let's now move away from physical。hardware
    let's abstract it away if you，memory，as just this grid and technically it's。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将占用两倍的空间，因此在计算机内存中表示一个更大的数字将需要使用构成这八个字节的所有零和一。不过现在让我们远离物理硬件，抽象一下，如果你把内存看作一个网格，从技术上讲，它就是这样的。
- en: not a two-dimensional structure i could，just as easily draw all of these bytes。from
    left to right i could just fit，fewer of them on the screen so we'll。take the physical
    metaphor a bit further，and just think of our computer's memory，those bytes。are
    each eight bits those bits are just，is zoom，in metaphorically on our computer's。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个二维结构，我可以同样容易地从左到右绘制所有这些字节。我可能在屏幕上只能放下更少的字节，因此我们将物理隐喻进一步拓展，想象我们计算机的内存，这些字节每个都是八位，这些位在隐喻上只是聚焦于我们计算机的。
- en: memory to start thinking about，where things are going to end up in，memory when
    you double click on a。program on your mac or pc or，in cs50 ide when you do dot
    slash hello。or dot slash buggy zero or buggy one，it's these bytes in your computer's。memory
    that are filled with all of your，variables values，so let's consider an example
    here。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内存开始考虑，当你双击 Mac 或 PC 上的程序，或者在 CS50 IDE 中执行 `./hello` 或 `./buggy0` 或 `buggy1`
    时，所有变量的值都会填满你计算机内存中的这些字节。因此，让我们在这里考虑一个例子。
- en: suppose i had written some code，that involved declaring three scores。maybe it's
    a class that's got like，three tests and you want to average the。use uh the student's
    score。![](img/8108029379785de9f1a769f3c0516d9f_103.png)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我写了一些代码，涉及声明三个分数，也许这是一个类，有三次测试，你想要计算学生的平均分数。![](img/8108029379785de9f1a769f3c0516d9f_103.png)
- en: acro the student's grade across all，three of those tests well let's go ah**d，exactly
    this。![](img/8108029379785de9f1a769f3c0516d9f_105.png)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 跨越这三个测试的学生成绩，让我们去**实现**这个。![](img/8108029379785de9f1a769f3c0516d9f_105.png)
- en: in cs50 ide i'm going to create a，program called scores。c，and in scores。c i'm
    going to go ah**d。i'm standardio。h to then do my int main，void as usual and then
    inside of here。i'm going to keep it very simple i'm，going to give myself one int。called
    score one and just to be a little，72，like last week i'm going to give myself。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CS50 IDE 中，我将创建一个名为 scores.c 的程序，在 scores.c 中，我将包含**stdio.h**，然后像往常一样编写我的
    `int main(void)`，然后在这里我将保持简单，给自己一个名为 score 的整型变量，值为 72，和上周一样。
- en: a second score and set it equal to 73，and then a third score call whose value，is
    going to be 33。and then let me go ah**d and print out，the average，of those three
    values by plugging in a。placeholder for a floating point value，right if you do
    if you add three，integers together。and divide them by three i may very well，get
    a fraction or a real number with a，percent f。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 设定第二个分数为 73，然后设定第三个分数为 33。然后让我去**打印**这三个值的平均值，通过插入一个占位符来表示浮点值。如果你将三个整数相加，然后除以三，我可能会得到一个分数或一个带有百分比的实数。
- en: instead of percent i because i don't，want to truncate someone's grade。otherwise
    if they have like a 99。9，they're not being rounded up to 100。they're going to
    get the 99 because of，truncation as we discussed last week。so how do i do now
    the math of an，average well it's pretty straightforward，score 1 plus score 2，math。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是percent i，因为我不想截断某人的成绩。否则如果他们有像99.9，他们不会被四舍五入到100，他们会得到99，因为截断，正如我们上周讨论的。那么我现在怎么做平均值的数学呢？其实很简单，得分1加得分2，数学。
- en: that file，let me do make scores at the bottom，again we're not going to use clang，manually
    no need to。because it's a lot easier to run make，but i did mess up here，argument
    has。type in so i don't quite understand that，but it's drawing my attention to
    the，percent f。and the fact that my math looks like，this，printf，is going to help
    me here because i'm the。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再次在底部做make scores，我们不会手动使用clang，没有必要。因为运行make要简单得多，但我在这里搞错了，参数类型不对，我不太明白，但是它引起了我对percent
    f的注意。并且我的数学看起来像这样，printf在这里会帮到我，因为我是。
- en: bug is within the printf line，i don't think that debug 50 is going to。really
    help me here because i already，know what line of，code the bug is in this feels
    like an。opportunity to like talk to the，object，or we can perhaps think about what，errors
    we ran into even。last week uh arpan，what do you think，i think it's because all
    right it's。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 错误出在printf行上，我认为调试50在这里不会真的帮到我，因为我已经知道错误在那一行代码中。这感觉像是一个机会，可以和对象对话，或者我们也许可以想想上周遇到的错误，阿尔潘，你觉得呢？我认为这是因为好的，它是那个文件。
- en: telling you this because it's，it's receiving a all the uh values are，in integer
    type。but you are telling it to be influenced，yeah you're putting it into the average。exactly
    score oh go ah**d，yeah sorry so the computer is just still，keeping it as float。so
    as a result it doesn't know what to，do indeed so score one score two score，three
    are all integers。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉你这些是因为，它接收到的所有值都是整型。但是你告诉它要受到影响，是的，你把它放入了平均分中。正是得分，哦，天哪，抱歉，所以计算机仍然把它当作浮点数。结果它不知道该怎么做，实际上得分一、得分二、得分三都是整数。
- en: integer and so，this time the compiler is smart enough，to，coerce an integer result
    into a floating。point value but you haven't done any，floating point arithmetic
    if you will。so you know there's a few ways to fix，this last week recall，we proposed
    that you could use a cast。and you could explicitly，cast one or more of those values
    to a，float so i could do this for instance。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 整数，因此这次编译器足够聪明，可以将整数结果强制转换为浮点值，但你并没有进行任何浮点运算。如果你愿意的话。所以你知道有几种方法来修复这个，上周回想一下，我们提出你可以使用强制类型转换，你可以显式地将一个或多个值转换为浮点数，所以我可以这样做，例如。
- en: or i could cast all of these to floats，or one of these to floats there's many，simplest
    fix。is just to divide for instance by 3。0 i，can avoid some of the the headaches
    of。casting from one to another，by just making sure that there's at。least one floating
    point value involved，in this arithmetic so now let me，recompile scores。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我可以把所有这些转换为浮点数，或者其中一个转换为浮点数，还有很多，最简单的修复方法。就是例如除以3.0，这样我可以避免一些从一种类型到另一种类型的麻烦，确保至少参与这个运算中有一个浮点值。现在让我重新编译得分。
- en: this time it compiles okay let me do dot，slash scores and voila，my average isn't
    so high 59。3333。all right so what is actually going on，inside of the computer
    in，irrespective of the floating point。last week，well let's consider these three，three，where
    are they actually being stored in。consider that，grid again and again i'm going
    to start，at top left for convenience。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这次编译正常，让我做一下点，斜杠得分，瞧，我的平均分不高，59.3333。好的，那么计算机内部到底发生了什么，与浮点数无关。上周，让我们考虑这三个，三个，它们实际上存储在哪里。再考虑一下那个网格，我将从左上角开始，方便起见。
- en: but technically speaking and we'll see，this down the road your computer's。memory
    is just like this big，different places，but for today we'll keep it clean the。first
    variable score one，i claim is going to be here top left for。simplicity but what's
    important about，stored，is it's come taking up four of these。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但从技术上讲，我们会在后面看到，你的计算机内存就像是这样一大堆不同的地方，但今天我们会保持简洁。第一个变量得分一，我声称它将在这里的左上角，简单起见，但存储的重要性在于，它占用了这四个。
- en: boxes each of these boxes recall，represents one byte，and an integer recall and
    cs50 ide is。four bytes，therefore i have used four bytes of，space to represent
    the number 72。the number 73 in score two similarly is，three，gonna take up four
    boxes as well but。what's really going on，underneath the hood here well if each
    of。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框中的每一个代表一个字节，整数回忆，cs50 ide 是四个字节，因此我使用了四个字节的空间来表示数字72。分数二中的数字73同样是三个，也会占用四个框，但这里的底层到底发生了什么呢？
- en: these squ*res represents a byte and each，of those bytes is eight。bits and a
    bit is just a zero or one，what's really going underneath the hood。is something
    like this somehow this，electronic memory，is storing electricity in just the right。way
    so that it's storing，and decimal，decimal，this pattern of zeros and ones aka 33。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些正方形代表一个字节，每个字节是八个比特，而比特就是零或一，真正发生的事情是这样的，这种电子存储器以正确的方式存储电，存储并以十进制方式存储这个零和一的模式，也就是33。
- en: in decimal but again we don't have to，keep thinking about or dwelling on the，that。everything
    we've discussed thus far is，coming together now in this one picture。because the
    computer is just storing，these patterns for us and we are。allocating space now
    thanks to our，programming language，via code like this but this code。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制中，但我们不必继续思考或沉迷于此。到目前为止我们讨论的一切，现在在这张图中汇聚在一起。因为计算机只是为我们存储这些模式，而我们正在分配空间，感谢我们的编程语言，通过这样的代码，但这段代码。
- en: correct though it may be indeed 59。33333，and so forth was my average if my test。scores
    were 72 73 and 33，but i feel like there's an opportunity，for better design here。so
    not just correctness not just style，recall that design is this other metric，of
    code quality。and it's a little more subjective and，it's a little more subject
    to debate，among reasonable people。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我的平均值确实是59.33333，如果我的测试分数是72、73和33，但我觉得这里有更好设计的机会。因此，不仅仅是正确性，不仅仅是风格，回忆一下设计是代码质量的另一种衡量标准。这更主观，且更容易在合理的人之间引发辩论。
- en: but i don't really love what i was doing，with this，naming scheme and in fact
    if we look at。the code there really wasn't much more，to my program than these
    three lines。i worry this program isn't particularly，well designed，about。![](img/8108029379785de9f1a769f3c0516d9f_107.png)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但我并不太喜欢我在这个命名方案中所做的，实际上如果我们看看代码，我的程序除了这三行外并没有更多。我担心这个程序设计得并不好。
- en: those three lines of code what could be，and even if you don't know the solution。especially
    if you've never programmed，before，what kind of smells about those three，code smell。it's
    like something not loving that for，on it。![](img/8108029379785de9f1a769f3c0516d9f_109.png)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码可能是什么，即使你不知道解决方案，尤其是如果你从未编程过，关于这三行代码的气味是什么？这就像某种不爱的感觉。
- en: what's，smelly if you will about score one score，i was going to say if you're
    doing an，add them up。all together in the code you can add，variable，absolutely
    if i'm computing the average。i don't need to keep all three around i，can just
    keep a sum and divide the whole。sum by the total number i like that，like，about
    the design of this code now score，one score two score。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意说分数一有什么不好的地方，我本来想说，如果你要把它们全部加起来。在代码中，你可以添加变量，绝对可以，如果我在计算平均值，我不需要保留这三个分数，我可以只保留总和，然后用总和除以数量，我喜欢这样，关于这段代码的设计，现在分数一、分数二。
- en: three score one score two score three，might there be opportunities still for。improvement
    i feel like anytime you，start to see this repetition，oh um i think i would not。hard
    code the three scores together okay，so not hardcode the three scores and。what
    would you do instead，i would maybe take an input or i would。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 三个分数，一个分数，两个分数，三个分数，是否还有机会进行改进。我感觉每当你开始看到这种重复时，哦，我想我不会将这三个分数硬编码在一起，好的，所以不硬编码这三个分数，那你会怎么做呢？我可能会接受一个输入，或者我会。
- en: yeah i wouldn't i wouldn't write out the，scores themselves yeah another good，written
    a program。compiled a program that only computes，the average for some student who。literally
    got those three test scores，here，moreover it's a little lazy too that i。called
    my variables score one score two，score three i mean where does it end。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我不会写出分数本身，是的，另一个好的程序。我编写了一个程序，仅计算某个学生的平均分，实际上得到了这三个测试分数。这里，此外，称我的变量为分数一、分数二、分数三也有点懒，究竟能到哪里呢？
- en: after that if i want to have a fourth，test next semester，now i have to go and
    have score four if。i've got a fifth score five，that starts to sort of be reminiscent
    of。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之后如果我想在下学期参加第四次测试，现在我必须去拿四分。如果我得到了五分，那就开始有点让人想起。
