- en: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P12：L3- 优化算法 2 (线性搜索，节点一致性) - ShowMeAI
    - BV1AQ4y1y7wy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-AI ｜ Python人工智能入门（2020·完整版）- P12：L3- 优化算法 2（线性搜索，节点一致性）- ShowMeAI - BV1AQ4y1y7wy
- en: increase the probability that we do find，it and so the most popular technique
    for。trying to approach the problem from that。![](img/0ad043a7140346c67529dfdc877302ff_1.png)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 增加我们找到它的概率，因此最流行的技术是从这个问题入手。![](img/0ad043a7140346c67529dfdc877302ff_1.png)
- en: angle is a technique known as simulated，annealing simulated because it's。modeling
    after a real physical process，of annealing where you can think about。this in terms
    of physics a physical，situation where you have some system of。particle ISM and
    you might imagine that，when you heat up a particular physical。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 角度是一种称为模拟退火的技术，之所以称为模拟是因为它模拟了一个真实的物理过程，即退火过程，你可以将其视为物理中的一种情况，涉及一些粒子系统，并且你可能会想象，当你加热某个特定的物理。
- en: system there's a lot of energy there，things are moving around quite randomly。but
    over time as the system cools down，it eventually settles into some final。position
    and that's going to be the，general idea of simulated annealing。we're going to
    simulate that process of，some high-temperature system where。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中有很多能量，事物随机移动得相当频繁，但随着时间的推移，随着系统降温，它最终稳定在某个最终位置，这就是模拟退火的一般思路。我们将模拟某个高温系统的过程，其中。
- en: things are moving around randomly quite，frequently but over time decreasing
    that。![](img/0ad043a7140346c67529dfdc877302ff_3.png)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事物会随机移动得相当频繁，但随着时间的推移，降低这个温度。![](img/0ad043a7140346c67529dfdc877302ff_3.png)
- en: temperature until we eventually settle，at our ultimate solution and the idea
    is。going to be if we have some state space，landscape that looks like this and
    we。begin at its initial state here if we're，looking for a global maximum and we're。trying
    to maximize the value of the，state our traditional hill climbing。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我们最终稳定在我们的最终解决方案，想法是如果我们有一些状态空间，景观看起来像这样，我们从初始状态开始，如果我们在寻找全局最大值并且我们。想要最大化状态的值，我们的传统爬山。
- en: algorithms would just take this state，and look at the two neighbor ones and。![](img/0ad043a7140346c67529dfdc877302ff_5.png)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 算法只会获取这个状态，并查看两个相邻的状态和。![](img/0ad043a7140346c67529dfdc877302ff_5.png)
- en: always pick the one that is going to，increase the value of the state but if。we
    want some chance of being able to，find the global maximum we can't always。make
    good moves we have to sometimes，make bad moves and allow ourselves to。make a move
    in a direction that actually，seems for now to make our situation。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 总是选择一个能够增加状态值的，但如果我们想有机会找到全局最大值，我们不能总是做出好的移动，有时我们必须做出糟糕的移动，允许自己朝着一个方向移动，这在目前看来似乎会让我们的情况。
- en: worse such that later we can find our，way up to that global maximum in terms。of
    trying to solve that problem of，course once we get up to this global。maximum once
    we've done a whole lot of，the searching then we probably don't。want to be moving
    to states that are，worse than our current state and so this。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟，这样之后我们可以找到通往全局最大值的路径，以解决该问题。当然，一旦我们达到这个全局最大值，经过大量搜索后，我们可能不想移动到比当前状态更糟的状态，因此。
- en: is where this metaphor for annealing，starts to come in where we want to start。making
    more random moves and over time，start to make fewer of those random。moves based
    on a particular temperature，schedule，so the basic outline looks something。like
    this early on and simulated，annealing we have a higher temperature。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是退火隐喻开始发挥作用的地方，我们想开始进行更多随机的移动，并随着时间的推移，基于特定的温度计划，逐渐减少这些随机移动，因此基本轮廓看起来像这样：在模拟退火的早期，我们有一个较高的温度。
- en: state and what we mean by a higher，temperature state is that we are more。likely
    to accept neighbors that are，worse than our current state but we。might look at
    our neighbors and if one，of our neighbors is worse than the。current state especially
    if it's not all，that much worse if it's pretty close but。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 状态，以及我们所指的较高温度状态是，我们更可能接受比当前状态更糟的邻居，但我们可能会查看我们的邻居，如果其中一个邻居比当前状态更糟，尤其是如果它并没有太糟，只是稍微糟一点。
- en: just slightly worse then we might be，more likely to accept that and go ahead。and
    move to that neighbor anyways but，later on as we run simulated annealing。we're
    going to decrease that temperature，and at a lower temperature we're going。to be
    less likely to accept neighbors。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可能更愿意接受，并继续移动到那个邻居那里，但随着我们运行模拟退火，稍后我们将降低温度，而在较低的温度下，我们将不太可能接受邻居。
- en: '![](img/0ad043a7140346c67529dfdc877302ff_7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad043a7140346c67529dfdc877302ff_7.png)'
- en: that are worse than our current state，now to formalize this and put a little。bit
    of pseudocode to it here is what。![](img/0ad043a7140346c67529dfdc877302ff_9.png)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那些比我们当前状态更差的状态，现在为了使这个更正式，下面是一些伪代码！[](img/0ad043a7140346c67529dfdc877302ff_9.png)
- en: that algorithm might look like we have a，function called simulated annealing
    that。takes as input the problem we're trying，to solve and also potentially some。maximum
    number of times we might want to，run the simulated annealing process how。many
    different neighbors were going to，try and look for them and that value is。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可能看起来像我们有一个叫做模拟退火的函数，它以我们试图解决的问题为输入，并可能还包括我们希望运行模拟退火过程的最大次数，以及我们将尝试查找多少个不同的邻居。
- en: going to vary based on the problem，you're trying to solve well again start。with
    some current state that will be，equal to the initial state of the。problem but
    now we need to repeat this，process over and over for max number of。times repeat
    some process some number of，times where we're first going to。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将根据你要解决的问题而变化，再次从某个当前状态开始，这将等于问题的初始状态，但现在我们需要重复这个过程多次，最多重复某个过程的次数。
- en: calculate a temperature and this，temperature function takes the current。time
    T starting at 1 going all the way，up to max and then gives us some。temperature
    that we can use in our，computation where the idea is that this。temperature is
    going to be higher early，on and it's going to be lower later on。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个温度，这个温度函数接受当前时间T，从1开始，一直到最大值，然后给我们一个可以在计算中使用的温度，其想法是这个温度在早期会较高，而后来会较低。
- en: so there are a number of ways this，temperature function could often work。one
    of the simplest ways is just the，same it is like the proportion of time。that we
    still have remaining out of like，max units of time how much time do we。have remaining
    you start off with a lot，of that time remaining and as time goes。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个温度函数可以有多种工作方式。最简单的方法之一就是它像剩余时间的比例，从最大时间单位中我们还剩多少时间，你一开始剩下很多时间，随着时间的推移。
- en: on the temperature is going to decrease，because you have less and less of that。remaining
    time still available to you so，we calculate a temperature for the。current time
    and then we pick a random，neighbor of the current state no longer。we're going
    to be picking the best，neighbor that we possibly can or just。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 温度将会下降，因为你剩下的时间越来越少。因此，我们计算当前时间的温度，然后随机选择一个当前状态的邻居，而不再选择我们可能能选择的最佳邻居。
- en: one of the better neighbors that we can，we're gonna pick a random neighbor it。might
    be better it might be worse but，we're gonna calculate that we're gonna。calculate
    Delta e at U for energy in，this case which is just how much better。is the neighbor
    than the current state，so if Delta e is positive that means the，state。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能选择的较好的邻居之一，我们会随机选择一个邻居，它可能更好也可能更差，但我们会计算，计算能量的Δe，这只是邻居比当前状态好多少，因此如果Δe为正，这意味着状态。
- en: if delta e is negative that means the，neighbor is worse than our current state。and
    so we can then have a condition that，looks like this if delta e is greater。than
    0 that means the neighbor state is，better than our current state and if。ever that
    situation arises we'll just go，ahead and update current to be that。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Δe为负，这意味着邻居比我们当前状态更差，因此我们可以有一个条件，像这样，如果Δe大于0，这意味着邻居状态比我们当前状态更好，如果这种情况出现，我们将更新当前状态。
- en: '![](img/0ad043a7140346c67529dfdc877302ff_11.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad043a7140346c67529dfdc877302ff_11.png)'
- en: neighbor same as before move where we，are currently to be the neighbor because。the
    neighbor is better than our current，state we'll go ahead and accept that but。now
    the difference is that whereas，before we never ever wanted to take a。move that
    made our situation worse，now we sometimes want to miracle make a。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居和之前一样，移动到我们当前的邻居，因为这个邻居比我们当前状态更好，我们将接受这个选择。但现在的不同之处在于，以前我们绝对不想采取使情况变糟的移动，而现在我们有时想要采取这种“奇迹”般的移动。
- en: move that is actually going to make our，situation worse because sometimes we're。going
    to need to dislodge ourselves from，a local minimum or local maximum to。increase
    the probability that we're able，to find the global minimum or the global。maximum
    a little bit later and so how do，we do that how do we decide to sometimes。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 移动实际上会使我们的情况变得更糟，因为有时我们需要摆脱局部最小值或局部最大值，以提高找到全局最小值或全局最大值的概率。那么我们该如何做到呢？我们如何决定有时。
- en: accept some state that might actually be，worse well we're going to accept a
    worse。state with some probability and that，probability needs to be based on a。couple
    of factors it needs to be based，in part on the temperature where if the。temperature
    is higher we're more likely，to move to a worse neighbor and if the。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一些实际上可能更糟的状态。我们将以某种概率接受一个更糟的状态，而这个概率需要基于几个因素，部分基于温度，如果温度更高，我们更有可能移动到更糟的邻居。
- en: temperature is lower we're less likely，to move to a worse neighbor but also
    to。some degree should be based on Delta e，if the neighbor is much worse than the。current
    state we probably want to be，less likely to choose that than if the。neighbor is
    just a little bit worse than，the current state so again there are a。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 温度降低时，我们不太可能移动到更差的邻居，但也应该在某种程度上基于Delta e。如果邻居比当前状态差得多，我们可能会更不愿意选择这个邻居，而不是当邻居仅比当前状态稍差时。所以再次说，这里有一个。
- en: couple of ways you could calculate this，but it turns out one of the most popular。is
    just to calculate e to the power of，Delta e over T where e is just a。constant
    Delta e over T are based on，Delta e and T here we calculate that。value and that'll
    be some value between，0 and 1 and that is the probability with。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以计算这个，但事实证明最流行的方法之一是计算e的幂，Delta e除以T，其中e只是一个常数。Delta e除以T是基于Delta e和T，在这里我们计算这个值，这个值将在0到1之间，这是概率。
- en: which we should just say all right let's，go ahead and move to that neighbor
    and。it turns out it than if you do the math，for this value when Delta e is such
    that。the neighbor is not that much worse than，the current state that's going to
    be。more likely that we're going to go ahead，and move to that state and likewise
    when。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该说，好吧，继续移动到那个邻居。事实证明，当Delta e的值使得邻居与当前状态没有那么差时，我们更可能继续移动到那个状态，同样当。
- en: the temperature is lower we're going to，be less likely to move to that。neighboring
    state as well so now this is，the big picture for simulated annealing。this process
    of taking the problem and，going ahead and generating random。neighbors will always
    move to a neighbor，if it's better than our current state。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当温度降低时，我们也不太可能移动到那个邻居状态。所以现在这是模拟退火的全局视角。这个过程涉及将问题进行处理，并生成随机邻居，如果邻居比当前状态更好，我们将始终移动到邻居。
- en: but even if the neighbor is worse than，our current state will sometimes move，there。depending
    on how much worse it is and，also based on the temperature and as a。result the
    hope the goal of this whole，process is that as we begin to try and。find our way
    to the local the global，maximum or the global minimum we can。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使邻居比我们当前的状态更糟，有时我们仍会移动到那里，这取决于有多糟，也取决于温度。因此，这整个过程的希望和目标是，当我们开始寻找局部或全局最大值或全局最小值时，我们可以。
- en: dislodge ourselves if we ever get stuck，at a local maximum or local minimum
    in。order to eventually make our way to，exploring the part of the state space。that
    is going to be the best and then as，the temperature decreases eventually we。settle
    there without moving around too，much from what we found to be the。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在局部最大值或局部最小值卡住了，我们需要摆脱这种情况，以最终探索状态空间中最佳的部分。随着温度的降低，我们最终会在我们发现的状态附近稳定下来，而不会移动太多。
- en: globally best thing that we can do thus，far so at the very end we just return。whatever
    the current state happens to be，and that is the conclusion of this。algorithm we've
    been able to figure out，what the solution is。and these types of algorithms have
    a lot，of different applications anytime you。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以做的最好事情。因此，在最后我们只需返回当前状态，这就是这个算法的结论，我们已经能够找出解决方案。这些类型的算法有很多不同的应用场景。
- en: can take a problem and formulate it as，something where you can explore a。particular
    configuration and then ask，are any of the neighbors better than。this current configuration
    and have some，way of measuring that then there's an。applicable case for these
    hill climbing，simulated annealing types of algorithms。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个问题表述为某种形式，探索一个特定的配置，然后问，是否有任何邻居比当前配置更好，并且有某种测量方法，那么对于这些爬山算法、模拟退火类型的算法就有适用的案例。
- en: so sometimes it can be for facility，location type problems like for when。you're
    trying to plan a city and figure，out where the hospital should be but。there are
    definitely other applications，as well and one of the most famous。problems in computer
    science is the，Traveling Salesman problem traveling。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候这可以用于设施选址问题，比如在规划一个城市时，确定医院应该在哪里，但也确实有其他应用，计算机科学中最著名的问题之一就是旅行商问题。
- en: salesman problem generally is formulated，like this I have a whole bunch of cities。here
    indicated by these dots and what，I'd like to do is find some route that。takes
    me through all of the cities and，ends up back where I started。so some route that
    like starts here goes，through all these cities and and ends up。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 销售员问题通常被表述为，我这里有一大堆城市，用这些点表示，而我想做的是找到一条经过所有城市并最终返回起点的路线。也就是说，一条从这里出发，经过所有这些城市，最后回到起点的路线。
- en: back where I originally started and what，I might like to do is minimize the
    total。distance that I have to travel in order，to or the total cost of taking this。entire
    path and you can imagine this is，a problem that's very applicable in。situations
    like when delivery companies，are trying to deliver things to a whole。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我最初开始的地方，我可能想做的是最小化我必须旅行的总距离，或者说是整个路径的总成本。你可以想象这是一个在交付公司试图将物品送到许多不同房屋时非常适用的问题。
- en: bunch of different houses they want to，figure out how do I get from the。warehouse
    to all these various different，houses and get back again all using as。minimal
    time and distance and energy as，possible so you might want to try to。solve these
    sorts of problems but it，turns out that solving this particular。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一堆不同的房子，他们想知道如何从仓库到达这些不同的房子，并且再返回，所有这些都尽可能使用最少的时间、距离和能量，所以你可能想尝试解决这些类型的问题，但事实证明，解决这个特定的销售员问题通常是这样的。
- en: kind of problem is very computationally，difficult it's a very computationally。expensive
    task to be able to figure it，out this falls under the category of。what are known
    as np-complete problems，problems that there is no known。efficient way to try and
    solve these，sorts of problems and so what we。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题在计算上非常困难，解决它是一个非常消耗计算资源的任务，这属于被称为 NP 完全问题的类别，这些问题没有已知的高效解决方法。因此，我们...
- en: ultimately have to do is come up with，some approximation some ways of trying。to
    find a good solution even if we're，not going to find the globally best。solution
    that we possibly can at least，not in a feasible or tractable amount of。time and
    so what we could do is take the，Traveling Salesman problem and try to。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我最终必须做的是提出某种近似方法，尝试找到一个好的解决方案，即使我们不能找到可能的全局最佳解决方案，至少在可行或可处理的时间内不能找到。因此，我们可以拿旅行商问题来尝试解决。
- en: formulate it using local search and ask，a question like all right I can pick。some
    state some configuration some route，between all of these nodes and I can。measure
    the cost of that state figure，out what the distance is and I might we。now want
    to try to minimize that cost as，much as possible and then the only。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部搜索来进行表述，问一个问题，比如，我可以选择某个状态、某个配置或节点之间的某条路线，并且我可以测量这个状态的成本，算出距离，然后我可能想尽可能地最小化这个成本。
- en: question now is what does it mean to，have a neighbor of this state what does。it
    mean to take this particular route，and have some neighboring route that is。close
    to it but slightly different and，such that it might have a different。total distance
    and there are a number of，different definitions for what a。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，拥有这个状态的邻居意味着什么？走这条特定路线意味着什么？以及是否存在一条与之接近但略有不同的邻近路线，这可能会导致总距离的不同，而对于这类问题有许多不同的定义。
- en: neighbor of a traveling salesman，configuration might look like but one。way is
    just the same a neighbor is what，happens if we pick two of these edges。between
    nodes and switch them，effectively so for example I might pick。these two edges
    here these two that just，happen to cross this node goes here this。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: node goes there and go ahead and switch，them and what that process will。generally
    look like is removing both of，these edges from the graph taking this。node and
    connecting it to the node it，wasn't connected to so connecting it up。here instead
    we'll need to take these，arrows that were originally going this。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: way and reverse them so move them going，the other way and then just fill in
    that。last remaining blank add an arrow that，goes in that direction instead so
    by。taking two edges and just switching them，I have been able to consider one。possible
    neighbor of this particular，configuration and it looks like this。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: neighbor is actually better it looks，like this probably travels a a shorter。distance
    in order to get through all the，cities through this route then the。current state
    did and so you could，imagine implementing this idea inside of。a hill climbing
    or simulated annealing，algorithm where we repeat this process。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: to try and take a state of this，Traveling Salesman problem look at all。the neighbors
    and then move to the，neighbors if they're better or maybe。even move to the neighbors
    if they're，worse until we eventually settle upon。some best solution that we've
    been able，to find and it turns out that these。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: types of approximation algorithms even，if they don't always find the very best。solution
    can often do pretty well at，to find solutions that are helpful too。so that then
    was a look at local search，particular category of algorithms that。can be used
    for solving a particular，type of problem where we don't really。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: care about the path to the solution I，didn't care about the steps I took to。decide
    where the hospital should go I，just cared about the solution itself I。just care
    about where the hospitals，should be or what the route through the。Traveling Salesman
    journey really ought，to be another type of algorithm that。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: might come up are known as these，categories of linear programming types。of problems
    and linear programming often，comes up in the context where we're。trying to optimize
    for some mathematical，function but oftentimes linear。programming will come up
    when we might，have real real numbered values so it's。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: not just like discrete fixed values that，we might have but any decimal values。that
    we might want to be able to。![](img/0ad043a7140346c67529dfdc877302ff_13.png)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: calculate and so linear programming is a，family of types of problems where we。might
    have a situation that looks like，this where the goal of linear。programming is
    to minimize a cost，function and you can invert the numbers。and say try and maximize
    it but often，we'll frame it as trying to minimize a。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: cost function that has some number of，variables X 1 X 2 X 3 all the way up to。X
    n just some number of variables that，are involved things that I want to know。the
    values to and this cost function，might have coefficients in front of。those variables
    and this is what we，would call like a linear equation we。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 成本函数有一些变量X1、X2、X3，一直到Xn，只是一些涉及的变量，我想知道这些变量的值，而这个成本函数可能在这些变量前面有系数，这就是我们所称的线性方程。
- en: just have all of these variables that，might be multiplied by a coefficient and。then
    add it together we're not gonna，square anything or cube anything because。that'll
    give us different types of，equations with linear programming we're。just dealing
    with linear equations in，addition to linear constraints we're a。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是有所有这些变量，可能会被一个系数相乘，然后相加，我们不会对任何东西进行平方或立方，因为那会给我们不同类型的方程式，在线性规划中我们只是处理线性方程，加上线性约束。
- en: constraint it's going to look something，like if we sum up this particular。equation
    that is just some linear，combination of all these variables and。it is less than
    or equal to some bound B，and we might have a whole number of。these various different
    constraints that，we might place onto our linear。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 约束条件看起来可能是这样的，如果我们将这个特定的方程式相加，这只是所有这些变量的某种线性组合，并且小于或等于某个界限B，可能会有许多不同的约束条件，我们可能会施加在我们的线性模型上。
- en: programming exercise and likewise just，as we can have constraints that are。saying
    this linear equation is less than，or equal to some bound B it might also。be equal
    to something but if you want，some sum of some combination of。variables to be equal
    to a value you can，specify that and we can also may be。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编程练习，同样地，我们可以有约束，表示这个线性方程小于或等于某个界限B，它也可能等于某个值，但如果你想要某个变量组合的和等于某个值，你可以指定这一点。
- en: specifying that each variable has lower，and upper bounds that it needs to be
    a。positive number for example or it needs，to be a number that is less than 2。for
    example and there are a number of，other choices that we can make there for。defining
    what the balance of a variable，are but it turns out that if you can。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指定每个变量具有下限和上限，例如，它需要是一个正数，或者它需要是小于2的数字，还有其他一些选择，我们可以在这里进行，以定义变量的平衡，但事实证明，如果你能。
- en: take a problem and formulate it in these，terms formulate the problem as your
    goal。is to minimize a cost function and，you're minimizing that cost function。subject
    to particular constraints，subjects to equations that are of the。form like this
    of some sequence of，variables is less than a bound or is。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将一个问题用这些术语进行公式化，公式化这个问题为你的目标是最小化一个成本函数，并且你在特定约束下最小化该成本函数，约束的方程形式像这样，一些变量的序列小于某个界限或等于某个值。
- en: equal to some particular value then，there are a number of algorithms that。already
    exist for solving these sorts of，problems so let's go ahead and take a。look at
    an example here's an example of，a problem that might come up in the。world of linear
    programming often this，is going to come up when we're trying to。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的就是这样，但我们需要做到这一点，以等于某个特定值，然后已经存在一些算法来解决这些类型的问题，所以让我们来看一个例子，这里是一个可能在线性规划领域出现的问题的例子，通常在我们试图解决时会出现。
- en: optimize for something and we want to be，able to do some calculations and we
    have。constraints on what we're trying to。![](img/0ad043a7140346c67529dfdc877302ff_15.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 优化某个东西，我们想能够进行一些计算，并且我们对我们正在尝试的内容有约束！[](img/0ad043a7140346c67529dfdc877302ff_15.png)
- en: optimize them and so it might be，something like this in the context of a。factory
    we have two machines x1 and x2，x1 cost $50 an hour to run x2 costs $80。an hour
    to run and our goal what we're，trying to do our objective is to。minimize the total
    cost so that's what，we'd like to do but we need to do so。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 优化它们，所以在工厂的背景下，它可能像这样，我们有两台机器x1和x2，x1的运行成本为每小时50美元，x2的运行成本为每小时80美元，我们的目标是最小化总成本。
- en: subject to certain constraints so there，might be a labor constraint that x1。requires
    5 units of labor per hour，x2 requires 2 units of labor per hour。and we have a
    total of 20 units of labor，that we have to spend so this is a。constraint we have
    no more than 20 units，of labor that we can spend and we have。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 受某些约束的影响，可能会有一个劳动约束，x1每小时需要5单位的劳动，x2每小时需要2单位的劳动，而我们总共有20单位的劳动可以使用，所以这是一个约束，我们最多只能花费20单位的劳动。
- en: to contend it across x1 and x2 each of，which requires a different amount of。labor
    and we might also have a，constraint like this that tells us x1 is。going to produce
    10 units of output per，hour x2 is going to produce 12 units of。output per hour
    and the company needs 90，units of output so we have some goal。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在x1和x2之间进行分配，每个都需要不同数量的劳动，并且我们可能还有一个约束条件，告诉我们x1每小时产生10单位的产出，x2每小时产生12单位的产出，而公司需要90单位的产出，因此我们有一些目标。
- en: something we need to achieve we need to，achieve 90 units of output but there
    are。some constraints that x1 can only，produce 10 units of output per hour。x2 produces
    12 units of output per hour，these types of problems come up quite。frequently and
    you can start to notice，patterns in these types of problems。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现90单位的产出，但有一些限制，x1每小时只能产生10单位的产出，x2每小时产生12单位的产出，这类问题相当常见，您会开始注意到这些类型问题中的模式。
- en: problems where I am trying to optimize，for some goal minimizing cost maximizing。output
    maximizing profits or something，like that and there are constraints that。are placed
    on that process and so now we，just need to formulate this problem in，with this
    first。two machines x1 and x2 X costs $50 an，hour x2 cost $80 an hour here we can。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在尝试优化的问题，目标是最小化成本或最大化输出、利润等，并且有一些限制条件。现在我们需要将这个问题表述为，涉及这两台机器x1和x2，x1每小时成本50美元，x2每小时成本80美元。
- en: come up with an objective function that，might look like this this is our cost。function
    rather 50 times x1 plus 80，times x2 where x1 is going to be a。variable representing
    how many hours we，run machine x1 4 x2 is going to be a。variable representing how
    many hours are，we running machine x2 4 and what we're。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提出一个目标函数，可能看起来像这样：这是我们的成本函数，实际上是50乘以x1加上80乘以x2，其中x1是一个变量，表示我们运行机器x1的小时数，x2是一个变量，表示我们运行机器x2的小时数。
- en: trying to minimize is this cost function，which is just how much it cost to run。each
    of these machines per hour summed，up this is an example of a linear。equation just
    some combination of these，variables plus coefficients that are。placed in front
    of them and I would like，to minimize that total value but I need。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要最小化的就是这个成本函数，即每小时运行这些机器的成本总和，这是一个线性方程，仅仅是这些变量加上前面的系数的某种组合，我希望最小化这个总值，但我需要。
- en: to do so subject to these constraints x1，requires 50 units of labor per hour。excuse
    to and we have a total of 20，units of labor to spend and so that。gives us a constraint
    of this form five，times x1 plus 2 times x2 is less than or。equal to 20 20 is the
    total number of，units of labor we have to spend and。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些约束条件下，x1每小时需要50单位的劳动，而我们总共有20单位的劳动可以使用，这样就给了我们一个这样的约束：5乘以x1加上2乘以x2小于或等于20，20是我们可以使用的劳动总量。
- en: that's spent across x1 and x2 each of，which requires a different number of。units
    of labor per hour for example and，finally we have this constraint here x1。produces
    10 units of output per hour，x2 produces 12 and we need 90 units of。output and
    so this might look something，like this that 10 x1 plus 12x - this is。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总量分配在x1和x2之间，每个每小时需要不同数量的劳动单位，最后我们还有这个约束，x1每小时产生10单位的产出，x2产生12单位，而我们需要90单位的产出，因此这可能看起来像这样：10乘以x1加上12乘以x2——这就是。
- en: amount of output per hour it needs to be，at least 90 if we can do better great。but
    it needs to be at least 90 and if，you recall from my formulation before I。said
    that generally speaking in linear，programming we deal with equals。constraints
    or less than or equal to，constraints so we have a greater than or。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每小时的产出数量需要至少为90，如果我们能做得更好，那很好，但至少需要达到90。如果您还记得我之前的表述，我说在一般的线性规划中，我们处理的是等式约束或小于等于约束，所以我们有一个大于或等于的约束。
- en: equal to sign here that's not a problem，whenever we have a greater than or equal。to
    sign we can just multiply the，equation by negative 1 and that'll flip。it around
    to a less than or equals，negative 90 for example instead of a。greater than or
    equal to 90 and that's，going to be an equivalent expression。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的等于号并不是问题，当我们有一个大于或等于的符号时，我们可以将方程乘以-1，这样就会翻转成小于或等于，比如说小于或等于-90，而不是大于或等于90，这将是一个等效的表达式。
- en: that we can use to represent this，problem so now that we have this cost。function
    and these constraints that it's，subject to it turns out there are a。number of
    algorithms that can be used in，order to solve these types of problems。and these
    problems go a little bit more，into geometry and linear algebra than。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来表示这个问题，现在我们有这个成本函数和这些约束条件，它们受到一些限制，结果是有多个算法可以用来解决这些类型的问题。
- en: we're really going to get into but the，most popular of these types of，algorithms。our
    simplex which was one of the first，algorithms discovered for trying to。solve linear
    programs and later on a，class of interior point algorithms can。be used to solve
    this type of problem as，well the key is not to understand。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以举个例子来看看！[](img/0ad043a7140346c67529dfdc877302ff_17.png)我们将深入探讨，但这些类型算法中最受欢迎的是单纯形法，它是最早被发现用来尝试解决线性规划的算法之一，后来还有一类内点算法也可以用来解决这种类型的问题，关键并不是理解。
- en: exactly how these algorithms work but to，realize that these algorithms exist
    for。efficiently finding solutions anytime we，have a problem of this particular
    form。and so we can take a look for example at。![](img/0ad043a7140346c67529dfdc877302ff_17.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题涉及的几何和线性代数的内容可能会多一点，而不是确切了解这些算法是如何工作的，但要意识到这些算法存在是为了高效地找到解决方案，每当我们遇到这种特定形式的问题时。
- en: the production directory here we're here，I have a file called production PI
    where。here I'm using scifi which is the，library for a lot of science related。functions
    within Python and I can go，ahead and just run this optimization。function in order
    to run a linear，program dot Lin prog here is going to。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的生产目录，我有一个名为 production PI 的文件，在这里我使用 scifi，这是 Python 中许多与科学相关的函数库，我可以继续运行这个优化函数来运行一个线性程序，dot
    Lin prog 在这里将会。
- en: try and solve this linear program for me，where I provide to this expression
    to。this function call all of the data about，my linear program so it needs to be
    in a。particular format which might be a，little confusing at first but this first。argument
    to scifi optimized lin，programming is the cost function which。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为我解决这个线性程序，我提供给这个表达式给这个函数调用所有有关我的线性程序的数据，所以它需要以特定格式提供，最初可能有点困惑，但这个 scifi 优化线性编程的第一个参数是成本函数。
- en: is in this case just an array or a list，that has 50 and 80 because my original。cost
    function was 50 times X 1 plus 80，times X 2 so I just tell Python 50 and。80 those
    are the coefficients that I am，now trying to optimize for and then I。provide all
    of the constraints so the，constraints and I wrote them up above。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它只是一个数组或列表，包含 50 和 80，因为我的原始成本函数是 50 乘以 X1 加 80 乘以 X2，所以我告诉 Python 50
    和 80，这些是我现在试图优化的系数，然后我提供所有的约束条件，约束条件我在上面写了。
- en: and comments is the constraint one is 5，X 1 plus 2 X 2 is less than or equal
    to。20 and constraint 2 is negative 10 X 1，plus negative 12 X 2 is less than or。equal
    to negative 90 and so Syfy expects，these constraints to be in a particular。format
    it first expects me to provide，all of the coefficients for the upper。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 并且约束条件一是 5X1 加 2X2 小于或等于 20，约束条件二是负 10X1 加负 12X2 小于或等于负 90，所以 Syfy 期望这些约束以特定格式提供，它首先期望我提供所有的上界系数。
- en: bound equations ub is just 4 4 upper，bound where the coefficients of the。first
    equation are 5 and 2 because we，have 5 x1 + 2 x2 and the coefficients。for the
    second equation are negative 10，and negative 12 because i have negative。10 x 1
    plus negative 12 X 2 and then，here we provide it as a separate。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 界限方程 ub 只是 4 4 上界，其中第一方程的系数是 5 和 2，因为我们有 5X1 + 2X2，而第二方程的系数是负 10 和负 12，因为我有负
    10X1 加负 12X2，然后这里我们将其作为一个单独的。
- en: argument just to keep things separate，what the actual bound is what is the。upper
    bound for each of these，constraints well for the first，was，number one and then
    for constraint。![](img/0ad043a7140346c67529dfdc877302ff_19.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 参数仅仅是为了保持事物的分隔，实际的界限是什么，每个约束的上界是什么，第一个约束是数字一，然后对于约束！[](img/0ad043a7140346c67529dfdc877302ff_19.png)。
- en: number two the upper bound is an ID so a，bit of a cryptic way of representing
    it。it's not quite as simple as just writing，the mathematical equations what really。is
    being expected here are all of the，coefficients and all of the numbers that。are
    in these equations by first，providing the coefficients for the cost。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，上界是一个 ID，所以有点神秘的表示方式，并不像简单地写下数学方程那么简单，真正期望的是所有的系数和这些方程中所有的数字，首先提供成本。
- en: function then providing all the，coefficients for the inequality。constraints
    and then providing all of，the upper bounds for those inequality。constraints and
    once all of that，information is there then we can run any。of these interior point
    algorithms or，the simplex algorithm even if you don't。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数提供所有不等式约束的系数，然后提供所有这些不等式约束的上界。一旦所有这些信息都在，我们就可以运行任何这些内部点算法或单纯形算法，即使你不。
- en: understand how it works you can just run，the function and figure out what the。result
    should be and here I said if the，result of the success we were able to。solve this
    problem go ahead and print，out what the value of x1 and x2 you。should be otherwise
    go ahead and print，out no solution and so if I run this。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 了解它的工作原理，你可以直接运行该函数，找出结果应该是什么。我说如果成功的结果是我们能够解决这个问题，继续打印出x1和x2的值，否则打印出没有解决方案，因此如果我运行这个。
- en: program by running Python production pi，it takes a second to calculate but then。we
    see here is what the optimal solution。![](img/0ad043a7140346c67529dfdc877302ff_21.png)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行Python程序来进行计算，计算需要一秒钟，但随后我们看到这是最佳解决方案。
- en: should be x1 should run for 1。5 hours x2，should run for 6 point 2 5 hours and
    we。![](img/0ad043a7140346c67529dfdc877302ff_23.png)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: x1应该运行1.5小时，x2应该运行6.25小时，我们。
- en: were able to do this by just formulating，the problem as a linear equation that
    we。were trying to optimize some cost that，we were trying to minimize them and
    then。some constraints that were placed on，that and many many problems fall into。this
    category of problems that you can，solve if you can just figure out how to。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过将问题表述为线性方程来实现这一点，我们试图优化一些成本，我们想要最小化的，然后是施加在这些问题上的一些约束，许多问题都属于这种你可以解决的类别，只要你能找出如何。
- en: use equations and use these constraints，to represent that general idea and thus。Athena
    is going to come up a couple of，times today where we want to be able to。take some
    problem and reduce it down to，some problem we know how to solve it in。order to
    begin to find a solution and to，use existing methods that we can use in。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方程和这些约束来表达那个总体想法，因此。雅典娜今天会出现几次，我们希望能够。将某个问题简化为我们知道如何解决的某个问题。以便开始寻找解决方案，并利用我们可以使用的现有方法。
- en: order to find a solution more，effectively or more efficiently and it。turns out
    that these types of problems，where we have constraints show up in。other ways too
    and there's an entire，class of problems it's more generally。just known as constraint
    satisfaction，problems and we're going to now take a。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效或更高效地找到解决方案，事实证明，这些类型的问题，带有约束的出现还有其他方式，并且有一整类问题更普遍地被称为约束满足问题，现在我们将进行一个。
- en: look at how you might formulate a，constraint satisfaction problem and how。you
    might go about solving a constraint，satisfaction problem but the basic idea。![](img/0ad043a7140346c67529dfdc877302ff_25.png)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你可能如何制定一个约束满足问题，以及你可能如何解决一个约束满足问题，但基本思路是。
- en: of the constraint satisfaction problem，is we have some number of variables that。need
    to take on some values and we need，to figure out what values each of those，variable。are
    subject to particular constraints，that are going to limit what values。those variables
    can actually take on so，let's take a look at a real world。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 约束满足问题的关键在于我们有一些变量需要取某些值，我们需要确定每个变量的值受特定约束的限制，这些约束会限制变量实际上可以取的值，因此，让我们看看一个现实世界的例子。
- en: example for example let's look at exam，scheduling that I have for students here。![](img/0ad043a7140346c67529dfdc877302ff_27.png)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看我为学生安排的考试安排。
- en: students 1 2 3 inform each of them is，taking some number of different classes。classes
    here are going to be represented，by letter ISM so student 1 is enrolled。in courses
    a b and c student 2 is，enrolled in courses b d and e so on and。so forth and now
    say university for，example is trying to schedule exams for。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 学生1、2、3每个人都在修一些不同的课程。这里的课程将用字母ISM表示，因此学生1注册了课程a、b和c，学生2注册了课程b、d和e，以此类推，现在假设某大学正在尝试为。
- en: all of these courses but there are only，3 exam slots on Monday Tuesday and。Wednesday
    and we have to schedule an，exam for each of these courses but the。constraint now
    the constraint we have to，deal with with the scheduling is that we。don't want
    anyone to have to take two，exams on the same day we would like to。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些课程中，周一、周二和周三只有三个考试时段，我们必须为每一门课程安排一次考试，但我们面临的约束是希望任何人都不要在同一天参加两场考试。
- en: try and minimize that or eliminate it if，at all possible so how do we begin
    to。represent this idea how do we structure，this in a way that a computer with
    an AI。algorithm can begin to try and solve the，problem well let's in particular
    just。look at these classes that we might take，and represent each of the courses
    'm as。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽量最小化或消除它，如果可能的话。那么我们如何开始表示这个概念？我们如何将其结构化，以便计算机与AI算法能够开始解决这个问题呢？让我们特别关注我们可能会选修的课程，并将每门课程表示为变量。
- en: some node inside of a graph and what，we'll do is we'll create an edge between。two
    nodes in this graph if there is a，constraint between those two nodes so。what does
    this mean well we can start，with student 1 who's enrolled in courses。a B and C
    what that means is that a and，B can't have an exam at the same time。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中某个节点内部，如果这两个节点之间存在约束，我们将创建一条边。因此，这意味着我们可以从选修课程A、B和C的学生1开始，这意味着A和B不能同时考试。
- en: and C can't have an exam at the same，time and B and C also can't have an exam。at
    the same time and I can represent，that in this graph by just drawing edges。one
    edge between a and B 1 between B and，C and then one between c na and that。encodes
    now the idea that between those，nodes there is a constraint and in。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C不能与A同时考试，B和C也不能同时考试，我可以通过在图中画边来表示这一点。A和B之间一条边，B和C之间一条边，再加上一条连接C的边。这现在编码了在这些节点之间存在约束的概念。
- en: particular the constraint happens to be，other，though there are other types of。constraints
    that are possible depending，on the type of problem that you're。trying to solve
    and then we can do the，same thing for each of the other。students so for student
    2 who's enrolled，in courses B D and E well that means B D。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，约束可能是其他类型的，尽管根据你试图解决的问题类型，可能还有其他约束。我们可以对其他学生做同样的事情，对于选修课程B、D和E的学生2，这意味着B、D和E之间都需要有连接边。
- en: and E or those all need to have edges，that connect each other as well student。3
    is enrolled in courses C E and F so，we'll go ahead and take C E and F and。connect
    those by drawing edges between，them two and then finally student fours。rolled
    in courses EF and G and we can，represent that by drawing edges between。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 学生3选修课程C、E和F，我们将继续连接C、E和F，并在它们之间画边。最后，学生4选修课程E、F和G，我们可以通过在它们之间画边来表示这一点。
- en: EF and G although ENF already had an，edge between them we don't need another。one
    because this constraint is just，encoding the idea that course Ian's。course F cannot
    have an exam on the same，day so this then is what we might call。the constraint
    graph there's some，graphical representation of all of my。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管E和F之间已经有一条边，但我们不需要再画一条，因为这个约束只是编码了课程I和课程F不能在同一天考试的概念。所以，这就是我们可能称之为的约束图，是对我所有课程的某种图形表示。
- en: variables so to speak and the，constraints between those possible。variables where
    in this particular case，each of the constraints represents an。inequality constraint
    and an edge，between B and D means whatever value the。variable B takes on cannot
    be the value，that the variable D takes on as well。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个约束代表一个不等式约束，而B和D之间的边意味着变量B所取的任何值不能与变量D所取的值相同。
- en: so what then actually is a constraint，satisfaction problem well a constraint。satisfaction
    problem is just some set of，variables x1 all the way through xn some。set of domains
    for each of those，variables so every variable needs to。take on some values maybe
    every variable，has the same domain but maybe each。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是约束满足问题呢？约束满足问题就是一组变量x1到xn，每个变量都有一组领域。每个变量需要取某些值，也许每个变量有相同的领域，但也可能每个变量都有不同的领域。
- en: variable has a slightly different domain，and then there's a set of constraint
    so。we'll just call a set C that is some，constraints that are placed upon these。variables
    like X 1 is not equal to X 2，like maybe，x1 equals x2 plus 1 if you if these。variables
    are taking on numerical values，in their domain for example the types of。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量有略微不同的范围，然后有一组约束，我们将称之为C，即施加在这些变量上的一些约束，例如X1不等于X2，或者X1等于X2加1，如果这些变量在它们的范围内取数值的话。
- en: constraints are going to vary based on，the types of problems and constraint。satisfaction
    shows up all over the place，as well in any situation where we have。variables that
    are subject to particular，constraints so one popular game is。Sudoku for example
    this 9 by 9 grid，where you need to fill in numbers in。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 约束将根据问题的类型变化，约束满足在任何我们有特定约束的变量的情况下都随处可见，一个流行的游戏是数独，例如这个9x9的网格，你需要在其中填入数字。
- en: each of these cells but you don't want，to make sure there's you want to make。sure
    there's never a duplicate number in，any row or in any column or in any grid。of
    3x3 cells for example so what might，this look like as a constraint。satisfaction
    problem well my variables，are all of the empty squares in the。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格的类型，但你不想确保在任何行、任何列或3x3的单元格网格中有重复的数字，例如，这个约束满足问题可能是什么样子呢？我的变量是所有的空方格。
- en: puzzle so represented here is just like，an X comma y coordinate for example
    as。all the squares where I need to plug in，a value where I don't know what value
    it。should take on the domain is just going，to be all of the numbers from 1 through。9
    any value that I could fill in to one，of these cells so that is going to be。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里表示的谜题就像是X，Y坐标，例如所有我需要填入值的方格，而我不知道该填什么值，范围只是从1到9的所有数字，任何我可以填入这些单元格的值。
- en: the domain for each of these variables，and then the constraints are going to
    be。of the form like this，can't be equal to this cell can't be，equal to cell can't
    be and all these。need to be different for example and，same for all of the rows
    and the columns。and the 3x3 squares as well so those，constraints are going to
    enforce what。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量的范围，然后约束将是这样的形式：不能等于这个单元格，不能等于那个单元格，所有这些需要是不同的，例如对于所有的行和列，以及3x3的方格也是如此，因此这些约束将强制执行什么。
- en: values are actually allowed and we can，formulate the same idea in the case of。this
    exam scheduling problem where the，variables we have are the different。courses
    a up through G the domain for，each of these variables is going to be。Monday Tuesday
    and Wednesday those are，the possible values each of the。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 值实际上是允许的，我们可以在这个考试安排问题中制定相同的想法，其中我们拥有的变量是不同的课程，G的范围对于这些变量的每一个都将是周一、周二和周三，这些是每个变量的可能值。
- en: variables can take on that in this case，just represent when is the exam for
    that。class and then the constraints are of，this form a is not equal to B a is
    not。equal to C meaning a and B can't have an，exam on the same day a and C can't
    have。an exam on the same day or more formally，these two variables cannot take
    on the。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在这个案例中取值，代表的是该课程的考试时间，然后约束的形式是A不等于B，A不等于C，这意味着A和B不能在同一天考试，A和C不能在同一天考试，或者更正式地说，这两个变量不能取相同的值。
- en: same value within their domain so that，then is this formulation of a constraint。satisfaction
    problem that we can begin，to use to try and solve this problem and。constraints
    can come in a number of，different forms there are hard。constraints which are constraints
    that，must be satisfied for a correct solution。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 同一值在它们的范围内，所以这就是我们可以开始使用的约束满足问题的一个公式化，约束可以以多种不同形式出现，有硬约束，必须为正确解决方案满足的约束。
- en: so something like in the Sudoku puzzle，you cannot have this cell and the cell。that
    are in the same row take on the，same value that is a hard constraint but。problems
    can also have soft constraints，where these are constraints that express。some notion
    of preference that may be a，and B can't have an exam on the same day。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在数独谜题中，像这样的情况是，你不能让同一行中的这个单元格和那个单元格取相同的值，这是一个硬约束，但问题也可以有软约束，这些约束表达某种偏好，例如A和B不能在同一天考试。
- en: but maybe someone has a preference that，A's exam is earlier than B's exam。doesn't
    need to be the case but there's，some expression that some solution is。better than
    another solution and in that，case you might formulate the problem as。trying to
    optimize for maximizing，people's preferences you want people's。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许有人希望 A 的考试比 B 的考试更早，这并不一定是事实，但有一些表达式表明某个解决方案优于另一个解决方案。在这种情况下，你可能会将问题表述为试图优化以最大化人们的偏好，你希望满足人们的。
- en: preferences to be satisfied as much as，possible in this case though we'll。mostly
    just deal with hard constraints，constraints that must be met in order to。have
    a correct solution to the problem，so we want to figure out some assignment。of
    these variables to their particular，values that is ultimately going to give。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能满足偏好，但在这种情况下，我们将主要处理硬约束，必须满足的约束，以便问题有一个正确的解决方案，因此我们希望找出这些变量到其特定值的某种分配，这最终会给。
- en: us a solution to the problem by allowing，us to assign some day to each of the。classism
    such that we don't have any。![](img/0ad043a7140346c67529dfdc877302ff_29.png)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们提供解决问题的方案，通过允许我们为每门课程分配某一天，以确保我们没有任何。![](img/0ad043a7140346c67529dfdc877302ff_29.png)
- en: conflicts between classes so it turns，out that we can classify the constraints。in
    a constraint satisfaction problem，into a number of different categories。the first
    of those category，perhaps the simplest of the types of。constraints which are known
    as unary，constraints where a unary constraint is。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类之间的冲突，因此我们可以将约束满足问题中的约束分类为多个不同的类别。其中第一个类别，也许是最简单的类型，被称为单元约束，单元约束是。
- en: a constraint that just involves a single，variable for example the unary。constraint
    might be something like a it，does not equal Monday meaning course a。![](img/0ad043a7140346c67529dfdc877302ff_31.png)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仅涉及单一变量的约束，例如单元约束可能是像 a 不等于星期一，这意味着课程 a。![](img/0ad043a7140346c67529dfdc877302ff_31.png)
- en: cannot have its exam on Monday if for，some reason the instructor for the。course
    isn't available on Monday you，might have a constraint in your problem。that looks
    like this something that just，has a single variable a in it and maybe。says a is
    not equal to Monday or a is，equal to something or in the case of。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因课程的讲师在星期一不可用，则该课程不能在星期一进行考试。你可能在你的问题中有一个看起来像这样的约束，它只涉及一个单一变量 a，并且可能说
    a 不等于星期一，或者 a 等于某个值，或者在这种情况下。
- en: numbers greater than or less than。![](img/0ad043a7140346c67529dfdc877302ff_33.png)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大于或小于的数字。![](img/0ad043a7140346c67529dfdc877302ff_33.png)
- en: something a constraint that just has one，variable we consider to be a unary。constraint
    and this is in contrast to，something like a binary constraint which。is a constraint
    that involves two，variables for example so this would be a。constraint like the
    ones we were looking。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 约束中只有一个变量的情况，我们认为这是一个单元约束，这与涉及两个变量的二元约束形成对比。例如，这将是我们所研究的那种约束。
- en: '![](img/0ad043a7140346c67529dfdc877302ff_35.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad043a7140346c67529dfdc877302ff_35.png)'
- en: at before something like a does not，equal B is an example of a binary。constraint
    because it is a constraint，that has two variables involved in an A。and B and we
    represented that using some，arc or some edge the K'NEX variable a。two variable
    B and using this knowledge，of okay what does a unary constraint。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似于 a 不等于 B 的情况下，这是一个二元约束，因为这是一个涉及两个变量 A 和 B 的约束，我们用一些弧或边表示这一点，K'NEX 变量 a，两个变量
    B，并利用这一知识，好的，单元约束是什么。
- en: what is the binary constraint there are，different types of things we can say。about
    a particular constraint。![](img/0ad043a7140346c67529dfdc877302ff_37.png)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是二元约束？我们可以对特定约束说出不同类型的事情。![](img/0ad043a7140346c67529dfdc877302ff_37.png)
- en: satisfaction problem and one thing we，can say is we can try and make the。problem
    node it consistent so what does，no consistency mean node consistency。means we
    have all of the values in a，variables domain satisfying that。variables unary constraints
    so for each，of the variables inside of our。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 满意度问题，我们可以说的是，我们可以尝试使问题节点一致。那么什么是“一致性”呢？节点一致性意味着变量域中的所有值都满足该变量的单元约束，因此对于我们所有变量中的每一个。
- en: constraint satisfaction problem if all，of the values satisfy the unary。constraints
    for that particular variable，we can say that the entire problem is。node consistent
    or we can even say that，a particular variable is node consistent。if we just want
    to make one node，consistent within himself so what does。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在约束满足问题中，如果所有值都满足该特定变量的一元约束，我们可以说整个问题是节点一致的，或者我们甚至可以说特定变量是节点一致的，如果我们只想让一个节点在其自身内部保持一致。
- en: that actually look like let's look at，now a simplified example where instead。of
    having a whole bunch of different，classes we just have two classes a and B。each
    of which has an exam on either，Monday or Tuesday or Wednesday so this。is the domain
    for the variable a and，this is the domain for the variable B。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个简化的例子，而不是拥有一大堆不同的类，我们只有两个类 a 和 B，每个类在星期一、星期二或星期三都有考试。所以这是变量 a 的域，这是变量
    B 的域。
- en: and now let's imagine we have these，constraints a not equal to Monday B not。equal
    to Tuesday B not equal to Monday a，not equal to B so those are the。constraints
    that we have on this，particular problem and what we can now，try to do is enforce
    No。consistency and node consistency just，means we make sure that all of the。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，我们有这些约束：a 不等于星期一，B 不等于星期二，B 不等于星期一，a 不等于 B。所以这些是我们在这个特定问题上的约束。现在我们可以尝试做的是强制节点一致性。节点一致性意味着我们确保所有节点都一致。
- en: values for any variables domain satisfy，its unary constraints and so we could。start
    by trying to make node a node，consistent like is it consistent does。every value
    inside of a domain satisfy，its unary constraints well initially。we'll see that
    Monday does not satisfy a，unary constraints because we have a。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 任何变量的域的值是否满足其一元约束？我们可以从尝试让节点 a 节点一致开始，检查它是否一致，a 的域内的每个值是否满足其一元约束。最初，我们会发现星期一并不满足
    a 的一元约束，因为有一个约束 a 不等于星期一，但星期一仍然在 a 的域中，因此这不是节点一致的。
- en: constraint a unary constraint here that，a is not equal to Monday but Monday
    is。still in a z-- domain and so this is，something that is not node consistent。because
    we have Monday in the domain but，this is not a valid value for this。particular
    node and so how do we make，this node consistent well to make the。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在域中有星期一，但这个值对于这个特定节点来说并不有效。那么我们如何让这个节点一致呢？为了使其与 B 不等于星期二的一元约束一致，我们将去掉 B
    域中的星期二，现在 B 的域只包含星期一和星期三。
- en: node node consistent what we'll do is，we'll just go ahead and remove Monday。from
    the AA's domain now a can only be，on Tuesday or Wednesday because we had。this
    constraint that said a is not equal，to Monday and at this point now a is。node
    consistent for each of the values，that a can take on Tuesday and Wednesday。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个值，a 可以在星期二和星期三之间取值，这样我们就会确保 a 是节点一致的。
- en: there is no constraint that is a unary，constraint that conflicts with that idea。there
    is no constraint that says that a，can't be Tuesday there's no unary。constraint
    that says that a cannot be on，Wednesday and so now we can turn our。attention to
    B B also has a domain，Monday Tuesday and Wednesday and we can。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何与这一想法相冲突的一元约束。没有约束说 a 不能在星期二，没有一元约束说 a 不能在星期三。因此，现在我们可以把注意力转向 B。B 的域也有星期一、星期二和星期三。
- en: begin to see whether those variables，satisfy the unary constraints as well。well
    here's a unary constraint B is not，equal to Tuesday and that does not。appear to
    be satisfied by this domain of，Monday Tuesday and Wednesday because。Tuesday this
    possible value that the，variable B could take on is not。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始看看这些变量是否也满足一元约束。这里有一个一元约束，B 不等于星期二，而这个约束在这个包含星期一、星期二和星期三的域中似乎并不满足。因为星期二是变量
    B 可能取的值之一。
- en: consistent with this unary constraint，that B is not equal to Tuesday so to。solve
    that problem we'll go ahead and，remove Tuesday from B's domain now B's。domain
    only contains Monday and，Wednesday but as it turns out there's。yet another unary
    constraint that we，placed on the variable B which is here B。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实证明，针对变量 B 我们还施加了另一个一元约束，即 B。
- en: is not equal to Monday and that means，that this value Monday inside of B's。domain
    is not consistent with B's unary，constraints because we have a constraint。that
    says the B cannot be Monday and so，we can remove Monday from B's domain and。now
    we've made it through all of the，unary constraints we've not yet。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于星期一，这意味着B的领域中这个值星期一与B的一元约束不一致，因为我们有一个约束表示B不能是星期一，因此我们可以将星期一从B的领域中移除，现在我们已经通过了所有的一元约束，但还没有。
- en: considered this constraint which is a，binary constraint but we've considered。all
    of the unary constraints all of the，constraints that，volved just a single variable
    and we've。made sure that every node is consistent，with those unary constraint
    so we can。say that now we have enforced node，consistency that for each of these。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑了这个约束，它是一个二元约束，但我们已考虑了所有的一元约束，所有仅涉及单个变量的约束，我们确保每个节点都与这些一元约束一致，因此我们可以说现在我们已强制执行节点一致性，对于这些每个节点。
- en: possible nodes we can pick any of these，values in the domain and there won't
    be。a unary constraint that is violated as a，result of it so node consistency is。fairly
    easy to enforce we just take each。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择这些可能的节点，领域中的值不会。因为作为结果的一个一元约束并未被违反，所以节点一致性相对容易强制执行，我们只需考虑每一个。
