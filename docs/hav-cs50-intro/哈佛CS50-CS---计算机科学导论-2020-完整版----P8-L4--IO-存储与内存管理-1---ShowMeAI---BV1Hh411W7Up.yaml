- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P8：L4- IO、存储与内存管理 1 - ShowMeAI - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P8：L4- IO、存储与内存管理 1 - ShowMeAI - BV1Hh411W7Up
- en: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_0.png)'
- en: it is cs50。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_2.png)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是cs50。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_2.png)
- en: it is cs50，and this is week four and for the past，several weeks we've had。training
    wheels of sorts on while using，this language known as c and those。training wheels
    have been in the form of，the cs50 library and you use this，library of course by。uh
    selecting and including cs50。h to top，your code and then if you think about。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是cs50，这是第四周，在过去的几周里，我们有了某种辅助轮，使用这种称为c的语言，而这些辅助轮的形式是cs50库，你当然通过选择和包含cs50.h在你的代码顶部来使用这个库，然后如果你考虑。
- en: how clang works you've been linking，that，has been automated for you up until
    now。using make today we'll transition from，last week's focus on，machines。and on
    the machines we now use to，implement these algorithms，all the more powerfully
    as we begin to。take off these training wheels and look，at what's really going
    on。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: clang的工作原理你一直在链接，直到现在这已经为你自动化了。今天我们将从上周对机器的关注转移。我们现在使用的机器来更强有力地实现这些算法，随着我们开始去掉这些辅助轮，看看真正发生了什么。
- en: underneath the hood of your computer and，as complicated as some aspects of c。have
    been as new as programming may very，well be to you，realize that there's not all
    that much。going on underneath the hood that we，need to understand，to now move
    onward and start solving far。more interesting and more sophisticated，and more
    fun problems we just need a few，we'll do this first。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计算机的内部，尽管某些c语言的方面很复杂。编程可能对你来说是全新的，但你会意识到在内部并没有太多事情。我们需要理解，以便继续前进并开始解决更有趣、更复杂、也更有趣的问题，我们只需要几个，首先做这个。
- en: by relearning how to count uh here for，instance is what we'll call the，grid
    before。and we can number recall all of the，bytes in your computer's memory we
    might。call this byte number 0 1 2 3 4 all the，way up to like byte 15，and so forth
    but it turns out when。talking about computers memories，uh computers and computer
    scientists and，decimal。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新学习如何计数，呃，比如说我们将称之为网格的东西。我们可以对你计算机内存中的所有字节进行编号，我们可以称之为字节编号0、1、2、3、4，一直到字节15，等等，但事实证明，在谈论计算机内存时，呃，计算机和计算机科学家以及十进制。
- en: they don't they definitely don't tend to，they，something called。hexadecimal hexadecimal
    is a different，base system that instead of using。10 digits or two digits uses
    16 instead，and so a computer scientist when，computer memory。would still do 0 1
    2 3 4 5 6 7 8 9，but after that instead of going onward，with decimal to say 10。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不会，他们绝对不倾向于，做一些叫做。十六进制的事情，十六进制是一个不同的基数系统，它不是使用10个数字或2个数字，而是使用16个，因此，当计算机科学家谈论计算机内存时，仍然会使用0、1、2、3、4、5、6、7、8、9，但在那之后，不是继续使用十进制到10。
- en: conventionally，would start using a few letters of the，alphabet and so in hexadecimal。this
    different base system base 16 you，start counting at zero still。you count up 2
    and through 9 but when，then go to，a b c d e，and f and the upside of this is that。within
    hexadecimal and that hex，implies 16 you have 16 total，individual digits 0 through
    9 and also。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会开始使用字母表中的几个字母，以十六进制的方式计数。这个不同的基数系统基数16，你仍然从零开始计数。你计数到2和9，但当你到达10时，就转向a、b、c、d、e和f，这样的好处是。在十六进制中，hex表示16，总共有16个独立的数字0到9和。
- en: now a through f so we don't have to，introduce second digits，just to count up
    as high as 16。we can。use individual digits 0 through f，and we can keep counting
    up further by，using multiple hexadecimal。digits but to get there let's introduce，this
    vocabulary so in binary of course，we use zeros and ones。uh in decimal of course
    we use zero，clear we're going to use。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是a到f，因此我们不需要引入第二个数字，只需计数到16。我们可以使用单个数字0到f，并且我们可以通过使用多个十六进制数字继续计数，但为了实现这一点，让我们引入这个词汇，所以在二进制中，当然我们使用零和一。呃，在十进制中，我们当然使用零，清楚地说我们将使用。
- en: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_4.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_4.png)'
- en: 16，and it's just a convention that we use a，through f we could have used any
    other。six symbols but these are what humans，have chosen so hexadecimal works quite。similarly
    to our familiar decimal system，and it's even familiar to now what you。know as
    the binary system as follows，let's consider a two-digit value using。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 16，这只是我们使用的约定，通过f我们本可以使用任何其他六个符号，但这些是人类所选择的，因此十六进制的工作原理与我们熟悉的十进制系统非常相似，甚至对现在你所知道的二进制系统也相当熟悉，如下所示，让我们考虑一个使用的两位数值。
- en: hexadecimal instead of decimal and，instead of binary。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_6.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制而不是十进制，也不是二进制。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_6.png)
- en: well just like in the world of decimal，we used uh base，10 or in the world of
    binary we used。base 2 we're just going to use now，base 16 ergo hexadecimal so
    this is 16。to the first this is 16 to the，first，and of course if we multiply that
    out。it's just the ones column and now the，16s column，and so if you want to count
    up in，usual。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在十进制世界中，我们使用了基数10，或者在二进制世界中我们使用了基数2，现在我们将使用基数16，因此十六进制就是16。这是16的第一，当然如果我们把它乘开。它只是个位列，现在是十六位列，因此如果你想以通常的方式数。
- en: then zero one zero two zero three zero，four zero five zero six，*****，things
    get interesting。now you don't go to one zero because，that would be incorrect，like
    16，we want。after the number we know is 9 we now，count up to a，again，but just like
    in the decimal system when。you count up to like 99 you have to，start carrying
    the one，same thing here if you want to count。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是零一零二零三零，四零五零六，*****，事情变得有趣了。现在你不去到一零，因为那是错误的，就像16一样，我们想要。在我们知道的数字9之后，我们现在再数到a，然而，就像在十进制系统中，当你数到99时，你必须开始进位，这里也是同样的情况，如果你想计数。
- en: past f you carry the one，and so now to represent one value，greater than f，it's
    not 10。in hexadecimal it is 1 0。16 times 1，gives us 16，1 times 0 gives us 0 and
    of course that，is 16。so we will no longer introduce more and，more base systems
    but let me stipulate。that just by using these columns that，presumably，can you
    implement any base system now it。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在f之后你进位，所以现在要表示一个大于f的值，不是10。在十六进制中是1 0。16乘1，给我们16，1乘0给我们0，当然那就是16。所以我们不再引入更多的基数系统，但让我声明。仅仅通过使用这些列，假设，你现在可以实现任何基数系统。
- en: just so happens that in the world of，computers and today in the world of，memory
    and soon also files。it's just going to be very conventional，to be able to recognize。and
    use hexadecimal and in fact there's，a reason humans like hexadecimal or at。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_8.png)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是在计算机的世界中，今天在内存的世界里，马上也会在文件中。能够识别和使用十六进制是非常常见的，实际上人类喜欢十六进制是有原因的。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_8.png)
- en: least some humans computer scientists，recall that if we count up as high as。ff
    in this case we would still do the，same math so，16 times 15 plus 1 times 15，course。240
    plus 15 or 255 and i did that pretty，quickly but that's just the sort of，column。by
    the value that's in it where again，each of these f's，digit，but recall that we've
    seen 255 before。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 至少一些人类计算机科学家，如果我们数到这个情况下的ff，我们仍然会做同样的数学运算，即16乘15加上1乘15，当然。240加15或255，我做得很快，但这就是那种列。根据它里面的值，再次，每一个f都是数字，但回忆一下我们以前见过255。
- en: back when we talked about binary a few，weeks ago 255 also happen to be，bits。using
    binary and so the reason that，computer scientists tend to like。hexadecimal is
    that you know what，in eight bits there's actually two pairs，right。if we sort of
    scooch these things over，it turns out，represent。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们几周前讨论二进制时，255恰好是位。使用二进制，因此计算机科学家倾向于喜欢十六进制的原因是，你知道吗，在八位中实际上有两个对。如果我们稍微移动这些东西，结果是，表示。
- en: 16 possible values it's a perfect system，for representing four bits at a time。after
    all if you've got four bits here，each of which can be a zero or one，that's two
    times。two times two times two possible values，for each of those or 16 total values。which
    is to say that in the world of，computers if you ever want to talk in，units of
    four bits。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 16个可能的值，这是一个完美的系统，用来一次表示四个位。毕竟，如果你有四个位，每个位可以是零或一，那就是两次。两次两次两次两次可能的值，或者说16个总值。这就是说，在计算机的世界里，如果你想用四个位的单位来交流。
- en: it's wonderfully convenient to use，hexadecimal instead，only because conveniently
    one。hexadecimal digit，happens to be equivalent to four binary，zero。all the way
    up through one one one one，the human convention，because of that convenience now
    some of。before in fact，recall our discussion in week zero of，rgb where we discussed
    the。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制是非常方便的，因为一个十六进制数字恰好等于四个二进制零。一直到一一一一，这是人类的约定，因此由于这种便利性，现在一些人。实际上，回忆一下我们在零周的讨论，关于RGB，我们讨论了。
- en: uh representation of colors using some，amount of red green and blue。and at the
    time we used this example we，took our example out of context。instead of using
    hi as a string of text，we reinterpreted，72 73 and 33 as a sequence of。colors how
    much red do you want how much，green do you want how much blue do you。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 呃，使用一些红色、绿色和蓝色的组合来表示颜色。在我们使用这个例子的时候，我们把例子脱离了上下文。我们不是用hi作为一串文本，而是重新解读了72、73和33作为颜色序列，你想要多少红色，多少绿色，多少蓝色。
- en: want and that's fine it's perfectly fine，of decimal，but computer scientists
    tend not to do。it that way in the context of colors and，in the context of memory，instead
    they tend to use something。called hexadecimal，and hexadecimal here would actually
    just，have you change these values from 72。73 33 to the equivalent，hexadecimal
    representation and we won't，just stipulate，thing，as 484921。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的是完全可以的，十进制没问题，但计算机科学家们在颜色和内存的上下文中倾向于使用称为十六进制的东西，而这里的十六进制实际上只需将这些值从72、73、33转换为相应的十六进制表示，我们不会仅仅规定为484921。
- en: in hexadecimal now obviously if you，glance at these three numbers it's not。at
    all obvious if you're looking at，hexadecimal digits or，decimal digits because
    they do use the。same subset zeros through nines，and so a convention two in the
    computing。world is anytime you represent，hexadecimal digits，with zero，x and there's
    no mathematical meaning to。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制中，显然如果你瞥一眼这三个数字，很明显你并不能确定这些是十六进制数字还是十进制数字，因为它们使用相同的子集0到9。因此，计算机世界中的一个约定是，每当你表示十六进制数字时，使用0x，并且这没有数学意义。
- en: the zero or the x，it's just a prefix you put there to make，clear to the viewer。that
    these are hexadecimal digits even，if they might otherwise look like。decimal digits
    so where are we going，with this well those of you who might。have experimented
    in the past with，making your own web pages and making，them colorful。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的零或x只是一个前缀，用于让观众明确这些是十六进制数字，即使它们看起来像十进制数字。那么，我们要去哪里呢？那些曾经尝试制作自己网页并让其多彩的人。
- en: or those of you who are artists and have，used programs like photoshop。odds are
    you've seen these codes before，in fact here are a few screenshots of，photoshop
    itself。if you click on a color in photoshop and，you pull up this window。you can
    change the color that you're，drawing on the screen to be any of the。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些艺术家们，如果你们使用过像photoshop这样的程序，那么你们很可能见过这些代码。事实上，这里有一些photoshop本身的截图。如果你在photoshop中点击一个颜色，弹出的窗口里，你可以将你在屏幕上绘制的颜色更改为任何颜色。
- en: colors of the rainbow but more arcanely，if you look down here，you can actually
    see these hexadecimal。codes because it's become human，convention over the years，to
    use hexadecimal to represent。different amounts of red green and blue，so if you
    have no red no green no blue。otherwise represented as zero zero 0 0，0 0 well that's
    going to give you the，color we know here as。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 彩虹的颜色更加深奥，如果你看看下面，你可以看到这些十六进制代码，因为多年来，人类已经习惯使用十六进制来表示不同数量的红色、绿色和蓝色。所以如果你没有红色、没有绿色、没有蓝色，也就是表示为000000，那么这将给你我们所知道的颜色。
- en: black it's sort of the absence of every，of any wavelengths of light there。if
    by contrast though you change all of，value，which again is f the range in，hexadecimal
    is 0。through f otherwise in decimal being 0，through 15，well with ff fff that's
    like a lot of。red or a lot of green a lot of blue and，light，you get the color
    we see here as white。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色可以说是任何波长光的缺失。如果你把所有的值改变一下，再说一遍，十六进制范围内是0到f，十进制范围是0到15，ff或fff就代表了大量的红色、绿色或蓝色，最终得到的颜色我们称之为白色。
- en: and you can imagine now，combining different amounts of red or，green or blue
    so for instance。in hexadecimal ff000 is the color we，know as red，green，and finally
    zero zero zero zero ff is。the color we know as blue because again，the system that，always
    use。is indeed this system of rgb for red，green and blue so we introduced this。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以想象，结合不同数量的红色、绿色或蓝色。例如，在十六进制中，ff000是我们所知道的红色，绿色，最后00ff是我们所知道的蓝色，因为我们一直使用的系统确实是rgb系统。
- en: here not because you have to start，thinking any differently because again，as
    week zero。but you're going to start seeing numbers，in examples and programs as
    just。appearing in hexadecimal by convention，as opposed to actually being uh，interpreted
    as decimal。so if we consider now our computer's，memory we'll now start thinking
    of this。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不是因为你必须以不同的方式思考，因为在第零周。但是你会开始在示例和程序中看到数字以十六进制出现，而不是被解释为十进制。因此，如果我们现在考虑我们电脑的内存，我们将开始这样思考。
- en: whole canvas of memory all of these，bytes inside of our computer's memory。as
    being numerable uh as enumerable as，like zero one two，all the way through f and
    then if we。keep counting we can go to one zero，one one one two one three one four
    one，nine。one a one b one c one d，and so forth and it's fine if it's not。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的内存画布中，所有这些字节在我们电脑的内存中。作为可枚举的，比如零、一个、二，一直到f，如果我们继续计数，我们可以到`one zero`、`one
    one`、`one two`、`one three`、`one four`、`one nine`、`one a`、`one b`、`one c`、`one
    d`，依此类推，没关系，如果没有。
- en: nearly that obvious as you look at these，things what the decimal equivalents
    are。that's not a problem it's just a，different way of thinking about，the locations
    in this case of a。computer's memory or，the representation of one color or，another
    all right。well let's now use this as an example of，uh an opportunity rather to
    consider。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些东西时，十进制等值是什么并不明显。这没问题，这只是一种不同的思考方式，关于计算机内存中位置的表示，或者一种颜色的表示。好了，现在让我们用这个作为一个机会来考虑。
- en: what's actually being stored in our，computer's memory and to be clear i'll。start
    prefixing all of these，memory addresses so to speak with 0x，just to make clear
    that we're now。ones，so here's a simple line of code out of，context we would need
    to actually put。this in main or some other，program to actually do anything with
    it。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的电脑内存中存储的内容是什么？为了明确起见，我会给所有这些内存地址加上前缀0x，以表明我们现在正在讨论的内容。这里有一行简单的代码，脱离上下文，我们实际上需要把它放在`main`或者其他程序中才能做任何事情。
- en: but we've seen this before many times，instance，its type，and then perhaps even
    assign it a value。well what's actually。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_10.png)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们之前见过很多次，例如，它的类型，然后甚至可能给它赋值。那么实际上存储在我们电脑内存中的是什么呢？![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_10.png)
- en: in our computer，well let's go ah**d and whip this thing，up in a actual program
    let me create a。file called address。c，because i want to start experimenting。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_12.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电脑中，好的，让我们继续把这个东西在一个实际程序中实现，让我创建一个叫做`address.c`的文件，因为我想开始实验。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_12.png)
- en: memory，i'm going to go ah**d and include，standardio。h i'm going to give myself。int
    main void and down here i'm going to，variable，int n equals 50 and then i'm going
    to go。ahead and print out，value of，n so nothing interesting there nothing。too
    complicated i'm going to go ah**d，and make address，and then i'm going to go ah**d
    and do。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 内存，我将继续包含`stdio.h`，我将给自己定义`int main void`，在这里我将定义一个变量，`int n equals 50`，然后我将打印出`n`的值，因此没什么有趣的内容，没什么太复杂的。我将继续创建地址，然后我将继续执行。
- en: week one，we should hopefully see just the number，50。but today we're going to
    give you。some more tools，with which you can actually start poking，around your
    computer's memory but let's。first consider this line of code in the，context of
    your computer's hardware so。if you're writing a program with a line，of code like
    this that，n needs to be somewhere in your。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一周，我们希望能看到数字50。但今天我们将为你提供一些更多的工具，以便你可以开始探查电脑的内存。不过首先，让我们考虑这一行代码在电脑硬件的背景下。因此，如果你正在写一个包含这一行代码的程序，`n`需要在你的。
- en: put somewhere，in your computer's memory so if we again，consider this to be。just
    part of our computer's memory a few，variable，deliberately drawn。n as taking up
    four bytes four squ*res，because recall that an integer。typically at least on cs50
    ide and，modern systems，tends to be four bytes so i made sure to。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将某个内容放在你电脑的内存中，因此如果我们再次考虑这是我们电脑内存的一部分，几个变量被故意画成四个字节，四个方块，因为记住一个整数通常在`cs50 ide`和现代系统上，往往是四个字节，所以我确保。
- en: have it fill，four complete boxes and then value might，be 50 that's actually
    stored there。well it turns out that within your，computer's memory again，there
    are these addresses that are。implicitly there so even though yes we，can refer
    to this variable。n based on the variable name i gave it，in my code，surely this
    variable exists at a。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让它填充四个完整的方框，那么值可能是50，这实际上存储在那里。事实证明，在你的电脑内存中，还有这些隐含存在的地址。因此，即使是的，我们可以根据我在代码中给它的变量名来引用这个变量`n`，这变量肯定存在于一个。
- en: specific location in memory i don't know，off hand where it is。but let me just
    propose that maybe it's，at location 0x12345678。just an arbitrary address i have
    no idea，in actuality where it is。but it certainly does have an address，because
    every one of these squ*res，address，forth。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的特定位置我不知道它具体在哪里，但让我假设也许它在位置0x12345678。这只是一个任意地址，我实际上不知道它在哪里，但它确实有一个地址，因为这些方框代表逻辑和。
- en: maybe the 50 ended up at memory address，cool about，this，no pun intended so let
    me go ah**d and。modify this program，and introduce a little bit of new syntax，that'll
    allow us to start poking around。the inside of your computer's memory so，we can
    actually see，what's going on underneath so i'm going。do this，instead i'm going
    to go ah**d and say，value，n which of course is 50。 let me see just。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 也许50最终位于内存地址，这个有趣的是，完全没有双关的意思。所以让我去ah**d并修改这个程序，引入一些新的语法，让我们能够开始探索计算机内存的内部，这样我们就可以真正看到下面发生了什么。因此，我将要这样做，取而代之的是，我将去ah**d并说，值n，当然是50。让我看看。
- en: out of curiosity what，is the actual address of n and to do。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_14.png)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，n的实际地址是什么？要做到这一点。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_14.png)
- en: that today we're going to introduce one，new piece of syntax，which happens to
    be this here there's。two new operators today in c，the first is an ampersand which
    does not。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_16.png)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们将介绍一条新的语法，它就是这里的这个。今天C语言中有两个新的运算符，第一个是&符号，它的作用是。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_16.png)
- en: represent a logical and，recall a couple of weeks ago we did see，expressions
    this。and that you use two ampersands it's an，unfortunate coincidence that an，ampersand。solo
    like this will mean something，different today specifically this。ampersand is going
    to be our address of，operator by simply prefixing any，variable name。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记得几周前我们看到了表达式。你使用两个&符号，不幸的是，单独的&符号今天会意味着不同的东西，具体来说这个&符号将成为我们的地址运算符，只需在任何变量名之前加上前缀。
- en: with an ampersand we can tell c please，tell me what address，this variable is
    stored in and this star。also has another，meaning in today's context when you use，this
    asterisk。you can actually tell your program to，look inside，of a particular memory
    address so the。ampersand tells you what address。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用&符号，我们可以告诉C，请告诉我这个变量存储在什么地址，以及这个星号在今天的上下文中还有另一层含义。当你使用这个星号时，你实际上可以告诉你的程序去查看特定内存地址的内容，因此&符号告诉你什么是地址。
- en: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_18.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_18.png)'
- en: a variable is at the star operator，operator，means go to the following address
    so。they sort of are reverse operations one，figures out the address，this，my。n in
    my program here to ampersand n，n，but the address of n and now how do i。print out
    an address well，it is just a number but actually printf，supports a different。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是星号运算符，运算符意味着去到下一个地址。因此，它们是一种反向操作，一个是确定地址，这里是我的程序中的n，n的&符号是n的地址。那么我如何打印出地址呢？这只是一个数字，但实际上printf支持不同的格式。
- en: format code for for addresses you can do，percent p，for reasons we'll soon see
    that says to。print out the address of this variable，so i'm going to go ah**d and
    make。address now after only to making，two changes to this file everything。seems
    to compile okay now i'm going to，go ah**d and run address，program，variable，fd80792f7c。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 地址的格式代码，你可以使用%p，出于我们将要看到的原因，这表示打印出这个变量的地址，因此我要去ah**d并创建地址。经过仅仅对这个文件做两处修改，一切似乎都能正常编译。现在我要去ah**d并运行地址程序，变量fd80792f7c。
- en: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_20.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_20.png)'
- en: fd80792f7c，now is that useful not in practice，necessarily we're going to。make
    this become useful by leveraging，these addresses but the specific address，is not
    interesting。i'm glancing at this number i have no，idea what that number is in
    decimal i。would have to do the math or frankly，just google a converter and do
    it for me。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: fd80792f7c，现在这有用吗？在实践中并不一定，我们将通过利用这些地址使其变得有用，但具体地址并不重要。我瞥了一眼这个数字，我不知道这个数字在十进制中是什么，我需要做一些数学运算，或者坦率地说，直接去谷歌找个转换器来帮我。
- en: so again that's not the interesting part，the fact that this is an hexadecimal
    is，to，and again。we want we won't want to do this，necessarily but just to be clear
    that。one of these operators the ampersand，gets the address and the star operator。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_22.png)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次强调，这并不是有趣的部分，事实上这是十六进制，且再一次。我们并不一定想要这样做，但为了清楚起见，这些运算符之一&符号获取地址，而星号运算符。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_22.png)
- en: goes to an address，we can actually undo the effects of，these things for instance。if
    i print out now not ampersand n，but just out of curiosity star ampersand。n i can
    kind of undo the effects of this，operator ampersand n。is going to say what is
    the address of n，star ampersand n，is going to say go to that address so。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一个地址，我们实际上可以撤销这些东西的影响，例如，如果我现在打印出，不是&n，而只是出于好奇的*星号&n*，我可以在某种程度上撤销这个&n的效果。它会告诉我n的地址，而*星号&n*会告诉我去那个地址。
- en: this is kind of a pointless exercise，because if i just want what's in，began。but
    again just as an intellectual，exercise if i prefix，n with the address of operator
    and then。use the asterisk，and say go to that address it's the same，exact thing
    as just printing n itself so。integer，instead of percent p let me go ah**d and，make
    address now。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点无意义的练习，因为如果我只想要*began*中的内容。但再说一次，作为一种智力练习，如果我用地址运算符给n加上前缀，然后使用星号，去那个地址，这和直接打印n本身是完全一样的。所以，整数，不是%p，让我去做**d**并现在获取地址。
- en: seems to compile okay and run address，and voila we're back at the 50。start to
    feel。realize that these operators at the end，of the day are relatively，simple
    in what they do and if you。understand that one just kind of undoes，build up，some
    pretty interesting programs with。them and we're going to do so by，leveraging a
    special type of variable。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编译似乎没问题并运行地址，瞧，我们回到了50。开始感受到。意识到这些运算符在一天结束时是相对简单的，如果你理解一个只是撤销构建的，你可以用它们构建一些相当有趣的程序，我们将通过利用一种特殊类型的变量来做到这一点。
- en: a variable called a pointer and there's，that p，in percent p a pointer is a variable。that
    contains the address，of some other value so we've seen，integers before we've seen。floats
    and chars and strings and other，types as well，pointers now are just a different
    type。of variable，you can have，pointers to integers pointers to chars。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为指针的变量，p在%p中，指针是一个变量，它包含某个其他值的地址。我们之前见过整数，见过浮点数、字符和字符串及其他类型，现在指针只是另一种变量。你可以有指向整数的指针，指向字符的指针。
- en: pointers to bools or any other data type，a pointer references the specific type，of
    the value。that it actually is referring to so，let's see this more concretely let
    me go。back now to my program here，and let me introduce another variable，here instead
    of。immediately printing out something like，n uh，let me go ah**d and introduce
    a second。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指向布尔值或任何其他数据类型的指针，指针引用的是它实际所指向值的特定类型。因此，让我们更具体地看看，让我回到我的程序这里，并引入另一个变量，而不是立即打印出像n这样的东西，呃，让我去做**d**并引入第二个。
- en: variable that is of type，int star and this i will admit is，probably the most
    confusing piece of c。syntax that we'll in general see just，because my god star，is
    now used for multiplication for going。variable，this is arguably not the best design，decision
    but it was made decades ago so。this is what we have，but if i do n star p equals
    ampersand，n now what i can do down here。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是类型为*int star*，我承认这可能是我们在C语言中见到的最混乱的语法。因为天哪，星号现在被用作乘法运算符。这个设计决定可以说不是最好的选择，但几十年前做出的决定就是这样。所以，这就是我们所拥有的，但是如果我现在做*n
    star p*等于&n，那么我可以在这里做些什么。
- en: is print out the address of n by，temporarily storing it，in a variable so i'm
    not doing anything。new just yet i'm still declaring on line，five an integer called
    n，on line 6。is that i'm introducing a new type of，variable this type of variable
    is known。as a pointer a pointer again is just a，variable that stores the address
    of，weird。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出n的地址，通过暂时将其存储在一个变量中，因此我现在还没有做任何新的事情。我在第5行仍然声明一个名为n的整数，第6行是我引入了一种新的变量类型，这种变量被称为指针。指针就是存储地址的变量。
- en: for declaring a pointer to an integer is，literally say，int because that's the
    type you're。pointing to，star and then the name of the variable，you want to create
    and i could call this，succinct。and again on the right hand side of the，equal sign
    is the same operator as，the address of n。it's just ampersand n and so we can，store
    that address now，somewhere longer term before i just，thing。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个指向整数的指针实际上是说，int，因为这是你要指向的类型，星号，然后是你想要创建的变量名，我可以称之为*succinct*。再次，在等号右侧是与n地址相同的运算符。它只是&n，因此我们可以将这个地址存储在某个地方，以便在较长的时间内使用。
- en: now i'm temporarily on line six storing，that address in a new variable。called
    p and its type is technically，so it would be，incorrect to say int p equals ampersand。n
    and indeed our compiler clang won't，like that it won't let you compile the，code
    most likely。and so instead i do instar p to make，clear that i know what i'm doing。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我暂时在第六行存储，那个地址在一个新变量中。叫做p，其类型是技术上说，因此说int p = &n是不正确的，实际上我们的编译器clang不会接受，它很可能不会让你编译代码。因此我会用`*p`来明确我知道自己在做什么。
- en: i am storing the address of an int not，and，save this recompile with make address。and
    notice i changed one line of code，two earlier i went back to percent p。to print
    a pointer that is an address，and i'm printing out the value of p no，longer the
    value of n。there's，that cryptic address and these addresses，on what's going on。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在存储一个整数的地址，不，保存这个重新编译的地址。注意我更改了一行代码，之前我返回到`%p`。打印一个指向地址的指针，我正在打印p的值，而不再是n的值。那是神秘的地址，这些地址，反映了发生了什么。
- en: inside of your program or other things，on the system these addresses might be，different
    each time。and that's to be expected and not，something to be relied on but it's。clearly
    some random cryptic address，similar to my arbitrary ox one two three。four five
    six seven eight，before but now let's just undo this，operation just so we can come
    full。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序或系统的其他地方，这些地址每次可能会不同。这是可以预期的，不是值得依赖的，但这显然是某个随机的神秘地址，类似于我任意的`0x12345678`。但是现在让我们撤销这个操作，以便我们可以完整地结束。
- en: circle here，let me now propose how i can print out，the value of n and let me
    call on，on line 7。is no longer to print the address of n，but to print n itself
    using p。i'm going to go ah**d and change，i，and a shorthand notation would obviously，be
    just print n。but suppose i don't want to print n for，this exercise，how can i now
    print the value。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里圈出，让我现在提出如何打印n的值，让我请到，第7行。不再打印n的地址，而是使用p打印n本身。我将去改成`d`并更改，我的简写符号显然就是打印n。但是假设我不想在这个练习中打印n，我现在该如何打印这个值。
- en: in n by referring it referring to it by，way of p，what should i literally type
    as printf。second argument，to print out the value of n，by using this new variable
    p in some way。any thoughts here how can i print out，brian any brave volunteers，yeah
    let's call on joshua。i believe if you use the ampersand，i believe if you use the
    ampersand，before the p。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在n中通过p来引用它，我应该字面上输入什么作为printf的第二个参数，来以某种方式打印n的值。这里有什么想法，我该如何打印出来，布赖恩，勇敢的志愿者，嗯，让我们请乔舒亚。
    我相信如果你在p之前使用&符号，我相信如果你在p之前使用&符号。
- en: you will probably do it okay ampersand p，let me go ah**d and try that let's
    try，ampersand p。to print out this value so ampersand p，i'm going to save the file，and
    it doesn't。seem to be the case notice that i'm，getting an error it's a little
    cryptic。format specifies type int but the，argument has type in，star star more
    on that another time so，take。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会没问题地使用& p，让我去尝试一下，让我们尝试& p。打印这个值，所以& p，我将保存文件，但似乎并不是这样。注意我得到了一个错误，它有点晦涩。格式指定类型int，但参数类型是`int
    **`，关于这一点以后再说，所以要注意。
- en: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_24.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_24.png)'
- en: one other suggestion because the，something，but p is already an address so joshua。what
    you technically proposed was，get me the address of the address and。that's not
    the direction we want to go，we want to go to what is at that address。yeah so i
    had a little trouble hearing，yeah so i had a little trouble hearing。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个建议，因为，某些东西，但是p已经是一个地址了，所以乔舒亚。你技术上提议的是，给我地址的地址。那不是我们想走的方向，我们想去看那个地址里的内容。是的，所以我有一点困难听到，
    是的，所以我有一点困难听到。
- en: you but i think if we instead use not，the ampersand operator but the star。operator
    that's going to be indeed the，means，go to the value in p and if the value in。p
    is an address i think let's try this，make address yep let that compiled okay。this
    time now if i do dot slash address，hopefully i will now see indeed，the number
    50。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我认为如果我们使用不是&运算符而是*运算符，那确实会去获取p中的值。如果p中的值是一个地址，我想让我们尝试一下，编译地址，是的，让它编译通过。现在如果我执行`./address`，希望我能确实看到数字50。
- en: so again we don't seem to，have made any fundamental progress at，the end of the
    day i'm still just。printing out the value of n，but we've introduced this new primitive。this
    new puzzle piece if you will，that allows you programmatically to。figure out the
    address of something in，the computer's memory，and to actually go to that address
    and。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再说一次，到头来我们似乎并没有取得任何根本性的进展，我仍然只是打印出 n 的值，但我们引入了这个新的原语。这块新的拼图，如果你愿意的话，允许你以编程方式找出计算机内存中某个东西的地址，并实际上到达那个地址。
- en: we'll soon see，it as well，but let's come back to picture a，pictorial representation
    of this and。consider what it is we just did in the，context now of this code。so
    inside of my main the two interesting，lines of code really，were these two lines
    first before we。made sophia's edition and actually，dereferenced p and printed
    it out with。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快也会看到它，但让我们回到一个图形表示，并考虑一下我们在这段代码的上下文中刚刚做了什么。所以在我的 main 中，真正有趣的两行代码就是这两行，首先在我们进行
    Sophia 的编辑之前，实际上对 p 解引用并打印出来。
- en: printf but let's consider for a moment，what these values now look like in a。computer's
    memory and again，the syntax is a little cryptic because。we now have a star and
    an ampersand，but again that just means now we get to，computer's memory。so for
    instance here's a grid of memory，inside of my computer and maybe。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: printf，但让我们暂时考虑一下，这些值在计算机内存中看起来是什么样的。语法有点神秘，因为我们现在有一个星号和一个和号，但这只是意味着现在我们可以访问计算机的内存。因此，例如，这里是我计算机内存的一个网格，也许。
- en: for instance the 50 and the n end up，down there they could end up anywhere。not
    even pictured on the screen here，they end up somewhere in the computer's，memory
    for our purposes。thus far but it technically lives in an，address and let me simplify
    the address。just so it's quicker to say，this 50 now stored in the variable n。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，50 和 n 最终在下方，它们可以出现在任何地方，甚至在这里的屏幕上都没有显示，它们出现在计算机的内存中。到目前为止，为我们的目的而言，但它技术上确实存在于一个地址中。让我简化这个地址，以便更快地表达，现在这个
    50 存储在变量 n 中。
- en: maybe it actually lives at address ox123，i have no idea where it is but we've。clearly
    seen that it can live in，what about，p p is technically a variable itself。it's
    a variable that stores the address，of something else but it's still a。variable
    which means when you declare p，take up，some bytes of memory on the screen and。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 也许它确实存在于地址 ox123，我不知道它在哪里，但我们已经明确看到它可以存在于，p。p 技术上是一个变量。它是一个存储其他东西地址的变量，但它仍然是一个变量，这意味着当你声明
    p 时，占用了屏幕上的一些内存字节。
- en: so let me go ah**d and propose，now p，is deliberately drawn to be longer here。i'm
    consuming eight total bytes this，time because it turns out on modern，computer
    systems。including cs50 ide pointers，tend to take up eight bytes so not one。not
    four but eight bytes so i've simply，drawn it to be bigger，so what is actually
    stored in the。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我继续提议，现在 p 被故意画得更长。我这次消耗了总共八个字节，因为在现代计算机系统中，包括 CS50 IDE，指针往往占用八个字节，所以不是一个，也不是四个，而是八个字节，因此我只是将它画得更大。那么在变量
    p 中实际存储了什么呢？
- en: variable p，well it turns out that again it's just，storing the address。of some
    value so if the integer n，which itself is storing 50 is at，location ox123。and
    pointer p is being assigned that，address it's just like saying well，stored in
    this variable p。is literally just a number represented，here in hexadecimal notation。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，它只是存储某个值的地址。所以如果整数 n 本身存储了 50，并且位于位置 ox123，而指针 p 被分配到那个地址，这就像是在说，存储在变量
    p 中的实际上只是一个以十六进制表示的数字。
- en: ox123 so that's all that's going on，inside the computer's memory with those。two
    lines of code like there's nothing，fundamentally new except the fact that。we have
    new syntax with which to refer，to these addresses explicitly。this is n down here
    this is p up here，and the value of p just happens to be。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ox123，因此在计算机内存中就发生了这些事情，这两行代码没有什么根本性的变化，除了我们引入了一种新的语法来显式地引用这些地址。这里是 n，这里是 p，而
    p 的值恰好是。
- en: an address now i keep saying that，these addresses are a little cryptic。they're
    a little arbitrary and they are，and honestly it is，rarely if ever going to be
    enlightening。to know as a human，what address this integer n is actually，at who
    cares if it's at ox123 or ox456。generally we don't and so computer，memory，tend
    not to talk at these low level。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个地址，我一直在说，这些地址有点神秘。它们有点任意，而且老实说，通常不会让人感到启发。作为一个人，知道这个整数 n 实际上处于哪个地址，谁在乎它是在
    ox123 还是 ox456。通常我们并不关心，因此计算机内存往往不会在这么低的层面上进行交流。
- en: details in terms of actual numbers，instead they tend to simplify the，picture
    sort of abstract away。all of the other memory which frankly is，not relevant to
    the discussion。thus far and just say you know what i，know that p，is storing an
    address and that address。happens to be that of 50 down here，but i really don't
    care in my everyday。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 具体数字的细节，相反，它们往往简化了画面，抽象掉了所有其他内存，这实际上与讨论无关。因此我就说，你知道的，我知道 p 存储着一个地址，而那个地址恰好是下面的
    50，但我在日常生活中并不关心。
- en: programming life what these specific，addresses are so you know what。let's just
    abstract it away as an arrow，and again abstraction，is all about simplifying lower
    level。understand，but you don't necessarily need to keep，thinking about you don't
    need to keep。think at this level，so we might as well draw a pointer，pictorially，as
    pointing at some value and。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编程生活中，这些具体的地址是什么，所以你知道的。我们就把它抽象成一个箭头，再一次，抽象就是简化低层次的理解，但你不一定需要持续思考这个层面，所以我们不妨以图形方式绘制一个指针，指向某个值和。
- en: irrespective of what the actual address，is and so this is very much the case
    in，conventions。at first glance，such that we may very well be using，these same。mechanisms
    in our everyday lives so for，instance if you happen to have a mailbox。on the street
    on your home or，down in the basement of harvard science。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不管实际地址是什么，所以在约定中确实如此。乍一看，我们可能会在日常生活中使用这些相同的机制，例如如果你在街上、家里，或哈佛科学楼的地下室有一个邮箱。
- en: center or when on campus it may very，well look like something like this at，least
    more residentially。and suppose that this mailbox here is，representing in this
    case。p in the story it's storing a pointer，that is the address of something else。well
    if there's a whole bunch of other，mailboxes on the street，well we can put anything
    we want in。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在校园中心，或者在校园内，它可能看起来像这样，至少更像是住宅。如果这个邮箱代表故事中的 p，它存储的是一个指针，也就是某个其他事物的地址。如果街上有很多其他的邮箱，我们可以随意放入任何东西。
- en: these mailboxes we can put，postcards letters packages even and just，as in the
    real world。can we do the same in the virtual i can，store chars or integers。or
    other things including addresses so，for instance brian，i think you have your own
    mailbox。somewhere else and brian of course has a，mailbox that itself has a unique
    address。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些邮箱里我们可以放明信片、信件、包裹，就像在现实世界中一样。我们能否在虚拟中做同样的事？我可以存储字符、整数或其他东西，包括地址。例如，布莱恩，我想你在别处有自己的邮箱，当然布莱恩也有一个邮箱，其本身有一个唯一的地址。
- en: so brian for instance what happens to be，the unique address，of the mailbox on
    your street there yeah。so here's my mailbox it's labeled n and，its address is
    over here。the address of my mailbox appears to be，ox123，yeah so my mailbox 2 has
    an address。frankly again i don't really care，about it so i've not even put it
    on the。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么布莱恩，实际上你街上邮箱的唯一地址是什么？是的，这里是我的邮箱，上面标有 n，它的地址在这里。我的邮箱的地址似乎是 ox123，是的，所以我的邮箱
    2 也有一个地址。坦白说，我并不在乎，所以我甚至没把它写上。
- en: mailbox here but if my mailbox，represents p，a pointer and brian's mailbox represents，n
    in integer。well it should mean that if i look，inside the contents of my pointer，and
    i see the value ox123。that is now my clue a breadcrumb of，sorts that can now let
    me go look inside。of brian's mailbox and brian if you，wouldn't mind doing that
    for us。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的邮箱，如果我的邮箱代表 p，一个指针，而布莱恩的邮箱代表整数 n。那么这应该意味着，如果我查看我的指针的内容，看到值是 ox123，那就是我的线索，一种面包屑，让我去查看布莱恩的邮箱，布莱恩，如果你不介意为我们做这件事。
- en: what do you have at that address and if，i look in my mailbox at addressox123
    i，have the number 50。inside of this mailbox yeah indeed so in，this case he happens
    to be storing an，again。we don't typically care about these，specific addresses
    once you understand。the metaphor really we can do something，mailbox，as storing
    a value that's like pointing。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在那个地址你有什么？如果我在地址 ox123 的邮箱里查看，我里面有数字 50。确实是这样，所以在这种情况下，它恰好存储的是，我们通常并不关心这些具体地址，一旦你理解了隐喻，我们可以将邮箱视为存储一个值，这就像是指向。
- en: at brian's mailbox it's some kind of，indirection drawn there，pictorially as
    an arrow here is a silly。uh foam finger，or if you prefer a foam，yale finger pointing
    instead at brian's。mailbox just as a sort of breadcrumb，leading us to some other
    value。on the screen so when we talk today and，beyond about addresses。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在布莱恩的邮箱那里，有某种间接性，以箭头图形化表示。这里有一个傻乎乎的泡沫手指，或者如果你愿意，可以是一个泡沫耶鲁手指，指向布莱恩的邮箱，就像是一种面包屑，引导我们去找屏幕上的某个其他值。因此，当我们今天以及今后谈论地址时。
- en: that's all we're talking about we humans，addresses for，eons now to uniquely
    identify our homes。or businesses or the like，computers do the exact same thing
    at a，memory。so let me pause here to see if there are，any questions on，pointers
    variables that store addresses。or on these new operators like the，ampersand or
    the asterisk。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所谈论的内容，我们人类，地址已经存在了数百万年，以独特地识别我们的住所或商家，计算机在内存中做的事情是完全相同的。所以让我在这里暂停，看看是否有关于存储地址的指针变量的任何问题，或者关于新的操作符，比如&符号或星号。
- en: which now has a new meaning today onward，any questions or confusion about，pointers。now
    i'll slowly tiptoe back over here，now i'll slowly tiptoe back over here。nothing
    yet all right seeing none well，let's consider now this same story in，data type，ins。but
    consider strings we've been spent a，lot of time on strings using。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从今天起，它有了新的意义，有关指针的任何问题或困惑吗？现在我将慢慢回到这里，没什么，好的，看到没有。好吧，让我们考虑一下这个相同的故事在数据类型中，但是考虑到我们花了很多时间在字符串上。
- en: uh encryption with them and solving uh，implementing electoral algorithms using。user's
    input so let's consider a，fundamentally different data type that。stores not individual
    integers，but strings of text instead so for，string。you might have a line of code
    that looks，like this string s，equals quote unquote high in all caps。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，使用它们进行加密并解决实现选举算法，使用用户输入。所以让我们考虑一种根本不同的数据类型，它存储的不是单个整数，而是文本字符串。对于字符串，你可能有一行代码看起来像这样：`string
    s = "HI";`（全大写）。
- en: with an exclamation point so that may，seen thus far，what's actually going on
    inside of the，that。computer，it ends up somewhere in your computer's，last week，a
    backslash zero or two weeks ago a。backslash zero，end，of that string but let's
    look a little，more carefully at what is going on。underneath this hood here，technically
    speaking i could address。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 带有感叹号的内容可能会让你看到目前为止，实际上发生在计算机内部的事情，它最终落在你的计算机的某个地方，上周是反斜杠零，或者两周前是反斜杠零，结束于那段字符串，但让我们仔细看看发生了什么。在这个引擎盖下，从技术上讲，我可以访问。
- en: those individual characters we have seen，as of week two，by using bracket notation
    like s bracket。zero s bracket one，s bracket two and s bracket three we use，the
    squ*re bracket notation to treat。a string as though it's an array of，is，but it
    turns out strings can also be，manipulated。by way of their addresses as well and
    so，for instance，maybe this same exact string hi is。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二周看到的那些个别字符，使用括号表示法，例如s[0]，s[1]，s[2]和s[3]。我们使用方括号表示法将字符串视为数组，实际上，它们也可以通过其地址进行操作。例如，也许这个完全相同的字符串“嗨”是。
- en: stored at memory address ox123，and then ox124 ox125 and ox126 notice，that they're
    deliberately。uh contiguous addresses back to back to，back and they're only one
    byte apart。because each of these chars of course is，just one byte，in c so those
    numbers are not important。specifically but the fact that they're，one byte apart
    from each other。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在内存地址ox123处，然后是ox124、ox125和ox126。注意，它们是故意连续的地址，前后相连，并且相距仅一个字节，因为这些字符在C语言中当然每个只占一个字节。所以这些数字并不重要，但它们彼此之间相距一个字节。
- en: is important because that's the，definition of a string and indeed an，back。now
    what exactly though is s s was the，name of the variable i gave him i'm，s。equals
    quantum quote hi well what is s s，is a variable，that has to go somewhere in the。computer's
    memory and suppose that，s is indeed high x，happens to live，can think of s，string。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为这就是字符串的定义，实际上是一个回溯。那么，s究竟是什么？s是我给它的变量名，我是s。等于量子引用“嗨”，那么s是什么呢？s是一个变量，它必须存储在计算机的内存中。假设s确实是“嗨”，它恰好存在于，想象一下s，字符串。
- en: but at a lower level is just the an，address of a string，more specifically let's
    start thinking。about a string，as technically being just the address of。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_26.png)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但在更低的层面上，它只是字符串的地址，更具体地说，让我们开始将字符串视为技术上仅仅是一个地址。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_26.png)
- en: the first character in the string，now that you might get that might give，first
    character。how are you going to remember that wait，a minute this string isn't at
    and。only at ox123 it also continues at ox124，ox125，and so forth but let me pause
    and ask，the group here。a computer and，us programmers to just think of terms，think
    of strings in terms of being。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的第一个字符，你可能会想到这可能会给你提供第一个字符。你将如何记住这一点，等一下，这个字符串不仅在ox123处，还在ox124、ox125等处继续。但让我暂停并询问在场的各位计算机和程序员们，想想字符串的定义。
- en: the address of the very first byte like，why is it sufficient no matter how long。the
    string is even if it's all paragraph，of text why is it very cleverly，sufficient。to
    think of a string like s as just，being identical to the address。of the first uh
    bytes uh ginny is it，yes yes am i audible yes we can hear you。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字节的地址，为什么这就足够了，无论字符串多长，即使是整段文本，为什么把字符串视为等同于第一个字节的地址是非常聪明的？嗯，是的，我听得见你吗？是的，我们能听到你。
- en: okay uh possibly because it happens that，strings whenever we are defining any。string
    that is all together，it will be g，i n and i all together so it will be。sufficient
    if something is pointed，towards just first character of my name。so that i can
    just follow up for the，first character and then get all the。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，可能是因为每当我们定义任何字符串时，它都会是`g，i，n`和`i`的组合。因此，如果某个东西指向我名字的第一个字符，那就足够了。这样我就可以跟踪第一个字符，然后获取所有的内容。
- en: uh characters afterwards perfect so all，of these basic definitions we had over，together。if
    a string is just an array of，characters and by definition of an array，back。and
    per two weeks ago every string，ends with this conventional backslash，zero or null
    character。all you need to do when thinking about a，string begin，because you can
    use a for loop or a。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符之后完美，所以所有这些基本定义我们都一起拥有。如果字符串只是字符数组，根据数组的定义，两个星期前每个字符串都以这个传统的反斜杠零或空字符结尾。当考虑字符串时，你需要做的就是开始，因为你可以使用`for`循环或一个。
- en: while loop or some other heuristic with，a condition and a boolean expression。to
    figure out where the string ends，length，so that is to say let's start for the。moment
    thinking about strings as being，quite simply that，in the string。and if we then
    take that as fact let's，go ah**d now and start playing with a。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`循环或其他启发式方法，带有条件和布尔表达式，以确定字符串的结束长度。也就是说，暂时让我们将字符串简单地视为在字符串中的内容。如果我们将其视为事实，那我们现在就可以**开始**进行实验了。
- en: program that doesn't use，integers but instead use strings using。this basic primitive
    so let me go ah**d，and delete the code i'd written before，in address。c。let me
    just change it up to be string，equals quote unquote high。semicolon and notice
    i'm not manually，typing any backslash zeros。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序不使用整数，而是使用字符串。使用这个基本原语，让我去**删除**之前在`address.c`中写的代码。让我只需将其更改为字符串，等于“高”。分号，并注意我并没有手动输入任何反斜杠零。
- en: c does that for us automatically when，you close the quote，the compiler takes
    care of adding that。backslash zero for you，now i'm going to go ah**d on the next，s
    backslash。n comma s if i want to print out that，string now this program is not
    at all，wrote something like。okay yes it is interesting because i，screwed up so
    five errors i've。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你关闭引号时，C会自动为我们处理这个，编译器会为你添加那个反斜杠零。现在我将继续下一个`s\n，s`，如果我想打印出那个字符串，现在这个程序根本不写成。好吧，是的，这很有趣，因为我**搞砸了**，所以有五个错误。
- en: written seven lines of code and five，errors and let's see what's going on。as
    always always go to the top because，odds are there's just some confusing，cascading
    effect。the very first error i see is use of，undeclared identifier，string did i
    mean standard n i didn't。mean standard n，string string string so i could run help，50
    as my friend here。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 写了七行代码和五个错误，让我们看看发生了什么。像往常一样，总是回到顶部，因为很可能有一些混淆的级联效果。我看到的第一个错误是使用未声明的标识符`string`，我是否意味着`standard
    n`？我并不意味着标准的`n`，而是`string string string`，所以我可以让我的朋友在这里运行帮助50。
- en: but i honestly i make this mistake often，enough that i kind of know now that
    i，forgot to include。cs50。h and indeed if i now，do this and recompile make address
    okay。all five errors are gone just by that，one simple change and if i run address。now
    it's just gonna quite simply say hi，but let's now start to consider what's。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但老实说，我经常犯这个错误，我现在有点知道我忘了包含`cs50.h`。实际上，如果我现在这样做并重新编译`make address`，所有五个错误都只通过这个简单的更改消失了。如果我现在运行`address`，它会简单地说“嗨”，但现在让我们开始考虑一下。
- en: going on underneath the hood of this，program suppose i am，curious and want to
    print out what is。actually，the address at which this string lives，well it turns
    out。let me be clever here let me print out，not a format code of percent s。but
    percent p show me this same string，as an address let me go ah**d and，recompile
    make address。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的底层运行着，假设我很好奇，想要打印出这个字符串实际所在的地址。那么，结果是，让我聪明一点，打印出不是格式代码的`%s`，而是`%p`，给我显示这个字符串作为地址。让我去**重新编译**并制作地址。
- en: seems to compile okay let me run dot，printing s，though it's，a pointer and interesting
    it's not the。same as before but again that's，reasonable because the memory addresses。aren't
    going to always be the same but，it doesn't matter what it is。but that's kind of
    interesting all this，time anytime you've been using strings。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来编译得不错，让我运行，打印 s，尽管它是一个指针，有趣的是，这并不和之前相同，但这又是合理的，因为内存地址。并不总是会相同，但，这无所谓。虽然这有点有趣，所有这些时间，每当你在使用字符串。
- en: had you just changed your percent s to a，memory，that string actually starts
    it's not。functionally useful to us just yet，but it's been there this whole time
    and。let me go ah**d and do the following now，suppose i get a little curious。further
    and i do printf let me go ah**d，and print out another address。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是把你的 %s 改成一个，内存，那字符串实际上开始的地方，它在功能上对我们来说还没有用，但它一直在那里。让我继续，现在做以下操作，假设我变得有点好奇。再进一步，我做
    printf，让我继续，打印出另一个地址。
- en: followed by a new line and let me go，ahead and print out，the address of the
    first character so。again this is a little weird to do and，we wouldn't typically
    do this that often，these operators。give us very simple answers to questions，like
    what is the address of this thing，represented。zero index means，s bracket zero
    is the first s bracket，one is the second if i play around with。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 后面跟着一个换行符，让我继续，打印出，第一个字符的地址。所以再次，这有点奇怪，我们通常不会这样做，这些操作符。给我们很简单的问题答案，比如这个东西的地址是什么，表示。零索引意味着，s[0]
    是第一个，s[1] 是第二个。如果我玩弄一下。
- en: today's new operator this ampersand，second，character and in fact let me go ah**d。and
    be more explicit，bracket zero，and put an ampersand here and let me go。ahead now
    and make this program make，address，okay a little funky oh i just missed a。semicolon
    so easy fix there，let me go ah**d and recompile with make。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的新操作符这个符号，第二个，字符，实际上让我继续，**前进**。并且更明确，括号零，并在这里放一个符号，让我继续。前进，现在让这个程序生成，地址，好吧，有点奇怪哦，我刚刚错过了一个；分号，所以在这里很容易修复，让我继续，**前进**并用
    make 重新编译。
- en: address let me go ah**d and run dot，slash address，and interesting uh well maybe。interesting
    to me so you see now two，addresses the first of which is ox4006。a four which apparently
    is the address，of the first character in s。but notice what's curious about the
    next，one it's almost the same。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 地址让我继续，**前进**并运行 ./address，嗯，有趣，哦，也许对我来说有趣。所以你现在看到两个地址，第一个是 0x4006。一个四，显然是 s
    中第一个字符的地址。但是请注意下一个地址的奇怪之处，它几乎是相同的。
- en: except the byte is one further away，and i bet if i do this not just for the。h
    and the i but also the exclamation，point let me do one more line of almost，identical
    code。just to make the point that all this，time it's indeed been the case。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_28.png)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除非字节相距一个进一步，我敢打赌，如果我这样做，不仅是 h 和 i，还有感叹号，让我再做一行几乎，完全相同的代码。只是为了表明，所有这些，时间确实是这样。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_28.png)
- en: that all characters in a string are back，to back to back and you can now see
    it，in code。b4 b5 b6 are just one，byte apart so we see some visual，confirmation
    now that strings are indeed。laid out in memory just like this，now again this is
    not a very useful。programmatic exercise to like look at，the address of individual
    characters but。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的所有字符都是紧挨着的，现在你可以在代码中看到。b4、b5、b6 之间仅相差一个字节，所以我们现在看到一些视觉确认，字符串确实在内存中就是这样布局的。再说一次，这不是一个非常有用的程序练习，像查看个别字符的地址，但。
- en: again this is just to emphasize that，underneath the hood，some relatively simple
    operations are。being enabled，by way of this new ampersand and in turn，star operator。so
    let's consider for a moment what this，memory，at a low level yes s is technically
    an。address and yes it's technically the，address of the first byte，which in the
    actual computer looked。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是为了强调，在底层，一些相对简单的操作正通过这个新的符号和反之，通过星号操作符来启用。所以让我们考虑一下这个内存，低层次的，是的 s 技术上是一个地址，是的，它技术上是第一个字节的地址，在实际计算机中看起来。
- en: different but in my slide here i just，arbitrarily proposed that it's at，ox123
    ox124 ox125。but again let's not care about that，level of detail，let's just kind
    of wave our hands and。abstract away these addresses and just，now start thinking
    of，s that is a string as。technically just being，a pointer a pointer so it turns
    out that。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不同，但在我的幻灯片中，我只是，任意提出它在，0x123、0x124、0x125。但再次让我们不在乎那个，细节层面，让我们只是挥手，抽象掉这些地址，并且现在开始思考，s
    作为一个字符串，技术上只是一个，指针。结果是。
- en: even though it's very useful and very，common to think of strings as obviously。just
    being sequences of characters and，that's been true since week one。and you can
    also think of them as arrays，back-to-back sequences of characters。you can also
    it turns out starting today，think of them，as just being pointers that is the。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将字符串视为显然是字符序列非常有用且常见，而这从第一周就已经成立。你也可以将它们视为数组，紧挨着的字符序列。结果是，从今天开始，你也可以将它们视为指针。
- en: address of a character，somewhere in the computer's memory and，as guinea notes。because
    all of the characters in a，string are by definition，back to back to back and because
    by。definition all strings end with，a backslash zero that is literally the。smallest
    and only amount of information，know where，all of your strings are just remember。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字符在计算机内存中的某个地址，正如 guinea 指出。因为字符串中的所有字符根据定义是紧挨着的，并且所有字符串根据定义都以反斜杠零结束，这实际上是知道所有字符串的最小和唯一信息，只需记住。
- en: the address of the very first character，to the end，by remembering that this
    backslash zero。is really just，eight zero bits otherwise represented as，backslash
    zero。and so we could certainly have an if，condition much like we did two weeks
    ago，strings，that。and so when i say we're taking off some，training wheels，here
    they go so with up until now we've。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符到结束的地址，记住这个反斜杠零实际上只是八个零位，其他形式表示为反斜杠零。因此，我们当然可以有一个条件，就像两周前的字符串一样。所以当我说我们正在去掉一些辅助工具时，它们就来了，所以到现在为止，我们已经……
- en: been using again the cs50 library which，gives us conveniently functions like，forth。but
    all this time the cs50 library，specifically the file cs50。h，had a little bit of
    a pedagogical。simplification in it，recall last week that you can define，your own
    custom data types。well it turns out that all this time，we've been claiming that
    strings exist。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用 cs50 库，它方便地为我们提供了像 forth 这样的函数。但这段时间 cs50 库，特别是文件 cs50.h，实际上有些教学上的简化。回想上周，你可以定义你自己的自定义数据类型。结果发现，这段时间我们一直声称字符串存在。
- en: and there's something you can use in，your programs and strings do。exist in c
    they do exist in python in，javascript and java and c。plus and many many many other
    languages，this is not a cs50 term。but string technically does not exist as，a data
    type，in c it instead is more cryptically。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你可以使用这些，字符串确实存在于 C 中，也存在于 Python、JavaScript、Java 和 C++ 等许多其他语言中，这不是 cs50
    的术语。但字符串在 C 中技术上并不存在作为数据类型，它实际上更隐晦。
- en: and more low level known as char，star char star now what does that mean。well
    char star much like our int star，a few minutes ago just represents the，address
    of a character。of an ant，and if again you kind of agree with me，now that you can
    think of strings。as sequences of characters or more，specifically arrays of characters
    or。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更低级的被称为 char star，char star 这是什么意思呢？好吧，char star 就像几分钟前的 int star，表示字符的地址。再次说，如果你同意我现在可以将字符串视为字符序列，或者更具体地说，是字符数组。
- en: more specifically as of today，the address of just the first character。then it's
    indeed the case that we now，can apply this new terminology today of，pointer。to
    our old familiar friends strings，you will，for char star and it's in the cs50，of
    code。that simplifies or abstracts away char，star which honestly no one wants to。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，从今天开始，就是第一个字符的地址。因此，实际上我们现在可以将这种新的术语“指针”应用到我们熟悉的字符串上，你将为 char star 而感到高兴，而在
    cs50 的代码中，简化或抽象掉 char star，实际上没有人想要这样。
- en: think about or struggle with in the，first week of a class，let alone the first
    two or three weeks。of a class it's a，simplification a custom data type，that we
    name string just so you don't。have to think about what is this star，address of，but
    today we can remove those training。wheels and reveal that all this time，you've
    just been manipulating characters。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想想或者在课程的第一周挣扎，别说前两三周了。课程中这是一个简化的自定义数据类型，我们称之为字符串，以便你不必思考这是什么星号地址，但今天我们可以去掉这些辅助工具，揭示出这些年来，你一直在操作字符。
- en: at specific addresses and we've used，this kind of technique before。abstracting
    away these lower level，details for instance recall。last week that we introduced
    this notion，of a struct，a data type that you can customize to be，book。by wrapping
    together a name and a number，inside of a custom data type，encapsulating them if
    you will。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定地址，我们之前使用过这种技术，抽象掉这些低级细节。例如，回想上周我们介绍了结构体这个概念，作为数据类型，你可以通过将名字和数字包裹在自定义数据类型中来定制它。
- en: inside of something we called person and，every person we claimed had a。a structure
    that contains a name and a，number and by way of this。feature of c typedef we can
    define a new，type and the name of that type。last week was just person so we're
    using，already and we have been sort of，our。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们称之为“person”的结构中，每个人都包含一个名字和一个数字，通过 C 的 typedef 特性，我们可以定义一个新的类型，而这个类型的名称上周刚好是“person”，所以我们已经在使用它。
- en: of c in the class a line of code that，actually looks like this。and this is indeed
    one of the lines of，code inside of cs50。h。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_30.png)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C 类中的一行代码实际上看起来像这样。这确实是 cs50.h 中的一行代码。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_30.png)
- en: it says type def which means give me a，custom type and it creates a synonym。for
    char star called string，and it's just a way where we can hide，the funky。char star
    we can hide the asterisk in，particular which would not be fun to。play with in
    the first few days，but without changing the definition of。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示 typedef，意味着给我一个自定义类型，并创建一个名为 string 的 char star 的同义词，这是一种隐藏 funky char star
    的方式，特别是隐藏星号，这在最初的几天里玩起来并不有趣，但没有改变字符串的定义。
- en: what a string is so strings exist in，in c，makes it，exist by way of that kind
    of definition。all right let me pause here to see if，strings，are or these new ways
    of thinking about，them。any questions about strings or char，i know it's a lot it's
    kind of low level，any hands here，what。okay all right well if no questions here，okay
    all right well if no questions here。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在 C 中存在，通过这种定义使它存在。好了，让我暂停一下，看看字符串，或者说这些新的思维方式，有没有关于字符串或 char 的问题，我知道这很多，算是比较底层的，有没有问题？好吧，如果没有问题。
- en: why don't we go ah**d and take our five，minute break here first，and we'll be
    back in five and take。another look at what we can now do with，all right we're
    back and we have now。all right we're back and we have now，this ability and code
    to get the address。of some variable and also to go to an，respectively，we've thought
    about strings as being not。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不先休息五分钟，然后再回来，再看看我们现在能做什么。好了，我们回来了，现在我们有能力和代码获取某个变量的地址，也可以去到相应的位置，我们考虑字符串时并不需要。
- en: only contiguous，uh sequences of characters but also，now，actual addresses the
    first the address。of the first character，and then from there can we find our way，programmatically
    to the end thanks to。that null character，but it turns out there's one other thing，we
    can do with these addresses or with。pointers more generally and that's known，as
    pointer arithmetic so anything that's，*****。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只有连续的字符序列，但现在还有实际地址，第一个字符的地址，然后我们能否程序化地找到结尾，多亏了那个空字符，但事实证明我们可以用这些地址或指针做另一件事，那就是指针运算，因此任何事情都是*****。
- en: and the math is not going to be，complicated but it is going to be。powerful for
    us here so i'm going to go，back to my most recent state of，address。c。and let me
    go ah**d now and reiterate，that we can print out the individual。characters in
    a string just like we did，back in week two as by using our squ*re。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数学不会复杂，但对我们来说会很强大，所以我将返回到我最新的 address.c 状态。现在让我再次重申，我们可以像第二周那样打印字符串中的单个字符，使用我们的方括号。
- en: bracket notation so i'm getting rid of，all evidence of those addresses for now。i'm
    recompiling this program as make，address and then i'm going to run dot，slash address
    now。and i see h i exclamation point one，character per line，but now consider that
    there doesn't need。to be a string data type in fact we can，take this training
    wheel off。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在清除所有那些地址的证据，暂时不需要。我将这个程序重新编译为 make address，然后我将运行 dot slash address。现在我看到
    h 感叹号每行一个字符，但现在考虑一下，实际上不需要字符串数据类型，事实上我们可以去掉这个辅助工具。
- en: and while it might feel a little，uncomfortable at first if i delete this。first
    line altogether as i've，accidentally omitted anyway sometimes。i don't need to
    keep calling things，verbally，i can think of them as strings because。string is
    a thing，in many different programming languages，but by default in c it just doesn't。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一开始可能会感到有点不舒服，如果我完全删除这一行，反正我有时会意外省略。其实我不需要不断地口头称呼这些东西，我可以把它们视为字符串，因为字符串在许多不同的编程语言中都是一个东西，但在
    C 中默认情况下并不存在。
- en: exist as a type，named char，star but again all that means is that，something。char
    means it's the address of a char so，char star，going to，point to a character so
    now if s is that。i can actually treat it the same there's，no reason i can't keep。using
    s like a string was back in week，two using our squ*re bracket notation。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种类型，名为 `char star`，但再说一遍，这意味着的是某物。`char` 意味着这是一个字符的地址，所以 `char star` 将指向一个字符，因此如果
    `s` 是这个，我实际上可以以相同的方式对待它，没有理由我不能继续使用 `s` 像在第二周那样，使用我们的方括号表示法。
- en: and i can keep printing out hi，exclamation point，but there's one。other way i
    can do this if i now know，that s is really just an address。i can get rid of this
    squ*re bracket，notation and i can actually just do。star s because recall that
    star，in addition to being the new symbol that。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续打印出嗨，感叹号，但还有另一种方式可以做到这一点，如果我现在知道 `s` 其实只是一个地址。我可以去掉这个方括号表示法，实际上可以只做 `star
    s`，因为要记住 `star` 除了是新符号外。
- en: we use when declaring a pointer up here，admittedly，that we use to go to an address
    so if s。is storing an address which it is by，definition of being a pointer，my
    picture。earlier it would seem to be the case。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_32.png)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明指针时使用，确实，我们用它来访问一个地址，所以如果 `s` 存储了一个地址，按照指针的定义，我之前的图像似乎是这样的。
- en: that s is most likely at an address，beginning at like ox123 it's not going。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_34.png)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`s` 很可能是一个地址，起始于类似 `0x123` 的地方，它并不会。'
- en: to be the same in my actual ide here，it'll be whatever the computer has，exact。idea
    so let me go ah**d and go to star，s and just for kicks let me leave it as，just
    that one line。so let me go ah**d and rerun this as，make address，all right and
    now dot slash address i。should see hopefully a capital，that s，a string is technically
    just an address。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的实际 IDE 中，它将是计算机所拥有的，完全相同的想法，所以让我继续走到 `star s`，为了好玩，让我只保留这一行。让我继续并重新运行这个作为
    `make address`，好的，现在点 `/address`，我希望能看到一个大写的，`s`，字符串在技术上只是一个地址。
- en: i can actually now do math on it and i，can go ah**d and print out another。character
    followed by a new line，and i can go to not s but how about。s plus one so i can
    do some very simple，arithmetic if you will on that pointer。and let me go ah**d
    and now recompile，this so uh，address and i should see。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在实际上可以在上面进行数学运算，我可以向前走，打印出另一个字符，后面跟着一个换行符，我可以去 `s` 加 `1`，所以我可以在那个指针上进行一些非常简单的算术。让我继续向前，重新编译这个，所以啊，地址，我应该能看到。
- en: h i and if i do one more line of code，like this printf，percent c backslash n
    star s。plus two i can now go to，the character that is two bytes away，from whatever
    s is which again is the。reprinted，high with the exclamation point，this fancy。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_36.png)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，如果我再多写一行代码，比如这个 `printf`，百分号 `c`，反斜杠 `n`，星号 `s`。加上 `2`，我现在可以去到距离 `s` 两个字节的字符，这又是。重打印，带有感叹号的高位，这个花哨的。
- en: squ*re bracket notation fancy only in，the sense that it was，will。i'm instead
    manipulating s for what it，really is which is just an address and，before。that
    squ*re bracket notation that we，just，anything，fundamentally different from these，asterisks。and
    these addresses it's just doing it，honestly in a much more user-friendly。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示法在某种意义上只是一种花哨的说法。我实际上是在操控 `s` 的真实含义，它只是一个地址，而在此之前。这个方括号表示法并没有任何根本上与这些星号和地址不同的东西，它只是做得更用户友好。
- en: way i still prefer personally，the squ*re bracket notation from week，two but
    it's the same thing。yourself，so c is just providing us with this，handy feature
    of using squ*re brackets。that does all of this so-called，pointer arithmetic for
    you but again。we're going to this low level just to，emphasize what it is，that's
    going on ultimately underneath。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人还是更喜欢第二周的方括号表示法，但这其实是一样的。你自己，所以 `c` 只是给我们提供了这个方便的特性，使用方括号，为你处理所有这些所谓的指针运算，但再说一遍。我们深入探讨这个低层次，仅仅是为了强调究竟发生了什么，终究在底层。
- en: the hood here，all right let me pause here for any，to，verbalize any on your end。i
    see a question that came in about what，would happen if you tried to print star。s
    plus three good question what if i try，to print star s plus three。i know intuitively
    i think that that，will end up being the new line，sorry the null character which。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我在这里暂停，看看是否有任何问题。我看到有个问题问，如果你尝试打印 `star s` 加 `3` 会发生什么？好问题，如果我尝试打印 `star
    s` 加 `3`。我直观地认为这将是换行符，抱歉，空字符。
- en: terminates the string but let's see if。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_38.png)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结束字符串，但让我们看看。
- en: we can confirm that let me go ah**d and，print out star as，i know about rewind
    so i i'm pretty sure。that's going to print out the null，as much here，percent c
    backslash n star，a little。adventurous here by looking at things i，maybe shouldn't
    be looking at because。that's a low level implementation detail，but let's see what
    happens。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认，让我继续并打印出星号，因为我知道重置，所以我很确定这会打印出空值，像这样，**%c\n**，星号，冒险点去查看一些我也许不该看的东西，因为那是底层实现的细节，但让我们看看会发生什么。
- en: it compiles okay dot slash address and，it seems to be blank，now maybe that's
    the null character。honestly it's not meant to be a，printable character it's this
    special。uh sentinel value that indicates the end，of the string but i could do
    this。i know from week two that chars are，integers and integers are chars if i。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编译没问题，**./address**，看起来是空的，可能是空字符。老实说，它并不应该是一个可打印字符，而是表示字符串结束的特殊哨兵值，但我可以这么做。我知道从第二周开始，字符是整数，而整数也是字符，如果我。
- en: want to think of them that way，so let me change only the very last，i，and run。address
    and voila h i exclamation point，zero and there is the all zero bits，digit。thanks
    to percent i now i can get really，crazy here，and why don't we go ah**d and print
    out。not just what characters，are right after this sequence h，i exclamation point
    null character why。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望以那种方式思考它们，所以让我只改动最后的**i**，然后运行。地址，然后出现了“嗨！”的感叹号，所有的位都是零。多亏了百分比**i**，我现在可以变得非常疯狂，为什么我们不继续并打印出来呢？不仅仅是这个序列之后的字符“嗨！”的感叹号和空字符。
- en: don't we go to，away，and really get nosy inside of my，address，okay nothing really
    going on over there。how about 10，000 bytes away let me go ah**d and make，address
    let me go ah**d and run this。and you might，be among the fortunate few who have
    seen，this error before。by touching memory you shouldn't and，we're going to deliberately
    consider。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去看看，真的深入我的地址，好吧，那里没什么。距离**10,000字节**的地方让我继续，做地址，让我继续运行这个。你可能是少数几个见过这个错误的人之一。因为触碰了不该触碰的内存，我们将故意考虑。
- en: this today but a segmentation fault，something wrong，somewhere in your code and
    it tends to，memory。that you shouldn't have and i have no，business honestly looking。10
    000 bytes away from the memory that i，know belongs to this string that's like。arbitrarily
    looking anywhere in your，computer's memory，which probably it seems is not a good。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 今天出现了一个分段错误，代码某处出了问题，内存出现了不应有的情况，而我根本不该去看。距离我知道属于这个字符串的内存大约**10,000字节**，就像是在随意查看你电脑的内存，这显然不是一个好的做法。
- en: idea but more on that，in just a bit so let's consider now some，of the implementations。of
    these underlying implementation，details and consider now from last week。why we
    did a few things the way we did，in the past few weeks in fact。so string is just
    a char star and let's，now consider an example let me zoom out。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好主意，但稍后再谈，所以现在我们考虑一下这些底层实现的实现细节，并回顾一下上周我们为什么以这种方式做某些事情，实际上在过去的几周中。字符串只是一个**char***，让我们现在考虑一个例子，让我缩小视野。
- en: on my memory just so i can cram more，in at once let's consider an example。where
    i might want to write a program，that compares two strings let me go。ahead and
    write some new code here in a，new file this time，called for instance compare。c
    my goal。with this program quite simply is going，to be to print out，the contents
    of or rather to compare。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的内存上，让我能一次性塞入更多内容，我们考虑一个例子。假设我想写一个程序来比较两个字符串，让我在一个新文件中写点新代码，暂且称之为**compare.c**。我这个程序的目标很简单，就是打印内容，或者说比较。
- en: two strings that the user might input，i'm going to go ah**d and include cs50。h。not
    because i want string per se anymore，but because i want to use getstring just。for
    convenience but we'll take that，training wheel off in a bit too。and in this program
    i'm going to go，ahead and first use not guest string yet。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个用户可能输入的字符串，我将继续并包含**cs50.h**。并不是因为我想要字符串本身，而是因为我想用**getstring**，只是为了方便，不过我们稍后会把这个辅助工具去掉。在这个程序中，我将先不使用**getstring**。
- en: let me go ah**d and keep it simple，and start with get int and i'll ask the，user
    for a variable i。and let me do another one of these and，get int and ask the user
    for a value for，simply say if i，out。same else let me go ah**d and print out，different
    so this is kind of week one。stuff where i'm using a couple of，branches，and i'm
    using printout to print printf。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续保持简单，先从**get int**开始，我会询问用户一个变量**i**。让我再做一个这样的，**get int**并询问用户一个值，简单地说如果**i**输出。否则让我继续并打印出不同，所以这有点像第一周的内容，我使用了一些分支，并使用**printf**进行打印。
- en: to print out whether those two variables，i and j are the same，as well。run compare
    and let me give it digits，one and two and，indeed they're different and let me
    go。ahead and give it one and one and，they're the same so i think logically。uh
    proof by example if you will this，program looks correct，but let me quickly make
    it seemingly。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出这两个变量i和j是否相同，运行比较，让我给它数字1和2，确实它们是不同的，让我再给它1和1，它们是相同的，所以我认为逻辑上，uh，通过例子证明，这个程序看起来是正确的，但让我迅速让它看起来似乎。
- en: uncorrect by not using，instead，let me go ah**d and give myself a string，wheel
    anymore。let's just do char star s equals，get string of s but again even though，i'm
    calling it char star it's。still a string like it was weeks ago let，me give myself
    another string called t，get。uh t will get that value there and let，me just very
    s，naively but kind of reasonably say if s。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确，因为没有使用，取而代之，让我**给自己**一个字符串，不再是“wheel”。我们就写“char star s = get string of s”，但即使我称之为“char
    star”，它仍然是一个字符串，就像几周前一样，让我再给自己一个叫“t”的字符串，uh，t会得到那个值，让我很天真，但也算合理地说，如果s。
- en: equals equals t，let's go ah**d and print out same and，otherwise let's go ah**d
    and print out。different so same exact code just，different data types and using
    get，string instead of get int。let me go ah**d and make compare seems，to compile
    okay，dot slash compare let me go ah**d and，type in。uh hi whoops，hi let me go ah**d
    and type in hi again，and voila。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “equals equals t”，让我们**继续**打印出相同，其他情况则打印出不同，所以相同的代码，只是数据类型不同，使用“get string”而不是“get
    int”。让我继续，比较似乎编译正常，点，斜杠比较，让我继续，输入“uh hi”，哎呀，“hi”，让我继续再输入一次“hi”，瞧。
- en: different huh and i forgot my backslash，my problems，let me recompile this make
    compare and。now let me run it again，how about with let's let's do a quick，test
    david brian these are definitely。to work，how about david david also different，huh
    let me try again brian brian。also different but i'm pretty sure those，strings
    are the same。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不同，嗯，我忘了我的反斜杠，出问题了，让我重新编译，进行比较，现在让我再运行一次，怎么样，我们来个快速测试，“david”和“brian”，这些肯定是可行的，怎么样，“david”也不同，嗯，让我再试一次，“brian”，“brian”也不同，但我很确定这些字符串是一样的。
- en: why might this program be flawed what is，wrong，what's wrong here any thoughts
    either on。what's wrong here any thoughts either on，camera or brian if you'd like
    to。verbalize some thoughts from the chat，any thoughts on why david and david are，high
    and high。are different a couple people in the，chat are saying that we're not actually。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个程序可能有缺陷，问题是什么，这里有什么问题，有什么想法？关于这里的问题，有什么想法？关于相机或者“brian”，如果你想把一些想法口头表达出来，任何关于为什么“david”和“david”是高和高不同的想法，聊天室里有几个人说我们实际上没有。
- en: comparing the characters we're comparing，the addresses，yeah so that's sort of
    the logical。conclusion from today's definition of，what a string really is if a
    string is。just the address of its first character，then if you're literally doing
    s equals，addresses。and they are probably going to be，different even if i type
    in the same。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 比较字符，我们在比较地址，是的，这就是今天关于字符串真正定义的逻辑结论，如果字符串仅仅是它第一个字符的地址，那么如果你真的在做“s equals”，地址，可能会是不同的，即使我输入的是一样的。
- en: thing because every time we've called，get into or get string，it's kind of plopped
    the user is in。user's input somewhere in my computer's，memory but we now have
    the tools。honestly to answer this or vet this，this answer ourselves let me go
    ah**d，and simplify this program。and let's just as a quick sanity check，print out
    s and let's go ah**d and print，out t。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用“get int”或“get string”时，用户的输入都会被放到我计算机的内存中，但我们现在确实有工具，可以回答这个问题，验证这个答案，让我继续，简化这个程序，快速检查一下，打印出s，让我们继续打印出t。
- en: uh using a new line after each just so，we can see what the strings are so let。me
    go ah**d and do this again，make compare okay compiles okay dot，slash compare let
    me type in hi。hi and they seem to be visually the same，but recall that now i have
    this other，format code。such that i can now start treating，strings as the addresses
    they，technically are。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，使用换行符让我们可以清楚地看到字符串，让我再**做一次**，让我们比较一下，好的，编译正常，点，斜杠比较，让我输入“hi”。“hi”，它们看起来是一样的，但请记住，现在我有了另一种格式代码，这样我就可以开始把字符串当作它们**技术上**是的地址来处理。
- en: so let me change percent s to percent p，in both places，let me then recompile
    the program and。now rerun compare with both high，and high identically typed but
    notice。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_40.png)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我把“percent s”改为“percent p”，在两个地方都改，然后让我重新编译程序。现在用相同的高和高重新运行比较，但注意到。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_40.png)
- en: they've ended up at slightly different，memory locations even though i have。coincidentally
    typed the same thing，c and my computer are not going to be so，presumptuous。as
    to use the same bytes for both，strings that's not going to give me much，the other。it's
    going to very simplistically put，one in this chunk of memory and the。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我恰好输入了相同的内容，它们最终在稍微不同的内存位置，即 c 和我的计算机不会那么自以为是地为这两个字符串使用相同的字节，这样做对我来说并没有太大好处。简而言之，它将非常简单地把一个放在这块内存中。
- en: other in this chunk of memory，and indeed those addresses are，respectively but
    arbitrarily。ox22 fe 670 and，ox22 fe 6b，oh so they are spread apart some，computer
    to decide。where to actually put those so what's，actually going on inside of the。computer's
    memory well let's consider，if for instance this is s my pointer or。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这块内存的其他地方，这些地址是各自的，但又是任意的。0x22 fe 670 和 0x22 fe 6b，哦，所以它们是分开的，计算机决定实际放置这些的地方。那么计算机内存中到底发生了什么呢？我们考虑一下，如果这是
    s，我的指针或。
- en: really my string but it's just a pointer，now it's the address of something。notice
    that i've drawn it as taking up，eight squ*res because again a pointer in。on modern
    systems is eight bytes so，that's why this thing is so big。meanwhile when i type
    in something like，high with the exclamation point。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 真的我的字符串，但它只是一个指针，现在是某个东西的地址。注意我画成占据了八个方块，因为在现代系统中，指针是八个字节，所以这就是为什么这个东西这么大。与此同时，当我输入像高这样的内容并加上感叹号。
- en: then it ends up somewhere in memory we，let's just arbitrarily，say it happens
    to end up there in my。computer's memory now each of those，bytes of course has
    an address。i don't necessarily know or care what，they are but for explanation
    sake let's。just number them again like before，ox123 ox124 ox125，ox126 when i then
    assign。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它最终会在内存的某个地方，我们随便说，它恰好在我计算机的内存中出现。现在每一个字节当然都有一个地址。我不一定知道或关心它们是什么，但为了说明的方便，我们再编号一下，0x123
    0x124 0x125 0x126。当我赋值时。
- en: s on the left the value from getstring，on the right，getstring what is it going
    to do well。you've been using it，it is yes getting a string and handing，it back
    to you as a return value。but what does that really mean well if a，string is just
    an address。the return value of a function like，getstring，is to return to not the
    string per se，concept。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的 s 是来自 getstring 的值，右边的 getstring 将要做什么呢？你一直在使用它，确实是获取一个字符串并将其作为返回值交还给你。但这实际上意味着什么呢？如果字符串只是一个地址。那么像
    getstring 这样的函数的返回值就是返回，而不是字符串本身的概念。
- en: what getstring has always been doing for，us is returning the address of the。string
    or more specifically，the address of the first character in，stored in。s to be clear
    is that address ox123，it's not returning to the whole string。the h the i the exclamation
    point rather，it's returning just one value to you。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: getstring 一直在为我们做的事情是返回字符串的地址，或更具体地说，是存储在 s 中的第一个字符的地址。为了清楚起见，那个地址是 0x123，它并没有返回整个字符串，h、i
    和感叹号，而是仅仅返回给你一个值。
- en: it's returning only to you the address，of the first character，of that string
    but again this is all。very，uh good for just s what's going on with，t t is kind
    of the same story because。i'm calling get string again，t is going to get assigned
    the address。of the first character of this version，of high and let's just arbitrarily
    say，it's at ox456。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它仅仅返回给你该字符串第一个字符的地址，但再一次，这对于 s 来说都很好，t 的情况也是类似的，因为我再次调用 getstring，t 将被赋值为这个版本的高的第一个字符的地址，我们随便说，它在
    0x456。
- en: ox457 ox4 5 8，and ox 459，and at this point t is going to take on，the value ox456。and
    now at this point honestly we're，really getting into the weeds let's just。start
    abstracting all of this away and，indeed，when we stop，caring about the particular
    addresses so。s is really just a pointer，a variable pointing at the first，character
    of high here t。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 0x457 0x458 和 0x459，此时 t 将获取 0x456 的值。老实说，现在我们真的进入了细节，让我们开始将这一切抽象化，确实，当我们不再关注特定的地址时，s
    只是一个指针，一个指向高的第一个字符的变量 t。
- en: is just a variable pointing at the first。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_42.png)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个指向第一个的变量。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_42.png)
- en: character of hi，strings，as i was before in the earlier version，of my program。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_44.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 字符 hi，字符串，就像我之前在程序的早期版本中那样。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_44.png)
- en: t。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_46.png)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: t。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_46.png)
- en: i was co i was indeed comparing，s and t but what are s and t s，and t respectively
    are。ox123 and ox456 or whatever the actual，values happen to be，which are not going
    to be the same。because they happen to point，to different chunks of memory all
    right。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_48.png)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实是在比较`s`和`t`，但`s`和`t`分别是什么呢？`s`和`t`的实际值是`ox123`和`ox456`，或者其他什么，这些值不会相同，因为它们指向不同的内存块。
    ![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_48.png)
- en: let me pause here，and brian see if there's any questions，or confusion。any questions
    or confusion no all right，well，who cares right like this is all kind of，cares。well
    how do we solve this problem let's，consider what i actually did，in a previous
    demo i sort of。function，string compare that allows you to，compare two strings
    and i promise that。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在这里暂停一下，看看布莱恩是否有任何问题或困惑。有没有问题或困惑？没有，好吧，谁在乎呢？就像这一切都有点无所谓。那么我们如何解决这个问题呢？让我们考虑一下我在之前演示中实际上做了什么。我有一个`string
    compare`函数，可以让你比较两个字符串，我保证。
- en: we would eventually explain why we use，stir compare，as opposed to just using
    the equal equal。sign well to use this function i am，going to need to add in，string
    dot h up here per lat time。but if string compare st let me go ah**d，and recompile
    this compare。dot slash compare now let me type high，and high identically，now they
    still seem to be different and。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会解释为什么使用`string compare`，而不是仅仅使用`==`。好吧，使用这个函数我需要在这里添加`string.h`，但如果使用`string
    compare`，让我继续重新编译这个`compare`。`./compare`，现在让我输入`hi`，而且`hi`是一样的，但它们看起来还是不同。
- en: damn it i made the same stupid mistake，as i did last time，does anyone know what
    uh mistake i made。when comparing two strings somehow i，mistake，ibrahim is suggesting
    that you add an，quite right。is to return，zero if they're the same a negative，other，and
    a positive number if one comes after。the other as in ascabetical order，so what
    i should have done both last，time and this time。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我真是太糟糕了，犯了和上次一样的愚蠢错误，有人知道我犯了什么错误吗？在比较两个字符串时，我不知怎么地犯了错。伊布拉欣建议你加上，没错。是的，如果它们相同则返回零，如果不同则返回负数或正数，正如字母顺序所示。因此，我应该在上次和这次都这样做。
- en: is check for equality with zero let me，go ah**d and recompile this program。okay
    good now let me re-run this program，with hi twice，voila they're the same and just
    to make。sure let me do one other check，let me do david and brian which should，be
    indeed different。so now again i haven't really done，but i'm now，thinking about
    these strings as being。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与零的相等性，让我继续重新编译这个程序。好的，现在让我重新运行这个程序，输入`hi`两次，瞧，它们是一样的。为了确保这一点，让我再做一次检查，输入`david`和`brian`，它们应该确实不同。所以现在我再次没有真正做到，但我现在在考虑这些字符串。
- en: fundamentally just their addresses and，so now let's make this，actually germaine
    let me go ah**d and。create a new file altogether and let's，pretty reasonably try
    to copy。one string and make changes to it so i'm，going to go ah**d here and just
    for。convenience i'm going to still use the，cs50 library not for the string data。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，它们只是地址而已，所以现在让我们真正进入正题，让我继续创建一个全新的文件，合理地尝试复制一个字符串并对其进行修改。因此，我在这里继续，为了方便，我仍然会使用`cs50`库，而不是字符串数据。
- en: type but just for the getstring function，which we'll see is more handy than
    other，things。than other ways of doing things and i'm，going to go ah**d and include，standardio。h
    and i'm going to go ah**d，and include，how about string。h，let me go ah**d and do
    in main void and。let me go ah**d in this program and get，myself a string but no
    we won't call it，star。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 只是针对`getstring`函数进行类型处理，我们将看到这比其他方法更方便。我要继续包含`stdio.h`，然后再包含`string.h`，让我在主函数中继续进行。让我在这个程序中继续并获取一个字符串，但我们不会称之为`star`。
- en: so again start taking off that training，a string，called s and then i'm going
    to get。another string but i won't call it that，i'll call it char star。t and i
    want to copy s and so you might，think based on week one week two and，variable。just
    do it i mean we've used the，assignment operator to copy，a variable from right
    to left for。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次开始处理这个字符串，叫做`s`，然后我将获取另一个字符串，但我不会称之为那个，我会称之为`char *t`，我想要复制`s`，所以你可能会想，基于第一周和第二周的变量，直接去做。我的意思是，我们已经使用赋值运算符从右到左复制一个变量。
- en: integers for chars and for other data，types perhaps too，i'm going to go ah**d
    now and make a。change to the original string，so let me go ah**d and do this let
    me go，ahead and say。let's change the first character of t，to be upper case recall
    that there's，this function two upper。which takes as input a character like，the
    first character in t。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 整数用于字符和其他数据类型，或许也是，我现在要继续对原始字符串进行更改，所以让我继续这样做，让我继续说。让我们把 t 的第一个字符改为大写，回想一下有这个函数
    `two upper`，它接受一个像 t 中第一个字符这样的字符作为输入。
- en: and returns the uppercase version now to，use two upper i need another。header
    file which i recall from a couple，weeks ago now i need ctype。h。so let me preemptively
    go back and put，that there and now let me go ah**d and。print these two strings，let
    me go ah**d and print out s as being，this percent s，value of。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回大写版本。现在要使用 `two upper`，我需要另一个头文件，我几周前记得我需要 `ctype.h`。所以让我提前回去把它放上，现在让我继续打印这两个字符串，让我继续打印出
    s，作为这个 `percent s` 的值。
- en: t with percent s as follows，so again what i'm doing is i'm getting a。string
    from the user and the only new，thing here is char star today because。which is
    synonymous with string on line，10 here i'm copying，the string from right to left
    and then。i'm capitalizing only the first letter，in the copy otherwise known as
    t and。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: t 的 `percent s` 如下，所以我再次所做的是从用户那里获取一个字符串，而这里唯一的新内容是 `char star`，因为在第 10 行，我是从右向左复制字符串，然后我只对复制的第一个字母进行大写，也就是
    t。
- en: then i'm just printing both out，so let me go ah**d and make copy okay，compile
    is okay，and type in h。enter，and voila it would seem that i somehow，capitalize
    both s and t。even though i only called to upper，on t brian，any thoughts from the
    group on why。i've accidentally and erroneous，erroneously，a couple people are saying
    that t is。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我只是把两个都打印出来，所以让我继续做复制，好的，编译也没问题，输入 h，回车，瞧！看起来我不知怎么地同时将 s 和 t 变成了大写，尽管我只对 t
    调用了 `to upper`。布莱恩，有没有人对此组有什么想法，为什么我意外地并且错误地这样做了？有几个人说 t 是。
- en: a couple people are saying that t is，just an alias of，s just an alias of s that's
    a reasonable。way of thinking of it sure and more，precisely any other thoughts，on
    why this is incorrect somehow。peter is now suggesting that they have，the same
    address，is copy s。into t but again what is s as of today，it's just an address，so
    yes i have copied s but i've copied。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个人说 t 只是 s 的别名，s 只是 s 的别名，这是一种合理的思维方式。确实，更准确的说法是，有没有其他想法说明这在某种程度上是错误的？彼得现在建议它们具有相同的地址，是将
    s 复制到 t，但再说一遍，s 到今天为止，它只是一个地址，所以是的，我复制了 s，但我复制了。
- en: address，ox123 or whatever it is and then on line，12 notice that i'm changing
    t by，uppercasing it。but t is at the same address of s so，really i'm，changing one
    and the same string so if。we think about this in terms of the，computer's memory，let's
    consider what i've just done let，put s。down as before let me put high down as，before
    but all lower case this time。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 `ox123` 或者其他的，然后在第 12 行注意到我通过将 t 转为大写来改变 t。但是 t 和 s 在同一个地址，所以实际上我在改变同一字符串。如果我们从计算机的内存角度考虑这一点，让我们考虑我刚做的事情，让
    s 和之前一样放下，让我把高放下，但这次全部小写。
- en: and recall that it might be at addresses，ox123 one two four one two five and
    one，two six。and now if we consider that s，technically contains，the address of
    that first character，variable t。and assign t the value of s i got to，take that
    statement literally。i'm literally just putting ox123 here，and if we now abstract
    away these。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并且回想一下，它可能位于地址 `ox123`、`one two four one two five` 和 `one, two six`。现在，如果我们考虑到
    s 技术上包含了第一个字符的地址，变量 t。并将 t 的值赋为 s，我得字面意思去理解这个语句。我确实是把 `ox123` 放在这里，如果我们现在抽象掉这些。
- en: details just to make it more clear，visually what's going on，that's pretty much
    like saying that both。s and t，yes in that sense t，is just an alias for s which
    is a，really just t。is identical to s so when you use the，squ*re bracket notation
    to go to the，first character of t。character，in s they are one in the same so when
    i，call to upper。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 细节只是为了让它更清晰，从视觉上看发生了什么，这几乎就像在说，s 和 t 是的，在这个意义上，t 只是 s 的别名，实际上 t 是与 s 完全相同的。因此，当你使用方括号表示法访问
    t 的第一个字符时，s 中的字符是一样的。所以当我调用 `to upper` 时。
- en: i'm calling it on this character which，of course is the one and only。h in the
    story and when i print s and i，print t，printf is following those same。breadcrumbs
    if you will，and ultimately displaying the same value。as having changed so we would
    seem to，need to fundamentally，rethink how we are copying strings and。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我是在这个字符上调用它，当然这是故事中唯一的一个 h，当我打印 s 和 t 时，`printf` 跟随那些相同的线索，最终显示出同样的值。看起来我们确实需要从根本上重新思考我们如何复制字符串。
- en: let me ask，what is if this is the wrong way to copy，one string into the other。what
    is the right way even if you don't，have the the functions in mind or the，right
    vocabulary。just intuitively if we want to copy a，string in the way that a human
    would，think of copying one。into the other like a photo a photograph，or a photocopy，how
    do we want to do this any thoughts，brian。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我问一下，如果这是把一个字符串复制到另一个的错误方式，正确的方式是什么？即使你没有想到正确的函数或词汇，只是凭直觉，如果我们想要以人类的方式复制一个字符串，就像复制照片一样，我们想怎么做？你有什么想法，布赖恩？
- en: yeah sophia suggested we would want to，somehow loop over the elements in。s and
    put them into t yeah i like that，so loop over the elements of。s and put them into
    t so it sounds like，more work，but that's again what we're going to。have to do
    if we want to think of these，if we want to accept the fact that these。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，索非亚建议我们想要以某种方式遍历 s 中的元素并将其放入 t 中，是的，我喜欢这个，所以遍历 s 中的元素并将其放入 t 中。这听起来更繁琐，但如果我们想接受这些事实，我们将不得不这样做。
- en: things s and t are just addresses we're，going to now have to go and follow。those
    breadcrumbs so let's go ah**d and，consider a variant of this program let，me go
    ah**d here。and change this such that i'm still，getting，such that i'm still getting
    a string s。but now let me go ah**d and and propose，exactly that that we copy the
    individual。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 s 和 t 只是地址，我们现在需要去跟踪这些线索，所以让我们考虑这个程序的一个变体，让我继续这里，并更改它，以便我仍然得到一个字符串 s。但现在让我继续并提出，我们逐个复制。
- en: characters but i need to copy them，somewhere so i feel like another step in。this
    process of copying a spring，has to be to give myself some additional，memory if
    i have h。i exclamation point and null character i，need to now somehow take control
    of the，in code，that i have。characters，so here's a new function today if i want，to
    create a string t。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 字符，但我需要把它们复制到某个地方，所以我觉得这个复制字符串的过程还需要一步，就是给自己额外的内存。如果我有 h。i 感叹号和空字符，我现在需要控制我拥有的代码。字符，所以今天有一个新函数，如果我想创建一个字符串
    t。
- en: otherwise known today as a char star，there is a new function we can use，allocation。this
    is a pretty fancy function that，fortunately is pretty simple to use。it takes as
    input just a number how many，bytes of memory do you want to ask the，computer for
    so。how do i do this well h i exclamation，point backslash 0。 i could literally，just
    say 4。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 今天也称为 char star，我们可以使用一个新的函数，分配。这是一个相当复杂的函数，但幸运的是，它使用起来相当简单。它只需要一个输入，询问你想要多少字节的内存，所以我该怎么做呢？h
    i 感叹号，反斜杠 0。我可以直接说 4。
- en: but this doesn't feel very dynamic i，think i can programmatically。implement
    this a little more elegantly，let me go ah**d and say，there are，characters in s
    plus one。plus one why am i doing this well h i，exclamation point，null character
    that's technically what's。stored underneath the hood but what do，you and i think
    of the length of high。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但这感觉并不是很动态，我想我可以更优雅地以编程方式实现这个，让我先说一下，s 中有一个加一的字符。加一，为什么我要这么做？好吧，h i，感叹号，空字符，这在技术上是存储在底层的，但你我认为高的长度是什么。
- en: as being well odds are in the human，world it's h i exclamation point and who。cares
    about this low level detail this，null terminator you don't include that，word。you
    only think of the actual characters，you can see so the length of high。is h i exclamation
    point three but i do，need to cleverly add one more byte，character。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“好吧”，在现实世界中很可能是 h i 感叹号，谁在乎这个低级细节，这个空终止符，你不需要包含那个单词。你只需考虑你能看到的实际字符，因此高的长度是
    h i 感叹号三，但我确实需要聪明地再加一个字节，字符。
- en: because i'm gonna have to copy that over，as well otherwise if i don't have an。identical
    null character，t is not going to have an obvious ending。so how do i copy now one
    string into the，other well let me go ah**d and take out，one，actually。n equals
    string length of s we've done，this trick before，i is less than n，simply say。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我也需要把它复制过来，否则如果没有一个相同的空字符，t 将不会有明显的结尾。那么我现在该怎么把一个字符串复制到另一个呢？让我先取出一个，实际上，n
    等于 s 的字符串长度，我们以前做过这个把戏，i 小于 n，简单地说。
- en: t bracket i gets s bracket i，so this will literally copy from s，into t。but i
    need to be a little smarter now，than n，i'm actually going to very aggressively。say
    i less than or equal to，n why why am i going，one step further than i feel we normally。do
    when iterating over strings and one，iterating，over a caesar cipher or enough string
    in。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`t[i]`得到`s[i]`，所以这将字面上从`s`复制到`t`。但我现在需要比`n`更聪明，我实际上会非常激进地说`i`小于或等于`n`，为什么我要比我们在字符串迭代时通常做的更进一步，以及迭代一个凯撒密码或足够的字符串。'
- en: that context，brian any thoughts here why am i going，from i less than or equal
    to n kind of。for the first time here，selena is suggesting that we need to，include
    the null character。yeah so if i and now i'm now i，understand how strings work
    so it's not。sufficient to just copy the hi，exclamation point i need to go one
    step。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，布莱恩，你有什么想法，为什么我要从`i`小于或等于`n`开始？这里，塞琳娜第一次建议我们需要包含空字符。是的，如果我现在理解字符串的工作方式，仅仅复制“hi”这个感叹号是不够的，我需要进一步一步。
- en: further one more than the length of the，would be，less than or equal to n or
    i could just。do a plus one there or i can do this any，it，but i think a less than
    or equal to is。one reasonable way to do it，and now let's go down to the bottom
    here。and now actually do this capitalization，let's now change，the first character
    in t to be the。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步比长度多一个，会小于或等于`n`，或者我可以在那加一个，或者我可以这样做，但我认为`i`小于或等于是合理的方法。现在让我们下到底部，实际上执行这个大写，让我们现在将`t`中的第一个字符改为。
- en: result of calling to，upper on the first character of t，print out whatever，print
    out。whatever t is and hope now that，only t has been capitalized but i do，need
    to make one change now。it turns out that this function malloc，comes in a file
    called standard，lib。h and again this is the kind of，can always google these，kinds
    of things even i forget what lot。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`toupper`在`t`的第一个字符上的结果，打印出任何内容，打印出`t`是什么，并希望现在只有`t`被大写了，但我现在需要做一个更改。结果证明这个`malloc`函数在一个叫做`standard
    lib.h`的文件中，再次，这种事情总是可以谷歌，甚至我也会忘记很多。
- en: what header files these functions are，sometimes declared in，but it happens to
    be a new one called。standard lib for library that gives you，access to malloc，so
    let me go ah**d now and make compare。all right so far so good dot slash，compare
    or sorry this is not compare，my god，oh i。looks like i forgot the ver the type
    of，i and n，so let me go into my for loop and add。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数有时在什么头文件中声明，但碰巧有一个新的，叫做标准库，它可以让你访问`malloc`，所以让我现在去比较一下。到目前为止，一切顺利，点斜杠比较，哦，不，这是比较，我的天，哦，我。看起来我忘了`i`和`n`的类型，所以让我进入我的循环中添加。
- en: the int that was my fault，let me make copy again okay all seven，errors thankfully
    went away。make copy let's go ah**d and type in，high in lowercase。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_50.png)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`是我的错误，让我再复制一次，好吧，所有七个错误幸运地消失了。再复制一下，让我们现在输入小写的`high`。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_50.png)'
- en: capitalized。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_52.png)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大写了。![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_52.png)
- en: only the copy of s-a-k-a-t，and just to be clear i've kind of，regressed back
    to my squ*re bracket。acceptable，it's very readable but notice if i，really want
    to show off。plus i location and then do this which，plus i location and then do
    this which，readability。but again there is this equivalence the，squ*re bracket
    notation is the same。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 只是`S-A-K-A-T`的副本，明确说一下，我已经回到了我的方括号中。可以接受，这非常可读，但注意如果我真的想炫耀。我加上`i`的位置，然后这样做，这样的可读性。但再说一次，这里有等价性，方括号语法是一样的。
- en: thing as pointer arithmetic so if you，want to go to，the address at t plus whatever
    i is to。offset yourself one or more bytes，you can totally do that and if i want
    to。be fancy i can go down here，and say go to the first character in t。and capitalize
    it but again i would，argue that even though yes you're very。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指针算术，如果你想到`t + i`的地址，以自己偏移一个或多个字节，你完全可以做到。如果我想要炫耀，我可以在这里说去`t`中的第一个字符并将其大写，但我认为尽管是这样，你还是非常。
- en: clever and that you understand pointers，and addresses at this point if you're，writing
    code like this。honestly it's not necessarily as，readable so sticking with week
    2 syntax。of the squ*re bracket notation totally，reasonable totally correct totally
    well，designed。and perhaps preferable though i should，be careful here，this line
    of code is a little bit risky。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的是你理解指针和地址，如果你正在写这样的代码。老实说，这并不一定那么可读，所以坚持使用第二周的方括号语法是完全合理、正确且设计良好的。尽管我应该小心，这行代码有点风险。
- en: for me because what if the user just，hits enter and they don't type hi。or david
    or brian what if they type，nothing except enter，in that case the length of the
    string。might be zero and then i probably，shouldn't capitalizing the first，character
    in a string that。probably，have some error checking like if，for instance the string
    length of t is，at least，do that。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，因为如果用户只是按回车而不输入hi。或者david或brian，如果他们什么都不输入，只按回车，那么字符串的长度。可能是零，那我可能不应该将字符串中的第一个字符大写。那可能有一些错误检查，比如如果t的字符串长度至少是这样做。
- en: but again this is just one example of，to the program，there's actually one more
    piece of error。checking i should really do in a fully，correct program as you should
    do in，problem sets。sometimes things can go wrong and if，your program is so big
    so fancy and so。memory hungry that you're，mallocking lots and lots of memory which。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是一个示例，关于程序，实际上我应该在一个完全正确的程序中做更多的错误检查，就像你在问题集中应该做的那样。有时事情会出错，如果你的程序如此庞大、如此华丽、如此占用内存，以至于你正在申请大量内存。
- en: you won't do in the program this small，but over time you might need more and。more
    memory we should also make sure，that t actually has a valid address，time。is going
    to return to you the address of，you，just like getstring it will return to。the
    address of the first，byte of the chunk of memory that it has，found space for。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中你不会这样做，但随着时间的推移，你可能会需要越来越多的内存。我们还应该确保t实际上有一个有效的地址，时间。会返回给你地址，就像getstring一样，它会返回找到的那块内存的第一个字节的地址。
- en: however sometimes things can go wrong，sometimes your computer can be out of。memory
    you've probably seen your mac or，pc freeze or hang or，reboot itself that is very
    often the。result of memory errors，so we should actually check something，like this
    if t equals equals this。special value，null then i'm going to go ah**d and just，bail
    out and return one。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时事情可能会出错，有时你的计算机可能会没有。内存，你可能见过你的mac或pc冻结、挂起或重启，这往往是内存错误的结果。因此，我们实际上应该检查类似这样的东西，如果t等于这个特殊值null，那么我会去啊**d并且退出并返回一个。
- en: quit just let's get out of the program，it's not going to work，this might only
    happen one out of a。million times but it's more correct，to check for null now
    unfortunately the。designers of c kind of used or，programmers more generally use
    this，n-u-l。otherwise known as backslash zero，unfortunately this is a different
    value。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 退出，让我们退出程序，这不会工作，这可能只会发生一百万次中的一次，但现在检查null更为正确。遗憾的是，c的设计者或更一般的程序员使用了这个n-u-l。也称为反斜杠零，遗憾的是这是一个不同的值。
- en: n-u-l-l represents the a null，pointer it is a bogus address it is the，address。zero
    it is different from backslash zero，you use null in the context of pointers，zero。otherwise
    known verbally as nul or null，in the context of characters so。backslash zero is
    for characters，and ull in all caps is for pointers and，it's just a new symbol。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: n-u-l-l表示一个空指针，它是一个虚假的地址，即地址。零，它与反斜杠零不同，你在指针的上下文中使用空指针。通常口头上称为nul或null，在字符的上下文中，反斜杠零用于字符，而ull大写是用于指针的，它只是一个新符号。
- en: we're introducing today that comes with，this standard lib，dot h file all right
    so it turns out。honestly i don't need to do some of this，work it turns out，that
    if i want to copy one string to。another there is a function，for that and increasingly
    you will not。have to write as many lines of code as，you previously did，because
    if you look up in the manual。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天介绍的，带有这个标准lib，dot h文件，好的，结果是，老实说，我不需要做一些工作，结果是，如果我想将一个字符串复制到另一个字符串，有一个函数，来完成这个，越来越多的时候你不需要像以前那样写那么多代码，因为如果你查阅手册。
- en: pages or you've heard about，or find online that there's another，function like
    one called stir copy。you can actually more simply do，something like this so even
    though i。really liked the idea and it was correct，to use like a for loop，to copy
    all of the characters from s。into t，there's a function for that it's called，stir
    copy it takes two。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 页面，或者你听说过，或者在网上找到另一个，类似的函数，叫做stir copy。实际上你可以更简单地做，像这样，所以尽管我真的很喜欢这个主意，并且使用像for循环来将所有字符从s复制到t是正确的，但有一个函数为此，它叫做stir
    copy，它需要两个。
- en: arguments the destination followed by，the source and it will just。handle all
    of the looping for us all of，the copying for us including the，backslash zero。so
    that i can focus on what i want to do，which in this case，is actually capitalize
    things so if we。consider now this example，in the context of my computer's memory。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，第一个是目标，后面是源，它会为我们处理所有循环和复制，包括反斜杠零。这样我就可以专注于我想做的事情，在这种情况下，实际上是大写字母。所以如果我们现在考虑这个例子，结合我计算机的内存。
- en: we'll see that it's laid out a little，differently but there's one more bug i，do
    want to fix first。and this is something we've not had to，do yet it turns out，malloc。you
    ask the computer for memory the onus，is on you the programmer to eventually，give
    it back。and by that i mean if you allocate four。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到它的布局稍有不同，但我首先想修复一个错误。这是我们尚未处理的事情，结果是，malloc。你请求计算机分配内存，责任在于你，程序员，最终要把它归还。我的意思是，如果你分配了四个。
- en: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_54.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbbbe7029dc68bebd0fd8bf9f84d17b_54.png)'
- en: bytes or who knows four million bytes of，memory for an even bigger program。you'd
    better give it back to the，computer more specifically the operating。system be
    it linux or mac os or windows，so that your computer eventually doesn't，ask for
    more memory。ask for more memory it stands to reason，that eventually your computer
    will run。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 字节或四百万字节的内存用于一个更大的程序。你最好把它还给计算机，更具体地说，是操作系统，无论是Linux、Mac OS还是Windows，这样你的计算机最终就不会要求更多内存。要求更多内存显而易见，最终你的计算机将运行。
- en: out because it only has a finite amount。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它只有有限的量。
