# 哈佛 CS50-WEB ｜ 基于Python ／ JavaScript的Web编程(2020·完整版) - P25：L8- 拓展性与安全 2 (缓存，安全，https) - ShowMeAI - BV1gL411x7NY

文章可能不会经常改变，如果一个人发出请求，一秒后另一个人又发出同样的请求，那么从数据库重新请求所有信息以再次生成该模板可能没有什么用，因为这是一项昂贵的过程。

从数据库请求数据或生成模板时，我们理想上希望有某种方法来处理这个问题，而我们可以解决这个问题的方式是某种形式的缓存，缓存指的是我们可以在不同地方使用的一系列不同类型的想法和工具。

在我们的系统中，一般来说，当我们谈论缓存时，我们是在谈论以某种方式存储某些信息的已保存版本，以便我们能够更快速地访问，因此我们不需要继续向数据库发出请求。例如，有许多方式可以进行缓存。

我们可以在客户端进行缓存，通过客户端缓存，想法是你的浏览器，无论是Safari、Chrome还是其他浏览器，都能够缓存数据，存储信息，这样浏览器下次就不需要重新请求相同的信息了，举个例子。

假设该页面加载了一张图片，并且你重新加载该页面，那么你的网页浏览器可能会尝试再次请求同样的图片，然后显示给你，但另一种可能是你的网页浏览器可以在缓存中保存该图片的副本以供本地存储。

存储该图片的一个版本，这样下次用户向网站发出请求时，用户就不需要重新加载整个图片，这也适用于整个网页和网络资源。如果某些页面不常改变，那么如果网页浏览器缓存了已保存的版本。

如果用户下一次访问他们的网页浏览器时尝试访问该页面，而不是重新向服务器发出请求并进行新的请求，如果浏览器缓存了该页面，浏览器可以直接显示缓存的已保存页面。

这可能根本不需要与服务器交互，因此这肯定有助于减少特定服务器的负担，因为如果用户在网页浏览器中缓存了信息，用户体验会更快，因为他们可以立即看到信息，而不需要发出请求并等待响应。

响应回来的好处在于服务器不需要处理那么多请求，如果其中一些请求得到了缓存。因此，尝试解决这个问题的一种方法是在HTTP响应的头部中添加一些内容，当你的web服务器响应某些请求时。

网络服务器可以在响应中包含类似这样的行：cache control max-age 86,400，实际上是指定你应该缓存此资源的秒数。但如果我在10秒后尝试访问这个页面，那就少于86,400秒，因此不必重新加载。

请求整个页面时，我们只是使用网页浏览器中缓存的版本。因此，这有几个优势，我们在减少查看页面内容所需时间方面已经讨论过，因为它已经保存。

这减轻了对任何特定服务器的负载，但也有缺点，例如如果在这段时间内资源发生了变化，假设在60秒内页面发生了变化，如果我再次加载页面，加载的是缓存的版本，我可能会看到过时的内容。

我看到的网页版本是旧版本，因为我的网页浏览器恰好缓存了该特定资源。这种情况可能适用于网页，尤其适用于其他静态资源，例如CSS文件或JavaScript文件，但网页的CSS。

页面可能并没有经常变化，因此很自然的是，网页浏览器不会一次又一次请求完全相同的CSS文件，而是可能只会保存这些CSS文件的副本，将其缓存，以便能够重复使用缓存版本。

如果网站更新了他们的CSS，你可能看不到最新的更改。如果你在自己开发网页应用时更改CSS并刷新页面，你可能不会总是看到这些更改被反映出来，如果你的网页浏览器正在缓存这些内容。

因此，在大多数网页浏览器中，你可以进行硬刷新，忽略缓存中的内容，实际上发出新请求并获取一些新数据。但最终如果你不这样做，你就会受到缓存控制的限制，网页浏览器将会说，除非经过的秒数达到了这个数字。

一旦过去了一段时间，我们将重新使用现有版本的页面。因此，这种方法的替代方案（这确实有效且相当流行），我们可以通过添加称为e-tag的内容来扩展这一方法。资源（如CSS文件、图像或JavaScript文件）的e-tag就是。

一些独特的字符序列，标识特定版本的资源，比如标识一个CSS文件或JavaScript文件的特定版本。这允许程序（如网页浏览器）在请求资源时，例如请求一个CSS文件。

JavaScript文件，它们会收到返回和相关的etag值。因此我知道这是与这个版本的CSS文件相关的值，如果网络浏览器的网络服务器曾经更改了那个CSS文件，并用一个更新的CSS文件替换它，对应的etag也会改变。

那么这有什么好处呢？这意味着如果我在考虑是否应该加载资源的新版本，或者是否应该尝试另一个请求以获取最新的CSS，首先我可以问一下etag值，这个短小的序列可以在浏览器中快速回答。

很快，我们可以回应说，如果etag值与我上次记住的相同，那么我就不需要获取整个新版本的资源，因此这很常见 - 我们的网页浏览器会说，嘿让我请求这个资源，但我已经有一个版本。

资源上指定这个特定etag，如果该etag仍然是某个特定资源（如CSS或JavaScript文件）最新版本的etag，那么网络服务器就不需要发送该文件的新版本，只需回应并说你拥有的版本，那个完全可以使用，但如果有。

是一个新版本，那么网络服务器可以用新资产进行响应。例如新的CSS文件，还有新的etag值，因此这两种方法可以相辅相成，你可以说继续缓存这些，持续一段时间，因此在这段时间内你不会。

决定请求该资源的新版本，但即使你在这段时间过后请求新的版本，如果etag值没有更新，那么就不需要重新下载特定文件的整个新版本，你可以直接重用缓存的版本。

所以缓存和浏览器可以是一个极其强大的工具，来加速这些请求，减轻特定服务器的负担，但客户端并不是我们开始进行这种缓存的唯一地方，我们也有能力进行。

服务器端缓存，在服务器端缓存中，我们将向我们的概念介绍一个缓存，拥有多个服务器与数据库进行通信，而这些服务器也可以与某个地方的缓存进行通信，在那里我们存储可能想要重用的信息。

而不是做所有的重新计算，结果发现Django有一个完整的缓存框架和一整套功能，允许我们利用这个能力使用缓存来加速请求，因此有按视图缓存，可以在。

特别的观点是，与其每次有人请求这个特定视图时都运行所有的Python代码，不如缓存该视图，这样在接下来的30秒或30分钟内，当下一个人尝试访问相同视图时，可以直接重用上次的结果。

上次加载该视图时的时间，这不仅适用于单一视图，也适用于模板中的片段，模板可能包含多个部分，在网页上，你可能会根据当天的信息渲染导航栏、侧边栏和页脚。

可能第二天会改变，但如果你预期页面的侧边栏在同一分钟或同一小时内不会频繁更改，那么你可以考虑缓存模板的这一部分，这样当django尝试加载整个模板时，就不需要重新计算。

如何为你的网站生成侧边栏，它只需知道我们可以使用上次加载该网站时保存的侧边栏版本，jingle还提供了访问较低级缓存API的能力，方便你缓存和存储任何信息以供后用。

你可以将信息保存在API中，进行一次耗时几毫秒或几秒钟的数据库查询，你可以将这些结果保存在缓存中，以便下次访问同样的数据时更容易获取。

这使我们能够通过减少服务器和数据库的负载来处理这些规模问题，而不是每次对特定网页应用程序发出新请求时都与数据库进行交互，我们可以重用缓存中已有的信息，从而提升我们的网页应用。

应用程序可以变得更加可扩展，因此我们会看一些与可扩展性相关的问题，然后将注意力转向安全，确保在构建和部署我们的网络应用程序时，随着更多用户的使用，我们要确保安全。

他们确保安全，还有一大堆安全考虑因素需要在我们所研究的所有主题中加以考虑。我们已经看过多个不同的主题，每个主题都有安全漏洞，需要注意相关的想法。

确保我们的应用程序是安全的，我们的故事实际上可以从git和版本控制开始，git的核心在于帮助我们跟踪代码的不同版本，而与git密切相关的是开源软件的概念。

在像GitHub和其他托管git存储库的服务的网站上，越来越多的软件正变成开源，任何人都可以查看并贡献应用程序的源代码，这在某种意义上是很棒的，因为它允许很多人能够合作共同工作。

为了尝试发现可能存在于网络应用中的错误，但这也带来了缺点，如果应用程序中有一个错误，现在查看我们程序源代码的人可能会发现这个错误，或者你可能会想象，因为 gate keeps。

跟踪我们代码的不同版本，每次我们向存储库提交时，你必须非常小心关于凭证或可能泄漏到源代码中的东西。通常情况下，你绝对不想把密码或任何安全信息放入git存储库中，因为。

git存储库可能会与其他人共享，可能向任何人开放以供查看，因此这些都是需要注意的安全考虑因素，如果你进行提交并意外地提交了你的代码。![](img/cdd7efd64de809f73ede64b817f02ea2_1.png)

如果你暴露了这些凭证，你可以删除这些凭证并再次提交，因此你程序的最新版本不包含这些凭证，但拥有访问git存储库的人可以访问的不仅是你代码的最新版本，还有你代码的每个版本。

而那个人理论上可以回顾存储库的历史记录，找到凭证暴露的提交，并查看那些凭证。因此，虽然git是一个非常强大的工具，但这也是需要注意的，任何你所做的更改可能会被保存在一个。

提交因此可能会在稍后被访问，所以如果存储库中暴露了凭证，你要确保删除所有之前的提交，而不仅仅是进行一些新的提交来试图隐藏之前可能暴露的凭证，因为它们可以。

仍然可以在任何特定存储库的历史记录中检索到，因此那时我们查看了一些可能出现的问题，我们还在课程开始时讨论了HTML，以及我们可以用HTML做什么，以及我们如何使用这种语言来设计。

网页的结构，以决定所有段落将放在哪里，页面上将包含哪些表格，我们讨论了链接以及如何使用锚标签将一个页面链接到另一个页面。现在一个关注点是这种攻击类型，称为网络钓鱼攻击，与HTML有关，网络钓鱼。

攻击实际上只涉及一小段HTML，像这样非常简单的代码，我有一个锚标签，它将用户引导到URL 1，但看起来是引导用户到URL 2。这种情况的例子是什么呢？

link.html，在linked out HTML中，我写了一个网站，看起来有一个指向谷歌的链接，但如果我点击那个链接，我突然被引导到了这个课程网站。那是怎么发生的，为什么会这样？

看起来它在链接谷歌，如果你查看代码，打开linked on HTML，你会看到这里有一个锚标签，它实际上链接到课程网站，但看起来是链接到谷歌。

这是一个非常常见的攻击向量。

特别是在电子邮件中，例如，你可能会看到一封电子邮件告诉你点击某个链接，但那个链接实际上会把你带到完全不同的地方，因此有人可能会不小心分享他们的银行账户凭证或其他敏感信息，这里也要引起注意。

互动网络时，可能并不一定在你自己的网站上，但在其他网站上你可能会互动，务必注意链接实际上将你带到哪里。大多数网页浏览器在你悬停在链接上时会显示该链接可能实际指向的地方，因为它可能是。

与文本中该特定锚标签所显示的内容不同，它可能链接到其他地方。因此，HTML存在各种不同的漏洞，因为你可以决定页面的结构，这就留下了有人试图欺骗你的可能性。

你正在访问一个实际上并不在的页面，这个问题更为普遍，因为任何人都可以查看任何页面的HTML。HTML来自服务器，因此网页浏览器可以访问所有这些HTML，并可以使用这些HTML来渲染页面，这留下了开放的可能性。

其他漏洞也是如此，例如，让我去美国银行（Bank of America）的官网，如果我想创建一个假冒的美国银行网站，以欺骗他人认为他们正在访问美国银行。

实际上，他们将访问我的网站。那么我可以查看这个网页的源代码。

我将查看页面源代码，这里是美国银行网站的所有HTML，没有什么可以阻止我复制所有这些内容，放入HTML文件中，创建一个新文件，然后我将其命名为Bank HTML，然后我会粘贴进去。

![](img/cdd7efd64de809f73ede64b817f02ea2_9.png)

那个 HTML 文件的内容在这里，那么这是全部的美国银行的 HTML，现在如果我打开 Bank HTML，这个我现在写的 HTML 文件其实只是。![](img/cdd7efd64de809f73ede64b817f02ea2_11.png)

从美国银行复制的，我打开它，现在我的页面上是一个看起来像美国银行的网页，它使用了美国银行的所有 HTML，但实际上是我的 HTML 页面，而不是美国银行。因此，你可能想象将这些结合在一起，创建一个更加令人担忧的攻击。

向 Google com 链接的方式，试试链接到美国银行 com，但实际上我。![](img/cdd7efd64de809f73ede64b817f02ea2_13.png)

我将链接到的是 Bank dot HTML，我的美国银行网站版本。![](img/cdd7efd64de809f73ede64b817f02ea2_15.png)

现在如果我打开链接 HTML，这里似乎有一个链接指向美国银行的网站。如果我点击那个链接，我会进入一个看起来像美国银行网站的页面，但它并不是！[](img/cdd7efd64de809f73ede64b817f02ea2_17.png)

美国银行的网站是我的银行，我写的 HTML 文件正好看起来像美国银行的网站，因为我复制了所有的底层 HTML。因此，HTML 能够描述我们网页的结构，但每当你写这 HTML 时，记得这一点是很重要的。

任何人都可以复制你的 HTML，从理论上讲，可以假装成 Yumi 的网站，这些安全漏洞值得我们在开始开发网络应用程序和与网络应用程序互动时注意。因此，最终我们在设计使用 Django 的网络应用程序时使用了 HTML。

框架到底是如何工作的，这些网络框架如何创建监听请求并响应这些请求的网络服务器？最终，互联网的许多内容都是围绕客户端与服务器之间的通信这个理念构建的，或者更一般来说，是任一台计算机之间的通信。

正在使用 HTTP 与另一台计算机通信，尤其是 HTTP 的更安全版本。因此，你可能想象这些协议实际上是关于如何将信息从一个人传递到另一个人，以及我们与这些信息一起存储的内容。

试图与另一台计算机通信，为此信息通常会通过这些路由器流动，你可以想象信息在一台计算机和另一台计算机之间来回传递，通过这些中间路由器沿途。

因此需要谨慎的一件事是，你如何知道这信息在来回传递时是安全的？理想情况下，当我向另一台计算机发送消息时，我就是在给其他人发送电子邮件，发送消息，或者发出请求。

比如，我不希望任何拦截请求的路由器能查看我的银行账户等敏感信息。我希望确保这些路由器无法看到我的请求及其内容。

我希望在网上发送的密码信息能够被加密，因此我们将讨论**密码学**，即确保能够与他人沟通而不被中间窃听者监听的过程。

显然，如果我直接发送未加密的消息文本，那么任何看到该消息的人都会知道内容，因此我需要某种加密方式。

对消息进行加密，以防有人在传输过程中能够解密。如果中间的路由器或其他人能够拦截消息，那么我们首先要考虑的是所谓的**对称密钥密码学**。

这里涉及的不是明文，而是某个密钥，一个用于加密或解密信息的秘密信息。我将使用密钥和明文生成称为**密文**的加密版本。

我可能想要通过互联网发送密文，而不是明文，以防发送明文导致内容泄露。因此，密文被传送，另一方也需要密钥。

如果其他人拥有密文和密钥，那么他们就可以利用这些信息使用密钥解密密文，得到原始明文。这个密钥可以称为**对称密钥加密和解密密钥**，用来加密和解密消息。

为了完成解密过程，我和交流对象都需要同样的密钥，只要我们都能访问这个密钥，就可以加密和解密消息，而仅拥有密文但没有密钥的人则不太可能解读出内容。

但在互联网环境中存在一个问题，即我和另一方都需要访问这个密钥。密钥用于加密和解密，但我不能直接将密钥通过互联网发送给他人。

如果我做得很好，那么中间的某个人拦截了我的请求，他们就可以同时获取密文和密钥，因此他们能够解密消息，因为他们同时拥有密文和密钥。如果我能够与另一个人当面交换密钥。

只要我们都有密钥，而且我没有将密钥公开分享给可能拦截消息的任何人，这个方案就能奏效。只有我和另一个人拥有密钥，但通常在互联网上交流时，你并不是在与你已经通信的服务器沟通。

在我尝试向一个新网站发起请求时，我们需要达成一个协议，让我可以加密消息，而只有对方能够解密这些消息，因此这种加密方式可能并不适合初步创建。

互联网的安全连接，对于密码学的一项重大进展是公共密钥加密的概念，而在秘密密钥加密中，密钥必须是秘密的，因为如果每个人都知道密钥，那么任何人都能够。

在公钥密码学中，我们能够创建一个安全的加密系统，其中密钥是公开的，或者至少是其中一个密钥。如你所见，这里的想法是我们使用两个密钥而不是一个，我们同时拥有一个公钥和一个称为私钥的密钥。

私钥是你应该绝对不与他人分享的东西，以保持加密方案的安全，而公钥则可以与他人分享，二者的区别在于公钥用于加密信息。

私钥将用于解密由公钥加密的信息，公钥与私钥在数学上是相关的，我们可以想象几种方法来实现这一点，但现在的想法是，如果我想与另一个人交流，那个人会把。

他们的公钥发送给我，公钥可以在互联网中传输。任何人都可以看到公钥，因为公钥仅用于加密数据，因此我可以使用明文和公钥生成密文。

我将密文发送给我想要沟通的另一方，而另一方现在使用密文，再用他们没有分享的私钥，私钥能够解密使用公钥加密的信息，因此使用这种方式。

密文与私钥的组合，使得我所沟通的那个人能够解密信息，恢复出原始的明文内容，因此这就是我们如何通过使用公钥和私钥对在互联网上进行大量通信的方式。

可以使用公钥进行加密，使用私钥进行解密，而现在两个之前从未互动过的计算机，无需见面以交换某些秘密信息，可以使用这种技术安全地互相沟通。

我们可以来回发送消息，而中间没有人能够拦截消息并识别消息的内容。一旦你具备这种能力，能够与他人秘密交流，那么你可以想象达成某种秘密密钥的共识，然后使用对称密钥加密。

以便能够加密和解密消息，因此这是你在尝试与他人通过互联网沟通时可以采取的一种方法。加密的理念使得HTTPS得以实现，这是HTTP协议的安全版本，以确保你在沟通时。

例如，你银行的网站上，途中不会有人能够拦截信息并识别你在沟通的内容，而只能得到加密版本的信息，以及一个公钥，用于加密信息，但没有可以解密信息的私钥。

最终，这种方法使我们能够在互联网上实现这种安全通信，并使我们的网络应用程序变得安全。此外，我们的网络应用程序不仅是监听请求，并提供某种响应。

在本课程中，我们引入了SQL数据表的概念，表中有代表信息的行和列，我们还创建了网络应用程序。![](img/cdd7efd64de809f73ede64b817f02ea2_19.png)

在本课程中，我们有用户使用的应用程序。![](img/cdd7efd64de809f73ede64b817f02ea2_21.png)
