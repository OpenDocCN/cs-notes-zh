- en: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P2：L0- 搜索算法 1  (搜索问题，深度优先搜索) - ShowMeAI
    - BV1AQ4y1y7wy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P2：L0- 搜索算法 1  (搜索问题，深度优先搜索) - ShowMeAI
    - BV1AQ4y1y7wy
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_0.png)'
- en: '[Music]。![](img/46e0108eee533ff10462be2a8cac4ce6_2.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[音乐]。![](img/46e0108eee533ff10462be2a8cac4ce6_2.png)'
- en: all right welcome everyone to an，introduction to artificial intelligence。with
    Python my name is Brian you and in，this class we'll explore some of the。ideas
    and techniques and algorithms that，are at the foundation of artificial。intelligence
    now artificial intelligence，covers a wide variety of types of。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎大家来到人工智能与Python的介绍课程，我的名字是布赖恩，在这节课中，我们将探索一些人工智能基础的思想、技术和算法。人工智能涵盖了多种类型。
- en: techniques anytime you see a computer do，something that appears to be intelligent。or
    rational in some way like recognizing，someone's face in a photo or being able。to
    play a game better than people can or，being able to understand human language。when
    we talk to our phones and they，understand what we mean and are able to。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到计算机做出某种看似智能或理性的事情，比如在照片中识别某人的脸，或能够比人类更好地玩游戏，或能够理解我们与手机对话时的语言，这些都是技术的表现。
- en: respond back to us these are all，examples of AI or artificial，intelligence and
    in this class we'll。explore some of the ideas that make that，AI possible so we'll
    begin our。conversations with search the problem of，we have an AI and we would
    like the AI。to be able to search for solutions to，some kind of problem no matter
    what that。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 回应我们，这些都是人工智能或人工智能的例子，在这节课中，我们将探讨使得这些人工智能成为可能的一些思想，因此我们将开始我们的讨论，搜索问题，即我们有一个人工智能，我们希望它能够搜索解决某种问题的方案，无论那是什么。
- en: problem might be whether it's trying to，get driving directions from point A
    to。![](img/46e0108eee533ff10462be2a8cac4ce6_4.png)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可能是无论它试图从A点到哪里获取行驶方向。![](img/46e0108eee533ff10462be2a8cac4ce6_4.png)
- en: point B or trying to figure out how to，play a game given a tic-tac-toe game
    for。![](img/46e0108eee533ff10462be2a8cac4ce6_6.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 点B或尝试弄清楚如何在给定的井字游戏中进行游戏。![](img/46e0108eee533ff10462be2a8cac4ce6_6.png)
- en: example figuring out what move it ought，to make after that we'll take a look
    at。![](img/46e0108eee533ff10462be2a8cac4ce6_8.png)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，弄清楚它应该做什么移动，然后我们将看一看。![](img/46e0108eee533ff10462be2a8cac4ce6_8.png)
- en: knowledge ideally we want our AI to be，able to know information to be able to。represent
    that information and more，importantly to be able to draw。inferences from that
    information to be，able to use the information it knows and。draw additional conclusions
    so we'll，talk about how a I can be programmed in。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 知识理想情况下，我们希望我们的人工智能能够知道信息，能够表示该信息，更重要的是，能够从这些信息中得出推论，能够利用它所知道的信息并得出额外的结论，因此我们将讨论如何对人工智能进行编程。
- en: order to do just that then we'll explore，the topic of uncertainty talking about。ideas
    of what happens if a computer，isn't sure about a fact but maybe is。only sure with
    a certain probability so，we'll talk about some of the ideas。behind probability
    and how computers can，begin to deal with uncertain events in。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将探讨不确定性的话题，讨论当计算机对某个事实不确定时会发生什么，也许它只对某个概率有把握，因此我们将讨论一些概率背后的思想，以及计算机如何开始处理不确定事件。
- en: order to be a little bit more，intelligent in that sense as well。after that we'll
    turn our attention to，optimization problems of when the。computer is trying to
    optimize for some，sort of goal especially in a situation。where there might be
    multiple ways that，a computer might solve a problem but。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这一意义上更加智能。之后我们将把注意力转向优化问题，当计算机试图优化某个目标时，尤其是在可能有多种方式解决问题的情况下。
- en: we're looking for a better way or，potentially the best way if that's at。![](img/46e0108eee533ff10462be2a8cac4ce6_10.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在寻找一种更好的方法，或者说潜在的最佳方法。![](img/46e0108eee533ff10462be2a8cac4ce6_10.png)
- en: all possible then we'll take a look at，machine learning or learning more。generally
    and looking at how when we，have access to data our computers can be。programmed
    to be quite intelligent by，learning from data and learning from。experience being
    able to perform a task，better and better。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都是可能的，那么我们将看看机器学习，或更一般的学习，以及当我们可以访问数据时，计算机如何能够通过从数据中学习和从经验中学习，被编程得非常智能，能够越来越好地执行任务。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_12.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_12.png)'
- en: based on greater access to data so your，email for example where your email inbox。somehow
    knows which of your emails are，good emails and whichever。emails are spam these
    are all examples，of computers being able to learn from。past experiences and past
    data well take，a look too at how computers are able to。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于更大的数据访问，因此，例如您的电子邮件，您的电子邮件收件箱以某种方式知道哪些电子邮件是好的，哪些电子邮件是垃圾邮件，这些都是计算机能够从过去的经验和数据中学习的示例，我们也将看看计算机如何能够。
- en: draw inspiration from human intelligence，looking at the structure of the human。brain
    and how neural networks can be a，computer analog to that sort of idea and。how
    by taking advantage of a certain，type of structure of a computer program。we can
    write neural networks that are，able to perform tasks very very。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从人类智能中汲取灵感，观察人脑的结构，以及神经网络如何成为计算机的类似物，如何利用某种类型的计算机程序结构，我们可以编写能够执行非常非常任务的神经网络。
- en: effectively and then finally we'll turn，our attention to language not。programming
    languages but human，languages that we speak every day and。taking a look at the
    challenges that，come about as a computer tries to。understand natural language
    and how it，is some of the natural language。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地，最后我们将关注语言，不是编程语言，而是我们每天使用的人类语言，并观察计算机理解自然语言时所面临的挑战，以及自然语言的一些。
- en: processing that occurs in modern，artificial intelligence can actually。![](img/46e0108eee533ff10462be2a8cac4ce6_14.png)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代人工智能中发生的处理实际上可以。![](img/46e0108eee533ff10462be2a8cac4ce6_14.png)
- en: work but today we'll begin our，conversation with search this problem of。trying
    to figure out what to do when we，have some sort of situation that the。computer
    is in some sort of environment，that an agent is in so to speak and we。would like
    for that agent to be able to，somehow look for a solution to that。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是今天我们将以搜索开始我们的对话，这个问题是试图弄清楚在某种环境中计算机处于什么情况，所谓的代理，希望该代理能够以某种方式寻找解决方案。
- en: problem now these problems can come in，any number of different types of formats。one
    example for instance might be，something like this classic 15 puzzle。with the sliding
    tiles that you might，have seen where you're trying to slide。![](img/46e0108eee533ff10462be2a8cac4ce6_16.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些问题可以有多种不同的格式。一个例子可能是经典的15拼图，您可能见过，它带有滑动的瓦片，您试图滑动。![](img/46e0108eee533ff10462be2a8cac4ce6_16.png)
- en: the tiles in order to make sure that all，the numbers line up in order this is
    an。example of what you might call a search，problem the 15 puzzle begins in an。initially
    mixed-up mixed-up state and we，need some way of finding moves to make。in order
    to return the puzzle to its，solved state but there are similar。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片的排列顺序，以确保所有数字都按顺序排列，这就是一个您可能称之为搜索问题的示例，15拼图从一个最初混乱的状态开始，我们需要某种方法找到移动的方式，以便将拼图恢复到已解决的状态，但还有类似的。
- en: problems you can frame in other ways，trying to find your way through a maze。for
    example is another example of a，search problem you begin in one place。you have
    some goal of where you're，trying to get to and you need to figure。out the correct
    sequence of actions that，will take you from that initial state to。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以用其他方式表述，试图找到穿越迷宫的道路，例如，是搜索问题的另一个示例，您从一个地方开始，目标是您想要到达的地方，您需要找出正确的行动顺序，使您从初始状态到达。
- en: the goal and while this is a little bit，abstract any time we talk about maze。solving
    in this class you can translate，it to something a little more real-world。something
    like driving directions if you，ever wonder how Google Maps is able to。figure out
    what is the best way for you，to get from point A to point B and what。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目标，尽管这有点抽象，每当我们在这门课中讨论迷宫解决时，您可以将其转换为更现实的东西，比如驾驶方向，如果您曾想知道谷歌地图如何能够找出您从A点到B点的最佳路径。
- en: turns to make it what time depending on，traffic for example it's often some
    sort。of search algorithm you have an AI that，is trying to get from an initial。position
    to some sort of goal by taking，some sequence of actions so we'll start。our conversations
    today by thinking，about these types of search problems and，like this。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于交通的时间，例如，它通常是某种搜索算法，您有一个人工智能，试图从初始位置到达某种目标，通过采取一系列动作，因此今天我们的对话将从思考这些类型的搜索问题开始，就像这样。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_18.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_18.png)'
- en: in order for an AI to be able to find a，good solution in order to do so though。![](img/46e0108eee533ff10462be2a8cac4ce6_20.png)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使AI能够找到好的解决方案，做到这一点。![](img/46e0108eee533ff10462be2a8cac4ce6_20.png)
- en: we're going to need to introduce a，little bit of terminology some of which。I've
    already used but the first term，we'll need to think about is an agent an。agent
    is just some entity that perceives，its environment it somehow is able to。perceive
    the things around it and act on，that environment in some way so in the。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引入一些术语，其中一些我已经使用过，但我们需要考虑的第一个术语是代理，代理只是一个感知其环境的实体，它能够以某种方式感知周围的事物并对环境采取行动。
- en: case of the driving directions your，agent might be some representation of a。car
    that it's trying to figure out what，actions to take in order to arrive at a。destination
    in the case of the 15 puzzle，with the sliding tiles the agent might。be the AI
    or the person that is trying，to solve that puzzle to try and figure。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在驾车导航的情况下，代理可能是汽车的一种表示，它试图弄清楚采取什么行动才能到达目的地；在15拼图中，移动瓷砖的代理可能是试图解决这个难题的AI或人。
- en: out what tiles to move it in order to，get to that solution next we introduce。the
    idea of a state a state is just some，configuration of the agent in its。environment
    so in the 15 puzzle for，example any state might be any one of。these three for
    example a state is just，some configuration of the tiles and each。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 找出要移动哪些瓷砖，以便达到解决方案，接下来我们引入状态的概念，状态只是代理在其环境中的某种配置。比如在15拼图中，任何状态可能是这三种之一，状态仅仅是瓷砖的某种配置。
- en: of these states is different and is，going to require a slightly different。solution
    a different sequence of actions，will be needed in each one of these in。order to
    get from this initial state to，the goal which is where we're trying to。get so
    the initial state thing what is，that the initial state is just the state。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态各不相同，并且每个状态都需要稍微不同的解决方案，每个状态所需的动作序列也会不同，以便从初始状态到达目标。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_22.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_22.png)'
- en: where the agent begins it is one such，state where we're going to start from。and
    this is going to be the starting，point for our search algorithms so to。speak we're
    going to begin with this。![](img/46e0108eee533ff10462be2a8cac4ce6_24.png)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代理开始的位置是其中一个状态，我们将从这里开始，这将是我们搜索算法的起点，可以这么说，我们将从此开始。
- en: initial state and then start to reason，about it to think about what actions。might
    we apply to that initial state in，order to figure out how to get from the。beginning
    to the end from the initial，position to whatever our goal happens to。be and how
    do we make our way from that，initial position to the goal well。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态之后，我们开始对其进行推理，思考对初始状态可能应用哪些动作，以便弄清楚如何从起始位置到达我们的目标，并且我们如何从初始位置走向目标。
- en: ultimately it's via taking actions，actions they're just choices that we can。make
    in any given state and in AI we're，always going to try to formalize these。ideas
    a little bit more precisely such，that we could program them a little bit。more
    mathematically so to speak so this，will be a recurring theme and we can。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，通过采取动作，我们可以做出在任何给定状态下的选择，在AI中，我们总是会尝试更精确地形式化这些思想，以便能够更数学化地编程。因此，这将是一个反复出现的主题。
- en: more precisely define actions as a，function we're going to effectively。define
    a function called actions that，takes an input s where s is going to be。some state
    that exists inside of our，environment and actions of s is going to。take the status
    input and return as，output the set of all actions that can。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地定义动作作为一个函数，我们将有效地定义一个称为动作的函数，它接受一个输入s，其中s将在我们的环境中存在某种状态，actions of s将接受状态输入并返回所有可以执行的动作集合作为输出。
- en: be executed in that state and so it's，possible that some action。are only valid
    in certain states and not，in other states and we'll see examples。of that soon
    too so in the case of the。![](img/46e0108eee533ff10462be2a8cac4ce6_26.png)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些状态下，某些动作是有效的，而在其他状态下则不是，我们很快会看到这方面的例子。在这种情况下，![](img/46e0108eee533ff10462be2a8cac4ce6_26.png)
- en: 15 puzzle for example they're generally，going to be four possible actions that。we
    can do most of the time we can slide，a tile to the right slide a tile to the。left
    slide our tile up or slide a tile，down for example and those are going to。be the
    actions that are available to us，so somehow our AI our program needs some。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以15拼图为例，通常会有四种可能的动作可以执行。大多数情况下，我们可以将一个方块滑到右边、滑到左边、向上滑动或向下滑动。例如，这些将是可用的动作，因此我们的AI或程序需要某种。
- en: encoding of the state which is often。![](img/46e0108eee533ff10462be2a8cac4ce6_28.png)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的编码通常是这样的。![](img/46e0108eee533ff10462be2a8cac4ce6_28.png)
- en: going to be in some numerical format and，some encoding of these actions but
    it。also needs some encoding of the，relationship between these things how do。the
    states in actions relate to one，another and in order to do that we'll。introduce
    to our AI a transition model，which would be a description of what。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将以某种数值格式呈现，并且对这些动作进行某种编码，但它也需要对这些事物之间的关系进行编码。状态与动作之间是如何相互关联的，为此我们将向我们的AI引入一个转换模型，这将描述什么。
- en: state we get after we perform some，available action in some other state and。again
    we can be a little bit more，precise about this define this，transition model a
    little bit more。formally again as a function the，function is going to be a function。called
    result that this time takes two，inputs input number one is s some state。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在执行某个可用动作后的状态，以及在其他状态中。我们可以更准确地定义这个转换模型，再稍微正式一些，再次定义为一个函数。这个函数将是一个名为result的函数，这次接受两个输入，输入数字一是某个状态s。
- en: and input number two is a some action，and the output of this function result。is
    it is going to give us the state that，we get after we perform action a in。state
    s so let's take a look at an，example to see more precisely what this，actually
    means。here's an example of a state of the 15，puzzle for example and here's an
    example。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数字二是某个动作，结果函数的输出将给我们在状态s中执行动作a后得到的状态。那么让我们看看一个例子，更精确地了解这实际上意味着什么。这是一个15拼图的状态示例，以下是一个例子。
- en: of an action sliding a tile to the right，what happens if we pass these as inputs。to
    the result function again the result，function takes this board this state as。its
    first input and it takes an action，as a second input and of course here I'm。describing
    things visually so that you，can see visually what the state is and。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个动作将一个方块滑到右边时，如果我们将这些作为输入传递给结果函数，结果函数将这个棋盘状态作为第一个输入，并将一个动作作为第二个输入，当然在这里我以视觉方式描述事物，以便你可以清楚地看到状态是什么。
- en: what the action ISM in a computer you，might represent one of these actions is。just
    some number that represents the，action or if you're familiar with enums。that allow
    you to enumerate multiple，possibilities it might be something like。that and this
    state might just be，represented as an array or，two-dimensional array of all of
    these。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，动作ISM可能代表这些动作之一。只是一些表示动作的数字，或者如果你熟悉枚举（enums），它可以让你枚举多个可能性，可能会是像这样的状态，这个状态可能只会被表示为一个数组或二维数组。
- en: numbers that exists but here we're going，to show it visually just so you can
    see。![](img/46e0108eee533ff10462be2a8cac4ce6_30.png)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 存在的数字，但在这里我们要以视觉方式展示它，这样你就能看到。![](img/46e0108eee533ff10462be2a8cac4ce6_30.png)
- en: it but when we take this state and this，action pass it into the result function。the
    output is a new state the state we，get after we take a tile and slide it to。the
    right and this is the state we get，as a result if we had a different action。and
    the different State for example and，pass that into the result function we'd。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们将这个状态和这个动作传递给结果函数时，输出是一个新的状态，我们在将一个方块滑到右边后得到的状态。如果我们有一个不同的动作和不同的状态，并将其传递给结果函数，我们将。
- en: get a different answer，altogether so the result function needs。to take care
    of figuring out how to take，a state and take an action and get what。results and
    this is going to be our，transition model that describes how it。is that states
    and actions are related，to each other if we take this transition。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 得到一个完全不同的答案，所以结果函数需要处理如何获取一个状态并采取一个动作来得到结果。这将是我们的转换模型，描述状态与动作之间是如何相互关联的。如果我们考虑这个转换。
- en: model and think about it more generally，and cross the entire problem we can
    form。what we might call a state space the set。![](img/46e0108eee533ff10462be2a8cac4ce6_32.png)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模型，想得更一般一些，跨越整个问题，我们可以形成一个我们称之为状态空间的集合。![](img/46e0108eee533ff10462be2a8cac4ce6_32.png)
- en: of all of the states we can get from the，initial state via any sequence of。![](img/46e0108eee533ff10462be2a8cac4ce6_34.png)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从初始状态通过任何序列获得的所有状态。![](img/46e0108eee533ff10462be2a8cac4ce6_34.png)
- en: actions by taking zero or one or two or，more actions in addition to that so
    we。could draw a diagram that looks，something like this，where every state is represented
    here by。a game board and there are arrows that，connect every state to every other
    state。we can get to from that state and the，state space is much larger than what
    you。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采取零个、一个、两个或更多的动作来实现的动作。因此，我们可以绘制一个类似这样的图表，其中每个状态通过一个游戏板表示，并且有箭头连接每个状态到所有其他状态。我们可以从那个状态到达的状态空间远比你在这里看到的要大得多。
- en: see just here this is just a sample of，what the state space might actually look。like
    and in general across many search，problems whether there this particular。15 puzzle
    or driving directions or，something else the state space is going。to look something
    like this we have，individual states and arrows that are。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是状态空间可能实际样子的一个示例，通常在许多搜索问题中，无论是这个特定的15拼图、驾驶方向还是其他东西，状态空间大致上都会像这样。我们有单独的状态和从一个状态到另一个状态的箭头，以及一个转移模型，定义了在我们采取特定动作后会发生什么。
- en: connecting them and oftentimes just for，simplicity we'll simplify our。representation
    of this entire thing as a，graph some sequence of nodes and edges。that connect
    nodes but you can think of，this more abstract representation as the。exact same
    idea each of these little，circles or nodes is going to represent。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们连接起来，通常为了简化，我们会将整个表示简化为图形，一系列连接节点的节点和边。但你可以将这种更抽象的表示视为完全相同的概念，每一个小圆圈或节点将代表。
- en: one of the states inside of our problem，and the arrows here represent the。actions
    that we can take in any，particular state taking us from one。particular state to
    another state for，example all right so now we have this。idea of nodes that are
    representing，these states actions that can take us。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们问题中的一个状态，这里的箭头表示我们在任何特定状态下可以采取的动作，将我们从一个特定状态转移到另一个状态。例如，现在我们有了表示这些状态的节点的概念，以及可以使我们达到特定目标的动作。
- en: from one state to another and a，transition model that defines what。happens after
    we take a particular，action so the next step we need to。figure out is how we know
    when the AI is，done solving the problem the AI needs。some way to know when it
    gets to the，goal that it's found the goal so the。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要弄清楚的下一步是，如何知道人工智能何时完成解决问题。人工智能需要某种方式来知道它到达了目标，找到了目标。
- en: next thing we'll need to encode into our，artificial intelligence is a goal test。some
    way to determine whether a given，state is a goal state in the case of。something
    like driving directions it，might be pretty easy if you're in a。state that corresponds
    to whatever the，user typed in as their intended，a goal State。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要在人工智能中编码的是一个目标测试。某种方式来确定给定状态是否为目标状态。以驾驶方向为例，如果你处于与用户输入的预期目标状态相对应的状态，可能就相当简单。
- en: in the 15 puzzle it might be checking，the numbers to make sure they're all in，ascending
    order。but the AG is some way to encode whether，or not any state that happen to
    be in is。a goal and some problems might have one，goal like a maze where you have
    one。initial position and one ending position，and that's the goal in other more。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在15拼图中，可能需要检查数字，以确保它们都是按升序排列的。但AG是某种方式来编码是否处于任何状态的目标，某些问题可能只有一个目标，比如迷宫，其中有一个初始位置和一个结束位置，那就是目标。
- en: complex problems you might imagine that，there are multiple possible goals that。there
    are multiple ways to solve a，problem and we might not care which one。the computer
    finds it as long as it does。![](img/46e0108eee533ff10462be2a8cac4ce6_36.png)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的问题中，你可能会想象有多个可能的目标，并且有多种方法来解决一个问题。我们可能不在乎计算机找到哪个目标，只要它能找到即可。![](img/46e0108eee533ff10462be2a8cac4ce6_36.png)
- en: find a particular goal however sometimes，a computer doesn't just care about。finding
    a goal but finding a goal well，or one with a low cost and it's for that。reason
    that the last piece of，terminology that we'll use to define。these search problems
    and is something，called a path cost you might imagine。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时计算机并不仅仅关心找到一个目标，而是要找到一个好的目标，或者说是一个成本较低的目标。因此，我们将用来定义这些搜索问题的最后一个术语是“路径成本”，你可以想象。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_38.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_38.png)'
- en: that in the case of driving directions，it would be pretty annoying if I said
    I。wanted directions from point A to point，B and the route that Google Maps gave
    me。was a long route with lots of detours，that were unnecessary that took longer。than
    it should have for me to get to，that destination and it's for that。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在驾驶方向的情况下，如果我说我想要从A点到B点的路线，而谷歌地图给我的路线是一个冗长的、有很多不必要绕路的路线，这会非常烦人，这样花费的时间比我到达目的地所需的时间要长。
- en: reason that when we're formulating，search problems will often give every。![](img/46e0108eee533ff10462be2a8cac4ce6_40.png)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在制定搜索问题时，我们通常会给每一个。![](img/46e0108eee533ff10462be2a8cac4ce6_40.png)
- en: path some sort of numerical cost some，number telling us how expensive it is
    to。take this particular option and then，tell our AI that instead of just finding。a
    solution some way of getting from the，initial state to the goal we'd really。like
    to find one that minimizes this，path cost that is less expensive or。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 路径有某种数值成本，告诉我们采取这个特定选项的代价，然后告诉我们的人工智能，我们不仅要找到从初始状态到目标的解决方案，我们确实希望找到一个能最小化路径成本的解决方案。
- en: takes less time or minimizes some other，numerical value we can represent this。graphically
    if we take a look at this，graph again and imagine that each of。these arrows each
    of these actions that，we can take from one state to another。state has some sort
    of number associated，with it that number being the path cost。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要的结果是用更少的时间或最小化某些其他数值，我们可以通过图形表示这一点，如果我们再次查看这个图，想象这些箭头，每个我们可以从一个状态到另一个状态的动作都有一个与之相关的数字，这个数字是路径成本。
- en: of this particular action where some of，the costs for any particular action。might
    be more expensive than the cost，for some other action for example。although this
    will only happen in some，sorts of problems in other problems we。can simplify the
    diagram and just assume，that the cost of any particular action。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定动作的情况是，任何特定动作的成本可能比其他某些动作的成本更高，例如。尽管这只会在某些问题中发生，在其他问题中，我们可以简化图示，假设任何特定动作的成本。
- en: is the same and this is probably the，case in something like the 15 puzzle for。example
    where it doesn't really make a，difference whether I'm moving right or。moving left
    the only thing that matters，is the total number of steps that I have。to take to
    get from point A to point B，and each of those steps is of equal cost。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这在15拼图之类的情况下可能是相同的，例如，移动向右或移动向左并没有太大区别，唯一重要的是从A点到B点所需的总步数，每一步的成本是相等的。
- en: we can just assume it's of some constant，cost like one and so this now forms
    the。basis for what we might consider to be a，search problem a search problem has
    some。sort of initial state some place where，we begin some sort of action that
    we can。take or multiple actions that we can，take in any given state and it has
    a。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设它的成本是某种常量，比如1，这就形成了我们可能考虑的搜索问题的基础，搜索问题有某种初始状态，我们开始的地方，有一些我们可以采取的动作或多种动作。
- en: transition model some way of defining，what happens when we go from one state。and
    take one action what state do we end，up with as a result in addition to that。we
    need some goal test to know whether，or not we've reached a goal and then we。need
    a path cost function that tells us，for any particular path by following。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡模型是定义从一个状态到另一个状态时采取某一动作后会发生什么，我们最终会处于什么状态。此外，我们需要一个目标测试，以了解我们是否已达到目标，然后我们需要一个路径成本函数，告诉我们通过任何特定路径的成本。
- en: some sequence of actions how expensive，is that path what is its cost in terms。of
    money or time or some other resource。![](img/46e0108eee533ff10462be2a8cac4ce6_42.png)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动作序列的路径有多昂贵，这条路径的成本在金钱、时间或其他资源方面是多少。![](img/46e0108eee533ff10462be2a8cac4ce6_42.png)
- en: that we are trying to minimize our user，job and the goal ultimately is to find
    a。solution where a solution in this case，is just some sequence of actions that。will
    take us from the initial state to，the goal State，and ideally we'd like to find
    not just。any solution but the optimal solution，which is a solution that has the
    lowest。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图最小化用户的工作，而最终的目标是找到一个解决方案，这里解决方案只是一些动作序列，将我们从初始状态带到目标状态，理想情况下，我们希望找到的不仅仅是任何解决方案，而是最优解决方案，即成本最低的解决方案。
- en: path cost among all of the possible，solutions and in some cases there might。be
    multiple optimal solutions but an，optimal solution just means that there。is no
    way that we could have done better。![](img/46e0108eee533ff10462be2a8cac4ce6_44.png)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可能的解决方案中，路径成本有时可能会存在多个最佳解决方案，但最佳解决方案仅意味着没有更好的方法来找到该解决方案。
- en: in terms of finding that solution so now，we've defined the problem and now we。begin
    need to begin to figure out how it，is that we're going to solve this kind。of search
    problem and in order to do so，you'll probably imagine that our。computer is going
    to need to represent a，whole bunch of data about this。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了问题，现在需要开始弄清楚我们将如何解决这种搜索问题。为此，你可能会想象我们的计算机需要表示与此相关的一整堆数据。
- en: particular problem we need to represent，data about where we are in the problem。and
    we might need to be considering，multiple different options at once and。oftentimes
    when we're trying to package，a whole bunch of data related to a state。together
    we'll do so using a data，structure that we're going to call a。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定问题，我们需要表示关于我们在问题中位置的数据，我们可能需要同时考虑多种不同的选项。通常，当我们试图将与某个状态相关的大量数据打包在一起时，我们将使用我们将称之为的数据结构。
- en: node a node is a data structure that is，just going to keep track of a variety
    of。different values and specifically in the。![](img/46e0108eee533ff10462be2a8cac4ce6_46.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一个数据结构，它将跟踪各种不同的值，特别是在这个情况下。
- en: case of a search problem it's going to，keep track of these four values in。particular
    every node is going to keep，track of a state the state we're。currently on and
    every node is also，going to keep track of a parent a parent。being the state before
    us or the node，that we used in order to get to this。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索问题的情况下，它将特别跟踪这四个值，每个节点将跟踪一个状态，即我们当前所在的状态，每个节点还将跟踪一个父节点，父节点是我们到达当前状态之前的状态，或者是我们用来到达这个状态的节点。
- en: current state and this is going to be，relevant because eventually once we。reach
    the goal node once we get to the，end we want to know what sequence of。actions
    we use in order to get to that，goal and the way we'll know that is by。looking
    at these parents to keep track，of what led us to the goal and what led。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态，这一点很重要，因为最终一旦我们到达目标节点，一旦我们到达终点，我们想知道我们为了到达该目标所采用的动作序列，而我们知道这一点的方法是查看这些父节点，以跟踪是什么引导我们到达目标，以及是什么引导。
- en: us to that state and what let us，to the state before that so on and so。forth
    backtracking our way to the，beginning so that we know the entire。sequence of actions
    we needed in order，to get from the beginning to the end the。note is also going
    to keep track of what，action we took in order to get from the。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 引导我们到该状态，以及让我们到达之前状态的路径，以此类推，回溯到开始，这样我们就知道从开始到结束所需的整个动作序列。节点还将跟踪我们采取了什么动作，以便从。
- en: parent to the current state and the note，is also going to keep track of a path。cost
    in other words it's going to keep，track of the number that represents how。long
    it took to get from the initial，state to the state that we currently。happen to
    be at and we'll see why this，is relevant as we start to talk about。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态的父节点，同时节点还将跟踪路径成本，换句话说，它将跟踪一个数字，该数字表示从初始状态到我们当前所在状态所花费的时间，随着我们开始讨论这个问题的相关性，我们将看到这一点。
- en: some of the optimizations that we can，make in terms of these search problems。more
    generally so this is the data，structure that we're going to use in。order to solve
    the problem and now let's，talk about the approach how might we。actually begin
    to solve the problem well，as you might imagine what we're going to。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这些搜索问题上进行的一些优化。更一般地说，这就是我们将要使用的数据结构，以解决问题。现在让我们谈谈方法，我们可能如何开始解决这个问题，正如你所想象的那样。
- en: do is we're going to start at one，particular state and we're just going to。explore
    from there the intuition is that，from a given state we have multiple。options that
    we could take and we're，going to explore those options and once。we explore those
    options will find that，more options than that are going to make。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个特定状态开始，只是从那里进行探索，直觉上，从给定的状态出发，我们有多个选择可供我们采取，我们将探索这些选项，一旦我们探索了这些选项，就会发现会有更多的选项。
- en: themselves available and we're going to，consider all of the available options
    to。be stored inside of a single data，structure that will call the frontier。the
    frontier is going to represent all，of the things that we could explore next。that
    we haven't yet explored or visited。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的节点，我们将考虑所有可用选项，将其存储在一个名为前沿的单一数据结构中。前沿将代表我们可以探索的所有事情，这些事情我们尚未探索或访问。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_48.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_48.png)'
- en: so in our approach we're going to begin，the search algorithm by starting with
    a。frontier that just contains one state，the frontier is going to contain the。initial
    state because at the beginning，that's the only state we know about that。is the
    only state that exists and then，our search algorithm is effectively。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法中，我们将通过一个仅包含一个状态的前沿开始搜索算法，前沿将包含初始状态，因为在开始时，这就是我们知道的唯一状态，也是唯一存在的状态，然后我们的搜索算法实际上是。
- en: going to follow a loop we're going to，repeat some process again and again and。again
    the first thing we're going to do，is if the frontier is empty then there's。no
    solution and we can report that there，is no way to get to the goal and that's。certainly
    possible there are certain，types of problems that an AI might try。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循一个循环，不断重复某个过程。首先，如果前沿是空的，那么就没有解决方案，我们可以报告没有办法到达目标，这当然是可能的，某些类型的问题可能是AI尝试解决的。
- en: to explore and realize that there is no，way to solve that problem and that's。useful
    information for humans to know as，well so if ever the frontier is empty。that means
    there's nothing left to，explore and we haven't yet found a。solution so there is
    no solution there's，nothing left to explore otherwise what。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要探索并意识到没有办法解决该问题，这对人类了解也是有用的信息，因此如果前沿为空，这意味着没有剩下的探索，我们尚未找到解决方案，因此没有解决方案，没有剩下的可探索内容，否则我们。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_50.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_50.png)'
- en: we'll do is we'll remove a node from the，frontier so our right now at the。beginning
    the frontier just contains one，node representing the initial state but。over time
    the frontier might grow it，might contain multiple states and so。here we're just
    going to remove a single，node from that frontier if that node。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前沿中移除一个节点，现在在开始时，前沿仅包含一个代表初始状态的节点，但随着时间推移，前沿可能会增长，可能包含多个状态，因此在这里我们只会从该前沿中移除一个节点。
- en: happens to be a goal then we found a，solution so we remove a node from the。frontier
    and ask ourselves is this the，goal and we do that by applying the goal。test that
    we talked about earlier asking，if we're at the destination or asking if。all the
    numbers of the 15 puzzle happen，to be in order so if the node contains。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该节点恰好是目标，那么我们找到了一个解决方案，因此我们从前沿中移除一个节点，并问自己这是目标吗，我们通过应用之前谈到的目标测试来实现，问我们是否到达了目的地，或者问15拼图的所有数字是否按顺序排列。
- en: the goal we found a solution，great we're done and otherwise what。we'll need
    to do is we'll need to expand，the node and this is a term of art in。artificial
    intelligence to expand the，node just means to look at all of the。neighbors of
    that node in other words，consider all of the possible actions。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是找到解决方案，太好了，我们完成了。否则，我们需要做的是扩展节点，这在人工智能中是一个专业术语，扩展节点意味着查看该节点的所有邻居，换句话说，考虑所有可能的行动。
- en: that I could take from the state that，this node is representing and what nodes。could
    I get to from there we're going to，take all of those notes the next nodes。that
    I can get to from this current one，I'm looking at and add those to the。frontier
    and then we'll repeat this，process so at a very high level the idea。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从这个节点所代表的状态采取的所有行动，以及我可以从那里到达哪些节点。我们将获取所有这些节点，即从当前节点可以到达的下一个节点，并将其添加到前沿，然后重复这一过程。总体来说，这个想法是。
- en: is we start with a frontier that，contains the initial State and we're。constantly
    removing a node from the，frontier looking at where we can get to。next and adding
    those nodes to the，frontier repeating this process over and。over until either
    we remove a node from，the frontier and it contains a goal。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个包含初始状态的前沿开始，不断从前沿中移除一个节点，查看我们可以到达的下一个节点，并将这些节点添加到前沿，重复这个过程，直到我们从前沿中移除一个节点并且它包含目标。
- en: meaning we've solved the problem，or we've run into a situation where the。frontier
    is empty at which point we're，left with no solution，so let's actually try and
    take the。pseudocode put it into practice by，taking a look at an example of a sample。search
    problem so right here I have a，sample graph a is connected to B via。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着我们已经解决了问题，或者我们遇到了一种情况，边界为空，此时我们就没有解决方案，所以让我们实际上尝试将伪代码付诸实践，看看一个示例搜索问题。因此，在这里我有一个示例图，a
    通过。
- en: this action B is connected to node C and，DSC is connected，edie is connected
    to F and what I'd like。to do is have my AI find a path from A，to E we want to
    get from this initial。state to this goal State so how are we，going to do that
    well we're going to。start with the frontier that contains，the initial State this
    is going to。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作 B 连接到节点 C，D 连接到 E，而 E 连接到 F，我希望我的 AI 找到从 A 到 E 的路径，我们想要从这个初始状态到达这个目标状态，那么我们将如何做到这一点呢？我们将从包含初始状态的边界开始。
- en: represent our frontier so our frontier，initially will just contain a that。initial
    state where we're going to begin，and now we'll repeat this process if the。frontier
    is empty no solution that's not，a problem because the frontier is not。empty so
    we'll remove a node from the，frontier as the one to consider next。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代表我们的边界，所以我们的边界最初只包含 a 这个初始状态，我们将开始，现在我们将重复这个过程，如果边界为空，没有解决方案，那不是问题，因为边界不为空，所以我们将从边界中移除一个节点，作为下一个考虑的节点。
- en: there's only one node in the frontier so，we'll go ahead and remove it from the。frontier
    but now a the，initial node this is node we're，currently considering we follow
    the next。step we ask ourselves is this node the，goal no it's not a is not the
    goal he is。the goal so we don't return the solution，so instead we go to this last
    step。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 边界中只有一个节点，所以我们将其从边界中移除，但现在 a 是初始节点，这就是我们当前考虑的节点。我们按照下一步进行，问自己这个节点是否是目标，不，它不是，a
    不是目标，而 e 是目标，所以我们不返回解决方案，因此我们转到最后一步。
- en: expand the node and add the resulting，nodes to the frontier what does that。mean
    well it means take this state a and，consider where we could get to next and。after
    a what we could get to next is，only B so that's what we get when we。expand a we
    find B and we add B to the，frontier and now B is in the frontier。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 展开节点并将结果节点添加到边界，这意味着什么呢？好吧，这意味着取这个状态 a 并考虑我们下一个可以到达的地方，a 后我们能到达的地方只有 B，因此这就是我们展开
    a 时得到的结果，我们找到 B，并将 B 添加到边界，现在 B 在边界中。
- en: and we repeat the process again we say，all right the frontier is not empty so。let's
    remove B from the frontier B is，now the node that we're considering we。ask ourselves
    is B the goal no it's not，so we go ahead and expand B and add its。resulting nodes
    to the frontier what，happens when we expand B in other words。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次重复这个过程，我们说，好吧，边界不为空，所以让我们从边界中移除 B，B 现在是我们正在考虑的节点。我们问自己，B 是目标吗？不，不是，所以我们继续展开
    B 并将其结果节点添加到边界。展开 B 会发生什么，换句话说。
- en: what nodes can we get to from B well we，can get to C and D so we'll go ahead
    and。add C and D from the frontier and now we，have two nodes in the frontier C
    and D。and we repeat the process again we，remove a node from the frontier for now。I'll
    do so arbitrarily just by picking C，we'll see why later how choosing which。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 B 到达哪些节点呢？我们可以到达 C 和 D，因此我们将继续从边界添加 C 和 D，现在边界中有两个节点 C 和 D。我们再次重复这个过程，从边界中移除一个节点，暂时我会任意选择
    C，稍后我们会看到选择哪个节点。
- en: node you removed from the frontier is，actually quite an important part of the。algorithm
    but for now I'll arbitrarily，remove seeing say it's not the goal so。we'll add
    e the next one to the frontier，then let's say I remove you from the。frontier and
    now I check I'm currently，looking at state e is that a goal State。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你从边界移除的节点实际上是算法中一个相当重要的部分，但现在我会任意移除它，因为说它不是目标，因此我们将下一个节点添加到边界，然后假设我从边界移除你，现在我检查一下，当前我正在查看的状态
    e 是否是目标状态。
- en: it is because I'm trying to find a path，from A to E so I would return the goal。and
    that now would be the solution that，I'm now able to return the solution and。I
    found a path from A to E so this is，the general idea the general approach of。this
    search algorithm to follow these，steps constantly removing nodes from the。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我正在尝试找到从 A 到 E 的路径，因此我将返回目标，现在这将是我能够返回的解决方案，我找到了从 A 到 E 的路径。因此，这是这个搜索算法的总体思路，遵循这些步骤，不断从边界中移除节点。
- en: frontier until we're able to find a，solution so the next question you might。reasonably
    ask is what could go wrong，here what are the potential problems。with an approach
    like this and here's。![](img/46e0108eee533ff10462be2a8cac4ce6_52.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前沿，直到我们能够找到一个解决方案，所以下一个你可能合理问的问题是，这里可能出什么问题，采用这种方法的潜在问题是什么。![](img/46e0108eee533ff10462be2a8cac4ce6_52.png)
- en: one example of a problem that could，arise from this sort of approach imagine。this
    same graph same as before with one，change the change being now instead of。![](img/46e0108eee533ff10462be2a8cac4ce6_54.png)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能出现的问题的例子是，想象一下这个与之前相同的图表，唯一的变化是现在而不是。![](img/46e0108eee533ff10462be2a8cac4ce6_54.png)
- en: just an arrow from A to B we also have，an arrow from B to a meaning we can go。in
    both directions and this is true in，something like the 15 possible where。when
    I slide a tile to the right I could，then slide a tile to the left to get。back
    to the original position I could go，back and forth between a and B and。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从A到B有一条箭头，我们也有从B到A的箭头，意味着我们可以双向移动，这在类似于15个可能的情况下是正确的，当我将一个拼图块向右滑动时，我可以然后向左滑动一个拼图块回到原来的位置，我可以在A和B之间来回移动。
- en: that's what these double arrows，symbolize the idea that from one state I。can
    get to another and then I can get，back and that's true in many search。problems
    what's going to happen if I try。![](img/46e0108eee533ff10462be2a8cac4ce6_56.png)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这些双箭头所象征的，从一个状态我可以到达另一个状态，然后我可以再回去，这在许多搜索问题中都是正确的，如果我尝试。![](img/46e0108eee533ff10462be2a8cac4ce6_56.png)
- en: to apply the same approach now we'll all，begin with a same as before and I'll。![](img/46e0108eee533ff10462be2a8cac4ce6_58.png)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将应用相同的方法，我们都将以之前的方式开始，我会。![](img/46e0108eee533ff10462be2a8cac4ce6_58.png)
- en: remove a from the frontier and then I'll，consider where I can get to from a
    and。after a the only place I can get to is B，so B goes into the frontier then
    I'll。say all right let's take a look at B，that's the only thing left in the。frontier
    where can I get to from B，before it was just C and D but now。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从前沿中移除A，然后我会考虑从A可以到达哪里，A之后我唯一可以到达的地方是B，因此B进入前沿，然后我会说，好吧，让我们看看B，这是前沿中剩下的唯一一项，我可以从B到达哪里，之前只是C和D，但现在。
- en: because of that reverse arrow I can get，to a or C or D so all three a C and
    D。all of those now go into the frontier，there are places I can get to from B and。now
    I remove one from the frontier and，you know maybe I'm unlucky and maybe I。pick
    a and now I'm looking at a again，and I consider where can I get to from a。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于那个反向箭头，我可以到达A、C或D，因此A、C和D这三者都进入前沿，我可以从B到达的地方，现在我从前沿移除一个，可能我运气不好，选择了A，现在我再次看着A，考虑我可以从A到哪里。
- en: and from a well I can get to B and now，we start to see the problem but if I'm。not
    careful I go from A to B and then。![](img/46e0108eee533ff10462be2a8cac4ce6_60.png)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从A到B我可以到达，现在我们开始看到问题，但如果我不小心，我从A到B然后。![](img/46e0108eee533ff10462be2a8cac4ce6_60.png)
- en: back to a and then to B again and I，could be going in this infinite loop。where
    I never make any progress because，I'm constantly just going back and forth。between
    two states that I've already，seen so what is the solution to this we。need some
    way to deal with this problem，and the way that we can deal with this。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回到A，然后再次到B，我可能会陷入这个无限循环中，永远无法取得进展，因为我一直在两个我已经见过的状态之间来回移动。那么这个问题的解决方案是什么？我们需要某种方法来处理这个问题，我们可以处理这个问题的方式是。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_62.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_62.png)'
- en: problem is by somehow keeping track of，what we've already explored and the。logic
    is going to be well if we've，already explored the state there's no。reason to go
    back to it once we've，explored a state don't go back to it。don't bother adding
    it to the frontier。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过某种方式跟踪我们已经探索过的内容，逻辑是，如果我们已经探索过该状态，就没有理由再回去，一旦我们探索了一个状态，就不要再回去，不要再将其添加到前沿。
- en: '![](img/46e0108eee533ff10462be2a8cac4ce6_64.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e0108eee533ff10462be2a8cac4ce6_64.png)'
- en: there's no need to so here is going to，be our revised approach a better way
    to。approach this sort of search problem and，it's going to look very similar just。with
    a couple of modifications we'll，start with a frontier that contains the。initial
    state same as before but now，we'll start with another data structure。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要这样，所以这将是我们修订的方法，一个更好的解决此类搜索问题的方法，虽然看起来非常相似，只是进行了几处修改，我们将从一个包含初始状态的前沿开始，与之前相同，但现在我们将使用另一种数据结构。
- en: which will just be a set of nodes that，we've already explored so what are the。states
    we've explored initially it's，empty we have an empty explored set and。now we repeat
    if the frontier is empty，no solution same as before we remove a。node from the
    frontier we check to see，if it's a goal state returned the。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只是我们已经探索过的一组节点，那么我们最初探索过的状态是什么呢？它是空的，我们有一个空的已探索集合。现在我们重复，如果边界为空，则没有解决方案，和之前一样，我们从边界中移除一个节点，检查它是否是目标状态，返回。
- en: solution none of this is any different，so far but now what we're going to do
    is。we're going to add the node to the，explored state so if it happens to be，frontier。and
    it's not the goal we'll add it to，the explored set so that we know we've。already
    explored it we don't need to go，back to it again if it happens to come。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案到目前为止没有任何不同，但现在我们要做的是将节点添加到已探索状态中，因此如果它恰好在边界中并且不是目标，我们将其添加到已探索集合中，这样我们就知道我们已经探索过它，不需要再返回。
- en: up later and then the final step we，expand the node and we add the resulting。nodes
    to the frontier but before we just，always added the resulting nodes to the。frontier
    we're gonna be a little clever，about it this time we're only going to。add the
    nodes to the frontier if they，aren't already in the frontier and if。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后一步是扩展节点，并将结果节点添加到边界，但在我们之前总是将结果节点添加到边界时，这次我们会聪明一点，仅当节点不在边界中时才添加它们。
- en: they aren't already in the explored set，so we'll check both the frontier and
    the。explored set make sure that the node，isn't already in one of those two and
    so。long as it isn't then we'll go ahead and，add it to the frontier but not otherwise。and
    so that revised approach is，ultimately what's going to help make。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还不在已探索集合中，所以我们会检查边界和已探索集合，确保节点不在这两者中，只要不在，我们就可以将其添加到边界，否则就不添加。因此，这种修订后的方法是**最终**能帮助我们。
- en: sure that we don't go back and forth，between two nodes now the one point that。I've
    kind of glossed over here so far is，this step here removing a node from the。frontier
    before I just chose arbitrarily，like let's just remove a node and that's。it but
    it turns out it's actually quite，important how we decide to structure our。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们不在两个节点之间来回移动，现在我这里有一点我到目前为止略过了，那就是在移除节点之前的这一步。我之前随意选择了一个节点进行移除，但事实证明，我们如何决定构建我们的结构实际上是相当重要的。
- en: frontier how we Adam and how we remove，our nodes the frontier is a data。structure
    and we need to make a choice，about in what order are we going to be。removing elements
    and one of the，simplest data structures for adding and。removing elements is something
    called a，stack and a stack is a data structure。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 边界是一个数据结构，我们需要选择我们将以什么顺序移除元素，而添加和移除元素的最简单数据结构之一是栈，栈是一种数据结构。
- en: that is a last in first out data type，which means the last thing that I add
    to。the frontier is going to be the first，thing that I remove from the frontier
    so。the most recent thing to go into the，stack or the frontier in this case is。![](img/46e0108eee533ff10462be2a8cac4ce6_66.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种后进先出的数据类型，这意味着我最后添加到边界的东西将是我从边界中移除的第一个东西。因此，在这种情况下，最后进入栈或边界的东西是！[](img/46e0108eee533ff10462be2a8cac4ce6_66.png)
- en: going to be the node that I explore so，let's see what happens if I apply this。stack
    based approach to something like，this problem finding a path from A to E。what's
    going to happen well again we'll，start with a and we'll say all right。let's go
    ahead and look at a first and，then notice this time we've added a to。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我探索的节点，所以让我们看看如果我将这种基于栈的方法应用到这样的一个问题上，即从A到E寻找路径，会发生什么。我们将从A开始，并说好，让我们先看A，然后注意到这次我们添加了A。
- en: the explored set a is something we've，now explored we have this data structure。that's
    keeping track we then say from a，we can get to B and alright from B what。can we
    do well from B we can explore B，and get to both C and D so we added C。and then
    D so now when we explore a node，we're going to treat the frontier as a。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 已探索集合A是我们现在已经探索过的东西，我们有这个数据结构在跟踪。然后我们说从A可以到达B，好的，从B我们可以做什么呢？从B我们可以探索B，并到达C和D，因此我们添加了C和D。所以现在当我们探索一个节点时，我们将边界视为一个。
- en: stack last in first out D was the last，explore，that next and say alright where
    can we。get to from D well we can get to F and，it's alright we'll explore it put
    F into。the frontier and now because the，frontier is a stack F is the most recent。thing
    that's gone in the stack so F is，what we'll explore next we'll explore F。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是后进先出，D是最后被探索的节点，接下来我们说，好吧，我们能从D到达哪里？我们可以到达F，没问题，我们会探索它，把F放入前沿，现在因为前沿是一个栈，F是最近进入栈的元素，所以F是我们接下来要探索的节点。
- en: and say alright where can we get do from，F well we can't get anywhere so nothing。gets
    added to the frontier so now what，was the new most recent thing added the。frontier
    well it's now see the only，thing left in the frontier we'll explore。that from
    which we can see all right，from C we can get to e so e goes into。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们说，好吧，我们能从F到达哪里？我们什么地方也去不了，所以前沿没有新元素被添加。那么现在最近添加到前沿的元素是什么？现在是C，前沿中唯一剩下的元素，我们将从C进行探索，从中可以看到，从C我们可以到达E，所以E被放入。
- en: the frontier and then we say alright，looks like an E and E is now the。solution
    and now we've solved the，problem so when we treat the frontier。like a stack a
    last in first out data，structure that's the result we get we go。from A to B to
    D to F and then we sort，of backed up and went down to C and then。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前沿中，我们说，好吧，E看起来是个选项，E现在是解决方案，我们已经解决了问题。因此，当我们把前沿视为一个栈，一个后进先出的数据结构时，得到的结果是从A到B再到D再到F，然后我们稍微退回，去探索C。
- en: e and it's important to get a visual，sense for how this algorithm is working。we
    went very deep in this search tree so，to speak all the way until the bottom。where
    we hit a dead end and then we，effectively backed up and explore this。other route
    that we didn't try before，and it's this going very deep in the。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: E，重要的是要对这个算法的工作方式有一个直观的理解。我们在这个搜索树中走得非常深，直到底部，遇到了死胡同，然后我们有效地退回，探索另一条之前未尝试的路径，这种方式在搜索中深入很重要。
- en: search tree idea this way the algorithm，ends up working when we use a stack
    that。we call this version of the algorithm，depth-first search depth-first search
    is。the search algorithm where we always，explore the deepest node in the frontier。![](img/46e0108eee533ff10462be2a8cac4ce6_68.png)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索树的理念是这样的，算法在我们使用栈时能够工作。我们称这种算法的版本为**深度优先搜索**。深度优先搜索是一种搜索算法，我们始终探索前沿中最深的节点。![](img/46e0108eee533ff10462be2a8cac4ce6_68.png)
- en: we keep going deeper and deeper through，our search tree and then if we hit a。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在搜索树中不断深入，如果遇到一个...
