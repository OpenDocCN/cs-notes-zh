CSE 331 软件设计与实现

# 测试指南

内容：

+   测试类型

    +   测试了多少

    +   正在测试的规范级别

    +   你知道实现吗？

        +   黑盒测试

        +   白盒测试

        +   讨论

    +   将测试分类方式进行比较

+   如何测试私有方法

+   测试方法论

    +   开始编写代码之前

    +   编写实现代码后

+   测试提示

+   测试代码重用

测试增加了我们对代码行为正确（即符合提供的规范）的信心。然而，测试只能证明错误**存在**，而不能证明程序没有错误。实际上，测试通常是在程序中找到错误的最实际和有效的方法。

调试是与测试不同的活动。

## 测试类型

测试可以根据各种方式进行分类，包括：

+   测试了多少代码：单元测试 vs. 系统测试

+   正在测试的规范级别：规范测试 vs. 实现测试

+   在编写测试时，你是否知道实现：黑盒测试 vs. 白盒测试

### 测试了多少

**单元测试**是对一个组件的测试。如果一个单元测试失败，你不必花费很多时间来定位缺陷，因为你确切地知道缺陷在哪里：在被测试的组件中。单元测试帮助你确保你正在用可靠的构件构建系统。通常，一个单元测试测试一个类的一个方法。然而，如果一个测试将注意力集中在一个类或一个包上，那么它也可以是一个单元测试 — 只要它比正在测试的整个系统小即可。

**系统测试**或**集成测试**是对整个系统是否正常工作的测试 — 即（单独正确、经过单元测试的）模块是否组合在一起实现了正确的功能。系统测试通常涉及比单元测试更复杂的操作。一个例子是读取定义了一些操作的文件，执行这些操作，写出一个结果文件，并将结果文件与经过手工检查和验证为正确的版本（称为*目标文件*或*黄金文件*）进行比较。

你应该先运行单元测试，然后只有在所有单元测试成功时才运行系统测试。通常最好先编写系统测试，甚至在你知道如何将实现模块化之前。

### 正在测试的规范级别

当你编写一个组件时，你是为了满足一些外部可见的需求，并且它具有客户端可以依赖的行为。这就是它的规范。你随系统交付的测试帮助客户端确信你的实现符合其公共规范。

实现实际上可能满足更强的规范。

+   实现可能被设计来加强公共规范的某些部分。例如，一个允许以任意顺序返回列表的例程可能总是以排序顺序返回列表。或者，一个实现可能对超出公共前置条件（`requires`子句）的输入有明确定义的行为。

+   一个实现可能比规范要求的组件更多。例如，一个类可能有额外的方法。或者，实现可能有辅助类。每个辅助类都有自己的规范，但客户端不知道，也不能使用或依赖这些辅助类。

客户端不能依赖于实现的额外属性，通常甚至不知道它们！然而，你可能希望确保你的实现满足这些属性，作为确保它符合你的设计的双重检查。这样的测试不应该暴露给客户端 — 它们是实现者的内部调试辅助。

另一种思考方式是规范具有不同的可见级别。例如，客户端可能只关心文件以特定格式读取和写入。这形成了一个规范级别。在设计程序以读取和写入这些文件时，工程师应该为他们使用的每个类中的每个公共方法编写规范（即通过 Javadoc 风格的代码注释）。这形成了另一个规范级别，比客户端规范更强。你应该在每个规范级别测试你的代码。

在 CSE 331 中，对于客户端（员工）规范级别的任何测试都应该由`SpecificationTests.java`调用。对于员工没有提供的规范的测试（即你设计的规范），应该放在`ImplementationTests.java`中。

这里有一个很好的指导原则：如果你的测试可以编译并运行作为对任何其他学生代码的有效测试，那么它应该放在`SpecificationTests.java`中。否则，它应该放在`ImplementationTests.java`中。

如果实现发生变化，你的实现测试可能会变得无效。然而，只要规范不变，你的规范测试将保持有效。它们保持有效，但你可能希望添加新的黑盒规范测试，以确保你的规范测试对你的实现有良好的覆盖率。

通常应首先编写规范测试。然后，添加实现测试以覆盖规范测试未涵盖的重要功能。有时，一个组件不需要实现测试，因为实现中没有任何规范测试未涵盖的额外内容；这是可以接受的，你不需要重复测试功能。有时，一个组件没有规范测试，因为在规范中看不到它。

### 你知道实现吗？

#### 黑盒测试

黑盒测试是在除规范外不了解任何内容的情况下编写的。

与透明盒测试相比，它们的优势在于，它们不太可能受到与规范相关的误解的影响，这可能导致实现中的错误。在许多情况下，黑盒测试是由不是编写实现的人编写的。黑盒测试可以在实现之前或同时编写。

黑盒测试应该首先编写，但通常单独编写的测试通常不足够。黑盒测试可能不覆盖（即，执行或执行）实现的所有部分，因此可能会错过错误。

它们还未能测试实现比规范更强的地方的具体内容。（这需要编写一个实现测试。）

#### 透明盒测试

透明盒测试是在完全了解实现的情况下编写的。

规范的透明盒测试具有一个优势，即能够测试实现中的特殊情况是否符合规范，即使这些情况在规范中并不特别。

透明盒测试的缺点在于，人们在编写透明盒测试时很可能会犯与编写被测试方法时相同的错误。这可能导致测试通过，而实际上规范并未被准确遵循。此外，如果实现更改，则透明盒规范测试仍然是有效的测试，但可能不再提供良好的覆盖。

#### 讨论

黑盒测试和透明盒测试测试*相同*的规范。每个测试对于该规范的任何实现都是有效的。唯一的区别是您用于决定测试输入的方法。当您的实现更改时，重复使用透明盒测试是完全可以的。（为什么要丢弃测试？）但是，您可能需要添加一些额外的透明盒测试以确保对新实现的良好覆盖。

您应该首先编写黑盒测试，然后根据需要添加透明盒测试，如果黑盒测试未涵盖实现行为。

### 关于测试分类的关系

单元测试与系统测试、规范测试与实现测试以及黑盒测试与白盒测试的概念是**完全正交**的。您可以有所有 8 种测试的变体 —— 尽管您可能不会在测试套件中明确地区分所有这些 8 种变体。

单元测试通常但不总是是实现测试，系统测试是规范测试。然而，如果规范足够详细，可以进行单元规范测试，并进行系统实现测试（如果您的实现比公共文档要求的规范更强）。无论测试的其他细节如何，都可以采用黑盒和白盒方法来生成测试输入数据。

## 如何测试私有方法

测试是在与被测试代码不同的类中编写的 —— 这样可以区分不同的关注点，并且使得测试不会使代码混乱。然而，这样做将无法直接测试私有方法，因为它们在所在的类之外是不可访问的。（当测试位于与被测试代码不同的包中时，对具有受保护或默认可访问性的方法也会出现类似的问题。在 JUnit 4 中，通过使用子类化，可以测试非 final 类的受保护（但不是私有）方法。）

假设您想测试一个私有方法。真的没有一个好方法来做到这一点。Bill Venners 提出了四种方法（http://www.artima.com/suiterunner/private.html 提出了建议）。（这是对他总结的重新措辞，以便更清晰。）第一种方法间接测试私有方法，后三种方法直接测试私有方法。

+   设计测试公共方法，以练习私有方法的所有功能。

+   将方法设为非私有，并编写正常的测试。

+   在类内部编写测试，其中可以访问私有方法。

+   使用反射来规避 Java 对私有方法的访问限制。

我们推荐第一种方法。它创建了一个规范测试，即使您的实现发生变化，它也将继续有用。由于私有方法设计用于特定目的，应该可以通过对公共方法的调用来练习其所有功能。如果私有方法中有更多功能，则与系统行为无关，可能应该删除。

要使用第三种方法，您将在与方法本身相同的类中编写测试，使用更高的可见性的方法。例如，要测试私有方法 `foo`，您将编写一个名为 `testFoo` 的公共方法。`testFoo` 的规范与 `checkRep`（另一个公共方法，测试类的私有、不可访问的细节）相同。这两者都不接受任何参数，也不返回任何结果，但如果其任何测试失败，则抛出异常。

其他方法不太理想。将方法设为公共会破坏模块化，客户端可能会依赖于它，限制实现者的灵活性。使用反射暂时将方法设为公共是丑陋且难以理解的。不测试方法甚至更糟，因为在仅通过调用它们的方法的不正确行为暴露时，辅助方法中的错误可能更难调试。

如果选择直接测试私有方法，使用最后三种方法之一，那么请确保将其放在实现测试中，而不是规范测试中。

此外，在所有方法中编写断言（包括 checkRep）总是一个好主意。编写断言与编写测试用例是正交的。

## 测试方法论

### 在开始编写代码之前

+   使用规范来确定每个非平凡的公共方法的抽象值域：该方法可以在哪些对象上调用，以及允许的输入��合是什么？

+   将每个领域划分为“相似案例”。例如，如果领域包含一个数字，那么该方法是否仅在正数、奇数等上操作？

+   为`SpecificationTests.java`中的每个非平凡的公共方法编写黑盒单元测试。

### 在编写实现后

+   作为您实现的第一件事之一，编写一个私有的`checkRep()`方法，并在每个非平凡的公共非构造方法的入口和出口处调用它（以及在所有构造函数的出口处）。如果只使用不可变对象和`final`字段，那么您可以在构造函数之后直接调用`checkRep()`。

+   在合理的情况下，为`ImplementationTests.java`中的规范和实现编写清晰的盒子测试。

## 测试提示

+   在定义测试套件的类的构造函数中，*不要*包含（定义或运行）任何实际测试。实际上，测试套件构造函数甚至不应构造被测试的类的实例 —— 将其留给定义测试的代码。测试套件构造函数应该设置任何在所有测试中有用的记账信息，如果没有也没关系。

+   编写小测试。这样，如果测试失败，您将知道当时发生了什么。

+   为您的测试选择好的名称，使用适当的断言方法的实例，并编写好的消息。这将确保您需要调试测试失败时所需的所有信息都存在。

+   仔细考虑每个测试。不要编写规范测试，但意外地将其称为实现测试。不要仅将您的解决方案用作预言，而要仔细考虑替代解决方案是否正确（例如，对于给定图形是否存在多个最短路径？）。

+   记住，测试需要编写清晰、简洁和有针对性的测试，而不仅仅是提出任意数量的随机示例。

## 测试代码重用

就像在程序中抽象和重用是好的一样，在测试中也是好的。我们鼓励您重复使用！

只需注意不要掩盖错误的原因。这可能发生是因为你没有测试一个特定的方法，所以很难隔离代码错误（或测试中的错误）。如果你仔细构建你的测试，你可以避免这个问题。
