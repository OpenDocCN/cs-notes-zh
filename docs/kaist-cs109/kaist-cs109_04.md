# 数字表示

让我们再看看我的 Collatz 代码。记住，猜想是 Collatz 序列总是以一结束。我们用一些较大的数字来测试这个：

```
$ ktc
>>> :load collatz3.kts
>>> findMax(100000)
Starting at 77031 needs 350 steps.
>>> findMax(110000)
Starting at 106239 needs 353 steps.
>>> findMax(113000)
Starting at 106239 needs 353 steps.
>>> findMax(114000)

```

此时程序似乎陷入了无限循环！

但这意味着我们没有达到数字一——我们成功找到了 Collatz 猜想的一个反例吗？让我们尝试找到导致无限序列的起始值。这是一个新的函数来做到这一点（[collatz4.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz4.kts)）：

```
fun collatzBounded(n0: Int, steps: Int): Int {
  var n = n0
  var count = 0
  while (n != 1 && count < steps) {
    n = next(n)
    count += 1
  }
  return count
}

fun findLong(n: Int, steps: Int) {
  for (i in 2 .. n) {
    val count = collatzBounded(i, steps)
    if (count >= steps) { 
      println("Starting at $i needs $count steps.")
    }
  }
}

```

让我们试试：

```
>>> :load collatz4.kts
>>> findLong(114000, 1000)
Starting at 113383 needs 1000 steps.
>>> findLong(114000, 10000)
Starting at 113383 needs 10000 steps.
>>> findLong(114000, 100000)
Starting at 113383 needs 100000 steps.
>>> findLong(114000, 1000000)
Starting at 113383 needs 1000000 steps.

```

从 113383 开始似乎会导致一个无限序列！让我们打印出这个序列中的前几个数字。我在 collatzBounded 中添加了一个打印语句（[collatz5.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz5.kts)）：

```
fun collatzBounded(n0: Int, steps: Int): Int {
  var n = n0
  var count = 0
  while (n != 1 && count < steps) {
    print("$n ")
    n = next(n)
    count += 1
  }
  println()
  return count
}

```

输出是这样的：

```
>>> collatzBounded(113383, 200)
113383 340150 170075 510226 255113 765340 382670 191335 574006 287003
861010 430505 1291516 645758 322879 968638 484319 1452958 726479
2179438 1089719 3269158 1634579 4903738 2451869 7355608 3677804
1838902 919451 2758354 1379177 4137532 2068766 1034383 3103150 1551575
4654726 2327363 6982090 3491045 10473136 5236568 2618284 1309142
654571 1963714 981857 2945572 1472786 736393 2209180 1104590 552295
1656886 828443 2485330 1242665 3727996 1863998 931999 2795998 1397999
4193998 2096999 6290998 3145499 9436498 4718249 14154748 7077374
3538687 10616062 5308031 15924094 7962047 23886142 11943071 35829214
17914607 53743822 26871911 80615734 40307867 120923602 60461801
181385404 90692702 45346351 136039054 68019527 204058582 102029291
306087874 153043937 459131812 229565906 114782953 344348860 172174430
86087215 258261646 129130823 387392470 193696235 581088706 290544353
871633060 435816530 217908265 653724796 326862398 163431199 490293598
245146799 735440398 367720199 1103160598 551580299 1654740898
827370449 -1812855948 -906427974 -453213987 -1359641960 -679820980
-339910490 -169955245 -509865734 -254932867 -764798600 -382399300
-191199650 -95599825 -286799474 -143399737 -430199210 -215099605
-645298814 -322649407 -967948220 -483974110 -241987055 -725961164
-362980582 -181490291 -544470872 -272235436 -136117718 -68058859
-204176576 -102088288 -51044144 -25522072 -12761036 -6380518 -3190259
-9570776 -4785388 -2392694 -1196347 -3589040 -1794520 -897260 -448630
-224315 -672944 -336472 -168236 -84118 -42059 -126176 -63088 -31544
-15772 -7886 -3943 -11828 -5914 -2957 -8870 -4435 -13304 -6652 -3326
-1663 -4988 -2494 -1247 -3740 -1870 -935 -2804 -1402 -701 -2102 -1051
-3152 -1576 -788 -394 200

```

这是什么？为什么有负数？最后一个正数是 827370449，所以让我们看看发生了什么：

```
>>> next(827370449)
-1812855948

```

哎呀！我们下一个函数的定义是错的吗？

```
>>> 827370449 * 3
-1812855949

```

不，看来 Kotlin 的算术出了问题！

原来你必须小心处理 Int 整数对象。Int 整数有 32 位，因此最大可能的 Int 值是 \(2^{31} - 1\)。你也可以将这个最大值表示为 Int.MAX_VALUE。但 \(3 \cdot 827370449\) 比这个值大。我们可以通过长算术来计算该值进行检查。Long 是具有 64 位的整数。你可以使用 toLong() 方法将整数转换为 Long，或者在字面整数后面简单地写一个 L：

```
>>> next(827370449)
-1812855948
>>> 827370449 * 3
-1812855949
>>> Int.MAX_VALUE
2147483647
>>> 827370449 * 3
-1812855949
>>> 827370449.toLong() * 3
2482111347
>>> 827370449L * 3
2482111347
>>> Int.MAX_VALUE
2147483647
>>> Long.MAX_VALUE
9223372036854775807

```

#### 数字是如何表示的

整数使用固定数量的位表示，如下所示：

| Long | 64 位 |
| --- | --- |
| Int | 32 位 |
| Short | 16 位 |
| 字节 | 8 位 |

对这些类型的算术是通过使用固定长度的寄存器的硬件执行的。例如，想象一下我们有一种具有四位的整数类型，并且我们执行一些加法：

```
 0010 = 2
+0111 = 7
---------
 1001 = 9

 1001 = 9
+0111 = 7
---------
 0000 = 0

```

由于寄存器只有四位，当你相加 \(9 + 7\) 时发生的溢出无法表示，结果不是 \(10000 = 16\) 而是 \(0000 = 0\)。

换句话说，整数加法和减法实际上是模 \(2^{k}\) 加法和减法，其中 \(k\) 是位数。对于我们的四位数据类型，加法是模 16，因此 \(9 + 7 = 0\)。

这实际上很方便，因为它允许我们使用负数而不需要任何额外的硬件：例如，由于 \(-1 \equiv 15\)（模 16），我们可以通过添加 \(15\) 来减去一个数：

```
 0101 = 5
+1111 = 15 = -1
---------------
 0100 = 4

 0111 = 7
+1100 = 12 = -4
---------------
 0011 = 3

```

当结果为 \(1111\) 时，如何确定输出表示什么数字。当结果为 \(1111\) 时，是表示 \(15\) 还是表示 \(-1\)？

标准惯例是说当第一位是一时，数字为负。换句话说，\(1000 ... 1111\) 是 \(-8\) 到 \(-1\)，而 \(0000 ... 0111\) 是 \(0\) 到 \(7\)：

```
0111 = 7
0110 = 6
0101 = 5
0100 = 4
0011 = 3
0010 = 2
0001 = 1
0000 = 0
1111 = -1
1110 = -2
1101 = -3
1100 = -4
1011 = -5
1010 = -6
1001 = -7
1000 = -8

```

这很方便，因为检测一个数字是否为负数非常容易，但这只是一种约定。一些编程语言（如 C 和 C++）也有无符号整数，其中\(0000 ... 1111\)表示\(0\)到\(15\)。原则上，我们也可以说\(1100 ... 1111\)表示\(-4\)到\(-1\)，而\(0000 ... 1011\)表示\(0\)到\(11\)。

在我们上面的例子中，我们进行了乘法运算\(3 * 827370449 = 2482111347\)。在二进制中，这是

```
11 * 00110001010100001010101111010001 = 
     10010011111100100000001101110011

```

结果的第一位是\(1\)，因此被视为负数。

您可以在[这里](http://www.swarthmore.edu/NatSci/echeeve1/Ref/BinaryMath/NumSys.html)了解更多关于数字表示的信息。
