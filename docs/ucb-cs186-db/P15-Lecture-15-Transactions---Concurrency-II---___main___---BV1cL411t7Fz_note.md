![](img/eae5e6a7bf6abaacd589335a2e1dca71_1.png)

# 📚 课程 P15：第15讲 事务与并发 II

在本节课中，我们将继续学习数据库事务的隔离性保证。我们将深入探讨调度的正确性概念，特别是**可串行化**及其更实用的变体——**冲突可串行化**。我们还将了解如何通过**锁**和**两阶段锁定协议**来实现这些概念，并讨论死锁的避免与检测方法。

---

## 🔍 回顾：调度与可串行化

上一节我们介绍了事务调度的基本概念。调度是一个或多个事务对数据项的操作序列。为了定义正确性，我们以**串行调度**为基准，即事务完全按顺序执行，互不干扰。

如果两个调度包含相同的事务集，且每个事务内部的操作顺序相同，并最终使数据库达到相同状态，则这两个调度是**等价**的。

一个调度被认为是**可串行化**的，如果它等价于某个串行调度。这意味着即使操作交错执行，其最终效果也与完全隔离的串行执行相同。

---

## ⚖️ 冲突可串行化

检查一个调度是否可串行化是困难的。因此，我们引入一个更保守但更易检查的概念：**冲突可串行化**。

首先，我们定义**冲突操作**。如果两个操作满足以下条件，则它们冲突：
1.  来自不同的事务。
2.  操作同一个数据对象。
3.  至少有一个是写操作。

冲突操作会引入事务间的排序依赖。非冲突操作的顺序交换不会影响数据库的最终状态。

基于此，我们定义**冲突等价**：如果两个调度涉及相同的事务和操作，且每一对冲突操作的执行顺序都相同，则它们冲突等价。

一个调度是**冲突可串行化**的，如果它与某个串行调度冲突等价。冲突可串行化是可串行化的一个子集，它更保守，但更容易通过算法进行检查。

---

### 如何检查冲突可串行化？

检查冲突可串行化的一个有效方法是构建**优先图**（或称冲突依赖图）。

![](img/eae5e6a7bf6abaacd589335a2e1dca71_3.png)

![](img/eae5e6a7bf6abaacd589335a2e1dca71_5.png)

以下是构建步骤：
1.  为调度中的每个事务创建一个节点。
2.  对于每一对冲突操作 `Oi`（来自事务 `Ti`）和 `Oj`（来自事务 `Tj`），如果 `Oi` 在调度中先于 `Oj` 执行，则添加一条从 `Ti` 指向 `Tj` 的有向边。

**定理**：一个调度是冲突可串行化的，当且仅当其优先图是无环的。

如果图是无环的，我们可以通过拓扑排序得到一个等价的串行调度顺序。

---

## 👁️ 视图可串行化

冲突可串行化虽然易于检查，但会排除一些实际可串行化的调度（假阴性）。**视图可串行化**是一个更宽松、假阴性更少的概念。

两个调度是**视图等价**的，如果满足：
1.  每个事务读取的每个数据的初始值相同。
2.  如果事务 `Ti` 在调度 S1 中读取了由事务 `Tj` 写入的值，那么在 S2 中 `Ti` 也必须读取由 `Tj` 写入的值。
3.  每个事务对每个数据的最终写入相同。

视图可串行化包含了所有冲突可串行化的调度，并且允许一种称为“盲写”的操作（即写入一个值但后续没有任何事务读取它）。然而，视图可串行化的检查非常复杂，在实践中难以实现。

---

## 🔒 基于锁的实现

为了保证冲突可串行化，数据库系统常使用**锁**。基本思想是：事务在访问数据项前必须先获得其锁，访问完成后释放锁。

一个简单的锁协议是：每个数据项有一个唯一的锁，事务必须获取锁才能读写，如果锁被占用则等待。

然而，简单的加锁/解锁并不能保证冲突可串行化，不当的锁释放时机可能导致**不可恢复的调度**或**级联中止**。

---

### 两阶段锁定协议

为了解决上述问题，我们使用**两阶段锁定协议**。

**规则**：在事务中，所有的锁请求必须在任何锁释放之前完成。这意味着事务有一个“增长阶段”（不断加锁）和一个“收缩阶段”（开始释放锁）。

2PL 能保证冲突可串行化。其证明思路是：如果存在一个非冲突可串行化的调度，那么在其优先图中必然存在环，而这与 2PL 的规则相矛盾。

---

### 严格两阶段锁定协议

为了进一步避免级联中止，我们使用**严格两阶段锁定协议**。

**规则**：事务持有的所有**排他锁**（用于写操作）必须在事务提交或中止后才能释放。

这确保了其他事务不会读到未提交的、可能被回滚的数据（脏读），从而使调度不仅是冲突可串行化的，也是可恢复的。

---

## ⚠️ 死锁

使用锁会引入**死锁**问题，即两个或更多事务相互等待对方持有的锁，导致所有事务都无法继续执行。

以下是处理死锁的几种策略：

### 1. 死锁预防
通过强制规定锁的获取顺序来预防死锁。一种常见方法是基于事务的“时间戳”或“年龄”。
*   **等待-死亡方案**：如果较老的事务请求较新事务持有的锁，则等待；如果较新的事务请求较老事务持有的锁，则较新事务中止。
*   **伤害-等待方案**：如果较老的事务请求较新事务持有的锁，则较新事务中止；如果较新的事务请求较老事务持有的锁，则等待。

这些方案通过打破循环等待的可能性来预防死锁。

### 2. 死锁检测与恢复
如果允许死锁发生，系统需要能够检测并恢复。
*   **检测**：周期性地构建**等待图**。图中的节点是事务，如果事务 `Ti` 等待事务 `Tj` 释放锁，则添加一条从 `Ti` 到 `Tj` 的边。如果图中存在环，则说明发生了死锁。
*   **恢复**：检测到死锁后，选择环中的一个事务作为“牺牲品”，将其中止并回滚，以释放其持有的锁，从而打破死锁。

---

## 🔧 锁管理器与锁粒度

在数据库系统内部，由**锁管理器**负责管理所有的锁请求和释放。它维护着一个数据结构（如哈希表），记录每个数据对象上的锁信息，包括锁模式、持有者列表和等待队列。

另一个重要概念是**锁粒度**，即锁定的数据单元大小。
*   **细粒度锁**（如行级锁）：允许高并发，但管理开销大。
*   **粗粒度锁**（如表级锁或数据库级锁）：管理开销小，但严重限制并发。

为了兼顾两者，数据库系统通常支持**多粒度锁定**，允许事务在不同层级（如数据库、表、页、行）上获取锁，并使用**意向锁**来高效地协调不同粒度锁之间的兼容性。

---

## 📝 总结

本节课我们一起深入学习了事务并发控制的核心机制：
1.  我们明确了**可串行化**是调度的正确性标准，并引入了更实用的**冲突可串行化**概念及其检查方法（优先图）。
2.  我们探讨了如何使用**锁**来实现隔离性，并通过**两阶段锁定协议**及其严格变体来保证冲突可串行化和可恢复性。
3.  我们分析了使用锁可能导致的**死锁**问题，并讨论了死锁的**预防**与**检测/恢复**策略。
4.  最后，我们简要介绍了数据库系统中**锁管理器**的作用和**锁粒度**的权衡。

![](img/eae5e6a7bf6abaacd589335a2e1dca71_7.png)

理解这些概念是构建和运用健壮数据库系统的基石。在接下来的课程中，我们将继续探索事务管理的其他方面。