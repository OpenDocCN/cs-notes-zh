# P24：第24讲 NoSQL I - ___main___ - BV1cL411t7Fz

它真的消耗很多电力吗？

![](img/4969c3b6bdb2795df8c30a9a8a3dbbc9_1.png)

我希望它不耗电。理想情况下不耗。但如果你像我一样每天翻阅《纽约时报》，那么这就会用更少的电量。我的初步研究是，我大概看了Deftico 30秒左右，听起来它是由苹果和谷歌的API驱动的。

他们被列为网页底部的可信合作伙伴。我找不到任何技术细节，不知道这是不是我们需要关注的问题，但也许我只是需要继续做一些更多的研究。我会在聊天中放一个链接，至少是协议的早期版本。

如果有人想讨论这个问题，欢迎发邮件给我，或者在Piazza上发帖。我觉得这些内容真的很有趣。我的意思是，实际上它是在校园内开发的。我的意思是，他们可能已经发布了代码，对吧？如果还没发布。你会惊讶于有些东西竟然没有开源。Dave，你知道吗？他们发布代码了吗？

我不知道。我不知道。API是公开的。我放了——它会是个邮件。那是在后面一个，对吧？但接下来我说的是，当你是那个最终开发出来的应用时。是的。还有其他开源的应用。我不知道这个是否是，但确实有其他在其他国家开发的应用。

其他后端。我们开始开发——开始在伯克利开发的，也是开源的。所以我不知道。我们会看到的。希望是的。我明白了。也许我们该开始了，Alvin。哦，为什么？好的，拜拜。好的。别让我们跑题。很好。那么今天我们已经在云端录制了吗？酷。好的。好吧。我们会继续的。

那么让我们回到关于NoSQL的讨论。我们在星期二的讲座中已经讨论过了这个动机。所以我只想在一开始快速展示几张幻灯片，提醒自己一下。这些是我们在本课程中讨论的两类数据库应用。OLTP基本上代表的是事务处理。

然后OLAP，或者说OLAP基本上是指那些不需要大量联接或事务处理的数据分析任务，对吧？所以NoSQL之所以诞生，是因为人们希望能够扩展，启动大量的OLTP工作负载，支持他们的初创公司或他们正在开发的应用程序。

所以这是一个问题，因为关系型系统通常不容易扩展。你们已经学过并行查询处理。所以NoSQL的解决方案基本上是放弃了一些功能，换取了易于扩展到大规模工作负载的能力。所以这就是我们在星期二讲座中停下来的地方。

讲到这些动机，顺便说一句，到目前为止，我们已经基本上完成了所有我们在关系型数据系统中想讨论的话题。所以如你们所记得，从课程的第一周开始，我们就讲了SQL，一直到上周，我们讨论并行查询处理为止。到目前为止。

我们一直在讲关系型系统。所以NoSQL基本上是我们第一次讲非SQL类型的数据管理系统的讲座。所以这基本上是给你们一个课程的流程图，告诉你们我们现在的进度。如果时间允许，我们还想讨论像map reduce和SPAC这样的内容，这些也是数据管理系统。

但它们并不是关系型的。就像我上次跟你们说的，目标并不是告诉你们哪个系统比其他所有系统更好。更重要的是告诉你们这些不同数据系统背后的一些技术性有趣的想法，然后让你们判断什么时候使用它们。

你们想使用哪些，并且何时使用。所以，正如我所说，NoSQL的动机就是尝试扩展这些事务型工作负载。它们基本上是通过减少数据模型和我们在系统中支持的功能类型来实现的。

你们会在几张幻灯片中看到我说的意思。所以在周二，我们也稍微讨论了这些不同类型的架构，或者说你们尝试扩展关系型系统的方式。所以我们最终形成了这种三层架构，现在大多数网页应用程序都采用这种结构。我们有一个数据库服务器的后台。

对吧？这基本上就是所有数据存储的地方。然后我们有一个中间层，它处理应用服务器的工作流。所以这些基本上是前端的网页服务器，当你们访问比如说，像google.com或facebook.com之类的网站时，你们会连接到这些服务器。所以这就是那种架构。

然后最后我们有客户端，对吧？在第三层。所以你们在最右边看到的就是它。扩展网页服务器的数量，主张是说，扩展这个比扩展数据服务器更容易，对吧？

因为我们并不打算去担心，比如一致性或者你们的持久性之类的东西，对吧？因为像你们知道的，所有的网页服务器所做的，基本上就是在客户请求某个页面或某个操作时，连接到客户端，从数据库中获取数据。

然后在那之后，呈现网页并将其发送回客户端。所以相对而言，它没有太多的状态。因此比起数据库服务器的扩展，它更容易扩展，正如我们已经讨论过的，使用并行数据库指标，对吧？所以其中一个主要原因是为什么。

扩展关系型数据库服务器是因为我们希望保持一致性。想想我们谈过的所有2PL的东西，所有2PC的东西，对吧？

所以我们想要扩展到大量数据，或者像多个数据库服务器。我们需要关注这些不同的方面。好吧，然后像这样。你已经知道这个故事了，关于这意味着什么，我们在扩展时，我们有多个。多个服务器，我们需要处理数据库方面的。

所以我们谈论了在扩展数据库时的不同策略，对吧？再说一遍，关系型的那些。我们已经谈过其中一个了。所以这是分区的想法。那么为什么我们不将数据分割到多个数据库服务器上呢？

所以这显然是我们可以扩展的一个方式，能够存储大量数据。然后我们已经谈过了你可以通过不同方式来分区数据，对吧？

通过范围，你知道的，通过哈希函数，或者只是通过轮询，举个例子。并不是这样。对吧？实际上是为了复制数据。如果我们负担得起的话。然而，这里的主张是，对于这两种方法，执行一致性是困难的。所以对于分区，我想你们已经看到了这个情况，为什么会是这样。

我在这里不需要重复自己，对吧？因为基本上现在我们在谈论2PC，对吧？例如，运行那个协议。它绝对不像，你知道的。它绝对不是零成本，对吧？正如你能想象的那样。所以只是作为提醒，对吧？

所以通过分区扩展基本上意味着，我们有许多机器用于存储集群中的数据。如果我们有足够的主内存可用，数据库也可以适合在主内存中。然后我们只是将查询分发到各个机器上，完成了。这里的主张是我们可以增加吞吐量，因为像。

你知道，在最优情况下，我们不需要触及多个机器来处理查询。那么，你知道的，它们可以并行运行。每个机器可以处理不同的入站客户端。所以我们可以处理的客户端数量严格来说，就是取决于我们能够负担得起多少数据库服务器。再说一遍。

这是一个大假设，像，你知道的，我们不需要运行像2PC那样昂贵的协议。我们也不需要检测那些事情，比如块检测和其他那些很酷的东西。正如你能想象的那样，对吧？你知道，在这个世界里写东西是很容易的。因为东西已经被分区到不同的服务器上。

所以一旦我们识别出需要更新的记录，我们就直接更新它。就这样，对吧？

这张图片，可能是你会想象的一张图。举个例子，像，你知道的。我们在这里将数据分割到三个不同的数据库服务器中。每个服务器都保存着，比如说，一段值范围，工具代码的范围，对吧？

例如，在这里，应用程序可以在最左边的服务器上进行更新。它也可能在最右边的服务器上更新其他内容。大多数情况下，这些更新基本上是独立的，对吧？

所以，这就是通过分区来做的一项好处。扩展数据库的另一种方式是通过复制。这里的想法基本上是，为什么不完全复制数据，跨多个服务器呢？就像你知道的那样。

假设我有三台不同的机器，再次强调，这里是相同的情况。如果数据量还不大，我实际上可以将整个数据集复制到所有机器上。为什么这样做有益呢？因为现在我可以分摊查询，对吧？

因为每个人都获得了完全相同的、相同的数据副本。所以，要求任何一台服务器来处理传入的查询是完全足够的。这和任何其他服务器一样好，明白了吗？所以在这种情况下，我们也可以提高系统的吞吐量，因为我们可以在不同的服务器上并行运行这些查询。

这对容错性也有好处。因为即使其中一台机器崩溃，我们也可以将所有查询重新路由到其他正常运行的服务器，同时等待崩溃的服务器恢复。因此，我们不需要停止工作，对吧？这与分片或分区的情况不同。

如果其中一台机器崩溃，那么它基本上会导致所有当前持有的数据都不可用。因此，如果任何传入的查询想要读取或写入该数据的任何部分，那么此时这些数据就不可用了。然而，在这个世界里，读取数据很容易，但写入变得更加昂贵。

只是因为我们现在正在跨多台机器复制完全相同的数据集。所以，写入任何一台机器的数据将会被转化为写入所有机器的数据。因为每台机器都持有相同的数据集，对吧？

所以它有利于将查询分布到多个服务器上，因为每个人都有相同的、完全相同的数据集。因此，无论你路由到哪个服务器，都没关系。缺点是，比如说，如果你想更新任何内容，那么这将变得非常昂贵。

因为现在我们在谈论向多个服务器写入数据。那么这里的最终目标是什么呢？嗯，这基本上意味着如果你在最佳情况下有一个只读工作负载，永远不会写入或更新任何内容，那就太好了，因为我们根本不需要处理写入问题，对吧？因此，我们只需运行查询。

在任何一台服务器上，举个例子，如果你正在运行查询，试图计算聚合，或试图计算统计数据之类的内容，对吧？

所以这些查询不需要更新任何内容，因此在这些复制的服务器上运行它们是不错的。例如。希望这能让你对关系型系统如何扩展有所了解。现在我们来谈谈为什么使用NoSQL，对吧？其中一个主要原因是因为数据复制很困难，正如我所说的。

关系型系统的权衡。就像我之前告诉你们的，我们已经讨论过的两种不同方案之间的权衡。所以，比如说，在这个例子中，假设我有这三个不同的关系在这里，分区。基本上意味着我们可能会在多个服务器上做连接。

如果我们需要读取当前在多台机器上存在的数据，我们已经了解了我们可以做并行连接的不同方式，对吧？

所以，这花了一整节课来讨论这个，你可以想象它有多昂贵，对吧？

如果我们使用这种复制或者重复数据集的方式进行扩展，那我们就会运行本地连接，这样很好。但然后，你知道的，取决于不同服务器的一致性如何，因为可能会有一些更新尚未传播，那么我们可能需要等一等。

如果你想读取数据库的一致视图，或者我们最终返回的值可能稍有偏差，对吧？所以，这又是一个权衡，对吧？没有免费的午餐。这就是关系模型的问题。我已经向你解释了为什么一致性变得如此困难。

结果证明这两种情况都很难做到一致，对吧？所以NoSQL应运而生，并说，好的，我们简化一下数据模型。那么我们就像，知道的那样，使用一些不依赖关系的东西。顺便说一下，我们也放弃一些关系型系统通常提供的功能。例如，一致性，基本上是这样的。

这意味着，如果你的应用程序想要能够执行类似连接的操作，或者他们关心读取最新的数据，那么他们需要自己搞定。所以这个选项永远存在，对吧？例如，应用程序开发者总是可以在应用程序中重新实现或者自己实现一些这样的功能。

但是从数据库系统的角度来看，这些将不再是由系统本身提供的功能。这样讲明白了吗？

所以把它当作你在实现书籍库，只是没有可用的连接，对吧？

我的意思是，只能选择。你可以阅读，对吧？然后，如果你想做一个连接，那就自己读取所有数据，然后实现你喜欢的连接算法，对吧？

所以这始终是这样。然后，另一种区分关系型系统和 NoSQL 的方式是，你可能会在 CAM1A 中学到的东西。就像之前所说的那样，对吧？我们已经在这门课中讨论过了，所以我不打算重复它的意思。希望到期末时你们能够记住它的意思。对于 NoSQL 来说。

他们提出了类似的概念。所以我们讨论的是 NoSQL 中的基本可用性（basic availability）。不同于原子性（atomicity），现在我们谈的是一种情况，在这种情况下，应用程序基本上必须自己处理所有这些潜在的故障。因此，当我们与一个服务器通信时，如果该服务器宕机了，那么应用程序就有责任弄清楚从哪里获取数据。

所以它不会，数据库不会提供例如恢复（recovery）等功能。这是一个选择。然后这就是基本可用性（basic availability）的含义，对吧？

所以这意味着它不再总是可用。有时候是可用的，有时候则不可用，对吧？所以这里的 V 代表的就是这个意思。接下来我们还谈到软状态（soft state）。与关系数据模型不同，在关系数据模型中，一切必须是一致和持久的。而在 NoSQL 中，我们需要能够处理这种情况。

数据库的状态在我们读取时可能发生变化。我在这里说的不是幻读（phantoms），我只是想说，由于更新可能需要时间传播到 NoSQL 系统中的不同服务器，因此我们可能需要处理这样一种事实：即使没有新的查询进入，数据库最终也会变得一致。

即尝试更新任何内容时，来自单一应用程序的不同读取实际上可能返回不同的结果，这只是因为新更新可能已经在应用程序执行两次读取之间传播过了。然后他们还谈到了最终一致性（eventual consistency）。基本上这意味着什么呢？

所以这是一种一致性模型，我们在这门课上还没有讨论过。在这门课中，到目前为止，我们在关系模型中讨论过，我们希望运行像，嗯，你知道的，直接到 BL，我们希望具有可串行化性（serializability），以及所有其他好的东西，对吧？

但是在 NoSQL 中，我们现在讨论的是，我们并不在乎事情是否是可串行化的。请注意，这是不同的意思，对吧？说没有一致性，并不是说没有一致性。所有这说的是，最终，数据库将变得一致，意味着我们可以容忍延迟更新，或者在我们尝试读取时进行更新。

还有其他所有好的东西，对吧？所以我们并不是说完全把一致性抛之脑后。我们要说的只是，事情最终会变得一致，但我们并没有说什么时候会发生。最终可能是 10 分钟后，1 小时后，或者永远不会发生，对吧？

或者像无限制一样，对吧？所以这并不违反任何规则。所以，基本上，这就是我们在NoSQL中讨论的一些内容。为什么这样是可以的呢？例如，想一想，如果你正在运营Instagram之类的应用，对吧？所以，像你知道的，你真的很在乎这些吗？

比如说，如果有人在他的账户上发布一张照片，然后传播这个更新给所有关注这个人的人，我是说，可能不会这样，对吧？所以，如果你的一些朋友先看到了照片，而其他一些朋友稍后看到了，那没关系，对吧？所以，这不是什么大问题，好吗？

这不是银行案例，这与银行案例不同。他们讨论的是我们投票的内容，投票训练事务，对吧？

对于事务，你大概不希望生活在那种世界里，对吧？比如，钱可以从你的账户扣除，但还没有存入到另一个人或你朋友的账户里，对吧？那样不行。所以我们在这里讨论的是不同的应用案例。

这里我们谈论的是Facebook、Instagram和所有社交网络网站之类的应用。例如，你知道的，是否某个帖子或墙壁显示出来，或者稍后显示，或者需要一些时间传播，这些其实并不重要。所以我们在这里讨论的就是这些类型的应用。

但为什么我说这行要圆一下呢？对吧？因为这是我们根据NoSQL系统总结出来的缩写，明白吧？

这正好与来自关系型世界的ACID相对立，对吧？

这可能有助于你们记住关系型数据库和NoSQL系统之间的区别。到目前为止，有什么问题吗？好的，现在让我们谈谈NoSQL世界中的数据模型。所以事实证明，实际上有几种可以选择的模型。所以这和关系型系统不同，关系型系统中一切都存储在关系中。

NoSQL世界基本上是在说，使用其他东西而不是关系来存储数据。所以我们来谈谈不同的数据模型。在这节课里，我只想简要介绍前两个，然后我们将更多关注最后一个，叫做文档存储。但你知道，我们首先需要理解。

NoSQL中这些不同数据模型背后的基本原理。所以第一个，键值存储。你们可能以前听说过键值存储，对吧？

能举手一下吗？有谁听说过这个的吗？是的，当然，对吧？是的，键值对。是的，太好了。那这意味着什么呢？对吧？其实非常简单。就是说一切只能是键值对。所以我们不是在讨论有模式的关系。

然后就像列和其他所有好东西。好吧。特别地，键可以是任何东西，比如字符串或整数，只要它在整个数据集里是唯一的。所以可以把它看作是，嗯，我们在关系型数据库中已经知道的主键。值可以真的是任何东西。

它可以是一个数组，一份名字列表，一个集合，一张图片，或者一个二进制文件块。任何东西。所以它可以是任何复杂的东西。只要有一种方法可以唯一标识那一段数据，否则就没有键。好吧。就是这样。所以忘掉那些像是规范化，或者你有，甚至我们必须拥有的每个工具框之类的东西。

拥有相同的架构，我想这里没有更多的架构了。在这个世界里，一切只是一个键值对。而支持的操作，只有获取和放入，对吧？获取只是说基于键进行检索的另一种方式。而放入基本上是插入数据的方式。

进入一个键值存储系统。然后它不支持其他任何东西。所以举个例子，如果你需要从一个值中提取某些内容，对吧？比如说，假设你知道，使用，嗯，假设我们把一份名字列表作为值，对吧？或者朋友列表，例如，或者某个人的名字。然后如果我们想检查它，比如，你知道。

比如说，某人是某个特定人的朋友，我们现在就需要手动写出这个关系。系统不支持这种操作。好吧。所以系统支持的所有功能就是获取和放入。仅此而已。所以其中一个好处，对吧？你们可以看到它相对容易实现，对吧？所以想象一下，我们，假设我们给你这个。

就像你要求作业时看的页面，对吧？我想你们大家现在都在笑，对吧？如果是这样，我们就不想支持其他任何东西。没有联接。没有像是分组、没有联合、没有聚合。没有那些新鲜事。比如说，忘掉事务处理，对吧？那么这个系统就是一个哈希映射吗？嗯。

你可以这么想。是的，从某种意义上说，它确实就是一个哈希映射。在这个意义上，它是一个庞大的哈希映射。不过，像是，我们确实需要支持，嗯，像是，数据的分布，针对这些键值对。这个也变得简单了，因为，嗯。

我们可以简单地使用基于哈希的分区作为一个非常简单的例子，对吧？

或者像以前一样，把数据复制到多个服务器上。而我在这里说的多路分区，就是我们之前讨论的关系型并行数据库系统中的方式，使用基于哈希的分区来拆分数据。

然而，问题是，像，嗯，你知道，如何实现，获取和存储，对吧？例如。让我们通过一个例子来说明。假设我想存储，比如，你知道。这些数据，这个，你知道，包含航班和承运人的数据集。那么，你们已经知道如何在关系型系统中做到这一点，对吧？嗯，你知道。

只声明两个关系，仅此而已。但在键值存储中。结果是我们可以通过不同的方式来做到这一点，对吧？例如。我们可以将键设置为航班ID，当然它应该是唯一标识符。然后值就是其余的记录，对吧？

所以，基本上这些不同的属性做的事情。我们还可以将键设置为航班的日期。你知道的，日期也应该是唯一的，对吧？因为只有一个，像，你知道的，2020年11月19日。然后值就对应那天发生的所有航班。你知道的，这也是一个选项。我是说。

并不是说，像，错或者对，或者，我的意思是，你知道，它完成了工作。它存储了我们想要的所有数据。然后另一个方法是，像，你知道，通过出发地和目的地对，以及两者之间的所有航班。哪一个更好？嗯，这取决于你的使用场景，对吧？所以，如果你的使用场景是，像，你知道，一个应用。

这使得人们可以查找两座城市之间的航班，那么显然，选项三是最好的。因为它允许我们立即获取我们想要的所有航班，对吧？

那么，想一想，如果你使用关系型系统，针对这两个特定关系，如何实现相同的事情，举个例子，对吧？

所以，如果我想写一个查询，像，你知道，获取所有从旧金山到，比如，纽约之类的航班，对吧？我的意思是，现在我们已经在谈论联接了，对吧？

因为我们需要做一个自连接，以便解决这些情况。好的？

但如果我们使用选项三，例如，作为一个NoSQL存储，那么它就很简单，对吧？然后只需要获取正确的城市名称，再传送给数据库，完事。好的？所以，你知道的，这基本上是我想提到的其中一个权衡点。然后正如我所说的，嗯，这个世界上有多种方式来划分数据。你可以。

我们可以使用哈希函数，或者我们可以，嗯，直接复制数据，对吧？如我之前提到的。我们可以将数据存储在多个服务器上，当更新发生时，假设，当存储操作发生时，对吧？然后我们可以根据需要将更改传播到其他服务器。我们可以立即传播它们。我们也可以像，你知道的，按时间推移传播它们。

对吧？这就是最终一致性的原则。除非，正如我之前所说的，对吧？你知道的，如果我们最终需要，假如应用程序实际上需要最新的信息，那么它可能需要先检查是否正在与包含最新数据的副本进行通信。所以，这完全是可以做到的，对吧？

正如你可以想象的那样，我们可以在应用程序本身中实现这个功能来进行检查。也许另一个应用程序根本不关心，像你知道的那样，是否读取到最新的数据。如果是这样的话，那就不需要做检查。所以，再次强调，对吧？这里的想法是，当你知道。

通过将功能推送到应用程序中，它使得数据库系统变得更加灵活，对吧？

在这种情况下，实施无SQL系统会非常简单。我们基本上是权衡了这样一个事实：你知道的，并不是每个应用程序都需要读取最新的信息，因此，如果你需要，它可以在数据库服务器或数据库系统本身之上实现，对吧？

默认情况下，系统不会强制执行，除非有人想要这样做。但这又是应用程序的决定。我们清楚了吗？好吧。正如我之前所说的，对吧？

这是无SQL的其中一种数据模型，就像简单的键值存储。另一种叫做可扩展的汇总存储。所以，如果你在文献中查找，它也被称为宽列存储。它实际上是基于谷歌的一篇论文，叫做 Bigtable。

这是第一个无SQL存储之一。如果你愿意，也可以找到它的开源实现来尝试一下。这个想法基本上就像你知道的那样，是比基础的键值存储更进一步的一个层次。所以，他们希望保留关系型的一些特性，特别是像你知道的那样，存在一些汇总，像你知道的那样。

这里有一些方面，每个表格只包含特定模式的两条记录，例如。但他们也希望拥有键值存储的灵活性。所以，最终他们提出的想法是，像你知道的那样，保持数据模型大部分时间仍然是键值对的。但后来，像你知道的那样。

这里的关键是有所限制。所以，它仍然可以有一个唯一标识符，然后作为键值，这样是可能的。但现在我们做了限制。另一个方法是基本上说，键本身是行和列的组合。所以，他们基本上重新引入了一个模式的概念，就像关系型数据库中一样。所以。

你不再能把任何唯一标识符直接放进去，如果它们都存储在同一个表中。所以，大表基本上重新引入了一个概念，即将具有相同模式的两条记录集合放在一起，就像关系型数据库一样。但他们不想限制每一条记录。

每两个帖子都需要有相同的键。所以，基本上，他们说，我们可以通过使用行 ID 作为键来实现，或者我们也可以使用行 ID 和一些列的组合作为键值。抱歉，应该是作为元组中的键。所以，同一表中的所有两个帖子仍然需要有一个模式。

但并不是每一行都需要仅仅通过唯一标识符来查找。所以，我们也可以通过唯一标识符的组合来查找，或者使用行 ID 和一些属性名称的子集来查找。否则，基本上它和键值存储是一样的。所以。

在本节课中，我们不会深入讨论这个问题，因为这基本上是键值存储和我们熟悉的关系型系统之间的混合体。所以，Nick 问：“这个功能和键值存储是不是差不多？”，是的，实际上它非常相似。唯一的区别是，我们现在在这里引入了一些规律性。

因为我们强制每个元组都必须有一组列名。就像在关系型系统中一样，而在键值存储的情况下，它甚至不需要有列属性名。所以，对于某些列而言，通过两个完整的列来查询会更容易。因此，这也取决于你想要解决的使用场景。

所以。

![](img/4969c3b6bdb2795df8c30a9a8a3dbbc9_3.png)
