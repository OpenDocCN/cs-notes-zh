![](img/a35d787499b28aec4dd3ca25f0963939_1.png)

# 课程 P14：第14讲 事务与并发 I 🧩

在本节课中，我们将要学习数据库查询优化的收尾工作，并正式开启关于“事务”这一核心主题的讨论。我们将了解为什么需要事务，以及事务如何保证数据库在多用户并发访问和系统故障情况下的正确性与可靠性。

---

## 查询优化收尾 📊

上一节我们介绍了查询优化中成本估算和选择性因子的概念。本节中，我们来看看如何利用这些概念，通过动态规划算法高效地找到最优查询计划。

我们的目标是给定一个查询，找出执行它的最佳方式。“最佳”可以从时间、I/O、内存等多个维度衡量。本课程主要关注时间和I/O成本。

一个简单的优化器实现是枚举所有可能的计划，估算每个计划的成本，然后选择成本最低的。但问题在于可能的计划数量太多，无法全部枚举。因此，我们需要一种更智能的方法在计划空间中导航，而不是穷举所有计划。

### 成本估算回顾

查询操作符的成本由两部分组成：
1.  **I/O成本**：将数据从磁盘加载到主内存的成本。
2.  **CPU成本**：数据加载到内存后，处理元组所需的CPU时间。这部分成本可以估算为 `需要处理的元组数量 × 一个CPU因子`。

为了计算成本，我们需要知道中间结果的大小。我们假设中间表的大小是输入大小乘以一个**选择性因子**。选择性因子是一个介于0和1之间的数。

以下是估算不同谓词选择性的方法：

*   **等值谓词（A = value）**：
    *   **系统R方法**：`选择性 = 1 / (A列的唯一值数量)`
    *   **直方图方法**：找到包含`value`的桶，`选择性 = (桶的高度) / (桶内不同值的数量)`
*   **等值连接谓词（A = B）**：
    *   **系统R方法**：`选择性 = 1 / MAX(A列唯一值数量, B列唯一值数量)`
*   **范围谓词（A > value）**：
    *   **系统R方法**：`选择性 = (范围内值的数量) / (整个范围的值数量 + 1)`
    *   **直方图方法**：将所有满足条件的桶的高度相加，然后除以总行数。

![](img/a35d787499b28aec4dd3ca25f0963939_3.png)

![](img/a35d787499b28aec4dd3ca25f0963939_5.png)

![](img/a35d787499b28aec4dd3ca25f0963939_7.png)

对于更复杂的谓词（如AND, OR, NOT），我们可以基于**独立性假设**，使用概率公式组合基本谓词的选择性。

### 动态规划与最优性原则

为了快速找到最低成本的计划，我们采用**动态规划**算法，其核心是**最优性原则**：最优（成本最低）的查询计划由其子查询的最优计划构成。

这意味着，连接三张表（A, B, C）的最佳方式，要么是先以最佳方式连接A和B，再连接C；要么是先以最佳方式连接A和C，再连接B，等等。

算法步骤如下：
1.  找出访问每个**基表**的最佳方式（如全表扫描或使用索引）。
2.  基于已找到的最佳单表计划，找出连接任意**两张表**的最佳方式。
3.  逐步扩展，找出连接**更多表**的最佳方式，每次都只保留成本最低的计划（除非该计划能产生“有趣的顺序”）。
4.  最后，为整个查询树添加分组、聚合等操作符的最佳计划。

### 有趣的顺序

某些连接操作（如排序合并连接）会产生副产品，例如对结果按连接键排序。如果查询后续有`ORDER BY`或`GROUP BY`子句，利用这个已排序的中间结果可以节省显式排序的成本。

因此，在动态规划表中，我们不仅记录计划成本，还记录它产生的“有趣的顺序”（如排序顺序）。这虽然增大了搜索空间，但可能找到整体更优的计划。这是一个典型的权衡：更精确的优化需要跟踪更多信息。

---

## 事务导论 🔄

现在，我们转换话题，开始讨论**事务**。这与我们之前讨论的查询处理与优化有本质不同。事务管理器是数据库系统的关键组件，负责处理多用户并发访问和系统故障，确保数据的正确性与持久性。

几乎所有现代服务（如社交媒体、银行应用、电商平台）都运行在数据库系统之上。除了执行单一查询，这些应用还需要数据库提供以下保证：
*   **原子性单元**：将多个SQL语句（如转账涉及扣款和存款）作为一个不可分割的单元执行。
*   **并发控制**：支持大量用户同时访问，且互不干扰。
*   **故障恢复**：在系统崩溃、断电等故障后，能恢复到一个一致的状态。

### 并发访问的问题

如果没有事务管理，并发访问可能导致多种问题：
*   **丢失更新**：两个事务同时读取并修改同一数据，其中一个的修改被覆盖而丢失。
*   **脏读**：一个事务读取了另一个未提交事务修改的中间数据，后者随后回滚，导致前者读到了不存在的数据。
*   **不可重复读**：同一事务内两次读取同一数据，结果不一致，因为中间被其他事务修改了。
*   **幻读**：同一事务内两次执行相同查询，返回的结果集不同，因为中间有其他事务插入了新数据。

### 事务与ACID属性

**事务**是数据库系统提供的一种机制，它将一系列数据库操作（读/写）组合成一个逻辑工作单元。事务通过**ACID**属性来解决上述问题：
*   **原子性**：事务中的所有操作要么全部完成，要么全部不完成。不存在中间状态。
*   **一致性**：事务必须使数据库从一个一致的状态变换到另一个一致的状态。一致性通常由各种约束（如主键、外键）定义。
*   **隔离性**：并发执行的事务彼此隔离，每个事务都感觉不到其他事务在同时执行。最终效果与串行执行这些事务相同。
*   **持久性**：一旦事务提交，它对数据库所做的修改就会永久保存，即使系统发生故障。

应用程序通过`BEGIN TRANSACTION`、一系列SQL语句、`COMMIT`（提交）或`ROLLBACK`（回滚）来定义一个事务。

### 并发控制基础

隔离性是事务管理器通过**并发控制**来实现的。最简单的实现是串行执行所有事务，但这会严重降低吞吐量和资源利用率。我们的目标是允许操作**交错执行**，同时提供与串行执行相同的最终结果。

为此，我们形式化**调度**的概念。调度是多个事务操作的一个执行序列。
*   **串行调度**：一个事务的所有操作完成后，再开始另一个事务的操作。这显然是正确的。
*   **可串行化调度**：一个操作交错的调度，如果其最终效果等价于**某个**串行调度，则它是正确的。

判断两个调度是否等价，关键在于**冲突操作**的顺序。两个操作冲突，如果它们：
1.  来自不同的事务。
2.  操作同一个数据库对象（如元组、页面）。
3.  至少有一个是写操作。

非冲突操作（如两个读操作）的交换顺序不会影响最终结果。因此，如果一个调度可以通过一系列交换非冲突操作，转换成某个串行调度，那么它就是可串行化的。我们将基于冲突的概念来构建更实用的并发控制协议（如下一讲将介绍的**两阶段锁协议**）。

---

![](img/a35d787499b28aec4dd3ca25f0963939_9.png)

本节课中我们一起学习了查询优化器的动态规划算法原理，并引入了数据库事务的核心概念。我们了解了为什么需要事务、ACID属性的含义，以及并发控制的基本目标——产生可串行化的调度。下一讲，我们将深入探讨实现可串行化的具体技术。