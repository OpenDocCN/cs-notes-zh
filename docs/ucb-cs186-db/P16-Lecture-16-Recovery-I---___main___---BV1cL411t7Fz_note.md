![](img/29600da32d3999ef340320b507cbdadb_1.png)

# 数据库系统原理 P16：第16讲 事务恢复 I 🔄

在本节课中，我们将要学习数据库系统中事务恢复的基础知识。我们将首先回顾并发控制中基于锁的实现，特别是两阶段锁协议及其变体，然后探讨事务可能中止的原因，并开始介绍恢复管理器如何确保事务的原子性和持久性。

---

## 回顾：基于锁的并发控制

上一节我们介绍了事务和可串行化的概念。本节中我们来看看如何通过锁机制来实现冲突可串行化。

锁意味着对一段数据（如数据库、表、记录）的独占访问权。为了简化，我们将锁操作抽象为两种：`lock` 和 `unlock`。

### 两阶段锁协议

为了保证冲突可串行化，我们引入了两阶段锁协议。该协议规定：对于每个事务，所有的锁请求必须在所有解锁请求之前。这可以防止某些调度问题。

然而，即使遵守2PL，仍可能出现“不可恢复调度”问题。例如，一个事务中止后，另一个已提交的事务可能读取了其未提交的数据。

为了解决这个问题，我们引入了**严格两阶段锁协议**。该规则要求所有的解锁操作必须与事务的提交或中止操作一同进行。这确保了已提交的事务不会读取到未提交的数据。

### 死锁问题

坚持严格2PL规则可能导致死锁，即多个事务相互等待对方释放锁，都无法继续执行。

以下是处理死锁的几种方法：

1.  **预防**：为所有锁对象设定一个任意的全局顺序，事务必须按此顺序获取锁。这可以避免循环等待，但在数据库环境中难以实施。
2.  **检测与处理**：系统维护一个“等待图”来检测死锁循环。一旦检测到，可以选择中止某个事务来打破循环。常用策略有：
    *   **等待-死亡**：较老的事务等待较新的事务；若较新的事务需要等待较老的事务，则较新的事务“自杀”（中止并重启）。
    *   **伤害-等待**：较新的事务等待较老的事务；若较老的事务需要等待较新的事务，则较老的事务“伤害”（中止）较新的事务。

### 锁的粒度与效率

只使用一种粒度的锁（如整个数据库或单个元组）会在并发性和开销之间产生矛盾。为了提高效率，我们引入了**多粒度锁层次结构**（例如：数据库 -> 表 -> 页 -> 元组）。

在层次结构中，锁定一个高层节点意味着隐式锁定了其所有后代节点。为了协调不同事务在不同粒度上的操作，我们引入了**意图锁**：

*   **IS锁**：意图共享锁，表示将在后代节点上加S锁。
*   **IX锁**：意图排他锁，表示将在后代节点上加X锁。
*   **SIX锁**：共享+意图排他锁，表示当前持有该节点的S锁，并可能在后代节点上加X锁。

获取锁时必须遵循**从根到叶**的顺序：在获取某个节点的S或X锁之前，必须先在其所有祖先节点上获得相应的意图锁。释放锁时则按相反顺序进行。

锁的兼容性由锁兼容性矩阵决定。例如，IS锁和IX锁在页面级别是兼容的，因为这意味着两个事务可以在同一页的不同元组上分别进行读和写操作。

### 幻读问题

当事务涉及插入或删除操作时，即使调度是冲突可串行化的，也可能出现“幻读”问题。即一个事务两次执行相同查询，中间由于另一个事务的插入操作而看到了新的“幻影”元组。

解决幻读的代价较高，常见方法包括：
*   锁住整个表（简单但并发性差）。
*   锁住相关索引。
*   使用谓词锁或间隙锁。

---

## 引入恢复机制

![](img/29600da32d3999ef340320b507cbdadb_3.png)

![](img/29600da32d3999ef340320b507cbdadb_5.png)

上一节我们讨论了如何通过锁来保证事务的隔离性。本节中我们来看看恢复管理器如何确保事务的原子性和持久性。

事务需要满足ACID属性：
*   **原子性**：事务中的所有操作要么全部完成，要么全部不发生。
*   **一致性**：事务必须使数据库从一个一致状态转变为另一个一致状态。
*   **隔离性**：并发执行的事务互不干扰。
*   **持久性**：一旦事务提交，其对数据库的修改就是永久性的。

![](img/29600da32d3999ef340320b507cbdadb_7.png)

![](img/29600da32d3999ef340320b507cbdadb_8.png)

![](img/29600da32d3999ef340320b507cbdadb_10.png)

![](img/29600da32d3999ef340320b507cbdadb_12.png)

![](img/29600da32d3999ef340320b507cbdadb_14.png)

![](img/29600da32d3999ef340320b507cbdadb_15.png)

恢复管理器主要负责保证**原子性**和**持久性**，并在系统崩溃后，回滚未提交的事务，重现已提交的事务。

![](img/29600da32d3999ef340320b507cbdadb_17.png)

![](img/29600da32d3999ef340320b507cbdadb_19.png)

![](img/29600da32d3999ef340320b507cbdadb_20.png)

![](img/29600da32d3999ef340320b507cbdadb_22.png)

![](img/29600da32d3999ef340320b507cbdadb_24.png)

![](img/29600da32d3999ef340320b507cbdadb_26.png)

### 事务中止的原因

事务可能因以下原因中止：
1.  **显式中止**：应用程序主动请求回滚 (`ROLLBACK`)。
2.  **违反完整性约束**：如违反主键、外键约束，数据库系统自动中止事务。
3.  **并发控制**：如死锁处理中，系统选择中止某个事务。
4.  **系统故障**：在事务提交前系统崩溃，恢复后该事务将被中止。

SQL中通过 `BEGIN TRANSACTION`, `COMMIT`, `ROLLBACK` 以及 `SAVEPOINT` 来控制事务。

### 为什么需要恢复？—— 系统崩溃

数据库可能因多种原因崩溃：
*   **操作错误**：如管理员错误配置、意外断电。
*   **软件故障**：数据库系统或操作系统本身的Bug。
*   **硬件故障**：如内存错误、磁盘损坏。

恢复的挑战在于数据的修改发生在**内存**（缓冲池）中，而持久化存储位于**磁盘**。内存中的数据在系统崩溃时会丢失，因此需要在磁盘上维护额外的信息（日志）来保证能恢复到一致状态。

我们假设恢复机制建立在严格的2PL和**就地更新**（数据在缓冲池中被直接修改并写回磁盘原位置）的基础上。

### 缓冲区管理器回顾

![](img/29600da32d3999ef340320b507cbdadb_28.png)

恢复操作的基本单位是**磁盘页**。缓冲区管理器管理着内存中的缓冲池，池中包含多个帧，每个帧可容纳一个磁盘页。

涉及的基本操作有：
*   **INPUT(A)**：将磁盘页A读入内存的缓冲帧。
*   **READ(X, t)**：从缓冲池中读取数据项X到程序变量t。
*   **WRITE(X, t)**：将程序变量t的值写入缓冲池中的数据项X。
*   **OUTPUT(A)**：将内存中已修改的页A写回磁盘。

正是内存（易失性）和磁盘（非易失性）存储之间的这种差异，使得恢复机制变得必要且复杂。

![](img/29600da32d3999ef340320b507cbdadb_30.png)

---

## 总结

本节课中我们一起学习了事务恢复的基础。我们首先回顾了基于锁的并发控制，包括两阶段锁、死锁处理以及多粒度锁机制。然后，我们探讨了事务可能中止的各种原因，并引出了恢复管理器的作用——确保事务的原子性和持久性。最后，我们分析了为什么需要恢复机制，并回顾了缓冲区管理的基本操作，为下一讲深入探讨具体的恢复算法（如日志技术）奠定了基础。

![](img/29600da32d3999ef340320b507cbdadb_32.png)

恢复机制是数据库系统稳定性的基石，它确保即使在发生故障时，数据库也能保持一致和可靠的状态。