# P17：第17讲 恢复 II - ___main___ - BV1cL411t7Fz

好的。我可以试试，如果你能的话。

![](img/cdf7441b4bd316e116edba77d09c12e9_1.png)

哦，我不知道你在这里。阿兰，我想他，既然我已经开始了，我觉得现在可能太晚了。好的，咱们开始吧。是的，开始吧。好的。好吧，嗯，你在讲恢复。嗯，祝好运，富兰克林。嗯。讲的是恢复，基本上我们在讨论如何，嗯。

那么，事情可能出错的不同方式是什么？又该如何从这些故障中恢复？对吧。所以我们讨论了，嗯，各种类型的错误。嗯，你可能会遇到操作员错误、配置错误、软件故障或硬件故障。我们还有一个自然的情况，就是你可能希望回滚一个事务的影响。

边界事务。例如，你遇到了完整性约束的问题，对吧？

然后你希望强制执行这些完整性约束。所以你回滚或边界事务。所以这些都是为什么恢复是一个重要主题的动机，而我们希望满足的两个属性是原子性和持久性。

这将是我们的重点。所以原子性基本上是说，嘿。我希望事务的效果要么完全出现，要么完全不出现。持久性基本上是说，嗯，一个事务提交后，它的效果需要，嗯，保存在磁盘上，对吧？它必须永久存在。这就是我们作为保证所希望的。好的。

所以现在我们将讨论恢复发生的机制。我们假设我们基本上有某种并发控制的方式。特别是，我们将假设严格的两阶段锁定（strict 2PL）。然后我们还将假设更新是就地发生的。所以基本上。

数据以页面的粒度被加载到缓冲池中。然后这些页面被覆盖，再写回磁盘。好的。所以事务并不是在数据的私有副本上完成的。所有操作都是在缓冲池中的这些页面上进行的。所以，嗯，这就是挑战所在。

当然，这些操作是离散的，对吧？

所以你有一些正在内存中发生的变化，然后这些变化被写入磁盘，而这些变化并不是瞬间发生的。所以数据将从磁盘加载到内存，修改之后再写回磁盘。

这就是离散性问题之一。另一个离散性问题是有一个时间差。通常会发生许多跨对象的变化。正如阿尔文在上一讲中提到的，你可能会在不同的粒度上抓取锁。但一个给定的事务可能包含许多不同的SQL语句并进行修改。

无论是单独的元组，还是元组的集合，都是如此，对吧？

因此，对于一个给定的事务，你可能会有许多不同的操作序列。因此，快速回顾一下缓冲管理器是很有用的，这样你就能理解这些操作。然后，页面被加载到缓冲池中，这些页面在主内存中的缓冲池中占据了帧的位置。这里的蓝色方块，网格中的蓝色矩形，表示被磁盘页面填充的帧。

因此，将这些页面从磁盘带入或写出称为读取或刷新。好的，这就是我们将使用的术语。你在缓冲管理器中有一些空闲的槽位，可以用来存放从磁盘带入的下一页面。随着页面请求发生，来自更高层代码的读取或写入操作也会作用于这些页面中的各个对象。

这些操作表示从磁盘中读取页面到缓冲池，并且在缓冲池页面上进行修改。然后这些修改会被写出，即被刷新。接着是一个页面，按照之前讲座中的约定，一个页面对应一个磁盘块。好的，接下来我们来讨论这里的基本操作，之所以我们对这些基本操作有些挑剔，是因为它们将帮助我们理解我之前提到的那种不连续性。

那么，什么时候修改，在哪里修改，以及如何从内存写入磁盘等。我们将使用这样的命令：read x，t，基本上是说将数据项x的值复制到事务的本地变量t中。

这个x可能是，例如，a。对吧？对，x。t基本上是在说，我将把这个事务本地变量的值写入这个数据项中。好的，所以这些读写操作发生的基本上是内存与内存之间的操作。好的，这就是我对这个的理解。因此，fetch操作则是内存与磁盘之间的关系，fetch x基本上是将包含数据项x的页面带到内存缓冲区中。

刷新操作将包含数据项x的页面从内存写回到磁盘。好的，这些就是我们将要操作的四个基本操作。接下来我们来看一个非常简单的例子，假设一个事务开始时，a = 8，b = 8。好的。

我们甚至没有讨论到两个操作的粒度，只讨论单个值a和b。因此，这个事务将a的值读取到临时变量t中，然后将其乘以2，再将这个临时变量的值写回b，读取b的值到临时变量中。

T 再将其乘以 2，然后写回 B，并进行注释。好的，这是一个简单的事务示例。在这里，我们从数据库中所期望的托马斯城市保证意味着，要么 T 提交并且值为 16，要么 T 不提交，B 值为 8。好的，接下来就是这些。

这是我们希望从数据库中获得的基本保证，即托马斯城市的保证。到目前为止有任何问题吗？好的，接下来让我们讨论涉及事务、局部变量、缓冲池和磁盘的操作顺序，随着各项操作的进行。

好的，假设对于对象 A，其当前磁盘上的值是 8，B 的当前值是 8。现在，通过说 fetch A，我的意思是将包含 A 的页面加载到缓冲池中的一个帧里。我将读取 A 的值到我的临时变量 T 中。所以，我从该页面取出 A 的值，然后将其放入 T 中。

我将其乘以 2 得到 16，然后将 A 的值写回 T，或者将 T 的值写回 A，即将其写回缓冲池中的页面。然后我继续取出 B，读取 B，将 B 的值存入 T，并将 T 乘以 2，然后写回 B。好的，再次让我们回顾一下这个过程。所以，fetch B 基本上是将包含 B 的页面加载到内存中。

然后，我将 B 的值读入这个临时变量 T，并将 T 乘以 2，然后将 T 写回 B。所以基本上，我将这个值 16 写入该位置。所以我将取出缓冲池中的该页面。然后，我会进行 flush A 和 B。那是什么意思呢？意味着我要将对应于 A 的页面从缓冲池写到磁盘。

然后取出对应于 B 的页面，并写入磁盘。好的，然后我可以提交。接下来，让我们看一下。这个就是操作顺序。好的，这些就是发生的事情，从缓冲池中的页面到对缓冲池中页面的操作。

然后，将从缓冲池写回磁盘的内容。现在我们看到，这是一次崩溃，对吧？所以在 flush A 和 flush B 之间发生了崩溃。现在，这有问题吗？嗯，有问题，对吧？首先，磁盘上的 A 值是 16，B 值是 8。这不是我们想要的保证，对吧？我们希望它们要么都是 8，要么都是 16。

事务没有提交，或者值为 16 和 16，并且事务已提交。所以崩溃对我们来说是一个问题。让我们再看一个例子。假设这里发生了一次崩溃。好的，这对我们来说是个问题吗？一些情况是的。所以，事实证明这也是一个问题。这也是个问题，因为 A 等于 B 等于 16。

但这是没有提交的。所以，因为没有提交，用户可能会尝试重新进行事务，认为他们原来的事务没有提交。所以他们可能会再次尝试。他们可能现在会从16、16变成32、32。对吧。这个就不理想了。好的。那么，嗯。

所以我们再看一个例子。假设这里，我遇到了一个在8、8和16、8之间的崩溃。就在这两步之间。对吧。那么这是个问题吗？不是问题。好的。之所以这不是问题，是因为你遇到了崩溃，但是你没有改变原始数据，而且你没有告诉用户操作已经提交。

所以事务没有提交，所以用户当然可以再次尝试。然后他们如果愿意，之后可以更新到16、16。好的。所以在这个情况下，我们是安全的，因为事务没有改变数据库的状态。从8变到16、8或者16、16。对吧。所以它们没有改变数据库的状态。

所以我们实际上处于一个好的状态。但我们仍然遇到了两种问题性崩溃，分别发生在flush和flush B之间，以及两次flush完成后的状态。所以这两个问题对我们来说是有影响的。现在，考虑到我们在同步刷写方面遇到问题，假如，比如说。我们把flush延迟到提交之后。好的。那么我们说，看看。

我们不立即在磁盘上标记数据。我们等到提交完成之后，然后再刷写数据到磁盘。好的，所以我们延迟写数据到磁盘。也就是延迟刷写数据到磁盘，直到我们完成提交。看看这是否能帮助我们。这里，我有一个提交，然后我刷写了A和B。那么这里有没有问题性的崩溃呢？

所以，你可以提交，但是如果在两者之间发生崩溃，那就不算提交。对吧。所以你可以提交，但实际上什么也没有写出去。对吧。所以你可以提交。然后这里可能会发生崩溃。或者这里，抱歉，应该是这里或这里。你可能会遇到问题。那么如果崩溃发生在这里怎么办呢？嗯。

在这里，你告诉用户他们的事务已经提交了。但实际上它并没有提交。所以用户可能会被误导，认为值已经被乘以2了，但实际上并没有。所以如果崩溃发生在flush和flush B之间，你就会留下一个奇怪的状态，其中一个值是16，另一个值是8。你不再保持A和B的值一致了。对吧。

所以你就会留下这种奇怪的状态。所以在这个上下文中，你确实会遇到问题性的崩溃。所以解决方法就是记录数据。对吧。在你更新数据之前，在最高级别进行更新之前，在你更新磁盘上的数据之前，你先把数据记录下来。对吧。然后在你提交之前，先记录数据。

所以你基本上是在采取某些行动之前先把事情写下来。所以在你需要做的事情之前先写下内容，这个概念就叫做预写日志。好的，所以这是一个重要的解决方案概念，我希望你能关注并尽量理解。预写日志的概念本质上就是在这个文件中不断添加日志元素或日志记录，追加到文件的末尾。

好的。这个日志通常保存在一个与数据页分开的不同磁盘上，所以你保持数据页不变，但你也有一个单独的预写日志，只记录你所做的所有操作。所以每次更新、提交或中止操作，你都会写入一个日志记录。好的。

所以你在进行更改时只是记录这些操作。所以你确实有多个事务并发执行，因为我们处于两阶段锁定模式。并且，你确实有多个事务并发执行。所以这些日志记录会交错出现在这些事务之间。

然后，在系统崩溃之后，这个日志会被用来确保持久性和原子性。所以，你基本上是用日志来重做已经提交的事务，重做确保了提交的事务得以持久化。好的，所以它们是持久的。你还可以使用日志来撤销那些未提交的事务。然后在崩溃时，这些事务就没有提交。

我们基本上撤销它们的所有影响。你会回到一个事务几乎从未执行过的状态，所以撤销确保了原子性。然后，你可以使用日志的性能优势，而不是页面写入。首先，日志是顺序写入的，而页面写入则可能是随机的。

所以，如果你记得，你实际上只是将内容添加到底部。所以它是按顺序写东西，如果你记得我们讲的磁盘讲座，顺序写入的效率要比随机写入快得多。日志的第二个性能优势是它可以是紧凑的。因此，你只需要存储增量，而不是存储整个页面的内容，独立于你所做的更改。

好的，举个例子，如果你做的只是修改页面中的一个元组，你可以只记录该元组的旧版本，而将新版本的元组放进来。你不需要记录该页面的其余部分，对吧，作为日志的一部分。所以，通过存储这些增量，你可以将许多许多日志记录打包到一个日志页中，通常跨越你对多个页面所做的更改。

好的。现在你知道什么是前写日志了。在日志策略方面，我们需要做出两个重要的决定。所以第一个决定是我们是否使用所谓的钢性策略还是非钢性策略。好吧，这是第一个决定，而钢性与非钢性决策影响原子性这一概念。

我们将讨论的第二个决定将影响持久性。好吧。钢性策略基本上说，我将允许缓冲池，或者等同地，另一个事务通过将页面刷新到磁盘来窃取未提交事务的固定页面。所以基本上这意味着，如果你有一个未提交的事务更新了某些数据页，这些脏数据可能会被刷新到磁盘并覆盖磁盘上的数据页。

另一方面，非钢性策略允许这种情况的发生。好吧。那么为什么钢性策略可能是一个问题呢？对。如果我们允许钢性，那么我们就需要处理未提交事务更新磁盘页面的事实。因此，为了确保原子性。

我们需要支持这些未提交事务的撤销。对，因为这个未提交事务可能最终不会提交，可能会被中止，或者系统可能崩溃。所以它对磁盘的任何更改都需要撤销。好吧，对于钢性策略，我们需要能够支持这些未提交事务的撤销，因为它们在这个数据上进行修改，使得数据变脏。

另一方面，非钢性策略的性能较差。因为如果有一个事务占用了大量页面，那么另一个事务就不能简单地说，你知道吗，你需要把你的页面写入磁盘，这样我才能获得一些页面。

所以基本上它限制了缓冲区替换。因此，钢性策略会导致性能较差，因为会因为未提交事务而被大量页面固定。但是，优点是你不需要撤销操作。对，你可以免费获得持久性。因此，唯一需要将数据写入磁盘的时机是事务已提交，而不是未提交的事务。所以这是第一个决定，且是一个重要的决定。第二个决定是强制与非强制。

而这也影响了另一个属性，即持久性，因此也影响了重做操作。强制策略基本上确保所有对事务的更新在提交之前都被强制写入磁盘。另一方面，非强制策略则没有这个限制。那么非强制的影响是什么呢？好吧，非强制的影响是你可以有已经提交的事务。

它的影响可能不会在磁盘上可见。因此，它们可能不是持久的。对。所以如果你基本上说，你知道吗，你不需要在提交之前强制将更改写入磁盘。那么事务可能已经提交并离开系统，其影响可能没有反映在磁盘上。对，用户已经被通知。嘿，你的事务已提交。

他们决定去开个派对。他们认为事务已经提交了，但实际上并没有提交，对吧？它并没有反映在系统中。因此，为了确保持久性，我们需要支持对这些已提交事务的重做。对吧？因此，我们需要能够重做这些事务，以确保它们反映到磁盘上。

尤其是在系统崩溃时。另一方面，force 选项的性能较差。而其性能差的原因在于，为了提交一个事务，你需要将所有的支付信息及其更新写入磁盘。而这些更新可能分布在各个地方，对吧？这些更新可能分布在各个地方。

所有这些都必须在事务允许提交之前写入磁盘。另一个原因是，这可能会有一些页面被许多事务同时更新。而这些页面，不让它们停留在缓冲池中，而是强制将它们写入磁盘，对吧？你就是在强制它们写入磁盘。

因此，由于被迫在提交事务之前将内容写入磁盘，出现了这些问题。好的一方面是，不需要重做。由于事务所做的所有更新在提交前都被强制写入磁盘，你可以免费获得持久性。

你可以免费获得持久性。好吧，这就是从恢复的角度来看，高层次的缓冲区管理设计决策总结。所以，你必须访问“强制/不强制”和“钢化/不钢化”。从性能角度来看，“钢化且不强制”是最佳选择。但它也是唯一一个既需要回滚又需要重做的选项。

"不钢化且强制"是最差的选项。它既不需要回滚也不需要重做。另一方面，“不钢化且不强制”需要重做但不需要回滚。“钢化且强制”需要回滚但不需要重做。好吧，所以这就是所谓的重做日志，因为对于“不钢化且不强制”来说不需要回滚。这就是所谓的回滚日志，因为你不需要重做。

这就是所谓的回滚重做日志，它的变体包含了更多的机制，使其更加高效，稍后我们会学习这一部分，即非重做日志。所以我们会首先讨论回滚日志，它是强制钢化的，然后谈论重做日志，它是“不钢化且不强制”的，之后我们再谈回滚重做日志，这个部分稍后会继续讲。哦，对了。

我有两个问题。首先，锁是不是必须写入磁盘，还是我们仅仅将其保存在内存中？看，意思是，我们绝对需要将日志写入磁盘，对吧？因为一旦发生系统崩溃，内存中的所有内容都会消失。所以，如果你想……举个例子，假设有一个未提交的事务，它正在决定更新磁盘上的一些数据。

好的，在更新磁盘上的数据之前，你不仅仅需要将它写入日志，你还需要将日志页写入磁盘，因为否则任何在内存中的东西都会消失。对吧？所以任何在内存中的东西都会消失。因此，在你触碰磁盘上的数据之前，你需要先把数据写出去，我们稍后会讨论相关的例子。

但是这个日志不仅仅是驻留在内存中的东西，它也存在于磁盘上。对吧？这就引出了我突然有的一个问题。我们如何确保不会出现你做了某事，但系统崩溃了，导致没有写入日志的情况？确切地说。

所以这可能是日志的某些部分已经写入了，但并不是所有日志都能写入。这些都是我们在政策中需要考虑的事情。是的，我们确实需要关注这个问题。肯定的。是的，非常感谢。那么为什么在没有强制写入的情况下没有撤销操作呢？因为看起来你还是在提交之前将脏数据写入了磁盘。

好的，我理解了定义。没有强制，没有偷窃。好的，那么我们再走一遍这个过程。好的，"没有强制没有偷窃"基本上意味着事务不能被写入缓冲池。缓冲管理器不能偷取那些未提交事务所写入的页面。也就是说，不能偷取未提交事务所拥有的、比如说被未提交事务固定的页面。

而没有强制的意思是页面……好的，让我展示一下定义。所以没有强制基本上意味着一个事务的所有更新不一定在提交前被强制写入磁盘。好的。那么我们如何确保？如果处于没有强制的范式下，如何确保事务的效果是持久的呢？对吧？嗯，为了确保在没有强制的范式下的持久性。

如果一个事务被允许提交，那么这个事务必须写入日志，然后需要写入磁盘。因此，数据页可能不会写入磁盘，但日志却会立即写入磁盘。所以你可以始终使用日志来恢复，我们会讨论确保这一点的机制。但是这就有道理了。是的，我认为原因是。

从听起来的情况来看，当你有强制时，你可能会有。在提交之前，你会把所有内容都写入磁盘。所以你可能需要撤销，但不需要重做，因为一切都已经写入了提交。但是如果是没有强制，你需要撤销，因为可能存在还未写入的脏页，因此你需要重做。

然后发生了提交崩溃，所以你需要重新做一次。这样准确吗？是的。好的。是的，我认为把这两者结合起来考虑是有用的。所以，强制决策基本上是。如果你选择没有强制，那么你有一个已经提交的事务，它的效果可能在磁盘上不可见。因此你需要能够支持重做。如果你使用偷窃。

然后，你有未提交的事务，它们正在与磁盘上的数据发生冲突。因此，你需要撤销它们的影响。所以在我们看来，这就是一种，我喜欢这样理解的方式。好的，看吧。好吧，让我们谈谈撤销日志。它基本上是强制和钢铁一致性的。好的。所以在撤销日志中。

你有各种类型的日志记录，你有一个开始事务，这基本上表示事务已经开始。你有一个提交，这基本上表示事务已经提交。同样，也有中止操作。然后是更新语句，它基本上表示事务已经更新了元素X，且其旧值是P。

Y的旧值重要吗？嗯，我们处在撤销日志的范式中。所以，为了撤销，我们需要在更新发生之前记录旧值。好的。那么，让我们在撤销日志范式下拍一个快照，看看事情可能会怎么出错，以及撤销日志范式提供了哪些保证。好的。

所以这是一个快照。好的，接下来你在日志中以此开始，并且有了这个事务。它在日志中反映为“开始”，在你写入的那个点，你对内存中的页面做了更改，决定将更改的旧版本写入撤销日志。同样，你也对B的旧版本做了相同的操作。然后，在你刷新了A和B之后。

你写出了一个提交信息。好的，这就是日志中显示的内容。这是磁盘上的日志。好的，这就是磁盘上显示的内容。现在，在我们讨论撤销日志范式提供的保证之前，我们先来谈谈崩溃。

假设你遇到各种类型的崩溃。假设这里发生了一个崩溃。那么，在这种情况下我们该怎么做呢？所以，我们基本上可以想象，所有这些都是不可见的。对吧？所有东西都消失了，因为这些都是临时的内存状态。你发生了崩溃，唯一能看到的是磁盘上的内容和撤销日志中的内容。

现在，看看你的撤销日志。你能看出什么吗？对吧。那么，在这种情况下我们会怎么做呢？通过查看撤销日志，你能判断事务T是否已经提交吗？它没有提交，对吧？你没有看到提交信息。你知道它没有提交。既然它没有提交。

由于撤销日志显示它尚未提交。那么你最终会做什么呢？你最终要做的就是撤销它的影响，对吧？那么，如何撤销它的影响呢？你查看B的前一个值，然后将它更改为8或B在此时的任何值，你将其更改为那个值。同样，你会更新A的值为8。通过在日志中记录A和B的旧值来完成这一操作。

我可以回滚，或者我可以撤销我所做的任何更改。在这个特定的情况下，尽管我只在磁盘上更改了a的值，但我并没有修改b，但我仍然可以撤销这个操作。我可以用旧值替换B，而旧值与新值相同，这不会影响我。对吧？这样合理吗？所以在这里，我可以通过将B设置为8，并且将a设置为8来撤销。

如果在提交之后发生崩溃怎么办？什么都不做，没关系。是的，你说得对。对。所以日志中包含了提交，这意味着我其实什么都不需要做。对，意味着如果我看到提交，这就意味着这个事务的效果已经写入磁盘，我不需要担心这个问题。对吧？所以我们为什么不……

Alvin，我们应该休息一下吗？因为我们大约到达了中途点。还是应该继续？当然。那么是读者部分的下一个部分吗？还是我还需要继续讲撤销部分？还是继续讲撤销，然后休息一下？是的，我在想这个问题。好的，那我就继续。好的。

那么这里我需要做出一个决定：我什么时候应该强制将日志页和缓冲池中的数据页写入磁盘？所以在撤销日志的范式下，我需要确保这条条目，即a的旧版本，在刷新a之前被写入。为什么呢？因为如果在记录之前就刷新了，那么旧值就不会被保存，或者它会被一个新值覆盖。

没错。如果我，假如我的日志中没有这个条目存在。 在我刷新a之前。那么我就会覆盖a，而且我无法恢复a的旧值。所以，我必须在刷新a之前把这个条目写入磁盘。 同样，我必须在刷新B之前把这个条目写入磁盘。既然我们在使用强制写入的范式，记住，撤销是钢铁般的，强制的。

由于我们处于强制写入范式中，我们希望在提交之前刷新a和B。好的。那么总体来说，这些就是我的规则。我需要确保日志条目代表更新的内容，也就是在更新之前，旧版本的内容首先写入磁盘。然后，我希望所有的刷新都发生在磁盘上，基本上所有的刷新都要完成。接着，我希望我的提交日志记录也能写入磁盘。好的，这就是更新的顺序。

那么让我们以更正式的方式来回顾这些规则。第一个规则基本上是说：如果T修改了x，那么T x V，也就是x的旧值必须在我刷新x之前写入磁盘。之所以有这个规则，是因为我希望在新值将旧值永久替代到磁盘之前，先记录下旧值。好的，我需要这样做，以便记录旧值，并在需要时撤销未提交事务的影响。

第二个规则基本上说，如果 T 提交，那么 flush x 必须在提交前发生。所以所有 T 所做的更改都必须在 T 被允许提交之前反映出来。这是因为我们处于强制执行的范式中，对吧？所以我们不想担心重做，我们想要免费的持久性。所以这就是第二个规则带来的好处。这样可以确保数据的稳定性。

第二个规则基本上是强制更新在事务提交前反映在此之前。所以在这里，flush 操作会在事务提交之前执行，我们将其与重做日志进行对比。嗯？是的，我有点困惑，因为早些时候你定义了 flush 是将页面写入磁盘。而这里看起来我们在区分“写入磁盘”和“刷新”操作。是的。

所以这是一个打字错误。所以必须执行 flush x。假设它必须发生。在提交之前。这更有意义吗？flush x 基本上是将 x 刷写到磁盘的操作。更精确地说，flush x 是对所有更新过的页面执行的操作。X 必须在提交之前发生。嗯，澄清一下。那么对于第一个规则，当你说我们需要在刷新之前写它时。

那么，这个 flush 是指仅仅从缓冲池中移除值吗？是的，flush 是指将包含 x 的数据页写入磁盘。所以这个条目 TXV 是一条日志条目。我们希望日志条目在更新对应的数据页元素之前被写出日志。基本上，你缓冲池中的页面会被写回磁盘。好的，谢谢。好的。

那么我们来谈谈使用撤销日志的恢复。我们需要解决几个问题。第一个是哪些更新需要撤销。那么，需要撤销的更新是所有未提交事务所做的更新，对吧？这些更新都是在崩溃发生时需要撤销的更新。那么我们需要回溯日志多远呢？我们需要回溯到最早未提交事务的开始。

对，所以你需要追溯到最早未提交事务的开始。不幸的是，如果你没有机制来标记最早未提交事务的开始位置，那么你就没办法了。你必须基本上遍历所有日志。因此，这样做会带来严重的性能和其他影响。

一些性能问题可以通过管理员稍后介绍的方案来解决。第三个问题是，如果在恢复过程中发生第二次崩溃，会发生什么？对吧？假设你正在进行恢复，并且发生了第二次崩溃。那也是可以接受的，因为在这里，撤销是关键。

所以如果你撤销并不断撤销，那是可以的。你基本上已经正确地将一个未提交事务生成的新值替换了旧值。现在你将再次用相同的值替换整个值，那也是可以的。所以对于这些重要的项，那是没问题的。再说一遍，这有一些性能问题，因为如果你不断崩溃并不断重复撤销，那就不是理想情况。所以再次强调，AD 提供了一些机制来改善这一点。在恢复时，这些是发生的步骤。

第一步是，在系统崩溃后，你运行恢复管理器。你需要判断每个事务是否完成。所以有两种类型的已完成事务。要么你看到提交，要么你看到中止。如果你没有看到提交或中止，那么它基本上就是未提交或不完整的。

对于所有这些不完整的事务，你将撤销它们的修改。因此，为了撤销它们的修改，你需要从日志的末尾开始读取。也就是回溯。如果你看到提交或中止记录，你基本上可以标记它。如果你看到更新，并且 T 没有完成，那么你就用 B 替换磁盘上 X 的值。

好吧，所以你将 X 替换为它的旧值 B。如果它已完成，你可以忽略它。如果你遇到开始事务的记录，你可以忽略它。你不需要做任何处理。那么你需要回溯多远呢？正如我之前提到的，你需要回溯到日志的最开始。而且这个……

你可能有一个非常长时间运行的事务，它从日志的最开始就启动，并且仍在继续运行。在理论上，最坏情况下可能发生，但实际上它可能不会发生。但你仍然没有选择，只能回溯到最开始。这是通过一种叫做检查点的概念来解决的，它基本上允许你……

从某种意义上说，检查点基本上告诉你我允许。你可以把它理解为临时保存状态的方式，这样你就不需要回溯到日志中的这些检查点之外，只需要回溯到这些检查点，而不是回溯到最开始。那么在这个例子中，发生了什么，让我们一步步看一下我们可能需要做什么。

所以你从底部开始，向上进行撤销恢复。你会看到这个日志记录，基本上是在说 x2 的旧值是 V2。那么你要做的就是简单地把 V2 写入 x2 到磁盘。接着你会看到下一个日志记录，它来自事务 T3。

它是在说 x3 的旧值是 V3。所以它简单地会说，好吧，我要把 V3 写入 x3 到磁盘。然后你会看到一个提交语句。那么你现在要做的是，你会说，好吧，我看到的任何来自 T5 的更新，我不需要担心，因为它已经提交了。好了，所以你会保持已提交状态。

事务，并且你将记录T5，T5在那里。因为你不再需要担心它的更新，其他所有需要撤销的内容。然后你可以标记T5为已完成。你从T4撤销此更新的效果。然后这个更新来自T5，你可以跳过它，因为你知道T5已经提交。

你撤销T1的效果。你撤销T6的效果，依此类推。好的，所以基本上你是从底部到顶部回退。你确定一个事务是否提交，如果已提交，你就不需要撤销它的效果，所有其他更新你都需要撤销。有什么问题吗？

Nicholas。所以我只是有一个一般性的问题，关于雪钢是如何工作的。因为你提到过，雪钢让我们不必进行撤销操作。但是如果我们使用雪钢，那么在提交之前，我们必须先将更改写入磁盘。但如果，比如说，我们正在将更改写入磁盘。

然后我们在提交之前崩溃了，我们岂不是仍然需要像你知道的那样，回去撤销我们写入磁盘的更改吗？好的，稍等一下，慢一点，我们来谈谈你说的是哪一种变体，哪一种读取情况。我说的是强制无钢。好的，你说的是没有撤销和没有重新执行。好的。

那么在这种情况下，你的问题是什么？是的。所以我猜，既然我们必须在日志中记录我们已经提交之前将更改写入磁盘，对吧？但是如果我们像你知道的那样，把更改写入磁盘，然后在提交之前崩溃了，我们岂不是仍然需要撤销那些我们已经写入磁盘的更改吗？没错。是的，实际上这是一个。

这种特定的组合实际上并没有提供原子性，没有提供原子性或持久性。这实际上是教科书中描述的一个案例。一个既没有提供原子性也没有提供持久性的案例。但这并不是一个理想的案例，不仅因为它性能较差，还因为没有保证，除非有额外的措施。

在这种情况下，让我们看看，是撤销还是重新执行机制。在这种情况下，既然你强制将更新写入磁盘，你仍然有日志。因此，你可以确保日志允许你……让我看看，我有点困惑。我自己搞混了。我认为问题在于，你无法判断某个事务是否已经提交。

对，因为就像你说的，Nicholas，你可能还没有将提交写入磁盘。而且你已经写入了其他所有内容，对吧？所以你需要一个机制来判断是否需要重新执行。Alvin，这就是你所说的吗？是的。所以在这种情况下，你可能还是需要重新执行。

即使它声称你既不处于撤销状态也不处于重做状态，你基本上是不可恢复的，因为你根本无法判断某个操作是否已经完全提交。所以这是问题所在。嗯。即使没有其他机制来恢复这种特定情况，它的性能也非常差。所以这是我们理想中不应该担心的情况。好的。

谢谢。好的，我们继续吧。我觉得我们可以休息一下，既然我们已经完成了撤销日志的处理，现在马上就要开始重做日志了。那我们休息一下，休息时我们可以播放一个视频。

![](img/cdf7441b4bd316e116edba77d09c12e9_3.png)

嗯，不过在那之前，我其实建议大家尽可能打开视频，因为我们需要使用笑声计量器来判断这是不是好笑。

![](img/cdf7441b4bd316e116edba77d09c12e9_5.png)

现在我们需要更加努力地做这件事。我找到了不错的东西，对吧？所以，是的，大家告诉我们。

![](img/cdf7441b4bd316e116edba77d09c12e9_7.png)

![](img/cdf7441b4bd316e116edba77d09c12e9_8.png)

好的。我的意思是，大家之后可以给我们点个赞或者点个倒赞。好的，嗯，我不知道我是否能做到。

![](img/cdf7441b4bd316e116edba77d09c12e9_10.png)

![](img/cdf7441b4bd316e116edba77d09c12e9_11.png)

我可以给你链接吗？抱歉，我觉得它不允许我分享声音。好的。你是怎么发给我的？或者我好吧，让我通过…发给你。

![](img/cdf7441b4bd316e116edba77d09c12e9_13.png)

我的意思是，你看到了吗？好的，我要打开它了。好的。

![](img/cdf7441b4bd316e116edba77d09c12e9_15.png)

![](img/cdf7441b4bd316e116edba77d09c12e9_16.png)

好的。好的。好的。所以，我已经开启了音频。我觉得音频帮助不大。我想它只是某种模糊的愤怒咆哮。好的。好的。好的。抱歉。好的。好的。好的。

![](img/cdf7441b4bd316e116edba77d09c12e9_18.png)

![](img/cdf7441b4bd316e116edba77d09c12e9_19.png)

好的。

![](img/cdf7441b4bd316e116edba77d09c12e9_21.png)

好的。嗯。好的。让我们分享。我会尽快找到链接并分享给大家。嗯。接下来，我要快速回到尼古拉斯的问题。所以我认为基本上我们所谈论的策略是“无强制与窃取”。所以像艾尔文提到的那样，简要回顾一下，发生了什么。

你们在提交时强制将所有这些脏页写入磁盘，直到提交时，所有脏页才会被固定在缓冲池中。所以至少从性能角度来看，这并不理想。但在提交时，你强制将这些脏页写入磁盘。因此，当你强制将一些脏页写入磁盘时。

如果你在执行过程的中途崩溃，基本上无法恢复，就像Alvin说的那样。你处于没有原子性的状态。对吧？所以除非你添加了日志记录并进行回滚，否则不需要重做，你确实需要回滚，因为没有原子性。明白了吗？尼古拉斯。好的。好的，接着说回重做日志，它是无强制且无钢化的。

好的。所以在重做日志中，我们对日志元素进行了一些更改。更改日志元素的方式是我们更新。我们将每个元素的值V更改为新值，而不是旧值。明白吗？这里是执行的快照，日志显示在这里。所以在这种情况下，

你有开始T，然后T和16被写入，所以这是一个新的值，因为缓冲池中的值从8更新到16。对于B也是一样。接着你有提交日志记录。然后刷新操作发生。好的。

在这个范式中，刷新操作发生在提交之后。我们稍后会讲这个。所以让我们先讲一下崩溃。如果你在这里发生崩溃，怎么办？我们如何恢复？你必须再次将16写入a和b，对吧？对。对的。所以你已经提交了，对吧？你处于无强制范式中，已经提交了。

但你不知道事务的效果是否持久。事实上，你可能刚刚写入事务所做的更改到磁盘，然后系统崩溃。所以你基本上要重做这个事务的效果。你实际上会将16写入a和b。即使你在这里崩溃了，你仍然会做出相同的决策，仍然会将16写入a和b。

即使你在这里崩溃，你仍然会做出相同的决策。好的。所以这是所有情况下的重做，通过设置a等于16，b也等于16。如果你在提交语句之前崩溃了，如何恢复？我们需要做什么吗？不需要，对吧？原因是因为它没有提交，所以你知道事务没有对磁盘上的数据做任何更改。

好的，所以你知道它没有提交，因此它还没有触及磁盘上的数据。所以你现在的状态还可以。那么在这种情况下，我们应该什么时候强制将页面写入磁盘，包括日志页面和刷新操作？由于我们处于无强制（no force）范式中，提交必须先发生，才会触及磁盘上的任何数据。所以在这种情况下，刷新操作发生在提交之后。所以在重做日志范式中，有一条简单的规则，基本上说如果T修改了X，

然后，TXV以及提交T必须在刷新操作发生之前写入磁盘。好的，所以简单来说，你可以忽略这个，只需要说提交T必须写入磁盘，因为提交T意味着T所做的所有更新也已经写入磁盘。

所以在这种情况下，刷新操作会晚一些执行，因为我们再次处于无钢化状态，因此必须先执行提交操作，然后才会进行刷新。好，关于这个有任何问题吗？那么我们如何通过重做日志进行恢复呢？系统崩溃后，你会运行恢复管理器，检查每个事务是否已完成。如果你有。

如果你已经看到提交或中止语句，那么这个事务已经完成，所以你不需要担心它。如果你没有看到提交或中止，那么你需要继续读取日志。抱歉，如果你看到提交或中止语句。

然后，你知道你需要撤销它的效果，或者重做它的效果。如果你还没有看到提交语句，那么你不需要担心它。所以你从日志的开头开始读取，重做所有已提交事务的更新。所以你基本上要检查。再一次，第一步是检查每个事务是否已完成。

所以这两个要么提交，要么中止，意味着事务已完成。如果你看到事务开始但没有提交或中止，那就意味着该事务未完成，所以你不需要担心它。它没有修改任何内容。对于所有已完成并已提交的事务，那些是你要处理的。所以你从日志的开头开始读取，重做所有已提交事务所做的更新。

好的，所以这可能会很慢，因为你从日志开始，然后一直读到末尾。你可以通过检查点来解决这个问题，这部分内容会在系列日志撤销重做日志系统中讲解。那么重做日志如何工作呢？你从查看第一个语句开始，也就是开始T1。实际上，在那之前，你需要弄清楚哪些事务已经提交。

对。这里你注意到T2已经提交。如果你回顾上一页，我们需要确定哪些事务已经提交，哪些没有。你需要重做已提交事务的更新。所以第一步是确定哪些事务在这种情况下已经提交。就是T2。

然后你从日志的顶部开始，只重做T2的效果，其他的你可以跳过，因为你知道那些事务没有修改过这个内容。所以你跳过T1所做的更新，跳过T3所做的更新。

实际上，对于T2，你需要写入，你需要重做它的效果。跳过T1所做的更新，跳过T3所做的更新，然后再跳过T1所做的更新。所以在这种特定情况下，你实际上不需要做太多事情，你只需要在磁盘上写入T2的值。也就是替换重做T2所做的动作到X2。B2是X2的新值。

我们实际上可以有效地确定一个事务是否已经提交。对。这将是 Aries 部分的重点，但一种简单的方法，也就是天真的方法，就是遍历整个日志，查看哪些事务已经看到提交条目。

显然，这并不是理想的做法。因此，我们将在 Aries 中讨论的机制将允许你跳过大量日志，通过创建检查点来使用这些检查点，从而只读取日志的后缀部分，而不是读取完整的日志。

理论上，我们永远无法知道何时刷新到磁盘，因为这并没有记录在日志中。是的，你唯一拥有的是日志和数据页。所以，你基本上需要通过尝试将数据页和日志中的内容进行关联来进行法医分析，反向推断你需要回溯多远，以及需要撤销哪些操作，重做哪些操作，等等。

在这种情况下就这样做。好了，撤销和重做日志的快速对比，撤销日志基本上会提前刷新数据页。所以因为你处于强制策略中，你会提前刷新。如果看到提交，那么它一定已经将所有数据写入磁盘。由于这是强制策略，事务在提交前，所有数据都会被强制写入磁盘，所以事务的持久性得到了保证。

所以在这种情况下你不需要撤销。对，如果你已经看到提交，那么如果没有看到提交，你就需要撤销该事务的影响并重做日志中的页面。页面刷新必须推迟执行。因为我们处于无强制策略中。如果没有看到提交，那么它肯定没有将任何数据写入磁盘，所以磁盘上没有数据，磁盘只会在提交被看到时被触碰。

对于所有已提交的事务，你需要进行重做。因此，撤销日志和重做日志各有优缺点。在撤销策略下，优点是它占用的内存较少，因为你会在日志记录刷新之后立即刷新这些更新的数据页。所以只要你确定日志包含了所有撤销所需的信息。

你可以刷新更新后的页面数据并继续。然后，只有在此之后你才会提交。这样做的延迟较高，因为你强制所有脏缓冲页面在提交前被刷新。对，和重做日志的情况不同，后者不强制这样做，而是强制所有内容在提交前被刷新。这可能会有很多随机的I/O，就像我们之前描述的那样。

在重做日志的情况下，你处于无强制策略。所以缺点是这更占内存，你需要将这些页面保留在缓冲池中。所有的固定页面都会停留在缓冲池中。所有未提交事务的页面都会停留在缓冲池中，直到提交日志被刷新。如果提交日志已经刷新，那么你可以开始刷新。

这样做的好处是稍微降低了延迟，你不需要等到所有数据页面被刷新到磁盘才能提交，因为你不在强制模式，而是在无强制模式。好的，那么回到我们的幻灯片，之前我们讨论了这两个内容，接下来我们要讨论这个。

作为这个方案的一部分。所以，对于这个撤销重做日志团队，我将为元素做一个准备，让它承担起治理的责任。日志现在将稍微有所不同。我们将有事务ID，我们将有页面ID，以及旧数据和新数据。因此，你需要同时保留旧版本和新版本，因为你需要支持撤销和重做。

这有点像抽象掉一些细节，是附加的信息。例如不同类型的日志记录和其他相关内容。我们稍后会看到这些内容。好的，到目前为止，这个日志协议有两个条件需要满足，如果你理解了重做日志和撤销日志，这两个条件应该能让你理解。

所以第一个条件基本上是说，在当前对应的数据页面写入磁盘之前，必须强制执行更新的日志记录。你必须在修改磁盘上的数据之前先记录你将要做的操作。这是针对未提交事务的。也就是说，你必须在修改磁盘上的数据之前做出这个更改。第二点是，在提交之前，必须强制执行一个事务的所有日志记录。

因此，在所有日志记录（包括提交日志）被提交并写入稳定日志之前，事务不会被提交。这使得我们能够通过查看日志，正确判断事务是否已经提交。好的，那么这个第一个规则，加上撤销操作的健康性，保证了原子性。

因为你有未提交的事务正在更新磁盘上的页面，但因为有日志记录，你可以撤销它的影响。所以第二条规则，加上重做操作的健康性，保证了持久性。你并不是强制要求所有数据页面在提交前都写入磁盘，而只是强制日志记录。

包括提交日志记录需要写入磁盘。因此，通过使用日志记录，你可以重做一个已提交事务的影响，尽管这些影响尚未反映到磁盘上。总的来说，这两者允许我们实现**强制**和**无强制**。好的，这就是我们想要的，因为它提供了最大的灵活性。好的，我想这就是我在这里要讲的内容了，我很高兴在 Alvin 设置的时候回答问题。

我可以开始了。好的。还有五分钟时间，所以不多了。是的，是的。

![](img/cdf7441b4bd316e116edba77d09c12e9_23.png)

![](img/cdf7441b4bd316e116edba77d09c12e9_24.png)

![](img/cdf7441b4bd316e116edba77d09c12e9_25.png)

是的，所以这一部分实际上是在回应刚才讲到的细节。提醒一下自己，对吧？在这个世界里，我们有四种不同的操作需要执行。我们从磁盘读取一个页面，并将其刷新。

然后这些就是刚才讲到的细节，所以我不再重复了。只要记住，在这里我们使用的是**前写日志（write-ahead logging）**，意味着所有操作必须先写入日志，然后才能真正写入磁盘。我们已经讲过撤销日志，也讲过重做日志，至于具体锁定了哪些内容。

好的，这个撤销和重做日志机制的问题在于每次我们需要从锁的最开始恢复，这在计算上是非常密集的。所以我确实提到过，嗯，基本上已经提了好几次了。这个部分讲座的整体目标就是基本上讲解另一种方案，它允许我们不必每次都从最开始就进行恢复。

虽然我也会说，就像在重做和撤销方案中进行恢复时，如果我们已经知道了哪些是已提交的事务，实际上我们可能不需要每次都从最开始读取，或者从锁的最末尾一直读取到最后。现在恢复时，我们可能并不总是需要做到这一点。所以要记住这一点。

所以我还有三分钟时间，我想我就简单介绍一下这是什么，然后我们下周再继续讲解算法的具体机制。所以这个“区域算法”是一种恢复技术，结合了重做和撤销操作。它实际上就是在这里的湾区开发的，位于圣荷西的阿尔马丁，由一位研究员开发。

成本C·莫汉（C Mohan）。我想他们会在聊天中分享论文链接，所以我并不是建议你阅读那篇论文，因为它其实是一篇非常难懂的论文。但如果你感兴趣，你也可以简单浏览一下。如果你去查看不同的实现版本，你会看到他们实际上做了这个算法的不同变种。我们在这门课中讲的就是最基本的那个版本。你在项目中实现的基本上跟讲座内容一致，唯一的区别是为了让它更高效，加入了一些额外的优化。

但是如果你去检查不同的实现，你会看到不同的版本。理解区域算法的第一件事就是理解“检查点”的概念。今天我们就停在这里。什么是检查点？检查点基本上是一种机制，可以定期保存整个数据库的状态。

那么我们在做检查点时做了什么呢？我们暂停了所有事务。我们阻止任何新的事务发出。所以，当有人访问我们正在实施的网站时，我们会显示类似“请稍后再来”的信息。我们暂停了整个系统。

我们等待直到所有正在进行的事务完成。然后我们将锁完全刷新到磁盘。接着，我们还将所有30个页面刷新到磁盘。之后，只有在这之后，我们才会写入一个检查点记录到锁中，并且刷新锁。所以，正如你所看到的，这个检查点记录是为做检查点而新增的内容。

所以，这基本上是一个新的锁记录形式。那么为什么我们要这样做呢？因为在这一点上，我们基本上可以确定所有由已提交事务所做的更改都已经持久化到磁盘。也就是说，我们不再需要任何类似于检查点之前的内容在锁中。对吧，因为所有的30个页面已经被写入磁盘了。

所有需要完成的事务已经全部完成了。它们要么已经提交，要么已经以其他方式结束。所以，所有的事务都已经停止了，我们已经暂停了所有操作。

因此，我们已经完全完成了。我们已经清理了事务管道。所以，基本上我们不再需要关注锁中检查点之前的任何内容。所以，如果你想的话，我们可以直接截断锁。在这些步骤完成后。

然后我们就可以恢复事务处理。我们可以允许新的事务出现，并继续我们之前的工作。因此，图示上，你可以看到有一个新的记录叫做“检查点”，它基本上标记了我们已经在那个锁的位置进行了检查点。

所以，如果发生崩溃，发生什么事情呢？我们基本上只需要查找锁中的第一个检查点，假设我们没有截断任何东西。那么我们会回到锁的末尾，然后找到最接近锁末尾的第一个检查点。

然后我们基本上可以意识到，在检查点之前的所有内容我们不再需要恢复，因为通过检查点的作用，我们已经知道它们的更改已经全部写入磁盘。所以，我们只需要关注的是在检查点记录之后开始的任何事务，看看它们是否已写入锁中。

所以举个例子，在这种情况下，注意到像你的事务基本上是在检查点之后才开始的。所以如果我们在屏幕的最后发生崩溃，我们就需要恢复它们。你可以想象一下这会有什么问题，比如说我们停止了世界的进程，这并不太好，对吧？我们在进行检查点时不能处理任何事情。如果在进行检查点时还有很多未完成的事务。

然后我们可能需要等待一段时间。所以这些是我们在进行检查点时会遇到的一些问题。接下来周二我们将开始讨论所谓的模糊检查点（fuzzy checkpointing）。在这种方法中，我们可以在事务仍在进行时继续做检查点。

所以我们不需要停止世界的进程，且在进行检查点时可以允许事务继续进行。好，明白了，所以我想在这里停下来，让你们提问，我也会停止录音。

![](img/cdf7441b4bd316e116edba77d09c12e9_27.png)
