- en: P24：Lecture 24 NoSQL I - ___main___ - BV1cL411t7Fz
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P24：第24讲 NoSQL I - ___main___ - BV1cL411t7Fz
- en: Does it actually consume a lot of power？
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 它真的消耗很多电力吗？
- en: '![](img/4969c3b6bdb2795df8c30a9a8a3dbbc9_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4969c3b6bdb2795df8c30a9a8a3dbbc9_1.png)'
- en: I hope it doesn't。 Ideally not。 But if you're scrolling through the New York
    Times。 as much as I do every day， then this， is going to use less battery。 My
    extremely preliminary research， that being I looked at like Deftico for about
    30 seconds。 it sounds like this is a powered off of sort of Apple， and Google's
    API for it。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望它不耗电。理想情况下不耗。但如果你像我一样每天翻阅《纽约时报》，那么这就会用更少的电量。我的初步研究是，我大概看了Deftico 30秒左右，听起来它是由苹果和谷歌的API驱动的。
- en: And they're listed as a trusted partner at the bottom， of the web page。 I can't
    find any technical details， which I don't know if that's something。 that we can
    be concerned about， but maybe I'll just， need to keep doing some more。 I'll put
    a link in the chat to at least an earlier version， of the protocol。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 他们被列为网页底部的可信合作伙伴。我找不到任何技术细节，不知道这是不是我们需要关注的问题，但也许我只是需要继续做一些更多的研究。我会在聊天中放一个链接，至少是协议的早期版本。
- en: And if anyone wants to talk about this at all， definitely send me an email，
    make a post on Piazza。 I think this stuff is really interesting。 I mean， it is
    actually developed on campus。 I mean。 they probably might have released a code，
    right？ If not already。 You'd be surprised what's not open source。 Dave， do you
    know？ I mean， are they releasing the code？
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人想讨论这个问题，欢迎发邮件给我，或者在Piazza上发帖。我觉得这些内容真的很有趣。我的意思是，实际上它是在校园内开发的。我的意思是，他们可能已经发布了代码，对吧？如果还没发布。你会惊讶于有些东西竟然没有开源。Dave，你知道吗？他们发布代码了吗？
- en: I don't know。 I don't know。 The API is public。 I put the--， It's going to be
    an email。 That's on the back one， right？ But then I'm talking about when you're
    the app that。 ended up being developed on call。 Yeah。 There are other apps that
    are open source。 I don't know if this one specifically is， but there are other
    apps developed in other countries。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道。我不知道。API是公开的。我放了——它会是个邮件。那是在后面一个，对吧？但接下来我说的是，当你是那个最终开发出来的应用时。是的。还有其他开源的应用。我不知道这个是否是，但确实有其他在其他国家开发的应用。
- en: other backends。 We developed-- started developing it back。 ended Berkeley as
    well that are open source。 So I don't know。 We'll see。 Hopefully it is。 I see。
    Maybe we should start， Alvin。 Oh， why？ OK， bye。 OK。 Not to keep us on track。 Great。
    So are we already recording today in the cloud？ Cool。 OK。 All right。 We'll keep
    up with that。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 其他后端。我们开始开发——开始在伯克利开发的，也是开源的。所以我不知道。我们会看到的。希望是的。我明白了。也许我们该开始了，Alvin。哦，为什么？好的，拜拜。好的。别让我们跑题。很好。那么今天我们已经在云端录制了吗？酷。好的。好吧。我们会继续的。
- en: So let's go back to our discussion of NoSQL。 So we started this on the Tuesday
    lecture。 in terms of motivation。 So I just want to flash a few slides。 in the
    beginning just to remind ourselves。 So these are the two classes of database applications。
    that we have been talking about in this class。 OLTP basically stands for Transactional
    Processing。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们回到关于NoSQL的讨论。我们在星期二的讲座中已经讨论过了这个动机。所以我只想在一开始快速展示几张幻灯片，提醒自己一下。这些是我们在本课程中讨论的两类数据库应用。OLTP基本上代表的是事务处理。
- en: And then OLAP or OLAP basically means， the kind of data analytical tasks that
    do not require。 a lot of joints or transaction on the board。 Right？ So the reason
    why NoSQL came into existence。 was because people wanted to be able to scale，
    to launch a large number of OLTP workloads that。 are running for their startup
    or whatever the app that they're， doing。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后OLAP，或者说OLAP基本上是指那些不需要大量联接或事务处理的数据分析任务，对吧？所以NoSQL之所以诞生，是因为人们希望能够扩展，启动大量的OLTP工作负载，支持他们的初创公司或他们正在开发的应用程序。
- en: So that is a problem because relational systems， don't tend to scale that easily。
    So you guys already learned about parallel query processing。 So the NoSQL solution
    was to basically give up， on some of the functionalities in trading off for easy。
    to scale up to like large workloads。 So that's where we stopped on Tuesday in
    the lecture。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个问题，因为关系型系统通常不容易扩展。你们已经学过并行查询处理。所以NoSQL的解决方案基本上是放弃了一些功能，换取了易于扩展到大规模工作负载的能力。所以这就是我们在星期二讲座中停下来的地方。
- en: about talking about these type of motivation。 And by the way， by this point
    in the course。 we have pretty much finished all the topics， that we want in comparable
    relational data systems。 So as you remember， we talked about everything， from
    SQL from the very first week of the class。 all the way up till last week， when
    we were talking about parallel query processing。 So far。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 讲到这些动机，顺便说一句，到目前为止，我们已经基本上完成了所有我们在关系型数据系统中想讨论的话题。所以如你们所记得，从课程的第一周开始，我们就讲了SQL，一直到上周，我们讨论并行查询处理为止。到目前为止。
- en: we have only been talking about relational systems。 So NoSQL is basically our
    first lecture。 talking about non-SQL type of data management systems。 So that's
    basically giving you guys。 kind of like a flow of the class and where we are。
    And then if time allows， we also want。 to talk about things like map reduce and
    SPAC， which are again， data management systems。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讲关系型系统。所以NoSQL基本上是我们第一次讲非SQL类型的数据管理系统的讲座。所以这基本上是给你们一个课程的流程图，告诉你们我们现在的进度。如果时间允许，我们还想讨论像map
    reduce和SPAC这样的内容，这些也是数据管理系统。
- en: but they're not relational ones。 And as I was telling you guys last time。 like
    the goal here is not to tell you that， like one of them wins over everybody else。
    So but more about like telling you guys， about the technical interesting ideas。
    behind all these different data systems。 And then let you guys be the judge about
    when。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们并不是关系型的。就像我上次跟你们说的，目标并不是告诉你们哪个系统比其他所有系统更好。更重要的是告诉你们这些不同数据系统背后的一些技术性有趣的想法，然后让你们判断什么时候使用它们。
- en: which ones you want to use and when。 So the motivation for NoSQL， as I said。
    was trying to scale up these transactional workloads。 And they are basically。
    and we are basically doing this by reducing the data model。 and the type of functionality
    that we support， within the system。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你们想使用哪些，并且何时使用。所以，正如我所说，NoSQL的动机就是尝试扩展这些事务型工作负载。它们基本上是通过减少数据模型和我们在系统中支持的功能类型来实现的。
- en: And you see what I mean in a few slides。 So on Tuesday， we also talked a little
    bit。 about these different types of architectures， or like your attempts to scale
    up relational systems。 So we ended up with this kind of three tier architecture。
    that most of web applications are structured these days。 So we have a database
    server backend。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你们会在几张幻灯片中看到我说的意思。所以在周二，我们也稍微讨论了这些不同类型的架构，或者说你们尝试扩展关系型系统的方式。所以我们最终形成了这种三层架构，现在大多数网页应用程序都采用这种结构。我们有一个数据库服务器的后台。
- en: right？ Which is basically where all the data is stored。 And then we have a middle
    tier that is doing， the application server workflow。 So these are basically the
    front end web servers， that you get connected to when you let's say。 go to like，
    you know， google。com or facebook。com or something。 So these are the kind of a。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？这基本上就是所有数据存储的地方。然后我们有一个中间层，它处理应用服务器的工作流。所以这些基本上是前端的网页服务器，当你们访问比如说，像google.com或facebook.com之类的网站时，你们会连接到这些服务器。所以这就是那种架构。
- en: and then finally we have the client here， right？ At the third one。 So that's
    what you're seeing on the far right。 So scaling number of web servers。 the claim
    is that like scaling that is easier， than scaling the data， the data server， right？
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后我们有客户端，对吧？在第三层。所以你们在最右边看到的就是它。扩展网页服务器的数量，主张是说，扩展这个比扩展数据服务器更容易，对吧？
- en: Because of the fact that we don't mean to worry， about things like consistency
    or like。 your durability or that stuff， right？ Because like， you know， all the
    web server does。 is basically connecting to the client， when they request for
    a particular page。 or an action to be done， fetching the data from the database。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们并不打算去担心，比如一致性或者你们的持久性之类的东西，对吧？因为像你们知道的，所有的网页服务器所做的，基本上就是在客户请求某个页面或某个操作时，连接到客户端，从数据库中获取数据。
- en: and then rendering the webpage after that， and sending it back to the client。
    So relatively speaking， it doesn't have too much state。 So that's why it's easier
    to scale。 than let's say like， you know， scaling off the database server， which
    we already talked about。 with the parallel database metrics， right？ So one of
    the primary reasons why it's difficult。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在那之后，呈现网页并将其发送回客户端。所以相对而言，它没有太多的状态。因此比起数据库服务器的扩展，它更容易扩展，正如我们已经讨论过的，使用并行数据库指标，对吧？所以其中一个主要原因是为什么。
- en: to scale relational database servers， is because of the fact that we want to
    have consistency。 So think of all the 2PL stuff， all the 2PC stuff that we talked
    about， right？
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展关系型数据库服务器是因为我们希望保持一致性。想想我们谈过的所有2PL的东西，所有2PC的东西，对吧？
- en: So we want to scale to large amounts of data， or like multiple database servers。
    that we need to worry about those different aspects。 Okay， and then like。 you
    already know the story， about like what that means， we try to scale， when we have
    like multiple。 multiple servers， that we need to deal with on the database side。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们想要扩展到大量数据，或者像多个数据库服务器。我们需要关注这些不同的方面。好吧，然后像这样。你已经知道这个故事了，关于这意味着什么，我们在扩展时，我们有多个。多个服务器，我们需要处理数据库方面的。
- en: So we talk about different strategies， in scaling up the database， right？ Again，
    relational ones。 So one of them we already talked about。 So this is the idea of
    petitioning。 So why don't we just split the data， across multiple database servers？
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们谈论了在扩展数据库时的不同策略，对吧？再说一遍，关系型的那些。我们已经谈过其中一个了。所以这是分区的想法。那么为什么我们不将数据分割到多个数据库服务器上呢？
- en: So that's obviously one way we can scale up， in terms of being able to store
    large amounts of data。 And then we already talked about like different ways， that
    you can petition the data， right？
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这显然是我们可以扩展的一个方式，能够存储大量数据。然后我们已经谈过了你可以通过不同方式来分区数据，对吧？
- en: By range， you know， by hash function， or just by Brown-Robbin， right， for example。
    And not a way。 right？ It's actually to duplicate the data。 If we can afford it。
    The claim here， however。 is that like， for all both of these approaches， it's
    difficult to enforce consistency。 So for petitioning， I think you guys already
    see the picture。 Why that is the case。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过范围，你知道的，通过哈希函数，或者只是通过轮询，举个例子。并不是这样。对吧？实际上是为了复制数据。如果我们负担得起的话。然而，这里的主张是，对于这两种方法，执行一致性是困难的。所以对于分区，我想你们已经看到了这个情况，为什么会是这样。
- en: And I don't need to repeat myself here， right？ Because basically now we are
    talking about 2PC。 right？ For example， running that protocol。 It's definitely
    not like， you know。 it's definitely not zero cost， right？ As you can imagine。
    So just as a reminder， right？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不需要重复自己，对吧？因为基本上现在我们在谈论2PC，对吧？例如，运行那个协议。它绝对不像，你知道的。它绝对不是零成本，对吧？正如你能想象的那样。所以只是作为提醒，对吧？
- en: So scaling through petitioning basically means， that we have many machines that
    is used。 for storing data in a cluster。 And the database might as well be fitting
    in main memory。 if we have enough main memory available。 And then we just spread
    the queries。 across the machines and that's it。 The claim here is that we can
    increase throughput， because like。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通过分区扩展基本上意味着，我们有许多机器用于存储集群中的数据。如果我们有足够的主内存可用，数据库也可以适合在主内存中。然后我们只是将查询分发到各个机器上，完成了。这里的主张是我们可以增加吞吐量，因为像。
- en: you know， in the optimal case， where we don't need to touch multiple machines，
    to process a query。 then like， you know， they can just run in parallel。 So each
    of the machines can be processing。 different incoming clients。 So the number of
    clients that we can process strictly。 is just depending on how many database servers，
    that we are able to afford。 Again。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，在最优情况下，我们不需要触及多个机器来处理查询。那么，你知道的，它们可以并行运行。每个机器可以处理不同的入站客户端。所以我们可以处理的客户端数量严格来说，就是取决于我们能够负担得起多少数据库服务器。再说一遍。
- en: this is the big assumption that， like， you know， we don't need to run expensive
    protocols like 2PC。 and we don't need to detect things， like that block detection
    and all that other cool stuff。 As you can imagine， right？ You know， it's easy
    to write things in this world。 because things have already been petitioned， across
    different servers。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大假设，像，你知道的，我们不需要运行像2PC那样昂贵的协议。我们也不需要检测那些事情，比如块检测和其他那些很酷的东西。正如你能想象的那样，对吧？你知道，在这个世界里写东西是很容易的。因为东西已经被分区到不同的服务器上。
- en: So once we identify the record that we need to update， we just update it there。
    That's it， right？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一旦我们识别出需要更新的记录，我们就直接更新它。就这样，对吧？
- en: So the picture， this is like one picture that you might imagine。 So for example，
    like， you know。 we split， across three different database servers， in this picture
    here。 each of them is holding on to， let's say， a range of values， a range of
    the tool codes， right？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片，可能是你会想象的一张图。举个例子，像，你知道的。我们在这里将数据分割到三个不同的数据库服务器中。每个服务器都保存着，比如说，一段值范围，工具代码的范围，对吧？
- en: So here， for example， the application can be updating， on the left most server。
    It might also be updating something else， right， on the right most server。 And
    then for the most part， these updates， are pretty much independent， right？
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，应用程序可以在最左边的服务器上进行更新。它也可能在最右边的服务器上更新其他内容。大多数情况下，这些更新基本上是独立的，对吧？
- en: So that's like one of the benefits， of doing it through a petitioning。 So another
    way to scale the database is through replication。 So the idea here is to basically
    say that， instead of petitioning the data。 why not just duplicate it completely，
    across multiple servers， right？ So like， you know。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是通过分区来做的一项好处。扩展数据库的另一种方式是通过复制。这里的想法基本上是，为什么不完全复制数据，跨多个服务器呢？就像你知道的那样。
- en: let's say I have three different machines， again， same situation here。 If the
    data size is not that big yet， I can actually just replicate the entire data set。
    across all machines。 Why is that beneficial？ Because now I can spread the queries，
    right？
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有三台不同的机器，再次强调，这里是相同的情况。如果数据量还不大，我实际上可以将整个数据集复制到所有机器上。为什么这样做有益呢？因为现在我可以分摊查询，对吧？
- en: Because everybody is getting the exact same， identical copy of the data。 So
    therefore asking anyone of the servers， to process the incoming query is just
    as good enough。 It's just as good as any other server， okay？ So in this case，
    we can also increase the throughput。 right， of the system because of the fact
    that we can run these queries。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个人都获得了完全相同的、相同的数据副本。所以，要求任何一台服务器来处理传入的查询是完全足够的。这和任何其他服务器一样好，明白了吗？所以在这种情况下，我们也可以提高系统的吞吐量，因为我们可以在不同的服务器上并行运行这些查询。
- en: in parallel across different servers。 And it's also good for fault tolerance。
    because even if one of the machines crashes， right， we can just route or reroute
    all the queries。 to the other servers that are up， while we wait for the crashed
    server to recover。 So therefore we don't need to stop the work， right？ Unlike
    in the sharding or the petition in case。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这对容错性也有好处。因为即使其中一台机器崩溃，我们也可以将所有查询重新路由到其他正常运行的服务器，同时等待崩溃的服务器恢复。因此，我们不需要停止工作，对吧？这与分片或分区的情况不同。
- en: where if one of the machines crashed， then it basically brings down with it
    all the data。 that is currently holding。 So if any of the incoming queries wants
    to read。 or write to any part of that data， then it's basically not available
    at that point。 In this world。 however， it's easy to read data， but writes becomes
    more expensive。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一台机器崩溃，那么它基本上会导致所有当前持有的数据都不可用。因此，如果任何传入的查询想要读取或写入该数据的任何部分，那么此时这些数据就不可用了。然而，在这个世界里，读取数据很容易，但写入变得更加昂贵。
- en: just because of the fact that we are now， replicating the exact data set across
    multiple machines。 So therefore， writes to any one of those machines。 will now
    be translated into writes across all the machines。 because everybody is holding
    onto the same data sets， right？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只是因为我们现在正在跨多台机器复制完全相同的数据集。所以，写入任何一台机器的数据将会被转化为写入所有机器的数据。因为每台机器都持有相同的数据集，对吧？
- en: So it's good for spreading queries across multiple servers。 because everybody
    is having the same identical data sets。 so it doesn't matter which one you really
    get routed to。 The downside is that， like。 if you ever want to update anything，
    then this is going to be expensive。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它有利于将查询分布到多个服务器上，因为每个人都有相同的、完全相同的数据集。因此，无论你路由到哪个服务器，都没关系。缺点是，比如说，如果你想更新任何内容，那么这将变得非常昂贵。
- en: because now we are talking about writing to multiple servers。 So what is the
    end goal here？ Well。 so it basically means that if you have， in the optimal case，
    a read-only workload。 that never writes anything or updates anything， then that's
    great because we never need to deal。 with this problem of writes， right？ So therefore，
    we can just run the query。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在我们在谈论向多个服务器写入数据。那么这里的最终目标是什么呢？嗯，这基本上意味着如果你在最佳情况下有一个只读工作负载，永远不会写入或更新任何内容，那就太好了，因为我们根本不需要处理写入问题，对吧？因此，我们只需运行查询。
- en: on any one of those servers。 So for example， if you are running queries。 that
    try to compute aggregates， or try to compute statistics or something， right？
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一台服务器上，举个例子，如果你正在运行查询，试图计算聚合，或试图计算统计数据之类的内容，对吧？
- en: So these queries don't need to update anything， so therefore it's good to be
    running them。 across these replicated servers， for example。 So hopefully this
    gives you some sense。 of like how scaling relational systems work。 So now let's
    talk about， like， you know， why no SQL。 right？ So one of the primary reasons is
    because it's difficult， to replicate data， as I said。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些查询不需要更新任何内容，因此在这些复制的服务器上运行它们是不错的。例如。希望这能让你对关系型系统如何扩展有所了解。现在我们来谈谈为什么使用NoSQL，对吧？其中一个主要原因是因为数据复制很困难，正如我所说的。
- en: right for relational systems。 So I already told you the trade-offs。 between
    the two different schemes that we have talked about。 So， like， you know， for example。
    in this case， let's say I have， these three different relations here， petitioning。
    Now basically means that we might end up doing joints， right， across multiple
    servers。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型系统的权衡。就像我之前告诉你们的，我们已经讨论过的两种不同方案之间的权衡。所以，比如说，在这个例子中，假设我有这三个不同的关系在这里，分区。基本上意味着我们可能会在多个服务器上做连接。
- en: If we need to read data that is currently reciting， on multiple machines。 And
    we already learned about the different ways， that we can do parallel joints， right？
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要读取当前在多台机器上存在的数据，我们已经了解了我们可以做并行连接的不同方式，对吧？
- en: So that took one whole lecture， just talking about that。 So you can imagine
    how expensive that is going to be， right？
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这花了一整节课来讨论这个，你可以想象它有多昂贵，对吧？
- en: Versus if we do scale up using this replication， or duplicated data set way。
    then we are running local joints， so that's great。 But then， you know， depending
    on how consistent。 all these different servers are， because of the fact that there
    might be updates。 that have not been propagated yet， then we might either need
    to wait。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这种复制或者重复数据集的方式进行扩展，那我们就会运行本地连接，这样很好。但然后，你知道的，取决于不同服务器的一致性如何，因为可能会有一些更新尚未传播，那么我们可能需要等一等。
- en: for those updates to be propagated， if you want to read a consistent view of
    the database。 or we ended up returning values that can be slightly off。 Right？
    So this is， again， a trade-off。 right？ No such thing as free lunch。 So this is
    the problem with the relational model。 And I have already explained to you why
    consistency is。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想读取数据库的一致视图，或者我们最终返回的值可能稍有偏差，对吧？所以，这又是一个权衡，对吧？没有免费的午餐。这就是关系模型的问题。我已经向你解释了为什么一致性变得如此困难。
- en: turns out to be hard for both of these cases， right？ So no SQL came into the
    picture and said， like。 okay， let's just simplify the data model。 So let's just，
    like， you know， use something。 out of them relations。 And by the way， let's also
    give up some of the functionality。 Is that relational systems tend to give us？
    So for example， consistency。 Basically。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明这两种情况都很难做到一致，对吧？所以NoSQL应运而生，并说，好的，我们简化一下数据模型。那么我们就像，知道的那样，使用一些不依赖关系的东西。顺便说一下，我们也放弃一些关系型系统通常提供的功能。例如，一致性，基本上是这样的。
- en: that means if your application， ever wants to be able to run things like joints。
    or they care about reading the most up-to-date data， well， then they need to figure
    out themselves。 So the option is always there， right？ So like， you know， the application
    developer can always。 re-implement or implement some of these， functionalities
    on their own in the application itself。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你的应用程序想要能够执行类似连接的操作，或者他们关心读取最新的数据，那么他们需要自己搞定。所以这个选项永远存在，对吧？例如，应用程序开发者总是可以在应用程序中重新实现或者自己实现一些这样的功能。
- en: But from a database system point of view， those are no longer going to be functionalities。
    provided by the system itself。 Does that make sense？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是从数据库系统的角度来看，这些将不再是由系统本身提供的功能。这样讲明白了吗？
- en: So think of it as like your implementing book base， except that there's no joints
    available， right？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以把它当作你在实现书籍库，只是没有可用的连接，对吧？
- en: I mean， there's only selections。 You can read， right？ And then if you ever want
    to do a joint， well。 read all the data yourself， and then implement your favorite
    joint algorithm， right？
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，只能选择。你可以阅读，对吧？然后，如果你想做一个连接，那就自己读取所有数据，然后实现你喜欢的连接算法，对吧？
- en: So that's always， that's always， that's always a case。 And then another way
    of contrasting between。 relational systems and NoSQL is something， that you might
    learn in CAM1A。 So as said， right。 we already talked about that， in this class，
    so not going to repeat what that means。 And hopefully you guys will remember what
    that means， by the time the final comes。 And for NoSQL。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这始终是这样。然后，另一种区分关系型系统和 NoSQL 的方式是，你可能会在 CAM1A 中学到的东西。就像之前所说的那样，对吧？我们已经在这门课中讨论过了，所以我不打算重复它的意思。希望到期末时你们能够记住它的意思。对于
    NoSQL 来说。
- en: they came up with something similar。 So we talk about basic availability in
    NoSQL。 Unlike atomicity。 we're now talking about a case， where the application
    basically has to handle。 all these potential failures themselves。 So we ended
    up talking to a server that is down。 then is the application's responsibility，
    to figure out where to fetch the data from。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提出了类似的概念。所以我们讨论的是 NoSQL 中的基本可用性（basic availability）。不同于原子性（atomicity），现在我们谈的是一种情况，在这种情况下，应用程序基本上必须自己处理所有这些潜在的故障。因此，当我们与一个服务器通信时，如果该服务器宕机了，那么应用程序就有责任弄清楚从哪里获取数据。
- en: So it's not going to， the database is not going， to provide even recovery， for
    example。 That's one option。 And then that's what basic availability means， right？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它不会，数据库不会提供例如恢复（recovery）等功能。这是一个选择。然后这就是基本可用性（basic availability）的含义，对吧？
- en: So it means that it's no longer always available。 Sometimes that is available，
    sometimes it's not。 right？ So that's what V here stands for。 And then we also
    talk about soft state。 So unlike in the relational data model， where everything
    has to be consistent and durable。 in this case for NoSQL， we need to be able to
    handle cases。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这意味着它不再总是可用。有时候是可用的，有时候则不可用，对吧？所以这里的 V 代表的就是这个意思。接下来我们还谈到软状态（soft state）。与关系数据模型不同，在关系数据模型中，一切必须是一致和持久的。而在
    NoSQL 中，我们需要能够处理这种情况。
- en: where the database state can actually change， while we are reading。 And I'm
    not talking about phantoms here。 I'm just talking about the fact that。 since the
    updates can take time to propagate， to the different servers in the NoSQL system。
    so we might need to do with the fact， that even without a new incoming query。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的状态在我们读取时可能发生变化。我在这里说的不是幻读（phantoms），我只是想说，由于更新可能需要时间传播到 NoSQL 系统中的不同服务器，因此我们可能需要处理这样一种事实：即使没有新的查询进入，数据库最终也会变得一致。
- en: that is trying to update anything， different reads from a single application。
    can actually return different results， just because of the fact that new updates。
    could have been propagated while in between， the two reads that the application
    is trying to do。 And then they also talk about eventual consistency。 So basically
    what that means is。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 即尝试更新任何内容时，来自单一应用程序的不同读取实际上可能返回不同的结果，这只是因为新更新可能已经在应用程序执行两次读取之间传播过了。然后他们还谈到了最终一致性（eventual
    consistency）。基本上这意味着什么呢？
- en: the database will eventually become consistent。 So this is a consistency model。
    that we have not talked about in this class。 So in this class so far in the relational
    model。 we have talked about like， we want to run like， you know， straight to BL。
    we want to have serializability， and all the other good stuff， right？
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一种一致性模型，我们在这门课上还没有讨论过。在这门课中，到目前为止，我们在关系模型中讨论过，我们希望运行像，嗯，你知道的，直接到 BL，我们希望具有可串行化性（serializability），以及所有其他好的东西，对吧？
- en: But in NoSQL we now talk about， we don't really care about whether things are
    serializable， or not。 So notice that this is different meaning， right？ And saying
    that there's no consistency。 All this is saying is that eventually， the database，
    the databases will become consistent。 meaning that we can tolerate late updates，
    or updates while we're trying to do reads。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在 NoSQL 中，我们现在讨论的是，我们并不在乎事情是否是可串行化的。请注意，这是不同的意思，对吧？说没有一致性，并不是说没有一致性。所有这说的是，最终，数据库将变得一致，意味着我们可以容忍延迟更新，或者在我们尝试读取时进行更新。
- en: and all that other good stuff， right？ So we're not saying that we're completely
    flowing。 consistency out of the window。 All that we're saying is that things。
    will eventually become consistent， but then we're not saying when that will happen。
    Eventually it might mean in 10 minutes an hour， or like never for example， right？
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他所有好的东西，对吧？所以我们并不是说完全把一致性抛之脑后。我们要说的只是，事情最终会变得一致，但我们并没有说什么时候会发生。最终可能是 10 分钟后，1
    小时后，或者永远不会发生，对吧？
- en: Or like infinite a lot， right？ So that's not violating anyway。 So like， you
    know， that's basically。 some of the things that we talked about in NoSQL。 Why
    is that okay， right？ For example， well。 I mean， think about， if you're running，
    if you're implementing， like your IG or something。 right Instagram。 So like， you
    know， do you really care that much。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像无限制一样，对吧？所以这并不违反任何规则。所以，基本上，这就是我们在NoSQL中讨论的一些内容。为什么这样是可以的呢？例如，想一想，如果你正在运营Instagram之类的应用，对吧？所以，像你知道的，你真的很在乎这些吗？
- en: if someone is posting a picture on like， you know， his or her account and then
    pop。 propagating that update to everybody， like， you know， that follows that particular
    person。 I mean。 maybe not， right？ So it's okay if some of your friends see a picture
    first。 before some of your other friends see that later on， right？ So， you know，
    big deal， okay？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，如果有人在他的账户上发布一张照片，然后传播这个更新给所有关注这个人的人，我是说，可能不会这样，对吧？所以，如果你的一些朋友先看到了照片，而其他一些朋友稍后看到了，那没关系，对吧？所以，这不是什么大问题，好吗？
- en: This is not， this is different from the banking example。 They were talking about
    what we were voting for， voting training transactions， right？
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是银行案例，这与银行案例不同。他们讨论的是我们投票的内容，投票训练事务，对吧？
- en: So for transactions， you probably don't want to live， in the world where like，
    you know。 money can be deducted from your account， but not yet deposited into
    like， you know。 the other person or your friends account， right？ That's not okay。
    So there's a different application use case， that we are talking about here。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事务，你大概不希望生活在那种世界里，对吧？比如，钱可以从你的账户扣除，但还没有存入到另一个人或你朋友的账户里，对吧？那样不行。所以我们在这里讨论的是不同的应用案例。
- en: So here we are talking about the Facebooks， and the IGs and all the social networking
    websites。 for instance， right？ Where， you know， it doesn't really matter whether
    like， you know。 post or wall shows up or like， you know， later on or take a little
    bit of time to propagate。 So those are the kind of applications， that we're talking
    about here。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们谈论的是Facebook、Instagram和所有社交网络网站之类的应用。例如，你知道的，是否某个帖子或墙壁显示出来，或者稍后显示，或者需要一些时间传播，这些其实并不重要。所以我们在这里讨论的就是这些类型的应用。
- en: But to round this line and why am I saying cam one day， right？ Because like，
    you know。 this is the acronym， that we came up with or NoSQL based， right？
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我说这行要圆一下呢？对吧？因为这是我们根据NoSQL系统总结出来的缩写，明白吧？
- en: And that is exactly in contrast to acid， which came from the relational world，
    right？
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好与来自关系型世界的ACID相对立，对吧？
- en: That's something that might actually help you guys remember， the difference
    between relational。 and NoSQL systems。 Any questions about this so far？ Okay，
    so now let's talk about data models。 in the NoSQL world。 So it turns out that
    there are a few of them actually， to choose from。 So it's not like， you know，
    unlike relational systems， where everything is stored in relations。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于你们记住关系型数据库和NoSQL系统之间的区别。到目前为止，有什么问题吗？好的，现在让我们谈谈NoSQL世界中的数据模型。所以事实证明，实际上有几种可以选择的模型。所以这和关系型系统不同，关系型系统中一切都存储在关系中。
- en: And NoSQL world is basically talking about， it's basically using something other
    than relations。 to store data。 So let's talk about different data models。 So in
    this class。 I just wanna briefly talk about the first two， and then we'll actually
    focus more。 on the last one called document stores。 But， you know， we first need
    to understand。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL世界基本上是在说，使用其他东西而不是关系来存储数据。所以我们来谈谈不同的数据模型。在这节课里，我只想简要介绍前两个，然后我们将更多关注最后一个，叫做文档存储。但你知道，我们首先需要理解。
- en: what is the basic principle， behind these different data models in NoSQL。 So
    the first one。 key value stores。 You guys have probably heard about key value
    stores before， right？
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL中这些不同数据模型背后的基本原理。所以第一个，键值存储。你们可能以前听说过键值存储，对吧？
- en: Can I get a show of hands？ For those of you who have heard about this？ Yeah，
    for sure， right？ Yeah。 key value pairs。 Yeah。 Great。 Yeah。 So what does that mean，
    right？ So this is extremely simple。 So it's basically saying that everything，
    is can only be a key and value pair。 So we're not talking about relations with
    a schema。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 能举手一下吗？有谁听说过这个的吗？是的，当然，对吧？是的，键值对。是的，太好了。那这意味着什么呢？对吧？其实非常简单。就是说一切只能是键值对。所以我们不是在讨论有模式的关系。
- en: and then with like the columns and all the other good stuff。 Okay。 In particular。
    key here can be anything， like a string or an integer。 as long as it is unique
    for the entire data sets。 So think of that as like， you know， primary key。 that
    we already know about in the relational world。 And value can really be anything。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就像列和其他所有好东西。好吧。特别地，键可以是任何东西，比如字符串或整数，只要它在整个数据集里是唯一的。所以可以把它看作是，嗯，我们在关系型数据库中已经知道的主键。值可以真的是任何东西。
- en: It can be like an array， a list of names， a set， a picture， you know， a binary
    blob of file。 anything。 So it can be anything that is complex。 As long as there's
    a way to uniquely identify。 that piece of data， otherwise no one's the key。 Okay。
    So that's it。 So forget about like， you know。 normal forms， or the fact that you
    have， we even have to have like every tool bowl。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是一个数组，一份名字列表，一个集合，一张图片，或者一个二进制文件块。任何东西。所以它可以是任何复杂的东西。只要有一种方法可以唯一标识那一段数据，否则就没有键。好吧。就是这样。所以忘掉那些像是规范化，或者你有，甚至我们必须拥有的每个工具框之类的东西。
- en: have the same schema that got， I think no more schema here。 Everything is just
    a key and a value pair in this world。 And the operations that are supported。 is
    only gets and puts， right？ Gets just is another way of saying retrieval。 based
    on a prime based on the key。 And input is basically a way to insert data。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相同的架构，我想这里没有更多的架构了。在这个世界里，一切只是一个键值对。而支持的操作，只有获取和放入，对吧？获取只是说基于键进行检索的另一种方式。而放入基本上是插入数据的方式。
- en: into a key value store。 And then it doesn't support anything else。 So for example。
    if you need to extract something， out of a value， right？ So like let's say， you
    know， use， you know。 let's say we put a list of names as a value， right？ Or list
    of friends， for example。 or a particular person。 Then if we want to check with
    it， like， you know。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个键值存储系统。然后它不支持其他任何东西。所以举个例子，如果你需要从一个值中提取某些内容，对吧？比如说，假设你知道，使用，嗯，假设我们把一份名字列表作为值，对吧？或者朋友列表，例如，或者某个人的名字。然后如果我们想检查它，比如，你知道。
- en: so and so is a friend of that particular person， that we need to write that
    out position now ourselves。 It's not supported by the system。 Okay。 So all that，
    all the systems support is just get and put。 That's it。 So one of the benefits，
    right？ I mean， you can already see that it's relatively easy。 It's an implement
    that， right？ So imagine we are， imagine we give you this。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，某人是某个特定人的朋友，我们现在就需要手动写出这个关系。系统不支持这种操作。好吧。所以系统支持的所有功能就是获取和放入。仅此而已。所以其中一个好处，对吧？你们可以看到它相对容易实现，对吧？所以想象一下，我们，假设我们给你这个。
- en: like you ask the assignment for look page， right？ I think all of you guys were
    just like being。 like， you know， smiling now， right？ If that's the case， we don't
    want to support anything。 There's no joint。 There's no like group by， there's
    no equity。 None of that news。 Forget about transaction， for example， right？ Is
    this system just a hash map？ Well。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你要求作业时看的页面，对吧？我想你们大家现在都在笑，对吧？如果是这样，我们就不想支持其他任何东西。没有联接。没有像是分组、没有联合、没有聚合。没有那些新鲜事。比如说，忘掉事务处理，对吧？那么这个系统就是一个哈希映射吗？嗯。
- en: you can think of it。 Yeah， in a sense， it is just a hash map。 It's a gigantic
    hash map in that sense。 However， they， you know， we do need to support， like。
    you know， distribution of data of this key value pairs。 And that also is made
    simple because of the fact that， you know。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这么想。是的，从某种意义上说，它确实就是一个哈希映射。在这个意义上，它是一个庞大的哈希映射。不过，像是，我们确实需要支持，嗯，像是，数据的分布，针对这些键值对。这个也变得简单了，因为，嗯。
- en: we can just use hash based petitioning， as a very simple example， right？
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用基于哈希的分区作为一个非常简单的例子，对吧？
- en: Or just replicate the data across multiple servers， just like before。 And what
    I'm saying here is multi-way petitioning。 is just the same way as what we've been
    talking about earlier。 the relational parallel database system， of using hash
    based petitioning to split data。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像以前一样，把数据复制到多个服务器上。而我在这里说的多路分区，就是我们之前讨论的关系型并行数据库系统中的方式，使用基于哈希的分区来拆分数据。
- en: The question， however， is like， you know， how to implement， get and put， right？
    For example。 so let's get， go through an example here。 So let's say I want to
    store， like， you know。 this piece of data， this， like， you know， data set here
    consisting of flights and carriers。 So。 like， you guys already know how to do
    that， in a relational system， right？ So， you know。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题是，像，嗯，你知道，如何实现，获取和存储，对吧？例如。让我们通过一个例子来说明。假设我想存储，比如，你知道。这些数据，这个，你知道，包含航班和承运人的数据集。那么，你们已经知道如何在关系型系统中做到这一点，对吧？嗯，你知道。
- en: just declare two relations， and that's it。 But in a key value store。 that turns
    out to be different ways， that we can do that， right？ So for example。 we can have
    to keep being the slight ID， which of course should be a unique identifier。 And
    then be the value being the rest of the record， right？
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只声明两个关系，仅此而已。但在键值存储中。结果是我们可以通过不同的方式来做到这一点，对吧？例如。我们可以将键设置为航班ID，当然它应该是唯一标识符。然后值就是其余的记录，对吧？
- en: So basically all these different attributes do。 We can also have the key being
    the date of the flight。 which， you know， should be also unique， right？ Because
    there's only one， like， you know。 November 19th， 2020。 And then the value just
    corresponds。 to all the flights that happened during that day。 You know， that's
    another option。 I mean。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，基本上这些不同的属性做的事情。我们还可以将键设置为航班的日期。你知道的，日期也应该是唯一的，对吧？因为只有一个，像，你知道的，2020年11月19日。然后值就对应那天发生的所有航班。你知道的，这也是一个选项。我是说。
- en: not saying， like， it's wrong or right， or， I mean， you know， it gets the job
    done。 And it stores all the data that we want。 And then another one is， like，
    you know。 by origin and destination pairs， and then all the flights in between。
    Which one is better？ Well。 it depends on what is your use case， right？ So if your
    use case is， like， you know， an application。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说，像，错或者对，或者，我的意思是，你知道，它完成了工作。它存储了我们想要的所有数据。然后另一个方法是，像，你知道，通过出发地和目的地对，以及两者之间的所有航班。哪一个更好？嗯，这取决于你的使用场景，对吧？所以，如果你的使用场景是，像，你知道，一个应用。
- en: that allows people to look up flights between two cities， then obviously， option
    three is the best。 Because that allows us to immediately fetch all the flights，
    that we want， right？
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得人们可以查找两座城市之间的航班，那么显然，选项三是最好的。因为它允许我们立即获取我们想要的所有航班，对吧？
- en: So think of how you might want to do， implement the same thing。 if you were
    to use a relational system， with these two particular relations， for example，
    right？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，想一想，如果你使用关系型系统，针对这两个特定关系，如何实现相同的事情，举个例子，对吧？
- en: So if I want to write a query， that， like， you know， fetches all the flights
    from San Francisco to。 like， New York or something， right？ I mean， now we are
    already talking about a joint， right？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我想写一个查询，像，你知道，获取所有从旧金山到，比如，纽约之类的航班，对吧？我的意思是，现在我们已经在谈论联接了，对吧？
- en: Because we need to do a self-joint order to break out， these cases。 Okay？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要做一个自连接，以便解决这些情况。好的？
- en: But then if we use option three， for instance， right， as a no-sequel store，
    then it's trivial。 right？ And then just get the right city names and then send
    it， over to the database， and that's it。 Okay？ So， you know， that's basically
    one of the trade-offs， that I want to mention。 And then as I said， right， there
    are multiple ways to， partition data in this world。 You can。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们使用选项三，例如，作为一个NoSQL存储，那么它就很简单，对吧？然后只需要获取正确的城市名称，再传送给数据库，完事。好的？所以，你知道的，这基本上是我想提到的其中一个权衡点。然后正如我所说的，嗯，这个世界上有多种方式来划分数据。你可以。
- en: we can use a hash function， or we just， we can just， replicate data， right？
    As I mentioned before。 we can store things on multiple servers， and on an， and
    when an update happens， let's say。 when a put happens， right？ Then we can propagate
    the changes to other servers as we like。 We can propagate them immediately。 We
    can also propagate them， like， you know， as time allows。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用哈希函数，或者我们可以，嗯，直接复制数据，对吧？如我之前提到的。我们可以将数据存储在多个服务器上，当更新发生时，假设，当存储操作发生时，对吧？然后我们可以根据需要将更改传播到其他服务器。我们可以立即传播它们。我们也可以像，你知道的，按时间推移传播它们。
- en: right？ That is the principle of eventual consistency。 Except， as I said， right？
    You know。 if we ended up needing to， if the application， actually need up-to-date
    information。 then it might need to， actually first check whether it has， it is
    talking to replica。 That contains all the most up-to-date data。 So， like， that
    is possible to be done， right？
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？这就是最终一致性的原则。除非，正如我之前所说的，对吧？你知道的，如果我们最终需要，假如应用程序实际上需要最新的信息，那么它可能需要先检查是否正在与包含最新数据的副本进行通信。所以，这完全是可以做到的，对吧？
- en: As you can imagine， we can implement that functionality。 in the application
    itself to do the checking。 Maybe another application actually doesn't care about。
    like， you know， reading up-to-date data。 And if that's the case， well。 then don't
    bother doing the check。 So， here， again， right？ The idea is that， when you know。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，我们可以在应用程序本身中实现这个功能来进行检查。也许另一个应用程序根本不关心，像你知道的那样，是否读取到最新的数据。如果是这样的话，那就不需要做检查。所以，再次强调，对吧？这里的想法是，当你知道。
- en: by pushing the functionalities into， the application， then it makes the database
    system， right？
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将功能推送到应用程序中，它使得数据库系统变得更加灵活，对吧？
- en: In this case， the no-sequel system implementation to be very simple。 We're basically
    trading off the fact that， you know。 not every application needs to read the most
    up-to-date information， and therefore， if you need it。 well， implement that on
    top of the， database server or database system itself， right？
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，实施无SQL系统会非常简单。我们基本上是权衡了这样一个事实：你知道的，并不是每个应用程序都需要读取最新的信息，因此，如果你需要，它可以在数据库服务器或数据库系统本身之上实现，对吧？
- en: And by default， the system is not going to enforce that unless， someone wants
    to do it。 But that's。 again， it's up to the application。 Are we clear on this？
    Okay。 So， as I said， right？
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，系统不会强制执行，除非有人想要这样做。但这又是应用程序的决定。我们清楚了吗？好吧。正如我之前所说的，对吧？
- en: That's one of the ways， one of the data models for no-sequel。 which is as simple
    as just key-value stores。 Another one is called extensible rack-up stores。 So。
    this one is also called wide-column stores if you look up on， but， you know， the
    literature。 It's actually based on a paper from Google called Bigtable。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无SQL的其中一种数据模型，就像简单的键值存储。另一种叫做可扩展的汇总存储。所以，如果你在文献中查找，它也被称为宽列存储。它实际上是基于谷歌的一篇论文，叫做
    Bigtable。
- en: It's one of the first no-sequel stores out there。 There's also an open-source
    implementation of that if you want。 to play around with it。 The idea is basically
    like， you know。 one level up about basic key-value stores。 So， they want to retain
    some of the features of relations。 namely the fact that， like， you know， there
    is， there are rack-ups， there are， like， you know。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个无SQL存储之一。如果你愿意，也可以找到它的开源实现来尝试一下。这个想法基本上就像你知道的那样，是比基础的键值存储更进一步的一个层次。所以，他们希望保留关系型的一些特性，特别是像你知道的那样，存在一些汇总，像你知道的那样。
- en: there's just aspects where every table， contains only two posts of a specific
    schema， for instance。 But then they also want to have the flexibility of key-value
    stores。 So。 what they ended up proposing is this idea of， like， you know。 having
    a data model still being key-valued for the most part。 But then， like， you know。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方面，每个表格只包含特定模式的两条记录，例如。但他们也希望拥有键值存储的灵活性。所以，最终他们提出的想法是，像你知道的那样，保持数据模型大部分时间仍然是键值对的。但后来，像你知道的那样。
- en: the key here is kind of restricted。 So， it can still have a unique identifier
    and then have。 as the key， that's possible。 But then now we're restricting。 but
    then another way is to basically say， that the key itself is a combination of
    rows and also columns。 So， they're basically bringing back this notion of a schema，
    just like in a relation。 So。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是有所限制。所以，它仍然可以有一个唯一标识符，然后作为键值，这样是可能的。但现在我们做了限制。另一个方法是基本上说，键本身是行和列的组合。所以，他们基本上重新引入了一个模式的概念，就像关系型数据库中一样。所以。
- en: you can no longer just stick anything that is a unique identifier。 if they were
    to all reside within the same table。 So。 big table basically brings back this
    notion of a collection of two posts， with a similar， similar。 with the same schema
    together as in a relation。 But then they don't want to restrict every single。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再能把任何唯一标识符直接放进去，如果它们都存储在同一个表中。所以，大表基本上重新引入了一个概念，即将具有相同模式的两条记录集合放在一起，就像关系型数据库一样。但他们不想限制每一条记录。
- en: every single two posts， to have the exact same key。 So， basically， they say
    that， okay。 so one way we can do that is by having both， a row ID as the key。
    or we can also have a combination of the row ID， and some combination of the columns
    to be the key value。 Sorry， to be the key in a tuple。 So， all two posts within
    the same table would still need to have a schema。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每两个帖子都需要有相同的键。所以，基本上，他们说，我们可以通过使用行 ID 作为键来实现，或者我们也可以使用行 ID 和一些列的组合作为键值。抱歉，应该是作为元组中的键。所以，同一表中的所有两个帖子仍然需要有一个模式。
- en: But then， like， it's not the case that every single row needs to be looked up。
    using only as unique identifier。 So， we can look it up by also the combination
    of the unique identifier。 otherwise， otherwise， with the row ID and also some
    subset of the attribute names。 Otherwise。 it's pretty much the same thing as key
    value store。 So。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不是每一行都需要仅仅通过唯一标识符来查找。所以，我们也可以通过唯一标识符的组合来查找，或者使用行 ID 和一些属性名称的子集来查找。否则，基本上它和键值存储是一样的。所以。
- en: we won't be talking too much about that in this class because this is just。
    basically a hybrid between key value stores and the relational systems that we
    know about。 So。 Nick is asking， "Is it this functionality pretty much the same
    thing as key value？"， Yeah。 it's actually very much similar。 The only thing is
    we're now bringing back a little bit of regularity into the picture here。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，我们不会深入讨论这个问题，因为这基本上是键值存储和我们熟悉的关系型系统之间的混合体。所以，Nick 问：“这个功能和键值存储是不是差不多？”，是的，实际上它非常相似。唯一的区别是，我们现在在这里引入了一些规律性。
- en: because we're forcing every tuple to have a bunch of column names。 just like
    in a relational system versus in the key value case。 it doesn't even need to have
    column attribute names at all。 So， for a while column。 it's easier to query by
    two full columns。 So， it also depends on your use case that you have in mind。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们强制每个元组都必须有一组列名。就像在关系型系统中一样，而在键值存储的情况下，它甚至不需要有列属性名。所以，对于某些列而言，通过两个完整的列来查询会更容易。因此，这也取决于你想要解决的使用场景。
- en: So。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以。
- en: '![](img/4969c3b6bdb2795df8c30a9a8a3dbbc9_3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4969c3b6bdb2795df8c30a9a8a3dbbc9_3.png)'
