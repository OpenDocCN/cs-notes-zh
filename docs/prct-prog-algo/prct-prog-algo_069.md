# 2.3 递归

> 原文：[`introcs.cs.princeton.edu/python/23recursion`](https://introcs.cs.princeton.edu/python/23recursion)

从一个函数调用另一个函数的想法立即引出了函数调用*自身*的可能性。Python 中的函数调用机制支持这种可能性，这被称为*递归*。递归是一种强大的通用编程技术，是许多至关重要的计算应用的关键，从组合搜索和排序方法（提供信息处理的基本支持（第四章））到用于信号处理的快速傅里叶变换。

* * *

## 你的第一个递归程序

递归的"HelloWorld"程序是实现*阶乘*函数，对于正整数`n`，它由以下方程定义：

> *n*! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1

用`for`循环计算*n*!很容易，但更简单的方法是使用以下递归函数，factorial.py 中使用了这种方法：

```py
def factorial(n):
    if n == 1:
        return 1
   return n * factorial(n-1)

```

你可以说服自己它会产生期望的结果，注意到`factorial()`在*n*为 1 时返回 1 = 1!，并且如果它正确计算值

> (*n*-1)! = (*n*-1) × (*n*-2) × ... × 2 × 1

然后它正确计算值

> *n*! = *n* × (*n*-1)! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1

我们可以像追踪任何函数调用序列一样追踪这个计算过程。

```py
factorial(5)
   factorial(4)
      factorial(3)
         factorial(2)
            factorial(1)
               return 1
            return 2*1 = 2
         return 3*2 = 6
      return 4*6 = 24
   return 5*24 = 120

```

我们的`factorial()`实现展示了每个递归函数所需的两个主要组成部分。

+   *基本情况*在不进行任何后续递归调用的情况下返回一个值。这是为了一种或多种特殊输入值，函数可以在没有递归的情况下进行评估。对于`factorial()`，基本情况是`n = 1`。

+   *减少步骤*是递归函数的核心���分。它将一个（或多个）输入处的函数与另一个（或多个）输入处的函数相关联。此外，参数值序列必须*收敛*到基本情况。对于`factorial()`，减少步骤是`n * factorial(n-1)`，每次调用`n`减少一次，因此参数值序列收敛到`n = 1`的基本情况。

* * *

## 数学归纳

递归编程与*数学归纳*直接相关，这是一种用于证明关于离散函数的事实的技术。通过数学归纳证明涉及整数`n`的陈述对无限多个*n*值成立涉及两个步骤。

+   *基本情况*是为了证明某些特定值或值的陈述对*n*（通常为 0 或 1）成立。

+   *归纳步骤*是证明的核心部分。例如，我们通常假设一个陈述对小于*n*的所有正整数都成立，然后利用这个事实来证明它对*n*也成立。

这样的证明足以表明该陈述对所有*n*值都成立：我们可以从基本情况开始，并使用我们的证明逐个证明该陈述对每个更大的*n*值都成立。

* * *

## 欧几里得算法

两个正整数的*最大公约数（gcd）*是能够整除它们的最大整数。例如，102 和 68 的最大公约数是 34，因为 102 和 68 都是 34 的倍数，但没有比 34 更大的整数能够整除 102 和 68。

我们可以使用以下性质高效地计算最大公约数，该性质适用于正整数`p`和`q`：

> *如果 p > q，则 p 和 q 的最大公约数与 q 和 p % q 的最大公约数相同。*

euclid.py 中的`gcd()`函数是一个紧凑的递归函数，其减少步骤基于这个性质。

```py
gcd(1440, 408)
   gcd(408, 216)
      gcd(216, 24)
         gcd(192, 24)
            gcd(24, 0)
               return 24
            return 24
         return 24
      return 24
   return 24

```

* * *

## 汉诺塔

没有讨论递归就不完整的话题是古老的*汉诺塔*问题。我们有三根柱子和*n*个适合放在柱子上的盘子。盘子的大小不同，最初排列在其中一根柱子上，从最大的盘子*n*到最小的盘子 1。任务是将盘子堆移到另一根柱子上，同时遵守以下规则：

+   每次只移动一个盘子。

+   永远不要将一个盘子放在一个较小的盘子上。

为了解决问题，我们的目标是发出一系列指令来移动盘子。我们假设柱子是排成一排的，并且每个移动盘子的指令都指定了它的编号以及是向左还是向右移动。如果一个盘子在左柱上，那么向左移动的指令意味着移到右柱；如果一个盘子在右柱上，那么向右移动的指令意味着移到左柱。

递归提供了我们需要的计划，基于以下想法：首先我们将顶部的*n*-1 个盘子移动到一个空柱子上，然后我们将最大的盘子移动到另一个空柱子上（这样它就不会干扰较小的盘子），然后我们通过将*n*-1 个盘子移动到最大的盘子上来完成工作。towersofhanoi.py 程序是该计划的直接实现。

* * *

## 指数时间

![指数增长](img/938fdb6e176f7cff0dbb9076aeb490e4.png)

有一个传说说，当一群特定的僧侣在一个寺庙里用三根金针上的 64 个金盘解决汉诺塔问题时，世界将会终结。我们可以估计到世界末日的时间（假设传说是真实的）。如果我们定义函数*T*(*n*)为`towersofhanoi.py`发出的移动*n*个盘子从一个柱子到另一个柱子的指令数量，那么递归代码意味着*T*(*n*)必须满足以下方程：

> *T*(*n*) = 2 *T*(*n* - 1) + 1 for *n* > 1, with *T*(1) = 1

这样的方程在离散数学中被称为*递归关系*。我们经常可以使用它们推导出所关心的数量的封闭形式表达式。例如，*T*(1) = 1，*T*(2) = 3，*T*(3) = 7，*T*(4) = 15。一般来说，*T*(*n*) = 2^(*n*) - 1。

知道*T*(*n*)的值，我们可以估计执行所有移动所需的时间。如果僧侣们每秒移动一个盘子，那么完成一个 20 盘子问题将需要超过一周的时间，完成一个 30 盘子问题将需要超过 31 年的时间，完成一个 40 盘��问题将需要超过 348 个世纪的时间（假设他们不犯错误）。64 盘子问题将需要超过 58 亿个世纪的时间。

* * *

## 格雷码

剧作家塞缪尔·贝克特写了一部名为*Quad*的戏剧，具有以下特点：从一个空舞台开始，角色一个接一个地进入和退出，但舞台上的每个角色子集都只出现一次。这部戏剧有四个角色，有 2⁴ = 16 种不同的四个元素子集；因此得名。贝克特是如何为这部戏剧生成舞台指示的？我们如何为 5 位演员或更多演员做到这一点？

> | ![格雷码表示](img/b0e061fba5db48825073246abc8e08c7.png) |  | ![2 位、3 位和 4 位格雷码](img/bbd92b4dd7b1530237ef0f915aa75545.png) |
> | --- | --- | --- |

一个*n*位的*格雷码*是一个包含 2^(*n*)个不同的*n*位二进制数的列表，使得列表中的每个条目与其前一个条目恰好在一位上不同。格雷码直接适用于贝克特的问题，因为我们可以将每一位解释为其位位置对应的整数是否在子集中。将一位的值从 0 改为 1 对应于一个整数进入子集；将一位的值从 1 改为 0 对应于一个整数退出子集。

我们如何生成格雷码？一个递归计划，与我们用于汉诺塔问题的计划非常相似，是有效的。*n*位二进制反射格雷码的定义如下递归地进行：

+   *n*-1 位代码，每个单词前面加 0，然后是

+   将*n*-1 位代码按相反顺序排列，每个单词前面加上 1。

0 位代码被定义为空，因此 1 位代码是 0 后跟 1。

经过一些仔细思考，递归定义导致了在 beckett.py 中实现贝克特舞台指示的实现。

* * *

## 递归图形

简单的递归绘图方案可能导致非常复杂的图片。例如，*n*阶 H 树的定义如下：当*n*=0 时，基本情况为空。减少步骤是在单位正方形内绘制三条 H 形状的线，四个*n*-1 阶 H 树，每个 H 形状的顶端连接到 H 的一个顶端，附加条件是*n*-1 阶 H 树位于正方形的四个象限的中心，尺寸减半。程序 htree.py 接受一个命令行参数`n`，并使用标准绘图绘制一个*n*阶 H 树。

| ![htree 1](img/c3ed4edf61ea3ca596d5ecf00bf3511f.png) | ![htree 2](img/1a8232d62b444aff139b3a8508dc2be6.png) | ![htree 3](img/b942420950f82948387919d9aee0eabd.png) | ![htree 4](img/3436d0cfb6f0833018f5aac682bc598f.png) | ![htree 5](img/5d6ca3619e95c5a86a988cd0b8701433.png) |
| --- | --- | --- | --- | --- |

* * *

## 布朗桥

H 树是*分形*的一个简单示例：一个几何形状，可以被分成部分，每个部分（大致上）是原始形状的缩小副本。对分形的研究在艺术表达、经济分析和科学发现中起着重要而持久的作用。艺术家和科学家使用它们来构建复杂形状的紧凑模型，这些形状在自然界中出现，并且难以用传统几何描述，如云、植物、山脉、河床、人类皮肤等。经济学家也使用分形来建模经济指标的函数图。

程序 brownian.py 生成一个函数图，近似一个称为*布朗桥*的简单示例和密切相关的函数。您可以将这个图形看作是连接两点的随机漫步，从(*x*[0]，*y*[0])到(*x*[1]，*y*[1])，由几个参数控制。该实现基于*中点位移法*，这是一个用于在区间[*x*[0]，*x*[1]]内绘制图形的递归计划。基本情况（当区间大小小于给定容差时）是��制连接两个端点的直线。减少情况是将区间分成两半，然后继续如下：

+   计算区间的中点（*x*[*m*]，*y*[*m*]）。

+   在中点的`y`坐标上加上一个从均值为 0 且给定方差的高斯分布中选择的随机值*δ*。

+   在子区间上进行递归，通过给定的缩放因子*s*来减少方差。

曲线的形状由两个参数控制：*波动性*（方差的初始值）控制图形偏离连接点的直线的距离，*赫斯特指数*控制曲线的平滑度。我们用*H*表示赫斯特指数，并在每个递归级别将方差除以 2^(2*H*)。当*H*为 1/2（每个级别除以 2）时，标准差在整个曲线上保持恒定：在这种情况下，曲线是一个布朗桥。这些图像显示了由命令`python brownian.py 1`、`python brownian.py .5`和`python brownian.py .05`生成的输出。

> | ![布朗桥](img/f68c09b7605aa0186306f5df9ad635ad.png) | ![布朗桥](img/114230a603be3f1fd0f2eb194bd18644.png) | ![布朗桥](img/715f81008644e03f7bf0f0902cac534e.png) |
> | --- | --- | --- |

* * *

## 递归的陷阱

通过递归，您可以编写简洁而优雅的程序，在运行时引起惊人的失败。

**缺少基本情况**。这个递归函数应该计算调和数，但缺少一个基本情况：

```py
def H(n):
   return H(n-1) + 1.0/n;

```

如果你调用这个函数，它将不断调用自身而永远不会返回。

**不保证收敛。** 另一个常见问题是在递归函数中包含一个递归调用来解决一个不比原问题更小的子问题。例如，如果使用任何值而不是 1 调用参数 n 来调用此递归函数，它将进入无限递归循环：

```py
def H(n):
    if n == 1:
        return 1.0
    return H(n) + 1.0/n

```

**过度空间需求。** Python 需要跟踪每个递归调用以按预期实现函数抽象。如果一个函数在返回之前递归调用自身过多次，Python 为此任务所需的空间可能是禁止的。例如，这个递归函数正确计算第 n 个调和数。然而，我们不能用它来计算大的*n*，因为递归深度与*n*成正比，这会导致`StackOverflowError`。

```py
def H(n):
    if n == 0:
        return 0.0
    return H(n-1) + 1.0/n

```

![计算斐波那契数的错误方法](img/2607a96b65fea126267c99324a64e48e.png)

**过度重复计算。** 编写一个简单的递归程序来解决问题的诱惑必须始终受到这样的理解的限制，即简单程序可能需要指数时间（不必要地），因为存在过度重复计算。例如，斐波那契数列

```py
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 ...

```

由公式*F*[*n*] = *F*[*n*-1] + *F*[*n*-2]定义，其中*n* ≥ 2，*F*[0] = 0，*F*[1] = 1。

一个初学者程序员可能会实现这个递归函数来计算斐波那契数列中的数字：

```py
def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n-1) + fib(n-2)

```

然而，这个程序效率极低！例如，考虑计算`fib(7)` = 13 的函数。它首先计算`fib(6)` = 8 和`fib(5)` = 5。为了计算`fib(6)`，它递归计算`fib(5)` = 5 和`fib(4)` = 3。事情迅速变得更糟，因为两次计算`fib(5)`时，它忽略了已经计算过`fib(4)`，依此类推。当计算`fib(n)`时，这个��序计算`fib(1)`的次数恰好是*F*[*n*]。重复计算的错误成倍增加。任何想象得到的计算机都无法执行那么多次计算。

顺便说一句，一种称为*记忆化*的系统技术允许我们避免这种陷阱，同时仍然利用计算的紧凑递归描述。在记忆化中，我们维护一个数组，以跟踪我们已经计算的值，这样我们可以返回这些值，并仅对新值进行递归调用。这种技术是*动态规划*的一种形式，这是一种组织计算的良好技术，如果你学习算法或运筹学课程，你将学到的。

* * *

#### 问与答

**问：** 有没有情况下迭代是解决问题的唯一选择？

**答：** 不，任何循环都可以用递归函数替代，尽管递归版本可能需要过多的内存。

**问：** 有没有情况下递归是解决问题的唯一选择？

**答：** 不，任何递归函数都可以用迭代方式替代。在第 4.3 节中，我们将看到编译器如何通过使用称为*栈*的数据结构为函数调用生成代码。

**问：** 我应该更喜欢递归还是迭代？

**答：** 任何导致更简单、更易理解或更高效代码的方式。

**问：** 我理解递归代码中过度空间和过度重复计算的担忧。还有其他需要关注的问题吗？

**答：** 在递归代码中极度谨慎地创建数组。使用的空间量可能会非常迅速地增加，内存管理所需的时间也会增加。

* * *

#### 练习

1.  如果你用负值的`n`运行`factorial()`会发生什么？用一个大值，比如 35 呢？

1.  编写一个递归程序，计算*ln*(*n*!)的值。

1.  给出调用`ex233(6)`时写出的整数序列：

    ```py
    def ex233(n):
        if n <= 0:
            return
        stdio.writeln(n)
        ex233(n-2)
        ex233(n-3)
        stdio.writeln(n)

    ```

1.  给出`ex234(6)`的值：

    ```py
    def ex234(n):
        if n <= 0:
            return ''
        return ex234(n-3) + str(n) + ex234(n-2) + str(n)

    ```

1.  批评以下递归函数：

    ```py
    def ex235(n):
        s = ex233(n-3) + str(n) + ex235(n-2) + str(n)
        if n <= 0:
            return ''
        return s

    ```

    *解决方案*：基本情况永远不会被触发。调用`ex235(3)`将导致调用`ex235(0)`、`ex235(-3)`、`ex235(-6)`等，直到发生"超出最大深度"的运行时错误。

1.  给定四个正整数`a`、`b`、`c`和`d`，解释`gcd(gcd(a, b), gcd(c, d))`计算的值是什么。

1.  用整数和除数的术语解释以下类似欧几里得函数的效果。

    ```py
    def gcdlike(p, q):
        if q == 0:
            return p == 1
        return gcdlike(q, p % q)

    ```

    *解决方案*。返回`p`和`q`是否互质。

1.  考虑以下递归函数：

    ```py
    def mystery(a, b):
        if b == 0:
            return 0
        if b % 2 == 0:
            return mystery(a+a, b//2)
        return mystery(a+a, b//2) + a

    ```

    `mystery(2, 25)`和`mystery(3, 11)`的值是多少？给定正整数`a`和`b`，描述`mystery(a, b)`计算的值。用`*`替换`+`，用`return 1`替换`return 0`回答相同的问题。

    *解决方案*：50 和 33。它计算`a*b`。如果你用`*`替换`+`，它计算`a^b`。

1.  编写一个递归程序`ruler.py`，使用`stddraw`绘制标尺的划分，就像第 1.2 节中的 ruler.py 程序一样。

1.  解决以下递归关系，均满足*T*(1) = 1。假设*n*是 2 的幂。

    +   *T*(*n*) = *T*(*n*/2) + 1

    +   *T*(*n*) = 2*T*(*n*/2) + 1

    +   *T*(*n*) = 2*T*(*n*/2) + *n*

    +   *T*(n) = 4*T*(*n*/2) + 3

1.  通过归纳证明，解汉诺塔谜题所需的最小移动次数满足我们递归解决方案使用的移动次数相同的递归关系。

1.  通过归纳证明，上面给出的递归程序在计算`fib(n)`时对`fib(1)`进行了恰好*F*[*n*]次递归调用。

1.  证明`gcd()`的第二个参数在每第二次递归调用时至少减少一半，然后证明`gcd(p, q)`最多使用 log[2]*n*次递归调用，其中*n*是*p*和*q*中较大的一个。

1.  修改`htree.py`���动画显示 H 树的绘制。

    > ![动画 H 树](img/39c8c4e203a2ebfdfcab9deac295cf57.png)

    接下来，重新排列递归调用的顺序（和基本情况），查看结果动画，并解释每个结果。

* * *

#### 创意练习

1.  **二进制表示。** 编写一个程序，从命令行接受一个正整数*n*（十进制），并写出它的二进制表示。回想一下，在第 1.3 节中，我们使用了减去 2 的幂的方法。相反，使用以下更简单的方法：反复将 2 除以*n*，并倒序读取余数。首先，编写一个`while`循环执行这个计算，并以错误的顺序写出位。然后，使用递归以正确的顺序写出位。

    *解决方案*：见 binaryconverter.py。

1.  **A4 纸。** [ISO 格式](http://www.cl.cam.ac.uk/~mgk25/iso-paper.html)纸张的宽高比是 2 的平方根比 1。A0 格式的面积为 1 平方米。A1 格式是将 A0 垂直切成两等份，A2 是将 A1 水平切成两等份，依此类推。编写一个程序，接受一个命令行参数*n*，并使用`stddraw`显示如何将一张 A0 纸切成 2^(*n*)份。这里有一个漂亮的[A 尺寸格式示意图](http://upload.wikimedia.org/wikipedia/commons/b/b7/A_size_illustration.png)。

1.  **排列。** 编写一个程序，接受一个命令行参数*n*，并写出从 a 开始的*n*!个排列的*n*个字母（假设`n`不大于 26）。*n*个元素的排列是元素的*n*!种可能的排序之一。例如，当*n*=3 时，你应该得到以下输出。不用担心你枚举它们的顺序。

    ```py
    bca cba cab acb bac abc

    ```

    *解决方案*：见 permutations.py。

1.  **大小为*k*的排列。** 修改你之前练习的解决方案，使其接受两个命令行参数*n*和*k*，并写出包含*n*个元素中恰好*k*个的*n*! / (*n*-*k*)!排列。当*k*=2 且*n*=4 时，以下是期望的输出。你不需要按任何特定顺序写出它们。

    ```py
    ab ac ad ba bc bd ca cb cd da db dc

    ```

*解决方案*：见 perm.py。

1.  **组合。** 编写一个程序，接受一个整数命令行参数 *n*，并写出任意大小的所有 2^(*n*) *组合*。组合是 *n* 个元素的子集，与顺序无关。例如，当 *n* = 3 时，你应该得到以下输出。

    ```py
     a ab abc ac b bc c

    ```

    注意，第一个写出的元素是空字符串（大小为 0 的子集）。

    *解决方案*: 参见 combinations.py。

1.  **大小为 `k` 的组合。** 修改你之前练习的解决方案，使其接受两个命令行参数 *n* 和 *k*，并写出所有大小为 *k* 的 *C**(n*, *k*) = *n*! / (*k*! * (*n*-*k*)!) *组合*。例如，当 *n* = 5 且 *k* = 3 时，你应该得到以下输出。

    ```py
    abc abd abe acd ace ade bcd bce bde cde

    ```

    *解决方案*: 参见 comb.py。

1.  **汉明距离。** 两个长度为 *n* 的比特串之间的汉明距离等于这两个串中不同的比特数。编写一个程序，从命令行接受一个整数 *k* 和一个比特串 *s*，并写出与 *s* 的汉明距离最多为 *k* 的所有比特串。例如，如果 *k* 为 2，*s* 为 0000，则你的程序应该写出：

    ```py
    0011 0101 0110 1001 1010 1100

    ```

    *提示*: 选择 *s* 中的 *n* 位中的 *k* 位进行翻转。

1.  **递归方块。** 编写一个程序来生成以下递归图案。方块大小的比例为 2.2:1。要绘制一个阴影方块，先绘制一个填充的灰色方块，然后是一个未填充的黑色方块。

    1.  | ![](img/84ea47fc520362efa19ee7fe093ebd72.png) | ![](img/4b5a9b292b61ca6bb9ad851f123df731.png) | ![](img/95575c922f02cb3ef1ff49e6365a3ef9.png) | ![](img/75a5acb259f4112db5e0a1cdb2636b42.png) |
    1.  | --- | --- | --- | --- |
    1.  | ![](img/7d9550b3af8284e66a563d4cb6fedb11.png) | ![](img/43519ae4e5ee974eaf460c59556276ec.png) | ![](img/9b6373f947301245661d48dfb666c3e2.png) | ![](img/a3bd5bf4e15b0f9d922d58648161224a.png) |
    1.  | ![](img/f5757b88ff729bf3e506ca924d9e86ae.png) | ![](img/4fb704e173a67519fc558b58418a8010.png) | ![](img/b7685f4ac2b3d02c87838c04e2663e62.png) | ![](img/32fec4c578cf37ccc67731cf363cd81d.png) |
    1.  | ![](img/a03dc5dedb6595f00ffc14516c3797f7.png) | ![](img/56eddbdeca4aca351d0c00dab3219c78.png) | ![](img/7c035dd9d3443560c3e1435c56e8e7fa.png) | ![](img/bfe8dbbcf5f16647fdc8c5c3face91c0.png) |

    *解决方案*: 参见 recursivesquares.py 以获取第 a 部分的解决方案。

1.  **煎饼翻转。** 你有一堆在煎锅上大小不同的 *n* 块煎饼。你的目标是重新排列这些煎饼，使最大的煎饼在底部，最小的在顶部。你只能翻转顶部的 *k* 块煎饼，从而颠倒它们的顺序。设计一个方案，通过最多 2*n* - 3 次翻转将煎饼排列成正确的顺序。

    *提示*: 你可以在这里[尝试策略](http://www.cut-the-knot.org/SimpleGames/Flipper.shtml)。

1.  **格雷码。** 修改 `beckett.py` 以写出格雷码，而不仅仅是变化的位位置序列。

    *解决方案*: 参见 graycode.py。

1.  **汉诺塔变种。** 考虑汉诺塔问题的以下变种。有 2*n* 个递增大小的圆盘存放在三根柱子上。最初，所有奇数大小的圆盘（1, 3, ..., 2*n*-1）按大小递增的顺序从顶部到底部堆叠在左柱上；所有偶数大小的圆盘（2, 4, ..., 2*n*）堆叠在右柱上。编写一个程序，为将奇数圆盘移动到右柱和偶数圆盘移动到左柱提供指令，遵守与汉诺塔相同的规则。

1.  **汉诺塔动画。** 编写一个使用 `stddraw` 的程序，以每秒大约移动一个盘子的速度动画显示解决汉诺塔问题的过程。

    *解决方案*: 参见 animatedhanoi.py。

1.  **谢尔宾斯基三角形。** 编写一个递归程序来绘制 *谢尔宾斯基地毯*。与 `htree.py` 一样，使用一个命令行参数来控制递归的深度。

    > | ![谢尔宾斯基三角形](img/2065f570826dc0c2202b64d2bb777fe7.png) | ![谢尔宾斯基三角形](img/dd0b7ae0b3555d26a04c6048ed104773.png) | ![谢尔宾斯基三角形](img/fab7963c2bc03de38f58002c92e9c06b.png) | ![谢尔宾斯基三角形](img/c4dc38fe3b42fbf14ccc7af8a8b9f59e.png) |
    > | --- | --- | --- | --- |
    > | ![谢尔宾斯基三角形](img/604e180b643069181ec0e309117846cf.png) | ![谢尔宾斯基三角形](img/e730d56b1b86f07d1c26e73cb7e4ff19.png) | ![谢尔宾斯基三角形](img/01168b3d68969b70be2be7ffca8a7fd2.png) | ![谢尔宾斯基三角形](img/fff92ac380765c8e1f22fc1f3942fc31.png) |

1.  **二项分布。**估计代码将使用的递归调用次数

    ```py
    def binomial(n, k):
        if (n == 0) or (k < 0):
            return 1.0
        return (binomial(n-1, k) + binomial(n-1, k-1)) / 2.0

    ```

    计算 `binomial(100, 50)`。开发一个基于记忆化的更好的实现。*提示*：参见第 1.4 节中的 *二项式系数* 练习。

1.  **一个奇怪的函数。**考虑麦卡锡的 91 函数：

    ```py
    def mcCarthy(n):
        if n > 100: return n - 10
        return mcCarthy(mcCarthy(n+11))

    ```

    确定在不使用计算机的情况下 `mcCarthy(50)` 的值。给出 `mcCarthy()` 用于计算此结果所使用的递归调用次数。证明对于所有正整数 *n* 都会达到基本情况，或者给出一个使该函数进入无限递归循环的 *n* 值。

1.  **Collatz 函数。**考虑以下递归函数在 collatz.py 中，它与一个著名的未解决的数论问题有关，即 [Collatz 问题](http://mathworld.wolfram.com/CollatzProblem.html) 或 *3n + 1 问题*。

    ```py
    def collatz(n):
        stdio.write(str(n) + ' ')
        if n == 1:
            return
        elif n % 2 == 0:
            collatz(n // 2)
        else:
            collatz(3*n + 1)

    ```

    例如，调用 `collatz(7)` 会写出 17 个整数的序列

    ```py
    7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1

    ```

    在 17 次函数调用之后。编写一个程序，接受一个命令行参数 *m*，并返回对于 `collatz(n)` 的递归调用次数最多的 *n* < *m* 的值。未解决的问题是没有人知道该函数是否对所有正值的 *n* 终止（数学归纳法无助，因为其中一个递归调用是针对参数值更大的情况）。开发一个基于记忆化的更好的实现。

1.  **递归树。**编写一个程序，接受一个命令行参数 *n*，并为 *n* 等于 1、2、3、4 和 8 时生成类似树状递归模式的程序：

    ![递归树](img/3a92c64d501fb8895038b1c7475b4541.png)

1.  **布朗尼亚岛。**Benoit Mandelbrot 提出了著名问题 *英国海岸有多长？* 修改 `brownian.py` 以编写一个绘制 [布朗尼亚岛](http://swiss.csail.mit.edu/~rauch/islands/) 的程序，其海岸线类似于英国的海岸线。修改很简单：首先，将 `curve()` 更改为在 *x* 坐标和 *y* 坐标上添加高斯；其次，将 `main()` 更改为从画布中心点绘制一条曲线回到自身。尝试使用各种参数值，使您的程序产生外观逼真的岛屿。

    > ![布朗尼亚岛](img/aff29185fc15188fd0ac852102138ffe.png)

    *解决方案*：参见 brownianisland.py。
