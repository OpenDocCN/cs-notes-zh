# 3.2   二叉搜索树

> 原文：[`algs4.cs.princeton.edu/32bst`](https://algs4.cs.princeton.edu/32bst)

我们研究了一种符号表实现，它将链表中的插入灵活性与有序数组中的搜索效率结合起来。具体来说，每个节点使用两个链接会导致基于二叉搜索树数据结构的高效符号表实现，这被认为是计算机科学中最基本的算法之一。

**定义.** *二叉搜索树*（BST）是一种二叉树，其中每个节点都有一个`Comparable`键（和一个相关联的值），并满足一个限制条件，即任何节点中的键都大于该节点左子树中所有节点的键，且小于该节点右子树中所有节点的键。

> | ![二叉树的解剖](img/c7a186b1ba47df404b4522dcea8d73a1.png) |                | ![二叉搜索树的解剖](img/46c3569875a35c583ddeec5eb1b56c72.png) |
> | --- | --- | --- |

## 基本实现。

程序 BST.java 使用二叉搜索树实现了有序符号表 API。我们定义一个内部私有类来定义 BST 中的节点。每个节点包含一个��、一个值、一个左��接、一个右链接和一个节点计数。左链接指向具有较小键的项目的 BST，右链接指向具有较大键的项目的 BST。实例变量`N`给出了根节点下子树中的节点计数。这个字段有助于实现各种有序符号表操作，你将看到。![在 BST 中的子树计数](img/0dd9ac1ad9d1c896a3bc99b50f43bd46.png)

+   *搜索.* 一个递归算法用于在 BST 中搜索键，直接遵循递归结构：如果树为空，则搜索未命中；如果搜索键等于根节点的键，则搜索命中。否则，我们在适当的子树中搜索（递归）。递归的`get()`方法直接实现了这个算法。它以一个节点（子树的根）作为第一个参数，以一个键作为第二个参数，从树的根和搜索键开始。![在 BST 中搜索](img/cd9a9e7be622ed5dbd12394957c314d4.png)

+   *插入.* 插入比搜索实现稍微困难一些。实际上，对于树中不存在的键的搜索会在一个空链接处结束，我们需要做的就是用包含键的新节点替换该链接。递归的`put()`方法使用了与递归搜索相似的逻辑来完成这个任务：如果树为空，我们返回一个包含键和值的新节点；如果搜索键小于根节点的键，我们将左链接设置为将键插入左子树的结果；否则，我们将右链接设置为将键插入右子树的结果。![在 BST 中插入](img/25a6c909d9984b81f5fec5a4b87d450b.png)

## 分析。

算法在二叉搜索树上的运行时间取决于树的形状，而树的形状又取决于键的插入顺序。

> | ![BST 的最佳情况](img/1a5f6b9819df8b623bb7b94861c1dd81.png) |                | ![BST 的典型情况](img/a6304eb52b2a7851d53fe976305f1970.png)                | ![BST 的最坏情况](img/f74efc1d5200ad692f7b55374163bc0f.png) |
> | --- | --- | --- | --- |

对于许多应用程序来说，使用以下简单模型是合理的：我们假设键是（均匀）随机的，或者等效地说，它们是以随机顺序插入的。

### 命题。

在由 N 个随机键构建的 BST 中，搜索命中平均需要约 2 ln N（约 1.39 lg N）次比较。

### 命题。

在由 N 个随机键构建的 BST 中，插入和搜索未命中平均需要约 2 ln N（约 1.39 lg N）次比较。

下面的可视化展示了以随机顺序向二叉搜索树中插入 255 个键的结果。它显示了键的数量（N）、从根到叶子节点的路径上节点的最大数量（max）、从根到叶子节点的路径上节点的平均数量（avg）、在完全平衡的二叉搜索树中从根到叶子节点的路径上节点的平均数量（opt）。

> <media/bst-255random.mov>
> 
> 您的浏览器不支持视频标签。

## 基于顺序的方法和删除。

二叉搜索树被广泛使用的一个重要原因是它们可以让我们保持键*有序*。因此，它们可以作为实现有序符号表 API 中众多方法的基础。

+   *最小值和最大值。* 如果根节点的左链接为空，则二叉搜索树中的最小键是根节点的键；如果左链接不为空，则二叉搜索树中的最小键是左链接引用的节点为根的子树中的最小键。查找最大键类似，向右移动而不是向左移动。

+   *下取整和上取整。* 如果给定的键 key 小于二叉搜索树根节点的键，则 key 的下取整（小于或等于 key 的二叉搜索树中的最大键）*必须*在左子树中。如果 key 大于根节点的键，则 key 的下取整*可能*在右子树中，但只有在右子树中存在小于或等于 key 的键时才可能；如果没有（或者 key 等于根节点的键），则根节点的键就是 key 的下取整。查找上取整类似，交换右子树和左子树。

+   *选择。* 假设我们寻找排名为 *k* 的键（即 BST 中恰好有 *k* 个其他键比它小）。如果左子树中的键数 *t* 大于 *k*，我们在左子树中查找排名为 `k` 的键；如果 *t* 等于 *k*，我们返回根节点的键；如果 *t* 小于 *k*，我们在右子树中查找排名为 *k - t - 1* 的键。

    > | ![二叉搜索树中的下取整](img/a98d1130955c98b6a3ea3e4f29bdc316.png) |                     | ![二叉搜索树中的选择](img/bee19829aa95cfddf9c5a08b587dae81.png) |
    > | --- | --- | --- |

+   *排名。* 如果给定的键等于根节点的键，则返回左子树中键数 *t*；如果给定的键小于根节点的键，则返回左子树中键的排名；如果给定的键大于根节点的键，则返回 *t* 加一（计算根节点的键）再加上右子树中键的排名。

+   *删除最小值和最大值。* 对于删除最小值，我们向左移动直到找到一个具有空左链接的节点，然后用其右链接替换指向该节点的链接。对于删除最大值，对称方法适用。

+   *删除。* 我们可以类似地删除任何只有一个子节点（或没有子节点）的节点，但是如何删除具有两个子节点的节点呢？我们剩下两个链接，但是父节点只有一个位置可以放置它们中的一个。1962 年 T. Hibbard 首次提出的解决这个困境的方法是通过用其*后继*替换节点 x 来删除节点 x。因为 `x` 有一个右子节点，其后继是其右子树中具有最小键的节点。替换保持了树中的顺序，因为在 `x.key` 和后继的键之间没有其他键。我们通过四个（！）简单的步骤完成了用其后继替换 x 的任务：

    +   在 `t` 中保存要删除的节点的链接

    +   将 `x` 设置为其后继 `min(t.right)`。

    +   将 `x` 的右链接（应指向包含所有大于 `x.key` 的键的二叉搜索树）设置为 `deleteMin(t.right)`，即删除后包含所有大于 `x.key` 的键的二叉搜索树的链接。

    +   将 `x` 的左链接（原本为空）设置为 `t.left`（所有小于被删除键和其后继的键）。

    > | ![删除二叉查找树中的最小值](img/f72f7068523c42ab128868a46ca63f99.png) |                     | ![二叉查找树中的 Hibbard 删除](img/05630d0dcdec39edc2477bb7a258679f.png) |
    > | --- | --- | --- |

    尽管这种方法能够完成任务，但它有一个缺点，在某些实际情况下可能会导致性能问题。问题在于使用后继者是任意的，而不是对称的。为什么不使用前任者呢？

    > *每个二叉查找树包含 150 个节点。然后我们通过 Hibbard 删除方法重复删除和随机插入键。二叉查找树向左倾斜。*
    > 
    > > <media/hibbard-150random.mov>
    > > 
    > > 您的浏览器不支持视频标签。
    > > 
    > +   *范围搜索。* 为了实现返回给定范围内键的`keys()`方法，我们从一个基本的递归二叉查找树遍历方法开始，称为*中序*遍历。为了说明这种方法，我们考虑按顺序打印二叉查找树中所有键的任务。为此，首先打印左子树中的所有键（根据二叉查找树的定义，这些键小于根键），然后打印根键，然后打印右子树中的所有键（根据二叉查找树的定义，这些键大于根键）。
    > +   
    >     ```
    >     private void print(Node x) {
    >        if (x == null) return;
    >        print(x.left);
    >        StdOut.println(x.key);
    >        print(x.right);
    >     }
    >     
    >     ```
    >     
    >     要实现带有两个参数的`keys()`方法，我们修改这段代码，将在范围内的每个键添加到一个`Queue`中，并跳过不能包含范围内键的子树的递归调用。

### 建议。

搜索、插入、查找最小值、查找最大值、floor、ceiling、rank、select、删除最小值、删除最大值、删除和范围计数操作在最坏情况下都需要时间与树的高度成比例。

#### 练习

1.  给出五种键`A X C S E R H`的排序方式，当插入到一个初始为空的二叉查找树时，产生*最佳情况*的树。

    *解决方案。* 任何首先插入 H；在 A 和 E 之前插入 C；在 R 和 X 之前插入 S 的序列。

1.  在 BST.java 中添加一个计算树高度的方法`height()`。开发两种实现：一个递归方法（需要与树高成比例的线性时间和空间），以及像`size()`那样为树中的每个节点添加一个字段的方法（需要线性空间和每次查询的常数时间）。

1.  为了测试文本中给出的`min()`、`max()`、`floor()`、`ceiling()`、`select()`、`rank()`、`deleteMin()`、`deleteMax()`和`keys()`的实现，编写一个测试客户端 TestBST.java。

1.  给出二叉查找树的`get()`、`put()`和`keys()`的非递归实现。

    *解决方案：*NonrecursiveBST.java

#### 创意问题

1.  **完美平衡。** 编写一个程序 PerfectBalance.java，将一组键插入到一个初始为空的二叉查找树中，使得生成的树等同于二叉搜索，即对于二叉查找树中任何键的搜索所做的比较序列与二叉搜索对相同键集的比较序列相同。

    *提示*：将中位数放在根节点，并递归构建左子树和右子树。

1.  **认证。** 在 BST.java 中编写一个名为`isBST()`的方法，该方法以一个`Node`作为参数，并在参数节点是二叉查找树根节点时返回`true`，否则返回`false`。

1.  **子树计数检查。** 在 BST.java 中编写一个递归方法`isSizeConsistent()`，该方法以一个`Node`作为参数，并在该节点根的数据结构中`N`字段一致时返回`true`，否则返回`false`。

1.  **选择/排名检查。** 在 BST.java 中编写一个名为`isRankConsistent()`的方法，检查对于所有`i`从`0`到`size() - 1`，是否`i`等于`rank(select(i))`，以及对于二叉查找树中的所有键，是否`key`等于`select(rank(key))`。

#### Web 练习

1.  **伟大的树-列表递归问题**。 二叉搜索树和循环双向链表在概念上都是由相同类型的节点构建的 - 一个数据字段和两个指向其他节点的引用。 给定一个二叉搜索树，重新排列引用，使其成为一个循环双向链表（按排序顺序）。 尼克·帕兰特将其描述为[有史以来设计的最整洁的递归指针问题之一](http://cslibrary.stanford.edu/109/TreeListRecursion.html)。 *提示*：从左子树创建一个循环链接列表 A，从右子树创建一个循环链接列表 B，并使根节点成为一个节点的循环链接列表。 然后合并这三个列表。

1.  **BST 重建**。 给定 BST 的前序遍历（不包括空节点），重建树。

1.  真或假。 给定 BST，设 x 是叶节点，y 是其父节点。 那么 y 的键要么是大于 x 的键中最小的键，要么是小于 x 的键中最大的键。 *答案*：真。

1.  真或假。 设 x 是 BST 节点。 可以通过沿着树向根遍历直到遇到具有非空右子树的节点（可能是 x 本身）；然后在右子树中找到最小键来找到 x 的下一个最大键（x 的后继）。

1.  **具有恒定额外内存的树遍历**。 描述如何使用恒定额外内存（例如，没有函数调用堆栈）执行中序树遍历。

    *提示*：在树下行的过程中，使子节点指向父节点（并在树上行的过程中反转它）。

1.  **反转 BST**。 给定一个标准 BST（其中每个键都大于其左子树中的键，小于其右子树中的键），设计一个线性时间算法将其转换为反转 BST（其中每个键都小于其左子树中的键，大于其右子树中的键）。 结果树形状应对称于原始形状。

1.  **BST 的层序遍历重建**。 给定一系列键，设计一个线性时间算法来确定它是否是某个 BST 的层序遍历（并构造 BST 本身）。

1.  **在 BST 中查找两个交换的键**。 给定一个 BST，其中两个节点中的两个键已被交换，找到这两个键。

    *解决方案*。 考虑 BST 的中序遍历 a[]。 有两种情况需要考虑。 假设只有一个索引 p，使得 a[p] > a[p+1]。 然后交换键 a[p]和 a[p+1]。 否则，存在两个索引 p 和 q，使得 a[p] > a[p+1]和 a[q] > a[q+1]。 假设 p < q。 然后，交换键 a[p]和 a[q+1]。
