# 1.5 输入和输出

> 原文：[`introcs.cs.princeton.edu/python/15inout`](https://introcs.cs.princeton.edu/python/15inout)

在本节中，我们扩展了我们一直在使用的简单抽象集合（命令行输入和标准输出），作为我们的 Python 程序与外部世界之间接口的一部分，包括*标准输入*、*标准绘图*和*标准音频*。标准输入使我们能够方便地组合处理任意数量的输入的程序，并与我们的程序进行交互；标准绘图使我们能够处理图形；标准音频添加了声音。

* * *

## 鸟瞰

![鸟瞰](img/dd46b13eb4b28374035e202c88fb90fa.png)

到目前为止，我们看到的 Python 程序从命令行获取输入值，并将一串字符作为输出。默认情况下，命令行输入和程序写入的输出都与在您的计算机上运行的接受命令的应用程序相关联（也就是说，您一直在其中输入 `python` 命令的应用程序）。我们使用通用术语*终端窗口*来指代该应用程序。

到目前为止，我们看到的 Python 程序已经使用了：

+   *命令行输入。* 任何 Python 程序都可以访问由 `sys.argv` 引用的字符串数组。该数组包含我们键入的命令行参数序列，由操���系统提供给 Python。按照惯例，Python 和操作系统都将参数作为字符串处理，因此如果我们打算将命令行参数作为数字处理，我们使用转换函数如 `int()` 或 `float()` 将其从字符串转换为适当的类型。

+   *标准输出。* 为了写入输出值，我们一直在使用函数 `stdio.write()` 和 `stdio.writeln()`。当程序调用这些函数时，Python 将结果以一种称为*标准输出*的抽象字符流的形式放置。默认情况下，操作系统将标准输出连接到终端窗口。到目前为止，我们程序中的所有输出都出现在终端窗口中。

程序 randomseq.py 使用了这个模型。它接受一个整数命令行参数 `n`，并向标准输出写入一个介于 0 和 1 之间的 `n` 个随机数序列，可能包括 0。

为了完成我们的编程模型，我们添加以下内容：

+   *标准输入。* 书站 `stdio.py` 模块定义了除了 `write()` 和 `writeln()` 之外的几个函数。这些额外的函数实现了一个标准输入抽象，以补充标准输出抽象。也就是说，`stdio` 模块包含了允许你的程序从标准输入中*读取*的函数。就像一个程序可以随时写入标准输出一样，一个程序也可以随时从标准输入中读取。

+   *标准绘图。* 书站 `stddraw` 模块允许你的程序创建和绘制图形。它实现了一个简单的图形模型，允许你的程序在计算机窗口中创建和绘制点、线条和几何形状。`stddraw` 还实现了动画功能。

+   *标准音频。* 书站 `stdaudio` 模块允许你的程序创建和播放声音。它使用标准格式将浮点数组转换为声音。

* * *

## 标准输出

这是与标准输出相关的 `stdio.py` 模块部分的 API：

> ![与标准输出相关的书站功能的 API](img/4d3cc1fd9d6b3d4a79a15ca6b7bcb80b.png)

`stdio.writeln()` 和 `stdio.write()` 函数是你一直在使用的。`stdio.writef()` 函数让你对输出的外观有更多控制，并值得一些解释。

### 格式化写入基础知识。

`stdio.writef()` 的最简单的调用只传递一个参数；该参数应为字符串。在这种情况下，`stdio.writef()` 简单地将字符串写入标准输出，因此等同于 `stdio.write()`。`stdio.writef()` 的更常见的调用传递两个参数。在这种情况下，第一个参数称为*格式字符串*。它包含一个*转换说明*，描述了第二个参数如何转换为输出的字符串。转换说明的形式为 `%w.pc`，其中：

![格式化写语句的解剖](img/55ee8ae35a4c1bdab5424e78e67fe836.png)

+   `w` 是*字段宽度*。字段宽度是应该写入的字符数。负的字段宽度表示输出应在右侧填充空格。

+   `p` 是*精度*。对于浮点数，精度是小数点后应写入的数字位数。对于字符串，精度是应写入的字符串的字符数。

+   `c` 是*转换代码*。当写入整数时，转换代码应为 `d`，当写入浮点数时，应为 `f` 或 `e`，当写入字符串时，应为 `s`。

> ![Writef 格式约定](img/e3a6862062f278cd1a856a2dbb47c9c9.png)

`stdio.writef()` 函数可以接受多于两个参数。在这种情况下，格式字符串将为每个参数都有一个格式说明符，可能由其他字符分隔以传递到输出。

格式字符串中任何不是转换说明的部分都会简单地传递到输出。例如，语句

```
stdio.writef('pi is approximately %.2f\n', math.pi)

```

写入行

```
pi is approximately 3.14

```

### 多个参数。

`stdio.writef()` 函数可以接受多于两个参数。在这种情况下，格式字符串将为每个参数都有一个转换说明，可能由其他字符分隔以传递到输出。

### 格式化写入的实现。

`stdio.writef()` 函数内部使用了 `%` 运算符。具体来说，形如 `stdio.writef(*formatString*, *value*)` 的函数调用在内部使用了形如 `*formatString* % *value*` 的表达式。

正如你所知，表达式 `*integer* % *integer*` 中的 `%` 运算符表示“计算余数”。表达式 `*formatString* % *value*` 中的 `%` 运算符表示根据 `*formatString*` 的指示将 `*value*` 转换为字符串。[Python 字符串格式化操作的文档](http://docs.python.org/library/stdtypes.html#string-formatting)详细描述了 `%` 运算符。因此，间接地，它也详细描述了 `stdio.writef()` 函数。

* * *

## 标准输入

我们的 `stdio.py` 模块支持标准输入，这是一个可能为空或包含一系列由空格分隔的值的抽象数据流。每个值都是一个字符串或 Python 的原始类型之一。标准输入流的一个关键特点是，当程序读取值时，程序会*消耗*这些值。一旦程序读取了一个值，它就不能回退并再次读取。这是与标准输入相关的 `stdio` 模块的一部分：

> ![与标准输入相关的 booksite 函数的 API](img/f2bceb0ae2f3601dbc989095dedf2117.png)

这些函数分为三类：逐个读取单个标记并将每个标记转换为整数、浮点数、布尔值或字符串的函数；逐行从标准输入读取行的函数；以及读取相同类型值序列的函数（将值返回为数组）。通常最好不要在同一个程序中混合来自不同类别的函数。

现在我们考虑一些示例程序，演示如何使用标准输入。

![命令的解剖](img/bd03485a2948affc7ed29326a1e79038.png)

### 输入输入。

程序 addints.py 接受一个命令行参数 `n`。然后它从标准输入读取 `n` 个数字，计算它们的总和，并将总和写入标准输出。

当您使用`python`命令从命令行运行 Python 程序时，实际上您正在做三件事：（i）发出命令开始执行您的程序，（ii）指定命令行参数的值，以及（iii）开始定义标准输入流。在命令行之后在终端窗口中键入的字符序列是标准输入流。当您输入字符时，您正在与您的程序交互。程序*等待*您创建标准输入流。

当您输入`python addints.py`时，在接受命令行参数后，程序调用`stdio.readInt()`并等待您输入一个整数。假设您希望`144`是第一个输入���当您输入`1`，然后`4`，然后`4`时，什么也不会发生，因为`stdio`不知道您何时完成输入整数，但当您输入`<return>`表示您的整数结束时，`stdio.readInt()`立即返回值 144。在这种方式输入四个数字后，程序不再期望更多输入，并将总和写入标准输出，如所需。

如果在`stdio.readInt()`期望整数时输入`abc`、`12.2`或`True`，那么它将返回`ValueError`。每种类型的格式与您在 Python 程序中使用的文字值的格式相同。`stdio`将连续的空白字符字符串视为一个空格，并允许您用这些字符串来分隔数字。无论您在数字之间放置多少空格，无论您是在一行上输入数字还是用制表符分隔它们或者将它们分散在几行上（除了您的终端应用程序一次处理标准输入一行，因此它将等到您输入`<return>`后才将该行上的所有数字发送到标准输入）。您可以在输入流中混合不同类型的值，但每次程序期望特定类型的值时，输入流中都需要有该类型的值。

### 交互式用户输入。

程序 twentyquestions.py 玩一个简单的猜谜游戏。您输入数字，每个数字都是一个隐式问题（*这是数字吗？*），程序会告诉您您的猜测是太高还是太低。

该程序说明了交互式用户输入。也就是说，它说明了程序可以交替写入标准输出和从标准输入读取，从而在程序执行期间与用户交互。

### 处理任意大小的输入流

程序 average.py 从标准输入读取一系列浮点数，并将它们的平均值写入标准输出。

通常，输入流是有限的：您的程序遍历输入流，消耗值直到流为空。但是输入流的大小没有限制。该程序说明了使用输入流的一个关键特性：程序不知道流的长度。我们输入所有的数字，然后程序对它们求平均值。在读取每个数字之前，程序调用`stdio.isEmpty()`来检查标准输入中是否还有更多数字。

当我们没有更多数据可输入时，如何发出信号？按照惯例，我们输入一系列特殊字符，称为*文件结尾序列*。在 OS X 和 Linux 上是`<ctrl-d>`，在 Windows 上是`<ctrl-z>`。在某些系统上，文件结尾序列必须单独出现在一行上。输入文件结尾序列表示标准输入为空。

* * *

## 重定向和管道

对于许多应用程序来说，从终端窗口将输入数据作为标准输入流输入是不可行的，因为这样做会限制我们程序的处理能力，限制了我们可以输入的数据量。同样，我们经常希望保存标准输出流上打印的信息以供以后使用。我们可以使用操作系统机制来解决这两个问题。

### 将标准输出重定向到文件。

通过向调用程序的命令添加一个简单的指令，我们可以*重定向*其标准输出到文件，以便永久存储或在以后的某个时间输入到其他程序中。例如，命令：

> ![将标准输出管道到文件](img/f81ee3a0c1f7cb00a518882b6eb2129f.png)

指定了标准输出流不写入终端窗口，而是写入名为`data.txt`的文本文件。每次调用`stdio.write()`或`stdio.writeln()`都会将文本追加到该文件的末尾。在这个例子中，最终结果是一个包含 1,000 个随机值的文件。终端窗口中不会显示任何输出：它直接进入以`>`符号命名的文件中。因此，我们可以保存信息以供以后检索。

### 从文件重定向标准输入。

同样地，我们可以重定向标准输入，使程序从文件而不是终端应用程序读取数据。例如，命令：

> ![从文件重定向到标准输入](img/74a02d6b2dadb77d21cf7da32b14f8de.png)

从文件`data.txt`读取一系列数字，计算它们的平均值，并将平均值写入标准输出。具体来说，`<`符号是一个指令，通过从文件`data.txt`而不是等待用户在终端窗口中键入来实现标准输入流。当程序调用`stdio.readFloat()`时，操作系统从文件中读取值。这种从文件重定向标准输入的功能使我们能够处理来自任何来源的大量数据，仅受我们可以存储的文件大小限制。

### 连接两个程序。

实现标准输入和标准输出抽象的最灵活方式是指定它们由我们自己的程序实现！这种机制称为*piping*。例如，以下命令：

> ![将一个程序的输出管道到另一个程序的输入](img/f7463e2a5da03bcb35a2c2953764a00a.png)

指定了随机序列.py 的标准输出流和平均值.py 的标准输入流是*相同*的流。也就是说，结果与以下命令序列具有相同效果：

> ```
> % python randomseq.py 1000 > data.txt
> % python average.py < data.txt
> 
> ```

但文件`data.txt`是不需要的。

### 过滤器。

对于许多常见任务，将每个程序视为以某种方式将标准输入流转换为标准输出流的过滤器，并使用管道作为连接程序的命令机制是方便的。例如，范围过滤器.py 接受两个命令行参数，并将标准输入中落在指定范围内的数字写入标准输出。

一些为 Unix 设计的标准过滤器仍然存在（有时使用不同的名称）作为现代操作系统中的命令。例如，`sort`过滤器从标准输入读取行并按排序顺序写入标准输出：

```
% python randomseq.py 9 | sort
0.0472650078535
0.0681950168757
0.0967410236589
0.0974385525393
0.118855769243
0.46604926859
0.522853708616
0.599692836211
0.685576779833

```

另一个有用的过滤器是`more`，它从标准输入读取数据，并在您的终端窗口中一次显示一个屏幕。例如，如果您键入

```
% python randomseq.py 1000 | more

```

您将在终端窗口中看到尽可能多的数字，但更多的数字将等待您按空格键，然后显示每个后续屏幕。

* * *

## 标准绘图

现在我们介绍一个用于生成绘图输出的抽象。我们想象一个抽象的绘图设备，能够在二维“画布”上绘制线条和点，然后在标准绘图窗口中显示该画布在您的屏幕上。该设备能够响应我们程序发出的命令，形式为对`stddraw`模块中函数的调用。该模块的 API 由两种函数组成：绘图函数会导致设备执行动作（如绘制线条或绘制点），控制函数控制绘图的显示方式并设置参数，如笔的大小或坐标比例。

### 创建绘图。

绘图的基本函数在此 API 中描述：

> ![Stddraw 绘图函数](img/be5a9d719c6cd328aed3a7d9cacd0406.png)

绘图函数几乎是自解释的：`stddraw.line()` 以给定参数作为坐标绘制连接两点的直线段，`stddraw.point()` 在给定坐标处绘制一个以该坐标为中心的点。默认坐标比例是单位正方形（所有坐标在 0 到 1 之间）。点 (0.0, 0.0) 在左下角，点 (1.0, 1.0) 在右上角 — 因此对应于熟悉的笛卡尔坐标系的第一象限。默认设置在白色背景上绘制黑色线条和黑色点。

控制函数 `stddraw.show()` 需要更多解释。当您的程序调用任何绘图函数，如 `stddraw.line()` 或 `stddraw.point()` 时，`stddraw` 使用一种称为*背景画布*的抽象。背景画布不会显示；它只存在于计算机内存中。所有点、线条等都是在背景画布上绘制的，而不是直接在标准绘图窗口中。只有当您调用 `stddraw.show()` 时，您的绘图才会从背景画布复制到标准绘图窗口中，在那里显示，直到用户关闭标准绘图窗口 — 通常通过单击窗口标题栏中的 *关闭* 按钮。

为什么 `stddraw` 需要使用背景画布？主要原因是使用两个画布而不是一个使 `stddraw` 模块更有效率。在许多计算机系统上，逐步显示正在创建的复杂图形可能效率低下。在计算机图形中，这种技术称为*双缓冲*。

要总结您需要了解的信息，使用 stddraw 模块的典型程序具有以下结构：

+   导入 `stddraw` 模块。

+   调用诸如 `stddraw.line()` 和 `stddraw.point()` 等绘图函数在背景画布上创建绘图。

+   调用 `stddraw.show()` 来显示标准绘图窗口中的背景画布，并等待窗口关闭。

### 你的第一个绘图。

使用 `stddraw` 进行图形编程的“Hello, World”等价物是绘制一个带有内部点的三角形。为了形成三角形，我们绘制三条线。程序 triangle.py 是完整的程序。

### 保存绘图。

您可以将标准绘图窗口画布保存到文件中。要这样做，请在窗口画布的任何位置右键单击。这样做后，`stddraw` 将显示一个文件对话框，允许您指定文件名。然后，在对话框中输入文件名并单击 *保存* 按钮后，`stddraw` 将窗口画布保存到指定名称的文件中。文件名必须以 `.jpg` 结尾（以 JPEG 格式保存窗口画布）或 `.png` 结尾（以“便携式网络图形”格式保存窗口画布）。本章中显示的图形程序生成的图形是使用此机制保存到文件中的。

### 控制命令。

标准绘图的默认坐标系是单位正方形，但我们经常希望以不同比例绘制图形。此外，我们经常希望绘制不同粗细的线条和不同大小的点。为了满足这些需求，stddraw 提供了以下函数：

> ![Stddraw 控制函数](img/e5e583116f3a4614dd9b0fd91344160b.png)

例如，当您调用函数 `stddraw.setXscale(0, n)` 时，您告诉绘图设备您将使用 0 到 `n` 之间的 x 坐标。请注意，两次调用序列

```
stddraw.setXscale(x0, x1)
stddraw.setYscale(y0, y1)

```

将绘图坐标设置为一个边界框，其左下角在 (`x0`, `y0`) 处，右上角在 (`x1`, `y1`) 处。

### 将数据过滤到标准绘图。

程序 plotfilter.py 读取由(*x*, *y*)坐标定义的一系列点，并在每个点处绘制一个点。它采用的约定是从标准输入读取的前四个数字指定了边界框，以便它可以缩放绘图。尝试将其标准输入重定向到 usa.txt 运行。

> ![绘图滤镜](img/caafbb4c33928ae3857b4b8320ac0ac2.png)

### 绘制函数图。

程序 functiongraph.py 在区间(0, π)中绘制函数*y* = sin(4*x*) + sin(20*x*)。在区间中有无限多个点，所以我们必须通过在区间内的有限数量的点评估函数来处理。我们通过选择一组*x*值来对函数进行采样，然后通过在每个*x*值处评估函数来计算*y*值。通过连接连续点以线条绘制函数产生了所谓的*分段线性逼近*。

> ![函数图](img/dd040dd9c16597b9b779dbf8a70f3e7c.png)

### 轮廓和填充形状。

`stddraw`模块还包括用于绘制圆、矩形和任意多边形的函数。每个形状定义一个轮廓。当函数名只是形状名时，轮廓由绘图笔描绘。当名称以`filled`开头时，命名的形状实际上是填充的实心形状，而不是描绘的。通常情况下，我们在 API 中总结可用的函数：

> ![Stddraw 形状函数](img/be276ec307cada3f34b601e536cffd55.png)

`stddraw.circle()`的参数定义了以(`x`, `y`)为中心的半径为`r`的圆；`stddraw.square()`的参数定义了以(`x`, `y`)为中心的边长为 2`r`的正方形；`stddraw.polygon()`的参数定义了我们通过线连接的一系列点，包括从最后一个点到第一个点的线。 

### 文本和颜色。

为了注释或突出显示绘图中的各种元素，`stddraw`包括用于绘制文本、设置字体和设置笔墨水的方法。

> ![Stddraw 文本和颜色函数](img/c545ee1ca12c634b0995ddaccf4c392f.png)

在这段代码中，颜色和字体使用的类型将在第 3.1 节中学习。在那之前，我们将细节留给`stddraw`。可用的笔颜色是`BLACK`、`BLUE`、`CYAN`、`DARK_GRAY`、`GRAY`、`GREEN`、`LIGHT_GRAY`、`MAGENTA`、`ORANGE`、`PINK`、`RED`、`WHITE`和`YELLOW`，这些都是在`stddraw`中定义的常量。例如，调用`stddraw.setPenColor(stddraw.GRAY)`会更改为灰色墨水。默认墨水颜色是黑色；默认字体是 12 点普通 Helvetica 字体。

这些代码片段展示了一些用于绘制形状和文本的 stddraw 函数：

> ![Stddraw 示例](img/333b2b1ca409cb9834444047a33e2e93.png)

### 动画

如果我们为`stddraw.show()`提供参数，则该调用不需要是程序的最后一个动作：它将将背景画布复制到标准绘图窗口，然后等待指定的毫秒数。很快你会看到，我们可以利用这种能力（结合擦除或清除背景画布的能力）在`stddraw`窗口中产生运动效果。

> ![Stddraw 动画函数](img/3ee86ef42aaba67179cd0e380b5338ef.png)

动画的“Hello, World”程序是在画布上产生一个黑色球，看起来在画布上移动。假设球在位置(*r[x]*，*r[y]*)，我们想要给人一种将其移动到附近新位置的印象，例如，例如，(*r[x]* + 0.01, *r[y]* + 0.02)。我们分三步进行：

+   清除背景画布。

+   在新位置绘制一个黑色球。

+   显示绘图并等待片刻。

为了营造运动的错觉，我们对一整个位置序列（在这种情况下将形成一条直线）进行迭代这些步骤。`stddraw.show()`的参数量化了“短暂的时间”，控制了视觉速度。

程序 bouncingball.py 实现了这些步骤，以创建一个球在以原点为中心的 2x2 盒子中移动的幻觉。球的当前位置是(*r[x]* , *r[y]*)，我们通过在每一步中将*v[x]*加到*r[x]*和*v[y]*加到*r[y]*来计算新位置。由于(*v[x]* , *v[y]*)是球在每个时间单位移动的固定距离，它代表速度。为了保持球在绘图中，我们模拟球按照弹性碰撞定律弹跳到墙壁的效果。这个效果很容易实现：当球撞到垂直墙壁时，我们只需将*x*方向上的速度从*v[x]*改变为-*v[x]*，当球撞到水平墙壁时，我们将*y*方向上的速度从*v[y]*改变为-*v[y]*。下面的图像显示了球的轨迹，这些图像是由这段代码的修改版本生成的（请参见本节末尾的一个练习）。

> ![弹跳球](img/c550daeebfaec00d6fc0fb9079a558c9.png)

* * *

## 标准音频

stdaudio 模块可以播放、操作和合成声音。它允许你播放`.wav`文件，编写程序来创建和操作浮点数组，并将它们读取和写入为.wav 文件：

> ![Stdaudio 模块](img/2bfde5c07d2c0a04334d0973cd8e096c.png)

我们首先介绍计算机科学和科学计算中最古老和最重要领域之一的一些基本概念，这个领域被称为*数字信号处理*。

### 协奏 A。

声音是分子振动的感知，特别是我们耳膜的振动。因此，振荡是理解声音的关键。也许最简单的起点是考虑中央 C 上方的音符 A，也称为*协奏 A*。这个音符只不过是一个正弦波，按照每秒振荡 440 次的频率进行缩放。函数 sin(*t*)每 2π单位重复一次，因此如果我们以秒为单位测量*t*并绘制函数 sin(2π*t* × 440)，我们得到一个每秒振荡 440 次的曲线。我们用[hertz](https://en.wikipedia.org/wiki/Hertz)（每秒循环次数）来衡量频率。当你将频率加倍或减半时，你在音阶上向上或向下移动一个八度。例如，880 赫兹是协奏 A 的一个八度，110 赫兹是协奏 A 的两个八度下方。作为参考，人类听觉的频率范围约为 20 至 20,000 赫兹。声音的振幅（*y*-值）对应于音量。我们假设它被缩放在-1 到+1 之间。

### 其他注意事项。

一个简单的数学公式描述了半音音阶上的其他音符。半音音阶上有 12 个音符，均匀分布在对数（以 2 为底）刻度上。我们通过将给定音符的频率乘以 2 的(*i*/12)次方来得到半音音阶上的第*i*个音符。换句话说，半音音阶上每个音符的频率恰好是音阶上前一个音符的频率乘以 2 的十二次方根（约为 1.06）。这些信息足以创作音乐！例如，要演奏曲调*Frere Jacques*，我们只需要通过产生适当频率的正弦波来演奏 A B C# A 的每个音符约半秒钟，然后重复这个模式。

> ![钢琴](img/0253880a42ad78551d58e4e5abeebb4b.png)

### 采样。

![采样正弦波](img/56ad6ea035a54e2c749c1374ca7f2df0.png)对于数字音频，我们通过在规则间隔上对其进行采样来表示曲线，这与绘制函数图形时的方式完全相同。我们采样得足够频繁，以便准确表示曲线 — 数字音频的常用采样率为每秒 44,100 个样本。对于升降调 A，该速率对应于在大约 100 个点上对正弦波的每个周期进行采样。由于我们定期采样，我们只需要计算采样点的 *y* 坐标。就是这么简单：我们将声音表示为一组数字（浮点值，介于 -1 和 +1 之间）。我们的 booksite 声音模块函数`stdaudio.playSamples()`以浮点数组作为其参数，并在您的计算机上播放由该数组表示的声音。

例如，假设你想要播放升降调 A 音符 10 秒钟。以每秒 44,100 个样本的速度，你需要一个包含 441,001 个浮点值的数组。为了填充数组，使用一个`for`循环，在其中对函数 sin(2π*t* × 440)在 *t* = 0/44100, 1/44100, 2/44100, 3/44100, ..., 441000 / 44100 进行采样。一旦我们用这些值填充了数组，我们就可以准备好使用`stdaudio.playSamples()`，就像下面的代码一样：

```
import math
import stdaudio
import stdarray
SPS = 44100                   # samples per second
hz = 440.0                    # concert A
duration = 10.0               # ten seconds
n = int(SPS * duration)
a = stdarray.create1D(n+1)
for i in range(n+1):
    a[i] = math.sin(2.0 * math.pi * i * hz / SPS)
stdaudio.playSamples(a)
stdaudio.wait()

```

这段代码是数字音频的“Hello, World”。一旦你用它让你的计算机播放这个音符，你就可以编写代码来播放其他音符并制作音乐！

### 保存到文件。

音乐可能会占用计算机上的大量空间。以每秒 44,100 个样本的速度，一首四分钟的歌曲对应于 4 × 60 × 44100 = 10,584,000 个数字。因此，通常会使用比我们用于标准输入和输出的数字串表示法占用更少空间的二进制格式来表示与歌曲对应的数字。近年来已经开发了许多这样的格式 — `stdaudio`使用`.wav`格式。

### 播放音乐。

程序 playthattune.py 是一个示例，展示了我们如何使用`stdaudio`轻松创建音乐。它从标准输入中获取音符，以升降调音阶为索引，并在标准音频上播放它们。尝试将其标准输入重定向到以下这些数据文件中的每一个（由不同学生创建）来重复运行它：elise.txt, ascale.txt, stairwaytoheaven.txt, entertainer.txt, firstcut.txt, freebird.txt, 和 looney.txt。

* * *

#### Q & A

**Q.** 如何使 Python 中的 booksite 模块 stdio、stddraw 和 stdaudio 可用？

**A.** 如果你按照这个 booksite 上的逐步说明安装 Python，这些模块应该已经可以在 Python 中使用了。

**Q.** 是否有用于处理标准输出的标准 Python 模块？

**A.** 实际上，这些功能已经内置在 Python 中。在 Python 2 中，你可以使用`print`语句将数据写入标准输出。在 Python 3 中，没有`print`语句；取而代之的是类似的`print()`函数。

**Q.** 那么，为什么我们在写入标准输出时使用 booksite 的 stdio 模块，而不是使用 Python 已经提供的功能呢？

**A.** 我们的意图是编写尽可能与所有 Python 版本兼容的代码。例如，在所有我们的程序中使用`print`语句将意味着它们将与 Python 2 兼容，但与 Python 3 不兼容。由于我们使用`stdio`函数，我们只需要确保我们有正确的库。

**Q.** 关于标准输入呢？

**A.** 在 Python 2 和 Python 3 中有与`stdio.readLine()`对应的功能，但没有与`stdio.readInt()`和类似函数对应的功能。再次强调，通过使用`stdio`，我们可以编写不仅利用这些额外功能的���序，而且在 Python 的所有版本中都能正常工作。

**Q.** 关于绘图和声音呢？

**A.** Python 没有附带`audio`库。Python 附带一个名为`Tkinter`的图形库用于生成绘图，但对于本书中的一些图形应用来说速度太慢了。我们的`stddraw`和`stdaudio`模块提供了易于使用的 API，基于`Pygame`库。

**Q.** 所以，让我弄清楚一点；如果我使用格式`%2.4f`与`stdio.writef()`一起写一个浮点数，我得到小数点前两位和小数点后四位数字，对吗？

**A.** 不，这只指定小数点后的四位数字。小数点前面的数字是整个字段的宽度。你需要使用格式`%7.2f`来指定总共七个字符 — 小数点前四位，小数点本身，以及小数点后两位数字。

**Q.** `stdio.writef()`还有哪些其他转换代码？

**A.** 对于整数值，有`o`表示八进制，`x`表示十六进制；对于浮点数，你可以使用`e`或`g`来获得科学计数法。还有许多日期和时间的格式。[Python 字符串格式化操作的文档](http://docs.python.org/library/stdtypes.html#string-formatting)提供了丰富的信息。

**Q.** 我的程序可以从标准输入重新读取数据吗？

**A.** 不。你只有一次机会，就像你不能撤消`stdio.writeln()`的调用一样。

**Q.** 如果我的程序在耗尽后尝试从标准输入读取数据会发生什么？

**A.** Python 会在运行时引发`EOFError`。函数`stdio.isEmpty()`和`stdio.hasNextLine()`允许你通过检查是否还有更多输入来避免这样的错误。

**Q.** 为什么`stddraw.square(x, y, r)`画出的正方形宽度是 2`r` 而不是`r`？

**A.** 这使得它与函数`stddraw.circle(x, y, r)`保持一致，其中第三个参数是圆的半径，而不是直径。在这个上下文中，`r`是可以容纳在正方形内的最大圆的半径。

**Q.** 如果我的程序调用`stddraw.show(0)`会发生什么？

**A.** 这个函数调用告诉 stddraw 将背景画布复制到标准绘图窗口，然后等待 0 毫秒（也就是根本不等待）才继续。如果，例如，你想以计算机支持的最快速度运行动画，这个函数调用是合适的。

**Q.** 我可以用`stddraw`画除了圆以外的曲线吗？

**A.** 我们不得不在某个地方划定界限（双关语），所以我们只支持文本中讨论的基本形状。你可以一次一个点地绘制其他形状，就像文本中的几个练习中探讨的那样，但不直接支持填充它们。

**Q.** 那么在为 playthattune.py 制作输入文件时，我使用负整数来低于 A 音调吗？

**A.** 是的。实际上，我们选择将 A 音调放在 0 的位置是任意的。一种流行的标准，称为*MIDI 调音标准*，从 A 音调下方五个八度的 C 开始编号。按照这个约定，A 音调是 69，你不需要使用负数。

**Q.** 当我尝试用频率为 30,000 赫兹（或更高）的正弦波进行声音化时，为什么我从标准音频听到奇怪的结果？

**A.** *奈奎斯特频率*，定义为采样频率的一半，代表可以重现的最高频率。对于标准音频，采样频率为 44,100，因此奈奎斯特频率为 22,050。

**Q.** 如果我正在从文件重定向标准输入，我如何输入文件结束序列？

**A.** 当标准输入绑定到你的终端应用程序时，最终你必须输入文件结束序列来通知程序标准输入没有更多数据可读取了。然而，当标准输入绑定到文件时，你不需要输入文件结束序列。相反，操作系统会在没有更多数据可从文件中读取时自动通知你的程序。

**Q.** `stdio.writef()`还有哪些其他转换代码？

**Q.** 如何在`stdio.writef()`中打印`%`字符？

**A.** 使用`%%`。

**Q.** 什么是表示一行结束的符号？

**A.** 不同的操作系统使用不同的符号。在 Unix 系统和 Mac OS X 上，换行符是`'\n'`。在 Windows 上，每行由两个字符的字符串`'\r\n'`终止。在 OS X 之前的 Mac 上，每行由字符串`'\n\r'`终止。在编写程序时，应避免使用特定于操作系统的功能，否则可能在其他系统上无法正常工作。使用`stdio.writeln()`来写入换行符。

**Q.** 如何为`stddraw`模块创建颜色？

**A.** stddraw 模块使用了一个我们专门为本书站点定义的名为`Color`的类。本站点的第三章描述了该类。

**Q.** PNG、JPEG 和 PostScript 图形格式的主要区别是什么？

**A.** 大多数网页上的图形都是以 PNG、GIF 或 JPEG 格式呈现的。这三种格式都是*基于栅格*的 —— 它们存储了表示图片所需的像素集和颜色渐变。PNG 和 GIF 适合显示带有直线和几何图形的图形，而 JPEG 最适合于照片。PostScript 是一种*基于矢量*的格式。例如，它将圆表示为几何对象，而不是成千上万个像素的集合。如果你放大或缩小它，质量不会降低。因此，大多数打印机使用 PostScript 来打印文档和图形。

**Q.** 错误消息`NameError: name 'stdio' is not defined`是什么意思？

**A.** 你可能忘记安装本站点模块了。当然，`stdarray.py`、`stddraw.py`和`stdaudio.py`也是一样。

**Q.** 如何创建一个动画 GIF？

* * *

#### 练习

1.  编写一个程序，从标准输入读取整数（用户输入的数量不定），并将最大值和最小值写入标准输出。

    *解决方案*: 请参阅 maxmin.py。

1.  修改上一个练习中的程序，要求整数必须是正数（提示用户输入正整数，如果输入的值不是正数）。

1.  编写一个程序，从命令行接受一个整数*n*，从标准输入读取*n*个���点数，并写出它们的平均值和标准差（平均值的平方根，除以*n*的差值平方和）。

    *解决方案*: 请参阅 stats2.py。

1.  扩展上一个练习中的程序，创建一个过滤器，写出所有偏离平均值 1.5 个标准差以上的值。

1.  编写一个程序，读取一系列整数，并写出出现在最长连续序列中的整数以及序列的长度。例如，如果输入是`1 2 2 1 5 1 1 7 7 7 7 1 1`，则你的程序应该写出`最长序列：4 个连续的 7`。

    *解决方案*: 请参阅 longestrun.py。

1.  编写一个过滤器，读取一系列整数，并写出这些整数，去除连续出现的重复值。例如，如果输入是`1 2 2 1 5 1 1 7 7 7 7 1 1 1 1 1 1 1 1 1`，你的程序应该写出`1 2 1 5 1 7 1`。

1.  编写一个程序，接受一个命令行参数`n`，从标准输入读取介于 1 和`n`之间的`n-1`个不同整数，并确定缺失的值。

1.  编写一个程序，从标准输入读取正实数，并写出它们的几何平均数和调和平均数。*n*个正数*x*[1]、*x*[2]、...、*x*[*n*]的*几何平均数*是(*x*[1] × *x*[2] × ... × *x*[*n*])^(1/*n*)。*调和平均数*是*n* / (1/*x*[1] + 1/*x*[2] + ... + 1/*x*[*n*])。*提示*：对于几何平均数，考虑取对数以避免溢出。

1.  假设文件`input.txt`包含两个字符串 F 和 F。以下命令做什么？更多关于龙曲线的信息，请参见第 1.2 节的练习。这是 Python 程序 dragon3.py。

    ```
    python dragon3.py < input.txt | python dragon3.py | python dragon3.py

    ```

1.  编写一个名为`tenperline.py`的过滤器，该过滤器读取介于 0 和 99 之间的整数序列，并每行写入 10 个整数，列对齐。然后编写一个名为`randomintseq.py`的程序，该程序接受两个命令行参数`m`和`n`，并写入 0 到`m`-1 之间的`n`个随机整数。使用命令`python randomintseq 100 200 | python tenperline.py`测试您的程序。

1.  编写一个名为`wordcount.py`的程序，从标准输入读取文本，并将文本中的单词数写入标准输出。对于本练习，单词是由空格包围的一系列非空白字符。例如，命令`python wordcount < tale.txt`应该写入 139043。

    *解决方案*：参见 wordcount.py。

1.  编写一个程序，从标准输入读取每行包含一个名称和两个整数的行，然后调用`stdio.writef()`将表格写入标准输出，其中包含名称的列、整数和将第一个整数除以第二个整数的结果，精确到三位小数。您可以使用这样的程序制表棒球运动员的击球率或学生的成绩。

1.  以下哪些*需要*保存所有来自标准输入的值（例如保存在数组中），哪些可以仅使用固定数量的变量实现为过滤器？对于每个输入，来自标准输入的是 0 到 1 之间的*n*个浮点数。

    +   写出最大和最小的数字。

    +   写出第*k*小的值。

    +   写出数字的平方和。

    +   写出数字的平均值。

    +   写出大于平均值的数字的百分比。

    +   按升序写出数字。

    +   按随机顺序写出数字。

1.  编写一个程序，为贷款编写一个每月付款、剩余本金和支付利息的表格，接受三个数字作为命令行参数：贷款年限、本金和利率。（请参见第 1.2 节中的相关练习。）

1.  编写一个程序，接受三个命令行参数*x*、*y*和*z*，从标准输入读取一系列点坐标(*x[i]*, *y[i]*, *z[i]*)，并写出距离(*x*, *y*, *z*)最近的点的坐标。请记住，(*x* , *y* , *z*)和(*x[i]* , *y[i]* , *z[i]* )之间的距离的平方是(*x* - *x[i]*)² + (*y* - *y[i]*)² + (*z* - *z[i]*)2。为了效率，不要使用`math.sqrt()`或`**`运算符。

    *解决方案*：参见 closest.py。

1.  编写一个程序，给定一系列对象的位置和质量，计算它们的质心，或*质心*。质心是按质量加权的*n*个对象的平均位置。如果位置和质量由(*x[i]*, *y[i]*, *m[i]*)给出，则质心(*x*, *y*, *m*)由以下公式给出

    > *m* = *m*[1] + *m*[2] + ... + *m[n]* *x* = (*m*[1]*x*[1] + ... + *m[n]x[n]*) / *m* *y* = (*m*[1]*y*[1] + ... + *m[n]y[n]*) / *m*

1.  编写一个程序，读取-1 到 1 之间的一系列浮点数，并写出它们的平均幅度、平均功率和零交叉数。*平均幅度*是数据值绝对值的平均值。*平均功率*是数据值的平方的平均值。*零交叉数*是数据值从严格负数转变为严格正数，或反之的次数。这三个统计量被广泛用于分析数字信号。

1.  编写一个程序，接受一个整数命令行参数`n`，并绘制一个由红色和黑色方块组成的`n`乘`n`棋盘。将左下角的方块涂成红色。

    > | ![5x5 棋盘](img/dc915cd7e82e99149c9f979d7b7697c2.png) | ![8x8 棋盘](img/3fc2385ef6145881761d8c3c8084166e.png) | ![25x25 棋盘](img/dd7fef0b179125bf302da039bd3ef0de.png) |
    > | --- | --- | --- |

    *解决方案*：参见 checkerboard.py

1.  编写一个程序，从命令行参数中接受一个整数`n`和一个介于 0 和 1 之间的浮点数`p`，在圆周上绘制`n`个等间距点，然后，对于每对点，以概率`p`，绘制连接它们的灰色线。

    > | ![erdos](img/023ea815e40c5c9c254daa2561dc9cd9.png) |
    > | --- |

1.  编写代码来绘制红心、黑桃、梅花和方块。要绘制一个红心，先绘制一个方块，然后将两个半圆连接到左上角和右上角。

1.  编写一个程序，接受一个整数命令行参数`n`，并绘制一个具有`n`个花瓣（如果`n`为奇数）或`2n`个花瓣（如果`n`为偶数）的“花朵”，通过绘制极坐标(*r*, θ)函数*r* = sin(*n* × θ)，其中θ范围从 0 到`2π`弧度。下面是`n`为 4、7 和 8 时的期望输出。

    > | ![玫瑰](img/2e84daf4180b13cde2c8a4d97a62afaa.png) |
    > | --- |

*解决方案*：参见 rose.py。

1.  编写一个程序，从命令行接受一个字符串`s`，并以横幅样式在屏幕上显示它，从左向右移动，并在达到末尾时回到字符串的开头。添加第二个命令行参数以控制速度。

    *解决方案*：参见 banner.py。

1.  修改 playthattune.py 以接受额外的命令行参数，控制音量（将每个采样值乘以音量）和节奏（将每个音符的持续时间乘以节奏）。

1.  编写一个程序，接受一个`.wav`文件的名称和一个播放速率*r*作为命令行参数，并以给定速率播放文件。首先，使用`stdaudio.read()`将文件读入数组`a[]`。如果*r* = 1，只需播放`a[]`；否则创建一个大约大小为*r*倍`len(a)`的新数组`b[]`。如果*r* < 1，通过从原始数组中进行*采样*来填充`b[]`；如果*r* > 1，通过*插值*从原始数组填充`b[]`。然后播放`b[]`。

1.  编写使用`stddraw`创建这些设计的程序。

    > ![几何设计](img/a15b4d142defa47e917b278ba1440848.png)

1.  编写一个程序，在单位正方形中的随机位置绘制随机大小的填充圆，生成类似下面的图像。您的程序应该接受四个命令行参数：圆的数量、每个圆为黑色的概率、最小半径和最大半径。

    > ![随机圆](img/acc9096db524d92edc6e8632eda8cec6.png)

* * *

#### 创意练习

1.  **可视化音频。** 修改 playthattune.py 以将播放的值发送到标准绘图，这样您就可以观看播放时的声波。您将不得不尝试在绘图画布中绘制多条曲线，以同步声音和图片。

1.  **统计调查。** 在为某些政治民意调查收集统计数据时，非常重要的是获得一个无偏的注册选民样本。假设您有一个文件，其中包含*n*个注册选民，每行一个。编写一个过滤器，写入大小为*m*的随机样本。（参见第 1.4 节的 sample.py 程序。）

1.  **地形分析。** 假设地形由二维高程值网格表示（以米为单位）。山峰是一个网格点，其四个相邻单元格（左、右、上、下）的高程值严格较低。编写一个程序，从标准输入读取地形，然后计算并写入地形中山峰的数量。

1.  **直方图。** 假设标准输入流是一系列浮点数。编写一个程序，从命令行接受一个整数`n`和两个浮点数`lo`和`hi`，并使用`stddraw`绘制一个直方图，显示标准输入流中落入(`lo`, `hi`)中的每个`n`个间隔中的数字的计数。

1.  **螺线图。** 编写一个程序，接受三个命令行参数*R*、*r*和*a*，并绘制结果的*螺线图*。一个[螺线图](https://en.wikipedia.org/wiki/Spirograph)（技术上，是一个外摆线）是通过围绕半径为*r*的圆在一个固定半径为*R*的大圆周围滚动形成的曲线。如果笔偏离滚动圆心(*r*+*a*)，那么在时间*t*时得到的曲线方程为

    ```
    *x*(*t*) = (*R*+*r*)cos(*t*) - (*r*+*a*)cos((*R*+*r*)*t*/*r*)
    *y*(*t*) = (*R*+*r*)sin(*t*) - (*r*+*a*)sin((*R*+*r*)*t*/*r*)

    ```

    这些曲线是由一种畅销玩具推广的，该玩具包含具有齿轮齿的圆盘和小孔，您可以在其中放入笔来追踪螺线图。

    *解决方案*：参见 spirograph.py。

1.  **时钟。** 编写一个程序，显示模拟时钟的秒、分和时针的动画。使用调用`stddraw.show(1000)`来大约每秒更新一次显示。

    *提示*：这可能是您想要使用浮点数的`%`运算符的罕见时刻之一；它的工作方式与您期望的一样。

    *解决方案*：参见 clock.py。

1.  **示波器。** 编写一个程序来模拟示波器的输出并产生利萨如图案。这些图案以法国物理学家朱尔斯·A·利萨如的名字命名，他研究了当两个相互垂直的周期性干扰同时发生时产生的图案。假设输入是正弦的，因此以下参数方程描述曲线：

    ```
    *x*(*t*) = *A[x]* sin (*w[x]t* + θ*[x]*)
    *y*(*t*) = *A[y]* sin (*w[y]t* + θ*[y]*)

    ```

    从命令行获取六个参数*A[x]*和*A[y]*（振幅）；*w[x]*和*w[y]*（角速度）；以及θ*x*和θ*y*（相位因子）。

    例如，下面的第一幅图像具有*A[x]* = *A[y]* = 1，*w[x]* = 2，*w[y]* = 3，θ*[x]* = 20 度，θ[*y*] = 45 度。另一个具有参数(1, 1, 5, 3, 30, 45)

    > | ![示波器 2](img/685cbd764bcfabbf9e58f88aaec1b45f.png) | ![示波器 3](img/61efeb8533a0ef43f16a3bc20564606b.png) |
    > | --- | --- |

    *解决方案*：参见 oscilloscope.py。

1.  **带轨道的弹跳球**。修改 bouncingball.py 以生成像本页早期显示的那样的图像，显示球在灰色背景上的轨迹。

1.  **带重力的弹跳球。** 修改 bouncingball.py 以在垂直方向上加入重力。添加调用`stdaudio.playFile()`来在球撞到墙壁时添加一个声音效果，撞到地板时添加另一个声音效果。

1.  **随机旋律。** 编写一个程序，使用`stdaudio`播放随机旋律。尝试保持在调内，给整音高概率，重复，以及其他规则来产生合理的旋律。

1.  **瓷砖图案。** 在之前的练习中，您编写了创建类似瓷砖的设计的程序。使用您解决该练习的解决方案，编写一个名为`tilepattern.py`的程序，它接受一个命令行参数`n`，并绘制一个`n`乘`n`的图案，使用您选择的瓷砖。添加第二个命令行参数以添加棋盘选项。添加第三个命令行参数以选择颜色。使用下面的图案作为起点，设计一个瓷砖地板。发挥创意！

    > ![瓷砖](img/cd274a60c340f86e2780bc64dac44d33.png)

    注意：这些都是古代的设计，您可以在许多古代（和现代）建筑中找到，例如罗马的圣若望大殿（圣约翰大殿） [1 2 3 4 5 6 ]或里斯本的瓷砖博物馆 [1 2 3 4 5 6 7 8 9 10 ]
