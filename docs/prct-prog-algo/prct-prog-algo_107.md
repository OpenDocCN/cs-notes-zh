# 5.1   字符串排序

> 原文：[`algs4.cs.princeton.edu/51radix`](https://algs4.cs.princeton.edu/51radix)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


本节正在大规模施工中。

### LSD 基数排序。

程序 LSD.java 实现了用于固定长度字符串的 LSD 基数排序。它包括一种用于对待每个整数作为 4 字节字符串处理的 32 位整数进行排序的方法。当 N 很大时，这种算法比系统排序快 2-3 倍。

### MSD 基数排序。

程序 MSD.java 实现了 MSD 基数排序。

### 三向字符串快速排序。

程序 Quick3string.java 实现了三向字符串快速排序。

#### 问与答

#### 练习

1.  **频率计数。** 读入一个字符串列表并打印它们的频率计数。算法：将字符串读入数组，使用三向基数快速排序对它们进行排序，并计算它们的频率计数。加速奖励：在三向分区期间计算计数。缺点：使用空间存储所有字符串。备选方案：TST。

1.  **对均匀分布数据进行排序。** 给定 N 个来自 [0, 1] 区间的随机实数，考虑以下算法对它们进行排序：将 [0, 1] 区间分成 N 个等间距子区间。重新排列（类似于累积计数）这 N 个元素，使每个元素都在其适当的桶中。对每个桶中的元素进行插入排序（或者等效地，只对整个文件进行插入排序）。也就是说，对一个级别进行 MSD 基数排序，然后切换到插入排序。[尝试原地进行？] *解决方案*：平均总共需要 O(N) 的时间。设 n_i 是桶 i 中的元素数量。插入排序所有桶的预期时间是 O(n)，因为 E[sum_i (n_i)²] <= 2n。

1.  给定一个包含 N 个不同长度的十进制整数的数组，描述如何在 O(N + K) 的时间内对它们进行排序，其中 K 是所有 N 个整数的总位数。

1.  **美国国旗排序。**（原地键索引计数）给定一个包含 N 个介于 0 和 R-1 之间的不同值的数组，以线性时间和 O(R) 的额外空间对它们进行升序排列。导致（本质上）原地字符串排序。

    *提示*：计算 `count[]` 数组，告诉你键需要放置的位置。扫描输入数组。取第一个键，找到它应该属于的桶，并将其交换到相应的位置（更新相应的 `count[]` 条目）。重复第二个键，但要小心跳过已知属于其位置的键。

#### 网络练习

1.  **2-sum.** 给定一个包含 N 个 64 位整数的数组 `a[]` 和一个目标值 T，确定是否存在两个不同的整数 i 和 j，使得 `a[i]` + `a[j]` 等于 T。你的算法应该在最坏情况下线性时间运行。

    *解决方案*。在线性时间内对数组进行基数排序。从左到右扫描指针 i 和从右到左扫描指针 j：考虑 a[i] + a[j]。如果它大于 T，则推进 j 指针；如果它小于 T，则推进 i 指针；如果它等于 T，则我们找到了所需的索引。

    注意，整数数组可以使用 Franceschini、Muthukrishnan 和 Patrascu 的高级基数排序算法在线性时间和常数额外空间内进行基数排序。

1.  **在排序的字符串数组中进行二分查找。** 实现一个用于排序字符串数组的二分查找版本，它跟踪查询字符串与 lo 和 hi 端点之间已知相同字符的数���。利用这些信息在二分查找过程中避免字符比较。比较此算法与调用 `compareTo()` 的版本的性能。（`compareTo()` 方法的优点是它不需要调用 `charAt()`，因为它是作为 `String` 数据类型的实例方法实现的。）
