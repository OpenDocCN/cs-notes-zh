# 4.1   无向图

> 原文：[`algs4.cs.princeton.edu/41graph`](https://algs4.cs.princeton.edu/41graph)

## 图。

*图*是一组*顶点*和连接一对顶点的*边*的集合。我们在 V-1 个顶点的图中使用 0 到 V-1 的名称表示顶点。![图](img/258e1245c0f0d47382c14553af418f18.png)

## 术语表。

这里是我们使用的一些定义。

+   *自环*是连接顶点与自身的边。

+   如果它们连接相同的一对顶点，则两条边是*平行*的。

+   当一条边连接两个顶点时，我们说这两个顶点*相邻*，并且该边*关联*这两个顶点。

+   一个顶点的*度*是与其关联的边的数量。

+   *子图*是构成图的边（和相关顶点）的子集，构成一个图。

+   图中的*路径*是由边连接的顶点序列，没有重复的边。

+   一个*简单路径*是一个没有重复顶点的路径。

+   *循环*是一条路径（至少有一条边），其第一个和最后一个顶点相同。

+   *简单循环*是一个没有重复顶点（除了第一个和最后一个顶点必须重复）的循环。

+   一条路径或循环的*长度*是其边的数量。

+   如果存在包含它们两者的路径，则我们说一个顶点*连接到*另一个顶点。

+   如果从每个顶点到每个其他顶点都存在路径，则图是*连通*的。

+   一个非连通的图由一组*连通分量*组成，这些连通分量是最大连通子图。

+   *无环图*是一个没有循环的图。

+   *树*是一个无环连通图。

+   *森林*是一组不相交的树。

+   连通图的*生成树*是包含该图所有顶点且为单棵树的子图。图的*生成森林*是其连通分量的生成树的并集。

+   *二分图*是一个我们可以将其顶点分为两组的图，使得所有边连接一组中的顶点与另一组中的顶点。

![图的解剖](img/46daced0fbff7aa77c7d4c8ace7b72b0.png) ![一棵树](img/e23ecfdc8c0e0b3eb55c47b055fc8dba.png) ![一个生成森林](img/ae66ac547a8a63b8d3a44e8466d652e2.png)

## 无向图数据类型。

我们实现以下无向图 API。![图 API](img/0e51968dc76e973997bf5601690a0af7.png)

关键方法`adj()`允许客户端代码迭代给定顶点相邻的顶点。值得注意的是，我们可以在`adj()`所体现的基本抽象上构建本节中考虑的所有算法。

我们准备了测试数据 tinyG.txt、mediumG.txt 和 largeG.txt，使用以下输入文件格式。

![图输入格式](img/bc23edebc7ea6cf17d86aea5d7ae5a66.png)

图客户端.java 包含典型的图处理代码。

## 图表示。

我们使用*邻接表表示法*，其中我们维护一个以顶点索引的数组，数组中的每个元素是与每个顶点通过边连接的顶点的列表。![邻接表无向图的表示](img/a03cd6de373b9fe9b46255254691e839.png)

图.java 使用邻接表表示法实现了图 API。邻接矩阵图.java 使用邻接矩阵表示法实现了相同的 API。

## 深度优先搜索。

深度优先搜索是一种经典的递归方法，用于系统地检查图中的每个顶点和边。要访问一个顶点

+   将其标记为已访问。

+   访问（递归地）所有与其相邻且尚未标记的���点。

深度优先搜索.java 实现了这种方法和以下 API：![搜索 API](img/cf60cdfd3ef4b9527a3058d7aa0c12f7.png)

## 寻找路径。

修改深度优先搜索以确定两个给定顶点之间是否存在路径以及找到这样的路径（如果存在）。我们试图实现以下 API：![路径 API](img/1f002f067f834492b9dc3f4994acf121.png)

为了实现这一点，我们通过将`edgeTo[w]`设置为`v`来记住将我们带到每个顶点`w`的边缘`v-w`，这是*第一次*。换句话说，`v-w`是从源到`w`的已知路径上的最后一条边。搜索的结果是以源为根的树；`edgeTo[]`是该树的父链接表示。深度优先路径.java 实现了这种方法。

## 广度优先搜索。

深度优先搜索找到从源顶点 s 到目标顶点 v 的一条路径。我们经常有兴趣找到*最短*这样的路径（具有最小数量的边）。广度优先搜索是基于这个目标的经典方法。要从`s`到`v`找到最短路径，我们从`s`开始，并在我们可以通过一条边到达的所有顶点中检查`v`，然后我们在我们可以通过两条边从`s`到达的所有顶点中检查`v`，依此类推。

要实现这种策略，我们维护一个队列，其中包含所有已标记但其邻接列表尚未被检查的顶点。我们将源顶点放入队列，然后执行以下步骤，直到队列为空：

+   从队列中移除下一个顶点`v`。

+   将所有未标记的与`v`相邻的顶点放入队列并标记它们。

广度优先路径.java 是实现`Paths` API 的一个实现，用于找到最短路径。它依赖于 FIFO 队列.java。

## 连通分量。

我们下一个直接应用深度优先搜索的是找到图的连通分量。回想一下第 1.5 节，“连接到”是将顶点划分为等价类（连通分量）的等价关系。对于这个任务，我们定义以下 API：![连通分量 API](img/cd756b03442c99919be26c3000b7ce1e.png)

CC.java 使用 DFS 实现此 API。

**命题。** DFS 在时间上标记与给定源连接的所有顶点，其时间与其度数之和成正比，并为客户提供从给定源到任何标记顶点的路径，其时间与其长度成正比。

**命题。**对于从`s`可达的任何顶点`v`，BFS 计算从`s`到`v`的最短路径（从`s`到`v`没有更少的边的路径）。在最坏情况下，BFS 花费时间与 V + E 成正比。

**命题。** DFS 使用预处理时间和空间与 V + E 成正比，以支持图中的常数时间连接查询。

## 更多深度优先搜索应用。

我们用 DFS 解决的问题是基础的。深度优先搜索还可以用于解决以下问题：

+   *循环检测：*给定图是否无环？循环.java 使用深度优先搜索来确定图是否有循环，如果有，则返回一个。在最坏情况下，它花费时间与 V + E 成正比。

+   *双色性：*给定图的顶点是否可以被分配为两种颜色，以便没有边连接相同颜色的顶点？二分图.java 使用深度优先搜索来确定图是否具有二��图；如果是，则返回一个；如果不是，则返回一个奇数长度的循环。在最坏情况下，它花费时间与 V + E 成正比。

+   *桥：* *桥*（或*割边*）是一条删除后会增加连接组件数量的边。等价地，仅当边不包含在任何循环中时，边才是桥。桥.java 使用深度优先搜索在图中找到桥。在最坏情况下，它花费时间与 V + E 成正比。

+   *双连通性：*一个*关节点*（或*割点*）是一个移除后会增加连接组件数量的顶点。如果没有关节点，则图形是*双连通*的。Biconnected.java 使用深度优先搜索来查找桥梁和关节点。在最坏情况下，它的时间复杂度为 V + E。

+   *平面性：*如果可以在平面上绘制图形，使得没有边相互交叉，则图形是*平面*的。 Hopcroft-Tarjan 算法是深度优先搜索的高级应用，它可以在线性时间内确定图形是否是平面的。

## 符号图。

典型应用涉及使用字符串而不是整数索引来处理图形，以定义和引用顶点。为了适应这些应用程序，我们定义了具有以下属性的输入格式：

+   顶点名称是字符串。

+   指定的分隔符分隔顶点名称（以允许名称中包含空格的可能性）。

+   每行表示一组边，将该行上的第一个顶点名称连接到该行上命名的每个其他顶点。

输入文件 routes.txt 是一个小例子。

> ![航线](img/2f0ea35e84ad2da2af76274beca97414.png)

输入文件 movies.txt 是来自互联网电影数据库的一个更大的示例。该文件包含列出电影名称后跟电影中表演者列表的行。

> ![电影-表演者图](img/73fe01debd55f407d63e6dde777b1ea2.png)

+   *API。* 以下 API 允许我们为这种输入文件使用我们的图处理例程。

    > ![符号图 API](img/2218ddcda67356768e65337c6dbb2d04.png)

+   *实现。*SymbolGraph.java 实现了 API。它构建了三种数据结构：

    +   一个符号表`st`，具有`String`键（顶点名称）和`int`值（索引）

    +   一个作为反向索引的数组`keys[]`，给出与每个整数索引关联的顶点名称

    +   使用索引构建的`Graph` `G`，以引用顶点

    > ![符号图数据结构](img/eed7178c60fcb5112f09b6876942314f.png)

+   *分离度。*DegreesOfSeparation.java 使用广度优先搜索来查找社交网络中两个个体之间的分离度。对于演员-电影图，它玩的是凯文·贝肯游戏。

#### 练习

1.  为 Graph.java 创建一个复制构造函数，该构造函数以图`G`作为输入，并创建并初始化图的新副本。客户端对`G`所做的任何更改都不应影响新创建的图。

1.  向 BreadthFirstPaths.java 添加一个`distTo()`方法，该方法返回从源到给定顶点的最短路径上的边数。`distTo()`查询应在常数时间内运行。

1.  编写一个程序 BaconHistogram.java，打印凯文·贝肯号的直方图，指示 movies.txt 中有多少表演者的贝肯号为 0、1、2、3 等。包括那些具有无限号码的类别（与凯文·贝肯没有联系）。

1.  编写一个`SymbolGraph`客户端 DegreesOfSeparationDFS.java，该客户端使用*深度优先*而不是广度优先搜索来查找连接两个表演者的路径。

1.  使用第 1.4 节的内存成本模型确定`Graph`表示具有`V`个顶点和`E`条边的图所使用的内存量。

    *解决方案。* 56 + 40V + 128E。MemoryOfGraph.java 根据经验计算，假设没有缓��`Integer`值—Java 通常会缓存-128 到 127 之间的整数。

#### 创意问题

1.  **并行边检测。**设计一个线性时间算法来计算图中的平行边数。

    *提示*：维护一个顶点的邻居的布尔数组，并通过仅在需要时重新初始化条目来重复使用此数组。

1.  **双边连通性。** 在图中，*桥*是一条边，如果移除，则会将一个连通图分隔成两个不相交的子图。没有桥的图被称为*双边连通*。开发一个基于 DFS 的数据类型 Bridge.java，用于确定给定图是否是边连通的。

#### 网页练习

1.  找一些有趣的图。它们是有向的还是无向的？稀疏的还是密集的？

1.  **度。** 顶点的度是与之关联的边的数量。向`Graph`添加一个方法`int degree(int v)`，返回顶点 v 的度数。

1.  假设在运行广度优先搜索时使用堆栈而不是队列。它仍然计算最短路径吗？

1.  **使用显式堆栈的 DFS。** 给出 DFS 可能出现堆栈溢出的示例，例如，线图。修改 DepthFirstPaths.java，使其使用显式堆栈而不是函数调用堆栈。

1.  **完美迷宫。** 生成一个[完美迷宫](http://www.mazeworks.com/mazegen/mazetut/index.htm)像这样的

    > | ![14×14 完美迷宫](img/8bbbfca0ad42890f0b0413098edbbbb6.png) | ![22×22 完美迷宫](img/90a35a525fbaaf918d724c57d4c9a95e.png) |
    > | --- | --- |

    编写一个程序 Maze.java，它接受一个命令行参数 n，并生成一个随机的 n×n 完美迷宫。如果迷宫*完美*，则每对迷宫中的点之间都有一条路径，即没有无法访问的位置，没有循环，也没有开放空间。这里有一个生成这样的迷宫的好算法。考虑一个 n×n 的单元格网格，每个单元格最初与其四个相邻单元格之间都有一堵墙。对于每个单元格（x, y），维护一个变量`north[x][y]`，如果存在将（x, y）和（x, y + 1）分隔的墙，则为`true`。我们有类似的变量`east[x][y]`，`south[x][y]`和`west[x][y]`用于相应的墙壁。请注意，如果（x, y）的北面有一堵墙，则`north[x][y] = south[x][y+1] = true`。通过以下方式拆除一些墙壁来构建迷宫：

    1.  从较低级别单元格（1, 1）开始。

    1.  随机找到一个您尚未到达的邻居。

    1.  如果找到一个，就移动到那里，拆除墙壁。如果找不到，则返回上一个单元格。

    1.  重复步骤 ii.和 iii.，直到您访问了网格中的每个单元格。

    *提示*：维护一个(n+2)×(n+2)的单元格网格，以避免繁琐的特殊情况。

    这是由卡尔·埃克洛夫使用此算法创建的一个 Mincecraft 迷宫。

    > ![Minecraft 迷宫](img/be08c6c1c40896e8782849a774cb48be.png)

1.  **走出迷宫。** 给定一个 n×n 的迷宫（就像在前一个练习中创建的那样），编写一个程序，如果存在路径，则从起始单元格（1, 1）到终点单元格（n, n）找到一条路径。要找到迷宫的解决方案，请运行以下算法，从（1, 1）开始，并在到达单元格（n, n）时停止。

    ```
    explore(x, y)
    -------------
      - Mark the current cell (x, y) as "visited."
      - If no wall to north and unvisited, then explore(x, y+1).
      - If no wall to east and  unvisited, then explore(x+1, y).
      - If no wall to south and unvisited, then explore(x, y-1).
      - If no wall to west and  unvisited, then explore(x-1, y).

    ```

1.  **迷宫游戏。** 开发一个迷宫游戏，就像来自[gamesolo.com](http://www.gamesolo.com/flash-game)的这个，您在其中穿过迷宫，收集奖品。

1.  **演员图。** 计算凯文·贝肯数的另一种（也许更自然）方法是构建一个图，其中每个节点都是一个演员。如果两个演员一起出现在一部电影中，则它们之间通过一条边连接。通过在演员图上运行 BFS 来计算凯文·贝肯数。比较与文本中描述的算法的运行时间。解释为什么文本中的方法更可取。*答案*：它避免了多个平行边。因此，它更快，使用的内存更少。此外，它更方便，因为您不必使用电影名称标记边缘-所有名称都存储在顶点中。

1.  **好莱坞宇宙的中心。** 我们可以通过计算他们的*好莱坞数*来衡量凯文·贝肯是一个多好的中心。凯文·贝肯的好莱坞数是所有演员的平均贝肯数。另一位演员的好莱坞数计算方式相同，但我们让他们成为源，而不是凯文·贝肯。计算凯文·贝肯的好莱坞数，并找到一个演员和一个女演员，他们的好莱坞数更好。

1.  **好莱坞宇宙的边缘。** 找到（与凯文·贝肯相连的）具有最高好莱坞数的演员。

1.  **单词梯子。** 编写一个程序 WordLadder.java，从命令行中获取两个 5 个字母的字符串，并从标准输入中读取一个 5 个字母的单词列表，然后打印出连接这两个字符串的最短[单词梯子](http://www.wordplay.fsnet.co.uk/wl/ladders.htm)（如果存在）。如果两个单词在一个字母上不同，那么它们可以在一个单词梯子链中连接起来。例如，以下单词梯子连接了 green 和 brown。

    ```
    green greet great groat groan grown brown

    ```

    你也可以尝试在这个 6 个字母单词列表上运行你的程序。

1.  **更快的单词梯子。** 为了加快速度（如果单词列表非常大），不要编写嵌套循环来尝试所有成对的单词是否相邻。对于 5 个字母的单词，首先对单词列表进行排序。只有最后一个字母不同的单词将在排序后的列表中连续出现。再排序 4 次，但将字母向右循环移动一个位置，以便在一个排序列表中连续出现在第 i 个字母上不同的单词。

    尝试使用一个更大的单词列表来测试这种方法，其中包含不同长度的单词。如果两个长度不同的单词���有最后一个字母不同，则它们是相邻的。

1.  假设你删除无向图中的所有桥梁。结果图的连通分量是否是双连通分量？*答案*：不是，两个双连通分量可以通过一个关节点连接。

    ## 桥梁和关节点。

    *桥梁*（或割边）是一条移除后会断开图的边。*关节点*（或割点）是一个移除后（以及移除所有关联边后）会断开剩余图的顶点。桥梁和关节点很重要，因为它们代表网络中的单点故障。蛮力方法：删除边（或顶点）并检查连通性。分别需要 O(E(V + E))和 O(V(V + E))的时间。可以通过巧妙地扩展 DFS 将两者都改进为 O(E + V)。

1.  **双连通分量。** 一个无向图是*双连通*的，如果对于每一对顶点 v 和 w，v 和 w 之间有两条顶点不重叠的路径。（或者等价地，通过任意两个顶点的简单循环。）我们在边上定义一个共圆等价关系：如果 e1 = e2 或者存在包含 e1 和 e2 的循环，则 e1 和 e2 在同一个双连通分量中。两个双连通分量最多共享一个公共顶点。一个顶点是关节点，当且仅当它是多于一个双连通分量的公共部分时。程序 Biconnected.java 标识出桥梁和关节点。

1.  **双连通分量。** 修改`Biconnected`以打印构成每个双连通分量的边。提示：每个桥梁都是自己的双连通分量；要计算其他双连通分量，将每个关节点标记为已访问，然后运行 DFS，跟踪从每个 DFS 起点发现的边。

1.  对随机无向图的连通分量数量进行数值实验。在 1/2 V ln V 附近发生相变。（参见 Algs Java 中的属性 18.13。）

1.  **流氓。**（安德鲁·阿普尔。）在一个无向图中，一个怪物和一个玩家分别位于不同的顶点。在角色扮演游戏 Rogue 中，玩家和怪物轮流行动。每轮中，玩家可以移动到相邻的顶点或原地不动。确定玩家在怪物之前可以到达的所有顶点。假设玩家先行动。

1.  **流氓。**（安德鲁·阿普尔。）在一个无向图中，一个怪物和一个玩家分别位于不同的顶点。怪物的目标是落在与玩家相同的顶点上。为怪物设计一个最佳策略。

1.  **关节点。** 设 G 是一个连通的无向图。考虑 G 的 DFS 树。证明顶点 v 是 G 的关节点当且仅当（i）v 是 DFS 树的根并且有多于一个子节点，或者（ii）v 不是 DFS 树的根并且对于 v 的某个子节点 w，w 的任何后代（包括 w）和 v 的某个祖先之间没有反向边。换句话说，v 是关节点当且仅当（i）v 是根并且有多于一个子节点，或者（ii）v 有一个子节点 w，使得 low[w] >= pre[v]。

1.  **谢尔宾斯基垫。** 一个优美的欧拉图的例子。

1.  **优先连接图。** 如下创建一个具有 V 个顶点和 E 条边的随机图：以任意顺序开始具有 V 个顶点 v1，..，vn。均匀随机选择序列的一个元素并添加到序列的末尾。重复 2E 次（使用不断增长的顶点列表）。将最后的 2E 个顶点配对以形成图。

    大致来说，等价于按照两个端点的度数的乘积成比例的概率逐个添加每条边。[参考](http://research.microsoft.com/users/lovasz/hom-survey.pdf)。

1.  **维纳指数。** 一个顶点的维纳指数是该顶点与所有其他顶点之间的最短路径距离之和。图 G 的维纳指数是所有顶点对之间的最短路径距离之和。被数学化学家使用（顶点=原子，边=键）。

1.  **随机游走。** 从迷宫中走出（或图中的 st 连通性）的简单算法：每一步，朝一个随机方向迈出一步。对于完全图，需要 V log V 时间（收集优惠券）；对于线图或环，需要 V² 时间（赌徒的失败）。一般来说，覆盖时间最多为 2E(V-1)，这是 Aleliunas、Karp、Lipton、Lovasz 和 Rackoff 的经典结果。

1.  **删除顺序。** 给定一个连通图，确定一个顺序来删除顶点，使得每次删除后图仍然连通。你的算法在最坏情况下应该花费与 V + E 成比例的时间。

1.  **树的中心。** 给定一个树（连通且无环）的图，找到一个顶点，使得它与任何其他顶点的最大距离最小化。

    *提示*：找到树的直径（两个顶点之间的最长路径）并返回中间的一个顶点。

1.  **树的直径。** 给定一个树（连通且无环）的图，找到最长的路径，即一对顶点 v 和 w，它们之间的距离最远。你的算法应该在线性时间内运行。

    *提示。* 选择任意顶点 v。计算从 v 到每个其他顶点的最短路径。设 w 是最大最短路径距离的顶点。计算从 w 到每个其他顶点的最短路径。设 x 是最大最短路径距离的顶点。从 w 到 x 的路径给出直径。

1.  **使用并查集查找桥梁。** 设 T 是一个连通图 G 的生成树。图 G 中的每条非树边 e 形成一个由边 e 和树中连接其端点的唯一路径组成的基本环。证明一条边是桥梁当且仅当它不在某个基本环上。因此，所有桥梁都是生成树的边。设计一个算法，使用 E + V 时间加上 E + V 并查集操作，找到所有桥梁（和桥梁组件）。

1.  **非递归深度优先搜索。** 编写一个程序 NonrecursiveDFS.java，使用显式堆栈而不是递归来实现深度优先搜索。

    这是 Bin Jiang 在 1990 年代初提出的另一种实现。唯一额外的内存是用于顶点堆栈，但该堆栈必须支持任意删除（或至少将任意项移动到堆栈顶部）。

    ```
    private void dfs(Graph G, int s) {
        SuperStack<Integer> stack = new SuperStack<Integer>();
        stack.push(s);
        while (!stack.isEmpty()) {
            int v = stack.peek();
            if (!marked[v]) {
                marked[v] = true;
                for (int w : G.adj(v)) {
                    if (!marked[w]) {
                        if (stack.contains(w)) stack.delete(w);
                        stack.push(w);
                    }
                }
            }
            else {
                // v's adjacency list is exhausted
                stack.pop();
            }
        }
    }

    ```

    这里是另一种实现。这可能是最简单的非递归实现，但在最坏情况下使用的空间与 E + V 成比例（因为一个顶点的多个副本可能在堆栈上），并且以标准递归 DFS 的相反顺序探索与 v 相邻的顶点。此外，`edgeTo[v]` 条目可能被更新多次，因此可能不适用于回溯应用。

    ```
    private void dfs(Graph G, int s) {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(s);
        while (!stack.isEmpty()) {
            int v = stack.pop();
            if (!marked[v]) {
                marked[v] = true;
                for (int w : G.adj(v)) {
                    if (!marked[w]) {
                        edgeTo[w] = v;
                        stack.push(w);
                     }
                }
            }
        }
    }

    ```

1.  **非递归深度优先搜索。** 解释为什么以下非递归方法（类似于 BFS，但使用堆栈而不是队列）*不*实现深度优先搜索。

    ```
    private void dfs(Graph G, int s) {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(s);
        marked[s] = true;
        while (!stack.isEmpty()) {
           int v = stack.pop();
           for (int w : G.adj(v)) {
               if (!marked[w]) {
                   stack.push(w);
                   marked[w] = true;
                   edgeTo[w] = v;
               }
           }
        }
    }

    ```

    *解决方案：*考虑由边 0-1、0-2、1-2 和 2-1 组成的图，其中顶点 0 为源。

1.  **Matlab 连通分量。** 在 Matlab 中，bwlabel() 或 bwlabeln() 用于标记 2D 或 kD 二进制图像中的连通分量。bwconncomp() 是更新版本。

1.  **互补图中的最短路径。** 给定一个图 G，设计一个算法来找到从 s 到互补图 G' 中每个其他顶点的最短路径（边的数量）。*互补*图包含与 G 相同的顶点，但只有当边 v-w 不在 G 中时才包含边 v-w。你能否比明确计算互补图 G' 并在 G' 中运行 BFS 做得更好？

1.  **删除一个顶点而不断开图。** 给定一个连通图，设计一个线性时间算法来找到一个顶点，其移除（删除顶点和所有关联边）不会断开图。

    *提示 1（使用 DFS）*：从某个顶点 s 运行 DFS，并考虑 DFS 中完成的第一个顶点。

    *提示 2（使用 BFS）*：从某个顶点 s 运行 BFS，并考虑具有最大距离的任何顶点。

1.  **生成树。** 设计一个算法，以时间复杂度为 V + E 计算一个连通图的生成树。*提示*：使用 BFS 或 DFS。

1.  **图中的所有路径。** 编写一个程序 AllPaths.java，枚举图中两个指定顶点之间的所有简单路径。*提示*：使用 DFS 和回溯。*警告*：图中可能存在指数多个简单路径，因此对于大型图，没有算法可以高效运行。
