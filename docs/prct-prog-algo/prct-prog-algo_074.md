# 3.3 设计数据类型

> 译文：[`introcs.cs.princeton.edu/python/33design`](https://introcs.cs.princeton.edu/python/33design)

在本节中，我们将重点放在开发 API 作为任何程序开发的关键步骤上。我们需要考虑各种替代方案，了解它们对客户端程序和实现的影响，并完善设计以在客户端需求和可能的实现策略之间取得适当平衡。

* * *

## 设计 API

在第 3.1 节中，我们编写了使用 API 的客户端程序；在第 3.2 节中，我们实现了 API。现在我们考虑设计 API 的挑战。

### 标准。

通过考虑其他领域，很容易理解遵循 API 的重要性。从铁路轨道，到螺纹螺母，到 MP3 和 DVD，到无线电频率，到互联网标准，我们知道使用共同的标准接口能够实现技术的最广泛使用。通过使用 API 将客户端与实现分离，我们为我们组合的每个程序获得标准接口的好处。

### 规范问题。

我们针对数据类型的 API 是一组方法，以及简短的英语描述这些方法应该做什么。理想情况下，一个 API 应该清晰地表达所有可能参数的行为，包括副作用，然后我们会有软件来检查实现是否符合规范。不幸的是，来自理论计算机科学的一个基本结果，即*规范问题*，表明这个目标实际上是不可能实现的。因此，我们转而采用带有示例的非正式描述，比如围绕我们的 API 的文本。

### 宽接口。

*宽接口*是具有过多方法的接口。在设计 API 时要遵循的一个重要原则是避免宽接口。

### 从客户端代码开始。

开发数据类型的主要目的之一是简化客户端代码。因此，在设计 API 时，从一开始就关注客户端代码是有意义的。甚至更好的是组合两个客户端。从客户端代码开始是确保开发实现值得的一种方式。

### 避免对表示的依赖。

通常在开发 API 时，我们心中有一个表示。毕竟，数据类型是一组值和在这些值上定义的一组操作，并且在不了解值的情况下谈论操作并没有太多意义。但这与了解值的表示是不同的。数据类型的一个目的是通过允许客户端避免对特定表示的细节和依赖来简化客户端代码。

### API 设计中的陷阱。

一个 API 可能太难实现，意味着难以开发或不可能开发的实现，或者太难使用，导致客户端代码比没有 API 更复杂。一个 API 可能太窄，省略了客户端需要的方法，或者太宽，包含大量任何客户端都不需要的方法。一个 API 可能太一般化，提供没有用的抽象，或者太具体，提供过于详细或过于分散的抽象。这些考虑有时总结为座右铭：*为客户端提供他们需要的方法，而不提供其他方法*。

* * *

## 封装

通过隐藏信息将客户端与实现分离的过程被称为*封装*。实现的细节对客户端保持隐藏，实现没有办法知道客户端代码的细节，甚至可能是未来创建的。我们使用封装来实现模块化编程，促进调试，并澄清程序代码。这些原因是相互联系的（设计良好的模块化代码比完全基于内置类型的代码更容易调试和理解）。

### 模块化编程。

模块化编程成功的关键在于保持模块之间的独立性。我们通过坚持 API 是客户端和实现之间唯一的依赖点来实现这一点——数据类型实现代码可以假定客户端除了 API 之外一无所知。

### 更改 API。

当我们使用标准模块时，我们经常会获得封装的好处。例如，Python 的新版本通常可能包括各种数据类型或定义函数的模块的新实现。改进数据类型实现的动机非常强烈且持续，因为所有客户端都有可能从改进的实现中受益。然而，Python 的 API 很少改变。当发生更改时，整个 Python 社区都会付出代价——每个人都必须更新他们的客户端。因此，一旦有大量客户端使用一个模块，就尽量不要更改其 API。

### 更改实现。 ![极坐标表示](img/eeaa12f3fec9b21411bef3325e0087e5.png)

考虑在 complexpolar.py 中定义的`Complex`类。它与 complex.py（来自第 3.2 节）中定义的`Complex`类具有相同的名称和 API，但使用不同的复数表示。complex.py 中定义的`Complex`类使用笛卡尔表示，其中实例变量`_re`和`_im`表示复数为*x* + *yi*。complexpolar.py 中定义的`Complex`类使用极坐标表示，其中实例变量`_r`和`_theta`表示复数为*r*(cos θ + *i* sin θ)。在这种表示中，我们将*r*称为*幅值*，θ称为*极角*。极坐标表示是有趣的，因为在极坐标表示中，对复数的某些操作更容易执行。加法和减法在笛卡尔表示中更容易；乘法和除法在极坐标表示中更容易。封装的思想是我们可以在不改变客户端代码的情况下将其中一个程序替换为另一个程序（无论出于何种原因），只需将`import`语句更改为使用`complexpolar`而不是`complex`。

### 私有。

许多编程语言提供支持以强制实现封装。例如，Java 提供了`private`可见性修饰���。当您将实例变量（或方法）声明为私有时，您使得任何客户端（另一个模块中的代码）无法直接访问修饰符所涉及的实例变量（或方法）。Python 没有提供`private`可见性修饰符，这意味着客户端可以直接访问所有实例变量、方法和函数。然而，Python 编程社区提倡一个相关的约定：如果一个实例变量、方法或函数的名称以下划线开头，那么客户端应该将该实例变量、方法或函数视为私有。通过这种命名约定，客户端被告知不应直接访问以这种方式命名的实例变量、方法或函数。

在这个书站中，我们总是在我们的类中将所有实例变量设为私有的。我们强烈建议您也这样做——没有理由从客户端直接访问实例变量。

### 限制错误的可能性。

封装还帮助程序员确保他们的代码按预期运行。例如，在 2000 年总统选举中，阿尔·戈尔在佛罗里达州沃卢西亚县的一台电子投票机上收到了负 16,022 票。计数器变量在投票机软件中没有被正确封装！要理解问题，请考虑 counter.py，它根据这个 API 定义了一个简单的`Counter`类：

> ![计数器 API](img/4a991ecbac09acb9cb2f39b1e403f3e8.png)

这种抽象在许多情况下都很有用，比如电子投票机。它封装了一个单一的整数，并确保唯一可以对该整数执行的操作是加一。因此，它永远不会变为负数。适当的封装远非是解决投票安全问题的完整解决方案，但却是一个很好的开始。

### 代码清晰度。

精确指定数据类型可以改善设计，因为它导致客户端代码可以更清晰地表达其计算。在第 3.1 节和第 3.2 节中，你已经看到了许多这样的客户端代码示例，从带电粒子到图片再到复数。良好设计的关键之一是观察到使用适当的抽象组合的代码几乎可以自我说明。

* * *

## 不可变性

如果一个数据类型的对象一旦创建就无法更改其数据类型值，则该数据类型的对象是*不可变*的。不可变数据类型，比如 Python 字符串，是所有该类型对象都是不可变的。相比之下，*可变*数据类型，比如 Python 列表/数组，是其对象的值被设计为可以改变的。在本章考虑的数据类型中，`Charge`、`Color`和`Complex`都是不可变的，而`Picture`、`Histogram`、`Turtle`、`StockAccount`和`Counter`都是可变的。是否使数据类型不可变是一个基本的设计决策，取决于手头的应用。

### 不可变数据类型。

许多数据类型的目的是封装不会改变的值。例如，一个程序员实现一个`Complex`客户端可能合理地期望组合代码`z = z0`，从而设置两个变量引用相同的`Complex`对象，就像对浮点数或整数一样。但是，如果`Complex`是可变的，并且在赋值`z = z0`之后被引用的对象发生变化，那么被`z0`引用的对象也会发生变化（它们是别名，或者都是对同一对象的引用）。从概念上讲，改变`z`的值将改变`z0`的值！这种意外的结果，称为*别名错误*，对许多初学者来说是一个惊喜，这是面向对象编程的一个重要概念。

### 可变数据类型。

对于许多其他数据类型，抽象的目的就是封装值随着变化而变化。在 turtle.py（来自第 3.2 节）中定义的`Turtle`类就是一个典型例子。同样，`Picture`、`Histogram`、`StockAccount`、`Counter`和 Python 列表/数组都是我们期望值会改变的类型。

### 数组和字符串。

作为客户端程序员，当使用 Python 列表/数组（可变）和 Python 字符串（不可变）时，你已经遇到了这种区别。当你将一个字符串传递给一个方法/函数时，你不��要担心该方法/函数改变字符串中的字符序列。相反，当你将一个数组传递给一个方法/函数时，该方法/函数可以自由地改变数组的元素。Python 字符串是不可变的，因为我们通常不希望`str`值发生变化；Python 数组是可变的，因为我们经常希望数组元素发生变化。

### 不可变性的优势。

一般来说，不可变数据类型更容易使用，更难被误用，因为能够改变对象值的代码范围远比可变类型小得多。

### 不可变性的代价。

不可变性的缺点是你必须为每个值创建一个新对象。例如，当你使用`Complex`数据类型时，表达式`z = z*z + z0`涉及创建第三个对象（用于保存值`z*z`），然后使用该对象与`+`运算符（不保存显式引用）并创建第四个对象来保存值`z*z + z0`，并将该对象分配给`z`（从而使原始引用`z`变为孤立）。一个程序，比如 mandelbrot.py（来自第 3.2 节），会创建大量这样的中间对象。然而，这种开销通常是可以接受的，因为 Python 的内存管理通常针对这种情况进行了优化。

### 防御性复制。

假设我们希望开发一个名为`Vector`的不可变数据类型，其构造函数接受一个浮点数数组作为参数来初始化一个实例变量。考虑以下尝试：

```
class Vector:
    def __init__(self, a):
        self._coords = a   # array of coordinates
    ...

```

这段代码使`Vector`成为一个可变数据类型。客户程序可以通过指定数组中的元素来创建一个`Vector`对象，然后（绕过 API）在创建后更改 Vector 的元素：

```
a = [3.0, 4.0]
v = Vector(a)
a[0] = 17.0  # bypasses the public API

```

为了确保包含可变类型实例变量的数据类型的不可变性，实现需要进行本地复制，称为*防御性复制*。回想一下第 1.4 节中，表达式`a[:]`创建了数组`a[]`的一个副本。因此，这段代码创建了一个防御性复制：

```
class Vector:
    def __init__(self, a):
        self._coords = a[:]   # array of coordinates
    ...

```

接下来，我们考虑这种数据类型的完整实现。

* * *

## 示例：空间向���

![一个空间向量](img/7bcd03654bc1ff810fadf378383d7517.png)

*空间向量* 是一个具有大小和方向的抽象实体。空间向量提供了一种自然的方式来描述物理世界的属性，如力、速度、动量或加速度。一种标准的指定向量的方式是作为从原点到笛卡尔坐标系中一点的箭头：方向是从原点到点的射线，大小是箭头的长度（从原点到点的距离）。为了指定向量，只需指定点即可。

这个概念可以扩展到任意维度：一个包含*n*个实数的有序列表（一个*n*维点的坐标）足以指定*n*维空间中的一个向量。按照惯例，我们使用粗体字母来表示一个向量，用逗号分隔的数字或带下标的变量名（斜体字母相同）在括号内表示其值。例如，我们可以用**x**表示向量(*x*[0], *x*[1], ..., *x*[*n*-1])，用**y**表示向量(*y*[0], *y*[1], ..., *y*[*n*-1])。

### API。

向量的基本操作是将两个向量相加，将一个向量乘以一个标量（一个实数），计算两个向量的点积，以及计算大小和方向，如下所示：

+   *加法*：**x** + **y** = (*x*[0] + *y*[0], *x*[1] + *y*[1], ..., *x*[*n*-1] + *y*[*n*-1])

+   *标量乘积*：α**x** = (α*x*[0], α*x*[1], ..., α*x*[*n*-1])

+   *点积*：**x** · **y** = *x*[0]*y*[0] + *x*[1]*y*[1] + ... + *x*[*n*-1]*y*[*n*-1]

+   *大小*：|**x**| = (*x*[0]² + *x*[1]² + ... + *x*[*n*-1]²)^(1/2)

+   *方向*：**x** / |**x**| = (*x*[0] / |**x**|, *x*[1] / |**x**|, ..., *x*[*n*-1] / |**x**|)

这些定义导致了以下 API：

> ![向量 API](img/b5292127553bed9ace9654f9cf0b4a08.png)

与`Complex`一样，这个 API 并没有明确指定数据类型是不可变的，但我们知道客户程序员（可能会以数学抽象的方式思考）肯定会期望这种约定，也许我们宁愿不向他们解释我们试图保护他们免受别名错误的影响！

### 表示。

在开发实现时，我们的第一选择是为数据选择一个表示。使用数组保存构造函数中提供的笛卡尔坐标是一个明显的选择，但不是唯一合理的选择。如果有必要，实现可以更改坐标系而不影响客户端代码。

### 实现。

给定表示，实现所有这些操作的代码是直接的，你可以在 vector.py 中定义的`Vector`类中看到。构造函数对客户端数组进行了防御性拷贝，而且没有任何方法给拷贝赋值，因此`Vector`对象是不可变的。

当客户端可以自由组合代码如`x[i] = 2.0`时，我们如何确保不可变性？这个问题的答案在于一个特殊的方法，我们在不可变数据类型中不实现：在这种情况下，Python 调用特殊方法`__setitem__()`而不是`__getitem__()`。由于`Vector`没有实现该方法，这样的客户端代码会在运行时引发`AttributeError`。

* * *

## 元组

Python 的内置`tuple`数据类型表示一个*不可变*对象序列。它类似于内置的`list`数据类型（我们用于数组），不同之处在于一旦创建了元组，就不能更改其项。你可以使用熟悉的数组表示法来操作元组，如本 API 中所述：

> ![元组 API（部分）](img/352e5b621c171f38278840c25ae5d5ed.png)

你可以使用内置函数`tuple()`创建元组，也可以通过列出一系列用逗号分隔的表达式，并（可选）用匹配的括号括起来。

使用元组可以改善程序的设计。例如，如果我们用以下语句替换 vector.py 构造函数中的第一条语句

```
self._coords = tuple(a)

```

那么任何尝试在 Vector 类内部更改向量坐标的操作都会在运行时引发`TypeError`，有助于强制执行`Vector`对象的不可变性。

Python 还提供了一个强大的元组赋值功能，称为*元组打包*和*元组解包*，它允许你将右侧赋值运算符上的表达式元组分配给左侧的变量元组（前提是左侧的变量数量与右侧的表达式数量相匹配）。你可以使用这个功能同时赋值多个变量。例如，以下语句交换了变量`x`和`y`中的对象引用：

```
x, y = y, x

```

你还可以使用元组打包和解包从函数中返回多个值（请参见本节末尾的一个练习）。

* * *

## 多态

通常，当我们组合方法（或函数）时，我们打算它们只能与特定类型的对象一起使用。有时，我们希望它们能够与不同类型的对象一起使用。一个可以接受不同类型参数的方法（或函数）被称为*多态的*。

最好的多态是意想不到的：当你将一个现有的方法/函数应用于一个新的数据类型（你从未计划过的）时，发现该方法/函数恰好具有你想要的行为。最糟糕的多态也是意想不到的：当你将一个现有的方法/函数应用于一个新的数据类型时，它返回错误的答案！发现这种错误可能是一个非凡的挑战。

### 鸭子类型。

鸭子类型是一种编程风格，语言不正式指定函数参数的要求；相反，它只是尝试调用定义了兼容函数的函数（否则会引发运行时错误）。这个名字来自一句被归因于诗人 J.W.莱利的古老引语：*当我看到一只鸟

走起来像鸭子，游泳像鸭子，嘎嘎叫像鸭子

我称那只鸟为鸭子*

在 Python 中，如果一个对象像鸭子一样走路，游泳，嘎嘎叫，你可以将该对象视为鸭子；你不需要明确声明它是鸭子。在许多语言（如 Java 或 C++）中，您需要明确声明变量的类型，但在 Python 中不需要 — Python 对所有操作（函数调用，方法调用和运算符）使用鸭子类型。如果由于不适当的类型而无法将操作应用于对象，则它会在运行时引发`TypeError`。这种方法导致客户端代码更简单、更灵活，并将重点放在实际使用的操作上，而不是类型上。

### 鸭子类型的缺点。

鸭子类型的主要缺点是很难准确知道客户端和实现之间的契约是什么，特别是当需要的方法只间接需要时。API 简单地不携带这种信息。这种信息的缺乏可能导致运行时错误。更糟糕的是，最终结果可能在语义上不正确，而根本没有引发错误。接下来，我们考虑这种情况的一个简单示例。

### 一个案例。

我们设计我们的`Vector`数据类型时，隐含地假设向量分量��是浮点数，并且客户端将通过将`float`对象数组传递给构造函数来创建一个新向量。如果客户端以这种方式创建两个向量`x`和`y`，那么`x[i]`和`x.dot(y)`都返回浮点数，`x + y`和`x - y`都返回具有浮点分量的向量，如预期的那样。

假设，相反地，一个客户通过将`int`对象数组传递给构造函数来创建具有整数分量的`Vector`。如果客户以这种方式创建两个向量`x`和`y`，那么`x[i]`和`x.dot(y)`都返回整数，`x + y`和`x - y`都返回具有整数分量的向量，如所需。当然，`abs(x)`返回一个`float`，而`x.direction()`返回一个具有`float`分量的向量。这是最好的多态性，其中鸭子类型恰好起作用。

现在，假设一个客户通过将`complex`对象数组传递给构造函数来创建具有复数分量的`Vector`。向量加法或标量乘法没有问题，但点积操作的实现（以及依赖于点积的幅度和方向的实现）却失败得惊人。这里是一个例子：

```
a = [1 + 2j, 2 + 0j, 4 + 0j]
x = Vector(a)
b = abs(x)

```

这段代码在运行时导致`TypeError`，因为`math.sqrt()`试图对一个复数取平方根。问题在于两个复值向量**x**和**y**的点积需要取第二个向量中元素的*复共轭*。教科书详细描述了问题及其解决方案。

在这种情况下，鸭子类型是最糟糕的多态性。当向量分量是复数时，客户端期望`Vector`的实现能够正常工作是完全合理的。一个实现如何能够预期并准备好处理数据类型的所有潜在用途呢？这种情况提出了一个不可能满足的设计挑战。我们所能做的就是警告您，尽可能检查您使用的任何数据类型是否能够处理您打算与之一起使用的数据类型。

* * *

## 重载

定义提供其自己的运算符定义的数据类型的能力是一种称为*运算符重载*的多态性形式。在 Python 中，您几乎可以重载每个运算符，包括算术、比较、索引和切片运算符。您还可以重载内置函数，包括绝对值、长度、哈希和类型转换。重载运算符和内置函数使用户定义的类型更像内置类型。

为执行操作，Python 内部将表达式转换为对应特殊方法的调用；要调用内置函数，Python 内部调用相应的特殊方法。要重载运算符或内置函数，您需要在自己的代码中包含相应特殊方法的实现。

### 算术运算符。

Python 为其每个算术运算符关联一个特殊方法，因此您可以通过实现相应的特殊方法来重载任何算术操作，详细��息请参见此表。

> ![算术运算的特殊方法](img/c23633d9f15ef3a334e80edd9533430d.png)

### 相等性。

![三个变量引用两个 Charge 对象](img/68c932f776df7152fe535677777e13c0.png) 用于测试相等性的`==`和`!=`运算符需要特别注意。例如，考虑右侧图中的代码，它创建了两个由三个变量`c1`、`c2`和`c3`引用的`Charge`对象。正如图中所示，`c1`和`c3`都引用相同的对象，这与`c2`引用的对象不同。显然，`c1 == c3`为`True`，但`c1 == c2`呢？对于这个问题的答案不明确，因为在 Python 中有两种思考相等性的方式：

*引用相等性*（*标识相等性*）。当两个引用相等时，它们指向同一个对象。内置函数`id()`给出对象的标识（其内存地址）；`is`和`is not`运算符测试两个变量是否引用同一个对象。也就是说，`c1 is c2`的实现测试`id(c1)`和`id(c2)`是否相同。在我们的例子中，`c1 is c3`如预期的那样是`True`，但`c1 is c2`是`False`，因为`c1`和`c2`位于不同的内存地址。

*对象相等性*（*值相等性*）。当两个对象相等时，它们具有相同的数据类型值。您应该使用`==`和`!=`运算符，这些运算符是使用特殊方法`__eq__()`和`__ne__()`定义的，用于测试对象的相等性。如果您没有定义`__eq__()`方法，那么 Python 会使用`is`运算符。也就是说，默认情况下，`==`实现引用相等性。因此，在我们之前的例子中，即使`c1`和`c2`具有相同的位置和电荷值，`c1 == c2`也是`False`。如果我们希望将具有相同位置和电荷值的两个电荷视为相等，则可以通过在 charge.py（来自第 3.2 节）中包含以下代码来确保这一结果：

```
    def __eq__(self, other):
        if self._rx != other._rx: return False
        if self._ry != other._ry: return False
        if self._q  != other._q:  return False
        return True
    def __ne__(self, other):
       return not __eq__(self, other)

```

有了这段代码，我们的例子中现在`c1 == c2`为 True。

### 哈希。

现在我们考虑与相等性测试相关的基本操作，称为*哈希*，它将对象映射到一个整数，称为*哈希码*。这个操作非常重要，Python 通过支持内置的`hash()`函数的特殊方法`__hash__()`来处理它。如果对象满足以下三个属性，则我们将对象称为`可哈希`：

+   通过`==`运算符，可以将对象与其他对象进行相等性比较。

+   每当两个对象比较相等时，它们具有相同的哈希码。

+   对象的哈希码在其生命周期中不会更改。

在典型应用中，我们使用哈希码将对象`x`映射到一个小范围内的整数，例如在 0 和`m`-1 之间，使用哈希函数

```
hash(x) % m

```

然后，我们可以使用哈希函数值作为整数索引到长度为`m`的数组中（请参阅本节后面描述的 sketch.py 程序和第 4.4 节中描述的 hashst.py 程序）。Python 的所有不可变数据类型（包括`int`、`float`、`str`和`tuple`）都是可哈希的，并且被设计为以合理的方式分布对象。

通过实现两个特殊方法`__hash__()`和`__eq__()`，你可以使用户定义的数据类型可哈希。设计一个良好的哈希函数需要科学和工程的巧妙结合，这超出了本书的范围。��反，我们在 Python 中描述了一个简单的方法，该方法在各种情况下都很有效：

+   确保数据类型是不可变的。

+   通过比较所有重要的实例变量来实现`__eq__()`。

+   通过将相同的实例变量放入元组并在元组上调用内置的`hash()`函数来实现`__hash__()`。

例如，以下是`Charge`数据类型（在 charge.py 中定义，来自第 3.2 节）的`__hash__()`实现，以配合我们刚刚考虑的`__eq__()`实现：

```
def __hash__(self):
    a = (self._rx, self._ry, self._q)
    return hash(a)

```

### 比较运算符。

同样，在 Python 中，像`x < y`和`x >= y`这样的比较不仅适用于整数、浮点数和字符串。再次，Python 为每个比较运算符关联了一个特殊方法，因此你可以通过实现相应的特殊方法来重载任何比较运算符，详细信息请参考下表：

> ![比较操作的特殊方法](img/2117176e80623b85b4db52e451bae6e8.png)

作为一种风格，如果你定义了任何一个比较方法，那么你应该以一致的方式定义所有这些方法。你可以通过实现六个特殊方法使用户定义的类型*可比较*，就像我们在 counter.py 中为`Counter`类所做的那样：

```
def __lt__(self, other): return self._count <  other._count
def __le__(self, other): return self._count <= other._count
def __eq__(self, other): return self._count == other._count
def __ne__(self, other): return self._count != other._count
def __gt__(self, other): return self._count >  other._count
def __ge__(self, other): return self._count >= other._count

```

### 其他运算符。

Python 中几乎每个运算符都可以被重载。如果你想重载一个运算符，你可以在[官方 Python 文档](https://docs.python.org/3/reference/datamodel.html)中找到相应的特殊方法。

### 内置函数。

我们一直在每个我们开发的类中重载内置函数`str()`，还有其他几个内置函数可以以相同的方式重载。我们在本书中使用的这些函数已总结在下表中。我们已经使用了所有这些函数，除了`iter()`，我们将在第 4.4 节中推迟使用。

> ![内置函数的特殊方法](img/0e4d725442ea235e5433c2e3af4a5f24.png)

* * *

## 函数是对象

在 Python 中，*一切*都是对象，包括函数。这意味着你可以将函数用作函数的参数并将它们作为结果返回。定义所谓的*高阶函数*，用于操作其他函数，在数学和科学计算中都很常见。

![近似积分](img/e8da3e02b82c92bb77b3cc50c8fbc541.png)

举个例子，考虑估计正实值函数*f*的*黎曼积分*（即曲线下的面积）的问题。也许最简单的方法是称为*矩形法*，在这种方法中，我们通过计算曲线下*n*个等宽矩形的总面积来近似积分的值。下面定义的`integrate()`函数评估了在区间(*a*, *b*)中实值函数*f*()的积分，使用*n*个矩形的矩形法：

```
def square(x):
    return x*x

def integrate(f, a, b, n=1000):
    total = 0.0
    dt = 1.0 * (b - a) / n
    for i in range(n):
        total += dt * f(a + (i + 0.5) * dt)
    return total

```

* * *

## 继承

Python 提供了定义类之间关系的语言支持，称为*继承*。软件开发人员广泛使用继承，因此如果你学习软件工程课程，你将详细学习它。有效使用继承超出了本书的范围，但我们在这里简要描述它，因为有一些情况下你可能会遇到它。

当正确使用时，继承使得一种称为*子类化*的代码重用成为可能。其思想是定义一个继承自另一个类（*超类*或*基类*）的新���（*子类*或*派生类），该子类继承自实例变量和方法。子类包含的方法比超类更多。系统程序员使用子类化来构建所谓的*可扩展*模块。其思想是一个程序员（甚至是您）可以向另一个程序员（或者可能是一组系统程序员）构建的类添加方法，有效地重用潜在庞大模块中的代码。这种方法被广泛使用，特别是在用户界面的开发中，以便可以重用提供用户所期望的所有功能所需的大量代码（下拉菜单、剪切和粘贴、访问文件等）。

尽管它有优点，但子类化的使用在系统程序员中是有争议的。我们在这个书站上没有使用它，因为它通常违反了封装。子类化使得模块化编程变得更加困难，原因有两个。首先，超类的任何更改都会影响所有子类。子类无法独立于超类开发；事实上，它完全依赖于超类。这个问题被称为*脆弱基类问题*。其次，子类代码可以破坏超类代码的意图，因为它可以访问实例变量。例如，类似`Vector`的类的设计者可能非常小心地使`Vector`不可变，但是子类可以访问实例变量，可以随意更改它们，给任何假设该类是不可变的客户端带来混乱。

* * *

## 应用：数据挖掘

为了在应用程序的背景下说明本节讨论的一些概念，我们接下来考虑一个在解决*数据挖掘*中令人生畏的挑战方面变得重要的软件技术，即搜索大量信息的过程。

为简单起见，我们将限制注意力在文本文档上（尽管我们将考虑的方法也适用于图片、音乐和各种其他文件）。即使有了这个限制，文档类型的多样性仍然显著。您可以在书站上找到这些文档的参考：

> ![一些文本文档](img/5631eebfd66ce4d49fe4dc7cb1e09df3.png)

我们的兴趣在于找到使用文件内容搜索的高效方法来表征文档。解决这个问题的一个富有成果的方法是为每个文档关联一个称为*草图*的向量，它是文档内容的超紧凑表示。基本思想是草图应该捕捉文档的显著统计特征，以便不同的文档具有“不同”的草图，相似的文档具有“相似”的草图。这些考虑导致了这个 API：

> ![草图 API](img/34024d9cc055209284bd15cb0d2e90c8.png)

构造函数的参数是一个字符串和两个控制草图质量的整数。客户端可以使用`similarTo()`来确定两个草图之间相似程度的范围，从 0（不相似）到 1（相似）。

### 计算草图。

计算文档的草图是第一个挑战。我们的第一个选择是使用`Vector`来表示文档的草图。我们的实现 sketch.py 使用了简单的频率计数方法。除了字符串外，构造函数还有两个参数，一个整数*k*和一个向量维度*d*。它扫描文档并检查文档中的所有*k*-gram — 即，从每个位置开始的长度为*k*的子字符串。在其最简单的形式中，草图是一个向量，给出了字符串中*k*-gram 出现的相对频率：为每个可能的*k*-gram 给出具有该值的文档中*k*-gram 的数量。

### 哈希。

在许多系统上，每个字符有 128 个不同的可能值，因此每个字符有 128*k*个可能的*k*-gram，简单方案中维度*d*将不得不是 128*k*。即使对于中等大小的*k*，这个数字也是不可接受的大。为了缓解这个问题，我们使用哈希，这是我们在本节前面考虑过的将对象映射到整数的基本操作。对于任何字符串`s`，`hash(s) % d`是一个介于 0 和`d`-1 之间的整数，我们可以将其用作数组的索引来计算频率。我们使用的草图是文档中所有*k*-gram 的��些值的频率定义的向量的方向（具有相同方向的单位向量）。sketch.py 中的测试客户端接受`k`和`d`作为命令行参数，并计算并写入从标准输入读取的文档的草图。尝试将标准输入重定向到文件 genome20.txt。

### 比较草图。

第二个挑战是计算两个草图之间的相似度。一个广泛使用的相似度度量称为*余弦相似度度量*。由于我们的草图是具有非负坐标的单位向量，它们的点积是介于 0 和 1 之间的数字。文件越相似，我们期望这个度量值越接近 1。sketch.py 中的`similarTo()`方法使用了这种方法。

### 比较所有配对。

程序 comparedocuments.py 是一个简单而有用的`Sketch`客户端，提供解决以下问题所需的信息：给定一组文档，找到最相似的两个文档。由于这个规范有点主观，程序会为所有文档对写入余弦相似度度量。程序接受命令行参数`k`和`d`，从标准输入读取文件名列表，并写入显示文件之间相似度度量的表格。尝试将标准输入重定向到 documents.txt，其中包含文件 constitution.txt、tomsawyer.txt、huckfinn.txt、prejudice.txt、djia.csv、amazon.html 和 actg.txt 的名称。

* * *

## 契约式设计

最后，我们简要讨论了 Python 语言机制，使您能够在程序运行时验证对程序的假设。

### 异常。

*异常*是程序运行时发生的中断性事件，通常用于表示错误。所采取的行动称为*引发异常*（或*错误*）。在学习编程过程中，我们已经遇到了 Python 标准模块引发的异常：`IndexError`和`ZeroDivisionError`是典型例子。您也可以引发自己的异常。最简单的一种是中断程序执行并写入错误消息的`Exception`：

```
raise Exception('Error message here.')

```

当异常对客户端有帮助时，使用异常是一个好的实践。例如，在 vector.py 中，如果要相加的两个`Vector`具有不同的维度，我们应该在`__add__()`中引发异常。为此，我们在`__add__()`的开头插入以下语句：

```
if len(self) != len(other):
    raise Exception('vectors have different dimensions')

```

### 断言。

*断言*是一个布尔表达式，你在程序中断言在那一点是`True`。如果表达式是`False`，程序将在运行时引发`AssertionError`。程序员使用断言来检测错误并增加对程序正确性的信心。断言还用于记录程序员的意图。例如，在 counter.py 中，我们可以通过在`increment()`的最后一条语句中添加以下断言来检查计数器永远不会为负：

```
assert self._count >= 0

```

这个声明会引起负计数的注意。您还可以添加一个可选的详细消息，例如

```
assert self._count >= 0, 'Negative count detected!'

```

以帮助识别错误。

默认情况下，断言是启用的，但你可以通过在命令行中使用带有 python 命令的`-O`（减号后跟一个大写字母“oh”）标志来禁用它们。（`O`代表“优化”）。断言仅用于调试；你的程序不应依赖断言进行正常操作，因为它们可能被禁用。

当使用*设计契约*模型时，数据类型的设计者表达了*前置条件*（客户在调用方法时承诺满足的条件）、*后置条件*（实现在从方法返回时承诺实现的条件）、*不变量*（实现在执行方法时承诺满足的任何条件）和*副作用*（方法可能引起的状态变化）。在开发过程中，这些条件可以通过断言进行测试。许多程序员在调试时会大量使用断言。

* * *

#### Q & A

**Q.** 为什么下划线约定不是 Python 的一部��（并受到强制执行）？

**A.** 很好的问题。

**Q.** 为什么要使用前导下划线？

**A.** 这只是许多例子之一，其中编程语言设计者遵循个人偏好，我们只能接受结果。幸运的是，你编写的大多数 Python 程序将是客户程序，不直接调用特殊方法或引用私有实例变量，因此它们不需要许多前导下划线。相对较少的 Python 程序员实现自己的数据类型（现在就是你），需要遵循下划线约定，但即使这些程序员可能会编写更多的客户端代码而不是类实现，所以从长远来看，下划线可能并不那么繁琐。

**Q.** complexpolar.py 中的`__mul__()`方法很笨拙，因为它创建了一个表示 0 + 0*i*的`Complex`对象，然后立即将其实例变量更改为所需的极坐标。如果我可以添加一个以极坐标为参数的第二个构造函数，设计会不会更好？

**A.** 是的，但我们已经有一个以矩形坐标为参数的构造函数。一个更好的设计可能是在 API 中有两个普通函数（而不是方法）`createRect(x, y)`和`createPolar(r, theta)`，它们创建并返回新对象。这种设计可能更好，因为它将为客户端提供切换到极坐标的能力。这个例子表明，在开发数据类型时考虑多种实现是一个好主意。当然，进行这样的更改需要增强所有现有实现和 API 的客户端，因此这种思考应尽早在设计过程中发生。

**Q.** 如何指定由零个项目或一个项目组成的元组？

**A.** 你可以分别使用`()`和`(1,)`。在第二个表达式中没有逗号，Python 会将其视为括号括起来的算术表达式。

**Q.** 如果我想使我的数据类型可比较，是否真的需要重载所有六个比较方法？

**A.** 是的。这是一个例子，其中约定为在实现中提供最大的灵活性，以换取额外的代码。通常，你可以利用对称性来减少实际的实现代码量。此外，Python 3 提供了一些快捷方式。例如，如果为数据类型定义了`__eq__()`方法，但没有定义`__ne__()`方法，那么 Python 会自动提供一个调用`__eq__()`并否定结果的实现。然而，Python 2 不提供这些快捷方式，因此最好不要在代码中依赖它们。

**Q.** 内置的`hash()`函数返回的整数值范围是多少？

**A.** 通常，Python 使用 64 位整数，因此范围在 -2⁶³ 和 2⁶³-1 之间。对于加密应用，应使用 Python 的 `hashlib` 模块，该模块支持支持更大范围的“安全”哈希函数。

**Q.** 哪些 Python 运算符不能被重载？

**A.** 在 Python 中，你不能重载

+   布尔运算符 `and`、`or` 和 `not`。

+   `is` 和 `is not` 运算符，用于测试对象标识。

+   字符串格式化运算符 `%`，仅适用于字符串。

+   赋值运算符 `=`.

* * *

#### 练习

1.  创建一个用于处理地球上位置的数据类型 `Location`，使用球面坐标（纬度/经度）。包括生成地球表面上的随机位置、解析位置“25.344 N, 63.5532 W”和计算两个位置之间的大圆距离的方法。

1.  创建一个三维粒子的数据类型，具有位置（*r*[*x*]、*r*[*y*]、*r*[*z*]）、质量 *m* 和速度 `(*v*[*x*]、*v*[*y*]、*v*[*z*])`。包括一个返回其动能的方法，等于 1/2 *m* (*v*[*x*]² + *v*[*y*]² + *v*[*z*]²)。使用在 vector.py 中定义的 `Vector` 数据类型。

1.  如果你了解物理学，请基于使用 *动量* (*p*[*x*]、*p*[*y*]、*p*[*z*]) 作为实例变量的上一个练习中的数据类型开发一个替代实现。

1.  开发一个 `Histogram` 类的实现，如第 3.2 节中定义的 histogram.py，使用 counter.py 中定义的 `Counter`。

1.  为 `Vector`（如 vector.py 中定义）实现一个 `__sub__()` 方法，用于计算两个向量的差。

    *解决方案*：

    ```
    def __sub__(self, other):
        return self + (other * -1.0)

    ```

    注意，`__sub__()` 调用 `__add__()` 和 `__mul__()`。这种实现的优点是限制了需要检查的详细代码量；缺点是可能效率低下。在这种情况下，`__add__()` 和 `__mul__()` 都会创建新的 `Vector` 对象，因此复制 `__add__()` 的代码并将减号替换为加号可能是更好的实现。

1.  为二维向量实现一个数据类型 `Vector2D`，其 API 与 `Vector` 相同（如 vector.py 中定义），只是构造函数接受两个浮点数作为参数。使用两个浮点数（而不是数组）作为实例变量。

1.  使用��个 `Complex` 对象作为唯一实例变量，实现上一个练习中的 `Vector2D` 数据类型。

1.  证明两个二维单位向量的点积是它们之间角度的余弦。

1.  为三维向量实现一个数据类型 `Vector3D`，其 API 与 `Vector` 相同，只是构造函数接受三个浮点数作为参数。此外，添加一个 *叉积* 方法：两个向量的叉积是另一个向量，由以下方程定义

    > | **a** × **b** = **c** &#124;**a**&#124; &#124;**b**&#124; sin θ |
    > | --- |

    其中 **c** 是垂直于 **a** 和 **b** 的单位法向量，θ 是 **a** 和 **b** 之间的角度。在笛卡尔坐标中，以下方程定义了叉积：

    > | (*a*[0]、*a*[1]、*a*[2]) × (*b*[0]、*b*[1]、*b*[2]) = (*a*[1] *b*[2] - *a*[2] *b*[1]、*a*[2] *b*[0] - *a*[0] *b*[2]、*a*[0] *b*[1] - *a*[1] *b*[0]) |
    > | --- |

    叉积出现在力矩、角动量和矢量算符旋度的定义中。此外，|**a** × **b**| 是以 **a** 和 **b** 为边的平行四边形的面积。

1.  你需要对 `Vector`（参见 vector.py）进行哪些修改（如果有的话）才能使其与 `Complex` 组件（参见 complex.py 第 3.2 节）或 `Rational` 组件（参见第 3.2 节中的“有理数”练习）一起工作？

1.  在 charge.py（第 3.2 节）中添加代码，使得 `Charge` 对象可通过电荷值确定顺序。

1.  编写一个函数`fibonacci()`，接受一个整数参数`n`并计算第`n`个斐波那契数。使用元组打包和解包。

1.  修改 euclid.py（来自第 2.3 节）中的`gcd()`函数，使其接受两个非负整数参数`p`和`q`，并返回一个整数元组（`d`、`a`、`b`），其中`d`是`p`和`q`的最大公约数，系数`a`和`b`满足贝祖等式：`d = a*p + b*q`。使用元组打包和解包。

    *解决方案*：这个算法被称为*扩展欧几里得算法*：

    ```
    def gcd(p, q):
        if q == 0: return (p, 1, 0)
        (d, a, b) = gcd(q, p % q)
        return (d, b, a - (p // q) * b)

    ```

1.  讨论 Python 设计中将内置类型 `bool` 设计为内置类型 `int` 的子类的优缺点。

1.  在`Counter`（如 counter.py 中定义）中添加代码，如果客户端尝试使用负值为`maxCount`创建`Counter`对象，则在运行时引发`ValueError`。

1.  使用异常开发`Rational`的实现（请参阅第 3.2 节中的“有理数”练习），如果分母为零，则在运行时引发`ValueException`。

* * *

#### 数据类型设计练习

*这组练习旨在让您有机会开发数据类型。对于每个问题，设计一个或多个 API，并通过实现典型客户端代码来测试您的设计决策。一些练习要求对特定领域的知识或在网络上搜索信息。*

1.  **统计**。开发一个用于维护一组浮点数统计信息的数据类型。提供一个添加数据点的方法和返回点数、均值、标准差和方差的方法。开发两种实现：一种实例值为点数、值的总和和值的平方和，另一种保留包含所有点的数组。为简单起见，您可以在构造函数中使用最大点数。您的第一个实现可能更快，占用的空间也更少，但也可能容易受到舍入误差的影响。

1.  **基因组**。开发一个用于存储生物体基因组的数据类型。生物学家通常将基因组抽象为核苷酸序列（A、C、G 或 T）。数据类型应支持`addCodon(c)`和`baseAt(i)`方法，以及`isPotentialGene()`（请参阅第 3.1 节中的 potentialgene.py）。开发三种实现。

    +   使用字符串作为唯一实例变量；使用字符串连接实现`addCodon()`。

    +   使用单个字符字符串数组作为唯一实例变量；使用`+=`运算符实现`addCodon()`。

    +   使用布尔数组，用两位编码每个碱基。

1.  **时间**。开发一个表示一天时间的数据类型。提供返回当前小时、分钟和秒的客户端方法，以及一个`__str__()`方法。开发两种实现：一种将时间保留为单个`int`值（从午夜开始的秒数），另一种保留三个`int`值，分别为秒、分钟和小时。

1.  **向量场**。开发一个表示二维力向量的数据类型。提供一个构造函数，一个用于添加两个向量的方法，以及一个有趣的测试客户端。

1.  **日期**。为日期（年、月、日）开发一个 API。包括比较两个日期的时间顺序、计算两个日期之间的天数、确定给定日期的星期几，以及客户端可能需要的任何其他操作。设计完 API 后，查看 Python 的`datetime.date`数据类型。

1.  **多项式**。开发一个具有整数系数的一元多项式数据类型，例如*x*³ + 5*x*² + 3*x* + 7。包括多项式的标准操作方法，如加法、减法、乘法、次数、求值、组合、微分、定积分和测试相等性。

1.  **有理多项式**。重复上一个练习，确保当提供`int`、`float`、`complex`和`Fraction`类型的系数时，多项式数据类型的行为是正确的（请参见第 3.2 节中的“有理数”练习）。

* * *

#### 创意练习

1.  **日历**。开发`Appointment`和`Calendar` API，可用于在日历年中跟踪约会（按天）。您的目标是使客户能够安排不冲突的约会，并向客户报告当前约会。使用 Python 的`datetime`模块。

1.  **矢量场**。矢量场将一个向量与欧几里得空间中的每一点相关联。编写一个版本的 potential.py（来自第 3.1 节），它以网格大小*n*作为输入，计算在*n*乘*n*的等间距点网格中每个点处由点电荷引起的势的`Vector`值，并在每个点处绘制指向累积场的单位矢量。

1.  **素描**。从书站选择一组有趣的文档（或使用您自己的集合），并使用各种命令行参数运行 comparedocuments.py，以了解它们对计算的影响。

1.  **多媒体搜索**。开发声音和图片的素描策略，并使用它们在计算机的音乐库中的歌曲和照片相册中发现有趣的相似之处。

1.  **数据挖掘**。编写一个递归程序，从给定为第一个命令行参数的页面开始浏览网页，并查找与给定为第二个命令行参数的页面相似的页面，方法如下。要处理一个名称，打开一个输入流，执行`readAll()`，进行素描，并在距离目标页面的距离大于作为第三个命令行参数给定的阈值时写入名称。然后扫描页面以查找所有包含子字符串`http://`的字符串，并（递归地）处理具有这些名称的页面。*注意*：此程序可能会读取大量页面！
