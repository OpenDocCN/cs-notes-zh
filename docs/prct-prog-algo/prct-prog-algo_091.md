# 2.2   归并排序

> 原文：[`algs4.cs.princeton.edu/22mergesort`](https://algs4.cs.princeton.edu/22mergesort)

我们在本节中考虑的算法基于一种简单的操作，称为*合并*：将两个有序数组组合成一个更大的有序数组。这个操作立即适用于一种简单的递归排序方法，称为*归并排序*：将数组分成两半，对这两半进行排序（递归），然后合并结果。

![归并排序](img/c0b4ef017f5f9b88384759a5bdc48df8.png)归并排序保证以与 N log N 成正比的时间对 N 个项目的数组进行排序���无论输入是什么。它的主要缺点是它使用与 N 成正比的额外空间。

## 抽象原地归并。

Merge.java 中的方法`merge(a, lo, mid, hi)`将子数组`a[lo..mid]`与`a[mid+1..hi]`的归并结果放入一个有序数组中，将结果留在`a[lo..hi]`中。虽然希望实现这种方法而不使用大量额外空间，但这样的解决方案非常复杂。相反，`merge()`将所有内容复制到辅助数组，然后再次归并到原始数组。![归并排序](img/9bdb45d8bf3aa3612a8cc8e66b82f9d0.png)

### 自顶向下的归并排序。

Merge.java 是基于这种抽象原地归并的递归归并排序实现。这是利用*分治*范式进行高效算法设计的最著名的例子之一。![归并排序](img/f781b3934b39bc4e24391d2ab9ec5d23.png)

### 命题。

自顶向下的归并排序使用 1/2 N lg N 和 N lg N 比较，并且最多需要 6 N lg N 次数组访问来对长度为 N 的任何数组进行排序。

### 改进。

通过对实现进行一些经过深思熟虑的修改，我们可以大大减少归并排序的运行时间。

+   *对小子数组使用插入排序。* 通过对待处理的小情况进行不同处理，我们可以改进大多数递归算法。对小子数组使用插入排序将使典型归并排序实现的运行时间提高 10 到 15％。

+   *测试数组是否已经有序。* 通过添加一个测试来跳过对`merge()`的调用，如果`a[mid]`小于或等于`a[mid+1]`，我们可以将已经有序的数组的运行时间减少为线性。通过这种改变，我们仍然执行所有递归调用，但对于任何已排序的子数组，运行时间是线性的。

+   *消除对辅助数组的复制。* 可以消除用于归并的辅助数组的复制时间（但不是空间）。为此，我们使用两次调用排序方法，一次从给定数组中获取输入并将排序后的输出放入辅助数组；另一次从辅助数组中获取输入并将排序后的输出放入给定数组。通过这种方法，在一些令人费解的递归技巧中，我们可以安排递归调用，使计算在每个级别切换输入数组和辅助数组的角色。

MergeX.java 实现了这些改进。

### 可视化。

MergeBars.java 提供了带有小子数组截止的归并排序可视化。![归并排序可视化](img/15858e5a89dce37051b2cd93e1103287.png)

### 自底向上的归并排序。

即使我们考虑将两个大子数组合并在一起，事实上大多数合并都是将微小的子数组合并在一起。 另一种实现归并排序的方法是组织合并，使我们在一次遍历中执行所有微小数组的合并，然后进行第二次遍历以成对合并这些数组，依此类推，直到进行涵盖整个数组的合并。 这种方法比标准递归实现需要更少的代码。 我们首先进行 1 对 1 的合并（将单个项目视为大小为 1 的子数组），然后进行 2 对 2 的合并（合并大小为 2 的子数组以生成大小为 4 的子数组），然后进行 4 对 4 的合并，依此类推。 MergeBU.java 是底部向上归并排序的实现。![底部向上的归并排序](img/376ddf6b3cbbadc8f4e2e30bfabd7670.png)

### 命题。

底部向上的归并排序使用了介于 1/2 N lg N 和 N lg N 次比较，以及最多 6 N lg N 次数组访问来对长度为 N 的任意数组进行排序。

### 命题。

没有基于比较的排序算法可以保证使用少于 lg(N!) ~ N lg N 次比较对 N 个项目进行排序。

### 命题。

归并排序是一种渐进最优的基于比较的排序算法。 也就是说，归并排序在最坏情况下使用的比较次数以及任何基于比较的排序算法可以保证的最小比较次数都是~N lg N。

#### 练习

1.  给出追踪，展示如何使用自顶向下的归并排序和自底向上的归并排序对键`E A S Y Q U E S T I O N`进行排序的方式。

    *解决方案。*

    > ![归并排序](img/371a6da248de01598053a1144bd08299.png)

1.  回答底部向上归并排序的练习 2.2.2。

    *解决方案。*

    > ![归并排序](img/121f0745c584416b0fc83890d211b3f8.png)

1.  如果抽象的原地合并仅在两个输入子数组按排序顺序排列时才产生正确的输出，那么是否正确？ 证明你的答案，或提供一个反例。

    *解决方案。* 是的。如果子数组按排序顺序排列，那么原地合并会产生正确的输出。 如果一个子数组未按排序顺序排列，则其条目将按照它们在输入中出现的顺序出现在输出中（与另一个子数组的条目交错）。

1.  给出自顶向下和自底向上归并排序算法在 n = 39 时每次合并后的子数组大小序列。

    *解决方案。*

    +   自顶向下的归并排序：2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39。

    +   底部向上的归并排序：2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39。查看代码 MergeSizes.java。

1.  假设自顶向下的归并排序修改为在`a[mid] <= a[mid+1]`时跳过对`merge()`的调用。 证明对于已排序顺序的数组，使用的比较次数是线性的。

    *解决方案。* 由于数组已经排序，不会调用`merge()`。 当 N 是 2 的幂时，比较次数将满足递归 T(N) = 2 T(N/2) + 1，其中 T(1) = 0。

1.  在库软件中使用类似 aux[]的静态数组是不明智的，因为多个客户端可能同时使用该类。给出一个不使用静态数组的 Merge.java 实现。

#### 创造性问题

1.  **更快的合并。** 实现一个`merge()`的版本，将`a[]`的后半部分以*递减顺序*复制到`aux[]`，然后将其合并回`a[]`。 这个改变允许你从内部循环中删除测试每个半部分是否已耗尽的代码。 *注意*：结果排序不是稳定的。

    ```java
    private static void merge(Comparable[] a, int lo, int mid, int hi) { 
       for (int i = lo; i <= mid; i++)
          aux[i] = a[i]; 

       for (int j = mid+1; j <= hi; j++)
          aux[j] = a[hi-j+mid+1];

       int i = lo, j = hi; 
       for (int k = lo; k <= hi; k++) 
          if (less(aux[j], aux[i])) a[k] = aux[j--];
          else                      a[k] = aux[i++];
    } 

    ```

1.  **改进。** 编写一个程序 MergeX.java，实现文本中描述的三个归并排序改进：添加对小子数组的截止，测试数组是否已经有序，通过在递归代码中切换参数来避免复制。

1.  **逆序数。** 开发并实现一个线性对数算法 Inversions.java，用于计算给定数组中的逆序数（插入排序为该数组执行的交换次数—参见第 2.1 节）。这个数量与 *Kendall tau 距离* 有关；参见第 2.5 节。

1.  **索引排序。** 开发一个版本的 Merge.java，该版本不重新排列数组，而是返回一个 `int[] perm`，使得 `perm[i]` 是数组中第 i 小的条目的索引。

#### 实验

#### 网络练习

1.  **每个项最多进行 log N 次比较的归并。** 设计一个合并算法，使得每个项最多比较对数次数。 （在标准合并算法中，当合并大小为 N/2 的两个子数组时，一个项可以比较 N/2 次。）

    [参考链接](http://www.reddit.com/comments/9jqsi/how_to_merge_sorted_lists_with_olog_n_comparisons/)

1.  **对于排序 Young 表格的下界。** 一个 *Young 表格* 是一个 N×N 矩阵，使得条目在列和行上都是有序的。证明对于排序 N² 个条目（只能通过成对比较访问数据）需要 Theta(N² log N) 次比较。

    *解决方案概述*。如果条目 (i, j) 在 i + j 的 1/2 范围内，则所有 2N-1 个网格对角线彼此独立。对对角线进行排序需要 N² log N 次比较。

1.  给定一个大小为 2N 的数组 `a`，其中前 N 个项按升序排列在位置 0 到 N-1，以及一个大小为 N 的数组 `b`，其中 N 个项按升序排列，将数组 `b` 合并到数组 `a` 中，使得 `a` 包含所有项按升序排列。使用 O(1) 额外内存。

    *提示*：从右向左合并。

1.  **k-近排序。** 假设你有一个包含 N 个不同项的数组 `a[]`，几乎是有序的：每个项最多离其在排序顺序中的位置不超过 k 个位置。设计一个算法，在时间复杂度为 N log k 的情况下对数组进行排序。

    *提示*：首先，对从 0 到 2k 的子数组进行排序；最小的 k 个项将处于正确的位置。接下来，对从 k 到 3k 的子数组进行排序；最小的 2k 个项现在将处于正确的位置。

1.  找到一组输入，对于这组输入，归并排序比对包含 N 个不同键的数组进行排序时的比较次数严格少于 1/2 N lg N。

    *解决方案*：一个 N = 2^k + 1 个键的逆序排序数组使用大约 1/2 N lg N - (k/2 - 1) 次比较。

1.  **最坏情况的输入数组。** 编写一个程序 MergeWorstCase.java，该程序接受一个命令行参数 *n*，并创建一个长度为 *n* 的输入数组，使得归并排序进行最大数量的比较。

1.  编写一个程序 SecureShuffle.java，从标准输入中读取一系列字符串并进行安全洗牌。使用以下算法：将每张卡片与一个介于 0 和 1 之间的随机实数关联起来。根据其关联的实数对值进行排序。使用 `java.security.SecureRandom` 生成随机实数。使用 `Merge.indexSort()` 获取随机排列。

1.  **合并两个不同���度的数组。** 给定大小为 M 和 N 的两个有序数组 `a[]` 和 `b[]`，其中 M ≥ N，设计一个算法将它们合并成一个新的有序数组 `c[]`，使用 ~ N lg M 次比较。

    *提示*：使用二分查找。

    *注意*：存在一个 [下界](http://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/recis/rec10.pdf) 为 Omega(N log (1 + M/N)) 次比较。这是因为有 M+N 个 N 个可能的合并结果。决策树论证表明，这至少需要 lg (M+N 个 N) 次比较。我们注意到 n 个 r 个选择 >= (n/r)^r。

1.  **合并三个数组。** 给定大小为 N 的三个有序数组 `a[]`、`b[]` 和 `c[]`，设计一个算法将它们合并成一个新的有序数组 `d[]`，在最坏情况下最多使用 ~ 6 N 次比较（或者，更好地说，~ 5 N 次比较）。

1.  **合并三个数组。** 给定三个大小为 N 的排序数组 `a[]`、`b[]` 和 `c[]`，证明没有基于比较的算法可以在最坏情况下使用少于 ~ 4.754887503 N 次比较将它们合并成一个新的排序数组 `d[]`。

1.  **具有 N^(3/2)逆序对的数组。** 证明任何基于比较的算法，可以对具有 N^(3/2)或更少逆序对的数组进行排序，在最坏情况下必须进行 ~ 1/2 N lg N 次比较。

    *证明概要*：将数组分成 sqrt(N) 个连续的子数组，每个子数组有 sqrt(N) 个项目，使得不同子数组之间没有逆序对，但每个子数组内的项目顺序是任意的。这样的数组最多有 N^(3/2) 个逆序对——每个 sqrt(N) 子数组中最多有 ~N/2 个逆序对。根据排序的下界，对每个子数组进行排序需要 ~ sqrt(N) lg sqrt(N) 次比较，总共需要 ~ 1/2 N lg N 次比较。

1.  **最优非遗忘排序。** 设计算法，使用最少的比较次数（在最坏情况下）对长度为 3、4、5、6、7 和 8 的数组进行排序。

    *解决方案。* 已知最优解使用 3、5、7、10、13 和 16 次比较，分别。已知 [Ford-Johnson](http://www.mat.unb.br/~ayala/4FordJohnson.ps) 合并插入算法对于 n <= 13 是最优的。在最坏情况下，它需要进行 sum(ceil(log2), k=1..n) 次比较。
