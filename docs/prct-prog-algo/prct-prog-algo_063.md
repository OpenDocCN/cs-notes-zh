# 1.4 数组

> 原文：[`introcs.cs.princeton.edu/python/14array`](https://introcs.cs.princeton.edu/python/14array)

*数据结构*是一种组织我们希望用计算机程序处理的数据的方式。*一维数组*（或*数组*）是一种存储对象序列（引用）的数据结构。我们将数组中的对象称为其*元素*。我们用来引用数组中的元素的方法是*编号*，然后*索引*它们。如果我们有* n *个元素在序列中，我们认为它们从 0 到* n *-1 编号。然后，我们可以通过引用该范围内的任何整数*i*的第*i*个元素来明确指定其中的一个。

*二维数组*是一个（引用）一维数组的数组。一维数组的元素由单个整数索引，而二维数组的元素由一对整数索引：第一个指定行，第二个指定列。

* * *

## Python 中的数组

在 Python 中创建数组的最简单方法是在匹配的方括号之间放置逗号分隔的文字。例如，代码

```py
SUITS = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
x = [0.30, 0.60, 0.10]
y = [0.50, 0.10, 0.40]

```

创建一个包含四个字符串的数组`SUITS[]`，并创建包含三个浮点数的数组`x[]`和`y[]`。

给定相同长度的两个向量，它们的*点积*是它们对应分量的乘积之和。如果我们将两个向量表示为长度为 n 的一维数组`x[]`和`y[]`，它们的点积很容易计算：

```py
total = 0.0
for i in range(n):
    total += x[i]*y[i]

```

例如，以下跟踪显示了计算长度为 3 的两个向量的点积。

> ![](img/e114ab4627575c0526ed48dbadceb1b9.png)

![数组数据结构](img/200f6a897c59649a78a6e9fd1bfe9574.png)

将数组中元素的引用连续存储在计算机内存中，如上图所示，对于上面定义的`SUITS[]`数组。

### 基于零的索引。

我们总是将数组 a[]的第一个元素称为 a[0]，第二个称为 a[1]，依此类推。可能更自然的是将第一个元素称为 a[1]，第二个元素称为 a[2]，依此类推，但从 0 开始索引有一些优势，并且已经成为大多数现代编程语言使用的约定。

### 数组长度。

您可以使用 Python 内置的`len()`函数访问数组的长度：`len(a)`是`a[]`中元素的数量。在 Python 中，我们可以使用`+=`运算符将元素附加到数组。例如，如果`a[]`是数组`[1, 2, 3]`，那么语句`a += [4]`将其扩展为`[1, 2, 3, 4]`。更一般地，我们可以使用以下代码创建一个包含`n`个浮点数的数组，其中每个元素初始化为`0.0`，

```py
a = []
for i in range(n):
    a += [0.0]

```

### 边界检查。

在使用数组编程时必须小心。在访问数组元素时使用合法索引是您的责任。

### 可变性。

如果一个对象是*可变*的，那么它的值可以改变。数组是可变对象，因为我们可以改变它们的元素。例如，如果我们用代码`x = [.30, .60, .10]`创建一个数组，那么赋值语句`x[1] = .99`将把它改变为数组`[.30, .99, .10]`。这个操作的对象级跟踪显示在右侧。

以下代码颠倒了数组 a[]中元素的顺序：

```py
n = len(a)
for i in range(n // 2):
    temp = a[i]
    a[i] = a[n-1-i]
    a[n-1-i] = temp

```

对于一个包含七个元素的数组`[3, 1, 4, 1, 5, 9, 2]`，这段代码的非正式跟踪显示在右侧。

### 迭代。

以下代码遍历数组的所有元素以计算其中包含的浮点数的平均值：

```py
total = 0.0
for i in range(len(a)):
    total += a[i]
average = total / len(a)

```

Python 还支持在不显式引用索引的情况下迭代数组中的元素。为此，在`for`语句中的`in`关键字后放置数组名称，如下所示：

```py
total = 0.0
for v in a:
    total += v
average = total / len(a)

```

### 内置函数。

Python 有几个可以接受数组作为参数的内置函数。我们已经讨论了`len()`函数。举个例子，如果`a[]`的元素是数字，那么`sum(a)`会计算它们的和，因此我们可以使用`float(sum(a)) / len(a)`来计算它们的平均值，而不是使用刚刚描述的任何一个循环。其他有用的可以接受数组作为参数的内置函数有用于计算最小值的`min()`和用于计算最大值的`max()`。

### 写入数组。

你可以通过将数组作为参数传递给`stdio.write()`或`stdio.writeln()`来写入数组。数组中的每个对象都会被转换为一个字符串。

* * *

## 数组别名和复制

在查看使用数组的程序之前，值得更详细地研究两个基本的数组处理操作。

### 别名。

![数组别名](img/46ee1209f80c593e59c1b862423f3922.png)如果`x[]`和`y[]`是数组，则语句`x = y`会导致`x`和`y`引用同一个数组。这个结果可能一开始会让人感到意外，因为自然而然地会认为`x`和`y`是指向两个独立数组的引用。例如，在赋值语句之后

```py
x = [.30, .60, .10]
y = x
x[1] = .99

```

`y[1]`也是`.99`，即使代码没有直接引用`y[1]`。这种情况——当两个变量引用同一个对象时——被称为*别名*，并在右侧的对象级别跟踪中进行了说明。

### 复制和切片。

![](img/4e1ce3311743e66750be1e765eac2cd0.png)那么我们如何复制给定数组`x[]`的副本`y[]`？对于这个问题的一个答案是通过遍历`x[]`来构建`y[]`，就像以下代码中所示：

```py
y = []
for v in x:
    y += [v] 

```

这种情况在右侧的对象级别跟踪中进行了说明。

复制数组是一个非常有用的操作，Python 为更一般的操作提供了语言支持，称为*切片*，表达式`a[i:j]`评估为一个新数组，其元素为`a[i], ..., a[j-1]`。此外，`i`的默认值为 0，`j`的默认值为`len(a)`，因此`y = x[:]`等同于前面给出的代码。

* * *

## 数组的系统支持

用于处理数组的 Python 代码可以采用多种形式。我们简要描述每种形式以便理解上下文。

### Python 内置的`list`数据类型。

在其最基本的形式中，数组支持四个核心操作：创建、索引访问、索引赋值和迭代。在这个书站中，我们使用 Python 的内置`list`数据类型来表示数组，因为它支持这些基本操作。我们将在第四章中考虑 Python 的`list`数据类型支持的更复杂的操作。

### Python 的`numpy`模块。

Python 内置的`list`数据类型可能会存在严重的性能问题。因此，科学家和工程师经常使用一个名为`numpy`的 Python 扩展模块来处理大量的数字数组，因为该模块使用了一个避免了标准 Python 表示中许多低效的表示的底层表示。请参阅附录：`numpy`以获取`numpy`模块的概述。

### 我们的`stdarray`模块。

之前我们介绍了书站`stdio`模块。现在，我们介绍另一个书站模块：`stdarray`模块。它的主要目的是定义用于处理数组的函数。

几乎每个数组处理程序中都会找到的一个基本操作是创建一个包含*n*个元素的数组，每个元素都初始化为给定值。正如我们所见，你可以使用类似以下代码在 Python 中实现这一点：

```py
a = []
for i in range(n):
    a += [0.0]

```

这样的代码是如此常见，以至于 Python 甚至为其提供了一个特殊的简写表示法：代码`a = [0.0]*n`等同于刚刚给出的代码。为了避免在整本书中重复这样的代码，我们将使用类似这样的代码：

```py
a = stdarray.create1D(n, 0.0)

```

为了保持一致，`stdarray`还包括一个`create2D()`函数，我们将在本节稍后讨论。

> ![Stdarray API](img/2cc2d66e674cfef0900458c157bd23f2.png)

* * *

## 数组的示例应用

接下来，我们考虑一些应用程序，这些应用程序说明了数组的实用性，并且本身也很有趣。

### 表示扑克牌。

假设我们想要编写处理扑克牌的程序。我们可能从以下代码开始：

```py
SUITS = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10',
         'Jack', 'Queen', 'King', 'Ace']

```

例如，我们可以使用这两个数组来编写一个随机的卡片名称，比如`梅花皇后`，如下所示：

```py
rank = random.randrange(0, len(RANKS))
suit = random.randrange(0, len(SUITS))
stdio.writeln(RANKS[rank] + ' of ' + SUITS[suit])

```

更典型的情况是当我们计算要存储在数组中的值时。例如，我们可以使用以下代码初始化一个长度为 52 的数组，表示一副扑克牌，使用刚刚定义的两个数组：

```py
deck = []
for rank in RANKS:
    for suit in SUITS:
        card = rank + ' of ' + suit
        deck += [card]

```

### 交换。

经常情况下，我们希望在数组中交换两个元素。继续我们的扑克牌示例，以下代码交换索引`i`和`j`处的卡片：

```py
temp = deck[i]
deck[i] = deck[j]
deck[j] = temp

```

### 洗牌

。以下代码洗牌我们的牌组：

```py
n = len(deck)
for i in range(n):
    r = random.randrange(i, n)
    temp = deck[r]
    deck[r] = deck[i]
    deck[i] = temp

```

从左到右进行，我们从 deck[i]到 deck[n-1]中随机选择一张卡片（每张卡片等概率），并将其与 deck[i]交换。

### 无放回抽样。

在许多情况下，我们希望从一个集合中随机抽取一个样本，以便集合中的每个元素在样本中最多出现一次。程序 sample.py 接受命令行参数`m`和`n`，并创建一个大小为`n`的排列，其中前`m`个元素构成一个随机样本。

### 预先计算的值。

数组的另一个应用是保存您已计算的值以供以后使用。例如，假设您正在编写一个使用调和数小值进行计算的程序。一种高效的方法是将这些值保存在数组中，如下所示：

```py
harmonic = stdarray.create1D(n+1, 0.0)
for i in range(1, n+1):
    harmonic[i] = harmonic[i-1] + 1.0/i 

```

请注意，我们在数组中浪费了一个槽位（元素 0），以使 harmonic[1]对应于第一个调和数 1.0，而 harmonic[i]对应于第 i 个调和数。如果我们需要大量 n 的值，这种方法并不有效，但如果我们需要多次获取小 n 的值，这种方法非常有效。

### 简化重复代码。

作为数组的另一个简单应用的例子，考虑以下代码片段，根据月份的数字（1 代表一月，2 代表二月，依此类推）写出月份的名称：

```py
if   m ==  1: stdio.writeln('Jan')
elif m ==  2: stdio.writeln('Feb')
elif m ==  3: stdio.writeln('Mar')
elif m ==  4: stdio.writeln('Apr')
...
elif m == 11: stdio.writeln('Nov')
elif m == 12: stdio.writeln('Dec')

```

更紧凑的替代方案是使用一个包含月份名称的字符串数组：

```py
MONTHS = ['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
...
stdio.writeln(MONTHS[m])

```

如果您需要在程序中的多个不同位置通过其数字访问月份的名称，这种技术将特别有用。请注意，我们故意浪费了数组中的一个槽位（元素 0），以使`MONTHS[1]`对应于一月，如所需。

![](img/bdc96ebdc3d0e502cb98eccdc7cbd430.png)

### 收集优惠券。

假设你有一副牌，并且你逐个随机选择卡片（有放回地）。在你看到每种花色之前，你需要翻开多少张卡片？这是著名的*收集优惠券*问题的一个例子。一般来说，假设一个交易卡公司发行了具有 n 种不同可能卡片的交易卡：在你收集到所有 n 种可能性之前，你需要收集多少张卡片，假设每张卡片收集时每种可能性都是等概率的？程序 couponcollector.py 是一个模拟这一过程的示例程序。详细信息请参阅教科书。

### 埃拉托斯特尼筛法。

素数计数函数*π*(*n*)是小于或等于*n*的素数的数量。例如*π*(17) = 7，因为前七个素数是 2、3、5、7、11、13 和 17。程序 primesieve.py 接受一个命令行整数 n，并使用[埃拉托斯特尼筛法](http://mathworld.wolfram.com/SieveofEratosthenes.html)计算*π*(*n*)。详细信息请参阅教科书。

* * *

## 二维数组

![](img/c7dde38383471de0cf1aa29eec1f8ccb.png)

在许多应用中，存储信息的一种便捷方式是使用一个以矩形表格组织的数字表，并引用表中的行和列。对应于这种表格的数学抽象是*矩阵*；相应的数据结构是*二维数组*。

### 初始化。

创建二维数组的最简单方法是在匹配的方括号之间放置逗号分隔的一维数组。例如，以下具有两行三列的整数矩阵

```py
18 19 20
21 22 23

```

可以使用以下数组表示在 Python 中：

```py
a = [[18, 19, 20], [21, 22, 23]]

```

我们称这样的数组为*2 乘 3*数组。更一般地，Python 将*m*乘*n*数组表示为包含*m*个对象的数组，每个对象都是包含*n*个对象的数组。例如，以下 Python 代码创建了一个浮点数的*m*乘*n*数组`a[][]`，其中所有元素都初始化为 0.0：

```py
a = []
for i in range(m):
    row = [0.0] * n
    a += [row]

```

对于一维数组，我们在整个本站使用了自描述的替代方案`stdarray.create2D(m, n, 0.0)`，该方案来自我们的本站模块`stdarray`。

### 索引。

当`a[][]`是一个二维数组时，语法`a[i]`表示对其第`i`行的引用。语法`a[i][j]`指的是第`i`行和第`j`列的对象。为了访问二维数组中的每个元素，我们使用两个嵌套的`for`循环。例如，以下代码将*m*乘*n*数组`a[][]`的每个对象写入，每行一个。

```py
for i in range(m):
    for j in range(n):
        stdio.write(a[i][j])
        stdio.write(' ')
    stdio.writeln()

```

该代码实现了相同的效果，而不使用索引：

```py
for row in a:
    for v in row:
        stdio.write(v)
        stdio.write(' ')
    stdio.writeln()

```

![](img/df81a47071dbd1e5ced8f4147b806b14.png)

### 矩阵操作。

在科学和工程中的典型应用涉及将矩阵表示为二维数组，然后使用矩阵操作数实现各种数学运算。例如，我们可以如下*相加*两个*n*乘*n*的矩阵`a[][]`和`b[][]`：

```py
c = stdarray.create2D(n, n, 0.0) 
for i in range(n):
    for j in range(n):
        c[i][j] = a[i][j] + b[i][j]

```

同样，我们可以*相乘*两个矩阵。矩阵`a[][]`和`b[][]`的乘积中每个元素`c[i][j]`是通过计算`a[][]`的第`i`行与`b[][]`的第`j`列的点积得到的。

```py
c = stdarray.create2D(n, n, 0.0) 
for i in range(n):
    for j in range(n):
        # Compute the dot product of row i and column j
        for k in range(n):
            c[i][j] += a[i][k] * b[k][j]

```

### 不规则数组。

事实上，并不要求二维数组中的所有行具有相同的长度。行长不一的数组称为*不规则数组*。不规则数组的可能性需要在编写数组处理代码时更加小心。例如，以下代码写入了一个不规则数组的内容：

```py
for i in range(len(a)):
    for j in range(len(a[i])):
        stdio.write(a[i][j])
        stdio.write(' ')
    stdio.writeln()

```

请注意，不使用索引的等效代码对于矩形数组和不规则数组同样有效：

```py
for row in a:
    for v in row:
        stdio.write(v)
        stdio.write(' ')
    stdio.writeln()

```

### 多维数组。

相同的表示法扩展到允许我们��用任意维数的数组来组合代码。使用数组的数组的数组...，我们可以创建三维数组、四维数组等，然后使用诸如`a[i][j][k]`的代码引用单个元素。

### 示例：避免自我随机漫步。

程序 selfavoid.py 是将二维数组应用于化学的一个示例。有关详细信息，请参阅教科书。

* * *

#### 问与答

**问：** 为什么 Python 字符串和列表的索引从 0 开始而不是从 1 开始？

**答：** 这种约定起源于机器语言编程，其中计算数组元素的地址是通过将索引加到数组开头的地址来完成的。从 1 开始的索引要么会导致在数组开头浪费空间，要么会浪费时间来减去 1。这里是[Edsger Dijkstra 的解释](http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF)。

**问：** 如果我使用负整数索引数组会发生什么？

**答：** 答案可能会让你惊讶。给定一个数组`a[]`，您可以使用索引`-i`作为`len(a)-i`的简写。例如，您可以用`a[-1]`或`a[len(a)-1]`引用数组中的最后一个元素，用`a[-len(a)]`或`a[0]`引用第一个元素。如果您使用范围在`-len(a)`到`len(a)-1`之外的索引，Python 会在运行时引发`IndexError`。

**问：** 为什么切片`a[i:j]`包括`a[i]`但不包括`a[j]`？

**答：** 这种表示法与使用`range()`定义的范围一致，其中包括左端点但不包括右端点。它导致一些吸引人的特性：`j-i`是子数组的长度（假设没有截断）；`a[0:len(a)]`是整个数组；`a[i:i]`是空数组；`a[i:j] + a[j:k]`是子数组`a[i:k]`。

**Q.** 当我用`(a == b)`比较两个数组`a[]`和`b[]`时会发生什么？

**A.** 这取决于情况。对于数字数组（或多维数组），它的工作方式如你所期望的：如果每个数组具有相同的长度且对应元素相等，则数组相等。

**Q.** 当随机漫步不避免自身时会发生什么？

**A.** 这种情况很容易理解。这是一个二维版本的赌徒破产问题，如 1.3 节所述。

**Q.** 使用数组时应该注意哪些陷阱？

**A.** 记住，创建数组所需的时间与数组的长度成正比。在循环内创建数组时要特别小心。

* * *

#### 练习

1.  编写一个程序，创建一个包含恰好 1000 个整数的一维数组`a`，然后尝试访问`a[1000]`。运行程序时会发生什么？

1.  给定用一维数组表示的长度为`n`的两个向量，编写一个代码片段，计算它们之间的*欧几里德距离*（对应元素之间差的平方和的平方根）。

1.  编写一个代码片段，反转一个浮点数一维数组的顺序。不要创建另一个数组来保存结果。*提示*：使用本网页早期提供的代码交换两个元素。

    *解决方案*：

    > ```py
    > n = len(a)
    > for i in range(n//2):
    >     temp = a[n-i-1]
    >     a[n-i-1] = a[i]
    >     a[i] = temp
    > 
    > ```

1.  以下代码片段有什么问题？

    ```py
    a = []
    for i in range(10):
        a[i] = i * i

    ```

    *解决方案*：最初`a`是空数组。随后没有元素附加到数组中。因此，`a[0]`，`a[1]`等等不存在。在赋值语句中尝试使用它们将在运行时引发`IndexError`。

1.  编写一个代码片段，使用`*`表��`True`，空格表示`False`，写出一个布尔值的二维数组的内容。包括行号和列号。

1.  以下代码片段写出了什么？

    ```py
    a = stdarray.create1D(10, 0)
    for i in range(10):
       a[i] = 9 - i
    for i in range(10):
       a[i] = a[a[i]]
    for v in a:
       stdio.writeln(v)

    ```

1.  执行以下代码片段后`a[]`是什么？

    ```py
    n = 10
    a = [0, 1]
    for i in range(2, n):
        a += [a[i-1] + a[i-2]]

    ```

1.  编写一个程序，从命令行参数`n`中接受一个整数，并从洗牌后的牌组中写出`n`个扑克手（每个五张牌），用空行分隔。

    *解决方案*：参见 deal.py。

1.  编写代码片段创建一个二维数组`b[][]`，它是现有二维数组`a[][]`的副本，在以下每种假设下：

    1.  `a`是方阵的。

    1.  `a`是矩形的。

    1.  `a`可能是不规则的。

    你对(b)的解决方案应该适用于(a)，你对(c)的解决方案应该适用于(b)和(a)。

1.  编写一个代码片段，写出一个二维数组的*转置*（行和列交换）。例如，给定这个整数二维数组：

    ```py
    99 85 98
    98 57 78
    92 77 76
    94 32 11
    99 34 22
    90 46 54
    76 59 88
    92 66 89
    97 71 24
    89 29 38

    ```

    你的代码应该写出这个：

    ```py
    99  98  92  94  99  90  76  92  97  89
    85  57  77  32  34  46  59  66  71  29
    98  78  76  11  22  54  88  89  24  38

    ```

1.  编写一个代码片段，就地转置一个方阵二维数组`b[][]`，而不创建第二个数组。

    *解决方案*。参见 transpose.py。

1.  编写一个代码片段，创建一个二维数组`b[][]`，它是现有*m*乘*n*数组`a[][]`的转置。

1.  编写一个程序，计算两个布尔值方阵的乘积，使用`or`操作代替`+`，使用`and`操作代替`*`。

1.  编写一个程序，从命令行接受一个整数*n*，创建一个*n*乘*n*的布尔数组`a`，使得`a[r][c]`为`True`，如果`r`和`c`是互质的（除了 1 没有其他公因数），否则为`False`。然后使用`*`表示`True`，空格表示`False`写出数组（参见书站本节中的先前练习）。包括行号和列号。*提示*：使用筛法。

1.  编写一个代码片段，用于乘法计算两个不一定是方阵的浮点数矩阵。*注意*：为了使点积有明确定义，第一个矩阵的列数必须等于第二个矩阵的行数。如果维度不满足此条件，请写出错误消息。

1.  修改 selfavoid.py 以计算并写入路径的平均长度以及死胡同的概率。保持逃逸路径和死胡同路径的平均长度分开。

1.  修改 selfavoid.py 以计算并写入包围路径的最小轴向矩形的平均面积。为逃逸路径和死胡同路径保持统计数据分开。

#### 创意练习

1.  **骰子模拟。** ���下代码计算两个骰子点数之和的精确概率分布：

    > ```py
    > probabilities = stdarray.create1D(13, 0.0)
    > 
    > for i in range(1, 7):
    >     for j in range(1, 7):
    >         probabilities[i+j] += 1.0
    > 
    > for k in range(2, 13):
    >     probabilities[k] /= 36.0
    > 
    > ```

    在此代码完成后，`probabilities[k]` 是骰子点数为 `k` 的概率。运行实验验证这个计算，模拟 *n* 次掷骰子，跟踪每个值出现的频率，当你计算两个介于 1 和 6 之间的随机整数的和时。在你的经验结果与精确结果匹配到小数点后三位之前，*n* 必须有多大？

1.  **最长高原。** 给定一个整数数组，编写一个程序，找到最长连续相等值序列的长度和位置，其中该序列前后的元素值较小。

1.  **经验洗牌检查。** 运行计算实验以检查我们的洗牌代码是否按照广告宣传的那样工作。编写一个程序，接受整数命令行参数 *m* 和 *n*，对一个大小为 *m* 的数组进行 *n* 次洗牌，每次初始化为 `a[i] = i`，并写入一个 *m*×*m* 的表，其中第 `i` 行给出了 `i` 最终在所有 `j` 位置上出现的次数。数组中的所有条目应接近于 *n*/*m*。

1.  **糟糕的洗牌。** 假设在我们的洗牌代码中选择一个介于 0 和 *n*-1 之间的随机整数，而不是介于 `i` 和 `n-1` 之间的随机整数。证明所得到的顺序不可能是 *n*! 种可能性之一。对这个版本运行上一个练习的测试。

    *部分解决方案*：当 *n* = 3 时，有 3! = 6 种可能性，但有些更有可能：

    > | ABC | ACB | BAC | BCA | CAB | CBA |
    > | --- | --- | --- | --- | --- | --- |
    > | 4/27 | 5/27 | 6/27 | 4/27 | 5/27 | 3/27 |

1.  **音乐洗牌。** 你将音乐播放器设置为随机模式。它在重复任何歌曲之前播放 *n* 首歌曲。编写一个程序来估计你不会听到任何连续一对歌曲的可能性（即，歌曲 3 不会跟在歌曲 2 后面，歌曲 10 不会跟在歌曲 9 后面，依此类推）。

1.  **排列中的极小值。** 编写一个程序，从命令行接受一个整数 *n*，生成一个随机排列，写入排列，并写入排列中从左到右的极小值的数量（元素是迄今为止看到的最小值的次数）。然后编写一个程序，从命令行接受整数 *m* 和 *n*，生成大小为 *n* 的 *m* 个随机排列，并写入所生成排列中从左到右的极小值的平均数量。*额外奖励*：提出一个关于大小为 *n* 的排列中从左到右的极小值数量的假设，作为 *n* 的函数。

1.  **逆排列。** 编写一个程序，从 *n* 个命令行参数中接受整数范围为 0 到 *n*-1 的排列，并写入其逆排列。（如果排列是一个数组 `a[]`，其逆排列是数组 `b[]`，使得 `a[b[i]]` = `b[a[i]]` = `i`。）确保检查输入是否是有效的排列。

    *解决方案*：参见 inversepermutation.py。

1.  **哈达玛矩阵。** *n*×*n* 哈达玛矩阵 *H[n]* 是一个布尔矩阵，具有显著的特性，即任意两行在恰好 *n*/2 个元素上不同。（这个特性使其在设计*纠错码*时非常有用。）*H*[1] 是一个 1×1 的矩阵，其中单个元素为 `True`，对于 *n* > 1，*H*[2*n*] 是通过将四个 *H[n]* 的副本对齐在一个大正方形中获得的，然后反转右下角的所有元素，如下例所示（其中 `T` 代表 `True`，`F` 代表 `False`，如常）。

    ```py
    H(1)  H(2)    H(4)
    -------------------
     T    T T   T T T T
          T F   T F T F
                T T F F
                T F F T

    ```

    编写一个程序，接受一个命令行参数*n*，并写出*H[n]*。假设*n*是 2 的幂。

    *解决方案*: 请查看 hadamard.py。

1.  **谣言。** 爱丽丝正在与其他 n 位客人举办派对，包括鲍勃。鲍勃向其中一位其他客人传播关于爱丽丝的谣言。第一次听到这个谣言的人会立即将其告诉另一位客人，从所有在派对上的人中（除了爱丽丝和他们听到谣言的人）随机选择一个。如果一个人（包括鲍勃）第二次听到这个谣言，他或她将不会再传播它。编写一个程序来估计在谣言停止传播之前每个在派对上的人（除了爱丽丝）都会听到谣言的概率。还计算一下预计会听到谣言的人数。

1.  **查找重复项。** 给定一个包含*n*个元素的数组，每个元素介于 1 和*n*之间，编写一个代码片段来确定是否存在任何重复项。你不需要保留给定数组的内容，但不要使用额外的数组。

1.  **扫雷。** 编写一个程序，接受三个命令行参数*m*、*n*和*p*，并生成一个*m*乘*n*的布尔数组，其中每个元素以概率*p*被占据。在扫雷游戏中，被占据的单元格代表炸弹，空单元格代表安全单元格。用星号表示炸弹，用句点表示安全单元格。然后，用相邻炸弹的数量（上、下、左、右或对角线）替换每个安全方块，并写出结果，如下例所示。

    ```py
    * * . . .       * * 1 0 0
    . . . . .       3 3 2 0 0
    . * . . .       1 * 1 0 0

    ```

    尽量表达你的代码，使得尽可能少处理特殊情况，通过使用一个(*m*+2)-by-(*n*+2)的布尔数组。

    *解决方案*: 请查看 minesweeper.py。

1.  **避免自我行走长度。** 假设网格大小没有限制。运行实验估计平均步行长度。

1.  **三维避障步行。** 运行实验以验证三维避障步行的死胡同概率为 0，并计算各个*n*值的平均步行长度。

1.  **随机行走者。** 假设有`n`个随机行走者，从一个*n*乘*n*的网格中心开始，每次移动一步，选择向左、向右、向上或向下的概率相等。编写一个程序来帮助制定并测试有关在所有单元格都被触及之前所需步数的假设。

    *解决方案*: 请查看 randomwalkers.py。

1.  **桥牌手。** 在桥牌游戏中，四名玩家每人发 13 张牌。一个重要的统计数据是每手中每种花色的牌数分布。5-3-3-2，4-4-3-2 或 4-3-3-3 哪种可能性最大？编写一个程序来帮助你回答这个问题。

1.  **��日问题。** 假设人们继续进入一个空房间，直到有一对人共享生日。平均需要多少人进入才会有匹配？运行实验估计这个数量的值。假设生日是在 0 到 364 之间均匀随机的整数。

    *解决方案*: 请查看 birthday.py 和 birthdays.py。

1.  **收集优惠券。** 运行实验验证经典数学结果，即收集*n*个值所需的期望优惠券数量约为*nH[n]*。例如，如果你在二十一点桌上仔细观察牌（并且庄家有足够多的随机洗在一起的牌组），平均需要发出约 235 张牌，才能看到每张牌的价值。

1.  **洗牌。** 编写一个程序，使用 Gilbert-Shannon-Reeds 模型的洗牌方法重新排列一副*n*张牌。首先，根据*二项分布*生成一个随机整数*r*：抛掷一个公平硬币*n*次，让*r*为正面的次数。现在，将牌分成两堆：前*r*张牌和剩下的*n* - *r*张牌。为了完成洗牌，反复从两堆中的一堆顶部取一张牌并放在一个新堆的底部。如果第一堆剩余*n*[1]张牌，第二堆剩余*n*[2]张牌，从第一堆选择下一张牌的概率为*n*[1] / (*n*[1] + *n*[2])，从第二堆选择的概率为*n*[2] / (*n*[1] + *n*[2])。研究需要对一副 52 张牌的牌组应用多少次洗牌才能产生一个（几乎）均匀洗牌的牌组。

1.  **二项式系数。** 编写一个程序，构建并写入一个二维不规则数组`a`，使得`a[n][k]`包含在你抛掷一个公平硬币`n`次时恰好获得`k`个正面的概率。接受一个命令行参数来指定`n`的最大值。这些数字被称为*二项分布*：如果你将第*k*行中的每个元素乘以 2*^n*，你将得到*二项式系数*（(*x*+1)*^n*中*x^k*的系数）在*帕斯卡三角形*中排列。要计算它们，从所有`n`开始，`a[n][0] = 0.0`，`a[1][1] = 1.0`，然后按照从左到右的顺序计算连续行中的值，`a[n][k] = (a[n-1][k] + a[n-1][k-1])/2.0`。

    ```py
    Pascal's triangle   Binomial distribution
    1                   1
    1 1                 1/2  1/2
    1 2 1               1/4  1/2  1/4
    1 3 3 1             1/8  3/8  3/8  1/8
    1 4 6 4 1           1/16 1/4  3/8  1/4  1/16

    ```
