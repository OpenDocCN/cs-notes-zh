# 2.3   递归

> 原文：[`introcs.cs.princeton.edu/java/23recursion`](https://introcs.cs.princeton.edu/java/23recursion)

从另一个函数调用一个函数的想法立即暗示了函数调用*自身*的可能性。Java 中的函数调用机制支持这种可能性，这被称为*递归*。

## 您的第一个递归程序。

递归的“Hello, World”是*阶乘*函数，它由正整数*n*的方程式定义

> $$n! = n \times (n-1) \times (n-2) \times \; \ldots \; \times 2 \times 1$$

数量*n*!可以通过`for`循环轻松计算，但在 Factorial.java 中更简单的方法是使用以下递归函数：

```java
public static long factorial(int n) { 
    if (n == 1) return 1; 
    return n * factorial(n-1); 
} 

```

我们可以以与跟踪任何函数调用序列相同的方式跟踪此计算。

```java
factorial(5) 
   factorial(4) 
      factorial(3) 
         factorial(2) 
            factorial(1) 
               return 1 
            return 2*1 = 2 
         return 3*2 = 6 
      return 4*6 = 24 
   return 5*24 = 120

```

我们的`factorial()`实现展示了每个递归函数所需的两个主要组成部分。

+   *基本情况* 在不进行任何后续递归调用的情况下返回一个值。它为一个或多个特殊输入值提供了函数可以在没有递归的情况下进行评估的值。对于`factorial()`，基本情况是*n* = 1。

+   *减少步骤* 是递归函数的核心部分。它将一个（或多个）输入值处函数的值与另一个（或多个）输入值处函数的值联系起来。此外，输入值序列必须*收敛*到基本情况。对于`factorial()`，*n*的值每次调用都减少 1，因此输入值序列收敛到基本情况。

## 数学归纳法。

递归编程与*数学归纳法*直接相关，数学归纳法是一种证明关于自然数的事实的技术。通过数学归纳法证明涉及整数*n*的语句对于无限多个*n*值为真涉及以下两个步骤：

+   *基本情况*：证明某些特定值或值的*n*（通常为 0 或 1）为真。

+   *归纳步骤*：假设对于所有小于*n*的正整数该语句为真，然后使用该事实证明对于*n*为真。

这样的证明足以表明该语句对于*无限*多个*n*值为真：我们可以从基本情况开始，并使用我们的证明逐个为每个更大的*n*值证明该语句为真。

## 欧几里得算法。

两个正整数的*最大公约数*（gcd）是能够均匀整除它们的最大整数。例如，gcd(102, 68) = 34。

我们可以使用以下性质高效地计算最大公约数 gcd，该性质对正整数*p*和*q*成立：

> 如果*p* > *q*，则*p*和*q*的 gcd 与*q*和*p* % *q*的 gcd 相同。

Euclid.java 中的静态方法`gcd()`是一个紧凑的递归函数，其减少步骤基于此性质。

```java
gcd(1440, 408) 
   gcd(408, 216) 
      gcd(216, 192) 
         gcd(192, 24)
            gcd(24, 0)
               return 24
            return 24 
         return 24 
      return 24 
   return 24 

```

## 汉诺塔。

![汉诺塔的递归解法](img/cfd21be7f571fbaf9be2c807be2f5a42.png) 在*汉诺塔*问题中，我们有三根杆和*n*个可以放在杆上的圆盘。这些圆盘大小不同，最初堆叠在一根杆上，从最大的圆盘*n*（底部）到最小的圆盘 1（顶部）。任务是将所有*n*个圆盘移动到另一根杆上，同时遵守以下规则：

+   一次只移动一个圆盘。

+   永远不要将一个较大的圆盘放在一个较小的圆盘上。

递归提供了我们需要的计划：首先将顶部的*n*−1 个圆盘移动到一个空柱子上，然后将最大的圆盘移动到另一个空柱子上，然后通过将*n*−1 个圆盘移动到最大的圆盘上来完成工作。TowersOfHanoi.java 是这种策略的直接实现。

## 指数时间。

![指数增长](img/9a3e349ca4c3b79eb5c0be843fa36bbe.png)  设 T(*n*)是 TowersOfHanoi.java 发出的移动指令数量，用于将*n*个圆盘从一个柱子移动到另一个柱子。那么，T(*n*)必须满足以下方程：

> $$T(n) = 2T(n-1) + 1 \text{ for } n > 1, \text{ with } T(1) = 1$$

这样的方程在离散数学中被称为*递归关系*。我们经常可以使用它们来推导出所关注的数量的闭合形式表达式。例如，T(1) = 1, T(2) = 3, T(3) = 7, T(4) = 15。一般来说，T(*n*) = 2^(*n*) − 1。假设僧侣们每秒移动一个圆盘，他们需要超过 58 亿个世纪才能解决 64 个圆盘问题。

## 格雷码。

*n*位*格雷码*是 2^(*n*)个不同的*n*位二进制数的列表，使得列表中的每个条目与其前一个条目在恰好一个位上不同。*n*位二进制反射格雷码的定义如下：

+   *n*−1 位编码，每个单词前面加 0，然后是

+   *n*−1 位编码按相反顺序排列，每个单词前面加 1。

0 位编码被定义为空，因此 1 位编码是 0 后跟 1\。

|                | ![格雷码表示](img/3c1deb8434d454058bc18cb9902f75c7.png) |                | ![2 位、3 位和 4 位格雷码](img/47f120f9f06757e65cb89ad050cc63c9.png) |
| --- | --- | --- | --- |

Beckett.java 使用*n*位格雷码打印舞台指令，用于*n*个字符的戏剧，使得角色一个接一个地进入和退出，以便舞台上的每个角色子集恰好出现一次。

## 递归图形。

简单的递归绘图方案可能导致非常复杂的图片。例如，*n*阶*H 树*的定义如下：当*n* = 0 时，基本情况为空。减少步骤是在形状为字母 H 的单位正方形内绘制三条线，四个*n* − 1 阶 H 树，每个 H 树与 H 的每个尖端连接，附加条件是*n* − 1 阶 H 树位于正方形的四个象限中心，尺寸减半。

| ![htree 1](img/abddc8550d2dd3f1ffb21f40d53ccdea.png) | ![htree 2](img/382562bcb3194374b999bcfec7559b78.png) | ![htree 3](img/a252015aa78d10438ecbd0e78bc58586.png) | ![htree 4](img/b42a26c1155077a1c093b8c4b6eb604a.png) | ![htree 5](img/85518097da4a973f47ae85df69cef073.png) |
| --- | --- | --- | --- | --- |

Htree.java 接受一个命令行参数*n*，并绘制一个*n*阶 H 树到标准绘图。H 树是*分形*的一个简单示例：一个几何形状，可以被分成部分，每个部分（大致）是原始形状的缩小副本。

## 布朗桥。

Brownian.java 生成一个函数图，近似于称为*布朗桥*的分数布朗运动的简单示例。您可以将这个图形看作是连接两个点（*x*[0], *y*[0])和（*x*[1], *y*[1])的随机行走，由几个参数控制。该实现基于*中点位移法*，这是一个递归绘制绘图的计划，位于*x*区间[*x*[0], *x*[1]]内。基本情况（当间隔的大小小于给定的容差时）是绘制连接两个端点的直线。减少情况是将间隔分成两半，然后继续如下操作：

+   计算间隔的中点（*x[m]*，*y[m]*）。

+   将中点的*y*坐标*y[m]*增加一个从均值为 0 且给定方差的高斯分布中抽取的随机值δ。

+   在子间隔上进行递归，通过给定的缩放因子*s*来减少方差。

曲线的形状由两个参数控制：*波动性*（方差的初始值）控制图形偏离连接点的直线的距离，*赫斯特指数*控制曲线的平滑度。

> |       | ![布朗桥](img/703e09db2d0eed077c43d617d778936b.png) |       | ![H = 0.5 的布朗运动](img/2a37e7191a15e3ce6bcf03c3bdd8c142.png) |       | ![H = 0.05 的布朗运动](img/cdc3430903174f36959472db9acf4370.png) |
> | --- | --- | --- | --- | --- | --- |

## 递归的陷阱。

通过递归，你可以编写简洁而优雅的程序，在运行时却失败得令人瞠目结舌。

+   *缺少基本情况。* NoBaseCase.java 中的递归函数应该计算调和数，但缺少一个基本情况：

    ```java
    public static double harmonic(int n) {
        return harmonic(n-1) + 1.0/n;
    }

    ```

    如果调用这个函数，它将不断调用自身而永远不会返回。

+   *��有收敛的保证。* 另一个常见问题是在递归函数中包含一个递归调用来解决一个不比原问题更小的子问题。例如，NoConvergence.java 中的递归函数对于其参数的任何值（除了 1）都会进入无限递归循环。

    ```java
    public static double harmonic(int n) {
        if (n == 1) return 1.0;
        return harmonic(n) + 1.0/n;
    } 

    ```

+   *过度内存需求。* 如果一个函数在返回之前递归调用自身过多次数，Java 需要的内存来跟踪递归调用可能是不可接受的。ExcessiveMemory.java 中的递归函数正确计算第 n 个调和数。然而，用一个巨大的`n`值调用它将导致`StackOverflowError`。

    ```java
    public static double harmonic(int n) { 
       if (n == 0) return 0.0;
       return harmonic(n-1) + 1.0/n; 
    } 

    ```

+   *过度重复计算。* ![计算斐波那契数的错误方法](img/111e822a28258fd755ae5d63d1003bed.png) 写一个简单的递归程序解决问题的诱惑必须始终受到这样的理解的限制，即简单程序可能需要指数时间（不必要地），因为存在过度重复计算。例如，斐波那契数列

    > 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...

    由公式定义

    > $$F_n = F_{n-1} + F_{n-2} \text{ for } n \ge 2, \text{ with } F_0 = 0 \text{ and } F_1 = 1$$

    一个初学者程序员可能会实现这个递归函数来计算斐波那契数列中的数字，就像 Fibonacci.java 中所示的那样：

    ```java
    // Warning: spectacularly inefficient.
    public static long fibonacci(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fibonacci(n-1) + fibonacci(n-2);
    } 

    ```

    然而，这个程序效率极低！要看出为什么这样做是徒劳的，考虑一下这个函数如何计算`fibonacci(8) = 21`。它首先计算`fibonacci(7) = 13`和`fibonacci(6) = 8`。为了计算`fibonacci(7)`，它递归计算`fibonacci(6) = 8` *再次*和`fibonacci(5) = 5`。事情迅速变得更糟。这个程序在计算`fibonacci(n)`时计算`fibonacci(1)`的次数恰好是*F*[*n*]。

## 动态规划。

实现递归程序的一般方法，*动态规划*的基本思想是将一个复杂问题递归地分解为若干较简单的子问题；存储每个子问题的答案；最终使用存储的答案来解决原始问题。通过仅解决每个子问题一次（而不是一遍又一遍），这种技术避免了运行时间的潜在指数级增长。

+   *自顶向下动态规划。* 在*自顶向下*动态规划中，我们存储或*缓存*我们解决的每个子问题的结果，这样下次我们需要解决相同的子问题时，我们可以使用缓存的值而不是从头开始解决子问题。TopDownFibonacci.java 演示了用于计算斐波那契数的自顶向下动态规划。

    > ![自顶向下动态规划](img/d2f1a08b69aef188f5b217fd2f65428f.png)

+   *自底向上动态规划。* 在*自底向上*动态规划中，我们计算所有子问题的解，从“最简单”的子问题开始，逐渐构建更复杂子问题的解。BottomUpFibonacci.java 演示了用于计算斐波那契数的自底向上动态规划。

    ```java
    public static long fibonacci(int n) {
        long[] f = new long[n+1];
        f[0] = 0;
        f[1] = 1;
        for (int i = 2; i <= n; i++)
            f[i] = f[i-1] + f[i-2];
        return f[n];
    }

    ```

+   *最长公共子序列问题。* 给定两个字符串*x*和*y*，我们希望计算它们的<em.longest common="" subsequence="">(LCS)。如果我们从*x*中删除一些字符，从*y*中删除一些字符，得到的两个字符串相等，我们称结果字符串为*公共子序列*。LCS 问题是找到两个字符串的一个尽可能长的公共子序列。例如，`GGCACCACG`和`ACGGCGGATACG`的 LCS 是`GGCAACG`，一个长度为 7 的字符串。

    ```java
    - - G G C - - A - C C A C G
    A C G G C G G A T - - A C G

    ```</em.longest>

+   *最长公共子序列递归。* 现在我们描述一个递归公式，使我们能够找到给定字符串`s`和`t`的 LCS。设`m`和`n`分别为`s`和`t`的长度。我们使用符号`s[i..m)`表示`s`从索引`i`开始的*后缀*，使用`t[j..n)`表示从索引`j`开始的`t`的后缀。

    +   如果`s`和`t`以相同字符开头，则`s`和`t`的 LCS 包含该第一个字符。因此，我们的问题简化为找到后缀`s[1..m)`和`t[1..n)`的 LCS。

    +   如果`s`和`t`以不同字符开头，则两个字符都不能成为公共子序列的一部分，因此可以安全地丢弃其中一个。在任何一种情况下，问题都简化为找到两个字符串的 LCS——要么`s[0..m)`和`t[1..n)`，要么`s[1..m)`和`t[0..n)`。

    一般来说，如果我们让`opt[i][j]`表示后缀`s[i..m)`和`t[j..n)`的 LCS 的长度，则以下递归成立：

    ```java
    opt[i][j] = 0                              if i = m or j = n
              = opt[i+1][j+1] + 1              if s[i] = t[j]
              = max(opt[i][j+1], opt[i+1][j])  otherwise

    ```

+   *动态规划解决方案。*LongestCommonSubsequence.java 从底向上的动态规划方法开始解决这个递归。

    > ![最长公共子序列](img/83212e1903cc0be5ecb7da3f7c2322a1.png)

    最终挑战是恢复最长公共子序列本身，而不仅仅是其长度。关键思想是*向后*重新跟踪动态规划算法的步骤，从`opt[0][0]`到`opt[m][n]`重新发现选择路径（在图中用灰色突出显示）。为了确定导致`opt[i][j]`的选择，我们考虑三种可能性：

    +   `字符 s[i]`匹配`t[j]`。在这种情况下，我们必须有`opt[i][j]` = `opt[i+1][j+1]` + 1，并且 LCS 中的下一个字符是`s[i]`。我们继续从`opt[i+1][j+1]`回溯。

    +   LCS 不包含`s[i]`。在这种情况下，`opt[i][j]` = `opt[i+1][j]`，我们继续从`opt[i+1][j]`回溯。

    +   LCS 不包含`t[j]`。在这种情况下，`opt[i][j]` = `opt[i][j+1]`，我们继续从`opt[i][j+1]`回溯。

#### 练习

1.  给定四个正整数`a`、`b`、`c`和`d`，解释`gcd(gcd(a, b), gcd(c, d))`计算的值是什么。

    *解决方案*：`a`、`b`、`c`和`d`的最大公约数。

1.  用整数和除数的术语解释以下类似于欧几里得函数的效果。

    ```java
    public static boolean gcdlike(int p, int q) {
       if (q == 0) return (p == 1);
       return gcdlike(q, p % q);
    }

    ```

    *解决方案*：返回`p`和`q`是否互质。

1.  考虑以下递归函数。

    ```java
    public static int mystery(int a, int b) {
        if (b == 0)     return 0;
        if (b % 2 == 0) return mystery(a+a, b/2);
        return mystery(a+a, b/2) + a;
    }

    ```

    `mystery(2, 25)`和`mystery(3, 11)`的值是多少？给定正整数`a`和`b`，描述`mystery(a, b)`计算的值。用`*`替换`+`，用`return 1`替换`return 0`后，回答相同的问题。

    *解决方案*：50 和 33。它计算 a*b。如果你用`*`替换`+`，它计算 a^b。

1.  编写一个程序 AnimatedHtree.java，用于动画绘制 H 树。

    > ![动画 H 树](img/5e790e385991e808af1b9269d960aeef.png)

    接下来，重新排列递归调用的顺序（和基本情况），查看生成的动画，并解释每个结果。

#### 创意练习

1.  **二进制表示。** 编写一个程序 IntegerToBinary.java，以十进制正整数*n*作为命令行参数，并打印其二进制表示。回想一下，在 Binary.java 中，我们使用了减去 2 的幂的方法。现在，使用以下更简单的方法：重复地将 2 除以*n*，并倒序读取余数。首先，编写一个`while`循环来执行这个计算并以错误顺序打印位。然后，使用递归以正确顺序打印位。

1.  **排列。** 编写一个程序 Permutations.java，接受一个整数命令行参数 *n*，并打印出以 `a` 开头的 *n* 个字母的 *n*! 排列。*n* 元素的排列是元素的 *n*! 种可能排序之一。例如，当 *n* = 3 时，您应该得到以下输出（但不必担心枚举它们的顺序）：

    ```java
    bca cba cab acb bac abc

    ```</m>

1.  **大小为 k 的排列。** 编写一个程序 PermutationsK.java，接受两个命令行参数 *n* 和 *k*，并打印出包含恰好 *k* 个 *n* 元素的排列的数量 \(P(n, k) = \frac{n!}{(n-k)!}\)。当 *k* = 2 且 *n* = 4 时，以下是期望的输出（再次，不必担心顺序）：

    ```java
    ab ac ad ba bc bd ca cb cd da db dc 

    ```

1.  **组合。** 编写一个程序 Combinations.java，接受一个整数命令行参数 *n*，并打印出任意大小的 2^(*n*) *组合*。*组合* 是 *n* 元素的子集，与顺序无关。例如，当 *n* = 3 时，您应该得到以下输出：

    ```java
     a ab abc ac b bc c

    ```

    请注意，您的程序需要打印空字符串（大小为 0 的子集）。

1.  **大小为 k 的组合。** 编写一个程序 CombinationsK.java，接受两个命令行参数 *n* 和 *k*，并打印出大小为 *k* 的组合的数量 \(C(n, k) = \frac{n!}{k! (n-k)!}\)。例如，当 *n* = 5 且 *k* = 3 时，您应该得到以下输出：

    ```java
    abc abd abe acd ace ade bcd bce bde cde 

    ```

    使用数组而不是字符串的替代解决方案：Comb2.java。

1.  **递归方块。** 编写一个程序来生成以下递归图案。方块大小的比例为 2.2:1。要绘制阴影方块，请先绘制填充的灰色方块，然后是未填充的黑色方块。

    > ![递归方块](img/cbb67867af17c3b55d47068e21c99349.png)

    RecursiveSquares.java 提供了第一个模式的解决方案。

1.  **格雷码。** 修改 Beckett.java 以打印格雷码（而不仅仅是变化的位位置序列）。

    *解决方案*：GrayCode.java 使用了 Java 的字符串数据类型；GrayCodeArray.java 使用了布尔数组。

1.  **汉诺塔动画。** 编写一个程序 AnimatedHanoi.java，使用 `StdDraw` 来动画显示解决汉诺塔问题的过程，每秒移动一个盘子。

1.  **Collatz 函数。** 考虑以下递归函数 Collatz.java，它与数论中一个著名的未解决问题相关，即 [Collatz 问题](http://mathworld.wolfram.com/CollatzProblem.html) 或 *3n + 1 问题*。

    ```java
    public static void collatz(int n) {
        StdOut.print(n + " ");
        if (n == 1) return;
        if (n % 2 == 0) collatz(n / 2);
        else            collatz(3*n + 1);
    }

    ```

    例如，调用 `collatz(7)` 打印出序列

    > ```java
    > 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 
    > 
    > ```

    由于 17 次递归调用的结果。编写一个程序，接受一个命令行参数 `n`，并返回使得 `collatz(i)` 的递归调用次数最大化的 `i < n` 的值。提示：使用记忆化。未解决的问题是没有人知道该函数对所有整数是否终止（数学归纳法无助，因为其中一个递归调用是针对参数的较大值）。

1.  **布朗岛。** B. 曼德布罗特提出了著名问题 *英国海岸有多长？* 修改 Brownian.java 以获得一个程序 BrownianIsland.java，绘制出类似于大不列颠岛的 [布朗岛](http://swiss.csail.mit.edu/~rauch/islands/)。修改很简单：首先，将 `curve()` 更改为在 *x* 坐标和 *y* 坐标上添加随机高斯数；其次，将 `main()` 更改为从画布中心的点绘制一条曲线回到自身。尝试使用各种参数值，使您的程序产生外观逼真的岛屿。

    > ![布朗岛](img/d8901e2a2634b519adef94f41361a3d1.png)

1.  **等离子云。** 编写一个递归程序 PlasmaCloud.java 来绘制等离子云，使用文本中建议的方法。

    > ![等离子云](img/b411ee84a4611aa2aea64caee2644086.png)

1.  **一个奇怪的函数。** 考虑麦卡锡的 91 函数：

    ```java
    public static int mcCarthy(int n) {
        if (n > 100) return n - 10;
        else return mcCarthy(mcCarthy(n+11));
     }

    ```

    确定 `mcCarthy(50)` 的值，不使用计算机。给出 `mcCarthy()` 用于计算此结果的递归调用次数。证明对于所有正整数 `n` 都会达到基本情况，或找到一个值 `n`，使得此函数进入递归循环。

1.  **递归树。** 编写一个程序 Tree.java，它接受一个命令行参数 `n`，并为 `n` 等于 1、2、3、4 和 8 生成以下递归模式。

    > ![递归树](img/a9d0bc474f1b08921a027c060c4f8620.png)

#### 网络练习

1.  如果输入可以是负数，Euclid.java 仍然有效吗？如果不是，请修复它。*提示*：回想一下，如果第一个输入是负数，% 可以返回一个负整数。在调用函数时，取两个输入的绝对值。

1.  编写一个递归程序 GoldenRatio.java，它接受一个整数输入 N，并使用以下递归公式计算[黄金比例](http://en.wikipedia.org/wiki/Golden_ratio)的近似值：

    ```java
    f(N) = 1               if N = 0
         = 1 + 1 / f(N-1)  if N > 0

    ```

    重新做，但不使用递归。

1.  发现[黄金比例](http://en.wikipedia.org/wiki/Golden_ratio)与斐波那契数之间的联系。*提示*：考虑连续斐波那契数的比率：2/1, 3/2, 8/5, 13/8, 21/13, 34/21, 55/34, 89/55, 144/89, ...

1.  考虑以下递归函数。`mystery(1, 7)` 是什么？

    ```java
    public static int mystery(int a, int b) {
       if (0 == b) return 0;
       else return a + mystery(a, b-1);
    }

    ```

    在上一个练习中，对于 0 到 100 之间的每对整数 a 和 b，函数是否会终止？给出对于 0 到 100 之间的整数 a 和 b，`mystery(a, b)` 返回的高级描述。

    *答案*：mystery(1, 7) = 1 + mystery(1, 6) = 1 + (1 + mystery(1, 5)) = ... 7 + mystery(1, 0) = 7。

    *答案*：是的，基本情况是 b = 0。连续的递归调用将 b 减少 1，将其推向基本情况。函数 `mystery(a, b)` 返回 `a * b`。数学倾向的学生可以使用恒等式 ab = a + a(b-1) 通过归纳法证明这一事实。

1.  考虑以下函数。`mystery(0, 8)` 做什么？

    ```java
    public static void mystery(int a, int b) {
       if (a != b) {
           int m = (a + b) / 2;
           mystery(a, m);
           StdOut.println(m);
           mystery(m, b);
       }
    }

    ```

    *答案*：无限循环。

1.  考虑以下函数。`mystery(0, 8)` 做什么？

    ```java
    public static void mystery(int a, int b) {
       if (a != b) {
           int m = (a + b) / 2;
           mystery(a, m - 1);
           StdOut.println(m);
           mystery(m + 1, b);
       }
    }

    ```

    *答案*：堆栈溢出。

1.  重复上一个练习，但将 `if (a != b)` 替换为 `if (a <= b)`。

1.  `mystery(0, 8)` 做什么？

    ```java
    public static int mystery(int a, int b) {
        if (a == b) StdOut.println(a);
        else {
           int m1 = (a + b    ) / 2;
           int m2 = (a + b + 1) / 2;
           mystery(a, m1);
           mystery(m2, b);
        }
    }

    ```

1.  以下函数计算什么？

    ```java
    public static int f(int n) {
       if (n == 0) return 0;
       if (n == 1) return 1;
       if (n == 2) return 1;
       return 2*f(n-2) + f(n-3);

    ```

1.  编写一个程序 Fibonacci2.java，它接受一个命令行参数 N，并使用以下替代定义打印出前 N 个斐波那契数：

    ```java
    F(n)   = 1                            if n = 1 or n = 2
           = F((n+1)/2)2 + F((n-1)/2)2     if n is odd
           = F(n/2 + 1)2 - F(n/2 - 1)2     if n is even

    ```

    使用这个定义，在一分钟内你能计算出的最大斐波那契数是多少？将其与 Fibonacci.java 进行比较。

1.  编写一个程序，它接受一个命令行参数 N，并使用[Dijkstra 提出的方法](http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF)打印出前 N 个斐波那契数。

    ```java
    F(0) =  0
    F(1) =  1
    F(2n-1) = F(n-1)² + F(n)²
    F(2n) = (2F(n-1) + F(n)) * F(n)

    ```

1.  通过数学归纳法证明前两个练习中给出的斐波那契函数的替代定义与原始定义等价。

1.  编写一个程序 `Pell.java`，它接受一个命令行参数 N，并打印出前 N 个 *Pell 数*：p[0] = 0，p[1] = 1，对于 n >= 2，p[n] = 2 p[n-1] + p[n-2]。打印连续项的比率，并与 1 + sqrt(2) 进行比较。

1.  考虑来自程序 Recursion.java 的以下函数：

    ```java
    public static void mystery(int n) {
       if (n == 0 || n == 1) return;
       mystery(n-2);
       StdOut.println(n);
       mystery(n-1);
    }

    ```

    `mystery(6)` 打印出什么？*提示*：首先弄清楚 `mystery(2)`，`mystery(3)` 等打印出什么。

1.  如果基本情况被替换为以下语句，上一个练习会发生什么？

    ```java
    if (n == 0) return;

    ```

1.  考虑以下递归函数。

    ```java
    public static int square(int n) {
       if (n == 0) return 0;
       return square(n-1) + 2*n - 1;
    }

    public static int cube(int n) {
       if (n == 0) return 0;
       return cube(n-1) + 3*(square(n)) - 3*n + 1;
    }

    ```

    `square(5)` 的值是多少？`cube(5)`？`cube(123)`？

1.  考虑下面一对相互递归的函数。`g(g(2))` 的求值结果是什么？

    ```java
    public static int f(int n) {     public static int g(int n) {
       if (n == 0) return 0;            if (n == 0) return 0;
       return f(n-1) + g(n-1);          return g(n-1) + f(n);
    }                                }

    ```

1.  编写程序验���（对于较小的 n 值），前 n 个斐波那契数的立方和 F(0)³ + F(1)³ + ... + F(n)³ 等于 (F(3n+4) + (-1)^n * 6 * f(n-1)) / 10，其中 F(0) = 1，F(1) = 1，F(2) = 2，依此类推。

1.  **通过递增和展开进行转换。** 给定两个整数 a ≤ b，编写一个程序 Sequence.java，通过最小的递增（加 1）和展开（乘以 2）操作将 a 转换为 b。例如，

    ```java
    % java Sequence 5 23
    23 = ((5 * 2 + 1) * 2 + 1)

    % java Sequence 11 113
    113 = ((((11 + 1) + 1) + 1) * 2 * 2 * 2 + 1)

    ```

1.  **哈达玛矩阵。** 编写一个递归程序 Hadamard.java，接受一个命令行参数 n，并绘制一个 N×N 的哈达玛图案，其中 N = 2^n。不要使用数组。一个 1×1 的哈达玛图案是一个黑色的正方形。一般来说，一个 2N×2N 的哈达玛图案是通过将 N×N 图案的 4 个副本对齐成一个 2×2 网格的形式获得的，然后反转右下角 N×N 图案中所有方块的颜色。N×N 哈达玛 H(N) 矩阵是一个布尔矩阵，具有任意两行恰好相差 N/2 位的显著特性。这个特性使得它对设计*纠错码*非常有用。以下是前几个哈达玛矩阵。

    > | ![2x2 哈达玛矩阵图](img/3fcca04e628395438f1368818224fcfb.png) | ![4x4 哈达玛矩阵图](img/4188238d690602071d30541d08ef4597.png) | ![8x8 哈达玛矩阵图](img/3a556cb365ae1a8ac2f806d8eb3c324d.png) | ![16x16 哈达玛矩阵图](img/283b5b4b908d053de67422d52ab78ca8.png) |
    > | --- | --- | --- | --- |

1.  **8 皇后问题。** 在这个练习中，您将解决经典的 [8 皇后问题](http://www.acm.org/classics/dec95)：在一个 8x8 的棋盘上放置 8 个皇后，使得没有两个皇后在同一行、列或对角线上。没有两个皇后放在同一行或列的方式有 8! = 40,320 种。整数 0 到 7 的任意排列 p[] 都可以给出这样的放置：将皇后 i 放在第 i 行，第 p[i] 列。您的程序 Queens.java 应该接受一个整数命令行参数 n，并通过绘制皇后的位置来列举解决 n 皇后问题的所有解决方案，就像下面的两个解决方案一样。

    ```java
    * * * Q * * * *      * * * * Q * * * 
    * Q * * * * * *      * Q * * * * * * 
    * * * * * * Q *      * * * Q * * * * 
    * * Q * * * * *      * * * * * * Q * 
    * * * * * Q * *      * * Q * * * * * 
    * * * * * * * Q      * * * * * * * Q 
    * * * * Q * * *      * * * * * Q * * 
    Q * * * * * * *      Q * * * * * * * 

    ```

    *提示*：确定设置 q[n] = i 是否与 q[0] 到 q[n-1] 冲突

    +   如果 q[i] 等于 q[n]：两个皇后放在同一列

    +   如果 q[i] - q[n] 等于 n - i：两个皇后在同一主对角线上

    +   如果 q[n] - q[i] 等于 n - i：两个皇后在同一副对角线上

1.  **另一个 8 皇后问题求解器。** 程序 Queens2.java 通过隐式枚举所有 n! 排列（而不是 n^n 放置）来解决 8 皇后问题。它基于程序 Permutations.java。

1.  **欧几里得算法和 π。** 从一个大随机数集中选择两个数，它们没有公共因子（除了 1）的概率是 6 / π²。利用这个想法来估计 π。罗伯特·马修斯使用相同的想法，通过将星空中的星星位置作为一个函数来估计 π。

1.  **汉诺塔变种 II。**（Knuth-Graham 和 Pathashnik）解决原始汉诺塔问题，但额外限制您不能直接将一个盘子从 A 移动到 C。解决具有 n 个盘子的问题需要多少步？*提示*：递归地将 A 到 C 的 n-1 个最小盘子移动（没有任何直接的 A 到 C 移动），将盘子 n 从 A 移动到 B，递归地将 C 到 A 的 n-1 个最小盘子移动（没有任何直接的 A 到 C 移动），将盘子 n 从 B 移动到 C，并递归地将 A 到 C 的 n-1 个最小盘子移动（没有任何直接的 A 到 C 移动）。

1.  **汉诺塔变种 III。** 重复上一个问题，但不允许 A 到 C 和 C 到 A 的移动。也就是说，每次移动必须涉及柱子 B。

1.  **四根柱子的汉诺塔。** 假设你有第四根柱子。从最左边的柱子转移一个由 8 个圆盘组成的堆到最右边的柱子需要的最少移动次数是多少？[答案](http://math.smsu.edu/~les/POW01_03.html)。在一百多年来，找到一般情况下最短的解决方案仍然是一个悬而未决的问题，被称为*雷夫谜题*。

1.  **另一个棘手的递归函数。** 考虑以下递归函数。`f(0)`是多少？

    ```java
    public static int f(int x) {
       if (x > 1000) return x - 4;
       else return f(f(x+5));
    }

    ```

1.  **检查 n 是否为斐波那契数。** 编写一个函数来检查 n 是否为斐波那契数。*提示*：当且仅当 (5*n*n + 4) 或 (5*n*n - 4) 是一个完全平方数时，正整数才是斐波那契数。

1.  **随机中缀表达式生成器。** 使用不同的命令行参数 p 在 0 和 1 之间运行 RandomExpression.java。你观察到了什么？

    ```java
    public static String expr(double p) {
       double r = Math.random();
       if (r <= 1*p) return "(" + expr(p) + " + " + expr(p) + ")";
       if (r <= 2*p) return "(" + expr(p) + " * " + expr(p) + ")";
       return "" + (int) (100 * Math.random());
    }

    ```

1.  **一个棘手的递归。** 定义 F(n) 使得 F(0) = 0 并且 F(n) = n - F(F(n-1))。F(100000000)是多少？

    *解决方案*：[答案](http://www.ocf.berkeley.edu/~wwu/cgi-bin/yabb/YaBB.cgi?board=riddles_medium;action=display;num=1065363259)与斐波那契数列和一个数字的[泽肯多夫表示](http://mathworld.wolfram.com/ZeckendorfRepresentation.html)有关。

1.  **冯·诺伊曼序数。** *冯·诺伊曼整数* i 的定义如下：对于 i = 0，它是空集；对于 i > 0，它是包含冯·诺伊曼整数 0 到 i-1 的集合。

    ```java
    0 = {}         = {}
    1 = {0}	       = {{}}
    2 = {0, 1}     = {{}, {{}}}
    3 = {0, 1, 2}  = {{}, {{}}, {{}, {{}}}}

    ```

    编写一个程序 Ordinal.java，其中有一个递归函数 `vonNeumann()`，接受一个非负整数 `N` 并返回冯·诺伊曼整数 N 的字符串表示。这是集合论中定义序数的一种方法。

1.  **字符串的子序列。** 编写一个程序 Subsequence.java，接受一个字符串命令行参数 `s` 和一个整数命令行参数 `k`���并打印出长度为 `k` 的 `s` 的所有子序列。

    ```java
    % java Subsequence abcd 3
    abc abd acd bcd

    ```

1.  **交错两个字符串。** 给定两个不同字符的字符串 `s` 和 `t`，打印出所有 (M+N)! / (M! N!) 交错，其中 M 和 N 是两个字符串中字符的数量。例如，如果

    ```java
    s = "ab"  t = "CD"
    abCD   CabD
    aCbD   CaDb
    aCDb   CDab

    ```

1.  **二进制最大公约数。** 编写一个程序 BinaryGCD.java，使用[二进制最大公约数算法](http://en.wikipedia.org/wiki/Binary_GCD_algorithm)找到两个正整数的最大公约数：gcd(p, q) =

    +   如果 q = 0，则为 p

    +   如果 p = 0，则为 q

    +   如果 p 和 q 都是偶数，则为 2 * gcd(p/2, q/2)

    +   如果 p 是偶数且 q 是奇数，则为 gcd(p/2, q)

    +   如果 p 是奇数且 q 是偶数，则为 gcd(p, q/2)

    +   如果 p 和 q 都是奇数且 p >= q，则为 gcd((p-q)/2, q)

    +   如果 p 和 q 都是奇数且 p < q，则为 gcd(p, (q-p)/2)

1.  **整数分区。** 编写一个程序 Partition.java，将一个正整数 N 作为命令行参数，并打印出 N 的所有分区。[分区](http://en.wikipedia.org/wiki/Integer_partition)是将 N 写成正整数之和的一种方式。如果两个和仅在其组成部分的顺序上有所不同，则认为它们是相同的。分区在数学和物理中的对称多项式和群表示理论中出现。

    ```java
    % java Partition 4      % java Partition 6
    4                       6
    3 1                     5 1
    2 2                     4 2
    2 1 1                   4 1 1
    1 1 1 1                 3 3
                            3 2 1
                            3 1 1 1
                            2 2 2
                            2 2 1 1
                            2 1 1 1 1
                            1 1 1 1 1 1

    ```

1.  **约翰逊-特罗特排列。** 编写一个程序 JohnsonTrotter.java，接受一个整数命令行参数 n，并以一种方式打印出整数 0 到 n-1 的所有 n! 排列，使得连续的排列仅在一个相邻的转位中有所不同（类似于格雷码在组合中迭代的方式，使得连续的组合仅在一个位上有所不同）。

    ```java
    % java JohnsonTrotter 3
    012   (2 1)
    021   (1 0)
    201   (2 1)
    210   (0 1)
    120   (1 2)
    102   (0 1)

    ```

1.  **按字典顺序排列的排列。** 编写一个程序 PermutationsLex.java，接受一个命令行参数 N，并按字典顺序打印出整数 0 到 N-1 的所有 N! 排列。

    ```java
    % java PermutationsLex 3
    012
    021
    102
    120
    201
    210

    ```

1.  **错位排列。** [错位排列](http://en.wikipedia.org/wiki/Derangement)是一个整数从 0 到 N-1 的排列`p[]`，使得对于任何 i，p[i]不等于 i。例如，当 N = 4 时有 9 个错位排列：1032, 1230, 1302, 2031, 2301, 2310, 3012, 3201, 3210。编写一个程序来计算大小为 N 的错位排列的数量，使用以下递推关系：d[N] = (N-1) (d[N-1] + d[N-2])，其中 d[1] = 0，d[2] = 1。前几项是 0, 1, 2, 9, 44, 265, 1854, 14833, 133496 和 1334961。

1.  **Tribonacci 数。** *Tribonacci 数*类似于斐波那契数列，不同之处在于序列中的每一项是前三项的和。前几项是 0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81。编写一个计算 Tribonacci 数的程序。连续项的比率是多少？*答案*。x³ - x² - x - 1 的根，约为 1.83929。

1.  **前 n 个斐波那契数的和。** 通过归纳证明，前 n 个斐波那契数 F(1) + F(2) + ... + F(N)的和是 F(N+2) - 1。

1.  **组合格雷码。** 按照只有一个元素不同的方式打印出 k 个 n 项的所有组合，例如，如果 k = 3 且 n = 5，123, 134, 234, 124, 145, 245, 345, 135, 235, 125。*提示*：使用格雷码，但只打印出那些在其二进制表示中恰好有 k 个 1 的整数。

1.  **迷宫生成。** 使用分而治之的方法[创建一个迷宫](http://en.wikipedia.org/wiki/Maze_generation_algorithm)：从一个没有墙壁的矩形区域开始。选择矩形中的一个随机网格点，并构建两条垂直墙壁，将正方形分成 4 个子区域。随机选择四个区域中的三个，并在每个区域中的一个随机点开一个单元的洞。递归直到每个子区域的宽度或高度为 1。

1.  **等离子云。** 程序 PlasmaCloud.java 接受一个命令行参数 N，并使用中点位移法生成一个随机的 N×N 等离子分形。

    > | ![等离子云 1](img/ec1d546e528e91882794533f70b7ae03.png) | ![等离子云 2](img/2bc93da5c14dce015352a1ae8fdf9511.png) | ![等离子云 3](img/906454727d634ad047c3e5049058bc0b.png) |
    > | --- | --- | --- |

    这里有一个 800×800 的示例。这里有一个[参考链接](http://www.gameprogrammer.com/fractal.html)，包括一个简单的一维版本。注意：在 x 和 y 轴平行方向上会有一些视觉伪影。不具备 2D 分数布朗运动的所有统计特性。

1.  **蕨类分形。** 编写一个递归程序来绘制蕨类或树，就像这个[蕨类分形演示](http://www.krazydad.com/bestiary/bestiary_fern.html)中所示。

1.  **��数集合划分。** 使用记忆化开发一个解决正整数值集合划分问题的程序。可以使用一个大小为输入值之和的数组。

1.  **投票权力。** 约翰·F·班扎夫三世提出了一个在分块投票系统中为每个联盟排名的系统。假设第 i 党控制 w[i]票。接受或拒绝提案需要严格多数的选票。第 i 党的[投票权力](http://acm.uva.es/p/v4/435.html)是它可以加入的少数派联盟数量，使其成为获胜多数联盟。编写一个程序 VotingPower.java，接受一个联盟权重列表作为命令行参数，并打印出每个联盟的投票权力。*提示*：使用 Schedule.java 作为起点。

1.  **两台并行机器上的调度。** 程序 Schedule.java 接受一个命令行参数 N，从标准输入读取 N 个实数，并将它们分成两组，使它们的差最小化。

1.  **霍夫斯塔德-康威 $10,000 序列。** 考虑以下递归函数。f(n) = f(f(n-1)) + f(n-f(n-1))，对于 n > 2 且 f(1) = f(2) = 1。计算 f(3)。编写一个 Java 程序来计算[Hofstadter–Conway $10,000 序列](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter–Conway_$10,000_sequence)中 f(n) 的前 50 个值。使用动态规划。这个序列具有许多迷人的特性，并与帕斯卡三角形、高斯分布、斐波那契数和卡特兰数相关。

1.  **运行时间递归。** 使用动态规划计算值表 T(N)，其中 T(N) 是以下分治递归的解。T(1) = 0，如果 N > 1，则 T(N) = N + T(N/2) + T(N - N/2)。

1.  **加油站优化。** 你正在驾驶一辆每加仑行驶 25 英里，油箱容量为 15 加仑的汽车从普林斯顿到旧金山。沿途有 N 个加油站可以停下加油。加油站 i 在旅程中的 d[i] 英里处，每加仑卖 p[i] 美元的汽油。如果你在加油站 i 停下加油，你必须完全加满油箱。假设你从满箱开始，d[i] 是整数。使用动态规划找到最少费���的停车顺序。

1.  **Unix diff。** Unix `diff` 程序逐行比较两个文件，并打印出它们不同的地方。编写一个程序 Diff.java，逐行读取命令行指定的两个文件，计算每个文件的组成行序列上的 LCS，并打印出与 LCS 中的非匹配对应的任何行。

1.  **3 个字符串的最长公共子序列。** 给定 3 个字符串，使用动态规划找到最长的公共子序列。你的算法的运行时间和内存使用情况是多少？

1.  **找零。** 给定 A 张一百美元的钞票，B 张五十美元的钞票，C 张二十美元的钞票，D 张十美元的钞票，E 张五美元的钞票，F 张一美元的钞票，G 个半美元，H 个四分之一美元，I 个一角，J 个五分，和 K 个便士，确定是否可能找零 N 分。提示：背包问题。（贪心算法也可行。）

1.  **找零。** 假设你是一个收银员，在一个货币面额为：1, 3, 8, 16, 22, 57, 103 和 526 分的奇怪国家。描述一个动态规划算法，使用最少数量的硬币找零 c 分。*提示*：贪心算法不起作用，因为找零 114 分的最佳方式是 57 + 57 而不是 103 + 8 + 3。

1.  **最长递增序列。** 给定 N 个 64 位整数的数组，找到严格递增的最长子序列。

    *提示。* 计算原始数组和去除整数重复副本的数组的排序版本之间的最长公共子序列。

1.  **最长公共递增序列。** 计算生物学。给定两个 N 个 64 位整数的序列，找到两个序列中都存在的最长递增子序列。

1.  **带利润的活动选择。** 工作 i 具有开始时间 s_i，结束时间 f_i 和利润 p_i。找到最佳的工作子集进行安排。

1.  **Diff。** 编写一个程序，读取两个文件并打印出它们的 diff。将每行视为一个符号，并计算一个 LCS。打印出那些不在 LCS 中的每个文件的行。

1.  **背包问题。** Knapsack.java。

1.  **文本对齐。** 编写一个程序，接受一个命令行参数 N，从标准输入读取文本，并以每行最多 N 个字符的方式打印出文本。使用动态规划。

1.  **维特比算法。** 给定一个有向图，其中每条边都标有来自有限字母表的符号。是否有一条从一个特定顶点 x 开始的路径，与字符串 s 中的字符匹配？动态规划。A(i, v) = 0 或 1，如果有一条从 x 到 v 的路径消耗了 s 的前 i 个字符。A(i, v) = max (A(i-1, u) : (u, v) 在用 s[i] 标记的 E 中)。

1.  **Viterbi 算法。** 语音识别，手写分析，计算生物学，隐马尔可夫模型。假设离开 v 的每条边都有概率 p(v, w) 被遍历。路径的概率是该路径上概率的乘积。什么是最有可能的路径？动态规划。

1.  **Smith–Waterman 算法。** 局部序列比对。

1.  **二项式系数（暴力法）。** [二项式系数](https://en.wikipedia.org/wiki/Binomial_coefficient) C(n, k) 是从 n 个元素的集合中选择 k 个元素的方式数。它在概率和统计中出现。计算二项式系数的一个公式是 C(n, k) = n! / (k! (n-k)!). 这个公式不太适合直接计算，因为中间结果可能会溢出，即使最终答案没有溢出。例如 C(100, 15) = 253338471349988640 可以适应 64 位 `long`，但 100! 的二进制表示有 525 位长。

    *Pascal's identity* 用较小的二项式系数表示 C(n, k)：

    ![Pascal's identity](img/eede25bdbac3b755a5e4cdaea2743275.png)

    SlowBinomial.java 在中等规模的 n 或 k 下表现惨不忍睹，不是因为溢出，而是因为同样的子问题被重复解决。

    ```java
    // DO NOT RUN THIS CODE FOR LARGE INPUTS
    public static long binomial(int n, int k) {
        if (k == 0) return 1;
        if (n == 0) return 0;
        return binomial(n-1, k) + binomial(n-1, k-1);
    }

    ```

1.  **二项式系数（动态规划）。** 编写一个程序 Binomial.java，接受两个命令行参数 *n* 和 *k*，并使用自底向上的动态规划计算 *C*(*n*, *k*)。
