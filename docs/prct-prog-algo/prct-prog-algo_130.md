# 1\.   组合结构和普通生成函数

> 原文：[`ac.cs.princeton.edu/10ogf`](https://ac.cs.princeton.edu/10ogf)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


## I.1 符号枚举方法

## I.2 可接受的构造和规范整数组合

## I.3 整数组合和分区

## I.4 单词和正则语言

## I.5 树结构

## I.6 附加构造

## I.7 视角

#### 选定练习

## 注释 I.23

*爱丽丝、鲍勃和编码界限。* 爱丽丝想要通过一个传输`0,1`位的通道（一根电线，一根光纤）向鲍勃传递$n$位信息，但是任何`11`的出现都会终止传输。因此，她只能在通道上发送她的消息的编码版本（其中编码长度为$\ell\ge n$），不包含模式`11`。

这是一个第一个编码方案：给定消息$m=m_1m_2\cdots m_n$，其中$m_j\in\{{\sf 0,1}\}$，应用替换：$\sf 0\mapsto \sf 00$ ��� $\sf 1\mapsto\sf 10$；通过发送$\sf 11$来终止传输。这个方案的$\ell=2n+O(1)$，我们说它的*速率*为 2。能否设计出速率更好的编码？速率是否可以无限接近 1，渐近地？

让$\cal C$是允许的码字类。对于长度为$n$的单词，只有当存在从$\{0,1\}^n$到$\bigcup_{j=0}^L \cal C_j$的一一映射时，长度为$L\equiv L(n)$的码字才是可实现的，即$2^n\le \sum_{j=0}^L C_j$。找到$\cal C$的 OGF，并使用它来展示\[ L(n) \ge \lambda n +O(1), \qquad \lambda=\frac{1}{\log_2 \varphi}\doteq 1.440420, \quad \varphi=\frac{1+\sqrt{5}}{2}.\] 因此，没有码字可以实现比 1.44 更好的速率；即，至少会有 44%的损失是不可避免的。

## 注释 I.43

*Cayley-Polya 数的快速确定。* 使用$H(z)$的对数微分为$H_n$提供一个可以作为计算$H_n$的基础的递归，其时间复杂度为$n$的多项式时间。（注：类似的技术也适用于分区数$P_n$。）

#### 选定实验

## 程序 I.1

确定四枚硬币的选择，使得更换一美元的方式数量最大化。

## 程序 I.2

编写一个估计 Cayley 数增长率（$H_n/H_{n-1}$）的程序。参见注释 I.43。

## 程序 I.3

编写一个估计分区数增长率（$P_n/P_{n-1}$）的程序。参见注释 I.43。

#### 网络练习

## I.1

(R. Brott) 给出一个~的近似值，表示将$N$表示为 1、2 和 4 的和（无序）的方式的数量。例如，对于$N=4$，有四种这样的方式：1+1+1+1，1+1+2，2+2 和 4。

## I.2

(D. Carter) *加权树*是一棵根为根的有序树，其中每个节点被分配一个严格正整数权重。找到权重为$N$的加权树的总数的~近似值。
