# 5.4   正则表达式

> 原文：[`algs4.cs.princeton.edu/54regexp`](https://algs4.cs.princeton.edu/54regexp)

本节正在大力整理中。

## 正则表达式。

NFA.java, DFS.java, Digraph.java, 和 GREP.java.

## 运行时间。

M = 表达式长度，N = 输入长度。正则表达式匹配算法可以在 O(M)时间内创建 NFA，并在 O(MN)时间内模拟输入。

## 库实现。

Validate.java。

大多数正则表达式库实现使用*回溯算法*，在某些输入上可能需要指数级的时间。这样的输入可能非常简单。例如，确定长度为 N 的字符串是否与正则表达式`(a|aa)*b`匹配，如果选择字符串得当，可能需要指数级的时间。下表展示了 Java 1.4.2 正则表达式的失败情况。

```java
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaac             1.6 seconds
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac           3.7 seconds
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac         9.7 seconds
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac      23.2 seconds
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac    62.2 seconds
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac 161.6 seconds

```

```java
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaac           1.28
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaac          2.45
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaaac         4.54
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaaaac        8.84
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaaaaac      17.74
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaaaaaac     33.77
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaaaaaaac    67.72
java Validate "(a*)*|b*" aaaaaaaaaaaaaaaaaaaaaaaaaaaac  134.73

```

上述示例是人为的，但它们展示了大多数正则表达式库中的一个令人担忧��缺陷。在实践中确实会出现不良输入。根据[Crosby 和 Wallach](http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf)的说法，以下正则表达式出现在 SpamAssassin 的一个版本中，这是一个功能强大的垃圾邮件过滤程序。

```java
[a-z]+@[a-z]+([a-z\.]+\.)+[a-z]+

```

它试图匹配某些电子邮件地址，但在许多正则表达式库中，包括 Sun 的 Java 1.4.2 中，匹配某些字符串需要指数级的时间。

```java
java Validate "[a-z]+@[a-z]+([a-z\.]+\.)+[a-z]+" spammer@x......................

```

这尤其重要，因为垃圾邮件发送者可以使用一种病态的返回电子邮件地址来拒绝服务攻击一个运行 SpamAssassin 的邮件服务器。这个特定的模式现在已经修复，因为 Perl 5 正则表达式使用内部缓存来在回溯过程中在相同位置短路重复匹配。

这些缺陷不仅限于 Java 的实现。例如，GNU regex-0.12 对于匹配形式为`aaaaaaaaaaaaaac`的字符串与正则表达式`(a*)*|b*`需要指数级的时间。Sun 的 Java 1.4.2 同样容易受到这个问题的影响。此外，Java 和 Perl 正则表达式支持反向引用 - 对于这些扩展正则表达式的正则表达式模式匹配问题是[NP 难的](http://perl.plover.com/NPC/)，因此在某些输入上这种指数级的增长似乎是固有的。

这是我实际写的一个，用来找到字符串`NYSE`之前的最后一个单词：regexp = "([\\w\\s]+).*NYSE";

参考：[正则表达式匹配可以简单快速（但在 Java、Perl、PHP、Python、Ruby 等中很慢）](http://swtch.com/~rsc/regexp/regexp1.html)。比较了 Thompson NFA 和回溯方法。包含了一些针对 Thompson NFA 的性能优化。还有一些历史注释和参考资料。

#### Q + A

**Q.** Java 正则表达式库的文档？

**A.** 这里是 Oracle 关于[使用正则表达式的指南](http://docs.oracle.com/javase/tutorial/essential/regex/)。它包括[更多操作](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html)，我们不会探索。还请参阅`String`方法`matches()`、`split()`和`replaceAll()`。这些是使用`Pattern`和`Matcher`类的简写。这里有一些[常见的正则表达式模式](http://javaalmanac.com/cgi-bin/search/find.pl?words=regex)。

**Q.** 用于电子邮件地址、Java 标识符、整数、小数等的工业级别正则表达式？

**A.** 这里有一个[有用的正则表达式库](http://regexlib.com/)，提供了工业级别的模式，用于匹配电子邮件地址、URL、数字、日期和时间。试试这个[正则表达式工具](http://www.weitz.de/regex-coach/)。

**Q.** 我困惑为什么`(a | b)*`匹配所有的 a 和 b 的字符串，而不仅仅是所有 a 的字符串或所有 b 的字符串？

**A.** *操作符复制正则表达式（而不是匹配正则表达式的固定字符串）。因此，上述等同于ε | (a|b) | (a|b)(a|b) | (a|b)(a|b)(a|b) | ....

**Q.** 历史？

**A.** 在 1940 年代，沃伦·麦卡洛克和沃尔特·皮茨将神经元建模为有限自动机来描述神经系统。1956 年，史蒂夫·克利纳发明了一种数学抽象称为*正则集*来描述这些模型。*神经网络和有限自动机中事件的表示*，《自动机研究》，3-42 页，普林斯顿大学出版社，新泽西州普林斯顿，1956 年。

**Q.** 有哪些可视化正则表达式的工具？

**A.** 尝试[Debuggerx](http://www.debuggex.com)。

#### 练习

1.  为以下每组二进制字符串编写正则表达式。只使用基本操作。

    1.  0 或 11 或 101

    1.  只有 0

    *答案*：0 | 11 | 101, 0*

1.  为以下每组二进制字符串编写正则表达式。只使用基本操作。

    1.  所有二进制字符串

    1.  所有二进制字符串，除了空字符串

    1.  以 1 开头，以 1 结尾

    1.  以 00 结尾

    1.  包含至少三个 1

    *答案*：(0|1)*, (0|1)(0|1)*, 1 | 1(0|1)*1, (0|1)*00, (0|1)*1(0|1)*1(0|1)*1(0|1)*或 0*10*10*1(0|1)*。

1.  编写一个正则表达式描述字母表{a, b, c}上按排序顺序的输入。*答案*：a*b*c*。

1.  为以下每组二进制字符串编写正则表达式。只使用基本操作。

    1.  包含至少三个连续的 1

    1.  包含子串 110

    1.  包含子串 1101100

    1.  不包含子串 110

    *答案*：(0|1)*111(0|1)*, (0|1)*110(0|1)*, (0|1)*1101100(0|1)*, (0|10)*1*。最后一个是最棘手的。

1.  为至少有两个 0 但不连续的 0 的二进制字符串编写正则表达式。

1.  为以下每组二进制字符串编写正则表达式。只使用基本操作。

    1.  至少有 3 个字符，并且第三个字符为 0

    1.  0 的数量是 3 的倍数

    1.  以相同字符开头和结尾

    1.  奇数长度

    1.  以 0 开头且长度为奇数，或以 1 开头且长度为偶数

    1.  长度至少为 1 且最多为 3

    *答案*：(0|1)(0|1)0(0|1)*,   1* | (1*01*01*01*)*,   1(0|1)*1 | 0(0|1)*0 | 0 | 1,   (0|1)((0|1)(0|1))*,   0((0|1)(0|1))* | 1(0|1)((0|1)(0|1))*,   (0|1) | (0|1)(0|1) | (0|1)(0|1)(0|1)。

1.  对于以下每个问题，指出有多少长度为 1000 的位字符串与正则表达式匹配：`0(0 | 1)*1`，`0*101*`，`(1 | 01)*`。

1.  编写一个正则表达式，匹配字母表{a, b, c}中包含的所有字符串：

    1.  以 a 开头且以 a 结尾

    1.  最多一个 a

    1.  至少有两个 a

    1.  偶数个 a

    1.  a 的数量加上 b 的数量为偶数

1.  找出字母按字母顺序排列的长单词，例如，`almost`和`beefily`。*答案*：使用正则表达式'^a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*$'。

1.  编写一个 Java 正则表达式，匹配电话号码，带有或不带有区号。区号应为(609) 555-1234 或 555-1234 的形式。

1.  找出所有以`nym`结尾的英语单词。

1.  找出所有包含三连字母`bze`的英语单词。*答案*：subzero。

1.  找出所有以 g 开头，包含三连字母`pev`且以 e 结尾的英语单词。*答案*：grapevine。

1.  找出所有包含三个 r 且至少有两个 r 的英语单词。

1.  找出可以用标准键盘顶行写出的最长英语单词。*答案*：proprietorier。

1.  找出所有包含字母 a、s、d 和 f 的单词，不一定按照顺序。*解决方案*：`cat words.txt | grep a | grep s | grep d | grep f`。

1.  给定一个由 A、C、T 和 G 以及 X 组成的字符串，找到一个字符串，其中 X 匹配任何单个字符，例如，CATGG 包含在 ACTGGGXXAXGGTTT 中。

1.  编写一个 Java 正则表达式，用于 Validate.java，验证形式为 123-45-6789 的社会安全号码。*提示*：使用`\d`表示任何数字。*答案*：`[0-9]{3}-[0-9]{2}-[0-9]{4}`。

1.  修改上一个练习，使`-`成为可选项，这样 123456789 就被视为合法输入。

1.  编写一个 Java 正则表达式，匹配包含恰好五个元音字母且元音字母按字母顺序排列的所有字符串。 *答案:* `[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*`

1.  编写一个 Java 正则表达式，匹配有效的 Windows XP 文件名。这样的文件名由除了冒号以外的任意字符序列组成。

    ```java
    / \ : * ? " < > |

    ```

    此外，它不能以空格或句号开头。

1.  编写一个 Java 正则表达式，描述有效的 OS X 文件名。这样的文件名由除冒号以外的任意字符序列组成。此外，它不能以句点开头。

1.  给定一个代表 IP 地址的名称为`s`的字符串，采用*dotted quad*表示法，将其分解为其组成部分，例如，255.125.33.222。确保四个字段都是数字。

1.  编写一个 Java 正则表达式，描述形式为*Month DD, YYYY*的所有日期，其中*Month*由任意大写或小写字母字符串组成，日期是 1 或 2 位数字，年份正好是 4 位数字。逗号和空格是必需的。

1.  编写一个 Java 正则表达式，描述形式为 a.b.c.d 的有效 IP 地址，其中每个字母可以表示 1、2 或 3 位数字，句点是必需的。是：196.26.155.241。

1.  编写一个 Java 正则表达式，匹配以 4 位数字开头并以两个大写字母结尾的车牌。

1.  编写一个正则表达式，从 DNA 字符串中提取编码序列。它以 ATG 密码子开头，以停止密码子（TAA、TAG 或 TGA）结尾。[参考](http://bioportal.weizmann.ac.il/course/prog/regexps/5.html)

1.  编写一个正则表达式来检查序列 rGATCy：即，它是否以 A 或 G 开头，然后是 GATC，最后是 T 或 C。

1.  编写一个正则表达式来检查一个序列是否包含两个或更多次重复的 GATA 四核苷酸。

1.  修改 Validate.java 使搜索不区分大小写。 *提示:* 使用`(?i)`嵌入式标志。

1.  编写一个 Java 正则表达式，匹配利比亚独裁者穆阿迈尔·卡扎菲姓氏的各种拼写，使用以下模板：(i)以 K、G、Q 开头，(ii)可选地跟随 H，(iii)后跟 AD，(iv)可选地跟随 D，(v)可选地跟随 H，(vi)可选地跟随 AF，(vii)可选地跟随 F，(vii)以 I 结尾。

1.  编写一个 Java 程序，读取类似`(K|G|Q)[H]AD[D][H]AF[F]I`的表达式，并打印出所有匹配的字符串。这里的符号`[x]`表示字母`x`的 0 或 1 个副本。

1.  为什么`s.replaceAll("A", "B");`不会替换字符串`s`中所有出现的字母 A 为 B？

    *答案*：使用`s = s.replaceAll("A", "B");`代替。`replaceAll`方法返回结果字符串，但不会改变`s`本身。字符串是不可变的。

1.  编写一个程序 Clean.java，从标准输入中读取文本并将其打印出来，在一行上去除任何尾随空格，并用 4 个空格替换所有制表符。

    *提示:* 使用`replaceAll()`和正则表达式`\s`匹配空格。

1.  编写一个正则表达式，匹配在文本`a href ="`和下一个`"`之间的所有文本。 *答案:* `href=\"(.*?)\"`。`?`使`.*`变得不贪婪而是懒惰。在 Java 中，使用`Pattern.compile("href=\\\"(.*?)\\\"", Pattern.CASE_INSENSITIVE)`来转义反斜杠字符。

1.  使用正则表达式提取在`<title>`和`<\title>`标签之间的所有文本。`(?i)`是另一种使匹配不区分大小写的方法。`$2`指的是第二个捕获的子序列，即`title`标签之间的内容。

    ```java
    String pattern = "(?i)(<title.*?>)(.+?)(</title>)"; 
    String updated =  s.replaceAll(pattern, "$2");

    ```

1.  编写一个正则表达式来匹配在<TD ...>和</TD>标签之间的所有文本。 *答案*：`<TD[^>]*>([^<]*)</TD>`

#### 创意练习

1.  **FMR-1 三联重复区域。** “人类 FMR-1 基因序列包含一个三联重复区域，在该区域中序列 CGG 或 AGG 重复多次。三联体的数量在个体之间高度变化，增加的拷贝数与脆性 X 综合征相关，这是一种导致 2000 名儿童中的一名智力残疾和其他症状的遗传疾病。”（参考：Durbin 等人的《生物序列分析》）。该模式由 GCG 和 CTG 括起来，因此我们得到正则表达式 GCG (CGG | AGG)* CTG。

1.  **广告拦截。** [Adblock](http://adblock.mozdev.org/) 使用正则表达式来阻止 Mozilla 和 Firebird 浏览器下的横幅广告。

1.  **解析文本文件。** 一个更高级的例子，我们想要提取匹配输入的特定部分。这个程序代表了解析科学输入数据的过程。

1.  **PROSITE 到 Java 正则表达式。** 编写一个程序，读取 PROSITE 模式并打印出相应的 Java 正则表达式。PROSITE 是蛋白质家族和结构域的“第一个和最著名”的数据库。其主要用途是确定从基因组序列翻译而来的未知功能蛋白质的功能。生物学家使用[PROSITE](http://us.expasy.org/tools/scanprosite/scanprosite-doc.html) 模式语法规则在生物数据中搜索模式。这是[CBD FUNGAL](http://us.expasy.org/cgi-bin/get-prosite-raw.pl?PS00562)（访问代码 PS00562）的原始数据。每行包含各种信息。也许最有趣的一行是以 PA 开头的行 - 它包含描述蛋白质基序的模式。这些模式很有用，因为它们通常对应于功能或结构特征。

    ```java
    PA   C-G-G-x(4,7)-G-x(3)-C-x(5)-C-x(3,5)-[NHG]-x-[FYWM]-x(2)-Q-C.

    ```

    每个大写字母对应一个氨基酸残基。字母表由对应于 2x 氨基酸的大写字母组成。连字符`-`表示连接。例如，上面的模式以 CGG（Cys-Gly-Gly）开头。符号`x`扮演通配符的角色 - 它匹配任何氨基酸。这对应于我们符号中的`.`。括号用于指定重复：`x(2)`表示恰好两个氨基酸，`x(4,7)`表示 4 到 7 个氨基酸。这对应于 Java 符号中的`.{2}`和`.{4,7}`。花括号用于指定禁止的残基：{CG}表示除 C 或 G 之外的任何残基。星号具有其通常的含义。

1.  **文本转语音合成。** grep 的原始动机。“例如，如何处理发音多种不同的二连音 ui：fruit, guile, guilty, anguish, intuit, beguine？”

1.  **具有挑战性的正则表达式。** 为以下每组二进制字符串编写一个正则表达式。只使用基本操作。

    1.  除了 11 或 111 之外的任何字符串

    1.  每个奇数符号是 1

    1.  包含至少两个 0 和最多一个 1

    1.  没有连续的 1s

1.  **二进制可被整除。** 为以下每组二进制字符串编写一个正则表达式。只使用基本操作。

    1.  以二进制数解释的比特串可被 3 整除

    1.  以二进制数解释的比特串可被 123 整除

1.  **波士顿口音。** 编写一个程序，将所有的 r 替换为 h，将句子翻译成波士顿版本，例如将“Park the car in Harvard yard”翻译为波士顿版本的“Pahk the cah in Hahvahd yahd”。

1.  **文件扩展名。** 编写一个程序，以文件名作为命令行参数，并打印出其文件类型扩展名。*扩展名*是跟在最后一个`.`后面的字符序列。例如，文件`sun.gif`的扩展名是`gif`。提示：使用`split("\\.")`；请记住`.`是一个正则表达式元字符，因此您需要转义它。

1.  **反向子域。** 为了进行网络日志分析，方便地根据子域（如`wayne.faculty.cs.princeton.edu`）组织网络流量。编写一个程序来读取域名并以反向顺序打印出来，如`edu.princeton.cs.faculty.wayne`。

1.  **银行抢劫。** 你刚刚目睹了一起银行抢劫案，并且得到了逃跑车辆的部分车牌号。它以`ZD`开头，中间有一个`3`，以`V`结尾。帮助警官写出这个车牌的正则表达式。

1.  **排列的正则表达式。** 找到 N 个元素的所有排列集合的最短正则表达式（仅使用基本操作），其中 N = 5 或 10。例如，如果 N = 3，则语言是 abc，acb，bac，bca，cab，cba。*答案：*困难。解决方案的长度与 N 呈指数关系。

1.  **解析带引号的字符串。** 读取一个文本文件并打印出所有带引号的字符串。使用类似`"[^"]*"`的正则表达式，但需要担心转义引号。

1.  **解析 HTML。** 一个>，可选地跟随空格，后跟`a`，后跟空格，后跟`href`，可选地跟随空格，后跟`=，可选地跟随空格，后跟`"http://`，后跟字符直到`"，可选地跟随空格，然后是一个<。

    ```java
    < \s* a \s+ href \s* = \s* \\"http://[^\\"]* \\" \s* >

    ```

1.  **子序列。** 给定一个字符串`s`，确定它是否是另一个字符串`t`的子序列。例如，abc 是 achfdbaabgabcaabg 的一个子序列。使用正则表达式。现在不使用正则表达式重复这个过程。答案：(a) a.*b.*c.*，(b) 使用贪婪算法。

1.  **亨廷顿病诊断。** 导致亨廷顿病的基因位于染色体 4 上，并且具有可变数量的 CAG 三核苷酸重复。编写一个程序来确定重复次数并打印`不会患 HD`，如果重复次数少于 26，则打印`后代有风险`，如果数字为 37-35，则打印`有风险`，如果数字在 36 和 39 之间，则打印`将患 HD`。这就是遗传测试中识别亨廷顿病的方式。

1.  **基因查找器。** 基因是基因组的一个子字符串，以起始密码子（ATG）开始，以终止密码子（TAG，TAA，TAG 或 TGA）结束，并由除起始或终止密码子之外的密码子序列（核苷酸三联体）组成。基因是起始和终止密码子之间的子字符串。

1.  **重复查找器。** 编写一个程序`Repeat.java`，它接受两个命令行参数，并查找指定由第二个命令行参数指定的文件中第一个命令行参数的最大重复次数。

1.  **字符过滤器。** 给定一个包含*坏字符*的字符串`t`，例如`t = "!@#$%^&*()-_=+"`，编写一个函数来读取另一个字符串`s`并返回删除所有坏字符后的结果。

    ```java
    String pattern = "[" + t + "]";
    String result  = s.replaceAll(pattern, "");

    ```

1.  **通配符模式匹配器。** 不使用 Java 内置的正则表达式，编写一个程序 Wildcard.java 来查找与给定模式匹配的字典中的所有单词。特殊符号*匹配任意零个或多个字符。因此，例如模式"w*ard"匹配单词"ward"和"wildcard"。特殊符号.匹配任何一个字符。您的程序应将模式作为命令行参数读取，并从标准输入读取单词列表（由空格分隔）。

1.  **通配符模式匹配器。** 重复上一个练习，但这次使用 Java 内置的正则表达式。*警告：*在通配符的上下文中，*的含义与正则表达式不同。

1.  **搜索和替换。** 文字处理器允许您搜索给定查询字符串的所有出现并用另一个替换字符串替换每个出现。编写一个程序 SearchAndReplace.java，它接受两个字符串作为命令行输入，从标准输入读取数据，并用第一个字符串替换所有出现的第一个字符串，并将结果发送到标准输出。*提示：*使用方法`String.replaceAll`。

1.  **密码验证器。** 假设出于安全原因，您要求所有密码至少包含以下字符之一

    ```java
    ~ ! @ # $ % ^ & * | 

    ```

    为`String.matches`编写一个正则表达式，如果密码包含所需字符之一，则返回`true`。*答案*："^[^~!@#$%^&*|]+$"

1.  **字母数字过滤器。** 编写一个程序 Filter.java，从标准输入中读取文本，并消除所有不是空格或字母数字的字符。*答案* 这是关键行。

    ```java
    String output = input.replaceAll("[^\\s0-9a-zA-Z]", "");

    ```

1.  **将制表符转换为空格。** 编写一个程序，将 Java 源文件中的所有制表符转换为 4 个空格。

1.  **解析分隔文本文件。** 存储数据库的一种流行方式是将其存储在一个文本文件中，每行一个记录，每个字段由称为分隔符的特殊字符分隔。

    ```java
    19072/Narberth/PA/Pennsylvania
    08540/Princeton/NJ/New Jersey

    ```

    编写一个程序 Tokenizer.java，它读取两个命令行参数，一个是分隔符字符，另一个是文件名，并创建一个标记数组。

1.  **解析分隔文本文件。** 重复上一个练习，但使用`String`库方法`split()`。

1.  **检查文件格式。**

1.  **拼写错误。** 编写一个 Java 程序，验证这个常见拼写错误列表中只包含形式为的行

    ```java
    misdemenors (misdemeanors)
    mispelling (misspelling)
    tennisplayer (tennis player)

    ```

    第一个单词是拼写错误，括号中的字符串是可能的替换。

1.  [有趣的英语单词](http://rec-puzzles.org/new/sol.pl/language/english/spelling/single.words)

1.  **DFA 的大小与 RE 的大小呈指数关系。** 给出一个 RE，用于表示所有最后一个字符为 1 的比特串集合。RE 的大小应该与 k 成线性关系。现在，给出同一组比特串的 DFA。它使用了多少个状态？

    *提示*：对于这组比特串，每个确定有限自动机（DFA）至少需要有 2^k 个状态。
