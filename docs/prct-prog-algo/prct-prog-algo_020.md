# 4.1   算法分析

> 原文：[`introcs.cs.princeton.edu/java/41analysis`](https://introcs.cs.princeton.edu/java/41analysis)

在本节中，您将学会在编程时尊重一个原则：*注意成本。* 为了研究运行它们的成本，我们通过*科学方法*研究我们的程序本身。我们还应用数学分析来推导成本的简洁模型。

## 科学方法。

以下五步方法总结了科学方法：以下 5 步方法。

+   *观察*自然界的某些特征。

+   *假设*一个与观察结果一致的模型。

+   使用假设*预测*事件。

+   通过进一步观察*验证*预测。

+   通过重复直到假设和观察结果一致来*验证*。

我们设计的实验必须是*可重现的*，我们制定的假设必须是*可证伪的*。

## 观察结果。

测量程序的确切运行时间很困难，但有许多工具可用于帮助。在本书中，我们简单地在各种输入上运行程序，并使用 Stopwatch.java 数据类型测量处理每个输入所需的时间量。关于大多数程序的第一个定性观察是，存在一个*问题规模*来表征计算任务的难度。通常，问题规模要么是输入的大小，要么是命令行参数的值。直观地，运行时间应该随问题规模增加而增加，但每次我们开发和运行程序时都会自然地产生一个*增加多少*的问题。

## 一个具体的例子。

为了说明这种方法，我们从 ThreeSum.java 开始，它计算一个包含\(n\)个整数的数组中总和为 0 的三元组的数量。问题规模\(n\)与`ThreeSum`的运行时间之间的关系是什么？

+   *加倍假设。* 对于许多程序，我们可以快速为以下问题制定一个假设：*将输入大小加倍对运行时间有什么影响？*

+   *经验分析。* 制定加倍假设的一种简单方法是将输入大小加倍并观察对运行时间的影响。DoublingTest.java 为`ThreeSum`生成一系列随机输入数组，每一步将数组长度加倍，并打印`ThreeSum.count()`对于每个输入的运行时间与前一个（大小为前一个的一半）的比率。如果您运行此程序，您会发现每行打印的经过时间增加了大约 8 倍。这立即导致假设：当输入大小加倍时，运行时间增加了 8 倍。

+   *对数-对数图。* 我们也可以在标准图（左侧）或对数-对数图（右侧）上绘制运行时间。对数-对数图是一条斜率为 3 的直线，清楚地表明运行时间满足\(cn³\)形式的幂律的假设。

    > ![对数-对数图](img/43cd93992de0ee76bf8850abdf320bbf.png)           ![对数-对数图](img/5eb5b8c5bd13dddb20b385364371977f.png)

+   *数学分析。* 总运行时间由两个主要因素决定：

    +   每个语句的执行成本。

    +   每个语句的执行频率。

    前者是系统的属性，后者是算法的属性。如果我们知道程序中所有指令的这两个属性，我们可以将它们相乘并对程序中所有指令求和，以获得运行时间。

    主要挑战在于确定语句的执行频率。有些语句很容易分析：例如，在`ThreeSum.count()`中将`count`设置为`0`的语句只执行一次。其他语句需要更高级别的推理：例如，在`ThreeSum.count()`中的`if`语句被执行了精确地\(n(n-1)(n-2) / 6\)次。

## 波浪线符号。

我们使用*波浪符号表示法*来开发更简单的近似表达式。首先，我们通过使用称为波浪符号的数学工具处理数学表达式的*主导项*。我们写\( \sim g(n)\)来表示任何数量，当除以\(f(n)\)时，随着\(n\)的增长趋近于 1。我们还写\(g(n) \sim f(n)\)来表示当\(n\)增长时，\(g(n) \,/\, f(n)\)趋近于 1。使用这种符号，我们可以忽略表示小值的表达式的复杂部分。例如，在`ThreeSum.count()`中的`if`语句执行\(\sim n³ / 6 \)次，因为\(n(n-1)(n-2) / 6 = n³/6 - n²/2 + n/3\)，当除以\(n³/6\)时，随着\(n\)的增长趋近于 1。

我们关注执行频率最高的指令，有时被称为程序的*内循环*。在这个程序中，合理假设是，内循环之外的指令所花费的时间相对不重要。

## 增长顺序。

分析程序运行时间的关键点在于：对于许多程序，运行时间满足关系\(T(n) \sim c f(n)\)，其中\(c\)是一个常数，\(f(n)\)是称为运行时间*增长顺序*的函数。对于典型程序，\(f(n)\)是诸如\(\log_2 n, n, n \log_2 n, n²,\)或\(n³\)的函数。

`ThreeSum.count()`的运行时间增长顺序为\(n³\)。常数\(c\)的值取决于执行指令的成本和频率分析的细节，但通常我们不需要计算出具体数值。了解增长顺序通常会立即导致一个倍增假设。对于`ThreeSum.count()`，知道增长顺序为\(n³\)告诉我们，当问题规模加倍时，预计运行时间会增加 8 倍，因为

> $$\lim_{n\to\infty} \frac{T(2n)}{T(n)} \;=\; \frac{c (2n)³}{c (n)³} \;=\; 8$$

## 增长顺序分类。

我们只使用几个结构原语（语句、条件、循环和方法调用）来构建 Java 程序，因此我们的程序的增长顺序往往是问题规模的几个函数之一，总结在下表中。

> ![增长顺序分类](img/e83ce4673f99241e1c4847275de16dfa.png)

## 估算内存使用量。

要注意成本，您需要了解内存使用情况。Java 在您的计算机上的内存使用情况是明确定义的（每次运行程序时，每个值将需要完全相同的内存量），但 Java 在各种计算设备上实现，内存消耗取决于实现。

+   *基本类型.* 例如，由于 Java `int`数据类型是介于-2,147,483,648 和 2,147,483,647 之间的整数值集合，共 2³²个不同的值，因此可以合理地期望实现使用 32 位来表示`int`值。

    > ![Java 中基本类型的典型内存使用情况](img/c87ab1386811254355161c8abbf35129.png)

+   *对象.* 要确定对象的内存消耗，我们将每个实例变量使用的内存量与每个对象通常使用的 8 字节开销相加。例如，一个 Complex.java 对象使用 32 字节（16 字节的开销，加上其两个`double`实例变量的每个 8 字节）。 

    > ![复杂对象的典型内存使用情况](img/637996c882529e16aebf3e2c21c2aaac.png)

    引用对象通常使用 8 字节的内存。当数据类型包含对对象的引用时，我们必须单独考虑引用的 8 字节和每个对象的 16 字节开销，*再加上*对象实例变量所需的内存。

+   *数组和字符串。* Java 中的数组是作为对象实现的，通常具有两个实例变量（指向第一个数组元素的内存位置的指针和长度）。对于原始类型，包含\(n\)个元素的数组使用 24 字节的头信息，加上\(n\)乘以存储一个元素所需的字节数。在 Java 中，二维数组是数组的数组。例如，一个\(n\)乘以\(n\)的整数数组使用大约\(4n²\)字节的内存。长度为\(n\)的字符串使用\(56 + 2n\)字节的内存。

    > ![Java 中变长数据类型的典型内存使用情况](img/72ba5d3b641a70a92e6ca60eacad094d.png)

详细信息请参阅教科书。

#### 练习

1.  为 ThreeSum.java 实现方法`printAll()`，打印所有总和为零的三元组。

1.  编写一个程序 FourSum.java，从标准输入读取一个整数`long`整数，并计算总和为零的 4 元组的数量。使用四重嵌套循环。你的程序的运行时间增长阶数是多少？估计你的程���在一个小时内可以处理的最大输入大小。然后，运行你的程序验证你的假设。

1.  在运行以下代码片段后，变量`count`的值作为\(n\)的函数是多少？

    ```java
    int count = 0;
    for (int i = 0; i < n; i++)
        for (int j = i+1; j < n; j++)
            for (int k = j+1; k < n; k++)
                count++;

    ```

    *解决方案*：\( \displaystyle { n \choose 3} = n (n-1) (n-2) / 6\).

1.  确定`ThreeSum`中此语句的运行时间作为标准输入上整数数量*n*的函数的增长阶数：

    ```java
    int[] a = StdIn.readAllInts();

    ```

    *解决方案*：线性。瓶颈是数组初始化和输入循环。然而，根据你的系统，像这样的输入循环的成本可能会在线性对数时间甚至二次时间程序中占主导地位，除非输入大小足够大。

1.  你更喜欢二次、线性对数还是线性算法？

    *解决方案*：虽然根据增长阶数做出快速决定很诱人，但这样做很容易被误导。你需要对问题规模和运行时间的主导系数的相对值有一些概念。例如，假设运行时间分别为\(n²\)秒，\(100 n \log_2 n\)秒和\(10000 n\)秒。对于\(n\)小于约\(1000\)的情况，二次算法将是最快的，而线性算法永远不会比线性对数算法更快（\(n\)必须大于\(2^{100}\)，远远大于考虑的范围）。

1.  运用科学方法，针对以下两个代码片段的运行时间作为\(n\)的函数，发展和验证一个关于增长阶数的假设。

    ```java
    String s = ""; 
    for (int i = 0; i < n; i++) {
        if (StdRandom.bernoulli(0.5)) s += "0"; 
        else                          s += "1"; 
    }

    StringBuilder sb = new StringBuilder(); 
    for (int i = 0; i < n; i++) {
        if (StdRandom.bernoulli(0.5)) sb.append("0"); 
        else                          sb.append("1"); 
    }
    String s = sb.toString(); 

    ```

    *解决方案*：第一个是二次的；第二个是线性的。

1.  给出一个线性时间的反转字符串算法。

    *解决方案*：

    ```java
    public static String reverse(String s) {
        int n = s.length();
        char[] a = new char[n];
        for (int i = 0; i < n; i++)
           a[i] = s.charAt(n-i-1);
        String reverse = new String(a);
        return reverse;
    }

    ```

#### 创意练习

1.  **子集求和。** 编写一个程序 SubsetSum.java，从标准输入读取`long`整数，并计算这些整数的子集中总和恰好为零的数量。给出你的算法的增长阶数。

1.  **亚指数函数。** 寻找一个增长阶数大于任何多项式函数，但小于任何指数函数的函数。 *额外加分*：找到一个运行时间具有该增长阶数的程序。

    *解决方案*：\(n^{\ln n}\).

#### 网页练习

1.  假设算法在输入大小为 1,000、2,000、3,000 和 4,000 时的运行时间分别为 5 秒、20 秒、45 秒和 80 秒。估计解决大小为 5,000 的问题需要多长时间。运行时间的增长阶数是线性、线性对数、二次、三次还是指数？

    *解决方案*：125 秒，二次。

1.  编写一个程序 OneSum.java，从标准输入读取一系列整数并计算其中值为 0 的数量。数据处理循环中执行了多少条指令？

1.  编写一个程序 TwoSum.java，从标准输入中读取一系列整数，并计算总共有多少对数的和恰好为 0。在数据处理循环中执行了多少条指令？

1.  分析以下代码片段的数学特性，并确定其运行时间的增长顺序是线性、二次还是立方的关于*n*的函数。

    ```java
    for (int i = 0; i < n; i++)
       for (int j = 0; j < n; j++)
          for (int k = 0; k < n; k++)
             c[i][j] += a[i][k] * b[k][j];

    ```

1.  以下函数返回一个长度为*n*的随机字符串。作为*n*的函数，其运行时间的增长顺序是多少？

    ```java
    public static String random(int n) {
        if (n == 0) return "";
        int r = StdRandom.uniform(26);     // between 0 and 25
        char c = 'a' + r;                  // between 'a' and 'z'
        return random(n/2) + c + random(n - n/2 - 1);
    }

    ```

1.  **埃拉托斯特尼筛法。** 作为*n*的函数，估计埃拉托斯特尼筛法寻找小于或等于*n*的所有质数的运行时间的增长顺序。

    *解决方案*：理论上，增长顺序是*n*对数对数*n*。这源自数论中的 Mertens 定理。实际上，很难识别出对数对数*n*的因子。
