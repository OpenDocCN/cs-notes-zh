# 6.1 表示信息

> 原文：[`introcs.cs.princeton.edu/java/61data`](https://introcs.cs.princeton.edu/java/61data)

一切适合数字计算机处理的内容都表示为一系列 0 和 1，无论是数字数据、文本、可执行文件、图像、音频还是视频。计算机中给定一系列比特的含义取决于上下文。在本节中，我们描述了如何以二进制、十进制和十六进制表示整数，以及如何在不同表示之间进行转换。我们还描述了如何表示负整数和浮点数。

## 二进制和十六进制。

自巴比伦时代以来，人们一直使用具有固定基数的*位置表示法*来表示整数。其中最熟悉的系统之一是*十进制*，其中基数为 10，每个正整数表示为介于 0 和 9 之间的数字字符串。具体来说，\( d_n d_{n-1} \ldots d_2 d_1 d_0 \)表示整数

> $$\quad\quad\quad\quad\quad\;\; d_n10^n + d_{n-1}10^{n-1} + \ldots + d_210² + d_110¹ + d_010⁰$$

例如，`10345`表示整数 10,345 = 1·10⁴ + 0·10³ + 3·10² + 4·10¹ + 5·10⁰。

+   *二进制*。当基数为 2 时，我们将整数表示为一系列 0 和 1。在这种情况下，我们将每个二进制（基数 2）数字——0 或 1——称为*比特*。具体来说，\(b_n b_{n-1} \ldots b_2 b_1 b_0\)表示整数

    > $$\quad\quad\quad\quad b_n 2^n + b_{n-1} 2^{n-1} + \ldots + b_2 2² + b_1 2¹ + b_0 2⁰$$

    例如，`1100011`表示整数 99 = 1·2⁶ + 1·2⁵ + 0·2⁴ + 0·2³ + 0·2² + 1·2¹ + 1·2⁰。

+   *十六进制*。![十六进制数字](img/8f15cc32db92a0b8c27d1e0e64220bfa.png) 在十六进制（或*hex*）中，十六进制数字序列具体表示为\(h_n h_{n-1} \ldots h_2 h_1 h_0\)表示整数

    > $$\quad\quad\quad\quad\;\; h_n 16^n + h_{n-1} 16^{n-1} + \ldots + h_2 16² + h_1 16¹ + h_0 16⁰$$

    我们需要一个字符来表示每个数字，因此我们使用`A`表示 10，`B`表示 11，`C`表示 12，依此类推。例如，`FACE`表示整数 64,206 = 15·16³ + 10·16² + 12·16¹ + 14·16⁰。

## 数字转换。

您需要知道如何将一个系统中表示的数字转换为另一个系统中的数字。

+   *十六进制和二进制之间的转换*。给定一个数字的十六进制表示，找到二进制表示很容易，反之亦然，因为 16 是 2 的幂。要从十六进制转换为二进制，将每个十六进制数字替换为对应值的四个二进制位。反之，要从二进制转换为十六进制，添加前导 0 使位数成为 4 的倍数，然后每 4 位分组并将每组转换为单个十六进制数字。

    > ![十六进制到二进制的转换](img/767bddd7bb383d475425d3678deb2d04.png)         ![二进制到十六进制的转换](img/aa15177682b2e5de51d375aa4b5e07cd.png)

+   *从十进制到基数 b 的转换*。将一个以十进制表示的整数转换为基数*b*的整数稍微困难一些，因为我们习惯于在十进制中进行算术运算。手动从十进制转换为基数*b*的最简单方法是反复除以基数*b*，并从上往下读取余数。例如，下面的计算将十进制整数 366 转换为二进制（101101110）和十六进制（16E）。

    > ![从十进制到二进制的转换](img/c1db22af82dd7c689f6f8f1cb2e9d5c3.png)

+   *解析和字符串表示.* 将一串字符转换为内部表示称为*解析*。首先，我们考虑一个方法`parseInt()`来解析以任何进制编写的整数。接下来，我们考虑一个`toString()`方法来计算给定进制中整数的字符串表示。BinaryConverter.java 提供了将一串位转换为 Java `int`和反之的方法。Converter.java 是一个更通用的版本，处理 2 到 36 之间任何进制的数字字符串。这些是 Java 的两参数[Integer.toString()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toString-int-int-)和[Integer.parseInt()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseInt-java.lang.String-int-)方法的简化版本。

以下表格包含了从 0 到 255 的整数的十进制、8 位二进制和 2 位十六进制表示。

> ![二进制、十进制和十六进制 00-7F](img/27915791b83f664d70dc7af63dedec68.png)    ![二进制、十进制和十六进制 80-FF](img/77f22725230d28736b202ba3b3ad7c33.png)

## 整数算术。

我们首先考虑的整数操作是基本算术运算，如加法和乘法。

+   *加法.* 在小学时，你学会了如何加两个十进制整数：将两个最低有效位（最右边的位）相加；如果和大于 10，则进位 1 并写下和模 10 的余数。重复下一个数字，但这次在加法中包括进位位。相同的过程可以通过用所需进制替换 10 来推广到任何进制。

    > ![整数加法（十进制）](img/df3664acdebedea152b0a47a434d7a50.png)     ![整数加法（十六进制）](img/7afe51fec1973b2bf727e9b2f6ed76f2.png)     ![整数加法（二进制）](img/2f97b670d07e44b29c199d72be9c3ad3.png)

+   *无符号整数.* 在*n*位字中，我们只能表示 2^(*n*)个整数。如果我们只想要非负（或*无符号的*)整数，自然的选择是使用二进制表示 0 到 2*n* − 1 的整数，带有前导 0。例如，使用 16 位字，我们可以表示 0 到 65,535 的整数。

+   *溢出.* 我们需要注意确保算术运算的结果值不超过最大可能值。这个条件称为*溢出*。对于无符号整数的加法，溢出很容易检测：如果最后（最左边）的加法导致进位，那么结果太大无法表示。

    > ![整数溢出](img/bd47a7e9a5a90ae574d1e06c8517fd2d.png)

+   *乘法.* 乘法的小学算法可以在任何进制下完美运行。

    > ![整数乘法（十进制）](img/5acdf60ba2946556975d660872202e2f.png) ![整数乘法（十六进制）](img/bcd86195013c7656480d03f4fdc1ca06.png) ![整数乘法（二进制）](img/3baf3f399cb32e994a8d64c8e16e59c0.png)

## 负整数。

修改整数数据类型以包含负数并不困难，使用一种称为*二进制补码*的表示方法。在*n*位二进制补码中，我们像以前一样表示正数，但我们用（正的，无符号的）二进制数 2^(*n*) – *x*来表示每个负数–x。例如，4 位二进制补码整数 0101 仍代表+5，但 1011 代表–5，因为 2⁴ – 5 = 11[10] = 1011[2]。

> ![4 位二进制补码整数](img/4444e10bc81b2ea785758efd5b691ae3.png)           ![16 位二进制补码整数](img/82817c36715986dbdee4a736c8528caf.png)

+   *加法.* 添加两个*n*位二进制补码整数很容易：将它们像无符号整数一样相加。检测溢出比对无符号整数更复杂一些。

    > ![二进制补码整数加法](img/fd283afd36f5b14c0cb530219373fa92.png)           ![二进制补码整数加法](img/2f952473372612230c0f3024bddde4d0.png)

+   *减法.* 要计算 x – y，我们计算 x + (– y)。也就是说，如果我们���道如何计算 –y，我们仍然可以使用标准二进制加法。要对二进制补码整数取反，翻转位然后加 1。

    > ![二进制补码整数减法](img/236e017740152be1841a13716e2f3c6a.png)           ![二进制补码整数减法](img/e4ebd4dd9e3ebaa4278b72a66b889d10.png)

+   *Java.* Java 的 `short`、`int` 和 `long` 数据类型分别是 16 位、32 位和 64 位的二进制补码整数。这解释了这些类型值的边界，并解释了我们在第 1.2 节中首次观察到的 Java 中溢出行为。

## 实数。

[IEEE 754 标准](https://en.wikipedia.org/wiki/IEEE_floating_point) 定义了大多数计算机系统中浮点数的行为。为简单起见，我们以 16 位版本（称为 *半精度二进制浮点数* 或简称为 `binary16`）进行说明。相同的基本思想适用于 Java 中使用的 32 位和 64 位版本，我们称之为 `binary32` 和 `binary64`。

+   *浮点数.* 计算机系统中常用的实数表示称为 *浮点数*。它就像科学计数法一样，只是一切都用二进制表示。与科学计数法一样，浮点数由 *符号*、*系数* 和 *指数* 组成。

    > ![浮点数的结构](img/3398f507992fbebd327dc39a3a8be008.png)                ![IEEE 754 半精度格式](img/344ae0e471c01c9ccdd2ef4aefd46d25.png)

+   *符号.* 浮点数的第一位是其 *符号*。如果符号位为 0，则数字为正（或零），如果为 1，则为负。

+   *指数.* 浮点数的接下来的 *t* = 5 位用于其 *指数*。浮点数的指数以 *偏移二进制* 表示，其中我们取 *R* = 2^(*t*−1) – 1（`binary16` 为 15）并用 *x* 在 −*R* 和 *R*（`binary16` 为 –15 和 16）之间的任何十进制数表示为 *x* + *R* 的二进制表示。例如，10101 表示指数 6，因为 6 + 15 = 21，而 10101[2] 是 21 的二进制表示。

+   *分数.* 剩余的 10 位用于 *系数*。归一化条件意味着系数小数点前的数字始终为 1，因此我们不需要在表示中包含该数字。这些位被解释为二进制分数，因此 1.101 对应于 1 + 2^(−1) + 2^(−3) = 1.625。

+   *编码和解码浮点数.* 遵循这些规则，解码以 IEEE 754 格式编码的数字的过程很简单。编码数字的过程更复杂，因为需要归一化并扩展二进制转换以包括分数。

    > ![浮点数到十进制的转换](img/1b40fbc7744b8097760e765c494dafbb.png)

+   *Java.* Java 使用 `binary32` 表示 `float` 类型（32 位，其中 8 位用于指数，23 位用于分数），使用 `binary64` 表示 `double` 类型（64 位，其中 11 位用于指数，52 位用于分数）。这解释了这些类型值的边界，并解释了我们在第 1.2 节中首次观察到的舍入误差的各种异常行为。

## 用于操作位的 Java 代码。

Java 将 `int` 数据类型定义为 32 位二进制补码整数，并支持各种操作来操作位。

> ![Java 中的位操作](img/761bcf79cd3178db52173070f9e20d0e.png)

程序 BitWhacking.java 从命令行读取两个整数 a 和 b，应用位操作，并打印结果。

+   *二进制和十六进制字面量.* 您可以在二进制（通过在前面加上 `0b`）和十六进制（通过在前面加上 `0x`）中指定整数字面值。您可以在任何可以使用十进制字面值的地方使用这些字面值。

    > ![二进制、十进制和十六进制字面量](img/3048204958a4dd56e91d3f683347778b.png)

+   *移位和位操作。* Java 支持各种操作来操作整数的位：

    +   补码：将 0 变为 1，将 1 变为 0。

    +   位逻辑运算符：将对应的两个位应用*与*、*或*和*异或*函数。

        > ![AND、OR 和 XOR 的真值表](img/6ed5b062f14bb74e0dc4c1d15e666e06.png)

    +   左移和右移：将位左移或右移给定数量的位置。对于右移，有两个版本：*逻辑右移*在左侧填充空出的位置为 0；*算术右移*在左侧用符号位填充空出的位置。

    以下是一些示例：

    > ![位操作示例](img/4d561f15ade0072020d4d5c4e7445588.png)       ![位操作示例](img/76431b15bc7e476e55714271d12e8ea1.png)

+   *移位和掩码。* 这种操作的主要用途之一是*移位和掩码*，其中我们从同一字中隔离一组连续的位。

    +   使用*右移*指令将位放在最右边的位置。

    +   如果我们需要*k*位，创建一个字面掩码，其位全为 0，除了其*k*最右边的位为 1。

    +   使用*位与*来隔离位。掩码中的 0 导致结果中的零；掩码中的 1 指定感兴趣的位。

    在下面的示例中，我们从 32 位`int`中提取第 9 到第 12 位。

    > ![移位和掩码](img/333070f7a75b8d42bad60ed8151e9a8b.png)

    ExtractFloat.java 演示了使用移位和掩码从浮点数中提取符号、指数和尾数的方法。

## 字符。

要处理文本，我们需要为字符提供二进制编码。基本方法非常简单：一个表定义了字符和*n*位无符号二进制整数之间的对应关系。ASCII 和 Unicode 是两种最流行的编码方案。

+   *ASCII。* [美国信息交换标准代码](https://en.wikipedia.org/wiki/ASCII)（ASCII）是一个 7 位代码，尽管在现代计算中，它通常以 8 位字节的形式使用，忽略了前导位。以下表格是 ASCII 的定义，提供了您需要从 8 位二进制（等效地，2 位十六进制）转换为字符和反向的对应关系。例如，4A 编码了字母 J。

    > ![十六进制转 ASCII](img/cf0650830580b1b7de0597879b83aa8f.png)
    > 
    > ![ASCII 转二进制](img/72affb4f8ee08deca10f890dae777451.png)

+   *Unicode。* [Unicode](https://en.wikipedia.org/wiki/Unicode)是一个支持成千上万字符的 21 位代码。Unicode 的主要实现被称为[UTF-8](https://en.wikipedia.org/wiki/UTF-8)。UTF-8 是一种可变宽度字符编码，用于 ASCII 字符的 8 位，大多数字符的 16 位，其他字符的最多 32 位。编码规则很复杂，但现在在大多数现代系统（如 Java）中已实现，因此程序员通常不需要过多担心细节。

## 大端序、小端序。

计算机在存储多字节信息的方式上有所不同，例如，16 位短整数 0111000011110010 = 70F2。这由两个字节 70 和 F2 组成，其中每个字节编码了 8 位。这两种是两种主要格式，它们只在存储字节的顺序或"[字节序](http://mindprod.com/jgloss/endian.html)"上有所不同。

+   *大端序*系统首先存储最重要的字节，例如，它们以自然顺序 70F2 存储上面的整数。Java 使用这种格式，苹果 Mac、IBM PowerPC G5、Cray 和 Sun Sparc 也是如此。

+   *小端序*系统首先存储最不重要的字节，例如，它们以反向字节顺序 F270 存储上面的整数。这种格式在手动执行算术运算时更自然，例如，对于加法，您从最不重要的字节到最重要的字节进行操作。Intel 8086、Intel Pentium、Intel Xeon 使用这种格式。

#### 练习

1.  将十进制数 92 转换为二进制。

    *解决方案*：1011100。

1.  将十六进制数 `BB23A` 转换为八进制。

    *解决方案*: 首先转换为二进制 `1011 1011 0010 0011 1010`，然后每次考虑三位 `10 111 011 001 000 111 010`，并转换为八进制 `2731072`。

1.  将两个十六进制数 `23AC` 和 `4B80` 相加，并以十六进制给出结果。*解决方案*: 6F2C。

1.  假设 *m* 和 *n* 是正整数。在 2^(*m* + *n*) 的二进制表示中有多少�� 1 位？*解决方案*: 1。

1.  唯一的十进制整数是其十六进制表示的数字被颠倒的整数。

    *解决方案*: 53 在十六进制中是 35。

1.  为 Converter.java 开发一个 `toInt()` 方法的实现，将范围在 `0-9` 或 `A-Z` 的字符转换为介于 0 到 35 之间的 `int` 值。

1.  为 Converter.java 开发一个 `toChar()` 方法的实现，将介于 0 到 35 之间的 `int` 值转换为范围在 `0-9` 或 `A-Z` 的字符。

#### 创意练习

1.  **IP 地址。** 编写一个程序 IP.java，将一个 32 位字符串作为命令行参数，并使用 *点分十进制* 表示法打印相应的 IP 地址。也就是说，每次取 8 位，将每组转换为十进制，并用点分隔每组。例如，二进制 IP 地址 01010000000100000000000000000001 应转换为 `80.16.0.1`。

#### 网络练习

1.  **Excel 列编号。** 编写一个函数，将非负整数转换为相应的 Excel 列名（0 = A，1 = B，...，25 = Z，26 = AA，...，702 = AAA）。

1.  **Elias Gamma 编码。** 编写一个函数 `elias`，接受一个整数 N 作为输入，并将 Elias Gamma 编码作为字符串返回。[Elias Gamma 编码](http://en.wikipedia.org/wiki/Elias_Gamma_coding) 是一种编码正整数的方案。要为整数 N 生成编码，将整数 N 用二进制表示，从二进制编码的位数中减去 1，并在前面添加相应数量的零。例如，前 10 个正整数的编码如下所示。

    ```
    1 1       6 00110
    2 010     7 00111
    3 011     8 0001000
    4 00100   9 0001001
    5 00101  10 0001010

    ```

1.  **位反转。** 编写一个函数，接受一个整数输入，反转其位，并返回该整数。例如，如果 n = 8，输入为 13（00001101），那么它的反转是 176（10110000）。

    ```
    public static int bitReverse(int input) {
       int ans = 0;
       for (int i = 0; i < n; i++) {
          ans = (ans << 1) + (input & 1);
          input = input >> 1;
       }
       return ans;
    }

    ```

1.  **位反转排序。** 使用先前的算法将由 N = 2^n 个元素组成的数组按其位反转顺序“排序”。如果 i 和 j 是彼此的位反转，则交换元素 i 和 j。这种排列在快速傅立叶变换中出现。

    ```
    0    1    2    3    4    5    6        12   13   14   15
    0000 0001 0010 0011 0100 0101 0110 ... 1100 1101 1110 1111

    0000 1000 0100 1100 0010 1010 0110 ... 0011 1011 0111 1111
    0    8    4    9    2    10    6        3   11    7   15

    ```

1.  **无需临时存储交换。** 给定整数 a 和 b，以下两个代码片段分别做什么？

    ```
    a = a + b;
    b = a - b;
    a = a - b;

    a = a ^ b;
    b = a ^ b;
    a = a ^ b;

    ```

    答案: 每个 3 行片段交换 a 和 b。只要 a 和 b 不是相同的变量（在这种情况下，两个变量都将被清零）。

1.  **找到唯一的整数。** 假设你有一个由 2N + 1 个整数组成的数组，并且你知道每个 N 个整数都恰好出现两次。描述一个优雅且高效的算法来识别只出现一次的整数。*提示*: 异或运算。

1.  **位操作版本的格雷码** 使用位操作和迭代而不是递归来生成格雷码。将你的程序命名为 BitWhackingGrayCode.java。

1.  **释放囚犯 I。** 当 17 名新囚犯到达时，看守与他们见面。看守告诉他们，他们今天可以见面并制定一个策略，但会议结束后，每个囚犯将被单独关押，无法互相交流。监狱有一个有 17 个开关的开关室，可以打开或关闭，尽管初始配置未透露。有一种特殊的 17 个开关设置，如果它被实现，囚犯们就可以自由了。每小时，看守会带一名囚犯到开关室，囚犯最多可以翻转一个开关（从开到关或从���到开）。看守可以任意选择囚犯的顺序，因此一个囚犯可能连续四次被选择，或者根本不被选择。设计一个策略，使 17 名囚犯保证在有限时间内被释放。

1.  **释放囚犯 II。** 与上述相同的前提，只是开关室有 2 个开关（最初都关闭），囚犯进入开关室时必须翻转其中一个开关。任何时候，一个囚犯可以宣布“我们 17 个人都去过控制室了”。如果是真的，所有囚犯都将被释放；否则他们都将被处决。看守可以任意选择囚犯的顺序，因此一个囚犯可能连续四次被选择，但每个囚犯将被无限次选择（假设他们从未被释放）。设计一个策略，使 17 名囚犯保证在有限时间内被释放。*额外加分*：不要假设初始配置是已知的。

1.  **计算 1 位的数量。** 编写一个函数，接受一个整数输入，并返回其二进制表示中的 1 的数量。

    *答案*：这里有一个迭代和一个递归解决方案。

    ```
    public static int bitCount(int input) {
       int count = 0;
       for (int i = 0; i < 32; i++)
          count = count + (input >>> i & 1);
       return count;
    }

    public static int bitCount(int x) { 
       if (x == 0) return 0; 
       return (x & 1) + bitCount(x >>> 1); 
    } 

    ```

    这是 Java 如何实现`Integer.bitCount()`的。看看你能否弄清楚它是如何工作的。

    ```
    public static int bitCount(int i) {
       i = i - ((i >>> 1) & 0x55555555);
       i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
       i = (i + (i >>> 4)) & 0x0f0f0f0f;
       i = i + (i >>> 8);
       i = i + (i >>> 16);
       return i & 0x3f;
    }  

    ```

1.  **稀疏位计数。** 解释为什么以下函数（在程序员的面试中经常出现）正确计算其输入的二进制表示中 1 的位数。如果输入有 k 个 1，while 循环会迭代多少次？

    ```
    public static int bitCount(int input) {
       int count = 0;
       while (input != 0) {
           count++;
           input = input & (input - 1);
       }
       return count;
    }

    ```

1.  **查表位计数。** 重复前面的练习，但预先计算一个表以加快计算速度。

    *答案*：这个假设你有一个大小为 256 的预先计算的表，其中`bits[i]`存储 i 的二进制表示中 1 的位数。你可以使用前面练习中的位计数函数来初始化它。

    ```
    public static int bitCount(int input) {
        return bits[(input >>  0) & 0xff]
            +  bits[(input >>  8) & 0xff]
            +  bits[(input >> 16) & 0xff]
            +  bits[(input >> 24) & 0xff];
    }

    ```

    将表大小增加到 2¹⁶ = 65,536 会使事情变得更快，假设你有足够的内存。大小为 2³²的表可能是禁止的。

1.  **Java 库函数用于位操作。** 重新实现[Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)类中定义的以下静态方法。

    | 函数 | 返回值 |
    | --- | --- |
    | `Integer.bitCount(x)` | x 中 1 的位数 |
    | `Integer.highestOneBit(x)` | 将 x 除最左边的 1 位外都置零。 |
    | `Integer.lowestOneBit(x)` | 将 x 除最右边的 1 位外都置零。 |
    | `Integer.numberOfLeadingZeros(x)` | 最高位 1 前面的零位数。 |
    | `Integer.numberOfTrailingZeros(x)` | 最低位 1 后面的零位数。 |
    | `Integer.rotateLeft(x, i)` | 将 x 循环左移 i 位。 |
    | `Integer.rotateRight(x, i)` | 将 x 循环右移 i 位。 |
    | `Integer.reverse(x)` | x 的位的反转。 |

1.  **字典攻��。**一种肮脏的垃圾邮件发送者使用的方法是通过枚举给定域名（例如 hotmail.com）的所有可能的电子邮件地址来自动生成电子邮件地址。这种恼人的策略称为字典或 Rumpelstiltskin 攻击，解释了为什么有时候你会收到发送到你尚未告知任何人的新电子邮件地址的垃圾邮件。使用 Converter.java 设计这样一个程序。你的程序 Rumpelstiltskin.java 应该接受一个命令行参数 N，并打印出所有 36^N 个可能的密码，其中包括数字和大写字母。

1.  **断金链。**你有一条有 14 个环节的金链，你要用它来支付一个工人 15 天，每天 1 个金环节的费用。通过切割 14 次，可以将链子分成 15 段。你的目标是在只断开链子 3 次的情况下支付工人。工人必须在每天工作结束后准确收到总支付的一定比例。*提示：*将链子断开，使得有 1 段、2 段、4 段和 8 段的部分。

1.  **海明编码器。**编写一个 Java 程序 HammingEncoder.java，读取 0 和 1 序列，每次 4 位，使用海明码进行编码。

1.  **海明译码器。**编写一个 Java 程序 HammingDecoder.java，读取使用海明码编码的 0 和 1 序列，每次 7 位，解码并纠正错误。

1.  **海明码。**修改你之前两个练习的解决方案，使输入位每 8 位打包一次。

1.  **绝对值。**常量`Integer.MIN_VALUE`是最负的 32 位补码整数。`Math.abs(Integer.MIN_VALUE)`是多少？

1.  证明一个 k 位的十进制数可以用不超过 4k 位的二进制表示。

1.  **2 的幂之和。**计算 2 的幂之和。在补码机器上，你最终得到什么值？

1.  **CD 数据库。**CDDB 和[freedb](http://freedb.org)是允许你在网络上查找 CD 信息并显示艺术家、标题和歌曲名称的数据库。每张 CD 都有一个（几乎）唯一的唱片 ID 号码，用于查询数据库。

    1.  编写一个静态方法`sumDigits()`，接受一个整数参数，并返回整数中十进制数字的和。例如，`sumDigits(6324)`返回 15，因为 6 + 3 + 2 + 4 = 15。

    1.  编写一个程序 CDDB.java，从曲目长度列表计算出唱片 ID。32 位（8 位十六进制数字）ID 号码是根据 CD 上曲目的长度和曲目数计算的：

        ```
        XXYYYYZZ
          XX   = checksum of track offsets in seconds, taken mod 255
          YYYY = length of the CD in seconds
          ZZ   = number of tracks on the CD

        ```

1.  真或假。如果 a xor b = c，那么 c xor a = b，c xor b = a 是否成立？

1.  解释为什么以下代码片段不会将`ABCD`留在变量`a`中。你会如何修复它？

    ```
    byte b0 = 0xAB; 
    byte b1 = 0xCD; 
    int c = (b0 << 8) | b1;

    ```

    *答案*。在 Java 中，`byte`是一个有符号的 8 位整数。右移会将`b0`提升为一个（负的）整数。要解决问题，使用`c = ((b0 & 0xff) << 8) | (b1 & 0xff);`。

1.  **有毒的酒。**“你是一个帝国的统治者，明天你将举办庆典。这次庆典是你举办过的最重要的派对。你有 1000 瓶酒打算在庆典上开启，但你发现其中一瓶被下毒了。实际的毒药在大约第 23 个小时左右才会出现症状，然后导致突然死亡。你手头有成千上万的囚犯。你必须让多少囚犯从瓶子中喝酒才能找到被下毒的瓶子？”

    *提示：*你可以用 10 位表示数字 1,000。

1.  **无符号 32 位整数。**描述如何在 Java 中模拟 32 位无符号整数。

    *解决方案*：首先，您确定您真的需要无符号类型吗。有符号和无符号整数在位运算符（除了>>）、加法、减法和乘法上的行为是相同的。在许多应用程序中，这些已经足够了，假设您用>>>替换>>。比较运算符易于通过检查符号位来模拟。除法和余数是最棘手的：最简单的解决方案是转换为`long`类型。

    ```
    long MASK = (1L << 32) - 1;   // 0x00000000FFFFFFFF; 
    int quotient  = (int) ((a & MASK) / (b & MASK));
    int remainder = (int) ((a & MASK) % (b & MASK));

    ```

    程序 UnsignedDivision.java 使用这个技巧，并且还直接使用 32 位操作。

1.  **无符号 8 位整数。**描述如何在 Java 中模拟 8 位无符号整数。

    *解决方案*：与前一个问题相同的建议。使用无符号整数很好的一个地方是用于查找表，由字节索引。使用有符号整数，索引可能为负。此外，如果`b`是`byte`，那么`b << 4`会自动将`b`转换为`int`。这可能是不希望的，因为`b`是有符号的。在许多应用程序中，您需要通过`(b << 4) & 0xff`来去除符号扩展位。

1.  **添加两个 short 整数。**解释为什么以下代码片段失败。

    ```
    short a = 4;
    short b = 5;
    short c = a + b;

    ```

    *解决方案*：Java 自动将大多数整数操作的结果提升为`int`类型。要将结果分配给`short`，需要显式将其转换回`c = (short) (a + b)`。是的，这有点古怪。这个规则的一个例外是如果使用`+=`，那么转换会自动执行。

    **使用字节掩码。**解释当`b`是`byte`类型时，`(b << i)`会产生奇怪的结果的原因。

    *解决方案*：在 Java 中，`byte`是一个 8 位有符号整数。在右移之前，`b`被转换为整数。您可能想要使用`((b & 0xff) << i)`。

1.  2²²²¹⁷ 的二进制表示中有多少位？

1.  程序 Overflow.java 中的以下代码片段打印什么？

    ```
    int a = 2147483647;   // 2³¹ - 1
    int b = a + 1;
    System.out.println("a = " + a);
    System.out.println("b = " + b);

    ```

1.  以下代码片段打印什么？

    ```
    int a = -5 >>  3;
    int b = -5 >>> 3;
    System.out.println(a);
    System.out.println(b);

    ```

1.  列出所有`int`类型的`a`值，使得`(a == (a >> 1))`。*提示*：不止一个。

1.  假设`a`是`int`类型的变量。找到两个值的`a`，使得`(a == -a)`为`true`。*答案*：0 和-2147483648。

1.  `a = -1 * -2147483648`的结果是什么？*答案*：0。

1.  以下代码片段打印出什么？

    ```
    int a = 11 & 17;
    int b = 11 ^ 17;
    int c = 11 | 17;
    int d = ~11;
    System.out.println(a);
    System.out.println(b);
    System.out.println(c);
    System.out.println(d);

    ```

1.  给定两个正整数`a`和`b`，以下 Java 代码片段将在`c`中留下什么结果？

    ```
    c = 0;
    while (b > 0) {
       if (b & 1 == 1) c = c + a;
       b = b >> 1;
       a = a << 1;
    }

    ```

    *答案*：a * b。

1.  以下代码对存储在两个不同变量`a`和`b`中的整数做了什么？

    ```
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;

    ```

1.  重复上一个问题，但假设`a`和`b`是相同的变量。

1.  以下代码对存储在两个不同变量`a`和`b`中的整数做了什么？有溢出问题吗？

    ```
    a = a + b;
    b = a - b;
    a = a - b;

    ```

1.  以下每个语句做什么？

    ```
    x = - ~x;
    x = ~ -x;

    ```

    *增加 x，减少 x*

1.  以下代码做什么？

    ```
    public static boolean parity(int a) { 
      a ^= a >>> 32; 
      a ^= a >>> 16; 
      a ^= a >>>  8; 
      a ^= a >>>  4; 
      a ^= a >>>  2; 
      a ^= a >>>  1; 

      return a & 1; 
    } 

    ```

    答案：使用分治法计算二进制表示中设置的 1 位数的奇偶性。

1.  在以下循环后，`cnt`的值是多少？

    ```
    int cnt = 0;
    for (int i = 1; i != 0; i = 2 * i) {
        cnt++;
    }

    ```

    *提示*：这不是一个无限循环。

1.  解释为什么以下 Java 代码片段正确确定整数`n`是否为 2 的幂。

    ```
    boolean isPowerOfTwo = (n & -n) == n; 

    ```

1.  **以-2 为基数计数。**使用位置表示法的定义来定义基数为-2 的数字系统。有两个数字 0 和 1。在这个系统中从-7 到 7 计数。

    ```
    0 = 0                         -1 = 11   (-2 + 1)
    1 = 1                         -2 = 10
    2 = 110   (4 + -2)            -3 = 1101 (-8 + 4 + 1)
    3 = 111                       -4 = 100
    4 = 100                       -5 = 1111
    5 = 101                       -6 = 1110
    6 = 11010 (16 + -8 + -2)      -7 = 1001
    7 = 11011

    ```

1.  **RGBA 颜色格式。** Java 的一些类（BufferedImage、PixelGrabber）使用一种称为 RGBA 的特殊编码来存储每个像素的颜色。该格式由四个整数组成，表示从 0（不存在）到 255（完全使用）的红、绿和蓝强度，以及从 0（透明）到 255（不透明）的 alpha 透明度值。这四个 8 位整数被压缩成一个 32 位整数。编写一个代码片段，从 RGBA 整数中提取四个分量，并反向操作。

    ```
    // extract
    int alpha = (rgba >> 24) & 0xff;
    int red   = (rgba >> 16) & 0xff;
    int green = (rgba >>  8) & 0xff;
    int blue  = (rgba >>  0) & 0xff;

    // write back
    rgba = (alpha << 24) | (red << 16) | (green << 8) | (blue << 0);
    System.out.println(rgba);

    ```

1.  **最小值和最大值。** 以下哪个计算`min(a, b)`，另一个计算`max(a, b)`而不使用分支。哪个是哪个？解释它是如何工作的。

    ```
    f = b + ((a - b) & -(a < b));    // min(a, b)
    g = a - ((a - b) & -(a < b));    // max(a, b)

    ```

1.  **找到缺失的值。** 假设你有一个由`int`类型的 2³² - 1 个整数组成的数组，其中没有任何整数出现超过一次。由于有 2³²个可能的值，恰好有一个整数缺失。编写一个代码片段，尽可能少地使用额外存储来找到缺失的整数。

    *提示*：这是一个常见的面试问题。可以只使用一个额外的`int`来完成。可以利用整数溢出的性质或使用 XOR 函数来实现。

1.  **循环冗余校验。** 编写程序 CRC16.java 和 CRC32.java 从标准输入读取数据并计算其 16 位或 32 位 CRC。编写一个程序 CRC16CCITT.java"用于 CCITT 格式的 16 位 CRC。
