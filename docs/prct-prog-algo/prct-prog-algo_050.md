# 9.1 浮点数

> 原文：[`introcs.cs.princeton.edu/java/91float`](https://introcs.cs.princeton.edu/java/91float)

本节正在进行重大施工。

传统计算机科学与科学计算的一个显著特征是其使用离散数学（0 和 1）而不是连续数学和微积分。从整数过渡到实数不仅仅是一种表面变化。数字计算机无法精确表示所有实数，因此在为实数设计计算机算法时，我们面临新的挑战。现在，除了分析运行时间和内存占用量之外，我们还必须关注结果解决方案的“正确性”。这个具有挑战性的问题进一步恶化，因为许多重要的科学算法为适应离散计算机而进行额外的近似。正如我们发现一些离散算法本质上太慢（多项式 vs. 指数），我们将看到一些浮点算法太不准确（稳定 vs. 不稳定）。有时，通过设计更聪明的算法可以解决这个问题。对于离散问题，困难有时是固有的（NP 完全性）。对于浮点问题，困难也可能是固有的（病态条件），例如准确的长期天气预测。要成为一名有效的计算科学家，我们必须能够相应地对我们的算法和问题进行分类。

## 浮点数。

20 世纪最伟大的成就之一如果没有数字计算机的浮点能力是不可能的。然而，大多数程序员对这个主题并不了解，经常引起混淆。在 1998 年 2 月的一次主题演讲中，名为*Java 扩展用于数值计算*的 James Gosling 断言“95%的人完全不了解浮点数”。然而，浮点数背后的主要思想并不难理解，我们将揭开大多数新手困惑的神秘面纱。

## IEEE 754 二进制浮点表示。

首先，我们将描述浮点数是如何表示的。Java 使用[IEEE 754 二进制浮点标准](http://754r.ucbtest.org/standards/754xml.html)的一个子集来表示浮点数并定义算术运算的结果。几乎所有现代计算机都符合这一标准。一个`float`使用 32 位表示，每种可能的位组合表示一个实数。这意味着最多可以精确表示 2³²个实数，尽管实数有无限多个（甚至在 0 和 1 之间）。IEEE 标准使用类似于科学记数法的内部表示，但是使用二进制而不是十进制。这涵盖了从±1.40129846432481707e-45 到±3.40282346638528860e+38 的范围。具有 6 或 7 个有效十进制数字，包括正无穷大、负无穷大和 NaN（不是一个数字）。该数字包含一个符号位*s*（解释为正或负），8 位指数*e*，和 23 位尾数*M*。十进制数根据以下公式表示。

```java
(-1)s × m × 2(e - 127)

```

+   *符号位 s（第 31 位）*。最高有效位表示数字的符号（1 为负，0 为正）。

+   *指数字段 e（第 30 - 23 位）*。接下来的 8 位表示指数。按照惯例，指数通过 127 进行*偏置*。这意味着要表示二进制指数 5，我们在二进制中编码为 127 + 5 = 132（10000100）。要表示二进制指数-5，我们在二进制中编码为 127 - 5 = 122（01111010）。这种约定是用于表示负整数的补码表示法的替代方法。

+   *尾数 m（位 22-0）*。剩余的 23 位表示尾数，*标准化*为 0.5 到 1 之间。通过相应地调整二进制指数，始终可以进行这种标准化。二进制小数与十进制小数类似：0.1101 表示 1/2 + 1/4 + 1/16 = 13/16 = 0.8125。并非每个十进制数都可以表示为二进制小数。例如，1/10 = 1/16 + 1/32 + 1/256 + 1/512 + 1/4096 + 1/8192 + ... 在这种情况下，数字 0.1 由最接近的 23 位二进制小数 0.000110011001100110011...来近似���还有一个进一步的优化。由于尾数始终以 1 开头，因此不需要显式存储这个*隐藏位*。

例如，十进制数 0.085 存储为 00111101101011100001010001111011。

```java
0.085:
bits:    31   30-23           22-0
binary:   0 01111011 01011100001010001111011
decimal:  0    123           3019899

```

这恰好表示数字 2^(e-127) (1 + m / 2²³) = 2^(-4)(1 + 3019899/8388608) = 11408507/134217728 = 0.085000000894069671630859375。

`double`类似于`float`，只是其内部表示使用 64 位，11 位指数，偏置为 1023，以及 52 位尾数。这覆盖了从±4.94065645841246544e-324 到±1.79769313486231570e+308 的范围，精度为 14 或 15 个有效数字。

## 精度与准确性。

精度=规范的严密程度。准确性=正确性。不要混淆精度和准确性。3.133333333 是数学常数π的估计值，其规范为 10 位小数，但只有两位小数的准确性。正如约翰·冯·诺伊曼曾经说过的：“当你连自己在说什么都不知道时，精确是没有意义的。”Java 通常以 16 或 17 位小数的精度打印浮点数，但不要盲目相信这意味着有那么多位的准确性！计算器通常显示 10 位数字，但以 13 位精度进行计算。卡汉：哈勃太空望远镜的镜子被磨得非常精确，但却是按照错误的规范。因此，最初它是一个巨大的失败，因为它无法产生预期的高分辨率图像。然而，它的精度使一名宇航员能够安装一个校正镜片来抵消误差。货币计算通常以给定的精度来定义，例如，欧元汇率必须报价到 6 位数。

## 舍入误差。

使用浮点数进行编程对于未经培训的人来说可能是一个令人困惑和危险的过程。整数运算是精确的，除非答案超出了可以表示的整数范围（溢出）。相比之下，浮点运算并不是精确的，因为一些实数需要无限位数的数字来表示，例如，数学常数 e 和π以及 1/3。然而，大多数初学者 Java 程序员会惊讶地发现，1/10 在标准二进制浮点数中也无法精确表示。这些舍入误差可能以非直观的方式传播到计算中。

+   *小数的四舍五入*。例如，下面来自 FloatingPoint.java 的第一个代码片段打印出`false`，而第二个则打印出`true`。

    ```java
    double x1 = 0.3;
    double x2 = 0.1 + 0.1 + 0.1;
    StdOut.println(x1 == x2);

    double z1 = 0.5;
    double z2 = 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
    StdOut.println(z1 == z2);

    ```

+   *牛顿法*。一个更现实的例子是以下代码片段，其目的是通过迭代牛顿法计算 c 的平方根。数学上，迭代���列收敛到√c，使得 t² - c > 0。然而，浮点数只有有限位数的准确性，所以最终，我们可能期望 t²精确地等于 c，直到机器精度。

    ```java
    double EPSILON = 0.0;
    double t = c;
    while (t*t - c > EPSILON)
        t = (c/t + t) / 2.0;

    ```

    实际上，对于某些 c 的值，这种方法是有效的。

    ```java
    % java Sqrt 2       % java Sqrt 4   % java Sqrt 10   
    1.414213562373095   2.0             3.162277660168379

    ```

    当我们尝试计算 20 的平方根时，可能会让我们对我们的代码片段正确性产生一些信心。但是当我们尝试计算 20 的平方根时，一个令人惊讶的事情发生了！我们的程序陷入了无限循环！这种错误称为*舍入误差*。*机器精度*是最小的数字ε，使得（1.0 + ε != 1.0）。在 Java 中，使用`double`是 XYZ，使用`float`是 XYZ。将误差容限ε更改为一个小的正值有所帮助，但并不能解决问题（参见练习 XYZ）。

    我们必须满足于近似平方根。进行计算的可靠方法是选择一些误差容限ε，比如`1E-15`，并尝试找到一个值`t`，使得|t - c/t| < ε t。我们使用*相对误差*而不是*绝对误差*；否则程序可能会陷入无限循环（参见练习 XYZ）。

    ```java
    double epsilon = 1e-15;
    double t = c;
    while (Math.abs(t*t - c) > c*epsilon)
        t = (c/t + t) / 2.0;

    ```

+   *调和级数。*可能是受到尝试估计欧拉常数γ = 当 n 趋向无穷大时γ[n] = H[n] - ln n 的启发。极限存在且约为 0.5772156649。令人惊讶的是，甚至不知道γ是否是无理数。

    程序 HarmonicSum.java 使用单精度和双精度计算 1/1 + 1/2 + ... + 1/N。使用单精度时，当 N = 10,000 时，总和精确到 5 位小数，当 N = 1,000,000 时，只精确到 3 位小数，当 N = 10,000,000 时，只精确到 2 位小数。实际上，一旦 N 达到 1000 万，总和就再也不增加了。尽管调和级数发散到无穷大，在浮点数中它收敛到一个有限的数！这打破了一个常见的误解，即如果你解决的问题只需要 4 或 5 位小数的精度，那么使用存储 7 位的类型是安全的。许多数值计算（例如，积分或微分方程的解）涉及对许多小项求和。误差可能会累积。这种舍入误差的累积可能导致严重问题。

    更好的公式：γ ≈ γ[n] - 1/(2n) + 1/(12n²)。对于 n = 100 万，精确到小数点后 12 位。

每次进行算术运算时，至少会引入一个额外的误差ε。Kernighan 和 Plauger 说：“浮点数就像沙堆；每次移动一个，你就会丢失一点沙子并拾起一点灰尘。”如果错误是随机发生的，我们可能会预期一个累积误差为 sqrt(N) ε[m]。然而，如果我们在设计数值算法时不够警惕，这些错误可能会以非常不利和非直观的方式传播，导致累积误差达到 N ε[m]或更糟。

## 金融计算。

我们举例说明一些可能破坏财务计算的舍入误差。涉及美元和美分的财务计算涉及基数 10 算术。以下示例演示了使用类似 IEEE 754 的二进制浮点系统可能遇到的一些危险。

+   *销售税。*程序 Financial.java 说明了危险。计算一个 50 美分电话的 9%销售税。（或者 0.70 美元电话的 5%销售税）。使用 IEEE 754，1.09 * 50 = xxx。即使精确答案是 0.xx，结果也会被四舍五入为 0.xx，而电话公司（根据法律）必须将其四舍五入为 0.xx（使用银行家舍入）。相比之下，一个 75 美分电话的 14%税可能会被四舍五入为 x.xx，即使��根据法律）电话公司必须将数字四舍五入为 x.xx（使用银行家舍入）。这几分钱的差异可能看起来不重要，你可能希望这些影响在长期内互相抵消。然而，经过数亿次交易，这种[薄利多销](http://en.wikipedia.org/wiki/Salami_slicing)可能导致数百万美元的损失。参考：《超人 III》（1983 年），《骇客》（1995 年）和《办公室空间》（1999 年）。在《办公室空间》中，三个朋友通过计算机病毒感染会计系统，将分数部分四舍五入并转移到他们的账户中。

    出于这个原因，一些程序员认为在存储财务值时应始终使用整数类型，而不是浮点类型。下一个示例将展示使用 `int` 类型存储财务值的危险。

+   *复利.* 这个例子向您介绍了舍入误差的危险。假设您以每日复利的方式投资 $1000.00，利率为 5%。1 年后您将有多少钱？如果银行正确计算价值，您应该最终得到 $1051.27，因为精确公式是

    ```java
    a * (1 + r/n)n

    ```

    这导致 1051.2674964674473.... 假设银行将您的余额存储为整数（以便士计算）。每天结束时，银行计算您的余额并乘以 1.05，然后将结果四舍五入到最接近的一分钱。那么，您最终只会得到 $1051.10，被骗了 17 分钱。假设银行每天结束时向下舍入到最接近的一分钱。现在，您最终只会得到 $1049.40，您将被骗走 $1.87。不存储分数部分的误差会累积，并最终可能变得显著，甚至是欺诈性的。程序 CompoundInterest.java。

    您应该使用 Java 的 `BigDecimal` 库，而不是使用整数或浮点类型。这个库有两个主要优点。首先，它可以精确表示十进制数。这可以避免使用二进制浮点数时的销售税问题。其次，它可以存储具有任意精度的数字。这使程序员能够控制舍入误差对计算的影响程度。

## 其他误差来源。

除了使用浮点运算时固有的舍入误差外，科学应用中常见的还有一些其他类型的近似误差。

+   *测量误差。* 计算中使用的数据值不准确。这源于实际（不准确或���精确的测量仪器）和理论（海森堡不确定性原理）考虑。我们主要关注的是对初始数据不太敏感的模型和解决方法。

+   *离散化误差。* 另一个不准确性来源是对连续系统进行离散化，例如，通过截断其泰勒展开来近似超越函数，使用矩形的有限和来近似积分，使用有限差分方法找到微分方程的近似解，或者在格点上估计连续函数。即使使用精确算术，离散化误差仍然存在。这通常是不可避免的，但我们可以通过使用更精细的离散化来减少截断误差。当然，这要以使用更多资源为代价，无论是内存还是时间。在实际应用中，离散化误差通常比舍入误差更重要。

+   *统计误差。* 没有足够的随机样本。

## 灾难性的取消。

当从大数通过加法或减法计算小数时，会导致精度严重丢失。例如，如果 x 和 y 除了最后几位外完全相同，那么如果我们计算 z = x - y，那么 z 可能只有几位精度。如果随后在计算中使用 z，那么结果可能只有几位精度。

+   *绘制函数。* 尝试绘制 f(x) = (1 - cos x) / (x²)，其中 x = -4 * 10^-8 到 4 * 10^-8。在这个区域内，数学函数 f(x) 大致恒定，值为 0.5。然而，在 IEEE 浮点数中，情况绝对不是这样！程序 Catastrophic.java 进行了这个操作，结果非常令人惊讶。

    > ![灾难性取消](img/0ef0a7835ed875539ec952c9cc8b4c74.png)

+   *指数函数。* 现在我们考虑灾难性取消的一个更微妙和有害的后果。程序 Exponential.java 使用泰勒级数计算 e^x

    ```java
    ex = 1 + x + x2/2! + x3/3! + x4/4! + ...

    ```

    该级数在所有 x 值上均一致绝对收敛。然而，对于许多负的 x 值（例如，-25），程序无法获得任何正确的数字，无论级数中有多少项相加。例如，当 x = -25 时，级数在浮点数中收敛为-7.129780403672078E-7（一个负数！），但真实答案是 1.3887943864964021E-11。要了解原因，请注意级数中的第 24 项是 25²⁴/24!，第 25 项是-25²⁵/25!。原则上，它们应该完全互相抵消。实际上，它们相互抵消得灾难性。这些项的大小（5.7 * 10⁹）比真实答案大 20 个数量级，任何抵消中的错误都会在计算答案中放大。幸运的是，在这种情况下，问题很容易纠正（见练习 XYZ）。

## 数值分析。

Lloyd Trefethen（1992 年）"数值分析是研究连续数学问题算法的学科。"

+   *稳定性.* 如果一个数学问题的解在输入参数发生微小变化时只有微小变化，则该问题是*良好条件*的。如果算法的输出在输入数据发生微小变化时只有微小变化，则该算法是*数值稳定*的。数值稳定性捕捉了算法如何传播错误。数值分析是寻找解决良好条件问题的数值稳定算法的艺术��科学。准确性取决于问题的条件和算法的稳定性。应用稳定算法解决病态问题或应用不稳定算法解决良好条件问题可能导致不准确性。

    +   *指数函数.* 举个简单的例子，计算 f(x) = exp(x)是一个良好条件的问题，因为 f(x + ε) = .... 通过其泰勒级数计算 exp(x)的一种算法。假设我们使用其泰勒近似的前四项来估计 f(x) = exp(x)：g(x) = 1 + x + x²/2 + x³/3!。那么 f(1) = 2.718282，g(1) = 2.666667。然而，它是不稳定的，因为如果 x < 0 ..... 一个稳定的算法是，如果 x 是非负的，则使用泰勒级数，但如果 x 是负的，则使用泰勒级数计算 e^(-x)并取倒数。

    +   *(1 - cos x) / (x²)函数.* 给出一个稳定的方法来评估这个函数。

+   *条件.* 我们看到了一个计算 exp(x)的不稳定算法的例子。我们也看到了一个稳定的计算算法。有时，我们并不总是那么幸运。如果没有稳定的算法来解决问题，我们称问题为*病态问题*。

    正数的加法、乘法、指数运算和除法都是良好条件的问题。计算二次方程的根也是如此。（见练习 XYZ。）减法是病态问题。找到一般多项式的根也是如此。解 Ax = b 问题的条件取决于矩阵 A。

    *人口动态.* Verhulst 方程是人口动态的简化模型。

    ```java
    xn = (R + 1)xn-1 - R (xn-1)2

    ```

    程序 Verhulst.java 读取命令行参数 R，并迭代 Verhulst 方程 100 次，从 x[0] = 0.5 开始。它以四种不同但在数学上等效的方式进行计算。当 R = 3 时，所有计算结果都明显不同，但都不正确（可以使用 Maple 中的精确算术进行验证）。([参考链接](http://www.lactamme.polytechnique.fr/Mosaic/descripteurs/Kepler.02..html))

    ```java
          (R+1)x-R(xx)  (R+1)x-(Rx)x ((R+1)-(Rx))x  x + R(x-xx)   correct
      0:  0.5000000000  0.5000000000  0.5000000000  0.5000000000  0.5000000000
     10:  0.3846309658  0.3846309658  0.3846309658  0.3846309658  0.3846309658
     20:  0.4188950250  0.4188950250  0.4188950250  0.4188950250  0.4188950250
     30:  0.0463994725  0.0463994756  0.0463994787  0.0463994775  0.0463994768
     40:  0.3201767255  0.3201840912  0.3201915468  0.3201885159  0.3201870617
     50:  0.0675670955  0.0637469566  0.0599878799  0.0615028942  0.0622361944
     60:  0.0011449576  0.2711150754  1.0005313342  1.2945078734  0.0049027225
     70:  1.2967745569  1.3284619999  1.3296922488  0.1410079704  0.5530823827
     80:  0.5530384607  0.8171627721  0.0219521770  0.0184394043  0.1196398067
     90:  0.0948523432  0.1541841695  0.0483069438  1.2513933889  0.3109290854
    100:  0.0000671271  0.1194574394  1.2564956763  1.0428230334  0.7428865400

    ```

    当 R > 2.57 时，该系统表现出混沌行为。系统本身是病态的，因此无法重构计算以使用浮点算术迭代系统。尽管我们不能指望我们的浮点算法正确处理病态问题，但我们可以要求它们报告与解决方案相关的错误范围，以至少警示我们可能存在的问题。例如，在解线性方程组时（见第 9.5 节），我们可以计算一种称为*条件数*的东西：这个量可以用来限制结果解的误差。

    病态条件不仅仅是一个理论可能性。天体物理学家已经确定我们的太阳系是混沌的。冥王星轨道的轨迹是混沌的，就像木星行星、哈雷彗星和小行星带轨迹的运动一样。在与金星的近距离接触中，水星可能在不到 35 亿年内被从太阳系中抛出！

+   *计算特殊函数。* 在学习微积分时，我们推导出用于计算指数和三角函数的收敛泰勒级数公式（例如，exp(x)，log(x)，sin(x)，cos(x)，arctan(x)等）。然而，在数字计算机上应用这些公式时必须非常小心。并非所有特殊函数都内置在 Java 的 Math 库中，因此有时必须自己创建。举例，误差函数。

    数值分析家们为计算科学应用中出现的经典函数（例如，双曲三角函数、伽玛函数、贝塔函数、误差函数、贝塞尔函数、雅可比椭圆函数、球谐函数）推导出了准确、精确和高效的算法。我们强烈建议使用这些经过验证的方法，而不是设计自己的临时程序。

## 真实世界的数值灾难。

我们上面讨论的例子相当简单。然而，这些问题在实际应用中会出现。如果处理不当，灾难可能很快发生。

+   *阿丽亚娜 5 号火箭。* 阿丽亚娜 5 号火箭在欧洲航天局发射后 40 秒爆炸。这是经过十年和 70 亿美元的研发后的首次飞行。传感器报告的加速度如此之大，以至于导致重新校准惯性导航的程序部分溢出。64 位浮点数被转换为 16 位有符号整数，但数字大于 32767，转换失败。意外的溢出被一个通用系统诊断捕获，并将调试数据转储到用于引导火箭发动机的内存区域。控制被切换到备用计算机，但这台计算机也有相同的数据。这导致了一次试图纠正不存在问题的激烈尝试，导致了火箭发动机与支架分离，导致了[阿丽亚娜 5 号的终结](http://www.around.com/ariane.html)。

+   *爱国者导弹事故。* 1991 年 2 月 25 日，一枚美国爱国者导弹未能追踪和摧毁一枚伊拉克飞毛腿导弹。相反，它击中了一个陆军兵营，造成 26 人死亡。后来确定原因是由于以十分之一秒为单位测量时间导致的不准确计算。由于使用了 24 位浮点数���无法准确表示 1/10。用于解决问题的软件于 2 月 26 日抵达达赫兰。这里有更多[信息](http://www.ima.umn.edu/~arnold/disasters/patriot.html)。

+   *英特尔 FDIV 错误* 五代芯片硬件浮点除法电路中的错误。英特尔于 1994 年 7 月发现，数学教授于 1994 年 9 月重新发现并公开。1994 年 12 月英特尔召回成本为 3 亿美元。1997 年发现另一个浮点错误。

+   *斯莱普纳石油钻井平台沉没。* 价值 7 亿美元的斯莱普纳 A 平台用于生产石油和天然气，在 1991 年 8 月在北海泄漏并沉没。有误差的有限元近似低估了剪切应力 47% [参考](http://www.ima.umn.edu/~arnold/disasters/sleipner.html)。

+   *温哥华证券交易所。* 温哥华证券交易所指数在累积了 22 个月的四舍五入误差后被低估了超过 50%。明显的算法是在每次交易后将所有股票价格相加。然而，“聪明”的分析师决定更高效地重新计算指数，方法是在每次交易后添加股票的净变化。这个计算使用四位小数并将结果截断（而非四舍五入）到三位。[参考链接](http://www.ualberta.ca/~carolina/CHE374/notes/U01_errors/flerrors/fl_and_errors.html)

**教训。**

+   为了精确性，请使用 `double` 而不是 `float`。

+   只有在真正需要节省内存并且意识到与精度相关的风险时才使用 `float`。通常情况下，这不会加快速度，有时甚至会减慢速度。

+   谨慎计算两个非常相似值的差异，并在随后的计算中使用结果。

+   谨慎添加两个数量的数量级差异很大。

+   谨慎多次重复进行略有不准确的计算。例如，随时间计算行星位置的变化。

+   设计稳定的浮点算法非常不容易。在有库可用时请使用库。

#### Q + A

**Q.** 有关浮点数的任何好参考资料吗？

**A.** 这里有两篇关于浮点精度的文章：[计算机科学家应该了解的浮点运算知识](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html) 由大卫·戈德堡（David Goldberg）撰写，以及由图灵奖获得者[威廉·卡恩](http://http.cs.berkeley.edu/~wkahan/)合著的[Java 的浮点数如何伤害每个人](http://www.cs.berkeley.edu/~wkahan/JAVAhurt.pdf)。这是维基百科关于[数值分析](http://en.wikipedia.org/wiki/List_of_numerical_analysis_topics)的条目。

**Q.** 如何将 IEEE 位表示转换为双精度浮点数？

**A.** 这里有一个[十进制到 IEEE 转换器](http://babbage.cs.qc.edu/courses/cs341/IEEE-754.html)。在 Java 中，要获取变量 x 的 IEEE 754 位表示，使用 `Double.doubleToLongBits(x)`。根据[Code Project](http://www.codeproject.com/useritems/precisefloating.asp)的说法，要获取大于 x 的最小双精度数（假设 x 是正的且有限的），使用 `Double.longBitsToDouble(Double.doubleToLongBits(x) + 1)`。

Q. 有没有直接的方法来检查整数类型的溢出？

A. 不。整数类型在任何情况下都不指示溢出。当分母为零时，整数除法和整数余数会抛出异常。

Q. 如果我输入一个太大的数字，比如 `1E400`，会发生什么？

A. Java 返回错误消息“浮点数太大”。

Q. 浮点类型有什么不同？

A. 溢出的操作会评估为正无穷大或负无穷大。下溢的操���会导致正零或负零。数学上没有明确定义的操作会评估为 NaN（不是一个数字），例如 `0.0/0.0`，`Math.sqrt(-3.0)`，`Math.acos(3.0)`，`Math.log(-3.0)` 和 `Math.pow(8, 1.0/3.0)`。

Q. 如何测试我的变量是否具有 NaN 值？

A. 使用方法 `Double.isNaN()`。请注意，NaN 是无序的，因此涉及一个或两个 NaN 的比较操作，如 >、< 和 = 总是评估为 false。任何涉及 NaN 的 != 比较都评估为 true，即使 (x != x)，当 x 是 NaN 时也是如此。

Q. -0.0 和 0.0 有什么区别？

A. 两者都是表示零的方式。如果 x = 0.0 并且 y = -0.0，那么 `(x == y)`。然而，1/x 产生 Infinity，而 1/y 产生 -Infinity。程序 NegativeZero.java 说明了这一点。它给出了一个令人惊讶的反例，即如果 `(x == y)`，那么 `(f(x) == f(y))`。log 0 = -infinity，log (-1) = NaN。log(ε) vs. log(-ε)。

Q. 我听说程序员永远不应该比较两个实数是否完全相等，而应该始终使用类似于 if |a-b| < ε 或 |a-b| < ε min(|a|, |b|) 的测试。这是正确的吗？

A. 这取决于情况。如果您知道浮点数是精确可表示的（例如，1/4 的倍数），那么可以进行精确相等的比较。如果浮点数不能精确表示，则通常首选相对误差方法（但如果数字非常接近零，则可能失败）。绝对值方法可能会产生意想不到的后果。不清楚要使用什么值的 ε。如果 a = +ε/4，b = -ε/4，我们真的应该认为它们相等吗。传递性不成立：如果 a 和 b 是“相等的”，b 和 c 是“相等的”，那么 a 和 c 可能不是“相等的”。

Q. Java 使用什么规则来打印双精度数？

A. 通过将所有指数位设置为 1。这里是 [java.lang.Double API](http://docs.oracle.com/javase/6/docs/api/java/lang/Double.html#toString(double))。它总是至少打印小数点后一位数字。之后，它使用尽可能多的数字（但不超过）来区分数字与最近可表示的双精度数。

Q. 零、无穷大和 NaN 如何使用 IEEE 754 表示？

A. 通过将所有指数位设置为 1。正无穷 = 0x7ff0000000000000（所有指数位为 1，符号位为 0，所有尾数位为 0），负无穷 = 0xfff0000000000000（所有指数位为 1，符号位为 1，所有尾数位为 0），NaN = 0x7ff8000000000000（所有指数位为 1，至少一个尾数位设置为 1）。正零 = 所有位为 0。负零 = 所有位为 0，除了符号位为 1。

Q. 使用双精度 IEEE 浮点数存储 0.1 时表示的确切值是多少。

A. 它是 0.1000000000000000055511151231257827021181583404541015625。您可以使用 `System.out.println(new BigDecimal(0.1));` 来自己查看。

Q. 什么是 `StrictMath`？

A. Java 的 `Math` 库保证其结果与真实答案的 1 或 2 [ulps](http://mindprod.com/jgloss/ulp.html) 之内。Java 的 `StrictMath` 保证所有结果准确到真实答案的 1/2 ulp。速度与准确性的经典权衡。

Q. 什么是 `strictfp` 修饰符？

A. 在声明类或方法时也可以使用 `strictfp` 修饰符。这确保浮点结果在不同的 JVM 中是逐位准确的。IEEE 标准允许处理器在结果溢出时使用更高精度进行中间计算。`strictfp` 要求每个中间结果被截断为 64 位双精度格式。这可能会对性能造成重大影响，因为英特尔奔腾处理器寄存器使用 IEEE 754 的 80 位双扩展格式。没有多少人会使用这种模式。

Q. 编译器标志 `javac -ffast-math` 是做什么的？

A. 它放宽了 IEEE 的一些舍入要求。它使一些浮点计算更快。

Q. 整数是否总是使用 IEEE 浮点数精确表示？

A. 是的，除了 52 位尾数的溢出。使用类型 `double` 时，不精确表示的最小正整数是 2⁵³ + 1 = 9,007,199,254,740,993。

Q. 当 a 和 b 是浮点数时，(a + b) 是否总是等于 (b + a)？

A. 是的。

Q. x / y 是否总是等于相同的值，不受我的平台影响？

A. 是的。IEEE 要求操作（+ * - /）必须精确执行，然后四舍五入到最接近的浮点数（如果出现平局，则使用银行家舍入：四舍五入到最接近的偶数）。这提高了可移植性，但以效率为代价。

Q. `(x - y)` 是否总是等于 `(x + (-y))`？

A. 是的。由 IEEE 754 保证。

Q. -x 是否总是等于 0 - x？

A. 几乎是，除非 x = 0。那么 -x = -0，但 0 - x = 0。

Q. (x + x == 2 * x) 是否成立？(1 * x == x)？(0.5 * x == x / 2)？

A. 是的，由 IEEE 754 保证。

Q. x / 1000.0 是否总是等于 0.001 * x？

A. 不是。例如，如果 x = 1138，则它们是不同的。

Q. 如果 `(x != y)`，那么 `z = 1 / (x - y)` 是否总是保证不会产生除以零的情况。

A. 是的，由 IEEE 754 保证（使用非规格化数）。

Q. `(x >= y)` 是否总是等同于 `!(x < y)`？

A. 如果 `x` 或 `y` 中有一个是 `NaN`，或者两者都是 `NaN`，则不会。

问：为什么不使用十进制浮点而不是二进制浮点？

A. [十进制浮点](http://www2.hursley.ibm.com/decimal/decifaq1.html)相对于二进制浮点有几个优势，特别是对于金融计算。但是，通常需要大约 20% 的额外存储空间（假设使用二进制硬件存储），而且生成的代码速度略慢。

问：为什么不使用固定点表示而不是浮点？浮点？

A. 固定点数在小数点后具有固定数量的数字。可以使用整数算术表示。浮点数具有动态精度的滑动窗口，提供了很大的动态范围和高精度。固定点数用于一些没有 FPU 的嵌入式硬件设备（为了节省成本），例如音频解码或 3D 图形。当数据受到一定范围的限制时，适用。

有关 Java 中数值计算的好资源吗？

A. [Java numerics](http://math.nist.gov/javanumerics/) 提供了关于 Java 数值计算的信息的焦点。[JSci](http://jsci.sourceforge.net/api/index.html)：Java 中用于数值计算的免费科学 API。

问：为什么 Java 的 `Math.sin` 和 `Math.cos` 函数比它们的 C 对应函数慢？

A. 在 -pi/4 到 pi/4 范围内，Java 使用硬件 sin 和 cos 函数，因此它们的执行时间与 C 中的大致相同。超出此范围的参数必须通过取模 pi 转换为此范围。正如 James Gosling 在 x87 平台上的[博客](http://blogs.sun.com/roller/page/jag?entry=transcendental_meditation)中所述，硬件 sin 和 cos 使用一种近似值，使计算速度快，但不符合 IEEE 所需的精度。C 实现通常对所有参数使用硬件 sin 和 cos，以速度换取 IEEE 符合性。

#### 练习

1.  以下代码片段的结果是什么？

    ```java
    double a = 12345.0;
    double b = 1e-16;
    System.out.println(a + b == a);

    ```

1.  列出具有 1 个符号位、3 个指数位和 2 个尾数位的 6 位浮点数的所有可表示数字。以下代码片段的结果是什么？

1.  以下代码片段打印出多少个值？

    ```java
    for (double d = 0.1; d <= 0.5; d += 0.1)
        System.out.println(d);
    for (double d = 1.1; d <= 1.5; d += 0.1)
        System.out.println(d);

    ```

    *答案：*九（第一个循环中五个，第二个循环中四个）。输出为：

    ```java
    0.1
    0.2
    0.30000000000000004
    0.4
    0.5
    1.1
    1.2000000000000002
    1.3000000000000003
    1.4000000000000004

    ```

1.  执行以下代码片段时打印出什么数字，其中 N = 25？

    ```java
    for (int i = 0; i < N; i++) {
       int counter = 0;
       for (double x = 0.0; x < i; x += 0.1)
          counter++;
       if (counter != 10*i) System.out.print(i + " ");
    }

    ```

    *答案：*1 5 6 7 8 9 10 11 12 13 14 15 16 17 18。你不太可能在不输入的情况下预测这个。避免使用浮点数来检查循环继续条件。

1.  以下代码片段的结果是什么？

    ```java
    for (double t = 0.0; t < 100.0; t += 0.01)
       System.out.println(t);

    ```

    *答案：*几乎符合你的预期，但最不显著的两三位有很多噪音。

1.  以下代码片段打印什么？

    ```java
    System.out.println(0.9200000000000002);
    System.out.println(0.9200000000000001);

    ```

    两次打印出 0.9200000000000002！

1.  找到一个值 x，使得 (0.1 * x) 与 (x / 10) 不同。

1.  找到一个实数 a，使得 (a * (3.0 / a)) 不等于 3.0。*答案：*如果 a = 0，则第一个表达式计算结果为 NaN。

1.  找到一个实数 a，使得 (Math.sqrt(a) * Math.sqrt(a)) 不等于 a。*答案：*a = 2.0。

1.  找到浮点值，使得 (x/x != 1)，(x - x != 0)，(0 != 0 * x)。*答案：*考虑 x 的值为 0、+- 无穷大或 NaN。

1.  找到浮点值 `x` 和 `y`，使得 `x >= y` 为 `true`，但 `!(x < y)` 为 `false`。

    *提示：*考虑 `x` 或 `y`（或两者）的值为 `NaN` 的情况。

1.  FloatingPoint.java 中以下代码片段的结果是什么？

    ```java
    float f = (float) (3.0 / 7.0);
    if (f == 3.0 / 7.0) System.out.println("yes");
    else                System.out.println("no");

    ```

1.  来自 S. M. Rump 的《计算机结果有多可靠》的示例。查看程序 Rump.java。

    +   计算 a*a - 2*b*b，其中 a = 665857，b = 470832，类型为 `float`。然后计算 a*a - 2.0*b*b。使用 `double` 类型重复。Java 的答案为 float：0.0 和 11776.0。Java 的答案为 double：1.0。精确答案为：1.0。

    +   计算 9x⁴ - y⁴ + 2y²，其中 x = 10864，y = 18817，类型为 `double`。Java 答案为 2.0。精确答案为 1.0。

    +   计算 p(x) = 8118x⁴ - 11482x³ + x² + 5741x - 2030，其中 x = 0.707107 是 `float` 和 `double` 类型。float 的 Java 答案：1.2207031E-4。double 的 Java 答案：-1.9554136088117957E-11。精确答案：-1.91527325270... * 10^-7。

1.  您认为使用 `double` 类型来存储总是以 1/64 递增的股价是个好主意吗？解释为什么或为什么不��*答案*：是的，这是完全可以的，因为这些值在二进制浮点数中可以精确表示。如果股价以十进制表示，例如 45.10，那可能会导致舍入误差。

1.  修复 Exponential.java，使其能正确处理负输入，使用文本中描述的方法。

1.  从左到右求和以下实数。使用浮点运算，并假设您的计算机只存储三位小数的精度。

    ```java
    0.007 0.103 0.205 0.008 3.12 0.006 0.876 0.005 0.015

    ```

    使用优先队列算法重复。使用 Kahan 的算法重复。

1.  编写一个程序，读取一系列银行账户值，并打印平均值，精确到最接近的一分钱，使用银行家舍入法。输入值将以空格分隔，并使用两位小数。提示：避免使用 `Double.parseDouble`。

    ```java
      100.00   489.12   1765.12   3636.10
     3222.05  3299.20   5111.27   3542.25
    86369.18   532.99

    ```

1.  以下 代码片段 打印什么？

    ```java
    long  x = 16777217;       // 2²⁴ + 1
    System.out.println(x);
    float y = 16777217;
    DecimalFormat df = new DecimalFormat("0.00000000000");
    System.out.println(df.format(y));

    ```

    *答案*：16777217 和 16777216.00000000000。2²⁴ + 1 是最小的正整数，使用 `float` 类型无法精确表示。

1.  能找到值 a、b 和 c，使得 Math.sqrt(b*b - a*c) 无效（NaN），但 (b*b < a*c) 为假吗？Kahan。

1.  以下 两个循环 各有什么问题？

    ```java
    int count1 = 0;
    for (float x = 0.0f; x < 20000000.0f; x = x + 1.0f)
       count1++;
    System.out.println(count1);

    int count2 = 0;
       for (double x = 0.0; x < 20000000.0; x = x + 1.0)
          count2++;
       System.out.println(count2);

    ```

    *答案*：当 x = 16777216.0f 时，第一个代码片段会陷入无限循环，因为使用 `float` 类型无法精确表示 16777217.0f，而 16777216.0f + 1.0f = 16777216.0f。第二个循环保证能正确运行，但使用 `int` 类型的变量作为循环变量可能更有效率。

1.  定义 e 的一种方式是当 n 趋近无穷大时的极限 (1 + 1/n)^n。编写一个计算程序，使用这个公式估计 e。对于哪个值的 n 你得到了最好的 e 近似值？*提示*：如果 n 太大，那么在浮点运算中 1 + 1/n 等于 1。

1.  以下 `Math.max()` 实现有什么问题。

    ```java
    public static double max(double x, double y) {
        if (x >= y) return x;
        return y;
    }

    ```

    *答案*：double 不能正确处理 NaN。根据这个定义，max(0, NaN) 是 NaN，但 max(NaN, 0) 是 0。应该是 NaN。

1.  并非所有减法都会导致灾难性的消除。演示当 x 接近 y 时，表达式 x² - y² 会出现灾难性的消除。然而，改进后的表达式 (x + y)(x - y) 仍然减去几乎相等的量，但这是一种良性的消除。

1.  (Goldberg) (1 + i/n)^n 在涉及利息的金融计算中出现。重写为 e^(n ln (1 + i/n))。现在的技巧是计算 ln(1+x)。当 x << 1 时，Math.log(1+x) 不准确。

    ```java
    if (1 + x == 1) return x
    else return (x * Math.log(1 + x)) / (1 + x) - 1.

    ```

    在 Java 1.5 中的替代方法：`Math.log1p(x)`

1.  要计算 e^x - 1，使用 `Math.expm1(x)`。对于 x 附近的值，Math.expm1(x) + 1 比 Math.exp(x) 更准确。

1.  灾难性的消除：f(x) = e^x - sin x - cos x 在 x = 0 附近。使用 x² + x³/3 作为 x = 0 附近的近似值。

1.  灾难性的消除：f(x) = ln(x) - 1。对于 x 附近的 e 使用 ln(x/e)。

1.  灾难性的消除：f(x) = ln(x) - log(1/x)。对于 x 附近的 1 使用 2 ln(x)。

1.  灾难性的消除：x^(-2)(sinx - e^x + 1)。

1.  找到一个 x 的值，使得 `Math.abs(x)` 不等于 `Math.sqrt(x*x)`。

1.  **数值稳定性。** *黄金分割数* φ = sqrt(5)/2 - 1/2 = 0.61803398874989484820... 它满足方程φ^N = φ^(N-2) - φ^(N-1)。我们可以使用这个递归来计算φ的幂，从 phi0 = 1，phi1 = φ开始，并通过迭代递归来计算φ的连续幂。然而，浮点舍入误差会在 N = 40 左右时影响计算。编写一个程序 Unstable.java，读取一个命令行参数 N，并打印出使用上述递归和`Math.pow()`计算的φ^N。运行你的程序，N 分别为 40 和 100，看看舍入误差的后果。

#### 创意练习

1.  **舍入误差。** 求和。相对误差 = |x - x'| / |x| = 与单位无关。一个想法是创建一个数字的优先级队列，并重复添加两个最小值并插入回优先级队列。 (参见练习 XYZ。) 更简单更快的替代方案：Kahan 求和公式 (Goldberg，定理 8)。利用(x + y) + z 不等于 x + (y + z)这一事实的有用算法的例子。优化编译器最好不要重新排列项。

    ```java
    double c = 0.0, sum = 0.0, y;
    for (int i = 0; i < N; i++)
      y = term[i] - c;
      c = ((sum + y) - sum) - y;
      sum = t;

    ```

    推荐方法：排序和添加。

1.  **柯西-施瓦茨不等式。** 柯西-施瓦茨不等式保证对于任意实数 x[i]和 y[i]，有

    ```java
    (x1x1 + ... xnxn) × (y1y1 + ... ynyn)  ≥ (x1y1 + ... xnyn)2

    ```

    特别地，当 n = 2，y[1] = y[2] = 1 时，我们有

    ```java
    2(x1x1 + x2x2) ≥ (x1 + x2)2

    ```

    编写一个程序 CauchySchwartz.java，读取两个整数 x[1]和 x[2]，并验证浮点数中的恒等式不一定成立。尝试 x[1] = 0.5000000000000002 和 x[2] = 0.5000000000000001

1.  **切比雪夫距离计算逼近。** 使用以下逼近计算 p 和 q 之间的距离，而不进行昂贵的平方根运算。sqrt(dx² + dy²) = max(|dx|, |dy|) + 0.35 * min(|dx|, |dy|)。有多精确。

1.  **毕达哥拉斯。** 编写一个程序 Pythagoras.java，读取两个实数命令行参数 a 和 b，并打印出 sqrt(a*a + b*b)。尝试避免溢出。例如，如果|a| >= |b|，则计算|a| sqrt(1 + (b/a)*(b/a))。如果|a| < |b|，则进行类似操作。例如：x = y = DBL_MAX / 10.0;

    Java 1.5 以来的可靠实现：`Math.hypot(a, b)`。

1.  **溢出。** 以下代码片段的结果是什么？

    ```java
    double a = 4.0, b = 0.5, c = 8e+307;
    System.out.println((a * b) * c);
    System.out.println(a * (b * c));

    ```

1.  **优化编译器。** 一个优化编译器... 必须谨慎地应用代数定律到计算机程序中，因为这可能导致灾难性的结果。证明浮点数中，加法不是可结合的。即找到值 a、b 和 c，使得((a + b) + c) != (a + (b + c))。还证明分配律不一定适用，找到值 a、b 和 c，使得(a * (b + c)) != (a * b + a * c)。问题在于乘法更加明显 ((a * b) * c) != (a * (b * c))。给出一个简单的例子。

1.  **整数运算。** 在 Java 中，整数加法和乘法在数学上是可结合的，例如，(a+b)+c 总是等于 a+(b+c)。

1.  **调和和。** 重新进行调和和计算，但从右到左而不是从左到右求和。这说明加法不是可结合的 (a + b) + c vs. a + (b + c)，因为我们根据从左到右或从右到左求和得到不同的答案。

1.  **圆周率。** 比较以下两种逼近数学常数 pi 的方法。当 p_k > p_k-1 时重复。序列 p_k 收敛到 pi。

    ```java
    s_6  = 1                               s_6  = 1
    s_2k = sqrt(2 - sqrt((2-s_k)(2+s_k))   s_2k = s_k / sqrt(2 + sqrt((2-s_k)(2+s_k))
    p_k  = k * s_k / 2                     p_k  = k * s_k / 2

    ```

    第二个公式的行为要好得多，因为它避免了灾难性的消除 2 - sqrt((2-s_k)(2+s_k))。

1.  **Jean-Michael Muller 的例子。** 考虑序列 x[0] = 4，x[1] = 4.25，x[n] = 108 - (815 - 1500/x[n-2]) / x[n-1]。程序 Muller.java 试图估计 n 变大时 x[n]收敛到的值。它计算值为 100.0，但正确值为 5。

1.  **另一个 Kahan 的例子。** 迷思：如果你不断增加精度并且答案收敛，那么它就是正确的。反例：E(0) = 1，E(z) = (exp(z) - 1) / z。Q(x) = |x - sqrt(x² + 1)| - 1/(x + sqrt(x² + 1))，H(x) = E(Q(x)²)。计算 x = 15.0, 16.0, 17.0, 9999.0 时的 H(x)。使用更多精度，比如使用 `BigDecimal`。 

1.  分割有理数 (a + ib) /(c + id)。参见 Smith 的公式（11）。

1.  对于整数类型，我们必须注意溢出问题。溢出的相同原则也适用于浮点数。例如，要计算 sqrt(x*x + y*y)，如果 x < y，则使用 fabs(y) * sqrt(1+(x/y)*(x/y))，如果 x > y，则使用类似的方法。x = y = DBL_MAX / 10.0;

1.  **Gamma 函数。** 编写一个程序 Gamma.java，接受一个命令行参数 x，并打印出 Gamma(x) 和 log Gamma(x) 至 9 个有效数字，其中 Gamma(x) 是 gamma 函数：

    |

    ```java
    Gamma(x) = integral( tx-1 e-t, t = 0..infinity )

    ```

    |

    Gamma 函数是阶乘函数的连续版本：如果 n 是正整数，则 n! = Gamma(n+1)。使用 [Lanczos' formula](http://www.rskey.org/gamma.htm)：

    |

    ```java
    Gamma(x) ≈ (x + 4.5)x - 1/2 * e-(x + 4.5) * sqrt(2 π) *
        [ 1.0 + 76.18009173    / (x + 0)   - 86.50532033    / (x + 1)
              + 24.01409822    / (x + 2)   -  1.231739516   / (x + 3)
              +  0.00120858003 / (x + 4)   -  0.00000536382 / (x + 5)
        ]

    ```

    |

    对于 x > 1，这个结果精确到 9 个有效数字。

1.  **Siegfried M. Rump 的例子。** 编写一个程序 Remarkable.java 来计算

    ```java
    y = 333.75 b6 + a2(11 a2 b2 - b6 - 121 b4 - 2) + 5.5 b8 + a/(2b)

    ```

    对于 a = 77617 和 b = 33096。尝试使用不同的浮点精度。可以重写

    ```java
    x = 5.5 b8
    z = 333.75 b6 + a2(11 a2 b2 - b6 - 121 b4 - 2)
    y = z + x + a/(2b)

    ```

    结果表明 x 和 z 有 35 位数字是相同的。

    ```java
    z = -7919111340668961361101134701524942850
    x = +7919111340668961361101134701524942848

    ```

    在 Java（在 Sun Sparc 上）使用单精度得到的答案是 6.338253 ×10²⁹，使用双精度是 a/(2b) = 1.1726039400531787。真正的答案是 -2 + a/(2b) = -54767/66192 = -0.82739606....，但 z + x = -2 项会在没有至少使用 122 位精度的情况下被灾难性地取消！我们使用 Java 的 Math 库中的 `BigDecimal` ADT 来匹配这个答案。

    论文 [A Remarkable Example of Catastrophic Cancellation Unraveled](http://link.springer.de/link/service/journals/00607/bibs/1066003/10660309.htm) 描述了这个著名的公式，展示了为什么在不同精度下获得相同结果并不意味着数学上的准确性。此外，即使在符合 IEEE 754 标准的平台上（Intel、Sun Sparc），根据中间舍入模式是 24、53 还是 64 位，你可能会得到不同的答案。这个引人注目的例子是由 IBM 的 Siegfried M. Rump 为 S/370 架构构建的。

1.  **三角形的面积。** 编写一个程序 `TriangleArea.java`，接受三个命令行输入 a、b 和 c，表示三角形的边长，并使用海伦公式打印出三角形的面积：area = sqrt(s(s-a)(s-b)(s-c))，其中 s = (a + b + c) / 2。当 a 接近 b 时不准确。使用 1960 年代的公式进行改进：排序 a >= b >= c。如果 (c + b < a) 则不是合法三角形。1/4 * sqrt((a+(b+c)) * (c-(a-b)) * (c+(a-b)) *(a+(b-c)))。例如：a = b = 12345679.0，c = 1.01233995。

1.  **二次方程公式。** *二次方程* 是一个用于找到 ax² + bx + c 的实根的小学公式。

    ```java
    discriminant = Math.sqrt(b*b - 4*a*c);
    root1 = -b + discriminant / (2*a);
    root2 = -b - discriminant / (2*a);

    ```

    一个初学者程序员需要计算二次方程的根，可能会天真地应用这个公式。当然，我们应该小心处理 a = 0 的情况，以避免除以零。此外，我们应该检查判别式 b² - 4ac。如果是负数，则没有实根。然而，这个公式的主要问题是，如果 a 或 c 非常小，那么其中一个根将通过从几乎相等的数量中减去 b 来计算。计算根的正确方法是

    ```java
    if (b > 0) q = -0.5 * (b + discriminant);
    else       q = -0.5 * (b - discriminant);
    root1 = q / a;
    root2 = c / q;

    ```

    例如，x² - 3000000x + 2 的根是 r1 和 r2。当使用双精度算术时，小根（6.665941327810287E-7）的小学公式仅提供 3 位精度，而好的公式提供 12 位精度（6.666666666668148E-7）。当 b = -30000000 时，情况恶化。小学方法现在只有两位精度（6.705522537231445E-8）与 12 位精度（6.666666666666681E-8）。当 b = -300000000 时，小学方法的精度为零（0.0），而不是 16（6.666666666666667E-9）。

    考虑用表格总结这一点。

1.  **有益的消除。** 减法中的大量消除并不总是导致灾难性的消除。消除误差并不总是导致不准确。如果 x 接近 1，则 f(x) = (x-1) / (e^(x-1) - 1)的直接实现不准确。令人惊讶的是，下面的解决方案无论 x 的大小如何都能实现完全的工作精度。通过有益的消除在极端巧妙中获得的最终计算答案比中间结果更准确！误差分析可能非常微妙和不明显。

    ```java
    double y = x - 1.0;
    double z = Math.exp(y);
    if (z == 1.0) return z;
    return Math.log(z) / (z - 1.0);

    ```

    程序 BeneficialCancellation.java 实现了直接和数值精确的方法。

    参见[Java 的浮点数如何伤害每个人](http://www.eecs.berkeley.edu/~wkahan/JAVAhurt.pdf)。

1.  **1 - cos(x)**。比较天真地计算 1 - cos(x)和使用公式 cos(x) = 2 sin(x/2)²。[正确计算的方法](http://www.plunk.org/~hatch/rightway.php)。

1.  **平方根消除。** 设计一个准确的表达式，表示(b² + 100)的平方根与 b 之间的差异。*解决方案*：如果 b 为负数或相对较小，只需做明显的事情。如果 b 远大于 100，可能会发生灾难性的消除。差异等于 b(sqrt(1 + 100/b²) - 1)。如果 x 非常小，那么可以安全地用 1 + x/2 来近似 sqrt(1 + x)。现在，差异大约为 b (100 / b²) / 2 = 50 / b。
