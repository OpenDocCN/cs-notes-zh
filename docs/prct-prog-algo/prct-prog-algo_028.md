# 5.3 通用性

> 原文：[`introcs.cs.princeton.edu/java/53universality`](https://introcs.cs.princeton.edu/java/53universality)

本节正在大力施工中。

20 世纪最重要的科学成就之一是形式化*计算*的概念。在本节中，我们探讨了这个宇宙中什么是可计算的这个基本问题。20 世纪的惊人发现是，通用计算机能够执行任何其他计算机可以执行的计算。也许这是计算机科学中最重要的思想。

点燃计算机革命的颠覆性技术。通用性有助于解释世界各地网页的快速采用。在 Web 存在之前，人们已经使用计算机进行数字计算和文字处理。通用计算机很容易适应处理 Web 协议、MP3 文件和数字照片。一旦技术可用，人们就可以立即利用其力量。（工业革命等过程采用速度较慢。）“很难想象电视的这个过程的类比 - 就好像数百万美国人被诱使购买他们客厅里的大型惰性盒子，十年后有人梦想出开始向他们广播图片的技术。但这与 Web 发生的情况差不多。”（Kleinberg-Papadimitriou）我们只能想象未来几十年会出现什么新技术，但我们可以肯定我们的通用计算机将能够充分利用它。

不需要单独的机器来处理图像和文本。一个通用机器适用于所有任务。这与大多数其他领域形成鲜明对比。例如，没有通用的烹饪设备。相反，我们有用于切片、混合、搅拌、烘烤、煮沸、烤、烤面包、烘烤、酿造和辐射的单独设备。在自然科学中可能有一个例外：基因组（可以改变基因组中的几个符号并创建新的生物体，就像编写新的计算机程序一样）。

许多不同类型的计算设备：Cray 超级计算机、戴尔个人电脑、iMac、Palm Pilot、XBox、Tivo、图灵机、TOY 机、Java 编程语言、Microsoft Excel、Java 手机、量子图灵机、Perl 编程语言。这些东西能做的事情与 Gaggia 浓缩咖啡机能做的事情有根本区别吗？

图灵机在功能上等同于 TOY 和 Java。可以用 Java 程序模拟任何图灵机，可以用图灵机模拟 TOY，可以用 TOY 机模拟 Java。同样的想法适用于 C、C++、C#、Python、Excel、Outlook。还有 Mac、PC、Cray、ENIAC、康拉德·祖斯的 Z3（但直到 1998 年才被证明）、Palm pilot。还有 TiVo、Xbox、Java 手机/但不包括 DFA、Gaggia 浓缩咖啡机，或者 MIT 学生们为了玩井字游戏而制作的[Tinker Toy 计算机](http://www.rci.rutgers.edu/~cfs/472_html/Intro/TinkertoyComputer/TinkerToy.html)。

TOY 机和 Java 编程语言有一个无限的存储量（*可扩展存储*）的隐含假设。否则，TM 就会严格更强大。这个假���合理吗？如果无限让你感到恐惧，你可以考虑签订服务合同。如果需要更多内存，你只需上网订购一些。我们默认认为栈/队列是无限的，尽管内存最终会用完。图灵机是计算的模型，而不是计算机的模型。因此，我们不限制机器带的磁带的大小。

Java 程序编写为处理任意长度的输入。您可能无法在内存有限的计算机上执行大输入的程序，但您可以在内存更大的计算机上执行该程序。图灵机模拟程序，而不是机器：对于给定问题存在一个快速的 Java 程序等价于存在一个相同问题的快速图灵机。

非正式地，*算法*是解决问题的逐步过程。形式上，我们将算法定义为图灵机。每个图灵机能够执行单个算法，例如，测试一个整数是否为质数。在这个意义上，图灵机类似于计算机程序（软件）而不是计算机（硬件）。Knuth：“算法是与宇宙物理定律无关的抽象概念。”这意味着我们可能需要为我们想要执行的每个算法构建一个单独的图灵机。这是非常不切实际的！

**通用图灵机。**  [通用图灵机](http://mathworld.wolfram.com/UniversalTuringMachine.html)是一种特定的图灵机，可以模拟任何图灵机的行为（包括自身！）。这使得图灵机能够回答关于其他图灵机（或自身）的问题。艾伦·图灵描述了这样一台机器：它的存在意味着有一台单独的图灵机，即 UTM，能够运行任何算法。关键思想是将图灵机的描述本身视为数据。例如，我们可以对下面所示的图灵机进行编码

![0 和 1 数量相等的图灵机](img/8e84ff66123059347fdbfffa2111b494.png)

其中包含以下表格。我们将每个状态标记为 0 到 5。我们为每个转换箭头包括一个行，用于表示每个状态的索引以及其标签（左、右、是、否或停止）。我们为每个转换箭头包括一行四个符号，分别表示当前状态、输入符号、下一个状态和写入符号。

```java
0 L
1 R
2 R
3 Y
4 R
5 N
0 1 # #
2 0 1 x
4 0 0 x
1 2 0 x
1 3 # #
1 4 1 x
2 5 # #
4 5 # #

```

现在，我们可以将表连接成一个关于字母表{0, 1, 2, 3, 4, 5, x, #}的单个字符串。

```java
0 L 1 R 2 R 3 Y 4 R 5 N 0 1 # # 2 0 1 x ... 4 5 # #

```

并用这个输入初始化磁带。由于原始图灵机本身也有一个输入，例如，我们想要检查其质数性质的整数，我们将这个输入附加到图灵机描述的末尾，用一个新符号分隔。

```java
0 L 1 R 2 R 3 Y 4 R 5 N 0 1 # # 2 0 1 x ... 4 5 # # # # 0 0 1 1 1 0 # #

```

我们还可以附加起始状态和磁带头的初始位置。

*通用图灵机*接受图灵机的描述作为输入（以及图灵机的初始磁带内容），并在该图灵机上模拟输入。因此，通用图灵机可以模拟任何单个 TM 的行为。用现代术语来说，通用图灵机是一个*解释器* - 它对任何图灵机进行逐步模拟。程序和数据是一回事 - 程序（图灵机）只不过是一个看起来像其他数据的符号序列。当输入到通用图灵机时，程序“变得活跃”并开始计算。（从 Web 下载程序和电子邮件病毒类似 - 只是数据，直到你双击它们并将它们提供给操作系统执行）。

建立这样一个通用图灵机似乎是一项艰巨的任务。艾伦·图灵在他的 1937 年论文中描述了第一台这样的图灵机。1962 年，明斯基发现了一台使用四个符号字母表执行的令人惊奇的 7 状态 UTM，但描述起来相当复杂。

**通用计算机。** 首次由艾达·洛芙莱斯（Ada Lovelace）阐述。她将巴贝奇的分析引擎描述为适合“开发和制表任何函数...引擎[是]任何不确定性功能的材料表达，无论其一般性和复杂性程度如何。”她描述了它在科学计算中的用途，包括三角函数和伯努利数。她还提倡它可以用于制作音乐和图形。通用计算机类似于通用图灵机：它们能够运行不同的算法，而无需进行任何硬件修改。这是可能的，因为现代微处理器基于*冯·诺伊曼结构*。在这种模型中，计算机程序和数据存储在同一主存储器中。这意味着内存内容可以视为机器指令或数据，取决于上下文。这与 UTM 的磁带内容完全类似，其中包含程序（原始 TM）和数据（原始 TM 的磁带内容）。艾伦·图灵关于 UTM 的工作预示了通用计算机的发展，并可以看作是软件的发明！

## 丘奇-图灵论题。

1936 年，阿隆佐·丘奇（Alonzo Church）和艾伦·图灵（Alan Turing）独立提出了计算模型，他们认为这些模型体现了机械过程的计算概念。丘奇发明了[λ演算](http://en.wikipedia.org/wiki/Lambda_calculus)来研究可计算性概念，而图灵则使用他的图灵机。尽管这两种模型看起来非常不同，但图灵后来证明它们是等价的，因为它们都选择了相同的数学函数集。他们得出了相同的结论，我们用图灵机的术语表达：

> *图灵机可以执行任何可以用纯机械过程描述的事情。*

换句话说，任何理想数学家可以执行的过程都可以在图灵机上模拟。随后，这个论题被扩展为断言宇宙中所有（物理上可利用的）过程都可以由图灵机模拟，这是我们将考虑的丘奇-图灵论题的版本。这将计算研究简化为图灵机的研究，而不是无限数量的潜在计算设备。这意味着我们不必寻找更强大的机器；我们唯一的选择是利用现有机器的能力或创建新的能够更快地完成任务的机器。这个论题的逆命题也具有深远的影响。它表明，如果某件事在图灵机上无法完成，那么我们无法使用任何纯机械过程来完成它。当我们发现有些问题图灵机无法解决时，我们将在第 7.6 节探讨其后果。请注意，丘奇-图灵论题不是一个数学命题，也不受严格证明的约束。它是关于现实可实现宇宙的陈述。然而，像任何良好的科学理论一样，丘奇-图��论题也可能被推翻。如果有人展示了一个严格更强大的计算模型，而且这个模型是物理上可利用的，我们将否定丘奇-图灵论题。

这个论题等同于说任何通用编程语言都足以表达任何算法。

**普适性。** 丘奇-图灵论题暗示了不同计算模型之间的*普适性*。有大量支持表明这种普适性。向图灵机添加新功能并不会使其在接受的语言或计算的函数方面更强大。

| 修改的图灵机 | 描述 |
| --- | --- |
| 多个磁头 | 两个或更多独立的磁头 |
| 多个磁带 | 两个或更多磁带 |
| 多维磁带 | 二维磁带 |
| 非确定性 | NFA 控制磁带而不是 DFA |
| 概率性 | 可以抛硬币。如果大多数硬币翻转导致接受状态，则接受输入 |
| 可编辑 | 可以在磁带上插入和删除符号 |

图灵机的定义非常健壮。以下限制不会影响图灵机的能力（当分别应用于标准图灵机时）。

| 修改图灵机 | 描述 |
| --- | --- |
| 单向无限 | 磁带只在一个方向上是无限的 |
| 二进制 | 磁带字母表只包含两个符号 |
| 两状态 | 控制磁带的 DFA 具有两个状态 |
| 非擦除 | 一旦写入磁带，就永远不能重新写入符号的图灵机 |
| 可逆时间 | 前一个状态总是可以从当前状��和磁带内容唯一确定。 |

数学家、计算机科学家、生物学家和物理学家已经考虑了许多其他计算模型。以下是一些已被证明与图灵机在能力上等效的模型的部分列表，从而进一步支持了丘奇-图灵论题。

| 通用计算模型 | 描述 |
| --- | --- |
| 波斯特形式系统 埃米尔·波斯特，1920 年代 | 旨在从一组公理中证明数学命题的字符串替换规则。 |
| 无类型λ演算 阿隆佐·邱奇，1936 | 一种定义和操作函数的方法。是函数式编程语言的基础，包括 Lisp 和 ML |
| 通用图灵机 阿兰·图灵，1936 | 可以模拟任何其他图灵机行为的图灵机。 |

| 一般递归函数 哈布兰德，1932

库尔特·哥德尔，1934 | 处理自然数上的计算的函数。 |

| 部分递归函数 阿隆佐·邱奇，1932

史蒂芬·克林，1935 | 处理自然数上的计算的函数。 |

| 马尔可夫算法 安德烈·马尔可夫，1960 | 按照预定顺序依次应用字符串替换规则。 |
| --- | --- |
| 无限制文法 诺姆·乔姆斯基，1950 年代 | 按任意顺序依次应用字符串替换规则，直到满足某种停止条件。被语言学家用来描述自然语言。 |
| 标记系统 埃米尔·波斯特，1921 年，1935 年，1965 年 | 只要字符串至少包含 k 个字母：读取第一个字母，删除前 k 个字母，并根据第一个字母附加一个字符串。 |
| 扩展 L-系统 阿里斯蒂德·林登迈尔，1976 | 并行应用字符串替换规则。生物学家用于模拟植物生长。 |
| 半图灵系统 阿克塞尔·图厄，1910 | 按任意顺序应用字符串替换规则。 |
| 霍恩子句逻辑 阿尔弗雷德·霍恩，1951 | 基于逻辑的定理证明系统。构成 Prolog 语言的基础。 |

| 1D 元胞自动机 马修·库克，1983

史蒂芬·沃尔夫拉姆，2002 | 一个一维布尔数组，其单元格的值根据相邻单元格的状态而改变。对应于有限冲激响应数字滤波器。 |

| 2D 元胞自动机 约翰·冯·诺伊曼，1952

约翰·康威，1960 年代 | 一个二维布尔单元格数组，其值根据相邻单元格的状态而改变。最著名的例子是康威的生命游戏。 |

| 波斯特机器 埃米尔·波斯特，1936 | 一个 DFA 加上一个队列。 |
| --- | --- |
| 两栈机 | 一个 DFA 加上两个栈。 |

| 两寄存器机器 谢泼德森-斯特吉斯，1963

马文·明斯基，1961 | 一个 DFA 加上两个整数计数器，它可以递增、递减，并与零进行比较。 |

| 编程语言 | Java, C, C++, Perl, Python, PHP, Lisp, PostScript, Excel, ... |
| --- | --- |
| 随机访问机 | 有限数量的寄存器加上可以用整数地址访问的内存。包括 TOY 和几乎所有现代微处理器。 |
| 指针机 | 有限数量的寄存器加上可以作为链表访问的内存。 |

| 量子图灵机 理查德·费曼，1965

大卫·迪奥特，1985 | 使用量子态叠加进行计算。 |

| 台球计算机 Fredkin-Toffoli, 1982 | 不可区分的台球在平面上移动，彼此之间和内部障碍物弹性碰撞。 |
| --- | --- |
| 粒子机器 | 信息通过粒子在空间中传递，计算发生在粒子碰撞时。 |
| 过滤器自动机 Park-Steiglitz-Thurston, 1985 | 使用新计算值一旦可用即刻使用的元胞自动机。对应于无限冲激响应数字滤波器。 |
| 广义移位映射 Christopher Moore, 1990 | 一个在由抛物面镜组成的三维势阱中移动的单个经典粒子。 |
| DNA 计算机 Len Adleman, 1994 | 使用 DNA 链上的生物操作进行计算。 |
| 类移位动力系统 Christopher Moore, 1981 | 使用混沌理论的基于动力学的计算。 |
| 动力系统 Sinha-Ditto, 1998 | 使用混沌理论的基于动力学的计算。 |
| 动力系统 | 混合系统、分段仿射系统、饱和线性系统。 |
| 孤立子碰撞系统 Ken Steiglitz, 2000 | 在均匀介质中的时间门控 Manakov 空间孤立子。一种没有空间固定门的无门计算机。 |
| 高级 Petri 网 Carl Petri, 1962 | 用于同时发生事件的自动机的泛化。应用于管理、制造、通信协议、容错系统。 |

**交互式计算。** 或许最自然的计算形式是作为计算器 - 将输入转换为输出。当图灵机计算时，它不接受外部输入；这阻止了它直接模拟许多自然过程。我们的计算机执行许多不太适合放入这个框架的操作。例如，你的操作系统、用户界面、文字处理器、视频游戏、踢足球的机器人、网络、传感器。所有这些都涉及与程序的外部代理（人或其他程序）的交互或通信。*交互机器* 是图灵机的自然推广，它接受同步或异步输入流。

为什么这不违反了丘奇-图灵论题？有人可能会争辩说外部代理本身可以被图灵机模拟！

**计算的物理学。** 在他们具有里程碑意义的论文[保守逻辑](http://www.digitalphilosophy.org/download_documents/ConservativeLogic.pdf)中，Fredkin 和 Toffoli 论证计算是一个物理过程，最终受物理原则支配。他们提出了一些所有计算过程都受到的公理。图灵的目标是发明一台捕捉计算本质的机器，同时仍受物理定律约束。Fredkin 和 Toffoli 讨论了图灵机如何隐含地体现这前三个公理。

+   *信息传播速度受限。* 在物理学中，*远距作用* 受到光速的限制。对于图灵机，磁带头每次只能向左或向右移动一个单元。因此，因果效应只能通过局部相互作用传播。

+   *有限系统状态中可以编码的信息量受限。* 在物理学中，热力学和量子物理的考虑表明存在这样的限制。例如，[全息原理](http://en.wikipedia.org/wiki/Holographic_principle)是一个关于量子热力学的猜想，它对时空表面积上的信息量设定了一个限制（每平方米[10⁶⁹ 位](http://arxiv.org/abs/hep-th/0203101)）。对于图灵机，每个单元只包含三种可能的符号之一。

+   *可以构建宏观、耗散性物理设备，以可识别和可靠地执行逻辑函数 AND、OR 和 FAN-OUT。* 这意味着可以用物理部件制造图灵机，并可靠地运行它们。

迪奥特提出了*丘琴原理*，它断言宇宙能够包含一个能够模拟宇宙本身的通用机器。这将计算性概念与物理学联系起来。

**祖斯-弗雷德金论**。大约在 1960 年，爱德华·弗雷德金首次提出了一个激进的观念，即宇宙是一个（通用的）元胞自动机，一种高度并行的计算设备。在 1960 年代末，康拉德·祖斯独立提出了宇宙是在计算机上计算的观点，可能是一个元胞自动机。他将其称为*Rechnender Raum*或*Computing Cosmos*。这一颇具争议的论点被称为*祖斯-弗雷德金论*。从物理学的角度来看，这是一个涵盖一切的普适理论。许多复杂系统可以用简单的离散过程来解释是事实。关于自然界中这种复杂性是由元胞自动机还是其他过程负责的问题，仍然是一个迷人的开放科学问题。尽管图灵-丘琴论被广泛接受，但更具深远意义的祖斯-弗雷德金论仍然相对默默无闻，尚未被广泛接受。其中一个主要挑战是[将其与量子物理相协调](http://digitalphysics.org/Publications/Petrov/Pet02a2/Pet02a2.htm)。此外，这一理论很难验证，尚未证明在利用传统方法无法做出的关于宇宙的准确预测方面有用。康拉德·祖斯论是两个新兴学科——数字力学和[数字物理学](http://digitalphysics.org)的基石。它具有深刻的哲学意义。例如，如果宇宙是一个元胞自动机，那么我们人类以及我们的逻辑思维就是在元胞自动机的某个时空区域中执行的*算法*。在祖斯、弗雷德金和许多其他人的研究基础上，史蒂夫·沃尔夫勃罗姆在他的书[一种新的科学](http://www.wolframscience.com/nksonline/)中提倡整个宇宙是一个巨大的计算过程，并且这样的物理过程最好通过研究元胞自动机等简单的计算模型来理解。

数字物理学：宇宙是一个确定性计算机的输出。

**计算的普遍限制**。霍金-贝肯斯坦界限假设一个半径为 R、能量为 E 的球体能够容纳的信息量（量子态数或可编码的比特数）存在一个限制：I &le 2 π E R / (ℏ c ln 2)，其中ℏ为普朗克常数，c 为光速。另一种表达方式是使用 E = mc²，&le k M R，其中 M 为区域的质量，k 约为 2.57686 × 10⁴³比特/(m 千克)。最大处理速度受限于状态转换的最短时间，这个时间受限于光穿过半径为 R 的区域所需的时间：π E / (ℏ ln 2)比特/秒。贝肯斯坦界限基于黑洞物理学。这意味着，理论上，图灵机，以其任意大小的磁带，只存在于我们的想象中（如果它们具有有限大小和有界能量）。尽管在实践中，它们是现实的极好模型。

问：假设人类大脑存储了 10¹⁶比特，质量为 1 千克，大致呈球形，半径为 10 厘米。将其效率与贝肯斯坦界限进行比较。

这个更严格的界限基于 Krauss 和 Starkmann 的[物理论文](http://arxiv.org/abs/astro-ph/0404510)，该论文表明，如果宇宙正在加速，那么即使在未来无限遥远的情况下，可以处理的信息总量也存在固有限制。估计的限制约为 10¹²⁰比特，因此目前无需担心！Seth Lloyd 的这篇 Nature 论文对 1 升容积的 1 千克计算机的计算速度和可访问的内存量进行了定量限制。

**超越教堂-图灵论题。** 是否有任何类型的计算无法由图灵机完成，但可以使用其他类型的物理或抽象机器完成？是的。我们考虑了一些所谓的[超级计算](http://arxiv.org/pdf/math.LO/0209332)的代表性例子。

这些计算模型能够解决一些问题（例如，停机问题），这些问题无法使用图灵机解决。我们不知道如何构建这样的机器，因此不违反教堂-图灵论题。

+   *Oracle 图灵机。* 一种带有用于回答问题的预言的图灵机，例如，用于停机问题。这种计算模型比图灵机更强大，但我们对如何构建这样的机器毫无头绪。因此，它们（目前）不违反教堂-图灵论题。

+   *带有初始铭文的图灵机。* 以无限数量的符号开始的图灵机。同样，这导致了比图灵机更强大的计算模型，但我们不知道如何构建这样的机器，因为它使用了无限的存储空间。

+   *实值图灵机。* 这是一种抽象的计算模型，其中每个磁带单元存储实值而不是离散符号。[Blum-Shub-Smale 模型](http://citeseer.ist.psu.edu/170087.html)允许每个磁带单元存储任意实数，可能是超越数。旨在捕捉科学计算、计算几何、计算代数、连续优化中的连续问题。这些机器使用无限精度操作实数。基本的单位成本计算步骤包括：算术运算（+，-，*，/），任意常数，比较运算或（，=如果在实数域上）。输入和输出是 R^n 中的向量。如果 x 在 R^n 中，则其大小为 n。（可以用另一个域替换实数，例如，复数 C，但不允许有序比较。如果域是 F_2，则恢复经典图灵模型。）在这个模型下存在不可判定的问题：给定一个复数 z，它是否在 Mandelbrot 集中？给定一个起始点 x，牛顿法是否收敛？在这个模型下存在“NP 完全”问题：背包问题：给定 n 个实数，是否存在一个子集的和恰好为 1？给定 n 个变量的实系数的 4 次多项式，它是否有一个实零点？给定 n 个变量的复多项式的有限集，它们是否有一个公共零点？然而，目前尚不清楚连续值是否真实存在于自然界中，如果存在，任何自然过程是否能利用它们的力量。

这些计算模型在可计算性方面等同于图灵机，例如，都无法解决停机问题。然而，这些模型可以解决计算函数和确定语言范围之外的问题，例如生成真正的随机数。

+   *概率图灵机。* 一种*概率图灵机*类似于非确定性图灵机，只是它从合法选择中均匀随机选择下一个转换。在可决定的语言或可计算的函数方面，概率图灵机与图灵机的能力是等价的。然而，概率图灵机可以生成真正的随机位，这是传统图灵机无法实现的。然而，似乎存在利用量子力学或其他自然现象产生随机性的物理过程。支持祖斯-弗雷德金论题的人会认为自然只产生伪随机数，这些可以在确定性图灵机上模拟。

+   *量子图灵机*。计算是一个物理过程，但图灵机忽略了量子力学效应。德沃斯提出了一种行为类似于图灵机但利用量子力学来进行计算的量子图灵机。量子图灵机在决定语言或计算函数方面与图灵机的能力相当。然而，量子图灵机开辟了新的计算模式，因为它们可以执行除计算函数和决定语言之外的任务。一个引人注目的例子出现在密码学中。在第零章中，我们考虑了一种称为一次性密码本的加密方案。为了使它们实用，我们需要一种有效的方法在两个方之间共享密钥（一串随机位），而不被第三方拦截，或者如果被拦截，两个通信方应该能够检测到。使用经典计算机和物理学是不可能实现无条件安全密钥分发的。然而，通过利用海森堡不确定性原理，本内特和布拉萨德（1984 年）设计了一个解决方案来解决这个问题。不确定性原理的主要论点是（i）从物理系统中提取信息的任何测量都必然会改变该系统，（ii）提取关于某一数量的信息的任何测量都必然会阻止提取关于共轭数量的信息。本内特和布拉萨德的方案使用单个光子发送每个量子位（比特的量子等价物）。光子在第一次被读取时就会被改变，因此不能被拦截而不被检测到。虽然我们还不知道如何构建量子图灵机，但科学家们已经开发了专门的密码学电路来实现本内特和布拉萨德的方案，并已经用它们安全地在 15 公里的光纤电缆上分发密钥。

莱文的[Tale of One-way Functions](http://arxiv.org/pdf/cs.CR/0012023)是对超级计算的一个对立观点。

#### 练习

1.  **康威的生命游戏**。普适性。这是马丁·加德纳在 1970 年发表在《科学美国人》上的[文章](http://ddi.cs.uni-potsdam.de/HyFISCH/Produzieren/lis_projekt/proj_gamelife/ConwayScientificAmerican.htm)。

1.  **元胞自动机**。[元胞自动机](http://mathworld.wolfram.com/CellularAutomaton.html)是试图模拟自然规律的计算机模拟。它们用于模拟生物、化学和物理过程，包括：根据伊辛模型的铁磁性、森林火灾传播、非线性化学反应扩散系统、湍流流动、生物色素图案、材料断裂、晶体生长以及植物和动物的生长。它们还用于图像处理、[计算机图形学](http://madeira.cc.hokudai.ac.jp/RD/takai/automa.html)、大规模并行硬件设计、密码学和艺术。

    一维元胞自动机是一个随时间演化的细胞数组，根据相邻细胞的状态和一组规则进行演化。在给定时间 t，每个细胞要么是活的，要么是死的。规则 90 表示细胞 i 在时间 t 处于活动状态，如果其相邻细胞（细胞 i-1 或细胞 i+1）在时间 t-1 处于活动状态。程序 Cellular.java 使用两个布尔数组模拟了这种元胞自动机的行为。数组元素 cells[i]在当前时间 t 中为 true，如果细胞 i 在当前时间 t 中是活的，则为 true；否则为 false；数组元素 old[i]在上一个时间步骤 t-1 中为 true，如果细胞 i 在上一个时间步骤 t-1 中是活的，则为 true；否则为 false。

1.  **元胞自动机**。这里有一篇关于[元胞自动机](http://cscs.umich.edu/~crshalizi/notebooks/cellular-automata.html)的好评。这里是[元胞自动机 FAQ](http://cafaq.com/)。给出 1d 通用自动机。

1.  **开火小队同步问题。** [开火小队问题](http://mathworld.wolfram.com/FiringSquadProblem.html)最初由迈尔希尔在 1957 年提出，并由摩尔在 1962 年在有限状态机的背景下解决。您有一个具有 2^n 个相同单元格的一维元胞自动机，每个单元格可以采用有限数量的颜色之一。它们都以相同的速度运行，每个单元格只能与其相邻的单元格通信。所有单元格最初都是白色的。设计机器，使得在向第一个机器（将军）发出“开始”信号后，所有机器（士兵）在时间 t 第一次变为特殊的“开火”颜色。您事先不知道数组的大小，因此您的解决方案不得依赖于 n。*提示*：尝试找到中间单元格。

1.  **斑马条纹。** 通过使用乌龟图形模拟 2D 元胞自动机来生成合成斑马条纹的图片。

    1.  首先创建一个 N×N 的单元格网格，随机初始化每个单元格为黑色或白色。然后，运行 10 个阶段，每个阶段依次遍历 N×N 单元格，更新单元格(i, j)的颜色（黑色或白色）如下：

        1.  对于每个黑色相邻单元格(i', j')，使得|i - i'| = 0 或 1 且|j - j'| <= 3，将 2.0 添加到一个累加总和中。

        1.  对于每个黑色相邻单元格(i', j')，使得|i - i'| = 2 或 3 且|j - j'| <= 3，从累加总和中减去 1.2。

        1.  如果累加总和超过 1.4，则将(i, j)着色为黑色；否则将其着色为白色。编写一个程序 Zebra.java 来说明元胞自动机的结果。

    1.  尝试使用不同的加权函数（例如 2.0 和-0.4），并使用曼哈顿距离函数|i - i'| + |j - j'|代替上面的函数。

1.  **帕特森蠕虫。** [帕特森蠕虫](http://www.accessv.com/~sven/worms/)是由约翰·康威发现并由马文·加德纳广泛推广的一种重现谜题，类似于康威的生命游戏。编写一个程序`PatersonWorm.java`，在乌龟图形中展示帕特森蠕虫的动画。

1.  **林登迈尔系统。** 将替换规则`F -> F+F--F+F`并行应用于初始字符串`F+F--F+F`。例如，一次应用后，字符串变为`F+F--F+F--F+F--F+F--F+F--F+F`。如果将`F`解释为向前走 1 步，`+`解释为顺时针旋转 60 度，`-`解释为逆时针旋转 60 度，这个命令序列绘制了科赫雪花。编写一个程序 Lindenmayer.java，它接受一个命令行参数 N，并打印生成 N 阶科赫曲线的命令。*提示*：使用字符串库方法`replaceAll`。

1.  **用林登迈尔系统生成树。** 编写一个程序 LSystem.java，使用林登迈尔系统创建类似树的图形：XYZ。

1.  **林登迈尔系统解释器。** 编写一个程序，读取林登迈尔系统的描述并绘制生成的图案。

1.  **阿克曼函数。** 阿克曼函数 A(m, n)是一个看似简单但在算法分析和复杂性理论中起着关键作用的函数。它的递归定义如下：

    > A(0, n) = n + 1
    > 
    > A(m, 0) = A(m - 1, 1)
    > 
    > A(m, n) = A(m - 1, A(m, n - 1))

    编写一个程序 Ackermann.java，接受两个命令行参数 M 和 N，并计算 A(M, N)。

    1.  计算 A(3, 9)时会发生什么？答案：堆栈溢出错误。

    1.  A(5, 5)是多少？答案：数字太多，无法打印出来。这里是[A(4, 2)](http://www.kosara.net/thoughts/ackermann42.html)。要看到这个函数增长的速度有多快，请考虑以下等价定义：

        > *A*(0, *n*) = *n* + 1
        > 
        > *A*(1, *n*) = 2 + (*n* + 3) - 3
        > 
        > *A*(2, *n*) = 2 × (*n* + 3) - 3
        > 
        > *A*(3, *n*) = 2 ^(*n* + 3) - 3
        > 
        > *A*(4, *n*) = 2^(2^(...²)) - 3        （塔中有*n* + 3 个项）
        > 
        > ...

1.  **巴克函数。** 巴克函数的递归定义如下：

    ```java
    f(m, n) = f(m-1, f(m, n-1))
    f(0, n) = n + 1
    f(1, 0) = 2
    f(2, 0) = 0
    f(m, 0) = 1 for m = 3, 4, ...

    ```

    手动计算 f(1, n)，f(2, n)，f(3, n)和 f(4, n)作为 n 的函数。

    *答案*: 2 + n, 2n, 2^n, 2^(2^(2^(...²)))（塔中有 n 个项）。

1.  **元胞自动机沙堆。** 使用[元胞自动机模型](http://schuelaw.whitman.edu/JavaApplets/SandPileApplet/)模拟沙子堆积。

1.  **谢林分离模型。** 研究[谢林分离模型（SSM）](http://www.econ.iastate.edu/tesfatsi/demos/schelling/schellhp.htm)。"首个能够自组织的动态系统的建设性模型。" 模拟了一个整合环境，其中每个代理人都略微偏好邻居是相同类型的可能导致分离。对于每个有颜色的单元，如果超过 1/3（或其他阈值）的邻居是不同颜色的，则移动到随机选择的单元（或让每个单元进行随机行走）。 （或者也许检查所有在某个邻域内的单元，权重与 1/d 成比例）。谢林获得了 2005 年的诺贝尔经济学奖。 绿色乌龟和红色乌龟。 偏好通过池塘传播。 即使乌龟最初只希望相似度达到 30％，最终也会达到约 70％。 这里有一个[演示](http://ccl.northwestern.edu/netlogo/models/run.cgi?Segregation.650.479)。
