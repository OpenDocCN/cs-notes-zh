# 6.3 机器语言编程

> 原文：[`introcs.cs.princeton.edu/java/63programming`](https://introcs.cs.princeton.edu/java/63programming)

本节正在建设中。

尽管 TOY 机器语言只包含 16 种不同的指令类型，但可以执行各种有趣的计算。事实上，任何可以在您的 PC 上用 Java 编程语言完成的计算也可以在 TOY 中完成（前提是给予 TOY 足够的主存储器和时间）。这可能是一个令人惊讶的事实；我们将在第八章中稍后证明它。下面，我们描述 TOY 语言中的每个指令。

## 内存-寄存器传输（操作码 8 和 9）。

为了在寄存器和主存储器之间传输数据，我们使用*load*（操作码 8）和*store*（操作码 9）指令。这些操作很方便，因为不可能直接对主存储器的内容进行算术运算。相反，数据必须首先转移到寄存器中。还有一些情况下，不可能同时在寄存器中维护程序的所有变量，例如，如果我们需要存储超过 16 个值。我们通过将变量存储在主存储器中，并使用*load*和*store*指令将它们来回传输到寄存器中，克服了 16 个寄存器的限制。

## 算术运算（操作码 1 和 2）。

*add*（操作码 1）和*subtract*（操作码 2）执行传统的算术运算。在 TOY 中，所有算术运算都涉及 16 位的二进制补码整数，如第 5.1 节所述。

+   *加法。* 程序 add.toy 将内存地址`00`和`01`视为存储变量`RA`和`RB`的输入值。然后计算这两个值的和，并将结果暂时放在寄存器 C 中。最后，将寄存器 C 的内容传输回内存，并将其存储在内存地址`02`处。重要的是要注意，内存位置`00`到`02`在此程序中永远不会被执行；它们被视为数据。

    |

    ```java
    00: 0005   5
    01: 0008   8

    10: 8A00   R[A] 
    ```

    |

    在程序终止时，寄存器 C 包含值`000D`，这是十进制整数 13 的十六进制等价值。（如果你计算出结果`0013`，开始适应使用十六进制整数。）

    如果算术运算的结果太大而无法适应 16 位寄存器怎么办？这种溢出通过忽略除最右边的 4 位十六进制数字外的所有内容来处理。例如，将`EFFF`和`1005`相加的结果是`0004`，因为`EFFF + 1005 = 10004`在十六进制中，我们丢弃了前导数字。这就是 Java 中加法的工作方式，只是`int`中有 32 位而不是 TOY 字中的 16 位。

+   *减法。* 类似地，程序 subtract.toy 计算`0005 - 0008 = FFFD`。答案`FFFD`是使用二进制补码整数表示的十进制整数-3 的十六进制等价值。（回顾第 5.1 节中对二进制补码表示法的描述。）

    |

    ```java
    00: 0005   5
    01: 0008   8

    10: 8A00   R[A] 
    ```

    |

## 标准输入和标准输出。

*load*和*store*指令也用于访问*标准输入*和*标准输出*。TOY 硬件中断拦截了特殊的内存地址`FF`：不是在内存位置`FF`加载或存储信息，而是从键盘接收数据或发送到屏幕。

+   *求两个整数的和。* 程序 stdin.toy 从标准输入读取两个整数，并将它们的和写入标准输出。

    |

    ```java
    10: 8AFF    read R[A] from stdin
    11: 8BFF    read R[B] from stdin
    12: 1CAB    R[C] 
    ```

    |

    当程序执行时，它会暂停，直到用户输入两个整数。通常情况下，整数被指定为 4 位十六进制数字。然后计算它们的和，并将结果打印到屏幕上。

+   *斐波那契数列。* 程序 fibonacci.toy 将斐波那契数列 0、1、1、2、3、5、8、D 等打印到标准输出。

+   *整数序列的和。* 程序 sum.toy 从标准输入读取一个整数序列，并打印出它们的和。在读取整数`0000`时停止。它演示了一个可以处理超出 TOY 内存容量的信息的程序。

*标准输入和输出的影响。* TOY 的标准输入和标准输出功能对 TOY 机器的功能有深远影响。一个明显的特点是将信息输入和输出到机器中。这些信息可以是数据，也可以是指令！*引导计算机*是将一系列存储的指令（例如操作系统）复制到计算机中。TOY 机器只有有限的内存（256 个字加上几个寄存器）。尽管如此，仍然可以处理比这更多的信息。标准输入的另一个优点是它提供了一种粗糙的用户交互形式。

## 流程控制（操作码 C 和 D）。

到目前为止，我们已经看到了如何将 TOY 用作计算器。*分支*语句使我们能够发挥 TOY 的真正力量，就像`while`循环和`if-else`条件语句使我们能够发挥 Java 的力量一样。程序计数器的值控制着 TOY 机器将执行下一个语句。通常，程序计数器在每个时间步长增加一次。这导致指令按顺序执行，依次执行。*分支如果为零*（操作码 C）和*分支如果为正*（操作码 D）使我们能够直接更改程序计数器，从而改变程序的控制流。

+   *二的幂。* 程序 powers2.toy 使用*分支如果为正*语句打印出正的二的幂。

    |

    ```java
    00: 0001   1

    10: 8A00   RA  0) goto 11         }
    14: 0000   halt

    ```

    |

+   *无限循环。* 改变程序流程控制的能力引入了无限循环的可能性，就像 infinite_loop.toy 中的情况一样。

    |

    ```java
    10: 1000   no-op                         
    11: 1000   no-op                         
    12: C010   goto 10                       

    ```

    |

+   *乘法。* TOY 指令集中明显缺少乘法指令。为了在软件中实现相同的效果，我们描述并实现了一个算法来将两个整数相乘。计算`c` = `a * b`的蛮力方法是将`c = 0`，然后将`a`加到`c`，`b`次。这表明有一个重复`b`次的循环。我们通过创建一个计数器变量`i`，将其初始化为`b`，然后递减到达 0 来实现这一点。我们使用分支如果为正指令来检测此事件。程序 multiply.toy 从内存位置`0A`和`0B`中加载两个整数到寄存器 A 和 B 中，将它们相乘并将结果放入寄存器 C，然后将结果写回内存位置`0C`。

    |

    ```java
    0A: 0003   3
    0B: 0009   9
    0C: 0000   0

    0D: 0000   0
    0E: 0001   1

    10: 8A0A   RA 
    ```

    |

    机智的读者可能会注意到我们的算法存在严重的性能缺陷。如果值很大，蛮力算法效率低下。循环迭代`b`次，由于`b`是一个 16 位整数，它可以达到 32767。在 64 位机器上，这个问题会更加突出，循环可能需要令人难以置信的 9,223,372,036,854,775,807 次迭代！幸运的是，我们可以引入更好的算法思想（正如我们下面所做的那样）来拯救这个看似无望的任务。

**TOY 惯用法。** TOY 中有几种常见的惯用法或伪指令，可用于常见的编程任务。这些技巧中的许多依赖于寄存器 0 始终存储值`0000`。

+   *寄存器之间的传输。* 假设您想要使寄存器 2 具有与寄存器 1 相同的值。没有内置指令可以做到这一点。依靠寄存器 0 始终包含`0000`这一事实，我们可以使用加法指令将`R0`和`R1`相加，并将结果放入`R2`中。

    |

    ```java
    14: 1201    R[2] 
    ```

    |

+   *交换。* 作为一个更复杂的例子，假设我们想要交换两个寄存器 RA 和 RB 的内容....

+   *无操作*。在像 Java 这样的结构化编程语言中（具有`for`和`while`循环），插入额外代码很容易。在像 TOY 这样的非结构化语言中（其中有行号和 goto 语句），必须小心插入代码。分支语句将内存地址硬编码为要跳转的地址；如果插入代码，程序的行号可能会更改。为了避免一些尴尬，机器语言程序员通常发现填充程序中的“无用”语句以充当占位符很方便。这些语句称为*无操作*，因为它们不执行任何操作。指令`1000`非常适合这个目的，因为寄存器 0 始终为 0。 （指令`10xy`对于任何 x 和 y 的值也是无操作，因为寄存器 0 始终包含 0，无论您如何尝试更改它。

+   *跳转*。没有直接将程序计数器更改为`addr`的指令。但是，可以使用零值分支指令与寄存器 0 来实现相同的效果。例如，指令`C0F0`将程序计数器更改为`F0`，因为寄存器 0 始终为 0。

## 位操作符（操作码 3, 4, 5, 和 6）。

位操作 - *按位与*（操作码 3）、*按位异或*（操作码 4）、*左移*（操作码 5）和*右移*（操作码 6） - 与 Java 中的类似操作一样，只是使用 16 位的二进制补码整数。

*按位与和按位异或*

*按位与*

*按位异或*

`00B5`

`00E3`

`3312`

`00A1`

*按位与*

|

```java
R[1] = 0000 0000 1011 0101 (binary) = 00B5 (hex)
R[2] = 0000 0000 1110 0011 (binary) = 00E3 (hex)
R[3] = 0000 0000 1010 0001 (binary) = 00A1 (hex)

```

|

+   *左移*（操作码 5）将位向左移动一定数量的位置，右侧填充 0。例如，如果寄存器 2 的值为`00B5`，寄存器 3 的值为`0002`，那么指令`5423`将值`02D4`赋给寄存器 4。要了解原因，请查看二进制表示。

    |

    ```java
    R[2]      = 0000 0000 1011 0101 (binary) = 00B5 (hex)  = 181 (dec)
    R[2] << 2 = 0000 0010 1101 0100 (binary) = 02D4 (hex)  = 724 (dec)

    ```

    |

    请注意，左移一位等同于乘以 2；左移*i*位等同于乘以 2^i。

+   *右移*（操作码 6）类似，但是位向右移动。根据符号位（最左边的位），左侧填充 0 或 1。例如，如果寄存器 2 的值为`00B5`，寄存器 3 的值为`0002`，那么指令`6423`将值`002D`赋给寄存器 4。要了解原因，请查看二进制表示。

    |

    ```java
    R[2]      = 0000 0000 1011 0101 (binary) = 00B5 (hex)  =  181 (dec)
    R[2] >> 2 = 0000 0000 0010 1101 (binary) = 002D (hex)  =   45 (dec)

    ```

    |

    寄存器 2 中的值为非负数，因此左侧填充 0。如果寄存器 2 的值为`FF4B`，那么右移的结果是`FFD3`。在这种情况下，寄存器 2 中的值为负数，因此左侧填充 1。

    |

    ```java
    R[2]      = 1111 1111 0100 1011 (binary) = FF4B (hex)  = -181 (dec)
    R[2] >> 2 = 1111 1111 1101 0010 (binary) = FFD2 (hex)  = - 46 (dec)

    ```

    |

    注意，将整数右移 1 位等同于将整数除以 2 并丢弃余数。这对于原始整数的符号无关紧要。一般来说，将整数右移*i*位等同于将其除以 2^i 并向下取整。���请注意，当被除数为负数时，这与 Java 中对应的 2 的幂的整数除法并不完全一致，例如，-181/4 = -45。）这种移位称为*算术移位*或*有符号移位*：它保留二进制补码整数的符号。

**高效的乘法。** 使用位操作符，我们提供了一个高效的实现 multiply.toy。要将两个 16 位整数*a*和*b*相乘，我们让*b[i]*表示*b*的第*i*位。也就是说，

|           b = (b[15] × 2¹⁵) + (b[14] × 2¹⁴) + ... + (b[1] × 2¹) + (b[0] × 2⁰) |
| --- |

通过分配率，我们得到：

|           a × b = (a × b[15] × 2¹⁵) + ... + (a × b[1] × 2¹) + (a × b[0] × 2⁰) |
| --- |

因此，要计算*a × b*，只需添加上述 16 个项即可。从表面上看，这似乎将执行一次乘法的问题减少到 32 次乘法，每个 16 个项需要两次。幸运的是，这 32 次乘法都是非常特殊的类型。回想一下*a × 2^i*等同于将*a*左移*i*位。其次，注意*b[i]*要么是 0 要么是 1；因此第*i*项要么是`a << i`要么是 0。程序 multiply-fast.toy 循环 16 次。在第*i*次迭代中，它计算第*i*项并将其添加到寄存器 C 中存储的运行总数中。为了获得一些视角，回想一下用于乘法两个十进制整数的标准小学算法。我们刚刚描述的按位过程实际上只是将小学算法应用于二进制整数。

## 装载地址（操作码 7）。

装载地址指令（操作码 7）是 TOY 语言中最原始的赋值语句类型。下面的代码片段将寄存器 A 初始化为`30`。

|

```java
11: 7A30    R[A] 
```

|

在使用*装载地址*指令时，我们经常将目标寄存器视为存储某些数据的内存地址。在处理数组时，这尤其有用。在 C 编程语言中，这种类型的变量被称为*指针*。然而，我们也可以使用*装载地址*指令将一个小常数存储到寄存器中，而不是使用*装载*指令。请注意，*装载地址*只允许您将 8 位整数（`00`到`FF`）分配给寄存器，即使寄存器能够存储 16 位整数。

## 数组（操作码 A 和 B）。

数组并不直接内置在 TOY 语言中，但可以使用*装载地址*（操作码 7）、*装载间接*（操作码 A）和*存储间接*（操作码 B）指令来实现相同的功能。我们用两个示例说明这种技术。首先，我们将考虑一个程序，该程序读取一系列整数并以相反顺序打印它们。然后，我们将考虑一个更复杂的数组应用程序，该程序对一系列整数执行经典的插入排序算法。

+   *反转。*程序 reverse.toy 从标准输入读取一系列正整数，并在遇到整数`0000`时停止。它从地址`30`开始将整数存储在主内存中。我们使用装载地址指令来存储地址`30`。然后，它以相反的顺序遍历元素，并将它们打印到标准输入。我们使用寄存器 B 来跟踪读入的元素数量。我们安排寄存器 6 包含当前正在读取或写入的数组元素的内存位置。为了写入和读取数组元素，我们分别使用操作码 A 和 B。

    ```java
    10: 7101   R[1] 
    ```

+   *缓冲区溢出。*程序 reverse.toy 存在一个关键缺陷。由于 TOY 机器只有 256 个内存位置，因此不可能存储或反转包含太多元素的列表。在上面的示例中，当程序填满内存位置`30`到`FF`时，它将绕回并开始写入内存位置`00`到`0F`。很快，它将开始覆盖原始程序的行`10`到`20`。一个狡猾的用户可以利用这种*缓冲区溢出*，以这样的方式输入整数，使得标准输入的整数被解释为指令而不是数据。病毒经常通过这种缓冲区溢出攻击传播。

    程序 crazy8.toy 是`reverse.toy`的一个版本，它从内存地址 00 开始存储数组。因此，在读取并存储 16 个整数后，程序开始覆盖自身。下面的输入特别恶意。在标准输入中输入 20 个整数可以让用户控制机器，并使其无限循环打印出 8888。

    ```java
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    8888 8810 98FF C011

    ```

## 函数（操作码 E 和 F）。

在 Java 中，将程序分解为较小的函数非常有用。我们可以在 TOY 中做同样的事情。下面是一个调用带有两个参数的乘法函数并计算它们乘积的 TOY 程序。由于所有变量（寄存器）都是全局的，我们需要就调用函数达成一致的协议。我们假设我们要将存储在寄存器`A`和`B`中的整数相乘，并将它们的乘积存储在��存器`C`中。程序 multiply-function.toy 两次调用乘法函数来计算*x* × *y* × *z*，一次计算*x* × *y*，然后再次计算（*x* × *y*）× *z*。它使用了专门设计用于此目的的*跳转和链接*（操作码 F）和*跳转寄存器*（操作码 E）指令。指令`11`和`14`在跳转到位于`F0`的函数之前将程序计数器的值存储在寄存器 3 中。这使得可以返回到主程序，而不需要将地址硬编码到程序中。

每当程序计数器重置为`F0`时，旧的程序计数器都会保存在寄存器 F 中以备将来使用。指令`F5`通过将程序计数器重置为寄存器 F 中存储的值来从函数中返回。还要注意，程序计数器在执行指令之前会先递增。因此，在第一次函数调用时，寄存器 F 为`16`而不是`15`。

在编写机器语言函数时一定要非常小心使用哪些变量。没有所谓的“局部变量”。如果我们继续在乘法函数中使用寄存器 2 作为循环计数器，这将覆盖主程序中正在用于存储量`b`的寄存器 2。

**霍纳法**。我们可以使用乘法函数来*评估多项式*：给定整数系数*a[n]*，...，*a[2]*，*a[1]*，*a[0]*和整数*x*，在整数*x*处评估多项式*p(x) = a[n] x^n + ... + a[2] x² + a[1] x¹ + a[0] x⁰*。多项式评估是早期机器的一个*存在理由*。它有许多应用，包括研究弹道运动和将整数从十进制表示转换为十六进制表示。

多项式评估的蛮力算法是将*n+1*项相加，其中第*i*项是*a[i]*和*x^i*的乘积。要计算*x^i*，我们可以编写一个将*x*乘以自身*i-1*次的幂函数。*霍纳法*是一个更高效且更易于编码的巧妙替代方法。基本思想是明智地安排项的乘法顺序。我们可以通过分配性重写一个三次多项式：

|           p(x) = a[3] x³ + a[2] x² + a[1] x + a[0]   =  (((a[3]) x + a[2]) x + a[1]) x + a[0] |
| --- |

同样，我们可以重写一个五次多项式

|           p(x) = a[5] x⁵ + a[4] x⁴ + a[3] x³ + a[2] x² + a[1] x + a[0]   =  (((((a[5]) x + a[4]) x + a[3]) x + a[2]) x + a[1]) x + a[0] |
| --- |

使用霍纳法，只需要*n*次乘法即可评估一个*n*次多项式。此外，我们可以直接将该方法转换为 Java 或 TOY 代码。程序 horner.toy 是 TOY 版本。在 TOY 版本中，每次我们想要将两个整数相乘时，我们都调用我们的乘法函数。

霍纳法是由英国数学家 W. G. Horner 于 19 世纪发表的，但该算法在一个多世纪前就被艾萨克·牛顿使用过。

我们可以使用 horner.toy 将十进制整数转换为其十六进制表示。要将 765[10]转换为十六进制，我们设置输入`x = A`，`n = 3`，`a[2] = 7`，`a[1] = 6`和`a[0] = 5`。由于所有算术都是在十六进制中进行的，程序计算出 7 × 10² + 6 × 10 + 5 的十六进制等价值为`02FD`。

**插入排序**。程序`insertion-sort.toy`从标准输入中读取一系列正整数并对它们进行插入排序。在读取非正整数时程序终止。

## 链表。

|

```java
// data
01: 0001                           the constant 1
02: 00D0                           memory address of first node of linked list

// initialize
10: 8101  R1  0) goto 12    } while (x != null) 
17: 0000  halt               

// data
D0: 0001    D4: 0004    D8: 0000    DC: 0000
D1: 00D6    D5: 0000    D9: 0000    DD: 0000
D2: 0000    D6: 0002    DA: 0003    DE: 0000
D3: 0000    D7: 00DA    DB: 00D4    DF: 0000

```

|

这段代码将遍历从内存位置 `D0` 开始的链表，打印出每个“节点”中存储的整数。它将打印出 `0001 0002 0003 0004`。在整个计算过程中，R1 始终为 1。指令 `A304` 和 `A203` 中使用了索引寻址。寄存器 R2 是一个*指针* - 它是下一个节点的内存地址。寄存器 R3 是指向 R2 立即后面的内存地址的指针。在每次循环迭代中，我们打印由 R2 引用的内存中的值，并使用由 R3 引用的内存中的值来确定下一次迭代中 R2 将存储的内存地址。对于上面给出的数据，寄存器 R2 将按顺序具有值 `D0`、`D6`、`DA`、`D4` 和 `00`。这个过程重复，直到 R2 为 `0000`，即链表的末尾。在 Java 中，关键字 `null` 扮演 `0000` 的角色，并用于终止链表。

**递归。** 你也可以在 TOY 中进行递归，但这相当棘手。

#### 练习

1.  编写一个程序 powers2.toy，将所有正的 2 的幂打印到标准输出。

1.  给定整数 x，其*Collatz 序列*定义为如果 x 是偶数，则用 x/2 替换它，如果 x 是奇数，则用 3x + 1 替换它，并重复直到 x 为 1。编写一个程序 `collatz.toy`，从标准输入读取一个整数 x，并将其 Collatz 序列打印到标准输出。*提示*：使用右移运算符执行整数除法。

1.  编写一个程序 sum_1-n.toy，从标准输入读取一个整数 N，并打印出 1 + 2 + 3 + ... + N 的和。

1.  编写一个程序 `min3.toy`，从标准输入读取三个整数，并打印出最小的一个。

1.  编写一个程序 `max3.toy`，从标准输入读取三个整数，并打印出最大的一个。

1.  编写一个程序 `sort3.toy`，从标准输入读取三个整数，并按升序打印到标准输出。

1.  编写一个程序 chop.toy，从标准输入读取一个整数 N，并将其打印为 2 的幂的和。例如，如果 N = `012A`，那么程序应该打印出

    |

    ```java
    0002
    0008
    0020
    0100

    ```

    |

    因为 `012A` = `0002` + `0008` + `0020` + `0100`。

1.  这个问题测试加载地址、加载和间接加载之间的区别。对于以下每个 TOY 程序，在终止时给出寄存器 1、2 和 3 的内容。

    |

    ```java
    (a)  10: 7211        (b)  10: 8211         (c)  10: 7211
         11: 7110             11: 8110              11: A102
         12: 2321             12: 2312              12: 2312
         13: 0000             13: 0000              13: 0000

    ```

    |

1.  考虑以下 TOY 程序。在终止时，寄存器 3 的值是多少？

    |

    ```java
    10: 7101
    11: 7207
    12: 7301
    13: 1333
    14: 2221
    15: D213
    16: 0000

    ```

    |

1.  编写一个程序，从标准输入读取一个整数 a，并输出 a³。

1.  编写一个程序，从标准输入读取一个整数 a，并在标准输出中打印 `AAAA`，如果

    +   a = 3

    +   a > 3

    +   a < 3

    +   a != 3

    +   a >= 3

    +   a <= 3

1.  假设你将以下内容加载到 TOY 的 10-17 位置，将 PC 设置为 10，然后按运行。

    |

    ```java
    10: 7100   R[1] 
    ```

    |

    如果标准输入中出现以下数据，标准输出会打印什么？

    |

    ```java
    1112 1112

    ```

    |

    *答案*：TOY 程序从标准输入读取两个值。第一个值放入内存位置 15，最终被*执行为代码*。这插入了第二个加法指令。

1.  重复上一个问题，但现在标准输入中有以下数据。

    |

    ```java
    C011 C011 1112 1112

    ```

    |

1.  编写一个程序，从标准输入读取三个整数 a、b 和 c，并计算判别式 d = b² - 4ac。使用上面描述的乘法函数。

1.  假设你将以下内容加载到 TOY 的 10-17 位置，将 PC 设置为 10，然后按运行。该程序从标准输入读取一个整数，并将一个整数打印到标准输出。列出所有输入值在 `0123` 和 `3210` 之间，使得程序打印 `0000`。

    |

    ```java
    10: 8AFF   read R[A]
    11: 7101   R[1] 
    ```

    |

    *答案*：`0200 0400 0800 1000 2000`。对于所有二进制表示中最多有一个 1 的输入，即十六进制整数 0000、0001、0002、0004、0008、0010、...、8000，它返回 1。

1.  假设你在按运行之前将以下数据加载到内存位置 30 到 37。

    |

    ```java
    30-37:  0001  0002  0003  0004  0004  0003  0002  0001

    ```

    |

    将 PC 设置为 10，然后按运行。运行程序后，内存位置 30 到 37 的内容将是什么？

    ```java
    10: 7101  R[1] 
    ```

1.  将上述 TOY 程序翻译成 Java 代码，填写????。

    ```java
    for (int i = N;  i > ???? ;  i = i ????)
        for (int j = 0;  j < ???? ;  j = j ????)
            a[ ???? ] = ???? ;

    ```

1.  假设你将以下内容加载到 TOY 的 10-1F 位置，将以下数据加载到 30-37 位置，假设你在按下运行之前将以下数据加载到内存位置 30 到 37。

    |

    ```java
    0001  0002  0003  0004  0004  0003  0002  0001

    ```

    |

    将 PC 设置为 10，然后按运行。运行程序后，内存位置 30 到 37 的内容将是什么？

1.  假设你将以下内容加载到 TOY 的 10-1B 位置，将 PC 设置为 10，然后按运行。还假设以下数据从标准输入输入。打印出什么值？

    |

    ```java
    1CAB EF00 0000 4321 1234

    ```

    |

    |

    ```java
    10: 7101   R[1] 
    ```

    |

1.  重复上一个练习，但使用以下数据作为标准输入。

    |

    ```java
    2CAB EF00 0000 4321 1234

    ```

    |

1.  下表显示了 TOY 寄存器的内容和 TOY 内存的一部分。假设将程序计数器设置为 30 并运行。在标准输出中打印出什么，如果有的话，在终止时列出寄存器 2 和 3 的最终内容。

    |

    ```java
    R0: 0000 0000 0000 0000 0000 0000 0000 0000
    R8: 0000 0000 0000 0000 0000 0011 0000 0000

    20: 0000 0000 0000 0000 0000 0000 0000 0000
    28: 0000 005A 0000 0000 0000 0000 0000 0000
    30: 7101 7200 8329 1221 1331 A303 D333 92FF
    38: 0000 0000 0000 0000 0000 0000 0000 0000
    40: 7101 7200 8329 A403 1224 1331 A303 D343
    48: 92FF 0000 0000 0000 0000 0000 0000 0000
    50: 0003 0000 0005 0000 0004 0052 0000 0000
    58: 0001 0060 0000 0058 0000 0000 0000 0000
    60: 0002 0050 0000 0000 0000 0000 0000 0000

    ```

    |

1.  假设内存位置 D0 到 E0 的数据如下。运行`linked.toy`的结果是什么？ *答案*：1 2 3 4 5 6 7。

1.  更改上一个练习中的一个内存字，以便打印出 1 2 6 7 而不是 1 2 3 4 5 6 7。 （链表删除）

1.  更改三个内存字（覆盖一个，使用另外两个）以便打印出 1 2 3 4 8 5 6 7。 （链表插入）

#### 创意练习

1.  **最大值。** 编写一个名为`max.toy`的程序，从标准输入读取一系列非负整数，并打印出最大值。一旦遇到负整数，停止读取整数。

1.  **魔术交换。** 编写一个 TOY 代码片段，交换寄存器 A 和 B 的内容，而不写入主存储器或任何其他寄存器。提示：使用 XOR 指令。

1.  **32 位整数。** 用 TOY 表示 32 位二进制补码整数，使用内存或寄存器的两个连续字（大端或小端）。解释如何相加两个 32 位整数。

1.  **格雷码。** 编写一个 TOY 程序 graycode.toy，从标准输入读取一个整数 n（介于 1 和 15 之间），然后打印出`(i >> 1) ^ i`到标准输出，其中 i = 2^n - 1 到 0。生成的序列称为 n 阶[格雷码](http://mathworld.wolfram.com/GrayCode.html)。参见第 5.1 节中的练习 XYZ。

    可视化 X-TOY 模拟器使用 LCD 显示器显示标准输出。观看备���标准输出（打孔卡）并查看每行的单个位是很有启发性的。

1.  **最大公约数。** 编写一个程序 gcd.toy，从标准输入读取两个整数，并将它们的最大公约数打印到标准输出。编写一个假设寄存器 A 和 B 包含两个输入整数的函数，将值输出到寄存器 C，并返回到寄存器 F 中存储的地址。你可以使用以下（低效的）算法：

    |

    ```java
    while (b > 0) {
       if (b > a) swap a and b
       a = a - b
    }
    return a

    ```

    |

1.  **一次性密码本。** 在 TOY 中实现一次性密码本，用于加密和解密 256 位消息。假设密钥存储在内存位置 30-3F，并且输入由十六个 16 位整数组成。

1.  **点积。** 计算两个数组的点积，这两个数组从 RA 和 RB 位置开始，长度为 RC。

1.  **Axpy。** 给定标量 a，向量 x 和向量 b，计算向量 ax + b。

1.  **查找单身数字。** 假设一个包含 2N+1 个 16 位整数的序列出现在标准输入中，其中 N 个整数出现两次，一个整数只出现一次。编写一个 TOY 程序来找到单身整数。

    *提示*：对所有整数执行异或操作。
