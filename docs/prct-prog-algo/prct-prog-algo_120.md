# 1\.   算法分析

> 原文：[`aofa.cs.princeton.edu/10analysis`](https://aofa.cs.princeton.edu/10analysis)

本章考虑了算法分析的一般动机以及研究算法性能特征的各种方法之间的关系。

## 1.1 为什么要分析算法？

分析算法的最直接原因是为了发现其特性，以便评估其适用性于各种应用程序或将其与同一应用程序的其他算法进行比较。此外，算法分析可以帮助我们更好地理解它，并提出明智的改进意见。在分析过程中，算法往往会变得更短、更简单和更优雅。

## 1.2 计算复杂性。

理论计算机科学的一个分支，其目标是根据效率对算法进行分类，根据固有难度对计算问题进行分类，被称为*计算复杂性*。矛盾的是，这种分类通常不适用于预测性能或比较实际应用中的算法，因为它们侧重于增长阶的最坏情况性能。在本书中，我们专注于可以用于预测性能和比较算法的分析。

## 1.3 算法分析。

对算法运行时间的完整分析涉及以下步骤：

+   完全实现算法。

+   确定每个基本操作所需的时间。

+   确定可以用来描述基本操作执行频率的未知量。

+   为程序的输入开发一个现实模型。

+   分析未知量，假设模拟的输入。

+   通过将每个操作的时间乘以频率计算总运行时间，然后将所有乘积相加。

早期计算机上的经典算法分析可以得出运行时间的精确预测。现代系统和算法要复杂得多，但现代分析受到这样一种思想的启发，即原则上可以执行这种精确分析。

## 1.4 平均情况分析。

初等概率论提供了多种计算数量平均值的方法。虽然它们之间密切相关，但对于我们来说，明确地确定两种不同的计算平均值的方法会更方便。

+   *分布式。* 让 $\Pi_N$ 表示大小为 $N$ 的可能输入数量，$\Pi_{Nk}$ 表示导致算法成本为 $k$ 的大小为 $N$ 的输入数量，因此 $\Pi_N=\sum_k\Pi_{Nk}$。那么成本为 $k$ 的概率是 $\Pi_{Nk}/\Pi_N$，期望成本为 $${1\over \Pi_N}\sum_k k\Pi_{Nk}.$$ 分析取决于"计数"。大小为 $N$ 的输入有多少个，大小为 $N$ 的输入导致算法成本为 $k$ 的有多少个？这些是计算成本为 $k$ 的概率的步骤，因此这种方法可能是从初等概率论中最直接的方法。

+   *累积。* 让 $\Sigma_N$ 表示算法在所有大小为 $N$ 的输入上的总（或累积）成本。（也就是说，$\Sigma_N=\sum_kk\Pi_{Nk}$，但重点是不必以那种方式计算 $\Sigma_N$。）那么平均成本就是简单的 $\Sigma_N/\Pi_N$。分析取决于一个不太具体的计数问题：所有输入的算法总成本是多少？我们将使用使这种方法非常吸引人的通用工具。

分布式方法提供完整信息，可直接用于计算标准差和其他时刻。当使用另一种方法时，也可以使用间接（通常更简单）的方法来计算时刻，我们将看到。在本书中，我们考虑这两种方法，尽管我们的倾向将是累积方法，最终使我们能够从基本数据结构的组合性质角度考虑算法分析。

## 1.5 示例：快速排序的分析。

经典的[快速排序算法](http://algs4.cs.princeton.edu/23quicksort/)是由 C.A.R. Hoare 于 1962 年发明的：

```java
public class Quick
{
   private static int partition(Comparable[] a, int lo, int hi)
   {
      int i = lo, j = hi+1;
      while (true)
      {
         while (less(a[++i], a[lo])) if (i == hi) break;
         while (less(a[lo], a[--j])) if (j == lo) break;
         if (i >= j) break;
         exch(a, i, j);
      }
      exch(a, lo, j);
      return j;
   }

   private static void sort(Comparable[] a, int lo, int hi)
   {
      if (hi <= lo) return;
      int j = partition(a, lo, hi);
      sort(a, lo, j-1);
      sort(a, j+1, hi);
   }
} 

```

要分析这个算法，我们首先定义一个*成本模型*（运行时间）和一个*输入模型*（随机排序的不同元素）。为了将分析与实现分开，我们定义$C_N$为对$N$个元素进行排序所需的*比较次数*，并分析$C_N$（假设任何实现的运行时间都将是$\sim aC_N$，其中$a$是依赖于实现的常数）。注意算法的以下特性：

+   用于分区的比较次数为$N+1$。

+   分区元素是第$k$小的概率是$1/N$，其中$k$介于$0$和$N-1$之间。

+   在这种情况下，要排序的两个子数组的大小分别为$k$和$N-k-1$。

+   分区后两个子数组是随机排序的。

这些暗示了一个数学表达式（一个*递归关系*），直接源自递归程序$$C_N = N+1 + \sum_{0\le k \le N-1}{1\over N}(C_k + C_{N-k-1})$$。这个方程可以通过一系列简单但神秘的代数步骤轻松解决。首先，应用对称性，乘以$N$，减去$N-1$的相同方程，并重新排列项以获得一个更简单的递归。$$\eqalign{ C_N &= N+1 + {2\over N}\sum_{0\le k \le N-1}C_k\\ NC_N &= N(N+1) + 2\sum_{0\le k \le N-1}C_k\\ NC_N - (N-1)C_{N-1} &= N(N+1) -(N-1)N + 2C_{N-1}\\ NC_N &= (N+1)C_{N-1} +2N\\ }$$ 注意，这个更简单的递归给出了一个计算确切答案的高效算法。要解决它，将两边除以$N(N+1)$并进行折叠。$$\eqalign{ NC_N &= (N+1)C_{N-1} + 2N {\quad\rm for\quad} N > 1 {\quad\rm with\quad} C_1 = 2\\ {C_N\over N+1} &= {C_{N-1}\over N} + {2\over N+1}\\ &= {C_{N-2}\over N-1} + {2\over N} + {2\over N+1}\\ &= 2H_{N+1} - 2\\ C_N &= 2(N+1)H_{N+1} - 2(N+1) = 2(N+1)H_N - 2N. }$$ 结果是一个关于调和数的精确表达式。

## 1.6 渐近近似

调和数可以通过积分（见第三章）近似为$$H_N \sim \ln N$$，从而得到简单的渐近近似$$C_N \sim 2N\ln N$$。验证我们的数学模型总是一个好主意。这段代码

```java
public class QuickCheck
{
   public static void main(String[] args)
   {
      int maxN = Integer.parseInt(args[0]);
      double[] c = new double[maxN+1];
      c[0] = 0;
      for (int N = 1; N <= maxN; N++)
         c[N] = (N+1)*c[N-1]/N + 2;

      for (int N = 10; N <= maxN; N *= 10)
      {
         double approx = 2*N*Math.log(N) - 2*N;
         StdOut.printf("%10d %15.2f %15.2f\n", N, c[N], approx);
      }
   }
}

```

产生这个输出。

```java
% java QuickCheck 1000000
        10           44.44           26.05
       100          847.85          721.03
      1000        12985.91        11815.51
     10000       175771.70       164206.81
    100000      2218053.41      2102585.09

```

表中的差异是由于我们去掉了$2N$项（以及我们没有使用更准确的积分近似）所解释的。

## 1.7 分布。

可以使用类似的方法找到标准差和其他时刻。快速排序使用的比较次数的标准差为$\sqrt{7 - 2\pi²/3}N \approx .6482776 N$，这意味着比较的预期次数与大$N$时的平均值不太可能相差太远。比较次数是否服从正态分布？不。表征这种分布是一个困难的研究挑战。

## 1.8 概率算法。

我们的假设是输入数组是随机排序的一个有效的输入模型吗？是的，因为我们可以在排序之前随机排序数组。这样做将快速排序转变为一个*随机算法*，其良好性能由概率法则保证。

验证我们的模型和分析总是一个好主意。在过去几十年里，许多人在许多计算机上进行了详细的实验，验证了快速排序的性能。

在某些应用程序中，对于数组项不需要是不同的这一模型的一个缺陷是。对于这种情况，可以使用三向分区实现更快的实现。

#### 选定的练习

## 1.14

按照上述步骤解决递归$$A_N=1+{2 \over N} \sum_{1\le j\le N} A_{j-1} {\quad\rm for\quad} N>0$$，其中$A_0=0$。这是快速排序在`hi≥lo`时被调用的次数。

## 1.15

显示在指针交叉之前第一个分区阶段使用的平均交换次数为$(N-2)/6$。 （因此，通过递归的线性性质，快速排序使用的平均交换次数为${1\over6}C_N-{1\over2}A_N$。）

## 1.16

当使用快速排序对大小为$N$的随机数组进行排序时，平均会遇到多少大小为$k>0$的子数组？

## 1.17

如果我们将上面快速排序实现中的第一行更改为当`hi-lo <= M`时调用插入排序，那么对于排序$N$个元素的总比较次数由递归描述为$$ C_N=\begin{cases}N+1+\displaystyle{1\over N} \sum_{1\le j\le N} (C_{j-1}+C_{N-j})&N>M;\\ {1\over4}N(N-1)&N\le M\\ \end{cases}$$ 解决这个递归。

## 1.18

忽略上一个练习的答案中的小项（明显小于$N$的项），找到一个函数$f(M)$，使得比较次数大约为$$2N\ln N+f(M)N.$$ 绘制函数$f(M)$的图形，并找到最小化函数的$M$的值。

#### 复习问题

## Q1.1

给定递归$F_N=t_N+{2 \over N} \sum_{1\le j\le N} F_{j-1} {\ \rm for\ } N>0$，其中$F_0=0$，对于以下选择的“通行费函数”$t_N$，给出$F_N$的增长顺序（常数、线性、线性对数、二次或三次）：(*a*) 0 (*b*) 1 (*c*) $N$ (*d*) $2N+1$ (*e*) $N²$

## Q1.2

在一个特定的（虚构的）云计算排序应用中，大小小于 100 万的文件的排序成本可以忽略不计。否则，比较成本是这样的，预算只能覆盖$10^{12}$次比较。在以下选项中，使用标准快速排序算法，对于大小小于 100 万的文件，可以在预算内排序的最大随机顺序键文件是哪一个：$10⁹$, $10^{10}$, $10^{11}$, $10^{12}$, $10^{13}$, 或 $10^{14}$？

## Q1.3

让$B_{Nk}$表示使用快速排序对$N$个不同元素的随机排序文件进行排序时遇到的大小不超过$k$的平均子文件数，其中对于$0\le N\le k$，$B_{Nk}=N$。对于$N>k$，$B_{Nk}$的值是多少？
