# 2.2 模块和客户端

> 原文：[`introcs.cs.princeton.edu/python/22module`](https://introcs.cs.princeton.edu/python/22module)

到目前为止，你编写的每个程序都包含在一个单独的 .py 文件中的 Python 代码。对于大型程序来说，将所有代码放在一个文件中是受限制且不必要的。幸运的是，在 Python 中很容易调用另一个文件中定义的函数。这种能力有两个重要的后果：

+   它实现了代码重用。一个程序可以使用已经编写和调试过的代码，而不是复制代码，只需调用它。通过这样做，你实际上可以扩展 Python —— 你可以定义并使用自己的一组数据操作。

+   它实现了模块化编程。你不仅可以将程序分成函数，就像在第 2.1 节中描述的那样，还可以将它们保存在不同的文件中，根据应用程序的需求进行分组。模块化编程很重要，因为它允许我们独立地逐步组合和调试大型程序的部分，将每个完成的部分留在自己的文件中以供以后使用，而无需再担心其细节。

* * *

## 在其他程序中使用函数

要引用另一个 Python 程序中定义的函数，我们使用与调用`std*`模块和 Python 的`math`和`random`模块中的函数相同的机制。在本节中，我们描述这种基本的 Python 语言机制。为此，我们区分两种类型的 Python 程序：

+   一个*模块*包含其他程序可用的函数。

+   一个*客户端*是使用模块中函数的程序。

创建和使用模块需要执行五个（简单）步骤。我们用模块 gaussian.py 和客户端 gaussiantable.py 来说明完整的过程，其中模块是计算高斯分布函数的模块化版本，而客户端使用该模块来计算并写入值表。这是五个步骤：

1.  *在客户端中：导入模块。* 客户端 gaussiantable.py 包含语句`import gaussian`；现在它可以调用在模块 gaussian.py 中定义的任何函数。

1.  *在客户端中：限定对模块的函数调用。* 客户端 gaussiantable.py 使用函数调用`gaussian.cdf(score, mu, sigma)`来调用在模块 gaussian.py ��定义的`cdf()`函数。

1.  *在模块中：编写一个测试客户端。* 模块 gaussian.py 包含一个`main()`函数，接受三个命令行参数，调用模块中的函数，并将结果写入标准输出。

1.  *在模块中：消除任意全局代码。* 我们不能在 gaussian.py 中留下任意全局代码，因为 Python 每次导入模块时都会执行它。相反，我们将测试代码放在一个`main()`函数中，就像刚才描述的那样。现在，我们可以安排 Python 在我们从命令行执行`gaussian.py`时调用`main()`（仅在那时），使用以下咒语：

```
if __name__ == '__main__': main()

```

1.  *使模块对客户端可访问。* Python 需要能够在处理`import gaussian`语句时找到文件 gaussian.py。你继续进行的最简单方法是将 gaussian.py 和 gaussiantable.py 放在一起。本节末尾的问答描述了另一种方法。

总之，模块 gaussian.py 中的函数可通过`import gaussian`语句供任何其他程序使用。相反，客户端 gaussiantable.py 包含任意全局代码，不打算供其他程序使用。我们使用术语*脚本*来指代这样的代码。

这张图总结了 gaussiantable.py 客户端、gaussian.py 模块和标准`math`模块之间的控制流。

> ![](img/bfb9c7ad81dd68ca2f4e06d4e93c827d.png) <alt of="" control="" in="" a="" modular="" program=""></alt>

### 模块化编程。

通过定义多个文件，每个文件都是一个独立的模块，具有多个函数，编程的潜在影响是我们编程风格的另一个深刻变化。通常，我们将这种方法称为*模块化编程*。模块化编程的关键好处在于鼓励我们将计算分解为可以单独调试和测试的较小部分。通常情况下，你应该通过确定一个合理的方式将计算分解为可管理大小的独立部分，并实现每个部分，就好像有人以后会想要使用它一样。

* * *

## 模块化编程抽象

接下来，我们描述作为模块化编程基础的抽象。

![模块化编程抽象](img/1fa629df7e528ce82a666fa32670f053.png)

### 实现。

我们使用通用术语*实现*来描述实现一组旨在重复使用的函数的代码。Python 模块就是一个实现：我们用一个名为 module 的名称来集体引用一组函数，并将它们保存在一个名为 module.py 的文件中。模块设计的指导原则是向客户提供他们需要的函数，而不是其他函数。

### 客户端。

我们使用通用术语*客户端*来指代使用实现的程序。我们说调用一个在名为`*module*.py`的文件中定义的函数的 Python 程序（脚本或模块）是`*module*`的客户端。

### 应用程序编程接口（API）。

程序员通常以客户端和实现之间的合同来思考，这是对实现要做什么的明确规范。你已经能够组成作为`math`和`random`等标准 Python 模块的客户端的程序，因为有一个非正式的合同（对它们应该做什么的���语描述）以及可供使用的函数的签名的精确规范。总体而言，这些信息被称为*应用程序编程接口（API）*。对于用户定义的模块，相同的机制是有效的。API 允许任何客户端使用模块，而无需检查定义模块的代码。当我们组成一个新模块时，我们总是提供一个 API。例如，这是我们的 gaussian.py 模块的 API：

> ![高斯 API](img/cc4ab3763e405e2d547a9a4445c7e4c2.png)

API 应包含多少信息？在这个书站中，我们坚持一个与我们的设计原则相一致的原则：向客户程序员提供他们需要的信息，而不是更多。

### 私有函数。

有时，我们希望在一个模块中定义一个不打算由客户端直接调用的辅助函数。我们将这样的函数称为*私有函数*。按照惯例，Python 程序员在私有函数名称的第一个字符中使用下划线。例如，以下是从 gaussian.py 中调用私有函数 _phi()的 pdf()函数的另一种实现：

```
def _phi(x):
    return math.exp(-x*x/2.0) / math.sqrt(2*math.pi)

def pdf(x, mu=0.0, sigma=1.0):
    return _phi(float((x - mu) / sigma)) / sigma

```

我们不在 API 中包含私有函数，因为它们不是客户端和实现之间的合同的一部分。实际上，函数名称中的下划线信号告诉客户不要显式调用该函数。（遗憾的是，Python 没有强制执行这种约定的机制。）

### 库。

*库*是一组相关的模块。例如，Python 有一个标准库（其中包括模块 `random` 和 `math`）和许多扩展库（如用于科学计算的 `NumPy` 和用于图形和声音的 `Pygame`）。此外，对于这本书，我们提供了一个书站库（其中包括模块 `stdio` 和 `stddraw`）。

### 文档。

所有标准、扩展和书站模块的 API 都可以通过交互式 Python 中内置的 `help()` 函数获得。如下所示，你只需要输入 `python`（进入交互式 Python），然后输入语句 `import module`（加载模块），然后输入 `help(module)` 来查看模块的 API。标准和扩展 Python 模块的 API 也可以通过[在线 Python 文档](https://docs.python.org/3/)以另一种形式获得。

> ![访问 Python 文档](img/2297c8656ca799ae917cab9e0221d28c.png)

接下来，我们介绍我们的 `stdrandom` 模块（用于生成随机数）、`stdarray` 模块（用于一维和二维数组）和 `stdstats` 模块（用于统计计算）的 API。我们还描述了这些模块的一些有趣的客户端。

* * *

## 随机数

`stdrandom.py` 模块用于从各种分布生成随机数。

> ![Stdrandom API](img/4c3208a64b0fcf1fc1e0213fa9e8b3b4.png)

### API 设计。

我们对传递给 `stdrandom` 中每个函数的对象做出了一些假设���例如，我们假设客户端将一个介于 0.0 和 1.0 之间的浮点数传递给 `stdrandom.bernoulli()`，并且将一个非负数数组（其中不是所有元素都为零）传递给 `stdrandom.discrete()`。这些假设是客户端和实现之间的合同的一部分。

### 单元测试。

我们实现 `stdrandom` 时没有参考任何特定的客户端，但将一个基本的测试客户端 `main()` 包含其中是良好的编程实践，至少要

+   测试所有代码。

+   提供了一些保证代码正常工作的保证。

+   从命令行接受参数以允许灵活测试。

尽管它不是为客户端设计的，但在调试、测试和改进模块中的函数时，我们使用 `main()`。这种实践被称为*单元测试*。适当的单元测试本身可能是一个重要的编程挑战。在这种特殊情况下，适合在一个单独的客户端中进行更广泛的测试，以检查这些数字是否具有与从引用分布中真正随机抽取的数字相同的属性。

### 压力测试。

一个被广泛使用的模块，比如 `stdrandom`，也应该经受压力测试，确保即使客户端不遵循合同或做出一些未明确涵盖的假设时，它也不会出现意外失败。如果一些数组元素为负数，`stdrandom.discrete()` 应该怎么办？如果参数是长度为 0 的数组呢？如果第二个参数小于（或等于）第一个参数，`stdrandom.uniform()` 应该怎么办？这些情况有时被称为*边界情况*。

* * *

## 数组处理 API

在第 1.4 节中，我们看到了创建指定长度的一维数组和指定行列数的二维数组的函数的实用性。因此，我们引入了书站库中的 `stdarray` 模块，特别是它的用于创建和初始化数组的函数 `stdarray.create1D()` 和 `stdarray.create2D()`。

此外，我们已经看到并将继续看到许多例子，我们希望从标准输入中读取值到数组中，并将值从数组写入标准输出。因此，我们在 `stdarray` 模块中包含了从标准输入读取整数、浮点数和布尔数组并将它们写入标准输出的函数，从而补充了 `stdio` 模块。这是 `stdarray` 的完整 API：

> ![Stdarray API](img/2cc2d66e674cfef0900458c157bd23f2.png)

我们采用的约定是标准输入中出现的数组包括维度，并按照指示的顺序出现，如下图所示。`read*()`函数期望这种格式，而`write*()`函数以这种格式生成输出。

> ![数组的文件格式](img/ec8517423641aba7d140a97c37549d25.png)

对于布尔数组，我们的文件格式使用`0`和`1`值，而不是`False`和`True`。这种约定对于大数组来说更加经济。更重要的是，使用这种文件格式更容易发现数据中的模式。

* * *

## 迭代函数系统

[迭代函数系统](http://www.cut-the-knot.org/ctk/ifs.shtml)（IFS）是产生分形图像如谢尔宾斯基三角形和巴恩斯利蕨的一般方法。作为第一个例子，考虑以下简单过程：从等边三角形的一个顶点开始绘制一个点。然后随机选择三个顶点中的一个，并在刚刚绘制的点和该顶点之间的中点绘制一个新点。继续执行相同的操作。

> ![一个随机过程](img/c388dafdf422670b2fea8e7d0efa15b1.png)

程序 sierpinski.py 模拟了这个过程。以下是 1000、10000 和 100000 步后的快照。您可能会认出这个图形是[谢尔宾斯基三角形](http://mathworld.wolfram.com/SierpinskiSieve.html)。

> ![一个随机过程？](img/90c71f02780233666de958cbdd7c93f6.png)

程序 ifs.py 是一个数据驱动版本的程序，模拟了这个过程的一般化。详情请参阅教科书。您可以在以下任何输入文件上运行它：barnsley.txt, binary.txt, coral.txt, culcita.txt, cyclososus.txt, dragon.txt, fishbone.txt, floor.txt, koch.txt, sierpinski.txt, spiral.txt, swirl.txt, tree.txt, 或 zigzag.txt。

> ![迭代函数系统示例](img/8e79629e66ef4d4aa1c7ed709f6ee2e8.png)

能够如此轻松地产生如此逼真的图表，引发了有趣的科学问题：计算告诉我们关于自然的什么？自然告诉我们关于计算的什么？

* * *

## 标准统计

`stdstats.py`模块用于统计计算和基本可视化，如下所示的 API。详情请参阅教科书。

> ![stdstats API](img/041a279d5fa1d406ff055b042e775d22.png)

### 伯努利试验。

程序 bernoulli.py 是一个`stdstats.py`客户端示例。它计算在抛掷公平硬币*n*次时找到的正面数，并将结果与预测的高斯分布函数进行比较。根据[中心极限定理](http://mathworld.wolfram.com/CentralLimitTheorem.html)，结果直方图极好���近似于均值为*n*/2 和方差为*n*/4 的高斯分布。这是命令`python bernoulli.py 20 100000`的输出：

> ![stdstats API](img/7f47da26a86081c76846792863a71fc1.png)

* * *

## 模块化编程的好处

我们开发的模块实现展示了模块化编程。我们不是将一个新程序组合成一个自包含的文件来解决新问题，而是将每个任务分解为更小、更易管理的子任务，然后实现和独立调试解决每个子任务的代码。ifs.py 和 bernoulli.py 程序展示了模块化编程，因为它们是相对复杂的计算，使用了几个相对较小的模块。 

> ![本节中客户端和模块的依赖图](img/24f881ba56010092d746348c476cd121.png)

我们在整个书站强调模块化编程，因为它有许多重要的好处，包括以下内容：

+   *合理规模的程序。* 没有一个大任务是如此复杂，以至于不能分解为更小的子任务。

+   *调试。* 通过模块化编程和我们的指导原则，尽可能将变量的作用域局限在本地，我们严格限制了在调试时需要考虑的可能性数量。同样重要的是客户端和实现之间的契约概念。一旦我们确信实现满足了约定的要求，我们就可以在这个假设下调试所有的客户端。

+   *代码重用。* 一旦我们实现了诸如 StdStats 和 StdRandom 之类的库，我们就不必担心再次编写代码来计算平均值或标准差或生成随机数 —— 我们可以简单地重用我们编写的代码。

+   *维护。* 像一篇好的文章一样，一个好的程序总是可以改进的。假设在开发新客户端时，您发现某个模块中有一个错误。通过模块化编程，修复该错误相当于修复所有模块的客户端中的错误。

* * *

#### 问答

**Q.** 我如何使一个书站模块（如`stdio`或`stdrandom`）可供我的 Python 程序使用？

**A.** 如果您按照书站上的逐步说明安装 Python，那么我们所有的标准模块（包括`stdio`、`stddraw`、`stdarray`、`stdrandom`和`stdstats`）应该已经可以在您的 Python 程序中使用。

**Q.** 我如何使非标准和非书站模块（如`gaussian`）可供我的 Python 程序使用？

**A.** 让我们具体一点。假设您编写了一个名为`myprogram.py`的程序，并且`myprogram.py`导入了`gaussian`。问题是如何使`gaussian`模块对`myprogram.py`可用。换句话说，问题是在执行`myprogram.py`时如何告诉 Python 在哪里找到`gaussian.py`文件。

最简单的方法是将`gaussian.py`放在与`myprogram.py`相同的目录中。然而，使用这种方法，您可能会在每个包含`gaussian.py`客户端的目录中得到多个副本的`gaussian.py` —— 每个目录中都有一个副本。这种方法会使`gaussian.py`代码难以维护。

另一种方法是将`gaussian.py`的一个副本放在某个目录中，然后*设置`PYTHONPATH`环境变量*以包含该目录。随后，每当 Python 遇到`import`语句时，它会在该目录中查找文件。

设置`PYTHONPATH`环境变量的机制取决于您使用的操作系统。假设您的计算机正在运行 Mac OS X 或 Linux。进一步假设您将`gaussian.py`放在目录`/Users/yourusername/common`中。然后这些命令是适当的：

```
export PYTHONPATH=/Users/yourusername/common
python myprogram.py

```

`export`命令将`PYTHONPATH`变量的值设置为`/Users/yourusername/common`。因此，在执行后续的`python myprogram.py`命令时，Python 在处理`import`语句时会查找`/Users/yourusername/common`目录，从而找到`gaussian.py`文件。

一般来说，在 Mac OS X 和 Linux 系统上，`PYTHONPATH`变量的值是由冒号分隔的一系列目录。因此，在您发出这个命令之后：

```
export PYTHONPATH=*directory1*:*directory2*:*directory3* 

```

当处理`import`语句时，Python 会先查找`*directory1*`，然后查找`*directory2*`，最后查找`*directory3*`中的`.py`文件。

另一方面，假设您的计算机正在运行 Microsoft Windows。进一步假设您将`gaussian.py`放在目录`c:\Users\yourusername\common`中。然后这些命令是适当的：

```
set PYTHONPATH=c:\Users\yourusername\common
python myprogram.py

```

`set`命令将`PYTHONPATH`变量的值设置为`c:\Users\yourusername\common`。因此，在执行后续的`python myprogram.py`命令时，Python 在处理`import`语句时会查找`c:\Users\yourusername\common`目录，从而找到`gaussian.py`文件。

一般来说，在 Microsoft Windows 系统上，`PYTHONPATH` 变量的值是由分号分隔的一系列目录。因此，在发出这个命令后：

```
set PYTHONPATH=*directory1*;*directory2*;*directory3*

```

处理 `import` 语句时，Python 会先查找 `*directory1*`，然后是 `*directory2*`，最后是 `*directory3*` 中的 `.py` 文件。

**Q.** 我尝试导入 `gaussian` 模块，但收到以下错误消息。出了什么问题？

```
ImportError: No module named gaussian

```

**A.** 你没有像上面描述的那��让 `gaussian` 对 Python 可用。

**Q.** 我尝试调用 `gaussian.pdf()`，但收到以下错误。出了什么问题？

```
NameError: name 'gaussian' is not defined

```

**A.** 你忘记了 `import gaussian` 语句。

**Q.** 有一个关键字可以识别 `.py` 文件是一个模块（而不是脚本）吗？

**A.** 不。从技术上讲，关键是避免使用前面描述的模式中的任意全局代码。如果你避免在一个 `.py` 文件中使用任意全局代码，以便该 `.py` 文件可以被导入到其他 `.py` 文件中，那么我们称之为一个模块。然而，从实用的角度来看，这种观点有一定的概念性飞跃，因为创建一个 `.py` 文件来运行（也许以后会用不同的数据再次运行），和创建一个 `.py` 文件以后在未来依赖它，以及为将来的其他人创建一个 `.py` 文件是完全不同的事情。

**Q.** 我如何开发一个我已经使用了一段时间的模块的新版本？

**A.** 谨慎处理。对 API 的任何更改都可能破坏任何客户端程序，所以最好在一个单独的目录中工作。当然，使用这种方法时，你是在使用代码的副本。如果你要对一个有很多客户端的模块进行更改，你就能体会到公司发布软件新版本时面临的问题。如果你只想向一个模块添加一些函数，那就继续：通常不太危险。

**Q.** 我怎么知道一个实现是否行为正常？为什么不自动检查它是否符合 API？

**A.** 我们使用非正式规范，因为撰写详细规范与撰写程序没有太大区别。此外，理论计算机科学的一个基本原则是，这样做甚至不能解决基本问题，因为通常没有办法检查两个不同的程序是否执行相同的计算。

**Q.** 我注意到当我运行本节中的程序时，出现了文件名后缀为 `.pyc` 的文件。例如，当我发出命令 `python gaussiantable.py` 时，我注意到 Python 自动创建了一个名为 `gaussian.pyc` 的文件。这些 `.pyc` 文件是什么？

**A.** 如第 1.1 节所述，每当 Python 执行一个程序时，它会将程序转换为一种更适合执行的内部（不可读）形式，称为*字节码*。当你第一次导入一个模块时，Python 会编译代码并将生成的字节码存储在一个 `.pyc` 文件中。这使得模块加载更快，因为 Python 不需要每次重新编译它（但这并不会使程序运行更快）。

当一个程序只包含一个文件时，Python 在执行完成后会丢弃文件的字节码。然而，当一个程序由多个文件组成，也就是说，当一个程序由一个客户端文件和模块组成时，Python 不会丢弃为模块生成的字节码。相反，它会将该字节码存储在 `.pyc` 文件中。

例如，回想一下 gaussiantable.py 依赖于 gaussian.py。所以当你发出命令 `python gaussiantable.py 1019 209` 时，Python 将 gaussiantable.py 转换为字节码。它也将 gaussian.py 转换为字节码。最终它会丢弃前者；但它会保存后者在名为 `gaussian.pyc` 的文件中。

Python 的理念是：由于 gaussian.py 在这个程序中被用作模块，很可能将来会在其他程序中作为模块使用。因此，Python 将 gaussian.py 的字节码版本保存在`gaussian.pyc`中，以避免在模块确实被重用时的翻译开销。

随时删除`.pyc`文件都是可以的；Python 会在适当时重新生成它们。如果你编辑了一个`.py`文件，Python 生成了相应的`.pyc`文件，那么不删除`.pyc`文件也是可以的，因为 Python 会自动重新生成`.pyc`文件。

* * *

#### 练习

1.  编写一个基于定义 sinh(*x*) = (*e*^(*x*) - *e*^(-*x*))/2 和 cosh(*x*) = (*e*^(*x*) + *e*^(-*x*))/2 的双曲三角函数的模块，其中 tanh(*x*), coth(*x*), sech(*x*), 和 csch(*x*)的定义方式类似于标准三角函数。

1.  为`stdstats`和`stdrandom`编写一个测试客户端，检查这两个模块中的所有方法是否按预期运行。使用命令行参数`n`，使用每个`stdrandom`函数生成`n`个随机数，并写出它们的统计数据。*额外加分*：通过与数学分析预期的结果进行比较来证明你得到的结果。

1.  开发一个为`stdrandom`进行压力测试的客户端。特别关注`discrete()`。例如，概率是否为非负？是否全部为零？

1.  编写一个函数，接受浮点数`ymin`和`ymax`（其中`ymin`严格小于`ymax`）以及一个`float`数组`a[]`作为参数，并线性缩放`a[]`中的元素，使它们都在`ymin`和`ymax`之间。

1.  编写一个 gaussian.py 和`stdstats.py`客户端，探索改变均值和标准差对高斯分布曲线的影响。创建一个曲线固定均值和各种标准差的图，另一个曲线固定标准差和各种均值的图。

1.  在`stdrandom.py`中添加一个函数`maxwellBoltzmann()`，返回从参数σ的*Maxwell-Boltzmann 分布*中抽取的随机值。为了产生这样的值，返回三个均值为 0，标准差为σ的高斯随机变量的平方和的平方根。（理想气体中分子的速度具有 Maxwell-Boltzmann 分布。）

1.  修改 bernoulli.py，为条形图添加动画效果，在每次实验后重新绘制，以便观察其收敛到正态分布。

1.  修改 bernoulli.py，添加一个命令行参数*p*，指定有偏硬币出现正面的概率。运行实验，以了解与有偏硬币对应的分布。一定要尝试接近 0 和接��1 的*p*值。

1.  编写一个模块`matrix.py`，为向量和矩阵实现以下 API（参见第 1.4 节）：

    > ![矩阵 API](img/db6060f1a8a89b0359bdd07f42523bdf.png)

    *解决方案*：参见 matrix.py。

1.  编写一个`matrix.py`的客户端（来自上一个练习），使用以下代码：

    ```
    moves = int(sys.argv[1])
    p = stdarray.readFloat2D()
    ranks = stdarray.create1D(len(p), 0.0)
    ranks[0] = 1.0
    for i in range(moves):
        ranks = matrix.multiplyVM(ranks, p)
    stdarray.write1D(ranks)

    ```

    该代码执行与 markov.py（来自第 1.6 节）相同的计算。

    在实践中，数学家和科学家使用成熟的库，如`NumPy`（或专用矩阵处理语言如`Matlab`）来执行这些任务，因为它们可能比你自己编写的任何东西更有效、准确和稳健。NumPy 附录描述了如何使用`NumPy`。

1.  编写一个`matrix.py`的客户端（来自前两个练习），命名为`markovsquaring.py`，实现了基于矩阵平方而不是迭代向量-矩阵乘法的版本的 markov.py（来自第 1.6 节）。

1.  重新设计随机冲浪者.py（来自第 1.6 节）使用`stdarray`和`stdrandom`模块。

    *部分解决方案：*

    ```
    ...
    p = stdarray.readFloat2D()
    page = 0   # Start at page 0.
    hits = stdarray.create1D(n, 0)
    for i in range(moves):
        page = stdrandom.discrete(p[page])
        hits[page] += 1
    ...

    ```

1.  向`stdrandom.py`添加一个函数`exp()`，它接受一个参数λ，并返回一个从速率为λ的*指数分布*中随机数。*提示*：如果*x*是均匀分布在 0 和 1 之间的随机数，则-ln *x* / λ是从速率为λ的指数分布中的随机数。

* * *

#### 创意练习

1.  **Sicherman 骰子。** 假设你有两个六面骰子，一个面标有 1、3、4、5、6 和 8，另一个面标有 1、2、2、3、3 和 4。比较这两个骰子的和的每个值发生的概率与标准骰子的概率。使用`stdrandom`和`stdstats`。

    *解决方案*：具有这些属性的骰子称为[Sicherman 骰子](https://en.wikipedia.org/wiki/Sicherman_dice)：它们产生与常规骰子相同频率的和（2 的概率为 1/36，3 的概率为 2/36，依此类推）。

1.  **Craps.** 这里是*craps*游戏中*pass bet*的规则：掷两个 6 面骰子，让*x*为它们的和。

    +   如果*x*为 7 或 11，则获胜。

    +   如果*x*为 2、3 或 12，则失败。

    否则，重复掷两个骰子，直到它们的和为*x*或 7。

    +   如果它们的和为*x*，则获胜。

    +   如果它们的和为 7，则失败。

    编写一个模块化程序来估计获胜*pass bet*的概率。修改你的程序以处理有偏骰子，其中骰子落在 1 上的概率来自命令行，落在 6 上的概率为 1/6 减去该概率，2-5 被假定为等概率。*提示*：使用`stdrandom.discrete()`。

1.  **动态直方图。** 假设标准输入流是一系列浮点数。编写一个程序，从命令行获取一个整数`n`和两个浮点数`l`和`r`，并使用`stdstats`绘制一个直方图，显示标准输入流中落入将`(l, r)`分成`n`个等大小区间的每个区间中数字的计数。使用你的程序为你之前在本节中的练习 2 的解决方案添加代码，以绘制每个函数产生的数字分布的直方图，从命令行获取`n`。

1.  **Tukey 图。** *Tukey 图*是一种概括直方图的数据可视化，适用于当给定范围内的每个整数与一组`y`值相关联时。对于范围内的每个整数*i*，我们计算所有相关*y*值的均值、标准差、第 10 百分位数和第 90 百分位数；画一条从第 10 百分位数*y*值到第 90 百分位数*y*值的垂直线；然后画一个细长矩形，以均值下方一个标准差到均值上方一个标准差为中心。假设标准输入流是一��列数对，其中每对中的第一个数是一个整数，第二个数是一个双精度值。编写一个`stdstats`和`stddraw`客户端，从命令行获取一个整数`n`，假设标准输入流中的所有整数都在 0 到`n-1`之间，使用`stddraw`绘制数据的 Tukey 图。

1.  **IFS.** 尝试使用各种输入来实验 ifs.py 以创建自己设计的图案，如谢尔宾斯基三角形、巴恩斯利蕨或其他示例。你可以从对给定输入进行微小修改开始实验。

1.  **IFS 矩阵实现。** 编写一个使用`matrix.multiply()`（如本节中的一个先前练习中开发的）而不是计算`x`和`y`的新值的方程的 ifs.py 版本。

1.  **压力测试。** 编写一个客户端对`stdstats.py`进行压力测试。与同学合作，一人编写代码，另一人测试。

1.  **赌徒困境。** 编写一个`stdrandom.py`客户端来研究赌徒困境问题（参见第 1.3 节中的 gambler.py 和该节末尾的练习）。*注意*：为实验定义一个函数比 bernoulli.py 更困难，因为函数不能返回两个值。但请记住，函数可以返回一个包含两个值的单个数组。

1.  **整数属性模块。** 基于本书中考虑的用于计算整数属性的函数，编写一个模块。包括确定给定整数是否为质数的函数；两个整数是否互质；计算给定整数的所有因子；两个整数的最大公约数和最小公倍数；欧拉函数（参见第 2.1 节中的*欧拉函数*练习）；以及你认为可能有用的其他函数。创建一个 API，一个执行压力测试的客户端，以及解决本书前面几个练习的客户端。

1.  **投票机。** 编写一个`stdrandom.py`客户端（具有适当的函数），研究以下问题：假设在一个拥有 1 亿选民的人口中，51%的选民投票给候选人 A，49%的选民投票给候选人 B。然而，投票机容易出错，有 5%的概率给出错误答案。假设错误是独立且随机发生的，5%的错误率足以使紧密选举的结果无效吗？可以容忍多少错误率？

1.  **扑克分析。** 编写一个`stdrandom.py`和`stdstats.py`客户端（具有适当的函数），通过模拟估计在五张扑克牌手中获得一对、两对、三条、满堂和同花的概率。将程序分解为适当的函数，并捍卫你的设计决策。*额外加分*：将顺子和同花顺添加到可能性列表中。

1.  **音乐模块。** 开发一个基于 playthattunedeluxe.py 中的函数的模块（来自第 2.1 节），你可以用来编写客户端程序来创建和操作歌曲。

1.  **动画绘图。** 编写一个程序，接受一个命令行参数`m`，并在标准输入上生成最近`m`个浮点数的条形图。使用我们在第 1.5 节中用于`bouncingball.py`的相同动画技术：擦除、重绘、显示，并稍作等待。每次程序读取一个新数字时，应重新绘制整个图形。由于大部分图像在稍微向左重新绘制时不会改变，因此你的程序将产生一个固定大小窗口动态滑过输入值的效果。使用你的程序绘制一个庞大的时变数据文件，如股票价格。

1.  **数组绘图模块。** 开发自己的绘图函数，改进`stdstats.py`中的函数。要有创意！尝试创建一个你认为将来会用到的绘图模块。
