# 8.3 操作系统

> 原文：[`introcs.cs.princeton.edu/java/83os`](https://introcs.cs.princeton.edu/java/83os)

本节正在进行重大改造。

**内存管理。** 在许多语言中，包括 C 和 C ++，程序员负责管理内存消耗，并在不再使用时显式释放它。如果正确执行，"微管理"内存可能更有效，但这很繁琐且容易出错。自动内存收集在常见应用程序中几乎可以与之一样有效，并且需要更少的开发时间。

**垃圾收集。** 由约翰·麦卡锡于 1958 年作为 LISP 的一部分发明。思路 = 通过其他可达对象的引用确定哪些对象是可达的；释放不可达对象（垃圾）。这里有一些常见的[垃圾收集技术](http://www.osnews.com/story.php?news_id=6864)。

+   *引用计数.* 计算对每个对象的引用次数。当引用次数为零时，可以释放对象。缺点 - 不适用于循环链接结构，需要频繁更新计数字段。

+   *标记-清除算法.* 将所有对象标记为垃圾。扫描所有可达对象并标记为可达。扫描后，仍标记为垃圾的任何内容都可以被清除。缺点 - 活动内存变得分散，必须扫描内存中的每个对象。

+   *复制.* 进行标记-清除，但将所有非垃圾对象复制到连续的内存块中。消除碎片。缺点 - 持久对象来回复制，需要两倍的内存。

+   *标记整理.* 将对象复制到内存的同一部分。持久对象很少被复制。

+   *分代.* 根据对象活跃时间将对象划分为几个"代"。最初，对象被放置在"最年轻"的代中，随着持久性，它们移动到"更老"的代中。

默认情况下，[Java](http://developers.sun.com/techtopics/mobility/midp/articles/garbagecollection2/#2) 使用三代垃圾收集器。

#### 创意练习
