# 9.6 优化

> 原文：[`introcs.cs.princeton.edu/java/96optimization`](https://introcs.cs.princeton.edu/java/96optimization)

本节正在大规模施工中。

## 寻找根。

目标：给定函数 f(x)，找到 x*使得 f(x*) = 0。非线性方程可以有任意数量的解。

```
x2 + y2 = -1 no real solutions
e-x  =  17 one real solution
x2 -4x + 3 = 0  has two solutions (1, 3)
sin(x) = 0 has infinitely many solutions

```

**无约束优化。** 目标：给定函数 f(x)，找到 x*使得 f(x)被最大化或最小化。如果 f(x)可微，那么我们正在寻找一个 x*，使得 f'(x*) = 0。然而，这可能导致局部最小值、最大值或鞍点。

**二分法。** 目标：给定函数 f(x)，找到 x*使得 f(x*) = 0。假设你知道区间[a, b]，使得 f(a) < 0 且 f(b) > 0。

**牛顿法。** 二次逼近。如果距离答案足够接近，收敛速度快。下面的更新公式用于找到 f(x)和 f'(x)的根。

```
root finding:  xk+1 = xk - f'(xk)-1 f(xk)
optimization:  xk+1 = xk - f''(xk)-1 f'(xk)

```

只有在距离解“足够接近”时，牛顿法才可靠。坏例子（Smale）：f(x) = x³ - 2*x + 2。如果你从区间[-0.1, 0.1]开始，牛顿法会收敛到一个稳定的 2 周期。如果从负实根的左侧开始，它会收敛。

为了处理一维一般可微或两次可微函数，我们可以声明一个接口

```
public interface Function {
    public double eval(double x);
    public double deriv(double x);
}

```

程序 Newton.java 在可微函数上运行牛顿法，计算满足 f(x*) = 0 和 f'(x*) = 0 的点 x*。

在氢原子的 4s 激发态中找到电子的概率在半径 r 处给出：*f(x) = (1 - 3x/4 + x²/8 - x³/192)² e^(-x/2)*，其中*x*是以玻尔半径（0.529173E-8 厘米）为单位的半径。程序 BohrRadius.java 包含 f(x)，f'(x)和 f''(x)的公式。通过从 0、4、5、13 和 22 开始牛顿法，我们获得所有三个根和所有五个局部极小值和极大值。

**高维牛顿法。** [可能省略或留作练习] 用于解决非线性方程组。一般来说，解决非线性方程组没有好的方法

```
xk+1 = xk - J(xk)-1 f(xk)

```

其中 J 是偏导数的雅可比矩阵。在实践中，我们不会显式计算逆矩阵。我们不是计算 y = J^(-1)f，而是解线性方程组 Jy = f。

为了说明这种方法，假设我们想要找到两个非线性方程组的解(x, y)。

```
x3 - 3xy2 - 1 = 0
3x2y - y3 = 0

```

在这个例子中，雅可比矩阵如下

```
J  = [ 3x2 - 3y2     -6xy      ]
     [ 6x           3x2 - 3y2  ]

```

如果我们从点(-0.6, 0.6)开始牛顿法，我们很快就能获得一个根(-1/2, sqrt(3)/2)，达到机器精度。另外两个根是(-1/2, -sqrt(3)/2)和(1, 0)。程序 TestEquations.java 使用接口 Equations.java 和 EquationSolver.java 来解决方程组。我们使用 Jama 矩阵库进行矩阵计算。

*优化。* 使用相同的方法来优化多个变量的函数。如果多变量函数足够平滑，那么存在很好的方法。

```
xk+1 = xk - H(xk)-1 g(xk)

```

需要梯度 g(x) = ∇f(x)和黑塞矩阵 H(x) = ∇²f(x)。该方法找到一个 x*，使得 g(x*) = 0，但这可能是一个极大值、极小值或鞍点。如果黑塞矩阵是正定的（所有特征值都是正的），那么它是一个极小值；如果所有特征值都是负的，那么它是一个极大值；否则它是一个鞍点。

此外，二���导数变化缓慢，因此可能不需要在每一步重新计算黑塞矩阵（或其 LU 分解）。在实践中，精确计算黑塞矩阵是昂贵的，因此其他所谓的*拟牛顿*方法更受青睐，包括 Broyden-Fletcher-Goldfarb-Shanno（BFGS）更新规则。

**线性规划。** 创建矩阵接口。推广两人零和博弈，许多组合优化问题，... [从网上运行 AMPL](http://www.ampl.com/TRYAMPL/startup.html)。

编程 = 计划。给出一些历史。决策问题长期以来不被认为在 P 中。1979 年，Khachian 肯定地解决了这个问题，并以一种称为*椭球算法*的几何分治算法登上了《纽约时报》的头条新闻。它需要 O(N⁴L)位操作，其中 N 是变量的数量，L 是输入中的位数。尽管这是优化中的一个里程碑，但它并没有立即导致一个实用的算法。1984 年，Karmarkar 提出了一个需要 O(N^(3.5)L)时间的投影缩放算法。它为高效实现打开了大门，因为通常比其最坏情况保证表现要好得多。1990 年代提出了各种*内点*方法，最佳已知复杂度界限为 O(N³ L)。更重要的是，这些算法是实用的，并且与单纯形法相竞争。它们还可以扩展以处理更一般的问题。

**单纯形法。**

**线性规划求解器。** 1947 年，乔治·丹齐格提出了线性规划的单纯形算法。是有史以来最伟大和最成功的算法之一。[线性规划](http://opsresearch.com/OR-Objects/api/drasys/or/mp/lp/package-summary.html)，但不具备工业强度。程序 LPDemo.java 演示了如何使用它。类`MPSReader`和`MPSWriter`可以解析标准 MPS 格式的输入文件并写入输出文件。在[MPS 格式](http://www.netlib.org/lp/data/)中测试 LP 数据文件。

**更多应用。** OR-Objects 还包括图着色、旅行推销员问题、车辆路径规划、最短路径等。

#### 练习

1.  使用牛顿法找到一个 x（以弧度表示），使得 x = cos(x)。

1.  使用牛顿法找到一个 x（以弧度表示），使得 x² = 4 sin(x)。

1.  使用牛顿法找到一个 x（以弧度表示），使得 f(x) = sin(x) + x - exp(x)最小化。

1.  使用牛顿法找到解决方程的(x, y)

    ```
    x + y - xy  = -2
    x exp(-y) = 1

    ```

    从点(0.1, -0.2)开始，该点接近真实根(0.09777, -2.325)。

1.  使用牛顿法找到解决方程的(x, y)

    ```
    x + 2y = 2
    x2 + 4y2 = 4

    ```

    从点(1, 2)开始，该点接近真实根(0, 1)。

1.  使用牛顿法找到解决方程的(x, y)

    ```
    x + y  = 3
    x2 + y2 = 9

    ```

    从点(2, 7)开始。

1.  使用牛顿法最小化 f(x) = 1/2 - x e^(-x²)。*提示*：f'(x) = (2x²-1)e^(-x²)，f''(x) = 2x(3-2x²)e^(-x²)。

1.  使用牛顿法找到以下两个变量函数的所有最小值、最大值和鞍点。

    ```
    f(x,y) = 3(1-x)2 exp(-x2-(y+1)2) -  10((y/6)-y3) exp(-x2-y2)

    ```

#### 创意练习

1.  **伯努利数。** 伯努利数出现在正切函数的泰勒展开式、欧拉-麦克劳林求和公式和黎曼ζ函数中。它们可以通过 B[0] = 1 的递归定义，并利用从 j = 0 到 N 的二项式(N+1, j) B[j]之和为 0 的事实来定义。例如 B[1] = -1/2，B[2] = 1/6，B[3] = 0，B[12] = -691/2730。伯努利通过手工计算了前 10 个伯努利数；欧拉计算了前 30 个。1842 年，阿达·洛夫莱斯建议查尔斯·巴贝奇利用他的分析引擎设计一个计算伯努利数的算法。编写一个程序 Bernoulli.java，它接受一个命令行参数 N 并打印出前 N 个伯努利数。使用第 9.2 节中的 BigRational.java 数据类型。

1.  **偏心率异常。**（克利夫·莫勒）*偏心率异常*出现在开普勒的行星运动模型中，并满足 M = E - e sin E，其中 M 是平均偏近角（24.851090），e 是轨道离心率（0.1）。解出 E。

1.  **带复数的牛顿法。** 实现用于找到方程的*复数*根的牛顿法。使用 Complex.java 并完全实现牛顿法，就像找到实根一样，但使用复数。
