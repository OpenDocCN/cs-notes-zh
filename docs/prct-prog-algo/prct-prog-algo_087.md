# 1.4   算法分析

> 原文：[`algs4.cs.princeton.edu/14analysis`](https://algs4.cs.princeton.edu/14analysis)

随着人们在使用计算机方面的经验增加，他们用计算机来解决困难问题或处理大量数据，不可避免地会引发这样的问题：

+   *我的程序需要多长时间？*

+   *为什么我的程序会耗尽内存？*

## 科学方法。

科学家用来理解自然界的方法同样适用于研究程序的运行时间：

+   *观察*自然界的某些特征，通常是通过精确的测量。

+   *假设* 一个与观察一致的模型。

+   使用假设*预测*事件。

+   通过进一步观察*验证*预测。

+   通过重复直到假设和观察一致来*验证*。

我们设计的实验必须是*可重复的*，我们制定的假设必须是*可证伪的*。

## 观察。

我们的第一个挑战是确定如何对程序的运行时间进行定量测量。Stopwatch.java 是一种测量程序运行时间的数据类型。![秒表 API](img/eb851a68937e3be9fcd8758438772bb9.png)ThreeSum.java 计算一个包含 *N* 个整数的文件中总和为 0 的三元组的数量（忽略整数溢出）。DoublingTest.java 生成一系列随机输入数组，每一步将数组大小加倍，并打印 `ThreeSum.count()` 的运行时间。DoublingRatio.java 类似，但还输出从一个大小到下一个大小的运行时间比率。![运行时间的对数图](img/419879ebb7433d723fba083a7250cf53.png)

## 数学模型。

一个程序的总运行时间由两个主要因素决定：执��每个语句的成本和每个语句的执行频率。

+   *波浪线近似。* 我们使用波浪线近似，其中我们丢弃复杂化公式的低阶项。我们写 *~ f(N)* 来表示任何函数，当除以 *f(N)* 时，随着 *N* 的增长趋近于 1。我们写 *g(N) ~ f(N)* 来表示当 *N* 增长时，*g(N) / f(N)* 趋近于 1。![波浪线近似](img/eb1844e39b170a1095ec45d7c3c0c45d.png)

+   *增长顺序分类。* 我们通常使用形式为 *g(N) ~ a f(N)* 的波浪线近似，其中 *f(N) = N^b log^c N*，并将 *f(N)* 称为 *g(N)* 的*增长顺序*。我们只使用几个结构原语（语句、条件、循环、嵌套和方法调用）来实现算法，因此成本的增长顺序往往是问题大小 *N* 的几个函数之一。![增长顺序分类](img/def2e557e026537a8e559a384a2ec2b1.png)

+   *成本模型。* 我们通过阐明定义基本操作的*成本模型*来关注算法的属性。例如，对于 3-sum 问题，一个适当的成本模型是我们访问数组条目的次数，无论是读取还是写入。

**性质。** ThreeSum.java 的运行时间增长顺序为 N³。

**命题。** 暴力 3-sum 算法使用*~ N³ / 2* 数组访问来计算在 *N* 个数字中总和为 0 的三元组的数量。

## 设计更快的算法。

研究程序增长顺序的一个主要原因是帮助设计更快的算法来解决相同的问题。使用归并排序和二分查找，我们为 2-sum 和 3-sum 问题开发了更快的算法。

+   *2-sum.* 暴力解决方案 TwoSum.java 需要的时间与 N² 成正比。TwoSumFast.java 在时间上与 N log N 成正比地解决了 2-sum 问题。

+   *3-sum.* ThreeSumFast.java 在时间上与 N² log N 成正比地解决了 3-sum 问题。

## 处理对输入的依赖。

对于许多问题，运行时间可能会根据输入而有很大的变化。

+   *输入模型.* 我们可以仔细地对要处理的输入类型进行建模。这种方法具有挑战性，因为模型可能是不现实的。

+   *最坏情况性能保证.* 程序的运行时间小于某个界限（作为输入大小的函数），无论输入是什么。这种保守的方法可能适用于运行核反应堆、心脏起搏器或汽车刹车的软件。

+   *随机算法.* 提供性能保证的一种方法是引入随机性，例如快速排序和哈希。每次运行算法时，它都会花费不同的时间。这些保证并不是绝对的，但它们无效的几率小于你的计算机被闪电击中的几率。因此，这些保证在实践中与最坏情况的保证一样有用。

+   *摊销分析.* 对于许多应用程序，算法的输入可能不仅仅是数据，还包括客户端执行的操作序列。摊销分析提供了对*操作序列*的最坏情况性能保证。

**命题.** 在`Bag`、`Stack`和`Queue`的链表实现中，所有操作在最坏情况下都需要常数时间。

**命题.** 在`Bag`、`Stack`和`Queue`的调整大小数组实现中，从空数据结构开始，任何长度为*N*的操作序列在最坏情况下需要与*N*成比例的时间（摊销每个操作的常数时间）。

## 内存使用。

要估算我们的程序使用了多少内存，我们可以计算变量的数量，并根据它们的类型按字节加权。对于*典型*的 64 位机器，

+   *原始类型.* 下表给出了原始类型的内存需求。

+   *对象.* 要确定对象的内存使用量，我们将每个实例变量使用的内存量加到与每个对象相关联的开销上，通常为 16 字节。此外，内存使用量通常会填充为 8 字节的倍数（在 64 位机器上）。![Integer 的内存需求](img/a05c5b3a215b8887262d2b30cbcd1502.png) ![Date 的内存需求](img/0dd6a7baa6e384821da604ab32b2d2a3.png)

+   *参考文献.* 对象的引用通常是一个内存地址，因此在 64 位机器上使用 8 字节的内存。

+   *链表.* 嵌套的非静态（内部）类，比如我们的`Node`类，需要额外的 8 字节开销（用于引用封闭实例）。![Node 的内存需求](img/35adbdc31e12c537791f79e636e4023d.png)

+   *数组.* Java 中的数组被实现为对象，通常需要额外的开销来存储长度。原始类型值的数组通常需要 24 字节的头信息（16 字节的对象开销，4 字节的长度，和 4 字节的填充），再加上存储值所需的内存。![数组的内存需求](img/09149479ff71f0c747a3c0417420b92c.png)

+   *字符串.* Java 7 中长度为*N*的字符串通常使用 32 字节（用于`String`对象），再加上 24 + 2*N*字节（用于包含字符的数组），总共为 56 + 2*N*字节。![String 的内存需求](img/473b238343cba579c4150be658f5c2d8.png)

根据上下文，我们可能会或不会递归地计算对象的内存引用。例如，我们会计算`String`对象中的`char[]`数组的内存，因为这段内存是在创建字符串时分配的。但是，我们通常不会计算`StackOfStrings`对象中`String`对象的内存，因为这些`String`对象是由客户端创建的。

#### 问与答

**问.** 如何增加 Java 分配的内存和堆栈空间？

**A.** 你可以通过使用 `java -Xmx200m Hello` 来增加分配给 Java 的内存量，其中 200m 表示 200 兆字节。默认设置通常为 64MB。你可以通过使用 `java -Xss200k Hello` 来增加分配给 Java 的堆栈空间量，其中 200k 表示 200 千字节。默认设置通常为 128KB。你可以通过使用 `java -Xmx200m -Xss200k Hello` 来同时增加内存和堆栈空间的量。

**Q.** 填充的目的是什么？

**A.** 填充使所有对象占用的空间是 8 字节的倍数。这可能会浪费一些内存，但可以加快内存访问和垃圾回收速度。

**Q.** 我在我的计算实验中得到了不一致的时间信息。有什么建议吗？

**A.** 确保你的计算消耗足够的 CPU 周期，以便你可以准确地测量它。通常，1 秒到 1 分钟是合理的。如果你使用了大量内存，那可能是瓶颈。考虑关闭 HotSpot 编译器，使用 `java -Xint`，以确保更统一的测试环境。缺点是你不再准确地测量你想要测量的内容，即实际运行时间。

**Q.** 如果考虑垃圾回收和其他运行时进程，链表实现的栈或队列是否真的保证每次操作的常数时间？

**A.** 我们的分析没有考虑许多系统效应（如缓存、垃圾回收和即时编译）-在实践中，这些效应很重要。特别是，默认的 Java 垃圾收集器仅保证每次操作的摊销常数时间。然而，有*实时*垃圾收集器保证最坏情况下每次操作的常数时间。[实时 Java](http://en.wikipedia.org/wiki/Real_time_Java)提供了 Java 的扩展，为各种运行时进程（如垃圾回收、类加载、即时编译和线程调度）提供最坏情况下的性能保证。

#### 练习

1.  给出以下代码片段的运行时间的增长顺序（作为 *N* 的函数）：

    1.  ```
        int sum = 0;
        for (int n = N; n > 0; n /= 2)
           for (int i = 0; i < n; i++) 
              sum++;

        ```

    1.  ```
        int sum = 0;
        for (int i = 1; i < N; i *= 2)
           for(int j = 0; j < i; j++)
              sum++;

        ```

    1.  ```
        int sum = 0;
        for (int i = 1; i < N; i *= 2)
           for (int j = 0; j < N; j++)
              sum++;

        ```

        *答案*：线性（N + N/2 + N/4 + ...）；线性（1 + 2 + 4 + 8 + ...）；线性对数级（外部循环循环 lg N 次）。

#### 创意问题

1.  **4-求和。** 对 FourSum.java 问题开发一个蛮力解决方案。

1.  **数组中的局部最小值。** 编写一个程序，给定一个由 *n* 个不同整数组成的数组 `a[]`，找到一个*局部最小值*：一个索引 `i`，使得`a[i] < a[i-1]` 和 `a[i] < a[i+1]`（假设相邻条目在范围内）。在最坏情况下，你的程序应该使用 ~ 2 lg *n* 次比较。

    *答案*：检查中间值 `a[n/2]` 及其两个邻居 `a[n/2 - 1]` 和 `a[n/2 + 1]`。如果 `a[n/2]` 是局部最小值，则停止；否则在较小邻居的一半中搜索。

1.  **矩阵中的局部最小值。** 给定一个由 *n*² 个不同整数组成的 *n*×*n* 数组 `a[]`，设计一个算法，其运行时间与 *n* log *n* 成正比，以找到一个*局部最小值*：一对索引 `i` 和 `j`，使得 `a[i][j] < a[i+1][j]`，`a[i][j] < a[i][j+1]`，`a[i][j] < a[i-1][j]`，以及 `a[i][j] < a[i][j-1]`（假设相邻条目在范围内）。

    *提示*：找到第 `n/2` 行中的最小条目，称为 `a[n/2][j]`。如果它是局部最小值，则返回它。否则，检查它的两个垂直邻居 `a[n/2-1][j]` 和 `a[n/2+1][j]`。在较小邻居的一半中进行递归。

    *额外奖励*：设计一个算法，其运行时间与 *n* 成正比。

1.  **双峰搜索。** 如果一个数组由一个递增的整数序列紧接着一个递减的整数序列组成，则该数组是*双峰*的。编写一个程序，给定一个由 *n* 个不同 `int` 值组成的双峰数组，确定给定的整数是否在数组中。在最坏情况下，你的程序应该使用 ~ 3 log *n* 次比较。

    *答案*: 使用二分查找的一个版本，如 BitonicMax.java 中所示，找到最大值（在~ 1 lg *n*次比较中）；然后使用二分查找在每个片段中搜索（每个片段在~ 1 lg *n*次比较中）。

1.  **只使用加法和减法的二分查找。** [[Mihai Patrascu](http://people.csail.mit.edu/mip/probs.html)] 编写一个程序，给定一个按升序排列的包含*n*个不同整数的数组，确定给定的整数是否在数组中。你只能使用加法和减法以及恒定数量的额外内存。你的程序在最坏情况下的运行时间应与 log *n*成比例。

    *答案*: 不要基于二的幂（二分查找）进行搜索，而是使用斐波那契数（也呈指数增长）。保持当前搜索范围为[i, i + F(k)]，并将 F(k)、F(k-1)保存在两个变量中。在每一步中，通过减法计算 F(k-2)，检查元素 i + F(k-2)，并将范围更新为[i, i + F(k-2)]或[i + F(k-2), i + F(k-2) + F(k-1)]。

1.  **带有重复项的二分查找。** 修改二分查找，使其始终返回与搜索键匹配的项的键的最小（最大）索引。

1.  **从建筑物上扔鸡蛋。** 假设你有一座*N*层的建筑物和大量的鸡蛋。假设如果鸡蛋从第*F*层或更高处扔下，就会摔碎，否则不会。首先，设计一种策略来确定*F*的值，使得在使用*~ lg N*次扔鸡蛋时破碎的鸡蛋数量为*~ lg N*，然后找到一种方法将成本降低到*~ 2 lg F*，当*N*远大于*F*时。

    *提示*: 二分查找；重复加倍和二分查找。

1.  **从建筑物上扔两个鸡蛋。** 考虑前面的问题，但现在假设你只有两个鸡蛋，你的成本模型是扔鸡蛋的次数。设计一种策略，确定*F*，使得扔鸡蛋的次数最多为 2 sqrt(√ *N*)，然后找到一种方法将成本降低到*~c √ F*，其中 c 是一个常数。

    *第一部分的解决方案*: 为了达到 2 * sqrt(N)，在 sqrt(N)、2 * sqrt(N)、3 * sqrt(N)、...、sqrt(N) * sqrt(N)层放置鸡蛋。（为简单起见，我们假设 sqrt(N)是一个整数。）假设鸡蛋在第 k * sqrt(N)层摔碎。用第二个鸡蛋，你应该在区间(k-1) * sqrt(N)到 k * sqrt(N)中进行线性搜索。总共，你最多需要进行 2 * sqrt(N)次试验就能找到楼层 F。

    *第二部分的提示*: 1 + 2 + 3 + ... k ~ 1/2 k²。

1.  **热还是冷。** 你的目标是猜测一个介于 1 和*N*之间的秘密整数。你反复猜测介于 1 和*N*之间的整数。每次猜测后，你会得知它是否等于秘密整数（游戏停止）；否则（从第二次猜测开始），你会得知猜测是*更热*（更接近）还是*更冷*（距离更远）比你之前的猜测。设计一个算法，在*~ 2 lg N*次猜测中找到秘密数字。然后，设计一个算法，在*~ 1 lg N*次猜测中找到秘密数字。

    *提示*: 第一部分使用二分查找。对于第二部分，首先设计一个算法，在*~1 lg N*次猜测中解决问题，假设你被允许在范围-*N*到 2*N*中猜测整数。

#### 网页练习

1.  设 f 是一个单调递增的函数，满足 f(0) < 0 且 f(N) > 0。找到最小的整数 i，使得 f(i) > 0。设计一个算法，使得对 f()的调用次数为 O(log N)。

1.  **上下取整。** 给定一组可比较的元素，x 的*上取整*是集合中大于或等于 x 的最小元素，*下取整*是小于或等于 x 的最大元素。假设你有一个按升序排列的包含 N 个项的数组。给出一个 O(log N)的算法，找到 x 的上取整和下取整。

1.  **使用 lg N 两路比较进行排名。** 实现`rank()`，使其使用~ 1 lg N 两路比较（而不是~ 1 lg N 三路比较）。

1.  **身份。** 给定一个按升序排列的包含 N 个不同整数（正数或负数）的数组 `a`。设计一个算法来找到一个索引 `i`，使得 `a[i] = i`，如果这样的索引存在的话。提示：二分查找。

1.  **多数派。** 给定一个包含 N 个字符串的数组。如果一个元素出现次数超过 N/2 次，则称其为*多数派*。设计一个算法来识别多数派是否存在。你的算法应在线性对数时间内运行。

1.  **多数派。** 重复上一个练习，但这次你的算法应在线性时间内运���，并且只使用恒定数量的额外空间。此外，你只能比较元素是否相等，而不能比较字典顺序。

    *答案*：如果 a 和 b 是两个元素且 a != b，则移除它们两个；多数派仍然存在。使用 N-1 次比较找到多数派的候选者；使用 N-1 次比较检查候选者是否真的是多数派。

1.  **第二小元素。** 给出一个算法，使用最少的比较次数从 N 个项目的列表中找到最小和第二小的元素。*答案*：通过构建一个锦标赛树，在 ceil(N + lg(N) - 2) 次比较中完成。每个父节点都是其两个子节点中的最小值。最小值最终在根节点处；第二小值在根节点到最小值的路径上。

1.  **查找重复项。** 给定一个包含 N 个元素的数组，其中每个元素是介于 1 和 N 之间的整数，请编写一个算法来确定是否存在任何重复项。你的算法应在线性时间内运行，并使用 O(1) 额外空间。*提示*：你可以破坏数组。

1.  **查找重复项。** 给定一个包含 N+1 个元素的数组，其中每个元素是介于 1 和 N 之间的整数，请编写一个算法来查找重复项。你的算法应在线性时间内运行，使用 O(1) 额外空间，并且不得修改原始数组。*提示*：指针加倍。

1.  **查找共同元素。** 给定两个包含 N 个 64 位整数的数组，设计一个算法来打印出两个列表中都出现的所有元素。输出应按排序顺序排列。你的算法应在 N log N 时间内运行。*提示*：归并排序，归并排序，合并。*备注*：在基于比较的模型中，不可能比 N log N 更好。

1.  **查找共同元素。** 重复上述练习，但假设第一个数组有 M 个整数，第二个数组有 N 个整数，其中 M 远小于 N。给出一个在 N log M 时间内运行的算法。*提示*：排序和二分查找。

1.  **变位词。** 设计一个 O(N log N) 算法来读取一个单词列表，并打印出所有的变位词。例如，字符串 "comedian" 和 "demoniac" 是彼此的变位词。假设有 N 个单词，每个单词最多包含 20 个字母。设计一个 O(N²) 的算法应该不难，但将其降至 O(N log N) 需要一些巧妙的方法。

1.  **在排序、旋转数组中搜索。** 给定一个包含 n 个不同整数的排序数组，该数组已经旋转了未知数量的位置，例如，15 36 1 7 12 13 14，请编写一个程序 RotatedSortedArray.java 来确定给定的整数是否在列表中。你的算法的运行时间增长应为对数级别。

1.  **找到数组中的跳跃。** 给定一个由 n 个整数组成的数组，形式为 1, 2, 3, ..., k-1, k+j, k+j+1, ..., n+j，其中 1 <= k <= n 且 j > 0，请设计一个对数时间算法来找到整数 k。也就是说，数组包含整数 1 到 n，只是在某个点上，所有剩余值都增加了 j。

1.  **找到缺失的整数。** 一个数组 `a[]` 包含从 0 到 N 的所有整数，除了 1。但是，你不能通过单个操作访问一个元素。相反，你可以调用 `get(i, k)`，它返回 `a[i]` 的第 k 位，或者你可以调用 `swap(i, j)`，它交换 `a[]` 的第 i 和第 j 个元素。设计一个 O(N) 算法来找到缺失的整数。为简单起见，假设 N 是 2 的幂。

1.  **最长的 0 行。** 给定一个由 0 和 1 组成的 N×N 矩阵，使得在每行中 0 不会出现在 1 之前，找到具有最多 0 的行，并在 O(N) 时间内完成。

1.  **单调二维数组。** 给定一个 n×n 的元素数组，使得每行按升序排列，每列也按升序排列，设计一个 O(n)的算法来确定数组中是否存在给定元素 x。你可以假设 n×n 数组中的所有元素都是不同的。

1.  你站在一条路中间，但有一场尘暴遮挡了你的视线和方向。只有一个方向有庇护所，但直到你站在它面前才能看到任何东西。设计一个能够找到庇护所的算法，保证能找到。你的目标是尽量减少步行的距离。*提示*：某种来回走动的策略。

1.  通过尽可能大的常数因子改进以下代码片段，以适应大规模 n。通过性能分析确定瓶颈在哪里。假设`b[]`是一个长度为`n`的整数数组。

    ```
    double[] a = new double[n];
    for (int i = 0; i < n; i++)
       for (int j = 0; j < n; j++)
           a[j] += Math.exp(-0.5 * (Math.pow(b[i] - b[j], 2)); 

    ```

1.  **原地置换。** 编写一个程序`Permutation.java`，其中包含接受数组和置换（或逆置换）的函数，并根据置换（或逆置换）重新排列数组中的元素。*原地操作*：只使用恒定量的额外内存。

1.  **三数之和。** 给定三个集合 A、B 和 C，每个集合最多包含 N 个整数，确定是否存在三元组 a 在 A 中，b 在 B 中，c 在 C 中，使得 a + b + c = 0。

    *答案*：按升序对 B 进行排序；按降序对 C 进行排序；对于 A 中的每��a，扫描 B 和 C，找到一个对，使得它们的和为-a（当和太小时，在 B 中前进，当和太大时，在 C 中前进）。

1.  **两数之和。** 给定两个集合 A 和 B，每个集合最多包含 N 个整数，确定 A 中任意两个不同整数的和是否等于 B 中的一个整数。

1.  **连续和。** 给定一组实数和目标值 V，找到一个连续块（任意长度），其和尽可能接近 V。

    *暴力法*：通过暴力法计算每个连续块的总和。这需要 O(N³)的时间。

    *部分和*：计算所有部分和 s[i] = a[0] + a[1] + ... + a[i]，以便连续块的和形式为 s[j] - s[i]。这需要 O(N²)的时间。

    *排序和二分查找*：按上述方式形成部分和，然后按升序对它们进行排序。对于每个 i，二分查找尽可能接近 s[i]的 s[j]。这需要 O(N log N)的时间。

1.  **三变量的线性方程。** 对于三个变量的固定线性方程（例如整数系数），给定 N 个数字，其中任意三个是否满足方程？为该问题设计一个二次算法。*提示*：参见三数之和的二次算法。

1.  **卷积三数之和。** 给定 N 个实数，确定是否存在索引 i 和 j，使得 a[i] + a[j] = a[i+j]。为该问题设计一个二次算法。*提示*：参见三数之和的二次算法。

1.  **找到主要项。** 给定一个从标准输入中任意长的项序列，其中一个项出现的次数严格占多数，识别主要项。只使用恒定量的内存。

    *解决方案。* 维护一个整数计数器和一个变量来存储当前的冠军项。读取下一个项，如果该项等于冠军项，则将计数器加一。(ii) 否则将计数器减一，如果计数器达到 0，则用当前项替换冠军值。终止时，冠军值将是主要项。

1.  **数组的记忆。** MemoryOfArrays.java。依赖于 LinearRegression.java。

1.  **字符串和子字符串的记忆。** MemoryOfStrings.java。依赖于 LinearRegression.java 和 PolynomialRegression.java。取决于你使用的是 Java 6 还是 Java 7。

1.  **栈和队列的记忆。** 作为 N 个项的栈的内存使用量是 N 的函数吗？

    *解决方案。* 32 + 40N（不包括引用对象的内存）。MemoryOfStacks.java。

1.  **欧几里得算法的分析。** 证明欧几里得算法的时间复杂度最多与*N*成正比，其中*N*是较大输入中的位数。

    *答案*：首先我们假设 p > q。如果不是，则第一个递归调用实际上会交换 p 和 q。现在，我们要证明在至多 2 次递归调用后，p 会减少一半。为了证明这一点，有两种情况需要考虑。如果 q ≤ p / 2，则下一个递归调用将有 p' = q ≤ p / 2，因此在仅一次递归调用后，p 至少减少了一半。否则，如果 p / 2 < q < p，则 q' = p % q = p - q < p / 2，因此 p'' = q' < p / 2，经过两次迭代后，p 将减少一半或更多。因此，如果 p 有 N 位，则在至多 2N 次递归调用后，欧几里得算法将达到基本情况。因此，总步数与 N 成正比。

1.  **查找重复项。** 给定一个包含 0 到 N 之间的 N+2 个整数的排序数组，其中恰好有一个重复项，设计一个对数时间复杂度的算法来找到重复项。

    *提示* 二分查找。

1.  给定一个包含 n 个实数的数组`a[]`，设计一个线性时间算法来找到`a[j] - a[i]`的最大值，其中`j` ≥ `i`。

    *解决方案*：

    ```
    double best = 0.0;
    double min = a[0];
    for (int i = 0; i < n; i++) {
        min  = Math.min(a[i], min);
        best = Math.max(a[i] - min, best);
    }

    ```

1.  给定一个包含 n 个实数的数组`a[]`，设计一个线性时间算法来找到`|a[j] - a[i]| + |j - i|`的最大值。

    *提示*：创建两个长度为 n 的数组 b[]和 c[]，其中 b[i] = a[i] - i，c[i] = a[i] + i。
