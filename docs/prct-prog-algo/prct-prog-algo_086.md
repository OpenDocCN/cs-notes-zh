# 1.3   袋子、队列和栈

> 原文：[`algs4.cs.princeton.edu/13stacks`](https://algs4.cs.princeton.edu/13stacks)

几种基本数据类型涉及对象的集合。具体来说，值的集合是对象的集合，操作围绕向集合中添加、删除或检查对象展开。在本节中，我们考虑了三种这样的数据类型，称为袋子、队列和栈。它们在规定下一个要移除或检查的对象方面有所不同。

## API。

我们为袋子、队列和栈定义了 API。除了基础知识外，这些 API 还反映了两个 Java 特性：泛型和可迭代集合。![袋子、队列和栈的 API](img/5460bd4efefb1f62d5c2069980397bbc.png)

+   *泛型.* 集合 ADT 的一个重要特征是我们应该能够将它们用于任何类型的数据。一种名为 *泛型* 的特定 Java 机制实现了这一功能。在我们的每个 API 中类名后面的 `<Item>` 表示将 `Item` 命名为 *类型参数*，一个用于客户端的具体类型的符号占位符。你可以将 `Stack<Item>` 理解为“项目的堆栈”。例如，你可以编写如下代码

    ```java
    Stack<String> stack = new Stack<String>();
    stack.push("Test");
    ...
    String next = stack.pop(); 

    ```

    用于 `String` 对象的堆栈。

+   *自动装箱.* 类型参数必须实例化为引用类型，因此 Java 在赋值、方法参数和算术/逻辑表达式中自动在原始类型和其对应的包装类型之间转换。这种转换使我们能够在原始类型中使用泛型，就像以下代码中所示：

    ```java
    Stack<Integer> stack = new Stack<Integer>();
    stack.push(17);        // autoboxing (int -> Integer)
    int i = stack.pop();   // unboxing   (Integer -> int)

    ```

    将基本类型自动转换为包装类型称为 *自动装箱*，将包装类型自动转换为基本类型称为 *拆箱*。

+   *可迭代集合.* 对于许多应用程序，客户端的要求只是以某种方式处理每个项目，或者在集合中 *迭代*。Java 的 *foreach* 语句支持这种范例。例如，假设 `collection` 是一个 `Queue<Transaction>`。那么，如果集合是可迭代的，客户端可以通过一条语句打印交易列表：

    ```java
    for (Transaction t : collection)
       StdOut.println(t);

    ```

+   *袋子.* 一个 *袋子* 是一个不支持移除项目的集合——它的目的是为客户提供收集项目并遍历收集项目的能力。Stats.java 是一个袋子客户端，从标准输入读取一系列实数，并打印出它们的平均值和标准差。

+   *FIFO 队列.* 一个 *FIFO 队列* 是基于 *先进先出*（FIFO）策略的集合。按照任务到达的顺序执行任务的策略在我们日常生活中经常遇到：从在剧院排队等候的人们，到在收费站排队等候的汽车，再到等待计算机应用程序服务的任务。

+   *推入栈.* 一个 *推入栈* 是基于 *后进先出*（LIFO）策略的集合。当你点击超链接时，浏览器会显示新页面（并将其推入栈）。你可以继续点击超链接访问新页面，但总是可以通过点击返回按钮重新访问上一页（从栈中弹出）。Reverse.java 是一个堆栈客户端，从标准输入读取一系列整数，并以相反顺序打印它们。

+   *算术表达式求值.* Evaluate.java 是一个堆栈客户端，用于评估完全括号化的算术表达式。它使用 Dijkstra 的 2 栈算法：

    +   将操作数推送到操作数栈上。

    +   将运算符推送到运算符栈上。

    +   忽略左括号。

    +   遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将将该运算符应用于这些操作数的结果推送到操作数栈上。

    这段代码是一个 *解释器* 的简单示例。

## 数组和调整大小数组实现集合。

+   *固定容量的字符串栈。*FixedCapacityStackOfString.java 使用数组实现了一个固定容量的字符串栈。

+   *固定容量的通用栈。*FixedCapacityStack.java 实现了一个通用的固定容量栈。

+   *数组调整大小栈。*ResizingArrayStack.java 使用*调整大小数组*实现了一个通用栈。使用调整大小数组，我们动态调整数组的大小，使其足够大以容纳所有项目，同时又不会浪费过多空间。如果数组已满，在`push()`中我们将数组大小*加倍*；如果数组少于四分之一满，在`pop()`中我们将数组大小*减半*。

+   *数组调整大小队列。*调整大小数组队列.java 使用调整大小数组实现队列 API。

## 链表。

*链表* 是一种递归数据结构，要么为空（*null*），要么是指向具有通用项和指向链表的节点的引用。要实现链表，我们从定义节点抽象的*嵌套类*开始。

```java
private class Node {
   Item item;
   Node next;
}

```

+   *构建链表。* 要构建一个包含项目`to`、`be`和`or`的链表，我们为每个项目创建一个`Node`，将每个节点中的项目字段设置为所需值，并设置`next`字段以构建链表。![构建链表](img/7a9bacafeccb1c97eed7cbc61bbaeab7.png)

+   *在开头插入。* 在链表中插入新节点的最简单位置是在开头。![在链表开头插入新节点](img/72cf0f3491801c4b270d0c93c67ba0d0.png)

+   *从开头删除。* 删除链表中的第一个节点也很容易。![删除链表中的第一个节点](img/1bd57fe595536664f5f220f60f4b892c.png)

+   *在末尾插入。* 要在链表的末尾插入一个节点，我们需要维护一个指向链表中最后一个节点的链接。![在链表末尾插入节点](img/a8eb4193b8059c1489ef1bc1f7c16e0a.png)

+   *遍历。* 以下是遍历链表中节点的习惯用法。

    ```java
    for (Node x = first; x != null; x = x.next) {
       // process x.item
    }

    ```

## 集合的链表实现。

+   *栈的链表实现。*Stack.java 使用链表实现了一个通用栈。它将栈作为一个链表维护，栈的顶部在开头，由实例变量`first`引用。要`push()`一个项目，我们将其添加到列表的开头；要`pop()`一个项目，我们将其从列表的开头移除。

+   *队列的链表实现。* 程序 Queue.java 使用链表实现了一个通用 FIFO 队列。它将队列作为一个链表维护，从最近添加的项目到最近添加的项目的顺序，队列的开始由实例变量`first`引用，队列的结束由实例变量`last`引用。要`enqueue()`一个项目，我们将其添加到列表的末尾；要`dequeue()`一个项目，我们将其从列表的开头移除。

+   *背包的链表实现。* 程序 Bag.java 使用链表实现了一个通用背包。该实现与 Stack.java 相同，只是将`push()`的名称更改为`add()`并删除`pop()`。

## 迭代。

要考虑实现迭代的任务，我们从一个客户端代码片段开始，该代码打印字符串集合中的所有项目，每行一个：

```java
Stack<String> collection = new Stack<String>();
...
for (String s : collection)
   StdOut.println(s);
...

```

这个*foreach*语句是以下`while`语句的简写：

```java
Iterator<String> i = collection.iterator();
while (i.hasNext()) { 
   String s = i.next();
   StdOut.println(s);
}

```

要在集合中实现迭代：

+   包含以下`import`语句，以便我们的代码可以引用 Java 的[java.util.Iterator](http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html)接口：

    ```java
    import java.util.Iterator;

    ```

+   将以下内容添加到类声明中，承诺提供一个`iterator()`方法，如[Java.lang.Iterable](http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html)接口中指定的：

    ```java
    implements Iterable<Item>

    ```

+   实现一个返回实现`Iterator`接口的类的对象的方法`iterator()`：

    ```java
    public Iterator<Item> iterator() {
        return new LinkedIterator();
    }

    ```

+   实现一个嵌套类，通过包含`hasNext()`、`next()`和`remove()`方法来实现`Iterator`接口。我们总是对可选的`remove()`方法使用空方法，因为最好避免在迭代中插入修改数据结构的操作。

    +   当底层数据结构是链表时，Bag.java 中的嵌套类`LinkedIterator`说明了如何实现一个实现`Iterator`接口的类。

    +   当底层数据结构是数组时，ResizingArrayBag.java 中的嵌套类`ArrayIterator`也是如此。

#### 自动装箱问题 + 回答

**Q.** 自动装箱如何处理以下代码片段？

```java
Integer a = null;
int b = a;

```

**A.** 这导致运行时错误。原始类型可以存储其对应包装类型的每个值，除了`null`。

**Q.** 为什么第一组语句打印`true`，但第二组打印`false`？

```java
Integer a1 = 100;
Integer a2 = 100;
System.out.println(a1 == a2);   // true

Integer b1 = new Integer(100);
Integer b2 = new Integer(100);
System.out.println(b1 == b2);   // false

Integer c1 = 150;
Integer c2 = 150;
System.out.println(c1 == c2);   // false

```

**A.** 第二个打印`false`，因为`b1`和`b2`是指向不同 Integer 对象的引用。第一个和第三个代码片段依赖于自动装箱。令人惊讶的是，第一个打印 true，因为在-128 和 127 之间的值似乎指向相同的不可变 Integer 对象（Java 的`valueOf()`实现在整数在此范围内时检索缓存值），而 Java 为此范围外的每个整数构造��对象。

这里是另一个 Autoboxing.java 的异常。

#### 泛型问题 + 回答

**Q.** 泛型仅用于自动转换吗？

**A.** 不是，但我们只会用于“具体参数化类型”，其中每种数据类型都由单个类型参数化。主要好处是在编译时而不是运行时发现类型不匹配错误。泛型还有其他更一般（更复杂）的用途，包括通配符。这种一般性对于处理子类型和继承很有用。有关更多信息，请参阅这个[泛型常见问题解答](http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html)和这个[Java 泛型教程](http://docs.oracle.com/javase/tutorial/java/generics)。

**Q.** 具体参数化类型可以像普通类型一样使用吗？

**A.** 是的，有几个例外情况（数组创建、异常处理、使用`instanceof`和在类文字中）。

**Q.** 我可以将 Node 类设为静态吗？

**A.** 对于 LinkedStackOfString.java，你可以这样做而不需要其他更改，并节省每个节点的 8 字节（内部类开销）。然而，在 LinkedStack.java 中的嵌套类`Node`使用外部类的`Item`类型信息，因此你需要做一些额外的工作使其静态化。Stack.java 通过使嵌套类（和嵌套迭代器）泛型化来实现这一点：有三个单独的泛型类型参数，每个都命名为`Item`。

**Q.** 当我尝试创建泛型数组时为什么会出现“无法创建泛型数组”的错误？

```java
public class ResizingArrayStack<Item> {
   Item[] a = new Item[1];

```

**A.** 不幸的是，在 Java 1.5 中无法创建泛型数组。根本原因是 Java 中的数组是*协变*的，但泛型不是。换句话说，`String[]`是`Object[]`的子类型，但`Stack<String>`不是`Stack<Object>`的子类型。为了解决这个缺陷，你需要执行一个未经检查的转换，就像在 ResizingArrayStack.java 中一样。ResizingArrayStackWithReflection.java 是一个（笨拙的）替代方案，通过使用反射来避免未经检查的转换。

**Q.** 那么，为什么数组是协变的？

**A.** 许多程序员（和编程语言理论家）认为 Java 类型系统中的协变数组是一个严重的缺陷：它们会产生不必要的运行时性能开销（例如，参见[ArrayStoreException](http://download.oracle.com/javase/6/docs/api/java/lang/ArrayStoreException.html)），并且可能导致微妙的错误。Java 引入协变数组是为了解决 Java 最初设计中不包含泛型的问题，例如，实现`Arrays.sort(Comparable[])`并使其能够接受`String[]`类型的输入数组。

**Q.** 我可以创建并返回一个参数化类型的新数组吗，例如为泛型队列实现一个`toArray()`方法？

**A.** 不容易。你可以使用反射来实现，前提是客户端向`toArray()`传递所需具体类型的对象。这是 Java 集合框架采取的（笨拙的）方法。GenericArrayFactory.java 提供了一个客户端传递`Class`类型变量的替代解决方案。另请参阅 Neal Gafter 的博客，了解使用[type tokens](http://gafter.blogspot.ru/2004/09/puzzling-through-erasure-answer.html)的解决方案。

#### 迭代器问答

**Q.** 为什么这个结构被称为*foreach*，而它使用关键字`for`？

**A.** 其他语言使用关键字`foreach`，但 Java 开发人员不想引入新关键字并破坏向后兼容性。

**Q.** `String`可迭代吗？

**A.** 不。

**Q.** 数组是`Iterable`吗？

**A.** 不。你可以使用它们的 foreach 语法。但是，你不能将数组传递给期望`Iterable`的方法，也不能从返回`Iterable`的方法返回数组。这样会很方便，但实际上不起作用。

**Q.** 以下代码片段有什么问题？

```java
String s;
for (s : listOfStrings)
   System.out.println(s);

```

**A.** 增强的 for 循环要求在循环内部声明迭代变量。

#### 练习

1.  在 FixedCapacityStackOfStrings.java 中添加一个`isFull()`方法。

1.  给出`java Stack`对输入打印的输出

    ```java
    it was - the best - of times - - - it	was - the - -

    ```

    *解决方案*。`was best times of the was the it (1 left on stack)`

1.  假设执行了一系列交错的（栈）*push*和*pop*操作。push 操作按顺序将整数 0 到 9 推入栈；pop 操作打印返回值。以下哪种序列不可能发生？

    ```java
    (a)  4 3 2 1 0 9 8 7 6 5

    (b)  4 6 8 7 5 3 2 9 0 1

    (c)  2 5 6 7 4 8 9 3 1 0

    (d)  4 3 2 1 0 5 6 7 8 9

    (e)  1 2 3 4 5 6 9 8 7 0

    (f)  0 4 6 5 3 8 1 7 2 9

    (g)  1 4 7 9 8 6 5 3 0 2

    (h)  2 1 4 3 6 5 8 7 9 0

    ```

    *答案*：(b)、(f)和(g)。

1.  编写一个栈客户端 Parentheses.java，从标准输入中读取一系列左右括号、大括号和方括号，并使用栈来确定序列是否平衡。例如，你的程序应该对`[()]{}{[()()]()}`打印`true`，对`[(])`打印`false`。

1.  当`n`为 50 时，以下代码片段打印什么？给出当给定正整数`n`时它的高级描述。

    ```java
    Stack<Integer> s = new Stack<Integer>();
    while (n > 0) {
       s.push(n % 2);
       n = n / 2;
    }
    while (!s.isEmpty())
        System.out.print(s.pop());
    System.out.println();

    ```

    *答案*：打印`N`的二进制表示（当`n`为`50`时为`110010`）。

1.  以下代码片段对队列`q`做了什么？

    ```java
    Stack<String> s = new Stack<String>();
    while(!q.isEmpty())
       s.push(q.dequeue());
    while(!s.isEmpty())
       q.enqueue(s.pop());

    ```

    *答案*：颠倒队列中的项目。

1.  在 Stack.java 中添加一个`peek`方法，返回栈中最近插入的项（不弹出）。

1.  编写一个过滤器程序 InfixToPostfix.java，将中缀算术表达式转换为后缀表达式。

1.  编写一个程序 EvaluatePostfix.java，从标准输入中获取后缀表达式，对其进行评估，并打印值。（将上一个练习的程序输出通过管道传递给这个程序，可以实现与 Evaluate.java 相同的行为。）

1.  假设客户端执行了一系列交错的（队列）*enqueue*和*dequeue*操作。enqueue 操作按顺序将整数 0 到 9 放入队列；dequeue 操作打印返回值。以下哪种序列不可能发生？

    ```java
    (a)  0 1 2 3 4 5 6 7 8 9

    (b)  4 6 8 7 5 3 2 9 0 1 

    (c)  2 5 6 7 4 8 9 3 1 0

    (d)  4 3 2 1 0 5 6 7 8 9

    ```

    *答案*：(b)、(c)和(d)。

1.  开发一��类 `ResizingArrayQueueOfStrings`，使用固定大小数组实现队列抽象，然后扩展您的实现以使用数组调整大小以消除大小限制。

    *解决方案*: ResizingArrayQueue.java

#### 链表练习

#### 创意问题

1.  **约瑟夫问题。** 在古代的约瑟夫问题中，*N* 个人陷入困境，并同意采取以下策略来减少人口。 他们围成一个圆圈（位置从 0 到 N-1 编号），沿着圆圈进行，每隔 M 个人就淘汰一个，直到只剩下一个人。 传说中约瑟夫找到了一个位置可以避免被淘汰。编写一个 `Queue` 客户端 Josephus.java，从命令行获取 M 和 N，并打印出人们被淘汰的顺序（从而向约瑟夫展示在圆圈中应该坐在哪里）。

    ```java
     % java Josephus 2 7
    1 3 5 0 4 2 6

    ```

1.  **复制一个栈。** 为链表实现的 Stack.java 创建一个新的构造函数，使得 `Stack t = new Stack(s)` 使 `t` 引用栈 `s` 的一个新且独立的副本。

    *递归解决方案:* 为从给定 `Node` 开始的链表创建一个复制构造函数，并使用它来创建新的栈。

    ```java
    Node(Node x) {
       item = x.item;
       if (x.next != null) next = new Node(x.next);
    }

    public Stack(Stack<Item> s) { first = new Node(s.first); }

    ```

    *非递归解决方案:* 为单个 `Node` 对象创建一个复制构造函数。

    ```java
    Node(Node x) { this.item = x.item; this.next = x.next; }

    public Stack(Stack<Item> s) {
       if (s.first != null) {
          first = new Node(s.first);
          for (Node x = first; x.next != null; x = x.next)
             x.next = new Node(x.next);
       }
    }

    ```

1.  **栈的可生成性。** 假设我们有一个混合 *push* 和 *pop* 操作的序列，就像我们的测试栈客户端一样，其中按顺序 0、1、...、N-1（*push* 指令）与 *N* 个减号（*pop* 指令）交错。设计一个算法，确定混合序列是否会导致栈下溢。 （您只能使用与 *N* 无关的空间量 - 不能将整数存储在数据结构中。）设计一个线性时间算法，确定给定排列是否可以由我们的测试客户端生成输出（取决于 *pop* 操作发生的位置）。

    *解决方案。* 只有存在整数 *k*，使得前 *k* 个 pop 操作发生在前 *k* 个 push 操作之前，栈才会下溢。

    如果可以生成给定的排列，那么它将唯一生成如下：如果排列中的下一个整数在栈的顶部，则弹出它；否则，将输入序列中的下一个整数推送到栈上（或者如果已经推送了 N-1，则停止）。 只有在终止时栈为空，排列才能生成。

1.  **栈可生成的禁止三元组。 (R. Tarjan)** 证明排列可以由栈生成（如前一个问题中所述），当且仅当它没有 *禁止的三元组 (a, b, c)*，其中 a < b < c，c 第一，a 第二，b 第三（可能在 c 和 a 之间以及 a 和 b 之间有其他插入的整数）。

    *部分解决方案。* 假设存在一个禁止的三元组（a，b，c）。 在 a 和 b 之前弹出项 c，但在 c 之前推入 a 和 b。 因此，当推入 c 时，a 和 b 都在栈上。 因此，在弹出 b 之前，a 不能被弹出。

1.  **可连接的队列、栈或 steque。** 添加一个额外的 *连接* 操作，（破坏性地）连接两个队列、栈或 steques。 *提示*: 使用循环链表，保持指向最后一项的指针。

1.  **快速失败的迭代器。** 修改 Stack.java 中的迭代器代码，如果客户端在迭代期间修改集合（通过 `push()` 或 `pop()`）则立即抛出 [java.util.ConcurrentModificationException](http://download.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html)。

    *解决方案:* 维护一个计数器，计算 `push()` 和 `pop()` 操作的次数。 创建一个迭代器时，将此值存储为迭代器实例变量。 在每次调用 `hasNext()` 和 `next()` 之前，检查该值是否自构造迭代器以来已更改；如果已更改，则抛出异常。

1.  **带优先级的表达式求值。** 编写一个程序 EvaluateDeluxe.java，扩展 Evaluate.java 以处理未完全括号化的表达式，使用标准的运算符 +、-、* 和 / 的优先级顺序。

#### 网络练习

1.  **尾部。** 编写一个程序 `Tail`，使得 `Tail k < file.txt` 打印文件 `file.txt` 的最后 `k` 行。使用 `StdIn.readLine()`。应该使用哪种数据结构？

1.  **有界栈。** 一个*有界栈*是一个最多容纳 N 个元素的栈。（应用：带有有限缓冲区的撤销或历史记录。）

1.  **删除第 i 个元素。** 创建一个支持以下操作的数据类型：`isEmpty`、`insert` 和 `remove(int i)`，其中删除操作删除并返回队列中最近添加的第 i 个对象。首先使用数组实现，然后使用链表实现。每个操作的运行时间是多少？

1.  **动态缩小。** 使用栈和队列的数组实现时，当数组不足以存储下一个元素时，我们会将数组大小加倍。如果我们执行了多次加倍操作，然后删除了很多元素，可能会得到一个比必要的大得多的数组。实现以下策略：每当数组的填充率低于 1/4 时，将其缩小到一半大小。解释为什么当填充率低于 1/2 时我们不将其缩小到一半大小。

1.  **栈 + 最大值。** 创建一个数据结构，有效支持栈操作（弹出和推入），并返回最大元素。假设元素是整数或实数，以便可以比较它们。

    *提示*：使用两个堆栈，一个用于存储所有元素，另一个用于存储最大值。

1.  **PostScript。** *PostScript* 是大多数打印机使用的基于堆栈的语言。使用一个堆栈实现 PostScript 的一个小子集。

1.  **面试问题。** 给定一个未知数量的字符串的堆栈，打印出倒数第 5 个字符串。在此过程中破坏堆栈是可以的。*提示*：使用一个包含 5 个元素的队列。

1.  **标签系统。** 编写一个程序，从命令行读取一个二进制字符串，并应用以下（00, 1101���标签系统：如果第一个位是 0，则删除前三位并追加 00；如果第一个位是 1，则删除前三位并追加 1101。只要字符串至少有 3 位，就重复此过程。尝试确定以下输入是否会停止或进入无限循环：10010, 100100100100100100。使用一个队列。

1.  **图灵带。** 实现一个*一维图灵带*。带由一系列单元格组成，每个单元格存储一个整数（初始化为 0）。在任何时刻，都有一个*带头*指向其中一个单元格。支持以下接口方法：`moveLeft` 将带头向左移动一个单元格，`moveRight` 将带头向右移动一个单元格，`look` 返回活动单元格的内容，`write(int a)` 将活动单元格的内容更改为 `a`。*提示*：使用一个 `int` 表示活动单元格，使用两个堆栈表示带的左侧和右侧部分。类似于文本编辑器缓冲区。

1.  **回文检查器。** 编写一个程序，读取一系列字符串并检查它们是否构成回文。忽略标点、空格和大小写。（A MAN, A PLAN, A CANAL - PANAMA）。使用一个栈和一个队列。

1.  **流算法。** 给定一长序列的项目，设计一个数据结构来存储最近看到的 k 个项目。

1.  **2 M/M/1 队列。** 下一个顾客被分配到两个队列中较小的一个。使用 2 个先进先出队列。当接近收费站时，总是选择较长的队列（或错误的车道）的感觉。假设两辆车同时进入收费站并选择相同长度的不同队列。计算一辆车领先另一辆车的平均时间长度。

1.  **M/M/k 队列。** 比较 k 个独立的 M/M/1 队列和 M/M/k 队列。

1.  **M/G/1 队列。** 分析具有不同服务分布（G = 一般）的排队模型。

1.  **中缀表达式转后缀表达式并考虑优先级顺序。** 编写一个程序将中缀表达式转换为后缀表达式。从左到右扫描中缀表达式。

    +   操作数：输出它。

    +   左括号：推入栈中。

    +   右括号：重复弹出栈中的元素并输出，直到遇到左括号。丢弃两个括号。

    +   优先级高于栈顶的运算符：推入栈中。

    +   优先级低于或等于栈顶的运算符：重复弹出栈中的元素并输出，直到栈顶的运算符具有更高的优先级。将扫描到的运算符推入栈中。之后，弹出栈中的剩余元素并输出。

1.  **检查重复。** 编写一个代码片段，确定一个袋子是否包含任何重复项目。使用两个嵌套迭代器。

1.  **检查三重复。** 编写一个代码片段，确定一个袋子是否包含至少三次重复的项目。使用三重嵌套迭代器。

1.  **相等。** 如果两个队列按相同顺序包含相同项目，则它们相等。如果两个袋子包含相同项目但顺序不同，则它们相等。

1.  **整数集合。** 创建一个表示 0 到 N-1 之间（无重复）整数集合的数据类型。支持`add(i)`，`exists(i)`，`remove(i)`，`size()`，`intersect`，`difference`，`symmetricDifference`，`union`，`isSubset`，`isSuperSet`和`isDisjointFrom`。包括一个迭代器。

1.  **冒号。** 有经验的程序员知道，像下面这样写一个循环通常是一个坏主意

    ```java
    for (double x = 0.0; x <= N; x += 0.1) {
       ..
    }

    ```

    由于浮点精度的结果，如果 N = xxx，则循环将执行 10N 次，如果 N = yyy，则执行 10N + 1 次。创建一个数据类型`Mesh`，使得`x`从`left`到`right`以`delta`的大小增量。假设`right >= left`，则循环应该*恰好*执行`1 + floor((right - left) / delta)`次。

    ```java
    for (double x : new Mesh(left, right, delta)) {
       ..
    }

    ```

    这是 MATLAB 中冒号运算符的工作原理。您还应该对程序进行调试，以确保即使`left > right`且`delta`为负数也能正常工作。

1.  **列表迭代器。** 我们可能还想包括用于在列表中向后移动的方法`hasPrevious()`和`previous()`。要实现`previous()`，我们可以使用双向链表。程序 DoublyLinkedList.java 实现了这种策略。它使用 Java 的`java.util.ListIterator`接口支持向前和向后移动。我们实现了所有可选方法，包括`remove()`，`set()`和`add()`。`remove()`方法删除`next()`或`previous()`返回的最后一个元素。`set()`方法覆盖`next()`或`previous()`返回的最后一个元素的值。`add()`方法在`next()`将返回的下一个元素之前插入一个元素。只有在调用`next()`或`previous()`之后，且没有调用`remove()`或`add()`之后，才能调用`set()`和`remove()`是合法的。

    我们使用一个虚拟的头节点和尾节点来避免额外的情况。我们还存储一个额外的变量`lastAccessed`，它存储在最近一次调用`next()`或`previous()`时访问的节点。删除元素后，我们将`lastAccessed`重置为`null`；这表示调用`remove()`是非法的（直到随后调用`next()`或`previous()`为止）。

1.  **双向迭代器。** 定义一个支持四种方法的接口`TwoWayIterator`：`hasNext()`，`hasPrevious()`，`next()`和`previous()`。实现一个支持`TwoWayIterator`的列表。*提示*：使用数组或双向链表实现列表。

1.  **将一个袋子添加到另一个末尾。** 编写一个方法，将一个袋子 b 的项目添加到调用方的末尾。假设两个袋子存储相同类型的项目。

    *提示*：使用迭代器遍历 b 的项目，并将每个项目添加到调用方的末尾。

1.  **替换所有。** 编写一个方法，在队列或栈中用项目`from`替换所有出现的项目`to`。

1.  **将列表添加到自身。** 以下代码片段的结果是什么？

    ```java
    List list1 = new ArrayList();
    List list2 = new ArrayList();
    list1.add(list2);
    list2.add(list1);
    System.out.println(list1.equals(list2));

    List list = new ArrayList();
    list.add(list);
    System.out.println(list.hashCode());

    ```

    *答案：* 栈溢出。Java 文档中说：“虽然列表可以包含自身作为元素，但极度谨慎是明智的：在这样的列表上，equals 和 hashCode 方法不再被很好地定义。”

1.  **歌曲播放列表。** 创建一个支持以下操作的数据类型：`enqueue`（将新歌曲添加到列表末尾）、`play`（打印下一首歌曲的名称）、`skip`（跳过列表中的下一首歌曲，不打印其名称）和`back`（返回上一首歌曲）。使用支持前向和后向迭代器的列表。

1.  **Josephus。** 程序 Josephus.java 计算 Josephus 数。

1.  以下代码会按升序打印出整数 0 到 9 吗？

    ```java
    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    for (int val : vals) {
       System.out.print(val + " ");
       StdRandom.shuffle(vals);     // mutate the array while iterating
    }
    System.out.println();

    ```

    不会。它会打印出 10 个值，但会有一些重复项，并且不会按升序排列。迭代器不会保存原始数组的副本 - 相反，它使用已变异的副本。

1.  **使用一个访问指针实现队列。** 重新实现一个队列，所有操作都需要恒定时间，但只有一个实例变量（而不是两个）。*提示：* 使用循环链表，保持指向最后一个项目的指针。

1.  **Steque。** *栈结束队列*或*steque*是一种支持 push、pop 和 enqueue 的数据类型。Knuth 将其称为输出受限双端队列。使用单链表实现它。

1.  **使用两个栈实现队列。** 实现一个使用两个栈的队列，使得每个队列操作都需要恒定的摊销栈操作次数。*提示：* 如果你将元素推入栈然后全部弹出，它们会以相反顺序出现。如果你重复这个过程，它们现在又会按顺序排列。

    *解决方案：*QueueWithTwoStacks.java。

1.  **使用恒定数量的栈实现队列。** 实现一个使用恒定数量的栈的队列，使得每个队列操作都需要恒定（最坏情况）的栈操作次数。*警告：* 难度非常高。

1.  **使用队列实现栈。** 实现一个使用单个队列的栈，使得每个栈操作都需要线性数量的队列操作。*提示：* 要删除一个项目，逐个获取队列中的所有元素，并将它们放在末尾，除了最后一个应该删除并返回。（诚然非常低效。）

1.  **使用 Deque 实现两个栈。** 使用单个 Deque 实现两个栈，使得每个操作都需要恒定数量的 Deque 操作。

1.  **使用两个栈实现 Steque。（R. Tarjan）** 实现一个使用两个栈的 Steque，使得每个 Steque 操作都需要恒定的摊销栈操作次数。

1.  **使用栈和 Steque 实现 Deque。（R. Tarjan）** 实现一个使用栈和 Steque 的 Deque，使得每个 Deque 操作都需要恒定的摊销栈和 Steque 操作次数。

1.  **使用三个栈实现 Deque。（R. Tarjan）** 实现一个使用三个栈的 Deque，使得每个 Deque 操作都需要恒定的摊销栈操作次数。

1.  *多词搜索。* 程序 MultiwordSearch.java 从命令行读取查询词 q[1]，...，q[k]的序列，从标准输入读取文档单词 d[1]，...，d[N]的序列，并找到这些 k 个单词按相同顺序出现的最短间隔。（这里最短意味着间隔中的单词数。）即找到索引 i 和 j，使得 d[i1] = q[1]，d[i2] = q[2]，...，d[ik] = q[k]，且 i1 < i2 < ... < ik。

    *答案*：对于每个查询词，创建一个在文档中出现的索引的排序列表。按照 2 到 k 的顺序扫描列表，删除每个列表前面的索引，直到生成的 k 个列表的第一个元素按升序排列。

    ```java
    q[1]: 50 123 555 1002 1066
    q[2]: 33 44 93 333 606 613
    q[3]: 60 200
    q[4]: 12 18 44 55 203 495

    q[1]: 50 123 555 1002 1066
    q[2]: 93 333 606 613
    q[3]: 200
    q[4]: 203 495

    ```

    列表 1 上的第一个元素序列形成包含列表 1 上第一个元素的最短间隔。

    现在删除列表 1 上的第一个元素。重复删除列表 2 中的元素，直到它与列表 1 一致。对列表 3 重复此操作，直到整个数组按升序排列。检查这个序列的第一个元素等等。

1.  *M/M/1 队列.* [马尔可夫/马尔可夫/单服务器模型](https://en.wikipedia.org/wiki/M/M/1_queue) 是运筹学和概率论中的基本排队模型。任务以特定速率 λ 按泊松过程到达。这意味着每小时到达 λ 个顾客。���具体地说，到达遵循均值为 1 / λ 的指数分布：在时间 0 和 t 之间到达 k 个的概率是 (λ t)^k e^(-λ t) / k!。任务按照率为 μ 的泊松过程按 FIFO 顺序服务。两个 M 代表马尔可夫：这意味着系统是*无记忆*的：到达之间的时间是独立的，离开之间的时间也是独立的。

    M/M/1 模型分析。我们感兴趣的是理解排队系统。如果 λ > μ，则队列大小会无限增加。对于像 M/M/1 这样的简单模型，我们可以使用概率论来分析这些数量。假设 μ > λ，系统中恰好有 n 个顾客的概率是 (λ / μ)^n (1 - λ / μ)。

    +   L = 系统中平均顾客数量 = λ / (μ - λ).

    +   L[Q] = 队列中平均顾客数量 = λ² / (μ (μ - λ)).

    +   W = 顾客在系统中的平均时间 = 1 / (μ - λ).

    +   W[Q] = 顾客在队列中的平均时间 = W - 1 / μ.

    程序 MM1Queue.java 对于更复杂的模型，我们需要使用这样的模拟。变体：多个队列，多个服务器，顺序多级服务器，使用有限队列并测量被拒绝的顾客数量。应用：麦当劳的顾客，互联网路由器中的数据包，

1.  *列出文件.* Unix 目录是文件和目录的列表。程序 Directory.java 接受目录名称作为命令行参数，并按级别顺序打印出该目录中包含的所有文件（以及任何子目录）。它使用一个队列。

1.  *中断处理.* 当编写可以被中断的实时系统（例如，通过鼠标点击或无线连接）时，有必要立即处理中断，然后再继续当前活动。如果中断应按照到达顺序处理，则 FIFO 队列是适当的数据结构。

1.  *库实现.* Java 有一个名为 `Stack` 的内置库，但您应该避免使用它。它具有不通常与堆栈相关联的附加操作，例如获取第 i 个元素和将元素添加到堆栈底部（而不是顶部）。尽管具有这些额外操作可能看起来是一个奖励，但实际上是一个诅咒。我们使用 ADT 不是因为它们提供了每个可用的操作，而是因为它们*限制*了我们可以执行的操作类型！这可以防止我们执行我们实际上不想要的操作。如果我们需要的不仅仅是 LIFO 访问，我们应该使用不同的数据类型。我们仍然可以从 Java 库构建一个堆栈数据类型，但我们要小心限制操作类型。没有 Java 队列实现。

1.  *负载平衡.* N 个用户必须在网络中的 N 个相同服务器中进行选择。目标：平衡用户在资源之间的分布。检查每个资源以找到一个空闲的（或最不忙的）资源太昂贵了。相反，选择一个随机服务器。在任何步骤中，您应该能够看到每台机器上的作业。程序 Server.java 绘制负载分布。理论：平均负载 = 1，最大负载 = log N / log log N。

1.  *负载平衡再加载.* ([Azar, Broder, Karlin, and Upfal](http://epubs.siam.org/sam-bin/getfile/SICOMP/articles/28849.pdf)) 选择两个随机资源。插入到两者中最不忙的资源上。理论：平均负载 = 1，最大负载 = log log N。

1.  *网格化。*给定单位盒中的 N 个欧几里得点和参数 d，找到所有距离 d 以内的点对。将盒子分成一个 G×G 的网格，其中 G = ceil(1/d)。将所有点放入给定网格单元格中的列表。任何距离 d 以内的邻居必须在该单元格或其 8 个邻居之一中。程序 Grid.java 使用辅助数据类型 Point2D.java 实现了这种策略。

1.  *Java 库。*Java 包含库类`LinkedList`和`ArrayList`，实现了一个列表。比我们的`Sequence`数据类型具有更广泛的接口：通过索引访问元素，删除元素，搜索元素。没有 urns。

1.  为`Stack`添加一个名为`dup()`的方法，用于创建顶部元素的副本并将其推入栈中。

1.  为`Stack`添加一个名为`exch()`的方法，用于交换栈顶部的两个元素。

1.  为`Stack`添加一个名为`size()`的方法，返回栈中的元素数量。

1.  为`Stack`添加一个名为`Item[] multiPop(int k)`的方法，从栈中弹出 k 个元素并将它们作为对象数组返回。

1.  为`Queue`添加一个名为`Item[] toArray()`的方法，将队列中的所有 N 个元素作为长度为 N 的数组返回。

1.  编写一个递归函数，该函数以队列作为输入，并重新排列队列，使其顺序相反。提示：出队第一个元素，递归反转队列，然后入队第一个元素。

1.  给定一个队列，创建两个新队列 q1 和 q2，使得 q1 包含 q 的偶数元素，q2 包含奇数元素，例如，就像处理一副牌一样。

1.  以下代码片段做什么？

    ```java
    Queue<Integer> q = new Queue<Integer>();
    q.enqueue(0);
    q.enqueue(1);
    for (int i = 0; i < 10; i++) {
        int a = q.dequeue();
        int b = q.dequeue();
        q.enqueue(b);
        q.enqueue(a + b);
        System.out.println(a);
    }

    ```

1.  在文字处理器中实现“撤销”功能，您会选择哪种数据类型来实现？

1.  假设您有一个大小为 N 的单个数组，并且希望实现两个栈，以便在两个栈上的元素总数为 N+1 之前不会溢出。您将如何实现这一点？

1.  假设您在 Stack.java 的链表实现中使用以下代码实现`push`。错误在哪里？

    ```java
    public void push(Item item) {
       Node second = first;
       Node first = new Node();
       first.item = item;
       first.next = second;
    }

    ```

    *答案*：通过重新声明`first`，您创建了一个名为`first`的新局部变量，它与名为`first`的实例变量不同。

1.  **最小栈。**设计一个数据类型，实现以下操作，所有操作都在常数时间内完成：推送，弹出，最小值。假设项目是`Comparable`的。

    *解决方案*：维护两个栈，一个包含所有项目，另一个包含最小值。要推送项目，请将其推送到第一个栈；如果它小于第二个栈的顶部项目，请将其也推送到第二个栈。要弹出项目，请从第一个栈弹出；如果它是第二个栈的顶部项目，请也从第二个栈弹出。要找到最小值，请返回第二个栈的顶部项目。

1.  **翻倍和减半。**将 ResizingArrayStack.java 中的减半测试从`if (N > 0 && N == a.length/4) resize(a.length/2);`替换为`if (N == a.length/4) resize(2*N);`的效果是什么？

1.  **Shunting-yard 算法。**实现 Dijkstra 的[shunting-yard 算法](http://en.wikipedia.org/wiki/Shunting-yard_algorithm)将中缀表达式转换为后缀表达式。支持运算符优先级，包括左结合和右结合运算符。

1.  **FIFO 队列与随机删除。**实现一个数据类型，支持*插入一个项目*，*删除最近添加的项目*和*删除一个随机项目*。每个操作应该在每次操作中花费常数期望摊销时间，并且应该使用空间（最多）与数据结构中的项目数量成比例。

1.  **股票价格。**给定每日股票价格数组`prices[]`，创建一个数组`days[]`，使得`days[i]`告诉您从第`i`天开始，直到股票价格超过`prices[i]`需要等待多少天。

    *提示*：你的算法应该以线性时间运行，并使用一个数组索引的栈。
