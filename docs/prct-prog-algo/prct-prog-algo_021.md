# 4.2   排序和搜索

> 原文：[`introcs.cs.princeton.edu/java/42sort`](https://introcs.cs.princeton.edu/java/42sort)

排序问题是将一个数组中的项按升序重新排列。在本节中，我们将详细讨论两种经典的排序和搜索算法——二分搜索和归并排序——以及它们的效率在多个关键应用中发挥的作用。

![二十个问题](img/948eb22e3e1438d4996a99d0fc146a32.png)

## 二分搜索。

在“二十个问题”的游戏中，你的任务是猜测一个秘密数字，该数字是 0 到*n*−1 之间的一个整数。为简单起见，我们假设*n*是 2 的幂，并且问题的形式是“数字是否大于或等于*x*？”

一个有效的策略是维护一个包含秘密数字的区间，猜测区间中间的数字，然后使用答案将区间大小减半。Questions.java 实现了这种策略。这是一个被称为*二分搜索*的一般问题解决方法的示例。

+   *运行时间分析*。由于每次迭代间隔的大小减少了 2 倍（当*n* = 1 时达到基本情况），二分搜索的运行时间是 lg *n*。

+   *线性对数鸿沟*。使用二分搜索的替代方法是猜测 0，然后 1，然后 2，然后 3，依此类推，直到找到秘密数字。我们将这样的算法称为*蛮力*算法：它似乎可以完成任务，但并不太关心成本（这可能会阻止它实际完成大问题的任务）。在最坏情况下，运行时间可能高达*n*。

+   *二进制表示*。如果回顾一下 Binary.java，您会发现二分搜索几乎与将数字转换为二进制的计算相同！每次猜测确定答案的一个位。例如，如果数字是 77，则立即得到答案序列 no yes yes no no yes no，这是 77 的二进制表示。

![二分搜索](img/85f81e045faa537355f64c3a6034cf97.png)

+   *反转递增函数 f(x)*。给定一个值*y*，我们的任务是找到一个值*x*，使得*f*(*x*) = *y*。我们从一个已知包含*x*的区间(*lo*, *hi*)开始，并使用以下递归策略：

    +   计算*mid* = *lo* + (*hi* − *lo*) / 2

    +   基本情况：如果(*hi* − *lo*)小于δ，则将*mid*作为*x*的估计返回

    +   递归步骤：否则，测试*f*(*mid*) > *y*。如果是，就在(*lo*, *mid*)中寻找*x*；如果不是，则在(*mid*, *hi*)中寻找*x*。

    Gaussian.java 中的`inverseCDF()`方法实现了这种策略，用于高斯累积密度函数Φ。在这种情况下，二分搜索通常被称为*二分搜索*。

![有序数组中的二分搜索](img/06533ff45ca9b401b60ba904e35f271e.png)

+   *有序数组中的二分搜索*。二分搜索最重要的用途之一是在有序数组中查找一个项。要做到这一点，查看中间的数组元素。如果包含您正在寻找的项，则完成；否则，从考虑中消除中间元素之前或之后的子数组，并重复。BinarySearch.java 是这种算法的一个实现。

## 插入排序。

插入排序是一种基于人们经常用来整理扑克牌的简单方法的蛮力排序算法：逐个考虑卡片并将每张卡片插入到已考虑的卡片中的适当位置（保持它们排序）。以下代码在一个 Java 方法中模拟了这个过程，用于对数组中的字符串进行排序：

```java
public static void sort(String[] a) {
    int n = a.length;
    for (int i = 1; i < n; i++) {
        for (int j = i; j > 0; j--) {
            if (a[j-1].compareTo(a[j]) > 0)
                exch(a, j, j-1);
            else break;
        }
    }
}

```

在外部`for`循环的每次迭代开始时，数组中的前`i`个元素是按顺序排列的；内部循环通过将`a[i]`与其左侧的每个较大值交换，从右向左移动，直到达到其正确位置，将其移动到数组中的正确位置。这是`i`为`6`时的一个例子：

> ![插入排序迭代](img/c10f35f7a2db838bccc4a8953b9d58fa.png)

这个过程首先执行`i`等于`1`，然后`2`，然后`3`，依此类推，如下面的跟踪所示。

> ![插入排序跟踪](img/bdcdd266d798c0a8e96d6bcc9430f391.png)

+   *运行时间分析*。插入排序代码的内部循环位于双重嵌套的`for`循环中，这表明运行时间是二次的，但由于`break`的存在，我们不能立即得出这个结论。

    +   *最佳情况*。当输入数组已经按排序顺序排列时，总比较次数约为*n*，运行时间为线性。

    +   *最坏情况*。当输入是逆序排序时，比较次数约为~ 1/2 *n*²，运行时间为二次。

    +   *平均情况*。当输入是*随机*排序时，预期的比较次数约为~ 1/4 *n*²，运行时间为二次。

+   *对其他类型数据进行排序*。我们希望能够对所有类型的数据进行排序，而不仅仅是字符串。对于对数组中的对象���行排序，我们只需要假设我们可以比较两个元素，以查看第一个元素是大于、小于还是等于第二个元素。Java 为此提供了[Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)接口。Insertion.java 实现了插入排序，以便对`Comparable`对象的数组进行排序。

+   *经验分析*。InsertionTest.java 测试了我们关于插入排序对于随机排序数组是二次的假设。

## 归并排序。

为了开发更快的排序方法，我们使用*分而治之*的算法设计方法，每个程序员都需要理解。为了*归并排序*一个数组，我们将其分成两半，独立地对这两半进行排序，然后合并结果以对整个数组进行排序。为了对`alo, hi)`进行排序，我们使用以下递归策略：

+   *基本情况*：如果子数组长度为 0 或 1，则已经排序。

+   *归约步骤*：否则，计算`mid = lo + (hi - lo) / 2`，递归地对两个子数组`a[lo, mid)`和`a[mid, hi)`进行排序，并将它们合并以产生排序结果。

> ![归并排序 Merge.java 是这种策略的实现。这里是在合并过程中数组内容的跟踪。> ![归并排序中合并的跟踪](img/44c45bec5bd1dd0c41450bffaf3ebde8.png)

+   *运行时间分析*。在最坏情况下，归并排序进行了约~ 1/2 *n* lg *n*到~ *n* lg *n*次比较，运行时间是线性对数的。有关详细信息，请参阅本书。

+   *二次-线性对数裂缝*。*n*²和*n* lg *n*之间的差异在实际应用中产生了巨大的影响。

+   *分而治之算法*。对于许多重要问题，相同的基本方法都是有效的，如果您学习算法设计课程，您将了解到这一点。

+   *归约到排序*。问题*A* *归约*到问题*B*，如果我们可以使用问题*B*的解决方案来解决问题*A*。例如，考虑确定数组中的元素是否都不同的问题。这个问题归约到排序，因为我们可以对数组进行排序，然后通过排序后的数组进行线性遍历，检查任何条目是否等于下一个条目（如果不是，则元素都不同）。

## 频率计数。

FrequencyCount.java 从标准输入读取一系列字符串，然后按照频率降序打印找到的不同值的表以及每个值被找到的次数。我们通过两次排序来实现这一点。

+   *计算频率。* 我们的第一步是对标准输入中的字符串进行排序。在这种情况下，我们不太关心字符串被排序，而是关心排序将相同的字符串放在一起。如果输入是

    ```java
    to be or not to be to 

    ```

    然后排序的结果是

    ```java
    be be not or to to to 

    ```

    像数组中的三个`to`出现次数相同的字符串一样放在一起。现在，将所有相同的字符串放在数组中，我们可以通过数组进行一次遍历来计算所有的频率。我们在第 3.3 节中考虑过的 Counter.java 数据类型是这项工作的完美工具。

+   *排序频率。* 接下来，我们对`Counter`对象进行排序。我们可以在客户端代码中这样做，无需任何特殊安排，因为`Counter`实现了`Comparable`接口。

+   *齐夫定律。* FrequencyCount.java 中突出显示的应用是基本的语言分析：文本中哪些单词出现频率最高？一种称为[齐夫定律](http://en.wikipedia.org/wiki/Zipf's_law)的现象表明，文本中第*i*个最常见单词的频率与*m*个不同单词的文本成反比。

#### 练习

1.  编写一个过滤器 Dedup.java，从标准输入读取字符串，并打印删除所有重复项的字符串（按排序顺序）到标准输出。

#### 创意练习

*这些练习旨在让您体验开发快速解决方案常见问题的经验。考虑使用二分查找、归并排序��设计自己的分治算法。实现并测试您的算法。*

1.  **整数排序。** 编写一个*线性时间*过滤器 IntegerSort.java，从标准输入读取介于 0 和 99 之间的整数序列，并按排序顺序将相同的整数打印到标准输出。例如，给定输入序列

    ```java
    98 2 3 1 0 0 0 3 98 98 2 2 2 0 0 0 2

    ```

    您的程序应该打印输出序列

    ```java
    0 0 0 0 0 0 1 2 2 2 2 2 3 3 98 98 98

    ```

1.  **三数之和。** 给定一个包含*n*个整数的数组，设计一个算法来确定其中任意三个数是否和为 0。程序的运行时间增长率应为*n*² log *n*。*额外加分*：开发一个能在二次时间内解决问题的程序。

    *解决方案*：ThreeSumDeluxe.java。

1.  **快速排序。** 编写一个递归程序 Quick.java，通过使用前面练习中描述的分区算法作为子程序，对包含`Comparable`对象的数组进行排序：首先，选择一个随机元素 v 作为分区元素。接下来，将数组分成一个包含所有小于 v 的元素的左子数组，一个包含所有等于 v 的元素的中间子数组，一个包含所有大于 v 的元素的右子数组。最后，递归地对左右子数组进行排序。

1.  **反向域。** 编写一个程序从标准输入中读取域名列表，并按排序顺序打印反向域名。例如，`cs.princeton.edu`的反向域是`edu.princeton.cs`。这种计算对于网络日志分析很有用。为此，创建一个实现`Comparable`接口的数据类型 Domain.java，使用反向域名顺序。

1.  **数组中的局部最小值。** 给定一个包含`n`个实数的数组`a[]`，设计一个对数时间算法来找到一个*局部最小值*（一个索引 i，使得`a[i-1] < a[i]`且`a[i] < a[i+1]`）。

    *解决方案*：查询中间值 a[n/2]，以及两个邻居 a[n/2 - 1]和 a[n/2 + 1]。如果 a[n/2]是局部最小值，则停止；否则���较小邻居的一半中搜索。

#### 网页练习

1.  **区间的并集。** 给定实数线上的 N 个区间，在 O(N log N)的时间内确定它们的并集长度。例如，四个区间[1, 3]，[2, 4.5]，[6, 9]和[7, 8]的并集为 6.5。

1.  **咖啡罐问题。** （大卫·格里斯）。假设你有一个咖啡罐，里面装有未知数量的黑豆和未知数量的白豆。重复以下过程，直到只剩下一颗豆：随机从罐中选取两颗豆。如果它们颜色相同，将它们都丢掉，但插入另一颗黑豆。如果它们颜色不同，扔掉黑色的那颗，但返回白色的那颗。证明这个过程以恰好一颗豆结束。根据初始黑白豆数量，你能推断出最后一颗豆的颜色吗？*提示*：找到一个过程中保持不变的有用不变量。

1.  **垃圾邮件活动。** 为了发起非法的垃圾邮件活动，你有一个来自各种域的电子邮件地址列表（电子邮件地址中@符号后面的部分）。为了更好地伪造返回地址，你想从同一域的另一个用户发送电子邮件。例如，你可能想伪造一个从 nobody@princeton.edu 发送到 somebody@princeton.edu 的电子邮件。你如何处理电子邮件列表以使这成为一个高效的任务？

1.  **顺序统计。** 给定一个包含 N 个元素的数组，不一定按升序排列，设计一个算法来找到第 k 个最大的元素。它应该在随机输入上以 O(N)时间运行。

1.  **肯德尔 tau 距离。** 给定两个排列，肯德尔 tau 距离是位置不正确的对数。"冒泡排序度量"。给出一个 O(N log N)算法，计算大小为 N 的两个排列之间的肯德尔 tau 距离。在前 k 个列表、社会选择和投票理论、使用表达谱比较基因以及[排名搜索引擎结果](http://www10.org/cdrom/papers/577/)方面很有用。

1.  **对脚点。** 给定圆上 N 个点，以原点为中心，设计一个算法来确定是否存在两个*对脚*点，即连接这两个点的直线经过原点。你的算法应该在时间上与 N log N 成正比。

1.  **对脚点。** 重复上一个问题，但假设点是按顺时针顺序给出的。你的算法应该在时间上与 N 成正比。

1.  **身份。** 给定一个按升序排列的包含*N*个不同整数（正数或负数）的数组`a[]`。设计一个算法，找到一个索引`i`，使得`a[i] = i`如果这样的索引存在。提示：二分查找。

1.  **L1 范数。** 平面上有 N 个电路元件。你需要沿电路运行一根特殊的线（与 x 轴平行）。每个电路元件必须连接到特殊的线。你应该把特殊的线放在哪里？*提示*：中位数最小化 L1 范数。

1.  **查找共同元素。** 给定两个包含 N 个 64 位整数的数组，设计一个算法来打印出两个列表中出现的所有元素。输出应按排序顺序排列。你的算法应该在 N log N 时间内运行。*提示*：归并排序，归并排序，合并。*备注*：在比较基础模型中，不可能做得比 N log N 更好。

1.  **查找共同元素。** 重复上述练习，但假设第一个数组有 M 个整数，第二个数组有 N 个整数，其��M 远小于 N。给出一个在 N log M 时间内运行的算法。*提示*：排序和二分查找。

1.  **字谜。** 设计一个 O(N log N)算法来读取一个单词列表并打印出所有字谜。例如，字符串"comedian"和"demoniac"是彼此的字谜。假设有 N 个单词，每个单词最多包含 20 个字母。设计一个 O(N²)算法应该不太困难，但将其降至 O(N log N)需要一些巧妙的方法。

1.  **模式识别。** 给定平面上的 N 个点列表，找到所有包含 3 个或更多[共线点](http://www.cs.princeton.edu/courses/archive/spring03/cs226/assignments/lines.html)的子集。

1.  **模式识别。** 给定平面上 N 个点的列表，这些点一般位置（没有三个共线），找到一个新点 p，它与 N 个原始点的任意一对都不共线。

1.  **在排序、旋转列表中搜索。** 给定一个已经旋转了未知次数的 N 个整数的排序列表，例如，15 36 1 7 12 13 14，设计一个 O(log N) 的算法来确定给定整数是否在列表中。

1.  **计算逆序数。** 每个用户按偏好顺序对 N 首歌曲进行排名。给定一个偏好列表，找到偏好最接近的用户。根据逆序数计算“最接近”。为该问题设计一个 N log N 算法。

1.  **从 N 层楼扔猫。** 假设您有一个 N 层楼房和一群猫。假设一只猫被扔到 F 楼或更高处时会死亡，否则会存活。制定一种策略来确定楼层 F，同时杀死 O(log N) 只猫。

1.  **从建筑物中扔猫。** 重复上一个练习，但制定一种杀死 O(log F) 只猫的策略。*提示*：重复加倍和二分查找。

1.  **从 N 层楼房中扔两只猫。** 重复上一个问题，但现在假设您只有两只猫。现在您的目标是最小化扔猫的次数。制定一种策略，在扔猫 O(√N) 次后确定 F（在杀死它们之前）。如果搜索命中（猫在摔下后存活）比未命中（猫死亡）便宜得多，则可能会发生这种情况。

1.  **从建筑物中扔两只猫。** 重复上一个问题，但只扔 O(√F) 只猫。*参考*：???。

1.  **几乎排序。** 给定一个包含 N 个元素的数组，每个元素最多离其目标位置 k 个位置，设计一个在 O(N log k) 时间内排序的算法。

    *解决方案 1：* 将文件分成大小为 k 的 N/k 个片段，并在 O(k log k) 时间内对每个片段进行排序，例如使用归并排序。请注意，这保留了没有元素超出位置 k 个元素的属性。现在，将每个 k 元素块与其左侧的块合并。

    *解决方案 2：* 将前 k 个元素插入二叉堆中。将数组中的下一个元素插入堆中，并删除堆中的最小元素。重复此过程。

1.  **合并 k 个排序列表。** 假设您有 k 个排序列表，共有 N 个元素。给出一个 O(N log k) 的算法，以生成所有 N 个元素的排序列表。

1.  **最长公共反向互补子串。** 给定两个 DNA 字符串，找到出现在一个字符串中的最长子串，其反向沃森-克里克互补出现在另一个字符串中。如果两个字符串 s 和 t 是反向互补的，那么 t 是 s 的反向，除了以下替换 AT，CG。例如 ATTTCGG 和 CCGAAAT 是彼此的反向互补。*提示*：后缀排序。

1.  **循环字符串线性化。** 质粒包含 DNA 在一个圆形分子中而不是线性分子中。为了在 DNA 字符串数据库中进行搜索，我们需要一个断开它以形成线性字符串的地方。一个自然的选择是留下字典序最小的地方。设计一个算法来计算圆形字符串的规范表示*提示*：后缀排序。

1.  **查找所有匹配项。** 给定一个文本字符串，找到查询字符串的*所有*匹配项。*提示*：结合后缀排序和二分查找。

1.  **具有更少内存的最长重复子串。** 不使用后缀数组，其中 suffixes[i] 指的是第 i 个排序后缀，而是维护一个整数数组，使得 index[i] 指的是第 i 个排序后缀的偏移量。要比较由 a = index[i] 和 b = index[j] 表示的子串，比较字符 `s.charAt(a)` 与 `s.charAt(b)`，`s.charAt(a+1)` 与 `s.charAt(b+1)`，依此类推。您节省了多少内存？您的程序更快吗？

1.  **空闲时间。** 假设一个并行机器处理 n 个作业。作业 j 从 s[j] 处理到 t[j]。给定开始和结束时间列表，找到机器空闲的最长时间间隔。找到机器非空闲的最长时间间隔。

1.  **矩阵的局部最小值。** 给定一个 N×N 的 N²个不同整数的数组`a`，设计一个 O(N)算法来找到一个*局部最小值*：一个索引对 i 和 j，使得 a[i][j] < a[i+1][j]，a[i][j] < a[i][j+1]，a[i][j] < a[i-1][j]，以及 a[i][j] < a[i][j-1]。

1.  **单调二维数组。** 给定一个 n×n 的元素数组，使得每行按升序排列，每列也按升序排列，设计一个 O(n)算法来确定数组中给定元素 x。你可以假设 n×n 数组中的所有元素都是不同的。

1.  **二维极大值。** 给定平面上的一组 n 个点，点(xi, yi)支配点(xj, yj)如果 xi > xj 且 yi > yj。极大值是一个不被集合中任何其他点支配的点。设计一个 O(n log n)算法来找到所有极大值。应用：x 轴是空间效率，y 轴是时间效率。极大值是有用的算法。提示：按照 x 坐标升序排序；从右到左扫描，记录迄今为止看到的最高 y 值，并将其标记为极大值。

1.  **复合词。** 从标准输入读取一个单词列表，并打印出所有的双词*复合词*。如果列表中包含`after`、`thought`和`afterthought`，那么`afterthought`就是一个复合词。注意：复合词中的组成部分不一定长度相同。

1.  **史密斯规则。** 在供应链管理中出现了以下问题。你有一堆工作要在一台机器上安排。（给出示例。）工作 j 需要 p[j]单位的处理时间。工作 j 有一个表示其相对重要性的正权重 w[j] - 将其视为存储工作 j 的原材料成本的单位时间。如果工作 j 在时间 t 完成处理，那么它的成本为 t * w[j]美元。目标是安排工作的顺序，以使每个工作的加权完成时间之和最小化。编写一个名为`SmithsRule.java`的程序，它读取一个命令行参数 N 和一个由它们的处理时间 p[j]和权重 w[j]指定的 N 个工作列表，并输出一个最佳的处理工作顺序。*提示：* 使用*史密斯规则*：按照处理时间与权重的比率顺序安排工作。这种贪婪规则被证明是最优的。

1.  **四个质数之和。** 哥德巴赫猜想说，所有大于 2 的正偶数都可以表示为两个质数的和。给定一个输入参数 N（奇数或偶数），将 N 表示为四个质数之和（不一定不同），或报告不可能这样做。为了使你的算法对于大的 N 快速，执行以下步骤：

    1.  使用厄拉托色尼筛法计算小于 N 的所有质数。

    1.  制表一个两个质数之和的列表。

    1.  对列表进行排序。

    1.  检查列表中是否有两个数字相加等于 N。如果是，打印出相应的四个质数。

1.  **打字猴和幂律。** （迈克尔·米岑马赫）假设一个[打字猴](http://www.internetmathematics.org/volumes/1/2/pp226_251.pdf)通过将每个 26 个可能的字母以概率 p 附加到当前单词来创建随机单词，并以概率 1 - 26p 完成单词。编写一个程序来估计生成的单词的频谱。

1.  **打字猴和幂律。** 重复上一个练习，但假设字母 a-z 出现的概率与以下概率成比例，这是英文文本的典型情况。

    | CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | A | 8.04 |  | G | 1.96 |  | L | 4.14 |  | Q | 0.11 |  | V | 0.99 |
    | B | 1.54 |  | H | 5.49 |  | M | 2.53 |  | R | 6.12 |  | W | 1.92 |
    | C | 3.06 |  | I | 7.26 |  | N | 7.09 |  | S | 6.54 |  | X | 0.19 |
    | D | 3.99 |  | J | 0.16 |  | O | 7.60 |  | T | 9.25 |  | Y | 1.73 |
    | E | 12.51 |  | K | 0.67 |  | P | 2.00 |  | U | 2.71 |  | Z | 0.09 |
    | F | 2.30 |  |

1.  **二分查找。** 证明以下修改版本的`binarySearch()`为什么有效。证明如果关键字在数组中，则它正确返回最小索引`i`，使得 a[i] = key；如果关键字不在数组中，则返回-i，其中 i 是使得 a[i] > key 的最小索引。

    ```java
    // precondition array a in ascending order
    public static int binarySearch(long[] a, long key) {
       int bot = -1;
       int top = a.length;
       while (top - bot > 1) {
          int mid = bot + (top - bot) / 2;
          if (key > a[mid]) bot = mid;
          else              top = mid;
       }
       if (a[top] == key) return  top;
       else               return -top - 1;
    } 

    ```

    *答案。* while 循环不变式表示 top >= bot + 2。这意味着 bot < mid < top。因此，每次迭代中间隔的长度严格减小。while 循环还保持不变式：`a[bot] < key <= a[top]`，其中`a[-1]`为负无穷，`a[N]`为正无穷。

1.  **范围搜索。** 给定 2006 年新泽西道路系统中收集的所有通行费的数据库，设计一种方案来回答以下查询形式：提取给定时间间隔内收集的所有通行费的总和。使用一个实现`Comparable`接口的`Toll`数据类型，其中关键是收取通行费的时间。

    *提示*：按时间排序，计算前 i 个通行费的累积和，然后���用二分查找找到所需的间隔。

1.  **最长重复子串。** 修改 LRS.java 以找到*所有*最长重复子串。

1.  **非递归二分查找。** 编写二分查找的非递归版本。

    ```java
    public static int binarySearch(long[] a, long key) {
       int bot = 0;
       int top = a.length - 1;
       while (bot <= top) {
          int mid = bot + (top - bot) / 2;
          if      (key < a[mid]) top = mid - 1;
          else if (key > a[mid]) bot = mid + 1;
          else return mid;
       }
       return -1;
    } 

    ```

1.  **两数之和为 x。** 给定一个排序的 N 个整数列表和一个目标整数 x，在 O(N)时间内确定是否有两个数的和恰好为 x。

    *提示*：维护索引 lo = 0 和 hi = N-1，并计算 a[lo] + a[hi]。如果总和等于 x，则完成；如果总和小于 x，则减少 hi；如果总和大于 x，则增加 lo。如果一个（或多个）整数为 0，请小心。

1.  **单调函数的零点。** 让 f 是一个单调递增函数，其中 f(0) < 0 且 f(N) > 0。找到最小的整数 i，使得 f(i) > 0。设计一个算法，使其对 f()进行 O(log N)次调用。

    *提示*：假设我们知道 N，维护一个区间[lo, hi]，使得 f[lo] < 0 且 f[hi] > 0，并应用二分查找。如果我们不知道 N，重复计算 f(1)，f(2)，f(4)，f(8)，f(16)等，直到找到一个值 N，使得 f(N) > 0。

1.  **双峰最大值。** 让`a[]`是一个开始递增，达到最大值，然后减少的数组。设计一个 O(log N)算法来找到最大值的索引。

1.  **双峰查找。** 如果一个数组由一个递增的整数序列紧接着一个递减的整数序列组成，则它是*双峰*的。给定一个由 N 个不同整数组成的双峰数组`a`，描述如何在 O(log N)步内确定给定整数是否在数组中。提示：找到最大值，然后在每个部分中进行二分查找。

1.  **两个排序数组的中位数。** 给定大小为 N[1]和 N[2]的两个排序数组，以 O(log N)时间找到所有元素的中位数，其中 N = N[1] + N[2]。*提示*：设计一个更通用的算法，找到任何 k 的最大元素。计算两个列表中较大的那个列表的中位数元素；丢弃至少 1/4 的元素并递归。

1.  **元素唯一性。** 给定一个包含 N 个长整数的数组，设计一个 O(N log N)算法来确定是否有任何两个相等。*提示*：排序将相等的值放在一起。

1.  **重复计数。** 给定一个包含 N 个元素的排序数组，可能包含重复项，在 O(log N)时间内找到 k 的第一次和最后一次出现的索引。给定一个包含 N 个元素的排序数组，可能包含重复项，在 O(log N)时间内找到元素 k 的出现次数。*提示*：修改二分查找。

1.  **公共元素。** 编写一个静态方法，该方法以三个字符串数组作为参数，确定是否有任何字符串同时存在于这三个数组中，并如果有，则返回其中一个字符串。您的方法的运行时间应该是总字符串数量的对数线性。

    *提示*：对三个列表进行排序，然后描述如何进行“三路”合并。

1.  **最长重复子串。** 编写一个程序 LRS.java 来找到字符串中最长的重复子串。找出你最喜欢的书中最长的重复子串。

1.  在 LRS.java 中添加代码，使其打印出最长重复子字符串出现的原始字符串中的索引。

1.  **最长公共子串。** 编写一个静态方法，找到给定字符串`s`和`t`的最长公共子串。

    *提示*：对每个字符串进行后缀排序。然后将两个排序后的后缀合并在一起。

1.  **最长重复、不重叠的字符串。** 修改 LRS.java 以找到最长的重复子字符串，*不重叠*。

1.  **押韵的单词。** 编写一个程序 Rhymer.java，制表一个列表，您可以使用该列表找到押韵的单词。使用以下方法：

    +   将一个单词字典读入字符串数组中。

    +   反转每个单词的字母（例如，`confound`变为`dnuofnoc`）。

    +   对结果数组进行排序。

    +   将每个单词中的字母反转回其原始顺序。

    例如，`confound`在结果列表中与`astound`和`surround`等单词相邻。

**排序的科学示例。** 谷歌显示搜索结果按“重要性”降序排列，电子表格显示按特定字段排序的列，Matlab 按对称矩阵的实特征值降序排序。排序也出现在许多看似与排序无关的应用程序中作为关键子程序，包括：数据压缩（参见 Burrows-Wheeler 编程作业）、计算机图形学（凸包、最近对）、计算生物学（下文讨论的最长公共子串）、供应链管理（安排工作以最小化加权完成时间之和）、组合优化（Kruskal 算法）、社会选择和投票（Kendall's tau 距离）。在历史上，排序对商业应用程序最为重要，但排序也在科学计算基础设施中扮演重要角色。[NASA](http://www.nas.nasa.gov/Research/Reports/Techreports/1990/rnr-90-017-abstract.html)和流体力学社区使用排序来研究稀疏流动中的问题；这些碰撞检测问题尤其具有挑战性，因为它们涉及数十亿粒子，并且只能在超级计算机上并行解决。一些快速 N 体模拟代码中也使用类似的排序技术。排序的另一个重要科学应用是平衡并行超级计算机的处理器。科学家依赖巧妙的排序算法在这些系统上执行负载平衡。
