# 9.9 密码学

> 原文：[`introcs.cs.princeton.edu/java/99crypto`](https://introcs.cs.princeton.edu/java/99crypto)

本节正在大力施工中。

**密码学。** *密码学* 是秘密通信的科学。它有两个主要子领域：*密码学* 是创建秘密代码的科学；*密码分析* 是破译代码的科学。密码学有五大支柱：

+   保密性：保持通信私密。

+   完整性：检测通信的未经授权的更改。

+   认证：确认发件人身份。

+   授权：为受信任的方建立访问级别。

+   不可否认性：证明通信已被接收。

我们将主要关注保密性，这些努力中最浪漫的部分。强烈推荐阅读娱乐：《密码本》。有用的 Flash 演示：[e-Security history](http://www.rsasecurity.com/experience/esecurity/index.html) 来自 rsa.com。

**密码学的一些应用。** 菲尔·齐默曼声称“密码学曾经是一门鲜为人知的科学，与日常生活无关。从历史上看，它一直在军事和外交通信中扮演着特殊的角色。但在信息时代，密码学涉及政治权力，特别是政府与人民之间的权力关系。它关乎隐私权，言论自由，政治结社自由，新闻自由，免受不合理搜查的自由，独处的自由。”（《密码本》，第 296 页）。密码学既有利于普通公民，也有利于恐怖分子。促进电子商务。以下是我们希望能够数字化和安全实现的活动表格。我们列出了每个任务的一些日常模拟实现。

| 任务 | 模拟实现 |
| --- | --- |
| 保护信息 | 密码本，锁和钥匙 |
| 识别 | 驾驶执照，社会安全号码，密码，生物信息学，秘密握手 |
| 合同 | 手写签名，公证 |
| 转账 | 硬币，纸币，支票，信用卡 |
| 公开拍卖 | 密封信封 |
| 公开选举 | 匿名投票 |
| 扑克 | 有隐蔽背面的牌 |
| 公开抽奖 | 骰子，硬币，石头剪刀布 |
| 匿名通信 | 匿名，勒索信 |

恶意对手有时可以破坏这些模拟实现：伪造，撬锁，伪造者，作弊者，投票作弊，偷骰子。

**我们的目标。** 我们的目标是数字化和安全地实现所有这些任务。我们还希望实现一些物理上无法完成的额外任务！例如：玩一种扑克变体，庄家赢得比赛如果没有人有一张 A 牌，进行一个匿名选举，每个人都知道赢家，但其他什么都不知道。这些是否有可能？如果是，如何实现？在本节的其余部分，我们将介绍现代（数字）密码学的风味，实现其中一些任务，并勾勒一些技术细节。

**历史。** 解密玛丽·斯图尔特的加密信件揭示了她暗杀伊丽莎白一世的意图。在 19 世纪，埃德加·爱伦·坡自夸可���通过频率分析破解任何人的密码。艾伦·图灵领导了布莱切利园的一个团队，破解了德国恩尼格玛密码机。许多历史学家认为这是第二次世界大战的转折点。这里有一个[恩尼格玛小程序](http://russells.freeshell.org/enigma)。

**安全性通过混淆实现。** 内容加密系统（CSS）被好莱坞用于加密 DVD。每张光盘有三个 40 位密钥。每个 DVD 解码器有唯一的 40 位密钥。原则上，在没有光盘的情况下在计算机上播放是“不可能的”。1999 年，两名挪威人（Canman 和 SoupaFrog，1999）编写了一个破解 CSS 系统的解密算法。CSS 是一种专有算法，好莱坞赌注于没有人会发现这个算法。此外，密钥的大小太小，因此可以进行穷举攻击。由于临时方法导致的其他高调失败：GSM 手机，Windows XP 产品激活，RIAA 数字音乐水印，VCR+代码，Adobe 电子书，Diebold AccuVote-TS 电子投票机，[埃克森美孚 SpeedPass RFIDs](http://rfidanalysis.org/)。

1883 年，荷兰语言学家[Auguste Kerckhoffs von Nieuwenhof](http://en.wikipedia.org/wiki/Auguste_Kerckhoffs)在他的论文[Cryptographie militaire](http://www.petitcolas.net/fabien/kerckhoffs/la_cryptographie_militaire_i.htm)中体现了指导现代密码学的基本原则。

> Il faut qu'il n'exige pas le secret, et qu'il puisse sans inconvenient tomber entre les mains de l'ennemi.
> 
> 系统不应该要求保密，可以被敌人窃取而不会造成麻烦。

这现在被称为*Kerckhoffs' Principle*。一个加密系统的安全性不应该依赖于保密算法，而只应该依赖于保密数字密钥。算法和数字密钥之间有两个主要区别。([Ed Felten](http://www.freedom-to-tinker.com/archives/2004_09.html)) 首先，由于我们随机生成数字密钥，我们可以准确地建模和量化对手猜测所需的时间（在一般技术条件下）；相比之下，预测或量化对手猜测我们的算法需要更多的努力。其次，对于不同的目的或人员，使用不同的数字密钥很容易，或者停止使用已被泄露的密钥；设计新算法更加困难。

它说基于“安全性通过混淆”的系统存在致命缺陷。这等同于香农的格言是“敌人知道系统。”设计安全系统应该留给专家。尽管如此，我们仍然可以探索专家使用的密码学基本思想。

**参与者。** 与密码学家丰富的传统一致，Alice 和 Bob 是两个试图在不安全的通信渠道上进行安全通信的人。我们假设消息已经以二进制编码，因此我们可以将其视为一个（可能很大的）整数*m*。我们让*N*表示消息*m*中的位数。Alice 将加密函数*E*应用于消息，产生另一个*N*位整数*E(m)*。Bob 收到*E(m)*并对其应用解密函数*D*。这个方案有意义的一个明显条件是*D(E(m)) = m*。换句话说，Bob 恢复了原始消息。Eve 是希望拦截消息的第三方。Eve 可以观察*E(m)*，因此为了使方案安全，Eve 应该从*E(m)*中单独恢复*m*应该是极其困难的。

**私钥加密。** 私钥 = 两个参与方在通信之前共享一个秘密密钥。一次性密码本（第一章）如果密钥中的位是从真正随机的来源生成的，则可以被证明是安全的。它也非常容易实现。然而，一次性密码本有几个减轻因素，使其在大多数情况下变得不切实际。首先，生成真正随机、没有偏见和相关性的位是一个挑战。必须走出数字计算机的世界，从某种物理来源提取它们（例如，由于放射性衰变而发射的粒子之间的时间、麦克风的声音、按键之间的经过时间）。这些来源通常是有偏见的，我们需要非常小心地防止伊夫观察或篡改过程。该方案被称为一次性，因为我们需要为每条消息或消息的一部分生成新密钥。如果我们重复使用一次性密码本，那么系统将不再安全。签名？不可否认？也许最具限制性的因素是密钥分发。爱丽丝和鲍勃必须相互认识并交换密钥发送秘密消息。克里姆林宫和白宫曾经使用这种方法相互通信。一个受信任的信使将被派遣穿越大西洋，手铐着一次性密码本的公文包。如果爱丽丝想要通过互联网从鲍勃购买产品，这种方法是荒谬的不切实际的。

其他私钥加密方案。数据加密标准（DES）。高级加密标准（AES，Rijndael 算法）。Blowfish。这些方法不像一次性密码本那样可以被证明是安全的，但经受住了数学审查的时间考验。高效。然而，这些方案遭受了困扰一次性密码本的相同密钥分发问题。解决密钥分发问题的一种新兴方法是使用量子力学。这被称为量子密钥分发。这是两个参与方分享一次性密码的一种无条件安全的方式。此外，还有入侵检测组件，因此如果伊夫观察到甚至一个位，双方都将了解到试图窃听。

**现代密码学。** 现代密码学理论利用了困难问题的理论。目标是表明破解安全系统等同于解决一些世界上最伟大的未解决问题！著名的电子安全专家布鲁斯·施奈尔在《应用密码学》中写道：“仅仅依靠法律保护自己是不够的，我们需要用数学来保护自己。”现代密码学的基础依赖于三个关键公理和一个重要事实。

+   *公理 1\. 参与方可以抛硬币。* 没有随机性，密码学是不可能的，因此这个公理是必不可少的。在实践中，我们可以通过使用量子现象或粒子的放射性衰变来生成真正随机的位。

+   *公理 2\. 参与方在计算上受限。* 我们通过限制参与者（通信各方和恶意对手）只使用多项式时间算法来正式表达这个概念。

+   *公理 3\. 因子分解在计算上很困难。* 我们假设在 N 位整数中不可能在 N 的多项式时间内分解出因子。给定一个整数（例如，1541），找到其素数分解似乎很困难。然而，给定因子（例如，23 * 67），很容易将它们相乘并获得原始数字。这被称为“一种单向陷阱函数”，因为从因子到乘积的方向很容易（从乘积到因子的方向似乎很困难）。

+   *事实。素性测试在计算上很容易。* 米勒-拉宾素性测试算法。2002 年证明了 PRIMES in P。

如果上述三个公理有效，则数字密码学存在。也就是说，可以通过数字方式完成以前的所有任务。

**公钥密码学.** 公钥密码学是一种令人惊奇的方案，使两方能够安全地通信，即使他们从未见过面。这是数字化的带有组合锁的盒子的类比。假设 Alice 想要向 Bob 发送一条消息。首先，Bob 将带有开放位置的挂锁的盒子发送给 Alice，而不向任何人透露组合。Alice 将她的消息放在盒子里，关闭组合锁，然后将其发送回 Bob。Eve 可能在传输过程中拦截盒子，但由于她不知道组合，她无法打开它。她可以尝试猜测组合，但可能性太多了。当盒子到达时，Bob 可以打开它，知道没有其他人看过里面（除非他们知道组合）。

Bob 在数字上有两个密钥（或组合）：他的私钥 d 不向任何人透露，他的公钥 e 在互联网电话簿中公布。我们将密钥视为整数，但实际上它们只是一系列位，比如 1024 位。如果 Alice 想要向 Bob 发送一条消息，她在互联网上查找 Bob 的公钥 e。她使用 e 加密她的消息并将其发送给 Bob。Bob 使用他的私钥 d 解密消息。

公钥密码学的概念最早是由 Whitfield Diffie 和 Martin Hellman 在他们开创性的论文*密码学的新方向*中于 1976 年首次发表的。这篇论文描述了用于密钥分发问题的公钥加密系统。这个想法显然是由英国政府通信总部（GCHQ）的 Ellis、Cocks 和 Williamson 在 20 世纪 70 年代早期独立发现的，但他们的工作保密了两十年。

## RSA 加密系统。

我们将描述 1978 年 Adleman、Rivest 和 Shamir 开发的[RSA 加密系统](http://www.acm.org/turingawardlecture/RSA/)的基本机制。这里是 RSA 论文。RSA 今天被广泛用于安全的互联网通信（浏览器，S/MIME，SSL，S/WAN，PGP，Microsoft Outlook），操作系统（Sun，Microsoft，Apple，Novell）和硬件（手机，ATM 机，无线以太网卡，Mondex 智能卡，Palm Pilots）。然后，我们将解释为什么它有效以及如何高效实现它。RSA 加密系统涉及模运算。回想一下......

*密钥生成.* 要参与 RSA 加密系统，Bob 必须首先生成公钥和私钥。即使他打算多次使用该系统，他也只需要这样做一次。

+   随机选择两个大素数 p 和 q。

+   计算 n = p × q。

+   选择两个整数 e 和 d，使得对所有整数 m 都有(m^e)^d ≡ m (mod n)。

举例来说，我们可能选择以下参数，尽管在实践中我们需要使用更大的整数来保证安全性。

```
p = 11, q = 29
n = 11 * 29 = 319
e = 3
d = 187

```

*加密.* Alice 想要向 Bob 发送一个 N 位的秘密消息 m。她从互联网上获取 Bob 的公钥（e，n）。然后她使用加密函数 E(m) = m^e (mod n)加密消息 m，并将 E(m)发送给 Bob。

```
m    = 100
E(m) = 1003 (mod 319) 
     = 254

```

*解密.* Bob 从 Alice 那里收到加密消息 c。Bob 回忆起他的私钥（d，n）。然后他通过应用解密函数 D(c) = c^d (mod n)来解密密文。由于 Bob 知道 d，他可以计算这个函数。

```
c    = 254
D(c) = 254187 (mod 319) = 100

```

*RSA 模拟器.* [RSA 模拟器](http://www-cs-students.stanford.edu/~tjw/jsbn/rsa2.html).

*正确性.* 为了确保 Bob 接收到原始消息，我们必须检查 D(E(m)) = m。在上面的例子中，当 m = 100 时，E(100) = 254，D(254) = 100，但我们需要确保它适用于所有可能的消息，以及所有有效的 e、d 和 n 的选择。这可以直接从定义和我们选择 e 和 d 的方式得出。

![](img/7efd53405c873dd97ddef65722d1d4ff.png)

我们省略了一个重要的细节 - 如何选择 e 和 d，以使魔术属性成立。

**实现 RSA 加密系统。** 实现 RSA 加密系统是一个艰巨的工程挑战。成功的实现需要许多巧妙的算法和对数论中几个定理的了解。我们将描述一个基本的实现，但商业实现更加复杂。

+   *大整数*。不能使用内置的`int`或`long`类型，因为数字太大。需要重新实现算术法则，例如加法、减法、乘法和除法。小学的算法对所有这些操作都相当有效，尽管总是有机会使用聪明的算法来改进。

+   *模指数*。如何执行模指数运算：a^b (mod c)。朴素的方法是重复地将 a 乘以自身，b 次，然后除以 c 并返回余数。当 a、b 和 c 是 N 位整数时，这种方法会因为两个原因而失败。首先，中间数 a^b 可能非常大。数字的位数可能是 N 的指数。当 N = 50 时，这将消耗 128TB 内存。第二个问题是乘法的次数也需要指数时间。因此，这将永远持续下去。

    更好的选择是使用*重复平方*。这个想法可以追溯到至少公元前 200 年，据 Knuth 称。程序 ModExp.java 使用以下递归计算 a^b mod n：

    1.  如果 b 是零：1

    1.  如果 b 是偶数：(a^(b/2) * a^(b/2)) mod n

    1.  如果 b 是奇数：(a * a^(b/2) * a^(b/2)) mod n 这类似于乘法的以下递归。

    1.  如果 b 是零：1

    1.  如果 b 是偶数：(a * b/2) + (a * b/2)

    1.  如果 b 是奇数：(a * b/2) + (a * b/2) + a

+   *计算一个随机质数*。为了生成密钥，我们必须有一个生成随机 N 位质数的方法，比���N = 1024。一个想法是随机选择一个 N 位整数并检查它是否是质数。如果是，那么停止；否则重复，直到找到一个质数。

    ```
    REPEAT
        x = random N-bit integer
    UNTIL (x is prime)

    ```

    这个简单的想法有效，但要实现它需要两个关键的想法。首先，如果没有足够的质数，循环可能需要很长时间。幸运的是，素数定理（Hadamard，Vallee Poussin，1896）断言 2 到 x 之间的质数大约是 x / ln x。有超过 10¹⁵¹个 512 位或更少的质数。换句话说，大约每 ln x 个 x 位数中有一个是质数，因此我们期望在偶然发现一个质数之前只需 ln x 步。但是我们如何检查一个数是否是质数呢？试图对其进行因式分解将是代价高昂的。相反，我们可以使用 Miller-Rabin（或更近期的 Agarwal-Kayal-Saxena）的巧妙算法，在多项式步骤内检查一个整数是否为质数。

+   *生成随机数*。（移到一次性密码？）物理随机源。Java 库`SecureRandom`是一个生成*密码安全*随机数的伪随机数生成器。这意味着计算未来位是困难的。与 LFSR 不同，你无法逆向工程它。

+   *计算私钥指数*。最后一个挑战是选择公钥和私钥。在实践中，通常使用 e = 65,537 作为公钥。但这意味着我们需要找到一个使魔术属性成立的私钥。这事实上是一个在数论中被充分理解的问题，只要 gcd(e, (p-1)(q-1)) = 1，就会存在一个唯一的 d。我们可以使用 Euclid 算法的扩展（参见练习 xyz）来实现这个目的。

    使用 Java 的`BigInteger`库来操作大整数非常容易。

    ```
    private final static SecureRandom random = new SecureRandom();
    BigInteger ONE = new BigInteger("1");
    BigInteger p   = BigInteger.probablePrime(N/2, random);
    BigInteger q   = BigInteger.probablePrime(N/2, random);
    BigInteger n   = p.multiply(q);
    BigInteger phi = (p.subtract(ONE)).multiply(q.subtract(ONE));
    BigInteger e   = new BigInteger("65537");
    BigInteger d   = e.modInverse(phi);

    BigInteger rsa(BigInteger a, BigInteger b, BigInteger c) {
        return a.modPow(b, n);
    }

    ```

**RSA 攻击。** 密码分析是破解秘密代码的科学。我们描述了一些常见的 RSA 加密系统攻击，以让您了解现代密码分析的风格。

+   *分解。* 破解 RSA 加密系统最明显的方法是分解模数 n。如果 Eve 能够分解 n = pq，那么她拥有与 Bob 完全相同的信息，因此她可以有效地计算出他的私有指数，给定公共指数（使用 Bob 用来计算私有指数的算法）。使用一个非常复杂的分解算法，即[一般数域筛](http://mathworld.wolfram.com/NumberFieldSieve.html)，研究人员最近成功地[分解了 RSA-576](http://www.rsasecurity.com/company/news/releases/pr.asp?doc_id=3520)，这是 RSA 安全性提供的一个挑战问题，一个 576 位（174 位十进制数字）的复合整数。这个工作需要 100 台工作站和 3 个月的计算。该算法的运行时间是超多项式但是次指数的 - O(exp(c (log n)^(1/3) (log log n)^(2/3)))。

+   *不当使用。* 如果 RSA 系统被不当使用，也会被破解。例如，如果 Bob 决定使用一个小的*私有*指数来减轻解密的计算负担，那么他就在牺牲安全性。如果 d < 1/3 n^(1/4)，那么可以在多项式时间内恢复 d（Wiener 攻击）。请注意，使用一个小的公共指数 e 是可以的，在实践中，65,537 是常见的。另一个错误是允许两个参与者共享相同的模数 n（即使双方都不知道如何分解 n）。例如，假设 Bob 和 Ben 分别拥有（d1，e1）和（d2，e2）作为他们的私有和公共指数，但他们都使用 n 作为模数。那么任何一方都有可能发现另一方的私有指数（Simmon's 攻击）。

+   *侧信道攻击。* 利用从机器泄露的物理信息，包括电磁辐射、功耗、CRT 显示器的漫射可见光和声学辐射。例如，在一个*时序攻击*中，Eve 通过测量 Bob 进行指数运算所需的时间来获取关于 Bob 的私有密钥的信息。如果 Bob 使用高度优化的指数运算例程，那么 Eve 可以发现足够的信息来揭示 Bob 的私有密钥。��近，Dan Boneh 展示了如何利用这种技术来在局域网上破解 SSL。

一个长期存在的开放研究问题是是否有一种方法可以在不分解或物理访问的情况下破解 RSA 系统。即使分解很困难，也不能保证 RSA 是安全的。此外，目前也没有关于分解很困难的数学保证！FACTOR 及其补充问题 NON-FACTOR 都在 NP 中。这使得 FACTOR 是 NP 完全的可能性很小，因为这将意味着 NP = coNP...

**语义安全。** 其他更强的安全概念。如果一个公钥加密系统是*语义安全*的，那么 Eve 可以在多项式时间内计算出密文中的任何内容，而无需密文。因此，观察密文不提供任何有用的信息。例如，我们不应该能够确定明文的最后一位是 0 还是 1，或者明文中 1 的位数是否比 0 多。RSA 系统不是语义安全的，实际上没有确定性方案可以实现。这不仅仅是一个理论上的缺陷。为了理解为什么，假设 Eve 知道 Alice 将向 Bob 发送 `ATTACK` 或 `RETREAT` 消息。Eve 可以使用 Bob 的公钥加密两条消息，然后与 Alice 发送给 Bob 的加密消息进行比较。因此，Alice 可以准确地了解发送了哪条消息。像在加密前附加一串随机的 0 和 1 到明文这样的天真想法通常不能保证额外的安全性。

**可证明安全的加密系统。** 使用一个不像某些困难问题（例如因子分解）那样难以证明的加密系统有点令人不满。理论高地=Blum-Goldwasser（1985）。与因子分解同样难度，语义安全。基于 Goldwasser 和 Micali 的概率加密方案。在速度上与 RSA 可比。

**电子投票。** 需要一种加密方案，使得可以确认你的选票被正确计算，而不透露你的选票给谁。需要第二个条件来防止某人“购买”你的选票，因为如果他们无法验证你投给谁，他们就没有贿赂你的动机。

**零知识证明。** Alice 想向 Bob 证明图 G 是 3 可着色的，但不想透露任何额外信息。这个例子可以推广到许多其他问题，因为 3Color 是 NP 完全的。

**数字版权管理。** 在传统设置中，试图进行通信的 Alice、Bob 和 Eve 是人类，他们使用计算机辅助计算。一个有趣的变体是当 Alice 和 Bob 是计算机，而 Eve 是人类。这正是音乐行业设想的数字版权管理的情景。在这种情况下，Alice 是你的计算机，Bob 是你的扬声器，而你是 Eve。音乐行业希望只有你的计算机能够在你的计算机上播放合法购买的音乐，但不希望你能够拦截原始音频数据。我们很快可以想象到一个世界，在那里对复制 DVD、运行软件、打印文件和转发电子邮件都有限制。所有这些限制将通过加密算法和协议执行。

目标：将一个程序转换为计算相同函数的混淆版本，但不向多项式有界的对手透露任何额外信息（例如源代码）。通常情况下无法混淆。

**安全。** 密码学只是整体计算机安全的一部分。这项[调查](http://news.bbc.co.uk/1/hi/technology/3639679.stm)显示，70%的人会为了一块巧克力棒而透露他们的计算机密码。一位安全专家评论说，“在互联网上使用加密相当于安排一辆装甲车将信用卡信息从一个住在纸箱里的人送到一个住在公园长椅上的人。”

**CAPTCHAs。** 完全自动化的公共图灵测试，用于区分计算机和人类。反向图灵测试，其中计算机是判官，试图区分人类和计算机。[纽约时报文章](http://www.nytimes.com/2002/12/10/science/physical/10COMP.html)。

#### 问答

#### 练习

1.  编写一个程序来经验性地确定方法`BigInteger.add`、`BigInteger.multiply`、`BigInteger.mod`和`BigInteger.modExp`的运行时间。尝试将每个操作的运行时间建模为 c N^k 秒，其中 c 和 k 是一些常数。使用`BigInteger.rand`生成随机输入参数。对于加法、乘法和模指数运算，对所有参数使用 N 位整数；对于除法，使用 N 位分子和 N/2 位分母。

1.  编写一个程序 RandomPrime.java，该程序接受一个命令行参数 N，并打印出一个（可能）是素数的 N 位整数。使用`BigInteger.probablePrime`进行素性测试，并使用`SecureRandom`生成密码安全的伪随机数。

1.  估计 RandomPrime.java 的运行时间作为位数 N 的函数。

1.  假设不使用`RandomPrime.java`来选择具有 N 位的素数，而是使用以下策略：生成所有最多具有 N 位的素数，并选择一个随机素数。如果 N 很大，比如 512，会发生什么？

1.  假设不使用重复平方来计算 a^b mod c，而是将 a 重复乘以自身 b 次，同时取模 c。估计当 a、b 和 c 都是 N 位整数时需要多长时间。

1.  以下问题的复杂度是多少：给定一个偶数 x，确定 x 是否有大于 1 的奇数因子。答案：多项式 - 检查 x 是否是 2 的幂。

1.  以下问题的复杂度是多少：给定一个偶数 x 和另一个整数 y，确定 x 是否在 3 和 y 之间有任何奇数因子。答案：等同于因式分解问题。

#### 创意练习

1.  **扩展欧几里得算法。** 扩展欧几里得算法用于计算 p 和 q 的最大公约数，还可以计算系数 a 和 b（可能为零或负），使得 ap + bq = gcd(p, q)。编写一个程序 ExtendedEuclid.java，接受两个命令行参数 p 和 q，并输出 gcd(p, q)以及如上所述的一对整数 a 和 b。

    ```
    EXTENDED-EUCLID(p, q)
       if q = 0
          then return (p, 1, 0)
       (d', a', b') return (d, x, y)

    ```

    提示：由于你的方法需要返回三个整数，考虑使用一个三元素数组。

1.  **最佳矩形。** 给定矩形的面积 A，找到一个宽度和高度为整数的矩形，其面积为 A，并且高度和宽度之间的差距尽可能接近。例如，如果 A = 48，则最佳矩形是 6 乘以 8 而不是 3 乘以 16 或 4 乘以 12。证明如果你能解决这个问题，你就能破解 RSA 加密系统。

1.  **水桶问题。** 给定容量为 p 和 q 的两个桶，一个无限容量的接收器，一个水管和一个排水口，设计一种方法，使用以下规则将恰好 k 升水倒入接收器中：

    +   你可以用水管装满任一桶。

    +   你可以将任一桶倒空到排水口。

    +   你可以在两个桶之间或一个桶和接收器之间转移水，直到一个满了或另一个空了。证明当且仅当 k 是 gcd(p, q)的倍数时，你才能解决这个问题。提示：使用前一个练习中存在整数 a 和 b 使得 ap + bq = gcd(p, q)的事实。

1.  **乘法逆元。** 给定正整数 n，整数 k 的*模 b 的乘法逆元*是一个整数 x，使得(k * x) % n = 1。这样的逆元存在当且仅当 gcd(k, n) = 1。���写一个程序 Inverse.java，读取两个命令行参数 k 和 n，并计算模逆元（如果存在）。*提示：*使用前一个练习的答案。另请参阅`BigInteger.modInverse`。

1.  **破解 RSA 加密系统。** 破解 RSA 加密系统的一个潜在方法是在给定 n 的情况下计算φ(n)。回想一下，如果 n = pq，那么φ(n) = (p-1)(q-1)。证明计算φ(n)等同于因式分解。

    *解决方案*：显然，如果你能分解 n = pq，那么计算φ(n) = (p-1)(q-1)就很容易。要看到另一个方向，观察者可以发现 n + 1 - φ(n) = pq + 1 - (p-1)(q-1) = p + q = n/q + q。因此 q² - (n + 1 - φ(n))q + n = 0。假设我们知道φ(n)，我们可以解二次方程得到 q，并恢复 n 的一个因子。通过计算 n/q，我们可以恢复另一个因子 p。

1.  **生成公钥和私钥 RSA 密钥。** 编写一个程序 RSA.java 来生成用于 RSA 加密系统的密钥对，确定两个 N/2 位素数 p 和 q。设置 e = 65537，计算 n = (p-1)(q-1)，找到一个数字 d，使得(e * d) % n == 0。假设 gcd(e, n) = 1，逆 d 将存在。*提示：*使用 RandomPrime.java 来计算 p 和 q，使用 Inverse.java 来计算 d。

1.  **Sophie Germaine 素数。** 如果你使用特殊类型的素数 p 和 q，RSA 加密系统的安全性似乎会得到改善。具体来说，[Sophie Germaine 素数](http://www.wikipedia.org/wiki/Sophie_Germain_prime)是一个素数 p，其中(p-1)/2 也是素数。生成一个公钥和私钥 RSA 密钥，其中 p 和 q 是 Sophie Germaine 素数。调查找到这样一个素数所需的时间与位数 N 的函数关系。

1.  **费马素性测试。** 费马素性测试是一种算法，接受一个奇数整数 n，并报告它绝对是合数或“可能”是素数。通过“可能”，该算法有时会出错，但不会太频繁。费马定理表明，如果 p 是素数且 gcd(a, p) = 1，则 a^(p-1) ≡ 1 (mod p)。PGP 加密系统中使用的一个版本的逆定理作为粗略的素性测试：如果 2^(p-1) ≡ 3^(p-1) ≡ 5^(p-1) ≡ 7^(p-1) ≡ 1 (mod p)，则使用 p 作为素数。不幸的是，有一些数字满足这个费马测试，但不是素数（例如 29341、46657、75361）。

1.  **米勒-拉宾素性测试。** 米勒-拉宾算法是一种用于确定奇数整数 n 是否为素数的随机算法。它接受一个安全参数 t，并输出`prime`或`composite`。如果输出`composite`，则 n 绝对是合数；如果输出`prime`，则 n 可能是素数，但算法可能以 2^(-t)的概率错误。

    ```
    boolean isProbablyPrime(BigInteger n, int t) {
       Compute r and s such that n-1 = 2sr and r is odd
       Repeat from 1 to t {
          Choose a random integer a such that 1 < a < n - 1 
          Compute y = ar mod n by repeated squaring
          If y ≠ 1 and y ≠ n-1 {
             j = 1 
             while (j < s and y ≠ n-1)
                y = y2 mod n 
                if (y == 1) return false
                j = j + 1
             if y ≠ n-1 return false
       }
       return true
    }

    ```

1.  **因式分解。** 从[RSA Security](http://www.rsasecurity.com/rsalabs/challenges/factoring)赢得 20 万美元，用于分解一个 2048 位数（616 位）。使用程序 xyz 在一分钟内分解一个 64 位数（32 位 RSA）。分解一个 128 位数需要多长时间？

1.  **波拉德的ρ方法。** 波拉德的ρ方法是一种随机因式分解算法，可以在合理的时间内分解 128 位数，特别是如果这些数有一些小因子的话。它基于以下事实：如果 d 是 N 的最小非平凡因子，而 x - y 是 d 的非平凡倍数，则 gcd(x-y, N) = d。一种朴素的方法是生成一堆随机值 x[1]、x[2]、...、x[m]，并计算所有 i 和 j 对的 gcd(x[i]-x[j], N)。[波拉德的ρ方法](http://planetmath.org/encyclopedia/PollardsRhoFactorization.html)是一种巧妙的方法，可以找到 x 和 y，而不必进行所有成对的计算。它的工作原理如下：随机选择 a 和 b 在 1 和 N-1 之间，并初始化 x = y = a。重复更新 x = f(x)，y = f(f(y))，其中 f(x) = x² + b，只要 gcd(x-y, N) = 1。gcd 是 N 的一个因子，但如果你运气不好，它可能等于 N。通过每次随机选择 a 和 b，我们确保我们永远不会太不幸。编写一个程序 PollardRho.java，它接受一个命令行参数 N，并使用波拉德ρ方法计算 N 的素因子分解。估计运行时间作为 N 的函数。

1.  **费特-汤普森猜想。** 反驳[费特-汤普森猜想](http://mathworld.wolfram.com/Feit-ThompsonConjecture.html)：不存在两个素数 p 和 q，使得(p^q - 1) / (p - 1)和(q^p - 1) / (q - 1)有除 1 以外的公因数。反例：(17, 3313)，公因数为 112643。

1.  **卡拉兹巴乘法。** 编写一个程序 Karatsuba.java，使用[卡拉兹巴算法](http://mathworld.wolfram.com/KaratsubaMultiplication.html)来计算两个整数的乘积。这种巧妙的算法仅使用三次 N 位乘法（以及线性量的额外工作）来计算两个 2N 位整数的乘积。要将 x 和 y 相乘，将 x 和 y 分解为 N 位块，并使用以下等式：

    ```
    xy = (a + 2Nb) (c + 2N d)
       = ac + [(a+b)(c+d) - ac - bd] 2N + bd 22N

    ```

    你的递归算法应该计算位数 N 的数量，并在 N 较小时（比如 10000）将截止值设为默认的`BigInteger.multiply`方法，并在 N 较大时应用 Karatsuba 分治策略。调查最佳截止点，并比较其在 N = 1000 万时与`BigInteger.multiply`的有效性。

1.  **因式分解归结为找到一个因子。** 给定一个函数`factor(N)`，如果 N 是素数则返回 1，否则返回 N 的任何非平凡因子，编写一个函数`factorize(N)`，返回 N 的素因子分解。

1.  **完全幂。** 如果存在两个整数 p ≥ 2 和 q ≥ 2，使得 N = p^q，则整数 N 是完全幂。设计一个高效的算法（与 N 中位数的位数成多项式关系）来确定 N 是否是完全幂，如果是的话，找到其质因数分解。*提示*：对于所有 q ≤ lg N，二进制搜索满足 N = p^q 的 p。

1.  **欧拉猜想。** 在 1769 年，欧拉猜想不存在正整数解使得 a⁴ + b⁴ + c⁴ = d⁴。218 年后，Noam Elkies 发现了第一个反例 2682440⁴ + 15365639⁴ + 18796760⁴ = 20615673⁴。编写一个程序 Euler.java 来证明欧拉的猜想是错误的。在练习 XYZ 中概述的蛮力解决方案不会奏效，原因有两点：（i）使用四重嵌套循环找到解决方案需要太长时间，（ii）计算 a⁴ 会导致 `long` 溢出，因为最小的这种反例是 95800⁴ + 217519⁴ + 414560⁴ = 422481⁴。

    1.  使用以下思路。遍历 1 到 N 之间的所有整数 a 和 b，并将 a⁴ + b⁴ 插入哈希表中。然后，遍历 1 到 N 之间的所有整数 c 和 d，并搜索以查看 d⁴ - c⁴ 是否在哈希表中。使用扩展精度整数以避免溢出。

    1.  使用扩展精度整数可能会比使用原始类型产生显著的开销。不要将 a⁴ + b⁴ 插入哈希表中，而是插入 a⁴ + b⁴ 模 p，其中 p 是某个大素数，比如 XYZ。然后，遍历所有 c 和 d，并搜索 d⁴ - c⁴ 模 p。如果有匹配项，使用扩展精度算术来检查它不仅仅是一个巧合的碰撞。提示：在计算 a⁴ + b⁴ 模 p 时，每次乘法后都要取出 p 的倍数以避免溢出。

1.  **指纹识别。** Alice 和 Bob 在不同地点维护着一个大基因组数据库的两份副本。为了保持一致性，他们希望能够比较这两个数据库是否相同。我们将数据库解释为 N 位整数，称为 A 和 B。由于 N 非常大，他们无法承担传输整个数据库的成本。相反，考虑以下方案发送数据的 *指纹*，使得 Alice 和 Bob 能够检查数据是否不一致。Alice 生成一个介于 2 和 N² 之间的随机素数 p，并发送 p 和 (A % p)。这只需要 O(log N) 位。Bob 声明如果 ((A % p) == (B % p))，则 A 和 B 相同。该方案产生错误否定（应该是是的否定）的概率为零。证明随着 n 趋近无穷大，错误肯定（应该是否定的是）的概率趋近于 0。*提示*：利用小于 n² 的素数数量至少为 c n² / log n，其中 c > 0 是一个常数。发送了多少位？

1.  **通过电话翻转硬币。** Alice 和 Bob 正处于一场激烈的离婚中。他们决定翻一枚硬币来决定谁将获得他们唯一儿子 Carl 的监护权。然而，他们拒绝亲自见面，也不希望任何其他人知道他们如何解决监护权纠纷。换句话说，我们希望设计一种方法，在电话线或互联网上公平地翻转一枚硬币，以便任何一方都无法作弊。以下是一个优雅的协议：

    1.  Alice 将两个或三个大素数相乘，将乘积 N 发送给 Bob。

    1.  Bob 收到整数 N，并回答数字 2 或 3。

    1.  Alice 等待 Bob 的有效回应，然后向 Bob 发送 N 的质因数分解。

    1.  如果 Bob 猜对了因子的数量，那么他获得监护权。否则，假设 Alice 遵循协议，她将赢得监护权。

    通过回答以下每个问题来解释系统为什么有效。您可以假设没有有效的方法来确定给定整数 N 是否至少有 3 个非平凡因子（尽管这是一个未解决的猜想）。

    1.  Alice 如何高效地计算 N？

    1.  为什么 Bob 不能有效地独自确定真实答案？

    1.  Bob 如何有效地检查 Alice 是否发送了正确的 N 的因数分解？换句话说，防止 Alice 在 Bob 说 3 时透露两个因数（其中一个不是质数），即使她将三个（或更多）质数相乘在一起。

1.  **电话上的扑克牌。** 使用上面描述的*比特承诺*方案开发一个在电话上玩扑克牌的协议，比如在两个当事方之间。

1.  **离散对数。** 设*p*为一个素数。*a*对于基数*b*的*离散对数*是唯一的整数*x*，满足 0 到*p*-1 之间的条件，使得*a = b^x (mod p)*。例如，如果*p* = 97，*b* = 5，*a* = 35，那么 log[5] 35 = 32，因为 5³² = 35 (mod 97)。编写一个名为`DiscreteLog.java`的程序，通过蛮力搜索，接受三个命令行输入 a、b 和 p，并计算模 p 下的*log[b] a*。

1.  **Diffie Hellman。** 设*p*为一个素数，*a*和*b*为两个整数。给定*p*，一个*x*，*x^a (mod p)*和*x^b (mod p)*，*Diffie-Hellman*问题是计算*x^(ab) (mod p)*。

1.  **Rabin 的加密系统。** 选择 p、q 为素数，使得 p = 3 mod 4 且 q = 3 mod 4。公钥为 n = pq，私钥为(p, q)。加密时，计算 E(m) = m² mod n。解密时计算 D(c) = sqrt(c) mod n。如何计算平方根：c = x² mod n？使用扩展欧几里得算法找到 a、b，使得 ap + bq = 1。计算 r = c^((p+1)/4) mod p 和 s = c^((q+1)/4) mod q。计算 m = (aps + bqr) mod n 和 t = (aps - bqr) mod n。c 的四个平方根为 m，-m mod n，t 和-t mod n。

1.  **模拟私钥交换。** 你被困在一个岛上，有一个盒子，一个带钥匙的挂锁，还有一本《计算机科学导论》的副本。你有一个在另一个岛上的朋友，他也有一个盒子，一个带钥匙的挂锁，但想借你的教科书。你可以通过一个不怀好意的快递服务运送物品，如果盒子没有锁上，他们会洗劫盒子里的任何东西。你如何把书送给你的朋友？

1.  **密码安全的哈希函数。** SHA-1 和 MD5。可以通过将字符串转换为字节来计算，或者在逐个读取字节时计算。

    ```
    import java.security.MessageDigest;
    ...
    MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
    sha1.update(s.getBytes());
    Byte[] hash = sha1.digest();

    ```

1.  **Java 中��RSA。** 用于 RSA 或 DSA 的内置功能。未经测试的代码如下。

    ```
    // key generation
    KeyPairGenerator keygen = KeyPairGenerator.getInstance("DSA");
    SecureRandom random     = new SecureRandom();
    keygen.initialize(512, random);
    KeyPair keys     = keygen.generateKeyPair();
    PublicKey pubkey = keys.getPublic();
    PrivateKey prikey = keys.getPrivate();

    // digital signing
    Signature signer = Signature.getInstance("DSA");
    signer.initSign(prikey); 
    signer.update(s.getBytes());
    Byte[] signature = signer.sign();

    // verifying
    Signature verifier = Signature.getInstance("DSA");
    verifier.initVerify(pubkey); 
    verifier.update(t.getBytes());
    Boolean check = verifier.verify(signature);

    ```

1.  **Blum-Blum-Shub 伪随机比特生成器。** 选择两个不同的 N 位素数 p 和 q，使得 p mod 4 = q mod 4 = 3。设 n = pq，并通过选择一个随机种子 1 < s < n，使得 gcd(s, n) = 1 来选择一个起始值 x[0]。形成整数序列 x[0] = s² mod n 和 x[i+1] = x[i] x[i] mod n。使用 x[i] % 2 作为伪随机比特序列。不需要保密 n。发现任何模式（在多项式时间内）与分解 n 一样困难。注意：我们仍然需要随机生成 p、q 和 s，但这些只有 O(N)位，我们将能够生成 2^N 个伪随机比特。可以用作一次性密码本。

    也可以直接用于[公钥加密](http://math.boisestate.edu/~marion/teaching/crypto1f03/bbs_the_system.htm)

1.  **VCR Plus 解码。** 用于在报纸上打印的特殊代码来录制 VCR 上节目的遥控方案。密码学不好，很容易破解。[论文链接](http://citeseer.nj.nec.com/260048.html)

1.  **帕斯卡三角形。** 计算帕斯卡三角形的第 k 行（对于 k > 2）的一种方法是计算(2^k + 1)^(k+1)，并以 k 位为一组取其二进制表示。

    ```
    10 = 1    (10 = 1 = 1)
    111 = 1 1    (31 = 3 = 1 1)
    10110 = 01 10 01    (52 = 25 = 1 2 1)
    10111 = 01 11 11 01    (53 = 125 = 1 3 3 1)
    1001100 = 001 100 110 100 001  1 4 6 4 1  (94 = 6561 = 1 4 6 4 1)
    10001101 = 0001 0101 1010 1010 0101 0001   (175 = 1419857)

    ```

1.  **Bailey-Borwein-Plouffe 算法。** 使用[BBP 算法](http://crd.lbl.gov/~dhbailey/expmath/expbook-C.pdf)计算π的第 i 位二进制数字，而不需要计算前面的数字，这需要模指数运算。

1.  **秘密分享。** 想要将一条消息分发给 N 个人，以便其中任意 3 个人可以恢复原始消息，但任何 1 或 2 个人都不能。[参考链接](http://www.chiark.greenend.org.uk/pipermail/ukcrypto/1999-November/007055.html)。[Scientific American 谜题](http://sciam.com/article.cfm?chanID=sa006&colID=14&articleID=0009F978-0583-1FFB-809C83414B7F0000)

1.  **梅森素数。** *梅森素数* 是形式为 M_p = 2^p - 1 的素数，其中 p 是一个奇素数。要测试 M_p 是否为素数，形成以下序列：s_0 = 4，s_i+1 = (s_i)² - 2 mod M_p。当且仅当 s_(p-2) = 0 mod M_p 时，M_p 是素数。这种方法被称为[卢卡斯-勒默素数检验](http://en.wikipedia.org/wiki/Lucas-Lehmer_test_for_Mersenne_primes)。
