# RPC 和线程

# 6.824 2015 年第 2 讲：基础设施：RPC 和线程

**注意：**这些讲座笔记是从 2015 年春季 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)上稍作修改的。

## 远程过程调用（RPC）

+   分布式系统的一个关键部件；所有实验都使用 RPC

+   *目标：*易于编程的网络通信

    +   隐藏了客户端/服务器通信的大部分细节

    +   客户端调用很像普通的过程调用

    +   服务器处理程序很像普通的过程

+   RPC 被广泛使用！

RPC 理想情况下使网络通信看起来就像普通的*函数调用*：

```
 Client
  ------
    z = fn(x, y)

  Server
  ------
    fn(x, y) {
      compute
      return z
    } 
```

RPC 旨在实现这种透明度

### RPC 消息图

```
 Client                      Server
  ------                      ------

          "fn", x, y
  request ---------->

                          compute fn(x, y)

            z = fn(x, y)
           <------------- response 
```

### 软件结构

```
 Client             Server
   ------             ------

  client app         handlers
    stubs           dispatcher
   RPC lib           RPC lib
     net <-----------> net 
```

*存根*有点像假的客户端端函数，看起来像真正的`f(x, y)`，但它们只负责打包参数、将其发送到网络上，并要求服务器计算`f(x, y)`。然后存根可以通过网络接收结果并将值返回给客户端代码。

来自实验 1 的例子:

+   `DoJob`

+   `Register`

### RPC 的一些细节

+   *编组：*将数据格式化为数据包

    +   对于数组、指针、对象等可能会有些棘手

    +   Go 的 RPC 库非常强大！

    +   有些东西你无法传递/编组：例如通道、函数

+   *绑定：*客户端如何知道要与谁通信？

    +   可能是一个名称服务--例如 DNS

+   *线程：*

    +   客户端通常有许多线程，因此`> 1`个调用未完成，将回复与调用匹配

    +   处理程序可能很慢，因此服务器通常在每个线程中运行

*RPC 问题：*如何处理失败？

+   例如丢失的数据包、网络中断、服务器崩溃、服务器慢

客户端的 RPC 库看到的失败是什么样的？

+   它从未看到服务器的响应

    +   可能数据包丢失了

+   它*不*知道服务器是否看到了请求！

    +   可能是服务器/网络在发送回复之前出现故障

### 最简单的方案：*"至少一次"*行为

```
 while true
        send req
        wait up to 10 seconds for reply
        if reply arrives
            return reply
        else
            continue 
```

+   RPC 客户端库会等待一段时间才会收到响应

+   如果没有收到，重新发送请求

+   多次执行这个操作

+   仍然没有响应--向应用程序返回错误

**问：**"至少一次"对应用程序来说容易应对吗？

至少一次的简单问题：

+   发生在**非** *无副作用* 的请求中

+   客户端发送*"从银行账户扣除$10"*两次，因为没有收到第一次的回复

更微妙的问题：客户端程序可能出现什么问题？

+   `Put("k", "v")`会用`v`覆盖`k`处的值

+   `Put("key", "value1")`--用于在 DB 服务器中设置键值的 RPC

+   `Put("key", "value2")`--客户端然后对同一个键进行第二次 Put

例子：

```
Client                              Server
------                              ------

put k, 10
            ----\
                 \
put k, 20   --------------------->  k <- 20
                   \
                    ------------->  k <- 10

get k       --------------------->

                10
            <--------------------- 
```

**注意：**客户端发送请求，服务器进行一些工作并回复，但回复丢失的情况经常发生，并且在实验中会经常遇到。

至少一次是否可以？

+   是的：如果重复操作是可以接受的，例如只读操作

+   是的：如果应用程序有自己的重复检测计划

    +   这些内容将会在 Lab 1 中用到

### 更好的 RPC 行为：*"至多一次"*

+   *思路：*服务器 RPC 代码检测到重复请求

    +   返回先前的回复而不是重新运行处理程序

+   客户端在每个请求中包含*唯一 ID（XID）*

    +   重新发送时使用相同的 XID

+   服务器检查 XID 是否之前已经看到

例如：

```
 if seen[xid]:
      r = old[xid]
    else
      r = handler()
      old[xid] = r
      seen[xid] = true 
```

一些至多一次的复杂性

+   如何确保 XID 是唯一的？

    +   大随机数？

    +   将唯一客户端 ID（ip 地址？）与序列号结合？

+   服务器最终必须丢弃有关旧 RPC 的信息

    +   何时丢弃是安全的？

    +   *想法：*

        +   唯一客户端 ID

        +   每个客户端 RPC 序列号

        +   客户端在每个 RPC 中包含*"已看到所有回复`<= X`"*，类似于 TCP 序列号和 ACK

        +   或者只允许客户端一次只有一个未完成的 RPC，以便到达`seq+1`时服务器可以丢弃所有`<= seq`

        +   或者客户端同意在`< 5`分钟内不断重试，服务器在 5 分钟后丢弃

+   在原始请求仍在执行时如何处理重复请求？

    +   服务器还不知道回复；不想运行两次

    +   *想法：*每个执行的 RPC 都有一个"挂起"标志；等待或忽略

如果一个至多一次服务器崩溃了怎么办？

+   如果至多一次在内存中有重复信息，服务器将忘记

    +   并接受重复请求

+   或许应该将重复信息写入磁盘？

+   复制服务器也应该复制重复信息吗？

### 关于*"仅一次"*怎么办？

+   *至多一次*语义加上无限重试加上容错服务

### Go RPC 是"至多一次"

+   打开 TCP 连接

+   将请求写入 TCP 连接

+   TCP 可能会重传，但服务器的 TCP 会过滤重复数据

+   Go 代码中不重试（即不会创建第二个 TCP 连接）

+   Go RPC 代码如果没有收到回复就会返回错误

    +   或许在超时后（来自 TCP）

    +   或许服务器没有看到请求

    +   或许服务器处理了请求但在回复返回之前服务器/网络失败了

### Go 的至多一次 RPC 对 Lab 1 不够

+   它仅适用于单个 RPC 调用

+   如果工作线程没有响应，主服务器会将其重新发送给另一个工作线程

    +   但原始工作可能没有失败，而且也在处理

+   Go RPC 无法检测到这种重复

    +   在实验 1 中没有问题，它在应用程序级别处理

    +   在实验 2 中，你将不得不防止这些重复

## 线程

+   线程是一种基本的服务器结构工具

+   你将在实验中经常使用它们

+   它们可能会很棘手

+   与 RPC 一起很有用

+   在 Go 中称为 goroutines

线程=“控制线程”

+   线程允许一个程序（逻辑上）同时执行多个任务

+   线程共享内存

+   每个线程包含一些线程状态：

    +   程序计数器、寄存器、堆栈

### 线程挑战：

+   在线程之间共享数据

    +   如果两个线程同时修改同一变量会怎样？

    +   如果一个线程读取另一个线���正在更改的数据会怎样？

    +   这些问题通常称为*竞争*

    +   需要保护共享数据的不变性（Go：*互斥锁*）

+   线程之间的协调（Go：*通道*）

    +   例如等待所有 Map 线程完成

+   *死锁*

    +   线程 1 正在等待线程 2

    +   线程 2 正在等待线程 1

    +   容易检测（不像竞争）

+   锁粒度

    +   粗粒度`->`少量并发/并行

    +   细粒度`->`大量并发，但竞争和死锁

+   让我们来看一个玩具 RPC 包，以说明这些问题。

## 查看今天的讲义 -- l-rpc.go

在这里获取它。

+   这是一个玩具 RPC 系统。

+   说明了线程、互斥锁、通道。

+   这是一个玩具。

    +   假设连接已经打开。

    +   仅支持整数参数，整数回复。

    +   不处理错误。

#### `struct ToyClient`

+   客户端 RPC 状态。

+   每个 `ToyClient` 都有一个互斥锁。

+   与服务器的连接（例如 TCP 套接字）。

+   xid -- 每次调用的唯一标识，以匹配回复和调用方。

+   `pending[]` -- 多个线程可能调用，需要找到它们。

    +   调用方正在等待的通道。

#### `Call()`

+   应用程序调用 `reply := client.Call(procNum, arg)`

+   `procNum` 指示在服务器上运行哪个函数。

+   `WriteRequest` 知道 RPC 消息的格式。

    +   基本上只是参数转换为数据包中的位。

+   **Q:** `Call()` 中为什么需要互斥锁？`mu.Lock()` 是做什么的？

+   **Q:** 我们可以将 `xid := tc.xid` 移到关键部分之外吗？

    +   毕竟，我们没有改变任何东西。

    +   [见下面的图表]

+   **Q:** 我们需要在关键部分内部调用 `WriteRequest` 吗？

    +   注意：Go 说你负责防止并发的映射操作。

    +   这就是为什么更新到待处理状态被锁定的一个原因。

图表：

#### `Listener()`

+   作为后台线程运行。

+   `<-` 做什么？

+   它可能需要在通道上等待调用方不太正确。

#### 回到 `Call()`...

**Q:** 如果回复很快回来怎么办？

+   `Listener()` 能在 `pending[xid]` 条目存在之前看到回复吗？

+   或者在调用方等待通道之前？

**Q:** 我们应该将 `reply := <-done` 放在关键部分内吗？

+   为什么在外面没问题？毕竟，两个线程都在使用它。

**Q:** 为什么每个 `ToyClient` 都有一个互斥锁，而不是整个 RPC 包只有一个互斥锁？

#### 服务器的 `Dispatcher()`

+   请注意，调度器将 xid 回显回客户端。

    +   这样 `Listener` 就知道要唤醒哪个调用。

+   **Q:** 为什么在单独的线程中运行处理程序？

+   **Q:** 调度器可以无序地回复有问题吗？

#### `main()`

+   请注意在 `handlers[]` 中注册处理程序。

+   程序会打印什么？

何时使用共享内存（和锁），何时使用通道？

+   这是我的观点。

+   当你想要一个线程明确等待另一个线程时，请使用通道。

    +   经常等待结果，或者等待下一个请求。

    +   例如当客户端 `Call()` 等待 `Listener()` 时。

+   当线程不是故意时，使用共享内存和锁。

    +   直接交互，但只是碰巧读/写相同的数据。

    +   例如当 `Call()` 使用 `tc.xid` 时。

Go 的 "内存模型" 需要显式同步才能通信！

这段代码是不正确的：

```
 var x int
    done := false
    go func() { x = f(...); done = true }
    while done == false { } 
```

很诱人地编写，但 Go 规范表示应该使用通道或 `sync.WaitGroup` 代替。

学习关于 *goroutines* 和 *channels* 的 Go 教程。
