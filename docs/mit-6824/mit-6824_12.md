# 最终一致性

# 6.824 2015 年第 12 讲：最终一致性

**注意：**这些讲义与 2015 年春季 6.824 课程网站上发布的讲义略有修改。

## 考试

+   为考试带上论文和讲义

## Bayou：最终一致性

+   一组数据的副本，应用程序可以使用数据的任何副本

+   本地读/写

+   即使网络中断，我仍然可以使用本地副本

    +   *断开操作*

+   临时同步

    +   笔记本电脑、手机、平板电脑可以在彼此之间同步，而不是依赖于互联网连接

+   可以与具有不同数据的数据库服务器一起工作，并相互同步

+   类似于 Ficus，但 Bayou 具有更复杂的冲突解决方法

### 冲突

+   如何处理允许人们写入本地副本并稍后同步它们时发生的不可避免的冲突

### 会议室调度器

传统方法（中央服务器）：

```
 PDA
|-----------------
|9am    824 staff     |----------------|
|--                   |  Server        |
|10am        -------------> | DB   |   |
|--                         | 9am  |   |
|11am                       | 10am |   |
|--                                    |
|12pm                                  |
|-- 
```

这不是一个好方法，因为它要求每个人都与服务器连接。

如果您能让 PDA 发送约会给笔记本电脑，然后再发送给服务器，那就太好了。

```
 PDA
|-----------------
|9am    824 staff     |----------------|
|--                   |  Server        |
|10am                       | DB   |   |
|--                         | 9am  |   | <-----\
|11am                       | 10am |   |        \
|--                                    |         |
|12pm                                  |      laptop
|--      \                                      /
          \----------------------------------->/ 
```

### 更新函数

**主要思想：**更新函数。 应用程序不再说“写入此数据库记录”，而是将函数交给根据数据库内容而表现不同的应用程序。

例如：

+   如果 10 点有空

    +   保留 @10am

+   否则如果 9 点有空

    +   保留 @9am

+   否则

    +   保留

Bayou 将此功能从 PDA 获取并交给笔记本电脑。

假设 A 和 B 希望在同一时间：

+   A 希望：10 点或 11 点的员工会议

+   B 希望：10 点或 11 点的招聘会议

如果您仅将这些函数应用于节点 A 和 B 的数据库，这是不够的：

+   X 与 A 同步：X 得到 10 点的员工会议

+   X 与 B 同步：X 得到 11 点的招聘会议

+   Y 与 B 同步：Y 得到 10 点的招聘会议

+   Y 与 A 同步：Y 得到 11 点的员工会议

+   **糟糕：**现在 X 和 Y 有不同的观点

`=>`必须以相同的顺序执行`A`和`B`的更新函数

### 编号更新

**下一个想法：**编号更新函数，以便您可以将它们视为日志

+   对事物排序的经典方法是用数字和排序标记它们

+   最初让 Bayou 更新 ID 为`<时间 T，节点 ID>`

    +   可能对于时间`T`来说，两个更新 ID 相同，但节点 ID 将不同（据推测）

+   排序规则：

    +   如果`a.T < b.T`或`a.T == b.T and a.ID < b.ID`，则`a < b`

如果我们以前的例子为例：

```
<T=10, nodeId=A>, A wants: either staff meeting at 10  or 11
<T=20, nodeId=B>, B wants: hiring meeting at 10 or 11 
```

+   当 Y 与 B 同步然后与 A 同步时，它将看到 A 的更新发生得更早

+   所以它撤销 B 的更新，应用 A 的更新，然后再次应用 B 的更新

我们需要能够回滚并重新执行日志。

更新是否符合因果关系？

+   PDA A 添加了一个会议

+   A 与 B 同步

+   B 删除了 A 的会议

如果第三个节点看到这些更新，有必要让会议创建时间戳小于删除时间戳。

### Lamport 逻辑时钟

每个节点维护`T_max`，这个节点从自身或其他节点看到的最高时间戳。

当节点创建事件并将其添加到日志中时，它选择时间戳`T = max（T_max + 1，壁钟时间）`

+   新时间戳始终比节点曾经看到的时间戳要高

### 临时条目，提交方案

令人讨厌的是，日历中的条目总是显示为临时的，因为可能会有另一个（更早的）更新进来并替换它。

+   也许是因为新的更新发送者长时间断开连接了

我们正在寻找一种方式，让大家都同意日志中某一点以上的任何内容都永远不会改变（它被冻结，没有人可以修改那里的东西）

**不好的想法：**一种可能性是让所有复制品互相交换关于它们所见内容的摘要：

+   X 已经看到了 A 的更新到 20，B 的更新到 17，C 的更新到 72

    +   这些是时间戳（逻辑时钟）

+   我们知道 X 永远不会创建小于 72 的时间戳

+   同样，节点 Y 也有他将生成的最小时间戳

    +   说 30

+   我们可以对所有这些最小值取最小值`min（30，72）= 30`并提交到该点的所有操作

+   问题是它需要每个节点都处于启动状态并连接到所有其他节点

#### Bayou 的提交方案

他们有一个神奇的节点，一个主节点。每个通过主节点的更新，主节点都会用*提交序列号*（CSN）给它盖上时间戳，实际排序号变为：`<csn，T，节点 ID>`

+   主节点不会等待较早的更新（带有较小的`T`）到达，它只是按照它们到来的顺序给事物打上时间戳。

+   提交保留因果顺序

+   提交不保留壁钟顺序

如果您没有 CSN：`<-, T，nodeID>`，则所有提交的操作都被认为在未提交的操作之前发生。

**TODO：**不清楚这个例子应该展示什么

+   A 的会议已创建

+   B 的会议已创建

+   B 与 C 同步

+   B 与 A 同步

+   C 与主节点同步

+   主节点将 CSN 应用于 A 的操作，但不是 B 的

+   B 与主节点同步

### 向量时间戳

同步

+   A 有

    +   `<-, 10，X>`

    +   `<-, 20，Y>`

    +   `<-, 30，X>`

    +   `<-, 40，X>`

+   B 有

    +   `<-, 10，X>`

    +   `<-, 20，Y>`

    +   `<-, 30，X>`

+   A 与 B 同步

    +   发送版本向量给 B，描述它从每个节点收到的更新。

        +   A：`[X 40，Y 20]`

        +   （记住时间戳始终由发送者增加）

        +   B：`[X 30，Y 20]`

        +   如果 B 将 A 的 VT 与他的比较，他会注意到他需要在时间戳 30 到 40 之间由 X 更新的内容

### 一个新节点加入

现在一些 VT 将有一些新节点 Z 的条目。例如，在前面的示例中

+   A 可以发送[X 40，Y 20，Z 60]给 B

我们还需要一种删除节点的方法。

但是 B 不知道`Z`是新增加的还是新删除的？

+   Z 加入系统

+   Z 与 X 交谈

+   X 生成 Z 的唯一节点 ID

    +   Z 的 ID =`<Tz，X 的节点 ID>`，其中 Tz 是 Z 与 X 通话的时间

+   X 发送一个时间戳为`<-, Tz，X>`的更新，说“新服务器 z”

    +   每个人都会在看到 Z 的更新之前看到这个

        +   Z 的更新的时间戳高于 Tz

    +   请注意，ID 的大小不受限制

忘记节点：

+   Z 的 ID =`<20，X>`

+   A 同步-> B

+   A 有来自 Z 的日志条目`<-, 25，<20，X>>`

+   B 没有 Z 的 VT 条目

现在 `B` 需要从 `A` 的更新中弄清楚 `Z` 是否被添加或移除

Case 1: 如果 `B` 对于 `X` 的 VT 条目比 `Z` 的 ID 中的时间戳要小，则意味着 `B` 甚至还没有看到 `Z` 的创建，更不用说来自 `Z` 的任何更新了 => `B` 应该为 `Z` 创建条目，因为对于 `B` 来说，`Z` 是新的

Case 2: 如果 `B` 对于 `X` 的 VT 条目高于 `Z` 的 ID 中的时间戳（即 `B` 在创建 `Z` 后看到了来自 `X` 的更新），那么 `B` 必须已经看到了 `Z` 的创建 `=>` `B` 必须已经看到了删除通知

**问：** 如果 `B` 中缺少 `Z` 的条目，则 `Z` （可能？）会说 `<-, T, Z> 再见, T > Tz`

* * *

# 6.824 记录

Bayou 中的管理更新冲突，一个弱连接的复制存储系统 Terry, Theimer, Petersen, Demers, Spreitzer, Hauser, SOSP 95

一些来自 [灵活的弱一致性复制中的更新传播](http://people.cs.umass.edu/~arun/cs677/notes/Bayou.pdf)，SOSP 97 的材料

## 为什么选择这篇论文？

+   最终一致性是非常普遍的

    +   git、iPhone 同步、Dropbox、亚马逊 Dynamo

+   为什么人们喜欢最终一致性？

    +   本地副本的快速读写（没有主副本，没有 Paxos）

    +   断开操作

+   有什么问题？

    +   看起来不像 "单一副本"（没有主副本，没有 Paxos）

    +   写入不同副本的冲突写入

    +   发现时如何调和它们？

+   Bayou 有最复杂的调和故事

论文背景：

+   早期的 1990 年代（像 Ficus 一样）

+   PDA、笔记本电脑、平板电脑的黎明

    +   硬件笨重但有明显的潜力

    +   商业设备没有无线功能

+   设备可能关闭或没有网络访问

    +   这个问题还没有消失！

    +   iPhone 同步、Dropbox 同步、Dynamo

让我们建立一个会议室调度程序

+   一次只允许一个会议（一个房间）。

+   每个条目都有一个时间和描述。

+   我们希望每个人最终看到相同的条目集。

传统方法：一个服务器

+   服务器一次执行一个客户端请求

+   检查冲突时间，回答是或否

+   更新数据库

+   继续下一个请求

+   服务器隐式地为并发请求选择顺序

为什么我们不满足于中央服务器？

+   我想在断开连接的 iPhone 上使用日程安排器等

    +   因此每个节点都需要数据库副本。

    +   在任何节点上修改，以及读取。

+   定期连接到网络。

+   定期直接与其他日历用户联系（例如蓝牙）。

## 草人 1：合并数据库

+   类似于 iPhone 日历同步，或文件同步。

+   可能需要比较每个数据库条目 -- 大量的时间和网络带宽。

+   仍然需要处理冲突条目的故事，即同时发生两个会议。

    +   用户可能在数据库合并时不可用于做出决定。

    +   因此需要自动调和。

冲突的想法：更新函数

+   应用程序提供一个函数，而不是一个新值。

+   读取数据库的当前状态，确定最佳变更。

+   例如 "如果 9 点有空房间，则在 9 点见面，否则在 10 点，否则在 11 点。"

    +   而不只是 "9 点见面"

+   函数可以为缺席用户做出调和决策。

+   同步交换函数，而不是数据库内容。

**问题：** 不能只将更新函数应用于数据库副本

+   A 的函数：10:00 或 11:00 开员工会议

+   B 的功能：在 10:00 或 11:00 举行面试。

+   X 同步与 A，然后 B

+   Y 同步与 B，然后 A

+   X 会将 A 的会议安排在 10:00，而 Y 则将 A 的安排在 11:00？

**目标：** 最终一致性

+   X 和 Y 最初的不一致是可以接受的

+   但是经过足够的同步，所有节点的数据库应该是相同的

**思路：** 有序的更新日志

+   每个节点的有序更新日志。

+   同步 == 确保两个节点在日志中具有相同的更新。

+   数据库是按顺序应用更新函数的结果。

+   相同的日志 `=>` 相同的顺序 `=>` 相同的数据库内容。

节点如何在更新顺序上达成一致？

+   更新 ID：`<时间 T，节点 ID>`

+   T 是创建节点的挂钟时间。

+   排序更新 a 和 b：

    +   如果 `a.T < b.T` 或者（`a.T = b.T` 且 `a.ID < b.ID`），则 `a < b`

例子：

```
 <10,A>: staff meeting at 10:00 or 11:00
 <20,B>: hiring meeting at 10:00 or 11:00

 what's the correct eventual outcome?
   the result of executing update functions in timestamp order
   staff at 10:00, hiring at 11:00 
```

同步之前的数据库内容是什么？

+   A：10:00 的员工

+   B：10:00 的招聘

+   这是 A/B 用户在同步之前将看到的内容。

现在 A 和 B 互相同步

+   每个节点将新条目排序到其日志中，按时间戳排序

+   现在两者都知道了完整的更新集

+   A 可以直接运行 B 的更新函数

+   但是 B 已经 *先前* 运行了 B 的操作，太早了！

回滚和重播

+   B 需要“回滚”数据库，按正确的顺序重新运行两个操作。

+   重要观点：日志才是真相；数据库只是一种优化。

+   我们稍后将优化回滚

显示的会议室日历条目是“暂定”的

+   B 的用户看到了 10 点的招聘，然后它变成了 11 点

更新顺序是否与挂钟时间一致？

+   也许 A 先行（按挂钟时间）用 `<10,A>` 

+   节点时钟不太可能完全同步

+   因此，B 可以生成 `<9,b>`

+   B 的会议优先级更高，即使 A 先发出请求

+   不是“外部一致的”

更新顺序是否与因果一致性一致？

+   如果 A 添加了一个会议，

    +   然后 B 看到了 A 的会议，

    +   然后 B 删除了 A 的会议。

+   或许

    +   `<10,A>` 添加

    +   `<9,B>` 删除 —— B 的时钟慢了

+   现在删除将在添加之前排序！

### Lamport 逻辑时钟用于因果一致性

+   想要给事件时间戳，例如：

    +   如果节点观察到 E1，然后生成 E2，那么 `TS(E2) > TS(E1)`

+   因此，所有节点都将按顺序排序 E1，然后 E2

+   `Tmax` = 从任何节点（包括自己）看到的最高时间戳

+   `T = max(Tmax + 1, 挂钟时间)` —— 生成时间戳

+   注意属性：

    +   在同一节点上 E1 然后 E2 `=> TS(E1) < TS(E2)`

    +   但是

    +   `TS(E1) < TS(E2)` 不意味着 E1 在 E2 之前发生

逻辑时钟解决了添加/删除因果关系的示例。

+   当 B 看到 `<10,A>` 时，

    +   B 将其 Tmax 设置为 10，所以

    +   B 将为其删除生成 `<11,B>`

令人恼火的是始终可能存在时间较长的具有较低时间戳的更新

+   这可能导致我的更新结果发生变化

    +   用户永远无法确定会议时间是否最终确定！

+   如果更新最终“稳定”，那就好了

    +   `=>` 在那一点之前的更新顺序没有变化

    +   `=>` 结果永远不会再次更改 —— 你确切地知道何时开会。

    +   `=>` 不必回滚，重新运行已提交的更新

**糟糕的想法：** 完全分散的“提交”方案

+   建议：如果所有节点都看到了所有时间戳小于等于 10 的更新，则 `<10,A>` 是稳定的。

+   让同步始终按日志顺序发送 —— “前缀属性”

+   如果你已经看到了来自*每个*节点的 `TS > 10` 的更新

    +   那么你将永远不会再���到一个 `< <10,A>`

    +   所以 `<10,A>` 是稳定的。

+   为什么 Bayou 不这样做？

    +   并非所有节点都互相连接。

Bayou 如何提交更新，使其稳定？

+   一个节点被指定为“主复制品”。

+   它用永久 CSN 标记收到的每个更新。

    +   提交顺序号。

    +   那个更新已经提交。

    +   因此一个完整的时间戳是 `<CSN, 本地时间, 节点 ID>`

    +   未提交的更新（被认为）在所有已提交的更新之后使用这个新的时间戳方案

+   CSN 通知在节点之间同步。

+   CSN 为已提交的更新定义了一个总顺序。

    +   所有节点最终都会同意它。

提交顺序会匹配临时顺序吗？

+   经常。

+   同步按日志顺序发送（前缀属性）

    +   包括从其他节点学到的更新。

+   所以如果 A 的更新日志说

    +   `<-,10,X>`

    +   `<-,20,A>`

+   A 将按照那个顺序将两者发送给主复制品

    +   主复制品将按照那个顺序分配 CSN

    +   在这种情况下，提交顺序将匹配临时顺序

提交顺序是否总是匹配临时顺序？

+   不：主复制品可能在看到较旧的更新之前看到更新。

+   A 刚刚有：`<-,10,A> W1`

+   B 刚刚有：`<-,20,B> W2`

+   如果 `C` 看到了 `W1 W2` 的更新

+   B 与主复制品同步，得到 `CSN=5`。

+   稍后 A 与主复制品同步，得到 `CSN=6`。

+   当 C 与主复制品同步时，它的顺序将变为 `W2 W1`

    +   `<5,20,B> W1`

    +   `<6,10,A> W2`

+   因此：提交可能会改变顺序。

提交允许应用程序告诉用户哪些日历条目是稳定的。

+   稳定的会议室时间是最终的。

节点可以丢弃已提交的更新。

+   相反，保留一个截至最高已知 CSN 的数据库副本

+   在重放临时更新日志时回滚到该数据库

+   永远不需要再回滚更远

    +   前缀属性保证看到 `CSN=x => 看到 CSN<x`

    +   在已提交的更新中不会有更新顺序的更改

如果我丢弃了日志的一部分，我该如何同步？

+   假设我已经丢弃了所有带有 CSN 的更新。

+   我保留一个反映刚刚丢弃条目的稳定数据库副本。

+   当我传播给节点 `X` 时：

    +   如果节点 X 的最高 CSN 小于我的，

        +   我可以发送给他我的稳定数据库，反映刚刚提交的更新。

        +   节点 X 可以使用我的数据库作为起点。

        +   并且 X 可以丢弃所有 CSN 日志条目。

        +   然后将他的临时更新播放到该数据库中。

    +   如果节点 X 的最高 CSN 大于我的，

        +   X 不需要我的数据库。

+   在实践中，Bayou 节点保留最近的几个已提交的更新。

    +   为了减少在同步期间必须发送整个数据库的机会。

如何同步？

+   A 发送给 B

+   需要一种快速的方式让 B 告诉 A 发送什么

+   已提交的更新很容易：B 将其 CSN 发送给 A

+   那么临时更新呢？

+   A 有：`<-,10,X>` `<-,20,Y>` `<-,30,X>` `<-,40,X>`

+   B 有：`<-,10,X>` `<-,20,Y>` `<-,30,X>`

+   在同步开始时，B 告诉 A “X 30, Y 20”

    +   同步前缀属性意味着 B 在 30 之前拥有所有 X 的更新，在 20 之前拥有所有 Y 的更新。

+   A 在 `<-,30,X>` 之后发送所有 X 的更新，`<-,20,X>` 之后发送所有 Y 的更新，等等

+   这是一个版本向量 -- 它总结了日志内容

    +   这是图 4 中的“F”向量

    +   A 的 F：`[X:40,Y:20]`

    +   B 的 F：`[X:30,Y:20]`

我们如何应对新服务器 Z 加入系统？

+   它可以开始生成写操作，例如 `<-,1,Z>` 吗？

+   其他节点是否只是开始在 VVs 中包含 Z？

+   如果 A 同步到 B，A 有 `<-,10,Z>`，但 B 的 VV 中没有 Z

    +   A 应该假装 B 的 VV 是 `[Z:0,...]`

当 Z 退休（离开系统）时会发生什么？

+   我们希望停止在 VVs 中包含 Z！

+   如何宣布 Z 已经离开？

    +   Z 发送更新 `<-,?,Z> "退休"`

+   如果您看到一个退休更新，请在 VV 中省略 Z

+   如何处理缺少 Z 的 VV？

+   如果 A 有来自 Z 的日志条目，但 B 的 VV 没有 Z 条目：

    +   例如 A 有 `<-,25,Z>`，B 的 VV 只是 `[A:20, B:21]`

    +   或许 Z 已经退休，B 知道，A 不知道

    +   或许 Z 是新的，A 知道，B 不知道

+   需要一种方式来区分：VV 中缺少 Z 是因为新的还是因为退休？

Bayou 的退休计划

+   Z 通过联系某个服务器 `X` 加入

+   Z 的 ID 由 X 生成为 `<Tz,X>`

    +   Tz 是 X 加入时的逻辑时钟

    +   注意：无限制的 ID 大小

+   X 发出 `<-,Tz,X> "新服务器 Z"`

`ID=<Tz,X>` 方案如何帮助区分新的与被遗忘的？

+   假设 Z 的 ID 是 `<20,X>`

+   A 同步到 B

    +   A 有来自 `Z <-,25,<20,X>>` 的日志条目

    +   B 的 VV 中没有 Z 条目

+   一种情况：

    +   B 的 VV：`[X:10, ...]`

    +   `10 < 20` 意味着 B 尚未看到 X 的 "新服务器 Z" 更新

+   另一种情况：

    +   B 的 VV：`[X:30, ...]`

    +   `20 < 30` 意味着 B 曾经知道 Z，但后来看到了一个退休更新

让我们退一步。

最终一致性是一个有用的概念吗？

+   是的：人们希望将快速写入本地副本

+   iPhone 同步，Dropbox，Dynamo，Riak，Cassandra，等等

更新冲突是一个真正的问题吗？

+   是的 - 所有系统都有或多或少笨拙的解决方案

Bayou 的复杂性是否合理？

+   即更新函数的日志、版本向量、暂定操作

+   只有在您需要点对点同步时才是关键的

    +   即断开连接的操作和临时连接性

+   只有在人类是数据的主要使用者时才能容忍

+   否则，您可以通过中央服务器进行同步（iPhone，Dropbox）

+   还是在本地读取但通过主服务器发送更新（PNUTS、Spanner）？

但有一些 Bayou 可以学习的好主意

+   用于自动应用驱动冲突解决的更新函数

+   有序更新日志是真相，而不是数据库

+   因果一致性的逻辑时钟
