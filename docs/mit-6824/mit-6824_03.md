# 主/备份复制

# 6.824 2015 年第 3 讲：主/备份复制

**注意：**这些讲座笔记略有修改自 2015 年春季 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)上发布的内容。

## 今天

+   复制

+   Remus 案例研究

+   实验 2 介绍

## 容错

+   我们希望一个服务能够在发生故障时继续运行！

+   **定义：**

    +   *可用* -- 尽管[某些类别的]故障仍可使用

    +   *正确* -- 对客户端的行为就像单个服务器

        +   出现的许多问题与*正确性*有关

+   非常困难！

+   非常有用！

### 需要一个故障模型：我们将尝试应对什么？

+   *最常见：*独立的故障停止计算机故障

    +   *故障停止故障：*一段时间内计算正确，然后停止

        +   与计算不正确（不同情况）相反

    +   必须假设故障独立

        +   （否则我们可能会有主节点故障`=>`备份故障`=>` fffffuu....）

    +   Remus 进一步假设一次只有一个故障

+   *另一个模型：*站点范围内的停电（以及最终重启）

+   （网络分区）

+   没有错误，没有恶意

### 核心思想：复制

+   *两个*服务器（或更多）

+   每个副本保留所需的服务状态

+   如果一个副本失败，其他副本可以继续

### 例如：容错 MapReduce 主节点

+   实验室 1 的工作节点已经具有容错能力，但主节点没有

+   `[图表：M1，M2，工作节点]`

+   状态：

    +   工作节点列表

    +   哪些工作已完成

    +   哪些工作节点空闲

    +   TCP 连接状态

    +   程序计数器

### 重要问题

+   要复制什么*状态*？

    +   *例子：*Remus 复制所有 RAM 和 CPU 状态

+   副本如何获取状态？

+   何时切换到备份？

    +   主节点真的宕机了还是只是网络宕机了？

+   切换时是否可见异常？

    +   客户端会看到什么？

+   如何修复/重新集成？

    +   如何获得新的备份？

### 两种主要方法：

1.  **状态转移**

    +   “主”副本执行服务

    +   主节点向备份发送[新]状态

    +   *例子：*Remus

1.  **复制状态机**

    +   所有副本（主节点和备份）执行所有操作

    +   如果相同的起始状态和相同的操作和相同的顺序和确定性和*然后* `=>` 相同的结束状态

    +   *操作*被转移而不是状态

### *状态转移*更简单

+   但状态可能很大，传输速度慢

+   *Remus*使用状态转移

### *复���状态机*可能更有效

+   如果操作相对于数据很小

+   但复杂，例如多核上的顺序，确定性

    +   很难确保每个人都达到相同的状态

    +   确定性可能会有问题（时间，线程等）

+   实验使用复制状态机

## Remus：通过异步虚拟机复制实现高可用性，NSDI 2008

### 非常雄心勃勃的系统

+   整个系统复制

+   对应用程序和客户端完全*透明*

+   任何现有软件的高可用性

+   如果运行良好将是奇迹！

+   *故障模型：*

    1.  独立的硬件故障

    1.  站点范围内的停电

### 计划 1（缓慢，破碎）：

+   `[图表：应用程序，操作系统，Remus 底层]`

+   两台机器，*主节点*和*备份*；加上网络和其他机器

+   主要运行操作系统和应用软件，与客户端交谈等。

+   备份最初不执行操作系统、应用程序等。

    +   它只执行一些 Remus 代码

+   每秒几次：

    +   暂停主要

    +   将整个 RAM、寄存器、磁盘复制到备份

        +   10Gbps = 1GB/s 网络带宽

        +   100MB/s 磁盘带宽

        +   网络带宽限制 RAM 传输速率

        +   磁盘带宽限制磁盘传输速率

    +   恢复主要

+   如果主要失败：

    +   开始备份执行！

**问：** 计划 1 正确吗（如上所述）？

+   即它看起来就像一个单一的可靠服务器吗？

+   不：

    +   客户端将写请求发送到主要，主要在备份有机会复制新状态之前回复

    +   主要失败，备份接管，但它不反映上一个写请求。

    +   客户端将会受挫，因为他的写入被丢失了

**问：** 如果主要失败了，副本接管了会看到外界什么？

+   备份是否具有与主要上次可见的相同状态？

+   客户端请求可能丢失吗？执行两次？

+   是的：参见上述问题

**问：** 如何确定主要是否失败了？

**问：** 客户端如何知道要与备份而不是主要交谈？

**问：** 如果整个站点停电怎么办？

+   主要正在运行一些操作系统，有一个从磁盘“崩溃一致”重新启动的计划

**问：** 如果主要在向备份发送状态时失败了怎么办？

+   即备份正在吸收新状态的中途？

**问：** 如果主要收到请求，向备份发送检查点，然后就在回复之前主要失败了怎么办？

+   TCP 层会处理这个吗？如果客户端重发请求，那可能有问题（副作用）。因此希望 TCP 介入并注意到没有回复。如何做到？主要刚要回复，但 Remus 将回复保持在缓冲区中。备份将具有相同的状态，因此它会认为自己已经回复并等待客户端的确认，但客户端什么也没收到。因此，备份将重新传输主要从未有机会发送的数据包，并最终获得客户端的确认。

**问：** 计划 1 有效吗？

+   我们能消除备份*状态*落后于主要的事实吗？

    +   看起来非常困难！

    +   主要将不得不告诉备份（并等待）每个指令。

+   我们能*隐藏*备份状态落后于主要的事实吗？

    +   防止外界*看到*备份落后于最后一个主要状态

        +   例如，防止主要的发送 RPC 回复，但备份状态没有反映该 RPC

        +   例如 MapReduce `Register()` RPC，备份忘记这个将是不好的

    +   *想法：* 主要“持有”输出直到备份状态赶上输出点

        +   例如主要收到 RPC 请求，处理它，创建回复数据包，但 Remus 将回复数据包保持，直到备份接收到相应的状态更新

## Remus 时代，检查点

1.  主要在 Epoch 1（E1）中运行一段时间，保存 E1 的输出

1.  主要暂停

1.  主要将 RAM+磁盘更改从 E1 复制到本地缓冲区

1.  主要在 E2 中恢复执行，保存 E2 的输出

1.  主要向备份发送 RAM+磁盘的检查点

1.  备份将所有内容复制到单独的 RAM，然后应用，然后确认

1.  主要释放 E1 的输出

1.  备份服务器将 E1 的更改应用于 RAM 和磁盘

如果主服务器失败，备份服务器完成应用上一个时期的磁盘+内存，然后开始执行

**问：** 有任何外部可见的异常吗？

**问：** 如果主服务器接收并执行一个请求，然后在检查点之前崩溃了？备份服务器将不会看到请求！

+   只要主服务器没有回复该请求，这没问题：客户端将重新发送请求

**问：** 如果主服务器发送了一个数据包，然后崩溃了，备份服务器是否保证具有该数据包暗示的状态更改？

+   是的。这就是将发送的网络数据包缓冲直到备份服务器更新的全部意义。

**问：** 如果主服务器在释放输出的过程中部分崩溃了？备份服务器必须重新发送吗？它如何知道重新发送什么？

**问：** Remus 如何决定应切换到备份？

+   天真的机制：如果主服务器停止与备份服务器通信，则出现了问题。

**问：** 是否存在 Remus 会错误激活备份的情况？即主服务器实际上是活着的

+   网络分区...

**问：** 主服务器恢复后，Remus 如何恢复复制？这是必要的，因为最终活动的前备份服务器本身也将失败

**问：** 如果 *两个* 都失败了，例如整个站点的停电？

+   RAM 内容将丢失，但磁盘可能会幸存

+   恢复电源后，从其中一个磁盘重新启动客户机

    +   操作系统和应用程序恢复代码将执行

+   磁盘必须是“崩溃一致”的

    +   如果正在安装检查点，则可能不是备份服务器的磁盘

+   磁盘不应反映任何保持的输出（...为什么不呢？）

    +   如果正在执行，则可能不是主服务器的磁盘

+   我不理解论文的这部分（第 2.5 节）

    +   似乎有一个窗口，在此期间如果断电，则两个磁盘都不能使用

        +   主服务器在时期期间写入其磁盘

        +   与此同时，备份服务器将上一个时期的写入应用到其磁盘上

**问：** 在哪些情况下 Remus 可能会有良好的性能？

**问：** 在哪些情况下 Remus 可能会有低性能？

**问：** 时期应该是短的还是长的？

## Remus 评估

+   *摘要：* 原生速度的 1/2 到 1/4

+   检查点很大且需要时间发送

+   输出保持限制了客户端交互的速度

### 为什么这么慢？

+   检查点很大且需要时间生成和发送

    +   100ms 用于 SPECweb2005 -- 因为有很多页面需要编写

+   因此，检查点间隔必须很长

+   因此，输出必须保持相当长的时间

+   因此客户端交互速度慢

    +   每个客户端每秒只有 10 个远程过程调用

### 如何提高复制性能？

+   使用特定于应用程序的方案可能会节省大量资源：

    +   只发送应用程序实际需要的状态，而不是全部状态

    +   以优化的格式发送状态，而不是整个页面

    +   如果操作比状态小，则发送操作

+   可能 *不* 对应用程序透明

    +   也可能不是对客户端的

## 实验室 2 中的主-备份复制

### 概述

+   简单的键/值数据库

+   主服务器和备份服务器

+   *复制状态机：* 主服务器将每个操作发送到备份服务器进行复制

+   容忍网络问题，包括分区

    +   要么继续运行，正确执行

    +   或者暂停操作直到网络修复

+   允许替换失败的服务器

+   你实际上要实现所有这些（不像实验 1）

### *"视图服务器"* 决定谁是主服务器 `p` 和备份 `b`

+   *主要目标：* 避免"分裂大脑"——关于谁是主服务器的分歧

+   客户端和服务器询问视图服务器

+   他们不会做出独立的决定

### 修复

+   视图服务器可以在旧的备份成为主服务器后将"空闲"服务器作为 `b`

+   主服务器初始化新备份的状态

### 关键点：

1.  一次只能有一个主服务器！

1.  主服务器必须拥有最新的状态！

我们将制定一些规则来确保这些

### 视图服务器

+   维护一系列"视图"

例子：

```
 view #, primary, backup
    0:      --       --
    1:      S1       --
    2:      S1       S2
    4:      S2       --
    3:      S2       S3 
```

+   监控服务器的存活状态

    +   每个服务器定期发送 ping RPC（更像是心跳）

    +   *"死亡"* 如果连续错过 `N` 次 ping

    +   *"活着"* 经过单次 ping 后

+   可以有两个以上的服务器对视图服务器进行 ping

    +   如果有两个以上的*"空闲"*服务器

+   如果主服务器死了：

    +   新视图中之前的备份作为主服务器

+   如果备份死了，或者没有备份

    +   新视图中之前的空闲服务器作为备份

+   只有一个主服务器，没有备份也可以

    +   但是——如果有空闲服务器可用，让其成为备份

### 如何确保新主服务器拥有最新的状态副本？

+   只提升之前的备份

    +   即不要让空闲服务器成为主服务器

+   备份必须记住是否已被主服务器初始化

    +   如果没有，即使被提升也不要作为主服务器运行！

**Q:** 是否可能有多个服务器认为自己是主服务器？

```
 1: S1, S2
       net broken, so viewserver thinks S1 dead but it's alive
    2: S2, --
    now S1 alive and not aware of view #2, so S1 still thinks it is primary
    AND S2 alive and thinks it is primary
    => split brain, no good 
```

### 如何确保只有一个服务器充当主服务器？

...即使有多个可能*认为*自己是主服务器。

*"Acts as"* `==` 执行并响应客户端请求

*基本思想：*

```
 1: S1 S2
    2: S2 --
    S1 still thinks it is primary
    S1 must forward ops to S2
    S2 thinks S2 is primary
    so S2 must reject S1's forwarded ops 
```

规则：

1.  视图 `i` 中的主服务器必须在视图 `i-1` 中是主服务器或备份

1.  主服务器必须等待备份接受每个请求

    +   **Q:** 如果没有备份或备份不知道自己是备份怎么办？

    +   **A:** 如果主服务器是视图的一部分但没有备份，那么主服务器无法取得进展，因此只能等待

    +   **A:** 如果视图已更新并且备份被移出视图，则主服务器可以在没有备份的情况下以"危险模式"运行

1.  非备份必须拒绝转发的请求

1.  非主服务器必须拒绝直接的客户端请求

1.  每个操作必须在状态转移之前或之后

例子：

```
 1: S1, S2
       viewserver stops hearing Pings from S1
    2: S2, --
       it may be a while before S2 hears about view #2

    before S2 hears about view #2
      S1 can process ops from clients, S2 will accept forwarded requests
      S2 will reject ops from clients who have heard about view #2
    after S2 hears about view #2
      if S1 receives client request, it will forward, S2 will reject
        so S1 can no longer act as primary
      S1 will send error to client, client will ask viewserver for new view,
         client will re-send to S2
    the true moment of switch-over occurs when S2 hears about view #2 
```

### 新备份如何获取状态？

+   例如所有的键和值

+   如果 S2 是视图 `i` 中的备份，但不在视图 `i-1` 中，

    +   S2 应该要求主服务器传输完整的状态

### 状态转移规则：

+   每个操作（`Put/Get/Append`）必须在状态转移之前或之后

    +   `==` 状态转移必须对操作是原子的

+   或者

    +   操作在之前，状态转移后反映操作

    +   操作在之后，状态转移不反映操作，主服务器在状��后转发操作

**Q:** 主服务器需要将 `Get()` 转发给备份吗？

+   毕竟，`Get()` 不会改变任何东西，那为什么备份需要知道呢？

+   而额外的 RPC 会耗费时间

+   与确保只有一个主服务器有关：

    +   假设出现两个主服务器（P 和 P' 都认为自己是主服务器）

        +   这可能发生吗？网络分区？

    +   假设客户端向错误的主节点 P' 发送 Get 请求

    +   然后 P' 将尝试将请求转发到 P（P'认为它是备份）

    +   然后 P 将告诉 P'：*“嘿，滚开，我是主要的”*

**问：** 我们如何使仅主要的 `Get()` 起作用？

**问：** 在实验 2 协议中是否存在无法取得前进的情况？

+   视图服务失败

+   在备份获取状态之前，主要失败

+   我们将在实验 3 中开始修复这些问题
