# Go

# **Russ Cox** 的 Go 讲座

## 为什么选择 Go？

+   解决 Google 在可扩展性方面的问题的答案

    +   `10⁶+` 台机器设计点

    +   在 1000 台机器上运行是例行公事

    +   不断地编写相互协调的程序

        +   有时 MapReduce 起作用，有时不起作用

## 谁在谷歌使用 Go

+   Chrome 移动设备上的 SPDY 代理使用 Go 编写的 *数据压缩代理*

+   dl.google.com

+   YouTube MySQL 负载均衡器

+   目标是网络服务器，但它是一种很棒的通用语言

+   Bitbucket、bitly、GitHub、Dropbox、MongoDB、Mozilla 服务、纽约时报等

## 并发

+   《通信顺序进程》，由霍尔，1978

    +   强烈建议阅读

    +   在某种意义上，是 UNIX 管道的泛化

+   贝尔实验室在 80 年代、90 年代开发了一些并发语言：

    +   Pan、Promela、Newsqueak、Alef、Limbo、Libthread、Concurrent ML

+   谷歌在 2000 年代开发了 Go

### 没有 goroutine ID

+   “没有 goroutine ID，所以我不能杀死我的线程”

    +   这就是通道的作用：只需通过通道告诉你的线程关闭自己

    +   此外，杀死它们有点“不合群”。

        +   我们的意思是，如果你一直像那样杀死你的线程，你的程序可能不会运行得很好

### 通道 vs. 互斥锁

+   如果你需要互斥锁，请使用互斥锁

+   如果你需要条件变量，请考虑使用通道代替

+   不要通过共享内存进行通信，而是通过通信共享内存

### 网络通道

+   拥有等效的网络通道会很棒

+   如果你将本地抽象（如通道）用于新的上下文，比如网络，忽略了故障模式（等等），那么你将会遇到麻烦

## 工程工作的规模

2011 年，Google 有：

+   5000 多名开发人员

+   每分钟 20 多次更改

+   每月 50% 的代码库更改（文件？可能不是行）

+   每天执行 5000 万个测试用例

+   单一代码树项目

需要一种新的语言来解决其他语言在这种规模的软件工程中存在的问题

编译规模很重要。

+   当你编译依赖于 B 的包 A 时，大多数（全部？）语言需要先编译 B

+   Go 不会。

+   如果你在谷歌项目的规模上使用传统语言，这样的依赖关系会减慢编译速度

    +   深层次依赖（`A->B->C->D->...`）会使情况变得更糟

+   *例子：*在某个时候，他们发现一个 PostScript 解释器无缘无故地编译到了服务器二进制文件中，这是由于奇怪的依赖关系

### 接口 vs. 继承

+   继承层次结构很难搞定，如果你没有搞定，以后更改起来就会很困难

+   接口更加非正式和更清晰地表明程序的哪些部分由谁拥有和提供

### 可读性和简单性

+   迪克·加布里埃尔的引言：

    > “我总是对早期编程语言的轻盈和静止感到高兴。文本不多；完成了很多事情。旧程序读起来像是一个口才流利的研究人员和一个精通机械的同事之间的轻松对话，而不是与编译器的辩论。谁会想到复杂性会带来这么多噪音呢？”

+   简化语法

+   避免聪明的做法：三元运算符，宏

+   不要让编写代码变成像“与编译器争论”一样

+   6 个月后不想要再费力地解析代码

## 设计标准

+   由 Rob Pike、Robert Griesemer 和 Ken Thompson 在 2007 年末创立

+   Russ Cox、Ian Lance Taylor 在 2008 年中期加入

+   通过共识来设计（每个人都可以否决一个特性，如果他们不想要它的话）

### 泛型

+   Russ 说：“不要使用 `*list.List`，你几乎永远不需要它们。使用切片。”

    +   泛型并不是坏事，只是很难做到正确。

        +   早期的 Java 泛型设计者也同意并警告 Go 设计者要小心

            +   似乎他们后悔涉足了那个行业

### 工程工具

+   当你有数百万行代码时，你需要机械帮助

    +   就像改变一个 API

+   Go 设计成易于解析（不像 C++）

+   标准格式化程序

+   这意味着你无法区分机械变化和手动变化

    +   实现代码的自动重写

### 更多自动化

+   修复因 API 更新而产生的代码问题

    +   早期的 Go 版本 API 发生了很大变化

    +   谷歌有一个重写器，会修复使用了已更改的 API 的代码

+   重命名结构字段，具有冲突解决的变量

+   移动包

+   包的分离

+   代码清理

+   将 C 代码改写为 Go

+   全局分析，找出例如一个接口的所有实现者是什么

## Go 的现状

+   Go 1.4 在 2014 年 12 月发布

+   Go 1.5 中的工具链是用 Go 实现的，而不是用 C 实现的

    +   并发 GC

    +   适用于移动设备的 Go

    +   Go 在 PowerPC、ARM64 上

+   很多人在使用它

+   在 Google/Go 之外的 Go 大会

## 问答环节

+   Go 对比 C/C++

    +   Go 是垃圾收集的，这是最大的区别，所以更慢

    +   有时候 Go 可以比 Java 更快

    +   一旦你意识到这一点，你可以编写比 C/C++ 代码运行更快的代码。

    +   没有理由不让不分配内存的代码运行得像 C/C++ 一样快

+   目标是在 Google 之外使用 Go 吗？

    +   是的！否则语言会消亡？

    +   你得到了一批专家给你建议并编写工具等等。

        +   C++ 内存模型的专家给出了关于 Go 内存模型的反馈

            +   非常有用

    +   不试图取代像语言 X 这样的东西

        +   但是他们曾经使用 C/C++，不想再使用了

        +   然而 Python 和 Ruby 用户更多地转向了 Go

            +   Go 感觉起来与 C/C++ 一样轻巧，但是静态类型检查了

+   关于 Go 的好处的研究？

    +   收集的数据不多
