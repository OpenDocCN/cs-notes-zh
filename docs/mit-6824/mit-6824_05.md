# Paxos

# 6.824 2015 年第 5 讲：Paxos

**注意：** 这些讲义笔记是从 2015 年春季 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html) 上发布的讲义笔记中稍作修改的。

## 简介

开始一个新的关于更强容错性的讲座组

+   今天：

    +   通过 Paxos 实现更干净的复制方法：RSM

    +   实验三

+   后续讲座：

    +   如何使用 Paxos 构建系统（Harp、EPaxos、Spanner）

## Paxos

链接：

+   简化版 Paxos，Leslie Lamport，2001 年

+   [Quora 上的简单解释](https://www.quora.com/Distributed-Systems/What-is-a-simple-explanation-of-the-Paxos-algorithm)

+   [简洁的算法 - Paxos](http://harry.me/blog/2014/12/27/neat-algorithms-paxos/)

+   [Paxos 复制状态机作为高性能数据存储的基础](http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf)

+   [Paxos 笔记](http://wellquite.org/blog/paxos_notes.html)

+   [Paxos 简化版论文评论](http://blog.acolyer.org/2015/03/04/paxos-made-simple/)

+   [关于 Paxos 的一些微妙之处](http://the-paper-trail.org/blog/on-some-subtleties-of-paxos/)

回想：RSM

+   通过以相同顺序执行操作来维护副本

+   需要所有副本就操作的（集合和）顺序达成一致

实验二批评

+   带有视图服务器的主/备份

+   **优点：**

    +   概念上很简单

    +   每个操作只需两个消息（请求、回复）

    +   主节点可以进行计算，将结果发送到备份节点

    +   只需要两个 k/v 服务器即可容忍一个故障

    +   与网络分区配合工作

+   **缺点：**

    +   视图服务器是一个 *单点故障*

    +   顺序可能混乱，例如新视图、数据备份、确认等

    +   如果备份节点慢 / 暂时不可用，会产生紧张

        1.  主节点可以等待备份节点 -- 较慢

        1.  视图服务器可以声明备份节点死亡 -- 昂贵，损害了容错性

我们希望有一个通用的排序方案，具有：

+   没有单点故障

+   优雅处理慢/间歇性副本

+   处理网络分区

**Paxos** 将是这一点的关键构建块。

+   一些节点参与 *Paxos 实例*

    +   **Q:** 这个 *实例* 是什么？

    +   **A:** *"每个新命令都需要一个单独的 Paxos 协议，文章称之为一个实例。因此，数据库副本可能会同意首个要执行的命令是 '命令一'，它们使用 Paxos 来达成一致。然后，这个 Paxos 实例就完成了。一段时间后，另一个客户端发送 '命令二'；副本将启动一个完全独立的 Paxos 实例来达成对第二个客户端命令的一致意见。”* --RTM

+   每个节点都知道该实例中每个其他节点的地址

+   Paxos 的每个实例通常只能达成对一个值的共识，系统通常使用多个 Paxos 实例，每个实例通常决定一个操作的假设：异步、非拜占庭

### Paxos 提供了什么？它是如何工作的？

+   **“黑盒子”** Paxos 实例的接口，在每个节点上：

    +   提议一个值（例如，操作）

    +   检查已决定的值，如果有的话

    +   [实验三 A：`src/paxos/paxos.go`：启动、状态]

+   **正确性：**

    +   如果达成协议，所有达成协议的节点都看到相同的值。

+   **容错：**

    +   可以容忍少数节点无法访问（正确性意味着它们根本不会达成一致）。

+   **活性：**

    +   大多数必须是活动的并且能够可靠地通信（少数不活动）。

### 如何使用 Paxos 构建系统？

1.  主/备份类似于 Lab 2，但使用 Paxos 复制视图服务器。

    +   [ 下周二的讲座将涉及这样的系统 ]

1.  *Lab 3*：没有视图服务器，所有复制品都使用 Paxos 而不是主/备份。

使用 Paxos 复制视图服务器或 K/V 服务器类似。

将查看如何进行基于 Paxos 的 K/V 服务器的草图。

**基本思想**：

+   [ 图表：客户端、复制品、每个复制品中的日志、K/V 层、Paxos 层]

+   没有视图服务器。

+   三个复制品。

+   客户端可以向任何复制品发送 RPC（不仅仅是主要的）。

+   服务器将每个客户端操作附加到一组复制的*操作日志*中。

    +   `Put`、`Get`（以及稍后的更多）。

+   日志条目（实例）按顺序编号。

+   Paxos 确保每个日志条目的内容达成一致。

+   每个这些日志条目都有单独的 Paxos 协议。

    +   为日志条目 #`i` 运行单独的 Paxos 算法实例。

    +   **问：** 一个日志条目可以与另一个同时达成一致吗？如果它们彼此依赖，比如 `Put(k1, a)` 和 `Append(k1, b)`？

    +   **答：** 可以！它们可以同时达成一致。

    +   **答：** 你可以在达成对日志条目 #`i` 的同意之前达成对日志条目 #`i+1` 的同意。

        +   这意味着与日志条目 `i+1` 中的 `Get` 或 `Put` 请求相关联的回复将不得不等待其他日志条目设置（有趣）。

+   服务器可以丢弃所有其他服务器已经达成一致（并响应？）的日志条目。

    +   但如果一个服务器崩溃，其他服务器将知道在它恢复时保留它们的日志条目。

+   协议**不**需要指定的提议者或领导者来确保正确性。

    +   这些只有在性能方面有所帮助。

    +   提议者等待随机时间可以克服建议的“活锁”的低概率。

+   一旦 Paxos 节点就某个值达成一致，就不会改变主意。

示例：

+   客户端将 `Put(a, b)` 发送给 `S1`。

+   `S1` 选择一个日志条目 3。

+   `S1` 使用 Paxos 让所有服务器都同意条目 3 包含 `Put(a,b)`。

示例：

+   客户端将 `Get(a)` 发送给 `S2`。

+   `S2` 选择日志条目 4。

+   `S2` 使用 Paxos 让所有服务器都同意条目 4 包含 `Get(a)`。

+   `S2` 扫描日志直到条目 4，以找到最新的 `Put(a, ...)`。

    +   **待办事项：** 对于执行 `Get`，最坏情况是 `O(n)`，因为可以有跟着一堆 `PutAppend` 的 `Put`（或者你可以只有一个存储在很远的地方的 `Put`？）。

        +   复制品是否可以索引他们的日志？我想是的。如果它们都完整地存储它。

+   `S2` 以该值回复。

    +   `S2` 可以缓存通过最后的日志扫描的 DB 内容。

#### 问：为什么是一个日志？

+   为什么不要求所有复制品在每个操作上都达成一致？

+   允许一个复制品落后，然后赶上。

    +   比如如果它慢的话。

    +   其他复制品不必等待。

+   允许一个复制品崩溃然后赶上。

    +   如果它在磁盘上保留状态。

    +   可以重放错过的操作。

+   允许协议的流水线处理/重叠

    +   结果表明达成一致需要多个消息回合

#### 问：达成一致怎么样——我们需要所有副本在每个日志槽中具有相同的操作

+   由 Paxos 提供，我们将在下面看到

*达成一致很难（1）：*

+   在特定日志槽中可能有多个操作的提议

+   `Sx`（服务器 `x`）可能最初听到一个，`Sy` 可能听到另一个

+   显然，必须稍后改变主意

+   因此：多个回合，最初是暂时的

+   我们如何知道达成一致已经是永久的——不再是暂时的？

*达成一致很难（2）：*

+   **待办事项：**如果 `S1` 和 `S2` 同意，而 `S3` 和 `S4` 没有回应，我们完成了吗？

+   协议必须能够即使在服务器失败时也能完成

+   我们无法区分失败的服务器和网络分区

+   因此，也许 `S3`/`S4` 分区了，已经“同意”执行不同的操作！

Paxos 中的两个**主要思想**：

1.  可能需要许多回合，但它们将收敛于一个值

1.  达成一致需要多数支持——防止“脑裂”

    +   *关键点*：任意两个多数交集

    +   因此，任何后来的多数都将与任何先前的多数共享至少一个服务器

    +   因此，任何后来的多数都可以找出先前的多数决定了什么

        +   **待办事项：**如何做？

实验室 3B K/V 服务器为每个客户端的 `Put`、`Get` 创建一个单独的 Paxos 实例

+   接下来的讲座重点放在了特定实例的协议上

## Paxos 轮廓

+   每个节点由三个逻辑实体组成：

    +   **提议者**

    +   **接受者**

    +   **学习者**

+   每个提议者都希望就其价值达成一致

    +   可以尝试使用“指定的领导者”来避免竞争的提议者

    +   允许有多个提议者，因此领导选举可以是近似的

+   提议者联系接受者，试图组建多数

    +   如果大多数回应，我们就完成了

+   在我们的 K/V 服务器示例中，大致如下：

    +   提议者从客户端接收 RPC，提出操作

    +   接受者是 Paxos 内部的，帮助决定共识

    +   学习者找出达成共识的操作是什么，回应客户端

*被推翻的草人：*我们是否可以在一个回合内完成 Paxos？

+   接受者“接受”它从提议者听到的第一个值

+   何时达成共识？

    +   我们是否可以选择得票最多的值？

    +   不，需要多数接受相同的值：`floor(n/2)+1`

    +   否则，对 2 个不同的值达成一致（丢失/分区网络）

+   *问题：*

    +   假设我们有 3 个服务器：`S1`、`S2`、`S3`

    +   如果每个服务器提出并接受自己的值会怎样？

        +   没有多数，陷入困境

        +   但也许我们可以检测到这种情况并恢复？

    +   *更糟糕的是：*`S3` 崩溃 `->` 我们可能已经达到了多数，但我们永远不会知道

+   如果尚未达成共识，需要一种使接受者改变主意的方式

### 基本 Paxos 交换

```
 proposer          acceptors

           prepare(n) ->
        <- prepare_ok(n, n_a, v_a)

           accept(n, v') ->
        <- accept_ok(n)

           decided(v') -> 
```

### 为什么 `n`？

+   以区分多个回合，例如，提议者崩溃，模拟提议

+   想要后续回合取代先前的回合

+   数字允许我们比较早期/晚期

+   `n` 值必须唯一且大致按时间排序

+   `n = <时间，服务器 ID>`

    +   例如，ID 可以是服务器的 IP 地址

+   “回合”与“提议”相同，但与“实例”完全不同

    +   回合/提议号码在特定实例内部

**定义：** 服务器 S *接受* `n/v`

+   它对`accept(n, v)`做出了`accept_ok`响应

**定义：** `n/v`是*被选择的*

+   多数服务器接受了`n/v`

**关键属性：**

+   如果一个值被选择，任何后续选择必须是相同的值

    +   即协议不能改变主意

    +   可能是不同的提议者等，但是相同的值！

    +   这使我们能够在崩溃后自由开始新的轮次

+   棘手的原因是因为*"被选择"*是系统范围的属性

    +   例如多数接受，然后提议者崩溃

        +   **待办事项：** 这里会发生什么？

    +   *没有节点可以在本地告知达成一致*

所以：

+   提议者不会在`prepare`中发送值

    +   **待办事项：** 任何值如何被接受者接受？

+   接受者发送回他们已经接受的任何值

+   如果有提议者，提议者提议该值

    +   为了避免改变现有选择

+   如果没有已经被接受的值，

    +   提议者可以提议任何值（例如客户端请求）

+   提议者必须从多数接收`prepare_ok`

    +   为了确保与任何先前多数的交集，

    +   为了确保提议者听到任何先前选择的值

### 现在协议--请参阅讲义

```
 proposer(v):
      choose n, unique and higher than any n seen so far
      send prepare(n) to all servers including self
      if prepare_ok(n, n_a, v_a) from majority:
        v' = v_a with highest n_a; choose own v otherwise
        send accept(n, v') to all
        if accept_ok(n) from majority:
          send decided(n, v') to all

    acceptor state:
      must persist across reboots
      n_p (highest prepare seen)
      n_a, v_a (highest accept seen)

    acceptor's prepare(n) handler:
      if n > n_p
        n_p = n
        reply prepare_ok(n, n_a, v_a)
      else
        reply prepare_reject

    acceptor's accept(n, v) handler:
      if n >= n_p
        n_p = n
        n_a = n
        v_a = v
        reply accept_ok(n)
      else
        reply accept_reject 
```

**示例 1**（正常操作）：

```
 `S1`, `S2`, `S3` but `S3` is dead or slow

    `S1`: -> starts proposal w/ n=1 v=A
    `S1`: <- p1   <- a1vA    <- dA
    `S2`: <- p1   <- a1vA    <- dA
    `S3`: dead...

    "p1" means Sx receives prepare(n=1)
    "a1vA" means Sx receives accept(n=1, v=A)
    "dA" means Sx receives decided(v=A) 
```

+   S1 和 S2 将回复`p1`消息为`prepare_ok(1, 0, null)`

+   如果`dA`丢失，等待的节点之一可以再次运行 Paxos 并尝试一个比之前更高的新`n`。

    +   `prepare_ok(2, 1, 'A')`的回复将返回，

    +   然后节点被迫发送`a2vA`，希望这次，在节点收到`accept_ok`消息后，它将发送不会再次丢失的`dA`消息

+   当多数接受者在`accept`处理程序中接受分支并接受值时，值被认为被选择

    +   然而，并不是每个人都*知道*这一点，这就是为什么发送`decide`消息的原因

这些图表并不具体说明提议者是谁

+   这并不重要

+   提议者在逻辑上与接受者分开

+   我们只关心接受者看到并回复的内容

请注意，Paxos 只需要大多数服务器

+   因此我们可以继续即使`S3`宕机

+   提议者不能永远等待任何接受者的响应

#### 如果网络分区会发生什么？

+   即`S3`是活动的并且有一个提议的值 B

+   `S3`的准备不会组成多数

#### 作业问题

Paxos 如何确保以下事件序列不会发生？实际发生了什么，最终选择了哪个值？

```
 proposer 1 crashes after sending two accept() requests
  proposer 2 has a different value in mind

  A: p1 a1foo
  B: p1       p2 a2bar
  C: p1 a1foo p2 a2bar

  C's prepare_ok to B really included "foo"
    thus a2foo, and so no problem 
```

**要点：**

+   如果系统已经达成一致，大多数将知道值

+   任何新的准备者的多数将与该多数相交

+   因此后续提议者将了解已经达成一致的值

+   并在接受消息中发送它

**示例 2**（并发提议者）���

```
 A1 starts proposing n=10 by sending prepare(n=10) 
    A1 sends out just one accept v=10
    A3 starts proposing n=11
      but A1 does not receive its proposal
      A3 only has to wait for a majority of proposal responses

    A1: p10 a10v10 
    A2: p10        p11
    A3: p10        p11  a11v11

    A1 and A3 have accepted different values! 
```

会发生什么？

+   **Q：** 如果`A2`收到来自`A1`的`a10v10`接受消息，`A2`会做什么？

    +   `a10v10`表示`accept(n=10,v=10)`，发生在发送`prepare->`并接收到`<-prepare_ok`之后

    +   **A：** A2 会拒绝，因为它有来自`p11`的更高`np`

+   **Q：** 如果`A1`收到来自`A3`的`a11v11`接受消息，`A1`会做什么？

    +   **A:** `A1` 将回复 `ACCEPT_OK` 并将其值更改为 11，因为 `n = 11 > np = 10`

如果 A3 在这一点崩溃（并且不重新启动）会怎样？

这样怎么样：

```
A1: p10  a10v10               p12
A2: p10          p11  a11v11  
A3: p10          p11          p12   a12v10 
```

系统在这一点上是否已经同意了一个值？

#### 什么是提交点？

+   即何时已达成一致意见？

+   即在什么时候更改值会造成灾难？

+   当多数人拥有相同的 `v_a` 之后呢？不会——为什么？以上是反例

+   当多数人有相同的 `v_a/n_a` 之后呢？是的——为什么足够？概述：

    +   假设多数人有相同的 `v_a/n_a`

    +   接受者将拒绝带有较低 `n` 的 `accept()`

    +   对于任何更高的 `n`：准备必须已经看到我们的多数 `v_a/n_a`（重叠）

    +   如果重叠服务器在 `accept(v_a, n_a)` 之前看到了 `prepare(n)` 怎么办？

        +   将拒绝 `v_a/n_a`

        +   因此还没有多数票

        +   提议者可能可以自由选择 `v != v_a`

#### 提议者为什么需要选择具有最高 `n_a` 的 `v_a`？

```
 A1: p10  a10vA               p12
    A2: p10          p11  a11vB  
    A3: p10          p11  a11vB  p12   a12v??

    n=11 already agreed on vB
    n=12 sees both vA and vB, but must choose vB 
```

两种情况：

1.  在 `n=11` 之前已经有多数票了

    +   `n=11` 的准备会看到值并重复使用它

    +   因此 `n=12` 安全地可以重新使用 `n=11` 的值

1.  在 `n=11` 之前没有多数票

    +   `n=11` 可能已经获得了多数票

    +   因此 `n=12` 必须重新使用 `n=11` 的值

#### 准备处理程序为什么要检查 `n > n_p`？

+   它正在进行 `max(concurrent n's)`，对于接受处理程序

+   对所有 `prepare()` 响应 `prepare_ok()` 也是可以的，

    +   但是 `n < n_p` 的提议者无论如何都会被 `accept()` 忽略

#### 接受处理程序为什么要检查 `n >= n_p`？

+   确保达成协议是必要的

+   有一个唯一的最高活跃 `n`

+   每个人都支持最高的 `n`

+   没有 `n >= n_p` 检查，你可能会得到这种糟糕的情况：

情景：

```
 A1: p1 p2 a1vA
    A2: p1 p2 a1vA a2vB
    A3: p1 p2      a2vB 
```

#### 接受处理程序为什么要更新 `n_p = n`？

+   早期的 `n` 被接受所需的数量

+   节点可以获得 `accept(n,v)`，即使它从未看到过 `prepare(n)`

+   没有 `n_p = n`，可以得到这种糟糕的情景：

情景：

```
 A1: p1    a2vB a1vA p3 a3vA
    A2: p1 p2           p3 a3vA
    A3:    p2 a2vB 
```

#### 如果新的提议者选择 `n <` 旧的提议者会怎样？

+   即使时钟未同步

+   无法取得进展，尽管没有正确性问题

#### 如果接受者在接收到接受之后崩溃会怎样？

```
A1: p1  a1v1
A2: p1  a1v1 reboot  p2  a2v?
A3: p1               p2  a2v?

A2 must remember v_a/n_a across reboot! on disk
  might be only intersection with new proposer's majority
  and thus only evidence that already agreed on v1 
```

#### 如果接受者在发送 `prepare_ok` 后重新启动会怎样？

+   它是否必须在磁盘上记住 `n_p`？

+   如果没有记住 `n_p`，可能会发生这种情况：

例子：

```
 `S1`: p10            a10v10
  `S2`: p10 p11 reboot a10v10 a11v11
  `S3`:     p11               a11v11 
```

+   11 的提议者没有看到值 10，因此 11 提出了自己的值

+   但就在那之前，已经选择了 10！

+   因为 `S2` 没有记住忽略 `a10v10`

#### Paxos 能够陷入僵局吗？

+   是的，如果没有可以通信的多数派

+   如果有多数票可用怎么办？

    +   可能会出现活锁：对决的提议者，不断地准备更高的 `n`

        +   尝试选举领导者的一个原因：减少对决的提议者的机会

    +   有单个提议者和可达多数派，应该能够达成共识
