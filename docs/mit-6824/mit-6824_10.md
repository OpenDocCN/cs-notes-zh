# 一致性

# 6.824 2015 年第 10 讲：一致性

**注意：**这些讲座笔记已经从 2015 年春季 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)上发布的笔记略有修改。

**今天：**一致性

+   懒惰释放一致性

+   使用懒惰一致性来提高性能

+   一致性=并发读写的含义

+   比看起来不那么明显！

+   选择在性能和程序员友好性之间进行权衡

    +   许多设计中的重要因素

+   今天的论文：案例研究

许多系统具有具有并发读写器的存储器/内存

+   多处理器，数据库，AFS，实验室

+   您经常希望以可能改变行为的方式进行改进：

    +   添加缓存

    +   分割在多个服务器上

    +   复制以实现容错

+   我们如何知道一个优化是否正确？

+   我们需要一种思考分布式程序正确执行的方法

+   大多数这些想法来自 20/30 年前的多处理器和数据库

我们如何编写正确的共享存储分布式程序？

+   内存系统承诺按照某些规则行事

+   我们编写程序假设这些规则

+   规则是“一致性模型”

+   内存系统与程序员之间的契约

什么构成了一个良好的一致性模型？

+   没有“正确”或“错误”的模型

+   一个模型可能会使编程变得更加困难或更容易

    +   即导致更直观或更模糊的结果

+   一个模型可能更难或更容易实现高效

+   同样也取决于应用程序

    +   例如 网页 vs 内存

一些一致性模型：

+   Spanner：外部一致性（表现得像一台机器）

+   数据库世界：严格的串行化，串行化，快照隔离，读取提交

+   分布式文件系统：打开到关闭一致性

+   计算机架构师：TSO（总存储器排序），释放一致性等等。

+   并发理论：顺序一致性，线性一致性

+   相似的想法，但有时意义略有不同

DSM 是研究一致性的良好起点

+   简单的接口：读取和写入内存位置

+   一致性在架构社区中得到了很好的发展

例如：

```
 x and y start out = 0
  M0:
    x = 1
    if y == 0:
      print yes
  M1:
    y = 1
    if x == 0:
      print yes
  Can they both print "yes"? 
```

DSM 的性能受到内存一致性的限制

+   使用顺序一致性，M0 的写操作必须在 M0 执行读操作之前对 M1 可见

    +   否则 M0 和 M1 都可以读取 0 并打印“是”

    +   （第二个“禁止”示例）

+   因此，在分布式系统中操作将需要一段时间

    +   他们必须逐个完成

Treadmarks 的高级目标？

+   更好的 DSM 性能

+   运行现有的并行代码（多线程）

    +   这段代码已经有锁了

    +   TreadMarks 将在单独的机器上运行每个线程/进程，并允许其访问 DSM。

    +   TreadMarks 利用代码已经使用锁定的优势

他们试图修复以前 DSM 存在的具体问题是什么？

+   **错误共享：**两台机器在同一页上读/写不同的变量

    +   m1 写 x，m2 写 y

    +   m1 写 x，m2 只读 y

    +   **问：**在这种情况下 IVY 做什么？

    +   **答：**Ivy 将页面在 x 和 y 之间来回弹跳

+   **写入放大：** 1 字节写入变成整页传输。

**第一个目标：**消除写放大。

+   不发送整个页面，只发送已写入的字节

### 大想法：写入差异（以解决写入放大问题）。

例子：

```
m1 and m2 both have x's page as readable
m1 writes x
            m2 just reads x 
```

+   在 M1 写入错误时：

    +   告诉其他主机使其失效，但*保留隐藏副本*

    +   M1 也制作了隐藏副本

    +   M1 将页面标记为读/写。

+   在 M2 读取错误时：

    +   M2 请求 M1 的最近修改

    +   M1 将当前页面与隐藏副本进行比较“差异”

    +   M1 将差异发送给 M2

    +   M2 将差异应用于其隐藏的副本。

    +   M2 将页面标记为只读

    +   M1 将页面标记为只读。

**Q：** 写入差异是否提供顺序一致性？

+   最多一个可写副本，因此写入是有序的

+   在任何副本可读时不写入，因此没有旧的读取

+   可读副本是最新的，因此没有旧的读取

+   仍然是顺序一致的。

**Q：** 写入差异是否有助于解决虚假共享问题？

**A：** 不，它们有助于减少写入放大。

下一个目标：允许多个读取者+写入者应对虚假共享

+   我们的解决方案需要允许两台机器写入同一页。

+   `=>` 当一台机器写入时不要使其他机器失效

+   `=>` 不要将写入者降级为只读，当另一台机器读取时。

+   `=>` 页面的多个*不同*副本！

    +   读者应该查看哪个？

+   差异有所帮助：可以合并对同一页的写入

+   但是什么时候发送差异？

    +   没有失效->没有页面故障->什么触发发送差异

...所以我们来到*发布一致性*

### 大想法：（渴望的）发布一致性（RC）

+   *再次：*什么会触发发送差异？

+   看起来我们应该在某人读取更改的数据时发送差异。如果我们不会因为没有使其他人的页面失效而获得读取错误，那么我们怎么知道有人正在读取数据？

+   没有人应该在没有持有锁的情况下读取数据！

    +   所以让我们假设一个锁服务器

+   在释放（解锁）时发送写入差异

    +   对于所有具有写入页面副本的机器

例子：

```
lock()
x = 1
unlock() --> diffs all pages, to detect all the writes since
             the last unlock
         --> sends diffs to *all* machines 
```

**Q：** 为什么检测自上次`解锁（）`以来的所有写入而不是自上次`锁定（）`以来的所有写入？

**A：** 请参阅下面的因果一致性讨论。

示例 1（RC 和虚假共享）

```
x and y are on the same page
ax -- acquire lock x
rx -- release lock x

M0: a1 for(...) x++ r1
M1: a2 for(...) y++ r2  a1 print x, y r1 
```

RC 做什么？

+   M0 和 M1 都获取缓存的可写副本页面

+   当它们释放时，每个都会计算相对于原始页面的差异。

+   `M1`的`a1`导致它等待直到`M0`的`r1`释放。

    +   所以 M1 将会看到 M0 的写入。

**Q：** RC 的性能优势是什么？

+   IVY 对示例 1 做了什么？

    +   如果`x`和`y`在同一页上，页面在`M0`和`M1`之间反弹

+   即使有 1 个或更多个写入，多台机器也可以拥有页面的副本

    +   `=>` 由于虚假共享而导致页面的反弹

    +   `=>` 读取副本可以与写入者共存

**Q：** RC 是否顺序一致？不是！

+   在 SC 中，读取看到最新的写入

+   在 M1 释放锁之前，M1 将不会看到 M0 的写入

    +   即 M1 可能会看到一个旧的 x 的副本，在顺序一致性下是不允许的。

+   因此机器可以暂时在内存内容上存在分歧

+   如果您总是锁定：

    +   锁强制顺序`->`没有旧的读取`->`像顺序一致性一样

**Q：** 如果您不锁定会发生什么？

+   读取可能返回过时的数据

+   对同一变量的并发写入→麻烦

**问：** 如果没有写差异，RC 是否有意义？

+   可能不会：需要差异来协调对同一页的并发写入

### 大想法：惰性释放一致性（LRC）

+   一个问题是当我们`unlock()`时，我们更新了所有人，但并不是每个人都可能需要更改的数据。

+   只向已释放的锁的下一个获取者发送写差异

    +   （即当有人调用`lock()`并且他们需要数据的更新时）

+   比 RC 更懒惰的两个方面：

    +   释放什么都不做，所以也许将工作推迟到将来的释放。

    +   只将写差异发送给获取者，而不是每个人。

示例 2（懒惰）

```
x and y on same page (otherwise IVY avoids copy too)

M0: a1 x=1 r1
M1:           a2 y=1 r2
M2:                     a1 print x,y r1 
```

LRC 是做什么的？

+   M2 询问锁管理器谁是锁 1 的上一个持有者

    +   它是 M1

+   M2 仅向持有锁 1 的上一个请求者请求写差异。

+   即使在同一页上，M2 也看不到 M1 对`y`的修改。

    +   因为它没有使用`a2`获得锁 2。

RC 做什么？

+   RC 会向所有人广播对`x`和`y`的所有更改

IVY 是做什么的？

+   IVY 将使页面失效，并确保只有写入者拥有只写副本。

+   在读取时，写入页变为只读，并由读取者获取数据

**问：** LRC 带来了什么性能提升？

+   如果你没有获取对象的锁，你就看不到对它的更新。

+   `=>`如果你只使用页面上的一些变量，你就看不到对其他变量的写入

+   `=>`网络流量减少

**问：** LRC 是否提供与 RC 相同的一致性模型？

+   **不！** LRC 隐藏了一些 RC 显示的写入

+   注意：如果你正确使用锁，那么你不应该注意到（E）RC 和 LRC 之间的差异。

+   在上面的示例中，RC 向 M2 透露了`y=1`，而 LRC 没有透露

    +   因为 RC 在释放锁时广播更改。

+   所以“M2：print x, y”对于 RC 来说可能打印出新鲜的数据，对于 LRC 来说可能是旧的数据。

    +   取决于 print 是在 M1 释放之前还是之后。

**问：** 如果每个变量在单独的页面上，LRC 是否胜过 IVY？

+   直到程序试图读取数据时，IVY 才会移动数据

    +   所以 Ivy 已经相当懒了

+   罗伯特：只有页面很大时，TreadMarks 才值得

+   还是优于 IVY 加上写差异？

我们认为所有的线程/锁定代码都能与 LRC 一起工作吗？

+   所有程序都会锁定它们读取的每个共享变量吗？

+   论文并没有完全说明，但强烈暗示“不行”！

示例 3（因果异常）

```
M0: a1 x=1 r1
M1:             a1 a2 y=x r2 r1
M2:                               a2 print x, y r2 
```

这里可能存在的问题是什么？

+   M2 可能看到 y=1 但 x=0 的情况是反直觉的

    +   因为 M2 没有获取锁 1，它无法获得对`x`的更改。

“因果一致性”的违反：

+   如果写入 W1 导致写入 W2，每个人在看到 W2 之前都会看到 W1

示例 4（有人认为这是*自然代码*的论点）：

```
M0: x=7    a1 y=&x r1
M1:                     a1 a2 z=y r2 r1  
M2:                                       a2 print *z r2 
```

在示例 4 中，M2 是否会从 M1 那里了解到 M0 也做出了对`y=&x`的贡献的写入，这一点并不清楚。

+   例如，如果`x`在被 M0 更改之前是 1，那么当它打印`*z`时，M2 会看到这一点吗？

TreadMarks 提供**因果一致性**：

+   当你获取一个锁时，

+   你看到上一个持有者的所有写入

+   以及上一个持有者看到的所有写入

如何跟踪哪些写入贡献了写入？

+   编号每台机器的发布 - “间隔”编号

+   每台机器跟踪它从其他每台机器看到的最高写入

    +   最高写入 = 该机器知晓的最后一次写入的间隔号

    +   “向量时间戳”

+   用当前 VT 标记每个释放

+   在获取时，告诉前一个持有者你的 VT

    +   差异指示需要发送哪些写入

+   （注释前面的例子）

+   什么时候可以丢弃差异？

    +   似乎你需要全局知道每个人对什么了解

    +   请参阅论文中的“垃圾收集”部分

VT 通过不同机器对同一变量的写入进行排序：

```
M0: a1 x=1 r1  a2 y=9 r2
M1:              a1 x=2 r1
M2:                           a1 a2 z = x + y r2 r1

M2 is going to hear "x=1" from M0, and "x=2" from M1.
TODO: what about y? 
```

M2 如何知道该做什么？

相同变量的两个值的 VT 是否不能被排序？

```
M0: a1 x=1 r1
M1:              a2 x=2 r2
M2:                           a1 a2 print x r2 r1 
```

### 程序员规则/系统保证的摘要

1.  每个共享变量都受到某个锁的保护

1.  在写入共享变量之前锁定以对同一变量的写入进行排序，否则“最新值”定义不清晰

1.  在读取共享变量之前锁定以获取最新版本

1.  如果读取没有锁定，保证看到为你锁定的变量做出贡献的值

LRC 可能过度劳累的示例。

```
M0: a2 z=99 r2  a1 x=1 r1
M1:                            a1 y=x r1 
```

TreadMarks 将 `z` 发送到 M1，因为它在 VT 顺序中出现在 `x=1` 之前。

+   假设 x 和 z 在同一页上。

+   即使在不同页面上，M1 也必须使 z 的页面无效。

+   但 M1 不使用 z。

+   系统如何理解 z 不需要？

    +   要求锁定你读取的所有数据

    +   `=>` 放宽 LRC 模型的因果部分

**问：** TreadMarks 能否在不使用 VM 页面保护的情况下工作？

+   它使用 VM 来

    +   检测写入以避免制作隐藏副本（用于差异）如果不需要的话

    +   检测对页面的读取 => 知道是否获取差异

+   两者都不是真正关键的

+   因此 TM 不像 IVY 那样依赖 VM

    +   IVY 使用 VM 故障来决定何时移动数据

    +   TM 使用 acquire()/release() 和差异来实现这一目的

### 性能如何？

图 3 显示大部分良好的扩展性

+   这与“好”一样吗？

+   尽管 Water 明显进行了大量的锁定/共享

它们距离最佳性能有多接近？

+   或许图 5 暗示只有约 20% 的脂肪需要减少

LRC 是否胜过先前的 DSM 方案？

+   他们只与自己的稻草人急切释放一致性（ERC）进行比较

    +   不反对已知最佳的先前工作

+   图 9 表明即使对于 Water 来说也没有太大的优势

### DSM 取得成功了吗？

+   协作机器集群取得了巨大成功

+   DSM 并不那么重要

    +   主要理由是对现有线程化代码的透明性

    +   对于新应用程序来说这并不有趣

    +   透明性使高性能难以实现

+   MapReduce 或消息传递或共享存储比 DSM 更常见
