# 乐观主义、因果性、向量时间戳

# 6.824 2015 年第 15 讲：乐观主义、因果性、向量时间戳

**注意：**这些讲座笔记是从 2015 年春季的 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)上稍作修改的。

到目前为止的一致性：

+   *并发*迫使我们思考读/写的含义

+   *顺序一致性：*每个人都看到相同的读/写顺序（IVY）。

+   *释放一致性：*每个人都按解锁顺序看到写入（TreadMarks）。

顺序一致性和释放一致性很慢：

+   一般情况下，必须在每个操作之前询问。

+   IVY：读故障和写故障->向管理器请求。

+   TreadMarks：获取和释放->向锁管理器请求。

+   我们是否可以通过降低一致性来获得更好的性能？

Paxos:

+   同样缓慢；需要几条消息达成一致。

    +   不仅仅是 IVY+TreadMarks

+   同样，“低”可用性

    +   如果没有多数，就没有进展。

+   不适合断开连接的操作。

## 乐观并发控制

+   现在执行操作（例如，读/写缓存副本）

+   以后再检查它是否正常。

+   如果不正常，恢复。

一个简单的例子——乐观的点对点聊天

+   我们每个人都有一个连接到互联网的计算机。

+   当我输入东西时，向每个参与者发送消息。

+   收到消息->添加到聊天窗口的末尾。

图：

```
m0              m1              m2 
\             /\              /\
 \------------/               /
  \                          /
   \------------------------/ 
```

我们在聊天中关心消息顺序吗？

+   网络可能会在不同参与者处以不同顺序传递。

+   乔：答案是 40。

+   弗雷德：不，是 41。

+   爱丽丝：那是正确的

+   或许山姆看到了不同的顺序：

    +   乔：40

    +   爱丽丝：那是正确的

这个例子出了什么问题？

+   爱丽丝根据某些输入“计算”了她的消息。

+   山姆只有在他也看到了这些输入时才能解释。

假设这是一个拍卖聊天程序：

```
Joe         Fred        Alice

$10 -->
            20
          <-- -->  

                 <-- winner is $20 
```

如果有第四个人，山姆：

```
Joe         Fred        Alice               Sam

$10 -->                                   sees $10
            20  
          <-- -->                         does not see $20 

                 <-- winner is $20 -->    sees winner is $20 
```

因此对山姆来说可能没有意义。他的问题是山姆在发送消息时不知道爱丽丝知道什么。

**定义：**`x`在因果上先于`y`

+   如果：

    +   M0 执行`x`，然后 M0 执行`y`。

    +   M0 执行`x`，M0 向 M1 发送消息，M1 执行`y`。

+   [传递闭包](https://zh.wikipedia.org/wiki/%E9%97%B4%E8%B0%8B%E9%9A%94%E5%85%B3)

+   `x`和`y`通常是写入、消息或文件版本。

+   也"`y`在因果上依赖于`x`"。

**定义：**因果一致性

+   如果`x`在因果上先于`y`，则每个人在`y`之前看到`x`。

优缺点：

+   优点：没有单一的主节点

+   缺点：事件上不是总序

### 因果一致性的实现缓慢。

+   每条消息都有一个唯一的 ID。

+   节点保留所有收到的消息 ID 的集合——“历史记录”。

+   发送`m`时，也发送当前历史集。

+   接收者延迟接收到的消息`m`，直到接收到`m`集合中的所有内容。

历史集会变得非常庞大——我们能否缩写？

+   每个节点对其消息进行编号，如 1、2、3 等。

+   按顺序传递每个节点的消息

+   那么历史记录只需要包括每个节点看到的最新编号。

    +   H1/4 意味着也看到了 1、2、3。

+   与历史集不同，此记法不会随着时间增长。

+   称为*向量时间戳*或*版本向量*。

### 向量时间戳

+   每个节点都对其自己的操作进行编号（例如发送的消息，在这种情况下）。

+   VT 是一个数字向量，每个节点有一个槽位。

+   每条消息都附带一个 VT。

+   `VT[i]=x =>` 发送者已看到节点`i`的所有消息，直到`#x`

+   这里的假设是一个节点向所有其他节点广播消息（因为我们正在尝试有效地复制一个系统）

+   必须知道整个系统中有多少个节点

    +   否则，复杂

+   当你有数千台机器时，VTs 会变得非常庞大

VT 比较

+   回答“消息 A 应该在消息 B 之前显示吗？”

+   让`a`和`b`表示与消息`A`和`B`相关联的 VTs

+   我们可以推断因果关系（即`a < b`还是它们是并发的`a || b`）

+   四种情况：`a < b, a || b`

+   如果两个条件成立，则`a < b`：

    1.  对于所有主机`i`：

        +   `a[i] <= b[i]`

            +   即`a`总结了`b`的一个正确前缀

            +   即要么

                +   `b`的发送者和`a`的发送者都看到了来自主机`i`的相同数量的消息

                +   `b`的发送者比`a`的发送者看到了来自主机`i`的更近的消息

    1.  *AND* 存在`j`，使得`a[j] < b[j]`

        +   即`a`在因果上先于`b`

            +   `b`的发送者 *绝对* 看到了来自主机`i`的更近的消息，而`a`的发送者看到的则不是

+   如果：

    +   属于 i，j 的存在：`a[i] < b[i]`且`a[j] > b[j]`

    +   即没有一个总结了另一个的前缀

    +   即没有因果关系的一个在先于另一个

        +   这是因为，正如我们之前所说的，没有完全的顺序

许多系统使用 VT 变体，但用途略有不同

+   TreadMarks，Ficus，Bayou，Dynamo 等

+   简洁地表示“我已经看到了每个人到目前为止的更新”

+   简洁地同意事件`x`是否在事件`y`之前发生

+   我假装这里有一个基本原则

    +   但只有当你站得足够远时才成立

### CBCAST -- "因果广播"协议

+   通用排序协议，适用于点对点聊天

+   来自康奈尔大学 Isis 研究项目

+   关键属性：

    +   将消息以因果顺序交付给各个节点

    +   如果`a`在因果上先于`b`，CBCAST 会先交付`a`

[图表：节点、消息缓冲、VC、聊天应用程序]

```
 APP         ^
         |      |
    -----|------|-----------
        \ /     |  CBCAST
         .   
    ---------      vector
    | m3    |      clock
    ---------      VT 
    | wait  |
    ---------
    | m1    | 
```

+   每个节点保留本地向量时钟，`VC`

    +   `VCi[j] = k`表示节点`i`已经看到了来自`j`的所有消息，直到消息`k`

    +   总结了应用程序也看到的内容

+   在节点`i`上`send(m)`：

    +   `VCi[i] += 1`

    +   `broadcast(m, i, VCi)`

+   在节点`j`上`receive(m, i, mv)`：

    +   `j`的 CBCAST 库缓冲了消息

    +   仅在以下情况下向应用程序发布：

        +   `mv <= VCj`，除非`mv[i] = VCj[i] + 1`

        +   即节点`j`已经看到了在因果上先于`m`的每个消息`VCj[i] = mv[i]`

        +   所以消息将反映`m`的接收

代码：

```
on receive(message m, node i, timestamp v):
    release when:
        this node's vector clock VT >= v EXCEPT FOR v[i] = VT[i] + 1 
```

例如：

```
 All VCs start <0,0,0>
    M0 sends msg1 w/ <1,0,0>
    M1 receives msg1 w/ <1,0,0>
    M1 sends msg2 w/ <1,1,0>
    M2 receives msg2 w/ <1,1,0> -- must delay because don't have msg1
    M2 receives msg1 w/ <1,0,0> -- can process, unblocks other msg 
```

为什么这么快？

+   没有中央管理者，没有全局顺序

+   如果没有因果依赖关系，CBCAST 不会延迟消息

+   例如：

    +   `M0 sends <1,0>`

    +   `M1 sends <0,1>`

    +   接收方可以按任意顺序交付

因果一致性仍然允许比顺序更多的惊喜

+   萨姆仍然可以看到：

    +   乔：40

    +   弗雷德：41

    +   鲍勃：42

    +   爱丽丝：那是正确的

+   她是指 42 还是 41？

+   因果一致性只表示 Alice 的消息将在之后被交付

    +   所有她在发送时看到的消息

+   *不*表示它将在所有她之前没看到的消息之前被交付

    +   如果 CBCAST 先呈现`x`然后是`y`，这并*不*意味着`x`必然发生在`y`之前

TreadMarks 使用 VTs 对不同机器对同一变量的写入进行排序：

```
 M0: a1 x=1 r1    a2 y=9 r2
  M1:              a1 x=2 r1
  M2:                           a1 a2 z=x+y r2 r1

  Could M2 hear x=2 from M1, then x=1 from M0?
  How does M2 know what to do? 
```

VTs 经常用于对复制数据进行乐观更新

+   每个人都有副本，任何人都可以写入

+   不想要 IVY 风格的 MGR 或锁定：网络延迟，故障

+   需要同步副本，仅接受“最新”的数据，检测冲突

+   文件同步（Ficus，Coda，Rumor）

+   分布式数据库（Amazon Dynamo，Voldemort，Riak）

## 文件同步--例如 Ficus

+   多台计算机都有所有文件的副本

+   每个主机都可以修改其本地副本

+   合并更改后--乐观

+   支持断开操作的文件同步

    +   两个人在两架不同的飞机上编辑同一个文件 :)

    +   当它们重新联机时，服务器需要检测到这一点

    +   ...并解决它

    +   ...并不会丢失更新（懒惰的服务器可以简单地丢弃一组更改）

情景：

+   用户在工作、家中、笔记本电脑上都有文件的副本

+   主机可能关闭，飞机上，等等--不总是在互联网上

+   在 `H1` 上工作一段时间，将更改同步到 `H2`

+   在 `H2` 上工作，将更改同步到 `H3`

+   在 `H3` 上工作，同步到 `H1`

+   **总体目标：** 推动更改以保持机器的一致性

约束：不丢失更新

+   只有在同步将版本 `x2` 复制到版本 `x1` 时才可以

    +   `x2` 包括所有在 `x1` 中的更新。

示例 1：

```
 Focus on a single file

  H1: f=1 \----------\
  H2:      \->  f=2   \               /--> ???
  H3:                  \-> tell H2 --/

  What is the right thing to do?
  Is it enough to simply take file with latest modification time?
  Yes in this case, as long as you carry them along correctly.
    I.e. H3 remembers mtime assigned by H1, not mtime of sync. 
```

示例 2：

```
 mtime = 10 | mtime = 20 | mtime = 25

  H1: f=1 --\       f=2              /-->
  H2:        \-->             f=0 --/
  H3: 

  H2's mtime will be bigger.

  Should the file synchronizer use "0" and discard "2"?
    No! They were conflicting changes. We need to detect this case.
    Modification times are not enough by themselves 
```

如果存在并发更新怎么办？

+   以便两个版本都不包含另一个的更新？

+   复制将会丢失其中一个更新

+   因此同步不会复制，宣布“冲突”

+   冲突是乐观写入的必然结果

如何确定一个版本是否包含另一个版本的所有更新？

+   我们可以记录每个文件的整个修改历史。

+   主机名/本地时间对的列表。

+   在主机之间同步时，同时携带历史记录。

+   例如 1：`H2: H1/T1,H2/T2 H3: H1/T1`

+   例如 2：`H1: H1/T1,H1/T2 H2: H1/T1,H2/T3`

+   那么很容易确定版本 `x` 是否包含版本 `y` 的所有更新：

    +   如果 `y` 的历史是 `x` 的历史的前缀。

我们可以使用 VTs 来压缩这些历史记录！

+   每个主机记住每个文件的一个 VT

+   为每个主机的文件写入编号（或分配墙钟时间）

+   只需记住每个主机上最后一次写入的数量

+   `VT[i]=x` => 文件版本包括主机 `i` 的所有更新直到 `#x`

示例 1 的 VTs：

+   在 H1 的更改后：`v1=<1,0,0>`

+   在 H2 的更改后：`v2=<1,1,0>`

+   `v1 < v2`，所以 H2 忽略 H3 的副本（因为 `<` 所以没有冲突）

+   `v2 > v1`，所以 H1/H3 将接受 H2 的副本（再次没有冲突）

示例 2 的 VTs：

+   在 H1 的第一次更改后：`v1=<1,0,0>`

+   在 H1 的第二次更改后：`v2=<2,0,0>`

+   在 H2 的更改后：`v3=<1,1,0>`

+   v3 既不 `<` 也不 `>` v1

    +   因此两者都没有看到对方的所有更新

    +   因此存在冲突

如果存在冲突更新怎么办？

+   VTs 可以检测到它们，但接下来呢？

+   取决于应用程序。

+   *简单难度：* 具有不同不可变消息的邮箱文件，只需合并。

+   *中等难度：* 对 C 源文件的不同行进行更改（diff+patch）。

+   *困难难度：* 对 C 源代码的同一行进行更改。

+   对于困难情况，必须手动进行调和。

+   今天的论文都是关于解决冲突

如何考虑文件同步的 VTs？

+   它们会检测是否存在版本的序列顺序

+   即。当我修改文件时，我是否已经看到了你的修改？

    +   如果是的话，没有冲突

    +   如果没有，则冲突

+   或：

    +   VT（向量时戳）总结了文件的完整版本历史

    +   如果您的版本是我的版本的前缀，则不会冲突

针对文件删除的情况怎么办？

+   如果删除文件，H1 可以忘记文件的 VT 吗？

    +   不：当 H1 与 H2 同步时，它会看起来像 H2 有一个新文件。

+   H1 必须记住已删除文件的 VT。

+   将删除视为文件修改。

    +   `H1: f=1 ->H2`

    +   `H2: del ->H1`

    +   第二次同步看到 `H1:<1,0> H2<1,1>`，因此在 H1 处删除胜出

+   可能会出现删除/写入冲突

    +   `H1: f=1 ->H2 f=2`

    +   `H2: del ->H1`

    +   `H1:<2,0> vs H2:<1,1> -- 冲突`

    +   在 H1 删除是否可以？

如何删除已删除文件的 VTs？

等待所有主机都看到删除消息足够吗？

+   同步将携带，对于已删除的文件，已看到删除的主机集合

“等待所有人都看到删除”行不通：

+   `H1: ->H3 forget`

+   `H2: f=1 ->H1,H3 del,seen ->H1 ->H1`

+   `H3: seen ->H1`

+   `H2 需要重新告诉 H1 有关 f，删除和 f 的 VT`

    +   H2 不知道 H3 已看到删除

    +   因此 H3 可能会与 H1 同步，然后告诉 H1 f 的情况

    +   H1 消失并重新出现是违法的

+   因此 -- 此方案不能可靠地让主机忘记

图表：

```
 | Phase 1              | Phase 2               | Phase 3 (forget f's VT)
H1: del f  \     | seen f  -\->         | done f  -\->          |
H2:         \--> | seen f  -/-> (bcast) | done f  -/-> (bcast)  |
H3:         |--> | seen f  -\->         | done f  -\->          | 
```

来自 Ficus 复制文件系统的工作 VT GC 方案

+   *第 1 阶段：*累积已看到删除的节点集

    +   当 == 所有节点的完整集合时终止

+   *第 2 阶段：*累积已完成第 1 阶段的节点集

    +   当 == 所有节点时，可以完全忘记文件

+   如果 H1 然后与 H2 同步，

    +   H2 必须处于第 2 阶段，或已完成第 2 阶段

    +   如果处于第 2 阶段，H2 知道 H1 曾看到过删除，所以不需要告诉 H1 关于文件的情况

    +   如果 H2 已完成第 2 阶段，它也不知道文件

VTs 的一个经典问题：

+   许多主机 -> 大 VTs

+   VT 很容易比数据大！

+   没有非常令人满意的解决方案

许多文件同步器不使用 VTs -- 如 Unison，rsync

+   如果只有两个当事方，或者星形，文件修改时间足够

+   需要记住“自上次同步以来已修改”

+   如果您想要 > 2 个主机之间的任何到任何同步，则需要 VTs

## 摘要

+   复制 + 乐观更新以提高速度，高可用性

+   因果一致性产生乐观更新的合理顺序（CBCAST）

+   因果排序检测冲突更新

+   向量时间戳简洁地总结了更新历史
