# PNUTS。

# 6.824 2015 年讲座 17：PNUTS。

**注意：** 这些讲义内容稍作修改自 2015 年春季的 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html) 上发布的内容。

# PNUTS。

+   解决相同问题的解决方案 Spanner 和 memcached 解决了。

+   PNUTS 比 Facebook 的 memcache 设计更有原则性。

    +   "它实际上是经过设计的"。

+   使读取快速。

+   优势：由于复制，Web 应用能够进行快速本地读取。

+   缺点：写入会很慢，因为它们需要复制。

+   因为写入必须分布到所有区域，所以在写入发生和更新实际传播之间会有一个基本延迟。

    +   `=>` 可能导致过期读取。

+   如果有数据可能被并发客户端更新，那么多次写入就会有问题。

    +   需要所有区域以相同的顺序看到我们的写入。

图表：。

```
Region R1                        Region R2
---------                        ---------

 W1 Mesage broker                 W1 Message broker
 W2     (replicated)              W2     (replicated)
 W3                               W3
 ..         Tablet controller     ..         Tablet controller
                (replicated)                     (replicated)

    Router1 Router2 ...              Router1 Router2 ...     

    SU1 SU2 SU3 ...                  SU1 SU2 SU3 ... 
```

+   每个区域都有自己的一组 Web 服务器。

+   每个区域都存储所有数据。

+   每个区域中的每个表都在存储单元（SUs）之间分区。

+   路由器知道分区。

+   每个 SU 都有一个磁盘。

## 更新。

+   在 PNUTS 中，每条记录都有自己的主区域，所有写入都必须通过它进行。

    +   与 Facebook 的 memcache 不同，他们有一个 *所有* 记录的主区域。

    +   在 PNUTS 中，每个记录都有一个不同的主人。

    +   注意：记录只是表中的一行（并有一个额外的字段存储其主人）。

+   更新远离用户的区域中的记录将花费更长的时间。

+   Web 服务器如何知道要将更新发送到哪里？

    +   联系一个路由器。

    +   路由器查看密钥，知道它存储在比如说 SU3 中。

    +   从 SU3 获取信息，了解不同区域 `r2` 具有主副本。

        +   不知道 `r2` 处的 SU 中记录的位置。

    +   联系 `r2` 中的一个路由器。

    +   路由器告诉您要将其存储在的 SU。

    +   然后 SU 需要将更新发送到所有其他区域。

    +   SU 将更新发送到消息代理。

        +   不清楚 SU 是否在自己的磁盘上应用更新之前。

    +   消息代理将更新的副本写入磁盘，因为它正在 *承诺* 实际发送更新到每个地方。

        +   很重要，因为我们不希望失败的服务器导致更新部分传播。

    +   MB 将它发送到其他站点的其他 MB。

    +   某种程度上，Web 应用需要找出写入何时完成。

        +   不清楚谁发送 ACK 回来。

        +   看起来 MB 一旦提交更新到磁盘，就会立即回复给 Web 服务器应用程序。

    +   异步写入，因为从 Web 应用的 POV 来看，写入在 MB 将其写入其磁盘时已完成。

    +   MB 为什么不是瓶颈？它必须写入很多东西：

        +   不同的应用程序有不同的消息代理。

        +   MB 可能能够更多地批处理写入。

        +   或许 MB 的写入也比普通数据库写入要简单，普通数据库写入需要修改 B 树，可能要经过文件系统等。

    +   因为他们将所有写入通过一些 MB 进行汇集，他们获得了一些写入的语义。

## 写入语义。

### 对单个记录的写入顺序。

```
Name        Where       What
----        -----       ----
Alice       home        asleep
Bob 
```

+   爱丽丝写下了一个有 3 列（姓名，地点，内容）的记录。

+   爱丽丝的应用程序说`write(what=awake)`

    +   写入通过 PNUTS 进行

+   爱丽丝的应用程序说`write(where=work)`

    +   写入通过 PNUTS 进行

+   PNUTS 提供的有用语义

    +   不同区域的其他人可能会看到

        +   爱丽丝在家里睡着了

        +   爱丽丝在家里醒着

        +   爱丽丝在工作时醒着

    +   其他人不会看到与写入顺序不一致的记录视图

        +   爱丽丝在工作时睡着了

    +   PNUTS 提供的主要一致性语义

    +   通过 MBs 对写入进行排序的结果

    +   论文将此称为*每个记录的时间线一致性*

    +   注意他们的模型限制了他们只能在单个记录基础上进行事务处理

### 什么时候您会关心陈旧数据？

+   在将某物添加到购物车后，您会期望在那里看到它

读取 vs. 陈旧性

```
 read-any(key) -> fast read, just executes the read on the SU and does
                   not wait for any writes to propagate

    read-critical(key, ver) -> returns the read record where ver(record) >= ver
     - useful for reading your own writes
     - true when you have one webpage in a single tab
     - if you update your shopping cart in one tab, then the other tab
       will not be aware of that version number from the first tab

    read-latest(key) -> will always go to the master copy and read the latest
                      data there 
```

### 写入，原子更新

例如：在记录中递增一个计数器

```
 test-and-set-write(ver, key, newvalue) -> always gets sent to the master
        region for the key. look at the version and if it matches provided
        one then update the record with the new value

        // implementing v[k]++
        while true:
            (x, v) = read-latest(k)
            if test-and-set-write(k, v, x+1)
                break 
```

## 今日问题

爱丽丝春假回来后，她：

+   将她妈妈从 ACL 中移除

+   春假照片发布

由于无序写入，她妈妈能看到她的照片吗？

如果爱丽丝把她妈妈能看到的所有照片放在一个记录中，那就不行。

```
Alice   |   ACL     | List of photos
-------- ----------- ----------------
            mom         p7, p99 
```

假设她妈妈正在执行的代码在进行检查时读取完整记录（ACL + 照片），而不是先读取 ACL，等一会儿再读取照片

## 失败

如果 Web 应用服务器在进行一系列写操作时失败，那么只有部分信息会被写入 PNUTS，可能导致数据损坏。

+   没有多个写操作的事务

如果 SU 崩溃并重新启动，它可以从磁盘中恢复，MB 可以继续重试

当 SU 失去其磁盘时会发生什么？它需要恢复数据。

+   论文称 SU 将从另一个区域的 SU 克隆其数据

    +   主要挑战在于 MBs 向正在复制的记录发送更新

    +   更新要么发送到副本源，要么目标副本记住更新

    +   最终他们都需要在最后更新

## 性能

评估主要集中在延迟上，而不是吞吐量。也许这是特定于他们需求的。

不清楚他们如何支持只能每秒进行数百次写操作的 MBs 来满足数百万用户。

为什么他们在进行本地更新时需要 75 毫秒，而所有人都在同一区域？

+   计算，磁盘，网络？

+   对于数据库来说，75 毫秒的写入时间是巨大的

# 6.824 笔记

Brian F. Cooper, Raghu Ramakrishnan, Utkarsh Srivastava, Adam Silberstein, Philip Bohannon, Hans-Arno Jacobsen, Nick Puz, Daniel Weaver 和 Ramana Yerneni. PNUTS: 雅虎的托管数据服务平台。VLDB 会议论文集，2008 年。

为什么这篇论文？

+   与 Facebook/memcache 论文具有相同的基本目标，但设计更有原则性

+   多区域非常具有挑战性--100 毫秒的网络延迟

+   一种在一致性和性能之间的明显权衡

PNUTS 的总体目标是什么？

图表：

```
[world, browsers, data centers] 
```

+   整体故事与 Spanner 和 Facebook/memcache 类似

+   遍布世界各地的数据中心（“区域”）

+   Web 应用程序，例如邮件，购物，社交网络

    +   每个应用程序可能在所有区域运行

+   PNUTS 为应用程序保留状态

    +   每个用户：个人资料，购物车，好友列表

    +   每个项目：图书流行度，用户评论

+   应用程序可能需要任何数据中心的任何数据片段

+   需要处理大量并发更新到不同数据的情况

    +   例如，许多用户必须能够同时向购物车添加项目，因此有数千个 PNUTS 服务器

+   数千台服务器 => 崩溃可能频繁发生

## 概述

图表：

```
3 regions, browsers, web apps, tablet ctlrs, routers, storage units, MBs] 
```

+   每个区域都有所有数据

+   每个表按键在存储单元上分区

    +   平板服务器 + 路由器知道分区计划

为什么在多个区域复制所有数据的副本？

+   多个区域 -> 每个用户的数据地理位置接近用户

+   多个完整副本 -> 可能在整个区域故障时幸存

+   完整副本 -> 快速读取任何内容

    +   因为一些数据被许多用户/许多区域使用

    +   一旦有了多个区域，快速读取非常重要

每个区域复制的缺点是什么？

+   更新将会很慢，需要联系每个区域

+   本地读取可能会过时

+   来自多个区域的更新需要进行排序

    +   保持副本相同

    +   避免顺序异常

    +   不要丢失更新（例如用于计数器的读取-修改-写入）

+   对于他们的用途，磁盘空间可能不是问题

数据和查询模型是什么？

+   基本上是键/值

+   读/写可能按列进行

    +   因此写入可能只替换一个列，而不是整个记录

+   有序表的范围扫描

更新是如何工作的？

+   应用服务器收到 Web 请求，需要在 PNUTS 中写入数据

+   需要更新每个区域！

+   为什么不让应用程序逻辑发送更新到每个区域？

    +   如果应用程序在更新了一些区域后崩溃会怎样？

    +   如果对同一记录进行并发更新会怎样？

PNUTS 为每个记录都有一个“记录主节点”

+   所有更新必须通过该区域进行

    +   每个记录都有一个隐藏列指示记录主节点的区域

+   负责存储单元按记录逐个执行更新

+   告诉 MB 广播更新到所有区域

+   每个记录的主节点可能比 Facebook/memcache 主节点区域更好

因此完整的更新故事（一些猜测）：

应用程序想要更新记录的某些列，知道键

1.  应用程序发送键和更新到本地 SU1

1.  SU1 查找键的记录主节点：SI2

1.  SU1 发送更新请求到 SI2 的路由器

1.  SI2 的路由器将更新转发给本地 SU2 以获取键

1.  SU2 发送更新到本地消息代理（MB）

1.  MB 存储在磁盘上 + 备份 MB，将版本号发送给原始应用程序，MB 如何知道版本号？也许是 SU2 告诉它，或者可能是 SU2（而不是 MB）回复给原始应用程序

1.  MB 发送更新到每个区域的路由器

1.  每个区域更新本地副本

谜题：

+   3.2.1 表示 MB 是提交点

    +   即 MB 写入两个磁盘上的日志，不断尝试传递，为什么 MB 磁盘不是一个糟糕的瓶颈？

+   更新是先到 MB 还是 SU2？还是 SU2 然后 MB？还是 SU2，MB，SU2？

    +   可能是 MB 然后 SU2，因为 MB 是提交点

    +   可能是 SU2 然后 MB，因为 SU2 必须检查它是否是记录的主节点，也许选择新的版本号，尽管可能不需要

+   谁回复客户端并附带新的版本号？

所有写入都是多区域的，因此很慢 -- 为什么这样做有意义？

+   应用程序等待 MB 提交但不等待传播（“异步”）

+   主节点可能是本地的（他们声称 80%的时间是这样）

    +   所以 MB 提交通常会很快

    +   应用/用户往往会很快看到自己的写入

+   仍然，如果主节点是远程的，评估会说 300 毫秒！

+   缺点：非主节点区域的读者可能会看到过时的数据

只读查询如何执行？

+   多种类型的读取（第 2.2 节）——为什么？

+   应用程序可以选择一致性的方式

+   `read-any(k)`

    +   从本地 SU 读取

    +   可能返回过时的数据（即使你刚刚写入！）

    +   为什么：应用需要速度但不关心新鲜度

+   `read-critical(k, required_version)`

    +   如果本地 SU 具有 vers >= required_version，则可能从本地 SU 读取

    +   否则从主节点 SU 读取？

    +   为什么：应用需要看到自己的写入

+   `read-latest(k)`

    +   总是从主节点 SU 读取（? "如果本地副本太陈旧"）

    +   如果主节点是远程的，速度会慢！

    +   为什么：应用需要新鲜数据

如果应用需要递增存储在记录中的计数器怎么办？

+   应用程序读取旧值，本地增加，写入新值

+   如果本地读取产生了过时的数据怎么办？

+   如果读取是 OK 的，但并发更新呢？

`test-and-set-write(version#, new value)` 为您提供对一条记录的原子更新

+   如果当前版本号不等于版本号，则主节点拒绝写入

+   所以如果并发更新，一个会失败并重试

`TestAndSet` 示例：

```
 while(1):
    (x, ver) = read-latest(k)
    if(t-a-s-w(k, ver, x+1))
      break 
```

## 这个问题

+   PNUTS 如何应对示例 1（第 2 页）？

+   最初 Alice 的母亲在 Alice 的 ACL 中，所以母亲可以看到照片

    1.  Alice 从 ACL 中移除她的母亲

    1.  Alice 发布春假照片

+   她的母亲可以看到更新#2 但看不到更新#1 吗？

    +   特别是如果母亲使用的区域与 Alice 不同，或者如果 Alice 从不同的区域进行更新

+   ACL 和照片列表必须在同一条记录中

    +   因为 PNUTS 仅保证对同一条记录的更新顺序

+   Alice 按顺序将更新发送到她记录的主区域

    +   主节点区域按顺序通过 MB 广播

    +   MB 告诉其他区域按顺序应用更新

+   如果 Alice 的母亲怎么办：

    +   读取旧的 ACL，其中包括母亲

    +   读取新的照片列表

    +   答案：只需读取 Alice 的记录一次，包含 ACL 和照片列表

        +   如果记录没有新的 ACL，那么顺序就说它也不能有新的照片

+   存储系统如何会出现这样的问题？

    +   没有通过单一主节点进行排序（例如 Dynamo）

如果没有故障，如何更改记录的主节点？

+   例如 我从波士顿搬到洛杉矶

+   可能只需通过旧主节点更新记录？

    +   因为主区域的 ID 存储在记录中

+   旧主节点通过 MB 宣布更改

+   几次后续更新可能会发送到旧主节点

    +   它会拒绝它们，应用程序重试并找到新的主节点吗？

如果我们想要进行银行转账怎么办？

+   从一个账户（记录）到另一个

+   `t-a-s-w` 可以用于这个吗？

+   多记录更新不是原子的

    +   其他读者可以看到中间状态

    +   其他写入者不被锁定

+   多记录读取不是原子的

    +   可能在转账之前读取一个账户，之后读取另一个账户

Web 应用程序缺乏通用事务是一个问题吗？

+   如果程序员知道要期望它，可能不会

如何容忍故障？

应用服务器在更新集合过程中崩溃

+   不是一个事务，所以只有一些写入会发生

+   但主 SU/MB 要么得到了每次写入，要么没有

    +   因此每次写入都会在所有地区发生，或者都不发生

SU 短暂宕机，或网络暂时中断/丢包

+   （我猜测，可能错误）

+   MB 会不断尝试直到 SU 确认

    +   SU 在安全写入磁盘之前不应该发送 ACK

SU 丢失磁盘内容，或不会自动重启

+   应用程序可以从远程地区读取吗？

    +   论文没有提到

+   需要从其他地区的 SU 恢复磁盘内容

    1.  订阅 MB 订阅，并暂时保存它们

    1.  从另一个地区的 SU 复制内容

    1.  重放保存的 MB 更新

+   谜题：

    +   如何确保我们没有错过此 SU 的任��� MB 更新？

        +   例如，订阅 MB 在时间=100，但源 SU 只看到了 90？

    +   会重放应用更新两次吗？这有害吗？

    +   论文提到通过 MB 发送检查点消息

        +   可能在检查点到达时获取副本副本

        +   并且只在检查点之后重放

        +   但没有多个地区的 MB 流之间的排序

MB 在接受更新后崩溃

+   在 ACK 之前将日志写入两个 MB 服务器的磁盘

+   恢复查看日志，（重新）发送记录的消息

+   记录主 SU 可能在 MB 在 ACK 之前崩溃时重新发送更新

    +   可能记录版本号将允许 SU 忽略重复

MB 是一个很好的想法

+   原子性：更新所有副本，或者不更新

    +   而不是应用服务器更新副本（崩溃...）

+   可靠：不断尝试，以应对暂时的 SU/地区故障

+   异步：应用程序无需等待写入完成，适用于广域网

+   有序：即使有多个写入者，也保持副本相同

记录的主地区失去网络连接

+   其他地区可以指定替代 RM 吗？

    +   不：原始 RM 的 MB 可能已记录更新，只发送了一部分

+   其他地区必须无限等待吗？是的

    +   这是有序更新/严格一致性的代价之一

## 评估

评估侧重于延迟和扩展性，而不是吞吐量

5.2：繁忙时插入所需时间

+   取决于记录主的距离有多远

+   RM 本地：75.6 毫秒

+   RM 附近：131.5 毫秒

+   RM 其他海岸：315.5 毫秒

5.2 在测量什么？从什么到什么？

+   可能 Web 服务器开始插入，RM 回复新版本？

+   不是 MB 传播到所有地区的时间

    +   因为本地 RM 不会比远程 `<` 

为什么是 75 毫秒？

75 毫秒是网络光速延迟吗？

+   不：本地

75 毫秒主要是排队等待其他客户端操作吗？

+   不：他们暗示 100 个客户端是不会导致延迟上升的最大值

5.2 结尾暗示 75 毫秒中有 40 毫秒在 SU 中

+   为什么可能需要 40 毫秒？

    +   每个键/值是一个文件吗？

    +   创建一个文件需要 3 次磁盘写入（目录，inode，内容）？

+   另外的 35 毫秒是什么？

    +   MB 磁盘写入？

但“有序表”（MySQL/Innodb）只有 33 毫秒（不是 75）

+   更接近我们期望的一个或两次磁盘写入

5.3 / 图 3：增加请求速率的影响

+   对于 x 轴请求速率，y 轴延迟的图表我们期望什么？

    +   系统具有某种固有容量，例如总磁盘寻道/秒

    +   对于较低速率，恒定延迟

    +   对于更高的速率，队列迅速增长，平均延迟急剧增加

+   爆炸应该接近硬件的最大容量

    +   例如 # 磁盘臂 / 寻道时间

+   我们在图 3 中没有看到这一点

    +   显然他们的客户端无法产生太大的负载

    +   第 5.3 节结束时说客户端太慢了

    +   在 >= 75 ms/op 时，300 个客户端 -> 大约 4000/sec

+   文本说最大可能的速率约为每秒 3000 次

    +   10% 的写入，因此每秒 300 次写入

    +   每个区域 5 个 SU，因此每秒 60 次写入/SU

    +   如果每次写入都执行随机磁盘 I/O，则大约合适

    +   但是您将需要大量的 SUs 来支持数百万活跃用户

回顾一下，PNUTS 的关键设计决策是什么？

1.  在多个区域复制所有数据

    +   读取速度快，写入速度慢

1.  松散的一致性 -- 陈旧的读取

    +   因为写入速度慢

1.  只有单行事务带有测试和设置写入

1.  将所有写入都按照主区域的顺序排序

    +   优点：保持副本相同，强制更新的序列顺序，易于理解

    +   缺点：慢，如果主区域断开连接则没有进展

下一步：Dynamo，一个非常不同的设计

+   异步复制，但没有主服务器

+   最终一致性

+   总是允许更新

+   如果网络分区，则版本树

+   读者必须调和版本
