# DSM 和顺序一致性

# 6.824 2015 年第 9 讲：DSM 和顺序一致性

**注意：** 这些讲义稍作修改，来自 2015 年春季的 6.824 课程网站上发布的讲义。

**主题：** 分布式计算

+   在分布式机器上进行并行计算

+   4 篇关于如何使用一组机器解决大型计算问题的论文

    +   我们已经阅读了其中一个：MapReduce

+   另外 3 篇论文（IVY、TreadMarks 和 Spark）

    +   两者提供通用内存模型

    +   Spark 类似于 MapReduce 风格

## 分布式共享内存（DSM）编程模型

+   采用多处理器提供的相同编程模型

+   程序员可以使用锁和共享内存

    +   程序员熟悉这种模型

    +   例如，像 goroutines 一样共享内存

+   通用型

    +   例如，不像 MapReduce 那样有限制

+   在多处理器上运行的应用程序可以在 IVY/TreadMarks 上运行

**挑战：** 分布式系统没有物理共享内存

+   在一组廉价机器的网络上

    +   [图示：LAN，带有 RAM 的机器，MGR]

图示：

```
 *----------*   *----------*   *----------*
    |          |   |          |   |          |
    |          |   |          |   |          |
    |          |   |          |   |          |
    *-----*----*   *-----*----*   *-----*----*
          |              |              |
  --------*--------------*--------------*-------- LAN 
```

图示：

```
 M0             M1
    *----------*   *----------*   
    | M0 acces |   | x x x x  |   
    |----------|   |----------|
    | x x x x  |   | M1 acces |   
    *-----*----*   *-----*----*   
          |              |        
  --------*--------------*------- LAN

  The 'xxxxx' pages are not accesible locally,
  they have to be fetched via the network 
```

**方法：**

+   使用硬件支持的虚拟内存模拟共享内存

+   用 2 台机器阐明的一般思路：

    +   地址空间的一部分映射到 M0 的物理内存的一部分

        +   在 M0 上，映射为 M0 的物理页

        +   在 M1 上，映射为不存在

    +   地址空间的一部分映射到 M1 的物理内存的一部分

        +   在 M0 上，映射为不存在

        +   在 M1 上，映射到其物理内存

+   M1 上的应用程序线程可能引用位于 M0 上的地址

    +   如果线程 LD/ST 到那个“共享”地址，M1 的硬件将发生页错误

        +   因为页被映射为不存在

    +   操作系统将页错误传播到 DSM 运行时

    +   DSM 运行时可以从 M0 获取页面

    +   M0 上的 DSM，将页映射为不存在，并将页发送到 M1

    +   M1 上的 DSM 从 M0 接收到，将其复制到内存的某处（比如地址 4096）

    +   M1 上的 DSM 将共享地址映射到物理地址 4096

    +   DSM 从页错误处理程序返回

    +   硬件重试 LD/ST

+   运行多线程代码而无需修改

    +   例如矩阵乘法、物理模拟、排序

**挑战：**

+   如何高效实现它？

    +   IVY 和 Treadmarks

+   如何提供容错性？

    +   许多 DSM（分布式共享内存系统）对此进行了折中处理

    +   一些 DSM 定期对整个内存进行检查点

    +   我们在谈论 Spark 时会回到这个问题上

**正确性：一致性**

+   在优化性能之前，我们需要明确什么是正确的

    +   优化应该保证正确性

+   比看起来不那么明显！

    +   选择在性能和程序员友好性之间权衡

    +   这在许多设计中是一个巨大的因素

    +   更多内容将在下一讲中介绍

+   今天的论文假设了一个简单的模型

    +   分布式内存应该表现得像单一内存

    +   Load/stores 类似于实验 2-4 中的 put/gets

**示例 1：**

```
 x and y start out = 0

  M0:
    x = 1
    if y == 0:
      print yes
  M1:
    y = 1
    if x == 0:
      print yes

  Can they both print "yes"? 
```

幼稚的分布式共享内存

**图示 1：**

+   M0、M1、M2、LAN

+   每台机器都有所有内存的本地副本

+   读取：来自本地内存

+   写入：向其他主机发送更新消息（但不等待）

+   快速：从不等待通信

这种天真的记忆是否有效？

+   它会对 示例 1 做什么？

    +   它可能会失败，因为 M0 和 M1 在到达它们的 `if` 语句时可能无法看到写入，因此它们都会打印*是*。

+   天真的分布式内存快速但不正确

图表（破碎的方案）：

```
 M0
    *----------*   *----------*   *----------*
    |          |   |          |   |          |
    |        ------------------------> wAx   |
    |        ----------> wAx  |   |          |
    *-----*----*   *-----*----*   *-----*----*
          |              |              |
  --------*--------------*--------------*-------- LAN 
```

+   M0 在本地写入并在完成后告知其他机器

+   想象一下，如果每台机器都运行一个将地址 A 处的值增加 3 次的程序，您将获得什么输出

一致性=*顺序一致性*

+   当你有多个进程时，“读取看到*最新*写入”的表述不够清晰

+   需要更加精确地确定正确性

+   顺序一致性意味着：

    +   任何执行的结果都与如果相同

        +   所有处理器的操作按某种顺序（总顺序）执行

        +   并且每个单独处理器的操作以其程序指定的顺序出现在此顺序中

            +   （如果 P 在 B 之前说 A，那么在该顺序中不能有 B; A; 出现）

        +   并且读取在总顺序中看到上次写入

+   必须存在某些操作的总顺序，使得

    1.  每台机器的指令按顺序出现在顺序中

    1.  所有机器看到与该顺序一致的结果

        +   即读取以顺序中的最新写入为准

+   单个共享内存的行为

顺序一致性是否会导致我们的示例获得直观的结果？

顺序：

```
 M0: Wx1 Ry?
  M1: Wy1 Rx? 
```

+   系统需要将这些合并为一个顺序，并保持每台机器操作的顺序。

+   所以有几种可能性：

    +   `Wx1 Ry0 Wy1 Rx1`

    +   `Wx1 Wy1 Ry1 Rx1`

    +   `Wx1 Wy1 Rx1 Ry1`

    +   其他人也是，但都是对称的吗？

+   什么是被禁止的？

    +   `Wx1 Ry0 Wy1 Rx0` -- Rx0 读取未看到前面的 Wx1 写入（天真的系统这样做了）

    +   `Ry0 Wy1 Rx0 Wx1` -- M0 的指令顺序错误（一些 CPU 这样做）

Go 的内存一致性模型

+   Go 对示例的语义是什么？

+   Go 将允许两个 goroutine 都打印“是”！

+   Go 的竞争检测器无论如何都不会喜欢示例程序

+   程序员*必须*使用锁定/通道来获取合理的语义

+   Go 不要求硬件/DSM 实现严格一致性

+   关于更弱一致性的详细内容将于星期四讨论

示例：

```
x = 1
y = 2 
```

+   如果线程 A 看到了对 y 的写入，Go 的内存模型告诉你线程 A 是否会看到对 x 的写入

    +   在 Go 中，如果 y 已被写入，就不能保证 x 的写入会被看到

顺序一致性的简单实现

获得顺序一致性的一种直接方法：在两台或三台机器之间添加一个管理器，将它们的指令交错执行

```
 *----------*   *----------*   
    |          |   |          |   
    |          |   |          |   
    |          |   |          |   
    *-----*----*   *-----*----*   
          |              |        
  --------*--------------*--------
                 |
                 |
           *----------*
           | inter-   |
           | leaver   |
           |          |
           *-----*----*
                 |
                -*-
                \ /
                 .
                RAM 
```

**图表 2：**

```
 *----------*   *----------*   
    |          |   |          |   
    |          |   |          |   
    |          |   |          |   
    *-----*----*   *-----*----*   
          |              |        
  --------*--------------*--------
                 |
                 |
           *----------*
           |          |
           |          |
           |          |
           *-----*----*
                 |
                -*-
                \ /
                 .
                RAM 
```

+   单个内存服务器

+   每台机器按顺序将 r/w 操作发送到服务器，等待回复

+   服务器从等待操作中选择顺序

+   服务器逐个执行，发送回复

+   大的思路：

    +   如果人们只是读取一些数据，我们可以在所有人上复制它

    +   如果有人写入数据，我们需要阻止其他人写入它

        +   所以我们借鉴了其他人的记忆

这种简单的实现将会很慢

+   单个服务器将会过载

+   没有本地缓存，因此所有操作都等待服务器

这让我们谈到了 **IVY**

+   IVY：耶鲁大学集成共享虚拟内存

+   共享虚拟内存系统中的内存一致性，Li 和 Hudak，PODC 1986

IVY 的大局观

```
 [diagram: M0 w/ a few pages of mem, M1 w/ a few pages, LAN] 
```

+   操作内存页，存储在机器 DRAM 中（没有内存服务器）

+   每个页面都存在于每台机器的虚拟地址空间中

+   每台机器上，页面可能无效、只读或读写

+   使用虚拟内存硬件拦截读取/写入

不变量：

+   页面要么是：

    +   在一个机器上读/写，所有其他机器无效；或

    +   在 $\geq 1$ 台机器上只读，无读写

+   在无效页面上的读取故障：

    +   降级 R/W（如果有的话）为 R/O

    +   复制页面

    +   标记本地副本 R/O

+   在只读页面上的写故障：

    +   使所有副本无效

    +   标记本地副本 R/W

IVY 允许在写入之间存在多个读取者副本

+   为了速度 - 本地读取速度快

+   不需要强制读取顺序，该顺序发生在两次写入之间的读取中

+   让它们同时发生 - 每个读者都有页面的副本

为什么在写入之前必须使所有副本无效？

+   一旦写入完成，所有后续读取*必须*看到新数据

+   否则，我们会破坏我们的示例，并且无法获得顺序一致性

IVY 在示例中的表现如何？

+   即，M0 和 M1 可以同时打印 “是” 吗？

+   如果 M0 看到 y == 0，

    +   M1 尚未将其写入 y（无陈旧数据 == 读取先前写入的数据），

    +   M1 尚未读取 x（每台机器按顺序），

    +   M1 必须看到 x == 1（无陈旧数据 == 读取先前写入的数据）。

消息类型：

+   [不要在板上列出这些，仅供参考]

+   RQ 读取查询（读取者到管理器（MGR））

+   RF 读取转发（MGR 到所有者）

+   RD 读取数据（所有者到读取者）

+   RC 读取确认（读取者到 MGR）

+   等等

（参见 ivy-code.txt 网站上的文件）

情景 1：M0 有可写副本，M1 想要读取

**图 3：**

```
 [time diagram: M 0 1] 
```

1.  M1 尝试读取得到页面错误

    +   因为必须将页面标记为无效，所以 M0 拥有它以进行 R/W（请参阅前面描述的不变量）

1.  M1 发送 RQ 到 MGR

1.  MGR 将 RF 发送到 M0，MGR 将 M1 添加到 `copy_set`

    +   什么是 `copy_set`？

    +   “`copy_set` 字段列出了所有具有页面副本的处理器。这允许执行无需广播的失效操作。”

1.  M0 标记页面为 $access = read$，发送 RD 到 M1

1.  M1 标记 $access = read$，发送 RC 到 MGR

情景 2：现在 M2 想要写入

**图 4：**

```
 [time diagram: M 0 1 2] 
```

1.  M2 上的页面故障

1.  M2 发送 WQ 到 MGR

1.  MGR 发送 IV 到 copy_set（即 M1）

1.  M1 发送 IC 消息到 MGR

1.  MGR 将 WF 发送到 M0，设置 owner=M2，copy_set={}

1.  M0 向 M2 发送 WD，访问=无

1.  M2 标记 r/w，发送 WC 到 MGR

**Q：** 如果两台机器同时想要写入同一页怎么办？

**Q：** 如果一台机器在所有权转移时刚好读取了怎么办？

IVY 是否提供严格一致性？

+   不：MGR 可能按照与发出时间相反的顺序处理两个 ST

+   不：ST 可能需要很长时间来撤销其他机器上的读取访问权限

    +   因此 LDs 可能长时间获取到过时的数据，之后才发出 ST

如果没有 IC 消息会怎样？

**待办事项：** IC 是什么？

+   （这是新问题）

+   即 MGR 没有等待副本持有者确认？

没有 WC？

**待办事项：** WC 是什么？

+   （这曾经是问题）

+   例如，MGR 在将 WF 发送到 M0 后解锁？

+   MGR 将后续的 RF，WF 发送到 M2（新所有者）

+   如果这样的 WF/RF 在 WD 之前到达 M2 会怎样？

    +   没问题！M2 在获得 WD 之前一直锁定`ptable[p].lock`

+   RC + `info[p].lock`防止 RF 被 WF 超越

+   因此不清楚为什么需要 WC！

    +   但我对这个结论不太有信心

如果没有 RC 消息会怎样？

+   即 MGR 在发送 RF 后解锁？

+   RF 是否会被后续的 WF 超越？

+   或者受后续 IV 的限制？

IVY 在哪些情况下表现良好？

1.  页面被许多机器读取，但没有被写入

1.  每次只有一台机器写入页面，其他机器根本不使用

IVY 以响应不断变化的使用模式移动页面的方式很酷

例如，页面大小为 4096 字节是好还是坏？

+   如果有空间局部性，即程序查看大块数据会怎样？

+   如果程序只在一页中写入少量字节会怎样？

    +   后续��取者为了获取一些新字节而复制整个页面

+   如果存在虚假共享会很糟糕

    +   即两个不相关的变量在同一页上

        +   并且至少有一个频繁写入

    +   页面将在不同机器之间反弹

        +   即使只读取不变量的用户也会收到失效

    +   即使这些计算机从不使用相同的位置

IVY 的表现如何？

+   毕竟，目的是通过并行性获得加速

在性能方面，我们能期望什么是最好的？

+   在 N 台机器上，速度提高 N 倍

什么可能阻止我们获得 N 倍速度提升？

+   应用程序固有地不可扩展

    +   不能分割成并行活动

+   应用程序通信的字节数太多

    +   因此，网络阻止了更多机器产生更多性能

+   对共享页面进行太多小读/写

    +   即使字节数很少，IVY 也会使其变得昂贵

它们的表现如何？

+   图 4：对于 PDE（偏微分方程）几乎是线性的

+   图 6：排序对于非常次线性

    +   对一个巨大数组进行排序涉及移动大量数据

    +   几乎肯定会至少将所有数据通过网络传输一次

+   图 7：矩阵乘法几乎是线性的

+   一般来说，当读取大量页面时，你最终会受到网络吞吐量的限制

为什么排序表现不佳？

+   这是我的猜测

+   N 台机器，数据分为 2*N 个分区

+   第 1 阶段：对于 N 台机器，本地排序 2*N 个分区

+   第 2 阶段：2N-1 次合并分裂；每轮次将所有数据发送到网络

+   第 1 阶段可能会获得线性速度提升

+   第 2 阶段可能不会 -- 受限于局域网速度

    +   同样，更多机器可能意味着更多轮次

+   因此对于少量机器，本地排序占主导地位，更多机器有助于提高性能

+   对于大量机器，通信占主导地位，更多机器并不会有所帮助

+   此外，更多机器从 n*log(n)本地排序转移到 n² 冒泡式排序

如何加快 IVY 的速度？

+   下一堂课：放宽一致性模型

    +   允许多个写者写入同一页！

论文介绍称 DSM 包含 RPC -- 这是真的吗？

+   何时 DSM 比 RPC 更好？

    +   更透明。更易编程。

+   何时 RPC 更好？

    +   隔离。控制通信。容忍延迟。

    +   可移植性。定义自己的语义。

    +   抽象？

+   在您的 DSM 系统中可能仍然希望使用 RPC 吗？ 为了高效的休眠/唤醒？

第 3.1 节伪代码中的已知问题

+   故障处理程序必须等待所有者发送 `p` 然后再向管理器确认

+   如果所有者具有只读页面并且发生写入错误，则会发生死锁

    +   令人担忧的是没有明确的顺序 `ptable[p].lock` 与 `info[p].lock`

    +   待办事项：嗯？

+   编写服务器/管理器必须设置 `owner = request_node`

+   故障处理程序的管理器部分不会向所有者请求页面

+   处理失效请求是否持有 `ptable[p].lock`？

    +   可能不行 -- 死锁
