# Raft

# 6.824 2015 讲座 6：Raft

**注意：**这些讲座笔记稍作修改，来自 Spring 2015 的 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)上发布的笔记。

## 本讲座：Raft

+   更大的主题是通过复制的状态机实现容错性

+   Raft--比直接的 Paxos 设计更完整

Raft 概述：

```
 clients -> leader -> followers -> logs -> execution 
```

### Raft 与 Paxos 有何不同？

+   我们使用 Paxos：

    +   对每个客户端操作分别达成一致意见

+   Raft：

    +   对每个新领导者（和日志尾部）都达成一致意见

    +   大多数客户端操作不需要协议

    +   Raft 是为日志附加而优化的 Paxos（多多少少）

+   为什么要 Raft 风格的领导者？

    +   没有*对决提议者*（除非领导者失败）

        +   领导者只告诉其他人要做什么

    +   较少的消息，较少的复杂性（除非领导者失败）

    +   有一个日志比另一个日志更完整的明确定义的概念

        +   简化了切换领导者（也许还有崩溃恢复）

        +   在 Paxos 中很难找到这个解决方案，因为日志有“空洞”

### 关于可理解性呢？

+   你必须自己决定

+   直接的 Paxos 比 Raft 更简单

+   但直接的 Paxos 对于实际复制来说太简单了

    +   每个人都以自己的方式扩展它

    +   并最终得到了更多或更少像 Raft 的东西

+   Paxos+日志+领导者可能不比 Raft 简单

    +   虽然可能取决于您选择了哪个 Paxos 变体

更直接地使用 Paxos（如实验室 3）是否曾经是一种成功？

+   即 Raft 风格的领导者是否永远是一个坏主意？

+   地理分布的对等体

+   单个领导者离某些客户端很远

+   一些对等体会比其他对等体慢（Paxos 容忍滞后）

让我们从没有领导变更的 Raft 开始

+   目前，可靠的领导者

+   跟随者可能慢或无法访问（但它们不会丢失状态）

+   我们想要什么？

    1.  容忍*少数失败的跟随者*

    1.  活跃的跟随者和死去的跟随者*在相同的日志上聚合*，因为复制需要相同的执行顺序

    1.  *仅在无法丢失条目*（已提交）时执行，因为无法轻松撤消执行或回复客户端

+   确保相同日志的想法：

    +   领导者发送*日志条目*，*索引*和有关*上一个*条目的信息

    +   客户端可以拒绝（例如我没有上一个条目！）

    +   领导者为该跟随者备份，发送较早的条目

        +   领导者强制跟随者的日志与领导者的日志相同

+   执行的想法：

    +   思路＃1 表示领导者知道跟随者在某个时刻是相同的

    +   一旦大多数达到某一点相同，

        +   领导者将其发送为提交点，

        +   每个人都可以通过那个点执行，

        +   领导者可以回复客户端

### 如果领导者崩溃怎么办？

+   其他服务器超时（一段时间没有 AppendEntries“心跳”）

+   如果其他服务器丢失心跳，它们开始怀疑领导者是否已下降

    +   无法真正确定网络上的领导者是下降/上升的

+   选择新领导者！

+   Raft 将时间划分为术语

+   大多数术语都有领导者

### 切换到新领导者时存在哪些危险？

+   两个领导者

+   没有领导者

+   可能会忘记已执行的日志条目

+   日志可能最终不同（分歧）

首先讨论领导者选举，然后是术语边界的日志一致性

### 如何确保一个任期内最多只有一个领导者？

+   （查看图 2，RequestVote RPC 和服务器规则）

+   领导者必须从大多数服务器获得投票

+   **规则：**服务器每个任期只能投一票

+   因此最多只有一个服务器可能认为自己赢了

+   为什么需要多数？

    +   答案总是一样的！

    +   “要求多数意味着不要求少数”

    +   允许容错（少数失败不会阻碍进展）

    +   防止分裂大脑（最多只有一个候选人可以获得多数票）

    +   确保重叠（大多数中至少有一个拥有每个先前提交的日志条目）

选举可能无法选择任何领导者吗？

+   是的！

    +   > = 3 个候选人平均分裂投票，或者甚至数量的活动服务器，两个候选人各获得一半

### 如果在一次选举中没有人获得多数票会发生什么？

+   超时，增加任期，新选举

+   当服务器决定可能想成为候选人时，首先会等待一个随机延迟，只有在没有收到其他人的消息时才会成为候选人

+   更高的任期优先，较旧任期的候选人退出

+   注意：超时必须比完成选举所需的时间长！

+   注意：这意味着一些任期可能没有领导者，没有日志条目

### Raft 如何减少由于分裂投票而导致选举失败的机会？

+   每个服务器在开始候选人身份之前都会延迟一段随机时间

+   随机延迟为什么有用？

    +   [查看服务器延迟到期时间的时间图]

    +   一个将选择最低随机延迟

    +   希望在下一个延迟到期之前有足够的时间进行选举

    +   这个想法在分布式系统中经常出现

图表：

```
 20 ms                   50 ms             80 ms
|-------------*-----------------------*-----------------*-----------|
              S1                     S2                S3 
```

### 如何选择随机延迟范围？

+   太短：第二个候选人在第一个候选人完成之前开始

+   太长：领导者失败后系统空闲太久

+   一个大致的指导：

    +   假设完成无阻挡选举需要 10ms

    +   并且有五个服务器

    +   我们希望延迟相隔（比如）20ms

    +   因此随机延迟从 0 到 100ms

    +   再加上几个领导者心跳间隔的倍数

记住这个随机延迟的想法！

+   这是一种经典的分散式软选举方案；例如以太网

Raft 的选举遵循一个常见模式：将安全性与进展分开

+   *硬*机制确保一个任期内 `< 2` 个领导者

    +   问题：选举可能失败（例如 3 路分裂）

+   解决方案：在新任期中始终启动新选举是安全的

    +   问题：重复的选举可能阻止任何工作的进行

+   解决方案：*软*机制降低浪费选举的概率

    +   来自领导者的心跳（提醒服务器不要开始选举）

    +   超时期限（不要太早开始选举）

    +   随机延迟（给一个领导者时间来当选）

**记住：**有一种方法可以将问题分为“安全/正确性”和“活性/性能”两个方面

### 如果旧领导者不知道新领导者当选了怎么办？

+   可能是因为旧领导者没有看到选举消息

+   新领导者意味着大多数服务器已经增加了 currentTerm

    +   因此旧领导者（带有��任期）无法为 AppendEntries 获得多数票

    +   尽管少数可能接受旧服务器的日志条目...

    +   因此，在旧任期结束时日志可能会分歧...

现在让我们转换话题到**数据处理**在任期边界

我们想要确保什么？

+   每个服务器按相同的顺序执行相同的客户端命令

    +   即如果任何服务器执行，则没有其他服务器为该日志条目执行其他操作

+   只要有单一的领导者，我们已经看到它使日志相同，当领导者改变时怎么办？

什么是危险？

第 3 任期的领导人在发送 `AppendEntries` 时崩溃

```
S1: 3
S2: 3 3
S3: 3 3
S2 and S3 might have executed; does Raft preserve it? 
```

可能是一系列崩溃，例如

```
S1: 3
S2: 3 3 (new leader) 4
S3: 3 3                (new leader) 5 
```

因此相同索引的不同条目！

回滚是一个大锤子 -- 强制领导者的日志在所有人身上

+   在上述示例中，谁被选举谁就会强加日志给所有人

+   例如：

    +   S3 被选为第 6 任期的新领导人

    +   S3 想要发送一个新条目（在第 6 任期）

        +   `AppendEntries` 表示前一个条目必须有 term 5

    +   S2 回复 false（`AppendEntries` 步骤 2）

    +   S3 减少了 `nextIndex[S2]`

    +   S3 发送 `AppendEntries` 以 term=5 的操作，表示 prev 的 term=3

    +   S2 删除了来自 term 4 的操作（`AppendEntries` 步骤 3）并替换为来自 S3 的第 5 任期的操作（S1 拒绝了，因为它在该条目中没有任何内容）

        +   S2 也为第 6 任期设置操作

好的，领导人将强制其自己的日志传给追随者

+   但这还不够！

+   回滚能删除一个已执行的条目吗？

何时执行日志条目？

+   当领导者推进 `commitIndex/leaderCommit` 时

+   当多数人与领导者一直匹配到这一点时

新领导人能否撤销上一任期末执行的条目？

+   即新领导人的日志中可能缺少已执行的条目吗？

+   Raft 需要确保新领导人的日志包含每个可能执行的条目

+   即必须禁止选举可能缺少已执行条目的服务器

选举规则是什么？

+   图 2 表示只有在候选人的日志“至少与最新”时才投票

+   因此，领导人将*至少与大多数一样更新*

“至少与最新”是什么意思？

这是否意味着日志的长度 >=？不，例如：

```
S1: 5, (leader) 6, (crash + leader) 7,
S2: 5                                  (leader) 8  
S3: 5                                           8 
```

+   首先，这种情况可能发生吗？怎么样？

    +   S1 是第 6 时代的领导者；崩溃+重启；第 7 时代的领导者；崩溃并停留在原地

        +   两次它仅在追加到自己的日志后崩溃

    +   S2 是第 8 时代的领导者，只有 S2 和 S3 存活，然后崩溃

+   谁应该成为下一任领导人？

    +   S1 拥有最长的日志，但是条目 8 已经提交！！！

        +   Raft 采用领导者的日志，因此 S1 作为领导者 -> 未提交的条目 8

        +   这样做是不正确的，因为 S2 可能已经回复给客户端

    +   因此新领导人只能是 S2 或 S3 中的一个

    +   即规则不能简单地是“最长的日志”

第 5.4.1 节的结尾解释了“至少与最新”投票规则

+   比较最后一个条目

+   较高的任期胜出

+   如果相等的话，更长的日志胜出

所以：

+   S1 无法从 S2 或 S3 获得任何投票，因为 `7 < 8`

+   S1 将投票给 S2 或 S3，因为 `8 > 7`

+   S1 的来自第 6 和第 7 任期的操作将被丢弃！

    +   好的，因为没有多数 -> 没有执行 -> 没有客户端回复

要点：

+   “至少与最新”规则导致新领导人的日志包含其日志中的所有已执行条目

+   因此新领导人不会撤销任何已执行的操作

+   类似于 Paxos：新回合最终使用上一回合选择的值（如果有的话）

问题：图 7，a/d/f 中哪个可以被选举？

+   即来自“不那么最新”的服务器的大多数投票？

Raft 最微妙的地方（图 8）

图 8：

```
S1 1, L 2,    ,      L 4,
S2 1,   2,    ,      \A/,
S3 1,   <-------- 2 <-| ,
S4 1,    ,    ,         ,
S5 1,    , L 3,         , L will erase all 2's 
```

+   不是百分之百真实的，大多数上的日志条目被提交

    +   即永远不会被遗忘

+   图 8：

    +   S1 在第 2 个任期中是领导者，发送了两份 2 的副本

    +   S5 在第 3 个任期中是领导者

    +   S1 在第 4 个任期中是领导者，发送了 2 的另一份副本（因为 S3 拒绝了操作 4）

    +   如果 S5 现在成为领导者会怎样？

        +   S5 可以获得大多数（没有 S1）

        +   S5 将回滚 2 并用 3 替换它

    +   2 能执行吗？

        +   它在大多数上...

        +   所以 S1 在大多数之后是否可以在 leaderCommit 中提到它？

        +   不是！图 2 的最后说"日志[N].term == currentTerm"

        +   当发送第 3 份 2 的副本时，S1 在第 4 个任期

    +   Raft 的实际提交点是什么？

        +   第 310 页右下角

        +   "一旦创建条目的领导者在大多数上复制，就被提交"

        +   并且一个条目的提交点提交所有在它之前的条目

            +   这就是 2 *如果* S1 没有失去领导权时如何提交的方式

另一个话题：配置更改（第 6 节）

+   配置=服务器集

+   Raft 如何更改服务器集？

+   例如，每隔几年可能想要退休一些，增加一些

+   或者一次性移动到一个全新的服务器集

+   或增加/减少服务器数量

*破损*配置更改会如何工作？

+   每个服务器都有当前配置中的服务器列表

+   通过逐一更改列表来更改配置

+   例如：想要用 S4 替换 S3

    +   S1：1,2,3 1,2,4

    +   S2：1,2,3 1,2,3

    +   S3：1,2,3 1,2,3

    +   S4：1,2,4 1,2,4

+   糟糕！

    +   现在*两个*不相交的组/领导者可以形成：

        +   S2 和 S3（不知道新配置）

        +   S1 和 S4

    +   两者都可以处理客户端请求，所以分裂大脑

### Raft 配置更改

+   **想法：**包括*旧*和*新*配置的“加入共识”阶段

+   旧组的领导者记录切换到联合共识的条目

    +   在联合共识期间，领导者分别记录在旧和新中

        +   即每个日志和每个日志条目上的*两个*协议

        +   这将迫使新服务器赶上并迫使新旧日志相同

+   在大多数旧和新的都切换到联合共识之后，

    +   领导者记录切换到最终配置的条目

例子（因为原始笔记中没有正确说明，所以不会有意义）：

```
 S1: 1,2,3  1,2,3+1,2,4
  S2: 1,2,3
  S3: 1,2,3
  S4:        1,2,3+1,2,4 
```

+   如果崩溃但新领导者没有看到切换到联合共识，

    +   然后旧组将继续，没有切换，但没关系

+   如果崩溃并且新领导者看到了切换到联合共识，

    +   它将完成配置更改

### 性能

+   没有关于它可以处理请求有多快的数字

+   瓶颈可能是什么？

+   磁盘：

    +   需要为客户端数据的持久性写入磁盘，以及协议承诺

    +   每个客户端请求写入？所以每秒 100 个？

    +   可能批量处理并获得 10,000 到 100,000

+   每个客户端请求几次消息交换

    +   本地 LAN 消息交换需要几十微秒？

    +   所以每秒 10 万个？

*下周：*在复杂应用中使用类似 Raft 的协议
