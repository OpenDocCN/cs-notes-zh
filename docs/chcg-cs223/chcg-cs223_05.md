# 不可变性和持久性

在纯函数环境中实现高效数据结构比在命令式环境中更难的原因是什么？

1.  *命令式*或*破坏性*更新的缺乏导致必须复制可能的大部分数据结构，以及

1.  所有版本的数据结构都预期是*持久的*，即使在更新之后也可以使用。

任何用于纯函数语言的实用编译器都会积极寻找将多个数据结构共享的机会。然而，与命令式环境中的类似数据结构相比，空间开销是不可避免的。然而，正如我们将在课程后期看到的那样，通过巧妙的设计和一点懒惰的评估，许多高效的数据结构可以设计用于纯函数环境中。但首先，先来了解一些基础知识...

#### 列表

以下函数更新了索引为`i`的`xs`中的元素（如果存在），并将其值设置为`y`：

```
update : List a -> Int -> a -> List a
update xs i y =
  case (xs, i) of
    ([],     _) -> []
    (x::xs', 0) -> y :: xs'
    (x::xs', _) -> x :: update xs' (i-1) y 
```

与`find`函数一样，按元素逐个遍历列表，`update`也是如此，通过跟踪还需要遍历多少元素`i`。`update`的最坏情况运行时间是*O(n)*，其中*n*是`xs`的大小。当`i`为负数时，为什么最坏情况运行时间不是无限的？

除了运行时间外，我们还需要注意所产生的空间开销。也就是说，在函数调用期间和之后，需要表示多少额外数据。

在第二种情况中，请注意输出列表`y :: xs'`引用了`xs'`，它与输入列表的尾部相同。这是语言实现的一个机会，当然会使用指针和指针操作，来共享`xs'`的底层表示在输入和输出列表之间。

另一方面，在第三种情况下，没有机会共享；结果列表是从`x`和由递归调用`update'`产生的某个未知列表构建而成的。因此，在输出列表中必须为`x`分配一个新的内存单元，并将其连接到递归调用结果的列表中。这种情况体现了关于空间（以及时间）的最坏情况。如果`update`需要更新列表中的最后一个元素，则会将`xs`的前*n-1*个元素复制并添加到单元素列表`y :: []`上。因此，在最坏情况下，`update`需要分配*O(n)*的空间。

考虑的另一个列表操作是`append`：

```
append : List a -> List a -> List a
append xs ys =
  case xs of
    []     -> ys
    x::xs' -> x :: append xs' ys 
```

让*n*是`xs`的大小，*m*是`ys`的大小。请注意，`ys`的元素根本没有被遍历（因此其元素数不会对执行时间产生贡献），并且在第一种情况中，`ys`被名称引用，语言实现可以在输入和输出列表中共享其表示。因此，`append`的最坏情况时间和空间成本为*O(n)*。

在实践中，通常使用单个变量 *n* 来描述列表的组合大小，或者较大列表的大小。在任何情况下，最坏情况的时间和空间成本仍然为 *O(n)*。

#### 二叉搜索树

回顾一下搜索二叉搜索树中元素的 `findBST` 函数，只在可能出现元素的子树中进行递归调用。保留二叉搜索性质的插入算法类似：

```
insert : comparable -> Tree comparable -> Tree comparable
insert x t = case t of
  Empty -> Node x Empty Empty
  Node y left right ->
    if | x == y -> t
       | x <  y -> Node y (insert x left) right
       | x >  y -> Node y left (insert x right) 
```

与 `findBST` 类似，`insert` 的运行时间为 *O(h)*，其中 *h* 是树的高度。树 *t* 的高度 *h* 在最坏情况下等于其大小 *n*，其中每个 `Node` 只有一个元素（即 *t* 是一个弯曲的列表）。在最佳情况下，当 *t* 大致平衡时，*h* 是 *O(n·log(n))*。

关于空间，`insert` 函数将观察到的所有节点值 `y` 复制到输出树中，直到达到 `Empty` 为止。但是，第二种情况中的 `right` 子树和第三种情况中的 `left` 子树在输入和输出树中都是共享的，因此实现有机会共享此表示。因为最多遍历 *h* 个节点，所以在最坏情况下，`insert` 分配 *O(h)* 的空间。

[`Persistence.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Persistence.elm) 包含上述的 `List` 和 `Tree` 示例。

## 阅读

#### 必需的

+   Okasaki，第 1 和第二章
