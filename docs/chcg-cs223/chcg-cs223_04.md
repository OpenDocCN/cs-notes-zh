# 渐近分析速成班

让我们回顾一下描述算法的时间和空间效率的基本数学技巧。算法操作的“成本”通常被指定为它们输入的函数（属性）的函数。因此，需要工具来“比较”函数。

## 大-Oh 符号

如果存在常数 *c > 0* 和 *N > 0*，使得对于所有 *n ≥ N*，*f(n) ≤ c·g(n)*，则 *f(n)* 是 *O(g(n))*。这被称为“*f(n)* 是 *g(n)* 的大-Oh”。定义有时在使用 *>, ≥, <,* 和 *≤* 时有所不同，但这些差异并不重要。

**示例**

+   *f1 = n/100*

+   *f2 = 100n*

+   *f3 = 100n + 23*

*f1 是 O(n)* 因为

+   *f1 ≤ n* 对于所有 *n ≥ 0*。

*f2 是 O(n)* 因为

+   *f2 ≤ 100·n* 对于所有 *n ≥ 0*。

*f3 是 O(n)* 因为

+   *f3 ≤ 101·n* 对于所有 *n ≥ 23*，或者

+   *f3 ≤ 102·n* 对于所有 *n ≥ 12*，或者

+   *f3 ≤ 111·n* 对于所有 *n ≥ 3*，或者

+   *f3 ≤ 200·n* 对于所有 *n ≥ 0*，或...

#### 术语

在计算机科学环境中，*g(n)* 经常被称为 *f(n)* 的大-Ω（写作 *g(n)* 是 *Ω(f(n))*）如果 *f(n)* 是 *O(g(n))*。然而，这个定义与[大-Ω的其他定义](http://en.wikipedia.org/wiki/Big_O_notation#Related_asymptotic_notations)冲突。

#### 紧界

大-Oh 关系指定了一个渐近上界，但不提供关于界有多“紧”的信息。例如，*n²* 是 *O(n⁴)*，但这个界限不如其他有效的上界信息丰富。

常常有必要为函数 *f(n)* 建立下界 *L(n)*（使得 *L(n)* 是 *O(f(n))*）除了上界 *U(n)*（使得 *f(n)* 是 *O(U(n))*）。当 *L = U* 时，界被称为紧的。

紧界由大-Theta 符号描述。也就是说，如果 *f(n)* 是 *O(g(n))* 且 *g(n)* 是 *O(f(n))*，则 *f(n)* 是 *Θ(g(n))*。

**可选练习** — 证明对于所有 *i* 和 *j*，*logi* 是 *O(logj)*。提示：对于所有 *b*，*logb = (ln x) / (ln b)*。

除非另有说明，我们将 *O(log(n))* 缩写为 *O(log2)*。考虑到以上事实，这种约定在渐近增长率方面是合理的。

**可选练习** — 定义一个 *[f[1], f[2], f[3,]...]* 函数的排序，以便对于所有 *i* 和 *j*，*i < j* 意味着 *f[i]* 是 *O(f[j])*。

+   *2^n*

+   *n*

+   *4*

+   *sqrt(n)*

+   *n²+3n*

+   *log(n)*

+   *n·log(n)*

+   *n!*

+   *n⁵ - n⁴*

+   *1.5^n*

## 递归关系

我们将考虑几个简单的算法，遍历数据结构查找特定元素。

#### 在列表中查找

这是一个简单的 `find` 函数，遍历列表 `xs`：

```
find x xs = case xs of
  | []     -> False
  | y::xs' -> if x == y then True else find x xs' 
```

我们想要定义一个函数 *T(n)* 来描述 `find` 的时间成本，其中 *n* 是 `xs` 列表的大小（即元素数量）。

有三种情况需要考虑：

+   如果 `xs` 是 `[]`，那么 `find` 在进行一些常量 *c1* 的模式匹配工作后就会返回。因此，*T(n) = c1*。

+   如果列表的头`y`等于`x`，则在进行一些常数*c2*的模式匹配和相等测试的工作后，`find`返回（请注意，我们假设`(==)`是一个常数时间操作，这可能并不总是一个合理的假设）。所以，*T(n) = c2*。

+   否则，`find`执行一些常数*c3*的工作进行模式匹配和比较*并且*还递归调用剩余列表`xs'`的`find`。因此，*T(n) = c3 + T(n-1)*。

要计算`find`的运行时间的上限，我们必须考虑最坏情况，这意味着在找不到所需元素`x`的情况下遍历整个列表。通过展开上述三种情况以获取整个列表的递归关系，我们得到以下递归关系：

```
 T(n) = c3 + T(n-1)
T(n-1) = c3 + T(n-2)
T(n-2) = c3 + T(n-3)
      ...
  T(1) = c3 + T(0)
  T(0) = c1 
```

要计算*T(n)*的闭式解，我们对方程组求和并得到：  

```
 T(n) = n*c3 + c1 
```

因为，*T(n)*是*O(n)*，我们说`find`在最坏情况下运行时间为*O(n)*。展示*T(n)*是*Θ(n)*也不是更多的工作，这是我们通常感兴趣的严格界限。然而，即使已知 Big-Theta 界限，通常也会非正式地参考 Big-O。

如果输入列表`xs`是排序的，`find`的运行时间如何？即便如此，函数的最坏情况是`x`不在列表中，而确保的唯一方法是遍历其所有元素。

请注意，这种*线性搜索*算法受到的约束是，在纯函数语言中，只能一次访问列表的*头部*。在具有指针或引用的语言中，可以在常量时间内访问列表的*任意*元素（这样的列表通常称为数组）。二进制搜索算法在数组上的成本具有更小的渐近增长率。（稍后，我们将看到纯函数语言通常如何提供数组数据结构。）

#### 二叉树中的查找

二叉树上的类似查找函数：

```
type Tree a = Empty | Node a (Tree a) (Tree a)

findBT x t = case t of
  Empty             -> False
  Node y left right -> x == y || findBT x left || findBT x right 
```

在不知道树结构的情况下，`findBT`必须在最坏情况下搜索整个树，通过递归遍历最坏情况下的`left`和`right`子树。如果`t`的大小=`Node y left right`是*n*，则`left`和`right`的组合大小为*n-1*。因此，进行两个递归调用总共需要时间*T(n-1)*。这导致以下递归关系，其中我们使用常数*c*和*c'*来表示最坏情况（需要两个递归调用）和最佳情况（检查`Empty`树）中涉及的操作。

```
 T(n) = c + T(n-1)
T(n-1) = c + T(n-2)
T(n-2) = c + T(n-3)
      ...
  T(1) = c + T(0)
  T(0) = c'
-------------------
  T(n) = n*c + c' 
```

因此，`findBT`在最坏情况下运行时间为*O(n)*（实际上是*Θ(n)*时间）。

#### 二叉搜索树中的查找

如果对于形式为`Node x left right`的每个子树，二叉树满足*二进制搜索顺序*属性，则`Node`中的所有`Node`都存储值`y`，使得`y < x`且`right`中的所有`Node`都存储值`y`，使得`x < y`。

假设树`t`满足此排序属性，则`findBST`被定义为仅查找包含所需元素`x`的子树：

```
findBST x t = case t of
  Empty -> False
  Node y left right ->
    if | x == y -> True
       | x <  y -> findBST x left
       | x >  y -> findBST x right 
```

然而，`findBST` 的递归关系与 `findBT` 的递归关系看起来很像；即使在最坏情况下只进行了一次递归调用（要么到`left`，要么到`right`），遍历的子树的最坏情况大小也是 *n-1*。因此，`findBST` 的运行时间为 *O(n)*。

#### 平衡二叉搜索树中的查找

如果二分搜索有序树也是 *平衡的*，即每个子树的子树大致相同大小（我们将在课程后面看到各种合理的定义），那么 `findBST` 的递归关系为：

```
 T(n) = c + T(n/2)
T(n/2) = c + T(n/4)
T(n/4) = c + T(n/8)
      ...
  T(1) = c + T(0)
  T(0) = c'
-----------------------
  T(n) = (log n)*c + c' 
```

与之前最坏情况下的 *n* 递归调用相比，现在最多只有 *log2* 个递归调用，因为每个子树（大致上）都是原大小的一半。因此，当树平衡时，`findBST` 的最坏情况运行时间为 *O(n·log2*。

请注意，我们没有详细追踪子树的确切大小，而是简单地将它们视为整个树大小的一半。尽管这可以且应该严格计算出来，但最终并不重要，因为定义增长率的常数和不等式提供了调整空间。如果您对此材料尚不熟悉，您可能希望阅读更多关于这些主题的背景知识。

## 阅读

#### 可选

+   在[这些笔记](http://people.cs.uchicago.edu/~rchugh/static/classes/introhwandsw.pdf)的第 7 和第八章中，可以找到更详细的渐近分析和递归关系的介绍（使用 Java 编程示例）。

+   这些主题的全面介绍可在经典的[CLRS 教材](http://mitpress.mit.edu/books/introduction-algorithms)中找到。
