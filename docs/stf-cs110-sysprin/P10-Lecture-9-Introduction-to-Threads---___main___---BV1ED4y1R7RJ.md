# P10：讲座9 线程简介 - ___main___ - BV1ED4y1R7RJ

好吧，外面肯定是阳光明媚，气温92度，因为看起来一半的人都来了。欢迎大家，谢谢你们在这个美丽的阳光明媚的日子里前来。只要你在这个建筑里，就有空调，所以很舒服。好了，几个简短的通知。希望第三次作业进展顺利。我会留下来。

今天讲座结束后，我会在219号教室待大约一个小时，最多一个小时15分钟。所以，如果你有任何关于作业的问题，随时可以来找我。记住，作业的截止时间是周日。周五和周六没有办公时间。所以你可以在Catholic Lion，Piazza，或者周日的办公时间找我。

可能会有很多人排队，所以这可能会很拥挤。如果可以的话，请在周末之前继续努力做作业。第二个简短的通知是期中考试将安排在下周四。是的，就是下个星期四，下午的考试。如果你有OAE的住宿安排。

如果你还没有发邮件告诉我这方面的事，请尽快发给我。否则，如果你因为时间冲突需要在其他时间参加考试，也请尽早通过邮件通知我。我会发布一些模拟考试题。我今天在Piazza上告诉某个人，我可能会在明天发布，但应该是在明后天。

有一些模拟考试题。今天我们会再讲几个之前考试中的问题，这些问题的类型可能会出现在你的考试中。现在就做出你的答案是很有帮助的。好了，回到正题。我们再快速回顾一下这个问题，因为讲座结束后。

大约20个同学对这个问题还有很多疑问。所以，让我们来讨论一个特定的答案，就是这个答案。我认为这是大多数同学会说：“等一下，我不明白为什么这个答案不可能出现。”好了，我们快速回顾一下这个程序。它是这样的。我们的`main`函数中有一个信号处理程序。这个信号处理程序是针对SIG user one的。这不是某个特定类型的信号。它是供用户或你的程序使用，发送给其他进程的信号。所以。

你不需要发送某个特定的信号。这个信号是一个通用信号，用来发送。这里所说的是，每当收到SIG user one信号时，就会调用bat函数。bat函数就在这里。bat函数简单地打印“pirate”然后退出，返回零。退出零意味着程序永远不会返回到主程序。

当信号处理程序介入时，程序会被中断。好了，它确实有一个分叉。如果你是子进程，你将打印“ghost”，然后返回零。这并不会立即退出程序，但它会关闭程序，因为你从`main`函数返回。所以就这样。如果你不是子进程的话，情况是这样的。

我们将发送 SIG_USER1 信号到 PID，在这种情况下，就是 fork 的返回值，意味着我们实际上是发送给子进程的。然后之后，它会打印 ninja。就是这样运作的。我们假设这个程序有几个可能我没完全说清楚的地方。

打印语句在这种情况下是原子的。这意味着，如果你正在执行一个打印语句，打印语句会被完全执行。所以首先，你不会得到类似 G H 然后进入信号处理程序的情况。你会得到完整的打印语句，或者什么都不打印。所以这一点对于所有操作系统都是适用的。

我们不知道，但我们假设这里是这样的。第二件事是我们假设，如果一个信号处理程序进入子进程，假设它会，除非你已经完成了程序，比如程序已经结束，否则它将被调用。所以即使你打印了 ghost，然后信号处理程序在其中发生，它也会在返回零之前调用这个函数。好的。

这是这里的基本思路。那么，问题是，使用我们这里的假设，是否可以让 ninja ghost 打印出来？好的。我们说不行。你可能有一些问题，想知道会发生什么。让我们看看这会涉及到什么。打印 ninja 然后打印 ghost。那么，嗯。

这意味着在缅因州，我们会进行分叉。好的。然后，在 ghost 被打印之前，父进程会调用 kill 或发送信号给子进程，然后打印 ninja。好的。现在，父进程可以在子进程做任何事情之前发送信号并打印 ninja。这绝对是有可能发生的。所以你完全可以先看到 ninja 打印。好的。

那可能是个问题。但让我们看看你是否能够让它在打印 ninja 之后、在 pirate 被打印之前打印 ghost。事实上，在这个程序中，这其实是不可能的。让我们看看为什么。让我们看看为了实现这种情况，必须发生什么。好的。所以假设你进行 fork，在 print F ninja 发生之前，我们还没有进入 print F。

好的。或者即使我们是那样，即使我们是那样，那也没关系。但是关键是，如果 ghost 正在打印，那么信号还没有到达子进程。好的。所以这就是会发生的事情。现在，你应该同意，如果你在发送信号之前先打印 ghost。

显然，ghost 会在 ninja 之前被打印出来，然后你就不能先打印 ninja。所以这是第一点。好的。那么假设也许你正好处在子进程要打印 ghost 的时候，这时信号到达了。嗯。如果它正准备打印 ghost，那么信号就会到达。好的。

如果信号发生，那么“pirate”将被打印，程序会退出。所以这种情况不会发生，这里不是这种情况。假设即使是在最宽容的情况下，假设我们正准备打印“ghost”，或者也许我们刚好在打印的过程中，就在打印时。

在打印“ghost”的汇编代码中，信号发生，然后……然后它在打印“ghost”之前停止。我们甚至可以假设，假设信号处理器不会被调用，就假设它不会被调用。然后“ninja”被打印出来。假设我们确实得到了“ninja”，然后再打印“ghost”。好的。

如果我们打印了“ghost”，信号已经发送给子进程了。因为在这之前仍然有返回值，所以信号处理器会发生。所以你最终会进入信号处理器并打印“pirate”。因此，实际上不可能让`print ups`是原子操作，`print ninja`先执行，再调用信号处理器，或者让信号处理器不在子进程中触发信号。

打印“ghost”，然后让这个程序或子进程完成，实际上是不可行的。好的，问题来了。你可以。我的意思是，如果你……所以我猜你问的是为什么，为什么在`print F`之前呢？假设信号在`print F`之前到达。那么，我们假设它会接收到信号。这是程序中发生的事情。

当程序接收到信号时，它会立即对该进程进行处理。每当进程收到信号时，它就会发生。如果信号在`print F`之前到达，那么信号会在`print F`之前发生，甚至在`print F`执行期间也会发生。它会在`print F`之后发生。好的，然后就是这样。

然后，在这种情况下，信号仍然会发生。如果信号已经进入程序，那么不会出现信号处理器之前发生两个语句的情况，但它不一定会发生在`print F`的中间。是的，太棒了。

当你在子进程中返回零时，或者你可以将信号传递给父进程，这样安全么？

是的，好的问题。在你将零返回给父进程之前发送信号，是否只有这种方式“pirate”才会被打印出来？不，实际上不是。我在课后和某人聊过这个问题，这个确实有点微妙。当你返回零时，实际上还有另一个叫做`main`的函数。

它是在你的程序之外的，但仍然可能是这种情况：你的信号处理器仍然设置好，所以即使在返回零后，它仍然可能会被调用。但在程序销毁时，信号处理器会在之后某个时间被销毁。好的，还有其他问题吗？我觉得这是个难题，因为你必须非常精细地考虑信号发生的时机，尤其是与所有`print F`的执行关系。

对那个问题挺好的。好的，让我们看看另一个问题。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_1.png)

我会稍微放大一点。所以这是另一个程序。跟之前差不多。这是过去期中考试中的一道题。你应该假设 printf 是原子操作，执行完才会结束，等等。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_3.png)

然后所有的操作都成功了。我希望你列出这个程序所有可能的输出。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_5.png)

好吧，为什么不这样做呢？花大约一分钟，或者两分钟左右，看看这个程序，开始思考它。和你旁边的同学讨论一下。我会在旁边走来走去，你们可以这样做。开始思考一下。然后我们会讨论我怎么思考的。好吧，别害怕，“哦。”

我要怎么分析这一切呢？”但你确实需要深入思考，“好吧，我得考虑所有不同的部分。”所以去做一会儿，假设两三分钟，我们再讨论。我会提供帮助。[沉默]，[沉默]，[沉默]，[沉默]，[沉默]。

[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]。[沉默]，再给我们一分钟。再给一分钟。[沉默]，[沉默]，好了，首先，你可能不应该在我给你的五分钟内做完这个问题。所以别想，“哦，不，他以为我们能这么快做完。”

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_7.png)

没关系。至少，希望你思考了一下。关于这个问题，我的第一个问题是，什么内容一定会最先打印出来？是 1。什么内容一定会最后打印出来？是 5。是的，真正需要我们思考的是那部分中间的内容。

那么，倒数第二个总是打印什么？实际上是 6。是那部分中间的内容需要我们仔细思考。这样做我会怎么做呢？如果你觉得，“我知道这个，”那我们就通过我如何理解它来看看。好吧？

所以程序在执行。好吧，那里有一个计数器。一般来说，我会怎么做呢？如果我在看这个程序，我会说，“好吧，我这里有一个父进程。”明白了吗？

父进程有一个计数器，初始值为零。明白了吗？然后我会下去说，“好吧，没问题。这个 while 循环中，计数器的值肯定小于 2，然后我们立刻分叉。”好吧。当我们分叉时，我会说，“好吧，现在有一个子进程，”子进程。就是这样，计数器也是零。你明白为什么会这样吗？它被复制了。明白了吗？

计数器被复制。然后我就继续往下看，“好了，我们来看下一行。”记住，现在有两个进程在执行这个操作。如果 fork 的 PID 返回值大于零，那么就意味着我们是父进程。我们会立刻跳出这个 while 循环，并且不会再回到 while 循环中。

所以父进程下来了，现在父进程就在这里。如果计数器大于零，那么父进程的计数器就不大于零。它不会那样做。如果PID大于零，当然。父进程的PID返回值大于零，因为它是子进程的PID。因此。

我们必须等待子进程。等待子进程。实际上，我会写子进程一，因为一会儿这里会有另一个子进程。好吧？

等待子进程一，然后当这个事件发生后，我们将计数器加五。也就是说，计数器的值不会是五。对于父进程，计数器等于五。然后我们打印五。但这必须发生在子进程结束之后。所以如果中间发生了任何其他事情，显然不会首先发生这件事。到目前为止，一切顺利。

好的。那么我们开始看看子进程做什么。现在先放下父进程。稍后会回到父进程的部分。子进程一。那么，好的。我们说如果PID大于零，跳出，我们不跳出。所以子进程一。嗯，它的计数器变成了一，接着立即打印一。打印一。

所以我们肯定会先打印一。没有其他逻辑上可能发生的情况。好的。然后，我们更新了计数器。现在我们回到`while`循环。这是子进程。它回到`while`循环中。计数器仍然小于二。看起来就是这样。

然后我们再次`fork`。哦天啊。好的。那么现在我们有了子进程二。子进程二的计数器初始值是多少？一，因为它是从子进程中产生的。好的。然后你可以认为它现在是新的父进程。

它获取了一个新的PID值，因为它已经改变了PID的值。它实际上将PID重置为`fork`调用的返回值。它不再是零。所以对于这个子进程来说，PID大于零。这个子进程做什么呢？嗯，它跳出。然后它下来了，计数器大于零。好的。

然后我们肯定会打印一。现在，我们不一定会立刻这样做。这里有些其他的事情在发生。我们没有在这里做任何等待。我们肯定知道我们会在某个地方打印一。所以那将在某个时刻发生。我们只是不知道确切时间。好的。

那么它接下来会做什么呢？嗯，PID仍然大于零，因为它是子进程一的`fork`调用的返回值。这意味着它是子进程二的PID。因此，我们将等待子进程二。然后我们要打印什么呢？计数器加五。所以计数器将等于六。然后我们打印六。好的。那将在某个时刻发生。

这绝对是对的，六会在一之后发生，因为在这个逻辑中没有其他方式可以发生。它可能发生，但你还不知道它相对于程序其他部分的关系是怎样的。然后你去到子进程二，想，好的，发生了什么？好吧。子进程二不是。它的 PID 返回值不是大于零。

它是零，因为它是 `fork` 调用的子进程。因此，我们将它的计数器更新为二。然后我们打印出来。打印二。好的。但我们并不确切知道那时会发生什么。那并不一定会在这个一之前发生。它可能会发生，但也可能不会。我们还不知道。好的。在这种情况下，这就是一个竞态条件。明白了吗？

那么它到底做了什么呢？它回到循环顶部，计数器不再小于二了。因此，它退出了这个 `while` 循环。然后如果计数器大于零，它将打印计数器。猜猜看？它得再打印一次二。我们不确切知道何时知道这个二会在这个二之后发生。

但是在这种情况下其实并不容易判断。就像在这种情况下并不重要，因为第一个。一个去，没什么关系。但那时它会发生。然后它到这里，PID 大于零。好吧，不是的。它是最后的子进程。所以它的 PID 值。`fork` 的返回值是零。所以它就结束了。好的。

从逻辑上看，我们先肯定会打印这个一。那必须发生。好的。然后我们有几个不同的情况。我们可能会打印这个一，或者这个二，或者这个二，在任何顺序下或者这个一。所以我们可能打印一，二，二，或者打印一然后是二一，或者抱歉，二一二。那是一个在里面的二。

一二，或者我们可以做一，然后是二，二，一。因为这些事情中的任何一个都可能在任何地方发生。在这个一和这两个二之间没有人在等待任何人。好的。它们可能有两个。好的。它们可能在任何地方发生。然后当这个二最终打印出来时，对吧。

那么我们肯定会回到这里等待。那时会发生什么？

我们必须打印六，因为这个一在等待一个子进程结束。好的。只有在那个二之后才能发生。好的。而且它必须结束。六必须在这个一之后发生，因为在子进程一中没有其他方式做到这一点。好的。然后六在所有情况下都会发生。然后这个子进程就结束了。

因此，我们正在等待那个子进程。我们肯定会打印五。所以这些就是三种可能的输出。好的。我想这在脑海中做起来会很难。对吧？所以我认为你应该像记录这些内容一样，写下来，随着进程进行，你应该最终能搞清楚。对此你有什么问题吗？大家都清楚了吗？好。这个不难。

那个问题需要稍微思考一下，但希望不会太难。而且五分钟可能不足以从头开始完成这部分。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_9.png)

那么如果我们现在将大于零的计数器改为大于或等于零的计数器，会发生什么呢？

就在这里。好吧，现在你有了其他可能发生的情况。现在，原来的父进程会打印它自己的计数器，那个时候是什么呢？

仍然是零。嗯，这个情况可能会在第一个之前发生。如果它发生在第一个之前，那会给你三个不同的输出。它也可能发生在第一个之后，那会是三个更多的输出。它也可能发生在第二个之后，因为在这种情况下没有任何人在等待。

它可能发生在下一个之后。三个更多。可能发生在下一个之后。三个更多。它甚至可能发生在六之后？可能吧。对吧？因为六实际上可能发生在之后，或者说，这会在调度中引发一些奇怪的情况，但它是可能的，没什么阻止它的东西，其他两个进程可以继续执行并完成，甚至在原始父进程之前。所以它可能会发生在那时。那是另外三个。

现在有三、六、九、十二、十五、十八种新的情况，你可以处理这些，但你可能不想把它们全部写出来，或者说你不一定会这么做，对吧？问题。没有问题。你很好。是的。这绝对是一个更有挑战性的问题，因为你得意识到现在发生了什么，你其实不太想写出所有十八种情况，尽管学生们可能写了。

好的。在继续下一个问题之前，有没有其他问题？好，好的。好的。我们来看。来了。再来一个。考虑以下程序。这里有个模式，对吧？假设每次调用都会刷新输出到控制台，而且这基本上意味着它是原子的，进一步假设系统调用都不会失败，类似于fork不会失败，wait PID只会返回负一，因为此时没有子进程。

决定返回它的返回值。好的。第一个问题是这个程序的输出是什么？请注意这个程序的输出是什么。你可能会想查看它，然后说“哦，那意味着不”。那意味着可能只有一个输出。我们来看看我能不能弄明白。所以继续吧。

再花几分钟做这个。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。好的。再30秒。好的。好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_11.png)

好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。

好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_13.png)

好的。 好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_15.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_17.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_18.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_20.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_21.png)

好的。 好的。 好的。 好的。 好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_23.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_25.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_26.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_28.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_29.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_31.png)

好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_33.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_35.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_37.png)

好的。 好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_39.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_41.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_43.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_45.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_47.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_48.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_50.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_51.png)

好的。 好的。 好的。 好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_53.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_55.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_57.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_58.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_60.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_62.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_64.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_66.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_68.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_69.png)

好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_71.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_72.png)

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_73.png)

好的。 好的。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_75.png)

给我们所有人。下次实验室见或下周见。

![](img/c4d04a56eb3fdffe753f10d82be4ef4b_77.png)
