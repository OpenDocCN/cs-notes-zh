# P16：第15讲 网络与客户端 - ___主___ - BV1ED4y1R7RJ

好的，那么我们将继续讨论网络。希望作业进展顺利。今天下课后我会有一个小型辅导会，大概一个小时或一个半小时。所以如果你愿意，可以随时过来。但今天我们将继续研究网络，我认为我们将会进一步深入。

今天你会到达一个点，你会说：“哦，我明白这里的波动互联网是怎么回事了。它确实有效一点。”希望这会很有趣。不过有个讲义，因为有很多代码，今天又是那种我不会只是疯狂输入代码的一天。

实际上我在上个季度做了这次讲座，那简直是噩梦，因为到最后我的手指都快裂开了，人们都说这是一堆荒谬的代码，根本不可能把这些代码写在黑板上或是试图现场做。所以你会看到很多代码。我们会慢慢地在黑板上讲解，让你可以记笔记或者。

提出任何问题。所以希望一切能顺利。

![](img/f50c184769ea64a2b64fcd4bbac6e714_1.png)

那么让我们回到周一讲座结束时的地方，也就是我们构建了第一个客户端，这个客户端基本上非常简单，就是说：“好，我们要创建一个客户端套接字，我们会深入了解这些细节。今天我们会做得更手动一些，你会看到更多的细节，但。

今天我们会看到一些细节，我不希望你们过于关注。你可以看一下这些细节，心想‘哦，那些是一些细节’，但我不希望你去思考。我们下周再讲这些。”但这就是连接是如何建立的，然后我们基本上设置了一个小的流，以便能够从服务器读取服务器告诉我们的内容。

就是这样，然后我们打印出来。所以这是最基础的服务器。现在通常你可能会希望实际上向服务器发送一些信息，我们今天就通过实际的 URL 来实现，然后当然你还想获取更多的信息，可能是以其他特定的形式返回。我们将通过几个例子来看看如何实现。

![](img/f50c184769ea64a2b64fcd4bbac6e714_3.png)

那么我们要看的第一个例子，我提到过，我在周一的时候稍微谈了一下它是如何工作的，并且展示了一个例子，就是这个 WGet 函数。这个功能是 Linux 内置的，你可以通过输入 WGetGoogle.com 来看到它实际的。

![](img/f50c184769ea64a2b64fcd4bbac6e714_5.png)

![](img/f50c184769ea64a2b64fcd4bbac6e714_6.png)

从 Google.com 下载结果到一个文件中。在这个例子中，它将结果保存为 index.html，就这样。所以这里就是 Google 首页，保存在一个叫做 index.html 的文件中，我刚刚用 WGet 获取的。这是一个非常简单的操作。你只需要向网站请求，网站会把它发送回来并保存。

![](img/f50c184769ea64a2b64fcd4bbac6e714_8.png)

所以我们要构建的就是这个。接下来我们要做的是，我们必须记住，我们将构建的是客户端部分，而不是服务器部分，抱歉，之前说错了。我们将构建客户端部分，它将接收一个 URL，并解析它。

它将把 URL 拆解成各个部分。好吧，像 Google 并不是一个很好的例子，但 web.stanford.edu/class110 就像是你可能传递给它的 URL。它需要做的是，连接到 web.stanford.edu 这一部分，剩下的基本上就是路径名。所以我们需要将它拆解成部分。我们可以使用部分 URL 函数来完成这项工作。

我们的大多数 URL 都会以 HTTP:// 开头。事实证明，HTTP 基本上告诉你“嘿，你正在访问万维网”。如今，你访问的大多数网站都是 HTTPS，代表“安全”，这是一种更好的做法，因为数据实际上是经过加密的。

因为你可能知道也可能不知道，我的意思是，当无线电信号发送到路由器时，除非是加密站点，否则来回发送的所有文本都是完全未加密的。如果你有密码，或者有类似的东西，它们是可以加密的，当然，也可以通过其他方式进行加密。但一般来说，HTTP 网站是不加密的。

对于某些网站来说这并不重要。但这意味着你可能会遭遇所谓的中间人攻击，在这种攻击中，你以为从一个不安全的站点获取数据，实际上数据来自另一个站点。这可能不是你想要的。因此，你应该更倾向于使用 HTTPS。

目前我们只使用 HTTP，因为我们不想处理加密。实际上，大部分处理发生在我们所处理的层次以下。但现在我们将使用 HTTP。默认路径就是斜杠。这意味着如果你输入 google.com，默认路径就是斜杠。

所以我们在这里做的其实是将 URL 拆解开来，我们只是说，如果它以 HTTP 开头，那么我们实际上需要获取它的其余部分，这就是这行 substring 代码的作用。然后你会寻找斜杠，如果有斜杠，那么斜杠后面的就是实际的路径名。所以大概就是这样，其余的部分是主机部分，比如 google。

com，或者是 web.stanford.edu 这类的网址，实际上就是这样做的。没什么复杂的，就是返回一个对。为什么返回一个对？因为 C++ 只允许返回一个东西。所以在这种情况下，我们返回的是主机和路径。因此，我们返回一个对。你也可以返回一个向量或数组，或者类似的东西，随便。

但关键是，在这种情况下，我们只是传递一个键值对，然后处理这个键值对的第一个和第二个部分。好的，挺直接的。顺便说一下，如果你尝试在字符串上使用find方法，如果没有找到，你会得到string::npos，这意味着你将使用。

默认路径就是斜杠，这意味着你只是说“嘿，我想要google.com”，没有任何附加的内容。好的。至于这个，主要部分将只调用一个函数，就是poll content，它将实际发起请求，获取结果并保存到文件中。这就是我们要做的。我们会在后续将这些步骤拆分成其他部分。

其实我们所做的就是去一个网站，发出请求，接着请求，获取数据并保存到文件，这就是Wget的工作原理。结果是这样的。好吧，有什么问题吗？是的。太棒了。是的。这就像Google.com/，就是你的问题所在。斜杠部分是默认路径，意味着没有额外的内容。

在你去到实际的网站后，我们稍后会看到为什么这有区别。这对做类似class/CS 110这种事有影响。这是我们的课程，它是一个共享网站，整个斯坦福的网络服务上都可以访问。

![](img/f50c184769ea64a2b64fcd4bbac6e714_10.png)

好的，还有其他人吗？好的。那么，poll content将做实际的工作，比如“嘿，我们需要设置一个客户端套接字”。好的，稍后我们会看到一些不同的实现方式。但现在我们只是设置客户端套接字。然后我们将进行一些错误检查，看看是否正确设置。

接着我们正在设置一个流，这个流将实际向服务器发送请求，说“嘿，给我数据”。好的。所以我们正在设置流，然后发出请求。我们将跳过所有的头部信息。记住，当一个网站响应时，它会返回很多详细信息，我们。

我们会稍后看到一些具体细节，这些细节对我们这个网站来说不重要，但你可能会在其他网站上在意这些。你可以要求网站返回经过压缩的数据，如果你愿意的话。那时，服务器会在头部告知你压缩类型。

你得自己解压，但我们现在不需要担心这些，我们直接从服务器拿回原始文本。好的。然后我们还得把它保存到文件中。好的。所以我们将创建一个客户端套接字。顺便说一句，为了这个，我们只需要URL的第一部分，因为。

这就是你如何设置它。我们不在乎它是`/class/CS110`，我们关心的是`web.stanford.edu`。这就是我们要连接的目标，连接到特定的端口上。互联网的端口通常是80端口，那是主要的互联网端口。有时你也会看到80 80端口，或者8000端口等，这些都是一些默认端口。

万维网（World Wide Web）运行在80端口上供服务器使用。这通常就是它所在的位置。好吧。如果你有一个家庭网络，且不希望其他人知道，你可以设置将流量转发到另一个端口，从而使得他人无法直接知道如何连接到它，除非他们知道。

端口号就是这样工作的。好的，关于这方面你有什么问题吗？是的，什么是组件？组件就是我们传递的那一对参数。它是主机名和实际的路径名或路径。是的，好的问题。

![](img/f50c184769ea64a2b64fcd4bbac6e714_12.png)

还有其他问题吗？好吧，到目前为止还是挺直观的。接下来，我们需要开始处理一些细节。记得我前几天做的Telnet吗？好的，实际上，Telnet命令或者说是实际的HTTP请求非常明确。它以`GET`开始，然后是路径，再到它所使用的协议。

在这种情况下，HTTP 1.0或1.1，使用哪个版本大概没有太大关系。接着，它会有一个有趣的`\r\n`。我们知道`\n`是什么意思，它表示换行。嗯，它其实更准确地说是“换行”，但它的真正含义是“直接跳到下一行”。`\r`是我们所说的回车符。

回车（carriage return）这一概念源自打字机时代，当你按下回车键时，实际上是按下一个小杠杆，推动打字机的纸张来回移动。打字机就是这样工作的。你可以找时间看看打字机。来我办公室看看，我有一个很酷的打字机项目，或者几个。

总之，回车意味着整个纸张会“嘟嘟”地回到另一侧。从你的角度看，它是“嘟嘟”回到另一侧。这就是`\r`的作用。`\r\n`应该是你每次告诉服务器“我完成这一行了”时应该发送的内容。这就是它的工作方式，它就是这么运作的。

Unix系统通常不会经常使用回车符`\r`。它的意思是“去下一行并回到行首”。但你仍然需要在这里使用回车符`\r`。是的，有问题吗？为什么不使用`\n`来换行？

好问题。N 到 L 只会发送反斜杠 N，事实证明是这样。是的，虽然是个好问题。反斜杠 N 只是做了 Unix 的方式，就是发送反斜杠 N。这个不是我们想要的。好的。所以它这么做了。然后下一行它会显示你所在的主机，和实际的主机地址。

然后是另一个反斜杠 R 反斜杠 N。告诉我们会正确地为你发送这个。然后我们发送另一个空行，表示我们已经完成了请求，接着我们刷新。现在我们必须刷新实际的数据，这意味着如果它在系统某处被缓冲，确保它实际到达另一台计算机。好的。

有时，如果你在做 `printf` 或者 `N` 时没有加反斜杠 N，有时字符不会显示出来，直到你加上那个 N。这就是刷新所做的事情。它说：“看，确保数据已经发送出去，否则 Web 服务器将不知道何时响应。”

![](img/f50c184769ea64a2b64fcd4bbac6e714_14.png)

好的，让我们再次做这个例子。是的，Davis。我会拔掉这些。不是，刷新并不会检查任何东西，它只是实际上说：“哦，如果我有一些缓冲数据，还没发送，确保它发出去。”这才是它的作用。它只是说我可以缓冲它，并保留它给自己。

我要收集所有数据，一次性发送出去。它说，看，现在我想让你发送它。现在一定要发送。太酷了，是的。你本来可以早点刷新，没错，实际上没关系。Web 服务器的成员会期待所有数据，它不会做任何事情，直到接收到所有数据。好问题，是的，好问题。

为什么需要刷新？事实证明，可能会有一种情况，如果没有刷新，单纯的反斜杠 N 可能不会起作用。实际上可能不会说“我有足够的数据可以发送”，谁知道呢，但刷新肯定会说：“看，我准备好发送数据了，确保它发送出去。”从这一点开始，所有内容都会被发送出去。就是这么运作的。这是什么？

从这个角度来看，这是一个安全保障。我们可以试着不使用它，看看会不会有问题，但也许它能工作。新行通常会发送一个刷新，但你永远无法预知，这种情况可能会发生。好的，你会得到一个 O。那是一个新词吗？是的，让我展示给你看。如果我们做 `telnet google.com 80`，然后我们说 `get`，我们需要路径名。那就是实际的路径名。

我会再次展示给你看，你可以在代码中查看，但我会再展示一次。然后我们说我们要告诉它一个斜杠一，我猜是 1.0，在这个例子中就是这样。然后我们发送一个回车，接着说主机，在这个例子中是 www.google.com，然后是你。

![](img/f50c184769ea64a2b64fcd4bbac6e714_16.png)

点击换行，然后它就会把所有内容输出。那就是我们需要发送的三件事，这也是我们在程序中发送的内容。让我们来看一下。我们在这里说get。我们在说。每次我连接到我的这个平板电脑时，似乎在我尝试在程序之间来回切换时它不起作用。不太知道为什么。但是它还是开始了。好了。

所以我们先执行get，然后执行路径，在这种情况下是斜杠。Google没有路径，我们也不想使用原始的index dot HTML。原始的路径是斜杠，然后我们说哦，我们正在使用HTTP 1.0，换行。接下来的那一行我们告诉它我们所在的主机。这是Google.com，www.google。

com，然后我们发送几个换行。顺序是重要的。是的，它确实按这个顺序来期待。为什么你想要主机放第二位？我不知道。这是他们设计协议的方式。我的意思是，你已经连接到Google.com了。你已经知道你连接到那里，但它仍然会说嘿，哪个特定的主机。

可能是因为你连接的网站有多个IP地址，但在该IP地址上有不同的主机。但是。是的，比如max。是的。它可能是别的，比如google.com docs.google。也可能是另一个。也有可能是这样。是的。那么这个双重操作呢？告诉那个部分的双重操作？不。

好问题。告诉它只是通过终端连接的一种方式。仅此而已。W get是通过网络执行这个操作的程序。我们正在写它。你会看到实际的单词，但我们正在写程序W get，它请求网站，获取它，下载它，保存到文件。这就是W get的作用。还有其他人吗？好的。

所以这就是请求函数要做的所有事情。它基本上就是在说嘿，获取请求。

![](img/f50c184769ea64a2b64fcd4bbac6e714_18.png)

然后我们需要做什么？我们需要跳过所有这些头部信息。跳过头部信息相对简单。你读取一堆行，直到遇到空行。好，来自网页服务器的第一部分内容是。

所有这些头部信息。它的定义方式是头部，头部，头部，头部，空行。剩下的就是数据。就是这么简单。在这种情况下，我们不关心这些头部信息是什么。如果我们愿意，可以将它们打印出来，或者查看它们，但对我们来说没关系。所以我们所做的就是执行一堆get操作，直到行为空为止。

我们只是继续读取它们。现在有些服务器不太友好，它们只发送换行，因为有些编写这些程序的人没有意识到你还需要反斜杠R。如果我们只获取一行，其中有反斜杠R，我们也会理解它。那只是一个hack，只是为了看看最常见的问题是什么。

为什么我们要用带有通配符条件的do，就像一条直线一样，通配符？

我们为什么要这么做呢？我想这可能是为了节省一行代码。我的意思是，你必须设置它，基本上得设置这一行使其不为空，然后还得以某种其他方式设置它，给它一个默认值，然后……做一个wild操作，再去获取它。我的意思是，你可以把它做得更简短，但在这种情况下，这样做只是节省了几行代码。

那么这件事是什么呢？最有趣的部分是那个小语言，但也有其他人熟悉get，我们应该了解吗？是的，这是个好问题。那么，为什么使用get呢？

好的，get是你可以用来从Web服务器请求信息的一种方式。你也可以使用post，这意味着我正在向Web服务器发送数据，比如我有一个文件，我想发送，或者我有一个名字或其他什么。你还可以使用……有另一个方法是你将在下一个作业中使用的，我忘记是什么了。

还有更多这样的情况，但这只是HTTP语言的一部分。就这么简单。它就是HTTP协议。你做的其中一件事就是使用get，或者使用post，或者使用77。追踪。那么如果你只用/r呢？如果你只用/r而不使用/n，Web服务器可能会搞混。我是说，它可能会问你“你这一行已经结束了吗？”。我不知道。你知道，这就是为什么你需要。

协议要求你必须同时有两者，所以我们发送了这两者。这就是它的工作方式。再次强调，这也是为什么当计算机相互通信时，它们需要知道确切的……正确的信息。这就是为什么我们在106A、B、107等课程中一再强调这一点。它的输出必须完全一致，这不仅仅是因为我们对它挑剔。

这是为了让计算机能够……因为我们的自动评分程序是计算机。它们也在试图进行通信，但你会一次又一次地看到这一点。你需要精确你的输出。所以这就是确切的要求。抱歉，头部信息到底包含什么？头部信息包含了它正在返回的是什么类型的数据？

无论是否，我们将看到这个例子，我们稍后会看到一些我们关心的头部数据。它是否压缩了。必须保留。无论网站是否可以在不在网站上的情况下请求数据。我的意思是，很多时候，网站并不会轻易把数据提供给其他计算机。

通过某些方法。在这种情况下，头部可以告诉你，嗯，可以，或者也许我们不想这么做。无论它是否被缓存。我的意思是，有很多不同的头部。你可以查找HTTP头部，看看有多少种。是的，头部是一行一行的。一个头部，一个头部，再一个头部，又一个头部。

然后最后一行是一个空行。然后我们进入数据部分。这就是协议。说起来很简单。考虑到所有的因素。一堆头部，换行数据。就是这些。好了。好了。我们看一下下一个例子。那就这样。哦，这不是我想要做的。等一下。

![](img/f50c184769ea64a2b64fcd4bbac6e714_20.png)

那我们开始吧。好的。那么我们接下来要看看获取文件名的函数。好的。顺便提一下，这一切都是因为你可以查看代码并看到发生了什么。但基本上我们只是将它分解到这里。获取文件名的功能将接受路径，并将路径转换为。

如果路径的最后部分是文件名，就返回文件名。如果没有文件名，它将使用 index.html，作为网页的默认文件名。如果你从未做过网页写作，如果你做过网页写作，可能已经见过 index.html，它基本上是你访问网页时看到的第一页。通常是这样。

这就是它的工作原理。好的。所以做起来很简单。它基本上就是说，如果路径为空或者路径末尾有斜杠，就返回 index.html。好的。否则，你会找到最后一个斜杠后的部分。这就是 R find 的作用，返回那部分。这就是全部。好的。

所以就是找到实际的文件和锚点。我们即将写出文件。好的。那么我们需要做什么来保存有效载荷？我们需要读取。好的。我们将会得到一个文件名，保存到其中，这个文件名将通过获取文件名来获得。我们将会得到一个流，我们将从中读取数据。

这个流基本上是网络流。好的。我们将设置并获取我们要读取的网络流，这样我们就可以读取所有的数据。好的。那我们将如何做到这一点？

基本上我们会说，直到我们没有读取完所有数据。我们用的是 while do，因为对于这种类型的流，我们可以这样做。然后我们就读取所有数据。对。我们会尽可能多地将数据读取到我们的缓冲区，它的长度是固定的。为什么是2014？

我不知道。它是2014年做的，可能是我们想要的任何东西。然后我们统计所有数据的数量，然后将其写入我们实际的缓冲区，抱歉，是写入缓冲区，然后让我们看看。抱歉。我们是将数据读取到缓冲区。抱歉。我们将缓冲区写入输出，写出我们读取的数据量。

这就是全部。好的。然后统计出多少字节，以便知道读取了多少字节。是的。对。这个问题很有意思。为什么我们需要获取 finally 和 function？

记住，如果我问最终的结果是什么，假设我们已经准备好使用了。slash class slash CS 110，那会是什么？class slash CS 110 听起来并不太合适。作为文件名。所以我们只想要它的最后部分。所以在这种情况下，我们看到的是 us 110，但实际上对于我们来说，这并不可行，因为我们会。

请求 CS 110 slash，但是如果我们这么做，那就是最后的部分。所以我们得到了路径，我们要请求的路径，但是最后的名称只是路径的最后部分。你知道的，我们只是创建这个，因为这就是 `W get` 工作的方式。对，那什么是 I/O sock 流？好的。这是你知道的，像你可以做 `cout`，你可以那样做，你也可以做 `cout`。

这些东西，它有效。好吧，这就是流，流是 C++ 中表示“嘿，这里有一些相对简单的方法来进行输入输出”的方式。I/O sock 流是一个类，它被创建出来包装网络文件描述符成流，以便更容易使用。就这些，我有的就是 sock。只是一个类，我们用它来简化操作，这样我们就可以做一些像输出这样的事情。对吧？

我们可以做一些事情，比如从 SS 读取数据，像这样，`SS.read`。这就像从流中读取数据等等。而且它会为你做所有的缓冲，你不需要担心要有一个 while 循环去处理，像是只处理一定量的数据，它会为你处理所有这些。David，你有问题吗？[听不清]，`SS.Gcount` 是你获得的返回数据量，我相信。

我认为就是这个。所以它基本上会显示我们刚才读了多少，嗯，我们刚才到底读了多少对吧，然后它就会从读取中不断更新这些数据。好了，现在我们正在处理的是一些帮助函数。所以让我们看看，那个值是不是唯一的，实际上就是它，我们实际上有的。

![](img/f50c184769ea64a2b64fcd4bbac6e714_22.png)

做好了所有的事情，没错，我们没有漏掉任何东西，实际上我们都做到了。

![](img/f50c184769ea64a2b64fcd4bbac6e714_24.png)

因为我们需要先发出请求，我们已经看到如何在这里发出 `get` 请求。

![](img/f50c184769ea64a2b64fcd4bbac6e714_26.png)

![](img/f50c184769ea64a2b64fcd4bbac6e714_27.png)

然后我们跳过所有的头部，读取所有的头部，然后是新的一行，然后。我们保存有效负载，也就是所有头部之后的内容。

![](img/f50c184769ea64a2b64fcd4bbac6e714_29.png)

我们是不是没有这个？我是不是跳过了跳过头部的功能？

![](img/f50c184769ea64a2b64fcd4bbac6e714_31.png)

不，它就在那儿，没错，就是这样，好的，所以就读取了所有内容。好了，这就是我们在这种情况下要做的全部。就是这样，让我们检查一下，看看它是否工作。

![](img/f50c184769ea64a2b64fcd4bbac6e714_33.png)

好的，看看这个，看看我们的一十春季直播讲座，先把这个弄清楚。好了，然后如果我们做网络连接，做 `wwebget`，我们试一下 Google.com。对吧？它说是两百一十九个字节，这意味着那里出了点问题。让我们看看，可能意味着它没有正确的东西。看看它们的索引。

html 是的，它显示它已移至 Google.com/，所以我们需要做斜杠。哦，我们还需要做的是，可能需要加上 wwew。好了，现在我们有足够的字节，得到了 46,000 字节，所以实际上这有效。如果我们没有加 wwew 直接使用 Google.com 会发生什么呢？如果我们看一下它显示的内容，它说嘿，文档已经移至 wwew。

google.com。所以这就是它，基本上 Google.com 和 wwew.google.com 之间有区别，所以 Google 已经设置了，当你请求 Google.com 时，它会说不不不，请求 wwew.google.com，浏览器会为你自动完成。如果你只输入 Google.com，它会转到 Google.com 获取这个消息，然后说哦，我得做这个。

另一个请求并获取实际版本返回。这就是所有的，没错。关于保存有效载荷函数的问题。

![](img/f50c184769ea64a2b64fcd4bbac6e714_35.png)

是的，让我拿出保存有效载荷函数。对了，那个反斜杠零（backslash zero）是用来干什么的？

![](img/f50c184769ea64a2b64fcd4bbac6e714_37.png)

那么，那个做了什么？啊，好问题，所以在这种情况下，因为我们正在尝试读取，问题是为什么有一个终止的反斜杠。我想我跳过了那部分。当你在读取时，实际上它说嘿，创建一个满是零的完整缓冲区。它在这种情况下做的是这样，所以它们已经是零了，这并不意味着你不需要。

当你读取所有数据时，你必须在末尾加上一个。所以它已经有了。好问题。好吧。是的。你还需要关闭输出吗？不。在这种情况下，对于 OF 流，你不需要关闭它们。像这种情况，是的，我认为实际上它会在超出作用域时自动关闭，因为它的工作方式就是这样。好了，现在我们来看看更有趣且有点酷的示例，直到最后。

![](img/f50c184769ea64a2b64fcd4bbac6e714_39.png)

我认为你会看到哦，这很酷，这就是互联网的工作方式。而且，这不是你创建网页的方式，但实际上它非常接近。事实证明，你不一定需要创建自己的 web 服务器。大多数情况下，当你将页面放在服务器上时，web 服务器会自动为你运行它。

在你的计算机上。我们现在要做一个更底层的版本，但基本上，你可以看到 web 服务器需要做什么才能获取你的数据并将其传输给请求它的其他客户端。好吧，我们要做的就是，我们要看一个示例，它是一个 API，基本上有一个与之关联的 API。

一个应用程序接口（API），基本上就是说我们知道需要发送什么数据到服务器，它将以我们能理解的某种格式返回数据。好的，谁听说过JSON？JSON。好的，几乎每个人都听说过，虽然不是每个人。JSON是一种机器可读但也相当人类可读的格式。好的，我们到时会看到实际的格式，但我们将以这种格式输出我们的。

我将展示的结果是这个格式，这样如果我们需要，最终我会展示一个我构建的小网页，利用这个我们可以实际获取格式化的数据，以便我们的计算机可以理解并做些有趣的事情。比如把它显示在屏幕上，或者用来做一些计算，或者其他。

但这就是我们最终会创建的。我们要做的是创建这个小程序，它会使用一个叫做Scrabble单词查找的程序。这个程序你当然可以去查看，但它是一个106B程序，基本上是接受你可能有的字母（比如从某个地方抓取的字母）。基本上是任何单词查找程序，像是“朋友连连看”之类的，你拥有一个数字。

这些字母和你用来组成单词的字母数量，字母都是混合在一起的，这个程序会从这些字母中找到字典中所有可以组成的单词。好的，这就是它要做的。让我给你展示一个例子，看看Scrabble单词。

![](img/f50c184769ea64a2b64fcd4bbac6e714_41.png)

查找斯坦福单词。好的，它会打印出你可以用斯坦福字母组成的所有不同单词。好的，这就是程序做的事情。好的，任何字典中存在的单词它都会生成。好的，Scrabble单词查找网络。好的，它会打印出所有你能从中构成的单词，而这些正是我们要做的。

假设我们有一个网站，想要实现这个功能。那么我们可能会创建一个斯坦福Scrabble单词查找程序，它正是做这个的，它接收作为参数的字母，然后输出所有由这些字母组成的单词。好的，我们要做的是创建一个使用这个程序的服务器。

或者做相同的事情，除了不再输出到屏幕，而是将结果以我们客户端能理解的形式发送出去，即JSON格式。好的，你可能会想，好的，让我们进入Scrabble单词查找程序，不管它在哪里做输出，我们设置一个网络连接，做一个客户端或者我们做一个小的服务器连接，然后就有了一个。

接受所有这些，那我们为什么要这么做呢？如果我们已经有了一个完全能正常工作的程序。你们做过一个作业，使用其他程序并从那些程序获取结果，那个程序你们写的是subprocess，对吧？现在，让我们利用subprocess来实际从这个程序中获取单词并通过我们的服务器。

这需要是一个非常小的功能，基本上就是：请求到来时，使用Scrabble Word Finder获取单词，然后将其发送回客户端，故事就这样结束了。好的，这很公平。

![](img/f50c184769ea64a2b64fcd4bbac6e714_43.png)

我们将经历的细节数量有很多，但正如你所见，这就是我们想做的。我们不想修改已经运行得非常好的程序。

![](img/f50c184769ea64a2b64fcd4bbac6e714_45.png)

我们可以使用子进程来完成这个任务，好的，接下来这是JSON的样子，顺便提一下。

![](img/f50c184769ea64a2b64fcd4bbac6e714_47.png)

这是我们将要做的事情的结果，我们将运行这个程序，启动这个服务器，假设它在端口13133上，位于myth 54，当我们请求myth 54:13133/lexical时，我们将把lexical传入Scrabble Word Finder，将字母传入。所以我们需要弄清楚这一点，并且需要解析出其中的各个部分。

我们可以从中获取字母，所以我们将做这个，然后我们将。

![](img/f50c184769ea64a2b64fcd4bbac6e714_49.png)

要生成像这样的内容，我们需要说明处理请求花费了多长时间。

![](img/f50c184769ea64a2b64fcd4bbac6e714_51.png)

我们将说明它是否已被缓存。所以这不是这个作业，而是下一个作业，实际上是一个非常酷的大型网络作业，你将要做一个Web缓存程序。实际上，缓存的概念在网络中是这样的：如果你之前做过某件事，就不要再做一次，因为网络本身相对来说是。

这很慢，但在这种情况下，实际上并不是这个问题，真正的原因是我们已经获得了一堆字母，并且已经将它们转换成了单词，既然如此，我们不妨将这些单词保存下来，以防有人再次请求相同的字母，放到缓存里，然后我们只需要报告它是否被缓存，客户端为什么会在乎呢？

谁知道呢，或许客户端在乎这个，但是我们将告诉他们它是否被缓存，然后它就会变成一个包含所有内容的数组。

![](img/f50c184769ea64a2b64fcd4bbac6e714_53.png)

好的，所以这其实是一个小小的内容，它基本上是一个映射，时间字段后面接时间，逗号后面是缓存状态false，然后是可能性，它是一个数组，这就是JSON的样子。注意，一旦你明白了哦，这就是JSON中的映射，你就能读懂它了，这非常直观，而且你的JavaScript程序。

![](img/f50c184769ea64a2b64fcd4bbac6e714_55.png)

结果表明可以非常轻松地读取这个内容，这也是你可能会请求的内容。服务器获取客户端数据，好的，明白了，所以这就是我们最终要做的事情。

![](img/f50c184769ea64a2b64fcd4bbac6e714_57.png)

通过这样做，让我们看看我们到底是如何做到这一点的。正如我所说，我们将利用子进程来完成这个任务，它只会使用它来获取输出并执行。我们需要向“scrap a word finder”发送任何数据吗？不，我们通过命令行来进行操作，因此实际上不需要指定字母。

我们本来可以设置程序来自动完成，但我们只是通过命令行来做这件事。

![](img/f50c184769ea64a2b64fcd4bbac6e714_59.png)

这个将会是相当直接的，所以这是主函数，主函数是做什么的呢？

![](img/f50c184769ea64a2b64fcd4bbac6e714_61.png)

我们的服务器应该和其他服务器相似，让我们看看，找找看。

![](img/f50c184769ea64a2b64fcd4bbac6e714_63.png)

这部分你们可以在第三页复制，可能不在第三页，在第八页。哦对了，它在程序的最后部分，没错，就是第八页，抱歉，实际的主函数就在第八页。所以，我们现在在做的事情是设置服务器，就像我们以前做的那样。我们将创建... 对的，就是这个。

![](img/f50c184769ea64a2b64fcd4bbac6e714_65.png)

放大这里，我们将创建服务器套接字。好的，我们首先提取端口，这实际上是一个相对简单的任务。我们基本上会从命令行获取这个端口号。你可以在运行时指定你想使用的端口。

运行它时，如果没有指定，它将会使用默认值，然后我们将创建服务器套接字。好的，然后我们将指定监听的端口。没什么大不了的，我们将设置一个叫做线程池的东西。记住，我们这样做的原因是为了能非常快速地接受最多16个连接。

然后根据这些连接启动线程。好的，所以你们会为下一个任务构建一个线程池。然后我们将有一个缓存，在这种情况下，缓存将是那些字母映射到结果字符串向量的内容。你认为我们应该对这些字符串做什么，以确保如果我们...

获取A B C D，然后我们得到D C B A，难道这些不会创建完全相同的单词集合吗？我们应该对得到的单词做些什么，才能在将它们放入映射之前进行处理？对它们进行排序。只是将它们排序，效果是一样的，但我们还是会这么做。好了，我们还需要一个互斥量，因为我们在处理线程时，需要一个互斥量。

这里是缓存锁，基本上是因为如果我们正在从缓存读取，而其他人恰好在此时写入缓存，这可能会带来麻烦，我们可能会得到错误的数据，或者可能会导致某些内容损坏，写入可能会出现问题。虽然可能不会真的损坏任何东西，但你可能会得到错误的数据。

它可能最终会进入一个状态未知的情况，因此每当我们读取或写入缓存时，都需要加锁。所以这是一个演示。接下来，我们将有一个常规的while循环，用于我们的服务器来接受连接。我们将以不同的方式处理这些事情。

在这里，这是我之前说过的不要过多关注的部分，让我们看一下，先大致了解下，我们下周会学习这个内容。我们将设置一个叫做struct socket address _in的东西来获取实际的IP地址。这样做的原因是每当我们得到一个客户端时，我们希望能够知道它是从哪个IP地址连接的。

为什么我们可能关心这个？我们可能想记录它，或许我们是一个非常关注Scrabble单词的程序，可能会记录它或者其他什么内容。相信我，每一个你访问的网站都会记录你的数据，记录你的IP地址，记录你请求的内容。看，这就是人们如何收集你的数据，始终记录登录细节。

在这种情况下，我们关心的是IP地址是什么。我们将通过这段代码来实现这一点，虽然我现在不会详细讲解，但我们下周会看到，这段代码基本上用于获取客户端的IP地址。

通过响应，我们将说明我们从哪里获取数据，并且我们需要正确地打印出来等等，但基本上会说嘿，接收到来自IP地址的连接请求，这就是我们关心的内容，好吗？然后我们将调度线程，以便能够快速返回并进行另一次接收。

一旦我们通过这些复杂的搜索找到IP地址，我们将通过调用我们已发布的Scrabble单词函数来实现，而该函数本身会调用自处理（self.process）。我们需要做的是传入客户端，我们将为此传入文件脚本，并通过引用传入缓存，缓存锁也通过引用传入。这就是我们要做的，好的，这是我们程序的核心思想。

然后一切都会在已发布的Scrabble单词中发生，所有的操作都从那里开始。对此有问题吗？别问细节，我们下周会讲解。好的，没问题。

![](img/f50c184769ea64a2b64fcd4bbac6e714_67.png)

就像我之前说的，这一切关于地址大小、I net 和 Top 的内容，我们下周会讨论。这挺酷的，好吗？发布的 Scrabble 单词将依赖于子进程，我们最终将创建 JSON 输出，然后我们将看到它是如何工作的。所以让我们来看看，接下来的这个函数非常详细，我们会逐行分析，它的名字是。

发布的 Scrabble 单词，它在第七页，所以我很熟悉这个内容，好了。

![](img/f50c184769ea64a2b64fcd4bbac6e714_69.png)

好了，下面是它的内容，你已经看到了，我希望你能从后面看到它。下面是我们在发布 Scrabble 单词时要做的事情。我们将使它变得简单，让我们可以轻松地写入客户端，或者像我们发现的那样，从客户端轻松地读取和写入。我们将调用一个函数。

叫做 get letters，这个函数会请求我们获得的请求，找出网页 URL 中斜杠后的部分，并把它们作为字母。然后，正如我们所说，我们将对它们进行排序，因为我们不在乎顺序，但这对我们的缓存来说很重要。接下来我们会。

定时它，那么我们为什么要关心定时呢？这就像是我们的小小好处，嘿，我花了多长时间来做这个，也许它会花太长时间，或者什么的。猜猜看，缓存一次应该比程序实际运行花费的时间要少得多。希望是这样的情况，随着我们的进展，我们将看看是否真的如此，好吗，我们继续。

获取开始时间，这就是你怎么做的。这是我上周展示给你看的，当时我们做了时间服务器客户端类似的事情。现在我们准备更新缓存，或者更准确地说，我们将检查字母是否在缓存中。首先，我们锁住它，然后在映射上进行查找，然后立刻解锁，不要锁得太长时间。

不要锁得比必要的时间还长。我们本来可以只做一个锁守卫，对函数的其余部分仅保护那个变量或者映射，但是我们不想这么做，因为我们希望其他线程也能读取它，并且其他线程也能更新它。所以不要锁得比必须的时间还长，这是一个明确的风格问题。

这也只会影响你的程序一次，所以要非常小心这样做。我们基本上是创建了一个布尔值，表示我们是否找到了缓存，或者是否在缓存中找到了字符串，然后我们将创建一个向量，把那些单词放进去。如果缓存命中，我们就完成了，对吧？我们基本上说“太好了”。

向量中的单词来自我们的缓存，故事好的方式是，find 函数的工作原理是，它给你返回一对，返回对中的第二个部分，迭代器会返回一个迭代器，而迭代器中的第二项是实际的向量，在这种情况下是映射中的值。好的，所以它会这样做，否则我们。

如果没有在缓存中找到，那么我们现在需要使用子进程。所以我们将调用我们的子进程，并且我们将设置子进程命令，我们怎么做呢？抓取一个单词查找器是程序的名称，letters.dot c string。这是我们刚刚获取的字母，作为第二个参数，第一个参数是。

通过我们的程序，然后没有什么特别的应该是你从斯坦福的变化中看到的内容。shell 好的，那么我们将调用一个名为 `poll formable words` 的函数，我们将传入向量的引用，并且我们将传入从子进程获取到的文件描述符。这基本上是在说，我们要获取所有的单词。

从子进程中获取它们，一次一行放入向量中，十分简单。别忘了，我们必须等到完成，对吧？如果你在做多进程，你必须做等待 PID。这个例子结合了我们到目前为止所做的一切，结果证明是这样的。然后一旦我们得到结果，我们知道之前没有缓存过，我们最好。

把我们的向量放入缓存中，所以我们锁定我们的变量，锁定我们的映射，我们应该通过缓存锁来锁定映射，然后我们根据字母的键更新缓存，字母已经排序好了。就这样，我们可以使用锁保护，因为当这个作用域结束时，锁会自动释放，即使我们之前是这样说的。

再次强调，我们之前故意说做什么哦，没错，没错，没错，我们不应该调用子进程，你可以调用，看看，你可以在这个情况下调用，哦，好的问题。问题是等等，我们不应该，我们不应该混合线程和多进程。在这种情况下，它实际上是可以的，因为子进程我们非常小心。

子进程仅允许它仍在同一个线程中，这种情况下是可以的。好的，我的意思是线程，现在你确实有多个线程，你有多个进程。但是我们在正确等待它，并且我们正在这样做。好的，所以在这种情况下没问题，是的，我想让我看一下更多的细节，是的，这是个不错的。

不过，这是个好问题，因为我们总是说不要混合，不能以这种方式混合它，虽然它确实能工作，但这是个好问题。所以我会进一步调查一下，是的，好问题，当然，我们现在要沿着这条路走。哦，是的，为什么我们通常不应该混合呢，如果你在一个线程中，并且你调用多线程，你在调用它，你在进行分叉。

在一个进程中，对吧，那么线程现在就算是在进程之外了，就像是它独立出来一样。线程必须协调，现在要等，等一下，我有另一个进程在运行，但我在进程中，线程也在运行，这就不一定是好事了。真是让人疑惑，为什么这样就能工作，但从这个角度看，你并不想这样做。

有一个线程管理器和一个进程管理器，它们并不总是能够很好地协同工作。一个进程中你应该能够调用线程，但我们这里做的是相反的，所以我会查一下原因，看看为什么。嗯，我不是这样做的，但总的来说，问题在于你有两个调度机制，它们不一定会很好地协同工作。

一起讨论这个问题，非常好的问题，这是一个很好的背景知识点。所以问题是，再讲一遍，为什么我们在这里使用锁而不是锁守卫？但我们可以在下面使用锁守卫，你完全正确，你的评论是在这里，我们需要在任何作用域结束前解锁。

如果使用锁守卫，它会在作用域外面不能正确释放锁，直到作用域结束后锁才会释放，而这不是我们想要的。但在这里，因为我们接下来的操作是更新缓存，然后要确保它肯定会正确退出作用域，所以我们可以使用锁守卫，没错。

你不必这样做，你可以在 `catch` 后面加上 `lock` 和 `unlock`，这样也完全可以，你并不会因此标记出问题，不，这不是风格问题，只是加了一个风格，它是风格上的选择，但并不是什么不好的做法，`lock` 和 `unlock` 完全没问题。追问一下，你有问题吗？没有？好，我就交给你了。这里有一些非常好的问题。

这就是关键部分了，获取到单词之后，就是花了多久的时间。然后我们获取结束时间，好，然后我们执行几个命令或者函数来计算持续时间，单位是秒。这是通过另一个时间函数来计算的，在这种情况下它只是用了秒数。

再加上毫秒或者微秒除以一百万，这样就得到了秒数。就是这样运作的。然后我们将设置负载，在这种情况下，我们基本上是根据是否已经处理完成，以及时间来构造负载，然后我们传入这个字符串，我们需要的。

我们要发送回客户端的字符串必须自己构造，而不是自动生成的。我们得从中创建一个 JSON 字符串。好，一旦构造好这个负载，我们就会使用一个名为 `send response` 的函数发送它。好的，负载是我们要发送回客户端的字符串，它是一个 JSON 格式的。

看看我们如何构建它。好的，这是一个很长的函数。其他问题？关于多线程、多进程的非常好的问题。其他问题？好的问题，很多问题。是的，问题是：嘿，这个时间是如何工作的？基本上，在这里我们创建了一个非常局部的变量，叫做 start，它恰好是一个结构体类型。

时间值，然后我们用当前时间填充，获取一天中的时间。我们会说，现在是什么时间，然后填充上这个时间。然后无论何时，我们都会保持这个时间本地保存。接下来，在做完所有检查或创建单词等操作后，我们再说，花了这么多时间，再次获取时间。

现在减去这两者，我们就能得到精确的持续时间，这正是你在期中考试中会做的事情。再说一遍，一切都要用时间来衡量。顶部的 sock 流基本上是用于读取数据的。我们会把数据写出来，接下来看看我们是否在其他地方读取它，或者它是否已经准备好，是的，获取字母就是。

我们将从那个地方读取，o string stream 是我们将构建一个字符串。这就是你如何做的，实际上它允许你逐步构建一个字符串。它的工作原理就像 Java 中的字符串构建器，你可能用过。你将看到它是如何工作的。

它是如何工作的，稍后你将看到它是如何工作的。对此还有其他问题吗？好的，让我们继续。

![](img/f50c184769ea64a2b64fcd4bbac6e714_71.png)

好的，所以词汇的轮询形式，这是我们需要使用从子进程中获得的文件描述符。我们将实际创建所有这些单词并将单词放入一个向量中。这其实很简单，对吧？我们将做这个，这是你之前可能没有见过的，它基本上是在创建一个数据结构。

它允许你为 C++ 创建一个输入流，仅此而已。然后我们从子进程中一次读取一行，直到读取到最后一行。然后我们将它推入向量中，这就是全部内容。那个向量是按引用传递的，所以你不需要返回或做其他操作。好的，发送响应时，请记住。

我们已经构建了有效负载，稍后会看到。好的，发送响应做了以下操作。它实际上是获取命令的反向操作。它是服务器发送数据回来的过程。之前我们做获取时间服务器时，我们并不关心格式是什么，它是我们自己特殊的格式。现在我们希望它是这样构建的，像一个 web 服务器一样。

客户端或网页浏览器可以使用我们的服务器。现在我们实际上是在提升这个问题的复杂度。我们说，“好吧，让我们从浏览器来做这个事情”，所以浏览器期望收到的响应格式如下。它期待我们说“我们正在使用HTTP 1.1”或“1.1”，然后它显示状态是什么，好的，在这种情况下是200。如果你去查阅的话，看看…

![](img/f50c184769ea64a2b64fcd4bbac6e714_73.png)

在这种情况下，HTTP 200表示，HTTP 200 OK状态响应码表示。

![](img/f50c184769ea64a2b64fcd4bbac6e714_75.png)

请求已成功，因此你会收到一个200状态码，表示“嘿，你的请求成功了”。有很多事情可能出错，比如服务器超时，这时会有不同的状态码。服务器也可能已经移动，记得我们之前看到的那个状态码是300，它的意思是服务器。

已经移动，你可以查阅所有的状态码，所有的。

![](img/f50c184769ea64a2b64fcd4bbac6e714_77.png)

状态码就在这里，200表示正常，201意味着有某些内容被创建。还有一个是accepted，基本上是服务器向客户端发送数据，告诉你当前发生了什么，通常你会看到200，这表示一切顺利。

![](img/f50c184769ea64a2b64fcd4bbac6e714_79.png)

一切顺利，那些执行重定向的状态码就是我们之前看到的状态码，接下来是客户端错误，400表示客户端说“哦，我搞砸了”或者“是你搞砸了”。然后服务器回应：“嘿，你搞砸了，你没有请求正确的东西。”

![](img/f50c184769ea64a2b64fcd4bbac6e714_81.png)

没有给他们正确的表单，或者是错误的请求、未经授权等等。500系列的错误意味着“我搞砸了”或者“服务器搞砸了”，它们通常出现在这里，内部服务器错误可能是其中之一。

![](img/f50c184769ea64a2b64fcd4bbac6e714_83.png)

你给了错误的请求，可能是超时之类的，或者是像418这样的状态码。让我们来看一下，有一个叫“我是一个茶壶”的状态码是418，它出现在这里。嗯，最早的一个网页服务器基本上是说办公室里的咖啡是否准备好，听起来很平常，但这就是事情的运作方式，当时就是这样。

创建这些东西，第一个网页服务器就是这个。所以某人编写了这个代码并说，如果你收到418，意味着你是一个茶壶。为什么？嗯，这就是事情的运行方式，这算是一个复活节彩蛋。结果证明，这样做没问题。好吧，我们会返回200，表示一切正常，然后你还会收到一个表示一切顺利的回应。

很好，然后你发送你的小反斜杠，然后你发送一些。头部，这是服务器发送给客户端的头部，好吧，这里的头部是text slash其中一个叫做content type，你在做后端服务器工作时经常会看到它，content type是我返回的数据是什么类型。

在这种情况下，我们发送的是text slash JavaScript，而且他们还说了我们使用的字符集。这是好事，因为全球的计算机知道如何翻译我们发送的内容。text slash JavaScript有点奇怪，我查了一下，我有点困惑。为什么我们要使用这个，为什么我们要自己使用它，所以我就查了一下，像是。

![](img/f50c184769ea64a2b64fcd4bbac6e714_85.png)

![](img/f50c184769ea64a2b64fcd4bbac6e714_86.png)

哎呀，JSON应该是什么样的内容类型呢。

![](img/f50c184769ea64a2b64fcd4bbac6e714_88.png)

![](img/f50c184769ea64a2b64fcd4bbac6e714_89.png)

如果你查找一下，当然第一个链接就是Stack Overflow，它说。我一直在这里乱搞，这是我使用过的，看到过的，哪个是。正确的，当我们使用的是application slash不，它是text slash JavaScript，所以你。

![](img/f50c184769ea64a2b64fcd4bbac6e714_91.png)

你可以用这个，但有人说不不不，你应该使用application不，抱歉，你应该。使用application slash JSON，那是我们应该使用的，所以我们可以改变它，然后。基本上你的浏览器如果能弄明白，它就知道大多数这些它会。

![](img/f50c184769ea64a2b64fcd4bbac6e714_93.png)

弄清楚了，这是我们在尝试的事情，在这种情况下，它说嘿，响应的格式会是什么样的。这就是我们正在做的事情，好吧，接下来我们。说数据有多长，所以内容长度是我要发送多少字节。你为什么需要发送数据，为什么不能直接在结尾加个零，它可能是二进制的。

数据可以是JPEG或其他不是文本的格式，而且你不能随意使用某些特定。字符来标识数据何时结束，你必须发送长度，这样客户端就知道。继续读取那么多数据，好吧，现在它可以一直读取直到结束，这也可能。没问题，但最好知道要发送数据的大小，这样它就知道数据的多少。

它在期待好吧，通常它会一直读取，直到没有剩下的，然后。说哦，所有数据都已经发送完了，记住，在我们的头部后面有换行，所以我们发送。了那个换行符，然后发送整个有效载荷，然后刷新以确保。数据通过网络发送过去，好吧，就这样，有问题吗。

这个，这些函数，这个响应是我们必须发送回去的，这样网站。或者说网页浏览器就知道该期待什么，好吧，接下来我们要做其他几件事。

![](img/f50c184769ea64a2b64fcd4bbac6e714_95.png)

看一下这里的获取字母功能，基本上就是从客户端获取字母。好的，怎么做呢？记住，如果你说的是 myth 58 /abcde，好吧，你还需要在其中包含端口号，但我们要抓取的是abcde部分。让我们看看我们是怎么做的，好吗？我们将做什么呢？我们获得了套接字。

我们之前已经设置的流就是这里，我们之前设置它的原因是因为我们要读取它，我们将创建一个方法字符串、路径字符串和协议字符串。因为记得有GET方法，然后是路径abcde，再到http 1.1等。好的，所以我们需要做的是方法、路径和协议，我们将读取它们，这就是流的一个好处。

你可以一个接一个地读取它们，噼里啪啦地连续读取，忽略其中的空白符，或者遇到空白符时就进行分割。好了，然后我们需要获取剩下的部分，也就是再来一行，因为我们知道在那之后我们还会有一行。好的，然后我们就使用路径。

是我们唯一需要用来获取路径末尾的部分，从中提取出我们的字母。所以基本上我们利用了你发送到特定路径这一事实，并使用该路径作为字母，这就是我们这么做的方式。好的，就这些。返回值是字符串，如果没有找到任何东西，那么我们要返回什么？

我们将返回整个路径，否则我们将只返回斜杠后的部分。是的，斜杠在这种情况下是暂停符。好的，然后构建负载部分将处理JSON部分。JSON是一种非常特定的格式，它以大括号开始，并以大括号结束，内部包含一些复杂的内容。

实际上，这里幻灯片上的那个我稍微修改了一下，以便我能稍后向你展示。基本上，真实的JSON实际上需要在所有不同部分周围加上引号，所以基本上所有部分都需要加上引号，这里没有反映出来，所以我想我应该更新一下。但是基本上，我们将会说返回。

时间退出时间，无论它是否被缓存，我们会设置为false，然后是我们从状态“OK”中返回的整个字符串向量。

![](img/f50c184769ea64a2b64fcd4bbac6e714_97.png)

我们说如果我们已经到了这一点，我们准备发送一个有效字符串，这意味着状态是“OK”。所以如果你已经收集了所有数据，一切准备好，你准备发送响应，且一切看起来都正常，你就发送“OK”，并说“是的，我准备好了，这是给你的有效响应。”

就是这样。如果中间有什么问题，比如网络断开，或者其他原因，你将无法收到响应，浏览器会超时，等等。

![](img/f50c184769ea64a2b64fcd4bbac6e714_99.png)

好的，好问题。那么我们已经准备好进行测试了，我还想展示一些其他有趣的东西。好了，我已经把它都写好了，它会是 Scrabble。Scrabble 单词查找服务器，我在 myth 59 上，哦不，我猜我在那上面，如果可以的话。

![](img/f50c184769ea64a2b64fcd4bbac6e714_101.png)

我们再做一下 12345，看看这样是否有效。好了，现在我们在 12345 了。所以如果在另一个窗口中我们访问 Talmet myth 59 12345。好的，在这里，注意到它说收到了来自 171.64.15.17 的连接请求。那就是日志，它说这是我们收到请求的来源，你的 IP 地址被发送。

当然，这个请求需要发送到服务器并进行记录。好的，我们来做一下我们的 `get` 命令，我们想要获取斜杠，然后假设是 Stanford。接着我们会写 HTTP colon slash 1.1，然后我们希望像 `host myth 59 I` 这样的一些信息。我认为它只是忽略了这些信息，在我们的情况中就是这样，接着就是这样，看看我们得到了什么。

我们得到了回来的所有单词，这也挺酷的，对吧？到目前为止都很好。那么我曾经承诺你们，我们可以从一个网页浏览器中做到这一点，看看它是否有效。

![](img/f50c184769ea64a2b64fcd4bbac6e714_103.png)

好的，如果我在浏览器中输入 myth 59 colon two three four five slash。有人给我提供一堆。

![](img/f50c184769ea64a2b64fcd4bbac6e714_105.png)

字母 a b c d e f j 好的，这一切都运作得很好，我们收到了我们的 JSON 响应。好了。

![](img/f50c184769ea64a2b64fcd4bbac6e714_107.png)

但这就是它的实际情况，这也是我们从网络服务器得到的结果。所以我们创建了一个网络服务器，实际上做到了这一点。好的，现在这有点有趣。顺便说一下，注意它花了多长时间？0.04秒，这就是它执行所有操作所花的时间。如果我们再次执行相同的请求，它花了 1.5 到 10 毫秒，甚至有时是负 5 毫秒，因为它是。

我们的服务器已经为我们缓存了这些单词，它们已经被缓存好了。我们的服务器只是直接提供了这些单词，不需要重新运行、也不需要调用那个子进程。Eva 告诉我们，这样做可能不是一个好主意，所以它就这样工作了。这就是它的工作方式。好的，现在你可能会想，这看起来并不是什么大事。

我访问过的网页是这样做的。所以你可以做的是，你可以，抱歉，是的，没错。那么你可以做的是让我打开，去到，好的，我现在去上面。

![](img/f50c184769ea64a2b64fcd4bbac6e714_109.png)

![](img/f50c184769ea64a2b64fcd4bbac6e714_110.png)

在这里，我们再做一次，但是这次是 myth 59 colon one three four five。好的，我这次没有加上那个。我在 JavaScript 中你实际上可以从 JavaScript 请求网站。好的，那我们就来做一下。你能做的事情，关于你的浏览器其实有一个很酷的功能，我也正是因此使用它。

因为我恰好知道如何使用这些工具，所以我决定使用 Chrome，看看这个。我们可以关闭这个，那么看看，这个可以变大吗？是的，我可以。好的，我们将实际使用一个叫做 fetch 的命令来做这个，所以如果我输入 fetch，它实际上有从网站获取数据的能力。好，如果我输入 HTTP://myth59。

dot Stanford dot edu colon 一二三四五，因为我们是 slash，让我们做一下呃，leland，假设我们有那些字母，好，然后方法，你采取这个方法。在这种情况下，我拼错了吗？为什么？哦，天哪，像这样，抱歉，抱歉，我现在感觉很糟糕。好吧，我在这里不会工作太久了，别告诉别人，拜托，好，继续。

我们将在这里使用 get 方法，我确实需要它，非常感谢，语法高亮很不错。好了，我们在这种情况下会使用 get，然后我们实际上会做一件叫做 then 的事情，这是请求的部分，告诉我们怎么做这个，你不需要了解这些细节，我只是展示给你看它是如何工作的，我们将返回数据。

dot JSON 因为我们知道它是 JSON，这就是我们所期望的。然后我们再做一次。然后在这种情况下，这是那个实际上做出响应的部分，好，我们可以做的是，我们可以通过控制台输出打印它：console dot log 和原则性日志响应。像这样，然后我们还可以实际捕捉错误，如果有错误的话，应该没有。

如果出错了，可能会有谁知道的错误，我们可以看看控制台日志，看看错误是什么。好的，如果一切顺利，我们来看看，好的，给了我们所花的时间，给了我们这些内容，就这样。所以我们刚刚写了一个小的 JavaScript 函数。再做一次，你自己会想，那看起来不像我见过的任何网页。

![](img/f50c184769ea64a2b64fcd4bbac6e714_112.png)

好的，但你可以做的是，我想去哪里？我觉得我把它放在了这里，是的，我放在那里了。顺便说一句，你们可以从你们的浏览器去做这个，我不认为他们在过去的五分钟内尝试过，不过那是什么？哦，是的，人们在做这个。谢谢，我猜大家都在做，你们可以做这个，我猜你们正在做。

类别 CS 110 WWW 好，看看它叫做 Scrabble word finder dot HTML，我写了一个小的 HTML 程序来实现这个，而我现在要更改它是因为我硬编码了。你不应该这么做，但我硬编码了错误的内容，我不知道它会在那里。123 或 5 在这里，好，基本上它是在设置一个小网页。

所以如果你做过任何网页工作，你会看到我只是设置了网页的标题和几个放置细节的地方，等等。如果一切顺利，我们应该能把这个放大一点，哎呀，我们应该能访问 web dot Stanford dot edu slash class slash CS 110 slash Scrabble word finder word finder。

.HTML文件，接下来我们可以继续，好的，我们有了字母，如果我们输入 L E L A N D 正确的话。没错吧，我们应该会得到返回，这就是我们的网页。所以我们创建了一个，顺便说一下，使用了 fetch 和其他 JavaScript 功能，说“哦，我知道这些是什么”，它将其转化为我们依然看起来很笨的网页，但它现在是可用的。

它就像任何你可能关心的其他网页一样正常工作，好的，那么里面还有什么奇怪的词吗？嗯，你可以从 Leland 获取 Dorns 吗？那是什么？不，你不能。你说得对，等等，怎么回事，刚才怎么不对了？再说一遍。哦，我可能说错了，不，我没，我应该是做了。哦，我的天，我做错了，你说得对。

![](img/f50c184769ea64a2b64fcd4bbac6e714_114.png)

好的，我会修复的，我会修复的，哇，好提醒，这没道理，好的，嗯，某种原因我以为应该能搞定，为什么没做到呢，反正我没做成。哦，找到了，就在那里，现在我们可以修复它，因为我们可以，这就是字母，我知道。我把它拿出来了，只是忘了做那个。让我们看看加号，让我们做这个斜杠加号。

字母，好了，实时改变网站，看看这个是否能更好地工作。好的，好的。好的，我不知道这是件好事，当你犯了个愚蠢的错误后还得到掌声。我要修复它，可能这是件好事。好的，你还有什么问题吗？今天有很多代码需要查看，但都在里面，里面有很多东西。

多年来，我会了解多进程的问题，提了个好问题。然后我们会做这个，好的，好的，好的，好的，好的。所以如果你只输入 myth 59，网络服务器就会是另一台完全不同的计算机。实际的斯坦福网络服务器并不在我们创建的机器上。我们创建了自己的小服务器，这部分很酷吧？对，但我们创建了自己的小服务器。

斯坦福大学使用的网络服务器是一个专业构建的开源服务器，但它是一个经过专业构建的服务器。它为你访问的所有常规斯坦福网页提供服务，比如你访问的 web.stanford.edu，这就是我放置这个页面的地方。但记住，这个页面是指向 myth 59 的，我做了一个硬编码，指向 myth 59，好的，这个是错的，这个标签页是我的计算机直接与 myth 59 对话的方式。

![](img/f50c184769ea64a2b64fcd4bbac6e714_116.png)

记得我前几天提到的 DNS 服务器吗？就是那个。域名服务器，你让它去访问 myth 59，你的计算机通过浏览器基本上就会查找出那个 IP 地址来进行连接，然后直接到达那里。

![](img/f50c184769ea64a2b64fcd4bbac6e714_118.png)

如果我现在在斯坦福的网站上，我就在访问斯坦福网站，浏览器正在与斯坦福网站交互，斯坦福网站通过 JavaScript 和它与我互动，然后它告诉我需要去访问 myth 59。所以基本上我正在从 web.stanford.edu 加载这个网页。

这是斯坦福大学的主网站，然后我自己直接在我的电脑上与 myth 59 进行通信。为了获取实际的单词，你也许可以通过另一种方式操作，让这个网站或我的电脑与斯坦福网站进行通信，之后斯坦福网站再与 myth 59 进行通信，这样就多了一个间接层。但是在这个例子中，我们跳过了这个间接层。

那里发生了很多事情。是的，端口关闭就在里面发生了，确实发生了。

![](img/f50c184769ea64a2b64fcd4bbac6e714_120.png)

当客户端套接字超出作用域时，它基本上会回到我们创建它的地方。我认为我们就是在这里创建它的，所以它会在这里结束时超出作用域。

![](img/f50c184769ea64a2b64fcd4bbac6e714_122.png)

这个函数，然后它关闭了它。这就是我们案例中，服务器关闭与客户端的连接的地方。好的，问题很棒。好吧，正如我所说，很高兴为大家解答。我……抱歉，之后随时可以停下来或者课后过来提问，期待见到大家。

![](img/f50c184769ea64a2b64fcd4bbac6e714_124.png)
