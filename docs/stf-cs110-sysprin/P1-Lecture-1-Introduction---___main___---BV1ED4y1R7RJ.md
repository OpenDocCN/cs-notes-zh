# P1：讲座1介绍 - ___main___ - BV1ED4y1R7RJ

好的，欢迎来到CS110。我是Chris Gregg，本学期教CS110，欢迎。这个教室，我们原本会在隔壁的好地方上课，但结果106AS就像你想象的那样巨大。所以我们就在这里。坏消息是，你们每一个人都必须来上每一节课。

讲座，所以所有座位都将被占满，我敢肯定。如果你决定不参加讲座，我们会详细讨论这意味着什么，随着课程的进行。CS110。计算机系统原理，我假设到目前为止你们已经修过CS106A或者某些AP课程，CS106B和CS107。如果你没有修过这些。

这系列课程欢迎每个人来，快点进来，你可以找个座位，我敢肯定中间有一些座位，你可以，我敢肯定你能找到一些。如果你还没有修过那一系列课程，特别是CS106B和CS107，这门课将会很有挑战性。现在，这门课整体上会有挑战性，正如你能想象的那样，但是它。

一些方面你做的事情，我们会做很多你在CS106B中见过的事情，因为你将构建大型程序，这意味着你必须使用你在CS106B中用过的许多数据结构，以及很多C++类，所以你必须记住这些事情，然后是CS107。

系统的这些内容，这也是一门系统课，所以你需要了解什么是指针，了解什么是void指针，虽然不需要了解太多，但你需要理解这些，需要理解什么是结构体以及所有这些内容。所以我们会讲一分钟的汇编代码，但就这些。

已经通过了107的障碍，那就是如此。那么，这门课是什么？

![](img/a24171389b50634ece0607b1841cc3fe_1.png)

这些内容其实有五个主要主题，几乎可以肯定你们没有详细了解过这些主题，你们可能看过其中一些，如果你自己做过一些编程，可能也见过其中一些，基本上就是五个主要的内容，第一个我们。

将涵盖，我稍后会更详细地讲解，但这是一个重点：Unix文件系统。所以你对文件有所了解，也使用过Unix，如果你已经登录过CS107等的myth。但我们将讨论实际的文件系统是如何构建的，像什么。

文件系统是什么？你如何实际追踪文件中的各个字节，并且如何追踪文件名，以及如何查找文件名和所有这些内容，这是第一个大主题，你会有一个关于它的作业，然后我们进入这个叫做的东西。

多进程的课程。你们知道，在计算机上，你可以同时浏览网页、打印文档、下载文件等等。所有这些都发生，因为你的计算机在同一时刻运行多个程序。

即便你计算机上只有一个处理器，操作系统也足够聪明，可以处理“嘿，我有两个程序或二十个程序在运行，我会为它们分配时间片，让这个程序运行一会儿，然后再给那个程序一点时间”等等。

在进行时，用户看起来似乎所有这些事情几乎是同时发生的。如果你的计算机有多个处理器或多个核心，事情就真的可以同时发生。所以我们将编写一系列程序来利用这些。

我们将编写一个程序，做我们所说的“分叉”，并在与第一个进程同时启动另一个进程，它们会同时进行。这个过程的难点是调试，你们觉得自己调试很牛，等到你们有两个或二十个任务同时运行的时候，再来看看吧。

同时进行调试时会有些更复杂，所以我们必须讨论这些内容。这是接下来要讲的第三个内容，信号处理是多进程的一部分。事实证明，如果你的计算机上有多个进程同时运行，你可能需要。

你可能希望它们互相通信。好吧，实际上，当你做这个叫做分叉的操作时，我们稍后会再次讲到，你会得到一个父进程和一个子进程，如果你想让它们之间通信，或者如果父进程想知道子进程什么时候完成，那么信号就会被设置。

我们接下来要讨论的这些内容，好了，然后我们将转到一个叫做多线程的东西，它是一个非常相似的话题，但它涉及到叫做线程的东西，这意味着一个程序现在在运行时，多个任务在同一进程中进行。

非常相似，但处理方式却完全不同。所以我们会过渡到这个部分，最后我们将讨论一些关于网络的内容。我们将构建一些服务器和客户端，并让它们在不同的。

通过机器和互联网等等，这将是课程的高潮部分。那么这些大话题都在讲什么呢？好吧，大多数话题其实都涉及操作系统方面的内容，所以110这门课经常被认为是类似于。

操作系统这门课稍微晚一点开设，它是操作系统的入门课程。如果你想深入学习操作系统，可以选择CS 140，去上一门实际的操作系统课程，但在这门课中，我们会讨论操作系统需要帮助你做的所有事情。好吧，这门课一共有八个部分。

会有八个作业，差不多每周一个，稍微超过一周做一个，还有期中考试。我们会把作业的截止日期稍微延长一点，这样你们有更多的时间来复习等等。你们可以查看所有的作业内容，基本上是测试我们要教授的所有内容。

我会讲的东西显而易见，还有一些多处理器相关的内容，以及一些线程的内容等等，最后会有一个汇总项目叫做MapReduce，它包含了线程、进程和网络，所有这些都结合在一起，这是一个很酷的数据集，最后一个作业就是这个。

这就是课程的概览，我看到有些人很友好。

![](img/a24171389b50634ece0607b1841cc3fe_3.png)

在这里我看到的各位脸孔都很友好，希望我曾见过一些熟悉的人。如果你之前没上过我的课，我的本科专业是电气工程，毕业于约翰·霍普金斯大学。之后我决定去海军服役，然后又做出了决定。

我去攻读了教育学硕士学位，之后稍晚些我还发现自己有一些GI Bill的学费资助，这是海军或者军方提供的大学资金支持，我还剩一些。所以我决定去攻读计算机工程的博士学位，并。

我一直在想我还是想继续教学，这种想法最终让我来到了马萨诸塞州的塔夫茨大学，然后来到这里，我已经在这里待了三年了。现在我是大三学生，所以你们中的一些人可能比我在这里待得更久。就这样，我讲授了很多课程，这也是我。

认出你们中的一些人，是因为我讲过106 B、106 X、107、107 E、208 E课程。这些是计算机科学中的伟大思想课程，我明年还会再讲。这是个很有趣的课程，通常班级人数很少，我们会讨论计算机科学中的所有这些伟大的思想，像是计算机科学的历史。

那门课很有趣，然后就是CS 110，关于CS 110的教学，我的第一学期是上个学期，通常这门课是Jerry Kane教授的，他本学期不在，我也想进来上110课程，所以我和Jerry一起上了这门课。课程名义上是他的，他也出了大部分作业。

我们不会做太多变化，我是一个和Jerry非常不同的讲师，但课程内容是一样的，除了几个小小的调整。我会尽量保持内容的稳定，稍微介绍一下我自己，我喜欢摆弄东西，如果你还没见过我的打字机项目，那。

音乐打字机项目，你可以在互联网上查找Chris Greg typewriter，然后你可以找到它，或者你也可以来我的办公室亲自看看。我喜欢做各种事情，从焊接到Arduino，再到树莓派项目。如果你有类似的项目，也可以来和我聊聊。

随时来找我聊聊这个问题，好吗？好了，还有谁？

![](img/a24171389b50634ece0607b1841cc3fe_5.png)

这门课有209名学生，截止到今天中午。它不是一个特别大的班级，但也算是相对较大的。你需要知道什么呢？我们主要会使用C和C++来编程，大部分项目实际上是用C++来做的。

之所以这么做，是因为使用C++字符串要容易得多，我们有很多很酷的东西，比如映射（maps）、集合（sets）等等，你可以使用这些功能。顺便说一下，我们会使用标准模板库，而不是斯坦福库。所以比如说，如果你想使用队列（queue），你就得使用。

如果你想从队列中取出前面的值，你需要使用`pop_front`，它会弹出一个值，但不会返回给你。如果你只使用`front`，它会把值返回给你。所以有一些细微的差别，你需要学习这些。大部分这些东西会相对自然地学会，不会花太长时间。

关于使用映射（maps）有一些小技巧，我会尽量提前给你们介绍一下，你们可能在CS 110中没有接触过的C++新知识。例如，这里有一些叫做闭包（closures）的东西，我们将在第一个作业中用到，并且会用到其他的大部分作业中。

你需要学习如何使用这些，我会解释如何使用这些，所以不用太担心这些。我们在这门课中会写相对复杂的程序，这意味着什么呢？这意味着你会有一个大型的代码库，你需要构建其中的一部分，你在之前的课程中可能做过一些类似的事情。

对于CS 110，可能还有一点适用于CS 107，这种情况甚至更加明显。人们总是先看看第一个作业，看到作业可能有15页长，或者类似的内容，文件数量也有22个。文件，其中一半是头文件，等等，你实际上需要能够理解这些内容。

在开始写代码之前，你需要理解这些内容。所以我会尝试。第一个作业是一个很好的例子，里面有一堆代码。你需要弄清楚应该把你的代码块放在哪里，这有时是这门课最难的部分之一。你应该能够追踪内存。

图示，你应该理解内存，如果你上过CS 107，我相信你已经了解足够的内存知识来应付这门课了，你还应该了解Unix和Linux，以及终端等内容，GCC和Valgrind。如果你上过CS 107E，例如，你可能根本不知道我说的是什么意思。

比如Valgrind，它只是一个程序，你运行它时，它会告诉你你的程序是否存在内存泄漏，或者你没有关闭文件等等，使用起来并不复杂，然后是make等工具。你不需要写make文件，但可能需要修改它们，所以稍微了解一下这些也不算坏主意。总共有10个助教，这个大致上和以前一样。

就像你们在107课上看到的那样，意味着你们有200个学生，而只有10个CAs，结果可能会比你希望的排队时间长，这就是现实。在办公室时间里，我认为这个问题在其他幻灯片中也有提到，110课程和其他课的不同之处就在于。

相比107，CAs不会审查你的代码，所以你带着bug去实验室时，他们会说：好，告诉我你的bug，发生了什么，之前做了什么，之后做了什么。他们不会坐下来帮你找bug，你们相互之间其实相信不相信。

你们现在已经是足够好的程序员了，应该能追踪到你bug出现的位置，对吧？当你进入多线程和多进程的环境时，这会变得更难，但到目前为止，你们已经相当进阶，我们也希望你们能够自己解决问题，这样就能使任务进展得更顺利。当然，如果你不幸碰到问题。

有些作业的要求其实并不开放式，它们更多的是让你写这个函数，然后你就写它，你的决定可能与你邻座同学的决定大不相同，CAs是无法坐下来试图搞清楚你们10个之间的区别的。

他们可能能给你提供的时间就是这样，所以就这样吧，至于它的价值，大多数人认为它其实效果不错，你会惊讶于**当你通过与自己讨论程序中应该发生的事情时**，这能转化为你自己修复bug的能力，真是令人惊讶，你不是更多的是六个或者七个吗？

现在已经不再是像107那样了，你可以依赖助教和CAs来帮忙。好的，CAs还会举办实验课，我稍后会讲到实验课的内容。所以，课程安排是这样的：每周一、三下午1:30到2:50，然后周五会有大部分实验课，时间大致相同。

另外，周四还有一些实验课，你可以注册参加。我稍后会详细讲解实验课。实验课其实并不是全程坐在电脑前的，你应该带上自己的笔记本电脑，实验由助教主持，大家喜欢这些实验课，因为它们让你感到一种更小型的互动氛围。

教学部分，好了，到目前为止有什么问题吗？我们稍后会讨论更多内容。

![](img/a24171389b50634ece0607b1841cc3fe_7.png)

后勤安排，我保证不会讲太多后勤内容，我们今天会深入讲一些真正的东西。今天 - 当然，网站是CS 110。stanford.edu，你可能猜到，这个网站并不是非常详细，它有课程讲座，有讲座幻灯片，有讲义，还有讨论部分。

信息和链接等等差不多就是这些，里面有一个日历，列出了目前所有作业的发放时间，截止日期还稍微需要确定一下。我们也有一个Piazza，你可以想象，Piazza会非常忙，因为有很多。

我们喜欢很多问题，并且要保持更新，保持关注，你将会处于一个不错的状态。然后我们还会有一个Slack频道，以防你需要查看，我不希望教学助理去Slack频道，我会盯着看。如果你有特定问题可以问，但它更多是供你们自己交流的地方。

如果你有问题，通常还是通过Piazza来提问。你可以想象，Piazza会非常忙，因为有很多问题。可是如果你有些想聊的内容，那Slack是一个更合适的地方。我有一些办公时间，你可以查一下这些时间。如果你无法参加我的办公时间，又真的想和我面对面交流。

给我发封邮件，我们会找时间见面。教学助理当然也会有自己的办公时间，我们可能这周就开始，但它们会在下周末正式开始，因为你们的第一次作业将在星期三发布。好的，正如我所说，教学助理在办公时间也不会看你的代码。

如果你有不理解的错误信息，当然我们会帮助你看。如果你觉得你的屏幕上有一些东西，看起来不对，我也能帮助你，至少能够帮助你弄明白那些错误信息是什么，如果你还没做过太多C++的编程。

编程时，你会发现C++的错误信息简直荒谬，所以这确实需要一些时间来理清楚，好吧，这是两个。

![](img/a24171389b50634ece0607b1841cc3fe_9.png)

课程教材是你可能在107课程中使用过的教材《The Bright》和《Halloran Halloran Halloran》，如果你要发音他名字的话，教材就是那个。实际上有一个为110课程定制的版本，里面包括了我们将在110课程中讲解的六到八章内容，如果你想购买那个版本的话，。

如果你上次买了整本书，继续使用它也没关系。如果你有稍旧的版本，也没关系，反正主要是供你阅读。我并没有指定书中的内容，书中的大部分内容也没有变化，而且这不像107课那样，旧版本是32位的。

架构，现在我们谈论的是64位架构，实际上在这门课中我们不会深入探讨这些细节，所以如果有问题也没关系。好吧，这里有另一本教材，主要是讲前几周关于文件系统的内容，书名叫《计算机原理》。

系统设计，如果你想在作业中表现好，阅读这本书很有帮助。它详细介绍了旧版Unix文件系统的构建方式。等到我们讲到这一部分，你会看到相关的阅读任务。你可以购买这本书，它也可以在网上免费获取，好吗？好了，讲座示例。

![](img/a24171389b50634ece0607b1841cc3fe_11.png)

这门课我会有幻灯片，但我还会做大量的实时编程演示，或者从我的笔记中展示代码。你会看到很多实际运行的代码示例。如果你想跟着一起做，或者自己查看，可以在线获取这些代码，我通常会提供链接。

幻灯片上的链接，你可以直接克隆整个示例库。我强烈建议你查看这些示例并理解它们的工作原理，特别是当它们在讲座中迅速展示时，而你可能跟不上，甚至不知道那是什么，就应该停下来逐行查看并尝试。

自己完成作业是一个很好的方式，可以帮助你迅速了解那些作业或代码示例。好的，我们所做的一切都会在**myth machines**上进行，如果需要的话，你也可以在**cardinal**上完成，但我们上课使用的机器是myth machines，如果某些工作不正常，那是因为机器的问题。

如果你因为出差而要坐飞机且没有网络连接，我们可以找办法让大部分内容在你的笔记本上运行，尤其是如果你使用Mac的话，但你也可以在电脑上安装Linux虚拟机，这样也能工作。我们可以搞定。

但大部分作业就像107一样，都会在这些机器上进行。好的，接下来是什么呢？幻灯片。我要尽量让幻灯片尽可能全面。有时我会听到一些抱怨，说幻灯片上的文字太多、内容太多。

幻灯片的内容，我会尽量避免过多聚焦于此，我当然会尽量避免像读幻灯片那样讲授内容，但你也可以把它们当作参考。虽然它们并不能替代出席课堂，因为我们会脱离课本内容，你也会问很多问题。

好的问题将会得到解答，我们会尝试解决一些不在幻灯片中体现的内容。我们在课堂上讨论的内容实际上会在期中考试和简答题中涉及，*当然不会偏离主题*。

你现在应该为此负责。顺便提一下，关于课堂是否会录像，实际上是没有录像的，虽然我带着麦克风，看起来像是录像了，但其实并没有。我通常会制作一个屏幕录制，这意味着你看到的只是黑板上的内容和我在讲解。

你将根本看不见我，有些人喜欢依赖这些资源，如果你依赖它们，只要知道有时我的电脑会坏，或者我忘记做屏幕录像，或者其他什么问题。如果你不想来上课，别怪我，我会尽力确保资源可用，我会尽力的。

这样做不是为了让你错过课程并错开讲座的时间，而是为了如果你需要回去查看某个讲座内容，这是一个不错的主意。做这件事是我这么做的原因，有些人会错开时间观看，我不会抱怨，但无论如何能看到你们我的脸总是很好的，没问题。

到目前为止有问题吗？到目前为止全是些后勤问题，好吧，我说过，我说过。

![](img/a24171389b50634ece0607b1841cc3fe_13.png)

这些内容大部分已经涉及了，关于这些内容的讲解，也有些大纲的内容再次提及，你可以在线查看大纲，我已经把这些细节放到日历上了，正如我所说，我们今天开始讨论的第一件事是 Linux 文件系统。

我们讲解了文件系统是如何实际工作的，以及我们将要使用的不同系统调用。顺便说一下，“系统调用”这个词可能是你之前没有听过的，它基本上是一个由操作系统内核运行的函数。所以你有自己的程序在运行。

然后它做一个系统调用，这就像是一个函数调用，进入内核，内核处理所有涉及系统的事情，比如文件和网络等。这样你就不能直接在自己的程序中访问它们，这是操作系统的一项安全特性。

好的，我们会讨论命名和分层，并讨论这些叫做iNodes的东西，iNodes是计算机跟踪你文件的方式，事实证明计算机实际上会给你的每个文件分配一个数字，真巧吧，当然会。

对，因为计算机比起单纯的文字更喜欢数字，所以有这么一个叫做iNodes的东西，它能区分你的文件和其他文件，实际上它只是一个数字。正如我所说，我们会讨论这个问题，然后我们将讨论多进程，并进行所谓的“分叉”操作。

就像是你的程序的分支一样，然后你必须能够协调这些进程，我们会用到像`wait PID`和`exec CVP`这样的工具，这基本上意味着将另一个程序立刻启动并运行，这已经在你的系统上了。

这是一种很酷的方式，可以在你的程序执行时运行外部程序。这个作业之一叫做 Stanford Shell，它基本上是在做你的 shell 所做的事情。如果我们来到这里，输入`LS`，那么这里就有一个。

![](img/a24171389b50634ece0607b1841cc3fe_15.png)

程序运行外壳，也就是你输入的内容，对吧？然后当我输入 `LS` 时，那是另一个程序，你的 shell 告诉操作系统，嘿，运行那个 `LS` 程序，然后再回到我继续执行。所以，当你输入 `LS` 时，这就是一个多处理的过程。

![](img/a24171389b50634ece0607b1841cc3fe_17.png)

就在这里，好吧，我们还会谈到保护地址空间，以及一点虚拟内存的内容。你知道如何在，嗯，让我看看我能不能做到，你知道在你们的 CS 107 课程中，我们画了这些内存图，并且我们说，好吧，它看起来不会像。

非常好，这里是另外的时间，我们做这些内存图，就像这是堆区，那里是栈区，或者，抱歉，栈是向下增长的，栈在这里，然后堆在下面，我做得有点反了，取决于你教的是哪一类课程，不管怎么画，栈是向下增长的，堆是向上增长的，嗯，这个。

类似地，它开始在某个值上运行，好吧，值无论如何都会存在。结果是每个程序都认为它可以访问整个内存系统，而这一切都是被虚拟化的，对吧？整个程序就像你的程序说，哦，我可以访问所有的内存，实际上每当它访问内存时，

操作系统介入并告诉你，实际上你正在看这个地方，但你以为你在看内存的这一部分，它是一种非常巧妙的方式来虚拟化东西，我们称之为虚拟内存，正因为如此。我们这么做的原因是为了简化你的。

程序一样，不是你的程序需要知道，哦，我被限制在这小部分内存里，而是你获得了整个系统的内存。我们会让它看起来像是你有整个系统的内存，我们会处理这些握手操作，让它返回到原来的状态，或者让它看起来像是你知道你正在做什么。

实际上存储内容的地方，它真正存在，我们将深入探讨这些细节，这都是多处理、异常控制流等内容的一部分。好的，我们还会稍微谈谈并发与并行的区别。并发是指两个或多个任务在同一时间内发生，而并行是。

这个想法是，你有一个大问题，正在将其分解成若干块并同时解决，所以在这里有一点区别。关于想法和抽象的部分，我们稍后会谈到这些内容，我们还会讨论如何在不同的程序之间发送信号，好吗？然后我说过我们已经。

![](img/a24171389b50634ece0607b1841cc3fe_19.png)

我们要谈论线程，这是另一种并发的概念。这是你可以利用线程概念模拟许多现实世界的事情，你基本上是说，嘿，我有一堆任务要做，它们可能会相互通信，我会将我的程序的一部分分配出去做。

这些事情相互独立地发生，直到接收到去。 做其他事情的消息，它们几乎同时发生，并为我们建模了一些有趣的问题。所以我们将会做那个，我们还。 必须讨论这个概念，如果你有两件事情都在尝试访问一个。

数据结构同时发生，假设它们都在尝试向一个。 集合中添加内容或从集合中读取内容，等等。如果它们正在尝试同时进行这些操作，而我们只有一个集合的副本，猜猜看，我们会遇到。 问题，除非我们说嘿，你先来，然后你先来，或者你先来。

第二个右边和一个接一个，我们可能无法对这些进行排序。 这也是这个课程的另一件事，存在很多非确定性的。 事情会在你的程序中发生，好吧，我指的不是那些。 只是错误的东西，我是说，当你连续运行两次时会发生的事情。

它是完全正确的，它将产生两个不同的输出，因为。 正巧操作系统首先抓取了程序的这一部分。 然后这个程序在略微不同的顺序中运行，所以这些事情。 是的，我们必须在接下来的过程中应对这些。

课程，好吧，但无论如何，关键是当你尝试通过两个不同的线程访问那个数据。 结构时，你需要做我们所说的锁定。 你基本上是说我现在要访问它，其他任何人都得等。 然后下一个线程可以继续进行，所以我们将。

进入这些细节时，当它工作时，它很有趣，而且有点。 挑战性，要做到正确，但它在工作时真的很有趣，好吧，好的，然后。 我们要讨论的是线程之间的一些差异。 在C和C++中的工作方式，大部分我们做的事情会在C++中进行，但我们会看到。

![](img/a24171389b50634ece0607b1841cc3fe_21.png)

差异，好吧，然后最后如我所说，我们要做网络编程。 网络编程，正如你所预期的那样，就是两台计算机相互通信，或者。 一台计算机通过一个叫做端口的东西与自己通信。 这涉及到IP地址，它是互联网确定哪个计算机是你的。

计算机是，如果你输入 myth。stanford。edu，它会去一个特定的计算机群。 和那是通过网络完成的，当然，我会写一些非常简单的网页，实际上会进行访问，这样你就可以用浏览器测试一些你的。 程序，我们将深入讨论这个，并且我们还会深入了解一些。

HTTP的细节，它是互联网中用来发送。 和接收数据的协议，就像两台计算机在相互通信时，必须就它们使用的语言和协议达成一致，否则它们永远无法交谈，HTTP恰好是。 互联网中使用的方式。

一种可行的方式，好吧，最后就像我说的，我们将最终实现一个叫做 MapReduce 的程序，这是一个将问题拆分成多个部分，让许多不同的计算机处理这些部分，然后收集数据得出最终答案的想法，所以这就是我们要做的事情。

最后一点，我们将在课程的最后几天讨论的内容，虽然没有实际的作业，叫做非阻塞 I/O。所谓的阻塞，我们稍后会看到一个阻塞的例子，意思是，当你请求数据时，程序会等待数据。

数据到达的过程称为阻塞，否则我们可以要求数据，然后继续进行，如果数据尚未可用，就会稍后返回并再次检查，所以这就是我们要做的最后一件事，好吗？所以这就是我要说的重点，就像我说的，本课程的大部分内容都围绕着这个。

就是操作系统的那一部分，所以我们将深入研究操作系统实际上为你做了什么，特别是 Linux 操作系统，但你猜怎么着，Mac 操作系统、Windows 操作系统和 Raspberry Pi 的操作系统也是一样的。

它们实际上是同样的事情，它们都在做同样的事情，具有相同的特性，因为有些人早些时候决定，嘿，这些是我们想要的很酷的特性。顺便说一句，在这门课中，我们会谈论很多内容，你会对自己说，嗯，这似乎。

这样做看起来确实像是一个非常具体的做法，你完全正确，这种做法确实是一些非常聪明的人做出的决定，我个人认为，他们选择了这种方式，当然有许多其他方法可以实现这一点。我们将查看第二个作业中的文件系统。

你需要知道该文件系统的所有细节，包括块号、I/O号，以及如何访问和存储多少数据等等。事实上，这并不是唯一的做法，实际上更新的操作系统使用了不同的文件系统，你的。

Mac 是一种文件系统，而 Windows 是另一种文件系统，这只是实现的一种方式。我们希望你能理解这一点，而不是单纯地认为，哦，天哪，这就是唯一的做法，我最好把这种方式完全记住。我的意思是，你确实需要知道它，但你。

你不需要特别认为，哦，这就是唯一的做法，请不要这样想。

![](img/a24171389b50634ece0607b1841cc3fe_23.png)

不要认为好吧，好了，这里还有一点点关于编程的后勤工作。作业占你成绩的40%，它们是最重要的部分。就像我说的，作业一共有八个，有些作业是做一个文件，做完你的事情就结束了，比如第一项作业，我想你得写。

基本上，大多数编程作业都要求你将代码写在一个文件中，但你需要在几个不同的文件中进行编写，通常你不需要写20个不同的文件，虽然每个文件都有一些关键内容，正如我几分钟前提到的，这些程序中涉及了很多文件，我们希望给你

编程作业既具有挑战性又有趣，为了做到这一点，很多时候我们需要进行大量的后端工作，才能让它顺利运行，然后你就可以做这部分内容了，这就是为什么有很多不同类型的头文件和其他东西，真的，真的，当你。

去阅读你的作业，花一两个小时看看头文件，哦，这就是那个，哦，这是什么，我最好记住这个，因为以后会用到，这将帮助你激活你的记忆，“哦，这就是我可以去用的东西”，你不会。

你会惊讶于Piazza上有多少问题都是关于“哦，我该怎么做？”而有人就在找这个头文件，头文件里面也有很多注释。这就是我对这个问题的评论，关于这门课的迟交政策，实际上，迟交政策可能会影响你得分，也可能不会。

这与很多其他课程有点不同，以下是运作方式。如果你按时提交，显然你可以获得最多百分之百的分数，这很有道理。如果你延迟最多24小时提交，你的作业分数将限制在90%。所以如果你在作业上得了80分，而你提交了。

如果迟交一天，没关系，你仍然会得到80%的分数，不会再扣更多分数。但如果你得了95分，它会被限制在90分，这就是它的运作方式。对于24小时内提交的情况，分数会下降到60%，如果超过48小时，分数会继续下降。所以你可能希望。

尽量在最多延迟一天的情况下提交，否则你会在很多分数上受到惩罚。我们通常不接受超过48小时的作业，除非有非常充分的特殊情况，比如生病，或者你有与课程相关的紧急情况，而不是另一门课，而是其他事情。

这与为什么你实际上不能做作业、参加面试或类似的事情有关，给我发个邮件，我可能会给你一个小的延迟，免费延长一下，看看哪部分哦，讨论小组。

![](img/a24171389b50634ece0607b1841cc3fe_25.png)

下一项，如我所说，周一和周三是你的讲座，唯一的例外是周五，我们将开始讲座实验部分，下周我们将进行三场讲座，只是为了能完成一些材料，为下周的项目或作业做准备，本周的三场讲座，接下来只剩周一。

周三的讨论课不是周五，周五通常是实验课和讨论课，正如我所说，助教会带这些课程，我也可能会带一个讨论课，它们会涉及一些理论内容，讨论我们在课堂上讲过的东西，但也有很多关于代码的分析和讨论。

代码，然后回答有关代码的问题，并做一些其他类型的细节分析，好吗？这些讨论课并不是强制性的，意思是如果你参加所有的实验课和讨论课，它们会占你期末成绩的5%，只要你出席，每次缺席一节讨论课，你的成绩会略微下降，期末考试的分数则会略微提高。

所以这不是一种惩罚，只是你如果不去上讨论课，就必须在期末考试上做得更好。这是针对那些说“我讨厌去讨论课”的人来说的。

觉得它们很无聊，不需要参加？好吧，那没关系，你可以不去，但这些课程是为了你的利益设置的。讨论课的报名将于4月7日（周日）中午12点开始，如我所说，大部分课程会安排在周五的这个时间段，一些课程会安排在其他时间。

所以，如果你真的想要一个周四的课程，周日中午左右早点去报名，好吗？我还不确定每个课程的具体数量，但到时候会公布的。好的，明白了。

![](img/a24171389b50634ece0607b1841cc3fe_27.png)

期中考试的时间是周四，5月2日，下午6点到8点。这是课外考试，我们会用蓝皮书，有人用过蓝皮书吗？是的，大多数人都用过。如果你没用过，它只是一个你可以写作答的工具，允许你输入答案。

人们倾向于喜欢这样，这也让评分变得稍微简单一些，而且你不需要担心自己的字迹问题，还可以擦掉、删除等等。我觉得这挺好的，它确实需要一台笔记本，如果你的笔记本电池不够好，无法持续两个小时，告诉我，我们会尝试为你解决。

好的，不希望因为这个原因导致任何人无法参加。考试是闭卷闭书的，你可以在期中考试时拿一张纸上的笔记。重要的事情是，你必须通过期中考试才能通过这门课。现在这意味着什么呢？意味着你们大多数人都会通过期中考试。

我是说，我们不会说“哦，40%的人因为期中考试挂了就要被淘汰”不会的，期中考试失败的人数非常非常少，但确实有可能会失败，所以你必须做得很好，必须达到及格分数。不要太焦虑，知道就好。

你确实需要做到这一点，这也让我想到另一个问题，我们这里有多少即将毕业的高年级学生？你们中的一些人对吧？首先，我想给大家掌声，好的，你们已经成功进入了斯坦福大学，差不多吧。还没完全通过斯坦福大学的考验，你们决定选择一门非常难的课程。

这门课是你们的最后一学期，有些同学可能必须这样做，我很抱歉如果你们必须这样做，这就是最终的安排。这是一门具有挑战性的课程，通常来说，你们可能没有修过后续的系统课程，因为你们本来就应该先修这门课程。所以这对你们来说可能是一门非常非常具有挑战性的课程，如果你们没有相关背景的话。

如果你发现自己跟不上进度，尤其是对于那些不能重修课程的高年级学生来说，这一点尤其重要，或者你必须和某些人一起上课或者其他情况，请请尽早寻求帮助，好吗？我知道我们在每门课中都会说这个，但是这真的非常非常重要，好吗？现在我们要给你们做一些多次练习。

我们会提供多次模拟考试，如果你在期中考试时间有冲突，我知道很多人会有，我觉得星期四晚上可能会有交响乐等活动没问题，你可以在当天早些时候参加，我们会稍后提供这些细节，好吗？

当然，如果你有考试 accommodations，请尽早发邮件给我。

![](img/a24171389b50634ece0607b1841cc3fe_29.png)

越早越好，期末考试的时间是6月10日下午3:30，考试占你总成绩的35%。它是综合性的，你将会看到有关文件系统的题目，期末考试是闭卷的，你可以带两页笔记，考试时间是6月10日下午3:30，抱歉，另外一个时间是晚上7点，如果你有冲突的话。

如果你有另一门课与这门课冲突，很多时候你会说你不能上。冲突的课程，我理解一些人有冲突的课程。如果你有两门冲突的课程，可以考虑在第二轮上课时解决。好的，或者三门冲突的课程，或者其他的冲突，弄清楚怎么解决，好吧，解决了就行。

你们做了什么其他关于期末考试的准备？通过了期末考试，通过了课堂考核，好吧。很少有人会失败期末考试，但确实会发生，好吧。好了，我想这些就是关于期末考试的所有内容了。

![](img/a24171389b50634ece0607b1841cc3fe_31.png)

![](img/a24171389b50634ece0607b1841cc3fe_32.png)

这是关于课程安排的最大问题，其实应该完全不需要提到的一个点是荣誉守则。看看一些作业是在网上的，好吗，你的朋友们以前修过这门课，或者作业在网上，或者其他地方因为有人把它们放上去了，你不应该把任何这些内容上传。

如果你们的作业上传到了公共仓库上，请注意我们会要求你们将其删除。如果你们在网上找到了类似内容，请忽略它们。你们应该按要求完成作业，我们有办法检查这些作业，所以我就说到这里，好的。

![](img/a24171389b50634ece0607b1841cc3fe_34.png)

在深入讨论文件系统之前，有没有关于物流的任何问题？如果没有，我们就开始讲文件系统。你们现在应该已经熟悉了Unix和Linux，对吧？如果你们输入`LS`，会看到当前目录下的文件列表。

![](img/a24171389b50634ece0607b1841cc3fe_36.png)

你会看到某个目录中的文件列表，你也可能已经在某个目录中往下遍历了一些距离，像这样……

![](img/a24171389b50634ece0607b1841cc3fe_38.png)

到达那里后，好吧，除了做这些事情外，你还可以做一些其他操作。

![](img/a24171389b50634ece0607b1841cc3fe_40.png)

输入`LS`时，如果输入`LS - AL`，例如，它会给你一个更详细的列表，其中A表示……

![](img/a24171389b50634ece0607b1841cc3fe_42.png)

`*` 代表所有文件，包括以句点开始的隐藏文件，`L`代表以较大格式列出文件的详细信息。在这里有两个特别有趣的文件，一个叫做“点”（dot），一个叫做“点点”（dot dot），你可能已经听说过这些。

这些是107的文件，但这些文件代表的是目录，表示当前目录是“点”文件（dot），而上级目录是“点点”文件（dot dot）。这就是你如何在目录中前后导航的方法。然后，这里其他的文件就是实际存在的文件，我想应该没有其他文件了。

![](img/a24171389b50634ece0607b1841cc3fe_44.png)

列表中以句点开始的文件是隐藏文件，然后还有其他一些信息，例如，这些在这里的内容稍后会进一步详细介绍。这告诉你它是否是一个目录，同时也列出了文件的权限，所以我们接下来会讨论文件权限。

在107中你没有遇到这些问题吧？我想你应该没有。好吧，文件权限基本上就是谁有权访问。

![](img/a24171389b50634ece0607b1841cc3fe_46.png)

这是你文件的访问权限，好的，列表上看起来我就是……

![](img/a24171389b50634ece0607b1841cc3fe_48.png)

只有其中一个有权限，因为在第一个破折号后的前三项是用户的权限，只有**我**（在这种情况下）有相关权限，其余的破折号是用于分配给你们这些属于不同组的用户，如课程组等。

你们也属于其他一些组，同时你们也属于“其他”类别，这是所有其他人的分类。

![](img/a24171389b50634ece0607b1841cc3fe_50.png)

那些是另外两个部分，我们稍后会更详细地讨论。好了，谁在给我发消息？请不要再发消息了，谢谢。你可以……

![](img/a24171389b50634ece0607b1841cc3fe_52.png)

请不要学会这样做，它很容易搞乱东西，反正不建议这样做。好吧，非常好，接下来……

![](img/a24171389b50634ece0607b1841cc3fe_54.png)

哦，对了，你所拥有的权限是读、写和执行，你唯一可以执行的文件是二进制文件，或者像。

![](img/a24171389b50634ece0607b1841cc3fe_56.png)

用 Python 等语言编写的脚本，好的，那就是为什么 X 变得重要。正如我所说，这些文件有三个部分，它们分别是拥有者部分、组部分和其他部分，每一部分都有自己的权限类型。如果上面有这个权限。

文件叫做 list，它有这些权限 - R W X R - X R - X，在这里。这基本上意味着，好的，拥有者有读、写和执行的权限。这里的拥有者是我，假设是我，组也可以读文件并执行，而其他任何人也可以读文件并执行，这就是这样。

权限是如此工作，好的，我们这样做是出于安全原因，我们也这样做是为了共享，如果你想共享东西等等。这里有趣的部分是，因为它是 R W 和 X，这意味着有三个信息位，三个信息位意味着三位二进制数的位。

你可以把信息编码成一个值，它的范围从零到七，这可能会让你想，嗯，为什么我们要用八进制的 8 系统呢？好吧，原因是，假设你有以下权限 R W X，假设 1 表示该权限已设置。

所以你可以这么做，零意味着它已被设置，因此不能再做任何操作，或者它未设置，所以 R W X 会是 1 1 1，就是 7，对吧，这是一个 1 或 7 之类的东西。将二进制转换成这个情况下的十进制或十六进制，或者如果是八进制的话，1 0 1 会是 R - X，这就是 5。

如果你拿到数字 7 5 5，那是一个八进制数，好的，所以它是一个 7。如果你在它上面加一，它就不会变成 7 5 6，而是变成 7 6 0，对吧。哦不，抱歉，它不会那样变，除非你加一，那它就会变成 7 5 6。如果你加三的话，它就会，或者如果你加三的话，它就会变成。

因为它是基于 8 的，所以重要的部分是，你通常会看到这些，只要把它们看作是每个三位二进制数的独立数字就行。这就是你真正需要了解的，好的，现在在 C 语言中，我们。

![](img/a24171389b50634ece0607b1841cc3fe_58.png)

你现在可以打开文件了，我猜你以前也做过类似的事。在其他课上，比如 107，如果你想打开文件，实际上有两种不同的类型。

![](img/a24171389b50634ece0607b1841cc3fe_60.png)

你可以用不同的方式来做这个，可以使用 open 命令，这实际上是一个系统调用。我之前说它看起来像是一个函数，其实它就是一个函数，你可以输入路径名，再加上一些标志，有些标志需要一个模式，也就是我们刚才讨论的权限，好的，你可以这样做。

![](img/a24171389b50634ece0607b1841cc3fe_62.png)

你可能会对自己说，哦，太好了，我知道如何重载函数，我知道。 所有这些，你可以在 C 语言中做到这一点，不知道你是否还记得 107，但。 结果是你不能在 C 中重载函数，那它是如何工作的呢？ 好吧，去看看。 你可以去 Stack Overflow 看看，看看是否有任何人查看了 Stack。

![](img/a24171389b50634ece0607b1841cc3fe_64.png)

今天的溢出情况，嗯，看起来有点丑，你的。 鼠标移过去，它会在后面加上小星星，还有横幅。

![](img/a24171389b50634ece0607b1841cc3fe_66.png)

一切都是如此，还有横幅之类的，它就像是说，就像90年代那样，他们尝试。

![](img/a24171389b50634ece0607b1841cc3fe_68.png)

让它看起来像90年代的风格，因为反正是愚人节，就这样吧。

![](img/a24171389b50634ece0607b1841cc3fe_70.png)

好的，等一下，来吧，好了，等一下，你不想再试一次。

![](img/a24171389b50634ece0607b1841cc3fe_72.png)

![](img/a24171389b50634ece0607b1841cc3fe_73.png)

让它变得稍微大一点，然后就这样，好了。 好吧，还是没变大，没关系，差不多。 好吧，你可以在 Linux 中使用 open 命令打开文件。 好的，你。 可以将文件打开为只读，这意味着你只能从中读取。

不能写入它，对，只读意味着你可以，我觉得这其实不是。 正确的标志，我会查一下，但你可以是只读、只写，或者你。 可以进行读写操作，这意味着你可以读取它并写入它，这是一。 点我不太经常做的事情，好吧，然后你可以做。

你实际上可以说，我想创建一个文件，我想创建这个。

![](img/a24171389b50634ece0607b1841cc3fe_75.png)

文件，当你创建一个文件时，你必须传入你想要的权限。 用于它，好吧，你可以通过执行 O_create（不带 E）来做到这一点。 这是因为他们想要一个安全空间，我猜他们决定不想再多一个字母，但你必须执行不带 E 的 O_create，它告诉。

你创建文件，然后 O_excl 表示只有在文件不存在时才创建文件。 这可能对你很重要，比如尝试创建文件，如果。 它已经存在就失败，不要重新创建文件，就像重新创建文件一样，所以我们要。

![](img/a24171389b50634ece0607b1841cc3fe_77.png)

关注这些事情，好吧，实际上顺便说一下，第三种模式是权限设置。 这实际上用于尝试设置权限。操作系统有点奇怪，好吧，操作系统做的其中一件事。 它说我要给你一组默认的权限。

创建这个文件，并且如果你告诉我创建更明确的权限，我。 不会让你这么做，听起来有点奇怪，但我会给你一个例子，展示如何。 它的工作原理，你可以通过一个叫做 umask 的命令来弄清楚，它基本上表示我们有什么默认权限，如果位。

如果你尝试为权限设置那个位，它不会生效，那时它就设置不对。

![](img/a24171389b50634ece0607b1841cc3fe_79.png)

让我给你展示我是什么意思，好的，我们实际上在这里写第一个程序。

![](img/a24171389b50634ece0607b1841cc3fe_81.png)

我们来看一下，我们把它命名为，我已经有一个程序了，我们将其命名为 show。

![](img/a24171389b50634ece0607b1841cc3fe_83.png)

你掩码点 C，好吧，在这里我们要做的是我们要包含一些东西，`#include`一些内容，`#include` h，`#include` cis/slash/types.h。还有一个，另外一个你也需要 `#include` 才能使用这个 u-mask 相关的东西，顺便说一下，我在打这些东西时总是犯错，所以如果你发现错误，抓住我。

`#include` cis/slash/stat.h 好的，然后你可以做我们的主函数， 就是 C 语言的，我现在就把返回 0 放进去，然后有一个类型叫做 mode_T，我会把它叫做旧掩码，下面是它的工作原理。

等于 u-mask，这意味着“嘿，给我你将允许我设置的权限。”好吧，我实际上会把它设置为零，这就意味着允许任何权限。这里有个小秘密，你可以设置任何权限，实际上可以设置，有点奇怪，好吧，但无论如何，它会执行这个操作。

然后，这是你获得结果的方式，挺愚蠢的，你必须先设置结果才能拿回来。所以我们可以做的是，我们可以说好吧，没关系，我们只需要把它设置回旧的掩码，我觉得这是一种奇怪的选择，但就是这样做的，好的，然后如果我们打印 F 你会发现掩码被设置为。

记住，它是八进制的，这些是八进制的。如果你写 `%0 3`，它会用零来填充它，然后你写 `0`，这意味着做一个三位数的八进制数。然后我们就用旧的掩码，我们就保持掩码，然后或者返回零，好吧，这一切其实就是在做这个。

![](img/a24171389b50634ece0607b1841cc3fe_85.png)

![](img/a24171389b50634ece0607b1841cc3fe_86.png)

你知道你的掩码会做什么，它会告诉我们哪些权限是正确的。好吧，077是什么意思，那三个位是什么，零代表什么，0 0 0，对吧？那七代表什么，一一一，那么这是什么意思呢？然后还有另一个，一一一，它的意思是用户可以设置任何权限，然后是组。

对于组和其他任何人，你不被允许设置权限。换句话说，它不会设置这些权限，它只是 —— —— —— 这就是它的意思。这看起来有点反常，但这就是它的原理。为什么我们这样做？这部分是因为有人决定了这样做。

希望事情更加安全，他们还希望某些东西能够有一些默认值。我和你们中认识 Michael Chang 的人聊过，谁上过他的 CS 107，他今天告诉我 UMass 的东西其实是个非常好的想法，出于这个原因。然后我说是的，没有人真正。

知道他去哪里，我知道没人知道，但无论如何，这就是关键所在。

![](img/a24171389b50634ece0607b1841cc3fe_88.png)

至于做这个事，它基本上就是在说你能设置什么权限。

![](img/a24171389b50634ece0607b1841cc3fe_90.png)

所以我们刚才做了这些事，现在我们实际上要写一个简短的程序。这些程序都是我说过的，你可以下载，或者实际上克隆到你自己的 myth 目录中。当你克隆它们时，你可以查看它们，好吗，每次我提到新的。

![](img/a24171389b50634ece0607b1841cc3fe_92.png)

示例我会把它们放到下一个存储库中，我想写的是一个小程序，它实际上打开一个文件或创建一个文件。

![](img/a24171389b50634ece0607b1841cc3fe_94.png)

然后设置一些权限，好吧，现在就让我们做这件事，我们这个。

![](img/a24171389b50634ece0607b1841cc3fe_96.png)

我打算把它命名为 open X.dot C，我已经在里面放了一些东西。好了，我们将要做的就是，我们基本上如我所说的，我们将打开一个文件，然后设置它的权限为某个值，好吧。我们打开它的时候好吧，好的。在 C 中，我们一般不喜欢全局变量。

变量，但常量是可以的。好吧，我们称这个为 K 文件名，我们就叫它我的文件。好的，这是一个全局变量，它是常量。好吧，有人知道 K 代表什么吗？常量，当然，这是某种原因，这是 C 中的做法，我不知道为什么他们总是这样做，但就是这样的。

我会再查找一个 K 文件存在错误，顺便说一下，把 K 放在那里很好，这样每次你在文件中使用它时，在程序的其他部分，你知道它是常量，这样它就能告诉你“好吧，我们稍后会解释这个”。然后在 main 中，我们只是简单地说。

你屏蔽了 zero，因为我实际上想按我的方式设置权限。结果发现，你必须设置它，告诉系统“嘿，我要按我自己的方式设置权限”。所以在这种情况下，我不关心 umask 是什么。好吧，然后我们做这件事，得到一个我们称之为文件的东西。

描述符，我们要去到 250 对吧？我们去到 250 文件描述符，这相当于在这种情况下打开 K 文件名。然后我们必须告诉它，“是的，这是错的，我会修正幻灯片。”只读是我们要做的事，我可以用位运算符将其与 0 或。

我们将创建并且可以使用按位操作，它与 `oh excl` 一起使用，意味着什么？对，只在文件不存在时创建文件，这就是这三个标志的意思。好的，然后我要改变，我将设置权限为 0 6 4 4，好吧，6 4 4 6 是什么？一一零，对吧？四是1。

零零和一零零零其他四个数字，注意我在这个数字前加了一个零，你认为这代表什么进制？它是八进制。事实证明，这就是在 C 语言中表示八进制数的方法。好的，然后我们将检查一个文件描述符，这就是我们的错误检查，你不需要做太多。

这是类中的错误检查，但我们通常尽量在讲座中或实际的幻灯片中演示如何做，因为你应该在实际工作中也这样做。`print F`，好，打开或创建时出现了问题，让我们调用一个 `percent S`，像这样。顺便说一下，在 Vim 中我不知道你是否知道怎么做...

很多人上个学期学了 CS107，并学了 emax，告诉你们，emax 也行，如果你想用它，你可以用 emax，我现在是个好人了，不管怎样。好的，如果发生错误，我们实际上可以使用一个叫做 `error no` 的东西来确定错误，文件存在的错误如果错误号等于文件...

如果文件已经存在，我们可以打印出来，好，文件已经存在了，对吧？如果我们不知道文件的状态，我们只会打印出未知错误 `error no`。你在 CS 107 中使用过 `error no` 吗？你可能用得不多，或许没有。`error no` 是一个全局变量，基于 C 语言，基本上它获取...

当你的程序出现某些错误时，这种方式有点奇怪，但这就是他们这么做的方式。这个方法将返回负一。

![](img/a24171389b50634ece0607b1841cc3fe_98.png)

基本上是说，嘿，我们的程序没有成功运行，然后我们将关闭这个文件描述符，就像这样，然后我们将返回零。好的。

![](img/a24171389b50634ece0607b1841cc3fe_100.png)

![](img/a24171389b50634ece0607b1841cc3fe_101.png)

那么文件描述符是什么类型？是整数。当你打开一个文件时，你会得到一个整数，很多时候是一个非常低的数字，比如 5 或 4，类似这样的数字。文件描述符是表示某个特定文件的低级方式，我们稍后会详细讲解这个内容。

一周后我们来看看它到底是怎么工作的。大家有没有看到其中的任何拼写错误？

![](img/a24171389b50634ece0607b1841cc3fe_103.png)

找到打开 `X`，好，如果我做 `open X`，它就会直接执行。

![](img/a24171389b50634ece0607b1841cc3fe_105.png)

我创建的文件名是什么？我的文件哦，"我的文件"，看，这就是它。

![](img/a24171389b50634ece0607b1841cc3fe_107.png)

注意权限是可读写的，然后记住它从第二个开始，这里第二个是指权限的设置。对于所有者是可读写的，对于用户组和其他人是可读的，这就是我们设置的权限。现在如果我再次运行它会发生什么？

创建文件时出现了问题，文件已经存在，对吧？我们检查过了，对吧？

![](img/a24171389b50634ece0607b1841cc3fe_109.png)

如果你想找出所有这些错误号，我会查找 `air no - L`，它会出现在那里，我们在课程中会用到许多错误号，用于不同的情况。在某些情况下，我们知道发生了错误，但我们不在乎错误本身，我们只想知道这是我们预期的错误。现在听起来有点奇怪，但我们会逐步理解，你会用到这些。

![](img/a24171389b50634ece0607b1841cc3fe_111.png)

给你一个所有文件号的列表，如果我们向上看，看到有很多，看看第17个，它写着文件存在，那个就会。

![](img/a24171389b50634ece0607b1841cc3fe_113.png)

内核执行打开文件的操作，然后将控制权交回给你的程序，从你的角度看，它就像一个函数调用，但我们需要了解一些底层的细节，明白吗？好吧。

![](img/a24171389b50634ece0607b1841cc3fe_115.png)

所以你会对这些操作变得熟悉，顺便问一下，在 Linux 上，如果我说错误号 `L`，然后能够在文件处理过程中中止文件，或者部分中止。

![](img/a24171389b50634ece0607b1841cc3fe_117.png)

总之，`less` 命令的效果很好，然后你可以。

![](img/a24171389b50634ece0607b1841cc3fe_119.png)

在 `less` 中上下滚动，看到它了，对吧？效果挺好的，这是一种不错的方法。

![](img/a24171389b50634ece0607b1841cc3fe_121.png)

你应该也习惯这些操作，好的，那么。

![](img/a24171389b50634ece0607b1841cc3fe_123.png)

这是文件系统的基础，接下来我们将了解许多其他低级操作，顺便提一下，`mask` 和 `open` 是这类操作中的两个，这些并不是真正的函数，它们是系统调用。当你调用 `open` 时，你的程序会把控制权交给操作系统，操作系统会。

让我们再做一件事，然后我就让你们去休息了，因为。

首先，我们来模拟 `copy` 命令 `CP`，好吧，如果你执行 `CP`，对，如果我们。

![](img/a24171389b50634ece0607b1841cc3fe_125.png)

执行 `CP`，我有一个叫 `copy.c` 的文件，然后我把它叫做 `copy copy.c`，这就有点元编程了，对吧？如果你这样做，现在就会有两个文件，`copy.c` 和 `copy copy.c`，它们是完全相同的。好了，现在我们删除 `copy copy.c`。

![](img/a24171389b50634ece0607b1841cc3fe_127.png)

我们想做的是，写一个小程序来复制文件，好的。我们通过执行 `open` 命令来做到这一点，同时也使用。

![](img/a24171389b50634ece0607b1841cc3fe_129.png)

还有另外两个系统调用叫做read和write，它们的作用如你所想的那样，读取。

![](img/a24171389b50634ece0607b1841cc3fe_131.png)

从一个文件中读取，然后写入文件。好了，让我们快速做一下这个。现在来看看copy.c，好吧，我已经有大部分了，已经完成了开头部分。

![](img/a24171389b50634ece0607b1841cc3fe_133.png)

其中有一些部分我想要能够正确格式化并完成。好了，这基本上是它，它说要运行这个，你需要提供文件名或复制命令，文件一将被复制到文件二中。好了，那它是如何工作的呢？好，我们需要一个输入文件，所以文件。

文件描述符打开argv中的第一个参数，哦，只读。好吧，它说我只会从那个文件中读取，所以我应该以只读的方式打开它，然后我们有了输出文件，它是另一个open，打开argv中的第二个参数，我们会做哦，写入模式，并且o创建（没有e）以及o_excl。

然后我们再次执行064，它会创建064吗？如果我不这么做，u-mask可能不会，但谁在乎呢，我们也不知道，好吧，你可以通过Linux设置你自己的u-mask，顺便说一下，如果你想这样做的话。好吧，反正这就是我们做的方式，现在让我们来做这个，创建一个缓冲区。

文件的长度为1024字节，好吧，然后我们会做s size t bytes red等于。现在s size t是一个奇怪的类型，你可能在107中使用过size_t，而s size_t是一个有符号的size_t，它允许我们使用负值，特定的目的是负一表示。

它会说发生了一个错误，这是他们使用s size t的唯一原因，否则它会使用size t，但这就是C语言的特性了。好吧，总之，bytes red等于，我们将进行读取，如何读取呢？我们从文件描述符读取，我们将数据读取到缓冲区，所以我们传入缓冲区并且我们。

读取缓冲区中的字节数，好吧，读取完成了。

![](img/a24171389b50634ece0607b1841cc3fe_135.png)

将字节数写入文件，好吧，然后它告诉我们读取了多少字节。现在，是什么导致程序没有读取我们传入的所有字节呢？可能是缓冲区的大小较小，如果文件只有10个字节，它不会读取全部1024字节。还有其他情况，实际上有一个。

实际上可能发生一种非常有趣的事情，可能是你尝试读取大量数据，以至于你的程序被时间片调度移出了处理器，去执行其他程序，然后它只返回了这么多字节。这个情况在读取本地文件时几乎不可能发生，但。

这在读取网络数据时经常发生。如果你读取网络数据并尝试读取一千二十四个字节，你可能只会读取到480个字节，即便那里还有更多字节，但它们暂时无法获取。这一切都是时间切片的问题，所以你需要小心处理。

你必须确保只写入你读取到的字节数，好的，出于多个原因。如果字节读取数为零，就跳出循环。

![](img/a24171389b50634ece0607b1841cc3fe_137.png)

有一件事我刚才说的不太准确，另一个原因是，你可能无法一次性读取所有字节。这个过程会阻塞直到所有字节都可用，结果是，如果字节数超过一千二十四个，它会或者，如果有一千二十四个字节。

字节数读取时，它会等待直到所有字节都读取完毕，但一般情况下，你可以在网络传输等场景下不必阻塞，没问题的。

![](img/a24171389b50634ece0607b1841cc3fe_139.png)

读取的字节数为零时，意味着我们完成了读取，因为没有字节返回。然后我们有一个常规的大小t字节，已写入字节数等于零，而已写入字节数小于读取字节数。已写入字节数增加。然后我们也向一个文件描述符写入数据，这次是输出文件。

缓冲区加上已写入的字节数，然后这是我们在缓冲区中查找的位置。结果就是这样，然后字节读取减去已写入字节数就这样。

![](img/a24171389b50634ece0607b1841cc3fe_141.png)

好的，我们将拥有这样一个奇怪的while循环。好的，我。

![](img/a24171389b50634ece0607b1841cc3fe_143.png)

少了一个，看看我哪里出错了，看看哪里，我还漏了一个，等一下，我敢打赌那是我的手机来电。是的，那是个垃圾电话，现在大家都接到这种电话吗？我听说这种机器人电话在过去一年里增长了三倍，真疯狂。好的，稍等一下，我们到时再检查。

无论如何，重点是，在做完这些之后，你需要实际关闭文件，然后关闭这两个文件，最后返回零。但这里有一个错误，我。

![](img/a24171389b50634ece0607b1841cc3fe_145.png)

![](img/a24171389b50634ece0607b1841cc3fe_146.png)

我只是想试试会发生什么，结果是这样。如果不是这样，就不在。

![](img/a24171389b50634ece0607b1841cc3fe_148.png)

是否中断，或者没有中断，23，好，看看我是不是漏掉了一个while语句。是的，我漏掉了一个while语句。好的，在这里我们需要一个while语句，它说的是“while true”。

![](img/a24171389b50634ece0607b1841cc3fe_150.png)

基本上是说，直到文件完成之前都要执行此操作，我刚才犯了个大错误，应该说直到文件完成。所以我们做了什么呢？我们打开了两个文件，一个用于读取，另一个用于写入，我们可以创建文件。然后我们每次读取一千二十四个字节，如果。

如果我们返回0，意味着没有字节剩下可以读取了。好的，所以我们可以停止读取，因为文件已经读取完毕。然后我们有一个奇怪的while循环，我们说，当写入的字节数小于读取的字节数时，就读取回写入字节的数量，然后继续处理。

缓冲区已经写入了某个字节数，我们就可以继续写入其余部分。这是同样的思路，当你不确定所有字节是否会一次性写入时，你就必须执行这个奇怪的while循环，好的。

![](img/a24171389b50634ece0607b1841cc3fe_152.png)

就是这样，它的工作原理就是如此。然后你应该记得在结束时关闭文件，我们确实会使用工具来确保你这样做。好的，制作副本吧。

![](img/a24171389b50634ece0607b1841cc3fe_154.png)

是复制吗？好吧，我们来做将copy dot c复制到copy dot c，并对比copy dot c和copy。

![](img/a24171389b50634ece0607b1841cc3fe_156.png)

![](img/a24171389b50634ece0607b1841cc3fe_157.png)

copy dot c 和 copy copy dot c，没错，它们是一样的。好的，就这样。

![](img/a24171389b50634ece0607b1841cc3fe_159.png)

这个工作得挺好，虽然理解起来不算太难，但其中还是有一些细节问题。你不能一次性写入所有字节并期望它们全部写入成功，也不能一次性读取所有字节并期望它们全部读取成功，除非在这种情况下，它确实能做到。我们知道它会在执行之前进行阻塞处理，好的，继续。

这就是复制程序的工作原理，计算机上的复制程序也并没有更复杂，CP命令并不比这个更先进。

![](img/a24171389b50634ece0607b1841cc3fe_161.png)

比这个更好，好的。那么关于这个还有一些事情，正如我所说的，你。

![](img/a24171389b50634ece0607b1841cc3fe_163.png)

你应该在做完之后关闭文件，让我们看看还有什么。如果你是。

![](img/a24171389b50634ece0607b1841cc3fe_165.png)

如果你习惯了C和C++，很多时候你会使用我们所说的文件指针（大写的FILE）和IO流等等，那是一个更高级的层次，使用读取和写入。我不这样做，基本上它知道如何处理那些while循环等等。那我们为什么在这门课上使用读取和写入？

有时候你必须这么做，因为你所做的操作类型有时会要求这样。你可能想这么做，因为你希望获得更底层的访问权限，这可能会更快，不会进行缓冲等等，你可能确实需要这样做。好的，很多时候你会使用流而不是文件指针。

因为这样更简单，所以在这个课程中大多数时候我们使用读取和写入，因为出于各种原因我们需要这样做。好的，我们在这里提前十分钟结束，如果你有问题可以过来找我，我会在课堂结束前一直待着。周三是下节课，到时见。

![](img/a24171389b50634ece0607b1841cc3fe_167.png)
