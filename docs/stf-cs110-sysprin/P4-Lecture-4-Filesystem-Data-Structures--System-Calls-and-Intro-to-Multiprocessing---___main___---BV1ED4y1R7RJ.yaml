- en: P4：Lecture 4 Filesystem Data Structures, System Calls and Intro to Multiprocessing
    - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P4：第四讲 文件系统数据结构、系统调用与多进程简介 - ___main___ - BV1ED4y1R7RJ
- en: Welcome。 Welcome to week two CS110。 I hope I've already had a nice weekend。
    I。 apologize for the lab sign up fiasco。 It was only half an hour but there were。
    some people who are definitely concerned about getting signed up。 It looks like。
    most people have signed up。 I can tell already that the Thursday times were， pretty
    important。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎。欢迎来到第二周的CS110课程。我希望我已经度过了一个愉快的周末。我为实验室注册的混乱表示歉意。虽然只有半个小时，但还是有一些人确实担心能否成功注册。看起来大多数人已经注册了。我可以看出来，周四的时间对于课程来说非常重要。
- en: It looks like most people wanted to do the Thursday times。 But in fact there's
    still some spots in the earlier time。 There's plenty of。 Friday times and you
    guys are signed up for the class during this term so it。 should be all right hopefully。
    If for some reason you are not able to get your。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来大多数人想选择周四的时间。但实际上，早些时候的时间还有空位。周五的时间也有很多，而你们在这个学期都已经注册了课程，所以应该没问题。希望如此。如果因为某种原因你不能参加你的时间段，请告知我。
- en: laptop in or whatever let me know。 We'll try to figure something else out。 But。
    most part looks like a lot of people got what they wanted and some people might。
    be didn't so just let me know if there's a big issue。 Okay so we are on to just。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把笔记本电脑或者其他设备带进来，请告诉我。我们会尝试找出其他解决方案。不过，大多数人看起来都得到了他们想要的，有些人可能没有得到，所以如果有大问题请告诉我。好了，我们继续。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_1.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_1.png)'
- en: re-plugging my tablet in here because it seems to be giving me fits。 I'm going
    to set this works maybe not。 Maybe we don't do this out。 Hold on one second。 I
    want everything。 This doesn't work。 It doesn't work。 Okay there we go。 All right
    so today we are going to continue with file systems。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在重新插入我的平板电脑，因为它似乎让我很困扰。我打算调整一下，可能没有效果。也许我们就不做这个了。等一下。我想确保一切正常。好像不行。不行。好了，终于搞定了。那么今天我们将继续讨论文件系统。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_3.png)'
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_4.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_4.png)'
- en: We're going to talk specifically about some data structures that the operating。
    system has set up for the for keeping track of files and for keeping track of。
    your processes as well as it turns out。 And then and remember this is the way。
    Unix does it or this is the way Linux does it。 It's not the way everything does
    it。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别讨论一些操作系统为跟踪文件和进程所设置的数据结构。正如事实所证明的那样，操作系统不仅仅是用来管理文件的，还包括进程的管理。然后记住，这就是Unix的做法，或者说这是Linux的做法，并不是所有操作系统都这样做。
- en: but it happens to be there Linux does it and it happens to be a pretty good。
    system for keeping track of your files for for what it's worth。 So we're going
    to。 do that then we're going to talk about system calls。 We have seen some system。
    calls already and we've used some but we're going to talk about the details of。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它恰好存在，Linux 做到了，而且它确实是一个非常好的系统，能够跟踪你的文件，至少在某种程度上是这样的。所以我们要做的是，接下来我们要讨论系统调用。我们已经看过一些系统调用并使用过一些，但接下来我们要讨论它们的细节。
- en: wait what does it mean to have a system call versus a regular function。 All
    right and then finally we should have time to start getting into the first。 kind
    of whoa this is a different way of programming which is multi processing。 Okay
    so I hope I hope you enjoy that part because it's actually kind of neat。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么是系统调用和普通函数的区别呢？好了，最后我们应该有时间开始讨论第一种——“哇，这是一种不同的编程方式”——即多进程编程。希望你们喜欢这一部分，因为其实它挺有意思的。
- en: once you start going whoa that's really I didn't really know you could do that。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始操作，你就会觉得“哇，我以前真没想到可以这么做。”
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_6.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_6.png)'
- en: for the program so that's what I think makes makes this stuff fun。 All right
    the。 assignment going all right assignment one going okay do Wednesday no there
    are no。 extensions of a allowed on no like late days for the first assignment
    and then。 the second assignment will be out on Wednesday as well all right come
    to。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作业还好，作业一进展如何？周三之前没有延期，也没有可以推迟的时间。第一次作业没有延期的余地，第二次作业也会在周三发布。好了，继续。
- en: off-sours we're still having trouble。 Okay so Linux when you run a program your。
    program ends up in what's called a process or it has a process that is。 basically
    saying it's given a number and it says this program is running and。 that's the
    process but it's running under okay we'll get to the details about how。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 离线外包我们仍然遇到麻烦。好的，所以在 Linux 中，当你运行一个程序时，你的程序会变成一个所谓的进程，或者说它会有一个进程，基本上是给定一个编号，并且它会说这个程序正在运行，这就是进程，它在某个地方运行。好吧，我们稍后会讲到如何工作的细节。
- en: that can change a little a little later but Linux maintains data structures
    to。 keep track of these processes of course it does right the operating system
    needs。 to know about your your programs that are running and so there's some data。
    structure that it keeps track so it keeps track of all the different parts of。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以稍后有所变化，但 Linux 会维护数据结构来跟踪这些进程，当然它会这么做，操作系统需要了解正在运行的程序，所以它会保留一些数据结构来跟踪这些内容，因此它会跟踪进程的不同部分。
- en: all the different things that are associated with your program okay they're。
    called process control blocks okay they're called process control blocks and they。
    have lots of information in them okay and they are stored in this thing called。
    the process table which is organized by the operating system okay process control。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与程序相关的不同东西都叫做进程控制块。它们叫做进程控制块，并且包含大量的信息，并且它们存储在操作系统所组织的一个叫做进程表的东西中。
- en: box store lots of things one thing that they score a store is called the。 descriptor
    table and the descriptor table is a data structure that holds。 information about
    the files you've opened or the files that have been open。 for you or the file
    like things that have been open for you or that you've。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 进程控制块存储着许多东西，其中一个叫做描述符表，描述符表是一个数据结构，保存你打开的文件的信息，或者是为你打开的文件，或者是你已经打开的类似文件的东西。
- en: opened like for instance networking is modeled using a file the terminal is。
    actually modeled using the file you can print to the terminal just like or you。
    can read and write from the terminal just like you read and write from a file。
    that's one of the beautiful things about Unix is they treat everything like a。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，网络就是通过文件来建模的，终端实际上也是通过文件来建模的。你可以像读写文件一样向终端输出或从终端读取。这是 Unix 系统的一个美妙之处，它把所有东西都当作文件来处理。
- en: file if you can this turns out but anyway they keep this thing called the。 descriptor
    table and each process maintains its own set of descriptors okay。 which is the
    things that it has open at the time and we all they always get 0 1。 and 2 for
    free those are standard out standard in or standard in standard out。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能找到这个文件，但无论如何他们保留了一个叫做描述符表的东西，每个进程都会维护自己的一组描述符。好的，就是它在运行时打开的东西，我们都知道它们会默认获取
    0、1 和 2 这三个值，它们分别是标准输出、标准输入或者标准输入、标准输出。
- en: and standard error they kind of get those for free okay most often they are
    what。 we call bound to the terminal in other words you type something and it goes
    to。 standard in you print out something from your program it goes to either standard。
    out or the standard error and those are the normal things now we will spend lots。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入输出和标准错误，它们是免费获得的。好的，它们通常会绑定到终端。换句话说，你输入的内容会送入标准输入，你的程序打印的内容会输出到标准输出或标准错误。这些是正常的事情。现在我们会花很多时间讲这个。
- en: of time in this course talking about hey what happens if we remap standard。
    into something else to reading in from a file or standard in standard or the。
    output of another program we'll talk lots about that as as the course goes。 goes
    along okay the descriptors as we've seen you use read write close etc open to。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程的后续部分，我们会讨论如果我们重新映射标准输入输出到其他地方，或者从文件读取标准输入输出，或是另一个程序的输出会发生什么。我们会讲很多关于这些内容的内容。
- en: actually interact with the files descriptors and then the process control。 block
    keeps track of all the different all the details of that okay if you do an。 open
    on a file you generally get a very small integer as the file descriptor。 because
    0 1 and 2 are taken and then it just kind of goes up from there and it's。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，描述符被用来执行读取、写入、关闭等操作，打开文件等。进程控制块用于跟踪所有不同的细节。好吧，如果你打开一个文件，你通常会得到一个非常小的整数作为文件描述符，因为
    0、1 和 2 是保留的，然后它会从那里递增。
- en: your own file descriptors are fairly small numbers generally okay all right
    now。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件描述符通常是比较小的数字，通常是这样的。好的，接下来。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_8.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_8.png)'
- en: this this diagram kind of goes down many levels here not many a few levels and
    we。 kind of understand each little level as we go if the file descriptor if a。
    descriptor is in use in other words it's an open file okay it maintains a link。
    to this thing called the open file table entry okay so if you have a file it's。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: open you've got this thing called an open file table entry which has some。 details
    about the file okay it has things like it takes it takes into account。 whether
    or not it's a read only file or read write file or write only file or。 so forth
    it takes it has and that's the mode part of it it also has this thing。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: called the cursor which just like the cursor on your screen tells you like。
    where in the file you're reading from okay so it turns out that you can do that。
    it also turns out that multiple programs can open the same file and be reading。
    from different parts of it at the same time okay so lots of lots of files could。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: be opened by various different programs and in fact they end up having this。
    cursor saying hey this program is at this point in the file and this program is。
    at this point that's the cursor okay it's also got this thing called the ref。
    count now the ref count discusses how or basically keeps track of how many。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: descriptors across all processes actually refer to that session okay and。 that's
    important because if you close the file it may be some other file needs to。 leave
    it open or something so it's not going to close it and just has this。 reference
    kind of that we will talk about what this other one this v node is in a。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: second but if you were to do something like say open some filing as read only。
    well this is what you might end up with you might end up with mode being read。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_10.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: because you've opened is read only cursor being at zero because it was just。
    opened and the cursor is right at the beginning ref count is one maybe you're。
    the only one in the system that has that file open it's pretty likely and the。
    V-Nope will get to in a second okay so that's how that that's how that works。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_12.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: all right and in fact this is for process one thousand and one which you。 can't
    see because that's way too small but process ID one thousand one later。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_14.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: today we'll talk about what process IDs actually are all about all right so
    what。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_16.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_17.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: else do we have well multiple and all the different processes on your computer。
    are take each have their own process control blocks and their own descriptor。
    tables but they all point to a common open file table it's actually a little。
    hard to read to I think but that's the open file table and this is where you have。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: all of the details of that that we talked about on the previous page but it
    may be。 more than one file might or more than one process may point to it okay
    now it。 turns out if you have a cursor like if two files are pointing to if two
    files。 are at different places in the in the actual file then you need to have
    two。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有我们之前页面上讨论的细节，但可能会有多个文件或者多个进程指向它。现在事实证明，如果你有一个光标，如果两个文件指向相同的光标，或者两个文件在实际文件中的位置不同，那么你需要有两个。
- en: different things you're pointing at okay but that's the basic deal there's one。
    open file table for all of the final resources and so you can share them I。 mean
    if 25 programs are opening a file you want to be able to share them question。
    yes the yellow and the green and the blue are the process control blocks for a。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的指向的对象。好吧，但基本情况是，有一个开放文件表，用于所有最终资源，因此你可以共享它们。我的意思是，如果25个程序都在打开一个文件，你就希望能够共享它们。问题来了。是的，黄色、绿色和蓝色是进程控制块。
- en: process so your programs running it might be the yellow one my programs。 running
    it might be the green one and remember we can all log on to the same。 time we
    can be running different programs at the same time we each get our own。 process
    control blocks for the offer the operating system does it now this is。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。所以你的程序可能是黄色的，我的程序可能是绿色的，记住我们都可以在同一时间登录，我们可以同时运行不同的程序，我们每个人都有自己的进程控制块。
- en: hidden commute by the way it's not like you can go and dig into your process。
    control block the operating system keeps track of that good question any of the。
    questions at this point yeah so a good question how do you keep track of which。
    file has reached which cursor these will actually point to different ones that
    if。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的通勤，顺便说一下，这并不是你可以去挖掘你的过程的方式。控制块，操作系统跟踪这个问题，任何一个。此时的疑问是，嗯，如何追踪哪个文件已达到哪个光标，这些实际上会指向不同的地方。
- en: they're at different places in the file so then you got I think you've got another。
    one that's open that has a different cursor associated with it that's because。
    you might be reading in different places so you're gonna have two copies of that。
    in that case okay and we'll talk about the Vino does in a second - that's another。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在文件中的位置不同，所以你会发现，我认为你还有一个打开的文件，它有不同的光标与之相关联，因为你可能正在从不同的地方读取，因此你会有两个副本。在这种情况下，我们稍后会讨论Vino是如何做的——这是另一个。
- en: one all right so we want to be able to keep track of all these files that are。
    shared okay in the case of 0 1 and 2 up here okay this this has a 0 and a 0 and
    a。 0 and a 0 that's standard in and they all happen to point down to this first
    one。 right here we look down here and then this one's all the way over here and
    they all。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以下面我们想要能够追踪所有这些共享的文件。好了，在0、1和2的情况下，这里有一个0，一个0，一个0，一个0，这是标准的输入，它们都指向这个第一个文件。我们往下看，这个则完全在这里，它们都指向。
- en: point to that one why because they're all reading from the same standard in。
    depending on which program happens to have control of the terminal at that。 point
    or the whatever the keyboard is going okay can't type in a keyboard and。 have
    to go to two different programs as it turns out okay it's only gonna go to。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 指向那个地方，为什么？因为它们都从相同的标准输入读取。具体取决于哪个程序在那时掌控终端或键盘的控制权，键盘是怎么工作的。好吧，你不能在键盘上输入并让它去两个不同的程序。这实际上只有一个地方。
- en: one program basically I mean there's a little more nuance than that but it says。
    basically the idea you also they also by the way all their standard outs go down。
    to this one okay and this one actually is interesting if you if you happen to。
    be running one program and and this is a standard act for like your programs that。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序，基本上我是说有一点点细微差别，但基本上就是说这个想法。顺便说一句，他们所有的标准输出都会输出到这个地方。这个地方实际上很有趣，如果你恰好正在运行一个程序，作为标准动作，你的程序可能也会在这里输出。
- en: you want if they offer like one kind of session if they all are printing things。
    out they all go to the terminal so you can run for instance make which you do。
    for your assignments right and make calls g plus plus will make may have some。
    output messages they go to the terminal and so does g plus plus because they。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望他们提供一种会话的方式，如果它们都在打印东西。它们都去终端输出，所以你可以运行比如make命令，你就会做作业对吧，make调用g++，会产生一些输出信息，这些信息会输出到终端，g++也是一样，因为它们。
- en: share the same file descriptor in that case okay the same they share the same。
    entry in the open file table in other words and that's just so that you can can。
    all they can all go to the terminal as it turns out okay so that's the basics
    of。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_19.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: that well guess what we can talk about these things called a V node so the V
    node。 is just a structure that holds the information about the file kind of like
    a。 cache and when we say cache we mean a place in memory that is storing something。
    instead of going back to the original location right it's stored in RAM。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: memory and it's very fast and that's what's happening with the V node here okay
    the。 V node is basically saying it's basically storing the details about what
    kind of。 file it is a regular file as a directory etc it also stores the reference
    count。 how many things have this file open and then it's stores a bunch of other
    details。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: needed to actually access the files a bunch of pointers and then it stores a。
    copy of the i node which we talked about last week which is the information about。
    a particular file so if a file is open you don't need to go back in if you want。
    to read from it or go back in and go and try to find it again in the file system。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: you've got the information about the i node right there okay so that's the details。
    and this gets updated as the file gets written to and so forth but and then that。
    gets that gets pulled in so those are the levels of the data structures that the。
    operating system and your program keep track of in order to in order to keep。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: track of what files we have open yes why does it store the ref count in two
    places。 that's probably a good question it may be depending on who's reading it
    when or。 which part of the which part of the opposite reading it when it'll go
    to。 either the it'll go to either V node or the open file table entry I'm not
    sure。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: why it does go but if they should be I think they should be locked up yeah。
    if you have different if you have you mean like this one might this one might。
    also point that would be a bad example of one but that might also point there。
    yeah so the ref count down here is how many of the open file table entries。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: point to that V node like you could have the same file open in two different
    ways。 okay because of you've opened and and that's I think that's the answer there。
    question it is a copy from the disk yeah this let me show you the next one right。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_21.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: here not the next one I'll get it I'll get to it what it basically does that
    just。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_23.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: reads it from the disk and then stores it in memory so you don't have to go
    look。 it up again on the disk just faster that way faster you can do that the
    better if。 you're you're dealing with things like memory， that's a good question
    the question is is the open file table sorted in any way。 no it's not sorted in
    any particular way you basically keep links to it it's not。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: like you're searching through the whole thing to find thing generally you have
    a。 like if your process opens a file it this green process might open this file。
    well it's got a link right there and it knows how to search that very quickly。
    and then it'll find here and then this might point to a V node that'll be so。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: it's it's not slow process not and the things aren't giant either there might。
    be thousands of files open but honestly thousands is small and computer speak
    so。 it's not a huge huge amount other questions right so this is a good。 question
    I should remember the answer the question was hey if I'm started if I。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: read from some file with this one another file is also pointing to it at the
    same。 time which cursor is getting updated I believe it may actually create a
    whole。 new entry in that case if it needs to have different cursors in different。
    places like if if one if if it's if it's reading through it needs to know where。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: it's reading from and so I think there's another one that created I'll look
    at it。 I'm not a hundred percent sure and where that one differentiates yeah anybody。
    else okay let's move on to another one here okay um there well I've already kind。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_25.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: of talked about this there's one system wide V node table basically because。
    everybody has to share these things because you don't want to have them all。 independent
    if you can help them help that okay it's kind of like an alias it。 says hey look
    somebody's opened this file why keep multiple copies of it for。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: each person that's or each file that's opened it let's just keep it all in one。
    place and then there's some coordination that has to go to deal with the cursors。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_27.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: and so forth all right and like I said the well first of all none of this is。
    really available to you just as the user the kernel keeps track of this you。 don't
    really want that by the way I mean you don't want you as the user to be。 able
    to walk through the open file table and see other people's files and what。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: other programs have files open or be able to change any details about that so。
    you want that to be somewhat secure and then this little i-node is and this is。
    basically separate from the file system by the way the file system is kind of
    on。 the disk and you keep a copy in memory of for instance this little yellow
    i-node。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: slice in memory okay and I'm not I'm not 100% sure when that actually gets。
    updated so but it like it gets modified that probably propagates through at some。
    point but it may not be immediate depending on the file system you're using。 okay
    so those are the big things now if you read the not the big textbook but the。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: smaller textbook the one that's online this is all laid out in that pretty。
    explicitly as well so if you need more details about it go with that all right。
    that's file systems like more details about that let's move on to system calls。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_29.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: this is where some interesting things happen system calls are as I've said。
    I've said this a number of times system calls are the way your program interacts。
    with your hardware and a network and things that are probably not so great to。
    have your program directly accessing why because you guys are mean and would。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: write malicious programs right like that's the basic idea this didn't always
    start。 this way Unix when it first started out you it was a very open sort of
    system。 and everybody it was in a research environment nobody was gonna go muck
    around。 in somebody else's files but when they when it started getting more and
    more。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: and more users they realized hey we better figure out how to make this so。 that
    there's good security and a system call is the way that works okay so we've。 seen
    some system calls already we've seen open and read and write and close and。 stat
    L staff there's all system calls okay we'll see lots and lots of more。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: system calls because remember this class is all about interacting with the。
    operating system and the functions are different okay we write functions or you。
    wrote some functions for 107 or 107 e that would have gone into let's say Lib
    C or。 just your user functions or lib standard C++ system calls have to be。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: privileged okay they have to access their own data structures that your。 program
    shouldn't have access to and they should be able to be partitioned off。 from the
    rest of the user okay and so that's what you really want to be able。 to able to
    do okay open needs access to the open file descriptor table and well。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: or the open and you don't want to be able to make the user have access to that
    okay。 in other words we shouldn't be able to get access to privileged information
    yet。 we still need to be able to open and close files okay so that's the bottom。
    line up so we need to have a different call and return model now if you took CS。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_31.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 107 or CS 107 e you'll remember that each process or maybe you don't and maybe。
    this was never explicit made explicit to you I mean 107 e those you took that
    it。 was pretty straightforward that the one program that was running has access
    to。 all of the memory in the system for 107 or for 106 B or whatever you run a。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: program it thinks it has access the entire system memory okay your program as
    far。 as its concerned can write and read from any part in memory now you can get。
    segfaults and things because you're not actually given that from the operating。
    system you can't just willy-nilly do it but that's the operating system saying。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序认为它有权访问整个系统内存，好吗？就程序而言，它可以在内存的任何部分进行读写。现在，你可能会遇到段错误等问题，因为操作系统并没有真正给你这么做的权限，你不能随意这么做，但这是操作系统在控制。
- en: look here's your portion but in the bigger picture it's not like if you were。
    able to access a different portion of memory some other program would be also。
    accessing it your program thinks it has all of memory this is going to become。
    very important in a few minutes but the 64-bit address space first of all it's。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，这就是你的部分，但在更大的图景下，并不是说如果你能够访问不同的内存部分，其他程序也会同时访问它。你的程序认为它拥有所有内存，这在几分钟后会变得非常重要，但首先，64位地址空间是非常巨大的。
- en: gigantic okay two of 64 is a very very very big number and as in the way the。
    operating system in the hardware works it like I said makes it seem like your。
    program has access to the entire memory system but it really does it this is a。
    virtualization layer what happens is you've got virtual memory which is the。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 两的64次方是一个非常非常大的数字，正如我说的，操作系统和硬件的工作方式，使得它看起来像你的程序拥有整个内存系统的访问权限，但实际上并不是这样，这是一层虚拟化层。发生的情况是，你拥有虚拟内存，
- en: addresses that your program thinks it's writing to and then that gets translated。
    into what we call physical memory which is the operating system in the hardware。
    saying okay this program actually has the memory here and this program has the。
    memory up here even though they both think they're writing to the same place okay。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 程序认为它正在写入的地址，会被转化为我们所说的物理内存，即操作系统和硬件会告诉你，好的，这个程序实际上的内存在这里，而另一个程序的内存则在这里，尽管它们都认为自己正在写同一个地方。
- en: so so it turns out that you can you can do that I wanted to show you an example。
    of that so I wrote a program and I was going to run it in two places at the same。
    time and show that it was the same memories place but it turns out that they。
    that the operating system plays some games for that so it doesn't ever put the。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明你可以这么做，我想给你展示一个例子。所以我写了一个程序，打算在两个地方同时运行，并展示它们是在相同的内存位置，但结果证明操作系统在这方面做了些手脚，所以它从不将它们放在同一个位置。
- en: same one even nearby it probably would if you if you if you tried to get a huge。
    amount of memory but but for you know for the purposes of this I couldn't quite。
    demonstrate it because the it was also a security measure - by the way I don't。
    know if you remember from CS 107 if you took that when you run a program the。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使接近的地方，它也不会放在同一个位置。如果你试图请求大量内存，它可能会这样做，但为了演示这个目的，我没能完全展示出来，因为它也是一种安全措施——顺便说一句，我不知道你是否记得CS
    107，如果你上过的话，当你运行一个程序时，
- en: stack ends up at a slightly different place and there's these canaries in there。
    that say whether or not the stack gets overwritten by a malicious user or。 something
    those are all security issues I think it's the same same sort of thing。 but anyway
    no process uses all to hunt to the 64 bytes okay most programs use a。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈最终位于一个稍微不同的位置，并且里面有一些看门狗检测，检查堆栈是否被恶意用户覆盖。这些都是安全问题，我认为它们是同样的事情。不过，反正没有任何进程会使用到64字节的全部空间。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_33.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_33.png)'
- en: very very small amount okay all right that's kind of the setup here there are。
    lots of different segments in the memory system you talked about some of these
    in。 one oh six or one or one oh seven or one oh seven e you've got the stack the
    stack。 is where your user program keeps all its local variables keeps its arrays
    and。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 非常非常少的内存，好吧？好了，这就是这里的基本设置，内存系统中有很多不同的段，你们在106或者107或者107e中谈到过一些这些，你有堆栈，堆栈是你的用户程序存储所有局部变量的地方，存储数组等等。
- en: keeps its kind of local data for functions the stack also is where function。
    calls get pushed on to all the data for function calls get pushed on to and you've。
    got the function calls the function calls in order on the stack okay you've also。
    got the heap you guys wrote a heap allocator and heap allocators get memory in
    bigger。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈保持着函数的局部数据，堆栈也是函数调用入栈的地方，所有函数调用的数据都会被压入堆栈，你有函数调用，函数调用按顺序压入堆栈，好吗？你还可以看到堆，你们写了一个堆分配器，堆分配器会分配更大内存。
- en: chunks generally and that's a different portion of memory there's also the code。
    section or also called the text section that's where your code is held okay。 there's
    a data section which is which has part of the data for like global。 variables
    things like that okay and the this this whole thing is managed basically。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: by the operating system for your process okay the operating system says here's。
    some memory for your process here's your stack here's your heap here's the data。
    here's the code go and it's it could look a very similar program to program but。
    again it's kind of abstracted a little bit away okay all right there's other。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_35.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: segments that you may not have talked about okay there's the shared 107 e。 definitely
    talks about this there's the shared library portion and the BSS。 portion and the
    read only data segment those are all segments that they're。 specialized uses read
    only data as you can imagine is read only data you're。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: only allowed to read to it you're not allowed to write to it they've got the。
    shared libraries if you have a function like printf right if you have printf。
    well there might be many many many programs all using printf at the same。 time
    to print out the individual terminals well why duplicate that code。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: for every user just put it in one code location and have that user or have the。
    user jump to that code location and run the shared code that's a good way to。
    save some memory okay and that's the way shared shared libraries work okay all。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_37.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: right so how do programs do function calls you should maybe remember this from。
    107 you have a stack pointer right and you have all these other registers in。
    here as well okay to call a function what do you do well you put a bunch of data。
    inside the registers rdi rsi rdx hopefully this is me。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: so it's up to some of us coming back to you from 107 right our CX etc if you
    run。 out of registers in other words the one two three four five six you start
    putting。 them on the stack and there's a very well defined way of doing that okay
    and。 again this is some people decided hey this is the way it's gonna be so this
    is。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: the way we're gonna do it it's not like this is some come down from high sort
    of。 you have to do it it's somebody decided this and said that's what we're gonna
    do。 the first the first parameters always gonna go into rdi the second parameters。
    always gonna rsi etc okay and then you do this call queue or call。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: assembly instruction and that jumps to the program code for your for your other。
    function in your own user's base and then it does the call and then you do a。
    return and it comes back that should be relatively familiar okay from doing。 107
    or 107 E although in 107 E you didn't have these register names they were。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: nice like R0 R1 R2 here there there are these these historical names from x86。
    days the original x86 days okay so that's how function calls work well what's。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_39.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_39.png)'
- en: the the big deal with that well this does not encapsulate the memory that we
    use。 in other words it doesn't hide that memory from anything else okay if you。
    have your let's say you have your main stack frame here okay and then you call
    a。 function just a regular function called load files well that's gonna go on
    the。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题在哪呢？问题在于它没有封装我们使用的内存。换句话说，它没有隐藏内存，其他任何东西都能访问它。如果你有，假设你有一个主堆栈帧，然后你调用了一个函数，叫做加载文件，这个函数将会在。
- en: stack okay and then you do your IF stream or whatever that might go on the stack。
    and then that's gonna call other like read and write function system calls but
    in。 this case remember from 107 where you did all that like sneaky stuff with
    I。 don't know if you still do this with like ATM machines and trying to pack in
    and。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你做你的 IF 流或者其他什么操作，这些可能会放到堆栈上，然后它会调用其他像读取和写入函数的系统调用。但在这种情况下，记得 107 课程中你做过那些偷偷摸摸的事情，我不知道你现在是否还会这样做，像是银行自动取款机，尝试进行某些操作。
- en: whatever because you can go and you can you can go and modify your own stack
    and。 whatever you can do that but that's not very secure okay in other words its。
    privacy is not the prime concern here basically they're saying look if you own。
    the stack for your program sure you want to muck around in your own stack go。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，因为你可以修改自己的堆栈等等，你可以这么做，但这不是很安全。换句话说，隐私并不是这里的首要问题。基本上他们的意思是，如果你拥有程序的堆栈，当然可以在自己的堆栈里乱搞。
- en: right ahead who cares you might crash your program or you might modify something。
    for your own program but it doesn't matter right that doesn't matter it all。 the
    things change everything changes when you all of a sudden have to go to when。
    you have to go to the system and get information from the system okay so now。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吧，谁在乎呢？你可能会崩溃你的程序，或者你可能会修改一些属于你自己程序的东西，但这不重要，对吧？这不重要。问题就出在，当你突然必须去系统获取信息时，一切都会改变。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_41.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_41.png)'
- en: we get to system calls well system calls okay like open they as we said I said。
    a hundred times already they shouldn't be exposed and they are need to be stored。
    in a region of memory that your program does not have access to okay it can't
    be。 a shared library it can't be something that your program could actually code。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了系统调用。系统调用，比如打开文件，正如我已经说了上百遍的那样，它们不应该被暴露，并且它们需要存储在一个你的程序无法访问的内存区域。它不能是一个共享库，它不能是你的程序实际上能编写的内容。
- en: that you write modify just shouldn't be allowed okay so what do we do well we。
    break up the memory diagram into a space that has the kernel stack in it okay
    you。 are not allowed to write to there and if you tried to the operating system
    would。 stop you anyway okay but the kernel stack resides in memory but your programs
    do。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你写入的东西就不应该被允许了。那么我们该怎么办呢？我们把内存图分成了包含内核堆栈的空间。你不被允许写入那里，如果你尝试写入，操作系统会阻止你。内核堆栈存在于内存中，但你的程序并不。
- en: not have access to that okay you basically have to tell the operating system
    hey。 I am about to do something or I want you to do something for me that involves。
    something I shouldn't have a direct access to okay so it needs to be in a。 region
    of memory that the user can't touch and it needs to be executed in a。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 没有访问权限。你基本上得告诉操作系统，“嘿，我现在要做一件事，或者我希望你为我做一件事，这件事涉及到一些我不应该直接访问的东西。”所以它需要位于一个用户无法触及的内存区域，并且需要在一个段中执行。
- en: privileged what we call super user mode okay so that that mode can have access。
    that this is not your code anymore okay it's the code that's owned by the。 kernel
    okay the kernel owns the that code and you have to say to the kernel。 hey go do
    this for me okay it's called kernel space and it's got the stack。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 特权模式，我们称之为超级用户模式，好吧，这种模式可以获得访问权限。这个时候，这不再是你的代码了，好吗？它是属于内核的代码。内核拥有这些代码，你必须对内核说，“嘿，帮我做这个。”这就叫内核空间，它有自己的堆栈。
- en: segment and it's got its own instructions as well okay we can't use call queue
    any。 more to do this okay because the minute we use call queue that stays within
    our。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它也有自己的指令。好了，我们不能再用调用队列来做这个了。因为一旦我们使用了调用队列，它会停留在我们的堆栈内。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_43.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_43.png)'
- en: own address space we could we could do that so we need a different way of doing。
    it what is that different way well that different way is to do a thing called
    a。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做些不同的事情。如果我们需要不同的方法，我们可以做的不同方式就是执行某个。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_45.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_45.png)'
- en: sys call and it's an actual instruction I'm going to show it to you in a second。
    okay and what it is is you place an opcode in other words an operation you。 want
    to do all the operations that are the system codes have and have a number。 associated
    with them if you want to read you've got one for the operation code if。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用（sys call）实际上是一个指令，我马上给你展示。好吧，它的作用是将操作码（opcode）放入，也就是你想要执行的操作。所有系统代码的操作都对应一个编号。如果你想读取，它有一个操作码。
- en: you want to write it's to open happens to be three we'll see that in a minute。
    open is three etc okay they all have their own opcodes that are based in the。
    kernel defines them okay and then you place arguments same as before you place。
    them in a bunch of registers now it happens for some reason it goes RSI R。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想写入，它的操作码是3，我们稍后会看到。打开操作是3，等等。每个操作都有自己的操作码，这些操作码是由内核定义的。然后你将参数放入，就像之前一样，将它们放入一堆寄存器中。现在出于某种原因，它变成了RSI和R。
- en: DIRS R DX R10 instead of RCX I don't know why that's changed but some other。
    reason for that not important for this class at all but that's that's the way。
    that goes and then what you do what you do is you perform what's called an。 interrupt
    one or seven E folks you'll know what interrupts are but an interrupt is。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: DIRS R DX R10，而不是RCX，我不知道为什么会有这个变化，但出于某些原因，它变了。对这门课来说不重要，但就是这样。然后，你所做的事情是执行所谓的中断1或7E，大家应该知道中断是什么，中断就是。
- en: basically saying hey operating system stop my program and handle this and the。
    operating system goes oh okay your program is not gonna be stopped and then。 I'm
    gonna go do I'm gonna look at the registers and do whatever you want and。 then
    I'm gonna start your program up again that's basically what an interrupt。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你是在说“嘿，操作系统，停止我的程序，处理这个任务”，然后操作系统会回应：“哦，好吧，你的程序不会被停止，然后我会查看寄存器，执行你想做的，然后再启动你的程序。”这基本上就是中断的作用。
- en: is doing it's interrupting your program until whatever you're asking get to
    get。 done gets done okay we're gonna see that a lot in this course of your program。
    waiting around for something else to get done being in some sort of interrupted。
    state or sleep state or something like that okay so you put all these things in。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的事情是中断你的程序，直到你要求的任务完成。好吧，在这门课程中，我们将看到你的程序会一直等待某些任务完成，处于某种中断状态或休眠状态之类的。好吧，所以你将这些操作放入。
- en: the in the registers you do this cis call it handles it and then it returns
    back。 to you with the result as you might expect in our a X except for a couple。
    things there's a question oh such a good question the question was yeah this。
    question was what happens if you have more than six arguments you don't there。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在寄存器中，你执行这个系统调用，它会处理，然后将结果返回给你，正如你预期的那样，结果在AX中，除了几个例外。
- en: are no system calls that are that have more than six arguments in them that's
    by。 the rules because of that exact reason you don't have access to put them on
    the。 stack so they they get put in the just in the registers you have and no system。
    calls need more there are there are ways of getting around that by the way you。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 没有系统调用会有超过六个参数，这是规则所在。正因为如此，你没有权限将它们放入堆栈。所以，它们被放入你拥有的寄存器中，并且没有系统调用需要更多的参数。当然，事实上，还是有办法绕过这一点。
- en: can but but in general there are no system calls that have more than six other。
    questions yeah yeah let me talk about the interrupt handler good question the。
    question was just like what's what's the steal the interrupt handler it's。 another
    function that's actually in the kernel space that runs and that function。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有个问题，非常好的问题，问题是，如果你有超过六个参数会发生什么？其实不会有这种情况。一般来说，没有系统调用会有超过六个参数。其他问题呢？是的，是的，让我讲讲中断处理程序。好问题，问题是“中断处理程序是什么？”这是内核空间中的另一个函数，它会运行，这个函数。
- en: goes okay now I'm in kernel space on the on the kernel I get to do and I get
    to。 access all things you can't affect that function at all but you can call it
    and。 that didn't calling it through the cis call method that we have here that's。
    how you do it so what's the bottom line on that this is how you tell the。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: operating system please do something for me because I'm not allowed you're not。
    allowing you to do this system calls or wait the way you do that and then there's。
    some some details about what happens if you return to the regular function and。
    there was an error if you if you have a return value that is negative what it。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: does is it sets the error number or air no which is that global variable to
    the。 positive value of that negative value why that's just the way they've done
    it。 and then you update r a x to actually contain negative one so if you do a。
    system call and you get back negative one you know that you've that you've got。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: an issue and and then you go and check the error number okay yeah air number。
    air number air no is per process yes it's part of the sea library yes。 yes so
    when you call the when you when you do the interrupt the current knows。 that your
    process is the one that in a yeah and it knows where to find those。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: details good question anybody else all right so that's how system calls work。
    I'm not gonna ask you too many more deep too many details about this I'm not。
    gonna certainly not gonna like make you do any assembly coding or anything like。
    that for this but I do want to just show you what happens when when you do。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_47.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: this remember the copy function that we had the copy function opened up two
    files。 opened up a file to read from opened up about the right right to and then。
    copied all the data out of one into the other let's look at that in gdb and let's。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_49.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: actually let's see let's stop it on line 19 we'll break on line 19 and we'll
    run。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_51.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_52.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: the program okay whoops I gotta run it with let's say copy that see to copy
    copy。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_54.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: dot see okay all right so now we stopped online 19 we're about to step into
    the。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_56.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: system call if I do yes to actually step into the system call you'll see that
    it。 goes into cis call template we haven't quite called the actual system call
    yet。 because we have to do the setup in other words we have to set the we have
    to set。 the parameters and we have to actually do that cis call but we can do
    disassemble。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_58.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: here and we'll notice that you have things like the a couple things going on
    here。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_60.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: that this is not really that important but it's gonna move some of some detail。
    like move 0 to remember I said open was 0 to for the。 operation code well there
    goes right there okay and and I think I said our。 DI is the where the actual name
    of the pro the first argument remember open here's。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个其实并不是特别重要，但它将移动一些细节，比如将 0 移动到记住我说过 open 是 0 到的操作码，好了，那里就是了。好的，我想我说过我们的 DI
    是程序的实际名称的参数，记住 open 的时候。
- en: what open looks like it is let's see let's just list 19 again whoops。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 open 长什么样，我们来看看，我们再列一下 19，哎呀。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_62.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_62.png)'
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_63.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_63.png)'
- en: list there it is so that's the open call is our V1 which I type is copy dot
    see。 okay is there all right so let's actually do this let's do this for I。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，那里就是它，所以这就是 open 调用，是我们的 V1，我输入的是 copy.dot see。好吧，好了，我们来做这个，来做这个给 I。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_65.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_65.png)'
- en: '- or if you this will actually list all the different instructions as I''m
    going。 through it let''s step into the instructions one at a time okay it''s gonna。'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '- 或者，如果你这样做，它会列出所有不同的指令，当我逐一查看时，接下来就一步一步执行这些指令。'
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_67.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_67.png)'
- en: do a couple things that aren't that important but then it's going to move。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 做几件不太重要的事，但接下来它将会移动。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_69.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_69.png)'
- en: 0 to which is the opcode into a E ax or our ax and then it's gonna do the。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 0 到这个操作码进入 E ax 或我们的 ax 然后它会执行。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_71.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_71.png)'
- en: cis call okay and it's gonna do the syscall so if we look our AX is going to。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: cis 调用，好吧，它将执行系统调用，所以如果我们看看我们的 AX，它将。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_73.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_73.png)'
- en: be to well that's the opcode for open if we print out our DI let's cast it to
    a。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是 open 的操作码，如果我们打印出我们的 DI，我们可以把它转换成一个。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_75.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_75.png)'
- en: char star our DI it should be there we go copy that see okay so it's done the。
    setup and it's about to call the function for us okay and do the system call now。
    you might ask you oh great can I step into the system call kind of impossible。
    to step into a system call because the operating system is running your program。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: char star 我们的 DI 它应该在那里，我们复制那个 see，好了，所以它完成了设置，并且即将为我们调用函数，好的，执行系统调用。现在你可能会问，哦太好了，我可以进入系统调用吗？有点不可能。进入系统调用是很难的，因为操作系统正在运行你的程序。
- en: which is running GDB or I guess it's running GDB which is running your program。
    and stepping into the operating system would mean trying to like stop the。 operating
    system and it just wouldn't work it turns out it would be impossible。 to if you
    want to debug a kernel you actually generally have to do it from。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在运行 GDB，或者我猜它在运行 GDB，而 GDB 又运行你的程序，进入操作系统意味着试图停止操作系统，而这根本行不通。事实证明，这是不可能的。如果你想调试一个内核，实际上你通常需要从。
- en: another computer that's talking to the other computer basically through like
    a。 connection of some sort it's tricky to debug a kernel because it's got to be。
    running and you can't really debug it that easily or put it in some other。 virtual
    machine or something like that so anyway if we let's just actually do S I。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一台计算机基本上通过某种连接与另一台计算机通信，调试内核非常棘手，因为它必须一直运行，而你不能轻易地调试它或将其放入其他虚拟机之类的东西。所以，如果我们就这样做
    S I。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_77.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_77.png)'
- en: see what happens it actually jumps it actually let's see I believe it jumped。
    back oh yeah jump back to our thing if we finish let's do p。rax yeah we had a。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看看会发生什么，它实际上跳转了，实际上我们看看，我相信它跳回去了。哦，是的，跳回到我们的东西，如果我们完成了，就做 p。rax 是的，我们有一个。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_79.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_79.png)'
- en: positive return value which is going to mean there was a success in that case。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正数返回值意味着成功，在这种情况下。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_81.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_81.png)'
- en: okay so that's how that's how system calls work it's kind of like calling a。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是系统调用的工作方式，它有点像调用一个。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_83.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_83.png)'
- en: function it's just you don't say call you say syscall which stops your process。
    and turns over to the kernel okay well questions you have about that system。 calls
    okay relatively straightforward I mean that shouldn't look too new to you。 just
    know that most of the functions we're going to use our system calls because。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你不说“调用”，而是说“系统调用”，这会停止你的进程并将控制权交给内核。好了，你对系统调用有问题吗？相对直接的，我想这对你来说应该不算新鲜。只需要知道我们将使用的大多数函数都是系统调用，
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_85.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_85.png)'
- en: of the type of class that this is okay here's the summary summary is we use。
    system calls because we don't want the user to have access to sensitive parts。
    great we can't do that using our regular function call why because we own that。
    memory we're allowed to touch on that memory so our code is accessing things。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程的类型是这样的。好了，简而言之，我们使用系统调用，因为我们不希望用户访问敏感部分。很好，我们不能用普通的函数调用来做这个，为什么？因为我们拥有那块内存，我们可以操作那块内存，因此我们的代码会访问本不该访问的内容。
- en: that it shouldn't be that would be bad because we could be malicious okay and。
    then the way this happens is through an interrupt called syscall and that stops。
    your program transfers over to the operating system and does that and then。 once
    the kernel is running it's in control does the opening closing reading。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是不好的，因为它可能是恶意的。然后，这一切通过一个叫做“系统调用”的中断来完成，这个中断会停止你的程序，转交给操作系统来处理。然后，一旦内核在运行，它就控制了这个过程，进行打开、关闭、读取等功能。
- en: from a disk whatever and then afterwards it returns back to your program okay
    all。 right what questions you have about those right now system calls anything
    else。 okay again this is this is in the this is talked about in the in the book
    in。 fact I think it's talked about in the bright you know how how how her hand
    book。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 比如从磁盘中读取文件等等。之后它会返回到你的程序中。好了，你现在有关于这些的任何问题吗？关于系统调用的，其他问题呢？好了，关于这个内容，书中也有讲解。实际上，我想它在《Bright
    Hand Book》里有提到过。
- en: as well okay let us move on to a fun topic called multi-processing okay so far
    we。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续讨论一个有趣的话题——多任务处理。到目前为止，我们……
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_87.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_87.png)'
- en: have been talking about programs that ever since 106 a 106 B 107 generally your。
    programs are running a single process okay a process that is going along and。
    might be doing lots of things but it's one process at a time okay it used to be。
    that one process was all computers could actually run anybody know what。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论的程序，自106A、106B、107开始，通常你的程序是运行单一进程的。一个进程在执行，可能在做很多事情，但它始终是一次一个进程。以前计算机只能运行一个进程，大家知道是什么原因吗？
- en: computer that one is on the board says it on there you kind of ABC it's an IBM。
    personal computer from about 1981 this was actually the computer I took to。 college
    it did it did not have a hard drive in it like I said and I said the。 other day
    it had a maximum of 640 kilobytes of memory which is not that much it， ran at
    4。0 4。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机就在屏幕上显示出来，它是大约1981年的一款IBM个人计算机，这其实是我带到大学的计算机。它没有硬盘，正如我之前提到的，它最大只有640KB的内存，这其实不算多。它的运行速度是4.0
    4。
- en: 77 megahertz your computers these days run at giga hertz so。 it was relatively
    slow but it actually had one process available at a time you could。 run one thing
    on to the time and that was all you got now along the way。 somebody some clever
    people did write a program or some various programs that。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 77 兆赫兹，你现在的计算机运行在千兆赫，因此它当时相对较慢，但实际上一次只能运行一个进程。你只能在同一时间做一件事，这就是你得到的所有功能。现在，随着时间的推移，一些聪明的人编写了程序或一些不同的程序，
- en: allowed you to kind of do multi processing but it was very rudimentary。 and
    it crashed a lot and it was didn't it didn't work particularly well and。 your
    computer the computer was slow enough that doing multiple things at once。 didn't
    really make sense anyway okay well these days we have really fast。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让你可以进行多任务处理，但它是非常初步的，并且经常崩溃，效果也不是很好。而且当时的计算机速度足够慢，以至于同时做多件事没有太大意义。好了，现在我们有了非常快速的计算机。
- en: computers okay we have computers that are giga hertz and that are running really。
    at very high frequencies okay and so we want to be able to run multiple programs。
    at the same time okay this is called multi processing all right and you will。
    tell your computer to do things concurrently in other words you're gonna。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: write a program and it's gonna be doing two different things potentially。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_89.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: exactly the same time that's kind of interesting okay I think that's that's。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_91.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: very interesting what we can do to show you a little bit about the process on。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_93.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: the computer in fact I will pull this up here let's see processing okay we are。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_95.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: gonna open up I think we're going to open up get PIDX。c so when your program
    is。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_97.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: running as I said before we kind of talked about this a couple times it has
    a。 process ID associated with it it is a process and it has a process。 identification
    identifier associated with it okay and we can actually get the。 identifier if
    you want by doing the following PIDT PID equals get PID okay。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: PID underscore T is just an integer okay you're all why don't we just call。
    it integers well they wanted to make it its own type it's just typed after to
    an。 integer okay you can do that and then you can say print F my process ID percent。
    D it's just an integer PID and return zero and that should do it except for I
    need a。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_99.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: semicolon after that there we go okay make get get PIDX okay get PIDX。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_101.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_102.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: process ID was 15，787 great process ID 15 788 process ID 15 789 now if I wait
    a。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_104.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_105.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: little bit right if we wait a little bit it's probably not gonna be 90 but it
    is。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_107.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: in that case okay so sometimes there are lots of other processes being。 started
    and stopped on like myth 55 right now that will probably start going。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_109.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: up in in order let's see if it goes up there we go we got a few more that kind。
    of started up in there right but but but that's what that's what episode。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_111.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: you're just given a number when your program's running and that's your。 process
    ID okay all right the process ID allows the operating system to keep。 track of
    you so that know it can use your process control blocks and it can do。 all that
    it can use your process ID number to say you get to run for a chunk。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: of time and then some other program gets to run for a chunk of time and this
    is。 why I can move my this is why I can have the program my program running and
    I can。 also do things like right on the board while the program is the other program。
    is running in the background the operating system is fast enough that it。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: allows your computer to seem like multiple programs are running at once。 most
    of the time there there's only one thing running at a time except for the。 fact
    that your computers these days all have multiple processors in them and in。 fact
    the myth machines all have four or eight different cores in them which are。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: individual processors which means they actually do run more than one program。
    at a time okay you can actually see this if you go to I don't think they have。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_113.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: this I think I installed this but we can we can do it but if you type H top
    okay。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_115.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_116.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: what H top does is it gives you a list of all the different programs that are。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_118.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: running on the system from all the other users to and you think wait a minute
    I。 can know what other users are running you can as it turns out that's not hidden。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_120.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: from from you and it also in fact this myth machine has eight different。 processors
    here and you can see them all running nobody's really doing anything。 right now
    like this myth happens to be very not busy right later in the quarter。 will be
    in class and we'll look at this and it'll be like going crazy because。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: some 107 assignments going you know they're doing some crazy things or whatever。
    okay but that's what's going on here you can actually look at this and it tells。
    you what percentage of each processor is being used most of the time it's pretty。
    idle but right now not much is really going on okay so that's it that's what。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_122.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: processes are okay and like I said your computers these days have multiple。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_124.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: processors which means they can run multiple programs at the same time。 literally
    it's not just time shifting or time splitting between the each process。 it's literally
    two are running at the same time okay we'll see how this becomes。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_126.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: important very soon okay so we have a new system call okay the new system call。
    is called fork and it's obviously it's I mean kind of like a fork you eat from。
    but it really is like a fork in the road okay this when we say fork what fork
    does。 is it says the fork is a system call that allows you to create a new process。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: from your program so that now your program is going to literally go down to。
    different code paths the exact same time okay that's what fork does did you have。
    a question okay so this is what fork actually does okay we're gonna see why。 that
    we might want to do that you might be able to start thinking about why you。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的程序中出来，现在你的程序会同时执行两条不同的代码路径，准确地说，是在相同的时刻。这就是 fork 的作用，你有问题吗？好，这就是 fork 实际上做的事情。我们接下来会看到为什么我们要这么做，你也许能开始思考一下为什么会这样。
- en: might want to do that but it's but for for the types of programs we're running。
    in this class multiple processes become very important here's what fork does and。
    this is a little subtle and people always tend to forget this so I'm gonna。 explicitly
    say what it does fork creates one more new process okay you've already。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想这么做，但对于我们在这门课上运行的程序，多个进程非常重要。接下来是 fork 的作用，这是一个稍微有点微妙的地方，人们总是容易忽略，所以我要明确说一下它的作用：fork
    会创建一个新的进程。你已经。
- en: got a process fork creates one more process that's a lot of people for some。
    reason last quarter thought that it created to it does not fork creates one。 and
    now there are two if each one of those forked right now there would be。 four right
    because each one of those creates one more and then there's a。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 进程 fork 创建了一个新进程，这是很多人不理解的原因。上一季度有些人认为它创建了两个进程，但其实它只创建了一个。现在有两个进程，如果每一个 fork
    都创建一个新的进程，现在就会有四个进程，因为每个进程都会创建一个新的进程，然后就会有更多的进程。
- en: total of four etc but your process if you fork it creates one more process and。
    that is called the child process because the parent is the one creating it okay。
    and the fork call by the way the child and parent and this is the most。 interesting
    part about it they both start executing on the next line after。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有四个进程等等，但如果你调用 fork，它会创建一个新的进程，这个新进程叫做子进程，因为是父进程创建了它。顺便说一下，fork 调用的有趣之处在于，父进程和子进程都会从下一行代码开始执行。
- en: fork it's not like you fork and the one the the child goes off somewhere else
    it。 does this in the probe probe the parent goes off no no they both go to the
    next。 instruction and now you've got two programs two processes running the next。
    line in your code which is kind of interesting you'll see how it works in。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: fork 并不像你想象的那样，子进程会去别的地方执行。它是在父进程中进行的，父子进程都会执行下一条指令，这样你就会有两个程序、两个进程同时在执行代码的下一行。这是一个有趣的现象，你将看到它是如何工作的。
- en: a minute okay fork returns a PID T or an integer but it's only kind of a PID。
    okay here's how it goes the parent when there when you call fork the parents。
    return value is the PID of the newly created child okay so you create a child。
    it's a new process it gets a process ID the parent gets that written in return。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等一下，fork 返回的是一个 PID_T 类型或一个整数，但它本质上是一个 PID。好吧，接下来是这样的：当你调用 fork 时，父进程返回的值是新创建的子进程的
    PID。所以你创建了一个子进程，它是一个新的进程，它会得到一个进程 ID，而父进程会得到这个 ID。
- en: okay so the parent actually can keep track of all its children that it creates。
    you can fork multiple times by the way so you can fork and you get back the the。
    ID of your child that you just forked the child gets back zero right the child。
    gets back zero if the child got back its own PID it wouldn't make much sense because。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，父进程实际上可以跟踪它创建的所有子进程。你可以多次调用 fork，因此你可以调用 fork 并获取你刚刚创建的子进程的 ID，而子进程会返回零。如果子进程返回了它自己的
    PID，那就没有什么意义了，因为。
- en: then it wouldn't like you wouldn't be able to differentiate between the child。
    and the parent if the parent got back the child's PID and the child got back the。
    parent's PID how do we know who's who we still can't make that decision right
    so。 the way it works the parent gets back the child PID and the child gets back
    zero。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你就无法区分子进程和父进程了。如果父进程返回了子进程的 PID，子进程返回了父进程的 PID，我们怎么知道谁是谁呢？我们仍然无法做出这个判断。那么它是怎么工作的呢？父进程会返回子进程的
    PID，而子进程会返回零。
- en: which means you're the child PID okay you are the child now look if the child。
    wants to get its own PID great it can it can call get PID but the return from。
    fork is zero if it's the child process that makes sense this confused people for。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你就是子进程的 PID。如果子进程想要获取它自己的 PID，那很好，它可以调用 get PID，但从 fork 返回的是零，如果是子进程的话，这就能理解了。这一点曾经让很多人困惑。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_128.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_128.png)'
- en: like for a while in other times I've taught this not not exactly sure why so。
    I'm being very specific oh good question if you're in the child。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我以前教这门课时一样，我并不完全确定为什么会这样，所以我会非常具体地讲解。哦，好问题，如果你在子进程中。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_130.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: process you can do get P PID to get your parents process if you want yeah and。
    this is a good this is good if you want to be let's say sending signals back and。
    forth between the parent and the child we'll talk about that later in the course。
    okay but yes you can if you want to you don't get it for this by default in fact。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: it's most often that the child could care less what its parents PID is it turns。
    out but you can get it if you want to okay now here's the other interesting part。
    about this all the memory between the parent and the child is identical I can't。
    draw the straight line at the bottom of this tablet all the memory is identical。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: but it is not shared okay so I create an integer int a and then I fork right
    on。 the next line the parent has an integer int a the child has an integer。 int
    a the parent let's say the pointer to the parent's version of a is 0 x 1 2 3。
    4 the child's version is 0 x 1 2 3 4 the pointer to that if the child changes。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: a the parents does not change how does that work any ideas yeah exactly the。
    answer was it doesn't it's not really the same exact memory they are now they。
    are now separate memory but they think they're the same part of memory now what。
    it does is you think wait a minute if I have a huge amount of code and I fork。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: isn't this gonna be really slow because it's got to somehow has to copy all
    the。 data from like the parent to the child it does this thing called copy on
    right in。 other words the operating system is clever enough not to make any copies。
    until either the parent or the child changes a value so it's kind of shared in。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: the sense that the operating system is keeping track of it all but the instant。
    you change a value in one in the child of the parent it is not reflected in the。
    opposite the child be your parent if you're the child not reflected you make it。
    the operating system makes a copy of it is okay great now you have your value
    and。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: you have your value okay it's a very interesting interesting concept as it。
    turns out it's right they did this for lots of reasons they did it so that they。
    can make it so that programs can go to the next line and not worry about any of。
    the data and they also did it in the way they did so that it's fast so that's。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: kind of me okay what questions you have on that how fork works yeah。 good question
    so we're gonna see actually we're not quite gonna see exactly that。 but the question
    was what happens when the parent process is terminated the。 child process keeps
    going yeah process child process keeps going now it turns。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: out that you might end up going back to the terminal because your parent is。
    what's running in the terminal and the child process might end it sometime later。
    after you type some other command or whatever so it's a little bit but of。 course
    we have a way of dealing with that which we'll talk about like how to。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: make sure that your parent doesn't end before your child does and so forth but。
    that's it the other interesting thing about it although not particularly。 relevant
    is that if the child or if the parent ends the child's parent now becomes。 root
    actually which is like the main underlying process doesn't have a parent。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: anymore parent died unfortunately sad but that's that's the way that goes good，
    question yeah。 Oh sure yeah this is the question is look if you wanted to pass
    along the。 PID to the child you could call get PID before you fork save it in
    a value and。 then it's available later sure or the child can just call get PPID
    which is。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: get parent PID so either one but yeah there's there's ways of doing that there。
    is there are ways of sharing data by the way but we're not going to cover that。
    really in here you'll see one example in a lab about sharing data but most of
    it。 is not most of it doesn't need to be shared as it turns out I asked it we
    asked。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: a pretty good in my humble opinion question on the final last quarter where
    a lot。 of people thought oh no we have to share memory but you actually didn't
    have to。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_132.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: as turned out but so you won't really be responsible for doing much of that
    okay。 all right the reason the parent the child get these two different term values
    is。 simply to differentiate them okay the first thing you will often do in a。
    program is if PID equals equals zero do this because I'm the child oh else do。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: this and that just says okay now I've got two of the process going in different。
    directions so that's generally what you do sometimes we want them both to do。
    exactly the same thing for various reasons but most of the time we do want。 to
    make a decision say look if I'm the child I'm gonna go down this path if I'm。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: the parent I'm gonna be on this path they start at the exact same point though。
    right so that's the difference there all right so let's look at a program okay。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_134.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: we're gonna we're gonna write another program called basic fork oops oh no I've。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_136.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: done it again hang on there we go cursor there we go okay basic fork dot no
    not。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_138.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: not the binary how about dot C there we go okay so what we're gonna do in here。
    okay is we are going to actually just print out greetings from a process and。
    then the per parent of that process okay so that's what it's gonna look like。
    there okay and then we're going to call fork okay and we do a little bit of error。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: checking if the PID is negative one it means the fork failed why would a fork。
    fail maybe the operating system ran on memory or some other thing happened you。
    will almost never see that actually that's not true you will see that if you try。
    to do thousands of processes your program is limited at least on our system。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: to about a thousand maybe a thousand twenty four different process so if you。
    tried to do forking such that it just kept creating many many more processes。
    you get limited about a thousand twenty four there's a thing called a fork bomb。
    which would which is where you just basically try to just do as many if you。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: do kind of recursively call for or you call it a loop or just everybody forks。
    and it just uses up all your processes this is why they had to limit it because。
    you could take down a system by doing the fork bomb which is very easy to do as。
    it turns out but anyway you were gonna check it there and then we're going to。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: print out buy buy from process your the process that we are going to get from。
    calling get PID and then we're going to also print out the parent process okay。
    everybody see how that's gonna happen remember by the time the program gets to。
    this line here there are now two processes going the original parent and。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: the child and that's the difference okay now we haven't done any checking to
    see。 who's the parent the child we don't really care for for this for this one。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_140.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: right now okay make basic fork it's already done yep okay basic fork and。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_142.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: there we go all right greetings from process 26385 with parent 2892 that's the。
    shell as it turns out okay and then it says buy buy from process 26385 with。 parent
    2892 because it ended and then it says buy buy from process 26386 which。 has parent
    a parent of 26385 and that is the parent that created okay so we can。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_144.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: run this a number of times again you probably will not see this with this。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_146.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: tiny little program but it turns out that the ordering of those two final lines。
    completely arbitrary okay why because who knows who gets to go next a parent of。
    a child it is completely arbitrary and non deterministic this is the problem。
    this is one of the harder parts about this class is that you're not dealing。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: with non-determinism okay debugging some of these things is very tricky if you。
    don't if you don't have a real clear idea of what you're expecting because you。
    can run a program two or three times in a row and it can come out absolutely。
    different each time but still be perfectly correct okay so that's a little bit
    a。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_148.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: little bit tricky to deal with sometimes question good question that was a very。
    good question why didn't the print-off statements like bang into each other and。
    print out like that so print F actually has some buffering in it and the way the。
    print-off function actually works it's going to generally keep like one call at。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: a time is going to get through and it will print all the way to a new line now。
    you are printing multiple things at once and some other person's printing multiple。
    things at once they might get interlaced but one line at a time not gonna get。
    interlaced good question though yeah you will see some interlacing but not not。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: one line at a time generally yeah when we get to C++ using C out。 Jerry Kane
    actually created a library that makes it so it doesn't do that and。 C out either
    which is nice yeah yeah so this is a good question the question was。 wait a minute
    when the parent process that when when you do four like one's。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: going and the other's going maybe maybe not at the same time okay two。 different
    processes now the operating system treats it just like any other。 two different
    processes if there's only one processor available the child gets。 to run for a
    little time the parent gets to run for a little time the child gets。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: run for a little time the parent gets run for a little time and it's just shifted。
    back and forth if there's two processors it actually could be that both are。 running
    on their own processor at exactly the same time literally the same time。 yeah
    but that's the that's a different there so the operating system is taking。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: care of that and saying great now even other process I better time slice it
    so。 it gets a little bit of time to keep running yeah we're gonna see lots of。
    those sorts of examples as we go along okay all right so that I just showed you。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_150.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: the output of this the as I said the original process has its parent being。
    the shell and then this is non deterministic so we have to be a little。 careful
    of that when we're writing these programs because you can't。 necessarily predict
    the order question yeah anybody else I'm sure you have lots。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_152.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: of questions on the stuff as we go a little bit farther okay fork is called。
    twice are called once fork returns twice right it returns to your program twice。
    in two separate processes okay as I said all segments of data are。 faithfully
    replicated all right the heap is replicated pointers are。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: replicated file descriptors are replicated which is interesting it means that
    as。 it turns out if you have a fork after you've opened a file and they both try
    to。 read from the file the first one to read gets part of the file the next one's。
    cursor is actually moved over and gets more of the other the rest of it so it's。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: actually duplicated at that level as it turns out okay the we will talk about。
    how to deal with open file descriptors as we go along as well okay what else。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_154.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: any other question on that all right now like I mentioned debugging this is
    a。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_156.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: bit tricky you might want to say you might be saying yourself hey how do I。
    actually go and debug this stuff well it's a little tricky you can do it in。 gdb
    I've given you the commands here you can go look at the actual you can go look。
    at the actual code to do to kind of the gdb trace if you want to I'm not going
    to。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有点复杂，你可能会对自己说，嘿，我到底该如何调试这些东西呢？嗯，这有点复杂，你可以在gdb中做，我已经给你们提供了命令，你可以去查看实际的代码，去查看实际的gdb
    trace，如果你愿意，我不会去。
- en: go over that right now but you can say for instance set detach on fork to off。
    basically what it normally does is gdb if you have a fork it just lets that child。
    go and it continues with the parent and the child processes on its own if you。
    set detach on fork off what it does is it actually goes down the path of the。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们就可以讨论这个，比如你可以设置“detach on fork”为关闭。基本上，它通常的做法是，gdb如果你有一个fork，它会让那个子进程继续运行，而父进程则继续它自己的执行。如果你设置“detach
    on fork”关闭，它实际上会沿着。
- en: child gdb keeps track of the child process you can do these things you can。
    do this thing called info in theoryers which is the two different all the。 different
    processes it gives you a list you can switch between them if you want。 to that's
    that's down here and you can also say oh if I'm going to continue I'm。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程gdb会跟踪子进程，你可以做这些事情，你可以做一个叫做“info in theoryers”的操作，它列出所有不同的进程，你可以在它们之间切换。如果你想要的话，可以切换，那个操作就在下面，你还可以说哦，如果我要继续，我。
- en: gonna continue one of the processes and then start debugging the other one you。
    can do that I would say most people probably don't get to this level but if。 you
    want to and you're milk and you're debugging you and I really can't。 figure this
    out this is how you would do it okay it's not not that often that you。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 继续一个进程，然后开始调试另一个进程。你可以这么做，我认为大多数人可能不会达到这个层次，但如果你想这样做，而且你正在调试，确实无法解决问题，这就是你该如何操作。好的，这并不是那么常见，但如果你。
- en: do that but just know that it's there in case you go ah I have to go debug this。
    and gdb I have no idea how that go look at the trace and you'll see how to do
    it。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，但请记住它在那里的存在，以防你想，哦，我需要去调试这个问题。在gdb中，我不知道怎么做，看看trace，你就能看到如何操作了。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_158.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_158.png)'
- en: okay all right like I said the only real difference is the process ID and the。
    return value from fork okay you get a new product you get a different process。
    ID if you're the child from the parent and either return value from fork is is。
    different okay parent gets the product PID child gets zero not its PID but that's。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题，就像我说的，唯一真正的区别就是进程ID和从fork返回的值。好的，如果你是子进程，你会得到一个新的进程ID，而父进程会得到不同的返回值。如果是子进程返回的是零，不是它自己的PID，但。
- en: how we differentiate it from the parent okay and that's how we make them go
    in。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何区分它与父进程的不同，好的，看看我们是如何让它们运行的。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_160.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_160.png)'
- en: different directions if we want to okay let's see another difference oh let's。
    actually this might be a duplicate so I hold on no not really it's kind of got。
    the it's replicating much information but there's no like I said there's no。 default
    sharing okay you can wait in the parent we're gonna get to that in a few。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要往不同方向走，好的，让我们看看另一个区别，哦，等等。实际上，这可能是重复的，所以我先暂停，不，实际上并不是，它有点像。它复制了很多信息，但正如我所说，它没有像默认共享那样的机制。好的，你可以在父进程中等待，我们稍后会讨论到这个。
- en: minutes where you can say hey I want to wait for my children in fact we're gonna。
    talk about that for much like for much of a multi processing material we're gonna。
    talk about hey how does the parent wait for all of its children appropriately。
    how does that work we're gonna get to that you can't wait for your parent as it。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设定一个时间，比如说我想等待我的子进程，实际上我们将会谈到这一点，关于多进程的内容，我们会讨论如何让父进程适当地等待所有子进程。它是如何工作的，我们稍后会讨论。你不能等待你的父进程，它是。
- en: turns out not really allowed the way it goes why I don't know they built it
    that。 way you're not really allowed to wait for your parent turns out when a child。
    process ends the parent can get notified or the parent can wait for that but it。
    doesn't go the other direction I'm not exactly sure why but that's the way they。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现并不是真的允许的，为什么我不知道，他们就是这样设计的。你并不是真的能等待你的父进程，实际上当子进程结束时，父进程可以被通知，或者父进程可以等待它，但并不会向父进程反向通知。为什么不行，我不太确定，但它就是这样。
- en: that's where they built it all right let's look at another program okay we're。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他们构建它的地方，好的，让我们看看另一个程序，好吧。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_162.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_163.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: gonna look at a little program of a tree of forks okay a tree of forks I think
    let's。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_165.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: see is this the one is it hang on oops there we go。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_167.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: there we go let's let's look at the see if we're gonna do which which one we're。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_169.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: gonna do we want to look at well let's just look at it here and then I'll go。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_171.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: run it as we go here's what this is gonna do okay this is going to basically
    do a。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_173.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: for loop around a bunch of fork calls okay so what we're gonna do is we are。
    going to basically have a string called K-trail okay and we are going to find。
    how long it is we're going to loop through all the letters in that string。 or
    all the characters in that string we're gonna print them out at one letter。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: at a time but in the meantime we're going to fork okay and then in this case
    it's。 an assert that just says look at the PID is assert the PID is greater than
    equal。 to zero which would make it so that if anything failed it would crash the
    program。 or stop the program and then it will keep going down okay what do you
    think is。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: gonna happen here if the string is ABCD oops if the string is ABCD what is going。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_175.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: to happen in here the first thing is gonna happen is what it's gonna print out。
    okay and then we're gonna end up with here's the parent we're gonna end up with。
    a child process okay and then the for loop is going to come back here remember。
    it's going to the same it's got the same value of I it's got the same value for。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: the string and same value all that okay but now there are two things going through。
    here I is going to be incremented to one okay and then it is going to print。 what
    from the child be and then what's gonna get printed from the parent be do。 we
    know what order that's gonna happen we have no idea but it doesn't matter because。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: they're both big right but then what's gonna happen with the parent the parent。
    is going to create a child and the child is going to create a child and then。
    everybody is gonna go back up here and that they're all gonna be on see now how。
    many versions of see are we gonna get four one two three four not necessarily。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: in that order and then all four are gonna each create another child and。 another
    child another child another child they get all and they all create a child。 how
    many different D's are we gonna have eight different D's let's try it okay。 let's
    try it I have to figure out which program this is because I think I forgot。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: which one is we are gonna look for trail length hang on trail like start a see。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_177.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: fork puzzle that's the one okay let's see fork oh no hang on in for might might
    not。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_179.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: be actually written oh it's not written hold on copy for I have I have written。
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_181.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: original let's see to fork puzzle that see okay yes make for puzzle okay okay
    okay。
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_183.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_184.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: ready a B C D A B C B D C D C D D oh not the order we necessarily would have。
    hoped for right it's not one a two B's three four C's eight D's but there are。
    that many right one a I see one a one two let's see two B's one two three four。
    C's and then eight D's I assume okay all right let's try running it again oh。
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: what happened there why do I have my come my line here and a D way over here
    any。 ideas what's up the parent finished first good answer yeah the parent finished。
    first and one of the children was still doing its printing after the pair finished。
    the shell got it back and did that right so we can we can do it a few more time。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: there you go got the same sort of thing again right that time it happened to。
    work okay but remember non deterministic and that's the way it goes so let's spend。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_186.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: a minute just making sure everybody understands what's happening in this。 program
    what questions do you have about it you get why there are one a two B's， forces
    etc yeah。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_188.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_189.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: yes so the question was okay I get that it's I get that why they're all the。
    letters there why they're all those letters why is it out of order is it。 because
    you have these multiple processes given time from the operating。 system it's exactly
    that and it turns out that the parent in there must have。
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: gotten the like gotten the signal to keep going through all of its D's before。
    one of the children did and in some cases the child and children all in before。
    the parents so it's it's completely non deterministic in that sense you can't。
    control it okay in that sense there are ways to control what happens we will get。
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: to that many times you don't want to necessarily hinder them from going in a。
    particular order but sometimes you need them to go in a particular order so we'll。
    talk about that too questions so if you have a parent and then you own a child。
    then there is an additional form that ends up with grandchildren let's say yes。
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: so grandchildren not the children yes the child finishes and then basically。
    disappears but those grandchildren are done is there new parents the original。
    parents or is it the terminal will they return to this that's a good question
    I。 believe that anytime your parent the question was hey what happens when the。
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: children's children died they their parent now become the grandparent and。 so
    forth no I don't I think it just becomes all the way to root I think if。 your
    parent dies you're just kind of become an orphan right so yeah I think。 that's
    what that's what happens about it， root is not the same as shell root is like
    the kernel basically running it's。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: running there might be some other program but yeah it's it's not the shell。
    it's out this shell can end and the other program will continue as well unless。
    there's some other method to kill them yeah good yeah。
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_191.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: yeah so the question was hey explain again what happens with the D at the end。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_193.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: let's see if we can get it to work no no there we go okay so why did that D。
    show up after my terminal line showed up well remember there's the parent。 process
    which when it ends the terminal says oh you've ended here's a here's a。 prompt
    again type something else right if the parent process ends before all of。
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: its children do then it will do that and the child can still be running and。
    print out to there we're gonna see we're gonna see an example of that I guess
    on。 Wednesday where we're gonna get into some of these crazy ones where you go
    oh。 wow it really does do that like it just it will print out you can type LS
    and it。
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: will still be putting stuff out for your program and whatever right you can
    you。 can do that but let me let me show you try something that's for I in let's
    see。 let's do this sequence one through 100 do echo I done no echo dollars on
    I done。 there we go okay that's gonna print out this is bash it's a different
    program。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: I'm just gonna print out a hundred numbers in a row but if we do this and we。
    say sleep for one second in between it's gonna print one two three etc right if
    we。 do this and we can run this what we call in the background I don't think I've
    ever。 done this before it is now running and I can type LS and my program is running。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_195.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: along in the background and doing its thing right I mean I can even it's even。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_197.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: crazier than that I can do like them and then oh boy you know so it'll do this。
    until it gets up to 100 and it's just two processes running at the same time and。
    they're both trying to print out the terminal and they don't care that you。 know
    one's going and one's not so that's what yeah so there you go that'll just。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_199.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: keep going right until you do that I think I can still end of it or whatever。
    right you can actually you can't you can put in the foreground and then kill it。
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_201.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: but you will learn all about this when you do the Stanford shell assignment
    which。 is coming up in a few weeks where you you have to build this and it you
    end up。 with things like this but yeah but does that answer your question about
    how it's。 happening yeah yeah， like in your parents it's like you know what happens。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: the question was what what's the significance of when the parent process。 dies
    before the child does nothing really I mean there's no real significance。 except
    for the fact that you can end up back in the shell and you might not want。 to
    be like we don't like it that it printed out that D after our after our。
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: prompt we want it to be like look finish everything then print out the thing
    and。 we'll we'll see examples that straight straight away on Wednesday yeah yes
    why。 are there always one child we do have multiple children we didn't know oh。
    lies are always one they're both there are that's a good question they're all。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: going roughly the same time right it's such a fast program they're roughly going。
    at the same time it could very easily come out there's two I mean you just don't。
    know but they're they're they're pretty much doing it all at the same time before。
    the and then the parent will we'll just end almost at the same time and sometimes。
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: one will be out but there's no significance to just having one yeah good。 question
    all right what else yeah good question if we look at the program the。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_203.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: question was can you choose to just do one fork each time well sure how about。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_205.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_206.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: this what if we wanted to stop the program at the end at the end of what if。
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_208.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: we wanted to stop the program so let's look at fork puzzle dot see okay okay
    so。
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_210.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: we have the fork there okay let's do let's see what would be interesting here
    if。 we did if we said this if PID equals zero now we know we're in the child right
    we。 could say oh I don't know print f by you know whatever and then we could also
    do。 exit zero or we can do return zero or whatever we want was to return zero
    return。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_212.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
- en: zero and that will actually say okay I'm done and not go through the fork right。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_214.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: for puzzle puzzle right and now it's gonna just do that parent only all the。
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_216.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: other children did there like guys but nobody ever got back in the for loop
    so。 you can just use to have you have to figure out the logic for that yeah good。
    question anybody else yes， ah that's a good question question was if we had one
    processor and you were。 forking the process are you necessarily going to are you
    ever gonna make the。
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: program faster because that probably not no I mean if you're trying to do a。
    certain amount of work and you have one processor to do it unless there's some。
    other thing going on like for instance you're waiting for network or you're。 waiting
    for a file be read or something like that that can take some time other。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行得更快，因为如果你试图完成一定量的工作，而只有一个处理器来做这件事，除非有其他事情发生，比如你在等待网络，或者你在等待文件被读取之类的事情，这些都会占用一些时间。
- en: than that no you're not gonna save time this is not necessarily a time saving。
    sort of thing it's kind of a logic thing where we want something to happen look。
    the shell is doing exactly this it's forking a process and running whatever。 you
    tell it to run and so so we'll use that met more than just this kind of。
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你不会节省时间，这不一定是一个节省时间的做法。这更像是一种逻辑问题，我们希望某些事情发生。看，shell 就在做这件事，它在分叉一个进程并运行你告诉它运行的内容。所以，我们将使用这种方法，不仅仅是为了这种情况。
- en: funny like oh do lots of things for multiple processes yeah good question。 all
    right I think we will see you guys on Wednesday。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣，哦，为了多个进程做很多事情，是的，问题提得好。好的，我想我们周三见。
- en: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_218.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b69340c585f582e2f65bbaf36c1a1e_218.png)'
