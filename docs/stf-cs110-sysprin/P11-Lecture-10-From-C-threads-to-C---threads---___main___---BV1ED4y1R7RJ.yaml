- en: P11：Lecture 10 From C threads to C++ threads - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P11：第10讲 从C线程到C++线程 - ___main___ - BV1ED4y1R7RJ
- en: Welcome。 All right。 Welcome to the 19 of you that are here。 No。 it's more than
    that for people watching this on， video。 There's more people than that here。 So
    assignment three， hopefully ended up okay。 There were lots of。 Piazza questions
    and lots of consternation about race conditions and this and that and that's the
    kind of thing。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎大家。好，欢迎来到现场的19位同学。不是的，观看视频的同学更多。现场的人比这多。所以第三次作业，希望大家都做得还不错。关于竞争条件的问题，Piazza上有很多提问和讨论，这类问题会经常遇到。
- en: you have to deal with when you're doing multi-processing， also multi-threading。
    which we're going to talk about， today and you will do more multi-processing for
    this week's assignment and then of course you'll practice it a。 little bit on
    the mid-term as well。 So big week this week。 I think I'm already behind but we
    will keep going， forward here today。 The mid-term is Thursday。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在做多进程时遇到这些问题，也包括多线程，这是我们今天要讨论的内容，你将在这周的作业中进行更多的多进程实践，然后在期中考试中也会做一些相关练习。所以这一周任务重。虽然我觉得自己有点落后了，但今天我们会继续往前走。期中考试定于星期四。
- en: It's 6 to 8 p。m。 Hewlett 200 which is across the hall。 It's not this， one。 Don't
    sit in here and think where's everybody？ It's across the hall。 If you are taking
    an alternate exam， hopefully you already emailed me。 If you haven't。 please do
    that today so I can set things up and same thing for， any accommodations that
    you have。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考试时间是晚上6点到8点，地点是Hewlett 200教室，就在大厅对面。不是这里，不要坐在这里想“大家在哪里？”考试在对面。如果你需要参加替代考试，希望你已经通过邮件联系我了。如果还没有，请今天发邮件给我，以便我可以做好相关安排，其他需要特殊安排的同学也是如此。
- en: Do that。 I plan on sending out emails about that this evening for people who。
    talk to me about those things already。 The exam is going to be on Blue Book。 Who
    has used Blue Book before？ Raise， your hands。 About half of you maybe。 To the
    other half。 what it is is you have your laptop and you load a program on it。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 做好准备。我计划今晚给已经和我联系过的同学发邮件。期中考试将使用Blue Book。谁用过Blue Book？请举手。大约一半同学用过。对另外一半同学来说，Blue
    Book是这样的：你将你的笔记本电脑加载一个程序。
- en: that you take the test on and it submits it to us and we grade it all kind of
    digitally。 The nice thing about Blue Book is， that you get to type your answers。
    Some people think that's nice anyway but it feels very much like taking a paper。
    exam in that we don't really， you can't compile code， you can't look things up。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用它来参加考试并提交给我们，然后我们会以数字方式批改。Blue Book的好处在于，你可以键入答案。一些人认为这很不错，但它和纸质考试很像，因为我们不能编译代码，也不能查找资料。
- en: You can't copy and paste within the， application and so forth but you should
    get it working on your computer before coming to the midterm。 What happens is，
    we will publish an encrypted exam sometime on either Wednesday night or Thursday
    morning that you can download and then。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在应用程序中复制粘贴等，但你应该在来参加期中考试之前先在电脑上把它弄好。考试内容是加密的，我们会在周三晚上或周四早上发布，你可以下载并开始考试。
- en: when you get to the exam we give you a password and then it starts the exam
    for you and it is timed on the computer。 If for some reason you don't have a laptop
    or your laptop battery is going to die after five minutes or something。 you should
    talk to me， sooner than later so we can find you another laptop to use or for
    your battery issues we will have some plugs but they are not going to be。 like
    for everybody。 Most people's laptops these days will last two hours although I
    know some people are。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进入考场时，我们会给你一个密码，然后考试会在电脑上开始，并且是限时的。如果因为某种原因你没有笔记本电脑，或者你的电池在五分钟后就没电了，你应该尽早联系我，这样我们可以为你提供另一台笔记本，或者如果是电池问题，我们会提供一些插座，但这些插座并不是每个人都能用到的。现在大多数同学的笔记本电池能用两个小时，虽然我知道有些同学的电脑电池可能更差。
- en: there will last like an hour and a half and you have to， get near a power plug。
    We will have that available for some extent。 You are allowed one back in front
    piece of paper for your own notes or whatever。 Please don't， bring any magnifying
    devices regular glasses are fine like I don't see people like you know like Microscope
    here。 I think I told this to people in 106D when I was doing a similar sort of
    thing。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考试会持续一个半小时，你需要靠近电源插座。我们会提供一些插座，但并不是每个人都有。你可以带一张纸，前后可以写上自己的笔记。请不要带放大镜之类的设备，普通眼镜就可以了，不要带显微镜这种设备。我记得我在106D课上也和同学们说过类似的话。
- en: I once heard and I mentioned， somebody else recently I once heard of a professor
    saying you can use anything you can bring into the exam for notes or to use for
    the exam and somebody came in carrying a graduate student。 Popped the next to
    him and that was that。 No， you are allowed one piece of paper back in front。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经听说过，也曾提到过，最近有人说过，一个教授曾经说过，你可以带任何东西进入考试，无论是笔记还是其他什么东西。结果有个人带进来了一个研究生，直接把他放在旁边就完事了。不是，你只能带一张纸进入考场。
- en: We will also， did that， did the joke just finally sick。 We will also give you
    a somewhat limited resource resources sheet。 It looks kind of like this where
    basically gives you all of the。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会，那个，刚才那个笑话终于说完了。我们还会给你一张稍微有限的资源表。它看起来大致是这样的，基本上给你提供所有的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_1.png)'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_2.png)'
- en: prototypes and things for functions that you'll need and then some some specific
    constants and things that you'll need。 We are not trying to make you memorize
    those sorts of things。 So in the middle of the exam you're like I forget how to
    do that。 It's probably not going to matter。 We're not going to try to compile
    your code necessarily。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数所需的原型之类的东西，然后是一些你会需要的特定常量之类的内容。我们并不是要让你记住这些东西。所以在考试过程中，如果你忘了怎么做，那大概也不重要。我们并不会真的去编译你的代码。
- en: But but either way it's not that we're not testing you on that。 Do the best
    you can with those sorts of things。 Let's see。 I think that's about it。 All the
    comments I have at the mid term。 Any questions at this point？
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不管怎样，我们并不是要测试你在这一方面的能力。尽力去做这些事情吧。我们来看看。我觉得差不多就这些了。这是我在期中时的所有评论。有问题吗？
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_4.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_4.png)'
- en: About the mid term comments。 It's two hour exam。 I'm going to try to make it
    so that you finish it that most people finish within an hour and a half or so。
    I mean I don't want this to be a test of your ability to like race through hard
    problems because they are sometimes difficult。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于期中评论。它是一个两个小时的考试。我会尽量让大多数人在一个半小时内完成。我不想让这次考试成为测试你们能否快速完成难题的能力，因为有时候这些题确实很难。
- en: Awesome。 Good question。 What's the format going to be？ Is it going to be like
    the practice ones？
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒的问题。格式会是什么样的？会像练习题那样吗？
- en: I would say it's going to be kind of most like the last practice one which is
    a couple of programming problems。 I'll try to walk you through the details of
    that pretty。 I don't want a wall of text if I can help it。 And then maybe a problem
    like the try to figure out what's going on with these signals like what's the
    output sort of thing。 And then something else is going to be a little bit more
    difficult。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说，它会和上次的练习比较相似，包含一些编程问题。我会尽量带你们走一遍这些细节。我不想给你们一堆文字，如果我能避免的话。然后可能会有一个问题，比如让你们弄明白这些信号的情况，像是输出是什么之类的。然后还有一些会稍微难一点的内容。
- en: And then some short answer questions which kind of cover the spectrum。 That's
    probably the way it'll be。 I'm still in the middle of finishing it。 Anybody else？
    Okay。 So we have another assignment。 This assignment， Stanford Shell。 I'm going
    to do a little demo of it to show you what it is。 Is kind of a neat assignment。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会有一些简答题，涵盖各个方面。大概就是这样的形式。我还在做最后的整理。还有别人吗？好吧。那么我们有另外一个作业。这个作业，斯坦福Shell。我会做一个小演示，向你们展示它是什么。这个作业还挺有意思的。
- en: It's basically building the shell that you use every day and have used since
    107。 And it's it needs to handle certain things。 You need to be able to do the
    basic things like quit it or exit it。 You will be putting processes in the background
    or in the foreground kind of like what we did in our simple shell。 So you can
    use that as a hey， how do we do it then and what do we need to do differently
    now。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是在构建你每天使用的外壳，从107开始你就一直在使用它。它需要处理一些特定的事情。你需要能够做一些基本操作，比如退出它或者结束它。你会把进程放在后台或前台，就像我们在简单的shell中做的那样。所以你可以用那个作为一个参考，看看我们是如何做到的，然后现在需要做些什么不同的事情。
- en: You also have to keep track of all the processes。 So you'll be able to have
    multiple processes。 You can throw in the background and then maybe a program process
    as well。 And your program has to handle all of those。 Okay。 So you need to be
    able to use FG to bring a background process into the foreground。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要跟踪所有的进程。所以你将能够有多个进程，你可以将它们抛到后台，然后也许还有一个程序进程。你的程序必须处理所有这些。好的。所以你需要能够使用 FG
    将一个后台进程调到前台。
- en: You need to be able to do BG， which restarts a stopped background process。 And
    you can tell it which one as well。 You also have to be able to kill a set of processes。
    And this is an interesting one。 We have this term， this command called slay。 which
    basically will send to a process group。 And that's a group of processes like for
    instance down here。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要能够执行 BG，重新启动一个停止的后台进程。你还可以指定是哪个进程。你还必须能够杀死一组进程。这是一个有趣的命令。我们有一个命令叫做 slay，它基本上会向一个进程组发送信号。进程组就是一组进程，比如下面这个。
- en: We have LS pipe through grep pipe through cut。 Well， they will all be in the
    same process group。 But if you kill the process group， they all die。 So that's
    the sort of thing you're going to have to think about when you're doing this。
    You also can halt a process that's currently running。 You're going to send a SIG
    stop to it or actually a SIG， actually， I think it is a SIG stop to it。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 LS 管道通过 grep 管道通过 cut。嗯，它们都会在同一个进程组中。但如果你杀掉进程组，它们都会死掉。所以这就是你在做这件事时需要考虑的事情。你还可以停止当前正在运行的进程。你需要发送一个
    SIG 停止信号给它，或者实际上，嗯，我想应该是一个 SIG 停止信号。
- en: You will be able to continue a process。 You'll also be able to tell what jobs
    are running with a command so you can see what the process IDs for all those jobs
    are。 And you're going to be responsible for setting up the pipelines。 I think
    this is one of the trickier parts of this assignment。 It's getting this to work
    where you have LS pipe through grep pipe through cut。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够继续一个进程。你还能够使用一个命令查看正在运行的作业，这样你就可以看到所有这些作业的进程 ID。你将负责设置管道。我认为这是这个任务中更难的部分。它就是让你能够实现
    LS 管道通过 grep 管道通过 cut。
- en: For any number of these。 And you'll also have to do things like sort input from
    a file as standard in error I get read from standard in。 And then maybe output
    to another file。 So those are things you're going to have to think about as well。
    So there's a lot of moving parts to this。 For that， the piping。 you have to think
    about what's happening here and you have to go， okay， well。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些任意数量的任务。你还需要做的事情包括对文件输入进行排序，作为标准输入错误，我从标准输入读取，然后可能输出到另一个文件。所以这些也是你需要考虑的事情。所以这件事有很多活动的部分。关于管道，你需要考虑这里发生了什么，并且你要说，好的。
- en: LS needs to have its standard out going to grep as its standard in。 It sounds
    a lot like pipeline。 right， which you've already done， but this is a more robust
    version。 And then same thing for us。 grep has to send its output to cut。 So guess
    what。 there's going to be like a pipe here and another pipe here。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: LS 需要将其标准输出通过 grep 作为标准输入。听起来很像管道吧，对吧？你已经做过了，但这是一个更强大的版本。然后对我们来说也是一样，grep 必须将其输出发送给
    cut。所以，猜猜看，这里会有一个管道，那里会有另一个管道。
- en: And they're not going to be the same pipe and you have to start them and stop
    them in different places。 And so it's a little bit trickier to get that going。
    You'll also have to be hand off terminal control to foreground process。 Sometimes
    when you type in process， well， your terminal isn't really grabbing the input
    anymore。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不会是相同的管道，你必须在不同的地方启动它们和停止它们。所以让这一切顺利进行是稍微有点复杂的。你还需要将终端控制交给前台进程。有时候，当你输入一个进程时，你的终端其实已经不再接收输入了。
- en: It's whatever program is running。 So there's a little bit of a hand off there。
    That's not actually one of the hardest things about the program。 You just have
    to end up thinking about it。 Question。 >> So it's going to rely on pipeline and
    sub-process from the last time。 >> It is a good question。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它是任何正在运行的程序。所以在这里有一些交接的过程。这其实不是这个程序最难的部分。你只需要考虑清楚。问题。>> 所以它会依赖于上次的管道和子进程。>>
    这是个好问题。
- en: It's not going to rely on pipeline sub-process。 You kind of recreate them in
    the form that we。 at least the pipeline one in the form that we will have for
    you。 Yeah。 What are their questions just so far on this？ All right。 This evening。
    I will do my best to put up a little video describing some of the details a little
    bit better。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会依赖于管道子进程。你需要以我们给你的形式重建它们，至少管道部分是我们会提供的形式。对了，到目前为止有什么问题吗？好的，今天晚上，我会尽力上传一个小视频，更详细地描述一些细节。
- en: There are a lot of moving parts to this， okay。 There's a ton of moving parts
    because you have to kind of move into the form。 You have to think about all the
    nuances to this shell。 There's a bunch of header files always read through those
    first。 If you've already downloaded the assignment， read through those。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务有很多复杂的部分，明白吗？有很多复杂的部分，因为你必须转变为这个形式。你需要考虑所有与这个 shell 相关的细节。总有一些头文件，首先一定要阅读这些文件。如果你已经下载了任务文件，先通读一下这些内容。
- en: You're only going to be putting modifying one program。 So that's at least like
    good。 It won't be like trying to figure out six different programs。 You can test
    the shell either by running programs。 I'll show you in a second。 Or through a
    driver program， which basically runs the shell using some input so you can see
    the output in a way that you can test a little better。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要修改一个程序。至少这点好，它不会像要处理六个不同的程序一样复杂。你可以通过运行程序来测试 shell，我一会儿会给你演示，或者通过一个驱动程序，基本上是通过一些输入运行
    shell，这样你可以看到输出并更好地进行测试。
- en: So it's a good way to test。 So get used to using the little driver。 You would
    definitely have to have a SIG child handler because all of your children are going
    to be starting。 continuing， stopping， all that kind of stuff。 And it's the SIG
    child handler that's going to be manipulating those and taking care of which programs
    are stopping when and so forth。 In some sense， it's a little like farm in that
    you have to get your SIG child handler pretty robust to get these。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的测试方法。所以，习惯使用这个小驱动程序。你肯定需要有一个 SIG 子进程处理程序，因为所有的子进程都会启动、继续、停止，等等。这些操作会由
    SIG 子进程处理程序来控制，处理哪些程序何时停止等问题。在某种程度上，它有点像农场管理，你必须使你的 SIG 子进程处理程序非常健壮，才能成功完成这些任务。
- en: You'll also have another handler or maybe two。 And by the way， you can make
    these into one handler。 If you want your shell， if I go to a shell， by the way。
    if I go over to a shell and I type control C， my shell doesn't die。 You're going
    to have your shell also make it so that it doesn't die when you do control C。
    Well。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要有另一个处理程序，或者可能是两个。顺便说一句，如果你愿意，也可以将这些处理程序合并成一个。比如说，我进入 shell，然后输入 Ctrl+C，这时我的
    shell 不会死掉。你也需要让你的 shell 在输入 Ctrl+C 时不会崩溃。
- en: that's actually where to do that you have to handle and you have to capture
    SIG in to which is the interrupt and SIG stop。 which is control Z。 And they should
    affect your processes that you have， but not your shell itself。 So there's a little
    bit of that going on as well。 As I said。 the piping between processes is a little
    bit tricky。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，要做到这一点，你必须处理并捕获 SIG INT（中断信号）和 SIG STOP（控制 Z 信号）。这些信号应该会影响你正在运行的进程，但不会影响
    shell 本身。所以在这方面也需要注意一些细节。如我所说，进程间的管道传输有点复杂。
- en: You'll have to take some time to get through that。 This assignment has lots
    of a whole list of milestones。 You should probably do this， then this。 then this，
    then this。 If you can follow those milestones。 you'll be able to do some testing
    and it will be a little more straightforward。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要花些时间来完成这个任务。这个任务有很多里程碑。你应该按照这个顺序做，接着做这个，再做这个。如果你能按照这些里程碑来做，你将能够进行一些测试，整个过程也会更加直接。
- en: Don't try to jump to the last part or like just go down some route。 Test as
    often as you can is the big thing。 Now， this is a detailed assignment。 We also
    have a midterm coming up this week。 It's due next Wednesday， which is a week and
    a half。 This should be about a week long assignment。 So I'm giving you a little
    bit of buffer room in there。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试跳到最后部分，也不要只走某一条路。尽可能多地进行测试是关键。现在，这是一个详细的任务。我们本周还有期中考试。任务的截止日期是下周三，也就是一周半后。这个任务大约需要一周时间。所以我给你留了一些缓冲时间。
- en: If you wait until Friday to start it， you can get it done。 but it's going to
    be a lot of work over the weekend and over the beginning of next week。 So I would
    at least start the assignment。 And by the way。 it's got all the signal handling
    stuff you will need to know for the exam。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等到周五才开始做，你是能完成的。但那样的话你得花很多时间在周末以及下周初。所以我建议你至少先开始做作业。顺便提一下，它包含了你需要了解的所有信号处理内容，这些对考试很有用。
- en: We will not ask specific questions， although the practice midterms did on Stanford
    Shell。 but we will， the material is ostensibly the same。 So you'll， starting to
    do the assignment。 at least you'll start， you'll continue to think about those。
    Okay。 All right。 And then we'll see how it goes as far as how people are doing
    after beginning of next week。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会问具体问题，虽然练习期中考试中有涉及Stanford Shell，但从本质上说，材料是一样的。所以你开始做作业后，至少会开始思考这些问题。好的。好的，然后我们看看下周初，大家的进展如何。
- en: All right。 What questions on the assignment at this point？ Anything else？ This
    is a fun one too。 It's definitely got a lot of parts。 So I said， okay。 All right。
    Then let's move on back to threads。 Now， remember， we have left multi processing
    world and we are now in multi threading world。 The biggest difference is that
    threads are all under one single process。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。到目前为止，有关作业的任何问题吗？还有其他问题吗？这个作业也很有趣，确实包含了很多部分。所以我说，好吧。好的，那我们继续讨论线程。记住，我们已经离开了多处理世界，现在进入了多线程世界。最大的区别是，线程都在一个单独的进程下运行。
- en: which means they share their memory。 They have a different stack space for each
    thread。 but they can relate to each other's stack frames。 You can pass references
    to global variables。 That works just fine。 And you can have threads interacting
    with， like， say。 one global data structure very easily。 That's one of the benefits
    of threads。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们共享内存。每个线程有一个独立的栈空间，但它们可以访问彼此的栈帧。你可以传递全局变量的引用，这完全没问题。而且你可以让线程轻松地与一个全局数据结构进行交互。这就是线程的一个优势。
- en: They're considered lightweight processes in the sense that they really are doing
    different things。 You can actually set the affinity on threads to run on different
    cores。 And they really do run in parallel， especially if you have different cores。
    So there are benefits using threading， but there's a lot of little things you
    have to think about。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 线程被认为是轻量级的进程，意味着它们实际上在做不同的事情。你可以设置线程的亲和性，使其在不同的核心上运行。它们确实能并行运行，尤其是当你有多个核心时。所以，使用线程是有好处的，但你需要考虑很多小细节。
- en: just like multi processing。 And there are many analogous things to multi processing
    that you'll have to look at。 On Wednesday， what we did was we looked at the C
    version of P threads。 Now。 threading doesn't come standard with Unix。 It's kind
    of a test。 It's kind of， well。 it's more or less added these days， but it's another
    library that we're going to use。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就像多处理一样。你需要注意，线程与多处理之间有很多相似之处。周三，我们看的就是P线程的C语言版本。现在，线程在Unix中不是标准配置的。这有点像测试，它在如今差不多已经添加进来了，但它是我们将要使用的另一个库。
- en: It's another library that you have to run。 So that's why we had P threads。 And
    for C， of course。 you have to do all these things with void star and pointers
    to send various blocks of data。 And it's kind of annoying。 It turns out in C++11，
    which is the version that we are using。 In C++11。 we have actual support for threading
    built into the language。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个你必须运行的库。所以我们才有了P线程。对于C语言来说，当然，你必须通过void指针和指向各种数据块的指针来处理这些事情。这其实有点麻烦。事实证明，在我们使用的C++11版本中，C++11内置了对线程的实际支持。
- en: And it works a little bit better and is actually much cleaner once you get to
    understand it than P threads are。 So we're going to quickly transition into that
    and then never speak of P threads again。 Although if you take a networks class
    or maybe an operating systems class。 you're going to have to probably implement
    those and think about those in the future。 Yeah。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它运作得稍微好一点，实际上，一旦你理解了它，它比P线程要更简洁。所以我们将迅速过渡到这部分，然后再也不提P线程了。虽然如果你上了网络课程或者操作系统课程，未来可能还需要实现和考虑它们。是的。
- en: '>> Is threading in the P threads on the term？ >> No， no。 There''s no threading
    in the mid term。 No。 good question。 Yeah。 Unless you want me to put it on there。
    [LAUGHTER]， So anyway。 let''s take a look at -- we''ll go back and look at the
    recharge or the introverts program that we had before。'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 线程在期中考试里吗？ >> 不，不是的。期中考试没有线程。没有。好问题。对。除非你希望我放上去。[笑声]，好吧。无论如何，我们回到之前的内容，再看一下充电或内向程序。'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_6.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_6.png)'
- en: Okay。 So let's actually log on to myth here。 Oh， I forgot to show you。 I'm going
    to show you Stanford shell。 I forgot about that。 [INAUDIBLE]， There we go。 So
    Stanford shell looks like this。 You can do things like LS。 You can do things like
    sleep in the background。 And it will -- oops。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们实际上登录到 myth 上吧。哦，我忘了给你们看。我打算给你们展示斯坦福 shell。我忘记了。[听不清]，好了。斯坦福 shell 看起来是这样的。你可以做类似
    `LS` 的操作。你也可以在后台做类似 `sleep` 的操作。然后它会——哎呀。
- en: Needs a sleep something like 10 in the background。 And then it goes in the background
    and you can type jobs and it will tell you that there's a sleep running。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个像 10 这样的后台睡眠。然后它就进入后台，你可以输入 `jobs`，它会告诉你有一个正在运行的睡眠任务。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_8.png)'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_9.png)'
- en: If I quickly do another one， I'm going to have time。 Let's do sleep 20 and then
    jobs。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我快速做另一个，我就没有时间了。让我们做 `sleep 20`，然后输入 `jobs`。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_11.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_11.png)'
- en: Jobs。 Then there's still only one。 Let's do another one。 Sleep。 20 in the background。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobs`。然后还是只有一个。我们再做一个。让它在后台睡眠 20。'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_13.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_13.png)'
- en: Now if we do jobs， there should be two。 Now there are two jobs in the background。
    We should be able to -- I think kill -- did I say it's not kill。 So let's go back
    to the next slide。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们输入 `jobs`，应该有两个。现在后台有两个任务。我们应该能够——我想是可以杀死的——我是不是说它不能杀死？那么我们回到下一张幻灯片。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_15.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_15.png)'
- en: So let's go back to the next slide。 So let's go back to the next slide。 So let's
    go back to the next slide。 So let's go back to the next slide。 So let's go back
    to the next slide。 So let's go back to the next slide。 So let's go back to the
    next slide。 So let's go back to the next slide。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们回到下一张幻灯片。让我们回到下一张幻灯片。让我们回到下一张幻灯片。让我们回到下一张幻灯片。让我们回到下一张幻灯片。让我们回到下一张幻灯片。让我们回到下一张幻灯片。让我们回到下一张幻灯片。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_17.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_17.png)'
- en: So let's go back to the next slide。 So let's go back to the next slide。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们回到下一张幻灯片。让我们回到下一张幻灯片。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_19.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_19.png)'
- en: So let's go back to the next slide。 And then you could put that through word
    count and so forth。 You could also do that and then output it to word count out。txt。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们回到下一张幻灯片。然后你可以把它通过 `word count` 之类的处理。你也可以这样做，然后把输出保存为 `word count out.txt`。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_21.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_21.png)'
- en: And then we could do cat word count out。txt。 It should look very much like a
    terminal。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以做 `cat word count out.txt`。它应该看起来非常像一个终端。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_23.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_23.png)'
- en: And that's what you do。 I shouldn't be able to do control C。 It actually says
    control C。 but it doesn't kill the shell。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我不应该能够按下 `Ctrl+C`。实际上它说是 `Ctrl+C`，但它不会杀死 shell。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_25.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_25.png)'
- en: It shouldn't anyway。 And then control Z will not do the same thing。 If I do
    something like。 let's do sleep 20。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 至少不应该这样。然后 `Ctrl+Z` 也不会做同样的事情。如果我做一些像是……让我们做 `sleep 20`。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_27.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_27.png)'
- en: And then I do control Z now。 It should bring you back and then have a background
    job there。 which it does。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我现在按 `Ctrl+Z`。它应该会让你返回，并且保持一个后台任务在那里。确实如此。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_29.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_29.png)'
- en: So there's all the different parts that you're going to have to do for that
    assignment。 What is the 12？ The 12 means the 12th job that you've actually launched
    so far， I think。 in your shell。 I think that's all it means。 Never。 [ Inaudible
    ]， Oh， well。 the question was why are we using STSH for cat？ Cat actually will
    print out a particular file。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是你需要做的作业中的所有不同部分。12是什么意思？12表示你在Shell中实际启动的第12个作业，我想。大概就是这个意思。没错。[听不清]，哦，问题是为什么我们使用`STSH`来做`cat`？`cat`实际上会打印出特定的文件。
- en: That's all we're doing there。 And I happen to have that in that folder so I
    know that file is there。 So that's why I just said cat that one。 I just happen
    to know that file is this。 Any other question on that？ Okay， and then to exit，
    quit or exit。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在那里做的所有事情。而且我恰好在那个文件夹中有它，所以我知道那个文件在那里。所以我才说用`cat`来打印那个。我刚好知道那个文件就是这个。还有其他问题吗？好的，然后退出，输入`quit`或者`exit`。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_31.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_31.png)'
- en: That's Stanford shell。 You'll get used to that。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那是斯坦福的Shell。你会习惯的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_33.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_33.png)'
- en: And by the way， use that solution one to see what the output should be like。
    And some people sometimes miss that。 All right。 Let's see。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，使用那个解决方案1来查看输出应该是什么样的。有些人有时会错过这一点。好吧，我们来看看。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_35.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_35.png)'
- en: Cpp now。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是C++。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_37.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_37.png)'
- en: Okay。 Let's look at a new introverts program。 This is the recharge。 Basically
    what we're going to do is the same thing as --， same thing as we did for the same
    program。 It basically has 10 threads or， I guess， six threads in this case。 And
    they're all going to print out something about recharging when you're alone。 Okay。
    In fact。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看一个新的内向者程序。这是充电程序。基本上我们要做的和之前一样——和我们做的相同程序一样。它基本上有10个线程，或者在这种情况下是6个线程。它们都将在你独处时打印出一些关于充电的内容。好的。事实上。
- en: we'll do that right now。 We are in C++ now so we can start to use C out。 Okay。
    And if we do C out。 I recharge by spending time alone。 Okay。 And then -- and then
    N to L。 One thing about C out is unlike printf， it is actually not thread safe。
    Which means that -- and it turns out here's how it's not thread safe， by the way。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在就来做这个。我们现在在C++中，所以可以开始使用`C out`了。好的。如果我们做`C out`，我通过独处来充电。好的。然后——然后是N到L。关于`C
    out`的一件事是，与`printf`不同，它实际上不是线程安全的。这意味着——而且事实证明，它不线程安全的方式是这样的，顺便提一下。
- en: Each one of these less than less thans are a new function。 So basically this
    can print separately from the end L。 And so we want to avoid that， actually。 Well。
    you might not want to avoid that， but let's say you want to avoid that， we normally
    will。 If we want that entire C out statement to print without any other。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些小于小于符号（`<<`）都是一个新的函数。所以基本上它们可以独立于`endl`进行打印。所以我们实际上想避免这种情况。嗯，你可能不想避免这个，但假设你想避免这种情况，通常我们会这样做。如果我们想要整个`C
    out`语句打印出来而不被其他线程打断。
- en: thread interrupting it -- by the way， it probably won't do it like between time
    and alone。 but it will do it like any time you have this。 So if we wanted to not
    interrupt that。 what we can do is we can actually use a function， that Jeri Caine
    created。 which is just a lock on it， which says， "Hey， after I say OS lock inside
    a C out statement or inside a C out function。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线程中断——顺便说一下，可能不会在时间和独立之间发生中断。但它会在你有这个情况时发生。所以如果我们不想中断它，我们可以做的是，实际上使用一个函数，这是Jeri
    Caine创建的。它只是对它加了一个锁，意思是：“嘿，在我说OS锁定之后，在`C out`语句或者`C out`函数内部执行。”
- en: I just want to not have any other thread get in there and do something， while
    it's still doing that。" And then after this， we should also have OS unlock。 And
    this is using a header file called OS stream lock that we'll just link you to。
    Okay， question。 Chase。 [ Inaudible ]， Couldn't you just use print F？ Sure。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是想要在它完成之前，不让其他线程进入并做一些事情。然后在这个之后，我们还应该使用`OS unlock`。这使用了一个名为`OS stream lock`的头文件，我们会提供链接给你。好的，问题。Chase。[听不清]，难道你不可以直接使用`printf`吗？当然可以。
- en: But there might be some things that you might want to see out that are easier
    to do。 and to see out maybe some output of some other -- I don't know。 some other
    type or something that has a built-in overload for out or something like that。
    But yeah。 you should just probably stick to see out in this for C++。 It's also
    the better way to do C++。 Yeah？
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是可能有一些事情你想要查看，它们更容易做到。而且也许查看一些其他的输出——我不知道，某种类型的东西，或者有内建重载的输出，之类的。不过是的，你可能还是应该坚持使用`cout`来做C++中的输出。这也是做C++的更好方式。对吧？
- en: '[ Inaudible ]， In this case， you could use a new line character。 Yes。 although
    new line may not flush in this case， but yeah。 you probably could use a new line
    in this case。 But sometimes what if we wanted to do something like this？'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]， 在这种情况下，你可以使用换行符。 是的， 尽管换行在这种情况下可能无法刷新，但你可能可以在这种情况下使用换行符。但有时候，如果我们想做像这样的事情呢？'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_39.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_39.png)'
- en: I'll just do this one。 Like， see out， this is -- I should do it in var a colon
    a。 You know what I mean？ Like that， you know， period or whatever。 Then we still
    want to wrap it in that OS lock， OS unlock。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '我就做这个。 比如，看到， 这是——我应该用 var a: a。 你明白我的意思吗？ 就是那样， 你知道的， 句号或其他什么的。 然后我们仍然想把它包裹在那个
    OS 锁（OS lock）， OS 解锁（OS unlock）中。'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_41.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_41.png)'
- en: It's easy to use anyway。 All right， and that's that。 Somebody else had a question
    up here。 or maybe it was the same。 No？ Okay。 So anyway， that's what we're going
    to do there。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 反正很容易使用。 好的， 就这样。 这里有人有问题吗？ 或者可能是一样的。 不？ 好吧。 总之，这就是我们要做的事情。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_43.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_43.png)'
- en: In fact， that's all this function actually does。 Okay？
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这就是这个函数的实际作用。 好吗？
- en: And then what we're going to do is we're going to use the actual， threading
    library built into C++。 Okay？ So let's hear from K-num-introverts space introverts
    period。 And why didn't I use the OS lock there？ We're not in a thread yet。 Like
    we're not even in a thread yet， so not really necessary。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做的是使用 C++ 内置的线程库。 好吗？ 所以我们来听一下 K-num-introverts 空格 introverts 句号。 为什么我没有在这里使用
    OS 锁？ 因为我们还没有进入线程。 就像我们甚至还不在线程中，所以其实并不必要。
- en: And although it wouldn't break if we did use it， it's just don't use if you，
    don't need to。 Okay？
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果我们使用它，程序不会崩溃，但如果你不需要的话，最好不要使用。 好吗？
- en: There's a thread library。 I'll talk about the details of the thread library
    after we see the example。 Okay？ Here's how it works。 We're going to do the following
    introverts。 Okay？ And K-num-introverts。 Introverts。 Okay？ And that is actually
    setting up。 So we're calling the default constructor for this thread class。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个线程库。 我会在我们看到示例之后再详细讲解线程库。 好吗？ 它是这样工作的。 我们将执行接下来的操作，内向（introverts）。 好吗？ 然后
    K-num-introverts。 内向（introverts）。 好吗？ 这实际上是正在设置。 所以我们正在调用线程类的默认构造函数。
- en: And it is placing them into that array one after the other。 Now you would think，
    oh。 does that mean that it's actually launching a thread？ As it turns out。 the
    default constructor doesn't do that。 And then I'll show you what we do in a minute。
    This is actually a nuanced thing of C++11 that I'll show you。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在一个接一个地将它们放入那个数组中。 现在你会想，哦。 这是不是意味着它实际上在启动一个线程？ 结果发现，默认构造函数并不会这么做。 然后我会给你展示我们接下来怎么做。
    这是 C++11 中的一个细节，我会向你展示。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_45.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_45.png)'
- en: But for now， just know that that sets up the array of threads。 And then we can
    do the following。 So for thread， definitely need the ampersand on there to make
    it a reference。 And you'd buy the way you could put that reference there too。
    I like to put it here。 but some people like to put it before or with a space or
    whatever。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，只需知道它设置了线程数组。 然后我们可以做接下来的操作。 所以对于线程，肯定需要加上“&”符号以使其成为引用。 顺便说一下，你也可以在这里加上引用。
    我喜欢把它放在这里，但有些人喜欢把它放在前面或者留一个空格什么的。
- en: It doesn't matter as far as C++ is concerned。 Introvert in introverts。 Okay？
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就 C++ 来说，这没关系。 内向（introvert）是内向的。 好吗？
- en: And then what we are going to do is we are going to do the following。 So introvert
    equals thread recharge。 And that's all you need to do to actually say， hey。 here's
    a new thread with the recharge function， launch it。 Okay？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做的是接下来的操作。 所以，内向（introvert）等于线程重载（thread recharge）。 这就是你需要做的，实际上是说，嘿。 这是一个具有重载功能的新线程，启动它。
    好吗？
- en: You can have as many parameters as you want here。 If you want to send in other
    parameters。 we'll do that in a second。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里添加任意多的参数。如果你想传入其他参数，稍后我们会处理。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_47.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_47.png)'
- en: You can do that。 But this is for the simple example。 That's all you need to
    do。 Now。 the interesting part is happening right here where you're doing this
    weird。 and if I spell the introvert right， that would be better。 You're doing
    the exchange as it turns out。 Instead of just setting it equal， I'll talk about
    that more in a minute。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样做。但这是一个简单的示例。你只需要做这些。现在，真正有趣的部分发生在这里，你做了这个奇怪的操作。如果我正确拼写 introvert，那会更好。事实证明，你在做的是交换操作，而不是简单地将其赋值。稍后我会详细讲解。
- en: But you might think to yourself， wait， didn't I just start 10 threads？
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能会想，等一下，我不是已经启动了 10 个线程了吗？
- en: And now I'm doing a copy of 10 more threads。 And how does that work？ And so
    forth。 It actually is because C++ allows it to work as it turns out。 Okay？
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我正在复制另外 10 个线程。这是怎么做到的呢？等等，实际上这是因为 C++ 允许它正常工作。对吗？
- en: Then what we can do is we can do another same sort of thing。 In thread， introvert，
    in introverts。 Okay？ And then we are just going to do introvert because this is
    C++ is a class。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以做另外一种相似的操作。在线程中，遍历 introverts。对的？然后我们只需要做 introvert，因为这是 C++ 中的一个类。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_49.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_49.png)'
- en: Join， which does the exact same thing as join the function called it in C and
    it waits for that particular thread to end before it moves on to the next one
    in the fourth。 Okay？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`，它与 C 中的 `join` 函数做的是完全相同的事情，它会等待特定线程结束后再继续执行下一个线程，发生在第四步。明白了吗？'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_51.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_51.png)'
- en: That's the beginning one。 Let's see if it works。 Anybody notice any type of
    stuff？
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开始的部分。我们来看一下它是否有效。有谁注意到什么问题了吗？
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_53.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_53.png)'
- en: Let's see。 Make， introverts。 Okay， looks so good。 Introverts。 And there we go。
    I recharged by spending time alone six times。 Okay？
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看。创建 introverts。好，看来没问题。Introverts。好了，我通过独处六次重新充电了。明白吗？
- en: So let's go back and talk about the details of this。 A little more， in a little
    bit more detail。 Anybody have any particular questions so far on this？
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们回到这里，详细讨论一下这个问题。再详细一点。到目前为止，有人对这个内容有特别的问题吗？
- en: So the syntax for the formants you're getting the introvert by reference？ Yeah，
    very good question。 You're getting the introvert by reference in the line down
    here。 Yes。 And here。 You're getting it by reference from the actual introverts
    array。 And well， yeah， good question。 Why are you doing that？ We need to， as it
    turns out， this is the C++ part。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于你获得引用传递的语法是什么？是的，问题问得很好。你在下面这一行获得了引用。对的。在这里，你是从实际的 introverts 数组中按引用获得的。嗯，是的，问题问得很好。为什么要这么做？我们需要这样做，事实证明，这是
    C++ 部分的内容。
- en: And I guess we should just talk about that right now。 We're trying to take a
    thread that we're creating and plop it into an array。 Normally what would happen
    is you would copy all the resources out of the thread and place。 it into that
    array。 Right？ Well， that would mean there's now kind of two threads that are going
    and there's no real。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜我们应该现在就讨论这个问题。我们试图将我们创建的线程放入一个数组中。通常发生的情况是，你会将线程的所有资源复制出来，然后放入那个数组中。对吗？那么，这就意味着现在有两个线程在执行，而且没有真正的。
- en: way to like shut down the one and start up the one in the array。 It just happens
    that that doesn't work in C++ normally。 Well， C++ itself。 I think this is on the
    next page， has a new function， which is， here it， is。 operator equals thread two
    ampersands other。 It's just a syntax thing。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 比如如何关闭某个线程并重新启动数组中的线程。恰好的是，这种操作在 C++ 中通常不起作用。好吧，C++ 本身，我想这是下一页的内容，提供了一个新函数，就是这样。`operator
    equals thread two ampersands other`。这只是一个语法上的问题。
- en: It basically means we are setting up this move type of equality。 Basically it's
    swapping the two things。 Okay？ And all you need to really know about that is that
    this works。 And so， what's kind of the bottom line is that when you do this， when
    you do the actual。 equals right down here， and you say， okay， look， the thread
    that we are creating here is。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上意味着我们在设置这种“移动类型”的等式。基本上是交换这两个东西。明白了吗？而你真正需要知道的是，这样做是有效的。所以，重点是，当你这样做时，当你在这里执行实际的
    `equals` 操作时，你会发现，嗯，创建的线程是。
- en: actually going to be placed into the place where the reference is in the array。
    And it actually does a complete swap and places the non-working thread that we
    constructed。 in the array into our actual as the kind of thread over on the other，
    on the right-hand side。 of the array。 And so， what we're going to do is we're
    going to do this。 And we're going to do this。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上将被放置到数组中引用的位置。它实际上会完成一次交换，并将我们构建的非工作线程放入数组中，作为右侧的线程。所以，我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。我们将要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 And we're going to do this。 And we're going
    to do this。 And we're going to do this。 And we're going to do this。 And we're
    going to do this。 And we're going to do this。 And we're going to do this。 And
    we're going to do this。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。我们要做这个。
- en: And we're going to do this。 And we're going to do this。 And we're going to do
    this。 And we're going to do this。 Yeah， good question。 Are there things like W-No-Hang
    and W-On-Trace and all that？
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做这个。我们要做这个。我们要做这个。我们要做这个。是的，好的问题。有没有像W-No-Hang和W-On-Trace之类的东西？
- en: Not really。 You're not going to have the same models when you're doing this。
    Basically。 you're most often going to join at the end。 And it's not like you're
    going to stop a thread using SIGSTOP and so。 forth。 It's not a process in itself。
    Most of the things that we did with threads are processes in。 that sense are not
    going to be really in the same model of， threading。 Okay。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其实不是。你在做这个时不会有相同的模型。基本上，你通常会在最后进行合并。并不像你会用SIGSTOP来停止一个线程之类的。它本身不是一个进程。我们做的与线程相关的大部分操作实际上是进程。就这一点而言，它们并不完全是线程模型中的一部分。好的。
- en: threading is most of the time breaking up a problem into。 many subproblems to
    solve kind of independently。 We'll see an example of that in a few minutes。 And
    that's where it differs a little bit from multi-processing。 Remember。 most of
    the time multi-processing is fork exec。 Fork exec fork exec。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 线程大多数时候是将一个问题分解成许多子问题，独立地解决。我们几分钟后会看到一个例子。这就是它与多进程的不同之处。记住，大多数时候多进程是fork exec。Fork
    exec fork exec。
- en: That's most of the time what we do with processes so that we can， launch other
    programs。 This is now saying everything's going to be in my one program。 but I'm
    going to make them all kind of happen in parallel。 Yeah。 Good question。 All right。
    So that's the actual program。 Let's see。 What else can we talk about here？
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候我们用进程做的就是这样，这样我们就可以启动其他程序。现在这是在说，一切都会在我的一个程序中进行。但我要让它们都并行发生。是的。好的问题。好的。那么，这就是实际的程序。我们来看看。还有什么我们可以讨论的？
- en: This is the important part。 We declare an empty thread。 The empty thread handles
    array。 That's the important one。 Okay。 And then we install the recharge function
    into temporary threads。 That's just saying thread and then the name of the function。
    And then they get copied over or I should say moved into the， array。 Okay。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重要部分。我们声明一个空线程。空线程处理数组。这是重要的一部分。好的。然后我们将重载函数安装到临时线程中。那只是说线程，然后是函数的名称。然后它们被复制或应该说是移入数组中。好的。
- en: So that's kind of the new C++ part。 All right。 And you can read a little more
    details about that as you go。 Join method。 We talked about the function can be
    anything we want。 Normally we just have a void function because we don't actually，
    ever get the return value of it。 It's not you can't really get the return value
    in the same sense， that you can in wait PID。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++的新部分。好的。你可以在继续学习时了解更多细节。Join方法。我们讨论过函数可以是任何我们想要的。通常我们只是有一个void函数，因为我们实际上从来不会获取它的返回值。你不能像在wait
    PID中那样获取返回值。
- en: But it can be the function can be anything。 So you'll see lots of functions
    you'll write that we actually。 launch in a thread。 And it's actually pretty nice。
    It's in some ways much simpler than multiprocessing。 And you don't have to have
    any special types of functions。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但是函数可以是任何东西。所以你会看到很多你写的函数，实际上是我们在一个线程中启动的。实际上它相当不错。在某些方面，它比多进程要简单得多。而且你不需要任何特殊类型的函数。
- en: Just call the function with the parameters you want。 There it is。 Now it's running
    in its own thread。 It's actually relatively clean。 Yeah。 >> Can you give arguments？
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 只需调用你想要的参数的函数。就这样。现在它在自己的线程中运行。实际上相对干净。是的。>> 你能传递参数吗？
- en: '>> You can give arguments。 We will talk about that now。 Good question。 Okay。
    All right。 So let''s move on to a different example。 Okay。 This is going to be
    a greeter program。 And it''s going to be just a program where we are going to
    have。 a number of threads run and print out a little greeting based on。'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 你可以传递参数。我们现在就来讨论这个。好的问题。好的。那么，让我们换一个例子。好的。这将是一个问候程序。它将是一个程序，在这个程序中，我们将有多个线程运行，并基于此打印出一个简单的问候语。'
- en: their thread number that we're assigning it。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在分配给它的线程编号。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_55.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_55.png)'
- en: So let's look at that。 Oops。 There we go。 Maybe that's the one。 I hope that's
    the one。 There we go。 Okay。 So in this one we are going to have a function that
    takes a。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们来看看。哎呀。好了。也许就是这个。我希望就是它。好了。好了。在这个函数中，我们将有一个接收a的函数。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_57.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_57.png)'
- en: parameter。 And so this is how to actually send that parameter。 You can send
    it by value or references。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。然后这是如何实际传递该参数的方法。你可以通过值或引用传递它。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_59.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_59.png)'
- en: It turns out you can do either。 We can -- we'll show you how to do both of those。
    Okay。 In this case we are going to have each greeter grader。 And we're going to
    have a number of different types of parameters。 And we're going to have both of
    those。 Okay。 In this case we are going to have each greeter grader grader a。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现你可以做任何一个。我们可以 -- 我们会向你展示如何做这两种方式。好的。在这种情况下，我们将有每个问候者和一个不同类型的参数。我们将有这两者。好的。在这种情况下，我们将有每个问候者，评估器，评估器a。
- en: whole number of times。 I'll show you what I mean。 Okay。 Size t -- size t。 I
    equals zero。 I is less than the id。 So whatever id we pass in it's going to greet
    them that many， times。 Why not？
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 整个次数。我会向你展示我的意思。好了。`size t` -- `size t`。I等于零。I小于id。所以无论我们传递什么id，它都会问候那么多次。为什么不呢？
- en: It's kind of a silly program。 Okay。 So whenever we have to do osloc because
    we are in a thread and。 we can say greeter number and then id says hello。 And
    l。 And then we do osloc because that's after the entire line。 Okay。 All right。
    And then what we're going to do is we're actually going to do。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点傻的程序。好的。所以每当我们需要做`osloc`时，因为我们在一个线程中。然后我们可以说，问候者号码和ID说了你好。然后L。然后我们做`osloc`，因为那是在整行之后。好的。好了。然后我们要做的事情是，我们实际上将做。
- en: something here where we pause for a little bit of time so you can。 see the interleaving
    of the threads。 So we're going to do kind of this interesting thing。 We're just
    going to use a little time structure called time， spec。 You don't have to know
    about it。 I mean we'll never ask you about that。 t s equals and then you can set
    it up like this。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个地方，我们暂停一会儿时间，这样你就可以看到线程的交替执行。我们将做一些有趣的事情。我们只需要使用一个叫做time spec的小时间结构。你不需要了解它。我是说，我们永远不会要求你了解它。`ts`
    等于，然后你可以像这样设置它。
- en: It's got a few different things in random。 And then we are going to -- oops，
    random mod。 1， 2， 3， 4。 5， 6， 7， 8， 9。 A big number。 Okay。 And let's see。 I think
    that's that。 There we go。 And then we're going to do this thing called nano sleep
    for that。 amount of time which is a slightly small amount of time because， it's
    time divided by a billion。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一些不同的随机元素。然后我们将要做 -- 哎呀，随机模。1，2，3，4，5，6，7，8，9。一个大数。好了。我们来看看。我想就是这样。好了。然后我们将做一个叫做nano
    sleep的操作，暂停那个时间，这个时间会稍微短一点，因为它是时间除以十亿。
- en: Okay。 And then we are going to end our loop。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们将结束我们的循环。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_61.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_61.png)'
- en: I don't know why this is not。 There we go。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么这没有。好了。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_63.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_63.png)'
- en: Okay。 And then we are going to do another cout， os lock。 And we're going to
    say。 creader number ID as issued all of their hellos comma。 And then you can --
    I guess because the next line here we'll， do it on the next line。 So let's see。
    So they go home。 And L。 And then os unlock。 And that's it。 Okay。 So that's our
    greeting function。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们将再做一个`cout`，`os lock`。我们会说，创建者号码ID已经发出了所有的问候，逗号。然后你可以 -- 我猜因为下一行我们将在下一行做。所以让我们看看。然后他们回家了。然后L。然后`os
    unlock`。就这样。好的。这就是我们的问候函数。
- en: Okay。 Question。 >> Is there a get-de-ed like get-de-ed sort of phone？ Can you
    join in this function？
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。问题。>> 是否有类似get-de-ed的电话？你能在这个函数中加入它吗？
- en: '>> Is there a get-de-ed？ Can you join in this function？ There is a get-thread-id。
    You can get your threads-id which is more or less a process， like id if you want
    to do that。 No。 you wouldn''t be joining inside the thread。 You don''t want to
    be joining inside the thread。 You want the main program to do the joining。 Yeah。
    Maybe some nuances to that。'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 是否有get-de-ed？你能在这个函数中加入它吗？有一个`get-thread-id`。你可以获取你的线程ID，它或多或少是一个进程ID，如果你想这么做的话。没有。你不会在线程内部加入。你不想在线程内部加入。你希望主程序来做这个加入。是的，也许有一些微妙之处。'
- en: but in general don't try to join， another thread。 And by the way， again。 multi-processing
    and multi-threading don't really mix too well。 You don't want to fork inside a
    thread。 Otherwise lots of things could be bad。 You could do threads inside a process
    that you fork but not， the other way around。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但一般来说，不要尝试连接另一个线程。顺便说一下，**多处理**和**多线程**其实不太兼容。你不应该在线程内进行分叉操作。否则可能会有很多问题。你可以在你分叉的进程内创建线程，但不能反过来做。
- en: Just the way it works。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样工作的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_65.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_65.png)'
- en: You've got to be used to that。 Okay。 So anyway， that is our grid。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你得习惯这个。好了。总之，这就是我们的网格。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_67.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_67.png)'
- en: Let's just make sure we made that make-readers looks good。 Define and I used
    okay。 Good。 All right。 So then in main， what we're going to do is we're going
    to do， something like see out。 Welcome to gretland。 Welcome to gretland。 We're
    going to gretland。 We should probably capitalize that if it's a proper noun。 Okay。
    And then and L。 Okay。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们让 make-readers 看起来不错。定义了，使用了好的。好了。接下来在主函数里，我们要做的是，像这样做，`see out`。欢迎来到格雷特兰。欢迎来到格雷特兰。我们要去格雷特兰。如果它是一个专有名词，我们应该大写。好了。然后是
    L。好了。
- en: And then thread。 Greeters。 This should look familiar。 K-nom-greeters。 And then
    four。 Size t。 I equals zero。 I is less than K-nom-greeters。 Semi-colon I plus
    plus。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是线程。欢迎语。这个应该很熟悉。K-nom-greeters。然后是四。大小 t。我等于零。我小于 K-nom-greeters。分号 I 加加。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_69.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_69.png)'
- en: Okay。 We can do greeters。 We could have done it the way we did before， but this
    is just a。 slightly different way of doing without the reference。 We'll still
    do a copy like we did before and move like we did before。 Okay。 Greeters I equals
    thread and greet。 And then what we do is we just pass the parameter as the next
    parameter。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们可以做问候语。我们本来可以按之前的方式做，但这只是一种略微不同的做法，没有使用引用。我们还是会像之前那样做一个拷贝，并且像之前一样移动。好了。问候语
    I 等于线程和问候语。然后我们要做的是传递下一个参数作为参数。
- en: And that's what it does。 It calls greet with the parameter I plus one passed
    by value。 Did I do something wrong？ I plus one。 Oh， not I plus I。 That would have
    been an interesting program。 Okay。 All right。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。它调用问候语，并传递参数 I 加一作为值传递。我做错了吗？是 I 加一。哦，不是 I 加 I。那会是一个有趣的程序。好了。好了。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_71.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_71.png)'
- en: I plus one。 There we go like that。 Okay。 And then that's that。 And then we need
    to join them for size。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我加一。就这样。好了。然后就是这样。接下来我们需要根据大小将它们连接起来。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_73.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_73.png)'
- en: I'll just do this。 It's going to be the same。 Okay。 For size t。 K-nom-greeters。
    Okay。 And then we just do a greeter。 Nope。 Actually in this case we don't want
    to do that。 We want to do the actual thread。 I can't do it the way I want it to。
    I guess we probably could。 We could。 But in this case we'll do it the way we did
    before。 And then we want to do the thread。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我就这样做吧。结果是一样的。好了。对于大小 t，K-nom-greeters。好了。接着我们只需要做一个问候语。不对，实际上在这种情况下我们不想这么做。我们需要做实际的线程。我不能按照我想要的方式做。我想我们可能可以。可以。但在这种情况下，我们还是按照之前的方式来做。然后我们要做线程。
- en: And percent greeter。 Mix and match。 Greeter。 That。 And then in this case we
    want to do greeter。join。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是百分比问候语。混合搭配。问候语。那个。然后在这种情况下，我们要做 greeter。join。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_75.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_75.png)'
- en: Okay。 That will wait for them all。 Okay。 And then we want to just say see out
    everyone。 All greeted out。 And out。 Okay。 That's what we're going to do。 Good
    question。 Wait。 why did you say that original form of--， The original form of
    wood have worked。 I just decided to do a different way。 The original form of wood
    would have been this。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那样会等待它们全部完成。好了。然后我们只需要说 `see out`，每个人都被问候过了。然后输出。好了。这就是我们要做的。好问题。等等，为什么你说那个原始的形式--，原始的形式应该能工作。我只是决定用不同的方式做。原始的形式应该是这样。
- en: We could have done the--， We would have just done the greeter's eye。join instead。
    That would have worked。 Yeah。 But different way of doing it。 Let's show you both。
    Question。 What happens if you joined right after you created it？ Good question。
    If you joined right after you created it， what would happen？ You tell me。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以做那个--，我们本来只需要做 greeter 的 I。join 就行了。那样也能工作。是的。但这是另一种做法。让我们展示给你看。问题。如果你在创建后立即加入，会发生什么？好问题。如果你在创建后立即加入，会发生什么？你告诉我。
- en: Because it was a good thing to do nothing so it wouldn't get like， different
    time。 It would do something？ What would it do？ That would--， Won't join and wait
    until that thread just--。 Yeah。 It would serialize everything。 If you create the
    thread and then immediately join。 then it won't， go on and it won't even go to
    the next loop until that thread finishes。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因为什么都不做是件好事，这样它就不会变得像不同的时间那样。它会做什么？它会做什么？它会--，不会加入并等待直到那个线程完成--。是的。它会序列化一切。如果你创建了线程然后立即加入，那么它不会继续，甚至不会进入下一个循环，直到那个线程完成。
- en: So you need two loops？ Because you want to launch all the threads。 Let them
    all work in parallel and then wait for them all afterwards。 In fact。 that's a
    very good point。 That this is actually kind of key。 This is very much non-blocking。
    This loop happens super-duper fast。 What happens？ It just basically calls this
    thread function with a function name and。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你需要两个循环吗？因为你想启动所有的线程。让它们都并行工作，然后之后再等待它们。事实上，这是一个非常好的观点。这实际上是关键。这是非常非阻塞的。这个循环非常快速地发生。发生了什么？它基本上是调用这个线程函数并传入一个函数名和。
- en: says on your own time， as soon as possible， launch this thread and it。 moves
    on to the next iteration of the loop。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 说的是在你自己的时间，尽快启动这个线程，并且它。继续执行循环的下一个迭代。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_77.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_77.png)'
- en: So there's no waiting at all on this and that's actually kind of key。 All right。
    Let's see if we did this right。 Make readers。 So far so good。 Greeters。 All right。
    And then Greeters。 There we go。 Okay。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里完全没有等待，这实际上是关键。好吧。让我们看看我们是否做对了。创建读取器。到目前为止都好。问候者。好吧。然后是问候者。就这样。好的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_79.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_79.png)'
- en: So remember it's wait pausing a little bit in there。 That's why it does that。
    How many times should six say hello？ Six， say hello six times， I believe。 unless
    I did the less than instead of。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以记住，里面稍微有一点等待暂停。这就是它做那样的原因。六应该说多少次你好？六，应该说六次你好，我相信。除非我做了小于而不是大于。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_81.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_81.png)'
- en: less than or equal to。 But anyway， that's what it is。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 小于或等于。但不管怎样，这就是它的意思。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_83.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_83.png)'
- en: One only says hello once and then one happens to be the first one that's。 issued
    all of its hello so that they go home and so on and so on and so forth。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个只说一次你好，然后恰好是第一个已经说完所有你好的人，所以他们可以回家，依此类推。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_85.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_85.png)'
- en: Yeah。 If you want to do all that， I think we're going to do all that。 Could
    you do an OS lock for the --， Okay。 So first of all， OS lock is not for processes。
    It's only for C out。 So OS lock is only -- we'll talk about locks and things in
    a minute as we go for it。 If you wanted to do it in order， you just probably wouldn't
    have threads， number one。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。如果你想做这一切，我认为我们会做这一切。你能为--做一个操作系统锁吗？好吧。首先，操作系统锁并不是为进程准备的。它仅仅是为了C输出。所以操作系统锁仅仅是--我们稍后会谈论锁和其他东西。如果你想按顺序执行，你可能就不会使用线程，第一点。
- en: And number two， if you really could just join after you do each thread and then，
    it would do it。 That's not really the way you would normally use threads anyway。
    All right。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点，如果你真的可以在每个线程完成后就加入，那么它会这样做。那其实并不是你通常使用线程的方式。好吧。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_87.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_87.png)'
- en: Questions on this one， on this greeter function。 You can actually pass the parameters
    in。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问候者函数，你实际上可以传递参数进去。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_89.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_89.png)'
- en: Yeah。 I'm Mark。 [ Inaudible ]， Oh。 [ Inaudible ]， Right。 There's a good question。
    The question is。 wait a minute。 And I think you're alluding to a wait PID where
    you can say， oh， this one ended。 I'm going to handle that one first。 Not really。
    In this case。 you just got to -- you have to wait for them all in kind of order
    -- in whatever， order you want。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我是Mark。[听不清]，哦。[听不清]，对。这个问题很有意思。问题是。等一下。我觉得你是指那个等待PID，你可以说，哦，这个结束了。我先处理这个。其实不是。在这种情况下，你只需要--你必须按某种顺序等待它们--按你想要的任何顺序。
- en: But there's not really a way to -- as far as I know， I'll look it up。 But I've
    never seen it where you've waited for things out of -- you've joined out of order。
    You kind of just go， I'm going to slouch these threads and then wait for them
    all at the end。 In some sort of order。 You can't say I'm going to wait for any
    thread like that。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上没有什么办法——就我所知，我会查一下。但我从未见过你等待事情发生时会——你会按顺序等待线程的结束。你只能说，我将暂时处理这些线程，然后等待它们最后完成。不能说我要等待任何一个线程就这样。
- en: It's not the same model as multi-processing。 Good question。 Okay。 All right。
    So that's the greeter program。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这与多处理的模型不同。好问题。好的。好的，这就是问候程序。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_91.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_91.png)'
- en: And notice you can send in a parameter。 Okay。 All right。 What we can do is we
    generally want to use threads to break up a smaller -- or a bigger problem。 such
    that some group of threads can work on individual parts of that problem independently。
    That's why we have multiple cores and multiple processors so that we can actually
    do this。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以传入一个参数。好的。我们可以做的是，我们通常想使用线程来分解一个更小——或者更大的问题。这样，一组线程可以独立地处理这个问题的各个部分。这就是我们拥有多个核心和多个处理器的原因，这样我们就可以实际做到这一点。
- en: It's actually a nice benefit of threads and probably the main reason threads
    were ever created in the beginning。 So what we're going to do is we're going to
    do another little program and we're going to model ticket sales。 Okay。 Basically，
    this is where you call up， like， I don't know， United Airlines in this case。 And
    you don't do that anymore。 People used to actually call them instead of doing
    it online。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是线程的一个好处，可能是线程最初创建的主要原因。所以我们将做另一个小程序，我们将模拟售票。好的。基本上，这就是你打电话给，例如，联合航空之类的公司。现在你不再这么做了。以前人们确实会打电话，而不是在线办理。
- en: But you would call them up。 And let's say we have 10 ticket agents， which I'll
    answer the telephone。 And when they answer a telephone， they sell a ticket。 And
    we have 250 tickets that can be sold。 Okay。 256 tickets can be sold。 And as they
    answer the telephone。 they get a caller and then they sell that ticket。 Okay。
    And they sell one ticket。 Now。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你会给他们打电话。假设我们有10个售票员来接电话。当他们接到电话时，他们就卖出了一张票。我们有250张票可以卖。好的，256张票可以卖。当他们接到电话时，他们会接到一个来电者，然后卖出那张票。好的。他们卖出了一张票。现在。
- en: it might turn out that somebody wants to fly to the middle of nowhere or whatever。
    And the ticket agent takes a little longer to actually process that ticket。 And
    it might be that some other ticket agent gets a whole bunch of people who just
    want to fly from New York to Boston。 And it's an easy， like， you know， two second
    call， phone call， whatever。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现有人想飞往一个荒无人烟的地方，或者类似的情况。然后，售票员可能需要稍微多一点时间来处理这个票务。也可能有其他的售票员接到一些只想从纽约飞往波士顿的乘客。这是一个很简单的，比如说，知道的，两个秒钟的电话之类的。
- en: That's -- so we don't want to necessarily limit all of the -- we don't want
    to limit -- oh， no。 All right。 Why do you do this？ Hang on。 We don't want to limit
    the actual number of tickets to 10% of the -- like 10% for each agent。 Okay。 And
    specifically， so that we can allow them to do it a little more effectively。 Okay。
    So what we might do is something like this。 Okay。 Let me actually start -- I'll
    actually do this in the program because we're going to run this for you in a minute。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那个——所以我们不一定要限制所有的——我们不想限制——哦，不。好的。为什么要这样做？等一下。我们不想限制每个售票员的实际票数，比如说限制为10%的票数。好的。具体来说，这样可以使他们更有效地工作。好的。所以我们可能会做类似这样的事。好的。让我实际开始——我会在程序中做这个，因为我们一会儿会为你运行这个。
- en: And let's see if I can clear it。 Okay。 Let's see。 This one is going to be called
    Confused。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我能否弄明白。好的。让我们看看。这个将被命名为“混乱”。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_93.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_93.png)'
- en: And we'll see why in a minute ticket agents。 Okay。 It's going to be a little
    bit confusing here。 But this is what we might start out with。 Okay。 We might start
    out with something like this。 All right。 Thread Agents 10。 Okay。 We could have
    a constant for that。 That's that。 Thread Agents 10。 Size T remaining tickets。
    Tickets equals 250。 Okay。 So we're going to have 250 remaining tickets。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上就会看到为什么需要售票员。好的。这里可能有点混乱。但是这就是我们可能开始时的样子。好的。我们可能会从类似这样的情况开始。好的。线程代理10。好的。我们可以为此设置一个常量。就是这样。线程代理10。大小T剩余票数。票数等于250。好的。所以我们将剩余250张票。
- en: All right。 And then four。 Size T。 I equals zero。 I is less than 10。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后四个。Size T。I 等于零。I 小于10。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_95.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_95.png)'
- en: I plus plus。 Okay。 What we're going to do here is we're going to say agents。
    I equals thread ticket agent because that's the function we're going to create。
    Ticket agent。 We'll give a ticket -- each ticket agent a little number between
    101 and I。 I'm not sure why we gave it a hundred and one， but we did。 Okay。 100
    and I。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: I 加一。好的。我们将在这里做的是，我们会说代理。I 等于线程票务代理，因为这是我们要创建的函数。票务代理。我们将给每个票务代理分配一个介于101和I之间的小数字。我不确定为什么我们给了它101，但我们确实这样做了。好的，100和I。
- en: And then we need to pass in the remaining tickets by reference。 Okay。 Now thread
    has no idea about a reference parameter versus a regular parameter。 So if you
    tried to say this remaining tickets like that， okay。 then what would happen is
    you would actually send it by value， which is not what you want to do。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要通过引用传递剩余票务。好的。现在线程对引用参数和常规参数没有概念。所以如果你尝试像这样说剩余票务，那么发生的事情是，你实际上会按值传递，这并不是你想要的。
- en: Okay。 And there's no real easy -- well， there is an easy way to do it。 but something
    you may not have seen before。 If you want to specifically send a parameter by
    reference。 you actually wrap it in a ref function。 Okay。 Or maybe it's an operator。
    But anyway。 it basically says send this by reference， not by value。 Okay。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。没有真正简单的方法——嗯，实际上有一个简单的方法。但可能是你之前没见过。如果你想特定地通过引用传递参数，你实际上需要将其包装在一个引用函数中。好的。或者可能是一个操作符。不过不管怎样，它基本上就是告诉你，通过引用传递，而不是按值传递。好的。
- en: So that's what we're going to do for each thing because now we're going to have
    one remaining tickets that all the agents are going to pull from。 Okay。 All right。
    And let's see。 That's -- let's see。 Is that the end of the function there？ Well。
    we've got it。 We've been running that statement。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将对每个操作执行相同的操作，因为现在我们将有一个剩余票务，所有代理都将从中提取。好的。好的。让我们看看。这是不是函数的结束？嗯，我们已经运行了那个语句。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_97.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_97.png)'
- en: Okay。 And then there， and then that actually launches them all。 And then we
    have for the red ampersand agent in agents， agent dot join like that。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后那边，然后实际上会启动所有的线程。然后我们有一个针对红色和符号代理的循环，代理点连接像这样。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_99.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_99.png)'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_100.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_100.png)'
- en: And then we will say see out end of business day。 Okay。 So we're basically going
    to -- after everybody finishes， we will say end of business day。 Okay。 All right。
    Everybody get what's happening in main there。 Okay。 Let's look at the actual remain
    or ticket agent function and see what we can come up with here。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会说，输出工作日结束。好的。基本上我们将在每个人完成后，说工作日结束。好的。大家都明白主函数中的操作了吗？好的。让我们来看一下实际的剩余票务代理函数，看看我们能提出什么。
- en: Okay。 Well， we're going to have each agent grab a ticket and sell it， basically。
    And then we're going to have a ticket that's going to be like a while remaining
    tickets。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们将让每个代理抓取一个票据并卖出，基本上就是这样。然后我们将有一个票据，就像是一个剩余票务的循环。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_102.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_102.png)'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_103.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_103.png)'
- en: It's greater than zero。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它大于零。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_105.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_105.png)'
- en: Okay。 Well， in here we are going to say I have a function that handles the call。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么在这里我们将说，我有一个处理调用的函数。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_107.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_107.png)'
- en: Okay。 You don't have to worry about the points up here somewhere。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。你不需要担心上面某些点。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_109.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_109.png)'
- en: You can actually read it later。 But don't -- actually。 it's just basically --
    it sleeps for a while to kind of mimic handling the call。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以稍后阅读它。但不要——实际上。它基本上是让程序睡眠一段时间，以模拟处理调用的过程。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_111.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_111.png)'
- en: Okay。 So we're going to handle the call。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们将处理这个调用。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_113.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_113.png)'
- en: Okay。 And then this is going to sleep for a little while to basically mimic
    handling the call。 Now。 how long it takes。 And that's a random number。 Okay。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后这个将睡眠一会儿，基本上模拟处理调用的时间。现在。它需要多长时间，这是一个随机数。好的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_115.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_115.png)'
- en: And then we're going to say remaining tickets minus minus because we just sold
    one。 Okay。 And then let's actually print out OS lock in this case and agent number。
    And same thing ID sold a ticket like that。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会说剩余票数减1，因为我们刚刚卖掉了一张票。好的。然后让我们在这种情况下打印出OS锁定和代理编号。然后是同样的事情，ID售出了一张票。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_117.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_117.png)'
- en: Okay。 And then we will say remaining remaining tickets more to be sold like
    that。 And then we have to do the OS unlock like that。 Okay。 So we're basically
    saying， okay。 well now a ticket -- ticket has been sold。 Okay。 And then we're
    going to let the agent take a break if it's time for them to take a break。 This
    is just to kind of interleave things a little bit more。 If should take break。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们会说剩余票数，像那样还需售出更多票。然后我们需要像那样解锁OS。好的。所以基本上我们是在说，好的，票已经售出。好的。然后如果代理该休息了，我们就让他们休息一下。这只是为了让事情稍微交替一下。如果该休息就休息。
- en: then we are going to basically take break。 Okay。 All right。 Sometimes these
    get a little bit silly。 But then that's it。 And then see out。 That is actually
    after the while loop， right？
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们基本上就要休息了。好的。好的。有时候这些事情会变得有点傻。但那就这样。然后输出。实际上这是在while循环之后，对吗？
- en: We get -- then we say， oh great。 We've sold all the tickets because the remaining
    tickets are not -- there's no more left。 Okay。 So we can say something like agent
    number ID notices。 All tickets are sold and goes home。 Okay。 And LOS unlock。 I
    forgot to do the OS lock beginning。 OS lock that。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到 -- 然后我们说，哦太好了。我们已经卖完所有的票，因为剩余的票已经没有了。好的。然后我们可以说类似“代理编号ID注意到，所有票已售完，然后回家”。好的。然后解锁LOS。我忘了在开始时做OS锁定。锁定它。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_119.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_119.png)'
- en: Okay。 All right。 So this is our first attempt。 Anybody see any bugs？ All right。
    This is our first attempt。 Basically we're going to have each agent keep countdown
    and go ahead and do it。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好的。这是我们第一次尝试。有人看到什么bug了吗？好的。这是我们第一次尝试。基本上，我们会让每个代理保持倒计时，然后继续操作。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_121.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_121.png)'
- en: Make confused。 Ticket。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让人困惑。票。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_123.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_123.png)'
- en: Agents。 Oh no。 Here we go。 Let's see。 No name type online。 Oh boy。 I love C++
    errors。 Okay。 Hold on。 Not there。 Where is the actual error？ Not there。 Not there。
    Not there。 Not there。 Uh oh。 Oh there it is。 62。 Maybe。 62。 All right。 What do
    we do here？ We're going to do a red ticket agent。 We're out for remaining tickets。
    Agents。 We set up agents。 And then what else？ It's the agent side。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 代理。哦不。我们来看看。没有名称类型在线。哦天。真爱C++错误。好的。等一下。不是那里。实际的错误在哪？不是那里。不是那里。不是那里。不是那里。呃哦。哦，找到了。62。也许。62。好的。我们在这里做了什么？我们要做一个红色票务代理。我们剩余票数用完了。代理。我们设置了代理。然后还需要做什么？是代理端。
- en: It goes through the ticket agent。 And plus the ref remaining tickets。 I think
    you don't define ticket agent。 I don't define ticket agent。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过票务代理。然后加上引用剩余票数。我想你没有定义票务代理。我没有定义票务代理。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_125.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_125.png)'
- en: Uh it's up here isn't it？ I think there it is right there。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 呃，它在这里，不是吗？我想应该就在那儿。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_127.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_127.png)'
- en: It's the function we're trying to send。 Mmm。 Let's see。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们试图发送的函数。嗯。让我们看看。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_129.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_129.png)'
- en: Do we need the ref？ We do。 That's right there。 That's going to happen there。
    We do need that。 You need to like import something。 I don't think so。 Um let's
    see。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引用吗？需要的。就在那儿。会发生的。我们需要这个。你需要导入一些东西吗？我不这么认为。嗯，让我们看看。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_131.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_131.png)'
- en: I'm trying to think if there's any。 Let's look at the error again。 No name type。
    Mmm。 Red 137。 Known type name type in class void。 Not sure。 Well in the interest
    of time I happen to have the original。 Let's just do it。 Let's do it。 This is
    just in case this sort of thing happens and I can't not。 good enough to find this。
    I'm confused ticket agents original CC。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我在想是否有其他问题。让我们再看一下错误。没有名称类型。嗯。红色137。已知的类型名称在类中为空。不是很确定。嗯，为了节省时间，我手头正好有原始的。我们就这样做吧。我们就这样做吧。这只是万一发生这种事，我也不会不行。够好，能找到这个。让我困惑的票代理原始CC。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_133.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_133.png)'
- en: Uh let's see。 What did we do here？
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，让我们看看。我们在这里做了什么？
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_135.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_135.png)'
- en: Oh no。 Doesn't look looks much different。 I don't think it。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不，看起来并没有太大变化。我觉得它没有。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_137.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_137.png)'
- en: Well it's the one I promise you it should be the one。 Now that's a hang on。
    That is it uses all the constants。 Yeah。 Maybe I actually forgot a part of it
    here。 No I don't think so。 Well here's what we're going to do。 We're going to
    copy it over and do it and run it。 Uh because I'll look at here。 Here's what I'll
    do。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它就是我承诺的那个。现在等一下。它使用了所有常量。是的。也许我在这里确实忘了一部分。没有，我不这么认为。好了，这就是我们要做的。我们将把它复制过去，执行它。嗯，因为我会看这里。我会这样做。
- en: I'll make a copy of it right now。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在就复制一份。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_139.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_139.png)'
- en: Confused ticket agents。cc to confused ticket agents。 Chris is confused。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 困惑的售票员。cc 转给困惑的售票员。Chris 感到困惑。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_141.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_141.png)'
- en: I'll check it out later and then confused ticket agents。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后检查一下，然后再看困惑的售票员。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_143.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_143.png)'
- en: Uh original to confused ticket agents。cc。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，原始的转给困惑的售票员。cc。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_145.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_145.png)'
- en: And right。 Okay。 Let's try it again。 Confused ticket agents。 That time it worked。
    Okay。 Now I swear I work when I try to。 Okay。 So here's what it's going to do。
    It's going to go count down all 250 each。 Each ticket agent is getting waiting
    some amount of time。 Some may get five over the course。 Some may get 10。 Some
    may get 20。 Some may get 30。 Whatever。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对，好的。我们再试一次。困惑的售票员。那次成功了。好的。现在我发誓我尝试时它会工作。好的。那么它将会做什么呢？它将会倒计时所有的250。每个售票员都在等待一段时间。某些售票员可能在过程中等待5秒，某些可能等10秒，某些可能等20秒，某些可能等30秒。无论如何。
- en: It will finally keep going and count down。 And then that's going to take a long
    time to get one more sold。 Okay。 So and this is going to go on basically forever。
    Right。 In fact when it gets down to about zero again it'll probably wrap around
    again。 Okay。 So we have an issue。 What is our issue is the question。 Okay。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最终它将继续进行并倒计时。然后，这将需要很长时间才能再卖出一个票。好的。那么这将基本上永远持续下去。对，实际上，当它倒计时到接近零时，可能会再次回绕。好的。那么我们有一个问题。我们的问题是什么，这是个问题。好的。
- en: Let's look at the actual code here that we should have been doing here。 Okay。
    That's main。 And then that's main two。 We already know that's there。 Let's see。
    Here's the ticket agent。 Maybe I still looks all right。 So here's what we're doing
    here。 Is there a race condition？
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们本应该在这里做的实际代码。好的。这是主函数。然后这是主函数2。我们已经知道那部分了。我们来看看。这里是售票员。也许它看起来还好。那么我们在做什么呢？这里有竞争条件吗？
- en: Some of you already noticed it。 I could tell when I was writing it。 What's the
    race condition here？
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人已经注意到了。可以看得出来，当我写代码时，我就知道会有这个问题。这里的竞争条件是什么？
- en: Yeah。 Emily。 They all have access to remaining tickets。 Right。 And when the
    remaining tickets when it does the decrement there and the remaining tickets。
    while remaining tickets is greater than zero and then remaining tickets minus
    minus。 those it may not be true that that actually that remaining tickets is still
    greater than。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Emily。他们都可以访问剩余的票。对。然后当剩余票数递减时，如果剩余票数大于零，那么剩余票数减一。这时，剩余票数是否依然大于零就不一定成立了。
- en: zero because some other thread could have come in and done the exact same thing。
    Okay。 So that's the issue。 One of the issues here。 In fact， it's much more subtle
    than that even。 Okay。 There's this idea that you can do that。 Well， what happens
    is， well。 we can see what happens there that it actually ends up going。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 零，因为其他线程可能已经进入并做了完全相同的事情。好的，这就是问题所在。这是其中一个问题。事实上，问题比这还要微妙。好的，有这样一个想法，你可以这样做。那么，结果是什么呢？我们可以看到这里发生了什么，实际上最终它还是会继续进行下去。
- en: down and wrapping around because two things have tried to decrement。 If actually
    indeed decremented the thread count before， another thread came out and said，
    oh。 there are any left。 Oh， yeah， there's four billion left。 So that's the issue。
    The， as I said。 it's even more subtle than that。 Even remaining tickets minus
    minus itself is not necessarily atomic。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下降并回绕，因为两件事尝试递减。如果之前确实已经递减了线程计数，而另一个线程出来时说，“哦，还有剩余的票”。哦，是的，还有四十亿张票。所以，这就是问题所在。正如我所说，这甚至比那还要微妙。即使是剩余票数减一本身也不一定是原子操作。
- en: Okay。 A C++ statement is atomic in that it runs on its own。 But remember。 what
    does a C++ statement do？ And all you people who took 107 would know that it gets
    translated into possibly a whole bunch。 of assembly code instructions， each one
    of which is more or less atomic， but together。 they certainly are not atomic。
    Okay。 So this， when you do remaining tickets minus minus。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，C++语句是原子性的，因为它是独立执行的。但记住，C++语句做什么呢？所有上过107课的人都知道，它会被转换成可能是一大堆汇编代码指令，每一条指令或多或少是原子性的，但它们加在一起就绝对不是原子性的。好吧。所以，当你执行remaining
    tickets--时，实际上。
- en: if you go and decompile， you can see， that it ends up coming into some。 ends
    up something like this assembly code here where you've got five different， instructions。
    any which， any one of which could get interrupted by going to the next thread，
    and having a problem。 So what are we actually doing？ We're getting the memory
    and then we are decrementing it by one。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去反编译，你会看到它最终会变成像这样的汇编代码，你会看到五个不同的指令。任何一条都可能被下一个线程中断，导致问题。那么我们实际上在做什么呢？我们获取内存，然后将其减去1。
- en: Remember our favorite command， LEA， for two people who took 107。 And then we're
    decrementing it by one。 And then we are moving it back into memory。 Well。 if any
    other thread did some of those operations while these were happening， like。 then
    the memory wouldn't necessarily be one or move。 This is a classic race condition。
    Okay。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们最喜欢的命令 LEA，给那些上过107课的人。然后我们将它减去1。接着，我们把它移回内存。好吧。如果其他线程在这些操作执行的过程中做了某些操作，像是…那内存就不一定是1，或者可能无法移动。这就是经典的竞争条件。好吧。
- en: Absolutely classic race condition that you need to be able to handle。 Okay。
    So what are the kinds of things we can do？ Well， what we can do。 and this is built
    into the thread libraries， we can say， okay， one， of the programs is not going
    to。 is not going to run， or one of the threads is going to have， access to this
    data structure。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对经典的竞争条件，你需要能够处理它。好的，那我们可以做哪些事情呢？好吧，我们可以做的事情，实际上它已经内置于线程库中了，我们可以说，好的，某个程序将不会运行，或者某个线程将有权访问这个数据结构。
- en: in other words， the， or， or， or data structures that remain， in tickets variable。
    while all the other ones have to wait on it。 Okay。 So that's what， and by the
    way。 I just realized what I can do here to make our code a little， simpler， as
    far as the， see。 then confused ticket agents， not CC。 I'm just going to do the
    following。 That was which one。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，或者，或者，或者数据结构会保留在票务变量中，而所有其他线程必须等待它。好的。顺便说一下，我刚意识到我可以做些什么来简化我们的代码，就像是，看看。然后搞乱票务代理，不是CC。我只是要做以下的修改。那是哪个？
- en: That was the ticket agent。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是票务代理。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_147.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_147.png)'
- en: Again， I'll go home and pour over this and see why I made this mistake before。
    But anyway。 we'll place that in there and then we will change main as well。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我会回家仔细研究这个问题，看看为什么我之前犯了这个错误。但无论如何，我们会把那个放进去，然后我们也会改变主函数。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_149.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_149.png)'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_150.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_150.png)'
- en: And then let's see， name is going to be here。 Okay。 And what we're going to
    do is， okay。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们看看，名字应该放在这里。好的，我们要做的是，好的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_152.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_152.png)'
- en: So let's see if that works now。 Make confused ticket agents。 Oh， no。 It must
    be my， wait。 I swear I typed this in the front。 Well， all right， hold on。 Maybe
    we won't do that。 Well。 what I'm going to， I'll show you what we're going to actually
    do here to， yes。 All right。 What we have to do is we have to modify using this
    thing called a mutex。 Okay。 And a mutex is。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们看看现在是否能正常工作。让我们搞乱票务代理。哦，不。一定是我的，等一下。我发誓我在前面输入过这个。好吧，等一下，也许我们不这么做了。好吧，我要做的是，我来给你们展示一下我们实际要做的事情，来，没错。我们需要做的是，使用这个叫做互斥锁（mutex）的方法。好吧，互斥锁就是。
- en: where did it go here？ A mutex， this we already went through this。 A mutex is
    a。 basically a lock that says when a particular thread calls lock on a mutex。
    Any other thread that also tries to call lock on that mutex has to wait until
    the previous。 thread releases it with an unlock。 Okay。 So here's how it goes。
    It's a class called mutex。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它在哪里？我们已经讲过了。互斥锁，这个我们已经讲过。互斥锁本质上就是一个锁，当某个线程调用互斥锁的锁定操作时，任何其他线程也想调用这个互斥锁，就必须等到前一个线程通过解锁释放它。好吧。它是一个叫做互斥锁（mutex）的类。
- en: And what you do is you say mutex m for some mutex variable。 Okay。 And then if
    a thread says mutex。lock， another thread can come in and say mutex。lock。 But if
    the previous thread already has it locked， the new thread just kind of waits around
    until。 it unlocks。 Okay。 If multiple threads are trying to lock on a mutex。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的是为某个互斥量定义一个变量，比如说 mutex m。好的。然后如果一个线程执行 mutex.lock，另一个线程也可以进来执行 mutex.lock。但是如果前一个线程已经锁定了它，新线程就得等待，直到它解锁。好的。如果多个线程都在尝试锁定同一个互斥量。
- en: then one of them will win during the， unlock battle that happens after it gets
    released。 And all the others will go back and wait again。 Okay。 So it's a way
    to say， no。 only one thread can handle this at a time。 And it's just using this
    variable as that beacon that says you are allowed to use it。 you are， not。 And
    that's how it works。 Okay。 It locks what we call critical regions of memory。 Okay。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后其中一个线程会在解锁竞争中获胜，其他线程会再次回去等待。好的。所以它的作用是告诉你，只有一个线程可以在同一时间处理这个区域。它只是通过这个变量作为信号，表示你被允许使用它，或者你不能使用它。它就是这样工作的。好的。它锁定了我们所说的内存中的关键区域。好的。
- en: And it's super useful。 And there's a couple of other ones that we're going to
    learn about as well。 Super useful to be able to say， oh， great。 Now we've got
    multiple threads here that all get to use that。 but nobody's going to step， on
    everybody else trying to do the decrement。 Question chasing。 Is it possible that
    thread will always lose the battle？ So that's a good question。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常有用。而且我们还会学习到其他几种互斥量类型。非常有用的是能够说，“哦，太好了，现在我们有多个线程可以使用这个资源。”但没有线程会在其他线程执行递减操作时互相干扰。问题追问：是否有可能线程总是输掉竞争？这是一个很好的问题。
- en: Is it possible that a single thread will always lose the battle？ Sure。 One thread
    might always lose the battle。 But then in the end， if all， whenever else finishes。
    it will finally get it。 If your logic is right， it would eventually get it。 But
    you can't promise to any one thread， you're going to be next。 No way to do that
    with a mutex。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有可能一个线程总是输掉竞争？当然。有可能一个线程总是输掉竞争。但是最终，当其他线程都完成时，它最终会获得锁。如果你的逻辑是对的，它最终会得到锁。但你不能承诺任何一个线程说下一个是你。用互斥量无法做到这一点。
- en: Good idea。 There are certain types of locking locks that have a priority associated
    with them。 We'll get to that later。 But the ones we're going to concentrate on
    have no。 you have no ability yet。 Yeah。 So that's C++ statements on atomic。 Because
    they're translated into assembly， the same culture to C++。 Yeah。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 好主意。有些类型的锁具有优先级。我们稍后会讨论到这一点。但我们现在要集中讨论的是那些没有优先级的锁，你目前还没有能力控制优先级。是的。所以这是关于 C++
    的原子操作语句。因为它们会被转换成汇编语言，就像 C++ 的文化一样。是的。
- en: The question was are C++ statements are not atomic because they're translated
    into assembly。 Same exact history for C。 Yeah。 All of that stuff that you did
    in 107 where you had to translate C statements into assembly。 you had lots of
    assemblies， statements per C statement。 So same exact thing。 So does it not get
    expensive instead of just getting hung up on this light log？ Ah。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，C++ 的语句是否不是原子操作，因为它们会被翻译成汇编语言。对于 C 语言来说也是一样的历史。是的。你在 107 课程中做的所有事情，你必须把
    C 语句翻译成汇编语言，你会发现每个 C 语句对应很多汇编语句。所以这是完全一样的事情。那么，这不会比单纯的挂起锁变得更昂贵吗？嗯。
- en: Very good question。 Does it get expensive because if they're held up a box？
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好的问题。是否会变得更昂贵，因为它们可能会被阻塞？
- en: Let's see what happens when we make a change here and then we'll see how it
    actually manifests。 itself。 A very good question and very pressing a question。
    Anybody else？ Okay。 So what is a mutex come from？ It stands for mutual exclusion
    and it basically is solely there so that you can mark where critical。 places in
    your code are that multiple threads might be working on at the same time。 Okay。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们在这里做一个更改会发生什么，然后我们会看到它实际是如何表现出来的。非常好的问题，而且是一个非常紧迫的问题。还有其他问题吗？好的。那么，互斥量是从哪里来的？它代表互斥，它的基本作用就是标记代码中可能会有多个线程同时操作的关键区域。好的。
- en: When you create a mutex， it is unlocked。 A particular thread calls lock on it
    and then nobody else can call lock。 They just wait until that lock is unlocked。
    The only thread that's allowed to call unlock after locking is the one that locked
    it。 Another thread could do it and it's undefined behavior and you shouldn't do
    that。 Only your heavy logic so that nothing tries to unlock a lock it doesn't
    hold。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个互斥锁时，它是解锁状态。某个线程调用 `lock` 时，其他线程就不能再调用 `lock`。它们只会等待直到锁被解锁。唯一可以在锁定后调用
    `unlock` 的线程是锁定它的那个线程。其他线程如果尝试解锁，则会导致未定义行为，而且你不应该这么做。只有在你的复杂逻辑中才确保没有其他线程尝试解锁它没有持有的锁。
- en: You'll see how that's not hard to get that right by the way。 And then that's
    that。 Okay。 So let's actually see what we would have to do to make our confused
    ticket agents。 Uh， hang on。 Confused ticket agents。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，这其实并不难做到。然后就是这样。好的。那么，让我们看看实际需要做些什么，才能让我们的票务代理搞清楚。呃，稍等。票务代理搞不懂了。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_154.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_154.png)'
- en: Program。 Do this。 Okay。 All right。 So here's where we've got the issue。 Okay。
    Well。 what we need to do is we need to have a mutex that we send in to all of
    the threads。 So they all have one mutex。 Okay。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。做这个。好的。那就是我们遇到的问题。好的。那么，我们需要做的是，我们需要有一个互斥锁，并将其传递给所有线程。这样它们每个线程都有一个互斥锁。好的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_156.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_156.png)'
- en: So let's go back down to main and actually do that。 Okay。 So， again。 what we're
    going to do is now we're going to say， oh， all right。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们回到主函数，实际操作一下。好的。那么，再次说明，我们现在要做的是，说，哦，好吧。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_158.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_158.png)'
- en: Let's have a mutex here that is， let's say mutex。 Let's see。 I haven't done
    the， yeah。 I haven't done the before。 Yeah。 Mutex tickets lock。 Okay。 All right。
    That's all you have to do for that。 Okay。 And what we can do is we can， um， in
    here。 we actually now have to， uh， send it in。 Okay。 So we're just going to do
    this。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里定义一个互斥锁，假设它叫 `mutex`。让我看看，我还没有做，嗯，还没做。是的，互斥锁 `tickets lock`。好的，明白了。那就是你需要做的全部工作。好的。那么我们现在可以做的是，我们要在这里，实际上我们现在需要，呃，传入它。好的。所以我们就这么做。
- en: We're going to say same thing as before。 We're going to say， uh， have the remaining
    tickets in here。 And then we're just going to put another parameter， which is
    the same thing as before。 ref tickets lock。 Okay。 Like that。 And then that will
    just send the other parameter in there。 We have to update our parameter list for
    the function as well。 So it can take the right function。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要说的和之前一样。我们要说，呃，将剩余票数放在这里。然后我们只需要再加一个参数，它和之前的参数一样。`ref tickets lock`。好的，就像这样。然后它就会把其他参数传入其中。我们还需要更新函数的参数列表，以便能够接受正确的函数。
- en: Okay。 And， um， other than that， that's all we have to change in main。 We're
    just creating in main and sending it into the threads。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，除此之外，这就是我们在主函数中需要改变的全部内容。我们只需要在主函数中创建并将其传递给各个线程。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_160.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_160.png)'
- en: Okay。 Now here we need to do a mutex reference。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们需要做一个互斥锁引用。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_162.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_162.png)'
- en: Mutex reference tickets lock。 Okay。 All right。 And what are we changing here？
    Well。 instead of doing， uh， remaining tickets is greater than zero。 Let's do the
    following。 Okay。 Let's do while true。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁引用 `tickets lock`。好的。那么我们在这里改变了什么呢？嗯，不再使用 `remaining tickets > 0`，我们改成这样。好的，我们做一个
    `while true`。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_164.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_164.png)'
- en: Okay。 And then let's do this tickets lock dot lock。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们做这个：`tickets lock dot lock`。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_166.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_166.png)'
- en: Okay。 Actually， I'm going to reform at this。 There we go。 Ticket lock tickets
    lock dot lock。 Okay。 And then we are going to do， we're going to check and see
    if remaining tickets， each。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，实际上，我要重新格式化一下。好啦。`ticket lock tickets lock dot lock`。好的。然后我们将检查，看剩余票数，逐个查看。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_168.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_168.png)'
- en: equal zero， right。 In other words， now we're the ones who are going to have
    access to that remaining tickets。 Nobody else can be changing it in the middle。
    We're going to be changing。 We're going to be checking it。 If it happens to be
    zero， we're done。 No more tickets to go。 You have a question。 So there's a lock
    lock all of the variables in this function or where did you have to。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 等于零，对吧。换句话说，现在是我们来访问剩余票的时间。其他人不能在中途修改它。我们将进行修改和检查。如果它恰好是零，那就完成了，没有票可以再去处理了。你有问题吗？那么，这个锁是不是锁住了这个函数中的所有变量，还是你必须在某个地方做其他操作？
- en: then you have to specify the remaining tickets to one model。 Yeah。 Good question。
    The question was。 does lock， lock all the remaining variables？ It's much more
    simple than that。 Lock says。 somebody else is going to want this exact data structure
    or want this critical， piece of code。 I'm going to just basically put the lock
    in here。 Nobody else can access this critical piece of code because they're also
    going to ask。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你必须为一个模型指定剩余的票。是的。好问题。问题是，锁是不是锁住了所有剩余的变量？其实比这简单多了。锁的意思是：别人可能也需要这个确切的数据结构，或者需要这段关键代码。我基本上就是把锁放在这里，没人能访问这段关键代码，因为他们也会请求锁。
- en: for the lock。 Okay。 Anything else， they're going to be doing the same sort of
    thing。 So you have to get your logic right so that you know that， oh， everybody
    who wants this。 critical data structure or in this case remaining tickets， just
    lock around it and then that's。 all we need to do。 Okay。 So what do we have to
    do after the actual while statement here？
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。其他的事情，它们也会做类似的操作。所以你必须把逻辑弄对，这样你才能知道，哦，所有想要这个关键数据结构或者在这个案例中剩余票的人，只需要在它周围加个锁，然后就是这样。我们只需要做这些。好的。那么在实际的
    `while` 语句之后，我们需要做什么呢？
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_170.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_170.png)'
- en: Tickets， lock， unlock。 Right。 So we have to do that if we're going to break
    out an unlock it there and then at that point。 everybody can do it。 We're not
    quite done yet。 You have a question before we go。 So is it that at that point
    they can lock？ None of the threads will run after that。 So all the threads are
    going to eventually get to this line。 And they're going to go。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 票，锁，解锁。对。我们必须这么做，如果我们要在这里跳出并解锁，那么到那时，大家都可以继续操作了。不过我们还没完全结束。在继续之前，你有问题吗？所以在那时，他们可以加锁吗？之后没有线程会再运行吗？所有线程最终都会到达这行代码。然后它们会去。
- en: I want to lock that variable。 One of them is going to win。 All the rest is going
    to wait around until this one finishes。 Okay。 Now this may cause an issue。 We'll
    talk about that。 They're waiting at that。 They're waiting at that lock。 Yep。 They're
    not doing anything。 There's waiting at the lock。 Yep。 Yeah。 Good question。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我想锁定那个变量。最终会有一个线程获胜，其他的线程会等着直到这个线程完成。好的。现在这可能会引发一个问题，我们稍后会讨论。它们在等待那个锁。是的。它们什么都不做。它们在等待那个锁。是的。嗯。好问题。
- en: So specifically because of that break we break out but we're still locked so
    we better unlock。 But as I said we're not quite done yet。 We also want to unlock
    actually let's say I guess we could do it either there or let's。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 所以特别是因为那个 `break`，我们跳出，但我们仍然保持锁定状态，所以最好解锁。不过，正如我所说，我们还没有完全结束。我们还需要解锁。其实我想我们可以在这里做，也可以在其他地方做。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_172.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_172.png)'
- en: say not there。 Let's say we want to lock like unlock right here。 On tickets
    lock unlock like that as well。 Now it will actually work out because what we didn't
    want to do is re-lock try to re-lock。 the lock。 Again you would actually deadlock
    because you've got the hold of the lock and then you try。 to lock it again and
    you're going to wait until you release it and that's impossible。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 说不行。假设我们想在这里锁定，比如解锁。这时会正常工作，因为我们不想做的是重新加锁，尝试重新加锁。再次加锁实际上会导致死锁，因为你已经持有了锁，然后再试着加锁，结果会一直等待直到释放锁，而这是不可能的。
- en: But that's so we do it in two different places in this case。 On next。 I guess
    on Wednesday we will learn about another， we do that or next week。 We will learn
    about another way to do it where you don't need both unlocks。 It's a different。
    actually a very clever piece of code。 We'll learn about that later but that's
    why we do it there。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但是就是这样，我们在这个例子中分别在两个不同的地方做了操作。下次，或者说在周三，我们将学习另外一种方法，这样你就不需要两个解锁了。这是另一种，其实是一个非常巧妙的代码。稍后我们会学习那个方法，但这就是我们在这里这么做的原因。
- en: Okay。 So I believe that is all we need to do at this point to make this now
    safe。 Right？ Question。 >> The original one that calls lock。 Once they call unlock
    the different threads come around and call that lock and when you。 press right。
    >> Yeah。 The question was if once you've got lock when it unlocks another thread
    can come in immediately。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 好。那么，我相信到目前为止，我们所做的就是为了确保这一过程现在是安全的，对吗？问题。 >> 原始的那个调用锁定的。当它解锁时，不同的线程会来调用锁定，然后你按下“对”。
    >> 对。问题是，一旦你获得了锁，在它解锁后，另一个线程可以立即进入吗？
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_174.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_174.png)'
- en: if it's waiting for that lock and then unlock it。 And two or more could be trying
    to do that and one will win。 And the other one will go back and stay locked for
    a while or stay in that position。 There's no race condition。 Well， I mean there
    is a race condition in that they're both looking for it but hopefully。 your lock
    doesn't matter at that point because you're not trying to change something in
    there。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它在等待那个锁，然后解锁。可能有两个或更多的线程正在尝试这样做，而其中一个会赢。另一个则会回去，保持锁定一段时间，或者保持在那个位置。没有竞争条件。嗯，意思是说，虽然它们都在寻找它，但希望你在那时锁定的内容不重要，因为你并没有试图去改变里面的东西。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_176.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_176.png)'
- en: You're not trying to serialize it or so forth。 Okay。 So let's see what happens
    when we do this。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你并没有尝试将其序列化，或者类似的操作。好。那么，看看我们这么做会发生什么。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_178.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_178.png)'
- en: Make confused， ticket， agents。 These are not confused anymore， hopefully。 Let's
    see what happens when we do that。 Confused ticket agents。 Okay。 Now。 what's the
    first thing you notice about this？ >> Slower。 >> Slower。 Right。 So there is an
    issue here because we've now got like every ticket agent is saying， okay。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使得票务代理感到困惑。这些问题希望已经解决了。我们来看看这样做会发生什么。困惑的票务代理。好。现在，你首先注意到什么？ >> 更慢了。 >> 更慢了。对。所以这里有一个问题，因为现在每个票务代理都在说，好。
- en: there's a ticket available。 I am going to go and I'm going to sell it。 Right。
    And then I'm going to decrement the remaining tickets and then I'm going to release
    the， lock。 Okay。 And this， the way what we've created is kind of inherently still
    serialized。 Right。 Now。 there is the break time which is not serialized。 That's
    fine。 I mean。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有票可卖。我将去卖票。对吧。然后我会减少剩余票数，再释放锁。好。这是我们创建的方式，本质上还是序列化的。对。现在。休息时间不是序列化的。那没关系。我的意思是。
- en: we get a little bit of benefit because we don't do the break time。 Anybody can
    be on break at the same time。 They don't fight over the coffee machine or something
    or whatever they need to like。 you know， do on that。 But otherwise it's taking
    a while。 This is taking like over a minute actually to run this now and you think，
    well， that seems。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能获得一点好处，因为我们不需要休息时间。任何人都可以同时休息。它们不会争夺咖啡机或者其他需要做的事。但是否则，这个过程要花很长时间。实际上，现在运行这一过程要超过一分钟，你会想，嗯，这似乎有点……
- en: a little crazy。 Okay。 So is there a way to actually modify this so that we can
    do this and still end up not。 blocking in quite like in a way that makes it so
    that we're slowing things down？ And by the way。 let's make sure， let's see if
    it works。 We're going to get down to zero。 It should be that everybody goes up。
    Okay。 Yay。 We worked。 Right。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有点疯狂。好。那么，是否有办法修改它，使得我们能做到这一点，并且最终不会像现在这样阻塞，导致我们拖慢进程？顺便说一句，我们来确认一下，看看它是否有效。我们将减少到零。应该是每个人都上去。好，耶，成功了，对吧？
- en: Because they all got to a point near the end where they， there were no more
    to be sold。 And by the way， you， let's see， is it saying or no？ They all， they
    all wait。 Notice the tickets are sold。 They actually all happen to wait at the
    same time in that case。 Okay。 And then because or they all ended up that place
    because they were all waiting for that。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们都达到了接近结束的一个点，在那里没有更多的票可卖了。顺便说一下，你，看看，是不是在说，还是没有？它们都，所有人都在等。注意，票已售出。实际上，它们恰好在同一时刻等待。好。然后，因为它们都等，所以最终都到了那个地方。
- en: lock to do that check。 So what do you think？ Can we fix this even to make it
    a little bit faster？
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定以进行检查。那么，你怎么看？我们能否修复这个问题，甚至让它更快一些？
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_180.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_180.png)'
- en: And maybe we have to change our own like understanding of what it means to sell
    a ticket。 Like sometimes you can't get away with that。 All right。 So in this case。
    could we do something here to make it so that this actually works and， faster
    anyway？
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们需要改变自己对卖票这个概念的理解。像是有时候你无法避开这个问题。好吧。那么在这种情况下，我们能做点什么让这个过程更高效吗？
- en: What do you think？ Awesome。 Like put the remaining tickets there and then do。
    I'm going to go this way。
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得怎么样？太棒了。把剩余的票放在那里，然后继续。我要走这条路。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_182.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_182.png)'
- en: This one up here。 Would that work？ I think it would work。 Right？
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里面上面的这个。那能行吗？我觉得可以。对吧？
- en: Now we're assuming that the ticket gets sold。 Right？
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们假设票已经卖出。对吧？
- en: So let's say the ticket agent gets on the phone。 The ticket agent says already
    said， oh。 I've got to say it's sold。 And then let's say that there's some logic
    where the。 I don't want that stupid ticket， airlines terrible to hang up on the
    phone or whatever。 Right？ Well。 they have to somehow put the ticket back and we
    don't have that logic in here， but。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 假设售票员接到电话。售票员已经说过了，“哦，我得说票已经卖完了”。然后假设有些逻辑，比如，“我不想要这张愚蠢的票，航空公司很糟糕，我得挂掉电话。”对吧？嗯，他们必须以某种方式把票退回去，但我们这里没有这部分逻辑。
- en: we could build it in if we， I mean， we， we could build it in。 You could build
    it in somehow where we say， oh， look， if you've got the last ticket， you。 better
    keep trying to sell it。 You've got to stay until it gets sold。 There's something
    like that。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们，呃，我们可以把它构建进去。你可以以某种方式把它构建进去，比如说，“哦，如果你卖的是最后一张票，你最好继续卖下去。你得等它卖掉才行。”之类的。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_184.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_184.png)'
- en: Right？ But I think this will actually， this will actually work。 Let's see。 make
    confused tickets and then， ah， still much faster now。 Right？ Not， not like way，
    way。 way faster， but definitely much faster。 I can say it is much faster。 In fact。
    and this is going a lot faster。 But let's see what happens near the end here。
    See if it still works。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？但我觉得这个其实会起作用。让我们看看。生成混乱的票，然后，啊，速度还是快了很多。对吧？并不是说快得离谱，但绝对更快了。我可以说它快多了。事实上，这个速度确实快了很多。让我们看看接近结尾时会发生什么。看看它是否还会继续工作。
- en: There we go。 Okay。 So it did finish and lots of agents said zero more tickets
    and they let。 they went， home while the other take， agents were still selling。
    Right？ But who cares at that point？
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，事情就这样结束了。许多代理人说没有票了，他们就离开了，回家了，而其他的代理人还在继续卖票。对吧？但在那个时候，谁在乎呢？
- en: We assume that each agent sells their ticket。 Okay？ So that's one way to do
    it。 So what you read。 the takeaway on this is if you can make your logic such
    that you lock。
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个代理人都会卖出他们的票。好吧？这是一种处理方式。那么你明白了，重点是，如果你能让你的逻辑让你进行锁定的话。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_186.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_186.png)'
- en: for a very short amount of time， that's the best way to do it。 Don't try to
    lock around important things like handle call。 It has nothing to do with whether
    or not the ticket itself has been decremented or not。 Now maybe we need more logic
    to put it back if it doesn't get sold and， you know， that's。
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在短短的一段时间内，这是最好的处理方式。不要在处理重要的事情时进行锁定，像是处理电话。它与票是否已被减去无关。现在也许我们需要更多的逻辑来处理票未卖出去的情况，你知道的，事情就是这样。
- en: a different， different program in some sense。 But you do have。 you do want to
    not lock around extended places that don't matter for， that lock。 Don't。 don't
    have the ticket agent say， you can't touch the ticket queue until I'm done， selling
    my ticket。 which is what we just did。 Yeah。 So in that like agent blank sold the
    ticket and there are like multiple of those statements。
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，这是一个不同的程序。但你确实需要，确实想要避免在不重要的地方进行锁定。不要让售票员说，“直到我卖完我的票，你不能碰票队列。”这就是我们刚才做的事。对。所以在那个代理空白的地方卖了票，并且有多个这样的声明。
- en: of like different agents and then the same number of tickets remaining。 Like
    because right now the lock is going to lock into that， you know， a decrement can。
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，不同的代理人，然后剩余的票数保持不变。因为现在的锁会锁住这个地方，你知道的，票数的减少。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_188.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_188.png)'
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_189.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_189.png)'
- en: happen before the print statement happens。 Right。 So like right here it says
    six more tickets to be sold from two different agents。 Is that your concern？ Yeah。
    In case it probably doesn't matter， you'd still have some other。 maybe we should
    have put the， print statement before they're unlocked or something if we wanted
    to。 We could have done that too。 But that's just a print statement in that case。
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印语句发生之前会发生什么？对的。所以像这里说的，从两个不同的代理商出售六张票。那是你的担心吗？是的。如果它可能不重要，你仍然会有其他的。也许如果我们想要的话，应该把打印语句放在它们被解锁之前。我们本来也可以这样做。但在这种情况下，那只是一个打印语句。
- en: We could probably clean that up。 In fact， we can try and see if it makes sense
    for our thing here。 Let's see。 Yeah。 I mean you would have to break it up here
    and say， you know。 put the number of tickets to， be sold up farther and the agents
    sold the ticket below。 You could break that， see out statement up and do that。
    But yeah。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能能清理一下。事实上，我们可以试试，看看它是否适合我们这里的情况。我们看看。是的。我的意思是，你需要在这里拆开，先放置要售出的票数，再把代理商出售票的部分放在下面。你可以把这个
    `see out` 语句拆开来做。不过，是的。
- en: that's another race condition in that sense。 Oh， two people think that there's
    the same amount of tickets left to be sold。 That seems a little odd。 But in the
    end， their logic for the stopping still works out。 But yeah。 that was kind of
    another anomaly that you'd have to fix。 Yeah。 Good question。 Okay。 Is there any
    way to make it near as fast as this won't be written lock at all？
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 那在某种意义上也是另一个竞态条件。哦，两个人认为剩下的票数是一样的。那似乎有点奇怪。但最终，他们停止的逻辑还是有效的。但对，是的。这是另一种你需要修复的异常情况。是的。好问题。好。有没有办法让它像这样快，完全不加锁？
- en: Is it like even that is not as quick as it works？ Is there any way to make it
    near as fast？
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 即使那样，它也不如预期的那么快？有没有办法让它接近这么快？
- en: This is pretty close actually。 I don't know if you remember from before。 It's
    about it。 It's pretty close。 But no， I mean， locking will involve some overhead
    because there is a time where two threads are。 trying to get the same data structure
    or variable and it's going to take more time。 And that's just a， that's a downside
    but a necessary downside of making it so it's functional。
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上很接近了。我不知道你是否还记得之前的内容。这差不多。但不是，我的意思是，加锁会涉及一些开销，因为在某些时刻，两个线程正在试图访问相同的数据结构或变量，而这将花费更多的时间。这就是一个弊端，但也是让它能够正常运行的必要弊端。
- en: So the program works。 But yeah， good question。 Yeah。 What we do do like conditional
    lock boards like the only lock where they're like 10 tickets。 left to the board。
    Yes， good question。 So Sam saying wait， what if。 is there a way to lock when there's
    like a certain number。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 所以程序是可以运行的。但好问题。是的。我们做的类似条件锁的方式就像是唯一锁，在那里像是有10张票剩下。是的，好问题。那么萨姆说，等等，如果是，是否有一种方法可以在剩下某个特定数量时加锁？
- en: of tickets left or something so that more people can go in and tell that there
    is， they're。 called conditional variables actually。 And there's also another one
    that will build ourselves called a semaphore which does that。 It allows you to
    basically have a count in which case you only lock when that count ends。 up at
    zero。 And then before then anybody can go in and grab as many as they can grab
    one until that。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的票数或者其他类似的东西，这样更多的人可以进入并告诉他们，那些被称为条件变量。实际上还有另外一种方法，我们会自己构建一个叫做信号量的方法来做这件事。它允许你基本上有一个计数器，在这个计数器为零时，你才会加锁。然后在那之前，任何人都可以进入并尽可能多地抓取票，直到计数为零。
- en: count becomes zero。 Good。 Good point。 We'll get there。 Good question。 Yeah。
    Could you explain to you how the lock calls inside the lock is slower？ Yeah， good
    question。 Well。 why is handle when handle call was inside the lock， why is it
    slower？ Well， handle call does what？
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 计数变为零。很好。好问题。我们会讨论到的。好问题。是的。你能解释一下为什么锁内的锁调用会更慢吗？是的，好问题。为什么，为什么当 `handle call`
    在锁内被调用时，会更慢？那么，`handle call` 做了什么？
- en: It just is asleep。 Right。 And if all the， if you have not unlocked yet by the
    time when handle call gets called。 everybody， else is standing or looking at that
    one ticket agent trying to sell the ticket because they。 can't get into the to
    modify it。 Right。 So there's where the inherent like slowness happened before。
    Every ticket agent was on and on their own selling a ticket with all the other
    ones waiting。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是处于睡眠状态，对吧？如果你在 `handle call` 被调用时还没有解锁的话。每个人，其他人都在站着看那个售票代理，试图卖票，因为他们无法进入去修改它。对吧？所以这里就是之前内在的慢速发生的地方。每个售票代理都是独立的，在卖票，而其他人都在等着。
- en: around going， I can't even sell a ticket because I can't even get out the thing。
    So our model wasn't perfect in that sense。 Right。 But knowing that a ticket's
    always sold makes it so we can do it。 Okay。 Other questions on this？ All right。
    Threading is kind of fun stuff。 but you can see lots of issues。 We will get to
    many more different types of locks as we go along。
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕着进行，我连票都卖不出去，因为我甚至无法把东西拿出来。所以从这个意义上来说，我们的模型并不完美。对吧。但知道票总是能卖出去，这样就使我们能够做到这一点。好的，关于这个有其他问题吗？好的。线程是有点有趣的东西，但你可以看到很多问题。随着我们继续前进，我们将接触到更多不同类型的锁。
- en: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_191.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f93b0bc9a9d8e944eb7fb7dd38f262_191.png)'
- en: All right。 I will see you Wednesday。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我周三见。
