# 课程 P21：第20讲 非阻塞I/O 🚀

在本节课中，我们将学习非阻塞I/O的概念。我们将探讨它与传统阻塞I/O的区别，了解其工作原理，并通过示例理解为何以及如何在特定场景下使用它来提升程序效率。

---

## 概述

到目前为止，我们讨论的I/O操作通常是阻塞的。这意味着当程序执行读写操作时，系统调用会一直等待，直到收到响应或数据才返回。这可能导致程序在等待I/O时无所事事，浪费了宝贵的CPU时间。

本节我们将介绍非阻塞I/O。在这种模式下，I/O调用会立即返回，无论数据是否就绪。如果数据未就绪，调用会返回一个特定的错误码，而不是让程序无限期等待。这允许程序在等待I/O的同时，继续执行其他有用的工作。

---

## I/O密集型与CPU密集型

![](img/969edac52273f03a794226a015ab0a12_1.png)

在深入非阻塞I/O之前，我们需要理解两个关键概念：**I/O密集型**和**CPU密集型**。

*   **I/O密集型**：指程序花费大量时间等待输入/输出操作完成（如网络请求、磁盘读写）。在此期间，CPU可能处于空闲状态。
*   **CPU密集型**：指程序花费大量时间进行计算和处理，CPU持续处于忙碌状态。

![](img/969edac52273f03a794226a015ab0a12_3.png)

一个程序可能在某些阶段是I/O密集型的，在另一些阶段是CPU密集型的。理解这一点有助于我们选择合适的并发模型来优化程序性能。

![](img/969edac52273f03a794226a015ab0a12_5.png)

---

![](img/969edac52273f03a794226a015ab0a12_7.png)

## 快速与慢速系统调用

系统调用也可以根据其等待行为进行分类。

![](img/969edac52273f03a794226a015ab0a12_9.png)

*   **快速系统调用**：调用会立即返回，不依赖于外部资源。例如，获取主机名的系统调用 `gethostname()`。
    ```c
    // 示例：快速系统调用
    gethostname(hostname, size);
    ```
*   **慢速系统调用**：调用可能无限期阻塞，直到某个外部事件发生。例如，从网络套接字读取数据 `read()`，或等待子进程结束 `waitpid()`。
    ```c
    // 示例：可能阻塞的慢速系统调用
    bytes_read = read(socket_fd, buffer, size);
    ```

![](img/969edac52273f03a794226a015ab0a12_11.png)

![](img/969edac52273f03a794226a015ab0a12_12.png)

![](img/969edac52273f03a794226a015ab0a12_14.png)

我们之前通过多线程来处理慢速系统调用，使得一个线程被阻塞时，其他线程可以继续工作。非阻塞I/O提供了另一种解决方案。

![](img/969edac52273f03a794226a015ab0a12_15.png)

![](img/969edac52273f03a794226a015ab0a12_17.png)

![](img/969edac52273f03a794226a015ab0a12_18.png)

---

![](img/969edac52273f03a794226a015ab0a12_20.png)

![](img/969edac52273f03a794226a015ab0a12_22.png)

## 非阻塞I/O的工作原理

![](img/969edac52273f03a794226a015ab0a12_24.png)

![](img/969edac52273f03a794226a015ab0a12_26.png)

![](img/969edac52273f03a794226a015ab0a12_28.png)

非阻塞I/O的核心思想是：**让慢速系统调用不再阻塞**。

![](img/969edac52273f03a794226a015ab0a12_30.png)

我们可以通过系统调用（如 `fcntl`）将一个文件描述符（如套接字）设置为非阻塞模式。

![](img/969edac52273f03a794226a015ab0a12_32.png)

![](img/969edac52273f03a794226a015ab0a12_34.png)

```c
// 将文件描述符 fd 设置为非阻塞模式
int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);
```

![](img/969edac52273f03a794226a015ab0a12_36.png)

![](img/969edac52273f03a794226a015ab0a12_37.png)

![](img/969edac52273f03a794226a015ab0a12_39.png)

设置之后，对该描述符的 `read`, `write`, `accept` 等调用行为会发生变化：

*   如果数据已就绪（或连接已到达），调用正常返回数据。
*   如果数据未就绪，调用**立即返回-1**，并将全局变量 `errno` 设置为 `EAGAIN` 或 `EWOULDBLOCK`（表示“本应阻塞”）。

![](img/969edac52273f03a794226a015ab0a12_41.png)

![](img/969edac52273f03a794226a015ab0a12_43.png)

![](img/969edac52273f03a794226a015ab0a12_44.png)

程序需要检查返回值：
*   若返回值 `> 0`：成功读取/写入了数据。
*   若返回值 `== 0`：通常表示到达文件末尾（对端关闭连接）。
*   若返回值 `== -1`：需要检查 `errno`。
    *   如果 `errno == EAGAIN` 或 `errno == EWOULDBLOCK`，表示暂时没有数据，应稍后重试。
    *   否则，表示发生了真正的错误。

![](img/969edac52273f03a794226a015ab0a12_46.png)

---

![](img/969edac52273f03a794226a015ab0a12_48.png)

![](img/969edac52273f03a794226a015ab0a12_50.png)

![](img/969edac52273f03a794226a015ab0a12_51.png)

## 示例：慢速字母服务器与客户端

为了演示阻塞与非阻塞的区别，我们来看一个“慢速字母服务器”的例子。

![](img/969edac52273f03a794226a015ab0a12_53.png)

上一节我们介绍了系统调用的分类，本节中我们来看看一个具体的阻塞I/O例子及其问题。

![](img/969edac52273f03a794226a015ab0a12_55.png)

### 服务器行为
服务器接受连接后，会以每次一个字母、每个字母间隔0.1秒的速度，向客户端发送26个英文字母。整个发送过程需要2.6秒，人为制造了I/O延迟。

![](img/969edac52273f03a794226a015ab0a12_57.png)

### 初始的阻塞客户端
客户端使用阻塞模式读取数据，每次读取一个字节。

![](img/969edac52273f03a794226a015ab0a12_59.png)

![](img/969edac52273f03a794226a015ab0a12_61.png)

![](img/969edac52273f03a794226a015ab0a12_63.png)

![](img/969edac52273f03a794226a015ab0a12_65.png)

```c
// 伪代码：阻塞客户端
while ((count = read(sock_fd, &ch, 1)) > 0) {
    printf(“%c”, ch);
}
```

![](img/969edac52273f03a794226a015ab0a12_66.png)

![](img/969edac52273f03a794226a015ab0a12_68.png)

![](img/969edac52273f03a794226a015ab0a12_70.png)

![](img/969edac52273f03a794226a015ab0a12_72.png)

**运行结果**：客户端耗时约2.6秒完成读取，期间主线程被 `read` 调用完全阻塞，无法进行任何其他操作。

![](img/969edac52273f03a794226a015ab0a12_74.png)

---

![](img/969edac52273f03a794226a015ab0a12_76.png)

## 改进：非阻塞客户端

![](img/969edac52273f03a794226a015ab0a12_78.png)

现在，我们将客户端修改为非阻塞模式。

![](img/969edac52273f03a794226a015ab0a12_80.png)

![](img/969edac52273f03a794226a015ab0a12_82.png)

![](img/969edac52273f03a794226a015ab0a12_84.png)

以下是修改的核心逻辑：

![](img/969edac52273f03a794226a015ab0a12_86.png)

![](img/969edac52273f03a794226a015ab0a12_88.png)

```c
// 伪代码：非阻塞客户端核心循环
set_nonblocking(sock_fd); // 将套接字设置为非阻塞

![](img/969edac52273f03a794226a015ab0a12_90.png)

![](img/969edac52273f03a794226a015ab0a12_92.png)

![](img/969edac52273f03a794226a015ab0a12_94.png)

while (!done) {
    count = read(sock_fd, &ch, 1);
    if (count > 0) {
        printf(“%c”, ch); // 成功读取到数据，处理它
        if (ch == ‘Z’) done = true; // 假设收到‘Z’表示结束
    } else if (count == 0) {
        // 对端关闭连接
        done = true;
    } else { // count == -1
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            // 没有数据可读，可以在这里执行其他任务
            do_other_work();
            // 然后继续循环，尝试再次读取
        } else {
            // 发生真实错误，处理错误
            handle_real_error();
            done = true;
        }
    }
}
```

![](img/969edac52273f03a794226a015ab0a12_96.png)

![](img/969edac52273f03a794226a015ab0a12_98.png)

![](img/969edac52273f03a794226a015ab0a12_100.png)

![](img/969edac52273f03a794226a015ab0a12_102.png)

**运行结果**：客户端仍然需要2.6秒来接收所有字母，但在这段时间内，`do_other_work()` 函数被调用了数百万次。这意味着主线程在等待数据的间隙，可以高效地处理其他任务，而不是被挂起。

![](img/969edac52273f03a794226a015ab0a12_104.png)

![](img/969edac52273f03a794226a015ab0a12_106.png)

**关键点**：非阻塞I/O将等待的“空闲时间”还给了程序本身，让程序有机会执行其他计算（CPU密集型工作），从而可能提高整体吞吐量。

![](img/969edac52273f03a794226a015ab0a12_108.png)

![](img/969edac52273f03a794226a015ab0a12_110.png)

---

## 事件驱动模型与 `epoll`

![](img/969edac52273f03a794226a015ab0a12_112.png)

简单的非阻塞I/O循环（忙等待）有一个明显缺点：如果大部分时间都没有数据，循环会空转，消耗大量CPU资源，变成“忙等待”，这显然不高效。

![](img/969edac52273f03a794226a015ab0a12_114.png)

为了解决这个问题，操作系统提供了更高级的机制，如Linux的 `epoll`。它允许程序**同时监视多个文件描述符**，并只在它们真正有事件（如可读、可写）发生时才被唤醒。

![](img/969edac52273f03a794226a015ab0a12_116.png)

![](img/969edac52273f03a794226a015ab0a12_118.png)

以下是使用 `epoll` 的基本步骤：

![](img/969edac52273f03a794226a015ab0a12_120.png)

![](img/969edac52273f03a794226a015ab0a12_122.png)

1.  **创建 epoll 实例**：`epoll_create1(0)` 返回一个文件描述符。
2.  **注册感兴趣的事件**：使用 `epoll_ctl` 将需要监视的文件描述符（如监听套接字、客户端连接套接字）添加到 epoll 实例中，并指定关心的事件类型（如 `EPOLLIN` 可读）。
3.  **等待事件**：调用 `epoll_wait`。这个调用会**阻塞**，直到一个或多个被监视的描述符上有事件发生，或者超时。
4.  **处理事件**：`epoll_wait` 返回后，程序遍历发生的事件，执行相应的读/写/接受连接操作。

![](img/969edac52273f03a794226a015ab0a12_124.png)

![](img/969edac52273f03a794226a015ab0a12_126.png)

这种模式被称为**事件驱动模型**。它结合了非阻塞I/O的效率和多路复用的优雅，是现代高性能服务器（如Nginx、Node.js）的基石。

```c
// 伪代码：epoll 事件循环框架
int epoll_fd = epoll_create1(0);
// ... 将 server_fd 等加入 epoll 监视 ...

while (1) {
    int n_ready = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    for (int i = 0; i < n_ready; i++) {
        if (events[i].data.fd == server_fd) {
            // 有新连接到达，接受它
            accept_new_connection(server_fd, epoll_fd);
        } else {
            // 某个客户端连接有数据可读或可写
            handle_client_event(events[i].data.fd, events[i].events);
        }
    }
}
```

使用 `epoll` 后，服务器在无事可做时会安静地阻塞在 `epoll_wait` 上，不消耗CPU。当事件发生时，内核会通知它，它再以非阻塞的方式处理这些事件。这完美避免了忙等待，同时保持了高并发处理能力。

![](img/969edac52273f03a794226a015ab0a12_128.png)

![](img/969edac52273f03a794226a015ab0a12_130.png)

![](img/969edac52273f03a794226a015ab0a12_132.png)

---

![](img/969edac52273f03a794226a015ab0a12_134.png)

![](img/969edac52273f03a794226a015ab0a12_136.png)

## 总结

本节课中我们一起学习了非阻塞I/O的核心概念。

我们首先区分了**I/O密集型**和**CPU密集型**任务，以及**快速**和**慢速**系统调用。然后，我们探讨了通过 `fcntl` 设置非阻塞模式，使慢速调用立即返回的基本方法，并通过“慢速字母客户端”的例子对比了阻塞与非阻塞模式的行为差异。

最后，我们介绍了更高级的**事件驱动模型**和Linux的 `epoll` 机制。这种模型允许单个线程高效地管理成千上万的并发连接，是现代高性能网络编程的关键技术。

选择阻塞I/O、多线程还是事件驱动非阻塞I/O，取决于具体的应用场景、性能要求和系统平台。理解这些底层原理，将帮助你在未来构建更高效、更健壮的系统。