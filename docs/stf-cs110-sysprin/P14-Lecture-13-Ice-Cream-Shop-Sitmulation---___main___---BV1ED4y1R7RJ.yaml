- en: P14：Lecture 13 Ice Cream Shop Sitmulation - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P14：讲座13 冰激凌店模拟 - ___main___ - BV1ED4y1R7RJ
- en: Okay， so we are starting out today。 Today is one problem。 Hopefully you've got
    the handout。 If you happen to break up here， I made plenty of them。 There's one
    program we're going to look at today and it is going to model。 Where did it go
    here？
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，今天我们开始了。今天有一个问题。希望你们已经拿到了讲义。如果你们有问题，我准备了很多份。今天我们要看一个程序，它将会模拟。它在哪里？
- en: It is modeling the ice cream shop。 We're actually going to try something live
    in person demo with people。 We have now opened up an ice cream shop。 I'm sorry
    for people watching the video。 You're going to not see the chaos that's about
    to ensue。 Here's what I need。 I need 11 volunteers or conscripts。 Come on up。
    First three people get their big customers。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模拟冰激凌店的场景。实际上，我们要进行一次真人示范。我们现在开了一家冰激凌店。抱歉视频前的观众，你们看不到即将发生的混乱。接下来我需要的是11个志愿者或者征召人员。来吧，前三位来做大客户。
- en: Which means you get ice cream if you actually buy ice cream。 Alright， let's
    see。 Okay， one， two。 three。 There we go。 Other people， the next people， you get
    to be a clerk。 Somebody gets to be the manager and somebody gets to be a cashier。
    I think there's a couple of clerks。 Anybody else who is up here？ There we go。
    Okay。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你真的买了冰激凌，你就能拿到冰激凌。好，看看。好的，一，二，三。好了。其他人，接下来的人，你们将成为服务员。有人将会是经理，还有人将会是收银员。我觉得有几个服务员。还有其他人上来吗？好的。
- en: thank you very much。 Clerks， go over in this corner over here。 Oh， and by the
    way。 everybody grab one of these too which is your instruction manual。 Okay。 there
    should be enough for everybody。 Okay， here's what we're doing。 We're going to
    model an ice cream shop。 Now what we're actually doing is we're modeling a problem
    that was given a believer in a lot of CS107 finally banned from many years ago
    when multi-processing and threading with the ANSES-1 upset。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢你们。服务员们，请到这边来。哦，顺便说一下，每个人也拿一本，这是你们的操作手册。好的，应该每个人都有一份。好了，接下来我们要做的事情是模拟一个冰激凌店。实际上，我们要模拟的是一个问题，这个问题曾经在很久以前的
    CS107 课程中提出，当时多处理和线程处理的问题让 ANSES-1 出现了麻烦。
- en: It used to be。 We've changed things since then。 Okay， but here's what we're
    doing。 Alright。 we are setting it up。 So where's our manager？ Please， okay， you're
    the manager。 You're going to be。 you're going to be， people are going to fight
    over you actually as it turns out。 Okay。 and where's our cashier？ You're going
    to kind of come in near the end。 Okay， but you have。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以前是这样做的。我们从那时开始已经做了些调整。好吧，接下来我们要做的事情是这样。我们正在设置。经理在哪里？请过来，好，你是经理。你将会是……实际上，大家会为你争夺职位。好，收银员在哪里？你差不多要在最后出现。好，明白了，你有。
- en: there's a little number system here。 So the one， two， three， they， people will。
    the customers will take the number in order。 So I've got numbers。 We have ice
    cream cons。 Okay。 and we have lots of， who are the customers？ Customers over here？
    Okay。 So here's the way this works。 Alright， we're modeling this with only three
    customers。 Okay， a customer does the following。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小小的编号系统。所以1，2，3号，他们，顾客将按顺序取号。我这里有编号，我们有冰激凌甜筒。好的，谁是顾客？顾客在这里吗？好的。现在这是怎么运作的。好，我们现在只用三位顾客来模拟。一个顾客的操作是这样的。
- en: Customer comes into our ice cream shop and says， "I want X number of cones。"
    And you have how many cones you want on there。 Okay。 so they're going to come
    in and they're going to say X number of cones。 And what they're going to do is
    because they want to get their cones quickly。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 客户进入我们的冰激凌店，告诉你，“我要 X 个冰激凌甜筒。”然后你会知道他们需要多少个甜筒。好的，他们会进来，说要 X 个甜筒。因为他们想尽快拿到自己的甜筒。
- en: or at least as quickly as they can， they're going to grab a clerk。 For some
    reason。 we have as many clerks as ice cream cons that are going to be delivered
    that day。 And each clerk gets to make one perfect ice cream cone。 In fact。 each
    clerk can try to make an ice cream cone perfect。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 或者至少尽可能快，他们会去找一个服务员。出于某种原因，我们的服务员数量和当天要送出的冰激凌甜筒数量相同。每个服务员负责做一个完美的冰激凌甜筒。事实上，每个服务员只能尽力做出一个完美的冰激凌甜筒。
- en: but the manager is going to keep them honest if it turns out to be terrible。
    I used to have a friend who， he worked in an ice cream shop and he and a buddy
    of his used to have a competition to see who could make the smallest scoop without
    somebody complaining。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是经理会保持公正，如果结果糟糕的话。我曾经有个朋友，他曾在一家冰淇淋店工作，他和他的朋友常常比赛，看看谁能做出最小的冰淇淋球，而不被人抱怨。
- en: Which is really a mean thing。 You know the tiny little scoop and you're like，
    "Oh。 I'm just too nice not to complain。"， Anyway， you don't get to do that。 You'll
    actually have more or less determinants。 It's a random thing。 but it's deterministic
    as far as the ice cream cons go。 Okay。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是一件很刻薄的事。你知道那个小小的勺子，你就会想，“哦，我就是太好心，不忍心抱怨。” 不管怎样，你是不能这么做的。你实际上会有更多或更少的决定因素。这是随机的，但在冰淇淋蛋筒上是确定的。好的。
- en: so they look at me and they will grab a clerk。 For the number of clerks for
    each ice cream cone。 Okay， each clerk will then actually make the clerks walk
    all the way over this table to grab an ice cream cone。 This is going to be a time
    thing。 There's going to be ice cream cones over there that you're going to make。
    When you may have made an ice cream cone， you're going to walk back and you're
    going to present it to the manager。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以他们看着我，然后他们会拉一个店员。每个冰淇淋蛋筒需要的店员数量。好的，每个店员然后会实际让其他店员走到桌子那边去拿一个冰淇淋蛋筒。这是一个时间上的问题。那里会有冰淇淋蛋筒，你将要制作。当你做完一个冰淇淋蛋筒时，你要走回来并呈交给经理。
- en: Okay， and by the way， you are milling around at this point， waiting for your
    ice cream cones。 You're not getting in the way。 You're just kind of waiting for
    your ice cream cones。 When you have created an ice cream cone that you think is
    perfect， in other words。 you have grabbed one， you're going to bring it back to
    the manager。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，顺便说一下，在这个时候，你会在四周走动，等待你的冰淇淋蛋筒。你并不会挡路，你只是等着你的冰淇淋蛋筒。当你做出了一个你认为完美的冰淇淋蛋筒，换句话说，你已经拿了一个，你要把它带回给经理。
- en: And if there are two of you who are kind of going towards the manager at the
    same time。 you get to fight over who gives it to the manager。 Okay。 now you don't
    really need to participate in this fight。 Just basically grab one。 And， you know。
    whoever you want， it's your kind of choice in that case。 Okay， and then the manager。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个人同时向经理走去，你们可以争夺谁把蛋筒交给经理。好的，现在你并不需要真正参与这场争斗。基本上随便拿一个，知道吗，谁先拿就给谁，反正那是你的选择。好的，然后经理。
- en: you are going to decide whether or not is a good ice cream cone。 Don't tell
    the clerks that you're not that。 The "e" means bad， the "g" means good。 Oh， nice。
    Don't tell the clerks this。 Okay， so anyway， and then you're going to either tell
    them， "Yes。 that was a beautiful ice cream cone。 In which case， you are going
    to say。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你要决定这个冰淇淋蛋筒是否好。不要告诉店员你不喜欢。 "e" 代表不好，"g" 代表好。哦，好极了。不要告诉店员这些。好的，反正，然后你要么告诉他们，“是的，那是一个美丽的冰淇淋蛋筒。”
    在这种情况下，你要说。
- en: '"Now I have made one of my six ice cream cones that I have to make today。"，
    Okay。 once you have made it， you might want to keep track。 You can say， "I''m
    going to make six。 and you can say five， and four。 Once you make all six days
    that are good， or that you have approved。 you get to go home for the day。"， Okay，
    all right。 Clerks， if the manager says， "No。'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在我已经做了今天必须做的六个冰淇淋蛋筒中的一个。" 好的，一旦你做好了，可能你会想要跟踪一下进度。你可以说，“我要做六个”，然后你可以说五个，四个。当你做完所有六个，且它们都合格，或者你已经批准过的，你就可以回家了。”
    好的，好的。店员们，如果经理说，“不行。”'
- en: that wasn't a good cone，" you have to throw that cone away。 just throw it around
    the floor wherever you want， go get another cone。 and come back and fight again。
    Okay， for the manager's attention。 Okay。 customers are just waiting around。 Now，
    if the manager says， "This is a great cone， perfectly fine。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是一个好蛋筒，"你必须把那个蛋筒扔掉，随便扔在地上任何地方，然后去拿另一个蛋筒，回来继续挑战。好的，为了引起经理的注意。好的，顾客们正在等着。现在，如果经理说，“这是一个很棒的蛋筒，完全没问题。”
- en: '" you can go deliver it to the customer and then you get to go home。 Okay，
    all right。 And now。 once you get all three of your cones back， you come take a
    number， okay。 and the cashier is waiting for somebody to take care of。 Okay， now。
    the minute you see somebody take a number， you can go， "Oh， I''ll take number
    one。"。'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"你可以把它交给顾客，然后你就可以回家了。" 好的，好的。现在，一旦你拿到所有三个蛋筒，你来拿个号码，好吗？收银员在等着有人处理。好的，现在，一旦你看到有人拿了号码，你就可以说，“哦，我拿一号。”'
- en: And then take as much time as you want， checking them out。 Make sure they pay
    you in the right。 whatever you want。 All right， but you have to check them out。
    Once you check them out。 you get to mark off， but you have checked off one， customer。
    You have to check off three customers。 then you get to go home。 Okay， all right。
    And then， customers， when she's checked you out。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，花你们想花的时间，结账时，确保顾客付对钱。无论他们想要什么。好了，但你必须帮他们结账。一旦结账完成，你就可以标记一位顾客。你必须结账三位顾客，然后你才能回家。好，好的。然后，顾客们，当她帮你结账时。
- en: you can then take your ice cream and go home。 Okay， at the end of that。 you
    should have however many ice cream comes you get。 Now， does everybody。 that was
    a lot of stuff all at once。 Okay， you have your own instructions here。 Okay， in
    fact。 I will pull up the instruction so that everybody can kind of see what's
    going on。 Let's see。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以拿着冰淇淋回家。好吧，在那之后，你应该拿到多少个冰淇淋就有多少个。现在，大家都明白了吗？那真的是一大堆东西，一下子说完了。好吧，你们手里有自己的指令。好，实际上，我会调出指令，让大家看看发生了什么。让我们看看。
- en: I'm going to do this。 I'm going to pull this up。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我要这么做。我会把它调出来。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_1.png)'
- en: Here it should be here， and then ice cream details。 There we go。 And if this
    pulls up correctly。 we should do that。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该是这里，然后是冰淇淋的详细信息。好了。如果这能正确加载，我们就应该执行那个步骤。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_3.png)'
- en: And there we go， hold on， not now。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后好了，等一下，现在不行。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_5.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_5.png)'
- en: And here are the instructions。 I will make this as big as I can。 And there we
    go。 Okay。 So。 I know there's a lot there， but you can kind of see what's happening，
    right？
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是指令。我会尽量把它放大。好了。那么，虽然这里有很多内容，但你大概能看到发生了什么，对吧？
- en: The customer grabs an ice cream cone， grabs a clerk price cream cone， mills
    around。 the clerks do their thing。 When the customer gets back the ice cream cones，
    they go to the cashier。 take a number， et cetera。 Everybody get what's going on
    more or less？ I mean。 it might look a little crazy。 Let's see if we can make this
    happen without， no real fights， please。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 顾客拿着冰淇淋筒，拿着冰淇淋筒去找店员，四处走动。店员做他们的事。当顾客拿回冰淇淋筒时，他们去收银台，拿一个号码，等等。大家大概明白发生了什么吗？我意思是，这可能看起来有点疯狂。让我们看看能不能在没有真正争吵的情况下完成这个。
- en: But you can see what happens。 Okay。 So， customers。 come on into the shop as
    much as whatever you want。 Okay。 And go buy your business。 Okay。 Clerk's over
    there。 All right。 I will now， I will marry for the people listening on the video。
    We are the ice cream cone customers are asking the clerks， they're grabbing the
    clerk。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以看到会发生什么。好吧。那么，顾客们。尽情进店，做你们想做的事。好，去做你们的事情。好，店员在那边。好了，我现在要为视频中的听众做点说明。我们是冰淇淋筒的顾客正在问店员，他们在抓住店员。
- en: A clerk is going over for the ice cream cone。 Clerk goes to the manager and
    says。 is that a good con？ Yes， it is。 It's a good con。 All right。 So。 we got a
    good con and you give it back there。 Okay。 And then now there's some people milling
    around。 but there's a little， oh， a bad con。 We got a bad con in there。 Okay。
    That is a good con。 Okay。 So。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一位店员走过去拿冰淇淋筒。店员走到经理那里，说：“这是一个好筒吗？”“是的，这是一个好筒。”好的。所以，我们得到了一个好筒，你把它还给那边。好了。然后现在有些人在四处游荡，但有一点，哦，坏筒。我们有一个坏筒在里面。好，这是一个好筒。好吧。所以。
- en: you can see there might be a little bit of a bottleneck here。 This is a little
    bit less than that。 Oh， no。 We got more bad con。 Okay。 Oh， bad con。 Okay。 No。
    You got a good con？ That was a good con。 Okay。 Okay。 Okay。 All right。 So， all
    right。 So， then the， has the cashier had anything to do yet？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里可能会有一点瓶颈。这里有点不太顺畅。哦，不，我们又有了坏筒。好，坏筒。好的。你有一个好筒吗？这是一个好筒。好的。好的。好了。所以，好的。那么，收银员有没有做什么事情呢？
- en: One person。 Okay。 And so， you have gotten all your cons。 Do you have just one
    con？ Yes。 Just one con。 Okay。 All right。 And so， you get to take a number。 Okay。
    That's a good con。 All right。 And let's see。 Two。 There's number two。 Okay。 So，
    one person is still waiting for the cons。 And have you done all six cons？ I said
    all six。 Okay。 You can go home。 All right。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人。好，看来你已经拿到了所有的冰淇淋筒。你只拿了一个筒吗？是的。只拿了一个筒。好。然后，你可以拿个号码。好的，这是一个好的冰淇淋筒。好了。让我们看看。二号。二号来了。好。一个人还在等冰淇淋筒。你拿了所有六个筒吗？我说的是六个。好了。你可以回家了。好的。
- en: Manage your just to go home for the day。 Clerk， so。 if you take and grab all
    your cons to this point， yeah， you're going to all go home。 You're great。 Good
    to go。 Now we have that and you have now taken care。 Okay。 And the cashier is
    the last one to go home。 Sadly。 But， but that's that。 Okay。 And you're all done。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 经理就是这样结束一天的工作。店员也是。如果你把到目前为止所有的冰淇淋都抓到手了，是的，你们都可以回家了。你们都很好，准备好走了。现在我们就这么做，工作完成了。好的。而且收银员是最后一个回家的。可惜。但是，就这样了。好的，你们都完成了。
- en: And you got your cons。 Okay。 Now， that was a bit of a melee up here， right？
    No fights。 I didn't see any real fights。 But did you kind of see that this is
    the thing we're about to try to model all of that madness in one program？
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你得到了你的冰淇淋。好的。现在，这里稍微有点混乱，对吧？没有打架。我没看到任何真正的打架。但是你们是不是看到这是我们即将尝试在一个程序中建模的那些混乱？
- en: Okay。 That's what we're trying to model here。 And you have the program and there's
    a lot to it。 But we can we'll go through it one little part at a time。 Okay。 So
    questions on what happened up here。 Did anybody see anything that was odd or didn't
    get or whatever？
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这就是我们试图在这里建模的内容。你有程序，而且内容很多。但是我们可以一小部分一小部分地进行。好的。那么关于上面发生的事情有什么问题吗？有人看到什么奇怪的地方，或者没搞明白的地方吗？
- en: Getting quite figure out what was happening。 That's okay。 Yes。 Okay。 So a customer
    asks one person and then they all wait。 Like。 because like technically only one
    degree you get like a message and then all of them wait for them。 Yeah。 So okay。
    Okay。 Well， first good question was look I'm confused on like the mechanics of
    how this is going to work like programming wise like getting it。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有点弄不清楚发生了什么事情。没关系。是的。好的。所以一个顾客问一个人，然后他们都等着。就像，因为技术上只有一个“线程”可以收到信息，然后所有人都等着。是的。好的。好的。那么，第一个好问题是，看看，我对它是怎么工作的，像编程方面，如何运行，我有些困惑。
- en: So it was all happening kind of in parallel。 Each customer was able to ask for
    however many cons by telling a clerk one clerk at a time。 please make me a con。
    And that was what was happening。 So one customer went to a clerk and said make
    me a con。 And for some reason we had a number of clerks one per cone， which is
    a weird model。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一切都发生得有点并行。每个顾客都可以通过告诉一个店员一次一个店员来要求制作任意数量的冰淇淋。那就是发生的事情。所以有一个顾客去找一个店员，说做一个冰淇淋。出于某种原因，我们有很多店员，每个冰淇淋一个店员，这个模型有点奇怪。
- en: So I will grant you that this model of an ice cream store is a little bit weird
    and probably wouldn't work in real life。 And you could certainly make it better。
    But that's the model one person who wants any number of cones goes to any number
    of clerks and says make me one con。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我承认这个冰淇淋店的模型有点奇怪，可能在现实生活中行不通。你当然可以让它更好。但是这就是模型——一个想要任何数量冰淇淋的人，去找任何数量的店员，告诉他们做一个冰淇淋。
- en: And then they go and ask the manager and the manager is saying that good cone
    bad cone and the clerk has to keep making cones until they get a good cone。 Emma，
    you probably made three cones or ever before you got a good one or whatever。 Right。
    So I thought I'm going to come back and forth a couple times and scowl on her
    face with a number of cones she was making。 And then the cashier had to get the
    now notice that the clerks were kind of fighting with each other for the manager's
    attention。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们去找经理，经理说这个是好冰淇淋，那个是坏冰淇淋，而店员必须继续制作冰淇淋，直到做出一个好的冰淇淋。Emma，你可能做了三次冰淇淋，或者其他任何的尝试，直到做出一个好的冰淇淋，对吧？所以我觉得她应该是来回走了几次，脸上带着皱眉，手里拿着几份冰淇淋。然后收银员必须处理。而注意到，店员们似乎在争抢经理的注意力。
- en: Fine。 The customers were not fighting for the cashier's attention and you probably
    want it that way。 Like even in a real ice cream store， you'd rather have the customers
    go when they get up to the line go on next and then they get handled next。 As
    far as the clerks and the manager go well they could kind of all mill around until
    one gets to decide。 Okay。 Do we see the kind of basic idea though of this？ Okay。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。顾客们没有争抢收银员的注意力，你可能希望是这样的情况。就像在一家真正的冰淇淋店，你会希望顾客排到队后，轮流处理，接着一个接一个地被处理。至于店员和经理嘛，他们可以稍微等待，直到有一个人做出决定。好的。我们是否看到了这个基本的想法呢？好的。
- en: Now we're going to try to model it using threading techniques that we hopefully
    kind of understand now but we will go through them。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试使用线程技术来建模，希望我们现在已经有了一些理解，但我们将一步步地走过这些技术。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_7.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_7.png)'
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_8.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_8.png)'
- en: Okay。 We're actually going to go through five different types of things here
    with this program。 It is kind of a meaty program。 I can't really imagine how it
    ended up as a one final exam problem。 Maybe it was two but but anyway that's the
    way it goes。 We're going to talk about a binary lock which should be at this point。
    Hey do a mutex。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们实际上会在这个程序中讲解五种不同类型的东西。这是一个比较有分量的程序。我真不敢想象它怎么会成为一题期末考试题。也许是两题，但无论如何就是这样。我们要讨论的是一个二进制锁，到目前为止，嘿，做一个互斥锁。
- en: Just going to be a binary lock。 We're going to do a generalized counter。 That
    should be thinking maybe semaphore。 You should be thinking about that。 A binary
    rendezvous。 A binary rendezvous is when basically well we'll get to it but it's
    two two threads trying to coordinate between each other。 Like for instance a clerk
    and a manager trying to make a decision like hey the clerk has to wait for the
    manager to tell them whether the cones good or not and the manager has to wait
    for the clerks to come over and so forth。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就是一个二进制锁。我们要做一个广义计数器。你应该在想，也许是信号量。你应该想到这一点。一个二进制会合。二进制会合基本上是，当两个线程试图协调时。比如说，一个店员和一个经理试图做决策，比如店员必须等经理告诉他们冰淇淋是否好，而经理必须等店员过来等等。
- en: So that's going to be something we're going to do。 A generalized rendezvous
    is when you have multiple things at once happening。 This could be with let's say
    the people who are asking for the ice cream cones have to wait for all their cones
    to be made。 They're generalized like I'm waiting for a bunch of things to happen
    kind of before I can do anything。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这将是我们要做的事情。广义会合是指你有多个事情同时发生。这可能是，比如说，要求冰淇淋的人必须等到所有的冰淇淋都做好。它们是广义的，就像是我在等许多事情发生，然后才可以做任何事情。
- en: And then layered construction is more or less it's more or less like how do
    you do this one thing on top of the other。 We'll do that。 And we'll see how that
    works。 You certainly can go download the code。 You have the multi-threading all
    the code right in front of you。 So if you're looking at one piece and you want
    to go back and go hey wait how did that work with the other part feel free。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '然后层次化构造或多或少就像是你如何在一个事情之上做另一个事情。我们将做这个，并且看看它是如何工作的。你当然可以去下载代码。你有多线程的所有代码都在你面前。所以如果你正在看某个部分，想回去看看另一个部分是怎么运作的，尽管去做。 '
- en: And I know you haven't had a chance to really look through this but we will
    go through it one thing at a time。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能还没有机会真正看过这个内容，但我们会一项一项地讲解。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_10.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_10.png)'
- en: Okay so binary lock what's the binary lock it's a mutex basically。 Okay to remind
    you a mutex does nothing else except allow two threads to try to get into some
    critical region。 And it doesn't even have to be the same critical region they
    just have to basically both be fighting over some resource。 One of only one of
    which can do can access that resource at a given time。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么二进制锁是什么？它本质上是一个互斥锁。好的，提醒你一下，互斥锁什么都不做，只是允许两个线程尝试进入某个临界区。而且它们不一定要进入同一个临界区，它们只是基本上在争夺某个资源。只有其中一个线程可以在某个时刻访问该资源。
- en: Many times it's a global variable or some shared variable they both want to
    update and you want to do it what we call it。 Okay and then so again it's all
    about single thread access。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，这是一个全局变量或一些共享变量，它们都想要更新，你要做我们所谓的操作。好的，然后再一次，它全是关于单线程访问。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_12.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_12.png)'
- en: Okay the generalized counter this is where we talk start talking about semaphores。
    This is where the counter itself the semaphore itself can do a can increment a
    variable atomically。 In other words no other like only one thread can actually
    make it do its thing at once do the incrementing or decrementing。 Okay we talked
    last time about the various things we can do with a semaphore。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，广义计数器，这是我们开始讨论信号量的地方。在这里，计数器本身，信号量本身可以原子性地递增一个变量。换句话说，只有一个线程可以在任何时候执行递增或递减操作。
- en: If we have a semaphore that has a count of zero like no permits it's basically
    just uses a signaling thing back and forth。 Okay so one thread can signal another
    thread which is waiting on that it's not like there's a permit here just one thread
    goes on waiting around。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个计数为零的信号量，比如没有许可，它基本上只是用来进行信号的往返传递。好吧，所以一个线程可以通知另一个正在等待的线程，表示这里没有许可，只有一个线程在等待。
- en: So we will see those used as we go as well。 Okay and this is where you're coordinating
    some limited resource that has some number of things in it。 Number of columns
    or one column or you know one sort of number of things that you might want to
    link。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在后面会看到这些用法。好吧，这就是你在协调一些有限资源时使用的方式，这些资源有一定数量的东西。可能是一些列数或一列，或者你知道的某种数量的东西，你可能希望将其连接起来。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_14.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_14.png)'
- en: Okay all right a binary rendezvous this is where again you use semaphore and
    this is for inter thread communication。 Okay and the example here is a pretty
    good one。 So suppose we had thread A that needs to know when thread B finishes
    something。 Okay so for instance when the manager has to determine whether or not
    the cone is well good or not the clerk has to wait around for that to happen and
    has to wait on that other thread to do to do their thing。 Okay what we can do
    is we can have this rendezvous semaphore initialized to zero because all we care
    about is the signaling part。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，好的，二进制会合就是在这里，你再次使用信号量，这是为了线程间通信。好吧，下面的这个例子很不错。假设我们有线程A需要知道线程B什么时候完成某些事情。好吧，比如当经理需要判断冰淇淋是不是好坏时，店员就得等着，必须等另一个线程完成它们的任务。好吧，我们可以做的是，让这个会合信号量初始化为零，因为我们关心的只是信号部分。
- en: Okay and thread A actually waits on that semaphore。 Okay and after thread B
    finishes it signals thread A which continues。 Okay and thread B does not care
    about anything else that the other thread is doing at that point。 It just goes
    signals and then moves on。 Okay so that's how a binary semaphore works or a binary
    rendezvous in this case。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，线程A实际上在等待这个信号量。好吧，在线程B完成后，它会通知线程A，线程A继续执行。好吧，线程B不关心其他线程在那时做的事情。它只是发出信号，然后继续。好吧，这就是二进制信号量工作原理，或者说在这种情况下的二进制会合。
- en: Okay there's only one event that needs to happen and that's all we care about。
    Okay this is sometimes used to wake up other threads like a thread just waiting
    around and then somebody wakes it up with this signal。 That's a good way of thinking
    about it。 You can do a bi-directional rendezvous。 This is different than a generalized
    one。 This is like basically one thread waits for the other which waits for the
    other。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，只有一个事件需要发生，这就是我们关心的全部。好吧，这有时也用来唤醒其他线程，比如某个线程一直在等待，直到有人用这个信号将它唤醒。这是一个很好的理解方式。你可以进行双向会合。这与广义的会合不同。这基本上是一个线程等待另一个线程，而另一个线程又等待其他线程。
- en: You have to be very careful that you do that so they're not both waiting at
    the same time because then you'll get deadlock。 So you have to be careful there。
    Okay so there's some logic that you need to figure out there。 Okay all right a
    generalized rendezvous is where you have a binary rendezvous and a generalized
    counter。 Okay this could be more or less the like ice cream customers are waiting
    for the clerk to do something or actually waiting for a bunch of clerks to do
    something and they have to sit around。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须非常小心这样做，避免它们同时等待，因为那样会导致死锁。所以你需要小心这一点。好吧，所以你得理清一些逻辑。好吧，好的，广义会合是指你有一个二进制会合和一个广义计数器。好吧，这可能就像冰淇淋顾客等待店员做某些事，或者实际上是在等待多个店员做某些事，他们必须等在那。
- en: So in this case thread a spawned five thread B's。 That sounds like the ice cream
    customer asking five different clerks。 Okay thread a spawned five thread B's and
    needs to wait for all of them to make a certain amount of progress before advancing。
    That's when we would use this technique。 Okay again you have the semaphore initialized
    to zero。 When a needs to sync up with the other ones it will block until they
    all finish。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下，线程A生成了五个线程B。听起来就像是冰淇淋顾客去问五个不同的店员。好吧，线程A生成了五个线程B，并且需要等它们都完成某个进度后再继续。这时我们会使用这种技术。好吧，再次强调，信号量初始化为零。当线程A需要和其他线程同步时，它会被阻塞，直到它们都完成。
- en: Okay and then when they all finish then they will the thread a will then be
    able to get moved forward after that。 Okay this is a good this is the generalized
    part of this is you have some task that you're dividing up。 You're saying I need
    to make three cones I'm dividing the three different clerks you need to generalize
    that and then wait for all those tasks to complete。 That's the generalized rendezvous。
    Okay all right and then this whole layered construction is basically using all
    this together to say oh we've got a mutex and then we can have a semaphore that
    uses the mutex and how do you kind of piece them together。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，当所有人都完成后，线程a将能够继续执行。好的，这个部分的普遍性在于你有一个任务要分配。你说“我需要做三个冰激凌球”，然后将这三个任务分给三个不同的店员，你需要将这个过程普遍化，然后等待所有这些任务完成。这就是通用的会合（rendezvous）模式。好的，接下来这个层级结构基本上是将所有这些内容结合起来使用，意味着我们有一个互斥量，然后可以有一个使用该互斥量的信号量，如何将它们组合在一起。
- en: You've got some global counter that uses this that's going to have mutex associated
    with it you've got to wait around what size the counter changes value or reaches
    some value and so forth。 So that's the big takeaway for that one is that you need
    to you need to be able to use these constructs together to suit your to suit whatever
    you're trying to do。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你们有一些全局计数器，使用了这个计数器，它将与互斥量（mutex）关联，你需要等待计数器的值变化或达到某个值等等。所以这里的主要内容是，你需要能够将这些构造一起使用，以适应你需要做的事情。
- en: Okay all right let us look at some of the actual code。 Okay I've already we've
    already talked about this we modeled it pretty distinctly okay ice cream store
    clerks manager customers cashier lots of clerks one manager one cashier。 Customers
    are in a hurry so they get lots of clerks per one per ice cream cone and then
    once they get their cones back they go to the cashier I mean it's not a terrible
    model。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题，让我们看一下实际的代码。好的，我们已经讨论过这个了，我们已经把它建模得相当清晰了，好的，冰激凌店员、经理、顾客、收银员，很多店员，一个经理，一个收银员。顾客比较着急，所以每个冰激凌球都会配一个店员，然后一旦他们拿到冰激凌球，就去找收银员。我是说，这个模型还算不错。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_16.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_16.png)'
- en: And then each clerk just gets to make one cone yeah that's a little weird but
    that's the way it works in this in this world and the manager has to determine
    whether or not the cone is legitimate or not。 Okay and the big issue there for
    the cashier is it has to be a first in first out queue otherwise it's chaos because
    the customer's going I was here first and why didn't you take care of me and so
    forth and Brenda would not want to do that because she could help。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每个店员只制作一个冰激凌球，是的，这有点奇怪，但这就是在这个世界中的运作方式，经理必须决定这个冰激凌球是否合法。好的，收银员面临的最大问题是，必须使用先进先出（FIFO）队列，否则就会一团混乱，因为顾客会说“我先到的，为什么你没有照顾我”，而布伦达是不希望那样的，因为她可以帮忙处理其他顾客。
- en: Okay and then we're actually have to at some point determine when everybody
    goes home it's a little wonky like that the manager knows the manager has to make
    six cones by the end of that little weird so we could have done it some other
    way but in this case we just say right off the bat we'll do that。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，然后我们实际上需要在某个时刻决定每个人什么时候下班，这有点奇怪，因为经理必须在那之前做完六个冰激凌球，虽然有点怪，但我们本来可以用其他方法来实现，不过在这个例子中，我们直接决定从一开始就这么做。
- en: You will see how the code ends up manifesting itself for that。 Okay all right
    questions before we start looking at the code about the overall picture here you've
    seen it now we're going to see some code you kind of get the idea。 Okay good all
    right so here's the various things we're going to look at。 Okay we're going to
    look at all these parts of the code you have them in here I'll try to tell you
    which page these are on as we go through them because they're not necessarily
    in the order on the code in the code。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你们将看到代码是如何体现这一点的。好的，开始之前，有没有问题？你们现在已经看过了整个大致框架，我们接下来将看一些代码，你们应该已经有个大概的了解了。好的，很好，那么接下来我们将看一些具体的内容。好的，我们将看代码的各个部分，你们已经有这些内容了，我会尽量告诉你们这些内容在哪一页，因为它们在代码中并不是按照顺序排列的。
- en: But the first thing we're going to look at is the random number generators just
    to kind of see where it is this is actually on page four of nine in the handout。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们首先要看的内容是随机数生成器，只是为了了解它在哪，这个内容实际上在手册的第4页。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_18.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_18.png)'
- en: And I've got it right here as well。 Basically we have lots of randomness going
    on here why because we want to make it look like it's some sort of like actual
    time constraints and it's not always the same time。 Okay we do this often with
    these sorts of things this makes debugging a little harder because it is kind
    of random but it will definitely test lots of different categories。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它也写在这里了。基本上我们这里有很多随机因素，为什么呢？因为我们想让它看起来像是某种实际的时间限制，并且时间并不总是一样的。好的，我们经常用这些方法，这让调试变得有些困难，因为它有点随机，但它肯定能测试很多不同的情况。
- en: Okay most of these are times we have get number of or get actually a couple
    of mark get number of cones like the customer comes in and says I want you know
    how many cones so that's not a time。 There's get browser browse time which is
    the customer milling around there is or and that's part of it。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些大多是时间，我们有获取数量的功能，实际上有几个标记获取数量的甜筒，比如顾客走进来告诉我们他们想要多少个甜筒，这就不是一个时间。而有浏览时间，是顾客在周围转悠的时间，这是其中的一部分。
- en: There's get prep time that's how long it takes the clerks to make an ice cream
    cone that may or may not be good。 And then there's get inspection time along manager
    takes and then finally there's get inspection outcome which is the binary yay
    or nay as far as the cone goes。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有准备时间，这是指店员制作冰淇淋甜筒所需的时间，可能好也可能不好。然后是检查时间，这个时间是经理所需要的，最后是检查结果，这是关于甜筒的二元决策——好与不好。
- en: Okay relatively straightforward not anything you need to particularly concern
    yourself about it's just using a library function we actually wrote to get these
    values out。 Okay let's look at the structs here so this model is if you're in
    106 B this or 106 A you would probably cringe if you saw this that there's some
    global struct here。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，相对简单，不需要特别关注它，只是使用了我们自己写的库函数来获取这些值。好的，我们来看一下这些结构体，所以如果你在106 B或者106 A，你可能会对看到这种全局结构体感到不适。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_20.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_20.png)'
- en: All right why because we don't necessarily like global things but with threads
    sometimes it just makes it easier to pass around global very or to have a global
    variable then to deal with having a having a struct that you're passing around。
    For encapsulation reasons we probably would want to pass it around in a in a more
    robust program but for now we are just making a struct called inspection and it's
    got these fields in it。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，为什么呢？因为我们并不一定喜欢全局变量，但在使用线程时，有时传递全局变量或者使用全局变量会比传递结构体更简单。出于封装的原因，我们可能会希望将它传递给一个更健壮的程序，但现在我们只是创建了一个名为inspection的结构体，它包含了这些字段。
- en: Okay it's got a mutex for available this is the handshake basically between
    it's the it's the binary round of view between the clerk and the manager。 Okay
    so there's an available mutex which is basically saying only one clerk can be
    dealing with the manager at a time the manager can only look at one ice cream
    cone at a time that's the mutex。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它有一个可用的互斥锁，这基本上是它与经理之间的握手，实际上是店员与经理之间的二进制交互。好的，所以有一个可用的互斥锁，这基本上意味着在同一时间只有一个店员可以和经理打交道，经理每次只能检查一个冰淇淋甜筒，这就是互斥锁。
- en: Okay there is a semaphore for signaling hey manager I've got an ice cream cone
    for you and there's a semaphore for saying hey clerk here's your ice cream cone
    it's terrible or it's great。 That's another one and then there's actually a boolean
    in here for whether or not it passed and then by the way out here we create a
    struct called inspection and then we immediately declare it as a variable inspection。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，有一个信号量用于通知经理“嘿，我有一个冰淇淋甜筒给你”，还有一个信号量用于通知店员“嘿，这是你的冰淇淋甜筒，它糟糕或者很好”。还有一个布尔值，用来表示它是否通过，顺便提一下，在这里我们创建了一个名为inspection的结构体，并立即将其声明为一个变量。
- en: Seems like it's overloading the name but that's the way it goes so this is a
    global variable again we didn't have to do it globally but just makes it a little
    easier。 Now there are a couple interesting things about this if there's only one
    value about past or not right how many things can be using this struct at any
    one time。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎它过载了这个名称，但就是这样，这仍然是一个全局变量，尽管我们不一定非要做成全局变量，但这样做更简单。现在有几个有趣的点，如果只有一个值表示是否通过对吧？那在任何时候，有多少个东西可以使用这个结构体呢？
- en: One thing right one manager or one one manager or one clerk can be inspecting
    this or using it at one time there's only one manager which is nice。 In fact if
    we did do many managers like let's see what multiple managers or assistant managers
    or whatever then we would have to rethink this we might have to have some other
    either array of these inspection structs or something else because the way it's
    worked right now there's one value at one time which says whether or not ice cream
    cone is good or not。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事，好的，一个经理或者一个职员一次只能检查或使用它，只有一个经理，这样挺好的。实际上，如果我们做了多个经理，比如看看多个经理或者助理经理之类的，那么我们就得重新考虑这个问题。我们可能需要其他东西，比如这些检查结构体的数组，或者其他什么，因为现在它的工作方式是，一次只有一个值，表示冰淇淋是否合格。
- en: Okay， all right so that's how the struct works what questions you have about
    that struct at this point maybe you don't。 We'll see it in action very soon。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，好吧，这就是结构体的工作原理。到目前为止，你对这个结构体有什么问题吗？也许你没有问题。我们很快就会看到它的实际应用。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_22.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_22.png)'
- en: Okay there's another struct which is the checkout one so we're kind of jumping
    ahead to the checkout phase but the checkout has a semaphore for next in place
    in line。 Okay which is a new kind of integer here it's an atomic unsigned in what
    that means is that that variable can be updated by multiple threads at the same
    time and it will never do that we're double or not not double counting。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，还有另一个结构体，就是结账的那个，我们有点提前跳到结账阶段了，但结账有一个信号量，用于排队等待的下一个人。好的，这是一个新的整数类型，它是一个原子无符号整数，这意味着这个变量可以被多个线程同时更新，而永远不会发生重复计数。
- en: So atomic such that it makes it so the plus plus works no matter 10 threads
    come at it once it's what we call thread safe 10 threads can go update that you'll
    always get 10 increments if 10 threads updated or not。 Yes。 Ah good question the
    question was hey is there ever a time you don't want to use the atomic variable
    most of the time you don't because most of the time you're not using threads right
    and the atomic operation is slower。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是原子性的，这使得它无论 10 个线程同时操作，`++` 都能正常工作，这就是我们所说的线程安全。无论 10 个线程是否更新，它都会得到 10 次递增。是的。啊，好问题，问题是，嘿，是否有时候你不想使用原子变量？大多数情况下你不会使用，因为大多数时候你并没有使用线程，对吧，而原子操作比较慢。
- en: Alright because it's got to do other some other things in there and it actually
    needs the hardware to support it so it's a different instruction and there's other
    hardware support which means it takes a little longer。 And if you know anything
    about C and C++ the bottom line is let the user do things as fast as necessary
    but give them the tools to be able to do it correctly if that has to be an issue。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为它需要做其他一些操作，而且实际上需要硬件来支持它，所以它是一个不同的指令，并且有其他硬件支持，这意味着它会稍微慢一些。如果你了解 C 和 C++，底线是让用户按需快速完成任务，但也给他们提供正确完成任务的工具，如果这成为一个问题的话。
- en: So this is one of those ones where only use an atomic number you're going to
    need it right otherwise use the faster ones because most of the time you don't。
    Very good question。 Yes。 If you just had a regular unsigned into you and you did
    plus plus it's going to be faster than plus plusing this one because this one
    has similar。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是那种仅在需要时才使用原子数值的情况，否则使用更快的类型，因为大多数时候你并不需要它。非常好的问题。是的，如果你只用了一个普通的无符号整数，并且进行了
    `++` 操作，它会比进行原子 `++` 操作更快，因为后者有额外的开销。
- en: Oh right right well sure you know the last time we could have used a we could
    maybe we could have done this with an autonomous number semaphore we could have
    done it so。 Maybe you would have used a conditional variable。 In this case we're
    going to see where it gets incremented or documented and then you'll go oh okay
    it makes sense that if we have this atomic thing we might as well use it。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对对，没错，当然你知道，最后一次我们本可以使用一个，也许我们可以用一个自主编号的信号量来实现，或者我们也可以使用条件变量。在这种情况下，我们将看到它是如何递增或被记录的，然后你会明白，如果我们有这个原子操作，我们不妨使用它。
- en: We'll get there。 Ask the question when we see it in action when you see somebody
    doing something the next place in line。 Good so that's the that's the the couple
    of the structs that we're going to have again global struct。 Okay and that's it。
    Now the other one again at this point it's a global it may be that multiple types
    of multiple threads are actually accessing at the same time。 It turns out it's
    okay but the cash here is still going to take the customers in order based on
    this array here when they end up in the array。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在实际操作中看到。我们会看到某人如何在“下一个排队位置”处进行操作。很好，这是我们将使用的几个结构体之一，依然是全局结构体。好的，其他的结构体也是全局的，可能有多个类型的线程同时访问它。实际上这是可以的，但收银员还是会按顺序根据数组中的顾客处理他们。
- en: Okay and and maybe you'll understand that once you if you can update this next
    place in line atomically then you can use that as the actual as the actual index
    into the array and make sure that each customer gets their own spot in the array。
    You'll see that see that happening as well。 Okay the waiting customer semaphore
    informs the cashier their customers waiting so cashier is going to go start up
    and then go I'm waiting for customers to finish and then just wait and then eventually
    a customer will signal the cashier。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，也许你会明白，如果你能原子性地更新下一个排队位置，那么你就可以将其作为实际的索引来访问数组，并确保每个顾客都能在数组中得到自己的位置。你会看到这个过程的发生。好的，等待顾客的信号量通知收银员有顾客在等待，所以收银员将开始工作，然后等待顾客完成，最终顾客会发出信号通知收银员。
- en: Hey I'm ready to get checked out let me check out。 Okay there are other ways
    of doing this this just happens to be one of them。 Okay。 All right let's move
    on to the next thing。 All right here's the first real like major function here
    this is the customer function the customer function is on page。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我准备好结账了，能结账吗？好的，有其他方式可以做这件事，但这只是其中之一。好的，我们继续下一个内容。好了，这是第一个真正的主要功能，这是顾客功能，顾客功能在页面上。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_24.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_24.png)'
- en: Yeah page nine of nine right near the end right before main customer line。 Okay
    all right so what is the customer have to do well the customer goes in and figures
    out the customer already knows by the time they get here how many cones they want
    we will do that we'll initialize that in main as it turns out。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，第九页，接近最后，主顾客队列之前。好的，那么顾客要做什么呢？顾客一进入就知道自己想要多少个冰淇淋，我们会在主函数中初始化这一点。
- en: And the customer will then create a vector of clerks。 Okay it could have created
    an array of clerks of the number it's going to do doesn't matter in this case
    we're just making a vector we're in C++ we can do vectors。 Okay and then it is
    going to call thread on the clerk function with its variable i which is just the
    it's not really the id in this case the id will be passed in based on because
    we've got two things going on here we've got the number of the cone which is i
    and the id of the customer as well。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后顾客会创建一个服务员的向量。好的，它本可以创建一个服务员数组，数量无关紧要，在这种情况下我们只是创建一个向量，在C++中我们可以使用向量。然后它会调用线程来执行服务员功能，并传递它的变量i，虽然i在这里并不是顾客的ID，ID会根据实际情况传递，因为我们有两个东西要处理——冰淇淋的数量（即i）和顾客的ID。
- en: Okay that's going to get passed into the clerk so the clerk needs to know who
    to go back to anyway and so the customer is going to ask a trigger for hey my
    idea is such and such i want i am this is calling whatever。 All right and then
    and then the customer goes and brows is which just is some time takes up some
    time。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这个信息将传递给服务员，所以服务员需要知道该去找谁。顾客会触发一个请求，告诉服务员：“我的ID是某某，我是某某”。然后顾客去浏览，花点时间做其他事。
- en: Okay and then the customer has to do what the customer has to wait before the
    customer checks out all of the customers cones need to be made。 Fair enough which
    means that you're going to they're going to actually join on all of their clerks
    and they're going to wait around until the clerks are done making their cones。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来顾客必须做的事情是，顾客必须等待，直到所有的冰淇淋已经做好才可以结账。没问题，这意味着他们需要等到所有的服务员都做好了冰淇淋。
- en: Now they might still be browsing and all the clerks end but either way it's
    going to at this by the time you get passed this line on line eight here you are
    going to the customer knows that all of the cones have been made。 Question。 Yes
    good question the the join here simply blocks until the threads are done and that's
    the whole point of join and it cleans up the thread because they're done as well。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在他们可能还在浏览，所有职员也已经结束了，但无论如何，当你走到第八行时，客户就知道所有的冰淇淋已经做好了。问题？是的，好问题，这里的 `join` 仅仅是阻塞直到线程完成，这就是
    `join` 的全部意义，并且在线程完成后它会清理线程。
- en: Okay so at this point we know going forward we can the customer can check out
    because all of the clerks have finished their cone making。 Okay now there's no
    like hey here's your cone business I mean it's all that would all have to happen
    some other we didn't make that into this thing but you can assume that if we were
    really doing this and there's something else here we would actually have a cone
    handover sort of thing。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到此为止，我们知道，接下来客户可以结账，因为所有职员都已经完成了冰淇淋的制作。好的，现在没有那种“这是你的冰淇淋”之类的业务，我是说，这一切本应发生在别的地方，我们没有把这些内容整合到这个环节，但你可以假设，如果我们真的在做这件事，实际上这里会有一个冰淇淋交接的过程。
- en: But in this case clerks just know or the customer knows I have my three cones
    now maybe they're waiting at the cashier who knows。 All right then the then the
    customer has to go and actually find the next place in line now take a look at
    this line this is where your question might come in。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，职员只知道，或者客户知道，他们已经有了三只冰淇淋，可能正在等结账，谁知道呢。好了，接下来客户必须去找下一个排队的位置，看看这一行，这里可能会有你的问题。
- en: Check out next place in line plus plus okay this is going to assign whatever
    next place in line is to this customer and then atomically increment that variable。
    Okay what this means is that if two threads are coming in at this if two customers
    are coming in at the same time boom one of them will get the next place in line。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下一个排队的位置，这个操作将把下一个排队的位置分配给这个客户，并原子性地递增该变量。好的，这意味着如果两个线程在同一时间到达，如果两个客户同时到来，那么其中一个将获得下一个排队的位置。
- en: Another one will get the following place in line guaranteed。 Okay there is no
    race condition here specifically because we used an atomic variable there otherwise
    we could have a new text on there and then lock it and then update the place in
    line and then unlock it。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个客户将获得下一个排队的位置，这是有保证的。好的，这里没有竞争条件，特别是因为我们使用了原子变量，否则我们可能会在上面加一个锁，再更新排队位置，最后再解锁。
- en: This makes it a little easier if we've got this atomic integer we might as well
    use it。 This kind of negates the necessity of a lock in this case。 Yeah yeah good
    question so one of the cases where you do need a music there aren't that many
    atomic operations increment happens to be one where we can or integer that gets
    increment and decrement it happens to be one where we can change it atomically。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有了这个原子整数，这会让事情变得稍微简单一些，反正我们可以用它。这样一来就不再需要锁了。是的，是的，好问题，实际上你确实需要锁的情况并不多，原子操作的种类并不多，递增恰好是其中之一，我们可以在整数上执行递增和递减操作，并且能原子性地改变它。
- en: I think you could also add something to it or subtract to multiply whatever
    whatever you want you do map on that one and it's going to do it atomically but
    there if it was a map。 There's no atomic map necessarily so still have a lock
    and unlock just makes it a little simpler but you simply certainly could do this
    with a lock and unlock you want to。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得你也可以对它做加法、减法、乘法，任何你想要的操作，你可以对它应用 `map`，它会原子性地执行，但如果是 `map` 操作，并没有原子性的 `map`，所以仍然需要锁和解锁，这样做虽然简单一些，但你完全可以用锁和解锁来实现这个操作。
- en: Yes。 Is it something that we can't know how is it going to be something or something
    like this？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们无法知道它会是什么吗？是不是类似的事情？
- en: Do you want to know how it's doing it atomically？ Yeah so it's a bit beyond
    the scope of this class as far as what's happening but there are machine instructions
    which when you call them will do this operation atomically and you just have to
    set it up such that this is a little bit more than you can。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道它是如何原子性地执行的吗？是的，这超出了本课程的范围，但有一些机器指令，当你调用它们时，会原子性地执行这个操作，你只需要设置它，以确保这比你所能做的稍微复杂一点。
- en: It's not just such that this uses that like uses that operation。 It may just
    be honestly it may be that that class just puts a locker on it。 It might just
    be as easy as that I don't have it looked it up but I think in other cases it's
    there are machine instructions and you'll speed things along so that's why you
    might want to use this。 [inaudible]， Yeah so the question was hey look in process
    we block and unblock if multiple processes can change one。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是使用那个操作就像是使用那个操作一样。可能说的就是，它可能真的只是那一类操作上加了一个锁。可能就是这么简单，我没有查过，但我认为在其他情况下，会有机器指令，它会加速过程，所以你可能会想要使用这个。[听不清]，是的，问题是，嘿，看看我们在进程中如何进行阻塞和解锁，如果多个进程能够更改其中一个。
- en: It's not really a global variable because it could be calling a signal handler
    because member processes don't share memory。 But in this case yes if you're using
    the atomic variable you don't need the lock if that's all you're really doing
    to it is updating the variable itself。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它其实不是一个全局变量，因为它可能会调用一个信号处理程序，因为成员进程不共享内存。但在这种情况下，如果你使用原子变量，你就不需要锁了，只要你做的只是更新变量本身。
- en: You don't need to worry about it because it will be done in such a way that
    you don't need to do the lock on it。 Just another thing to show you you can use
    this if it's a case where you have something like this。 Don't overuse it because
    it is a little slower but use it when you can if you want to or you can just lock
    nobody's going to take off points for that if it's if you do one of the other。
    Okay so then what happens after the customer gets in line well the customer tells
    the checkout signals the checkout person to the cashier to actually keep going
    so the checkout waiting customer signal so the cashier is going I'm waiting around
    waiting around and going oh there's a signal let's start processing this。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要担心，因为它将以一种方式完成，这样你就不需要在它上面做锁。只是另外告诉你，如果是这种情况，你可以使用它。不要过度使用，因为它会稍微慢一点，但如果你能使用它，或者你也可以选择加锁，这不会有人因为你选择其中一个而扣分。好了，那么当客户排队后会发生什么呢？客户告诉收银员继续结账，所以收银员会在等待时收到信号，哦，有信号了，开始处理。
- en: The next customer and the checkout the cashier will go and look up who the next
    customer is based on the same variable。 Okay you'll see how that works as well
    when we get to the cashier。 And while the cashier is checking the customer out
    the customer has to wait。 Okay so the customer says check our customers place
    wait remember this is a semaphore per each one of those or rather a what looks
    like hold on it is what it is a semaphore per customer in that case。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个客户和收银员将根据相同的变量查看下一个客户是谁。好的，你会看到当我们到达收银员时它是如何运作的。并且在收银员结账的时候，客户必须等。好了，所以客户会说“结账”，客户会等。记住，这是每个客户对应一个信号量，或者说，实际上是每个客户的信号量。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_26.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_26.png)'
- en: And let's see the semaphore again it's a let's see semaphore customer it's just
    a single zero value semaphore just signaling doesn't need any like permits or
    anything like that。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下信号量，它是一个信号量的客户，它只是一个零值的信号量，仅用于信号传递，不需要任何像许可证之类的东西。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_28.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_28.png)'
- en: Could you have done this with permits maybe like with permits the thing about
    permits though is that there's still a bit of a race condition there as far as
    who gets handled next with a permit like there might be some permit thing if you
    signal everybody it won't go necessarily in line。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你能用许可证来做吗？也许吧，不过关于许可证的问题是，仍然会有一点竞争条件，关于谁会先处理的问题。比如用许可证的方式，如果你向所有人发信号，它们就不一定按顺序处理。
- en: That's going to be an issue。 Okay we need the customers based on our model to
    be handled in order they arrived at the cashier that's the important part。 Okay
    all right once the signal comes back from the cashier the customer has checked
    out and leaves。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这会是个问题。好的，我们需要基于我们的模型按客户到达收银员的顺序处理客户，这是最重要的部分。好了，一旦收银员传回信号，客户就结账离开了。
- en: Okay question there are okay this weight right here you tell me what that's
    weight what did the customer what did the customer just do customer just signaled
    the cashier。 So what's the customer have to do wait for the cashier to check them
    out that's what's happening here。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，问题来了，看看这里的等待，告诉我那是什么等待？顾客刚刚做了什么？顾客刚刚给收银员发送了信号。那么顾客接下来需要做什么？等待收银员结账，这就是发生的事情。
- en: Okay so there's a double signal going on here the signaling the cashier to say
    hey can you check me out and then waiting for the cashier to signal back。 Now
    the cashier has to signal back in the proper order right the cashier because this
    signal there is no waiting associated with a signal like you signal and then you
    go on。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以这里有两个信号：一个是信号收银员说，“嘿，你能帮我结账吗？”然后等待收银员的信号回复。现在收银员必须按正确的顺序进行回复，因为这个信号没有等待的过程，你发送信号后就可以继续前进。
- en: So it might be that all the customers are sitting here waiting the cashier needs
    to go to signal the correct next customer and we'll get to see how that works
    in a little bit。 Okay question。 The cashier will signal you in order cashier will
    signal in order we'll see how that happens。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以可能所有顾客都在这里等待，收银员需要发出信号给下一个正确的顾客，然后我们将看到这个是如何运作的。好的，问题来了。收银员会按顺序发出信号，我们将看到这个是如何发生的。
- en: Is it possible that a person further along the line could have their ice cream
    cones completed or will they not have sent the signals to the cashier。 Right so
    your second part so basically the question was wait if the could somebody in line
    not have their or have their cones made before somebody further up in line。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有可能排在后面的顾客会先完成他们的冰淇淋，或者是他们还没向收银员发送信号呢？对，所以第二个问题基本上是，如果排队的某个人是否可能比排在前面的顾客先完成他们的冰淇淋呢？
- en: Remember the customers just milling around until they get all their cones back
    then they get in line。 Alright this isn't a case where like you go stand in line
    while everybody goes and gets the you know whatever it's you know your one person
    stand you only stand in line when you get your cones so that's the order you'll
    be taking it。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，顾客会一直在等，直到他们的冰淇淋做好，然后才会排队。好了，这不是那种大家都去拿东西然后排队的情况，不是的。你是只有在冰淇淋做好时才去排队，所以你排队的顺序就是这样。
- en: And now it could be certainly that two customers get their cones at the same
    time and then fight over who gets to be in place first。 That's fine but whoever
    ends up in first place gets handled by the cashier first and we'll see how that
    happens in an interview。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有可能是两个顾客同时拿到冰淇淋，然后争抢谁先排队。这没问题，但无论如何排在第一位的人会先由收银员处理，我们稍后会看到面试中是怎么处理的。
- en: Other questions on this one。 Yes。 So just some main clear is just looks a little
    weird though。 So the whole check out dot customers play。 That's because you literally
    have an array of semaphores one for each customer or you have one semaphore that's
    needed to track up all the way。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他问题吗？是的。有点困惑的是，这看起来有点奇怪。所以整个结账顾客的流程。这是因为你实际上有一个顾客的信号量数组，每个顾客一个信号量，或者你有一个信号量用来跟踪所有顾客的位置。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_30.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_30.png)'
- en: No let's take a look。 There is a customer's array which is a semaphore per customer。
    Right so each customer gets their own semaphore what's their rating on how do
    they know which which where they are in line。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们来看一下。有一个顾客数组，每个顾客有一个信号量。对，所以每个顾客都有一个自己的信号量，他们如何知道自己在排队中的位置？
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_32.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_32.png)'
- en: They do right here they get their place in line by getting the next place in
    line variable which is updated per customer that comes in and then incrementing
    it so the next customer gets the next place in line。 That's what we're doing right
    there。 And the cashier is just going to go through a little bit and go you you
    you you and know which one to actually get next。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 他们就在这里，按顺序获得他们的位置，通过获取下一个排队位置的变量，每个顾客进来时更新这个变量，然后递增它，这样下一个顾客就能得到下一个排队位置。这就是我们在做的事情。收银员只是稍微浏览一下，按顺序处理每个人，知道下一个应该处理谁。
- en: Right and the only way the cashier is going to know to get anybody is because
    the cashier gets a signal。 So that's the the signaling part there。 Okay。 Does
    it start in the jail a little bit how this stuff works？
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对，收银员知道要处理谁的唯一方式是因为收银员收到了信号。所以这就是信号传递的部分。好的。现在是不是有点开始明白这些东西是如何运作的吗？
- en: Good。 Okay。 If it's if you're like oh I get it all on the board awesome。 I would
    love it if that was a guess。 Okay。 So great。 If that's if that's what's going
    through your head。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。好了，如果你现在心里想：“哦，我明白了，非常棒。”那我会很高兴的。如果那是你脑海中的想法，那就太好了。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_34.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_34.png)'
- en: Okay。 How does the customer browse pretty straightforward。 The customer just
    gets a browse time and then sleeps for that amount of browse time。 All right。
    Sleep for is the way threads sleep for a particular amount of time。 They cause
    sleep for and then the amount of time in micro millisseconds and then they do
    that and then the customer just said customer just killed so many seconds。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。顾客是如何浏览的呢？非常简单。顾客只需要获取一个浏览时间，然后按这个浏览时间休眠。好了，`sleep for`是线程休眠一段特定时间的方式。它们执行`sleep
    for`，然后是微秒或毫秒为单位的时间，然后它们就这样做，顾客就这么度过了多少秒。
- en: Okay。 All right。 That's that。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，明白了，就这样。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_36.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_36.png)'
- en: All right。 Let's look at the clerk function。 Okay。 Remember one。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们来看一下职员函数。记住一点。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_38.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_38.png)'
- en: Oh， by the way， what happened？ We kind of went right over this part。 Here is
    where the clerk threads get started。 This is back in the in the customer function。
    This is an interesting point。 We are going to see when we get to main that both
    the manager and the customers and the cashier are all created in main。 And then
    the cashier and the manager immediately go to sleep basically because they don't
    have anything to do yet but have their thread started。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，顺便说一下，发生了什么？我们有点跳过了这一部分。这是职员线程开始的地方。回到顾客函数中。这是一个有趣的点。我们会看到，到了主函数中，经理、顾客和收银员都是在主函数中创建的。然后，收银员和经理几乎立即进入睡眠状态，因为他们暂时没有事情做，但他们的线程已经启动了。
- en: Yes， their threads have started。 So which means that it's actually less time
    to wake them up。 This is going to actually follow directly into the next thing。
    In fact。 not this next assignment which I'll have out by tonight at some point
    or the by the next assignment。 You'll learn about these things called thread pools
    which are ready waiting threads to go do their thing。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，他们的线程已经启动了。所以这意味着唤醒他们所需的时间其实更少。实际上，这将直接进入下一个内容。事实上，不是下一个作业，我会在今晚某个时刻发布它，或者是下一个作业。你将学习到一种叫做“线程池”的东西，它是准备好等待执行的线程。
- en: Does that sound like any other assignment you've seen？ Farm maybe。 Right。 Farm
    was processes waiting to go。 They're already ready。 They're what we call spun
    up ready to go。 That's the same sort of thing。 We are spinning up the customers。
    the manager and the and the cashier but we are not spinning up the clerks until
    the customer actually does it。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像你见过的其他作业吗？可能是农场作业。对吧？农场作业是进程在等待启动。它们已经准备好了。它们是我们所说的“已启动准备就绪”。这是同样的情况。我们正在启动顾客、经理和收银员的线程，但直到顾客实际执行时，我们才启动职员线程。
- en: So it's kind of like the customer goes and like hires a clerk。 You can think
    of it that way which would be weird。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以就像顾客去“雇佣”一个职员。你可以这么理解，虽然那样说有点怪。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_40.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_40.png)'
- en: Now we go into the clerk and we see what happens with the clerk。 So the clerk，
    all right。 The clerk needs to do what？ Make a cone that's perfect and if it's
    not perfect then it needs to make another cone until the manager says you have
    made a perfect cone。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入职员函数，看看职员会发生什么。职员需要做什么？制作一个圆锥，如果圆锥不完美，那就需要再做一个，直到经理说“你已经做出了完美的圆锥”。
- en: So there's a little while loop in here that says while not success。 This success
    is a local variable。 Does not need to be locked or anything。 It's before the clerk
    itself and that's the way it goes。 It's kind of nice。 Every clerk has its own
    success variable。 No need to block on that or have any reason to lock on those。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有一个小的循环，表示“当没有成功时”。这个成功是一个局部变量，不需要锁定什么。它在职员本身之前，所以就是这么回事。挺不错的。每个职员都有自己的成功变量。没有必要在那个上加锁，也没有理由加锁。
- en: What does the clerk do？ The clerk makes a cone。 The clerk locks the available
    lock。 The available lock is whether or not the manager is available。 So the clerk
    says。 "I need to lock this manager lock。"， What happens if a thread tries to lock
    and somebody else holds lock？
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 职员做什么？职员制作一个圆锥。职员锁定可用的锁。可用的锁是指经理是否可用。所以职员说：“我需要锁定这个经理锁。”如果一个线程尝试锁定，而另一个人已经持有锁，会发生什么情况？
- en: Just blocks。 All the clerks could come and this is where they're fighting over
    the manager。 One of the managers looking at a cone and then says the manager unlocks
    available and then goes or the other clerk that holds this lock unlocks it and
    then the manager is a free for all。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样被阻塞了。所有职员都可能来到这里，这时他们在与经理争抢。经理正在看着一个锥形物，然后说经理解锁了这个锁并可以继续，或者另一个职员拿着锁并解锁它，这时经理变成了一个自由角色。
- en: All the other clerks try to grab that manager right there。 Then once the lock
    is gathered then the clerk says， "Oh， I'm going to signal the manager。 Hey。 go
    please inspect my cone。"， And then what does it do？ It waits。 This looks exactly
    like what it did before。 The first signal then you wait because you're telling
    the other thread。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有职员试图立刻抓住那位经理。然后，一旦锁定完成，职员就说：“哦，我要给经理发信号。嘿，请检查我的锥形物。”然后它会做什么？它等待。这看起来完全像之前的情况。第一次信号发出后，你会等待，因为你在告诉另一个线程。
- en: '"Do something and I''m going to wait for you to finish it。"， Good？ Question，
    how''s it？'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “做点什么，我会等你完成。” 好吗？问题，怎么样？
- en: '>> So requested the requested and finished parts of the inspections part or
    both semifor？'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 那么，是否请求了检查部分并且已经完成，或者两者都已完成半信号？'
- en: '>> They are both semifor and zero permits。 It''s just a signaling semifor in
    that case。 The finished one or the requested is requesting the manager。 And by
    the way。 what do you think the manager is doing at this point？'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 它们都是半信号和零许可的。只是在这种情况下，它是一个信号半信号。完成的那个或请求的是请求经理的。顺便问一下，你觉得经理此时在做什么？'
- en: If the manager is waiting for the requested signal， it is waiting。 So that's
    what it's doing right there。 And then the manager has to then signal back to the
    thread。 "Oh， now you can go again。"， So there's only one requested and one finished。
    What does that mean again about how many things can be dealing with this struct
    at one time？
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经理在等待请求的信号，它就会等待。所以这就是它正在做的事情。然后经理必须向线程发送信号：“哦，现在你可以继续了。”所以只有一个请求和一个完成。那么，这意味着一次能处理多少事物？
- en: It turns out there's two that the manager and the clerk。 but no other clerks
    because they're all going to be stuck on this lock before they could go and change
    anything。 That's why there's only one need for a zero one there。 >> So there's
    like the following one way。 >> There could be always one waiting and always one
    like， "Yeah， then the manager signals。"， Maybe。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，只有经理和职员是相关的。但没有其他职员，因为他们都将被卡在这个锁上，直到他们能够去更改任何东西。这就是为什么这里只有一个零一的需求。>> 所以像是下面的方式。>>
    总是有一个在等待，总是有一个说：“是的，然后经理发信号。”也许吧。
- en: maybe not depending on how much time these things take。 The manager could be
    sleeping。 which means the manager is going to just wait until it gets a signal。
    Or it could happen immediately。 I mean， here's the nice thing about all of this。
    The way we set this up， as long as things are progressing okay， it's as efficient
    as it can be。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不会，取决于这些事情需要多少时间。经理可能正在睡觉，这意味着经理会一直等，直到收到信号。或者可能立刻发生。我是说，所有这些的好处是，我们设置的方式，只要事情进展顺利，它就能尽可能高效。
- en: There may be some wait time， but that wait time is out of our control。 We're
    going to make it as efficient as possible， so there's no extra wait time。 And
    there's certainly no busy waiting here。 We're not spinning， we're not doing any
    process。 We're just kind of going， "Look， I know I'm waiting for some other thread。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些等待时间，但这种等待时间超出了我们的控制范围。我们会让它尽可能高效，所以不会有额外的等待时间。而且这里肯定没有忙碌等待。我们不是在旋转等待，也没有进行任何处理。我们只是在想，“看，我知道我在等其他线程。”
- en: I'm just going to sleep until it happens。 The incident happens， I move on。"，
    That's where it goes。 >> Why would we go after requested and finished？ How does
    one form but it's waiting to signal requested and then wait on request？
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我会一直睡觉，直到事情发生。事件发生后，我继续前进。”这就是它的走向。>> 为什么要在请求和完成之后继续？它是如何等待信号请求并且然后在请求上等待的？
- en: '>> Yeah， very good question。 Why couldn''t we signal on requested and？ And
    wait on requested。 I was thinking about this。 I think there''s a race condition
    there。 If you signal and then try to wait， you might actually be the one getting
    your own signal。 If everything has to happen in an order where you don''t， you，
    in an order。'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 是的，问题很棒。为什么我们不能在请求和完成时发信号？然后再等待请求。我在考虑这个问题。我认为那里会有竞争条件。如果你先发信号，然后再等待，你可能实际上是在接收自己的信号。如果一切必须按照一定的顺序发生，你不能，必须按顺序进行。'
- en: it could happen in an order where you send a signal， go to sleep and wait。 And
    then by the time that signal propagates through the operation。 it comes back to
    you instead of the other thing waiting。 And not only that， there's。 the semaphore
    would drop down again and then it would take two signals， actually。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会按顺序发生，你发送一个信号，去休眠并等待。然后，当信号传播通过操作时，它会回到你这里，而不是另一个在等待。而且，不仅如此，信号量会再次下降，然后实际上需要两个信号。
- en: So that's probably the even better one。 It would take two signals to actually。
    to make one of them go unless it happened to be exactly ordered。 So you want to
    just avoid that kind of ordering nightmare。 In this case。 just use two because
    you know that one thread is going to wait on the request。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那可能是更好的方式。实际上，两个信号会导致其中一个必须等待，除非它恰好按顺序发生。所以你应该避免那种排序的噩梦。在这种情况下，使用两个信号，因为你知道一个线程会等待请求。
- en: and the other is going to wait on finished and you're okay。 You can try it。
    In fact。 go try to build it with one and see if it， if you can get it to do a
    deadlock or not。 But I imagine you might be able to。 Good questions。 All right。
    Anything else on the clerk？
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个会等待完成，然后你就没问题了。你可以试试看。事实上，去试试用一个去构建，看看你是否能让它发生死锁。但我想你应该能做到。好问题。好了，店员方面还有别的内容吗？
- en: What the clerk's doing？ Oh， by the way， the clerk does what？ Here， the clerk
    says。 waits for the manager to come back。 And then the clerk checks success and
    says， oh。 either it passed or not， right？ And if it didn't pass， well， first of
    all， it unlocks。 And if it didn't pass， well， it makes another cone， right？ Otherwise。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 店员在做什么？哦，对了，店员在做什么？这里，店员说。等待经理回来。然后，店员检查是否成功，并说，哦，要么通过，要么没有，对吧？如果没有通过，首先，它解锁。如果没有通过，那么它再做一个圆锥，对吧？否则。
- en: it would leave if it didn't do that。 And so it may stay in this loop as long
    as it keeps making bad cones。 It's just going to stay in that loop。 Really understand
    what's going on there。 All right。 Good。 All right。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，它会离开。所以它可能会停留在这个循环中，只要它一直在做坏的圆锥。它将一直停留在那个循环中。真正理解发生了什么。好的。好的。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_42.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_42.png)'
- en: Make a cone pretty straightforward。 It's just going to wait again。 It's going
    to， like， say。 I'm about to make a cone。 And it's going to get some time and then
    sleep for that amount of time。 And then tell how much time it was。 I'm going to
    run this program at the end。 It scrolls through the screen and it's like， oh，
    my gosh， what's going on？
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个圆锥很简单。它将再次等待。它就像说，我马上要做一个圆锥了。然后它会花点时间，休眠一段时间。然后告诉花了多少时间。最后我将运行这个程序。它会滚动屏幕，就像，哦，天哪，发生了什么？
- en: But you'll see when it happens。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但你会看到它发生时的情形。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_44.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_44.png)'
- en: OK？ All right。 Let's look at the manager function。 So the manager， remember。
    the manager starts out knowing how many cones it's going to make that day。 It's
    a little weird。 We could have done something else where there's a Boolean flag
    that says， all cones are going to go。 All the other signals are going to be handled。
    Or not even signal。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？好的。让我们看一下经理函数。所以经理，记住。经理一开始就知道今天要做多少个圆锥。这有点奇怪。我们本可以做其他事情，比如有一个布尔标志，表示所有圆锥都会做完。所有其他信号都会处理，或者甚至没有信号。
- en: Just you could have another signal if you wanted to。 Or you could just say the
    signal would probably work pretty well。 Have another sum up for being done for
    the manager。 It says， go home。 You're done。 And maybe you could link it together
    with one for the cashier as well or something like that。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以有另一个信号，如果你愿意的话。或者你也可以说信号可能会很好用。再加一个总结，表示经理已经完成了。它说，回家吧。你完成了。也许你还可以将它和收银员的信号联系起来，之类的。
- en: Although the manager can actually go home， although not the best business process。
    before the cashier does。 Because cashier might still be taking care of all the
    other customers。 But that's what it does。 So it needs to-- so it knows how many
    cones it needs to make。 manager knows how many cones they need to make。 And then
    they are going to attempt a bunch。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管经理实际上可以先回家，虽然这不是最好的业务流程。因为收银员可能还在照顾其他顾客。但这就是它所做的。所以它需要知道——它知道需要做多少个圆锥。经理知道需要做多少个圆锥。然后他们将尝试做一大堆。
- en: We're just doing this to log it， as it turns out。 And then they're going to
    approve a bunch of cones as well。 Until they approve the total number of cones
    they need to， they can't leave。 They are going to。 first things first， well， find
    out if they can leave， which they can't immediately。 And then they're going to
    wait on requested。 Because they're waiting for a clerk to come and hand them an
    ice cream cone and say。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做只是为了记录它，事实证明如此。然后他们会批准一堆圆锥。直到批准了他们需要的圆锥总数，他们才能离开。他们首先要做的事是，确定是否能离开，但他们不能立刻离开。接着他们会等待请求。因为他们在等职员来给他们一个冰激凌圆锥并说。
- en: please investigate there。 Please inspect this。 Then they inspect the cone。 Just
    again。 it's just going to be some time。 And it's going to be some time。 And it's
    going to actually update the struct to say whether or not the cone passed。 And
    then after it inspects it， it's going to send a signal back to the waiting clerk
    to say。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请在这里调查。请检查这个。然后他们检查圆锥。只是再检查一遍。它只需要一些时间。然后会花一些时间，实际上会更新结构，标明圆锥是否通过了检查。然后在检查之后，它会向等待的职员发出信号。
- en: go check your cone。 I just inspected it。 And then it does the num cones attempted
    plus plus。 And if inspection passed it's going to say the number of proof。 Now，
    the， can the。 this is going to happen at the same time as possibly the clerk is
    looking at inspection passes。 Is that okay if they both look at the same variable
    at the same time？ That's actually okay。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 去检查你的圆锥。我刚检查过了。然后它会把尝试的圆锥数量加一。如果检查通过，它会显示验证的数量。现在，能否同时发生呢？这可能和职员查看检查是否通过的过程同时进行。如果他们同时查看同一个变量，这样可以吗？其实是可以的。
- en: As long as no thread is able to update while the other thread is looking at
    it。 many threads can look at that one variable at the same time because it's not
    going to change。 So that's perfectly fine。 They might do it in some weird order
    in with the assembly language。 but it doesn't matter。 Doesn't matter。 All right。
    So what do they do after that？ So what's the。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有线程能够在另一个线程查看时更新它，许多线程可以同时查看同一个变量，因为它不会改变。所以这是完全可以的。它们可能会以某种奇怪的顺序进行，可能是在汇编语言中，但这不重要。没关系。好的，那么他们之后做什么？接下来是什么？
- en: what's the manager do after they inspect a cone？ They check number code。 they
    update number of cones proof possibly。 And then they go back in the while loop。
    If they have reached the number of cones they need exit the while loop， go home
    for the day。 That's that question。 [ Inaudible ]， Say again。 [ Inaudible ]， Oh，
    such a good question。 Okay。 Yes。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 经理在检查一个圆锥之后做什么？他们检查圆锥编号，可能会更新圆锥的验证数量。然后他们会返回到循环中。如果他们已经达到需要的圆锥数量，就退出循环，结束这一天。这个问题就到这里。[听不清]，再说一遍。[听不清]，哦，真是个好问题。好的。是的。
- en: So you're saying look， the lock happening， oops， the lock happening here。 Is
    this the one here？
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你是说，看，锁在这里发生，哦，锁在这里发生。这个是这里的那个吗？
- en: Yeah。 So the lock happening right here。 Okay。 You just have to remember that
    a lock has no care about what data structures there are。 It doesn't know。 It's
    not， it's not saying you can't touch this data structure。 It's saying anyone else
    who tries to get this lock is going to be denied。 Right。 That's all it's doing。
    It's not packaging up a data structure。 It's saying nobody else can touch it。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以这里发生了锁定。好的。你只需要记住，锁并不关心有什么数据结构存在。它不知道。它并没有说你不能触碰这个数据结构。它只是说任何尝试获得这个锁的人都会被拒绝。对吧？它只做这件事。它并没有封装一个数据结构。它只是说没有其他人能触碰它。
- en: It's just saying hey， if you're going to try to get my lock you're not going
    to be able， to。 So it's very abstract in that case。 Right。 It's just saying nobody
    goes past this line until the lock is unlocked。 That's the end of the story there。
    Okay。 All right。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是在说，嘿，如果你要尝试获得我的锁，你是无法得到的。所以在这种情况下，它是非常抽象的。对吧？它只是说没有人可以跨越这条线，直到锁被解开。这就是故事的结尾。好的，明白了。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_46.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_46.png)'
- en: Good question。 Does that answer it for you there？ Doesn't it doesn't affect
    the actual。 so it doesn't， the manager can go and do whatever it。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。这个回答能帮到你吗？它并不会影响实际操作。所以不会，经理可以去做任何事。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_48.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_48.png)'
- en: does with that data structure at that point because it doesn't need to lock。
    Now if it was。 if two threads were trying to update that data structure then you
    would。 need to lock and then only one would be able to do it based on your logic
    around locking。 So it might go a whole block if the tries to modify it or it can
    go？ No。 You will get a note。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，数据结构的操作就不需要锁了。如果是两个线程尝试更新该数据结构，那么你就需要加锁，这样只有一个线程能够基于你的锁定逻辑进行更新。所以，它可能会进行一整块操作，直到它成功修改，或者它会怎么样？不会的，你会收到一个通知。
- en: If it tried to， if， very good question。 If the manager tried to update something
    here。 in fact it does， it actually updates the， it actually updates the， in Inspector
    Cohen。 we'll see that in a minute。 It updates the Boolean about whether or not
    it passed or not。 Perfectly able to do that。 The child or the， not the child。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试，嗯，非常好的问题。如果经理试图更新这里的内容，实际上它会更新，实际上它会更新检查员 Cohen，我们稍后会看到。它会更新是否通过的布尔值。完全可以做到这一点。这个不是子任务。
- en: the clerk is not going to look at that until after it gets， a signal， which，
    that case will be fine。 Everything will be updated and it will be fine。 Good。
    All right。 Other questions on this？
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 店员在得到信号之前不会查看它，在那种情况下会没问题。所有的内容都会更新，没问题。好的，其他关于这个的疑问吗？
- en: Sounds like you guys are starting to get this。 Great。 Okay。 All right。 Let's
    now， let's see。 Why can there only be one waiting clerk？ Because of that lock。
    That's the whole point of this。 that lock before。 All of the clerks would get
    there and go， "I can't do anything yet。"， Okay。 So let's look at the， this is
    the Inspector Cohen。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来你们已经开始理解了。太好了。好的。那么，接下来，我们来看一下，为什么只能有一个等待中的店员？因为那个锁。这就是整个问题所在。之前的锁，如果所有店员都在那儿，他们会说：“我还不能做任何事情。”好的。那么，让我们看看，这就是检查员
    Cohen。
- en: This is not too interesting except so basically sleeps for a while while it's
    inspecting the。 system and then updating inspection passed based on whatever the
    random number that comes。 back from get inspection outcome is and then it reports
    on whether it's approved or not。 and then ends。 That's all the inspect Cohen does。
    But again。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太有趣，基本上就是在检查系统时，它会睡一段时间，然后根据从 `get inspection outcome` 返回的随机数更新检查结果，并报告是否通过。然后结束。这就是检查
    Cohen 的全部功能。但再次强调。
- en: it does update the inspection passed very， uh， struct but that's perfectly fine，
    because no。 we know logically that no other threat is even looking at that right
    now。 Okay。 What it can't do by the way is you can't go to the customer， they can
    customer can't。 what if the clerk went and said， "Oh， I didn't get this to pass。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实会更新检查是否通过的结构体，但这完全没问题，因为我们知道从逻辑上讲，没有其他线程在查看它。好的。顺便提一下，它做不到的是不能访问顾客，顾客不能……如果店员去说，“哦，我没能通过这个检查。”
- en: I'm going to give it back to the customer anyway even though it's not a good
    inspection。"。 It's not like the customer can go check this because the customer
    should not have access。 to this because it's not， it's just between the， the manager
    and the clerk。 I might be stressing the analogy of it but that's the way that，
    that you wouldn't want the。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 即使检查结果不理想，我也会把它交还给顾客。"并不是说顾客可以去检查这个，因为顾客不应该访问它。这个只是经理和店员之间的事。我可能在强调这个比喻，但这就是你不希望顾客知道的方式。
- en: you wouldn't want the customer to have access to this because this number is
    going to change。 for every inspection passed is going to change for every Cohen
    that comes through。 And it's only one value and it's not like it's stored anywhere
    except after the。 or except while the customer and the manager， or the clerk and
    the manager care。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会希望顾客访问这个值，因为这个数字会发生变化。每次检查通过都会改变，每个通过的 Cohen 都会改变。而且它只有一个值，除了在顾客和经理，或者店员和经理关心的时候，它并没有被存储在任何地方。
- en: then it's updated again for the next one that comes through。 Single struct in
    this case。 Okay。 Why are there no locks needed here？ Because we already locked
    what we need to。 We logically know the only update is going to happen from the，
    uh， right here and the， and the。 and the clerk is not reading this value at all
    right now。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会再次更新，以便下一个通过的项目。这种情况下是单个结构体。好吧，为什么这里不需要锁呢？因为我们已经锁定了我们需要的部分。我们逻辑上知道唯一的更新会发生在这里，而且此时店员根本没有读取这个值。
- en: We know that based on our logic and that's sometimes the hardest thing to remember
    to。 solve to figure out。 Other questions to this one？
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这一点是基于我们的逻辑，而这有时是最难记住的东西。解决它，弄清楚。还有其他问题吗？
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_50.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_50.png)'
- en: Okay。 All right。 Now we're finally to the cashier。 Okay。 So again。 the cashier
    knows how many customers there will be during the day。 Um， a little weird。 Uh。
    in that sense， we could have again done something where we had a queue that kept。
    or this vector or a queue， probably a queue of， um， that eventually the cashier
    would， uh。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们终于到了收银员那儿。好了。那么收银员知道当天会有多少顾客。嗯，有点奇怪。嗯。从这个角度来看，我们本可以做一个队列来保持，或者说这个向量或队列，可能是一个队列，嗯，最终收银员会，嗯。
- en: get a signal that says there's no more people that are going to enter the queue。
    And then when the queue is empty， the cashier can go home。 We didn't do it quite
    this way。 Remember。 it's a final exam problem。 It's not like this was an assignment
    problem。 But， uh。 but that's that the cashier。 Now this is where it starts to
    get interesting for the cashier。 Okay。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 得到一个信号，表示没有更多的人会进入队列。当队列为空时，收银员就可以回家了。我们并不是完全按照这种方式做的。记住，这是一个期末考试问题，不像这是一个作业问题。但是，嗯。但就是这样，收银员。现在，这就是开始变得有趣的地方。
- en: The cashier does go in order。 Right。 The cashier goes from zero to the number
    of customers。 Okay。 And the cost， the first thing the cashier does is wait on
    the， uh， the waiting customer。 sell for it。 In other words， if nobody's there
    yet， don't do anything but just sit there and wait。 Okay。 Wait for that thing。
    Could you have maybe done it where they wait on the first one and then the signal
    comes in。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 收银员确实按顺序处理。对。收银员从零开始，到顾客的总数。好的。然后，收银员做的第一件事是等待那个，嗯，等待的顾客。换句话说，如果还没有顾客在那儿，就什么都不做，只是坐在那里等。好了。等待那个信号。你能不能做到先处理第一个顾客，然后信号才到呢？
- en: maybe。 That might have been another， another way of doing it。 But in this case，
    we just have that。 some affords is waiting on several。 Then what does it do？ Okay。
    It rings up the customer eye because anytime it's， when it gets that first signal，
    it knows。 that signal had to have the first one anyway， has to come from that
    first， uh， from that， first， uh。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也许。这可能是另一种做法。但在这种情况下，我们只有这个。某些资源在等待多个顾客。那么它接下来做了什么呢？好了。它结账了顾客，因为每当它接收到第一个信号时，它就知道。那个信号必须是来自第一个，嗯，来自那个，第一个，嗯。
- en: customer。 Okay。 And so it brings up the customer。 And then what does it do？
    Well。 it knows that that was the customer just rang up。 So it signals that particular
    customer through that customer semaphore to say you're not。 We have checked you
    out， go at your ice cream。 Okay。 And then it goes and does the next one。 Now。
    what could happen in the meantime if another customer has come in and is waiting，
    in the queue。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 顾客。好的。那么它就调出了顾客。然后它做了什么？嗯。它知道这是刚刚结账的顾客。所以它通过那个顾客的信号灯向该顾客发出信号，表示“你已经结账了，可以去拿你的冰淇淋了”。然后它就去处理下一个顾客。那么在这期间，如果另一个顾客进来了并在排队等待，会发生什么呢？
- en: well， this weight right here， this weight right here will blast right through。
    It'll blast right through that because another customer has already signaled。
    And this is different。 This is a difference between semaphores and signaling in，
    um， like a， uh， signaling in， processes。 The signal remember does what？ It's on
    a semaphore。 It just decrements or increments a counter。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个权重，正是这个权重，将会直接突破。它会突破，因为另一个顾客已经发出了信号。这就是不同之处。这是信号灯和进程中信号传递的区别。记住，信号是什么？它是在一个信号灯上。它只是递减或递增一个计数器。
- en: So there's some counter there that has been， uh， in the， in case of the signaling
    has incremented。 that counter。 And so by the time this weight happens， if another
    customer is already there， right。 through and handled the next customer immediately。
    Okay。 That's an important part right there。 Okay。 And then， uh， it signals that
    customer goes to the next customer， might have to wait if。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那儿有一个计数器，在信号传递的情况下已经递增。到这个权重发生时，如果另一个顾客已经在那儿，直接通过并立即处理下一个顾客。好了。这是一个重要的部分。好了。然后，嗯，它向那个顾客发出信号，去处理下一个顾客，如果有的话，可能需要等待。
- en: the customer's not ready yet。 Uh， if the customer is ready， then， um， then it
    will just go， the。 this will go right up， and ring up with that customer。 But
    it's doing it in order。 And that's the。 that's the important part here because
    this is kind of a cued up sort of， system。 Okay。 Once all it goes through all
    the customers it needs to goes home。 Okay。 Question。 Yeah。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 顾客还没准备好。嗯，如果顾客准备好了，那么，嗯，它就会继续，接着和那个顾客一起结账。但是它是按顺序进行的。这就是这里重要的部分，因为这是一个排队的系统。好的。一旦它处理完所有需要的顾客，它就可以回家了。好的。问题。是的。
- en: Good question。 How is it that it's doing it in order of the customer？ It's not
    only the order。 sorry， it's not when they arrive。 It's when they arrive to check
    out。 In other words。 the customer has gotten her ice cream cones and then she
    goes up to the。 cashier or goes up in the line， which may have other customers
    in it and stands there。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。它是怎么按顾客的顺序进行的呢？不仅仅是按订单的顺序。抱歉，不是他们到达的顺序，而是他们到达结账的顺序。换句话说，顾客拿到了她的冰淇淋蛋筒，然后她走到收银员那里，或者走到队伍前面，那里可能有其他顾客，然后站在那里。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_52.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_52.png)'
- en: At that point， let's go back quickly and look at what the customer， uh， what
    the， let's。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，让我们快速回顾一下顾客做了什么，嗯，嗯，看看，嗯，顾客做了什么。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_54.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_54.png)'
- en: see， this is what the customer was doing。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看，这就是顾客正在做的事。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_56.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_56.png)'
- en: Here's where the customer is doing this。 Remember。 the customer gets their place
    in line by checking the next place in line variable。 and then that's the， that's
    the signal it will end up waiting for。 Right？ Because it actually。 remember， here's
    where it does it。 It waits in its place in line。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是顾客正在做的事。记住，顾客通过检查队列中的下一个位置变量来获得他们的排队位置，然后这就是它最终会等待的信号，对吗？因为它实际上，记得，这里它是怎么做的？它会在排队的位置等待。
- en: And so the only way it can get in line is to go and get the next place in line
    and then。 update the counter so the next person line gets the next place。 It's
    kind of like taking that little bar at the supermarket and moving it behind your，
    groceries。 like， you know， the next person is going to be behind that， right？
    And that's what you're doing。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它排队的唯一方式就是去拿下一个位置，然后更新计数器，让下一个排队的人得到下一个位置。它有点像在超市里把那个小条形标放在你的商品后面，就像，你知道，下一个人会站在那个后面，对吧？这就是你正在做的事。
- en: You're like， oh， here's my place and then I'm going to put the bar behind the
    next one。 That's kind of what's going on with that， that update right here。 Okay。
    Other questions on that？
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你就像，哦，这是我的位置，然后我会把那个条形标放在下一个人后面。这就是那个更新正在发生的事情。好的。还有其他问题吗？
- en: Good。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_58.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_58.png)'
- en: Let's go back and look at， let's see， we did the manager respect on cashier。
    Okay。 Cashier。 cashier is done when they check every out in order。 Yeah。 Okay。
    You got it。 What was it？
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，看看，之前我们做了经理尊重收银员的部分。好的，收银员。收银员在检查每个订单时完成。是的。好的，你明白了。那是什么？
- en: Is this something interesting？ No， this is exactly what she was talking about
    waiting for。 Okay。 How does it know to wait in order？ Yeah。 The customer gets
    the ordering。 Because if we're updating the customers' array with their order
    and then we're just looking。 for that array in signal。 Yeah。 So it is， it is，
    yeah， this is， I mean。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么有趣的地方吗？不，这正是她所说的等待的内容。好的。那它是如何知道按顺序等待的呢？是的。顾客得到了订单。因为如果我们正在更新顾客的数组并记录他们的订单，然后我们只是在查看那个数组的信号。是的。所以它就是这样，是的，这就是，嗯，我的意思是。
- en: this is an interesting thing。 Way of doing this。 This function has no real idea
    how many， like。 which customer is where， except for the fact， that it's going
    through this loop。 And the only reason it gets through the loop is because it
    first has to wait for that semaphore。 for the waiting semaphore， which is， are
    there any customers？ Is really what it is。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的方法。这个函数并不真正知道有多少顾客，像是哪个顾客在哪儿，除了它正在通过这个循环。它之所以能通过这个循环，唯一的原因是它必须先等待那个信号量。就是等待信号量，意思是，是否有顾客在排队？这其实就是它的意思。
- en: And then as a customer comes through， the customer， when that signal happens，
    that gets documented。 again。 But if another customer comes in and gets incremented，
    and so if two customers come in。 it will be， high enough that you know there's
    two people in line。 And then that will go right through。 But it goes in order
    because of this for loop。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当顾客进来的时候，当信号发生时，这个过程就被记录下来。再来一次。但是如果有另一个顾客进来并被递增，假设有两个顾客进来，它就会足够高，表示队列中有两个人。然后程序继续进行。但因为有这个循环，它会按顺序执行。
- en: forces it to go 0， 1， 2。 And which one is it actually signaling？ It's signaling
    0， 1， and then 2。 based on that。 Yeah。 And remember， this program， there is actually
    very， very， very simple。 kind of thing。 And there is actually very little actual
    communication between the threads。 I mean。 it's really only the customer is just
    waiting for the signal。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 强制程序按0、1、2顺序进行。实际上它信号的顺序是怎样的呢？它是先信号0，再信号1，然后信号2。就是这样。对了，记住，这个程序实际上非常非常简单，基本上几乎没有线程之间的实际通信。我的意思是，顾客基本上就是在等待信号。
- en: And then that signal comes out of nowhere and it moves on。 You know。 it doesn't
    know what place -- it knows what place in line it is。 But it doesn't really care
    at that point。 It's just going， "I'm just waiting。"。 And then it gets a signal
    that's， "I'm done。 I can leave this store。"， So， yeah。 Good question。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后那个信号突然传来，程序继续运行。你知道的，程序知道它在队列中的位置，但此时它并不在乎。它只是等待，然后收到信号，“我完成了，可以离开这个商店了。”
    所以，是的。好问题。
- en: Okay。 Could we have handled the cashier， customer cashier if we handled the
    clerks manager without the array？
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。如果我们没有使用数组，处理收银员和顾客的事务时，是否还能处理好员工经理？
- en: Not really， right？ The problem is that we needed to do this in order。 So we
    need to have enough semaphores for each one to wait in their place。 Otherwise。
    if there was one semaphore， it would be -- there would be fighting going on when
    that signal came through。 And the person who came in last in line could all of
    a sudden be jumping up in front。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不太对吧？问题在于我们需要按顺序执行这一操作。所以我们需要为每个线程准备足够的信号量，让它们在各自的位置上等待。否则，如果只有一个信号量，就会发生争抢情况，当信号传递过来时，排在最后的人可能突然就跳到最前面。
- en: That wouldn't be so good。 We wouldn't like that at all。 Kind of like that one
    where a line of his grocery store ends up。 Somebody opens it up and the person
    in the back of the line goes straight to the other cashier。 And you're everybody
    else like， "Well， that's not the right order。"， Chaos。 That's it。 All right。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可就不好了，我们可不希望那样。就像超市排队的情形，排队的最后一个人突然走到另一个收银员那里。你和其他人会想，“这顺序不对。” 混乱。就是这样。好了。
- en: Any other questions on what the cashier is doing？ Okay。 So， we have -- so， yeah。
    we made -- we needed to do that。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于收银员的操作有其他问题吗？好吧。所以，是的，我们必须这么做。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_60.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_60.png)'
- en: The main function -- we finally made it to the main function here。 So。 the main
    function sets things up。 And let's see how it actually sets things up。 Okay。 It
    sets up the customers， the manager， and the cashier。 Remember。 it does not do
    anything with the clerks because the clerks happen in the customer --。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数 —— 我们终于到了主函数。好。主函数负责设置一切。让我们看看它是如何设置的。好。它设置了顾客、经理和收银员。记住，它没有做任何关于员工的事情，因为员工的操作发生在顾客那里。
- en: the customer somehow magically creates a clerk thread。 Okay。 That's how that
    works。 Okay。 So。 the customers -- the total cones order -- this is just for logging，
    basically。 It sets up here。 And then the customers -- we know how many customers
    are going to come in because we're。 writing this program。 Maybe that could be
    some other random number。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 顾客某种程度上神奇地创建了一个收银员线程。好吧，就是这样运作的。好。然后，顾客 —— 总订单的锥形数组 —— 其实就是用来记录日志的。它在这里设置。然后顾客
    —— 我们知道会有多少顾客进来，因为我们在编写这个程序。也许这可以是一个随机数。
- en: but that's the -- that's -- we did it as a constant。 Okay。 For each customer，
    what do we do？
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是 —— 就是 —— 我们把它做成了常量。好吧。对于每个顾客，我们该怎么做？
- en: We get how many cones they want。 That's where we determine how many cones each
    customer wants。 Then we set up a thread for each customer with the customer ID，
    basically， and with the number。 of cones they want。 And that's how each customer
    knows to go and get so many clerks -- one for each cone -- and。 then it passes
    on its own ID to the clerks and to the cashier。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到他们想要多少个冰淇淋。这就是我们确定每个顾客想要多少个冰淇淋的地方。然后我们为每个顾客设置一个线程，基本上是顾客ID，并且是他们想要的冰淇淋数量。就这样每个顾客知道去找多少个收银员——每个冰淇淋一个收银员——然后它将自己的ID传递给收银员和收银员。
- en: And then we actually just keep track of the total cones order because we want
    to report， on that。 All right。 We're going to have to join these at some point
    because they're all threads and they。 need to -- when they end we need to join
    them， we'll get there。 Okay。 Then we need one thread for the manager and one thread
    for the cashier。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实际上只需跟踪总的冰淇淋订单，因为我们想要报告这个。好吧，我们需要在某个时候加入这些线程，因为它们都是线程，而且它们——当它们结束时我们需要加入它们，我们会处理这个。好吧。然后我们需要一个线程给经理，一个线程给收银员。
- en: And we don't need to tell them anything。 At this point -- well。 we need to tell
    the manager -- the total number of cones ordered。 and the cashier will use the
    global constlet to tell how many customers there are。 So it doesn't need to be
    passed in。 Probably should have been in terms of the encapsulation question。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要告诉他们任何事情。此时——好吧，我们需要告诉经理——总共订购了多少个冰淇淋。这时收银员会使用全局常量来告诉有多少个顾客。所以不需要传递进去。可能应该考虑到封装问题。
- en: So notice that -- I noticed that the cashier gets joined before the manager。
    What's the idea there？
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以注意到——我注意到收银员在经理之前就被加入了。这里有什么想法吗？
- en: Is that on purpose？ Cashier gets joined for the manager。 I don't think it matters。
    Yeah。 I don't think these are irrelevant because they're both ending and they're
    ending and。 they're not coordinating and they don't really need to worry about
    it。 Yep。 [ Inaudible ]。 The max number of clerks is the total -- total cones ordered，
    yes。 Yeah。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是故意的吗？收银员在经理之前被加入。我觉得这没关系。是的，我觉得这些不相关，因为它们都会结束，它们结束了并且——它们没有协调，实际上也不需要担心这个。是的。[听不清]。最大收银员数就是总共订购的冰淇淋数，没错。是的。
- en: That's because we know that each clerk only makes one cone。 And no， that's not
    true。 Each clerk could make infinite number of cones， but it only makes one good
    cone。 It only makes one passed inspection cone。 So the other question。 Is it possible
    that the clerk signals before the manager is fun？
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们知道每个收银员只制作一个冰淇淋。不是的，这不对。每个收银员可以制作无限多个冰淇淋，但他只制作一个合格的冰淇淋。他只制作一个通过检查的冰淇淋。所以另一个问题是，是否有可能收银员在经理的任务完成之前就发出信号？
- en: Is it possible that the clerk signals before the manager is fun？ Sure。 Nothing
    happens then because nobody is -- that -- all that's happening when you signal。
    Remember。 this is not the same as signaling in a process。 This is just updating
    that semaphore。 And so the semaphore is going to get updated no matter what。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有可能收银员在经理的任务完成之前就发出信号？当然。那时不会发生任何事情，因为没有人——发生的只是你发出信号。记住，这和进程中的信号不一样。这只是更新信号量。所以信号量无论如何都会被更新。
- en: Who cares if there's a manager thread yet？ Unless the manager thread gets ready
    and checks that signal。 does it wait on that signal， it will move right on。 Yeah。
    Good question。 Like this is not signaling in the same sense。 It's too bad it's
    called signal in some sense because it's not really the same like I'm。 signaling。
    You're signaling the semaphore and then somebody else might be waiting on that
    semaphore。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 谁在乎是否已经有经理线程了？除非经理线程准备好并检查该信号。否则如果它等待这个信号，它会直接继续。是的。好问题。这个信号并不是在相同的意义上进行的。很遗憾它被称为信号，因为它并不完全像我那样发信号。你发的是信号量，然后其他人可能会在等待这个信号量。
- en: And so that's where the abstract signaling part comes in。 Good question。 Everybody
    else on this one？
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是抽象信号部分的作用。好问题。其他人对此有问题吗？
- en: So then what do we do after we -- so now here's the most interesting part。 And
    I already mentioned this a little bit。 The manager thread -- so the customers
    are just all spinning up and going about their。 business。 They're creating clerks
    and so forth。 The manager and the cashier。 the first thing they are likely to
    do is just wait。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在我们接下来做什么呢——现在这是最有趣的部分。我已经稍微提到过了。经理线程——顾客们只是都在启动并忙着他们的事务。他们在创建收银员等等。经理和收银员，他们最初可能做的事情就是等待。
- en: But they are already running and ready to go and they're just waiting for that
    one signal。 to happen and through the condition variable any and when that happens，
    boom， they go and。 they start respecting。 You don't have to spin up a thread and
    spinning up a thread takes a little time。 This is a good way。 This is going to
    set us up for that thread pool stuff we'll talk about as in two assignments。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们已经在运行并且准备好，只是在等待那个信号的发生。当通过条件变量任何时候发生时，啪，它们就开始工作，开始执行。你不需要重新创建一个线程，而创建线程会花费一些时间。这是一个很好的方法。这将为我们设置接下来讨论的线程池内容做准备，大约在两次作业后。
- en: from now。 We'll get to there。 And thread pools are a good way to make it so
    that you reduce the lag that comes with。 creating a thread。 There is some。 Okay。
    Then what do we do？ We join all of the customers。 Then we join the clerk and we
    join the manager。 I don't believe that matters what order those happen in because
    we're just waiting for them。 all to end。 That will mean that we don't end our
    program until that finishes。 All right。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到时候会讨论这个。线程池是一个很好的方法，可以减少创建线程时带来的延迟。确实会有一些延迟。好吧，那么我们该怎么做？我们先让所有顾客都完成任务。然后我们让职员和经理完成任务。我不认为这些任务的顺序有什么关系，因为我们只是等待它们全部结束。那意味着我们不会结束程序，直到所有任务完成。好的。
- en: There's a lot of code to look through。 Hopefully we did it in pieces so you
    got the feeling for whichever。 what they all did。 It was much better than me typing
    it all live。 That would have been a nightmare。 Any questions on the code so far？
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多代码需要查看。希望我们是分段讲解的，这样你就能理解每一部分它们做了什么。这样比我现场打字要好得多。那会是一个噩梦。到目前为止，关于代码有任何问题吗？
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_62.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_62.png)'
- en: What are the takeaways from this？ There's a lot going on here。 We made a big
    model。 Not even that big really， but it's a big enough model that there's lots
    of moving parts managing。 all the threads， waiting。 You do have to plan this out。
    This is not something you can just throw together and go， "Oh， now I need something。"。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从中你能学到什么？这里有很多内容。我们做了一个很大的模型。其实并不算很大，但足够大，有很多活动的部分需要管理所有线程、等待。你确实需要计划好这一切。这不是你可以随便拼凑一下，然后就说，“哦，现在我需要些什么”。
- en: You had to sit there and plant。 Trust me， Julie Zelensky， once you created this。
    must have spent some time going， "Okay， what do I really need here？
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须坐在那里种植。相信我，朱莉·泽伦斯基，一旦你创建了这个，肯定花了一些时间在想，“好吧，我真正需要什么？”
- en: I want all these things to happen。 I need some managers out there going to need
    a semaphore。 There's going to be another semaphore for the clerk and all I need
    to and whatever。 It's not like she just started writing code。 She's certainly
    planned this out to some extent。 Although I guess I know Julie enough to know
    she probably just did started， but she's good。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望所有这些事情都能发生。我需要一些经理，那里将需要一个信号量。职员也会有另一个信号量，我只需要这些，其他的都可以。并不是她一开始就写代码的。她显然已经计划过这一切。虽然我想我知道朱莉足够了解她，她可能只是开始写了，但她很厉害。
- en: enough to do that。 I'm not going to do that。 Anyway， you didn't even plan these
    things out。 This is not the only way to do it。 You could modify this model in
    a zillion different ways。 You could make it so that the clerks， there's multiple
    clerks that all are always spun up。 and then you get one in time。 That'd be a
    thread tool sort of thing where a clerk。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 足够做这些事情。我不会做这些的。无论如何，你甚至没有计划好这些。这并不是唯一的方法。你可以以无数种不同的方式修改这个模型。你可以让职员们一直被激活，然后你就能在某个时刻拿到一个。这将是一个线程池的类似实现，职员们。
- en: once they make a good ice cream goes， back in the pool and gets another one。
    Maybe you'd want a semaphore， some number of permits with the number of clerks
    that can。 do it at a time or something。 Who knows？ But you would do that。 If we
    had more than one manager。 we've already talked about the details of that。 That's
    going to not involve more structure。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们做出一个好的冰淇淋，就会回到泳池，再拿一个。也许你会想要一个信号量，或者一些许可数量来限制每次能处理的职员数之类的东西。谁知道呢？但你会这么做的。如果我们有多个经理，我们已经讨论过相关细节。那将不会涉及更多的结构。
- en: different structure， semaphores。 Then you could have done a main and then spun
    them up a little bit。 Yeah。 So I keep throwing around this thread pool thing。
    A thread pool is basically a number of threads that are all waiting to do a job。
    I think it's exactly like the farm where you have all those Python processes that
    are。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的结构，信号量。然后你可能做一个主程序，再稍微启动它们。是的。所以我一直在谈论这个线程池的东西。线程池基本上是一些线程，它们都在等待执行任务。我认为它就像农场那样，所有那些Python进程。
- en: still running on machines around the world。 You've got all those processes that
    are all ready to go。 waiting for something to do and， then boom， they do it。 They
    don't need to start anything else up。 You will see that into assignments。 You'll
    actually build a thread pool and see how it works。 But it's not really that complicated。
    You have a whole bunch of threads and then you say go but just do a wait and then
    I'll。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在全球范围内的机器上运行。你有所有这些已经准备好的进程，等待着做事情，然后轰的一下，它们就做了。它们不需要启动其他任何东西。你将在作业中看到这个。你实际上会构建一个线程池，并了解它是如何工作的。但其实它并不复杂。你有很多线程，然后你说开始，但只是等待一下，然后我就会。
- en: eventually signal you。 It's really all there is to it。 And then， yeah， that's
    the thread pool。 waiting around。 We want to avoid spinning up a thread， taking
    the time to do that if we can。 But for this program， we did it for the clerks
    or we didn't do it for the clerks。 We did it for the manager and the cashier。
    All right。 So that is the program。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最终信号会传达给你。这其实就是所有的内容。然后，嗯，那个就是线程池。等待中。我们想避免启动一个线程，浪费时间去做这件事。如果可以的话。但对于这个程序，我们是为店员做的，或者说我们并没有为店员做这件事。我们是为经理和收银员做的。好吧。这就是程序。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_64.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_64.png)'
- en: Let me actually show it to you in action。 Let's go find a terminal here。 Oops。
    Skip this version。 Need to go back to the cursor。 Skip this version。 Hang on。
    There we go。 Okay。 All right。 So we need to。 Let's see。 Are we in myth？ Yes， we
    are。 We need to go to 110 and spring。 Live lecture thread。 CPP。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我实际展示给你看。我们去找一个终端。哦，跳过这个版本。需要回到光标。跳过这个版本。稍等。好了。好的。所以我们需要去看看。我们在神话中吗？是的，我们在。我们需要去110和Spring。直播讲座线程。CPP。
- en: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_66.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd4f11fd1845e9f40df784abcfff8b8_66.png)'
- en: Okay。 In here， I've already created the ice cream parlor。 Let's see it go。 Now。
    this is going to go on。 It goes on and on and on and on。 If we kind of go up and
    see what's going on here， clerks starts to make ice cream cone。 zero for customer
    number seven。 Managers presented with an ice cream cone。 Clerk just spent 0。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。在这里，我已经创建了冰淇淋店。我们来看它的运作。现在。这个会持续下去。它会一直接着，一直接着。如果我们往上看，看看这里发生了什么，店员开始为顾客7制作冰淇淋锥形杯。经理拿到一个冰淇淋锥形杯。店员刚花了0。
- en: 287 seconds making an ice cream cone。 Right？ Et cetera， et cetera。 And it keeps
    going， keeps going。 keeps going， keeps going。 And you can kind of see， eventually
    it's going to keep going。 I don't know how many there is。 Okay。 So at the end
    here， what happens， well。 it says the managers presented with an ice cream， cone。
    And then the manager is done。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个冰淇淋锥形杯需要287秒。对吧？等等，等等。它会一直继续，一直继续，继续下去。你可以看到，最终它会继续下去。我不知道有多少个。好吧。到最后，这里会发生什么呢？嗯。它显示经理拿到一个冰淇淋锥形杯。然后经理完成了。
- en: Manager inspected a total of 333 ice cream cones before approving a total of
    27。 Terrible clerks。 it turns out。 Right？ Wasting a whole bunch of ice cream。
    90% of the ice cream is wasted。 Not good。 Not going to be in business very long。
    And then the manager leaves。 Right？ And then the customer。 the last customer here
    takes up position， let's see， 14 at the counter。 Why would that happen？
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 经理在批准27个冰淇淋锥形杯之前，检查了总共333个冰淇淋锥形杯。真是糟糕的店员。结果是这样的。对吧？浪费了大量的冰淇淋。90%的冰淇淋被浪费了。不好，不会做生意很长时间。然后经理离开了。对吧？然后最后的顾客。最后一位顾客在柜台上排队，看看，是14号位置。为什么会这样？
- en: How do we have customer tenting？ I don't know。 I'd have to look into that。 Why
    it's not position 10。 I'll flip it up。 I'll have to see。 Oh， I know why。 Because
    12， 11， 5， whatever。 they all happened before。 Turns out that it took the most
    time to make customer 10s。 which is not the order of customer， 10 gets in line。
    The order of customer 10 was the 14th cut。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何进行顾客排队呢？我不知道。我得调查一下。为什么它不是第10位。我会翻转一下。我得看看。哦，我知道为什么了。因为12、11、5，等等。它们都发生在之前。结果，制作顾客10的冰淇淋花费了最多的时间。而顾客的顺序不是这样，顾客10会排队。顾客10的顺序是第14次切割。
- en: the final customer to get their cones made， is what happened there。 Okay？
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最终顾客拿到他们的冰淇淋锥形杯，这是发生的情况。明白吗？
- en: And then the cashier has already run everybody up。 It took less time to ring
    them up。 I'm going to cashier good one。 Yeah。 [ Inaudible ]， Close。 The question
    was technically the cashier that the manager thread ends before the cashier。 The
    manager thread is joined after the cashier thread。 So if you want to think about
    it。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后收银员已经把每个人的账都结了。结账花费的时间更少。我给收银员打个好评。是的。[听不清]，好了。问题是，技术上来说，收银员的线程在经理线程之前结束。经理线程是在收银员线程之后加入的。所以，如果你想考虑这个问题。
- en: the cashier has to wave at the door before leaving。 Yes。 Although the thread
    is actually gone。 but all the cleanup for the thread has not happened， yet。 So
    I'm going to say the cashier。 the manager left their coffee cup on the table。
    Somebody has to go clean it up。 That's still there。 But the manager is long gone。
    All done。 Okay。 All right。 Feel free to look at this code， modify it。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 收银员必须在离开前向门口挥手。是的。虽然线程实际上已经结束了，但线程的所有清理工作还没有完成。所以我要说，收银员。经理把咖啡杯留在了桌子上。有人必须去清理。它还在那里。但是经理早就走了。一切都完成了。好的。好了。随时可以查看这段代码，修改它。
- en: check it out， try to make some other semaphore， changes， see what happens。 This
    is not a bad problem for our final exam。 If you want it， if this is the kind of
    -- now。 coming up with Hall， making it work is the， hard part， like for designing
    the problem。 so it's unambiguous。 But this is a pretty good problem。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一下，试着做一些其他的信号灯，做些更改，看看会发生什么。这对我们的期末考试来说并不是一个坏题目。如果你想做的话，如果这是那种——现在。设计Hall并使其工作是，最难的部分，就像设计这个问题一样。所以它是明确无误的。但这个问题还是挺好的。
- en: So I would really try to understand this if you go back to the slides， look
    at the code。 run the code， and you may see something similar on the final exam。
    We'll see you guys through the results。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你回去看幻灯片，看看代码，运行代码，我真的建议你要理解这一点，可能在期末考试中会看到类似的内容。我们会通过结果来见面。
