- en: P7：Lecture 7 Signals - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P7：第七讲 信号 - ___main___ - BV1ED4y1R7RJ
- en: Welcome to Wednesday。 Hope the assignment's going well。 I will go back to my
    office。 right after class today。 I guess you get the benefit of coming to class
    and， under hearing this。 I'll go back to my office today and then stay there for
    about。 45 minutes to an hour for anybody who has questions on homework。 I also
    have。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到星期三。希望作业进行得顺利。今天下课后，我会回到我的办公室。我猜你们有机会来上课，顺便听到这些内容。今天我会回到办公室，然后待在那里大约45分钟到1小时，供有作业问题的同学提问。我也有。
- en: off-sours tomorrow morning from 10 until noon。 So feel free to stop by Gates。
    201 if you want to go to my office hours。 And then of course there's regular。
    off-sours with the TAs this evening and tomorrow as well。 The assignment is due，
    tomorrow。 Hopefully it's going all right。 Remember this is a real file system
    you。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 明天早上10点到中午12点我会有办公时间。如果你想来我的办公室，请随时来Gates 201。晚上和明天也会有助教的常规办公时间。作业明天截止，希望大家进展顺利。记住，这是一个真实的文件系统。
- en: guys are actually looking at。 So all the little nuance parts to it。 Well that's，
    real life。 That happens in in real programs。 So you're getting a little bit， of
    a taste of that。 Let's see I put a joke up here。 The barman asks what the first。
    one wants to race and she's walking to a bar。 So I know it's hilarious isn't it？
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大家其实在看着这些内容。所以所有细微的部分。嗯，这就是真实生活。在真实的程序中确实会发生这种情况。所以你们正在体验这种感觉。让我看一下，我在这里放了一个笑话。酒吧老板问第一个人想和谁比赛，她走进酒吧。所以我知道，这个笑话太好笑了，不是吗？
- en: The so the joke is you always have to explain your jokes if they're not that，
    hilarious right。 So the joke is that this is a race condition。 We haven't really。
    talked too much about race conditions yet but we will start to see many many，
    race conditions。 We've seen a few here and there。 A race condition is simply when。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所以笑话是，如果笑话不够好笑，你总是得解释它。笑话的意思是这是一个竞争条件。我们还没有深入讨论竞争条件，但我们将会看到很多很多的竞争条件。我们已经看到了一些零星的竞争条件。竞争条件就是当。
- en: two things are happening simultaneously and you don't know and you can't predict。
    which one will actually get to where it's trying to go first。 That becomes an。
    issue if you're doing things like trying to wait for something to happen or。 rather
    not wait for something if you forget to wait for something to happen。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 两件事同时发生时，你不知道也无法预测哪一件会先到达它的目的地。如果你在等待某个事件发生，或者说如果你忘记等待某个事件发生时，这就会成为一个问题。
- en: and it may be out of order from what you kind of expected。 So you have to think，
    about that。 It makes programming concurrently tricky because you have to， think
    about that。 So today we're going to do a few examples where we're going to。 see
    race conditions and we're going to see one way of handling them。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与你预期的顺序不同。所以你必须考虑这一点。这使得并发编程变得棘手，因为你必须考虑这一点。今天我们将通过一些示例来展示竞争条件，并且会展示一种处理竞争条件的方法。
- en: Okay so this is what I introduced on Monday。 We're talking about signals now。
    Okay and signals are a way to send a message basically not even a message。 basically
    a way to say to another process something has happened。 You don't。 even get to
    say like any message itself。 The best you can do is you can actually。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我在周一介绍的内容。我们现在在讨论信号。好的，信号是一种基本上用于发送消息的方式，实际上并不是传递消息，基本上是一种告诉另一个进程某些事情已经发生的方式。你甚至无法传递任何具体的消息。你能做的最好的就是实际上。
- en: pass a signal number which is the actual signal that gets sent but you。 don't
    get any other information。 If you want to pass other information to the other。
    signal you have to do it in such a way that both processes have access to it。
    which generally would mean shared memory or a file or something like that and。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递一个信号编号，那个信号就是实际发送的信号，但你不会得到其他任何信息。如果你想向另一个信号传递其他信息，你必须以这样的方式进行，确保两个进程都能访问这些信息，这通常意味着共享内存、文件或类似的东西。
- en: that becomes a little bit trickier to do too。 So it's not like you have this。
    situation where you're just signaling another process and then being able to，
    tell it lots of stuff。 It's got to be a logic sort of thing like when this。 signal
    happens you're going to do this because the signal happened。 That's what。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做也会变得有点复杂。所以这不是一种简单的情况，你只是向另一个进程发送信号，然后就可以告诉它很多东西。这必须是一个逻辑上的过程，比如当这个信号发生时，你将会执行某个操作，因为这个信号发生了。这就是。
- en: that's what we're going to do。 We're going to see examples as we go through，
    this。 Okay a signal handler is a it's a function that you write that goes into
    a。 process and when that signal arrives or the process the signal handler gets，
    called。 Okay and the ones that we're going to focus on are when a child has。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要做的。我们会在整个过程中看到一些例子。好的，信号处理程序是你写的一个函数，它会进入一个进程，并且当信号到达时，进程的信号处理程序就会被调用。好的，我们要关注的是，当一个子进程出现异常时。
- en: some change of state when it ends when it stops when it's continued and we haven't。
    even talked about how you continue a child that stopped will get there and。 that's
    that's a function that you write and it gets called when that happens。 Okay all
    right the there are lots of different types of signals as we said。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些状态变化，当它结束、停止或者继续时，我们还没有讨论如何继续一个已经停止的子进程，我们将会讲到这一点。那是一个你写的函数，它会在那个时刻被调用。好的，没问题，正如我们所说，有很多不同类型的信号。
- en: there's signals that happen because something bad goes wrong like there you。
    divide by zero that sends a signal or if you try it if you do control C well。
    your program gets a signal that it actually can't block it actually is going。
    to kill your program generally there's some limited ways around that but that's。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有些信号是因为某些错误发生，例如除以零时会发送一个信号，或者如果你按下了控制+C，你的程序会收到一个信号，它实际上是无法被阻止的，通常会导致程序被终止。当然，也有一些有限的方式可以规避这种情况，但它有一定的时间限制。
- en: generally what's going to happen and there are other types of signals that you。
    can send that are user signals there's a couple separate ones that are specifically。
    for you to use for whatever purpose you want that's another type of signal。 Okay
    all right so as I said sick child is the one we're going to care the most。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会发生的是，还有其他类型的信号可以发送，这些是用户信号，有几个不同的信号是专门为你使用的，可以根据你的需要发送。这是另一种类型的信号。好的，没问题，正如我说的，生病的子进程是我们最关心的。
- en: about at least for this class and it happens whenever a child process of a。
    particular parent changes state and so we're going to be able to capture that。
    that is generally when we're going to want to do our weight PID for the child。
    to actually find out what happened to the child what did it just do did it and
    did。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 至少对于这门课来说，它会在某个特定父进程的子进程状态发生变化时发生，所以我们能够捕捉到这个状态变化。通常我们会在子进程的生病处理程序中看到等待 PID
    的操作。好的，我们通常会通过这种方式来获取子进程发生了什么，它刚刚做了什么，是否正常退出，或者发生了什么。
- en: it diad normally what happened to it so we're gonna generally see weight PIDs。
    inside of the sick child handler。 Okay the first one that we talked about is。
    this program that I'm going to just retype so that you kind of get the feeling
    or。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正常情况下，我们会看到等待 PID 的操作出现在生病的子进程处理程序中。好的，我们讨论的第一个程序，我会重新输入一下，这样你能更好地理解，或者说，感受一下它的流程。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_1.png)'
- en: you actually kind of see what it is kind of in more a little bit slower so you。
    can kind of process what's going on I know a lot of times I've run through code。
    really fast and you go I've never seen that before how can I even process it so。
    I'll try to like slow down a little bit in that sense more often and actually。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上是以一种稍微慢一点的方式来看待它，这样你就能处理发生了什么。我知道很多时候我快速地浏览代码，结果发现自己从没见过那段代码，根本没法处理它。所以，我会尽量放慢一点节奏，更多地去处理这个问题。
- en: type things out explain as I'm typing give you a second to process it and so。
    forth okay so let's start out we will write a main function this is the example。
    I talked about on Monday where you have this model of dad taking his five。 children
    to Disneyland and he lets them all go off and play they each play for。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧，我们将编写一个主函数，这就是我在星期一提到的例子，假设父亲带着五个孩子去迪士尼乐园，然后他让他们各自去玩，每个人都玩了很久。
- en: a certain amount of time and then they come back in the meantime dad sleeps。
    okay and I actually said something on Monday that I was very confused about。 and
    I figured out why it was because I hadn't typed the program in I'll when I。 get
    there I'll show you what what I'm talking about but in this case what we're。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它们会回来，在此期间，父进程会休眠。好的，我实际上在星期一说了一个我自己也很困惑的东西，后来我弄明白了原因，那是因为我没有键入程序代码。我到时候会给你展示我到底在说什么，但在这个案例中，我们会边打字边解释，给你一些时间来处理这些信息。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_3.png)'
- en: gonna do is we're gonna start out so let me a little higher on the screen here。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是从这里开始，让我把屏幕稍微调高一点。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_5.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_5.png)'
- en: there we go we're gonna do is we're going to start out here and we're just。
    gonna say print F let my five children play while I take a nap look if I was a。
    dad going to Disneyland I'd be on all the rides too so I don't know what he's。
    doing to take them in that but anyway that's what this dad is doing okay and。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们要做的就是从这里开始，我们就直接说`print F`，让我五个孩子玩，而我自己小憩一下。看，如果我是一个带孩子去迪士尼乐园的父亲，我也会去玩所有的游乐设施，所以我不知道他是怎么带着孩子去的，但无论如何，这就是这个父亲的做法。
- en: then we're gonna set up the signal handler by saying signal SIGCHLD by the。
    reason they left out all those like what they left out letters and things is。
    because it used to be that you had to have a certain file length or your。 certain
    name length limitation and so a lot of these names are really short and。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过`signal SIGCHLD`来设置信号处理器，省略了那些字母和东西的原因是，因为以前你必须遵循某种文件长度限制或者名称长度限制，所以很多这些名字都非常简短。
- en: kind of leaving out letters just because that's historical in this case so we
    are。 going to tell it what function we need to set as the signal handler in this
    case。 is going to be reap child okay and then we're going to start up all these。
    children processes okay so we're just gonna go for size TI equals zero I or。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以省略字母，是因为这在历史上是这样做的，所以我们将告诉它需要设置哪个函数作为信号处理器，在这种情况下。它将是`reap child`，然后我们将启动所有这些子进程。所以我们就直接用`size
    TI = 0 I or`。
- en: actually we'll start with one so we just get one two three four five I is less。
    than or equal to five I plus plus and then we are just gonna fork so we're。 gonna
    have this kind of we're not gonna actually capture the PID from the child。 but
    in this case we're just gonna say if fork equals zero that means we are the。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们从1开始，这样我们就能得到1、2、3、4、5，`I`小于等于5，`I++`，然后我们就会进行`fork`，所以我们不会实际捕获子进程的PID。但在这种情况下，我们只需要说如果`fork
    == 0`，这意味着我们是子进程。
- en: child that we're in this block we're going to sleep for three times the I guess
    I。 said kid before didn't I do it kid like this， yeah there we go sleep for three
    times whatever the kid index is index starting。 at one right sleep in this case
    is gonna emulate playing or whatever playing it。 is new and okay and then after
    the child wakes up from the sleep or finishes。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，我们将休眠三倍的时间，我想我之前说过“孩子”对吧？做成这样，是的，休眠时间是三倍的孩子索引，从1开始。在这种情况下，休眠将模拟游戏，或者说玩耍。好的，然后在孩子从睡眠中醒来或者结束后。
- en: playing we're just gonna say print F we're gonna say child and then because
    we。 used size T we have to use like ZU or something like that is tired returns
    to。 dad not data to dad there we go I guess it makes sense in computer science
    okay。 so there we go and I might need a press it quote on there all right and
    then we。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们就直接说`print F`，然后说子进程，然后因为我们用了`size T`，所以我们得用像`ZU`之类的东西，返回给父进程，而不是数据给父进程。好了，我想在计算机科学中这有意义，好的，接下来我可能需要加个引号，然后。
- en: are going to just returns here from the child okay so that's what's gonna happen。
    in the child we're gonna do that five times boom and they're gonna sleep for。
    three seconds six seconds nine seconds etc yeah probably thank you very much。
    how about kid thank you very much that would be a bad mistake probably would have。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在子进程中返回，所以这就是在子进程中会发生的事，我们会执行五次，砰，然后它们将休眠三秒钟、六秒钟、九秒钟，等等，是的，应该是这样，非常感谢。那么孩子们呢，非常感谢，不过那应该是个大错误，可能本来会有麻烦。
- en: gotten a warning I hope we'll see good catch all right so anyway that's gonna。
    be the five children starting up and just sleeping for a while okay and then。
    we're gonna have the parents in this case like the dad okay while numb children。
    done playing is less than K numb children whoops。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 收到了一个警告，我希望没问题，继续，好的。所以不管怎样，这将是五个孩子启动并休眠一段时间的情况。然后我们会有父母在这里，比如父亲，好吧，当孩子们玩得还不够时，我们将会做一些处理。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_7.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_7.png)'
- en: hang on oh no I knew I'd do something like this I tried to do a special like。
    special command and of course it's not working no oh no hang on match one of 76。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，哦不，我知道我会做这种事，我试图做一个特殊的命令，结果当然它不工作了，哦不，等等，匹配 1 个 76。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_9.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_9.png)'
- en: how about we know one oh oh no what have I done let's sit right again I wonder
    if any。 of that got saved let's see we'll find out I don't think I saved it anyway
    spring。 and let's see it's live lecture processing let's see it did get a swap
    file。 let's see if we can recover it five children see and looks like it doesn't。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_11.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: want to play there goes okay what does it say it says file swap owned by that。
    another program edit in the file I want to recover it enter okay so I got saved。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_13.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: anyway it looks like most of it did okay well anyway all right let's try this。
    again I won't try to be fancy on this so in this so we got the everything in。
    there for the parent or for the child and then the parents going to do while。
    num children what's the name of the variable there it was num children done。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_15.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: playing children done playing is less than okay num children all right so what
    are。 we going to do we are going to print F at least one child is still laying
    so dad。 nods off okay and then the other day we use when in fact in earlier in
    this。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_17.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: program we used sleep I don't know if you remember that when I said that hey
    it。 looks like the dad is waking up or is not waking up when he should be and
    I。 thought that was because sleep should sleep normally stop sleeping at the。
    point where a signal is handled actually or I guess is not handled but anyway
    it。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: does if a signal happens sleep will generally return what we want to do is。
    we want to actually have the dad not wake up so we're gonna say snooze which is
    a。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_19.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: little function we wrote that just basically does this and says don't wake。
    up if you get a signal okay so that's what we wanted to snooze for five。 seconds
    and then print F dad wakes up that and there we go and then when you get。 all
    the children back we're just gonna say print F all children。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: accounted for good job dad nothing like that and then we're gonna return to。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_21.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: her okay so that's our function let's just run it okay make five children okay
    and。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_23.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: when we run this right what it does is it does all those that forking and then。
    dad nods off child one returns after three seconds dad wakes up child's two and。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_25.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: and then goes back to sleep child two and three wake up while dad sleeping in。
    that next five seconds and then dad goes back to sleep again and then child four。
    and five also wake up a return rather and then that's it so what did I forget
    to。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_27.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: do I forgot to write the function that actually does anything right so let's。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_29.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: see you know this one I want to delete it there we go okay so in this case let's。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_31.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: see actually hang on one side jump yes no it doesn't say it's in there anyway。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_33.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_34.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: okay so we have to actually write reap child well this is gonna be a really。
    simple reap child in this case okay all it's gonna do it's going to clean up。
    after the children so it's gonna be wait PID all right and then negative one says。
    wait for any child okay no because we don't care about capturing the return。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: values at this point or not you would if you were doing this for a little more。
    robust program and then zero which we'll get to changing that today actually just。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_36.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: basically says just block until that child returned but it's going to have。
    just ended because that's why the signal handler got called okay and then at。
    this point we need to update the num was it again num children done playing okay。
    and then that should do that now this signal handler is in the parent and it's。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: getting called when the child ends okay that's how this is getting called question。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_38.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: if you didn't write the wait PID there that's a good question all that would。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_40.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: really happen is it would it would be as if you were leaking the memory I mean
    you。 wouldn't clean up after the child nothing else would actually happen in that
    case。 and it would still actually work we can test if you want that's it any other。
    questions on that let's see if this one works now I just made it five children。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: there we go okay so same thing again waiting for three seconds and then returns。
    to dad that wakes up two more children are going to end in the next five。 seconds
    and then finally the last two children and and then dad wakes up and。 then we
    can say that all children are accounted for okay so that's what's。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: happening the the main parent or the parent function is in that while loop but。
    just sleeping for five seconds and the signal handler is happening and when the。
    gets when the dad gets done sleeping because hey all my children back I'm。 relieving
    question so if you didn't write the rep child function dad。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: just keep waking up yes that's exactly what we did when I didn't write that
    the。 question was wait if you didn't write the rep child or function what would
    it what。 would happen the dad would keep waking up and then that global variable
    wouldn't be。 updated so it would just stay at zero as it turns out yeah yeah。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: yeah good very good question when you call us when you when you call the。 signal
    function you are passing in a function pointer to reap child good。 correct well
    you don't you generally don't need to give it arguments it's a。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_42.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: good question but you don't need to when you say signal all it needs to know
    is。 reap child there there's only one argument that reap child must take and。
    it happened to be an integer for the signal number cleaning up after the。 children
    does not do that and the good question like you're saying why why does。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: cleaning up after the children make it happen it's this that makes the dad。
    because that's a global variable that is being updated by the signal handler。
    all right now if you're thinking wait a minute I thought children and parents。
    have different memories and so if I update the global variable here it's not。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: gonna update the parent remember it's not had none of these this function is。
    not happening in the child this function is happening in the parent when the。
    child ends so it in fact is the same global variable okay all right so that's。
    what happens here what if we so just change it here what if we change。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_44.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: something and say let's let all the children sleep for the same amount of。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_46.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: time okay so in other words they're all gonna go out and play they're all gonna。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_48.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: come back the exact same amount of time let's find out what happens if we do。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_50.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: this five children okay so now same thing's gonna happen they all come back
    at the。 same time maybe in some other different order right dad wakes up and then
    five。 seconds later dad wakes up again and we got all the children back but somehow。
    numb children done must not have been updated correctly okay let's actually。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: see what happens let's look at this again like this let's do this in the。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_52.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: SIGCHI in the handler let's just do this print F numb children done playing
    like。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_54.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: that and see that should do it and it is going to be numb I'm gonna try this。
    again up that time work okay all right and then that should do it okay so new。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_56.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: children there we go all right and so let's see what happens oh well it looks。
    like four of them seem to have come back all at once and called that signal。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_58.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: handler once it turns out that if children end at roughly the same time。 this
    is by the way out this is a kernel race condition and this is how the。 kernel
    handles it if a bunch of children end at the same time the kernel。 will take well
    we'll just say fine I am going to call one instance of the。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: child handler function you get to deal with whether or not like how what what。
    that the ramifications of that is okay so it's kind of a race condition in the。
    sense that in this case four of them were handled by only one child handler。 process
    like happening at the same time the the nice thing about it is that if。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: you are already in the child the signal handler and another child ends it will。
    call the signal handler again so it's not that it you lose any children it's。
    just that you have to deal with all the ones that have ended already immediately。
    okay and you have to do that inside the child handler we'll see how that goes。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: yeah question exactly so that so the question the comment is a。 perfect comment
    the comment was it's not that the children are ending and not。 being processed
    and not hand like the signal handler is not getting called。 them it's that they're
    all coming in at the same time the function is only getting。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: called once and therefore when when and they've already ended and that function。
    only ends up incrementing non children done once what we can do is we can。 modify
    our program to actually say all right well maybe if all those children。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_60.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: are if all those children have ended when the signal handler just happens let's。
    do this while true inside our signal handler okay I'm gonna get rid of this。 for
    now just so we don't because we don't need that right now okay when the。 while
    true okay what we're gonna do is we're gonna wait for all of the children。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: okay and if the return value for wait PID which normally is the child that was。
    just waited for if it returns negative or if it returns negative one there or
    I。 guess a negative number it means that there are no more children waiting in。
    that one like thing now if another one happens to end it will call the signal。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: handler again okay so it's not like you have to kind of keep waiting and maybe。
    it's happened there's no more rates conditions in that case okay so what you。
    need to do in this case is you need to say well our better capture the PID for。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_62.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: this right and if PID is less than zero we're just gonna return okay so we're。
    basically gonna break out of the while loop after we've now handled all over。
    the potential children that may have ended in that case okay question it's not。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_64.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: less than one for the last child it's that we're recalling we're gonna call。
    wait PID again there are no more children that have to end therefore wait PID。
    says there's no more children that have that have ended now therefore we're。 going
    to we are going to return this will well this will every for every child。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: that's ended in this little loop here right it's going to stay in that loop。
    until until it says no more children are left that's what's happening here you。
    not get that if they finish at the same time that's okay but we've got a while。
    loop that's gonna get the first one then the second one then the third one then。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: the fourth one is keep gonna keep going in the while loop and just keep asking
    and。 one of them will end up being the one that the wait PID captures we don't
    know。 which one one of them will then we'll go through the while loop again and
    it will。 return a PID so we'll go oh we're not gonna break we're then gonna go
    do it。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: again and do it again and do it again until all the children are captured okay。
    still don't get it you have a question about go ahead think of a question yeah。
    so read child is getting called， that doesn't necessary so but wait PID is getting
    called multiple times until all。 the child children have been fixed yes wait PID
    is getting called well wait。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: PID is getting called once when one when any child ends and then we're going
    into。 this while it's going oh let's keep waiting for children until there are
    no。 more left okay and then we're gonna end question about yeah that is a good。
    question it in this case the way we were running it right now it blocks while。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: there are still children not done so it will wait yeah it'll actually wait for。
    all them to be done now they're all gonna come back in roughly the same amount
    of。 time in this case but that's a good point and we'll see how to handle that
    in a。 second if you want to deal differently husband okay all right okay if you're。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: still well well let's see what happens when we when we run this and okay five。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_66.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_67.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: children okay now it's going to go into that while loop they're gonna return
    to。 dad all five of them end up getting captured it in the in that while loop
    and。 then dad wakes up and it did increment all got five of their。 incremented
    numb children done each time yeah yeah very good question in this。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: case the signal handler it turns out that the signal handler is called once
    as。 it turns out it may get called again although it doesn't matter it doesn't。
    actually matter because we're calling wait PID remember what wait PID does and。
    this is a very good point in this form when we say wait PID like this when we
    say。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: wait PID like that what it says is okay wait for any child to finish if there
    are。 outstanding children to finish like if there's any children out there wait
    for。 any one of them to finish okay and it will actually block until a child finishes。
    if there are no more children because they're all already finished it will。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: return negative one immediately and that's when we'll break out of that loop。
    yeah let's do that this old college says whoa wait a minute what if we made the。
    following change and just said oh let's see if our new method which we proved。
    works for the other the one where they're all ending at the same time what if
    we。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: did this now what's gonna happen and the his comment was oh is it gonna mean
    that。 we're never going to like it's and we're not gonna see all that dad wakes
    up。 business until way at the end let's find out all right now the child's playing。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_69.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_69.png)'
- en: remember now they're doing three seconds each right okay child one returned
    after。 three seconds child two returned after three seconds dad still hasn't woken
    up。 yet child three return child for return dad still hasn't woken up in fact
    dad's。 trying to wake up but guess what the signal handler is the part of the。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，现在它们每个子进程执行 3 秒，对吧？好的，第一个子进程三秒后返回，第二个子进程三秒后返回，父进程仍然没有醒来。第三个子进程返回，第四个子进程返回，父进程依然没有醒来，事实上，父进程在尝试醒来，但猜猜看，信号处理程序是执行的部分。
- en: program that's running it will not also it's only one process now even though。
    there's two functions that could happen the signal handler is the one that's in。
    this while loop and the dad never has a chance to actually wake up and see if。
    the children have ended yet so yes we broke this one by doing that fancy。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在运行时，它也不会，实际上现在只有一个进程，尽管可能有两个函数会发生，但信号处理程序是位于这个 while 循环中的，而父进程没有机会醒来，检查所有子进程是否已经结束。所以是的，我们通过做这些花哨的操作破坏了这一点。
- en: while we got to do something else yeah， yeah the question is is the signal handler
    running on the call of when the。 first child ends it could be the first or it's
    in this case it is the first。 because they are ending at different times it could
    be many ending at the same。 time calling it once but in this case yes the signal
    handler starts when the。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得做些别的事情，是的，是的，问题是信号处理程序是否会在第一个子进程结束时运行，这可能是第一个，或者在这种情况下确实是第一个。因为它们在不同的时间结束，可能有多个子进程同时结束，只调用一次，但在这种情况下，是的，信号处理程序在这个时候启动。
- en: first child finishes and then it doesn't know it never leaves the signal handler。
    until all of them finish this is actually not good programming you want。 your
    signal handler to be fast if you did one oh seven e you know that's true。 about
    interrupts this is basically the same sort of thing you want your signal。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个子进程结束后，它就不知道，直到所有子进程都结束，它才会离开信号处理程序。其实这并不是一个好的编程方式，你希望信号处理程序尽量快。如果你做了 107e，你知道这对于中断来说是对的，这基本上是相同的道理，你希望你的信号处理程序能够迅速完成。
- en: handler in and out as fast as you can so you don't want to wait for all those。
    other children remember the dad had job to do the dad was supposed to wake up。
    and say oh I'm gonna see if all my children are back but he couldn't until。 all
    the children got back right so that's the big that's a big problem， yeah。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序进进出出要尽可能快，所以你不想等待其他子进程，记住，父进程有事情要做，父进程应该醒来并说：“哦，我要检查一下我的所有子进程是否都已经结束了”，但他不能，直到所有子进程都结束了才行，对吧？所以这是一个大问题，是的。
- en: no no good quite good question has it does the is the weight PID called before
    or。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不，不好，非常好的问题，它是否是在调用 `wait PID` 之前，还是之后？
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_71.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_71.png)'
- en: after the child ends it is called because the child has ended okay so。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在子进程结束后被调用，因为子进程已经结束了，好吧，所以。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_73.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_73.png)'
- en: in other words reap child gets called when the child has ended and it has not。
    been cleaned up yet there's no way so the operating system is basically saying。
    oh this child has ended well I'm gonna wait around until somebody cleans it up。
    until the parent cleans it up and so it's it's in the process of being finished。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`reap child` 会在子进程结束时被调用，而子进程还没有被清理干净。没有办法，所以操作系统基本上在说：“哦，这个子进程已经结束了，好吧，我等着，直到有人清理它，直到父进程清理它”，所以它是在被处理完成的过程中。
- en: but the child hasn't been cleaned up yet that's why it gets the PID returned
    at。 that point yeah question if we print it out here。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但子进程还没有被清理，这就是为什么会返回 PID 的原因。对吧？问题是，如果我们在这里打印出来呢？
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_75.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_75.png)'
- en: yeah let's see what happens when we do that all right what it's gonna do it's。
    going to when each child gets back it's going to just do that right because it。
    by the way it's still inside the loop right it's still inside that while loop。
    not leaving that while I'll show it to you again and then then we'll see let it。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，让我们看看当我们这么做时会发生什么，好吧，它会做什么呢？它会在每个子进程返回时，就执行这个操作，因为，顺便说一下，它仍然在循环内，没离开那个 while
    循环。我再给你展示一次，然后我们再看，看看它会怎么样。
- en: finish here and then let's see there we go okay so it's still in this while
    loop。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这里，然后我们看看，好吧，仍然在这个 while 循环里。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_77.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_77.png)'
- en: remember forever true while true it's in that while loop until weight PID returns
    a。 negative number saying there are no more children left and in this case that's。
    really not what we'd like to do it's not the best coding style because we're。
    staying in that child that signal handler until they all finish what if。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，永远是`true`，一直在那个while循环中，直到`wait PID`返回一个负数，表示没有更多的子任务了。而在这种情况下，实际上我们并不想这么做，这不是最好的编码风格，因为我们会一直停留在那个子任务的信号处理程序中，直到它们都完成。如果有一个任务需要持续好几天，那其他程序就无法做任何事了。所以不应该一直待在信号处理程序中这么长时间，对的。其他等待返回的子任务在返回时，会再次调用这个子任务。
- en: one was supposed to go on for days well the rest of the program wouldn't be
    able。 to do anything so you shouldn't stay in the signal handle that long yeah。
    when the other children that is waiting for it to return when they do return。
    is they call the child again yeah this is a good question when I believe it。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好问题，我相信它会的。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_79.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_79.png)'
- en: does as it turns out call reap child again yeah I mean let let's do that let's。
    let's let's find out let's see if we can test this I'm not 100% sure this is gonna。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如结果所示，确实又调用了reap child。对啊，我是说，让我们试试吧。让我们看看能不能测试一下，我不完全确定这会成功。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_81.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_81.png)'
- en: do anything but let's test this reap child just called okay I think the question。
    was what happens if they've been cleaned up in here does another signal get。 generated
    I believe it will I'm not a hundred percent sure once it's cleaned up。 it might
    be removed from the it probably is it's probably once it's cleaned up it。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不做任何事，但让我们来测试一下，reap child刚才被调用了。好的，我想问题是，如果它们在这里已经被清理了，是否会再次生成信号。我相信会的，我不是百分之百确定，一旦被清理，它可能会从中被移除，应该是的，可能在清理之后它就会被移除。
- en: goes oh I don't need to send another signal because it's been cleaned up I'm。
    guessing that's the case well let's just let's just find out okay let's see how。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看来哦，我不需要再发送另一个信号，因为它已经被清理了。我猜是这个情况。好吧，我们就让我们来看看吧。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_83.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_83.png)'
- en: many times is so we actually need to do here is we also need to let's say all。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候是这样的，所以我们实际上需要做的是，我们也需要说所有。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_85.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_85.png)'
- en: children are counted for let's just see if there's any other issues maybe down。
    here later so let's do another let's do another shoes for like three more。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子任务已经被计算了，我们就看看是不是还有其他问题，可能在下面。好吧，让我们再做一次测试，做三次。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_87.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_87.png)'
- en: seconds or something like that okay make five children children okay so boom。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟或者其他什么事情，好的，创建五个子任务，孩子们，好的，开始了。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_89.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_89.png)'
- en: reap child just got called now it's gonna be in reap child not calling it。 again
    until all five get done we know because it's in that while loop and it's。 just
    gonna sit there and do that okay and it can't and it doesn't you can't call。 the
    same signal from inside this there it goes again it did get called again so。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: reap child刚刚被调用，现在它将在reap child中，不会再调用。直到所有五个任务完成，我们知道它会因为在那个while循环中，而一直停留在那，继续执行。好的，它不能也不允许你从这里面调用相同的信号。它又去了，它确实再次被调用了。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_91.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_91.png)'
- en: yeah it looks like it got called for once more because every all those children。
    that triggered it so I was wrong it does get called at least one more time now
    it。 didn't matter because that what would go into that while loop and it would。
    immediately say there's no more children goodbye and that's it so there's some。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对，看起来它确实被再次调用了一次，因为所有那些子任务都触发了它。所以我错了，它确实至少会被调用一次。现在这并不重要，因为它会进入那个while循环，并且立即说没有更多子任务了，拜拜，就是这样，所以有一些情况是这样的。
- en: logic there you have to handle yeah good question the SIG the signal parameter。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑是你必须处理的，对的，问题是SIG，也就是信号参数。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_93.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_93.png)'
- en: I'm gonna get rid of some of these things because we're gonna change it again
    in a。 second the signal here over here that parameter all it says in this case
    is。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算去掉其中一些东西，因为我们很快会再次修改它。这里的信号参数，它说的是在这种情况下。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_95.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_95.png)'
- en: that it's a SIG child that's the only thing gives you doesn't give you any。
    other information just says which signal you could ask which signal that。 called
    I mean you basically look at that go is it the SIG job yes that's it maybe。 we
    maybe we want this to be an encompassing function to capture many。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: signals and maybe you want to know which signal actually triggered it so that's。
    how you do that yeah， be careful do you mean reap child's called right here it
    is not called there。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_97.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: this is just simply calling signal with a function pointer to reap child saying。
    when a child ends that's when reap child gets called that's a good question。 it
    may be the case that the rest of them haven't been created yet by the time。 you're
    right in this for loop here if we had made it sleep zero or no sleep at。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: all then it might have jumped into the loop and then it would have done but
    it。 still would have worked okay because let's say it didn't have any children
    at。 that point it would have exited the reap child but then the next child would。
    have gotten created and it would have gone back and called so I mean it's not。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: like anything would have broken in that case but you're right it could have
    been。 that we ended up in reap child before any of the other children were created
    but。 it's still going to get called later when they do get created and then eventually。
    finish good lots of good questions here glad I'm going over this again or at least。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_99.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: this part of here okay so what do we want to do in this case so now we've got。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_101.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: this problem here remember we've got that we've changed the behavior by adding。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_103.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: this this while loop up here okay we've said wait block until all the children。
    are done and if we've got five children outstanding then it's going to sit there。
    and block until all the children are done and that's not what we want we want。
    the signal handle will be in and out really quickly that's the basic idea so。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: it turns out that we will finally get a chance to use this final parameter for。
    wait PID okay this parameter there's a bunch of flags you can put in there you。
    just order them together one of the flags that we care about and in fact。 specifically
    for this is called double you no hang and double you no hang is a。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: flag that says wait for any child except if there are none that are finished
    just。 return immediately with a return value of zero so it said that means a return。
    value of zero means that there are children remaining but have not ended。 yet
    but I'm gonna return now because you don't I don't want to block on this I。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: don't want to stick around waiting for those in this while the only other thing。
    we have to change here is we have to say oh fine if PID is less than or equal
    to。 zero because if the zero case there are still children but they're still going。
    so I'm not gonna stick in or stick around and try to wait for them I'm gonna come。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不想等着那些在等待中的子进程。唯一需要改变的地方是，我们必须说，如果PID小于或等于零，因为在零的情况下，子进程仍然存在，但是它们还在运行。所以我不会停在那里或者等着它们，我会继续。
- en: back later when they finish and and call this function that's what's going on
    here。 let's try this and see if it works five children okay five children so remember。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，当他们完成后再调用这个函数，这就是这里发生的事情。让我们试试看，看看它是否有效，五个孩子，好，五个孩子，记住。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_105.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_105.png)'
- en: now we've got this idea where we want the dad to wake back up after the first。
    two children okay we have to wait read children I'll take that out so you can。
    see what's going on in a second here but you can see that dad's waking up now。
    which is exactly what we wanted exactly what we had the very first one but now。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个想法，我们希望父进程在前两个子进程完成后能重新唤醒。好的，我们得等一下第三个子进程，我会把它去掉，这样你就能看到接下来发生了什么，你可以看到父进程现在正在唤醒，正是我们想要的，和我们第一次看到的完全一样，但现在。
- en: we're doing it in a way that we can capture in case all the some children end。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一种方式进行操作，这样可以捕捉到所有子进程结束的情况。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_107.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_107.png)'
- en: exactly the same time or roughly the same time okay let me just run it again。
    without this line in there anymore and we'll just see it work in general。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上在相同的时间或者大致相同的时间，好，让我再运行一遍，不再有这一行，我们就看看它一般是怎么工作的。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_109.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_109.png)'
- en: what questions do you have about this the purpose of W know hang we will use
    that。 very often okay and we'll use that because specifically because we want
    to。 keep our program going we don't want to sit there and go oh let's wait for
    the。 child let's wait around for the child let's do something else let the signal。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于W挂起标志有什么问题，我们会经常使用它，好的，我们会使用它，特别是因为我们希望让程序继续运行，不想坐在那里等待子进程，等待它们完成，而是让信号来处理。
- en: handler get called when the child ends and deal with it that question。 basically
    the flag just says don't like stop the program anymore just deal with。 them already
    ended whereas we did not like it was created。 yeah so the question is this flag
    or a comment is this flag W know hang it says。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当子进程结束时，处理程序会被调用来处理这个问题。基本上，这个标志表示不再停止程序，只是处理那些已经结束的子进程，而不是我们不喜欢它的创建方式。是的，问题是，这个标志或者说是注释，是不是这个标志W，它会挂起。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_111.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_111.png)'
- en: to the weight PID function if there is a child that's ended return that PID
    and。 clean it up if any of the children have ended return pick one of them clean
    it up。 and give me that PID back so I can do whatever else I want with it if there
    are。 no children that have ended but there are still children out there don't
    wait for。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于等待PID的函数，如果有子进程结束，返回该PID并清理它。如果有子进程已经结束，返回其中一个并清理它，给我那个PID，这样我可以做我想做的其他事情。如果没有子进程结束，但仍有子进程存在，别等待它们。
- en: one like we've always done in the past just return zero and say look they're。
    still there but I'm not gonna wait you asked me not to wait for that's what。 it's
    doing is well so the question is is there a queue of processes needs to be。 clean
    up yes I mean it's it's operating system specific and I don't know exactly。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们过去一直做的那样，返回零并说看，它们还在那里，但我不会等，你让我不要等待，这就是它在做的事情。问题是，是否存在一个需要清理的进程队列？是的，我是这么认为的，它是操作系统特定的，我不确定具体情况。
- en: how Linux does it but the operating system is part of this whole game when。
    the child ends the operating system says okay I I owe the parent a signal and
    it。 sends the signal whenever that child ends now if the parent has already ended。
    well then you know you don't want that but the in this case the parent we've。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是如何处理的呢，操作系统是这个整体过程的一部分。当子进程结束时，操作系统会说“好，我欠父进程一个信号”，并且每当子进程结束时，它就发送信号。如果父进程已经结束了，那么你就不想再发送信号了，但在这种情况下，父进程我们。
- en: made it so the parent will not end until all the children end but yeah that's。
    that's kind of what's happening the operating system saying I'm gonna build。 up
    a little queue of ended children and then I'll call wait PID when I need to。 lots
    of other questions yeah good question we don't know how many times。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做使得父进程不会在所有子进程结束之前结束，是的，基本上就是这样发生的，操作系统说，我要建立一个已结束子进程的小队列，然后在需要的时候调用 `wait
    PID`。还有很多其他问题，好的问题，我们不知道会调用多少次。
- en: reap child is called in general in this case because they're staggered three。
    seconds three seconds three seconds three seconds it's called five times。 because
    there aren't two that end at the same time anytime two or more will end at。 the
    same time it could only get called once and that's why you have to handle。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`reap child` 一般会在这种情况下被调用，因为它们是错开的，三秒钟，三秒钟，三秒钟，三秒钟，它会被调用五次，因为没有两个进程会同时结束。每当有两个或更多进程同时结束时，它可能只会被调用一次，这就是为什么你需要处理它们。'
- en: them all inside that because you may not get another call later and it's just
    a。 it's a race condition that's kind of built into the operating system and this
    is。 the the way they they said look you have to plan for if reap child gets called。
    maybe more than one child has ended you better deal that because we're not。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的子进程都要处理，因为你可能不会再收到另一个调用，这只是操作系统中内建的竞态条件，按照它们的说法，你必须计划好，如果 `reap child` 被调用，可能有多个子进程已经结束，你最好处理好这些情况，因为我们不会。
- en: gonna call it again in that case yeah so if we do go back to when multiple。
    well too convinced at the same time yeah， correct you would you would go through
    that so yes if two ended at the same。 time you would end up getting the called
    once probably and then it would go then。 this while loop here would go through
    the both of them and clean both of them up。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，是否会再次调用呢？是的，如果我们回到多个进程同时结束的情况，是的，正确，你会依次处理它，所以如果两个进程同时结束，你最终会得到一次调用，然后它会继续，然后这个
    `while` 循环会处理两个子进程并清理它们。
- en: and then find out that none have let know none of the others have finished。
    return zero and then you return from the function yeah no in this case remember。
    this was the status so we could have done in fact you normally should do。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后发现没有，其他的都没有结束，返回零，然后你从函数中返回。是的，在这种情况下，记住这是状态，所以我们本来可以做的，事实上你通常应该做的是。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_113.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_113.png)'
- en: something like this status and then you paste in status like that and it gives。
    you more information what was the return value of the child did it end up normally。
    was there some other there's lots of information that you've some of the more。
    information you get from that what status did it what how did it end did it was
    it。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的状态，然后你粘贴一个状态，像那样，它会给你更多的信息，子进程的返回值是什么，它是否正常结束，是否有其他的，里面有很多信息，从中你能获得更多的信息，状态是什么，怎么结束的，是否正常结束。
- en: stopped or rather did it end or was it stopped or was it continued that gives。
    you more information about that good questions yeah。 could I run it without which
    oh yeah you want me to run without the so they all。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 停止，或者说它是结束了，还是被停止了，还是继续执行了，它会给你更多关于这个问题的信息。好的问题，是的，我能不能在没有的情况下运行它？哦，是的，你是要我在没有的情况下运行吗？所以它们都会。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_115.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_115.png)'
- en: end at the same time sure let's see so if they all at the same time do that
    and。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同时结束，没问题，让我们看看，如果它们同时结束，那会发生什么。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_117.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_117.png)'
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_118.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_118.png)'
- en: see okay so remember they're all gonna go boom and after three seconds or。 whatever
    right boom they all ended dad finally wakes up and says oh they've。 all ended
    we're done and they got handled inside that good question right。 that's a lot
    of that's a lot of like stuff packed into one program a lot of。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看，这样记住它们都会发生，然后三秒钟后，或者其他的，对吧，它们都结束了，最后父进程醒来，发现它们都结束了，我们完成了，它们已经在那个里面得到了处理。好的问题，没错，这个程序确实包含了很多东西，是一个程序里有很多内容。
- en: different things going on but what we've learned now is well these signal。 handlers
    have some nuance to them they have some they have this ability to get。 called
    but sometimes it's a little bit like odd because two things could kind。 of call
    it at the same time so that's nuanced we've got wait PID which will。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了不同的事情，但我们现在学到的是，这些信号处理器确实有一些微妙之处，它们有一些能力可以被调用，但有时这有点奇怪，因为两件事可能会在同一时间被调用，所以这是微妙的，我们有
    `wait PID`，它会。
- en: wait for any children and you can use negative one for the first parameter to。
    wait for any of the children and now we've said yeah but what if we don't want。
    you to block and wait for that child we only just return immediately and we。 capture
    the information about that saying oh there's no if it's zero there are。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 等待任何子进程，你可以将第一个参数设置为负一来等待任何子进程，现在我们说了，但如果我们不想让你阻塞并等待该子进程，只是立即返回，我们会捕获关于这一点的信息，说明如果是零的话就没有。
- en: children still remaining that have not been captured yet okay now we didn't
    care。 if it was children still remaining or all the children are done because
    we just。 know that we're counting correctly so reap child will get called again
    if we。 haven't counted or if all the children are still remaining just because
    the。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然剩下的子进程，这些子进程还没有被捕获到。好吧，现在我们不在乎是否还有子进程剩下，或者所有子进程已经完成，因为我们知道我们正在正确地计数。所以，如果我们还没有计数，或者如果所有子进程仍然存在，`reap
    child`将会再次被调用，仅仅是因为父进程或该进程的父部分仍然在做自己的事情。
- en: main the parent program or the parent part of the process is do kind of doing。
    its own thing okay all right I know this I know there's a lot going on there but。
    do ask more questions and feel free to go run the code yourself if you want to。
    you can download it I didn't put it in the slideshow today I'm not sure if that。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我知道这里面有很多内容，但请随时提问，并且如果你想的话可以自己去运行代码。你可以下载它，我今天没有把它放在幻灯片里，不确定它是否包含了这个。
- en: screwed up my tablet or not but the other day but I'll try it again in the。
    future so anyway we went through all these different cases so I don't I don't。
    think we need to redo these because we did them kind of as we go along but feel。
    free to read the slides about that it's just basically going through exactly。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我搞坏了我的平板电脑，但前几天我会再试一次的。所以我们已经遍历了所有这些不同的情况，我不认为我们需要重新做这些，因为我们在进行时就已经做了这些，但可以随时阅读幻灯片，它基本上就是一一遍历所有情况。
- en: what we did live and you saw that we had some various cases where we needed
    to。 do more logic and different type of logic okay all right so let's see that
    I think。 it's that for there there are other flags besides W no hang there's also
    W。 untraced which is a weird name but basically what it means is block until a。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际操作过的，看到我们有一些需要进行更多逻辑判断的情况和不同类型的逻辑。好的，接下来我们来看一下，我认为到此为止。还有其他的标志，除了 `W no
    hang` 之外，还有 `W untraced`，虽然这个名字有点奇怪，但基本上它的意思是：阻塞直到某个子进程的状态发生变化。
- en: child process has either ended or been stopped and stopped is paused not ended。
    and we'll see lots of cases where they get paused if you use W untraced with W。
    no hang it removes that weight that blocking part it doesn't actually block。 in
    that case W no hang always says well I'm not gonna block but the other ones。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程要么已经结束，要么已被停止，而“停止”是指暂停，并非结束。我们将会看到很多这种暂停的情况，如果你使用 `W untraced` 和 `W no hang`，它会移除阻塞部分，它实际上并不会阻塞。在这种情况下，`W
    no hang` 总是表示“不阻塞”，而其他的选项则不然。
- en: W untraced is if it stops and then you also have W continued for the situation。
    where the child process has been stopped and then gets started back up again。
    your parent will also get a notice about that get a signal about that okay so。
    often we will see three of them together W untraced or W continued or W no hang。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`W untraced` 是指它已经停止，另外你还会有 `W continued`，用于子进程被停止后重新启动的情况。父进程也会收到相关的通知或者信号。所以，我们通常会看到三者一起出现：`W
    untraced`，`W continued` 或 `W no hang`。'
- en: and that just says look I want you to wait and return information about a。 child
    process that has changed any kind of its state not just ended not just。 continue
    not just stop not just continued and by the way don't actually block when。 you're
    doing that okay all right so that's the basic idea of signal。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是说，看，我希望你等待并返回关于某个子进程的状态变化的相关信息，不仅仅是结束，不仅仅是继续，不仅仅是停止，而是任何状态的变化，顺便说一下，在执行这些操作时不真正进行阻塞。好的，这就是信号的基本概念。
- en: handlers so far we have some more nuance and race conditions that we have to
    deal。 with going forward okay so we have to talk about some more synchronization。
    issues okay when you talk about signal handlers okay。 remember that the signal
    handler gets called when the whatever thing happens。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们已经处理了一些更加细微的竞态条件，接下来我们需要继续处理这些问题。好的，我们必须讨论一些更多的同步问题，特别是在讨论信号处理程序时。记住，信号处理程序会在某个特定事件发生时被调用。
- en: happens okay so the question came up earlier and said and somebody said what
    if。 what if the child process ends before the parent actually gets to something
    or。 whatever that could happen all right and you because of the way you write
    your。 code that might actually happen and it might not be what you want at least
    what。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: happens might not be what you want so we have to actually deal with this here's。
    what we're gonna do I'm gonna write another program and it's going to be。 basically
    a job list toward a program in other words we're gonna start up a。 bunch of programs
    using fork exec cvp like we've done before we'll start them。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: up and we're gonna add them to a job list now in fact you're gonna do this for。
    assignment for coming up not this week but next week you're gonna start you're。
    gonna do this coming up for that assignment and you're gonna have to do。 this
    because your shell does that whenever you type a command guess what the。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: shell takes that command and puts it into some list that it's keeping track
    of to。 know which programs are running that's what it's doing so that's what we're
    gonna。 do we're gonna run these programs three of them as it turns out and then
    we are。 going to every second by right we're gonna do it one second after the
    other。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: after the other and then we're gonna have a signal handler that gets that gets。
    called when the child state changes remember it always gets called in the。 child
    state changes and we are going to add it to this job list through the signal。
    handling okay all right and then the parent is also going to maintain well it's。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: kind of the parent is maintaining this job list is really what it is okay in
    fact。 we're not really maintaining it always printing it up okay let me show you
    the。 program and then we will see it in action okay this is gonna be called job
    list。 synchronization doc see and it's gonna be the fun again we'll write the
    main main。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: part first just to kind of show you what it's actually doing here okay I have
    I'm。 gonna call by the way the date function you haven't seen the date function
    before。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_120.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: it just does the date prints out the date okay so I'm gonna call the date。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_122.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: function and it's going to run that and then print it off the screen okay that's。
    all the date function is actually going to do okay and so what we're going to
    do。 is we're going to set up a signal handler signal SIG child and it's going
    to be。 in this case reap processes all right that's setting it setting up the
    setting up。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: the signal handler okay and then we are going to do what we call we are going
    to。 we are going to just actually we're not we're not we're gonna do this in a。
    minute right now we're just going to start the actual for loop to start the。 process
    so for size TI equals zero I is less than three in this case I plus plus。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: okay PID T PID equals fork okay if no why this is not okay there anyway all
    right。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_124.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_125.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: fork did I have I might have had a mistake in there so anyway if the PID is。
    zero means we're in the child okay what are we gonna do in there in this case。
    we are actually going to just call exes cvp okay and that's k arguments zero and。
    k arguments remember this is how X that VP works okay and that's that okay。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_127.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: remember that will not return if it works and we're gonna assume the date function。
    is gonna work in this case we're not doing any error checking in that case okay。
    and then we're going to sleep for one second okay which basically forces the。
    CPU or forces the parent off the CPU what do I mean by that I mean that it's。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: gonna tell the parent go to sleep and then the child is actually gonna get to
    do。 its thing if you have multiple processors this will probably happen。 anyway
    but in this case we're just forcing it to make the parent wait for a。 second why
    well who knows maybe this is a system where you know you're typing。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: commands in and it's waiting for commands to go whatever we're just we're。 for
    now we're just forcing it off the CPU and then we're going to print job。 percent
    d added to the job list and we're going to print the actual PID of the。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_129.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: child okay and then we're going to return zero and that's okay so everybody
    gets。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_131.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: what's going on here we're gonna start a process three processes the date command。
    it's going to we're gonna print out hey I've started these processes after one。
    second okay that's happening there in reap chai reap processes in this case。 okay
    what we're gonna do is we're still gonna do this while true because we don't。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: know we're almost always gonna do this from now on because we don't know how。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_133.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: many children have ended or have changed state okay and we're going to say。
    PID equals wait PID negative one no and W no hang because we don't want to wait。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_135.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: we don't want to block on these okay and then we're gonna say if PID is less。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_137.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: or equal to zero we're simply gonna break same exact things we did before okay。
    and then now we're going to if we were keeping track of this which you'll do for。
    assignment for we're gonna print job percent we're just gonna print it in this。
    case percent D removed from the job list okay so in this case what it's going
    to。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_139.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: do is when the job ends remember no hang actually in this case it's just just。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_141.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: when the job actually finishes okay it will say it's removed from the job list。
    when the child ends well why are we keeping in the job list let's remove it。 from
    the job list okay so again the parent is creating all these processes。 and putting
    it into the job list we're just putting it out but it's like putting。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务真正完成时，它会说从任务列表中移除了。子进程结束后，为什么我们还要把它保留在任务列表中呢？我们把它从任务列表中移除吧。所以再次强调，父进程创建了所有这些进程，并将它们放入任务列表中，我们只是把它们移出去，但这就像是放入…
- en: it into a job list when the child handle when the signal handler gets called
    for。 the child process it says oh the job is now removed from the from the job
    list。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当子进程处理完信号并调用信号处理程序时，它会说，哦，这个任务现在已经从任务列表中移除了。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_143.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_143.png)'
- en: okay let's run this and see what happens。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们运行这个看看会发生什么。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_145.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_145.png)'
- en: okay jobless synchronization all right it says job two three seven three five，
    which the P。I。D。 of the child removed from the job list and then it says job two。
    three seven three five added to the job list and then it says the date great。
    actually said the date first in fact because it had to end it said the date。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，任务列表同步。它说任务23735，也就是子进程的PID，从任务列表中移除，然后它说任务23735已被加入到任务列表，然后它说，日期好了。实际上，它首先说了日期，事实上因为它需要结束，首先会说日期。
- en: and then ended and then it did the same thing and then it says the next job
    was。 removed and then added and then removed and then added now you're probably
    saying。 yourself well that's kind of dumb the jobless here are they're being at
    they're。 being removed before they're being added right and you've got to say
    to yourself。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它结束了，做了同样的事情，接着说下一个任务被移除并重新添加，然后又移除再添加。现在你可能会想，自己说，这有点傻，任务列表中的项目在被添加之前就被移除了，对吧？你必须问自己。
- en: well why is that happening right well what did we do to make it happen that's。
    the bigger question yeah comment or question yeah we did this little sleep。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么会发生这种情况呢？我们做了什么让它发生的呢？这是更大的问题，对吧？评论或问题？是的，我们做了这个小睡眠。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_147.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_147.png)'
- en: for one second right well well when by the time it gets to that sleep the child。
    is already on its way and the date does not take more than one second to happen。
    it happens like instantly right when the date function is done command is done。
    it calls the signal handler all of that happens before one second is done now。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一秒钟，对吧？那么当它到达那段睡眠时，子进程已经开始了，而且日期函数的执行不会超过一秒，它几乎是瞬间完成的。`date`函数执行完后，命令也就完成了，调用信号处理程序，所有这些都在一秒钟内完成。
- en: you'll notice when I run it that one second actually doesn't happen by the。
    time it says it's because sleep does not wait that one second if I change the。
    snooze it would actually wait one second but in this case it just it just。 wakes
    up immediately in that case yeah very good question very good comment the。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到当我运行它时，实际上那一秒钟并没有发生。因为`sleep`并不会等待那一秒钟。如果我改变延迟，它确实会等一秒钟，但在这种情况下，它立即醒来了，没错，非常好的问题，非常好的评论。
- en: question and comment was wait wait if we remove sleep one wouldn't it still
    have。 this potential problem because you don't know if the date command is going
    to run。 faster faster than this command is going to get to absolutely like you
    don't know。 that and then we're purposely putting in this this sleep in here to
    say hey。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 问题和评论是，等等，如果我们去掉`sleep 1`，它是不是仍然会有这个潜在问题，因为你不知道`date`命令是否会运行得比这个命令更快，绝对是的，你不能知道这些，然后我们故意在这里加了这个`sleep`，是为了告诉大家，嘿。
- en: this is something that could happen even though we're forcing it to so we know。
    what's gonna happen gets me forcing it to but yeah these are race conditions you。
    can't predict them very good good point yeah if you had this right here before。
    you checked if it was the child it would all well remember that it would get。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能发生的事情，尽管我们强制它发生了，所以我们知道会发生什么，但这些就是竞态条件，你无法预测它们，非常好，很好的观点。是的，如果你在这里加上判断条件，确保它是子进程之前…
- en: printed twice in that case because there's because the child and the parent
    would。 do it so that's not really that's not really what we wanted to do in this
    case。 but you see the issue here we've got this race condition and really what
    we want。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于父进程和子进程会各自执行，所以在这种情况下，它被打印了两次。这其实不是我们在这种情况下想要的结果。但你看到了这里的问题，我们有一个竞态条件，实际上我们想要的是…
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_149.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_149.png)'
- en: to do is we want the child not to send that signal until after this command。
    that's what we want okay we want the child to maybe it ends we don't care if。
    the child ends we just don't want that signal to be sent until after or until。
    we're ready for that signal to be sent okay and in this case it's going to be。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要做的是，我们希望子进程在执行此命令之后再发送信号。我们希望的是，子进程可能结束，我们不在乎子进程是否结束，只是我们不希望那个信号在我们准备好之前发送，直到我们准备好接收这个信号。
- en: after we've added the job to the list because that would be kind of hard in。
    this is especially true if you literally were keeping some list that you needed。
    to like if it was a if it was a queue or something or some or some set or。 something
    of like the list and you tried to remove it before you added it well。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它会在我们把任务添加到列表之后，因为如果你真的是在维护一个需要的列表，特别是如果它是一个队列或某种集合，或者是某个列表，而你在添加之前就试图移除它，那就有点难。
- en: you're gonna crash right or there's some other like oh I can't remove that job。
    even though it ended that's weird right so you need to need to somehow be able。
    to say don't call that signal until after this printout in this case all right
    so。 how are we going to do that okay there's the thing we just did what we need
    to。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你会崩溃，对吧？或者有其他情况，比如“哦，我不能移除那个任务，即使它已经结束了”，这很奇怪，对吧？所以你需要以某种方式能够说，在这次打印输出之后再调用那个信号，在这种情况下，好吧。那么我们怎么做呢？好吧，刚才我们做的那个就是我们需要做的。
- en: do okay well this is we actually kind of went through all this all this detail。
    here what we need to do is we need to use a different type of system call here。
    okay we need to use have this idea of a signal set and this signal set is。 going
    to be a data structure that says when you call the this function called。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个我们其实已经讲过了所有这些细节。我们需要做的是我们需要使用一种不同类型的系统调用。好吧，我们需要使用信号集的概念，这个信号集将是一个数据结构，表示当你调用这个函数时。
- en: SIGPROC mask it says don't let a particular signal get called until we。 unblock
    it okay so we're going to block a bunch some signal in fact sometimes you。 can
    block many blocks many signals as you want but we're gonna in particular block。
    the SIG child until we're ready for that SIG child to be okay to be fired that's。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: SIGPROC mask表示在我们解锁之前，不允许某个特定的信号被调用。好吧，所以我们将阻塞一些信号，实际上有时你可以阻塞许多信号，但我们特别要阻塞SIG
    child，直到我们准备好让这个SIG child信号被触发。
- en: all we're doing okay there's three different type like functions we have to。
    deal with in this case the one is called SIG empty set let me make this a little。
    bigger one it's called SIG empty set and SIG empty set basically takes this。 SIG
    set T type that we have and it kind of initialized it says there are no。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的事情好吧，这里有三种不同类型的函数我们需要处理。在这种情况下，其中一个叫做SIG empty set，让我把它放大一点。它叫做SIG empty
    set，而SIG empty set基本上接收我们拥有的SIG set T类型，并且它会初始化，表示没有信号。
- en: signals in that set okay it's just an initialization and by the way this signal。
    sets basically an integer that's got a bunch of bits it's that's obviously it's。
    got a bunch of bits and it's got the bits are set depending on the signal and
    so。 32 bit integer turns out there's less than 32 signals so we can do we can
    get。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 信号集中的信号，好吧，这只是一个初始化。顺便说一下，这个信号集基本上是一个整数，它有许多位，显然它有许多位，并且这些位会根据信号的不同而设置。所以它是一个32位的整数，结果是信号的数量少于32个，所以我们可以处理它。
- en: away with that then if you want to add a particular signal to a set you can
    you。 say okay I'm going to pass in the set that I'm going to add and then I'm
    going to。 tell it which signal I want to actually add to that set okay you can
    also remove。 them the three that we're gonna care about right now are these three
    and then。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想往一个集合中添加特定的信号，你可以这么做。你可以说：“好吧，我将传入我想要添加的集合，然后告诉它我要向集合中添加哪个信号。”你也可以移除它们，接下来我们关心的三种是这些。
- en: if you want to say go block this signal you call SIG proc mask with a with a
    value。 called SIG block then then you pass in the SIG set that you care about
    you can。 also you can also get back the signal that you that have already been
    set like。 it's kind of one of those weird things really like well we're not gonna
    tell。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想说“去阻塞这个信号”，你需要调用SIG proc mask并传入一个名为SIG block的值，然后传入你关心的SIG set。你也可以获取已经设置的信号，就像那种奇怪的情况，实际上我们不会告诉你。
- en: you remember like from day one where we talked about we talked about you mask
    and。 there was that weird thing where you the only way to check you mask was to。
    actually change it and you get back what you check it's the same sort of thing。
    here why they did this is just historical I'm guessing but anyway most of the。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得从第一天开始我们谈论的那个掩码吗？有个奇怪的事情是，唯一检查掩码的方法是实际上改变它，然后你得到你检查的内容，这里也是一样的。为什么这么做，可能是历史原因，我猜，但无论如何，大多数的。
- en: time we're not gonna care about the existing set we're just gonna say look。
    here's our new set I don't care what signals are already done let's just go。 with
    it if you're writing a more robust program you might care about that okay。 all
    right so let's see how this actually works in practice so let's go modify our。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不在乎现有的集合，我们只会说，看看，这是我们的新集合，我不在乎已经完成的信号，我们就这么做。如果你写的是一个更健壮的程序，你可能会在意这些。好的，现在让我们看看这在实践中是如何工作的，所以让我们修改一下。
- en: our let's go modify our main function here we're not gonna have to do anything
    by。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改一下我们的main函数，我们不需要做任何事情。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_151.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_151.png)'
- en: the way to the reprocesses we're just gonna have to change main here to have。
    this signal set that we're gonna block and you'll see how that happens okay all。
    right so what we're gonna do is we're going to the same thing we're gonna set。
    up this signal and then we are going to say okay fine I'm going to get a SIG。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是需要在这里更改main函数，使用我们将要阻塞的信号集合，你会看到这是如何发生的。好的，所以我们要做的就是做同样的事情，我们将设置这个信号，然后我们将说，好的，我要得到一个SIG。
- en: set underscore T and I'm just gonna call it my set I'm going to initialize it
    by。 calling SIG empty set SIG empty set and then we pass in a pointer to the set
    and。 then we say let's add the SIG child that SIG add set SIG or sorry set and
    SIG CHLD。 okay all right so at this point now we've got our set that we're going
    to be able。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 设置下划线 T，然后我只想称它为我的集合，我将通过调用SIG空集合SIG空集合来初始化它，然后我们传递一个指向集合的指针，然后我们说让我们添加SIG子集SIG或抱歉，集合和SIG
    CHLD。 好的，现在我们已经得到了我们的集合，我们将能够。
- en: to say hey wait for this signal like block this signal until we're ready for。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 说，嘿，等待这个信号，直到我们准备好。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_153.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_153.png)'
- en: okay we don't need to quite block it yet right we want to block it before we。
    actually have the chance to call it like before we actually do for it because。
    at that point we need it to be we need it to be kept blocked okay so at this。
    point we're gonna say SIG PROC MASK okay SIG BLOCK and then we are going to。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们还不需要阻塞它对吧？我们希望在我们实际上有机会调用它之前阻塞它，像是在我们实际执行fork之前，因为在那个时候我们需要它保持阻塞。好的，在这一点上我们将说SIG
    PROC MASK，好的，SIG BLOCK，然后我们将。
- en: pass in our set and we're not gonna care about the other set so at this point。
    right before fork we have blocked the signals it turns out and this is a good。
    thing as it turns out blocked signals are passed along to your children。 whatever
    signals are blocked in the parent are also blocked in the children。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 传递我们的集合，我们不在乎其他集合，所以在这一点上，在fork之前，我们已经阻塞了信号，结果证明这是好事。事实证明，阻塞的信号会传递给子进程。父进程中阻塞的信号在子进程中也会被阻塞。
- en: and the reason for that is so that we can do this I mean that's really the basic。
    the main reason that that we did this is so that we can do that so by the time。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是为了让我们能做到这一点。我的意思是，这真的是我们这么做的基本原因。这样到时候。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_155.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_155.png)'
- en: you get to this child part the the by the time we actually run the date command。
    we are not allowed in fact the program is not allowed to call the SIG child。 signal
    now it doesn't mean that it gets like ignored forever if once we unblock。 the
    signals that cue of signals that need to be sent will go oh okay the。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你到达子进程部分时，等到我们实际运行date命令时，实际上程序不允许调用SIG子信号。现在并不意味着它会永远被忽略，一旦我们解除阻塞，所有需要发送的信号队列就会恢复，哦，好的。
- en: operating system will go oh great I've got this this child has ended I better。
    call it but it's only after we unblock it okay all right so what do we have to。
    do at this point we now need to in the child this is gonna seem a little strange。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统会说，哦，太好了，我得到了这个子进程已经结束，我最好调用它，但只有在我们解除阻塞之后。好的，那我们现在需要做什么呢？我们现在需要在子进程中做点事情，这看起来可能有点奇怪。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_157.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_157.png)'
- en: but in the child we're gonna do SIG PROC MASK okay actually I kind of lied to。
    you a little bit earlier the reason the signals get the reason the signals get。
    blocked in the children is not because of this actually it's because you may want。
    the children to also be able to block on their signal and it might be because。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: you're running the same sort of program we will see why that's actually not。
    important because of what I'm exactly gonna do right now we're going to unblock。
    for the child only right there so in other words what if date call the child。
    process if we didn't unblock at that point the date function would start out。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: with its child process blocked and date doesn't do that so it doesn't actually。
    matter that much but if date had its own child because the signal sets are passed。
    along to their children date would also have that issue it might not be able to。
    handle that okay so who knows that might be it might be an issue but for now what。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: we're doing is we're saying in the child go ahead and unblock because it。 doesn't
    matter the child we don't care if the child gets a child handler called。 we care
    about the parent's child handler getting called and we don't want it to。 unblock
    until right here after the printf okay so after the printf SIG PROC。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: MASK SIG UNBLOCK IN THE PARENT SET we don't care about what the previous one
    was。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_159.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: no like that after this now when the child signal or the parent's signal。 handler
    can get called when the child ends it probably already will have ended。 because
    we just waited for a whole second and in this case so really fast。 function question
    yes good very good question question where go back a second。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: explain why unblocking the child unblocking the signal in the child doesn't
    have。 anything to do with a parent okay the parent forget about the child for
    a。 second the parent has a main function and it has a child hand a signal handling。
    for the SIG child the parents SIG child handler gets called when the child ends。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: unless we have told the parent we're not going to let you send we're not going
    to。 let you accept that signal really what it is or you can't send that signal
    to。 the parent okay so it doesn't matter if the child signal is blocked or not
    that's。 dealing with its own children if it had some so it doesn't matter so when
    you say。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: SIG PROC MAS SIG UNBLOCK INSIDE THE CHILD it's just saying I'm making sure。
    that child doesn't have any signals of its own blocked right now okay and then。
    and that might because that might be important to the child right in the。 parent
    though even here we are still blocking that signal for the parent。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: because the last thing the parents saw was this block right here before before。
    so the parents child handler is not going to get called until line 45 down。 here
    when we call unblock we'd say SIG PROC MAS UNBLOCK SIG UNBLOCK on that set。 at
    that point now the parents signal handler can get called and it will get。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: called because the operating system goes oh now you're accepting signals I've
    got。 one for you and it calls it them hopefully this will actually see how this。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作系统会说，哦，现在你正在接受信号，我有一个信号要给你，然后它就会调用它，希望这次实际可以看到这种情况。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_161.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_161.png)'
- en: work jobless synchronization and hopefully there we go now we actually are。
    waiting for one second and now the jobs are added and then removed in the proper。
    order why because we wouldn't we didn't allow them to be removed until they've。
    been added and in this case that just took it took us a little time to edit。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表的同步？希望是的。现在我们实际上在等了1秒钟后，任务已经按正确的顺序添加和移除。为什么呢？因为我们不允许它们在添加之前就被移除，在这个案例中，只是需要一点时间来编辑。
- en: that's the way that's okay question yeah the date gets printed before we have。
    the job we don't really care about that because we said to the that's a good good。
    point though we said hey go run right we're trying to do our own like adding in。
    we're trying to do our own bookkeeping but yeah you're often running right now。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，没问题。问题是，日期被打印出来是在我们有任务之前。我们其实不太在乎这个，因为我们说了，这是一个好点子，我们说“嘿，去运行吧”，我们在尝试做自己的添加操作，做我们自己的记账，但你现在已经在运行了。
- en: if you want to do that yeah there's you wouldn't if you needed to do that we。
    would have done we would have done something like this if you said wait I。 didn't
    want date to run before we did the exact V is CVP right like we would。 have to
    before even forked we would have to then figure out like how to do you know。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想做这个，假设你需要这样做，我们就会做类似这样的事情。如果你说，等一下，我不想让日期在我们做精确的 V 或者 CVP 之前运行，对吧？像是我们在分叉之前就必须弄清楚，如何处理这些事情。
- en: do that now this might actually this also might be like an issue can't in this。
    case we would have to do something else to try to figure out like how to do how。
    to wait to print until the parent has did done it but once you've got a child。
    in the parent they're kind of independent anyway so you're not really。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做这件事，实际上这可能会是一个问题。在这种情况下，我们必须做些别的事情来弄清楚如何等到父进程完成后再打印出来。不过一旦你有了子进程，它们就算是独立的了，所以你并不真正在乎...
- en: gonna want to you're not gonna be able to wait for the parent on the children
    the。 child is not really gonna be a way for the parent itself so you got to be
    able。 to figure some other logic out to do that yeah yeah。 very good question
    the question was wait is reprocesses also passed down to the。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能等父进程的孩子，子进程本身没有办法为父进程等待，所以你必须想出一些其他的逻辑来处理这个问题。对，没错。非常好的问题，问题是，等待的信号是否也会传递给...
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_163.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_163.png)'
- en: child it certainly is because it's part of the program right so the child has。
    access to all its own functions now the child's reprocess won't get called when。
    the child ends because it's not it doesn't have a child that's ended。 as a bit
    inception like earlier yeah yeah the right the date might have a。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程确实是程序的一部分，所以它有权限访问它自己的所有函数。现在子进程的重处理信号不会在子进程结束时被调用，因为它没有结束的子进程，像是之前提到的那样。这有点像是前面的内省现象。
- en: child process in which case then it would get called correct yeah yeah so the。
    question was we if the date did have a child then this signal might get called。
    now likely the child would set up its own well actually that's good point in。
    this case the this one would it sure it might have gotten called if the child。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子进程存在，那么这个信号可能会被调用。现在很可能子进程会自己设置好，实际上这是一个好点子。在这种情况下，这个信号确实可能会被调用，如果子进程...
- en: process had a child process yeah if the child process had a child process yeah。
    the child's one would get called wouldn't get added to our the parents job list。
    we get out of a child's job list or I guess we would get it would get removed。
    from the child job list so you would have to put more logic in there if you。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 进程有一个子进程，如果子进程还有一个子进程。那这个子进程的情况就会被调用，而不会被添加到父进程的任务列表中。我们会从子进程的任务列表中退出，或者我猜我们会把它从子进程的任务列表中移除。所以你需要在里面加上更多的逻辑来处理这种情况。
- en: cared about that yeah yeah good point yeah what you could also do is you could。
    you can basically say you can set up the signal you can say signal with a no value。
    well basically it's saying don't handle it anymore you could do that in the child。
    if you cared about that we have to not care about that for this part good very。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关心这个问题，对，挺好的观点，对，你还可以做的是，你可以基本上说，你可以设置信号，你可以说信号没有值。基本上就是在说不要再处理它了，你可以在子进程中这样做。如果你在乎这个问题，那我们就不需要在这部分关心这个问题了。很好。
- en: good good point there are lots of things think about with these things when
    you're。 building these real programs yep so a sig block does that not allow the
    program。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，很好的观点，做这些事情时有很多东西需要考虑，当你。构建这些实际的程序时，没错，`sig block` 是否不允许程序。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_165.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_165.png)'
- en: to receive signal or sentencing it is not a lot good question if the question
    was。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接收信号或发送信号没有限制。好问题，如果问题是。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_167.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_167.png)'
- en: does it does sig block not allow the program to receive signals or send it it。
    doesn't allow the parent in this case to receive that signal that its signal。
    handler will not get called it may be queued up to get called later but it。 will
    not get called good question there are limits how many signals the。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`sig block` 是不是不允许程序接收信号或发送信号？它不允许父进程接收该信号，信号处理器将不会被调用，它可能会被排队等待稍后调用，但它。不会被调用。好问题，操作系统有一定的限制，限制信号的数量。
- en: operating system will like block and store oh good question is there some some
    list。 or some queue limit on the number of signals I don't know of any it's probably。
    big enough that it's not going to matter like it's probably thousands and you。
    probably likely won't be able to even create thousands of children anyway or。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统会像阻塞并存储信号一样，哦，好的问题，是否有某种列表或者队列限制信号的数量，我不知道有没有这样的限制，但它可能。足够大，以至于不会产生影响，可能有成千上万的信号。而且你。可能根本无法创建成千上万的子进程，或者。
- en: whatever so it's probably some limit that we aren't going to worry about yeah
    good。 question if we come if we write if we commented this out it's going to run。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 随便吧，可能是某种限制，我们不需要担心。对，好问题，如果我们写下注释，它会运行。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_169.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_169.png)'
- en: exactly the same because the child isn't going to get any children and it's
    not。 going to ever it's not going to matter anyway although if we if we if we
    ran。 another program that had children yet probably would print that some job
    has。 been added that's weird that why would that happen right but no in this case。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 完全一样，因为子进程不会获得任何子进程，它也不会。无论如何，它不再重要，尽管如果我们。如果我们运行了另一个有子进程的程序，可能会打印出某些作业已。被添加，那就奇怪了，为什么会发生这种情况呢？不过，在这种情况下。
- en: not gonna matter did I delete the wrong one oh no thank you for oh you want
    to do。 this one that one would just make your behaviors of did before that one
    thank。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不会有影响，我删错了吗？哦不，谢谢你，哦，你想做的是。这个吗？那个只会使你之前的行为发生变化，谢谢。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_171.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_171.png)'
- en: you all this synchronization yeah same sort of thing right no children for。
    the children are getting calling that function if you had one that did right if。
    date had its own shy-up process yeah we probably would have gotten a weird。 print
    up in there that said some other process and added a job list and they。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你们所有的同步，没错，就是类似的东西，对吧，没有子进程。子进程会调用那个函数，如果你有一个函数那样做的话。如果日期有自己的子进程，我们可能会看到一个奇怪的打印出来，显示某个其他进程并添加了一个作业列表，他们。
- en: know well so again when you're trying to do these things you have to kind of。
    keep track of some of the details of these because it's because it's tricky。 yeah
    good question yeah good question if you want to say stops calling my。 function
    or signal handler you I forget exactly what it is but it's another you。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了，所以再次强调，当你尝试做这些事情时，你必须有点。跟踪这些细节，因为它有点复杂。对，好的问题，对，好的问题，如果你想说停止调用我的。函数或信号处理器，我不记得确切是什么，但它是另一个你。
- en: basically do signal and then instead of SIG child it's like no signal or it's。
    not that but it's something like that I don't remember exactly what it is but。
    that's what it that's what it is in fact we can look it up if we do man signal。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上发信号，而不是 SIG_CHILD，类似这样，或者不是那样的，但类似的。我不记得确切是什么，但。就是那样的。事实上，我们可以查找一下，如果我们做
    `man signal`。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_173.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_173.png)'
- en: let's see here we go let's see here we go SIG IGN means the signal is gonna
    get。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看，SIG IGN意味着信号将会被。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_175.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_175.png)'
- en: ignored or SIG DFL means that the default action will happen so you've got。
    you've got you just passed that into signal and it goes all right no more。 SIG
    child is gonna be called into my in my process good question all right kind of。
    nice when you have the manual right there your fingertips okay all right so。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略或SIG DFL意味着默认的操作将会发生，所以你已经做到了。你已经将其传递给信号，它就会继续，没有问题。SIG child将在我的进程中被调用，好的问题。好了，当你手头有手册时，这种情况会变得很方便，好的，继续吧。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_177.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_177.png)'
- en: that's some those are signals there we have gone through the different types
    of。 signals we can actually write a little function to kind of capture this instead。
    of writing each little part out individually in this case we can write。 impose
    SIG child block which does sets up a set and then calls SIG proc master。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是信号，我们已经讲过了不同类型的信号。我们实际上可以写一个小函数来捕获这些，而不是逐一写出每个部分。在这种情况下，我们可以编写一个`impose
    SIG child block`，它设置一个信号集，然后调用SIG proc master。
- en: block and then we could do the exact lift one which does the same sort of thing。
    except unblocks it you could also have one that toggles it if you want to and。
    you'll see those functions we've written some of those functions for you there。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞，然后我们可以执行精确的解除阻塞操作，它执行类似的操作。只是它会解除阻塞，如果你想的话，你也可以有一个切换操作。你会看到这些函数，我们为你编写了一些函数。
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_179.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_179.png)'
- en: okay right we already did this the improved job list and what else can we say。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经做了这个改进的作业列表，还有什么可以说的吗？
- en: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_181.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5307d4923970aa2b8e91ebe06d2ca1fa_181.png)'
- en: for it yeah as I said for process and hair it's the block signal sets so it。
    should it should lift that signal just in case the child cares about it and as。
    as people have already mentioned it probably should also un like it should。 get
    rid of that signal handler too so it doesn't get called when the child ends。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它，是的，正如我所说，针对进程和信号的阻塞信号集。所以它应该，它应该解除该信号，以防万一子进程在意它。正如人们已经提到的，可能还应该取消这个信号处理程序，以便子进程结束时不再调用它。
- en: because that's not part of our program again things you have to think about。
    when you're building these for real you have to do lots and lots of testing on。
    this sort of stuff okay two more quick signals or two more quick system calls。
    here processes can send messages to other processes without something。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因为那不是我们程序的一部分，再次提醒，当你在实际构建这些时，你必须进行大量的测试。好了，再快速讲两个信号或两个系统调用。这里，进程可以向其他进程发送消息而不需要任何事情发生。
- en: happening you are allowed to send a signal to another process you do it using。
    a slightly ill-defined command called kill now kill was named because the only。
    signal that they originally sent was one to terminate a process basically said。
    kill this process and it means not make it stop running right says the original。
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向另一个进程发送信号，你可以使用一个略显不明确的命令，叫做`kill`。现在kill之所以命名是因为最初它只发送了一个终止进程的信号，基本上就是说“杀死这个进程”，它意味着停止它的运行。这是最初的意思。
- en: and then they said well what if we want to send other signals let's just keep。
    kill why didn't you call it send signal or something I don't know but they kept。
    it is called it called kill okay so it doesn't actually kill if you send a。 sick
    kill yes it will make the terminate the process but otherwise you are allowed。
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们说，假如我们想要发送其他信号呢？那我们就继续使用`kill`吧。为什么不叫它`send signal`或者别的什么呢？我也不知道，但他们还是叫它`kill`。好了，它实际上不会杀死进程，如果你发送的是`SIG
    kill`，是的，它会终止进程，但否则你可以发送其他信号。
- en: to give an AP ID send a particular signal okay so if you want to send the。 SIG
    child signal to a particular process you can send it you can also send I。 think
    there's two other ones called like it's SIG I think it's SIG USR1 which is。 like
    a generic one that you're allowed to send just because hey maybe you want to。
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送一个AP ID发送特定的信号，好的，如果你想将SIG child信号发送到特定的进程，你可以发送它。你还可以发送，我想还有两个其他的信号，比如SIG，我想是SIG
    USR1，它是一个通用的信号，你可以发送，因为嘿，或许你只是想发送它。
- en: send one that's not a special one that says killer that says term you know that。
    says stop or it says continue or whatever we will see lots of use of these as
    we。 go you can also send a signal to yourself which is you do by the raised。 system
    call which basically just takes the signal number you're trying and it。
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 发送一个不是特殊的信号，比如说杀死信号，它说的是终止，你知道的，或者是停止或者继续，我们在后面会看到这些信号的许多用法。你也可以发送信号给你自己，这可以通过调用
    `raise` 系统调用实现，基本上它就是将你尝试的信号号传进去。
- en: sends it to your own process it is exactly like saying kill with get PID for。
    your own PID signal number it's you could use either and they're interchangeable。
    okay you can also get the value of that you can change PID to not be the actual。
    PID you can make it affect other processes that are tangentially related to a。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到你自己的进程，这就像是通过获取 PID 来发送信号一样，**你的** PID 信号号，你可以使用任何一种，它们是可以互换的。好，你还可以获取它的值，你可以更改
    PID，使其不再是实际的。PID，你可以让它影响到其他与 A 稍微相关的进程。
- en: particular process and you handle that with a thing called groups I'm not going。
    to go into right now but if you send a negative number less than one to kill it。
    actually goes and finds the group that's associated with that process what you。
    can do with processes you can set them up such that they're in same group so if。
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的进程，你可以通过一种叫做“组”的方式来管理，我现在不打算详细讲解这个，如果你给 kill 信号传入一个负数小于一的值，它实际上会找到与该进程相关的组。你可以将进程设置成同一组，这样如果……
- en: you want to send a signal to one process it can then or it can if you want to
    send。 one kill signal it can it can go to a whole bunch of different processes
    so。 it's nice to have these groups we'll get into groups when you get to assignment。
    assignment four and then you can also be zero or negative one we're not going
    to。
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想发送一个信号到某个进程，它可以接收，或者如果你想发送一个杀死信号，它也可以传播到很多不同的进程。所以，拥有这些组非常方便，我们会在做作业四时深入了解组的概念。然后你也可以设为零或者负一，我们暂时不讨论这个。
- en: worry about that for right now okay that was a lot of stuff you have assignment。
    to do tomorrow assignment three will come out tomorrow morning I'll do it。 release
    it first thing in the morning for anybody wants to get going on it and I。 will
    explain a little bit about assignment three on Monday so if you want to get。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先不用担心这些，好，这有点多的内容，你明天有作业要做，第三次作业明天早上发布，我会在早上第一时间发布它，任何想要开始的人都可以拿到。我会在周一稍微解释一下第三次作业的内容，所以如果你想提前准备的话，可以这么做。
- en: started on it you well maybe I'll do a little video I don't know when I'm gonna。
    do a video but anyway I will do some explaining about assignment three on。 Monday
    all right last minute questions on this stuff or otherwise yeah。 assignment three
    is actually gonna be due a week from Sunday so it's a little。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开始了，可能我会做一个小视频，不知道什么时候会做，但是不管怎样，我会在周一稍微解释一下第三次作业的内容。好了，还有什么问题吗？是关于这些内容还是别的？对了，第三次作业实际上是下周日到期，所以有点……
- en: longer amount of time and then the next one's gonna be out that day and then
    then。 the midterm happens so you've got an extra time for the next one as well
    so。 it's a little stretched out because midterms and so forth all right so you。
    guys Monday or in lab oh that reminds me I totally forgot sorry one last thing。
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 时间稍长，然后接下来的一次会在那天发布，之后就是期中考试了，因此你还有额外时间来准备下一次作业。所以整个计划会稍微推迟一下，因为期中考试之类的。好了，周一或者实验室见，哦，提醒我，抱歉，我差点忘记了，最后一件事。
- en: there we so there are a lot of people who wanted to do the Thursday I forget，
    which one three p。m。 lab we are adding another Thursday lab so we're changing。
    like one of the Thursday morning labs which not many people are in we're。 changing
    or adding a Thursday afternoon lab we're gonna combine the two Thursday。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有很多人希望能参加周四的课，我忘记了是哪个，下午三点的实验课。我们会增加一个周四的实验课，所以我们会调整一个周四早上的实验课，那里人不多，我们会调整，或者增加一个周四下午的实验课，我们会将两个周四的课程合并。
- en: morning ones and it's only like four or five extra people so it's not a big
    deal。 I will put that up later today so if you want to add the Thursday section
    if you。 don't like the section you're in an afternoon one you'll be able to do
    that。 all right see you guys later。
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 早上的部分只是四五个人增加所以不是什么大问题。我稍后会发布更新，所以如果你想换到周四的课时，或者如果你不喜欢你现在所在的下午班，你可以换。好了，稍后见。
