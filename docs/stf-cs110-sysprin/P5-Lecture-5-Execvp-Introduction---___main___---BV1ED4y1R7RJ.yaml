- en: P5：Lecture 5 Execvp Introduction - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P5：第五讲 Execvp介绍 - ___main___ - BV1ED4y1R7RJ
- en: Okay， welcome back。 There are fewer of you here than before。 I kind of figured
    that might happen over the course of the quarter。 Thank you for joining us today。
    So today we're going to continue with talking about fork and we're going to talk
    about this new thing called exec CVP。 which is generally why we use fork as it
    turns out。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎回来。这里的人比之前少了。我大概猜到在这一学期的过程中会发生这种情况。感谢你们今天加入我们。所以今天我们将继续讨论fork，并且我们将讨论一个叫做exec
    CVP的新东西。这也是我们使用fork的原因，事实证明。
- en: And I will also talk about the assignment that's going out that just went out
    today。 Speaking of fork。 So， I， let's see， how can I do this？ I took， so I was。
    I was finishing some things up today and then I took a little break and I went
    to Reddit。com。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会讨论一下今天发布的作业。说到fork。所以，我，看看我怎么做这个？我今天在完成一些事情时，休息了一下，去了Reddit.com。
- en: '![](img/12985c8e5f99b7c7460e806495676228_1.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_1.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_2.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_2.png)'
- en: Our programming， because I look at the programming ones， right？ And let's see。
    the first thing that's there is this thing called a fork in the road。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 说到我们的编程，我看的是编程的内容，对吧？我们来看一下。那里第一个提到的是一个叫做fork in the road的东西。
- en: '![](img/12985c8e5f99b7c7460e806495676228_4.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_4.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_5.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_5.png)'
- en: And I went， oh， cool。 We're talking about fork in class today。 Let me click
    on it and see what it says。 What do they must be talking about？
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我想，哦，酷。今天我们在课堂上讨论fork。让我点进去看看它说了什么。他们一定在讨论什么吧？
- en: '![](img/12985c8e5f99b7c7460e806495676228_7.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_7.png)'
- en: Some cool things on， on fork。 And then let's see， is the actual paper here。
    I believe it is。 There it is。 Okay。 So I go great。 This thing called fork and
    order。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有些酷的东西在运行，关于fork。然后我们看看，实际的论文就在这里。我相信它在这里。找到了。好的。这个东西叫做fork和order。
- en: '![](img/12985c8e5f99b7c7460e806495676228_9.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_9.png)'
- en: The received wisdom suggests that Unix is unusual combination of fork and exec。
    which is what we're going to talk about today， for process creation was an inspired
    design in this paper。 We argue with that fork was a clever hack for machines and
    programs in the 1970s that has long outlived its usefulness and is now a liability。
    And I went， oh no。 Here we go。 And it talks about。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍的观点认为Unix是fork和exec的一个不寻常的组合。这也是我们今天要讨论的内容，关于进程创建的设计在这篇论文中非常有启发性。我们对此提出异议，认为fork是70年代机器和程序的巧妙黑客，但它的有用性已经过时，现在反而成了负担。我心想，哦不，来了。然后它讨论了。
- en: and so I read this paper and it talks about how fork is actually not the best
    thing in the world to teach。 Like as the first thing， which is exactly what we
    do in this class， is teach the first。 It says。 as designers and implementers of
    operating systems。 we should acknowledge that forks continued existence as a first
    class operating system primitive holds back systems research and deprecated。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我读了这篇论文，它讨论了fork其实不是教得最好的东西。就像我们在这门课上做的那样，作为第一件事教fork。论文中提到，作为操作系统的设计者和实现者，我们应该认识到fork作为一个操作系统的基本原语的延续，阻碍了系统研究并且已经过时。
- en: As educators， that's me， as educators we should teach for as a historical artifact
    and not the first process creation mechanism students encounter。 Sorry。 Sorry。
    So， by the way， this is written by Microsoft who， for what it's worth。 does not
    produce a Unix operating system。 They have their own operating system。 But it
    actually has some interesting interesting things to say about fork and about how
    there are some things that we will actually talk about where it does produce not
    the best like answer to kind of your questions。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为教育者，也就是我，作为教育者，我们应该把fork当作历史遗物来教授，而不是学生接触的第一个进程创建机制。抱歉，抱歉。顺便提一下，这篇论文是微软写的，微软本身并不生产Unix操作系统，它们有自己的操作系统。但实际上它对fork有一些有趣的看法，关于如何有些问题我们将讨论，这些问题可能并没有提供最好的答案。
- en: For instance， for happens to be what we call not threads， say。 and we will talk
    about threading a little later in the course。 And it means that you can't mix
    and match forks and threads in certain ways。 And that's kind of not a great thing。
    So， as an educator。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，fork恰好是我们所说的非线程的东西，我们稍后会在课程中讨论线程。它意味着你不能以某些方式混合使用fork和线程。这其实不是一件好事。所以，作为一个教育者。
- en: I'm presenting this to you as a historical， what did they say？ A historical
    artifact。 So take that for what it is。 You still have to know it for the mid-term
    exam。 And who knows？ Maybe。 maybe we will retool the way these things go as we
    do this a few more times in the course。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这段内容呈现给你们作为一个历史遗物。就当作它是这样。你们仍然需要知道这些内容，特别是为了期中考试。而谁知道呢？也许，我们会在课程进行几次之后重新调整这些内容的方式。
- en: '![](img/12985c8e5f99b7c7460e806495676228_11.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_11.png)'
- en: Anyway， I thought that was interesting and a little sad that I thought it was
    going to be this great article。 There you go。 Alright， so the other day in class，
    somebody asked a great question。 I figured it is。 I apologize。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我觉得这很有趣，也有点令人遗憾，我原以为这会是一篇很棒的文章。就这样吧。好吧，前几天在课堂上，有人问了一个很好的问题。我想这个问题值得关注。对此，我感到抱歉。
- en: '![](img/12985c8e5f99b7c7460e806495676228_13.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_13.png)'
- en: Someone asked a question because we were putting up all these diagrams about
    file systems。 And the question was， "Hey， these various process control blocks
    that the operating system keeps track of that actually have file descriptor pointers
    basically in them can point to file descriptors in the open file table。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有人问了一个问题，因为我们展示了许多关于文件系统的图表。问题是，"嘿，操作系统跟踪的那些各种进程控制块，实际上包含文件描述符指针，这些指针基本上指向打开文件表中的文件描述符。"
- en: And there is one open file table。 And those descriptors in the open file table
    lists。 has some information about the various files that are open， including the
    mode。 whether it's read or write， read only， etc。 It also has the cursor position
    in there。 And the question was， "Wait a minute。 If there is only one copy and
    two files are allowed to simultaneously read a particular file and be at different
    places in the file。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 而且只有一个打开文件表。这些打开文件表中的描述符列表包含了一些关于各种打开文件的信息，包括模式，是否为只读，读写等。它还包含了游标的位置。问题是，"等一下，如果只有一个副本，而两个文件被允许同时读取同一个文件，并且文件位置不同，怎么办？"
- en: how does that work if there is only one copy in the open file table？" And I
    said， "Well。 it's probably true。 There is more than one copy。" And I wasn't sure。
    So I went and looked it up。 Indeed， the open file table， every time you call open，
    creates a new entry in the open file table。 which has a cursor for it。 So if two
    programs call open on a particular file or two processes even。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果在打开文件表中只有一份副本，怎么办？" 我说，"嗯，可能是对的，确实有不止一份副本。" 但我不确定，于是去查了一下。确实如此，每次调用 `open`
    时，打开文件表会创建一个新的条目，并且会为其分配一个游标。所以，如果两个程序对同一个文件进行 `open` 操作，或者甚至是两个进程。'
- en: call open on a particular file。 You do get duplicates here。 And I said， "Well。
    the reason it's only one is because you don't like all these duplicates。" The
    difference is that there are， when we do fork， for instance。 we know that you
    copy all of the memory and therefore they will indeed point to the same place
    in the open file table。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `open` 打开一个特定的文件时，确实会有副本存在。我说，"嗯，之所以只有一个副本，是因为你不喜欢这些重复的副本。" 区别在于，当我们进行 `fork`
    操作时，我们知道会复制所有的内存，因此它们会指向打开文件表中的同一个位置。
- en: So it is true that processes can point to the same open file table record。 which
    will have one cursor where in the file you are。 But if two programs open it up。
    you do get duplicates in there。 So that's how you get two different cursors。 It's
    clear things up a little for the people who are curious about that。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以确实是这样的，进程可以指向相同的打开文件表记录，其中包含文件中的游标位置。但如果两个程序打开同一个文件，里面确实会出现副本。这就是为什么你会有两个不同的游标。这样就能稍微澄清一下那些好奇的人。
- en: Not the biggest deal in the world， but that's how this ends up working。 And
    I thought I'd at least give you the information I looked up on that。 Okay。 So
    hopefully first assignment is finishing up due tonight， midnight no extensions
    remember。 If you do have trouble finishing up there， I believe there are still
    offsours tonight。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是世界上最大的事，但这就是它的工作原理。我想至少给你们提供我查到的信息。好了，希望你们完成第一项作业，今晚午夜前提交，记得没有延期。如果你们在完成时遇到问题，我相信今晚还有外包工作。
- en: so you guys should be able to get to there if you need to。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你们应该能找到这个地方，如果需要的话。
- en: '![](img/12985c8e5f99b7c7460e806495676228_15.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_15.png)'
- en: The second assignment， which is the next assignment。 in fact the first assignment
    where we're really testing things that you probably haven't seen before。 namely
    the file system stuff。 And it is on the file system we described in class。 specifically
    the Unix version six file system from the late 1970s。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个作业，实际上是下一个作业，事实上是第一个真正考察你可能以前没有见过的内容的作业，即文件系统的相关内容。它基于我们在课堂上描述的文件系统，具体来说是1970年代末的Unix版本六文件系统。
- en: '![](img/12985c8e5f99b7c7460e806495676228_17.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_17.png)'
- en: Okay， why do we care about that file system？ It happens to be a decent file
    system。 It happens to be relatively， relatively straightforward to understand
    for what it's worth。 And it is just a good one to practice manipulating data structures
    needed for file systems。 Okay。 the test data that you're going to read from the
    actual test disks that we have are literally built bit for bit representations
    of a Unix version six disk。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，为什么我们关心这个文件系统呢？恰好它是一个不错的文件系统。它相对来说比较简单，容易理解，值得一提的是，它是一个很好的练习，适合操作文件系统所需的数据结构。好了，你将从我们提供的实际测试磁盘中读取的测试数据，实际上是Unix版本六磁盘的逐位表示。
- en: So somebody had a universe version six system up and running somehow。 probably
    in a virtual machine or something， and they copied the disks off and then put
    it in this assignment。 And that's where they came from。 And so you're going to
    have to figure out how to read those disks specifically。 Okay， we've given you
    some scaffolding for that obviously， but you're going to have to do that。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有人成功地让一个版本六的系统运行起来，可能是在虚拟机中或其他什么地方，他们把磁盘拷贝下来，然后放入了这个作业中。这就是它们的来源。所以，你需要弄清楚如何读取这些磁盘，具体来说。好了，我们已经给你提供了一些框架，显然，但你还是需要自己去做。
- en: The lectures from lecture three， very important to understand。 because I think
    we went over the specifics there。 And then this section 2。5 of one of the textbooks
    that we have， you can have a link straight to it。 is where you get even more specific
    information about the file system。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第三讲的内容非常重要，因为我认为我们在那里讲解了具体细节。然后是我们其中一本教材的第2.5节，你可以直接获取该链接，这是获取文件系统更具体信息的地方。
- en: So if you have questions about specifics， go there first， then ask the question
    on Piazza。 come to Office Hours， etc。 So the assignment is you've got this disk
    image and you have to be able to read and write files and find files on those
    that system。 Okay， and then you should be able to read the files and read any
    black in that file and so forth。 You'll primarily be writing in four different
    files， so you have code in four different places。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你对具体的内容有疑问，先去查看那部分内容，然后在Piazza上提问，或者来参加办公时间等。作业是，你有一个磁盘镜像，必须能够读取和写入文件，并且能够在系统上找到这些文件。好了，然后你应该能够读取文件并读取该文件中的任何块等等。你将主要在四个不同的文件中编写代码，因此你将有四个不同的代码位置。
- en: We do， we suggest that you do them in this order。 First you do the functions
    in iNode。c。 and you can imagine what that is that's manipulating or like using
    the information in an iNode to get out information about the file blocks。 And
    then file。c which kind of puts another abstraction layer on it and says here's
    a file that you should be searching for。 Okay， and then directory。c which is also
    kind of for manipulating the actual directors。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你按这个顺序进行。首先完成iNode.c中的函数，你可以想象那是操作iNode中的信息，以获取关于文件块的信息。接着是file.c，它在其上加了一层抽象，表示你应该搜索的文件。然后是directory.c，它也是用来操作实际目录的。
- en: I guess file。c is for like reading a specific file。 Directory is going and searching
    for the file。 Remember you have to search for root and you have to search all
    the files in there and then one after the other until you find the path you're
    looking for the file at the path you're looking for。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我想file.c是用来读取特定文件的。directory.c则是用来搜索文件的。记住，你必须搜索根目录并搜索其中的所有文件，直到你找到你想要的路径下的文件。
- en: And then finally path name is actually doing the searching as well。 Anyway。
    we say go through and note that order and after， I guess after the first two you'll
    have some functionality that you can test with either sanity check or by running
    the program。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后，路径名实际上也在进行搜索。不管怎样，我们说要逐步完成并注意顺序，之后，我想在前两个之后，你会有一些可以通过正常性检查或运行程序来测试的功能。
- en: And then as each one， as you finish each one you get a little bit more functionality。
    Okay。 so that's the basic idea。 This assignment is in C， not C++。 You don't have
    access to maps or sets or vectors or anything like that。 You've got to deal with
    low level arrays and you have to deal with structs and so forth。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你完成每个任务时，你会获得更多的功能。好的，这就是基本的想法。这个作业是用C语言写的，不是C++。你不能使用映射（maps）、集合（sets）、向量（vectors）或者类似的东西。你必须处理低级数组，并且要使用结构体（structs）等等。
- en: So no C++ stuff in this assignment。 Not the end of the world but it just means
    that if I think I might be able to do that with a map。 you can't。 No maps allowed
    in this assignment。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个作业中没有C++的内容。虽然这不是世界末日，但它意味着，如果你认为可以用映射（map）来完成某个任务，那就不行了。在这个作业中不允许使用映射。
- en: '![](img/12985c8e5f99b7c7460e806495676228_19.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_19.png)'
- en: Okay， the basic ideas I said you'll be able to locate and read files in this
    file system。 All right。 you'll be using functions that we've written for you and
    you're doing your own。 The one that I mentioned here that you'll use a bunch of
    times is called disk image read sector and it takes in a few parameters。 It takes
    in a file descriptor basically。 It takes in the sector number or I guess it's
    a file system。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我之前说过，你能够在这个文件系统中定位并读取文件。好的，你将使用我们为你写好的函数，也会自己编写一些函数。我在这里提到的一个函数，你会用到很多次，叫做`disk_image_read_sector`，它接收几个参数。它接收一个文件描述符，基本上。它接收一个扇区号，或者我想它是一个文件系统。
- en: It's kind of what it is。 It takes in a sector number and then it takes in a
    buffer and that will read a particular sector off of this disk image and we've
    written that for you。 Okay， you don't need to worry about that part of it。 Finding
    the right block to read is the important part。 A couple things to notice or to
    know about it。 The function will always read disk image underscore sector underscore
    size number of bytes。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它大致就是这样。它接收一个扇区号，然后接收一个缓冲区，这个缓冲区会从磁盘映像中读取特定的扇区，我们已经为你写好了这部分代码。好的，你不需要担心这一部分。重要的是要找到正确的块来读取。这里有一些事情需要注意或了解。这个函数总是会读取`disk
    image_sector_size`字节的数据。
- en: And you ask yourself， well， what if the file is only 12 bytes long？
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果文件只有12个字节长怎么办？
- en: Is it always going to read this many and this many happens to be 512 as we've
    discussed？ Yes。 it reads that many because the non first 12 bytes are all garbage
    but the disk has to read 512 at a time。 So you're responsible for saying， well，
    which of those bytes are actually relevant and there's a little bit of arithmetic
    involved with that。 Okay， so you're going to have to think about those sorts of
    things。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它总是会读取这么多字节吗？这些字节恰好是512字节，正如我们讨论过的？是的。它读取这么多是因为除了前12个字节之外，其他都是垃圾数据，但磁盘一次只能读取512字节。所以你需要负责确定哪些字节是相关的，其中涉及一些算术运算。好的，所以你得考虑这些问题。
- en: It's critical that you read through the header files for this。 The header files
    are actually not that big for this assignment but there's lots of constants in
    there you're going to need。 For instance， root I number。 It's a constant in there。
    Now we talked about that。 It happens to be one and that's the I number for the
    root。 But you need to use the root I number。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要阅读这些头文件。对于这个作业，头文件其实并不大，但里面有很多常量是你需要的。例如，根I号（root I number）。它是一个常量。在头文件中我们已经提到了它，它的值恰好是1，这是根的I号。但是你需要使用这个根I号。
- en: You could use one but in this case it's defined for you。 There's a directory
    entry struct and so forth which has a file name in it and all that。 And these
    are the things you learn from the header files。 Okay， so make sure you read through
    that。 And the assignment is up right now already by the way。 You can go take a
    look at it。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用1，但在这种情况下它已经为你定义好了。有一个目录项结构体（struct），其中包含了文件名等等。这些内容你可以从头文件中学到。好了，所以确保你阅读了这些内容。顺便提一下，作业现在已经发布了。你可以去看看。
- en: It's due next Thursday for what it's worth。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个作业的截止日期是下周四，供参考。
- en: '![](img/12985c8e5f99b7c7460e806495676228_21.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_21.png)'
- en: One function I did want to talk about。 This seems to be the one that gives people
    kind of the most trouble。 And maybe mainly because they don't really understand
    what it's asking before they start trying to code it。 Not a good thing。 You should
    try to understand what you're trying to code before you do it。 But here's what
    this function is。 It's called I node index lookup。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我想谈谈一个函数。这似乎是让人最困惑的一个，可能主要是因为在开始编写代码之前，他们并不完全理解它到底在问什么。这可不好。你应该在编写代码之前先理解你到底在做什么。但是这个函数是这样的。它叫做
    I 节点索引查找。
- en: And you actually get passed in a Unix file system。 We have already created and
    initialized that for you。 You don't need to worry about that。 By the time this
    function gets called you will actually have an I node pointer itself。 Okay。 which
    is populated with the details of the I node。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实际使用 Unix 文件系统时，你会传递给函数，我们已经为你创建并初始化了它。你不需要担心这个问题。等到这个函数被调用时，你实际上已经拥有了 I 节点指针。好的，指针已经填充了
    I 节点的详细信息。
- en: Remember it's got all the blocks that have block numbers in them and it's got
    the information about how big the file is and if it's a large file and so forth。
    Okay， and then it's also got a block number that you're searching for。 This is
    the block number of the file itself for however many blocks that file takes up。
    So if it's a 512 byte long file it takes one block and so there would only be
    a block number zero。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，它有所有包含块号的块，并且还包含关于文件大小的信息，如果是一个大文件等等。好的，然后它也包含你要查找的块号。这是文件本身的块号，表示该文件占用的块数。所以如果它是一个
    512 字节长的文件，它只占用一个块，那么只有块号为零。
- en: Right？ Block index zero。 If it's a two， like a 1024 byte file it takes up two
    blocks。 Okay。 the I node does and the I node takes up it's just regular， what
    did I say 32 bytes or whatever。 But the actual blocks in the file are what this
    function is going to return the index into the actual file that you're looking
    for。 Okay， so that's the。 Yeah。 If I say okay so I have a file that's I have a
    file that's I have a file that's 1024 long。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？块索引为零。如果是 1024 字节的文件，它会占用两个块。好的，I 节点就是这样，它占用的是常规的 32 字节，或者其他什么字节。但实际上文件中的块就是这个函数要返回的内容，它会返回你正在寻找的文件中的块的索引。好的，理解了吗？比如说，我有一个文件，这个文件的大小是
    1024 字节。
- en: Right？ Okay。 The block number is going to be let's say one， which is the block
    into that file。 Okay。 and you need to find the index of that block in the file
    system that you're looking for。 Okay。 In other words， the， I'll show you and you'll
    see how it works in a second。 It is a bit confusing。 Yeah。 Are you coming from
    zero or from one？ Are you coming from zero or from one？ Good question。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？好的。假设块号是 1，也就是文件中的一个块。好的，然后你需要在你正在寻找的文件系统中找到该块的索引。好的，换句话说，我会给你展示一下，你马上就能明白它是怎么工作的。稍微有点混乱。是的。你是从零开始还是从一开始？你是从零开始还是从一开始？好问题。
- en: You can do either but you have to make sure you know which one when you're actually
    coding it up。 Yeah。 Okay。 In this case， it would probably be zero。 But here's
    the example I just wanted to show you。 Okay。 Here's the example I wanted to show
    you。 Let's say that the I node indicates that the file is 180，000 bytes long。
    Okay。 180，000 bytes。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择任意一个，但你必须确保在编码时知道你使用的是哪一个。是的，好的。在这种情况下，它可能是零。但这是我想给你展示的例子。好的，这是我想给你展示的例子。假设
    I 节点表示文件的大小是 180,000 字节。好的，180,000 字节。
- en: And let's say the block number is 302。 Here's what that means。 If you go 512
    bytes at a time。 the 300 second one is the one you want to return。 Okay。 See。
    it's the block that you will then look up in your file system for that one。 Okay。
    Remember。 a file can have a block here that's the first 512 bytes and then it
    went over here。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设块号是 302。这意味着什么呢？如果你每次读取 512 字节，那么第 302 个块就是你要返回的那个。好的，看到了吧。就是你接下来在文件系统中查找的那个块。好的，记住，一个文件可以有一个块，前
    512 字节是一个块，然后它可能接着往下存储。
- en: That's the next 512。 And then one over here is the next 512 or whatever。 We're
    looking for the 300 and second one of those。 The block number for that。 Does that
    make sense？
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是下一个 512 字节。然后这边是下一个 512 字节，或者是其他什么的。我们要查找的是第 302 个块的块号。明白了吗？
- en: What we're trying to look for？ Yeah， hustle？ How do you get the other ones？
    Well。 you call it once for each time。 So， I mean， if you want to get。 let's say
    the file had 302 blocks in it。 You have to call this function 302 times to get
    each individual index for each one。 You see how that works？ That's the only way
    you can do it。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找什么？对，急吗？你怎么获得其他的呢？嗯。你每次调用一次这个函数。所以，意思是，如果你想得到。假设文件有302个块。你必须调用这个函数302次，才能获得每个块的单独索引。你明白它是如何运作的吗？这就是唯一的做法。
- en: There's no linked list here that goes between them all， right？ You've got the
    seven first。 or you've got the eight file number or the block numbers inside the
    I node。 And then you've also got the indirect ones as well and the double indirect
    one as well。 Yeah。 So。 just to be clear， this isn't necessarily the three hundred
    and second amount of data in the file。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有链接列表连接它们，对吧？你有前七个，或者你有I节点里面的八个文件编号或块编号。然后你还会有间接的那些，也会有双重间接的那些。是的。所以，明确一下，这不一定是文件中第三百零二个数据块。
- en: No， it exactly is。 It's the three hundred and second amount of 512 blocks data。
    That's what it is。 Okay， so it's not that。 So， it could theoretically be somewhere
    before that we're going to first block。 It could be anywhere in the file system
    outside the I-nodes。 but it's going to be anywhere in the I-file system。 But the，
    it's the。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不，确切来说是。它是第三百零二个512字节数据块。就是这样。好吧，那不是。理论上它可能在那之前的某个地方，我们会先找到第一个块。它可能在I节点之外的文件系统中的任何地方。但是，它会在I文件系统中的任何地方。但它就是。
- en: if you're walking through the file， you first need to go find a block for the
    first 512。 then you need the next 512。 Then you need the next 512。 We're trying
    to find the three hundred and second 512 block， right？ And to find that。 you have
    to know a lot about the file system to figure out how to follow all the little
    ways around to do it。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在遍历文件，你首先需要找到第一个512字节的块。然后需要下一个512字节块。然后需要下一个512字节块。我们要找到第三百零二个512字节的数据块，对吧？为了找到它，你必须了解很多关于文件系统的知识，才能搞清楚如何跟踪所有的小路径来做到这一点。
- en: That makes sense？ Yeah， so that's why this function is confusing because people
    don't quite get。 but hopefully we're clearing that up now。 Okay， all right。 let's
    just look at how we might actually do that。 Okay， let's say， as I said， the 180，000
    bytes。 we're looking for block number 302。 Okay， we're looking for the third。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这有道理吗？是的，所以这就是为什么这个函数很困惑，因为人们不太理解。但希望我们现在已经澄清了。好，好的。现在我们来看看我们可能如何实际做这件事。好吧，假设，如我所说，180,000字节。我们要找的是第302个块。好吧，我们要找第三个。
- en: three hundred and second block of 512 bytes of data。 Okay， and remember。 and
    this actually isn't going to matter so much for what we're doing， but blocks are
    512 bytes long。 Okay， and how do you find the sector index？ That's the actual。
    what sector do I need to tell the disk to read to get that third。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三百零二个512字节的数据块。好，记住。其实这对我们正在做的事情影响不大，但块的大小是512字节。好，如何找到扇区索引？那就是实际的。我需要告诉磁盘读取哪个扇区，才能获取到第三个。
- en: three hundred and second block of information？ That's what we have to do with
    this function。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三百零二块信息？这就是我们必须用这个函数来处理的。
- en: '![](img/12985c8e5f99b7c7460e806495676228_23.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_23.png)'
- en: Okay， well， what do you have to do？ Well， first things first。 Remember how I
    know， it's right。 there's those， those eight different blocks that have been there，
    right？ One， two， three， four。 five， six， seven， eight。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那你需要做什么？嗯，首先要记住，我是怎么知道的，对吧？有那八个不同的块，对吧？一，二，三，四，五，六，七，八。
- en: '![](img/12985c8e5f99b7c7460e806495676228_25.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_25.png)'
- en: And each one of those， if it's a small file， that's going to have a block number
    that's going to be the first 512 bytes。 That's going to be the next 512， the next
    512， next 512， et cetera。 All the way up to 4096。 because that would be the only
    amount you can keep in eight blocks of， "Hey。 here's the different blocks。"， So，
    the first thing your function better do is figure out if this larger small file。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块，如果是一个小文件，它将有一个块编号，这个编号对应第一个512字节。然后是下一个512字节，下一个512字节，接下来的512字节，依此类推，一直到4096。因为那是你能在八个块中存储的唯一数量，“嘿，这就是不同的块。”所以，你的函数首先要做的是判断这个文件是大还是小。
- en: because it's going to change what these numbers actually refer to， if it means。
    if it's a large file versus a small file。 It's a small file， easy， right？
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它会改变这些数字实际所指代的内容，如果它是指。是一个大文件还是一个小文件。是一个小文件，很简单，对吧？
- en: You know that it's going to be what that block， it couldn't be 302， by the way。
    because 302 would be two， it could only be between zero and seven， if it was a
    small file。 But anyway， all you would do is go to that i-node， read the number
    off there。 and that's the number that you send back to the return。 In this case，
    it is a large file。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道那个块中的数字不会是302，顺便说一下，因为302会是2，它只能在0到7之间，如果是小文件的话。但无论如何，你要做的就是去读取那个i节点，从中读取出数字，然后把它返回。在这个例子中，它是一个大文件。
- en: so you know you have indirect addressing， which changes things。 Now。 each one
    of these block numbers here， they refer to a block in the file system。 a segment
    in the file system。 But those， if when you go there， they have 256 numbers in
    them。 each one of which refer to a block where data is。 Okay， so， what does that
    mean？ Well。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你知道你有间接寻址，这改变了事情。现在，这里每个块编号，指向文件系统中的一个块，文件系统中的一个段。但如果你去那里，你会发现它们包含256个数字，每个数字都指向一个存有数据的块。好的，那这是什么意思呢？嗯。
- en: the three hundred and second block of your data is going to fall into the second
    indirect block。 Not this one， but this one。 Do you understand why that's the case？
    There's 256。 this one is going to refer to， because this points to a block which
    has 256 numbers in it。 and those are the first 256。 And then the next block has
    the next 256。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据中的第302个块将会落入第二个间接块。不是这个，而是这个。你明白为什么会是这样吗？这里有256个，这个块会指向一个包含256个数字的块，这就是前256个数字。然后下一个块包含接下来的256个。
- en: and 302 happens to be in that one。 Ready with me there？
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 而且302恰好位于那个块中。你准备好了吗？
- en: So you see how you're going to have to start thinking about this？ Okay， so what
    does that mean？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你看到你需要开始这样思考了吗？好的，那这是什么意思呢？
- en: Well， you are going to use disk image read sector to read the sector that is
    in， and I erased it。 one， two， three， four， five， six， seven， eight。 You're going
    to go read the number here and read the disk image from that number。 which is
    somewhere else in the file system。 That is going to give you a block that's going
    to get 512 bytes。 which is going to have individual block numbers in them。 They
    are all Uint_T， they are shorts。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你将使用磁盘映像读取扇区来读取其中的扇区，我已经擦除了它。一个，二，三，四，五，六，七，八。你将读取这里的数字，并从该数字开始读取磁盘映像，这个数字指向文件系统中的另一个地方。这样，你就会得到一个包含512字节的块，这个块中包含了各个块的编号。它们都是Uint_T类型，都是短整型。
- en: unsigned shorts。 Okay， you are going to then find the 302nd mod 256 short in
    that list。 and you are going to return the number there， which refers to the index
    in the block that you are looking for。 If the block number that you are looking
    for happen to be in this eighth one here， well。 you have another level of indirection，
    so your function better account for that as well。 Okay。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号短整型。好的，接下来你需要在这个列表中找到第302个取模256的短整型，并返回其中的数字，这个数字表示你正在寻找的块的索引。如果你正在寻找的块恰好位于这里的第八个块，那么你就需要另一个间接层级，所以你的函数需要考虑这一点。好的。
- en: so you see how that works？ Great。 I'm sure you'll have questions about that
    as you start doing the assignments。 but at least at this point， hopefully you're
    at least going， "Oh。 I see what this function is trying to get me to do。 Now I
    kind of have to go through all the calculations to do it。" Good。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你看到这是怎么运作的吗？太好了。我相信当你开始做作业时，你一定会有一些问题，但是至少到目前为止，希望你至少明白，“哦，我明白这个函数要我做什么了。现在我得做一些计算来完成它。”很好。
- en: What questions you have on that？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你有什么问题吗？
- en: '![](img/12985c8e5f99b7c7460e806495676228_27.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_27.png)'
- en: Okay， good。 So I'll just delete all the Piauts questions that come up about
    it。 So you also。 of course， for this assignment have to search through the directories
    to locate a particular file。 You don't have to follow symbolic links。 There's
    no worries about what's going on with a weird symbolic link。 You don't need to
    worry about that。 You can ignore those。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太好了。那我就把关于它的问题全部删除了。那么，当然，在这个作业中，你还需要在目录中搜索以定位某个特定文件。你不需要跟随符号链接。你不需要担心符号链接有什么奇怪的情况。你可以忽略那些。
- en: You do need to consider directories that are more than 32 files。 because they
    could be as many files as we want， basically。 Do not think that that's a special
    case。 Don't say， "Oh， no， it's more than 32。 I have to handle it in some special
    way。" You have already written， presumably， you will have written at that point。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你确实需要考虑那些有超过 32 个文件的目录。因为它们可能有任意多的文件，基本上不受限制。不要认为那是特例。不要说，“哦，不，它超过了 32，我得用特殊的方式处理它。”你已经写了，假设到那时你已经写了。
- en: functions that are able to read an entire file one block at a time。 Okay。 that's
    kind of the function we just talked about。 Like， "Go find the next block in this
    file。" You do not need to make this a special case。 Too many people try that sometimes。
    It's not necessary。 Just deal with it like any other file and say， "I want to
    read the next one。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数能够一次读取整个文件的一个块。好的，这就是我们刚才讨论的函数。比如，“去找到这个文件中的下一个块。”你不需要把它当作特例。太多人有时会这么做，实际上没必要。像处理其他文件一样处理它，说，“我想读取下一个。”
- en: read the next one， read the next one。" And you'll be fine。 Okay， they all fit
    in 512 bytes。 It's not like a file entry in that can be， like， across two blocks。
    It's not going to happen because of the way they're written。 Okay？ By the way。
    you will probably need to lay some structs over this data that you get back from
    these things。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 读下一个，读下一个。" 然后你就没问题了。好了，它们都适合在 512 字节内。不是像文件条目那样，可能会跨越两个块。由于它们的写法，跨块的情况不会发生。明白吗？顺便说一下，你可能需要在这些从中得到的数据上放一些结构体。
- en: Right？ There's going to be structs of different things like directory entries
    and so forth。 Take those and kind of apply them in a CS107 sense to the data。
    and you'll be able to read them off directly。 Okay？
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？会有不同类型的结构体，比如目录条目等等。把它们应用到数据上，按照 CS107 的方式处理，你就能够直接读取它们了。明白吗？
- en: So that's the kinds of things I could think about。 All right？ Don't forget，
    and this is one thing。 file names are 14 characters maximum。 And if they happen
    to be exactly 14 characters， well。 there's no trailing zero at the end。 Why？ Because
    they wanted to save one byte。 For all those 14 length files， they wanted to save
    one byte and said， "Oh， if it's 14。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我能想到的事情。好吧？别忘了，这是一个要点。文件名最大为 14 个字符。如果它们恰好是 14 个字符，那么没有结尾的零。为什么？因为他们想节省一个字节。对于所有这些
    14 长度的文件，他们想节省一个字节，于是说，“哦，如果是 14 个字符的话。”
- en: I don't need to worry about it。"， So what that means is if you're trying to
    compare two file names。 like one that you're looking for and one that's in your
    data， you better not use Stercomp。 because Stercomp looks for the n zero on the
    end。 You might want to use Stercomp or do some other method to say。 "Hey， is there
    a zero at the end there？"， Okay？ You probably shouldn't do Sturlenn either。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要担心这个。" 那么，这意味着如果你尝试比较两个文件名，比如一个是你在找的，另一个是你数据中的文件名，你最好不要使用 Stercomp。因为 Stercomp
    会查找末尾的零。你可能想使用 Stercomp 或者做其他方法来检查，“嘿，末尾有零吗？”，明白吗？你也许不应该使用 Sturlenn。
- en: because Sturlenn， all those string functions presume that it's a properly formatted
    string。 If you have a 14 character name， not properly formatted string， but still
    in the file system。 Okay？
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Sturlenn，所有这些字符串函数都假定它是一个格式正确的字符串。如果你有一个 14 个字符的名称，它并不是格式正确的字符串，但仍然存在于文件系统中。明白吗？
- en: Little nuances like that。 That happens in programming。 Like we try to save some
    space here and say。 "You better document it if you're going to build something
    like that。" And of course they did。 Good？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这种小细节。在编程中常常会发生这种情况。我们试图节省一些空间，然后说，“如果你要做这样的事情，最好文档化一下。”当然，他们做到了。好吗？
- en: All right。 That is assignment one。 It's a relatively advanced assignment。 I
    mean。 it's the first assignment where you're doing new stuff that you've seen
    only in this class and haven't done before。 Please start early。 You hear that
    in every class。 Come to Office Hours， Ask Piauts questions。 obviously。 The CAs
    are not going to look at your code for this。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。这是作业一。是一个相对高级的作业。我的意思是，这是第一个你开始做新的内容的作业，这些内容你在这门课上才见过，之前没做过。请尽早开始。你在每门课上都会听到这句话。来上办公时间，问
    Piauts 问题，显然。助教不会看你这次作业的代码。
- en: So if you have questions about your code formulated in some sort of conceptual
    way and say。 "Here's what I'm trying to do。 What am I doing wrong or what kinds
    of things do I need to think about because I'm trying to do this and draw some
    diagrams and so forth that the CAs can help you with。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你有关于代码的问题，按某种概念性的方式表达出来并说：“这是我想做的事。我做错了什么？或者我需要考虑哪些问题，因为我在做这个并画一些图等等，助教可以帮助你。”
- en: They're not going to like--they will look at error messages and they'll try
    to figure that out。 But they're not going to dig into your code and try to figure
    out what you're trying to do。 They're going to ask you， "What are you trying to
    do？ Here's the conceptual framework you find it。" Okay？ All right。 Other questions
    about that？ The assignment？ It's kind of a fun one。 I mean。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不会喜欢——他们会查看错误消息，试图弄清楚。但他们不会深入研究你的代码，试图理解你到底在做什么。他们会问你，“你在做什么？这是你能找到的概念框架。”明白吗？好的。还有其他问题吗？作业？其实是一个挺有趣的作业。我是说。
- en: it's definitely a pretty media assignment。 As far as it goes。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个相当不错的媒体任务。就目前来看是这样的。
- en: '![](img/12985c8e5f99b7c7460e806495676228_29.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_29.png)'
- en: Okay。 All right。 Let us go back to multi-processing。 Okay。 So here's where we
    left off on Monday。 On Monday we said， "Hey， there's this new function called
    fork。 It's actually a system call。 It's called fork。 It takes no parameters。 And
    it just returns to you a number integer which is either the PID of the child process
    that for creates if you are the parent that created that called fork or it returns
    zero which is the value saying basically you are the child。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好了，我们回到多进程。好吧，这就是我们星期一停下的地方。星期一我们说：“嘿，有一个新函数叫做fork。它实际上是一个系统调用。它叫做fork。它没有参数。它会返回一个整数，要么是父进程创建的子进程的PID，要么返回零，表示你是子进程。”
- en: It is not the PID of the child for the child。 Okay？
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是子进程的PID。明白吗？
- en: Because you want to be able to differentiate between these two。 Okay？
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你希望能够区分这两者。明白吗？
- en: And then we started looking at some of the various programs about this。 And
    we looked at this one called fork puzzle。 Right？
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始查看一些关于这个的不同程序。我们看了一个叫做fork puzzle的程序。对吧？
- en: And we found out that it turns out that with fork puzzle you can end up with
    data and going in--or the output in some order that you can't predict。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们发现，实际上在fork puzzle中，你可能会遇到数据或输出以你无法预测的顺序出现。
- en: '![](img/12985c8e5f99b7c7460e806495676228_31.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_31.png)'
- en: Right？ If I do it again it'll probably be a slightly different order。 And in
    fact this time it went and we found that the parent finished before one of the
    children。 And so the command of the crop came back and then they got this weird
    D at the end。 And it was kind of ugly and kind of things that you don't necessarily
    want。 Okay？
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？如果我再做一次，顺序可能会稍有不同。事实上，这次我们发现父进程在某个子进程之前就完成了。所以crop命令返回了，然后他们在最后得到了一个奇怪的D，感觉有点丑，像是你不想要的东西。明白吗？
- en: We want to make this a little bit more predictable if we can help it。 And specifically
    we want the parent to be able to wait for the child。 Okay？
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望如果可能的话，让它变得更加可预测。特别是我们希望父进程能够等待子进程。明白吗？
- en: We want the parent to be able to say I'm going to wait for any children I create
    to finish。 Okay？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望父进程能够说“我将等待我创建的任何子进程完成”。明白吗？
- en: So how do we do that？ Well， we use this system called weight PID。 Okay？ Weight
    PID。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该怎么做呢？嗯，我们使用了一个叫做weight PID的系统。明白吗？weight PID。
- en: '![](img/12985c8e5f99b7c7460e806495676228_33.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_33.png)'
- en: Weight PID has a few arguments of course and it has an argument that's a PID。
    Most of the time as it turns out we won't actually put a PID in there。 You'll
    see why later。 But it stands for the weight set which can be one PID。 Like I am
    looking for a particular child or it can be another number like negative or like
    yeah negative one which means wait for any child。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: weight PID当然有几个参数，其中有一个是PID。事实证明，大部分情况下我们实际上不会在里面放一个PID。你稍后会明白为什么。但它代表的是等待集，可以是一个PID。例如，我正在寻找特定的子进程，或者可以是另一个数字，比如负数——比如说负一，表示等待任何子进程。
- en: And then whenever any child ends this will continue。 Okay？
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每当任何子进程结束时，程序将继续。明白吗？
- en: And it does stop the parent until a child ends。 Okay？
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它会暂停父进程，直到子进程结束。明白吗？
- en: The parent just sits there and waits and doesn't do anything。 And by the way
    it doesn't use up lots of processor time either。 The kernel。 the operating system
    says， "Oh， you're waiting for the child。" Okay。 just go to sleep for a while and
    it doesn't do any processing which is a good thing。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 父母只是静静地坐在那里等待，并没有做任何事情。而且顺便说一下，它也不会消耗大量的处理器时间。操作系统，内核会说，“哦，你在等孩子。” 好的，那就先休息一下，不会进行任何处理，这是一件好事。
- en: We like that in our programs。 Okay？ So that's that。 It also takes an address
    of a。 get to your second one second。 It takes an address of a status。 So you pass
    in the address of an integer and it will populate that integer with your。 with
    the result of the weight PID call。 Which can be an error or it can encompass the
    return value and so forth。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中喜欢这么做。好吗？所以就是这样。它还需要一个地址。等一秒，接下来是第二个。它需要一个状态的地址。所以你传入一个整数的地址，它会用你调用等待
    PID 后的结果填充那个整数。可能是一个错误，也可能是包含返回值等等。
- en: And then finally we have the options which are basically a bitwise or set of
    options。 For now we're going to make it zero because we're going to get to those
    later。 Okay？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有基本上是按位或设置的选项。现在我们先将其设置为零，因为稍后我们会处理这些。好吗？
- en: There are no options we're going to worry about right now。 Question。 Good question。
    If the child makes a child， does the weight PID wait for that？ No。 The child can
    only wait for its own child in that case。 The parent doesn't necessarily know
    that its own child。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有需要担心的选项。问题。好问题。如果孩子有了孩子，等待 PID 会等待那个吗？不。在这种情况下，孩子只能等待它自己的孩子。父母不一定知道它自己的孩子。
- en: that its grandchildren or it can wait for those。 No。 It does need to wait for
    only its children。 Good question。 All right。 Anything else on that？ Let's see
    an exact， yeah。 That's a good question。 If the， okay， you're getting into the
    weeds here。 If the parent has a child and the child has a child。 the grandchild
    does not have any relation to the grandparent to the extent that it will wait。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它的孙子或者它是否需要等待呢？不。它只需要等待它的孩子。好问题。好吧。还有别的问题吗？让我们来看一个具体的例子，嗯。那是个好问题。如果，嗯，好吧，你开始进入细节了。如果父母有一个孩子，而孩子有一个孩子，那么孙子与祖父母之间没有任何关系，以至于它需要等待。
- en: When the parent's child ends， even if the parent's grandchild keeps going。 the
    parent will get notified。 So， no。 It doesn't sit there and wait for any of grandchildren
    to finish。 If you use weight-purity for both， then the child can't finish until
    its child finishes。 which means the parent will not finish until the child finishes。
    Yeah。 So。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当父母的孩子结束时，即使父母的孙子继续进行，父母也会收到通知。所以，不。它不会一直等待任何孙子完成。如果你为两个都使用等待纯度，那么孩子必须等到它的孩子完成后才能完成。也就是说，父母必须等到孩子完成后才能完成。是的。所以。
- en: you can string them along like that， but you have to be a little careful with
    that。 But don't think that somehow the grandchildren all get encompassed into
    the parent。 Yeah。 Good question。 Okay。 Yeah。 Yes。 Good question。 You're saying
    you're passing in the child that you want to finish。 In this case， if we pass
    in a PID， not negative one， for instance， then it will wait for that child。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像那样串联它们，但你必须小心一些。但不要认为孙子们都会被包含在父母里面。是的。好问题。好了。是的。好问题。你是说你传入的是你希望完成的孩子。在这种情况下，如果我们传入一个
    PID，而不是负一，例如，它将会等待那个孩子。
- en: Correct。 And you can't pass in one for your grandchildren。 It doesn't know about
    that。 You only pass in ones that you might know。 They are direct children and
    yours。 You'll see。 Let's do an example and then， and then we'll see。 Okay。 By
    the way。 the return value is the PID of the child or negative one if there was
    no。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正确。你不能传入孙子的 PID。它并不了解那个。你只会传入你可能知道的 PID。它们是直接的孩子，属于你的。你会明白的。让我们做一个例子，然后，嗯，再看看。好的。顺便说一下，返回值是孩子的
    PID，或者如果没有，返回负一。
- en: if there were no children available still running， because that could be the
    case too。 If no children happen to be still running and you say wait， PID for
    a child。 it will return negative one。 And that means， oh， there weren't need to
    wait or that one in particular had already ended。 Yeah。 Before you're done using
    the way PID that one of that child could terminate before it actually。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有子进程仍在运行，因为也有可能这种情况发生。如果没有子进程仍然在运行，而你说等待某个子进程的 PID，它会返回负一。这意味着，哦，不需要等待，或者那个特定的进程已经结束。是的。在你使用完等待
    PID 之前，那些子进程有可能已经终止。
- en: Good question。 Doesn't mean that your to the child could terminate before you
    even call it a PD。 Absolutely。 Yep。 And that's okay as it turns out。 Yeah。 By
    the way， PID also does some cleanup。 It makes it so the child process does get
    cleaned up。 So we actually should do a way PID in general。 We didn't in the program
    before because we hadn't learned about it yet。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。这并不意味着子进程可能在你调用 PID 之前就已经终止了。确实有可能。是的。这没关系，事实证明。对了，PID 也做了一些清理工作。它确保子进程得到了清理。所以一般来说，我们应该调用
    wait PID。我们在之前的程序中没有这么做，因为我们还没学到这个。
- en: but you should do it in general。 Yeah。 Again， we'll see some examples in this。
    Yeah。 Sorry。 What's the question again？ If you call wait， PID on the root or well，
    let's just put it this way。 If you the if you call wait， PID on， you should call
    it only on your children or use negative one and we'll get to what that is in
    a bit。 If you only call it on the children， if your children already ended。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但一般来说，你应该这么做。是的。我们稍后会看到一些例子。对不起，问题是什么来着？如果你在根进程上调用 wait，PID，或者说，我们这么理解。如果你调用
    wait，PID，你应该只在子进程上调用，或者使用负一，我们稍后会解释这个。如果你只在子进程上调用，且你的子进程已经结束。
- en: the return value will be negative one， which is fine。 You'll be able to catch
    that。 Or it will give you back the PID saying， hey， yeah， that child just ended。
    All you really need to know about that。 And we'll see how it manifests itself
    in a minute。 Yeah。 What happens if you add a property that owns PID and you feel
    waits at？ If you add your own process。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值将是负一，这没问题。你可以捕捉到这一点。或者它会返回 PID，告诉你，嘿，是的，那个子进程刚刚结束了。这就是你需要知道的内容。我们稍后会看到它是如何表现出来的。是的。如果你添加了一个拥有
    PID 的属性并且你等待它会怎样？如果你添加了自己的进程。
- en: it is not a child of you， so it'll kind of ignore that， I believe。 So you're
    not going to wait on your own PID。 So what would it play？
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是你的子进程，所以它会忽略这个，我相信。所以你不会等待你自己的 PID。那么它会怎么玩？
- en: I don't think anything will happen， actually。 Like。 I don't think it'll crash
    or wait forever or whatever。 But no， I don't think we can try it。 but I don't
    think that's what's going to happen。 I don't think anything will happen as it
    turns out。 It'll probably return negative one saying， no， that one's not even
    in your child's set at all。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得实际上什么也不会发生。就像，我不认为它会崩溃或永远等待之类的。但是不，我认为我们可以尝试一下。但我不认为会发生那种情况。事实证明，什么也不会发生。它可能会返回负一，表示不，这个根本不在你的子进程集合中。
- en: It's probably what will happen。 Okay， let's look at an example。 Okay。 What we're
    going to do is we're going to do an example called separate。 I don't need to do
    that right now。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能就是发生的情况。好，我们来看一个例子。好，我们要做的是一个名为 separate 的例子。我现在不需要做这个。
- en: '![](img/12985c8e5f99b7c7460e806495676228_35.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_35.png)'
- en: We're going to do an example called separate， which is going to use some of
    this information。 this wait PID， so that we can actually do something where we
    know what's going to happen and the ordering is going to happen in it。 Okay， so
    here's what we're going to do。 We're going to say print F before。 So this is the
    first thing that's going to happen is going to， it's going to print before。 Okay。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做一个名为 separate 的例子，这个例子会用到一些信息。这个 wait PID，这样我们就可以做一些事情，知道会发生什么，并且事件的顺序会怎样。好，接下来我们要做的是打印
    F before。所以这是第一件发生的事，它会打印 before。
- en: and then we're going to say PID T， PID equals fork。 and that's going to do this
    process separation business。 Okay。 and then we're going to say print F after。
    How many of these should we get to， right？
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将说 PID T，PID 等于 fork。这将实现进程分离。好，然后我们会说 print F after。我们应该得到多少个？
- en: Because now we have one extra process and both are going to do that。 Okay， if
    PID equals zero。 what does that mean？ Child， or the child。 Okay， if the PID equals
    zero。 Okay。 you're going to want to say something like print F， I am the child。
    Okay。 and the parent will wait up for me。 Okay， it's kind of a nice analogy in
    that sense。 If you want。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在我们有了一个额外的进程，两个进程都会这么做。好，如果 PID 等于零。那意味着什么？子进程，或者说子进程。好，如果 PID 等于零。好，你应该说类似
    print F，我是子进程。好，父进程会等待我。好，从这个角度来看，这其实是一个不错的类比。如果你愿意。
- en: Okay， and then we're going to immediately return if we are the child。 and let's
    just return 110 for CS 110 or whatever。 It doesn't matter。 We're just going to
    show that it's not zero。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，然后如果我们是子进程，我们将立即返回。我们就返回 110，表示 CS 110 或者其他。无所谓。我们只是想展示它不是零。
- en: '![](img/12985c8e5f99b7c7460e806495676228_37.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_37.png)'
- en: Just the return value。 You can actually get the return value from the。 you can
    get the return value from the return when the child ends。 which is kind of nice
    because maybe you want to know what happened with your child that it ended appropriately
    or not。 or maybe you'll pass some information that way if you want to。 Okay， all
    right。 At this point。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只是返回值。你实际上可以从子进程结束时获取返回值。这很不错，因为也许你想知道子进程是否正确结束，或者你可能想通过这种方式传递一些信息。好吧，到此为止。
- en: we can put an else。 This else is not strictly necessary because of the way we've
    done our program。 right？ It will always， the child will always return at this
    point。 Okay。 so the else is not really necessary in that case。 But anyway。 the
    point is that it's now we're saying we are the parent in here。 Okay。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以加一个 else。这个 else 并不是绝对必要的，因为我们编写的程序方式。对吧？它总是会在这一点上返回子进程。好吧，所以在这种情况下，else
    并不是真的必要。但不管怎样，重点是现在我们可以说我们在这里是父进程。明白了吗？
- en: and the parent is going to have a status。 Okay， and the parent is going to do
    wait PID。 For now。 we're just going to wait for the actual PID。 We're going to
    pass in a pointer to the status。 and we're going to pass in zero for the options。
    We'll get to what the options mean later。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程会有一个状态。好吧，父进程会执行 wait PID。现在，我们只需要等待实际的 PID。我们会传入状态的指针。并且我们会为选项传入零。稍后我们会解释这些选项的含义。
- en: '![](img/12985c8e5f99b7c7460e806495676228_39.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_39.png)'
- en: Okay， all right。 After this， this will wait until the child finishes。 Okay，
    and then it will， yeah。 question。 The status doesn't need to be initialized。 It's
    going to pass in a pointer。 and it's going to be changed。 It's not used。 The function
    is not using the value of status。 It's populating the value of status for you。
    Okay。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题。在这之后，这个函数会等待子进程完成。然后，嗯，问题来了。状态不需要初始化。它会传入一个指针，并且它会被更改。它没有被使用。函数没有使用状态的值。它是在为你填充状态的值。明白了吗？
- en: it's another way to get kind of two return values， if you will。 The status and
    the actual PID。 It's kind of the C way of doing that。 Okay， so we're going to
    do that。 Now。 we're going to check some things about this。 Okay， we're going to
    use a macro。 which basically is an， you can think of it as an inline function。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是获取两种返回值的另一种方式。如果你愿意，可以这么理解。状态和实际的 PID。这是 C 语言处理这个问题的方式。好吧，所以我们现在要这么做。现在，我们要检查一些内容。好吧，我们会使用一个宏，你可以把它理解为一个内联函数。
- en: We've seen a little bit of those before， but it's called WIF-exited。 Okay。 now
    I know that looks like wife exited。 And I always say that when I think it because
    I read it and I go。 oh， that means， but it's not。 It means WIF-exited。 And what
    it does is it checks the status。 Okay。 and if the status is， if that macro returns
    true， it means， okay， it was fine。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看过一点类似的内容，但它叫做 WIF-exited。好吧，现在我知道它看起来像是 wife exited。我每次想到它时都会这么说，因为我读到这个时会想，哦，这意思是……但其实不是。它的意思是
    WIF-exited。它的作用是检查状态。好吧，如果宏返回 true，意味着状态是正常的。
- en: It exited with a regular old return value。 I'll show you what that means when
    it doesn't happen in a few minutes too。 Okay， and what you can do is you can print
    F and you can say child exited with status percent D。 Okay， and this is going
    to be the actual， it probably shouldn't be status should be something like the
    return value or whatever。 And then you get another macro， which does exited status，
    sorry， W exit status。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它用一个普通的返回值退出。我会向你展示当没有发生这种情况时它意味着什么，稍后几分钟我也会解释。好吧，你可以做的就是打印 F，然后你可以说“子进程以状态百分比
    D 退出”。好吧，这就是实际的，可能不应该叫状态，而应该是像返回值之类的东西。然后你得到另一个宏，它做的是退出状态，抱歉，W exit 状态。
- en: And that's going to give you the status。 It's just reading off these bits because
    the。 the actual macro or the status variable holds a whole bunch of information
    in it。 Part of it is the return value。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你状态。它只是读取这些位，因为实际上宏或状态变量里包含了很多信息。其中一部分就是返回值。
- en: '![](img/12985c8e5f99b7c7460e806495676228_41.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_41.png)'
- en: Part of it is the other information about how it exited and so forth。 Okay。
    so that's what we're going to do there。 All right。 And then we want to do what？
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一部分包含关于子进程如何退出等的其他信息。好吧，这就是我们接下来要做的。好吧，接下来我们要做什么？
- en: We want to do an else on this case。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想加一个 else。
- en: '![](img/12985c8e5f99b7c7460e806495676228_43.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_43.png)'
- en: So let's say that we had bad news。 The child didn't exit correctly。 We can print
    F child terminated。 Ab normally。 Okay， something like that。 Okay。 And then we've
    got that。 And then after this。 we can just return zero。 Okay。 So that's what's
    going to happen。 Okay。 Anybody see any type of。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们遇到不好的情况。子进程没有正常退出。我们可以打印“子进程异常终止”。类似这样的信息。然后在这里，我们可以返回零。好了，这就是会发生的情况。大家看到什么问题了吗？
- en: '![](img/12985c8e5f99b7c7460e806495676228_45.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_45.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_46.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_46.png)'
- en: We'll find out。 Make separate。 Okay， looks good。 Okay。 So if we run it， right，
    it says before。 after， after， and then it says， I am the child and the parent
    will wait up for me。 Child exited with status 110。 And it will always be in that
    order。 no matter how many times I run it。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看。做分离。好，看来没问题。那么如果我们运行它，输出是：先是“之前”，接着是“之后”，然后打印“我是孩子，父进程会等我”。子进程以状态110退出。无论我运行多少次，输出都会按这个顺序进行。
- en: '![](img/12985c8e5f99b7c7460e806495676228_48.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_48.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_49.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_49.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_50.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_50.png)'
- en: Okay。 Because the parent is forced to wait until the child exits at which point
    that we are all set。 Okay。 All right。 You might be asking yourself， well， how
    could it exit？ Ab normally？ Well。 how might we make the child exit in a bad way？
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。因为父进程必须等到子进程退出后才能继续执行，这样我们就都准备好了。好的。那么你可能会问，子进程怎么退出？正常退出吗？我们怎么让子进程以错误的方式退出呢？
- en: '![](img/12985c8e5f99b7c7460e806495676228_52.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_52.png)'
- en: In other words， crash it。 Can I get the job to crash？ We can do a bunch of things。
    We could divide by zero if we wanted to。 How about this？ This is one that I was
    like。 int star a equals no。 Asterisk a equals five。 That would be bad news， right？
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，崩溃它。我能让程序崩溃吗？我们可以做很多事情。如果我们想的话，甚至可以做除零运算。怎么样？这是我曾经遇到过的一种情况：`int* a = NULL;
    *a = 5;` 那将是个大麻烦，对吧？
- en: Try to dereference in place of value at no， which is going to be bad， bad news，
    right？
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试去解引用一个`NULL`值，那将是个大麻烦，对吧？
- en: And if the compiler shouldn't actually care about it。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器其实不应该关心这个。
- en: '![](img/12985c8e5f99b7c7460e806495676228_54.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_54.png)'
- en: Make separate。 There we go。 Okay。 Separate。 And before， after， after， I'm the
    child。 the parent will wait up for a child terminated normally。 Right？ We killed
    the child。 That got the exit status to be to tell you that。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 做分离。好了，分离。接下来，子进程会在父进程等待子进程正常终止之后结束，对吧？我们杀死了子进程。然后获取它的退出状态，告诉你。
- en: '![](img/12985c8e5f99b7c7460e806495676228_56.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_56.png)'
- en: Oh， bad news。 Something happened。 Okay。 Question。 Is it possible for the child
    to print like the child？
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，出问题了。发生了什么事情。好了，问题来了。子进程能打印出“我是孩子”吗？
- en: Is it possible for the child to print？ I am the child before the child parent
    prints after。 It is possible。 It's probably not going to happen in this case，
    but that's perfect。 Yes。 That's possible。 So I guess in this case， it could happen
    that that's the case。 It's probably not just because that's a good point。 Yeah。
    So that is a。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子能在父进程打印之前打印“我是孩子”吗？是有可能的。虽然在这种情况下可能不会发生，但这完全是可能的。是的，可能的。所以我猜在这种情况下，确实有可能发生这种情况。可能性不大，但这是个很好的问题。对，就是这样。
- en: '![](img/12985c8e5f99b7c7460e806495676228_58.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_58.png)'
- en: By the way， this is a good term to learn。 That's called a race condition。 And
    a race condition means two things are going down some paths at the same time。
    One of them is going to win， but you don't know which one is going to win。 We
    try to avoid race conditions in this class。 Sometimes you absolutely have race
    conditions and therefore you have to do some logic to make sure you know what
    will happen。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这是个不错的术语，值得学习。这被称为竞争条件。竞争条件意味着两件事同时沿不同路径进行。其中一个会“赢”，但你无法预知哪个会先完成。在这门课上，我们尽量避免竞争条件。有时你必须处理竞争条件，因此需要编写一些逻辑，确保你知道接下来会发生什么。
- en: Okay。 When we get to threads， you'll see this a lot with， well， actually。 you'll
    see it in processes a lot too。 But in particular。 if you're trying to modify shared
    data structures。 you have race conditions where they're both two things might
    be trying to do that。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。当我们讨论线程时，你会看到很多这种情况，实际上。你也会在进程中看到这种情况。但特别是，如果你试图修改共享数据结构时，你会遇到竞争条件，在这种情况下，两个操作可能同时进行。
- en: you want to avoid that。 So you， you handle in ways that we'll talk about。 Question。
    Yeah。 In the L statement where it calls way PID down here， yes？
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你想避免这种情况。所以，你要以我们将要讨论的方式来处理它。问题吗？是的，L 语句中调用 `wait PID` 这一部分，对吗？
- en: '![](img/12985c8e5f99b7c7460e806495676228_60.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_60.png)'
- en: '[inaudible]。'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]。'
- en: '![](img/12985c8e5f99b7c7460e806495676228_62.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_62.png)'
- en: Isn't that supposed to be a child's PID？ It is the child's PID because remember
    what is the return value for fork？
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该是子进程的 PID 吗？是的，它是子进程的 PID，因为记得 `fork` 的返回值是什么吗？
- en: The parent gets the child's PID as its return value。 So yes， that's exactly。
    And that's why that happens so you can use it。 It turns out a good question。 Any
    other questions on this？ Okay。 Let's keep going。 So this function。 the output
    is same every time barring that one thing where the child could print the。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程会得到子进程的 PID 作为返回值。是的，正是如此。这就是为什么会发生这种情况，你可以利用它。这个问题很好。还有其他问题吗？好的，我们继续。这个函数每次的输出都是一样的，除了那一点：子进程可能会打印。
- en: could print the after and then it's line before the parent even gets to after。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会在父进程在 `after` 之前就打印出来。
- en: '![](img/12985c8e5f99b7c7460e806495676228_64.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_64.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_65.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_65.png)'
- en: The parent， the whole reason this works in the order we expect is because the
    parent waits for the child to end。 And then you use these macros to actually get
    more information about this。 And you might be able to say， wait a minute， how
    can you overlap the return value and other information？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程，之所以能按我们预期的顺序工作，是因为父进程会等待子进程结束。然后你使用这些宏来获取更多的信息。你可能会问，等等，怎么能重叠返回值和其他信息呢？
- en: Right？ Wasn't the return value an int？ Not really。 Return values are supposed
    to be between 0 and 255。 So you have lots of extra bits in that int to store other
    information。 That's the way return values should be。 They are ints but you should
    limit them between 0 and 255。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？返回值不是应该是一个 int 吗？其实并不是。返回值应该在 0 和 255 之间。所以你在那个 int 中还有很多额外的位可以用来存储其他信息。这就是返回值应该是这样的原因。它们是
    int 类型，但你应该将它们限制在 0 到 255 之间。
- en: That's the way it goes。 Okay。 And then as I said， the wait PID does donate the
    resources back to the system。 In other words， it's kind of the cleanup that you
    like to do at the end of the program when something happens。 You should be doing
    this wait PID for all of your children as it turns out。 Okay。 Better for the。
    in the end， no matter what the system will clean up for you but it's just like
    doing free after you do a malloc。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。好的，正如我之前说的，`wait PID` 确实会将资源归还给系统。换句话说，这就像你在程序结束时进行的清理操作。当发生某些事情时，你应该为所有子进程执行
    `wait PID`。最终，不管怎样，系统会帮你清理，但这就像在调用 `malloc` 后你做的 `free` 一样。
- en: It's nice to do because it cleans things up。 All right。 What else？ Okay。 So。
    let's look at another example。 Okay。 In this other example。 we're going to see
    it's kind of a little bit of a brain teaser。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做很好，因为它能清理资源。好的，接下来呢？好，我们来看看另一个例子。在这个例子中，我们将看到一个有点像脑筋急转弯的问题。
- en: '![](img/12985c8e5f99b7c7460e806495676228_67.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_67.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_68.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_68.png)'
- en: And we're going to， we're just going to kind of walk through it and say。 and
    it's going to demonstrate to you how deep this copy actually is。 Okay。 This one
    is going to be called the what？ This one is going to be parent child。c。 Okay。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将逐步讲解，展示这个复制到底有多深。好的，这个例子将被称为“父子进程.c”。 '
- en: '![](img/12985c8e5f99b7c7460e806495676228_70.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_70.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_71.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_71.png)'
- en: Here's what we're going to do here。 This is going to involve random numbers。
    Okay。 We're going to have some randomness in here。 Okay。 And in this case。 what
    we're going to do is we're going to first say print F， I am unique。 And just get
    printed once。 Okay。 And we know why that's the case because there's no forking
    yet。 Okay。 And then we'll do PIDT。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是这个。这将涉及随机数。好的，我们将在这里添加一些随机性。好的，在这种情况下，我们首先会说 `printf`，我很独特。并且只会打印一次。好的，我们知道这是为什么，因为还没有进行
    `fork` 操作。然后我们将做 PIDT。
- en: PID equals fork like we kind of always do。 Then I'm going to just do a make
    figure out a little Boolean。 Boolean parent equals PID equals， let's see， PID
    is not equal to zero。 Okay。 What is that all about？
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PID 等于 fork 就像我们通常做的那样。然后我要做一个布尔值判断。布尔值 parent 等于 PID 等于，看看，PID 不等于零。好吧。这是什么意思呢？
- en: Basically it's saying if it's the parent， in other words， if the PID is not
    zero， it's the parent。 It's just going to set that。 Otherwise it's not going to
    be the parent。 Okay。 It's just kind of a fancy way of doing that。 Okay。 All right。
    And then we're going to。 we're going to say， okay， if random， which is going to
    give you a random number。 Okay。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上是说，如果是父进程，换句话说，如果 PID 不等于零，那么它就是父进程。它就会设置这个。否则就不是父进程。好吧。它只是一种巧妙的做法。好吧。然后我们会说，如果是随机的，那将会给你一个随机数。好吧。
- en: '![](img/12985c8e5f99b7c7460e806495676228_73.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_73.png)'
- en: Mod two equals zero and that equals the parent。 In other words， this is C。 so
    one and zero are true and false basically。 Okay。 If that equals the parent。 then
    we're going to sleep for one second。 That's what this means。 Okay。 Sleep is another
    command that basically says turn your process off for that amount of time and
    then wake it up again after that amount of time。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Mod 两等于零，这就代表父进程。换句话说，这是 C。所以 1 和 0 基本上是对和错。好吧。如果等于父进程。那我们就休眠一秒钟。意思就是这样。好吧。Sleep
    是另一个命令，基本上是让你的进程在那段时间内暂停，然后在这段时间后再次唤醒它。
- en: Okay。 All right。 And then if we are the parent， we are going to wait PID for
    PID。 No。 Oops。 No。 And zero for basically because we're not doing anything there。
    Okay。 Parent waits for child in that case。 Okay。 And then we're going to say print
    F， I get printed twice。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后如果我们是父进程，我们就要等待 PID 等于 PID。不是。哎呀。不对。零是因为我们什么也不做。好吧。在这种情况下，父进程等待子进程。好吧。然后我们会说
    print F，我被打印了两次。
- en: '![](img/12985c8e5f99b7c7460e806495676228_75.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_75.png)'
- en: This one is from percent S， comma， if I'm the parent， I'm going to print out
    parent。 Otherwise。 I'm going to print out child。 Okay。 And then we're going to
    return zero。 Okay。 So what this is doing is this is going to set up so that only
    one of the two actually gets to sleep。 Right。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是来自 percent S，逗号，如果我是父进程，我就打印父进程。否则，我就打印子进程。好吧。然后我们会返回零。好吧。所以这意味着什么呢？这会设置这样一个规则，只有两个进程中的一个能休眠。对吧？
- en: '![](img/12985c8e5f99b7c7460e806495676228_77.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_77.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_78.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_78.png)'
- en: And if it's the parent， it's going to have to wait for the child。 Okay。 Make
    parent child。 Okay。 Parent child。 Now， you kind of have to， I'm going to put it
    up here。 You kind of have to watch this pretty closely because it's only one second。
    Right。 But watch what happens。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是父进程，它就得等子进程。好吧。让我们做个父子进程。好吧。父子进程。现在，你得注意了，我要把它放在这里。你得盯着看，因为只有一秒钟。对吧。但看看会发生什么。
- en: '![](img/12985c8e5f99b7c7460e806495676228_80.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_80.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_81.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_81.png)'
- en: Boom。 I mean， you can get printed once。 It waited for a little bit of time and
    then I get printed twice。 Okay。 If I run it again， it printed that I got printed
    twice immediately。 And then printed the next one。 I'll show you again。 Let's see
    which one happens here。 Okay。 So that means that the parent was the one that had
    to sleep。 Okay。 And then maybe they're again。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸。我的意思是，你可以只打印一次。它稍等了一下，然后我打印了两次。好吧。如果我再运行一遍，它会立即打印出我被打印了两次。然后打印下一个。我再给你看一次。我们来看这里会发生什么。好吧。所以这意味着父进程必须等待。好吧。然后也许它们又来了。
- en: And the child is the one that had to sleep。 Okay。 Everybody see how that's working。
    Only one of them actually allowed to do that。 What seems weird about this？
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 而且是子进程必须等待。好吧。大家看到它是如何工作的了吗？实际上只有一个能做到这一点。这看起来有什么奇怪的地方吗？
- en: We've got random numbers in here。 What seems a little bit weird？
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有随机数。看起来有什么奇怪的地方吗？
- en: Why wouldn't it ever be the case that two of them could sleep？
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么两者不能同时休眠呢？
- en: '![](img/12985c8e5f99b7c7460e806495676228_83.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_83.png)'
- en: It's a random number for each one。 Yeah。 Is the seed of the random number you're
    sharing to change your confidence？
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有一个随机数。是的。你共享的随机数的种子会改变你的结果吗？
- en: That's a perfect answer。 The seed is actually shared between the two processes
    because everything is shared。 In other words， random numbers are not really random。
    They're pseudo random numbers。 Which means that there's an algorithm which decides
    which number comes next。 Okay。 And it should be seemingly random。 Okay。 And what's
    going on here is we're saying， oh， okay。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完美的答案。种子实际上是在两个进程之间共享的，因为一切都是共享的。换句话说，随机数并不是真正的随机数。它们是伪随机数。也就是说，有一个算法决定了下一个数字是什么。好吧。它应该是看起来随机的。好吧。这里发生的事情是我们在说，哦，好吧。
- en: We are both calling the random function in two different processes。 but it's
    the exact same random generator。 So the next random number will be the same for
    both。 meaning only one of them will end up sleeping。 Question？
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个不同的进程中都调用了随机函数，但它们使用的是完全相同的随机生成器。所以下一个随机数字对两者来说都会是一样的。这意味着只有其中一个会进入休眠。明白了吗？
- en: So that's kind of the x random random number。 Yeah。 So the x random is just
    seeding the random number with the current time as it turns out。 Don't worry about
    random numbers too much， but a pseudo random number generator says。 I'm going
    to start somewhere in my list of random numbers。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是x随机数。对。所以x随机数只是用当前时间作为种子生成随机数。别太担心随机数，实际上伪随机数生成器是这样工作的。它会在我的随机数列表中的某个地方开始。
- en: and I'm going to start giving you what look like random numbers after that。
    And the seed says start here， basically the way it works。 Okay。 So it's not really
    random。 it's pseudo random。 But it kind of demonstrates that， oh yeah， they both
    have the same memories。 It turns out。 Yeah。 What happens if you comment out the
    19？ If you comment out the 19。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将开始给你们看一些看起来像是随机的数字。种子说从这里开始，基本上就是它的工作方式。好吧。所以这其实并不完全是随机的。它是伪随机的。但它有点演示了，哦，对，它们有相同的记忆。结果就是这样。是的。如果你注释掉19会发生什么？如果你注释掉19的话。
- en: nothing would happen to have any different except that it would， well， I get
    that's not true。 It would probably do the exact same thing every time because
    the random number generator starts in a particular。 value every time。 And we can
    see if that's the case， we can try it and see if that， in other words。 no matter
    when you start a program， it's going to。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它会，嗯，我明白了，实际上并不会有任何不同。它可能每次都会做完全相同的事情，因为随机数生成器每次都会从某个特定的值开始。而我们可以看看是否是这样，试试看，换句话说，不管什么时候你开始程序，它都会。
- en: so let's see if we run parent child looks like the parent slept， the parent
    slept， the parent slept。 so it's going to be the same one every time。 We could
    probably print out the random number and it's going to be the same one every time。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们看看，如果我们运行父进程和子进程，似乎父进程在休眠，父进程在休眠，父进程在休眠。所以每次都会是同一个。我们可能会打印出随机数，它每次都会是同一个。
- en: '![](img/12985c8e5f99b7c7460e806495676228_85.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_85.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_86.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_86.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_87.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_87.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_88.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_88.png)'
- en: Why is the parent sleeping when it goes slow like that？ Good question。 What's
    the code look like？
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么父进程会在那样慢下来时休眠？好问题。代码是什么样的？
- en: Right？ The code says， I'm going to take this back out again or put that back
    in again。 Okay。 It says， if you are the parent， right， or if the random number
    equals what the parent is。 in other words， if the parent is one， then the random
    number is one， then sleep。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？代码说，我将把这个拿出来，或者再放回去。好吧。它说，如果你是父进程，对吧，或者如果随机数等于父进程的值。换句话说，如果父进程是1，那么随机数是1，那么就休眠。
- en: '![](img/12985c8e5f99b7c7460e806495676228_90.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_90.png)'
- en: Right？ Otherwise the other one has to be the one sleeping， which is the child。
    And remember。 the parent is the one that is not going to even print。 I get printed
    twice until after the child ends， so if it's sleeping。 it's going to wait until
    the child prints it and then the parent does。 Make sense？
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？否则另一个就必须是休眠的那个，也就是子进程。记住，父进程是那个直到子进程结束才会打印的那个，所以如果它在休眠，它会等到子进程打印完后再由父进程打印。明白了吗？
- en: Let's look at it again。 Yeah， question。 The sleep has to just sleep the parent，
    right。 because only whatever process it's in。 Okay。 Let's look at it again here。
    Parent child。 Okay。 I'm going to， I'm going to print it once。 And then the child
    got printed before you could see that it waited a little bit。 then the child got
    printed immediately。 Right。 And now it's going to be， well， in this case。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一遍。嗯，问题。休眠只需要让父进程休眠，对吧？因为无论它在哪个进程中。好，咱们再看一遍。父子进程。好，我会先打印一次。然后子进程在你看到它等待了一下后，马上打印出来了。对吧。现在会是，嗯，在这种情况下。
- en: it's always going to be the child is going to print。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程总是会打印。
- en: '![](img/12985c8e5f99b7c7460e806495676228_92.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_92.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_93.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_93.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_94.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_94.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_95.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_95.png)'
- en: No， it's not necessarily。 It is。 Let's say， did I make it again？ Hang on。 Hang
    on。 Did I make it again？ I thought I did。 I did。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不一定。是的。我们来假设一下，我又做了一遍吗？等等。等等。我做了吗？做了。
- en: '![](img/12985c8e5f99b7c7460e806495676228_97.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_97.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_98.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_98.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_99.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_99.png)'
- en: Parent child。 I mean， let's try to get there， guys。 Okay。 So the child got printed
    at that time immediately because it didn't sleep。 Right。 It's always going to
    be in this order because the parent has to wait until the child prints。 but whether
    or not the child prints immediately or waits a second is the difference。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 父子进程。我的意思是，大家，咱们尽量搞清楚这个。好。子进程在那时立即打印出来了，因为它没有休眠。对吧。它总是按这个顺序执行，因为父进程必须等到子进程打印出来。但子进程是否立刻打印，或者稍等一会儿，是其中的区别。
- en: '![](img/12985c8e5f99b7c7460e806495676228_101.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_101.png)'
- en: Does that help？ Yeah。 Let's look at it again。 I mean， just quickly， let's just
    look at it again。 If you， and this is the logic part that you definitely need
    to kind of understand。 Okay。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这样有帮助吗？嗯。再看一遍。我的意思是，我们就快速再看一遍。如果你理解了这个逻辑部分，你肯定需要搞清楚。好。
- en: '![](img/12985c8e5f99b7c7460e806495676228_103.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_103.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_104.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_104.png)'
- en: If the parent ends up having to sleep， that's your question in a minute。 the
    parent does have to sleep， then the parent will sleep and the child will immediately
    print it。 Does that make sense， everyone？ Does that make sense？ Yeah。 If the child
    is the one that sleeps。 both of them have to wait until the child prints it because
    the parent is definitely waiting for the child to sleep。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父进程最终不得不休眠，那你的问题就是一分钟后的事。父进程确实需要休眠，那父进程会休眠，子进程会立即打印。大家明白了吗？明白吗？嗯。如果是子进程需要休眠，那么两者都必须等到子进程打印出来，因为父进程肯定在等待子进程休眠。
- en: The parent has to wait anyway， but only because the child hasn't finished yet。
    Not because it's sleeping。 Yeah。 [inaudible]， Yeah。 Good question。 If you wanted
    to use the。 if you wanted to have a random number in both that was different。
    you would see the random number general after the fork。 [inaudible]， Oh， that's
    a good question。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程必须等，无论如何，但只是因为子进程还没完成，而不是因为它在休眠。对。[听不清]，对。好问题。如果你想要在两者中都使用不同的随机数。你会看到在分叉之后才生成随机数。[听不清]，哦，这真是个好问题。
- en: Can you actually use time because it would probably be the same time？ Yeah。
    That's going to be a little bit trouble too。 You'd have to figure out some other
    way to get a different seed and time would not be the best one。 Yeah。 There are
    other ways to get seeds， but that's a good， good point。 Very good point。 Yeah。
    Question over here。 Yeah。 Sorry。 Would you mind explaining and why only forces
    only the parent or the child would sleep？
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你能不能用时间，因为它们可能在同一时刻？嗯。那可能也会有点麻烦。你得想办法得到不同的种子，时间可能不是最好的选择。嗯。还有其他方法可以得到种子，但这是一个很好的问题。非常好的问题。嗯。这里有个问题。对。抱歉。你能解释一下为什么只有父进程或子进程会休眠吗？
- en: Yeah。 So the question is， why does it only make the parent or the child？ Okay。
    You will agree that。 hopefully agree at this point that both share the same exact
    memory。 meaning that the random number generator in both is going to give the
    same number。 Okay。 One of them based on the PID value that gets back is either
    the parent wants the child。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。那么问题是，为什么它只会让父进程或子进程？好吧。你应该同意，*希望此时你已经同意*，两者共享完全相同的内存。这意味着它们中的随机数生成器将给出相同的数字。好吧。基于返回的PID值，其中一个决定是父进程，另一个是子进程。
- en: This line right here says， if you're the， if the number mod two equals the parent，
    right？
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码的意思是，如果数字模二等于父进程，对吧？
- en: Then sleep for one， meaning that if it's a parent and the mod number， then the
    number was one。 then it would sleep。 If it's a child， it would not。 but it can't
    be both because they're both going to have different Boolean values。 Parent and
    child are both going to be different。 There was a question up here。 Yeah。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后休眠一秒，意味着如果是父进程且模二的结果是1，那么它就会休眠。如果是子进程，它不会休眠。但是它们不能同时是父进程和子进程，因为它们的布尔值会不同。父进程和子进程是不同的。这里有个问题。对。
- en: So I have a question。 [ Inaudible ]， Correct。 Only one of them is sleeping。
    Yes。 [ Inaudible ]。 At least one of them is sleeping。 Yes。 Absolutely。 So one
    of them is absolutely sleeping because they're both different Boolean values。
    Good。 Yes。 [ Inaudible ]， What's the mod two doing？ The random function call gives
    you a number between zero and two to the 32 minus one。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我有一个问题。[ 听不清 ]，对吧。只有一个进程在休眠。是的。[ 听不清 ]。至少有一个进程在休眠。是的。完全正确。所以其中一个进程绝对在休眠，因为它们的布尔值不同。很好。是的。[
    听不清 ]，模二操作是做什么的？随机函数调用会给你一个介于零和二的32次方减一之间的数字。
- en: We're just trying to make it between zero and one。 So now our mod two is between
    zero and one。 Yes。 [ Inaudible ]， If you sleep for longer， could the child wait？
    Yes。 The child actually almost always does when you're， when you're sleeping。
    Yeah。 Let's do this。 Here。 one thing we can check is let's see if parent， let's
    see if parent， here's what we're going to do。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是试图让它在0和1之间。所以现在我们的模二结果就是在0和1之间。是的。[ 听不清 ]，如果你休眠更长时间，子进程能等待吗？是的。子进程实际上几乎总是在你休眠时会等待。是的。让我们来做这个。我们可以检查一下，看看父进程，看看父进程，这就是我们将要做的。
- en: We're going to change this a little bit and we're going to say， in PID return
    equals wait PID。 And we're going to print it out and see what happens。 Print F，
    PID return。 It may actually。 you know， it may actually always give the value of
    the child。 I think it actually will。 It may give negative on。 We'll find out if
    it's already ended。 But I think it's going to。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要稍微修改一下，改成`PID return = wait PID`。然后我们会打印出来看看会发生什么。`Print F`，PID return。它可能实际上会，知道吗，它可能真的总是给出子进程的值。我想它确实会。它可能会给出负一。我们会看看它是否已经结束。但我认为它会的。
- en: I think this is not going to be what I thought it was going to be。 But anyway，
    PID return like that。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这可能不是我原本预期的样子。但无论如何，PID返回的就是这个。
- en: '![](img/12985c8e5f99b7c7460e806495676228_106.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_106.png)'
- en: Yeah。 That should do it。 Let's see。 Make parent child parent child。 Okay。 Okay。
    Return is that one。 And then now it's waiting。 No， it's always， it will always。
    it looks like it'll always give back to parent that child's one。 Even if it's
    already ended。 In fact， it would return immediately if the child has already ended。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这样应该可以。让我们看看。父进程 子进程 父进程 子进程。好吧。返回的是这个。然后现在它在等待。不是的，它总是会。看起来它总是会将返回结果给父进程，而不是子进程。即使它已经结束。事实上，如果子进程已经结束，它会立即返回。
- en: '![](img/12985c8e5f99b7c7460e806495676228_108.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_108.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_109.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_109.png)'
- en: Alright。 Anything else on that one？ One stuff， huh？ I'm getting there in this
    stuff。 Okay。 So what happens when we want to have multiple children？ Okay。 If
    we have multiple children。 then we can actually wait for all of them。 Okay。 And
    we can wait for all of them by using negative one as the PID as the first parameter
    in PID。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。还有其他问题吗？嗯？我已经快弄清楚这些了。好吧。那么如果我们想要多个子进程会发生什么？好吧。如果我们有多个子进程，那么我们实际上可以等待所有子进程。好吧。我们可以通过使用负一作为PID的第一个参数来等待所有子进程。
- en: '![](img/12985c8e5f99b7c7460e806495676228_111.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_111.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_112.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_112.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_113.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_113.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_114.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_114.png)'
- en: Wait PID， which means wait for any child。 Okay。 And if a child has ended。 return
    to me and give me the PID and so forth。 Okay。 Any， for its， its， its， absolute
    to any child。 So you're going to see we're going to do this in a while loop and
    it's going to say， okay。 we're going to wait for all the children。 You'll see
    as we， as we do this。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 等待PID，意味着等待任何一个子进程。好。如果一个子进程已经结束，返回给我并给我PID，依此类推。好。任何，关于它，绝对是任何一个子进程。所以你将看到我们将在一个while循环中做这个，程序会说，好，我们将等待所有的子进程。你会看到我们在做这个时的过程。
- en: '![](img/12985c8e5f99b7c7460e806495676228_116.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_116.png)'
- en: So reap as they exit。c。 Okay。 Here's what we're going to do。 Okay。 We are going
    to do the fun。 We're going to create eight children for size t i equals zero。
    i is less than eight。 i plus plus。 Okay。 If for。 Okay。 Okay。 Equals equals zero。
    What's that mean？ The child。 Okay。 We're going to exit with a value of one， one
    ten plus i。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在它们退出时要进行回收。好。我们要做什么呢？好，我们要做的是，我们将创建八个子进程。对于size t i等于零；i小于八；i加加。好。如果是for。好。好。等于零。这是什么意思？是子进程。好，我们将以值为一、十加i退出。
- en: So we'll get a different return value for each one of those。 One ten， one eleven，
    one twelve。 et cetera。 Okay。 And then that should do it。 So we'll always exit
    there。 And we're going to do eight of it。 Okay。 Question。 What's your reason why
    you're using an exit instead of just going return one ten plus five？
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将为每一个子进程得到不同的返回值。一十，一一一，一一二，等等。好。然后这应该就可以了。所以我们将始终在那里退出。然后我们将做八次。好。问题。为什么你使用exit而不是直接返回一十加五？
- en: You could do return one ten plus i。 We normally exit out of the children instead
    of return。 It doesn't really matter as it turns out。 But yeah， this， that's good
    question。 We normally do that。 Okay。 So we're going to do that。 And then now we're
    going to say， okay， fine。 We are going to do a while。 We're going to do a while
    true in this case。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以返回一、十加i。我们通常退出子进程而不是直接返回。结果证明其实没有什么区别。但是的，这个问题很好。我们通常这么做。好。那我们就这么做吧。然后现在我们要说，好，好的。我们将做一个while。我们将在这种情况下做一个while
    true。
- en: I'm going to demonstrate something else from you。 We could search for it。 We
    could wait for all of them because we know there's going to be eight of them in
    this case。 But we're going to do this status。 P。I。D。T。 P。I。D。 equals weight。 P。I。D。
    negative one。 And we're going to pass in the status like we did there。 And then
    zero。 Okay。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示一些不同的内容给你。我们可以搜索它。我们可以等它们全部完成，因为我们知道在这种情况下会有八个。但我们将做这个状态。P.I.D.T。P.I.D。等于权重。P.I.D。负一。然后我们像之前那样传递状态。然后是零。好。
- en: And then we're going to look。 And if we find out that if P。I。D。 equals negative
    one。 Well。 that means there were no more children to wait for so we can stop our
    while loop in this case。 Okay。 And what we actually want to do in this case， you
    don't always have to do this。 But it's a little bit of error checking。 We're going
    to assert in this case that the error number equals each child。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将检查。如果我们发现P.I.D.等于负一。那么，这意味着没有更多的子进程等待，所以我们可以在这种情况下停止while循环。好。实际上，我们在这种情况下想要做的是，虽然你不必总是这么做，但这是一种错误检查。我们将断言在这种情况下错误码等于每个子进程的错误号。
- en: I'll tell you what that is in a second。 And then we're going to break。 Okay。
    What we're doing here is we're saying， well， the return value is negative one。
    Technically。 if the return value is negative one， yes， it meant that there were
    no more children。 But it also could mean， hey， there's an actual error here in
    your wait P。I。D。 call。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我一会儿告诉你那是什么。然后我们将跳出循环。好。我们在这里做的是，我们说，如果返回值是负一。从技术上讲，如果返回值是负一，表示没有更多的子进程了。但也可能意味着，嘿，你的wait
    P.I.D.调用出现了实际错误。
- en: It's kind of overloaded。 So it's got a wait P。I。 It's got an error。 It definitely
    could be an error。 But what it does is it sets error no to each child。 which means
    the reason I gave you an error is because there were no more children left。 And
    if you check that， then that's actually okay。 In fact， works perfectly for our
    purposes。 Okay。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它有点过载了。所以它有一个wait P.I.D.，也有错误。它肯定可能会有错误。但它的作用是将每个子进程的错误码设置为错误号，这意味着我给你错误是因为没有更多的子进程了。如果你检查这个，那么这其实没问题。实际上，这对于我们的目的非常合适。好。
- en: Yes， it's an error。 But oh， it's the child issue。 Fine。 Let's just go ahead
    and go on。 Okay。 So that's what we're doing with that one。 Okay。 And then we should
    just check our W if exited status here。 Okay。 And then let's print a child percent
    D。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个错误。哦，是子进程的问题。好吧。我们继续。好的。这就是我们在做的事情。好的。接着我们应该检查我们的 W 是否退出状态。好的。然后打印子进程
    %d。
- en: '![](img/12985c8e5f99b7c7460e806495676228_118.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_118.png)'
- en: exited status percent D。 Now let's do the P。I。D。 and the exit status。 So you
    can get the exit status from the status itself， which will be the return value
    for the child。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态 %d。现在让我们打印 P.I.D. 和退出状态。所以你可以从状态本身获取退出状态，这将是子进程的返回值。
- en: '![](img/12985c8e5f99b7c7460e806495676228_120.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_120.png)'
- en: Okay。 And then it looks like I have something wrong here。 Hold on。 Let's see。
    Print that child extra bad。 Child extra status that P。I。D。W。X。 status。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后看起来我这里好像有些错误。等一下。让我们看看。打印那个子进程的额外信息。子进程的额外状态是 P.I.D.W.X. 状态。
- en: '![](img/12985c8e5f99b7c7460e806495676228_122.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_122.png)'
- en: That's the one。 There we go。 Okay。 How's that？ That was bright。 But I don't
    think that's the actual issue there。 Oh， there's a bracket。 Yeah。 Okay。 And then
    else and then print a child child percent D， exited ab normally。 And we'll go
    just P。I。D。 because no， there's nothing else there。 And that should do it。 And
    then our return zero。 Okay。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这个。好了。怎么样？那个亮了。 但我不认为那是实际的问题。哦，有个括号。是的。好的。然后是 else，接着打印子进程 %d，正常退出。然后我们只需要打印
    P.I.D.，因为没有其他内容了。然后这就行了。接着返回零。好的。
- en: So let's see what happens when we do this。 Oops。 That I don't want to do。 Okay。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们看看我们这样做会发生什么。哎呀。那是我不想做的。好的。
- en: '![](img/12985c8e5f99b7c7460e806495676228_124.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_124.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_125.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_125.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_126.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_126.png)'
- en: Anybody ever done that with the encrypt their file？ It's bad。 I mean， try it。
    Okay。 Make。 reap as they exit。 Okay。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有人做过加密他们的文件吗？这很糟糕。我是说，试试看。好的。创建。重新处理它们退出。好的。
- en: '![](img/12985c8e5f99b7c7460e806495676228_128.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_128.png)'
- en: Okay。 Creep as they exit。 And what should happen is it does 10， 11， 12， 13，
    14， 15， 16， 17。 But let's do it again。 Let's see。 10， 12。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。它会随着它们的退出按顺序爬行。应该发生的情况是：10，11，12，13，14，15，16，17。但是我们再做一次看看。看看。10，12。
- en: '![](img/12985c8e5f99b7c7460e806495676228_130.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_130.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_131.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_131.png)'
- en: There we go。 Okay。 Finally， I got any wrong order。 10， 11， 12， 16， 13， 17， 14，
    15。 This is not in enough particular order because we are saying wait for any
    child to exit any one of those children could exit before any other one。 Although
    it's likely that the one that came first exits first because it's just not in
    the case of the child。 Okay。 So we can get some non-determinist behavior here。
    Okay。 Everyone see what's happening there。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。终于，我搞错了顺序。10，11，12，16，13，17，14，15。这个顺序不够特别，因为我们说的是等待任何子进程退出，任何一个子进程可能会先于其他进程退出。虽然有可能先到的进程先退出，因为它仅仅是由于在子进程的情况下。好的。所以我们可能会遇到一些非确定性行为。好的，大家看明白发生了什么吗？
- en: Negative one for wait P。I。D。 does that for you。 Okay。 All right。 Let us say
    wait。 What if we wanted to actually wait for them in order？ Like， could we wait
    for them in order？ Okay。 We certainly， this is what it does do， by the way。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 P.I.D. 为负一，这样可以为你做这件事。好的。我们来看看，如果我们真的想按顺序等待它们会怎样？比如，我们能按顺序等待它们吗？好的。我们当然可以，这是它的功能。
- en: '![](img/12985c8e5f99b7c7460e806495676228_133.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_133.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_134.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_134.png)'
- en: This is what does that。 And I said， talked about error number and all that。
    What if we did want to wait for them in order？ Let's take a look at another program。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它做的事情。我提到了错误号和所有的内容。如果我们真的想按顺序等待它们会怎么样呢？让我们看一下另一个程序。
- en: '![](img/12985c8e5f99b7c7460e806495676228_136.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_136.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_137.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_137.png)'
- en: This one's going to be reaped in fork order because we want to actually do it
    in the order they are in。 Okay。 So let's do same sort of thing。 Except now， if
    we want to wait for them in order。 we better know what the order is。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将按 fork 顺序回收，因为我们要按照它们的顺序来处理它们。好的。接下来我们做类似的事情。但现在，如果我们要按顺序等待它们，我们最好知道顺序是什么。
- en: '![](img/12985c8e5f99b7c7460e806495676228_139.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_139.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_140.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_140.png)'
- en: Okay。 So we probably want to do something like P。I。D。T。 children array of eight。
    Right。 Because now we need to keep track of all the P。I。D。s if we're going to
    wait for them in order。 We're going to have a same size T。 I equals zero。 I is
    less than eight。 I plus plus。 And then。 and then we are going to do status in
    here。 P。I。D。T。 Sorry。 I'm going to put a formula in here。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以我们可能想做类似P.I.D.T. 子数组的八项。对吧？因为现在我们需要追踪所有的P.I.D.s，如果我们要按顺序等待它们。我们将有相同大小的T。I等于零。I小于八。I加加。然后。然后我们将会在这里做状态。P.I.D.T.
    对不起，我会在这里放一个公式。
- en: In this case， we're just going to create them all here。 If children of I equals
    fork。 We're going to do a little bit of a formula。 We're going to do a little
    bit of a formula。 We're going to do a little bit of a formula。 Okay。 All right。
    And then we're going to do now we're going to go through them all for another
    size T。I。 equals zero。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将把它们都创建在这里。如果子项为I等于分叉。我们将做一些公式。我们将做一些公式。我们将做一些公式。好的。然后，我们现在将遍历它们，另一个T。I等于零。
- en: Not a while true loop is this case。 Although you could probably make it work
    if you really wanted to。 Okay。 And in this case， we are going to now do P。I。D。T。
    P。I。D。 equals wait P。I。D。 for a particular child。 I status zero。 Okay。 Let's assert
    that we got the right child。 even though we almost always would。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不是一个while true循环在这种情况下。虽然如果你真的想让它工作，你可能也能做到。好的。在这种情况下，我们现在要做P.I.D.T. P.I.D.
    等于等待P.I.D.，等待某个特定的子项。我状态为零。好的。让我们确认我们得到了正确的子项，尽管我们几乎总是会。
- en: '![](img/12985c8e5f99b7c7460e806495676228_142.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_142.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_143.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_143.png)'
- en: P。I。D。 equals equals children I。 Okay。 And then， assert really could we're not
    waiting for anyone。 We're waiting for specific one right now。 And let's do。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: P.I.D. 等于等于子项I。好的。然后，确认真的没有人在等待。我们现在只等待特定的一个。然后我们继续。
- en: '![](img/12985c8e5f99b7c7460e806495676228_145.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_145.png)'
- en: We're going to just kind of check a couple things at once here。 W。X。 its status
    status equals 110 plus this is like lots of extra checking just in case here。
    Okay。 And then we're going to print child with P。I。D。 percent D is accounted for。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将同时检查几个事情。W.X. 它的状态等于110，再加上这像是额外的检查，以防万一。好的。然后我们将打印子项，带有P.I.D.，百分比D已被计算。
- en: '![](img/12985c8e5f99b7c7460e806495676228_147.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_147.png)'
- en: And return status of percent D。 Period。 New line。 Children。 I。 And we'll give
    the actual status of it。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回百分比D的状态。句号。换行。子项。我。我们将给出它的实际状态。
- en: '![](img/12985c8e5f99b7c7460e806495676228_149.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_149.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_150.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_150.png)'
- en: Which is the return value。 Okay。 And that's it。 Say again。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回值。好的。就这样。再说一遍。
- en: '![](img/12985c8e5f99b7c7460e806495676228_152.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_152.png)'
- en: I do not need to initialize that。 Oh， you do declare it。 I do indeed need to
    clear it。 I don't initialize though。 Thank you。 Thank you。 Okay。 Anybody else
    issues？ Let's try it。 Make reap in four quarter。 Okay。 Looks good。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要初始化它。哦，你需要声明它。我确实需要清除它。我不初始化，谢谢。谢谢。好的。还有其他问题吗？让我们试试看。四分之一的结果。好的，看起来不错。
- en: '![](img/12985c8e5f99b7c7460e806495676228_154.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_154.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_155.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_155.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_156.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_156.png)'
- en: Now， in this case， it has to wait for each one。 So we are going to always get
    them in order。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，它必须等待每一个。所以我们将始终按顺序获取它们。
- en: '![](img/12985c8e5f99b7c7460e806495676228_158.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_158.png)'
- en: Because it's waiting for 110， 911， then 112， etc。 And all of them might be ending
    in different orders。 It's just going to eventually reap the process。 Another way
    P。I。D。 is going to where specifically going to ask for a specific one。 And it's
    going to return and say。 yes， you got it。 Okay。 What questions you have on that？
    Yeah。 That's a very good question。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它在等待110、911，然后是112，等等。而且它们可能以不同的顺序结束。它最终会结束这个过程。另一种方式是P.I.D. 会在哪里，特定地去请求某个特定的。它会返回并说：是的，你得到了。好的，你对这个有什么问题？是的，这是个很好的问题。
- en: And you have to be careful。 The question was， doesn't it populate the children
    array with the P。I。D。 Only for the parents。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心。问题是，它不会用P.I.D.填充子数组吗？只会填充父级。
- en: '![](img/12985c8e5f99b7c7460e806495676228_160.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_160.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_161.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_161.png)'
- en: It gives it the child's P。I。D。 Remember， what is the child's P。I。D。 or what's
    the result of fork for the child？ Zero。 It is not the child's P。I。D。 It's only
    zero if you are the child。 So in this case， I kind of briefly mentioned this。
    In this case， yeah， it's putting a zero in there for the child's version of that
    array。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它给了孩子的P.I.D。记住，孩子的P.I.D。是什么，或者说fork对孩子的结果是什么？零。如果你是孩子，它就不是孩子的P.I.D。只有当你是孩子时，才是零。所以在这种情况下，我简要提到过这一点。在这种情况下，是的，它为孩子版本的那个数组放入了一个零。
- en: But we're going to ignore it。 We don't care except to say， is it zero or not？
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们会忽略它。我们不在乎，除了问它是零还不是零？
- en: We've got to follow up。 Yeah。 In the forward， then it will wait for children
    I to follow。 Ah。 good question。 When you wait for children I down here， isn't
    always going to be zero。 There are two arrays every time you fork now。 There's
    a parent array。 You fork。 The child has its own version of the array。 The parent
    still has its same version as before。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得继续跟进。是的。在向前执行时，它将等待孩子I继续。啊，好的问题。当你在这里等待孩子I时，不一定总是会是零。现在每次fork时，都会有两个数组。一个是父进程数组。你fork了，孩子有自己版本的数组。父进程仍然保持原来的版本。
- en: It gets the parent gets the child P。I。D。 The child gets zero， but it's initially
    immediately exits。 Oh， it worked。 Yeah。 This is why I want to be really careful
    about that return value for fork is not a PID except for the parent。 It's only
    the child P。I。D。 for the parent。 It is always zero for the child。 If the child
    wants its P。I。D。 for some reason， it has to call get P。I。D。 Question？ No。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它让父进程获得孩子的P.I.D。孩子得到零，但它会立即退出。哦，工作了。是的。这就是为什么我要非常小心地说明，fork的返回值不是P.I.D.，除了父进程。对于父进程来说，它永远是孩子的P.I.D。对于孩子来说，它总是零。如果孩子出于某种原因想要获取自己的P.I.D.，它必须调用get
    P.I.D。问题？没有。
- en: The children never do the second for loop。 Exactly。 Good question。 Yes。 So，
    in this case。 most of the time we call get P。I。D。 for the parent。 It's already
    exited。 Some of the children have already exited。 Yes。 In fact。 most of them after
    the first couple loops have probably already exited。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子们从不执行第二个for循环。没错。好问题。是的。所以，在这种情况下，我们大多数时候会调用父进程的get P.I.D。它已经退出了。一些孩子已经退出了。是的。事实上，大多数孩子在前几个循环后可能已经退出了。
- en: You can wait for a child after it's exited and it still returns without it。
    We tested that a little earlier。 Good question。 Yeah。 Could a child create a like
    I equals seven look back on the P。I。D。 values of the children for like I equals
    five or three？ No。 Yes。 It could。 Sure。 Yeah。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在孩子退出后等待它，它仍然会返回。这一点我们稍早前测试过。好问题。是的。孩子是否能像i=7那样，回顾i=5或i=3时孩子们的P.I.D.值？不。是的。它可以。没错。是的。
- en: This is a good question。 Could the 6th or 7th child see all the values of the
    P。I。D。s for the previous children？ Sure。 Before that， it's still the parents。
    It's the same。 Yeah。 The parent keeps it and keeps populating。 So sure。 Now you're
    not trying to hide that from the children。 It wouldn't be in that case。 Good question。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好问题。第六或第七个孩子能看到前面孩子的所有P.I.D。值吗？当然。在那之前，它还是父进程的。是一样的。是的。父进程保持着，并持续填充。所以当然可以。现在你并不是想隐藏这些给孩子们。在这种情况下是不会的。好问题。
- en: Yeah。 Because I'm confused。 Why can you wait for a child after it's exited when
    she wants to like reuse that process or something else？
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。因为我很困惑。为什么你可以在一个孩子退出后等待它，当你想像重新利用那个进程或做其他事情时？
- en: Why can you wait for a child after it's exited when she wants to reuse that
    child for a process or something else？
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你可以在孩子退出后等待它，当你想重新利用那个孩子做其他进程或事情时？
- en: It hasn't been cleaned up yet until wait P。I。D。 is called。 So you're still waiting
    for。 In fact。 there is some extra overhead because it hasn't been cleaned up yet。
    That's really the difference。 You've once it ends， it's waiting for somebody to
    do a wait P。I。D。 on it basically。 That's the clean up process。 Yeah。 Why doesn't
    the first four look like creative that tree of like that？
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 它还没有被清理，直到调用wait P.I.D。为止。所以你仍然在等待。事实上，因为它还没有被清理，所以会有一些额外的开销。这就是区别所在。一旦结束，它会等待有人对其进行wait
    P.I.D。调用，基本上。这是清理过程。是的。为什么第一个fork看起来不像创造那样的树结构？
- en: Yeah。 Why doesn't the first four look creative tree？ You tell me。 What's happening
    in this first one right here？ What happens at each child？
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。为什么第一个fork看起来不像创造那样的树结构？你告诉我。这里第一个发生了什么？每个孩子发生了什么？
- en: What does each child immediately do？ It dies。 So it never gets to the next loop。
    Because it exits。 Yeah。 All right。 Good。 This is like， you can see why this stuff
    is like challenging to get the first time。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子进程接下来会做什么？它会退出。所以它永远不会进入下一个循环。因为它退出了。是的。好了。很好。这就像，你可以理解为什么第一次接触这些内容时会觉得很有挑战性。
- en: '![](img/12985c8e5f99b7c7460e806495676228_163.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_163.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_164.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_164.png)'
- en: The first couple of times you see it。 Okay。 This is what it is ever in theory。
    You could have any of the children in any order。 But the loop is still going to
    be held up waiting for that first child to end。 then the second， then the third，
    then the fourth。 That's just the way these ones work。 Okay。 All right。 So that's
    the， that's fork。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次看到它的时候，可能是这样的。好吧，这就是它的理论。你可以让任何一个子进程按任何顺序执行。但循环仍然会被阻塞，等待第一个子进程结束，然后是第二个，第三个，第四个。就是这些进程的工作方式。好吧。好了。这就是
    fork。
- en: '![](img/12985c8e5f99b7c7460e806495676228_166.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_166.png)'
- en: Now we have showed some interesting examples of fork and how you've got your
    program going in two different directions。 and you've got your code in the child
    and your code in the parent and so forth。 It turns out that most times you use
    fork， it is not going to be to do your code in both the parent and the child。
    It turns out that what normally happens is we are going to make another program
    run。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示了一些有趣的 fork 示例，展示了你的程序如何在两个不同的方向上运行，你的代码在子进程中运行，父进程中也有代码，等等。结果是，大多数情况下你使用
    fork 并不是为了在父进程和子进程中都执行代码。实际上，通常发生的情况是，我们会让另一个程序运行。
- en: We're going to set some other program off to run such that it does its thing
    and we may or may not capture the output。 But we actually are running some other
    program。 That was kind of the original reason。 Fork a process， have the other
    process the child run some other program。 That's mainly what it's for。 You can
    do what we've been doing where we show these kind of interesting tree examples
    and interesting child。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动另一个程序，让它执行它的任务，我们可能会捕获输出，也可能不会。但实际上，我们正在运行另一个程序。这就是最初的原因。fork 一个进程，让子进程运行另一个程序。这就是它的主要用途。你也可以做我们一直在做的事情，展示这些有趣的树形示例和有趣的子进程。
- en: But most of the time this is what we're going to be doing。 Okay。 We're going
    to run a completely separate program and we may or may not capture its standard
    out。 We may or may not send it information in standard in。 Okay。 This is what
    your shell does。 Okay。 When you type LS on your shell， right， well what happens
    is the shell is a program and when you type LS it takes that and says。
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数时候，我们要做的就是这个。好吧。我们将运行一个完全独立的程序，可能会捕获它的标准输出，也可能不会。我们也可能会或不会向它发送标准输入的信息。好吧。这就是你的
    shell 做的事情。好吧。当你在 shell 中输入 LS 时，对吧，发生的事情是 shell 是一个程序，当你输入 LS 时，它会处理这个命令并执行。
- en: '![](img/12985c8e5f99b7c7460e806495676228_168.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_168.png)'
- en: '"Oh， okay。 There''s a program called LS on the system。" And it runs that program。
    waits for it to end and gives you a prompt back。 That''s what''s happening with
    the shell。 So the shell is doing exactly this。 It''s doing what we call forking
    and then execvp which is another system call。'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，好吧。系统中有一个叫做 LS 的程序。”然后它运行这个程序，等待它结束，然后给你一个提示。这就是 shell 在做的事情。所以 shell 正在做完全一样的事情。它正在进行我们所说的
    fork 操作，然后是 execvp，这是另一个系统调用。
- en: '![](img/12985c8e5f99b7c7460e806495676228_170.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_170.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_171.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_171.png)'
- en: And this system call does the following。 It basically reboots the process with
    some other program。 Okay。 And this is one way to do it and in fact kind of the
    default way to do it。 And that paper I showed you earlier is probably complaining
    about this。 It's complaining about like。 "Why have we do it this way？ There's
    other better ways of doing this and so forth。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个系统调用做的就是以下操作。它基本上是用另一个程序重启进程。好吧。这是做这件事的一种方式，实际上也是默认的做法。我之前给你们展示的那篇论文可能是在抱怨这个。它在抱怨：“为什么我们要这么做？有其他更好的方式可以做这些事情等等。”
- en: '" But this is what it does。 Execvp， it''s basically a family of commands all
    called exec as in execute。 I guess。 And the vp happens to be a certain variety
    that we''re going to use。 You can go look up all the other ones。 If you type man
    execvp， man execvp。 you can see that it actually shows a whole bunch of them。'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '"但这就是它的作用。Execvp，它基本上是一组命令，都叫做exec，就像执行。猜测。vp刚好是我们将要使用的某种变体。你可以查阅其他的。如果你输入man
    execvp，man execvp。你会看到它实际上列出了一大堆。'
- en: '![](img/12985c8e5f99b7c7460e806495676228_173.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_173.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_174.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_174.png)'
- en: execl， execlp and so forth。 The one we use and it's just so you can have different
    environment variables。
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: execl，execlp等等。我们使用的就是这样，你可以使用不同的环境变量。
- en: '![](img/12985c8e5f99b7c7460e806495676228_176.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_176.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_177.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_177.png)'
- en: Not really that important。 The one we're going to use and focus on is execvp
    which basically takes a path。 and then takes an argument array just like argv
    and it runs the program at that path with the argument string or array passed
    into it。 Okay。 As it turns out just like all your other regular programs。 the
    path and argv zero are going to be the same。 Because the first argument in argv
    is always the name of the program。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 其实并不重要。我们要使用并关注的是execvp，它基本上是接受一个路径，然后接受一个像argv一样的参数数组，并且使用这些参数在那个路径下运行程序。好的。事实证明，就像你所有其他常规程序一样，路径和argv零将会是一样的。因为argv中的第一个参数总是程序的名称。
- en: So therefore we're going to have the name of the program as the path which is
    also the same as argv zero。 Okay。 So that's just the way that works。 And all it
    does is it runs it and it basically takes over that process。 runs that program
    in it and that's that。 Now what's interesting about this is if it doesn't work。
    let's say you gave it a bad path and the path didn't work， it would not actually
    run anything。
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将把程序的名称作为路径，这个路径也就是argv零。好的。它就是这么工作的。它所做的就是运行它，基本上接管那个进程，运行那个程序，这就是它的作用。现在有趣的是，如果它不工作，假设你给它一个错误的路径，而路径无法工作，它实际上什么都不运行。
- en: It would return to you and give you an error message or an error return value
    of negative one and you can capture that and say oh there was an error。 Okay。
    If it does succeed， like in other words if it runs that program it never returns
    to the calling function。
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它会返回一个错误消息或错误返回值负一，你可以捕获它并说哦，发生了错误。好的。如果它成功了，换句话说，如果它运行了那个程序，它就永远不会返回到调用函数。
- en: It just doesn't ever return。 Why？ Because it's a whole new process。 Well it's
    actually cannibalized to the process， to the extent that it is now the same process
    that you just created with fork except it's it's all own。 got it's own， everything
    else。 Okay。 So that's what's happening with execv and Jerry put this in here。
    That hashtag deep。 Right。 But it's like never returns if it succeeds。 That's the
    way it goes。 Okay。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 它就是永远不会返回。为什么？因为这是一个全新的进程。实际上它已经被“吞噬”了，和你刚刚通过fork创建的进程一样，除非它已经成为了它自己的进程，拥有自己的所有内容。好的。所以这就是execv发生的事情，杰瑞把它放在这里。那个井号深度。对吧。但如果它成功，它就永远不会返回。就是这样。好的。
- en: So that's what execv。 If he does this is mainly the big reason we're going to
    use for is to do that and to call them。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是execv。如果他这么做，主要的原因就是我们会使用它来做这些，并调用它们。
- en: '![](img/12985c8e5f99b7c7460e806495676228_179.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_179.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_180.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_180.png)'
- en: Okay。 What example are we going to do？ I've got seven minutes and I guess I
    can do the whole。 Yeah it's actually it's actually not that bad。 We're going to
    do a little system example。 Okay。 We're basically going to do a tiny little shell。
    If you guys are in CS107E you know all about shells and you're going to build
    one for an assignment in this class as well。
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们要做什么例子？我有七分钟时间，我猜我可以做完。是的，实际上它并不算那么难。我们将做一个小的系统示例。好的。我们基本上要做一个小的shell。如果你们在CS107E课程中，应该了解shell，并且你们在这门课的作业中也将构建一个shell。
- en: '![](img/12985c8e5f99b7c7460e806495676228_182.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_182.png)'
- en: But for right now we are going to do a tiny little one called my system。 Okay。
    And what it's going to do is it's going to cheat a little bit。
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们要做一个小的，叫做我的系统。好的。它将会有一点小小的作弊。
- en: '![](img/12985c8e5f99b7c7460e806495676228_184.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_184.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_185.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_185.png)'
- en: It's going to use the shell a shell program to run a program we give it。 Why？
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用shell程序来运行我们给它的程序。为什么？
- en: Because I don't want to have to parse out the different parts of the command
    line。 You'll see what happens when we do this。 And it's a good first example anyway。
    Okay。 We're going to actually do the my system function itself。 It's going to
    be passed in a command that we want to run。 Okay。 And here's how it's going to
    work。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我不想解析命令行的不同部分。你将看到我们这样做时会发生什么。这是一个很好的初步示例。好的。我们将实际调用我的系统函数。它将传入我们想要运行的命令。好的。它将这样工作。
- en: Okay。 PID equals fork。 So the first thing you do when you do this exact series
    you need another process。 You don't have to have another process but if you don't
    have one you never get back to your original program。 It gets cannibalized。 Okay。
    If PID equals zero that means we are the child。 Then what we're going to do in
    this case is we're going to say all right our arguments equals and what we're
    going to do is we're going to say run this program called bin slash SH and that's
    the program that's going to get run。
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。PID等于fork。所以，当你执行这个系列的操作时，首先需要一个新的进程。你不一定非得有另一个进程，但是如果没有，你永远无法回到原始程序。它会被吞噬掉。好的。如果PID等于零，意味着我们是子进程。那么，在这种情况下我们要做的就是，好的，我们的参数等于，我们要做的就是运行一个叫做bin斜杠SH的程序，那就是将要运行的程序。
- en: Then slash SH if you want to run another program from within that you have to
    do a command parameter called dash C。 And then here's the command itself which
    you have to make it constant or you have to make it non constant as it turns out。
    It'll just be a warning。 It doesn't really matter。 But it's passed in as a constant
    in that case。 Command and no。 Okay。 You have to end your it's this one。 Thank
    you。 Sorry for the program。
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果你想从其中运行另一个程序，可以使用斜杠 SH。你必须使用一个命令参数叫做dash C。然后这是实际的命令，你需要让它成为常量，或者实际上需要将其设置为非常量。它只是一个警告，实际上没有太大关系。但是在这种情况下它会作为常量传递。命令和没有。好的，你必须结束它，就是这个。谢谢。抱歉程序出问题了。
- en: That's just creating an array by the way is really all that's doing。 Okay。 And
    you have to end the last argument with no。 It's just the way that we do these
    kind of arrays because they're all strings we can do that as it turns out。 Okay。
    All right。 So that's what we're going to do。 And then at this point then we can
    say oh great exact CVP the arguments zero which is the。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这只是在创建一个数组。好的。你必须以没有（no）结束最后一个参数。这是我们做这些类型数组的方式，因为它们都是字符串，正如结果所示，我们可以这样做。好的。好了。那么我们要做的就是这样。然后到这个时候，我们可以说，哦，太好了，精确的CVP，参数零就是这个。
- en: bin slash S H and then arguments。 And then that will actually do the process
    right if we can say print if we get to this point。 It means we failed because
    why because it never returns if it doesn't get to this。 Doesn't if it works。 Okay。
    Failed to invoke failed to invoke slash bin slash S H to execute the supply command。
    Sad face。 Okay。 And I guess we should probably do。 That doesn't really matter。
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: bin斜杠SH，然后是参数。然后这实际上会执行这个进程，如果我们能打印出来的话。如果我们到达这个点，意味着我们失败了，因为为什么呢？因为如果它没有到达这里，它就不会返回。如果它能工作。好的。调用失败，无法调用斜杠bin斜杠SH来执行提供的命令。伤心脸。好的。我猜我们可能应该做。其实没关系。
- en: We'll get a new line later。 Okay。 And then exit zero just to say well we got
    it。 We have our fork where we're done。 Okay。 And that will do that if we are the
    parents。 We're going to do in status。 All right。 Well， we're going to wait for
    it。 All right。
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会有一行新的代码。好的。然后退出零只是为了表示我们完成了。我们有了我们的分叉，任务完成。好的。如果我们是父进程的话，它会这么做。我们将进入状态。好吧。我们将等一下。好的。
- en: '![](img/12985c8e5f99b7c7460e806495676228_187.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_187.png)'
- en: Wait PID。 P ID status and zero。 And oops。 Okay。 And then return。 W if exit status。
    Okay。 If that's true。 We're going to say the exit status。 Otherwise we're going
    to return。 We're going to turn the negative of the termination status which just
    basically says well what happened。 Don't worry too much about that。 For that。
    I think it's term。 Yeah， that should be it。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 等待PID。PID状态和零。哎呀。好的。然后返回。W如果退出状态。好的。如果是真的，我们将说退出状态。否则我们将返回。我们将返回终止状态的负值，这基本上就是说发生了什么。不要太担心这个。至于那个，我想是term。是的，应该就是这样。
- en: And then that's that。 So that's our function。 Okay。 Let's write a little kind
    of a driver for it here。 Okay。 And the driver is going to be just the main part
    that's going to call it。 So let's actually set it up。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就是这样。那就是我们的函数。好的。我们来写一个小驱动程序。好的。驱动程序就是调用它的主要部分。所以我们实际上需要设置它。
- en: '![](img/12985c8e5f99b7c7460e806495676228_189.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_189.png)'
- en: Okay。 We'll make it like a little terminal。 We'll just keep going in some loop
    until you do it。 Let's see。 We want to do。 Let's do create a char command。 Let's
    make it K max。 Let's just say you can't type more than 2048 characters in your
    command。 Okay。 And then while true。 It's going to keep doing this forever。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们将其做成一个小终端。我们将持续执行一个循环，直到你完成。让我们看看。我们想做什么。我们来创建一个字符命令吧。设定它为 K max。我们假设你不能在命令中输入超过2048个字符。好的。然后使用
    while true。它将永远执行下去。
- en: '![](img/12985c8e5f99b7c7460e806495676228_191.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_191.png)'
- en: While true we're going to print F a little prompt like that。 And then use F
    get S which basically is a nice way of getting something from a file descriptor。
    Right。 And in this case we're going to or not it's a kind of a different kind
    of file descriptor。 It's a similar sort of thing。 K max lines in case you type
    too much。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 while true，我们将打印出一个类似提示符的内容。然后使用 F get S，这基本上是一种从文件描述符获取内容的好方法。对吧。在这种情况下，它不是文件描述符，而是另一种类似的东西。设定
    K max 行数，以防你输入太多。
- en: And then we're going to get it from standard in。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将从标准输入获取数据。
- en: '![](img/12985c8e5f99b7c7460e806495676228_193.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_193.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_194.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_194.png)'
- en: Which is the way you can do this with this。 And if F E O F standard in which
    basically means if we have the if we've ended if we do control D this will end
    it。 We're going to break out of our loop。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以用这个方法做到的。如果是 F E O F 标准输入，这基本上意味着如果我们结束了，如果我们按下控制 D，这将结束它。我们将跳出循环。
- en: '![](img/12985c8e5f99b7c7460e806495676228_196.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_196.png)'
- en: And otherwise we're going to say come in。 And we're going to overwrite the last
    part of the command with a zero instead of a new line it gets you get the new
    line back。 Like that。 Okay。 We're going to overwrite the end there and we'll let
    you run there。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 否则我们将说进入。然后我们将用零覆盖命令的最后一部分，而不是新的一行，这样你就会得到一个新的行。就这样。好的。我们将覆盖结尾部分，让你继续运行。
- en: Probably forgot to print the thing here。 There we go。 Okay。 And then finally
    we're going to print out print F return code and percent D and my system。
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 可能忘了在这里打印内容。好了。好的。最后我们将打印出 print F 返回码和百分号 D 以及我的系统。
- en: '![](img/12985c8e5f99b7c7460e806495676228_198.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_198.png)'
- en: And like that。 Okay。 And then we're going to print a new line。 And we're going
    to print our turn。 Okay。 That is going to hopefully if I did everything right
    make my system。
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。好的。然后我们将打印一行新的内容。然后打印我们的回合。好的。希望如果我做得对，它将使我的系统运行起来。
- en: '![](img/12985c8e5f99b7c7460e806495676228_200.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_200.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_201.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_201.png)'
- en: Oh no。 Let's see。 Expect a cost chart。 Let's see。 Hang on。 Passing argument
    makes a pointer from integer。 What did I do here。
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不。让我们看看。期待一个成本图表。我们看看。等等。传递参数使整数成为指针。我在这里做了什么？
- en: '![](img/12985c8e5f99b7c7460e806495676228_203.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_203.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_204.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_204.png)'
- en: Chart star arguments is that I don't want to keep you guys much longer。 I just
    want to run it for you。 Hang on。 Let's see。 Chart star。 Oh arguments think it
    needs to be a right， doesn't it。
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Chart star arguments 是我不想让你们再等太久了。我只想为你们运行它。等等。让我们看看。Chart star。哦，参数应该是对的，不是吗？
- en: '![](img/12985c8e5f99b7c7460e806495676228_206.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_206.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_207.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_207.png)'
- en: Then my system needs to be an array。 Thank you。
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我的系统需要是一个数组。谢谢。
- en: '![](img/12985c8e5f99b7c7460e806495676228_209.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_209.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_210.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_210.png)'
- en: That should do it maybe。 There we go。 Okay。 Now my system will give you a prompt。
    So there's your little prompt。 And if you type LS it runs LS。 Right。 And there's
    our prompt。 And if we say we could actually run Python or something。 Right。 And
    whatever you want。 Right。 If you want to run it does the return code。 If you type
    some bogus something it'll say hey permission denied or something else it'll say
    return code 127 which is incorrect。
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该就可以了。好了。现在我的系统会给你一个提示符。所以这是你的提示符。如果你输入`LS`，它会执行`LS`命令。对吧。然后这是我们的提示符。如果我们说，我们实际上可以运行Python或者其他什么的。对吧。你想做什么就做什么。对吧。如果你想运行，它会返回代码。如果你输入一些无效的东西，它会说“权限被拒绝”，或者如果是其他错误，它会显示返回码127，这表示不正确。
- en: Okay。 That's the first example of exact CEP。 We will start with that on Monday。
    See you then。
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这是精确CEP的第一个例子。我们将在周一开始学习。到时见。
- en: '![](img/12985c8e5f99b7c7460e806495676228_212.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_212.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_213.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_213.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_214.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_214.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_215.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_215.png)'
- en: '![](img/12985c8e5f99b7c7460e806495676228_216.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12985c8e5f99b7c7460e806495676228_216.png)'
