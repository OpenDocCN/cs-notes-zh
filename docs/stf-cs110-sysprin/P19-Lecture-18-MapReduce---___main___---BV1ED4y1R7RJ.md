# P19：Lecture 18 MapReduce - ___main___ - BV1ED4y1R7RJ

好的，欢迎回来。欢迎回来。所以这和课堂内容一点关系都没有。不过，顺便问一下，你喜欢我现在成了视频里的小明星吗？是前几天实验室视频里的那个。

对，我完全忘记了我出现在那个视频里。真是的。所以你可能会问自己，为什么他要给我们看这些傻乎乎的视频？

还有一件事，本周我们会让你们在课堂上做的，那就是关于视频的五分钟调查。这其实是一个研究项目的一部分，你们会在本周的实验室中了解到更多。哦，还有什么我要给你们展示的呢？哦，另一个视频。这个和课堂内容无关，我只是觉得挺有趣的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_1.png)

所以下周，哦不，最近。最近，我和我的妻子搬进了新家，我们家有个小小的后院被围起来了。每天我都会去那儿，发现围栏下有个小洞。似乎有东西从围栏下挖过去了。于是我现在在那儿放了个摄像头。

你想看看我们找到的东西吗？我们来看看。是的，你大概能从这里看到。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_3.png)

就在这里。是的，非常可爱。问题是，如果我们让狗狗们进入那个区域，它们就有麻烦了。如果那只臭鼬赢了这场“战争”，我肯定它会的。不过无论如何，这就是我发现的情况。当你安装了摄像头，你会发现一些有趣的事情，当然也会发现其他一些事情。然后，我就在底下放了一些木板，它就再也没有回来。虽然我听说臭鼬其实挺聪明的。

它们非常擅长挖掘，根本不在乎这些木板。所以我们就看看会发生什么吧。我们会看看会发生什么。好了，来看看吧。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_5.png)

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_6.png)

第七次作业进展如何？差不多完成了，希望如此。我们明天晚上再做一下这部分内容吧。它在这之间。好的。我在这之后大约有一个小时的空闲时间，如果你遇到什么特别的问题，可以过来找我。然后我们将进入最后的作业，今天我们会完全讨论这个作业，帮助你赶上进度。

我们上周简要提到的，名为MapReduce的内容。MapReduce是一个算法，我们今天会稍微深入探讨一下。然后我会更多地向你们讲解作业的具体细节，告诉你们如何完成它。这个作业有很多环节，我知道这是每次都有的。这次的作业部分很多。

这次有四个不同的任务，不过它们被分解成了不同的小任务。今天我们也会看一看一些代码，我会指出一些重点。然后我们就开始这个作业。MapReduce作业技术上已经发布了，我今天早些时候发布了。如果你还没有开始做，可以着手了。

如果你已经完成了，那也没关系。它表面上是下周三截止，就是上课的最后一天。我会让任何愿意在周四提交的人都能提交，而不会受到任何惩罚。所以你可以自己去理解这在大局中的意义。如果你愿意，可以在周四交。没有惩罚的截止时间是下周五。

这就像是 90% 和 60% 的周六。所以你有一点额外时间可以用来完成。但它的技术截止日期是星期三。好吧。让我们来聊聊这个 MapReduce 算法。现在，我之前没有告诉你们的事情是，MapReduce 是一个在 Google 被广泛使用的算法。它实际上是在 Google 发明的，尽管它与过去的一些发明非常相似。

这并不是说他们在之前完全重新发明了整个系统。但它在 Google 被广泛使用。它也被应用在一个叫做 Hadoop 的系统中，Hadoop 是一个利用 MapReduce 来解决大数据问题的系统。而 MapReduce 的基本思路是，你把需要分析的数据分发给一堆服务器，然后进行映射阶段，在这个阶段你会处理所有这些不同的部分。

你将这些大量数据分配到所有不同的服务器上，处理其中的不同部分。然后在服务器上，你会进行减少操作，将它们整合回来。实际上，你是在做一种过滤的操作，把很多东西合并后再送回主服务器。所以它在我们的案例中利用了 myth 机器。但如果你愿意，你也可以在一大批服务器上使用 Hadoop 或 MapReduce。

拥有成千上万、成千上万的处理器。它的优点是，如果你构建程序得当，而我们这里的程序不一定是为了这个目的，但如果构建得好，它对于计算机宕机是非常稳健的。所以，如果你去 Facebook 或 Google 的数据中心，他们那里面有成千上万台计算机。

而且每天很多硬盘或计算机会坏掉。因为当你扩展到成千上万台设备时，事情往往会出问题。现在真的有专门的人负责推着装满硬盘或 SSD 的小车到处走。他们会去数据中心的这一排这一列，替换坏掉的硬盘。

然后因为它坏了。你的部分数据可能就在那些损坏的硬件上，但你必须确保系统足够稳健，以便数据实际上能够分布到多个系统上。这与使用成千上万台计算机的算法本质上是一样的。

你需要编写你的应用程序，确保如果其中一台计算机崩溃，你不需要重新启动整个过程。这样做是致命的，因为没有任何一台拥有 60,000 台计算机的系统能够在没有其中一台计算机出故障的情况下持续超过一个小时。所以，你必须在设计上确保其鲁棒性。而这个生产过程正好允许你做到这一点，确保系统可以处理这些问题。

尽管这并不是我们任务的重点。所以我做了这个。我前几天开始了这个，接下来我要简单回顾一下，帮助我们重新回到进度。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_8.png)

我之前差不多已经说过了，你有映射部分和归约部分。映射部分处理数据并得出一些中间结果。现在，我们将用一个例子来展示，这个例子是经典的词汇处理。基本上，它将每个单词提取出来，并把它放入某个文件的列表中，并在后面加上 "一"，表示这是一个单词。

为什么加上那个 "一" 是为了方便后续的加总。你可以忽略它，也可以不加 "一"，直接假设它在那儿，这样也没问题。但在这种情况下，会有一个中间结果，我们会看到它，这个结果只是一个单词，然后旁边加上数字 "一"，表示这是下一个。

现在这个还完全没有排序。接下来是排序阶段，你可能会取一个文件，将所有单词排序，使得它会按 "一"、"一"、"一"、"一"、"一" 这样的顺序排列。它被排序后，你再运行按键分组，基本上就是遍历列表，统计所有的手数，然后写下一个 "一" 和总和，然后对所有其他单词执行相同的操作。

然后你需要进行归约，基本上是将所有的结果整合在一起，然后将它们发送回原始服务器。好的，这就是整个大流程。映射阶段取决于你映射的内容，归约阶段取决于你归约的内容。

但是，如果你在每个问题中都做相同的排序和按键分组，那么它们永远都是一样的。所以你永远不需要重新做这些部分。好的，我们在接下来的讲解中会更详细地讨论这个。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_10.png)

这里是一个小示例，现在我们要展示一些 Python 程序。顺便说一句，这些程序并没有在你的任务中列出，但如果你想在代码中使用这些 Python 程序，欢迎使用，你不必自己重写这些算法。

其实这样做也没问题。它并不会帮助映射和归约部分，但它帮助了实际的排序等操作，你可以使用这些。它的作用基本上是，这个文件通过标准输入处理，找到所有行并分割它们，按照空格或者其他分隔符进行分割。

然后对于其中的每个标记，它实际上会将单词转为小写，然后匹配并基本上打印出单词，然后在它旁边打印一个1。就这些，这部分就是在做这些。所有这些文件都在做这个。好吧。怎么运行它呢？

你可以这样说，然后我们就去做。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_12.png)

我们来看看。我们需要进入正确的文件夹。你可能想记下其中一些。你可能希望把这些文件放在手边，因为你可以在不将它们复制到你的文件夹中的情况下调用它们。你会看到接下来它是如何工作的。我们来看看。Spring，然后是live map reduce。好吧。假设我们输入`cat Anna Karenina`，然后通过`dot slash word count mapper`将其传递。

好的。这就是它在做的事。对吧。列出每个单词并在旁边加上一个1。现在大多数情况下，你要么让它直接输出到一个文件，因为你将做很多这样的操作，要么你会让它。你可能不会让它直接打印到屏幕上。你可能会让它通过管道输出到某个文件。就这些，它做的就是：拿每个单词，标记一个1。

Word one。Word one。就这样。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_14.png)

好的。好的。那么在我们做完这些之后，接下来你就会遇到一个按键分组的情况，你尝试将输出按键排序。在这种情况下，我们所需要做的就是，如果我们在命令行上操作，只需要将其通过`sort`命令传递，它就会完成排序。

所以你可以看到zoological发生了两次，但这就是最终结果应该包含的内容，作为最终的结果之一。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_16.png)

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_17.png)

但现在我们可以通过使用另一个程序来运行它，并将它们加总起来。这就是接下来要做的部分。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_19.png)

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_20.png)

好的。这个是另一个有趣的小Python脚本，顺便说一句，它有点复杂。事实证明，它并不难理解，一旦你明白了，但它使用了一些在C++中不一定常见的东西。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_22.png)

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_23.png)

比如说，这个`yield`，基本上这个函数是在另一个函数中使用的，你将在下面看到。它基本上是遍历每一行并抓取第一个项目——即单词，然后将所有相同的单词连接在一起，使用1来计数。

所以它基本上就是在做这个，然后它输出实际的单词，哦，抱歉，这个在计数中没有做，实际上只是把单词放进去，然后再放上1111111。这就是它在做的事情。好吧，接下来让我们看看当我们这么做时会发生什么，如果你想查看程序的细节，你可以。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_25.png)

但这个方法是我们首先做这个，然后按键分组，然后这个方法就会说，好吧，现在它就一步步地执行。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_27.png)

现在，虽然你可能可以将一些步骤合并在一起，如果你真的想这样做，但这就是主要的算法，按照这种方式做，它适用于许多不同的问题。所以并不是说你必须，如果你把所有的map reduce任务都按这种格式来写，它就总是能工作。

如果我们以其他方式进行操作，情况可能就不一样了，但例如你的操作在那个文档中有很多次。所以一旦你得到了这个结果，你就需要编写另一个程序，在这个例子中是单词计数归约器，它是这些陌生事物中的另一个，但基本上它做的事情是一样的，处理每一行，取出第一列，也就是第一个单词。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_29.png)

第一个由空格分隔的值就是单词，然后对于其他所有空格分隔的值，都是1，它们将被全部求和。好的，基本上它做的是所有剩余值的求和，然后打印出单词和总和，这就是你的答案，接着这些数据将被发送回服务器。

记住我们在这里做的不是跨多个服务器的map reduce，而只是单台计算机上的操作。那么这个操作应该是什么呢？那就是`./word_count_reducer`，希望它能顺利执行，注意到其中包含了单词和其他内容，例如你自己输入的27个字等等。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_31.png)

这就是map reduce的核心思想。好的，现在执行一对一操作。将所有的单词整理在一起，然后计算一些单词的出现次数，然后基本上将数据返回。问题是，你必须执行分布式操作，这部分就是科学所在。是的。所以，一对一看起来像是一个程序，你可以把它拿出来，在第二步中直接求和。

但因为我们正在分发这个任务，它们只能附加一个值，因为每个进程都无法访问其他进程的结果。嗯，这是个很好的表达方式。是的，Sam的评论非常好，原因是我们之所以进行一对一操作，在这里似乎没有意义，因为你本可以直接进行求和，因为那时是一个线程在执行所有操作。

但当多个线程都试图向一个文件贡献时，比如说，它们每个线程都只能贡献一个值，所以会在末尾附加一个值。现在，它能读取这个值并把它放进去，当然可以，但我的意思是，从这个角度来看，这是最通用的做法。

在你们在中心幻灯片上看到的管道中，线程会在哪里呢？是的，是的。所以这是一个成员，这不是那个，这是现在一个单线程的例子，所以它不可能发生在哪儿。它们会在归约阶段重新合并，基本上归约会将它的各个部分缩减，然后当最后一个完成时，它基本上告诉服务器“嘿，我们都完成了，去取这个文件”，然后服务器去获取文件。所以，这就是作业的工作原理。关于这项作业的好处是，这在世界各地的数据中心之间不一定适用，但对于我们的作业来说，我们有多少个神话系统？我们有10个、12个还是15个，或者其他什么。

那么多个神话系统共享相同的文件系统，这就是这项作业的好处。如果你请求一个文件，你可以使用一个路径，不管你在哪个神话系统上，它都会从文件系统中获取该文件。我的意思是，你每天都在做这件事，当你请求这个代理并进入你的CS 110文件夹时。

它在多个不同的神话系统上是相同的文件夹，因为实际上它是相同的底层分布式文件系统。所以，这项作业的好处是，虽然我们使用了多个神话机器来完成这个任务，但我们只使用了一个单一的文件系统。你可能会想，“哦，如果我们没有共享文件系统，该怎么做呢？”

好吧，你必须每次都来回传递数据。因此，如果你想说，“嘿，去处理这块数据”，你首先必须把数据传送到那台机器上，当它完成时，你必须把数据重新收集回来。

如果你曾经上过并行处理课程，或者将来有同学会学到，你会明白为什么这很重要。为什么这是个大问题呢？有时候在多个数据中心之间保持整个文件系统同步的成本太高了。现在情况不那么糟糕，但在多个数据中心之间保持同步并不高效，因此实际上发送数据并获取返回比仅仅说“嘿，读取本地数据，然后一旦到达就获取响应”更容易。

就是这样。好了，关于MapReduce算法本身的问题，除了那些关于这些步骤什么时候发生的问题，还有其他人有问题吗？是的。我们再回顾一下按键分组做了什么。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_33.png)

按键分组只是将所有这些数据放入其中，但它实际上还没有进行合并。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_35.png)

就像它还没有把所有数据加起来一样。在我们的案例中，归约器只是做加总的部分。这就是它所做的一切。为什么它们分开？我认为这归结于一个想法，就是许多文件会合并到一个文件中，而那个文件不会是最终的结果。

这归结于这个想法：很多文件会被添加到某个文件中，可能是更新一个文件，或者它们会更新多个文件，但可能有多个线程在同一台机器上进行这个操作，因此你不想在加和的同时进行求和，这可能会变得更慢。

如果你只是在添加一个元素，那比起说“哦，我现在要获取值并求和”更容易，我认为这大概是主要的原因。所以让我们来看一下实际的作业，一旦我们开始。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_37.png)

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_38.png)

正如我之前说的，这个作业是下周三前完成，虽然从周五开始才会有延期天数，所以你可以在周四提交，当然会有相应的惩罚。这个作业显然是要实现MapReduce算法。它会使用 Myth Machines，所以你需要在一台 Myth Machine 上运行你的基本程序，然后它会创建一个程序并通过 SSH 启动。你可以查看代码，看看它是如何实现这一点的，然后这个程序会回调到服务器并说“请给我一些数据，告诉我该做什么”。

基本上，这个程序将把所有这些处理分配到不同的服务器或不同的任务中，然后每个任务都会回调到主任务，并说“嘿，给我点工作做”。事实证明，大部分代码已经为你写好了。这里有很多内容。

我们已经为你提供了一个非常强大的程序开始框架。这意味着你必须事先理解大量代码。事实上，这个情况在整个课堂中都存在，几天前我和某人在办公时间聊过这个问题，我们有很多代码需要阅读，而这种情况在哪里都会发生。

有多少人已经做过计算机科学领域的实习？嗯，你们有没有发现，到了某个阶段，大家就会说：“好吧，你的工作就是对代码库进行一些更新”，然后你看着代码库，它有十亿行代码。

说真的，它有十亿行代码，你得弄清楚怎么做，而且每个地方的代码格式不同，使用的工具也不同，他们有不同的方式来管理文件和做代码审查，你必须学习所有这些东西，这其实和你进去后看到一堆代码，准备以某种方式修改它的情况非常相似。

你得先理解代码。 所以如果你在想，哦，这有很多代码要看，这不仅仅是为了让你有乐趣，我们这么做是为了让你为将来必须在现实中做这件事做好准备。

好的，这是我们给你提供的稳健起点，我们给了你很多代码，你可以浏览一下，我们将在几分钟后逐步查看其中的一些内容。有四个任务，你要依次处理它们，最好按这个顺序进行。你当然会添加一个线程池，添加线程池可以让你的主分发程序启动所有的线程，而不必担心线程的问题，并且当工作量增大时，每个工作线程也可以有多个线程来处理任务。

这是其中一个挺酷的部分。好的，你将要做的是`reduce`部分，我们给你留下的唯一真正开放的部分就是`reduce`阶段，我们给你了一个相当开放的框架，如果你看一下，我们稍后会看这个，但先看看吧。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_40.png)

如果我们找到了它，查看`assignment eight map reduce reducer dot CC`。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_42.png)

好的，这是你到目前为止的函数，就像我们没有给你太多内容一样，我们给了你完全没有内容的代码。这是你的部分，是你大显身手的地方，你需要编写`reducer`函数，但一旦你理解了需要做的事情，你就会明白，所有这些分布式文件将采用这种格式。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_44.png)

现在我需要一起处理它们，然后把它们重新交给服务，这是可以做到的。好的，我们走到这一步时会继续讨论。好的，没问题，差不多就这样。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_46.png)

让我们来详细讨论一下这些细节，因为你需要赶上这些细节的进度。当你克隆作业时，好的，实际上我来做，看看`R`和`dash R`，我需要哪个？我需要`files`，希望是`files`，如果不是就麻烦了。

所以当你开始你的作业时，嗯，我只是提醒你，不要做类似`R`和`R*`这样的操作，这样做真的很糟糕，我只是说`/star`那样做会破坏很多东西，尤其是当你是超级用户时，千万不要那样做。相信我，我曾经做过类似的事情，只是你不小心做了，就会把一天的工作给毁了，我可以告诉你这一点。

所以，无论如何，当你开始时，并不是所有的文件都会最终进入这个特定的目录，这将在你进行调试时帮上大忙。所以你要做的是输入`make directories`，它会创建一些目录，一个叫做`files/intermediate`，另一个叫做`files/output`，然后它会创建一些临时的文件，创建它们的工作原本应该是可以在虚拟环境中完成的，但它会为你自动创建。

这就是所有数据将要存放的位置，好的，每次运行程序时，你应该通过执行`make file free`来清理该文件夹。这样做的作用就是删除该文件夹中的所有文件。好吧，这样做的原因是，你不希望之前存在的文件在你尝试处理新的数据批次时造成损坏。因此，记得执行`make file free`，你只需要在每次运行程序之前做一次。

你应该这样做。好的，实际上这个程序涉及五个不同的可执行文件。好的，我看到有些人可能在想你在说什么。这其实没那么复杂。你有map reduce map，它负责映射，map reduce reducer，它负责归约，而这些程序是协调工作的。还有我们为你编写的两个程序——word count mapper和word count reducer。

这些文件与我们之前看到的Python文件类似。好的，它们已经构建好了。你只需要修改这些其他文件才能使它真正工作。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_48.png)

因为你采用的这种方式，你可能会想，哦，那我需要多少线程，多少台服务器，这个那的？你有一个配置文件。好的，事实上，如果我们现在查看它，我们将查看Odyssey中的这个CFG文件。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_50.png)

哎呀，等一下，我发誓我刚才点了，行了，我们看一下Odyssey中的这个CFG文件。这里是这个文件的内容，它总是会像这样显示：你告诉它你要使用哪个文件来实际映射单词。嗯，它会是这个word count mapper程序。那哪个文件会做归约器的单词计数呢？就是这个word count reducer。

我们会有多少个映射器（mappers）？我们会有八个映射器。基本上就是八个线程，会在不同的服务器上执行各自的任务。那我们会有多少个不同的归约器（reducers）呢？我们会有四个归约器。为什么是这个数字呢？这些数字有点随意。

通常你可能会将它们设置为相等，但也许你知道在映射部分工作量较大，所以你希望为此分配更多的计算资源。然后它会显示输入路径。在这种情况下，就是这个Odyssey文件夹。我马上会展示里面的内容。然后你告诉它中间路径是什么。中间路径是在映射器完成后使用的。

它们会将大量文件放入这个中间路径，我们将查看这些文件。然后，你还有一个输出路径，最终结果会存放在这里。我们也会看到它。现在我们去看一下Odyssey文件夹。如果我们进入samples文件夹，然后进入Odyssey full。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_52.png)

这里我们已经为你做了这一步，将《奥德赛》教科书或文本分成了十二个不同的文件。我们来看其中一个，0007.input。顺便说一句，在进入这一部分之前，看看这个文件名是四个零和一个七，后面还有三个零和十一。你需要自己写出这一部分。比如，如何构造一个字符串，前面有三个零，总共凑成五个字符。

其实不算太难。别想太多。但要知道，你需要自己做这一步，然后才会明白，哦，好吧，这就是它没有为你自动完成的部分。很多人卡在这里，就会想，哦，为什么它没有做到这一点？其实你只需要自己动手做。

不管怎样，先来看其中一个文件。这就是它的样子。它只是《奥德赛》的一部分。好的，你可以通读一下，这是重点。我们已经把它分成了十二个不同的文件，因为我们基本上是将每个文件分发到不同的服务器去执行各自的任务。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_54.png)

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_55.png)

就是这样运作的。所以在进行过程中，你会发现其实不需要做太多修改。如果你愿意的话，可以使用《奥德赛》部分文件（Odyssey partial）。是的，《奥德赛》部分文件包含的文件要少得多。所以如果你是在调试，可能使用这个会更好，这样就不会花太长时间。只需要注意修改这个部分。你只需要修改CFG文件，或者运行这个Odyssey partial.dot CFG文件。

然后你做这个。好的，接下来这些就是我们的文件，我刚才已经给你展示过了。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_57.png)

所以我们实际上运行它。好的，当你运行它时，我会复制这一行，因为它有点长。你会习惯复制粘贴这一行或你程序中的那一行。也许我不粘贴了。好了。我已经做了make文件自由的步骤，已经完成了。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_59.png)

不，我还没有。我做过，但我得在正确的文件夹里。做文件自由。好了。接下来我们要运行这行代码。现在看这个部分。它的第一部分是映射器（map reducer）协调器。就是这个部分，还是这个部分？

我们要运行解决方案，看看结果。接着映射器会使用MRM映射器解决方案，减少器会使用MRR解决方案，然后配置文件就是这个。接下来，你可以打开你的文件，问自己，为什么我们不把这些内容放到配置文件里呢？你本来可以这么做的。

但实际上，这是一种相当通用的做法，它在这个意义上更为通用。你可以在这里使用其他文件，但仍然保持相同的配置文件。这就是我们在这个案例中的做法。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_61.png)

好的，让我们运行这个，你会看到很多内容快速飞过。好的，所以所有这些日志数据其实是可以用来帮助你了解发生了什么的。只是这里有很多数据，最终这就是带有线程的完整版本，而且实际上速度相对较快。它会处理完毕，并最终输出所有结果文件，并且它会对这些输出文件进行哈希处理，这样你就可以检查答案了。

记得回到第一次作业或文件作业时。类似的事情，你会说哦，我的哈希值是相同的，我们可以继续了。好的，所以这就是你需要做的。正如我所说，你的程序正在调用这些 SSH 操作。

现在让我们实际查看一下它是如何执行 SSH star。cc 的。好了。所以它基本上是在做一些文件。文件里有一些流，它基本上就是在做类似这样的操作，它说好的，这就是你，它会告诉它如何进行 SSH。

好的，这里有很多有趣的内容。你可能会问自己它是怎么知道你的密码的，实际上我也不知道。我忘了它是怎么做的。我会查一下它是怎么做的。那是什么？

它不知道你的密码，所以它在不需要知道你密码的情况下执行。我忘了怎么做。我会查一下。我不确定。反正它就是这样做的。然后让我们看看其他的。这里发生的所有不同的通信，就像它说的那样。哦，通知 Myth 52 工作节点，所有文件模式已经处理完毕。

我们将会看到一些内容来执行这个操作。记住这些，因为它们会在你调试时帮助你。好的。好了。那么就是这样。现在我们来看一下输出发生的位置。好的。那么如果我们查看 files/intermediate。好的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_63.png)

这里有一堆文件。好的。现在事实证明，这就是它们实际工作的方式。00001。0000.mapped。好的。基本上是从文件 00001.input 中获取一个单词子集，并将这些单词分别哈希后存入 00000.mapped 文件中。每次你看到一个以 .0000.mapped 结尾的文件，它意味着那个单词被哈希到了那个数字 mod，我相信是 32。

所以如果我们向下滚动，查看 Mac yacko 0 到 31。那么每个文件的名字都包含 31。现在有 12 个不同的文件。为此有 32 个独立的映射文件。所以 32 乘以 12 是 384。这个文件夹里应该有 384 个不同的文件。而在这个案例中，确实有。好的。我们会详细讨论这是什么。

我第一次看这些文件时，不知道发生了什么。让我给你看看。好的。所以如果你查看所有这些文件。好的。这就是 word count mapper 生成的文件。好的，当我们实际查看这些文件时，你会觉得很熟悉。好的。word count mapper 把这些文件放在这里。

它们代表了从输入中哈希到该特定数字的单词，所以我会向你展示哈希的含义，我还写了一个小程序来测试它，这样你也可以测试一个单词哈希。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_65.png)

但是让我展示一下，假设我们看一下12到28，0 0 0 1 2点0 0 0 2 8。这个看起来熟悉吗？这是之前映射器的输出，它处理了这些。它们实际上在稍微下游的地方，这些是所有从零零零到零零十二的单词。

从零零零开始，来看一下，所有从零零零到十二的输入，已经映射到这个或者那个，当哈希结束时，结果是经过32取模后得到的28值。让我给你展示这是什么意思。好吧？它就在这里。它在这个列表里。所以如果我们通过某个哈希函数运行它，你会得到一个数字，对吧？我们来做这个。

我写了一个文件或程序，来看一下，它是，来看一下CS 1。我直接从这里运行它。CS 110，你也可以运行它，来看从这里运行。你可以这样运行，输入斜杠。用户斜杠课程CS 110，W不用知道，我们可以做讲座例子。好了，讲座例子MapReduce，哦，不，它没做，你得做。抱歉。

你必须在下载用户时先制作它，来看一下CS 110春季课程，MapReduce。哈希——哈希器，好吧，如果你运行一个哈希，它会说请提供一个要哈希的东西。那么如果我们提供它，它将哈希成这个数字，哈希函数是什么？

这是C++内建的东西，它可能在不同的机器、不同的操作系统和不同的C++编译器上有所不同。我们使用的是相同的，所以对我们来说它总是一样的。但是如果我再次运行它，它应该总是哈希成相同的数字，这个数字将无法适应32个桶。

所以如果我们对其进行32取模，它会适配到28桶，好吗？这不就是我们之前想要的吗？

看看，如果我们输入greev g r e ve，然后尝试相同的g r i e ve，它也应该哈希到28桶。好吧，那么这里发生了什么？我们有。每个单独的文件，这里每个输入文件有32个文件，现在已经按照以下方式映射，其中输入文件中的所有单词被哈希到特定的32个桶之一，就放到那个文件里，并附加一个小的编号。

就是这样，这就是中间文件的最终结果。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_67.png)

好的，然后它们是384，不行，可能部分已经在里面，不，问题不行，问题是等等。你刚才说了些关于我必须做的事情，我必须弄明白这一点。0 0 0 1 2的事，部分已经为你搞定了，像这些，你需要自己写，我会告诉你它是如何工作的。

实际上它不是为你写的，因为它原本就在那里。你必须弄清楚如何把一个数字和前导零加到五位。这就像一个一或六的问题，其实不难吧？

当你写程序时你会发现。我是说，嗯，它是在，我忘记了。它在映射阶段发生。是的，这是发生的事情。不是在管道编号中。这将会在C++中。没错。你不会忘记这个。好了。你还没完全用它。我们现在还没有用到任何Python，稍后你会看到发生的地方，好的。

那现在，有没有关于结果是什么以及为什么这里有384个文件的问题？

我并没有详细告诉你为什么正好是这384个文件。但事实是，结果是有八个mappers和四个reducers。所以我们每个输入文件会生成32个不同的文件，明白吗？这就是为什么是这样的。为什么是mapper的数量乘以reducer的数量？这完全是任意的，明白吗？

这是任意的，主要是因为如果我们这样做，这会迫使你将代码拆分成许多不同的部分，这样在做线程部分时会。暴露出一些更难发现的错误，主要是你是否正确地锁定了需要的部分，或者其他什么。

所以这就是这件事的重要性，我们说你必须生成这32个文件，或者在这个案例中是8乘以4，因为我们希望你能够。编写你的线程并使锁正常工作。所以在这个意义上它有点任意，但这就是现在发生的事情。明白了吗？

好的，所以，我们再看一个文件，确保一下，如果我们看一下，我们刚才看过的零零零一二点input。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_69.png)

如果我们看一下零零零五，还是28，而不是12，看一下零零零零零五点，28，嗯，它也应该包含V。好的，任何带28的表示最终在那里出现的单词哈希到28。为什么在此时不同的文件中有不同的这些？现在。

每个单独的输入文件中可能包含很多这样的内容。事实上，我们可以查找。看看我们是否能做到。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_71.png)

看一下grip，如果我们查找，作为，嗯，我们来看看，怎么做呢？

这有点难，因为文件的原因，稍微有点难做到完美。但是如果我们查找，嗯，且它不会做逗号和其他东西，来看样本。让我们看看Odyssey full，Star是的，它会说，然后我们再看。我认为-L会列出它们所在的文件，-L。好了。

结果证明，V恰好位于文件三到十二中，可能也包括二。但我做错了。所以它们都在每个文件里。所以它们都会出现在任何包含28的文件中。是的，好的问题，问题是，嗯，当我们进行多线程处理时，到底会加速多少？

所以其实回答这个问题有点困难，它会很好地扩展。我这么说吧。仅仅因为你将它分布在多个不同的服务器上。当我们尝试启动版本时，它没有任何线程处理，也没有做完整的操作。但你会发现，它稍微慢一点，不过你确实能看到一些加速效果，做的时候你会感受到一些速度提升。

不过很难精确量化这个问题的大小。我们正在做的，可能不会得到巨大的加速，但会有一些，好的。那么目前我们站在哪里呢？我们现在已经展示了，你需要将这些映射到多个不同的文件中。在你做reduce之前。是的，嗯，问题是，哈希的目的是否就是为了让我们可以将它们分割成？

文件基本上是均匀分布的。我们实际上来看看文件的大小，看看它们的情况。它们是这样的，685看起来是一个小的文件，但之后的文件可能有几千个，甚至可能有一万个，我不确定，但它们的大小大致相同，有没有别的方法来处理呢？

我的意思是，你可能能通过你所拥有的数据来弄清楚这一点。你知道，你可能会说，哦，就在这个文件中做一个从A到L的操作，然后你知道从哪些额外的词开始。可能并不会完美无缺。不过，从这个角度来看，这可能稍微好一点，是的。好的问题，其他人呢？好，咱们看看。

只是想知道你是否可以轻松地计算《奥德赛》中的所有单词，看看吧。想一想，看看我们是否做以下操作，当然现在不做。我们可以计算所有单词，看看它们是否都在里面，我会把这个放在Piazza上。比我现在尝试弄明白命令要容易得多。

但它是可行的。所以如果你想学习如何使用哈希函数，我们已经为你写好了一个非常合适的地方，或者直接查看我提供的这个文件。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_73.png)

我粘贴的，或者我放在这里的，不是那个。我觉得我做错了。哦，我好像粘贴错了。糟糕，我大概粘贴了错的那个。我会修正的，哈希程序的位置。稍等。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_75.png)

不，它没有做到。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_77.png)

没有，它没做到。好吧，如果你点击它应该能出现，但你可以查看那个文件，实际上看一下它是如何做到的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_79.png)

其实并不难，cat slash。这是我接下来会展示给你的，Spring I map reduce 和 Hasher 已经有了 CC。它非常容易使用，你基本上只需要写 hash，括号或尖括号字符串 hasher 然后，传入字符串， voilà。这样就能得到哈希值。所以这真的非常简单。嗯，你还有其他问题吗？问题是，如果你这样做了，那么映射完成后，你是否就没有任何竞争条件了？

不，我是说，如果你正在使用分布式文件系统，每当两个线程在任何一个神话实例中试图写入同一个文件时，它们最好不要写到同一个文件。所以你确实需要在这里做一些事情。现在，这会有点困难，你不能跨线程加锁。

是的，神话。还有其他你需要担心的事情。我觉得在这种情况下，让我们看看。不，这只会是多个线程的情况，你可能会遇到那个问题。所以，每个独立的神话实例不会和其他实例写同一个文件。这是一个好事。所以它在整体上会运行得很顺利。

你仍然需要考虑线程的问题，就像平时那样考虑。我应该退一步想，就像平时那样考虑，如果多个线程可以同时修改一个数据结构，我最好加锁。那就是最大的问题。我们要考虑这个，好的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_81.png)

好的，那么我们现在实际上运行一下启动代码吧。好的，看看你的启动代码究竟会输出什么。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_83.png)

好的，我会做和之前一样的事情，先做一个文件三。好的，现在清理一下所有内容。别忘了这么做。然后我只会复制这一行，好的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_85.png)

所以这个基本上是使用你版本的我们提供的启动代码，和我们提供的 mrm 代码，以及我们提供的 mr 代码。然后它会显示 "仅映射"。这是因为我们没有为你写归约部分，"安静"意味着除了这些你会看到的哈希值，不会打印任何其他细节。好的，这就是我们要运行的，你可以看到它的运行速度，看看它是更快还是更慢。

然后，好的，我们看看。我从这里开始做。好了，正在进行中。现在我得等一下，等一下。这只是映射部分，对吧？看，它开始了。就这样。所以映射部分，我猜你可能看不太出来，但它会显示一些输出的哈希值。现在我们来看看文件，顺便说一下是中间文件。

如果我们查看输出文件的话，当前没有任何文件，因为还没有进行归约阶段。但是如果我们查看中间文件，那么你的解决方案并没有把文件分解成任何哈希部分。那部分是你需要完成的，但是它做的事情是已经进行过映射了。

就像是“零零零一.映射”这样的文件，看看它为你已经做了什么，对吧？

所以在这个意义上，我们不需要你在这里使用那个 Python 程序做任何事情。我们已经用 C++ 为你写好了。好的，现在这部分已经相当接近完成了，关于它是如何为你做映射的。好的，现在让我们在没有安静模式的情况下做，重新让文件可用。

确实重新让文件可用，然后我想在没有安静模式的情况下做这个，你将会看到这里发生了什么其他事情。好的，所以它仍然在通信。它已经在做很多这种通信的事情。所以并不是像仅仅在本地运行像 Python 脚本那样。它实际上是在通信并发送回数据。

我是说很多东西已经为你写好了，问题是，它没有进行哈希处理，对吧？是的，所以现在这个只部分完成，你仍然需要将它进一步分解成。32个部分，在四乘八的情况下是不同的文件。针对每一个输入文件，你可以通过哈希来完成这一部分。

再次说明部分原因是我们让你做这部分内容。这是为了让更多文件能够分散到更多的服务器上。另一部分是你可以做这种测试，验证锁定和多块或多线程是否正常工作。我们再次提供了线程池。并不是说你必须写这部分代码。

你只需要写锁定并做好正确的锁定，这实际上。在大局上，从现在开始最重要的部分就是。你已经写好了线程池，之前也做过常规的线程处理。从现在起，你可能只会使用线程池，或者单独使用线程。

但现在在这个阶段，重要的部分是，哦，你真的知道在哪些地方进行锁定吗？这是最重要的部分。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_87.png)

好的，其他问题，好的，那我们回到这里。所以这就是我们实际在程序中做的事情，你可以看到。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_89.png)

事实上，现在我们可以看看它实际显示在哪里。让我们看看，找不到问题，然后我们就这样做，文件路径是文件夹/中间结果星号。- 哦，这是一个，它应该告诉我们它实际上找到了哪些文件，并且在这个例子中。是的，找到了所有文件，但只有其中一个文件没有结束符号，在这种情况下就是这样。

所以它已经将每个输入文件拆分开了，并且完成了这个操作。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_91.png)

第一次映射给你，好的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_93.png)

好的，那现在我们处于什么情况？我们来看看一些文件。这是你现在需要查看的主要文件，顺便提一下，分四个任务，任务一是理解这些文件。任务一你不需要做任何事情，除了吸收并且你得有些基本了解。

以最佳方式完成，但不要跳过任务一。否则你会被压垮，因为有太多东西要理解，对吧？即使只是阅读，也不要想着跳过，先理解这些东西。好了，mrm，那是入口点。

这是 map reduce 服务器的客户端，好的，服务器在每台机器上远程调用 mrm。所以每台机器都会运行一个 map reduce mapper，好的，然后。就像我说的，这之所以能工作，是因为 x-men 文件系统，map reduce mapper 是那个。实际上处理所有服务器业务的类。好的。

这里是最有趣的部分，来吧，我们来看一下 map reduce mapper 和 map reduce。map reduce，worker，好的，如果我们看一下，来看一下，看看。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_95.png)

让我们看看文件的名称是什么，看看它生成了什么，我们来看一下 map reduce。首先是 map reduce worker，好的，我们来看一下 map reduce worker。h。现在定义了 map reduce worker 基类，现在有多少人记得 106b 的内容？

就像上周课上你们已经不再关注时，你们谈论的多态，讲述了叙述者等内容，谁还记得？是的，可能只有一个人记得吧，所以这是为你们写的。

所以你不需要担心这些，但基本上我们已经把它拆解开来，看看。这里有一个服务器和 reducer，以及 mapper，它们都必须以几乎相同的方式与服务器进行通信。所以让我们，但不完全相同，我得说在这儿也有不同之处。

所以让我们创建一个基类，它执行这个 worker 部分，然后每个独立的 reducer 和 mapper 从这个 worker 类继承并执行。所以你需要理解一点继承。当你阅读这些内容时，别害怕看到这些。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_97.png)

一会儿我会给你展示一些奇怪的东西。好了，在这里，我们有什么内容？

我们有一个庞大的。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_99.png)

这个的参数集。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_101.png)

好的，然后我们可以请求输入，请注意这里有客户端的部分，这部分大多数已经为你写好了。我们不要求你重新做所有客户端创建的事情。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_103.png)

好的，它有服务器的部分，也有提醒服务器进度的功能。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_105.png)

你应该使用其中一些来打印出正确的消息。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_107.png)

当你尝试做进度更新等事情时，好吧，让我们看看map reduce mapper，我会给你展示可能看起来有点奇怪的部分，看看map reduce mapper。好吧，这是它的实际构造函数，好的，注意到它有一个map reduce工作者，作为其定义的一部分。

这是因为它在子类化map reduce工作者，结果是，嗯，实际上很不错，它甚至没有其他参数。基本上是把所有自己的参数传递到map reduce工作者的类里，然后更新一些功能。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_109.png)

嗯，在这里，好的，我们有map正在运行，这就是我们目前所拥有的，好的。我会给你展示map reduce reducer。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_111.png)

嗯，但我会再给你展示一下，这里user，Cc也是类似的东西，它子类化了map reduce工作者，然后有了这个reduce函数。好的，所以你并不需要去挖掘太多东西就能弄明白发生了什么。

你必须理解那些文件中发生了什么？好吧，那是任务一。好的，理解所有这些文件，嗯，让我们看看这里还有什么。我们来看一下mrm.cc。哦，mrm.cc。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_113.png)

好吧，这基本上现在说的是map，map，这就是它在做的。它最终会调用reduce，好的。所以你必须做那个，你还必须做reduce。你还需要做的事情是，结果是，你必须修改这里的参数个数。

当你阅读任务说明时，你会发现，嗯，基本上你必须添加另一个参数来根据这些哈希和其他内容来拆分文件。所以你需要更新这一点，嗯。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_115.png)

它在任务清单上列出，你必须做那个，好的，任务二。嗯，现在我们得启动多个mappers。每当你说启动多个时，你应该立刻想到线程池，对吧，这就是你需要开始的地方。所以你必须说，哦，好吧。我基本上是要修改spawn mappers。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_117.png)

spawn成员在哪里？在map reduce服务器中，app reduce服务器中，好吧。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_119.png)

启动映射器，好的，当前的启动映射器函数没有线程池。好的，但你要做的是，你将会，在启动工作线程的周围包裹一个线程池，这样它就能执行多个工作线程。好的，为什么我们要这么做呢？因为这将使它变得更加容易，或者说，这将使它在速度上更加高效，并且能更好地进行通信。

好的，你需要对它做什么？你需要确保在正确的地方加锁，嗯。现在你已经了解线程池了，所以这些就是你必须做的事情。嗯，如果你实际使用了错误的那个参数，那么会有一个问题。

名为`orchestrate workers`的方法，它使用了`handle request`，我认为是`handle request`，你实际上会在这个方法中映射到一个调度任务。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_121.png)

嗯，`handle request`。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_123.png)

我们来看一下。这里有一个`orchestrate workers`函数，我们会查看头文件，看看它是怎么定义的，然后还有一个`handle request`函数。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_125.png)

在这里，这就是我们可以基本完成的部分。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_127.png)

在这里，你最终会进行调度。好的。我们想查看这个函数的头文件。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_129.png)

好的，`orchestrate`。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_131.png)

哦，那里并没有说到这个。哦，不，我以为有说。嗯，无论如何，它在作业要求中已经提到了。而且他们提到，针对汽车，请确保你正确地写入你的 Texas，并且只修改那些会被多个线程修改的部分。你需要查看代码，看看这些地方在哪里发生。好的，问题来了，在`handle request`中，你基本上会需要用到互斥锁，对吗？你会在这里需要它，然后任何调用它的地方可能最终都会加锁。

需要加锁，因为会有各种文件被写入、读取等等，你需要注意这些。还有其他人吗？好的，那就这样。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_133.png)

然后是任务三。这是哈希部分。现在。这是你要做的地方。此时，实际上你的程序只会创建这些小的00xx.map文件。现在我们需要做的是将它们拆分成。所有那些我们稍早看到的中间文件。好的。

这就是你需要更新构建映射或命令的地方。这个是我们需要添加另一个参数的地方。好的。那么这个参数将是每个映射器使用的哈希码的数量。你怎么弄清楚这一点？

嗯，你可以通过将服务器数量乘以映射器数量或者映射器数量乘以归约器数量来计算这个数字。好吧，你还得更新mrm.cc以接受它的rv中的另一个参数，这意味着你得更新map reduce mapper。所以有一系列的步骤你得去做，“哦，现在这个也需要更新了。”

更新的参数，那个也得更新，才能传递过去，那个也得更新。所以它有一点点传播，你会在到达那个部分时看到，但不要太害怕。如果你开始觉得“哦，我更新了很多参数”，你至少得做三次。你得做三次，而且哈希码的数量，我说的是映射器的数量乘以归约器的数量。

大致上就是，嘿，你在做这个的时候，和并发相关的部分你做对了吗？

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_135.png)

好的，最后你得做归约部分，嗯。这就是我之前说的，这部分比较开放。因为我们没给你任何代码，只是告诉你算法应该怎么工作。在这一点上，你知道哦，现在我有了384个文件，我需要做什么。

然后将其合并回我们现在的输出文件中。嗯，让我回去一下。我刚才没展示给你看，忘了做这个。嗯，我没有展示给你看。我们做这个make file free，好吗，然后做原来的那个，不是的，那个更长，我想回到那个，这个。好了，呃。

就是这个，和这个将会处理所有文件，这就是解决方案，嗯。就这样，看看文件/输出，在这种情况下会有32个输出文件。好的，000，One dot out或者zero，Dot output，好吧，现在是按字母顺序排列的，实际的总计数。这就是你最终会得到的，好的。

如果你真的想创建另一个文件，将所有的文件合并在一起，因为它们会在这种情况下被使用。呃，我们来看看00031 dot output，呃，哦不，这不是按字母顺序排列的，否则你需要做一些额外的排序。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_137.png)

但是它将会基于你输出的单词生成32个不同的文件，好的。那就是这样，但我猜你会觉得有一个额外的步骤需要你去做。我认为我们不需要做这个，所以让我们看看，我们要怎么做这个部分？嗯，你需要知道你需要做什么，但归约器需要将包含键（也就是单词）的中间文件集合整理在一起。

嗯，使用相同的哈希代码对其进行排序，然后按键对排序结果进行分组，然后调用归约器，嗯，实际生成输出文件，然后你可以将它保留为最终的输出文件格式。好的，嗯，假如你不想重新编写代码，可以在这里开始使用我们提供的python程序。如果你不想做排序和分组，嗯，这就是你可以去的地方。

哦，好吧。我将使用你已经给我们的文件。它们位于这里。你应该在程序中使用那个绝对的文件名，实际上可能作为常量在其中。嗯，例如，按键分组，词频统计归约器等等。你可以这样做。问题是如何运行那些python程序？

你可能可以使用子进程，或者可能可以使用我们之前做过的类似方法。事实上，有一个函数叫做system，使用起来非常简单，好的。让我来展示一下它有多简单，嗯，让我们看看，我们要去。应该有这个，我应该有这个在第二个文件中，我的讲座映射归约。好了。

在这里，system示例，好的，system示例接受一个参数，即。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_139.png)

你在命令行中输入的命令，它会执行，对吧。你不需要将其解析成rv。你什么都不需要做。它直接执行就行了，就这么简单。嗯，它不会给你返回答案。它实际上会做它该做的事情。它不会返回输入或输出，你必须实际去。

将其管道输出到一个文件，但比如说，我会给你一个示例。我要稍微重新输入一下，但，嗯。让我给你展示一下这个应该是什么，并确保你明白它。记住我们之前提到的事情，我们有所有不同的，嗯。

我们之前有这个完整的python流，嗯，如果你运行它，你可以从你的c++程序中通过使用那个system命令来运行这个精确的命令。所以如果你运行它，它应该会输出到我叫的那个文件：all_output.txt，就这么简单。

所以你可以通过使用那个system命令来为每个单独的文件运行它，这样你就不必做排序了。你不需要做，实际上它会在这种情况下做。如果你不做所有的流水线操作，但做其中的一部分，它比用c++写要稍微容易一点。你完全可以用c++写，可能会更快，因为它不需要调用程序外部的所有这些函数。

但如果你想做得更简单一点，因为我们之前做过的东西，可以照做。字母顺序排序，对吧，这就是我们在python程序中做的事情，python程序在这里调用了排序函数。

你会做同样的事情，你可以使用排序，你也可以使用 C++ 的排序函数，如果你有类似的文件。或者你可以读取所有文件并以这种方式排序，你也可以那样做，不，不，你会排序单个文件。对，你可以通过读取它们然后再推回到文件里来做到这一点。

这样也行，或者你可以使用它或者让它为你处理，所以最终你可以决定用哪一种方法。但是它们已经有了，所以记得中间文件的输出是什么。我们来看一个中间文件，像是 1000006 点零零零二九。哎呀，点-mapped，看起来像这样，但还没有排序。

就像文件进来时的样子，就是你得到的内容，所以你需要首先对它们进行排序，然后你需要汇总它们。做所有的工作，然后你需要加总所有这些文件，其他的 Python 程序会为你做这些。如果能用的话，最好用那个，你得弄清楚最终的文件名会是什么，等等。但这就是基本思路，所以你可以选择以任何一种方式来做。

我可能会建议使用 Python 版本，因为它很容易实现。你需要在所有文件上运行它。是的，你确实需要在所有文件上运行它。是的，你必须在每个文件上运行它，你会在后续的部分看到的。是的，你必须在所有文件上运行它，然后一旦你有了所有这些文件，就把它们汇总在一起。

![](img/a7a304e14cd2dd38cb9686e50bf4fc64_141.png)

当你到达程序中的那个部分时，你会明白的。但这就是基本思路，好的，好的，这就是你如何做到的。嗯，这里有一个提示我想指出，虽然现在可能没什么意义。一旦映射器的工作进展到可以进行汇总处理的阶段，好的。

你需要将所有这些文件减少到相同的哈希值，所有那些例如以零零点零零零零零零零一结尾的文件。好的，我想我可能漏掉了一个，以文件结尾的部分。是的，我想我漏掉了什么，但无论如何，所有这些文件都应该以零零零一点napped结尾。

你需要将所有这些文件拿来并进行汇总处理。好的。所以你可能需要某种模式匹配。把它内置到你的程序中，这样基本上就是告诉它，这里有所有的文件，你只使用与这个模式匹配的文件。

其实这并不难，只要记住你需要逻辑地弄清楚如何编写那部分代码。好吧，你完全可以有任意多个中间文件。嗯，只要记住在最终完成之前删除它们。比如，创建任意多的中间文件，嗯。

然后在你把所有东西处理成最终输出后，删除所有中间文件。除了那些我们希望你保留的文件，确保你做到这一点。所以，如果你愿意，你可以保留它们。我知道在这一点上，某些内容可能还不太理解，因为你还没有真正深入研究这个任务。

但一旦你到达那里，好的，好的。你还有什么问题吗？这是 Mapper 程序，不要害怕它。就像你如果你一开始想到代理，你会想，我该怎么办？

我们会完成所有的任务。这是同样的思路。嗯，步骤很多，我们写了很多，你会逐步走过这些。是的，那么这个是如何运作的呢？计算机崩溃了。这个问题，好的，问题是，等等，怎么解决这个问题？

那么，这个如何能应对计算机崩溃等问题呢？

这个例子不是，但是你可以想象，如果你想让它更健壮。你实际上，嗯，我不确定我们是否已经在其中写了一些这个。如果其中一个任务，比如说没有返回你的值，你会在主程序的主映射中遇到一些超时问题。那是主程序正在执行的地方。最好把它发送到一个不同的地方。

我最好安排一个不同的任务来处理这个问题，因为这个任务似乎在崩溃。对，生成映射本身并不能解决问题。但是，MapReduce 使得解决这个问题变得相对容易，因为现在你有了大量的服务器。你可以并且在进行数据传输。然后你会明白，哦，所有你需要做的基本上就是这样说：哦。

好的，我没有从那个服务器得到任何返回。我最好把这个相同的任务重新指派给其他服务器。然后这就是你如何处理健壮性部分的问题，好的。好的，我们提前几分钟结束，除非还有其他问题。我接下来要回到我的办公室办公，直到大约下午4点。现在是2:19，我在 Gates，我们稍后见。
