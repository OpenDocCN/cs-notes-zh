# 讲座 9

> 原文：[`cs50.harvard.edu/python/notes/9/`](https://cs50.harvard.edu/python/notes/9/)

+   等等

+   `set`

+   全局变量

+   常量

+   类型提示

+   文档字符串

+   `argparse`

+   解包

+   `args` 和 `kwargs`

+   `map`

+   列表推导式

+   `filter`

+   字典推导式

+   `enumerate`

+   生成器和迭代器

+   恭喜！

+   这是 CS50！

## 等等

+   在过去的许多课程中，我们已经涵盖了与 Python 相关的许多内容！

+   在本课中，我们将关注许多之前未讨论的“等等”项目。“Et cetera”字面意思是“等等”。

+   的确，如果你查看 Python 文档，你会找到许多其他功能。

## `set`

+   在数学中，一个集合会被认为是一个没有重复数字的数字集合。

+   在文本编辑器窗口中，按照以下方式编写代码：

    [PRE0]

    注意到我们有一个字典列表，每个字典代表一个学生。创建了一个名为 `houses` 的空列表。我们遍历 `students` 中的每个 `student`。如果一个学生的 `house` 不在 `houses` 中，我们就将其添加到我们的 `houses` 列表中。

+   结果表明，我们可以使用内置的 `set` 功能来消除重复项。

+   在文本编辑器窗口中，按照以下方式编写代码：

    [PRE1]

    注意到我们不需要包含任何检查来确保没有重复项。`set` 对象会自动为我们处理这个问题。

+   你可以在 Python 的文档中了解更多关于 `set` 的信息：[Python 的 `set` 文档](https://docs.python.org/3/library/stdtypes.html#set)。

## 全局变量

+   在其他编程语言中，存在全局变量的概念，这些变量可以被任何函数访问。

+   我们可以利用 Python 中的这一功能。在文本编辑器窗口中，按照以下方式编写代码：

    [PRE2]

    注意到我们如何在任何函数之外创建一个名为 `balance` 的全局变量。

+   由于执行上述代码没有出现错误，你可能会认为一切正常。然而，事实并非如此！在文本编辑器窗口中，按照以下方式编写代码：

    [PRE3]

    注意我们现在添加了向 `balance` 添加和提取资金的功能。然而，执行此代码时，我们遇到了一个错误！我们看到一个名为 `UnboundLocalError` 的错误。你可能能够猜到，至少在我们当前编写的 `balance` 和 `deposit` 以及 `withdraw` 函数的方式中，我们无法在函数内部重新分配它的新值。

+   要在函数内部与全局变量交互，解决方案是使用 `global` 关键字。在文本编辑器窗口中，按照以下方式编写代码：

    [PRE4]

    注意到 `global` 关键字告诉每个函数，`balance` 并不指向一个局部变量：相反，它指向我们在代码顶部最初放置的全局变量。现在，我们的代码可以正常工作了！

+   利用我们从面向对象编程中获得的经验，我们可以修改我们的代码，使用类而不是全局变量。在文本编辑器窗口中，编写以下代码：

    [PRE5]

    注意，我们如何使用 `account = Account()` 来创建一个账户。类允许我们更干净地解决需要全局变量的这个问题，因为这些实例变量可以通过 `self` 访问本类的所有方法。

+   一般而言，全局变量应该非常谨慎地使用，如果必须使用的话！

## 常量

+   一些语言允许您创建不可更改的变量，称为“常量”。常量允许程序员进行防御性编程，并减少重要值被更改的机会。

+   在文本编辑器窗口中，编写以下代码：

    [PRE6]

    注意，在这个例子中，`MEOWS` 是我们的常量。常量通常用大写变量名表示，并放置在代码的顶部。尽管这 *看起来* 像一个常量，但实际上，Python 实际上没有机制来阻止我们在代码中更改该值！相反，您需要遵守诚信原则：如果变量名全部大写，就请不要更改它！

+   您可以创建一个名为“常量”的类，现在我们用引号括起来，因为我们知道 Python 并不完全支持“常量”。在文本编辑器窗口中，编写以下代码：

    [PRE7]

    因为 `MEOWS` 是在任何一个特定类方法之外定义的，所以所有这些方法都可以通过 `Cat.MEOWS` 访问该值。

## 类型提示

+   在其他编程语言中，您需要明确表达您想要使用的变量类型。

+   如我们在课程中较早看到的，Python 不需要显式声明类型。

+   尽管如此，确保所有变量都是正确的类型是一个好的实践。

+   `mypy` 是一个程序，可以帮助您测试以确保所有变量都是正确的类型。

+   您可以通过在终端窗口中执行以下命令来安装 `mypy`：`pip install mypy`。

在文本编辑器窗口中，编写以下代码：

[PRE8]

您可能已经看到，`number = input("Number: )"` 返回了一个 `string`，而不是 `int`。但 `meow` 很可能需要一个 `int`！

+   可以添加类型提示来给 Python 提示 `meow` 应该期望的变量类型。在文本编辑器窗口中，编写以下代码：

    [PRE9]

    注意，尽管如此，我们的程序仍然会抛出错误。

+   安装 `mypy` 后，在终端窗口中执行 `mypy meows.py`。`mypy` 将提供一些关于如何修复此错误的指导。

+   您可以对所有变量进行注释。在文本编辑器窗口中，编写以下代码：

    [PRE10]

    注意，现在 `number` 被提供了一个类型提示。

+   再次强调，在终端窗口中执行 `mypy meows.py` 可以为您提供更具体的反馈。

+   我们可以通过以下方式修复我们的最终错误：

    [PRE11]

    注意，现在运行 `mypy` 没有错误，因为我们已经将输入转换为整数。

+   让我们通过假设 `meow` 将返回一个字符串，或 `str`，来引入一个新的错误。在文本编辑器窗口中，编写以下代码：

    [PRE12]

    注意`meow`函数只有一个副作用。因为我们只尝试打印`meow`，而不是返回一个值，所以当我们尝试将`meow`的返回值存储在`meows`中时，会抛出一个错误。

+   我们还可以进一步使用类型提示来检查错误，这次注释函数的返回值。在文本编辑器窗口中，代码如下：

    [PRE13]

    注意到`-> None`的表示法告诉`mypy`没有返回值。

+   如果我们希望返回一个字符串，我们可以修改我们的代码：

    [PRE14]

    注意我们如何在`meows`中存储多个`str`。运行`mypy`不会产生错误。

+   你可以在 Python 的[Type Hints](https://docs.python.org/3/library/typing.html)文档中了解更多信息。

+   你可以通过程序的自身文档了解更多关于[`mypy`](https://mypy.readthedocs.io/)的信息。

## Docstrings

+   使用 docstring 来注释函数的目的是一种标准做法。在文本编辑器窗口中，代码如下：

    [PRE15]

    注意三个双引号指定了函数的功能。

+   你可以使用 docstrings 来标准化你如何记录函数的特性。在文本编辑器窗口中，代码如下：

    [PRE16]

    注意到包含了多个 docstring 参数。例如，它描述了函数接受的参数以及函数返回的内容。

+   建立的标准工具，如[Sphinx](https://www.sphinx-doc.org/en/master/index.html)，可以用来解析 docstrings，并自动以网页和 PDF 文件的形式为我们创建文档，这样你就可以发布和与他人分享。

+   你可以在 Python 的[docstrings](https://peps.python.org/pep-0257/)文档中了解更多信息。

## `argparse`

+   假设我们想在程序中使用命令行参数。在文本编辑器窗口中，代码如下：

    [PRE17]

    注意`sys`是如何被导入的，通过它我们可以访问到`sys.argv`，这是一个数组，包含了运行程序时提供给我们的命令行参数。我们可以使用多个`if`语句来检查用户是否正确地运行了我们的程序。

+   假设这个程序将会变得更加复杂。我们该如何检查用户可能插入的所有参数呢？如果我们有超过几个命令行参数，我们可能会放弃！

+   幸运的是，`argparse`是一个处理复杂命令行参数字符串解析的库。在文本编辑器窗口中，代码如下：

    [PRE18]

    注意我们是如何导入`argparse`而不是`sys`的。从`ArgumentParser`类创建了一个名为`parser`的对象。该类的`add_argument`方法用于告诉`argparse`，当用户运行我们的程序时，我们应该期望从用户那里得到哪些参数。最后，运行解析器的`parse_args`方法确保用户已经正确地包括了所有参数。

+   我们还可以编写更干净的代码，这样当用户未能正确使用程序时，他们可以获取一些关于我们代码正确使用方法的信息。在文本编辑器窗口中，代码如下：

    [PRE19]

    注意到用户提供了一些文档。具体来说，提供了一个`help`参数。现在，如果用户执行`python meows.py --help`或`-h`，用户将看到一些关于如何使用此程序的提示。

+   我们可以进一步改进这个程序。在文本编辑器窗口中，代码如下：

    [PRE20]

    注意到不仅包含了帮助文档，而且当用户没有提供任何参数时，你还可以提供一个`默认`值。

+   你可以在 Python 的`argparse`文档中了解更多信息。[`argparse`](https://docs.python.org/3/library/argparse.html)。

## 解包

+   不想能够将一个变量分割成两个变量不是很好吗？在文本编辑器窗口中，代码如下：

    [PRE21]

    注意到这个程序尝试通过简单地在一个空格上进行分割来获取用户的名字。

+   结果表明，还有其他方法可以解包变量。通过理解如何以看似更高级的方式解包变量，你可以编写更强大、更优雅的代码。在文本编辑器窗口中，代码如下：

    [PRE22]

    注意到这返回了 Knuts 的总价值。

+   如果我们想要将硬币存储在一个列表中？在文本编辑器窗口中，代码如下：

    [PRE23]

    注意到创建了一个名为`coins`的列表。我们可以通过索引使用`0`、`1`等来传递每个值。

+   这变得相当冗长。如果我们能够简单地将硬币列表传递给我们的函数，不是很好吗？

+   为了使传递整个列表成为可能，我们可以使用解包。在文本编辑器窗口中，代码如下：

    [PRE24]

    注意到`*`如何解包列表的序列，并将每个单独的元素传递给`total`。

+   假设我们可以以任何顺序传递货币的名称？在文本编辑器窗口中，代码如下：

    [PRE25]

    注意到这仍然计算正确。

+   当你开始谈论“名称”和“值”时，字典可能会浮现在你的脑海中！你可以将其实现为一个字典。在文本编辑器窗口中，代码如下：

    [PRE26]

    注意到提供了一个名为`coins`的字典。我们可以使用键，如“galleons”或“sickles”来索引它。

+   由于`total`函数期望三个参数，我们不能传递一个字典。我们可以使用解包来帮助解决这个问题。在文本编辑器窗口中，代码如下：

    [PRE27]

    注意到`**`允许你解包一个字典。在解包字典时，它提供了键和值。

## `args`和`kwargs`

+   回想一下我们在这门课程中之前看到的`print`文档：

    [PRE28]

+   `args`是位置参数，例如我们提供给`print`的`print("Hello", "World")`。

+   `kwargs`是命名参数，或称为“关键字参数”，例如我们提供给`print`的`print(end="")`。

+   正如我们在上面`print`函数的原型中看到的，我们可以告诉我们的函数期望一个目前未知数量的位置参数。我们也可以告诉它期望一个目前未知数量的关键字参数。在文本编辑器窗口中，代码如下：

    [PRE29]

    注意到执行此代码将打印为位置参数。

+   我们甚至可以传递命名参数。在文本编辑器窗口中，编写如下代码：

    [PRE30]

    注意命名值是以字典的形式提供的。

+   考虑到上面的 `print` 函数，你可以看到 `*objects` 可以接受任意数量的位置参数。

+   你可以在 Python 的文档中了解更多关于 `print` 的信息：[print](https://docs.python.org/3/library/functions.html#print)。

## `map`

+   早期，我们开始了过程式编程。

+   我们后来揭示了 Python 是一种面向对象的编程语言。

+   我们看到了函数式编程的暗示，其中函数有副作用但没有返回值。我们可以在文本编辑器窗口中演示，输入 `code yell.py` 并编写如下代码：

    [PRE31]

    注意 `yell` 函数是如何简单地被喊出来的。

+   不想喊一个无限单词的列表吗？修改你的代码如下：

    [PRE32]

    注意我们是如何累积大写单词的，通过迭代每个单词并对它们进行“大写化”。使用 `*` 解包，我们打印出大写列表。

+   移除括号后，我们可以将单词作为参数传递。在文本编辑器窗口中，编写如下代码：

    [PRE33]

    注意 `*words` 如何允许函数接受多个参数。

+   `map` 允许你将函数映射到一系列值。在实践中，我们可以这样编写代码：

    [PRE34]

    注意 `map` 接收两个参数。首先，它接收一个我们想要应用到列表中每个元素的函数。其次，它接收那个列表本身，我们将应用上述函数。因此，`words` 中的所有单词都将传递给 `str.upper` 函数，并返回到 `uppercased`。

+   你可以在 Python 的文档中了解更多关于 `map` 的信息：[map](https://docs.python.org/3/library/functions.html#map)。

## 列表推导式

+   列表推导式允许你在一行优雅的代码中动态创建一个列表。

+   我们可以在我们的代码中如下实现：

    [PRE35]

    注意我们如何没有使用 `map`，而是在方括号内编写 Python 表达式。对于每个参数，`.upper` 都会被应用到它上面。

+   将这个概念进一步扩展，让我们转向另一个程序。

+   在文本编辑器窗口中，输入 `code gryffindors.py` 并编写如下代码：

    [PRE36]

    注意我们在创建列表时有一个条件。*如果*学生的房子是格兰芬多，我们就将学生添加到名字列表中。最后，我们打印出所有的名字。

+   更优雅地，我们可以用列表推导式简化这段代码，如下所示：

    [PRE37]

    注意列表推导式是如何放在一行上的！

## `filter`

+   使用 Python 的 `filter` 函数允许我们返回一个序列的子集，其中某些条件为真。

+   在文本编辑器窗口中，编写如下代码：

    [PRE38]

    注意如何创建一个名为`is_gryffindor`的函数。这是我们用于筛选学生的函数，它将根据学生的学院是否为格兰芬多返回`True`或`False`。你可以看到新的`filter`函数接受两个参数。首先，它接受应用于序列中每个元素的函数——在这个例子中是`is_gryffindor`。其次，它接受要应用筛选函数的序列——在这个例子中是`students`。在`gryffindors`中，我们应该只看到那些在格兰芬多的学生。

+   `filter`也可以使用 lambda 函数如下：

    [PRE39]

    注意提供了相同的学生的列表。

+   你可以在 Python 的`filter`函数文档中了解更多信息[《filter》](https://docs.python.org/3/library/functions.html#filter)。

## 字典推导式

+   我们可以将列表推导式的相同理念应用到字典中。在文本编辑器窗口中，编写如下代码：

    [PRE40]

    注意此代码（目前！）没有使用任何推导式。相反，它遵循我们之前看到的相同范例。

+   我们现在可以通过修改我们的代码来应用字典推导式：

    [PRE41]

    注意所有之前的代码是如何简化成一行，其中为`students`中的每个`student`提供了字典的结构。

+   我们甚至可以进一步简化如下：

    [PRE42]

    注意字典将使用键值对构建。

## `enumerate`

+   我们可能希望为每个学生提供一些排名。在文本编辑器窗口中，编写如下代码：

    [PRE43]

    注意运行此代码时每个学生是如何被列举的。

+   利用枚举，我们可以做到相同：

    [PRE44]

    注意`enumerate`如何展示每个`student`的索引和值。

+   你可以在 Python 的`enumerate`函数文档中了解更多信息[《enumerate》](https://docs.python.org/3/library/functions.html#enumerate)。

## 生成器和迭代器

+   在 Python 中，有一种方法可以防止系统资源耗尽，当它们解决的问题变得太大时。

+   在美国，当人们难以入睡时，习惯于在心中“数绵羊”。

+   在文本编辑器窗口中，输入`code sleep.py`并编写如下代码：

    [PRE45]

    注意这个程序将如何计数你要求其数绵羊的数量。

+   我们可以通过添加一个`main`函数来使我们的程序更加复杂，如下所示：

    [PRE46]

    注意提供了一个`main`函数。

+   我们已经养成了抽象代码部分的习惯。

+   我们可以通过修改我们的代码来调用绵羊函数：

    [PRE47]

    注意`main`函数是如何进行迭代的。

+   我们可以给`sheep`函数提供更多功能。在文本编辑器窗口中，编写如下代码：

    [PRE48]

    注意我们如何创建一群绵羊并返回`flock`。

+   执行我们的代码时，你可以尝试不同的绵羊数量，例如`10`、`1000`和`10000`。如果你要求`1000000`只绵羊，你的程序可能会完全挂起或崩溃。因为你试图生成一个庞大的绵羊列表，你的电脑可能难以完成计算。

+   `yield`生成器可以通过一次返回一小部分结果来解决这个问题。在文本编辑器窗口中，编写如下代码：

    [PRE49]

    注意到`yield`一次只提供单个值，而`for`循环则持续工作。

+   你可以在 Python 的[生成器](https://docs.python.org/3/howto/functional.html#generators)文档中了解更多信息。

+   你可以在 Python 的[迭代器](https://docs.python.org/3/howto/functional.html#iterators)文档中了解更多信息。

## 恭喜你！

+   当你从这门课程退出时，你拥有更多的心理模型和工具箱来解决编程相关的问题。

+   首先，你学习了函数和变量。

+   第二，你学习了条件语句。

+   第三，你学习了循环。

+   第四，你学习了异常。

+   第五，你学习了库。

+   第六，你学习了单元测试。

+   第七，你学习了文件 I/O。

+   第八，你学习了正则表达式。

+   最近，你学习了面向对象编程。

+   今天，你学习了你可以使用的许多其他工具。

## 这就是 CS50！

+   一起创建一个最终程序，在你的终端窗口中输入`code say.py`，并编写如下代码：

    [PRE50]

    注意到运行这个程序为你提供了一个充满活力的告别。

+   我们伟大的希望是，你将利用在这门课程中学到的知识来解决世界上的实际问题，使我们的地球变得更美好。

+   这就是 CS50！
