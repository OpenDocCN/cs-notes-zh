["```\nfrom pomegranate import *\n\n# Rain node has no parents rain = Node(DiscreteDistribution({\n    \"none\": 0.7,\n    \"light\": 0.2,\n    \"heavy\": 0.1\n}), name=\"rain\")\n\n# Track maintenance node is conditional on rain maintenance = Node(ConditionalProbabilityTable([\n    [\"none\", \"yes\", 0.4],\n    [\"none\", \"no\", 0.6],\n    [\"light\", \"yes\", 0.2],\n    [\"light\", \"no\", 0.8],\n    [\"heavy\", \"yes\", 0.1],\n    [\"heavy\", \"no\", 0.9]\n], [rain.distribution]), name=\"maintenance\")\n\n# Train node is conditional on rain and maintenance train = Node(ConditionalProbabilityTable([\n    [\"none\", \"yes\", \"on time\", 0.8],\n    [\"none\", \"yes\", \"delayed\", 0.2],\n    [\"none\", \"no\", \"on time\", 0.9],\n    [\"none\", \"no\", \"delayed\", 0.1],\n    [\"light\", \"yes\", \"on time\", 0.6],\n    [\"light\", \"yes\", \"delayed\", 0.4],\n    [\"light\", \"no\", \"on time\", 0.7],\n    [\"light\", \"no\", \"delayed\", 0.3],\n    [\"heavy\", \"yes\", \"on time\", 0.4],\n    [\"heavy\", \"yes\", \"delayed\", 0.6],\n    [\"heavy\", \"no\", \"on time\", 0.5],\n    [\"heavy\", \"no\", \"delayed\", 0.5],\n], [rain.distribution, maintenance.distribution]), name=\"train\")\n\n# Appointment node is conditional on train appointment = Node(ConditionalProbabilityTable([\n    [\"on time\", \"attend\", 0.9],\n    [\"on time\", \"miss\", 0.1],\n    [\"delayed\", \"attend\", 0.6],\n    [\"delayed\", \"miss\", 0.4]\n], [train.distribution]), name=\"appointment\") \n```", "```\n# Create a Bayesian Network and add states model = BayesianNetwork()\nmodel.add_states(rain, maintenance, train, appointment)\n\n# Add edges connecting nodes model.add_edge(rain, maintenance)\nmodel.add_edge(rain, train)\nmodel.add_edge(maintenance, train)\nmodel.add_edge(train, appointment)\n\n# Finalize model model.bake() \n```", "```\n# Calculate probability for a given observation probability = model.probability([[\"none\", \"no\", \"on time\", \"attend\"]])\n\nprint(probability) \n```", "```\n# Calculate predictions based on the evidence that the train was delayed predictions = model.predict_proba({\n    \"train\": \"delayed\"\n})\n\n# Print predictions for each node for node, prediction in zip(model.states, predictions):\n    if isinstance(prediction, str):\n        print(f\"{node.name}: {prediction}\")\n    else:\n        print(f\"{node.name}\")\n        for value, probability in prediction.parameters[0].items():\n            print(f\"  {value}: {probability:.4f}\") \n```", "```\nimport pomegranate\n\nfrom collections import Counter\n\nfrom model import model\n\ndef generate_sample():\n\n    # Mapping of random variable name to sample generated\n    sample = {}\n\n    # Mapping of distribution to sample generated\n    parents = {}\n\n    # Loop over all states, assuming topological order\n    for state in model.states:\n\n        # If we have a non-root node, sample conditional on parents\n        if isinstance(state.distribution, pomegranate.ConditionalProbabilityTable):\n            sample[state.name] = state.distribution.sample(parent_values=parents)\n\n        # Otherwise, just sample from the distribution alone\n        else:\n            sample[state.name] = state.distribution.sample()\n\n        # Keep track of the sampled value in the parents mapping\n        parents[state.distribution] = sample[state.name]\n\n    # Return generated sample\n    return sample \n```", "```\n# Rejection sampling\n# Compute distribution of Appointment given that train is delayed N = 10000\ndata = []\n\n# Repeat sampling 10,000 times for i in range(N):\n\n    # Generate a sample based on the function that we defined earlier\n    sample = generate_sample()\n\n    # If, in this sample, the variable of Train has the value delayed, save the sample. Since we are interested interested in the probability distribution of Appointment given that the train is delayed, we discard the sampled where the train was on time.\n    if sample[\"train\"] == \"delayed\":\n        data.append(sample[\"appointment\"])\n\n# Count how many times each value of the variable appeared. We can later normalize by dividing the results by the total number of saved samples to get the approximate probabilities of the variable that add up to 1. print(Counter(data)) \n```", "```\nfrom pomegranate import *\n\n# Define starting probabilities start = DiscreteDistribution({\n    \"sun\": 0.5,\n    \"rain\": 0.5\n})\n\n# Define transition model transitions = ConditionalProbabilityTable([\n    [\"sun\", \"sun\", 0.8],\n    [\"sun\", \"rain\", 0.2],\n    [\"rain\", \"sun\", 0.3],\n    [\"rain\", \"rain\", 0.7]\n], [start])\n\n# Create Markov chain model = MarkovChain([start, transitions])\n\n# Sample 50 states from chain print(model.sample(50)) \n```", "```\nfrom pomegranate import *\n\n# Observation model for each state sun = DiscreteDistribution({\n    \"umbrella\": 0.2,\n    \"no umbrella\": 0.8\n})\n\nrain = DiscreteDistribution({\n    \"umbrella\": 0.9,\n    \"no umbrella\": 0.1\n})\n\nstates = [sun, rain]\n\n# Transition model transitions = numpy.array(\n    [[0.8, 0.2], # Tomorrow's predictions if today = sun\n     [0.3, 0.7]] # Tomorrow's predictions if today = rain )\n\n# Starting probabilities starts = numpy.array([0.5, 0.5])\n\n# Create the model model = HiddenMarkovModel.from_matrix(\n    transitions, states, starts,\n    state_names=[\"sun\", \"rain\"]\n)\nmodel.bake() \n```", "```\nfrom model import model\n\n# Observed data observations = [\n    \"umbrella\",\n    \"umbrella\",\n    \"no umbrella\",\n    \"umbrella\",\n    \"umbrella\",\n    \"umbrella\",\n    \"umbrella\",\n    \"no umbrella\",\n    \"no umbrella\"\n]\n\n# Predict underlying states predictions = model.predict(observations)\nfor prediction in predictions:\n    print(model.states[prediction].name) \n```"]