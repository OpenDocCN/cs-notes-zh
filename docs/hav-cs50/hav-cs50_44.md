# 第 6 讲

> 原文：[`cs50.harvard.edu/r/notes/6/`](https://cs50.harvard.edu/r/notes/6/)

+   欢迎！

+   异常

+   信息

+   `警告`（`warning`）

+   `停止`（`stop`）

+   单元测试

+   testthat

+   浮点数测试（`testing-floating-point-values`）

+   `容忍度`（`tolerance`）

+   测试驱动开发

+   行为驱动开发

+   测试覆盖率

+   总结

## 欢迎！

+   欢迎回到 CS50 的 R 语言编程入门课程！

+   今天，我们将学习关于程序测试的内容。我们将了解程序可能会出错的地方，当它们出错时我们如何处理，以及如何系统地测试我们的程序以确保它们按预期运行！

## 异常

+   考虑以下计算平均值的程序：

    [PRE0]

    注意这个程序尝试将其输入作为一个数字向量，并输出平均值。

+   你可以想象用户可能会意外地传递字符而不是数字，导致我们的`average`函数输出错误。

+   这些错误被称为*异常*。有没有可能检查潜在的这种异常呢？考虑以下对`average`的更新：

    [PRE1]

    注意一个条件语句，一个`if`语句，是如何检查向量`x`是否不全是数字。在 R 世界的惯例中，在这种情况下返回一个值`NA`是合适的。

## `信息`（`message`）

+   虽然这允许我们的程序无声运行，但我们可能希望让用户知道发生了异常。一种通知用户的方式是通过`message`函数：

    [PRE2]

    注意程序返回`NA`的原因是通过`message`发送给用户的。

+   传统上，`message`是在没有出错时使用的：`message`纯粹是信息性的。因此，我们可以通过`warning`提升这条信息的重要性。

## `警告`（`warning`）

+   我们可以将我们的`message`的重要性提升到`warning`，如下所示：

    [PRE3]

    注意现在输出的是一个警告信息。

+   一个`warning`不会完全停止程序，但它确实让程序员知道出了问题。

## `停止`（`stop`）

+   你可以想象一些情况，你并不只是想警告用户；你可能想完全停止函数。考虑以下：

    [PRE4]

    注意`stop`告诉用户，由于他们提供的输入，我们无法继续。

+   也可以将两种可能性结合起来。例如，以下代码检查了`x`包含非数字元素的情况。同样，此代码也适应了存在`NA`值的情况：

    [PRE5]

    注意提供了两个`if`语句。

## 单元测试

+   *单元测试*用于测试我们的函数和程序。

+   考虑以下在单独文件中对`average`进行的测试函数：

    [PRE6]

    注意到这个函数提供了一个测试案例，其中将数字 `1`、`2` 和 `3` 传递给 `average` 函数。然后，提供了一些反馈。注意在第一行，`source` 确保这个测试文件可以访问 `average` 函数。

+   测试负数也是明智之举：

    [PRE7]

    注意到为正数、负数和零提供了额外的测试。

+   我们已经编写了 21 行代码！幸运的是，程序员已经创建了各种测试包或库，可以用来测试我们的代码。

## testthat

+   testthat 是一个用于测试 R 代码的包。可以通过在控制台中输入 `library(testthat)` 来加载。

+   testthat 包含一个名为 `test_that` 的函数，可以用来测试我们的函数：

    [PRE8]

    注意到 `test_that` 函数可以指示期望各种数字的平均值等于某个特定值，这要归功于 `expect_equal`。同样，我们也可以向 `test_that` 函数提供指令以 `expect_warning`，当平均计算包含 `NA` 值时。此外，注意测试被分为不同的部分。一个部分测试平均值的计算，而另一个部分测试警告。

+   运行上述测试，我们发现我们的`average`函数中`if`语句的顺序可能是不正确的：

    [PRE9]

    注意到条件语句的顺序被改变了。

+   我们应该测试`average`在输入为`NA`值时返回`NA`，而不仅仅是`average`会引发警告！

    [PRE10]

    注意到我们有两个独立的测试，将 `NA` 值作为输入传递给 `average`。一个测试正确的返回值，而另一个测试会引发一个 `warning`。

+   `test_that` 有其他函数可以帮助我们进行测试，包括 `expect_error` 和 `expect_no_error`。

+   使用 `expect_error` 我们可以修改我们的代码如下：

    [PRE11]

    注意到当输入是“quack！”或提供字符而不是数字时，代码期望出现错误。

## 测试浮点值

+   我们可能希望将浮点值（即十进制值）作为输入传递给 `average`：

    [PRE12]

    注意到在第一组测试的末尾添加了一个浮点值的测试。

## 容忍度

+   浮点值是独特的，因为它们受到浮点数不精确性的影响。

+   让我们通过例子来理解浮点数的不精确性：

    [PRE13]

    注意到在 R 中，0.3 并不是精确地表示为 0.3。这是编程语言中常见的现象，因为存在无限多的浮点值和有限的位数来表示它们。

+   由于浮点数的不精确性，涉及浮点值的等式测试需要允许一定的*容忍度*。容忍度指的是一个范围，即高于或低于预期值，将被视为与预期值相等。容忍度通常以绝对值指定，例如 ± .000001。

+   `expect_equal` 函数已经提供了一种通常适用于大多数用例的容差级别。这个默认值可以通过 `tolerance` 参数进行更改。

+   你和你的团队应该决定在计算中期望的精度水平。

## 测试驱动开发

+   一种开发哲学被称为 *测试驱动开发*。在这种思维模式下，人们认为在编写将被测试的源代码之前先创建一个测试是最好的。考虑以下测试：

    [PRE14]

    注意你可以想象一个 `greet` 函数应该能够问候作为输入的用户。

+   观察这个测试，我们可以编写响应测试的代码：

[PRE15]

注意这段代码是如何通过用户名向用户打招呼的。

+   在测试驱动开发中，编写测试让程序员知道他们应该实现哪些功能。好处是这些功能随后可以立即进行测试。进一步的修改应该始终通过已经编写的测试。

## 行为驱动开发

+   *行为驱动开发* 在精神上与测试驱动开发相似，但更侧重于函数在上下文中的行为。在行为驱动开发中，人们可能会通过明确命名函数应该做什么来描述我们希望函数执行的操作。

+   testthat 包含两个函数来实现行为驱动开发，`describe` 和 `it`：

    [PRE16]

    注意 `describe` 包含了几个基于代码的描述，说明了 `it`（该函数！）应该能够做什么。

## 测试覆盖率

+   当你开始为你的代码编写测试时，考虑这些测试的全面性。定义出你的代码需要完成的关键任务，并创建体现这些关键任务的测试。

## 总结

在本课中，你学习了如何在 R 中测试程序。具体来说，你学习了以下内容：

+   异常

+   `message`

+   `warning`

+   `stop`

+   单元测试

+   testthat

+   测试浮点值

+   容差

+   测试驱动开发

+   行为驱动开发

+   测试覆盖率

次次见，届时我们将能够打包我们的代码并与世界分享。
