# 第 1 讲

> 原文：[`cs50.harvard.edu/python/notes/1/`](https://cs50.harvard.edu/python/notes/1/)

+   条件语句

+   if 语句

+   控制流、elif 和 else

+   或

+   且

+   取模

+   创建我们自己的奇偶函数

+   Pythonic

+   match

+   总结

## 条件语句

+   条件语句允许你，作为程序员，让你的程序做出决定：就像你的程序根据某些条件在左边的路或右边的路之间做出选择。

+   条件语句允许你的程序做出决定，根据指定的条件选择一条路径而不是另一条路径。

+   Python 内置了一套“运算符”，用于提出数学问题。

+   `>` 和 `<` 符号你可能很熟悉。

+   `>=` 表示“大于或等于”。

+   `<=` 表示“小于或等于”。

+   `==` 表示“等于”。注意双等号：单个等号用于赋值，而两个等号用于比较值。

+   `!=` 表示“不等于”。

+   条件语句比较左边的项与右边的项。

## if 语句

+   在你的终端窗口中，键入 `code compare.py`。这将创建一个名为“compare”的新文件。

+   在文本编辑器窗口中，开始如下：

    [PRE0]

    注意你的程序如何接受用户对 x 和 y 的输入，将它们作为整数转换并保存到各自的 x 和 y 变量中。然后，`if` 语句比较 x 和 y。如果满足 `x < y` 的条件，则执行 `print` 语句。

+   `if` 语句使用 `bool`（布尔）值（`True` 或 `False`）来决定是否执行代码。如果比较 `x > y` 的结果是 `True`，解释器将运行缩进的代码块。

## 控制流、elif 和 else

+   进一步修改你的代码如下：

    [PRE1]

    注意你提供了一系列 `if` 语句。首先，评估第一个 `if` 语句。然后，执行第二个 `if` 语句的评估。最后，执行最后一个 `if` 语句的评估。这种决策流程称为“控制流”。

+   我们的代码可以表示如下：

    [PRE2]

+   这个程序可以通过不连续问三个问题来改进。毕竟，不是所有三个问题都能得到 `true` 的结果！按照以下方式修改你的程序：

    [PRE3]

    注意 `elif` 的使用如何使程序做出更少的决策。首先，评估 `if` 语句。如果这个语句被评估为真，则不会运行所有的 `elif` 语句。然而，如果 `if` 语句被评估并发现为假，则第一个 `elif` 将被评估。如果是真的，它将不会运行最终的评估。

+   我们的代码可以表示如下：

    [PRE4]

+   虽然你的电脑可能在速度上没有注意到我们的第一个程序和这个修订程序之间的差异，但考虑一下，一个每天运行数十亿或数万亿此类计算的在线服务器，这样的小代码决策肯定会有影响。

+   我们可以对我们的程序进行最后一次改进。注意 `elif x == y` 在逻辑上不是必须的评估。毕竟，如果逻辑上 x 不小于 y 且 x 不大于 y，那么 x 一定等于 y。因此，我们不需要运行 `elif x == y`。我们可以使用 `else` 语句创建一个“通配符”，默认结果。我们可以这样修改：

    [PRE5]

    注意到通过我们的修订，这个程序的相对复杂性已经降低。

+   我们的代码可以表示如下：

    [PRE6]

## 或

+   `or` 允许程序在一种或多种选择之间做出决定。例如，我们可以进一步编辑我们的程序如下：

    [PRE7]

    注意到我们的程序结果相同，但复杂性降低。代码的效率提高了。

+   到目前为止，我们的代码相当不错。然而，设计是否可以进一步改进？我们可以进一步编辑我们的代码如下：

    [PRE8]

    注意到我们完全移除了 `or`，只是简单地问，“x 是否不等于 y？”我们只问一个问题。非常高效！

+   为了说明，我们也可以将代码修改如下：

    [PRE9]

    注意到 `==` 操作符用于判断左边的值和右边的值是否相等。使用双等号非常重要。如果你只使用一个等号，解释器可能会抛出一个错误。

+   我们可以将代码表示如下：

    [PRE10]

## 和

+   与 `or` 类似，`and` 也可以在条件语句中使用。

+   在终端窗口中执行 `code grade.py`。启动你的新程序如下：

    [PRE11]

    注意到通过执行 `python grade.py`，你将能够输入一个分数并得到一个等级。然而，请注意这里存在潜在的错误。

+   通常，我们不想让用户输入正确信息。我们可以这样改进我们的代码：

    [PRE12]

    注意到 Python 允许你以其他编程语言中相当不常见的方式链接着操作符和条件。

+   尽管如此，我们还可以进一步改进我们的程序：

    [PRE13]

    注意到通过减少问题数量，程序得到了改进。这使得我们的程序更容易阅读，并且在未来的维护中更加高效。

+   你可以在 Python 的文档中了解更多关于[控制流](https://docs.python.org/3/tutorial/controlflow.html)的信息。

## 取模

+   在数学中，奇偶性指的是一个数是偶数还是奇数。

+   编程中的取模 `%` 操作符允许你查看两个数是否能够整除，或者除后是否有余数。

+   例如，4 % 2 的结果将是零，因为它可以整除。然而，3 % 2 不能整除，结果将是一个非零的数字！

+   在终端窗口中，通过输入 `code parity.py` 创建一个新的程序。在文本编辑器窗口中，输入以下代码：

    [PRE14]

    注意我们的用户可以输入任何大于等于 1 的数字来查看它是否为偶数或奇数。

## 创建我们自己的偶奇函数

+   如在讲座 0 中讨论的，你会发现创建自己的函数很有用！

+   我们可以创建自己的函数来检查一个数字是否为偶数或奇数。按照以下方式调整你的代码：

    [PRE15]

    注意到我们的`if`语句`is_even(x)`即使没有操作符也能正常工作。这是因为我们的函数返回一个`bool`（布尔值），`True`或`False`，并将其返回给主函数。`if`语句只是简单地评估`x`的`is_even`是否为真或假。

## Pythonic

+   在编程世界中，有一些编程类型被称为“Pythonic”的编程。也就是说，有一些编程方式只在 Python 编程中看到。考虑以下程序的修订版：

    [PRE16]

    注意到我们代码中的这个返回语句几乎就像一个英文句子。这是仅在 Python 中才能看到的独特编码方式。

+   我们可以进一步修改代码，使其更加易读：

    [PRE17]

    注意程序将评估`n % 2 == 0`的结果，将其视为`True`或`False`，并将其简单地返回给主函数。

## `match`

+   与`if`、`elif`和`else`语句类似，`match`语句可以用来有条件地运行与某些值匹配的代码。

+   考虑以下程序：

    [PRE18]

    注意前三个条件语句打印了相同的响应。

+   我们可以使用`or`关键字稍微改进这段代码：

    [PRE19]

    注意`elif`语句的数量减少了，这提高了代码的可读性。

+   或者，我们可以使用`match`语句将名称映射到房屋。考虑以下代码：

    [PRE20]

    注意到最后一个情况中使用了`_`符号。这将与任何输入匹配，产生类似于`else`语句的行为。

+   匹配语句将`match`关键字后面的值与`case`关键字后面的每个值进行比较。如果在事件中找到匹配项，则执行相应的缩进代码部分，程序停止匹配。

+   我们可以改进代码：

    [PRE21]

    注意，使用了单个竖线`|`。与`or`关键字类似，这允许我们在同一个`case`语句中检查多个值。

## 总结

现在，你可以在 Python 中使用条件语句来提问，并让程序相应地采取行动。在本讲座中，我们讨论了…

+   条件语句；

+   `if`语句；

+   控制流程，`elif`和`else`；

+   `or`；

+   `and`；

+   取模；

+   创建你自己的函数；

+   Pythonic 编码；

+   和`match`。
