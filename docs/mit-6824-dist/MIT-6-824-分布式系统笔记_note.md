# MIT 6.824 分布式系统笔记：第1课 - 介绍 🚀

在本节课中，我们将要学习分布式系统的基本概念、其重要性以及面临的挑战。我们将探讨为什么需要构建分布式系统，并初步了解其核心设计目标。

## 什么是分布式系统？

分布式系统由多个通过网络连接的计算机组成。这些计算机协同工作，以完成一个共同的目标。它们呈现给用户的印象是一个单一、连贯的系统。

## 为什么需要分布式系统？

构建分布式系统主要出于三个原因。

*   **性能/并行性**：通过多台机器并行处理任务，可以显著提升计算能力与速度。
*   **容错性**：系统的一部分出现故障时，其他部分可以继续工作，从而提高了整体可靠性。
*   **物理原因**：不同组件或用户本身在地理上就是分布的，例如银行的各个分行。
*   **安全性/隔离性**：通过将不同部分运行在独立的机器上，可以实现更好的安全隔离。

## 面临的挑战

尽管分布式系统优势明显，但其设计也面临诸多困难。

*   **并发执行**：许多事情会同时发生，需要复杂的协调机制。
*   **局部故障**：系统中的部分组件可能独立于其他部分发生故障。
*   **性能瓶颈**：网络延迟和带宽限制可能成为系统性能的瓶颈。

上一节我们介绍了分布式系统的定义与挑战，本节中我们来看看实现分布式系统时追求的核心目标。

## 分布式系统的目标

设计良好的分布式系统通常致力于实现以下几个关键目标。

*   **可扩展性**：随着机器数量的增加，系统的性能应能线性提升。
*   **高可用性**：系统应能在部分故障时继续提供服务，通常通过**复制（Replication）** 技术实现。
*   **强一致性**：尽管存在复制和并发，系统应表现得像单一机器一样，这是最理想但最难实现的目标。

---

接下来，我们将通过一个核心概念来理解分布式系统中的数据一致性。

## 核心概念：可线性化（Linearizability）

可线性化（或称强一致性）是分布式系统中最强的一致性模型。它要求系统表现得好像所有操作都在某个单一副本上原子性地、按顺序执行，并且这个顺序与真实时间顺序一致。

简单来说，对于任何一系列读写操作，存在一个全局的、线性的顺序，这个顺序符合每个操作的真实发生时间，并且读操作总能读到最新写入的值。

我们可以通过以下伪代码描述一个可线性化的键值存储的写操作逻辑：

```go
func Put(key, value) {
    // 1. 为操作生成全局唯一且递增的时间戳（或序列号）
    timestamp = generate_monotonic_timestamp()
    // 2. 将 (key, value, timestamp) 同步复制到大多数副本
    replicate_to_majority(key, value, timestamp)
    // 3. 确认成功后，操作才被视为完成
    return success
}
```

而读操作则需要读取已提交的最新数据：

```go
func Get(key) {
    // 1. 向所有副本查询该key的最新已提交数据
    latest_data = query_all_replicas_for_latest(key)
    // 2. 确保读取到的数据是已达成多数派共识的
    ensure_data_is_committed(latest_data)
    // 3. 返回该数据
    return latest_data.value
}
```

这种模型对编程者非常友好，但为了实现它，通常需要付出性能代价，例如使用同步通信和共识算法。

---

本节课中我们一起学习了分布式系统的基础：它的定义、构建原因、主要挑战和设计目标。我们重点探讨了**可线性化**这一强一致性模型，它要求分布式系统像单机一样运作。理解这些基本概念是深入后续课程中关于复制、容错和一致性协议等内容的重要基石。在接下来的课程中，我们将看到为了在现实约束下平衡这些目标，系统设计者所做出的各种权衡。