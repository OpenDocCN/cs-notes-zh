# 课程 P19：第 18 讲 - Fork 一致性与 SUNDR 🛡️

在本节课中，我们将要学习去中心化系统中的一个核心概念：如何在没有单一可信中心的情况下，构建一个能抵御恶意（拜占庭式）参与者的文件系统。我们将重点探讨 SUNDR 系统提出的 **Fork 一致性** 模型及其背后的关键技术——**签名日志**。

## 概述：去中心化与拜占庭威胁

去中心化系统意味着没有单一权威机构控制整个系统。这与我们之前讨论的、所有参与者都在单一可信机构控制下的系统（如 Raft）有本质不同。在去中心化环境中，参与者可能是**拜占庭式**的：他们有时遵守协议，有时则可能为了自身利益而欺骗、破坏系统。这使得系统设计更具挑战性，因为它位于分布式系统与安全领域的交汇点，需要借助密码学工具（如签名和哈希）来保障安全。

SUNDR 这篇论文虽然未直接投入实际应用，但它提出的 **签名日志** 思想极具影响力，后续出现在 Git、比特币等众多系统中。

## 背景与动机：为何需要 SUNDR？

SUNDR 的设定是一个网络文件系统，类似于我们之前学过的 Frangipani。不同之处在于，SUNDR 假设**文件服务器本身可能是恶意的（拜占庭式）**。这种威胁模型非常强大，涵盖了诸如利用软件漏洞获取控制权、物理入侵机器、贿赂管理员等多种现实攻击场景。

论文的一个核心动机是防止软件仓库被篡改。例如，2003年 Debian Linux 的开发服务器曾被入侵，攻击者植入了后门。发现后，开发者不得不花费数天时间从备份中甄别哪些文件被篡改，导致开发进程冻结。SUNDR 旨在解决此类问题，确保文件系统的**完整性**（即数据未被非法修改），而非保密性。

让我们通过一个具体例子来理解问题。假设三位开发者 A、B、C 合作开发一个银行应用 `zoobar`：
*   A 负责修改 `auth.py`，以支持 MIT 证书认证。
*   B 负责修改 `bank.py`，将其与真实支付系统 `TechCash` 对接。
*   C 负责最终部署软件。

如果文件服务器被攻陷（成为拜占庭式），可能发生两种攻击：
1.  **结果1**：服务器直接篡改 `auth.py` 或 `bank.py` 的内容。
2.  **结果2（更微妙）**：服务器有选择性地只向 C 提供 B 修改的新版 `bank.py`，同时提供 A 未修改的旧版 `auth.py`。这样，支付系统已上线，但用户认证却失效了，造成严重安全漏洞且难以察觉。

## 初始方案：简单的文件签名及其不足

一个简单的起点是让每个文件修改者对自己的文件进行数字签名。例如，A 修改 `auth.py` 后，用其私钥对文件内容生成签名。C 下载文件时，用 A 的公钥验证签名，从而确认文件确实来自 A 且未被篡改。

这个方案可以抵御直接的篡改攻击（结果1），但存在严重缺陷：
*   服务器可以发送一个完全不同的文件，并谎称它是 `auth.py`（可通过在签名中包含文件名修复）。
*   服务器可以发送旧版本的文件，因为签名只认证文件内容，不认证其“新鲜度”。
*   服务器可以有选择性地展示文件（例如，只展示新版 `bank.py` 而隐藏新版 `auth.py`），因为文件之间没有关联。
*   服务器可以声称某个文件不存在。

![](img/e46c8c173a752e54c8649c4660dc2571_1.png)

核心问题在于，简单的文件签名无法提供**文件系统的一致性全局视图**，客户端无法判断自己看到的是否是所有文件的最新、完整状态。

## 核心思想：签名操作日志 📝

![](img/e46c8c173a752e54c8649c4660dc2571_3.png)

SUNDR 论文提出了一个强大的核心思想：对文件系统的**操作日志进行签名**。这个日志不仅记录修改操作，也记录读取（获取）操作。

每个日志条目都包含当前操作（例如“A 修改了 auth.py”）以及**之前所有日志条目的加密哈希值**。当用户对条目签名时，签名覆盖的正是这个“当前操作+历史哈希”的组合。

用伪代码表示日志条目 `i` 的结构：
```python
LogEntry[i] = {
    operation: “Modify auth.py by A”，
    prev_hash: Hash(LogEntry[i-1])， // 前一个条目的哈希
    signature: Sign(operation + prev_hash， private_key_of_A)
}
```

这种设计带来了关键优势：**服务器无法在不被察觉的情况下删除或重排日志中间的条目**。因为后续条目的签名依赖于被删除条目的哈希值，任何篡改都会导致签名验证失败。

## 包含“获取”操作的重要性

上一节我们介绍了签名日志的概念，本节中我们来看看为什么读取（获取）操作也必须被记录在日志中。

假设日志中不记录获取操作。考虑以下攻击序列：
1.  C 请求获取 `auth.py`。恶意服务器可以返回一个**不包含 A 和 B 修改操作**的日志前缀，以及旧的 `auth.py` 文件。C 验证这个前缀签名有效，且包含自己之前的操作，因此接受并安装了旧版 `auth.py`。
2.  随后，C 请求获取 `bank.py`。这次服务器返回**完整的日志**（包含 A 和 B 的修改）。C 验证通过，构建文件系统视图，得到了新版 `bank.py`。

从 C 的视角看，A 和 B 的修改似乎是与它的两次读取**同时发生**的。它无法察觉自己先读到了旧版 `auth.py`，后读到了新版 `bank.py`，从而落入了“结果2”的攻击陷阱。

如果将获取操作也签名并加入日志，情况则不同：
1.  C 获取 `auth.py` 后，会在日志中追加一个“C 获取了 auth.py”的签名条目，并上传给服务器。
2.  当 C 再次获取 `bank.py` 时，服务器返回的日志**必须包含** C 刚才的获取记录。如果服务器试图返回一个不包含 A 修改的日志前缀，那么这个前缀里自然也不会有 C 的获取记录，C 会因找不到自己的最后操作而拒绝该日志。

因此，记录获取操作是防止服务器向客户端呈现不一致历史视图的关键。

![](img/e46c8c173a752e54c8649c4660dc2571_5.png)

## Fork 一致性：能力与极限

![](img/e46c8c173a752e54c8649c4660dc2571_7.png)

尽管签名日志非常强大，但它仍然无法阻止一种特定的攻击：**服务器可以对世界进行“分叉”**。

由于服务器是唯一存储和分发日志的实体，它可以这样做：
*   为客户端 A 维护并展示一条日志分支。
*   同时，为客户端 B 维护并展示另一条不同的日志分支。
*   只要这两个分支从某个点分叉后就不再合并，并且分别满足签名链的连续性，那么 A 和 B 各自看到的都是一个内部一致但彼此不同的文件系统视图。

这就是 **Fork 一致性**。它是 SUNDR 在恶意服务器模型下所能提供的最强一致性保证。服务器无法回滚单个客户端的视图（因为客户端会检查自己最后的操作是否在日志中），但它可以创造多个并行演进的分支。

那么，如何检测这种分叉呢？论文提出了两种方法：
1.  **带外通信**：客户端之间直接通信，交换各自看到的最后一条日志条目哈希。如果发现不一致，则表明可能发生了分叉。
2.  **引入可信时间戳服务**：一个受信任的第三方定期向日志中写入带时间戳的条目。由于所有客户端都期望看到连续的时间戳，服务器就很难在不被发现的情况下维持长时间的分叉。

## SUNDR 的实际实现：版本向量与快照

上一节我们探讨了概念上的签名日志，本节中我们来看看 SUNDR 如何高效地实现这一思想。实际上，SUNDR 并不维护一个从头开始的完整物理日志，而是为每个用户维护一个文件系统状态的**快照**，并使用**版本向量**来协调不同用户的视图。

以下是其核心机制：

*   **i-handle（用户快照）**：每个用户都有一个 `i-handle`，它是其当前文件系统视图的加密哈希。这个哈希实际上是一个 Merkle 树的根哈希，该树涵盖了用户可见的所有文件和目录的元数据及内容哈希。任何文件修改都会导致 `i-handle` 更新。
*   **版本向量**：每个用户的快照都关联一个**版本向量**。这是一个计数器数组，记录了该用户所见到的、由其他每个用户执行的修改操作次数。版本向量本身也被用户签名。

其工作流程简化如下：
1.  A 修改 `auth.py` 后，计算新的 `i-handle_A`，并更新版本向量（例如，将 A 自己的计数器加1）。然后对新的 `i-handle` 和版本向量签名。
2.  B 修改 `bank.py` 时，会先获取 A 的最新版本向量和 `i-handle`。然后基于此计算自己的新 `i-handle_B`，并更新版本向量（将 A 的计数器和 B 自己的计数器都更新到最新值），最后签名。
3.  当 C 读取文件时，它会下载所有用户（A 和 B）最新的、已签名的版本向量和 `i-handle`。通过比较版本向量，C 可以确定哪个视图包含了所有已知的最新修改（例如 B 的视图），然后基于该视图的 `i-handle` 来读取文件。

这种设计同样能防止服务器隐藏修改：如果服务器想向 C 隐藏 A 的修改，它只能提供旧的、不包含 A 修改的版本向量和 `i-handle`。但这样一来，它也无法提供 B 基于 A 修改后产生的新 `i-handle`，因为 B 的签名版本向量证明了它看到了 A 的修改。因此，C 总能检测到视图的不一致。

## 总结

本节课我们一起学习了在去中心化系统中应对拜占庭式服务器的挑战。SUNDR 系统的核心贡献在于提出了 **Fork 一致性** 模型以及实现它的关键技术——**签名日志**。我们了解到：

1.  简单的文件签名不足以防御恶意服务器有选择性地展示文件状态。
2.  将**所有操作（包括读取）** 记录在一个前后哈希关联、并经过签名的日志中，可以防止服务器篡改或隐藏历史。
3.  即使如此，服务器仍能创建不同的日志分支，导致 **Fork 一致性**。客户端需要通过带外通信或可信时间戳来检测分叉。
4.  SUNDR 通过**版本向量**和基于 **Merkle 树**的用户快照（`i-handle`）来高效实现签名日志的语义，确保用户能获得一个包含所有已知修改的一致文件系统视图。

![](img/e46c8c173a752e54c8649c4660dc2571_9.png)

签名日志的思想影响深远，为比特币等区块链系统奠定了基础。在下节课中，我们将看到比特币如何利用类似的技术，并通过共识算法来解决 Fork 一致性问题。