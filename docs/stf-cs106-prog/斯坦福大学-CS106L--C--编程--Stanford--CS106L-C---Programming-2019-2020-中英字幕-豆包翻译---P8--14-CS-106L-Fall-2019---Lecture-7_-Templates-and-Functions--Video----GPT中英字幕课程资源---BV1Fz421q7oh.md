# 斯坦福大学《CS106L： C++编程｜ Stanford  CS106L C++ Programming 2019+2020》中英字幕（豆包翻译 - P8：[14]CS 106L Fall 2019 - Lecture 7_ Templates and Functions (Video) - GPT中英字幕课程资源 - BV1Fz421q7oh

你可能会问，好吧，我怎么编译代码？我怎么运行代码？要编译代码，你可以选择你想使用的编译器。我想使用 G++，所以我会输入 G++。这指定了我想运行的程序。然后我会给它提供几个标志。记住之前的内容。

标志就像是参数。你可以准确指定你想让程序如何运行。我将指定我想要 STD，即哪个版本。我想要 C++17 或 20。然后在这里指定你想编译的文件。我想跳过编译文件的长而复杂的过程。

我们只是做一些简单的事情，我们将使用标志。编译后，发生的事情是它会将 CPP 文件转换为一个可以运，行的二进制文件。我将把二进制文件命名为 HelloWorld。G++ 意味着我想使用编译器 G++。

STD17，破折号 STD 等于 C++17，意味着我想使用 C++17 ，标准。HelloWorld 是我想编译的文件。破折号，你不必过多了解这一点，但编译过程有很多阶段。我只是让它跳过所有内容。

我只想编译文件并给我二进制可执行文件。所以只需在这里添加破折号。然后 HelloWorld 是输出，即我们的二进制文件名称。然后我运行它。一旦你运行它，如果你再点击一次 LS，你会看到有一个 。

HelloWorld 二进制文件。基本上发生的是编译器把 HelloWorld CPP 文件变成了一，个可执行文件。如果我运行这个可执行文件，它就像你下载的任何可执行，文件一样。如果你运行可执行文件。

那么会弹出一些东西，并运行程序， HelloWorld。如果你想从终端运行程序，你需要指定你想运行的目录，即，然后我们说斜杠 HelloWorld。这将运行程序。酷，对吧？酷。

让我们运行一个更复杂的程序。记住，我正在使用 Vim 访问 HelloWorld。cpp。我们把它放进去。数字，C8。你真的不想在鳄鱼中使用 C8。你应该使用什么？GetLine。你还应该使用字符串。

字符串。但仅仅作为示例，我们输入这个。有没有人想提醒我，我们需要输入什么来编译它？第一件事是你使用的编译器，C++。第二件事？我们要输入我们使用的标准。你不必输入这个，但如果你不输入，C++。

取决于你的编译器，将默认为 1998 年发布的版本，这很糟糕。我鼓励你输入版本。你还可以使用 14，17。为了好玩，我们试试 20。我不知道他们是否发布了，但也许。然后，答案是什么？

HelloWorld。cpp。你要编译的文件，答案是什么？破折号 O。破折号 O 基本上只是跳过你需要编译的复杂阶段。我只是跳过所有内容，从文件到可执行文件。破折号 O 意味着目标文件。

有一个中间目标文件。我们只跳过所有内容，直接到最后。最后一件事是什么？C++ 20 尚未发布，但你可以使用 C++ 2A 作为可用版本。我们试试看吧。这很酷，对吧？你实际上可以运行 C++ 20 代码。

虽然它还没有发布。我们如何运行程序本身？我们要求 cin，所以它在等待我们输入一些内容。我们输入了 15。HelloWorld。dash O 是你为文件起的名字吗？这个吗？

最后一项是你希望可执行文件被命名为什么。如果你查看实际的文件夹，你会发现 HelloWorld 实际上，是一个可执行文件。有点像你从互联网下载的任何东西。你可以点击它，它就会运行。它应该能运行。哦，不。

我需要输入一些东西。15。哇。一个简单的建议。不要这样做。不要做点、句点、斜杠，然后是你随机从互联网下载的可，执行文件，而你不知道它是什么。因为那只是运行一个程序在终端里。不要下载某种文件。

然后在不清楚它是什么的情况下运行，它。不要随便运行可执行文件。如果你要运行可执行文件，就直接运行它。不要在终端里运行它。这要看情况，例如，我可以使用 root 权限运行一个可执行，文件。

这意味着使用 sudo。sudo 的意思是 root 访问权限。你知道你在电脑上有不同的用户吗？还有一个 root 用户，他有管理权限。在这种设置下运行程序是相当危险的，因为你的程序可以。

在每个设置中进行更改。它可以基本上更改你的笔记本电脑。这非常危险。所以不要输入 sudo。不要使用 sudo。有问题吗？只是一些有趣的命令。不要记住这些，因为你会习惯它们。但有一个命令你可以使用，比如。

我们来文档一下。我们创建一个文档文件夹。它目前只有讲座视频。你可以创建一个目录。M-K-D-I-R。这意味着创建目录。我们创建一个名为 code 的目录。哇，它出现了。L-S-M 意味着删除。

所以我可以说 R-M code。这不起作用。R-M，你可以删除一个目录。如果你想删除一个文件，你可以用 R-M 删除那个文件。如果你想删除一个目录，你可以使用 R-M 带有连字符的递，归删除。

R-M code，意味着删除目录。但因为这是一个目录，当你删除一个目录时，你还必须删除，目录中的所有内容。这就是为什么它叫做递归。你必须进入目录，删除那里所有的内容，然后再返回。

你们都听说过可以输入的非常危险的命令吗？Sudo。好吧，我不想输入它。但你们都听说过那个命令，对吧？我不想输入它。R-M。R-M。点。好吧，所以。这是真的吗？它会清除你的电脑吗？不会。

因为我没有说 sudo。因为它不允许清除所有东西。它只能清除它可以访问的内容。所以我的用户只能访问我自己的内容。但如果我想，我可以删除自己的账户。好的，现在，删除。等一下，等一下，等一下。删除，删除。

好了。所以 R 代表递归的。这意味着进入目录并删除所有内容。这意味着进入目录，删除所有内容。如果你有更多目录，那么进入那些目录并删除所有内容。所以这就像删除你的整个目录一样。

然后 R-F 的意思是如果你只使用 -R，它会问你，是否确定，要删除这个？它会逐个文件地询问你，是否确定要删除这个？你猜 F 代表什么？F 代表强制，这意味着你告诉它，直接删除并强制删除。不要询问。

你可以强制执行，但你是在说一切都删除。是的。然后记得点号是什么意思吗？当前目录。当前目录，是的。所以那一行的意思是删除当前目录中的所有内容，并递归，地删除，这意味着进入所有目录并删除那些目录中的所有。

内容。并且强制执行，所以不要问我。在继续之前，让我先。等一下，我没听懂那个点号。好的，是的。所以如果你进入，L-S 的意思是列出当前目录中的所有文，件。哦，桌面。哦，那就是那个。是的。

所以如果你做 L-S，它会显示这个文件，对吗？这是一个文件。我可以创建另一个目录代码。是的。如果你做 L-S，它会显示代码和。好的。当然。好的。让我开始，好吗？但如果你对这个有更多问题，告诉我。

希望这对你有帮助。你可以运行你的程序。希望如此。如果你来晚了，那是你的错。好的。我们开始吧。我的。在幻灯片中。好的。好的。正如我在 Piazza 帖子中所说的，如果你在讲座期间有问，题，随时问。

但我要做的是我会有一个特别的。我会有特定的幻灯片，上面写着问题。所以把你的问题留到那些幻灯片上，好吗？我有点想在回答问题之前完成一个完整的块。其次，如果你。确保你的问题与我们正在编写的材料直接相关。

或者是类，似于之前幻灯片的内容，好吗？如果你的问题是这样形式的，为什么不这样做呢？或者你不能用其他方法做到这一点吗？我非常喜欢这些问题。把这些问题留到讲座后再问。好吗？这只是为了确保我们都能完成材料。

并且保持我的流程进，行。好的？酷。好的。我们今天不会涵盖所有这些内容，但会涵盖其中一些。所以简单回顾一下。上周我们写了一个叫做通用 Minmax 的东西。不是 Minimax。Minmax。好的？

所以简单回顾一下。模板类型名称 T 是做什么的？是的？它定义了一个自定义类型。是的。所以我们指定我们要编写的是一个模板函数，然后具体来，说它将使用这个模板参数 T。

然后我们只需将所有假定我们类型为 T 的实例替换掉。你们有多少人做了作业？好的。所以是四个？好的，因为反馈中有超过四个人说他们想要更多的练习题，但只有四个人做了作业。所以作业是查看幻灯片并完成。

基本上让函数不匹配变得，更加通用。你们看过了吗？然后我查看了三张幻灯片后的答案。所以我得到的结论是我不应该发布答案。好的。我忘记做整个录屏的事情了。你们今天只想看视频吗？好的。好的。好的。

我不会在这上面花时间，因为你们应该自己做这个。所以我会跳过它。但基本上你们得到的是一个针对向量的不匹配函数，你们，需要通过使它尽可能通用来提升概念。

所以这里的 mismatch 函数可以接受一个范围的输入迭代，器，它还接受第二个范围的输入迭代器。为什么你们不需要传递最后两个？我们需要传递第一个和最后一个。为什么我们不需要传递最后两个？好的。实际上。

由于你们中的大多数人没有做作业，我不知道为什，么我会问这个问题。好的。所以原因是因为 mismatch 函数基本上遍历两个范围，找，到范围不匹配的第一个实例。问题是如果你已经知道一个范围的长度。

你应该知道另一，个范围的长度。这就是为什么你只需要传递第一个和第二个。今天会多次出现这个问题。然后这个函数基本上只是遍历这些范围。它只是遍历两个范围，找到哪个不匹配。这段代码，对吧？但是 2 较短。

在指针的情况下，对吧，如果你访问一些新的东西，看起来，是错误的，对吧？那么你怎么知道它不是错误的呢？记住，C++ 的一个哲学是它会给你接口并告诉你它期望什，么。如果你决定不遵循它，那么它不会试图阻止你。

所以它基本上告诉你——如果你查看文档，它会告诉你两个，范围必须是相同大小的。如果两个范围大小不同，那么比较这两个范围其实没有意，义。然后显然会出现不匹配的情况。所以它假设这样，如果你不遵循它。

那么——哦，好吧，如果你，不遵循它，它只是读取到——如果你的第一个范围比第二个，范围短，如果你的第一个范围比第二个范围长，那么它只是，尝试读取那边的内容。今天我们将重点解决这里的最后两个任务。好吧。

我们已经解决了倒数第二个任务，我们将重点讨论如，何解决最后一个任务。因为上次我们已经写了一个通用函数，count ，occurrences，它可以接受任何范围，比如一个字符串列表，的后半部分。

以及一些数据类型，比如 5。字符串 5。问题是，好的，嗯——这里有一个错字，应该是 8。但是我们要尝试解决一个更通用的问题，即计算某个范围，内的元素数量。但是我们不仅仅是检查是否相等，我们说。

好的——但在我们，进入这个问题之前，我们快速谈谈泛型编程和概念提升。概念提升是我们查看对参数的假设，并质疑这些假设是否，真的必要的过程。还记得上次吗？我们从计算整数向量中的出现次数开始，它尝试找出该整。

数的实例有多少。我们将它泛化到可以是任何类型的向量。然后我们进一步泛化，使其可以是任何类型的容器。我们更进一步。它可以是任何范围。我们可以计算任何范围中的出现次数。在你这样做的时候。

你必须小心你对参数的假设。这就是隐式接口出现的地方。假设我们尝试使用之前做的事情来调用这个函数。我们有一个 v1，我们有一个 v2。然后我们想要计算——我们在这个上调用计算出现次数。这没有意义。

因为我们有一个范围和另一个范围，但我们还，是会尝试调用它。这段代码有什么问题？让我先说说我试图做什么。我试图计算 v1 中第一个元素的出现次数。因为 begin 指向第一个元素。为什么这个无法编译？

作为提示，让我们看看代码。编译器所做的是，它基本上试图推断类型是什么，然后将其，直接放入代码中。如果我们仅仅查看类型，v1。png 的类型是什么？它是四个向量位的迭代器。v2。png 的类型是什么？

也是一样的。如果我们进入这里，它会直接尝试推断这些类型是什么。它在下面的代码中造成了一个问题。你能看到这个问题是什么吗？注意在这一行，我们说解引用迭代器。这应该给你什么？一个 int。

然后我们比较它是否等于 val。val 是什么？我们在比较一个 int 和一个迭代器。这就是隐式接口出现的地方，即当你声明模板时，你可以直，接尝试将任何类型插入模板中。有时候它会工作，有时候它不会工作。

编译器会强制执行哪些类型不起作用。它是通过查看你对这些类型进行的操作来确定的，它查看，这些类型必须满足什么条件。你刚刚指出了一个好的类型，即当你解引用 iter 时，它必，须能够与 val 进行比较。

这是这些类型的一个要求。当你解引用这些类型中的一个时，你必须能够通过相等性，比较来比较它。如果这是一个迭代器，而这是另一个迭代器，那是不行的。如果这是一个迭代器，而这是一个 int，那是可以的。

明白了吗？让我们看看输入迭代器和数据类型还有什么其他要求。这个函数施加了一些其他要求。这些要求是什么？好问题。这里说 begin 必须是可复制的。不是所有类型都是可复制的。我们稍后会学习这一点。

这里我们有一个强制要求，我们必须能够复制任何输入迭，代器。这很重要。迭代器 iter 必须可以与 int 比较。在这里，我们还看到，为了使这段代码编译通过，你必须能，够递增 iter。

你能想到不能递增的类型吗？哪些类型不能递增？对，字符串。你不能递增一个字符串。如果我们尝试传递一个字符串给 iter，那将不起作用。你看到这些是如何导致这些隐式要求的吗？我们没有明确说明要求是什么。

但代码本身强制这些要求，我们来做一些问题吧。你在说 begin 并不一定对所有类型都可赋值。字符串会是一个例子吗？好问题。一个不能被复制的东西是字符串。如果我让你复制 cout，那将不起作用。

想象一下如果可以，这会造成什么样的混乱。你会有多个 cout 的副本在四处流动。有些东西就是不可复制的。如果你学过 C、S106B 或 X，你会知道你必须通过引用传，递文件流。原因是流不可复制。

如果我们尝试传递一个流到这里，这个隐式接口将不起作，用。这就强制你必须能够从这里复制东西。这里的另一个问题是你必须能够将你的迭代器与 int 比，较。在这里，我们强制 iter 必须在其中。

如果你给它奇怪的限制，它真的会尽力寻找符合所有约束，的东西吗？是的。假设我们给它一个字符串。这将有效，因为 auto 推断你传入的是一个字符串。你提到，auto 会尽力找出是什么类型。

你提出了一个很好的观点，即 auto 会尽一切努力找出是，什么类型。即使类型是错误的。这个 auto 本身不是隐式接口。但是，可赋值、可复制的部分是接口的一部分。我们说 auto 好像它是一个坏东西。

但想象一下，如果不用 auto，你必须在这里写什么类型才，能使其编译？如果我们不使用 auto，你必须在这里写什么类型？输入迭代器，对吧？因为这个类型应该是一个输入迭代器。

它是从一个输入迭代器复制过来的。在这个例子中，直接插入它是可以的。但有时你的类型会更复杂，这时候 auto 是一种很好的方，式来说，好吧，帮我找出那个类型。真正的接口在你尝试找出其他部分时才会出现。

之前我们提到，这是隐式接口失败的地方，我们尝试解引用，输入迭代器时，它必须能够与你的数据类型比较。模板对类型施加了这些要求。问题？是的。当你将迭代器传递给那个函数时，它是否自动按引用传递？默认情况下。

我们并没有按引用传递它。我们只是按值传递。你也可以用 & 来指定，我希望它按引用传递。我们实际上是对那个迭代器进行了复制。你提出了一个很好的观点。在这里，我们已经在复制迭代器了。

当你执行 auto iter = begin 时，这也会创建一个副本吗，是的，它会创建一个副本。好问题。这一行确实会做一个副本。对于大多数类型，迭代器的复制相对便宜。通过值传递它们是没问题的。

还有其他问题吗？为什么不能递增指向字符串向量的迭代器？让我们看看。为什么不能递增指向字符串向量的迭代器？如果输入迭代器是字符串的向量的迭代器，那是可以的。但如果begin本身是一个字符串。

那我们尝试将迭代器设为，begin，这样应该是一个字符串。然后我们试图说，好吧，拿一个字符串。我不会做那个例子，但如果你尝试编译这段代码，你会得到，一长串难看的错误信息。曾经有一个编程在线竞赛。

其目标是写尽可能少的代码，并，尽量生成最多的错误。赢得比赛的方法是使用模板。模板的作用是，如果它发现不匹配，上周我提到的这些自动，推导规则。它会尝试每一种可能的类型，并会基本上尝试所有可能的。

方法来看看是否有任何有效的。如果不行，那么它会说，哦，这些都不行，所有这些都是错误，的。所以你会得到这些非常长的消息。我已经调试过一些学生的代码，你会看到这些巨大的错误，信息。最糟糕的是。

错误信息非常糟糕。这些信息一点帮助都没有。这就是模板的一个困难之处。我们应该注意哪些问题以便在错误代码中识别出这是一个，迭代器问题？好问题。我现在没有例子，但如果你去Qt Creator。

有时错误信息会，显示错误代码1。有没有人遇到过错误代码1？类似的错误。如果你遇到这个问题，你应该去“编译输出”标签页，在那里，你会看到所有的错误。并且查找你写的代码行。因为有很多错误。

其中很多来自于迭代器库。所以你应该查找你写的代码。你应该能看到main的内容，也就是你写的内容。这就是我开始调试的方式。这些问题很难调试，这就是为什么C++20有一个新特性来帮，助处理模板。

而且它实际上是C++20中最重要的特性之一。它叫做概念。我接下来会谈谈这个。嗯，可能不会。我可能会跳过它。好的。再举一个例子。好吧，拿这个。和你的伙伴讨论一分钟。讨论这个函数的隐式接口是什么。

对集合和调试有什么要求？好的。好的。所以对那些想要糖果的人，谁能告诉我对集合或数据类型，有什么限制？在那边。是的？数据类型是否需要实现比较函数？让我们看看。数据类型是否需要实现比较函数？那么在哪里呢？

这里，对吧？是的。所以当你做list bracket I时，应该给你一个数据类型的，元素。它们是否自动知道比较数据类型是否等于数据类型？应该是的。应该能够的。尽管，你应该 - 如果你定义了自己的类的话。

是的，如果你定义了自己的类，它可能会或不会是可比较的，所以，是的，这是一个很好的观点。这绝对是一个接口。嗯，糖果？你选择什么都可以。太晚了。我已经为你选择了。好的。是吗？

你需要能够使用括号表示法访问数据类型吗？确切地说。好点子。所以列表，这个集合，它必须具有括号表示法。好的？那么，什么类型没有括号表示法？映射肯定有，但它不是你期望的那样。像列表、集合，是的。糖果？嗯。

当然。什么类型？栈。是吗？它必须具有点大小方法。是的，好点子。所以列表必须有一个点大小方法。哪些类没有点大小方法？栈。当然。栈。嗯，栈没有 - 字符串。是的。好的。酷。糖果？当然。好的。

如果你说“当然”，我会假设那意味着任何东西。好的。还有其他的吗？你必须 - 有些数据类型，如，不 - 是的。像，即使是现有的，不一定是你自己创建的，有一些数据类，型适用于它吗？这是个好点子。

所以有些 - 所以当你处理一个集合时，比如向量，每次你，把东西放到向量中时，它会复制你放入向量的内容。所以数据类型必须被复制。哦，对不起。刚才说的，是的。对不起。

集合必须能够 - 必须有大小 T 的索引，这也意味着它必，须已经是有序的？是的，好点子。它必须是一个序列容器，对吧？嗯，不只是任何序列容器，但这基本上仅存在于向量和索引，中。列表没有这些。是的。所以。

是的，好点子。它必须是可索引的。糖果？奇巧。奇巧。好的，这行不通。这行不通。这行不通。差不多。是的。第三个记录数据类型，是否已经暗示它是某种集合？比如，里面有多个东西？第二个记录等等？这是个好点子。

我认为这可能是个错误。我可能确实需要删除这个。没错。我应该删除这个。是的，好的。是的，好点子。这不应该在那里。然后集合本身应该能够推断它是一个 - 然后这确实提出，了一个要求，就是集合，集合中的东西。

必须是类型 A。所以如果你那样输入，它是否仍然能够编译，一旦你有 - ，我认为这不会编译。好的。我知道你仍然需要保留引用。所以模板不假设引用。好的。我会修复这个问题。你能再次看到那个问题在哪里吗？是的。

所以这里我们不应该放这个尖括号，因为编译器会试图弄，清楚集合是什么类型的。它会说，哦，这是一个字符串的向量。是的，所以我们不需要尖括号。现在，这是一个额外的要求，即集合中存储的内容必须是数，据类型。

是的，你不能让这个是一个字符串的向量，而这个是一个整，数。或者让它可通过等号与数据类型进行比较。所以如果我们看到另一个等号。那么我们就来逐一查看它们。大小。是的。而且你们还发现了一些其他问题，这很好。

让我快速讲一下 C++20 的一些内容。C++20 允许程序员显式指定接口是什么。所以这里我们显式地说明它，无论是什么，都必须是一个输，入迭代器。而且它必须是值类型。如果我们解引用迭代器。

它应该可以与类型进行比较。我认为这就是它的意思。再次强调，这是 C++20 的特性。这还没有正式化，但这就是 C++20 将要做的事情。这允许的是，如果你打破了某个接口，错误信息不会是一大。

堆恐怖的错误信息。错误信息将源于此。所以这不是隐式接口，而是显式接口。显式总是比隐式更好。然后在文档中，你会看到这个，它是自我文档化的。你确切知道它作为输入迭代器，并且在解引用时将是可比，较的。好的。

酷。我们来做一些问题。有问题吗？你能解释一下隐式接口和显式接口之间的区别吗？当然。所以这里，看着这段代码，我们只是尝试弄清楚隐式接口是，什么。我们尝试弄清楚关于输入迭代器和数据类型的要求是什么。

但它没有明确写在这里。你必须实际查看函数，一步步弄清楚这些类型必须符合什，么要求。这不是很好，特别是当你只有文档的时候。你不完全知道输入类型和数据类型必须满足什么要求。所以为了使其更明确。

现在你可以像这样做，明确说明它必，须是一个输入迭代器，可比较等等。我们在代码中明确写出了要求。有什么问题吗？好的，我们继续。函数到 Lambda 表达式。我们今天的进展很快。我们讨论了概念提升。

这是我们写的函数，它解决了一个问题，即某个类型的某个，值在一系列元素中出现了多少次？我们可以使这个问题更加通用。一种方法是我们可以查看这一部分，将其重新表述为，在一，系列元素中。

元素满足等于值的情况有多少次？明白了吗？是一样的，对吧？这是在做相同的事情。同意吗？好的。现在，我们可以更进一步地概括。因为等于值，我们可以用其他东西替代它。我们可以将其替换为。

元素在一个范围内满足小于5的次数，是多少？这不一定要是等于值。可以是任何一种真或假的条件。这被称为谓词。谓词是一个接受一些参数并返回布尔值的函数。例如，是否等于3？我们有一个函数。这是一个一元谓词。

它接受一个值作为参数，并返回一个值是否等于3。你也有二元谓词，它接受两个参数，然后返回一些真假值。与其说，元素有多少次满足等于另一个元素，我们可以用一，些通用的谓词来替换。更好的是。

现在你可以传入一些通用的谓词。你能看到这比我们之前写的计数出现次数还高一层吗？之前，它必须是有多少个元素等于另一个元素。现在是有多少个元素满足这个条件。然后我们可以这样做。这非常简短，所以我不想写代码。

但你可以这样做，你可以定义一个函数，判断是否小于5。然后你可以在 v。begin、v。end 上调用 count ，occurrences，并传入条件。发生的情况是，它会尝试运行这个条件。

如果谓词对这个元，素有效。它会尝试对每个元素调用谓词，如果谓词返回 true，则计，数加一。这非常重要。现在有问题吗？有吗？所以谓词在这种情况下是一个函数吗？所以你是把一个函数作为参数运行吗？没错。

是的。你需要列出它吗？如果你想使其更通用，你需要列出很多不同的谓词函数吗？你必须具体写出来吗？是的，所以有函数的语法。你可以显式地写出函数指针，这在 C 语言中很常见。但因为通常不需要这样做。

我们不这样做。但最好还是作为模板来做。我们也可以模板化函数。还有一种类型叫做 std：function，它像是任何类型函数，的通用类型。所以你可以尝试这样做。你也可以这样做。

然后我们可以使用这个函数调用，并且它应该返回 true。是的，我们可以创建很多不同的谓词。这些都是谓词函数。不用担心这个 inline。这不是特别重要。但我们可以写很多谓词。

唯一的要求是它必须返回布尔值，并且必须接受一些谓词，作为参数。回到 Andrew 的问题，注意即使在我们的谓词中，我们也可，以将我们的谓词函数本身做成模板函数。

所以我们在其他模板函数中使用模板函数作为参数。是的？所以谓词不一定要是布尔值，对吗？你可以有与成本相关的值，并仍然以相同的方式调用它们，吗？谓词必须返回布尔值。

因为我们将谓词用于调用某些东西并查看它是否返回 ，true 或 false。在这种情况下，但在其他情况下，它总是布尔值吗？是的，我们使用“谓词”这个术语来表示它必须是布尔值。它必须返回一个布尔值。

返回布尔值的函数。是吗？如果一个谓词需要若干参数，那这些参数的数量可以是零，吗？它需要一些参数吗？是的。它可以是一个已知参数的函数。我认为在CS110中，这些被称为惰性函数。T-H-U-N-K-S。

是的，惰性函数。你可以使用这些，但对于我们今天要做的情况，它们不会特，别有用。因为，我的意思是，你只是对每个元素调用相同的函数，但，没有传递任何参数。比如，是吗？

一个不接受任何参数的函数并不是特别可定制，对吧？它每次都运行相同的内容。回到Michael的问题，我觉得你可能在问，是否有任何情况，我们可以传递一个不是谓词的函数？确实有这样的情况。

我们实际上在之前的一个算法示例中，见过，我认为Avery可能会在未来讲解这个问题。在这种情况下，你可以将它称为谓词，但确实可以传递做特，定事情的函数，而这些函数不一定返回布尔值。在这种情况下。

你确实可以。好的，是的，这些是一些谓词函数。我真的很喜欢这个。我的就寝时间是4点，所以……，这就是我的就寝时间。是凌晨4点还是下午4点？当然是凌晨4点。好了，现在我们，可以这样做。这就像是一个数字向量。

这就像是我的睡眠时间是4点。所以你可以说，好吧，我可以传递计数出现次数，计算有多，少个小于2。我可以说我的第4周的睡眠时间中有多少超过了我的就寝，时间。一个，就是这样。好的，有什么问题吗？好的。

这种方法有两个主要问题。我们称之为函数指针方法，即我们本质上是在传递另一个，函数。有人看到问题了吗？有问题吗？是吗？是的，请继续。这不太明确。这很……，你是说它不明确，然后你必须说小于5。

然后它是特别的……，是这个意思吗？不，但现在是了。哦，好吧，好吧。抱歉，我没有明白你的意思。我的意思是，当你使用这个函数时，使用它的人可能不确定，如何使用它。是的，当然。例如。

一个问题是你必须编写这个函数。有人必须编写函数，然后你必须知道要调用哪个函数。这是一个好问题。另一个问题，我已经给出了答案，那就是，对于小于5，这种，方法有效。你必须做这样的事情，对吧？有什么……。

有没有注意到我在这个例子中没有尝试的一件事，你可能，想尝试？比如你在说，为什么我必须硬编码这些？传递第二个值。传递一个用于比较的第二个值。所以我可以尝试，不仅传递一个值，我可以传递一个参数，对吧？

这就是你自定义函数的方式。你可以传递更多参数。问题是，谓词的隐式接口是什么？当你调用谓词时，你传递了多少个参数？所以，如果你尝试声明另一个有多个参数的谓词，这段代码，将无法编译。覆盖一个函数。

就像一个名字相同，但参数数量不同的函数。问题是因为我们写了这个。这是你在调用的函数，你不能真的改变那个函数。我们在编写自己的代码，但你不能改变。谢谢。我可以在讲座后回答那个问题吗？因为我知道你在说什么。

但这是一个更长的解释。是的，问题？一个对吗？是一个对吗？如果你想发送到。为了比较？但问题是。所以你在说谓词接受一个对。让我对此进行反馈。我认为那不会奏效。是的，问题是，谓词函数不知道它接受什么。

我接受一个值，还是两个值？所以我不是。让我再回到这个问题上。所以你可以尝试做的是，好的，我们来设置一个限制，对吧？但你不能真正把这个限制传递进来。所以这是一个问题。你不能把它作为一个参数添加进去。

你不能把它作为参数添加进去，因为那样的话这个就不会，工作。我真的很想去写代码，但。 我不太想拉出代码。但如果你尝试这样做，它会再次显示很多错误。说。它会准确告诉你，这段代码无法编译。问题是。

这段代码通常在某个你没有写的库中。所以你会被告知。好的，我喜欢这样的 Piazza 帖子，指出斯坦福库有问题。错误告诉我它们是。错误信息告诉我，斯坦福库有问题。因为当模板错误发生时，它们会指向源头。

即不能编译的确，切行。问题是，你传递了无法编译的东西。而不是那行代码本身。我喜欢那些 Piazza 消息。然后一些名叫 Anand 的友好的助教会礼貌地告诉你你的，代码坏了。看看。

6B 的学生知道我在说什么吗？好的，没关系。他仍然回答 Piazza 上的问题。好的，算了。这是助教 Anand，他回答问题非常直率。而且非常迅速。好的，那么 pre-C++11 的解决方案是这样做的。

现在，这个话题对我来说非常重要，因为当我面试这个工作，时，这是我展示的内容。但这有点复杂，因为你必须了解类。而且似乎为了写一个谓词函数写整个类有点过头了。所以我们甚至不会去看这个，但如果你想了解这个。

请告诉，我。我们可以在以后的讲座中学习这个。但 C++11 的解决方案是使用一个叫做 lambda 的东西。这就是这一行。Lambda 基本上是你可以创建的一个非常轻量级的函数。这个函数是一个对象。

但它表现得像一个函数。我们来做一个例子。所以我没有真正准备好这个，但我们可以这样做。有很多代码。所以让我们创建一个简单的 lambda。假设它是小于的。不要担心语法。但是 int i。

然后返回 i 小于。所以我刚刚声明了一个 lambda。不要担心这个复杂的语法。现在，这个对象，这就是一个对象，对吧？这是一个变量，它存储了某种对象。这个对象的行为就像一个函数。那么你可以用函数做什么？

调用它，对吧？所以假设小于，那么你怎么调用一个函数？是的，所以我们说它小于 2。让我们放入 1。那应该返回 true，false。对吧？然后它小于 3。所以我们只是声明了一个像函数一样的对象。

有些人称这些为函数对象。然后你可以像使用函数一样使用它们。例如，这里我们有一堆成绩。我们需要一些学生的成绩，并计算他们中有多少人得了 A，然后在这里，我们传入的这个，就像一个函数。

然后我们传入一个函数对象。让我们更详细地分解这一行。我们来看一下语法。因为语法的某些部分可能看起来非常熟悉。其他部分则不然。lambda 函数的结构如下。所以你有，声明一个函数对象。

你有一个称为捕获子句的东西。然后你有一堆参数，这个返回类型，然后你有一个主体。在 C++14 中，这个返回类型是相当可选的。所以你通常可以省略它。通常对于谓词，它们返回布尔值。所以你不需要真的保存它。

参数，正如你从函数中所期望的那样。它接收一些参数。lambda 的一个很酷的地方是你可以为这些参数使用 auto，所以让我们用 auto。然后对于主体，它就像一个函数一样工作。

在你的函数中放入你想要的任何内容。然后，是的，到目前为止就是这样。我现在停止。到目前为止有任何问题吗？有吗？通常，我们希望如果可以的话就使用 auto。但是在这种情况下。

我们是否应该保存 bool 以使其明显，是一个谓词？你是说返回值？是的，返回值。嗯，我想一开始。是 auto。哦，你是说这个。所以有两个 auto。这个 auto 或者这个 auto？第一个。第一个。

好的。这是个很好的问题。所以问题是，这个是一个函数对象。它的类型是什么？C++？这在 Java 中有效，因为所有东西都从对象派生。但 C++ 没有对象类型。所以这很酷。当你写这样的代码时。

C++ 会将其转换为，它为你创建一个，类。很酷，对吧？但问题是你不知道这个类的名称是什么。编译器会给它一个非常奇怪的名称。你真的不知道名称是什么。这就是你必须使用 auto 的地方。

因为你真的不知道名称，是什么。好的，那么关于括号后的返回类型，是否使用它来明确表示，这是一个谓词比较好呢？人们的偏好不同，取决于你喜欢哪种风格。因为我们经常使用 Lambda 表达式。

通常用它们作为谓词，在这种情况下，返回是合适的，这是一种隐含的含义。还有其他情况下你可能需要使用 Lambda 表达式。如果你学过 CS，你会经常使用 Lambda 表达式。在这些情况下。

明确指出返回值可能是有帮助的。但随着 C++ 的发展，大家变得越来越懒。还有其他问题吗？好吧，这个编译不通过。这是之前遇到的相同问题。我们可以声明一个限制，但这会创建它自己的作用域。

所以这里面的任何东西都不能以任何方式影响它。在一些语言中，你会听到这叫做闭包，这就是原因。它像一个函数那样封装自己的变量。所以这些变量不会相互作用。有人想猜猜捕获子句的作用吗？它捕获变量。

所以我们可以明确地说，捕获这个作用域中的变量并使其，在 R 内部可用。这个代码工作得很完美。好吧，有问题吗？如果你在调用 func term 后改变了变量的值，然后调用类，似你的伪造列表的东西。

它会引用哪个值？是当前的状态吗？好问题。我认为是当前的状态。是你在这个函数中声明的状态。所以它基本上是提取值限制。但是。我们会再确认一下。我对此很确定，因为接下来会发生的情况是你可能会有。

 如果限制超出了那个作用域呢？因为这会拷贝一份。哦，引用与拷贝。是的，好吧。好问题。这正好引出我们要讨论的内容。你可以通过引用或拷贝来捕获这些变量。所以在这种情况下，它会拷贝一个。是吗？

只是作为另一个参数传递给 auto-vowel 吗？好问题。你可以这样做，但你会遇到相同的问题，就是这里。谓词的隐式接口只接受一个参数。这是我们之前处理过的完全相同的问题。你不能添加任何额外的参数。

所以这就是我们特别设置这个东西的原因，它允许你捕获，变量而不将它们计入参数。让我们快速谈谈。这是另一个茶的例子。我在这里骑车时丢了我通常喝的茶瓶。所以我现在有点渴。是的。好吧。

还有更多方式来捕获这些变量。你可以通过引用来捕获它们。例如，一组字符串，我们不希望拷贝它们，所以你可以通过，引用来捕获。你可以指定哪些要通过引用捕获，哪些不通过引用捕获。有问题吗？是吗？

如果你用这种方式捕获所有东西，你会希望通过引用来做，吗？拷贝那些大的东西，比如 Ts 吗？我们来看看。所以在这里你想把与符号放在 Ts 之前，表示我想通过引，用复制这个变量。不是通过引用复制。

我想传递这个。我想通过引用捕获它。通常，如果你在一个类中捕获所有内容，因为我知道你可以，用这个捕获所有内容，你会用与符号 this 吗，以便你可以，复制所有内容？我们不谈这个。

因为当我们讨论类时会涉及到。但是列表默认是指针，所以你可以通过值复制它。还有一些方法可以直接捕获所有内容。如果你用等号，这意味着按值捕获所有内容。如果有些内容你特别想通过引用捕获，那么你可以在后面。

写出来。你也可以通过引用捕获所有内容，然后接受你所写的内容，不推荐这样做，因为这会让它变得全局化。它会捕获所有内容。所以这就是我们的目标。这就像是把你函数中所有可用的内容捕获到。我们下次会谈论这个。

但我基本上会给你一个下次会发生，什么的概述。我们将基本上使用 STL 算法库，利用这个关于函数对象的， API 的新知识。将会发生的是，你会看到我们今天写的计数出现次数，其实。

是一个叫做 countInOccurrences 的 STL 算法。还有大量其他算法，非常可定制化。你可以传入函数对象，传入匿名函数，它会处理库的操作。我们会做一些非常酷的事情。我有一个例子。

我有一个文件，里面记录了完成了作业 1 ，的每个人的名字、年份，以及你在 106B 的成绩。然后我们会做一些任务，比如，有人失败了吗？这是一个危险的文件。我只是在开玩笑。我确实为你的成绩生成了随机数字。

会有随机数字，但那些不是你的，特别是如果你现在在 ，106B 的话，那些不是你的预测成绩。也就是说，我们预测你们都能得到 100% 因为你们在上这，门很棒的课程。开玩笑的，开玩笑的。另外。

回答 Bish 的问题，函数对象在运行时使用章节类的，值。什么是整数？