![](img/e344f9e1722ece9f6a7be11157babca0_0.png)

# 课程19：图算法进阶：Dijkstra算法与A*搜索算法 🧭

在本节课中，我们将学习两种重要的图算法：Dijkstra算法和A*搜索算法。我们将从回顾广度优先搜索（BFS）的路径重建问题开始，然后深入探讨如何在带权重的图中找到成本最低的路径，最后介绍结合了启发式思想的A*算法。

## 回顾广度优先搜索（BFS）的路径重建

上一节我们介绍了广度优先搜索（BFS），它可以找到两个节点之间边数最少的路径。本节中我们来看看BFS在路径重建方面的一个挑战。

BFS在存储待查找节点时使用队列。当访问一个新节点时，会查看其所有邻居。主要区别在于，如果我们有一个顶点队列，仅仅访问节点本身不足以重建从起点到终点的具体路径。

为了重建路径，我们需要为每个节点记录其“前驱”节点。例如，如果知道节点A的邻居是B、E和D，并且从A搜索到了F，那么我们就需要知道F是从哪个节点访问过来的。这是在作业中需要实现的关键点。

以下是关于BFS的一些观察：
*   BFS总能找到边数最短的路径。
*   如果不考虑边的权重（成本），BFS找到的就是最优路径。
*   在BFS中，重建实际遍历的边序比深度优先搜索（DFS）需要更多思考，因为DFS可以通过栈或递归调用来自然追踪路径。
*   BFS找到的是最短路径，而DFS可能占用更少内存，但找到的路径不一定最短。因此，在选择算法时需要权衡。

在继续讨论Dijkstra算法之前，如果有人好奇BFS的运行时间：基本上是遍历每个顶点和每条边各一次，所以时间复杂度是 **O(V + E)**。

## 引入带权图与最短成本路径问题

我一直暗示的一个想法是：在有**权重**的图中，我们如何找到**成本最低**的路径？在现实世界中，这是一个常见问题。

例如，在规划旅行时，直飞纽约可能比在芝加哥中转更贵。如果你更关心金钱而非时间，可能就愿意选择中转以节省机票费用。现实世界中的图，每条边（例如路段、网络连接）都有特定的权重（如距离、时间、成本），我们通常希望最小化路径的总权重。

另一个例子是城市地图导航，不同街道的通行时间（权重）可能差异很大。服务器处理请求时，也可能根据延迟（权重）来选择路径。

那么，为什么BFS对于这类问题不够好呢？让我们看一个例子。

![](img/e344f9e1722ece9f6a7be11157babca0_0.png)

假设我们想找到从A到F成本最低的路径。BFS会找到路径 A -> B -> E -> F，总成本是 2 + 3 + 4 = 9。
然而，存在一条更好的路径：A -> D -> G -> F，总成本是 1 + 1 + 4 = 6。
BFS找到的是边数最少的路径，但不一定是权重和最小的路径。当图变得非常庞大时，肉眼寻找最优路径将非常困难。

## Dijkstra算法：寻找带权图的最短路径

Edsger Dijkstra提出了一种算法来解决这个问题，他因此获得了图灵奖（计算机领域的诺贝尔奖）。传说中，编程中常用`i`， `j`， `k`作为循环变量就是因为Dijkstra的名字。

Dijkstra算法用于在**带权有向图**中，找到从一个给定起点到图中其他所有顶点的**最低成本路径**。它的基本思想是：我们不再盲目地将所有邻居加入队列，而是会跟踪到达每个节点的当前已知最低成本，并优先探索成本最低的节点。

### 算法伪代码与核心概念

算法从起点开始，设其成本为0，其他所有节点的成本初始化为**无穷大**。我们使用一个**优先队列**（通常是最小堆），根据当前已知的到达成本对节点进行排序。

以下是算法步骤：
1.  将起点以成本0加入优先队列。
2.  **while** 优先队列不为空：
    a. 从队列中取出当前成本最低的节点 `u`，标记为“已访问”。
    b. 对于 `u` 的每个未访问的邻居 `v`：
       计算通过 `u` 到达 `v` 的**新成本** = `u`的成本 + 边(`u`, `v`)的权重。
       **if** 新成本 < `v`的当前记录成本：
           更新 `v`的成本为新成本。
           将 `v`（以新成本）重新加入优先队列。
           记录 `v`的“前驱”节点为 `u`（用于最终路径重建）。

### 算法示例演示

让我们用之前的图例，一步步看Dijkstra算法如何找到从A到F的最低成本路径。

1.  **初始化**：起点A成本=0（黄色）。其他节点成本=∞。
    *   优先队列 PQ: `[(A, 0)]`
2.  **处理A**：取出A（标记为绿色）。查看邻居B和D。
    *   到B的新成本 = 0 + 2 = 2。更新B成本为2，前驱为A。B入队。
    *   到D的新成本 = 0 + 1 = 1。更新D成本为1，前驱为A。D入队。
    *   PQ: `[(D,1), (B,2)]`
3.  **处理D**：取出D（成本最低）。查看邻居C和G。
    *   到C的新成本 = 1 + 2 = 3。更新C成本为3，前驱为D。C入队。
    *   到G的新成本 = 1 + 1 = 2。更新G成本为2，前驱为D。G入队。
    *   PQ: `[(G,2), (B,2), (C,3)]`
4.  **处理G**：取出G（与B成本相同，任取一个）。查看邻居F。
    *   到F的新成本 = 2 + 4 = 6。更新F成本为6，前驱为G。F入队。
    *   PQ: `[(B,2), (C,3), (F,6)]`
5.  **处理B**：取出B。查看邻居E（D已访问，忽略）。
    *   到E的新成本 = 2 + 3 = 5。更新E成本为5，前驱为B。E入队。
    *   PQ: `[(C,3), (E,5), (F,6)]`
6.  **处理C**：取出C。查看邻居F。
    *   到F的新成本 = 3 + 5 = 8。8 > F的当前成本6，因此**不更新**F。
    *   PQ: `[(E,5), (F,6)]`
7.  **处理E**：取出E。查看邻居F。
    *   到F的新成本 = 5 + 4 = 9。9 > 6，不更新。
    *   PQ: `[(F,6)]`
8.  **处理F**：取出F。发现F就是目标节点，算法可以提前终止（优化）。
    *   通过回溯前驱节点（F <- G <- D <- A），得到最低成本路径 **A -> D -> G -> F**，总成本为6。

### 算法特性与注意事项

*   **贪婪算法**：Dijkstra算法是一种**贪婪算法**，它在每一步都做出当前看来最优的选择（访问成本最低的节点），并希望这能导致全局最优解。
*   **正确性保证**：算法之所以有效，是因为它始终维护两个关键属性：
    1.  对于任何**已访问**的节点，我们记录的成本就是从起点到该节点的**最低成本**。
    2.  对于优先队列中的节点，其优先级是当前已知的、**通过已访问节点**可达的临时最短路径成本。
*   **路径重建**：必须额外存储每个节点的“前驱”信息，才能在算法结束后重建完整路径。
*   **无穷大的表示**：在编程中，通常用一个非常大的数（如`INT_MAX`）来代表无穷大。
*   **运行时间**：由于使用了优先队列，每次插入、删除或更新优先级都是 **O(log V)** 操作。算法大致会检查每条边，因此总时间复杂度约为 **O((V+E) log V)**。对于稠密图，这比BFS的O(V+E)要慢。
*   **局限性**：Dijkstra算法要求边的权重**非负**。如果存在负权边，算法可能无法得到正确结果。

## A*搜索算法：启发式引导的Dijkstra

Dijkstra算法会均匀地向所有方向探索，直到找到目标。但如果我们有关于目标位置的信息，能否让搜索更“智能”地朝向目标呢？这就是A*搜索算法的思想。

设想一个网格，起点在左下，终点在右上。Dijkstra会像圆形波纹一样扩散，探索许多不必要的节点。A*算法通过引入一个**启发函数**来估算从当前节点到目标节点的剩余成本，从而引导搜索方向。

### 启发函数

启发函数 `h(n)` 是对从节点 `n` 到目标节点代价的**估计**。一个关键要求是，启发函数必须是**可采纳的**，即它永远不能**高估**实际成本。在路径规划中，直线距离（欧几里得距离或曼哈顿距离）常被用作可采纳的启发函数。

例如，在只能上下左右移动的网格中，从当前点到目标的曼哈顿距离就是一个很好的启发函数。

### A*算法原理

A*算法与Dijkstra非常相似，区别在于优先队列中节点的优先级计算方式：
*   **Dijkstra**：优先级 = 从起点到当前节点的已知成本 `g(n)`
*   **A***：优先级 = `g(n)` + `h(n)`，其中 `h(n)` 是从当前节点到目标的估计成本。

这样，A*会优先探索那些**已知成本低**且**看起来离目标近**的节点，从而有望更快地找到目标。

### 伪代码对比

**Dijkstra优先级设置：**
```cpp
priority = cost_so_far[current_node]
```

**A*优先级设置：**
```cpp
priority = cost_so_far[current_node] + heuristic(current_node, goal)
```

算法主体结构与Dijkstra一致，只是在节点入队时计算优先级的方式不同。

## 总结

本节课中我们一起学习了两种重要的图算法：
1.  **Dijkstra算法**：用于在**边权重非负**的图中，找到从单一源点到所有其他顶点的**最短（最低成本）路径**。其核心是使用优先队列进行贪婪搜索，时间复杂度约为 **O((V+E) log V)**。
2.  **A*搜索算法**：Dijkstra算法的改进版，通过引入一个**可采纳的启发函数** `h(n)` 来估算到目标的剩余成本，从而引导搜索方向，在实践中往往能更快地找到目标路径。其优先级计算为 `f(n) = g(n) + h(n)`。

理解这些算法，关键在于掌握它们如何利用数据结构（队列、优先队列）来管理待探索节点，以及它们保证正确性的核心思想（Dijkstra的已访问节点成本确定性，A*的可采纳启发函数）。在具体实现时，别忘了记录前驱节点以重建最终路径。

![](img/e344f9e1722ece9f6a7be11157babca0_2.png)

![](img/e344f9e1722ece9f6a7be11157babca0_2.png)