# 斯坦福大学《CS106L： C++编程｜ Stanford  CS106L C++ Programming 2019+2020》中英字幕（豆包翻译 - P7：[13]CS 106L Fall 2019 - Lecture 6_ Templates (Video) - GPT中英字幕课程资源 - BV1Fz421q7oh

好的，我想我们准备好了。

![](img/09ab7f555a33b141c1d158d778f655d6_1.png)

是的，我来开车。Facebook。Facebook。是的。好吧，我们开始吧。有人能检查一下摄像机是否在录制吗？是吗？好，太棒了。那么，大家欢迎回来。第四周过得怎么样？举个大拇指？好的。竖个拇指？好的。

所以，我昨晚睡到五点，我刚刚做了一个期中考试。但我非常兴奋来教你们。大约十分钟。那么，让我们看看。首先，去106L网站下载QT文件。根据你们的一些反馈，我们将进行更多互动式教学，这意味。

着我们将做一些示例，但我也会让你们尝试自己编写这个，函数。所以，我鼓励你们下载QT Creator文件。如果你没有笔记本电脑，没关系。找个搭档。是的，找个搭档。在你们这样做的同时，让我们快速谈谈这个。

所以，根据你们的反馈，我们今天主要不会使用幻灯片。我将通过代码来激励一切。所以，是的，幻灯片作为参考是重要的，但你们在讲座期间，不必一定跟随它。如果对你有帮助，你可以在我讲解代码时把幻灯片放在那，里。

好的。如果这对你们来说没问题，请点头。即使你摇头，我今天也不会对此采取任何行动。好的。顺便说一下，这只是反馈的总结。你们提到的一些喜欢的方面。互动性。幻灯片看起来很不错。谢谢。

我们花了很多时间在幻灯片上，所以谢谢。我们真的很喜欢制作幻灯片。有人说我们，“”很友好。所以，我不知道这是什么意思，但希望不是讽刺。有些人说这门课真的很轻松。确实很轻松。这门课就是要轻松一点。

你们不应该感到压力。还有一些人很喜欢课堂上提问的数量。一些不喜欢的方面。有些人觉得课程有点快，内容有点多。幻灯片太多了。是的，不幸的是。有些人希望有更多的练习。所以，除了作业，也许还有更多的练习题。

更多互动式讲座，我们今天一定会开始这样做。还有些人不喜欢提问的数量。好的。所以，这里是一些我个人将在本次讲座中做出的更改总结，所以，今天，我会在Piazza上发布几个练习题，如果你们想，练习的话。

我减少了今天内容和幻灯片的30%。但幻灯片仍然在里面。只是我会跳过它们。好的。所以，你们都能看到你们错过了什么。然后，今天我们将有时间来处理问题。但在那段时间里你们也可以提问。所以。

希望这能平衡问题的数量。有问题吗？好的。哦，还有多人提到我应该多准备糖果。所以，我带了糖果。好的。我想我会在停下来回答问题时，拿几块糖果。然后我们会继续问问题，直到糖果用完。当糖果用完时。

那就是我们该继续的信号。这听起来公平吗？好的。我还没有真正练习过拿糖果这件事，所以我可能会拿太多，只是说说而已。所以，这是我们到目前为止所覆盖的内容的路线图。我们正在学习标准模板库。今天。

我们将进入一个叫做模板的小领域。你可以看到这是更大领域中的一部分，叫做泛型编程。所以，编程中有几种范式。你听说过哪种编程范式？好的。所以，我听说过面向对象编程。这就像是Java中的一个最大热门词。

因为Java是面向对象，的编程语言。这也是你到目前为止大部分使用的东西。你听说过其他这些范式吗？是的。函数式。函数式编程。所以，C++确实有函数式编程的能力，但我们不会涵盖这些，因为在我看来。

我认为有更多适合函数式编程的语言。好的？是的。编程范式本质上是解决问题的不同方式。一种方法是将问题分解为类，将这些东西在计算机科学中，可视化为对象。这就是我们称之为面向对象编程的原因。

这在类中占有很大一部分。我们将学习C++如何实现面向对象编程。但还有其他类型的编程。一种叫做过程式编程。这在C中主要使用。对吧？C基本上是，好的，这里有一个指令。做这个。做那个。做那个。

这叫做过程式编程。C++很酷的地方在于，人们称它为多范式语言，因为它结合，了所有这些不同的范式。你可以进行过程式编程。这就是C++从C派生的原因。你可以进行面向对象编程。我们很快会谈到类。

然后还有第三种，叫做泛型编程。这可能是你在上课时甚至没有想到的，你可能没有想到自，己是为了学习泛型编程而来上这门课的。但我相信泛型编程是C++中最独特的部分之一。其他语言也有泛型编程。它们有模板的能力。

各种各样的东西。但我认为C++有一套非常独特的泛型编程工具。这就是我们要学习的内容。我们有四节关于泛型编程的讲座。今天是第一节。然后在星期四，我们将讲解函数和算法。现在，你们可能会想，是的。

我知道什么是函数。我知道什么是算法。但那节课非常重要。确保你完成那节课。好的，今天我们将学习模板函数。所以这是我们要讨论的第一件事。我们将跳过可变参数模板，这是我觉得非常酷的内容，但我，们没有时间讲解。

不过幻灯片里有相关内容。概念提升，这是一个重要的讨论——动机是为什么我们需要，模板函数。然后我们会讨论隐式接口和概念。这将直接引入我们下周关于算法和函数的讨论。好的，我现在要切换过来。

我们不再使用幻灯片了。我们将讨论模板函数。我怎么放大？命令什么？哦，这样就好了。好的，所以我们要编写的第一个函数是我们将编写一个名，为myminimax的函数。现在。

我真的想把这个函数叫做minimax，但不幸的是C++里，有一个minimax函数。我们基本上要实现那个函数。但我会称它为myminimax。基本上，myminimax的工作方式是你给它两个参数。

比如说a，和b。然后，例如，这里我们说myminimax 3和负2。然后它应该返回一个对，其中第一个元素是较小的，第二个，元素是较大的。到目前为止很简单吧？好的，作为一个快速测试，你们都能看到这个吗？

好的，min1应该是什么？负2。Max1应该是什么？3。好的，太棒了。你们都能比较数字。做得很好。好的，所以这基本上就是这个函数的功能。为了使代码更简洁，我还编写了这个函数printminimax，它。

接收最小值和最大值，并打印出最小值。所以如果你运行它，它的行为正如你所想。为了证明给你们看，min是负2，max是3。如果两个数字相同，哪个是最小值哪个是最大值并不重要，到目前为止有任何问题吗？所以。

好吧，我们快速讨论一下这个。这个函数对整数来说很好用。但如果我想做类似的事情，比如说，QtCreator不是最新的，版本，所以它不识别自动缩进。它不识别结构绑定或有效的东西。所以你会看到奇怪的自动缩进。

好的，如果我们想做这样的事情呢？8。3和7。4的最大值。所以这不起作用。有人想猜猜为什么它不起作用吗？双精度浮点数转换成整数。对。你想要一颗糖吗？对。好吧，所以对，8。3是双精度浮点数，这不是整数。

现在，你会看到它仍然会编译。它会给你一个非常严重的警告。是的，你在尝试将双精度浮点数转换成整数。但它会编译。猜猜它打印什么？对，它打印8和7。它基本上将这些数值转换成整数，然后尝试做其他整数操，作。

这绝对不是你想要的结果。好的，明白了吗？当它说隐式转换时，是指编译时，还是在运行时它看双精度，浮点数，将其转换为整数，然后给你一个意外的结果？是的，隐式转换是在编译时完成的。所以当你按下运行时。

当它在编译时，它会看到哦，你在尝，试将 double 转换为 int，所以它会为你执行转换。然后在运行时，你会发现哦，它什么也没有打印。所以，另一种方法是，它们可以显示一个错误，以便我们意，识到这一点。

对，是的，完全正确。所以 C++ 可以在那儿显示一个错误，但记住 C++ 的一个，关键理念。不要，不要，这个理念是什么？不要，是的，基本上是给程序员完全的控制，如果他们想做，任何他们说要做的事情。

即使是错误的，C++ 也会让你这样，做。模板的一个重要特点是它会为你进行编译时检查。如果你输入错误，它有时会发现并告诉你，嘿，那不是你输，入的内容。问题，对吗？我知道这是一个隐式转换，它会起作用。

但如果你传入字符，串 "8" 和字符串 "7" 会发生什么？好问题。嘿，巧合的是，我这儿有这些东西，所以我们拿出来看看。好的，你可以看到这里，比如说，我们尝试使用字符，所以技，术上字符可以转换为整数。

所以这不是问题，即使这仍然有，点奇怪，但你可以这样做。如果你尝试使用字符串，那就不行，对吧？字符串不能隐式转换为整数。所以，不用担心模板是什么，如果你对模板一无所知，你会，怎么解决这个问题？

我们可以将其做成一个函数，并传入一个比较函数来比较，两个元素。传入一个函数。好的，所以你是说我们传入一个比较函数？是的。好的，这有点更高级。我们下周会讨论这个。但是，是的，我们很快会讨论这个。这有点。

假装你不知道它。那也需要模板，所以我们不要讨论那个，但，是的，你绝对正，确，这就是我们下周会做的事情。是吗？哦，这符合超时要求吗？哦，是的，一次。

你想要 Reese、Kit Kat 和 Hershey's 吗？Reese，Kit Kat。你想要 Kit Kat 吗？哦，你想要 Kit Kat，还有什么你想要的？好的，我们会给你一个 Reese。

哦，你可以重载那个 print、min 和 max 方法。当然。min 和 max 方法，然后分别为字符串、双精度数和字符串，提供一个。当然，好主意。这就是你在 C 中会做的事情。如果你在编码 C。

如果你们，中有些人正在上 107 课程，你将会这样做，因为那个函数，不起作用，所以我们写一个处理字符串的函数。那么你会如何编写函数本身？是的，所以如果 a 小于 b，你可以使用字母顺序比较字符，串。

然后返回 a，否则返回 b。好的？很好，这解决了这个问题。是的，这解决了这个问题。我们还需要为 print min 和 max 做同样的事情，所以我，们不做那个。那么你如何解决这个双精度数的问题？是吗？

在另一种方法中，你可以将你的输入或函数声明为 auto ，吗？有趣，所以你是说将这些做成 auto 吗？是的。这是个好问题。auto 可以用于许多地方，但它不能用于参数。所以，是的。

这是一个非常好的问题，基本上你不能在这里，使用 auto，否则会报错。你可以在返回类型中使用 auto，你可以在其他地方使用 ，auto，但你不能在这里使用 auto。但我们要做的是，模板。

就像在打印中使用 auto 一样。我可以因为那个问题要一个糖果吗？当然可以。好的，那么。Kit Kat。另外，我会指向你，如果你不说你想要什么，我就随便扔一，个东西给你。好的。我还想确保你们都保持警觉。

好吧，是的，这很不错。我们如何处理 double 类型呢？一样的处理。好的。好的，你知道吗？我就直接复制粘贴这个。是的，就这样。是的，这是个好点子。所以，幻灯片真的很漂亮，所以我会。好吧。

这就是我们写的，对吧？实际上，好吧，这就是我们写的。顺便说一下，有时候你会看到这样的情况，每个你调用的函，数，好吧，这些是 int 类型的，这些是 double 类型的，还，有字符串类型的。这很糟糕。

因为你必须在函数中实际写出 int。为什么要这样？哦，在 C 语言中你必须这样做，因为你不能重载？在 C 语言中你可以重载。是的。在 C 语言中你可以重载，但这是最基本的情况。如果你不知道重载函数。

你可以这样做。有时候对于星号来说。是的，我不打算讨论 void 星号，但这确实是一个使用它的，地方，对吧？所以，是的，这就是我们写的，对吧？好的，你注意到了什么？它们是如此冗余。好的，它们是冗余的。

对吧？好的，这是一个观察，这也是为什么我要有幻灯片，因为它，看起来真的很漂亮。注意那些高亮的部分。你注意到了什么？它们完全一样。就像，没什么不同，它们完全一样。你注意到的唯一区别是时间。所以。

让我们做你可能自然会做的事。好的，让我们用 T 来替代它们。好的，如果我用 T 替换它们，你注意到整个情况有什么不，同吗？一切都是一样的。是的，所以我们就把它们合并成一个吧。这样就有了一个通用函数。

现在，C++ 不知道那是一个通用函数。它查找类型 T，然后它想，哦，T 是什么？我实际上不知道 T 是什么。所以你必须实际告诉它，哦，这是一个模板。就是这样。模板非常复杂，但最基本的模板形式，就是这样。

我们告诉 C++ 我们在声明一个模板函数，它有不同的模板，变量。我们有一个模板叫 T，然后我们在不同的地方使用这个 T，是的？有没有不能模板化的东西？例如运算符？你可以模板化一个运算符。是的。

我认为可以。但我认为这实际上是它们的实现方式。有一些非常高级的 C++ 特性是通过模板化的运算符来实，现的。我们会讨论运算符。但一般来说，有没有不能模板化的东西？你可以模板化 Lambda 表达式。

你可以对类进行模板化。你可以模板化……，我遗漏了什么吗？你可以模板化很多东西。我们会讨论很多，但我现在想不到什么……，我的意思是，你不能模板化一个变量。虽然，是的，那些通常会这样做。

所以我会再回到这个问题上。我知道你会提到这一点，所以我们来看看。是吗？你能在 T 之外放入别的东西吗？或者放 B 吗？当然可以。或者在这种情况下用 B，但 T 小写。很棒的问题。

那么让我们过渡到输入代码，试试看。所以模板，类型名称，然后为了好玩，我们叫它……，你想叫什么？小写 T。好的。当然。然后在这里，我们会说，不是 int，而是 T，然后我们不需要，其他东西。是的。

这样可以。哦，哇。这很完美。关于这一点，还有一点就是，一旦你学会了这个结构，人们，会告诉你，他们其实希望你给类型名称起个能提供信息的，名字。所以，比如说，类型名称……，是的，你可以起任何你想要的变量名。

是的，不过……，我只是打算叫它 T。但我们以后会给它们更具信息性的名字，因为之后我们会，处理多个类型。所以你不想要 T……，T 后面是什么字母？T……，U。T-U-V-W。是的，你不想要那些。

所以作为一个例子，我们现在用 T，但以后我们会用其他名，字。是吗？是的，我有个问题。如果你尝试模板化一个不可比较的自定义结构体，那会不，工作吗？这是个很好的问题，我们会在 20 分钟后讨论。不。

不是 30 分钟，是在课堂结束时。20 分钟。是的，这和隐式接口和概念有关。但你提出了一个很好的点，对吧？这个函数假设你可以将一个 T 与另一个 T 进行比较。但，有些东西实际上你不能这样做。

所以我们会讨论这个。糖果？名字？任何人。好吧，没有人喜欢这些，所以我要给你这个。这些有……，它们很好吃。好的，等等。如果你有过敏症，你不应该吃这个，对吗？是的。这是一个好的类比，是的。你还好吗？好的。

如果 A 是 double 而 B 是……，很好问题。我们会在五分钟后讨论。糖果？不，我没事。好的。是吗？那么模板 T 的定义时间有多长？对于 printmin 和 max，我也可以使用 T 吗？

还是我需要再次声明模板类型名称 T？好问题。我认为……，安娜，如果我错了请纠正我。我认为你只能在这个地方使用它。你必须为每个函数重新定义。虽然我不确定。是的，我认为因为这是一个函数模板。

所以它是为紧接着的，函数定义的，当我们谈到类模板时，你可以在整个类中使用，它。糖果？我要去做了。当我说糖果时，你必须立即说出你想要什么糖果。否则，我就把你放到别的地方。是吗？

这是否具有类似于 Java 泛型的功能，你可以指定。你只能指定。它只会接受某些东西。这是一个很好的问题，我们很快会讲到。这与所谓的概念有关，这是 C++20 的特性。我们会讲到那个。在 Java 中。

他们称之为接口。接口，或者。我对 Java 不太熟悉。在 Java 中他们叫它什么？接口，对吧？是的，有类似的东西，但我们很快会讲到这个。你问的问题非常好，这些正是我将要讲解的内容。还有其他问题吗？

是吗？你能详细讲解一下这行是什么意思吗？看起来类型名称是变量类型，然后 T 是一个变量类型名称，什么是模板？好问题。模板本质上就是声明，好吧，接下来的是一个模板。然后类型名称意味着任何。

我们正在使用某种类型对其进行模板化。你实际上可以使用其他类型进行模板化。这就是说，好吧，T 是一个大小。你可以说，这就是你想要实现的东西。你也可以使用值进行模板化。但我们大多数情况下，对于我们的模板。

我们主要是使用类，型进行模板化。这就是为什么我们在这里说类型名称。对于类型名称，这意味着你可以放入整数，你可以放入双精，度，你可以放入自定义结构体，你可以放入任何东西。稍后我们会看到，我们会讲到类。

这意味着 T 必须是一个，类。所以整数和双精度将不起作用。你想要糖果吗？黑巧克力？没有黑巧克力。那就 Kit Kat 吧。好的。我们能否继续。我们先完成代码，然后再问更多问题。这一切都不起作用。

我们能否制定一个规则？你只能请求桌上现在有的糖果。让我先完成这个函数。我们进行了模板化。我们还需要模板化这个。所以 G，T。和。几乎所有的都有效。让我们试着运行它。你注意到了什么？最小值，最大值，很好。

最小值，最大值，很好。最小值，最大值，很好。最小值，是的，B 小于 L。这是正确的吗？哪个按字母顺序排在前面？所以 Anna 应该是最小值，然后 Avery 应该是最大值，对，吧？奇怪。

但我不会告诉你原因。我们先来谈谈实例化。那么什么是实例化？我们会做一些幻灯片，因为这些幻灯片也非常漂亮。好的，所以有两种方式。当你调用如 minimax 时，最清楚的指定 T 的方式是显式，实例化。

其中你在函数后面用括号明确指定类型。这种表示法，你可能见过类似的，当你尝试声明一个向量时，对吧？当你声明一个向量时，你把类型放在里面。所以你可能猜到，向量也是一个模板。这里，函数是一个模板。

你在里面指定 T 是什么。取消这些注释。顺便说一下，我真的很努力地弄清楚哪个部分应该注释，哪，个部分不应该。好了，我们这里有一个 int，double，string，int，double。好的。

这很有趣。一个 int 向量。所以 T 是一个 int 向量，然后我们传递的向量是，我们使，用统一初始化，1，2 和 3。我们还可以声明 times。这是开始时间和结束时间。

我没有打印向量的 minmax，但我确实打印了时间，你会看，到的。那么，让我们看看。这一切都很好。你在这里注意到了什么？这是正确的。发生了点奇怪的事情，对吧？Minmax 3，这很有意义。2 和 2。

3，这也很有意义。时间，它甚至能判断 3。30 在 4。20 之前。现在，稍微提一下，唯一能够编译的原因是如果你查看 ，temp。h，我定义了比较两个时间的意义。

因为 C++ 实际上不知道你说的比较时间是什么意思。我在这里定义了这些。我们还不会谈论这些。我们会在几周后讨论它们。但是问题是，如果你告诉 C++ 如何明确地比较时间，你可，以比较时间。有问题吗？

到目前为止我觉得很有意义。今天我们要讲的内容不多，所以我们可以稍后再深入讨论，有问题吗？如果你去掉那一行，模板，类型名称 T，因为我们已经提到，我们在内容中使用的变量类型，这样做有效吗？

你是说去掉这部分？去掉模板类型，类型名称 T。这一部分？问题在于，C++ 不知道 T 不是一个真实的类型。它是一个模板。这就像一个模板。你必须明确地说它是一个模板，才能让它知道，哦，T 不是。

一个真实的类型。它是一个在调用函数时会被填充的东西。到目前为止有问题吗？你想要更多糖果吗？我知道这可能有点泛泛而谈，但你能定义一下模板吗？模板一般是什么？模板是什么？它在内部如何结构化？它的目的是什么？

好问题。今天我们主要关注模板函数。我们只会模板化函数。还有更多的东西可以模板化，但这需要更深入的 C++ 知识，我们会在几周后讲到关于模板类的内容。你可以模板化很多东西。今天我们主要关注函数。

但我们会讨论这些。模板化某物是什么意思？这意味着在编写代码时，你在不确定的情况下以某种方式，编写代码，具体细节将在调用函数时确定。例如，让我们快速浏览一下……，再去看一下幻灯片。例如。

当你第一次调用 my minmax double 时，当编译器看，到这个时，编译器会说，好的，my minmax，我知道这是一个，函数，而这个函数是一个模板。它会尝试确定，好的，我的 T 是什么？

T 是 double。它的作用是将 double 替换为所有的双倍数。代码就是这样运行的。有趣的是，这一切都发生在编译时。当你编译代码时，所有这些函数，这些包含 T 被替换的函，数，都是在编译时生成的。

这是一个编译时的过程，当你按下编译时，所有这些函数都，是从那个模板中生成的。在运行时，一切都只是一样，就像我们自己写的一样。不过要注意，这仅发生在显式实例化时。当你进行隐式实例化时，一个好处是。

或者说好处或缺点是，它在运行时创建这些函数，因此你只会获得你在代码中直，接调用的函数。这可以是一个好处。如果你在代码中有很多额外的显式函数，它可能是一个缺，点，因为它会使你的编译时间更短。抱歉，对。

编译时间更短，但运行时间更短。我刚刚错过了。等一下，因为如果你用错误的类型实例化它，它会编译它。它会检查，但不会生成它。所以，是的，这基本上就是问题所在。是吗？你能给出每个 ID 的例子吗？

因为我们以后不会涵盖那个。我想在以后涵盖那个。好的。那边有一个问题。我有两个简短的问题。第一个是更机械化的问题。你说模板是整个函数，但我认为模板是类型。所以类型 T 不是模板吗？好的，让我想想词汇。

整个函数是一个模板函数。函数是一个模板。那个词不正确吗？它是一个……，是的，所以整个东西现在只被称为函数模板。它不再是一个函数。那我们怎么称呼 T？然后 T 是模板参数？好的，模板参数。

因为这些有点像参数。你用某个东西填充它，然后它变成箱子里的东西。第二个问题，抱歉。你能回到代码上吗？是的，所以如果你想放两个不同的类型，比如第一个数字是， double，第二个是整数，我们怎么做？哦。

好吧。所以你说给出两个不同的类型？是的。我们可以做这样的事情。我们叫它 T……，好的，我不知道我的字母。你可以这样做。所以你说，好的，T 是模板，U 是模板。是的。那么问题是，这样不太合理，因为你说。

我可以比较一个 ，int 和一个字符串。你怎么确定哪个是 int，哪个是字符串？所以这个函数实际上没有意义，因为它允许你比较不同的，类型。好的。我以为你只是一般性地向她展示一些东西，而那样的话，通。

常也会带到那里。我不知道你试图将它应用到那个函数中。是的。所以语法是这样的。你不能用这个函数，因为两个不同类型之间没有 min 和 ，max。但是语法会是这样的。我们很快就会做这个。

我们可能不会做到这一步。听着，你能不能添加第二种类型并用逗号调用这个函数？好的。就是你给我的那个。好的。嗯？那么这些类型名称会沿文件一直跟随吗？所以你在一个文件中有多个函数吗？是的。它只跟随函数。好的。

还有其他问题吗？我没有很多问题。嗯？当你使用类型名称 p 然后是类型名称 u 时，t 能否和 u ，一样？可以。你可以模板化函数吗？哦，意思是你传递一个函数？是的。可以的。因为那样你可以接受任意的函数。

是的。这就是本讲座的全部内容。好的。好问题。这里有问题吗？有。那么，当你进行显式实例化时，为什么 string 函数返回的，值会是？好问题。我本来打算稍后讲这个，但我现在会快速讲一下。

原因是字面量 Avery 的类型是什么？这是一个 C 字符串。所以要记住，它是一个 C 字符串，对吧？记得，106B。OX 的第一周，Cynthia 讲过 C 字符串与字符，串本身的不同。

字面量本身是一个 C 字符串，而比较 C 字符串是不好的，你真的不想比较 C 字符串。所以这里的原因是因为我之前声明了 Avery，这就是为什，么 C 字符串 Avery 小于 C 字符串。

但是我们可以通过显式指定字符串来解决这个问题，它会，查看这些 C 字符串，但它会说，等等，你想要一个字符串。T 是一个字符串，而不是 C 字符串。所以它将 C 字符串转换为字符串。好问题。

还有其他问题吗？是的，任何人都可以问。如果我们重载你有的函数，比如 my。min。max，使其适用于，所有类型，除了 int，然后用另一个定义重载 int，那它会，选择哪个？这是个很好的问题。好的。

这些问题都很棒，也很难。所以 C++ 有一些东西，当你创建一个模板时，它首先查看，所有可能的函数，包括所有模板和所有重载函数。我认为这叫做重载集合或其他什么东西。这些都是所有可行的函数。

然后它有一系列规则来确定哪，个是最好的选择。是的，但在这种情况下，当它试图解决这些冲突时，这两个，函数的签名完全相同。那么它会如何决定使用哪个？在 CppReference 上有一系列规则。

简短的答案是，不要这样做，因为这真的很混乱。但有一系列规则来确定哪个模板是最好的选择。而且它很可怕。我不理解这些。所以如果你不显式指定模板是什么，它会按照这些规则来，确定模板是什么。没有人会记住这些。

然后它会查看所有可能的类型。是的，确实有一种结构化的方法来做到这一点。还有其他问题吗？好，我们可以继续吗？我们继续吧。如果有问题，我们可以稍后再讨论。你现在的任务，非常简单。有人认识这个函数吗？

GetInteger。所以我们来将它模板化，现在可以用 get 代替 ，getInteger。所以现在在你的笔记本电脑上，尝试把它写成 get ，something。基本上就是模板化它。

不要返回一个 int，而是让它返回某种任意类型。这样说有意义，对吧？作为我们将如何使用这个的一个例子，我们将这里。作为我们将如何使用这个的一个例子，我们将说，好，getTypeValue 和 int。

这会提示用户输入一个整数。GetValueType，int，好的。GetValueType，double，提示用户输入一个 double。GetValueType，time，它提示用户输入一个时间。

好的，所以现在尝试将它模板化。应该很简单。那么你做了什么？你在顶部声明了模板，然后用 t 代替 int 来获取那个值，然后 typeId int，你也会将其更改为 t。结果呢？对，结果也应该是 t。

一切都编译通过了。现在试着运行一下。顺便说一下，你不必了解 typeId 的作用。在周末，我花了很多时间尝试让它打印 enter 和 int。但问题是，我的编译器对 int 做了奇怪的处理，所以它显。

示的是 i。假设是 3，因为它有两个 int。假设我们用了 6。8 的有效格式，因为它知道 t 是 int，它，不能将 6。8 读入其中。输入 double，3。0，输入 a，它称之为时间。

并且这是一个结，构体。然后我特别指示它，可以像这样输入时间。它会选择一个类型 int，还是你自己选择的？我在这里选择了它的类型。我说，要求用户输入一个 int、一个 int、一个 double 。

int。这是一个显式实例化。我们跳过很多隐式实例化的部分，因为没有太多内容需要，讲解。唯一需要讲解的是，有时候你会遇到歧义，这就是隐式实例，化问题所在。所以这里，编译器足够智能，知道 t 需要 4。2。

一个 ，double，这里 t 是一个 double。这里的 t 是什么？t 是一个 C 字符串，所以这将不起作用。你可以做几件事，你可以传递一个字符串，这样它就会转换，为一个字符串。

或者你可以显式实例化它。问题，是吗？如果你有一个情况，你可能传递一个整数或一个向量，你会，一直传递引用，还是有其他方法可以在之后选择？好问题。如果是大集合，我会这样做。我想确实有一种方法，你可以说。

如果是类，而不是输入类，那么它将按引用传递。但我认为这肯定会有效。还有其他问题吗？那么如果你传递了一个 int 和一个 double，会发生什么？它会将它们都变成 double，还是都变成 int。

还是会保持，它们的类型？好问题。所以在这里，你会看到它给你一个编译器。它说，好，t 是一个 int，但它意识到 2。3 不是 int，所以，这不起作用。所以在这种情况下，你会添加另一个类型，对吧？是的。

但你不真的想对 minmax 做那样的事，因为这允许你，给出不可比较的类型，比如 int 和 string。是吗？为什么不会自动将 double 转换为 int？模板有关于特定转换的特殊规则。

所以我认为它尽可能严格。当你使用模板时，它不会做任何隐式类型转换。好问题。好吧，你能猜到为什么这不工作吗？为什么这两个不工作？哦，这个也不工作。为什么这些不工作？Vector，time。

还有这个是一个 patient string。如果你上过这些课程，你已经知道那是什么了。是的，为什么那些不工作？什么是 patient 结构体？是的。好，首先，光看这些，你知道哪个是 time 吗？

不是特别清楚，对吧？是的，这正是重点，我们使用这个统一初始化的方式，所以，它不知道是什么类型的。所以让我们把这些拿出来。让我们快速进入下一部分。好吧，显然我们没有谈论真正有趣的内容。可变参数。

如果你想了解更多，跟我说。好，我们来谈谈泛型编程。所以我们将编写泛型函数，我们为什么要编写泛型函数？泛型函数让我们可以编写可以在多种不同上下文中使用的，函数。它足够灵活。

无论你有何种问题或想进行何种操作，你都可，以使用类似的单个函数来解决。好？你可以想象这有多有帮助。它一个接一个地重复。它也给你一个非常强大的函数，可以在任何上下文中使用，例如，我们将编写一个单一的函数。

可以解决所有这些问题，例如，计算某个元素在某个列表中出现的次数。计算 5 在列表的后半部分中出现的次数。计算一个元素在列表的后半部分中出现的次数，最多为 5 ，次。好？有一种叫做概念提升的东西。

本质上我们将从一个函数开，始，然后我们将质疑我们对函数的假设。利用这些假设，我们将尝试给函数添加模板，以使其更有趣，举个例子，看看这个函数。所以这个函数本质上计算一个整数值在整数向量中出现的，次数。好？

明白了吗？这个函数很简单明了。这个函数对自身做了一些不必要的假设。当然。所以你可以查看一下，好的，整数。它必须是整数吗？它可以是其他任何东西的向量吗？好。所以这是一个我们可以放松的好假设。

为了放松这个假设，我们可以给它添加一个模板。所以不必说它必须是 int，我们可以说它可以是任何类型，的 int。所以如果数据类型在这里，数据类型是。明白了吗？你们当中有没有些是 Jerry 学生？

我简直不敢相信没有人发现这一点。所以它必须是一个向量吗？好问题。那么它必须是一个向量吗？好的？让我们将其模板化。所以，代替向量，你有一个数据类型的集合。哦，只是一个问题。当然。哦，抱歉。没关系。哦。

好吧。只是一个问题。如果你在迭代一个映射，你难道不需要使用迭代器而不是，使用 size_t 吗？很好。这段代码不起作用。为什么？因为如果集合是一个映射或集合，它们是不可索引的。

你不能使用 size_i 等于 0，i 小于它的大小，i 加上我的，大小。你不能那样做。这就是迭代器的强大之处。迭代器提供了一个统一的接口，用于遍历集合中的元素。例如，如果我们使用列表。

列表是不可索引的，所以这将无，法编译。原因是因为我们使用了这种数组表示法，而在。基本上，它只允许在向量中使用。所以，我们可以通过一种方式解决这个问题，即我们需要迭，代器。这里有一个更通用的类型。

即我们不是遍历索引，而是遍历，迭代器。这仍然做出了一个假设。你看到这个假设是什么了吗？你确定吗？是的。这是一个常量吗？好点子。所以，如果它是常量，那即使你传入的是非常量或常量，两，者都会起作用。哦。

我明白了。如果你将它设为非常量，那么你不能传入一个常量。不过，你提出了一个好点子。我可能应该做。数据类型不必是常量。是的，这是一个好点子。如果我们去掉常量，那么我们不能传入常量集合。是吗？

它是否假设双等号有效？双等号，好吧。好点子。所以，让我们看看。哦，双等号是否一定有效？你是在说这是。这是一个问题还是一个假设？我只是说，如果双等号在其他情况下不起作用，那么你需要，使用点等号方法。

好点子。好的，那么，让我们看看。我怎么回答这个问题？是的，这个函数确实假设双等号有效。我不确定是否应该使用点等号，因为整数可能会无效。但我们下次会更详细地讨论这个问题，在那里你传入的集。

合的数据类型必须是可比较的。这实际上是在 later slides 中关于 inless 和 ，ineffects 的内容。假设，是吗？这不假设你遍历整个集合吗？是的，太棒了。

这假设我们正在遍历整个集合。记住，如果我们回顾之前的问题，有一个问题是，我们能否，计算列表的第二半部分有多少个？那么，我们怎么做呢？我们怎么可以传入集合中的一个范围，而不是整个集合呢？你先举手了。是吗？

你能传入一个对吗？很好。让我们传入两个迭代器。所以，我们有一个迭代器开始，一个迭代器结束，以及一个，数据类型。快速问题。我把这个命名为输入迭代器。为什么它必须是输入的？

为什么我不说随机访问迭代器和输入迭代器？是的。因为并非所有集合都有输入迭代器，因此这将使我们的函，数仅能用于具有随机访问迭代器的集合。例如，我本来打算给你展示这个，但我们时间不够，这里是。

写这个函数的一个不好的方式。写这个函数的一个不好的方式是这样。这是写这个函数的一个不好的方式。在这里，你可以看到我们在移动索引，然后我们尝试计算起，始位置加上某个数字。本质上。

是将那个迭代器前移一定的量。这不起作用，因为这对这个迭代器有什么假设？假设它是随机的。是的。假设这个迭代器是一个随机访问迭代器。我们希望尽可能少地假设关于那个迭代器的内容。

迭代器唯一需要做的就是能够读取元素本身。它不需要做其他任何事情。这就是为什么我们指定这个应该是一个无限迭代器。关键在于，这只是一个名称，所以它不强制执行。你会在编译时遇到奇怪的错误。如果需要。

你可以这样做。我只是这样做。你怎么解决这个问题？并发到最小值。你怎么解决这个问题？你怎么解决这个问题？等等。如果你想要第二部分，那么你可以传递中间迭代器。我们还不能解决这个问题。

因为这需要一个叫做信用工具，包的东西。如果有人问这个问题，你必须传递一个函数。我们下次会讲到这个。这匹配了一个非常酷的函数。我在周末发现了它，但我们没有时间去讲这个。我们今天基本上讲了我们想讲的内容。

我在想，也许我们可以讲到这个，但我们下次会从这里开始，因为这个隐式接口基本上涉及到你们很多问题，即我们对，不同类型有什么假设？我们对传入的类型有什么假设？因此，我们需要思考这个问题。下次会很酷。

辛迪在第一天的课堂上做了一个汉密尔顿示例。我要做一个更好的汉密尔顿示例。是的，我要写一个程序，屏蔽汉密尔顿中的所有坏组，我不，会使用任何公式。一个公式都不用。如果你想要糖果，就过来拿。谢谢你们。好了。

你们想要选择。你们都想去外面吗？等一下，安娜，不要就这样出去。我们就出去吧。

![](img/09ab7f555a33b141c1d158d778f655d6_3.png)

好吧，就在这里吧。小心点。