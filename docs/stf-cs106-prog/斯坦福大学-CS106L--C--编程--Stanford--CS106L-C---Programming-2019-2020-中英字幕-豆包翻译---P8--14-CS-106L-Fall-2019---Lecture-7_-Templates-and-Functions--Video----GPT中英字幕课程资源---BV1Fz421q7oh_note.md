# 课程 7：模板与函数 🧩

在本节课中，我们将学习如何编译和运行C++程序，并深入探讨模板函数、隐式接口以及如何使用Lambda表达式来编写更通用的代码。

## 编译与运行C++程序

上一节我们介绍了C++编程的基础，本节中我们来看看如何将代码转换为可执行程序。

要编译代码，你需要选择一个编译器。例如，使用G++编译器。你需要输入`g++`命令，并指定一些标志来控制编译过程。

以下是编译步骤：
1.  指定编译器：`g++`
2.  指定C++标准版本：例如 `-std=c++17`
3.  指定要编译的源文件：例如 `HelloWorld.cpp`
4.  使用 `-o` 标志指定输出文件名：例如 `-o HelloWorld`
5.  运行生成的可执行文件：`./HelloWorld`

完整的编译命令如下：
```bash
g++ -std=c++17 HelloWorld.cpp -o HelloWorld
```
这个命令将`HelloWorld.cpp`文件编译成一个名为`HelloWorld`的二进制可执行文件。运行`ls`命令，你可以看到新生成的`HelloWorld`文件。执行`./HelloWorld`即可运行程序。

**注意**：不要随意运行从网络下载的未知可执行文件，尤其是在终端中使用`sudo`（root权限）运行，这可能对系统造成危险。

## 模板与隐式接口

现在，让我们回顾并深化对模板的理解。上周我们编写了一个通用的`minmax`函数模板。

模板通过`template <typename T>`声明，它定义了一个自定义类型`T`，使得函数可以处理多种数据类型。这个过程称为“概念提升”，即我们不断泛化函数，减少对参数类型的假设。

考虑以下计算元素出现次数的泛化过程：
1.  最初，函数只能计算`vector<int>`中某个整数的出现次数。
2.  然后，我们将其泛化为可以计算任何类型`T`的`vector<T>`。
3.  进一步，我们使其能处理任何容器类型。
4.  最终，我们使其能处理任何迭代器范围。

当我们调用模板函数时，编译器会尝试推断类型。代码本身对类型提出了“隐式接口”要求。例如，在遍历迭代器时，要求迭代器可以被解引用、递增，并且解引用的结果可以与另一个值进行比较。

如果传入的类型不满足这些隐式要求，编译将失败，并可能产生冗长复杂的错误信息。C++20引入了“概念（Concepts）”特性，允许程序员显式地指定模板参数的接口要求，这能使错误信息更清晰。

## 从函数到Lambda表达式

我们之前编写的`countOccurrences`函数计算的是等于某个特定值的元素个数。我们可以将其进一步泛化。

我们可以不检查“等于某个值”，而是检查元素是否满足某个更通用的条件（谓词）。谓词是一个返回布尔值的函数。

例如，我们可以计算范围内有多少个元素小于5。这不再局限于相等性比较。我们可以定义一个谓词函数`isLessThan5`，然后将其传递给泛化的`countOccurrences`函数。

然而，使用独立的谓词函数有两个问题：
1.  需要为每个不同的条件（如小于5、大于10）单独编写函数，很繁琐。
2.  难以向谓词传递额外的参数（例如，我们想检查是否小于一个变量`limit`，而不是固定的5）。

C++11引入了Lambda表达式来解决这些问题。Lambda允许你内联地定义一个匿名函数对象。

一个Lambda表达式的基本语法如下：
```cpp
auto lambda = [/*捕获列表*/](/*参数列表*/) -> /*返回类型*/ {
    // 函数体
};
```
例如，创建一个检查是否小于某值的Lambda：
```cpp
int limit = 5;
auto isLessThan = [limit](int value) -> bool {
    return value < limit;
};
// 使用
bool result = isLessThan(3); // 返回 true
```
Lambda的“捕获列表”`[limit]`允许Lambda访问其定义作用域中的变量`limit`。变量可以通过值（默认）或引用（使用`&`）被捕获。

这使得创建高度可定制的谓词变得非常方便，无需定义独立的函数，并且可以轻松封装所需的状态。

## 总结

本节课中我们一起学习了：
1.  如何使用`g++`编译器和相关标志来编译和运行C++程序。
2.  模板函数的隐式接口概念，以及代码如何对类型提出要求。
3.  如何通过谓词将函数泛化，以及使用独立函数作为谓词的局限性。
4.  Lambda表达式的语法和强大功能，它允许我们内联创建可捕获外部状态的函数对象，从而编写出更简洁、更灵活的通用代码。

掌握Lambda表达式是有效使用C++标准库算法的基础，我们将在后续课程中进一步探索。