![](img/d6a70f0f589203816f7e5c17270c398c_1.png)

# 课程13：链表操作与内存管理 🧠

在本节课中，我们将学习链表的基本操作，包括在链表头部和尾部添加节点，以及删除节点。我们还将探讨如何通过引用传递指针来修改链表，并介绍C++中内存管理的基本概念，特别是如何避免内存泄漏。

---

![](img/d6a70f0f589203816f7e5c17270c398c_3.png)

![](img/d6a70f0f589203816f7e5c17270c398c_5.png)

## 概述

链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。本节课我们将重点学习如何操作链表，包括添加和删除节点，并理解指针在链表操作中的关键作用。

![](img/d6a70f0f589203816f7e5c17270c398c_7.png)

---

![](img/d6a70f0f589203816f7e5c17270c398c_9.png)

## 链表回顾 📝

上一节我们介绍了链表的基本概念和结构。链表由节点组成，每个节点包含数据和一个指向下一个节点的指针。我们编写了遍历链表的代码，例如打印链表中的所有元素。

![](img/d6a70f0f589203816f7e5c17270c398c_11.png)

以下是遍历链表并打印元素的代码示例：

![](img/d6a70f0f589203816f7e5c17270c398c_13.png)

![](img/d6a70f0f589203816f7e5c17270c398c_15.png)

![](img/d6a70f0f589203816f7e5c17270c398c_17.png)

```cpp
void printList(ListNode* front) {
    ListNode* current = front;
    while (current != nullptr) {
        cout << current->data << " ";
        current = current->next;
    }
    cout << endl;
}
```

在这段代码中，我们使用一个临时变量 `current` 来遍历链表，而不是直接移动 `front` 指针，以保持链表头部的完整性。

---

## 在链表头部添加节点 ➕

本节中我们来看看如何在链表的头部添加一个新节点。这是一种高效的操作，因为它只需要常数时间，而不需要遍历整个链表。

### 基本思路

![](img/d6a70f0f589203816f7e5c17270c398c_19.png)

1. 创建一个新节点。
2. 将新节点的 `next` 指针指向当前链表的头部。
3. 将链表的头部指针更新为新节点。

以下是实现这一操作的代码：

```cpp
void addFront(ListNode*& front, int value) {
    ListNode* newNode = new ListNode;
    newNode->data = value;
    newNode->next = front;
    front = newNode;
}
```

### 关键点

- 函数参数 `front` 是一个指向指针的引用（`ListNode*&`），这样我们才能修改调用函数中的 `front` 指针。
- 如果 `front` 是通过值传递的，修改它只会影响函数内部的局部变量，而不会影响原始链表。

![](img/d6a70f0f589203816f7e5c17270c398c_21.png)

---

## 在链表尾部添加节点 ➕

![](img/d6a70f0f589203816f7e5c17270c398c_23.png)

现在，我们来看看如何在链表的尾部添加一个新节点。这需要遍历链表以找到最后一个节点，然后将新节点附加在其后。

![](img/d6a70f0f589203816f7e5c17270c398c_25.png)

### 基本思路

![](img/d6a70f0f589203816f7e5c17270c398c_27.png)

1. 如果链表为空，直接将新节点设置为头部。
2. 否则，遍历链表直到最后一个节点。
3. 将最后一个节点的 `next` 指针指向新节点。

以下是实现这一操作的代码：

![](img/d6a70f0f589203816f7e5c17270c398c_29.png)

```cpp
void addBack(ListNode*& front, int value) {
    if (front == nullptr) {
        front = new ListNode(value);
        return;
    }
    ListNode* current = front;
    while (current->next != nullptr) {
        current = current->next;
    }
    current->next = new ListNode(value);
}
```

### 关键点

- 必须处理链表为空的情况，否则在遍历时会引发错误。
- 循环条件是 `current->next != nullptr`，这样 `current` 会停在最后一个节点，而不是越过它变为 `nullptr`。

---

## 从链表头部删除节点 ➖

接下来，我们学习如何从链表的头部删除一个节点。这涉及到更新头部指针并释放被删除节点的内存。

### 基本思路

1. 如果链表为空，则无需操作。
2. 否则，保存当前头部节点到一个临时指针。
3. 将头部指针移动到下一个节点。
4. 删除临时指针指向的节点以释放内存。

以下是实现这一操作的代码：

```cpp
void removeFront(ListNode*& front) {
    if (front == nullptr) {
        return;
    }
    ListNode* garbage = front;
    front = front->next;
    delete garbage;
}
```

![](img/d6a70f0f589203816f7e5c17270c398c_31.png)

### 关键点

![](img/d6a70f0f589203816f7e5c17270c398c_33.png)

- 必须使用 `delete` 释放内存，否则会导致内存泄漏。
- 删除节点的顺序很重要：先移动头部指针，再删除旧节点。

---

![](img/d6a70f0f589203816f7e5c17270c398c_35.png)

## 内存管理 🗑️

在C++中，动态分配的内存（使用 `new`）必须手动释放（使用 `delete`），否则会导致内存泄漏。内存泄漏是指程序不再使用的内存没有被释放，从而无法被重新利用。

![](img/d6a70f0f589203816f7e5c17270c398c_37.png)

![](img/d6a70f0f589203816f7e5c17270c398c_39.png)

### 避免内存泄漏

![](img/d6a70f0f589203816f7e5c17270c398c_41.png)

- 每次使用 `new` 分配内存后，确保在适当的时候使用 `delete` 释放它。
- 在链表操作中，删除节点时务必释放该节点的内存。

![](img/d6a70f0f589203816f7e5c17270c398c_43.png)

![](img/d6a70f0f589203816f7e5c17270c398c_45.png)

例如，在删除链表节点时：

![](img/d6a70f0f589203816f7e5c17270c398c_47.png)

![](img/d6a70f0f589203816f7e5c17270c398c_49.png)

![](img/d6a70f0f589203816f7e5c17270c398c_51.png)

```cpp
ListNode* garbage = front;
front = front->next;
delete garbage; // 释放内存
```

![](img/d6a70f0f589203816f7e5c17270c398c_52.png)

---

![](img/d6a70f0f589203816f7e5c17270c398c_54.png)

![](img/d6a70f0f589203816f7e5c17270c398c_56.png)

## 总结

本节课我们一起学习了链表的基本操作，包括在头部和尾部添加节点，以及从头部删除节点。我们还探讨了如何通过引用传递指针来修改链表，并介绍了C++中内存管理的基本概念，特别是如何避免内存泄漏。

![](img/d6a70f0f589203816f7e5c17270c398c_58.png)

通过绘制指针图和编写代码，我们加深了对链表操作的理解。记住，链表操作的关键在于正确处理指针和内存管理，尤其是在修改链表结构时。

---

![](img/d6a70f0f589203816f7e5c17270c398c_60.png)

**注意**：本教程根据提供的视频内容整理，旨在帮助初学者理解链表操作的基本概念和实现方法。在实际编程中，请根据具体需求调整代码，并始终注意内存管理。