![](img/918ecf73de3563c49c625cc13afa9fce_1.png)

# 斯坦福大学《CS106L：C++编程》课程笔记 - 第10讲：类与常量正确性 🧱

![](img/918ecf73de3563c49c625cc13afa9fce_3.png)

在本节课中，我们将学习C++中类的核心概念，并深入探讨`const`关键字的各种用法和重要性。理解`const`是编写安全、高效且易于维护的C++代码的关键。

![](img/918ecf73de3563c49c625cc13afa9fce_5.png)

![](img/918ecf73de3563c49c625cc13afa9fce_7.png)

## 课程回顾：STL算法应用

![](img/918ecf73de3563c49c625cc13afa9fce_9.png)

![](img/918ecf73de3563c49c625cc13afa9fce_11.png)

上一节我们介绍了如何使用STL算法解决“联邦论文”作者归属问题。本节中，我们来看看该解决方案的总结与实现细节。

我们尝试解决的问题是：给定一系列已知作者的文章和一篇未知作者的文章，能否通过计算特定“常见词”在文本中出现的频率（即特征向量），并使用向量夹角（通过点积计算）来判断未知文章的作者？夹角越小，文本越相似。

以下是实现过程中的关键步骤：

1.  **读取文件并转换为字符串**：首先，我们需要从文件中读取文本内容。
2.  **计算词频**：对于特征向量中的每个词，计算它在文本字符串中出现的次数。这里不能使用`std::count`算法，因为它只能统计单个字符。
3.  **使用`std::search`算法**：为了统计一个**字符串**在另一个字符串中出现的次数，我们使用了`std::search`算法。其核心逻辑是一个`while`循环，不断在文本中搜索目标词的下一次出现。

    ```cpp
    // 伪代码逻辑
    while (未到达文本末尾) {
        found_pos = std::search(文本起始, 文本结束, 目标词起始, 目标词结束);
        if (未找到) break;
        计数增加;
        将搜索起始位置设为找到位置之后;
    }
    ```
4.  **计算相似度**：通过计算两个特征向量的点积来衡量相似度。这里可以直接使用STL中的`std::inner_product`算法。
5.  **计算向量模长**：一个向量的模长等于该向量与自身点积的平方根，即 `magnitude = sqrt(dot_product(vec, vec))`。

![](img/918ecf73de3563c49c625cc13afa9fce_13.png)

![](img/918ecf73de3563c49c625cc13afa9fce_15.png)

![](img/918ecf73de3563c49c625cc13afa9fce_17.png)

至此，我们完成了对STL容器和算法单元的总结。接下来，我们将开启新的主题。

## 面向对象编程与类基础回顾

![](img/918ecf73de3563c49c625cc13afa9fce_19.png)

![](img/918ecf73de3563c49c625cc13afa9fce_21.png)

![](img/918ecf73de3563c49c625cc13afa9fce_23.png)

![](img/918ecf73de3563c49c625cc13afa9fce_25.png)

在进入新内容前，我们先简要回顾面向对象编程（OOP）和类的基础知识。C++支持多种编程范式，OOP是其最常用的方式之一。

![](img/918ecf73de3563c49c625cc13afa9fce_27.png)

![](img/918ecf73de3563c49c625cc13afa9fce_29.png)

以下是OOP的核心概念，我们将在后续课程中深入探讨：
*   **类、对象与封装**：将数据和对数据的操作封装在一起。
*   **运算符重载**：赋予自定义类型与内置类型相似的操作符行为。
*   **继承**：实现代码复用和层次化设计。
*   **多态与虚函数**：实现接口统一，运行时动态绑定。

关于类的实现，有两个关键文件：
*   **头文件 (.h/.hpp)**：用于声明类的接口（API），即公有成员函数和变量。这是类对外的承诺。
*   **源文件 (.cpp/.cc)**：用于实现头文件中声明的函数，隐藏复杂的内部细节。

![](img/918ecf73de3563c49c625cc13afa9fce_31.png)

![](img/918ecf73de3563c49c625cc13afa9fce_33.png)

![](img/918ecf73de3563c49c625cc13afa9fce_35.png)

![](img/918ecf73de3563c49c625cc13afa9fce_37.png)

此外，还有几个基本概念：
*   **构造函数/析构函数**：用于对象的初始化和清理。
*   **`const`成员函数**：承诺该函数不会修改类的成员变量。

## 深入理解`const`关键字 🔒

![](img/918ecf73de3563c49c625cc13afa9fce_39.png)

`const`是C++中一个历史悠久且功能强大的关键字，它能显著提升代码的安全性和可读性。本节我们将详细解析`const`的各种用法。

![](img/918ecf73de3563c49c625cc13afa9fce_41.png)

### 为什么使用`const`？

![](img/918ecf73de3563c49c625cc13afa9fce_43.png)

使用`const`主要基于以下几点原因：
1.  **安全性**：防止意外修改不应改变的数据。
2.  **接口清晰**：明确告知函数调用者，哪些参数或返回值是只读的。
3.  **编译器优化**：编译器可以利用`const`信息进行更好的优化。
4.  **设计约束**：强制实施设计意图，避免全局变量等难以推理的用法。

![](img/918ecf73de3563c49c625cc13afa9fce_45.png)

考虑以下场景：一个函数本应只计算地球的人口，但其内部实现却错误地修改了地球对象。如果将参数声明为`const`引用，编译器就能在编译期捕获这个错误，避免运行时灾难。

![](img/918ecf73de3563c49c625cc13afa9fce_47.png)

```cpp
// 错误：函数可能意外修改planet
int countPeople(Planet& p);

![](img/918ecf73de3563c49c625cc13afa9fce_49.png)

![](img/918ecf73de3563c49c625cc13afa9fce_51.png)

![](img/918ecf73de3563c49c625cc13afa9fce_53.png)

// 正确：函数承诺不修改planet
int countPeople(const Planet& p); // 安全！
```

![](img/918ecf73de3563c49c625cc13afa9fce_55.png)

### `const`与指针

当`const`与指针结合时，需要仔细区分两种常量性：
*   **指针本身是常量**（指针不能指向别的地址）。
*   **指针所指向的数据是常量**（不能通过该指针修改数据）。

以下是三种常见情况：
```cpp
int* const p1 = &a; // p1是常量指针，指向非常量int（指针不能变，值能变）
const int* p2 = &a; // p2是非常量指针，指向常量int（指针能变，值不能变）
const int* const p3 = &a; // p3是常量指针，指向常量int（指针和值都不能变）
```
**记忆口诀**：从右向左读。`const`修饰它左边最近的东西（如果左边没东西，则修饰它自己）。

### `const`与迭代器

迭代器的`const`行为与指针类似，但需要注意STL中专门定义了`const_iterator`类型。
*   `const std::vector::iterator itr;` 相当于**常量指针**，迭代器本身（`itr++`）不能移动，但可以修改它指向的元素（`*itr = 5;`）。
*   `std::vector::const_iterator itr;` 是**指向常量的迭代器**，迭代器本身可以移动（`itr++`），但不能修改它指向的元素。

### `const`成员函数

在类中，可以将成员函数声明为`const`，这表示该函数不会修改类的任何成员变量（除非成员被`mutable`修饰）。这对于在常量对象上调用函数至关重要。

```cpp
class MyClass {
public:
    int getValue() const; // 常量成员函数，可在常量对象上调用
    void setValue(int v); // 非常量成员函数，不能在常量对象上调用
};

const MyClass obj;
obj.getValue(); // 正确
obj.setValue(10); // 编译错误！
```

**常量正确性规则**：一个常量对象只能调用其常量成员函数。

## 总结与最佳实践

本节课中我们一起学习了C++中类的初步知识，并深入探讨了`const`关键字的强大功能。

以下是关于`const`的最佳实践总结：
1.  **尽可能使用`const`**：标记所有不应被修改的变量、参数和成员函数为`const`。这是一种良好的设计和承诺。
2.  **优先按`const`引用传递**：对于非基本类型（如自定义类、`std::string`、`std::vector`），应优先按`const`引用传递，以避免不必要的拷贝，同时保证数据不被修改。基本类型（如`int`, `double`）通常按值传递即可。
3.  **理解指针/迭代器的双重`const`**：始终清楚你希望限制的是指针本身，还是指针指向的数据。
4.  **使用`const`成员函数设计类接口**：明确区分会修改对象状态的函数和不会修改的函数。这使你的类更安全、更易用。

![](img/918ecf73de3563c49c625cc13afa9fce_57.png)

![](img/918ecf73de3563c49c625cc13afa9fce_59.png)

掌握`const`正确性是成为熟练C++程序员的重要一步。它不仅是编译器的检查工具，更是表达程序设计意图、编写健壮代码的核心机制。