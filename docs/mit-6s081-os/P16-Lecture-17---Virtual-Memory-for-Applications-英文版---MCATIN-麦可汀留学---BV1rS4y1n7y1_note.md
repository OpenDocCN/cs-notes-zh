![](img/34aa4f9fc39dabb7509d4bcc7255c15b_0.png)

# 课程 P16：第17讲 - 应用程序的虚拟内存 🧠

在本节课中，我们将学习操作系统如何将虚拟内存的强大能力开放给用户应用程序。我们将探讨一篇经典论文提出的核心观点，了解现代操作系统（如Linux）如何通过系统调用实现这些功能，并通过具体的应用实例（如大表缓存和垃圾回收器）来理解其工作原理和优势。

---

## 概述

虚拟内存是操作系统的核心机制，传统上主要由内核使用。然而，用户应用程序同样可以从类似的机制中受益。本节课将介绍如何通过特定的系统调用，让应用程序能够更灵活地管理自己的内存，例如处理页面错误、动态调整内存区域的访问权限等。我们将从理论基础开始，逐步深入到具体实现和应用案例。

---

## 核心虚拟内存原语

上一节我们概述了用户程序使用虚拟内存的可能性。本节中，我们来看看实现这种能力所需的核心原语（Primitives）。论文指出，尽管应用程序需求多样，但它们都依赖于少量共同的虚拟内存原语。

以下是实现用户级虚拟内存功能所需的关键原语：

1.  **陷阱（Trap）**：允许在内核中发生的页面错误传播到用户空间。用户空间可以安装一个处理程序来响应这些错误。
    *   **代码描述**：类似于 `signal(SIGSEGV, handler)` 安装信号处理程序。
2.  **降低可访问性（Reduce Accessibility）**：降低一个或多个内存页面的访问权限（例如，从可读写变为只读，或变为完全不可访问）。
    *   **公式描述**：`mprotect(addr, len, PROT_READ)` 将区域设置为只读。
3.  **提高可访问性（Increase Accessibility）**：提升内存页面的访问权限（例如，从只读恢复为可读写）。
4.  **查询脏页（Dirty）**：找出哪些页面已被修改（变“脏”）。
5.  **双重映射（Map2）**：允许将同一物理内存区域以不同的访问权限映射到同一地址空间的多个虚拟地址范围。

在这些原语中，**陷阱**和**保护（Protection）**（即改变可访问性）是最核心的。现代UNIX系统（如Linux）通过一系列系统调用提供了这些功能的等价实现。

---

## 现代UNIX的系统调用实现

上一节我们介绍了理论上的原语。本节中我们来看看这些概念在现代操作系统中是如何具体实现的。Linux等系统提供了一组系统调用，几乎可以直接映射到上述原语。

以下是关键的系统调用及其作用：

*   **`mmap`**：将对象（如文件或匿名内存）映射到调用进程的地址空间。这是实现内存映射文件等功能的基础。
    *   **代码描述**：`void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
*   **`mprotect`**：更改已映射内存区域的保护（访问权限）。
    *   **代码描述**：`int mprotect(void *addr, size_t len, int prot);`
*   **`munmap`**：删除指定地址范围的映射。
*   **`sigaction`**：允许应用程序为特定信号（如 `SIGSEGV` 段错误）安装处理程序。这实现了“陷阱”原语，使用户代码能响应页面错误。
    *   **代码描述**：`int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);`

通过这些系统调用，应用程序获得了管理自身虚拟内存的强大工具。其中，`mmap` 和 `sigaction` 尤为重要。

![](img/34aa4f9fc39dabb7509d4bcc7255c15b_2.png)

---

![](img/34aa4f9fc39dabb7509d4bcc7255c15b_4.png)

## 操作系统内部支持机制

上一节我们看到了用户态可用的接口。本节中我们深入一步，看看操作系统内部是如何支持这些功能的。这主要涉及两个关键数据结构：VMA（虚拟内存区域）和用户级陷阱的处理流程。

**虚拟内存区域（VMA）**
操作系统内核使用VMA来跟踪进程地址空间中每个连续区域的信息。每个VMA记录了一段地址范围的起始、长度、权限以及背后映射的对象（例如一个文件）。当应用程序调用 `mmap` 时，内核就会创建一个新的VMA来记录这次映射。

**用户级陷阱处理流程**
1.  应用程序访问了一个权限不足或未映射的页面，触发硬件页面错误。
2.  CPU陷入内核模式，内核保存现场并查询VMA等数据结构，确定错误原因。
3.  如果该错误对应一个用户安装的 `SIGSEGV` 处理程序，内核将控制权传递给该用户态处理函数。
4.  用户处理函数执行（例如，调用 `mprotect` 修改权限），然后返回。
5.  内核恢复被中断的进程现场。如果错误原因已被处理（如权限已修复），指令将重新执行；否则可能再次陷入内核。

这个机制确保了用户程序能够安全、高效地响应内存访问事件。

---

## 应用实例一：大表缓存

上一节我们了解了内核的支持机制。本节中我们来看一个具体的应用实例，展示如何使用这些原语实现一个“大表缓存”。这个例子虽然简单，但能清晰体现用户级虚拟内存的威力。

**场景**：假设有一个计算非常耗时的函数 `f(i)`。我们希望预计算所有 `i` 对应的 `f(i)` 并存入一个大表，后续查询只需查表，避免重复计算。但此表可能极大，无法全部装入物理内存。

**解决方案**：
1.  使用 `mmap` 分配一块巨大的虚拟地址空间用于存放表，但**不立即分配物理内存**（类似懒惰分配）。
2.  当程序首次访问表中某个条目时，会触发 `SIGSEGV` 页面错误。
3.  在错误处理程序中，分配一个物理页，计算该页所涵盖的所有条目的 `f(i)` 值并填入，然后将该页映射回地址空间。
4.  程序恢复执行，此次及后续对同一页内条目的访问都变为快速的查表操作。
5.  如果物理内存不足，处理程序可以淘汰一些已计算的页（先调用 `mprotect` 取消其访问权限），当这些页再次被访问时，会触发新的页面错误并重新计算填充。

**优势**：应用程序可以用很小的物理内存开销，表示一个巨大的虚拟表。访问模式决定了哪些部分真正留在内存中，实现了高效缓存。

---

## 应用实例二：垃圾回收器

上一节的例子展示了性能优化。本节中我们探讨一个更复杂的系统级应用：使用虚拟内存原语实现并发垃圾回收器（Garbage Collector, GC）。论文以“复制式回收器”为例。

**传统复制式GC的问题**：
1.  **开销大**：应用程序每次访问指针，都需要插入检查代码，判断对象是否在待回收区域，并进行转发（Forwarding）。这增加了指令开销。
2.  **并发难**：回收器与应用程序并发运行时，需要精细的同步来防止竞态条件。

**基于VM的解决方案**：
1.  将堆内存划分为“From空间”和“To空间”。回收开始时，将存活对象从From空间复制到To空间。
2.  关键技巧：将To空间中**尚未扫描完成**的区域，通过 `mprotect` 设置为**不可访问**。
3.  当应用程序试图访问一个位于“未扫描区域”的对象时，会触发页面错误。
4.  在错误处理程序中，回收器扫描触发错误的这一页对象，将其内部指针指向的对象也复制到To空间，然后使用 `mprotect` 将本页标记为**可访问**。
5.  回收器自身为了扫描对象，需要使用 `mmap` 将同一物理内存以**可读写**权限映射到另一个地址范围（即“Map2”原语的应用）。

**优势**：
*   **低成本检查**：指针检查由硬件MMU通过页面错误自动完成，省去了显式的条件判断指令。
*   **隐式并发同步**：应用程序无法访问“未扫描页”，回收器则可以安全地扫描它，硬件保护自然避免了并发冲突。

---

## 总结

![](img/34aa4f9fc39dabb7509d4bcc7255c15b_6.png)

本节课我们一起学习了用户应用程序如何利用虚拟内存原语来获得更强的能力和更好的性能。我们从一篇倡导此概念的经典论文出发，了解了现代操作系统（如Linux）通过 `mmap`、`mprotect`、`sigaction` 等系统调用对这些原语的具体实现。通过“大表缓存”和“垃圾回收器”两个深入案例，我们看到了这些技术如何解决实际编程中的难题，例如管理超出物理内存的数据结构、实现高效且并发的内存自动回收等。虚拟内存不仅是操作系统的核心，也是赋能应用程序开发者的重要工具。