![](img/2560cc93e558d8e9bdb7ab02e0210a2a_0.png)

![](img/2560cc93e558d8e9bdb7ab02e0210a2a_1.png)

# P5：第6讲 - 隔离与系统调用进入/退出 🚀

在本节课中，我们将要学习用户代码与内核代码之间的转换机制，即系统调用、异常或中断发生时，如何从用户模式安全、高效地切换到内核模式，并在处理完毕后返回。这个过程对于操作系统的隔离性、安全性和性能至关重要。

## 概述

当用户程序（例如shell）需要执行特权操作（如写入控制台）时，它会发起一个系统调用。这触发了从用户空间到内核空间的转换。硬件状态（如寄存器、模式、页表）必须发生一系列精心设计的改变，以确保内核能安全执行，同时用户程序对此过程毫无感知。本节课我们将深入探讨这一转换过程的每一步。

## 硬件状态与转换需求

上一节我们介绍了转换的基本概念，本节中我们来看看转换发生时，具体的硬件状态是什么，以及我们需要改变什么。

系统调用发生时，CPU的所有状态都设置为运行用户代码。我们需要改变的状态包括：

![](img/2560cc93e558d8e9bdb7ab02e0210a2a_3.png)

*   **用户寄存器**：所有31个通用寄存器（包括堆栈指针`sp`）都需要保存，以便内核处理后能透明地恢复用户程序。
*   **程序计数器（PC）**：需要保存，以便知道从哪里恢复执行用户程序。
*   **模式**：需要从用户模式切换到主管模式，以便内核能使用特权指令和访问受保护资源。
*   **页表指针（`satp`）**：当前指向用户页表，它只包含用户程序所需的映射。内核代码需要切换到内核页表才能访问其数据和代码。
*   **堆栈指针（`sp`）**：需要指向内核中的某个堆栈，以便内核可以调用C函数。

## 高层目标与设计限制

在考虑如何实现上述状态转换时，有两个高层目标限制了我们的设计选项：

1.  **安全与隔离**：陷阱机制不能信任用户空间的任何数据。用户寄存器可能包含恶意值，因此内核陷阱处理程序在查看这些寄存器前，必须先将它们保存起来。
2.  **对用户代码透明**：陷阱处理完毕后，应能在用户代码毫无察觉的情况下恢复其执行。

此外，我们需要理解主管模式的特权具体是什么。在RISC-V中，主管模式主要允许：
*   读写控制寄存器（如`satp`， `stvec`）。
*   使用页表项中未设置`PTE_U`标志的页面。
主管模式代码同样受页表限制，只能访问当前页表中已映射的虚拟地址。

## 系统调用流程概览

以下是系统调用从发起到返回的完整流程预览，我们将通过GDB跟踪一个具体的`write`系统调用来详细分析。

1.  **用户空间**：Shell调用`write`库函数，该函数将系统调用号加载到寄存器`a7`，然后执行`ecall`指令。
2.  **陷阱入口（汇编）**：`ecall`指令将模式改为主管，保存PC到`sepc`，并跳转到`stvec`寄存器指向的地址（即`trampoline`页开头）。执行的第一条内核指令是`uservec`（位于`trampoline`页的汇编代码）。
3.  **切换到C环境**：`uservec`保存用户寄存器，切换页表，设置内核栈，然后跳转到C函数`usertrap`。
4.  **系统调用处理（C代码）**：`usertrap`判断陷阱原因为系统调用，调用`syscall`函数。`syscall`根据系统调用号查找并执行对应的内核函数（如`sys_write`）。
5.  **陷阱返回（C代码）**：系统调用执行完毕后，`usertrap`调用`usertrapret`函数，为返回用户空间做准备（如设置`stvec`， 准备陷阱帧等）。
6.  **返回用户空间（汇编）**：`usertrapret`最终跳转到`trampoline`页中的`userret`汇编函数。`userret`切换回用户页表，恢复用户寄存器，最后执行`sret`指令返回用户空间，在`ecall`指令后继续执行。

## 通过GDB深入分析转换过程

现在，让我们通过GDB实际跟踪一个`write`系统调用的完整过程，以理解上述每一步的细节。

### 1. 用户空间发起系统调用

我们在shell的`write`库函数中的`ecall`指令处设置断点。此时，我们处于用户模式，使用用户页表，地址空间很小。寄存器`a0`， `a1`， `a2`分别保存了文件描述符、缓冲区指针和字节数。

### 2. 执行ECALL进入内核

执行`ecall`指令后，硬件自动完成三件事：
*   将模式从用户改为主管。
*   将当前PC（`0xde6`）保存到`sepc`寄存器。
*   将PC设置为`stvec`寄存器的值（`0x3ffffff000`），即`trampoline`页的起始地址。

此时，我们开始在`trampoline`页中执行，处于主管模式，但**仍在使用用户页表**。所有通用寄存器仍保持用户程序设置的值。

### 3. TRAMPOLINE代码 (uservec)

`trampoline`页被映射到每个用户页表的固定高地址处，且其页表项**未设置`PTE_U`标志**，因此用户代码无法访问，保证了安全性。`ecall`后第一条指令是：
```assembly
csrrw a0, sscratch, a0
```
这条指令交换了寄存器`a0`和`sscratch`的内容。此前，内核已将`sscratch`设置为指向当前进程的`trapframe`页的指针。交换后，`a0`持有了`trapframe`的地址，而用户原来的`a0`值被暂时保存在`sscratch`中。

`trapframe`是内核为每个进程预留的内存区域，用于保存和恢复状态。其结构（`struct trapframe`）中包含了保存所有用户寄存器的槽位。

接下来，`uservec`使用一系列的`sd`（存储双字）指令，将除`a0`外的所有用户寄存器保存到`trapframe`中相应的偏移位置。然后，它从`trapframe`中加载内核栈指针到`sp`，加载内核页表地址到`satp`寄存器，并执行页表切换。

**关键点**：为什么切换页表后不会崩溃？因为`trampoline`页在内核页表中**同样被映射在相同的虚拟地址**。因此，切换页表后，我们仍在执行相同的`trampoline`代码。

最后，`uservec`从`trapframe`中加载C处理函数`usertrap`的地址，并跳转到该C代码。

### 4. C陷阱处理 (usertrap)

现在我们进入了内核C代码环境，使用内核页表和内核栈。`usertrap`函数首先将`stvec`改为内核陷阱处理程序的地址（因为之后可能处理内核中的陷阱）。然后，它保存`sepc`（用户PC）到进程的`trapframe`中，因为后续可能发生进程切换。

接着，它检查陷阱原因（`scause`寄存器）。对于系统调用（值8），它需要：
*   将保存的PC（`sepc`）加4，以便返回时执行`ecall`之后的下一条指令。
*   打开中断（因为在陷阱入口时中断被关闭）。
*   调用`syscall()`函数。

`syscall()`函数从`trapframe`中读取用户设置的系统调用号（`a7`），并据此索引到一个函数指针表，调用相应的内核系统调用实现（如`sys_write`）。系统调用的参数也从`trapframe`中相应的寄存器槽位（`a0`， `a1`， `a2`...）读取。返回值被写入`trapframe`中的`a0`槽位。

### 5. 准备返回用户空间 (usertrapret)

系统调用处理完毕后，`usertrap`调用`usertrapret`为返回用户空间做准备。`usertrapret`负责：
*   关闭中断（因为接下来要修改`stvec`， 若此时发生中断指向用户处理程序会导致问题）。
*   将`stvec`重新设置为`uservec`的地址，以便下次用户陷阱时使用。
*   在`trapframe`中写入下次陷阱所需的内核数据：内核页表地址、内核栈指针、`usertrap`函数地址等。
*   设置`sepc`为之前保存的用户PC。
*   计算`trampoline`页中`userret`函数的地址，并以`trapframe`和用户页表地址为参数，“调用”该汇编函数。

### 6. TRAMPOLINE代码返回 (userret)

控制权回到`trampoline`页中的`userret`汇编代码。此时仍在主管模式，使用内核页表。
*   首先，它将第二个参数（用户页表地址）加载到`satp`寄存器，切换回用户页表。
*   然后，它将第一个参数（`trapframe`指针）与`sscratch`交换。现在`a0`指向`trapframe`， 而`sscratch`保存了指向`trapframe`的指针（为下次陷阱做准备）。
*   接着，它从`trapframe`中恢复所有用户寄存器的值。注意，此时`trapframe`中的`a0`槽位已经是系统调用的返回值。
*   最后，它执行`sret`指令。该指令将模式改回用户，将PC设置为`sepc`的值，并重新开启中断。至此，CPU完全回到了用户空间，从`ecall`之后的下一条指令继续执行，并且寄存器`a0`中包含了系统调用的返回值。

## 设计思考与总结

本节课我们一起学习了xv6操作系统中用户空间与内核空间通过陷阱机制进行转换的完整过程。这个过程比普通的函数调用复杂得多，主要源于**隔离性要求**（内核不能信任用户数据）和对**性能的追求**。

我们可以思考一些替代设计：
*   **硬件辅助**：`ecall`能否做得更多？例如自动保存寄存器或切换页表？RISC-V选择只做最小化工作，将灵活性留给软件，以支持不同操作系统的各种优化策略（如不切换页表、部分保存寄存器等）。
*   **安全性**：恶意程序能否滥用这些机制？整个设计，特别是通过`trampoline`页和未设置`PTE_U`的陷阱帧，确保了用户代码无法干扰陷阱进入/退出路径上的关键数据。

![](img/2560cc93e558d8e9bdb7ab02e0210a2a_5.png)

xv6的实现展示了在RISC-V架构上实现安全、透明且相对高效的陷阱处理的一种方式。理解这一过程是理解操作系统如何实现隔离和保护的关键。