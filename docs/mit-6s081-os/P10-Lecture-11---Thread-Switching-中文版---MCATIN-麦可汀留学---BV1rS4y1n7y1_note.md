![](img/4c0f21ff94f6c74e5c0d1185ab9b48b1_0.png)

![](img/4c0f21ff94f6c74e5c0d1185ab9b48b1_1.png)

# 课程11：线程切换 🧵

在本节课中，我们将学习操作系统中的核心概念——线程切换。我们将探讨为什么需要线程、线程是什么、以及xv6操作系统是如何实现线程切换的。通过理解保存和恢复线程状态、调度器的工作方式以及上下文切换的底层机制，你将能够掌握多任务处理的基本原理。

---

## 概述：为什么需要线程？🤔

人们希望计算机能够同时处理多项任务。这支持了时间共享，允许多个用户同时登录并运行进程。即使在单用户设备上，我们也期望它能运行多个不同的进程。线程简化了程序结构，有时是帮助程序员组合简单程序、降低复杂性的优雅方法。例如，在第一个实验的素数筛中，虽然没有直接使用线程，但使用了多个进程来构建软件。最后，线程允许程序的不同部分在不同核心上并行运行，从而可能提升性能。

---

## 什么是线程？🧶

线程是一种简化编程的抽象，用于处理多个任务。你可以将线程看作是一个单一的串行执行流。如果你编写一个按顺序做事的程序，那么该程序就是一个单一的控制线程。线程的状态很重要，因为我们需要保存并在以后恢复它。线程状态最重要的部分是它的程序计数器，它指示了执行的位置。此外，由于编译器生成代码的方式，每个线程通常都有自己的栈，用于记录函数调用，反映当前执行点。

---

## 线程系统的职责 🏗️

xv6的线程系统负责管理多个线程的交错执行。我们希望系统能够处理数十、数百甚至数千个线程，并让它们都取得进展。主要有两种策略来实现这种交错：

1.  **多CPU/多核**：每个CPU核心运行自己的线程。每个线程自动拥有自己的程序计数器和寄存器。
2.  **线程切换**：如果一个CPU需要运行多个线程，系统会在不同线程之间切换。它会保存当前线程的状态，切换到另一个线程执行一段时间，然后再切换回来。

xv6结合了这两种策略，在所有可用核心上运行线程，并且每个核心会在其管理的线程之间进行切换，因为通常线程数量远多于CPU核心数量。

---

![](img/4c0f21ff94f6c74e5c0d1185ab9b48b1_3.png)

## 线程与内存共享 🔗

不同的线程系统或实例的区别在于线程是否共享内存。

*   **共享内存线程**：多个线程在同一个地址空间内执行，可以看到彼此对内存的修改。xv6内核线程就是共享内存的例子，它们共享内核内存。
*   **非共享内存线程**：每个线程有自己的独立地址空间。xv6的用户进程就是如此，每个进程只有一个线程，且进程间不共享内存。

像Linux这样的系统允许单个用户进程内存在多个共享内存的线程，这需要更复杂的内核支持。

---

## 实现线程系统的挑战 ⚙️

要实现一个线程系统，我们需要解决几个高级挑战：

1.  **如何实现切换**：如何实际实现线程间的切换，以实现交错执行。这个决策过程通常被称为**调度**。
2.  **如何保存和恢复状态**：当停止一个线程并想在以后恢复时，需要决定保存哪些状态以及如何保存。
3.  **如何处理计算密集型线程**：如果一个线程在进行长时间计算而不主动让出CPU，我们需要一种机制来自动中断它，以便其他线程可以运行。

---

## 抢占式调度与计时器中断 ⏰

处理计算密集型线程的关键机制是**计时器中断**。每个CPU核心都有一个硬件计时器，会周期性地产生中断（例如每10毫秒）。即使一个用户程序在运行无限循环，计时器中断也会将控制权从用户代码强制转移到内核中的中断处理程序。

*   **抢占式调度**：计时器中断“抢占”当前运行的线程，即使该线程不想主动放弃CPU。内核的中断处理程序会将CPU交还给调度器，让调度器决定运行哪个线程。
*   **线程状态**：我们需要区分线程的不同状态：
    *   **RUNNING**：线程正在某个CPU核心上执行。
    *   **RUNNABLE**：线程当前未在执行，但其状态已保存，并且希望尽快运行。
    *   **SLEEPING**：线程正在等待某些I/O事件，事件发生后才会变为RUNNABLE。

计时器中断所做的就是将当前**RUNNING**的线程转变为**RUNNABLE**状态。

---

![](img/4c0f21ff94f6c74e5c0d1185ab9b48b1_5.png)

![](img/4c0f21ff94f6c74e5c0d1185ab9b48b1_6.png)

## xv6中的线程切换全景图 🖼️

在xv6中，线程切换不是直接从用户进程切换到另一个用户进程，而是通过内核间接完成的。以下是更完整的流程：

假设我们有两个进程：进程1（正在运行）和进程2（可运行但未运行），以及两个CPU核心。

1.  **计时器中断**：CPU 0上的计时器中断迫使控制权从进程1的用户空间转移到内核。
2.  **保存用户状态**：蹦床代码将进程1的用户寄存器保存到其陷阱帧中。
3.  **内核处理**：执行内核的中断处理代码（`usertrap`）。
4.  **调用 yield**：内核决定让出CPU，调用 `yield` 函数。
5.  **获取进程锁**：`yield` 获取进程1的锁，防止其他核心的调度器在此过程中查看或运行该进程。
6.  **状态变更**：将进程1的状态从 RUNNING 改为 RUNNABLE。
7.  **调用 sched**：`yield` 调用 `sched` 函数。
8.  **调用 switch**：`sched` 调用 `switch` 函数，这是核心步骤。
    *   `switch` 保存当前内核线程（进程1的内核线程）的寄存器到进程1的 `context` 结构中。
    *   然后，它恢复CPU 0的**调度器线程**之前保存的寄存器（存储在 `cpu` 结构中）。
    *   这导致CPU开始执行调度器线程的代码，并从 `switch` 返回到调度器函数（`scheduler`）中。
9.  **调度器运行**：现在CPU 0运行的是调度器线程。它释放进程1的锁，并在进程表中查找下一个可运行的进程（例如进程2）。
10. **再次切换**：调度器找到进程2后，获取进程2的锁，将其状态设为 RUNNING，记录当前CPU正在运行进程2，然后再次调用 `switch`。
    *   这次，`switch` 保存调度器线程的寄存器到CPU的 `context` 中。
    *   恢复进程2之前保存的内核线程寄存器（从其 `context` 中）。
    *   这导致CPU开始执行进程2的内核线程，并从进程2上次调用 `switch` 的地方返回（可能是某个系统调用或中断处理代码中）。
11. **返回用户空间**：进程2的内核线程完成其工作后，通过恢复其陷阱帧中保存的用户寄存器，返回到进程2的用户空间继续执行。

**关键点**：
*   每个进程结构（`struct proc`）中都有一个 `context` 结构，用于保存其内核线程的寄存器。
*   每个CPU结构（`struct cpu`）中也有一个 `context` 结构，用于保存其调度器线程的寄存器。
*   线程切换的核心就是 `switch` 函数，它通过保存和恢复寄存器来改变CPU的执行流。

---

## 代码剖析：switch 函数 💻

`switch` 函数是线程切换的核心，用汇编语言编写。它执行以下操作：

```assembly
# 参数：a0 = 当前线程的 context 结构指针
#        a1 = 目标线程的 context 结构指针
switch:
        sd ra, 0(a0)        # 保存返回地址
        sd sp, 8(a0)        # 保存栈指针
        sd s0, 16(a0)       # 保存被调用者保存寄存器 s0-s11
        ...
        sd s11, 104(a0)

        ld ra, 0(a1)        # 恢复目标线程的返回地址
        ld sp, 8(a1)        # 恢复目标线程的栈指针
        ld s0, 16(a1)       # 恢复目标线程的寄存器 s0-s11
        ...
        ld s11, 104(a1)

        ret                 # 返回到目标线程的 ra 地址处
```

**为什么只保存部分寄存器？**
`switch` 被C代码调用。根据RISC-V调用约定，寄存器分为调用者保存（caller-saved）和被调用者保存（callee-saved）。编译器生成的C代码会负责在调用函数前保存调用者保存的寄存器（如临时寄存器）。因此，`switch` 只需要保存那些被调用者需要保存的寄存器（`s0`-`s11`、`ra`、`sp`），这些寄存器在函数调用后必须保持不变。

**程序计数器（PC）呢？**
不需要显式保存PC。因为当调用 `switch` 时，我们知道执行点就在 `switch` 函数内部。真正需要保存的是 `ra`（返回地址），它指示了从 `switch` 返回后应继续执行的位置。

---

## 锁的作用：保护切换过程 🔒

进程锁（`p->lock`）在切换过程中至关重要，它确保状态转换的原子性，防止竞态条件。

*   **在让出CPU时（yield）**：获取锁后，进程状态被改为 RUNNABLE，寄存器被保存到 `context`。在完成这些步骤并实际调用 `switch` 切换到调度器之前，锁防止了其他核心的调度器看到这个处于“部分让出”状态的进程并错误地运行它。
*   **在开始运行进程时（scheduler）**：调度器在找到一个新进程后，会先获取该进程的锁。然后设置状态为 RUNNING，调用 `switch` 恢复其寄存器。在这个过程中，锁防止了计时器中断在该进程寄存器尚未完全恢复时就中断它，否则可能导致保存不完整的寄存器状态。

---

## 其他触发切换的场景 🔄

除了计时器中断，线程切换还可能由以下情况触发：

*   **系统调用等待I/O**：例如，一个进程执行 `read` 系统调用等待磁盘数据或管道数据。如果数据未就绪，内核会将该进程置于 SLEEP 状态，并调用 `yield` 让出CPU。
*   **进程退出**：进程执行 `exit` 系统调用时，也会最终调用 `yield` 让出CPU。

在这些情况下，切换的底层路径（经过 `yield` -> `sched` -> `switch`）与计时器中断是相似的。

---

## 总结 📚

本节课我们一起深入学习了线程切换机制。我们了解到：

1.  线程是串行执行流，线程切换是实现多任务的核心。
2.  xv6通过**计时器中断**实现**抢占式调度**，强制收回CPU控制权。
3.  线程切换是间接的，总是从用户态进入内核态，在内核线程间切换，再返回用户态。
4.  切换的核心是 `switch` 汇编函数，它通过保存和恢复一组被调用者保存的寄存器来实现执行流的跳转。
5.  进程锁（`p->lock`）保护了切换过程中关键状态的原子性变更。
6.  上下文（`context`）结构分别保存在进程结构（用户进程内核线程）和CPU结构（调度器线程）中，用于存储线程挂起时的寄存器状态。

![](img/4c0f21ff94f6c74e5c0d1185ab9b48b1_8.png)

理解这些概念是理解现代操作系统如何管理并发和执行多任务的基础。