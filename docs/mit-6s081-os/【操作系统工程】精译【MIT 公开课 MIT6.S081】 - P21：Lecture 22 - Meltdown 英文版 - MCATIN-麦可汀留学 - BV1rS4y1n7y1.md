# 【操作系统工程】精译【MIT 公开课 MIT6.S081】 - P21：Lecture 22 - Meltdown 英文版 - MCATIN-麦可汀留学 - BV1rS4y1n7y1

![](img/a6a8b4fec2e38ec74d4c9ce6a0059e4a_0.png)

好吧，今天我们有熔毁，我们读这篇论文的原因，安全一直是一个话题，在内核的设计中出现了很多，我们在课堂上谈到的，正如我们所知，我们已经谈到的主要策略，对于内核来说，提供安全性意味着什么是隔离。

就像你知道的那样，用户程序不能从内核读取数据，用户程序不能从其他用户程序中读取其他用户的数据，以及我们所看到的操作系统为了获得隔离而使用的特定技术，或者像用户监督模式和硬件，页表和硬件。

以及一些精心设计的内核软件，比如系统调用，都对他们如何使用，用户提供的指针，但值得思考的是，看看这种东西是如何出错的例子，我是说，事实上，你知道的，内核努力提供隔离和安全，但是出现了一些问题。

这篇论文是提出的最有趣的问题之一，最近的操作系统安全，《熔毁》于1918年初出版，所以不久前，很多像我一样的人发现这很惊讶，实际上很令人不安，对用户内核隔离的相当令人不安的攻击，它真的破坏了信仰。

或者这个非常基本的假设，页表，硬件供应只会让你隔离，故事就这样结束了，这次攻击根本不支持这一观点，这是最近许多例子中的一个例子，所谓的微建筑攻击，涉及，利用CPU内部隐藏的实现细节。

这些细节通常甚至不是这样的，CPU是如何工作的，但是人们猜测，他们能够成功地攻击，基于对CPU隐藏细节的正确猜测，实现熔毁是可以修复的，这似乎已经完全修复了，但尽管如此，人们，它有点陷害人们。

担心可能会有类似的微型建筑攻击的开放式供应。

![](img/a6a8b4fec2e38ec74d4c9ce6a0059e4a_2.png)

所以这是最近一个非常重要的值得理解的事件，让我先从，布局攻击的基本核心，我们来谈谈这里发生了什么，但这是论文中关于攻击工作原理的代码的简化版本，基本的想法是，你是一个攻击者，因为这样或那样的原因。

你可以运行软件，在一些有你喜欢偷的秘密的电脑上，你不能直接泄露秘密，但他们在记忆中，可能是内核内存或其他进程内存，您已经能够运行一个进程，也许是因为你登录了一个像雅典娜机器一样的分时机。

也可能是因为你在一些托管服务上买了时间，所以攻击允许你运行一个程序，其中在自己的内存中声明缓冲区，所以这个buff只是可以访问的普通用户内存，你在你感兴趣的东西的内核中有虚拟地址，偷窃，嗯，你发布什么。

我在这里写的是一种，你知道C和汇编程序的混合，但我在第三行的意思是，你有，要窃取并注册one和r one的数据的内核虚拟地址，三号线的是，或者想象这是取消引用的指令，寄存器一并将其结果加载到寄存器二。

这就是我们要运行的指令，然后有一个指令，只是得到寄存器二的低位，所以这次攻击，这种攻击的特定版本只读一点，只需内核中一个内存位置的一个低位，乘以四千四千九十六，因为它不是零就是一，这意味着R2最终为零。

四千九十六，然后我们简单地读取缓冲区的内容，用户内存中的缓冲区，我们简单地读到零的缓冲区或四千九十六的缓冲区，这是基本的攻击，所以一个问题是为什么这不直接起作用，就像第三行读取这个内核地址。

我们能从内核读取地址吗，否，否，我们都相信答案不可能是肯定的，我们不可能直接从内核读取，如果我们在用户空间，我们知道CPU以某种方式调用的机器，让这一切都不成功。

当我们使用意味着在页表中查找的内核虚拟地址时，页表中有权限位，我们只是假设，操作系统尚未在页表中设置标志，内核虚拟地址项，没有设置允许用户使用这些地址的标志，那是风险五号上的PU旗，因此。

此指令必须失败，必须导致页面错误，而且确实，如果我们运行这个代码，如果我们试图，如果我们，你知道的，在这之后添加了一个代码说，打印寄存器3中的值，3号线出现页面错误，我们永远也拿不到打印声明。

我们发现我们不能直接从内核中窃取数据，尽管如此，这个序列原来很有用，正如论文所示，有一件事，嗯啊，论文假设的一件事不再是真的，在很大程度上是内核映射到每个用户进程的地址空间，也就是当用户。

当用户代码运行页表中存在的全套内核PAS时，但他们有PTE U位清楚，所以嗯，用户代码将出现错误，如果它试图使用内核虚拟地址，所以在写这篇论文的时候，所有这些映射，所有这些映射都在那里。

在用户空间执行时，它们只是不能被用户代码使用，它们造成故障的地方，它们是由用户代码使用的，以及操作系统设计者映射内核和用户地址的原因，当你运行用户代码时，系统调用会更快，因为这意味着当系统调用发生时。

你不必切换页表，切换页表通常本身就需要时间，并且通常会导致CPU缓存被刷新，使后续代码变慢，所以人们通过映射用户和内核映射得到了提升，始终在用户空间中，但这次袭击实际上，而这次攻击依赖于那个习惯，好的。

所以我要解释一下这里发生了什么，这使得这段代码很有用，但在我这么做之前，任何，有什么问题吗，对此有什么问题吗，这个代码片段，我想知道他是否能重复你刚才说的内核到用户映射，没有真正注册，好的，让我们看看。

你知道在XV中，当你执行，以及当进程在用户空间中执行时，如果你看页表，该页表具有用户地址和，就像蹦床页和陷阱框架页，没有别的，这就是xpsix的工作原理，本文假设的页表与，在这篇论文写的时候。

大多数操作系统，在页表中有一组完整的内核映射，当用户代码运行时，所以所有这些页表条目都会在那里，当用户代码运行时，所有内核页表条目都将存在，但是因为每个页表条目上的PTE U位都很清楚。

用户代码实际上不能使用内核虚拟地址，但是映射在那里，原因是当您进行系统调用时，不必切换页表，因为你对内核进行系统调用，然后砰的一声，现在您使用的是相同的页表，但是现在你可以使用所有这些内核PT。

因为你处于主管模式，这节省了在系统调用期间进出内核的大量时间，所以每个人每个人都用这种技术，事实上，这几乎可以肯定是英特尔想要的，如何编写操作系统，好的，这样整张纸，这种结构是为攻击而假设的，当然。

摆脱它是解决这个问题最直接的办法，但在论文写的时候，所有这些内核映射都存在于用户空间中，其他问题，所以你需要知道你想要得到的地址，这是正确的，它是，呃，你知道，所以这是一个很好的观点。

您需要知道内核虚拟地址，这实际上可能不是开玩笑，是啊，是啊，你可能会认为这会让攻击变得更难，但首先，安全哲学的观点，你只需要假设攻击者有无限的时间和耐心，如果他们想要什么有价值的秘密。

他们可能愿意花几个月的时间试图窃取这个秘密，um或更长，对呀，因为你知道它会是某人的密码，就像，保护各种有价值的东西，也许是钱，或者你知道，秘密电子邮件，嗯，所以这意味着，比如说。

攻击者可能有时间尝试每一个内核地址，寻找他们想要的任何珍贵数据，也许是密码，或者攻击者可能有时间喜欢学习，查看内核代码，查看典型的编译内核并查找地址，也许把打印语句放在内核中，检查内核内存中的数据结构。

直到他们了解内核如何工作得足够好，能够在这里得到一个地址，实际上是因为这个游戏一直在进行，这个安全游戏的其他版本已经进行了很长时间，内核实际上保护自己免受涉及猜测内核地址的税收。

这篇论文中提到的一件事叫做，布局随机化，所以现代内核实际上以随机地址加载内核，为了让人更难猜到，内核内核虚拟地址，他们在这之前就这样做了，早在这篇论文出来之前，因为它有助于击败其他攻击，嗯马马虎虎。

这就是游戏，但是，我们必须假设攻击者最终，攻击者很可能会赢得这场比赛，好的，所以说，我们只能假设攻击者知道一个多汁的内核，要查看的虚拟地址，或者能猜到一个，或者愿意穷尽地尝试每一个地址。

论文认为这是一个合理的策略，一旦你崩溃了，好的，那么会发生什么，所以我们想知道这些代码怎么可能对攻击者有用，答案必须像这样，如果CPU的工作方式就像你在CPU手册中读到的那样，这次袭击显然是胡说八道。

就像它会在指令三出错一样，就这样结束了，但事实证明，CPU的工作方式比手册中复杂得多，攻击的工作方式是因为一些CPU实现细节，嗯，攻击实际上依赖于两个主要因素，一个是CPU的一个实现技巧，叫做推测执行。

我先说说，和，攻击所依赖的另一个实现技巧是CPU进行缓存的方式，所以第一次投机性执行，让我让我我也有一个代码示例，就目前而言，我根本不是在谈论安全问题，我是投机执行，这东西只是一种提高CPU性能的技术。

和CPU使用的优化技巧，所以想象一下你知道我们只是我们有，我们只是运行这个代码，这是一个有点做作的例子，但它说明了投机性执行是怎么回事，假设我在某地有地址，说，寄存器零，只是因为我的程序的逻辑。

地址有效或无效，也许它包含零，如果在某些情况下，比如我们已经初始化了我的数据，所以有这个，我们假设有一个有效变量，那是在记忆中，在使用这里的地址之前，寄存器零中的此地址，在4号线这里，我们要测试一下。

我们将从内存加载有效值，我们只使用地址，如果valid设置为1，而valid设置为零，我们只是根本不打算用这个地址，如果有效，则设置为1，然后我们将取消引用地址，你知道的，将数据点加载到并注册两个。

并向其添加一个，这并不重要，我们将对我们在本例中加载的数据做些什么，向其添加一个，并将寄存器设置为三个，等于，数据加一，所有的权利，嗯，在一个简单的CPU实现中，啊，第二行在这里，你必须加载有效的。

Vois位于内存和RAM中的变量，嗯，我们必须发布某种这将是，第二行将是某种加载指令，从RAM中读取有效的，在其他条件相同的情况下，如果我们真的必须从RAM加载它，在我们的两千兆赫机器上需要数百个循环。

就像任何必须进入RAM的负载一样，需要数百个循环，你知道的机器可以在每个周期执行一条指令，所以如果我们真的要在这里等几百个循环，我们会，机器会在那里空转数百个循环，有点浪费时间，因为这是一个显著的放缓。

如果一切顺利的话，我们将能够在每个周期执行一条指令，而不是每隔几百个循环，嗯，都是现代的，都很严重，现代CPU确实使用了一种叫做分支预测的东西，所以这个if语句是分支，如果我们真的把它变成机器指令。

我们会看到这里有一根树枝，它是一个基于此的条件分支，寄存器一是否等于一的检验，而CPU所做的是，他们使用所谓的分支预测，那是对每一个分支或或多或少，CPU基本上记住了程序中每个分支的信息缓存。

或者至少每个最近执行的分支并记得，哦，那根树枝被拿走了还是没被拿走？如果CPU没有足够的信息来预测，所以这是基于上次执行分支的预测，即使CPU没有预测，它可能仍然只是继续执行指令，要么是树枝带你去。

要么是通过指示坠落，假设树枝没有被拿走，这甚至是在CPU知道这个条件是否为真之前，它会选择一条路或另一条路，并开始沿着这条路执行，即使这可能是错误的道路，它还不知道，所以在这种情况下。

可能在此加载完成之前，在知道valid的值之前，CPU可以开始执行指令四，用R0中的任何值加载，它可能是有效的指针，也可能不是有效的指针，一旦负载产生了一些东西，甚至可以在其中添加一个。

并将寄存器3设置为该值，也许很长一段时间后，当这条负载线最终完成时，嗯，我们现在知道有效的值是多少，CPU就会真的，你知道的，它记录了这样一个事实它执行了第4行和第5行，不知道这是否合适，嗯。

如果有效是一个，那就没问题，它一直在继续，如果有效为零，然后呢，CPU有足够的聪明，取消其执行第4行和第5行的影响，并重新启动执行，和7号线支线后的适当位置，在你知道你是否真的应该执行之前。

这个代码的执行，这叫投机，重点是性能，如果CPU猜对了，然后它就有了一个大头，开始执行这些指令，而且不必等待昂贵的内存负载的内存，关于这意味着什么有什么问题吗，这个机器，硬件，CPU中的晶体管进行猜测。

CPU中有大量的工作要做，没有一个是出版对的，这都是英特尔内部的东西，不是指示，机器手册里没有，所以周围的熔毁和攻击，就像，这是一个巨大的猜测，CPU内部可能发生了什么。

为了使这样那样的攻击起作用或不起作用，好吧，回到猜测，虽然，的，呃，呃，正在发生的一件事是，为了消除投机失败，投机小姐，错过预测的投机执行，呃，这台机器保存了寄存器的影子版本，基本上，你知道。

它将分配给寄存器2和寄存器3，但它会被分配给它，一种临时寄存器，如果SEC的投机成功，然后这些寄存器，这些影子寄存器变成了真正的寄存器，如果失败了，然后这些阴影寄存器被丢弃，CPU丢弃阴影寄存器。

所以这两个作业是两个，R3就像从来没有发生过一样，所以在这个代码中，嗯，我们需要考虑如果寄存器零是有效指针会发生什么，如果它不是有效的指针会发生什么，如果我们推测执行第4行，寄存器2是有效指针。

那么CPU实际上会做负载，并至少将其加载到寄存器2的瞬态版本中，所以我们真的要出去，然后然后呃，试着取我们的零点所做的，如果R为零，这肯定会起作用，如果数据R0指向缓存中，我不知道它是否。

如果CPU会做负载，如果它在缓存中丢失，并且必须从RAM加载，它可能，但也许对我们来说，这次攻击更有趣的问题是，如果注册会发生什么，没有有效的指针，那样的话，如果我们在这里推测执行。

机器在这一点上不能出故障，因为我们在投机性地执行，机器不知道它可能知道R0是无效的，这个推测执行的指令试图使用一个无效的指针，无效的地址，但它不能页错。

因为它不确定这个执行是否为val是一个正确的推测性执行，或错过一次猜测，所以只有这样，所以在有效之前，它实际上不会在四号线上出现故障，有效值已知，在这个分支之后，这个推测性的预测分支是。

在我们知道什么之后在机器知道什么情况之后，如果机器看到，你知道如果CSO寄存器的机器，有一个无效的地址，然后有效的结果是一个，然后，也只有这样，机器才真正产生页面错误，如果R零是一个无效的地址。

选票结果是零，机器不会产生页面错误，所以关于是否推迟违约的决定，可能持续数百个循环，直到知道有效值，专业术语是指我们知道指令是否，而不是被扔掉，这叫退休，所以我们说指令是推测性的，在某个时候，它退休了。

那时我们知道它要么会被扔掉，还是真的，它应该是它的效果应该致力于机器的可见状态，规则是，一条指令只有在首先完成执行的情况下才能退役，你知道的，加载内存，你在给某物加一个，在它之前执行的每一条指令。

在它也退休之前，所以你知道，在有效值加载完成之前，第4行不能退役，并对病情进行评估，只有到那时才能退休，所以如果它要落在我身上，它会出错的，可能有数百条指令，它做了内存加载，我们很想做内存加载。

作为这次袭击的关键细节，还有一个更多的，呃，如果让我们看看嗯，如果r零中的地址无效，并且在页表中根本没有映射，RZero中的地址有页表映射，但没有许可，那是普旗没有设置，英特尔机器实际上做的是加载数据。

并将其分配到瞬态寄存器中以，其中它可以通过线phi的推测执行来使用，所以即使R零是一个我们没有许可的地址，因为它是内核地址，我们仍然会看到它的值被加载到R3中，它的值加上1，对不起，我们不会看到它。

但它会被加载到R2，再加上1，再加载到R3，然后当这个负载退役时，机器就会意识到啊哈，这是一个无效的负载，因为页表项不允许，所以我们要提出一个错误，并取消后续指令的执行，并取消本指令的效果。

撤销对r 2和r 3的修改，所以在这个例子中，正在进行的两种猜测，一个是，我们在猜测这在哪里，机器在猜测树枝去了哪里，只是说，哦，我走了这样或那样的路，我只是想推测一下，此外，每次加载后都有推测性执行。

我们本质上是在猜测，机器在猜测这个负载是否能成功完成，在负载的情况下，英特尔的机器总是继续，你知道吗，是否可以提供数据，因为它在缓存中，并且至少存在页表项，权限不是，机器会投机性地继续执行。

只有在退休时，呃，它真的会产生故障吗，这将导致猜测被取消，对这些东西有什么问题吗，我对第二个猜测有点困惑，也就是，呃，把r 0加载到r 2，所以嗯，这是否意味着R0的值被加载到R2中，稍后检查标志。

是呀，那么发生了什么，是呀，完全正确，所以实际发生的是，在投机阶段，嗯，不管我们的零点做什么，如果有一种，如果它指向什么，如果r零点指向任何东西，那么该内存位置的数据将在以后加载到R2中。

当这个负载退役时，它转动，然后权限将被检查，如果我们没有被允许做那批货物，则所有后续指令效果将被取消，就像寄存器的所有这些修改一样，它就会被解开，机器和寄存器的状态将引发故障，就像他们在指示之前一样。

好的，那很有趣，是呀，是呀，我也有个问题，是否没有可能的方法来限制CPU检查权限，在进行投机加载之前，你的意思是，有没有办法让机器在装货前做检查，是呀，我猜，更具体的说，这是个问题的唯一原因。

或者其中一种方法是我们只是加载一个页面，如果我们能意识到它的权限会很糟糕，不知何故是对的，我们正在访问一个我们不访问的页面，我们不应该能够访问，投机性的执行可以取消吗，鉴于我们可以读取这些权限，是呀。

在耶，是呀，那是，呃，是啊，是啊，嗯嗯，有两个答案，一个是英特尔芯片CPU实际上不是这样工作的，另一个答案是肯定的，本来应该是，我相信他们很容易做到，并强制执行检查，即使是投机性负载。

所以即使在投机登记中，两个永远不会被写出来，而且确实，原来你可能没有注意到，论文提到熔毁似乎在AMD CPU上不起作用，尽管AMD CPU的使用手册与英特尔CPU相同，本质上，它们运行相同的指令集。

说明书的意思是一样的，攻击在AMD CPU上不起作用，人们普遍认为原因是AMD CPU，即使在投机性执行时，您没有权限阅读此地址，甚至不会推测地将值加载到R 2中，这就是为什么攻击没有奏效。

amd cpus和最近的intel cpus显然已经采用了这种方法，他们实际上不会投机性地装载，如果他们没有权限，据我所知，没有特别的牺牲和表现，我想信息都在那里，但因为我不知道，只是说也许几个门。

他们决定只把它涂在，退休，因为他们需要非常有趣，是啊，是啊，我是说，我先警告你，这里有很多猜测，我相信我说的是真的，但在英特尔和AMD并没有透露发生了什么，好的，有一个，这里有一些术语，那很重要。

你在CPU手册上读到的，哦，你知道的，什么增加了指令，取两个寄存器并将其相加，把它们放在第三个，那些东西，这方面的设计被称为建筑和广告，所以机器的广告行为是，如果你从一个地址加载。

你和任务为你得到一个页面错误期，你不允许装载，这与，呃，机器实际上在做什么，这就是所谓的微，建筑学，也就是，你知道的，实际上机器有推测性的执行，做所有这些疯狂的事情，而不告诉你CPU设计者的意图。

当他们设计所有这些复杂的微架构优化时，他们是透明的，那个是的，你知道它在内部做所有这些事情，但看起来你从程序中得到的结果是一样的，你会从一个更简单的机器上得到，它只是做了简单的事情，这是手册上的对吧。

它们是透明的，所以你知道，比如说，在某种程度上，英特尔在这里做的是透明的，是啊，是啊，也许他们不检查权限当你，当您进行内存加载时，如果退休有问题，它会消除所有这些影响，所以你永远不会看到那段记忆。

你不应该看到这么糟，这看起来就像手册上说的，你不允许装载东西，你没有得到允许，所以这种区别是，这次攻击的很多内容，它知道攻击对里面发生的事情了如指掌，好的，关于呃的其他问题，投机执行。

我要把它放在一边一会儿，谈论另一个微架构，又是这些，我是说，每个人都知道那里有藏匿处，但你知道，他们应该或多或少，或多或少透明，所以说，让我画一张我认为相关的缓存的图片，我认为与熔毁最相关的缓存结构。

所以首先你有，我们有核心，也就是，你知道的，机器上解析指令并具有寄存器的部分，并有一个加法单元和一个除法单元，你知道，不管机器的执行部分是什么，然后呢，每当它需要装货或存储时，与存储系统对话，嗯。

存储系统有一堆缓存，所以特别是在我们所说的机器中，有，称为一级数据缓存的数据缓存是，也许你知道64千字节的大小或者不是很大的东西，但如果你，如果您需要的数据在L One缓存中，你在几个周期内回到你身边。

L1缓存的结构是，它有一堆线条，什么叫线条，每一个都可能包含64字节的数据，行被索引，这是一张桌子，真的缓存，行按虚拟地址索引，嗯，呃，如果虚拟地址在缓存中，然后缓存保存该虚拟地址的数据，和，此外。

事实证明，人们相信，l一个缓存项包含从页表项获取的权限的副本，与此虚拟地址相对应的，所以有一个完整的，这是一个，我是说，核心发出加载指令，发生的第一件事是硬件在l one缓存中查找。

并查看是否有一个缓存项，其虚拟服装与请求的匹配，我们试图从中加载的地址，如果是这样我们就可以了机器就从缓存中返回这些数据，我们很快就完成了，如果数据不在L One缓存中。

那么下一步是我们--存储系统的其余部分--在，用物理地址寻址，所以我们现在需要一个物理地址，如果我们错过了一号缓存，把这个翻译放在一边，缓冲区是页表项的缓存，所以我们要查找程序在翻译中发出的虚拟地址。

往旁边看，缓冲器，它可能不在那里，在这种情况下，现在我们有很多工作要做，因为我们必须从内存中加载相关的页表条目，但让我们假设我们在翻译中击中了，往旁边看，缓冲器，我们现在可以得到所需的物理地址。

通常还有另一个缓存，另一个更大的缓存，物理索引，用物理地址索引，所以我们现在可能有了物理地址，所以我们可以看看这个缓存，如果我们错过了那里，然后我们必须在RAM系统之后发送物理地址，需要很长时间。

但当我们现在终于拿回数据时，我们可以填充二级缓存，并用这些东西填充一级缓存，我们从拉姆回来，把，呃，数据返回核心，我只是，呃，在L中命中一个缓存可能需要几个周期，击中左二缓存可能需要十几个或两个循环。

一个需要你去撞的失误可能需要你几百个循环，这些循环是，小于说，在一台2G赫兹的机器上半秒，所以有缓存是非常有利的，我是说你会，如果你没有缓存，你会在性能上牺牲几百倍，所以这些对体面的性能绝对至关重要。

这些缓存，这个缓存是L一个缓存，嗯，好吧，两者都有，事实证明，这两个缓存都可以包含，如果我们在用户空间运行，操作系统崩溃中的这两个缓存都是针对，这两个缓存都可以包含用户数据和内核数据。

L 2缓存可以包含内核数据，因为，它是物理地址，没有问题，嗯，Lone缓存有点棘手，当我们更改页表时，它实际上得到了解决，l one缓存的内容不再有效，因为我们改变页表。

这意味着虚拟地址的含义发生了变化，因此，如果您更改页表，您必须刷新l one缓存，尽管有更复杂的技巧可以让你避免这种情况，嗯等，但事实上，在本文的时代，这些操作系统。

在用户空间和内核空间之间更改时不更改页表，意味着我们不必刷新L1缓存的数据，这意味着l one缓存将同时包含用户和内核数据，它打的一些电话甚至更快，如果在系统调用返回时调用系统调用，还是会有。

呃可能仍然有用，缓存中的用户数据，因为我们从来没有改变过，我们从不改变页表或改变这些地址的含义，嗯反正，所以很可能有内核数据，即使您在用户空间中运行，L1缓存中可能有内核数据。

这些权限是从TLB中复制出来的，从页表条目中复制出来，告诉机器，哦，即使数据在缓存中，你不能看，它读取一个页面错误，所以这是一个很好的时间提到，尽管微架构优化的目的是完全透明的，那不可能是真的。

因为这些微架构优化的全部意义几乎总是提高性能，所以他们会，你保证至少在性能方面是可见的，也就是，您可以知道您的机器是否有缓存，因为如果它没有缓存，它会慢上几百倍，此外，您可以判断您试图获取的数据是否。

如果你能足够准确地测量时间，你做了一个负载，你可以知道负载是否在几个周期内返回，如果加载一百次后返回，数据一定已经缓存，数据可能必须从RAM加载，所以差异是深刻的，如果你能测量时间，你知道吗。

几纳秒甚至几十纳秒，你可以分辨出，所以在表演层面，微架构绝对不透明，我们谈论的所有事情，比如分支预测，缓存，或者不管那些东西是什么，嗯，所以，当然啦，很多人，即使微观建筑设计是在任何详细的层面上。

英特尔的秘密，他们如何实施这一点只是他们的私事，事实上，一直以来，它都引起了许多人的极大兴趣，因为它对性能影响很大，所以编译器编写者，比如说，对微架构了解很多，因为，像大多数人一样。

许多编译器优化都在隐式地利用，人们对机器内部实际工作的良好猜测，而且确实，CPU，只是制造商发布了优化指南，揭示了一些微架构技巧，但他们很少详细说明，当然没有足够的细节来真正理解熔毁的确切原因。

所以微架构的东西有点介于，应该是透明的、可见的和隐藏的，有点，很多人都很感兴趣，很多人知道关于它的各种随机的事情，好的，所以这个缓存的东西对熔毁感兴趣的原因，首先呢，关于缓存的任何问题。

关于论文使用缓存的主要方式，这篇论文谈到了这种叫做同花顺的技术，冲洗并重新装填，冲洗和重新加载是为了什么，它在回答这个问题，做了一段特定的代码，使用特定地址的内存，这不是直接的安全漏洞。

因为它只对你能得到的记忆有效，所以如果你是一个用户代码，然后你就有了一些记忆，那是你的记忆，你可以使用它，您可以调用自己的一个函数，或者你知道你，你就能看出，您可以使用刷新和重新加载来判断函数是否。

您刚刚执行的函数，用你的记忆，你不能直接用这个攻击，否则就不是袭击，你不能用这种技术来弄清楚，尽管因为进程有时共享内存，是啊，是啊，你可能还能做得很好，正确的说法是，你只能发现关于记忆，你可以访问。

好的，所以它回答了这个问题，确实做了一个特定的功能，呃，用这个记忆，所以第一步，嗯是我们要去冲洗，假设我们对地址X感兴趣，我们想刷新缓存，我们要确保缓存不包含位置x的内存，事实证明，为了我们的方便。

英特尔提供了一条名为CL Flash的指令，你给它一个地址，它会摆脱，它这个，将确保该位置不缓存在任何缓存中，所以这是超级方便的，嗯，即使机器没有提供这个指令，尽管事实证明有办法从缓存中删除东西，就像。

比如说，如果你知道缓存有64千字节，如果你加载64千字节的随机内存，你只需加载指令这些指令将被加载到缓存中，在您将64千字节的新数据加载到缓存中后，以前在里面的东西一定都不见了。

因为缓存只能容纳64千字节或者其他什么，即使没有这个漂亮的指令，您仍然可以刷新缓存中的所有内容，那么第二步就是，您对某个特定的代码是否使用x处的数据感兴趣，你只要调用代码，不管它是什么，它做它所做的。

也许用X，也许它没有，嗯，现在你想知道x是否真的在缓存中，因为如果是的话，因为你从缓存中刷新了它，如果它在缓存中，现在一定是f导致它被加载，除非有其他事情发生，所以你需要，你想做一个负载。

但你想知道装载需要多长时间，但你知道我们说的只是纳秒，就像5纳秒和100纳秒，我们怎样才能准确地测量时间，就是这样，Cpus来帮助我们，它们实际上提供指导，它给你循环粒度时间，嗯，它被称为RDTSC。

所以我们要，执行rdtc指令，它基本上告诉我们自机器以来经过的循环数，自机器启动以来已经经过的周期，因为它可能是，你知道的，两千兆赫兹机器，这意味着我们这里的精度是半纳秒，这是相当小的，现在我们要加载。

我又得到时间了，看看区别，对呀，b减去a，如果b减去a是，你知道的，五、六、七或者其他什么，这意味着缓存中的负载，这意味着这个函数使用了数据，如果b减去a是150，呃，这意味着X不在缓存中，是的，是的。

你知道吗，这可能意味着F，这可能意味着f从来没有使用过x，现在还不完全是板上钉钉的，因为f可能用了x，然后使用了缓存中与x冲突的其他内容，并导致X再次被踢出缓存，但你知道，对于简单的情况。

一个非常大的b减去a的值意味着没有使用它，b减去a的一个小值意味着f确实使用了该数据，所以这还不是攻击攻击，因为再一次，呃，我们必须能够，呃访问这个内存，所以这是我们的记忆。

关于同花顺加重新加载有什么问题吗，我想所有的预赛都结束了，呃，现在，让我们回到熔毁，所以这是一个更完整的版本，我在一开始给你展示了一个崩溃的核心，这是一次更彻底的熔毁。

所以我们现在知道了我是如何再次添加刷新和重新加载部分的，我们要声明这个缓冲区，这个想法是取决于，我们将只触摸内核的一点，嗯，我们要把它乘以四千九十六，所以我们希望用冲水加重新加载。

查看零的任何一个buff都在缓存中，或者四千九十六的buff在缓存中，那里大分离的原因，很明显，这个硬件有一个预取器，所以如果你从内存中加载一件事，它会把接下来的几个东西装起来，从内存到下几个缓存行。

所以我们不能有两个不同的缓存线，我们将应用冲洗和重新加载，以特别接近，需要相隔足够远，即使是硬件预取也不会造成混乱，所以我们把它们分开一整页，冲洗部分，现在我们只调用CL刷新指令。

以确保我们缓冲区的相关部分，我们在利用这条线路，可能有必要，也可能没有必要，但这里发生的是，我们在利用这种嗯，我们将利用时间上的差距，在你知道我们之间，呃，你是说这个10号线吗？它是内核地址的加载。

所以它会出错，嗯，但我们希望能够执行另几个指令，推测在这一指令退役之前，在它真正提出错误并取消这些指令之前，对如果故障，如果这个负载退役，在这一点上说这对我们来说还为时过早，因为结果会是。

我们实际上需要13号线进行推测性执行才能完成攻击，所以我们要确保这些负载不会尽可能长时间地退役，为了延迟故障和延迟投机性取消，现在我们知道，在所有以前的指令退役之前，指令是不会退役的，这是规则之一。

所以在七行，我在想象我们将推出一些昂贵的指导，很长一段时间都没有完成，你知道的，也许它装载了其他已知来自RAM的东西，所以需要几百个循环，或者它做除法或平方根，或者一些知道什么的人。

一些需要很长时间而且很长一段时间内不会退休的东西，因此会导致这个负载在很长一段时间内不会退役，给这些指令时间来推测性地执行，现在我们再次假设内核中有一个虚拟地址，执行第10行，在那之前。

第十行不会出现故障，我们知道它会升起一个断层，在它退休之前不会产生故障，但我们打算我们相信我们安排了事情，所以暂时不会退休，因为它还没有退休，因为在英特尔CPU上，返回数据，即使你不被允许看到它。

数据返回用于推测执行，即使你没有得到允许，这意味着我们可以推测地执行，机器将推测地执行第11行，获得内核数据的低位现在乘以四千九十六，13号线本身就是一个负载，又是一个负担，使用地址。

基本上是缓冲区的地址，加上r 2的内容，我们知道它会被取消，因为我们知道这会出错，我们知道我们三个的实际权利将被取消，但是十三行会导致，缓冲区中的一些数据要加载到缓存中，即使它最终不会影响寄存器三。

亚瑟第13行会导致一些东西被装载到缓存中，在这种情况下，取决于负载位是零还是一，第13行将导致实际缓存包含0的buff，或四千九十六的buff，然后向右，你知道即使R 2和R 3被取消，缓存中的更改。

你知道的，因为它应该是隐藏的微观建筑状态，它实际上会是，缓存将被更改，最终在某个时候故障会发生我们需要在故障发生后进行恢复，但是它，只是页面错误，事实证明，您可以或使用一个过程。

可以注册页面错误处理程序，并在页面错误后重新获得控制权，这篇论文提到了其他几种在故障后能够继续下去的方法，嗯，所以现在，我们所要做的就是弄清楚它是否是零的buff。

或者是装在缓存中的四千九十六块的buff，现在我们可以做刷新和重新加载的重新加载部分，你知道的，读出准确的时间，呃，零负载缓冲器，再读一遍时间，一个人的buff，再读一遍时间，并在时间上比较两个差异。

无论哪一个花的时间越短，um可能指示内核数据的低位是零还是一，然后如果我们报告，重复一遍，你知道几十亿次，我们可以扫描所有的内核内存，嗯，但是在这个例子中，如果b减去a小于c减去b。

这不意味着0的buff是c吗，让我们看看，如果我错了，b减去a，是啊，是啊，这意味着缓冲零是现金，哦，是啊，是啊，是啊，是啊，你说的对，是啊，是啊，现在我们在做饭，哦，对不起，你之前需要什么。

我们有一个，如果之前喜欢我的九行，我们需要吗，如果现在，还是还是不不不，哦，“如果”是为了帮助我说明投机性处决的正当理由，保持计算，即使我们不知道树枝是否拿走了，但在这里，猜测的真正核心是。

我们不知道这批货是否会出错，所以我们是机器在投机性地执行超过负载，理论上它可能在大多数负载上，别错对了，或者即使可能需要很长时间，就像一个负载可能需要数百个循环，嗯，所以我们希望能够，因此。

机器将投机性地执行超过负载，即使它没有，你知道不知道它是否会出错，这是一个负载做了故障，然后它将撤销所有这些投机性的执行，有一个投机性的处决出现了，一个长时间运行的指令，可能成功也可能不成功。

就像除法一样，我们知道它是否会被0除吗，所以除法后的指令也是推测性的，无论如何，猜测，真正关键的猜测现在从这里开始，事实上，我们试图让攻击更成功，我们确保猜测从这里开始，但这是我们真正关心的猜测。

对于本例，我们只读了一点，是呀，有一些像真的很小的，我们可以进行简单的修改，以读取完整寄存器的比特大小，是啊，是啊，跑这个六十，四次，一位一个，为什么不可能一次读取64位，六口井，你需要缓冲器。

这个缓冲区的大小必须是，呃，脚趾，你知道2到你正在阅读的位数，四千九十六什么的，所以六十四位太大了，因为我们没有足够的内存，呃，做一个缓冲器，这么大，我们需要这样设置，但不管怎样，是啊，是啊。

六十四位太多了，你当然可以一次读八个比特，这个缓冲器的大小是250，六次，四千，九十六，这篇论文实际上在一个，论文观察到，因为大部分时间都在同花顺加上重新加载，如果您一次读取一个字节。

然后计算出那个字节的位是什么，需要256个，刷新并为每个可能的值重新加载一次，如果你一次加载一点，然后每个位只需要一次同花顺加上重新加载，或者两个两个探针或两个冲洗加重新加载，所以如果你一次读一点。

那么你最终只做了16个同花顺加上重新加载，如果你一次读一口，你最终会做256个同花顺加上重新装填，所以报纸上说一次做一点会更快，一次咬一口，这似乎有点违反直觉，但似乎是真的，其他问题，所以呃。

这个用户会在哪里，或者这个程序必须从哪里运行，机器上有什么特定的位置吗，一定要这样吗，或者像你会在哪里咬它，我猜你想去哪儿，这个程序将从哪里运行，呃，它能像用户一样，嗯是的，这取决于您对机器的访问权限。

你想窃取的数据在哪里，你知道谁知道，但一个例子是假设，你登录了雅典娜拨号机，你知道，有几百个其他用户，你想偷别人的密码，你很有耐心，你可以用，让我们假设雅典娜现在是几年前，雅典娜运行的是Linux版本。

它将内核映射到每个用户的，每个进程都处理空间，然后你就可以用熔毁出去了，你知道的，一点一点，或者内核中的一切，包括i o缓冲区和网络缓冲区之类的，如果有人输入密码，如果你幸运或有耐心。

有人在输入你的密码，加载所有内核内存，您将在内核内存中看到密码，因为事实上内核可能会映射像xv六个映射，所有的物理记忆，这意味着你可能可以读取所有的物理内存，这就是所有其他过程。

在分时机上使用此技术的内存，这样我就可以看到文本编辑器内容中每个人的内容，或者我现在喜欢的任何东西，你必须这样做，这是你可以使用它的一种方式，如果你在其他情况下使用分时机。

这将是不同的意义我的意思是分时度假不再那么普遍了，但最致命的场景是某种云计算，你知道你在使用像亚马逊这样的云提供商，你知道哪些是同一台机器上的许多客户，你知道这取决于他们如何设置虚拟机的细节。

监视器或容器系统，或者不管是什么，如果你从亚马逊买时间，然后你就可以窥视其他客户的记忆，运行在同一台亚马逊机器上的软件，也许，所以我想这是真正的，这就是人们实际上使用这个的方式，可能实际上是另一个时间。

它可能会有用，当你浏览网页时，你的浏览器是什么，你的浏览器实际上在里面运行了很多代码，不受信任的，这是由您访问的随机网站提供的，也许是插件的形式，也许是JavaScript的形式。

加载到浏览器中并由浏览器编译的，并执行它，这次袭击有可能是由，嗯，代码，在浏览器中运行的，当你浏览网页时，你可能不会，即使它是从网站上加载的，他们会偷走你笔记本电脑上的任何东西，我不知道细节是否很好。

但是有人通过JavaScript或WebAssembly演示过攻击吗，我不知道，我不知道，我觉得人们当然担心网络组装，我不知道这次攻击对JavaScript来说是否真的可能，我知道也许症结在于。

准确的时间，你不能完全得到这纳秒的时间，所以你现在不能完全执行刷新加重新加载，你知道的，更聪明的人是否能想出一种方法来做到这一点，我不知道我们有汇编更接近于只是运行机器代码。

你知道我不知道细节是怎么解决的，但你知道，天哪，人们很快就想到了，嗯，事实证明，攻击并不总是像，出于，我不认为作者从来没有解释过或只是猜测过，你可以看到，我不知道你是否看得清，也许你看不到这个。

但如果你翻到他们论文的最后一页，您将看到，其实，你知道的，他们对自己的机器发动了攻击，并从他们自己的数据中提取了一堆数据，他们自己机器上的内核，如果你仔细观察，你会看到有一个巨大的。

所有这些线都只是xxx xx xx x，所有这些带点的线x轴，这些地方他们没有设法提取任何东西，熔毁失败的地方，即使他们重复了很多次，嗯，你可以看出他们一定是，你知道他们是。

报纸对这次攻击的版本被重试了很多很多次，因为，比如说，第六节第二节，谈论性能，说在某些情况下，他们提取数据的速度只有每秒10字节，这意味着他们坐在那里一次又一次地尝试，千百次之后。

他们终于得到了一些数据，就是那个同花顺加重新加载，表示两个缓存线在不同的加载时间，所以有一些无法解释的原因，熔毁实际上失败是相当频繁的，我得到了一些数据，我这里有真实的数据，但也有一堆数据表明。

他们没有得到，我不知道据我所知的人，人们并不确定它成功时的所有条件是什么，当你不知道的时候，最直接的可能性是，如果内核数据在l one缓存中，熔毁成功，如果内核数据不在l one缓存中，它没有成功。

很容易相信这可能是发生了什么，嗯，因为如果它不在Lone缓存中，那么就会有一大堆更多的机器参与投机负载，很容易想象用于投机负载的CPU，那是，你知道的，也许不知道，如果需要的话。

不会费心做从RAM加载东西所需的所有工作，事情没那么简单，你可以看出事情没那么简单，因为报纸上说有时当他们被审判时，许多人重试过，很多次它终于奏效了，所以有一些更复杂的情况，也许一场有效的比赛。

CPU内的竞赛，它偶尔会在下面工作，即使对于不在缓存中的数据，论文的结尾其实也是，如果你没有得到值得一读的，因为它确实解释了一种更真实的世界，就像我们想找出这个特殊的东西，你知道这个，就像。

我们知道Firefox的密码管理器中存储了密码，我们想让他们出去用熔毁来偷他们，你知道所有的，你知道吗，你怎么知道地址的？比如说，他们策划了一次全面的攻击，我是说，学者们的全面攻击，不是真正的攻击者。

但尽管如此，我还是填写了许多务实的细节，我想说的最后一件事是修复，嗯，当这篇论文出来的时候，我们已经触及了一点，引起了很多关注，实际上还有第二篇论文，一组重叠的人关于不同的攻击，也使用不同的。

CPU内部称为Specter的不同类型的猜测，所以这两份文件几乎是在同一时间出来的，非常令人兴奋，所以人们匆匆忙忙，人们意识到那个男孩，这是极其有害的，因为现在我们谈论的是你知道孤立已经被打破了。

太基本了，你几乎不再想它了，但你知道这件事，这是一种破坏页表保护的技术，这就像是非常基本的，或者至少以一种非常普遍的方式破坏了一个极其重要的安全部分，对呀，好像你什么都能读。

所以人们真的真的很努力地部署修复程序，以及许多操作系统在几周内安装的即时修复，呃，嗯，这张纸出来了，有时已经安装了这个叫做Kaiser的东西，它现在在Linux中被称为KPTI，这是一个非常简单的想法。

这个想法就像不把内核映射放在用户页表中一样，取而代之的是，如在X中，v，系统调用和用户空间期间的六个切换页表，您只有用户映射，进行系统调用，有某种蹦床的安排，就像在x v中，六，将页表切换到页表。

它具有内核映射以便执行内核，这导致这次攻击不起作用，因为，因为你切换页表，呃，r one中的虚拟地址，不仅不再有效，它不再有意义了，因为它没有翻译，所以CPU不知道该怎么处理它。

像这样的虚拟地址不会被缓存，它甚至不在TL B中，所以说，内核没有办法决定，与此虚拟地址相对应的内存是什么，你知道，当在用户空间执行此攻击时，因为这个虚拟的，这个内核虚拟地址不再意味着什么，它不是。

这并不违法，只是毫无意义，所以这将导致攻击不起作用，这个kaiser修复的缺点是现在系统调用更加昂贵，因为切换页表，嗯，如果你什么都不做，切换页表会导致刷新TOB，因为现在，所有这些虚拟地址，和结核病。

是错误的虚拟地址，不再与此页表对应，它导致l one缓存被刷新，因为它实际上被寻址了，等等，在一些机器上，制作了切换页表，系统调用要慢得多，但是最近的机器实际上有一个叫做PCI的技巧，你可以查一下。

但基本上做到了，这样您就可以避免刷新页表开关上的这些缓存，虽然还需要一些时间，如果你在网上到处找人，当时有很多人担心这次分裂，这两个页表的想法会慢得令人无法接受，事实上，这并不是一个严重的问题。

如果你四处闲逛，你会看到人们对典型工作量的猜测，你知道它对典型工作负载的整体性能有多大影响，那个，毕竟，不要把所有的时间都花在输入X和内核上，就像5%，所以这不是一个糟糕的交易。

那么关于这位德皇有什么问题吗，所以人们很快就采用了这个，事实上，有些果仁已经采用了它因为它可以抵御其他攻击，还有一个合理的硬件修复，我相信英特尔实际上在最近的处理器上制造了，AMD已经做了。

这基本上是因为呃，事实上，许可，你知道的，这是缓存的结构，当和一条指令从l one缓存加载某些内容时，就像这个内核数据，我们试图攻击权限，或者人们认为权限就在缓存条目中，所以CPU没有问题。

检查此时的权限，而且确实，um AMD CPU，也许现代英特尔CPU会很早就进行权限检查，不会返回此数据，他们甚至不会把它送回核心，如果权限检查没有结果，所以这些推测性的指令都不能看到禁止的数据。

所以我不知道你是否知道，这个问题的答案很可能只是一种推测，但是嗯，呃，无意双关语，但为什么你认为英特尔会这样做似乎是因为对我来说，好像是在讨论，我们应该检查瞬态指令的权限吗，他们就像不，何必费心呢，嗯。

我只需要一个简单的检查，但为什么要费心呢，东西是透明的，对呀，我的意思是，无论哪种方式，用户都无法看到数据，早点检查，你知道吗，这就像在一条非常关键的道路上的一些大门，对的。

你知道核心孤独的数据缓存路径是非常关键的性能，你知道的，如果你能刮掉几个晶体管，你知道在发出指令和取回数据之间的关键路径，你知道这可能会让你有一个稍微快一点的周期时间和运行程序更快。

所以一定是我不知道的情况，一定是这样，但很容易想象这会让他们付出代价，几个晶体管来尽早执行权限，因为毕竟他们退休后仍然需要所有的东西，这不像做得早，会节省他们以后的一些工作，他们还是得把故障推迟到退休。

所以所有的东西都还在那里，我只是在猜测，这会有任何好处，会有一点额外的工作，直到它完全看不见，你知道的，在体系结构级别上理论上是不可见的，有没有内核决定喜欢，还原此Kaiser修复。

现在英特尔已经修复了CPU，我想我又要提高表现了，我知道它在很多内核上是可选的，我不太确定，英特尔的修复是怎么回事，我相当肯定他们有这样的解决方案，但你知道我真的不知道发生了什么，我认为Linux内核。

你可以直接问，你知道的，已实施哪些硬件修复，和Linux，你知道改变了它所能实现的缓解，取决于什么，实际上硬件告诉它，所以它可能，这样你就可以，你真的可以这么做，就像你可以阅读足够多的关于处理器的信息。

作为内核知道该做什么，但你可以在你的奔跑中奔跑，你的笔记本电脑，有一个Linux命令实际上是打开的，就像我们只是它告诉你的，准确地说，你知道已经实现了什么修复，在硬件上减轻了什么，因为有很多这样的东西。

你知道的，光谱执行攻击，你是说Linux实际上会使用组合页表，如果CPU，是呀，酷，给它一个，你知道，我最近检查过了，对呀，我相信是这样，所有的权利，对不起，那么人们在做什么，就像。

他们是怎么找到这个的，他们想做什么，他们想做什么，试图闯入电脑，没有井，谁知道他们到底想做什么，我是说那些文件，或，你知道，由各种学者写的，也许你知道他们的研究发现了安全问题，我想对坏人来说。

很长一段时间以来，他们的动机之一是他们想打破，呃，地址空间随机化，他们有更早的锥度，你知道，不同的计划试图对归化产生巨大的兴趣，就像一群，你知道的，在这个领域的一股研究人员，有这个背景。

我认为零人项目来自一个完全不同的角度，我看见你了，谢谢。这是人，我想罗伯茨之前说过人们在这个领域工作了几十年，你知道的，试图找到他们可以利用的bug，取而代之的是，所以我想这是一个很难回答的问题。

但像有多大可能有另一个像融化在那里，因为看起来很有可能，好的，他就像微型的，那个，基本的，像微架构的东西，比如公开更改，那是对的，我认为部分原因是CPU制造商，你知道的，几十年来，你知道的，越来越乐观。

我是说有很多，很多，在微架构中有许多很酷的小技巧来让事情变得更快，你知道，现在，人们并不那么担心，或者只是没有注意到这可能是一个严重的安全问题，所以现在人们非常清楚这些东西可能是一个严重的安全问题。

但我们现在的处境是，你知道的，在CPU内部三十年的聪明想法，所以确实有一群，我是说，自从这篇论文发表以来，确实在这篇论文出来之前，一堆的，一系列这种类型的攻击已经曝光，利用各种不同的，呃，东西和CPU。

所以我想这一切还需要一段时间才能平息，你知道的，两年，基本上每年，每次会议基本上都是在，就像，属性，看看它们是否能让税收发挥作用，也许一个更大的问题是你是否知道情况是否良好，你知道有，你知道。

十五、二十、三十，必须解决的事情，然后我们就结束了，或者是否有更高的水平，出了问题，你知道我们都，我是说，这可能太悲观了，但你知道，人们对孤立很有信心，作为一个想法，假设隔离有效是完全合理的。

我们将设计云计算之类的东西，你知道，在浏览器中运行JavaScript，所有这些东西都是在假设，这其实不是真的，但它足够接近相信足够接近真的，这种孤立只会，你知道吗，因为没什么大不了的，安全问题。

实际上可能仍然，这一袋微观建筑税不是，那个故事似乎更有说服力。那是肯定的，只是为了补充一下，我不太确定，呃，办公室的专业水平会喜欢CPU设计，但是在没有微架构的情况下。

CPU设计能在多大程度上简单地进行呢，在保持高性能的同时，我是说人们相信这很好的安全性，我也是，但是是的，嗯，其中一些显然是可以修复的，就像这个熔毁的东西，我是说有一个解决办法，你知道的，实际检查权限。

所以可能不会因为出现的其他攻击而牺牲任何性能，不清楚您是否可以在不牺牲性能的情况下修复它们，我是说一些非常，非常深，就像我们分享的事实，你知道有很多分享，比如在分时或云环境中，只是有很多分享，所以说。

比如说，假设有一个磁盘驱动器或网络，哎呦，您可能能够获得云服务器上其他人的信息，只需观察他们的交通如何干扰你的交通，此通信量或网络通信量，或者内存贩子什么的，所以有某种，你知道，我不知道那是否实际。

也许不是，虽然你知道，对许多人来说，人们说的许多事情，男孩，那次攻击似乎不实际，你知道它被证明是足够实际的，我想，所以很多微观建筑的东西，也许可以在没有性能损失的情况下进行清理。

或者可能无法清理而不损失性能，但我觉得，我认为这是一个比仅仅，我们要应用一些修复，而更长的路，和其他地方最尖锐的是密码学，有很多，多年来人们研究这种聪明的，经常缓存，基于时间的感知方法。

密钥和其他人的密码，你知道的，跑步的人，我正在运行密码和加密，在同一台机器上，你通过看缓存定时来猜测我的密钥，答案是绝对的，它不像一个微架构bug，它是，这只是分享的结果，无论如何。

我不知道这一切会如何发展，但它不是，这并不简单，奇怪的是，当人们在，嗯，只是测量CPU的电磁辐射，并找出运行的指令和其中的数据，但是机器学习有一定的准确性，你知道的，不是百分之百，但就像惊人的准确性。

因为任何超过零的东西都很可怕，是啊，是啊，我们都生活在，你知道吗，都是，在攻击之间有一个界限，在可能的攻击之间有一些门槛，但你知道，天啊只是好像啊，太贵或尴尬，或者痛苦，或任何复杂的执行。

真正可以实施的攻击，当然我们只应该防御二类，因为头等舱往往太贵了，无法防御，但由于所包含的东西的价值，计算机变得更大，攻击者变得更聪明，更接近共享环境，攻击的阈值，足以抵御变化的可行性，我听够了讲座。

但我很乐意回答更多的问题，人们有，谢谢。谢谢。谢谢，哦，我其实有个关于缓存的问题，所以Lone缓存，钉子二分享得好吗，所以每个CPU的图片都是不同的，对于不同型号的CPU，等，今天的习惯。

比这个复杂一点，通常您有多个核心，二、四、八、六十，四个什么的，每一个都有一个离CPU很近的l one缓存，但它很小，又快又小，每个核心通常也有一个更大的L 2缓存，你知道的，它有点专用于那个CPU。

然后呢，然后通常有一个共享的L 3缓存，经常但不总是，另一种方法是将L两个缓存求和，对所有的CPU来说都很方便，这样我就可以超高速访问我的L 2缓存，但我可以用稍微大一点的惩罚来对付其他人。

所以现金规模的影响更大，所以你们三个经常看到三级缓存或者，你把两个第二级缓存连接起来，通常L2和L3是物理寻址的，我一个，对不起，所以物理处理的意义在于不同的，是啊，是啊，很容易。

L One中的东西实际上可以寻址缓存，嗯，如果相同的数据与不同的虚拟地址一起使用，你不能，你知道的，虚拟地址缓存并不能真正帮助您找到它，如果它缓存在不同的地址下，这两个缓存，数据是独立可用的。

无论您在哪个虚拟地址下寻址它，嗯，是啊，是啊，相对于TLV中的所有这些缓存，MU位于哪里，哦，它不是，它是，它是分布的，真的是因为，我是说，最明显的，我是说，我想在现实生活中，最关键的是TLB。

我相信它与Lone缓存并行索引，典型的好吧，所以如果你在缓存中命中，Lone缓存很棒，虽然可能有一个，无论如何，如果你在Lone缓存中错过了，然后现在你有身体，你抬头看结核病，同时，现在你是一只实体猫。

虽然不仅仅是一个盒子坐在某个地方，它实际上涉及到，哦好吧，但它不是硬件吗，所以哦，一切都是这里的硬件，是啊，是啊，哇真有趣，但请记住这些，你知道吗，这些芯片上有数十亿个晶体管，所以是的，可能是硬件。

但我们说的是非常复杂的硬件，它是用非常复杂的软件设计的，比如设计技术，这样它就可以做非常，非常复杂和复杂的事情，所以是的，是硬件，但是是的，一点也不，直截了当，表映射也是如此。

就像页表映射最终会化为灰烬一样，还是它们总是通过TLB路由，因为如果你错过了，TLB，你必须去记忆中找回那个权利，所以L2缓存肯定会容纳，呃从托布小姐的L 2缓存的角度来看，结核病重新加载。

或者只是内存访问，所以TB需要加载一堆页表垃圾，这只是一个内存负载，它可以很容易地缓存在L 2中，但它必须跳过1，因为我有虚拟地址，我不认为TLB会因为它而咨询L，好的，所以因为它实际上是被解决的。

是的嗯还有关于幽灵袭击的一件事，嗯嗯，你怎么会这样，所以事情就像，我听说过熔毁检查员至少十几次，每次我查的时候，我不明白，所以这是我第一次真正明白发生了什么，嗯，但幽灵是有嗯，就像，熔化有多相似。

它不是，这是不好的，我对幽灵攻击的理解是通过训练分支预测器，你知道的，你试图从其中获得税收的另一个代码，让我们，我想，嗯，另一个过程，你和它分享一些记忆，你知道，因为你，它真的和你的节目一样。

但是是其他用户在运行程序，你可以把树枝，支部，分支预测器使用的表是共享的，不同的你知道，如果我在CPU上运行，禁止你跑，或者你在同一个CPU的不同超线程上运行，每个人都看到同一根树枝。

你知道看到相同的分支预测器，所以我可以训练分支预测器以某种方式预测分支，然后我让你跑，你在用我的分支预测器训练跑步，对吧，所以这意味着我基本上可以诱骗你的程序投机性地执行，我选择的指示，现在只是猜测。

所以说，它们当然会被解开，但它们会造成现金负担，在某种程度上我可以控制，因为我控制你如何推测，你执行，然后如果我们共享记忆，我可以使用刷新和重新加载来感知哪些缓存行，您的程序加载在这个推测执行中。

哦所以，那样的话，你就不需要了，嗯，你不需要喜欢，如直接地址，寻址一段内存，您只需要确保程序将推测性地执行，就像熔毁一样，我们自己做的，但是探长你刚才说，这有点酷，因为你可以说，哦，你知道吗。

只需通过训练分支预测器来加载这个秘密，不知道秘密在哪里，是啊，是啊，或者像你认识了一个人，是啊，是啊，你，你得知道，你吃的和或谷物很棒，是啊，是啊，对不起，是啊，是啊，你要知道，但你不必自己去爱它。

是啊，是啊，东西不是秘密，对呀，你可能在运行一个程序，我知道你在运行什么程序，你知道，是啊，是啊，好的，那是有道理的，谢谢。是啊，是啊，我只是在想，当你发表这样的研究论文时，你知道它就在外面，人。

Linux和Windows以及英特尔，让他们试着去争先恐后地修补窃听器，但它也在那里，黑客可以开始喜欢，从论文中学习并喜欢，哦，这是我们可以使用的一种方法，我是，我在想，就像，作为一个研究员在那里。

的一般做法，就像，当我们在写论文的时候，会喜欢透露是的，先引用未引用的好人，这样他们就可以领先一步，作者已经通知了每一个，你知道的，CPU制造商和EOS制造商在发表论文之前，有一个完整的。

报纸上有一个完整的协议，这种人甚至不会再被接受了，除非你知道你遵守了协议，是啊，是啊，这并不意味着攻击者没有正确使用它，因为耶，可能知道袭击者20年前发现了这个，但是，因为两者都不直截了当。

我想在这个特殊的情况下，我想你知道有一些，呃，英特尔对Linux社区之间的合作并不太兴奋，而且间隔不是完全光滑的，我想在，当这件事发生的时候，我想他们在一些国王那里工作过，但是，我觉得有点吓人。

因为我在维基百科上读到Ubuntu修复已经发布，论文发表后，我觉得很吓人，但是，非常感谢，谢谢。谢谢。谢谢。

