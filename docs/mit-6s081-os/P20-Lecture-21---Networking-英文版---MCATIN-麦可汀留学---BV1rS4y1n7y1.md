# P20：Lecture 21 - Networking 英文版 - MCATIN-麦可汀留学 - BV1rS4y1n7y1

所有的权利，你好，欢迎大家感恩节归来，嗯，有人能听到我吗是的，你真厉害，今天一切都好，我想谈谈，呃，网络及其与操作系统的关系，嗯，这其中的很多是，一个面向实验室的，最后一个实验室。

你将在其中真正构建一些网络接口驱动程序，有些只是性格，对网络软件在操作系统中通常如何设置的一般理解，然后我们将讨论今天关于Livelock的报纸，这说明了一个有趣的危险，网络和堆栈设计中的UM。

所以首先让我通过画几张网络图片来设置一般的滑雪场景，um网络，当然，连接不同的主机，呃，有两种方法，其中可以查看连接，一个是在附近的宿主中，他们经常和你联系在一起，但本质上是同一个网络。

所以可能有一个以太网，也许这是一个开关或电缆，您可能有一堆主机连接到这个，这个以太网，或者你好，先生，笔记本电脑或服务器，或者路由器，尽可能地忽略，这个网络直接连接到什么的细节，所以它可能是一根电缆。

嗯，大概是这样，嗯，今天的论文写的时候，这可能是以太网交换机，这可能是某种WiFi无线土地，这些东西根本不是电线，而是无线电链接，但在很大程度上，这些嗯，这些差异在某种程度上确切地说，本地连接是什么。

在网络堆栈中的一个相当低的级别上完全被掩盖了，以此类推，这些主机中的每一个都可能有不同的应用程序，也许这里有一个网络浏览器，你知道的，这里的http服务器，他们需要互相交谈，这个网络。

你能建立一个局域网的规模是有限制的，所以现在，其缩写通常为局域网的n，思考的方式，也许是局域网可以和网络上的一样大，让所有的主持人都能看到，对方所有的包，有时主持人需要向所有本地主持人广播。

你知道用12个20个或50个都可以，甚至可能有一百个主机，但是你不能很容易地建立单一的网络，在那里，所有的主持人都可以或多或少地直接与对方交谈，不止说几百个主持人，所以为了处理这个问题。

更大的互联网的构建方式是有许多这些单独的土地，也许麻省理工学院有一个，你知道的，也许哈佛有一个，它们之间有某种联系，您可以将其视为路由器，所以可能有一个路由器插入了麻省理工学院的局域网，也可能与。

到哈佛网络，事实上有一个路由器网络，它本质上是互联网的支柱，包括长途路由器到路由器链路，所以全国各地可能有更长的联系，也许这个路由器插在，呃，斯坦福大学的一些本地网络，然后我们有主持人，我们有那种，嗯。

呃，我们想在麻省理工学院主持的更详细的任务，能够通过一系列路由器与斯坦福大学的主机交谈，这叫做路由，所以我们需要一个方法让麻省理工学院的主持人解决，为斯坦福大学的个别主持人命名，我们需要一些方法。

这样麻省理工学院附近的路由器就可以查看麻省理工学院发送的数据包，并说，哦，那是哈佛的包裹，或者给斯坦福的一包，或者一个包，你知道需要去日本的某个地方，或者谁知道是什么，所以说，从网络协议的角度。

这个当地人，这种本地通信由以太网协议负责，这种远距离通信是在此基础上分层的，并由IP或互联网协议处理，知道如何长途跋涉到遥远的宿主，好的，简而言之，这就是网络的样子，我现在想谈谈。

在以太网上移动的数据包里面有什么，或者在更大的互联网上移动，着眼于最终谈论软件，必须处理主机的主机和必须处理这些数据包的路由器，所以让我从最低的水平开始，谈论以太网数据包里有什么。

所以当两个离得很近的宿主，连接到同一电缆或同一WiFi网络，或者同一个以太网想互相交谈，最低级的协议，允许同一片土地上的两个主人互相交谈，作为以太网协议，你可以想到一个主机主机，一个。

通过以太网发送一个帧给两个主机，所谓的以太网帧，也就是数据包的以太网，它是一系列发送的字节，通过以太网从一个主机到另一个主机，以太网协议的作用是在其中包含足够的信息，让两个主持人意识到谁在互相交谈。

并使主机能够识别发往它们的数据包，所以以太网头是什么样子的，所以以太网处理的方式，这是每个以太网数据包在开始时，有三个字段的标头，然后是一些以太网有效载荷，标题中的内容是以太网地址。

我们称它们为目的地地址和源地址，以及数据包的类型，这些地址中的每一个都是一个4位8位的数字，唯一标识特定网络接口卡的，真的，嗯，并且此类型字段将指示收件人主机，它应该怎么处理那个包，这真正意味着的是。

什么更高级别的协议应该检查和处理以太网包的有效负载，所以这些是，嗯，通常设置为通过电线，嗯，这四十八，加四八，加上16位头部，然后，不管有多少有效载荷，软件并不真正可见，但是在包的开头会有一些东西。

这是硬件在很低的水平上识别的，表示数据包的开始，接收方需要知道数据包何时结束，所以最后会有另一种特殊的位模式，表示数据包的结束，这两个开始和结束标志从来没有被软件看到，但剩下的。

这个以太网帧的其余部分由网络接口卡交付，软件在H 2处的缺口，如果你看过这门课的最终实验室，你会看到我们给你的软件包括一堆新文件，包括内核斜杠，净点h，它包含了一系列数据包头的定义，对于不同的网络协议。

所以这只是直接从我们给你的net dot h文件中提取的文本，它包括以太网布局的描述，我们给你的这个软件实际上使用，字面上，使用此结构定义来解析传入的以太网数据包，也就是把头部分开以获得目的地并键入。

它还使用该结构来格式化数据包，所以主人真的负责，设置和解析以太网使用的这个头，是啊，是啊，我有个问题，拜托了，就是，是您提到的硬件使用的位模式，确定类似于实验室中eoop的包的开始和结束。

也就是包的末尾，否，EAP是驱动器和缺口之间的独立机构，帮助他们交流，这是，你知道的，有一些电气方案，有一些慢电平的电或光信号方案，通过以太网电缆传输比特，这些旗帜与，它们是典型的电模式。

在包内是不合法的，所以你知道，一个方案是不只是通过电线发送零一个比特，你可以发送，你可以发送，两个信号的序列，所以可能有四种不同的符号，两个不同的序列，你知道的，电压等级什么的。

四个可能的符号中的两个表示数据包正文中的零位或一位，剩下的表示开始和结束，这实际上是几年前使用的一个计划，几年前在以太网中就使用了类似的方案，我其实不知道它是怎么工作的，现在，我想知道这些地址。

这是四个八位地址吗，四个八位的原因是他们想确保，有足够的比特能够给出一个唯一的地址，每一个不同的缺口，所以有大量可能的地址，这四个八位地址的内部结构是，前二十四位是制造商编号，每个网络接口卡的制造商。

尼克斯有自己的制造商号码，这是前两个四位，第二个2-4位是任意数字，可以是制造商分配的任何唯一号码，所以制造商通常按升序分配它们，所以如果你买，你知道半打网络接口卡，网络接口卡。

每个网络接口卡都有自己的地址，如果你看看地址，你会看到这六张牌的高位是一样的，你从同一个制造商买的，但低沉的，低的2 4位可能是6，他们没有帮助的是定位目标软管。

所以如果你知道你所说的主机在同一个局域网上，因为您可以使用以太网地址，它在同一个局域网上，所以我们会监听有自己地址的数据包，但如果你想和主持人说话，在这个国家的另一边，你必须使用不同的方案。

这就是IP的全部，我稍后会讲到，这就是，呃，这些包看起来像，您实际上可以查看运行中的以太网数据包，使用TCP转储程序，你被鼓励这样做，你可能需要把这个作为实验室的一部分，这实际上是一个。

实验室TCP转储的输出，TCB转储在这里告诉我们什么，告诉我们一大堆事情，第一部分是数据包到达的时间，嗯，如果你喜欢，你可以在笔记本电脑上试试这个，如果安装tcp转储，嗯，第一行的其余部分是一种人类。

对那是什么样的数据包的可读解释，然后下面这三行，或者这里的这一部分是接收到的数据包的十六进制转储，你可以看到我们实际上可以跟随以太网头，前四个八位或六个字节是广播地址，所有的F和所有的F。

广播到本地网络上所有主机的以太网地址，接下来的四个八位是发送主机的以太网地址，那个，你知道的，我们不一定能说出任何关于，虽然高比特，事实上，这是由XP产生的，六个在Q亩以下，所以没有真正的尼克参与。

所以这里实际上不是制造商的号码，这只是Q穆编造的东西，然后接下来的16位，接下来的两个字节是类型，这是数据包的以太网类型，在这种情况下是零八，零六，这是一个叫做ARP的协议，我一会儿就会谈到。

剩下的东西是一个艺术包的有效载荷，我也会谈论任何问题，关于我们是什么，我们在这里看到的，如果你关心网络，这非常值得在你自己的电脑上尝试一下，好的，所以下一个与实验室相关的协议。

通过以太网进行通信称为ARP，所以在以太网级别，每台主机都有一个4位8位以太网地址，而是为了在互联网上交流，原来你需要使用一个32位的互联网地址，互联网地址不同的原因是互联网地址有内部结构，在三。

两个位在主机的三个两个位的Internet地址中，高比特充满了关于整个互联网中哪里的各种提示，1。这个包必须送走，所以你可以把互联网地址想象成在高比特中有一个网络号码，实际上比那要复杂一点。

但它本质上是一个网络号码，每个网络和互联网都有一个不同的数字，路由器看这些，Internet地址中的高位来决定Internet上的哪个路由器，这个数据包需要转发到，然后是32位以太网互联网地址中的低位。

IP地址，是我们要在其本地网络上与之交谈的主机的号码，但是当一个包最终到达，当Internet数据包到达以太网时，我们需要某种方法给出一个32位的IP地址，找出那个主机的四个八位以太网地址。

互联网选择这样做的方式是有一个动态解析协议，一种称为ARP的地址解析协议的请求响应协议，思考的方式是，当IP数据包到达路由器时，或者需要由主机发送，到已知位于同一局域网局域网上的主机。

发送者首先在上面广播一个艺术包，这是一个请求，说明谁拥有这个IP地址，请使用您的48位以太网地址进行响应，假设主机存在，并且它被打开，它将用ARP响应包进行响应，嗯，这是一个艺术包的包的格式。

它实际显示的方式是在以太网数据包中，所以你，你在网络中看到的首先是以太网头，它有四个八位源字段和一个四个八位目标字段，可能是目标源类型，所以这是以太网头，然后从以太网的角度来看，剩下的是有效载荷。

但实际上这是一门艺术，在以太网有效负载中是一个艺术包，在以太网头部之后，这些字段嘣嘣嘣，接收主机知道的方式是一个艺术包，就是通过查看这个类型字段，如果是零八零六，这是ARP的以太网协议号。

然后接收主机软件就会知道把这个数据包交给它的ARP，这些包里装的是什么？这里有一堆垃圾，这基本上相当于说我有一个互联网地址，我想把它变成一个以太网地址，如果您拥有此互联网地址，请回复，然后呢。

发送这个艺术包的任何主机，这就足以确定谁将动态地建造这辆车了，告诉他们以太网和IP地址之间的对应关系的表，同样，我们可以使用TCP转储来查看这些数据包，你很有可能看到他们，如果运行tcp转储，又来了。

从实验室获取的TCP转储输出，事实证明，在实验室里，你会知道你的XV6最终会模拟说话，真实但会说话的以太网协议，并通过模拟以太网协议通过以太网发送IP数据包，与您运行的任何主机，你想要的QM。

所以当你想，你实际上可以看到X之间的ARP交换，V6和你的主人，所以我们在这里看到的是，我的主人想知道我的x vsix的IP地址，想弄清楚它在陆地上的以太网地址，QMU模拟的第二个包是我的XV6。

您可以看到生成这个的代码，我的XVSix看到了这个请求，意识到它是IP地址和请求的所有者，它发回响应，tcp dump很好地解析了art包中的字段，印在这里，我想这是发件人的IP地址，这就是抱歉。

这是发件人的IP地址，这是发件人感兴趣的IP地址，这些大概会放在这里和这里，这是一个回应，呃，这个IP地址所有者的以太网地址和这个，最终在这个领域，如果我们足够聪明，我们可以把这些包拆开。

看到其中的一些领域，我们知道这部分，是以太网头目的地，以太网地址，来源，以太网地址和数据包类型零，八，零，六，向后工作，这是提示字段，这是IP地址，发件人要查找的以太网地址，如果你把这个拆开。

IP地址的四个字段各有一个字节，对不起，它真的在寻找十点到十五分，这是十个黑客，零黑客攻击，两个十六进制，十五个黑客，然后是目标以太网地址，这是不知道的，然后是发件人的IP地址，十点零到两点。

发件人的以太网地址和一堆其他垃圾，说我们对以太网和IP地址格式感兴趣，这是诅咒，这是请求，这就是反应，对我们的，是啊，是啊，问题嗯好吧，为什么发件人有必要包括其IP地址，如果它，如果它的以太网地址已经。

嗯，包括在包里，喜欢回应它，不是吗不是吗，接收者只需要以太网地址，是啊，是啊，我不知道为什么这些东西都在里面，嗯，我想你知道，如果你想，你可以把这个剥下来一点，嗯，你不喜欢这味道，嗯，好的，也许答案是。

该协议被设计成可用于以太网以外的网络，所以它被设计成相当独立的，所以它不依赖于任何东西，不依赖其他任何东西，因此，ARP头现在有一个以太网地址的副本，事实上，如果您知道您正在通过以太网发送ARP。

以太网数据包也有所有的以太网地址，就像你在这里看到的，如果你在以太网上运行ARP，这是多余的，但也许如果你在其他事情上运行ARP，你需要这些字段，因为也许还有别的东西，数据包格式没有，不包括这些地址。

我明白了，好的，谢谢。哦对不起，右边的部分是什么，你在哪里，哦这个，好吧这个，这还不是很有趣，但这是，对这些字节的解释如此之好，这里的点对应于，你知道，见鬼，一个没有ASCII等价物的字节。

我想在这里的某个地方，五十二还是五十五，可能是52可能是5 5可能是你在ascii，所以这会更有趣，当我们开始发送包含实际ASCII文本的数据包时，而不是二元场，好的，我明白了，谢谢。好的。

我给你看这个是因为你会在实验室里看到这些包，好的，嗯。

![](img/946e12e4ef5b70d771615cf3d380c702_1.png)

其实，有件事我想告诉你，呃。

![](img/946e12e4ef5b70d771615cf3d380c702_3.png)

有件事我想确保你们都参与了这次讨论，这就是格式化数据包的习惯，嵌套协议和嵌套头，所以我们刚才看到的是一个数据包，它有一个以太网头，和以太网有效载荷，以太网有效载荷的第一部分是，你知道一个弓箭手。

碰巧的是，我们没有剩余的有效载荷，嗯，但我们一会儿会看到其他的，是复杂得多的结构，其中我们有一个包含IP包的以太网包，IP包里面是一个UDP包，所以你知道，udp是另一个可以在ip上运行的协议。

所以有一个udp头，它也是，你知道你不一定要理解这些首字母缩写，但是有UDP头，UDP数据包还具有报头和有效负载，有时你在UDP中携带另一个协议，例如，域名系统有另一种格式的数据包，找到适合UDP的。

所以你看到的是，发送数据包的um主机将建立一个数据包，DNS软件会说我想通过UDP发送一个数据包，UDP软件将预置UDP头，我们需要通过IP发送，IP软件将被写一个IP头，以太网软件将是一个以太网头。

当它发送时，逐渐在软件中建立数据包，类似地，当系统接收数据包时，它首先得到了整个包，并检查第一个报头，并注意到这个以太网，因为它从以太网接收，你知道的，检查这个标头的一些有效性条带以查看下一个标头。

会有这样一种类型，你们总是一个要么一个类型字段，或者在这种情况下，一个协议字段，它告诉软件在以太网头之后会发生什么，所以有一个类型字段指示IP和ARP，所以软件会查看每个标题，验证一下，把它剥下来。

显示下一个标题，你知道吗，检查那个头或解释它，弄清楚这意味着什么，把它剥下来，揭示下一个，然后把它交给下一层软件，嗯，我会多谈谈这个，但这是一种普遍的方式来看待这些嵌套的，所有的权利，所以以太网数据包。

以太网头，足以将数据包发送到局域网上的主机，嗯，什么时候，尤其是当您想在本地发送IP数据包时，呃，你可以用ARP，但是嗯，IP的使用要普遍得多，IP是，呃，帮助您传递数据包的协议层，在互联网的任何地方。

基于IP地址，这是IP数据包的格式，你可以在net dot h中找到它，我们给你的来源，嗯和以太网，至少你会看到，这是在一个以太网数据包中，目标源和类型为，以太网类型等于零八O O，然后IP头。

当您将数据包发送到遥远的网络时，你知道在世界的另一边，IP头被传递，你知道这个以太网头被剥离了，离开本地以太网后，也许会有一个新的，对于数据包路由的每一跳，但是IP头从终极的整个过程中基本上保持不变。

原始源主机，您知道您的计算机一直到目标主机，所以这个标题具有全局意义，而以太网头实际上只用于每个，对于单个局域网，所以这里必须有足够的信息来携带一个包，一直到互联网的另一边，对于我们的目的来说。

关键字段实际上是这个包格式中三个非常有趣的字段，嗯，目标字段，就是三十个，我们要将包发送到的主机的两位IP地址，尤其是它的高比特，它会有网络号码在里面，这将有助于路由器，然后当数据包交付时。

这个p协议字段将告诉目标主机如何处理数据包，不是在它剥离IP标头后接下来如何处理它，你见过麻省理工学院的IP地址吗，你会看得很清楚的，有几个不同的，但是，比如说，如果你看到它，互联网地址从十八这个开始。

在过去的几年里，事情实际上发生了变化，但这很长一段时间，呃是麻省理工学院的网络号码，因此，大多数托管的mit都有高字节为18的IP地址，世界各地的路由器都会有一些桌子，他们会查到十八岁，然后说，啊哈。

我知道怎么把这个包裹送到麻省理工学院，所以让我，呃，再给大家看一下，TCP转储输出，实际上是从实验室取的，包括，我们可以解析这个数据包，因为它是通过以太网发送的，它从一个以太网头开始。

它实际上不会认为这些tcp有问题，转储，使用生成的这些数据包，现在我看到了，我不知道出了什么问题，他们不应该从所有这些以太网头开始，不应该从所有的FS开始，因为这是导致数据包到达每个主机的广播地址。

对于在两个单独的主机之间发送的数据包，您不会看到这一点，因为这个是在一个真实的网络上，所以有一些有趣的事情发生在我的，网络实验室的解决方案，或者用Q木，无论如何，我们有以太网目的地地址，以太网源地址。

以太网类型和零，八点是，这意味着剩余的字节或IP数据包，嗯，IP包头长度，我想是二十个字节，所以我们终于可以结束到十五了，所以这一定是IP头的结尾，向后工作，因为这些是我们真正关心目的地的领域。

ip字段a是101002，也就是，我觉得In Q的搞笑模拟网络，是真实计算机的地址，我在跑步，然后是IP源地址，也就是十点到十五，哪个是发件人，这是QMU for x v six的地址。

基本上在q亩里面跑，然后这个东西之前是所有其他的东西，有一个16位校验和，你的软件应该检查，意识到数据包已损坏，应该被丢弃，就是这个校验和，有一个字节，我在这里搞砸了一些事情，哦，这是这是十六岁。

对不起，这是十六位校验和，这十一个是协议号码，这是特别重要的，十一十六进制是十六加一或十七，这意味着这是一个基于协议字段的udp数据包，然后所有其他我们并不真正关心的东西，它有像包的长度这样的东西。

关于IP标头的任何问题，同样，关键的是IP头有IP地址，目的地的来源，这个协议字段将告诉目标主机，这个数据包应该由它的UDP软件处理的网络堆栈，我现在就谈谈，好吧这个。

这个IP头足以将数据包发送到Internet上的任何主机，嗯，但我们想做得更好，每一个宿主，正在运行很多很多不同的程序需要使用网络，你需要在网络中发送和接收数据包，所以我们需要一种不在眼睛里的方法。

它不包括在IP字段中，以决定哪种申请，嗯，这需要到目标主机上的哪个应用程序，这个包裹应该交给，有几个协议可以做这项工作，其中之一是tcp，这是相当复杂的，另一个是UDP。

tcp实际上主要用于像Web这样的东西，和，tcp是一个非常复杂的协议，这不仅有助于将数据包发送到正确的应用程序，但也有很多东西，比如序列号，为了检测丢失的数据包并重传它们，确保数据包是按顺序传递的。

没有空隙，万一出了什么问题，udp是一个简单得多的协议，它只是提供了一种最大的努力，向特定应用程序传送数据包，但没有任何纠错或，嗯，基本上没有其他东西给我们，关键字段是这两个端口号，这里的游戏是。

当你的应用程序想要发送接收包时，它使用所谓的套接字API，无论如何在UNIX上，这是一组系统调用，其中进程可以说look，我对发往特定端口的数据包感兴趣，它会说什么端口号，它很感兴趣，对不起，带有特定。

我想收到，具有特定目的端口的数据包，和操作，所以你做一个系统调用，它设置了这个，操作系统将返回一个文件描述符，每次数据包到达应用程序要求的端口时，该数据包将出现在文件描述符上，应用程序可以读取它。

这些端口，实际上有两种端口，有些是众所周知的端口号，就像我认为53号端口是众所周知的官方，dns名称服务器的普遍同意的端口号，因此，如果要向DNS名称服务器发送请求，您可以将其发送到一个UDP数据包中。

地址是驱逐五三，还有许多其他著名的常用服务端口，普遍同意的数字，然后使用16位端口号空间的剩余部分，对于匿名客户端和支持，所以如果我想把数据包发送到DNS服务器，它的驱逐出境将是五次，三个好的。

但对于我来说，它的ORT将是一个或多或少随机选择的数字，这样当那个将与我的应用程序的套接字关联时，以便当DNS服务器发送答复时，会解决的，dns服务器将请求源端口复制到目标端口，答复的字段。

把它送回我的机器，我的机器将使用这个端口号来计算哪个应用程序应该得到答复，好的，所以这里的主要功能是让这两个端口号，为了分发，能够将数据包传递给单个应用程序，在这台机器上，所以请随时提问，我有TCP。

转储输出，UDP也再次从实验室取出，同样，我们有一个以太网头和20个IP头，大概到这里就结束了，十一是IP协议，十七是UDP，这样接收主机就知道用它的UDP软件处理它，是UDP标头。

就在这里所以谁知道这些端口号是什么，我是说，这些都没有，不幸的是，这是一个由实验室软件生成的数据包，没有任何，里面有什么特殊的数字吗，所以这些是碰巧选择的端口号，这一定是包的长度，1b是二十几岁。

这是我的，你知道的，我们的UDP和XPSix软件太蹩脚了，呃，不填写校验和字段，但这是标题，然后在UDP报头之后是UDP数据包的有效负载，在本例中，应用程序发送ASCII文本，ASCII文本就在这里。

所以这是一个面具，我在UDP数据包中的文本位置，放置在IP包中，放置在以太网数据包中，通过模拟以太网发送，哦，好吧，对不起，我只是有个问题，所以当你当你说，当你给某人寄包裹时，你不知道那里，以太网。

我喜欢地址，所以你只是把它发送到你的路由器，然后路由器从那里计算出来，如果嗯，如果对大多数人来说，对于发送到其他地方的数据包，你的主人，如果您将数据包发送到特定的IP地址。

您的主机软件将查看目标地址以确定，如果目标主机与您在同一局域网上，如果是一切，使用ARP将IP地址转换为以太网地址，然后通过以太网将数据包发送到目标主机，所以这就是发生的事情。

在目标主机位于同一网络的特殊情况下，在更一般的情况下，在那里你把数据包发送到全国互联网上的其他地方，您将把数据包发送到同一局域网上的路由器，该路由器将查看目标IP地址以选择下一个路由器。

决定连接哪个路由器，它为包提供，包裹会跳过，跳过路由器，离回答你问题的目标越来越近，好的，我明白了，是呀，非常感谢，有人问一个包的长度是否有限制，答案是肯定的，有几个不同的限制，嗯每个网络。

每一种底层网络技术，如以太网，但还有其他事情就像，以太网有自己的最大数据包长度，所以今天的论文写的时候，以太网上的最大数据包长度是1500字节，我觉得。

现代以太网允许高达9000或10000字节的数据包，但这大概是我听说过的最大数据包大小了，而原因，有几个原因，为什么你不想要无限长的单包，其中之一是数据包是，你知道的，你通过电线发送这些数据包。

电线可能很长，并受到噪音和干扰，所以当你发送数据包时，你确实会得到比特的损坏，基本上每一种网络技术都是某种校验和或纠错码，每包都有，校验和和纠错码只能，可靠地检测一定数量的错误。

所以当你增加比特数的时候，未捕获错误的概率越来越高，因此，这限制了合理的大小，检查16或32位限制数据包的最大大小，另一个限制是，如果你发送巨大的数据包。

这意味着所有涉及的路由器和主机都必须有巨大的数据包缓冲区，准备好收到巨大的包裹，这开始变得笨重和昂贵，很难有可变长度的缓冲区，最方便的是只有一个长度的缓冲区，如果最大数据包长度不太大，这种方法效果最好。

所以对伊森来说，因为以太网有一千五百或，九千字节限制，此外，你知道的，对于所有这些IP协议来说，长度字段都是16位，因此，即使您愿意使用以太网，也要有更大的数据包大小，IP本身有一种最大的烘焙包。

64千字节的大小，UDP到此为止，希望当你完成实验室时，您将看到非常像这样的输出，特别是来自十六的消息一条消息，或者从运行QM U的主机回复，事实上，实际上在实验室的尽头，呃，你要用，嗯，你将运行软件。

我们提供的，它实际上会向谷歌的，DNS服务器并获取响应，我们的软件会打印响应，但你的软件将完成以太网级别的设备驱动程序交互，嗯，这就是线路中的报头和协议的故事，与这些数据包格式相对应的是。

在主机上运行的所谓网络软件栈，所以嗯，如果你想想主机里面有什么，嗯，从现在开始，我谈论的主要是典型的软件安排，人们有各种各样不同的方式来构建网络软件，我和我要讲的有些不同，但我要谈谈。

我认为至少是一种标准的方法，所以你知道，让我们假设我们运行的是linux或者xvsix，嗯，我们有一堆应用程序，也许是网络浏览器，它可能是DNS服务器，谁知道一堆应用程序，嗯。

他们已经使用了套接字API，打开套接字杀戮器中的文件描述符，所以这将是这个，一个叫做套接字层的软件层，记住，具有记住应用程序读取或写入的文件描述符之间的对应关系的表，然后嗯，UDP端口号或TCP端口号。

这是为了，这些文件描述符引用的会话端点的类型，所以套接字层有这些文件表和端口号，它通常也有一个已经到达的数据包队列，并且等待被每个套接字或文件描述符读取，我们提供给你的软件有一个非常原始的插座杀手。

下面会是，嗯，UDP N，UDP几乎什么都没有发生，它基本上查看传入的数据包，提取目标端口号，并将数据包交给插座层，因此有效负载被排在正确的文件描述符上，传入队列tcp实际上要复杂得多。

它为每个TCP连接保持状态，并记住各种序列号和未被确认的数据包，需要重传的，在所谓的协议控制中的大量状态，TCP中的控制块，UDP层几乎没有状态，这些通常被称为传输层，udp和tcp。

我们为您提供一个简单的UDP层，但不是TCP下面的TCP层，IP是一个，通常相当简单，与IP层并行，2。我不知道该不该把它画在同一水平线上，或者在它下面，嗯，他们两个下面的R播放器是吗。

我们可以把它想象成一个以太网层，但它真的，通常没有单独的以太网层，通常有一个或多个尼克司机，在最低层，这些与，呃，实际，网络接口硬件，它本身与本地网络有连接，或者任何类型的网络，嗯，在这个水平上。

发生的事情是，数据包从网络到达，这个缺口，你知道，把它从网络上拉下来，嗯，把它交给司机，驱动程序本质上推动网络，网络堆栈上的数据包，嗯，在堆栈中的每一层，的，你知道，那个图层的头部，你知道。

就像IP层会看IP头一样，验证标头，把它剥下来，把它交给UDP，udp，会找出什么文件描述符，提示数据并将其添加到队列中，所以数据包进来并被解析，头部在向上的路上被剥离，当应用程序发送数据包时。

相反的事情发生在数据包向下移动通过层，越来越多的标题被添加到底层，然后把数据包交给尼克传输，嗯，所以，当然啦，软件--人们思考它和设计网络软件的方式，内核通常是由数据包中的协议嵌套驱动的。

对这个结构有什么问题吗，其实有一件很重要的事我忘在这里了，坐在边上的，有缓冲器，整个过程都有数据包缓冲区，所以当一个包到达时，它被复制到数据包缓冲区中，数据包缓冲区在堆栈中上下发送。

通常有相当多的数据包缓冲区，这些层之间经常排队，这里肯定排起了长队，等待应用程序处理的数据包，这将是一个链表缓冲区，所以有一个缓冲区分配器，这就是这个缓冲方案，和整个堆栈中使用的缓冲区分配器。

在我们给你的软件中，缓冲方案被称为M buffs，所以这是一种m buff，不是层的方案，但在所有这些层都被使用，好的，这是典型网络堆栈的分层图，为本文，了解控制流是如何工作的实际上很重要。

这可能与图表中的有点不同，嗯，关于网络堆栈需要了解的一件事是，通常有多个，处理数据包并接受输入的独立参与者，思考这些数据包并产生输出，由于各种原因，这些不同的行为者是脱钩的，这样它们就可以并发运行。

并有包队列连接它们，所以从本文的角度来看，这是极其重要的，所以在内核中，所以我们又有了一个网络接口卡，然后我们有内核，这里的一个经典安排是让尼克以某种方式得到包，当它接收到数据包以产生中断时。

所以有一个中断，每当有中断时就会被触发，中断程序的工作是从尼克那里得到数据包，和，因为我们不想奉献，CPU现在完成数据包处理的时间，嗯，中断例程通常只是将数据包追加到数据包队列中，供日后处理，然后返回。

所以最小的工作，需要从尼克那里得到包并把它放在队列中，我们想要传输的原因或者在传统的网络堆栈中，我们想快速地把数据包从缺口移到这个软件队列中，尼克斯通常用于排队数据包的内存非常有限，而在主存中。

RAM和计算机，我们可能有千兆字节的内存，所以这里的空间要大得多，所以这个缺口，所以如果有一个包的爆发，缺口实际上可能没有空间来提示他们，所以我们在这里复制这个提示以避免缺口用完空间，然后分别。

也许在一个单独的线程中有，我称之为IP处理线程，有时它不是一根线，有时它是一种不同的实体，但它的基本工作是读取这些传入队列的数据包，可能会有多个刻痕，你知道的，将数据包附加到这些提示。

所以我们的IP线程运行，它查看在这里排队的数据包，并决定如何处理它们，一种可能是通过UDP发送它们，呃，进入套接字层排队等待某个应用程序，通常，这只是在这个线程的上下文中调用的一个函数调用，另一种可能。

而这是该报最关心的可能性，这个主机实际上是一个路由器，它的数据包在一个缺口里进来，然后被路由出去，一个或多个其他刻痕，因为用普通操作系统构建路由器是很常见的，喜欢Linux喜欢。

如果你现在买一个WiFi盒，或者电缆调制解调器路由器什么的，它极有可能在内部运行Linux，并使用标准的Linux堆栈，它有一个完整的路由器实现，它很有可能使用标准的Linux堆栈，为了进行路由。

如果IP线程查看目标，IP地址并决定，哦，我应该把这个发出去，我应该把这个包裹寄出去，你知道另一个网络接口，嗯，它将把数据包添加到传出数据包的队列中，对于此传出接口，几乎可以肯定。

这是接收中断或接收的RX，通常会有某种传输，每当它发送完一个数据包时，尼克就会中断，并准备好被递给更多的包，所以这些传出中断可能也很重要，嗯，这里的重点是有一堆并发实体，嗯。

它们是以各种不同的方式单独安排的，这些中断是由尼克斯队要求中断引发的，数据包到达时或数据包已发送时，这个线程可能是一个内核线程，就像我们在XV中一样，在一个单元处理器上，就像今天的报纸一样，你知道的。

这个线程不能在中断的同时运行，中断多核机器上的绝对优先级，可能会有更多的并行性，然后，如果应用程序能够读取数据包很重要，应用程序是另一种独立调度的实体，呃，我们希望，呃，以获得在CPU上执行的机会。

所以这些都是，在这个调度游戏中本质上，经常提到的一件事是缓冲，所以这里有三个Q通过缓冲，我是说，这些结构中，一个独立的实体追加输入数据包，其他实体将数据包从队列的前面拉出来。

这些线索在网络系统中无处不在，它们的一个原因是允许临时的来应对临时的爆发，你知道的，这个IP线程可能只能处理，不管每秒多少，但尼克也许能更快地运送包裹，所以可能会有一点暂时的数据包爆发。

我们想找个地方放它们，嗯，等待IP线程处理它们，这就是输出端的线索的一种用法，线索的另一个用途是我们想，嗯，尤其是当数据包爆裂时，我们希望能在这里堆叠一堆包，准备好尼克发送，以保持尼克输出尼克忙。

因为取决于事物的速度，能够狩猎可能是相当重要的，利用这里100%的网络，另一个原因可能是同样的原因，对排队有不同的说法，就是能够把软件构造成独立的部分，这些部分是单独安排的。

我们不一定想要我们的IP线程，或者应用程序知道其他必须进行的事情，比如中断处理，所以IP线程是一种传统的网络系统，你知道不一定知道，嗯，当中断发生时或当应用程序运行时，虽然，我们会在这篇论文中看到。

在那里有一点知识可能会有好处，关于这种调度控制图的问题，我有个小问题，所以同一个缺口可以不用吗，呃发送和接收，不能，你为什么，好的，好的，所以我的笔记本电脑只有一个接口它连接到WiFi。

当它收到一个数据包时，在我的笔记本电脑上，这个尼克实际上是一个WiFi无线电接口，数据包在同一个缺口到达和离开，两个缺口的情况当然用于路由器，所以你的家庭WiFi，我不知道。

也许如果我有WiFi和有线电视，有一个路由器盒有两个刻痕，一个是它连接到我的电缆调制解调器，这导致了互联网的其余部分，另一个是我的WiFi界面，所以电缆调制解调器电缆公司寄给我的作为路由器的小盒子。

具有两个网络接口，实际上有很多服务器有多个接口，也是，尤其是那些Web服务器，你知道你想在一个界面上与外界交谈，和您的私人敏感数据库计算机，或者在一个完全独立的网络上的东西，在一个与另一个网络接口上。

所以这种安排很常见，拥有多个尼克斯的标准只是想与不同的网络交谈，然后是的，好的，是啊，是啊，如果你想和不同的网络交谈，那么你就会有很多东西，是呀，所有的权利，我想作为旁白，多说一点，嗯。

当尼克斯队到达时，他们会怎么处理包裹，这与实验室特别相关，嗯，呃你，你，呃，你知道的，虽然，内部的缺口是什么样子的，嗯，你知道的，嗯，你知道的，当电子进入时，它会观察它们，并将它们变成包，然后是宿主。

主机里有某种驱动程序软件，以这样或那样的方式，你知道的，我们需要一个在缺口里解码的数据包进入内存，主机中的IP软件可以解析该数据包，所以这些年来设计了很多不同的方案，纸张方案是缺口有很多内存。

当数据包到达时，唯一一件事，唯一直接发生的事情是尼克把，你知道的，将数据包放置在自己的缓冲区内存中，就这样，打断了主人，宿主，这样缺口就有了包的内部提示，和一堆记忆，然后在主机驱动程序的中断中。

主机驱动程序中有一个循环，主持人司机会和尼克说，你知道有很多数据包缓冲，如果它现在这样做了，主机有一个循环，它只复制，你知道通过字节或一个字一个字，把这个数据包拷贝到，宿主的记忆并将其附加到提示，呃。

在宿主内部，报纸的缺口就是这样工作的，驱动程序负责从Nick内存复制到主机内存，这在三十年前的今天很有意义，尽管事实证明CPU中的循环复制，嗯，你知道的，与外部硬件或硬件交谈，坐在公共汽车上非常非常慢。

这是一种，有一个，你知道，在微处理器设计的宏伟计划中，CPU和外部设备之间的距离，即使是在同一台电脑上，这是一段很长的距离，今天的每一次谈话都要花很长时间来来回回地聊天，所以你不想有很多咬一口的互动。

所以人们不再设计这样的高速接口了，嗯，进入一个更现代的安排看起来像这样，所以现在我要谈谈一个安排，它出现在E 1000尼克，你将在实验室或模拟中使用，一千个缺口的工作方式，所以它有它的电线，它在看电子。

但当包裹到达时，尼克写的，这并没有重要的内部缓冲，虽然它有一点点，它实际上将数据包直接复制到主机内存中，他们将坐在主人记忆中的地方，等司机来接他们，有点已经复制了。

但这意味着尼克必须知道每个数据包在内存中的位置，所以你一千个数控的工作方式是主机软件格式化，所谓的环，分组指针的dma环，所以DNA环只是一个数组，到数据包缓冲区，所以主机主机驱动程序。

当它在卡中初始化时，将分配，然而许多人说，161500字节数据包缓冲区，将创建一个由15个指针或16个指针组成的数组，并使这些指针指向那里，然后它会告诉尼克在配置时间看，这是戒指，所以这叫做DMA环。

因为呃，在你离开尽头之后，你从头开始，司机的软件会告诉下一个外观，这里是，这里有一个指针，戒指在我公羊上的地址，你应该用来存放传入数据包的DMA环，所以当一个包到达时，镍实际上记得，嗯，哪个环是下一个。

嗯，它有一个小指针可以让你记住下一个条目，它应该把一个包放入，当一个包到达时，缺口会把指针从这个里面拿出来，从主机RAM中获取此缓冲区指针，将数据包字节复制到此缓冲区。

然后在这里推进它的内部索引指向下一个环槽，我们将用于下一个包，还有一个类似的，所以这将是接收的RX环，司机设置了一个类似的环，其中驱动程序放入它希望缺口结束的数据包，所以尼克也有一个指向TX环的指针。

所以你会学到，你在实验室的工作基本上是编写处理这些环的驱动软件，对这项安排有什么问题吗？是啊，是啊，呃，E一千与，你知道的，可用于高性能环境的生产级组合，如Well，当一千出来的时候。

这绝对是最好的尼克，它是在严肃的生产环境中使用的尼克，但那是，然而多年前现代尼克斯队，嗯是相当聪明的一点，没有太大变化的东西，这个DMA环结构是，你还是会发现刻痕，他们使用DMA来传递数据包。

以及他们找到递送包裹的地方的方式，是通过这些缓冲区指针环，主要是有几件事，现代尼克斯队更聪明，现代刻痕，你可以用很多很多的线索来设置它们，米一千，我想只有一个接收队列，但你可以看出一个现代尼克的样子。

你知道的，我要你把我的包裹分成32个不同的传入队列，以下是如何决定每个包，您必须查看这个字段，并使用它来选择DMA的哪个环，将数据包放入，人们有一大堆聪明的方法来使用这种能力，比如如果您有多个虚拟机。

你是亚马逊，你正在运行许多来宾虚拟机，您可以使用该功能将每个数据包引导到提示，对应于应该读取该数据包的虚拟机，现代尼克斯队更聪明的另一个方面，他们会在脖子上做一些TCP处理，就像通常检查一些计算，最。

现代耐克，或者像一千个，但更多，谢谢，对不起，去吧，哦耶，我只想问，所以在我们实验室的方案中，IP层和驱动程序之间没有队列，对呀，是啊，是啊，是啊，是啊，实验室网络堆栈被剥离到绝对最小的更简单的讲师。

比真正的网络堆栈，但就性能而言，这更糟，哦，我不知道在现实生活中谁会说话而从不运行它，我确定我是说，在编写实验室网络堆栈时，他们肯定没有注意到性能，所以把好的表现拿出来会很令人惊讶，但大多数情况下。

这是毫无疑问的，性能，有限制，这不行，你需要一个网络堆栈来做的95%，处理多个刻痕有tcp权利，对呀，好的，我明白了，谢谢。对不起，呃，所以呃，有没有类似硬件的变化，就像整个系统一样，需要使。

就像尼克斯队有直接的内存访问，就像上一张图片一样，所有的东西都是通过CPU或CAN刻痕进行中介的，也喜欢直接在画面中到达记忆，我以前显示过脖子在记忆中根本够不着好吧，我其实不知道。

我是说也许最重要的问题是虚拟内存是如何，虚拟内存转换是否以及如何工作，当尼克想要使用引用主机内存的地址时，我真的不知道这是怎么回事，我不知道那是怎么回事，我怀疑有翻译，你知道尼克真的坐在一辆公共汽车上。

这辆公共汽车与，你知道通过一些相当智能的硅到DRAM系统，我相信在现代机器中，你可以设置翻译表，这样尼克就可以使用虚拟地址或地址，由位于它和运行之间的硬件转换，这在某些情况下是非常有价值的。

另一件事我是说，我意识到的另一件事是，如果尼克要写一些记忆，或者读一些记忆，内存缓存在CPU上，你，你知道你想让尼克读，如果如果如果软件只是，你知道写了一个数据包缓冲区，但是CPU没有。

CPU只是缓存在右边，因为毕竟呃，大部分记忆都回来了，嗯，这意味着该内存的真正最新版本位于CPU缓存中，不是在公羊里，在这种情况下，我们希望尼克读取CPU缓存，不是咆哮，如果有DMA。

当然在英特尔的机器上，可能也在别人身上，有一些相当精细的机器，这样如果缺口读取了一些记忆，但该内存的最新副本在CPU缓存中，这个，是CPU缓存将产生数据，而不是公羊，这很有趣，是啊，是啊。

那实际上是一个你可以，这是一些聪明的软件用来获得高性能，这是为了产生这样的效果，此外，尼克基本上将直接在缓存中写入缓存行，CPU可以非常快地获取数据，是啊，是啊，如此简单，但现实生活，这很复杂。

我现在想转换话题看今天的报纸，嗯，我只想，因为我们已经讨论过了，这篇论文的很多背景，我就直接去看报纸上的第一张图，本质上是为了把讨论从论文的图表中移开，所以我们在这里看到的是路由器的性能图，嗯。

在x轴上，有一条有两个刻痕的路线，他们的工作是把它们装在一个缺口里，它应该只是把他们送出另一个尼克，嗯，x轴是数据包到达输入缺口的到达率，y轴是输出速率，在其中观察到数据包离开输出颈，我们关心的线是。

填充的圆圈，它上升然后下降所以即使不知道这里发生了什么，我们可以看看这个图，我们可以问自己，哎呦哎呦，怎么就上去了，为什么会往下走，你知道，这一点有什么特别之处，那是一种屈折变化，是什么支配着。

它上升的速度有多快，或者它下降的速度有多快，所以即使没有知识，我们对该问什么问题有很好的线索，那么它为什么会上升呢，做这些任务，到处走，这不是一个很深的问题，他们上去了，对不起，去吧，哦，因为当他们像。

直到它饱和，您可以处理更多的输入包，生产更多的alpha包，绝对喜欢，直到事情开始出错，嗯，面糊里的每一个包都把它转发出去，所以你知道，直到事情出错，如果数据包以每秒2000个的速度到达。

它只是将每个输入数据包复制到输出，这意味着输出速率正好等于输入速率，所以这只是y=x，你知道的，因为每个输入数据包都被发送出去，所以有一段时间y等于x，那么为什么它停止上升。

这不是他们在报纸上提到的一件事吗，呃，他们被打断了，不能以必要的速度处理，这就是问题的答案，为什么会往下走，我的问题是，怎么就不往上走了，在一个精心设计的系统中，这条线是什么。

假如他们没有把设计弄糟的话，对呀，你和我会设计一个没有问题的系统，对呀，在我们的系统中，这条线会一直往上走吗，嗯，我想不是，因为在某个时候，数据包来的速度会，如果你能足够快地处理数据包，那么在某一点上。

瓶颈将是数据包到达的速率，这是正确的，我们所说的系统有一些限制，它不是，CPU不是无限快，CPU执行，然而，每秒有许多指令，不再如此，这些数据包中的每一个都必须处理，IP软件必须查看标题并检查。

并查找目标地址和表格，不惜一切代价，每个数据包数十万个CPU周期，所以我们永远不能指望这些线无限期地上升，他们一定会在什么地方停下来，我们可以知道我们可以在这个系统上做一些猜测，到了五千，再也没有了。

这基本上向我们暗示了什么，在这台电脑上大约需要200微秒，处理每个数据包，对呀，这就是这一点，拐点在这里的事实，意味着，暗示着，处理数据包的总成本，大约是200微秒的CPU时间，是啊，是啊，那是。

只是猜测，但很可能接近正确，所以我们不可能得到，你知道吗，也许我们可以让软件更有效率一点，也许我们可以把它减少到每包150微秒，什么的，所以也许我们可以把拐点抬高一点，但我们肯定面临着某个时候。

这是系统可以处理的数据包的数量，这不一定是这里发生的事情，好吧，这碰巧是这里发生的事情，但它没有，这不是一成不变的，事实上，还有其他瓶颈可能是极限，CPU时间以外，值得考虑的。

最明显的是网络的速度他们使用的网络，以每秒10兆比特的速度运行，这就是所有网络硬件发送比特的速度，所以它不能每秒传输超过一万个比特，嗯，所以这也可能构成一个限制，所以我们在想。

也许这就是决定这5000英镑的原因，我不知道，这份报纸没有说得足够多，无法知道是否，关键是它是CPU还是NIC，这里的限制因素，但事实是他们的十兆网络，如果你发送小包，它能把十兆转换成什么。

每秒一万到一万五千个数据包，这就是网线对输入速率的限制，所以这很好，低于网络每秒一万或一万五千个数据包的能力，所以几乎可以肯定的是，限制与CPU或内存或其他东西有关，而不是。

我们喜欢在设计良好的路由器中看到的是，它实际上可以，你知道的，如果转发一个数据包需要200微秒，处理我们想看到的包，路由器实际上可以每秒转发5000个数据包，无论发生什么，即使负荷很高。

所以我们想看到的是这条线，其中输出速率与输入速率匹配，直到达到系统的容量，你知道的，每秒五千包，然后它继续每秒转发5000个数据包，然后大概下降，丢弃物，剩下的，所以这是我们喜欢设计的。

但实际发生的事情比那糟糕得多，当你把利率提高到五千以上时，它设法转发的数据包数量下降到零，那么为什么这条线，我想以前有人提到过这件事，好吧呃，作者发现的原因是，随着输入率的增加。

这些输入数据包中的每一个都产生一个中断，中断实际上在他们的系统上需要时间，中断是相当昂贵的，因为它们涉及到从网络接口卡和域内存中复制数据包，这花了很长时间，因为CPU正在这样做，所以每个，所以你知道。

我们知道，如果数据包以每秒一万的速度到达，我们当然不能转寄一万，嗯，这意味着我们所能希望的最好结果是转发5000，然后简单地扔掉剩下的五千，但事实上，每个额外的5000个数据包产生了一个非常昂贵的中断。

所以每增加一个数据包每秒超过5000个，我们正在产生越来越昂贵的中断，像中断一样有优先级，男孩，无论你在做什么，它都停止了，机器接受中断，因为机器本质上是优先考虑，这些中断，就是说。

每秒每增加一个数据包都会占用转发代码的CPU时间，直到，终于，100%的CPU时间被用在输入中断例程中，线程中不使用CPU时间，这个下去，嗯，事实上，这条线是向下的，而不是说转向旗。

人们所说的中断活锁是什么意思，它实际上是一种发生在许多系统中的现象，我是说那种驱使，就是有两个独立的任务，比如输入中断任务和转发任务，因为调度问题，本质上优先考虑输入任务，会饿死，包处理任务。

在几乎任何有多个独立任务的系统中，或者一系列独立的任务，需要对每个输入进行，输入速率不一定能控制，如果你把它们推得太紧，许多这样的系统都会出现活锁，您可以获得带电锁定由于许多资源，不仅仅是CPU。

但可能是NIC，你知道的，DAS用完公羊循环来做DAS的尼克，如果缺口用的是公羊，CPU不能使用RAM，所以另一种获得Lioeven的方法，如果你有很多CPU时间，你知道的，在其他设计中。

你可能会被活锁，因为缺口快用完了，RAM资源，RAM性能资源，所以CPU无论如何都不能使用RAM，这条线向下就是他们所说的带电块，你可能会问多余的包会怎么样，如果你回忆起他们软件的结构，他们有一个缺口。

基本上是为了接收中断，接收到的中断软件将每个数据包复制到队列中，然后有某种网络线程，从队列中提取数据包，数据包丢失的确切地点就在这里，将要发生的是中断例程，你知道吗，一旦我们带着严重的活锁下来。

中断例程将填满这个队列，这里会有一些最大队列长度，你知道吗，至少整个公羊，但可能少得多，中断例程会从脖子上拉下一个包，看这个球杆已经是允许的长度了，中断例程将丢弃数据包，但后来，当然啦。

紧接着会有另一个中断，例程将再次丢弃下一个包，因为网络线程总是被中断，永远不允许运行，关于这个图表的一个问题，论文中最重要的图表，所有的权利，嗯，嗯，基本上没有时间了，2。

我将设法把问题的答案压缩到一分钟内，嗯，作者提出了一个解决方案，关于解决方案最直接的好消息是，这是他们解决方案的性能，即随着输入速率的上升，因为多达五千，然后它持平于五千，无论输入速率如何。

所以这是一个完美的非活锁性能线，当然啦，因为我们每秒只能处理5000个数据包，由于CPU的速度，他们得到这个的方式，他们还有这个网络线程，他们还有一个中断小组，所以当尼克第一次打断，它会运行中断例程。

但是中断例程不复制，巴基斯坦尼克，它唤醒网络线程，然后在缺口上留下中断，这样我们就不会再被打扰了，唤醒网络线程，然后中断例程将返回，所以现在打断了，蛇被关掉了，网络的读取基本上有一个循环，它会检查缺口。

你知道，拉几包，从脖子，五个，我觉得，是他们最终用的，然后处理这些数据包，然后如果没有，如果这个，呃，它会检查，那么现在是这个网络线程从颈部读取数据包，不是中断例程，如果没有包在等着，它启用中断。

然后就睡着了，因为它启用了，下次数据包到达时会中断，蛋白质会唤醒这条线，它会从睡眠中出来，回到循环的顶部，这是他们解决方案的结构，和一种查看方式，这就是他们把中断方案变成轮询方案，在高负荷下。

他们只是坐在这个循环中，他们读取包过程，它读取中断关闭的包进程，所以他们做了，因为那些中断被关闭了，他们永远不会得到这种效果，因为他们中断了从主线程中窃取时间，而在低负载下，它们可能会中断一段时间。

直到数据包到达，但他们会立即被中断程序吵醒，如果有包裹到达，这就是我要说的，有什么问题吗？我有个问题，嗯，那个循环是在查看所有的设备吗，或者只有生成Interru的那个，这是个好问题，如果有多个刻痕。

循环，我真的不知道他们是怎么，循环是如何工作的，一个非常合理的设计是为了这个网络线程，跟踪每一个缺口，不管是中断模式还是轮询模式，然后它实际上只会，因为中断例程不再是来自尼克的副本。

这意味着循环可能会在这一点上检查每个接口，每个价格都会在这一点上检查每一个缺口，并在每一个缺口上停车，如果它有几包包，如果那个尼克有包裹在等着，循环会从脖子上拉出一些并处理它们，然后如果尼克斯队都没有。

如果它检查了所有的尼克斯，没有一个有任何包等待，循环将在所有的尼克斯和睡眠上启用中断，任何打断的尼克都会把它吵醒，我有个小问题，那么如何在循环运行时这样做呢，数据包实际上是如何进入要拉的线索的。

我觉得一次只有一个，然后这个循环，你知道当它回到循环的顶部时，它会查看每一个缺口，实际上和尼克·硬件谈谈，问它，您的内存中是否有任何输入数据包等待，如果是这样，那么这个循环就会，你知道的。

在RAM中分配数据包缓冲区，将数据包的字节从缺口中复制出来，分组缓冲区，然后处理该分组缓冲区，所以我可以复制多个包，是啊，是啊，我想他们可以五人一组，为了，即使有一百个包裹在这里等着。

它只会处理接下来的五个，以便在输入刻痕中公平，为了避免产量不足，但这需要增加缺口的内存容量，对呀，可能是，我不知道，我不知道尼克可能有多少合理的数量，问题是这个中断，你知道的，这种活锁现象。

就像这个点下面，我们可能打扰到你们了，如果一个包到达，网络线程几乎会立即被唤醒并将数据包拉出，我们在这个地区有太多的包裹到达，这个循环正在轮询，而不是中断数据包将丢失，我们只是知道，因为区别。

ID之间的差异，输入速率和输出速率，这都是掉落的数据包是的，是的还有，我不认为添加，因为这些数据包无论如何都会被丢弃，在颈部添加缓冲可能没有太大帮助，我不知道，我想是个缺口。

尚不清楚尼克需要的不仅仅是少量的缓冲，是啊，是啊，这是有道理的，是啊，是啊，你只需要它饱和所需的量，所以你知道，我想在他们的设计中他们会拉五包配额是五包，所以下一个肯定需要五包缓冲，为了让这有意义。

但它可能，不清楚比这更多是否会有很大的好处，缓冲的目的是吸收瞬态爆发，所以保持数据包足够长的时间，软件就可以读取它，但在这种情况下，我们不是在谈论短暂的任何事情，我们说的是持续超载。

所以这意味着没有太多的功能，对于大量的缓冲是有意义的，谢谢。嗯，我想我的问题与此有关，它是如此，如果中断之间的差异，就这里而言，它将是一样的，但就像它，它仍然会把东西放在队列上，如果它能。

但它不会发出中断，但如果队列中没有位置，然后它就会放弃中断，中断例程，这个新方案从不查看数据包，哦是的，明白我的意思，就像，呃，2。你说过你可以暂时停止工作，对呀，是啊，是啊。

这就是中断处理程序中发生的事情，它是禁用的吗，打断了这个缺口，然后唤醒网络线程，这就是它的作用，它就会回来，我想我的问题是当中断被禁用时，尼克还能把数据包放在自己的缓冲区上吗，是呀，脖子是自给自足的。

所以它有内部缓冲，不管是不是，无论中断是启用还是禁用，当一个包到达时发生的唯一事情，就是那个缺口，将数据包追加到其自身内存中的数据包队列中，当一个包到达时，就会发生这种情况，所以它从来没有。

这张报纸上的缺口网，我是说，不同的尼克设计非常不同，但为了这篇论文，他们的脖子从来没有DNA，它从未触及主人的记忆，好的，只是在自己的记忆中保留了一个内部提示，主机可以读出数据包，如果它想，好的。

我明白了，如果没有记忆，然后在这个设计中下降，如果数据包是这些多余的数据包，他们被扔下的地方是在缺口里面，会发生什么，是一个包，就会，你知道，如果我们在超载的情况下，那么下一个队列就满了。

所有的重量几乎总是，所以当一个包到达时，下一个队列通常已满，它就会掉下来，这个缺口，将在主机上不浪费任何CPU时间的情况下丢弃数据包，好的，是啊，是啊，好的，是啊，是啊，它可以掉下来而不燃烧的事实。

这里的CPU时间是解释他们如何避免Livelock的一种方式，对呀，对呀，好的，非常感谢，我有个小问题，呃，会不会有这样的场景，CPU循环会拉几个数据包，但是像内部的软件提示都像满的，哦当然，是啊。

是啊，还有一些其他的瓶颈，所以说，比如说，假设这些传入的数据包，其中一些需要传递到套接字上的某个应用程序，如果应用程序读取数据包的速度不够快，那么嗯，导致的套接字缓冲区，你知道应用程序应该读的会满的。

然后数据包可能被丢弃在网络线程中，这也可以导致生存，因为现在因为我们有同样的，你知道的，Livelock出现的原因是我们花费了资源，处理后来被丢弃的数据包，所以是白费力气，如果应用程序不读取，很好。

我们可以得到它的一种方法，活锁是随着负载的增加，也许我们最终会花100%的时间在网络线程上，将零%的时间留给任何应该读取数据包的应用程序，然后我们会再次得到Livelock，但不会被打断，活锁。

它将是网络处理，活锁什么的，报纸上有一篇报道，在第六区的某个地方，他们谈论网络，如果数据包被传递到本地应用程序，网络线程将查看该应用程序的套接字队列，如果时间变长，它会关闭中断，它会关闭中断。

并停止从网络接口上提取数据包，直到队列变短，这意味着网络线程将停止运行，并给应用程序一个运行和处理数据包的机会，所以你可以在任何阶段得到像OCK这样的情况，如果你在这种多阶段处理方案中不小心，好的。

那是有道理的，谢谢。谢谢。