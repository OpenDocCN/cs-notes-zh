# 讲座 7 - 创建，调度

### 公共服务公告

1.  作业 1 的截止日期

1.  合作伙伴

* * *

### 软件中断后

##### 在内核中

顺序很重要，除了最后两个

1.  保存用户状态

1.  获取请求

1.  检索内核状态

在这个列表中几乎每件事都有多种方法可以做，我选择描述这样做的方式是因为它最简单，而不一定是最好的！。

此时内核已准备处理请求。

* * *

### 处理请求

##### 需要做什么

1.  检查错误

1.  操作 TDs

1.  有时，将字节从一个地址空间复制到另一个地址空间。

##### 保存返回值

提出请求的任务可能不是下一个要运行的任务。

+   内核需要保存请求的返回值，直到下次请求者被调度。

+   一个解决方案是将其放在 TD 中。

+   也可以立即将其放在需要的地方（如 r0）。

* * *

### 调度

调度有两个重要问题

1.  何时重新调度？

1.  我们调度时激活谁

#### 何时调度

每次我们在内核中时，问题是`我们何时进入内核？'

##### 三种可能性

1.  任务运行到完成，这意味着直到它们请求内核服务

1.  事件驱动的抢占，这意味着当硬件请求服务时

1.  时间片切片

    +   仅当切片计时器超时时才重新调度

    +   时间片切片的两个问题

        1.  切片太大=>响应不佳

        1.  切片太小=>内核运行太多=响应不佳

    +   什么定义了`太大'和`太小'？

        1.  期望的响应时间

        1.  硬件请求的频率

        两者差异很大

我们做 1 和 2，但不做 3，因为我们的任务是合作的。当任务对抗时需要时间片切片。

### 谁来调度

为了满足所有截止日期而需要的人

+   或者优化某些东西。

因为这不是一个简单的问题，我们不希望在内核内解决它。内核所做的应该是快速的（=常数时间），而且不受资源限制。

##### 以廉价（=常数时间）的方式进行调度

先最便宜

1.  活动任务决定=协程

1.  轮转

    +   每个人都有同样的机会

    +   但通常长时间运行=不重要

1.  优先级

    1.  在编译时固定

    1.  任务创建时固定

    1.  每次任务被调度时都会重新固定

        +   你有一个好的算法吗？

优先级的数量应该小，但不要太小。

相同优先级的任务应具有相同的优先级。

调度算法

1.  找到最高优先级的非空就绪队列。

1.  调度队列中的第一个任务。

    最近调度（运行）任务的状态是活动的，而不是就绪的。

    内核维护对活动任务的 TD 的指针，以便知道哪个任务正在发出当前请求。

1.  当任务准备就绪时，将其放在其就绪队列的末尾。

##### 实现

就绪队列的数组，每个优先级一个。

每个就绪队列都是一个带有头指针（用于提取）和尾指针（用于插入）的列表。

提示。《计算机编程艺术》（Donald Knuth）说循环队列更好。为什么？

##### 实现决策

1.  有多少个优先级

1.  哪个任务应该有哪个优先级

1.  当没有准备好的任务时该怎么办

##### 典型运行系统的队列

1.  最高优先级：

    +   等待中断的任务

    +   几乎总是被阻塞

    +   进行最少的处理，然后释放被阻塞在它们上面的任务

1.  中等优先级

    +   接收被阻塞的任务

    +   几乎总是被阻塞

    +   为应用任务提供服务

1.  低优先级

    +   发送阻塞任务

    +   大多数情况下被阻塞

    +   做出关于接下来应该做什么的决定

1.  最低优先级

    +   一个无需阻塞即可运行的任务

    +   空闲任务

    +   使用电源而不做任何事情

* * *

### 在软件中断之前

过了一会儿就该离开内核了

1.  安排下一个要运行的任务

    +   即获取`active`的值

1.  调用`GetNextRequest( active )`

在 GetNextRequest 内

1.  从 TD 或用户栈

    +   获取 sp_usr

    +   设置 spsr_svc = cpsr_usr

        +   你应该理解这如何将我们带回用户模式。

    +   设置 lr_svc = pc 以返回到用户模式

1.  在内核堆栈上保存内核状态

    +   结合以上 6 点，这应该是一个 NOP

1.  通过覆盖用户栈上的 r0 设置返回值

1.  切换到系统模式

1.  从用户栈加载寄存器

    +   结合以上 3 点，这应该是一个 NOP

1.  返回到监督者模式

1.  让它走

    ```
    movs   pc, lr
    ```

这条指令之后通常是内核入口。

* * *

### 制作包装 swi 的存根

对于每个内核原语，用户代码中必须有一个可用的函数：内核的 API。

+   例如 `int Create( int priority, void ( *code ) ( ) );`

##### gcc 为你做了什么

调用 Create 之前

1.  gcc 将临时寄存器保存到内存中。

1.  gcc 将参数放入临时寄存器，可能也放在堆栈上。

在调用 Create 时

1.  `bl`到 Create 的入口点

在执行 Create 时

1.  gcc 保存**它认为**在函数执行期间将被更改的寄存器到内存中。

    +   gcc 认为错了，因为只有汇编器知道 swi 在指令流中

1.  你的代码被执行

1.  gcc 恢复它保存的寄存器，仅恢复那些寄存器。

退出 Create

1.  执行 mov pc, lr，或等效的操作，将执行返回到 bl 后的指令

调用 Create 后

1.  gcc 将寄存器 r0，即返回值，存储在 Create 的结果分配给的变量中。

##### 你编写的代码做了什么

1.  将参数从 gcc 的位���移动到你为内核选择的任何约定

1.  执行 swi n，其中 n 是 Create 的代码。

1.  将返回值从你内核的常规位置移动到 r0。

* * *

## 创建一个任务

创建任务时你必须做两件事

1.  获取并初始化任务所需的资源

    +   TD

    +   内存

1.  使任务看起来好像刚进入内核

    +   当被调度时，它准备好执行

##### 你需要做的事情

获取一个未使用的 TD 和其堆栈的内存

+   内存可能在初始化期间与 TD 关联

+   实际上是一种常数时间内存分配形式

+   除非你实现 Destroy

大部分是在 TD 中填写字段。

1.  任务 ID

1.  栈指针

1.  SPSR

1.  链接寄存器

1.  父 Tid

    +   活跃任务

1.  返回值

    +   虚拟

    +   对于活跃任务，其返回值不同，会进入其 TD

1.  状态

    +   就绪

1.  安装在就绪队列中

    +   TD 中的指针

还必须初始化栈

+   就像任务刚刚执行内核入口一样。

+   仔细查看你的内核退出代码会做什么

+   最后栈指针必须对应栈内容

+   我将栈指针初始化为分配内存的顶部

    +   我的栈向下增长

    然后当我将东西推到栈上时改变它

    +   模拟上下文切换代码

* * *

### 创建函数

你还需要一个 `int Create( int priority, void (*code) ( ) )` 函数供用户任务调用。

尽管它不过是一个包装器，但有一些问题需要解决。

1.  传递参数

    +   进入时参数在某处，通常是 r0 和 r1

    +   你必须把它们放在内核能找到的地方。

    +   gcc 的函数入口代码立即将它们放在堆栈上。

    +   在汇编中，你可以使用帧指针找到它们。

1.  进入内核

1.  从内核获取返回值并返回它。

    +   你会在内核放置它的地方找到它

    +   gcc 的函数退出代码期望它是基于帧指针的索引

        +   从这里进入 r0

* * *

### 其他原语

这些原语主要是为了确保任务创建和调度在没有太多其他实现时能够正常工作，我们，包括你在内。

##### `Tid MyTid( )`

自解释

+   不阻塞，但会重新调度。

一个问题，有一个正确答案，或者更具体地说，一个正确的（答案，原因）对。

+   Tid 应该存储在用户空间吗？

##### `Tid MyParentTid( )`

自解释

+   不阻塞，但会重新调度。

父 Tid 在哪里，内核如何找到它？

##### `void Pass( )`

不阻塞：调用 `Pass( )` 的任务仍然准备好执行。

重新调度。

何时 `Pass( )` 是一个 `NOP`？

##### `void Exit( )`

调用任务从所有队列中移除，但其资源不会被回收或重用。

也就是说，任务进入僵尸状态，在这种状态下，它既不能活跃也不能就绪，但仍然拥有所有资源。

### 执行应该如何终止？

很好。

当就绪队列中没有任务时，它会返回到 RedBoot。

+   当硬件中断实现时，这种行为会发生变化。

* * *

返回至：

+   Bill Cowan 的 CS452 s12 讲座笔记

+   Bill Cowan 的 2012 年春季 CS452 页面

+   Bill Cowan 的 CS452 页面

+   Bill Cowan 的教学页面

+   Bill Cowan 的主页
