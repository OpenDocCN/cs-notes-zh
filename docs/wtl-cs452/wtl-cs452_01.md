# 讲座 1 - 介绍

### 公共服务公告

1.  作业 0/1 的截止日期

1.  结合火车实验室

1.  Ubuntu 10.10

1.  如何编译和运行您的第一个程序

* * *

### 实际细节：pdf

* * *

### 嵌入式系统

大部分在内部表示和现实世界之间的中介是由嵌入式系统完成的

+   隐形计算

+   感知和控制

+   数十亿个

### 开发模型

两个盒子模型

+   在一个盒子上进行开发

+   在不同的盒子上执行。

发展周期

+   在一个盒子上编辑和编译

+   下载到第二个盒子

+   执行

问题一

+   拥有硬件本身的原始代码

+   硬件特定的库提供对硬件的访问

    +   微控制器/漏斗示例

问题二

+   操作系统类似的硬件抽象

+   看起来像一堆库，再加一点点。

* * *

### 什么是实时编程？

实际上是现实世界的编程，这意味着

+   世界是用秒、米等来衡量的。

+   程序操作位、字节、字，必须转换为实际世界的度量。

    例如，

    +   格式化输出：将计算机操作的 int 转换为人类可读的十进制

        +   公开的：i2a（），printf（）

        +   隐藏的：print，cout

    +   银行业：int 转化为，例如，美分数

        +   程序说 dispense（10000），意思是“将五个二十元放入漏斗中”。

        +   微控制器启动

            +   激活电机

            +   感知力量

            +   读取数字化视频

            +   等等。

    +   列车控制：消息内容映射到改变速度、转向开关、传感器触发

### 实时编程的重要性是什么？

1.  吞吐量

    +   例如，游戏中的每秒帧数

    +   例如，过程控制中传感器采样的频率

    +   除了没有解决方案

        1.  获得更好的硬件

        1.  获得更好的算法

        1.  重新组织任务

1.  响应时间

    +   例如，从按下按钮到游戏中开枪射击的时间

    +   例如，从传感器读取到过程控制中的控制代码执行的时间

    +   存在几种编程技术

        1.  忙等待

        1.  轮询循环

        灵活性和性能之间的张力

在 cs452 中，我们将有保证的响应时间作为实时计算的定义质量。

* * *

### 串行输入/输出

使用称为 UART 的设备，

+   实际上只是两个移位寄存器

+   每个之前都有一个字节缓冲区

+   每个控制寄存器中加一个位。它们的含义是

    +   读取：有一个字节您尚未读取

    +   write：缓冲区为空，您可以写入

* * *

### 忙等待

这用于与外部事件同步，最大程度地减少响应时间。

```
#define FOREVER for( ; ; )
FOREVER {
   while( !ready( ) ) ;
   do-it( );
}
```

或以另一种形式

```
FOREVER {
   if ( ready( ) ) do-it( );
}
```

有时您只想做一次事情，就像在串行线上放置字符时一样。

```
#define UART1_BASE        0x808c0000
#define UART_DATA_OFFSET        0x00    // low 8 bits
#define UART_FLAG_OFFSET        0x18    // low 8 bits
#define TXFF_MASK               0x20    // Transmit buffer full

        flags = (int *)( UART1_BASE + UART_FLAG_OFFSET );
        data = (int *)( UART1_BASE + UART_DATA_OFFSET );
        while( ( *flags & TXFF_MASK ) ) ;
        *data = c;
```

##### 最坏情况下的响应时间

从准备好的位设置开始到执行 do-it 的第一条指令的时间

+   执行时间为

    ```
    while( !ready ) ;
    do-it;
    ```

+   即使是中度优化的编译器也会生成良好的机器代码。像这样的东西

    ```
    ready:
      ldb  r0, STATUS-ADDRESS
      and  r0, r0, READY-BIT
      beq  _ready
    do-it:
      ldb r0, DATA-ADDRESS

    ```

    这里的 do-it 是在接口硬件指示数据寄存器中有有效数据可用时从接口硬件中获取一个字节。

+   最坏情况下的响应时间是执行`and`、`beq`、`ldb`、`and`和`beq`

+   通常这样的代码会在循环内部，逐个获取字节，直到没有更多可用为止。

##### 忙等待的问题

如果 CPU 必须同时做两件事会怎样？

例如，

1.  收集串口传入的字节

1.  维护一个时钟

除非字节传入速率和时钟滴答速率相同

你肯定会迟早丢失一些东西。

* * *

返回至：

+   比尔·考文 2012 年春季 CS452 课堂笔记

+   比尔·考文的 2012 年春季 CS452 页面

+   比尔·考文的 CS452 页面

+   比尔·考文的教学页面

+   比尔·考文的主页
