# 第 28 讲 - 演示，预订

### 公共服务公告

1.  期末考试日期：8 月 7 日上午 9 点至 8 月 9 日上午 11 点 30 分

* * *

## 病理

随着我们逐渐深入这个列表，病理检测和编辑-编译-测试周期的长度会无限增长。

### 1. 死锁

一个或多个任务将永远不会再次运行。例如

1.  任务发送给自己（本地：系统的其余部分继续运行，任务本身永远不会运行）

1.  每个任务都执行 Receive()（全局：没有任何任务在运行）

1.  任务在循环中发送（本地：其他任务继续运行）

内核可以检测到这些问题

+   它是做什么的？

潜在死锁可以在编译时检测到

+   所有可能发生的发送图中的循环

    +   记住隐式发送

+   不一定发生在运行时

    +   也就是说，这是一个必要但不充分的条件。

+   更糟糕的是，

    +   当测试很短的时候不会发生

    +   当测试运行时间较长时，它出现在最后

    +   关键竞争中的变化可能导致潜在死锁显现出来。

##### 解决方案

+   门控

    +   最常见的例子是初始化，其中发送/接收模式可能与 FOREVER 不同

    +   门控初始化结束

+   定义四种任务类型

    +   管理员（A），包括各种服务器：只接收

    +   工作者（W），包括通知者：只发送

    +   客户端（C）：只发送

    +   通知者（N）：只发送给其管理员

    +   两个 A 任务不能直接通信；两个 W/C 任务也不能直接通信。

    +   对于 W/C/N 任务，`Send`有两种不同的形式

        +   C 任务

            ```
            FOREVER {
                Send( A, request, result )
                ...
            }
            ```

        +   W 任务

            ```
            FOREVER {
                Send( A, result, request )
                ...
            }
            ```

        +   N 任务

            ```
            FOREVER {
                Send( A, result, request )
                result.data = AwaitEvent( request.event )
                ...
            }
            ```

        +   对应于 W、C 和 N 任务的接收通常是相同的。

            +   N 实际上是一个 W 任务

                +   重要的区别在于，虽然 W 和 C 任务的优先级低于 A 任务，但 N 任务的优先级更高。

            +   C、W 和 N 的请求和结果必须具有兼容的数据类型。

            +   请求可能实际上是一个联合

                +   负载在运行时以不同方式解释，

                +   使用消息类型开关的不同情况。

        +   一个信使对一个 A 任务是 W 类型，对另一个是 C 类型

            ```
            FOREVER {
                Send( A1, request, result )
                Send( A2, result, request )
            }
            ```

        +   偶尔，但不经常，两个 A 任务以一种使得通过一个服务器可以双向通信的方式同步。

            +   然后使用两个信使

### 2. 活锁（致命拥抱）

##### 定义

两个或更多任务处于 READY 状态。对于每个任务，其他任务的状态阻止了进展，无论哪个任务是 ACTIVE。

需要更高级别的协调。

存在两种类型的活锁

1.  由糟糕编码导致的结果

    +   找到错误并将其移除。

1.  应用程序定义中固有的病理

    +   检测活锁并解决它。

在寻找解决方案时，我们更喜欢避免中央计划者的解决方案。为什么？

+   在二十世纪，有一系列依赖中央计划者的政治体系

    +   大多数已经不存在

活锁通常发生在资源争用的情况下

#### 真正的死锁是活锁

+   client1 需要 resource1 和 resource2；

    +   从 proprietor1 获取 resource1；

    +   向 proprietor2 请求 resource2

+   client2 需要 resource1 和 resource2；

    +   从 proprietor2 获取 resource2；

    +   向 proprietor1 请求 resource1

+   可能的代码

    +   客户端 1

        ```
        Send( prop1, getres1, ... );
        Send( prop2, getres2, ... );
        // Use the resources and release them
        ```

    +   客户端 2

        ```
        Send( prop2, getres2, ... );
        Send( prop1, getres1, ... );
        // Use the resources and release them
        ```

    +   所有者

        ```
        FOREVER {
           Receive( &clientTid, req, ... );
           switch ( req-type ) {
           case REQUEST:
              if( available ) { 
                 Reply( clientTid, use-it, ... );
                 available = false;
              }
              else enqueue( clientTid );
           case RELEASE:
              available = true;
              Reply( clientTid, "thanks", ... );
              if( !empty( Q ) ) {
                 available = false;
                 Reply( dequeue( ), use-it, ... );
              }
           }
        }
        ```

+   状态：

    +   client1，client2：REPLY-BLOCKED - 无法释放资源

    +   proprietor1，proprietor2：SEND-BLOCKED - 等待释放

    +   这是一个真正的死锁--四个任务永远都不会再次运行--即使调用图中没有循环。

    +   依赖关系在其他地方。在哪里？

    +   （你可以在互联网上找到与 vi vs emacs 或 Apple vs Microsoft 一样激烈的术语争论。）

##### 解决方案

1.  制作一个单一的复合资源，但是

    +   所有客户端可能都不需要这两个

    +   有些资源根本不能合并

1.  对所有客户端必须遵循的资源请求施加全局顺序。

    +   对恶意或无能的程序员不安全

    +   一些资源没有足够强的排序，例如火车集的轨道段

1.  创建一个处理所有资源请求的超级服务器

    +   客户端一次性请求所有资源，超级服务器在存在数百个截止日期时提供资源使用的最佳解决方案。

    +   客户端可能不知道需要 A 直到处理 B 进行到很高的程度

#### 真实的活锁

所有者 1 和所有者 2 拒绝了请求

+   所有者

    ```
    FOREVER {
       Receive( &clientTid, req, ... );
       switch ( req-type ) {
       case REQUEST:
          if( available ) { 
             Reply( clientTid, use-it, ... );
             available = false;
          }
          else Reply( clientTid, "sorry", ...);
       case RELEASE:
          available = true;
          Reply( clientTid, "thanks", ... );
       }
    }
    ```

+   轮询是最有可能的结果。典型的客户端代码。

    ```
    while ( Send( prop1, getr1, ... ) != GotIt ) ; 
    while ( Send( prop2, getr2, ... ) != GotIt ) ; 
    // Use the resources
    ```

+   问题在于这段代码通常只有在测试相对较短时才能正常工作

#### 真正是关键竞争的活锁

我们可以试着让客户端更加体谅

```
While ( no resources ) {
   Send( prop1, getres1, result );
   while ( result == "sorry" ) {
   if ( result == "sorry" ) {
      Delay( ... );
      Send( prop1, getres1, result );
   }
   Send( prop2, getres2, result );
   if ( result == "sorry" ) {
      Send( prop1, relres1, ... );
      Delay( ... );
   } else {
      break; 
   }
}
```

### 固有的活锁

记得那个两列火车正面相对的例子吗，每一列都在等待另一列移动。它们会一直等待着彼此，直到演示结束，可能会轮询。

解决这个问题有什么困难吗？

+   两位司机都不知道另一位司机在试图做什么。

在现实生活中，

+   驱动程序会进行通信，但是

+   在你的软件中，这既不容易

    +   可能需要多少不同的“对话”？

    既不是可取的

    +   两位司机特殊安排对其他列车的影响是什么？

对你来说最容易的是为每个驱动程序编写程序

1.  检测，例如，

    +   延迟随机时间

    +   再次请求

    +   如果被拒绝了，就想办法解决。

1.  解决方法，例如，

    +   重新开始按照目标工作，就像轨道被堵住了一样。

### 3.关键竞争

##### 例子

1.  两个任务，A 和 B，优先级相同

1.  A 正在进行大量的调试输入/输出。

1.  B 总是在 A 之前保留一节轨道，一切都很好。

1.  调试输入/输出已移除。

1.  A 在 B 之前保留了一个部分，执行崩溃了。

1.  将 A 的优先级降低到与 C 相同的级别。

1.  现在 C 执行得更快，并在 D 之前获取了资源。

1.  你永远都在调整优先级，最终恢复，重新插入调试输入/输出。

##### 定义

计算执行的顺序是确定其是否成功的重要因素。

关键竞争，就像活锁一样

+   是程序内部的，就像上面的那个，或者

+   不是程序外部的，而是应用程序领域内在的

##### 症状

1.  优先级的微小改变会不可预测地改变执行，并且会发生重大变化。

1.  调试输出会严重改变执行。

1.  列车速度的变化会极大地改变执行。

    +   几个学期前的例子

`极端'通常意味着混乱，从两个意义上讲

1.  第一感觉：初始条件的微小变化会导致执行中指数增长的分歧。

1.  第二个感觉：读者的练习。

##### 解决方案

1.  显式同步

    +   但是你必须知道允许事件发生的顺序

    +   例如 尝试列出系统中事件发生的所有顺序

        +   然后注意到仅仅按照相同的顺序到达通常是不够的

1.  门控是一种全局同步技术

    +   这可以由侦探/协调员提供

### 4\. 性能

一个任务相对于另一个任务性能的变化经常导致关键竞争

最难解决的问题

+   你只是不知道什么是可能的

+   提出一个问题，比如：

    +   我的内核代码是否在性能方面达到了可能的极限？

    +   我们可以比较消息传递等的性能，因为两个内核几乎相同。

        +   比较很多内核，你应该能够找到一个下限

    +   不能为火车应用做同样的事情

在实践中，你如何知道你有性能问题？我见过的问题

##### 优先级

最难做到正确的事情

+   人类大脑的 NP 难题

+   实用方法从所有优先级相同开始，然后调整

+   良好优先级分配的症状

    +   优先级越高，就越有可能就绪队列为空

    +   实践中，实际运行时间越短，优先级越高

优先级问题

1.  优先级反转

1.  一个资源，多个客户端

1.  任务试图做太多事情

##### 拥塞

1.  太多任务

    +   阻塞任务不计入，

    +   最低优先级任务几乎不算

分层抽象是昂贵的

例如 通知器 -> 串行服务器 -> 输入累加器 -> 解析器 -> 轨道服务器

##### 输出

1.  太多终端输出会干扰列车控制器的通信

    +   不要重绘整个屏幕

1.  请求轮询传感器的请求在串行服务器中积压，或者提供输出缓冲的人。

#### 硬件

1.  打开优化，但要小心

    +   有些地方你已经手动分配了寄存器

1.  打开缓存

    +   锁定是可能的

根据缓存行的大小和对齐方式校准大小和对齐校准表

+   链接器命令脚本

+   我认为这有点牵强。

* * *

返回到：

+   比尔·考恩 2012 年春季 CS452 讲义

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的主页
