# 第 32 讲 - 通信顺序处理（CSP）

### 公共服务公告

1.  期末考试日期：8 月 7 日上午 9 点至 8 月 9 日上午 11 点 30 分

1.  最终演示：8 月 26 日和 8 月 27 日

    +   8 月 25 日

        +   27 日进行演示的组在 13.00 离开实验室

    +   8 月 26 日

        +   代码冻结在 9.00

        +   演示从 9.30 开始

            +   时长 30 分钟

        +   演示结束于 13.00，27 日进行演示的组重新进入实验室

    +   8 月 27 日

        +   代码冻结在 9.00

        +   演示从 9.30 开始

            +   时长 30 分钟

        +   演示结束于 13.00

1.  在里程碑 2 的演示中注意到

    1.  保守的预留表现最佳

        +   它使边缘情况不存在

        +   但它们会抑制性能：我们看到两列车系统死机。

    1.  我的印象：

        +   每个组都有接近惊人的东西

        +   一些组有稳健的实现，不一定完整

    1.  一个稳健的实现有许多终端可控参数

    1.  只有一个组--我们询问的组中--有一个小的空闲任务执行时间比例，约为 50%，而且他们遇到了性能问题。

    1.  接下来，首先进行大循环，然后进行小循环，是对预留的一个很好的测试。

        +   我们喜欢那些调整速度最佳的。

        +   这是能够在没有锁死的情况下运行更多列车的症状

* * *

## 消息传递是否可以做到类型安全？

#### 动态地

是的，甚至包括类型��展和多态性，但是

+   当程序检测到类型不匹配时会做什么？

+   嗯，它在死机之前可以发送更多信息的错误消息。

#### 静态地

不，

+   结构化编程在于良好定义的范围至关重要。

+   虽然任务在内部有范围，但没有任务间的范围。

+   实际上，我们很高兴摆脱了范围限制，因为这使我们可以尝试更多种类的程序结构。

### CSP

对于形式方法的人来说，CSP 是一个用于推理多进程/多线程/多任务（MPTT）系统正确性的演算法。已经进行了四十年的积极研究，有几个目标

+   将其他同步/通信语义翻译成 CSP 并从 CSP 翻译

+   寻找关于 CSP 的推理新方法

+   将所有内容按比例缩放，使 CSP 对于生产规模的程序有用

+   在那段时间里，许多鸡在形式方法期刊和会议记录的页面上留下了它们的足迹！

对于程序员来说，主张并且一直主张 CSP 提供了一种优越的方法来构建 MPTT 系统。（“优越”是指“更容易设计、实现和理解”。）

+   该主张首次出现在 1970 年代末/1980 年代初。

+   它在 1990 年代初再次出现，这次有贝尔实验室的支持。

+   并且在最近几年再次提出，这次有谷歌的支持。

##### 原语

在 CSP 中有两个通信原语。在 occam 2/Go 的表示法中，它们是

1.  **读取**

    ```
    keyboard ? ch
    ch = <- keyboard
    ```

    +   从名为`keyboard`的输入通道读取并将其读取的内容赋给变量`ch`

    +   通道必须有一个关联类型，并且该类型必须与变量的类型匹配。

    +   也就是说，通道和变量必须在相同的范围内。

    +   读取阻塞，直到通道上有输入可用

1.  **写**

    ```
    keyboard ! duh
    keyboard <- duh
    ```

    +   将变量`duh`的值写入通道`keyboard`

    +   直到

    +   因此，读/写对保证了读取过程中的读取与写入过程中的相应写入同时发生或之后发生。

还有一个创建原语

+   occam -- PAR

    +   没有共享内存：昂贵

+   Go -- go

    +   共享内存：廉价

通信原语需要一种新的东西，称为通道。

```
CHAN OF CHAR keyboard
keyboard chan char
```

+   每个通道都有一个协议，规定它处理的消息的类型必须是什么。

+   知道通道的名称对于使用它是必不可少的。

    +   应用程序控制谁可以在通道的另一端，这对于安全性至关重要，通过控制谁知道通道的名称。

### 祖父--传输器--和孙子--Go

使用许多合作的、中等能力的微型 CPU 来完成一项大任务。

+   一个时机再次到来的想法。

+   谷歌

问题是通信

+   大颗粒度（厚客户端：微软，谷歌）

    +   最小化通信

    +   最大化复制数据

    +   谷歌的方法：

        +   一个没有人考虑过的机会

        +   一个没有人考虑过的问题。

+   小颗粒度

    +   最小化复制数据

    +   最大化通信

    +   你的系统，像线程解决方案一样，依赖于共享内存进行通信

        +   你如何处理缓存？

#### 传输器硬件

传输器是一个早期的、现在消失了的、基于丰富的小颗粒通信的实时系统的例子。你的内核是另一个例子。

+   你的内核：基于内核普遍可访问的内存进行通信，易于编程，难以确保安全。

+   传输器：基于交换介导的数据包通信，难以编程，易于确保安全。

传输器本身

+   CPU、内存、交换机在一块芯片上

+   芯片连接成一个数组

+   大概一个运行时系统决定任务将去的地方

    +   最大化 CPU 吞吐量

    +   最小化通信开销

    +   可以被程序员接管。

实时怎么样？

+   大量计时器（计时器）硬件

    +   倒计时和计时器的交互以制作您的时钟服务器

+   定时器的实例不能保证同步

    +   两个计时器如何同步？

#### 谷歌（数据中心）硬件

许多单板（包括磁盘）计算机

+   通过高速以太网通信

### 软件

农民与客户端和工人

#### Occam2

```
FOREVER
  ALT
    from.client ? request && workerfree
      SEQ
        workerfree = false
        to.worker ! request
    from.worker ? result
      SEQ
        workerfree = true
        to.client ! result
```

#### 去

```
FOREVER {
    select {
    case request <- from.client && workerfree
        workerfree = false
        request.data -> to.worker
    case result <- from.worker
        result -> request.chan
    {
}
case result <- from.worker
```

超时

#### Occam2

```
PAR
  SEQ
    sleep( delay )
    timeout ! true
  ALT
    in.data ? data
      // respond to data
    timeout ? now
      // data timed out
```

#### 去

```
timeout := make( chan bool )
go func( ) {
  time.Sleep( delay )
  timeout <- true
}( )
select {
case <- ch:
  // data available
case <- timeout:
  // read timed out
}
```

##### 基本思想

1.  进程（任务）

    +   可以命名，接受参数并返回值

    +   可能被合并

1.  CSP 通道

1.  时间

##### 结合进程

1.  顺序

1.  ���条件的

    +   if/then

    +   按情况选择

1.  循环

    +   没有测试/中断

    +   带有测试/中断

1.  并行

    +   当关键字 PAR 出现时启动。

1.  交替

    +   保护性选择

    +   如果有多个保护条件为真，则随机选择

        +   可以优先考虑

##### 时间

+   计时器将时间作为通道输入返回

    ```
    clock ? now
    ```

+   `AFTER`可以用来组合时间，因为基于时间的总序。

    ```
    IF now AFTER yesterday THEN
    ```

+   `AFTER`可以使计时器输入阻塞

    ```
    clock ? AFTER tomorrow
    ```

### 你能用类型检查构建服务器吗？

```
Outer
Scope
|
| CHAN OF REQUEST request
|
| Server 
| Scope
| |
| | REQUEST sreq
| | CHAN OF REPLY srep
| |
| | request ? sreq
| | srep := sreq.reply
| |
| | srep ! sresult
| |
| |
| |
| Client
| Scope
| |
| | REQUEST creq
| | CHAN OF REPLY crep
| |
| | creq.reply := crep
| | request ! creq
| |
| | crep ? cresult
| |

```

##### 结果

你可以编写一个类型安全的服务器，但是

+   所有可能的客户端必须在相同的范围内才能获得静态类型检查

+   使用动态、结构类型检查，你只需将任务编写成具有相同类型系统的语言

但是

通过这种结构，客户端中过多的代码会削弱同步，这可能不是你想要的。

* * *

返回：

+   比尔·科温 2012 年春季 CS452 课堂笔记

+   比尔·科温的 2012 年春季 CS452 页面

+   比尔·科温的 CS452 页面

+   比尔·科温的教学页面

+   比尔·科温的主页
