# 第 29 讲 - 病理学 II

### 公共服务公告

1.  期末考试日期：8 月 7 日上午 9 点至 8 月 9 日上午 11 点 30 分

* * *

## 病理学

随着我们逐渐深入了解这个列表，病理检测和编辑-编译-测试周期的长度会无限增长。

### 1\. 死锁

### 2\. 活锁（致命拥抱）

##### 定义

两个或更多任务处于准备状态。对于每个任务，其他任务的状态阻止了进展，无论哪个任务处于活动状态。

需要更高级别的协调。

有两种类型的活锁

1.  那些由糟糕编码导致的

    +   找到错误并消除它。

1.  那些固有于应用程序定义中的

    +   检测活锁并解决它。

在寻找解决方案时，我们更喜欢避免中央计划者。为什么？

+   在 20 世纪，有一系列依赖中央计划者的政治体系

    +   大多数已经不存在

活锁通常发生在资源争用的情况下

#### 真正的死锁活锁

+   客户端 1 需要资源 1 和资源 2；

    +   从所有者 1 处获取资源 1；

    +   向所有者 2 请求资源 2

+   客户端 2 需要资源 1 和资源 2；

    +   从所有者 2 处获取资源 2；

    +   向所有者 1 请求资源 1

+   可能的代码

    +   客户端 1

        ```
        Send( prop1, req{ REQUEST, ... );
        Send( prop2, getres2, ... );
        // Use the resources and release them
        ```

    +   客户端 2

        ```
        Send( prop2, getres2, ... );
        Send( prop1, getres1, ... );
        // Use the resources and release them
        ```

    +   所有者

        ```
        FOREVER {
           Receive( &clientTid, req, ... );
           switch ( req.type ) {
           case REQUEST:
              if( available ) { 
                 Reply( clientTid, "use-it", ... );
                 available = false;
              }
              else enqueue( clientTid );
           case RELEASE:
              available = true;
              Reply( clientTid, "thanks", ... );
              if( !empty( Q ) ) {
                 available = false;
                 Reply( dequeue( ), "use-it", ... );
              }
           }
        }
        ```

+   状态：

    +   客户端 1，客户端 2：回复阻塞 - 无法释放资源

    +   所有者 1，所有者 2：发送阻塞 - 等待释放

    +   这是一个真正的死锁 - 四个任务都不会再运行 - 即使在调用图中没有循环。

    +   依赖关系存在于其他地方。在哪里？

    +   （您可以在互联网上找到关于术语的争论，就像您在 vi vs emacs 或 Apple vs Microsoft 中看到的那样激烈。）

##### 解决方案

1.  制作一个单一的复合资源，但是

    +   所有客户端可能不需要全部

    +   一些资源根本无法合并

1.  对所有客户端必须遵循的资源请求施加全局顺序。

    +   不安全，容易受到恶意或无能程序员的攻击

    +   一些资源没有足够强的排序，例如火车轨道上的轨道段

1.  创建一个处理所有资源请求的超级服务器

    +   客户端一次性请求所有资源，超级服务器在存在数百个截止日期的情况下提供资源使用的最佳解决方案。

    +   客户端可能不知道需要 A 直到与 B 的处理已经进行到很深的阶段

#### 真正的活锁

所有者 1 和所有者 2 未能满足请求

+   所有者

    ```
    FOREVER {
       Receive( &clientTid, req, ... );
       switch ( req-type ) {
       case REQUEST:
          if( available ) { 
             Reply( clientTid, "use-it", ... );
             available = false;
          }
          else Reply( clientTid, "sorry", ...);
       case RELEASE:
          available = true;
          Reply( clientTid, "thanks", ... );
       }
    }
    ```

+   轮询是最可能的结果。典型的客户端代码。

    ```
    for ( Send( prop1, get-res1, result1 ) && Send( prop2, get-res2, result2 );
          !((result1 && result2) || time-out( )) ; ) {
       if ( !result1 ) Send( prop1, get-res1, result1 );
       if ( !result2 ) Send( prop2, get-res2, result2 );
    }
    // Use the resources
    ```

+   问题在于这段代码通常只要运行的时间相对较短就能正常工作

#### 真正的活锁是真正的关键竞争

我们可以尝试让客户端更加体贴些

```
   for ( Send( prop1, get-res1, result1 ) && Send( prop2, get-res2, result2 );
         !(result1 && result2) || !time-out( ); 
         Send( prop1, get-res1, result1 ) && Send( prop2, get-res2, result2 ) {
      if ( result2 ) Send( prop2, release-res2, ... );
      if ( result1 ) Send( prop1, release-res1, ... );
      Delay ( random( ) );
   {
```

### 固有的活锁

记得那个两列火车正面相对的例子，每列火车都在等待另一列火车移动。它们将面对面等待，直到演示结束，可能会轮询。

解决这个问题有什么困难？

+   两个驱动程序都不知道另一个驱动程序在尝试做什么。

在现实生活中，

+   驱动程序会进行通信，但是

+   在您的软件中，这并不容易

    +   可能需要多少不同的“对话”可用？

    也不是理想的

    +   两个司机特殊安排对其他火车的影响是什么？

对你来说最容易做的事情就是为每个驱动程序编程

1.  检测，例如，

    +   延迟一个随机时间

    +   再次请求

    +   如果被拒绝，解决方法

1.  解决方法，例如，

    +   重新开始工作目标，就好像轨道被阻塞了。

注意上面的解决方案对于火车司机不适用，因为他无法释放他所在的轨道。他的解决方案可能是类似于

```
   for ( Send( prop, get-res, result );
         !result && !time-out( ); 
         Send( prop, get-res, result ) Delay ( random( ) );
   }
```

### 3. 临界竞争

##### 例子

1.  两个任务，A 和 B，具有相同的优先级

1.  A 正在进行大量的调试 IO

1.  B 总是在 A 之前预留一段轨道，一切正常。

1.  调试 IO 被移除

1.  A 在 B 之前预留了一段轨道，执行崩溃了。

1.  将 A 的优先级降低到与 C 相同的水平。

1.  现在 C 执行更快，并在 D 之前获得资源。

1.  你不断地调整优先级，最终恢复，重新加入调试 IO。

##### 定义

计算的执行顺序是决定其成功与否的重要因素。

临界竞争，像活锁一样可能

+   程序内部，就像上面的那个，或者

+   程序外部但固有于应用领域

##### 症状

1.  优先级的微小变化会使执行变得不可预测，而且剧烈。

1.  调试输出的更改会使执行发生剧烈变化。

1.  火车速度的变化会使执行发生剧烈变化。

    +   几个学期前的例子

`剧烈'通常意味着术语的混乱

1.  第一种感觉：初始条件的微小变化会导致执行中指数增长的分歧。

1.  第二种感觉：读者的练习。

##### 解决方案

1.  显式同步

    +   但你必须知道允许事件发生的顺序

    +   例如，尝试列出系统中事件发生的所有顺序

        +   然后注意到仅仅按照相同的顺序到达通常是不够的

1.  门控是一种全局同步技术

    +   这可以由侦探/协调员提供

这些解决方案很难找到，因为

1.  面向场景的设计对人类来说是自然的（甚至可能是不可避免的）

1.  过多的同步会降低性能，因为它引入了额外的依赖关系。（检查有多少任务正在延迟。）

### 4. 性能

与另一个任务相比，性能的变化经常导致临界竞争

最难解决的问题

+   你只是不知道什么是可能的

+   提出一个问题，比如：

    +   我的内核代码是否达到了性能上的极限？

    +   我们可以比较消息传递等性能，因为两个内核几乎相同。

        +   比较很多内核，你应该能够找到一个下限

    +   无法为火车应用做同样的事情

在实践中，你如何知道自己有性能问题？我见过的问题

##### 优先级

最难做到正确的事情

+   人脑对于 NP 难

+   实际方法从所有优先级相同开始，然后进行调整

+   良好优先级分配的症状

    +   优先级越高，就越有可能就绪队列为空

    +   实践中运行时间越短，优先级越高

优先级问题

1.  优先级反转

1.  一个资源，多个客户端

1.  任务尝试做得太多

##### 拥塞

1.  任务过多

    +   阻塞的任务不计入，

    +   优先级最低的任务几乎不计入

分层抽象成本高昂

例如：通知器 -> 串行服务器 -> 输入累加器 -> 解析器 -> 跟踪服务器

##### 输出

1.  过多的终端输出干扰了列车控制器的通信

    +   不要重绘整个屏幕

1.  请求轮询传感器在串行服务器中积压，或者提供输出缓冲的其他地方。

#### 硬件

1.  打开优化，但要小心

    +   有些地方你已经手动进行了寄存器分配

1.  打开缓存

    +   锁定是可能的

根据缓存行的大小和对齐方式调整大小和对齐校准表

+   链接器命令脚本

+   我认为这有点牵强。

* * *

返回至：

+   比尔·考恩 2012 年春季 CS452 课堂笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的主页
