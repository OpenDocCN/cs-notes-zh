# 讲座 33 - 循环执行

### 公共服务公告

1.  期末考试日期：8 月 7 日 9.00 至 8 月 9 日 11.30

1.  最终演示：8 月 26 日和 8 月 27 日

    +   8 月 25 日

        +   在 27 日演示的组在 13.00 离开实验室

    +   8 月 26 日

        +   代码冻结在 9.00

        +   演示从 9.30 开始

            +   长度为 30 分钟

        +   演示在 14.00 结束，27 日演示的组重新进入实验室

    +   8 月 27 日

        +   代码冻结在 9.00

        +   演示在 9.30 开始

            +   长度为 30 分钟

        +   演示在 14.00 结束

* * *

### 软件

#### 带客户端和工作者的服务器

##### Occam2

```
FOREVER
  ALT
    from.client ? request && workerfree
      SEQ
        workerfree = false
        to.worker ! request
    from.worker ? result
      SEQ
        workerfree = true
        to.client ! result
```

##### 开始

```
FOREVER {
    select {
    case request <- from.client && workerfree
        workerfree = false
        request.data -> to.worker
    case result <- from.worker
        result -> request.chan
    {
}
```

#### 计时中断

##### Occam2

```
PAR
  SEQ
    sleep( delay )
    timeout ! true
  ALT
    in.data ? data
      // respond to data
    timeout ? now
      // data timed out
```

##### 开始

```
timeout := make( chan bool )
go func( ) {
  time.Sleep( delay )
  timeout <- true
}( )
select {
case <- ch:
  // data available
case <- timeout:
  // read timed out
}
```

* * *

## 循环执行

#### Voyageur

持续运行 34 年 10 个月 7 天。

它被设计成有三年的寿命！

##### 计算机

6000 字的指令和临时数据存储器

62,500 K 字节数字磁带记录器用于存储传感器数据

##### 系统软件

循环执行

### 循环执行

1.  时钟滴答

1.  按优先级顺序开始执行已准备好的程序。

1.  在程序结束时，等待时钟滴答声，然后进入步骤 2。

1.  如果时钟在程序结束之前滴答作响，则向地球报告故障并进入步骤 2。

1.  循环可以被地球发送的输入中断，告诉它跳转到引导模式。

    +   检查来自地球的输入是运行的程序之一。

    +   引导模式通常需要从地球加载新程序。（目前加载需要很多小时，而小时接近于天数。你们很幸运！）

这是一个抽象描述：由于内存很少，每个字都至关重要。

大多数程序的形式是

1.  如果来自 X 的输入，则执行 A。

我们回到了课程的开始，但现在我们知道的更多了。

### 实时调度

大多数实时计算都在类似航天飞机的环境中进行

1.  被轮询的传感器组，其固定周期不一定

1.  传感器输入触发任务，这些任务也以传感器的周期性运行

典型的例子，一组返回的传感器

+   轮轴的转速，以及

+   排气混合物，以及

+   扭矩，以及

+   控件的状态，以及...

一组任务以及

+   更新发动机参数，如燃烧混合物，以及

+   更新传输参数，如换挡速度等

+   将信息传递给仪表控制器，

+   和 ...

每当传感器返回新数据时，调度程序都会运行

1.  使数据准备好运行任何任务

1.  决定将准备好的任务中的哪个调度，并

1.  开始运行。

你的内核可以相当有效地处理这样的问题，

+   但你可以做得更好。

### 循环执行

让我们制定一个重复的有限日程安排

```
                                               A                                       A
  AC  BA    A C  A    A  C A    A B CA    A    C    A    AC B A    A C  A    A  C A    B
  |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
      |                           |                         |                          |
   |          |          |          |          |          |          |          |
________________________________________________________________________________________________________ time
```

如果时间是整数，那么一段时间后模式会重复。

+   你需要做的所有思考总量是有限的。

+   你所做的思考是将需要处理的量插入到日程表中

    +   最坏情况

+   将所有工作安排好，确保没有冲突。

    +   使用启发式算法，毫无疑问

#### 让它变得更容易一点

1.  通过使传感器周期成为彼此的倍数，使完整的模式变短。如果你能控制传感器周期。

    +   底层时钟。

    +   传感器 i 每 ni 个时钟周期读取一次。

    +   主周期的长度为 LCM(n1, n2, n3, ...)。

    +   手动（=脑力）安排主周期的时间表

1.  标准化每个点的处理

1.  最小化任务之间的交互

1.  如果任务无法适应，请调整完整的传感器/程序系统。

#### 让它更容易

证明一些定理，比如[Liu & Layland.](http://portal.acm.org/citation.cfm?id=321743&dl=ACM&coll=portal&CFID=10903146&CFTOKEN=86528874) 定理的本质是

1.  **关键时刻**，保证存在，发生在所有三个任务同时调度的时候。

1.  如果你选择任务优先级，使得最频繁调度的任务具有最高优先级，那么

    +   如果存在一个满足所有截止日期的时间表，那么

    +   你选择的任务优先级符合所有截止日期

#### 你的项目

如果你的项目是正确的，但资源受限，那么限制资源的关键时刻是你的项目失败的地方。例如。

+   如果你的项目受 CPU 限制，那么在 CPU 可以回到做最重要的新事情之前，必须完成最大计算的地方。

+   如果你的项目受火车通信带宽限制，那么这是所有当前希望同时通信的带宽用户的关键时刻。

### 小型计算设备

1977 年，当 Voyageou 发射时，计算是昂贵的，因此计算中的行动是在昂贵的大型设备中。现在计算是廉价的，行动在廉价的小型设备中。想想移动电话是如何工作的。

+   它有必须定期完成的维护功能，比如

    +   告知最近的地面站准备接听电话

    +   更新时钟

    +   刷新内存

+   当你打电话时，有一些电话功能必须定期完成

    +   从天线收集音频数据包

    +   对其中包含的数字音频进行信号调理。

    +   将数字音频放入数据缓冲区，然后发送到扬声器。

    +   在麦克风和天线之间介入的类似事物。

当你想玩游戏，查看日历，浏览互联网等时，你希望手机异步响应

+   当负载过重时，它应该减速而不是崩溃。

+   这样做的简单方法。

    +   将所有常规功能放入循环执行程序中，仔细分析每个功能的运行时间，确保一切都能按时完成。

    +   几乎每个周期都会有一些剩余时间。在这段时间内运行一个支持非关键但仍然实时特性的异步操作系统，比如

        +   管理用户界面

        +   发短信

        +   玩游戏

        +   浏览互联网

        +   以及你可以在应用商店找到的其他任何东西。

        这是你的内核擅长的事情。

    +   “非关键”的定义取决于用户的能力。例如，

        +   如果 UI 稍微减慢，用户可以轻松调整反应以适应

        +   但如果声音在一个单词中间停顿一秒钟，用户无法暂停听力以将单词的两半拼接在一起

这听起来很容易。为什么在实践中很难？

+   有必要共享资源。

    +   硬件，比如内存和 I/O

    +   软件，比如数据结构

    电池寿命是销售手机的关键

    +   因此资源是有限的

+   特别是，从异步 UI 开始，用户启动同步的功能，比如电话通话。

    +   同步/异步通信很难在满足严格的实时约束条件的同时实现。

    +   代码必须跨越同步/异步边界

更加棘手的是，你必须处理外部代码，比如应用程序。

+   决定是否安全地将新活动包含在日程安排中，这被称为**准入控制**，需要了解其性能特征。

+   你可以放心地将自己的代码放入日程安排中，因为你信任收到的性能特征。

+   外部代码，也就是在其他地方生成的代码，是不可信的。

+   你如何将其包含在日程安排中？

利用以人类术语定义的实时性。

+   如果其报告的性能特征足够好，就安装它。

+   如果在前 100 毫秒内违反了其性能特征，那么

    +   它可能是无能的。拒绝并告诉用户原因。

    +   这对用户来说是实时的。

+   如果它在后来违反了其性能特征，

    +   它可能是恶意的

你只需要处理循环执行中的溢出而不会错过截止日期的代码！

* * *

返回至：

+   比尔·考恩在 s12 学期 CS452 课程的讲座笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的主页
