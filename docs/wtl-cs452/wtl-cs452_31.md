# 第 31 讲

## - 上电

### 公共服务公告

1.  期末考试日期：8 月 7 日上午 9 点至 8 月 9 日上午 11 点 30 分

* * *

## 上电

### 初始状态

#### ARM

#### Cirrus

#### Technologic

下列内容是 TS7200 的特性，描述在 Technologic 文档、手册和电路图中

1.  启动控制位，设置为正常启动、32 位总线宽度、同步启动设备、内部、关闭看门狗定时器。

1.  物理内存映射

    +   0x80000000 到 0x800fffff，由 Cirrus 用于片上组件

    +   SDRAM 芯片将内存分成 4M 块。4M 块的地址为

        +   `0x00000000` 到 `0x003fffff`

        +   `0x00400000` 到 `0x007fffff`

        +   `0x00800000` 到 `0x00bfffff`

        +   `0x00c00000` 到 `0x00ffffff`

        +   `0x01000000` 到 `0x013fffff`

        +   ...

    +   TS7200 使用 4 位芯片选择将内存分成 256 M 字节块

        +   `0x00000000` 到 `0x0fffffff`（前 256M）SDRAM，CS0，32 总线周期

        +   `0x10000000` 到 `0x1fffffff`：CS1，8 位总线周期

        +   0x20000000 到 0x2fffffff：CS2，16 位总线周期。

        +   0x60000000 到 0x7fffffff：CS6/7，闪存

        +   0x80000000 到 0x8fffffff：包括 I/O 寄存器

            +   0x80000000 到 0x807fffff：包括 AHB 映射寄存器

                +   DMA

                +   以太网

                +   USB

                +   内存控制器

                +   预启动 ROM

                +   ICU 寄存器

            +   `0x80800000` 到 `0x8fffffff`：I/O 寄存器

        SDRAM 芯片将内存分成 4M 块。4M 块的地址为

    +   `0x00000000` 到 `0x003fffff`

    +   `0x00400000` 到 `0x007fffff`

    +   `0x00800000` 到 `0x00bfffff`

    +   `0x00c00000` 到 `0x00ffffff`

    +   `0x01000000` 到 `0x013fffff`

    +   ...

1.  AHB 寄存器中有一个 16K 块的 ROM，从 `0x80090000` 到 `0x80093fff`

    +   最初，它被映射到整个内存空间，间隔为 16K。

    +   芯片选择和寻址方式。

        +   此块的芯片选择为 `0x8009[00XXb]XXX`

        +   芯片选择有两部分

            +   I/O 芯片选择：`0x8XXXXXXX`

            +   AHB 芯片选择：`0xY00XXXXX`

            +   ROM 芯片选择：`0xYYY9[00XXb]XXX`

    +   执行的第一条指令是在 `0x80090000` 处找到的那一条

### 预预启动序列

1.  跳转到 `0x80090018.`

1.  打开 LED

1.  使 CPU 完全标准。例如，

    +   无缓存，物理内存映射，

1.  关闭看门狗定时器

1.  配置外部时钟（串行启动所需）

1.  获取启动状态配置输入

    +   这些是 EP9302 上的输入引脚，其状态由 TS7200 决定。

    +   一些可以通过跳线控制的用户可控制。

    +   这些是 EP9302 对外部世界唯一知道的东西

1.  使用启动状态配置

    +   闪存存储器控制器

    +   SDRAM 存储器控制器

    这些配置为非常保守的参数

1.  清除启动模式 `memory map'

1.  切换 LED

1.  开关

    +   UART1 上的串行启动

        1.  输出 ">"

        1.  从 CRUS 或 SURC 开始读取 2048 字节到 Mac FIFO

        1.  跳转到 Mac FIFO 的起始位置

    +   从 SoC 外部的 ROM 启动

        1.  断言 ROM 芯片选择以查找 CRUS

        1.  找到后从 ROM 读取 2048 字节到 Mac FIFO

        1.  跳转到 Mac FIFO 的起始位置

    +   从闪存启动

        1.  在可能的闪存起始位置查找 CRUS

        1.  找到后跳转到起始位置加上 `0x4（考虑 CRUS）`

    +   如果未找到

        +   如果 0x0 可写目的地是 SDRAM，否则目的地是 Mac FIFO

        +   将 20 个字载入目的地

        +   永久闪烁 LED

1.  在前两种情况下，2048 字节包含一个内存测试，然后是一个加载程序。

1.  Mac FIFO 代码也用于预引导中的过早死亡。

### 预引导序列

这段代码对 EP9302 和 TS7200 了如指掌。

1.  在以太网缓冲区中设置一个堆栈

1.  将 CPSR 设置为普通状态：无中断，svc 模式

1.  从闪存复制 80 个字到以太网缓冲区

1.  初始化其拥有的内存控制器

1.  配置 GPIO。

1.  关闭看门狗定时器

1.  为监视器设置适当的串行端口

1.  加载 RedBoot

* * *

## 消息传递是否可以变得类型安全��

#### 动态地

是的，甚至包括类型扩展和多态性，但是

+   当程序检测到类型不匹配时会做什么？

+   嗯，它在崩溃之前可以发送更多信息的错误消息。

#### 静态地

不，

+   结构化编程在很大程度上取决于明确定义的范围。

+   虽然任务在内部有范围，但没有任务间的范围。

+   实际上，我们很高兴摆脱了范围限制，因为这使我们可以尝试更多种类的程序结构。

### CSP

对于正式方法的人来说，CSP 是一种用于推理多进程/线程/任务（MPTT）系统正确性的演算法。 过去四十年一直在进行积极的研究，有几个目标

+   将其他同步/通信语义转换为 CSP 并从 CSP 转换

+   寻找关于 CSP 的推理的新方法

+   将所有内容缩放以使 CSP 对生产规模的程序有用

+   在那段时间里，许多只小鸡在正式方法期刊和会议记录上留下了它们的足迹！

对于程序员来说，有人声称并且声称 CSP 提供了一种优越的方法来构建 MPTT 系统。（“优越”是指“更容易设计、实现和理解”。）

+   该主张最初是在 1970 年代末/1980 年代初提出的。

+   它在 1990 年代初再次提出，这次是贝尔实验室的支持。

+   并且最近几年又一次提出，这次是谷歌的支持。

##### 原语

在 CSP 中有两种通信原语。 在 occam 2/Go 的表示法中，它们是

1.  **read**

    ```
    keyboard ? ch
    ch = <- keyboard
    ```

    +   从名为`keyboard`的输入通道读取内容，并将其赋给变量`ch`

    +   通道必须有一个关联的类型，并且该类型必须与变量的类型匹配。

    +   也就是说，通道和变量必须在相同的范围内。

    +   read 在通道上有输入可用时会阻塞

1.  **write**

    ```
    keyboard ! duh
    keyboard <- duh
    ```

    +   将变量`duh`的值写入通道`keyboard`

    +   write 不会阻塞

    +   因此，读/写对保证了读取过程中的读取与写入过程中的相应写入同时发生或之后发生。

通信原语需要一种新的东西，称为通道。

```
CHAN OF CHAR keyboard
keyboard chan char
```

+   通道是先进先出的仓库。

+   每个通道都有一个协议，规定它处理的消息类型必须是什么。

+   知道通道的名称对于使用它是至关重要的。

    +   应用程序控制谁可以在通道的另一端，这对于安全性至关重要，通过控制谁知道通道的名称。

### 传输器

使用许多合作的、中等能力的微型 CPU 来完成一项大任务。

+   一个时机已经到来的想法。

+   谷歌

问题是通信

+   大颗粒（厚客户端：微软，谷歌）

    +   最小化通信

    +   最大化复制数据

    +   谷歌的方法：

        +   一个没有人考虑过的机会

        +   一个没有人考虑过的问题。

+   小颗粒

    +   最小化复制数据

    +   最大化通信

    +   你的系统，像线程解决方案一样，依赖于共享内存进行通信

        +   FORTRAN 公共块的回归

        +   你如何处理缓存？

通信要求要么

+   一个共同的总线，星形拓扑结构

    +   系统总线（=共享内存）

    +   局域网

+   一个共同的通道，在其中用户实时传递消息

    +   浪费带宽

    +   模拟电话

+   沿着传递消息

    +   强调连接共同总线的开关（桥）

    +   实际上更像是一个混合体，根据抽象级别进行不同分类。

关于实时性怎么样？

+   大量的计时器（计数器）硬件

    +   倒计时和计时器的交互以制作你的时钟服务器

+   计时器的实例不能保证同步

    +   两个计时器如何同步？

传输器是一个早期的、现在已经消失的、基于丰富的小颗粒通信的实时系统的例子。你的内核是另一个例子。

+   你的内核：基于共享内存的通信，易于编程，难以确保安全。

+   传输器：基于交换介导的数据包通信，难以编程，易于确保安全。

传输器硬件

+   CPU、内存、一块芯片上的开关

+   连接在一个数组中的芯片

+   大概是一个运行时系统决定任务将去的地方

    +   最大化 CPU 吞吐量

    +   最小化通信开销

### Occam 2

##### 基本思想

1.  进程（任务）

    +   可能被命名，接受参数并返回值

    +   可能被组合

1.  CSP 通道

1.  时间

##### 组合进程

1.  顺序

1.  有条件的

    +   if/then

    +   按情况选择

1.  循环

    +   没有测试/中断

    +   带有测试/中断

1.  并行

    +   当关键字 PAR 出现时启动。

1.  交替

    +   受保护的备选项

    +   如果有多个保护条件为真，则随机选择

        +   可以优先考虑

##### 时间

+   计时器将时间作为通道输入返回

    ```
    clock ? now
    ```

+   `AFTER`可以用来组合时间，因为基于时间的总序

    ```
    IF now AFTER yesterday THEN
    ```

+   `AFTER`可以使计时器输入阻塞

    ```
    clock ? AFTER tomorrow
    ```

### 你能用类型检查构建一个服务器吗？

```
Outer
Scope
|
| CHAN OF REQUEST request
|
| Server 
| Scope
| |
| | REQUEST sreq
| | CHAN OF REPLY srep
| |
| | request ? sreq
| | srep := sreq.reply
| |
| | srep ! sresult
| |
| |
| |
| Client
| Scope
| |
| | REQUEST creq
| | CHAN OF REPLY crep
| |
| | creq.reply := crep
| | request ! creq
| |
| | crep ? cresult
| |

```

##### 结果

你可以编写一个类型安全的服务器，但是

+   所有可能的客户端必须在同一范围内才能获得静态类型检查

+   使用���态、结构类型检查，你只需要用相同类型系统的语言编写任务

但是

在这种结构中，客户端中过多的代码会削弱同步，这可能不是你想要的。

* * *

返回到：

+   比尔·考恩 2012 年春季 CS452 讲座笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考文的教学页面

+   比尔·考文的个人主页
