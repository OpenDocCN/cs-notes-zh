# 第 14 讲 - 串行 I/O，调试

### 公共服务公告

1.  作业 4

1.  性能测量

* * *

## 串行 I/O

参见 pdf。

FIFO

为什么 UART 中存在 FIFO？

### 大错误

要有效使用 FIFO，必须能够独立关闭发射机和接收机。

但查看 UARTxCtrl 中的 UARTE

+   UART 启用。

+   如果此位设置为 1，则 UART 已启用。

+   数据传输和接收发生在 UART 信号中。

### 小错误

`假设 UART 的各种配置寄存器不会连续快速写入，以确保在实现中配置信息的正确同步。这些寄存器包括 UART1Ctrl 和 UART1LinCtrlHigh。...在两次写入之间，至少必须发生两个 UARTCLK 周期。在最坏的情况下，两次写入之间必须至少有 55 个 HCLK 周期。最简单的方法是通过 55 个 NOP 将这两次写入分开。'

为什么会发生这种情况？

+   CPU 由 CPU 时钟驱动

+   系统总线由几个不同的时钟驱动

+   UART 由自己的时钟驱动

+   时钟未适当同步

为什么没有人在意？

+   UART 在开发过程的开始阶段使用

+   一旦其他 I/O（以太网，USB 等）正常工作，UART 将不再使用，除非可能由引导加载程序使用

### 中断

##### 设备中有五个中断

这些中断可以单独启用和禁用。

1.  发送

    +   FIFO 启用

        +   当发送 FIFO 少于一半时断言。

        +   当发送 FIFO 超过一半时清除。

    +   FIFO 禁用

        +   当保持寄存器为空时断言

        +   写入保持寄存器时清除

    +   不受启用条件限制。

1.  接收

    +   FIFO 启用

        +   当接收 FIFO 为一半时断言

        +   当接收 FIFO 读取到少于一半时清除。

    +   FIFO 禁用

        +   当接收缓冲区已满时断言

        +   当接收缓冲区被读取时清除

1.  调制解调器状态

    +   当硬件流控制位发生变化时断言

    +   当调制解调器状态寄存器被写入时清除

1.  接收超时

    +   当接收 FIFO 不为空且经过 32 位周期没有新数据时断言

    +   当所有数据从 FIFO 中读取完毕时清除

1.  组合

    +   上述四个中断的 OR

    +   当上述任一中断断言时断言

    +   当上述所有中断都未断言时清除。

##### ICU 的三个输入

1.  发送

1.  接收

1.  组合

这些对于与终端交互是足够的，但对于与列车控制器交互则不够。

##### 使用中断的简单方法

仅启用组合；读取 UART 寄存器以决定下一步操作。

将 UART 的接收和发送部分视为单独的状态机

+   将状态机基于状态寄存器中的位

+   为流控制制作一个单独的状态机

### 实用建议

到目前为止，您一直在使用忙等待 I/O 来获取调试输出。在实现基于中断的 I/O 时，您希望继续获得调试输出。

1.  ARM 板上有两个 UART 端口。

1.  将每个连接到终端上的不同终端窗口。

1.  在调试一个忙等待 I/O 的同时，让另一个工作中断介导的 I/O 起作用。

1.  然后在创建和调试另一个服务器时，在工作串行服务器上进行调试 I/O。

**提示**。终端的串行服务器必须比火车控制器的串行服务器复杂得多。

* * *

## 调试实时程序

经验丰富的程序员使用的最常见的一组调试工具是最古老的：printf、grep 和堆栈跟踪。

+   这些工具的强大之处在于代码格式化中的强大约定。

实时程序的调试，本质上与任何其他调试相同，也与经验科学相同。

1.  收集数据。

1.  创建一个解释数据的模型

1.  进行模型测试

1.  如果模型不正确，转到第 1 步。

1.  记住，模型始终是临时的：稍后收集的数据可能会使其无效，无论有多少数据证实了它。

但实时程序更难调试。很少有程序完全没有关键竞争，这是最糟糕的错误类型，在看似正确的代码中潜伏数周、数月甚至数年，然后在发生无害的、不相关的更改时出现。

#### 关键竞争

没有已知的方法可以消除关键竞争。

+   同步一切，这似乎是一个明显的解决方案，但会降低性能，因为它会从执行中移除灵活性。

原则上不���能通过测试消除关键竞争。为什么？

+   当三列火车连续运行十分钟时，现实世界中会发生多少事件？

+   这些事件有多少种可能的顺序？

+   重新排序甚至不是发生关键竞争的必要条件，只是时间上过于接近。

### RedBoot

内存内容不会在重置时被擦除。只有通过重置后内存内容才能检测到一些最困难的错误。通过插入产生有用结果

```
    str   pc, <magic location>
```

你的代码中的许多地方。然后，借助负载图的帮助，您可以找出在问题发生时您在哪个代码中以及在哪个代码中。

在 RedBoot 中，原则上可以跟踪任何一个内核

### 堆栈跟踪

在单线程程序中，这通常是最有用的工具。

+   任何异常终止执行的内容都会打印出活动堆栈帧的集合

+   最小版本

    +   调用函数的名称

    +   调用的行号

+   极端版本

    +   参数的值

    +   本地变量的值

在实时多任务环境中，堆栈跟踪的等价物是什么？

+   如何实现它？

    要回答的两个基本问题。

    1.  何时产生？

    1.  它应该包含什么？

+   如何使其可读？

### 断点

它是做什么的？

+   系统的快照

    +   这意味着计算，包括对中断的响应，必须停止，否则就不是一个快照。

+   提供用于检查内核数据结构的交互式工具，例如

    +   任务描述符

    +   列表和队列

    +   个别任务的堆栈，包括程序计数器和本地变量

+   立即重新启动系统

    +   如果你想要在处理停止的地方继续，你必须确保在进入断点时保存所有状态，并在离开时恢复。那么待处理的中断呢？你不能停止整个宇宙！

    +   否则你可以重新进入 RedBoot。

如何启动它？

+   函数调用，在编译代码时插入的。

    +   实现的最简单和最快的形式。

    +   将调用作为 ASSERT 的一部分是常见的。

    +   必须退出到 RedBoot。（跳转到 x00。）

+   使用系统调用而不是函数调用，这尊重内核/用户的区别。

+   外部触发的异常

    +   在初始化时

        1.  设置系统，以便外部事件将生成异常

        1.  例如，将按钮连接到第三个连接器上的 PDIO，设置 ICU。

    +   在运行时

        1.  触发中断

        1.  在事件处理程序中切换到断点

        1.  要么退出到 RedBoot，

        1.  或清理待处理的中断并恢复执行。

断点是一种非常常见的特定类型工具的特例。

+   条件发生 => 信息可用

+   断点提供交互式信息（`交互式' = `用户时间尺度上的'）

    +   它可以完全停止系统。怎么做？

    +   但它有限的能力来停止真实世界

        +   即，它隐藏了一些错误

将信息更接近实时。

* * *

返回到：

+   比尔·考恩在 s12 为 CS452 的讲座笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的主页
