# 第 14 讲 - 串行 I/O，调试

### 公共服务公告

1.  作业 4

1.  性能测量

* * *

## 串行 I/O

参见 pdf。

FIFO

为什么 UART 中存在 FIFO？

### 大错误

要有效使用 FIFO，您必须能够独立关闭发射机和接收机。

但看看 UARTxCtrl 中的 UARTE

+   UART 启用。

+   如果此位设置为 1，则 UART 已启用。

+   数据传输和接收发生在 UART 信号中。

### 小错误

“假定 UART 的各种配置寄存器不会连续快速写入，以确保在实现中跨配置信息的正确同步。这些寄存器包括 UART1Ctrl 和 UART1LinCtrlHigh。...在两次写入之间，至少必须经过两个 UARTCLK 周期。在最坏的情况下，两次写入之间必须至少有 55 个 HCLK 周期。最简单的方法是通过 55 个 NOP 将这两次写入分开。”

为什么会发生这种情况？

+   CPU 由 CPU 时钟驱动

+   系统总线由几个不同的时钟驱动

+   UART 由自己的时钟驱动

+   时钟未适当同步

为什么没有人在意？

+   UART 在开发过程的开始阶段被使用

+   一旦其他 I/O（以太网，USB 等）正常工作，UART 将不再使用，除非可能由引导加载程序使用

### 中断

##### 设备中有五个中断

这些中断可以单独启用和禁用。

1.  发送

    +   FIFO 已启用

        +   当传输 FIFO 少于一半时断言。

        +   当传输 FIFO 超过一半时清除。

    +   FIFO 已禁用

        +   当保持寄存器为空时断言

        +   写入保持寄存器时清除

    +   不受启用条件限制。

1.  接收

    +   FIFO 已启用

        +   当接收 FIFO 半满时断言

        +   当接收 FIFO 读取不到一半时清除。

    +   FIFO 已禁用

        +   当接收缓冲区满时断言

        +   当接收缓冲区被读取时清除

1.  调制解调器状态

    +   当硬件流控制位发生变化时断言

    +   当调制解调器状态寄存器被写入时清除

1.  接收超时

    +   当接收 FIFO 非空且经过 32 位周期没有新数据时断言

    +   当所有数据从 FIFO 中读取完毕时清除

1.  组合

    +   上述四个中断的逻辑或

    +   当上述任一中断被触发时断言

    +   当上述所有中断未被触发时清除

##### ICU 的三个输入

1.  发送

1.  接收

1.  组合

这些对于与终端交互是足够的，但对于与列车控制器交互则不够。

##### 使用中断的简便方法

仅启用组合；读取 UART 寄存器以决定下一步操作。

将 UART 的接收和发送部分视为独立的状态机

+   基于状态寄存器中的位构建状态机

+   为流控制制作一个独立的状态机

### 实用建议

到目前为止，您一直在使用忙等待 I/O 来获取调试输出。在实现中断 I/O 时，您希望继续拥有调试输出。

1.  ARM 板上有两个 UART 端口。

1.  将每个连接到终端上的不同终端窗口。

1.  在调试另一个时，通过忙等待 I/O 来调试一个，同时让中断介导的 I/O 在另一个上运行。

1.  然后在创建和调试另一个服务器时，在工作串行服务器上进行调试 I/O。

**提示**。终端的串行服务器必须比火车控制器的串行服务器复杂得多。

* * *

## 调试实时程序

经验丰富的程序员使用的最常见的一组调试工具是最古老的：printf、grep 和堆栈跟踪。

+   这些工具的功能受到代码格式强大约定的极大增强。

实时程序的调试，本质上与任何其他调试相同，也与经验科学相同。

1.  收集数据。

1.  创建解释数据的模型

1.  测试模型

1.  如果模型不正确，转到 1。

1.  记住模型始终是暂时的：稍后收集的数据可能会使其无效，无论有多少数据已经确认了它。

但实时程序更难调试。很少有程序完全没有关键竞争，这是最糟糕的错误类型，在看似正确的代码中潜伏数周、数月甚至数年，然后在发生无害的、不相关的更改时出现。

#### 关键竞争

没有已知的方法可以消除关键竞争。

+   同步一切，这似乎是一个明显的解决方案，但会降低性能，因为它会从执行中移除灵活性。

原则上，不可能通过测试消除关键竞争。为什么？

+   当三列火车连续运行十分钟时，现实世界中会发生多少事件？

+   这些事件有多少种可能的顺序？

+   重新排序甚至不是发生关键竞争的必要条件，只是时间上过于接近。

### RedBoot

内存内容不会被重置擦除。一些最困难的错误只能通过在重置后使用内存内容来检测。通过插入

```
    str   pc, <magic location>
```

你的代码中的许多地方。然后，借助负载映射的帮助，您可以找出在发生问题时您在哪个代码中。

在 RedBoot 中，原则上可以跟踪任何一个内核

### 堆栈跟踪

在单线程程序中，这通常是最有用的工具。

+   任何异常终止执行的内容都会打印出活动堆栈帧的集合

+   最小版本

    +   调用函数的名称

    +   调用的行号

+   极端版本

    +   参数的值

    +   本地变量的值

在实时多任务环境中，堆栈跟踪的等价���是什么？

+   你如何实现它？

    要回答的两个基本问题。

    1.  何时产生？

    1.  它应该包含什么？

+   你如何使其可读？

### 断点

它是做什么的？

+   系统的快照

    +   这意味着计算，包括对中断的响应，必须停止，否则它不是一个快照。

+   提供用于检查内核数据结构的交互式工具，例如

    +   任务描述符

    +   列表和队列

    +   包括各个任务的堆栈，包括程序计数器和本地变量

+   立即重新启动系统

    +   如果要继续处理停止的地方，必须确保在进入 Beakpoint 时保存所有状态，并在离开时恢复。挂起的中断怎么办？你不能停止整个宇宙！

    +   否则，你可以重新进入 RedBoot。

如何启动它？

+   函数调用，在编译代码时插入。

    +   实现的最简单和最快的形式。

    +   将呼叫作为 ASSERT 的一部分是常见的。

    +   必须退出到 RedBoot。（跳转到 x00。）

+   系统调用而不是函数调用，尊重内核/用户区分。

+   外部触发的异常

    +   在初始化时

        1.  设置系统，使外部事件会产生异常。

        1.  例如，将按钮连接到第三个连接器上的 PDIO，设置 ICU。

    +   在运行时

        1.  触发中断

        1.  在事件处理程序中切换到断点

        1.  要么退出到 RedBoot，

        1.  或清理挂起的中断并恢复执行。

断点是一种非常常见的特定工具的特例。

+   条件发生 => 信息可用

+   断点提供交互式信息（`交互式' = `用户时间尺度上的'）

    +   它可以完全停止系统。怎么做？

    +   但它有限的停止现实世界的能力

        +   即，它隐藏了一些错误

获取更接近实时的信息。

* * *

返回到：

+   Bill Cowan 在 s12 的 CS452 讲座笔记

+   Bill Cowan 的 2012 年春季 CS452 页面

+   Bill Cowan 的 CS452 页面

+   Bill Cowan 的教学页面

+   Bill Cowan 的主页
