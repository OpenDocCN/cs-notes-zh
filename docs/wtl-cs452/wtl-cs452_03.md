# 第 3 讲 - 计时器，I/O，陷阱

### 公共服务公告

1.  作业 0 的截止日期

1.  缓存，优化，时钟速度，FIFO

1.  库：特别是 memcpy

1.  课程帐户需要进行一些清理

* * *

## 提供的硬件/软件

由 CSCF 提供和维护

+   Linux 系统

    +   交叉编译器：在 86_64 上运行，生成 ARM 的代码

    +   GNU 工具链：编译器，汇编器，链接编辑器

        +   你会注意到我的 makefile 分开了

            +   编译为汇编代码，

            +   汇编汇编代码，并

            +   链接编辑。

    +   需要显式登录到`linux.student.cs`

+   TFTP 服务器

    +   需要显式键入 IP 号码

### TS-7200

Technologic 提供的具体文档

##### 系统芯片（SoC）

EP9302，由 Cirrus 半导体设计和制造

##### 记忆

字节可寻址，字长 32 位

+   32 M 字节的 RAM，从`0x00000000`开始

+   4 M 字节的闪存 RAM，从`0x60000000`开始

    +   包含 RedBoot，它在启动时加载到 RAM 中

+   低地址处的特殊位置

+   低于`0x80000000`的特殊位置

    两种特殊位置

    +   由 Technologic 提供：`0x80840000`至`0x80840047`

    +   由 Cirrus 提供：

        +   `0x80010000`至`0x8081ffff`

        +   `0x808a0000`至`0x80900023`

分开指令和数据缓存

##### “COM”端口

连接到 UART

+   RS-232

+   EP9302 上实际的 UART 硬件

实际上只有两个

##### 以太网端口

RedBoot 中的忙等以太网代码

+   加载程序用于执行 TFTP 协议

+   由 Technologic 定制并安装在 Flash RAM 中的 RedBoot 使用

##### 复位开关

+   红色，尽管文档说是黑色的

+   实际上，有些是黑色的

### EP-9302

Cirrus 的具体文档

##### SoC

+   ARM 920T 核心，实现 ARM v4T 指令集

    +   ARM 的具体文档

+   两个协处理器

    1.  系统控制器，MMU

        +   ARM 文档

    1.  Maverick Crunch 浮点单元

        +   Cirrus 文档

+   两个中断控制器

    +   ARM 和 Cirrus 文档都有

    +   由 ARM 设计的部件，PL-190

+   外设

    1.  UART

    1.  计时器

    1.  DIO

    1.  A/D

    1.  等等。

### 软件

##### 编译器

GNU 工具链

+   当你开始优化时通常是一个坏主意

+   软件乘法，除法，浮点运算来自 libgcc.a

+   gcc 使用了一些函数，比如 memcpy

+   Makefile

+   target.ld

##### RedBoot

部分实现

+   fconfig :: 不

+   载入（tftp）

+   检查，复制，填充内存

程序终止时返回

##### 忙等 IO

COM2 使用监视器；COM1 连接到火车

1.  初始化

1.  输出

1.  输入

* * *

### 计时器

如何在计算机中计时？

+   晶体振荡器

+   来自计时器的中断

+   ntp

计时器通常是倒计时的

你通过三个寄存器与计时器进行交互

+   寄存器用于加载计时器

+   寄存器用于读取计时器

+   将定时器注册到命令

EP9302 中可用的计时器。

1.  两个十六位

1.  一个三十二位

1.  一个四十位

1.  一个看门狗

* * *

## 轮询循环

轮询循环允许您同时管理多个条件/活动对。

基本轮询循环

```
FOREVER {
  if( c1 ) a1;
  if( c2 ) a2;
  ...
  if( cN ) aN;
}
```

#### 几点评论

##### 浅层计算

##### 最坏情况的响应时间

+   sum over n of {`if( c<n>`的执行时间) + `a<n>`的执行时间}

##### 你放入一个动作中的内容非常重要。

假设你将忙等待 I/O 放入火车控制器中的一个动作

你会在测试中捕捉到吗？

+   可能不会。

#### 当你错过截止日期时

##### 多次测试

假设你想要更好的 `a1` 响应时间。那么尝试这个循环

```
FOREVER {
  if( c1 ) a1;
  if( c2 ) a2;
  if( c1 ) a1;
  if( c3 ) a3;
  ...
  if( c1 ) a1;
  if( cN ) aN;
}
```

`a1` 的最坏情况响应时间

+   `if( c1 )` 的执行时间 + 对于 n 的最大执行时间的总和 `if( cn ) an`

##### 分解成片段

假设响应时间仍然太长，因为某个动作的执行，比如 a2，太长了。那么你可以将 a2 分成两部分

```
FOREVER {
  if( c1 ) a1;
  if( c2 ) { a2.1; half-done = TRUE; }
  if( c1 ) a1;
  if( half-done ) { a2.2; half-done = FALSE; }
  ...
}
```

这开始变得有点复杂，而我们还没有提到交互通信

* * *

返回至：

+   Bill Cowan 在 s12 学期 CS452 课程的讲座笔记

+   Bill Cowan 2012 年春季 CS452 页面

+   Bill Cowan 的 CS452 页面

+   Bill Cowan 的教学页面

+   Bill Cowan 的主页
