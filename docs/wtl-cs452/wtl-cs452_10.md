# 第 10 讲 - 名字服务器

### 公共服务公告

1.  作业 1 的截止日期

1.  下周的课程安排

1.  作业 2

    +   截止日期

    +   你要做什么

* * *

## 发送/接收/回复

### 状态序列

### 有两种情况

##### 发送前接收

| 发送者动作 | 发送者状态 | 接收者动作 | 接收者状态 | 注释 |
| --- | --- | --- | --- | --- |
|  | 活跃 |  |  |  |
| 发送 | RCV_BL |  |  | 发送者添加到接收者的 sendQ 中 |
|  |  |  | 活跃 |  |
|  | RPL_BL | 接收 | 就绪 | 请求已复制发送者从接收者的 sendQ 中删除 |
|  |  |  | 活跃 | 已执行的服务 |
|  | 就绪 | 回复 | 就绪 | 回复已复制 |

##### 发送前接收

| 发送者动作 | 发送者状态 | 接收者动作 | 接收者状态 | 注释 |
| --- | --- | --- | --- | --- |
|  |  |  | 活跃 |  |
|  |  | 接收 | SND_BL | 接收者的 sendQ 为空 |
|  | 活跃 |  |  |  |
| 发送 | RPL_BL |  | 就绪 | 请求已复制 |
|  |  |  | 活跃 | 已��行的服务 |
|  | 就绪 | 回复 | 就绪 | 回复已复制 |

* * *

### 实际细节

+   需要保留的请求

    +   对于 SendQ 中的 Send_Blocked 接收方

        +   与 Receive_Blocked 发送方相同

    +   对于 Reply_Blocked 发送方。

+   消息

+   任务状态

+   你可以在指定之外添加额外的返回值

* * *

### int 发送( Tid tid, char *message, int mslen, char *reply, int rplen )

这些都很容易理解，除了

1.  返回值是实际放置在回复缓冲区中的字符数

    +   包括回复缓冲区的内容是字符串时的终端字符（\000）

1.  如果出现问题，返回值为负数，编码以指示出了什么问题

    会出什么问题

    1.  非法的`tid`

    1.  `tid`不是现有任务

    通过查看其返回值，`Send`需要检查回复缓冲区是否足够大

    如果我们`Send`的任务从不`Receive`，那不是错误

    +   应该是吗？

    +   提示。找出任务“永远不接收”等同于什么问题？

1.  解析`argument`和`reply-buffer`可能是昂贵且容易出错的

    +   类型系统可能很好

    +   但是然后你会感到有必要实现运行时类型检查

##### 实现发送

用户空间中只是存根。

+   检查参数

+   将参数放在正确的位置

    +   请注意有五个参数

内核必须做什么

1.  检查参数

    +   tid 是否有效？

1.  将发送方的状态更改为 RECEIVE_BLOCKED

1.  将发送者放在接收者的 sendQ 的末尾

1.  如果接收方是 SEND_BLOCKED，请参考#3 in Receive。

* * *

### int 接收( Tid *tid, char *message, int msglen )

这些都很容易理解，除了

1.  任务 ID 是如何从内核复制到接收者的？

    +   也就是说，指针指向哪里？

1.  如果缓冲区不够大怎么办？

1.  如果有几个任务都执行了`Send`，哪一个会先被`Receive`？

1.  返回值是消息中的字节数，包括终端字符（\000），如果消息实际上是一个字符串。

    +   看起来返回值应该是 tid。有些不对劲。

1.  如果出现问题，返回值为负数，编码以指示出了什么问题

    会出什么问题？

    1.  只有消息的一部分被复制

    通过查看其返回值，`Receive`负责检查消息缓冲区是否足够大

##### 实现接收

内核必须做什么

1.  检查参数

1.  将接收者的状态更改为 SEND_BLOCKED

1.  检查`sendQ`

1.  如果 sendQ 为空

    1.  退出内核后进行调度

    sendQ 不为空

    1.  提取发送队列的头部，称为下面的发送者

    1.  将消息从发送者复制到接收者，检查缓冲区大小

    1.  将发送者的状态更改为 REPLY_BLOCKED

    1.  将接收者的状态更改为 READY

    1.  将发送者的 tid 放入接收者的参数中

    1.  将接收者放入其`readyQ`

    1.  设置接收者的返回值

    1.  退出内核后进行调度

* * *

### int Reply( Tid tid, char *reply, int rplen )

这些都很容易理解，除了

1.  回复者不必是接收者，但必须与接收者联系

    +   为什么？

1.  当一切顺利时，Reply 在完成后会使两��任务保持 READY 状态

##### 实现回复

1.  检查参数

    +   发送者（tid）必须是 REPLY_BLOCKED 状态

1.  将消息从回复者复制到发送者，检查缓冲区大小

1.  设置发送者的返回值

1.  将发送者的状态更改为 READY

1.  将发送者放入 readyQ

1.  设置回复者的返回值

1.  将回复者的状态更改为 READY

1.  将回复者放入 readyQ

1.  退出内核后进行调度

* * *

## 服务器

##### 什么是服务器？

+   为客户端任务提供服务的任务

    +   请求服务的任务，客户端，必须知道服务器的 Tid

+   拥有资源并提供同步访问的任务。

+   上面，

    +   `a task'拥有该接口

    +   其他任务可能会执行这项工作

##### 服务器是如何实现的？

+   接收是关键

    +   接收请求

    +   回复响应

+   发送者（客户端，发出请求的任务）在响应可用之前会被阻塞。也就是说，在请求和响应之间，发送者实际上以服务器的优先级运行

    +   服务器优先级应根据其提供的服务的重要性进行设置。

    +   但服务器应考虑客户端的优先级。例如，

        +   为优先级较高的客户端提供一组指令

        +   为优先级较低的客户端提供一组指令

* * *

## 名称服务器

什么是名称服务器？

+   存在一组全局的与执行无关的名称

+   存在一组与名称相关联的执行相关任务

+   名称服务器维护一个将名称映射到资源的最新表

    +   接受更新表的请求

    +   接受有关表的查询

### 为什么我们需要名称服务器

| 名称 | 在应用程序和执行过程中保持不变 | 接口 | 与一组服务（一个 API）相关联 |
| --- | --- | --- | --- |
| 任务 ID | 在应用程序和执行过程中变化 | 实现 | 与特定一组指令和数据（一个执行）相关联 |

### 如何获取名称服务器的任务 ID？

1.  使其在每次执行中保持不变

### 名称服务器 API

```
int RegisterAs( char *name );
```

+   一个任务可以注册两个名称。

+   每个名称与单个任务关联。

+   名称以`\000`结尾。

```
int WhoIs( char *name );
```

+   名称以`\000`结尾。

### 名称服务器语义

##### RegisterAs

+   错误

    1.  不是合法的名称。

        +   决定什么是合法名称由你决定

    1.  tid 不是一个任务

    1.  tid 不是名称服务器

    1.  已经有人注册了那个名称

        +   调用者做什么？

##### WhoIs

+   错误

    1.  不是法定名称。

    1.  tid 不是一个任务

    1.  tid 不是名称服务器

    1.  没有注册在那个名称下的任务

        +   调用者做什么？

##### 注释

+   `RegisterAs`会覆盖。

+   为什么？规则是名称->任务映射是多对一的。

    +   一个任务可能有很多名称

    +   一个名称可能只有一个任务

### 名称服务器实现

#### 用户代码

例如，`RegisterAs`

```
typedef struct {
    int type;
    char name[MaxNameSize];
    int tid;
} NSstruct;
int RegisterAs( char *name ) {
    NSstruct *req, *result;
    bytes = Send( NSTid, (char *) req, sizeof(NSstruct), (char *) result, sizeof(NSstruct) );
    if ( bytes != sizeof(NSstruct) ) {
        // Do something error-like
    } else return 0;
}
```

有很多可能的变体。

#### 服务器代码

```
typedef struct {
    int type;
    char name[MaxNameSize];
    int tid;
} NSstruct;

NSstruct req;
// initialize tables
FOREVER {
    bytes = Receive( &tid, &req, sizeof(NSstruct) );
    if ( detectError( ... ) ) {
        // Reply with error
    } else {
        switch( req.type ) {
        case REGISTERAS:
            insert( req.name, tid );
            Reply( tid, SUCCESS, sizeof(NSstruct) );
            break;
        case WHOIS:
            result.tid = lookup( name );
            Reply( tid, result, sizeof(NSstruct) );
            break;
        default:  // This should never happen
            Reply( tid, ERROR, sizeof(int) );
            break;
        }
    }
}
```

##### 注释

1.  这段代码会运行多少次？

    +   它何时运行？

1.  你会如何实现插入和查找？

    +   搞清楚

        1.  名字服务器有哪些截止日期？

        1.  NameServer 中会有多少个名称？

        1.  有多少个 RegisterAs？何时？

        1.  有多少个 WhoIs？何时？

    +   作为名称应该被允许什么？

* * *

返回至：

+   比尔·考恩在 s12 为 CS452 的讲座笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的主页
