# 第 2 讲 - 轮询循环

### 公共服务公告

1.  作业 0 的截止日期

1.  Ubuntu 10.10

1.  如何编译和运行您的第一个程序

1.  缓存，优化，时钟速度，FIFO

1.  库：特别是 memcpy

* * *

### 实际细节：pdf

### 什么是实时编程？

实际世界编程，这意味着

+   世界以秒、米等来衡量。

+   程序操作位、字节、字，必须转换为现实世界的度量。

    例如，

    +   格式化输出：从计算机操作的 int 翻译成人类阅读的十进制

        +   在公开场合：i2a( )，printf( )

        +   隐藏：print，cout

    +   银行：int 翻译成，例如，分的数量

        +   程序说 dispense(10000)，意思是`将五张二十元纸币放入投币口'。

        +   微控制器启动

            +   激活电机

            +   感知力量

            +   读取数字化视频

            +   等等。

    +   火车控制：消息内容，有时间接地，映射到火车速度变化，状态变化（转辙，火车位置），传感器报告。

### 对于实时系统来说什么是重要的？

1.  吞吐量

    +   例如，游戏中每秒帧数

    +   例如，过程控制中传感器采样的频率

    +   除了没有解决方案

        1.  获取更好的硬件

        1.  获取更好的算法

        1.  重组任务

1.  响应时间

    +   例如，游戏中从按键按下到枪发射的时间

    +   例如，传感器读数到过程控制中控制代码执行的时间

    +   存在几种编程技术

        1.  忙等待

        1.  轮询循环

        灵活性和性能之间的张力

在 cs452 中，我们将有保证的响应时间作为实时计算的定义质量。

* * *

### 计时器

如何在计算机中计时？

+   相位锁定环中的晶体振荡器

+   来自定时器的中断

+   ntp

## 轮询循环

### 忙等待

这用于与外部事件同步，最小化响应时间。

```
#define FOREVER for( ; ; )
FOREVER {
   while( !ready( ) ) ;
   do-it( );
}
```

或以另一种形式

```
FOREVER {
   if ( ready( ) ) do-it( );
}
```

有时您只想做一次事情，就像在串行线上放置字符时一样。

```
#define UART1_BASE        0x808c0000
#define UART_DATA_OFFSET        0x00    // low 8 bits
#define UART_FLAG_OFFSET        0x18    // low 8 bits
#define TXFF_MASK               0x20    // Transmit buffer full

        flags = (int *)( UART1_BASE + UART_FLAG_OFFSET );
        data = (int *)( UART1_BASE + UART_DATA_OFFSET );
        while( ( *flags & TXFF_MASK ) ) ;
        *data = c;
```

**注意**。`volatile`关键字。

##### 最坏情况响应时间

从准备位设置的时间到执行 do-it 的第一条指令

+   执行时间为

    ```
    while( !ready ) ;
    do-it;
    ```

+   即使是中度优化的编译器也会生成良好的机器代码。类似于

    ```
    ready:
      ldb  r0, STATUS-ADDRESS
      and  r0, r0, READY-BIT
      beq  _ready
    do-it:
      ldb r0, DATA-ADDRESS

    ```

    这里的 do-it 正在从接口硬件中获取一个字节，当状态寄存器指示数据寄存器中有有效数据时。

+   最坏情况响应时间是执行`and`，`beq`，`ldb`，`and`和`beq`

+   通常这样的代码会在循环内部，一个接一个地获取字节，直到没有更多可用为止。

##### 忙等待的问题

如果 CPU 必须同时做两件事怎么办？

例如，

1.  收集串口传入的字节

1.  维护时钟

除非字节传入速率和时钟滴答速率相同

+   您肯定会迟早失去某些东西。

### 轮询循环

轮询循环允许您同时管理多个条件/活动对。

基本轮询循环

```
FOREVER {
  if( c1 ) a1;
  if( c2 ) a2;
  ...
  if( cN ) aN;
}
```

##### 最坏情况响应时间

+   对于 {执行时间为`if( c<n>`的时间 + 执行时间为`a<n>`的时间} 求和

##### 你放入动作中的内容非常重要。

假设你将忙等待 I/O 放入了列车控制器中的一个动作。

你会在测试中捕捉到它吗？

+   可能不是。

##### 多次测试

假设你想要 a1 的更好的响应时间。然后尝试循环。

```
FOREVER {
  if( c1 ) a1;
  if( c2 ) a2;
  if( c1 ) a1;
  if( c3 ) a3;
  ...
  if( c1 ) a1;
  if( cN ) aN;
}
```

`a1`的最坏情况响应时间

+   `if( c1 )`的执行时间 + `if( cn ) an`的最大值

##### 分解成片段

假设响应时间仍然太长，因为某个动作的执行，比如 a2，太长了。那么你可以将 a2 分成两部分。

```
FOREVER {
  if( c1 ) a1;
  if( c2 ) { a2.1; half-done = TRUE; }
  if( c1 ) a1;
  if( half-done ) { a2.2; half-done = FALSE; }
  ...
}
```

这开始变得有点复杂，而且我们还没有讨论互动通信的任何内容。

* * *

返回到：

+   Bill Cowan 在 s12 学期的 CS452 讲义笔记

+   Bill Cowan 的 2012 年春季 CS452 页面

+   Bill Cowan 的 CS452 页面

+   Bill Cowan 的教学页面

+   Bill Cowan 的个人主页
