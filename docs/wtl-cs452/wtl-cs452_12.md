# 第 12 讲 - 硬件中断

### 公共服务公告

1.  星期三的课程

    +   你需要吗？

1.  作业 3

* * *

## 硬件中断

### 什么是硬件中断？

### 中断的上下文切换

##### 与软件中断的区别

不可能预测它们发生的位置

+   你可能对它们何时发生做出了一些假设

##### 用户任务和内核之间的不对称性

必须保存 Scratch 寄存器

+   为用户任务启用，而不是为内核

+   包括 IP

##### ICU 的有用特性

1.  几个可以读取状态的地方

1.  几个可以阻止中断流的地方

1.  从软件触发硬件中断

    +   中断的难点在于你同时在做两件半难的事情

        1.  使硬件产生中断

        1.  响应中断

    +   这使得你可以在开发/调试中将它们分开

* * *

### 实验室中的硬件

### 32 位定时器

### 中断控制单元（ICU）

实际设备是 ARM PL190

##### 硬件定义

**基本操作寄存器**

| 寄存器名称 | 偏移 | 读/写 | 描述 |
| --- | --- | --- | --- |
| VICxIRQStatus | 0x00 | 只读 | 每个中断源的一位，如果中断被触发且启用则为 1 |
| VICxFIQStatus | 0x04 | 只读 | 与 FIQ 相同 |
| VICxRawIntr | 0x08 | 只读 | 与上述相同但未屏蔽 |
| VICxIntSelect | 0x0c | 读/写 | 0: IRQ, 1: FIQ |
| VICxIntEnable | 0x10 | 读/写 | 0: 屏蔽，1: 启用 |
| VICxIntEnClear | 0x14 | 写入 | 清除 VICxIntEnable 中的位 |
| VICxSoftInt | 0x18 | 读/写 | 从软件中断中断 |
| VICxSoftIntClear | 0x1c | 写入 | 清除来自软件的中断 |
| VICxProtection | 0x20 | 读/写 | 位 0 启用用户模式访问保护 |
| VICxVectAddr | 0x30 | 读/写 | 启用优先级硬件请参阅文档。 |

##### ICU 的有用特性

1.  几个可以读取状态的地方

1.  几个可以阻止中断流的地方

1.  从软件触发硬件中断一次

    1.  中断的难点在于你同时在做两件半难的事情

        +   使硬件产生中断

        +   响应中断

    1.  软件中断生成允许你在开发/调试中将它们分开

* * *

#### 非向量操作

##### 初始化

1.  在设备中启用中断

    +   有时会出现虚假中断，有时则不会。

1.  在 ICU 中启用中断

1.  在 CPU 中启用中断，通常通过 MOVS

##### 中断发生

1.  在每次指令获取之前检查 IRQ 和 NOT（禁用 IRQ）的 AND。

1.  如果设置 IRQ 异常，则在下一条指令获取的位置发生 IRQ 异常。

    +   可能会执行零条活动任务的指令。

    +   确保这种情况有效

1.  切换到内核的上下文

    * * *

    ##### 上下文切换的新奇之处

    与软件中断的区别

    +   不可能预测它们发生的位置

    +   你可能无意中对它们何时发生做出了一些假设

    +   必须保存 Scratch 寄存器

        +   r0-3

        +   IP -- 仅由 gcc 非常偶尔使用

    +   你如何区分 IRQ 和 SWI？

    +   两个链接寄存器

        +   从中断返回

        +   从被中断的任务返回到调用它的地方

    * * *

1.  定位中断源

1.  收集易失性数据

1.  在设备中关闭中断

    +   ICU 中会自动关闭

1.  在设备中关闭中断

    +   应该在 ICU 中关闭中断

    +   IRQ 怎么办？

现在你已经准备好在内核中处理中断了

* * *

#### 向量操作

##### 总体思路

编程 ICU 的标准方式要求内核查询 ICU。有时候（！），这是不可接受的低效率。然后，您有另一种选择，即向量中断。

相关寄存器：

1.  你需要写入 16 对

    | 寄存器名称 | 偏移 | R/W | 描述 | 注释 |
    | --- | --- | --- | --- | --- |
    | VICxVectAddry | 0x100+4y | R/W | 中断 y 的向量地址 | 中断 y 的 ISR 入口点 |
    | VICxVectCntly | 0x200+4y | R/W | 中断 y 的控制寄存器 | 位[0-4]：中断 y 的中断源 位[5]：使能向量中断 y |

1.  该程序使用了一对

    | 寄存器名称 | 偏移 | R/W | 描述 |
    | --- | --- | --- | --- |
    | VICxVectAddr | 0x030 | R/W | 读取：最高优先级中断的向量地址写入：服务完成，启用优先级硬件 |
    | VICxDefVectAddr | 0x034 | R/W | 默认向量地址 |

    +   第一个是最高优先级中断的地址（ISR 入口点）。在中断处理期间写入它以获取当前的最高优先级中断。

    +   第二个通常是 0x34，内核的入口点。

##### 过程

初始化

1.  将内核入口点写入 VICxDefVectAddr

1.  如果需要，在 VICxVectAddry 中写入特殊入口点

1.  准备好接受中断后，将源和使能写入 VICxVectCntly

当中断发生时

1.  读取 VICxVectAddr 以查找地址

1.  将结果移动到 PC

    ```
        ldr   pc, #<VicVectAddr>
    ```

    （请注意，这与 0x014 中的指令类似。我们能否一次完成所有操作？）

1.  在重新启用中断之前，将 VICxVectAddr 写入以启动优先级硬件

##### 回答问题。

仔细查看 0x18 中的内容

+   通常是 `ldr pc, [pc, #offset]`

    你能让 [pc, #offset] 计算 `<VicVectAddr>` 吗？

+   指令是如何编码的

    +   31:28 - 条件代码

    +   27:20 - 操作码和标志，0101<偏移符号>001

    +   19:16 - 基寄存器

    +   15:12 - 目标寄存器

    +   11:00 - 12 位偏移

+   使用 12 位偏移和 pc=0x18，你可以寻址到

    +   从 `0x18 + 0x8 - 0xffc = -0xfdc =``0xfffff020`

    +   到 `0x18 + 0x8 + 0xffc = 0x1020`

+   你可以将内核入口点放在

    +   或者 `0x800b0030`

    +   或者 `0x800c0030`

+   两者都超出范围。你可以怎么做？

    +   通过将 ICU 放置在例如 `0xfffff000` 的范围内将 ICU 映射到该范围。

* * *

## 时钟服务器、任务结构

#### 一个新的内核原语：int AwaitEvent( int EventType )

### 如何使用 AwaitEvent？

1.  对于每种中断类型，几乎总是应该有一个任务被阻塞在 AwaitEvent 上。为什么？

1.  服务器不能调用 AwaitEvent。为什么？

1.  我们称调用 AwaitEvent 的任务为通知器。为什么？

1.  典型通知器的代码

    ```
    main( ) {
        Tid server;
        int evtType, data;
        Receive( &server, &evtType, ... );
        // Other initialization
        Reply( server, ... );
        FOREVER {
            data = AwaitEvent( evtType );
            Send( server, &data, ... );
        }
    }
    ```

1.  典型服务器的代码

    ```
    main( ) {
        notifier = Create( HIGHEST, ... );
        // other initialization
        Send( notifier, &evtType, ... );
        FOREVER {
            Receive( &requester, &request, ... );
            switch ( request.type ) {
            case NOTIFIER:
                Reply( notifier );
                data = request.data;
                break;
            case CLIENT:
                ...
            }
        }
    }
    ```

### 更多关于 AwaitEvent 的内容

#### 参数

1.  某处有一个事件类型列表

    +   应用程序员知道列表

    +   内核可以响应列表中的每种事件类型

1.  这不太便携

    +   列表通常是所有硬件上发生的所有类型的并集

    +   这是 Windows 的问题

#### 内核中的处理

+   初始化

    1.  内核初始化时 IRQ 被屏蔽

    1.  内核初始化 ICU

    1.  对每个设备

        1.  内核初始化硬件

        1.  内核在设备中打开中断

    1.  内核启动第一个用户任务

    1.  最终，通知器被创建

    1.  通知器

        1.  初始化设备

        1.  在设备中打开中断

        1.  在 ICU 中打开中断

        1.  调用 AwaitEvent

+   过程

    1.  内核

        1.  识别中断源

        1.  识别正确的通知器

        1.  获取易失性数据

        1.  在设备中重新启用中断

        1.  在 ICU 中重新启用中断

        1.  在任务激活期间重新启用 CPU 中的中断（例如，`movs`）

        1.  将易失性数据放入 AwaitEvent 的返回值

        1.  使通知器准备就绪

    1.  通知器

        1.  收集和打包数据

        1.  发送到服务器

    1.  最终服务器

        1.  回复通知器

+   优点

    +   清洁一致的用户代码

+   缺点

    +   内核必须对硬件有很多了解。

    +   硬件知识在通知器和内核之间分割

### HALT 与空闲任务

当没有任务运行时，你会怎么做？

+   空闲任务

    +   最低优先级

    +   诊断系统

    +   搜索 ETI

+   HALT

    +   关闭 CPU 时钟

    +   节省电源（电池）

    +   提供两种方式

        1.  通过系统控制协处理器

        1.  通过 TS-7200 时钟控制器

    +   IRQ 路径是异步的，因此在关闭时钟时可以工作

* * *

## 时钟服务器

### 原语

```
int Time( )
```

+   时钟服务器在初始化时从零开始

+   时间单位是 tick

```
int Delay( int ticks )
```

+   注意错误返回

+   你可能想为负参数添加一个错误

    +   计算 ticks 通常是，负值是落后的早期警告。

```
int DelayUntil( int ticks )
```

+   可以从上述两个基本元素构建。

### 实现

```
main( ) {
    notifier = Create( HIGHEST, ... );
    time = 0
    Send( notifier, &evtType, ... );
    FOREVER {
        Receive( &requester, &request, ... );
        switch ( request.type ) {
        case NOTIFIER:
            Reply( notifier, ... )
            time++;
            break;
        case TIME_REQUEST:
            Reply( requester, time,... )
            break;
        case DELAY_REQUEST: 
            Add requester to list of suspended tasks
            break;
        }
        Check list of suspended tasks and reply
    }
}
```

注释：

1.  你需要一个常见的请求类型，或者可能是一个联合体。

1.  你应该注意典型的服务器模式。

    +   通知器更新数据

    +   可以立即提供服务的客户端被服务

    +   未来需要服务的客户端被挂起

    +   挂起任务列表定期检查

对挂起任务列表进行排序是正常的。为什么呢？

* * *

返回至：

+   比尔·考恩 2012 年春季 CS452 课堂笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的主页
