# 第 11 讲 - 硬件中断

### 公共服务公告

1.  下周的课程

    +   从编程切换到监听的上下文切换

1.  作业 2

    +   截止日期

    +   性能：

        +   有一个计数周期的 40 位时钟

        +   尊重确切的 CPU 条件

        +   测量几次并取平均值

* * *

## 服务器

##### 什么是服务器？

+   为客户端任务提供服务的任务

    +   请求服务的任务，客户端，必须知道服务器的 Tid

+   拥有资源并提供同步访问的任务。

+   上面，

    +   `一个任务' 拥有接口

    +   其他任务可能会完成工作

##### 服务器是如何实现的？

+   接收是关键

    +   接收请求

    +   回复响应

+   发送方（客户端，发出请求的任务）会一直阻塞，直到响应可用。也就是说，在请求和响应之间，发送方实际上是以服务器的优先级运行的。

    +   服务器的优先级应根据其提供的服务的重要性来设置。

    +   但服务器应该考虑客户端的优先级。例如，

        +   为较高优先级客户端准备一组指令

        +   为较低优先级客户端准备一组指令

* * *

## 名称服务器

### 为什么我们需要一个名称服务器

| 名称 | 在应用程序和执行过程中保持不变 | 接口 | 与一组服务相关联（一个 API） |
| --- | --- | --- | --- |
| 任务 ID | 在应用程序和执行过程中变化 | 实现 | 与特定指令和数据集相关联（一个执行） |

可能每个任务有多个名称，但

+   不可能有多个任务使用同一个名称。

### 名称服务器实现

选择是阻塞还是回复。

* * *

## 硬件中断

### 什么是硬件中断？

##### 在 CPU 中

1.  在获取下一条指令之前测试中断信号

    +   实际上是 CPSR 中 INT 和 IRQ 位的 AND 运算

1.  如果断言，将模式更改为 IRQ

1.  在 CPSR 中禁用中断

1.  在地址 0x18 处执行指令

##### 在中断控制单元（ICU）中

+   当中断发生时，可能存在多个中断

    +   通过优先级机制选择一个

    +   放在一个特殊的位置

    +   软件可以选择忽略 ICU 中的优先级机制

+   清除一个中断可能只会暴露另一个中断

##### 在外围硬件中

+   当中断发生时可能存在多个中断

    +   在外围硬件中进行 OR 运算

    +   在粘合硬件中进行 OR 运算

    +   很少有优先级机制存在

+   清除一个中断可能会暴露另一个中断

##### 当存在两个中断时

当中断处理开始时可能存在两个

+   在这种情况下，现在发生的中断被认为是较低优先级的

可能在中断处理开始后发生

+   在这种情况下，现在发生的中断可能是较高优先级的

接下来会发生什么？

1.  内核在中断禁用的情况下执行

1.  切换到用户任务的上下文切换会打开中断

1.  在获取第一个用户任务指令之前测试中断信号

1.  如果断言，重新启动中断处理

* * *

### 用于中断的上下文切换

##### 与软件中断的区别

不可能预测它们发生的位置

+   你可能对它们何时发生有一些假设

##### 用户任务和内核之间的不对称性

必须保存 Scratch 寄存器

+   包括 IP

两个链接寄存器

1.  一个用于从中断返回

    +   在中断处理代码的寄存器中

    +   返回到正确位置的中断任务

1.  一个用于移动到调用者的堆栈帧

    +   在中断任务的寄存器中

    +   返回到中断任务中启动���任何内容

##### ICU 的有用功能

1.  几个地方可以读取状态

1.  几个地方可以阻止中断流

1.  从软件触发硬件中断

    +   中断难的地方在于您同时进行两个半难的事情

        1.  使硬件产生中断

        1.  响应中断

    +   这使您可以在开发/调试中将它们分开

* * *

### 列车实验室中的硬件

### 32 位定时器

基地址：`0x80810080`

三个寄存器：

| Offset | Function | R/W | Bits | Comments |
| --- | --- | --- | --- | --- |
| 0x0 | Timer3Load | R/W | 32: <Load/Reload Value> |  |
| 0x4 | Timer3Value | R | 32:<当前值> | 在写入 Load 时设置，即使在计数时也是如此 |

| 0x8 | Timer3Control | R/W | 3:xxx<CLKSEL>xx<MODE><ENABLE> | <CLKSEL>: 0，2KHz 时钟；1，508KHz <MODE>: 1，连续计数；0，仅计数一次

<ENABLE>: 时钟打开

|

| 0xc | Timer3Clear | W | 32: | 写入任何内容都会清除中断 |
| --- | --- | --- | --- | --- |

### 中断控制单元（ICU）

实际设备是 ARM PL190

此设计中的逻辑完全异步，因此在关闭 CPU 时它可以正常工作。

+   对低功耗操作至关重要。

所有输入信号都是

+   高电平

+   电平敏感

基地址

+   VIC1：`0x800B0000`

+   VIC2：`0``x800C0000`

#### 基本操作

VIC 上电

+   所有向量中断已禁用。

+   所有中断屏蔽

+   所有中断都给予 IRQ

##### 过程

初始化

1.  保持保护关闭

1.  当准备处理中断时，在 VICxIntEnable 中启用

在中断时

1.  读取 VICxIRQStatus

1.  选择要处理的中断

1.  清除设备中的中断源

用于调试

1.  使用 VICxSoftInt 和 VICxSoftIntClear 在软件中关闭和打开中断源

##### 硬件定义

**基本操作寄存器**

| 寄存器名称 | 偏移 | R/W | 描述 |
| --- | --- | --- | --- |
| VICxIRQStatus | 0x00 | RO | 每个中断源的一位，如果中断被断言并启用则为 1 |
| VICxFIQStatus | 0x04 | RO | 与 FIQ 相同 |
| VICxRawIntr | 0x08 | RO | 与上述相同但未屏蔽 |
| VICxIntSelect | 0x0c | R/W | 0：IRQ，1：FIQ |
| VICxIntEnable | 0x10 | R/W | 0：屏蔽，1：启用 |
| VICxIntEnClear | 0x14 | WO | 清除 VICxIntEnable 中的位 |
| VICxSoftInt | 0x18 | R/W | 从软件断言中断 |
| VICxSoftIntClear | 0x1c | WO | 清除软件中的中断 |
| VICxProtection | 0x20 | R/W | 位 0 启用用户模式访问保护 |
| VICxVectAddr | 0x30 | R/W | 启用优先级硬件请参阅文档。 |

##### ICU 的有用功能

1.  几个地方可以读取状态

1.  几个地方可以阻止中断流

1.  从软件触发硬件中断一次

    1.  中断难的地方在于您同时进行两个半难的事情

        +   使硬件产生中断

        +   响应中断

    1.  软件中断生成允许您在开发/调试中将它们分开

* * *

#### 非向量操作

##### 初始化

1.  在设备中启用中断

1.  在 ICU 中启用中断

1.  在 CPU 中启用中断，通常通过 MOVS

##### 中断发生

1.  在每次指令获取之前检查 IRQ 和 NOT（禁用 IRQ）的 AND。

1.  如果设置 IRQ 异常，则在下一条指令获取的位置执行

    +   可能会执行零条活动任务指令。

    +   确保这种情况能够运行

1.  切换到内核上下文

    * * *

    ##### 上下文切换的新奇之处

    与软件中断的区别

    +   不可能预测它们发生的位置

    +   你可能会误以为它们发生的时间

    +   必须保存 Scratch 寄存器

        +   r0-3

        +   IP -- 由 gcc 极少使用

    +   两个链接寄存器

        +   从中断返回的一个

        +   从被中断的任务返回到调用它的位置

    * * *

1.  关闭设备中的中断

    +   应该关闭 ICU 中的中断

    +   IRQ 是什么？

现在你已经准备好在内核中处理中断

#### 向量操作

##### 过程

初始化

1.  将内核入口点写入 VICxDefVectAddr

1.  如果需要，将特殊入口点写入 VICxVectAddry

1.  当准备接受中断时，将源和使能写入 VICxVectCntl

当中断发生时

1.  读取 VICxVectAddr 以找到地址

1.  将结果移动到 PC

1.  当服务完成时，将 VICxVectAddr 写入重新运行优先级硬件

| 寄存器名称 | 偏移 | 读/写 | 描述 |
| --- | --- | --- | --- |
| VICxVectAddr | 0x030 | 读/写 | 读取：最高优先级中断的向量地址写入：服务完成，启用优先级硬件 |
| VICxDefVectAddr | 0x034 | 读/写 | 默认向量地址 |
| VICxVectAddry | 0x100+4y | 读/写 | 中断 y 的向量地址 |
| VICxVectCntly | 0x200+4y | 读/写 | 中断 y 的控制寄存器位[0-4]：中断 y 的中断源位[5]：启用向量中断 y |

* * *

返回到：

+   比尔·考恩在 s12 学期的 CS452 讲座笔记

+   比尔·考恩 2012 年春季 CS452 页面

+   比尔·考恩的 CS452 页面

+   比尔·考恩的教学页面

+   比尔·考恩的个人主页
