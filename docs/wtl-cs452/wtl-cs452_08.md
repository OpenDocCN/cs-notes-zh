# 第 8 讲 - 创建，初始化

### 公共服务公告

1.  作业 1 的截止日期

1.  维多利亚日假期

* * *

## 初始化内核

#### 设置硬件

1.  繁忙等待 io

1.  低内存

    +   内核入口在哪里？

1.  在 ICU 中关闭中断

    +   这应该是不必要的，但如果之前的内核打开了它们呢？

    +   以后你会以不同的方式初始化 ICU。

#### 准备内核数据结构

内核的堆栈指针现在在哪里？堆栈是什么样子的？

+   你想把它放在那里吗？你宁愿把它放在别的地方吗？

+   这是你最后一次改变它的机会。（如果你决定改变它，你可能想保留你要替换的东西。为什么？）

内核数据结构

1.  一个空的就绪队列数组

1.  活动任务的 TD 的指针

1.  一个 TD 数组

1.  一个指向空闲 TD 的指针的空闲列表

#### 准备任务使用的内存

1.  任务内存

#### 创建第一个用户任务

现在可以在关闭中断的情况下运行（保险起见），但以后需要打开。

提醒。内核开始执行的地方具有全局名称 main，不能重新使用。

* * *

## 创建一个任务

在创建任务时，你必须做两件事

1.  获取并初始化任务所需的资源

    +   TD

    +   内存

1.  使任务看起来好像刚进入内核

    +   当计划好时，它就准备好执行了

#### 你需要做的事情

##### 分配资源

获取一个未使用的 TD 和未使用的内存用于其堆栈

+   实际上是一种常数时间内存分配

##### 初始化资源

主要是填写 TD 中的字段。这些应该在 TD 中的字段在这里。

1.  任务 ID

1.  优先级

1.  堆栈指针

1.  父任务 ID

    +   活动任务

1.  状态

    +   就绪

1.  安装在就绪队列中

    +   TD 中的指针

这看起来像是六个词，可以压缩成更少的词。（稍后会有更多。）

+   如果你在考虑缓存，如何使任务描述符数组对齐缓存。

这些可能在 TD 中，也可能在堆栈中。

1.  SPSR

1.  链接寄存器

1.  返回值

##### 初始化堆栈

+   就好像任务刚刚执行了内核入口一样

+   仔细看看你的内核退出代码会做什么

+   最后堆栈指针必须对应堆栈内容

+   我将堆栈指针初始化为分配内存的顶部

    +   我的堆栈向下增长

    然后随着我将东西推到堆栈上而改变它

    +   模拟上下文切换代码

这是我总是做的事情。

+   将独特的值放入寄存器中，如 00000000，11111111，22222222 等。

+   这使得解决指针不对齐问题更容易

* * *

### 创建函数

你还需要一个`int Create( int priority, void (*code) ( ) )`函数供用户任务调用。

尽管它不过是一个包装器，但有一些问题需要解决。

1.  传递参数

    +   进入时，参数通常在某处，通常是 r0 和 r1。

    +   你必须把它们放在内核能找到的地方。

    +   gcc 的函数入口代码立即将它们放在堆栈上。

    +   在汇编中，你可以使用帧指针找到它们。

1.  跳入内核

1.  从内核获取返回值并返回它。

    +   你可以在内核放置的地方找到它

    +   gcc 的函数退出代码期望它从帧指针索引

        +   从那里进入 r0

* * *

### 其他原语

这些原语主要存在是为了我们，也包括你，可以确保任务创建和调度在没有太多其他实现时正常工作。

##### `Tid MyTid( )`

自解释

+   不会阻塞，但会重新调度。

一个问题，有一个正确答案，或更具体地说，一个正确的（答案，原因）对。

+   Tid 是否应存储在用户空间？

##### `Tid MyParentTid( )`

自解释

+   不会阻塞，但会重新调度。

父 Tid 在哪里，内核如何找到它？

##### `void Pass( )`

不会阻塞：调用`Pass( )`的任务仍然准备执行。

重新调度。

`Pass( )`何时是`NOP`？

##### `void Exit( )`

调用任务从所有队列中移除，但其资源不会被回收或重用。

也就是说，任务进入僵尸状态，无法处于活动或准备就绪状态，但仍然拥有所有资源。

### 执行应该如何终止？

很好。

当准备队列中没有剩余任务时，它会返回到 RedBoot。

+   当硬件中断实现时，此行为会发生变化。

* * *

返回到：

+   比尔·考恩（Bill Cowan）在 s12 为 CS452 的讲座笔记

+   比尔·考恩（Bill Cowan）2012 年春季 CS452 页面

+   比尔·考恩（Bill Cowan）的 CS452 页面

+   比尔·考恩（Bill Cowan）的教学页面

+   比尔·考恩（Bill Cowan）的主页
