# 第 4 讲 - 任务与内核

### 公共服务公告

1.  作业 0 的截止日期

1.  课程账户需要一些清理，课程介绍已清理完成。

1.  RTS/CTS

    +   当列车控制器的 UART 准备好接收字节时，它会断言 RTS。

    +   RTS 连接到 ARM UART 的 CTS 位。

    +   检查调制解调器状态寄存器

    +   仅在 CTS 被断言时才向列车控制器发送字节

    +   当 CTS 被否定时，你**不**发送。

1.  新闻组：`uw.cs.cs452`。

1.  课程邮箱账号：`cs452@cgl.uwaterloo.ca`

1.  预期作业 0 的文档

1.  合作伙伴

* * *

## 实时操作系统的内核

### 介绍

轮询循环的基本单位是

+   ```
    if ( condition ) action;
    ```

将`action`视为任务的执行，例如洗碗。将`condition`视为来自外部的信号，告诉你是时候执行任务了。

动作并不是彼此独立的：洗碗需要热水、洗洁精等，这些由其他动作提供。需要进行通信。

因此，任务需要一些支持。

+   执行指令的能力

    +   带有指向其中的 PC 的代码

    +   状态，以内存形式

+   互相通信的能力

    +   传递数据

    +   同步

+   从现实世界接收信息的能力

    +   提供数据

    +   可能仅仅是同步

这些基本需求由操作系统的内核提供。我们在 cs452 中创建的内核是微内核，因为它提供了这些功能，而没有其他功能。

我们将微内核分为四个作业来构建

1.  任务创建和调度

1.  任务间通信

1.  一个中断原语

1.  复杂的服务器

* * *

### [微内核](http://en.wikipedia.org/wiki/Microkernel)

我们构建的实时操作系统由

1.  一个不可中断的微内核，加上

1.  可中断的设备处理服务器任务在用户空间中运行，并具有允许它们访问硬件的权限。

### 微内核提供了什么？

##### 任务

+   程序被构想为一组协作的任务

+   提供应用程序与模块化。在你完成操作系统的时候，讨论了任务结构作为程序组织的一种方法。

+   由...组成

    +   对于同一种任务的所有任务，都有一些指令是通用的，

    +   全局**常量**，比如用于格式化消息的字符串，以及

    +   本地状态，相同类型的不同任务在不同任务中具有不同状态，每个任务实例都需要一个单独的内存块。

+   任务如何协同工作

    +   同步

    +   通信

    +   结合成一个机制：消息传递

+   为什么任务很重要？

    +   一次只考虑一件事情很容易。

        +   想想毕业后你期望有的选择。

    +   同时考虑多件事情是困难的。

        +   继续思考，同时听我谈论任务

        +   括号里的备注。当你走路时可能在和某人交谈，或者思考着某件事情。你做这两件事都很轻松。为什么？

    +   实时地同时考虑多件事情非常困难

        +   -   想想在学习骑自行车时如何转动方向盘、蹬踏和保持平衡

        +   -   你是如何学会在实时中协调所有这些活动的？

    +   -   任务允许程序员将活动的每个组件转换为一组顺序的指令，其中包括与其他任务通信。

##### -   通信

-   通信有两个方面

1.  -   共享信息，请求服务

1.  -   同步

-   我们使用发送/接收/回复（SRR）来执行这两个任务。

1.  -   发送块

1.  -   接收块：与调用发送同步

1.  -   回复不阻塞：与从发送返回同步

##### -   同步

1.  -   在任务之间

    +   -   协作任务的执行协调

    +   -   使用 SRR

1.  -   使用内部事件

    +   -   通过与实时时钟同步来实现实时性：例如时钟服务器

    +   -   执行顺序：例如名字服务器，有界缓冲区

    +   -   使用 SRR

1.  -   与外部事件

    +   -   中断

##### -   中断

-   外部世界的输入

1.  -   提供你所轮询的信息

1.  -   ISR 操作系统设计，本质上是一个跳转表，它将测试与操作分开

    ```
    interrupt entry point:
        calculate action_entry_point;
        jump to act_entry_point;
    entry_point1:
        action1;
    entry_point2:
        action2;
    ...
    entry_pointn:
        actionn;
    ```

    -   这些是你在轮询循环中实现的相同操作，

    +   -   他们都有相同的问题。

    +   -   值得思考的事情

        +   -   轮询循环是单线程的

            +   -   当你收到信号开始另一个计算时，你保证不会处于计算的中间状态。

            +   -   ISR 不一定是单线程的

            +   -   在执行过程中关闭中断，可以通过关闭中断来重新获取轮询循环。

        +   -   ISR 之间没有重要性层次结构

            +   -   轮询循环的层次结构在轮询结构中

            +   -   选择性中断屏蔽可以重现层次结构，

            +   -   但是你必须保存状态

-   * * *

### -   任务

-   什么是任务？

1.  -   一组指令

1.  -   当前状态，通过执行指令来改变，其中包括

    +   -   其变量的值，这些变量是在堆栈上维护的自动变量

    +   -   寄存器的内容

    +   -   其他处理器状态，如 PSR

        +   -   处理器模式

        +   -   条件码

        +   -   等等。

    +   -   其运行状态和内核维护的其他信息

-   两个任务可以使用相同的一组指令，但是

+   -   每个任务都有自己的状态

+   -   因此，没有静态变量

-   内核跟踪每个任务的状态

+   -   本质上，服务请求就是改变一个或多个任务的状态。

+   -   内核为每个创建的任务维护一个任务描述符（TD）。

+   -   也就是说，要创建一个任务，内核必须分配一个 TD 并对其进行初始化。

-   TD 通常包含

1.  -   任务的堆栈指针，指向任务内存中包含的私有堆栈，其中包含

    +   -   PC

    +   -   其他寄存器

    +   -   局部变量

    -   所有准备好在下次运行任务时重新加载。

1.  -   下一次激活任务时可能的返回值

1.  -   任务的父任务

1.  -   任务的状态

1.  -   任务所在队列的链接

    +   -   内核使用这些来在服务请求时找到任务

-   任务的可能状态

1.  -   活动：正在运行或即将运行

    +   -   在单处理器系统上，只能有一个任务处于活动状态。

    +   -   但是我们希望能够平滑地推广到多个处理器。

1.  -   准备就绪：如果被调度可以运行

    +   需要一个队列，由调度程序使用，以决定下一个活动任务是哪一个

1.  阻塞：等待某些事情发生

    +   需要几个队列，每个可能发生的事情一个

* * *

### 内核结构

内核只是像任何其他函数一样，但是永远运行。

```
kernel( ) {
  initialize( );  // includes starting the first user task
  FOREVER {
    request = getNextRequest( );
    handle( request );
  }
}
```

操作系统在哪里？

+   请求来自正在运行的用户任务

    +   本质上是系统调用

+   一种请求类型创建一个任务

    +   需要一个启动所有任务的第一个任务

* * *

内核内部完成的所有有趣的事情都隐藏在`getNextRequest`内。

```
int getNextRequest( ) {
  return activate( schedule( ) ); //the active task doesn't change
}
```

`activate( active )`内部有什么？

1.  控制转移到活动任务

1.  执行活动任务直到完成

    +   `to completion' 意味着直到活动任务向内核发送请求

1.  控制转移到内核的返回

1.  获取请求

正确执行的难点是`transfer of control'

+   我们称之为上下文切换

* * *

返回：

+   比尔·考温 s12 的 CS452 讲座笔记

+   比尔·考温 2012 年春季 CS452 页面

+   比尔·考温的 CS452 页面

+   比尔·考温的教学页面

+   比尔·考温的主页
