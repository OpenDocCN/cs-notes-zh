# 第 13 讲 - 硬件中断

### 公共服务公告

1.  作业 3

* * *

## 硬件中断

#### 向量操作

##### 总体思路

编程 ICU 的标准方式要求内核查询 ICU。有时（！），这是不可接受的低效率。然后，你有另一种选择，即向量中断。

相关寄存器：

1.  有 16 对你要写的

    | 寄存器名称 | 偏移 | R/W | 描述 | 注释 |
    | --- | --- | --- | --- | --- |
    | VICxVectAddry | 0x100+4y | R/W | 中断 y 的向量地址 | 中断 y 的 ISR 入口点 |
    | VICxVectCntly | 0x200+4y | R/W | 中断 y 的控制寄存器 | 位[0-4]：中断 y 的中断源 位[5]：启用向量中断 y |

1.  程序使用了一对

    | 寄存器名称 | 偏移 | R/W | 描述 |
    | --- | --- | --- | --- |
    | VICxVectAddr | 0x030 | R/W | 读取：最高优先级中断的向量地址写入：服务完成，启用优先级硬件 |
    | VICxDefVectAddr | 0x034 | R/W | 默认向量地址 |

    +   第一个是最高优先级中断的地址（ISR 入口点）。在中断处理期间写入以获取当前最高优先级中断。

    +   第二个通常是 0x34，内核的入口点。

##### 过程

初始化

1.  将内核入口点写入 VICxDefVectAddr

1.  如果需要，将特殊入口点写入 VICxVectAddry

1.  准备好接受中断时，将源和使能写入 VICxVectCntly

当中断发生时

1.  读取 VICxVectAddr 以查找地址

1.  将结果移动到 PC

    ```
        ldr   pc, #<VicVectAddr>
    ```

    （请注意，这类似于 0x014 中的指令。我们能否一次完成所有操作？）

1.  在重新启用中断之前，将 VICxVectAddr 写入以启动优先级硬件

##### 回答问题。

仔细看看 0x18 中的内容

+   通常，`ldr pc, [pc, #offset]`

    你能让`[pc, #offset]`计算`<VicVectAddr>`吗？

+   指令如何编码

    +   31:28 - 条件码

    +   27:20 - 操作码和标志，0101<偏移符号>001

    +   19:16 - 基址寄存器

    +   15:12 - 目的寄存器

    +   11:00 - 12 位偏移

+   有了 12 位偏移和 pc=0x18，你可以寻址

    +   来自`0x18 + 0x8 - 0xffc = -0xfdc =``0xfffff020`

    +   到`0x18 + 0x8 + 0xffc = 0x1020`

+   你可以将内核入口点放在

    +   要么`0x800b0030`

    +   或者`0x800c0030`

+   两者都超出范围。你能做什么？

    +   将 ICU 映射到范围内，例如将其放置在`0xfffff000`处。

* * *

## 时钟服务器

### 原语

```
int Time( )
```

+   时钟服务器在初始化时从零开始

+   时间单位是滴答

```
int Delay( int ticks )
```

+   注意错误返回

+   你可能想为负参数添加一个错误

    +   通常计算滴答声，负值是落后的早期警告。

```
int DelayUntil( int ticks )
```

+   可以从上述两个原语构建。

### 实施

```
main( ) {
    notifier = Create( HIGHEST, ... );
    time = 0
    Send( notifier, &evtType, ... );
    FOREVER {
        Receive( &requester, &request, ... );
        switch ( request.type ) {
        case NOTIFIER:
            Reply( notifier, ... )
            time++;
            break;
        case TIME_REQUEST:
            Reply( requester, time,... )
            break;
        case DELAY_REQUEST: 
            Add requester to list of suspended tasks
            break;
        }
        Check list of suspended tasks and reply
    }
}
```

注释：

1.  你需要一个常见的请求类型，或者可能是一个联合体。

1.  你应该注意到一个典型的服务器模式。

    +   通知者更新数据

    +   现在可以提供服务的客户端已经得到服务

    +   未来需要服务的客户端被挂起

    +   挂起任务列表定期检查

1.  对挂起任务列表进行排序是正常的。为什么？

* * *

## HALT 与空闲任务

当没有任务可运行时，你会怎么做？

+   空闲任务

    +   最低优先级

    +   诊断系统

        +   哲学问题。检测错误很容易；但当你检测到错误时该怎么办。

            +   极端例子：不完整的交易与爆炸

        +   将错误分为两类的实际解决方案

            1.  在不停止的情况下恢复。极端例子是麦哲伦号航天器：

                +   金星后面是寂静；金星后面又开始交谈

                +   在轨道插入期间：从金星后面出来，什么都没有

                +   等六周，“我在这里。”

                +   等三周，什么都没有

                +   等六周，“我在这里。”

                +   等三周，“我稳定了。”

                +   发生了什么？

            1.  停止，诊断，重新编程，重新运行

            极端例子是麦哲伦号航天器：

            1.  金星后面是寂静；金星后面又开始交谈

            1.  在轨道插入期间：从金星后面出来，什么都没有

            1.  等六周，“我在这里。” 等三周，什么都没有

            1.  等六周，“我在这里。”

            1.  等三周，“我稳定了。”

            1.  发生了什么？

            1.  现在进入标准的两箱开发模型中的第二类别。

    +   搜索 ETI

+   待机/停止

    +   关闭 CPU 时钟

    +   节省电力（电池）

    +   提供两种方式

        1.  通过系统控制器协处理器

            +   使用 MCR 指令，访问协处理器 15。

            +   只能在特权模式下执行

        1.  通过 EP9302

            +   写入位置`0x80930008`（停止）或`0x8093000c`（待机）

            +   位必须设置为`0x80930080`

    +   IRQ 路径是异步的，因此在时钟关闭时起作用

        +   但必须启用中断

        +   因此你想要处于用户模式

    +   查看 pdf 以获取一些细节。

* * *

## 串行 I/O

查看 pdf。

FIFO

为什么 UART 中存在 FIFO？

### 大错误

要有效使用 FIFO，必须能够独立关闭发射机和接收机。

但看看 UARTxCtrl 中的 UARTE

+   UART 启用。

+   如果此位设置为 1，则 UART 已启用。

+   UART 信号进行数据传输和接收。

### 小错误

“假设 UART 的各种配置寄存器不会连续写入多次，以确保在实现中跨配置信息的正确同步。这些寄存器包括 UART1Ctrl 和 UART1LinCtrlHigh。...在两次写入之间，至少必须经过两个 UARTCLK 周期。在最坏的情况下，两次写入之间必须至少有 55 个 HCLK 周期。最简单的方法是通过 55 个 NOP 分隔两次写入。”

为什么会发生这种情况？

+   CPU 由 CPU 时钟驱动

+   系统总线由几个不同的时钟驱动

+   UART 由自己的时钟驱动

+   时钟未适当同步

为什么没有人在乎？

+   UART 在开发过程的开始阶段使用

+   一旦其他 I/O（以太网，USB 等）工作正常，UART 就不再被使用，除了启动加载程序

### 中断

##### 设备中有五个中断

这些中断可以单独启用和禁用。

1.  发射

    +   启用 FIFO

        +   当传输 FIFO 少于一半时断言。

        +   当传输 FIFO 超过一半时清除。

    +   禁用 FIFO

        +   当保持寄存器为空时断言

        +   写入保持寄存器时清除

    +   不受启用条件限制。

1.  接收

    +   FIFO 已启用

        +   当接收 FIFO 半满时断言

        +   当接收 FIFO 读取至不足半满时清除

    +   FIFO 已禁用

        +   当接收缓冲区已满时断言

        +   当接收缓冲区被读取时清除

1.  调制解调器状态

    +   当硬件流控位发生变化时断言

    +   当调制解调器状态寄存器被写入时清除

1.  接收超时

    +   当接收 FIFO 非空且经过 32 个位周期没有新数据时断言

    +   当所有数据从 FIFO 中读取完毕时清除

1.  组合

    +   上述四个中断的 OR

    +   当上述任一中断被断言时断言

    +   当上述所有中断都未被断言时清除

##### PIC 的三个输入

1.  传输

1.  接收

1.  组合

##### 使用中断的简单方法

仅启用组合；读取 UART 寄存器以决定下一步操作。

将 UART 的接收和发送部分视为独立的状态机

+   基于状态寄存器中的位来构建状态机

+   制作一个独立的状态机用于流量控制

* * *

返回至：

+   Bill Cowan 在 s12 的 CS452 课程讲义

+   Bill Cowan 2012 年春季 CS452 页面

+   Bill Cowan 的 CS452 页面

+   Bill Cowan 的教学页面

+   Bill Cowan 的主页
