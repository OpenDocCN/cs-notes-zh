# 课程 P13：Lecture 10： RISC-V 过程（函数）调用 🧩

在本节课中，我们将要学习 RISC-V 架构中过程（或称为函数）调用的机制。你将理解计算机如何跟踪函数调用、传递参数、保存返回地址以及管理寄存器，从而让复杂的程序能够有条不紊地运行。

## 概述：为什么需要过程调用？

到目前为止，你已经学会了如何使用跳转和分支指令在程序中移动。你可以编写循环和条件判断。但你还没有办法编写一个可以被重复调用的、独立的函数模块。函数调用是结构化编程的核心，它允许代码复用和逻辑封装。本节将揭开函数调用背后的神秘面纱。

上一节我们介绍了基本的控制流指令，本节中我们来看看如何实现更高级的函数调用与控制权转移。

## 函数调用的六个步骤

为了实现一个函数调用，处理器需要协同完成一系列标准化的步骤。以下是调用函数的六个关键步骤：

1.  **传递参数**：将函数需要的参数值放置到约定的位置。
2.  **转移控制权**：跳转到被调用函数的代码起始地址。
3.  **分配局部存储**：为被调用函数的局部变量分配内存空间（如果需要）。
4.  **执行函数体**：运行函数内部的指令，完成计算任务。
5.  **存储返回值**：将函数的计算结果存放到调用者能获取的位置。
6.  **恢复控制权并返回**：跳转回调用发生位置的下一条指令，继续执行。

我们将具体看到在 RISC-V 中如何实现这些步骤。

## RISC-V 的调用约定

为了确保不同函数之间能正确协作，RISC-V 定义了一套严格的“调用约定”，规定了寄存器的用途。

### 参数寄存器：a0-a7

RISC-V 使用 `a0` 到 `a7` 这 8 个寄存器来传递函数参数。这是为了效率，因为访问寄存器远比访问内存快。
*   `a0` 对应 `x10`
*   `a1` 对应 `x11`
*   ...
*   `a7` 对应 `x17`

**核心概念**：
```assembly
# 假设要调用函数 func(x, y)
# 将参数 x 的值放入 a0，参数 y 的值放入 a1
mv a0, s0  # s0 中存放着 x 的值
mv a1, s1  # s1 中存放着 y 的值
```

**注意**：如果函数参数超过 8 个，超出的部分需要通过“栈”来传递。

### 返回地址寄存器：ra

寄存器 `ra` (即 `x1`) 用于存放**返回地址**。当调用函数时，处理器会自动将当前指令的下一条指令地址（即返回后应继续执行的位置）存入 `ra`。函数执行完毕后，通过跳转到 `ra` 中的地址来返回。

### 保存寄存器：s0-s11

寄存器 `s0` 到 `s11` (对应 `x8-x9`, `x18-x27`) 被称为“保存寄存器”。调用约定规定，被调用的函数如果使用了这些寄存器，**必须保证在返回前，它们的值恢复到被调用之前的状态**。这意味着，如果函数内部要使用 `s` 寄存器，它必须先把旧值保存到内存（通常是栈上），使用完毕后再恢复。这样，调用者就可以放心地在 `s` 寄存器中存放重要数据，而不必担心被调用的函数破坏它们。

### 临时寄存器：t0-t6

寄存器 `t0` 到 `t6` (对应 `x5-x7`, `x28-x31`) 被称为“临时寄存器”。与 `s` 寄存器相反，被调用的函数可以随意使用它们，而无需保存和恢复。因此，调用者如果希望某个值在函数调用后保持不变，就不应该把它放在 `t` 寄存器中。

## 关键指令：跳转与链接

简单的 `j` (jump) 指令可以实现跳转，但无法保存返回地址。RISC-V 提供了专门的函数调用指令。

### `jal` (Jump and Link) 指令

`jal` 指令完成两件事：
1.  **链接**：将下一条指令的地址（`PC + 4`）保存到 `ra` 寄存器中。
2.  **跳转**：跳转到目标标签指定的地址。

**核心概念**：
```assembly
# 调用函数 ‘sum’
jal sum   # 1. 将返回地址 (PC+4) 存入 ra
          # 2. 跳转到标签 ‘sum’ 处执行
# 函数返回后将从此处继续执行
```

### `jalr` (Jump and Link Register) 指令

`jalr` 指令与 `jal` 类似，但跳转目标地址来自一个寄存器。
*   `jalr ra, 0(t1)` 表示：将 `PC+4` 存入 `ra`，然后跳转到 `t1` 寄存器中存储的地址。
*   `ret` 是一个伪指令，等价于 `jalr zero, 0(ra)`，用于从函数返回。

## 栈：函数调用的内存舞台

当一个函数需要更多的存储空间（例如，保存 `s` 寄存器的值、存放局部变量、或者传递超过8个的参数）时，它就会使用“栈”。栈是一段按照“后进先出”原则管理的内存区域。

*   **栈指针**：寄存器 `sp` (即 `x2`) 指向栈的“顶部”。
*   **栈的生长方向**：在 RISC-V 中，栈向内存地址减小的方向生长（向下生长）。
*   **分配空间**：通过减小 `sp` 的值来在栈上分配新的空间。
    ```assembly
    addi sp, sp, -16  # 将栈指针下移 16 字节，分配空间
    ```
*   **释放空间**：函数返回前，通过增加 `sp` 的值来释放它分配的空间。
    ```assembly
    addi sp, sp, 16   # 将栈指针上移 16 字节，释放空间
    ```
*   **栈帧**：每次函数调用所分配的栈内存块，称为该函数的“栈帧”。

## 实例分析：一个叶子函数

让我们分析一个简单的“叶子函数”（即不调用其他函数的函数）的例子：`leaf(g, h, i, j)`，它计算 `(g+h) - (i+j)`。

以下是该函数的 C 代码和对应的 RISC-V 汇编代码：

**C 代码**:
```c
int leaf(int g, int h, int i, int j) {
    int f;
    f = (g + h) - (i + j);
    return f;
}
```

**RISC-V 汇编**:
```assembly
leaf:
    # 1. 在栈上分配空间（16字节：8字节用于保存s0，8字节对齐）
    addi sp, sp, -16
    # 2. 保存需要使用的保存寄存器 s0, s1
    sd s0, 0(sp)   # 将 s0 的旧值存到栈帧
    sd s1, 8(sp)   # 将 s1 的旧值存到栈帧

    # 3. 执行函数计算
    # 参数已在 a0(g), a1(h), a2(i), a3(j) 中
    add t0, a0, a1 # t0 = g + h
    add t1, a2, a3 # t1 = i + j
    sub s0, t0, t1 # f = (g+h) - (i+j) 结果放在 s0

    # 4. 将返回值放入 a0
    mv a0, s0

    # 5. 恢复保存的寄存器
    ld s1, 8(sp)   # 从栈帧恢复 s1
    ld s0, 0(sp)   # 从栈帧恢复 s0
    # 6. 释放栈空间
    addi sp, sp, 16
    # 7. 返回
    ret
```

**代码解读**：
1.  函数首先通过调整 `sp` 在栈上开辟了 16 字节空间。
2.  因为它要使用 `s0` 和 `s1` 寄存器，所以必须先将它们当前的值保存到栈上 (`sd` 指令)。
3.  使用 `a0`-`a3` 中的参数进行计算，结果暂存于 `s0`。
4.  将最终结果 `f` 移动到返回值寄存器 `a0`。
5.  在返回前，从栈上恢复 `s1` 和 `s0` 的原始值 (`ld` 指令)。
6.  通过调整 `sp` 释放栈空间。
7.  使用 `ret` 指令跳转回 `ra` 指向的地址。

## 嵌套调用与非叶子函数

当一个函数（我们称之为主调函数）内部又调用了其他函数（被调函数）时，情况会复杂一些。主调函数必须注意：
*   如果它自己的返回地址 `ra` 在调用其他函数后还需要使用（通常都需要），那么它必须在调用前将 `ra` 保存到栈上，否则 `ra` 会被新的调用覆盖。
*   如果它放在 `a0-a7` 中的参数在调用其他函数后还需要使用，也需要提前保存，因为被调函数有权覆盖这些寄存器。
*   临时寄存器 `t0-t6` 永远不可靠，如果其中的值在调用后还需要，必须提前保存。

保存和恢复这些值的原理与保存 `s` 寄存器完全一样，都是通过栈操作 (`sd`/`ld`) 来完成。

## 总结

本节课中我们一起学习了 RISC-V 架构中过程调用的完整机制。我们了解了函数调用的六个步骤，掌握了 RISC-V 关键的调用约定，包括参数寄存器 (`a0-a7`)、返回地址寄存器 (`ra`)、保存寄存器 (`s0-s11`) 和临时寄存器 (`t0-t6`) 的角色。我们学习了 `jal` 和 `jalr` 指令，并深入探讨了栈的概念及其在管理函数局部数据和保存现场中的核心作用。通过分析叶子函数的汇编实例，你将函数调用的抽象概念与具体的机器指令联系了起来。理解这些内容是编写和阅读复杂汇编程序的基础。