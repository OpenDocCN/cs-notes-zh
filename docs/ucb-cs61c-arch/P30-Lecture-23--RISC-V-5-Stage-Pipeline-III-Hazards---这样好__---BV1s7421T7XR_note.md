![](img/0967f31ff5224396c692e8fbbdc5f20c_0.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_2.png)

# 课程 P30：第23讲：RISC-V 五级流水线 III - 冒险处理 🚧

![](img/0967f31ff5224396c692e8fbbdc5f20c_4.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_6.png)

在本节课中，我们将学习RISC-V五级流水线中一个核心概念：冒险。我们将探讨什么是冒险，它们如何影响流水线性能，以及如何通过硬件和软件技术来解决这些冒险。

![](img/0967f31ff5224396c692e8fbbdc5f20c_8.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_10.png)

---

## 期中考试与课程支持 📝

![](img/0967f31ff5224396c692e8fbbdc5f20c_12.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_14.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_16.png)

本周有期中考试，请务必参加实验课并填写期中考试复习表。这是一个实验，旨在帮助大家建立对RISC-V和RISC-V C的信心。请让我们知道未来需要改进的地方。

![](img/0967f31ff5224396c692e8fbbdc5f20c_18.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_20.png)

关于期中考试的其他注意事项，公司发布了一篇教育帖子。相关幻灯片应该很快就会发布。目前请不要讨论作业，因为我们还没有为所有人发布解决方案。当允许讨论期中考试时，我们会通知大家。如果你有任何与考试相关的紧急问题，请发邮件给我们。

![](img/0967f31ff5224396c692e8fbbdc5f20c_22.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_24.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_26.png)

如果你担心跟不上课程进度，特别是在期中考试后内容较多，请务必报名参加学生支持会议。你可以通过扩展表单完成报名。我们期待在这门课上继续支持你。

![](img/0967f31ff5224396c692e8fbbdc5f20c_28.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_30.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_32.png)

我们希望你能感受到我们61C大家庭的支持。这只是一个顶层声明，你需要仔细阅读每一个细节。我们有首尔国立大学的李杰教授作为实验室会议的一部分发言。当你读博士或在学术环境中，你有不同的研究实验室，这并不总是意味着人们在做生物学实验，有时他们在设计GPU等不同类型的设备。切片实验室是一个领域特定架构实验室，围绕不同类型的应用程序设计处理器。

![](img/0967f31ff5224396c692e8fbbdc5f20c_34.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_36.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_38.png)

李教授将分享关于领域特定硬件的见解。他拥有该领域的博士学位，并在谷歌工作过一段时间。这将是很好的分享，我可能也会在周三的课上分享。

你们中有多少人复习了星期五的课？我看到90%的人复习了。如果你不确定，请举手。我们将做一个快速回顾，因为我知道期中考试后每个人都需要回到这些概念上，然后我们会继续学习剩余的内容。

![](img/0967f31ff5224396c692e8fbbdc5f20c_40.png)

---

![](img/0967f31ff5224396c692e8fbbdc5f20c_42.png)

## 流水线回顾与冒险引入 🔄

![](img/0967f31ff5224396c692e8fbbdc5f20c_44.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_46.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_48.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_50.png)

在谈论冒险之前，我想提醒你我们目前的位置。

![](img/0967f31ff5224396c692e8fbbdc5f20c_52.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_54.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_56.png)

我们称之为流水线数据路径。流水线数据路径的不同之处在于，它不是只有一个指令可以按顺序执行所有阶段，而是有多个指令共享流水线。

![](img/0967f31ff5224396c692e8fbbdc5f20c_58.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_60.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_62.png)

我们思考这个问题的方式是：假设我们有一个加法指令紧跟着一个减法指令。在这个特定的时钟周期中，加法指令当前处于执行阶段（ALU阶段），因此目前使用管道的这一部分。然后减法指令使用ID阶段，即指令解码阶段。

![](img/0967f31ff5224396c692e8fbbdc5f20c_64.png)

这意味着它正在访问寄存器文件。为什么我们可以让这些指令共享相同的管道？我们可以有称为流水线寄存器的东西来保存所有指令的数据，然后在时钟上升沿将其传递出去，以便让指令使用那个阶段。这就像一个快照点，允许所有这些指令数据共享同一组导线。

![](img/0967f31ff5224396c692e8fbbdc5f20c_66.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_68.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_70.png)

但请注意，实际上这里有一些称为“冒险”的东西。

---

![](img/0967f31ff5224396c692e8fbbdc5f20c_72.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_74.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_76.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_78.png)

## 数据冒险详解 ⚠️

![](img/0967f31ff5224396c692e8fbbdc5f20c_80.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_81.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_83.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_85.png)

特别是在我们的加法（add）和减法（sub）的情况下，现在我有三条指令，我还遵循了一个称为“或”（or）的指令。我们有这些称为“冒险”的东西，当一些指令实际上还不能正确执行时就会发生。

![](img/0967f31ff5224396c692e8fbbdc5f20c_87.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_89.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_91.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_93.png)

因为它使用的源寄存器（例如 `s0`）在之前的指令中被写入。我们知道，如果我们把所有的细节都流水线化，`s0` 寄存器直到第五个周期才会被写入。

![](img/0967f31ff5224396c692e8fbbdc5f20c_95.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_97.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_99.png)

如果我们从周期一、二、三、四、五开始数，如果那是第五周期，实际上减法指令在上一个周期就需要它，就在这里。

![](img/0967f31ff5224396c692e8fbbdc5f20c_101.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_103.png)

因为它需要用 `t0` 减去 `s0`。它实际上是在ID阶段读取了错误的值——`s0` 的旧值。在幻灯片的底部，它不会更新到新值（假设是9），直到它被写回WB阶段。

![](img/0967f31ff5224396c692e8fbbdc5f20c_105.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_107.png)

所以这就是这里的冒险。减法指令实际上不能与加法指令并行执行，或者也读取了错误的寄存器值 `x0`。因此，从技术上讲，那里也不可能发生，因为有一种叫做“数据冒险”的东西，它得到了错误的数据。

那么解决办法是什么呢？我们上次谈到，这就是我们的结局。我们谈到了一个叫做“流水线停顿”的事情。换句话说，让一些指令实际上不执行，等到没有更多的数据危险之后再运行。

![](img/0967f31ff5224396c692e8fbbdc5f20c_109.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_111.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_113.png)

这看起来像是当减法指令有一些解码发生时，流水线实现发现：“哎呀，我现在还不能开始执行减法，因为我正在读取的 `s0` 还没有被更新。”所以它让这些气泡沿着管道流动。对于这个图来说，这意味着流水线阶段只是运行垃圾数据，它实际上并没有写任何东西来更新其他地方的所有状态。

![](img/0967f31ff5224396c692e8fbbdc5f20c_115.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_117.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_119.png)

然后在第二个周期也是如此，它试图再次运行减法指令，但发现：“啊，好吧，又来了，因为 `s0` 还没有被写入，我没有 `s0` 的正确值。”然后它继续停顿或产生气泡。最后，在倒数第二行，现在是减法指令。在这一点上，当寄存器文件被读取时（在ID阶段），它将从中读取。这个指令解码阶段很好，它发生在同一个周期中，当寄存器文件在WB阶段被写入时。因为上次的寄存器文件是写操作，然后读操作可以发生在同一个周期中，所以这很好。最后一条指令（or）在这一点上，我们肯定知道 `s0` 没有被写入，所以我们可以像平常一样获取它。

![](img/0967f31ff5224396c692e8fbbdc5f20c_121.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_123.png)

有时讲座结束后会出现一些问题，感觉还行。就像，这是怎么发生的？这些气泡是怎么起作用的？你可以想象在之前的图表中，如果我很快回到上一张幻灯片，只需添加更多的电线和更多的块，并添加更多通过流水线寄存器布线的项。还记得上次我们谈到通过流水线寄存器进行控制转发。大家可以想象一下，也有一些空操作（NOP）指令正在通过寄存器转发，以确保我们不会将任何内容更新到我们的状态文件中，像寄存器和内存。

![](img/0967f31ff5224396c692e8fbbdc5f20c_125.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_127.png)

但是，事实证明，这实际上在时间上是昂贵的。因为这意味着在接下来的两个周期里，你不能实际执行这些指令，你的整个流水线都停止了。没有指令完成执行。所以“转发”是另一种硬件解决方案，它实际上显式地将管道的输出连接到不同阶段的不同部分。

![](img/0967f31ff5224396c692e8fbbdc5f20c_129.png)

换句话说，在上一个版本中，我们在考虑只能从寄存器中读取值，当它们都正确更新时。但我们知道，由于我们的五级流水线，到了第三个周期（EX阶段结束时），我们确实有结果 `f0` 的正确值。因为 `s0` 是 `g0` 加 `t1`。然后这个值通过MEM阶段，然后在WB阶段写回。但在最后两个阶段并没有改变。所以，如果有一种方法可以直接连接前一阶段的输出到后一阶段的输入，那么我们就可以知道在下一个周期，当我们执行减法指令的ALU部分时，我们实际上可以用 `s0` 的正确值执行。

![](img/0967f31ff5224396c692e8fbbdc5f20c_131.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_133.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_135.png)

这是一个巨大的进步，但让我给你们看另一个例子。在这一点上，让我们来看看OR指令。这个或指令有效地在执行阶段只需要知道 `s0` 的正确值，因为这是操作数之一。源操作数很好，我们什么时候知道正确的值？从技术上讲，它是在前一个阶段（MEM阶段）写的，但我们在WB阶段才知道。但我们知道前一条加法指令的EX阶段发生了。所以如果我们有类似的东西，如果我们要把 `s0` 转发到MEM阶段，因为它最终会被写到WB阶段，我们可以把输出连接在一起。这是 `s0` 进入OR的执行阶段。

![](img/0967f31ff5224396c692e8fbbdc5f20c_137.png)

我想，老实说，这可能是所有图表中最具挑战性的图表。因为这里重要的是要知道，这就像是同一条管道。我刚刚重复了三次管道，但这是同样的硬件。那么“转发”是什么意思呢？转发意味着结果及时地转发到某个未来需要的值。所以在这种情况下，我们说在时钟周期三中，加法指令EX阶段的结果被转发到减法指令EX阶段的输入（时钟周期四），而不是等到时钟周期五它被写入寄存器文件。同样地，OR指令从MEM阶段转发到EX阶段的输入（时钟周期四）。所以时间是向前的。

有个问题，问得好。问题是：“我们不能喜欢这里的紫色电线吗？从技术上讲，它来自MEM阶段。那是怎么回事？为什么它会变成X？它不应该从这里一路连接吗？”这是一个很好的观点。其中一些只是基于事物是如何连接在一起的。这里的重点是，如果你把镜头拉近，你会看到我实际上使用了流水线寄存器作为电线的来源。所以正在发生的是，它没有直接连接到ALU的输出或直接连接到MEM的输出，它真的来自我拥有的任何一组管道寄存器。

![](img/0967f31ff5224396c692e8fbbdc5f20c_139.png)

因此，如果我们回到最初的幻灯片，你可以想象ALU值是在EX/MEM管道寄存器中设置的，以及这个MEM/WB管道寄存器。所以所有这些都有ALU值，电线就是从那里来的。实际上，让我们在下一节中看看这个。所以我要向你们展示转发是如何工作的，对于其中一种情况（add -> sub）。我不会告诉你减法或OR是什么，我让你自己想办法。我尽量保持图表相对简单，因为它们非常复杂。

![](img/0967f31ff5224396c692e8fbbdc5f20c_141.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_143.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_145.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_147.png)

但让我们再来看看这个。我们在想什么？我们在考虑这个案例（add后接sub）。然后我们从X值（这个特殊的管道寄存器，存储ALU当前结果的东西）试图将它直接连接到ALU的输入。所以即使我们在管道上及时转发了这个数据路径，实际上看起来事情在倒退，因为我们处理的是同一条管道。每个人都在使用相同的管道。如果我们想转发ALU的结果，让我们看看这是如何工作的，尽管该值存储在EX/MEM管道寄存器中。

![](img/0967f31ff5224396c692e8fbbdc5f20c_149.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_151.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_153.png)

好的，中间这个。现在让我强调一下，如果是这样的话，我们需要以某种方式连接这个管道寄存器。我要留着，当这两个... 因为它最终会被加入。那么这是怎么发生的呢？只是有些电线。所以我要把我连接在一起的东西，这里是，我说。好啦，在MEM阶段的管道寄存器输出会发生什么？它要接上电线，然后连接到这两个多路选择器，选择ALU输入A和B。这里还有一些关于我当前指令的信息。

![](img/0967f31ff5224396c692e8fbbdc5f20c_155.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_157.png)

那么这个紫色的指令是什么？这是添加指令。这里的蓝色指令是什么？它被转发到控制逻辑，这是第二条指令的子指令。然后转发控制逻辑会做什么？就像是：“好啦，嗯，我知道ALU的值，也就是 `f0`，它将需要用作源输入之一，事实上，输入ALU的A，为了下一阶段。” 那有点复杂。这个文件是怎么回事？你有什么问题？我认为就电线而言，这可能是最具挑战性的，因为在数据路径中，电线倒过来了。紫色的线在向后，但在梯形图中，箭头是向前的，因为你在时间上向前推进。

我们在这里有什么问题？好的问题。让我回到上一张幻灯片，不幸的是，我的颜色在这里不完全正确，所以我可能会有点困惑。我们在这里做的是，我们把注意力集中在绿盒子上，我们在说：“好啦，我们真正需要的是结果，它位于EX和MEM之间的管道寄存器，这需要转发给输入，EX阶段。” 因为从技术上讲，前一条指令的EX阶段是完全相同的EX阶段，它只是每个周期被执行。发生的事情是，EX/MEM管道寄存器的输出，就像回到EX输入的电线。但随着时间的推移，至少在这个流水线梯形图中，我们看到事情向前进展。所以这就是为什么我认为这是一个挑战。

![](img/0967f31ff5224396c692e8fbbdc5f20c_159.png)

那么“转发”的是什么？平均转发意味着及时转发，这样你就不用等着写东西了。我们将在下一个例子中看到，也就是加载指令（load）。所以让我们看看会发生什么。就像我说的，当我们试图比只把东西写到寄存器文件更快时，只有在正确的WB阶段才会发生。让我们看这组特殊的指令：从add到load word到or，然后左移逻辑。在这种情况下，我在这里突出显示了一些寄存器，我们实际上可能有数据危险，但我们要通过将硬件逻辑转发到我们的数据路径中来修复。

![](img/0967f31ff5224396c692e8fbbdc5f20c_161.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_163.png)

所以让我们看看转发可以修复的两个危险，这需要更多的硬件和更多的转发控制逻辑。其中一个是在add中写入 `s0`，所以更新 `s0` 的值，但在下一条指令中立即读取。所以再一次，如果我们没有转发，这意味着我们必须让整个流水线停顿，直到 `s0` 被写入。但是因为我们确实有转发，我们会知道到那时，`s0` 或 `t1` 加 `t2` 在前一阶段计算，我们可以直接把这个转发到EX阶段进行load工作。现在为什么加载字（load word）在执行阶段需要 `s0`？我们把8加到 `s0` 上，只是记住load word是如何工作的。所以这很好，就像在绿色盒子里一样。

这里的另一个危险是：load word指令中的 `s1` 是什么？让我强调一下。这里的一个是我们记忆单词的目的地，或者像这样，我们的记忆字将生活在寄存器文件中。所以 `s1` 会在WB阶段更新，但真的，它将在MEM阶段结束时被知道。在这种情况下，只要有一个or指令，就像 `f0` 加上8的值，就像你知道在那个地址的单词的价值一样。一旦那个单词从内存中加载，从技术上讲，我们需要在下一阶段把它写到 `s1`（WB阶段）。但在这个时候，一旦内存字被加载到数据路径中，我们知道它的值是多少，所以我们可以把它作为一个源转发给or指令。所以这就是为什么你可以看到这根电线，上面写着：“好吧，这就是一个值将被知道的地方，我将需要它为ALU的输入在执行阶段。”

![](img/0967f31ff5224396c692e8fbbdc5f20c_165.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_167.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_169.png)

好的，所以这就是我们所看到的。这就是我们在这里看到的蓝色盒子。所以转发解决了这两种情况，因为否则我们将不得不等待另一个周期或拖延另一个周期。转发就像是快捷方式。

![](img/0967f31ff5224396c692e8fbbdc5f20c_171.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_173.png)

然而，这里有一个数据危险是转发不能解决的。所以记住，当你看到这种类型的图表时，你的口头禅是：“恰逢其时，转发及时向前。” 现在让我们看看这个特定的数据危险会发生什么。上面写着：“好，load word指令的 `s1` 将被写在WB阶段，但我们会在MEM阶段结束时知道的。但是，or指令在EX阶段需要 `s1`。” 哦不，这是做什么的？你记得我说过的话，我说过MEM阶段的输出，就像那种管道寄存器，它将知道 `s1` 的值。但我们需要这个来输入EX阶段。所以这个箭头是时光倒流，没有进展。

![](img/0967f31ff5224396c692e8fbbdc5f20c_175.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_177.png)

那么这里的问题是什么呢？到底发生了什么？在相同的时钟周期中我们需要输入，它实际上是其他一些数据路径元素的输出。换句话说，这里的MEM数据路径元素需要以某种方式向前向后。或者像你知道的，所以说，如果我们想想向前向后的事情，这个不太有道理。所以这实际上是不可能的。为什么物理上不可能？为了让这种情况发生，我们需要像DM访问这样的MEM首先发生，然后是EX（ALU需要能够执行）。但时钟周期长度仅够ALU或DM访问之一，所以我们的时钟周期不够长，所以我们可以把这些东西连接在一起。我们该怎么办？

![](img/0967f31ff5224396c692e8fbbdc5f20c_179.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_181.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_183.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_185.png)

答案是：当加载后立即使用（load-use）发生时，我们真的无能为力。没有硬件解决方案来修复这一个停顿。我们有一个额外的停顿。给大家看一下，我来教你这个，这在实践中是如何工作的。就硬件不可避免地要做的事情而言，因为我们不能后退，对呀，因为我们不能把时间倒过来。

![](img/0967f31ff5224396c692e8fbbdc5f20c_187.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_189.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_191.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_193.png)

取而代之的是，当我们看到这个，或者我们知道我们无法在执行阶段及时得到 `s1` 的这个值。因此，我们将知道它，好的，所以我们在这里称之为指令，我们称之为“加载延迟槽”，暗示这就是延迟发生的地方。

![](img/0967f31ff5224396c692e8fbbdc5f20c_195.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_197.png)

所以一旦我们看到or指令使用load word的结果（`s1`），然后它必须知道选择它，因为它知道它不能执行or指令，当字的值仍从内存中加载时，它无法运行其执行阶段。所以它必须再等第二个周期，然后在这一点上，它能够向前做。

你在这里有什么问题？哦，伟大的洞察力。所以问题或洞察力是：“好啦，所以如果加载延迟槽没有使用load word的结果，那就不会耽搁了。” 是呀，我们会在下一张幻灯片上看到。所以至少每个人都明白，如果我们有这种依赖性，在需要使用or指令的地方，作为一个我们不可避免地会有延迟。我不需要做或不做，好啦，我们得到了。

还有一个问题，哎呦，只是为了所有人。这里有一个关于程序计数器的问题：这个空操作（noop）到底会发生什么？所以禁令真正做的是，上面写着：“好的，请不要实际更新程序计数器，因为我需要再次访问该指令。” 是啊，这是个好问题。所以你也会把这看作是讨论的一部分。如果需要重新加载上一条指令，PC加四，你不应该更新到下一条指令，因为那样你就会失去一切。这就是失速逻辑实际上为你实现的东西。但就像它是一种方式。

![](img/0967f31ff5224396c692e8fbbdc5f20c_199.png)

所以让我们回到那个想法，这没关系。对于加载后立即使用加载结果的任何指令，我们将需要解决，但其他一切都会好起来的。这允许我们做什么？看看我们的RISC-V说明书，试着重新排序指令，这样负载延迟就不会发生。这就是在代码编译阶段完成的。通常，在硬件级别上可能会发生一点重新排序，我们今天下课后再谈。

![](img/0967f31ff5224396c692e8fbbdc5f20c_201.png)

---

![](img/0967f31ff5224396c692e8fbbdc5f20c_203.png)

## 代码调度与性能优化 ⚙️

![](img/0967f31ff5224396c692e8fbbdc5f20c_205.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_207.png)

让我们假设这是我们的C代码。我们有几个数组访问：`a[0]`, `a[1]`, `a[2]`。我们把它们加起来，然后我们把它们存储到同一个数组中。这在简单的编译案例中是什么样子的？所以让我们假设我没有考虑很多，像我这样的编译器，我没想太多。我在想把C转换成RISC-V，我可能会做的是：

![](img/0967f31ff5224396c692e8fbbdc5f20c_209.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_211.png)

我会先加载 `a[0]`，把它放在 `t1`。我会加载 `a[1]`，然后把它放进 `t2`。这就是为什么那里有绿色价值。然后我会加 `a[0]` 和 `a[1]`，也就是 `t1` 和 `t2`，我会把它存储到 `t3`。这是那里的前三个指令。然后我们的前四个指令，然后我会把 `a[2]` 装进 `t4`，然后把它们相加并存储这个值到 `a[3]`，它需要在哪里。

![](img/0967f31ff5224396c692e8fbbdc5f20c_213.png)

然而，这会导致延迟，因为我们有一个操作，在这种情况下，紧随加载之后的add操作使用类似的值，使用 `t2`（使用load word的结果）。因此，在硬件层面上，这不可避免地会造成一个周期的延迟。同样地，同样的事情在7到8号线又发生了。即load word `t4` 的结果，这就是我们这里的 `a[2]`，需要立即被读取为下一条指令的源。所以这不可避免地会造成延迟。

没什么大不了的，只会降低我们的表现。好啦，这其实是件大事。问题是关于汇编的，以及加载需要什么。这个稍微有点不一样。我很乐意事后再谈。这是说在汇编中，就像中央的柱子一样，此代码可能发生，这就像是完全可行的代码，它会正常执行的，只是执行得很慢。

![](img/0967f31ff5224396c692e8fbbdc5f20c_215.png)

![](img/0967f31ff5224396c692e8fbbdc5f20c_217.png)

那么什么是更好的汇编呢？如果编译器知道会有一个循环延迟（一个周期停顿），然后它可以尝试重新排序指令，这样这些停顿就不会发生了。

我在这里做的唯一一件事是：我把第三个load word指令（也就是我在访问 `a[2]` 的值）提前了。好啦，所以我有，我从数组中加载所有三个元素（数组元素0, 1和2），然后我添加它们并将单词存储在一起。所以这将允许我做什么？现在不再有立即使用load word结果的指令在它们的负载延迟槽里。这让我能做的结果是：这是加载延迟后的一条指令。因此，只要我的管道有转发，这个问题就可以解决。

![](img/0967f31ff5224396c692e8fbbdc5f20c_219.png)

好啦，有一个问题要回答，因为你必须看起来像。这是个好问题。所以问题是如何编写编译器来使其工作？答案是很多人。但实际上更重要的答案在左边，也就是说，你需要知道CPU正在处理的流水线，因为如果你不知道加载发生在第四阶段（MEM），执行发生在第三阶段（EX），那你就不知道怎么重新排序了。所以这种事情，我要去之后回答几个问题，但我还需要完成一个部分。

谢谢。这又是两个部分。好啦，所以这很低，然后你可以看到我们完全建立了我们对管道情况的了解，处理危险。现在我们有另一种危险。

![](img/0967f31ff5224396c692e8fbbdc5f20c_221.png)

---

![](img/0967f31ff5224396c692e8fbbdc5f20c_223.png)

## 控制冒险 🎮

我们上次简短地讲到的，这就是所谓的控制冒险。所以我们又到了这里。这里危险的定义是什么？这意味着我们在技术上无法执行该指令，所以我们需要以某种方式解决问题。否则，我们看到管道降低了