![](img/8909df85cfbf71088110ca0d873a6380_0.png)

# 课程 P37：第28讲：弗林分类法与SIMD 🧠

![](img/8909df85cfbf71088110ca0d873a6380_2.png)

在本节课中，我们将学习计算机体系结构中的一个重要概念——并行性。我们将从弗林分类法开始，了解不同类型的并行计算模型，并重点探讨单指令多数据流（SIMD）模型。这是一种允许一条指令同时处理多个数据的强大技术，广泛应用于图形处理和科学计算等领域。

![](img/8909df85cfbf71088110ca0d873a6380_4.png)

![](img/8909df85cfbf71088110ca0d873a6380_6.png)

![](img/8909df85cfbf71088110ca0d873a6380_8.png)

---

![](img/8909df85cfbf71088110ca0d873a6380_10.png)

![](img/8909df85cfbf71088110ca0d873a6380_12.png)

![](img/8909df85cfbf71088110ca0d873a6380_14.png)

![](img/8909df85cfbf71088110ca0d873a6380_16.png)

![](img/8909df85cfbf71088110ca0d873a6380_18.png)

![](img/8909df85cfbf71088110ca0d873a6380_20.png)

## 弗林分类法概览 📊

![](img/8909df85cfbf71088110ca0d873a6380_22.png)

![](img/8909df85cfbf71088110ca0d873a6380_24.png)

![](img/8909df85cfbf71088110ca0d873a6380_26.png)

![](img/8909df85cfbf71088110ca0d873a6380_28.png)

![](img/8909df85cfbf71088110ca0d873a6380_30.png)

![](img/8909df85cfbf71088110ca0d873a6380_32.png)

![](img/8909df85cfbf71088110ca0d873a6380_34.png)

![](img/8909df85cfbf71088110ca0d873a6380_36.png)

上一节我们介绍了并行性的基本概念。本节中，我们来看看如何系统地分类不同的并行计算模型，即弗林分类法。

![](img/8909df85cfbf71088110ca0d873a6380_38.png)

![](img/8909df85cfbf71088110ca0d873a6380_40.png)

![](img/8909df85cfbf71088110ca0d873a6380_42.png)

弗林分类法根据指令流和数据流的数量，将计算机体系结构分为四类。以下是其核心分类：

![](img/8909df85cfbf71088110ca0d873a6380_44.png)

*   **单指令流单数据流（SISD）**：这是传统的串行处理器模型。一次执行一条指令，处理一个数据项。公式表示为：`指令流 = 1， 数据流 = 1`。
*   **单指令流多数据流（SIMD）**：一条指令同时作用于多个数据项。这是我们本节课的重点。公式表示为：`指令流 = 1， 数据流 = N (N>1)`。
*   **多指令流单数据流（MISD）**：多条指令同时处理同一个数据。这种模型在实际中很少使用。
*   **多指令流多数据流（MIMD）**：多个处理器核心同时执行不同的指令，处理不同的数据。这是现代多核处理器的基础。

![](img/8909df85cfbf71088110ca0d873a6380_46.png)

![](img/8909df85cfbf71088110ca0d873a6380_48.png)

![](img/8909df85cfbf71088110ca0d873a6380_50.png)

软件（如操作系统或应用程序）可以是串行的或并行的，硬件也可以是串行的（如老式单核CPU）或并行的（如现代多核CPU）。这四种组合都是可能的。

![](img/8909df85cfbf71088110ca0d873a6380_52.png)

![](img/8909df85cfbf71088110ca0d873a6380_54.png)

---

![](img/8909df85cfbf71088110ca0d873a6380_56.png)

## 深入SIMD：单指令多数据流 ⚡

![](img/8909df85cfbf71088110ca0d873a6380_58.png)

![](img/8909df85cfbf71088110ca0d873a6380_60.png)

![](img/8909df85cfbf71088110ca0d873a6380_62.png)

![](img/8909df85cfbf71088110ca0d873a6380_64.png)

理解了弗林分类法后，我们聚焦于其中的SIMD模型。本节中我们来看看SIMD是如何工作的以及它的优势。

![](img/8909df85cfbf71088110ca0d873a6380_66.png)

![](img/8909df85cfbf71088110ca0d873a6380_68.png)

![](img/8909df85cfbf71088110ca0d873a6380_70.png)

SIMD的核心思想是**数据级并行**。它利用一组非常宽的寄存器，能够一次性加载多个数据元素（例如4个单精度浮点数），然后通过一条特殊的指令（如向量加法）同时对这些数据进行相同的操作，最后再将结果存回内存。

![](img/8909df85cfbf71088110ca0d873a6380_72.png)

![](img/8909df85cfbf71088110ca0d873a6380_74.png)

以下是一个直观的例子。假设我们需要将两个数组 `A` 和 `B` 中的每个对应元素相加，结果存入数组 `C`。

![](img/8909df85cfbf71088110ca0d873a6380_76.png)

*   **传统SISD方式（伪代码）**：
    ```c
    for (int i = 0; i < N; i++) {
        C[i] = A[i] + B[i]; // 每次循环执行一次加法
    }
    ```
*   **SIMD方式（概念性描述）**：
    ```c
    for (int i = 0; i < N; i += 4) { // 假设SIMD宽度为4
        // 一条指令加载A[i]到A[i+3]四个数到宽寄存器RegA
        // 一条指令加载B[i]到B[i+3]四个数到宽寄存器RegB
        // 一条指令执行 RegC = RegA + RegB // 同时完成4次加法
        // 一条指令将RegC中的4个结果存回C[i]到C[i+3]
    }
    ```

![](img/8909df85cfbf71088110ca0d873a6380_78.png)

通过SIMD，理论上可以将此类循环操作的速度提升数倍（取决于SIMD寄存器的宽度）。

![](img/8909df85cfbf71088110ca0d873a6380_80.png)

![](img/8909df85cfbf71088110ca0d873a6380_82.png)

![](img/8909df85cfbf71088110ca0d873a6380_84.png)

---

![](img/8909df85cfbf71088110ca0d873a6380_86.png)

![](img/8909df85cfbf71088110ca0d873a6380_88.png)

![](img/8909df85cfbf71088110ca0d873a6380_90.png)

![](img/8909df85cfbf71088110ca0d873a6380_92.png)

## SIMD的演进与应用实例 🚀

![](img/8909df85cfbf71088110ca0d873a6380_94.png)

![](img/8909df85cfbf71088110ca0d873a6380_96.png)

![](img/8909df85cfbf71088110ca0d873a6380_98.png)

![](img/8909df85cfbf71088110ca0d873a6380_100.png)

![](img/8909df85cfbf71088110ca0d873a6380_102.png)

了解了SIMD的基本原理后，本节中我们来看看它在实际硬件中的发展历程和典型应用。

![](img/8909df85cfbf71088110ca0d873a6380_104.png)

![](img/8909df85cfbf71088110ca0d873a6380_106.png)

![](img/8909df85cfbf71088110ca0d873a6380_108.png)

![](img/8909df85cfbf71088110ca0d873a6380_110.png)

![](img/8909df85cfbf71088110ca0d873a6380_112.png)

![](img/8909df85cfbf71088110ca0d873a6380_114.png)

![](img/8909df85cfbf71088110ca0d873a6380_116.png)

![](img/8909df85cfbf71088110ca0d873a6380_118.png)

![](img/8909df85cfbf71088110ca0d873a6380_120.png)

SIMD并非新概念。早在1957年麻省理工学院的TX-2计算机就包含了类似的思想。然而，它的普及始于个人计算机时代，主要驱动力是多媒体处理（如音频、视频编解码），这些任务通常需要对大量数据执行相同的操作。

![](img/8909df85cfbf71088110ca0d873a6380_122.png)

![](img/8909df85cfbf71088110ca0d873a6380_124.png)

![](img/8909df85cfbf71088110ca0d873a6380_126.png)

英特尔处理器中的SIMD指令集经历了多次演进：
1.  **MMX**：引入64位宽寄存器，主要处理整数。
2.  **SSE**：扩展到128位寄存器，支持单精度浮点数运算（一次处理4个float）。
3.  **AVX**：进一步扩展到256位寄存器（一次处理8个float）和512位寄存器（一次处理16个float）。

![](img/8909df85cfbf71088110ca0d873a6380_128.png)

![](img/8909df85cfbf71088110ca0d873a6380_130.png)

在代码中，程序员可以通过编译器提供的**内部函数**来使用SIMD指令。这些函数看起来像普通的C函数，但会被直接编译为特定的SIMD汇编指令。

![](img/8909df85cfbf71088110ca0d873a6380_132.png)

![](img/8909df85cfbf71088110ca0d873a6380_134.png)

例如，使用SSE内部函数进行向量加法的代码片段可能如下所示：
```c
#include <xmmintrin.h> // SSE头文件

![](img/8909df85cfbf71088110ca0d873a6380_136.png)

__m128 vec_a, vec_b, vec_result; // 声明128位向量寄存器
// ... 将数据从内存加载到 vec_a 和 vec_b ...
vec_result = _mm_add_ps(vec_a, vec_b); // 执行4个float的并行加法
// ... 将结果 vec_result 存回内存 ...
```

性能提升是显著的。将简单的矩阵乘法从纯Python实现，优化为使用C语言并配合AVX内部函数，可以获得数百倍的加速比。

![](img/8909df85cfbf71088110ca0d873a6380_138.png)

![](img/8909df85cfbf71088110ca0d873a6380_140.png)

![](img/8909df85cfbf71088110ca0d873a6380_142.png)

![](img/8909df85cfbf71088110ca0d873a6380_144.png)

![](img/8909df85cfbf71088110ca0d873a6380_146.png)

![](img/8909df85cfbf71088110ca0d873a6380_148.png)

![](img/8909df85cfbf71088110ca0d873a6380_150.png)

---

![](img/8909df85cfbf71088110ca0d873a6380_152.png)

![](img/8909df85cfbf71088110ca0d873a6380_154.png)

![](img/8909df85cfbf71088110ca0d873a6380_156.png)

![](img/8909df85cfbf71088110ca0d873a6380_158.png)

![](img/8909df85cfbf71088110ca0d873a6380_160.png)

![](img/8909df85cfbf71088110ca0d873a6380_162.png)

## 总结与核心要点 ✅

![](img/8909df85cfbf71088110ca0d873a6380_164.png)

![](img/8909df85cfbf71088110ca0d873a6380_166.png)

![](img/8909df85cfbf71088110ca0d873a6380_168.png)

![](img/8909df85cfbf71088110ca0d873a6380_170.png)

本节课中我们一起学习了并行计算的基础分类——弗林分类法，并深入探讨了单指令多数据流模型。

**核心要点总结：**
*   **弗林分类法** 从指令流和数据流的角度，将计算机分为SISD、SIMD、MISD、MIMD四类。
*   **SIMD** 的核心是**数据级并行**，通过一条指令同时处理多个数据，非常适合处理数组、图像像素、音频采样等**尴尬并行**的任务。
*   SIMD需要特殊的**宽寄存器**和**向量指令**支持。在x86架构上，它经历了从MMX、SSE到AVX的演进，寄存器宽度和并行能力不断提升。
*   在编程中，通常通过编译器**内部函数**来显式地使用SIMD指令，这要求程序员对数据布局和算法有更细致的控制。
*   记住唐纳德·克努斯的忠告：**“过早优化是万恶之源”**。首先保证代码正确性，然后再考虑使用SIMD等并行技术进行优化。

![](img/8909df85cfbf71088110ca0d873a6380_172.png)

![](img/8909df85cfbf71088110ca0d873a6380_174.png)

下一节课，我们将探讨弗林分类法中的另一个重要模型——多指令多数据流，即现代多核处理器所采用的线程级并行。