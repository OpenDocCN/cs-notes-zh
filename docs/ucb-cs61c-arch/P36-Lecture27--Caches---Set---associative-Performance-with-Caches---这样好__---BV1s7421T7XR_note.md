![](img/f0745d9b679e70a58cf34ae09fdb34b6_0.png)

# 课程27：缓存 - 组相联与缓存性能 🧠💾

![](img/f0745d9b679e70a58cf34ae09fdb34b6_2.png)

在本节课中，我们将学习缓存设计中的组相联映射方式，并探讨如何评估缓存性能。我们将了解组相联缓存如何工作，它与直接映射和全相联缓存的区别，以及如何通过多级缓存和替换策略来优化系统性能。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_4.png)

---

![](img/f0745d9b679e70a58cf34ae09fdb34b6_6.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_8.png)

## 概述：什么是组相联缓存？

![](img/f0745d9b679e70a58cf34ae09fdb34b6_10.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_12.png)

上一节我们介绍了直接映射和全相联缓存。本节中，我们来看看介于两者之间的组相联缓存。组相联缓存将缓存划分为多个组（Set），每个组内包含多个块（Block）。内存地址首先映射到一个特定的组，然后在该组内可以存放在任意一个块中。这结合了直接映射的简单性和全相联的灵活性。

**核心概念**：对于一个内存地址，其映射过程可以表示为：
```
组索引 (Set Index) = (内存地址 / 块大小) % 组数
```
在找到对应组后，在该组内进行全相联查找。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_14.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_16.png)

---

![](img/f0745d9b679e70a58cf34ae09fdb34b6_18.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_20.png)

## 组相联缓存的工作原理

![](img/f0745d9b679e70a58cf34ae09fdb34b6_22.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_24.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_26.png)

组相联缓存的设计引入了“组”的概念。以下是其关键组成部分：

![](img/f0745d9b679e70a58cf34ae09fdb34b6_28.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_30.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_32.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_34.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_36.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_38.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_40.png)

1.  **地址划分**：内存地址被划分为三个部分：**标签（Tag）**、**组索引（Set Index）** 和 **块内偏移（Block Offset）**。
2.  **查找过程**：使用组索引找到对应的组，然后并行比较该组内所有块的标签位，以确定是否命中。
3.  **数据读取**：如果命中，则根据块内偏移从对应的块中读取数据；如果未命中，则需要从主存中调入数据。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_42.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_44.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_46.png)

**核心硬件**：组相联缓存需要多个并行的比较器来同时检查一个组内的所有块标签。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_48.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_50.png)

---

![](img/f0745d9b679e70a58cf34ae09fdb34b6_52.png)

## 组相联缓存的优势

![](img/f0745d9b679e70a58cf34ae09fdb34b6_54.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_56.png)

组相联缓存的主要优势在于减少了“冲突未命中”。在直接映射缓存中，如果两个频繁访问的内存块映射到同一个缓存行，就会产生严重的冲突。组相联缓存允许它们共存于同一个组内的不同块中。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_58.png)

**示例对比**：
*   在直接映射缓存中，两个映射到同一行的内存块会互相驱逐，导致频繁未命中。
*   在双向组相联缓存中，这两个块可以存放在同一组的两个不同块中，从而可能同时命中。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_60.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_62.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_64.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_66.png)

---

## 块替换策略

当缓存未命中且目标组已满时，需要选择一个现有块进行替换。这就是块替换策略。以下是几种常见策略：

*   **最近最少使用（LRU）**：替换最长时间未被访问的块。这通常能获得较好的命中率，但硬件实现较复杂（尤其是高相联度时）。
*   **先进先出（FIFO）**：替换最早进入缓存的块。实现简单，但可能替换掉仍要使用的块。
*   **随机替换**：随机选择一个块替换。实现非常简单，且性能有时出人意料地好。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_68.png)

对于双向组相联缓存，LRU策略只需一个位来记录两个块中哪个是最近被访问的。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_70.png)

---

![](img/f0745d9b679e70a58cf34ae09fdb34b6_72.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_74.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_76.png)

## 缓存性能分析

![](img/f0745d9b679e70a58cf34ae09fdb34b6_78.png)

缓存设计的最终目标是降低平均内存访问时间（AMAT）。其公式为：
```
AMAT = 命中时间 + 未命中率 × 未命中惩罚
```

![](img/f0745d9b679e70a58cf34ae09fdb34b6_80.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_82.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_84.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_86.png)

**影响AMAT的因素**：
1.  **命中时间**：访问缓存所需的时间。更小、更简单的缓存（如L1缓存）命中时间更短。
2.  **未命中率**：缓存未命中的概率。增大缓存容量、增加相联度、优化块大小可以降低未命中率。
3.  **未命中惩罚**：从下级存储器（如主存或下一级缓存）加载数据所需的时间。这个时间通常很长。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_88.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_90.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_92.png)

---

![](img/f0745d9b679e70a58cf34ae09fdb34b6_94.png)

## 多级缓存

![](img/f0745d9b679e70a58cf34ae09fdb34b6_96.png)

为了同时获得低命中时间和低未命中率，现代计算机采用多级缓存层次结构。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_98.png)

*   **L1缓存**：容量小（几十KB），速度极快（1个时钟周期），集成在CPU核心内。
*   **L2缓存**：容量较大（几百KB到几MB），速度较慢（几个到十几个时钟周期），可能被多个核心共享。
*   **L3缓存**：容量更大（几MB到几十MB），速度更慢，通常由所有核心共享。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_100.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_102.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_104.png)

**多级缓存的AMAT计算**（以两级缓存为例）：
```
AMAT = L1命中时间 + L1未命中率 × L2命中时间 + L1未命中率 × L2未命中率 × 主存访问时间
```
通过增加L2缓存，即使L1未命中，也能从较快的L2中获取数据，从而显著降低有效的未命中惩罚。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_106.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_108.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_110.png)

---

## 实际案例与总结

![](img/f0745d9b679e70a58cf34ae09fdb34b6_112.png)

本节课中我们一起学习了组相联缓存的设计与性能评估。我们了解到：

![](img/f0745d9b679e70a58cf34ae09fdb34b6_114.png)

1.  **组相联缓存**是直接映射和全相联的折中，通过将缓存分组来减少冲突未命中。
2.  **替换策略**（如LRU、FIFO、随机）决定了组满时如何选择被替换的块。
3.  缓存性能的核心指标是**平均内存访问时间（AMAT）**，它受命中时间、未命中率和未命中惩罚影响。
4.  **多级缓存**是平衡速度与容量的关键架构，通过层次化的设计，用较小的快速缓存（L1）覆盖大部分访问，用较大的慢速缓存（L2/L3）捕获更多的未命中，从而在整体上实现接近快速缓存的速度和接近大容量存储的容量。

![](img/f0745d9b679e70a58cf34ae09fdb34b6_116.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_118.png)

![](img/f0745d9b679e70a58cf34ae09fdb34b6_120.png)

缓存是计算机体系结构中提升性能的核心技术之一，其设计需要在硬件成本、功耗和性能之间进行精妙的权衡。理解这些基本原理是进行高效系统设计的基础。