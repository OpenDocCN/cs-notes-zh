![](img/08eac33950f7757e6b018dbb68a571e1_0.png)

# 课程 P45：Lecture 34： VM III： TLB 🧠💾

![](img/08eac33950f7757e6b018dbb68a571e1_2.png)

![](img/08eac33950f7757e6b018dbb68a571e1_4.png)

在本节课中，我们将学习虚拟内存（VM）的第三个核心部分：转换后备缓冲区（TLB）。我们将探讨TLB如何作为页表的缓存，以加速地址转换过程，并理解它与CPU缓存、异常处理以及上下文切换之间的关系。

![](img/08eac33950f7757e6b018dbb68a571e1_6.png)

![](img/08eac33950f7757e6b018dbb68a571e1_8.png)

---

![](img/08eac33950f7757e6b018dbb68a571e1_10.png)

![](img/08eac33950f7757e6b018dbb68a571e1_12.png)

![](img/08eac33950f7757e6b018dbb68a571e1_14.png)

![](img/08eac33950f7757e6b018dbb68a571e1_16.png)

![](img/08eac33950f7757e6b018dbb68a571e1_18.png)

## 概述：虚拟内存与性能挑战

![](img/08eac33950f7757e6b018dbb68a571e1_20.png)

![](img/08eac33950f7757e6b018dbb68a571e1_22.png)

![](img/08eac33950f7757e6b018dbb68a571e1_24.png)

![](img/08eac33950f7757e6b018dbb68a571e1_26.png)

![](img/08eac33950f7757e6b018dbb68a571e1_28.png)

上一节我们深入探讨了虚拟内存的页表结构。本节中，我们将退一步思考如何高效地实现虚拟内存，使其与操作系统其他部分（特别是我们之前搁置的缓存概念）协同工作。核心挑战在于：每次内存访问都需要进行虚拟地址到物理地址的转换，如果每次都访问内存中的页表，性能开销将非常大。

![](img/08eac33950f7757e6b018dbb68a571e1_30.png)

![](img/08eac33950f7757e6b018dbb68a571e1_32.png)

![](img/08eac33950f7757e6b018dbb68a571e1_34.png)

![](img/08eac33950f7757e6b018dbb68a571e1_36.png)

![](img/08eac33950f7757e6b018dbb68a571e1_38.png)

![](img/08eac33950f7757e6b018dbb68a571e1_40.png)

![](img/08eac33950f7757e6b018dbb68a571e1_42.png)

---

![](img/08eac33950f7757e6b018dbb68a571e1_44.png)

![](img/08eac33950f7757e6b018dbb68a571e1_46.png)

## 陷阱处理程序回顾 🚨

![](img/08eac33950f7757e6b018dbb68a571e1_48.png)

![](img/08eac33950f7757e6b018dbb68a571e1_50.png)

![](img/08eac33950f7757e6b018dbb68a571e1_52.png)

![](img/08eac33950f7757e6b018dbb68a571e1_54.png)

在深入TLB之前，我们需要简要回顾陷阱处理程序（Trap Handler）的工作机制，因为TLB未命中和页面错误等事件都需要它来处理。

![](img/08eac33950f7757e6b018dbb68a571e1_56.png)

![](img/08eac33950f7757e6b018dbb68a571e1_58.png)

![](img/08eac33950f7757e6b018dbb68a571e1_60.png)

![](img/08eac33950f7757e6b018dbb68a571e1_61.png)

![](img/08eac33950f7757e6b018dbb68a571e1_63.png)

![](img/08eac33950f7757e6b018dbb68a571e1_65.png)

![](img/08eac33950f7757e6b018dbb68a571e1_67.png)

![](img/08eac33950f7757e6b018dbb68a571e1_69.png)

陷阱处理程序是一个运行在**监管模式（Supervisor Mode）**下的程序，用于处理**中断（Interrupt）**和**异常（Exception）**。
*   **中断**与当前程序执行**异步**发生（例如，键盘输入、鼠标点击）。
*   **异常**与当前程序执行**同步**发生（例如，页面错误、无效指令）。

![](img/08eac33950f7757e6b018dbb68a571e1_71.png)

![](img/08eac33950f7757e6b018dbb68a571e1_73.png)

![](img/08eac33950f7757e6b018dbb68a571e1_75.png)

![](img/08eac33950f7757e6b018dbb68a571e1_77.png)

以下是陷阱处理程序的工作步骤：
1.  **完成与刷新**：CPU完成故障指令**之前**的所有指令，并刷新故障指令**之后**所有未完成的指令（类似于处理流水线冒险时清空流水线）。
2.  **保存状态**：陷阱处理程序保存当前进程的状态（所有寄存器、程序计数器PC等），以便后续可能恢复。
3.  **诊断原因**：检查是何种异常或中断（例如，查看故障指令及其在流水线中的阶段）。
4.  **处理事件**：根据原因执行相应操作（例如，从磁盘加载页面、终止程序）。
5.  **恢复或终止**：
    *   可能恢复原始程序执行（恢复保存的状态，CPU切换回用户模式）。
    *   也可能终止程序（释放其占用的所有资源）。

陷阱处理程序的应用实例包括：
*   **上下文切换（Context Switch）**：由定时器中断触发。处理程序保存当前进程的PC和页表寄存器（PTR）等状态，然后加载下一个进程的状态，实现进程快速切换。
*   **页面错误（Page Fault）**：当访问的页面不在DRAM中时触发。处理程序从磁盘加载所需页面到内存，更新页表，并可能在此期间切换到其他进程执行。
*   **系统调用（System Call）**：程序主动请求操作系统服务（如文件操作、`malloc`）。通过执行类似`ecall`的指令触发陷阱，陷入内核（监管模式）执行服务。

![](img/08eac33950f7757e6b018dbb68a571e1_79.png)

![](img/08eac33950f7757e6b018dbb68a571e1_81.png)

![](img/08eac33950f7757e6b018dbb68a571e1_83.png)

![](img/08eac33950f7757e6b018dbb68a571e1_85.png)

---

![](img/08eac33950f7757e6b018dbb68a571e1_87.png)

## 缓存与需求分页：术语对比 🔄

![](img/08eac33950f7757e6b018dbb68a571e1_89.png)

![](img/08eac33950f7757e6b018dbb68a571e1_91.png)

![](img/08eac33950f7757e6b018dbb68a571e1_93.png)

![](img/08eac33950f7757e6b018dbb68a571e1_95.png)

![](img/08eac33950f7757e6b018dbb68a571e1_97.png)

为了理解TLB，我们需要将缓存（Cache）的概念与虚拟内存的**需求分页（Demand Paging）**进行对比。两者都涉及将数据从低速存储器复制到高速存储器，但使用的术语和规模不同。

![](img/08eac33950f7757e6b018dbb68a571e1_99.png)

![](img/08eac33950f7757e6b018dbb68a571e1_101.png)

![](img/08eac33950f7757e6b018dbb68a571e1_103.png)

![](img/08eac33950f7757e6b018dbb68a571e1_105.png)

以下是核心概念的对比：

![](img/08eac33950f7757e6b018dbb68a571e1_107.png)

![](img/08eac33950f7757e6b018dbb68a571e1_109.png)

![](img/08eac33950f7757e6b018dbb68a571e1_111.png)

![](img/08eac33950f7757e6b018dbb68a571e1_113.png)

![](img/08eac33950f7757e6b018dbb68a571e1_115.png)

![](img/08eac33950f7757e6b018dbb68a571e1_117.png)

| 特性 | 缓存 (Cache) | 需求分页 (Demand Paging) |
| :--- | :--- | :--- |
| **内存单元** | **块（Block）**，较小（如64字节） | **页（Page）**，较大（如4KB） |
| **未命中术语** | **缓存未命中（Cache Miss）** | **页面错误（Page Fault）** |
| **映射策略** | 直接映射、组相联、全相联 | 通常使用**全相联**（页可放入内存任何位置） |
| **替换策略** | LRU（最近最少使用）、随机等 | LRU、FIFO、随机等 |
| **写策略** | 写直达（Write-Through）、写回（Write-Back） | **写回（Write-Back）** |

![](img/08eac33950f7757e6b018dbb68a571e1_119.png)

![](img/08eac33950f7757e6b018dbb68a571e1_121.png)

![](img/08eac33950f7757e6b018dbb68a571e1_123.png)

![](img/08eac33950f7757e6b018dbb68a571e1_125.png)

![](img/08eac33950f7757e6b018dbb68a571e1_127.png)

![](img/08eac33950f7757e6b018dbb68a571e1_129.png)

![](img/08eac33950f7757e6b018dbb68a571e1_131.png)

![](img/08eac33950f7757e6b018dbb68a571e1_133.png)

**关键理解**：在内存层次结构中，DRAM可以看作是磁盘页面的缓存。而**页表本身并不是缓存**，它只存储物理页码和状态位等映射信息，并不存储实际数据。

![](img/08eac33950f7757e6b018dbb68a571e1_135.png)

![](img/08eac33950f7757e6b018dbb68a571e1_137.png)

![](img/08eac33950f7757e6b018dbb68a571e1_139.png)

![](img/08eac33950f7757e6b018dbb68a571e1_141.png)

---

![](img/08eac33950f7757e6b018dbb68a571e1_143.png)

![](img/08eac33950f7757e6b018dbb68a571e1_145.png)

## 转换后备缓冲区（TLB） ⚡

![](img/08eac33950f7757e6b018dbb68a571e1_147.png)

![](img/08eac33950f7757e6b018dbb68a571e1_149.png)

地址转换是虚拟内存的核心，但每次访问都查询内存中的页表（**页表遍历，Page Table Walk**）太慢。例如，单级页表需要**两次内存访问**（一次查页表，一次取数据），多级页表则需要更多。

![](img/08eac33950f7757e6b018dbb68a571e1_151.png)

![](img/08eac33950f7757e6b018dbb68a571e1_153.png)

**解决方案**：为**地址转换**专门设立一个缓存——**转换后备缓冲区（Translation Lookaside Buffer, TLB）**。

![](img/08eac33950f7757e6b018dbb68a571e1_155.png)

![](img/08eac33950f7757e6b018dbb68a571e1_157.png)

### TLB 是什么？
TLB是一个小型、快速的硬件缓存，存储的是**最近使用过的页表项（Page Table Entries, PTEs）**。
*   **TLB 命中**：虚拟页码在TLB中找到对应的PTE，**转换仅需1个周期**。
*   **TLB 未命中**：需访问内存中的页表进行页表遍历，找到PTE后将其载入TLB。

![](img/08eac33950f7757e6b018dbb68a571e1_159.png)

![](img/08eac33950f7757e6b018dbb68a571e1_161.png)

![](img/08eac33950f7757e6b018dbb68a571e1_163.png)

![](img/08eac33950f7757e6b018dbb68a571e1_165.png)

![](img/08eac33950f7757e6b018dbb68a571e1_167.png)

![](img/08eac33950f7757e6b018dbb68a571e1_169.png)

![](img/08eac33950f7757e6b018dbb68a571e1_171.png)

### TLB 与缓存的数据流
在61C的模型中，我们采用**物理索引、物理标记（Physically Indexed, Physically Tagged）**的缓存策略。这意味着：
1.  **先进行地址转换（通过TLB）**，得到物理地址。
2.  **再用物理地址访问数据缓存**。

![](img/08eac33950f7757e6b018dbb68a571e1_173.png)

![](img/08eac33950f7757e6b018dbb68a571e1_175.png)

![](img/08eac33950f7757e6b018dbb68a571e1_177.png)

![](img/08eac33950f7757e6b018dbb68a571e1_179.png)

访问顺序流程图如下：
```
CPU发出虚拟地址 (VA)
        ↓
    查询 TLB
        ↓
      /     \
  命中       未命中 (触发页表遍历)
    ↓               ↓
获取物理地址(PA)  从内存页表获取PTE并载入TLB
        ↓               ↓
用PA访问数据缓存       返回步骤“查询TLB”
        ↓
   命中/未命中
        ↓
  返回数据/从内存载入块
```

![](img/08eac33950f7757e6b018dbb68a571e1_181.png)

![](img/08eac33950f7757e6b018dbb68a571e1_183.png)

![](img/08eac33950f7757e6b018dbb68a571e1_185.png)

### TLB 与保护机制
TLB在转换地址的同时，也负责实施内存**保护（Protection）**。PTE中的状态位（如读/写/执行权限）也保存在TLB中。如果访问违反权限（例如，尝试写入只读页），TLB会触发保护错误异常，由陷阱处理程序处理（通常导致段错误）。

![](img/08eac33950f7757e6b018dbb68a571e1_187.png)

### 上下文切换时的TLB
每个进程有自己的页表。当发生上下文切换时，新进程的虚拟地址映射关系不同。因此，操作系统通常会在切换时**使旧进程的所有TLB条目失效**（或给TLB条目打上进程ID标签）。新进程开始时TLB为空，随着执行逐渐填充，这被称为**TLB冲刷（TLB Flush）**。

![](img/08eac33950f7757e6b018dbb68a571e1_189.png)

![](img/08eac33950f7757e6b018dbb68a571e1_191.png)

![](img/08eac33950f7757e6b018dbb68a571e1_193.png)

![](img/08eac33950f7757e6b018dbb68a571e1_195.png)

---

![](img/08eac33950f7757e6b018dbb68a571e1_197.png)

## 总结 🎯

![](img/08eac33950f7757e6b018dbb68a571e1_199.png)

本节课我们一起学习了虚拟内存的关键性能优化组件——转换后备缓冲区（TLB）。

![](img/08eac33950f7757e6b018dbb68a571e1_201.png)

*   我们回顾了**陷阱处理程序**如何作为操作系统内核的入口，处理异常、中断和系统调用，并管理上下文切换与页面错误。
*   我们对比了**缓存**与**需求分页**的术语，理解了它们在不同内存层次上优化访问速度的相似理念。
*   我们深入探讨了**TLB**作为页表缓存的核心角色。它通过缓存最近使用的页表项，将频繁的地址转换操作从缓慢的内存访问变为快速的缓存查询，极大提升了虚拟内存系统的性能。
*   我们了解了地址转换的典型数据流（先TLB转换，后缓存访问），以及TLB如何与保护机制、上下文切换协同工作。

![](img/08eac33950f7757e6b018dbb68a571e1_203.png)

![](img/08eac33950f7757e6b018dbb68a571e1_205.png)

![](img/08eac33950f7757e6b018dbb68a571e1_207.png)

TLB是硬件与操作系统软件紧密配合以提升系统性能的完美例证。掌握TLB的工作原理，对于理解现代计算机如何高效、安全地管理内存至关重要。