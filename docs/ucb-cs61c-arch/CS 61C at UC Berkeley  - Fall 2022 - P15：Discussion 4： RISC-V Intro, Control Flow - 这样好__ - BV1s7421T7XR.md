# CS 61C at UC Berkeley  - Fall 2022 - P15：Discussion 4： RISC-V Intro, Control Flow - 这样好__ - BV1s7421T7XR

![](img/59a245bc5109ea1f0ba3e60006f2c96c_0.png)

它应该像好的那样编辑，每个人，呃，我们现在要开始了，所以嗯，你好，欢迎参加今天的讨论，我们将介绍风险五的介绍部分，所以一个快速的温度检查，让我们看看人们对风险的感受五号上升一半下降，好啦，好啦，嗯。

所以我看到了很多很多，嗯嗯，中下，所以我会尽可能详细地报道，回答尽可能多的问题，所以我们可以这样风险五就有希望变得更多，哦更容易理解，所以所以几个物流，所以第四圈已经结束了，我想说做这个项目非常重要。

因为它涵盖了调用约定，我们今天的讨论将不涉及，那是下周的讨论，但大腿盖住了它，我认为仔细看一下真的很重要，因为是的，然后一个项目二已经发布了，项目二a将于本周三到期，我们会有更多的助教。

在本周本学期的教职员工中使用导师和人工智能，因为项目到期了，第三个家庭作业是浮点运算，今天要交，所以我会在办公时间来，你需要任何帮助，今天我们要讨论，呃，风险五概述，与之相关的指令种类。

风险五到底是什么，从C到风险五的翻译，反之亦然，在我们开始之前，有人有什么很酷的问题要问吗，所以我喜欢用这张照片，因为它恰到好处地显示了手腕5，把它融入了六比一的C课程，所以在这节课中。

我们将使用这个整体的想法，并考虑这个，我们的计算机现在正在处理处理器中的东西，不管我们报道了什么，早些时候已经习惯了，只需提供计算机中实际发生的事情的高级抽象，现在我们要低一点，覆盖一些东西。

在一个叫做数据路径的东西中覆盖东西，我们将在将来更详细地介绍数据路径，呃，讨论情况，但现在只需知道以下项目，所以我们有一台电脑，它是一个程序计数器，它是硬件的一部分。

它存储了我们当前正在执行的指令的地址，然后我们有寄存器，它是小块硬件，方便快捷，它存储cpu当前正在执行的任何值，然后我们有一个算术和逻辑，我们的ALU执行任何算术，所以加减法，乘法，司，或逻辑操作。

如位移位，或者和或异或操作，这就是我们的数据路径中基本上涵盖的内容，然后呢，我们能够使用我们的数据路径与一种内存交互，通过内存指令，根据我们想要的东西写入或读取数据，那么风险五到底是什么。

风险五代表减少教学，顺便说一下，加州大学伯克利分校发明了五台计算机，所以这是一件值得骄傲的事情，风险五本质上是指令集架构，这是一个由CPU和主存组成的系统。

它还使用一种由简单指令组成的汇编语言来完成单个任务，CPU的作用是，它负责计算，如果你，CPU接受一个和指令，并执行任何必要的操作，以确保进一步的指令获得必要的输出，然后是主内存乔丹的长期数据，哪个呃。

我们在前面的图表中提到了一点，但它展示了我们如何，您可以通过使用某些指令来与主存和我们的数据路径交互，然后CPU可以通过寄存器存储内存，登记册，它们是CPU中存储二进制文件的硬件组件，他们在风险5，呃。

我们有三个两个寄存器，它们每个最多存储三个二位寄存器编号为0到3 1，所以x 0到x 3 1，在五号危险区有一个很特别的，也就是鸡蛋0和x 0只存储0的值，它不能储存，您不能修改该值，它总是被设置为零。

要知道的一件事是寄存器不是变量，你不能假设，仅仅因为您之前设置了寄存器值，这还没有完全一样，在你完成一组指令之后，它有可能会被保存下来，或者类似的东西，呃，到目前为止还有什么问题吗，好啦。

所以我们可以去，我们要开始检查说明书，我强烈推荐的是，就像我提到的，早些时候，当人们慢慢涌入，就是看看六一C参考卡，它将包含我们所有的指示，说明的名称，以及每条指令如何工作的描述。

如何和一个叫做操作码的东西，放克三号和放克七号，呃，它没有，如果你现在还不明白，别担心，我们将在以后的讨论中讨论这个问题，好啦，所以冒险五集会，每当有危险的时候，我们通常有指令。

指令通常是在我们有指令名的格式中，然后我们就有了目的地寄存器，然后我们的操作数，可以是两个源寄存器，也可以是一个源寄存器，和一个即时的，从理论上讲，你可以在每一项旁边加上逗号，你在写指示。

你把指令放进去，但是呃，没关系，不管你有没有加逗号，这仍然是我想我实际上会推荐的东西，使您的代码看起来更干净，然后使用哈希符号编写注释，很像Python，然后我们有寄存器呼叫，然后我们有一组寄存器。

它们以某些方式起作用，取决于他们的名字，所以我们有一个零，所以我们有我们的s寄存器，它们都是零，是一点，然后是两点到十一点，它们充当保存寄存器，然后嗯，现在，我们只需要知道它们是保存的寄存器，呃。

他们会的，当我们报道呼叫约定时，会更有意义，为什么它们被称为保存寄存器，然后我们有T 0，两个，三二六，又是临时寄存器，当我们打电话给林大会，那也更有意义，为什么它们也被称为临时寄存器。

然后我们从0到7，呃，通常每当我们调用风险五计划，呃，指示，我们传入函数的任何类型的数据，通常存储在寄存器中，然后我们有r，它是一个回信地址，回信地址基本上是，假设我们把一个内部风险五环。

如果我们想把我们的地址，这样我们就可以回到我们从，我们会把那个地址，那台电脑，寄存器中的程序计数器，然后我们有堆栈指针，哪个是哪个是哪个存储堆栈的地址，正如我们所记得的，我们讨论了堆栈堆代码和静态代码。

这个sp只存储堆栈指针，我们会减少，每当我们想添加更多，我们希望在堆栈上存储任何新变量，所以算术指令我们的第一套指令，我们要复习一下我们的算术，这里有三种主要的算术指令，所以我们有加减法。

几乎就是把两个寄存器加在一起，把这个值放入一个新的寄存器，还有什么，然后耶，我们实际编写和注册的一个例子是这样的，加x三x二x一，因为我们的语法在本例中是我们的目标寄存器，然后源寄存器1和源寄存器2。

我们知道源寄存器中的值是存储在，呃，目标寄存器x3，呃，它将是x2之和的值，或者x 2中的值，加上x 1中的值，然后减法是同样的惯例，只不过它只是用了Sub，然后我们有两种班次。

我们有逻辑移位和算术移位，它们基本上是一样的，只有一个例外，我现在要看一下，我们需要知道的是，对于逻辑转移，每当我们移动任何一种二进制数，从右到左或从左到右，我们会在必要时追加零，然而。

我们不能对算术移位说同样的话，如果我们决定从右向左移动，我们就不能，或者是的，从右到左，那么是的，可以追加零，但是，如果你从左向右移动，你有任何类型的数字，你附加到，MSV必须等于MSB，例如。

如果我们把二进制数，如果我们转移，如果我们做一个向右的算术移位，我们可以做的就是加上我们可以去掉这个零，然后在后面加一个零，但是，在二进制数是1-1-0的情况下，发生的事情是，我们会，从理论上讲。

我们可以从理论上摆脱这个零，我们会代替，但因为我们的MSB是一个，我们必须向MSB预先准备一个，所以这就是我们的转变，两者对乘法和除法都很有用，逻辑转移，尤其是对于无符号数的乘除，然后你有算术移位。

适用于无符号数和有符号数的乘法，但它对正弦数的除法很好，呃，有人对转移有什么问题吗，是呀，你刚才举的一个例子，即使你把它移位了，呃，离开了大，是呀，当最有效的位是1时离开，你也不必加一个，嗯等等。

请您再说一遍好吗？所以这就像，你知道这个例子，你就会得到1 1 0 0，你把它移到那边，是啊，是啊，嗯，你为什么要喜欢，加一个，因为什么时候已经有一个了，不管怎么说，那里，不是我要左移的原因。

这次我们做了一个正确的转变，好啦，是啊，是啊，左移，是啊，是啊，我们会在末尾加上零，否，不管是算术移位还是逻辑移位，所以如果你有一个和一个移动左边三个两个位，所以它变成了负数，所以只有一号，是啊，是啊。

好啦，所以在数字中，如果我们假设它是三个二位，我们可以假设在十六进制中，我们可以很容易地把它写成零x零，零零一，意味着四位数意味着，这意味着每个零等价于四个二进制零，然后你的问题是。

如果我们在4点31分后向右或向左移动，好啦，所以第一个应该是一个，而且MSB变成了一个，所以它变成了一个负面的，是啊，是啊，它本质上确实变得消极，而且是的，似乎你必须对这样的事情保持谨慎。

尤其是当涉及到符号数字时，你转移得越多，很有可能变成负数，如果你自己去做MSB，是啊，是啊，也是为了算术红移，如果你移动32次，第一个是一个，所以它就变成了，否则哪个是哪个不是数字，嗯，数字。

我会说我们在这里表示的数字是二的补数，所以不是数字，我相信是浮点，呃，我们不必为此担心浮点运算，是啊，是啊，有办法实施浮点和风险五顺便，但那超出了课堂的范围，所以呃，呃，这里有个问题，所以我想澄清一下。

所以如果你是负数，如果算术移位，对不起对，它总是会答应，我们只是简单地添加了一个，我们在MSC那边留了一个，这样就保留了它的消极部分，嗯，我想快点，呃，这里有几个例子来说明转换是如何工作的。

算术和逻辑算术移位和逻辑移位，所以我们做算术的指导是正确的，班在哪里，我们的决赛，我们的末端代表着，我们要移动多少位，我们在这里做的是，呃，正如我前面提到的，我们除掉，我们去掉右边的数字，但在左边。

我们准备了一个，因为我们的MSV是一个，我们保持这种状态，是啊，是啊，对于斯里兰卡来说，而不是把它转移到，是啊，是啊，对于斯里兰卡来说，在这种情况下，这是合乎逻辑的右移，我们会，我们不在乎MSV是什么。

我们总是在后面加上零，然后是一个S lli或Sr，我是我们的李或者是的，Lli，当我们轮班的时候，我们也会加上零，然后对于，如果我们也做一个算术左移，是啊，是啊，有人对运输有什么最后的问题吗，好啦。

所以考虑到这一点，我们有一件事我想尽快谈谈，是立竿见影的，正如我们之前看到的，我们在我们的sr ai说明中，我们在最后有一个数字，这个数字就是我们所说的中间数，而直接数是一个数字常数，它是2的补语。

所以这是非常重要的事情，这就是为什么我们报道转移，因为2的补语，它们经常以代码的形式出现，而且对他们有特别的说明，呃，有一种特定类型的指令，在这种情况下，其中一个例子是add i指令。

我们要做的是添加排序，我们在源寄存器中的值上加上十，在这种情况下是x2，然后把它加到x3，语法与add指令几乎相同，但我们可以，但是我们有一个数字，它存储在我们的第二个源寄存器所在的地方，而不是第二种。

举个例子，正如你在这里看到的，加将等于它，如果我们能加x 2 x 1 x 0，或者如果我们想用一个即时的，我们可以加i，x 2 x 1，那么我们的直接等于零，考虑到这一点。

我想复习一下工作表上的一个子问题，我相信这是二号，我想这是第一个，呃，三号中的三号，是啊，是啊，所以花几分钟，请随意与邻居聊天，如果您不确定语法是如何工作的，请随时询问我们，你有什么详细的问题吗。

聊天里有个问题，立即的范围是多少，我现在还不知道，我以为它就像一个32位的价值，但我可能错了，所以它可能是一个三二位二补码，但我想这是三个二位二的补语，因为我是说，如果你决定表示一个二三二位的无符号数。

这很容易被翻译成2的补语，当你做加法之类的，我去查查文件，很快的，我想要两千，我们已经讨论过了，哦，你有吗，好啦，我告诉你的iPhone的名字，好啦，好的很好，如果你想储存一个更大的，比两千块还快。

我们会被称为，有一个伪指令可以为您做到这一点，称为load mediate，那就是我们不会，我们在今天的讨论中可能不会涉及这一点，但这只是要知道的一件事，你们和缩放听到回应了吗，除非你能拿起，确保你。

媒体对前三名其他人有一个更好的，对不起，请您再说一遍好吗？编写代码时，我们可以用什么寄存器，我知道怎么用，类似于临时寄存器，我们也用像，你可以用s，但是有一个特定的语法，你得遵循某种惯例，所以嗯。

我可以简单介绍一下，因为被称为保存寄存器，我们要做的是确保，如果我们从，想要访问S寄存器，调用新函数后，必须是一样的，所以新函数要做的是存储，将s寄存器存储到堆栈中，并将s寄存器的值存储在堆栈上。

如果他们想使用任何特定的s寄存器，最后他们把它们装回去，然后原始函数可以访问与寄存器相同的，像以前一样调用函数，是呀，你说过，寄存器没有数据类型，是自我约定，这是不是像，与那个想法不同，就像一个数据。

我去开会，您可以将开始视为只需要从一个开始，好啦，我想我们现在可以开始了，所以在我们的C代码的第一行，我们有int a等于4，B等于五，C等于6，有谁知道将军，我们会使用指令来做第一行的每一个设置。

我想和我是的，我会工作得很好，所以如果我们决定使用，为a b和c加上眼睛，我们能做的就是，加上i，在这种情况下，如果我们想把a设置为4，我们必须等于零，然后我们希望它等于四，所以我们可以做x 0然后4。

然后我们把同样的原理应用到b和c，所以它是加i s 1 x 0和5，再加上i 2 6 0和6，最后我们有了最后一句台词，在z处等于a+b+c+10 um，我们会有多少不同的指示，会。

我们需要专门用于这条线路，哪个名字，呃，C代码的第二行，是的为了很多指示为了指示，是啊，是啊，我是在暗示像你一样，你得用，添加和添加i，因为您在末尾有一个新的媒体，但是是的，看来你们都明白了。

呃我有个问题，是啊，是啊，我们也能立即装载零号吗，是的，嗯，我会我实际上建议只使用加载立即，因为这比在零x零4处写作要容易得多，对于那些想知道，嗯加载立即是一个伪指令，在伪指令中发现，参考表的一部分。

它是，它几乎只是添加i，你的寄存器，x，零，任何你想要的即时，但可能会有一种情况，你想要一个更大的即时，这种伪吸引力也涵盖了，是啊，是啊，所以考虑到这一点，我可以随便写，这一行被转换为风险五。

所以这将是，我哦对不起，因为我们将在这里使用寄存器，如果我们知道z等于s3，我们做的是3x0，或者实际上我可以让这变得更容易，通过做s 0和s 1，然后我们加嗯三三和二，然后加i。

3等于3等于10对每个人来说都有意义吗？是呀，所以我们需要初始化，嗯你其实没有，因为呃，我们已经知道我们的值在零点和零点会是什么，好像有什么额外的价值，如果从s 3开始有任何值，呃。

s 0和s 1之和将覆盖s 3中已经存在的内容，所以取而代之的是，如果我们不把3等于零，如果我们三等于三等于零，那我们就得排队了，是呀，是啊，是啊，因为这意味着你会假设s3等于零，因此。

我们将继续我们的下一组指令，其中涉及控制，控制的主要思想是，通常在一个，在正常的五险功能中，你会看到，呃，按顺序执行的指令，什么，如果您想确保在某种情况下跳转到不同的指令，或者您想跳转到另一个函数。

它位于程序计数器中，这不是立即，这不像你目前正在使用的指令旁边，这就是控制的用武之地，然后我们有两种不同的控制函数，所以我们有一个分支，它非常类似于，有点像，if else语句，然后它，它会。

分支实际上会工作，它会跳到，呃一个P，它将跳转到一台新的PC上，如果，如果满足条件，所以，例如，我们这里的分店指示是B E Q B G，B g e u d l t和B o tu，所以BQ会分支会去。

标签指向的任何东西都将流向PC，如果RS是1等于，如果rs1的值等于rs2的值，然后对于bge，如果rs 1大于，它就会分支，或者rs1的值大于或等于rs2，然后为了一个BG U，它是，这是一回事。

但它对待中间人在第一和第二我们没有签名，对英国电信来说，它是否会分支，如果rs是1小于rs 2，然后BTU是一样的，除了它假定存储在rs 1和rs 2的即时数据是无符号的。

然后我们有我们的跳转和链接指令，即无条件跳跃，意味着无论发生什么，不管什么情况它都会跳，它将R rd值设置为PC加4，原因是如果我们决定以某种方式跳跃，如果我们决定跳转到另一个函数设置。

Rd到P C加4将保证，如果我们决定跳回我们返回中存储的任何东西，在我们的退货地址寄存器中，当我们跳到那个，它就会变成p等于4，然后耶，它跳到标签，有两个和伪指令存在于。

当我们不需要下一张幻灯片的链接时，我们将更详细地讨论这一点，所以我们有j标签，它等价于凝胶x零标签，这意味着您将跳转到另一行代码，但你不在乎你从哪里来，你只是要去另一个地方，然后是jr x 1。

也就是jer x 0 um，然后让我先看看凝胶和乔，所以通用电气正在加入链接，所以它把我们的rd设置为p c加4，然后它将我们的PC设置为PC加偏移，偏移量是我们标签上指定的。

然后我们有Jer Rd Rone和M，所以rd再次设置为pc+4，但在这种情况下，是啊，是啊，我是说，啊，好啦，所以一台电脑而不是我们的Jer，我们假设我们的回信地址存储在我们要去的地方的A中。

存储在寄存器中，所以我们的电脑将被设置为RS 1加上媒体，是啊，是啊，是啊，是啊，嗯，你提到当指示，呃，喜欢吗？因为那个指示无关紧要，你来自哪里，或者当你知道来自，是啊，是啊，哪里。

但这和这些有什么关系，我是说，它不是开始利用目标，就像我来自哪里，因为有些情况下你需要跟踪，你来自哪里，因为在我们的凝胶教学中，我们有一个RD，如果我们想知道，如果我们想回到我们来的地方。

或者继续从那里走下去，我们实际上必须在我们的RD中存储我们想要的任何价值，这样我们以后就可以跳回它了，如果我们不在乎它从哪里来，Rd简单地设置为x零，我们看到的是一个重要的，你从哪里来，它会自动跳回来。

开始，是啊，是啊，所以嗯，这是假设你要去的地方你的新风险五标签，它有一条指令跳回存储在rd中的地址，嗯，那样的话，难道这不重要吗？无论你来自哪里，因为你无论如何都可以引入跳回标签，就是说。

你总是可以用嗯来结束电话，你知道跳回标签，然后再回去，因此是真的，但又一次，这取决于你的rd是像一个实际的寄存器还是x零，如果是x 0，我们不能修改它，所以我们叫它，我们不在乎你来自哪里。

因为我们不会再回到，我们从哪里调用函数，这有道理吗，你能解释一下，好啦，是啊，是啊，所以凝胶，我们指定rd，呃好吧，其实呢，这两个罐子和罐子是一样的，但是，但最重要的是这是一个相似之处，但不同的是。

在凝胶中，我们提供了一个标签，这几乎是一个即时的，然后我们做的是，我们设置PC将等于PC加偏移量，但对狱卒来说，我们指定了一个寄存器，它将程序计数器的一部分存储到我们要去的地方。

所以我们要做的是把我们的PC设置为rs 1，加上即时，如果有道理的话，就像你在指定一个寄存器，你想去杰里，但你没有，你几乎不需要为凝胶指定任何寄存器，还有其他问题吗？所以你不在乎回来，如果你专门用像零。

当我们看下一张幻灯片时，它会更有意义，下一张幻灯片，所以呃，几个学期前我做了这个幻灯片，这是呃，这就说明了JZhao Jer和JR的区别，因为它们看起来都很相似，但他们也都很不一样，所以嗯，在我们有。

呃，J和凝胶，这将假设我们的标签是提供的，但是我们想用JJ，如果我们打完电话后不想回来，因为j等于gex零，如果我们打完电话后想回来，我们必须使用地理，嗯，因为凝胶凝胶，如果我们只写凝胶。

这相当于凝胶或，这意味着我们的回信地址存储在我们的寄存器中，然后在新的，然后新的标签，你跳到那里，如果有一个登记册上写着j r r a或类似的东西，我们可以回到收银台，好啦，然后呃。

我们有jr和jer的区别，所以主要的，所以现在我们正在使用一个实际提供的寄存器，现在我们得考虑打完电话后是否不想回来，或在通话后返回，所以在这里的情况下，嗯小J几乎等于杰鸡蛋零，我相信呃等于罐子，是零。

我想是的，它在，这是一辆参考车，嗯对于那些好奇的人来说，但是是的，我是，我是对的，是一个罐子x零，或者我不知道，我在试句号，好啦，哎呦，你有一个问题，是的为了确认黄金的归还，仅在风险文件的上下文中。

向右跳跃，是呀，你可以在翻译中说，我可以晚点再看，我正在打回复，我没有，哦不用担心，好啦，然后Jer几乎是假设我们在电话后回来，然后我们的寄存器就提供了，我相信这等于罐子，这个，我相信不要相信我的话。

但我相信这等于贾勒，R a然后什么的，然后你就有了你的任何登记册和即时，我想真正明确的，对用户来说有点不必要，你只需要想想我是不是要跳到一个标签上，把范围缩小到两条指令。

我是不是跳转到一个存储在寄存器中的地址，把范围缩小到另外两个，是啊，是啊，想想你所拥有的，你需要去的地方，好啦，有人对此有疑问吗，是呀，那么我们的，正如我前面所指出的，A是寄存器。

我们三个两个寄存器中的一个，通常A是用来存储我们的回信地址的，如果我们决定，呃，就像跳出来，就像储存我们的RD，我们可以解决，是啊，是啊，几乎是商店，呃，在我们执行完我们的新函数后，我们想回到哪里。

我想回到艺术上，是的通常你会做的，如果你想回医院，我们会用JR RA，这相当于一个叫做rat的伪指令，但就今天的讨论而言，这个Jr a很重要，还有其他问题吗？有一件事我想指出的是，任何直接的，那就是。

在任何跳转指令或分支指令中，是到达下一条指令的偏移量，不是实际的，嗯指令地址，期中考试有个问题，关于期中考试，我把它解释了，我把它，就在考试结束前两分钟，然后我意识到，哦等等，是偏移量。

所以我就像匆匆忙忙地计算，两者的互补，就像，我觉得是负2 4之类的，我没有足够的时间做这件事，一个非常，呃，分支和控制指令的良好使用通常是如果我们想循环，这方面的一个例子就在这里。

所以这里的通用代码是bg e x11x13dun，所以从字面上看，这意味着如果x11，如果x11处的值大于或等于x13处的值，然后我们跳到其他地方，如果我们不，如果我们不跳，我们要做的是把9加到。

我们会把4加到x9，然后我们把1加到x上，我们会在x11上加一个，然后我们简单地调用j循环，这样我们就可以回到循环的开始，继续下去，直到我们到达分支指令，然后在我们完成后跳转完成，是呀。

你需要像杰伊·莫托一样，如果你没有j循环，自动转到标签完成，或者你需要叫什么，简，呃，它会自动完成，好啦，在汇编代码中记住，我们逐行执行，从字面上看，然后耶，如果你想在编码中跳来跳去，明明白白的说。

你需要在公园里写什么吗，嗯，通常在我们想遵守调用约定的情况下，这是完成的标签，退出标签通常用于恢复我们的寄存器并获得我们的RA，如果我们决定拯救它，然后我们一般地跳回来，是啊，是啊，所以对R R A。

通常当我们开始召集会议时，那就更有意义了，还有其他问题吗？这是风险五如何使用的第二个最重要的部分，我们要讨论的第一个最重要的部分，在我们做完这个问题之后，这里的这些问题，好啦，在第一个问题的左边。

我们有几个C代码，我们想通过，然后在底部这里，我们有风险五代码，应该翻译回C，去吧，和你的邻居谈谈，如果你得到的代码有点不稳定，为了嗯，为了风险五看，不用担心，有一种方法可以让它变得更简单，是啊，是啊。

你画画的原因，就像这个例子中的j一样，有什么原因，A，嗯，我想就今天讨论的目的而言，我们想强调使用凝胶和Jer，你可以很容易地使用，J，很抱歉有人看了录音，我完全忘了继续录音，好啦。

然后这里我们要做的主要事情是如何做，s 1等于s 1，加一个，正如我前面提到的，等于s 1乘以2，然后耶，我们就是这么做的，作为for循环，那里有，是啊，是啊，等等，你能重复一下我们为什么用。

或者喜欢它的样子，为了下巴，像女孩一样，就像，那是什么来着，好啦，所以呃，像零一样，正如我提到的，相当于J，每当我们有J的时候，基本上意味着我们要跳到任何，我们的任何地址都是由我们的标签指定的。

但我们不一定要储存我们来自哪里，我们不想我们不会储存我们的回信地址，因为我们只想继续这个循环，我们再次，我们不在乎我们从哪里来，我喜欢用这个比喻，呃，对此有什么问题吗，我不知道你有没有提到这个。

但为什么下一个零，哦，是的，嗯，所以记住凝胶会在争论中，我们的第一个论点是一个寄存器，在这种情况下，寄存器就是我们的回信地址，因为它是零蛋，请记住，我们不能在x零寄存器中存储任何东西，它总是被设置为零。

所以这就是为什么，呃，当我们做凝胶像零，我们有点忘了，事实上，我们是从这里来的，我们把这个寄信人地址，好像那是我们遗忘的方式，我们从哪里来，我们不存储回信地址，是啊，是啊，为什么不说，简，是啊，是啊。

我们也可以说j循环，它等价于jx零，是啊，是啊，Jo就像一个双手伪指令，是呀，J jr是伪指令，连接得怎么样，你不能用它们，只是如果你在原始风险五代码中看到它，它会被翻译成像零或乔尔零这样的凝胶。

这就是发生的事情，是呀，你可以在金星上看到这个，对就像实际上，是呀，嗯嗯，如果你写得像j循环，然后你把它组装在金星上，你会看到的不仅仅是Jagzero，但你也会看到，我相信你会看到实际的，呃。

存储循环的偏移量，就像你是一成不变的，即使你是，嗯，他们实际上是继续通过它，不会抛出错误，数据路径的结构是这样的，所以任何东西都不会被修改到外部，不可变，是呀，所以调用函数，你要用其他JA吗，是呀。

理论上你会使用凝胶或Jer，因为如果你只是你，如果你做一些直接的凝胶循环，这几乎相当于说凝胶或循环，所以几乎把我们的回信地址存储在我们的A中，然后我们完成这个功能之后，嗯哦是的，在你们离开之前，嗯。

我们有正常的，呃，反馈表，所以请花一点时间填好这张表，我们真的真的很感激你的反馈，我们可能正在修改我们进行讨论的方式，所以说，那实际上是下周的，是啊，是啊，今天的讨论也将被加载和存储，但是是的。

我们没有足够的时间，我可以问一个，是啊，是啊，所以我是你们第一个，为什么我们有，所以说，我确实想要一种感觉一根树枝，如果他上了，是呀，我们还是去上学吧，如果这不是正在发生的事情，为什么实际上，哎呦。

差不多就这样定了，那只是设定零的一种花哨的方式，零x零零到零，我能不能简单地修改为0到0，随你喜欢添加。



![](img/59a245bc5109ea1f0ba3e60006f2c96c_2.png)

哦耶，你可以做的加载中位数指令。