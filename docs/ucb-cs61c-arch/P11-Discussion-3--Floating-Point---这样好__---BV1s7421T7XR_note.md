![](img/37fa218aab3f8799c75c11cf31b92344_0.png)

# 课程 P11：讨论课 3 - 浮点数与 C 语言内存管理 🧠💾

在本节课中，我们将学习 C 语言中的内存管理分区，以及浮点数的 IEEE 754 标准表示方法。我们将通过具体示例来理解这些核心概念。

## 概述 📋

本次讨论课将分为两部分。首先，我们将回顾 C 语言程序运行时内存的四个主要分区：栈、堆、静态区和代码段。其次，我们将深入探讨浮点数的表示，特别是 IEEE 754 标准，学习如何在小数和二进制浮点表示之间进行转换。

---

## C 语言内存管理 💻

上一节我们介绍了课程的主要内容。本节中，我们来看看 C 程序运行时内存是如何组织的。

C 程序的内存主要分为四个分区：

*   **栈**：主要用于存储局部变量、函数参数和返回地址。栈内存由编译器自动管理，函数调用时分配，返回时释放。
    *   **公式示例**：当一个函数 `func(int a)` 被调用时，参数 `a` 的值会被复制到栈上的新位置。
*   **堆**：用于动态内存分配，通过 `malloc`、`calloc` 等函数手动申请，使用 `free` 函数手动释放。
    *   **代码示例**：`int *arr = (int*)malloc(10 * sizeof(int));`
*   **静态区**：存储全局变量、静态变量（`static` 关键字）和字符串字面量。该区域在程序整个生命周期内存在。
    *   **代码示例**：`static int count = 0;` 或 `char *str = "Hello";` 中的 `"Hello"`。
*   **代码段**：存储程序的机器指令（代码）和只读常量（如一些宏定义）。

以下是关于字符串在内存中存储位置的一个重要区别：

*   `char arr[] = "Hello";`：字符串字面量 `"Hello"` 存储在静态区，但其内容会被复制到栈上为新数组 `arr` 分配的空间中。因此，可以修改 `arr` 的内容。
*   `char *ptr = "Hello";`：指针 `ptr` 直接指向存储在静态区中的字符串字面量 `"Hello"`。尝试通过 `ptr` 修改内容通常是未定义行为。

关于动态内存分配，`malloc` 和 `calloc` 的区别如下：
*   `malloc(size)`：分配指定字节数的内存，不初始化内容（内容随机）。
*   `calloc(num, size)`：分配 `num` 个大小为 `size` 的元素空间，并将所有位初始化为 0。

---

## 浮点数表示 🌊

理解了内存的基本分区后，本节我们来看看计算机如何表示浮点数。

我们使用 **IEEE 754 单精度**标准。它将 32 位分为三个字段：
*   **符号位 (1 bit)**：`0` 表示正数，`1` 表示负数。
*   **指数位 (8 bits)**：采用 **偏置表示法**。实际指数 = 无符号指数值 - 127。
*   **尾数位/有效数字位 (23 bits)**：存储规格化后二进制小数的小数部分（即省略掉开头的 `1.`）。

浮点数主要有两种类型：
*   **规格化数**：当指数位不全为 0 且不全为 1 时。这是最常用的形式，能表示非常大和非常小的数。
    *   此时，尾数隐含一个前导的 `1.`。值为：`(-1)^符号位 × 1.尾数(2) × 2^(指数-127)`
*   **非规格化数**：当指数位全为 0 时。用于表示非常接近 0 的数。
    *   此时，尾数隐含一个前导的 `0.`，且指数固定为 -126。值为：`(-1)^符号位 × 0.尾数(2) × 2^(-126)`

---

## 转换练习 🔄

上一节我们介绍了浮点数的结构，本节中我们通过一个具体例子来练习从十进制到浮点表示的转换。

**问题：将十进制数 39.5625 转换为 IEEE 754 单精度二进制表示。**

**步骤 1：处理符号**
39.5625 是正数，所以 **符号位 S = 0**。

**步骤 2：分别转换整数和小数部分为二进制**
*   整数部分 39：`39(10) = 32 + 4 + 2 + 1 = 100111(2)`
*   小数部分 0.5625：`0.5625(10) = 0.5 + 0.0625 = 0.1001(2)`
*   合并：`39.5625(10) = 100111.1001(2)`

**步骤 3：规格化二进制数**
将二进制小数点左移，使其左边只有一位 `1`。
`100111.1001(2) = 1.001111001(2) × 2^5`

**步骤 4：确定指数字段**
实际指数 E = 5。
偏置指数 = E + 127 = 5 + 127 = 132。
`132(10) = 10000100(2)`
所以 **指数位 Exp = 10000100**。

**步骤 5：确定尾数字段**
从规格化形式 `1.001111001` 中，取小数点后的部分，并在右侧补零至 23 位。
尾数 M = `00111100100000000000000`。

**步骤 6：组合**
最终 32 位表示为：`S | Exp | M`
`0 | 10000100 | 00111100100000000000000`
转换为十六进制更紧凑：`0x42272000`。

---

## 总结 🎯

本节课中我们一起学习了：
1.  **C 语言内存管理**：程序内存分为栈、堆、静态区和代码段。我们比较了 `malloc` 和 `calloc`，并区分了字符数组与字符指针初始化字符串时的内存差异。
2.  **浮点数表示**：深入理解了 IEEE 754 单精度浮点数的标准，包括符号位、偏置指数位和尾数位的含义，以及规格化与非规格化数的区别。
3.  **转换方法**：通过逐步演示，掌握了将十进制小数转换为 IEEE 754 二进制格式的方法。

![](img/37fa218aab3f8799c75c11cf31b92344_2.png)

理解这些底层概念对于编写高效、正确的 C 程序至关重要，也是后续学习计算机体系结构的基础。