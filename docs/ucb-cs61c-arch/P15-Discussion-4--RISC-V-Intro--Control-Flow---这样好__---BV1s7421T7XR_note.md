![](img/59a245bc5109ea1f0ba3e60006f2c96c_0.png)

# 课程 P15：RISC-V 介绍与控制流 🚀

在本节课中，我们将学习 RISC-V 架构的基础知识，包括其指令集、寄存器以及控制流指令。我们将从 C 语言代码翻译到 RISC-V 汇编，并理解程序如何在底层执行。

---

## 概述

RISC-V 是一种精简指令集计算机（RISC）架构，由加州大学伯克利分校发明。本节课将介绍 RISC-V 的基本概念，包括数据路径、寄存器、算术指令和控制流指令。我们还将学习如何将简单的 C 语言代码翻译成 RISC-V 汇编代码。

---

## 数据路径简介

在深入了解 RISC-V 指令之前，我们需要理解计算机数据路径的基本组成部分。数据路径是处理器中执行指令的硬件路径。

计算机包含以下几个关键部分：
*   **程序计数器（PC）**：存储当前正在执行的指令的地址。
*   **寄存器**：CPU 中的小块高速存储单元，用于存储当前正在处理的值。
*   **算术逻辑单元（ALU）**：执行算术（加、减、乘、除）和逻辑（移位、与、或、异或）操作。
*   **主内存**：用于长期存储数据。CPU 可以通过特定的加载和存储指令与主内存交互。

---

## 什么是 RISC-V？

RISC-V 代表“精简指令集计算机，第五代”。它是一种指令集架构（ISA），定义了由 CPU 和主内存组成的系统的工作方式。RISC-V 使用一种由简单指令组成的汇编语言，每条指令完成一个单一任务。

CPU 负责执行计算。它接受指令并执行必要的操作以产生输出。主内存用于长期存储数据。寄存器是 CPU 中存储二进制值的硬件组件。

在 RISC-V 中，有 32 个通用寄存器，编号为 `x0` 到 `x31`。其中有一个特殊的寄存器 `x0`（零寄存器），它硬连线为值 0，且不可更改。

**重要提示**：寄存器不是变量。不能假设在指令序列执行后，寄存器中的值会保持不变。

---

## RISC-V 指令格式

RISC-V 汇编指令通常遵循以下格式：
`指令名 目标寄存器， 源操作数1， 源操作数2`

操作数可以是两个源寄存器，也可以是一个源寄存器和一个立即数（常数）。使用逗号分隔和井号（`#`）添加注释可以使代码更清晰。

寄存器根据其命名约定有不同的用途：
*   `x0`：零寄存器。
*   `s0`-`s11`：保存寄存器。在函数调用后，其值必须保持不变。
*   `t0`-`t6`：临时寄存器。函数可以自由使用，调用者不期望其值被保存。
*   `a0`-`a7`：参数寄存器。通常用于向函数传递参数。
*   `ra`：返回地址寄存器。存储函数调用后应返回的地址。
*   `sp`：堆栈指针寄存器。存储当前堆栈顶部的地址。

---

## 算术指令

上一节我们介绍了指令的基本格式，本节中我们来看看用于计算的算术指令。RISC-V 提供了多种算术指令。

以下是主要的算术指令类型：

**加法与减法**
*   `add rd, rs1, rs2`：将寄存器 `rs1` 和 `rs2` 中的值相加，结果存入 `rd`。
    *   **公式**：`rd = rs1 + rs2`
*   `sub rd, rs1, rs2`：将寄存器 `rs1` 的值减去 `rs2` 的值，结果存入 `rd`。
    *   **公式**：`rd = rs1 - rs2`

**移位操作**
移位操作对乘法和除法非常有用。有两种主要类型：
1.  **逻辑移位**：移位时，空出的位用 `0` 填充。
2.  **算术移位**：右移时，空出的位用**最高有效位（MSB）** 的值填充，这可以保持有符号数的符号。

*   `slli rd, rs1, imm`：逻辑左移。
*   `srli rd, rs1, imm`：逻辑右移。
*   `srai rd, rs1, imm`：算术右移。

**立即数指令**
立即数是一个编码在指令中的常数。例如：
*   `addi rd, rs1, imm`：将寄存器 `rs1` 的值加上立即数 `imm`，结果存入 `rd`。
    *   **公式**：`rd = rs1 + imm`

立即数通常是一个 12 位的二进制补码数。如果需要更大的常数，可以使用伪指令 `li`（加载立即数）。

---

## 控制流指令

到目前为止，我们看到的指令都是顺序执行的。但在编程中，我们经常需要根据条件改变执行流程，这就是控制流指令的作用。

控制流指令主要分为两类：**条件分支**和**无条件跳转**。

**条件分支**
条件分支类似于高级语言中的 `if-else` 语句。如果条件满足，程序将跳转到一个新的地址（标签）执行。

以下是常见分支指令：
*   `beq rs1, rs2, label`：如果 `rs1 == rs2`，则跳转到 `label`。
*   `bne rs1, rs2, label`：如果 `rs1 != rs2`，则跳转到 `label`。
*   `blt rs1, rs2, label`：如果 `rs1 < rs2`（有符号比较），则跳转到 `label`。
*   `bge rs1, rs2, label`：如果 `rs1 >= rs2`（有符号比较），则跳转到 `label`。
*   `bltu rs1, rs2, label`：如果 `rs1 < rs2`（无符号比较），则跳转到 `label`。
*   `bgeu rs1, rs2, label`：如果 `rs1 >= rs2`（无符号比较），则跳转到 `label`。

**无条件跳转**
无条件跳转总是会跳转，不依赖于任何条件。它用于实现函数调用和循环。

*   `jal rd, label`：跳转并链接。将下一条指令的地址（`PC+4`）存入 `rd`，然后跳转到 `label`。
    *   这通常用于函数调用，`rd` 通常设为 `ra`（返回地址寄存器）。
*   `jalr rd, rs1, imm`：跳转并链接寄存器。将 `PC+4` 存入 `rd`，然后跳转到地址 `rs1 + imm`。
*   `j label`：这是一个伪指令，等价于 `jal x0, label`。它直接跳转到 `label`，但不保存返回地址（因为 `x0` 不可写）。
*   `jr rs1`：这是一个伪指令，等价于 `jalr x0, rs1, 0`。它跳转到 `rs1` 寄存器中存储的地址。

**关键区别**：
*   使用 `jal` 或 `jalr` 时，你会存储返回地址，以便之后能返回。
*   使用 `j` 或 `jr` 时，你不关心返回地址，只是单纯地跳走（例如，在循环末尾跳回循环开头）。

---

## 代码翻译示例

理解了算术和控制流指令后，让我们来看一个将 C 代码翻译成 RISC-V 汇编的简单例子。

**C 代码**：
```c
int a = 4;
int b = 5;
int c = 6;
int z = a + b + c + 10;
```

**RISC-V 汇编**（假设 `a`->`s0`, `b`->`s1`, `c`->`s2`, `z`->`s3`）：
```assembly
addi s0, x0, 4   # a = 4
addi s1, x0, 5   # b = 5
addi s2, x0, 6   # c = 6
add  s3, s0, s1  # z = a + b
add  s3, s3, s2  # z = z + c
addi s3, s3, 10  # z = z + 10
```
注意：我们不需要显式地将 `s3` 初始化为 0，因为第一条 `add` 指令会直接覆盖 `s3` 中原来的值。

---

## 总结

![](img/59a245bc5109ea1f0ba3e60006f2c96c_2.png)

在本节课中，我们一起学习了 RISC-V 架构的基础知识。我们从数据路径和寄存器的概念开始，然后学习了 RISC-V 指令的基本格式和命名约定。我们详细探讨了算术指令（如 `add`, `sub`, 移位）和立即数的使用。最后，我们深入研究了控制流指令，包括条件分支（如 `beq`, `blt`）和无条件跳转（如 `jal`, `j`），并理解了它们在实现循环和函数调用中的作用。通过一个简单的代码翻译示例，我们实践了如何将高级语言逻辑映射到底层汇编指令。掌握这些概念是理解计算机如何执行程序的关键一步。