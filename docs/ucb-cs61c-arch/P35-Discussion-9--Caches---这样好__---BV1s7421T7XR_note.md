![](img/7a01420a8f2bc3bfda2c21f9893fd08f_0.png)

# 课程 P35：缓存详解 🧠

在本节课中，我们将学习计算机体系结构中的两个核心概念：**数据与控制冒险**，以及**缓存**的工作原理。我们将从回顾冒险开始，然后深入探讨缓存的类型、结构和替换策略，帮助你理解它们如何提升计算机性能。

## 数据与控制冒险回顾 🔄

上一节我们介绍了流水线的基本概念，本节中我们来看看流水线执行时可能遇到的两种主要问题：数据冒险和控制冒险。

### 数据冒险

当两条指令之间存在数据依赖关系时，就会发生数据冒险。例如，第二条指令需要使用第一条指令的计算结果。在简单的单周期处理器中，这不是问题。但在流水线中，由于指令是重叠执行的，可能导致第二条指令在第一条指令将结果写回寄存器之前就去读取该寄存器，从而读到错误（旧）的值。

以下是解决数据冒险的两种主要方法：

*   **数据转发**：将执行阶段的结果直接传递到后续指令的解码或执行阶段，绕过写回阶段。这需要额外的硬件（如多路复用器）和控制逻辑。
    *   **公式/概念**：`EX/MEM.RegisterRd -> ID/EX.RegisterRs` （将前一条指令ALU的结果直接作为后一条指令的输入）
*   **流水线停顿**：插入空操作指令，使流水线暂停几个周期，等待前一条指令完成写回。这种方法简单但会降低性能。

### 控制冒险

当处理器需要根据条件判断（如分支指令）来决定下一条执行哪条指令时，就会发生控制冒险。在流水线中，在分支指令的执行阶段完成并计算出目标地址之前，后续指令可能已经被取指并进入流水线。如果分支被采纳，这些已被取指的指令就是无效的，需要被丢弃。

以下是解决控制冒险的两种主要方法：

*   **流水线停顿**：暂停取指，直到分支指令的执行阶段结束，明确知道下一条指令的地址。这同样会带来性能损失。
*   **分支预测**：预测分支是否会被采纳，并基于预测继续取指和执行。如果预测错误，则需要“清空”流水线中错误的指令，并转向正确的指令流。虽然预测错误有代价，但总体效率通常高于总是停顿。

**过渡**：理解了流水线中的冒险及其解决方案后，我们接下来将探讨一个用于解决内存访问速度瓶颈的关键技术：缓存。

## 为什么需要缓存？⚡

目前，我们的系统模型是处理器直接访问主内存。然而，访问主存（DRAM）的速度很慢，可能需要数十甚至上百个时钟周期。访问磁盘等次级存储则更慢。为了弥补处理器高速与内存低速之间的差距，我们引入了**缓存**。

缓存是一小块高速存储器，位于处理器和主存之间。它存储最近或经常被访问的数据副本，使得处理器在需要这些数据时，可以快速从缓存中获取，而无需访问慢速的主存。

使用缓存主要基于以下两个 locality（局部性）原理：

*   **时间局部性**：如果一个数据项被访问，那么它在不久的将来很可能再次被访问。缓存通过保留最近访问过的数据来利用这一点。
*   **空间局部性**：如果一个数据项被访问，那么其邻近地址的数据项也可能很快被访问。缓存通过一次加载一个数据块（包含目标地址及其相邻数据）来利用这一点。

**过渡**：现在，让我们看看缓存是如何集成到计算机系统以及它是如何组织的。

## 缓存的组织与结构 🏗️

在概念上，我们可以将缓存视为一个表格。缓存由多个**缓存行**组成，每个缓存行存储一个从内存加载来的**数据块**。每个缓存行还包含一些管理信息。

以下是描述缓存结构的关键术语：

*   **块/行**：缓存中存储数据的基本单位。
*   **组**：一个或多个缓存行的集合。
*   **索引**：用于定位缓存中特定组或行的地址部分。
*   **标记**：存储在缓存行中，用于唯一标识该行数据来自内存中哪个地址块。与索引一起，用于判断缓存命中或缺失。
*   **偏移**：地址中用于定位块内特定字节的部分。
*   **关联度**：衡量缓存灵活性的指标，决定了一个索引可以对应多少个缓存行。
*   **替换/驱逐**：当缓存已满且需要加载新数据时，选择移除哪个旧数据块的操作。

一个内存地址通常被划分为以下字段用于缓存查找：
`[ 标记 (Tag) | 索引 (Index) | 块内偏移 (Block Offset) ]`

**过渡**：根据关联度的不同，缓存主要有三种类型，它们各有特点。

## 缓存的三种类型 🗂️

### 1. 直接映射缓存

这是限制最严格的缓存。每个内存块只能被放到缓存中唯一一个特定的位置（由索引决定）。

*   **工作方式**：使用地址的索引位找到对应的唯一缓存行。然后比较该行的标记是否与地址的标记位匹配。如果匹配且有效，则为命中；否则为缺失。
*   **优点**：硬件简单，查找速度快（只需一次比较）。
*   **缺点**：冲突率高。如果两个频繁访问的内存块映射到同一个缓存行，它们会不停地相互驱逐，导致缓存效率低下。

### 2. 全相联缓存

这是限制最宽松的缓存。任何内存块可以被放置到缓存中的任何一行。

*   **工作方式**：没有索引位。需要将地址的标记位与**缓存中的所有行**的标记进行比较，以确定是否命中。
*   **优点**：冲突率最低，缓存空间利用率高。
*   **缺点**：硬件成本高，查找速度慢（需要与所有行比较），难以实现大容量。

### 3. N路组相联缓存

这是直接映射和全相联的折中方案，也是最常用的类型。缓存被分为若干组，每组有N个缓存行（N路）。

*   **工作方式**：使用地址的索引位找到对应的组。然后，需要将该地址的标记位与该组内**所有N个缓存行**的标记进行比较。
*   **类比**：可以想象成一个二维数组。索引决定行（组），然后在该行（组）的N个列（路）中查找匹配的标记。
*   **平衡**：通过调整路数N，可以在硬件复杂度、查找速度和冲突率之间取得平衡。例如：
    *   N=1 时，即为直接映射缓存。
    *   N = 缓存总行数 时，即为全相联缓存。

**过渡**：在组相联或全相联缓存中，当发生缓存缺失且对应组已满时，需要选择一个旧块进行替换。这就引出了替换策略。

## 缓存替换策略 🔄

当必须从已满的组中驱逐一个块以便为新块腾出空间时，就需要替换策略。以下是两种常见策略：

以下是两种常见替换策略的对比：

*   **先进先出**：选择在组内停留时间最长的块进行替换。实现简单，但可能替换掉仍然常用的块。
*   **最近最少使用**：选择在组内最长时间未被访问的块进行替换。这更符合时间局部性原理，通常能获得比FIFO更高的命中率，但实现起来更复杂（需要记录访问顺序）。

**代码/概念描述**：对于LRU，可以为组内的每个块维护一个“年龄”计数器，每次访问某块时将其年龄置为0，其他块年龄加1。需要替换时，选择年龄最大的块。

![](img/7a01420a8f2bc3bfda2c21f9893fd08f_2.png)

---

本节课中我们一起学习了流水线中的数据与控制冒险及其解决方案，并深入探讨了缓存技术。我们了解了引入缓存的原因、缓存的基本组织结构、三种主要的缓存类型以及常见的缓存替换策略。掌握这些概念对于理解现代处理器如何高效工作至关重要。