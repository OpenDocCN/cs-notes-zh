![](img/404243642bd2ec6770a46a09f840c44a_0.png)

![](img/404243642bd2ec6770a46a09f840c44a_2.png)

![](img/404243642bd2ec6770a46a09f840c44a_4.png)

![](img/404243642bd2ec6770a46a09f840c44a_6.png)

![](img/404243642bd2ec6770a46a09f840c44a_8.png)

![](img/404243642bd2ec6770a46a09f840c44a_10.png)

# 课程 P17：编译器、汇编器、链接器、加载器 🛠️

![](img/404243642bd2ec6770a46a09f840c44a_12.png)

![](img/404243642bd2ec6770a46a09f840c44a_14.png)

![](img/404243642bd2ec6770a46a09f840c44a_16.png)

![](img/404243642bd2ec6770a46a09f840c44a_18.png)

![](img/404243642bd2ec6770a46a09f840c44a_20.png)

![](img/404243642bd2ec6770a46a09f840c44a_22.png)

在本节课中，我们将学习程序从高级语言（如C语言）到最终在计算机上运行所经历的完整过程。这个过程通常被称为“CALL”，它代表编译（Compile）、汇编（Assemble）、链接（Link）和加载（Load）。我们将逐一拆解这些步骤，了解它们如何协同工作，将人类可读的代码转化为机器可执行的指令。

![](img/404243642bd2ec6770a46a09f840c44a_24.png)

![](img/404243642bd2ec6770a46a09f840c44a_25.png)

![](img/404243642bd2ec6770a46a09f840c44a_27.png)

![](img/404243642bd2ec6770a46a09f840c44a_29.png)

![](img/404243642bd2ec6770a46a09f840c44a_31.png)

![](img/404243642bd2ec6770a46a09f840c44a_33.png)

## 伪指令与真实指令 🔄

![](img/404243642bd2ec6770a46a09f840c44a_35.png)

![](img/404243642bd2ec6770a46a09f840c44a_37.png)

![](img/404243642bd2ec6770a46a09f840c44a_39.png)

上一节我们介绍了课程概述，本节中我们来看看伪指令的概念。在之前的课程中，你可能已经在RISC-V模拟器中使用过伪指令。伪指令是为了方便人类或编译器编写汇编代码而存在的，它们并不直接对应具有特定操作码和功能的机器指令，而是真实指令的快捷方式。

![](img/404243642bd2ec6770a46a09f840c44a_41.png)

以下是几个伪指令及其对应的真实指令示例：

![](img/404243642bd2ec6770a46a09f840c44a_43.png)

![](img/404243642bd2ec6770a46a09f840c44a_45.png)

*   **`mv rd, rs`**： 这条伪指令表示将寄存器`rs`的内容“移动”到寄存器`rd`。实际上，它被翻译为一条**`addi rd, rs, 0`**指令，即将`rs`的值加上立即数0，结果存入`rd`。
*   **`not rd, rs`**： 这条伪指令表示对寄存器`rs`的内容进行按位取反。实际上，它被翻译为一条**`xori rd, rs, -1`**指令。在二进制补码中，-1的表示是全1，因此与-1进行异或操作（XOR）就实现了按位取反的效果。
*   **`li rd, immediate`**： 这条伪指令表示将一个立即数加载到寄存器`rd`。根据立即数的大小，它可能被翻译为一条**`addi rd, x0, immediate`**指令（如果立即数在12位有符号数范围内），或者被翻译为**`lui rd, upper_20_bits`**后接**`addi rd, rd, lower_12_bits`**两条指令（如果立即数超过12位）。
*   **`j label` 和 `jr rs`**： 跳转伪指令。`j label`被翻译为**`jal x0, label`**，使用PC相对寻址。`jr rs`被翻译为**`jalr x0, rs, 0`**，使用绝对寻址（通过寄存器中的地址）。
*   **`la rd, label`**： 加载地址伪指令。它把标签`label`的地址加载到目标寄存器`rd`。汇编器会根据情况将其翻译为类似`li`的指令序列，可能涉及PC相对计算。
*   **`call label`**： 调用伪指令。它通常被翻译为**`jal ra, label`**，用于函数调用，同时会将返回地址保存在`ra`寄存器中。

![](img/404243642bd2ec6770a46a09f840c44a_47.png)

![](img/404243642bd2ec6770a46a09f840c44a_49.png)

理解伪指令有助于我们阅读编译器生成的汇编代码，并明白它们最终都会转化为标准的RISC-V机器指令。

![](img/404243642bd2ec6770a46a09f840c44a_51.png)

![](img/404243642bd2ec6770a46a09f840c44a_53.png)

![](img/404243642bd2ec6770a46a09f840c44a_55.png)

![](img/404243642bd2ec6770a46a09f840c44a_57.png)

![](img/404243642bd2ec6770a46a09f840c44a_59.png)

![](img/404243642bd2ec6770a46a09f840c44a_61.png)

## 程序翻译与运行概述 📁

![](img/404243642bd2ec6770a46a09f840c44a_63.png)

![](img/404243642bd2ec6770a46a09f840c44a_65.png)

![](img/404243642bd2ec6770a46a09f840c44a_67.png)

![](img/404243642bd2ec6770a46a09f840c44a_69.png)

![](img/404243642bd2ec6770a46a09f840c44a_71.png)

上一节我们了解了伪指令如何被翻译，本节中我们来看看将程序从源代码转化为可执行文件的整体流程。翻译是指将程序从一种语言（通常是高级语言）转换为另一种语言（通常是更低级的语言）的过程。这可以提高程序的效率和性能。

![](img/404243642bd2ec6770a46a09f840c44a_73.png)

![](img/404243642bd2ec6770a46a09f840c44a_75.png)

![](img/404243642bd2ec6770a46a09f840c44a_77.png)

![](img/404243642bd2ec6770a46a09f840c44a_79.png)

![](img/404243642bd2ec6770a46a09f840c44a_81.png)

![](img/404243642bd2ec6770a46a09f840c44a_83.png)

![](img/404243642bd2ec6770a46a09f840c44a_85.png)

例如，C语言是一种典型的编译型语言。它需要被编译和链接才能生成可执行文件。作为对比，Python通常是一种解释型语言，代码由解释器直接逐行执行，而无需预先编译成独立的机器码文件。

![](img/404243642bd2ec6770a46a09f840c44a_87.png)

![](img/404243642bd2ec6770a46a09f840c44a_89.png)

![](img/404243642bd2ec6770a46a09f840c44a_91.png)

![](img/404243642bd2ec6770a46a09f840c44a_93.png)

![](img/404243642bd2ec6770a46a09f840c44a_95.png)

![](img/404243642bd2ec6770a46a09f840c44a_97.png)

从C程序到运行该程序，主要经历以下四个步骤，合称为“CALL”：
1.  **编译（Compile）**： 将C源代码（`.c`文件）转换为汇编代码（`.s`文件）。
2.  **汇编（Assemble）**： 将汇编代码（包含伪指令）转换为机器代码目标文件（`.o`文件）。
3.  **链接（Link）**： 将一个或多个目标文件与所需的库文件合并，解析它们之间的引用关系，生成最终的可执行文件（如`a.out`）。
4.  **加载（Load）**： 操作系统将可执行文件加载到内存中，并为其创建运行环境，然后开始执行。

![](img/404243642bd2ec6770a46a09f840c44a_99.png)

![](img/404243642bd2ec6770a46a09f840c44a_101.png)

![](img/404243642bd2ec6770a46a09f840c44a_103.png)

![](img/404243642bd2ec6770a46a09f840c44a_105.png)

![](img/404243642bd2ec6770a46a09f840c44a_107.png)

![](img/404243642bd2ec6770a46a09f840c44a_109.png)

![](img/404243642bd2ec6770a46a09f840c44a_111.png)

我们通常所说的“将C编译成二进制”，指的就是前三个步骤。

![](img/404243642bd2ec6770a46a09f840c44a_113.png)

![](img/404243642bd2ec6770a46a09f840c44a_115.png)

## 编译器（Compile） ➡️

![](img/404243642bd2ec6770a46a09f840c44a_117.png)

![](img/404243642bd2ec6770a46a09f840c44a_119.png)

编译器是CALL流程的第一步。它的输入是高级语言（如C）编写的源代码文件（例如`foo.c`），输出是对应的汇编语言文件（例如`foo.s`）。

![](img/404243642bd2ec6770a46a09f840c44a_121.png)

![](img/404243642bd2ec6770a46a09f840c44a_123.png)

![](img/404243642bd2ec6770a46a09f840c44a_125.png)

![](img/404243642bd2ec6770a46a09f840c44a_127.png)

在CS61C课程中，我们经常扮演“人类编译器”的角色，手动将C代码逻辑翻译成RISC-V汇编代码。真正的编译器（如GCC）则自动化了这个过程。编译器不仅进行直译，还会应用各种优化算法来提高生成代码的效率。

![](img/404243642bd2ec6770a46a09f840c44a_129.png)

![](img/404243642bd2ec6770a46a09f840c44a_131.png)

![](img/404243642bd2ec6770a46a09f840c44a_133.png)

![](img/404243642bd2ec6770a46a09f840c44a_135.png)

编译器生成的汇编代码中可能会包含我们之前提到的伪指令，以及一些给汇编器的指示信息。

![](img/404243642bd2ec6770a46a09f840c44a_137.png)

![](img/404243642bd2ec6770a46a09f840c44a_139.png)

![](img/404243642bd2ec6770a46a09f840c44a_141.png)

## 汇编器（Assemble） ⚙️

![](img/404243642bd2ec6770a46a09f840c44a_143.png)

上一节我们介绍了编译器的工作，本节中我们来看看汇编器。汇编器接收编译器生成的汇编代码文件（`.s`文件）作为输入，输出一个机器语言模块，即目标文件（`.o`文件）。

![](img/404243642bd2ec6770a46a09f840c44a_145.png)

![](img/404243642bd2ec6770a46a09f840c44a_147.png)

这个目标文件包含了二进制形式的机器代码，但它还不是一个完整的、可独立运行的程序。除了将汇编指令（包括伪指令）翻译成机器指令外，汇编器还负责处理汇编文件中的**指示符（Directives）**。

![](img/404243642bd2ec6770a46a09f840c44a_149.png)

![](img/404243642bd2ec6770a46a09f840c44a_151.png)

![](img/404243642bd2ec6770a46a09f840c44a_153.png)

![](img/404243642bd2ec6770a46a09f840c44a_155.png)

![](img/404243642bd2ec6770a46a09f840c44a_157.png)

指示符是汇编器指令，它们本身不产生机器指令，而是指导汇编器如何构建目标文件。例如：
*   **`.text`**： 后续内容为代码（指令）。
*   **`.data`**： 后续内容为静态数据。
*   **`.global sym`**： 声明符号`sym`为全局符号，允许其他文件访问。
*   **`.string “abc”`**： 在数据段中存储字符串“abc”。
*   **`.word 0x1234`**： 在数据段中存储一个字（4字节）的数据。

![](img/404243642bd2ec6770a46a09f840c44a_159.png)

![](img/404243642bd2ec6770a46a09f840c44a_161.png)

一个目标文件（`.o`）通常包含以下几个部分：
1.  **文件头（Header）**： 描述文件结构和各段位置的信息。
2.  **文本段（.text）**： 所有指令的机器码。
3.  **数据段（.data）**： 所有静态数据的机器表示。
4.  **符号表（Symbol Table）**： 本文件中定义的标签（如函数名、全局变量名）及其（预计的）地址列表。
5.  **重定位信息（Relocation Information）**： 一个“待办事项”列表，记录了本文件中那些在汇编阶段无法确定地址的引用（如调用外部函数、引用其他文件的全局变量），需要链接器后续处理。
6.  **调试信息（Debugging Information）**： 用于调试器的附加信息。

![](img/404243642bd2ec6770a46a09f840c44a_163.png)

![](img/404243642bd2ec6770a46a09f840c44a_165.png)

汇编器在翻译时，对于像`beq`, `jal`这类使用PC相对寻址的指令，如果目标标签在同一文件内，它可以计算并填充偏移量。这个过程通常需要扫描汇编代码两遍（Two-pass Assembler）：第一遍记录所有标签的位置，第二遍利用这些信息来填充指令中的偏移量字段。

![](img/404243642bd2ec6770a46a09f840c44a_167.png)

![](img/404243642bd2ec6770a46a09f840c44a_169.png)

然而，对于引用其他文件符号（如`printf`）或引用静态数据地址的指令，汇编器无法在此时知道最终地址，因此它只能生成一个占位符，并将需要修复的位置和类型记录在“重定位信息”表中，交给链接器处理。

![](img/404243642bd2ec6770a46a09f840c44a_171.png)

![](img/404243642bd2ec6770a46a09f840c44a_173.png)

![](img/404243642bd2ec6770a46a09f840c44a_175.png)

![](img/404243642bd2ec6770a46a09f840c44a_177.png)

![](img/404243642bd2ec6770a46a09f840c44a_179.png)

## 链接器（Link） 🔗

![](img/404243642bd2ec6770a46a09f840c44a_181.png)

![](img/404243642bd2ec6770a46a09f840c44a_183.png)

![](img/404243642bd2ec6770a46a09f840c44a_185.png)

![](img/404243642bd2ec6770a46a09f840c44a_187.png)

上一节我们了解到汇编器会生成带有“未解之谜”的目标文件，本节中我们来看看链接器如何解决这些问题。链接器接收一个或多个目标文件（`.o`）以及库文件作为输入，输出一个完整的可执行文件。

![](img/404243642bd2ec6770a46a09f840c44a_189.png)

![](img/404243642bd2ec6770a46a09f840c44a_191.png)

![](img/404243642bd2ec6770a46a09f840c44a_193.png)

![](img/404243642bd2ec6770a46a09f840c44a_195.png)

链接器的主要工作包括：
1.  **合并段**： 将所有输入目标文件的`.text`段合并到输出文件的`.text`段，将所有`.data`段合并到输出文件的`.data`段。
2.  **符号解析与重定位**： 这是链接器的核心工作。它收集所有输入文件的符号表，形成一个全局符号表。然后，它遍历每个文件的重定位信息表，查找每个未解析符号在全局符号表中的最终地址，并回过头去修改目标文件中对应指令的机器码，用正确的地址替换掉占位符。

![](img/404243642bd2ec6770a46a09f840c44a_197.png)

![](img/404243642bd2ec6770a46a09f840c44a_199.png)

![](img/404243642bd2ec6770a46a09f840c44a_201.png)

![](img/404243642bd2ec6770a46a09f840c44a_203.png)

![](img/404243642bd2ec6770a46a09f840c44a_205.png)

![](img/404243642bd2ec6770a46a09f840c44a_207.png)

![](img/404243642bd2ec6770a46a09f840c44a_209.png)

链接器需要处理几种不同类型的地址引用：
*   **PC相对引用（如`beq`, `jal`到同一文件内标签）**： 在汇编阶段已解决，链接器通常无需修改。
*   **外部函数引用（如`call printf`）**： 链接器必须解析`printf`在库中的实际地址，并修改调用它的`jal`指令中的偏移量字段。
*   **静态数据引用（如加载全局变量地址）**： 链接器必须确定该变量在最终数据段中的地址，并修改相应的`lui`/`addi`指令序列。

![](img/404243642bd2ec6770a46a09f840c44a_211.png)

![](img/404243642bd2ec6770a46a09f840c44a_213.png)

链接方式主要有两种：
*   **静态链接**： 将库代码直接复制到最终的可执行文件中。优点是生成的文件自包含，不依赖运行环境；缺点是文件体积大，且库更新后需要重新链接所有程序。
*   **动态链接**： 可执行文件中仅记录它需要哪些库。在程序被加载或运行时，操作系统才将所需的共享库（如`.so`或`.dll`文件）映射到进程内存空间。优点是节省磁盘和内存空间，库升级方便；缺点是程序依赖运行环境，且初次运行有链接开销。

![](img/404243642bd2ec6770a46a09f840c44a_215.png)

## 加载器（Load） 🚀

![](img/404243642bd2ec6770a46a09f840c44a_217.png)

![](img/404243642bd2ec6770a46a09f840c44a_219.png)

链接器为我们生成了可执行文件，最后一环是加载器。加载器是操作系统的一部分，它的职责是将可执行文件加载到内存中，并启动执行。

![](img/404243642bd2ec6770a46a09f840c44a_221.png)

![](img/404243642bd2ec6770a46a09f840c44a_223.png)

![](img/404243642bd2ec6770a46a09f840c44a_225.png)

![](img/404243642bd2ec6770a46a09f840c44a_227.png)

加载器的工作流程如下：
1.  **创建地址空间**： 操作系统为程序创建一个独立的虚拟内存地址空间。
2.  **加载段**： 将可执行文件的`.text`段（代码）和`.data`段（初始化数据）读入（或映射到）该地址空间的相应位置。
3.  **初始化堆栈**： 设置堆栈指针（`sp`寄存器），并为`main`函数的参数（`argc`, `argv`）在堆栈上分配空间。
4.  **跳转到入口点**： 将程序计数器（PC）设置为程序的入口地址（通常是`_start`或类似的启动例程），开始执行。启动例程会负责将命令行参数从堆栈设置到寄存器，然后调用用户的`main`函数。当`main`函数返回后，启动例程会发起系统调用结束进程。

![](img/404243642bd2ec6770a46a09f840c44a_229.png)

![](img/404243642bd2ec6770a46a09f840c44a_231.png)

## 总结 📚

![](img/404243642bd2ec6770a46a09f840c44a_233.png)

![](img/404243642bd2ec6770a46a09f840c44a_235.png)

![](img/404243642bd2ec6770a46a09f840c44a_237.png)

![](img/404243642bd2ec6770a46a09f840c44a_239.png)

本节课中我们一起学习了程序从C源代码到最终运行的完整旅程——“CALL”流程。

![](img/404243642bd2ec6770a46a09f840c44a_241.png)

![](img/404243642bd2ec6770a46a09f840c44a_243.png)

*   **编译**将人类可读的C代码转换为汇编代码。
*   **汇编**将汇编代码（含伪指令）转换为机器码目标文件，并生成符号表和重定位信息。
*   **链接**将多个目标文件和库合并，解析所有符号引用，生成统一的可执行文件。
*   **加载**由操作系统将可执行文件装入内存，初始化运行环境，并启动程序执行。

![](img/404243642bd2ec6770a46a09f840c44a_245.png)

![](img/404243642bd2ec6770a46a09f840c44a_247.png)

![](img/404243642bd2ec6770a46a09f840c44a_249.png)

![](img/404243642bd2ec6770a46a09f840c44a_251.png)

![](img/404243642bd2ec6770a46a09f840c44a_253.png)

![](img/404243642bd2ec6770a46a09f840c44a_255.png)

![](img/404243642bd2ec6770a46a09f840c44a_256.png)

理解这个过程，有助于我们洞察软件底层的运作机制，为学习操作系统、编译原理等更深入的课程打下坚实基础。