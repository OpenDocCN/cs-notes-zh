![](img/20c495857631be128dfb4c88e5bc2b58_0.png)

# 课程 P22：Lecture 17：组合逻辑块 🧩

在本节课中，我们将要学习组合逻辑块的核心概念，特别是多路复用器和算术逻辑单元。我们将从回顾基本逻辑门开始，逐步构建更复杂的电路，并理解如何将它们组合起来实现强大的功能。

---

![](img/20c495857631be128dfb4c88e5bc2b58_2.png)

![](img/20c495857631be128dfb4c88e5bc2b58_4.png)

## 概述 📋

![](img/20c495857631be128dfb4c88e5bc2b58_6.png)

![](img/20c495857631be128dfb4c88e5bc2b58_8.png)

![](img/20c495857631be128dfb4c88e5bc2b58_10.png)

本节课我们将探讨组合逻辑块的设计与应用。我们将首先回顾如何从真值表构建逻辑电路，然后重点介绍多路复用器这一关键组件。接着，我们将学习如何构建一个简单的算术逻辑单元，并深入理解加法器和减法器的内部工作原理。最后，我们将讨论溢出检测的逻辑。

![](img/20c495857631be128dfb4c88e5bc2b58_12.png)

---

![](img/20c495857631be128dfb4c88e5bc2b58_14.png)

![](img/20c495857631be128dfb4c88e5bc2b58_16.png)

![](img/20c495857631be128dfb4c88e5bc2b58_18.png)

![](img/20c495857631be128dfb4c88e5bc2b58_20.png)

## 多路复用器：数据的选择器 🚦

![](img/20c495857631be128dfb4c88e5bc2b58_22.png)

![](img/20c495857631be128dfb4c88e5bc2b58_24.png)

上一节我们介绍了如何从真值表构建任意逻辑门。本节中我们来看看一个特殊的组合逻辑块：多路复用器。

多路复用器是一种数据选择器。它有几个数据输入、一个选择信号和一个输出。其功能是根据选择信号的值，决定哪一个输入信号可以驱动输出。

![](img/20c495857631be128dfb4c88e5bc2b58_26.png)

![](img/20c495857631be128dfb4c88e5bc2b58_28.png)

### 二选一多路复用器

一个最简单的多路复用器是二选一多路复用器。它有两个数据输入 `A` 和 `B`，一个选择信号 `S`，以及一个输出 `C`。

其工作规则如下：
*   当 `S = 0` 时，输出 `C` 等于输入 `A`。
*   当 `S = 1` 时，输出 `C` 等于输入 `B`。

![](img/20c495857631be128dfb4c88e5bc2b58_30.png)

![](img/20c495857631be128dfb4c88e5bc2b58_32.png)

我们可以用以下逻辑公式来描述：
```
C = (¬S ∧ A) ∨ (S ∧ B)
```

![](img/20c495857631be128dfb4c88e5bc2b58_34.png)

以下是其真值表：

| S | A | B | C |
|---|---|---|---|
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 1 |

![](img/20c495857631be128dfb4c88e5bc2b58_36.png)

![](img/20c495857631be128dfb4c88e5bc2b58_38.png)

![](img/20c495857631be128dfb4c88e5bc2b58_40.png)

构建这个电路需要四个逻辑门（两个非门、两个与门和一个或门）。

![](img/20c495857631be128dfb4c88e5bc2b58_42.png)

![](img/20c495857631be128dfb4c88e5bc2b58_44.png)

![](img/20c495857631be128dfb4c88e5bc2b58_46.png)

### 构建更宽的多路复用器

多路复用器可以处理多位宽的数据。一个“n位宽的二选一多路复用器”意味着 `A`、`B` 和 `C` 都是 n 位信号。其内部是 n 个并行的、相同的一位二选一多路复用器，所有单元共享同一个选择信号 `S`。

![](img/20c495857631be128dfb4c88e5bc2b58_48.png)

![](img/20c495857631be128dfb4c88e5bc2b58_50.png)

### 四选一多路复用器

![](img/20c495857631be128dfb4c88e5bc2b58_52.png)

![](img/20c495857631be128dfb4c88e5bc2b58_54.png)

![](img/20c495857631be128dfb4c88e5bc2b58_56.png)

![](img/20c495857631be128dfb4c88e5bc2b58_58.png)

如果需要从四个输入（A, B, C, D）中选择一个，我们就需要一个四选一多路复用器。此时，选择信号需要两位（`S1`, `S0`）来编码四种选择（00, 01, 10, 11）。

![](img/20c495857631be128dfb4c88e5bc2b58_60.png)

![](img/20c495857631be128dfb4c88e5bc2b58_62.png)

![](img/20c495857631be128dfb4c88e5bc2b58_64.png)

![](img/20c495857631be128dfb4c88e5bc2b58_66.png)

构建四选一多路复用器有两种方法：
1.  **直接法**：根据所有输入（6个：S1, S0, A, B, C, D）写出庞大的真值表（2^6 = 64行），然后推导逻辑表达式。这种方法不实用。
2.  **级联法**：使用三个二选一多路复用器分层构建。这是一种更优雅和高效的方法。

以下是级联法的思路：
*   第一层：用 `S0` 选择 `A` 或 `B` 作为胜者；用另一个 `S0` 选择 `C` 或 `D` 作为胜者。
*   第二层：用 `S1` 从第一层的两个胜者中选出最终输出。

硬件会并行计算所有路径的值，但只有被选中的路径信号能最终驱动输出。

![](img/20c495857631be128dfb4c88e5bc2b58_68.png)

---

![](img/20c495857631be128dfb4c88e5bc2b58_70.png)

![](img/20c495857631be128dfb4c88e5bc2b58_72.png)

## 算术逻辑单元 🧮

![](img/20c495857631be128dfb4c88e5bc2b58_74.png)

![](img/20c495857631be128dfb4c88e5bc2b58_76.png)

上一节我们学会了如何用多路复用器选择数据。本节中我们来看看如何用多路复用器构建一个能执行多种算术与逻辑运算的单元——算术逻辑单元。

![](img/20c495857631be128dfb4c88e5bc2b58_78.png)

![](img/20c495857631be128dfb4c88e5bc2b58_80.png)

![](img/20c495857631be128dfb4c88e5bc2b58_82.png)

ALU 是一个通用的计算盒子，它接收两个操作数 `A` 和 `B`，以及一个操作选择信号 `S`。根据 `S` 的值，ALU 对 `A` 和 `B` 执行不同的运算（如加、减、与、或等），并将结果输出。

![](img/20c495857631be128dfb4c88e5bc2b58_84.png)

![](img/20c495857631be128dfb4c88e5bc2b58_86.png)

### 一个简单的 ALU 设计

![](img/20c495857631be128dfb4c88e5bc2b58_88.png)

![](img/20c495857631be128dfb4c88e5bc2b58_90.png)

![](img/20c495857631be128dfb4c88e5bc2b58_92.png)

假设我们要构建一个支持四种操作的简单 ALU：加法、减法、按位与、按位或。我们需要两位选择信号 `S1 S0`。

![](img/20c495857631be128dfb4c88e5bc2b58_94.png)

其设计思路如下：
1.  并行放置四个功能单元：加法器、减法器、与门、或门。它们同时接收 `A` 和 `B`。
2.  用一个四选一多路复用器，根据 `S1 S0` 的值，选择其中一个功能单元的结果作为最终输出。

![](img/20c495857631be128dfb4c88e5bc2b58_96.png)

![](img/20c495857631be128dfb4c88e5bc2b58_98.png)

![](img/20c495857631be128dfb4c88e5bc2b58_100.png)

例如：
*   `S1 S0 = 00`：选择加法器结果。
*   `S1 S0 = 01`：选择减法器结果。
*   `S1 S0 = 10`：选择按位与结果。
*   `S1 S0 = 11`：选择按位或结果。

![](img/20c495857631be128dfb4c88e5bc2b58_102.png)

![](img/20c495857631be128dfb4c88e5bc2b58_104.png)

在这个设计中，所有功能单元都在持续工作并产生结果，但只有被多路复用器选中的结果会被传递出去。

---

## 加法器与减法器的构建 ➕➖

![](img/20c495857631be128dfb4c88e5bc2b58_106.png)

![](img/20c495857631be128dfb4c88e5bc2b58_108.png)

上一节我们看到了 ALU 的顶层结构。本节中我们深入其核心，看看如何构建加法器和减法器。

### 一位加法器

![](img/20c495857631be128dfb4c88e5bc2b58_110.png)

![](img/20c495857631be128dfb4c88e5bc2b58_112.png)

![](img/20c495857631be128dfb4c88e5bc2b58_114.png)

我们从最简单的单位开始：一位加法器（全加器）。它接收三个一位输入：`A`、`B` 和来自低位的进位 `Cin`；输出两个一位：和 `S` 以及向高位的进位 `Cout`。

![](img/20c495857631be128dfb4c88e5bc2b58_116.png)

![](img/20c495857631be128dfb4c88e5bc2b58_118.png)

![](img/20c495857631be128dfb4c88e5bc2b58_120.png)

其真值表如下（`A + B + Cin = {Cout, S}`）：

| A | B | Cin | Cout | S |
|---|---|-----|------|---|
| 0 | 0 | 0   | 0    | 0 |
| 0 | 0 | 1   | 0    | 1 |
| 0 | 1 | 0   | 0    | 1 |
| 0 | 1 | 1   | 1    | 0 |
| 1 | 0 | 0   | 0    | 1 |
| 1 | 0 | 1   | 1    | 0 |
| 1 | 1 | 0   | 1    | 0 |
| 1 | 1 | 1   | 1    | 1 |

观察真值表，我们可以得到优美的逻辑表达式：
*   和 `S` 是 `A`、`B`、`Cin` 的异或：`S = A ⊕ B ⊕ Cin`。这本质上是将三个数相加后取最低位（奇偶性）。
*   进位 `Cout` 是 `A`、`B`、`Cin` 的多数表决：当三个输入中至少有两个为1时，进位为1。`Cout = (A ∧ B) ∨ (A ∧ Cin) ∨ (B ∧ Cin)`。

### 多位加法器与行波进位

![](img/20c495857631be128dfb4c88e5bc2b58_122.png)

要构建一个 n 位加法器，我们可以将 n 个一位加法器串联起来。低位加法器的 `Cout` 连接到相邻高位加法器的 `Cin`。

这种结构称为“行波进位加法器”。其缺点是延迟较长：最高位的计算必须等待进位从最低位像波浪一样依次传递上来。最坏情况下的延迟与位数 n 成正比。存在更快的设计（如超前进位加法器），可以提前计算进位以减少延迟。

### 溢出检测

加法结果可能超出输出位数所能表示的范围，即发生溢出。溢出的判断方式取决于我们对数字的解释（无符号数 vs 有符号补码）。

*   **无符号数溢出**：只需检查最高位加法器产生的进位 `Cout`。如果 `Cout = 1`，则发生溢出。
*   **有符号数（补码）溢出**：规则更复杂。观察最高位加法器的进位输入 `Cin` 和进位输出 `Cout`。当 `Cin` 和 `Cout` 不相等时（即一个为0，一个为1），发生有符号溢出。这对应了两种错误情况：两个正数相加得负数，或两个负数相加得正数。

### 构建减法器

![](img/20c495857631be128dfb4c88e5bc2b58_124.png)

减法可以通过加法来实现。在二进制补码系统中，`A - B` 等价于 `A + (-B)`，而 `-B` 等于 `按位取反 B 再加 1`。

![](img/20c495857631be128dfb4c88e5bc2b58_126.png)

![](img/20c495857631be128dfb4c88e5bc2b58_127.png)

![](img/20c495857631be128dfb4c88e5bc2b58_129.png)

![](img/20c495857631be128dfb4c88e5bc2b58_131.png)

因此，一个聪明的减法器设计如下：
1.  使用一个条件取反器（例如，通过异或门实现）：当减法控制信号 `Sub` 为1时，将 `B` 的每一位取反；当 `Sub` 为0时，`B` 保持不变。
2.  同时，将减法控制信号 `Sub` 作为进位 `Cin` 输入到加法器。
这样，当执行减法时（`Sub=1`），我们实际上计算的是 `A + (~B) + 1`，即 `A - B`。当执行加法时（`Sub=0`），我们计算的是 `A + B + 0`。

![](img/20c495857631be128dfb4c88e5bc2b58_133.png)

![](img/20c495857631be128dfb4c88e5bc2b58_135.png)

![](img/20c495857631be128dfb4c88e5bc2b58_137.png)

![](img/20c495857631be128dfb4c88e5bc2b58_139.png)

---

![](img/20c495857631be128dfb4c88e5bc2b58_141.png)

![](img/20c495857631be128dfb4c88e5bc2b58_143.png)

![](img/20c495857631be128dfb4c88e5bc2b58_145.png)

![](img/20c495857631be128dfb4c88e5bc2b58_147.png)

## 总结 🎯

本节课中我们一起学习了组合逻辑块的核心知识。

![](img/20c495857631be128dfb4c88e5bc2b58_149.png)

我们首先回顾了从真值表构建逻辑电路的方法。然后，我们深入探讨了**多路复用器**，它像一个交通指挥员，根据选择信号决定哪个输入数据可以通过。我们学习了如何构建二选一和四选一多路复用器，并理解了级联构建的方法。

接着，我们将多路复用器应用于构建**算术逻辑单元**。ALU 利用多路复用器来选择不同的运算结果，实现了在一个通用单元内完成加、减、与、或等多种操作。

![](img/20c495857631be128dfb4c88e5bc2b58_151.png)

![](img/20c495857631be128dfb4c88e5bc2b58_153.png)

最后，我们剖析了 ALU 的核心计算部件：**加法器**和**减法器**。我们学习了一位全加器的设计（利用异或和多数表决电路），了解了多位行波进位加法器的原理及其延迟问题，讨论了无符号数和有符号补码的**溢出检测**逻辑，并掌握了一个非常巧妙的技巧：通过条件取反和加1，用加法器来实现减法运算。

![](img/20c495857631be128dfb4c88e5bc2b58_155.png)

现在，我们已经拥有了构建复杂数字系统（如 CPU 数据通路）所需的基本模块。在接下来的课程中，我们将学习如何将这些模块组合起来。