# 第五讲：映射、折叠和 Map-Reduce 范式

## Map-Reduce 范式

*Map-reduce*是一个根植于函数式编程的编程模型。除了通常为涉及列表或集合的问题产生简短、优雅的代码外，这种模型在大规模高度并行数据处理方面也被证明非常有用。在这里，我们将 map 和 reduce 视为在列表上操作以具体化，但它们适用于任何集合（集合等）。*Map*在值列表上操作，以生成一个新的值列表，通过对每个值应用相同的计算。*Reduce*在值列表上操作，将这些值折叠或组合成单个值（或一些值），同样是通过对每个值应用相同的计算。

对于大型数据集，以相同操作独立应用于数据集中的每个项目来处理，已被证明特别有价值，无论是生成新数据集，还是为整个数据集生成摘要结果。这种思考方式在并行硬件上通常效果良好，其中许多处理器可以同时处理一个或多个数据项。20 世纪 80 年代末开发的大规模并行计算机 Connection Machine 就大量使用了这种方法。

近年来，谷歌利用他们庞大的服务器农场，非常有效地运用了 map-reduce 范式。两位谷歌研究员，迪恩和盖马瓦特，在 2004 年的 OSDI（操作系统设计与实现会议）上以及 2008 年的 CACM（主要计算机科学专业协会的月刊）上报告了一些这些应用。这些论文的重点大部分在于将在大型机器群上操作的容错性和分布式处理问题与编程语言抽象分离开来。他们发现 map-reduce 是一种成功的方式，可以将大规模数据集上的计算概念模型，使用映射和归约操作，与如何在大型机器群上可靠实现该计算的问题分离开来。

在他们 2008 年的论文介绍中，迪安和盖马瓦特写道：“我们的抽象受到 Lisp 和许多其他函数语言中存在的映射和归纳原语的启发。 我们意识到，我们大部分的计算涉及将映射操作应用于输入中的每个逻辑记录，以便计算一组中间键/值对，然后将归纳操作应用于所有共享相同键的值，以便适当地组合派生的数据。” 在论文中，他们讨论了通过这种大规模并行视图简化的一些应用。 为了让人们对这些程序所处理的规模有所了解，他们指出，自 2004 年以来，谷歌已经实施了超过一万个使用映射-归纳的程序，并且在 2007 年 9 月，谷歌使用了超过 130,000 台机器月份的处理时间，处理了超过 450 PB（450,000 TB）的数据。

对于我们在本编程课程中的目的，在映射-归纳范式中表达哪些问题对于了解谷歌发现有用是很有启发性的。 计算大量文档中每个单词出现的次数是索引大型文档集合的一个核心计算问题。 这可以被表达为对跨文档集合中的每个文档应用返回给定单词计数的函数进行映射。 然后通过对计数求和来缩减结果。 因此，如果我们有一个字符串列表，映射返回一个整数列表，其中包含每个字符串的计数，然后缩减那些整数。 许多其他计数问题可以类似地实现。 例如，在日志文件中计算某种模式的出现次数，例如给定用户查询或特定 URL 的出现次数。 在不同主机上可能有许多日志文件，这可以看作是一个大型字符串集合，具有与文档单词计数相同的映射和归纳操作。

将 web 图的链接反转是另一个可以这样看待的问题。 网络是一组从给定页面指向它链接到的页面的出链。 一个映射函数可以为每个源页面输出目标-源对，并且一个 reduce 函数可以将这些折叠成对应于每个目标页面的源页面列表（即，链接到页面）。

反向索引是从术语到包含该术语的所有文档的映射。 它是搜索引擎的重要部分，因为引擎必须能够快速将术语映射到相关页面。 在这种情况下，映射函数为每个文档返回术语和文档标识符的对。 归纳将结果折叠成给定术语的文档 ID 列表。

在 Google 的论文中，他们报告重新实现生产索引系统导致的代码更简单、更小、更易于理解和修改。这反过来导致了一个更容易操作的服务，因为故障诊断和恢复也相应更容易。然而，这种方法产生的代码速度足够快，没有性能下降。

## 在 OCaml 中的映射和折叠（归约）

首先让我们更详细地看一下映射操作。这个操作将指定的函数*f*应用于列表的每个元素，以产生一个结果列表。结果列表的每个元素是通过将*f*应用于输入列表的相应元素获得的。OCaml 库函数`List.map`是柯里化的，先接受函数，然后接受列表。对于一个包含三个元素的列表，它产生以下值：

```
List.map f [a; b; c] = [f a; f b; f c]

```

回想一下，在上一讲中我们介绍了我们自己的多态`list_`类型：

```
type 'a list_ = Nil | Cons of ('a * 'a list_)

```

这种类型的映射操作可以写成：

```
let rec map (f : 'a -> 'b) (x : 'a list_) : 'b list_ = 
  match x with
      Nil -> Nil
    | Cons (h, t) -> Cons (f h, map f t)

```

`map`的类型是

```
('a -> 'b) -> 'a list_ -> 'b list_

```

参数`f`是一个从输入列表的元素类型`'a`到输出列表的元素类型`'b`的函数。

使用匿名函数与 map，我们可以定义一个复制列表的函数：

```
let copy = map (fun x -> x)

```

（这等同于说

```
let copy lst = map (fun x -> x) lst

```

但实际上我们不需要在定义中包含第二个参数；`copy`函数的类型是`'a list_ -> 'a list_`，即使没有第二个参数也已经定义完整。

类似地，我们可以从`int list_`创建一个`string list_`：

```
# let string_list_of_int_list = map string_of_int;;
*val string_list_of_int_list : int list_ -> string list_ = <fun>*
# string_list_of_int_list (Cons (1, Cons (2, Cons (3, Nil))));;
*- : string list_ = Cons ("1", Cons ("2", Cons ("3", Nil)))*

```

现在让我们考虑 reduce 操作，它类似于 map，将一个函数应用于列表的每个元素，但在这样做时累积一个结果，而不仅仅产生另一个列表。与 map 相比，reduce 运算符接受一个额外的累加器参数。与 map 一样，我们将考虑 reduce 的柯里化形式。

有两个版本的 reduce，基于函数*f*在创建结果值时的应用嵌套。在 OCaml 中，操作列表的内置 reduce 函数称为`List.fold_right`和`List.fold_left`。这些函数产生以下值：

```
fold_right f [a; b; c] r = f a (f b (f c r))
fold_left f r [a; b; c] = f (f (f r a) b) c

```

从这两个结果的形式可以看出为什么这些函数被称为`fold_right`，它使用`f`的右括号化应用，以及`fold_left`，它使用左括号化。请注意这两个函数的形式参数顺序不同：在`fold_right`中，累加器位于列表的右侧，在`fold_left`中，累加器位于左侧。

再次使用`list_`类型，我们可以定义这两个函数如下：

```
let rec fold_right (f : 'a -> 'b -> 'b) (lst : 'a list_) (r :'b) : 'b = 
  match lst with
    Nil -> r
  | Cons (hd, tl) -> f hd (fold_right f tl r)

let rec fold_left (f : 'a -> 'b -> 'a) (r : 'a) (lst : 'b list_) : 'a = 
  match lst with
    Nil -> r
  | Cons (hd, tl) -> fold_left f (f r hd) tl

```

`fold_right`和`fold_left`的类型是

```
('a -> 'b -> 'b) -> 'a list_ -> 'b -> 'b
('a -> 'b -> 'a) -> 'a -> 'b list_ -> 'a

```

分别。

这两个函数中的参数`f`是一个从输入列表的元素类型和累加器类型到累加器类型的函数。输入列表和累加器的类型不必相同。

有了这些定义，诸如对整数列表的所有元素求和等操作可以自然地使用 `fold_right` 或 `fold_left` 定义。

```
let sum_right_to_left il = fold_right (+) il 0
let sum_left_to_right = fold_left (+) 0

```

这里 `(+)` 等同于 `fun x y -> x + y`。注意，由于在 `fold_left` 中参数的顺序，所以在第二种情况下我们不需要 `il`。

## 折叠的力量

折叠是一种非常强大的操作。我们可以用折叠来定义许多其他列表函数。实际上 `map`，虽然最初听起来与 `fold` 非常不同，但可以通过累积一个列表结果来自然地使用 `fold_right` 来定义。继续使用我们的 `list_` 类型，

```
let mapp f lst = fold_right (fun x y -> Cons (f x, y)) lst Nil

```

累加器函数只是将 `f` 应用于每个元素并从空列表开始构建结果列表。

整个映射-归约范式可以使用 `fold_left` 和 `fold_right` 实现。然而，从概念上来说，将映射视为生成列表，将归约视为生成值通常是有用的。

用 `fold_left` 而不是 `fold_right` 来定义 `map` 怎么样？在这种情况下，我们得到一个进行映射的函数，但生成的输出是逆序的，因为 `fold_left` 从左到右处理输入列表的元素，而 `fold_right` 从右到左处理。

```
let maprev f = fold_left (fun x y -> Cons (f y, x)) Nil

```

（同样，由于参数的顺序，我们可以省略第二个参数 `lst`。）这个结果函数也可能非常有用，特别是因为它是尾递归的。如果我们希望结果列表的元素按与输入列表相同的顺序排序，我们可以在完成后反转列表。

映射的另一个有用变种是过滤，它根据一些布尔条件选择列表的子集。

```
let filter f lst =
  fold_right (fun x y -> if f x then Cons (x, y) else y) lst Nil

```

函数 `f` 是输出列表中成员的测试。它只接受一个参数并返回一个布尔值。例如，我们可以过滤整数列表中的偶数：

```
let select_evens = filter (fun x -> (x / 2) * 2 = x)

```

请注意，`select_evens` 的参数类型及其结果被限制为 `int list_` 而不是底层 `filter` 的更一般的 `'a list`，因为匿名函数接受一个整数参数并返回一个整数值。

确定列表的长度是另一个可以轻松使用折叠来定义的操作。

```
let length = fold_left (fun x _ -> 1 + x) 0

```

那么用 `fold_right` 呢？

你应该尝试使用 `map`、`fold_left` 和 `fold_right` 编写一些函数。这些原语非常有用。即使在没有这些内置操作的语言中，它们也是构建许多计算结构的有用方式。
