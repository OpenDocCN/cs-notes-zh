# 讲座 18：验证

我们将使用术语**验证**来指代一个生成高度保证的代码，能够在所有输入和所有环境下运行的过程。测试是一种很好的、具有成本效益的获取保证的方法，但在这个意义上它不是一个验证过程，因为无法保证测试的覆盖范围足以满足代码的所有用途。验证生成一个（有时是隐含的）证明，证明所有输入都将产生符合规范的输出。在这次讲座中，我们将基于明确但在某种程度上不太正式的证明代码的正确性来进行验证。

验证往往是昂贵的，需要仔细考虑和深入理解待验证的代码。在实践中，它往往被应用于重要且相对较短的代码。验证对于测试效果较差的关键系统尤其有价值。由于它们的执行不确定性，同时运行的程序很难测试，有时微妙的错误只能通过尝试形式化验证代码来发现。事实上，帮助证明程序正确的工具已经变得越来越有效，一些大型系统已经完全经过验证，包括编译器、处理器和处理器仿真器，以及关键的操作系统部件。

学习验证的另一个好处是，当你了解证明代码正确所需的步骤时，它将帮助你推理你自己的代码（或他人的代码），并编写更有可能正确的代码，基于更精确和有用的规范。

近年来，已经发展出一些技术，将验证和测试的思想结合起来，有时可以同时兼顾两者的优点。这些想法，**模型检查**和**抽象解释**，可以以更低的成本提供与正式验证相同级别的保证，或者比测试提供更多的保证。然而，在这次讲座中，我们将从经典意义上来看待验证。

## 一个简单的例子

让我们以一种稍微不太正式但希望能令人信服的方式证明一段代码的正确性。这里是一个对整数使用 `abs` 的稍微奇怪的 `max` 函数的实现，同时也给出了它的规范：

```
(* Returns: max x y is the maximum of x and y.  That is,
 * ((max x y = x) or (max x y = y)) and (max x y >= x) and (max x y >= y)
 *
 * Requires: Both x and y are between min_int/2 and max_int/2
 *)
let max x y = (x + y + abs(y-x))/2

(* Returns: abs x  is x if x >= 0, -x otherwise. *)
val abs : int -> int

```

因为这个实现没有使用 `if`（假设 `abs` 没有使用），这可能比显而易见的实现更快！

要验证类似这样的函数 `max`，我们将使用两个想法。首先，我们将考虑从满足前置条件的任意调用开始的代码的可能执行。随着执行的进行，我们将积累关于当前执行的已知事实。其次，在执行过程中的某些时刻，我们对于应该发生的事情还不清楚，我们将不得不考虑一些可能的情况。我们必须论证无论采取哪种情况，函数的后置条件都得到满足。

我们开始考虑对 `max x y` 进行评估，其中 `x` 和 `y` 表示满足前提条件的整数。我们将前提条件记录为右列的假设。为简洁起见，我们将使用 PRE 表示前提条件，(min_int ≤ x ≤ max_int 且 min_int ≤ y ≤ max_int)。我们需要知道的一件事是，OCaml 运算符 `+` 和 `−` 的作用就像数学加法和减法一样，只要数学结果在范围 `min_int` 到 `max_int` 内：

```
   (* (+) x y is x + y.
      Requires: min_int ≤ x + y ≤ max_int *)
   (* (−) x y is x − y.
      Requires: min_int ≤ x − y ≤ max_int *)

```

现在我们按照表格的形式进行证明，每一行代表一个评估步骤。

| 表达式 | 假设条件 | 证明 |
| --- | --- | --- |
| `max x y` | PRE | 我们考虑 `max` 的任意合法应用。 |
| `(x+y+abs(y-x))/2` | PRE | 在函数体中将形式参数替换为实际参数。 |
| `(n1+abs(y-x))/2` | PRE n1 = x + y | x+y 评估为某个数 n1。PRE 表示 x 和 y 都小于 min_int 或 max_int 的一半，因此它们的和必须是一个有效的整数；因此当它们相加时不会发生溢出。 |

| `(n1+abs(n2))/2` | PRE n1 = x + y

n2 = y − x | y−x 评估为某个数 n2。同样，我们在进行减法时不会发生溢出。但是现在我们不知道 `abs` 的结果。我们使用 `abs` 的规范，但分别考虑了 y ≥ x 和 y < x 的情况。 |

| 情况：y ≥ x |
| --- |

| `(n1+n2)/2` | PRE n1 = x + y

n2 = y − x

y≥x | 由于 y≥x，abs(n2) = n2。 |

| `n3/2` | PRE n1 = x + y

n2 = y − x

y≥x

n3 = n1+n2 = 2y | n1+n2 = x+y + (y−x) = 2y。因为 y ≤ max_int/2，所以这里也不会发生溢出。 |

| `y` | PRE y≥x

| n1+n2 = x+y + (y−x) = 2y。由于 y≥x，根据规范，我们得到的答案（y）是正确的。现在我们考虑另一种情况，这是对称的。 |
| --- |
| 情况：y < x |

| `(n1+n2)/2` | PRE n1 = x + y

n2 = y − x

y<x | 由于 y<x，abs(n2) = −n2 = x−y |

| `n3/2` | PRE n1 = x + y

n2 = y − x

y<x

n3 = n1−n2 = 2x | n1+n2 = x+y - (y−x) = 2x。由于 x ≤ max_int/2，所以这里也不会发生溢出。 |

| `x` | PRE y<x

| n1+n2 = x+y - (y−x) = 2x。因为 y<x，根据规范，我们得到的答案（x）是正确的。 |
| --- |
| 证毕 |  |

这里的游戏规则是，只要我们的假设中有足够的信息来知道采取了哪种评估步骤，我们就可以在左列上进行评估步骤。我们可以引入新的变量，如 n1、n2、n3，来表示计算得到的未知值。如果满足它们的前提条件，我们可以应用函数，比如`abs`。如果我们在当前假设集中没有足够的信息（中间列），那么我们可以将我们的分析分解为一组情况，只要这些情况是穷尽的。按情况进行分析就像一个堆栈：每种情况都是一个单独的假设或假设，它们创建了一个我们必须进行推理的假设世界。上表中的缩进表示我们何时处于这样的假设世界中。一旦我们得出结果，我们需要能够证明该结果满足后置条件，使用当前假设集中可用的信息。

## 模块化验证

在我们证明`max`符合其规范时，我们假设`abs`符合了*它的*规范。这很好，因为我们不需要查看`abs`的代码。这是**模块化验证**的一个例子，我们能够一次验证一个小的代码单元。函数规范、抽象函数和表示不变量使得能够逐个函数验证模块，而无需查看其他函数的代码。如果模块之间没有循环依赖关系，这是 OCaml 所执行的，那么每个模块的证明都可以假定每个其他模块都满足其接口中的规范。整个软件系统的证明然后是自底向上构建的。

## 细化

有时一个规范比另一个规范更强。例如，考虑`find`的两种可能规范：

```
A: (* find lst x  is an index at which x is
    *   is found in lst; that is, nth(lst, find lst x) = x
    * Requires: x is in lst *)
```

```
B: (* find lst x  is the first index at which x is
    *   is found in lst, starting from zero
    * Requires: x is in lst *)
```

规范 B 比规范 A 严格**强大**：给定规范 B 指定的特定函数输入，可能结果或结果集较 A 小。与 A 相比，规范 B 减少了非确定性的数量。在这种情况下，我们说规范 B**细化了**规范 A。通常情况下，如果 B 的任何实现都是 A 的有效实现，则规范 B 细化了规范 A。

初始时，细化和前置条件之间的交互可能会令人困惑。假设规范 A 和 B 具有相同的后置条件（结果子句），但规范 A 具有更强的前置条件。在上面的例子 A 中，我们可能要求 x 不仅在 lst 中，而且在列表中确切地出现一次。在这种情况下，B 仍然细化 A：它具有更强的（更具限制性的）后置条件和*较弱*的（不太具限制性的）前置条件，这意味着 B 的实现满足 A 的规范。从期望 A 但实际上得到 B 的客户的角度考虑这一点可能会有所帮助。客户进行的调用满足 A 的前置条件，因此也满足 B 的前置条件。客户收到满足 B 的后置条件的结果，因此也满足 A 的后置条件。

还有其他方式可以细化规范。例如，如果规范 A 包含一个要求子句，并且规范 B 与之相同但将要求子句更改为检查子句，则 B 细化 A：它更精确地描述了指定函数的行为。

我们可以将实际实现函数的代码视为要执行的计算的另一个规范。这个基于实现的规范必须至少和注释中编写的规范一样强；否则，实现可能会执行规范禁止的操作。换句话说，*任何正确的实现必须细化其规范*。

## 自动验证

我们一直在探讨如何编写易读的规范。可以使用形式语言编写允许计算机阅读的规范。这些机器可读的规范可用于对程序进行**形式验证**。利用形式规范，自动定理证明器可以*证明*整个程序实际上执行了它所说的。形式程序验证是一项吸引人的技术，因为它可以用来保证程序不包含错误！
