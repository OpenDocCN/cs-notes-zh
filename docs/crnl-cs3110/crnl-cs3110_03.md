# 第三讲：元组、记录和数据类型

## 元组

在 OCaml 中，每个函数都接受一个值并返回一个结果。例如，我们的`squareRoot`函数接受一个浮点数值并返回一个浮点数值。始终接受一个参数并返回一个结果的优势在于语言非常统一。稍后，我们将看到，当涉及将旧函数组合成新函数时，这给我们带来了很多好处。

但看起来我们可以编写接受多个参数的函数！例如，我们可以写成：

```
let max1 (r1, r2) : float =
  if r1 < r2 then r2 else r1

```

```
max1 (3.1415, 2.718)

```

看起来`max1`接受两个参数。事实上，`max1`接受一个*2 元组*（也称为*有序对*）作为参数。

一般来说，*n 元组*是一个有序的*n*个值的序列，用括号括起来，用逗号分隔，如(*expr, expr,* ..., *expr*)。例如，`(42, "hello", true)`是一个 3 元组，它包含整数`42`作为其第一个分量，字符串`"hello"`作为其第二个分量，布尔值`true`作为其第三个分量。注意*n*可以为 0，这给出了空元组`()`。这在 OCaml 中称为"unit"。

当您在 OCaml 中调用一个接受多个参数的函数时，您可以将参数传递给一个元组。例如，当我们写：

```
max1 (3.1415, 2.718)

```

我们将 2 元组`(3.1415, 2.718)`传递给函数`max1`。我们也可以写成：

```
let args = (3.1415, 2.178)

```

这将使我们能够编写

```
max1 args (* evaluates to 3.1415 *)

```

n 元组的类型写作*t*[1]`*`...`*`*t[n]*。例如，上面 args 的类型是`float * float`。这种表示法基于数学中的笛卡尔积（即平面是 R² = R * R）。

类似地，3 元组`(42, "hello", true)`的类型为`int * string * bool`。请注意，`max1`的类型为`(float * float) -> float`，表示它接受一个参数（包含两个浮点数的 2 元组）并返回一个结果（一个浮点数）。

结合我们迄今所见，我们可以写出基本类型的语法如下：

> *t*  ::=  `int`  |  `float`  |  `bool`  |  `string`  |  `char`  |   *t*[1] `*` ... `*` *t[n]*  |  *t*[1] `->` *t*[2]  |  `(`*t*`)`

这有一些棘手的部分。最重要的两点是`->`的优先级低于`*`，因此类型`(float * float) -> float`和`float * float -> float`是完全相同的类型。第二点是`->`是右结合的，这意味着

> *t*[1]`->`*t*[2]`->`*t*[3]        和        *t*[1] -> (*t*[2]`->`*t*[3])

是相同的。这将在讨论高阶函数时出现。

您可以使用`fst`和`snd`运算符提取元组的前两个分量，它们分别检索元组的第一个和第二个元素。然而，对于元组的其他元素没有类似的函数。

因此，例如，我们可以将 max 函数重写如下：

```
let max1 (pair : float * float) : float =
  if (fst pair) < (snd pair) then (snd pair) else (fst pair)

```

而这与第一个定义完全等价。这强调了 `max` 真的只接受一个参数 -- 一个浮点数对。但是当然，它比第一个定义稍微不那么可读。我们可以通过声明局部值 `r1` 和 `r2` 并将它们绑定到对的适当组件来更接近第一个定义：

```
let max1 (pair : float * float) : float =
  let r1 = fst pair in
  let r2 = snd pair in
    if r1 < r2 then r2 else r1

```

### 模式匹配元组

这样做会稍微好一些，因为我们避免了一遍又一遍地重新计算相同的表达式。但是，仍然不如我们第一个定义的 max 那样简洁。这是因为第一个定义使用*模式匹配*来隐式解构 2-元组并将组件绑定到变量 `r1` 和 `r2`。您可以在 `let` 声明或函数定义中使用模式匹配来解构元组。元组模式始终为 `(`*x*[1]:*t*[1], *x*[2]:*t*[2],..., *x[n]*:*t[n]*`)` 的形式。模式匹配（无论是在 `let` 还是函数声明中）是从元组中提取元素的推荐方法。它通常更有效，并且几乎总是更简洁且更易读。例如，这是另一个使用 `let` 声明中的模式来解构对的 max 版本：

```
let max1 (pair : float * float) : float =
  let (r1, r2) = pair in
    if r1 < r2 then r2 else r1

```

在上面的示例中，`let` 声明将对与元组模式 `(r1, r2)` 匹配。这将 `r1` 绑定到对的第一个组件 `(fst pair)`，`r2` 绑定到对的第二个组件 `(snd pair)`。当您编写一个使用元组模式的函数时，就像 max 的原始定义中一样，也会发生类似的情况：

```
let max1 (r1, r2) : float =
  if r1 < r2 then r2 else r1

```

在这里，当我们使用对 `(3.1415, 2.718)` 调用 max 时，元组与模式 `(r1, r2)` 匹配，`r1` 绑定到 `3.1415`，`r2` 绑定到 `2.718`。正如我们后面将看到的那样，OCaml 在许多地方使用模式匹配来简化表达式。

假设我们想要在单个函数中提取两个数字的最小值和最大值。使用元组，这很容易：我们只需返回一个包含两个结果的元组。使用 let，我们也可以方便地将两个结果分别提取到不同的变量中：

```
let minmax (a, b) : float * float =
  if a < b then (a, b) else (b, a)

```

```
let (mn, mx) = minmax (2.0, 1.0)

```

这将 `mn` 绑定到 `1.0`，`mx` 绑定到 `2.0`。`minmax` 的类型是 `(float * float) -> (float * float)`，我们可以省略括号，因为在写类型表达式时 `*` 的优先级高于 `->`。

总结：

+   OCaml 中的每个函数都接受一个参数并返回一个结果。

+   表达式 `(`*e*[1]`,` ...`,` *e[n]*`)` 的值是一个 *n*-元组。

+   元组类型看起来像 *t*[1] `*` ... `*` *t[n]*

+   函数 `fst` 和 `snd` 提取 2-元组的第一个和第二个组件

+   `let``(`*x*[1]:*t*[1], *x*[2]:*t*[2],..., *x[n]*:*t[n]*`)`*=* *e* 匹配表达式 *e* 的值（*e* 必须是一个 *n*-元组）与元组模式 `(`*x*[1]:*t*[1], *x*[2]:*t*[2],..., *x[n]*:*t[n]*`)` 并将模式中的标识符绑定到元组的适当组件。

+   `let` *y*`(`*x*[1]:*t*[1], *x*[2]:*t*[2],..., *x[n]*:*t[n]*`)`*=* *e*是一个接受*n*-元组作为参数并将该元组与元组模式`(`*x*[1]:*t*[1], *x*[2]:*t*[2],..., *x[n]*:*t[n]*`)`匹配，然后使用这些绑定评估*e*的函数*y*的声明。

## 记录

记录类似于元组，因为它们是用于保存多个值的数据结构。但是，它们与元组不同，因为它们携带一个*无序*的*带标签*值集合。记录表达式的形式为`**{**`*x*`[1]=`*e*[1]`;`...`;`*x[n]*`=`*e[n]*`**}**`，其中标识符*x*是标签。然而，在创建记录之前，你必须使用`type`关键字为其类型命名。要声明记录类型，类型必须用大括号括起来，并且每个字段必须被赋予自己的名称和类型。例如，以下声明了一个`account`类型：

```
type account = {first:string; last:string; age:int; balance:float}

```

一旦你声明了类型，你就可以创建该类型的记录。例如，给定`account`类型的声明，表达式

```
{first="John"; last="Doe"; age=150; balance=0.12}

```

是一个具有四个名为`first`、`last`、`age`和`balance`的字段的记录。你可以通过使用`exp.id`从记录中提取字段，其中`exp`是记录，`id`是你想要提取的字段。例如，对上面的记录应用`.age`会得到 150，而应用`.balance`会得到 0.12。

创建记录时，给出字段的顺序并不重要。因此，记录

```
{balance=0.12; age=150; first="John"; last="Doe"}

```

等同于上面的例子。当你在 OCaml 顶层输入其中一个记录时，它会根据类型声明中的顺序将字段排序为规范顺序：

```
# let pers = { last = "Doe";
              age = 150; balance = 0.12;  first = "John" };;
*val pers : account = {first = "John"; last = "Doe"; age = 150; balance = 0.12}*

```

记录的类型写作`**{**`*x*[1]:*t*[1]; *x*[2]:*t*[2]; ... ; *x[n]*:*t[n]*`**}**`。

就像你可以使用模式匹配来提取元组的组件一样，你也可以使用模式匹配来提取记录的字段。例如，你可以写：

```
let {first=first; last=last; age=age; balance=balance} = pers

```

OCaml 的回应是：

```
*val first : string = "John" val last : string = "Doe" val age : int = 150 val balance : float = 0.12*

```

从而将标识符`first`、`last`、`age`和`balance`绑定到记录的各个组件。你还可以编写参数为记录的函数，使用记录模式。例如：

```
let full_name {first=first; last=last; age=age; balance=balance} : string =
  first ^ " " ^ last (* ^ is the string concatenation operator *)

```

调用`full_name`并将记录`pers`传递给它会得到`"John Doe"`作为答案。

我们可以将元组视为记录的简写。特别地，元组表达式`(3.14, "Greg", true)`类似于记录表达式`{1=3.14; 2="Greg"; 3=true}`。因此，在某种意义上，元组只是记录的语法糖。

总结：

+   在创建记录之前，你必须使用`type`声明记录类型。

+   记录表达式的形式为**`{`***x*[1] `=` *e*[1]`;` *x*[2] `=` *e*[2]`;` ...`;` *x[n]* `=` *e[n]***`}`**。

+   记录类型的形式为`**{**`*x*[1]:*t*[1]; *x*[2]:*t*[2]; ... ; *x[n]*:*t[n]*`**}**`。

+   你可以通过写*e*`.`*x*来从记录中提取字段，其中*x*是字段的名称。

+   你可以使用形式为`**{**`*x*[1]=*id*[1]; *x*[2]=*id*[2]; ... ; *x[n]*=*id[n]*`**}**`的模式匹配记录。

下周我们将介绍更多种类的类型（数据类型）和更多的模式匹配结构。

* * *

## 简单数据类型和匹配表达式

数据类型用于两个基本目的，我们将通过示例描述。数据类型声明的第一个示例如下：

```
type mybool = Mytrue | Myfalse

```

这个定义声明了一个新类型（`mybool`）和两个构造器（`Mytrue`和`Myfalse`）来创建`mybool`类型的值。换句话说，在将这个定义输入到 OCaml 之后，我们可以使用`Mytrue`和`Myfalse`作为`mybool`类型的值。实际上，这些是`mybool`类型的*唯一*值。因此，数据类型的一个目的是引入新类型到语言中，并引入创建此新类型值的方法。实际上，内置的`bool`类型简单地定义为：

```
type bool = true | false

```

请注意，数据类型定义很像 BNF 语法。例如，我们可以认为 bool 由`true`或`false`组成。当我们开始构建语言的实现时，我们将会充分利用 OCaml 中的这种内置语法。

**旁注：**逻辑连接和逻辑析取的运算符如下：

> *exp*   ::=   ...   |   *e1* && *e2*   |   *e1* | | *e2*

请注意，`and`并不是用于逻辑连接的，尽管它是一个关键字。它们看起来像二元运算符；但是，它们不同于中缀函数，因为所有其他二元运算符都会评估两个表达式。这两个逻辑构造具有称为短路评估的特殊功能。如果可以通过评估左侧表达式来确定逻辑公式的结果，则右侧表达式将保持未评估状态。

另一个数据类型声明的示例如下：

```
type day = Sun | Mon | Tue | Wed | Thu | Fri | Sat

```

这个声明定义了一个新类型（`day`）和七个该类型的新构造器（`Sun`–`Sat`）。例如，我们可以编写一个将数字映射到一周中的某一天的函数：

```
let int_to_day (i : int) : day =
  if i mod 7 = 0 then Sun else
  if i mod 7 = 1 then Mon else
  if i mod 7 = 2 then Tue else
  if i mod 7 = 3 then Wed else
  if i mod 7 = 4 then Thu else
  if i mod 7 = 5 then Fri else Sat

```

这一系列`if`表达式测试值`i`相当繁琐。更简洁的写法是使用`match`表达式：

```
let int_to_day (i : int) : day =
   match i mod 7 with
     0 -> Sun
   | 1 -> Mon
   | 2 -> Tue
   | 3 -> Wed
   | 4 -> Thu
   | 5 -> Fri
   | _ -> Sat

```

`match`表达式类似于诸如 Java 或 C 等语言中的`switch`语句。在上面的示例中，我们对(`i mod 7`)的值进行分析，并将其与一组数字模式进行匹配（即，0, 1, 2 等）。最后一个模式是通配符，可以匹配任何值。在 Java 中，我们可以将上述内容写成类似于以下的形式：

```
switch (i % 7) {
  case 0: return Sun;
  case 1: return Mon;
  case 2: return Tue;
  case 3: return Wed;
  case 4: return Thu;
  case 5: return Fri;
  default: return Sat;
}

```

这样就可以将整数映射到日期。那么将日期映射到整数呢？

```
let day_to_int (d : day) : int =
   match d with
     Sun -> 0
   | Mon -> 1
   | Tue -> 2
   | Wed -> 3
   | Thu -> 4
   | Fri -> 5
   | Sat -> 6

```

使用`match`表达式，我们技术上不需要`if`表达式形式。特别是，形式为`if` *exp1* `then` *exp2* `else` *exp3*的表达式等价于：

```
match *exp1* with
  true -> *exp2*
| false -> *exp3*

```

实际上，事实证明，通过数据类型的一般形式和 case 表达式，我们可以编码许多似乎内置在语言中的东西。这是一件好事，因为它简化了我们需要考虑的特殊形式的数量。

总之：

+   `type` *id* = *id1 | id2 | id3 | ... | idn*声明了一个新类型（*id1*），具有*n 个数据*构造器（*id1 id2 id3 ... idn)*。

+   `match` *exp* `with` *pat1 -> exp1 | pat2 -> exp2 | ... | patn -> expn* 评估 *exp*，然后依次将其与模式匹配。也就是说，首先尝试第一个模式（*pat1*），如果匹配成功，则评估相应的表达式（*exp1*）。如果匹配失败，则继续下一个模式 *pat2*，依此类推。

+   到目前为止，模式可以由整数（例如，12，~4）、作为变量的标识符（例如，`x`）、元组模式、记录模式或作为数据构造函数的标识符（例如，`Sun`，`Mon`，`true`等）组成。

+   `if`-表达式是对 `match`-表达式的语法糖。

* * *

## 代数数据类型和更多模式匹配：

记录（或元组）在逻辑上类似于“和”。例如，类型为 `int * float * string` 的元组是一个包含 `int` *和* `float` *和* `string` 的对象。数据类型，在最一般的形式上，用于定义“或”类型--当某物需要是一种类型或另一种类型时。特别是，假设我们想要定义一个包括 `int` 或 `float` 类型元素的新类型“number”。这可以通过以下数据类型定义在 OCaml 中完成：

```
type num = Int_num of int | Real_num of float

```

这个声明给了我们一个新类型（`num`）和两个构造函数 `Int_num` 和 `Real_num`。`Int_num` 构造函数以 `int` 作为参数并返回一个 `num`，而 `Real_num` 构造函数以 `float` 作为参数并返回一个 `num`。通过这种方式，我们可以创建两种其他类型的（不相交的）联合类型。

但是我们如何使用类型为 `num` 的值呢？我们不能对其应用诸如 + 之类的操作，因为 + 仅对 `int` 定义。为了使用类型为 `num` 的值，我们必须使用模式匹配来解构它。例如，以下函数计算两个 nums 的最大值：

```
let num_to_float (n : num) : float =
   match n with
     Int_num i -> float_of_int i
   | Real_num r -> r

```

```
let max1 (n1, n2) : num =
  let r1 : float = num_to_float n1 in
  let r2 : float = num_to_float n2 in
    if r1 >= r2 then Real_num r1 else Real_num r2

```

这个策略很简单：将数字转换为浮点数，然后比较这两个浮点数，返回较大的那个。为了使返回值是一个 `num`（而不是一个 `float`），我们必须将结果放在一个 `Real_num` 构造函数中。我们可以写成这样：

```
let max2 (n1, n2) : num =
  let r1 : float = num_to_float n1 in
  let r2 : float = num_to_float n2 in
    Real_num (if r1 >= r2 then r1 else r2)

```

在这里，我们用 `Real_num` 构造函数包装了整个 `if`-表达式。这是将 `if` 视为*表达式*而不是语句的一个优势。

注意，在函数 `num_to_float` 中，我们使用了一个 `match`-表达式来确定数字 *n* 是整数还是浮点数。模式 `Int_num i` 只有当 *n* 是使用 `Int_num` 数据构造函数创建的时候才匹配 *n*，而 `Real_num r` 只有当它是用 `Real_num` 数据构造函数创建的时候才匹配 *n*。此外，请注意在 `Int_num i` 案例中，我们将由数据构造函数承载的基础整数绑定到变量 `i` 上，并且这在表达式 `float_of_int i` 中使用。类似地，`Real_num r` 模式提取由数据构造函数承载的基础浮点值，并将其绑定到 `r` 上。

因此，例如，调用`num_to_float (Int_num 3)`匹配第一个模式，将`i`绑定到 3，然后返回`float_of_int i` = `float_of_int 3` = `3.0`。调用`num_to_float (Real_num 4.5)`无法匹配第一个模式，但可以匹配第二个模式，将`r`绑定到 4.5，然后返回`r` = `4.5`。

这里是关于数字最大值的另一种定义。

```
let rec max2 (n1, n2) : num =
  match (n1, n2) with
     (Real_num r1, Real_num r2) -> Real_num (max r1 r2)
   | (Int_num i1, Int_num i2) -> Int_num (max i1 i2)
   | (_, Int_num i2) -> max2 (n1, Real_num (float_of_int i2))
   | (Int_num i1, _) -> max2 (n2, Real_num (float_of_int i1))

```

请注意，在`max2`中的`match`表达式匹配了数字`n1`和`n2`的元组。因此，案例表达式中的所有模式都是元组形式。例如，模式`(Real_num r1, Real_num r2)`只有当两个数字都是浮点数时才匹配。

在第三和第四种模式中，我们使用了一个“通配符”（或默认）模式。例如，第三种模式`(_, Int_num i2)`匹配的条件是第一个数字可以是任何值，但第二个数字必须是整数。在这种情况下，我们只需将整数转换为浮点数，然后递归调用自身。同样，第四种模式`(Int_num i1, _)`第一个数字是整数，第二个数字可以是任何值。在这种情况下，我们将第一个数字转换为浮点数，然后递归调用自身。

现在假设我们用两个整数调用`max2 max2 (Int_num 3, Int_num 4)`。看起来好像这匹配了最后三种情况中的任何一种，那么我们应该选择哪一个呢？答案是我们按顺序尝试匹配。因此第二种模式会成功，其他模式甚至不会尝试。

另一个问题是，我们如何知道每种情况都有一个案例呢？例如，假设我们不小心写成：

```
let rec max3 (n1, n2) : num =
  match (n1, n2) with
     (Int_num i1, Int_num i2) -> Int_num (max i1 i2)
   | (_, Int_num i2) -> max3 (n1, Real_num (float_of_int i2))
   | (Int_num i1, _) -> max3 (n2, Real_num (float_of_int i1))

```

现在没有考虑`n1`和`n2`都是浮点数的情况。如果你在 OCaml 中输入这个，它会抱怨模式匹配不是穷尽的。这很好，因为它告诉你你的代码可能会失败，因为你忘记了一个情况！一般来说，我们*不会*接受有不穷尽警告的代码。也就是说，你必须确保你永远不会提交没有覆盖所有情况的代码。

如果我们添加了太多的情况会发生什么？例如，假设我们写成：

```
let rec max2 (n1, n2) : num =
  match(n1, n2) with
     (Real_num r1, Real_num r2) -> Real_num(max r1 r2)
   | (Int_num i1, Int_num i2) -> Int_num (max i1 i2)
   | (_, Int_num i2) -> max2 (n1, Real_num (float_of_int i2))
   | (Int_num i1, _) -> max2 (n2, Real_num (float_of_int i1))
   | (_, _) -> n1

```

然后 OCaml 会抱怨最后一个匹配情况未被使用（即永远不会被执行）。这很棒，因为它告诉我们有一些无用的代码，我们应该将其删除或重新检查为什么它永远不会被执行。再次强调，我们*不会*接受有冗余模式的代码。

那么 OCaml 类型检查器如何确定模式匹配是穷尽的，没有死代码呢？原因是模式只能测试有限数量的事物（模式中没有循环），测试相当简单（例如，这是一个`Real_num`还是一个`Int_num`？）并且给定类型的数据构造函数集是*封闭*的。也就是说，在定义数据类型之后，我们不能简单地向其添加新的数据构造函数。请注意，如果可以的话，那么*每个*模式匹配都可能是不穷尽的。

起初，这似乎是语言的一个缺点。添加新的构造函数是经常发生的事情，就像在 Java 程序中经常添加新的子类一样。在 OCaml 中的区别在于，如果您向数据类型声明添加了新的数据构造函数，那么编译器将通过“匹配不完全”错误告诉您需要检查或更改代码的位置。这使得模式匹配成为程序维护和演化的无价工具。

有时，通过*限制*编程语言，我们可以获得一些力量。在 OCaml 的模式匹配子语言中，设计者限制了可以执行的测试集，以便编译器可以自动告诉您需要查看代码的位置，以使其与您的定义同步。
