# 讲座 19：逻辑

+   介绍

+   命题

+   推理规则

+   一个示例证明

## 介绍

我们能证明任何给定的程序对所有可能的输入都有效吗？不，那个问题是不可判定的。但是，我们能开发一个针对给定可计算任务的程序，以便我们可以证明它对所有可能的输入都有效吗？原则上是可以的。实际上，这种方法耗时太长，无法应用于大型程序。但是，看看如何构建正确性证明是有用的：

+   对于绝对必须有效的简短代码，正确性证明非常有用。

+   自动定理证明器继续改进，并且证明正确性变得越来越具有成本效益。

+   理解证明程序正确意味着你成为一个更好的程序员。

什么是证明？一个完全令人信服的论证，证明某事是真实的。对于一个论证要完全令人信服，它应该由小步骤组成，每一步都是显而易见的。事实上，每一步都应该如此简单和明显，以至于我们可以构建一个计算机程序来检查证明。需要两个要素：

1.  用于清楚表达我们想要证明的内容的语言。

1.  构建显然正确的步骤的论证规则。

一个 **逻辑** 实现了这两个目标。

证明程序正确的策略将是将程序及其规范转换为纯逻辑语句，该语句要么为真，要么为假。如果该语句为真，则程序是正确的。但是为了使我们的证明真正令人信服，我们需要清楚地理解证明是什么。

有趣的是，数学家直到 20 世纪才真正研究他们正在构建的证明。一旦他们这样做了，他们发现逻辑本身是一个深刻的主题，对数学的其余部分有很多影响。

## 命题

我们从**命题逻辑**开始，这是一种由简单符号组成的逻辑，表示关于某个世界的命题。对于我们的例子，我们将使用字母 A、B、C、... 作为命题符号。例如，这些符号可能代表各种命题：

+   A = "期末考试得了 90%"

+   B = "每次上课都出席"

+   C = "在课堂上得了 A"

+   D = "x + 1 ≤ y"

+   E = "e ∈ s"

*命题*逻辑并不是为这些符号分配含义的工作。但是，我们使用语句来表达 D 和 E 的含义，以讨论程序的正确性。

### 命题的语法

我们从这些符号构建的 **命题** 的语法开始。我们使用字母 P、Q、R 来表示命题（或 **公式**）：

```
P,Q,R ::= ⊤              (* true *)
        | ⊥              (* false *)
        | A, B, C        (* propositional symbols *)
        | ¬P             (* sugar for P⇒⊥ *)
        | P ∧ Q          (* "P and Q" (conjunction) *)
        | P ∨ Q          (* "P or Q" (disjunction) *)
        | P ⇒ Q         (* "P implies Q" (implication) *)
        | P ⇔ Q         (* "P if and only if Q" (double implication) *)

```

注：在某些浏览器上，在某些操作系统上，在某些字体上，连词（and）的符号可能会被错误地渲染为一个小圆圈。它应该看起来像一个倒置的 ∨。在本文档中，它将以 `∧`、∧ 或 ∧ 的形式出现。

这些形式的优先级随着列表向下减少，所以 P ∧ Q ⇒ R 和 (P ∧ Q) ⇒ R 是相同的。需要注意的一件事是，⇒ 是右结合的（就像 → 一样），所以 P ⇒ Q ⇒ R 和 P ⇒ (Q ⇒ R) 是相同的。我们将根据需要引入括号以便清晰。我们使用逻辑否定的符号表示，但它实际上只是 ⊥ 的含义 P ⇒ 的句法糖。我们还将 P ⇔ Q 写成句法糖为 (P ⇒ Q) ∧ (Q ⇒ P)，意味着 P 和 Q 在逻辑上等价。

这个语法定义了命题的语言。通过适当的命题符号，我们可以表达各种有趣的陈述，例如：

A ∧ B ⇒ C

"如果我期末考得了 90 分并且我上了课，我会得到 A"

¬C ⇒ (¬A ∨ ¬B)

"如果我在课上没得 A，那么我要么期末考没得 90 分，要么我没上课"

C ∨ ¬A ∨ ¬B

"我要么在课上得了 A，要么我期末考没得 90 分，要么我没上课"

实际上，这三个命题都是逻辑上等价的，这是我们可以确定的，而不需要知道期末考试和出勤的具体含义。

## 证明

测试命题是否是永真式通过测试每一种可能的真值赋值是昂贵的——有指数多种情况。我们需要一个**演绎系统**，它将允许我们逐步构造永真式的证明。

我们将使用的系统被称为**自然推导**。该系统由一组**推理规则**组成，用于从前提中推导出结果。一个证明树被构建，其根是要证明的命题，其叶子是最初的假设或公理（对于证明树，我们通常将根绘制在底部，将叶子绘制在顶部）。

例如，我们系统的一个规则被称为**假言推理**。直觉上，这意味着如果我们知道 P 是真的，而且我们知道 P 意味着 Q，那么我们可以得出 Q。

上面的命题称为**前提**；线下的命题是**结论**。前提和结论都可能包含元变量（在这种情况下为 P 和 Q），代表任意命题。当推理规则作为证明的一部分使用时，元变量以一致的方式替换为相应类型的对象（在这种情况下为命题）。

在非正式证明过程中，我们通常做临时假设。在正式证明中， ⊢ 符号（读作"推导符"）用于将这些临时假设与我们正在证明的陈述分开。假设放置在推导符的左侧，结论放置在右侧。**断言** P ⊢ Q 应该读作 "在前提 P 下 Q 成立"。

## 推理规则

大多数规则分为两种类型之一：**引入**规则或**消除**规则。引入规则告诉我们如何证明包含逻辑运算符的结论（"将"其引入到结论中），而消除规则告诉我们如何使用一旦证明的逻辑陈述（"从"前提中消除）。

例如，假言推理是 ⇒ 的消去规则：它告诉我们一旦我们证明了 P ⇒ Q，我们可以得出什么结论。这里是上述逻辑连接词的引入和消去规则：

| 规则名称 | 规则 | 直觉 |
| --- | --- | --- |
| ∧ | 引入 |  | 要证明 (在没有假设的情况下) P∧Q 成立，我们必须证明 P 成立 (⊢P)，并且我们必须证明 Q 成立 (⊢Q)。 |
| 消去 |  | 如果我们知道 P∧Q，我们可以用它来推导出 P。我们也可以用它来推导出 Q。 |
| ∨ | 引入 |  | 我们可以通过证明 P 或者证明 Q 来证明 P∨Q。 |
| 消去 |  | 如果我们知道 P∨Q 成立，并且我们可以证明在 P 成立的情况下 R 成立，我们也可以证明在 Q 成立的情况下 R 成立，那么我们知道 R 在任何情况下都成立，因此 R 成立。 |
| ⇒ | 引入 |

&#124; P⊢Q &#124;

&#124; ⊢P⇒Q &#124;

| 要证明 P⇒Q，我们首先假设 P，然后在这个假设下我们必须证明 Q |
| --- |
| 消去 |

&#124; ⊢P &#124; ⊢ P⇒Q &#124;

&#124; ⊢Q &#124;

| 如果我们知道 P⇒Q，并且我们知道 P，那么我们可以得出 Q。 |
| --- |
| ¬ | 引入 |

&#124; ⊢P⇒⊥ &#124;

&#124; ⊢¬P &#124;

| ¬P 只是 P⇒⊥ 的简写，所以我们有转换这些表示之间的规则。 |
| --- |
| 消去 |

&#124; ⊢¬P &#124;

&#124; ⊢P⇒⊥ &#124;

|

| T | 引入 |
| --- | --- |

&#124;  &#124;

&#124; ⊢T &#124;

| 证明 "true" 是很容易的！（但它对你没什么用 —— 没有消去规则） |
| --- |
| ⊥ | 消去 |

&#124; ⊢⊥ &#124;

&#124; ⊢P &#124;

| 如果你设法证明 "false"，你可以得出任何你想要的结论。（但祝你好运证明它 —— 没有引入规则） |
| --- |
| 假设 |

&#124;  &#124;

&#124; P⊢P &#124;

| 你可以使用你的假设。 |
| --- |
| 排除中间项 |

&#124;  &#124;

&#124; ⊢P∨¬P &#124;

| 每个命题要么为真，要么为假 |
| --- |

## 一个示例证明

现在我们将逐步展示一个关于 (A∧B⇒C)⇒(¬C⇒¬A∨¬B) 的形式化证明。通常最容易构造这些证明的方式是"目标导向"的方式 —— 我们从结论开始构建证明树。我们的目标是 ⊢(A∧B⇒C)⇒(¬C⇒¬A∨¬B)。为了非正式地证明这一点，我们会假设蕴含关系的左侧，并尝试证明 RHS。形式上，我们应用 ⇒ 引入规则：

|

&#124; (A∧B⇒C) ⊢ ¬C⇒¬A∨¬B &#124;

&#124; ⊢ (A∧B⇒C)⇒(¬C⇒¬A∨¬B) &#124;

| (⇒ 引入) |
| --- |

现在我们必须构造一个 ¬C⇒¬A∨¬B 的证明。同样，我们应用 ⇒ 引入规则，因为我们试图证明一个蕴含关系：

现在我们必须展示 ¬A 或 ¬B 成立，但我们想要使用的证明取决于 A 是否为真。所以我们将使用排除中间项引入 A∨¬A，并且我们将使用 ∨ 消去规则来证明我们当前的目标：

剩下的两个子目标中的第二个很容易：

因此，我们现在需要证明的是 (A∧B⇒C), ¬C ⊢ A ⇒ ¬A∨¬B。我们再次使用排除中间项法将证明分成情况，这次是针对 B：

进展已经取得！剩下的就是证明 A∧B⇒C, ¬C, A, B ⊢ ¬A ∨ ¬B（从中间分支）。在这一点上，我们的假设中存在矛盾，所以我们将使用它：

现在我们已经完成了所有的子目标，这意味着我们已经完成了证明。要组装最终的证明，我们只需将以上构建的各部分连接起来即可。

正如我们在课程中之前看到的非正式证明相比，这样的形式证明既有优点又有缺点。优点在于每一步都是完全明确的，可以完全机械地检查。缺点在于我们必须写下每一步，而且为了证明定理的真实性，高层次的论证变得模糊不清。
