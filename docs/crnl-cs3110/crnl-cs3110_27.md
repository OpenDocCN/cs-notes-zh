# 第 17 节：验证示例，逻辑复习

在上一节讲座中，我们看到了一个验证的例子。今天我们将看另一个例子。

考虑以下递归实现一个函数`lmax`，它计算非空列表的最大元素：

```
(* Returns: lmax xs  is the maximum element in the list xs.
 * Checks: xs != []
 *)
let rec lmax (xs : int list) : int =
    match xs with
        [] -> raise (Failure "requires clause of max violated")
      | [x] -> x
      | x :: t -> max x (lmax t)

```

我们如何处理递归函数？我们将使用一种假设的方法，即递归调用时递归函数满足其规格。然后，正确性的证明将确保函数实现的**部分正确性**，我们可以将其与**完全正确性**区分开：

> **部分正确性**：每当函数在满足前置条件并终止时被应用，它产生满足后置条件的结果。
> 
> **完全正确性**：函数具有部分正确性，并且在应用函数时总是终止。

这种方法的好处是，我们可以将证明函数计算正确答案的问题与证明函数终止的问题分开。

### 部分正确性

让我们证明部分正确性。首先，我们需要更加准确地了解我们的后置条件。列表的元素是什么？我们可以定义一个函数，通过对列表进行归纳，给出我们的元素：

> elements(`[]`) = ∅
> 
> elements(h `::` t) = {h} ∪ elements(t)

就像一个抽象函数一样，这个函数将从 OCaml 列表的具体域映射到更抽象的数学域，即集合的域。

| 表达式 | 假设 | 正当化 |
| --- | --- | --- |
| `lmax xs` | xs ≠ [] | 考虑满足前置条件的任意调用。 |
| `match xs with []-> ...` | xs ≠ [] | 展开函数体。现在我们需要创建情况来知道`match`会走哪个路线。这里有三种穷举情况：xs = []，xs = [x]，xs = x :: t。 |
| 情况 xs = [] |
| `raise (Failure ...)` | xs ≠ [] | 根据我们的假设，这种情况不可能发生。后置条件被空泛地满足。 |
| 情况 xs = [x] = x :: [] |
| `x` | xs = [x] | 结果是`xs`中唯一的元素，因此`elements(xs) = {x}`，因此`x`是`elements(xs)`中的最大元素。 |
| 情况 xs = x::t 且 t ≠ [] |
| `max x (lmax t)` | xs = x::t t ≠ [] | 现在可以将`lmax`应用于`t`；关键是，`t`不是空列表，因此`lmax`的前置条件得到满足。 |

| `max x n1` | xs = x::t t ≠ []

n1 = elements(t)的最大值 | 现在我们可以应用函数`max`，使用*它*的规格，得到满足`max`后置条件的一些值 n2。 |

| `n2` | xs = x::t t ≠ []

n1 = elements(t)的最大值

(n2 = x 或

n2 = n1）

n2 ≥ x

n2 ≥ n1 | 根据集合最大元素的数学定义，值 n1 必须是 t 的一个元素，并且必须至少与 t 的任何元素一样大。规范指出 n2 必须是 xs 的一个元素，并且至少与 xs 的任何元素一样大。我们从元素的定义知道，elements(xs) = {x}∪elements(t)。因此 n2 必须是 xs 的一个元素，因为它要么是 x，要么是 n1，而 n1 是 t 的一个元素。此外，n2 必须至少与 x 一样大（n2 ≥ x）。并且它必须至少与 elements(t) 一样大，因为它至少与 n1 一样大，而 n1 至少与 t 的任何元素一样大。因此在这种情况下，n2 是 xs 的最大元素。 |

| QED |
| --- |

### 总正确性

证明总正确性的关键是证明递归不能永远进行。我们需要能够将函数参数映射到具有最小元素的集合上。通常，我们通过给出一个**减函数** d(x)，将函数参数 x 映射到自然数上来实现这一点。减函数 d 具有两个属性：

+   它将任何满足前置条件的函数参数映射到一个自然数（≥ 0）上：

    PRE ⇒ 0 ≤ d(x)

+   每当有递归调用时，减函数应用于递归调用的参数 x' 时都会严格变小：

    0 ≤ d(x') < d(x).

    当减函数为零时，意味着没有递归调用。

这些条件确保减函数在每次递归调用时都变得更小，但不能永远变小。

例如，在 `lmax` 中，一个适当的减函数是：d(x) = `List.length`(x) − 1\. 它必须是非负的；当它为零时，函数终止；而且对 `lmax` 的递归调用是在一个更短的列表 `t` 上进行的。

## 命题逻辑回顾

请回顾 CS 2800 中*命题*逻辑是由表示有关某个世界命题的简单符号构建的逻辑。对于我们的例子，我们将使用字母 A、B、C，... 作为命题符号。例如，这些符号可能代表各种命题：

+   A = "期末考试得了 90%"

+   B = "每次上课都有参加"

+   C = "在课程中得了 A"

+   D = "x + 1 ≤ y"

+   E = "e ∈ s"

*命题*逻辑的工作不是为这些符号分配含义。但是，我们使用关于 D 和 E 的含义的语句来讨论程序的正确性。

我们为从这些符号构建的**命题**定义了一个语法。我们使用字母 P、Q、R 来表示命题（或**公式**）：

```
P,Q,R ::= ⊤              (* true *)
        | ⊥              (* false *)
        | A, B, C        (* propositional symbols *)
        | ¬P             (* sugar for P⇒⊥ *)
        | P ∧ Q          (* "P and Q" (conjunction) *)
        | P ∨ Q          (* "P or Q" (disjunction) *)
        | P ⇒ Q         (* "P implies Q" (implication) *)
        | P ⇔ Q         (* "P if and only if Q" (double implication) *)

```

注意：在某些浏览器、某些操作系统、某些字体上，合取（并且）的符号被错误地渲染为一个小圆圈。它应该看起来像一个倒置的∨。在这些课程笔记中，它将以 `∧`，∧，或∧ 的形式出现。

随着我们往下看，这些形式的优先级会降低，因此 P ∧ Q ⇒ R 和 (P ∧ Q) ⇒ R 是一样的。需要注意的一点是，⇒ 是右结合的（就像 → 一样），所以 P ⇒ Q ⇒ R 和 P ⇒ (Q ⇒ R) 是一样的。我们会根据需要引入括号以保持清晰。我们会使用逻辑否定的符号，但实际上它只是蕴含 P ⇒ ⊥ 的一种语法糖。我们也将 P ⇔ Q 写成 (P ⇒ Q) ∧ (Q ⇒ P) 的语法糖，意思是 P 和 Q 在逻辑上是等价的。

这个语法定义了命题的语言。通过合适的命题符号，我们可以表达各种有趣的陈述，例如：

A ∧ B ⇒ C

"如果我期末考试得了 90 分，并且我上了课，那我就会得到 A"

¬C ⇒ (¬A ∨ ¬B)

"如果我在课堂上没有得到 A，那么要么我期末考试没得到 90 分，要么我没有上课"

C ∨ ¬A ∨ ¬B

"要么我在课堂上得到了 A，要么我期末考试没有得到 90 分，要么我没有上课"

实际上，这三个命题都是逻辑等价的，我们可以在不知道期末考试和上课意味着什么的情况下确定这一点。
