# 朗诵 3：高阶函数，匿名函数，柯里化，副作用，打印和异常

这个朗诵涵盖：

+   高阶函数

+   匿名函数

+   柯里化

+   副作用和打印

+   异常

## 高阶函数

函数在 OCaml 中就像任何其他值一样。这究竟意味着什么？这意味着我们可以将函数作为参数传递给其他函数，我们可以将函数存储在数据结构中，我们可以从其他函数返回函数作为结果。这个完整的含义直到后来才会让你明白，但相信我们，它会。

让我们看看为什么拥有高阶函数很有用。第一个原因是它允许您编写更通用的代码，因此更可重用的代码。作为一个运行示例，考虑整数上的函数*double*和*square*：

```
let double (x : int) : int = 2 * x
let square (x : int) : int = x * x

```

现在让我们想出一个函数来将一个数字四倍。我们本可以直接做，但出于完全扭曲的动机，决定使用上面的*double*函数：

```
let quad (x : int) : int = double (double x)

```

��够直接了。那么一个将整数提升到四次幂的函数呢？

```
let fourth (x : int) : int = square (square x)

```

这两个函数之间有一个明显的相似性：它们的作用是将一个给定的函数两次应用于一个值。通过将函数传递给另一个函数`twice`作为参数，我们可以抽象出这个功能，从而重用代码：

```
let twice ((f : int -> int), (x : int)) : int = f (f x)

```

使用这个，我们可以写：

```
let quad (x : int) : int = twice (double, x)
let fourth (x : int) : int = twice (square, x)

```

我们利用了这两个函数之间的相似性来节省工作。这可能非常有帮助。如果有人提出了一个改进（或更正）版本的`twice`，那么使用它的每个函数都会从改进中受益。

函数`twice`是所谓的*高阶函数*：它是一个从函数到其他值的函数。注意`twice`的类型是`((int -> int) * int) -> int`。

为了避免污染顶层命名空间，将函数定义为局部函数以传递为参数可能很有用。例如：

```
let fourth (x : int) : int =
  let square (y : int) : int = y * y in
    twice (square, x)

```

为了在接下来要做的评估示例中更清晰，让我们使用上周看到的函数的另一种语法来重新编写：

```
let fourth = fun x ->
  let square = fun y -> y * y in
    twice (square, x)

```

当我们评估使用高阶函数的表达式时会发生什么？我们使用与之前相同的规则：当一个函数被应用（调用）时，我们用函数体替换调用，用参数变量（实际上是出现在参数模式中的变量）绑定到相应的实际值。例如，`fourth 3`的评估如下：

```
 fourth 3
   --> (fun x -> let square = fun y -> y * y in twice (square, x)) 3
   --> let square = fun y -> y * y in twice (square, 3)
   --> twice (fun y -> y * y, 3)
   --> (fun y -> y * y) ((fun y -> y * y) 3)
   --> (fun y -> y * y) (3 * 3)
   --> (fun y -> y * y) 9
   --> 9 * 9
   --> 81

```

* * *

## 匿名函数

我们刚刚使用的“替代语法”对于函数来说是更加广泛有用的。您可能会注意到，定义和命名一个函数只是为了将其作为参数传递给另一个函数似乎有点愚蠢。毕竟，我们真正关心的是`twice`得到一个将其参数加倍的函数。幸运的是，OCaml 提供了一个更好的解决方案——匿名函数：

```
let fourth (x : int) : int = twice (fun (y : int) -> y * y, x)

```

我们引入一个新表达式，表示“一个期望某种类型的参数并返回某个表达式值的函数”：

*e* ::= ...  |  `fun` `(`*x* : *t*`) ->` *e*

`fun`表达式创建了一个**匿名函数**：一个没有名称的函数。参数类型可以省略；OCaml 将自动推断它。匿名函数的返回类型未声明，会自动推断。`fun (y : int) -> y = 3`的类型是什么？

**答案：** `int -> bool`

请注意声明

```
let square : int -> int = fun (y : int) -> y * y

```

具有相同效果的是

```
let square (y : int) : int = y * y

```

实际上，没有`fun`的声明只是对更繁琐的长定义的**语法糖**。（但对于递归函数来说不是这样。）

* * *

## 柯里化

匿名函数对于创建传递给其他函数的函数很有用，但也对编写返回其他函数的函数很有用。让我们将`twice`函数重写为接受一个函数作为参数并返回一个将原始函数应用两次的新函数：

```
let twice (f : int -> int) =
  fun (x : int) -> f (f x)

```

此函数接受一个类型为`int -> int`的函数`f`作为参数，并返回值`fun (x : int) -> f (f x)`，这是一个函数，当应用于参数时，将`f`应用两次于该参数。因此，我们可以写成

```
let fourth = twice (fun (x : int) -> x * x)
let quad = twice (fun (x : int) -> 2 * x)

```

并尝试评估`fourth 3`确实会产生`81`。

函数返回其他函数在函数式编程中非常常见，因此 OCaml 为它们提供了特殊的语法。例如，我们可以将上面的 twice 函数写成

```
let twice (f : int -> int) (x : int) : int = f (f x)

```

这里的“第二个参数”`x`不是`twice`的参数，而是`twice f`的参数。函数`twice`只接受一个参数，即函数`f`，并返回*另一个*函数，该函数接受一个参数`x`并返回一个`int`。这里的区别至关重要。

此设备称为*柯里化*，取自逻辑学家 H·B·柯里的名字。此时，您可能担心返回中间函数的效率，因为您最终会一次性传递所有参数。如果您想测试一下（您应该找出如何做到这一点），但请放心，柯里化函数在函数式语言中是完全正常的，因此没有值得担心的速度惩罚。

`twice`的类型是`(int -> int) -> int -> int`。`->`运算符是右结合的，因此这等价于`(int -> int) -> (int -> int)`。请注意，如果我们省略了对`f`类型的括号，我们将不再有一个接受另一个函数作为参数的函数，因为`int -> int -> int -> int`等价于`int -> (int -> (int -> int))`。

以下是更多有用的高阶函数示例，我们留给您思考（并在家里尝试）：

```
let compose ((f, g) : (int -> int) * (int -> int)) (x : int) : int =
  f (g x)

```

```
let rec ntimes ((f, n) : (int -> int) * int) =
  if n = 0
  then (fun (x : int) -> x)
  else compose (f, ntimes (f, n - 1))

```

* * *

## 副作用

到目前为止，我们只向您展示了纯函数式编程。但在某些情况下，命令式编程是不可避免的。打印值到屏幕就是其中之一。到目前为止，您可能发现在没有任何方法在屏幕上显示中间值的情况下调试您的 OCaml 代码很困难。OCaml 提供了函数`print_string : string -> unit`来将字符串打印到屏幕上。

打印到屏幕被称为*副作用*，因为它改变了计算机的状态。到目前为止，我们编写的函数没有改变任何状态，只是计算某个值。稍后我们将向您展示更多副作用的示例，但现在打印就足够了。

由于 OCaml 的类型系统，`print_string`不像 Java 的`System.out.println`那样重载。要打印`int`、`float`、`bool`等，必须先将其转换为字符串。幸运的是，有内置函数可以进行这种转换。例如，`string_of_int`将`int`转换为`string`。因此，要打印 3，我们可以写成`print_string (string_of_int 3)`。这里需要括号，因为 OCaml 从左到右评估表达式。

那么如何在代码中放置打印语句呢？有两种方法。第一种是使用`let`表达式。这些可以放在其他`let`表达式中，允许您打印中间值。

```
let x = 3 in
  let () = print_string ("Value of x is " ^ (string_of_int x)) in
  x + 1

```

还有第二种方式。为此，我们引入新的语法。

*e* ::= ...  |  `(`*e*[1]`;` ... `;`*e[n]* `)`

这个表达式告诉 OCaml 按顺序评估表达式*e*[1]，...，*e[n]*并返回评估*e[n]*的结果。因此，我们可以将我们的例子写成

```
let x = 3 in
  (print_string ("Value of x is " ^ (string_of_int x));
   x + 1)

```

* * *

## 异常

为了处理错误，OCaml 提供了内置异常，就像 Java 一样。要声明一个名为`Error`的异常，您可以这样写

```
exception Error

```

然后，要抛出异常，我们使用`raise`关键字。使用平方根函数的示例是

```
let sqrt1 (x : float) : float =
  if x < 0 then raise Error
  else sqrt x

```

异常的类型与抛出异常的代码匹配。例如，在`sqrt1`函数中，`Error`的类型将是`float`，因为表达式必须求值为实数。

异常也可以携带值。一个例子是内置异常`Failure`，定义如下

```
exception Failure of string

```

要引发此异常，我们写

```
raise (Failure "Some error message")

```

我们还可以通过使用`try-with`关键字捕获异常。滥用这种能力是不明智的。过多使用异常会导致难以阅读的意大利面代码。在这门课程中，可能永远不需要处理异常。异常应该只在真正异常的情况下引发，也就是说，在造成无法恢复的损害时。如果可以通过检查边界或使用选项来避免异常，那是更可取的。请参考 OCaml 风格指南，了解更多关于如何正确使用异常的示例和信息。
