# 第 23 课：递归关系

渐近复杂度有其局限性，但仍然是分析和改进程序性能的有用工具。使用大 O 符号简化了分析性能的任务。对于 OCaml，我们假设在评估过程中执行的所有简化都需要常量时间，包括所有算术运算和模式匹配。

如果你从替换模型的角度来思考，这个假设可能会让人感到惊讶。替换可能需要大量工作，因为替换的变量可能会出现在代码中的许多不同位置。然而，OCaml 的实现更接近于求值的环境模型，在这种模型中，实际的替换从未执行过，而是将绑定记录在一个单独的*环境*中以供以后查找。环境可以被实现为所有环境操作（包括查找）都可以在常数时间内执行。

下面的非负整数乘法例程是正确的，但不太高效：

```
let rec times1 a b =
  if b = 0 then 0
  else a + times1 a (b - 1)

```

作为参数`b`的大小函数*n*的时间需求的增长顺序是多少？注意，数字的“大小”可以用它的幅度或数字的位数（写下该数字所需的空间）来衡量。通常使用位数来衡量，但在这里我们使用幅度。请注意，写下一个大小为*x*的数字只需要大约*log[10] x*位，因此这两个度量是非常不同的。

假设`times1`函数中的所有原始操作（`if`、`+`、`=`和`-`）以及函数调用的开销都需要常量时间。因此，如果*n*=0，该例程需要一些常量时间*c*[2]。如果*n*>0，则在大小为*n*的输入上所花费的时间最多为某个常量*c*[1]加上对*n**`-`*`1`的递归调用所花费的时间。换句话说，存在常量*c*[1]和*c*[2]使得*T(n)*满足：

```
*T(n) = T(n-1) + c[1]*     for *n > 0*
*T(0) = c[2]*

```

这是一个**递归关系**（或简称**递归**），定义了一个函数*T(n)*。它简单地说明了将一个数字*a*乘以另一个大小为*n>0*的数字*b*所需的时间是将*a*乘以一个大小为*n`-`1*的数字的时间再加上一定量的工作（执行的原始操作）。

递归关系是一个函数的归纳定义。这个特定的递归关系有一个唯一的**闭合形式解**，它定义了*T(n)*而不涉及任何递归。为了确定递归函数的运行时间，我们将编写描述运行时间的递归，找到它们的闭合形式解，并用大 O 符号表示这些解。

展开这个特定的递归可以给出如何将其转换为闭合形式的一些思路：

```
*T(n) = T(n-1)* + *c[1]*     for *n > 0*
     = *T(n-2)* + *c[1]* + *c[1]*
     = *T(n-3)* + *c[1]* + *c[1]* + *c[1]*
     = ...
     = *T(n-k)* + *kc[1]*    for *0 ≤ k ≤ n*
     = ...
     = *T(0)* + *nc[1]*      for *n ≥ 0*
     = *c[2]* + *c[1]n*        for *n ≥ 0*

```

即为*O(n)*。

更一般地说，我们猜测递归的闭合形式解，然后通过归纳证明它成立。有时，将递归展开几步可以帮助猜测。

现在考虑另一种乘两个数字的过程：

```
let rec times2 a b =
  if b = 0 then 0
  else if even b then times2 (a*2) (b/2)
  else a + times2 a (b-1)

```

再次，我们希望用 *n* 的表达式来表示运行时间，参数 `b` 的大小。我们假设双倍和半操作是常数时间的（这可以通过算术移位在常数时间内完成），以及标准的原语也是常数时间的。对于这个问题，递归关系比之前的更复杂：

```
*T(n) = T(n-1) + c*1   for *n > 0* and *n* odd
*T(n) = T(n/2) + c*2   for *n > 0* and *n* even
*T(0) = c*3

```

我们需要弄清楚这个递归关系的第一分支和第二分支将被执行多少次。如果 *n* 是 2 的幂，即如果 *n = 2^m* 对于某个整数 *m* 成立，那么这就很容易。在这种情况下，当 *n* = 1 时，第二分支只会执行一次，因为 *2^m* 是偶数，除非 *m* = 0，即当 *n* = 1 时。因此，对于这种特殊情况，我们可以使用上面的展开技巧得到关于 *m* 的封闭形式：

```
*T(2^m) = T(2^(m-1))* + *c[2]*     for *m > 0*
     = *T(2^(m-2))* + *c[2]* + *c[2]*
     = ...
     = *T(2^(m-m))* + *mc[2]*    
     = *T(1)* + *mc[2]*    
     = *T(0)* + *c[1]* + *mc[2]*   
     = *c[3]* + *c[1]* + *mc[2]*   

```

这是 *O(log n)*。我们可以通过归纳证明这一点。

## **强归纳**

强归纳与普通归纳有着相同的步骤，你可能还记得来自 CS 2800 的，但归纳假设略有不同：

1.  陈述待证命题 *P*(*n*) 的形式

1.  基本情况：证明 *P*(*n*[0]) 成立

1.  归纳假设：假设对于所有 *n*[0] ≤ *m* ≤ *n*，*P*(*m*) 都成立。这与普通归纳不同，普通归纳只假设 *P*(*m*) 对 *m* = *n* 成立。

1.  归纳步骤：利用归纳假设，证明 *P*(*n*+1) 成立。

1.  结论：*P*(*n*) 对于所有 *n* ≥ *n*[0] 都成立。

我们可以将这个过程形式化为一个推理规则，这个规则给了我们证明对于某个谓词 P，命题 ∀n.P(n) 的方法。以下分别是弱归纳和强归纳的规则：

| **弱归纳：**

&#124; P(0) &#124; ∀n (P(n) ⇒ P(n+1)) &#124;

&#124; ∀n P(n) &#124;

|  | **强归纳：**

&#124; ∀n (∀m (m < n ⇒ P(m)) ⇒ P(n)) &#124;

&#124; ∀n P(n) &#124;

|  |
| --- |

注意，基本情况在强归纳规则中并没有明确出现。然而，它仍然在隐含中存在：对于 n=0，你必须证明 ∀m (m < 0 ⇒ P(m)) ⇒ P(0)，这可以简化为 P(0)，因为∀m (m < 0 ⇒ P(m)) 是虚假的，因为不存在 m < 0。

在实践中，通常用强归纳来证明渐近复杂度边界比用弱归纳更容易，因为你有一个更强的归纳假设可用，即 ∀m m < n ⇒ P(m) 而不是 P(n)。然而，这两个规则在逻辑上是等价的：可以用弱规则证明强规则的有效性，其中归纳假设 P'(n) = ∀m (m < n ⇒ P(m))。

## `times2` 的运行时间

让我们回到对 `times2` 的分析。当 *n* 是 2 的幂时，我们有以下递归：

```
*T(n) = T(n/2) + c*2   for *n > 1* and *n* a power of 2
*T(1) = c*4            where c4 = c3 + c1

```

我们用强归纳来证明 *T(n) = c[2] log n + c[4]* 是这个递归的解。

基本情况：*T(1) = c[4] = c[2] log 1 + c[4]*。

归纳假设：*T(m) = c[2] log m + c[4]* 对于所有 *1 ≤ m < n* 成立。

归纳步骤：

*T(n) = T(n/2) + c[2]*

*= c[2] log(n/2) + c[4] + c[2]* 由 I.H. 推导得出。

*= c2 + c[4] + c[2]*

*= c[2] log n − c[2] + c[4] + c[2]*

*= c[2] log n + c[4]*。

因此，在输入大小为 *n* 且为 2 的幂的情况下，`times2` 的运行时间为 *O(log n)*。

在一般情况下，`times2` 的运行时间也是 *O(log n)*，但我们需要一个稍微不同的递归来更容易地展示这一点。 注意，在连续两次递归调用 `times2` 时，参数 `b` 不可能为奇数，因为当它为奇数时，会减去一个，使其变为偶数。 因此，我们可以将原始递归重写为：

```
*T(n) = T((n−1)/2) + c[1] + c[2]*  for *n > 1* and *n* odd
*T(n) = T(n/2) + c[2]*           for *n > 1* and *n* even
*T(1) = c*4
*T(0) = c*3

```

注意，这个新的事件与重写代码的情况类似，使得两次递归调用都将输入大小减半：

```
let rec times3 a b =
  if b = 0 then 0
  else if even b then times3 (a*2) (b/2)
  else a + times3 (a*2) ((b-1)/2)

```

对于这个递归式找到一个封闭形式的解有点困难。 但是，使用强归纳，我们可以证明无论它是什么，对于足够大的常数 *d* 和 *e*，它都被形式为 *d log n + e* 的函数渐近地界定，并且这足以证明解为 *O(log n)*。 因此，我们想要通过强归纳来证明 *T(n) ≤ d log n + e* 对于一些（尚未确定的）常数 *d* 和 *e*。 为了找到合适的 *d* 和 *e*，我们将直接开始并查看使证明有效的需要什么。

基本情况：我们希望 *T(1) = c[4] ≤ d log 1 + e*。 只要我们选择 *e ≥ c[4]*，这就成立。

归纳假设：对于所有 *1 ≤ m < n*，*T(m) ≤ d log m + e*。

归纳步骤，*n* 为偶数：

*T(n) = T(n/2) + c[2]*

*≤ d log(n/2) + e + c[2]* 通过 I.H.

*= d log n − d + e + c[2]*

*≤ d log n + e*，只要我们选择 *d ≥ c[2]*。

归纳步骤，*n* 为奇数：

*T(n) = T((n−1)/2) + c[1] + c[2]*

*≤ d log((n−1)/2) + e + c[1] + c[2]* 通过 I.H.

*= d log(n−1) − d + e + c[1] + c[2]*

*≤ d log n − d + e + c[1] + c[2]*

*≤ d log n + e*，只要我们选择 *d ≥ c[1] + c[2]*。

选择足够大的 *d* 和 *e* 来满足所有这些条件，我们看到 *T(n) ≤ (c[1] + c[2]) log n + c[4]* 对于所有 *n ≥ 1* 成立，因此 *T(n)* 是 *O(log n)*。
