# 第十讲：红黑树

集合和映射是重要且有用的抽象。我们已经看到了实现集合和映射的抽象数据类型的各种方法，因为实现集合的数据结构也可以用来实现映射。今天我们将看一种渐进有效且在实践中有用的集合实现。这种实现是几种*平衡二叉树*方案之一。

与渐进更高效的哈希表相比，二叉树具有两个优点：首先，它们支持非破坏性更新，具有相同的渐进效率。其次，它们按顺序存储它们的值（或键，在地图的情况下），这使得范围查询和按顺序迭代成为可能。

搜索树的一个重要属性是它可以轻松实现**有序集合**或有序映射：保持其元素按排序顺序排列的集合（映射）。虽然我们今天不会考虑这样的操作，但有序集合通常提供查找集合的最小和最大元素、在两个元素之间迭代所有元素以及提取（或迭代）在范围之间的元素的操作。

## 二叉搜索树

在 OCaml 中，很容易归纳地定义二叉树。我们将使用以下定义，将内部（非叶）节点表示为包含类型为`'a`的值和两个子节点的`TNode`，将叶表示为`TLeaf`。在这种表示中，叶子不包含数据。

```
type 'a tree = TNode of 'a * 'a tree * 'a tree | TLeaf

```

一个**二叉搜索树**是具有以下表示不变式的二叉树：

> 对于任何节点*n*，*n*的左子树中的每个节点的值都小于*n*的值，而*n*的右子树中的每个节点的值都大于*n*的值。

给定这样的树，如何执行查找操作？从根开始。在每个节点，如果节点的值是你要查找的值，那么就完成了。否则，根据你要查找的值是小于还是大于当前节点存储的值，在左子树或右子树中递归搜索。在代码中：

```
let rec contains x = function
    TLeaf -> false
  | TNode (y, l, r) ->
      x = y || (x < y && contains x l) || contains x r

```

注意关键字`function`的使用，这样模式匹配中使用的变量不需要被命名。这相当于（不必要地）命名一个变量，然后使用`match`：

```
let rec contains x t =
  match t with
      TLeaf -> false
    | TNode (y, l, r) ->
        x = y || (x < y && contains x l) || contains x r

```

添加元素类似：你进行查找，直到找到应该包含该值的空节点。这是一种非破坏性更新，因此当递归完成时，将构造一个新的树，它与旧树完全相同，只是具有一个新节点（如果需要）：

```
let rec add x = function
    TLeaf -> TNode (x, TLeaf, TLeaf) (* If at a leaf, put new node there *)
  | TNode (y, l, r) as t -> (* Recursively search for value *)
      if x = y then t
      else if x > y then TNode (y, l, add x r)
      else (* x < y *) TNode (y, add x l, r)

```

这些操作的运行时间是多少？由于`add`仅是具有额外常量时间节点创建的`lookup`，我们将重点放在`lookup`操作上。显然，`lookup`的运行时间为*O*(*h*)，其中*h*为树的高度。树的最坏情况高度是多少？它发生在所有节点都在单个长分支上的树中（想象一下按顺序将数字 1,2,3,4,5,6,7 添加到二叉搜索树中）。因此，查找的最坏运行时间仍然是*O*(*n*)（*n*为树中的节点数）。

什么样的树形状能够实现快速查找呢？一个**完美二叉树**在给定高度*h*时具有最大的节点数*n*：*n* = 2^(*h*+1)−1。因此*h* = log(*n*+1)−1 = *O*(log *n*)。（如果未指定，对数始终以 2 为底，虽然这并不重要，因为是*O*( )。）

```
          ^                   50
          |               /        \
          |           25              75
 height=3 |         /    \          /    \
  n=15    |       10     30        60     90
          |      /  \   /  \      /  \   /  \
          V     4   12 27  40    55  65 80  99

```

如果保持一棵拥有*n*个节点的树平衡，其高度为*O*(log *n*)，这导致查找操作在*O*(log *n*)的时间内完成。

我们如何保持树的平衡？在添加或删除元素过程中，树可能会失去平衡。大多数平衡树方案涉及添加或删除元素，就像在普通二叉搜索树中一样，然后进行某种树形手术来重新平衡树。一些平衡二叉搜索树数据结构的例子包括

+   AVL（或高度平衡）树（1962）

+   2-3 树（1970 年代）

+   红黑树（1970 年代）

在这些情况下，我们通过对数据结构施加比二叉搜索树不变式更强的不变式，确保渐近复杂度为*O*(log *n*)。

## 红黑树

红黑树是一种维持平衡二叉树的相当简单而非常有效的数据结构。其思想是加强表示不变式，使得树的高度对数于*n*。为了帮助执行不变式，我们给树的每个节点着色为*红*或*黑*。在需要时，我们将空树的颜色视为黑色。

```
type color = Red | Black
type 'a rbtree =
  Node of color * 'a * 'a rbtree * 'a rbtree | Leaf

```

这里是我们添加到二叉搜索树表示不变式的新条件：

1.  沿着任意路径不存在两个相邻的红色节点。

1.  从根到叶子的每条路径上具有相同数量的黑色节点。这个数字称为树的*黑高度*（BH）。

如果一棵树满足这两个条件，那么每棵子树也必须满足这些条件。如果一棵子树违反了这些条件中的任何一个，那么整棵树也会违反。

另外，我们要求树的根节点着色为黑色。这总是可以通过简单地将其颜色设置为黑色来实现；这样做不会违反任何其他不变式。

具有这些不变量，从根到空节点的最长可能路径将交替包含红色和黑色节点；因此，它最多比只包含黑色节点的最短路径长两倍。如果*n*是树中的节点数，则最长路径的长度不能大于完美二叉树中路径的两倍长度：2 log *n*，即 O(log *n*)。因此，树的高度为 O(log *n*)，所有操作在节点数的渐近对数中。

另一种看待这个问题的方法是只考虑树中的黑色节点。假设我们剪掉树中的所有红色节点，并将每个黑色节点重新连接到其最近的黑色祖先。然后我们得到一棵树，其叶子节点都在深度 BH 处，其分支因子在 2 和 4 之间。这样的树必须包含至少Ω(2^(BH))个节点，当我们将红色节点重新添加时，整个树也必须包含这么多节点。如果*n*是Ω(2^(BH))，那么黑色高度 BH 是*O*(log *n*)。但不变量 1 表明最长路径最多为*h* = 2BH。因此*h*也是*O*(log *n*)。

我们如何检查红黑树中的成员资格？与一般二叉树一样。

```
let rec mem x = function
    Leaf -> false
  | Node (_, y, left, right) ->
      x = y || (x < y && mem x left) || (x > y && mem x right)

```

更有趣的是`insert`操作。与标准二叉树一样，我们通过替换搜索过程找到的叶子节点来添加一个节点。我们还将新节点着为红色，以确保保持不变量 2。然而，这可能通过产生两个相邻的红色节点破坏不变量 1。为了恢复不变量，我们不仅考虑新的红色节点及其红色父节点，还考虑其（黑色）祖父节点。下图显示了可能出现的四种情况。

```
       1 2 3 4

       Bz            Bz            Bx            Bx
      / \           / \           / \           / \
     R[y]  d         R[x]  d         a   R[z]        a   R[y]
    /  \          / \               /  \          /  \
  R[x]   c         a   R[y] R[y]   d        b    R[z]
 /  \               /  \          / \                /  \
a    b             b    c        b   c              c    d

```

请注意，在这些树中，节点 a、b、c、d 的值必须相对于 x、y 和 z 具有相同的顺序关系：a < x < b < y < c < z < d。因此，我们可以通过用上述四种情况之一替换任何一个来转换树，从而在本地恢复不变量。

```
     R[y]
    /  \
  Bx    Bz
 / \   / \
a   b c   d

```

这个平衡函数可以简单而简洁地使用模式匹配编写，其中每个四种输入情况映射到相同的输出情况。此外，还有一种情况是树在本地保持不变。

```
let balance = function
    Black, z, Node (Red, y, Node (Red, x, a, b), c), d
  | Black, z, Node (Red, x, a, Node (Red, y, b, c)), d
  | Black, x, a, Node (Red, z, Node (Red, y, b, c), d)
  | Black, x, a, Node (Red, y, b, Node (Red, z, c, d)) ->
      Node (Red, y, Node (Black, x, a, b), Node (Black, z, c, d))
  | a, b, c, d -> Node (a, b, c, d)

```

这种平衡转换可能会在树中的上一级破坏不变量 1，但可以以相同方式在该级别恢复，依此类推。在最坏的情况下，这个过程一直级联到根，导致两个相邻的红色节点，其中一个是根。但如果这种情况发生，我们可以将根节点重新着色为黑色，这会增加 BH 一次。工作量为*O*(log *n*)。使用`balance`的`insert`代码如下：

```
let insert x s =
  let rec ins = function
    Leaf -> Node (Red, x, Leaf, Leaf)
  | Node (color, y, a, b) as s ->
      if x < y then balance (color, y, ins a, b)
      else if x > y then balance (color, y, a, ins b)
      else s in
  match ins s with
    Node (_, y, a, b) ->
      Node (Black, y, a, b)
    | Leaf -> (* guaranteed to be nonempty *)
        failwith "RBT insert failed with ins returning leaf"

```

## 删除元素

从红黑树中移除一个元素的操作类似于二叉搜索树的元素移除。我们首先执行二叉搜索树的元素移除操作，然后再进行重新平衡。当删除一个内部（非叶子）节点时，如果它有少于两个非叶子子节点，我们就简单地将其拼接出来；如果它有两个非叶子子节点，我们就在树中找到下一个值，这个值必须在它的右子节点中找到。

在从红黑树中删除元素时平衡树需要考虑更多情况。从树中删除一个黑色元素会导致树中某些路径上的黑色节点过少，从而破坏黑高不变性 2。解决方法是将该路径视为包含一个“双黑”节点。然后，一系列树旋转可以通过将“黑色”传播上去直到一个红色节点可以转换为黑色节点，或者直到达到根节点并且可以将其从双黑变为黑色而不破坏不变性。
