# 讲座 21：谓词逻辑

## 语法

在命题逻辑中，我们要证明的陈述是完全抽象的。要能够证明程序的正确性，我们需要一种能够讨论程序计算的内容的逻辑：整数、字符串、元组、数据类型构造函数和函数。我们将用能够讨论这些内容的方式丰富命题逻辑，从而得到一个版本的**谓词逻辑**。

语法使用了一些新表达式扩展了命题逻辑，如下所示：

```
Formulas f,g ::=
          ⊤             (* true *)
        | ⊥             (* false *)
        | ¬f            (* negation; syntactic sugar for f ⇒ ⊥ *)
        | f ∧ f         (* conjunction (and) *)
        | f ∨ f         (* disjunction (or) *)
        | f ⇒ f         (* implication (if-then) *) 
        | ∀x.f          (* f is true for all x. f can mention x*)
        | ∃x.f          (* There exists some x such that f is true *)
        | t1 = t2       (* t1 is equal to t2 *)
        | P(t1,...,tn)  (* n-ary predicate (aka relation) P is true 
                                                 for t1,...,tn *)

Terms t ::=     
          c             (* constants (integers, tuples, other values) *)
        | x             (* variables *)
        | fn(t1,...,tn)  (* result of applying n-ary function fn 
                                                  to t1,...,tn *)

```

项 t 代表我们正在推理的一些对象域中的个别元素，例如自然数。

公式 ∀x.f 表示对于任意选择的 x，公式 f 都成立。这被称为**全称量化**，∀ 是**全称量词**。公式 ∃x.f 表示**存在量化**。它意味着存在某个选择的 x 使得公式 f 成立，尽管可能存在多个这样的 x。

可以将量词的范围限制为量化到可能值域的某个子集。对于全称量词，我们使用蕴含符号 ⇒，而对于存在量词，我们使用合取符号 ∧。例如，如果我们想要说所有*正*数 x 都满足某个性质 Q(x)，我们可以写成 ∀x.x > 0 ⇒ Q(x)。这有效是因为对于不大于 0 的数来说，量化的公式是空真的。要说存在一个满足 Q 的正数，我们可以写成 ∃x.x > 0 ∧ Q(x)。

使用量词，我们可以表达一些有趣的陈述。例如，我们可以用各种逻辑等价的方式表达一个数 n 是质数的想法：

| Prime(n) | ⇔ | ∀m. 1 < m ∧ m < n ⇒ ¬∃k. k*m = n |
| --- | --- | --- |
|   | ⇔ | ¬∃m. 1 < m ∧ m < n ∧ ∃k. k*m = n |
|  | ⇔ | ¬∃m. ∃k. 1 < m ∧ m < n ∧ k*m = n |

## 量词规则

对于全称量词和存在量词，可以定义引入和消除规则。在以下规则中，f(t) 指的是将变量 x 的所有自由出现替换为项 t 后的 f(x)。

| rule name | rule | intuition |
| --- | --- | --- |
| ∀ | intro |  | (*) 只有当 x 不在 Γ 中自由出现时才能应用此规则。如果我们选择一个**任意的** x 并证明 f(x)，我们就可以得出 f 对所有 x 都成立的结论。 |
| elim |  | 如果我们已经证明了对所有 x 成立的 f，那么我们可以得出对于任意给定的 t，f 也成立。 |
| ∃ | intro |  | 我们可以通过简单地产生一个具有性质 f 的 t 来证明存在某个 x 拥有性质 f。 |
| elim |  | (*) 只有当 a 不在 Γ 或 g 中自由出现时才能应用此规则。这类似于 ∨ 消除 —— 我们只有在结论 g 不依赖于满足 f 的 x 是哪个时才能从存在一个 x 推断出一些东西。 |

规则 (∀-elim) 将公式 f(x) 特化为 x 的特定值 t。（我们隐含要求 t 是适合替代 x 的正确类型。）由于 f 对所有 x 都成立，它应该对任意选择的 x 都成立，包括 t。 (∀-intro) 规则正式化了一种类型的论证，即以“假设 a 是一个任意元素...”开头。如果可以证明对于任意选择的 a 都成立一个事实 f(a)，那么 f(x) 对所有 x 都成立。

规则 (∃-intro) 推导出 ∃x.f(x)，因为存在量化的证据 t 已经被产生。直观地说，如果对某个 t 成立 f(t)，那么肯定存在一个 x 使得 P(x) 成立。 规则 (∃-elim) 的背后思想是，如果能够证明 g 而不使用有关证据 x 的任何信息，除了 f(x)，那么仅仅存在一个满足 f 的元素就足以暗示 g。

(∀-intro) 和 (∃-elim) 规则中的附注 (*) 是对规则使用的限制。这种限制防止我们进行不合理的推理，如下所示：

这个证明表明如果一个特定的 x 大于 10，那么每个 x 都大于 10，这显然是错误的！问题在于使用了 ∀-intro：我们能够证明 x > 10，但不是对于任意的 x，而是对于我们已经做出假设的特定的 x。

但是，在应用 (∀-intro) 的地方之后，变量 a 出现在假设中是可以的。例如，

```
write(
  infer('⊢ ∀x.(x>10 ∧ x<20) ⇒ x > 10','(∀ intro)',[
    infer('⊢ x>10 ∧ x<20 ⇒ x>10','(⇒ intro)',[
      infer('x>10∧x<20⊢ x>10', '(∧ elim)',[
        infer('x>10∧x<20 ⊢ x>10∧x<20', '(assum)', [])
      ])
    ])
  ])
);

```

在允许用户通过子目标开发自然演绎证明的自动证明助手中，证明是从底部生成的。在这样的系统中，(*) 可以通过在应用 (∀-intro) 或 (∃-elim) 时生成一个新的变量 a 来强制执行。

## 使用等号推理

谓词逻辑允许使用任意谓词 P。等号 (=) 就是这样的谓词。它适用于两个参数；我们可以将 t[1]=t[2] 视为谓词 =(t[1],t[2])。但是，除了上述任意谓词的规则之外，相等性还具有一些特殊性质。以下三条规则体现了相等性是一个等价关系的性质：它是自反的、对称的和传递的。

|

&#124;   &#124;

&#124; t = t &#124;

| (reflexivity) |
| --- |

&#124; t[1] = t[2] &#124;

&#124; t[2] = t[1] &#124;

| (symmetry) |
| --- |

&#124; t[1] = t[2] &#124; t[2] = t[3] &#124;

&#124; t[1] = t[3] &#124;

| (transitivity) |
| --- |

除了是等价关系外，相等性在替换下保持意义。如果两个事物相等，则在相等的术语中替换一个事物为另一个事物会得到相等的术语。这就是莱布尼茨法则（等同物的替换）的含义：

|

&#124; t[1] = t[2] &#124;

&#124; t{t[1]/x} = t{t[2]/x} &#124;

|

莱布尼茨法则也可用于展示命题在逻辑上等价：

|

&#124; t = t' &#124;

&#124; P{t/x} ⇔ P{t'/x} &#124;

|

例如，假设我们知道 y = x+1 和 x(x+1)+(x+1) = (x+1)²。然后我们可以使用该规则证明 xy+(x+1) = y²，通过使用 t = x+1，t' = y，以及 P = (xz+(x+1) = z²) 应用该规则。

相同的思想也可以完全应用在命题层面上。如果我们可以证明两个公式是等价的，那么它们可以在任何其他公式中相互替换。

|

&#124; Q ⇔ R &#124;

&#124; P{Q/A} ⇔ P{R/A} &#124;

|

这个可接受的规则在编写证明时非常方便，尽管我们可以用基本规则证明任何内容。当有大量逻辑等价关系库可供利用时，它可能非常方便，因为它允许重新编写深度嵌套的子公式。

## 对整数和其他集合的推理

对于特定类型的值进行推理，我们需要描述这些值行为的公理。例如，以下公理部分描述了整数，并且可以用来证明关于整数的许多事实。事实上，它们定义了一个更一般的结构，即**交换环**，因此使用它们证明的任何内容都适用于任何交换环。这些公理都被认为是隐含的普遍量化。

| (x+y)+z = x+(y+z) | （+的结合性） |
| --- | --- |
| x+y = y+x | （+的交换性） |
| (x*y)*z = x*(y*z) | （*的结合性） |
| x*y = y*x | （*的交换性） |
| x*(y+z) = x*y+x*z | （*对+的分配性） |
| x + 0 = x | （加法单位元） |
| x + (-x) = 0 | （加法逆元） |
| x*1 = x | （乘法单位元） |
| x*0 = 0 | （湮灭） |

这些规则使用了许多函数：+，*，-，0 和 1（我们可以将 0 和 1 视为不带参数的函数）。这些符号在前面的语法中由元变量 f 表示。

证明关于算术的事实可能会很繁琐。对于我们的目的，我们将进行合理的代数操作，将证明作为一个单一步骤，例如：

|

&#124; (x+2)² = 2*x &#124;

&#124; x² = −2*x−4 &#124;

| （代数） |
| --- |

这个证明步骤可以通过上述规则和公理来明确完成，但需要多个步骤。
