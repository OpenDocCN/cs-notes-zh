# 第四讲：作用域、柯里化和列表

+   作用域和绑定

+   柯里化函数

+   OCaml 列表

## 作用域

OCaml 中的变量声明**绑定**变量到**作用域**，程序的一部分，变量在其中代表绑定到的值。例如，当我们写`let` *x* = *e*[1] `in` *e*[2]时，标识符 *x* 的作用域是表达式 *e*[2]。在该作用域内，标识符 *x* 代表表达式 *e*[1] 计算得到的任何值 *v*。由于 *x* = *v*，OCaml 通过将 *x* 的出现替换为值 *v* 重写`let`表达式来评估它。例如，表达式`let x = 2 in x + 3`被评估为`2 + 3`，然后使用算术运算得到结果值`5`。

函数也绑定变量。当我们在 OCaml 中编写函数定义时，我们为函数名和函数参数引入新变量。例如，在此表达式中，绑定了两个变量：

```
let f x = e1 in e2

```

形式参数`x`的作用域正好是表达式`e[1]`。变量`f`（它绑定到函数值）的作用域是`let`的主体，即`e[2]`。

`let`表达式可以一次引入多个变量，如下例所示：

```
let x = 2
and y = 3
in x + y

```

这里`x`和`y`都将`let`的主体作为它们的作用域。即使`y`在`x`之后声明，`y`的定义也不能引用变量`x`——它不在作用域内。

要声明递归函数，函数必须在其自身的主体中处于作用域内。在 OCaml 中，这需要使用`let rec`而不是`let`。使用`let rec`，它声明的每个变量都在其自身的定义以及所有其他变量的定义中都是在作用域内的。为使其正常工作，使用这些变量的所有定义都必须是函数。例如，下面是如何定义**相互**递归函数`even`和`odd`的方法：

```
let rec even x = x = 0 || odd (x-1)
    and odd x = not (x = 0 || not (even (x-1)))
in
  odd 3110

```

此示例中有两个名为`x`的变量，它们仅在绑定它们的各自函数内部作用域中。但是，变量`even`和`odd`在彼此的定义以及`let`的主体内都是在作用域内的。

### 限定符标识符

可以使用`open`表达式命名模块中定义的事物，而不使用限定符标识符：

```
# String.length "hi";;
*- : int = 2*
# open String;;
# length "bye";;
*- : int = 3*

```

OCaml 提供了许多预定义的库模块，非常有用。例如，`String`模块提供了许多有用的字符串操作，而`List`模块提供了列表操作。许多有用的操作位于`Pervasives`模块中，默认情况下已经打开。要了解有关 OCaml 库及其提供的操作的更多信息，请参阅[Objective Caml 参考手册，第 IV 部分](http://caml.inria.fr/pub/docs/manual-ocaml/)。

例如，有一个用于计算整数绝对值的内置操作称为`Pervasives.abs`，可以简单地称为`abs`。

花些时间浏览库，并找出它们提供了什么。你不应该重新编写库中已有的东西（除非我们明确要求你这样做）。

## 柯里化函数

我们看到，具有多个参数的函数实际上只是传递元组作为参数的函数的语法糖。例如，

```
let plus (x, y) = x + y

```

是糖语法，表示

```
let plus (z : int * int) = match z with (x, y) -> x + y

```

这反过来又是糖语法表示

```
let plus = fun (z : int * int) -> match z with (x, y) -> x + y

```

当我们应用此函数时，比如对元组 `(2, 3)`，评估过程如下：

```
plus (2, 3)
= (fun (z : int * int) -> match z with (x, y) -> x + y) (2, 3)
= match (2, 3) with (x, y) -> x + y 
= 2 + 3
= 5

```

原来，OCaml 还有另一种声明具有多个形式参数的函数的方式，事实上，这是通常的方式。上述声明可以以**柯里化**形式给出如下：

```
let plus x y = x + y

```

或者将所有类型明确写出：

```
let plus (x : int) (y : int) : int = x + y

```

注意参数之间没有逗号。同样，当应用柯里化函数时，我们不写逗号：

```
plus 2 3 = 2 + 3 = 5

```

这里发生的事情比看起来的要复杂。回想一下我们说过函数实际上只有一个参数。当我们写 `plus 2 3` 时，函数 `plus` 只被传递了一个参数，即数字 2。我们可以将该术语括起来，如 `(plus 2) (3)`，因为应用是左结合的。换句话说，`plus 2` 必须返回一个函数，该函数可以应用于 3 以获得结果 5。实际上，`plus 2` 返回一个将 2 添加到其参数的函数。

这是如何工作的？上述柯里化声明是为了创建一个**高阶函数**的语法糖。它代表着：

```
let plus = function (x : int) -> function (y : int) -> x + y

```

对 `plus 2 3` 的评估过程如下：

```
plus 2 3
= ((function (x : int) -> function (y : int) -> x + y) 2) 3
= (function (y : int) -> 2 + y) 3
= 2 + 3
= 5

```

因此，`plus` 实际上是一个以 `int` 作为参数的函数，并返回一个类型为 `int -> int` 的新函数。因此，`plus` 的类型是 `int -> (int -> int)`。我们可以简单地写为 `int -> int -> int`，因为类型运算符 `->` 是右结合的。

原来，我们可以将诸如 `+` 这样的二元运算符视为函数，并且它们像 `plus` 一样进行柯里化：

```
# (+);;
- : int -> int -> int = <fun>
# (+) 2 3;;
- : int = 5
# let next = (+) 1;;
val next : int -> int = <fun>
# next 7;;
- : int = 8;

```

## 列表

到目前为止，我们唯一能构建的真正数据结构是由元组构成的。但元组不允许我们构建在编译时大小未知的数据结构。为此，我们需要一种新的语言特性。

我们熟悉的一个简单数据结构是单链表。原来 OCaml 中已经内置了列表。例如，在 OCaml 中，表达式 `[]` 是一个空列表。表达式 `[1;2;3]` 是一个包含三个整数的列表。

在 OCaml 中，列表的所有元素都必须具有相同的类型。例如，整数列表的类型为 `int list`。类似地，列表 `["hi"; "there"; "3110"]` 的类型将为 `string list`。但 `[1; "hi"]` 不是合法列表。在 OCaml 中，列表是**同质列表**，而不是**异质列表**，其中每个元素可以具有不同的类型。

列表是**不可变**的：你不能改变列表的元素，不像 Java 中的数组。一旦列表被构造，它就不会改变。

### 构造列表

我们经常想要用较小的列表构造一个列表。我们可以使用 `@` 运算符连接两个列表。例如，`[1;2;3] @ [4;5]` = `[1;2;3;4;5]`。然而，这个运算符并不是很快，因为它需要构建整个第一个列表的副本。（它不会复制第二个列表，因为第二个列表的存储与连接列表的存储是共享的。）

在构建列表时，我们更经常使用 `::` 运算符，它将一个元素添加到现有列表的前面（“前置”意味着“添加到前面”）。表达式 `1::[2;3]` 是 `1` 添加到列表 `[2;3]` 的前面。这就是列表 `[1;2;3]`。如果我们对空列表使用 `::`，它会生成一个单元素列表：`1::[]` = `[1]`。

出于历史原因，回到 Lisp 语言，我们通常将 `::` 运算符称为“cons”。

列表是不可变的事实符合 OCaml 是函数式语言的特性。这实际上也有助于提高 OCaml 的效率，因为这意味着不同的列表数据结构可以在计算机内存中共享部分表示。例如，评估 `h::t` 只需要在计算机内存中为一个额外的列表节点分配空间。它与现有列表 `t` 共享其余部分。

### 列表的模式匹配

从列表中提取元素的最佳方法是使用模式匹配。运算符 `::` 和括号构造函数可以在 `match` 表达式中用作模式。例如，如果我们有一个列表 `lst`，并且希望在 `lst` 为空时得到值 0，在 `lst` 有一个元素时得到值 1，在 `lst` 有 2 个或更多元素时得到值 2，我们可以编写：

```
match lst with
    [] -> 0
  | [x] -> 1
  | _ -> 2

```

在这里，如果评估第二个匹配分支，则 `x` 将绑定到列表的单个元素。

经常，操作列表的函数是递归的，因为它们需要对每个元素执行一些操作。例如，假设我们想要计算字符串列表的长度。我们可以编写一个递归函数来实现这个目标（实际上，库函数 `List.length` 就是这样做的）：

```
(* Returns the length of lst *)
let rec length (lst : string list) : int =
  match lst with
    [] -> 0
  | h :: t -> 1 + length t

```

这里的逻辑是，如果列表为空（`[]`），它的长度显然是零。否则，如果它是将元素 h 添加到另一个列表 t 中，其长度必须比 t 的长度大一。

可以使用括号语法编写模式。这与使用 `::` 运算符编写类似模式完全相同。例如，以下模式都是等价的：`[x;2]`、`x::2::[]`、`x::[2]`。当用作项时，这些表达式也都是等价的。

### 库函数

OCaml 结构体[`List`](http://www.standardml.org/Basis/list.html) 包含许多用于操作列表的实用函数。在使用列表之前，值得一看。我们稍后会更详细地讨论其中一些。两个应该谨慎使用的函数是 `hd` 和 `tl`。这些函数分别获取列表的头部和尾部。然而，如果应用于空列表，则会引发异常。它们很容易让人忘记列表可能为空的可能性，从而创建出现预期异常的情况，导致程序崩溃。因此，通常最好避免使用它们。

### 列表示例

我们可以使用模式匹配来实现列表上的其他有用函数。假设我们想要一个函数，该函数通过列表中的索引提取列表元素，其中第一个元素的索引为零。我们可以通过同时对列表和整数 n 进行模式匹配来整洁地实现这一点：

```
(* nth lst n returns the nth element of lst. *)
let rec nth (lst : string list) (n : int) : string =
  match lst with
    h :: t -> if n = 0 then h else nth t (n - 1)
  | [] -> raise Not_found

```

如果 `n` 小于 0 或大于或等于 `lst` 的长度，则会引发 `Not_found` 异常。
