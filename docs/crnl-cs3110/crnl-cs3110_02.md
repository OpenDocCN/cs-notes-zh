# 第二讲：OCaml 程序的语法和评估

主题摘要：

+   OCaml 语法

+   表达式、项、类型和值

+   错误

+   评估和重写规则

+   命名空间和作用域

+   限定标识符和库

## OCaml 语法

在上一次讲座中，您应该已经看到了 OCaml 的一些简单表达式和声明形式。这个语言片段的语法可以总结如下：

| 语法类 | 语法变量和语法规则 | 示例 |
| --- | --- | --- |
| **标识符** | *x, f* | `a`, `x`, `y`, `x_y`, `foo1000`, ... |

| **常量** | *c* | ...`-2`, `-1`, `0`, `1`, `2`（整数）`1.0`, `-0.001`, `3.141`（浮点数）

`true`, `false`（布尔值）

`"hello"`, `""`, `"!"`（字符串）

`'A'`, `' '`, `'\n'`（字符） |

| **一元运算符** | *u* | `-`, `not` |
| --- | --- | --- |
| **二元运算符** | *b* | `+`, `*`, `-`, `>`, `<`, `>=`, `<=`, `^`, `!=`, ... |
| **项** | *e* ::= *x*  &#124;  *c * &#124;  *u e  &#124;  e*[1]* b e*[2] *&#124;*`if`* e *`then`* e* `else`* e  &#124;  *`let` *d*[1] `and`...`and` *d[n]*`in`*e*  &#124;  *e* `(`*e*[1]`,` ...`,` *e**[n]*`)` | `foo`, `-0.001`, `not` `b`, `2+2` |
| **声明** | *d* ::= *x = e  &#124;  * * f *`(` *x*[1], ...,  *x[n]*`):` *t* =  *e* | `one = 1 square(x:int):int = x*x` |
| **类型** | *t* ::= `int`  &#124;  `float`  &#124;  `bool`  &#124;  `string`  &#124;  `char`  &#124;  *t*[1]`*`...`*`*t[n]*`->`*t* | `int`, `string`, `int->int`, `bool*int->bool` |

一个 OCaml 程序，像任何其他语言一样，由各种 **表达式** 组成。上表描述了如何构造其中一些表达式。也就是说，它指定了 OCaml 的一些语法。其中一些表达式，比如标识符、常量和运算符，我们仅通过示例来描述。这些表达式都是单个 **标记**。其他表达式，比如项、声明和类型，由 **语法规则** 描述。这些规则以称为 BNF（巴科斯-瑙尔形式）的形式编写。每个规则描述了构建特定类型的表达式的各种方法，用竖线分隔。例如，一个项可以是一个标识符、一个常量、任何一元运算符 *u* 后跟任何表达式 *e*（*u e*）、任何两个项 *e*[1] 和 *e*[2] 之间用任何二元运算符 *b* 分隔，等等。注意，我们使用字母 *u* 表示任何一元运算符，字母 *e* 表示任何项。这些都是 **语法变量** 或 **元变量** 的示例。语法变量不是 OCaml 程序变量；它只是某种语法结构的通用名称。例如，*x* 可以是任何标识符，*e* 可以是任何表达式。我们有时在语法变量上加上下标以帮助我们将它们区分开（如上所示），但这并非必需。

OCaml 解释器允许在提示符处输入项或声明。我们可以将程序看作仅仅是一个 OCaml 表达式，尽管后面我们会发现它更复杂。

### 程序错误

仅仅因为一个表达式具有合法的语法并不意味着它是合法的；这个表达式还必须是类型正确的。也就是说，它必须仅使用与其类型相符的表达式。我们稍后会更详细地看一下表达式是什么意思。通常，把类型想象成一组可能的值（通常是无限集）是很有用的。我们将看到 OCaml 有一个功能强大、富有表现力的类型系统。

更一般地说，OCaml 中的表达式可以出错的方式有很多，就像在英语中一样：

+   *语法错误*：`let 0 x =`；“斯波特跑看见”

+   *类型错误*：`"x" + 3`；“看到斯波特跑了”

+   *语义错误*：1/0；“无色绿色的想法狂暴地睡觉”（良好的语法，不连贯的语义）

+   *更一般的错误*：正确计算错误答案的 OCaml 程序，“警官，您不敢给我开罚单！”

现在，我们如何编写表达式和声明呢？这里是一个简单函数的声明，它计算给定整数的绝对值：

```
let abs (x : int) : int =
  if x < 0 then -x else x

```

或者，也可以这样写

```
let abs : int -> int =
  function x -> if x < 0 then -x else x

```

或者更简洁地说，

```
let abs = fun x -> if x < 0 then -x else x

```

每个表达式和声明都有一个*类型*和一个*值*。当你在 OCaml 顶级环境中键入一个表达式或声明时，它会报告表达式的类型和值。如果我们在 OCaml 提示符下键入`abs`的定义，然后跟着`;;`，告诉 OCaml 解释器现在应该评估这个表达式，它会回应

```
*val abs : int -> int = <fun>*

```

这意味着我们刚刚将名字`abs`绑定到一个类型为`int -> int`的函数上。

### 示例

这是一个确定其参数是否为素数的函数。这个函数的类型是`int -> bool`。

```
Turn on Javascript to see the program.

```

关于这个程序有几点需要注意。首先，注意到递归辅助函数`noDivisors`的使用，它被声明在函数`isPrime`内部。这个函数使用`let rec`来定义，因为它是递归的。在命令式语言中，这个函数会使用循环来写，但是使用一个恰当命名的辅助函数比通用的循环更易读。声明的作用域是声明本身的主体和跟在`in`后面的表达式；它在其他地方是不可用的。

这是一个找到给定浮点数的平方根近似值的函数。它基于这样一个事实：对于任何正数*x*和*g*，数字*g*和*x*/*g*位于 sqrt(*x*)的两侧。这是因为它们的乘积是*x*。

```
Turn on Javascript to see the program.

```

这个示例展示了很多东西。首先，你可以声明局部变量，比如`delta`和局部函数，比如`goodEnough`、`improve`和`tryGuess`。注意，“内部”函数（比如`improve`）可以引用“外部”变量（比如`x`）。还要注意，后面的声明可以引用前面的声明。例如，`tryGuess`同时引用了`goodEnough`和`improve`。实际上，后面的声明都在前面的`in`表达式内部。

如果您将上面的`squareRoot`声明键入 OCaml 顶级，它会响应：

```
*val squareRoot : float -> float* = <fun>

```

表示您声明了一个变量（`squareRoot`），其值是一个函数（`<fun>`），其类型是从浮点到浮点的函数。所有函数定义的内部结构都是隐藏的；从外部来看，我们只知道它的值是一个简单的函数`float -> float`。特别地，函数`tryGuess`在`squareRoot`之外没有定义：

```
# tryGuess;;
*Characters 0-8: tryGuess;; ^^^^^^^^ Error: Unbound value tryGuess*

```

在键入函数后，您可能会尝试在浮点数（如 9.0）上使用它：

```
# squareRoot 9.0;;
*- : float = 3.0000000013969839*

```

OCaml 已经评估了表达式`squareRoot 9.0`并打印了其值（`3.0000000013969839`）和其类型（`float`）。

目前，我们对将此表达式键入 OCaml 时确切发生了什么有一个不精确的概念。我们很快将有更精确的理解。

如果您尝试将`squareRoot`应用于没有浮点类型的表达式（例如整数或布尔值），那么您将收到一个类型错误：

```
# squareRoot 9;;
*Characters 11-12: squareRoot 9;; ^ Error: This expression has type int but is here used with type float*

```

在表达式中使用插入符号（`^^^`）来指示错误表达式。

### 限定标识符和库

限定标识符的形式为*x.y*，其中*x*是一个**模块**标识符。示例包括`String.length`、`List.map`和`String.sub`。与 Java 中的包和类一样，在 OCaml 中，限定标识符允许一组名称被分组在一个单独的代码模块中。

## 评估

OCaml 提示符允许您键入一个术语或将变量绑定到一个术语的声明。它**评估**术语以产生一个**值**：一个不需要进一步评估的术语。我们也可以将值*v*定义为一个语法类。目前，我们可以认为值与常数相同，尽管我们将看到它们有更多的内容。

运行 OCaml 程序只是评估一个术语。当我们评估一个术语时会发生什么？在一种命令式（非函数式）语言中，比如 Java，有时我们会想象有一个正在执行的“当前语句”的概念。这对于 OCaml 来说不是一个很好的模型；最好将 OCaml 程序视为以与评估数学表达式相同的方式进行评估。例如，如果你看到一个表达式像(1+2)*3，你知道你首先评估子表达式 1+2，得到一个新的表达式 3*3。然后你评估 3*3。OCaml 评估的方式与此相同。在每个时刻，OCaml 评估器获取最左边的不是值的表达式，并将其**重写**（或**简化**）为一些更简单的表达式。最终整个表达式都是一个值，然后评估停止：程序完成。或者可能表达式永远不会简化为一个值，在这种情况下，您会得到一个无限循环。

OCaml 内置了许多重写规则，远远超出了简单的算术。考虑 if 表达式。它有两个重要的重写规则：

```
if true then *e*1 else *e*2   -->  *e*1
if false then *e*1 else *e*2  -->  *e*2
```

如果评估器遇到一个 if 表达式，它首先尝试将条件表达式简化为 true 或 false。然后它可以应用这里的两条规则中的一条。

### 替换

使用重写规则也会对`let`表达式进行评估。它的工作原理是首先评估所有的绑定。然后，这些绑定被替换到`let`表达式的**主体**（`in`之后的表达式）中。例如，下面是使用`let`的一系列评估步骤：

```
let x = 1+4 in x*3
   --> let x = 5 in x*3
   --> 5*3
   --> 15

```

函数调用是最有趣的情况。当调用函数时，OCaml 会进行类似的替换：它将传递的参数值替换到函数的主体中。考虑评估`abs(2+1)`：

```
abs (2+1)
   --> abs 3
   --> if 3 < 0 then -3 else 3
   --> if false then -3 else 3
   --> 3

```

这是一个简单的开始，介绍了如何思考评估问题；我们将在接下来的几堂课上进一步讨论评估问题。
