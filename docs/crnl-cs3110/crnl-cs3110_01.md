# 第 1 次课：OCaml 语法介绍

本学期我们将使用 Objective Caml（OCaml）编程语言。OCaml 是一种函数式语言，而不是命令式语言；这两类语言之间的关键区别在于*执行模型*---程序执行的方式。*命令式*（或*过程式*）语言，如 C 和 Java，基于改变执行机器状态的命令。例如，赋值语句（在 C 和 Java 中）明确地改变了某个内存位置存储的值。相比之下，*函数式*语言基于评估表达式以产生值。OCaml 提供了构建正确、可理解和大型表达式的良好方法。本讲座的重点是理解表达式。

对于实际应用，使用表达式进行编程可能看起来有些牵强。毕竟，应用通常不会“计算”任何东西；相反，它们让你可以“做”某事。在课程的后期，我们将介绍*副作用*的概念：在评估**这个**时，同时做**那个**—例如，评估一个表达式，并（作为副作用）在屏幕上显示一个窗口。但目前，我们将生活在一个*纯净*的世界中，一个没有副作用的世界。

要开始学习 OCaml，您应该通过编写玩具表达式来开始使用 OCaml 语言。与大多数编程语言一样，Ocaml 有一个编译器，可以在源文件上运行以生成目标文件。但要真正理解表达式，有一种更好的与 OCaml 编译器交互的方法，称为*OCaml* *顶层系统*。这个系统有点像一个非常复杂的计算器---您通过键入表达式与它交互，它通过评估该表达式并告诉您结果值来回应。

* * *

**重要提示**：在以前的学期中，这门课程是用 SML 教授的，这是一种与 OCaml 非常相似的语言。它们有共同的起源和几乎所有的语法。为了帮助理解以前年份的笔记，您可能希望查阅[SML vs. OCaml](http://www.mpi-sws.mpg.de/~rossberg/sml-vs-ocaml.html)页面，该页面提供了两者之间差异的详细列表。

如果您在笔记中注意到任何 SML/OCaml 的差异，请告诉我们。

* * *

**启动 OCaml 顶层系统。** 课程资源页面上有安装 OCaml 的说明。安装好 OCaml 后，您可以通过在终端（即 Unix shell 或 Windows 控制台）中键入`ocaml`来启动交互式会话。（3110 虚拟机上安装了名为`utop`的增强版本的`ocaml`。）您将获得一个*顶层提示符*“#”，表示编译器已准备好接受表达式并评估它们。要退出顶层系统，请输入您平台的文件结束字符（Unix 上为 Ctrl-D，Windows 上为 Ctrl-Z + Return）。

**使用 OCaml 顶层系统。** 输入一个表达式（可能跨多行，之后第一行之后将有一个次级提示符“=”），然后键入 `;;` 并按 Enter 键。注意，`;;` 不是要评估的表达式的一部分。它只是向编译器指示你已经完成了输入表达式的工作，并且你已经准备好进行评估。在评估表达式之前，编译器将对其进行类型检查。

**提示**：顶层系统在读取输入时对某些事情非常挑剔，只有当它确切地位于顶层提示符处时才会接受退出请求——即，如果没有其他内容已经输入。当存在疑问时（特别是如果输入似乎表现得很奇怪），按下 Ctrl-C 以中断并将提示重置为正常状态可能是有用的。

**提示**：将表达式放入文件中可能会很有用，这样你就不必一遍又一遍地输入它们。只需使用编辑器编辑文件，然后你就可以使用操作 `#use "file";;` 将其加载到 OCaml 中，该操作的行为就好像这些表达式已经输入到了顶层提示符（别忘了分号！）。关键问题是文件应该存储在哪里。操作 `#use` 默认在当前工作目录中查找文件。要更改当前工作目录，请使用操作 `#cd "*path*";;` 其中 *path* 是你想要进入的路径。要将目录添加到 OCaml 查找文件的目录列表中，请使用操作 `#directory "*path*";;`。使用 Unix 约定（即使在 Windows 上）：路径分隔符是“/”。

**提示**：更多关于顶层系统的详细信息可以在[OCaml 手册页面](http://caml.inria.fr/pub/docs/manual-ocaml/toplevel.html)找到。

* * *

## 基本表达式和类型

表达式求值为 *值*。值可以根据其类型进行分类：

| 类型 | 示例值 |
| --- | --- |
| 整数 | `0`，`1`，`2`，`-1`，`-2` |
| 布尔 | `true`，`false` |
| 浮点数 | `3.141592, 1.618034` |
| 字符串 | `"Hello world!"，"xyzzy"` |
| 字符 | `'A','Z'` |

让我们开始看一下简单表达式，具体语法如下：

> *e* ::= *c*  |  *unop**e*  |  *e1**binop**e2*  |  if*e1*then*e2*else*e3*  |  (*e*)

其中 *c* 是常量（上述值描述的值），*unop* 是一元操作，*binop* 是二元操作。我们使用 *巴科斯-诺尔* 形式（BNF），一种计算机语言语法的常见符号，来表示这个语法。**注意给教师：**表达式的 BNF，以及后来的声明的 BNF，应该放在黑板的一侧，并且在本节进行时应该一直保留在那里，因为我们将随着本节的进行添加表达式类型和声明类型。

一元操作符包括：

| 操作符 | 含义 |
| --- | --- |
| `-` | 取一个 int（或一个 float）并返回其负值 |
| `not` | 取一个布尔值并返回其否定 |

二元操作符包括：

| 操作符 | 含义 |
| --- | --- |
| `+`,`-`,`*`, `/` | 取两个整数并返回它们的和、差、积或商 |
| `+.`,`-.`,`*.`, `/.` | 接受两个浮点数并返回它们的和、差、积或商 |
| `mod` | 接受两个整数并返回它们的整数余数 |
| `>`,`>=`,`<`,`<=` | 接受两个整数（或两个浮点数）并返回它们的比较结果 |
| `=` | 接受两个值并返回它们是否相等 |
| `^` | 接受两个字符串并返回它们的连接成一个新字符串 |

表达式通过*求值规则*转换为值。简单表达式的求值规则为：

+   常量已经是值了。

+   一元和二元运算符首先将它们的参数求值为值，然后执行操作。

+   条件语句 if *e1* then *e2* else *e3* 将 *e1* 评估为一个值（类型为 bool）：如果它是 `true`，则评估 *e2*，如果它是 `false`，则评估 *e3*。

只有当操作数的类型一致时，操作符的求值才有意义。例如，`+` 操作符在两个操作数都是整数时被定义，但是将整数加到布尔值上是没有意义的。因此，进行类型检查以确保表达式有意义，这需要给每个表达式指定一个类型。OCaml 如何确定表达式的类型？

每个常量都有一个类型（`42` 的类型为 `int`，`true` 的类型为 `bool`，等等）。运算符也有类型（我们以上给出的是非正式的）；在 OCaml 语法中，这些类型如下：

> ```
>  -     :  int -> int (* or *) float -> float                  
>  not   :  bool -> bool
>  +     :  int -> int -> int
>  +.    :  float -> float -> float
>  >     :  int -> int -> bool (* or *) float -> float -> bool
>  ^     :  string -> string -> string
> ```

每个操作符都指定它接受的值的类型以及它返回的值的类型。加法操作符 `+` 接受一个 `int`，另一个 `int`，然后返回一个 `int`。

现在我们可以给出确定表达式类型的规则。这些规则体现的原则是：

> **表达式的类型总是其结果的类型。**

+   对于表达式 *unop* *e*，如果 *e* 的类型为 *t1*，并且 *unop* 的类型为 *t1* `->` *t2*，那么 *unop* *e* 的类型为 *t2*。

+   对于表达式 *e1* *binop* *e2*，如果 *e1* 的类型为 *t1*，并且 *e2* 的类型为 *t2*，并且 *binop* 的类型为 *t1* `->` *t2* `->` *t3*，那么 *e1* *binop* *e2* 的类型为 *t3*。

+   对于条件语句 if *e1* then *e2* else *e3*，如果 *e1* 的类型为 `bool`，并且 *e2* 和 *e3* 都具有相同的类型 *t*，那么条件语句本身的类型为 *t*。

    +   为什么 *e2* 和 *e3* 必须具有相同的类型？从编译器的角度来看，任一分支都可能被执行。如果执行 then 分支，则结果值的类型将与 *e2* 的类型相同。同样，else 分支产生的值与 *e3* 的类型相同。因此，条件语句的类型必须以某种方式概括 *e2* 和 *e3* 的类型。确保这种可能性的一种安全方式是要求两个分支返回相同的类型。

如果表达式不满足这些规则中的条件，则无法为该表达式指定类型。它不会通过类型检查，编译器会将其拒绝作为程序。这可以防止对无意义表达式的求值。这样做很重要，因为这种编程错误可能会导致运行时错误。

## 声明

值可以被命名。这不是一种表达形式，而是向编译器指示您正在*声明*一个新名称。

> *d* ::= let*id* = *e*

例如，让`pi = 3.141592`是一个声明。声明告诉编译器评估表达式*e*，生成一个值，并将该值*绑定*到名称*id*。在后续表达式中，*id*可以用来引用该值。因此，我们扩展了表达式的语法：

> *e* ::= ...  |  *id*

评估*id*意味着查找它绑定的值是什么。*id*的类型是它绑定的值的类型。

声明持续到遇到同名的另一个声明（*遮蔽*—即替换—先前的声明）。我们还可以引入仅在表达式评估期间持续的局部声明。

> *e* ::= ...  |  let *d*in*e*

要评估 let 表达式，首先评估声明*d*，然后评估*e*，考虑声明中的绑定。

> **问题**：let*d*in*e*的类型是什么？答案：*e*的类型，因为表达式的类型是结果的类型。

在这一点上，我们可以编写大型表达式，但不能轻松地重用表达式。因此，我们引入函数。函数声明是一种新的声明形式：

> *d* ::= ...  | let *id* ((*x1*:*t1*), ..., (*xn*:*tn*)):*t* = *e*

在这种新形式的声明中，*e*被称为函数*id*的*主体*。例如，`let square (x:int) : int = x * x`是一个函数定义，其主体是`x * x`。函数的类型类似于运算符的类型。例如，`square`的类型是`int -> int`。

这里有一个带有两个参数的函数示例：

> ```
> let max2 ((a:int),(b:int)):int = 
>   if a>b then a else b
> ```

其类型是`(int * int) -> int`。参数类型由`*`分隔。请注意，在此语法中，`*`不表示整数乘法。

**提示**：不一定需要为函数注释类型。大多数情况下，OCaml 可以从函数的定义中推断出函数的类型。例如，我们可以将`max2`重写如下：

> ```
> let max2 (a,b) = 
>   if a>b then a else b
> ```

请注意，我们不必在参数周围写内部括号，因为我们省略了它们的类型注释。OCaml 为`max2`推断的类型现在变得相当神秘：`'a * 'a -> 'a`。暂时将`'a`视为表示“任何类型”。由于`int`是任何类型的一个示例，我们仍然可以在`int`上使用`max2`。

**陷阱**：正如您很快会注意到的，调试一个无法通过类型检查的程序可能非常困难。很难弄清楚为什么编译器为**那个**表达式推断出**这个**类型。解决方法：使用类型注释来捕捉类型错误！

**超级提示**：始终为函数注释类型是非常好的做法。我们通常要求您在编程作业中这样做。

我们甚至可以有一个带有三个参数的函数：

> ```
> let max3 ((a:int),(b:int),(c:int)):int = 
>   max2(max2(a,b),c)
> ```

其类型是`(int * int * int) -> int`。

你可能会想知道为什么接受两个参数的内置运算符的类型，比如`+`，看起来和`max2`的类型不太一样。我们稍后会讨论这个原因（大约两节课后）。

对于递归函数，需要使用`let rec`：

> *d* ::= ...  | `let rec *id* ((*x1*:*t1*), ..., (*xn*:*tn*)):*t* = *e*

这与普通函数声明相同，但在函数体内使用的任何 *id* 都将绑定到函数本身的值。

我们如何使用函数？我们引入一个新的表达式称为 *函数应用*：

> *e* ::= ...  |  *id* (*e1*,...,*em*)

我们如何对函数应用 *f* (*e1*,...,*em*) 进行类型检查？如下所示：

1.  如果 *f* 的类型是 (*t1* * ... * *tn*) `->` *t*，并且

1.  如果传递给函数的参数数量与函数期望的参数数量相同，即 *m* 等于 *n*，并且

1.  如果 *e1* 的类型是 *t1*，*e2* 的类型是 *t2*，依此类推，*en* 的类型是 *tn*，

1.  那么 *f* (*e1*,...,*em*) 的类型是 *t*。

因此 `square (10)` 类型检查通过，但 `square (true)` 不通过。

如何评估函数应用 *f* (*e1*,...,*em*)？评估 *e1*,...,*em* 到值 *v1*,...,*vm*，然后用 *x1* 绑定到 *v1*，...，*xm* 绑定到 *vm* 来评估 *f* 的主体。所以 `square (10+10) --> square (20) --> 20*20 --> 400`。一周后我们会看到更多关于评估的细节。现在，我们只想给你一个关于简单情况的直觉。

函数绑定可以在 let 表达式中使用，以获得一个局部函数（类似于 Pascal，不同于 C）。例如：

> ```
> let fourth (y:int) : int =
>   let
>     square (x:int):int = x * x
>   in
>     square (square (y))
> 
> ```
