# 第 24 讲：解决递归关系

在上一讲中，我们看到了如何解决递归关系的方法，以一个简单的乘法函数作为例子，该函数只使用加法，并在时间上运行为*O(log n)*。今天我们将通过证明归并排序的复杂性以及计算斐波那契数的函数的复杂性来看更多的例子。

## 归并排序

### 归并排序的实现

```
let rec split (l: 'a list) : 'a list * 'a list = 
   match l with
    [] -> [],[]
  | [x] -> [x],[]
  | x::y::t -> let l,r=split t in x::l,y::r

(* A simpler way to write split. Recall the definition of
   List.fold_right. What is the asymptotic performance of 
   List.fold_right f lst acc0 where f is an O(1) function
   and lst is an n-element list? O(n). *)
let split' (l: 'a list) : 'a list * 'a list = 
  List.fold_right (fun x (left,right) -> (x::right,left)) l ([],[])

let rec merge (left: 'a list) (right: 'a list): 'a list =
  match (left, right) with
    ([],_) -> right
  | (_,[]) -> left
  | (x::rest_left, y::rest_right) -> 
      if x > y then y::(merge left rest_right)
               else x::(merge rest_left right)

(* merge_sort l is a list containing the same elements as xs but in
 * ascending (nondescending) sorted order.  *)
let rec merge_sort (l: 'a list) : 'a list =
(* Implementation: lists of size 0 or 1 are already sorted. Otherwise,
 * split the list into two lists of equal size, recursively sort
 * them, and then merge the two lists back together. *)
  match l with
   ([]|[_]) -> l
  | _ -> let (left, right) = split l in 
           merge (merge_sort left) (merge_sort right)

```

### 归并排序渐近时间复杂度分析

现在让我们展示`merge_sort`不仅是一个*正确*的算法，而且是一个*高效*的排序数字列表的算法。我们首先观察到，没有证明的情况下，`split`函数的性能与输入列表的大小成线性关系。这可以通过与我们将对`merge`采取的相同方法来证明，因此我们只看`merge`。

`merge`函数的运行时间也是线性的—也就是*O*(*n*)—在两个输入列表的总长度上。我们首先找出执行时间的递归关系。假设输入列表的总长度为零或一。那么函数必须执行 case 表达式的两个*O*(1)分支之一。这些最多花费一些时间*c*[0]来执行。所以我们有

> *T*(0) = *c*[0]
> 
> *T*(1) = *c*[0]

现在，考虑总长度为*n*的列表。递归调用的列表总长度为*n*−1，因此我们有

> *T*(*n*) = *T*(*n*−1) + *c*[1]

这里，*c*[1]是对执行 if 语句和操作符`::`（对于列表的常规实现需要常数时间）所需时间的常数上界。这给了我们一个解决*T*的递归关系的递归关系。我们可以通过展开前几个步骤的递归关系不等式来应用迭代方法来解决递归关系。

> *T*(0) = *c*[0]
> 
> *T*(1) = *c*[0] *T*(2) = *T*(1) + *c*[1] = *c*[0] + *c*[1] *T*(3) = *T*(2) + *c*[1] = *c*[0] + 2*c*[1] *T*(4) = *T*(3) + *c*[1] = *c*[0] + 3*c*[1
> 
> ...] *T*(*n*) = *T*(*n*−1) + *c*[1] = *c*[0] + (*n*−1)*c*[1] = (*c*[0] - c[1])+ *c*[1]*n*

我们注意到最后一行捕捉到的模式。这种模式可以通过归纳更严谨地证明：让我们归纳地证明，对于*n >=0*，*T*(*n*)=(*c*[0] - c[1])+ *c*[1]*n*。对于*n=0*，结果是正确的（以上已证明），如果对于*n-1*成立，则使用上面的最后一行，对于 n 也是成立的。

回想一下，如果对于所有大于某个*n*[0]的*n*，我们可以找到一个常数*k*，使得*T*(*n*) < *kn*，那么*T*(*n*)是*O*(*n*)。 对于至少为 1 的*n*，通过设置*k* = *c*[0] + 2*c*[1]，这很容易满足。或者我们可以记住，任何一次多项式都是*O*(*n*)，也是Θ(*n*)。找到正确的界限的更简单的方法是观察常数*c[0]*和*c[1]*的选择并不重要；如果我们将它们都替换为 1，我们得到*T*(1) = 1，*T*(2)=2，*T*(3)=3 等，这显然是*O*(*n*)。

现在让我们考虑`merge_sort`函数本身。同样地，对于零个和一个元素的列表，我们在常数时间内计算。对于 *n* 个元素的列表，我们进行两次递归调用，但是对大约一半大小的子列表进行调用，以及对于每个都需要Θ(*n*)时间的`split`和`merge`。为简单起见，我们假装子列表的大小正好是一半。我们获得的递归关系形式如下：

> *T*(0) = *c*[0]
> 
> *T*(1) = *c*[0] *T*(*n*) = 2 *T*(*n*/2) + *c*[1]*n + * *c*[2]*n + c*[3]

让我们使用迭代法来计算`merge_sort`的运行时间。我们知道任何解决方案都必须适用于任意常数 *c*[0] 和 *c*[4]，所以我们再次将它们都替换为 1 以保持简单。这样，我们就得到以下递归方程：

> *T*(1) = 1
> 
> *T*(*n*) = 2 *T*(*n*/2) + *n*

从迭代法开始，我们可以开始展开时间方程，直到注意到一种模式：

> *T*(*n*) = 2*T*(*n*/2) + *n*
> 
> = 2(2*T*(*n*/4) + *n*/2) + *n*
> 
> = 4*T*(*n*/4) + *n* + *n*
> 
> = 4(2*T*(*n*/8) + *n*/4) + *n* + *n*
> 
> = 8*T*(*n*/8) + *n* + *n* + *n*
> 
> = *nT*(*n*/*n*) + *n* + ... + *n* + *n* + *n*
> 
> = *n* + *n* + ... + *n* + *n* + *n*

计算最后的总和中 *n* 的重复次数，我们看到它们有 lg *n* + 1 个。 因此，运行时间为 *n*(lg *n* + 1) = *n* lg *n* + *n*。我们观察到 *n* lg *n* + *n* < *n* lg *n* + *n* lg *n* = 2*n* lg *n* 对于 *n*>0，所以运行时间是 *O*(*n* lg *n*)。 现在我们已经通过迭代方法进行了分析，让我们使用强归纳来验证这个界限是否正确。

### 使用强归纳的归并排序分析

**要证明的性质 P(n)：**

> *n* ≥ 1 ⇒ *T*(*n*) = *n* lg *n* + *n*

**对于 n 进行强（函数值）归纳**。对于任意的 *n*，假设归纳假设 *T*(*m*) = *m* lg *m* + *m* 对于所有的 *m*<*n* 是真实的。

**情况 n = 0**：空证

**情况 n = 1**：T(1) = 1 = 1 lg 1 + 1

**情况 n > 1**：

> 归纳假设：
> 
> 证明：
> 
> *T*(*n*) = 2 T(*n*/2) + *n*
> 
> = (*n*/2) lg (*n*/2) + 2(*n*/2) + *n*              *(根据归纳假设)*
> 
> = *n* lg (*n*/2) + 2*n*
> 
> = *n* lg *n* − 1) 1) + 2*n*
> 
> = *n* lg *n* + *n*

由于 *n* lg *n* + *n* 是Θ(*n* lg *n*)，我们已经证明了归并排序是Θ(*n* lg *n*)。

## 斐波那契数

斐波那契数，记作*F(n)*，由*F(0)=0*，*F(1)=1*定义，对于*n>1*，*F(n)=F(n-1)+F(n-2)*。 前几个斐波那契数是 0,1,1,2,3,5,8,13,21,34,55,89,...

### 第一个实现版本及其复杂度

我们想要编写一个计算第 *n* 个斐波那契数的函数。 第一个实现版本可能是：

```
(* requires n>=0 *)
let rec fibo=function
  0 -> 0
| 1 -> 1
| n -> (fibo (n-1))+(fibo (n-2))

```

此函数直接遵循斐波那契数的定义，因此它的正确性是显而易见的。现在，如果我们尝试在 OCaml 中运行它，比如说 100，它需要永远的时间才能完成。让我们通过分析其渐近时间来看看为什么。

当*n=0*和*n=1*时的渐近时间是常数，我们称之为*c[0]*，因此*T(0)=T(1)=c[0]*。为了计算*T(n)*，我们进行两次递归调用，得到*T(n)=T(n-1)+T(n-2)*。

在数学中，可以证明这个递推关系的解的形式是 *T(n)=a[1]*r[1]^n+a[2]*r[2]^n*，其中 *r[1]* 和 *r[2]* 是方程 *r²=r+1* 的解。我们得到 *r[1]=(1+sqrt(5))/2* 和 *r[2]=(1-sqrt(5))/2*。然后根据 *T(0)=T(1)=c[0]*，我们得到 *a[1]+a[2]=a[1]r[1]+a[2]r[2]=c[0]*，从而得到 *a[1]=c[0]r[1]/sqrt(5)* 和 *a[2]=-c[0]r[2]/sqrt(5)*。

我们可以看到 *r[2]<1*，因此 *r[2]^n* 是 *o(1)*。因此 *T(n)* 是 *Θ(r[1]^n)*，其中 *r[1]=(1+sqrt(5))/2*。因此算法完成所需的时间是指数级的。

### 更高效的实现方式

```
(* requires n>=0 *)
let fibo' n=
 if(n=0) then 0 else 
   (* a is F(i-2) and b is F(i-1) *)
   let a=ref 0 and b=ref 1 and c=ref 0 in
   for i=2 to n do
      c:= !b;
      b:= !a + !b; 
      a:= !c;
   done; !b

```

这个实现显然是线性的：每次循环需要固定的时间完成，循环次数是*n*的数量级。与之前一样，正确性可以通过对*n*进行递归来得到（声明在每次循环中，*a=F(i-2)* 和 *b=F(i-1)*）。
