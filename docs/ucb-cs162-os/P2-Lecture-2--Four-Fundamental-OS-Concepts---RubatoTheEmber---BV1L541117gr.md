# P2：第二讲：操作系统的四个基本概念 - RubatoTheEmber - BV1L541117gr

好的，大家好，欢迎回到162课堂。我将进行第二讲，继续讲解上一节未完成的内容。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_1.png)

上次我们开始讨论的内容。如果你还记得，上一节我们大致讲了操作系统，并且我们问了自己，操作系统究竟是什么。然后我试图向你们说明，操作系统有很多种，不同的人对此会有不同的看法。但这些。

裁判、魔术师和粘合剂这三种功能在各种操作系统中都很常见，许多操作系统都具备这三者。好的，裁判实际上是在管理资源，魔术师则提供了无限内存和完美硬件资源的幻象。而粘合剂则由一系列常见服务组成，比如文件系统。

等等，这些都能帮助我们更好地进行机器编程。我们也。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_3.png)

我们开始谈论一般的保护问题，这将是我们第一个详细讨论的主题之一，不过今天我们会简单提及。这里我展示的是，硬件在下面，操作系统在上面，基本上为进程提供了虚拟机视图。好的，进程就是我们接下来要讨论的内容。

今天我们要更详细地讨论，并且在未来几周会进一步深入讨论的内容，实际上是这些虚拟容器，它们认为自己有完美的硬件底层，并认为自己拥有整个机器。所以在这里，我展示了一个棕色进程和一个绿色进程，棕色进程认为自己拥有所有的内存、所有的文件系统、所有的套接字和线程，进程。

绿色的进程类似地认为，操作系统的职责就是提供这种幻象。至于保护问题，当然这里的关键部分是，例如这个绿色进程，在运行时，可能会试图访问棕色进程的内存，可能会试图访问操作系统的内存，也可能会试图访问存储的一部分。

它不应该这么做。在所有这些情况下，最终发生的事是，操作系统基本上阻止了这种情况发生，然后会导致一个分段错误，并基本上把进程强行退出。所以这就是保护机制。我们将在接下来的几周中详细讨论这一点，会有许多不同的方法来实现这一点。

这就是某种形式的保护，今天我会先给你们展示一个相对简单的思路。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_5.png)

我们上次没有完全讲到的，现在我想提一下的是真正的复杂性。你看到了上次我展示的世界作为单一机器的画面，那个单一的大型计算机。那是一大堆硬件，必须以某种方式加以驯服。如果你看看应用程序，它们实际上有各种各样的需求。

软件模块运行在各种不同的设备或机器上，实施不同的硬件架构，运行竞争的应用程序，以意想不到的方式发生故障，可能会受到攻击。实际上，无论是应用程序想做什么，还是所有底层硬件的复杂性，都非常巨大。好吧，这其实是不切实际的。

测试所有组合几乎是不可能的。我的意思是，你怎么可能测试一个应用程序与一个配备1TB固态硬盘、2TB旋转存储、6GB内存和100GB内存的机器的兼容性呢？你根本做不到，而且所有的组合是不可能的。所以，我们真的得弄清楚如何去做。

从一开始就正确设计这些东西是非常复杂的。而且，你知道，让我们现在接受这一点。问题不在于是否会有bug，而是bug的严重性以及它们的类型。我们将在整个学期中尽力进行bug管理。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_7.png)

导致复杂性的原因是并行性。正因如此，当然，我们将在接下来的几周里花大量时间讨论同步原语。但是我想提一下，这是一个来自2027年的好例子。英特尔的Skylake处理器拥有最多28个核心，甚至有56核版本，可以支持最多56个线程。所以每个核心有两个线程，此外还有许多不同的安全指令和图形指令。

在L2级别有28MB的缓存，在L3级别有38.5MB的缓存。采用基于目录的缓存一致性技术。还存在多种类型的网络，包括芯片内的网状网络和快速的芯片外网络，DRAM连接可以达到1.5TB。这一切都非常复杂。

即使是单个节点也是如此。所以当我们将这一切连接起来时，事情就变得非常有趣，对吧？但并行性是当今的基础。除了并行性，

![](img/80deaa59936768fb1fcdc3b7bf8785ea_9.png)

现代芯片通常还配有一个芯片组。所以你在顶部看到的是一个英特尔芯片家族的处理器示例，拥有多个核心。它与内存和PCI Express有直接连接，以进行高速通信。然后，通常还有一个直接的媒体接口连接到下面的芯片组。

芯片组可能处理所有其他有趣的部分。所以从处理器的角度来看，我们有高带宽内存通道。我们有非常高速的I/O用于图形。我们有这个直接媒体接口连接到这个二级芯片组，曾经被称为南桥。例如，但现在不再是了。但无论如何，从那儿我们有。

PCI Express。我们有SATA用于硬盘。我们有USB用于其他类型的I/O。我们有以太网，I/O，PCIe，RAID等等。各种各样非常有趣的东西都连接到这个CPU上。所以如果你看看，嗯，这本身就很有趣。这非常有趣。复杂性很高。而且，你知道，我很喜欢这个图表。你们都应该看看。你们。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_11.png)

你可以访问 information is beautiful.net/visualization/millionlinesofcode，查看多年来一些代码的数量统计。好的。有趣的是，如果你看看某个版本的更新内容，比如Linux 2.2与Linux 3.1，通常是越来越大。所以每一代的程序都更多。对吧。也就是说，每一代都需要更多的内存，更多的复杂性。

一辆车开始变得非常复杂。1亿行代码。实际上，看到一辆特斯拉是怎样的会很有趣。你知道，那种复杂性。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_13.png)

如果你没有正确设计它，漏洞就会渗透到操作系统中。然后你会看到蓝屏。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_15.png)

好的。鼠标碱基对。问题是，什么是鼠标碱基对？这实际上是小鼠的DNA。好的，所以我们并没有离这个复杂性太远。好的。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_17.png)

第三方设备驱动程序，作为操作系统的一部分，负责访问外部世界，是操作系统中最不可靠的部分之一。好的。其原因是，它们并不是写得很好，通常是快速编写以支持新设备，并且它们不是由微软、苹果或你的操作系统供应商编写的。

结果是，它们往往是导致系统崩溃的原因。好的。基本上，从操作系统到设备之间有着干净的接口。这是一次尝试，提供一个干净的接口，使得第三方可以编写这类代码。讽刺的是，在某些情况下，这反而会导致更多的崩溃。我们将花时间。

后期我们会花很多时间讨论设备驱动程序。并且存在各种各样的漏洞。好的。看，如果你没有足够的复杂性来保证一切正常工作，现在你就会有安全漏洞。好的。2017年一个很好的例子是臭名昭著的Meltdown漏洞，当时发现尽管硬件上有所有保护措施。

在操作系统中正确使用这些硬件，你最终得到了用户级程序能够从内核中提取安全信息的能力。好的。所以如果你考虑一下，那就像是，我做了我能做的一切，但硬件中有一个没人知道的奇怪漏洞，甚至让一些著名的计算机架构师都感到惊讶。

像Dave Patterson和John Hennessy。所以复杂性总是存在的。在最好的情况下，我们必须管理它。好的。然后像版本队列、库等问题会导致各种各样的问题。好的。数据泄露、拒绝服务攻击、时序通道。比如心脏出血SSL漏洞，等等。所以如果你不小心，所有这些漏洞都会存在。好的。

所以，我看到聊天中有个评论，说这是一个非常酷的漏洞。是的，Altong作为漏洞确实很酷。我们实际上会在学期后期讨论这个。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_19.png)

所以回到操作系统应该做什么。我们有这么多复杂性。实际上，操作系统在努力驯服底层硬件，并提供一个干净的虚拟机抽象。所以这里是底层的硬件。我们有物理机器接口，它们就是它们的样子，它们的总线，它们与磁盘的接口。我们有一个。

操作系统在其上运行，然后将所有这些不完美的物理接口或有限的物理接口转化为一个干净的编程抽象，以便上面的抽象机器接口可以被应用程序使用。好的。我给你最简单的思考方式就是这种无限内存的错觉。所以也许你只有。

你的笔记本上有16GB内存，但操作系统给你一种错觉，认为内存远远更多。它通过分页和各种其他虚拟内存技术来实现这一点，我们稍后会讨论。但操作系统的功能是提供这个虚拟或抽象的机器接口，它比硬件更完美。

好的。那么底层的处理器变成了一个干净的线程。底层的内存变成了一个干净的地址空间。磁盘和SSD，这些只是基于块的存储，变成了文件。好的。网络通向套接字，套接字给你提供了一种能力，能够完美地从世界的一部分发送流到另一台机器，机器变成了进程。好的。

所以这里有各种有趣的东西，但基本上这是操作系统作为一名魔术师，去除软件硬件的怪癖，给我们一个更好的抽象。好的。你可以选择任何操作系统领域，我们有很多领域，我们将在本学期有一个有趣的示例，比如文件系统、虚拟内存、网络、调度等等。

我们需要提出的问题是，我们需要处理的硬件接口是什么？那是物理现实。而我们希望提供的软件接口是什么？那是更为优雅的抽象。因此，我们将在整个学期中探索硬件接口与自然抽象之间的关系。好的。今天我们有四个基本的操作系统概念，我们希望传达这些概念。

让我们深入探讨并开始行动。好的。第一个概念是线程。线程是一个虚拟执行上下文，完整描述了正在执行程序的程序状态。它有计数器，有寄存器，有执行标志，还有栈。好的。然而，这个线程是一个虚拟实体，稍后你会看到，这不一定是。

它始终在 CPU 上运行，并且不一定运行在同一个 CPU 上。因此，线程本身是一个独立的实体。好的。希望我们能达到一个阶段，我们会从线程而非 CPU 的角度来思考。实际上，在第一次讲座之后，我们在 Piazza 上有过一些关于这个概念的有趣讨论。今天我们也会进一步讨论这个话题。

另外一个我们想讨论的概念是带有或不带有翻译的地址空间。地址空间本质上是程序在读写时所看到的内存地址集。它实际上可能与物理机器是不同的。因此，地址空间是一个虚拟化的概念。第三个概念是。

现在它将变成一个进程。所以一个进程是一个受保护的地址空间和一个或多个线程的组合。好的。因此，进程实际上是程序的一个执行实例，处于它自己的受保护环境中，可能有多个任务在运行。好的。最后，我们将引入一些硬件。这个硬件的概念是双模式操作。

这就带来了保护问题，而双模式操作的真正含义是，某些事情只能由系统来完成。好的。我们区分系统模式和非系统模式的方式，将会是硬件中至少一个位，可能更多的位，用来指示我们是处于系统模式还是用户模式。好的。

我们将展示更多关于它是如何工作的。但简单的想法是，当你处于系统模式时，硬件允许你比在用户模式下有更多的访问权限，这将使我们能够提供一个干净、清晰的虚拟抽象。我们称之为双模式，因为有两种模式。好的。那么，现在让我们来看看。

结论是什么？结论是什么？操作系统帮助我们运行程序。这是我们在这里要关注的重要方面，对吧？所以这是 Joe，他正在打字。他写出了一个程序，他将一些内容输入到编辑器中。然后编译器实际上会生成这些指令的二进制版本。

将会在 CPU 上执行。它将包含数据。它将包含指令。以二进制模式。通常，它存储在一个名为 a.out 的文件中，这是编译器的结果，可能还有链接器的结果。好的。一旦这个文件存在，它可能会保存在你的磁盘上，然后当我们想要执行它时，我们就会取出这个可执行文件，将它加载到内存中。

这就是程序开始执行的时刻。好的。所以，程序是潜在的可执行文件。一旦它加载到进程中，就成为一个正在执行的进程。好的。我们可以在不同的进程中同时运行同一个可执行文件的多个实例。你会在接下来的过程中看到这一点。但是如果你注意到，

这是一个进程的典型地址空间，地址空间大致上，记得我说过，它包括所有可以访问的地址。通常，从零开始，到 FFFF。低地址部分通常存储指令，数据位于其上面，堆等等。然后在顶部，是操作系统空间。

这是受保护的。然后，我们从那里向下扩展以创建栈。现在，有一个问题是，链接器在哪里。我没有在这里展示，但可以把它想象成是一个结合了编译和链接的过程，生成最终的可执行文件。链接器实际上是在将你编译的各个部分和一些库文件结合起来，形成一个整体。

我们会在接下来的过程中看到更多的内容。好的。一旦我们将数据加载到内存中，并且处于进程中，我们就创建栈和堆。栈是向下增长的，允许我们进行递归调用。堆则是向上增长，用于分配内存。因此，最终我们将拥有一个完全执行的进程。

进程。好的。那么它是如何开始执行的呢？我们加载程序计数器。然后我们让处理器指向进程中的一个起始指令。接着我们告诉处理器开始执行。从那时起，它就开始执行了。通常，我们不会在系统模式下进行这个操作。我们确保在发出开始执行指令时，它是在用户模式下。

结果是，这将是一个受保护的实体。当我们处于用户模式时，当我们处于系统模式时，不必太担心细节，因为我们会随着进度给出更多细节。我们现在要传达的是一个高层次的概念。那么，有问题吗？每个进程分配多少内存？这是一个好问题。

所以答案是，大多数操作系统会尽量只分配最基本的内存需求。它基本上只分配指令和数据。通常不会为堆或栈分配实际的 DRAM。但地址空间是存在的。好的。所以这里，你需要开始考虑虚拟地址与物理地址的区别。物理上，

我们启动时不会获得太多内存。虚拟上，我们有所有这些地址。接下来会发生的是，当程序尝试使用未映射到实际内存的地址空间部分时，它们会被操作系统捕获，操作系统会为其分配更多内存，然后返回给用户。因此。

使用现代操作系统，我们可以从给定进程最小需要的资源开始。然后，当程序开始运行时，它会自动适应。好的。当然，一旦一切都运行起来，操作系统将通过系统调用提供服务，我们稍后会讨论这些。好的。还有其他问题吗？

安东尼实际上提供了一些关于链接的好细节。所以有静态链接和动态链接。我们稍后也会讨论这些。好的。那么现在让我们后退一点。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_21.png)

从你在61 C课程中学到的内存深度来看。如果你记得处理器内部的内容。顺便说一下，系统调用是将控制权转移到内核的过程，是一种受控的转移。我们将继续深入讨论这些内容。所以，如果你看到这里，我们通常会有一个程序计数器，它是处理器内的一个寄存器。

然后我们在内存中有指令，这些指令位于进程的地址空间中，还有数据。程序计数器指向下一条待执行的指令。接下来，实际的处理器会从内存中提取该指令，解码它，并决定如何处理。好的。例如，一旦我们获取了指令，它将被解码。然后。

解码后的指令将会在数据路径上工作，可能会从寄存器中提取数据，并指示算术逻辑单元（ALU）进行乘法运算或其他操作。结果可能会被存储到内存中，或者从内存中提取数据。然后我们执行下一条指令。好的。所以这就是取指、解码、执行的连续循环。

然后返回内存。好的。希望这能提醒你一些61 C课程的内容。这里有个问题是，如果程序中发生内存安全违规会怎样。那么，我们需要更详细地了解这意味着什么。但我在前几张幻灯片中展示了，绿色进程试图访问内存的那个概念。

在棕色进程中。并且该内存访问违规被标记为段错误（segmentation fault）。然后绿色进程被转储。好吧。这将是我们可以得到的许多响应之一。所以，你知道，本质上，处理器将在执行过程中通过一系列的指令来推进程序计数器（PC）。这就是我们让程序运行的方式。好的。

我在这里提到的第一个概念是控制线程。线程实际上是一个唯一的执行上下文，包含程序计数器、寄存器、执行标志、栈和内存状态。好的，你需要把它当作这个的虚拟版本来看待。所以61C的想法是，处理器正在执行指令。好的。

但是，抱歉，仅仅让那个处理器执行指令的做法太低级，无法在其上构建现代环境。所以，我们将用线程来虚拟化这个概念。线程是有程序计数器的东西，因此它知道下一条指令来自哪里。但由于它是虚拟的，实际上它可以是。

从物理处理器卸载一会儿，然后重新加载并重新开始执行。所以即使线程没有访问CPU，它也能保持自己的身份。这对我们来说是有帮助的。好的。线程本质上是在处理器或核心上执行的，当它常驻时。好的，当它在处理器寄存器中。

顺便说一句，让我澄清一下，接下来的几周里，我们将独立地讨论处理器或核心。我们现在会考虑每台机器只有一个核心或处理器。好的，所以不要担心多核。好的，我们首先要理解单核。

所以我将使用“处理器”这个词，可能也会使用“核心”这个词。接下来的几周里，这两个词基本可以互换使用。好的。无论如何，线程实际上是在处理器寄存器中执行的。所以，如果你回头看一下，你可以说，嗯，这可以被看作是一个处于寄存器中的线程，或者有指针指向内存中结果要存储的位置。

现在正在运行，因为它的程序计数器位于处理器的真实程序计数器中。好的。那么这里“常驻”真正的意思是寄存器保存所有状态，线程的根状态或上下文。寄存器中加载了程序计数器，程序目前正在从那里执行指令。程序计数器指向内存中下一个指令。

所有的指令都存储在内存中，这样处理器或核心开始执行时，就可以从内存中取出指令。好的。所以我们真正需要的指令就在内存中。它还包括正在计算中的中间值，这些值保存在实际的寄存器中。比如我们可能加了两个数，它们的结果是。

而且，物理硬件中的栈指针实际上保存着线程栈顶的地址，这个栈是在内存中的。其他的一切都在内存中。所以这是一个正在执行的线程。如果你想再想一想61C，正在执行的线程。

线程或加载线程或驻留线程是一个运行中的示例，就像你在61C中思考的那样。好吧，当线程被挂起或不执行时，它的状态不在处理器中。所以，这就像是你把61C中的东西完全卸载并放到某个内存位置一样，我们将。

我们称之为线程控制块，它依然是一个线程，只不过它没有在运行。好的。此时，其他东西正在运行。所以处理器状态指向了另一个线程。明白吗？好的。那么，我们再回到。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_23.png)

向你的61C学习。我们将继续保持虚拟机的概念。我只是想展示这个图，看看这是一个处理器或核心。我们将执行取指-执行循环。我们有一堆寄存器加载好了。执行序列会取出程序计数器指向的指令，解码它，执行它，写回结果，然后跳到下一条指令。

所以，结束并重复，这就是一个洗净再来、循环往复的场景。例如，如果程序计数器指向指令零，我们将执行它，然后跳到指令一，继续指令二、三、四。好的。请记住，在这门课中有一个问题是，核心、处理器或执行单元是否是同一个东西。

知道了，我知道安东尼对此给出了一个答案。现在暂时不要对这个感到困惑。处理器可以是多个核心的集合，有时候它们的工作方式就像一个实体。我们现在讨论的只是一个处理器，它只执行一个核心，并且只有一个核心。所以暂时不要对此感到困惑。好吧。所以每当我提到核心时，请理解为处理器。

我在考虑的是一个仅包含一个执行管道的东西。好吧。另一个我想说的事情是，别急着深入探讨这里的挂起问题，等一会儿再讨论。如果安东尼愿意，他可以回答。但是我们先把这个问题搁置一两周。好的，那样会更有意义。

这是我们的执行序列。程序计数器正在忙于执行。有一组寄存器代表线程，并且在任何给定时刻都已加载。这就是比如61C的视图，它像一个简单的RISC处理器，拥有一组非常直接的寄存器，而且它们非常多。如果你看，那有点像。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_25.png)

风险五。好的。我们有一堆寄存器，其中一些是下一个程序计数器，还有一些是堆栈指针等等。可以执行的指令集很简单。有加法、减法等等。在这门课上，我们将突破现代计算机的复杂性，这种计算机更可能存在于你的笔记本电脑中。好吧，像是x86架构。

所以，如果你注意到，x86 架构有很多不同类型的寄存器，但它们的数量比较少。好的，这里有段寄存器用于段操作，还有一些寄存器用于控制和标记等等。还有许多其他的寄存器。所以我们将看看这些寄存器的作用，因为这个环境

我们在这个课程中使用的 PintoOS 操作系统运行在 x86 环境下。好的，接下来的部分会更详细地介绍架构。我也会在后续深入讲解。但我现在要重点讲的是，大家把注意力集中在这里：我们如何可能只有一个核心或一个。

处理器有许多线程，看起来像是同时运行的。好的，我们将得到一组虚拟 CPU 或线程的视图，所有线程共享相同的内存。这就是程序员对进程的视图。所以假设只有一个核心。现在问题是，我们如何提供这种错觉？我们通过多路复用来实现。

所以可以将线程看作虚拟核心。这里时间向右移动。接下来我们要做的是，我们将先运行虚拟 CPU 一段时间，然后是第二个虚拟 CPU 一段时间，再是第三个虚拟 CPU 一段时间。然后我们会回到第一个虚拟 CPU，依此类推。基本上，我们将把线程的内容加载到处理器中。

我们会运行一段时间，然后卸载它。接着加载下一个线程。我们将不断地重复这个过程。如果我们用足够精细的粒度来进行操作，那么从表面上看，所有线程似乎是同时运行的，尽管实际上只有一个线程在处理器上运行。

好的，一个虚拟核心的内容就是我们一直在说的一个线程。程序计数器、堆栈指针、寄存器等。线程在哪里？它实际上是在真实的物理核心上，就像在品红色时间中，CPU 一或线程一实际上被加载到物理核心上，或者在不运行时保存到一块内存中，这块内存叫做。

线程控制块。好的，操作系统负责调度，并负责反复将这些线程交换进出，以便给我们这种错觉。好的，我会重复多次这个过程，只是为了确保大家都在同一页面，因为这个概念比较简单。如果你还不太明白。

如果我们没有掌握这里发生的事情，那么后面的内容会显得很混乱。那么，其他问题呢？问题是好的。这里在 Slack 中的一个大问题是：每个线程的执行时间是否相同？答案是，不必相同。事实上，我们会有一个专门的单元讨论调度程序，在那里我们会根据不同的情况改变线程的时间分配。

基于优先级，或者我们将根据实时要求进行调整。所以你能做的最简单的事情就是给每个线程相同的时间。但这绝对不是必须的。为了让你更清楚为什么这可能行不通，假设 CPU 一运行了一段时间，然后它必须与磁盘或网络进行通信。

这需要几毫秒或几秒钟。它不能运行。所以，让 CPU 等待这些外部内容毫无意义。因此，切换到另一个线程是一个很好的理由。好吧。那么，CPU 空闲意味着什么呢？它的意思是，目前没有任何线程可运行，因为它们都在等待，空闲。好吧。

这将是一个很好的空闲 CPU 示例。好吧，理解了吗？现在，顺便提一下，我假设在这张幻灯片中我们有三个可运行的线程。因此，我才会显示它们交替运行。现在，让我们继续探讨这个幻觉。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_27.png)

暂停一下。那么，考虑一下，例如，在时刻一，虚拟 CPU 一在实际核心上。CPU 二在时刻二回到内存中，虚拟 CPU 一在核心上，CPU 二在内存中，等等。好吧。那么，从 T 一到 T 二发生了什么？嗯，如果你思考一下，肯定有某些东西接管并卸载了线程一，然后加载了线程二。这是什么呢？嗯。

是操作系统。所以，在线程一和线程二之间的这个边界，操作系统以某种方式运行了。它保存了程序计数器、堆栈指针，以及所有的 CPU 线程内容到内存中，然后将 CPU 二线程的内容从内存加载回 CPU。好吧。并且，如果你仔细思考，可能会问自己，嗯，怎么可能。

操作系统是如何获得控制的，因为用户正在运行这里，对吧？假设 CPU 一正在做我最喜欢的事情，也就是忙着计算 pi 的最后一位数字。那么它不会把任何时间分给操作系统，因为它正在计算最后一位数字。所以，实际上，必须在这里进行某种干预。好吧。

我们将学到更多关于这一点的内容。但最简单的干预是定时器触发后进入操作系统。然后操作系统从 T 一 中夺取控制并交给 T 二。好吧。顺便说一下，作为 162 课程的重要部分，你必须知道为什么计算 pi 的最后一位数字很重要。好吧。这基本上是为了移除恶意实体。

来自早期企业计算机的图像。唯一让斯波克能够恢复计算机的方法是，他让所有的内存银行开始计算 pi 的最后一位数字，这才挽救了局面。所以你们需要记住这一点。这就是今天的历史。好吧。现在，定时器是否有自己的线程或进程？这是个好问题。

答案是，它不需要。它只需要有某些东西在计时器触发时接管运行。所以大多数时候，它可能根本不在运行。当它开始运行时，它可能是在一个中断上下文中运行，并不一定是一个完整的线程。我们会详细讨论这个问题。好的。所以保持这个答案在心中。

保留在你脑海中的问题，稍后再问我，好吧，不是今天，可能在几节课后。好的。那么是什么触发了这个切换呢？我刚才讲过计时器，但还有其他原因。例如，CPU 之一可能自愿放弃了 CPU。一个很好的例子是系统调用。你好，我想做 I/O。好的，我放弃了 CPU，因为 I/O 将进行，而计时器。

不是计时器，调度程序接管了控制，并在 I/O 操作进行时也会加载 CPU。所以这是一个自愿的过程，这是 I/O。也可以选择给其他任务一个机会。其他我们稍后讨论的内容。好的。但我们必须有某种方式来接管控制权。现在，问题是，我能否重复操作系统如何重新获取控制权？如果你看一下规范。

在这里的最后一条内容，它为你列出了操作系统如何控制的所有方式。今天最简单记住的一点是，操作系统内的计时器触发后，会从线程一中抢夺控制权。好的。因为操作系统是在中断级别运行，而线程是在用户级别运行，所以答案是：不行，操作系统能够抢夺它的控制权。

线程一无法阻止这种情况发生。这很重要。所以多个。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_29.png)

现在谈谈控制线程的问题。通常我们称之为多任务处理。如果你看一下这里，我们有一堆进程在操作系统上运行。每个进程都有自己的一小块内存。当它们运行时，需要有一种假象，认为它们拥有 100% 的内存。所以我们。

必须对 DRAM 做一些处理，以产生那种假象。例如，当绿色处理器运行时，它拥有全部内存，因为显然内存中有许多不同的进程。好的。聊天室中的一个好问题基本上是：既然线程就像虚拟 CPU，为什么现代 CPU 会有特定数量的线程？

答案是，CPU 规格中列出的线程数是硬件线程的数量。这是我们能够同时运行的控制线程的数量，实际上是在硬件层面上。好的。那么现在，我们暂时不考虑硬件线程或多个核心，我们稍后会回到这一点。

我保证。好了，如果你看看线程控制块，它保存了线程未运行时的寄存器内容，其他信息呢？它会有诸如寄存器、程序计数器，正如我提到的，栈指针等等。那么，线程控制块存储在哪里？

它目前会在内核中。可以开始做一些事情，比如阅读`thread.h`和`thread.c`，这是在进程控制结构中，当你开始第一个项目，项目零时，你可以通过阅读这些文件来开始。这样你就有机会实际操作。

很快你就可以开始查看代码了，开始看到我所讲解的某些内容是如何实现的。好的。关于什么是用户级别或中断级别的问题，我们稍后再处理太多的详细问题。只需记住，用户级别的优先级低于内核级别或中断级别。好的，我们稍后会讲到。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_31.png)

后续会更详细讲解这些。所以现在让我们谈谈一些琐事。所有人，不论是已经注册的同学还是仍在等待名单上的同学，都应该做作业零。好的，它的截止日期是下周三，所以你需要开始做它。而且它很重要，因为它将帮助你设置你的虚拟机环境。

并熟悉工具以及其他一些内容，包括作业零和项目零，项目零将在下周一开始。因此，所有这些内容对于尽快开始非常重要，因为当项目，真正的项目启动时，并且你的组已经准备好，第三周会发生这一切，你需要已经完成了这些准备。

完成所有这些初步工作。所以即使你觉得你仍然能进入这门课，并且在等待中，你也应该做这个作业。除非你退课了并且不再在等待名单上，当然也不是在这门课上，你应该做这个作业。好的。接下来，我们终于整理好了我们的分组。所以所有的。

从下周开始，我们的大部分小组会安排在星期五。我知道我们之前有些奇怪的安排，比如星期三和星期四。但这样安排的重要性在于，我们可以确保小组能够覆盖本周两次讲座的细节，并且每个人都能得到相同的内容。

在小组前的讲座。所以这将使事情变得更加清晰。好的。请注意，Piazza和我们网站上的更新。好的。滑动天数。你会得到一些滑动天数。这里有个好问题。让我倒回去。关于是否需要注册小组，或者前两周可以去任何一个小组的问题？你可以去任何提供的小组。

好的。当你们报名加入小组时，即将在第三周开始，我们会根据你们的偏好分配小节，以确保你们四个小组成员都在同一个小节，或者至少由同一个助教负责。这一点非常重要，因为这样助教就能了解你们和你们小组的成员。好的。

所以你们将实际报名加入小组并给出一些偏好，之后我们会根据这些偏好为你们分配小节。好的。但是现在，前两周，任何小节都可以。回到补交天数。所以你们有三天补交期用于作业，四天补交期用于项目，完全可以根据自己的需要使用。但是不要马上就用掉，因为。

当你开始用完补交天数时，作业或项目将不再给予延期成绩。好的。这非常重要。这些补交天数并不是用来弥补开始得太晚的，尽管你偶尔可以这么做。它们是为了应对突发情况。如果有什么没有顺利进行，或者有人有问题，受伤或生病的情况下。好的。至于星期六。

这是一个可选的复习环节。好的。Zoom链接可能会在之后公布，或者通过Piazza发布，可能会录制。好的。星期五是退选截止日期，从这个星期五算起，一周后。请在那之前退选，如果你打算退选的话。这样我们可以确保每个想加入并能够加入的人都能顺利加入。好的。因为之后就很难再退选了。

退选截止日期过后就很难再进行退选。所以请尽早退选，而不是等到最后。好，大家有问题吗？

让我们看看。我有打开吗？这是最后一个。顺便提一下，我们的最终班级人数已经确定。我们不会再增加更多的小节了。现在有11个小节。我们也不打算增加更大的班级规模。所以，你们知道的，我想我们快接近最终的注册人数了。我们将选择所有的星期五小节。好的。所以我们。

不再进行星期四的课程。再说一遍，从课程内容的角度来看，这是很重要的。好的。我再次提醒大家合作政策。我们可以向其他小组解释概念性的内容。好的。概念性地讨论算法。好的。讨论调试方法时不涉及具体细节，可能可以。

在线搜索如哈希表这样的通用算法是可以的。好的。好了，这些算是允许的合作。与其他小组共享测试用例的代码。不好。复制或阅读其他小组的代码或测试用例。不好。复制或阅读你朋友的代码。不好。好的。你不能搜索来自过去年份的在线代码或测试用例。

我们实际上会对这一点进行检查。好的。我们有实时检查，确保没有人这么做。所以不要做这件事，因为如果你被抓到进行违规合作，会给大家带来麻烦。我们真的不希望处理这些问题。好的。帮助另一个小组的人调试。

他们的代码。不好。好吧。所以我们会将所有的项目提交与往年的项目和在线解决方案进行对比，如果发现匹配的地方我们会采取行动。不要，别。让朋友陷入困境，帮你做一些事情。好吧。别问他们要代码。这只会，结果对你们俩都不好。好吧。好的。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_33.png)

那么我们来看看地址空间的第二个概念。你们整个学期会使用哪些测试框架吗？这是个好问题。我们会从确保你们学会GDB开始。随着时间推移，我们可能会给你们更多的单元测试选项。好的问题。我们看看能做什么。好吧。但肯定的。

想要掌握GDB。所以我之前提到过地址空间。这里是一个例子，假设是32位地址的地址空间。那意味着这里有32位的数字。这些是十六进制的。所以有8个十六进制数字。从00到FFFF，这是一个地址空间。好吧。这是32位处理器的所有地址。

可以想象访问。请注意，这只是一个虚拟的概念。好吧。所以仅仅因为它们可以访问所有32位并不意味着所有32位都是有效的，甚至不一定由DRAM支持。好吧。这是一个线程在运行时的视图。好吧。所以一个地址空间集就是在状态下可以访问的地址集合。对于一个32位的处理器，它大约有40亿个地址。

对于一个64位的处理器，它要大得多。好吧。它有18亿亿个地址。那么当一个线程在运行时，从某个地址读取或写入会发生什么？答案是，嗯，可能它就像普通内存一样，你可以读取或写入到内存。也许你写入它，但什么都没有发生，因为它是只读的，但它已经设置好了。

忽略你的权限。好吧。也许它会导致一个I/O操作。可能从一个地址读取或写入，实际上会导致屏幕上显示一些东西。好吧。这就是内存映射I/O。我们将深入讨论这个。也许它会引发一个异常或故障。好吧。那意味着你试图访问内存空间的某些部分。

你没有权限访问，结果会发生页面错误。可能它会和另一个程序通信。好吧。所以，这里有一个有趣的点，我们稍后会称其为共享内存。或者实际上在几节课后，你会看到在某些地址上进行读写时，这些地址会出现在其他人的地址空间中。好吧。所以地址空间就是一组地址集合。

你可以访问的地址，以及你尝试读取或写入它们时发生的情况，取决于操作系统和它的配置方式。我们将深入讨论如何做到这一点。好吧。现在，给你们看一张图。这里是处理器寄存器。这里是程序计数器。它指向地址空间中的某个地址指令。这里是堆栈指针。

它指向栈的底部。好的。那么，代码段中有什么呢？嗯，指令。静态数据段中有什么呢？嗯，就是在你的 C 程序中静态定义的数据。好的，栈段中有什么呢？嗯，希望我们下次会更详细地讨论这个。你还记得栈是什么吧？所以栈就是一组局部变量。

通常，当你调用一个过程时，会分配一个新的栈段来处理所有的局部变量。当你从过程返回时，栈会被弹出。我要给你展示的是栈增长的典型模式。所以栈指针从 FFFF 开始，当你压入东西时，栈会增长。

它是向下增长的。当你从栈中弹出数据时，它会向上增长。好的，堆中有什么呢？嗯，堆是动态分配的内存。好的，那么它是如何分配的呢？嗯，通常是通过调用像 malloc 这样的函数，那么它有多大呢？嗯，这取决于你进行了多少分配。你知道，你调用 malloc 的次数有多少。

最终将调用 S 中断和底层系统。但你知道，堆中有多少内容取决于你请求了多少。然后中间有个空洞，好的。这个空洞在接下来的几讲中会变得有些有趣，因为你知道，当你尝试在栈上压入某些内容，而底层没有物理内存时，会发生什么。

这将导致页面错误。操作系统可以做几件事情，例如它可以增加更多内存，或者它可能会引发段错误。所以我们也会详细讨论这个问题。好的，问题来了？好问题。什么是栈溢出？

那么，栈溢出就是当你分配了过多的栈空间，因为你不断地压栈，直到操作系统决定不能再分配更多空间时，你就会遇到栈溢出的情况。如果操作系统正确处理了它，最糟糕的结果就是你的程序或进程会被终止。

可能不太幸运的情况是，如果栈扩展到堆，并且没有适当的保护，那么你就会悄悄覆盖掉一些数据。而更糟糕的是，发生这种情况时，你并不会收到错误提示。你只是会遇到一些非常奇怪的行为。好的，我们稍后会再次讨论这些概念。好的，堆可以。

会发生溢出吗？是的。那么让我们来谈谈之前讨论的线程问题。非常简单，多道程序设计就是我们在做的事情。好的。所有虚拟 CPU 都共享同一块内存、IO 设备等，它们都在同一地址空间内。品红色线程可以覆盖或者查看蓝色和青色线程的值。好的。因此，每个线程都不是独立的。

保护了其他部分。它能覆盖操作系统吗？这是个好问题。在很多操作系统中不能，但在最早期的操作系统中确实能。好的。那么这个场景不可用的原因是线程可能会相互覆盖，或者覆盖操作系统吗？嗯，这种方式在计算机早期没有保护的情况下被使用过。它仍然常常。

在嵌入式应用中使用。早期的一些 Mac OS 版本，或者 Windows 3.1、Windows 95 实际上采用了这种简单的多路复用保护方式，根本没有任何保护。因此，线程有可能覆盖包含操作系统的地址空间的某些部分。这是有风险的。好的。正如我之前提到的。

早些时候提到的，操作系统如何确保重新获得控制？嗯，如果没有保护，用户线程可能会覆盖本该执行这些操作的代码。结果就是，计时器中断可能会触发，但却发生了错误，无法重新获得控制。所以这是一个问题。简单的多路复用。

没有保护，但是操作系统必须保护自己。你可以想象，有很多原因需要这样做。比如可靠性。如果我们妥协操作系统，通常会导致它崩溃，至少是崩溃，安全性方面，如果限制线程的操作范围，它们就不能从其他线程中窃取信息。

隐私方面，可能一个正在运行的程序偷取另一个程序中的密钥。公平性方面，每个线程可能会限制自己合适的系统资源份额，覆盖操作系统来限制其他系统资源的份额，并且基本上永远不放弃 CPU。所以所有这些都意味着操作系统需要一些东西。

比简单的多路复用要好。好的。那么它还必须保护用户程序不互相干扰，确保不同的程序不能相互覆盖。那硬件能做什么呢？嗯，它可以开始添加一些硬件。好的，我们可以开始增加一些硬件来防止隐私和安全的侵犯。这里有一个特别简单的例子，我们称之为指向最低地址的基址。

我们将称之为基址和边界。这个地址空间的概念是，我展示给你的是所有 D RAM 物理 D RAM 选项的集合。它是操作系统，这里是灰色部分。还有一个我们希望在受保护模式下运行的特定线程，位于这里的黄色部分。基址和边界的概念是存在一个特殊寄存器。

顺便说一下，我从之前的内容倒过来了，所以较小的地址在上面。但这个基址指向的是黄色部分可以访问的最低地址。边界指向的是黄色部分可以访问的最高地址。结果是，如果我们能够以某种方式防止那些本应是独立进程的事情发生。

防止用户模式下的程序访问灰色区域，那么我们可以防止黄色区域覆盖操作系统。因此，例如，这里有一个示例，其中程序地址指向数据。如果我们让CPU尝试访问比如说地址1010，我们要做的是问自己，它是否大于基址？

如果你注意到1010大于1010，那么答案是肯定的。好的，它是否小于界限？

答案是肯定的，在这种情况下我们继续允许访问。因此，仅通过这两个寄存器和一些硬件比较机制，这些机制会引发异常，我们就能实现保护。好的，非常简单的保护机制——基址和界限。好的，那么如果你注意到磁盘上的这个程序的简单版本。

事实上，它认为代码的地址是零，堆栈的地址是较高的地址，静态数据的地址在文件系统中是0010。因此，当我们将其加载到内存中时，我们需要动态转换所有地址，将它们映射到新的位置。请注意，代码在这里的地址全是零，但是。

现在它全是零。所以有一个动态加载器，它会将代码中的所有地址转换为与基址一致的地址（即全零）。如果我们这样做，那么就可以使用基址和界限来允许执行。所以你看这里。那么，操作系统如何在地址空间中存在呢？

操作系统本身提供地址空间的抽象。好吧，我刚刚向你展示了这里。它是保护的魔法。所以这里操作系统在运行。所有的代码都在这里，灰色的区域。我在用户模式下时，防止了任何操作。注意，我还没有进入用户模式。但是当我进入用户模式时，基址和界限寄存器就会。

将会设置并强制执行。因此，用户代码将无法破坏操作系统。所以它得到了保护。因此，正如在聊天中提到的，这些基址和界限寄存器是动态设置的。每次线程开始执行时，都会进行设置。所以当我们决定一个线程准备好执行时，我们会设置基址和界限寄存器。

所以这保护了操作系统并隔离了程序，需要一个重定位加载器，然而，这个加载器能够将磁盘上的地址转换为内存中的地址。顺便说一下，这会在稍后讲解时变得有意义。硬件路径中没有特别的地方，比如加法或其他什么。对于那些上过硬件课程的人来说。

当我们尝试通过这种特定机制从堆中读取时，不会引入任何延迟，因为地址会直接发送到内存。好的。我们将有一种更好的保护类型，这将增加一些硬件延迟。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_35.png)

那么，什么是重定位？你可能还记得在61C课上学过这个。这里是一个汇编语言指令跳转和链接的例子，它被翻译成二进制，其中操作码000 000 011在上方，打印定义的地址被放入二进制指令的下半部分。当我们加载它，编译它时。

它在磁盘上的样子是这样的，x被二进制替换掉。但是当我们最终加载它时，那时它需要被正确地转换和链接到它在内存中的正确位置。所以在那个时刻，我们做的是所谓的重定位，我们将所有这些地址重新定位，无论是在加载时还是在。

我们进行链接。那是两种可能性。好的。并且在磁盘上的可执行文件中的地址，就好像所有东西都加载到内存中的000位置。当我们进行链接或加载到内存时，那个时刻我们会转换到它的新位置。好的。让我在接下来的几张幻灯片中展示给你。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_37.png)

通过将一些复杂性放入硬件中，使软件稍微简单一些。如果你注意到，回想一下我之前展示的内容，我在这里做的唯一一件事就是添加了一个加法器。好的。这是一个硬件加法器。它的意思是，当程序的地址从CPU输出时，它们会经过

在它们访问DRAM之前加一个加法器。好的。如果你考虑这个问题，我会设置一个基地址，仍然是10000。但是现在，当CPU尝试访问地址0010000时，我们会把基地址加到它上面，这样我们就访问到了1010000。突然间，我们就将CPU的视图转换成了物理视图。所以这实际上是一种虚拟内存。好的，里面我们做了转换。

在运行时。好的。这将给我们一种记忆的错觉。但它并不会是一个很好的错觉，尤其是在无限错觉的情况下，不过它确实给了我们一种错觉。好的，希望大家都能理解。那么现在，二进制文件在磁盘上的表现与在内存中的表现是一样的。我们只是把它从磁盘加载到内存中。

然后我们可以像它位于零地址一样执行它，因为它是程序，或者说CPU认为它位于零地址。我们通过在其真实位置上加上基地址，动态地访问它。好的。这是硬件重定位，而不是软件中的情况，软件需要更改其位置。那么程序能接触到操作系统吗？答案是否定的，因为。

它必须提供一个负地址，这个地址会低于黄色区域，而它无法做到这一点。或者它必须提供一个如此大的地址，以至于会发生地址回绕。它也不能这么做，因为它被限制在基地址和绑定区之间。好的。所以这仍然是在保护操作系统，位于这小段黄色物理内存中。

它能接触到其他程序吗？答案是不能，因为如果你想象一下这里的绿色区域，CPU只能使用那些当加到基址后，落在100到1100之间的地址，其他的无法访问。所以所有其他的程序和操作系统都是被保护的。现在是一个好问题。

这里的聊天中提到的是：这是不是硬件延迟？是的。但在现代CMOS类型中，这个额外的加法器几乎是不可察觉的。还有许多其他东西在里面。所以这个额外的小硬件延迟不会以任何合理的方式改变周期时间。如果它改变了周期时间，你也希望能减慢周期时间，这样做的好处是巨大的。好的。

因为这意味着同样的代码可以从磁盘加载到内存，并直接运行。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_39.png)

执行了。顺便说一下，我们不必担心这些硬件延迟问题。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_41.png)

在这门课中我们会偶尔提到它们。更多的是在152课程中讲解。现在。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_43.png)

x86是一种非常有趣的架构，具有大量所谓的**段**。好的。并且使用段寄存器来定义它们。例如，代码段基本上有一个指向这些块开始的指针，并且有一个链接。所以它非常像基址和界限，然而我们不止有一个基址和界限，而是有多个。

不同的功能，如代码、数据、栈等等。好的。我们将会得到更多。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_45.png)

随着我们继续深入，分段的概念会更清晰。但要记住的是，那里有许多基址。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_47.png)

每个基址都有一种它允许的功能。好的。现在稍微有点不同的是。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_49.png)

与我在这里介绍的简单方法不同，这是一个完全通用的基于地址的转换方法。在这里，地址从处理器中输出，并进行转换。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_51.png)

转换为物理地址。顺便提一下，你可以说它发生在这里，对吗？从这里出来。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_53.png)

处理器将被转换为物理地址。但我们更为通用，而在此情况下。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_55.png)

在前一个例子中，它们是从基址到界限线性排列的。在这里，我们可以在其中放入一个任意的转换器，所以虚拟地址可以在物理内存的任何地方。因此，这将引导我们进入另一个61C的概念，你简要了解过，那就是**分页虚拟地址空间**。在分页的情况下，这个转换器是一个非常特定的。

它会移动某些内容，但它是以页面为单位进行的。这里有一个非常好的问题，我觉得刚刚在聊天中出现了，就是 RISC 5 和 x86 中的寄存器是同一物理寄存器，只是被分配给了不同的功能。你不能真的那样理解。x86 CPU 和 RISC 5 CPU。

完全不同。没有简单的方式可以让你翻个开关，一个变成另一个。所以它们都有寄存器，都有类似的功能，但它们在实现上非常不同，不是说 x86 的那些寄存器通过翻开关就变成了 RISC 5 中的寄存器。这就是页面虚拟地址空间的情况。

回到这个问题。问题是，这是不是软件？但不是，它是硬件翻译。软件负责设置翻译，但实际翻译是由硬件完成的。好的，所有页面的大小是相同的，因此很容易将每个页面放入内存中。硬件通过页表翻译地址。好的，每个页面都有一个基地址和界限，但是它们。

大小都是相同的。好的，特殊的硬件寄存器指向这个页面。我们将把内存当作页面大小的框架来处理。大量的页面大小框架。好的，这是另一个快速的 CS 161 C 复习。这里的想法是，我刚才提到的翻译器其实叫做页表。接下来会发生的是，地址将会。

我们将从处理器中取出该地址，然后在页表中查找该地址在物理内存中的位置。所以对于一个给定的地址，会有一个框架地址，这里是蓝色的，它指向 DRAM 中的某个特定页面，我们基本上会将虚拟地址分为页面编号和偏移量。而这个页面编号。

在翻译成蓝色后，我们再取偏移量，它告诉我们到蓝色页面的偏移量。好的，希望这能让大家有所启发。但请注意，例如这里的地址按虚拟地址空间中的顺序排列。一旦翻译成物理顺序，它们的顺序就不一定是一样的。

所以，蓝色的框架可以在物理内存中，而上面的绿色框架则在虚拟空间中。处理器在虚拟空间中运行时认为所有内容都整齐有序，但实际上页表可能会把它们打乱在内存中，结果证明，这对于管理非常有帮助。好吧，这实际上是一个非常好的事情。

好的，指令在虚拟地址上操作。指令地址是虚拟的，加载和存储的数据地址也是虚拟的。它们通过页表转换为物理地址，物理地址就是在 DRAM 中查找的地址。好的，任何一个地址空间的页面都可以放在内存中的任何位置。所以这是一个。

我刚才给你展示的基址和界限的替代方案。好的。问题是，局部性会受到任何影响吗？让我们稍微停一下这个问题，因为甚至对“局部性”一词的定义都有问题。请记住，对于我们讨论的这些处理器，处理器在这里与在这里访问时。

除非内存没有加载，否则速度没有差异。好的。现在我们不会讨论两级虚拟内存的问题，请稍后再问。很好，你知道要问这个问题，但我们会在稍后处理它。好的。还有一个特殊的寄存器叫做页表地址，它指向页表的基址。请注意，什么是。

很酷的是，如果不同的进程有不同的地址空间，那么当我准备从品红色进程切换到青色进程时，我所需要做的就是，除了加载和保存寄存器外，我只需要更改页表的基地址。突然间，我们刚刚交换进来的新线程就有了一套完全不同的物理。

可用的地址空间。好的。这将引出进程的第三个概念，那就是具有受限权限的执行环境。好的。这里有一个受保护的地址空间，里面有一个或多个线程，它拥有一些内存，所以这就是它拥有的地址空间，文件描述符、文件系统上下文等等。它将封装一个或。

共享进程资源的线程更多。好的。所以，当一个程序加载到内存并开始执行时，它就是一个进程。好的。复杂的应用程序实际上可以将自己分叉成多个进程，这是一种可能性。好的。这将有多个这样的东西，所有这些东西都代表进程在工作，每个都有自己的受保护的地址空间。

此外，一个受保护的地址空间可以包含一个或多个线程。好的。那么，为什么进程有用呢？它们彼此之间是相互保护的。所以，回想一下我在讲座开始时展示的幻灯片。棕色和绿色。棕色进程被绿色进程保护。为什么？因为它们各自有自己的地址空间，这要么通过基址和界限来实现，要么更可能是。

在现代处理器中，通过其页表来实现。它们每个都有页表存在内存中，因此当我们从棕色切换到绿色并再切换回来时，我们除了加载寄存器外，还会改变页表地址。结果，当我们从棕色切换到绿色并再切换回来时，它们完全被保护在各自的地址空间中，除非我们决定允许它们，否则它们无法互相干扰。

好的，操作系统构建页面表吗？是的。好的，页面表是一个长期存在的东西，从进程创建到进程终止都存在。现在我们可以说，页面表绝对存在于操作系统中。好的，你们会知道，当你再次问我这个问题时，我可能会给出不同的答案。

但可能要等一个月左右。好的，操作系统肯定控制着页面表。如果你注意到，为什么我们需要进程呢？因为进程彼此之间是被保护的，操作系统也被保护不受它们的影响。好的，为什么呢？好吧，回到这个问题。如果内存中的唯一部分是我可以访问的页面表中的部分，那么如果没有指针指向。

页面表中，运行在该进程中的处理器无法通过页面表访问到本应仅操作系统可访问的内存区域。好的，操作系统之所以受到保护，是因为虚拟进程中没有任何可以访问操作系统的指针。好的，另一个好问题是，进程中的线程是否受到彼此保护？

不，线程之间没有保护，这是一个特性。好的，进程内部的线程彼此之间没有保护，这是好的，因为它们共享并发性和内存，以便快速完成某些任务。所以它们之间没有保护，但这是有意为之。我们之所以不认为这是安全漏洞，是因为我们假设你已经编写了程序以。

工作正常，你编写了程序以使用这些线程，并让这些线程彼此协作。正确，因此它们彼此之间没有保护，但它们被保护免受其他人线程的干扰。好的。现在这是我刚刚提到的单线程和多线程进程的视图。例如，单线程进程中有代码、数据和文件。

寄存器、栈和单一控制线程。因此，当该进程进入休眠时，只有一个线程需要被休眠。多线程进程有很多线程。好的，每个线程都有自己的寄存器和栈。这是使它独特地成为线程的部分，但它们也有共享的代码和数据。所以典型的多线程进程有一大块代码，线程们在这段代码中四处运行，但这些代码都属于同一个链接映像。好的，所以线程封装了并发性方面。好的。

它们是活跃的组成部分，是过程的执行组件。地址空间封装了保护机制。它是被动组件，或者说是盒子。好吧，我喜欢把地址空间看作是我们把这些东西塞进去的盒子。线程们在那个盒子里忙着四处跑。好的，那个盒子提供了保护。

防止恶意深度程序崩溃系统。好问题是堆是否被不同的线程共享？是的。通常会有一个堆。好的，代码、数据、文件、堆——都是一个堆。我们需要多个堆栈的原因是，因为每个线程都在忙于运行自己的递归例程等等。所以它需要自己的堆栈。

当然，它有自己的寄存器，因为它在执行实际的操作。好的。那么，多个堆栈是如何设置的呢？其实，这部分内容与进程分配有关，它会为你提供至少一个寄存器和堆栈。然后，当你创建新线程时，会有更多的堆栈。

所有这些通常是在用户层完成的，或者可以在内核中完成。我们将讨论这两者作为选择。好的，我们将逐步了解如何构建一个进程并使其运行。所以，保护和隔离是一起重要的。那么，为什么我们需要进程呢？只是提醒一下，这是为了可靠性。

因为错误只能覆盖进程所在的内存区域。所以这是好的，安全和隐私。恶意程序受到限制的进程不能查看其他进程的数据。好的，在某种程度上是公平的。所以通过将线程限制在一个进程中，并且这些进程受到操作系统的保护和管理，意味着操作系统。

系统可以确保没有一个进程能窃取所有资源并阻止其他进程运行。好的。所以，操作系统中的进程保护环境和适当的调度使我们能够构建现代操作系统，在其中我们可以保证即使是恶意进程也不能阻止其他进程的运行，或防止或窃取信息。好的，现在这个。

使这一切工作的机制，我们已经向你展示了地址转换的概念。但如果你仔细想想，为什么我们不能让进程自行更改页表指针呢？好的，有人能弄明白为什么吗？那么，为什么我们不能让正在运行的进程更改它自己的页表呢？Rizal，我会很快回答你的问题。有人能想出为什么我们。

为什么不能让进程更改自己的页表？是的，如果它能更改自己的页表，那就不受保护，对吧？它可能将页表指向操作系统或其他进程。好的，显然，在进程内部运行时，它不能触碰页表。好的，这意味着我们必须有一些硬件，它具有我之前提到的两种模式，确保。

当你以进程的形式运行时，你不能随意修改页表，只有进入操作系统时才能修改页表，也就是经过审核且已知无害的内核代码，至少我们希望它是这样的。好的，现在我想简要回答一个问题：在单核中，多线程有什么优势？

答案是并发。好的。所以这并不是关于从并行性中获取性能，而是允许你有许多事情在开始、停止和等待事件。好的。随着你向前推进，你将会变得更加精通。即使只有一个单核，线程并发也有很大的用途。

这不仅仅是为了让事情更快，而是为了处理这样一个事实：你想要在一个重要的方式上重叠计算和输入输出。好的。而且还要确保，当一个线程在等待时，不会阻塞其他所有线程。所以今天的第四个概念，我们会很快结束这一部分。

硬件必须提供至少两种模式，内核模式、用户模式或监控模式。好的。在用户模式下有某些操作是被禁止的。好的。比如更改页表指针等。而且在用户模式下，必须有一些严格控制的过渡，不能进行这些操作。用户模式到内核模式的过渡必须非常小心地控制。

在这种情况下，系统调用、中断、异常，都是从用户模式到内核模式的过渡的例子，这种过渡是经过严格控制的，它不仅仅是进入内核模式，还确保只有经过审核并属于操作系统的代码才能运行。

所以显然我们不能允许用户代码直接进入内核模式，因为那样它就可以执行任何它想执行的操作。因此，我们必须控制进入内核模式的过渡。我们今天已经提到过的一个例子就是系统调用的概念。

用户进程正在用户模式下运行。然后它说，嘿，我需要从磁盘读取数据。于是它会进行系统调用，这将做两件事。第一，它会进入一个非常明确定义的代码段，这段代码代表着读取系统调用。第二，这个过渡也会将过渡到内核模式。

在这里我展示的是，其中有一个单独的位，用户模式位，它是处理器中的一个寄存器。我们在这里运行时，用户模式位被设置为1。但是当我们执行系统调用时，我们将过渡到用户模式，并将该位设置为0。于是，现在只有内核代码在运行，并且具有很多特权。

它可以做任何它需要做的事情，包括可能改变页表。然后当它返回到用户代码时，就像从函数调用返回一样，但这是一个特殊的函数调用，我们将返回到用户模式，回到用户进程内。好的。所以例如，我们现在可以开始讨论一个。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_57.png)

如此图所示。这是典型的单元系统结构。顺便说一句，我有点晚了。如果你们能再等五分钟，我想确保我们能继续进行几件事。好的。但如果你看，我们可以想象东西在用户模式下运行。这些是应用程序和标准库的各个部分，全部运行在这里，没有特殊权限。

它们可以由你构建，或者由你链接，或者由其他用户构建，按任何你想要的方式。内核模式则是以较高优先级运行的内容。这代表了必须完美执行的任务。好的，必须以一种没有漏洞、不会让人们发生安全违规的方式来完成。所以这很重要。好的。所以我们需要确保这些代码都是完全正确的。好的。

如果现在看看硬件，好的，那是最低的层次。通常情况下，只有内核模式的程序才能真正访问硬件。这部分是因为它们设置了内核模式标志。硬件只会与内核模式标志被设置时的东西进行通信。好的。所以我们可以开始看看这个结构。

典型系统是这样的。好的。那么现在，我们来看一下我们得到的东西。我们得到了。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_59.png)

硬件就是这堵砖墙。这是我们的软件。所以我们有核心部分，运行在经过严格审查的内核模式下。用户模式则是你或者普通用户生产的所有内容。发生的情况是，内核会执行一个进程。你们在做Shell时会学到如何做到这一点。它执行这个进程，将其从磁盘加载到内存中。

然后它会在该文件的启动例程中以用户模式启动。好的，这就是通常的主流程。好的。它会运行一段时间。然后，当它完成时，进程会退出。然后该进程会被关闭，我们将回到内核模式。好的。现在，在这个过程中，从开始到结束，可能会发生一些事情，比如说，嗯。

我们可以进行系统调用进入内核模式，然后在完成后返回用户模式。或者我们可以有一个中断。所以中断是一种来自外部的事件，比如定时器，它将会从用户模式强制切换到内核模式，在那里会发生一些事情。然后，最终可能会访问硬件，例如。

然后在中断完成后最终返回。所以如果网络数据包进入，等等，可能会发生这种情况。好的。最后，异常可能是你尝试除以零，这种情况下我们可能会进入内核。如果它是不可恢复的错误，比如除以零，那么我们可能会终止该进程。

如果是不同类型的异常，比如页错误，我们稍后会学习很多关于它的内容。那么它会返回。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_61.png)

正确执行。好吧。所以现代系统中有不同的保护层。例如，操作系统之上可能会有更高权限的东西，比如虚拟机监控器。好吧。这些是额外的保护层，我们可以在其上运行操作系统的虚拟机，虚拟机使我们能够在它们之上运行操作系统。

操作系统认为它完全控制了机器。但虚拟机监控器正在进行多路复用。其底层是这样的。好吧。而这就是你现在正在操作的部分，你正在进行设置。设置你的虚拟机。好吧。那么，操作系统默认是在用户模式下运行吗？所以，再次问一下。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_63.png)

这是一个很好的问题，适合接近结尾。如果你看这一点，我们有一些内核模式的东西，这些可能是操作系统，它们在内核模式下运行。因此，这里有接触硬件并执行高度特权操作的代码。然后我们有用户模式，它是你的用户程序，这些程序并不执行特殊的代码。

那么关于操作系统是否在用户模式下运行的一个答案是，操作系统实际上总是运行在内核模式下。好吧。虽然它不一定总是占用 CPU 的周期，因为它可能处于这样的实例中：在这里，我们处于用户模式。如果只有一个 CPU，那么操作系统根本就不运行，对吧。

不在运行。我们一旦有了系统进入内核，系统就会转换到内核模式。此时用户模式的代码不再运行，内核模式的代码开始运行，运行意味着占用了 CPU。好吧。希望这有帮助。我们后面会继续讲这个内容。所以我想。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_65.png)

我给你最后一个例子。好吧，我承诺五分钟。那么我们来看看这个。例如，让我来展示一下。我们使用基本地址和边界。这里是操作系统。这里是两个进程。我们将构建一个进程的幻象。请注意，当我们运行操作系统时，我们处于系统模式。因此，这个开关是打开的。

所以这不是一个用户模式位。这是系统模式位。程序计数器指向操作系统。栈指针指向栈，操作系统内核模式正在运行。现在我们要做的是，想要开始运行其他内容，比如黄色代码。

所以我们即将从中断返回。为了做到这一点，我们将指针设置到黄色代码所在的特殊寄存器中，这样当我们执行返回到用户模式时，程序计数器（PC）就会切换到黄色代码。基本地址和边界将会被强制执行，因为系统模式为零。所以只有在我们处于系统模式零或者内核模式时。

模式，抱歉，我是说用户模式时，基本地址和边界会被使用，而当我们处于内核模式时，内核可以自由地做任何它想做的事情。好吧。好吧，下次我将讨论。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_67.png)

![](img/80deaa59936768fb1fcdc3b7bf8785ea_68.png)

不同类型的内核模式切换。总之，今天我们讨论了四个基本的操作系统概念。线程，它是一个虚拟化的 CPU。它是一个执行上下文，完全描述了程序的状态，包括程序计数器、寄存器、执行标志和堆栈。并且它可以进行多路复用。因此，线程的数量可以超过实际 CPU 或核心的数量。地址空间有或没有。

翻译是一个受保护的框架。它是程序可访问的所有内存地址的集合，供读写使用。例如，对于一个 32 位的 CPU，它有四十亿个地址值。好了，它可能与物理机器不同。这就是我们开始进行地址转换的原因。我们讨论了进程，它将线程和地址空间结合成一个有用的概念。

这是一个受保护的地址空间，包含一个或多个线程。然后我们还讨论了硬件需要有两种模式：系统模式和用户模式，以便我们可以强制执行某些硬件不能被用户访问，以确保我们的完全保护。好了，我已经讲完了，谢谢大家的耐心听讲。

我希望大家晚上过得愉快，保重身体。

![](img/80deaa59936768fb1fcdc3b7bf8785ea_70.png)
