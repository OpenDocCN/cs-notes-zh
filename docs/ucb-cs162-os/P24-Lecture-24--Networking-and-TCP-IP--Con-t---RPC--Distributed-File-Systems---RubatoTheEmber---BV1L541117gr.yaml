- en: P24：Lecture 24： Networking and TCP IP (Con't), RPC, Distributed File Systems
    - RubatoTheEmber - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P24：第24讲：网络与TCP/IP（续），RPC，分布式文件系统 - RubatoTheEmber - BV1L541117gr
- en: All right， so let's get started。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们开始吧。
- en: '![](img/193c262c45839f75eb2f216af3003afc_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_1.png)'
- en: So we did not intend to be remote again this semester， but here we are remote
    once again。 hopefully just for today。 So this is lecture 24 and we have a lot
    to go through。 We're gonna continue talking about distributed consensus making。
    Then we're gonna get into networking and TCP/IP， and time permitting。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们原本并不打算本学期再次远程授课，但现在我们又一次远程授课了，希望今天仅此一次。这是第24讲，我们有很多内容要讲。接下来我们将继续讨论分布式共识问题，然后将进入网络与TCP/IP的内容，如果时间允许的话。
- en: we'll get into our remote procedure call， and distributed file systems。 So if
    you remember from last time， we talked about distributed consensus making。 where
    we have a consensus problem。 So nodes propose a value and we want。 even in the
    presence of crashes and failures of other nodes。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论远程过程调用（RPC）和分布式文件系统。所以如果你还记得上次，我们讨论了分布式共识问题。在那里，我们有一个共识问题。节点提出一个值，我们希望即使在其他节点崩溃或故障的情况下，仍然能够达成一致。
- en: to be able to reach a decision across all of the nodes。 and have that be the
    same decision at all of the nodes。 So examples are choosing between true and false，
    or choosing between commit and abort。 Now it's very important that we make our
    results durable。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 需要能够在所有节点之间达成一致决策，并确保所有节点的决策相同。举个例子，就是在选择真假之间，或者选择提交或中止之间做决定。现在非常重要的是，我们要确保我们的结果是持久的。
- en: So we're gonna use a log or other form of stable storage。 to ensure that the
    decision persists once it's made。 Okay， and remember also we talked about。 the
    two phase commit protocol， where we have a persistent stable log on each node。
    and that's where nodes track and record， whether a commit has occurred or not。
    There are two phases。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用日志或其他形式的稳定存储，以确保一旦做出决策，它就能持久化。好的，另外，记得我们还讨论过两阶段提交协议，其中每个节点都有一个持久的稳定日志，节点在其中跟踪并记录提交是否已发生。这个过程有两个阶段。
- en: that's why it's called two phase commit， which starts with the prepare phase。
    where the global coordinator requests， that all of the participants promise to
    commit。 or decide to roll back the transaction。 So the participants each record
    their decision。 their promise in the log and acknowledge that， to the coordinator
    and if anyone votes to abort。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么它被称为两阶段提交，首先是准备阶段，在这个阶段，全球协调者要求所有参与者承诺提交，或者决定回滚事务。所以参与者每个人都记录下他们的决定，他们的承诺并在日志中确认这一点，随后将确认发送给协调者。如果有人投票决定中止。
- en: then the coordinator is going to write abort in its log。 and tell everyone to
    abort and record abort in their log。 During the commit phase。 if everyone has
    agreed， that they are prepared to commit。 then the coordinator writes commit in
    its log。 When it writes committed in its log。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，协调者将在其日志中写入中止，并告诉每个人中止并在他们的日志中记录中止。在提交阶段，如果每个人都同意准备提交，那么协调者会在其日志中写入提交。当它在日志中写入提交时。
- en: that's when the transaction is considered committed。 and no matter what happens
    with machines going up and down。 eventually everybody will commit their transactions。
    It then asks all the nodes to commit。 and respond with an acknowledgement， after
    it receives and acknowledge all of the acknowledgments。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当事务被认为已提交时。无论机器如何启动和停止，最终所有节点都会提交它们的事务。然后，它要求所有节点提交并在收到所有确认后进行确认。
- en: it writes got commit to the log。 So the log here is used to guarantee that our
    decision， persists。 that it's a decision to commit， or it's a decision to abort
    the transaction。 So some discussion。 Now， why is distributed decision making important，
    and desirable because of faults that can happen？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它写入日志以提交。因此，日志在这里用于保证我们的决策得以持久化。它是一个提交决策，或者是一个中止事务的决策。接下来是一些讨论。那么，为什么分布式决策制定如此重要且可取呢？因为可能会发生故障。
- en: We want fault tolerance。 We want a grouping machines to be able to come， to
    a decision。 even if one or more of those happens， to fail during that process。
    So this simple failure mode is called， we're assuming here a simple failure mode。
    that's called fail stop。 So if a machine has problems， it stops， it crashes。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要容错能力。我们希望即使在某些机器出现故障的情况下，分组机器仍然能够达成一致决策。所以这个简单的故障模式被称为假设一个简单的故障模式，叫做停止故障（fail
    stop）。如果机器出现问题，它就会停止，崩溃。
- en: it reboots and then recovers。 There are other modes that we'll talk about。 in
    just a moment which are more Byzantine， in terms of the way that they might fail。
    Now after a decision is made， we recorded in multiple places that again ensures。
    that it persists after that decision is made。 Now， some people have asked， why
    is Too Faced commit。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它重启并恢复。我们会谈到其他模式，这些模式在失败时更具拜占庭特性。现在，做出决策后，我们会在多个地方记录，这再次确保在做出决策后，它会持久化。现在，一些人问，为什么
    Too Faced 提交不受将军悖论的影响？
- en: not subject to the same paradox as the general's paradox？ Well。 the difference
    here is that Too Faced commit， is about eventually coming to the same decision。
    It's not necessarily true that they all come， to the same decision at the same
    time。 It simply says that they will eventually all come。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不是说它们在同一时刻做出相同的决定，而是它最终会达到相同的决策。它并不一定要求所有节点在同一时间做出相同的决定，它只是说它们最终都会做出相同的决策。
- en: to that same decision because machines might fail， and have to reboot。 And so
    we want to make sure that again， eventually we reach that decision。 Okay。 second
    thing I want to talk about， is that there is a problem with Too Faced commit。
    and there is a reason why Too Faced commit， can be troublesome to actually use
    and practice。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为机器可能会失败并需要重启，所以我们希望确保最终我们能做出决定。好的，我接下来想谈谈的是，Too Faced 提交存在一个问题，实际上它在实践中可能很麻烦，这也是为什么
    Too Faced 提交有时候不太容易使用。
- en: and that is blocking。 So let's say， so one machine can be stalled。 that is prevented
    from doing any useful work， until another site recovers。 So site B writes prepared
    to commit， and records that in its log。 and then sends a yes vote to the coordinator，
    which we'll say is site A and then crashes。 Well。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是阻塞。因此，假设一台机器可能会被停滞，不能做任何有用的工作，直到另一个站点恢复。于是站点 B 写入“准备提交”并将其记录在日志中，然后向协调器发送“是”票，我们假设协调器是站点
    A，然后它崩溃了。嗯。
- en: eventually it'll come back up。 In the meantime， let's say site A also crashes。
    So now site B is coming back up and it checks its log， and it says， oh， I voted
    yes。 And so it's going to send a message to site A， saying， well， what happened？
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最终它会恢复。在此期间，假设站点 A 也崩溃。那么现在站点 B 正在恢复，并检查它的日志，发现它已经投了“是”。于是它将向站点 A 发送消息，问：“发生了什么？”
- en: Did that transaction commit or abort？ Now at this point， site B cannot unilaterally
    decide。 I'm going to abort， right？ Because it already said it was prepared to
    commit。 and that update might have actually committed， in which case it then has
    to go through。 with its promise to commit。 So it's blocked until A comes back
    up and responds。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事务是提交还是中止了？现在，在这个时候，站点 B 不能单方面决定：“我要中止。”对吧？因为它已经表示准备提交，并且该更新可能已经提交，这时它就必须履行它的提交承诺。所以它会被阻塞，直到站点
    A 恢复并作出回应。
- en: The coordinator comes back up and says， what happened to the transaction。 Now
    the reason why this is a problem， is because that block site B holds resources，
    right？
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 协调器恢复并询问：“事务发生了什么？” 这之所以成为问题，是因为阻塞的站点 B 持有资源，对吧？
- en: So it might be holding locks on updated items。 It might have pages that are
    pinned in memory。 and it can't release any of those resources， until it knows
    the fate of the update。 And so if it takes the global coordinator， a few hours
    to come back， well， those resources are held。 and that could hold up progress
    on site B。 Okay， so there are some alternatives to two phase commit。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它可能会持有已更新项目的锁。它可能会有一些页面在内存中被固定，并且在得知更新的结果之前，它无法释放任何这些资源。因此，如果全球协调器恢复需要几个小时，那么这些资源就会被占用，这可能会阻碍站点
    B 的进展。好的，所以有一些替代方案可以取代两阶段提交。
- en: There's an alternative called three phase commit， which adds in another phase。
    That's why it's called three phase commit， and that allows nodes to fail or block。
    and yet we can still make progress。 Now it's a much more complex algorithm。 and
    it's not widely used in practice。 Paxos is an algorithm for a distributed commit。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种叫做三阶段提交（three phase commit）的替代方案，它增加了一个阶段。这就是为什么它被称为三阶段提交，它允许节点失败或阻塞，但我们仍然可以继续推进。现在，它是一个更加复杂的算法，而且在实际中并不广泛使用。Paxos
    是一个分布式提交的算法。
- en: that was developed and is used by Google， and it doesn't have the two phase
    commit blocking problem。 It was developed by Leslie Lamport。 You may remember
    him from last time。 He's the person who said that distributed computing， is when
    a machine crashes and prevents me。 from getting my work done， and I have no idea
    what that machine is。 And so with Paxos。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由Google开发并使用的，并且没有两阶段提交的阻塞问题。它由莱斯利·兰波特开发。你可能还记得他，上一回我们提到过他。他是那个说分布式计算就是当一台机器崩溃，阻止我完成工作，而我不知道是哪台机器的人。所以，使用Paxos。
- en: there's no fixed leader。 You choose a leader on the fly。 And so that makes it
    much easier to deal with， a failure occurring。 but it's a very complex algorithm，
    and so it's not as widely used as we'd like to see it be used。 There's an alternative
    that was developed later， called Raft developed by Professor John Austerhat。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有固定的领导者。你会临时选择一个领导者。因此，这使得处理故障变得更容易，但这是一个非常复杂的算法，所以它并不像我们希望的那样广泛使用。后来有一个替代方案被开发出来，叫做Raft，它由斯坦福大学的约翰·奥斯特哈特教授开发。
- en: at Stanford and it's much simpler to describe， the complete protocol and so
    some people。 have started using Raft as an alternative， to Paxos or two phase
    commit。 Now。 up until now we've assumed that failures that occur， occur because
    of normal things that happen。 like cosmic rays or machine crashes or hardware
    failures， and other sorts of things。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它的协议描述起来简单得多，因此有些人已经开始将Raft作为Paxos或两阶段提交的替代方案。现在，直到目前为止，我们假设发生的故障是因为正常的事情，比如宇宙射线、机器崩溃或硬件故障等。
- en: What happens when failures are caused， because nodes act maliciously？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当故障是由于节点恶意行为造成时，会发生什么？
- en: So malicious means that a node is attempting， to compromise the decision making
    process。 So if everyone is saying do， yes， the malicious node says， for example，
    do no。 So we need to use a more hardened decision making process， and like Byzantine
    agreement。 which we're going to look， at in just a moment or blockchains。 And
    unfortunately。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意意味着一个节点试图破坏决策过程。所以如果大家都在说“是”，恶意节点可能会说“不是”。因此，我们需要使用更为强大的决策过程，比如拜占庭协议，我们稍后会讨论，或者使用区块链。不幸的是。
- en: we don't have time， to look at blockchains today。 So the assumption here is
    that you have an adversary。 that's trying to basically do the worst case， damaged
    your system。 So if you're just dealing with normal faults， this takes it， this
    will also help you。 because sometimes systems will fail， in truly bizarre ways。
    They start acting inconsistent。 Well。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天没有时间讨论区块链。因此，这里假设你有一个对手，基本上是在尽最大努力损害你的系统。所以，如果你只是处理正常故障，这也能有所帮助，因为有时系统会以非常奇怪的方式失败。它们开始表现得不一致。那么。
- en: that to a certain extent could look like a malicious， actor， but it's not。 It's
    just a node that's misbehaving， and performing incorrectly。 The nice thing about
    the Byzantine algorithms， is that they'll handle those misbehaving nodes。 just
    equally as well。 Okay， so we have a different problem now。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上看起来像是一个恶意行为者，但其实不是。这只是一个表现不正常的节点，正在执行错误的操作。拜占庭算法的一个优点是，它们能够很好地处理这些不正常的节点。好吧，现在我们遇到了一个不同的问题。
- en: which is the Byzantine generals problem。 So the Byzantine generals problem has
    n players in it。 So we have one general。 So here's our general and we have n minus
    one lieutenants。 In this case。 we have four players， and we have one general and
    three lieutenants。 So some number of these participants， can be insane or malicious。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是拜占庭将军问题。所以，拜占庭将军问题中有n个参与者。我们有一个将军。这里是我们的将军，我们有n-1个副将。在这个例子中，我们有四个参与者，一个将军和三个副将。因此，这些参与者中有一部分可能是疯狂或恶意的。
- en: And that includes both the general and the lieutenants。 So the commanding general
    sends an order。 to his n minus or her n minus one lieutenants， such that the following
    integrity constraints apply。 The first one is that all loyal lieutenants， must
    obey the same order。 The second one is that if a commanding general is loyal，
    then all loyal lieutenants obey the order。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括将军和副将。所以指挥将军会向他的n-1个副将发出命令，并且满足以下完整性约束：第一个是所有忠诚的副将必须遵守相同的命令；第二个是，如果指挥将军是忠诚的，那么所有忠诚的副将都必须遵守该命令。
- en: that he or she sends。 So here our general， who is loyal， sends attacked everybody。
    And all the loyal lieutenants send an attack to everyone else。 But this malicious
    lieutenant here。 tells this lieutenant retreat， right？ And tells this lieutenant
    retreat。 All right。 so we want the decision in this case， because the general
    is loyal and says attack to be attacked。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 他或她发送的消息。所以这里我们的忠诚将军给每个人发送了攻击命令。所有忠诚的中尉也向其他人发送了攻击命令。但这个恶意中尉在这里告诉这个中尉撤退，对吧？并告诉这个中尉撤退。好了，所以在这种情况下，我们希望决策是因为将军忠诚并下达攻击命令而进行攻击。
- en: But again， the malicious lieutenant here， is trying to make the distributed
    decision be retreat。 So we can differentiate between the malicious actors， and
    the loyal actors in this case， right？
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里的恶意中尉试图让分布式决策是撤退。所以我们可以区分恶意行动者和忠诚行动者，对吧？
- en: Because here this lieutenant receives two attack messages， and one retreat message。
    And same with this loyal lieutenant receives one retreat message， and two attack
    messages。 But it's not always the case。 There are some impossibility results。
    So in particular。 if we only have three players， then we can't solve the Byzantine
    general's problem， right？
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个中尉收到了两个攻击消息和一个撤退消息。这个忠诚的中尉收到了一个撤退消息和两个攻击消息。但并非总是如此。有些情况下是不可能的。所以特别地，如果我们只有三名玩家，那么我们无法解决拜占庭将军问题，对吧？
- en: Because one player here can mess everything up， right？
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这里一个玩家可以把一切搞砸，对吧？
- en: So here we have a loyal general and a loyal lieutenant， and the general says
    attack to everybody。 And here we have a malicious lieutenant， and they say retreat，
    right？
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，我们有一个忠诚的将军和一个忠诚的中尉，将军对所有人下达攻击命令。而这里有一个恶意的中尉，他们说撤退，对吧？
- en: So now from the point of view of this lieutenant， they get one order to attack。
    and they hear a hearsay order to retreat。 On the right， we have a malicious general。
    who do one lieutenant， the one on the left says attack。 The one on the right says
    retreat and these two are loyal。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个中尉的角度来看，他们收到一个攻击命令，且听到一个撤退的传闻命令。右边是一个恶意的将军，指挥一个中尉，左边的那个说攻击，右边的说撤退，而这两个是忠诚的。
- en: So this one's going to accept that attack from the general， and it's also going
    to hear retreat。 from this loyal lieutenant who's gonna relay that retreat。 So
    the challenge here is that we can't see， we can't determine from the point of
    view。 of this lieutenant on the left， which of the commands to follow， right？
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个中尉会接受将军的攻击命令，同时也会听到撤退命令。这个忠诚的中尉会传递撤退命令。所以问题在于，我们无法从左边这个中尉的角度判断该跟随哪个命令，对吧？
- en: Because here we can't tell is it the general that is loyal。 or that it's the
    other lieutenant that is loyal。 So in general with F faults。 we're gonna need
    N greater than three F to solve the problem。 You can ask questions。 If you have
    a question， please ask questions in chat。 That'll make it easiest。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这里我们无法判断是将军忠诚，还是另一个中尉忠诚。所以在一般情况下，有F个故障时，我们需要N大于3F才能解决问题。如果你有问题，请在聊天中提问，这样最方便。
- en: '''cause then everyone can read it， and it''ll be included in the transcript。
    Okay。 So there''s lots of algorithms to solve the problem。 The original algorithm
    has a number of messages。 that''s exponential in N， and newer algorithms have
    message complexity， of order N squared。 And there''s an algorithm that people
    use from MIT。'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个人都可以阅读它，它将被包含在记录中。好吧。解决这个问题有很多算法。原始算法需要的消息数量是N的指数级，更新的算法消息复杂度是N平方级别。有一个MIT使用的算法，
- en: that was developed by Castro and Liskoff back in 1999。 So the question here
    is if a general was malicious， what orders are we supposed to execute。 for the
    problem to work？ So in the case where the general is malicious。 you'd basically
    take the order that was opposite， right？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法是由卡斯特罗和利斯科夫在1999年开发的。那么这里的问题是，如果将军是恶意的，我们应该执行什么命令，才能使问题正常工作？如果将军是恶意的，你基本上会采取相反的命令，对吧？
- en: You'd be able to tell them the general is malicious。 because they're gonna be
    telling some people to attack。 They're gonna be telling some people to retreat。
    We still want to reach a general consensus。 for all of the correct players in
    the game。 Okay。 So when we have these Byzantine fault tolerance algorithms。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够判断将军是恶意的，因为他们会告诉一些人攻击，告诉另一些人撤退。我们仍然希望达成一个所有正确玩家的一致意见。好吧。所以当我们有这些拜占庭容错算法时，
- en: it allows multiple machines to make a coordinated decision。 even if some subset
    of them are malicious。 So it allows us to have a request。 We want this group to
    make a decision， and we have these malicious participants here。 who are gonna
    take the information coming in on the request。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许多个机器做出协调的决策，即使其中一些机器是恶意的。所以它允许我们发出请求。我们希望这个群体做出决策，而这里有一些恶意的参与者，他们将获取请求中的信息。
- en: and try to make the decision go their way， to pollute by confusing everyone
    else。 and sending mixed messages to those other participants。 But as long as there
    are less than a third。 of the population that are malicious， the Byzantine fault
    tolerance algorithms。 will still be able to come into agreement， across all of
    the other participants。 Okay。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并试图让决策朝着他们的方向进行，通过混淆其他参与者来污染决策，并向其他参与者发送混合信息。但只要恶意参与者少于三分之一，拜占庭容错算法仍然能够在其他所有参与者之间达成一致。好的。
- en: Any other questions about BFT before we change gears？ And again。 this works
    well for malicious environments。 It also works well where you have nodes。 that
    are flaky and fail in bizarre Byzantine kinds of ways。 Okay。 So let's switch gears
    and talk about network protocols。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们切换话题之前，有没有其他关于BFT的问题？再说一次，这种方法在恶意环境下非常有效。它也适用于那些节点不稳定且以奇异拜占庭方式故障的情况。好了，让我们换个话题，来谈谈网络协议。
- en: So we have networking protocols on many levels。 So at the physical level。 there
    are protocols for the mechanical connectors， and for the electrical network。 how
    we represent zero and ones in waveforms。 That the link level。 there are packet
    formats and error control。 At the network level， we have routing and addressing。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在许多层次上都有网络协议。在物理层，有用于机械连接器和电气网络的协议，如何用波形表示0和1。在链路层，有数据包格式和错误控制。在网络层，我们有路由和寻址协议。
- en: And then at the transport level， we might have something like reliable message
    delivered。 And so if we look at the protocols in today's internet， the ones that
    are most commonly used。 at the physical layer， we have protocols like ethernet。
    So I'm doing Zoom on a computer。 that's connected over ethernet。 That computer
    also has a wifi interface。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在传输层，我们可能会有像可靠消息传递这样的东西。因此，如果我们看一下今天互联网中的协议，最常用的协议之一是在物理层，像以太网这样的协议。所以我正在用一台通过以太网连接的电脑进行Zoom会议。那台电脑还有一个Wi-Fi接口。
- en: and can also communicate over that interface。 You can also have cellular protocols
    like LTE。 In between， again， we have the hourglass。 We have IP， the internet protocol
    as the narrow waste。 And then we have transport layer protocols， like the unreliable
    data gram protocol。 and the transmission control protocol。 On top of that， we
    can build our applications。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并且还可以通过那个接口进行通信。你还可以使用像LTE这样的蜂窝协议。在中间，我们再次看到沙漏形状的结构。我们有IP协议，作为狭窄的瓶颈。然后，我们有传输层协议，比如不可靠数据报协议和传输控制协议。在此之上，我们可以构建我们的应用程序。
- en: We can have libraries that implement protocols， like remote procedure call and
    so on。 So let's start with looking at the physical link。 What kinds of networks
    do we have？ Well。 the most common type of network is a broadcast network， where
    we have a shared communication medium。 Now you have one， you popped open your
    computer， inside that shared medium is a set of wires。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有实现协议的库，比如远程过程调用等。那么，让我们从物理链路开始看起。我们有哪些类型的网络呢？最常见的网络类型是广播网络，在这种网络中，我们有一个共享的通信介质。现在，你打开了电脑，在这个共享介质中有一组电线。
- en: that interconnects all of the components， the processor， the I/O devices， memory
    and so on。 So inside the computer， we call this a bus。 And all devices are simultaneously
    connected。 to that bus and can communicate。 Originally， Ethernet was a broadcast
    network。 and all computers on a local subnet， were connected to one another。 Now，
    we have other examples。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议连接所有的组件，包括处理器、I/O设备、内存等。因此在计算机内部，我们称之为总线。所有设备都同时连接到这条总线上，并能够进行通信。最初，以太网是一种广播网络，局域网中的所有计算机都彼此连接。现在，我们有了其他的例子。
- en: So for example， where the wireless medium is air。 So when we're in the classroom
    and we're speaking。 that's via a communication medium， that's a broadcast medium
    that is the air。 We also have Wi-Fi。 right？ And so Wi-Fi is a broadcast medium。
    And so this is one of the reasons why。 when you're at a cafe， people tell you，
    use a virtual private network。 For example， the campus VPN。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，无线介质是空气。当我们在教室里说话时，这就是通过一个通信介质进行的，这个广播介质就是空气。我们还有Wi-Fi，对吧？所以Wi-Fi也是一个广播介质。这就是为什么当你在咖啡馆时，人们会告诉你使用虚拟私人网络（VPN）。比如校园VPN。
- en: because you're broadcasting the information， from your computer and anyone who's
    sitting there。 in the cafe could actually receive that information， and potentially
    know what you're doing。 and potentially get sensitive information。 There are other
    broadcast networks like cellular networks。 where all devices are communicating
    over shared medium， which is radio frequencies。 Okay。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你正在从你的计算机广播信息，而在咖啡馆里坐着的任何人实际上都可能接收到这些信息，可能知道你在做什么，并且可能获得敏感信息。还有其他广播网络，比如蜂窝网络，其中所有设备都通过共享介质——无线电频率来进行通信。
- en: so some of the details about a broadcast network。 So in most common networks
    that are based on protocols。 like Ethernet， there's what's called a media access
    control， address or MAC address。 It's a 48-bit physical address for the hardware
    interface。 And every device in the world has a unique address。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于广播网络的细节。在大多数基于协议的常见网络中，比如以太网，有一个叫做媒体访问控制（MAC）地址的东西。它是硬件接口的48位物理地址。世界上的每个设备都有一个唯一的地址。
- en: Now I say sort of because the way MAC addresses are assigned， is vendors get
    a prefix。 So 3。com gets a prefix， Netgear gets a prefix， and then the assigned
    devices in their space of bits。 Because manufacturers produce a lot of devices，
    they sometimes reuse MAC addresses。 So they're supposed to be unique， but they're
    not always guaranteed to be unique。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我说是“几乎唯一”是因为MAC地址的分配方式是，厂商会获得一个前缀。所以3com获得一个前缀，Netgear获得一个前缀，然后在他们的位空间中分配设备。由于制造商生产了大量设备，他们有时会重复使用MAC地址。所以它们应该是唯一的，但并不总是能保证唯一。
- en: if the manufacturer has recycled some of those addresses。 Okay， now delivery。
    So when you broadcast a packet， how does a receiver know that it's supposed， to
    receive that packet？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果制造商回收了某些地址。那么，数据包的传输是怎样实现的呢？当你广播一个数据包时，接收者怎么知道它应该接收这个数据包呢？
- en: Because that packet goes to everyone。 So it's literally like standing up in
    a room。 and starting talking。 How does someone in the room know， that you're actually
    talking to them。 and not just to the room as a whole？ So if we look at the nodes
    in a network。 they each have this MAC address。 So here this one has MAC address
    three， and it's sending a packet。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个数据包会传送给每个人。所以这实际上就像在一个房间里站起来开始讲话。房间里的人怎么知道你是在和他们说话，而不是只是在对整个房间说话？如果我们看一下网络中的节点，它们每一个都有一个MAC地址。这里的这个节点有MAC地址3，并正在发送数据包。
- en: Well， the way we determine the destination， is we take our packet and we prepend
    on that packet a header。 And that header has the destination MAC address。 So now
    when everyone receives that packet。 this one with ID one ignores it。 This one
    with ID four ignores it。 And this one， oh， ID two。 that matches the destination。
    It'll receive the packet， pass it on to the operating system。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们确定目的地的方法是，我们将数据包加上一个头部。这个头部包含了目的地的MAC地址。所以现在当每个人接收到这个数据包时，ID为1的设备会忽略它，ID为4的设备也会忽略它。而ID为2的设备，它的目的地址匹配，便会接收这个数据包，并将其传递给操作系统。
- en: pass it on to the application。 Now very important is that in Ethernet。 this
    check is done in hardware。 So the operating system isn't getting interrupted。
    every time a packet is broadcast。 The look and see， oh， is this packet for me。
    Now that said。 you can actually disable that hardware check， that puts your adapter
    into mode。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据包传递给应用程序。现在非常重要的是，在以太网中，这个检查是在硬件中完成的。所以操作系统不会在每次广播数据包时被中断。它只会查看，哦，这个数据包是要发送给我的吗？说到这一点，你实际上可以禁用这个硬件检查，将你的适配器设置为某种模式。
- en: that's called promiscuous mode， because it'll now listen to and receive。 every
    single packet that's transmitted。 So again， this is the reason why。 you wanna
    make sure you use a VPN， when you're using public Wi-Fi。 because anybody can put
    their adapter into promiscuous mode。 Now they receive all of the packets。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式叫做混杂模式，因为它现在会监听并接收每一个传输的数据包。所以再次强调，这就是为什么你在使用公共Wi-Fi时要确保使用VPN的原因，因为任何人都可以将他们的适配器设置为混杂模式。这样他们就能接收到所有的数据包。
- en: that are being transmitted by people in that area。 and they can decode them
    and see what people are doing。 Not every application will unfortunately encrypt，
    its sensitive data。 And so you could have passwords and usernames， and other things
    that get stolen。 Okay。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据是由该区域的人传输的，他们可以解码并看到人们在做什么。不幸的是，并非每个应用程序都会加密其敏感数据。因此，你可能会丢失密码、用户名和其他被盗的东西。好的。
- en: so an alternative to broadcast networks， is point-to-point networks。 Why have
    a shared bus？
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，广播网络的一个替代方案是点对点网络。为什么要使用共享总线呢？
- en: You could simplify things， you could increase the available bandwidth。 If you
    had point-to-point links， then you added in routers and switches。 So why was this
    not done originally？ Cost。 It used to be routers and switches。 were very expensive
    on a per-port cost。 Now， there are dollars， tens of dollars， or less per switch。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简化事情，增加可用带宽。如果你有点对点链路，然后添加路由器和交换机。那么，为什么最初没有这么做呢？成本。过去，路由器和交换机的每端口成本非常高。现在，交换机的成本通常是几十美元，甚至更低。
- en: And so the cost per port is very， very small。 And so point-to-point networks。
    are pretty much the point you'll see in most environments。 Again， except for wireless
    environments。 So on a point-to-point network， you have a network where every physical
    wire。 is connected to only two computers， or a computer and a switch or a computer。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每个端口的成本非常非常低。因此，点对点网络几乎是你在大多数环境中看到的网络类型。除了无线环境之外。所以，在点对点网络中，你会有一个网络，每一根物理线缆只连接两个计算机，或者是计算机和交换机，或者计算机与计算机之间。
- en: and a router or a switch and other switch， or a switch and other router or two
    routers。 So a switch。 What's the difference？ I'm using the term switch in routers。
    Well。 a switch is a bridge that transforms that shared bus。 that broadcast configuration
    into a point-to-point network。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个路由器或交换机以及其他交换机，或者交换机和其他路由器，或者两个路由器。那么，交换机有什么区别呢？我在路由器中使用交换机这个术语。好吧，交换机是一种桥接设备，它将共享总线的广播配置转变为点对点网络。
- en: And it adaptively figures out what MAC addresses， are available on each port。
    and only routes traffic to the ports， that have the particular MAC address。 that
    matches what's in the header。 So here the switch is actually looking at the header。
    and it's seeing who is sending this， what's the MAC address of the sender。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自适应地找出每个端口上可用的MAC地址，只将流量路由到那些具有与头部中匹配的MAC地址的端口。因此，交换机实际上是在查看头部，并查看谁在发送数据，发送者的MAC地址是什么。
- en: recording it for that port， and looking in a lookup table to find out。 where
    is the MAC address for the recipient， in the header located。 A router acts as
    a junction between physical networks。 So between switches and say the internet。
    we have routers。 And routers instead of looking at MAC addresses， use IP addresses。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为该端口记录数据，并在查找表中查找以确定收件人MAC地址在头部的位置。路由器充当物理网络之间的连接点。所以，交换机和互联网之间就是通过路由器连接的。路由器不看MAC地址，而是使用IP地址。
- en: So they're routing at the layer above。 So the question is， are switch and router。
    both computers as well or just special ones？ The answer is sort of yes。 So typically
    routers are built using， application specific integrated circuits or ASIX。 So
    this is custom logic。 And， but if you look at what that custom logic is。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们在更高层次进行路由。那么问题是，交换机和路由器是不是也属于计算机，还是仅仅是特殊设备？答案是“是的”。通常，路由器是使用应用特定集成电路（ASIX）构建的。这是定制的逻辑。如果你看这些定制逻辑的内容。
- en: a lot of times it's ARM cores， or other sorts of computational units。 that are
    the same types of things， that we find in microprocessors。 It is also possible
    to actually use modern microprocessors， to do routing and switching。 And you can
    do this if you， for example， want to implement functionality inside the network。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，使用的是ARM核心，或者其他类型的计算单元。这些都是我们在微处理器中发现的类似设备。实际上也可以使用现代微处理器来进行路由和交换。如果你想在网络内部实现某些功能，完全可以这样做。
- en: So going against the end-to-end principle， you could push functionality into
    the network。 implement it on a general purpose computer。 But in general， for the
    kinds of performance。 that we're trying to get to， you know， 100 gigabit， 400
    gigabit links。 those are typically done using ASIX。 So special purpose hardware。
    Okay。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，违背端到端原则，你可以将功能推送到网络中，在通用计算机上实现。但一般来说，对于我们所追求的性能，比如100千兆、400千兆的链路，通常是使用ASIX来实现的。这是专用硬件。好的。
- en: so let's look at the internet protocol。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们来看看互联网协议。
- en: '![](img/193c262c45839f75eb2f216af3003afc_3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_3.png)'
- en: So it's the internet's networking layer。 So it's this red layer here in our
    stack。 And the service that it provides， is a best effort packet delivery service。
    Right。 so it's gonna try its best， to deliver packets to its destination。 That
    means， however。 that packets might get lost。 They might get corrupted， they might
    get delivered out of order。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是互联网的网络层。所以它是我们堆栈中的这个红色层。它提供的服务是尽力而为的数据包传递服务。对，它会尽力把数据包传递到目的地。但是，这意味着数据包可能会丢失，可能会被破坏，可能会乱序到达。
- en: So the way I like to think about packets is like postcards， right， you go on
    vacation， and。 you know， when we go away， we'll send postcards to a bunch of friends。
    And we might send， you know。 three or four postcards， from different places while
    we're traveling around。 And it's always humorous when you get back to find out，
    well。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把数据包想象成明信片，你知道的，你去度假时，你会，嗯，去不同的地方旅行时，我们会给一堆朋友寄明信片。我们可能会从不同的地方寄三四张明信片。而每次你回家后发现，哎，原来它们不是按顺序到达的，这总是让人觉得很有趣。
- en: what order of those postcards arrive in？ Did they arrive in the order we sent
    them？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些明信片是按什么顺序到达的呢？它们是按照我们发送的顺序到达的吗？
- en: And did they arrive， period？ And， you know， a lot of times they don't arrive，
    or， you know。 someone missing， and they arrive out of order。 Well， that's just
    like the internet， right？
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些信息包到达了吗？你知道，很多时候它们没有到达，或者，有些丢失，或者它们的到达顺序错乱。嗯，这就像互联网一样，对吧？
- en: There's no guarantee that packets won't be lost， that they won't be corrupted。
    or that they might be delivered out of order。 So there's a question to summarize
    the difference。 between switch and router。 So again， switches operate on local
    area networks。 routers connect local area networks to wider networks。 So switches
    are on Mac addresses。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证数据包不会丢失，不会被破坏，或者它们可能会乱序到达。所以，总结一下，交换机和路由器之间的区别是什么？再次强调，交换机操作在局域网内，路由器连接局域网到更广泛的网络。所以交换机是根据MAC地址工作的。
- en: routers operate on IP addresses。 Okay， so you can think of IP as a data gram
    service。 We're routing across many physical switching domains， or subnets， so
    local area networks。 And so those local area networks again， subnets， those are
    switches。 The routers operate here at the network layer， to interconnect those
    subnets。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器操作在IP地址上。好的，你可以把IP看作是一种数据报服务。我们正在跨越许多物理交换域或子网进行路由，因此局域网。所以这些局域网，换句话说，子网，那些是交换机。路由器在这里的网络层工作，用来互联这些子网。
- en: So we divide IP addresses up into， you can think of them as a 32-bit namespace。
    and that's divided up into four octets or four bytes。 And so we'll typically write
    them。 as those four bytes dot separated。 So here we have 169。229。6。83。 That happens
    to be the IP address。 from one of the computer science file servers， one of the
    departmental file servers。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把IP地址分成，你可以把它看作是一个32位的命名空间。然后它被划分为四个八位组或四个字节。因此，我们通常会将它们写成四个字节之间用点号分隔的形式。所以这里我们有169.229.6.83。那恰好是其中一个计算机科学文件服务器的IP地址，一个部门文件服务器的IP地址。
- en: An internet host， this is the computer， that's connected to the internet。 Now，
    what does that mean？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个互联网主机，就是连接到互联网的计算机。那这意味着什么呢？
- en: Well， that could be anything from， we have smart thermostats。 and those thermostats
    have an IP address。 They're connected to the internet。 Your phone has an IP address。
    It's connected to the internet。 Your tablet， your computer。 all of these have
    an IP address， one or more of them and they're used for routing。 So for example。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，那可以是任何东西，比如，我们有智能温控器，这些温控器有一个IP地址。它们连接到互联网。你的手机有一个IP地址。它连接到互联网。你的平板电脑、你的电脑，所有这些设备都有一个或多个IP地址，它们用于路由。所以比如说。
- en: on your phone， you have an IP address that's assigned， for the LTE or 5G network。
    You also。 when you're on WiFi， have an IP address for that WiFi network。 So simultaneously。
    your phone has two IP addresses。 Now， some of these might be private。 and they
    can't be used for routing。 So the IP address that you get， say when you're at
    home。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的手机上，你有一个分配给LTE或5G网络的IP地址。当你连接WiFi时，你也会有一个WiFi网络的IP地址。所以，你的手机同时拥有两个IP地址。现在，其中一些可能是私有的，不能用于路由。所以，你在家时获得的IP地址就是一个例子。
- en: is a private network address。 You can't route directly to it。 And not every
    computer has a unique IP address。 So when you're at home， your cable modem。 or
    your fiber modem has an IP address。 And then your local subnet is a private subnet。
    Your cable modem uses network address translation。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个私有网络地址，无法直接路由到它，并不是每台计算机都有一个唯一的 IP 地址。所以当你在家时，你的电缆调制解调器或光纤调制解调器有一个 IP 地址，然后你的本地子网是一个私有子网。你的电缆调制解调器使用网络地址转换。
- en: to translate requests from host outside your network， to host inside your network
    and vice versa。 So your machines or your devices at home， all have the same public
    IP address。 and they have an internal private IP address。 So a subnet is a set
    of a network that connects hosts。 that have related IP addresses。 And so that
    it's identified by a 32-bit value。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将来自网络外部的请求转换为网络内部主机的请求，反之亦然。所以你家里的设备或者机器，都有相同的公共 IP 地址，并且它们有一个内部私有 IP 地址。子网是一个连接有相关
    IP 地址的主机的网络。它由一个 32 位的值来标识。
- en: and a prefix number of bits。 So it'll be a slash， the mask。 So here 128。32。131。0/24
    says that all of the addresses， that match the first 24 bits will match。 So are
    the subnet。 So that would be 128。32。131。whatever is all， on the same subnet。 So
    the last XX is gonna be between zero and 255。 All right。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个前缀位数。所以它会是一个斜杠后跟掩码。例如，128.32.131.0/24 表示所有与前 24 位匹配的地址都会匹配。所以这个子网就是 128.32.131.任意，最后的
    XX 会在 0 到 255 之间。
- en: And that mask is just simply the number of matching bits。 So 24 represents the
    first three bytes。 or the first three octets。 But it doesn't have to be units
    of eight。 It could be anything。 It could be 22， it could be 31。 It all will depend。
    And then often routing within the subnet。 is done by MAC address。 So within a
    subnet， the switch will see all of the hosts。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个掩码实际上只是匹配位数的数量。所以 24 表示前 3 个字节，或者前 3 个八位组。但它不一定是以 8 为单位的，可以是任何值。可以是 22，也可以是
    31，这取决于情况。然后，通常在子网内的路由是通过 MAC 地址来完成的。所以在子网内，交换机会看到所有的主机。
- en: that have the same， that are on that subnet， and then just use its MAC address。
    to route packets between those hosts。 All right。 So there's a question when someone
    from the outside sends。 a request to one machine inside a private network。 How
    does a router know which computer。 to send the request？ So it's all gonna depend
    on the computer。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同子网上的设备之间，然后只使用它的 MAC 地址来路由数据包。好的。那么当外部有人向私有网络中的一台计算机发送请求时，路由器如何知道将请求发送到哪台计算机呢？这将取决于计算机。
- en: that made the outbound request to that server。 When that happens network address
    translation。 will record that there was the outbound request， and then match that
    up with the inbound response。 or inbound request。 There also are protocols like
    the universal plug， and play protocol or UPNP。 where a host inside the network
    can say， hey， route connections for me on this particular port。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它发出了到该服务器的出站请求。当发生这种情况时，网络地址转换（NAT）会记录出站请求，然后将其与入站响应或入站请求进行匹配。还有像通用即插即用协议（UPnP）这样的协议，网络中的主机可以告诉路由器，为我在特定端口上建立连接。
- en: to on the public IP to my host inside that。 So for example， devices like game
    consoles。 and telephone adapters use that kind of approach， to tell the router
    to open ports up for them。 So that's how you'll do that reverse mapping。 So the
    question is， so the Wi-Fi routers in our home。 is really a combination of switch
    and router， that is responsible for both public。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我的主机能够访问公共 IP。所以，举个例子，像游戏主机和电话适配器这样的设备，采用这种方法，告诉路由器为它们开放端口。这样，你就能完成反向映射。所以问题是，我们家里的
    Wi-Fi 路由器，实际上是交换机和路由器的结合体，负责处理公共网络。
- en: and private data transfer。 Absolutely。 That's why on the back of your router。
    you'll see typically four ports， right？ One is an upstream port， which might connect。
    to another router and then the other ports are internal ports， which you can plug
    your devices into。 and connections will be routed， between or will be switched
    between those devices。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 和私有数据传输。绝对是这样的。这就是为什么你在路由器的背面通常会看到四个端口，对吧？一个是上行端口，可能连接到另一个路由器，其他端口是内部端口，你可以将设备插入这些端口，连接将在这些设备之间进行路由或交换。
- en: And then it's doing a routing function， between the subnet that's your internal
    subnet。 like a 192 subnet and the external subnet， which is your providers wide
    area network subnet。 So someone says， I guess Nat keeps the table， for translation
    which binds empirical port。 to destination port， is that correct？ Yes。 So Nat
    does keep a table。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它在内部子网和外部子网之间执行路由功能。比如192子网和外部子网，即你服务提供商的广域网子网。所以有人会说，我猜Nat会保持一个翻译表，这个表将实际端口与目标端口绑定，对吗？是的。所以Nat确实保持一个表。
- en: that does mapping between internal ports and external ports。 We're gonna get
    into ports in just a moment， when we start talking about UDP。 Okay。 so if we look
    at the format of an IPv4 packet。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行的是内部端口和外部端口之间的映射。我们稍后会谈到端口，特别是在讨论UDP时。好的。如果我们看一下IPv4数据包的格式。
- en: '![](img/193c262c45839f75eb2f216af3003afc_5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_5.png)'
- en: I'm not gonna go through all the fields here， but some of the fields that are
    important are。 there's the version， there's version four， there's the size， this
    is my header plus data。 there's the destination IP address， again， it's the 32-bit
    address， the source address， again。 that's a 32-bit address， and there's a checksum
    type of transport protocol。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会一一讲解所有字段，但一些重要字段包括：版本，有版本四；大小，这是我的头部加数据；目的地IP地址，同样是32位地址；源地址，同样是32位地址；还有校验和类型的传输协议。
- en: and a bunch of other important options， flags and features。 Not all of the features
    will be supported by all devices。 There's a sort of core set that are required
    though。 The function of an IP data gram is just again。 like a postcard。 It's unreliable，
    unordered， could be damaged。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一堆其他重要的选项、标志和功能。并非所有设备都支持所有功能。不过，确实有一组核心功能是必须的。IP数据报的功能再次类似于明信片。它是不可靠的，无序的，可能会损坏。
- en: packet that's sent from a source to a destination。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从源到目的地发送的数据包。
- en: '![](img/193c262c45839f75eb2f216af3003afc_7.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_7.png)'
- en: And the function of the network， is simply to deliver data grams。 Now。 we kind
    of already started talking about it， but between two hosts on the internet。 is
    a wide area network。 And you can think of the wide area network。 as a network
    that covers a broad area。 So it could be a city， it could be a county， a state。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的功能简单来说就是传送数据报。现在，我们已经开始谈论这个话题了，但在互联网中的两个主机之间是广域网。你可以把广域网看作是覆盖大范围区域的网络。所以它可能是一个城市，可能是一个县，或者是一个州。
- en: a country， could be an entire planet， right？ The internet is a wide area network。
    Wide area networks connect multiple physical data link， networks。 so multiple
    subnets or local area networks， get connected by a wide area network。 The data
    link networks are themselves connected by routers， right？
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个国家，也可以是一个整个星球，对吧？互联网是一个广域网。广域网连接多个物理数据链路网络。因此，多个子网或局域网通过广域网连接。数据链路网络本身通过路由器连接，对吧？
- en: And so different local area networks， could use completely different technologies。
    So you might have one local area network， that is using Wi-Fi， another local area
    network。 that's using ethernet， and another local area network that's using LTE，
    or laser or， you know。 any different technology。 And the routers interconnect
    all of these different local area， networks。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不同的局域网可能使用完全不同的技术。所以你可能有一个局域网使用Wi-Fi，另一个局域网使用以太网，另一个局域网使用LTE，或激光，或者任何其他不同的技术。路由器将这些不同的局域网互联起来。
- en: OK， so the role of routers is to forward each packet that's。 received on an
    incoming link to the appropriate， outgoing link。 And the ideas that outgoing link
    is closer to the destination。 And it's going to be based on that packet's destination
    IP， address。 So that's， again。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以路由器的作用是将每个接收到的数据包从进入链路转发到适当的出去链路。并且这个出去链路会更接近目的地。它将基于数据包的目的地IP地址。所以，这是再次强调的内容。
- en: in contrast to switches， which deliver packets based on MAC addresses。 the media
    access control addresses， routers operate at the network layer。 and route based
    on IP addresses。 Routers operate with storm forward。 so packets are buffered and
    then they're forwarded。 And there's a forwarding table。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与根据MAC地址传递数据包的交换机不同，媒体访问控制地址，路由器在网络层工作。并根据IP地址进行路由。路由器操作时是逐个转发数据包，因此数据包会被缓冲，然后再转发。而且有一个转发表。
- en: which maps between IP， addresses and the output link。 So here。 we can see what
    it might look like inside a router。 We have incoming links and packets coming
    in on those links。 So you can see here we have a bunch of blue packets coming
    in。 They get buffered in memory。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 IP 地址与输出链路之间的映射。所以在这里，我们可以看到路由器内部的情况。我们有传入链路和通过这些链路传入的数据包。所以你可以看到这里有一堆蓝色数据包正在传入。它们被缓存在内存中。
- en: And then routed to the appropriate output link。 And so here you can see there's
    some demultiplexing。 between the green and the red packets。 The green end up going
    out this link。 The red end up going out this link。 You can see that there's multiplexing。
    of the black packets coming in here and the red packets coming， in here。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后路由到适当的输出链路。所以在这里你可以看到，绿色和红色数据包之间有一些解复用。绿色的数据包最终通过这个链路出去。红色的数据包最终通过那个链路出去。你可以看到，这里有黑色数据包和红色数据包的复用。
- en: And they're both going out on this outgoing link。 And so we use buffers because
    we might have more traffic coming。 in for an output link than we have capacity
    on that output link。 These buffers are fixed size。 So if too many packets， too
    many of these black and red packets。 come in and it exceeds the capacity of this
    link consistently。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都通过这个输出链路发送出去。所以我们使用缓冲区，因为可能会有比输出链路容量更多的流量进入。 这些缓冲区是固定大小的。所以如果进来的数据包太多，黑色和红色的数据包太多，超过了该链路的容量。
- en: and we run out of memory to buffer those packets， we drop those packets。 Again，
    IP is best effort。 So if we run out of space in the routers， packets get dropped。
    It's up to the upper levels to deal with those packets that， get lost。 OK， so
    packet forwarding。 Here's an example of an IP packet going from host A to host
    B。 And when a router receives a packet。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有足够的内存来缓存这些数据包，我们就会丢弃这些数据包。再次提醒，IP 是尽力而为的。如果路由器内存空间不足，数据包就会被丢弃。由上层协议来处理那些丢失的数据包。好了，数据包转发。这里有一个示例，展示了
    IP 数据包从主机 A 到主机 B 的过程。当路由器接收到一个数据包时。
- en: it's going to weed the IP destination address of the packet。 look at its forwarding
    table to determine the output port。 and then forward the packet to the corresponding
    output port。 Now we include default route for subnets where we don't have， an
    explicit entry。 And basically。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它将会筛选数据包的 IP 目标地址。查看其转发表来确定输出端口。然后将数据包转发到相应的输出端口。现在我们为没有明确条目的子网添加默认路由。基本上就是这样。
- en: you can think of this， as for passing the problem off to someone else。 hopefully
    a more authoritative router that， knows how to get to that location。 So your cable
    modem。 all it knows， is it has a default route， which is send it， to the cable
    company。 and that cable company router， will figure out where to send it。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这看作是把问题交给别人来处理。希望是一个更有权威的路由器，它知道如何到达那个位置。所以你的有线调制解调器，它只知道，它有一个默认路由，就是将数据包发送到有线电视公司，而那个有线电视公司路由器会处理发送到哪里。
- en: So that way you don't need to have a cable modem that。 has the way to reach
    every possible network in the world。 All it needs to know is there's another more
    authoritative router， that does have that information。 OK， so I've been talking
    about IP addresses。 I've been talking about MAC addresses。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就不需要有一个可以到达世界上每个网络的有线调制解调器。它只需要知道有另一个更有权威的路由器，它知道如何到达那个网络。好的，我一直在讲 IP 地址，也讲了
    MAC 地址。
- en: It can get very confusing because we're， talking about things that operate at
    different levels。 And so here's an example to help you， think about what the difference
    is。 So here we have John Doe。 and John Doe has a Social Security， number， and
    John Doe lives in Washington， D。C。 But John Doe gets an acceptance letter from
    Berkeley， comes to Berkeley to go to school。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让人感到很困惑，因为我们在谈论的是在不同层次上运行的东西。所以这里有一个例子，帮助你理解它们之间的区别。这里有约翰·多伊。约翰·多伊有一个社会安全号码，他住在华盛顿
    D.C.，但是约翰·多伊收到了一封来自伯克利的录取信，于是他去了伯克利上学。
- en: moves to Berkeley。 All right， so now John has a Berkeley address。 But his Social
    Security number still remains the same。 Now。 why do we not use MAC addresses for
    routing？ Because it wouldn't scale。 How do we know where John Social Security
    number， 0， 0， 0， 0， 0， 0， 0 is located？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到伯克利。好的，现在约翰有了伯克利的地址，但他的社会安全号码依然保持不变。那么，为什么我们不使用 MAC 地址进行路由呢？因为这样无法扩展。我们怎么知道约翰的社会安全号码，0，0，0，0，0，0，0，位于哪里呢？
- en: We'd need a table that tells us where every single Social， Security number is
    located。 So the analogy here is that a MAC address， is like a Social Security
    number。 whereas an IP address is like some home address。 And the thing is that
    the MAC address。 is uniquely associated with the device for the lifetime， of that
    device。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个表格，告诉我们每个社会安全号码的位置。所以这里的类比是，MAC 地址就像社会安全号码，而 IP 地址就像家庭地址。问题是，MAC 地址是唯一地与设备在其生命周期内相关联的。
- en: So the MAC address that your laptop has， for its wireless card， is permanent。
    It's assigned at the factory， and it doesn't change。 Whereas the IP address you
    have is going to change， throughout the day。 When you're at home。 you're going
    to have one IP address， the public IP address of your cable or fiber modem。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你的笔记本电脑无线网卡的 MAC 地址是永久的。它是在工厂分配的，且不会改变。而你拥有的 IP 地址在一天中会发生变化。当你在家时，你会有一个 IP
    地址，也就是你宽带或光纤调制解调器的公共 IP 地址。
- en: When you're on campus， well， as you move from building， to building。 and you
    switch from edge to room network， to edge to room network， your IP address may
    change。 And again， the MAC address never changes。 OK， so why does Packet Ford
    and using IP addresses scale？
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在校园内时，随着你从一栋楼移动到另一栋楼，从边缘网络到教室网络再到边缘网络，IP 地址可能会发生变化。而 MAC 地址是永远不变的。好的，那为什么使用
    IP 地址的包转发能够扩展呢？
- en: Because IP addresses are aggregated。 So you're not just randomly assigned an
    IP address。 but rather they belong to organizations。 So at UC Berkeley， all IP
    addresses。 start with the first two bytes being A9 and E5。 So any address of the
    form， A9， E5， something。 something， belongs to Berkeley。 So a router in New York
    just needs one entry。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 IP 地址是聚合的。所以你不是随机分配一个 IP 地址，而是它们属于某个组织。所以在 UC 伯克利，所有的 IP 地址的前两个字节都是 A9 和
    E5。所以任何形式为 A9，E5，某某某的地址都属于伯克利。所以纽约的路由器只需要一个条目。
- en: to route to all of the hosts at Berkeley。 If instead we were using a MAC address。
    then that router in New York would， have to have table entries for the， whatever，
    70。000 devices that we might have active at any given time， on campus， so it wouldn't
    scale。 So the question is， does every router in the world， know that this address
    belongs to Berkeley。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 路由到伯克利的所有主机。如果我们改用 MAC 地址，那么纽约的路由器就必须为我们校园内可能在任何时刻激活的 70,000 台设备维护路由表条目，这样就无法扩展。所以问题是，世界上的每个路由器都知道这个地址属于伯克利吗？
- en: or only some top nodes？ Again， it depends， right？ Depending on the size of the
    ISP。 they may not know how to reach Berkeley， which case。 they'll forward the
    packet on to their internet service。 provider who will forward it on to someone
    else。 And eventually you reach a router that is authoritative。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还是只有一些顶级节点知道？这取决于对吧？根据 ISP 的规模，他们可能不知道如何到达伯克利，在这种情况下，他们会将数据包转发给他们的互联网服务提供商，后者会将数据包转发给其他人。最终，你会到达一个权威路由器。
- en: and can route to it。 On the other hand， if you're at a major provider， like。
    say Comcast or AT&T or others， they would have all of the routing tables。 to reach
    all of the major organizations in the internet。 So the analogy here is， give this
    letter。 to a person with a given Social Security number， right？ That's a pretty
    intractable problem。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以进行路由。另一方面，如果你在像 Comcast 或 AT&T 等主要提供商处，他们会有所有的路由表，来到达互联网上的所有主要组织。所以这里的类比是，把这封信交给一个有特定社会安全号码的人，对吧？这是一个相当棘手的问题。
- en: to track that person down。 On the other hand， if I say， give it to John Smith，
    who。 was at 123 First Street in Los Angeles， California， in the United States，
    very easy to route。 to that particular address。 OK， so some administrative stuff。
    We have a midterm next week from 7 to 9 PM。 It'll cover all course material with
    a focus。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪这个人。另一方面，如果我说，把它交给约翰·史密斯，他住在美国加利福尼亚州洛杉矶市的 123 第一街，这个地址非常容易路由到。好的，一些行政事项。我们下周有期中考试，时间是晚上
    7 点到 9 点。考试内容涵盖所有课程材料，重点是
- en: a priority， on the material from before the last midterm to now， or from the
    last midterm to now。 And then we have a review session coming up next Monday，
    on the 25th from 1 to 3 PM。 OK。 back to routing and naming。 So we need to go from
    human readable names to IP addresses。 So I don't want to have to remember that
    www。berkeley。edu。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 优先考虑从上次期中考试到现在的材料，或者从上次期中考试到现在的材料。接下来我们将在下周一，25号下午 1 点到 3 点，举行复习课。好的，回到路由和命名。所以我们需要将人类可读的名称转化为
    IP 地址。我不想记住 www.berkeley.edu 这样的地址。
- en: is represented by the host with IP address 128。32。139。48。 I got that good at
    remembering numbers。 so I probably would not be able to remember that， and type
    that in on my phone keyboard。 Same thing。 Sometimes it's also the case that a
    name maps， to many different hosts。 So www。google。com maps to hundreds of thousands，
    of different hosts depending on where you are in the world。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由IP地址128.32.139.48表示的主机。我可能记不住这些数字，或者在手机键盘上输入这些数字。所以有时候，名称也可以映射到许多不同的主机。例如，www.google.com在世界各地会映射到数以十万计的不同主机。
- en: And so and the load on those different servers。 And so we need a way of mapping
    from human readable names。 to IP addresses。 There's a question， is there a class
    that is about networks？ Yes。 The undergraduate class is CS 168。 And the graduate
    class is CS 268。 We're going to do a very surface level discussion of networking。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同服务器的负载问题。所以我们需要一种从人类可读的名称到IP地址的映射方式。这里有一个问题，是否有一门课程是关于网络的？是的，本科课程是CS 168，研究生课程是CS
    268。我们将对网络进行一个非常基础的讨论。
- en: in this class just because we have a limited amount of time。 But because networking
    is really important to distributed systems， and systems in general。 we're going
    to give you， a basic understanding of how networking works。 But if you really
    want to understand the full details， and build applications that use networking。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这门课程中，由于时间有限，我们只能覆盖有限的内容。但由于网络对于分布式系统和一般系统都非常重要，我们会让你对网络如何工作有一个基本的了解。但如果你真的想理解更多细节，并构建使用网络的应用程序……
- en: take CS 168。 OK。 So again， IP addresses， they're hard to remember。 IP addresses
    change。 If a server crashes and gets replaced by another one， I don't want people
    remembering that。 you know， www。berkeley。edu is 12832， 13948。 Right。 So the mechanism
    we use is called DNS or the domain naming system。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择修读CS 168。好了，再说一遍，IP地址很难记住，IP地址会变化。如果服务器崩溃并被另一个服务器替代，我不希望人们记住www.berkeley.edu是12832，13948。对吧。所以我们使用的机制叫做DNS，即域名系统。
- en: '![](img/193c262c45839f75eb2f216af3003afc_9.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_9.png)'
- en: And the domain naming system is a hierarchical mechanism， that we use for naming。
    So names are divided into domains and it goes from right to left。 So the top level
    domain。 what's missing here is there's actually， a dot and that's the top level
    is dot。 And then there's edu and then there's Berkeley。edu。 And then there's eks。berkeley。edu。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统是一种分层机制，用于命名。名称被分为不同的域，从右到左排列。顶级域名是……缺少的部分是其实有一个点，顶级域名就是这个点。然后是edu，再然后是Berkeley.edu。最后是eks.berkeley.edu。
- en: And then there's the host that we're trying to find。 So each domain is owned
    by a particular organization。 The top level is handled by ICANN。 the Internet
    Corporation for， assigned numbers and names。 And so they're the ones that hand
    out top level domain。 So when， you know， a few years ago。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要找的是主机。每个域名都由特定的组织拥有。顶级域名由ICANN（互联网名称与数字地址分配机构）管理。所以他们是分配顶级域名的机构。几年前，当……
- en: they created a ton of new domains。 And those were assigned。 handled out or handed
    out rather by ICANN。 Each of these subsequent levels is owned by a particular
    organization。 So there's an organization that runs。com。 There's an organization
    that runs。edu。 There's an organization that runs dot。 That mill。gov。org and so
    on。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 他们创建了大量的新域名，并且这些域名是由ICANN分配的。每一个后续层级的域名都由特定的组织拥有。所以有一个组织管理.com域名，另一个管理.edu域名，另一个管理.dot域名，还有mil，gov，org等等。
- en: So each of these organizations then hands out to lower level organizations，
    for。 so for academic organizations in the US， they can get a。edu。 So there's MIT。edu。
    If you want to find out what www。mit。edu maps to， you go to the MIT。edu， server。
    which is run by MIT。 Similar in our case， well， we want to find the eks， a web
    server。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每个组织将这些域名分配给更低级别的组织。对于美国的学术组织，他们可以获得一个.edu域名。例如MIT.edu。如果你想知道www.mit.edu对应的地址，你需要访问MIT.edu服务器，这由MIT管理。我们这边也是类似的，我们需要找到eks，这是一个Web服务器。
- en: We're going to go to the campus， the Berkeley campus domain name server。 And
    it'll tell us， oh。 go to eks。 Eks is hand， eks department happens to be one of
    the departments in campus that runs its own DNS。 And so you'll go to the eks。berkeley。edu
    DNS， and it will tell you， oh。 that host is for www that maps to 123 to 139。48。
    Now that takes time。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问校园，伯克利校园的域名服务器。它会告诉我们，“哦，去访问eks”。Eks部门恰好是校园中一个运行自己DNS的部门。因此，你会访问eks.berkeley.edu的DNS，它会告诉你，“哦，这个主机是www，映射到123到139.48”。这需要一些时间。
- en: It took a lot of time to explain this。 If every time you wanted to look up，
    you know， www。eks。berkeley。edu， you had to go all the way up to the top level
    and go all the way down this tree to find the host that would take a lot of time。
    That would also put a tremendous level。 If you think of the billions of devices
    that are looking up host names every day。 that would put a tremendous level on
    the load， rather on the top level。 And so we use caching。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这个过程花了很多时间。如果每次你想查找www.eks.berkeley.edu时，都必须从顶级域名服务器一直查找到树的最底端，找到目标主机，那会花费很多时间。如果你考虑到每天有数十亿设备在查找主机名，这样的请求会给顶级服务器带来巨大的负载。所以我们使用缓存来优化这个过程。
- en: And so there's caching at clients of the results。 And typically you'll cash
    for anywhere from a couple of hours all the way up to could be a couple of weeks。
    It's kind of a trade off cash too long。 And if a name changes that the mapping
    changes。 then it'll break because you won't， you'll think you can't reach that
    host cash to infrequently。 you know， too short。 A time period， and you'll end
    up putting more load on the DNS server。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端会缓存结果。通常情况下，缓存时间从几个小时到几周不等。这是一个权衡，如果缓存时间太长，如果某个名字发生了变化，映射也发生了变化，那么就会出现问题，因为你可能无法访问该主机。如果缓存时间太短，负载则会增加，因为你会不断向DNS服务器请求。
- en: So it's kind of a trade off in terms of fault tolerance versus load balancing。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这在容错性和负载均衡之间是一种权衡。
- en: '![](img/193c262c45839f75eb2f216af3003afc_11.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_11.png)'
- en: Okay， so how important is the correct resolution。 Well。 there are people have
    constantly been trying to launch attacks against DNS。 because that way they could
    say， you know， get Wells Fargo。com to resolve to their server。 create a server
    that looks just like it。 And now you're going to connect and think you're connecting
    to your bank when you're not really and then you give up your username and password。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么正确的分辨率有多重要呢？嗯，实际上，有些人一直在尝试攻击DNS。因为这样他们就可以让，比如说，Wells Fargo.com解析到他们的服务器，创建一个看起来完全一样的服务器。这样，你本以为是连接到自己的银行，实际上却并没有，结果你可能会泄露你的用户名和密码。
- en: So a lot of phishing attacks will oftentimes try to work in conjunction with
    a DNS manipulation type of attack。 And it's because DNS really isn't secure。 There
    are a lot of vulnerabilities and substitution attacks that can be launched against
    DNS。 These have happened before back in 2008 there was a major hole in DNS that
    was discovered。 and it was so critical that they had to， you know。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以很多钓鱼攻击常常与DNS篡改类型的攻击协同工作。因为DNS本身并不安全，存在许多漏洞和替换攻击可以用来攻击DNS。这些事情以前就发生过，2008年DNS发现了一个重大漏洞，这个漏洞如此严重，以至于他们不得不紧急修补。
- en: widely say DNS is broken without actually seeing what the vulnerability was
    because they didn't want to leak too much information and allow attackers to start
    using that attack before people could patch their systems。 Now there are other
    protocols like a secure DNS protocol。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 他们广泛地说DNS已经被破解，但实际上并没有明确指出具体的漏洞，因为他们不想泄露太多信息，避免攻击者在其他人修补系统之前就开始利用这个漏洞。现在也有其他协议，比如安全DNS协议。
- en: but it requires a lot of work to actually implement these。 and people have found
    vulnerabilities in those secure DNS protocols too。 So it's a challenge and it
    is a， it is definitely a weak link。 Okay。 So layering is all about building complex
    servers services rather from simpler services。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是实际实现这些防护措施需要大量工作，而且人们在这些安全DNS协议中也发现了漏洞。所以这依然是一个挑战，绝对是一个薄弱环节。好的，层叠架构就是通过构建复杂的服务器服务，逐步从简单的服务发展而来的。
- en: Each layer provides the services that are needed by the higher layers。 and it
    does that by utilizing services that are provided from the lower layer。 It adds
    a layer of a direction。 So if we look down at the physical link layer things are
    really very limited。 right， packets have a very limited size maximum transfer
    unit。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层提供了高层所需的服务。它通过利用低层提供的服务来实现这一点。它增加了一个方向层。因此，如果我们看看物理链路层，事情真的非常有限。对吧，数据包的大小是非常有限的，最大传输单元。
- en: it could be anywhere from 200 bytes if we're dealing with something like dial
    up over a telephony network up to 1500 or 800 bytes for。 a particular network
    like Ethernet routing is limited within a physical link or maybe through a particular
    switch。 So our goal here is to go from， you know， is to use abstraction as we
    have throughout this class to go from the messy physical reality to a more desirable
    abstraction。 So if you look at reality packets have limited is a limited sizes，
    MTU's。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它的大小可以从200字节，如果我们处理的是类似电话网络上的拨号连接，到1500字节或800字节，取决于特定的网络，如以太网，路由通常局限于物理链路内，或者可能通过特定的交换机。因此，我们在这里的目标是利用我们在这门课程中学到的抽象，将混乱的物理现实转化为更理想的抽象。如果你看看现实情况，数据包有大小限制，即最大传输单元（MTU）。
- en: they're unordered sometimes they might be unreliable if， you know， it's a lossy
    wireless link。 They're machine to machine， they only operate on the local area
    network there。 they're asynchronous we never know when they're going to arrive
    or be sent， and it's insecure。 Right。 And the abstraction we want is secure reliable
    messaging。 Right。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是无序的，有时可能不可靠，如果你知道的话，可能是因为无线链路存在丢包情况。它们是机器对机器的，只在局域网内操作。它们是异步的，我们永远不知道它们何时到达或被发送，而且它们是不安全的。对吧。我们想要的抽象是安全可靠的消息传递。对吧。
- en: so arbitrary sizes ordered reliable from process to process。 So from application
    to application。 not just simply from one machine to another machine so one operating
    system to another operating system。 routed anywhere in the world， synchronously
    delivered and secure against。 And so integrity against manipulation， and perhaps
    maybe even authenticated for who sent it。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以大小是任意的，从进程到进程的有序可靠传输。是从应用程序到应用程序的，而不仅仅是从一台机器到另一台机器，从一个操作系统到另一个操作系统。可以在全球范围内路由，按顺序交付，并且能够防止篡改，甚至可能经过身份验证，确认是谁发送的。
- en: '![](img/193c262c45839f75eb2f216af3003afc_13.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_13.png)'
- en: Okay， remember again our packet format here， we're going to look at different
    types of transport protocols。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，再次记住我们的数据包格式，我们将查看不同类型的传输协议。
- en: '![](img/193c262c45839f75eb2f216af3003afc_15.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_15.png)'
- en: So we're going to build a messaging service on top of IP， we want process to
    process communication。 And if you think about what IP gives us is， is just so
    it's like having a postcard that's just delivered to an address。 No name on it。
    And so let's say you've got， you know。 five or six people living in an address
    in a postcard arrives。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要在IP之上构建一个消息服务，我们想要进程到进程的通信。如果你想想IP为我们提供的是什么，其实就像是收到了一张送达地址的明信片，明信片上没有名字。所以假设你知道，某个地址有五六个人住，有一张明信片到达了这个地址。
- en: Who is it from well there's a sending address， and there's a destination address。
    Well the transport layer says who is the person receiving the application。 So
    we want routing from process to process and so what we're going to do is we're
    going to add ports。 So 16 bit destination port a 16 bit source port。 This will
    tell us what is the communication channel。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它来自哪里？有发送地址，也有目标地址。传输层告诉我们谁是接收应用程序的那个人。所以我们想要从进程到进程的路由，因此我们要做的是添加端口。一个16位的目标端口，一个16位的源端口。这将告诉我们通信通道是什么。
- en: and we'll define a communication channel between two applications by what's
    called a five to bowl and that five to bowl consists of the source IP address。
    the source port。 The destination IP address the destination port， and the protocol。
    So in this case。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过所谓的五元组来定义两个应用之间的通信通道，这个五元组由源IP地址、源端口、目标IP地址、目标端口和协议组成。所以在这种情况下。
- en: this is the user data， the unreliable data gram protocol。 And。 and so that defines
    the five to bowl for this， this connection。 With the unreliable data gram protocol，
    we have data grams。 an unreliable packet that gets sent from a source to a destination
    user。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户数据，不可靠的数据报协议。所以这定义了这个连接的五个要素。通过不可靠的数据报协议，我们有数据报。从源到目标用户发送的不可靠数据包。
- en: and the important aspect here is it's relatively low overhead so on top of the
    IP header which was 20 bytes。 We're going to add a few more bytes for our port
    our length or checksum and our port。 Now here's where things get a little complicated。
    But if we go back to our IP picture， right。 there's a 16 bit header checksum here，
    which is over this IP header。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要方面是，它的开销相对较低，因此在 IP 头（20 字节）之上，我们将添加一些字节来表示端口、长度、校验和和端口。现在事情变得有些复杂。但如果我们回到
    IP 的示意图，右边有一个 16 位的头部校验和，它覆盖了这个 IP 头。
- en: '![](img/193c262c45839f75eb2f216af3003afc_17.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_17.png)'
- en: '![](img/193c262c45839f75eb2f216af3003afc_18.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_18.png)'
- en: And now we've added a 16 bit UDP checksum， which is going to be over our， our
    data also。 Okay。 so this type of data gram is oftentimes used for things where
    we want unreliable delivery。 but it might be high bound。 So for example， this
    video connection。 Typically the video。 So my video would be sent over UDP。 My
    audio would also be sent over UDP because it's more important that it get there
    in a timely manner。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们又添加了一个 16 位的 UDP 校验和，它将覆盖我们的数据。好的，这种数据报通常用于那些我们希望不可靠传输的情况，但它可能是高带宽的。例如，视频连接。通常，视频和音频都会通过
    UDP 发送，因为它更重要的是按时送达。
- en: and that it be reliable so there may be some losses or maybe some， some gaps。
    And so screen sharing that's kind of less synchronous and so that oftentimes might
    be set sent over TCP because you want a nice clear picture so you can read all
    of the words that are on it。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能不可靠，因此可能会丢包或出现一些空白。所以，屏幕共享通常是较不同步的，因此这类信息通常会通过 TCP 发送，因为你希望能够看到清晰的图像，以便能阅读上面的所有文字。
- en: And so zoom actually gives you the option of whether you want screen sharing
    done over UDP or you want it done over TCP。 UDP allows you to just like kind of
    blast these high bandwidth communications。 And so it's not really very， it's kind
    of anti social。 It's not friendly to other applications that might simultaneously
    be trying to use the same network。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 Zoom 实际上给了你一个选项，选择是否通过 UDP 进行屏幕共享，或者通过 TCP 进行。UDP 允许你以一种爆发式的方式进行高带宽通信。因此，它并不是很“社交”，对其他可能同时使用同一网络的应用程序不太友好。
- en: It's UDP is just going to send it whatever the rate the sender sending it。 That's
    the right we're going to push it through the network so really the sender controls
    how it's using the network and ignores other users in the network。 TCP will see
    on the other hand tries to be more social and well behaved when a network gets
    congested。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 会根据发送方的发送速率直接发送数据。我们会按照这个速率将数据推送通过网络，所以发送方控制着如何使用网络，忽略网络中的其他用户。另一方面，TCP
    会尝试在网络拥堵时变得更加“社交”和“守规矩”。
- en: '![](img/193c262c45839f75eb2f216af3003afc_20.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_20.png)'
- en: Okay， so the Internet architecture really has kind of five layers from the application
    transport network data link to physical。 the lowest three layers we implement
    everywhere。 Right。 so the physical layer connects hosts and routers， and other
    routers。 the data link connects hosts and routers and other routers switches everything。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，互联网架构实际上有五个层次，从应用层、传输层、网络层、数据链路层到物理层。最低的三层我们在各处都实现。对，物理层连接主机和路由器，以及其他路由器。数据链路层连接主机和路由器，以及其他路由器交换机。
- en: The network layer again is used at hosts and routers it's not used at switches
    typically。 So switches might only implement the lower two， and the application
    and transport layers only get implemented at hosts。 And so this is where our sockets
    get implemented when we have a connection。 we have going down all the way the
    stack across to appear then all the way back up。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层再次用于主机和路由器，通常不在交换机上使用。因此，交换机可能只实现了最低的两层，而应用层和传输层仅在主机上实现。所以，当我们建立连接时，套接字就会在这里实现。我们将一直向下走，直到堆栈的最底层，再向上返回。
- en: back down across to appear， and then all the way back up until we deliver。 So。
    in most cases this is how things work。 People break the end to end principle。
    and sometimes implement functionality in the in the routers。 So， for example。
    caching in the network of content。 That would be applications that effectively
    are running inside the network instead of running end to end。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从头到尾再到一端，然后一直回到上面直到交付。所以，在大多数情况下，这就是事情的运作方式。人们有时会打破端到端原则，并在路由器中实现功能。例如，内容的网络缓存。那将是有效地在网络中运行的应用程序，而不是端到端运行的。
- en: And to trade off， you know， and then principle says we should only do that at
    the end。 but we'll do it sometimes in the network because we get efficiency and
    bandwidth benefits and latency benefits also。 Okay。 So， we can think about layering
    as putting packets in an envelope。 So an application has some data and wants to
    send from one application to another application。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了权衡，原则上我们应该只在最后一步执行这个操作。但在网络中我们有时会这么做，因为这样做能带来效率、带宽和延迟的好处。好的。所以，我们可以把分层看作是把数据包放进信封。一个应用程序有一些数据，想要从一个应用程序发送到另一个应用程序。
- en: And so it's going to take that app that data， it's going to put it in a transport
    layer envelope that adds a transport header。 which is used by the transport layer。
    The transport layer is going to put it in another envelope。 Right， so it's like
    you get a letter from someone and then you take it and you put it into a bigger
    envelope address to someone else。 Right。 And so that's the， adds a network header
    to that。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它将把应用程序中的数据放入一个传输层的信封中，添加一个传输头部，这个头部由传输层使用。传输层会把数据放入另一个信封中。对，像是你收到一个人的信件，然后你把它放进一个更大的信封里，寄给另一个人。对，这样它就会添加一个网络头部。
- en: And then the network layer takes that set of envelopes and puts it into another
    envelope and adds the frame header that we need for the data link layer。 and then
    we encode it into the ones and zeros that we need for the physical layer。 So again。
    the challenge here and this is why， you know， the layering has huge benefits。
    but you can also see and this is not the scale that you know let's say this is
    a small amount of data that we're trying to send。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后网络层将这些信封放入另一个信封中，添加我们在数据链路层所需的帧头部，然后我们将其编码为物理层所需的“0”和“1”。所以，再次强调，这就是为什么分层有巨大好处，但你也可以看到，这并不是一个你能轻松缩放的场景，假设我们试图发送的数据量很小。
- en: We're putting a lot of header information on that relatively small amount of
    data。 And so the efficiency that we're going to get at our physical layer could
    be very limited。 if mostly what we're sending is header and not data。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在相对较少的数据上添加了大量的头部信息。所以我们在物理层能够获得的效率可能会受到很大限制，尤其是当我们发送的大部分是头部而非数据时。
- en: '![](img/193c262c45839f75eb2f216af3003afc_22.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_22.png)'
- en: Okay。 So the data gram service is basically a no frills extension of best effort
    IP so instead of sending packets now we can send longer packets。 They're bigger
    than the MTU that we might have at the lowest data link layer。 and it handles
    the multiplexing and demultiplexing of these packets to processes at the end house。
    So we're able to send between two processes， these longer messages。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以数据报服务基本上是最简化的、扩展了的尽力而为IP，相比发送数据包，我们现在可以发送更长的数据包。它们比我们在最低数据链路层可能遇到的最大传输单元（MTU）要大，并且它能够处理这些数据包到端点进程的复用和解复用。所以我们能够在两个进程之间发送这些较长的消息。
- en: TCP the transmission control protocol gives us reliable in order delivery。 And
    so that gives us connection setup and tear down deals with packets that might
    be corrupted packets that might be lost flow control congestion controls we don't
    overload the receiver。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: TCP（传输控制协议）为我们提供了可靠的有序传输。所以它为我们提供了连接的建立与拆除，处理可能被损坏的包、可能丢失的包、流量控制、拥塞控制，避免我们超载接收端。
- en: and so that we don't overload the network。 So there's a question between what's
    the difference between the data link layer and the physical layer so the physical
    layer is the ones and zeros。 the data link layer is the protocol that we use to
    access the media。 So when we're speaking。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就不会超载网络。关于数据链路层和物理层之间有什么区别，物理层是“0”和“1”。数据链路层则是我们用来访问媒体的协议。所以，当我们发声时。
- en: our physical layer is our vocal cords， making us phonemes and our ears。 hearing
    those phonemes receiving them。 And so data link equivalent would be raising your
    hand because you have a question that you want to ask or something that allows
    us to do media access control between people and then also like。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的物理层是我们的声带，制造音素，而我们的耳朵则是接收这些音素。数据链路层的等效操作可能是举手提问，或者其他让我们在人与人之间进行媒体接入控制的方式。
- en: you know， saying your name， so that you know I'm talking to you in a in a group
    as opposed to just broadcasting something。 Okay， other examples of of internet
    transport protocols that nobody actually uses are but you know there are standards
    for it are the data gram congestion control protocol。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，像说出你的名字，这样你就知道我在群体中是在跟你说话，而不是只是广播一些内容。好的，其他一些没有人实际使用但有标准的互联网传输协议包括数据报拥塞控制协议。
- en: the reliable data protocol， and the stream control transmission protocol。 But
    those aren't used。 Okay， so remember how sockets work as a concept we at the server
    created a server socket bind it to an address。 So now you know where you know
    that that host IP address and port come from。 we listen for connection， and then
    we'll use the， call to accept a connection when the client which also created
    a socket connected it to that host and port that we had bound the server socket
    to。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠数据协议和流控制传输协议。但是这些协议并没有被使用。好的，记住套接字是如何工作的，作为一个概念，我们在服务器端创建了一个服务器套接字，并将其绑定到一个地址。现在你知道了那个主机的IP地址和端口是从哪里来的。我们监听连接，然后在客户端也创建了一个套接字，并将其连接到我们绑定到的服务器套接字的主机和端口时，我们会使用调用来接受连接。
- en: then that creates a connection socket。 And that allows us to write requests。
    read those requests writer response read those response。 Okay。 so when we're talking
    about reliable message delivery we're talking about how do we make this connection
    work properly that socket connection。 Okay， so the problem。 Well， we just went
    through them right physical networks， they can garble。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这就创建了一个连接套接字。它允许我们写入请求，读取这些请求，写入响应，读取这些响应。好的，当我们谈论可靠消息传递时，我们是在讨论如何让这个连接正常工作，即套接字连接。好的，那么问题是，我们刚才讲过它们，物理网络，它们可能会出现乱码。
- en: they can drop or lose packets right at the physical layer packet might not be
    transmitted or received。 you know， if we're transmitting at the maximum rate，
    we get more throughput。 but we might have more error。 And so higher error rate
    and so some packets might get corrupted or lost。 And we transmitted sort of the
    best power per bit。 So at a really low power level。 Well， you know。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以在物理层丢弃或丢失数据包，数据包可能无法传输或接收。如果我们以最大速率进行传输，我们会得到更多的吞吐量，但可能会有更多的错误。因此，错误率更高，一些数据包可能会被损坏或丢失。而我们以每比特最佳功率进行传输。在一个非常低的功率水平下。嗯，你知道的。
- en: error correction， you know， might be able to correct some of the errors。 If
    the if we have a physical encoding that includes error correction。 but it might
    not be able to correct all of them。 And so again。 we'll have some garbling or
    loss of packets。 And so the suggestion means we might not have any place to put
    an incoming packet。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 错误校正，你知道，可能能够纠正一些错误。如果我们有一个包含错误校正的物理编码，可能无法纠正所有错误。因此，依然会有一些乱码或丢包的情况。所以，这意味着我们可能没有地方接收一个传入的数据包。
- en: Right， think about your phone it's kind of relatively weak processor in it in
    comparison to a web server that might be sending。 you know， at a very high rate。
    If it sends it to higher rate。 you're not going to have enough buffer space on
    your phone in the operating system and so it's just going to drop packets。 And
    so we're going to have a network。 So you might have insufficient queue space it
    switches and routers broadcast link。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对，想想你的手机，它的处理器相对较弱，相较于可能以非常高的速率发送数据的Web服务器。如果它以更高的速率发送数据，你的手机的操作系统中的缓冲空间就不够了，因此它会丢弃数据包。所以，我们会有一个网络，你可能在交换机和路由器上有不足的队列空间，广播链路。
- en: you might have two hosts that are simultaneously trying to use the link so two
    hosts that speak at the same time。 And receivers are just going to hear like some
    superposition of that signal and they're not going to be able to distinguish it。
    Again， any network where there's insufficient buffer space and if a sender is
    fast sending faster than a receiver can can process。 So we want to build reliable
    message delivery on top of these unreliable packets， these IP packets。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有两个主机同时尝试使用链路，即两个主机同时发送数据。接收方会听到这个信号的叠加，而无法区分它们。再次强调，任何网络中如果缓冲区空间不足，而发送方的发送速度快于接收方的处理速度，就会出现这个问题。所以我们希望在这些不可靠的数据包——这些IP数据包之上构建可靠的消息传递。
- en: So we need some way to make sure that packets actually make it to the receiver
    and we'd like exactly once。 So every packet is received at least once， and every
    packet is received at most ones。 Now if we want to combine this with ordering
    and say something even stronger that every packet is received by a process at
    a destination。 exactly once， and in order。 And so this is what the transmission
    control protocol or TCP provides this way。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要某种方式来确保数据包确实能够到达接收方，并且我们希望每个数据包只接收一次。因此，每个数据包至少接收一次，且最多接收一次。如果我们想要结合顺序，并说得更强一些，每个数据包由目标的进程接收，且**只接收一次**，并且按顺序接收。那么，传输控制协议（TCP）就提供了这种方式。
- en: So we have a stream of bytes that we send in。 They go through routers switches
    more switches more routers more switches。 and at the destination process， we get
    a stream out。 So it's a reliable byte stream between two processes on different
    machines over the Internet。 And we can do read， write and flush， just as we could
    do to a file or local IPC。 So some details。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个字节流要发送出去。它们通过路由器、交换机、更多的交换机、更多的路由器和交换机，到达目的地进程时，我们得到一个字节流。所以这是一个在不同机器上的两个进程之间通过互联网传输的可靠字节流。我们可以进行读、写和刷新，就像对文件或本地IPC进行操作一样。所以一些细节。
- en: TCP has to take this byte stream and fragmented into IP packets and then into
    packets handed to IP and IP may turn around and break it up into further packets。
    fragments rather based on the maximum transmission units。 It uses a window based
    acknowledgement protocol and this is a way of minimizing the state that we need
    to maintain at the sender and also the state we have to maintain at the receiver。
    The window is kind of a reflection of how much storage we have at the receiver。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: TCP必须将这个字节流分段成IP数据包，然后交给IP，IP可能会再次将其拆分成更多的数据包，基于最大传输单元进行分片。它使用基于窗口的确认协议，这是最小化我们需要在发送方和接收方维护的状态的方式。窗口反映了接收方有多少存储空间。
- en: because we don't want the sender to overrun the receivers buffer space。 But
    the window window also has to reflect the speed and the capacity of the network。
    We don't want to overload the network。 Also， it takes time。 Speed of light is
    finite。 And so it takes time for the traffic we inject in the network to actually
    reach the sender。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望发送方超出接收方的缓冲区空间。但是窗口窗口也必须反映网络的速度和容量。我们不想让网络过载。同时，光速是有限的。因此，我们注入网络的流量需要时间才能真正到达发送方。
- en: And so we want to make sure that's not going to overload the sender either。
    It handles automatically retransmitting any packets that are lost or garbled。
    And it tries to adjust its rate of transmission to be a good citizen。 So unlike
    UDP， which。 you know， if I just start blasting packets out in UDP， I can blast
    whatever rate I want。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们要确保不会超载发送方。它会自动重新传输任何丢失或损坏的数据包。并且它试图调整其传输速率，成为一个好的网络公民。所以与UDP不同，如果我只是开始在UDP中发送数据包，我可以按我想要的速率发送。
- en: And the network， you know， could easily become overloaded。 and other clients
    could see their traffic impacted by my UDP streams。 TCP tries to figure out who
    else is transmitting what is the available capacity and adjust itself to fit within
    that available capacity。 So it tries to be a good citizen。 Okay， so let's look
    at the problem with drop packets。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，您知道，可能会轻易过载，其他客户端可能会看到它们的流量受到我的UDP流的影响。TCP试图弄清楚还有谁在传输数据，什么是可用的容量，并调整自身以适应这个可用容量。因此，它试图成为一个好的网络公民。好的，我们来看一下丢包问题。
- en: So all physical networks， they can garble， they can lose packets， right。 it
    could be hardware issues。 And so IP， because it's built on those physical links
    can garble or drop packets and it doesn't repair it。 Right， so IP doesn't try。
    The only thing IP does is its header looks at the check。 it's header checksum
    just looks at the checksum for the header。 Right。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有物理网络都可能发生干扰，丢包，对吧？这可能是硬件问题。因此，IP由于基于这些物理链路，也可能发生干扰或丢包，并且不会进行修复。对吧？所以IP并不会尝试修复。IP唯一做的事情就是它的头部查看校验。它的头部校验和仅查看头部的校验和。对吧。
- en: and so if that gets corrupted， you know， then， you know。 we're going to throw
    away the packet because we can't route it。 But otherwise。 the packet could be
    damaged and it's up to the application to figure out what to do。 because that's
    the end to end principle。 And again。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据被损坏，您知道，我们会丢弃这个数据包，因为我们无法路由它。但如果没有损坏，数据包可能会受损，应用程序需要判断如何处理它。这是端到端原则。而且，再次强调。
- en: that's important because we want protocols like UDP。 because sometimes we're
    willing to accept damaged or corrupted packets and still try to decode them。 use，
    you know， for example， an audio codec that can handle corruption or。 use a video
    codec that can handle corruption。 So you still see something。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们希望使用像UDP这样的协议，因为有时我们愿意接受损坏或腐败的包裹，并仍然尝试解码它们。你可以使用，例如，能处理损坏的音频编解码器，或者使用能处理损坏的视音频编解码器。这样你仍然能看到一些内容。
- en: it might be a garbled frame or you hear something that's a little garbled。 but
    you get it instead of simply just having silence and missing all of the context
    and contents and information。 Okay， so we need reliable message delivery。 Make
    sure packets are integral。 Their integrity is preserved and make sure they arrive
    exactly once。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能是一个损坏的帧，或者你听到的内容有点混乱，但是你收到了它，而不是简单地让它消失，错过了所有的上下文、内容和信息。好的，因此我们需要可靠的消息传递，确保包裹是完整的，它们的完整性得以保存，并且确保它们只会到达一次。
- en: So we can do this by using acknowledgments。 Right。 so we're going to have checksums
    that will detect whether this packet gets garbled when we send it from a to B。
    And if it's garbled， we simply discard it。 If it's okay， then we'll send back
    an acknowledgement。 And that tells the sender that we correctly received this
    packet。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用确认来实现这一点。对的，我们会有校验和，用来检测当我们从A发送包裹到B时，包裹是否被损坏。如果被损坏，我们就丢弃它。如果没问题，我们就会发送确认回去，告诉发送方我们正确地接收了这个包裹。
- en: Now if we send it in the packet gets corrupted and so we rejected it B or the
    network loses it。 then there'll be a timeout so a starts a timer so when you send
    a packet。 start a timer that timers running， if you don't get an acknowledgement
    within that window of that timeout。 then you'll just simply retransmit the packet
    and again start the timer again and wait for the acknowledgement。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们发送的包裹被损坏，或者网络丢失了它，那么就会发生超时，因此A会启动一个计时器。当你发送一个包裹时，启动计时器，这个计时器在运行。如果在超时窗口内没有收到确认，则会简单地重新发送包裹，并重新启动计时器，等待确认。
- en: So there's some questions that should pop into mind when I say something like
    this。 So the first is。 doesn't mean if the sender doesn't get an acknowledgement
    that the receiver did not get the original message。 So it could be。 Right， but
    not necessarily。 Right。 it could be no right because the acknowledgement itself
    is a packet sent unreliably。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我说这些时，应该有一些问题出现在你脑海中。第一个问题是，发送方如果没有收到确认，是否意味着接收方没有收到原始消息？这可能是对的，但不一定是对的。它也可能是错误的，因为确认本身就是一个不可靠发送的包裹。
- en: And so it could get lost。 Right， so it's sort of like I send you a postcard。
    And you send me back a postcard and the post office treats postcards is like the
    lowest of priority and it gets stuck in machines and。 you know， get lost in the
    carriers bag and， and so that acknowledgement。 And so。 that's the data gram that
    comes back， could just get lost。 Right。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所以包裹可能会丢失，对吧？这有点像我给你寄了一张明信片，然后你也给我寄回了一张明信片，而邮局把明信片当做最低优先级，卡在了机器里，或者你知道的，丢失在了运输员的包里。所以那个确认，它是回传的数据报，可能就这样丢失了。
- en: Or it could be the case that it gets delayed。 And so I do send back the acknowledgement。
    but that acknowledgement comes after the timeout period。 And so you've already
    started the。 by retransmitting the packet。 And then the sender doesn't get the
    acknowledgement。 it just simply retransmits。 And then the receiver is going to
    get the message twice and have acknowledged each one of those。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可能是因为包裹被延迟了。因此我确实发送了确认，但这个确认是在超时期后才到达的。这样你已经开始了，通过重新发送包裹。然后发送方没有收到确认，它只是简单地重新发送。接着接收方会收到两次消息，并确认了每一次。
- en: Okay， so let's look at a protocol that we could use。 This protocol is called
    stop and wait。 we'll look at this in the context， first of the case where we don't
    have any packet loss。 So we're going to send， and then wait for an acknowledgement。
    Okay， and then repeat。 So we send packet one， we get an acknowledgement for packet
    one。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看可以使用的一个协议。这个协议叫做停止等待协议。我们首先在没有包裹丢失的情况下来看这个协议。我们发送一个包裹，然后等待确认。好的，然后重复这个过程。我们发送包裹1，接收到包裹1的确认。
- en: So this time between when we send the packet， it goes to the receiver。 and we
    get a response is called the round trip time。 And that is the time it takes the
    packet to travel from the sender to the receiver and back。 Right。 Now， the one
    way delay， if you can think about it is going to be D。 Right。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们发送数据包的时间，它到达接收方，并且我们收到回应的时间被称为往返时延。这是数据包从发送方到接收方再返回所需的时间。对吧？现在，单程延迟，如果你考虑的话，就是D。对。
- en: so that's the delay from the sender to the receiver。 And if it's symmetric，
    the links that we have。 then in terms of latency， then the round trip time is
    going to be twice this one way delay。 Right。 So now we send our second packet。
    Right， and we get our second acknowledgement back。 Okay。 and then we can send
    our third packet。 And we'll get our third acknowledgement back。 Right。 So now。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是从发送方到接收方的延迟。如果它是对称的，也就是我们拥有的链接在延迟方面是对称的，那么往返时延将是单程延迟的两倍。对吧？所以现在我们发送第二个数据包。对，然后我们得到第二个确认回来。好的。然后我们可以发送第三个数据包。我们会收到第三个确认。对吧？所以现在。
- en: how fast can we send data with this kind of approach。 Well， think about it。
    What we can use is a law called little's law that we can apply to the network。
    It says that n equals B times the round trip time。 So for stop and wait， we have
    one packet in flux。 Right。 There's one packet。 We send a packet， wait for a response
    round trip time。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用这种方式能多快地发送数据呢？嗯，想一想，我们可以使用一个叫做小定律的法则，它可以应用于网络。它表示n等于B乘以往返时延。所以对于停止等待协议，我们只有一个数据包在传输中。对，我们发送一个数据包，等待一个往返时延的响应。
- en: and we send the next packet。 So our bandwidth is going to be one packet for
    round trip time。 So this means that our bandwidth depends on latency， not the
    capacity of the network。 Right。 so imagine we have a 10 gigabit connection between
    Berkeley and Paris。 Right。 that's very high latency。 That could be， you know，
    a couple hundred milliseconds。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们发送下一个数据包。所以我们的带宽将是每个数据包的往返时延。这意味着我们的带宽取决于延迟，而不是网络的容量。对吧？想象一下，我们有一条10千兆比特的连接，连接伯克利和巴黎。对吧？这非常高的延迟。那可能是，嗯，几百毫秒。
- en: And we're not going to be able to send at anywhere near the capacity of that
    10 gigabit link between Berkeley and Paris。 Okay。 So suppose as an example， our
    round trip time is 100 milliseconds。 and one packet is 1500 bytes in size。 Then
    our throughput。 our bandwidth for the network is going to be 1500 over 0。1， which
    is 120 kilobits per second。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在伯克利和巴黎之间那条10千兆比特链接的容量范围内发送数据。好的。假设作为一个例子，我们的往返时延是100毫秒，而一个数据包的大小是1500字节。那么我们的吞吐量，网络带宽将是1500除以0.1，也就是120千比特每秒。
- en: So again， if we have 100 megabit per second link， we're only using 120 kilobits
    per second of that capacity。 So we're using a tiny fraction of the capacity of
    that link。 So loss recovery here relies on timeouts。 All right， so we have our
    round trip time。 and we're going to add something to our round trip time to calculate
    what our time out value would be。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再说一遍，如果我们有100兆比特每秒的链接，但我们只使用了120千比特每秒的容量。那么我们只用了这条链接容量的极小一部分。所以，丢包恢复在这里依赖于超时机制。好的，所以我们有了往返时延，我们将往返时延再加上一些东西来计算超时时间。
- en: You know， maybe here it's 50%。 So 1。5 times our round trip time。 And so if we
    don't get our acknowledgement， either because the packet didn't get delivered
    or the acknowledgement didn't get delivered。 we're going to time out and then
    retransmit the packet。 So how do we choose a good timeout value？
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，也许这里是50%。也就是1.5倍的往返时延。因此，如果我们没有收到确认，无论是因为数据包没有成功传输，还是确认没有传回，我们都会超时并重新传输数据包。那么我们如何选择一个合适的超时时间值呢？
- en: Well， too short， right， if we made it， you know， just a little， you know， right。
    just a little bit over the round trip time， or maybe exactly the round trip time。
    Well。 there's going to be a little bit of variability， because there may be other
    congestion and traffic in the network。 which is going to cause us to， you know，
    exceed that round trip time， and that timeout。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，太短了，不对。如果我们设定的超时时间仅仅是稍微超过往返时延，或者可能正好是往返时延的话。嗯，实际上会有一点波动，因为网络中可能存在其他的拥塞和流量，这会导致我们超过往返时延，从而触发超时。
- en: our average round trip time and time out。 And then we're going to be retransmitting
    a lot。 Right。 so that'll lead to a lot of duplication。 We said， set it too long。
    Let's say we said it all the way around， you know， down here。 then we're going
    to have a lot of disruption when there's a packet loss。 Right。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的平均往返时间和超时。然后我们会进行大量的重传。对，这会导致大量的重复发送。我们说过，超时时间设得太长会怎样。假设我们把它设置得非常长，你看，这样一来在发生数据包丢失时就会出现很多干扰。对。
- en: because it's going to take us a long time to realize that the packet has been
    lost。 and to actually transmit it。 Now， how do we deal with the fact that if we
    set our timeouts too short。 we're going to resend packets before they， we get
    the acknowledgement for that packet so we'll send packet one twice。 or like in
    this case， right there， acknowledgement gets lost。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们会花很长时间才意识到数据包丢失，并且实际进行重传。那么，如何处理超时时间设置得太短的问题呢？这样我们就会在收到确认之前重新发送数据包，所以我们会重复发送数据包一。或者就像在这种情况下，确认消息丢失。
- en: but the packet was actually correctly received。 So， we transmission means this
    can happen。 And so a particular approach that we could use is just simply to put
    a sequence number in a message to identify we transmitted packets。 Right， so the
    receiver is just going to check for duplicate numbers and it gets a duplicate
    message。 It'll just simply discard that message。 Right， so the requirements here
    are the sender keeps a copy of any messages that have not been acknowledged。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上数据包已经正确接收。所以，传输意味着这种情况可能会发生。因此，我们可以使用的一个特定方法就是在消息中简单地添加序列号来标识我们发送的包。对，接收方只需要检查是否有重复的序列号，若收到重复的消息，它将简单地丢弃该消息。对，因此这里的要求是发送方保留任何尚未确认的消息副本。
- en: Right， and that's easy， you just， you buffer those messages。 and just retain
    the buffer until you get an acknowledgement。 and the receiver tracks possible
    duplicate messages。 So this is a little bit hard。 Right。 because when is it okay
    to forget about a received message to forget that I actually received a particular
    message。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对，这很简单，你只需要缓存那些消息，并且在收到确认之前保持缓存。接收方则跟踪可能的重复消息。因此，这有点复杂。对，因为什么时候忘记一个已接收的消息是可以的呢，什么时候可以忘记我实际上已经接收到某条特定的消息？
- en: Right， so here's an alternating bit protocol where you send a message。 At a
    time。 and you don't send the next message until you get an acknowledgement。 Right。
    and so the sender just keeps track of the last message。 and at the receiver they
    just simply need to track the sequence number of the last message that was received
    so you send it back and zero。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个交替位协议，你发送一个消息，逐个发送，直到收到确认才发送下一个消息。对，发送方只需跟踪最后一条消息，接收方只需简单地跟踪最后一条接收到的消息的序列号，然后将其返回并置为零。
- en: You acknowledge zero， you send packet one， you acknowledge one， you send packet
    zero。 you acknowledge zero。 The advantages， this is simple。 and it has low overhead
    it's a single bit that we need to keep track of that sequence number。 The downside
    though is that if the network could arbitrarily delay messages or duplicate messages
    arbitrarily。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你确认零，发送数据包一，你确认一，发送数据包零，你确认零。这有一个优点，这个方法简单，而且开销低，我们只需要跟踪一个序列号。缺点是，如果网络可能任意延迟消息或任意重复消息时，就会出现问题。
- en: then we might get this packet zero but it's actually this packet zero and so
    we can't tell the difference between is this a new packet zero。 or is this a duplicate
    of that packet zero， or if we didn't receive packet zero and we see packet one
    right so you can see。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可能会收到这个数据包零，但它实际上是数据包零，因此我们无法判断这是一个新的数据包零，还是这个数据包零的重复，或者如果我们没有收到数据包零却看到了数据包一，情况就是这样。你可以看到。
- en: there can be a number of different cases where we end up not being able to tell
    whether we're getting a new message or we're getting a duplicate of an old message。
    So there's lots of advantages of moving away from stop and wait right if we have
    a larger space of acknowledge of acknowledgments。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有多种情况，导致我们无法判断是收到了一条新消息，还是收到了一条旧消息的重复。因此，如果我们拥有更大的确认空间，脱离停止等待协议会有很多优点。
- en: then we can pipeline。 Right， so we can send multiple messages。 Right。 while
    we're waiting for those acknowledgments to come in。 Right。 so the acknowledgments
    serve dual purposes。 One is they confirm that a packet was received。 And they
    provide us with ordering， right， because packets could be reordered at the destination。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可以进行流水线处理。对的，所以我们可以发送多个消息。在等待确认消息到来时。对，确认消息有双重作用。一是确认数据包已被接收。二是提供排序信息，因为数据包可能在目的地被重新排序。
- en: and so we might receive packet one， before we receive packet zero。 So we might
    receive acknowledgement one before we receive acknowledgement zero。 But if we
    have sequence numbers， you know， that are large enough space。 then we can differentiate
    between messages that are duplicated messages that arrive out of order。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可能会先收到数据包 1，而不是先收到数据包 0。我们可能会先收到确认消息 1，而不是先收到确认消息 0。但如果我们有足够大的序列号空间，那么我们就可以区分重复的消息和顺序错乱的消息。
- en: and we can reorder those at the receiver， and avoid having to retransmit them
    from the sender。 So now how much data can we have in flight。 So going back to
    little law， right。 our sending window is going to be around trip time times our
    bytes per second。 So our send a sender's window size， tells us the number of packets
    that we're going to have in flight。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在接收方重新排序这些数据包，避免从发送方重新传输它们。那么我们能在传输中的数据量是多少呢？回到小法则，对的。我们的发送窗口将是往返时间乘以每秒字节数。所以，发送方的窗口大小告诉我们传输中的数据包数量。
- en: Right， so the packets in flight would be the window size divided by the size
    of those packets。 So how long does the sender have to keep the packets around。
    Right。 so how much buffer space is the sender going to need that's one question
    we can ask another question we could ask is how long does the receiver have to
    keep the packets data to let the sender know yes。 you know， if the， sender tries
    sending it again yeah I've already received that。 Right。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对，所以正在传输的数据包数量将是窗口大小除以数据包的大小。那么发送方需要保留这些数据包多长时间？对的，发送方需要多少缓冲区空间，这是我们可以提出的一个问题。另一个问题是接收方需要将数据包数据保留多长时间，以告知发送方：“是的，你知道的，如果发送方重新发送，实际上我已经收到了。”对的。
- en: and what if the sender is sending packets faster， then the receiver can process
    the data。 Right。 and so it's if this floods the receiver and the receiver right
    around here runs out of buffer space。 you know， then all of these packets that
    were sent were sent kind of in vain。 because they're going to have to be repeated
    anyway because the receiver dropped those packets on the floor。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果发送方的发送速度比接收方处理数据的速度快呢？对的。如果这导致接收方溢出，并且接收方在这里大致没有了缓冲区空间，那么所有这些已发送的数据包就有点白费了。因为它们将不得不被重新发送，因为接收方已经丢弃了这些数据包。
- en: '![](img/193c262c45839f75eb2f216af3003afc_24.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_24.png)'
- en: So， remember when we have communication between processes， we have this in memory
    queue。 Right。 and so you write into the queue as a producer and the consumer process
    be here is reading from that queue。 and the queue has a fixed capacity。 So if
    this process a exceeds the capacity of that queue。 then we block it。 Right。 And
    similarly， if this process be this consumer is trying to read from this queue
    and it's empty。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，记住当我们在进程之间进行通信时，我们会有这个内存队列。对的。所以你作为生产者会写入队列，而消费者进程 B 在这里从队列中读取。并且这个队列有固定的容量。如果进程
    A 超过了队列的容量，那么我们就会阻塞它。对的。同样地，如果消费者进程 B 试图从队列中读取数据，而队列是空的。
- en: it'll wait， it'll block。 Right， so posits provides this in the form of pipes。
    So when we think about buffering in a TCP connection， right。 so we have a host
    here with process a there's a queue of packets that are outgoing and process be
    we have a receive queue of packets that have been received。 but not yet consumed
    by the process， So you can see we've taken that sort of single queue that we had
    in in a Unix environment。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它会等待，它会阻塞。对，所以 posits 通过管道的形式提供这个功能。所以当我们考虑 TCP 连接中的缓冲时，我们有一个主机，这里有进程 A，它有一个待发送的数据包队列，而进程
    B 有一个接收队列，用于存放已经接收但尚未被进程消费的数据包。所以你可以看到，我们已经将原本在 Unix 环境下的单一队列，扩展成了这种形式。
- en: we've now split it into two queues， a queue at the sender for outgoing packets。
    and a queue with the receiver for packets that have been received， but not yet，
    process。 So process a sends in the send queue the packets get sent across the
    network received。 and then they get sent to process be。 So this is bidirectional。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将其分成两个队列，一个是发送方的队列，用于外发数据包；另一个是接收方的队列，用于已接收但尚未处理的数据包。所以进程A将数据包放入发送队列，数据包会穿过网络被接收，然后发送到进程B。因此，这是双向的。
- en: because we're going to send the response back from host to in a send queue。
    packetize that receive queue， and then that goes to process a。 So there's a separate
    pair of queues per TCP connection。 So every TCP connection has both a receive
    queue and a send queue associated with it。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要将响应从主机发送回发送队列。将接收队列进行数据包化，然后它会传递给进程A。所以每个TCP连接都有一对独立的队列。因此，每个TCP连接都有与之关联的接收队列和发送队列。
- en: So we need four in memory queues to at each of the house to buffer sends in
    one direction。 and to buffer receives in the other direction or from the other
    perspective of that that connection。 Okay， so the window size is the space that
    we have in this more receive queue， right。 how much remaining space we have in
    that receive queue and a host is going to advertise this window size in every
    TCP packet it's in so everything。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要四个内存队列，每个主机有两个队列，用来缓冲一个方向的发送和另一个方向的接收，或者从该连接的另一角度看。好的，窗口大小是我们在接收队列中剩余的空间，对吧？也就是接收队列中的剩余空间，主机将在每个TCP包中宣告此窗口大小，所以每个数据包都会如此。
- en: It's sending back all those acknowledgments and any outgoing traffic is going
    to say， hey。 this is how much space I have in my buffer don't overrun it。 So the
    center is never going to send more than what the receiver。 It's advertised window
    sizes。 even if the network link would support sending much more data。 Right。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它会发送所有这些确认消息，并且任何外发流量都会说，“嘿，这是我缓冲区中的可用空间，别超出它。”所以发送方永远不会发送超过接收方所宣告的窗口大小的数据。即使网络链路支持发送更多的数据，也不行。对吧。
- en: so we're going to bound the amount of data that'll be in flight by the receive
    queue。 All right。 so the set we use a sliding window protocol and the sender knows
    that it should never exceed the windows receiver with window size。 and it。 But
    packets that it previously sent might arrive and then fill the window size。 So
    as a result， it needs to ensure that the number of sent by but unack acknowledged
    bytes is less than the advertised window side so that's going to include any packets
    that are in flight。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将通过接收队列来限制飞行中的数据量。好的，我们使用滑动窗口协议，发送方知道它永远不能超过接收方窗口大小所宣告的窗口大小。但之前发送的数据包可能会到达并填满窗口大小。因此，发送方需要确保已发送但未确认的数据字节数少于宣告的窗口大小，这将包括所有飞行中的数据包。
- en: To that receiver。 They're considered in flight because the receiver has not
    acknowledged yet that it has received those。 those bites。 So we can send new packets
    as long as the sent but unack acknowledged packets haven't already filled that
    advertised window side so that's。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对接收方来说，它们被视为飞行中的数据包，因为接收方尚未确认已经接收到这些字节。所以我们可以发送新的数据包，只要已发送但未确认的数据包没有填满宣告的窗口大小即可。
- en: that's the way of getting around the fact that， you know。 because there's speed
    of light and round trip times and and delay。 We could have a lot of packets in
    flight， and we don't want the receiver saying， hey， I'm full。 you know， by the
    time that gets back to the sender the sender is already overrun。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了绕过这样一个事实：你知道的，因为存在光速、往返时间和延迟。我们可能有很多数据包在飞行中，而我们不希望接收方说，“嘿，我满了。”你知道，当这些数据包返回到发送方时，发送方已经溢出了。
- en: So it's going to keep track of what it's already sent in into the network。 Okay。
    so here's an example with a window size of three packets。 and the window size
    to fill the link is given by W times the bandwidth packets per second times the
    round trip time so little's law comes into play。 Once again， now for TCP， the
    window is in bites， not in packets because it's it's bites in the buffer。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它将跟踪已经发送到网络中的数据。好的，下面是一个窗口大小为三个数据包的示例。填满链路的窗口大小由W（带宽）乘以每秒数据包数再乘以往返时间给出，所以小法则再次起作用。现在对于TCP，窗口大小是以字节为单位，而不是数据包，因为它是在缓冲区中的字节。
- en: So we have unacknowledged packets that the sender is sent。 we have out of sequence
    packets that might be in the receivers window because again the network can。 can
    reorder。 So we have a packet that goes out。 Another packet that goes out。 Another
    packet that goes out。 All right， so now we have filled the receivers buffer。 So
    wait。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有未确认的数据包，是发送方已经发送的。我们有乱序的数据包，这些可能在接收方的窗口中，因为网络可以重新排序。所以我们有一个数据包发出去，另一个数据包发出去，再一个数据包发出去。好，现在我们已经填满了接收方的缓冲区。所以等待。
- en: or there until we get an acknowledgement。 So now we get an acknowledgement for
    that first。 And so now we can send another packet。 Right， when we get an acknowledgement
    for the second one。 Now we can send another packet， we get a knowledge meant for
    the third one。 Now we can send another packet。 So， we can send another packet
    to the server。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 或者直到我们收到确认。所以现在我们收到了第一个数据包的确认。然后我们可以发送另一个数据包。对吧，当我们收到第二个数据包的确认时，我们可以发送另一个数据包，当我们收到第三个数据包的确认时，我们可以发送另一个数据包。所以，我们可以向服务器发送另一个数据包。
- en: we can send another packet to the server window。 And so we can send another
    packet to the server window。 And so， we can send another packet to the server
    window。 And so。 we can send another packet to the server window。 And so。 we can
    send another packet to the server window。 And so。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以。
- en: we can send another packet to the server window。 And so。 we can send another
    packet to the server window。 And so。 we can send another packet to the server
    window。 And so。 we can send another packet to the server window。 So， with TCP，
    again it's per byte。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以，我们可以向服务器窗口发送另一个数据包。所以，在TCP中，仍然是按字节发送。
- en: We have three regions at the sender。 So the first sequence region is packets。
    bytes rather than have been sent and acknowledged。 All right。 so those we can
    forget about the second region is sent， but not yet acknowledged。 So。 these could
    be in flight， they could be represent packets that have been lost packets that
    have been garbled or packets that just simply haven't been delivered yet or packets
    that we simply haven't gotten the return acknowledgement again because of the
    round trip time。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在发送方有三个区域。第一个序列区域是已经发送并确认的数据包，字节数。好，这些我们可以忽略。第二个区域是已发送，但尚未确认的。所以，这些可能正在传输中，可能是丢失的数据包，可能是损坏的数据包，或者是还没有被传送的数据包，或者是我们没有收到返回确认，因为往返时间的原因。
- en: And then we have packets and bytes rather that have not yet been sent。 And it's
    this window this color region here in blue that's adjusted by the sender based
    on what information we get from the receiver。 Similarly， we think about the receiver。
    Right the receiver has received bites and given them up to the application。 It
    has bytes that have been received and buffered and bites that have not yet been
    received。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有尚未发送的数据包和字节。正是这个窗口，这里蓝色的区域，由发送方根据我们从接收方获得的信息进行调整。同样地，我们考虑接收方。对吧，接收方已经接收并将字节交给了应用程序。它有已经接收并缓冲的字节，以及尚未接收的字节。
- en: And you can see that this is a smaller region than the sender right because
    these are packets that could be in flight。 Right。 And so they haven't been received
    yet or rather。 they haven't been acknowledged yet rather so the acknowledgments
    here are in flight。 And these over here are packets that are in flight。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这是比发送方更小的区域，对吧？因为这些是可能正在传输中的数据包。对吧？所以它们还没有被接收，或者说，它们还没有被确认，因此这些确认信息正在传输中。而这些则是正在传输中的数据包。
- en: And so they haven't been received yet at the receiver。 Okay。 so here's an example
    of how this window based acknowledgments works in TCP with bites。 Right。 so here
    we send sequence number 100 size 40 so we have a packet that goes out at 100。
    then another packet that goes out at 140。 Right， and so now again we're taking
    up space in our buffer size 50 so now from 140 to 190。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们还没有在接收方被接收。好，这里是一个关于TCP中基于窗口的确认机制如何工作的示例。对吧？所以在这里，我们发送序列号为100，大小为40的数据包，然后另一个数据包在140时发出。对吧？现在我们再次占用了大小为50的缓冲区，所以从140到190。
- en: And we're going to get an acknowledgement for 190 to 210 we send out a package。
    a packet rather for sequence number 230 size 30。 And so here， the receiver， it's
    going to say hey。 I've only heard up to 190。 And I've got 210。 Right。 And so we've
    got this gap here from 190 to 230 the receive the sender， meanwhile。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会收到190到210的确认，我们发出了一个数据包，或者说是序列号为230、大小为30的数据包。所以接收方会说，“嘿，我只收到了190，收到了210。”对，所以在190到230之间有一个空隙，接收方，发送方此时呢。
- en: still sending packets at the receiver we're receiving these packets。 So here
    we are at sequence to 60 size 40， and the receiver is saying hey I'm acknowledging。
    I still have only heard up to 190 to 10。 So the question here is if the receivers
    act doesn't get through and the sender doesn't know the window size has increased。
    Well TCP stall。 So yes eventually so that's exactly what's happened here right。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在发送数据包，接收方正在接收这些数据包。所以我们现在处于序列号260，大小40，而接收方正在说，“嘿，我在确认。我仍然只收到了190到210。”所以这里的问题是，如果接收方的确认没有传输成功，而发送方不知道窗口大小已经增加，TCP
    就会停止。是的，最终就是这样发生的。
- en: Well it's not what's happened here right the the receiver is sending back an
    acknowledgement saying。 I've missed a packet。 If I don't get these acknowledgments
    eventually TCP will stop at the sender because it won't。 it will think it has
    filled the advertised window。 And so to wait until it hears acknowledgement saying，
    okay it's all right， you know。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这里发生的情况并不是这样，接收方正在发送回一个确认信息，表示它丢失了一个数据包。如果我最终没有收到这些确认信息，TCP 会在发送方停止，因为它会认为它已经填满了广告窗口。所以它会等待直到它听到确认信息说，好的，没问题，你知道的。
- en: for me to proceed。 Right。 And it could be that the acknowledgments aren't coming
    back because they're getting lost。 it could be that the outbound packets are getting
    lost， or in this case， you know。 things might be arriving out of， there could
    be a variety of different reasons but yes eventually TCP will stop from the sender
    point of view if it feels like it is filled the window and has not gotten acknowledgments。
    Okay so here we've said 340。 And again， still we're sending acknowledgement for
    190 to 10 eventually that acknowledgement makes it back。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说继续进行。对。可能是确认信息没有回来，因为它们被丢失了。也有可能是传出的数据包丢失了，或者在这种情况下，事情可能是以某种方式到达的，也可能是各种不同的原因，但最终是的，TCP
    会从发送方的角度停止，如果它觉得已经填满了窗口并且没有收到确认信息。好的，所以这里我们说是340。再一次，我们仍然在为190到210发送确认，最终那个确认会回来。
- en: And so now the sender will say oh I need to retransmit 190 and so it'll fill
    in that gap。 It arrives at the receiver the receiver will then send back。 Okay，
    I got up to 340。 Right。 And so it's acknowledging all those intermediate packets。
    And so that avoids us needing to retransmit all of those packets right and we
    can keep going until we fill the window。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在发送方会说，“哦，我需要重新传输190”，于是它会填补这个空隙。当它到达接收方时，接收方会发送回，“好的，我收到了340。”对，所以它在确认所有那些中间的包。所以这避免了我们需要重新传输所有这些包，我们可以继续进行，直到填满窗口。
- en: All right， so let me just summarize。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我总结一下。
- en: '![](img/193c262c45839f75eb2f216af3003afc_26.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_26.png)'
- en: Okay so what TCP gives us is a reliable byte stream between two processes that
    are on different machines over the Internet。 It gives us the ability to have read，
    write and flush。 and uses a window based acknowledgement protocols we just looked
    at。 And in the next lecture we'll look at how it uses congestion avoidance to
    dynamically adapt the sender's window to account for congestion in the network。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，TCP 给我们提供的是两个不同机器上的进程之间的可靠字节流，通过互联网传输。它让我们能够进行读、写和刷新，并且使用我们刚刚看到的基于窗口的确认协议。在下节课中，我们将学习它如何通过拥塞避免动态调整发送窗口，以应对网络中的拥塞。
- en: And so I'll see everybody on Thursday and hopefully on Tuesday rather and hopefully
    we will be back in person on Tuesday。 Thank you。 You。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我会在周四见到大家，希望我们能在周二见面，或者希望我们能在周二恢复面对面的交流。谢谢大家。你们。
- en: '![](img/193c262c45839f75eb2f216af3003afc_28.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c262c45839f75eb2f216af3003afc_28.png)'
- en: You。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你们。
