![](img/53a0bbd96bce73194524f58499453c5d_1.png)

# 操作系统课程 P7：同步、并发（续）、锁的实现与原子操作 🔒

在本节课中，我们将继续深入探讨并发编程的核心问题。我们将从线程调度的底层机制出发，理解线程切换是如何在硬件和操作系统层面实现的。接着，我们将直面并发编程中最核心的挑战——同步问题，并学习如何使用锁等机制来确保多线程程序的正确性。最后，我们会探讨原子操作的概念及其重要性。

---

## 线程切换的底层机制回顾 🧵

上一节我们介绍了线程调度的基本概念。本节中，我们来看看线程切换在底层是如何具体实现的。

线程切换的核心在于保存当前线程的上下文（主要是寄存器状态），并恢复另一个线程的上下文。这个过程通常由操作系统内核中的调度器（`scheduler`）和上下文切换函数（`switch`）协作完成。

每个线程都有自己的栈。当一个线程（例如线程S）调用 `yield()` 主动让出CPU时，控制流会进入内核。内核的调度器（例如 `run_new_thread`）会选择一个新线程（例如线程T）来运行，并调用 `switch()` 函数。

`switch()` 函数执行以下关键操作：
1.  将当前线程（S）的寄存器状态保存到其线程控制块（TCB）中。
2.  从目标线程（T）的TCB中加载其寄存器状态到CPU。
3.  其中一个关键的寄存器是栈指针（SP）。切换SP意味着CPU的执行栈从线程S的栈瞬间跳转到了线程T的栈。

因此，当从 `switch()` 函数返回时，程序计数器（PC）和栈指针（SP）都已指向线程T的上下文，从而实现了线程的切换。被换出的线程S的状态被完整保存，仿佛被“冻结”，直到下次被调度器选中并切换回来时，再从当初保存的断点处继续执行。

---

## 用户态与内核态的栈切换 🏗️

线程切换常常伴随着处理器模式从用户态到内核态的转换。现代处理器硬件（如x86）为此提供了直接支持。

当用户线程发起系统调用或触发中断时，硬件会自动执行以下操作：
1.  将当前用户态的指令指针（PC）和栈指针（SP）等关键信息保存到预设的内核栈中。
2.  将处理器模式切换到内核态，并使用预设的内核栈指针和异常处理程序的入口地址。

这个过程是原子且由硬件保障的。在内核中处理完请求后，通过执行 `iret`（中断返回）等指令，硬件会逆向操作，恢复用户态的PC和SP，从而返回到用户空间继续执行。

每个用户线程都有一个对应的内核栈，用于它在内核态执行时使用。调度器在进行线程切换时，不仅需要切换用户态的上下文，也需要切换对应的内核栈。

---

## 并发编程的挑战与同步的必要性 ⚠️

我们有了在多个线程之间切换的机制。然而，如果不加控制地使用并发，可能会从功能性和正确性上“摧毁”你的程序。

考虑一个简化的银行存款服务器示例。多个线程可能同时处理不同客户的存款请求，它们都执行以下代码：

```c
balance = get_balance(account); // 1. 读取余额
balance = balance + amount;     // 2. 增加金额
put_balance(account, balance);  // 3. 写回余额
```

如果两个线程（一个存$10，一个存$500）几乎同时操作同一个账户，它们的指令可能会以如下方式交错执行：
1.  线程A读取余额（假设为$100）。
2.  线程B读取余额（同样为$100）。
3.  线程A计算新余额（$110）并写回。
4.  线程B计算新余额（$100 + $500 = $600）并写回。

最终账户余额是$600，而不是正确的$610。线程A的存款“丢失”了。这是因为“读取-修改-写回”这三个步骤组成的操作不是**原子**的，它可能被其他线程打断。

**原子操作**是指一个操作要么完全执行，要么完全不执行，在执行过程中不可被中断。单个内存的读或写操作在大多数现代处理器上是原子的，但像“递增”这样的复合操作不是。

因此，我们需要一种机制来保护像“更新账户余额”这样的**临界区**代码，确保在任一时刻，最多只有一个线程在执行它。这就是**同步**。

---

## 锁：同步的基本工具 🔐

实现同步最直接的工具是**锁**。锁提供了**互斥**访问的能力。

锁的基本操作有两个：
*   `acquire(lock)`：获取锁。如果锁已被其他线程持有，则调用线程会等待（通常进入休眠状态），直到锁被释放。
*   `release(lock)`：释放锁。允许其他正在等待的线程之一获取该锁。

使用锁修正后的银行存款逻辑如下：
```c
acquire(account_lock);          // 进入临界区前加锁
balance = get_balance(account);
balance = balance + amount;
put_balance(account, balance);
release(account_lock);          // 离开临界区后解锁
```
现在，即使有多个存款线程，`acquire` 和 `release` 之间的临界区也保证了同一时间只有一个线程能执行余额更新操作，从而避免了数据竞争。

正确使用锁的要求是：所有访问共享资源（如同一个银行账户）的线程，必须使用**同一个锁**来保护对该资源的所有访问。

---

## 实现锁的挑战与思路 💡

如何实现一个锁呢？一个理想的锁应该具备：
1.  **互斥性**：保证最多一个线程持有锁。
2.  **公平性**（可选）：等待的线程最终能获得锁，不会饿死。
3.  **性能**：尤其是当锁被占用时，其他线程不应忙等待（busy-waiting）而空耗CPU周期，应进入休眠状态。

仅使用原子的读/写操作来实现一个正确的锁非常复杂。我们通过一个“买牛奶”的类比来探索几种方案：

*   **方案一（先检查后留便条）**：可能导致两人都看到没牛奶且没便条，于是都去买，造成“牛奶过多”。
*   **方案二（先留便条后检查）**：可能导致两人都留下便条，然后都看到对方的便条，于是都不去买，造成“缺奶”。
*   **方案三（Peterson算法思想）**：通过更复杂的标志和轮流机制，可以在两个线程间正确工作，但代码复杂、不对称，且涉及忙等待。
*   **方案四（理想的锁）**：这正是我们需要的——`acquire()` 操作在锁被占用时让线程休眠，`release()` 操作唤醒一个等待线程。这需要操作系统底层原语的支持。

为了实现方案四，操作系统需要提供比原子读/写更强大的**硬件原子操作原语**，例如：
*   禁用中断（在单处理器上可行）。
*   特殊的原子指令，如 **Test-and-Set (TAS)**、**Compare-and-Swap (CAS)** 等。

这些硬件原语允许我们以不可分割的方式“检查并修改”一个内存值，从而可以作为构建更高级同步机制（如锁、信号量）的基石。

---

## 总结 📚

本节课中我们一起学习了：
1.  **线程切换的底层细节**：理解了 `switch()` 函数如何通过保存和恢复寄存器（尤其是栈指针）来实现线程上下文切换，以及硬件如何辅助完成用户态/内核态的栈切换。
2.  **并发编程的核心挑战**：多个线程不加控制地访问共享数据会导致**数据竞争**，产生不可预测且难以调试的错误。
3.  **同步与原子操作**：**同步**是协调线程活动以确保正确性的机制。**原子操作**是不可分割的基本执行单元，是构建同步机制的基础。
4.  **锁的概念与使用**：**锁**是实现**互斥**、保护**临界区**的基本工具。正确使用锁可以防止数据竞争。
5.  **锁实现的思路**：实现一个高效、正确的锁需要硬件提供原子操作原语的支持，以避免复杂的软件算法和忙等待。

![](img/53a0bbd96bce73194524f58499453c5d_3.png)

并发编程要求开发者必须仔细设计，预先考虑所有可能的线程交错执行情况。在接下来的课程中，我们将基于锁的概念，继续学习信号量、条件变量等更高级的同步机制。