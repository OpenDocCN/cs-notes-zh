# P4：讲座 4：`fork`（续），I/O 介绍（万物皆文件！） - RubatoTheEmber - BV1L541117gr

好的，欢迎大家回到 162 课。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_1.png)

我们将从上次的内容继续，简要地完成对 `fork` 的讨论，然后继续。所以上次如果你记得，我们在谈论如何创建新进程。基本上我们讨论的机制是 `fork`。这将是我们本学期讨论的几个并行性和并发性机制之一。

如果你记得，`fork` 是一个调用，相比于你之前见过的任何其他调用，它有点奇怪。所以 `fork` 做的是，在一个进程中调用 `fork`，然后它会在两个不同的进程中返回。好的。所以你有一个父进程，你调用 `fork`。它会创建一个与父进程完全相同的子进程，然后它们都从 `fork` 系统调用返回。

如果你注意到，返回的其中一个值会大于零，另一个会等于零。如果大于零，那么这个值将是原始的父进程。你得到的数字是子进程的进程 ID。如果返回零，那么进程就知道它是子进程，并可以调用 `get PID` 和 `get parent PID` 等来找到父进程的 ID。

这是一个概念。只有当你得到一个小于零的值时，你才知道 `fork` 过程失败了，并且你仍然在父进程中运行，返回的数字告诉你某种错误代码。好的，关于 `fork` 的关键是，原始进程的状态最终会在父进程和子进程中都被复制。

所以，如果有数 GB 的内存。在父进程中，当你调用 `fork` 时，子进程将会有数 GB 的内存。好的，这看起来可能有点过于庞大，除非你明白实际发生的事情是，我们不会复制所有的内存，我们只是复制了父进程和子进程的页表，这样我们就能做到。

复制内存时并不需要实际复制任何内容。这个问题将会是另一个讨论的话题。所以，记住，在 `fork` 之后有两个进程存在，并且它们都会从 `fork` 返回。所以我在这里展示的是我们调用 `fork` 后发生的事情。返回的值是一个整数。好的，实际上是一个 PID T，但它本质上是一个整数，父进程和子进程都从同一个地方开始。

如果，然后它们开始运行。你会看到，父进程会注意到进程 ID 大于零的进程从这个点开始运行。子进程会注意到进程 ID 等于零的进程从这个点开始运行。从那时起，两个进程的执行将会分岔。父进程和子进程可以做完全不同的事情。好的。

那么，这个聊天中的问题是，父进程和子进程共享内存吗？答案是既是又不是。所以我不想过多讲解其中的细节，你应该将其视为它们各自获得了完整的副本。实际上，它将会是，我们将所有内容设置为只读，只有当其中一个进程尝试写入时，才会复制内存，这样它们看起来就像是有各自的独立副本。

但是它比复制所有内存要便宜得多。好的，我们将在接下来的几节课中进一步讨论这个问题。那么，我想知道大家是否对这个基本概念有任何问题？如果没有，我们将继续往下讲。好的，假设有一个进程调用了两个子进程返回四。好了，现在，给大家一个很好的挑战。这里有一个程序。注意它的功能，它声明了一个整数作为全局变量。它调用时，父进程会在`L`的一个分支中运行，子进程会在另一个分支中运行，我暂时忽略错误处理。

问题是，如果这个程序运行时，我们在屏幕上看到的是什么？因为看起来`I`的两个使用是相互干扰的，一个在递增，另一个在递减，两个进程同时运行，会发生什么？

非常好。所以有人在聊天中问，等等，进程不应该是彼此隔离的吗？是的，回答得很好。你可以注意到，父进程有一个全局变量`I`，当我们复制它时，两个进程都拥有一个全局变量`I`，但是它们是不同的全局变量，因为它们位于完全不同的地址空间。所以，实际上，这两个进程会完美地进行它们的循环，一个进程让`I`递增，另一个进程让`I`递减。

我们会看到的一个非确定性因素是，它们都在打印到相同的标准输出，因此稍后我们将在讲座中讨论这个问题。你会看到两个进程的输出会交替出现，但不会产生混淆。

好的，基本上，我所说的“`I`”就是执行图的分支，它分裂成两个完全不相关的部分。是的，关于我们上次讨论的`exit`，它是分支的一个例子。接下来，我想给大家讲一些更多关于进程管理的内容，然后再进入下一个话题。到目前为止，我展示的给你们的是新的进程，但它们基本上是彼此的复制品，这在你需要创建大量新进程时可能并不太有用。

好的。为了做到这一点，我们将使用精确的系统调用，而`wait`将帮助父进程了解子进程何时完成执行。我们先来看一下精确的部分。精确的系统调用有很多不同的变体，所以我将把它们通称为精确调用。

你可以通过`man exec`来查看所有不同的版本。但这里会发生的事情是，如果你注意到，我们从`fork`开始。当我们在父进程中时，我们要做的就是执行`wait`，它会一直等待直到子进程退出，我会在下一张幻灯片中详细讲解。子进程将做一些有趣的事情，它将创建一个包含字符串的数组，并且注意到这是`ls -l`，然后是一个数字。

所以这是一个包含两个字符串和一个数字的数组。准确的V系统调用将会把第一个参数设置为`/bin/ls`，第二个参数将是这个参数数组。好，令人感兴趣的是，父进程创建了两个进程，父进程只是等待。

它实际上只是在等待一段时间。子进程没有执行`exec`。而这会在文件系统中查找这个程序，并用新程序的内容替换进程中的一切，然后开始运行。好，假设没有错误。我们刚刚做的是创建了一个新进程，一个子进程，开始运行`LS`程序，父进程则在等待。好。

所以现在你可以开始看到你的shell是如何工作的。shell有一个父进程，显示提示符并处理你输入的内容。你启动的所有程序都会作为子进程放入它们自己的进程中。好。所以`exec`做的事情是，假设没有失败的情况下。

`exec`会丢弃现有进程中的所有内存内容，并开始在该进程中运行一个新程序。所以，进程仍然存在，但是该进程的地址空间内容发生了变化。而你只有在出现错误时才会从`exec`返回。好，那么`wait`系统调用是怎么回事呢？其实有很多版本的`wait`，你可以查找更多信息。

我在这里提到的最简单的例子是试图解决一个有趣的问题，你可以想象一下。假设父进程启动了一个子进程，子进程结束了。父进程希望知道该进程的执行结果。是成功返回，还是出现错误，等等。所以，`wait`系统调用基本上就是让我们做到这一点。

所以，如果你注意到这里，子进程基本上在执行某些内容。然后它没有退出42，因为42不是零，技术上来说这是一个错误。父进程调用`wait`并传递一个整数变量的地址来获取返回值。这个`wait`系统调用将等待直到子进程退出，此时退出代码将被放入我们提供的变量中。

然后，`wait`系统调用将返回，我们可以查看子进程的返回值是什么。好的，嗯，关于这里的问题，哎呀，ARGS基本上就像是LS命令的参数。那就是LS命令的参数是如何被放入的。好了。接下来，`wait`系统调用会等待子进程退出，获取其返回值，然后继续执行。

好的。所以你可以理解，为什么这需要更加复杂的操作。之所以不清楚，是因为如果一个子进程在父进程准备执行`wait`之前就已经退出了，显然这个进程必须保留其返回代码，尽管它已经完成，以便父进程最终可以获得退出状态。好的，如果是这样的话。

那么，那个曾经是子进程，但现在不再运行的进程就被称为僵尸进程，它会一直存在，直到某个进程执行了`wait`系统调用。现在有一个很好的问题，如果你有多个子进程从这个`wait`系统调用派生出来，这个版本将会等待下一个子进程退出。

还有很多其他的调用，你甚至可以指定等待某个特定进程ID退出，等等。所以你可以做更复杂的操作。另一个问题是，这个`exec`进程是否可以访问父进程的所有内存。答案是否定的。发生的情况是，子进程会有自己的内存。好的。

这实际上是父进程的一个副本，但与父进程是分开的，`exec`将会用新的执行镜像覆盖一切。好的。所以这里是我称之为shell模式的典型示例。这是你在shell中通常看到的情况。在你输入命令之后，我们会派生出一个新进程。子进程去执行`exec`命令，运行那个进程。

父进程执行`wait`并等待子进程完成。好的，这就是你通常在命令行中输入命令后所看到的现象。你按下回车键后，某些事情发生，然后它把控制权交还给命令行。那就是这个情况。现在，在另外一种模式下，你希望启动一个子进程，然后继续执行，允许它运行，并继续在命令行中做其他事情。

这将是一个我们不执行`wait`，而是直接继续执行的情况。好的。那么问题是，如果你查看这个特定代码，状态变量是从哪里来的。注意，它是退出代码。所以当子进程以退出代码42退出时，这就是返回到状态变量的状态码。好的，明白了。然后，最后。

我想谈一谈。我们之前谈到了启动、停止和管理进程。从父进程的角度来看，系统需要能够控制那些已经在运行的进程。所以基本上就是所谓的`kill`操作。好的，基本上。

我这里给你展示一个例子。通常情况下，如果你按下Ctrl+C，实际上会发送一个信号，这是一个中断信号，发送到正在运行的进程。你想要的，我们这里有一个更通用的想法，我们可以向任何进程发送信号。这有点像中断的用户级版本。

你将在你的项目中实际操作这个。但我只想展示一个特别简单的例子，展示你可以做什么。所以当你按下Ctrl+C时，默认情况下，系统会捕获这个Ctrl+C并终止它。好的，然而，如果你想做一些不同的事情，你可以这样做。

所以注意，主要的过程实际上是设置了一个SIG动作，你可以查看这段代码。我现在不想详细讲解。但是SIG，SIG动作有一个处理器，它是一个程序，是你已经注册的一个函数。所以这是你在代码中放入的信号回调处理器。

你把它注册为在收到SIG时调用的处理器。所以当你按下Ctrl+C时，它将调用这个，而不是系统的默认版本。在这种情况下，它会显示“捕获到信号”，然后退出。但你也可以让它显示“捕获到信号，忽略”，并立即返回。这样Ctrl+C就不会做任何事，只会一直显示“捕获到信号”。

所以在信号方面有很多灵活性。好的，然后有很多不同的信号，像SIG和SIG interrupt控制C。还有SIG term，这是kill shell命令。然后还有SIG kill和SIG stop，这是无法捕获的信号。SIG kill是通过kill -15或者kill -9得到的。

你会得到这些无法捕获的极端信号。好的。所以我想我还不完全理解这个问题，为什么仅仅是状态变量？这是一个代码和选定的变量，所以在这个例子中是状态。所以状态，这里的状态一词只是因为我说了状态，注意到我的城市和状态，这可以是任何名称的变量。

所以这可能是wait。Fred，如果你愿意，我不知道这是否回答了你的问题。无论你，如何命名父进程中的那个变量都可以。好的，接下来，如果你记得上次以及上上次，我们给你展示了这个图，它大致展示了用户模式和内核模式之间的区别。

所以内核模式是内核中一组高优先级的东西，它们可以直接访问硬件，必须是完美的。好的，用户模式是用户和其他人编写的东西，可能存在缺陷，通常内核的工作是提供进程抽象，并确保文件系统的保护。

所有其他的东西都由操作系统维护。所有这些都在内核里面。用户模式是运行大多数程序的地方，但它运行在一个进程地址空间内，并且与其他进程隔离，其他进程也被保护不受它的影响。好吧。所以，内核和shell之间的区别是，shell只是一个运行在用户模式下的程序，你是在自己的系统上运行它。

但它请求内核启动一个新的进程。所以内核是操作系统的核心部分，处理文件系统、调度以及所有相关事务，并且基本上始终存在。好吧，shell只是一个像其他程序一样的用户模式程序，只不过它被设置用来处理你的命令，并利用这些命令启动程序的运行。好吧，再说一次，如果有多个子进程，那么wait会等待下一个进程退出。

然后你可以一遍又一遍地运行它。好吧，顺便说一下，另外需要注意的是，这里展示的用户模式中有两个东西，分别是应用程序和标准库。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_3.png)

![](img/b59c0e1f5f8864879bc09f46bc086ef0_4.png)

所以标准库是围绕系统调用接口的一个包装集，使得它比原始的系统调用接口稍微更易于使用。如果你看这里这种系统调用接口的狭窄空间，像lib C这样的库是将其放置在系统调用接口之上的一个很好的例子。

在lib C中的内容相对来说更容易使用。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_6.png)

而不是直接使用原始的系统调用。所以大多数用C语言编程的人至少会链接lib C，因此他们不会直接使用系统调用，而是使用lib C，lib C内部会使用系统调用。好吧。所以，举个例子，我之前展示了这张图片，我只是想澄清一下，通常你会有像lib C这样的库。

你可以看到这里有一个库。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_8.png)

为了澄清，通常你会有像lib C这样的库，它被链接到你的应用程序中，这里展示的是一堆不同的应用程序，绿色、黄色、橙色与lib C一起使用，而lib C则为应用程序提供了一个简洁、易用的接口。

它通常会调用操作系统，并且大部分库代码运行在用户模式中，偶尔会调用操作系统中的系统调用。是的，正如Anthony所说的关于wait，我知道这对许多人来说是一个重要话题，但使用man wait，你会看到它有很多不同的版本。

许多它所做的事情，你知道，是非阻塞的，可以让你说，等待这个特定的进程，等等。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_10.png)

好的。所以，这里将事物封装在系统调用接口中的想法是非常标准的，因为系统调用接口非常强大，它就像是一个进入内核的函数调用，但是它非常精简，是你所需的最基本的部分。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_12.png)

好的。今天我们将讨论很多关于如何跨越那个系统调用接口的内容。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_14.png)

我将给你一些很好的例子，说明 lib C 如何发挥作用，为实际调用系统调用接口提供一个更干净的封装。好的，这应该能很好地帮助你为项目一做好准备。所以，今天的第一个想法是“一切皆文件”。好的，这是一个非常 Unix 的想法。它被采纳并标准化为 POSIX，我稍后会说一下 POSIX 是什么，但它是 Unix 的大量标准化内容。

这个背后的想法是它是一个相同的接口，适用于文件、设备、磁盘上的常规文件、网络、进程间通信，所有这些，一切看起来都像是文件。好的。所以，这种类型的通信，跨越那个系统调用接口的东西，通常基于像 `open`、`read`、`write`、`close` 这样的系统调用。到学期结束时，你将非常熟悉这些。好的。

这个接口还有一个我们还没有讨论的附加部分，叫做 I/O 控制（I octals）。I/O 控制，或者我听人们说的 I octal，虽然这对我来说听起来有点奇怪。但 I/O 控制接口允许你在不能完全将所有内容都强行装入 `open`、`read`、`write`、`close` 时，对接口进行定制。通常，这是一个 I/O 控制接口，它让你对这些东西进行一些额外的配置，稍后我们会在学期中讨论一些 I/O 控制的调用。

但基本上，想象一下 `open`、`read`、`write` 和 `close` 几乎是你对所有事物所做的事情。而“一切皆文件”的想法，实际上在最初提出时是有些激进的。你可以在 Richie 和 Thompson 于 1974 年发表的早期论文《Unix 时间共享系统》中看到这一点。如果你感兴趣，我已经把这篇文章发布在资源页面上，它实际上是我们在 262A 课程中阅读的第一篇论文，你可以从中感受到一些有趣的味道，了解一下研究生计算机系统的样子。

“一切皆文件”的这个想法非常强大，以至于现在我们甚至不再认为它是激进的，它甚至被采纳为一个标准化接口。所以我想说一下什么是 POSIX，POSIX 是所谓的便携操作系统接口，用于 Unix。

它是为应用程序开发人员提供的接口，特别是一个系统调用接口。它的创建旨在解决 Unix 的不同版本在全球范围内广泛存在且略有不同的问题。

调用接口。因此，发生的事情是，他们采用了一个更标准化的版本，叫做POSIX。一些POSIX接口甚至在Windows中也能找到，尽管Windows不是一个Unix操作系统，但它仍然有POSIX接口。所以当我谈论Unix系统调用等内容时。

大多数情况下，我是在讲那些在POSIX中标准化的东西，如果不是，我会做出澄清。那么，让我们来看看这个始终存在的文件系统抽象。文件是文件系统中一个命名的数据集合。例如，POSIX文件数据是一个字节的序列，可以是文本、二进制或序列化对象，实际上并不重要。

操作系统并不关心数据的格式，因此操作系统对你如何格式化数据并不感兴趣，它只会给你一个按顺序排列的字节包，接下来由你来解释它们。好了，唯一一个由Unix文件系统直接处理的文件类型就是目录，它们采用一种特殊格式。稍后我们会讨论这个问题，但现在可以理解为，文件是字节的序列。

字节表示的内容并不重要。好吧，然后还有文件的元数据，比如大小、修改时间、所有者、安全信息等等，这些内容在你开始更频繁地使用这个接口时会有更深刻的理解。目录实际上只是另一个特殊文件，包含指向文件和其他目录的指针，并且这些指针有名称。

好吧，每个目录都提供了一个映射，映射文件名和其所代表的目录或文件。如果你从根目录（即最顶层）开始，沿着一系列目录追溯到一个文件，实际上你是在通过这些目录跳跃。

根目录是一个指向下一个目录的文件，下一个目录又是一个文件，依此类推，直到最后一个文件，它不是一个目录。我们将在几周后深入讨论文件系统时详细探讨这种路径追踪。你们都已经使用过这种方式，所以对这个概念应该很熟悉。在Unix中。

每个进程实际上都有自己的当前工作目录，这是该进程正在使用的文件的目录路径。系统有一个调用接口叫做更改目录，可以用来设置当前的工作目录。而绝对路径是以斜杠开头的路径，它们不依赖于当前的工作目录。

所以，像“/home/osuki/six/CS6162”这样的路径就是根文件系统下的路径，而相对路径是带有点（dot）符号的路径，或者在某些情况下带有波浪符（tilde），这些路径是相对于当前工作目录的。例如，如果你说“index.html”，实际上指的是当前工作目录下的“index.html”。

那么，文件的接口怎么样呢？今天我想做的是，我们将快速浏览 I/O 栈的各个层级，从流的高层开始，这就是缓冲 I/O，它在 libc 中，然后是低层，一直到 Cisco 接口。

我们现在不会谈论很多关于文件系统的内容，但我们也会稍微提到一些 I/O 设备驱动程序，只是让你们了解这些栈中有趣的部分，我们将随着学期的进展逐步涵盖。好了，在最高层，我们有被称为流的东西。好的，C 的高层 API 操作于流。因此，流是一个字节序列，并没有以特定的方式进行格式化。

它有一个与之相关的位置。我在这里画了一个小箭头。这里有 F open 和 F close 例程。这些大多在 libc 中，用于打开文件或关闭文件。注意，这里有一个特殊的 F 在前面，F open 和 F close。所以这些不是一般的 open 和 close，而是 F 版本，或者说是流版本。因此，F open 接受一个文件名。

它可以是一个绝对路径，也可以是相对于当前工作目录的路径。然后是一些模式位。它返回一个叫做 file star 的东西，它是一个你不需要深入了解的结构，但它是一个你可以读写的流。当你完成时，你使用 F close 关闭它，返回 file star。那么记住，这意味着有一个文件结构，它返回一个指向该结构的指针。

然后，定义是针对这个标准 I/O 点 H，包含你所需要的所有定义。好了，现在关于什么是流的问题，我稍后会进一步说明，但实际上就像我说的，它是一个未格式化的字节序列，就像在流动一样，你将读取它们。就是读取一个完整的字节序列，没错，它是一个字节流。

它就像一条河流。好的，这些模式位实际上是你传递给它的一个字符串，一个字符集的指针。这里有很多模式选项，如果你给它一个 R，它是只读的，如果你给它一个 W，它是只写的，如果你给它一个 A，它是追加的，即从文件末尾开始等等。现在，关于文件权限是否存储在元数据中的问题。

所以，我想说对于 Unix 系统的功能来说，答案是肯定的。我们将首先查看 FAT 文件系统，它的权限定义不太清晰，但目前它实际上是元数据的一部分。好了。所以，打开的流实际上由一个指向文件结构的指针表示，因此，从 F open 返回的是一个 file star。好的。那么，如何返回错误呢？这个问题将是我想要训练大家的关键问题，Anthony 也会想要在学期结束时将其训练好。

每当你执行某种系统功能时，你总是要问自己，错误条件是什么？在这里，错误条件是，如果你没有得到一个文件结构的指针，而是得到了一个空值（即零）。好的，这时`F open`失败了，你不应该继续进行。好的，课堂上我稍后会讲更多内容，可能并不总是，事实上，通常我不会去看错误情况，因为那样会让我的幻灯片显得杂乱无章。

但作为有志向的系统程序员，你应该时刻考虑错误。错误的返回值是什么？我们来看看流接口的部分内容，除此之外，还有一些总是处于打开状态的标准流，用于读写。这些就是标准输入、标准输出和标准错误。

所以标准输入，如果你从中读取，那就是正常的输入源。好的，通常情况下，如果你什么都不做，它通常是键盘。标准输出是一个输出流，如果你不做特殊处理，它会直接在屏幕上打印。标准错误也会打印到屏幕上，但通常错误信息会发送到标准错误。

所以，标准输出和标准错误，除非你改变它们，通常是交错的，它们会显示在同一个屏幕上。好的。不同于普通文件，我必须执行`F open`才能读取每个进程。你自动就有了标准输入、标准输出和标准错误，随时可以使用。好的，基本上，它们以一种有趣的方式使得Unix的组合变得可能。

你可能还没有做过，但应该在你的Unix环境中做的事是，如果你输入`cat`，它意味着输出`hello.text`的内容，然后你输入一个小竖线（即管道符），再输入`grep world`。你真正做的是，将这个进程的输出传递给第二个进程。

Shell会启动两个进程，第一个进程的输出会传递到标准输出。第二个进程的输入来自标准输入，用于查找匹配项，但小管道符实际上自动将第一个进程的标准输出连接到第二个进程的标准输入。因此，结果就是它会获取`hello`文件的所有内容。

文本并将其发送给`grep`，以便在该文件中查找单词“world”，即“world！”这个单词。好的。所以我们实际上是通过Shell连接标准输入和标准输出，这也是你将在Shell作业中做的事情。

好的。那么这是值得期待的。现在，我们来看一下。聊天中的一个好问题是，如果只是使用`grep`，会发生什么？答案是，实际上你会这样做：你会说`grep world`，然后给出文件名，然后`grep`实际上有两个参数要使用。好的，如果你只是说`grep`并单独输入`world`，会怎样呢？

它会在那里暂停，因为它在等待标准输入。所以在这种情况下，你实际上会遇到一个失败。好的，因为你确实需要一个文件来进行`grep`操作。好的，试试看。好的。这实际上就是会发生的情况。好了，你试试，看看会发生什么。好的。那么现在我们要做的是。

这里还有另一个问题，关于大于号（`>`）符号的作用是什么，我们暂时不会深入讨论细节，直到稍后，但如果我在所有这些后面加上一个大于号（`>`），然后加上一个文件名，它的意思是将来自`grep`进程的标准输出重定向到一个文件中。

所以，大于号（`>`）符号，而不是竖线（`|`），实际上允许你将输出重定向到一个文件中。所以，部分的shell作业就是你要学习如何正确使用竖线、大于号和小于号符号，通过将多个进程串联起来。

所以这实际上就是你需要做的事情。那么我们来看一下不是标准输入输出的情况。如果我们假设有一个文件在磁盘上，并且我们想对它做一些操作，一旦我们打开了它。那么我们就可以拿到我们打开的文件的文件指针，现在我们可以进行单个字符或字符串的读写操作。

好的。这个操作将返回并尝试将值写入流中，所以这是一个写操作。它将返回字符或错误。例如，这里有一个读取字符串的操作，它实际上会读取直到某个位置，或者说，抱歉，`Fput`实际上是将字符串写入文件，直到没有更多内容为止。然后还有其他类似的操作，这些都是面向字符的I/O操作。

你可以使用`man`命令。所以我希望你开始学习使用`man`命令，然后输入一个命令，这样就能给你提供这些命令的详细信息。好的，另外一种方式，让我们看一个例子。注意，我是如何打开`input.text`文件的，这一切都是相对于当前工作目录的。

我得到输入文件指针`file_star`，然后有一个输出文件`output_file_star`，注意输入文件是以只读方式打开的，而输出文件是以写入方式打开的。然后我从输入文件中获取一个字符，只要那个字符不是`EOF`，我就把它写入输出文件，然后获取下一个字符，继续循环。这样就会将输入文件的所有内容转移到输出文件中。最后关闭两个文件。这是在做字符逐个读取和写入的I/O操作。

所以在前面的例子中，顺便提一下，问题是`cat`和`grep`是否会同时启动两个不同的子进程？是的。好的，那么那些是面向单个字符或字节的I/O操作，我们也有面向块的I/O操作，再次注意它们前面都有F，这一点很重要。

所以除了文件指针之外，在这个情况下我们实际上传递一个指向缓冲区的指针，以及我们想要的元素大小和我们想要读取或写入的数量。这个操作会一次性读取一大堆数据。好了，这样就是有缓冲的操作。

更大的IO操作，好的，将其放入你指定的缓冲区中，所以这个`void*`实际上只是一个指向你预先分配的缓冲区的指针，缓冲区的类型可以是任意的，这就是`void*`的含义，你也会习惯这种用法。通过`F read`，我可以一次读取一大块数据，而不是单个字符，使用`F write`，我可以一次写入一大块数据，而不是逐个字符地写。

你可以想象，这样的开销要小得多，所以你肯定会想使用缓冲区读取操作，对吧？好的，这是另一个使用缓冲区读写版本的例子，注意我在这里做了什么，或者说是`read F`、`write F`和`F read`版本的使用，注意我在这里定义了缓冲区大小作为常量1024。

在`main`函数中，我声明了一个大小为1024的缓冲区，这就是这个意思，它是一个字符缓冲区。然后，我要做的是将数据读取到这个缓冲区中。这是一个指向缓冲区的指针，最大大小为`buffer size`，一个元素的大小是字符的大小。好了，从输入文件读取数据。

它会返回一个链接，告诉我们返回了多少长度，如果是零，文件结束，如果不是零，那么我就继续将缓冲区的数据按数量写出，并继续循环。这样现在从输入文本到输出文本的复制效率大大提高，可能会一次读取1024个字节，效率更高。好了。

这里，我们依然在做所有的操作都是流式的，但是我们在做基于块的IO，而之前是基于字符的IO，所以我们依然在进行流式操作。好了，再次强调，检查错误，始终做程序员助手。你应该真正写出像这样的代码，从`F open`获取输入，如果输入是`no`，我们做其他的事情，因为失败了，你不想传递`no`。

你想通过将`no`变成一个类似于F的读取方式，如果它是`no`，那么这个操作就会以一种不好的方式失败，好的，你可能并不一定知道为什么。好了，始终检查错误，始终从输出错误返回是什么样子开始命令。那不是类中的错误检查，但并不意味着你不应该检查它。好了，这就是高层API。

还有很多其他的事情，比如你可以使用`F seek`将指针设置到文件中的特定位置。好了，`F seek`你可以相对于当前位置设置它，下面是文件的当前位置，你可以从这里偏移，或者从文件开头偏移。通过这种方式，你可以随机读取文件的不同部分。

好的，但如果你不进行搜索（seek），那么每次读取，无论是字符定向的 `getchar` 还是块定向的读取（block read），都会慢慢地进行，因为它会随着你前进而推进指针。好的，现在我刚刚描述的流（streams）其实是 Lib C 为你封装低级描述符的一个很好的示例。好的，这个封装的原因特别有用。一个特别好的原因是，如果我们回到每次读取一个字符，写入一个字符的例子。

你可以想象，这样的做法是非常低效的。一般来说，因为发生的事情是，如果你为每一个字符调用一次系统调用，你就得进入内核，这会有很多开销，它得去找到字符并把它取回来。所以这会是非常低效的。

只不过我们使用的是流版本，因为这里有 F。发生的事情是，`Fgetc` 实际上是在内核中以用户级别运行，抱歉，是在进程中的用户级别运行。这个文件描述符实际上在用户级别为缓冲区保留了一块内存。所以当你第一次调用 `Fgetc` 时，它实际上会进入内核，抓取一块数据，比如1024字节，并把它放到用户级别的缓冲区中。

从那时起，直到数据用完之前，每次调用 `Fgetc` 都非常高效，因为它是在用户级别处理的。所以流处理实际上就是在 Lib C 中实现了自动缓冲，省去了你必须担心它的麻烦。好的。所以，这在低级别是通过实际使用系统调用来实现的，这些调用包括 `open`、`create` 和 `close`，而且这不是拼写错误，`create` 这个词是正确的，它们是直接进入内核的系统调用。

在这里，我给出了一个名为 `open` 的文件以及一些标志和模式，比如。它为我打开了文件，但返回的是一个整数，而不是文件指针（file pointer），这意味着它返回的是一个文件描述符。好的。这个文件描述符整数是我从此以后在读写时要使用的东西。稍后我会给你展示。好的。那么要注意的是这一点。

有一些标志，如读取（read）、写入（write）、创建（create）等。还有一些像权限（permissions）这样的位，我需要在写入时使用，你知道的，用户组和我想在文件中设置的其他权限。注意，`open` 返回的结果，假设它不是错误（即不会是负值返回）。

我得到的是一个整数类型的文件描述符。好的。还有我要指出的另一件事是，`open` 前面没有加 F，它是没有 F 的 `open`。好的。如果从 `open` 返回的是负值，那就是错误。否则它就是一个文件描述符。好的。就像缓冲流版本一样。

非缓冲的低级版本也有文件描述符，标准输入、标准输出和标准错误都用整数表示。但是因为它们是整数，我们知道 0 是标准输入，1 是标准输出，2 是标准错误。每个进程通常从这些值开始分配。标准输入（即 0）用于从键盘获取内容，标准输出和标准错误通常设置为将内容输出到屏幕。

好的。你应该使用宏。你不应该写 012，因为那是糟糕的编程风格。你应该写标准输入文件、标准输出文件等等。这些宏在另一个包含文件中定义。明白了吗？好的。现在，缓冲版本和非缓冲版本的区别在于，非缓冲版本没有那个内存中的缓冲区。好的。所以它们没有请求内核返回比用户当前需要更多数据的效率。

好的。但这是直接进入内核的接口。所以，注意。例如，现在的 `read` 前面没有 F，因为我使用的是低级接口。我将文件描述符作为第一个参数，然后是一个缓冲区和大小，大小是我可以返回的最大字符数。好的。

这就是 `read`，`read` 会读取最多我请求的最大大小，但它可能少于这个数。好的。并且，注意这里的事实，`read` 返回的结果有两种可能性：要么是 0，这种情况下不仅没有读取任何内容，文件已经读取完毕，也就是到达文件末尾。否则，

它是一个大于 1 的数字，告诉我我读到了多少个字符。好的。它实际上可能少于我要求的数量。所以如果我要求 20，它可能只给我 1 个。你需要记住这一点。好的。所以它返回最多最大大小。所以如果你期望更多的话，

你可能需要在一个循环中进行此操作。好的。通常来说，如果返回值是负数，则表示出错。好的。写入也有类似的概念。注意，文件 `crypto` 是第一个参数，它是整数，我有缓冲区和我要写入的字节数，它返回写入的字节数。在这种情况下，唯一会返回少于我请求的字节数的原因通常是出错。

但是你也应该查阅手册，明白吗？好的。文件描述符是整数的原因是什么？因为它将在内核中的表格中进行查找。所以，大家，我让你们稍微回想一下我们之前说的关于中断处理程序的内容。对吗？中断处理程序有一个向量，我们通过中断号来确定一个非常清晰的入口点进入内核。

这就是一种防止用户做出疯狂操作的方式。这个例子中，文件描述符只是一个整数，它的思路是相同的，返回一个整数，然后我在读取和写入时将一个数据整数传递给内核。

而内核不信任文件指针，它只是一个缓冲区，可能是用户空间中无效的。它只有一个整数值，并且可以直接检查这个整数是否有效。好吧。但无论如何，读取、写入、定位。好吧。这些都是我们刚才在缓冲的意义上看到的版本。好。

所以这是一个简单的例子，我打开一个文件进行读取。好吧。然后我这里有一些权限位。接着我读取它。好吧。我关闭它，然后将其写入标准输出。所以这是一个非常简单的例子。好吧。这个程序读取了多少字节呢？它将读取最多1000字节。

然后，文件描述符的不同之处在于，它是从打开操作中返回的内容，它是一个文件描述符。好吧。它是一个整数零或者一个正整数。如果你得到的是一个负数，那么就知道有问题了。好吧。所以，我想强调一下这里的内容，那就是我们一直在讨论的低级和高级的设计模式。

低级设计模式是你在使用之前总是先打开。好吧，所以注意我们总是做了打开操作，因此打开是关键，或者如果你使用的是流式版本，则是F打开。接着，检查权限的部分会确保你有权限使用某个文件，并假设打开操作没有出错。那么，你就不需要再检查权限，因为现在你拥有了一个文件描述符，可以继续用于读写。

假设你按照自己说的方式来使用——比如说你想读取或者写入，它应该会工作。好吧，因此我们首先进行所有的权限检查，然后所有后续的读写操作都不再做权限检查。所以如果你看看这里，例如我们在这个时刻做了权限检查。然后现在，当我们进行读取时，我们只需要提供文件描述符，而不需要再说文件名或者其他任何事情，因为打开操作现在已经有了一个有效的文件描述符，我们就直接使用它。

不要。好吧，它是一个索引，文件描述符是内部表格中的一个索引，我们将进一步讨论这一点。好吧。所以这里的模式是我们总是先打开。它是基于字节的，因此不管我是否抓取了大块的字节都无关紧要。假设它是字节，因此我可能会说我想要1024字节，或者我只需要一个字节。好。

它不在乎。哦，它不在乎这是什么，或者那些字节代表什么，它只是给我字节，或者为写入字节而取字节。我们明确地关闭它。好吧。所以，内核中的读取其实是有缓冲的。因为磁盘，正如你将在本学期稍后学到的，通常以1024或4096字节为一块来处理。甚至从磁盘读取一个字节都没有意义。

所以，在低级接口中，当你使用系统调用并请求几个字节时，内核实际上有它自己的缓存，我们稍后会讲到。我们会讲到缓冲区缓存，它存储来自磁盘的一块块数据，并以一种让它看起来像是字节导向的方式喂给用户。所以这就是“一切都是文件”。一切都是字节导向的文件，底层存储是基于块的，我们给了它一个一切都是文件，且一切都是字节导向的假象。

所以，我不确定我们是否在内核中，因为你也不能向磁盘写入单个字节。好吧。所以所有这些都在内核内进行缓冲。而这个缓冲算是一种在整个机器上的全局缓冲管理。为了让事情变得复杂一点，缓冲是由操作系统完成的。

流缓冲由用户级库完成，这两个缓冲区如果你不小心并且不记得缓冲的地方，可能会让你遇到麻烦。好吧。但你会习惯的。别担心。我们也会确保这一切都能让你理解。此外，还有许多其他低级操作。我提到了 iocthal 接口，用来改变分辨率和终端等。

以及错误率之类的。有一些方法可以复制描述符，稍后你会学到很多关于你 shell 的内容。举个例子，我可以取一个旧的文件描述符，然后说，取这个文件描述符，把这个新的文件描述符作为旧文件描述符的副本。

等等。这里有管道，它们是进程间通信的一种方式，你将会了解它们。还有文件锁定的方式，文件内存映射的方式，这样你就可以在进程间共享数据。异步IO的方式，各种各样的东西。但是这里的关键点是，记住一切都是文件。好吧，以我通过系统调用接口与之交互的方式来看。

一切都有打开、读取、写入、关闭，几乎所有的东西。即使我在和网络通信，或者在和一个文件通信，或者在和另一个进程通过管道通信，所有这些我读取和写入的东西都像是文件一样，而这就是。

今天讲座的标题是：一切皆文件。是的，连鼠标也是一个文件。好的，你可以打开文件系统中的/ dev部分的流，在那里你可以找到一个原始端口进行读取。好的，那么高级和低级API之间有什么区别呢？我将它们放在同一讲座中，因为我希望你们始终思考：它前面有没有一个F。

它是F open还是open，我是不是将文件指针和整数混淆了。我希望你们至少知道它们两者都存在，这样你就不会混淆。好的，但是如果你查看高级流接口。

发生的事情是，F read函数实际上在lib C中，并且有一大堆在用户级别运行的内容。就像一个普通函数，它可能偶尔会进行系统调用，其中包含一些汇编头文件等内容，这些你会在项目一中学到。

然后我调用内核，内核为我做一些事情，接着我退出内核，做更多的用户级别的操作。所以我有点像是在用一些有趣的用户级别的东西（比如流中的缓冲）来封装这个内核接口。

这就是我如何获得高级的流式读取、写入、打开F read、F write、F open。低级的基本上就是直接与内核交互的原始接口。所以这是一个原始的系统调用，我作为这个原始的系统调用进行读取。F read会做一些其他的缓冲操作等等。好的。

所以，实际上，高级API通过在其周围包装内容，使其对人们更有用。好的，正如Anthony在聊天中所说的，你应该查看一下/ damn /，里面有各种奇怪的文件，如果你是超级用户，你可以做很多事情。所以我只想做一件最后的事情，记住所有的缓冲，因此流是缓存在用户内存中的。

比如，print F作为一个流接口，实际上是这样的，它基本上接收一个行首，我休眠一会儿，然后说行尾。这个过程中有足够的缓冲，它会在用户级别等待，直到遇到换行符（即斜杠n），然后它才会发送。

结果会在屏幕上显示出来。如果我使用非常低级的操作，比如我写入标准输出的行首并且休眠，然后说行尾。那么发生的事情是你会看到行首，等待10秒钟，然后才会显示行尾。

这样做的原因是，在这种情况下，缓冲是在用户级别进行的。好的。所以我提到的内核中的缓冲缓存对用户来说是不可见的。好的，它在那里，你偶尔需要刷新以将某些内容推送到磁盘，但大多数时候你可以忽略用户级别的缓冲。对于流式接口，你需要稍微小心一些。好的，我今天行政事务稍微晚了一点，所以我的办公时间。

我觉得现在我们打算在星期二和星期三进行一次到两次会议。所以我挑了一个上课的日子和一个不上课的日子，希望大家能够参加。我可能会做一次 Zoom 会议，或者我会发布一个 Zoom 链接。我们看看下周的情况，理论上下周我们会在办公室。

现在等候名单上没有人了，所以所有将参加这门课的人都已经在课上了。明天是退课的最后期限。所以请确保，如果有你们的朋友可能忘了退课但最终决定不继续上课，赶紧处理。

确保他们明天来一趟。好吧，每个学期结束时，总有人会来找我说，哦，库比教授，我忘记退课了，现在遇到麻烦，想申请退课，但是并不总是能通过。所以请确保他们退课，如果你打算退课，也请退掉。否则，你应该开始组建小组了。好的。

我会说，你们需要确定谁会参加这门课。你们需要四人一组。我们有一个小组形成的链接，你们可以选择想参加的讨论课。快去完成这个任务吧。好的。另一件事是，如果你仔细看网站，会发现随着我们逐渐深入，更复杂的内容，网站上会有一些你们教材里的阅读材料，你们应该去看看。我知道有些人喜欢通过阅读来深入学习，所以你们应该利用课前的时间看看章节，帮助你们理解我们接下来会讨论的内容。

好的。你们应该去参加上周和这周的讨论课，明天和周五也有，因为在这些早期的讨论课中，我们尝试向你们提供一些信息，帮助你们为项目做好准备。

对于讨论课没有任何作业或限制，大家可以去任何一个讨论课。所以，去吧，下一周五，我们将分配小组，届时你们就会有自己固定的讨论课。小组报名系统已经启用，你们小组里的所有人应该去同一个讨论课，或者如果因为某些原因不能去同一个课，可以去两个有相同助教的讨论课。好的。好吧，我想，接下来是期中考试一。

二三，所有的日期已经确定。时间是七点到九点。现在就剩下处理冲突等问题了。关于冲突的其他事情我们会在接下来的过程中讨论。我没有把这些放到幻灯片上，但我想说的是，作为一个常规事项，我们需要面对现实了，差不多是时候了。

下周会进行面对面的课程。如果你生病了，请不要来上课，也不要去上你的辅导班。我们会有方式帮你补上可能错过的内容等。请不要来上课，我们希望确保每个人都能保持安全和健康。好的，我们不会检查大家是否到场等情况。

这会让你相信你需要生病时也来上课，如果你觉得自己生病了必须来上课，请不要这么做。你可以问一下你的助教是否有不确定的地方，看看如何补救。好的，关于我的管理工作就这些了。我知道安东尼会给你们一些办公时间。我之前没能从他那提前得到这些信息，但我会把它们发布到网站上。

如果他愿意的话，可以把它们发到聊天里。好了，回到正题。上一张幻灯片上有几个问题。一个是关于写操作是如何缓冲的。关于缓冲写操作的回答是，它们在高层和低层都被缓冲。在高层，发生的情况是，如果你写入几个字符，它们会进入用户内存中的缓冲区。

所以你写了几字节到文件，可能直到你刷新（flush）和关闭文件，它们才会真正写入磁盘。好的，所以你需要小心，因为高级缓冲的目的是减少内核之间来回的交互次数，因为进入内核的操作是昂贵的。这是写入的一种方式，你通过`F right`一次写入一个小字符。

然后最终你会说一个刷新（flush），然后它会被推送到磁盘，通过一个单独的`F right`。好的，这个过程也发生在内核内部，对你来说更加透明。你将通过系统写入一堆单个字符，依次调用它们。它们会被缓存在内核内部，你需要确保它们被刷新到磁盘上。

如果你想确保它们在磁盘上，但除此之外，你不会知道太多低层次的细节。但你需要知道缓冲区的存在。另一个问题是，为什么会有延迟，这里是一个缓冲的情况，我们的打印行开始会进入用户空间中的缓冲区，因为`printf`在等待一个斜杠（/），在发送内容之前。

直到你写入行结束符，并插入一个反斜杠和换行符（new line），它才会真正显示到屏幕上。好的，那我们再往下看。好的，我们来看看系统调用接口，我给你们一些系统调用的实际例子，比如`read`和`write`。

你知道的，`for`是另一个系统调用。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_16.png)

所以，如果你查看例如Linux系统调用的参考文档，会看到有很多的系统调用，比如退出、读取、打开等等。这些都有编号。好的，为什么系统调用有编号？我们为什么为系统调用使用编号，而不是函数指针？没错。所以我们这么做是因为我们在一个向量表中进行索引。

因为我们不能信任用户仅仅说一个通用的函数调用。哦，我知道哪里有fork的地址，把它交给它。所以我们需要进入内核，切换到内核模式，然后从一个明确定义的、经过验证的函数开始，比如读取函数。

这就是为什么一切都有一个编号。好的，实际的系统调用是一个特殊类型的同步陷阱，它传递一个调用号。并且它会在一个向量表中查找。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_18.png)

好的，关于我们上面谈到的读取和写入接口，在系统调用层面，我们一直在谈论描述符号。好的。顺便提一下，系统调用的数量远远不止255个。所以我们有一个描述符号，它是一个整数，在更高层次下。实际上，在内核内存中有一个结构体，它表示你已经打开的文件，这个结构体是用户看不见的。

好的。所以在顶层有一个整数，而描述符内实际上是一个指向文件的结构体。用户所知道的这个整数通过索引进入一个表来查找这个底层结构。好的。我们不会深入讨论。但如果你查看Linux内核，或者查看Pintos内核，你会发现有一个文件结构体。所以，用户无法看到它，且至少有两个非常重要的部分，一个是。

如果它是一个文件，文件在磁盘上的位置在哪里，文件系统磁盘文件。这是一个已知的指针，我们将在讨论文件系统是如何构建的时候讲到它。这就是当前位置，所以每次你读取一个字节，内核中的位置都会自动前进，这样后续的读取就会超出已经读取的部分，你可以进行一系列读取，从文件的开始读取到文件的末尾。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_20.png)

好的。那么，系统调用到驱动程序的过程是怎么样的呢？让我们看看，当你执行读取系统调用时，它实际上会进入内核。它查找该读取的文件结构体。然后它会调用一些内部函数，比如VFS读取，我们将在本学期稍后讨论虚拟文件系统接口。所以，我们会给你一个概念，展示这个我们刚才提到的文件结构体，内核知道它的存在。

这里是用户询问的参数。好的，从文件中读取最多`count`字节的数据并放入缓冲区，所有这些内容都已经进行了合理性检查，并将在内核内进一步检查。然后确保你被允许读取文件。我们确保文件有读取方法。好的，所以每个文件实际上都有一组你可以执行的操作，如果你尝试读取一个没有读取选项的文件，你将会失败。

你知道那是什么例子吗？那可能是一个输出流，比如串行连接，你不能从输出连接中读取，因此它就不会有读取方法。如果你尝试读取它，它会失败。我们还会检查缓冲区是否具有适当的权限，因为我们不相信用户提供的缓冲区是好的。

我们检查是否正在从文件中的有效范围读取数据。然后进入实际的读取操作。好的，这里有一个函数表，如果该特定类型的文件，如果它的设备驱动允许你执行同步读取，那么它就会使用这个函数。否则，它将会基于异步读取构建一个同步读取。

好的，你不需要担心所有的细节，我只是给你一个大致的概念。好的，然后有一个通知，表示“哦，有人读取了这个”，这是给文件的父进程的。我们会更新当前任务读取的字节数，这是一些统计信息和其他统计信息，然后退出。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_22.png)

![](img/b59c0e1f5f8864879bc09f46bc086ef0_23.png)

好的，当你调用系统调用读取时，类似这样的操作将在内核级别执行。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_25.png)

好的。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_27.png)

现在，我们回到这里，注意我提到过这个文件。这是一个获取文件本身指针的操作。查看它的f op子字段，然后查看其中的读取方法。这实际上是该类型文件的设备驱动，无论它是什么。如果它是在文件系统上，它可能是一个磁盘设备驱动，或者它可能是一个文件系统。好的。

这些都是很多不同的选项。它可能会引用鼠标，正如大家早前提到的。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_29.png)

好的，设备驱动实际上有一个像这样的结构，叫做文件操作结构。每当一个新设备被加入系统时，都会注册一个文件操作到设备驱动中，基本上告诉内核如何执行所有这些操作。如何读取？如何写入？如何执行其他操作。好的。

所以，关于我们的想法，所有东西都是文件，这是至关重要的。因为我们能够将所有东西都当作文件，并且拥有相同的打开、读取、写入、关闭接口的方式是：我们可以关注的每一种设备类型，或者我们可以尝试进行读取、写入、关闭、打开操作的所有东西，都会注册文件操作。

所以，内核实际上可以做同样的事情。你给它一个读取请求，它会进入那个 VFS 读取例程。它自动知道应该向哪个设备驱动程序请求数据。是磁盘吗？是你的鼠标吗？是网络吗？

![](img/b59c0e1f5f8864879bc09f46bc086ef0_31.png)

好的。那么，什么是设备驱动程序？设备驱动程序是内核中与设备硬件直接交互的特定于设备的代码。它为你提供了一个标准接口——打开、读取、写入、关闭。还有一个 I/O 控制系统调用，用来对设备执行特殊操作。好的，设备驱动程序通常分为两个部分，你们也会接触到。

上半部分来自用户并在系统调用级别工作，提供打开、关闭、读取、写入、I/O 控制、策略等。然后是下半部分，负责处理来自设备本身的中断。因此，所有来自该设备的中断处理程序都会在下半部分运行。好的，我再次强调。

本讲座是关于这一切如何相互联系的不同方式。如果你考虑从文件读取。好的，你看到的是用户程序即将进行读取。因此，它将通过发起系统调用请求一些 I/O 操作。如果我们执行读取操作，可能该读取的内容已经缓存在内核的缓存中。

在这种情况下，如果数据已经在那里，那么我们就会有一个快速的路径从内核返回。我们只需要从缓存中复制数据，调整指针，然后顺利返回。但如果没有，我们可能需要请求磁盘设备开始读取，并且我们会将进程挂起。

这实际上意味着，用户进程的一半会在设备繁忙时被挂起。好的，我们下次会详细讨论调度和挂起的内容。但是想象一下，如果一个用户进程正在尝试从磁盘读取，那是一个长延迟操作。这里有一个数字，希望到学期结束时你们会自动知道，如果问到进行磁盘读取需要多少条指令。

好的，嗯，这很大程度上取决于具体情况，但一个需要记住的数字是，一百万条指令的时间。好的，进行一次离散操作需要这么多时间，这非常长。所以我们不希望浪费所有时间等待磁盘，因此我们将进程挂起。

这意味着其他人可以工作。好的，设备驱动程序的上半部分可能会让我们进入休眠状态。然后我们设置磁盘进行读取，因此，硬件隐式地监控并等待中断，但其他部分正在运行。

最终，中断会到来，中断处理程序将运行，唤醒那个正在休眠的进程。好的，然后它会从中断返回，调度器会接管，并注意到该进程应该重新运行。它会从设备驱动程序的缓冲区中复制数据，等等。然后将数据传输到用户缓冲区并完成操作。好的。文件。

所以，这个过程略过了文件系统的部分。好，想象一下这是从一个没有复杂文件系统的设备读取数据，而是像原始磁盘或者其他类似的设备。所以，这是在处理读取操作，记住，所有东西看起来都像是一个文件。

所以，这是读取系统调用。一旦我们进入文件系统，文件系统就像这里的这个蓝色问号。好的，文件系统和文件接口的概念就是在这里处理的。好的，但我们稍后会讨论这一部分。最后一件事。好的，我喜欢那个评论。

聊天中有个评论说，操作系统并没有真正轮询I/O设备，而是给它发出一个警报。是的，我们做的是设置所有东西，使得进程在等待队列上等待一个事件，这个事件在这个案例中是来自设备的中断。因此，进程在与设备相关联的等待队列中休眠。

硬件本身会引发一个中断，唤醒该进程并将其从等待队列中移除，重新置为准备运行状态。所以，是的，操作系统不需要像我在这里描述的那样轮询来等待设备。好，最后但同样重要的是，让我们将“所有事物都是文件”这一观点推得更远。那么，关于通信呢？假设一个进程打开文件进行写入，而另一个进程则以读取模式打开它。

我们可以像这样在进程间进行通信吗？当然可以。对吧？我们可以在这里写入文件，另一个进程可以从文件中读取，数据会通过文件系统传输给另一个进程。我们就这样在两个进程间进行了通信。现在，如果我们只写一次数据，并且只读取一次数据。这就真正像一个队列。

这有点浪费，因为我们正在把数据写入磁盘，但这些数据不会再被读取，对吧？因为这就像一个队列。因此，我们可以开始考虑一个队列。事实上，你通常会想到的典型例子是网络。例如，我们在网络的两端都有队列。

我们设置好它们，客户端向队列写入数据，这些数据通过网络传输到服务器端的另一个队列，服务器从中读取。好的，这些是通过互联网连接的队列。但请注意，接口看起来仍然像一个文件。好的。

我们正在读写文件描述符。所以问题可能是，这里的 open 类似物是什么？好的，名称空间是什么？它们如何在时间上连接？所有这些东西，我们得弄明白。但简单的概念是，一切都是文件。事实上，我们可以继续这样想。对吧？我们可以把一个单一机器上的客户端-服务器看作是客户端发起一个写请求。

好的，然后它等待响应。运行在同一台机器上的服务器读取请求，处理后发送回去。通过读取，我们唤醒并继续进行。好的，这在单台机器上是可行的，但瞧，加入网络后怎么样？好的。现在听起来不错。好，这开始看起来像是一个网页服务器了，对吧？

所以，套接字抽象实际上是一个队列的概念，从一个终端点传递到另一个终端点。这些终端点实际上可以跨越网络。好的。例如，当我们在两侧都有套接字时，这中间其实可以包含网络。而一个进程在一端打开套接字，另一个进程在另一端打开。

我们有某种方式连接这两者。如果我们做到这一点，那么我们就能在一方写入，在另一方读取，它就会正常工作。好的。现在，套接字是通信的终端点的概念，它们是暂时存储结果的队列。这些队列不一定非要跨网络。

它们可以在同一台机器上，也可以跨网络。实际上，我们可以……我们可以让这两个客户端-服务器代码集相同，其中一个在同一台机器上运行，而另一个在不同的机器上运行。我们稍后会深入讨论这种灵活性。

所以，通过互联网或网络连接的两个套接字为我们提供了网络上的进程间或进程内部的通信。好，我们还是不知道如何打开它或名称空间是什么。好的。聊天中的一个好问题是，如果我去做一个读取操作，而那边没有数据，怎么办？答案是，没问题，它会进入休眠状态，直到数据到来。好的，没错。

好的，现在，实际上，这正是如此。聊天中的问题是，如果我们尝试不通过将一切视为文件来实现，情况会如何？所以，在 Unix 中，你不能做到不把一切都视为文件。好的，在 Unix 中，正是这样一个接口。在这种情况下，套接字并没有将内容存储到磁盘，它们只是传递数据的队列，从一端到另一端。

但是，写入和读取的接口看起来和文件接口完全一样，这就是一切都像文件一样的思想，接口也是相同的。好吧。两个进程能共享一个套接字吗？两个进程可以拥有套接字的两个端点。好吧。我们稍后会看不同的通信方式。好吧。更多细节，套接字是网络连接一个端点的抽象，例如。

大多数操作系统都提供套接字功能，即使它们没有 Unix I/O API 的其他部分。好吧。它们最早是在 BSD Unix 中引入的。好吧。4.2 版本很重要的是，4.2 BSD 是一个大事件。这是在每个人都没有像现在这样使用互联网的日子里发生的事情。当时，伯克利大学正在发布 4.2 版本的最终版本，将其复制到磁带上。

当时有很多人在伯克利等着拿到磁带，将其带回公司，然后将其加载到他们的机器上。所以，4.2 BSD 版本带来了极大的兴奋，套接字只是其中的一个重要部分。好吧。它是很多类型网络的相同抽象，包括没有网络的情况。

所以它在机器内部是本地的，互联网的 TCP、IP、UDP、IP 都与套接字配合使用。甚至是一些现在没人再使用的东西。还有像 OSI、Apple Talk 和 IPX 等类型的网络，也都使用套接字。好吧。所以它看起来就像一个具有读写权限的文件描述符的文件。好吧。现在，不是所有的文件类型调用都能正确工作，比如你不能在套接字上执行 seek 操作。好吧。

但是你可以读写它。那么，如何使用套接字来实现实际应用呢？好吧，它是一个字节流。实际应用通常需要在其上封装其他内容，比如消息传递功能或远程过程调用功能，这些功能基本上可以序列化和编码数据，等等。我们将在本学期稍后时间详细讨论这个问题。但现在。

我们只是通信字节。所以这是一个简单的回显服务器示例。客户端发送 hello world，服务器回应 hello world。好吧，这是一个挺傻的例子。它是这样的。这里是两个套接字。假设它们已经连接。那么在客户端，我们要进行回显。但在那之前，服务器启动并进入等待读取状态。

这是一个阻塞读取。客户端可能通过 `fgets` 从用户那里获取一个字符串，用户会输入 hello world。然后它将使用这个结果缓冲区，写入到套接字。接着，它将执行读取操作，这将导致它等待。所以它在等待回显。它把值写入了网络，然后等待。与此同时。

数据从套接字发送到服务器端。服务器会接收它，打印到自己的屏幕上，然后发送回去。数据通过网络传输，唤醒客户端，然后，哇，我们刚刚进行了回显，然后双方都会重复这一过程。好的，现在，问题来了。字符串是否保证一次性返回，还是会分块返回？

事实上，它并不保证一次性返回。因此，实际上你可能需要执行多次读取，来寻找末尾的空值。好问题。那么这里有一段相对简单、快速的代码。我假设套接字已经打开，因为我还没向你展示如何做到这一点。

但在这里，我们有一边的写入和另一边的读取，注意我没有像应该做的那样在循环中检查读取操作。这是一个好问题。但接着，我会获取结果，假设没有错误发生。我将它写回去，然后得到我的回显。好了，回显回显回显。那么我们在这里做了什么假设呢？我们假设它是可靠的。所以当你写入它时。

你会把它拿回来。所以没有丢失任何内容。这是一种特殊类型的套接字。我们需要设置一个TCP套接字与另一方连接。我们假设一切正常，所以这也得到了TCP套接字的帮助。那么什么时候准备好呢？我们将依赖于读取操作去休眠。如果没有字节准备好。那么我们怎么创建套接字呢？嗯。

文件系统基本上提供了一组永久性的对象。而且，你知道，打开文件是很容易的。但是套接字有点奇怪，对吧？

所以这是两个完全不同机器上的进程之间的双向通信。所以我们必须有某种方式在我们想要建立连接的愿望和某个远程提供服务的愿望之间进行对接。所以问题就变成了，我们如何命名我们正在打开的对象。以及这些完全独立的程序如何知道另一个程序想要与它们通信。

好的，我将完成这部分内容，但让我们先保持思考。这里的命名空间是什么？我们有文件系统，命名空间就是所有可能路径名的集合，对吧？在网络通信的情况下，命名空间就像是主机名或IP地址。还有端口号，所以给定的IP地址代表一台机器，而端口号则代表一个服务。

好的，通常，如果你连接到某个人，实际上是连接到IP地址和端口的组合。好吧，今天我们要讨论的最后一件事就是这个。请再忍耐我两张幻灯片。那么我们实际是如何设置套接字的呢？服务器端通过创建一个所谓的服务器套接字来开始。

然后那个服务器套接字执行了一个监听。这个监听的作用是，我在等待有谁想要连接到我的IP地址和大家都知道的这个端口上。可能是回声端口，也可能是Web服务器端口。好的，稍后客户端发起连接请求，说“你好，这是我的地址，这是我有的端口。我想连接。”如果服务器套接字接受了连接请求。

然后它创建了一个全新的套接字并建立了连接。好的，基本上那个连接现在是一组连接的套接字。这些是绿色的套接字。那个黄色的连接实际上是通过五元组来唯一定义的。这个五元组包括源IP地址、目标IP地址。

源端口号、目标端口号和协议，在这个情况下是TCP。好的，客户端端口号为了确保唯一性，通常是随机选择的。而那个知名的端口通常是80（Web端口）或者443等。好的，那么，我们需要结束了。总的来说，系统调用接口是用户程序与内核之间的一个狭窄接口。

流式输入输出（Streaming IO）是一系列字节。大多数流式函数以F开头，比如F3。我们还有一种稍微底层的输入输出，它是真正的内核接口。好的，系统调用。我们讨论了组合方式，讨论了设备驱动程序是什么以及它们是如何工作的。而文件抽象基本上用于所有的内容。好的。

然后我们终于完成了关于套接字的内容，下次我们会继续讲解。抱歉，我讲得有点超时了。希望大家度过一个愉快的晚上，我们下次见。再见。[沉默]。

![](img/b59c0e1f5f8864879bc09f46bc086ef0_33.png)
