![](img/888f4959ddbb2f061b653e72a9b8e495_1.png)

# CS162 第三讲：进程、系统调用与Fork 🧠

![](img/888f4959ddbb2f061b653e72a9b8e495_3.png)

在本节课中，我们将要学习操作系统中的核心概念：进程、系统调用以及创建新进程的 `fork` 机制。我们将从进程的基本定义开始，探讨操作系统如何通过系统调用和中断与硬件交互，并最终理解如何创建和管理多个进程。

![](img/888f4959ddbb2f061b653e72a9b8e495_5.png)

---

![](img/888f4959ddbb2f061b653e72a9b8e495_7.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_9.png)

## 进程与地址空间回顾

![](img/888f4959ddbb2f061b653e72a9b8e495_11.png)

上一节我们介绍了线程和地址空间的概念。本节中，我们来看看如何将它们组合成一个完整的进程。

一个**进程**是一个正在运行的程序实例。它包含一个或多个线程，并拥有一个受保护的**地址空间**。地址空间是程序可以访问的内存地址集合，它通过硬件翻译机制（如基址-界限或分页）与物理内存隔离，从而保护进程之间以及进程与内核之间互不干扰。

![](img/888f4959ddbb2f061b653e72a9b8e495_13.png)

进程的核心数据结构是**进程控制块**，它存储了进程的所有状态信息，例如进程ID、寄存器值、内存界限等。

![](img/888f4959ddbb2f061b653e72a9b8e495_15.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_17.png)

---

![](img/888f4959ddbb2f061b653e72a9b8e495_19.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_21.png)

## 进程切换与保护机制

![](img/888f4959ddbb2f061b653e72a9b8e495_23.png)

我们已经知道操作系统需要在多个进程之间切换。这种切换是如何在保护机制下安全进行的呢？

![](img/888f4959ddbb2f061b653e72a9b8e495_25.png)

关键在于**双模式操作**。硬件支持至少两种模式：**用户模式**和**系统模式**（内核模式）。用户模式下的进程权限受限，无法直接访问硬件或内核内存。当需要操作系统服务或发生外部事件时，会通过受控的路径切换到系统模式。

![](img/888f4959ddbb2f061b653e72a9b8e495_27.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_29.png)

以下是触发从用户模式切换到内核模式的三种主要方式：

![](img/888f4959ddbb2f061b653e72a9b8e495_31.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_33.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_35.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_36.png)

1.  **系统调用**：用户程序主动请求内核服务（如读写文件）。
2.  **中断**：由外部硬件设备触发的异步事件（如定时器到时、网络数据到达）。
3.  **异常**：由正在执行的指令引发的同步事件（如除零错误、页错误）。

![](img/888f4959ddbb2f061b653e72a9b8e495_38.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_40.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_42.png)

当中断或系统调用发生时，硬件会原子性地完成以下操作：
*   保存当前用户程序的程序计数器（PC）和栈指针（SP）。
*   切换到系统模式。
*   将程序计数器设置为预定义的中断向量或系统调用处理程序的地址。
*   切换到内核栈。

这个过程确保了进入内核的入口是**唯一且受控的**，防止了恶意用户代码破坏内核。

---

![](img/888f4959ddbb2f061b653e72a9b8e495_44.png)

## 系统调用工作流程

系统调用是用户程序使用操作系统服务的主要方式。它的执行流程如下：

![](img/888f4959ddbb2f061b653e72a9b8e495_46.png)

1.  用户程序将系统调用编号和参数放入约定的寄存器或栈中。
2.  执行特殊的指令（如 `int` 或 `syscall`），触发从用户模式到系统模式的硬件切换。
3.  内核根据系统调用编号，跳转到对应的处理函数。
4.  内核在**验证所有参数安全**后，执行服务（例如，检查用户提供的指针是否指向其合法的地址空间）。
5.  内核将结果复制回用户空间。
6.  执行返回指令，恢复用户寄存器并切换回用户模式，用户程序从调用点之后继续执行。

![](img/888f4959ddbb2f061b653e72a9b8e495_48.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_50.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_52.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_54.png)

**关键点**：内核绝不信任用户输入。所有来自用户空间的参数都必须经过严格验证。

![](img/888f4959ddbb2f061b653e72a9b8e495_56.png)

---

![](img/888f4959ddbb2f061b653e72a9b8e495_58.png)

## 创建新进程：Fork

![](img/888f4959ddbb2f061b653e72a9b8e495_60.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_62.png)

现在，我们来看一个创建新进程的核心系统调用：`fork`。

![](img/888f4959ddbb2f061b653e72a9b8e495_64.png)

`fork` 是一个特殊的函数，调用一次，却会“返回”两次。它的作用是**复制当前进程**，创建一个几乎完全相同的子进程。

以下是 `fork` 的基本行为：

*   **在父进程中**，`fork` 返回新创建的子进程的进程ID（PID），这是一个大于0的值。
*   **在子进程中**，`fork` 返回0。
*   如果创建失败，则在父进程中返回-1。

子进程是父进程的副本，它拥有：
*   相同的代码段、数据段和堆栈内容。
*   相同的文件描述符表（指向相同的打开文件）。
*   独立的进程ID和地址空间。

以下是一个简单的 `fork` 使用示例：

![](img/888f4959ddbb2f061b653e72a9b8e495_66.png)

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t cpid = fork(); // 在这里，进程一分为二

    if (cpid > 0) {
        // 这段代码只在父进程中执行
        printf("I am the parent. My child's PID is %d.\n", cpid);
    } else if (cpid == 0) {
        // 这段代码只在子进程中执行
        printf("I am the child. My PID is %d.\n", getpid());
    } else {
        // fork 失败
        perror("fork failed");
        return 1;
    }
    return 0;
}
```

![](img/888f4959ddbb2f061b653e72a9b8e495_68.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_70.png)

![](img/888f4959ddbb2f061b653e72a9b8e495_72.png)

**理解 `fork`**：可以想象在 `fork()` 调用执行完毕的瞬间，操作系统复制了整个进程，并让两个进程都从 `fork()` 返回处开始继续执行。唯一的区别就是返回值，程序通过判断这个返回值来决定父进程和子进程后续执行不同的逻辑。

`fork` 常与另一个系统调用 `exec` 配合使用，后者用于将当前进程的地址空间替换为一个全新的程序。这是 Shell 运行新命令的基础：先 `fork` 出一个子 Shell 进程，然后子进程调用 `exec` 来执行目标命令。

---

## 总结

本节课中我们一起学习了：
1.  **进程**是拥有独立地址空间和执行资源的程序实例，是操作系统资源分配和保护的基本单位。
2.  通过**双模式操作**、**中断向量**和**独立内核栈**等机制，操作系统实现了从用户模式到内核模式的安全、受控切换。
3.  **系统调用**是用户程序请求内核服务的标准接口，内核在执行前会严格验证所有参数。
4.  **`fork` 系统调用**通过复制自身来创建新的进程，这是 Unix/Linux 系统中创建进程的主要方式，它创造了一个与原进程几乎完全相同的子进程，并通过返回值区分父子进程的后续执行路径。

![](img/888f4959ddbb2f061b653e72a9b8e495_74.png)

理解进程的创建、切换和保护机制，是掌握操作系统如何管理并发和资源的基础。在接下来的课程中，我们将深入探讨进程调度、线程以及进程间通信等高级主题。