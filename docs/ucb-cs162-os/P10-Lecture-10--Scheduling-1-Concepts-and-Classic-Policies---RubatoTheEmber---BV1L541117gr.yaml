- en: P10：Lecture 10： Scheduling 1 Concepts and Classic Policies - RubatoTheEmber
    - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P10：第10讲：调度概念与经典策略 - RubatoTheEmber - BV1L541117gr
- en: Okay， welcome everybody to the first post midterm one lecture。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎大家来到第一次期中后的讲座。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_1.png)'
- en: Yeah， you survived。 So we're actually going to do a little bit of a change in
    topic。 Let me make sure。 Let's see。 Can everybody see my slides？ Also in cyber
    space。 Okay。 so if you remember。 I wanted to review a couple of things that we
    were doing just at the very end。 And so we can close out kind of a bit on synchronization
    here。 So， first of all， if you remember。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你们成功了。所以我们实际上将稍微改变一下话题。让我确认一下，大家能看到我的幻灯片吗？虚拟空间里的朋友们也能看到吗？好的，如果你记得，我想回顾一下我们在最后做的一些事情，确保同步部分可以结束。所以，首先，如果你记得的话。
- en: we talked about semaphores last time in more detail。 And there's two uses of
    semaphores。 So semaphores have an initial number。 Value that you set when you
    allocate them。 And if you set that value to one， you basically just get a mutex
    or what's called a binary semaphore and you can use it for locking。 And so you'd
    use it like this， where you do the P operation down and the V operation up when
    you're done。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我们更详细地讨论了信号量。信号量有两个使用方式。信号量有一个初始值，这是在分配时设置的。如果你将这个值设置为 1，实际上你得到了一个互斥锁，或者称为二进制信号量，你可以用它来进行锁定。所以你会像这样使用它，做
    P 操作时把它减到 1，做 V 操作时把它加到 1。
- en: And if two folks try to do that semaphore P at the same time， one of them gets
    put to sleep。 And this is a purely atomic operation。 So it's not possible for
    two threads to get through there by accident。 Okay， so it will atomically decrement
    the value。 And if you're would go before zero。 put you to sleep。 We also looked
    at the fact that we could do scheduling constraints by setting the initial value
    to zero。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个人同时尝试做信号量 P 操作，其中一个会被挂起。这是一个纯粹的原子操作。所以两个线程不可能意外地同时通过这个操作。好的，它会原子性地递减这个值。如果你想递减到零以下，它会让你进入休眠状态。我们还看到了通过将初始值设置为零，我们可以实现调度约束。
- en: And that might allow you to do a joint operation。 So you set it to zero。 you
    go to sleep by trying to do a P operation。 Anybody else could wake you up with
    a V。 Okay。 and then finally， and so this is the example of thread join where the
    original parrot thread。 let's say， goes to sleep and then the finishing child
    thread executes a V and wakes them up。 Okay。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你进行一个联合操作。所以你把它设为零，然后尝试做一个 P 操作来让自己进入休眠状态。其他任何人都可以用一个 V 操作把你唤醒。好的，最后，这就是线程连接的例子，假设原始的“鹦鹉线程”进入休眠，然后结束的子线程执行
    V 操作把它唤醒。好的。
- en: and then finally we had the bounded buffer solution for the coke machine。 And
    this was a good example for three semaphores。 And if you remember the reason we
    had three semaphores was we have two conditions and a lock。 The two conditions
    have to do with bounding the maximum number of coke cans in the machine and saying
    that it doesn't make sense to have a negative number of coke cans in the machine
    so we're bounding the two sides。 Okay， and if you remember the code kind of look
    like this for the producer in the consumer。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后我们给出了可乐机的有界缓冲区解决方案。这是一个很好的三信号量的例子。如果你记得，我们之所以有三个信号量，是因为我们有两个条件和一个锁。这两个条件是关于限制可乐机中最大可乐罐数量的，同时也在说明不能让可乐罐数量变成负数，所以我们在两个方面都做了限制。好的，如果你记得，代码大概是这样的，用于生产者和消费者。
- en: This key pattern here is that we always protect things like in queue and because
    those are those are operations that could get screwed up if multiple threads go
    in them and so that's why we have new Texas around them。 And then we execute a
    semaphore P on the empty slots to make sure there is something before the producer
    goes in and the flip side for the consumer。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键模式是，我们总是像队列一样保护一些东西，因为这些操作如果多个线程同时进入可能会出现问题，这就是为什么我们在它们周围加上新的 Texas。然后我们在空槽上执行一个信号量的
    P 操作，以确保生产者进入之前有东西，消费者则是相反的操作。
- en: And so， you know， if you look， what's in red here are critical sections in the
    locking sense just to protect the cues。 And then we have this signaling that when
    the producer finally produces something they'll wake up somebody who might be
    sleeping。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你看这里的红色部分，是用来保护队列的临界区。然后我们有这个信号，当生产者终于生产了东西，它会唤醒某些可能正在休眠的线程。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_3.png)'
- en: And when the consumer kind of finally empties a can out they might wake up a
    producer。 Okay。 so before we leave this I just wanted to see if there were any
    last minute questions on this。 Semaphores are very common in operating system
    so。 All right， good。 So， however。 we said there's something even better。 Okay，
    a monitor which is a lock and zero or more condition variables。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者最终把罐子倒空时，他们可能会唤醒生产者。好吧，在我们离开之前，我想看看有没有最后的问题。信号量在操作系统中非常常见。好，好的。那么，然而，我们说过有更好的东西。好吧，一个监视器，它是一个锁和零个或多个条件变量。
- en: And actually if you only have zero condition variables it's not that interesting。
    And the condition variable was specifically a weight queue that you can go to
    sleep on with the lock being held that's the key idea here。 Okay， so unlike any
    other weight queue。 And the condition variable weight queue you grab the lock
    you check your conditions then you go to sleep if they're not satisfied。 And it's
    that weirdness， or difference in API that really makes them so powerful and easy
    to use。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，如果你只有零个条件变量，那就不太有趣了。条件变量专门是一个等待队列，你可以在持有锁的情况下去休眠，这就是关键的概念。好的，和其他任何等待队列不同的是，在条件变量的等待队列中，你先抓住锁，检查条件，然后如果不满足就去休眠。正是这种奇特的差异或者API的不同，使得它们变得非常强大且易于使用。
- en: There are three operations typically they got different names depending on what
    the packages are。 but roughly a weight， a signal and a broadcast。 And the rule
    is always hold the lock when doing any of these three operations。 Now， I know
    there are many of you who would say well why do I have to hold the lock to do
    a signal or a broadcast。 There are various reasons for that and depends a lot
    on the scheduling package as to whether that's legal but for now we'll just say。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有三种操作，它们根据不同的包有不同的名字，但大致是等待、信号和广播。规则是，进行这三种操作时，始终要持有锁。现在，我知道很多人会问，为什么我在做信号或广播时也必须持有锁。这个问题有很多原因，具体取决于调度包是否允许这样做，但现在我们只说。
- en: always hold the lock around everything。 Okay， especially in this class。 Are
    there any questions on the interface。 So we gave you this typical structure so
    if you're thinking about a monitor program this is one way to think about it。
    You grab the lock。 You check and see whether conditions are met or not。 And if
    they aren't met。 then you go to sleep。 And notice that that weight operation always
    happens。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 始终在所有操作中持有锁。好吧，尤其是在这门课中。接口上有什么问题吗？所以我们给了你这个典型的结构，如果你在考虑一个监视器程序，这是一个思考的方式。你抓住锁。你检查条件是否满足。如果不满足，你就去休眠。注意，这个等待操作总是会发生。
- en: Like a semaphore P which might not put you to sleep a weight always puts you
    to sleep。 This is the key interface aspect。 And then when you wake up with typical
    Mesa scheduling you always have to loop back and check your condition again。 And
    then you might somehow reserve the thing that you found you've got and then you
    can unlock and then when you end you kind of lock again and signal that you're
    done。 This is a pattern。 Okay， and we did that with the readers writers example。
    Okay。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一个信号量P，它可能不会让你休眠，而一个等待操作总是会让你休眠。这是关键的接口方面。然后，当你醒来时，使用典型的Mesa调度，你总是必须重新检查你的条件。然后你可能以某种方式保留你找到的资源，然后你可以解锁，结束时你再锁一次，并发送信号表示你完成了。这是一个模式。好吧，我们在读者-写者示例中做到了这一点。好的。
- en: And this was the readers writers example can have one writer or multiple readers
    but never a writer and reader will meet。 Okay， and actually unlike on the exam
    question， whatever it was。 The three C maybe you can't have two writers either。
    Okay， so one one writer at a time。 And that was the motivation for the code that
    we had here。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读者-写者示例，它可以有一个写者或多个读者，但读者和写者永远不会同时存在。好的，实际上与考试题目无关，不管是什么，三C题中也许你不能有两个写者。好的，所以每次只有一个写者。那就是我们这里代码的动机。
- en: which was this was a reader code where you grab the lock。 See the pattern there。
    You check and make sure there aren't any writers either active or sleeping ones。
    And if there are you become a waiting writer and you go to sleep。 And then when
    you wake up you're no longer a waiting writer。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个读者代码，你抓住锁。看到了模式吗？你检查并确保没有写者在活动或者休眠。如果有，你就变成一个等待的写者，然后去休眠。当你醒来时，你不再是一个等待的写者。
- en: you loop and you keep doing this until you get through without there being any
    writers in the system and in that case。 you do a plus plus saying， you're an active
    reader， release the lock and do the database access。 and then on checkout， you
    acquire the lock again， you decrement you're no longer a waiting reader。 And then
    there's this condition that if there are no readers left。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你会一直循环，直到系统中没有任何写者，在这种情况下，你就会执行`++`操作，表示你是一个活跃的读者，释放锁并访问数据库。然后在签出时，你再次获取锁，减少计数，表示你不再是一个等待中的读者。接着如果没有剩余的读者，就会触发某些条件。
- en: that are active but there's a waiting writer then you go ahead and wake them
    up with a signal and then you eventually release。 Okay。 And so why do we release
    the lock at this point。 Anybody remember？ What was the story。 Why do we release
    at this point。 That's right。 Remember this entry things not is not preventing
    access to the database。 What it's doing is it's protecting the entry conditions
    to the database。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那些是活跃的，但如果有等待的写者，你就会通过信号唤醒它们，然后最终释放锁。好的。那么，为什么我们在这个时候释放锁？有人记得吗？是什么原因？没错。记住，这个进入条件并不是阻止访问数据库。它的作用是保护数据库的进入条件。
- en: We need to release the lock so other threads can come in and classify themselves
    right。 And then the writer is similar， a little bit the same but different。 Okay。
    And so here。 our entry condition for the writer is there can't be any active writers
    or active readers。 in which case， if there are either of those we go to sleep。
    Otherwise we wake up， we do our access。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要释放锁，这样其他线程才能进入并自行分类。写者的情况类似，但稍有不同。好的。那么在这里，我们对写者的进入条件是：不能有任何活跃的写者或活跃的读者。如果有任何一种情况，我们就会进入睡眠状态。否则，我们会醒来并进行访问。
- en: which is a modification style access。 And then when we acquire the lock again
    we're no longer an active writer if there are any other waiting writers we wake
    one of them up。 Otherwise， if there are any waiting readers， we wake them all
    up。 And then we exit。 Okay。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种修改样式的访问。然后，当我们再次获取锁时，如果没有其他等待中的写者，我们就不再是一个活跃的写者。如果有等待中的写者，我们会唤醒其中一个。如果有等待中的读者，我们则会唤醒所有读者。然后我们退出。好的。
- en: And so again， why do we do a broadcast down here instead of signal。 Might have
    multiple readers wake them all up， right。 Okay， any questions on this。 Yeah。 Yep。
    right here you're saying， absolutely， get my little。 So right here， up， wake up。
    And then we'll get more than one waiting writer。 Ah， well。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次说明，为什么我们在这里使用广播而不是信号。可能有多个读者，唤醒他们所有人，对吧？好的，有没有问题？是的。没错，你在这里说的对，绝对是这样。所以在这里，向上，唤醒。然后我们会有多个等待中的写者。啊，嗯。
- en: you just anticipated a couple slides I was going to do here so the question
    is。 could we just to get rid of the check and just wake up a writer anyway。 And
    then we'll get to that as well。 Yes， because in that instance。 what would happen
    is they would check in that loop。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚预测了我接下来几张幻灯片的内容。那么问题是，难道我们不能直接去掉检查，并且无论如何就唤醒一个写者吗？我们会探讨这个问题。是的，因为在那种情况下，发生的事情是它们会在那个循环中检查。
- en: Now notice that what we do get by doing this set of if and else is。 is we make
    sure that we give priority to writers over readers。 And then we'll get in broad
    signal the writer， and then broadcast to the readers。 It's not clear whether one
    of the readers would wake up before the writer and so we would actually have violated
    what here is a priority of our policy。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注意到，通过执行这组`if`和`else`语句，我们确保了优先给写者而不是读者。这时我们会广泛地发出信号给写者，然后再广播给读者。尚不清楚是否某个读者会在写者之前醒来，若发生这种情况，我们实际上会违反我们政策中的优先级规则。
- en: which is always， let the writers go first。 Correctness wise， it would be fine。
    Okay。 it wouldn't violate the one writer or multiple readers。 Correctness condition。
    but it would violate the policy， but it seems to be what this particular code
    has right the policy is that writers get priority over readers。 Okay， good。 So
    that's actually leads to， you know， why give priority to writers。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是先让写者去执行。就正确性而言，这是没问题的。好的，它不会违反“一个写者或多个读者”的正确性条件，但它会违反政策。似乎这个特定的代码符合的政策是写者优先于读者。好的，很好。那么这实际上导致了，为什么要给写者优先权。
- en: There's actually a couple of reasons for that right one of them is that if you
    look at typical traces there are more reads and writes so giving priority to the
    writers is not a bad thing。 The other is you can imagine writers are making the
    data more up to date and so you get the writers or the readers a chance to get
    more up to date data。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这里有几个原因。其一是，如果你查看典型的跟踪，读取操作通常比写入操作多，所以优先考虑写者并不是坏事。另一个原因是，你可以想象，写者使数据更加更新，因此给读者提供了获取更新数据的机会。
- en: Okay。 That's not required。 You could do any other policy you want and in fact
    we even have done that another exams in the past。 The question here about why
    releasing the lock again I'm assuming the person who asked us in cyberspace talking
    about this release the lock up here。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这不是强制要求。你可以使用任何其他策略，事实上，我们过去也曾在其他考试中这样做过。这里的问题是为什么要再次释放锁，我假设问这个问题的人在虚拟空间中是在谈论在这里释放锁的事。
- en: The answer is we have to release the lock up there so that other threads can
    come in and classify themselves。 Okay， because if we hold the lock， then no other
    thread that comes in could get classified as a reader or writer。 Okay。 Now， the
    question that was asked is a couple here one is can the can the reader starve。
    What do you think。 Can this lead to a starvation condition。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们必须释放上面的锁，以便其他线程可以进入并进行分类。好的，因为如果我们持有锁，那么进入的其他线程就无法被分类为读者或写者。好的。现在，问题是这里有几个问题，一个是读者是否会饿死。你怎么看？这会导致饥饿现象吗？
- en: It's different from an incorrectness condition。 Who thinks it could why why
    why did it start go ahead。 That's right。 So if there's a continuous stream of
    writers the readers might never get to go。 Yes。 Okay， so if that's a use condition
    for you you might have to design your code slightly differently but monitors are
    powerful enough to do that。 What if we erase the condition check we just had that
    question right so what if we redraw out this。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它与不正确的条件不同。谁认为它可能不对？为什么？为什么它会开始？继续。没错。所以，如果写者持续不断，读者可能永远无法得到机会。是的。好的，如果这是你使用的条件，你可能需要稍微调整代码的设计，但监视器足够强大来处理这种情况。如果我们取消了条件检查，刚才我们问过这个问题，假如我们重绘出这个呢？
- en: Okay。 Will it still be correct。 Yes， it'll still be correct because of the while
    loop。 Okay。 at the entry way and that's kind of one of the reasons that Mesa is
    so much more preferred than the horse semantics is you can also be a little sloppy。
    Okay， you can wake up as long as you wake up more than you need to you know you'll
    still be correct。 The danger in these kind of situations is you could wake up
    not enough of them and then the thing would just sort of deadlock。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那这样做还会正确吗？是的，依然正确，因为有了 `while` 循环。好的，入口处就是这样，这也是为什么Mesa比“马语义”（horse semantics）更受欢迎的原因之一，因为你可以稍微松懈一些。好的，只要你唤醒的线程比需要的多，你仍然会是正确的。这种情况的危险是你可能唤醒的线程不够，接着系统就会死锁。
- en: Okay， so we don't want to do that。 Actually， I guess it's kind of a live walk
    will be more specific about that。 In a couple of lectures so， and then we could
    just turn this signal into a broadcast and wake all the writers up。 Why would
    that still be correct。 Yeah。 That's right only one writer would get it and the
    others wouldn't and the way to think about this is because of that lock at the
    beginning of the code。 All all threads entering the system are serialized by the
    lock so you only have them look one at a time at the conditions。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们不想这样做。实际上，我想这算是一个活锁，稍后我们会更具体地讲解。在接下来的几节课中，然后我们可以将这个信号转变为广播，唤醒所有的写者。为什么这样做还是正确的呢？是的。没错，只有一个写者会得到它，其他的写者不会。理解这一点的方式是因为代码开始时的那个锁。所有进入系统的线程都会被锁串行化，所以你每次只能查看一个条件。
- en: Okay， and so one at a time even if there's a thousand writers one at a time
    to go through the first one will get the ability to be an active writer the rest
    will be waiting later。 Okay， and then finally， what if we only use one condition
    variable。 Okay。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以下来一个一个地处理，即使有一千个写者，也是一个一个地处理，第一个将获得作为活跃写者的能力，其他的会在稍后等待。好的，然后最后，如果我们只使用一个条件变量，会怎么样呢？
- en: so don't separate between reads and writes and just say well it's okay to continue。
    Okay。 now it turns out that what I said about the loop is correct so we won't
    get incorrect behavior but what could happen if we don't use broadcast instead
    of signal。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不要将读取和写入操作分开，仅仅说“好吧，继续进行就可以了”。好的。现在事实证明，我说的关于循环的内容是正确的，所以我们不会得到不正确的行为，但是如果我们不使用广播而使用信号，可能会发生什么呢？
- en: Yeah。 That's right， because if the readers and writers are all on the same queue
    and we only wake up one we might not get the type of waiter we want。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。没错，因为如果读者和写者都在同一个队列中，我们只唤醒一个，那么我们可能无法得到我们想要的服务员类型。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_5.png)'
- en: Okay， and so， so for instance what if we turn okay to write an okay to read
    into a single okay to continue so this is different code here now see the red。
    And we have this scenario where our one arrives， then w one are to arrive。 well
    our one is still working。 And so then when that reader goes to check out。 If we
    only signal one。 Waiter than what will happen is we'll actually end up signaling
    the wrong person right we'll signal w one。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么例如如果我们将“okay to write”变成“okay to read”，再变成“okay to continue”，这样就变成了不同的代码，现在看到红色了。然后我们有这样的场景，假设我们的一个到达了，接着w一个要到达。嗯，我们的一个仍在工作。然后当那个读者去检查时，如果我们只发送信号给一个。服务员，那么会发生什么呢？我们实际上会发送信号给错误的人，对吧？我们会给w一个发送信号。
- en: but w one to wake up and say oh look， there are readers in the system maybe
    this doesn't work so we have to make sure that we get it correctly。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是w一个醒来后会说：“哦，看，系统中有读者，可能这样不起作用。”所以我们必须确保正确发送信号。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_7.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_7.png)'
- en: There， okay。 And so we put a broadcasting here just to make sure there's enough
    folks that wake everything up。 All right， and this is actually particularly challenging
    on the the writer the。 well it's challenging on both sides so basically you want
    to just broadcast。 All right。 Now。 our monitors fundamentally different than semaphores。
    Well， you might suspect the answer is no。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以我们在这里进行广播，只是为了确保有足够的人能唤醒所有的东西。好了，这对于写者来说尤其具有挑战性。嗯，它在双方都有挑战性，所以基本上你只想广播。好了，现在我们的监视器与信号量根本不同。嗯，你可能会怀疑答案是否定的。
- en: because we managed to somehow do a very complicated cue。 You know。 for the coke
    machine right so semaphores were pretty powerful。 So if they're really equivalent
    it seems like if we have semaphores we ought to be able to make monitors。 Doesn't
    it sort of like a， you know， completeness from a synchronization standpoint。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们设法以某种方式做出了一个非常复杂的提示。你知道的，对于可乐机来说，信号量是非常强大的。所以如果它们真的是等价的，似乎如果我们有了信号量，我们应该能够实现监视器。不是吗？从同步的角度来看，这不是某种完整性吗？
- en: And the trick though is we got to be careful。 So first of all locks are easy
    right monitors have locks semaphores you start you initialize it to a one you
    got locks easy。 Okay， promise it gets harder from there right so what if we try
    to implement condition variables like this weight takes a semaphore and does a
    semaphore P and signal does a semaphore V。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是技巧是我们得小心。首先，锁是简单的，对吧，监视器有锁，信号量你初始化为1，锁很简单。好了，保证从那里开始会变得更难，对吧？那么如果我们尝试像这样实现条件变量，等待会获取一个信号量，并执行一个信号量P，信号则执行一个信号量V呢？
- en: Does this work。 How many people think we could implement monitor condition variables
    this way。 How many people think we can't and if you raise your hand you have to
    tell me why。 Go for it why。 Right， but let's suppose that we could put any value
    of a semaphore in here we wanted。 Yes。 Yeah。 so the problem with this is we grab
    the lock semaphore and you do a weight。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这能工作吗？有多少人认为我们可以通过这种方式实现监视器条件变量？有多少人认为我们做不到？如果你举手了，你得告诉我为什么。来吧，为什么？对，但让我们假设我们可以在这里放入任何一个信号量的值。是的。嗯。问题在于我们获取了信号量锁并执行了等待。
- en: On a condition variable semaphore you're going to go to sleep with the lock。
    Oh。 everything's broken。 Okay， so this is a bad implementation right off the bat。
    because you can't sleep with this particular semaphore。 So that doesn't work。
    Okay。 Does this work better so wait releases the lock， then does the semaphore
    P on the condition variable。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个条件变量信号量上，你将带着锁去睡觉。哦，一切都坏了。好的，所以这一实现一开始就不行，因为你不能在这个特定的信号量上睡觉。所以这样不行。好吧，这样行吗？所以等待释放锁，然后在条件变量上执行信号量P。
- en: and then re acquires the lock before exiting wait。 And then the signal just
    does the semaphore V。 Okay， so this looks a little better because it doesn't lock
    up because of the because of holding the lock and going to sleep right because
    you see when you do wait you release the lock first。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在退出等待之前重新获取锁。信号只是执行信号量V。好了，这看起来稍微好一点，因为它不会因为持有锁而进入死锁状态，因为你看，当你执行等待时，你先释放了锁。
- en: Okay， but does this work。 Yes。 Great。 So this is still broken。 because remember
    that signal is not the same as some of the because if you signal first and then
    wait with this implementation。 they'll never wait。 Whereas condition variables
    you go to say wait you'll always wait。 Okay。 so this is broken。 Everybody see
    that。 Prom is semaphores or symmetrical condition variable signal is not。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但这有效吗？是的。太好了。那么，这仍然是错误的。因为记住，信号与某些操作不相同，因为如果你先发出信号然后再等待，使用这个实现，它们永远不会等待。而条件变量是，你去说等待时，你总是会等待。好吧。所以这是错误的。大家明白了吗？信号量是对称的，而条件变量信号则不是。
- en: Okay。 So what can we do。 Well， you know， and you can say here what if a thread
    signals and nobody's waiting to know up。 Right。 So what if a thread later weights，
    the thread weights。 Okay。 so if a thread signals in a forest and nobody's listening
    nobody listens， right。 Whereas if you do a V， and nobody's waiting。 You increment
    the semaphore and if the thread later does P you decrement and continue。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们能做什么呢？嗯，你知道，你可以在这里说，假设一个线程发出信号，而没有人等待，知道吗？对吧。那么，如果一个线程稍后等待，线程就会等待。好吧。那么如果一个线程在一个森林中发出信号，而没有人听，没人听，知道吗？而如果你做一个V操作，而没有人在等待，你会增加信号量，如果线程稍后执行P操作，你就会减少信号量并继续。
- en: And so this will not have the property that every time you fall wait， you will
    sleep。 Okay。 So everybody see the problem。 This looks broken。 Maybe we can't do
    it。 Well。 the problem with the previous try courses that P and V are commutative
    result is the same no matter what order they occur in condition variables aren't。
    So if you look， you could say， well， does this stick fix the problem， wait， releases
    the law。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这将没有这样的特性：每次你调用等待时，你都会休眠。好吧。大家看到这个问题了吗？这看起来是错误的。也许我们做不到。好吧。之前尝试的一个问题是，P和V是可交换的，不管它们按什么顺序执行，结果是一样的，而条件变量则不是。所以，如果你看看，你可以说，嗯，这个修复解决了问题，等待时释放了锁。
- en: does a semip and acquires and signal says if the semaphore queue is not empty，
    then you do a semiv。 Does this work。 It works， but it's illegal。 You're not allowed
    to read the value of a semaphore。 Okay。 So， there's a race condition here， signal
    or can slip in the wrong spot。 But it actually turns out it is possible。 And I'll
    give you a hint。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是否一个信号量P并获取锁，而信号量说如果信号量队列不为空，那么执行一个信号量V。这样行吗？它有效，但它是非法的。你不允许读取信号量的值。好吧。所以，这里有一个竞争条件，信号量操作可能会在错误的时机执行。但实际上，事实证明这是可能的。我会给你们一个提示。
- en: If we keep a condition variable integer of all our own that we use to increment
    before we release the lock。 then we can keep track of how many sleepers there
    are。 And the signal or can look at that because that's not illegal。 Since they
    have the lock。 Okay。 so here is an interesting example where having the lock around
    a single actually is it would be crucial to this particular implementation working。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持一个条件变量整数，所有我们用来在释放锁之前增加的那个变量，那么我们可以跟踪有多少个线程在休眠。信号量操作可以查看它，因为这是合法的。因为他们有锁。好吧。所以这里是一个有趣的例子，拥有锁在信号量操作周围实际上对于这个特定实现的工作至关重要。
- en: Okay， because if you didn't have the lock and you tried to do check a condition
    variable or check that integer variable。 And you don't have the lock， then somebody
    could change it out from under use that problem。 All right。 Not going to belabor
    the point。 So bottom line is can make monitors out of semaphores and you can imagine
    it's。 it's even easier to make semaphores out of monitors that's a an exercise
    for you guys。 Well。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为如果你没有锁，试图检查条件变量或检查那个整数变量，而你没有锁，那么有人可能会在你不知情的情况下改变它，这就是问题所在。好吧。我们不再详细讲这个问题了。那么，重点是，你可以用信号量做出监视器，而你可以想象，用监视器做出信号量更容易。这是一个你们可以做的练习。嗯。
- en: you're sitting there。 So。 Okay， going to close this out。 But。 So as we go forward。
    The assumption here is that you're going to get better and better at looking at
    synchronization situations and figuring them out。 You know it's one of these things
    where I can give you examples。 But it's going to be up to you to sort of retrain
    your brain into thinking about these。 All right。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你就坐在那里。那么，好吧，我将关闭这个话题。但是，随着我们前进，假设你们会越来越擅长于查看同步问题并解决它们。你知道，这就是其中之一，我可以给你们举例，但最终还是要靠你们自己去重新训练思维，去思考这些问题。好吧。
- en: But， you know， I think。 If worse comes to worse going to a monitor certainly
    ought to be the easiest thing to think about。 I haven't had an example in a research。
    Project I'm doing where I suggested that somebody is condition variable because
    they had to put the thread to sleep。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但你知道，我认为，如果最糟糕的情况发生，使用监视器应该是最容易想到的事情。我在我做的一个研究项目中曾建议过某人使用条件变量，因为他们需要让线程休眠。
- en: And wake it up later and it turned out that was absolutely the right thing to
    do。 Very simple。 And these， by the way， are available in a lot of situations。
    including in thread packages like Pete threads。 But I wanted to say a little bit
    about before we sort of close out synchronization entirely。 I wanted to say a
    little bit about。 Support for synchronization in languages。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后稍后唤醒它，结果证明这绝对是最正确的做法。非常简单。顺便说一下，这些在很多情况下都可以使用，包括像 P 线程这样的线程包。但在我们完全关闭同步之前，我想说一点关于语言同步支持的内容。
- en: So if you go to the thread， you'll see I should put a slide in here on that。
    There are P thread new Texas and there are P thread condition variables。 That
    are implemented。 So if you just do a man on the P thread packages， you'll see
    those。 So if you're working with P thread， you'll you'll absolutely be able to
    synchronize with monitors and semaphores。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你去查看线程，你会看到我应该在这里加入一张关于这个的幻灯片。这里有 P 线程新的 Texas，还有 P 线程条件变量。它们已经被实现了。所以如果你只需要做一下
    man 查阅 P 线程包，你会看到它们。只要你在使用 P 线程，你肯定能够与监视器和信号量同步。
- en: Those are available。 Okay。 So， see is a little bit of a crazy language， though。
    All right。 How many people think C is a crazy language。 Okay。 The worst part about
    C is it lets you do all sorts of bad things。 Okay， that you should never do。 All
    right。 And the worst thing you can do with C is you can have dangling memory pointers
    that you forget about or you free something twice or there's a lot of bad things
    there。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以使用的。好吧，C 是一种有点疯狂的语言。好吧，有多少人认为 C 是一种疯狂的语言？好的。C 最糟糕的地方就是它允许你做各种坏事。你永远不应该做的事情。最糟糕的是你可能会有悬空的内存指针，或者忘记了释放某个东西，或者释放了两次，这里有很多坏事。
- en: But that's not what we're going to talk about here。 Here。 if you have some code
    that acquires a lock and there's an exception inside of the code。 you need to
    check every exception path and release the lock before returning from that procedure。
    Because if you don't do that， we'll be leaving this here。 If you don't do that。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是我们今天要讨论的内容。如果你的代码获取了锁，并且在代码内部发生了异常，你需要检查每一个异常路径，并在从该过程返回之前释放锁。因为如果你不这么做，我们会把它留在那里。如果你不这么做。
- en: then you can either easily have an exception and return out of the code to the
    calling function and the lock is still kept and there's nobody to ever release
    it。 See that， because normal， normal code is you acquire you do some stuff you
    release。 But if there's an exception， you need to make sure to release the lock。
    Okay。 and this makes see really messy for locking。 You just got to do it。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以很容易地通过抛出异常返回调用函数，锁依然保持着，没有人会释放它。看到了吗？因为正常的代码是你获取锁，做一些操作，然后释放锁。但是如果发生了异常，你需要确保释放锁。好的。这使得
    C 在锁定方面真的很复杂。你必须做这些事。
- en: What even makes it more messy is the set jump jump long jump idea。 How many
    of you have run into set jump and long jump before anybody。 You're lucky。 Let
    me tell you what set jump and long jump are these are a poor man's version of
    exceptions。 which are here's a stack。 You start with procedure A and then you
    go to procedure B and you call something called set jump。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更加复杂的是 set jump 和 long jump 的概念。你们中有多少人遇到过 set jump 和 long jump？没有遇到过的真幸运。让我告诉你们，set
    jump 和 long jump 是异常的一种简陋版本。它们是这样的：有一个堆栈，你从程序 A 开始，然后到程序 B，接着调用一个叫做 set jump 的东西。
- en: which gives you a handle that'll let you throw out a bunch of the stack and
    return to the place where you called set jump。 So it's like an exception。 So here
    we are， we go to C， we acquire the lock， we go to D。 There's an error or something
    in E that calls long jump。 it'll throw all this stack out and go back up there
    without acquiring the lock。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你一个句柄，让你可以丢弃一大堆堆栈并返回到你调用 set jump 的地方。所以它就像一个异常。这里，我们进入 C，获取锁，进入 D。在 E 中出现错误或某些情况时调用
    long jump。它会丢弃所有的堆栈并返回上面，而不需要重新获取锁。
- en: or without releasing the lock。 And so， there we go。 Bad news。 Okay。 Now。 fortunately
    set jump and long jump are something you use a lot these days。 but I'm just warning
    you that and see this is just messy。 Okay。 And then maybe you could use go to。
    How many people have been told that never use go to。 Okay。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者没有释放锁。好了，坏消息。好的。现在，幸运的是，set jump 和 long jump 是你今天经常使用的东西。但我只是警告你，在 C 语言中，这只是乱七八糟。好的。然后也许你可以使用
    goto。多少人曾被告诫永远不要使用 goto？好的。
- en: under pain of losing your first born or something to to the sea troll。 I mean，
    this is， you know。 so this is not great。 When you get to anything more powerful
    than see though it turns out it's good。 For instance， in C you still got to make
    sure that if if food has an exception， it'll get thrown。 And you can catch it，
    which means that you want to do something like this at minimum where you say I'm
    going to try to do who if there's an exception I released a lot。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以失去你的大儿子或某些东西被海怪带走为代价。我是说，这就是，你知道的。所以这并不好。当你接触到比 C 语言更强大的东西时，结果发现它是好的。例如，在 C
    语言中，你仍然需要确保如果食物有异常，它会被抛出。而且你可以捕获它，这意味着你至少需要做类似这样的事情：你说我要尝试做，如果有异常，我会释放很多。
- en: Notice how that's looks like the C code， but this is a lot cleaner because all
    exceptions will come through that one path。 Okay。 Now， if you're a C plus plus
    person in the audience， you'll say， but wait a minute。 That's not a good way to
    do it。 There's an even better way。 Okay， and you guys。 I encourage you to Google
    lock guard。 Okay， so what this means is here we have a procedure。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意看，这看起来像是 C 代码，但它要干净得多，因为所有异常都会通过那一条路径。好的。现在，如果你是 C++ 背景的观众，你可能会说，但等等。这不是做这件事的好方法。还有更好的方法。好的，我鼓励你们谷歌一下锁守卫。好的，这意味着这里我们有一个过程。
- en: That's going to increment this global variable cleanly no matter who how many
    people try to do it。 And what happens here is when you allocate the lock。 So this
    is actually on this is a local variable。 Here you allocate a lock guard and it
    locks the global mutex。 And the point of this is it doesn't matter how safe increment
    exits under any circumstances whatsoever if safe increment exit that lock will
    get freed。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论有多少人尝试执行，它都会干净地增加这个全局变量。这里发生的事情是，当你分配锁时。其实这是一个局部变量。在这里，你分配了一个锁守卫，它锁定了全局互斥量。关键在于，无论安全增量退出的条件如何，这个锁都会在任何情况下释放。
- en: Okay， so if you're ever doing locking and C plus plus this or some of its variants
    are the cleanest。 Okay， because this particular type of thing this lock guard。
    Basically。 anytime it finally goes out of scope， it pulls the path that basically
    unlocks。 Okay。 Python。 Well。 you could allocate a lock and then you can say with
    lock to stop and what that means is no matter how that with statement exits。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以如果你在做锁定操作时，C++ 或它的一些变种是最干净的。好的，因为这种特定类型的锁守卫。基本上，每当它最终超出作用域时，它就会自动释放锁。好的。Python。嗯。你可以分配一个锁，然后你可以说用锁来停止，这意味着无论那个
    with 语句如何退出。
- en: The lock will be free。 That's almost identical to what I just showed you with
    C plus plus。 Java。 your favorite， right。 They， I don't know， they still do Java
    and 61 be good。 I haven't taught that in a while。 Actually， I haven't taught that
    when I。 I'm not sure if you're not going to get things about it， but if you look
    here。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 锁会被释放。这几乎与我刚才展示的 C++ 完全相同。Java。你最喜欢的，对吧？他们，我不知道，他们现在还在用 Java 和 61 好吗？我已经有一段时间没教这个了。实际上，我从没教过它。我不确定你是不是不了解它，但如果你看看这里。
- en: you can say public synchronized。 And what that means is that every object has
    an implicit monitor built in that includes a lock and a condition variable。 And
    so as a result， you can say this particular method get balanced。 You remember
    when we talked about the bank account is synchronized。 And this get balance will
    ever get run by a thread is if it first acquires the objects lock and then it'll
    go in there and let you go。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说 public synchronized。意思是每个对象都有一个内建的隐式监视器，包括一个锁和一个条件变量。因此，结果是，你可以说这个特定的方法
    get balanced。你还记得我们讨论过银行账户是同步的吗？而这个 get balance 只有在获取对象的锁之后才能被线程运行，然后它会进入并让你继续。
- en: Okay， so just by saying the word synchronize。 We use the law automatically。
    How's that for a lot simpler than the way we introduced this a few lectures ago。
    Okay。 and furthermore， Java has， like I said， a single condition variable。 You
    can write every object and so you can do weight。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，仅仅通过说出“同步”这个词。我们就可以自动使用这个法则。比起我们几节课前介绍的方式，这样是不是简化了很多？好的。此外，正如我之前所说，Java 只有一个条件变量。你可以为每个对象编写代码，所以你可以进行等待操作。
- en: and you can also do a weight that has a timeout。 And you can notify and notify
    all of those who are the full and await and broadcast or have signal and broadcast。
    I mean。 And so that's how you do it in Java。 So Java actually has monitors built
    into the language。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以进行带有超时的等待操作。而且你可以通知并通知所有等待的线程，或者进行广播、信号和广播。这就是你在 Java 中如何做的。所以 Java 实际上将监视器内建到了语言中。
- en: which is kind of cool。 Okay。 All right， I think we're gonna we're gonna let
    we're gonna let synchronization rest for a little bit unless people have some
    questions。 Go ahead。 Let's see。 Make sure there's nobody here。 Okay， anybody else
    have any questions。 Oh。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的挺酷的。好吧。好了，我想我们暂时可以放下同步这个话题，除非有人有问题。继续吧。让我看看。确保没有人遗漏。好的，还有其他问题吗？哦。
- en: in the back。 No， that was a stretch。 Okay。 So， I've been a strivia as easy today。
    Unlatt like last week where you had an exam and a design review。 and had to solve
    the halting problem standing on your head drinking coffee。 This is a relatively
    minor week。 And so I don't think there's any major deadlines。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 后面那位？不，那只是个伸展动作。好的。所以，今天的琐事比较轻松。不像上周那样，你们既有考试，又有设计审查，还得在喝咖啡时站着解决停机问题。这一周相对轻松一些。所以我觉得没有什么重大期限。
- en: although you got to keep moving on stuff。 I took a glance at the schedule。 And
    so。 I'm waiting the midterm。 I was told to say that there's anywhere between 80%
    and 85% done。 And of course I want to inform you that。 You know。 75% of all statistics
    are made up so you know you can use that as a。 However you want to。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你们得继续推进各项工作。我瞥了一眼时间表。关于期中考试的部分。我被告知说，大约完成了 80% 到 85%。当然，我还要提醒你们，75%的统计数据都是随便编出来的，你们可以自行决定如何看待这一点。
- en: I'm not sure if anybody has any administrative， it's trivia today。 So I figured
    we start a new topic if that's okay with y'all。 We can put our minds to rest about
    the midterm there's solutions that are posted。 There is a thread for asking questions
    about the solutions and I'm a little behind on answering some of them。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定今天大家是否有任何管理类的琐事。既然如此，如果大家没问题，我想我们可以开始一个新话题。我们可以把期中考试的事情放一放，答案已经发布了。关于答案的提问也有讨论区，虽然我还没能及时回答所有问题。
- en: but I will make sure they get answered。 Should we move forward。 Forward。 Alright，
    so I want to say。 here's a picture。 I think I even had this picture in the slides
    for the first day。 which is this this loop of what what it is in operating system
    does it sort of says if there's a ready thread。 If there are any ready threads
    you pick one of them， and you run it。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我会确保问题得到解答。我们继续往下走吧。往前走。好了，接下来我想说的是，这里有一张图。我记得这张图第一次课上就展示过，它是关于操作系统的一种循环。图中提到，如果有就绪线程，系统就会从中选择一个执行。
- en: And otherwise you run an idle thread and periodically you loop。 Okay， that's。
    I think the way I said well this is the whole operating system we're done let's
    do our final right。 What we want to do today is we want to start discussing scheduling
    which is really what is the select red thing。 There's another picture I showed
    you here about， you know， scheduling。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你就会运行一个空闲线程，并定期执行循环。好吧，我想我说得对，这就是整个操作系统的工作。我们可以结束今天的内容，准备做我们的最终总结。今天我们想要做的，是开始讨论调度，实际上就是“选择什么”的问题。我曾经给你们展示过另一个关于调度的图。
- en: which says there's a ready queue， which is a set of all threads that the CPU
    is ready to run。 And really the question is how is the OS to decide which thing
    on the ready queue is going to be the one that goes next。 Okay， and so scheduling
    is really deciding which threads to give access to resources for moment to moment。
    And by the way， for the next several lectures， we'll talk about giving access
    to CPU time。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图显示了一个就绪队列，它是所有准备好由 CPU 执行的线程集合。真正的问题是，操作系统如何决定就绪队列中的哪个线程将会是下一个执行的线程？好的，所以调度其实就是决定哪些线程在每一时刻可以访问资源。顺便提一下，在接下来的几节课中，我们将讨论如何分配
    CPU 时间。
- en: but scheduling is so much more。 Okay， we， you can talk about scheduling this
    bandwidth。 you can talk about scheduling， I/O resources can talk about scheduling
    memory。 There's lots of things you can schedule， but we're going to just schedule
    the CPU for the moment。 because we're really trying to figure out what happens，
    between the ready queue and the CPU。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是调度远不止这些。好吧，我们可以讨论带宽调度。你可以谈论I/O资源调度，可以谈论内存调度。你可以调度很多东西，但目前我们将只调度CPU。因为我们实际上是在试图弄清楚发生了什么，介于就绪队列和CPU之间。
- en: All right， that's our goal for the next couple of lectures。 And I'm happy to
    admit， by the way。 that Anthony is actually back so he may actually get to do
    a couple of these lectures too so we'll get to see somebody else but for today。
    other than me， but for the day。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是接下来几节课的目标。顺便说一下，我很高兴地承认，Anthony实际上回来了，所以他也许会参与几节课的讲解，我们也可以看到其他人的风格，但今天除了我之外，只有我一个人。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_9.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_9.png)'
- en: Scheduling is all about cues。 Okay， and cues I'm sure are your favorite things。
    Okay。 this is clearly from the before times because they're not all wearing masks。
    and they're not six feet apart。 Yes， soon maybe okay。 What are some assumptions
    about scheduling okay the first assumption is some of the assumptions really came
    up from the 70s so scheduling really became a big deal in the 70s。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调度完全是关于提示信号的。好吧，我敢肯定，提示信号是你最喜欢的东西。好吧。这显然是从之前的时代，因为他们并没有戴口罩，而且他们之间也没有保持六英尺的距离。是的，可能很快会有这样的规定。关于调度的一些假设，首先，一些假设实际上来自70年代，调度在70年代成为了一个重要的议题。
- en: And it was a big area of research。 Notice that we only have three lectures on
    it。 but it was a really a major area of research。 And many of the implicit assumptions
    for CPU scheduling actually came from back then。 And they are sort of like well
    there's one program per user。 One thread per program programs are independent。
    Okay， so that's a little bit。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的研究领域。请注意，我们只有三节课讲它，但它确实是一个重要的研究领域。很多关于CPU调度的隐性假设实际上都来源于那个时期。而这些假设类似于：每个用户只有一个程序，每个程序只有一个线程，程序是独立的。好吧，这些是一些基本假设。
- en: You know that's a very old school way of thinking of things is also kind of
    what happens when you have a bunch of different users sharing the same machine
    so it's kind of the main frame look at things。 Okay， but a lot of the work that
    was done in the 70s is still happily used today。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，这是一个非常老派的思维方式，也算是一种当多个用户共享同一台机器时的情况，所以它是一种大型机的视角。好吧，但70年代做的许多工作至今仍然被愉快地使用。
- en: Clearly these particular ideas here are unrealistic but they do simplify the
    problem in a way that can be solved。 So the for the very first lecture here we're
    going to kind of start with this idea in our background to one program per user
    one program program through independent。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些具体的想法是不现实的，但它们确实简化了问题，以一种可以解决的方式来处理。所以在第一次讲座中，我们将从这种背景开始：每个用户一个程序，每个程序线程独立。
- en: And then we're going to slowly add in more complexity to our processes as we
    go forward to get more interesting scheduling。 Okay。 And so the high level goal
    just to remind you here。 this is you know our favorite diagram again from the
    first day of the printer inverse colors magenta cyan and yellow。 Those represent
    different threads we're going to all decide to how to schedule those on a CPU
    one CPU。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将逐步为我们的过程增加更多的复杂性，以便使调度变得更加有趣。好吧。高层次的目标，提醒一下，这就是我们最喜欢的图表，再次来自第一天的打印机逆色：品红色、青色和黄色。这些代表着不同的线程，我们将决定如何在一个CPU上调度它们。
- en: And notice how now they're all have different amounts of CPU time because they're
    longer shorter whatever。 How does the scheduler decide。 Okay。 All right， so far
    so easy questions。 Yes。 Ah， what is a user。 So the user。 Is an instance of a principle
    or somebody who has。 Resource is allocated to them the simplest thing you could
    think of as a login right you log in your user。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在它们的CPU时间各不相同，因为程序执行的时间长短不同。调度程序如何决定呢？好吧，到目前为止，问题还很简单。是的，嗯，什么是用户？用户是一个实体或一个拥有资源分配的人，最简单的想法就是登录，你登录了，就成了用户。
- en: The CPU treats you as with your with your user ID。 But as we get a little bit
    further in the term。 it can be more more general than that it can be like I said
    if you have a public private key pair it could be a principle in this in the security
    sense but for now think of a login ID for now。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CPU通过用户ID来处理你。但随着学期的推进，实际上可以更一般化。比如说，如果你有一个公私钥对，在安全的意义上，它也可以是一个“主体”，但是现在就当作登录ID来理解吧。
- en: Okay。 Another question here is process scheduling more of an implicit thing
    by the scheduler like the scheduler who has switched threads and those might be
    in different processes。 So up to for now we're not actually going to talk about。
    Or limit ourselves to worrying about which threads are in which processes。 Okay。
    we got a bunch of threads they all need CPU time。 And in answer to this question。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里还有一个问题，进程调度是不是更多的是调度器的隐式操作呢？比如调度器切换线程，而这些线程可能属于不同的进程。所以暂时我们不会讨论，或者限制自己去担心哪个线程属于哪个进程。好的，我们有很多线程，它们都需要CPU时间。那么对于这个问题的回答是……
- en: you could imagine for instance that you might work your way through all the
    threads in a process and then switch to another process。 You could imagine。 I
    can imagine almost anything right。 A large。 for a Latino or something right you
    can imagine almost anything。 But what's interesting there since it was brought
    up is if you've got processes with 100 threads and another process with one thread。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 比如你可以想象，可能会处理完一个进程中的所有线程后，再切换到另一个进程。你可以想象，几乎可以想象任何场景，对吧？例如，大规模的拉丁语程序之类的，你几乎可以想象任何事情。但有趣的是，既然已经提到这个问题，如果有一个进程有100个线程，另一个进程有一个线程。
- en: What's fair。 Is it fair to give equal time to 100 threads in process A and one
    threaded process B so that they're really are 101 threads and each of them get
    one over 101 of the time。 Or， what it makes sense to give half of the time to
    process A and have to be and then process A divides all their time up to their
    100 threads。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是公平呢？将相同的时间分配给进程A中的100个线程和进程B中的一个线程，是否公平？也就是说，它们总共有101个线程，每个线程得到1/101的时间。或者，是否更合理地将一半的时间分配给进程A，另一半分配给进程B，然后进程A将其所有的时间分配给它的100个线程呢？
- en: Okay， so what is fair。 That's going to be a problem here that we have to solve。
    Okay。 So one assumption that was in a lot of these earlier scheduling papers and
    is a good one is basically this idea of CPU bursts。 where if we look at how long
    does a thread run。 Oh yeah， go ahead。 Is program the same as process。 Well， I'm
    going to say yes for now。 Imagine you know about for right so program could have
    a bunch of processes and then in that case program and process are not quite the
    same thing but we can only so throw so much complexity in one day so let's stick
    with one process per program just for now。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么什么是公平呢？这将是我们必须解决的问题。好的。那么，很多早期调度论文中的一个假设是非常好的，基本上就是这个“CPU突发”概念。如果我们看一个线程运行的时间。哦，是的，请继续。程序和进程是一样的吗？嗯，我现在先说是吧。想象一下，你知道程序是可以有多个进程的，在这种情况下，程序和进程不完全是同一回事，但我们今天只能处理这么多复杂性，所以暂时就按每个程序对应一个进程来理解吧。
- en: But if you notice， when you have a thread and it's circling between the CPU
    and the various weight cues。 You could say how long does it run on the CPU before
    it's put the sleep。 So if you have a timer going off and it computes forever。
    Then what you'll see is you'll just see threads maybe cycling between CPU and
    weight cue。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你注意到，当一个线程在CPU和各种等待队列之间循环时，你可以问它在CPU上运行多久才会被休眠。所以，如果你有一个定时器，而线程永远计算下去，那么你会看到线程可能会在CPU和等待队列之间循环。
- en: And they all have exactly the same amount of time they get to compute before
    they go to sleep。 And so， we actually put IO into the picture， then you can imagine
    that some number of those threads are waiting are only woken up because of a key
    stroke on a keyboard and they run for a little brief free to time and then they
    go back to sleep on a way to associate with the keyboard。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有相同的计算时间，直到进入休眠状态。所以，如果我们把I/O加到画面中，你可以想象一些线程是等待的，只有在键盘上按下一个键时才会被唤醒，它们运行一段短暂的时间后，然后再次进入休眠，等待与键盘相关的事件。
- en: Okay， so there's a lot of reasons that threads could go to sleep and so if we
    were to measure this called the CPU burst time which is kind of how long does
    a thread run before it goes back to sleep again。 So， something like this peak
    here， where there's a lot of really short bursts and some and a very long tail
    tail of long ones。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有很多原因导致线程进入休眠。所以，如果我们测量这个叫做CPU突发时间，就是线程运行多久后再回去休眠。所以，类似这样一个峰值，在低端有很多非常短的突发，且尾部有一个非常长的尾巴。
- en: Okay。 And so programs or whatever they are threads we're not going to get too
    tight up at all of this yet。 So， there's threads run for a period period of time
    called a burst and then they go back to sleep。 And if we were to measure this
    think of this as a probability distribution of bursts of threads you see this
    peak at the low end。 Can anybody give me an idea where that peak at the low end
    might come from。 Okay。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。于是程序或者不管它们是什么，线程我们暂时不会深入探讨。然后，线程会运行一段时间，称为一个突发，然后它们回去休息。如果我们测量这个，可以把它看作是线程突发时间的概率分布，你会看到低端有一个峰值。有人能给我一个想法，低端的那个峰值可能来自哪里吗？好吧。
- en: the duration of a timer interrupt。 No， let me explain why I don't think that's
    what you're looking for。 So if everybody was bounded by a timer interrupt。 Then
    there would be a like a delta function at one time right because the。 you know
    you'd run for 10 milliseconds a timer go off the next guy run for 10 milliseconds。
    But we have this distribution that's not like that right it's got some peaks at
    the low end and a very long tail。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器中断的持续时间。嗯，让我解释一下为什么我认为这不是你所寻找的东西。所以，如果每个人都被定时器中断所限制。那么会有一个类似于脉冲函数的时刻，因为你知道你会运行10毫秒，然后定时器响起，下一个人会运行10毫秒。但我们有这种分布，不是那样的，它在低端有一些峰值，且有一个非常长的尾巴。
- en: And because there's things with the long tail， you have to suspect that if the
    timer ever gets involved。 It's interrupting folks way down here。 Right， because
    they're running for a long time and then they get interrupted。 So why do we think
    there's a burst down here。 Yeah。 Starting up the process。 All right， maybe。 Yeah。
    go ahead。 Okay， I owe you're getting。 Yep， that's pretty good。 Getting closer。
    What about I owe。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有长尾的东西，你必须怀疑，如果定时器介入了，它是在打断那些很长时间运行的人。对吧？因为他们运行了很长时间，然后才被中断。那么，为什么我们认为这里有一个突发？是的，启动进程。好吧，可能是。是的，继续。好吧，我欠你一些解释。嗯，是的，差不多了。接近了。那我欠你什么呢？
- en: Yes。 Okay， maybe it's disk access time， although actually that's going to be
    way the heck out here in a place you can't see on the screen because remember
    million cycles。 What type of I oh yeah。 Okay。 So， yes， you have to load the program
    so I'm going to give you a guess here so somebody says actively computing and
    then waiting for I owe yes。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。好吧，也许是磁盘访问时间，虽然实际上那会在这里屏幕上看不见的地方，因为记住是百万次周期。那么，什么类型的I/O呢？好吧。所以，是的，你必须加载程序。所以我给你一个猜测，有人说是主动计算然后等待I/O，是的。
- en: Point number one。 Why short interactive processing right because you。 you're
    waiting and you get a key stroke and you process that the letter a。 and then you
    go back to sleep and then they type a B and you process the letter B and go back
    to sleep。 So things at the low end here tend to be interactive。 Okay。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点。为什么是短暂的交互式处理？因为你在等待并且接收到一个按键输入，然后你处理字母a。接着你又回去休息，然后他们输入字母B，你处理字母B，然后又回去休息。所以这里低端的事情通常是交互式的。明白吗？
- en: there are situations where the program threads are running on behalf of a user
    and making the user happy by quickly processing some event from the user and then
    going back to sleep。 Okay， and now if we start including other things like I owe
    of other sorts。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况，程序线程是代表用户运行的，通过快速处理来自用户的某些事件，让用户感到满意，然后再回去休息。好吧，现在如果我们开始考虑其他类型的I/O。
- en: And we look at this much longer realm， but I think the important part here is
    if you look at the set of threads out there。 There's a lot of really short bursts
    and that's because in even back then you have these machines are processing user
    interactive。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看一下这个更长的范围，但我认为这里重要的部分是，如果你看一下外面的一组线程。会发现有很多非常短的突发，这是因为即使在那时，这些机器也是在处理用户的交互。
- en: I owe。 Okay。 And so every scheduling decision。 Kind of is about if you've got
    a whole bunch of threads。 how do you pick the next one。 This shows you if you
    have a bunch of threads and you run them。 What did they behave yet the scheduling
    decision is before we run it。 How do we decide which are the ones to get。 Okay。
    And what。 You know。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我明白了。好的。所以每一个调度决策，其实都是关于在你有一堆线程的情况下，如何选择下一个要执行的线程。这就展示了如果你有很多线程并且运行它们，它们会怎样表现，然而调度决策是在我们执行之前做出的。我们如何决定哪些线程应该被执行呢？好的，怎么做呢？
- en: and with time slicing in the timer you probably could be forced to give up the
    CPU if you're computing pie or something but why can somebody tell me why just
    processing the threads in BIFO order might not be the best for users。 Yeah， so
    users have some interactivity they want to have happen。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间片轮转和定时器的配合下，你可能会被迫放弃CPU资源，假设你在计算圆周率之类的东西。但为什么有人能告诉我，仅仅按先入先出（FIFO）顺序处理线程，可能不是最符合用户需求的方式呢？对，用户有他们希望得到交互的需求。
- en: And if you're busy computing the next million digits of pie。 Maybe you don't
    care。 Right。 So it might make sense to give priority to the short burst over the
    long ones right and that's for interactivity。 So scheduling here you can see starts
    to come into play with how do we make sure that the scheduler makes users happy。
    So that's going to be important to us。 So what are some goals that we might have
    for the scheduling policy。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正忙着计算圆周率的下一个百万位数字，或许你并不在意。对吧？所以可能优先处理短时间的任务比长时间的任务更合理，这对于交互性来说非常重要。所以调度在这里开始发挥作用，如何确保调度程序能让用户满意，这对我们来说非常重要。那么，我们可能会对调度策略有什么样的目标呢？
- en: So one might be we want to minimize the response time。 So this is minimize the
    elapsed time to do some operation。 So it might be the time to echo a keystroke
    on in an editor or the time to compile a program。 or maybe with real time tasks
    which are going to be more topic for next time。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个目标可能是我们希望最小化响应时间。也就是说，最小化执行某个操作的经过时间。比如，在编辑器中回显按键的时间，或编译程序的时间，或者是实时任务，这将是下次讲座的更多话题。
- en: We might want to meet the goals imposed by the world。 Yeah， it is interesting。
    It hasn't escaped my notice that there's a lot of Tesla model wise floating around
    these days you guys see them they're like every other car on the road practically。
    But here's a situation where you have cars that are driven by computers。 And you
    can imagine certain things really have to happen quickly like breaking。 Okay。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要满足外部世界的目标。对，挺有趣的。我注意到，最近特斯拉的Model Y车好像随处可见，几乎每条路上都有。你们看到过吗？这是一种由计算机驱动的汽车。你可以想象，在某些情况下，确实必须快速做出反应，比如刹车。好的。
- en: so if we go back to this， and we're talking about， you know。 what to prioritize
    it might be in a real time sense we better prioritize stopping over missing the
    video that you're not supposed to be watching。 Right。 So real time tasks scheduling
    starts to get very interesting。 Okay。 and we're going to have to have whole lectures
    on that include real time in it。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们回到这个问题，谈论的是，知道优先级应该放在哪里，在实时任务的场景下，我们可能会更倾向于优先停止任务，而不是错过你不应该观看的视频。对吧？所以实时任务调度开始变得非常有趣。好的，我们可能会有专门的讲座来讨论实时任务调度。
- en: So another is maximizing throughput。 So these， you know。 things have gotten
    a lot cheaper over the years， but it's still important to maximize the best use
    of your CPU。 And so maximizing throughput could be important and maximizing throughput
    and minimizing response time are not necessarily compatible with each other。 Okay，
    because minimizing response time might mean as soon as a user's responsive thread
    needs to run。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一个目标是最大化吞吐量。这些年，硬件变得越来越便宜，但仍然重要的是最大化CPU的使用效率。因此，最大化吞吐量可能很重要，而最大化吞吐量和最小化响应时间并不一定是相互兼容的。好的，因为最小化响应时间可能意味着一旦用户的响应线程需要运行，就会立刻执行。
- en: go ahead and interrupt the current one and run。 That gives you response time
    minimizing response time。 but maximizing throughput might be never interrupt a
    computing thread so that it's cash state and all that other stuff gets to be undisturbed
    and the thing can run at maximum speed。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行并中断当前任务然后运行。这可以减少响应时间，最小化响应时间。但最大化吞吐量可能意味着永不中断计算线程，以保证它的缓存状态以及其他所有东西不被干扰，从而使得任务能够以最大速度运行。
- en: Right， so minimizing response time maximizing throughput， not quite the same
    thing。 All right。 And then of course there's this fairness thing which is you
    should sharing a CPU among users or among different aspects of the system。 So
    in this case， like in a Tesla users could reflect breaks video playback， you know。
    whatever you could， you could divide all these things up。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对，所以最小化响应时间和最大化吞吐量并不完全是同一回事。好的，然后当然还有公平性的问题，你应该在不同用户之间，或者系统的不同部分之间共享 CPU。所以在这种情况下，比如在特斯拉中，用户可能会影响视频播放的优先级，或者其他任何事情，你可以把这些都进行分配。
- en: Those are all different users and we need to have different priorities among
    them。 Okay。 and so that that little conundrum I gave you earlier about what it
    means to be fair to the threads in a process with 100 threads is a little bit
    tricky because you could do fairness by thread or fairness by process or fairness
    by who knows what else。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是不同的用户，我们需要在它们之间设定不同的优先级。好的。所以，之前我给你提到的那个关于在一个拥有 100 个线程的进程中，如何公平地分配线程的问题其实有些棘手，因为你可以按线程公平、按进程公平，或者按其他一些标准来分配公平。
- en: Okay。 Good。 I don't want to belabor this point， but any other questions on this
    so far。 So now you can start to see why scheduling is not just yeah a couple of
    slides were done。 Right。 because you know you have to decide what's the policy
    you want。 and then you have to decide how do you build a good scheduler the kids
    you have policy。 So。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，明白了。我不想过多强调这一点，但到目前为止有其他问题吗？所以现在你可以开始理解为什么调度不仅仅是“对，几个幻灯片就完成了”，对吧？因为你知道，你必须决定你想要的策略是什么，然后你还要决定如何构建一个好的调度器以匹配你的策略。所以。
- en: the first type of scheduling is easy and let's talk about this first come for
    serve or FIFO。 So the idea there is basically a thread goes on one cue。 and it
    runs until it's done and then you pull the next one and then you pull the next
    one and then you pull the next one。 right。 And so， there you go。 There's a， there's
    a FCFS or FIFO Q。 And in early systems。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种调度方式很简单，让我们先谈谈先到先服务（FIFO）。基本的思路是一个线程进入队列，直到执行完毕，然后再取下一个，依此类推。对吧？所以，这就是 FCFS
    或 FIFO 队列。在早期的系统中。
- en: this was basically meant that one program runs until it's done， including IEL。
    So you'd have these huge machines they'd fill a room。 You would submit your job
    to run overnight。 and they would run them one at a time。 They'd run the first
    job， then they run the second job。 then they run the third job。 And they would
    do that to really maximize usage of the hardware to make it work as good as well
    as possible。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着一个程序运行直到完成，包括 I/O 操作。所以你会有这些庞大的机器，它们占满了一个房间。你会提交你的任务，让它运行一整晚。然后它们会一个一个地执行这些任务。先运行第一个任务，然后运行第二个任务，再运行第三个任务。它们这样做是为了最大化硬件的使用率，尽可能高效地运作。
- en: Okay。 Now， we can think of a modern update to first come for service you run
    until your first runs out。 and then you go to the end of the queue。 Okay。 So this
    is that there's no timer interrupt here。 This is just run into a bunch of bursts
    until you do something that requires either IO or you're actually done。 Okay。
    And so we could do this with a Gantt chart like this so suppose the processes
    arrive in order process one。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，我们可以考虑一种现代化的更新方式，就是先到先服务，直到你第一个运行的任务结束。然后你排到队伍的末尾。好的。所以这里没有定时器中断，这只是一直运行，直到你做一些需要
    I/O 或者你真的完成的事情。好的，我们可以用一个甘特图来表示，假设进程按顺序到达，进程 1。
- en: two， three， and suppose the process one。 As a first time of 24 process two as
    a first time of three process three as a first time of three。 Then， if I， if they
    arrive in that order and I process them first come first serve what does that
    mean it means I serve process one and then process two and then process three。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设进程一的执行时间为 24，进程二的执行时间为 3，进程三的执行时间为 3。如果我按先到先服务的顺序处理这些进程，这意味着我会先处理进程一，然后是进程二，再然后是进程三。
- en: And so if you look at that， that means if I have one CPU process one runs for
    24 time units then process two runs for the next three and process three runs
    for the next three。 And we can start computing metrics like what's the waiting
    time for process one zero because it doesn't have to wait。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你看看这个情况，这意味着如果我有一个 CPU，进程一会运行 24 个时间单位，然后进程二会运行接下来的 3 个时间单位，接着进程三会运行接下来的
    3 个时间单位。我们可以开始计算一些指标，比如进程一的等待时间是零，因为它不需要等待。
- en: What's the waiting time for process to 24 because it's got to wait for process
    one to finish。 Okay。 everybody with me on this。 Okay， and then we can come up
    with what's the average wait time。 So zero plus 24 plus 27 over three average
    wait time is 17。 and then average completion time so wait time until you get to
    start completion time is until you're done。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进程 2 的等待时间是多少？是 24，因为它必须等进程 1 完成。好的，大家跟得上吗？然后我们可以算出平均等待时间。所以 0 加 24 加 27 除以
    3，平均等待时间是 17。然后是平均完成时间，即等待时间直到开始，完成时间是直到完成。
- en: And so we can compete those two metrics。 Okay， now this is not terribly profound
    or hopefully not too difficult either unless you can't add and divide which of
    course that's always a problem we'll have right。 You can imagine that this average
    waiting time and the average completion time reflects something about goodness
    of the scheduler。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以计算这两个指标。好的，现在这并不是特别深奥，或者希望也不太难，除非你不会加法和除法，当然了，那总是个问题。你可以想象，平均等待时间和平均完成时间反映了调度器的优劣。
- en: especially since the average waiting time if you've got a bunch of interactive
    threads that are waiting to run。 You probably want to keep the waiting time as
    low as possible to keep your users happy。 Right。 so this is a metric that maybe
    we need to optimize。 And actually if you look at this。 but it's really unfortunate
    about this is only because process one arrived first through process two and three
    after wait so long。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是如果你有一堆交互线程在等待运行，你可能希望尽量降低等待时间，以保持用户的满意度。对吧？所以这是一个可能需要优化的指标。事实上，如果你看这个图，会发现不幸的是，这只是因为进程
    1 先到，而进程 2 和 3 在后面等待了这么久。
- en: So this particular scheduler is really sensitive to what order things arrived
    in， you know。 and that's， that's probably not a good thing。 Right。 And so we actually
    have here what's called the convoy effect。 which is short processes get stuck
    behind long processes。 Right。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个特定的调度器对任务到达的顺序非常敏感，你知道吗？而且，这，可能并不是一个好事。对吧？因此，我们实际上这里有一个叫做“车队效应”的问题。也就是说，短小的进程被长时间的进程卡住了。对吧？
- en: this is also known as the five items or less problem。 And safely right do you
    think you're going into the five items or less line except that the person with
    their one item is a is a cart full of 12。000 items right and so they never worked
    like there should。 Okay。 so if you look at this convoy effect we could graph this
    out。 So， we have sort of scheduled task。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为“少于五项”问题。安全检查，你觉得你在走“少于五项”的队伍，但那个只有一项的人的购物车里却有 12000 项东西，对吧？所以它永远都不会像应该那样工作。好的，如果你看这个车队效应，我们可以将其绘制成图。所以，我们有一个调度任务。
- en: Here we have the green one arrives dark green arrives blue was already ready
    running。 Now green gets the run， you see this so this is the actual scheduled
    task， these are the cues。 And so， we basically we had blue running green and dark
    green showed up there run to completion then red shows up。 etc。 And we can start
    tracing through this but suppose that red that showed up is going to take。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，绿色到达，深绿色到达，蓝色已经准备好并在运行。现在绿色开始运行，你看到了吗？这就是实际调度的任务，这些是队列。然后，基本上我们先让蓝色运行，绿色和深绿色接着到达并运行直至完成，然后红色到达，依此类推。我们可以开始追踪这个过程，但是假设那个到达的红色进程需要一些时间。
- en: a long time。 Notice how we take red off the queue and started running so light
    blue is the head of the queue and green shows up and purple shows up and some
    other color of green forest green shows up and then blue。 And notice how all of
    these threads showed up in our building up in our queue。 Well， red is running。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 很长时间。注意，我们把红色从队列中取出并开始运行，所以浅蓝色是队列的头，绿色到达，紫色到达，还有其他绿色，森林绿色到达，然后是蓝色。注意到这些线程都进入了我们的队列，而红色正在运行。
- en: Okay， so that's the convoy effect because they're all stuck in a convoy behind
    red。 Again。 hopefully that's just a graphic。 Example of why maybe first come for
    search that's terribly great for us。 Okay。 So here's a and here's the other thing
    to see right if they happen to show up in the other order like P two P three and
    then P one。 Then we could compute stuff and notice that our average waiting time
    now is three instead of 17 and our average completion times 13 instead of 27。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是车队效应，因为它们都被卡在了红色进程后面。再说一遍，希望这只是一个图示，展示为什么可能“先来先服务”并不适合我们。好的。所以这里有一个，另一件需要注意的事情是，如果它们恰好以不同的顺序到达，比如
    P2、P3 然后是 P1。那么我们可以计算一下，注意到我们的平均等待时间现在是 3，而不是 17，平均完成时间是 13，而不是 27。
- en: So just by reordering， we've got really happy users now are much happier users。
    Okay， so。 so the pros and cons of this fight for first come for serve is plus
    simple。 Minus short jobs stuck behind the long one。 And that's the safe way example。
    I guess the positive is your stuck in line to get to read about space aliens。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通过重新排序，我们现在有了非常高兴的用户，他们变得更加满意了。好的，那么，这种“先到先得”的利弊是什么呢？优点是简单。缺点是短任务可能被长任务卡住。这是安全示例。我猜优点是你在排队时能了解一些关于外星人的知识。
- en: while you're waiting to check out counter I guess there's something but。 All
    right。 So。 the question here also is first defined as a period of time with lots
    of computation activity no burst is the time。 Of from when you start running to
    when you stop running and then we graph that earlier。 Okay。 Now。 let's do something
    different。 Okay， go ahead question。 Ah。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在等待结账时，我猜应该有其他的东西吧。好的。那么，问题在于，“Burst”定义为一段时间内有大量计算活动的时间，不是“Burst”的时间是从你开始运行到停止运行的时间，然后我们之前做过那个图。好的。那么，现在我们做些不一样的事情。好的，继续提问吧。啊。
- en: so for now let's assume the scheduler is infinitely fast。 So it doesn't have
    to run very long all that has to happen is when P two finishes at that little
    sliver of time we asked the scheduler who's next。 And the scheduler says P three。
    And if you think about a FIFO queue。 there's not a lot of computing cycles involved
    in a FIFO queue。 Right。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们假设调度器是无限快的。它不需要运行很长时间，发生的事情就是当P2完成时，在那一小段时间里我们问调度器“谁在接下来？”调度器说“P3”。如果你想一想FIFO队列，在FIFO队列里不会涉及太多的计算周期。对吧？
- en: Now as I mean you just pull the thing off the head of the queue。 Now as we get
    more interesting。 Our structures are going to get more interesting and you guys
    are going to have to remember your 61 B so like we could have a heap structure
    or something like that where we're trying to pull the shortest predicted burst
    time off the queue but we're not there yet。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的意思是你只是把任务从队列的头部取出来。现在，随着我们深入，结构会变得更加有趣，你们得记住你们的61 B（课程）。所以我们可以有堆结构或者类似的东西，在那里我们试图把预测的最短执行时间的任务从队列中取出来，但我们还没有到达那个阶段。
- en: So for now let's just assume the scheduler runs in that infinitely small period
    of time from when we ask it to get something back。 Okay， yeah question。 So for
    now， remember that all of the mechanism mechanism for putting threads to sleep
    and waking them up all that's in the kernel。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们假设调度器在我们请求它取回任务的那个无限小的时间段内运行。好的，是的，问题。现在，记住所有关于将线程放入休眠和唤醒它们的机制，所有这些都在内核中。
- en: And that when you go to put a thread to sleep you ask the scheduler will still
    in the kernel to give me the next thread so all the way cues all that stuff is
    in the kernel for now。 Okay。 We'll get more interesting at other times but for
    now everything's in the kernel still。 Okay。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 而当你让一个线程进入休眠时，你会请求调度器（仍然在内核中）给我下一个线程，所以所有的队列操作这些东西现在都在内核中。好的，其他时候会更有趣，但现在一切都还在内核里。好的。
- en: so this， this doesn't seem great。 Okay， so first come first service basically
    not done in interactive systems at all。 Okay， so what else could we do。 We could
    do something called round Robin。 So this。 so the problem with the first come first
    serve scheme is it's potentially bad for short jobs。 Depends crucially on the
    submit order。 Okay， if you're first in line the supermarket with milk you don't
    care who's behind you but on the other hand if you're behind somebody you do care
    who's behind you're in front of right。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个，这个看起来不太好。好的，首先“先到先得”这种方式在交互式系统中基本上是不可行的。好的，那我们还能做什么呢？我们可以采用一种叫做“轮询法”（Round
    Robin）的方法。那么，先到先得方案的问题在于，它可能对短任务不友好。它严重依赖于提交顺序。好的，如果你是排队拿牛奶的超市里第一个，你不在乎你后面是谁，但另一方面，如果你在某人后面，你会关心你在谁前面，对吧？
- en: or who's in front of you so the round Robin scheme。 Is what we call preemption。
    Okay。 Sorry about the robin there but I was， I got a little carried away with
    clip art at one time so this Robin I。 I'm not subjecting you to this Robin spinning
    around here so we're good。 All right。 The round Robin scheme often called preemption
    is very simple。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你在乎谁在你前面，所以轮询法方案就是我们所说的“抢占”（Preemption）。抱歉，我刚刚提到的“Robin”是因为当时我玩得太开心，做了这个插图，所以这个
    Robin 我……我并没有让你们被这个 Robin 转来转去，我们没事了。好了，轮询法方案，通常称为抢占，非常简单。
- en: and we've been talking about this since day one， but you didn't realize it。
    It is， you run a thread。 a timer goes off you take the thread off the CPU you
    put it at the end of the queue and you take the next one and you run it。 Okay，
    that's called round Robin believe it or not and it's because all of the threads
    are going around between the ready queue and the CPU。 Okay， and after the quantum
    expires whatever that is well I say here between 10 and 100 milliseconds that's
    a pretty standard number for a modern Linux kernel is 10 or 100 milliseconds。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一天开始就一直在讨论这个，但你们没有意识到。这是因为你运行一个线程，一个定时器响了，你将线程从CPU上取下，然后把它放到队列末尾，再取出下一个线程并运行。好了，这叫做轮转调度，相信与否，这是因为所有线程都在就绪队列和CPU之间轮流执行。好吧，当时间片到期时，不管它是多长，我这里说的是10到100毫秒，这是现代Linux内核的标准时间，通常是10毫秒或100毫秒。
- en: And after the quantum expires the process is preempted and we had the current
    thing to the end of the queue and we grabbed the one at the head。 So for instance
    if they're in processes and already Q and the time quantum is Q。 Every process
    gets one over end of the CPU time just because it gets one end。 And in chunks
    of it most queue time units。 And so if you think about it no process ever has
    to wait more than n minus one times queue time。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当时间片到期时，进程会被抢占，我们将当前进程放到队列末尾，并取出队列头部的进程。例如，如果它们在进程中并且时间片为Q，那么每个进程都会占用一次CPU时间，因为它获得了一个时间片，并且以队列时间单位的块形式分配。所以，如果你仔细想想，没有任何进程需要等待超过n-1次队列时间。
- en: And why is that well it's just you have to wait for the folks in front of you
    and then you get to go。 And so we can tune Q down if we wanted to to make things
    more responsive to make sure that if somebody were an interactive thread they
    could run quicker。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？因为你必须等前面的进程完成，然后才能运行。所以，如果我们想的话，可以将Q调小一些，以提高响应性，确保如果某个线程是交互式的，它可以更快地运行。
- en: Okay， and if you notice I have the quanta here as a range between 10 and 100
    milliseconds being standard。 I think I mentioned this in a previous lecture let's
    see if you remember what what is significant about 100 milliseconds and humans。
    Hopefully your reaction time is a little faster than that normally。 What else。
    but that's your on the right track。 It's when you start getting annoyed so when
    things feel laggy。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你注意到，我把时间片量设定为10到100毫秒之间的范围，这个范围很标准。我想我在之前的讲座中提到过，看看你是否还记得，100毫秒对人类来说有什么特别的意义。希望你的反应时间通常比这个更快。还有什么？你在正确的轨道上。那就是当你开始感到烦躁时，当事情感觉有延迟时。
- en: Okay laggyness is certainly at 100 milliseconds they done a lot of studies。
    For this okay and you can imagine if there if you're heavily interactive you might
    want to get down to the 10 millisecond range or whatever。 Okay。 But so performance
    you can imagine a lot of tuning here so if Q is really long。 Then you almost never
    have the timer go off and you basically just have first time for a serve again。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，延迟感在100毫秒时肯定比较明显，已经有很多研究做过这个。你可以想象，如果你是一个高度交互式的用户，可能希望将时间片缩短到10毫秒左右。好的。但你可以想象在性能方面，这里有很多调优的空间。如果Q非常长，那么定时器几乎永远不会响，你基本上就是让第一个进程被优先服务。
- en: Right， because you almost never cut anybody off。 If it's really small。 You're
    interleaving because you run for， you know。 a few milliseconds and then the next
    one runs and the next one runs。 And if you really went down to like one， maybe
    it's like hyper threading except you'd never do that because the software is running
    this right so this would be all overhead and no computing。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对，因为你几乎从不中断任何进程。如果时间片真的很短，你就会进行交替调度，因为你运行几毫秒后，接着是下一个进程运行，再接着是下一个进程。实际上，如果时间片非常小，比如1毫秒，可能就像超线程技术一样，但你永远不会这么做，因为软件会进行调度，这样会完全变成开销而不是计算。
- en: Okay， so Q has got to be large with respect to the context switch time。 Because
    otherwise the overhead is too high but you want it small enough that interactive
    jobs don't annoy their users。 So you can see there's a trade off there。 Okay，
    questions。 So actually。 you can't leave that up there long enough any questions。
    So now if you look。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Q必须相对于上下文切换时间较大。否则，开销太高，但你也希望它足够小，以便交互式任务不会让用户感到烦躁。所以你可以看到这里有一个权衡。好了，有问题吗？事实上，你不可能让这个时间显示得太长，有什么问题吗？现在，如果你看一下……
- en: here's an example of round Robin with the time quantum equal to 20。 So process
    P one。 First time a 53 process P two first time of eight process P three versus
    the key eight process for 24。 So imagine the quantum is 20， which means we wait
    20 units of time before the timer goes off。 So notice if P one starts， it gets
    to run for 20。 Before it gets killed off restarted using put back on the end of
    the queue because the first time is over 20 right so we run for at least 20。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个时间量子等于 20 的轮转法示例。假设进程 P 一的首次执行时间为 53，进程 P 二的首次执行时间为 8，进程 P 三的首次执行时间为 8，进程
    P 四的首次执行时间为 24。所以，假设量子是 20，这意味着我们等待 20 个时间单位，直到计时器响起。注意，如果 P 一开始，它将运行 20 个单位时间，然后会被中断，重新放回队列末尾，因为首次执行时间超过了
    20，对吧，所以我们至少会运行 20 个单位时间。
- en: And now P two only runs for eight。 Why。 Because the first time is only eight
    right。 So it's going to end at eight and then P three gets to run for 20 because
    it's time is at least 68。 Before gets to run for 20。 And then as we work our way
    through notice that P two is already exited the system。 etc。 And we could， we
    could go through those one at a time and that might get very agonizingly painful
    so we won't。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 而且现在，P 二只运行了 8 个单位时间。为什么？因为首次执行时间只有 8。它将在 8 时结束，然后 P 三会运行 20 个单位时间，因为它的首次执行时间至少是
    8。接下来，随着我们继续执行，注意到 P 二已经退出了系统，等等。我们可以逐个线程地分析，但这可能会变得非常繁琐痛苦，所以我们就不继续了。
- en: But we could say what is the waiting time for different threads so P one's waiting
    time is notice it starts out with no waiting time。 But then it has to wait 68
    minus 20 units of time right。 And then it also has to wait 112 minus 88 units
    of time。 So we could see that for P one。 the total amount of time it waits is
    is 72 here。 And similarly we can compute for all the other ones。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以计算不同线程的等待时间。P 一的等待时间，注意，它一开始没有等待时间。但随后它需要等待 68 减去 20 个单位时间。然后它还需要等待 112
    减去 88 个单位时间。所以，我们可以看到，P 一的总等待时间是 72。同样地，我们可以计算其他线程的等待时间。
- en: And then the average waiting time is 66 and a quarter and the average completion
    times 104 and a half。 So that。 You know， those are just numbers， but you can see
    we can use these metrics to start playing with。 Like as we change the quantum，
    do we have a better average waiting time or not。 Okay。 and so the brown Robin，
    the pros are it's better for short jobs by far than first come for serve context
    switching time adds up for long jobs。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，平均等待时间是 66 又四分之一，平均完成时间是 104 又二分之一。所以，这些，嗯，这些只是数字，但你可以看到，我们可以利用这些指标开始进行一些实验。例如，当我们改变量子时，是否能获得更好的平均等待时间？好的。所以轮转法的优点是，它对于短作业比先到先得好得多，但对于长作业来说，上下文切换的时间会累计。
- en: Okay， and here， we're assuming just because it slides in class that there's
    zero context which time but we all know better。 Right。 So if you switch a lot，
    you know you're going to add up a bunch of time saving and restoring registers
    and doing all that sort of stuff。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在这里，我们假设由于课堂演示的关系，没有上下文切换时间，但我们都知道其实并非如此。对吧？如果进行大量上下文切换，显然会增加许多时间，用来保存和恢复寄存器等操作。
- en: Okay。 And so， for instance， here we had when we have if we have a quantum of
    10。 and we have T one and T two， we see that we get an average response time that's
    long if we have a shorter quantum。 Notice that our average response time goes
    down。 Why？ Well。 because we get T one out of the way so T two can run。 Okay， make
    sense。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。例如，在这里，如果我们有一个量子为 10，并且有 T 一和 T 二，我们可以看到，如果我们有更短的量子，平均响应时间就会变长。注意到我们的平均响应时间下降了。为什么？嗯，因为我们先处理了
    T 一，这样 T 二就可以运行了。明白了吗？
- en: Here we have two threads with a quantum of 10。 Well。 the quantum of 10 doesn't
    affect the two threads because their first times are one。 So the average response
    times 1。5。 Same with the quantum's one so quantum here doesn't change anything。
    Okay， so now you're going to start to say wait， this is very dependent on the
    threads。 Yes。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个线程，量子为 10。嗯，量子为 10 对这两个线程没有影响，因为它们的首次执行时间都是 1。所以平均响应时间是 1.5。量子为 1 时也是一样，因此量子的改变对这里的结果没有影响。好的，现在你开始意识到，这很大程度上取决于线程。没错。
- en: unfortunately it is。 Right。 So here。 If our quantum goes from one down to a
    half。 The average response time goes up。 Why is that because we've gotten to a
    point where we're switching too much。 It actually makes things a little worse
    on the average response time front。 Okay。 Now。 you can obviously see。 Mid term
    questions out of this。 But hopefully you don't get hung up on that。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，确实是这样。对吧？如果我们的时间片从1秒降到0.5秒，那么平均响应时间会增加。为什么呢？因为我们已经到了一个切换过多的地步，这反而使得平均响应时间变得更糟。好的，现在，你们显然可以从这里看到期中考试的相关问题，但希望你们不要因此困扰。
- en: Try to get some insight here right so。 How do you implement round Robin in the
    kernel。 I'm going to show you that trade off with you in another slide in a second。
    But a five oh Q。 Just the same is with first come first serve， but you preempt
    the job as soon as the timer goes off。 you take it off of the CPU， put it on the
    end of the queue and just keep going。 Okay。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从这里获取一些洞见。那么，如何在内核中实现轮询调度呢？我马上会在另一张幻灯片中向你们展示这种权衡。但5.0版本的队列，与先到先得是一样的，不过你会在计时器一响时就抢占任务，将其从CPU中移除，放到队列的末尾，然后继续下一个任务。好的。
- en: Time or interrupt。 So I've been talking about round Robin since the day we started。
    Okay。 lecture one round Robin。 So in this ready cue。 Here's the cue we're talking
    about right there。 Okay。 hopefully not too mysterious。 Project two。 Not there
    yet。 You get to work on scheduling。 This is a relaxing week。 You work on project
    one。 But when we get to project two。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 时间片或中断。自从我们开始上课以来，我就一直在讲轮询调度。好的，第一课讲的是轮询调度。在这个就绪队列中，就是我们现在讲的这个队列。希望这不太神秘。项目二，还没有到。你们得做调度的作业。这是一个轻松的一周，专注于项目一。但当我们进入项目二时……
- en: you get to work on scheduling。 Okay。 Now， you know， how do you choose the time
    slice？ Well。 hopefully you see if it's too big。 The response time suffers。 If
    it's infinite。 you get first come for serve。 Time slice too small。 You're through
    put suffers and you swap too much。 And so actual choices。 I said again。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要开始做调度的作业了。好的，现在，如何选择时间片呢？希望你能明白，如果时间片太大，响应时间会变差。如果时间片是无限大的，你就会变成先到先得。如果时间片太小，你的吞吐量就会下降，并且交换太频繁。所以实际的选择，我再说一遍。
- en: we're between 10 and 100 milliseconds。 And， you know， originally in Unix。 they
    actually had a one second time。 And I have to say。 I wrote papers with multiple
    email access。 Talking to the same mainframe。 And it was amazing when there were
    too many users you type a long phrase。 To be or not to be that is the question。
    And a second later it would go。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间在10毫秒到100毫秒之间。你知道，在最初的Unix系统中，他们实际上设置了1秒的时间片。我必须说，我曾经写过多篇论文并使用多个电子邮件账户，与同一个主机交互。当用户太多时，打一个长句子，"To
    be or not to be, that is the question"（生存还是毁灭，这是个问题），然后过了一秒钟才会响应。
- en: And you get your to be your thought to be that is the question。 So not interactive。
    Even slightly。 Okay， try to imagine editing a paper like that。 It was。 Not fun。
    So you got a balance short job performance and long job throughput。 So typical
    time slices 10 milliseconds to 100 milliseconds。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你会通过思考“to be or not to be”（生存还是毁灭）来进行选择。即使是稍微不互动的情况也会如此。好的，试着想象一下像那样编辑一篇论文。那可真是不有趣。所以，你需要在短任务性能和长任务吞吐量之间找到平衡。典型的时间片是10毫秒到100毫秒之间。
- en: Typical contact switch overhead between point one and one millisecond。 And so
    roughly。 you could say we're getting about a 1% overhead of switching。 So that's
    not too bad。 We're not wasting。 More than about a 1% of our cycles doing the switching。
    Okay。 Questions。 Good。 Yeah。 Ah， is the time slice always constant or can it change？
    Yes。 So。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，切换开销在0.1毫秒到1毫秒之间。所以大致上可以说，切换的开销大约是1%。这并不算太糟，我们不会浪费超过大约1%的周期来进行切换。好，问题。好，嗯，时间片总是固定的吗，还是会变化？是的，确实会。
- en: mostly people leave alone and it's constant。 But you can change it under some
    circumstances。 So。 it depends on。 It depends on your scheduler and system。 But，
    you know。 the problem with the problem with the quantum and I'm going to show
    you another slide just a second here is。 It's a pretty。 Course。 It's a pretty
    good thing to tune。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，时间片是固定的，不会变。但在某些情况下，你可以调整它。所以，这取决于你的调度程序和系统。你知道，关于时间片的一个问题，我接下来会给你们展示另外一张幻灯片。它是一个比较粗略的设定，调优它是一个挺好的选择。
- en: It doesn't necessarily give you what you want in terms of really responsive
    and so on。 It's pretty good。 It's a nice kind of heuristic that works pretty well
    most of the time。 And so trying to fine tune cue。 It is probably not going to
    be worth the trouble。 But it's a。 it's an interesting thing to think about。 And
    in principle， you can。 I'm going to put this up。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它不一定会按你想要的方式提供快速响应等。它还是挺好的，算是一种大多数情况下有效的启发式方法。所以，尝试微调队列可能并不值得麻烦。但这是一个有趣的思考问题。从原则上讲，你可以。我打算展示一下这个。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_11.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_11.png)'
- en: I wanted to put this up because。 Let's put a couple more slides up here。 So
    simple example。 you got 10 jobs each。 Take 100 seconds of CPU time。 Round robin
    scheduler quantum of one second。 All jobs start the same time。 So you can look
    at the completion times here with FIFO。 And then you're done in a thousand cycles
    and again we're assuming that there's no overhead to switching with round robin
    in one second you're just doing。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以要展示这个，是因为。让我们再放几张幻灯片。举个简单的例子，你有 10 个任务，每个任务需要 100 秒的 CPU 时间。轮转法调度器的量子时间是
    1 秒。所有任务同时开始。所以你可以看看 FIFO 的完成时间。在这种情况下，你将在 1000 个周期内完成，假设没有切换的开销，在轮转法中，每 1 秒就进行一次切换。
- en: you know。 Job one job to job three job for job。 You work your way through and。
    That will also end in a thousand because they're both。 You know。 100 times 10
    total CPU cycles are needed。 So they both finish at the same time。 but the average
    response times much worse under round robin here。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道。任务一、任务二、任务三、任务四，你逐一执行它们。那也会在一千个周期后结束，因为它们两个都需要，嗯。你知道，100 乘以 10，总共需要的 CPU
    周期。所以它们同时结束。但在轮转法下，平均响应时间要差得多。
- en: And the easy intuition is with FIFO you got some jobs that end really early。
    whereas with round robin they all end really late。 So the， the， you know， the。
    the average response and final response final completion time are very bad。 And
    in this round robin case， your cash state keeps getting swapped out so to any。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的直觉是，在 FIFO 策略下，有些任务会非常早结束，而在轮转法中，它们都会非常晚结束。所以，平均响应时间和最终完成时间非常差。而在这个轮转法的例子中，你的缓存状态会不断被交换出去，所以……
- en: to the extent that your CPU is doing a nice job trying to get things in cash。
    This is kind of working against throughput for you。 Okay。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 CPU 做得很好，尽量把任务加载到缓存中，这反而会影响吞吐量。好的。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_13.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_13.png)'
- en: So here's another slide。 You know， cyan and Fuchsia great colors right so the
    best for suppose we have threads here P one is 53。 P two is eight P three is 68
    P four is 24。 We showed you that earlier。 The best first come first serve is if
    the shortest one goes first and then we go the next longest and the next longest
    and the next longest。 And so you can kind of see。 From a wait time standpoint，
    the best first come first serve。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是另一张幻灯片。你知道，青色和紫红色是很棒的颜色，对吧？那么最好的是假设我们这里有线程，P 一是 53，P 二是 8，P 三是 68，P 四是 24。我们之前给你展示过这个。最好的先来先服务方式是最短的先执行，然后依次执行下一个最长、下一个最长、下一个最长。所以你可以看到，从等待时间的角度来看，最好的先来先服务。
- en: And then for the average of 31 and a quarter， the worst gives you an average
    of 83 and a half wait time。 And then from a completion time we get 69 and a half
    and 121 and three quarters for completion time。 We can say at the quantum is eight。
    We can see that we get our average wait time to 57 and a quarter and average completion
    time to 95 and a half。 So notice that that's between the best and the worst。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于 31 和四分之一的平均值，最差的情况给你带来 83 和三分之一的平均等待时间。而从完成时间来看，我们得到 69 和三分之一，以及 121 和三分之四的完成时间。如果量子值为
    8，我们可以看到平均等待时间降至 57 和四分之一，平均完成时间为 95 和三分之一。所以请注意，这个值介于最好和最差之间。
- en: And then of course we can put all these other ones in the middle。 And you can
    see that， you know。 as long as you're kind of in the middle， it mostly works pretty
    well。 And fine tuning plus or minus is not really going to give you necessarily
    anything consistent there。 Okay。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以把这些其他情况放在中间。你可以看到，只要你处于中间，大部分情况下，它都能很好地工作。微调上下波动实际上并不会给你带来什么一致性的结果。好的。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_15.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_15.png)'
- en: Notice also though， P2。 What about P2 P2 is eight。 It's the shortest one。 Notice
    that P2 has the worst variance in possible scheduling here。 So notice。 if P2 is
    short because it's an interactive job for a user。 Notice that it has awesome wait
    time at zero or really bad wait time at 145。 Okay。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请注意，P2。P2是什么？P2是8，它是最短的一个。请注意，P2在调度时的可能变动最差。所以注意。如果P2是短任务，因为它是一个用户的交互任务，注意它的等待时间可以是零，也可能会有非常长的等待时间，达到145。好的。
- en: so this user is really either really happy or pissed。 And fortunately。 if you
    kind of get a reasonable quantum there。 Neither right there just they're okay。
    Right。 So the shortest job gets the most impact by varying the scheduling。 And
    the other thing to notice the longest job， like we're computing digits of pie
    has the least variation because notice。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个用户要么非常开心，要么非常生气。幸运的是，如果你能合理地选择一个时间片，那么两者的情况都会还行。所以最短的任务通过调整调度会受到最大影响。另一个需要注意的是，最长的任务，比如我们计算圆周率的任务，变化最小，因为注意。
- en: unless you pick the worst first come first serve when it gets to run first。
    It's otherwise basically the same， no matter what your quantum is。 So what is
    that。 What's the bottom line from this slide the bottom line from this slide is。
    You want you don't want to worry as much about the long jobs because the short
    ones get really impacted by scheduling。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你选择最差的先来先服务方式，让它最先运行，否则不管你的时间片是多少，它基本上是相同的。那么，这是什么？这个幻灯片的重点是什么？幻灯片的重点是，你不必过于担心长任务，因为短任务会受到调度的巨大影响。
- en: Okay， and the short jobs are your users。 So what that says is really annoyed
    users are much easier to get than annoyed computations of pie。 Right。 Good。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，短任务是你的用户任务。所以，这意味着恼怒的用户比计算派的长时间任务要容易得多，对吧？好。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_17.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_17.png)'
- en: Now， that's all fight and dandy， except that the problem with this is kind of
    everything is mostly treated I they're treated identically here right because
    we。 we basically say we set a timer。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切看起来都很好，除了问题在于几乎所有的任务都被当作相同的来处理，对吧？因为我们基本上说我们设置了一个计时器。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_19.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_19.png)'
- en: And if the timer goes off and you're still running we put you at the end and
    we'll run you again later that's the only thing that's going on here and all tasks
    are equal。 But we can imagine， instead wanting to prioritize tasks and suddenly
    we've got a priority scheduler。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计时器响了，而你还在运行，我们就把你放到队列的末尾，然后稍后再运行你，这就是这里发生的唯一事情，所有任务都是平等的。但是我们可以想象，实际上我们想要优先处理某些任务，这时我们就有了一个优先级调度器。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_21.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_21.png)'
- en: And you'll get to learn a lot more about this and when you start doing number
    two of your projects。 And so if you look here， we could have， you know， priority
    three priority two priority one priorities you're。 Zero queues。 And this now we
    have an execution plan which is always execute the highest priority runable jobs
    to completion。 possibly with a round robin and then go to the next priority in
    the next priority in the next priority。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始做项目的第二部分时，你会学到更多关于这一点的内容。所以，如果你看这里，我们可以有优先级三、优先级二、优先级一的任务队列。现在我们有一个执行计划：始终执行最高优先级的可运行任务直到完成，可能还会采用轮询算法，然后再执行下一个优先级的任务，依此类推。
- en: So notice that now， not only do we have round robin to make sure sort of all
    the jobs kind of make progress at a given priority level。 but we've now put priorities
    on them。 So that we can decide that some jobs are more important than others。
    Okay， you've all read animal farm， how many people remember animal farm right。
    Some。 some animals are more important than others all right so that's what we
    get out of this priority scheduling。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请注意，现在不仅我们有了轮询机制，确保在给定的优先级层级中，所有任务都能有进展。而且我们现在还给它们设置了优先级。这样我们就可以决定哪些任务比其他任务更重要。好的，你们都读过《动物农场》，多少人记得《动物农场》对吧？一些动物比其他动物更重要，好吧，优先级调度就是我们从中得到的东西。
- en: Okay。 Now， of course the problem with this is going to be choosing who's what
    priority right picking the priority so that you get whatever effect you want it's
    going to be tricky。 But， and some problems that are pretty obvious hopefully is
    that starvation becomes very possible。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。当然，问题在于选择谁的优先级，正确地设置优先级，以便获得你想要的效果，这将是很棘手的。但是，像饿死现象这样的明显问题，也许会变得非常可能。
- en: If you've got a job stuck at the lowest priority and nothing but higher priority
    things come in and the low priority one will never run。 Okay。 And so， you could
    actually end up with something even worse which is a priority inversion。 And this
    actually took out the Martian Rover。 And maybe I'll make sure we talk about that
    next time but what happened there was if a low priority job grabs a lock。 And
    then a high priority job is waiting for the lock。 Okay。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个任务被卡在最低优先级，并且只有更高优先级的任务不断进入，而低优先级的任务永远无法运行，好的。然后，你甚至可能会遇到更糟糕的情况——优先级倒置。这实际上曾经导致了火星车的故障。也许下次我会确保我们讨论这个问题，但当时发生的事情是，如果一个低优先级的任务获取了锁，然后一个高优先级的任务在等待这个锁。那么，发生了什么呢？
- en: and a middle priority job is running computing pie。 Now you're now you're dead
    law。 Why is that well the high priority ones trying to sleep。 They're trying to
    get the lock but sleeping the middle ones running and the low priority one can
    never run and release the lock。 Okay， and that is a situation that will never
    resolve itself。 Okay。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中等优先级的任务正在运行计算饼图。现在你现在死锁了。为什么会这样呢？因为高优先级的任务正在尝试进入休眠状态。它们试图获取锁，但正在休眠，而中等优先级的任务正在运行，低优先级的任务则永远无法运行并释放锁。好了，这就是一个永远无法自行解决的情况。好的。
- en: And it turned out there was a problem with the Martian Rover just like this。
    And where the high priority was was the bus and the low priority was a particular
    measurement scheme in the middle priority was doing some maintenance of the of
    the device。 And the only reason they actually managed to get the Rover to do the
    right thing。 This is one of the original rovers was they were able to reboot it
    and debug it from earth。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，火星车的确出现了一个类似的问题。高优先级任务是总线，低优先级任务是一个特定的测量方案，而中等优先级任务则在进行设备的维护。唯一让他们最终能够让火星车执行正确操作的原因是，他们能够从地球远程重启和调试它。
- en: which was pretty fortuitous。 So， so how do we fix problems with priority scheduling
    well that's going to be an interesting topic for us。 Because we got to start varying
    the priorities dynamically。 So we start with a given set of priorities but then
    we move things up or down based on dynamic heuristics。 Okay， and that's how we're
    going to play with this。 Okay。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很巧合。那么，如何解决优先级调度的问题呢？这将是一个有趣的话题。因为我们必须开始动态地调整优先级。所以我们从一组给定的优先级开始，但随后根据动态启发式算法将任务的优先级向上或向下调整。好的，这就是我们将要处理的方式。好的。
- en: so hopefully you're starting to see that scheduling gets more interesting with
    the moment right or maybe more complicated。 I don't know。 We'll have to talk about
    that。 So we can ask ourselves what about fairness。 So strict fixed priority scheduling
    between cues is very unfair。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所以希望你们开始看到调度在这一刻变得更有趣了，或者可能更复杂了。我不知道。我们得讨论一下这个问题。所以我们可以问自己，公平性怎么样呢？严格的固定优先级调度在队列之间是非常不公平的。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_23.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_23.png)'
- en: Okay， this， this is unfair because as long as there are priority three jobs。
    none of the lower priority ones get to run。 But maybe that's okay if the priority
    three jobs are trying to put the brakes on。 Okay。 Now the question I just got
    in the chat is， is what I'm saying here about priority rearrangement。 meaning
    that the something with the lowest priority could suddenly become the highest。
    Well。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这不公平，因为只要有优先级三的任务，低优先级的任务就永远无法运行。但是如果优先级三的任务正在尝试实施制动措施，也许这样就可以了。现在，我刚刚在聊天中收到的问题是，我所说的优先级重排是否意味着，最低优先级的任务可能会突然变成最高优先级的任务？嗯。
- en: in fact， yes， there's something called priority donation。 where if a high priority
    thread is trying to grab a lock， but a low priority one has the lock。 All right，
    what will happen is the high priority one will be able to donate its priority
    to low priority one so that it can run long enough to release the law。 Okay， and
    that's just one of many dynamic priority things we're going to come up with。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，是的，存在一个叫做优先级捐赠的机制。如果一个高优先级的线程试图获取一个锁，而一个低优先级的线程已经持有该锁。那么，高优先级的线程将能够将它的优先级捐赠给低优先级的线程，以便它能够运行足够长的时间来释放这个锁。好了，这只是我们将要提出的众多动态优先级机制中的一个。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_25.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_25.png)'
- en: So， so strict priority scheduling between cues is unfair。 There was an urban
    legend that's absolutely not true。 but I'll repeat it anyway because it's an urban
    legend， which was in multi。 They shut down the machine and found a 10 year old
    job that had been sitting in the queue for 10 years and never run。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，队列之间的严格优先级调度是不公平的。曾经有一个完全不真实的都市传说，但我还是要重复它，因为它是都市传说。那就是在多任务操作系统中，他们关掉机器，发现一个10年的作业一直在队列中等着，从未运行过。
- en: Okay， the only thing this serves is to point out that urban legends are ridiculous。
    And be a B and be that。 Trying to make it very clear that low priority things
    might not get to run。 Okay。 So you have to give long running jobs， some fraction
    of the CPU。 you do strict priority scheduling。 Maybe you won't have a job stuck
    for 10 years。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这唯一的作用是指出都市传说是荒谬的。并且很明确地指出低优先级的任务可能无法运行。好的。所以你必须为长时间运行的作业分配一定比例的 CPU。你使用严格的优先级调度。也许这样你就不会让一个作业卡在队列里待10年。
- en: but you could have very well have a job that you want to make some progress
    that never makes progress。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可能会有一个作业，它想要取得进展，但始终没有进展。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_27.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_27.png)'
- en: Okay， so this in its purest form is probably not a good plan。 Okay。 but it starts
    to give us the idea of knobs that we can twist to try to allocate CPU to things
    that matter in the moment。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这在最纯粹的形式下可能不是一个好计划。好的，但它开始给我们提供了一些可以调整的思路，以便尝试将 CPU 分配给当前重要的任务。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_29.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_29.png)'
- en: Okay。 So the trade off is the fairness gained by hurting the average response
    time。 So what we do is we give the long running jobs a fraction of the CPU。 then
    they're really short ones。 Get less CPU and that might be okay。 So how do you
    implement fairness， you could give each cue some fraction of the CPU。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以权衡是通过牺牲平均响应时间来换取公平性。我们做的就是为长时间运行的作业分配一些 CPU，然后让非常短的作业得到更少的 CPU，这可能是可以接受的。那么，如何实现公平性呢？你可以给每个队列分配一定比例的
    CPU。
- en: If you have one long running job and 100 short running ones。 You know， what
    do you do。 you could increase the priority of jobs that don't get service。 Yes，
    go ahead。 Ah， so the。 is there a way to decide your priorities。 So the tricky
    part about that question is。 You think you're doing you come up with a good scheme
    and invariably it's not a good scheme。 So。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个长时间运行的作业和100个短时间运行的作业，你该怎么办？你可以增加那些没有得到服务的作业的优先级。是的，继续吧。啊，所以，是否有办法来决定优先级？这个问题的难点在于，你以为自己想出了一个很好的方案，但往往它并不是一个好方案。所以。
- en: there's lots of ways that people pick priorities。 Okay， and just because I like
    answering questions。 I'll give you this one。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 人们有很多方法来选择优先级。好的，因为我喜欢回答问题。我给你这个问题。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_31.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_31.png)'
- en: Assume for a moment that there's 140 priorities。 And the bottom one or the top
    100 of them。 the most important ones get chosen based on how frequently an event's
    going to happen in the bottom 40 get chosen based on what we're talking about。
    That's exactly what the Linux scheduler has it has 100 real time priorities。 And
    the way you choose a priority is the thing that occurs with a higher frequency
    gets the higher priority。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一下有140个优先级。底部的或者最重要的前100个优先级，基于事件发生的频率来选择，底部40个则基于我们正在讨论的内容来选择。这正是 Linux 调度器所采用的方式，它有100个实时优先级。选择优先级的方式是，频率较高的事件会得到更高的优先级。
- en: And so there's a way to assign based on its period you could choose one of the
    hundreds。 One of the hundred priorities and that's a mathematical choice。 And
    then the remaining 40。 And then the problem we just talked about， which is you
    got to choose。 but that's at least one way of assigning priorities that matter。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以根据周期来分配，你可以从100个优先级中选择一个，这个是一个数学选择。然后剩下的40个优先级，再结合我们刚才讨论的问题，你必须做出选择。但至少这是分配优先级的一种方式，这些优先级是重要的。
- en: And I'll talk about that when we talk about real time。 So， you could each。 we
    could get each queue of some fraction of the CPU。 And then we could increase priority
    of jobs that don't get service。 So if a job is running for a very long time and
    it's not getting any service。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在谈论实时时提到这个问题。所以，你们可以分别为每个队列分配一部分 CPU。然后，我们可以增加那些没有得到服务的作业的优先级。所以，如果一个作业运行了很长时间却没有得到任何服务。
- en: then you could slowly up its priority to give it more service。 Okay， that's
    kind of dynamic。 But I want to close with this idea of what if we knew the future
    instead。 Could we come up with the best first come first serve because remember。
    first come first serve is only bad some of the time where it's really bad。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以逐渐提高它的优先级，以便为它提供更多的服务。好吧，这算是动态的。但是我想以这个问题来结束：如果我们知道未来会怎样呢？我们能不能想出最佳的先来先服务策略，因为请记住，先来先服务只是某些时候不好，尤其是当它真的很糟糕的时候。
- en: But sometimes it's really good。 Right， a really good first come first serve
    is what we manage to have the shortest jobs first。 That's great。 Right。 But can
    anybody tell me why it's hard to do。 No， right。 you would have to do a good job
    predicting。 So instead， in the last couple minutes of the class。 what I want to
    do is， what if you knew the future。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候它真的很好。对吧，一个非常好的先来先服务策略就是我们能确保最短的任务优先完成。太棒了。对吧。但是有谁能告诉我为什么这么做很难吗？没有对吧？你必须做出很好的预测。所以相反，在课堂的最后几分钟，我想探讨一下，如果你知道未来会怎么样。
- en: So I'm not going to tell you how to know the future yet。 We'll do that next
    time and you guys can get your stock trading accounts out and stuff but。 Suppose
    we actually knew。 Okay， then we could get an algorithm。 an algorithm we're going
    to call the shortest remaining time first， which is when。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我现在不会告诉你们怎么知道未来。我们下次会讲，大家可以准备好股票交易账户什么的。不过，假设我们真的知道。好吧，那么我们就可以得到一个算法，叫做最短剩余时间优先，这就是……
- en: when you've got a cue and you got to pick the next one you just grab the one。
    You just grab the one who has the shortest remaining part portion of their birth，
    and you run them。 Shortest remaining time first and there's actually a， a shortest
    job first。 which is the non preemptive version but let's just talk about shortest
    remaining time first。 And。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个队列，必须选择下一个任务时，你只需要选择剩余部分最短的那个。你选择剩余时间最短的任务来运行。最短剩余时间优先，实际上还有一个非抢占式的最短任务优先。但我们先讨论最短剩余时间优先。
- en: and we can apply it to the whole program or to birth or whatever but if we knew
    the future。 Then we could do this SRTF and it turns out that SRTF which again
    it's， we look at the cue。 I picked the one with the shortest runtime left and
    I run it has the absolute best minimal average response time。 So if we could somehow
    figure out the future we could do that。 Okay， and it's provably optimal。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它应用到整个程序，或者应用到出生等地方，但如果我们知道未来。那么我们就可以做最短剩余时间优先，事实证明，最短剩余时间优先是，嗯，我们查看队列，选择剩余运行时间最短的任务运行，它有着绝对最佳的最小平均响应时间。所以如果我们能以某种方式预测未来，我们就可以做到。好吧，这个是可以证明最优的。
- en: Okay， to the extent that provably optimal involves predicting the future。 So
    if you compare SRTF with first come first serve， for instance。 what if all the
    jobs are the same link。 Well SRTF just becomes the same as first come first serve
    why 10 jobs that are equal link。 They're all the same like you pick one， it starts
    running。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在可以证明最优策略涉及预测未来的情况下。如果你将最短剩余时间优先与先来先服务进行比较，例如，假设所有任务的时长相同。那么最短剩余时间优先就变成了和先来先服务一样，为什么呢？如果10个任务时长相同，大家都是一样的，你挑一个，它就开始运行。
- en: it's no longer ever going to get preempted because it's now the shortest one
    left right so it runs the completion next next。 Okay， on the other hand if the
    jobs have the varying link。 the shortest remaining time first just make sure that
    short jobs always go first。 Okay。 and here's a benefit。 So if you have three jobs
    we have a and b are really long so they run for a week。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它就永远不会被抢占，因为它现在是剩余时间最短的任务，所以它接下来就运行。好吧，另一方面，如果任务有不同的时长，最短剩余时间优先就能确保短任务总是优先执行。好吧。这里有一个好处。如果你有三个任务，假设a和b非常长，它们需要一周才能完成。
- en: See has to run for a very short period of time because it's doing something
    like copying data off a disk。 So it computes what the next data get off the disk
    is that it does the disk time and then it computes the next thing。 And so to get
    maximal behavior。 What I'm going to want to do is run this thing at extraordinarily
    high priority for the brief compute and then I send things out to disk and I can
    run something else。 So the only way that this job gets maximum bandwidth out of
    the disk is if we're always running the short little compute type thing at highest
    priority。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 看，任务必须运行非常短的时间，因为它正在做一些像从磁盘上复制数据的事情。它计算出下一个要从磁盘获取的数据，然后执行磁盘操作，然后计算下一个任务。所以，为了获得最大效益，我想做的是将这个任务以极高的优先级运行在短时间内，然后把东西发送到磁盘，接着可以运行其他任务。因此，这个任务只有在我们始终以最高优先级运行短小的计算任务时，才能最大化磁盘带宽的使用。
- en: Okay， and these guys in the background they're going to compute for a week anyway
    so they don't care if we interrupt them。 Okay， so with first come first serve，
    if a or b gets to run， see is just toast。 Right。 it will just not work because
    you got to wait a week。 Okay。 and you don't copy things off of the disk。 So round
    Robin。 Well with round Robin。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些后台的任务无论如何都要计算一周，所以它们不在乎我们是否中断它们。好的，按照先到先得的原则，如果a或b可以运行，c就完蛋了。对吧？它根本行不通，因为你得等一周。好的，另外，你不能从磁盘上复制东西。那么轮转调度呢？如果使用轮转调度。
- en: you kind of get this right you run see for a very short period of time。 and
    then it does its disk access。 And then it gets to run for say 100 milliseconds
    and be for 100 milliseconds and then see runs for a very short period of time。
    Okay， and if you look at this previous slide here。 We want to see actually to
    run for one millisecond and nine milliseconds at this time。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你这样理解就对了，先运行c很短的时间，然后它进行磁盘访问。然后它可以运行100毫秒，b也运行100毫秒，然后c再运行很短的一段时间。好的，如果你看一下之前的幻灯片，我们希望c实际上运行一毫秒和九毫秒的时间片。
- en: So it's only with one millisecond and nine milliseconds at this time that we
    get 100% of the I/O。 And so here， our disc utilization is now nine out of 201
    it's only 4。5%。 Okay， so this is bad。 If we round Robin it， we waste a huge amount
    of time。 We can get the disc utilization back up to close to 90%。 With SRTF。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以只有在一毫秒和九毫秒的时间片内，我们才能实现100%的I/O利用率。所以在这里，我们的磁盘利用率现在是201个单位中的9个，仅为4.5%。好的，这样很糟糕。如果我们用轮转调度，那就浪费大量的时间。我们可以通过SRTF调度将磁盘利用率恢复到接近90%。
- en: we can get it to be exactly 90% which is the best we can do。 So I'm going to
    close there for now we're going to pick up this next time。 But and we're going
    to take that prediction of the future and we're going to figure out how to do
    that。 But round Robin's scheduling is give each thread a small amount of the CPU
    time when it executes cycle between all the threads shortest job first。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其调整到90%，这是我们能做的最好的情况。所以我就先停在这里，我们下次再继续。不过，我们会用预测未来的方式来解决这个问题。但是轮转调度是给每个线程一个小的CPU时间片，执行时在所有线程之间循环，采用最短作业优先的策略。
- en: It's going to be run whatever job has the least amount of computation to do
    and do that somehow by predicting the future。 And we're going to turn all that
    into a multi level feedback scheduler which gives us somewhat of a prediction
    of the future。 All right。 Have a great rest of your Tuesday and we'll probably
    see you on Thursday。 Ciao。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它将运行计算量最少的任务，并通过预测未来以某种方式执行。我们将把这一切转化为一个多级反馈调度器，从而在某种程度上预测未来。好的，祝你们周二剩下的时间愉快，我们可能周四再见。再见。
- en: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_33.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c4cf6f6acdc9fbdb98280ebf30c638_33.png)'
- en: '[BLANK_AUDIO]。'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[BLANK_AUDIO]。'
