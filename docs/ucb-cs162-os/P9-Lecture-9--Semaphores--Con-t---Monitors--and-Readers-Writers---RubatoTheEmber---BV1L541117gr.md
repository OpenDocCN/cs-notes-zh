# P9：第9讲：信号量（续）、监视器和读写者 - RubatoTheEmber - BV1L541117gr

好的。

![](img/1641ab5f908ca769eaeff2b6ac73408a_1.png)

![](img/1641ab5f908ca769eaeff2b6ac73408a_2.png)

欢迎大家。今天是最后一堂同步讲座，我们希望确保讲解一些重要的内容，帮助你们为考试做好准备。所以，今天的内容将是上次更新的额外讲座的很多相同内容，那个讲座我已经在周四发布了，但今天会有一些不同。

亲临现场，你会喜欢的。所以，如果你还记得上次我们讨论的是同步问题。我们做的一件事是介绍了原子指令序列的概念。实际上，这就是能使同步在用户模式下运行得很好的原因，因为如果没有这一点，最好的方法只是禁用和启用中断，或者加载和存储，而这两者都不是我们之前看到的理想方案。所以我们有了“测试与设置”（test and set）这种原子指令。

这些序列应该是你非常熟悉的，因为它们几乎出现在如今的任何架构上。一些更有趣的指令比如交换（swap）。交换基本上是将寄存器和内存位置交换，而“设置与测试”（test and set）则是将一个内存位置置为1。然后，交换指令会把两个寄存器中的值进行检查，看第一个寄存器的值是否和内存中的值相同，如果相同，就将第二个寄存器的值存入内存。

好的，然后这个链接加载和链接存储条件指令（link load link store conditional）是另一种更具风险的RISC风格的原子指令序列，我稍微提到过，但我们会稍后再详细讨论。所以，这些原子序列有哪些选择呢？是的。对的。

所以有一个交换（swap）指令，然后是对交换的封装。这样你就可以在代码中使用它，或者其他地方使用。交换这个简单的指令就是把寄存器和内存中的内容交换。当你完成时，寄存器中有一些东西，在C代码中这并不十分有用，因为你看不到寄存器的内容。所以通常交换宏或其他方式会把寄存器中的值返回。

所以这就是我在这里展示它的原因。实际上，我并没有在这里展示返回值，但这个想法是，如果你将值返回到寄存器中，那么它就会是……你知道，当你进行交换时，你会得到一个不在内存中的东西。然后你可以使用它。稍等一下，我会给你展示你现在想到的幻灯片。好吧。是的。所以。

所有这些东西都是原子的。好吧，在这个特殊的比较与交换指令（compare and swap）中，它在x86架构中有，在68.000架构中也有。但是原子性意味着我刚才说的所有这些内容和我在这里展示的所有操作，都以一种不能被其他线程交错或中断的方式发生。

所以它是一个单一的指令。所以在比较和交换（compare and swap）的情况下，这个指令在 x86 上通过两个寄存器和一个内存位置进行操作，检查第一个寄存器与内存中的值是否匹配，如果匹配，就将第二个寄存器的值存入内存。返回的结果是一个成功或失败的标志。所以在比较和交换的情况下，如果你进行了存储操作，就返回成功；如果没有进行存储操作，因为第一个值不匹配，那么返回失败。

好的。是的，这前三个都是单一的汇编指令。对。好的。很好。这些指令对我们构建各种复杂的同步非常有帮助，因为我们需要能够同时进行存储和加载，才能真正实现同步，因此我们需要以某种方式将它们结合起来。

好的。那么我们开始构建更好的锁，这是使用测试和设置（test and set）的一个例子。测试和设置将一个 1 存储到内存中，然后返回存储之前的值，并在这里用 C 语言实现。所以我可以这样说：好，测试和设置。嗯，接着我们查看了将测试和设置作为本地同步操作来使用，最后决定这有点复杂，于是我们有了更好的锁。

我们花了很多时间讨论过这个，其中实际上我们在内存中既有一个保护（guard），又有一系列的锁。其思想是快速检查保护区。如果保护区是空闲的，那么就可以继续执行锁操作，否则就进入休眠。如果是空闲的，就获取锁并返回。因此我们将保护区像禁用和启用中断一样使用。

我们讨论了很多关于这一点的内容。我们还稍微谈了一下 Few texts。所以 Few texts 是一个隐藏的 lib C 或者隐藏的系统调用，帮助你进行同步操作。好的，使用的库，比如 p thread new texts 等，都使用了 Few texts。所以基本的 utext 系统调用接受一个内存位置、一个值和一个操作。然后它。

它基本上根据操作的不同，要么唤醒某个线程，要么表示如果内存位置的值不匹配，执行操作。所以如果你不打算这样做，但如果你不打算这样做，你就不能这样做。如果你不打算这样做，你就不能这样做。如果你不打算这样做。

你不能这样做。所以如果你不打算这样做，你就不能这样做。如果你不打算这样做，你就不能这样做。如果你不打算这样做，你就不能这样做。对，你得禁用中断，得弄乱调度队列。所以进入休眠并不是用户级操作。所以你必须像进入内核那样去做。

Few texts 是一种接口，它可以让你干净地进入内核，而不需要一直这么做。好的，实际上，曾经有这样一个东西，虽然我们不打算进一步讨论。我上次有提到过，这就是当时所做的事情。

![](img/1641ab5f908ca769eaeff2b6ac73408a_4.png)

这是之前提到的内容，但关键在于它是在用户级别。当锁可用时，它会迅速获取锁并释放锁。如果没有竞争，也就是你是唯一获取并释放这个锁的线程，那么这个实现有一个非常好的特性，就是你永远不会进入内核。所以如果你快速获取锁，做某些事情，然后释放锁，而你是唯一的线程。

这个实现永远不会进入内核。所以这是一个对用户来说非常好的实现，也不会导致忙等待。好了。这基本上是你在使用 p 线程同步操作时得到的效果。好了，我不想在这个话题上停留太久，因为我想回到讨论比锁更强大的同步方式。好了，继续提问。没有问题。好吧。那么，继续，你可以问你的问题。是的。

那么，发生了什么，当你执行原子操作时。通常情况下，你会让它看起来像一个函数调用，而被竞争的值会被放入一个寄存器中，而我的锁是一个位置，然后当你执行交换时，竞争中的值从寄存器中被放入内存中。

所以，这就是这种语法的含义，它会编译成一些指令的汇编代码。对于那些真正深入研究代码的人来说，可能会看到一些汇编指令嵌入在 C 代码中。好吧，G，GCC 编译器等有一种清晰的方式来处理与寄存器和内存交互的内容，并将其包装成看起来像是一个函数调用的形式，这就是这里发生的事情。好了，明白了。接下来。所以我们在看可乐机的例子，这就是这个有界缓冲区。

在这里，缓冲区有一个有限的大小，消费者在喝可乐，生产者在生产咖啡。无论有多少生产者和消费者，无论是 M 和 N，反正就是很多。而缓冲区是固定大小的，我们希望有一个非常干净的语义，这样如果缓冲区没有剩余空间，而一个生产者来了，尝试往缓冲区放东西时，就会进入睡眠状态。

然后，当有空间时，它会在稍后被唤醒，消费者也是一样，如果消费者尝试从缓冲区中获取某些东西，如果里面没有东西，那么消费者会睡眠，直到有人生产。好吧。这个类比就像可乐机一样，真的很好。你只能在可乐机里放这么多罐子，所以当送货员来时，如果可乐机已经满了。

它就会进入睡眠状态。好吧，也许这个类比有点勉强，但可以这样理解。当你急需一罐咖啡因的时候，你去到机器旁，它是空的。如果我进入睡眠状态，这个似乎更符合现实。然后送货员过来，放上罐子，机器醒了，你拿到你的罐子然后继续。好了。

所以，这里的可乐机就是一个有界缓冲区。好的。好的。之前在聊天中有人问到什么是原子操作，原子操作意味着不可中断的操作序列。所以，我们不希望生产者或消费者必须步调一致地工作，我们希望它们是异步的，意味着生产者和消费者可以在任何时候进行操作。我们希望有正确的等待条件。我举了一个例子，比如使用管道的GCC编译器。

你们现在都很熟悉的就是，C语言的预处理器将信息输出到标准输出，然后第一阶段的C编译器会将其从标准输入中提取出来，第二阶段是反汇编、汇编和加载器。这个管道就是一个有界缓冲区。好的，这正是我们在谈论的内容。然后是可乐机的例子，接着是web服务器和路由器，它们都有这些有界缓冲区，所以这是一个非常有用的概念。

现在当我们开始思考该做什么时，我们必须从下面的数据结构开始思考。所以，在61 B中，你学习了各种很酷的数据结构。好的，这是其中最无聊的。

![](img/1641ab5f908ca769eaeff2b6ac73408a_6.png)

你们一定学过的其中一个是有限大小的循环缓冲区。它有一个头指针和尾指针，或者一个写指针和读指针。其想法是，当你到达一端时，你会回绕，根据写指针和读指针之间的关系，可能是空的，也可能是满的，等等。好的，这些都是61 B的内容。

但你可以看到的是，为了从这个缓冲区中插入或移除某些东西，我们实际上需要比较正确的写入索引和读取索引。如果两个线程同时在执行这一操作，其中一个是写入操作，举个例子，我们就会出现问题。好的，这就是一个同步问题。好的。

我们可以很容易地问自己这样的问题：这里需要原子性吗？那么，什么需要是原子的，并且能让这个过程正常运作？任何人？是的，增加一个索引。但这不能是全部。问题不仅仅是增加索引，还要在增加之前将当前索引与另一个索引进行比较，因此这必须作为一个序列是原子的。因为如果你进行比较，准备增加索引，但有人在你之前把东西取走了，然后你再增加索引，那么队列就会出错，对吧？所以，必须有一组指令要作为原子操作一起执行。

所以大家理解了吗？它不能只是单独一个操作。顺便说一句，增加索引本身就是一个问题，因为你需要从内存中读取，增加某个值或做减法，这显然需要做成原子操作，另外，比较操作也需要做到这一点。所以，这是你在尝试同步时首先要考虑的事情。好的。

你知道，这可能是我们第一次的尝试，因为我们需要做同步操作。我们可能会说，让我们加个锁。好的，那么为了生产某样东西，生产者会先获取队列上的锁，然后将物品放入队列并释放锁。

从不让队列出错的角度来看，这个方案看起来还不错。好的，因为如果有两个生产者或者一个生产者和一个消费者来操作队列，只有一个能够获取锁。所以我们需要小心这一点，例如消费者端，我们获取并释放锁。

好的，这段代码有什么问题呢？对，这是非常有问题的代码。好的，一旦触发其中一个条件，你基本上就会锁死。让我们弄明白这一点，我们获取锁，检查缓冲区状态，然后说，哎呀，缓冲区满了。好的，作为送货员，我只能在可乐机前睡着。

然后我会等待有人清空可乐机。然后你有了锁。那么谁能清空呢？好，这里就是你们，这些学生们去拿可乐。他们在拿之前尝试获取锁，但锁已经被占用了，他们只好睡觉。好的，生产者已经拿到锁，生产者一直在不停地旋转，而消费者则尝试获取锁但只能睡觉。

然后你会有一些送货员，实际上只有一个站在机器前面，而一群学生正在睡觉，任何可乐都无法传递出去。好的，这看起来是个糟糕的解决方案。我希望大家清楚为什么这是不行的。好的，这里有问题吗？只要你从不填满机器或清空机器，这个方案其实是没问题的。

但问题不在这里。对，我们明白了，我们正在尝试创建一个有界缓冲区。我们想要一个无限缓冲区，在那个情况下，我猜你可以走开拿到一瓶空的可乐。而也许去掉这些死循环是可以的，但这不是我们当前的目标。好的，继续之前有问题吗？问题的根源在于我们实际上在合并多个操作。

这就像是一个单一的锁，这实际上是我们遇到麻烦的根本原因。我们正在以一种方式组合队列上的原子操作，确保队列在有多个生产者或消费者的情况下不会出错。同时，我们还在检查队列是否已满或为空。这两者都被组合在一个锁中，这正是会给我们带来麻烦的原因。

好吧，我们不能优雅地做这个。我们可以这么做。好的，这不是优雅的代码。它是可以工作的代码，因此不会死锁，但请注意我所做的不同之处。就在这里，在while循环中，我说，只要缓冲区已满，就释放锁，再次获取锁，等等，一直重复，释放、获取、释放、获取、释放、获取，一直循环。

为什么这样可以防止死锁？你们自己想一想。是的，如果你释放了锁，你不会进入休眠。但想象一下这个情境。可乐商人出现了，缓冲区已满。与此同时，另一个学生来了，他们尝试获取锁，但是锁被占用了，所以他们进入了休眠状态，消费者就坐在那里睡觉。而生产者持有锁，但我们释放了它。好的。

当我们释放锁时，并不是我们进入了休眠，而是另外一个线程（学生）被唤醒。所以现在有两个线程，两个都在就绪队列中，并且都可以运行。这意味着我们可以让学生去拿可乐。

然后，生产者会重新获取锁，发现缓冲区没有满，并能够执行一个项目。但是，这种方式有很多问题。第一个问题是它是繁忙等待。好吧，这种繁忙等待是有问题的。我们之前谈过这个问题，但如果你看看生产者或消费者，它们一直在不停地忙碌地旋转。好吧，释放锁，获取锁，释放锁，获取锁，一直重复。所以这浪费了指令时间。

第二个问题是，如果你释放了这个锁，并且生产者和消费者都准备好运行，实际上没有保证你不会立刻再次获取锁。好的，然后消费者就能运行，检查是否有空的项，然后立刻重新进入休眠状态，所以在这个过程中也没有任何顺序。

所以这就是，你知道的，它们会运行，最终会取得进展，但这不是一个好的解决方案。好的。是的。好的。那么，问题是，当我们把所有人都放到就绪队列时。是否可能存在一个死锁的情况，它们仍然无法取得进展？好的。现在，聊天中有个问题说，嗯。

所以，这比我们之前的解决方案中的繁忙等待要好一些，之前的解决方案完全是死锁。无论如何，那就是坏掉了。这个方案不好，可能会有进展。好的，但这仍然不是好代码，如果你在这门课之外的地方写了这个，我们可能会多次质疑它。好吧，接下来我们做点别的事情，也就是选对抽象。

所以这里的真正问题是，我们限制自己只使用锁，锁其实是非常原始的。我是说，它们比没有锁要好，但我们希望有一个更高级的原语，它能以一种更自然的方式来表达我们期望的并行性。好的，这将是我们的目标。

所以，好的原语和实践非常重要。那么，执行方面。我希望到现在你已经意识到，程序并不是一直顺序执行的，因为我们有线程，它们在这里运行，然后在这里运行，接着在这里运行，它们之间是有并发的。

等等。所以，当你面临非确定性时，真的很难找到错误。因此，实际上，我们通过选择正确的同步原语来做的是：确保我们写出的代码是正确的。好的，我们通过选择一个好的同步原语来做到这一点。对了，锁现在已经在你口袋里了。但让我们看看是否能做得更好。

我之前提到过，Unix现在已经相当稳定了，但在80年代的时候，可就不一样了。当时有各种各样奇怪的同步错误，大家并不完全理解这些问题。所以同步是一种使用共享状态来协调多个活动的方法。好的，接下来我们来讨论信号量，信号量比锁更进一步。

它们有点像一种通用的锁，并且最早是由Dyke String在60年代定义的，因此它们已经存在很长时间了。然后，在很多版本的Unix中，它们是主要的同步原语。好的。那么，什么是信号量呢？信号量是一个非负整数，有两个操作：down或P和up或V。好的，P操作是一个原子操作，它会等待信号量变为正数，并将其减少1。

V操作会将信号量递增1，如果此时有线程在休眠，它们将被唤醒。好的，那么让我们再思考一下。它是一个非负整数，你一开始得到它，一旦你设置了它，它就完成了初始化，你再也无法读取它了，所以接口甚至不允许你查看它的值。

但是你只有P和V。好的，所以，P表示递减，除非它已经为零或更低，否则就让它休眠。然后它会递增，如果你从零变成一，而有线程在休眠，那么你会把它们唤醒。好的，所以它是一个有趣的整数类型。好了，我给你们展示过这个。

我不会玩动画的。信号量就像整数，只是没有负值。唯一允许的操作是P和V。顺便说一句，你知道吗，P和V是最初的名字，来自荷兰语的down和up，或是semi down和semi up。对于这个名字你可以有一些灵活性。

但我们会确保你知道该使用哪个。所以，如果它很重要，我们稍后会讨论P和V操作。我们将采用传统的方法，但唯一的操作是P和V。所以你不能读取或写入值，这些操作必须是原子性的。那么为什么这很重要呢？这表示，如果信号量为零，并且某个线程正在尝试执行P操作，

它会注意到值为零并自己进入睡眠状态。因此，如果你要执行操作V，它也是原子性的。如果你要从零变成一，你需要在变为一的那一瞬间检查，看看有没有线程需要被唤醒，并且要原子地唤醒它们。所以，确保这两件事原子地绑定在一起是非常重要的，否则我们就得不到同步行为。如果有任何交错执行的情况，我们就会遇到麻烦。

因为我们不希望某个线程执行P操作后开始睡觉，另一个线程执行V操作，结果让信号量从零递增到1，而原本在睡眠中的线程未被唤醒。

好的，这会是一个具有原子性的失败，因此我们永远不希望发生这种情况。好的。所以，POSIX通过增加一种读取值的能力，虽然技术上不合法。信号量来自铁路的类比，我之前展示过，这里是一个信号灯系统。我们将初始值设置为2。现在当火车经过时，它们将尝试对该值执行P操作。

它不会降到零以下，这样就没问题了。好的，所以在这里，注意到火车经过，它执行了P操作，或者说下行操作，值降到1，火车通过。第二辆火车，值降到0，火车通过。那么第三辆火车经过时会发生什么？它将进入睡眠状态，因为它将执行P操作，注意到它不能执行，因为这会使值低于零。

因此，我将进入睡眠状态，所以这列火车正在睡觉。这些火车在那边不管是思考还是做其他什么。现在，当火车离开时，它将执行一个V操作，值将增加到1，并唤醒这个线程重新执行它的P操作，注意。

你看到值从1再回到0了吗？所以这就是原子性的基本概念。好的，有问题吗？是的，继续。哦，好的，继续。我在过道这边。好的，问题很好。假设我将初始值设置为2，这意味着只有两个线程能进入吗？好的，不是。

这意味着如果我执行了一系列V操作，我可以将值增加很多，然后一堆P操作可能会接踵而来。所以，实际上初始值更与你打算如何使用这个信号量有关。如果我把V设置为1，那么我得到的是什么？一个锁。因为如果我把它设置为1，

第一个P操作将其设置为0。第二个操作使其进入休眠，第三个、第四个或第五个操作都将进入休眠。当持有锁的线程通过V操作将信号量递增时，其中一个正在休眠的线程会醒来并执行P操作，继续进行。是的。

它如何选择唤醒哪个线程？嗯，这是宇宙中的一个大谜题。未定义。好的，除非你的信号量指定将按FIFO顺序唤醒线程，否则它不会按FIFO顺序唤醒。好的，事实上，它会保证做任何可能破坏你算法的事情。对，这是Cooby的坏调度器，恶意调度器规则编号。

无论我在之前的讲座中给它设置了什么数字。好的。现在有另一个问题。继续。哦，好的。如果我将它设置为1，我基本上得到一个锁。如果我将它设置为0，我会得到什么？是的。是的，你会得到一个等待其他人的信号。非常好。所以，如果我将它设置为0，第一个到达的人将会得到一个可以唤醒其他人的信号。

如果我将它设置为二呢？好吧，你可以看到，我们可以开始对事物的数量施加约束。好的。我希望你们都在提前思考。显然，这和可口可乐自动售货机有关系，对吧？你可以想象我们对可口可乐罐的数量和空槽的数量有约束。好的。那么，如果我们现在回到这个问题。我们再次使用信号量中的互斥性。

这通常被称为二进制信号量或互斥量。好的。这为我们提供了类似锁的东西，因为我们将一个信号量P操作和一个信号量V操作配对作为调度约束。好的，在这里我们允许一个线程等待来自线程2的信号，那就是将其设置为0。这是执行线程连接的一种方式，所以如果你请求连接。

你在一个初始化为0的信号量上执行操作，而你等待的线程执行V操作，现在你们两个都可以继续前进。现在，让我们回顾一下有界缓冲区，因此我们可以实践约束条件，约束是三重的。首先，消费者必须等待，直到缓冲区满，缓冲区只有一个对吧，进入。然后，如果缓冲区完全为空，消费者需要休眠。

生产者必须等待，直到有空槽。如果有界缓冲区完全满了，生产者必须休眠。而我们最初引入这一切的原因，我们仍然需要对队列操作进行原子性处理。所以我们要确保多个线程不会同时操作队列并破坏它。

所以这实际上让我们想到了需要三个信号量来实现一个正确的有界缓冲区。好的，一个用于满槽条件，一个用于空槽条件，另一个则充当锁，以确保队列本身不会出问题。好的。那么为什么我们需要互斥呢？因为计算机基本上很愚蠢，不能自己解决问题。当然，在现实生活中，送货员可能会在机器前看到有学生睡着，然后意识到他们可能想买一件外套之类的。

所以，关于信号量的一般规则是，每个约束条件使用一个独立的信号量。在这里我们有满缓冲区、空缓冲区和互斥锁约束，我们有三个缓冲区。因此，有界缓冲区的完整解决方案是这样的：信号量满槽，我们初始化为零，表示没有可乐；空槽我们设置为缓冲区大小，互斥锁设置为1，所以这个互斥锁将充当我们的锁。

另外两个将作为消费者和生产者的约束条件。好的，现在，让我们看看我们的生产者是什么样的。它在空槽上使用了一个信号量，基本上就是在说，如果空槽数为零，那么我们需要让生产者休眠。注意他们在获取队列的互斥锁之前就做了这个检查。好的，所以我们首先检查。

那么可乐放在哪里呢？或者我们实际上在队列上进行任何操作吗？大家明白了吗？然后，假设这有效，那么我们不会在这里休眠，或者我们会被唤醒，二者其一。然后我们获取互斥锁并把可乐放入，释放互斥锁。然后，作为结束操作，我们增加满槽的数量，因为我们放入了一罐可乐。

消费者实际上就像这个的镜像对吧？所以消费者首先检查并设置，看看满槽是否为空。如果满槽数为零，那么机器里没有可乐。但如果不为零，我就能进入。我获取互斥锁，进行出队操作，释放互斥锁，然后作为结束操作，通过增加空槽数量来告诉生产者可能需要更多。好的。

所以，实际上，互斥锁给了这些红色的关键部分，以确保多个线程不会搞乱队列。好的，其他部分，满槽的信号量是在通知消费者机器里有新的可乐，空槽则是在通知生产者有空位可以放可乐。问题？是的。

好问题，那么问题是，如果有两个生产者，其中一个填满了整个机器会怎样？如果你看这个，这不是代码的写法，这段代码是生产者需要对每个项进行处理。

那么两位生产者会发生什么呢？他们每个人都有一瓶可乐，试图把它放入机器中。只有当那个信号量至少为2时，他们两个才有可能都通过这个信号量。两个人都将其减到零，他们每个人都抓住了一个插槽。现在不管他们获取锁的顺序如何，一个先获得锁，把可乐放进机器，另一个接着获得锁。

就像他们的可乐机器一样，退出时，他们都会把满的插槽数增加一。因为这些是原子操作，所以这些增量操作不会出错。没有交错操作。所以无论是其中一个先执行V操作，另一个后执行，还是反过来都没关系。但当我们完成时，满的插槽数已经增加了两个。而且，除此之外。

如果有两个学生正好在睡觉，他们都会被唤醒，因为第一次V操作将信号量从零变为一，唤醒第一个学生。接下来的V操作唤醒第二个学生。好的，是的。所以因为我们有双向的约束，不能低于零，也不能高于最大值，我们需要信号量，因为信号量是单向的。对吧，它们只能从零开始往上计数。所以实际上一个信号量在计数可乐罐的数量，从零开始往上计数，而另一个信号量则计数满的插槽数，从零或者空插槽数从零到最大值。

所以我们需要信号量来做约束。好吧，多少人认为这是个很酷的解决方案？好的，没关系，我们不会评价你的酷或不酷。多少人觉得这可能有点复杂？好的，可能它并不算非常复杂，因为我刚才已经给你描述过了，但想象一下，这段代码已经存在了。

你知道，五年后，你现在回头看，得弄明白信号量约束的问题。它很强大，统一的。抱歉，统一的解决方案可以用于各种同步，这就是信号量在Unix中受欢迎的原因。因为你可以用它们来做锁，也可以用它们来做约束。

我不认为你可以用它们来解决整个问题，但你知道，基本上，你可以。你可以用它们进行各种同步，所以它们非常强大。因此，想要实现一个同步原语的人可能会实现信号量。至少在最初的思维方式下，因为你可以用它们做很多事情。

![](img/1641ab5f908ca769eaeff2b6ac73408a_8.png)

但我们来看一下这一点。那么为什么这里会有不对称性呢？因为生产者对空缓冲区执行了一些P操作，对满缓冲区执行了相应的操作，而消费者则做相反的。其实这就是因为生产者生产，消费者消费，我们正在做这两者的相反操作，所以也许这并不让人太惊讶。

有意思的是，P 操作的顺序在这里重要吗？如果我们像这样交换生产者的操作，会发生什么呢？是的，很糟糕。好的，我们不要这样做。医生，啊，我交换了信号量的 P 操作，别那样做。因为这样做会导致与我们进入信号量之前一样的锁定问题，正因为你锁住了它。

你锁住队列。然后你检查条件，进入睡眠状态，现在你已经获得了队列的锁，没人能更改队列，所以这种方式就是不好的。如果我交换 V 操作，会发生什么呢？是的，它仍然能工作。它可能会改变调度效率，因为它可能会唤醒一个线程而不是另一个，但实际上并不会导致死锁。好的，因为我们所做的只是递增操作。

你知道，交换递增操作并不会带来太多麻烦。那么，如果我们有两个生产者和两个消费者，或者五个生产者和一百个消费者，代码是否能正常工作呢？是的，好的，这段代码在有多个生产者和多个消费者的情况下能够正常工作。好的，信号量很好，但接下来我们要讲的监视器更好。

信号量是一个巨大的进步。试想一下，仅仅通过加载和存储来实现有界缓冲区。记得我们之前的《牛奶讲座》吗？几节课前的事情。想象一下，尝试用《牛奶讲座》中的解决方案三来实现有界缓冲区。好的，这将完全无法工作，这样做简直是邪恶的，可能是我们在考试中给出的一个题目。

不，我在开玩笑。我们不会那样对待你。所以这里的问题实际上是信号量具有双重用途。它们实际上既用于互斥锁（mutex）或锁定，也用于调度约束，具体取决于你初始化它们的方式以及你如何使用它们，结果也就不同。

现在很好，因为你坐在那里看着代码，我一直在给你解释。但是，再一次，如果你五年后再看你的代码，你就得重新提取出它的含义。对吧？从长期可读性的角度来看，这种方式可能不是很好。好吧。所以一个更干净的想法是回到用于互斥的锁，因为那是锁的作用。

让我们选择其他东西来进行调度约束，那就是条件变量。关键是，监视器是一种编程范式，它有一个锁和零个或多个（通常是一个或多个）条件变量。好的，这就是我们要用来编程的东西，一些语言，如 Java，实际上原生支持这个功能。大多数其他语言则是将锁和条件变量一起使用。

它们实际上给你提供了监视器的概念，但它们都基于相同的编程思路。如果我们在讲座的最后提到这个问题，我实际上会给你们展示监视器在某些语言中的实现，并给你一些代码示例。

好的。但我首先想做的是，我们先谈谈一些背景知识。希望这不会让你们感到太惊讶。然后我们将在星期四，也就是两天后，宣布应该进入哪个房间，因为有两个房间，三个房间的选择。我们需要确保一切顺利进行。

并且有两个房间和其他几个房间。好的。如果你生病了，告诉我们。不要带病参加考试。如果你有COVID阳性检测结果，好的，请不要硬来。好的，和我们说一声。我今天不会在办公室办公，但星期四上课时间我会在办公室进行办公，明天正常的办公时间是1点。好的，过来找我。除了今天早上以外，我都会在。

我也一直在尽力回答Piazza上的讲座问题。所以，那里还有一个提问的渠道。好的，那么，让我们问自己一个问题，什么是条件变量？好的，那么，我们怎么改变，例如，消费者例程，直到队列中有东西为止。

我们已经向你展示了如何通过使用信号量来保持事物计数，但这其实很容易出错。所以我们将改用条件变量的概念，这最初看起来有点奇怪。好的，让我告诉你为什么它看起来奇怪。之所以奇怪，是因为你获取锁，检查条件，但如果条件不满足的话。

你和锁一起休息。好吧，有多少人认为这听起来很糟糕？好吧，嗯，没错，听起来确实不好。结果证明其实没关系。只有这一种情况是这样的，这就是条件变量的用途。它们是以一种方式设计的，让你在条件不满足的情况下与锁一起休息。好的，而在后台，它会处理解锁锁的操作，让其他人能进入。

但是这个范式，我希望能让你们的大脑转变一下思维方式。这是我的工作，顺便说一句。扭曲大脑是我的职责，就是理解这种范式编程的模式，其中你锁定某些事物，检查条件，并且与它们一起“睡觉”。这些操作是一种权重操作，你给它锁。好吧，"wait" 就是让它去休息。但顺便说一句，这是我当前锁定的那个锁。

所以你可以想象为什么这不会导致所有操作都死锁。然后你会看到一个信号，表示叫醒一个等待者。广播信号会唤醒所有等待者。现在，如果你从面向对象的角度来看，你应该这样理解它们。

所以这就是Java为你提供的。如果你在使用C语言和P线程，那么你还会有一个指向条件变量的指针，因为显然这些操作是作用于条件变量上的。好的。在做这些操作时，你始终需要持有锁。持有锁意味着你获取了它。好的，所以带有条件变量的监视器确实需要一个锁。

它提供了互斥机制。在访问共享数据结构之前，你总是需要先获取它。所以你可能会有很多人尝试进入监视器。你可以在程序中有许多条件变量，它们都代表着可以让你休眠的等待队列。所以我们真正做的是，我们正在利用内核能够轻松处理的那些功能，比如有等待队列，可以让你自己进入休眠状态。

我们在用户级别导出了这个功能，这样你作为用户程序员就可以使用它。这也正是为什么这个想法如此酷的原因。与信号量相比，信号量无法在获取锁后让线程进入睡眠状态。记得我们交换P操作时导致了我们的可乐机死锁。天哪，要是凌晨四点时发生死锁，那可真糟糕了。好吧。

使用条件变量后，这种情况不会发生。好吧。接下来，我想给你一个缓冲区的例子。好吧，这是一个无限同步队列，我们可以在这里放入任意数量的元素。我这里只展示了单向的情况。比如，我们有一个锁，那就是缓冲区锁。

我们有一个条件变量和一个队列。现在，这个队列是一个包含链表之类的对象。也许它使用的是你的列表操作。这些天来，这可是个大热点，特别是在笔记本电脑上。所以生产者呢，生产者必须做的事情。基本上，因为这是一个无限队列，我们不需要担心填满它，但我们确保在往队列中放入东西时。

我们不会弄乱队列。如果有任何人在可乐机前面等着，我们会把他们叫醒。好吧，操作过程非常简单。我们首先获取锁。稍等一下，让我拿一下我的魔法激光指示器。我们在这里获取锁，然后，因为我们已经有了锁，我们可以安全地将一个元素加入队列，而不用担心有人会因此出问题。

然后，我们在该条件变量上发出信号，唤醒正在等待队列的某个线程。接着，我们释放锁，一切就绪。接下来，我们来看看生产者在这个单向队列中的操作，实际上非常简单。它只需要能够唤醒那些正在睡觉的人。

这里有趣的地方在于消费者，因为消费者在从队列中取出项目时，如果队列中没有数据，它需要进入休眠状态。好吧，因为如果你从一个空队列中进行出队操作，你会得到一个空值，结果很混乱。然后我们让它等待直到有东西出现。所以，这里就是操作模式。

我们像往常一样获取锁。现在我们进入了监视器，然后我们说，如果队列为空，那么就一直等待。因为队列为空对我们来说很糟糕，我们需要等到有东西进来。于是我们在条件变量和锁上进行等待。这里我们使用的是类似C语言的语法。注意我们把这个放在了一个while循环里。如果队列为空，就去睡觉。当你醒来时。

再次检查队列是否为空。如果不再为空，我们通过了 while 循环，执行出队操作。然后释放锁。最后返回该项。因为我们在执行出队操作之前已经检查过队列是否为空。所以我们知道返回的这个项不是空的。看起来很简单。

但这里有一些非常有趣的东西，我想讨论一下。首先。是的，继续。啊。所以，因为只要按照这个规则来。每当你进行等待信号或广播时，你总是处于锁的内部。好的，称它为规则。是的，称它为规则。继续。好的。那么，问题是，当它从条件等待中醒来时。

它是否获得了锁呢？那么，你需要做的是。记住脑部扭曲。好的。你从这段代码中看到什么？我获取了锁，做了一堆事情，最后释放了锁。这就是我看到的代码，是吧？不要想得太复杂。不要想得太深。我获取了锁，释放了锁。好了，我就在这里。这一切都与锁有关。好的。

不要纠结于你等待了，并且你知道，去睡觉，实际上从字面上理解这段代码，你获得了锁。做了很多事情。然后你释放它。然后这种思维方式是非常强大的，认为所有这些都有一个锁的原因是，我可以说当队列为空时。我决定队列不再为空时，我可以下去进行出队操作，并且我知道没有其他线程进入并从我手中取走它，因为我有锁。

我的意思是，看，你看，我在这里获取了锁。我在这里释放了锁。好的。那么我们可以讨论一下如何构建这个。也许你可以滑动，但现在，如果你想一想。我获取了锁，做了所有与锁相关的事情，然后释放了锁。这样就更容易理解代码在做什么了。好的。所以，正是因为这样。

你可以说，如果我在这里检查到条件并发现它不为空，我可以继续进行出队操作，并且我可以绝对确定没有任何人因并发问题而从我手中偷走一个项，因为我有锁。他们必须在做任何事情之前获取锁。因此，在那段小代码中，我是无敌的。是的。所以这是一个无限队列。没问题。

我之前做了双面打印。希望你能看到这里如何轻松实现双面打印。但我想先从一个简单的事情开始。所以这个队列不会溢出，它会一直继续下去。是的。再说一遍。这个问题很好，这是忙等待吗？不是。因为我大部分时间都在睡觉，所以这不是忙等待。

所以我做一个循环，直到有人发送信号。我就一直等着，这样就不会浪费 CPU 周期。实际上这就是在等待一个信号条件。问题很好。问题。是的。非常好。那么，很好。你决定去实现这个，这是非常值得钦佩的事情。那么，如何让它工作呢，对吧？它必须在我等待的条件下才能工作。

监视器条件变量运行时系统，不管那是什么，把我放在一个等待队列里并释放了锁。实际上，它把锁交给了其他人，但自动释放锁。在我醒来并离开等待状态之前，锁会重新获取到我手里。所以就这个代码而言，我始终持有锁。

而我唯一没有持有锁的时候，就是当我在睡觉，且不知情的时候。好问题。是的。是的。为什么我们要有这个死循环？有谁想尝试一下吗？嗯，你可以说生产者，生产者只会被唤醒一次，因为我们发出的是信号而不是广播。好的，你说对了。你走在正确的道路上。

就是跟随别人，谁还能偷走它。对。对。记住我们有多个消费者，可能其中一个在睡觉。但生产者把他们叫醒了。但是另一个消费者在错误的时间冲进来，从队列中抢走了项目。所以我们必须总是检查我们的条件，在决定我们拿到项目之前，双重检查我们的条件。

事实上，这恰好是进入接下来的两张幻灯片的完美开场。条件变量和监视器有两种调度类型。一种叫做Mesa调度，另一种叫做Horror调度。注意我们正在看这个循环，它说的是……

我们不断检查条件，如果条件还不对，就去睡觉。然后当我们从条件中醒来时，我们再检查一次。这显然是你在问问题时想到的。为什么我们不直接说，好吧。如果队列为空，我们就去睡觉。否则……

我们就只是直接掉下去，对吧。这里的问题在于它取决于信号发出时发生了什么。因为你能想象到的最简单的情况，也就是所谓的Mesa调度，是的，你发出信号给某人，然后他们就被放入准备队列，调度器继续执行它的任务。如果其他人先进入队列，那么他们可能会从你下面抢走它。

好吧，但你可以想象，Horror实际上是一个数学家。他提出了另一种看待这个问题的方法，我将在下一张幻灯片中展示给你。所以这个当前的等待死循环是一个简单的例子，叫做Mesa调度，得名于施乐帕克的Mesa操作系统。另一个则以一位英国逻辑学家的名字命名。如果你看看他对监视器的定义……

就是当你发出信号时，你实际上把锁交给了那个正在睡觉的人。然后把他们唤醒，让他们运行，最终他们会回到你这里。通过这种方式，你可以保证如果我发信号给某人，他们会立刻运行并得到我发给他们的信号内容。好的，所以你可以理解为什么这对逻辑学家来说可能很有吸引力，因为它既简洁又干净。

所以，如果我们看一下这个序列，我们有左边的信号发出者或生产者，以及右边的消费者，我们看到的是生产者获取了锁，因为你总是有锁，信号发出给消费者。然后，紧接着发生的事情是该线程将锁和CPU交给了另一个线程。

然后让它运行条件等待，接着会释放。假设中间是我们从队列中取出一个项目。所以我们知道，当我们发出信号时，我们就是那个运行的人。我们是冠军，我们从队列中取出了那个人。然后，当我们在代码中释放时，就是我们说“好吧，这里不再需要原子性，任何人都可以运行”的时刻。

然后，关于马匹调度发生的事情是，我们将锁返回到原来的线程，他可以完成他正在做的事情。所以在第一次授予时，这实际上看起来像是非常好的语义，因为当你向某人发信号时，你发信号的人会得到你要求他们做的事情。

好的，听起来不错。好了，但事实证明，大多数教科书都谈到这一点，大多数操作系统做的是另一种方式，有人能告诉我为什么要做另一种方式吗？是的，你可以给出一个锁，对吧，你只需要说，好，你得到了锁。

而且你知道，关键在于谁在条件等待时出来，因此在内部交出锁并不是一件难事。好，明白了。看得出，你们在座的每个人都开始变得足够复杂，能够开始询问关于开销的问题。

对的。如果我从这个线程切换到这个线程，再切换到这个线程，然后再回到这个线程。我就有了上下文切换，我有缓存缺失，所有这些开销可能完全没有必要，因为我们只是放入一个while循环而已，这其实并不需要。相反，大多数系统做的是，它们只是发出信号，实际上只是唤醒这个线程，并将其放到红队中。

然后它继续进行。这就是Mesa版本。所以信号会一直保持锁在处理器中，等待者会被放到红队队列中，没有特殊优先级。所以，在同样的场景下，信号会把等待线程放入红队队列中。然后我们继续进行，释放并运行一段时间，过一段时间调度器决定让我们休眠并唤醒另一个线程。

然后，这不是一个条件等待，需要重新检查条件，因为自从发信号以来已经过了一段时间。如果一切正常，就完成了。好了。这就是所谓的Mesa调度，实际上你需要在等待后再次检查条件。

好的。是的。嗯，很好的问题。我们担心的是退出while循环时发生上下文切换，结果有人进入并抓住了锁。这就是你的担忧。好，有人想告诉我为什么这种情况不会发生吗？是的。是的。

我们获取锁。好的。记住，我们要把这个当作我们已经获取了锁来思考。所以，只要我们不释放锁，我们就拥有锁。没有线程能够进入这个区域来接触这个队列，因为它们都必须先获取锁。而我们已经拥有锁。这个问题问得很好。你看到了它是怎么运作的吗？

我们获取锁，执行我们的任务，然后释放锁。现在我们可以切换很多线程。你知道，线程xyzq都可以运行，只要它们不试图接触这些内容。但如果它们要接触这些，它们就必须先获取锁，然后会被挂起。是的，当然。所以，因为生产者还没有释放锁。

没有人可以从条件等待中出来。这是因为条件等待首先会重新获取锁，但它会等待直到锁释放。所以，在我尽可能鼓励大家“让大脑转弯”的时候，想一想获取和释放锁以及里面所有的代码，实际上锁在那里，所以没有线程可以进入你的代码。

好的。很好。是的。抱歉，你能再大声一点说吗？所以，你是在问它们能否作为单条指令类型的原子操作来完成吗？它们并不是真正的单条指令，因为它们会让线程休眠等等。所以它们与调度程序有交互。但是你可以知道，你所期望的原子性来自于我们拥有锁的事实。

所以无论条件权重和信号有什么，它们都必须遵循这个规则。这样，如果我从条件权重中出来，我就会再次进行处理，因为我尊重程序员认为在这里存在锁的概念。好的。没问题。一旦你理解了这一点，一旦你把脑袋绕过来，这将是极其强大的。

好的，我将展示读者写者模型。好了，顺便说一下，大多数真实的操作系统都会这么做，因为直接通过信号通知某人并让他们从等待队列中移除，然后将其放入准备队列，比起通过锁之类的操作要简单得多。

那么，这里有其他问题吗？我们是否开始理解了？有点奇怪，是吧？后面有问题吗？不，只是在伸展一下。好的，抱歉。那么，这是环形缓冲区的第三版。它与我们之前做的类似，但你会注意到它有一些不同。我们获取锁。现在我们说，只要缓冲区满了，就等待。

我们将一直循环。但这不是忙碌等待，因为我们会去睡觉。我们唯一会被唤醒的方式是通过某个信号通知。好了。然后，一旦我们醒来，缓冲区就不再满了，因为我们已经获取了锁。我们继续将项放入队列。我们给消费者发送信号，然后释放锁，消费者就会获取锁并继续执行。

好吧，好吧，缓冲区是空的。休眠，等待，对吧，去休眠。当我们从中出来时，顺便提一下，我注意到我这里漏了一个地址。抱歉。我们出队一个项目。我们发信号给生产者让它醒来。我们释放缓冲区锁。我们返回。所以现在我有一个双向缓冲区，我们做得非常复杂，是一个非常复杂的过程。

信号量的东西，现在我通过监视器非常简单地实现，因为这个条件可以复杂到我喜欢的程度。好的，实际上它所说的就是，在我无法继续的情况下，去休眠。信号者会在我可以继续时发信号给我，我可以再次检查这个条件并继续。是的。所以，如果我们执行条件等待，完全有可能另一个消费者会进入那里。

是的。如果你想一想，但实际上，永远不会有这种情况：我们从条件等待中出来并开始运行，这时其他线程能够进入。唯一可能发生重排序的时刻是当我们休眠时。好的，明白了。当我一旦去休眠，我就不再持有锁，因为我在休眠。所以生产者完全可以进入。没问题。

只是有多个消费者在周围漂浮，哪些消费者能够得到生产者的项目是未定义的。既包括那些休眠的，也包括那些仍然在运行的。这种情况是没有固定顺序的。好的，大家准备好做一些更强大、更复杂的事情了吗？

我们也许可以，反正我们有15分钟，对吧？所以，继续吧。没有保证。如果你想的话。如果你必须得到一个特殊的实现来告诉你，但那也没用，因为可能还有其他没有休眠的消费者对吧？所以他们随时可能进来。所以即使是……

即使条件变量完全遵循先进先出（FIFO）顺序，你也不能完全确定是否会有一个明确的顺序。而在考试中，如果顺序可能很重要，我们会告诉你假设哪种顺序。但是，原则上，你可以创建一个先进先出的等待变量。尽管这样做对其他那些在休眠的消费者来说并没有帮助。

但是如果你需要知道，我们会告诉你。好的，另外，你必须查看规格说明。规格说明没有说权重变量上有任何特殊的顺序，假设权重没有顺序。好的，明白了。现在让我们再看看为什么是while循环，Mesa语义。大多数操作系统遵循Mesa语义，当你发出信号时，它只是把线程放入就绪队列。

它可能不需要立即获取锁，但你知道当代码从条件等待中出来并运行在用户代码中时，锁已经被获取。好的。那么这是忙等吗？不是的，因为我们在休眠，我们只是……你知道。

当我们醒来并检查一个条件时，那是实际的计算，对我们是有帮助的。然后我们会等待。好了，让我们来看看读者写者问题。这里的动机是一个共享数据库。两类用户：读者和写者，读者永远不修改数据库，而写者会修改。它们都可以读取和修改数据库。因此，我们需要确保，当一个写者正在写入数据库时。

因为写者要做一些奇怪的事情，可能会修改很多不一致的内容，直到它释放锁并表示完成。所以我们绝不能让读者在写者写入时查看数据库。而且，在最简单的情况下，我们甚至不希望两个写者同时进行。

好的，实际上，我们可以有多个读者同时存在，也可以有一个写者，但读者和写者绝不能同时存在。除非在数据库中，且在不同的时间。我们明白了吗？所以这将是我们要尝试做的事情。记住，这就像是一个快速的记忆法。这里是我们典型的监视器程序结构。首先，你获取一个锁。

你检查并查看你的条件是否满足。如果不满足，你就等待，并可能会再次检查。当你准备好时，你解锁。现在，在这个循环中，我做了“预定”我需要的东西。好了，然后我可以继续做其他事情，因为我已经预定好了，或者在上面检查了条件。

然后，当我完成时，我会锁定，可能会发送信号给某人，并解锁。所以这将是我们的一种模式。好了，如果你考虑一下，在队列的情况下，我所说的“预定”是什么意思。我在这里检查，可能会给你一个项目。在我释放锁之前。

但是现在，我已经拥有了这个项目，我可以对其进行任何操作，因为它是我的了。好了，数据库将是我们在这里操作的内容。所以我们将检查读者和写者的条件，然后再进行数据库操作。假设我们现在只有读者或者一个写者。完成后我们就可以结束。

我们会进行一些信号传递，以防有人需要醒来。好了，这将是我们基本的模式。它一开始看起来可能很复杂，但我将展示给你看的有趣之处在于，A，它其实并没有那么复杂，B，它会向你展示，你可以用监视器做比你想象的更多事情，远超过信号量能做到的。

好的，因为你可以像我即将展示的那样使用监视器做一些事情，但我会把如何使用信号量来做这个作为练习留给读者。好了，那么我们正确地处理了这个约束条件。读者可以在没有写者的情况下访问数据库，写者可以在没有读者或其他写者的情况下访问数据库，因为我们只希望在任何时刻只有一个写者。并且，只有一个线程可以操作这些用于追踪当前世界状态的变量，我们将通过我们的监视器锁来实现这一点。

所以基本的结构是这样的：一个读者会等待，直到没有写者，然后访问数据库，并且唤醒一个等待的写者（如果有的话）。好的，然后一个写者会等待，直到没有读者或写者，然后他们访问数据库，最后他们会检查：我完成了，是否有等待的写者或读者需要我唤醒？如果有，他们会在那个时刻唤醒他们。

好的，我们将通过一些状态变量来实现这一点。好的，这真令人兴奋。所以我们有四个状态变量和两个条件变量。好的。状态变量是四个整数。它们分别是活跃读者的数量（AR），等待读者的数量（WR），以及活跃写者的数量。

W和等待写者的数量W。那什么是活跃读者呢？活跃读者是指已经通过了入口代码，现在正在从数据库中读取，进行搜索，或者作为读者正在做任何事情的人。等待读者是指那些实际上正在等待读取条件变量的读者，因为某些东西阻止他们前进，比如有写者正在写。好的，因此A和W之间的区别在于，活跃读者正在访问数据库。

等待读者正在等待访问数据库，活跃写者正在访问数据库，等待写者也在等待。有人能立刻告诉我，W的最大值是多少吗？是1，对吧？很好。好的，为什么是1？因为我们每次只想有一个写者。好的，如果W是1，你能告诉我AR是多少吗？是0，对吧？好的。

你可以开始看到我们这里的约束是如何适用的。好吧。如果你看一下，这就是一个读者的样子，读者首先将自己检查到监视器中，这样他们就获得了锁。然后他们执行这个`while`循环。注意这里说的内容：只要有一个活跃的写者或者一个等待的写者，我就会加在一起，得到大于零的值。我不能执行，因此我增加等待的读者数量，并且我会等待。

然后当我退出等待时，我不再处于等待状态，因此我会减少等待的读者数量，并再次检查我的条件。我会继续循环，直到我确定活跃写者和等待写者的数量都是零，因为它们加在一起是零。

只有在这时，我才会退出这个`while`循环。此时我成为一个活跃读者，所以我将其增加1。我释放锁。然后，我不做其他的。我开始读取数据库。所以，我能读取的唯一方式是，如果我已经确保系统中没有写者，无论是等待的还是活跃的写者。我已经增加了AR，表示我是一个活跃的读者，这样就不会有写者突然出现来打扰我。

然后我可以访问数据库，完成后。我会再次获取锁来退出系统。我减少活动读者的数量，因为我不再是一个活动读者。然后我说，嘿。如果没有活动的读者，恰好有一个等待的写入者。

继续并通知一个写入者醒来，因为现在没有活动的读者，通知它并释放锁。好的，注意到我从不查看那些整数。A R W R A W W，除非我已经获得锁。我在一个临界区。所以当我查看那些变量时，我知道没有人会闯进来并搞乱它们。

我可以直接查看它们。好的，顺便说一下，为什么我这里做了 W R 加一操作。你们现在都是加一操作的大粉丝吧，对吧？但那实际上是读取并加一存储，也就是三个指令。好的，所以如果没有锁，那将非常糟糕，因为那不是一个原子操作，不同的线程可能会把我搞砸，记得我们三节课前就是这么开始的吗？

好的，所以注意到每次我查看这些变量时，我现在已经获得了锁。为什么要在这里释放锁呢？那是为了让其他线程可以进入临界区并自我分类。而我必须通过释放锁来做到这一点。好的，现在是写入者的代码，我获取锁。然后我说，只要有活动的写入者或活动的读者。

我作为一个等待的写入者进入休眠。当我醒来时，我减少等待的写入者数。我退出这个条件，现在变成了一个活动的写入者。释放锁。现在我正在写入数据库。我确定如果我要读取，里面就没有写入者，或者没有读者会给我制造麻烦。好的，现在我完成后，通过获取锁来退出系统，我不再是一个活动的写入者。

然后我说，如果有等待的写入者，通知他们醒来。否则，如果有等待的读者。那么我们知道 WR。没有 W，W 意味着没有写入者，可能会有多个读者，所以我广播并唤醒所有人。因为原则上，所有的读者都可以运行。

然后他们都会醒来，如果你想一下发生的事情，在他们醒来后。一个接一个地，它们的条件等待获得锁，醒来并发现没有写入者，进行加一操作并开始运行。然后释放锁，下一个继续，依此类推，如果有 20 个读者正在休眠。

它们会接二连三地响起来“嗡嗡嗡嗡嗡嗡嗡嗡嗡嗡嗡”。然后我们会有 20 个读者在数据库中。是的，问题。好的，接下来。其实有很多情况，你可以唤醒它们，因为你总是检查条件。所以稍等，我们想做的是，确保如果有写入者，我们可以唤醒他们。

好吧，你会发现，如果你仔细查看这段代码，它偏向写者而非读者。好吧，这背后的想法是：写入操作意味着保持数据库的最新状态，所以我们确保写者能够继续执行。

是的。没有，写者休眠时会收到信号。如果你看写者的状态。

![](img/1641ab5f908ca769eaeff2b6ac73408a_10.png)

如果写者决定与某个读者发生冲突，它会进入休眠状态，不再看任何事情。所以它在“可以写入”的条件变量上休眠，什么也不做，除非有人给它发送信号，否则它永远不会醒来，只会一直待在那里。所以实际上，如果我们有一个写者在条件等待上休眠的话。

它们被唤醒的方式就是这里，它们会收到唤醒信号，或者这里它们会收到信号。

![](img/1641ab5f908ca769eaeff2b6ac73408a_12.png)

好的。现在让我简单演示一下，以便你们可以看到。我们的顺序是：一个读者，一个读者，一个写者，一个读者。最初，当然，一切从`a=0`、`w=0`开始。如果你看一下，我们的`r1`来了，房间获得了锁。

所以我们知道没有其他线程在干扰这些变量，问题是：`a_w + w_w`是否大于零？对吧，只要看这些变量就知道它们不大于零。所以我们增加了`a_r++`，你看它变成了1，然后释放了锁。现在我们释放锁是为了让其他线程进来。

让自己有机会进行分类，并在需要时根据正确的提示进入休眠状态。好了，现在我们正在访问数据库。与此同时，稍后回来，我们获取了另一个线程，`r2`来了，获取了锁。检查时，仍然没有写者，增加了计数器，释放了锁并访问数据库。所以现在数据库里有两个读者。

这没问题。好吧，类似地。现在，读者们正在忙于长时间的操作。`w1`过来了，它获得了锁。现在`a_w + a_r`是否大于零？是的，因为有正在活跃的读者。对吧。所以，作为写者，我们不能与活跃的读者冲突。所以，我们进入休眠状态。

注意我们如何增加了`w_w`，因为我们现在正在等待写者。好吧。与此同时，`r3`过来了。请注意，这时我们的策略开始发挥作用，因为`r3`进入了。现在问题是，`a_w + w_w`是否大于零？是的。所以第三个读者会被视作在写者之后。我们将让它进入休眠状态。

所以我们给写者一个写入机会，这是一个策略决策。好吧，接下来我们将作为一个等待的读者进入休眠状态。嘿，`r3`不能开始了。所以请注意此时的状态：`r1`和`r2`在读，`w1`和`r3`在休眠。好吧，稍后一点时间。两周后，`r2`完成了，退出了数据库，获取了锁。

减少活跃读者（AR），所以它们现在降到1。然后它检查，活跃读者是否为0？不是。好的。所以我们不能让写者继续前进，因为你知道，我们的朋友（一号）还在阅读。所以我们就退出。与此同时，在前线，一号完成了，做了类似的事情，但现在注意到活跃读者为0。到那个时候。

我们说，没有活跃的读者，也没有等待的写者。所以我们将唤醒W一个。好的，现在我们进入写者代码。在这种情况下，我们唤醒写者代码。然后它减少等待写者的数量。它会再次检查。条件合适时，它将继续进行。然后它增加一个活跃写者。开始了。

我们有一个活跃写者和一个等待读者。然后我们获取锁，完成后。我们减少活跃写者，看看是否还有等待的写者。没有。是否有一个或多个等待的读者？有。所以我们广播。如果当时有12个等待的读者，我们会把它们都唤醒。与此同时，在前线，那个读者（三号）醒了。

所以它们不再等待，检查其条件递减，知道自己在做什么。然后增加数据库中的活跃读者。完成后，它获取锁并释放。此时，我们已经完成了。数据库处于空闲状态，我们已经正确地处理了数据库中的读者写者操作。好的。现在，我看到聊天中的问题。

我想强调的是为什么又是使用while循环。因为看起来我们已经有了锁。为什么还需要重新检查条件？答案是，当我们醒来时，我们可能会在就绪队列中等待一段时间，而其他线程可能会进入并破坏我们的条件。所以我们总是要检查条件。好吧，那么我们在这里就结束。

今天我们谈到的信号量，它们像是具有受限接口的整数。它们在完成任务时非常强大。信号量有两个操作：P操作，等待零并递减，直到不为零；V操作，递增并唤醒一个睡眠中的任务。

你可以初始化任何值，值监视器或锁加上零、一个或多个条件变量。根据我们查看的时机，等待、信号、广播者或选项。监视器实际上代表了程序的逻辑。希望你已经看到了，我们能够做一个非常复杂的事情。相对容易，对吧？

我们在里面有一个非常有趣的政策，关于读者在写者之后才能进入，所有这些在使用监视器时都很容易实现，我挑战你尝试用信号量来实现这个。好了，但试试看在你睡眠不足的时候，也许它能帮助你入睡。

好的，祝你们考试好运。周四没有课，但我会有办公时间。（嗡嗡声）。

![](img/1641ab5f908ca769eaeff2b6ac73408a_14.png)

[观众沉默]。
