![](img/a7353a8fe01a4d4e85be5c8f65818da4_0.png)

# GAMES401-泛动引擎(PeriDyno)物理仿真编程与实践 - P7：插件与功能拓展 🧩

在本节课中，我们将学习PeriDyno框架的插件机制与功能拓展方法。核心目标是理解如何利用这套机制，将各种独立的仿真技术（如流体、刚体、布料等）整合到一个统一的框架中，从而构建复杂的仿真场景。我们将重点探讨C++与蓝图（Blueprint）的协同工作方式、反射机制、回调函数以及插件设计原则。

---

## 概述：从研究到应用的挑战与引擎的价值

从理论创新到实际工程应用是一个漫长的流程。在这个过程中，不同角色（如研究人员、研发工程师、应用设计师）的协作面临诸多挑战：

*   **研究阶段**：以发表论文为主，但代码资产往往缺乏长期维护和规范，导致难以传承和复用。
*   **研发阶段**：需要将研究代码改造为工程可用模块，涉及数据规范、接口兼容性等问题，常需研究人员与工程人员紧密协作。
*   **应用阶段**：在实际场景中测试，面临性能、稳定性、可靠性等挑战。发现问题后，可能又需要回到研究阶段寻求新的理论突破。

整个流程是一个闭环，但不同角色间的协作成本很高。PeriDyno引擎的核心目标之一，就是通过提供统一的框架和工具，降低这种协作成本，让每个角色都能在其擅长的领域深耕，并通过引擎便捷地整合成果。

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_2.png)

## C++与蓝图：代码逻辑与界面逻辑的统一 🧠

PeriDyno解决协作问题的核心思想是**实现C++代码运行逻辑与图形化界面（蓝图）运行逻辑的统一**。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_4.png)

*   **C++逻辑**：对应程序员或研发人员的视角，用于实现核心算法和数据结构。
*   **蓝图逻辑**：对应最终用户或设计师的视角，通过可视化的节点图方式，拖拽和连接各种模块来搭建仿真任务。

这种设计使得非计算机专业的人员也能相对轻松地构建复杂仿真流程，而开发者则能专注于底层算法的实现。蓝图的概念借鉴了现代游戏引擎（如Unreal Engine），它通过组件化和数据流图的方式，让任务流程变得动态和可配置，而非固化在代码中。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_6.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_8.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_10.png)

为了实现这一目标，PeriDyno采用了一种相对轻量级的实现方案，主要依赖两个关键技术：**反射（Reflection）** 和 **宏（Macro）**。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_12.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_14.png)

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_16.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_18.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_20.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_22.png)

## 反射机制：实现动态类型识别的基石 🔍

![](img/a7353a8fe01a4d4e85be5c8f65818da4_24.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_26.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_27.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_29.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_30.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_31.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_33.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_34.png)

反射是指程序在运行时能够检测、查询甚至修改自身状态的能力。在PeriDyno中，反射主要用于：
1.  **动态创建对象**：通过类名字符串，在运行时创建对应的C++类实例。
2.  **自动生成UI**：识别类的成员变量（属性），并自动在界面中生成对应的编辑器控件（如滑块、输入框）。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_36.png)

由于C++是编译型语言，本身不支持反射，因此PeriDyno需要自行实现这套机制。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_38.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_40.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_42.png)

### 反射的实现原理

![](img/a7353a8fe01a4d4e85be5c8f65818da4_44.png)

PeriDyno中所有需要支持反射的类都继承自一个公共基类 `Object`。反射的核心在 `Object` 类中实现。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_46.png)

**类的注册与管理：**
`Object` 类内部维护了一个全局的映射表（例如 `std::map<std::string, ClassInfo*>`），用于存储所有已注册类的信息（类名、构造函数等）。当一个新的派生类被定义时，需要通过特定的宏将其信息注册到这个全局表中。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_48.png)

**关键宏定义：**
对于一个需要反射的类，通常需要在头文件和实现文件中使用宏。

*   **声明（在头文件中）**:
    ```cpp
    PERIDYNO_DECLARE_CLASS(YourClassName)
    ```
*   **实现（在源文件中）**:
    ```cpp
    PERIDYNO_IMPLEMENT_CLASS(YourClassName, “YourClassName”, ParentClassName)
    ```
    这个宏会创建一个静态的 `ClassInfo` 对象，并在程序启动前（进入main函数之前）自动执行注册逻辑，将类名和其构造函数指针存入全局映射表。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_50.png)

**成员变量的反射：**
对于需要在UI中暴露和控制的成员变量（称为 `Field`），同样使用宏来声明。
```cpp
DEFINE_VAR(YourType, YourVarName, “FieldDisplayName”);
```
这样，框架就能识别这个变量，并在UI中为其生成相应的控制部件。

通过这套机制，当用户在蓝图界面中输入“Cube”或点击创建Cube节点的按钮时，底层框架就能通过字符串“Cube”找到对应的类信息，调用其构造函数动态创建对象，并自动生成带有“边长”、“分段数”等属性控件的UI节点。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_52.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_54.png)

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_56.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_58.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_59.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_61.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_63.png)

## 节点、场景与数据流：静态结构的对应 🧱

在PeriDyno中，仿真场景由**节点（Node）** 构成，节点之间通过**数据连接**形成有向无环图（DAG），即场景图。

*   **节点**：对应蓝图中的一个图形模块。每个节点内部包含：
    *   **控制变量（Control Fields）**：用户可通过UI调整的参数（如立方体的边长、发射器的位置）。
    *   **状态变量（State Fields）**：描述节点内部状态的最小数据集（如粒子的位置、速度）。
    *   **输入/输出端口**：用于与其他节点交换数据。
*   **场景**：是多个节点及其连接关系的集合，对应一个完整的仿真任务。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_65.png)

**C++代码与蓝图的对应关系：**
一段创建流体仿真场景的C++代码，其逻辑与在蓝图界面中拖拽节点并连线的操作完全对应。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_67.png)

例如，创建发射器、连接流体求解器、设置边界的C++调用：
```cpp
auto emitter = scene->createNode<FluidEmitter>();
auto solver = scene->createNode<FluidSolver>();
auto boundary = scene->createNode<VolumeBoundary>();

![](img/a7353a8fe01a4d4e85be5c8f65818da4_69.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_71.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_73.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_75.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_77.png)

// 连接操作对应蓝图中的连线
emitter->connect(solver); // 将发射器的粒子数据输出到求解器
solver->connect(boundary->inFluid()); // 将求解后的流体数据连接到边界节点的流体输入端口
```
这段代码构建的静态数据流图，与在UI中看到的节点连接图是完全一致的。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_79.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_81.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_83.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_85.png)

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_87.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_89.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_91.png)

## 回调函数：处理动态事件与交互 🔄

![](img/a7353a8fe01a4d4e85be5c8f65818da4_93.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_95.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_97.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_99.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_100.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_101.png)

仿真不仅是静态场景，更是动态的时间序列。PeriDyno通过**回调函数（Callback）** 机制来处理运行时的动态事件和交互。

核心的动态操作包括：
*   **重置（Reset）**：将所有状态变量恢复初始值。
*   **更新（Update）**：执行一个时间步的计算。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_103.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_105.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_107.png)

对于更细粒度的、由特定事件触发的操作（如某个参数被修改后，只需更新局部数据），则使用回调函数。回调函数允许将一个函数对象“注入”到某个 `Field` 中，当该 `Field` 的值发生变化或被访问时，自动触发该函数。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_109.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_111.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_113.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_115.png)

**回调函数的应用实例：**
1.  **自动控制可见性**：当一个网格生成器的输入端口连接上数据时，自动隐藏前一个节点的渲染模块，避免视觉遮挡。
2.  **参数归一化**：在SPH权重函数参数改变时，自动触发回调函数重新计算归一化因子，确保权重和为1。
3.  **UI同步**：当用户在3D视图中拖动物体的操纵器（Gizmo）时，通过回调函数同步更新属性面板中的坐标值，反之亦然。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_117.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_119.png)

回调函数有两种主要形式：
*   **成员函数回调**：绑定某个类的成员函数。
*   **Lambda表达式回调**：更灵活，可以直接捕获上下文变量。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_121.png)

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_123.png)

## 插件系统与设计原则：构建可扩展的生态 📦

![](img/a7353a8fe01a4d4e85be5c8f65818da4_125.png)

为了管理日益增长的代码库并支持协同开发，PeriDyno采用了**插件（Plugin）** 系统。其核心思想是将一个复杂系统拆分为框架核心和多个独立的功能模块（DLL动态库或静态库）。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_127.png)

### 插件机制
*   **框架端**：提供插件管理器，负责加载、管理和调用各个插件。
*   **插件端**：每个插件是一个独立的库，需要实现一个特定的入口类（如 `PluginEntry`），并在其中注册该插件提供的所有节点、模块等。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_129.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_131.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_133.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_134.png)

### 面向贡献者的设计原则
为了保持代码的可维护性和可扩展性，在为PeriDyno贡献代码时，应遵循一些软件设计原则：
1.  **单一职责原则**：一个类只负责一项明确的功能。
2.  **开闭原则**：对扩展开放，对修改关闭。通过继承和组合来扩展功能，而非直接修改原有类。
3.  **接口隔离原则**：节点或模块的输入/输出接口应尽可能精简，只暴露必要的部分。
4.  **里氏替换原则**：子类对象应该能够替换其父类对象，而不影响程序正确性。例如，一个需要三角网格输入的节点，也应该能接受其子类（如四边形网格）的输入。
5.  **合成复用原则**：优先使用对象组合（has-a），而非类继承（is-a）来复用功能。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_136.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_137.png)

遵循这些原则有助于降低代码耦合度，使插件系统更健壮，便于多人协作和长期维护。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_139.png)

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_141.png)

## 实战演示：从实体建模到多物理场耦合 🎬

![](img/a7353a8fe01a4d4e85be5c8f65818da4_143.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_145.png)

本节将通过一个综合案例，展示如何利用PeriDyno的插件机制，将实体建模、流体仿真、布料仿真等多个模块串联起来，构建一个复杂的耦合场景。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_147.png)

**步骤概述：**
1.  **实体建模**：使用基础几何体（立方体、球体）和SDF（有向距离场）布尔运算（融合、相交等），构建一个自定义的复杂实体模型。
2.  **流体耦合**：
    *   创建流体发射器和求解器。
    *   将生成的实体模型作为“体积边界”输入到流体仿真中。
    *   运行仿真，观察流体与自定义实体边界的交互效果。
3.  **布料耦合**：
    *   移除流体节点，创建一个布料求解器和一个平面网格。
    *   将同一实体模型作为“三角网格边界”输入到布料仿真中。
    *   运行仿真，观察布料与障碍物碰撞和形变的过程。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_149.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_151.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_153.png)

这个案例清晰地展示了如何将不同插件（建模、流体、布料）中的节点像搭积木一样组合，快速搭建出多物理场耦合的仿真应用。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_155.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_157.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_159.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_160.png)

**动态插件加载**：
PeriDyno支持动态插件加载。开发者可以将编译好的算法模块（DLL文件）放入指定插件目录，主程序启动时会自动扫描并加载这些插件，使其功能（如新的节点类型、工具栏按钮）即时可用，极大地增强了框架的扩展性。

---

![](img/a7353a8fe01a4d4e85be5c8f65818da4_162.png)

## 总结与作业 📚

![](img/a7353a8fe01a4d4e85be5c8f65818da4_164.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_166.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_168.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_170.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_172.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_174.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_176.png)

本节课我们一起深入学习了PeriDyno框架的插件与功能拓展机制。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_178.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_180.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_182.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_184.png)

*   **核心思想**：通过**C++与蓝图统一**、**反射**和**回调函数**，降低从研究到应用全流程的协作成本。
*   **关键技术**：理解了反射如何实现动态对象创建和UI自动生成；掌握了回调函数如何处理运行时事件。
*   **系统架构**：熟悉了基于插件的可扩展架构，以及面向协同开发的设计原则。
*   **综合应用**：通过实战案例，看到了如何将独立模块整合为复杂的多物理场仿真场景。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_186.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_188.png)

![](img/a7353a8fe01a4d4e85be5c8f65818da4_190.png)

**课后作业（建议）**：
尝试将你自己实现的一个算法模块（或选择一个现有模块进行改造），按照本课所讲的规范进行“插件化”封装。重点练习：
1.  使用正确的宏定义暴露必要的类和成员变量。
2.  为模块设计合理的输入/输出接口。
3.  尝试添加一个简单的回调函数，用于处理某个参数变更后的特定操作。
4.  将其编译为插件，并成功加载到PeriDyno主程序中，通过蓝图界面调用它。

![](img/a7353a8fe01a4d4e85be5c8f65818da4_192.png)

通过实践，你将更深刻地体会到引擎框架在整合与复用代码方面的强大能力。