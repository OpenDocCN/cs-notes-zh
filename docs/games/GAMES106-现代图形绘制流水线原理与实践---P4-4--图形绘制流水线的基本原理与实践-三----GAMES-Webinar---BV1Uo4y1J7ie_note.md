![](img/586e9be416be3093b03e2d25990a971b_1.png)

![](img/586e9be416be3093b03e2d25990a971b_3.png)

# GAMES106-现代图形绘制流水线原理与实践 - P4：图形绘制流水线的基本原理与实践(三) 🎬

在本节课中，我们将学习 Vulkan 图形 API 中的多线程同步机制、Frame Graph 技术以及移动端常见的优化实践。课程将涵盖同步原语的使用、资源依赖管理以及针对移动设备架构的性能优化策略。

![](img/586e9be416be3093b03e2d25990a971b_5.png)

![](img/586e9be416be3093b03e2d25990a971b_7.png)

![](img/586e9be416be3093b03e2d25990a971b_9.png)

---

## Vulkan 同步原语 🔒

上一节我们介绍了 Vulkan 的绘制对象与内存管理。本节中，我们来看看 Vulkan 中用于协调 CPU 与 GPU 以及 GPU 内部命令执行顺序的同步原语。理解这些同步机制对于编写高效、正确的 Vulkan 程序至关重要。

Vulkan 的多线程框架基本结构如下：在 CPU 端（Host）有若干条命令缓冲区（Command Buffer），每条命令缓冲区是 GPU 命令的堆栈。CPU 通过队列（Queue）将命令缓冲区提交给 GPU 执行。

Vulkan 主要提供了三种同步信号：

1.  **栅栏 (Fence)**
2.  **事件 (Event)**
3.  **信号量 (Semaphore)**

此外，还有用于管理内存资源读写的**屏障 (Barrier)**。

### 1. 栅栏 (Fence)

栅栏是粒度最大的一种同步原语，它用于同步一整条命令缓冲区的执行完成状态。

*   **工作原理**：CPU 将命令缓冲区提交给 GPU 后，GPU 会在该命令缓冲区**全部执行完毕**后，改变对应栅栏的状态。CPU 端可以通过查询（`vkGetFenceStatus`）或等待（`vkWaitForFences`）这个状态来判断命令是否执行完成。
*   **等待方式**：`vkWaitForFences` 会依赖于操作系统的调度，让线程进入休眠，从而节省 CPU 资源。当然，也可以使用类似自旋锁（spin lock）的方式循环查询状态。
*   **类比**：可以近似等价于 OpenGL 中的 `glFinish`，用于保证所有 GPU 调用都已完成。

### 2. 事件 (Event)

![](img/586e9be416be3093b03e2d25990a971b_11.png)

![](img/586e9be416be3093b03e2d25990a971b_13.png)

事件的同步粒度比栅栏更细，它可以标记命令缓冲区中**某个特定操作**的完成。

![](img/586e9be416be3093b03e2d25990a971b_15.png)

![](img/586e9be416be3093b03e2d25990a971b_17.png)

![](img/586e9be416be3093b03e2d25990a971b_19.png)

![](img/586e9be416be3093b03e2d25990a971b_21.png)

![](img/586e9be416be3093b03e2d25990a971b_22.png)

*   **工作原理**：可以在一条命令的结束时设置事件状态（例如，标记为“已完成”）。**CPU 和 GPU 都可以设置事件**，但**只有 GPU 的命令可以等待事件**。CPU 只能查询事件状态，不能像等待栅栏那样阻塞等待。
*   **应用场景**：常用于构建命令之间的依赖关系，类似于拓扑排序。例如，后处理 Pass 需要等待几何渲染 Pass 完成，就可以通过事件来通知。
*   **额外用途**：可用于手动实现 GPU 性能分析。通过创建事件并在不同操作点设置，然后由一个线程查询事件完成时间，可以记录每个 GPU 操作的耗时。

### 3. 信号量 (Semaphore)

![](img/586e9be416be3093b03e2d25990a971b_24.png)

信号量主要用于**GPU 端不同队列（Queue）之间**或**同一队列内命令缓冲区之间**的同步。

![](img/586e9be416be3093b03e2d25990a971b_26.png)

![](img/586e9be416be3093b03e2d25990a971b_28.png)

![](img/586e9be416be3093b03e2d25990a971b_30.png)

![](img/586e9be416be3093b03e2d25990a971b_32.png)

*   **工作原理**：它表示一条命令缓冲区需要等待另一条命令缓冲区执行完成后，才能在 GPU 上开始执行。**CPU 端不能直接设置或等待信号量**，它是纯粹给 GPU 内部使用的同步机制。
*   **与事件的区别**：信号量同步的粒度是整条命令缓冲区，而事件可以同步到缓冲区内的某个具体操作。

![](img/586e9be416be3093b03e2d25990a971b_34.png)

![](img/586e9be416be3093b03e2d25990a971b_36.png)

### 4. 屏障 (Barrier)

![](img/586e9be416be3093b03e2d25990a971b_38.png)

屏障与其他原语不同，它主要用于管理**内存资源的读写顺序和一致性**，解决资源竞争问题。

*   **类型**：分为全局内存屏障（Memory Barrier）、缓冲区屏障（Buffer Barrier）和图像屏障（Image Barrier）。
*   **作用**：确保在屏障之前的所有命令对资源的读写操作完成后，屏障之后的命令才能访问该资源。例如，防止一个 Pass 在读某个纹理时，另一个 Pass 同时在写这个纹理。
*   **使用思路**：在实际开发中，可以简化理解为：**当资源的使用方式发生改变时（例如，从“渲染目标”变为“着色器只读资源”），就需要插入一个屏障**。虽然底层实现更复杂，但遵循这个原则通常可以保证正确性。

![](img/586e9be416be3093b03e2d25990a971b_40.png)

![](img/586e9be416be3093b03e2d25990a971b_42.png)

**优化提示**：应尽量减少屏障的使用。频繁改变资源状态（读->写->读）会影响性能。可以通过优化渲染流程，将同类操作（如所有写操作）集中在一起，来减少状态切换。

---

![](img/586e9be416be3093b03e2d25990a971b_44.png)

![](img/586e9be416be3093b03e2d25990a971b_46.png)

![](img/586e9be416be3093b03e2d25990a971b_48.png)

![](img/586e9be416be3093b03e2d25990a971b_50.png)

## Frame Graph 技术 🗺️

了解了基础的同步原语后，我们面临一个问题：在复杂的多 Pass 渲染流程中，如何清晰地管理资源依赖并实现高效的同步？这就引入了 Frame Graph 技术。

Frame Graph 是一种声明式的渲染框架设计，它将一帧内的所有渲染 Pass 及其资源依赖关系描述为一个有向无环图（DAG）。

### 为什么需要 Frame Graph？

1.  **管理复杂依赖**：现代渲染管线包含许多 Pass（如深度预渲染、SSAO、阴影、光照、后处理等），Pass 之间存在着复杂的输入输出依赖。Frame Graph 能清晰地表达这些依赖关系。
2.  **自动同步**：基于依赖图，Frame Graph 可以自动在需要的地方插入正确的同步原语（信号量、事件、屏障），避免手动同步容易出错的问题。
3.  **资源生命周期管理**：Frame Graph 可以识别出哪些资源在某个 Pass 之后就不再使用，从而允许**复用内存**，减少内存分配开销。
4.  **优化与调试**：可以方便地启用/禁用某个特性（如关闭 SSAO），Frame Graph 会自动剔除相关的 Pass 和资源，便于性能分析和调试。

### Frame Graph 示例

一个简单的延迟渲染管线 Frame Graph 可能包含以下节点和边：
*   **蓝色节点**：渲染 Pass（如 `DepthPrePass`, `SSAOPass`, `LightingPass`）。
*   **橙色节点**：资源（如 `DepthBuffer`, `NormalBuffer`, `AlbedoBuffer`）。
*   **边**：表示 Pass 对资源的读写依赖。

![](img/586e9be416be3093b03e2d25990a971b_52.png)

![](img/586e9be416be3093b03e2d25990a971b_54.png)

![](img/586e9be416be3093b03e2d25990a971b_56.png)

通过 Frame Graph 编译（Compile）阶段，系统可以自动计算出最优的 Pass 执行顺序和资源分配策略。

![](img/586e9be416be3093b03e2d25990a971b_58.png)

![](img/586e9be416be3093b03e2d25990a971b_60.png)

### 实践推荐

![](img/586e9be416be3093b03e2d25990a971b_62.png)

![](img/586e9be416be3093b03e2d25990a971b_64.png)

![](img/586e9be416be3093b03e2d25990a971b_66.png)

![](img/586e9be416be3093b03e2d25990a971b_68.png)

对于想深入学习 Frame Graph 实现的同学，推荐研究谷歌的 **Filament** 渲染引擎。它包含了一套清晰且高效的 Frame Graph 实现，其接口通常包含：
*   `addPass`：声明一个渲染 Pass。
*   `setInput` / `setOutput`：声明该 Pass 的输入输出资源，从而构建依赖关系。
*   `execute`：执行编译后的 Graph。

![](img/586e9be416be3093b03e2d25990a971b_70.png)

![](img/586e9be416be3093b03e2d25990a971b_72.png)

![](img/586e9be416be3093b03e2d25990a971b_74.png)

![](img/586e9be416be3093b03e2d25990a971b_76.png)

---

![](img/586e9be416be3093b03e2d25990a971b_78.png)

![](img/586e9be416be3093b03e2d25990a971b_80.png)

![](img/586e9be416be3093b03e2d25990a971b_82.png)

## Vulkan 移动端优化实践 📱

最后，我们探讨一些针对移动端设备的 Vulkan 优化实践。移动端 GPU（通常采用 Tile-Based Rendering 架构）与桌面端 GPU（Immediate Mode Rendering）有显著差异，因此优化策略也不同。

移动端优化的核心矛盾是：**计算能力相对强大，但内存带宽和功耗极其受限**。因此，优化大多围绕节省带宽和减少功耗展开。

以下是来自 ARM、高通等厂商最佳实践文档中的一些关键点：

### 常见优化建议

![](img/586e9be416be3093b03e2d25990a971b_84.png)

![](img/586e9be416be3093b03e2d25990a971b_86.png)

以下是针对移动端 Vulkan 开发的一些具体建议：

*   **使用索引绘制 (Indexed Draw Call)**：即使顶点没有复用，也建议使用 `vkCmdDrawIndexed`。这与直觉相悖，但符合移动端驱动的优化特性。
*   **避免使用 32 位索引**：在满足顶点数量的前提下，使用 16 位索引（`VK_INDEX_TYPE_UINT16`）可以减少带宽消耗。
*   **使用半精度浮点数**：在 Fragment Shader 中，除了计算世界空间位置等需要高精度的数据，应尽量使用 `mediump`（半精度）浮点数。
*   **避免深度预渲染 (PreDepth Pass)**：在移动端，Tile-Based GPU 的 Hidden Surface Removal (HSR) 机制能有效处理 Overdraw，额外的深度预渲染 Pass 反而会增加开销。
*   **避免破坏 Early-Z 的行为**：
    *   **Alpha Blend** 和 **Discard** 操作会禁用 Early-Z 优化，导致 Overdraw 增加。
    *   **优化方案**：对于 Alpha Test 物体（如树叶、草丛），可以将其几何体轮廓提取出来，用实体几何代替 Alpha Blend 的四边形，从而保持 Early-Z 有效。
*   **RenderPass 配置**：尽量使用 `LOAD_OP_CLEAR` 或 `LOAD_OP_DONT_CARE`，避免 `LOAD_OP_LOAD`，以减少内存加载带宽。
*   **避免巨型 Uber Shader**：不要使用通过 Uniform 变量控制大量分支的“全能”着色器。分支会严重影响性能。应该根据特性编译不同的着色器变体。
*   **减少单个着色器的代码量**：过于复杂的着色器会导致编译慢、执行效率低。必要时可考虑将功能拆分到多个 Pass。
*   **减少通用寄存器使用**：例如，将两个 `vec2` 变量打包成一个 `vec4`。
*   **展开短循环**：对于确定次数的短循环，手动展开代码通常比使用循环语句性能更好。

### 案例分析：前向渲染 (Forward) 与延迟渲染 (Deferred) 在移动端的抉择

这是一个经典的性能取舍问题：

![](img/586e9be416be3093b03e2d25990a971b_88.png)

*   **延迟渲染 (Deferred Lighting)**：
    *   **优点**：灯光数量与性能消耗呈线性关系，易于支持大量动态光源。
    *   **缺点**：需要存储 G-Buffer（法线、颜色、深度等），**带宽消耗极大**，在移动端是主要瓶颈。
*   **前向渲染 (Forward Lighting)**：
    *   **优点**：带宽消耗低，更适配 Tile-Based Rendering 架构。
    *   **缺点**：灯光计算在着色器内进行，受限于着色器指令数和寄存器数量，**能支持的光源数量有限**。一个模型有 N 个光源就需要计算 N 次。

#### 混合优化方案

为了在移动端兼顾性能和效果，可以采用一种**混合方案**：

![](img/586e9be416be3093b03e2d25990a971b_90.png)

![](img/586e9be416be3093b03e2d25990a971b_92.png)

![](img/586e9be416be3093b03e2d25990a971b_94.png)

![](img/586e9be416be3093b03e2d25990a971b_96.png)

1.  **分离阴影计算**：将有阴影的灯光和无阴影的灯光**拆分成不同的渲染 Pass**。
    *   `ShadowCasterPass`：专门处理带阴影的灯光（数量需严格限制，如1-3个）。每个这样的灯光可能都需要单独的 Pass。
    *   `ForwardLightingPass`：处理所有不带阴影的灯光。由于没有阴影计算，着色器较轻量，可以支持较多数量（如几十个）。
2.  **性能提升**：通过这种拆分，避免了在着色器中使用 Uniform 分支判断“是否计算阴影”，符合了“避免 Uber Shader”的最佳实践。实测中，这种优化可能带来 **60%-70%** 的性能提升。
3.  **代价**：Draw Call 数量会增加，变为 `Mesh数量 * (1 + 有阴影灯光数量)`。需要权衡 CPU 提交命令的开销和 GPU 着色器的执行效率。

![](img/586e9be416be3093b03e2d25990a971b_98.png)

![](img/586e9be416be3093b03e2d25990a971b_100.png)

**核心思想**：移动端优化没有银弹，必须仔细权衡带宽、计算量和 Draw Call。最可靠的依据是硬件厂商（如 ARM、高通）提供的官方最佳实践文档，并在真实设备上进行测试。

---

![](img/586e9be416be3093b03e2d25990a971b_102.png)

## 总结 📝

![](img/586e9be416be3093b03e2d25990a971b_104.png)

![](img/586e9be416be3093b03e2d25990a971b_106.png)

本节课我们一起学习了 Vulkan 图形管线中三个高级主题：
1.  **同步原语**：掌握了 Fence、Event、Semaphore 和 Barrier 的作用与区别，理解了它们如何协调 CPU 与 GPU 的执行。
2.  **Frame Graph**：了解了这种声明式渲染框架如何通过图结构管理复杂的 Pass 依赖和资源生命周期，实现自动同步与优化。
3.  **移动端优化**：探讨了移动端 GPU 架构的特点，并学习了一系列以节省带宽为核心的最佳实践，特别是通过拆分渲染 Pass 来优化复杂光照场景的具体案例。

![](img/586e9be416be3093b03e2d25990a971b_108.png)

掌握这些知识，将帮助你构建更高效、更健壮的 Vulkan 渲染引擎，尤其是在资源受限的移动平台上。