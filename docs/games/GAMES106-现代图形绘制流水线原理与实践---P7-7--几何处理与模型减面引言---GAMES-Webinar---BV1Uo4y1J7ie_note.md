![](img/34814f6da7589962c0023e80206b3aed_1.png)

![](img/34814f6da7589962c0023e80206b3aed_3.png)

# GAMES106-现代图形绘制流水线原理与实践 - P7：几何处理与模型减面引言 🎯

在本节课中，我们将要学习三维模型的几种主要表示方法，并初步了解模型减面的基本思路和分类。我们将从模型表示的基础概念开始，逐步过渡到模型简化的核心思想。

***

## 模型表示方法

上一节我们介绍了课程的整体安排，本节中我们来看看三维模型在计算机中是如何被表示的。对于三维模型，我们需要用数字化的方式来描述其形状。其中一种非常常见且历史悠久的表示方式是参数化的曲线和曲面。

*   **参数化曲线与曲面**：对于一条二维空间中的曲线，其x和y坐标可以用一个参数`t`来控制。对于一个三维空间中的表面，则可以用两个参数（例如`u`和`v`）来控制。例如，计算机图形学中常见的贝塞尔曲线和曲面就属于此类。这种表示方式在计算机辅助设计领域非常流行。

![](img/34814f6da7589962c0023e80206b3aed_1.png)

*   **网格模型**：另一种常见的表示方式是使用网格。一个连续的表面可以用许多多边形（最常见的是三角形）拼接起来进行逼近。网格模型在渲染时通常需要转换为三角形。我们可以为网格表面贴上纹理或赋予材质颜色以便渲染。

*   **点云**：点云是另一种表示方式，它通过在模型表面上采集一系列离散的点来近似描述形状。三维扫描仪（如激光扫描仪）获取的数据通常就是点云。

*   **隐式距离场**：与点云相关的一种表示是隐式距离场。它在整个空间中定义一个函数，对于任意一点，该函数值表示该点到模型表面的（有符号）距离。距离场便于进行距离查询等操作，但需要额外技术来提取出显式的表面网格。

*   **神经表示**：近年来，使用神经网络来表达模型数据变得非常流行。例如，神经辐射场将一个三维空间点的位置`(x, y, z)`和观察方向`(θ, φ)`作为输入，通过神经网络输出该点的颜色`(RGB)`和密度`(σ)`。这种表示通常与体渲染结合，能从少量输入（如照片）中重建出逼真的多视角模型。

由于本课程更关注渲染，我们将集中讲解最常用的**网格模型**表示方式。

***

## 网格模型详解

上一节我们了解了模型的多种表示法，本节中我们深入探讨网格模型的具体构成。一个网格模型要表达出如图所示的完整外观，需要两部分信息。

![](img/34814f6da7589962c0023e80206b3aed_3.png)

1.  **形状**：通过点、线、面（网格）的组合来定义模型的轮廓和曲面起伏。
2.  **外观（如颜色）**：通常通过一张称为**纹理贴图**的二维图片来定义。为了将这张二维图片“贴”到三维网格表面，需要建立两者之间的映射关系。

这个过程称为**UV展开**。我们需要将三维网格表面（可能经过切割）展开到二维平面`(u, v)`上，建立网格顶点与纹理像素之间的一一对应关系。这样，在渲染每个三角形时，就能通过查询对应的UV坐标从纹理贴图中获取颜色值。

接下来，我们介绍网格模型的一些基本概念，这些概念对理解后续的简化算法非常重要。

### 连接关系与拓扑

网格由顶点、边和面（如三角形）组成。连接关系描述了这些元素是如何关联的，类似于图论中的图。

*   **点的度数**：指一个顶点所连接的边的数量。对于内部点，其度数等于相邻的三角形面数；对于边界点，则有所不同。
*   **邻域**：例如，一个顶点的一阶邻域包括所有通过一条边直接与该顶点相连的顶点、边和面。二阶邻域则需要通过两条边才能到达。
*   **流形与非流形**：流形网格是指其表面任意一点的局部邻域都能与一个二维圆盘建立同胚映射。非流形情况包括：
    *   **点的非流形**：一个顶点及其相邻的三角形无法构成一个简单的环（即映射不到一个圆盘上）。
    *   **边的非流形**：一条边被三个或更多个面共享。

### 欧拉-庞加莱公式

这是一个连接拓扑信息的恒等式，对于表面网格有：
`V - E + F = 2 * (S - G)`
其中：
*   `V` = 顶点数
*   `E` = 边数
*   `F` = 面数
*   `S` = 连通分量数（模型由几个独立部分构成）
*   `G` = 亏格（通俗理解，最少需要切几刀能将模型变成与球面同胚，例如一个环面的亏格为1）

### 几何量

以下是一些常用且重要的几何概念：

*   **边长**：边在三维空间中的欧几里得长度（L2范数）。
*   **面积**：三角形面积有明确公式。对于非平面的四边形，通常将其分割为三角形计算。
*   **二面角**：一条边相邻的两个三角形所在平面之间的夹角。
*   **法向**：表面上某一点处垂直于切平面的方向，通常为单位向量。
*   **相交**：指模型自身面片之间相互穿透，或不同模型之间发生穿透。
*   **退化单元**：面积为零的三角形（退化成线或点），或长度为零的边。
*   **包围盒**：能完全包裹住三维模型的最小轴向对齐或方向自适应的长方体。常用于算法中作为尺度参考，以提高对不同大小模型的鲁棒性。
*   **曲率**：描述表面弯曲程度的量。表面上一点有无数个曲率方向，其中存在**主曲率**（最大和最小曲率）。
*   **特征**：通常指模型中需要特殊处理的部位，如根据二面角提取的尖锐边、角点等，它们构成的图可将表面划分为不同区域。
*   **豪斯多夫距离**：衡量两个形状之间差异的度量。定义为从一个形状上任意点到另一个形状最近点的距离的最大值。
*   **面翻转**：在一致的网格朝向（如所有三角形顶点按逆时针排列）中，某个面的法向与周围面相反。在UV展开中，面翻转会导致纹理映射错误。
*   **凸包**：包含给定点集的最小凸集。在二维中是最小凸多边形；在三维中是最小凸多面体。

### 数据结构

如何在程序中存储和高效访问网格信息是关键。设计需要在存储空间、访问速度和更新效率之间取得平衡。存储的信息通常包括顶点位置、每个顶点附加的属性（颜色、UV、蒙皮权重等），以及点、边、面之间的连接关系。

一个经典且巧妙的数据结构是**半边结构**。它将一条边拆分为两个有方向的半边来存储。主要存储以下信息：
*   顶点：位置 + 一条出射半边的索引。
*   半边：起始顶点索引 + 左侧面片索引 + 同面内上一条和下半边的索引。
*   面片：包含的一条半边的索引。

通过这种结构，可以高效地进行邻域遍历等操作。例如，要遍历一个顶点的一环邻域面，可以从该顶点存储的半边出发，找到其对边，再通过“下一条半边”指针遍历该面，并循环此过程访问所有相邻面。

***

## 模型简化方法概述

前面我们介绍了网格模型的基本概念，那么接下来我们看看如何对模型进行简化或压缩。在游戏等实时渲染应用中，场景包含大量三维模型。模型越精细（面数越多），效果越逼真，但对计算和存储的压力也越大。

一种常见的解决方案是**层次细节渲染**：根据物体与摄像机的距离，使用不同面数版本的模型进行渲染。距离越近，使用面数越多的高模；距离越远，则使用面数少的低模。这就需要我们预先计算好同一个模型的多个简化版本。

模型简化方法在实际中主要分为两大类：

### 保纹理简化

**核心思想**：在简化三维网格和其UV网格的同时，**不改变**原始的纹理贴图。简化后的模型渲染时仍使用原纹理。

**优点**：节省存储空间，因为纹理数据通常很大，重用原纹理避免了额外的纹理存储。

**要求**：简化后的UV布局应尽可能与原UV布局保持一致，以确保从纹理采样得到的颜色能正确映射到简化后的模型表面，保持外观相似。

**主流方法**：基于**二次误差度量**的边坍缩算法是这类方法的核心。它通过逐条计算并坍缩对模型形状改变最小的边，来逐步减少面数。此类方法有大量研究和变种。

**其他思路**：
*   对三角面进行聚类，每一类用一个多边形表示，再对该多边形进行三角化。
*   针对四边形网格的简化。
*   （注：一些基于机器学习的简化或基于内在三角形表示的方法，可能不专注于保持UV，但提供了不同的思路。）

### 不保纹理简化

**核心思想**：简化过程完全打乱原有的网格连接关系和UV布局，生成一个全新的、更简单的网格。因此，必须为这个新网格**重新生成**对应的纹理贴图。

**优点**：通常能获得面数更少、几何更简洁的简化结果。

**流程**：通常包含三个主要步骤：
1.  **重新网格化**：为模型生成一个全新的、质量更好的网格。方法多样，例如用大的平面片（如四边形）去拟合模型、将模型划分为更规律的网格、或通过优化方法提取一组平面来近似原模型等。
2.  **UV展开**：为新的网格计算UV坐标，将其展开到二维平面。
3.  **纹理烘焙**：将高精度模型（高模）上的颜色、光照等信息“烘焙”到新网格（低模）的纹理贴图上。

**纹理烘焙方法**：
*   **光线投射**：从低模表面向高模发射射线，取交点处的信息（如颜色）作为低模对应纹理像素的值。简单直接，但在高低模差距大时可能映射错误。
*   **可微渲染**：利用可微渲染技术，通过优化过程将高模的外观信息传递到低模的纹理上，通常能获得更高质量的结果。

***

本节课中我们一起学习了三维模型的多种表示方法，重点剖析了网格模型的构成、基本概念（拓扑、几何量、数据结构），并概述了模型简化的两大方向：保纹理简化和不保纹理简化，以及它们的基本流程和核心思想。下一节课，我们将深入讲解保纹理简化中具体的算法原理。