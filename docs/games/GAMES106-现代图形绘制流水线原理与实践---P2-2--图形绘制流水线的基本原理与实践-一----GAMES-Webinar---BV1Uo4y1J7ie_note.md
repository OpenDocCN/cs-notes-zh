![](img/a63657bb1ec7158da67abd4eeb526707_1.png)

![](img/a63657bb1ec7158da67abd4eeb526707_3.png)

![](img/a63657bb1ec7158da67abd4eeb526707_4.png)

# GAMES106-现代图形绘制流水线原理与实践 - P2：图形绘制流水线的基本原理与实践(一) 🎬

在本节课中，我们将学习现代图形API Vulkan的基本原理与实践入门。课程将从Vulkan的简介开始，对比传统与现代图形API的差异，并详细介绍Vulkan应用程序的初始化流程、核心概念以及渲染主循环的构成。

---

## Vulkan简介与课程目标 🎯

Vulkan与OpenGL类似，其最初提案名为“GLnext”，意为下一代OpenGL。它是一个由官方组织制定统一标准的跨平台图形API，具体实现由各硬件厂商负责。这与苹果的Metal或微软的Direct3D不同，后两者的标准与实现绑定更紧密。

Vulkan的一个重要特征是**扩展**机制。各平台或硬件厂商可以提供自己的扩展功能，例如`VK_XXX_NV`（NVIDIA扩展）、`VK_XXX_AMD`（AMD扩展）或`VK_XXX_KHR`（Khronos官方扩展）。这些扩展后续可能被吸收进Vulkan核心规范。

### 课程适合人群与前置要求

以下是本课程的目标人群与学习前提：

![](img/a63657bb1ec7158da67abd4eeb526707_6.png)

*   **适合人群**：刚开始接触学习现代图形API的初学者。如果你已对OpenGL或Direct3D 11有了解，并希望更深入理解绘制管线，本课程是合适的。若已对Vulkan非常熟悉，本课程意义可能不大。
*   **前置要求**：必须掌握C和C++语言。

![](img/a63657bb1ec7158da67abd4eeb526707_7.png)

### 学习收获

![](img/a63657bb1ec7158da67abd4eeb526707_9.png)

通过本课程，你将获得以下知识：

1.  Vulkan API的基本使用方法。
2.  对Vulkan绘制管线相对全面的理解。
3.  一些针对移动端图形应用的优化实践经验。

需要区分移动端与桌面端开发，因为图形API是面向硬件的接口。不同平台的硬件特性（如移动端常受带宽限制，桌面端受计算能力限制）决定了优化策略的不同。即使是移动端，不同芯片（如高通、华为麒麟、联发科）也可能需要针对性优化。

---

## 传统与现代图形API对比 ⚖️

上一节我们介绍了Vulkan的基本情况，本节我们来对比传统与现代图形API的核心差异。

### 状态机 vs 显式控制

传统API（如OpenGL, Direct3D 11）是**状态机**。它们有一个“上下文”概念，保存着各种渲染状态。这可能导致一些问题，例如：
*   **资源管理冲突**：如果外部代码错误地释放了由内部SDK管理的、具有相同ID的资源，会导致不可预知的崩溃或错误，且难以调试。
*   **隐式同步**：驱动会自动处理同步。例如，使用`glReadPixels`从GPU读取纹理数据时，CPU会隐式等待所有相关的GPU渲染命令完成，这可能导致CPU停滞，但保证了结果正确。

现代API（如Vulkan, Direct3D 12）则不同：
*   **驱动层很薄**：驱动只做最核心的工作，将控制权交给开发者。
*   **显式管理**：开发者必须清楚了解程序的资源生命周期、内存分配、命令依赖关系和同步需求。例如，在Vulkan中，你需要先申请一大块内存，然后自行管理其中哪些部分分配给哪张纹理。
*   **高性能潜力**：这为开发者提供了写出高性能程序的能力，但要求开发者对硬件和程序逻辑有深入了解。

### 多线程与命令提交

现代API对多线程更友好：
*   **基于命令缓冲**：Vulkan使用`VkCommandBuffer`。CPU将命令记录到缓冲中，再提交到队列，GPU随后从队列获取执行。命令缓冲可以复用，如果每帧绘制命令相同，只需构建一次并重复提交。
*   **传统API的多线程**：由于状态机的存在，实现多线程较为复杂，需要为每个线程创建并共享上下文，管理各自的状态机。

### 学习路径建议

不建议零基础直接学习Vulkan或Direct3D 12，因其概念繁多，初始化复杂。推荐的学习路径是：
1.  **OpenGL**：上手简单快速，易于实现各种效果，适合建立图形学直观感受。
2.  **Direct3D 11**：接口基于面向对象设计，有助于更清晰地理解绘制管线结构。

开发时需注意：应严格按照API的标准流程编写代码，避免省略步骤。不同硬件驱动对标准的实现可能有差异，省略可能导致在某些设备上运行异常。

---

## Vulkan应用程序基础框架 🏗️

前面我们对比了图形API的差异，现在我们来具体看一个Vulkan应用程序的基础框架。整个流程可分为三大部分：初始化、渲染主循环和资源清理。

![](img/a63657bb1ec7158da67abd4eeb526707_11.png)

![](img/a63657bb1ec7158da67abd4eeb526707_13.png)

我们的目标是一个能绘制三角形的简单程序，其代码结构清晰地对应了这三个阶段。

### 程序流程总览

一个Vulkan程序的基本流程如下：

![](img/a63657bb1ec7158da67abd4eeb526707_15.png)

![](img/a63657bb1ec7158da67abd4eeb526707_16.png)

1.  **初始化阶段**
    *   创建应用程序窗口。
    *   初始化Vulkan（加载驱动，连接物理设备）。
    *   创建交换链，关联Vulkan与显示窗口。
2.  **渲染主循环阶段**
    *   **更新CPU逻辑**：处理游戏逻辑、UI、输入等。
    *   **更新GPU资源**：将CPU端更新好的数据（如矩阵、参数）拷贝到GPU内存。
    *   **提交渲染命令**：构建并提交命令缓冲，驱动GPU进行渲染，并将结果呈现到屏幕。
3.  **清理退出阶段**
    *   退出主循环后，释放所有Vulkan资源。
    *   关闭程序窗口。

![](img/a63657bb1ec7158da67abd4eeb526707_17.png)

渲染可以看作一个函数：输入是几何信息和Uniform参数，输出是屏幕画面，而处理逻辑就是着色器程序。

![](img/a63657bb1ec7158da67abd4eeb526707_19.png)

---

## Vulkan核心概念与初始化详解 🔧

了解了整体框架后，本节我们深入Vulkan初始化的核心概念。

### Vulkan实例与层

创建Vulkan实例是与驱动沟通的第一步。这里引入一个关键概念：**层**。

Vulkan的加载过程不是直接调用驱动，而是经过一个或多个“层”。`VkInstance`是应用程序与Vulkan库之间的桥梁。层机制允许在调用驱动函数前后插入自定义代码，常用于：
*   **启用扩展**：如交换链扩展。
*   **调试与验证**：启用调试层，为资源设置易读名称，或检查API调用错误。
*   **性能分析**：使用如RenderDoc等工具层。

层的工作方式类似于函数钩子。当调用一个Vulkan函数时，会依次经过各个启用的层进行处理，最后才到达驱动。这为调试和性能分析提供了官方支持的标准方式。

### 物理设备与队列家族

初始化实例后，需要选择物理硬件设备。系统可能有多块显卡，Vulkan可以查询所有可用物理设备及其属性（如设备名称、能力限制）。程序应根据需求选择合适的设备。

每个物理设备有一个或多个**队列家族**。队列是命令缓冲提交的地方。不同的队列家族支持不同类型的操作：
*   **图形队列**：支持渲染命令。
*   **计算队列**：支持计算着色器命令。
*   **传输队列**：支持内存复制命令。
*   **呈现队列**：支持将结果呈现到屏幕。

![](img/a63657bb1ec7158da67abd4eeb526707_21.png)

![](img/a63657bb1ec7158da67abd4eeb526707_22.png)

并非所有队列都支持所有操作。一个物理设备可以创建多个**逻辑设备**，每个逻辑设备可以创建来自不同队列家族的队列。这样，你可以将图形命令提交到图形队列，计算任务提交到计算队列，实现更精细的任务分工与并行。

![](img/a63657bb1ec7158da67abd4eeb526707_24.png)

![](img/a63657bb1ec7158da67abd4eeb526707_26.png)

### 为什么设计如此复杂？

这种设计是为了提供极大的灵活性。例如，在多GPU系统（如四路显卡）中，你可以让不同显卡专精于不同任务（物理模拟、部分渲染、最终呈现），并通过Vulkan显式地管理和调度它们，从而充分利用所有硬件资源。虽然简单应用通常只用一个实例、一个逻辑设备和少数队列，但Vulkan为此类高级用例提供了可能。

![](img/a63657bb1ec7158da67abd4eeb526707_28.png)

---

![](img/a63657bb1ec7158da67abd4eeb526707_30.png)

![](img/a63657bb1ec7158da67abd4eeb526707_32.png)

![](img/a63657bb1ec7158da67abd4eeb526707_34.png)

## 总结 📚

![](img/a63657bb1ec7158da67abd4eeb526707_36.png)

![](img/a63657bb1ec7158da67abd4eeb526707_37.png)

![](img/a63657bb1ec7158da67abd4eeb526707_39.png)

![](img/a63657bb1ec7158da67abd4eeb526707_40.png)

本节课我们一起学习了现代图形API Vulkan的入门知识。

![](img/a63657bb1ec7158da67abd4eeb526707_41.png)

![](img/a63657bb1ec7158da67abd4eeb526707_43.png)

![](img/a63657bb1ec7158da67abd4eeb526707_44.png)

我们首先了解了Vulkan的定位、特点以及本课程的学习目标。随后，通过对比传统与现代图形API，我们理解了Vulkan**显式控制、驱动层薄、面向多线程**的设计哲学，这带来了高性能的潜力，也提高了开发复杂度。

![](img/a63657bb1ec7158da67abd4eeb526707_45.png)

接着，我们剖析了一个Vulkan应用程序的**基础框架**，包括初始化、主循环和清理三个阶段。最后，我们深入讲解了初始化的核心概念：**实例与层**用于调试和扩展，**物理设备与队列家族**则提供了连接硬件和提交命令的途径。

![](img/a63657bb1ec7158da67abd4eeb526707_47.png)

这些概念是构建任何Vulkan程序的基石。在接下来的课程中，我们将基于这些知识，学习如何创建渲染对象、管理内存并进行实际的绘制。