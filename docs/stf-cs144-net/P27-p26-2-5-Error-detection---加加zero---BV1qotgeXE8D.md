# P27：p26 2-5 Error detection - 加加zero - BV1qotgeXE8D

网络并非完美，运行在网络上的主机也并非如此，它们可以引入错误，为了使网络能够正常运行，它需要能够检测这些错误，例如，假设我们路径上的路由器有一个坏掉的记忆细胞，使得有时候它在数据包中翻转一个位，想象。

例如，如果位是，如果位翻转，是金额要充电的最 significant 位吗，信用卡，我们需要能够检测到错误发生，所以我们不接受被腐蚀的数据作为正确的，今天的数据网络通常使用三种不同的误差检测算法。

校验和，循环冗余代码或 crcs，和消息认证代码或 macs，他们每个人都有非常不同的特性，理解他们的差异很重要，实际上，我在ietf的会议上有过，在那里，有几个人对差异并不知情，如果你不知道。

你可能做出错误的协议决策或协议分析。

![](img/4796a6f5c915f19d050b842b4a36faed_1.png)

从高层次来看，错误检测看起来像这样，我们有一个数据包，我们将在该数据上计算一些错误检测位，并将其附加或预端到数据包中，例如，以太网在数据包后附加一个循环冗余码或crc。

而传输层安全tls则在消息后附加一个消息认证码，IP预先生成，一个校验和，将其放置在IP头部，tls和以太网有一个footer协议信息，紧随负载后，这就是他们放置crc的地方在mac。



![](img/4796a6f5c915f19d050b842b4a36faed_3.png)

三种常用错误检测算法中的第一个是校验和，你只需要将数据包的所有数据相加，这就是tcp和ip使用校验和的地方，校验和是很好的，因为它们计算速度快且便宜，即使在软件开始流行的时候，而且一切都是软件。

这是有价值的，它们的主要缺点是错误检测保证较弱，虽然他们可以捕获许多随机错误，用不超过两个位错误就可以欺骗校验和，如果这两个位错误相互抵消，例如，如果一个位错误增加三个二，另一个位错误减去三个二。

校验和无法捕获错误，所以校验和可以捕获很多错误，但事实证明，它对将捕获哪些错误有非常弱的保证，三种常用错误检测算法中的第二种是循环冗余码，或crc crc比校验和计算上要昂贵得多。

但也要 robust得多，它计算多项式的余数，我会解释这是什么意思，并在几分钟内用今天的处理器来解释它如何工作，这很容易做，在硬件上做真的很容易，在一些方面，以太网和许多链路层都使用这种技术。

TCP和IP可以避开校验和，因为链路层使用CRC，如果你有一个长度为c的CRC，一个CRC可以检测任何一位错误，任何两位错误，以及任何长度不超过c位的单个爆发，以及任何奇数个错误。

所以你可以检测很多错误，比校验和提供更强大的保证，最终的算法被称为消息认证代码或mac，消息认证代码将包与一些秘密信息结合生成值，理论上，只有生成或检查mac的人才能，如果他们有秘密，所以。

如果你收到一个包且mac正确，那么你对计算机到计算机之间的包相当确定，mac有秘密，除非我有秘密，生成包正确mac异常困难，所以，一个坏蛋不能轻易地生成新的包，实际上，如果你有一个强大的mac算法。

那么，给定一个包和它的mac，我对mac将看起来什么样子一无所知，如果我翻转一个位，消息认证产品因此对恶意修改具有抵抗力，消息认证产品在传输层安全tls中用于，这就是你当安全浏览网页时使用的https。

但它们实际上并不擅长捕获错误，如果我在包中翻转一个位，没有一和二的c，那个更改的包有相同mac的机会，我看到人们在谈论错误纠正时犯这个错误。



![](img/4796a6f5c915f19d050b842b4a36faed_5.png)

认为mac和crc一样好，不是，如果我有一个十六位crc，我保证我会检测到错误爆发，那就是十六位长或短，如果我有一个十六位mac，我仅保证我会以非常高的概率检测出竞标者，九十九点。

九十 percent 或 一在六十五万五千三百三十六，这很高，但想想你看过的包有多少，仅仅接收这个视频。



![](img/4796a6f5c915f19d050b842b4a36faed_7.png)

我现在将去详细解释这些算法，让我们从校验和开始，IP、UDP和TCP，使用一补码校验和，这意味着他们使用一补码算术来添加包，二进制算术的一种形式，一些旧电脑现在仍在使用，使用二补码算术，算法很简单。

你开始将包的校验和字段设置为零，然后您添加包的每个十六位字，每当您需要携带时，因为和超过2的16次方或65万5355。



![](img/4796a6f5c915f19d050b842b4a36faed_9.png)

您将后一位的位带回来，所以60万，加上8万是68万，减去65万，5355，加上一次或两次万四千六百六。



![](img/4796a6f5c915f19d050b842b4a36faed_11.png)

您已经添加了整个包。

![](img/4796a6f5c915f19d050b842b4a36faed_13.png)

翻转您和的位，并将此设置为包的校验和，然后如果您添加整个包，包括这个校验值，您应该得到零，X F F F 所有一。



![](img/4796a6f5c915f19d050b842b4a36faed_15.png)

有一个边缘情况，如果计算机校验和是全一，您不会将校验和字段设置为零，您将其设置为所有一，一个IP，UDP和TCP，校验和字段为零意味着没有校验和，这就是全部，您可以用几行C代码来写这个，它快。

容易计算和检查，您只需要添加包的字节并检查那个。

![](img/4796a6f5c915f19d050b842b4a36faed_17.png)

校验和是全一，考虑到大多数早期的互联网实现都是在软件中实现的。

![](img/4796a6f5c915f19d050b842b4a36faed_19.png)

这真的很有帮助，缺点是它并不真的很 robust，虽然它确实检测到了很多随机错误，它关于能检测到什么样的错误能给出的保证真的很弱。



![](img/4796a6f5c915f19d050b842b4a36faed_21.png)

在实际中，它只能承诺捕获单个位错误。

![](img/4796a6f5c915f19d050b842b4a36faed_23.png)

但是，它工作得非常好，并且链路层为我们做了很多繁重的工作，链路层在做它们的繁重工作，使用被称为循环冗余检查或crc的东西，crc的概念是，我想要从源数据中提取n位，一些会将它们浓缩为错误检测数据的位。

其中c比n小，例如，我可能有一个1500字节的以太网帧，有一个4字节的，3，2位crc，USB和蓝牙，使用十六位crcs，当然我们不能检测所有问题，给定一些其他随机包。

crc匹配的机会是2的负c或1和2的c。

![](img/4796a6f5c915f19d050b842b4a36faed_25.png)

例如，如果我使用八位crc，那么在所有包的空间中，一在两百五十，六或零点，有四分之一的包与我的包具有相同的crc值，但是crc比校验和更强大，它们可以检测到任何包含奇数错误位的包中有错误，两比特错误。

或者是任何长度不超过c的单位错误爆发，它们不能保证检测到这些以外的错误。

![](img/4796a6f5c915f19d050b842b4a36faed_27.png)

但是，它们做得很好，例如，一个十六位的crc不能保证，会检测到相隔很远的三比特错误爆发，但是，它很可能检测到它。



![](img/4796a6f5c915f19d050b842b4a36faed_29.png)

链路层通常使用crcs，它们相当 robust。

![](img/4796a6f5c915f19d050b842b4a36faed_31.png)

并且，由于许多链路层对错误爆发敏感，crc的爆发检测能力是有用的，使它们并不难，使硬件快速计算它们并不难。



![](img/4796a6f5c915f19d050b842b4a36faed_33.png)

你可以计算，在你读者的包写入过程中逐个计算它们。

![](img/4796a6f5c915f19d050b842b4a36faed_35.png)

那么crc是如何工作的，它将这些n位转换为c位，使用被称为多项式长除法的东西。

![](img/4796a6f5c915f19d050b842b4a36faed_37.png)

你取消息的位并将其用于描述多项式，M。

![](img/4796a6f5c915f19d050b842b4a36faed_39.png)

包中的每个位是多项式的一个术语的系数，如果位是零，术语不存在，如果位是一，术语存在，所以，例如，一个消息'11011101'是x的七次方，加上x的四次方，加上x的立方，加上x的平方。

加上一个等于0的1是x的零次方，这是因为消息的第七，第四，第三，第二和零次方位被设置，当我们计算crc时，我们有一个叫做生成器多项式的东西，这是由crc算法定义的，例如，用于usb的crc十六算法。

有一个生成器多项式为x的十六次方，加上x的十五次方加上x的平方加上一。

![](img/4796a6f5c915f19d050b842b4a36faed_41.png)

由于令人沮丧的历史原因，这些生成多项式比这个数字位的位数长一个项。

![](img/4796a6f5c915f19d050b842b4a36faed_43.png)

第一个项总是一，所以crc十六的生成器多项式被写成零x八零零五，尽管它有一个到十六项的x来计算crc，你取消息，用等于crc长度的零填充消息，并将这个填充值除以g。



![](img/4796a6f5c915f19d050b842b4a36faed_45.png)

余数是crc，你将crc附加到消息中以检查crc，你将消息加上crc除以生成器多项式g，如果余数为零，那么crc通过，我不会详细解释这如何从数学上工作，但结果是它可以在硬件中实现得非常快和高效。



![](img/4796a6f5c915f19d050b842b4a36faed_47.png)

你的crc算法的强度取决于你选择的生成多项式g，人们对此进行了大量的研究，因此有许多好的选择，其中具有我之前提到的错误检测属性的有很多。



![](img/4796a6f5c915f19d050b842b4a36faed_49.png)

但你可能不能得到相同的错误检测强度。

![](img/4796a6f5c915f19d050b842b4a36faed_51.png)

如果你选择你自己的生成多项式，在网络中常见的第三种也是最后一种错误检测算法，是消息认证码或mac，如crcs，消息认证码的工作原理有深厚的数学和丰富的数学背景。



![](img/4796a6f5c915f19d050b842b4a36faed_53.png)

有好的和坏的。

![](img/4796a6f5c915f19d050b842b4a36faed_55.png)

因此，你通常想要使用现有的方案，而不是冒险，幸运的是，标准通常指定应该使用哪种Mac。

![](img/4796a6f5c915f19d050b842b4a36faed_57.png)

尽管九十年代末期的标准有一些错误，选择算法，现在，安全性已经重要到每个人都依赖于少数经过深入研究的方法，消息验证可以使用密码学，密码学的一个分支，处理秘密，大多数消息验证代码的理念是。

两个方共享一个秘密s。

![](img/4796a6f5c915f19d050b842b4a36faed_59.png)

秘密只是一个由随机生成的位组成的集合random，因此，很难猜测或计算消息验证代码，C，您将MAC算法应用于消息m和秘密s的MAC算法，该算法具有属性。



![](img/4796a6f5c915f19d050b842b4a36faed_61.png)

如果您没有s，那么对于消息干扰生成正确的c来说，真的很难，此外，创建消息m也非常困难，其消息认证代码为c的消息，很难通过硬手段创建，我的意思是，这是最佳情况。

您只需要 exhaustively 尝试有m和c给您几乎不提供关于什么，s的信息，这意味着如果您收到带有正确消息认证代码的消息m。



![](img/4796a6f5c915f19d050b842b4a36faed_63.png)

这意味着生成该消息的计算机可能具有秘密，或者是那个计算机重播的消息，因为目标是保持秘密，加密强消息认证有一个有趣的属性，如果您更改m中的一个位，这将导致一个全新的crc，其中c中的任何位概率为零。

一个似乎是随机且与以前的c独立的位，如果不是这样，那么某人可以取一条消息翻转一个位，所以改变一个美元值，生成正确的c并不难，这意味着从技术上讲，消息认证代码没有错误检测的保证。



![](img/4796a6f5c915f19d050b842b4a36faed_65.png)

如果您翻转一个位，您可能会得到与原始mac相同的mac，消息认证代码非常有用，但它们首先和主要。

![](img/4796a6f5c915f19d050b842b4a36faed_67.png)

是一种安全机制，能够同时提供错误检测和安全，一个机制既足够又好，但他们的安全特性意味着他们的错误检测不如其他方法。



![](img/4796a6f5c915f19d050b842b4a36faed_69.png)

让我们回顾答案， both checksums can detect a single bit error，记住，这是检查和保证检测错误的一种错误。

 both ccs can also detect a single bit error，一个mac不能保证它能检测到一个位错误，出于安全原因，它可能是新的mac与旧的mac相同，所以它不能保证检测它。

实际上，并且一个mac不能保证检测任何错误，所以您可以在所有列中标记为否，对于消息认证代码，那么对于两个位错误呢，检查和保证不能检测两个位错误，所以对于两者都是否定的，crcs，虽然。

可以检测保证位错误，运行时间不超过或等于crc的长度，由于两个比特比八位和十六位都短，两种ccs都可以检测到两个比特的错误运行，相应地，一个八位，Crc无法保证检测到九位错误运行。

但一个十六位crc可以，所以对于八位crc来说，是的，是的，对于十六位序列，对于九位错误运行，是的，对于相隔一百位的两个比特错误，如何呢，结果，所有这些算法都无法保证检测此错误，所以对于所有这些。

查看此矩阵，是的，你可能认为错误检测是浪费，算法承诺非常少，但保证是一个非常强烈的声明，嗯，一个八位校验和，无法保证您将捕获九位错误运行，有很大的可能性，同样，一个十六位crc。

有很高的可能性检测相隔一百位的两个比特错误，在实际应用中，高概率往往足够好，如果失败很少，那么您有时只需要做更昂贵的事情来恢复，但这意味着在实际应用中您往往有多层错误检测，链路层检测它们，crcs。

ip检测，校验和，tcp会取一些校验和，然后通常应用程序有自己的错误检测，所以所有放在一起，错误渗透的机会非常非常低。



![](img/4796a6f5c915f19d050b842b4a36faed_71.png)

我们已经看到了三种错误检测方案，检查一些crc和消息身份验证代码。

![](img/4796a6f5c915f19d050b842b4a36faed_73.png)

数据错误检测是端到端原则的伟大例子。

![](img/4796a6f5c915f19d050b842b4a36faed_75.png)

实际上，这是原动力，一个层只能确保它正确地通信数据。

![](img/4796a6f5c915f19d050b842b4a36faed_77.png)

是通过进行端到端检查来实现的，以太网需要确保其帧没有错误，以便它可以正确解析它们，所以它有一个crc，ip需要确保其包没有错误。



![](img/4796a6f5c915f19d050b842b4a36faed_79.png)

以便它可以正确解析它们，ip不能依赖以太网做什么来检查自己的检查。

![](img/4796a6f5c915f19d050b842b4a36faed_81.png)

以太网卡或驱动可能会引入错误。

![](img/4796a6f5c915f19d050b842b4a36faed_83.png)

在那之后，驱动检查了包，所以ip必须在网络层进行自己的和端到端检查。

![](img/4796a6f5c915f19d050b842b4a36faed_85.png)

使用消息身份验证代码的tls是另一个例子，它特别有趣，因为tls对错误检测的要求与ip大相径庭，以太网，它想要安全，所以它必须提供它，提供自己从开始到结束的错误检测方案，因为它是唯一确保它是要求的方式。



![](img/4796a6f5c915f19d050b842b4a36faed_87.png)