# 课程P42：分组交换原理 - 播放缓冲区 🎬

在本节课中，我们将学习实时应用（如流媒体视频）如何处理网络中可变的排队延迟。我们将重点介绍**播放缓冲区**的概念，了解其工作原理以及如何通过它来吸收延迟变化，从而保证流畅的用户体验。

---

![](img/8d2a90c21d81104dda36314d817b6f64_1.png)

## 播放缓冲区的作用

上一节我们介绍了端到端延迟的计算及其不稳定性。本节中我们来看看，对于实时应用而言，这种延迟的变异性为何至关重要。

我们使用的大多数应用并不特别关心端到端延迟的变异性。例如，下载网页或发送电子邮件时，我们希望尽快完成，但不介意单个数据包花费10到12毫秒到达。

![](img/8d2a90c21d81104dda36314d817b6f64_3.png)

![](img/8d2a90c21d81104dda36314d817b6f64_1.png)

但有些应用必须关心排队延迟，特别是**实时应用**，如流媒体视频和语音。在接下来的内容中，我们将解释排队延迟如何使这些应用变得困难。这可以作为排队延迟的一个好例子，并解释我们如何在实践中缓解此问题。

应用无法确切知道数据包何时到达，因此不能保证能够按时向用户交付所需的语音或视频样本。为此，它们会在一个称为**播放缓冲区**的地方积累数据包。

![](img/8d2a90c21d81104dda36314d817b6f64_3.png)

## 播放缓冲区的直观认识

你可能已经见过播放缓冲区。下图是YouTube客户端底部的一个小截图。剩余的部分显示我们已经看过的视频，这里的播放点表示我们当前观看的位置。灰色线条部分显示了已经缓冲但尚未播放给用户的视频数据包，这就是我们感兴趣的**播放缓冲区**。

客户端故意构建这个播放缓冲区，试图领先一步，以防止一些数据包被延迟或无法按时到达，从而避免播放中断。

![](img/8d2a90c21d81104dda36314d817b6f64_5.png)

设计播放缓冲区时，我们必须考虑希望缓冲区领先多远。如果我们将缓冲区构建得很大，就可以吸收更多的数据，并容忍更大的队列延迟变化。如果缓冲区非常短，当队列延迟出现大幅变化或突然增加时，我们可能会耗尽数据包，因为它们可能无法按时出现。因此，设计播放缓冲区对于应用正常工作至关重要。

## 播放缓冲区的详细分析

让我们更详细地分析播放缓冲区。下图展示了我们正在播放的点，以及我们已经缓冲的数据量。

![](img/8d2a90c21d81104dda36314d817b6f64_5.png)

这是播放缓冲区的内容。我们以此为例进行设置：想象我们在右侧的笔记本电脑上观看YouTube视频，它从左侧的YouTube服务器流式传输视频。

我们假设视频以 **1 Mbps（每秒1兆比特）** 的速率流式传输。这只是一个示例数字，实际速率可能不同。数据包将通过路径中的多个路由器（图中标记为1、2、3），实际路径中的路由器可能多达10到15个。

我们主要关心的是路径中的**队列延迟**。这里有三个可能经历队列延迟的地方，这种可变的队列延迟意味着数据包到达时间略有不可预测。

## 数据发送与接收的累积图

下面的图表显示了服务器随时间累积发送的字节数。由于它以恒定的1 Mbps速率发送，这条线是直的。累计发送的位数或字节数随时间线性增长：一秒后发送100万位，十秒后发送1000万位。

由于网络中的可变队列延迟，笔记本电脑上的累计到达量看起来不同，可能像图中这样一条弯曲的线。

这意味着，如果我们取第一个到达的字节（按到达顺序），可以水平画一条线，查看特定字节何时到达。X轴表示特定字节从发送到接收所花费的时间。

注意，这里使用“位”和“字节”，但单位并不重要。如果我们取图中任意一点（例如某个特定字节），水平画一条线，该线与X轴的交点即该字节到达笔记本电脑的时间。因此，**延迟由水平距离测量**，并且这个距离是变化的，取决于每个数据包遇到的队列延迟。

我们还可以看到，在任意给定时间，路径上缓冲的数据量（即从服务器发出但尚未被客户端播放的字节数）由图中的**垂直距离**显示。因为它表示在特定时间已发送的数量与已接收的数量之差。

从这张图中我们可以获取很多信息。横轴表示延迟，纵轴表示网络中当前缓冲的字节数。

## 延迟的界限与约束

让我们回到我们的例子。延迟的最大组成部分是**传播延迟**和**打包延迟**，这些是固定部分。因此，我们对这个线段的形状有相当的了解。实际的形状可能非常不同，但我刚刚创造了这个形状来说明。

首先我们知道一些事情：从开始到结束的总延迟不能少于传播和打包延迟，这是一个**下限**。因此，图中两条线之间的水平距离有一个下限。

它也有一个**上限**：路由器中的缓冲区大小是有限的。因此，任何数据包可能经历的最大延迟是它通过所有路由器缓冲区时的排队延迟之和，再加上打包延迟和传播延迟。这代表了一个上限。

但上限并不非常有用，因为它可能非常大。在实际应用中，路由器可能具有半秒的缓冲，如果我们经过多跳，下限和上限之间可能存在巨大差异，因此这对我们几乎没有用。

我们还知道右侧的累计到达量是**非递减的**。换句话说，这个值总是增加，因为它是接收到的字节总数，显然不能出现负的字节数。

最后我们还知道一件事：因为我们知道最后一段链路的速率有一个上限（可能是100 Mbps或1 Gbps），它告诉我们**瞬时到达率**（即图中到达曲线的斜率）不能超过该链路的数据速率。

## 客户端的工作机制

有了所有这些限制，让我们来看看客户端需要采取哪些步骤才能使这一切工作。

图中的红色线显示了视频向用户的**播放速率**。这告诉我们，在某个时间点，它正在播放服务器发送的第一个字节（当然，这也是接收器接收的第一个字节）。

如果我们在这里取一条水平线，它将告诉我们一个特定字节被发送、接收然后播放的时间。这意味着这里的水平距离告诉我们一个特定的字节已经被缓冲了多久。因此，在任何时间我们都可以知道一个字节在播放缓冲区中停留了多长时间才被播放。

我们还知道播放缓冲区中有多少字节：它是图中在任意时间的垂直距离，这告诉我们**播放缓冲区的占用情况**。

我们可以看到，开始时播放缓冲区非常小，然后逐渐积累，在这里达到了一个非常大的值，随后随着播放进度落后，缓冲区变小，几乎变空。我们非常幸运，因为有些字节可能后来才出现，我们只是避免了缓冲区耗尽。然后，在某个时候，我们又积累了一些缓冲区。

我们以恒定的1 Mbps速率回放，这就是用户听到的内容。这是一个好的例子：我们选择了正确的值，等待了足够长的时间，积累了足够的缓冲，最终一切顺利。

## 客户端的内部结构

在客户端内部，它大致看起来像这样：播放缓冲区是客户端内存中持有的一个缓冲区。客户端正在选择**播放点**，即我们在YouTube客户端上看到的那个点。字节从播放缓冲区中取出后，被放入视频解码器，转换回视频，然后在屏幕上播放。

![](img/8d2a90c21d81104dda36314d817b6f64_7.png)

## 缓冲区不足的情况

![](img/8d2a90c21d81104dda36314d817b6f64_7.png)

让我们来看看事情不太顺利的情况。同样的例子再次出现：服务器在左侧发送字节，笔记本电脑在右侧接收字节。但在这种情况下，我们等待播放第一个字节的时间不够长。

你可以在这里看到，我们从接收到第一个字节到开始播放的等待时间稍微短了一些。当然，一旦我们开始播放字节，我们就必须承诺以1 Mbps的速率播放它们，否则无法在屏幕上持续显示视频。

对于这个特定情况，一开始一切看起来很好，缓冲区占用率良好。但它变得越来越小，直到最终到达一个点，我们遇到了问题：**缓冲区变空**。这意味着我们没有任何可以解码并显示在屏幕上的字节。图中所有的红色区域都是我们处于“赤字”的时间，这很不好。

客户端做得好的是（我们都见过这种情况）：它必须使缓冲区更大。它通过**重新缓冲**来实现这一点，即冻结屏幕，等待一些字节积累，然后才能继续播放。

如果你一直在慢速链接上观看这个视频，或者你距离很远，数据包需要通过许多路由器，你可能经历过这种缓冲事件。你可以通过以更低的速率流式传输视频，或者简单地提前下载视频来解决这个问题。

![](img/8d2a90c21d81104dda36314d817b6f64_9.png)

## 总结与回顾

总的来说，在带有缓冲区的播放中，当我们进行端到端的分组交换时，延迟是可变的。我们使用**播放缓冲区**来吸收这种变化。

![](img/8d2a90c21d81104dda36314d817b6f64_9.png)

我们可以使播放缓冲区非常大，但那样视频在开始时会有延迟（即我们等待第一个字节到达直到播放的时间）。如果我们使缓冲区更大，就必须延迟视频的起始点，这在观看视频时会带来不便。

因此，应用程序试图**估计延迟**。它们试图估计从服务器到笔记本电脑的延迟，设置播放点，然后如果延迟发生变化，则调整缓冲区大小。

![](img/8d2a90c21d81104dda36314d817b6f64_11.png)

现在让我们回到对端到端延迟的原始表达式。现在我们看到，它由以下三个部分组成：
1.  **打包延迟**
2.  **传播延迟**
3.  **可变的队列延迟**

![](img/8d2a90c21d81104dda36314d817b6f64_11.png)

队列向路径添加了可变和不可预测的延迟。

![](img/8d2a90c21d81104dda36314d817b6f64_13.png)

![](img/8d2a90c21d81104dda36314d817b6f64_13.png)

## 课程总结 🎯

本节课中我们一起学习了：

*   端到端延迟由三个部分组成：
    *   **传播延迟**：比特在链路上传播所需的时间（固定）。
    *   **分组延迟**：将分组放入链路所需的时间（固定）。
    *   **队列延迟**：数据包在路径上路由器的缓冲区中等待的时间（可变）。
*   一些应用（如流媒体视频）使用**播放缓冲区**来吸收可变的队列延迟，帮助应用以固定的速率将视频流回给用户。
*   播放缓冲区的设计需要在**启动延迟**和**抗抖动能力**之间进行权衡。

这就是分组交换原理中关于播放缓冲区的内容。在接下来的课程中，我将介绍一个简单的确定性模型，帮助我们更好地理解这些概念。

![](img/8d2a90c21d81104dda36314d817b6f64_15.png)

![](img/8d2a90c21d81104dda36314d817b6f64_15.png)