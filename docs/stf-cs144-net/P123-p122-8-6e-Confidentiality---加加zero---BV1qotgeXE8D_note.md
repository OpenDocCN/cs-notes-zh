# 课程 P123：Blowfish 简化版安全性分析 🔐

![](img/d3238fedc913c099d7d780c7a9824e88_1.png)

在本节课中，我们将分析一个简化版 Blowfish 加密算法的场景，并尝试推导出特定明文块中的信息。我们将通过一个具体的例子，理解迭代轮数对加密安全性的影响。

---

上一节我们介绍了 Blowfish 算法的基本结构。本节中我们来看看一个简化版本，并分析其潜在的安全问题。

![](img/d3238fedc913c099d7d780c7a9824e88_3.png)

假设我决定让 Blowfish 算法运行得更快，并将其迭代轮数削减到仅剩一轮。

我向这个简化版的算法输入两个明文块。第一个明文块全部由零组成，并且我的对手以某种方式知道了这个事实。该算法产生了此处显示的第一个密文。

接着，我输入第二个明文块，算法产生了此处显示的第二个密文。

那么，第二个明文块中 **L0** 的值是多少？

以下是解题所需的已知信息与推导步骤：

![](img/d3238fedc913c099d7d780c7a9824e88_5.png)

*   **已知条件 1**：加密算法是仅进行一轮迭代的简化版 Blowfish。
*   **已知条件 2**：第一个明文块 `P1` 是全零块，且对手知晓这一点。
*   **已知条件 3**：我们拥有第一个明文块对应的密文 `C1`。
*   **已知条件 4**：我们拥有第二个明文块对应的密文 `C2`。
*   **推导目标**：求出第二个明文块 `P2` 的左半部分 `L0` 的值。

核心推导逻辑基于 Blowfish 的单轮 Feistel 结构。在单轮加密中，对于任意明文块 `P = (L0, R0)`，其加密过程可以简化为：
```
R1 = F(L0 ⊕ P_arrays[0]) ⊕ R0
L1 = R0
```
其中，`F` 是轮函数，`P_arrays[0]` 是第一轮的子密钥。

由于我们知道第一个全零明文块 `P1 = (0, 0)` 及其密文 `C1 = (L1, R1)`，我们可以利用这个关系来解出轮函数 `F` 在特定输入下的输出，进而破解第二个密文。

![](img/d3238fedc913c099d7d780c7a9824e88_7.png)

具体方法是，通过 `P1` 和 `C1` 计算出 `F(P_arrays[0])` 的值。因为 `L0=0, R0=0`，所以 `R1 = F(0 ⊕ P_arrays[0]) ⊕ 0 = F(P_arrays[0])`。而 `R1` 可以从 `C1` 中获得。

得到 `F(P_arrays[0])` 后，对于第二个密文 `C2 = (L1‘, R1’)`，其对应的右半部分明文 `R0‘` 就是 `L1‘`。接着，我们可以逆向计算左半部分明文 `L0‘`：
```
L0‘ = F_inverse(R1‘ ⊕ R0‘) ⊕ P_arrays[0]
```
由于我们已知 `F(P_arrays[0])` 的值，并且知道 `F` 函数在单轮简化模型下可能可逆或可通过已知输入输出对推导，因此可以计算出 `L0‘` 的值。

![](img/d3238fedc913c099d7d780c7a9824e88_9.png)

---

本节课中我们一起学习了如何利用已知明文攻击来分析迭代轮数不足的加密算法。通过一个具体的 Blowfish 单轮简化模型，我们演示了当对手掌握一个已知明文-密文对时，可能如何推导出另一个密文对应的部分明文信息。这强调了在密码学设计中，足够的迭代轮数对于抵抗密码分析至关重要。