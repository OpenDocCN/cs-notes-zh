- en: P24：13-03-view-modifications-using-triggers.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P24：13-03-view-modifications-using-triggers.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: In this video， which will mostly be live demo， we'll talk about modifying views
    through triggers。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段视频中，主要是现场演示，我们将讨论通过触发器修改视图。
- en: '![](img/33021a3a111aaaa798f0a452f51b7087_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33021a3a111aaaa798f0a452f51b7087_1.png)'
- en: As a reminder， once we've defined a view， say called V。 we'd like to be able
    to run modification commands over V as if it were a regular table。 Now。 since
    V is not a regular table， it's just a view definition。 what happens is that the
    modification commands against V are rewritten to modify the base tables over which
    V is defined。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，一旦我们定义了一个视图，例如叫做V，我们希望能够像对待常规表一样对V运行修改命令。但由于V并不是常规表，它只是一个视图定义，实际上，针对V的修改命令会被重写为修改V所定义的基础表。
- en: And as we talked about previously， unlike with queries over views。 we can't
    in general automate the process of rewriting of modifications on views into modifications
    on the base tables。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所讨论的，与查询视图不同，我们一般无法自动化地将对视图的修改重写为对基础表的修改。
- en: '![](img/33021a3a111aaaa798f0a452f51b7087_3.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33021a3a111aaaa798f0a452f51b7087_3.png)'
- en: As we discussed in the introductory video， there are two basic approaches to
    dealing with the fact that the translation can't be automated。 One is to have
    intervention by the view creator where the rewriting process is specified as part
    of creating a view if we want to allow that view to have modifications against
    it。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍视频中讨论的那样，处理无法自动化翻译的情况有两种基本方法。一种是由视图创建者进行干预，在创建视图时指定重写过程，如果我们希望允许该视图进行修改。
- en: And the other is to restrict the allowed views and modifications so that the
    translation can be automated。 In this video， we're talking about the first case，
    and specifically。 we're going to see how instead of triggers， a special type of
    trigger can be used to specify the rewriting process to enable modifications against
    views。 We'll be using our standard simple college admissions database for the
    demonstration where we have our usual free tables。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个目的是限制允许的视图和修改，以便能够自动化翻译。在这段视频中，我们讨论的是第一种情况，具体来说，我们将看到如何使用一种特殊类型的触发器，而不是普通的触发器，来指定重写过程，从而启用对视图的修改。我们将在演示中使用我们标准的简单大学招生数据库，包含我们通常的免费表。
- en: the college table， the student table， and the table containing information about
    students applying to colleges。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 包括学院表、学生表以及包含学生申请学院信息的表。
- en: '![](img/33021a3a111aaaa798f0a452f51b7087_5.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33021a3a111aaaa798f0a452f51b7087_5.png)'
- en: So let's turn to the demo。 As usual， we'll start with our four colleges， Stanford，
    Berkeley， MIT。 and Cornell， our bunch of students， and finally， the records showing
    our students applying to colleges for a specific major and a decision for that
    application。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始演示。和往常一样，我们将从四所大学开始：斯坦福、伯克利、麻省理工和康奈尔，我们的一群学生，最后是显示学生申请特定专业的大学记录及其申请结果。
- en: Some of the views that we use in this demo are going to be the same views that
    we used in our demo showing how we define and query overviews。 but now we're going
    to be focusing on the ability to run modification commands against views。 Our
    first view is one of those。 It's called CS accept， and as before。 it contains
    the student ID in the college name where the student has applied to major and
    CS at that college。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中使用的部分视图将与我们在展示如何定义和查询概览时使用的视图相同。但现在，我们将专注于运行修改命令对视图进行操作的能力。我们的第一个视图就是其中之一，名为CS
    accept，和之前一样，它包含了学生ID和学生申请的大学及其主修专业（CS）。
- en: and the decision is yes。 We've now created the view， and we can take a look
    at its contents。 and we'll see that we have a few students who have been accepted
    to CS at a few colleges。 Now what we'd like to do is run a delete command against
    the view。 Let's say that we want to delete student one， two， three， the two records
    of student one， two。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是肯定的。我们已经创建了视图，可以查看它的内容，看到有一些学生已经被一些大学的CS专业录取。现在我们想要做的是对这个视图执行删除命令。假设我们想删除学生一、二、三，删除学生一和学生二的两条记录。
- en: three being accepted to major and CS。 So we would run that command like this，
    very simple。 delete from CS accept or student ID equals one， two， three， but when
    we run the command。 we get an error because SQLite does not allow us to modify
    views。 So here's the trigger that we're going to create to enable deletion commands
    to be run on the CS accept view。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将像这样运行命令，非常简单。`delete from CS accept where student ID = 1, 2, 3`，但当我们运行命令时，出现了一个错误，因为SQLite不允许我们修改视图。因此，这就是我们将要创建的触发器，它可以使删除命令在CS接受视图上运行。
- en: This trigger is going to intercept those deletions。 and it's going to translate
    them into deletions on the base data over which CS accept is defined。 So let's
    take a look at what we'd like to happen。 If a user asks to delete some data from
    the view。 and then again， let's go back and take a look at our view。 If the user
    wants to delete one， two。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个触发器会拦截这些删除操作，并将它们转化为对CS接受视图所定义的基础数据的删除操作。让我们看看我们希望发生什么情况。如果用户要求从视图中删除某些数据，然后再回到视图中。如果用户希望删除一、二。
- en: three， Stanford from the view， then what we'd like to be deleting is the apply
    records that gave us these tuples in the view。 So let's go take a look at the
    apply relation here。 and we'll see that this was the first record here where the
    student applied to CS at Stanford。 and the decision is yes， and the third record
    where this person， one， two， three。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从视图中删除了三，斯坦福，那么我们希望删除的是那些为我们提供这些元组的申请记录。让我们来看看这里的申请表，我们会发现这是学生申请斯坦福CS专业的第一条记录，且决定为“是”，第三条记录是这个学生（一、二、三）被接收为CS专业。
- en: applied to Berkeley and CS is yes。 We don't want to delete the other records
    for the student one。 two， three， because those weren't contributing to our CS
    accept view。 So we'd like to translate that deletion on the view into a deletion
    over apply such that the new value of the view no longer has those first two tuples
    for student one。 two， three。 So let's see how that's implemented by our trigger。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 申请伯克利并且专业为CS，决定为“是”。我们不想删除该学生的其他记录（例如，学生一、二、三的记录），因为那些记录并没有贡献到我们的CS接受视图。因此，我们希望将视图中的删除操作转化为对申请表的删除操作，这样视图中的新值就不再包含学生一、二、三的前两个元组。让我们看看触发器是如何实现这一操作的。
- en: Now the one important thing to know that happens， and this is the one real contribution
    the system makes to what we're doing here to enable view modifications。 is that
    we do have access to the deleted tuples。 So this trigger， it's actually a row
    level trigger。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一件重要的事情需要知道，那就是系统对我们所做的工作提供的一个重要贡献，它使得视图修改成为可能，那就是我们确实可以访问已删除的元组。所以这个触发器实际上是一个行级触发器。
- en: so it's going to be run once for each deleted row， and when we run the trigger。
    we will have this special variable old that contains the contents of the row to
    be that's the divisor。 So in the action portion of the trigger， we can refer through
    the variable old to the student ID and college name that are in the accept view
    as if we were really deleting that tuple from the view。 So again， let me reiterate，
    the system is going to bind two variable old。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每个已删除的行运行一次，当我们运行触发器时，我们将有一个特殊的变量`old`，它包含了被删除行的内容。所以在触发器的执行部分，我们可以通过变量`old`引用学生ID和大学名称，仿佛我们真的在视图中删除了那个元组。因此，我再重复一遍，系统将绑定一个变量`old`。
- en: the tuples to be deleted from the view using the schema of the view。 even though
    those tuples aren't physically in existence。 And we'll use the value from those
    to translate to the deletion we want to perform on the apply table。 Very specifically
    for the CS accept view， if we have a student ID college name combination to be
    deleted from the view。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除的元组将使用视图的模式，即使这些元组在物理上不存在。我们将使用这些值来翻译成我们希望在申请表上执行的删除操作。非常具体地，对于CS接受视图，如果我们有一个要从视图中删除的学生ID和大学名称组合。
- en: then what we'd like to delete from the apply table is the tuple that has that
    student ID。 that college name， a major of CS and a decision， yes。 So the person
    who writes this trigger。 which is presumably also the person who created the view。
    is going to use the combination of what was defined in the view， major equals
    CS in decision equals。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们想从申请表中删除的元组是包含该学生ID、大学名称、CS专业以及决定（是）的元组。因此，编写此触发器的人（推测也是创建视图的人）将使用视图中定义的组合，例如专业等于CS，决定等于“是”。
- en: yes。 Combine with the values that it's getting to be deleted from CS accept。
    I hope that makes some amount of sense。 So now that we've created this trigger。
    let's go back and let's try to perform our deletion operation again。 This time
    it looks like we had success， so let's go ahead and see what happened。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。结合它从`CS accept`中删除的值。我希望这个能有一定的理解。那么现在我们已经创建了这个触发器，让我们回到操作并尝试再次执行删除操作。这一次我们似乎成功了，所以让我们继续看看发生了什么。
- en: We go to our view manager and we see indeed those tuples are gone。 Now remember
    this table isn't actually stored， this when we look at the view it's actually
    running the view query against the data。 so when we look at the apply table we
    should also find， that's the really important thing。 that the tuples corresponding
    to 123 be accepted to CS are indeed gone。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入视图管理器，确实可以看到这些元组已经消失。现在记住，这张表并不是真正存储的，当我们查看视图时，它实际上是在对数据执行视图查询。所以当我们查看`apply`表时，我们应该也能发现，这才是最重要的事情，123对应的CS接受记录已经被删除。
- en: And it's the deletion of these tuples from apply that causes the tuples to be
    deleted from the view。 and that was the deletion on apply was because we installed
    this trigger that intercepted the deletion on the view and translated to the deletions
    on the base tables。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这些元组从`apply`表中删除会导致这些元组从视图中被删除。这是因为我们安装了一个触发器，它拦截了视图中的删除操作并将其转化为基础表的删除操作。
- en: So that worked out pretty well。 Now let's suppose we want to enable update commands
    on our view。 Let's say we want to change this student 345's acceptance to CS at
    Cornell to be an acceptance to CS at Carnegie Mellon University instead。 So here's
    the update command that we run。 It's very simple。 We find student ID 345 and we
    change the college name to CMU and we're updating the view CS accept。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这次操作进行得相当顺利。现在假设我们想在视图上启用更新命令。假设我们想将学生345在康奈尔大学的CS接受更改为卡内基梅隆大学的CS接受。那么这是我们运行的更新命令，非常简单。我们找到学生ID
    345，将大学名称更改为CMU，并更新视图中的CS接受。
- en: Of course when we run this we again get an error because SQLite won't allow
    us to perform an update command on a view except if we have a special instead
    of trigger that intercepts that command and translates it。 So that's what we'll
    do next is create a trigger。 So here's the trigger but what I'm going to demonstrate
    with this trigger is that nothing is forcing the trigger writer to actually do
    the right thing when a modification is translated to the base tables。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们运行这个命令时，我们再次会遇到错误，因为SQLite不允许我们对视图执行更新命令，除非我们有一个特殊的`instead of`触发器来拦截该命令并将其转化。所以接下来我们将创建一个触发器。这个触发器我要演示的是，在将修改转化为基础表时，并没有任何强制措施要求触发器的编写者必须正确处理。
- en: So we are going to intercept updates to the CS accept view and in fact you might
    remember from triggers that we can be even more specific with update triggers
    and say which column is updated。 So this particular trigger is only going to update
    is only going to intercept commands that are trying to update the college name
    column of the CS accept view。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拦截对`CS accept`视图的更新，实际上你可能还记得触发器，我们可以在更新触发器中更具体地指定哪一列被更新。所以这个特定的触发器只会拦截试图更新`CS
    accept`视图中大学名称列的命令。
- en: And then it's going to translate them to update the apply table。 Now what we
    have when this trigger is run and again is run once for each roving updated is
    we have old and new that are bound to the old value of the updated view tuple
    and the new value of the updated view tuple。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将转化为更新`apply`表。当这个触发器被运行时，它会为每个被更新的记录执行一次，这时我们有旧值和新值，分别绑定到更新视图元组的旧值和新值上。
- en: And only the college name will have changed in this case。 So we're going to
    update the apply relation and we're going to set the college name to be the new
    college name and that's going to be for the tuple where we have the old student
    ID and the old college name that finds the tuple to update。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有大学名称会发生变化。所以我们将更新`apply`表中的关联，并且我们会把大学名称设置为新的大学名称，这将应用于具有旧学生ID和旧大学名称的元组，用来查找需要更新的元组。
- en: However whoever wrote this got a little whack-o and instead of writing the condition
    that it's applications to CS where the decision is yes。 they've made it applications
    to EE where the decision is no。 But nothing prevents us from writing this trigger
    which performs this incorrect translation。 So now that the trigger is installed
    we can run our update command。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，写这个触发器的人有点不太对劲，他们没有写正确的条件，而是写了针对 EE 专业且决策为 no 的应用条件，应该写的是针对 CS 专业且决策为 yes
    的条件。但没有什么能阻止我们写这个触发器，它会执行这个错误的翻译。因此，触发器安装后，我们可以执行更新命令。
- en: Before we do that let's just go look again and remind ourselves what we have。
    We have 345 is applied to Cornell and we're trying to change that to be Carnegie
    Mellon。 And in our apply relation we have 345 is applied to Cornell CS yes that's
    why 345 is in the view 345 also by the way has applied to Cornell for EE and the
    decision on that one was no。 So back to our update command now we'll run the command
    and now that we have our trigger installed the command succeeds and let's go see
    what's happened to our database。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行之前，让我们再看一遍，提醒自己目前的状态。我们看到 345 申请了康奈尔大学，我们想把它改成卡内基梅隆大学。在 apply 表中，345 申请了康奈尔大学
    CS 专业，并且决策是 yes，这就是为什么 345 会出现在视图中的原因。顺便提一下，345 也申请了康奈尔大学的 EE 专业，而且那个决策是 no。所以回到我们的更新命令，执行命令后，由于触发器已经安装，命令成功执行，让我们看看数据库发生了什么变化。
- en: Here we are in CS accept and nothing has changed 345 has still applied to Cornell。
    We wanted it to be CMU but we wrote the wrong trigger so it did the wrong thing。
    Specifically if we go look at apply now we see that this record here this apply
    record has actually been updated so our trigger went in and modified that core
    record。 So we want to modify that Cornell to be CMU because it matched the major
    being EE and the decision being no。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看的是 CS 录取视图，什么都没有变化，345 仍然申请了康奈尔大学。我们原本希望是卡内基梅隆大学，但我们写错了触发器，导致执行了错误的操作。具体来说，如果我们去查看
    apply 表，我们会看到这条记录被更新了，因此我们的触发器修改了原始记录。所以我们想把康奈尔大学改为卡内基梅隆大学，因为它匹配的是专业 EE 且决策为 no。
- en: So again what I'm emphasizing here is that it is important to write the correct
    translation and nothing in the system is checking that that is the correct translation。
    Of course the correct translation would be if we wrote CS here and decision equals
    yes that would be the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我再次强调的是，写正确的翻译非常重要，并且系统并不会检查翻译是否正确。当然，正确的翻译应该是，如果我们在这里写的是 CS，并且决策等于 yes，那样就是正确的。
- en: Whoops decision equals yes here would be the correct trigger that we'd like
    to install to manage updates on the college name of the CS acceptability。 So far
    we've been looking at the CS accept view and we've looked at deletions and updates
    now we're going to look at insertions and we'll look at a somewhat different view。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，决策等于 yes 是我们希望安装的正确触发器，用来管理计算机科学专业录取的学院名称更新。到目前为止，我们一直在查看 CS 录取视图，已经查看了删除和更新，现在我们将查看插入操作，并且我们会查看一个稍微不同的视图。
- en: This is a view of the IDs， college names and majors of students who have applied
    to major in either CS or EE。 Now let's take a look at the contents of our view
    in CSE and we see we have quite a number of students who have applied to major
    in EE or CS and the colleges to which they've applied。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个视图，显示了已申请计算机科学（CS）或电子工程（EE）专业的学生的 ID、学院名称和专业。现在我们来看看 CSE 视图的内容，我们看到有相当多的学生申请了
    EE 或 CS 专业，以及他们申请的学院。
- en: Now let's suppose we want to insert a new tuple into this view so we want student
    111 to have applied to Berkeley in CS。 We run the command and of course we're
    going to get an error because we haven't yet installed a trigger that intercepts
    insertions into the view called CSE。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要向这个视图中插入一个新的元组，因此我们希望学生 111 申请了伯克利大学的计算机科学专业。我们执行这个命令，当然会出现错误，因为我们还没有安装一个拦截视图插入操作的触发器，视图的名字叫做
    CSE。
- en: So here's the trigger and this one's pretty straightforward。 It says instead
    of inserting on the view and again the system will provide to us the users intended
    insertion on the view in the variable called new as part of the trigger。 So instead
    of inserting into the view we'll insert into the apply table the student ID。 the
    college name， the major and then we'll put in null for the decision。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是触发器，它非常简单。它说，替代在视图上执行插入操作，系统会在触发器中通过一个叫做 new 的变量提供用户意图的插入内容。因此，替代在视图上插入数据，我们会插入到
    apply 表中，插入学生 ID、学院名称、专业，然后将决策字段设置为 null。
- en: With that trigger installed we can now go back to enter insert and perform it
    and take a look at the contents of our view。 So here's our new tuple that we wanted
    inserted into the view。 Again this is not a stored table this is just a result
    of a query over apply but it's there as we wanted it to be and if we take a look
    at the apply table we'll see that 111 was inserted with Berkeley CS and a null
    value for the decision。 But now let's see where things can go wrong our trigger
    was blissfully simple but what if we put here that 222 is going to apply to Berkeley
    in biology and we try to insert that tuple into our view called CSE that's supposed
    to be CS and E majors。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了触发器后，我们现在可以回到插入模式并执行它，查看我们视图中的内容。所以这是我们希望插入到视图中的新元组。再强调一次，这不是一个存储表，它只是通过应用查询的结果，但它正如我们所希望的那样存在，如果我们查看应用表，我们会看到
    111 已经插入了 Berkeley CS 并且决策字段是空值。但现在让我们看看问题可能出在哪里，触发器虽然简单，但如果我们在这里输入 222 将申请到 Berkeley
    生物学，并尝试将该元组插入名为 CSE 的视图（本应为 CS 和 E 专业），会发生什么？
- en: So let's go ahead and run that insertion and everything went fine let's take
    a look at our data。 Well here's our view and nothing changed our attempted insertion
    apparently didn't happen。 Well here's our insertion we inserted a biology major
    so in some sense that's good we don't want our biology major to show up in our
    view。 On the other hand our insertion trigger was activated and if we go ahead
    and look at the data specifically the apply relation we'll see that we did get
    a tuple inserted into apply that tuple just didn't show up in our view because
    it didn't satisfy the condition。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们继续执行插入操作，一切顺利。我们来看一下我们的数据。好吧，这是我们的视图，什么也没变，我们的插入尝试显然没有发生。这里是我们插入的内容，我们插入了一个生物学专业的学生，从某种意义上来说，这很好，因为我们不希望生物学专业的学生出现在我们的视图中。另一方面，我们的插入触发器被激活了，如果我们查看数据，特别是应用表中的数据，我们会看到确实插入了一个元组，尽管它没有出现在视图中，因为它不满足条件。
- en: So presumably we don't want users to be able to write insertion commands against
    a view that affect the underlying database but don't get reflected in the view
    because they shouldn't be in the view in the first place。 So we need to write
    a better trigger to handle insertions into this particular view。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们大概不希望用户能向视图写入插入命令，这些命令会影响底层数据库，但不会反映在视图中，因为它们本来就不该出现在视图里。因此，我们需要编写一个更好的触发器来处理此特定视图中的插入操作。
- en: So we're going to drop the trigger that we wrote and create a new one and this
    one is going to use the when clause of triggers it's the first time we've used
    it in this demo and it's going to check that the tuple that the user is attempting
    to use the trigger。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将删除我们写的触发器，创建一个新的，这个触发器将使用触发器的 when 子句，这是我们在本演示中第一次使用它，它将检查用户尝试使用触发器的元组。
- en: The user is attempting to insert into the view has a major that's CS or a major
    in that's EE。 If the attempted insert doesn't have CS or EE as a major then the
    trigger won't do anything but if it does then it will insert into apply the student
    ID name and major。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户尝试插入视图中的元组时，必须是 CS 或 EE 专业的学生。如果插入的元组不是 CS 或 EE 专业，那么触发器将不做任何操作，但如果是，那么触发器会将学生的
    ID、姓名和专业插入应用表中。
- en: Now that we've fixed up our trigger let's go back to our insertion command we've
    already done damage with student 222。 So let's try student 333 this time let's
    attempt to insert the student and then let's see what happened。 If we go to the
    view that student is not in the view which is a good thing because it's a biology
    major but most importantly we hope that nothing happened to the apply table and
    just to be sure we refresh and we see that indeed nothing got inserted。 So that's
    the case that we would like and maybe we'd like an error message to be generated
    but certainly if the user attempts to insert into the view a tuple that doesn't
    belong in the view we wouldn't like the database to be altered。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修正了触发器，让我们回到插入命令。我们已经对学生 222 做了插入尝试。那这次我们尝试学生 333，尝试插入该学生，然后看看发生了什么。如果我们查看视图，会发现该学生不在视图中，这很好，因为他是生物学专业的学生，但最重要的是我们希望应用表没有发生变化，为了确认，我们刷新了一下，发现确实什么都没有插入。所以这是我们希望看到的情况，或许我们希望生成一条错误信息，但如果用户尝试插入一个不属于视图的元组，我们当然不希望数据库被修改。
- en: Now let's suppose instead that student 333 asks to major in EE。 Now when we
    run the command we should see in our view that the student has shown up and indeed
    they have so that insertion was intercepted and the underlying modification was
    made to the apply table so that the view is not in the view。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设学生333申请了电气工程（EE）专业。现在当我们执行命令时，我们应该在视图中看到这个学生，确实他出现了，因此插入操作被拦截，并且基础表中的数据也被修改了，从而视图中不再显示该学生。
- en: So we've seen examples of triggers to intercept now deletions。 updates and insertions
    to views and do the right thing of modifying the underlying base tables so that
    the view gets the desired modification。 The next phase of the video is going to
    show a few examples quickly where we'll define views that have ambiguous modifications
    in fact where we might not even want to allow users to modify the contents of
    the view at all。 So our first view demonstrates that when a view includes aggregation
    it's probably not sensible to allow users to modify it。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过一些拦截触发器的例子，现在包括删除、更新和插入操作，它们会对视图进行相应的修改，确保对基础表的修改能够反映到视图上。视频的下一部分将快速展示几个例子，在这些例子中，我们将定义一些含有模糊修改的视图，实际上，我们甚至可能不希望允许用户修改视图的内容。因此，我们的第一个视图演示了，当视图包含聚合时，允许用户修改它通常是没有意义的。
- en: This view finds for each high school size the average GPA of students who went
    to a high school of that size。 So we'll create the view， we'll go and take a look
    and let's see what it contains。 So here are the contents of that view。 It has
    the different size high schools represented in our database and the average GPA
    of students who went to a high school of that size。 So does it make sense for
    a user to modify this view？
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图为每个高中规模找到了去过该规模高中的学生的平均GPA。因此我们将创建这个视图，接着查看它的内容，看看它包含了什么。这里是这个视图的内容。它包含了我们数据库中不同规模的高中，以及去过该规模高中的学生的平均GPA。那么用户修改这个视图有意义吗？
- en: I mean maybe would a user want to write a command that says update the view
    and set the average GPA to 3。6 for the high school size is 200？ So going back
    and looking here we want to change this average GPA to 3。6。 How would we have
    a rule for modifying the underlying data to change the average GPA？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，用户是否会想写一个命令，更新视图并将平均GPA设置为3.6，适用于高中规模为200的情况？回到这里，我们想把这个平均GPA修改为3.6。我们如何制定规则来修改底层数据，以更改平均GPA呢？
- en: It really isn't very sensible and making insertions and deletions to this view
    well maybe we translate deletions to translate to delete every student who went
    to a high school of that size but that's probably not what we want。 So fundamentally
    when a view includes aggregation it usually doesn't make sense to allow users
    to perform modifications on that view。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，在这个视图上进行插入和删除操作并不太合理。也许我们可以将删除操作翻译为删除所有去过该规模高中的学生，但这可能不是我们想要的。因此，根本来说，当视图包含聚合时，通常不应该允许用户对该视图进行修改。
- en: Aggregation views are most useful just for running queries。 Here's an even simpler
    view where we may not want to allow users to make modifications。 This view just
    lists all the majors that are represented in our apply relation。 So we'll create
    the view and take a look at it and we see that we have seven different majors
    in our relation。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合视图最有用的地方通常是执行查询。这里是一个更简单的视图，在这个视图中，我们可能不希望允许用户进行修改。这个视图仅列出了我们申请关系中所有的专业。因此我们将创建这个视图并查看它，我们看到在我们的关系中有七个不同的专业。
- en: Now would it make sense for a user to say I want to add a new major to that
    view so I'd like to have students who have applied to the chemistry major？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果用户说我想向这个视图中添加一个新的专业，比如想要查看申请化学专业的学生，这样的请求有意义吗？
- en: Well certainly looking at the view it would be no big deal to put chemistry
    in here but what would be the underlying change to the database？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，查看这个视图时，把化学专业加进去也没有什么大不了的，但这对数据库的底层结构会有什么影响呢？
- en: Who would be the student that's applied to that major and at what college？
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 谁是申请该专业的学生，在哪个学院？
- en: So in this case what makes it not very sensible to update this view is mostly
    that we're just taking one column out of our table and also that we're eliminating
    duplicates from that column。 So to think how to translate this to the underlying
    base data we'd have to add a lot of new values for columns just to begin with
    and maybe there would be multiple tuples contributing to a new tuple in the apply
    relation。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为什么不太合理更新这个视图，主要是因为我们只是从表中选取了一列，而且我们正在消除该列中的重复项。所以，若要将其翻译到底层的基础数据，我们首先需要为列添加很多新值，可能还会有多个元组贡献到应用关系中的一个新元组。
- en: Again you know we might allow deletions we could potentially say if we delete
    a major then we delete every application to the major but that may not be what's
    intended by creating the view。 So when we have projections onto a few columns
    or we have the distinct keyword that's another example where we may not want to
    allow users to perform modifications to the view。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们可能允许删除操作，我们可能会说如果删除一个专业，那么就删除该专业的所有申请，但这可能不是创建视图时的预期。因此，当我们对少数几列进行投影，或者使用了
    `distinct` 关键字时，这又是一个我们可能不希望用户对视图进行修改的例子。
- en: And here's our third and last example along these lines this one's actually
    the most complicated one。 The viewer we're creating now called Non-unique is going
    to give us all student tuples where there's some other student who has the same
    GPA and the same high school and it's a different student。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们沿着这个思路看到的第三个也是最后一个例子，这个实际上是最复杂的一个。我们现在要创建的视图叫做 Non-unique，它将返回所有学生的元组，其中有其他学生拥有相同的
    GPA 和相同的高中，而且这些学生是不同的。
- en: So you may want to refresh your sequel to remind yourself how this works。 Let's
    go ahead and create the view and take a look at what's in it。 Here we find that
    there are three students who some other where some other student has the same
    GPA and size high school and in fact all three have the same GPA and size high
    school which is not surprising in our small data set。 So let's suppose that the
    user decides that they don't want Amy in this view so they try to run the command
    delete from the non-unique view where the student name is Amy。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能需要刷新你的 SQL 语句来提醒自己这是如何运作的。让我们继续创建视图并查看其中的数据。这里我们发现有三个学生，其中有些其他学生拥有相同的 GPA
    和高中，事实上这三位学生的 GPA 和高中都是相同的，这在我们的小数据集里并不奇怪。那么，假设用户决定不希望 Amy 出现在这个视图中，所以他们尝试运行命令，从
    Non-unique 视图中删除名字为 Amy 的学生记录。
- en: So what deletion should be performed or what modification should be performed
    to the underlined data in order to get Amy out of the view。 Well of course we
    could delete Amy herself and that might be the most sensible but if we deleted
    Doris here and the other Amy I forgot to point out these are two different Amy's。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应该对底层数据执行什么删除操作，或者对视图中的数据执行什么修改操作，以将 Amy 从视图中移除呢？当然，我们可以直接删除 Amy 这个记录，这可能是最合理的做法，但如果我们删除
    Doris 和另外一个 Amy，我忘了提到，这其实是两位不同的 Amy。
- en: So we could delete this one 654。 If we deleted Doris and the other Amy then
    this Amy would be deleted from the view too。 So there's something a little subtle
    going on in this particular example。 We are asking to delete from a view that
    just selects from students so you might think oh well there's a one to one math
    thing so let's just delete the students that we're asking to have taken out of
    the view。 But because the sub query references the same relation as the outer
    query deleting a tuple reference in the outer query also affects the result of
    the sub query which can feedback into what's in the outer query。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以删除这个 654。如果我们删除 Doris 和另一个 Amy，那么这个 Amy 也会从视图中被删除。这个例子里有一些微妙之处。我们请求从一个只从学生表中选择数据的视图中删除数据，你可能会想，“哦，这里是一个一对一的映射，那就直接删除我们请求从视图中删除的学生记录吧。”但是，由于子查询引用了与外部查询相同的关系，删除外部查询中的元组引用也会影响子查询的结果，这可能会反过来影响外部查询中的数据。
- en: So it's this interaction between the two references of the table that makes
    it pretty tricky to figure out how a modification to the view should be mapped
    to a modification to the base table。 So we've seen three examples where it doesn't
    make a lot of sense to allow users to write modifications commands against the
    view。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正是这两个表中引用的交互关系，使得确定如何将视图的修改映射到基础表的修改变得相当棘手。我们已经看到了三个例子，在这些例子中，允许用户对视图执行修改命令并没有太大意义。
- en: And those are based on constructs in the view definition。 And actually we're
    going to see those same constructs pop up when we talk about what the SQL standard
    says about views that are allowed to be modified。 But I do want to remind you
    that in this video we're talking about writing triggers that enable modifications
    to views。 And so really for all the views that I showed you we could choose to
    write triggers that intercept the modifications and perform some modifications
    on the base table。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于视图定义中的构造。实际上，我们将在讨论SQL标准关于允许修改的视图时看到这些相同的构造。但是我确实想提醒你，在这段视频中，我们讨论的是编写触发器来启用视图的修改。因此，对于我展示的所有视图，我们可以选择编写触发器，拦截这些修改并对基础表进行某些修改。
- en: But probably that translation would not make a lot of sense。 And that's the
    point I'm trying to make。 Not that you can't do it when you have the power of
    writing instead of triggers but that you probably don't want to do it because
    it probably doesn't make sense in the application。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种翻译可能并没有太大意义。这正是我想要表达的重点。并不是说在拥有代替触发器的能力时你不能这样做，而是你可能不希望这样做，因为这在应用中可能没有意义。
- en: Now let's return to views that we do want to allow to be modifiable。 And so
    we're going to enable that through instead of triggers。 And the next example is
    more complex because it involves a join of two tables。 This view is called Burke
    and it returns student IDs and majors where the student has applied for that major
    at Berkeley。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们希望允许修改的视图。因此，我们将通过“代替触发器”来启用这个功能。下一个例子更为复杂，因为它涉及到两个表的连接。这个视图被称为伯克利视图，它返回学生ID和专业，表示该学生已申请伯克利大学的该专业。
- en: We'll create the view， we'll take a look at its contents and we'll see that
    we have two students who have applied to Berkeley。 One to major in biology and
    one to major in computer science。 Some of our other students have gotten deleted
    from our database along the way through our examples by the way。 So let's say
    that we want to enable insertions into this view。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建视图，查看它的内容，我们会看到有两个学生申请了伯克利。一位申请生物学专业，另一位申请计算机科学专业。顺便提一下，我们的一些其他学生已经在我们举例的过程中从数据库中被删除了。所以假设我们希望启用对这个视图的插入操作。
- en: So we want to be able to insert a pair that's a student ID and a major and then
    insert into our underlying tables in some fashion so that that tuple is now in
    the view。 So what we're going to do is assume that when someone wants to insert
    into this view they're inserting for an existing student and we'll actually check
    that's the case。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们希望能够插入一对数据，即学生ID和专业，然后以某种方式插入到我们的基础表中，这样该元组就会出现在视图中。那么我们将假设，当有人想要向这个视图插入数据时，他们插入的是一个已存在的学生，我们将实际检查是否确实如此。
- en: So if we have an existing student and we're inserting into the view then all
    we need to do is add a tuple to the apply relation that says that they are applying
    to Berkeley for the major that's specified in the insertion we've asked for on
    the view。 So we'll write that as a trigger。 So here's a trigger it says instead
    of inserting on the Burke relation for each row again we'll get one instance of
    a trigger for each inserted row。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一个已存在的学生并且我们正在插入到视图中，那么我们所需要做的就是向申请关系中添加一个元组，表示他们正在申请伯克利大学的某个专业，这个专业是根据我们在视图中请求的插入内容来确定的。我们将通过触发器来实现这一点。这里是一个触发器，它表示：对于每一行的插入操作，我们会为每个插入的行触发一次。
- en: We'll check first of all that the student ID of the inserted tuple and again
    new is bound to the inserted tuple the student the tuple the user wants to insert
    into view Burke。 We'll check that that student does exist in the student relation。
    If they don't exist in the student relation we're just not going to do anything
    with the requested insert。 If they already exist in the student relation then
    we can insert into apply the student's ID Berkeley because we know this is the
    view for students who have applied for applications to Berkeley。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会检查插入的元组的学生ID，并且确保新的元组与插入的元组绑定，查看用户想要插入的元组是否符合条件。我们将检查该学生是否存在于学生关系中。如果该学生不存在于学生关系中，我们将不会对请求的插入进行任何操作。如果该学生已经存在于学生关系中，那么我们就可以将学生ID插入到申请表中，因为我们知道这是一个申请进入伯克利的学生视图。
- en: The major that they're applying for and null for the decision。 So instead of
    demonstrating just a single tuple being inserted I'm going to do something a little
    more complicated and ask to insert a whole bunch of tuples into Burke and we're
    going to see that each of those tuples is going to result in an insertion into
    the apply table underneath and of course the desired insertion into the view。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 他们申请的专业是 `null`，决定结果也是 `null`。所以，我并不只是展示一个元组被插入，而是做一些稍微复杂一点的操作，要求一次插入一批元组到伯克利视图中，我们会看到这些元组中的每一个都将导致
    `apply` 表中的相应插入记录，并且当然，也会按预期插入到视图中。
- en: So the way that I'm going to generate a batch of tuples to be inserted into
    the view is to run a sub query and the sub query is going to take all student
    IDs that are not in the apply table for Berkeley。 So students who have not yet
    applied to Berkeley and we're going to for each one ask that we insert into the
    view that student and a psychology major application to Berkeley。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我生成一批元组插入视图的方法是执行一个子查询，这个子查询会获取所有在 `apply` 表中没有记录的伯克利学生 ID。也就是说，尚未申请伯克利的学生，我们将为每一个学生插入该学生的心理学专业申请记录到视图中。
- en: So let's first take a look at our apply table to see who's going to be applying
    to Berkeley for psychology。 So we have 2， 3， 4 who's applied to Berkeley already
    in 9， 8， 7 and they're in our view。 By the way if you're wondering why these three
    students down here didn't appear in our view it's because these were inserted
    as an artifact of our demo and we never inserted matching student tuples。 So these
    aren't going to participate in the joint。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下 `apply` 表，看看哪些学生将申请伯克利的心理学专业。所以我们有 2、3、4 号学生已经申请了伯克利，还有 9、8、7 号学生也在我们的视图中。顺便提一下，如果你在想为什么这三个学生没有出现在我们的视图中，那是因为这些是作为演示的产物插入的，我们并没有插入匹配的学生元组。所以这些学生不会参与联合查询。
- en: So we just have two students in our joint all the rest of the students here
    who haven't applied to Berkeley are now going to apply to Berkeley in psychology
    as a result of us running that insert command that's going to be intercepted by
    our trigger。 So here's the trigger。 Here's the insert command。 Let's go ahead
    and run the insert and now let's take a look and see what happened。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在在联合查询中只有两个学生，所有其他尚未申请伯克利的学生，现在都将因为我们执行了插入命令而申请伯克利的心理学专业，这个插入命令会被我们的触发器拦截。接下来是触发器的内容，接下来是插入命令。让我们运行插入命令，然后看看发生了什么。
- en: We go to Berkeley and we do see indeed a whole bunch of psychology majors now
    in our view and of course that's because we should have a whole bunch of psychology
    majors now in our apply relation and here they are。 So back to our view what if
    we now want to enable users to delete from the view。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去看伯克利的视图，确实看到一大批心理学专业的学生已经出现在视图中了，当然，这是因为我们的 `apply` 表中现在应该有一大批心理学专业的学生记录，正如我们所看到的那样。回到视图，如果现在我们希望启用用户从视图中删除记录怎么办呢？
- en: We're going to again assume that the intention is not to delete the student。
    The student ID table is going to say stay stable and what we're going to do is
    we're going to delete the corresponding applications。 So here's the trigger to
    do that。 It's activated by deletions on the Burke view and the system again will
    bind the desired deleted tuples from the view to the reserved variable old。 So
    the action part of that trigger will delete from apply where the student ID matches
    the one to be deleted。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次假设我们的目标不是删除学生。学生 ID 表将保持稳定，我们要做的是删除相应的申请记录。所以这是实现这一操作的触发器。它是通过在伯克利视图上的删除操作触发的，系统会将视图中已删除的元组绑定到预留变量
    old。因此，该触发器的操作部分将删除 `apply` 表中与被删除学生 ID 匹配的记录。
- en: The college name is Berkeley because that's what we're looking for。 That doesn't
    come from the deleted tuple。 That's not present in the view but we know that that's
    a condition from the view definition。 And the major has to match the desired deleted
    major。 So we'll ask to delete from Berkeley all the records where the major is
    CS。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大学名称是伯克利，因为我们要查询的就是伯克利。这并不是来自已删除的元组，也不在视图中，但我们知道这是视图定义中的条件。而且专业必须与已删除的目标专业匹配。所以我们会要求删除伯克利所有专业是
    CS 的记录。
- en: So let's go ahead first and take a look at the view and we see that we have
    just one so we'll expect this tuple to be deleted from the view but that's going
    to happen because we're going to delete the corresponding apply record underneath。
    So we'll go ahead and execute the deletion。 We'll take a look first at the view。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们首先查看视图，我们看到我们只有一个记录，所以我们预计这个元组会从视图中删除，因为我们将删除对应的 `apply` 记录。我们将执行删除操作，并首先查看视图。
- en: make sure that that person that CS is gone and it is， and then we'll go look
    at apply。 We forgot to look at it in the first place but I think it was student
    987 and now 987 has no longer applied to Berkeley。 And finally let's enable updates
    to our Burke view。 Probably doesn't make sense to update the student ID but we'll
    allow updates to the major。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保那个计算机科学专业的学生已经删除了，然后我们查看 `apply` 表。我们在一开始忘记查看它，但我认为是学生 987，现在 987 已经不再申请伯克利了。最后，让我们启用对伯克利视图的更新。可能没有意义去更新学生
    ID，但我们将允许更新专业。
- en: So we'll have a student who applied to Berkeley in psychology。 I decide they
    want a major in something else。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个学生申请了伯克利的心理学专业。我决定他们想换一个其他专业。
- en: '![](img/33021a3a111aaaa798f0a452f51b7087_7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33021a3a111aaaa798f0a452f51b7087_7.png)'
- en: So here's the trigger and this one is going to intercept updates to the major
    on Berkeley so it won't intercept updates to the student ID and again now we'll
    have the old and new values bound to the old and new imaginary tuples of Burke。
    It's going to update the apply relation。 It's going to find the record where we
    have the student ID in our update。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是触发器，它将拦截伯克利专业的更新，因此它不会拦截学生 ID 的更新。现在我们将把旧的和新的值绑定到伯克利虚拟元组的旧值和新值。它将更新 `apply`
    关系，并找到我们更新中的学生 ID 记录。
- en: This could be old student ID or new student ID since its value isn't changing。
    So we find the student ID we care about their application to Berkeley for the
    old major and we'll change that to be applying to the new major。 So let's take
    all those psychology majors and let's turn them into physics majors。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是旧的学生 ID 或新的学生 ID，因为它的值不会改变。因此，我们找出我们关心的学生 ID，他们在伯克利申请旧专业的记录，然后将其修改为申请新专业的记录。所以我们将把所有心理学专业的学生转变为物理学专业的学生。
- en: '![](img/33021a3a111aaaa798f0a452f51b7087_9.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33021a3a111aaaa798f0a452f51b7087_9.png)'
- en: So with this one update command we'll be asking to update most of the tuples
    in the Burke view。 Each tuple one at a time will be intercepted by our trigger
    and it will modify the apply table for the corresponding record and turn the psychology
    major into physics。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过这一个更新命令，我们将要求更新伯克利视图中的大多数元组。每个元组都会被我们的触发器逐个拦截，它会修改对应记录的 `apply` 表，并将心理学专业改为物理学。
- en: We'll run the command and we'll take a look at what happened。 Here's our view
    and we see indeed that all the psychology majors have turned into physics majors
    and of course that's a result of the modifications to the underlying table apply
    where again we've seen that all the psychology is in the middle。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行命令并查看发生了什么。这里是我们的视图，我们可以看到，确实所有的心理学专业都已经变成了物理学专业，当然这是由于对底层 `apply` 表的修改所导致的，我们再次看到中间的所有心理学专业记录已经变更。
- en: All the psychology is changed to physics。 Now back to our view I said we weren't
    going to allow modifications to the student ID and the trigger that we wrote only
    intercepted modifications to the major。 So let's see what happens if we try to
    modify the student ID。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的心理学专业都已经变成物理学专业。现在回到我们的视图，我之前说过我们不允许修改学生 ID，而我们写的触发器只会拦截专业的修改。那么如果我们尝试修改学生
    ID，会发生什么呢？
- en: Here's a command that tries to set three to one to one to three in our Burke
    view。 If we run the query then we do get an error because we didn't implement
    any translation for modifications to that column。 The last portion of our demonstration
    is going to demonstrate the interaction between view modifications and constraints。
    So I'm going to drop my apply table and create a new version of it where we add
    to the decision column a constraint that the column is not allowed to be null。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个命令，它试图在我们的伯克利视图中将三比一设置为一比三。如果我们运行查询，会出现一个错误，因为我们没有为该列的修改实现任何翻译。我们演示的最后部分将展示视图修改与约束之间的交互。所以我要删除我的
    `apply` 表，并创建一个新的版本，在其中我们为决策列添加了一个约束，要求该列不允许为空。
- en: Now let me remind you of a view we created a long time ago called CSE that took
    the students colleges and majors where the student had applied to major in CS
    or EE。 And let's look specifically at the trigger that we created to handle insertions
    into this view。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: So you might remember or you might not that we first created an incorrect trigger
    but here's the one that we have activated。 And the important thing to notice is
    that it intercepts insertions into the view and then it inserts into apply a tuple
    that contains the student ID。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: the college name and the major and then puts null for the decision。 And this
    is where our troubles are going to occur because we've now created a version of
    apply that doesn't allow null for a decision。 So let's try inserting into our
    CSE view the values one to three Berkeley and CS and that will translate to an
    insertion to apply of the same values and null for a decision。 We run the insertion
    and we get the constraint violation。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: So what happened is the insertion into the view was intercepted by the trigger
    translated to an insertion into apply but that insertion generated a violation
    against our not null constraint on the decision column。 So it's doing the right
    thing but we'll never be able to insert into the CSE view now because we're always
    going to attempt to insert null values。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: So if we want to have that not null constraint on the apply relation we'll have
    to modify our translation for CSE so that it doesn't generate the null values。
    And here's a second example along the same lines。 We're going to drop apply again
    and create a new version of apply。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: This time we're going to allow null values and decisions so we've taken away
    that not null constraint but we've added a key constraint to apply saying that
    the combination of student ID。 college name and major must be unique。 So a student
    can't apply twice to the same college for the same major。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: So because we've created a new apply relation it's starting out empty but let's
    insert some tuples what we're going to insert into the apply relation via the
    CSE view and it's trigger。 So we'll insert student one two three applying to Berkeley
    for CS and Berkeley for EE and again we're inserting these into the view。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We'll run that we'll take a look at our view and we'll see that where is it。
    Here we go。 CSEE has the two tuples that we inserted of course those were intercepted
    by the trigger and created insertions into apply and here's the apply relation
    which looks exactly the same but with the decision as null。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now what we're going to do next is actually insert into one of our other views。
    I don't know if you remember the Berkeley view but that was the IDs and majors
    of students who had applied to Berkeley and let's go take a look at what happens
    when we try to insert into the Berkeley view。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Here's the trigger we wrote to handle insertions into Berkeley。 When the student
    that we're trying to insert does exist then we'll insert a record into apply having
    that student apply to Berkeley for the major that's specified in the insertion
    and a null decision which again is fine now because。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们编写的触发器，用于处理向伯克利插入数据的操作。当我们尝试插入的学生已存在时，我们将插入一条记录到apply表，表示该学生申请伯克利，并指定插入中的专业，同时决策为null，这在现在是可以的，因为……
- en: we remove that non-null constraint。 So we're going to try to insert into Berkeley
    student one two three majoring in EE and we're going to see that that's actually
    going to violate our key constraint。 So let's go ahead and we get a non-unique
    constraint because that attempted to insert into the apply table。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了那个非空约束。因此，我们将尝试向伯克利学生表插入一条记录，学生编号为一二三，专业为EE，我们将看到这实际上会违反我们的主键约束。因此，让我们继续操作，我们会收到一个非唯一约束错误，因为试图插入到apply表中。
- en: Let's go look at that table。 It attempted to insert into apply one two three
    Berkeley EE and that would have violated the constraint that we can only have
    one tuple for a student ID college name and major combination。 So again our attempt
    to insert into the view was translated oops that's the earlier insert sorry our
    attempt to insert into the Berkeley view was translated into an insertion into
    apply that violated the constraint。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个表。它试图插入一条记录到apply表，学生编号一二三，专业为伯克利EE，这会违反约束：每个学生ID、学校名称和专业组合只能有一条记录。因此，再次尝试插入到视图中时，实际上是转换为插入到apply表，并且违反了约束。
- en: And as a grand finale let's try an update on our Burke view so let's suppose
    that we want student one two three to major in CS in both applications to Berkeley
    and that will generate an update to the underlying apply table that should violate
    our constraint。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后作为盛大结局，让我们尝试更新伯克利视图。假设我们希望学生一二三在伯克利的两个申请中都选择CS专业，这将生成对底层apply表的更新，应该会违反我们的约束。
- en: Just as a reminder let's take a look at what happens when we try to run an update
    command on the major of the Burke view。 Here's our trigger that we wrote a while
    ago it intercepts updates to Burke and it translates them to update the apply
    relation find the appropriate record where it's an application to Berkeley matching
    the old major and the student ID and it changes it to the new major。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，让我们看看当我们尝试更新伯克利视图中的专业时会发生什么。这里是我们之前编写的触发器，它拦截对伯克利的更新，并将其转换为更新apply表中的记录，找到与旧专业和学生ID匹配的申请记录，并将其更改为新专业。
- en: So we're going to try to update a Burke we're going to try to set let's find
    it here we're going to try to set the major equals CS for student ID one two three。
    So if we take a look at what it's going to try to do the to to the apply relation
    it's going to try to set these majors both to CS and that will give us again a
    key constraint violation。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将尝试更新伯克利视图，尝试将学生编号一二三的专业设置为CS。如果我们查看它尝试在apply表中执行的操作，它会试图将这两个专业都设置为CS，这将再次导致主键约束违规。
- en: So let's go ahead and try to run the command against Burke it'll translate to
    an update on apply and that update won't be allowed。 So that completes our demonstration
    of enabling view modifications using triggers。 So this demonstration was all run
    on the SQLite system the SQLite system does not allow any modifications commands
    on views directly so we saw every time we tried that we got an error and the only
    way that a user can run modifications overviews is if we have in place the special
    instead of triggers that intercept the modifications that are attempted on the
    views and translates those to modifications on the base table。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们继续操作，尝试在伯克利视图上运行命令，它将转换为对apply表的更新，而该更新将不被允许。因此，这完成了我们使用触发器启用视图修改的演示。这个演示是在SQLite系统上运行的，SQLite系统不允许直接对视图进行任何修改命令，因此每次我们尝试时都会出现错误，用户只能通过使用特殊的替代触发器来拦截对视图的修改，并将其转换为对基础表的修改。
- en: Now the system when it does process the triggers generates for the modifications
    on the views what the data would be in terms of binding those modifications the
    old and new variables that are available in triggers but the rest of the process
    is up to the user to write the actions that will be will take place when these
    are attempts to do a modification on a view。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当系统处理触发器时，它会为视图上的修改生成数据，这些数据会绑定这些修改，包含在触发器中可用的旧变量和新变量，但其余的过程由用户编写操作，这些操作将在尝试对视图进行修改时发生。
- en: And as we saw there's no checks in place to make sure that the user writes correct
    modifications that result in correct view updates however when the user does things
    correctly it can all work in a very powerful and correct fashion。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，系统没有检查机制来确保用户写出正确的修改，从而导致正确的视图更新。然而，当用户按正确的方式操作时，一切都能以非常强大且正确的方式运行。
- en: '![](img/33021a3a111aaaa798f0a452f51b7087_11.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33021a3a111aaaa798f0a452f51b7087_11.png)'
- en: fashion。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: fashion。
