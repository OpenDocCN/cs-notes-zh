- en: P27：16-02-olap-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P27：16-02-olap-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: In this video， we'll be doing a live demonstration of OLAP。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视频中，我们将进行OLAP的现场演示。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_1.png)'
- en: We'll create a star schema similar to the one we used in our previous examples。
    It will be sales data with a fact table and several dimension tables。 and then
    we'll do several different types of OLAP queries。 We'll show a full star join
    over the star schema。 We'll show some examples of drill down and roll up。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类似于我们之前示例中的星型架构。它将是销售数据，包括一个事实表和多个维度表，然后我们将执行几种不同类型的OLAP查询。我们将展示整个星型架构的星型连接，并展示一些钻取和汇总的示例。
- en: We'll also show what's known as slicing and dicing， which we haven't explained
    yet。 We'll just do when we get to those queries。 And finally， we'll show the width，
    cube。 and width roll up clauses， that have been added to the SQL standard for
    OLAP queries。 For those。 we'll be using MySQL。 Actually， for the whole demo， we'll
    be using MySQL。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将展示所谓的切片和切块操作，我们还没有解释过。等到我们做这些查询时就会介绍。最后，我们将展示SQL标准中针对OLAP查询新增的宽度、立方体和汇总操作。这些操作将使用MySQL进行演示。事实上，整个演示将使用MySQL。
- en: MySQL supports with roll up。 Neither of the other systems that we've been using，
    SQLite or Postgres。 supports with roll up yet。 And MySQL does not yet support
    with cube。 but we'll see that we can simulate the behavior of with cube。 using
    the width roll up command of MySQL。 So let's move to the demo。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持with roll up。我们使用的其他系统，SQLite和Postgres，目前还不支持with roll up。MySQL也尚不支持with
    cube，但我们将看到我们可以使用MySQL的with roll up命令来模拟with cube的行为。那么我们开始演示吧。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_3.png)'
- en: Here we are in the demo。 We have a fact table that contains information， about
    stores， items。 and customers。 We don't see much here except their ID values。 And
    we have 60 tuples loaded up in our fact table。 Our dimension tables are the customer
    table。 We have four customers with a gender and an age。 We have our item table，
    five items。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是演示部分。我们有一个事实表，包含有关商店、商品和顾客的信息。我们这里只看到他们的ID值。我们在事实表中加载了60个元组。我们的维度表是顾客表。我们有四个顾客，每个顾客有性别和年龄。我们有商品表，包含五个商品。
- en: a category of the item， just t-shirts and jackets just in blue and red。 And
    finally。 we have our stores。 And we have six stores that are in various cities
    in Santa Clara。 San Mateo County in California and King County in Washington。
    Our first query is simply the complete star join。 So we're joining all four tables
    using the foreign key。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 商品的一个类别，仅包括蓝色和红色的T恤和夹克。最后，我们有我们的商店。我们有六家商店，分别位于加利福尼亚州圣克拉拉、圣马特奥县和华盛顿州金县的不同城市。我们的第一个查询就是完全的星型连接。所以我们通过外键连接所有四个表。
- en: references in the fact table to the keys in the dimension tables。 Now。 since
    these are foreign key references， you can think of this star join as simply extending。
    the tuples in the sales table with further information， about the store， item。
    and customer mentioned in each one。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实表中对维度表中键的引用。由于这些是外键引用，您可以把这个星型连接看作是简单地将销售表中的元组扩展，加入有关每个元组中提到的商店、商品和顾客的进一步信息。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_5.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_5.png)'
- en: So here we go。 And we should expect again 60 tuples in the results。 one for
    each tuple in the fact table。 And we can see that we have the information from
    the fact。 table， but then we also have more information， that we've joined in
    from the dimension tables。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们开始吧。我们应该再次期望结果中有60个元组，每个元组对应事实表中的一行。我们可以看到我们从事实表中获得了信息，但我们也加入了来自维度表的更多信息。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_7.png)'
- en: Now， it's not typical to do the complete star join。 Usually we would at least
    constrain the star join in some way。 So our next query will do selections and
    projections， on the star join。 We're going to limit ourselves to sales， where
    the state of the sale is California。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完全进行星型连接并不常见。通常我们至少会对星型连接做一些约束。所以我们接下来的查询将对星型连接进行选择和投影。我们将限制查询只涉及销售，并且销售的状态是加利福尼亚州。
- en: the category is T-shirt， the age of the customer is less than 22。 And the last
    condition is actually over the fact table。 saying the price of the purchase was
    less than 25。 And that will return the city， color。 customer name， and price of
    the item。 We run the query and we see now that we have just five sales。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类别是T恤，顾客的年龄小于22岁。最后的条件实际上是基于事实表，说明购买价格低于25。这将返回城市、颜色、顾客姓名和商品价格。我们运行查询，现在看到只有五笔销售记录。
- en: that meet our criteria。 So we've seen the star join with constraints on the
    star， join。 but what's even more common in OLAP applications， is to do grouping
    and aggregation in order。 to analyze the data。 And we're going to start by looking
    at grouping。 and aggregation involving dimension attributes in the group。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些符合我们标准的内容。我们已经看到星型连接和在星型连接上的约束，但在OLAP应用中更常见的，是进行分组和聚合以便分析数据。我们将从查看涉及维度属性的分组和聚合开始。
- en: by and then the dependent attribute being aggregated。 This is a very common
    form of query。 So here we'll say we want to analyze our data based， on combinations
    of stores and customers。 So we'll group by store ID and customer ID， and then
    we'll sum up to see the total sales for each combination。 of store and customer。
    So here's our result。 Now， maybe not that meaningful to us right now。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是被聚合的依赖属性。这是查询中非常常见的一种形式。这里我们假设我们想要根据商店和顾客的组合来分析数据。所以我们将按商店ID和顾客ID进行分组，然后求和以查看每个商店和顾客组合的总销售额。这里是我们的结果。现在，可能目前对我们来说意义不大。
- en: just looking at these store ID and customer IDs， but for an analyst it might
    be meaningful。 We'll see in a moment doing group by and aggregation。 on other
    attributes that look a little more interesting。 So now I'll demonstrate the concept
    of drilling down。 So you might remember drilling down。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只查看这些商店ID和顾客ID，但对分析师来说，这可能是有意义的。稍后我们会看到，对其他更有趣的属性进行分组和聚合。现在，我将展示钻取的概念。所以你可能还记得钻取。
- en: says that we're looking at data that's aggregated。 in some fashion and we decide
    we want more detail。 We get more detail by adding more attributes to the group
    by。 So let's say in this case I want to break out not only， by store and customer，
    but also by item。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们正在查看某种方式聚合的数据，并且我们决定需要更多细节。我们通过向group by中添加更多的属性来获得更多细节。比如在这个案例中，我想按商店、顾客和商品进行细分。
- en: So I add item ID to the group by and also to the select。 And when I run this
    query I see that I get more results。 and I now have more detail in the analysis
    of the data。 Now I don't have 60 tuples in my result。 even though I'm grouping
    by all three dimension attributes。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将商品ID添加到group by中，并且也添加到select中。当我运行这个查询时，我看到结果变多了，分析的数据也更加详细。现在，即使我按所有三个维度属性分组，我的结果中也没有60个元组。
- en: because I do have in my fact table more than one tuple。 for some combinations
    of store item and customer。 Next I'm going to introduce a query that shows the
    concept。 called slicing。 Slicing of course evokes the data cube。 We talked about
    the data cube in the previous video， and we specifically use this example。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在我的事实表中，对于某些商店、商品和顾客的组合，确实有多个元组。接下来，我将介绍一个展示“切片”概念的查询。切片当然是与数据立方体相关的。我们在之前的视频中讨论过数据立方体，并且我们特别使用了这个例子。
- en: to demonstrate a three dimensional data cube。 So the idea of a slicing query
    is a query that。 analyzes a slice of the cube。 And it does that by constraining
    one of the dimensions。 So what I'm going to do is add to this query， a constraint
    that says let's only consider sales。 that are from the state of Washington。 And
    when I add that we'll continue to do the group。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用于展示三维数据立方体的查询。因此，切片查询的概念是分析数据立方体的一个切片。它通过约束某一维度来实现这一点。所以我要做的是，在这个查询中添加一个约束，表示我们只考虑来自华盛顿州的销售。当我添加这个约束后，我们会继续进行分组。
- en: by an aggregation but only on that slice of the cube， representing Washington
    stores。 the sales that， are from Washington stores。 So it made a few changes to
    the query。 The first thing we see is that I added the store relation， to the from
    clause。 In order to constrain the state of the sale， I have to join with the store
    table。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过聚合，但仅限于数据立方体中的这一部分，代表华盛顿州的商店。销售来自华盛顿商店。所以对查询做了一些修改。我们首先看到的是，我在from子句中加入了商店关系。为了限制销售的州，我必须与商店表进行连接。
- en: that dimension table， so that I can access the value of state， which。 is not
    present in the sales table。 So I also had to add variables and I。 add the join
    condition for the sales table， to join with the dimension table。 And then I add
    the constraint that the state is Washington。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 维度表，我可以访问到销售表中没有的州（state）值。因此，我还需要添加变量，并为销售表添加连接条件，使其与维度表连接。接着，我加上约束条件，确保州为华盛顿。
- en: The last small change is to add a variable to the store ID， so that I don't
    get an ambiguous error。 So now let's go ahead and run the query。 And we see that
    we do get a subset of what we had before。 And that subset is the slice of the
    data cube， if you want to think of it that way， representing。 the sales in Washington
    state。 Now in addition to slicing， there's also， a notion of dicing。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个小改动是为商店 ID 添加一个变量，这样我就不会遇到歧义错误了。现在，让我们继续运行查询。我们看到，确实得到了之前数据的一个子集。这个子集代表了华盛顿州的销售数据，如果你这样理解的话，这是数据立方体的一片切片。现在，除了切片之外，还有一个叫做“切丁”（dicing）的概念。
- en: And again， if you imagine the data cube， what a dice does is slice into dimensions。
    and it gives you a chunk of the cube。 So I'm going to add a condition on the item
    being sold。 I'm going to add that the item must be red。 So then I'm going to be
    looking at the chunk of the data。 cube that identifies red items purchased， in
    the state of Washington。 So here's the query。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，如果你想象数据立方体，切丁的作用是将立方体切分成多个维度，它会给你一个立方体的块。因此，我将添加一个条件，限制所售商品为红色。这样，我将查看华盛顿州购买的红色商品数据块。这里是查询。
- en: I've added a third relation to the from clause。 I added the item dimension table
    so that I。 can constrain the color to be red。 I've added a join condition joining
    the fact table。 to the item dimension table。 I've added the condition that the
    color is red。 And finally。 I had to add again the variable names， to make sure
    I didn't get ambiguous attribute references。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `from` 子句中添加了第三个关系。我添加了商品维度表，这样我可以将颜色限制为红色。我添加了连接条件，将事实表与商品维度表连接起来。我添加了条件，要求颜色为红色。最后，我还必须再次添加变量名，以确保不会遇到歧义的属性引用。
- en: So we'll run this query and we see， that we get an even smaller portion of the
    data cube。 Again。 a dice where we've constrained two dimensions。 So we've seen
    drilling down and slicing and dicing。 Now let's take a look at rolling up。 Rolling
    up says that we're looking at our data analysis。 and we decide that it's too detailed。
    We want to have less detail。 In other words， more aggregation。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行这个查询后，会发现我们得到的数据立方体的一部分比之前更小了。再次是一个切丁操作，我们约束了两个维度。我们已经看过钻取、切片和切丁。接下来，让我们看一下汇总操作。汇总表示我们在进行数据分析时，认为数据太过详细，希望降低细节层次。换句话说，更多的聚合。
- en: To do that， we take attributes out of the group by clause。 So let's say this
    is way。 way too much detail。 And we just want our sales broken down on item。 So
    we take all of the attributes out of our group， by clause except for item。 Here
    we go。 And then when we run the query， we'll， see much more summarized data。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们通过 `group by` 子句提取出属性。假设这是一个过于详细的方式。我们只希望按商品来划分销售数据。因此，我们从 `group
    by` 子句中移除所有属性，保留商品属性。好了，接下来当我们运行查询时，您会看到更加汇总的数据。
- en: And here it is broken down again just by separate items。 So far， our grouping
    and aggregation。 has been on the dimension attribute。 Specifically， the ID attributes
    identifying the tuples。 in the dimension table。 And that may be meaningful for
    analyses。 But for this demonstration。 it's more， fun to look at attributes that
    actually mean something to us。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次按单独的商品进行拆分。到目前为止，我们的分组和聚合基于维度属性，具体来说是标识元组的 ID 属性，存在于维度表中。这对于分析可能有意义。但对于这个演示，更有趣的是查看那些对我们实际有意义的属性。
- en: So let's try a few queries that group instead， based on attributes in the dimension
    tables。 we'll still be using the fact table。 We'll be joining with dimension tables。
    And here we're going to start by grouping， on the state and the category of the
    sales。 Again。 summing up the total sales for the different groups。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们尝试一些查询，基于维度表中的属性进行分组。我们仍然会使用事实表，并且会与维度表进行连接。我们将从按州和销售类别进行分组开始，再次对不同组别的总销售额进行求和。
- en: So here we see that we have four combinations of state， and category-- California，
    Washington。 jackets， and t-shirts。 And then we have the total sales in each of
    those。 So we can see in both states that the sales for jackets。 account for considerably
    more than the sales for t-shirts。 But we do also notice that in California。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到有四种州和类别的组合——加利福尼亚、华盛顿、夹克和T恤。然后我们看到了每种组合的总销售额。我们可以看到，在这两个州中，夹克的销量明显高于T恤。但我们也注意到，在加利福尼亚州，
- en: there's a lot more sales of t-shirts， than there are in Washington。 And I guess
    that's not surprising given the weather。 Now let's demonstrate drill down on this
    query。 So let's say we want a little more information。 Maybe we want to break
    down by county in addition to state。 So to do that， we add county to the group
    by clause， and a select clause。 And when we run the query。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在华盛顿州，T恤的销量要多得多。我想这并不令人惊讶，考虑到天气。现在，让我们演示一下如何在这个查询上进行下钻。假设我们想要更多的信息，也许我们希望除了州之外，还能按县进行划分。为了做到这一点，我们需要在`group
    by`子句和`select`子句中添加县。然后我们运行查询。
- en: we see we do now have more detail。 We can see， for example， that we had more
    jackets--。 sales in Santa Clara County than in San Mateo County。 although the
    t-shirts were approximately equal。 A little， actually， more t-shirts in San Mateo。
    This is a little surprising because Santa Clara is generally， warmer than San
    Mateo。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到现在我们有了更多的细节。例如，我们可以看到，圣克拉拉县的夹克销售量要高于圣马特奥县，尽管T恤的销量大致相等。实际上，圣马特奥的T恤稍微多一些。这有点让人惊讶，因为圣克拉拉通常比圣马特奥温暖。
- en: but it's fabricated data。 Now let's say we want to drill down even further。
    and we want to break our data down by gender， as well as the other attributes。
    In order to drill down based on gender， I first needed to add the customer table
    to our from clause。 Prior to this， we weren't doing any analysis that involved，
    any attributes of the customer table。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是伪造的数据。现在，假设我们想进一步下钻，我们希望根据性别以及其他属性来拆分数据。为了基于性别进行下钻，我首先需要将客户表添加到`from`子句中。在此之前，我们没有进行任何涉及客户表属性的分析。
- en: And so I need to add the joint condition here， and then to do the drill down。
    I add the gender attribute， to the group by and to the select。 We run the query。
    and what do we find？ Well， we can see， for example， that not too many females。
    in San Mateo County are buying t-shirts。 Most of those t-shirt sales are counted
    for by males。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我需要在这里添加连接条件，然后进行下钻。我将性别属性添加到`group by`和`select`中。我们运行查询，结果怎么样？我们可以看到，例如，圣马特奥县的女性买T恤的数量不多。大多数T恤的销售来自男性。
- en: The other thing we notice is that we， don't have every single combination of
    county， category。 and gender。 Very specifically， we look and we， can see that
    no males in King County bought any t-shirts。 So we only have， in our result， those
    combinations。 of dimension values that actually appear in the fact table。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的另一件事是，我们并没有每一个县、类别和性别的所有组合。非常具体地说，我们查看后发现，金县的男性没有购买任何T恤。因此，我们的结果中只包含那些实际上出现在事实表中的维度值组合。
- en: or in the join of the fact table with the dimension tables。 Now let's suppose
    after I've gotten to this level of analysis。 I've decided that what might be most
    interesting， is the data broken down just by combination of state and gender。
    So that would be a roll-up operation。 And remember， for roll-up， I take attributes
    out。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在事实表和维度表的连接中。现在假设在进行到这一层次的分析后，我决定，可能最有趣的是将数据按州和性别的组合来拆分。这将是一个roll-up操作。记住，对于roll-up，我需要从`group
    by`子句中移除属性。
- en: of the group by clause。 So I take out the county and category。 and I'm just
    interested in state gender combinations。 By the way， at this point， if I wanted
    to。 I could remove the item table because I'm， no longer constraining based on
    items or grouping based on items。 But I'll just leave it in for now。 It's not
    going to make a difference in our result。 Of course。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我移除了县和类别，且只对州和性别的组合感兴趣。顺便提一下，在这一点上，如果我想的话，我可以移除项目表，因为我不再基于项目进行约束或基于项目进行分组。但我现在就留着它吧，它不会对我们的结果产生影响。当然。
- en: for efficiency， I might prefer to take it out。 Anyway， let's run the query。
    And now we see that rolled up data。 And when we look at it， I guess our main conclusion
    here。 would be that in our database， the California males， are the big spenders。
    So far。 everything we've seen has actually just， used the regular SQL constructs
    that we already knew about。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，我可能更倾向于将其移除。无论如何，让我们运行查询。现在我们看到的是汇总数据。当我们查看它时，我猜我们的主要结论是：在我们的数据库中，加利福尼亚的男性是大消费者。到目前为止，我们所看到的一切实际上都是使用我们已经熟悉的常规SQL构造。
- en: Although we were demonstrating them over a star schema， and we are showing the
    types of queries。 that one tends to run over star schemas in OLAP applications。
    Now we're going to move to the specific constructs that， have been added to SQL
    for OLAP。 As you may remember， the two constructs， are called withCUBE and withRollUp。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们是在一个星型模式上演示它们，并且我们展示的是在OLAP应用程序中，通常会在星型模式上运行的查询类型。现在我们将转向SQL中为OLAP添加的特定构造。正如你可能记得的那样，这两个构造分别叫做withCUBE和withRollUp。
- en: and they are written in the group by clause。 So our first query is the absolute
    basicCUBE query。 We start with our sales fact table。 We group on all three of
    its dimensions。 and then we add withCUBE。 And what we're going to get is basically
    the data。 in the data cube that we saw in our previous video that， introduced
    the cube。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是在group by子句中编写的。因此，我们的第一个查询是最基本的CUBE查询。我们从我们的销售事实表开始，对它的三个维度进行分组，然后添加withCUBE。我们得到的基本上是数据立方体中的数据，这是我们在前一个视频中看到的，介绍了立方体的内容。
- en: So let's go ahead and run the query。 Disappointingly， we get an error message
    that。 says this version of MySQL doesn't yet supportCUBE。 Actually， no version
    of MySQL supportsCUBE。 at this point in time， but we're hopeful that a future
    one， will。 In fact。 of the three open source systems， that we've been using for
    our demos。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们继续运行查询。不幸的是，我们收到了一条错误信息，显示这个版本的MySQL还不支持CUBE。实际上，目前没有任何版本的MySQL支持CUBE，但我们希望未来的版本会支持。事实上，我们在演示中使用的三种开源系统中，只有其中一种支持CUBE。
- en: only MySQL supports the withRollUp。 So we will continue with MySQL。 And in fact。
    you can get the same result， that you would get if withCUBE were supported using
    withRollUp。 Although it's a little bit contorted， but I'll do that now to demonstrate
    what you would get。 if you wrote withCUBE。 So here's the query。 I'm not going
    to explain it if you're particularly。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 只有MySQL支持withRollUp。因此，我们将继续使用MySQL。事实上，你可以得到与支持withCUBE时相同的结果，使用withRollUp。尽管这有点绕，但我现在会展示一下，如果你写withCUBE时会得到什么结果。下面是查询。我不会解释，除非你特别需要。
- en: interested in it。 You can download our script and examine it yourself。 Again。
    what I'm most interested in is looking at the results。 And here they are。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对它感兴趣。你可以下载我们的脚本并自行检查。再说一次，我最感兴趣的是查看结果。结果就在这里。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_9.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_9.png)'
- en: So this result is the result of a withCUBE， on the grouping and aggregation
    on all dimensions。 of our sales table， all three dimensions。 So some of our tuples
    look very normal。 This first tuple。 second and third tuple， are all giving us
    the total price for a combination of store， item。 and customer。 And these are
    exactly what we got in our original query。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个结果是通过withCUBE，针对我们销售表的所有维度进行分组和聚合的结果，涵盖了所有三个维度。所以我们的一些元组看起来很正常。第一个元组，第二个和第三个元组，都给出了店铺、商品和顾客组合的总价。这些正是我们在原始查询中得到的结果。
- en: that didn't have the withCUBE operator。 But now we see some tuples that have
    blanks。 And as a reminder， blanks in this interface mean null。 So this tuple is
    store， item， and null。 And what this corresponds to is an element， on the face
    of the cube。 So this is the face of the cube that's， not constraining the customer
    dimension。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那时没有withCUBE操作符。但现在我们看到一些有空白的元组。作为提醒，界面中的空白意味着null。所以这个元组是店铺、商品和null。它对应的是立方体的一个面。因此，这是立方体的一个面，没有限制顾客维度。
- en: And what the value gives us then is the value， we would have on the face of
    the cube， which。 is the total sales for the combination of store one， and item
    one and any customer。 And that's 70。 And we can actually cross check that， by
    seeing that the first three tuples add up to 70。 because those happen to be the
    three customers that， have made purchases at store one and item one。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个值给我们的就是立方体面上的值，即店铺一、商品一和任何顾客的总销售额。这个值是70。我们实际上可以通过看到前三个元组加起来正好是70来交叉验证这一点，因为这正好是三位在店铺一和商品一购买的顾客。
- en: And we can similarly see for store one and item two， the total sales are 150。
    If we scroll down a bit， we'll see cases， where we have other single null values。
    I'll keep going until I find one here。 For example， here we have the null value
    for the store。 And that would be the face of the cube that's， not constraining
    the store dimension。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以看到对于商店一和商品二，总销售额是150。如果我们再往下滚动一点，会看到其他只有单个空值的情况。我会继续，直到找到一个。比如，这里我们有一个空值是在商店上。这将是数据立方体的面，未约束商店维度的面。
- en: So that would be the sum for item one and customer one， at any store， item one
    customer to it。 any store。 Then we also have tuples that have two null values。
    Here's an example。 So this one is going to be corresponding， to the edge of the
    cube。 So this is the edge of the cube that， is along the store dimension and is
    picking out store five。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这将是任意商店中商品一和顾客一的总和，商品一顾客二在任意商店中的总和。然后，我们还有一些包含两个空值的元组。这里是一个例子。所以这个将对应于立方体的边缘。这是沿着商店维度的立方体边缘，挑选出了商店五。
- en: along that dimension and then giving the total sales， for all items and all
    customers in store five。 And we see that。 And again， we'll see other instances，
    where we're missing two values。 It gets scrolled down to get here。 We've got one
    where we're missing the store and the item。 So this would be on the edge along
    the customer dimension。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着那个维度，然后给出商店五中所有商品和所有顾客的总销售额。我们看到了这一点。再一次，我们会看到其他例子，其中缺少两个值。需要滚动下去才能看到这里。我们有一个缺少商店和商品的例子。所以这将在顾客维度的边缘。
- en: So this gives us the total sales for any store， item， by customer three。 And
    then finally。 if we find it， we'll find the one that's all three null values。
    And that's right here。 So that represents the corner of the cube。 That gives us
    the total for all stores， all items。 and all customers。 So what we've done here
    by adding with cube--， and again。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就得到了顾客三在任意商店和商品的总销售额。最后，如果我们找到了，它将是所有三个空值的情况。就在这里。所以它代表了立方体的角落。这给了我们所有商店、所有商品和所有顾客的总和。因此，通过添加`cube`，我们做的就是这个——再一次。
- en: it's really that would be the result， if the square here were supported--。 what
    we're getting is the contents of the data cube， which， are the inner parts of
    the cube， which。 is what we would get without adding anything to our group。 by
    what we saw in one of our very first queries of the demo--， in addition to the
    data on the faces。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是结果，如果这里的方形立方体被支持——我们得到的是数据立方体的内容，即立方体的内部部分，这也是我们在最初的查询中看到的内容——除了立方体面的数据。
- en: the edges， and the corner of the cube。 Now let's do a quick cross check。 So
    this data tells us that the corner of the cube here， the one with all null values。
    is a 3350 total price。 So that should be exactly what we get。 if we sum up our
    prices without doing any grouping， or aggregation。 So let's give that a try。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体的边缘和角落。现在让我们做一个快速的交叉检查。所以这些数据告诉我们，立方体的角落，这里所有空值的那一部分，是3350的总价。所以如果我们在没有做任何分组或聚合的情况下求和价格，应该正好是这个结果。让我们试试看。
- en: So we merely take our sales table， we sum up the total prices， and we run it。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们只需将销售表格拿出来，求和所有价格，然后运行它。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_11.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_11.png)'
- en: and indeed we get 3350。 So now we've seen how SQL can be used to effectively
    create， the data cube。 Sometimes in OLF applications， it's， convenient to query
    the cube directly。 So people frequently create data cubes， say in SQL using a
    materialized view。 or just by creating a table that contains the result， of the
    data cube。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果确实是3350。所以现在我们已经看到了SQL如何有效地创建数据立方体。有时在OLAP应用中，直接查询立方体是很方便的。因此，人们经常在SQL中创建数据立方体，例如使用物化视图，或者通过创建一个包含数据立方体结果的表。
- en: which is what we're going to do。 There are even some systems that use the data
    cube。 as their basic native data model。 So let's go ahead and take the result
    of our cube query。 and put it in a table。 So I've just added Create Table Cube
    as before our query。 And the one other thing I did was， add a name to the result
    of the aggregation attribute。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们要做的。有些系统甚至将数据立方体作为它们的基础本地数据模型。所以让我们继续，将我们的`cube`查询结果放入表格中。我刚刚添加了创建表格`Cube`，就像之前的查询一样。还有一件我做的事，就是给聚合属性的结果添加了名称。
- en: so that we can refer to it in the data cube。 So P then will be containing the
    sum of the price。 for the items inside the data cube， as well as for the faces，
    edges， and corners。 So let's go ahead and create that table。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在数据 cube 中引用它。接着，P 将包含数据 cube 中商品的价格总和，此外还包括 cube 的面、边和角的总和。所以让我们创建这个表。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_13.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_13.png)'
- en: And now let's look at querying the cube directly。 So the first thing you'll
    notice in the next few queries。 is that we've replaced the sales table with the
    cube table。 So we're going to run our queries directly on the cube。 and we can
    join the cube with the store and item tables， and the customer if we needed it。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们直接查询 cube。所以你会在接下来的几个查询中注意到，唯一的变化是我们将销售表替换为了 cube 表。因此，我们将直接在 cube 上运行查询，并且我们可以将
    cube 与店铺、商品表连接，甚至在需要时连接客户表。
- en: just as we joined the sales table， because it does contain the same dimension
    attributes。 What the cube gives us is pre-aggregated data， both for the store，
    a customer。 and item combinations， as well as the data that has no values that
    is already。 aggregated for the faces， edges， and corner of the cube， as we'll
    just see in a moment。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前连接了销售表一样，因为它确实包含相同的维度属性。cube 给我们提供的是预聚合数据，既包括店铺、客户和商品的组合，也包括那些没有值的数据，这些数据已经针对
    cube 的面、边和角进行了聚合，正如我们马上就会看到的。
- en: So what our query is going to do， is find total sales of blue items in the state
    of California。 I'm going to start by showing the tuples that are used， to get
    that total。 So we'll join our cube table with the store， and the item dimension
    tables in order。 to constrain the state and the color， and then we will constrain
    the state and the color。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的查询将做的事情是，找出加利福尼亚州蓝色商品的总销售额。我将首先展示用于获取该总额的元组。所以我们将按顺序将 cube 表与店铺和商品维度表连接，以便限制州和颜色，然后我们将限制州和颜色。
- en: And notice the last thing we say is that customer ID is no。 And that's going
    to give us the data that's， on the face of the cube that doesn't go along。 the
    customer dimension。 That means it's going to be pre-aggregated for all customers。
    And that's what we want， since we don't care about the customers。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们最后说的是客户 ID 为 `no`。这将给我们提供 cube 面上的数据，这些数据不涉及客户维度。这意味着这些数据已经为所有客户进行了预聚合。而这正是我们想要的，因为我们不关心具体的客户。
- en: and just about the color in the state。 So let's first run this query， and we
    see we get six tuples。 These tuples are all from the portion of the result。 of
    that cube query we ran that has a no value for customer ID。 And then it's all
    combinations of stores and items。 And if we checked our dimension tables。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后关于颜色和州的情况。首先让我们运行这个查询，我们看到得到六个元组。这些元组都是来自我们之前运行的 cube 查询结果的一部分，该部分的客户 ID 值为
    `no`。然后它是所有店铺和商品的组合。如果我们检查我们的维度表。
- en: we'd see that these stores are in California， and these items are blue。 And
    these are our total sales broken down by store and item。 Finally， to get the total
    total sales。 we'll just sum up our column P， which remember， was the sum of price
    in the data cube。 So we replace c。star with sum of P， and we run the query， and
    we see that our total is 1365。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这些店铺位于加利福尼亚州，这些商品是蓝色的。以下是按店铺和商品细分的总销售额。最后，为了得到总的销售额，我们只需将列 P 相加，记住 P 是数据
    cube 中价格的总和。因此，我们将 `c.star` 替换为 P 的总和，并运行查询，最后得到总销售额为 1365。
- en: Now let me show you something that may seem nonintuitive， at first， but if you
    think about it。 maybe run the queries， yourself， you'll start to understand exactly
    what's happening。 I'm going to go back to c。star in the select clause。 And incidentally，
    I didn't mention it before。 but c。star gives us in the select clause， all the
    attributes from the cube table。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我展示一些可能一开始看起来不太直观的东西，但如果你自己思考一下，甚至运行一下查询，你会开始理解到底发生了什么。我将回到 `c.star`，在选择子句中使用它。顺便提一下，我之前没有提到过，`c.star`
    在选择子句中为我们提供了所有来自 cube 表的属性。
- en: And that's showing which tuples are being， used for the aggregation。 So we had
    before six tuples that were being used。 Now I'm going to make one tiny change
    to the query。 Instead of finding the customer IDs that are no， I'm going to find
    the customer IDs that are not no。 I'm going to run that query， and I， see that
    we have 14 tuples now。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了用于聚合的元组。我们之前有六个元组被使用。现在我将对查询做一个小改动。不是查找客户 ID 为 `no` 的记录，而是查找客户 ID 不为 `no`
    的记录。我将运行这个查询，看到现在有 14 个元组。
- en: What we've actually done is moved away， from the face of the cube and into the
    cube。 And I've said。 don't give me any of the summarized data。 Just give me the
    original values that are the store item。 and customer together。 So I've taken
    away the summaries。 but actually this should still give me the same answer。 And
    let's make sure that's the case。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们所做的就是离开了数据立方体的表面，进入了数据立方体。我已经说过，不要给我任何汇总数据。只给我商店、商品和客户的原始值。所以，我去掉了汇总数据，但实际上这仍然应该给我相同的答案。我们来确保这一点。
- en: I do sum of P， and I run it， and I can get 1365。 So what happened here is I
    used what's effectively the same data。 but broken down by customer， and I added
    it up。 That was a less efficient query。 but both of those queries， do give the
    correct result。 They do give you the total sales of California stores， or blue
    items。 Again。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我对P求和，然后运行，结果是1365。所以这里发生的事情是，我使用了本质上相同的数据，但按客户拆分，并进行了求和。这是一个效率较低的查询，但这两个查询都给出了正确的结果。它们确实给出了加利福尼亚州商店或蓝色商品的总销售额。再次强调。
- en: I encourage you to download these and run them， yourself to figure out exactly
    what's going on。 And as a last demonstration of this very same query， we can actually
    go back to the sales table。 Let's say we don't even have our data cube。 So we're
    going to use our sales table instead。 and it should give us the same result， but
    even less efficient than the last query that we did。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你下载这些并亲自运行，搞清楚到底发生了什么。作为对这个相同查询的最后演示，我们实际上可以回到销售表。假设我们甚至没有数据立方体。那么我们将使用销售表来代替，结果应该是相同的，但比我们之前做的查询效率低。
- en: So you can see here that I've changed the cube， to be the sales and all the
    C dots to F dots。 I took away the constraint on being null or not null， since
    that's not relevant in the sales table。 Otherwise， the query looks pretty much
    the same。 So let's run this much and see how many tuples。 we're operating on now。
    So now we're operating on 25 tuples。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我已经将数据立方体改为销售表，并将所有的C点替换成F点。我去掉了是否为null的约束，因为在销售表中这并不相关。除此之外，查询看起来基本相同。现在我们运行这个查询，看看我们现在正在操作多少个元组。现在我们操作的是25个元组。
- en: So this is the original completely broken down data。 Just as a reminder， in
    the data cube。 even in the cells， we'll be summarizing or summing for the combination，
    of store item and customer。 So if we have three tuples that are the same store
    item， and customer。 those will be broken out in the sales table， and summarized
    in the cube。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始的完全拆解数据。作为提醒，在数据立方体中，即使是在单元格中，我们也会对商店、商品和客户的组合进行总结或求和。所以，如果我们有三个相同商店、商品和客户的元组，这些会在销售表中拆分出来，并在数据立方体中汇总。
- en: even in the least summarized， portion of the cube， if you get what I'm saying。
    So now we've got our 25 tuples， and if we sum up， the price of those 25 tuples。
    we should get that same result， 1365， and we do。 So we saw that we had six tuples
    in the most efficient query。 over the data cube。 When we used just the center
    portion of the cube， we had 14 or something。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在数据立方体中最不简化的部分，如果你理解我的意思。现在我们有了25个元组，如果我们对这25个元组的价格进行求和，我们应该得到相同的结果，1365，结果确实是这样。所以我们看到，在最有效的查询中，我们只用了六个元组来查询数据立方体。当我们只使用数据立方体的中心部分时，我们有14个元组左右。
- en: I actually don't remember the exact number。 And then 25， all of them gave us
    the same answer。 Obviously， these numbers are very small。 But if you think about
    huge data that has millions。 or tens of millions of rows， then we're， talking
    about dramatic differences in how much data needs。 to be summarized or aggregated
    in order to get the answer。 So using the summary data from the cube。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上不记得确切的数字了。然后是25个，所有这些都给我们相同的答案。显然，这些数字非常小。但是如果你考虑到拥有数百万或数千万行数据的庞大数据集，那么我们就在谈论在获取答案时需要总结或聚合的数据量的巨大差异。所以，使用数据立方体中的汇总数据。
- en: can be orders of magnitude faster than going， to the original fact data。 Now。
    a variation on the width cube， is to give specific attributes with the cube operator
    itself。 And what that says is to only give summaries， for these dimension attributes
    and not the others。 In other words， we'll only see null values in the result，
    for the store ID and customer ID。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这比直接查询原始事实数据快几个数量级。现在，宽数据立方体的一种变体是直接在数据立方体操作符中给出特定属性。它的意思是只对这些维度属性进行汇总，而不是其他属性。换句话说，在结果中，我们只会看到商店ID和客户ID的null值。
- en: And we won't see any null values for the item ID。 So in some sense， we're materializing
    just some。 of the faces， edges， and corner of the cube， not all of them。 If we
    run this query， well。 we'll get the same results， that MySQL doesn't yet support
    it。 But this is the SQL standard for the cube operator。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会看到项目 ID 的空值。所以在某种意义上，我们仅对立方体的一些面、边和角进行具体化，并不是所有的。如果我们运行这个查询，嗯，我们会得到相同的结果，MySQL
    目前还不支持它。但这就是 SQL 标准中的立方体操作符。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_15.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_15.png)'
- en: with subsets of attributes。 As before， I've cooked up an equivalent query。 using
    a MySQLs with rollup command。 And I'm certainly not going to explain it。 but you're
    welcome to download it and examine it。 What I really like to look at is the result。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性的子集。像以前一样，我编写了一个等效的查询，使用了带有 rollup 命令的 MySQL。 当然，我不会解释它，但你可以下载并查看它。我真正想看到的是结果。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_17.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_17.png)'
- en: And here it is。 So this looks a lot like our original data cube。 But what we
    will notice is that there， are no null values in the item column。 So it's a subset
    of the result of the cube query。 And we would use that when we know we're never。
    going to be rolling up on items。 So that dimension is--， the summaries based on
    that dimension。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下。这看起来和我们原始的数据立方体非常相似。但我们会注意到，项目列中没有空值。所以它是立方体查询结果的一个子集。当我们知道自己永远不会对项目进行汇总时，我们就会使用这个维度。所以基于这个维度的汇总就是如此。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_19.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_19.png)'
- en: aren't going to be useful to us。 Now let's look at width rollup， which。 is supported
    natively by the MySQL system。 Width rollup again gives us a subset of the data
    cube。 But it's a very specific one。 And it's based on the ordering of the attributes。
    in the group by clause。 So let me just go ahead and run it， and explain what we
    get。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说不会有太大帮助。现在，让我们来看一下 width rollup，这是 MySQL 系统本地支持的功能。width rollup 给我们提供了数据立方体的一个子集，但它是一个非常特定的子集。它基于
    group by 子句中属性的排序。让我直接运行它，并解释我们得到的结果。
- en: We again get null values。 And those null values indicate the summary。 For example。
    the store one item one and 70， is the sum of prices for all customers for store
    one， and item one。 And we see store one item two as well。 We again see cases with
    two null values。 So this is the summary for store one， all of the items and customers，
    the total sales。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到空值。这些空值表示汇总。例如，商店一，项目一，70 是商店一和项目一所有客户的价格总和。我们也可以看到商店一项目二。我们再次看到包含两个空值的情况。所以这是商店一所有项目和客户的汇总，表示总销售额。
- en: And we also have the triple null somewhere。 That's at the bottom this time。
    with that total sales of 33。50。 But what we'll see is that we don't have all combinations。
    of null values。 We have a null value for customer ID。 or we have nulls for the
    combination of customer ID， and item ID， or all three null。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会看到某些地方有三个空值。这个空值出现在底部，表示总销售额为 33.50。但我们会看到的是，我们没有所有空值组合。我们有客户 ID 的空值，或者客户
    ID 和项目 ID 组合的空值，或者全是空值。
- en: So we only have the right-hand attribute， or the two most right attributes or
    all of them。 And if we had a fourth dimension， we'd see we'd have the right-most，
    two-right-most。 three-right-most。 So this doesn't really make any particular sense
    for this query。 but it's used when we have dimensions that are hierarchical。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们只拥有最右边的属性，或者最右边的两个属性，甚至是所有属性。如果我们有第四个维度，我们会看到最右边的两个、三个、甚至更多属性。所以对于这个查询而言，这并没有什么特别的意义，但它在具有层次化维度时使用。
- en: And I actually introduced a hierarchical dimensions， in our original schema
    just for this purpose。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我在我们原始的架构中引入了层次化维度，正是为了这个目的。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_21.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_21.png)'
- en: So let's turn to that query。 So here's a query that's grouping， by the state，
    county， and city。 These are three dimension attributes。 They all come from the
    store dimension table。 And they are hierarchical， meeting， that we don't have
    every combination of state， county， and city。 We have cities that are in specific
    counties， and counties that are in specific states。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来看这个查询。这个查询是按州、县和市进行分组的。这三个是维度属性，全部来自商店维度表。它们是层次化的，意味着我们没有州、县和市的所有组合。我们有属于特定县的城市，也有属于特定州的县。
- en: So when we look at the results of the query， we see， of course， that when we
    have San Mateo。 it's always in the state of California。 King County is always
    in the state of Washington。 We don't have Palo Alto combined with， say， King County
    with state California。 So we don't have all the combinations of the three。 We
    have a hierarchical structure on them。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们查看查询结果时，我们当然会看到，当我们有圣马特奥时，它总是在加利福尼亚州。金县总是在华盛顿州。我们没有看到帕洛阿尔托与，比如说，金县和加利福尼亚州组合在一起。所以我们没有所有三者的组合。我们有它们的层次结构。
- en: And it's this structure that makes sense when we use a roll up。 So let's add
    with roll up to this query and see what we get。 So here in our result。 we see
    our original tuples， for a state， county， city combination。 And then we see， for
    example。 this tuple here， which， is taking the state of California and county
    of San Mateo。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 而正是这种结构使得我们在使用上卷时能够理解。所以让我们在这个查询中添加`with roll up`，看看会得到什么。在我们的结果中，我们看到原始的元组，表示州、县、市的组合。然后我们看到，例如，这个元组，它表示加利福尼亚州和圣马特奥县。
- en: and adding up all of the sales there。 And we see， similarly， that we have all
    the sales。 for Santa Clara County。 Then we can see that we have all of the sales
    for each state。 So this is the California sales and the Washington sales。 And
    finally。 the triple null is the corner of the cube。 It's all of our sales。 And
    as usual。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并且对所有销售额进行了汇总。我们还看到了类似的情况，展示了圣克拉拉县的所有销售额。然后我们可以看到各个州的所有销售额。所以这就是加利福尼亚州的销售额和华盛顿州的销售额。最后，三重空值是数据立方体的角落，它代表了我们所有的销售额。和往常一样。
- en: we get the total of 33。50。 Now， what don't we see in here compared with the
    data cube？ Well。 we don't see， for example， a tuple that， has California and Palo
    Alto and the county as null。 Why is that？ Well， Palo Alto is always in Santa Clara
    County。 So rolling up that the county or saying， I want California and Palo Alto
    sales for every county。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的总和是33.50。那么，与数据立方体相比，我们在这里看不到什么呢？嗯，我们看不到一个元组，它有加利福尼亚州、帕洛阿尔托和县为空的情况。为什么呢？因为帕洛阿尔托总是在圣克拉拉县。所以滚动上去（即选择）县，或者说，我想要加利福尼亚州和帕洛阿尔托在每个县的销售额。
- en: is exactly the same as saying， I want California and Palo Alto， sales in Santa
    Clara County。 We also don't see， for example， the state and county， both being
    null。 For example。 if we had Seattle as a city and the state and county， being
    null， well。 Seattle is always in King County， and always in Washington。 So we're
    not aggregating anything there。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与说“我要加利福尼亚州和帕洛阿尔托在圣克拉拉县的销售额”是完全一样的。我们还没有看到，例如，州和县都为空的情况。例如，如果我们有西雅图这个城市，州和县都为空，那么，西雅图总是在金县，总是在华盛顿州。所以我们在那里没有进行任何汇总。
- en: We get the exact same result as having Seattle King in Washington。 So if we
    ran with cube on this hierarchically structured data。 we'd actually not get any
    more information。 We'd have a bigger result， but it wouldn't。 be giving us more
    information。 It would just be less efficient for getting the same data。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果与在华盛顿州使用西雅图金县是完全相同的。所以，如果我们在这个层次结构的数据上使用`cube`，我们实际上不会获得更多的信息。我们会得到一个更大的结果，但它并不会给我们更多的信息。它只是使得获取相同数据的过程变得更低效。
- en: So that concludes our OLAP demonstration。 We saw a star schema， and we saw plain
    SQL queries。 over that schema。 We saw the concept of drilling down and rolling
    up， also slicing and dicing。 We introduced the with cube extension to SQL， which
    is not， yet implemented in MySQL， but we were。 able to write a query that's equivalent
    to with cube。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的OLAP演示。我们看到了星型架构，也看到了基于该架构的简单SQL查询。我们了解了下钻和上卷的概念，也包括切片和切块。我们引入了SQL中的`with
    cube`扩展，它还没有在MySQL中实现，但我们能够编写一个与`with cube`等效的查询。
- en: We also saw putting with cube query into a table， and then querying that table
    directly。 And that can be much more efficient， than running the equivalent query
    in SQL directly。 over the fact table。 We also saw with OLAP， which is implemented。
    We didn't demonstrate putting the result of with OLAP， in a table。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了将`with cube`查询放入表格中，然后直接查询该表格。这比直接在事实表上运行等效的SQL查询要高效得多。我们还展示了已实现的OLAP功能，但我们没有演示将`with
    OLAP`的结果放入表格中。
- en: but we could certainly do that too。 All of these features are useful primarily
    in applications。 that are performing analyses over very large data sets。 that
    exhibit this dimensional type structure。 But this is actually quite a common structure。
    in analysis applications。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们当然也可以做到这一点。所有这些功能主要用于处理执行大规模数据集分析的应用程序，这些数据集表现出这种维度类型的结构。但这种结构实际上在分析应用中非常常见。
- en: '![](img/ea1a92387a8b601c91c5e9409fe50977_23.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1a92387a8b601c91c5e9409fe50977_23.png)'
