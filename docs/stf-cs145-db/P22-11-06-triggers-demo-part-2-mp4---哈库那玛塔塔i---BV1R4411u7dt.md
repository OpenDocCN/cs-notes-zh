# P22：11-06-triggers-demo-part-2.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

如果你已经完成了演示的第一部分，展示了触发器的内容，我们现在进入第二部分。

![](img/6cb78d1fae7c69689e799fa280d93b57_1.png)

两个。作为提醒，我们关于触发器的介绍视频使用了SQL标准，但没有数据库系统完全实现这个标准，大多数系统有很大的偏差。Postgres是最接近的，并且是最具表现力的触发器系统。然而，它的语法比较繁琐，所以我们没有在演示中使用它。

SQLite遵循Postgres，并且也非常灵活。相比之下，MySQL则表现得较为有限，主要体现在触发器的交互上存在一些限制。

![](img/6cb78d1fae7c69689e799fa280d93b57_3.png)

所以，作为提醒，我们的演示使用的是SQLite，且与标准有一些差异。它只支持行级触发器，没有语句级触发器，并且具有立即激活的语义。每行都可以在触发器中指定，但如果没有指定，仍然是行级触发器。由于它只有立即激活语义，所以没有old table或new table。

它没有引用子句。在每个触发器中，变量old和new会自动绑定到如果有引用子句时的old.row和new.row。最后，SQLite触发器的动作部分是嵌入在`begin`和`end`块中的SQL语句。

![](img/6cb78d1fae7c69689e799fa280d93b57_5.png)

总体来说，以下是我们在两部分演示中涵盖的功能清单。第一部分涵盖了前五个功能，在第二部分我们将讨论自触发触发器。我们将讨论具有循环行为的触发器，冲突。这意味着当我们有多个触发器同时触发时。

最后是嵌套的触发器调用，当触发器的动作部分触发其他触发器时。最后，我们还将向演示中添加SQLite的行级立即激活演示。再次说明，这不符合标准。虽然这有点微妙，但让我来解释一下。根据SQL标准，所有触发器都在命令执行结束时激活，即使它们修改了数据。

多行数据。而在SQLite和MySQL中，触发器会在每一行级别的修改后立即激活。我们将在这个演示中使用的表非常简单，因为我们想专注于触发器行为，因此我们只会使用四个表，每个表都有一个属性。

![](img/6cb78d1fae7c69689e799fa280d93b57_7.png)

我们来做一个演示。我们的第一个触发器是一个简单的示例，演示触发器如何触发自身。它在我们对T1进行插入时被激活。它没有条件，插入之后，它会向T1中插入一行数据，这行数据包含插入的值加一。所以，让我们插入一行数据，看看会发生什么。T1中的第一个元组，就是那个。

这是我们通过命令插入的元组。第二个元组“2”是由触发器自动插入的。然而，我们预计会有额外的触发器激活，插入更多的元组。事实证明，SQLite 默认情况下不允许在一次触发器处理会话中触发器被激活多次。

这可能是为了防止无限循环行为。但是，如果我们愿意的话，可以在 SQLite 会话中切换一个变量，叫做递归触发器。如果我们启用递归触发器，那么该检查会被关闭，触发器可以在触发器处理会话中任意次数地激活。

现在启用了递归触发器，这个触发器实际上会无限次地激活自己，不断地将更多元组插入到 T1 中。实际上，最终会发生错误，但是我们可以修改触发器，设置一个限制条件。具体来说，我们会为触发器添加一个条件，表示只有当 T1 中的元组数少于 10 时，才会执行操作。

所以现在我们期望的情况是，当我们开始插入一个元组时，我们会插入 1、2、3、4、5 等等。但当大小达到 10 时，条件将不再满足，操作将不再执行，触发器处理停止。我从 T1 中删除了两个元组，所以现在我们重新开始，插入一个元组。

![](img/6cb78d1fae7c69689e799fa280d93b57_9.png)

我们看一下表 T1，刷新一下，看到确实插入了 10 个元组，第一个是我们手动插入的，剩下的都是通过我们单一触发器的自我触发插入的，当达到 10 个元组时，触发停止，因为触发器的条件部分没有满足。

现在，让我们将这个概念推广到三个互相触发的触发器。第一个触发器将通过 T1 上的插入操作激活，当 T1 上插入时，它会将相同的元组插入到 T2 表中，只不过值会增加 1。这将激活触发器 R2，而 R2 是由 T2 上的插入触发的。

当 R2 被激活时，它也会将插入的值增加 1 并插入到 T3 表中，然后触发器 T3 会被激活，插入到 T1 表中，再次将值增加 1。所以，让我们像往常一样，从插入值 1 开始，看发生了什么。

现在让我提一下，在开始这个示例之前，我关闭了递归触发器标志。所以这是我们的原始元组 1，它激活了触发器并将 2 插入到了 T2 表中。我们可以继续查看。这又激活了一个触发器，将 3 插入到 T3 表中，然后我们回到 T1 表，插入了 4，但因为 SQLite 默认情况下限制每次触发器处理会话中只能激活一次触发器，

在触发器处理会话中，触发器只会被激活一次，到那时触发器处理就会终止。现在，我们将做与上次相同的操作，重新启用递归触发器，使用此命令启动SQLite会话，然后我们将修改触发器，添加一个终止条件。所以我们只需要在一个触发器中加入终止条件，我们将把它放在第三个触发器中。

第三个触发器将添加一个条件，当第一个表T1的大小小于100时，触发器会继续执行其操作，但当T1的大小超过100时，它就不会执行，这将打破循环，触发器处理将终止。

一如既往，让我们先通过插入元组1到表T1来开始操作。当我们查看表T1时，我们看到原始插入项，接着它将2插入到表T2中，然后导致3被插入到表T3中，再回到表T1插入4，进而触发5被插入到T2中，以此类推。

所以我们现在可以看到触发器的行为，我们确实设置了一个限制条件，因此当我们查看表T1的大小时，我们会看到它的大小正好是100，当T1的大小超过100时，第三个触发器的条件不满足，这导致它的操作没有执行，从而使得整个过程停了下来。好吧，这就是关于循环的部分。

现在让我们看一个情况，假设我们有两个触发器在完全相同的时间被激活，并且它们对数据库的相同部分进行更新。我们的两个触发器都是通过向表T1插入数据来激活的，我们将通过插入一个值为1的元组来启动触发器处理。

第一个触发器没有条件，它会将T1中的所有值更新为2。第二个触发器检查表T1中是否存在值为2的项，如果有，它就会将这些值设置为3。所以这两个触发器的设计特别是为了让我们看到哪个会先执行。如果触发器R1先执行，它会将值设置为2，而R2的条件部分将会。

触发器R1会先激活，并且会将值设置为3。然而，如果触发器R2先执行，它将不会在表T1中找到2，因此它的操作将不会执行，然后触发器R1会接着执行，并将值设置为2。好吧，接下来我们按照定义的这两个触发器进行插入操作，看看会发生什么。我们插入了值后，查看T1，发现我们得到了值2。

那么这告诉我们什么呢？实际上，这告诉我们触发器R2先执行了。我们进行了插入，它查看表中是否有2，但由于表中只有1，所以它没有执行其操作，然后触发器R1执行并将值修改为2。所以这很有趣，第二个触发器先执行了。

作为实验，我们试着反转触发器定义的顺序。我们将首先创建触发器R2，然后创建触发器R1。我已经删除了T1中的一个元组，所以我们再次插入一个T1，以便启动三件事。我们来查看一下，现在我们确实看到了值3。回过头来看我们的触发器，值3意味着触发器R1先执行，它将值设为2，这使得触发器R2的条件成立，然后它将值设为3。所以有趣的是，在SQLite中，当触发器同时激活时，似乎是第二个创建的触发器先执行。

现在让我们实验一下触发器的嵌套调用。 

这次我们来点刺激的，我将从插入一个0到表T1开始，而不是1。我们将使用所有四个表T1到T4，并且有三个触发器。第一个触发器将在T1的插入操作后被激活，它将简单地在表T2和表T3中各插入一个元组1。

我们将要看到并具体实验的是，第一个插入操作实际上会在第二个插入操作执行之前激活触发器。第一个插入到T2会激活我们的第二个触发器，在T2上插入数据，这个触发器将会进一步插入到表T3和T4中，并且也会插入相应的值。

所以这将以某种嵌套的方式发生，事实上，在这个操作中，我们将看到第一个命令会被执行，并且它将在嵌套的方式下激活我们的触发器R3，触发器R3将简单地将值3插入到表T4中。那么，让我们开始吧，正如我之前提到的，为了让它更刺激，我们这次将插入一个0，然后我们来看看我们的表发生了什么。

所以表T1只包含我们预期插入的0。表T2只有一个元组，值为1，正是我们预期的内容。这个触发器只会被激活一次。现在让我们来看一下表T3。表T3有2和1，它们的顺序是这样的，这告诉我们。

这里的插入操作由触发器R2激活，它发生在由触发器R1激活的插入之前，这就演示了触发器的嵌套调用。为了查看最后一个表，我们会在T4中看到类似的情况，我们再次看到嵌套调用，因为2出现在第一次插入3之后，然后我们有了最后一次的插入3。

这个有点复杂，您可能想重新看一下视频，或者更好的是，下载触发器并自己尝试一下。我们的最后一个例子是专门设计来展示在SQLite中立即激活行级触发器的。具体来说，我已经在表T1中填充了4个值为1的元组，当我向T1中插入更多值时，我的触发器将会插入到表T2。

表T1中的平均值。我将插入一批元组到T1。实际上，我将插入4个值为2的元组，这样当我完成时，表T1中将有4个元组。如果触发器遵循SQL语义，在整个语句的最后激活，即整个批量插入完成后，那么我们插入到T2的平均值将会是...

它将反映4个值和4个元组的平均值，所以结果应该是1.5。然而，SQLite的做法是在每次插入元组后激活触发器。因此，当我们一次插入一个2时，平均值会被插入到表T2中，第一个平均值反映的是表T1中有一个2，第二个平均值则反映的是表中有两个元组。

T1等。 当我展示发生了什么时，我想你会明白的。所以这是我将用来将4个元组插入表T1的命令。我将插入一个子查询的结果，该查询将每个值加1。现在我们继续执行，看看表T1，我们现在看到确实如此。

我们有4个1和4个元组。所以，真正的故事是在查看表T2时讲述的，在这里我们确实看到，结果并不是我们在SQL标准语义下会得到的4个1.5的平均值。相反，我们看到每插入一个2，就会将一个平均值插入到T2，反映到目前为止表中的元组数量。

再次，这相当复杂，你可能需要再看一遍这个示例，或者下载下来自己尝试。所以，这就结束了关于触发器的相当长的讲解。我们已经看到，当触发器与数据库上的更新交互时，尤其是它们相互作用时，事情实际上可能变得相当复杂。

事实上，触发器在应用程序中的许多使用场景是为了非常简单的目的。我们可能有几个触发器用于强制执行简单的约束。它们不会彼此交互，也不会以复杂的方式与数据库交互。我之前已经展示过一些这样的触发器。然而，我想强调的是，当触发器用于更复杂的目的时...

当它们彼此以及与数据库的交互变得复杂时，这是非常重要的。

![](img/6cb78d1fae7c69689e799fa280d93b57_11.png)

必须非常小心，完全理解它们是如何工作的。
