# P10：06-06-aggregation.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

接下来的查询将引入 SQL 中聚合的概念。

![](img/a153f67db14c8401cb375180fc02a97d_1.png)

再次强调，我们从基本的 `select from where` 语句开始，这次我们将介绍被称为聚合函数的概念。这些函数最初会出现在 `select` 子句中，它们的作用是对关系中多行的值集进行计算。

所有 SQL 系统支持的基本聚合函数是最小值、最大值、总和、平均值和计数。现在，一旦我们引入了聚合函数，我们还可以向 SQL `select from where` 语句添加两个新子句：`group by` 和 `having` 子句。`group by` 允许我们将关系划分为不同的组。

然后，我们将独立地对每个组计算聚合函数。`having` 条件允许我们在聚合值的结果上进行筛选。`where` 条件适用于单行数据，而 `having` 条件将应用于我们从 `group by` 子句生成的各个组。

当我们展示一些例子时，所有这些构造将变得非常清晰。

![](img/a153f67db14c8401cb375180fc02a97d_3.png)

像往常一样，我们的例子将使用一个简单的大学招生数据库，其中包含一个学院表、一个学生表，以及关于学生申请学院的信息。和往常一样，我们有四所学院，一些学生，以及学生申请具体专业的学院申请。我们的第一个聚合查询非常简单，它计算数据库中学生的平均 GPA。

这是查询，但为了先解释查询，我将首先用星号替换聚合。当我们运行 `select * from students` 时，我们会得到一个结果。具体来说，当我们查看 GPA 列时，聚合将对该列的所有值执行计算，然后在结果中只生成一个包含该值的元组。所以我们将计算平均 GPA。

我们运行查询，现在可以看到数据库中的平均 GPA。我们的第二个查询稍微复杂一些，涉及到一个连接。它查找的是申请计算机科学专业的学生的最低 GPA。所以我们通过学生 ID 对学生和申请进行连接，并筛选出专业为 CS 的学生。再一次。

让我先移除聚合，这样我们就可以看到没有聚合的结果。这里我们可以看到所有申请计算机科学专业的学生信息。聚合将查看 GPA 列，并将取该列中的最低值。所以我们写下 `min GPA`，然后运行查询。

我们发现最低的GPA是3.4。现在让我们再次回到平均值聚合函数。所以让我们计算一下申请计算机科学的学生的平均GPA。执行查询，结果是大约3.7。事实上，这个结果可能并不是我们真正想要的。在之前的视频中。

我们详细讨论过这种查询形式与使用子查询来查找申请计算机科学的学生GPA之间的差异。这个查询的问题是，让我们回到select star的版本。是如果一名学生多次申请计算机科学，比如学生1-3，Amy同时申请了斯坦福和伯克利，那么当我们计算她的平均GPA时。

我们将会计算每个学生的GPA两次。假设我们真正想要的是计算每个申请计算机科学的学生的GPA一次，无论他们申请了多少次。为了做到这一点，我们使用子查询的形式，在其中从学生表中选择。

然后我们检查每个学生的ID是否在申请计算机科学的学生列表中。所以让我们先做一点编辑。从apply，where major equals CS。我打字不是很快。让我们先看一下子查询的形式。我们看到我们在这里犯了个错误，显示我们忘记了一个词，就是in。

为此我们道歉。好的，现在我们有了申请计算机科学的学生，而且在这个情况下，我们每个学生只有一个实例。现在如果我们运行聚合查询，当我们计算平均GPA时，我们会正确地只计算每个学生的GPA一次。所以记得之前约为3.7，现在我们运行查询，结果显示正确的结果是3。

68。虽然不太一样，但这是数值上正确的结果。到目前为止，我们已经看过了平均值和最小值聚合函数。这个查询展示了计数函数。所以不出所料，计数函数仅仅返回结果中元组的数量。所以这个查询特别查找我们数据库中录取人数超过15的大学数量。

000。为了更加彻底，我们不使用聚合函数，直接运行查询，结果显示有两个，聚合函数只是简单地计算了这些元组的数量。我们运行查询，结果是两个，符合预期。让我们做一个非常相似的计数查询。在这种情况下。

我们在统计申请康奈尔大学的学生人数。所以查询看起来是一样的。我们执行查询，结果发现有六名学生申请了康奈尔大学。然而，实际上我们统计的其实是申请康奈尔大学的申请次数，而不是申请康奈尔大学的学生人数。如果一名学生申请了三次。

然后我们在这个结果中将它们计算了三次。所以在某种程度上，这和我们之前看到的类似。我们重复计算了，可以尝试用子查询来修复它，等等，但实际上，C.B.E.E. 提供了一种非常好的方式来执行我们想要的查询。在 count 函数中。

我们可以放一个特殊的关键字 distinct，然后是一个或多个属性的名称。在这种情况下，count 将查看结果，然后计算特定属性的不同值。所以我们运行查询，发现有三个不同的学生 ID。如果我们不加上 distinct，就像这样运行。

当我们查看时，我们会看到，并且再次发现有三个不同的学生 ID。所以 count distinct 实际上在 SQL 中是一个非常有用的功能。

![](img/a153f67db14c8401cb375180fc02a97d_5.png)

这是一个看起来相当复杂的查询，我必须承认，它计算的是一些比较晦涩的内容，但它展示了一些功能。这个查询计算的是，返回所有学生，其中与该学生具有相同 GPA 的其他学生数量等于与该学生具有相同高中规模的其他学生数量。再次承认它有点晦涩，但让我们看看它是如何工作的。

所以它查看学生关系，并对每个学生，计算具有相同 GPA 的其他学生的数量。这是通过测试 ID 是否不同，来计算具有相同 GPA 的其他学生的数量。它还计算具有相同高中规模的其他学生的数量。如果这两个值，这两个子查询都生成一个单一的值。

这就是为什么我们可以测试相等性，如果这两个值相同，那么学生会出现在结果中。让我们运行查询，得到答案。我留给你自己去验证，通过查看数据来确认这是正确的结果。

![](img/a153f67db14c8401cb375180fc02a97d_7.png)

这是另一个看起来比较复杂的查询，尽管它计算的内容实际上更加直观。这个查询计算的是，申请计算机科学的学生的平均 GPA 超过未申请计算机科学的学生平均 GPA 的差额。

我们假设它确实超过了。所以在这个例子中，我们使用的是 From 子句中的子查询。我希望你还记得之前的视频。From 子句中的子查询允许你写一个 select from where 表达式，然后把该表达式的结果当作数据库中的实际表来使用。

所以我们将计算 From 子句中的两个子查询。一个是计算计算机科学申请者的平均 GPA，另一个是非计算机科学申请者的平均 GPA。让我们稍微仔细看一下这里。这个查询的意思是，找到那些申请计算机科学专业的学生，然后计算他们的平均 GPA。

我们将它称为平均 GPA。我们将整个结果命名为 CS。类似地，在 `From` 子句中我们计算的第二个新关系是没有申请 CS 的学生的平均 GPA，所以这些学生的学号不在申请 CS 的学生集合中。我们将其称为非 CS。所以现在在这个 `From` 子句中，我们有一个叫做 CS 的关系，它有一个属性叫做平均 GPA。

然后是一个名为非 CS 的关系，它有一个叫做平均 GPA 的属性。接下来，`select` 子句将简单地进行非 CS GPA 和 CS GPA 的减法操作。我们运行查询后发现，CS 申请者的平均 GPA 超过了非 CS 申请者的 GPA 0.19。现在，为了演示目的，让我展示一下我们如何通过在 `select` 子句中使用子查询来编写相同的查询。

你可能还记得在之前的视频中，我们在 `select` 子句中可以编写子查询，只要它返回一个单一值。我们要做得更进一步，我们将编写两个返回单一值的子查询并进行减法操作。所以我要把这个 `From` 替换成 `select`。我要把这一行的内容去掉。然后，我需要做些什么呢？我要把这里的 `As` 去掉。

然后我将其替换为减号。我会把这里的 `As` 去掉。所以现在我们得到的是 `select` 子句中 CS 学生的平均 GPA 作为一个值，非 CS 学生的平均 GPA 进行减法操作，作为 `select` 子句的一部分。最后我们需要做的就是在 `From` 子句中加上内容，所以我们会写 `From student`。

我们将这个减法的结果称为 D，假设它代表差异。我们运行查询并得到几乎相同的结果，除了有一堆重复的记录。重复的原因是我们针对学生表中的每个元组都计算了一次这个结果。我们可以加上 `distinct`，现在我们就能得到唯一的结果。

![](img/a153f67db14c8401cb375180fc02a97d_9.png)

现在让我们了解一下 `group by` 子句，它仅在与聚合操作一起使用时才有效。我们的第一个查询是找出每所学院的申请人数。它将通过分组来实现这一点。实际上，分组的作用是将一个关系按照给定属性或属性集的值进行划分。具体来说，在这个查询中，我们将 `apply` 关系按学院名称进行分组。

这样就会得到斯坦福小组、伯克利小组等。然后，对于每个小组，我们会返回一个元组，其中包含该小组的学院名称和该小组的元组数量。为了更清晰地说明分组的发生情况，我将从用 `select *` 替换 `select` 子句开始。

移除聚合操作，并对大学名称进行排序。这样做只是为了展示我们将在实际查询中使用的分组。因此，我们看到伯克利大学有三个元组，康奈尔大学有六个元组，等等。然后在每个组内，对于当前查询，我们只需计算元组的数量。

所以回到“group by”的形式，我们返回大学名称，并返回元组的计数。在我实际运行查询之前，有一点需要注意，就是在选择子句中加入什么是合适的。我们正在按大学名称进行分组，因此在同一组内，大学名称对于所有元组是相同的。所以包含大学名称是合理的，但包含其他不同的属性就不太合理了。

尽管稍后我们会看到一个例子，其中包含这些信息，产生一些有趣的结果。目前我们只将分组属性的名称放入，然后我们可以对其进行聚合操作，在这个例子中是计数。我们运行查询，看到伯克利大学有三名申请者，康奈尔大学有六名，等等。这里有一个非常相似的查询，作为第二个例子。

在这个例子中，我们正在查找每个州的大学生总入学人数。现在我们数据库里恰好只有三个州和四所大学，但这个查询的作用是，它会将大学关系表按州划分成多个分区，然后在每个分区或组内，它会返回该分区的州名以及入学人数的总和。我们运行查询后，看到预期的结果。

![](img/a153f67db14c8401cb375180fc02a97d_11.png)

这是一个更复杂的“group by”查询。在这种情况下，我们按两个属性进行分组，还涉及了连接操作，并且在结果中计算两个聚合函数。这个查询计算的是每个大学和专业的组合，申请该大学的学生的最低和最高GPA。

像往常一样，在进行聚合之前，我们先将查询替换为一个可以明确显示分组的查询。我将在这里放入GPA，改为按GPA排序，我们运行查询后，看到伯克利大学的生物学专业实际上只有一名申请者。

对于伯克利大学的计算机科学专业，我们有两个申请者，我想斯坦福大学计算机科学专业的申请人数最多，有三个。一旦我们把聚合操作加回去，每个大学和专业的组合都会被单独考虑，对于每一个组合，我们将计算最低和最高的GPA。

让我们继续进行操作。所有这些括号。好吧，将其更改为按大学名称分组。运行查询后，我们看到，对于伯克利大学的生物学专业，最低和最高GPA是相同的，因为我们看到只有一名学生申请了伯克利大学生物学专业。对于斯坦福大学的计算机科学专业，我们有三名学生。我们可以看到他们的GPA分布，以及每个大学专业组合的情况。

那么，如果我们对每个大学和专业的GPA分布感兴趣呢？

最小值和最大值之间的差异。假设我们实际上要找的是最大的差距，但我们一步步来。我将把当前的查询放入前置子句中。所以现在在前置子句中，我将有一个关系，称为 M，它将包含大学和专业组合以及最低和最高 GPA。

现在，这个 M 会显示我们下面看到的结果。一旦我们有了这个结果，在 `select` 子句中就可以访问这些属性。让我称它为 M 和 M X，如果我们在这里写下 `M X - M N`，我们将得到每个大学和专业的最低和最高 GPA 的差距列表。所以我们看到很多是零。这些都是只有一个学生的组合，但在某些情况下，确实有差距。

我们要找的是最大的差距。看这个，挺有趣的。我们只需要在这里加一个最大值函数（max）。运行查询后，我们发现男女之间的最大差距大约是1。接下来的查询序列介绍了 `group by` 子句的一些细节。我们的查询查找的是每个学生申请的大学数量。

所以查询连接了学生和申请数据。它根据学生 ID 对结果进行分组，然后在每个学生 ID 下找出该组中不同大学的数量。因此，再次说明，我们可以去掉聚合操作。我们用一个排序（order by）替代分组（group by），这样就能看到我们正在处理的数据。运行查询后，我们看到学生一二三申请了斯坦福大学四次。

伯克利和康奈尔是三所不同的大学。二三四有一所，以此类推。所以现在让我们回到原始查询，按学生分组。我们将计算不同的大学名称。运行查询后，我们得到了预期的答案。学生一二三申请了三所不同的大学，二三四申请了一所，以此类推。也许我们还想把学生的姓名和结果一起显示。这个很容易做到。

我们只需要将学生姓名添加到 `select` 子句中，然后运行查询，现在我们就添加了 Amy 是一二三，Bob 是二三四，以此类推。在这种情况下没问题，但稍后我们会看到，单纯地在 `select` 子句中添加一个属性，在使用 `group by` 时会产生一些奇怪的效果。

事实上，之所以在这种情况下能正常工作，唯一的原因是当我们按学生 ID 分组时，在每个组内我们有相同的学生姓名。让我们看看，先看一下这个情况。我们将“group by”替换成“order by”。我们按学生 ID 排序，我们看到对于第一个组（ID 一二三），所有成员都是 Amy；对于三四五组，所有成员都是 Craig，依此类推。所以当我们在分组查询的 SELECT 子句中放入学生姓名时，它是没问题的，因为对于每个组我们都有相同的学生姓名。

这不是我们想要的结果，通常我们应该得到一个错误，但让我们看看会发生什么。所以假设我们现在不仅想在查询中找到学生姓名，还进一步添加大学名称。让我们回到原始查询，加入大学名称。我们将大学名称加到结果中，并且继续按学生进行分组。

现在对于每个学生，我们将根据学生 ID 返回每个组的信息，包括 ID、姓名、不同大学的数量和一个大学。让我们运行这个查询，结果是正常的，没有错误，所以我们得到了 Amy，ID 是一二三，她申请了三所不同的大学，但不知为何系统决定告诉我们关于斯坦福大学的信息。

Craig 申请了两所大学，系统告诉我们关于 MIT 的信息。让我们再回去，恢复到我们查询的“order by”形式，并去掉聚合操作。当我们运行查询时，我们看到 Amy，她确实申请了四所不同的大学，但当我们把大学名称放入分组查询时，系统选择告诉我们关于斯坦福大学的信息。系统实际上在做的是，当我们在分组查询的 SELECT 子句中加入一个非分组属性时，它会随机选择该组中的一个值来返回。

在学生姓名的情况下，随机值总是相同的，因为对于相同的学生 ID，学生姓名总是相同的。而在大学名称的情况下，它从各大学中选择了一个随机值。就个人而言，我并不太喜欢这种行为，在我们演示中使用的三种开源数据库系统中，有两种允许这种行为，分别是 SQLite 和 MySQL，我今天恰好使用的是 MySQL。如果我们使用的是 Postgres，它实际上会在这种情况下抛出一个错误。

让我们回到原始查询，查询每个学生申请的大学数量。这里是我们最初写的查询，下面是查询结果。现在，数据库中可能有些学生根本没有申请任何大学，他们不会出现在我们的结果中，因为他们不会出现在连接的结果中，而且我们没有看到任何零计数的情况。如果我们想要列出那些没有申请任何大学的学生 ID，并在结果中显示零该怎么办呢？

这实际上是我最喜欢用作课堂练习或考试题的查询之一，因为它需要一点创新才能搞明白如何编写。

![](img/a153f67db14c8401cb375180fc02a97d_13.png)

我们的写法实际上是通过使用`union`操作符来实现的，希望你还记得在之前的视频中提到过。我们将把那些已经申请过某些学校的学生与那些没有申请任何学校的学生联合起来，对于没有申请任何学校的学生，我们将直接在结果中显示零。

让我先写下这个的开头部分，我们要找出那些根本没有申请过任何学校的学生。所以这些学生的SID不在`apply`关系中的所有SID集合中。这样就找到了那些没有申请任何学校的学生。对于每个学生，我们将返回他们的学号，然后我们希望在结果中显示一个零。

非常简单。我们只需要写零。我们运行查询，然后如果向下滚动，我们将看到除了所有已经申请过的学生，我们还会看到没有申请过任何地方的学生的结果中有零。

![](img/a153f67db14c8401cb375180fc02a97d_15.png)

在本视频中，我们将介绍的最后一个子句是`having`子句，`having`子句也仅在与聚合操作一起使用时才有意义。`having`子句允许我们对聚合函数的结果应用条件。因此，`having`子句是在`group by`子句之后应用的，它允许我们检查涉及整个分组的条件。与此相比，`where`子句一次只对一个元组应用条件。

这个查询实际上是在寻找申请人数少于五个的大学。我们查看`apply`关系，并按学校名称进行分组，这样每个学校就有一个分组。然后我们只保留那些分组中元组数少于五个的组，这表示该大学的申请人数少于五人。我们运行查询后，将看到伯克利和麻省理工学院每所学校的申请人数都少于五个。

假设康奈尔和斯坦福的申请人数都大于或等于五个，你可以通过检查数据来确认这一点。现在，实际上是可以在没有`having`子句的情况下写出同样的查询，事实上也不需要分组子句，让我展示一下如何实现。

我们将再次选择`apply`中的`C name`，接下来我们要做的是在这里添加一个属性。我们将创建一个表变量。我们将提升整个操作，然后找到所有的申请人。所有的申请记录中，让我为你输入一下。

五大于`apply A2`中的计数，其中`A2.C name`等于五，`C name`等于`A1.C name`。让我们来看看这到底在做什么。所以我们在这里做的事情是，我们查看每一条申请记录，并检查是否有其他的申请记录是针对同一所大学的。

我们要找到同一学院的所有申请记录。我们将对它们进行计数，并查看这个数量是否小于五。所以这有点不直观。现在记住，结果应该是伯克利和麻省理工。我们运行查询，确实得到了伯克利和麻省理工。我们再次得到了重复的记录。

原因是我们在检查每个申请记录的条件。所以对于每一个申请到伯克利的记录，我们检查这个条件，可能有很多个类似的记录，对于每一个申请到麻省理工的记录也是如此，依此类推。当然，像往常一样，我们可以添加`distinct`。我们可以运行查询，现在得到结果。事实上，任何可以在`group by`和`having`子句中写的查询，都可以用另一种形式来表示。

有时它可能非常复杂，但在我的课堂上，我喜欢给学生一个更复杂的练习，证明你可以在不使用`group by`和`having`子句的情况下编写每个`group by having`查询。现在让我们回到查询的原始形式，其中使用了`group by`和`having`。

所以我们就把这些都去掉。抱歉，我打字很糟糕。`group by`按学院名称分组，`having count(*) < 5`。我们运行查询，得到相同的结果。如果我们感兴趣的不是那些申请少于五次的学院，而是那些有少于五个申请的学院呢？

这是一个微妙的要点，但我们不想计算每个学院的`apply`元组的数量，而是要计算在该学院的`apply`元组分组中出现的不同学生ID的数量。所以现在我们在查找的是那些有少于五个不同学生申请的学院数量。

现在我们看到，另外一所学院加入了分组，所以康奈尔有超过五个申请，或者至少有五个申请，但它的申请人数少于五个。这里是我们的最终查询。它有一个`having`子句和`group by`，此外，它在`having`子句中还有一个子查询，并且这个子查询也使用了聚合。

这个查询找到的是数据库中所有专业，其中申请该专业的学生的最高GPA低于数据库中的平均GPA。所以我们连接了`student`和`apply`表，并按专业进行分组，这样我们就可以一次查看一个专业。

在专业内，我们找出申请该专业的学生的最大GPA，并检查它是否低于学生表中的平均GPA。我们运行查询，发现生物工程和心理学在当前时刻的申请者的最高GPA低于数据库中的平均GPA。

当然，这并不代表现实情况。

![](img/a153f67db14c8401cb375180fc02a97d_17.png)
