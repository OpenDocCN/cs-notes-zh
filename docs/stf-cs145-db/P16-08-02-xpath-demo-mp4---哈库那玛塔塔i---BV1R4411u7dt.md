# P16：08-02-xpath-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

在本视频中，我们将通过对我们的书店数据运行一系列查询来演示 X-Path。

![](img/a3f43e46c606e8e4248c1148c66b1de1_1.png)

让我们首先看看数据。我们稍微扩展了之前视频中使用的数据，但它的结构基本保持不变。我们有许多书籍，书籍有属性，如 ISBN、价格，有时还包括其他内容。它们有标题子元素，作者包括名和姓。所以我们有我们的第一本教材和完整书籍。

![](img/a3f43e46c606e8e4248c1148c66b1de1_3.png)

我们的完整书籍也有一个备注，正如你可能记得的那样。

![](img/a3f43e46c606e8e4248c1148c66b1de1_5.png)

然后我添加了几本书。我添加了 Jeffrey Elman 和 Hector Garcia Molina 的《数据库提示》，并附有备注，这是你课本的不可或缺的伴侣。

![](img/a3f43e46c606e8e4248c1148c66b1de1_7.png)

我还添加了 Jennifer 的经济型数据库提示。

![](img/a3f43e46c606e8e4248c1148c66b1de1_9.png)

只需花费$25，你就能获得一些提示。然后最后，为了演示某些表达式。

![](img/a3f43e46c606e8e4248c1148c66b1de1_11.png)

我还插入了三本杂志，包括《国家地理》和《新闻周刊》。最后，我还插入了一本名为《Hector 和 Jeff 的数据库提示》的杂志。

![](img/a3f43e46c606e8e4248c1148c66b1de1_13.png)

所以，记住这些数据后，我们来处理查询。我们将从简单的查询开始，随着进展逐渐变得复杂。

![](img/a3f43e46c606e8e4248c1148c66b1de1_15.png)

在这个窗口中，我们将在上方窗格中输入我们的 X-Path 表达式，然后执行查询，结果将在下方窗格中显示。X-Path 的工作原理是，每个表达式的第一部分指定了要在其上评估 X-Path 表达式的文档。因此，我们有你在名为 bookstoreQ.xml 的文档中看到的数据。

你会看到，在我们的每个表达式中，我们首先指定该文档，然后继续进行其余的 X-Path 表达式。我们的第一个表达式是一个非常简单的路径表达式。它的意思是通过首先进入名为 Bookstore 的根元素来浏览 XML。

然后查看所有书店（Bookstore）下的书籍子元素，最后是所有元素的标题。

![](img/a3f43e46c606e8e4248c1148c66b1de1_17.png)

让我们运行查询，然后在下方查看结果。

![](img/a3f43e46c606e8e4248c1148c66b1de1_19.png)

所以，正如我们所看到的，我们这里的结果实际上是以 XML 形式书写的，出现了一个小的头部，然后我们看到了数据库中四本书的标题。现在，让我们修改我们的路径表达式。不仅获取书籍标题，而是获取书籍或杂志的标题。我们通过扩展中间匹配元素来使用类似正则表达式的语法来做到这一点。

![](img/a3f43e46c606e8e4248c1148c66b1de1_21.png)

书籍或杂志，我们将它放在括号中。现在它表示匹配数据中从书店元素开始的任何路径，跟随书籍或杂志的子元素，最后是标题子元素。当我们运行查询时，我们现在看到的不仅是我们书籍的标题，还有杂志的标题。到目前为止，我们在路径表达式中明确提到了元素名称。

但正如我在介绍视频中提到的，我们还可以使用所谓的通配符符号——星号符号。星号表示匹配任何元素名称。所以现在我们将重新从书店开始，匹配书店下的任何元素，最后找到那些元素下的标题子元素。

现在恰好在书店下方的唯一元素是书籍和杂志。所以当我们运行查询时，我们将得到完全相同的结果。到目前为止，我们一直在使用单斜杠操作符进行导航，告诉我们一次处理一个元素。我们处在一个特定的元素上。

然后我们通过我们输入的特定标签匹配子元素。还有一个双斜杠操作符。如你在介绍视频中记得的，双斜杠表示匹配我自己，或者我自己所有的后代元素，直到任何长度。所以如果我输入双斜杠标题，那么我们匹配的将是XML树中任何位置的标题元素。

我们运行查询，再次得到完全相同的结果，因为我们已经得到了所有书籍或杂志的子元素——标题。现在让我们做些不同的事情。让我们输入双斜杠星号。那可是一个非常野的东西。

因为它表示我将匹配整个树中的任何元素，而且它可以是任何类型的元素。让我们运行查询，看看会发生什么。

![](img/a3f43e46c606e8e4248c1148c66b1de1_23.png)

我们得到的是一个巨大的结果。

![](img/a3f43e46c606e8e4248c1148c66b1de1_25.png)

让我向下滚动，这样你就能看到结果。实际上，我们得到的是树中每个层级的所有元素，包括它的所有子元素。

![](img/a3f43e46c606e8e4248c1148c66b1de1_27.png)

实际上，我们结果中的第一个元素是我们的整个树结构，因为它是我们的书店元素。

![](img/a3f43e46c606e8e4248c1148c66b1de1_29.png)

我们会一直走到书店的最底部。接下来是我们结果中的一些书店子元素，所以我们得到了书籍元素。

![](img/a3f43e46c606e8e4248c1148c66b1de1_31.png)

我们还将在答案中得到它们的子元素，并且随着我们继续向下滚动。

![](img/a3f43e46c606e8e4248c1148c66b1de1_33.png)

我们会看到我们得到了整个数据库中的每一个元素。

![](img/a3f43e46c606e8e4248c1148c66b1de1_35.png)

这不是一个有用的查询，但它确实展示了构造方法，双斜杠表示匹配树中的任何元素，星号表示匹配任何元素的标签。现在，让我们转向属性。假设我们有兴趣返回数据库中的所有ISBN号码。我们将回到说书店、书籍子元素，然后获取ISBN属性。

![](img/a3f43e46c606e8e4248c1148c66b1de1_37.png)

所以我们输入@符号和ISBN。让我们运行查询，结果出现了一个错误。原来，属性不能被序列化以便返回类似XML的结果。因此，我们实际上需要做的是从属性本身获取数据，一旦我们这么做，就会看到我们得到了想要的答案。所以我们会请求属性的数据。

运行查询，现在我们看到所有的ISBN号码。现在，属性数据只是字符串。所以我们将ISBN号码作为一组字符串返回，中间有空格。其实这些是X-Path工作方式的一些特殊情况。再说一次，我们不能返回属性，因为它不知道如何构造结果。

但是一旦我们从属性中提取了数据，它会将其作为字符串值返回。到目前为止，我们只看到了没有涉及条件的路径表达式，所以让我们加入一个条件。假设我们有兴趣返回价格低于$90的书籍。那么我们在这里要做的是导航到书籍。

然后我们将使用方括号，它表示从当前导航点开始评估条件。所以我要设置的条件是书籍的价格低于$90。

![](img/a3f43e46c606e8e4248c1148c66b1de1_39.png)

我们运行该查询，然后我们会看到有两本书，或者说三本书，我道歉，它们的价格低于$90。现在，我们返回了满足条件的书籍。如果我们实际上想要返回的是价格低于$90的书籍的标题呢？

我们可以做的是，在评估了书籍的条件后，实际上可以继续进行导航。所以我们只需在这里加上/title，它表示找到书籍，保留那些符合条件的，然后继续向下导航到它们的标题，并将其作为查询结果返回。

![](img/a3f43e46c606e8e4248c1148c66b1de1_41.png)

我们运行查询，并看到我们的结果。现在，我们可以在方括号中放入另一种类型的条件——存在条件，而不是比较条件。如果我们例如仅在方括号中放入标签remark，它表示我们应该匹配那些有remark的书籍。所以将元素名称放入方括号中就是对该元素的存在条件。

所以元素存在。一旦我们隔离出有备注的书籍，我们将返回这些书籍的标题。我们运行查询，发现有两本书有备注。你可以回去检查数据，确认确实是这样。现在让我们稍微复杂一点。我们先去掉这个查询，换成一个全新的查询。

在这个查询中，我们将查找价格低于90美元且Omen是其中一位作者的书籍标题。所以现在我们在方括号中有了一个更长的条件。这个条件是价格低于90美元，并且存在一个路径——这是隐含的存在——存在一个从书籍的author/author/last name子路径，其值为Omen。

如果我们满足这两个条件，那么我们将返回书籍的标题。所以我们运行查询，发现了两本价格低于90美元且其中一位作者是Omen的书籍。现在让我们通过添加另一个条件来扩展这个查询。我们不仅要作者的姓氏是Omen，还要名字是Jeffrey。

所以现在我们在寻找的是Jeffrey Omen是作者之一且书籍价格低于90美元的书籍。我们运行查询，得到相同的结果，这并不令人惊讶，因为Omen总是和Jeffrey配对。但是实际上，这个查询并没有完全达到我们的预期，我将通过展示一些修改来解释原因。假设我们改变查询，不再寻找Jeffrey Omen作为作者，而是寻找Jeffrey Widdham。

希望我们不会得到任何答案，但当我们运行查询时，我们看到仍然有一本书被返回。那就是《数据库系统第一课程》。回到数据中查看这本书的两个作者是Jeffrey Omen和Jennifer Widdham。那么我们来看看为什么这本书会在这个查询中被返回。原因是如果我们仔细观察这个条件，我们会发现我们在寻找的是价格低于90美元的书籍，并且存在一个作者的author/last name路径，其值是Widdham，且存在一个作者的first name路径，其值是Jeffrey。

这实际上是对的。我们有一位作者的姓氏是Widdham，另一位作者的名字是Jeffrey。现在让我们尝试制定正确的查询。所以，我们不再分别匹配整个路径的姓氏和名字，而是希望逐一查看每个作者，并在该作者内部同时查看姓氏和名字。

所以，为了修改我们的查询，我们将在条件内使用条件，特别是在author/author部分，我们将查看姓氏和名字。这个语法错误是暂时的，等我们完成查询后，一切都会正常。

所以我们在这里放了第二个方括号，让我再展示一下我做了什么。我说我们在寻找那些价格低于90并且存在一个作者/作者子元素的书籍，这个作者的姓氏是Widdham，名字是Jeffrey。希望我们能得到一个空的答案。我们执行查询，结果确实如此。现在我们最初的目标是找出Jeffrey Omen。因此，最后我们会把Jeffrey Omen改成，运行查询，现在我们得到了正确的答案。

顺便提一下，这是一种很常见的错误，当我们有一个条件时，我们往往会在条件前面加上斜杠。如果我们这么做，会得到语法错误。当我们编写方括号时，它实际上起到了斜杠的作用，所以当我们在方括号内引用子元素名称时，我们实际上是隐式地导航到那个子元素。

![](img/a3f43e46c606e8e4248c1148c66b1de1_43.png)

接下来我们将尝试一个稍微不同的类似查询。我们要尝试查找那些Omen是作者而Widdham不是作者的书籍。

![](img/a3f43e46c606e8e4248c1148c66b1de1_45.png)

所以我们像往常一样导航到书籍，查找那些作者的姓氏是Omen，而作者的姓氏不是Widdham的情况。现在你可能已经发现这不是正确的查询，但我们还是继续运行，结果显示我们得到了三本书，但我们知道前两本书中Widdham是作者。

所以，正如你可能已经察觉到的，这并不正确，这个查询要求的是书籍中有一个姓氏为Omen的作者，并且有一些姓氏不是Widdham的作者。事实上，每本书中有Omen作为作者，都会有一个姓氏不是Widdham的作者，那就是Omen。

所以即使我去掉这个条件，再次运行查询，我也会得到完全相同的结果。

![](img/a3f43e46c606e8e4248c1148c66b1de1_47.png)

实际上我遇到了一个语法错误。哎呀，我忘了删除那个，所以下去这个，运行查询，现在我们确实得到了完全相同的结果。

![](img/a3f43e46c606e8e4248c1148c66b1de1_49.png)

所以，作为提醒，我们之前是在尝试查找那些Omen是作者而Widdham不是作者的书籍。实际上，我们还没有构建出能够写出这个查询的结构。稍后在演示中我们会看到如何以一种稍微复杂的方式来写这个查询，但截至目前，我们所见到的路径表达式和条件，我们无法写出这个特定的查询。到目前为止，我们已经看过了括号中使用的两种条件类型。

我们看过比较操作，也看过存在性约束，即检查某个子元素是否存在。正如你从介绍中可能记得的，我们也可以在方括号中放入数字，这些数字告诉我们返回第n个子元素。

具体来说，如果我们看这个查询，我们使用双斜杠直接导航到作者元素，然后我们希望返回每个作者元素的第二个作者子元素。所以我们运行查询，我们会看到，如果查看我们的数据，我们会看到Jennifer Widdham。

Jeffrey Omen 和 Hector Garcia Molina 每个人都作为书籍或杂志的第二作者出现一次。如果我们把这个改为三，我们只会返回第三作者，而且我们可以看到只有 Jennifer Widdham 是第三作者。如果我们改为十，希望得到空结果，实际上确实得到了。现在，让我们来看一些内建函数和谓词。

在这个查询中，我们将查找所有书籍，其中有一个关于书的备注，包含“great”一词。所以我们将使用斜杠斜杠直接导航到书籍元素，在书籍元素中，我们会有一个条件，调用这个内建谓词 contains，正如我在介绍视频中提到的，它会比较两个字符串，并检查第一个字符串是否包含第二个字符串。

所以，如果我们有一本书，其中有一个备注，它是一个包含“great”一词的字符串，那么这本书就会符合条件，我们将返回书的标题。我们运行查询，看到我们有一本书，它的备注包含了“great”一词。

![](img/a3f43e46c606e8e4248c1148c66b1de1_51.png)

我们的下一个查询做了一些新鲜的事情。我喜欢称这个查询为自连接，但这可能是因为我偏向关系型思维。实际上，它正在查询我们书店数据的两个实例，并将它们连接在一起。

所以我们会看到我们的 doc bookstore 在这个表达式中出现了两次。让我解释一下这个表达式在做什么。它在查找所有杂志，这些杂志中有一本书，它的标题与杂志的标题相同，下面是它是如何实现的。我们第一个路径表达式导航到杂志，然后在条件中提取杂志的标题。如果杂志的标题等于某本书的标题，它就会匹配。所以为了找到书的标题，我们需要返回到文档的顶部，因此我们会得到文档的第二个实例，并找到书的标题。

现在，当我们在这里使用等号时，这个等号是隐式存在量化的。这意味着，尽管我们对实际上是一个集合的东西进行等值比较，条件是满足的，只要集合中的某个元素等于第一个标题。XPath 和 XQuery 中有很多隐式的存在量化，稍后我们会看到。无论如何，让我们运行查询，我们会返回事实，名为 Hector 和 Jeff's database hints 的杂志与一本书的标题相同，如果你回顾数据，你会看到发生了什么。

所以在数据中你会看到我们确实有一本同名的书。我们看到一个内建谓词的例子，包含了这个例子，它展示了另一个内建函数，这次是名称函数，并且它也展示了我们的第一个导航轴的例子。

我们将使用父轴。这个查询要查找的是所有其父元素标签不是书店或书籍的元素。当然，这只是为了演示目的，实际上这个查询并没有多大用处。我们只是演示查询的构造过程。我们从书店元素开始，然后使用斜杠斜杠星号，这会找到所有元素。

我们之前看到过`// *`，当我们运行查询时，我们看到它匹配了数据库中所有的元素。现在，由于我们已经放入了书店元素，我们将不会匹配书店元素本身，而是匹配书店元素的所有子元素。

这个条件查找的是当前元素的父标签，并检查它是否是书店或书籍，如果既不是书店也不是书籍，我们就返回该元素。下面是如何找到父标签的方法。`name`是一个内置函数，`name`作用于一个元素，并返回该元素的标签。

我们要查看的元素是当前元素的父元素，我们使用的是父导航轴，即`parent::`。最后，星号匹配父元素的标签。所以这里我们说匹配任何父元素的标签，提取该标签并检查它是否是书店或书籍。

![](img/a3f43e46c606e8e4248c1148c66b1de1_53.png)

所以当我们运行查询时，我们会看到返回了很多数据，但它们都是父元素不是书店或书籍的数据库元素。

![](img/a3f43e46c606e8e4248c1148c66b1de1_55.png)

![](img/a3f43e46c606e8e4248c1148c66b1de1_56.png)

这是另一个导航轴的示例。在这种情况下，我们使用了`following sibling`（后续兄弟）。`following sibling`表示，如果我们在树中的某个特定位置，我们应该匹配每个兄弟元素，也就是文档中紧随当前兄弟元素之后的同一级别的所有其他元素。

所以让我们逐步解析这个表达式，看看我们在做什么。这个表达式的目标是查找所有标题不是唯一的书籍和杂志。换句话说，查找所有有其他书籍或杂志拥有相同标题的书籍或杂志。所以我们导航到书籍或杂志元素。

这是我们之前在路径表达式中看到的内容。我们会匹配任何书籍或杂志元素。然后，我们希望找到标题等于某个后续兄弟元素标题的元素。现在，我们的书籍和杂志都在数据中的同一级别，因此，当我们使用`following sibling`时，我们将匹配所有出现在当前元素之后的书籍和杂志。同样，星号表示我们可以匹配任何类型的元素。

我们得到的结果只会是书籍或杂志，因为我们知道它们都是书籍或杂志，我们稍后会做这件事，但现在让我们专注于运行查询。

![](img/a3f43e46c606e8e4248c1148c66b1de1_58.png)

所以我们执行查询，得到两个结果。

![](img/a3f43e46c606e8e4248c1148c66b1de1_60.png)

我们找到了Hector和Jeff的数据库提示，它是一本书，因为我们有一本同名的杂志；我们还找到了《国家地理》，它是一本杂志，因为有另一本文字相同的杂志。

![](img/a3f43e46c606e8e4248c1148c66b1de1_62.png)

所以实际上这个查询有点不完整，这是我们的错误。我们写查询时说要返回标题相同的书籍或杂志元素，但这个查询并没有返回所有具有非唯一标题的元素。

它只返回每个非唯一标题的第一个实例。

![](img/a3f43e46c606e8e4248c1148c66b1de1_64.png)

让我们修改查询以做正确的事情。我们需要做的不仅仅是检查标题是否等于某本书或杂志的下一个兄弟标题，还需要检查它是否可能等于前一个标题。我们添加了标题相等的构造，使用了preceding sibling轴/slur标题。

![](img/a3f43e46c606e8e4248c1148c66b1de1_66.png)

看，运行查询后，我们看到Hector和Jeff的数据库提示和《国家地理》都被返回了，但我们也得到了另一篇《国家地理》和另一篇Hector和Jeff的数据库提示。

![](img/a3f43e46c606e8e4248c1148c66b1de1_68.png)

![](img/a3f43e46c606e8e4248c1148c66b1de1_69.png)

现在我们得到了正确的答案。我们不仅仅得到了重复标题的第一个实例，还得到了所有的重复实例。现在要展示这个星号的使用，我们匹配任何书籍或杂志作为下一个兄弟元素。如果我们只关心有一本书与其他杂志有相同标题的情况，我们可以在这里做同样的事情。

![](img/a3f43e46c606e8e4248c1148c66b1de1_71.png)

![](img/a3f43e46c606e8e4248c1148c66b1de1_72.png)

在这种情况下，我们就不应该再获取《国家地理》了。

![](img/a3f43e46c606e8e4248c1148c66b1de1_74.png)

让我们运行查询，确实我们得到的所有结果实际上是Hector和Jeff的数据库提示作为一本杂志，因为这是唯一一个确实有相同标题的书。与匹配书籍或杂志的星号不同。

![](img/a3f43e46c606e8e4248c1148c66b1de1_76.png)

先别看这个查询。让我在你试图解开语法之前先解释一下我在做什么。正如我之前提到的，expath涉及隐式存在量化。所以当我们在寻找作者时，如果某个作者的姓是Omen，我们会匹配任何具有Omen姓氏的路径。一般来说，大多数expath的操作都围绕着匹配一组值，然后返回集合中符合条件的元素。

如果我们想要做全称量化，也就是说“对所有”，这就更复杂了，但我们可以通过一个巧妙的方法来实现。所以，在这个查询中，我们将查找所有作者的名字中都包含J的书籍。如果我们按照可能的方式写这个查询，可能会尝试这样写：`book author/author first name contains J`。

然后我们将获取一些作者的名字中包含J的书籍。要获取所有作者的名字中都包含J的书籍则更加困难，我们要做的方法有点像是变通法。我们将使用内建函数count。所以在这个查询中，我们正在查找所有书籍，其中作者的名字包含J的数量与该书的作者总数相等，且没有附加条件。

具体来说，在book元素下，我们统计一个作者的author子元素中匹配的数量，其中内建函数contains为真，且该作者的名字包含J。因此，我们在计算名字中包含J的作者数量，并将其设置为与first name子元素的数量相等。

![](img/a3f43e46c606e8e4248c1148c66b1de1_78.png)

我们运行查询，确实找到了两本书，所有这些书的作者名字中都包含J。

![](img/a3f43e46c606e8e4248c1148c66b1de1_80.png)

我们可以使用一个相关的技巧，来编写我们之前尝试但没有成功的查询，目的是查找那些所有作者都是男性且Whittom不是作者的书籍。所以在隐式存在的情况下，之前发生的是我们找到了一个名叫Omen的作者，然后又找到了一个姓氏不是Whittom的作者。

当然，我们依然找回了所有结果。我们真正想找到的是那些有一个姓氏为Omen的作者，并且所有作者的姓氏都不是Whittom的书籍。实际上这又是一个全称量化，或者说是“对所有”。对于所有的作者，他们的姓氏都不是Whittom。由于我们没有“对所有”这种构造，且在Expat中也没有，所以我们将再次使用count技巧。

所以在这个查询中，我们正在查找那些其中一个作者的姓氏为Omen，且使用count函数来统计作者姓氏为Whittom的数量为零的书籍。

![](img/a3f43e46c606e8e4248c1148c66b1de1_82.png)

现在我们已经表达了这个查询，运行后我们得到了正确的答案。这就结束了我们关于Expat的演示。我们展示了许多构造，并且编写了一些相当复杂的查询。另一方面，当然我们也没有覆盖整个Expat语言。如果你对我们的众多在线资料感兴趣，我们也将提供数据，并鼓励你自己进行实验。

![](img/a3f43e46c606e8e4248c1148c66b1de1_84.png)

![](img/a3f43e46c606e8e4248c1148c66b1de1_85.png)
