# P13：07-01-relational-design-overview.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

在这一系列视频中，我们将学习如何为关系数据库设计良好的模式。

![](img/08c656414c2b104a8091d239884ef9ca_1.png)

所以假设我们正在为一个应用程序或一组应用程序构建数据库，并且我们需要弄清楚我们希望存储数据的模式是什么。通常，数据库有很多不同的可能模式设计，而且数据库确实会变得相当复杂，一些设计远比其他设计更好。

那么我们如何选择使用什么设计呢？实际上，人们通常使用更高层次的工具来设计关系数据库，而不是直接设计模式本身。但是有些设计师确实会直接进入关系设计，此外，理解由设计工具生成的关系为何会是那样，也是很有用的。

此外，从学术角度来看，事实证明有一个非常好的理论。

![](img/08c656414c2b104a8091d239884ef9ca_3.png)

这是关于关系数据库设计的理论。所以让我们考虑一下为我们关于申请大学的学生数据库设计模式的过程。具体来说，对于一个给定的学生，假设我们有他们的社会安全号码，他们的名字，他们申请的大学，学生就读的高中及这些高中的所在城市，还有学生的爱好。

所以如果这就是我们想要的，我们可以创建一个叫做apply的单一关系，它有一个属性来表示每一项信息。

![](img/08c656414c2b104a8091d239884ef9ca_5.png)

现在让我们看看这个数据库如何填充数据。假设我们有一个学生，社会安全号码是123，她去了帕洛阿尔托的两所不同的高中，她打网球和吹小号，并且她正在申请斯坦福、伯克利和麻省理工学院。

所以让我们看看我们将在apply关系中使用的一些元组，以表示关于Anne的信息。所以我们将有123 Anne，她的名字，她正在申请斯坦福，她去了帕洛阿尔托高中，位于帕洛阿尔托，她的一个爱好是打网球。然后我们还会有123 Anne，她申请了伯克利。

并且她去了帕洛阿尔托的帕洛阿尔托高中，在那里打网球。当然，她还有一个元组，表示她正在申请伯克利，我们依旧保持帕洛阿尔托高中，并且她吹小号。正如你所看到的，我们会有更多的元组，我们会有各种斯坦福和伯克利的记录。

我们将为她的另一所高中设计一个数据库，叫做Gun High School，也在帕洛阿尔托。等等。所以如果我们考虑这个问题，我们需要12个元组来表示有关Anne的信息。那么，我们认为这是一个好的设计吗？

我会反驳，这不是一个好的设计。这个设计中有几种异常类型。首先，我们在设计中多次记录信息，我将举几个例子。例如，我们记录123这个社会保障号码与名为安妮的学生关联的次数有多少次。

我们在12个元组中记录了12次这个事实。我们记录安妮上过帕洛阿尔托高中的次数有多少次？

我们将记录六次，并且记录她演奏10次的事实也会有六次，我们会记录她申请MIT的事实四次。所以对于每一条信息，实际上我们会记录很多次。所以这似乎不是设计的一个好特性。第二种异常是更新异常。

这实际上是冗余的直接影响。更新异常的意思是你可以在某些地方更新事实，但并不是所有地方都更新，或者在不同的地方更新的方式不同。举个例子，假设安妮吹奏小号。我可能决定改为称之为短号，但我可以继续修改，比如修改其中三处记录。

我们记录她吹奏小号的事实，而不是第四个事实。结果我们得到的实际上是一个不一致的数据库。而第三种可能发生的异常被称为删除异常。这里有一种情况，我们可能会不小心完全删除数据库中的某个人。

比如说，我们决定冲浪是不被接受的爱好，针对我们的大学申请者，我们删除了关于冲浪的元组。如果有学生的唯一爱好是冲浪，那么这些学生将被完全删除。

![](img/08c656414c2b104a8091d239884ef9ca_7.png)

现在你可能会认为这是正确的做法，但可能这并不是原本的意图。所以现在让我们来看一下同一数据的一个完全不同的设计。这里我们有五个不同的关系，一个是关于学生及其姓名的信息，一个是他们申请的大学，一个是他们上过的高中。

关于他们高中的位置，以及学生有哪些爱好。在这种情况下，我们没有异常。如果我们回头看看这三种不同的类型，在这个设计中它们不会发生。我们没有冗余信息，没有更新异常，也没有删除异常。除此之外。

我们可以从我们最初的设计中重建所有原始数据。所以通过这种方式拆分，我们没有丢失任何信息。所以实际上，这看起来是一个更好的设计。现在让我提几个可能会发生的设计修改。例如，假设仅凭高中名称并不能作为唯一标识。

所以，当我们把高中名称和高中城市拆开时，我们就无法再仅凭这些信息来识别高中。在这种情况下，优选的设计是将高中城市移到这里。这样我们就能把它和高中名称放在一起，而不再需要这里的关系。

事实上，这是一个很好的设计。它没有引入任何异常。这只是基于我们需要将高中名称和城市一起使用来进行标识这一事实。举个例子，假设一个学生不希望所有的爱好都被透露给他们申请的所有大学。例如。

也许他们不希望斯坦福知道他们喜欢冲浪。如果是这样的话，我们可以再次修改设计。在这种情况下，我们会将爱好放到这里，并标明他们申请的大学。这样就可以包含他们希望透露给特定大学的爱好。

然后我们将去掉这个。因此，看起来我们是把之前的小关系再合并回了一个包含更大关系的设计。但在这种情况下，这一设计是非常有理由的。我们需要这些属性一起使用来识别高中，并且我们希望能够将爱好与特定大学对应。

所以，这表明，关系数据库应用的最佳设计，不仅仅依赖于如何构建关系，还取决于数据的实际需求。

![](img/08c656414c2b104a8091d239884ef9ca_9.png)

这在现实世界中所表示的含义。所以我们接下来要做的基本思路是通过分解来设计。具体来说，我们将从一开始就做我们在这个例子中所做的事情，首先创建包含所有我们想要在数据库中表示的属性的大关系。

然后我们将把这些大的关系分解成更小的关系，它们更好，但仍能捕捉到相同的信息。最重要的是，我们可以自动完成这个分解过程。

![](img/08c656414c2b104a8091d239884ef9ca_11.png)

那么自动分解是如何工作的呢？除了这些大的关系，我们还将正式指定数据的属性。系统将利用这些属性来分解关系，然后保证最终的关系集满足要求。

这叫做规范化形式，我们将正式化这一切。但规范化形式背后的基本理念是，它们没有我之前展示的那些异常，而且不会丢失任何信息。所以，特别是对于属性的规范化，我们将从查看一个叫做函数依赖的概念开始。

一旦我们指定了函数依赖，系统将生成符合博伊斯-科得范式的关系。顺便提一下，博伊斯和科得是关系数据库领域的两位早期先驱。接下来我们将查看另一种叫做多值依赖的规范，它将与函数依赖结合使用。当我们同时拥有函数依赖和多值依赖时。

然后我们可以得到所谓的第四范式。同样，这将是由系统生成的、符合范式的关系。博伊斯-科得范式比第四范式更严格。具体来说，如果我们在这里绘制一个包含所有关系设计的大维恩图。

这些符合博伊斯-科得范式，顺便说一下，博伊斯-科得范式通常缩写为B、C和F，它包含了所有符合第四范式的关系，通常缩写为四和F。所以，所有符合第四范式的关系也符合博伊斯-科得范式，但反之则不然。现在你可能会想，第一范式和第二范式去了哪里？

和第三范式。所以，第一范式基本上只是一个规范，要求关系必须是真正的关系，每个单元格中都有原子值。第二范式是指定关系结构的一种方式，涉及到它们的主键。如今，这两个范式已经不太被讨论了。第三范式是对博伊斯-科得范式的轻微弱化。

有时人们确实喜欢讨论第三范式。你可以把第三范式想象成一个稍微更大的圆圈。我们在这个视频中不会讲解第三范式，因为博伊斯-科得范式是最常用的范式。

如果我们只有函数依赖并且符合第四范式，那么如果我们有函数依赖和多重依赖。那么接下来我要给出一些例子，以激发对这四个概念的理解：函数依赖、博伊斯-科得范式、多值依赖以及第四范式，之后的视频将更深入地讲解每一个概念。

所以让我先简单介绍一下函数依赖和博伊斯-科得范式。我们将使用一个非常简单的例子，一个简化版本的申请关系，其中包含学生的社会安全号码、学生的姓名以及他们申请的大学。

即使是这个小关系，实际上也存在冗余和更新、删除异常。具体来说，假设我们的学生123-AN申请了七所大学，那么将会有七个元组，每个元组都表示学生123的社会安全号码和名字为AN。具体地说。

我们将为每个学生存储一次他们的姓名和社会保障号码对，每次他们申请的大学都有记录。所以现在让我解释一下什么是功能依赖，然后我们将看到如何使用功能依赖来识别像这样的设计缺陷，以及我们如何修正它。功能依赖。

在这个例子中，从社会保障号码到名字，表示社会保障号码功能性地决定学生名字，意味着相同的社会保障号码总是对应相同的名字。换句话说，每次看到123，我们都会看到AN。现在，这不一定适用于反向。也许不是每当我们看到AN时，都会是123。

但是每当我们看到123，它就是AN。所以我们希望做的是只存储一次这个关系，举例来说，记录123对应的名字是AN。Boyce-Codd范式所说的是，每当我们有一个这样的功能依赖时，该功能依赖的左侧必须是一个关键。想一想这意味着什么。记住，一个关键意味着我们对每个属性的值都有唯一的一个元组。

所以如果我们有例如社会保障号码到姓名的功能依赖，并且满足Boyce-Codd范式，那么我们就会说社会保障号码必须是我们关系中的一个关键，而且每个社会保障号码只会有一个元组。具体来说，我们可以回到原始关系。我们有这个功能依赖。

这里的社会保障号码不是一个关键，对吧？所以我们知道这不符合Boyce-Codd范式。

![](img/08c656414c2b104a8091d239884ef9ca_13.png)

因此，我们将使用功能依赖来帮助我们分解我们的关系，使得分解后的关系符合Boyce-Codd范式。在这个例子中，我们的功能依赖会告诉我们将社会保障号码和学生姓名提取到一个新的关系中，在这个关系中，社会保障号码是关键。

然后我们每个社会保障号码只记录一次，学生的名字也是。接着，我们会单独记录学生的信息以及他们申请了哪些大学。再次强调，我们将完全形式化这个概念，功能依赖的定义，它们的属性，范式，以及我们如何在后续的视频中进行分解。

现在让我们类似地说明多值依赖和第四范式的概念。其实这个稍微复杂一点，但仍然遵循大致相同的框架。现在让我们来看一下申请信息的另一个部分，假设现在我们只关心学生信息。

他们申请的大学以及他们曾就读的高中。我们仍然会有冗余和更新、删除异常。例如，一个申请斯坦福大学的学生将会为每一所他/她曾就读的高中记录一次该信息。一个曾就读于帕洛阿尔托高中的学生，将会为他/她申请的每一所大学记录一次该信息。

此外，我们还会遇到一种乘法效应。假设一个学生申请了C所大学并曾就读于H所高中。虽然我知道学生通常不会上很多所高中，但假设这是一个经常转学的学生。在这种情况下，我们将得到C乘以H的元组。

我们真正想要的，是类似C与H的关系，因为那样我们只会存储每条信息一次。现在有趣的是，这种特定设计的缺陷并没有被博伊斯-科得范式解决。事实上，这个关系符合博伊斯-科得范式，因为它没有。

功能依赖。并不是每一个社会安全号码实例都与一个特定的大学名称或一个特定的高中名称相关。如我们稍后将看到的，如果没有功能依赖关系，那么该关系会自动符合博伊斯-科得范式（Boyce-Codd Normal Form），但它并不符合第四范式。

![](img/08c656414c2b104a8091d239884ef9ca_15.png)

所以第四范式与所谓的多值依赖有关。当我们指定一个多值依赖时，就像我们这里使用双箭头所做的那样，这意味着如果我们在关系中取一个特定的社会安全号码，我们将会得到与之关联的每一个大学名称的组合。

每个社会安全号码与所有与该社会安全号码相关的高中一起存储。当我们有这个多值依赖时，我们实际上也会自动拥有这种关系。你知道，这看起来有点复杂。我们会完全形式化它，但现在，只需考虑多值依赖的英文陈述：它表明我们。

将会得到每一个给定社会安全号码下的这两个属性或属性值的所有组合。换句话说，这些值实际上是相互独立的。所以，如果我们遇到这种情况，那么我们真正应该做的是将每个大学名称与每个高中名称分开存储。

每个社会安全号码只记录一次与每个高中的关联。这就是第四范式将为我们做的事情。与博伊斯-科得范式类似，第四范式也要求如果我们有依赖关系，那么依赖关系的左侧必须是一个关键字。在这种情况下，我们正在查看的是多值依赖，所以它实际上表达的是不同的意思。但基本思想是一样的，那就是我们希望。

只有一个元组包含在多值依赖的左侧出现的每个值。那么我们来看一下在这个示例中会发生什么。如果我们使用多值依赖根据第四范式的思路来分解关系，那么直观的结果是显而易见的。我们将学生申请的大学名称信息与高中本身的信息分开。

然后我们会看到，每个事实只会存储一次，并且我们确实实现了存储C加H个元组，而不是C乘H个元组。就像在Boyzka范式中的函数依赖一样，我们将在后续的视频中完全形式化所有这些推理和定义。总结一下，我们将进行关系设计。

通过分解。我们将从指定包含所有我们想要捕捉的信息的超级关系开始，并指定数据的属性，这些属性通常以某种方式反映现实世界。系统可以根据我们指定的属性自动将超级关系分解成更小的关系，并保证最终的关系集。

关系具有某些良好的属性，这些属性在一个标准化形式中被捕捉。它们不会出现异常，并且保证不会丢失信息。我们将从指定属性作为函数依赖开始，系统会保证Boyzka范式，然后我们会在此基础上添加作为多值依赖指定的属性，从而保证第四范式。

这种形式比Boyzka范式更强，并且通常被认为是良好的关系设计。

![](img/08c656414c2b104a8091d239884ef9ca_17.png)
