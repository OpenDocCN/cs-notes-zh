- en: P25：15-02-basic-recursive-with-statement-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P25：15-02-basic-recursive-with-statement-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: This video gives a live demonstration of the recursive constructs in SQL that
    we introduced in the previous video。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本视频展示了我们在前一个视频中介绍的SQL递归构造的实时演示。
- en: '![](img/21534375bc2b413d811307b8b694e624_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_1.png)'
- en: As a reminder， recursion has been introduced into SQL as part of the width statement
    where we can set up relations that are defined by queries that themselves refer
    to the relation being defined。 And finally， we have a query that can involve the
    recursively defined relations as well as other tables in the database。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，递归已被引入SQL中，作为宽度语句的一部分，在这个语句中，我们可以设置由查询定义的关系，这些查询本身会引用正在定义的关系。最后，我们有一个查询，它可以涉及递归定义的关系以及数据库中的其他表。
- en: The typical expression within a width statement for recursively defined relation
    would be to have a base query that doesn't depend on R and then a recursive query
    that does depend on R。 We gave three examples in the introductory video， and those
    are the same examples that we'll be demonstrating shortly。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 递归定义关系中的典型表达式会是在宽度语句中，先有一个不依赖于R的基本查询，然后是一个依赖于R的递归查询。我们在介绍性视频中给出了三个示例，这些示例也是我们接下来要演示的内容。
- en: The first one was to compute ancestors when we have only a parent relation and
    the family tree could be arbitrarily deep。 Our second example was a case where
    we have an arbitrarily deep company hierarchy and we want to compute the total
    salary cost of a project starting at that project's manager and summing the salaries
    of the entire sub tree。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是计算祖先，当我们只有父母关系时，家族树可能深得无法预料。我们的第二个示例是一个关于公司层级关系的案例，层级可以非常深，我们想计算一个项目的总薪资成本，从该项目的经理开始，汇总整个子树的薪资。
- en: And our third example was about airplane flights where we want to find the cheapest
    way to fly from point A to point B and we're willing to change planes as many
    times as we might need to in order to bring down the cost。 We saw that all of
    these examples involved basically a notion of transit of closure computed as a
    recursively defined relation。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个示例是关于飞机航班的，我们想找到从A点到B点的最便宜的飞行方式，并且我们愿意根据需要换乘多次飞机以降低成本。我们看到所有这些示例基本上都涉及了一种闭包传递的概念，这个概念作为递归定义的关系进行计算。
- en: The last portion of our demo after we see these three queries solved using recursion
    will introduce one more twist。 which is what happens when we introduce cycles。
    So in the airline example。 we'll set up a case where you can fly from one city
    to another one and back。 which is of course true in reality， and we'll see what
    happens when we try to answer our query in that setting。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用递归解决这三个查询的演示的最后部分，我们将引入一个新的 twist，即当我们引入循环时会发生什么。所以在航空公司示例中，我们将设置一个案例，你可以从一个城市飞往另一个城市并返回，这在现实中当然是成立的，我们将看到当我们在这种情况下尝试回答查询时会发生什么。
- en: I've started by creating a table called parent of with parent child relationships。
    So we have Alice Carol Bob， Carol Carol， Dave and so on。 You might actually want
    to write this down in a piece of paper to see what the actual tree looks like。
    but the query we want to run is to find all of Mary's ancestors。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了一个名为parent的表，用来表示父母与子女之间的关系。所以我们有Alice、Carol、Bob，Carol、Carol、Dave等等。你实际上可能想在纸上写下来，看看实际的树形结构是什么样的，但我们要运行的查询是找到所有Mary的祖先。
- en: So we're going to of course have Eve as a parent and Dave as a parent and then
    Dave's parent is Carol and Carol's parent is Bob and so on。 We'll get most of
    the data in our database in our query。 So here is the query。 It's our first example
    of a recursive query。 Let me say right off that even more than anything else we've
    done in these videos。 I am going to encourage you to download the script and take
    a close look at the query and preferably actually run the queries and play with
    them on the Postgres system。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们当然会有Eve作为父母，Dave作为父母，然后Dave的父母是Carol，Carol的父母是Bob，依此类推。我们将在查询中获取数据库中的大部分数据。这里是查询，它是我们第一个递归查询的示例。让我直接说，即使比我们在这些视频中做过的任何事情，我也会鼓励你下载脚本，仔细查看查询，并最好在Postgres系统上实际运行查询并进行试验。
- en: And we are using for this demo Postgres， a SQL item MySQL do not support the
    with recursive statement at this point in time。 So anyway， here's our query and
    it is the form that we described in the introduction。 It's a with statement with
    recursive that's going to set up a recursive relation called ancestor。 So this
    is what we were calling our earlier。 This is our ancestor with the schema AD for
    ancestor and descendant。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次演示使用的是Postgres，SQL的一个项目，而MySQL目前不支持with recursive语句。无论如何，这是我们的查询，它的形式如我们在介绍中描述的那样。它是一个with语句，带有recursive，用来设置一个名为祖先的递归关系。这就是我们之前所说的。这是我们定义的带有AD模式的祖先关系，包含祖先和后代。
- en: Our final query once ancestor is all set up is very simple。 It just says take
    the A attribute from ancestor where a descendant is Mary。 So that will give us
    Mary's descendants。 Of course。 what's interesting is what's right here inside
    these parens because this is our recursive query and it does take the form we
    described of having a base query。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦祖先设置好后，我们的最终查询非常简单。它只是说从祖先表中取出A属性，其中一个后代是Mary。这样就会得到Mary的后代。当然，有趣的是括号里的部分，因为这是我们的递归查询，它确实采用了我们之前描述的形式，即包含基本查询。
- en: That's the first line and then the recursive query with a union between them。
    So we're going to start by saying that whenever we have a parent child relationship。
    that's also an ancestor relationship。 So we're going to take from our parent of
    table。 the parent and child and we have to rename them as A and D。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一行，然后是带有联合的递归查询。所以我们将从父子关系开始，这也是一种祖先关系。因此，我们将从我们的父母表中取出父母和孩子，并将它们重命名为A和D。
- en: And that says that parent children are in ancestor。 What else is an ancestor？
    Well。 if we have a top of an ancestor， an ancestor， and a descendant。 and that
    descendant is the parent of another person， then the ancestor。 the A and the ancestor
    together with the child from the parent of is also an ancestor relationship。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明父子关系是祖先关系。还有什么是祖先呢？嗯，如果我们有一个祖先，且这个祖先的后代是另一个人的父母，那么这个祖先与该父母的孩子也会形成一个祖先关系。
- en: So this is kind of doing the join， not just kind of。 it's actually joining our
    ancestor as it's been created and extending that relationship by joining with
    another instance of parent。 So you can kind of think of going down the ancestor
    tree adding relationships as we go down。 Again。 I really can't encourage you enough
    to download this query and play with it yourself to fully understand what's going
    on。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这有点像是在做连接，实际上它是在连接我们的祖先，并通过与另一个父母实例连接来扩展这种关系。你可以把它想象成在祖先树上向下添加关系。再强调一遍，我真的强烈鼓励你下载这个查询并亲自玩一下，充分理解它的工作原理。
- en: Let's go ahead and run it。 It's going to be rather anticlimactic。 When we run
    it。 we do discover that these five people are Mary's ancestors。 and if you draw
    on the little tree of the data， you can verify that that's the correct answer。
    Let's play around a little bit and try a few other people's ancestors。 Let's try
    Frank。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行它。这可能会有点平淡无奇。当我们运行时，我们确实发现这五个人是Mary的祖先。如果你画出数据的小树图，你可以验证这是正确的答案。我们来玩一下，尝试查找其他人的祖先。我们试试Frank。
- en: We don't see Frank here because Frank actually happens to be a child of Mary。
    so we should get even more ancestors when we write that when we run this one。
    especially Mary should be included。 And in fact， she is。 There she is。 And these
    are Frank's ancestors。 Let's try George。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看不到Frank，因为Frank实际上是Mary的孩子。所以，当我们运行这个查询时，我们应该能得到更多的祖先，特别是Mary应该被包括在内。事实上，她是的。她就在这里。这些是Frank的祖先。我们来试试George吧。
- en: I think George was somewhere in the middle of the tree there。 Yes， George has
    three ancestors。 And finally， let's try Bob。 I think Bob is at the root。 so we
    should get an empty result and we do because again Bob has no ancestors in our
    database。 Now let's take a look at our second example。 That was the one where
    we had a hierarchy of management chain in a company。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我想George大概位于树中的某个位置。是的，George有三个祖先。最后，我们来试试Bob。我认为Bob位于根节点，所以我们应该得到一个空结果，果然是这样，因为Bob在我们的数据库中没有祖先。现在让我们看看第二个例子。那是我们有一个公司管理链层级的例子。
- en: and then we were interested in computing the total salary cost of a project。
    So I've set up our three tables。 The first one is the employee table。 It just
    gives the IDs of the employees and the salary of each employee。 The second table
    is the manager relationship。 So again， you might want to draw the little tree
    here。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们关注的是计算项目的总薪资成本。所以我设置了三个表。第一个是员工表。它提供了员工的 ID 以及每个员工的薪资。第二个表是经理关系。所以你可能想画出这棵小树。
- en: although it's pretty simple this time。 One， two， three is at the root of our
    little management structure has two。 three， four as a subordinate。 Two， three，
    four has two subordinates， three， four， five， and four。 five， six。 M three， four，
    five is another one。 So it's only a three level tree。 Of course。 if we knew it，
    we're only three levels， we wouldn't need recursion at all。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这次的结构相对简单。根节点是第一、第二、第三号，管理着两个下属：第三、第四号和第四、第五号。第三、第四号有两个下属：第四、第五号和第五、第六号。M
    三、四、五是另一个。因此它只是一个三层树。如果我们知道只有三层的话，其实完全不需要递归。
- en: but we're going to write a query that will work for arbitrary numbers of levels。
    So that's our management structure。 And finally， our third table。 the project
    table says that employee one， two， three is the manager of project X。 So what
    we want to do is find the manager of project X in the hierarchy and then take
    that manager's salary along with the salaries of all of the managers。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们要写一个能适应任意层数的查询。所以这是我们的管理结构。最后，第三个表，项目表，表明员工一、二、三是项目 X 的经理。所以我们要做的是在层级结构中找到项目
    X 的经理，然后加上所有经理的薪资。
- en: Subordinates recursively down the management structure。 And of course。 that's
    everybody in our little database。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下属递归地遍历管理结构。当然，这就是我们小数据库里的所有人。
- en: '![](img/21534375bc2b413d811307b8b694e624_3.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_3.png)'
- en: Again， can't encourage you enough to download the script and run it for yourself。
    So here's our query to find the total salary of project X。 And I'm actually going
    to give a couple of different ways of running this query。 The way we've done it
    the first time is to effectively expand the management structure into a relation
    called Superior。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强烈建议你下载脚本并自己运行一下。所以这是我们查询项目 X 总薪资的查询。实际上，我会给出几种不同的查询方式。我们第一次做的方式是将管理结构展开成一个叫做
    Superior 的关系。
- en: So that's really pretty much doing the ancestor computation。 which by the way
    is a transitive closure。 I should have mentioned that earlier。 For those of you
    familiar with transitive closure， it's basically that operation。 So we're going
    to compute these superiors so that we'll have every manager and employee relationship
    where the manager is arbitrarily above the employee。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这实际上是在做祖先计算，顺便提一下，这就是传递闭包。我早该提到的。对于熟悉传递闭包的人来说，它基本上就是那个操作。因此，我们将计算这些 superior
    关系，以便拥有每一个经理与员工的关系，其中经理是员工的上级。
- en: And then once we have that superior relationship computed。 then we write actually
    a fairly complicated query。 So this is the final query of our with statement。
    And this one says we've got this recursive relation superior。 We're going to sum
    up the salaries from the employee relation where the ID is either the manager
    of the project X。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们计算出这个 superior 关系，我们就写一个相当复杂的查询。所以这是我们 with 语句的最终查询。这个查询说，我们有这个递归关系 superior。我们将从员工表中汇总薪资，其中
    ID 要么是项目 X 的经理。
- en: So that's the first half here。 Or the an employee that's managed by the manager
    of project X。 Now this down here， I just want to emphasize this is not recursive。
    It just so happens to have that same structure of union。 But there's nothing recursive
    happening down here。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是前半部分。或者一个由项目 X 的经理管理的员工。现在这里，我想强调的是，这不是递归的。恰好它有相同的联合结构，但这里并没有发生递归。
- en: So this is just a regular SQL query once we have the superior relation。 That's
    the transitive closure of the manager relation。 So let's take a look at superior。
    Superior here， this is recursive with the union says that if we have a manager
    and that's the M ID and E ID。 then if somebody is managing someone else， then
    they are their superior。 Notice by the way。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一旦我们拥有了 superior 关系，这就是经理关系的传递闭包，我们就可以写一个普通的 SQL 查询。让我们来看一下 superior。Superior
    这里，使用递归与联合表示，如果我们有一个经理，且其 ID 是 M ID 和 E ID，那么如果某人管理另一个人，那么他们就是这个人的上级。顺便提一下。
- en: I didn't specify a schema here。 So the schema is implicitly going to be M ID
    E ID。 So we're going to put manager relationships in。 And then if we have a superior
    relationship。 so if we have an M ID managing an E ID in the S relationship。 then
    we can add one more level because we join with the manager saying that if we have
    if X is a superior of Y and Y is the manager of Z。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里没有指定架构。所以架构隐式地将是 M ID E ID。所以我们会加入经理关系。然后如果我们有一个上级关系，也就是如果 M ID 管理着 E ID
    的 S 关系，那么我们可以再添加一层，因为我们通过与经理的连接，假设如果 X 是 Y 的上级，且 Y 是 Z 的经理。
- en: then X is a superior of Z。 This parallels exactly what we did with the ancestor
    computation in the previous example。 Again， it's going to be rather anti climactic
    to run the query， but let's do it。 And we find out that 400 is the total salary
    cost of project X when we count the manager of project X together with all of
    the people。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 X 是 Z 的上级。这与我们在前面的例子中计算祖先关系时完全相同。再一次，运行查询的结果可能会比较平淡，但我们还是做一下。我们发现，当把项目 X
    的经理与所有参与人员一起计算时，项目 X 的总薪资成本为 400。
- en: '![](img/21534375bc2b413d811307b8b694e624_5.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_5.png)'
- en: Underneath that manager in the hierarchical structure。 So when we think of recursion。
    we often think of transitive closure or expanding hierarchies as we've done with
    our examples so far。 But if we step back for a second， we can see that there's
    quite a bit。 quite a bit simpler way to express the query that finds the salary
    burden of project X。 Now。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个经理下的层级结构中。所以，当我们想到递归时，通常会想到传递闭包或扩展层级结构，就像我们之前的例子那样。但是如果我们稍微退后一步，就会发现有一种更简单的方式来表达查询，来计算项目
    X 的薪资负担。现在。
- en: not only is this actually nicer to look at， it's probably much more efficient
    depending on how smart the query processor is。 In our previous example， if the
    query processor X used the query in the straightforward way。 it would compute
    the superior relationship for the absolute entire company hierarchy before it
    figured out which of those people were involved in project X。 Now， a really good
    query processor might actually figure out to fold in a project X。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，这种表达方式实际上更好看，而且可能更加高效，这取决于查询处理器有多智能。在我们之前的例子中，如果查询处理器以直接的方式使用查询，它会计算整个公司层级结构中的上级关系，然后才找出哪些人参与了项目
    X。现在，一个非常好的查询处理器可能会智能地处理，直接将项目 X 并入其中。
- en: but not necessarily。 Here's an example， and here's a new formulation of the
    query。 where we're actually going to tie X specifically to our recursion。 What
    we're going to compute in our recursive with statement here。 so this is the temporary
    relation we're computing。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但不一定。这里有一个例子，展示了查询的新表述方式，在这个查询中，我们实际上会将 X 特定地与我们的递归绑定。我们将在递归的 with 语句中计算。这是我们正在计算的临时关系。
- en: is a relation containing just a list of the IDs of the employees who are involved
    in project X。 Once we have all the employees involved in project X， the query
    down here is trivial。 We just find those employees who are among the X employees，
    and we sum up their salaries。 So let's take a look at the recursive definition
    here， and again。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只包含涉及项目 X 的员工 ID 列表的关系。一旦我们找到了所有参与项目 X 的员工，下面的查询就非常简单。我们只需找出这些员工是否属于 X 员工，并将他们的薪资相加。所以，让我们来看看这里的递归定义，再次强调。
- en: it's taking the usual form of a base query， union， or recursive query。 And here's
    what we do。 Well。 obviously， the manager of project X is one of the IDs involved
    in project X。 So here we find in the project the project named X， and we take
    the manager of that project。 and we put that person's ID into XMs。 That's the
    first ID that's going to go in there that's going to seed the recursion。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它呈现出通常的查询形式，包括基本查询、联合查询或递归查询。接下来我们来看看怎么做。显然，项目 X 的经理是项目 X 中涉及的 ID 之一。因此，在项目中，我们查找名为
    X 的项目，并提取该项目的经理，并将那个人的 ID 放入 XMs 中。这就是将进入递归的第一个 ID。
- en: That's again the base query。 Then we add in our recursive step any employee
    who is managed by anybody who's in the X employees。 So we'll take our manager
    relationship， our X employees relationship。 and if the employees manager is in
    X， then that employee is also involved in X。 So we seed the recursion with the
    manager of project X。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是基本查询。然后我们加入递归步骤：任何由 X 员工中的某个人管理的员工都会被算作与 X 相关。因此，我们将使用经理关系和 X 员工关系，如果该员工的经理在
    X 中，那么这个员工也参与了 X。所以我们用项目 X 的经理作为递归的起始点。
- en: and then we just recursively go down the tree adding all the employees that
    are underneath one by one。 We don't have to know the depth of the tree because
    the recursion will continue until nobody else is added。 I guess I should have
    mentioned that earlier in my earlier examples。 Again。 the recursion sort of adds
    data over and over again until there's nothing new to add。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需递归地向下遍历树，逐一添加所有在下层的员工。我们不必知道树的深度，因为递归将继续，直到没有人再被添加。我想我应该在之前的示例中提到这一点。再一次，递归会反复添加数据，直到没有新数据可添加。
- en: and that's when it terminates。 So let's go ahead and run the query， anti-climactic
    again。 but we get the same answer of 400 as the salary cost of project X。 Now
    we use the same form of query to find the total salary cost of two projects， Y
    and Z。 and that will also demonstrate having two relations that are defined in
    the with recursive command。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它就结束了。那么让我们继续运行查询，再次有些让人失望，但我们得到了与项目X薪资成本相同的答案，即400。现在，我们使用相同形式的查询来查找两个项目Y和Z的总薪资成本，这也将展示在with
    recursive命令中定义的两个关系。
- en: '![](img/21534375bc2b413d811307b8b694e624_7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_7.png)'
- en: So we've added projects Y and Z to our project table。 and they're both managed
    by employees who are already in the database。 so they're a little lower down the
    hierarchy。 We should expect those projects to have lower total costs than for
    project X whose manager was at the root of our hierarchy。 So here's our query。
    It's a big one。 We're going to define YMs and ZMs exactly as we defined XMs in
    the previous examples。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将项目Y和Z添加到我们的项目表中，它们都由数据库中已有的员工管理，因此它们位于层次结构的稍低位置。我们应该预期这些项目的总成本会低于项目X，因为项目X的经理位于我们层次结构的根部。所以这是我们的查询，这是一个很大的查询。我们将定义YMs和ZMs，正如我们在前面的示例中定义XMs一样。
- en: So YMs is a table of a recursively defined relation temporary that's going to
    contain a list of IDs of the people that employees who are involved in project
    Y。 So we're going to put the manager of project Y as our base query。 and then
    we're going to add to it in the recursion all of the employees who are managed
    by someone who's in the YMs。 And ZMs is exactly the same。 We start with the manager
    of project Z。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以YMs是一个递归定义的关系表，它将包含参与项目Y的员工ID列表。所以我们将项目Y的经理作为我们的基础查询，然后我们将在递归中添加所有被YMs中某个员工管理的员工。ZMs也是完全一样的。我们从项目Z的经理开始。
- en: and then we add to it all of the people who are managed transitively down the
    tree by someone who's in the ZMs relation。 And then our final query down here
    for the with statement is a union of two queries。 The first one gets the total
    salary for Y， and it labels it as Y total。 So it takes all the IDs that are in
    the YMs table。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将所有通过在ZMs关系中的某个人传递管理的人员加到树中。接下来，我们在这里的最终查询对于with语句是两个查询的并集。第一个查询获取Y的总薪资，并将其标记为Y
    total。因此，它获取所有在YMs表中的ID。
- en: and from the employee table gets their salaries and sums them up， and similarly
    the Z total。 So now we'll run this query。 It'll be slightly less anti-climatic。
    We do have now two tuples in our result。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从员工表中获取他们的薪资并将其求和，同样是Z总薪资。那么我们现在运行这个查询，它将稍微少些让人失望。我们现在的结果中确实有两个元组。
- en: '![](img/21534375bc2b413d811307b8b694e624_9.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_9.png)'
- en: We see that the total salary for Y is 300 and the total salaries for Z is 70。
    And if you cross check this result against the data。 you'll see that these are
    indeed the total salaries when we take the managers we specified for projects
    Y and Z。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Y的总薪资是300，Z的总薪资是70。如果你交叉检查这个结果与数据，你会看到，当我们考虑为项目Y和Z指定的经理时，这些确实是它们的总薪资。
- en: '![](img/21534375bc2b413d811307b8b694e624_11.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_11.png)'
- en: And finally， our last and most fun example， the one to find how to fly from
    point A to point B when all we're concerned about is cost。 and we don't care how
    many times we have to change planes。 So here's the little flights table I've set
    up， and I used A and B so we can literally fly from point A to point B。 All of
    our intermediate destinations are actually real airport codes， and I've put in
    some airlines。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是我们的最后一个也是最有趣的例子，找出如何从A点飞到B点，而我们只关心的是成本，而不在乎换多少次飞机。所以这是我设置的小型航班表，我用了A和B，方便我们字面上从A点飞到B点。我们所有的中途目的地实际上都是实际的机场代码，我还加入了一些航空公司。
- en: although they're not actually going to be used in our query。 And then I've put
    in the cost of the flights。 You might want to draw yourself a little graph so
    you can see what's going on。 and we can fly from A to Chicago for 200 from Chicago
    to B for another 100。 or we can go from A to Phoenix。 And then Phoenix to Las
    Vegas and Las Vegas to， oh。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在我们的查询中实际上并不会被使用。我还加入了航班的费用。你可能想画一个小图表，这样你就能看到发生了什么。我们可以从A飞到芝加哥，费用是200，从芝加哥飞到B又需要100，或者我们可以从A飞到菲尼克斯，然后从菲尼克斯飞到拉斯维加斯，再飞到...哦。
- en: I don't remember what this is， C M H Detroit Cincinnati somewhere in the Midwest。
    and from there to point B， or we can take a nonstop from A to B on good old jet
    blue for 195。 So clearly we're never going to be going through Chicago for a total
    of 300 with that jet blue flight。 But I've set up the data as you're probably
    not surprised so that there's a long route through Phoenix to Las Vegas and somewhere
    in the Midwest is in fact going to be our cheapest way to go。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我不记得这是什么，CMH是底特律、辛辛那提附近的某个地方。从那里到B点，或者我们可以乘坐老牌的JetBlue直飞A到B，费用是195。所以显然，搭乘这班JetBlue航班，经过芝加哥的300美元费用显然是不可能的。但如你所料，我已经设置了数据，以便通过菲尼克斯到拉斯维加斯和中西部的某个地方，事实上，这将是我们最便宜的路线。
- en: So now let's take a look at the recursive query that's going to find us our
    route from point A to point B。 or at least find us the cheapest way to get from
    point A to point B。 So the first query I'm going to show actually gives us all
    the different costs of getting from A to B just so we can see those enumerated
    for us。 and then we'll modify the query to give us the cheapest cost。 So here's
    the recursive query。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看递归查询，它将帮助我们找到从A点到B点的路线，或者至少找到从A点到B点的最便宜方式。首先，我将展示的查询实际上列出了从A到B的所有不同费用，目的是让我们看到这些费用的枚举。然后，我们会修改查询，给出最便宜的费用。这就是递归查询。
- en: and we're going to use a recursively defined relation called root。 And root
    says that we can get from an origin to a destination for a particular total cost。
    Okay。 so we again in our recursion have the base query and the recursive query。
    This is exactly what you'd imagine。 We can certainly get from point X to point
    Y for a total cost if we can take a direct flight from point X to point Y for
    a given top cost。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个递归定义的关系，称为`root`。`root`表示我们可以从一个出发地到达目的地，并且有一个特定的总费用。好吧，所以我们在递归中有基本查询和递归查询。这正是你想象的那样。如果我们能从X点到Y点搭乘直飞航班，那么我们就能以给定的最高费用从X点到Y点。
- en: So that's our base query。 We start out with all of the direct flights in our
    root relation。 and then we start adding roots by doing the join of a root with
    an additional flight。 So basically what this joint here says is if I can get from
    the origin in a root to the destination。 and then that destination is the origin
    of another flight， then I can add that flight。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的基本查询。我们从`root`关系中的所有直飞航班开始，然后通过将`root`与额外航班连接来添加更多路径。所以，基本上这里的连接意味着，如果我可以从`root`中的某个出发地到达目的地，并且这个目的地是另一航班的出发地，那么我就可以添加这个航班。
- en: I can start with my original origin， final destination。 and the cost of that
    is going to be the total that I already had plus the cost of the new flight。 and
    that's my new total。 So again， this is another transit of closure like recursion。
    It's very similar to the ancestor recursion， very similar to expanding the company
    hierarchy。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从我的原始出发地和最终目的地开始。然后，成本将是我已经拥有的总额加上新航班的费用。这就是我的新总额。所以，这又是一个类似递归的封闭遍历。这与祖先递归非常相似，非常类似于扩展公司层级。
- en: The only real difference here is that we're also accumulating these costs as
    we do the recursion。 So once we've done this recursion， then we have a complete
    specification of all the roots within our flights database all of the ways we
    can get from A to B。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的真正区别在于我们在执行递归的同时也在积累这些成本。所以一旦我们完成了递归，那么我们就可以完全指定我们航班数据库中所有的路径，所有从A到B的方式。
- en: And the total cost。 Now one thing I should say is this is not actually giving
    us the ways of getting from one place to another。 If we wanted to accumulate the
    actual root that we take。 so the flights and the costs and the airlines and so
    on。 we'd have to kind of use a structured structure inside our database to accumulate
    those。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以及总费用。现在我应该说，这实际上并没有给我们从一个地方到另一个地方的所有方式。如果我们想积累我们实际采取的路径，也就是航班、费用、航空公司等，我们需要在数据库中使用结构化的方式来存储这些信息。
- en: There are ways of doing that， but I'm not going to demonstrate that here。 I'm
    just going to demonstrate the basic use of recursion and computing the total cost。
    Okay。 so let's go ahead and run this query。 So we've computed all of the roots
    and then we're just going to start by finding the roots from A to B and what the
    total costs of those are。 So we'll run the query and we'll find out that there
    are three ways of getting from A to B。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有实现这个的方法，但我这里不打算演示。我只是要演示递归的基本用法和计算总费用的过程。好的，那我们就继续执行这个查询。我们已经计算了所有的路径，然后我们将从
    A 到 B 开始查找，看看这些路径的总费用是多少。我们将运行查询，结果会发现从 A 到 B 有三种不同的方式。
- en: The first one happened to be that direct jet blue flight for 195。 The second
    was the flight through Chicago for a total cost of 300。 You can go back and look
    at the data and verify these。 And the third one was that complicated rooting where
    we stopped several times。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果恰好是那班直飞的捷蓝航班，费用为195。第二个是经过芝加哥的航班，总费用为300。你可以返回查看数据并验证这些结果。第三个则是复杂的路径，其中我们停留了几次。
- en: but we save a lot of money。 Well， $20 over the direct flight by going through
    those cities because the total cost is 175。 I'll leave it up to you whether it's
    worth $20 to stop several times versus the direct flight。 So now since my actual
    specification of what I wanted to know was the cheapest way to go。 then I just
    say min total instead of star in my final query。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们节省了不少钱。通过经过那些城市，和直接航班相比节省了$20，因为总费用是175。我留给你决定是否值得为了节省$20而多次停留，还是选择直接航班。所以现在，由于我实际的需求是找到最便宜的方式，那么我只需要在最终查询中使用最小总费用（min
    total），而不是星号（star）。
- en: And I run that and my answer is that 175 is the cheapest way to get from A to
    B。 Now here's an alternative formulation of the same query that essentially parallels
    the alternative that we looked at with our project costs where we built in project
    X into our recursion that simplified the recursion in that case。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我执行这个查询后，得到的答案是175是从 A 到 B 的最便宜方式。现在这里有一个替代的查询方式，它本质上与我们在项目成本中所看的替代方案相似，我们在递归中加入了项目
    X，简化了那个情况下的递归。
- en: In this case it's not simpler， but it could potentially be more efficient。 We're
    going to build in the fact that we're starting from origin A。 So instead of finding
    all roots from any point to any other point in our recursion and then finding
    the roots from A to B。 let's create a relation recursively that says starting
    from point A。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这并不更简单，但它可能会更高效。我们将从起点 A 开始，构建这个事实。所以下次我们不再需要在递归中查找从任意点到任意其他点的所有路径，再查找从
    A 到 B 的路径。让我们递归地创建一个关系，表示从 A 点出发。
- en: I can get to a particular destination for a particular total cost。 So this is
    going to build up roots starting from A。 the base query is going to of course
    start by looking at direct flights where the origin is A and it's going to put
    the destination and the cost into our relation called from A。 So that starts with
    that first gives us direct flights from A where we can get on the direct where
    we can get to and how much it will cost us。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以以特定的总费用到达某个特定的目的地。所以这个方法将从 A 开始构建路径。基础查询当然会先查找直飞航班，其中出发点是 A，然后将目的地和费用加入到我们名为
    from A 的关系中。所以这就开始了，首先给出我们从 A 出发的直飞航班，我们可以登上这些航班并到达目的地，且知道费用是多少。
- en: And then our recursion is going to add flights to that one。 Again it really
    parallels what we did with the project X。 Our recursion is going to say， okay。
    we know we can get from particular， we can get to a particular place from point
    A for a certain cost。 So that's our destination。 If we add one more flight。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的递归将会在这个基础上添加航班。它实际上与我们在项目 X 中所做的非常相似。我们的递归会说，好的，我们知道从 A 点出发，能以一定的费用到达某个特定地点。那么那个地点就是我们的目的地。如果我们再加上一个航班。
- en: so the origin of that flight is the destination where we can get。 then that
    will also be a destination that we can get to from point A and we'll just add
    the address。 And we'll just add the cost of the additional flight on。 One more
    time。 a strong suggestion that you download and try these things for yourself。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个航班的起点是我们可以到达的目的地。那么这个目的地也将是我们可以从 A 点到达的目的地，我们只需要将这个地址加进来。然后我们只需要加上额外航班的费用。再提醒一次，强烈建议你下载并亲自尝试这些操作。
- en: Once we've found all the places we can get from A。 then we'll use that to figure
    out the cheapest way to get to point B。 But let's just start by running with the
    width statement where all we do is see the places we can get to from A and the
    total cost of getting there。 So here we go， and we can get to Chicago Phoenix，
    we can get to be a couple of different ways。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了所有可以从 A 到达的地方，我们就可以用它来找出到达 B 点的最便宜方式。但让我们先运行一个宽度语句，其中我们只查看可以从 A 到达的地方及其到达费用。所以，开始吧，我们可以到达芝加哥、凤凰城，也可以用几种不同的方式到达
    B。
- en: three different ways actually， as we already knew。 we can also get to Las Vegas
    and this mysterious CMH I wish I remembered what it worked。 So now if we're interested
    in finding the cheapest way to get from A to B。 then we'll add where the destination
    equals B on here and we'll add the minimum total cost。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 三种不同的方式，实际上，正如我们已经知道的那样，我们还可以到达拉斯维加斯和这个神秘的 CMH，我真希望我记得它是什么。因此，现在如果我们有兴趣找到从 A
    到 B 的最便宜路线，我们将在这里添加“where destination = B”，并加上最小总成本。
- en: And hopefully that will be our good old 175 and indeed it is。 By the way。 we
    can do the same basic idea about backwards， instead of finding all the places
    that we can get from city A。 how about if we find all the places from which we
    can get to city B。 So here's the query that does that。 To be is going to be a
    recursively defined relation that's going to give us the origin。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这会是我们经典的 175 结果，确实如此。顺便说一句，我们也可以做相同的基本操作，但反向的。不是找出所有可以从 A 城市到达的地方，而是找出所有可以到达
    B 城市的地方。那么，这里就是执行该操作的查询。B 将是一个递归定义的关系，它将给我们出发地。
- en: the place from which we can get to be and the total cost of getting to be from
    that place。 So again。 the structure is exactly parallel。 We start out with our
    base query saying if we have a direct flight to B。 then we can get from the origin
    of that direct flight at the cost of the flight to B。 And then we recursively
    add flights on， but you can think of if you're going from left to right。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从哪些地方可以到达 B 以及从该地方到达 B 的总费用。所以，结构完全相同。我们从基本查询开始，假设如果我们有到 B 的直飞航班，那么我们可以从该航班的出发地按航班费用到达
    B。然后我们递归地添加航班，但你可以想象成从左到右。
- en: adding flights from the left。 So if we know we can get from a place to B and
    then we can go from。 take a direct flight from somewhere else to that place。 then
    we can get from that somewhere else to B。 Anyway， so we do that again by joining。
    so we're going to take our origin from which we can get to B。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧添加航班。所以如果我们知道可以从 A 地到 B 地，然后我们可以从其他地方直接飞到那个地方，那么我们就可以从其他地方到 B 地。无论如何，我们通过连接来再次实现这一点。因此，我们将以可以到达
    B 的出发地为起点。
- en: We're going to find flights that take us to that origin。 We're going to add
    the cost of that flight。 and that gives us a new way to get to B。 And then let
    me start by just writing the query that finds all of the places from which we
    can get to be in the cost of getting there。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将找到带我们到这个出发地的航班。我们将加上该航班的费用，这样就会给我们一个新的到达 B 的方式。然后让我先写出查询，找到所有可以从某地到达 B 的地方以及到达那里所需的费用。
- en: We'll run the query and we can see that we can get to B from point A in three
    different ways and from our other cities in our database as well。 Similarly to
    what we did previously， if we're particularly interested in getting from A to
    B。 whoops， let's make that our origin， then we add where origin equals A。 And
    if we want the minimum。 it would be our minimum total， again paralleling exactly
    what we did before。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行查询，我们可以看到我们可以通过三种不同的方式从 A 地到 B 地，也可以从我们数据库中的其他城市到达 B。类似于我们之前所做的，如果我们特别关注从
    A 到 B。那么，哎呀，让我们把那个作为出发地，然后添加“where origin = A”。如果我们想要最小值，那么它将是我们的最小总成本，再次完全与之前的做法相同。
- en: we run it and good old 175 comes out。 Now we're going to have some real fun
    because I added another flight to our database。 And this flight takes us from
    Columbus， I now know it's Columbus。 to Phoenix and creates a loop in our flights。
    So that means that we can fly from A to Phoenix to Las Vegas to Columbus back
    to Phoenix and then to Las Vegas and Columbus again。 So we're going to have arbitrarily，
    actually unbounded。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行它，得到了经典的 175 结果。现在我们将开始一些真正有趣的事情，因为我在我们的数据库中添加了另一个航班。这个航班将我们从哥伦布（我现在知道是哥伦布）带到凤凰城，并在我们的航班中创建了一个循环。这意味着我们可以从
    A 飞到凤凰城，再到拉斯维加斯，然后回到哥伦布，再到凤凰城，再到拉斯维加斯，最后再回到哥伦布。这样，我们就会有任意多个，实际上是无限的方式。
- en: actually infinite length routes that we can take now。 Now obviously those routes
    aren't going to ever be the cheapest way because as we take those routes it's
    going to get more and more expensive。 None of them are negative costs paying us
    to take flights。 But if we just do our naive recursion where we generate all of
    our routes before we take a look at our final query。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，现在我们可以采取无限长的路线。显然，这些路线永远不会是最便宜的方式，因为随着我们采取这些路线，成本会越来越高。没有一条路线是负成本的，也不会有任何路线是支付我们飞行费用的。但如果我们只是进行天真的递归，在我们查看最终查询之前生成所有的路线。
- en: then we're going to be generating an infinite number of routes。 So here's our
    original query。 the first one we wrote where we were just finding all of the costs
    of getting from A to B by computing all of the routes in the entire database and
    then looking at those from A to B。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将生成无限多的路线。下面是我们原始的查询。我们写的第一个查询，通过计算整个数据库中的所有路线，然后查看从A到B的路线，来查找从A到B的所有成本。
- en: Now with our additional flight that creates a loop we run this command and nothing
    happens。 Actually if we wait long enough we're going to get an error。 Well okay，
    we waited for a while。 It appears that the user interface we're using isn't going
    to show us the error。 But if you try running this in Postgres command line interface
    I assure you if you wait long enough eventually it'll tell you that the recursion
    effectively overflowed。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加入了额外的航班，创建了一个循环，我们运行这个命令，什么也没发生。实际上，如果我们等得够久，我们会得到一个错误。好吧，我们等了一会儿。似乎我们正在使用的用户界面不会显示错误。但如果你在Postgres命令行界面中运行这个，我向你保证，如果你等得够久，最终它会告诉你递归实际上已经溢出。
- en: So it is trying to compute this unbounded number of routes in the recursive
    part of the with statement and never even gets to the query that we want to execute。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它正在尝试计算在`WITH`语句的递归部分中这个无限数量的路线，甚至都没有到达我们想要执行的查询部分。
- en: '![](img/21534375bc2b413d811307b8b694e624_13.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_13.png)'
- en: Okay so here's my first attempt at fixing the problem。 We know that we're never
    going to want to take an arbitrarily long route。 We're never going to want to
    go around a cycle lots of times as our cheapest way to get from point A to point
    B。 So what I've done here and I'm not going to go into this in great detail but
    I've added a condition in the recursion that says I'm only going to add a new
    route。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我第一次尝试解决这个问题。我们知道我们永远不会想采取一个任意长的路线。我们永远不会希望以绕圈子多次的方式作为从A点到B点的最便宜路线。所以我在这里做了一个处理，我不会详细介绍，但我在递归中添加了一个条件，表示我只会添加一条新路线。
- en: a new route into my recursively defined route table when the total cost of that
    route and that's defined as the cost plus total here when we added is less than
    all of the ways。 we can already get from that place to that origin to that destination。
    So in other words I'm only going to add cheaper routes than the ones that are
    already there。 And by the way if there are no routes already from the origin to
    the destination then this will be satisfied and we will add that first route then
    after that only adding cheaper ones。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当一条新路线加入到我的递归定义路线表中时，当这条路线的总成本（在此定义为成本加总费用）小于从该地点到目标地点的所有已有路线的成本时，我才会加入新路线。换句话说，我只会添加比已经存在的路线更便宜的路线。而且顺便提一下，如果从起点到终点没有已有路线，那么这个条件会被满足，我们会添加第一条路线，然后只会添加更便宜的路线。
- en: So let's try running this query and see what happens。 Well we got an error。
    Now this is not a runtime execution error。 This is actually an error that says
    we're not allowed to refer to our recursively defined relation in a sub query
    within our recursion。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们试着运行这个查询，看看会发生什么。嗯，我们遇到了一个错误。这个不是运行时执行错误。实际上，这是一个错误，表示我们不允许在递归查询中引用我们递归定义的关系。
- en: The SQL standard actually might allow this particular use but I don't know that
    any implementation actually handles it。 It can be fairly difficult to handle a
    case where you have the recursively defined relation in a sub query as well as
    in the outer query here。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: SQL标准实际上可能允许这种特定的用法，但我不知道有任何实现真正处理它。处理递归定义关系在子查询和外部查询中同时出现的情况可能相当困难。
- en: So that's obviously not going to solve our problem。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以显然这并不能解决我们的问题。
- en: '![](img/21534375bc2b413d811307b8b694e624_15.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_15.png)'
- en: Now there's actually a feature of basic SQL that can help us here with our problem。
    There's something called limit。 We actually didn't discuss this in the SQL videos
    but that says just give us this number of results。 So let's say that we're going
    to have our recursion here for the routes but down here we're going to say I only
    need up to 20 results for how I get from point A to point B。 And the Postgres
    system actually makes use of the limit command in the final query to restrict
    the recursion。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际上有一个基本SQL的特性可以帮助我们解决这个问题。有一个叫做limit的东西。我们在SQL视频中实际上没有讨论过，但它的作用是给我们指定结果的数量。假设我们将有一个关于路线的递归，但在这里我们会说我只需要最多20个结果来表示从A点到B点的路径。而Postgres系统实际上会在最终查询中使用limit命令来限制递归。
- en: It's a nice feature and it was added specifically for this problem of possibly
    infinite recursions where we actually don't want it to be infinite because we
    only need a finite number of answers。 Okay so let's go with that here and we'll
    see that great。 Everything worked well。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的功能，专门为可能出现的无限递归问题添加的，在这种情况下我们实际上不希望它是无限的，因为我们只需要有限数量的答案。好的，既然如此，我们就这样做，看看效果。所有的都运作得很好。
- en: We got our routes from A to B and I do have 20 routes。 So they're getting very
    expensive。 Down here I'm going to go around and around the Midwest lots and lots
    of times but that did limit the recursion。 It did stop unlike our query where
    we didn't have the limit and it just went on indefinitely。 So that looks pretty
    good with one unfortunate problem which is if we still want the minimum we're
    going to again get a infinite execution。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了从A到B的路线，我有20条路线。所以它们变得非常昂贵。在这里，我会在中西部绕来绕去很多次，但这确实限制了递归。它停了下来，不像我们的查询那样没有限制，结果是无限进行的。所以这个看起来不错，唯一的一个不幸问题是，如果我们仍然想要最小值，我们会再次遇到无限执行的情况。
- en: So the old result is still sitting here but now the system is chunking along
    because the limit here is applied to this min to the number of tuples in our result。
    That's not going to limit the recursion。 We're always going to get only one tuple
    in our result。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以旧的结果仍然在这里，但现在系统在继续处理，因为这里的限制应用于最小值到我们结果中元组的数量。这不会限制递归。我们总是会在结果中只得到一个元组。
- en: So even if we said limit one here we'd still get the infinite behavior。 So we
    haven't quite solved our problem。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在这里说限制为1，我们仍然会得到无限的行为。所以我们还没有完全解决问题。
- en: '![](img/21534375bc2b413d811307b8b694e624_17.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_17.png)'
- en: Okay so here's what we're going to do。 Eslitically maybe it's not the absolutely
    best solution but I'm going to argue that it's a pretty reasonable one。 We tried
    limiting our recursion to only add new routes that were cheaper than existing
    routes to and from the same place。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是我们要做的。虽然从严格意义上讲这可能不是最好的解决方案，但我认为它是一个相当合理的方案。我们尝试限制递归，只添加比现有路线便宜的新的路线，以便从同一地点来回。
- en: We weren't allowed to do that syntactically。 The recursive with statement didn't
    allow the sub query with the recursively defined relation in it。 So we're going
    to do a different change here where we're not going to add new routes to our flight
    when the length of the route。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上我们不允许这样做。递归的with语句不允许带有递归定义关系的子查询。所以我们将做一个不同的改变，我们不再在航班的路线长度时添加新的路线。
- en: in other words the number of flights contributing to that route is greater than
    or equal to ten。 So how do we do that？ We're going to add to our recursively defined
    relation route the origin destination and total cost of that and then we're going
    to add the length。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，贡献到该路线的航班数量大于或等于十个。那么我们该怎么做呢？我们将向我们递归定义的路线关系中添加出发地、目的地以及它们的总成本，然后再添加长度。
- en: And so that's going to put in each route table how many flights were involved
    in that route。 So let's see how we do that with our recursion。 We still have the
    base case here and the recursively defined union。 In our base case we're going
    to be adding to our route the nonstop flights so we'll have exactly what we had
    before and then we'll have the constant one to say that this nonstop flight is
    just one flight。 Then when we do our recursion we're joining our route relation
    that we're building up by extending it with an additional flights exactly as before。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录每条路线所涉及的航班数量。那么我们来看一下如何通过递归实现这一点。我们依然有基本情况以及递归定义的联合。在我们的基本情况下，我们将添加直飞航班，因此我们会得到与之前一样的结果，然后加上常数1，表示这次直飞航班就是一次航班。然后，当我们进行递归时，我们将通过扩展路线关系来加入额外的航班，就像之前一样。
- en: But there's two changes here。 One of them is that we're going to compute our
    new length by adding one to the existing length of the route for our new route
    because we're adding one flight and then we're only going to add tuples to the
    route relation when the length of the route that we're adding is less than ten。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有两个变化。其一是，我们将通过将现有路线的长度加一来计算新路线的长度，因为我们新增了一个航班，然后只有当我们添加的路线长度小于十时，才会将元组添加到路线关系中。
- en: So now let's see what happens。 I'm going to start again by looking at all of
    the costs of getting from point A to point B and then we'll take a look at finding
    the least。 So we'll go ahead and execute the query and we see that we have one
    to three or five ways of getting from A to B where the length of the route。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看会发生什么。我将重新开始，查看从A点到B点的所有费用，然后我们再来看看如何找到最便宜的路线。我们会执行查询，看到从A到B有一到三或五种不同的路线，其中每条路线的长度。
- en: the number of flights involved， is less than or equal to ten。 We see our friends
    here。 This was the nonstop flight。 This was the one through Boston。 Here's our
    favorite one。 And there's a few more。 So these are going to go through that cycle
    a couple of times。 But once we get to the length of ten we're not going to add
    anymore。 So we got termination。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的航班数量，小于或等于十。我们看到这些是我们的朋友们。这个是直飞航班，那个是经过波士顿的航班。这里是我们最喜欢的航班，还有几个其他的。所以这些将会通过循环几次。但是一旦我们达到十个航班的长度，就不再添加更多了。所以我们达到了终止条件。
- en: And if we want to change it to find the minimum cost flight then it's just the
    min total as before and we'll find good old 175。 Now what's unesthetic about this
    is that we're actually limiting the amount of recursion。 So the whole point of
    writing recursive queries is when we don't know the maximum number of computations
    that we need to do to get our answer。 So maybe it would so happen to turn out
    that the more than ten flights were required to get the cheapest。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将其更改为找到最低费用的航班，那么就像之前一样，只需使用最小总和，我们就能得到熟悉的175。现在这不太美观的地方是，我们实际上限制了递归的次数。编写递归查询的主要目的是在我们不知道需要进行多少次计算才能得到答案时使用。所以可能会发生这样一种情况，即为了找到最便宜的航班，可能需要超过十个航班。
- en: And if that was the case then we wouldn't get our right answer。 Of course we
    could change it to 100 and we'd still get the 175。 And honestly we could change
    it to 10，000。 And you can't see it happening here but it is actually recomputing
    that 175 even when I put in 10。000。 I can even do 100，000 and it's still going
    to work for me。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，我们就无法得到正确的答案。当然我们可以将其更改为100，仍然可以得到175。坦率地说，我们可以将其改为10,000，尽管这里看不出来，但实际上即使我设定为10,000，175依然会重新计算。我甚至可以设定为100,000，它依然会为我正常工作。
- en: So if we presume that nobody wants to take more than 100。000 flights in order
    to get from point A to point B in the cheapest fashion。 this would be a reasonable
    way to bound the recursion and get the answer that we want even in the presence
    of cycles in our relation。 [BLANK_AUDIO]。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们假设没有人希望通过超过100,000个航班以最便宜的方式从A点飞到B点，这样就为递归过程设定了一个合理的边界，即使在我们的关系中存在循环，也能得到我们想要的答案。[BLANK_AUDIO]。
- en: '![](img/21534375bc2b413d811307b8b694e624_19.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21534375bc2b413d811307b8b694e624_19.png)'
