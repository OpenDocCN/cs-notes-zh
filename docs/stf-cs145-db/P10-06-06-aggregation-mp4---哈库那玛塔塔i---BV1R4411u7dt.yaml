- en: P10：06-06-aggregation.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P10：06-06-aggregation.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: The next set of queries will show introduce the concept of aggregation in SQL。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的查询将引入 SQL 中聚合的概念。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_1.png)'
- en: Once again， we start with the basic select from where construct。 and this time
    we're going to introduce what are known as aggregate or aggregation functions。
    These are functions that will appear in the select clause initially。 and what
    they do is they perform computations over sets of values in multiple rows of a
    relation。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们从基本的 `select from where` 语句开始，这次我们将介绍被称为聚合函数的概念。这些函数最初会出现在 `select` 子句中，它们的作用是对关系中多行的值集进行计算。
- en: And the basic aggregation functions supported by every SQL system are minimum，
    maximum， sum。 average， and count。 Now， once we've introduced aggregation functions。
    we can also add two new clauses to the SQL select from where statement。 the group
    by and having clause。 The group by allows us to partition our relations into groups。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 SQL 系统支持的基本聚合函数是最小值、最大值、总和、平均值和计数。现在，一旦我们引入了聚合函数，我们还可以向 SQL `select from
    where` 语句添加两个新子句：`group by` 和 `having` 子句。`group by` 允许我们将关系划分为不同的组。
- en: and then we'll compute our aggregate functions over each group independently。
    The having condition allows us to test filters on the results of aggregate values。
    The where condition applies to single rows at a time。 the having condition will
    apply to the groups that we generate from the group by clause。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将独立地对每个组计算聚合函数。`having` 条件允许我们在聚合值的结果上进行筛选。`where` 条件适用于单行数据，而 `having`
    条件将应用于我们从 `group by` 子句生成的各个组。
- en: All of these constructs will become very clear when we show some examples。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示一些例子时，所有这些构造将变得非常清晰。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_3.png)'
- en: As usual， our examples will use our simple college admissions database that
    has a table of colleges。 a table of students， and information about students applying
    to colleges。 As usual。 we have four colleges， a bunch of students， and applications
    of students to colleges for specific majors。 Our first aggregation query is a
    very simple one that computes the average GPA of the students in the database。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们的例子将使用一个简单的大学招生数据库，其中包含一个学院表、一个学生表，以及关于学生申请学院的信息。和往常一样，我们有四所学院，一些学生，以及学生申请具体专业的学院申请。我们的第一个聚合查询非常简单，它计算数据库中学生的平均
    GPA。
- en: Here's the query， but just to explain the query， let me first replace the aggregation
    with star。 When we run select star from students， we get a result here。 Specifically。
    when we look at the GPA column， what the aggregation is going to do is perform
    a computation over all values in the column。 and then produce just one tuple in
    the result that has that value。 So we'll write average GPA。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查询，但为了先解释查询，我将首先用星号替换聚合。当我们运行 `select * from students` 时，我们会得到一个结果。具体来说，当我们查看
    GPA 列时，聚合将对该列的所有值执行计算，然后在结果中只生成一个包含该值的元组。所以我们将计算平均 GPA。
- en: We'll run the query， and we see now the average GPA in the database。 Our second
    query is a bit more complicated。 It involves a join。 What it finds is the minimum
    GPA of students who have applied for a CS major。 So we do the join a student and
    apply on student ID， filter for major equals CS。 Once again。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行查询，现在可以看到数据库中的平均 GPA。我们的第二个查询稍微复杂一些，涉及到一个连接。它查找的是申请计算机科学专业的学生的最低 GPA。所以我们通过学生
    ID 对学生和申请进行连接，并筛选出专业为 CS 的学生。再一次。
- en: let me just remove the aggregation first so we can see the result without aggregation。
    Here we see all of the information about students who have applied to a CS major。
    The aggregation is going to look at the GPA column。 and it's going to take the
    lowest value in that column。 So we write min GPA， run the query。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先移除聚合，这样我们就可以看到没有聚合的结果。这里我们可以看到所有申请计算机科学专业的学生信息。聚合将查看 GPA 列，并将取该列中的最低值。所以我们写下
    `min GPA`，然后运行查询。
- en: and we discover that the lowest GPA is 3。4。 Now let's go back to the average
    aggregate function again。 So let's compute the average GPA of the students who
    have applied to computer science。 run the query， and we see the result is about
    3。7。 In fact。 this result is probably not precisely what we were looking for。
    In a previous video。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现最低的GPA是3.4。现在让我们再次回到平均值聚合函数。所以让我们计算一下申请计算机科学的学生的平均GPA。执行查询，结果是大约3.7。事实上，这个结果可能并不是我们真正想要的。在之前的视频中。
- en: we talked in some detail about this particular form of query versus using a
    subquery to find the GPA of students who have applied to CS。 The issue with this
    particular query， and let's go back to the select star version。 is that if a student
    applied to CS multiple times， for example。 student 1-3 Amy applied to both Stanford
    and Berkeley， then when we compute their average GPA。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论过这种查询形式与使用子查询来查找申请计算机科学的学生GPA之间的差异。这个查询的问题是，让我们回到select star的版本。是如果一名学生多次申请计算机科学，比如学生1-3，Amy同时申请了斯坦福和伯克利，那么当我们计算她的平均GPA时。
- en: we're going to be counting their GPA twice。 Presumably what we actually want
    is to count the GPA once for each student who applied to CS no matter how many
    times they applied。 So in order to do that， we use the subquery form where we
    select from student。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会计算每个学生的GPA两次。假设我们真正想要的是计算每个申请计算机科学的学生的GPA一次，无论他们申请了多少次。为了做到这一点，我们使用子查询的形式，在其中从学生表中选择。
- en: and then we just check for each student whether their ID is among those who
    applied to CS。 So let's just do a bit of editing here。 From apply， where major
    equals CS。 I'm not a very good typist。 Let's just first take a look at the subquery
    form。 and we see that we made a mistake here， and it says that we forgot a word
    here， which is in。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查每个学生的ID是否在申请计算机科学的学生列表中。所以让我们先做一点编辑。从apply，where major equals CS。我打字不是很快。让我们先看一下子查询的形式。我们看到我们在这里犯了个错误，显示我们忘记了一个词，就是in。
- en: apologize for that。 Okay， now we have the students who applied to CS。 and in
    this case we only have one instance of each student。 So now if we run the aggregation。
    when we compute the average GPA， we'll correctly count each student's GPA only
    one time。 So remember with 3。7 approximately before， now we run the query and
    we see that the correct result is 3。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为此我们道歉。好的，现在我们有了申请计算机科学的学生，而且在这个情况下，我们每个学生只有一个实例。现在如果我们运行聚合查询，当我们计算平均GPA时，我们会正确地只计算每个学生的GPA一次。所以记得之前约为3.7，现在我们运行查询，结果显示正确的结果是3。
- en: 68。 Not that different， but this one is the numerically correct result。 So far
    we've seen the average and min aggregate functions。 This query shows the count
    function。 So not surprisingly， the count function just returns the number of tuples
    in the result。 So this particular query finds the number of colleges in our database
    whose enrollment is greater than 15。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 68。虽然不太一样，但这是数值上正确的结果。到目前为止，我们已经看过了平均值和最小值聚合函数。这个查询展示了计数函数。所以不出所料，计数函数仅仅返回结果中元组的数量。所以这个查询特别查找我们数据库中录取人数超过15的大学数量。
- en: 000。 Just for to be thorough， let's run the query without the aggregate function。
    and we see that there are two of them， and the aggregate function simply counts
    those number of tuples。 We run the query， and the result is two， as expected。
    Let's do another count query that looks very similar。 In this case。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 000。为了更加彻底，我们不使用聚合函数，直接运行查询，结果显示有两个，聚合函数只是简单地计算了这些元组的数量。我们运行查询，结果是两个，符合预期。让我们做一个非常相似的计数查询。在这种情况下。
- en: we're counting the number of students who have applied to Cornell。 So the query
    looks the same。 We'll run the query， and we discover six students have applied
    to Cornell。 Well， in reality。 what we've actually counted is the number of applications
    to Cornell。 not the number of students who have applied to Cornell。 If a student
    applied three times。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在统计申请康奈尔大学的学生人数。所以查询看起来是一样的。我们执行查询，结果发现有六名学生申请了康奈尔大学。然而，实际上我们统计的其实是申请康奈尔大学的申请次数，而不是申请康奈尔大学的学生人数。如果一名学生申请了三次。
- en: then we're counting them three times in this result。 So in some sense。 this
    is similar to the previous one we saw。 We were over counting。 and we could try
    to fix it with a subquery in the in and so forth， but actually， C。B。E。E。E。 provides
    a very nice way for us to perform the query that we want。 In the count function。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在这个结果中将它们计算了三次。所以在某种程度上，这和我们之前看到的类似。我们重复计算了，可以尝试用子查询来修复它，等等，但实际上，C.B.E.E.
    提供了一种非常好的方式来执行我们想要的查询。在 count 函数中。
- en: we can put a special keyword distinct， and then the name of one or more attributes。
    And in this case， what the count will do is we'll look at the result。 and then
    it will count the distinct values for the particular attributes。 So we run the
    query。 and we find that there are three distinct student IDs。 If we ran it without，
    just like this。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以放一个特殊的关键字 distinct，然后是一个或多个属性的名称。在这种情况下，count 将查看结果，然后计算特定属性的不同值。所以我们运行查询，发现有三个不同的学生
    ID。如果我们不加上 distinct，就像这样运行。
- en: when we see， we would look， and again， we would find that there are three distinct
    student IDs。 So count distinct actually turns out to be a very useful feature
    in SQL。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看时，我们会看到，并且再次发现有三个不同的学生 ID。所以 count distinct 实际上在 SQL 中是一个非常有用的功能。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_5.png)'
- en: Here's a rather complicated looking query， and I have to admit。 it computes
    something fairly obscure， but it does demonstrate some features。 What this query
    computes is it gives us back all students where the number of other students who
    have the same GPA as the student is equal to the number of other students that
    have the same high school size as the student。 Again， I admit it's a little bit
    obscure， but let's take a look at how it works。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个看起来相当复杂的查询，我必须承认，它计算的是一些比较晦涩的内容，但它展示了一些功能。这个查询计算的是，返回所有学生，其中与该学生具有相同 GPA
    的其他学生数量等于与该学生具有相同高中规模的其他学生数量。再次承认它有点晦涩，但让我们看看它是如何工作的。
- en: So it looks at the student relation， and for each student， it counts the number
    of other students。 That's by testing that the ID is different， that have the same
    GPA。 It also counts the number of other students that have the same size high
    school。 and if those two values， and these subqueries both produce a single value。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它查看学生关系，并对每个学生，计算具有相同 GPA 的其他学生的数量。这是通过测试 ID 是否不同，来计算具有相同 GPA 的其他学生的数量。它还计算具有相同高中规模的其他学生的数量。如果这两个值，这两个子查询都生成一个单一的值。
- en: which is why we can test equality， if those two values are the same。 then the
    student comes out in the result。 Let's run the query， we get our answer。 I'll
    leave it to you to verify by looking at the data that this is indeed the correct
    result。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们可以测试相等性，如果这两个值相同，那么学生会出现在结果中。让我们运行查询，得到答案。我留给你自己去验证，通过查看数据来确认这是正确的结果。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_7.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_7.png)'
- en: Here's another complicated looking query， although this one computes something
    quite a bit more intuitive。 What this query computes is the amount by which the
    average GPA of students who apply to computer science exceeds the average GPA
    of students who don't apply to computer science。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个看起来比较复杂的查询，尽管它计算的内容实际上更加直观。这个查询计算的是，申请计算机科学的学生的平均 GPA 超过未申请计算机科学的学生平均 GPA
    的差额。
- en: and we're going to assume it does in fact exceed。 So we're using in this example
    subqueries in the From clause。 which I hope you remember from the previous video。
    A subqueries in the From clause allows you to write a select from where expression。
    and then use the result of that expression as if it were an actual table in the
    database。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设它确实超过了。所以在这个例子中，我们使用的是 From 子句中的子查询。我希望你还记得之前的视频。From 子句中的子查询允许你写一个 select
    from where 表达式，然后把该表达式的结果当作数据库中的实际表来使用。
- en: So we're going to compute two subqueries in the From clause。 one of them which
    is the average GPA of CS applicants， and one the average GPA of non CS applicants。
    Let's look a little closer here。 So this query here says。 let's find the students
    who have applied to major in CS， let's compute their average GPA。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将计算 From 子句中的两个子查询。一个是计算计算机科学申请者的平均 GPA，另一个是非计算机科学申请者的平均 GPA。让我们稍微仔细看一下这里。这个查询的意思是，找到那些申请计算机科学专业的学生，然后计算他们的平均
    GPA。
- en: and we'll call it average GPA。 We'll take the whole result， and we'll name it
    CS。 Similarly。 the second new relation that we're computing in the From clause
    computes the average GPA of students who do not apply to CS。 so their student
    ID is not in the set of students who applied to CS。 We'll call that one non CS。
    So now with this From clause we have a relation called CS with an attribute called
    average GPA。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它称为平均 GPA。我们将整个结果命名为 CS。类似地，在 `From` 子句中我们计算的第二个新关系是没有申请 CS 的学生的平均 GPA，所以这些学生的学号不在申请
    CS 的学生集合中。我们将其称为非 CS。所以现在在这个 `From` 子句中，我们有一个叫做 CS 的关系，它有一个属性叫做平均 GPA。
- en: and a relation called non CS with an attribute called average GPA。 And then
    the select clause will simply do the subtraction of the non CS GPA from the CS
    GPA。 We run the query and we discover that the CS applicants exceed on average
    the non CS by 。19。 Now just for demonstration purposes， let me show that we can
    write this same query by using sub queries in the select clause。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个名为非 CS 的关系，它有一个叫做平均 GPA 的属性。接下来，`select` 子句将简单地进行非 CS GPA 和 CS GPA 的减法操作。我们运行查询后发现，CS
    申请者的平均 GPA 超过了非 CS 申请者的 GPA 0.19。现在，为了演示目的，让我展示一下我们如何通过在 `select` 子句中使用子查询来编写相同的查询。
- en: You right remember from the previous video that in a select clause we can write
    a sub query as long as it returns a single value。 We're going to go even further，
    we're going to write two sub queries that return single values and subtract them。
    So I'm going to replace this From with select。 I'm going to take out this whole
    first line here。 and then I'm going to， let's see， what else do I need to do？
    I'm going to take out the As here。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在之前的视频中，我们在 `select` 子句中可以编写子查询，只要它返回一个单一值。我们要做得更进一步，我们将编写两个返回单一值的子查询并进行减法操作。所以我要把这个
    `From` 替换成 `select`。我要把这一行的内容去掉。然后，我需要做些什么呢？我要把这里的 `As` 去掉。
- en: and I'm going to replace it with a minus。 I'm going to take out the As here。
    So now what we've got is we've got the average GPA of CS students in the select
    clause producing a value。 The average GPA of non CS students， we perform the subtraction
    as part of the select clause。 The last thing we need is something in the From
    clause， so we'll say From student。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将其替换为减号。我会把这里的 `As` 去掉。所以现在我们得到的是 `select` 子句中 CS 学生的平均 GPA 作为一个值，非 CS 学生的平均
    GPA 进行减法操作，作为 `select` 子句的一部分。最后我们需要做的就是在 `From` 子句中加上内容，所以我们会写 `From student`。
- en: We'll call the result of the subtraction D， let's say， for difference。 We run
    the query and we get almost the same result except for a bunch of duplicates。
    The reason for the duplicates is that we computed this result once for each tuple
    in student。 We can add distinct and now we get the single result。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个减法的结果称为 D，假设它代表差异。我们运行查询并得到几乎相同的结果，除了有一堆重复的记录。重复的原因是我们针对学生表中的每个元组都计算了一次这个结果。我们可以加上
    `distinct`，现在我们就能得到唯一的结果。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_9.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_9.png)'
- en: Now let's learn about the group by clause， which is only used in conjunction
    with aggregation。 Our first query is going to find the number of applicants to
    each college。 and it's going to do so by using grouping。 Effectively what grouping
    does is it takes a relation and it partitions it by values of a given attribute
    or set of attributes。 Specifically in this query we're taking the apply relation
    and we're breaking it into groups where each group has one of the college names。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们了解一下 `group by` 子句，它仅在与聚合操作一起使用时才有效。我们的第一个查询是找出每所学院的申请人数。它将通过分组来实现这一点。实际上，分组的作用是将一个关系按照给定属性或属性集的值进行划分。具体来说，在这个查询中，我们将
    `apply` 关系按学院名称进行分组。
- en: so that would be the Stanford group， the Berkeley group and so forth。 Then for
    each group we'll return one tuple in the result containing the college name for
    that group and the number of tuples in the group。 To illustrate what's happening
    with grouping very clearly。 let me start by replacing the select clause with select
    star。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就会得到斯坦福小组、伯克利小组等。然后，对于每个小组，我们会返回一个元组，其中包含该小组的学院名称和该小组的元组数量。为了更清晰地说明分组的发生情况，我将从用
    `select *` 替换 `select` 子句开始。
- en: removing the aggregation and doing an order by on the college name。 That just
    illustrates the groups that we're going to be using in the actual query。 So we
    see there are three tuples for Berkeley， there are six tuples for Cornell and
    so forth。 Within each group then for the particular query we're doing we're simply
    going to count the number of tuples。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 移除聚合操作，并对大学名称进行排序。这样做只是为了展示我们将在实际查询中使用的分组。因此，我们看到伯克利大学有三个元组，康奈尔大学有六个元组，等等。然后在每个组内，对于当前查询，我们只需计算元组的数量。
- en: So going back to the group by form we return the college name and we return
    the count of the number of tuples。 Now before I actually run the query one thing
    to notice is what it makes sense to put in the select clause here。 We're grouping
    by the college name， so the college name is going to be the same for all of the
    tuples in the group。 So it's sensible to include that but it wouldn't really be
    sensible to include one of the other attributes that differs。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到“group by”的形式，我们返回大学名称，并返回元组的计数。在我实际运行查询之前，有一点需要注意，就是在选择子句中加入什么是合适的。我们正在按大学名称进行分组，因此在同一组内，大学名称对于所有元组是相同的。所以包含大学名称是合理的，但包含其他不同的属性就不太合理了。
- en: Although we'll see an example later where we include that in interesting things
    happen。 For now we'll just put the name of the grouping attribute and then we
    can perform aggregation over that in this case count。 We run the query and we
    see that there are three applicants to Berkeley。 six to Cornell and so forth。
    Here's a very similar query just as a second example。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管稍后我们会看到一个例子，其中包含这些信息，产生一些有趣的结果。目前我们只将分组属性的名称放入，然后我们可以对其进行聚合操作，在这个例子中是计数。我们运行查询，看到伯克利大学有三名申请者，康奈尔大学有六名，等等。这里有一个非常相似的查询，作为第二个例子。
- en: In this example we're finding the total enrollment of college students for each
    state。 Now we only happen to have three states and four colleges in our database
    but what this query does is it takes the college relation。 it breaks it up into
    partitions by state and then within each partition or group it will return the
    state for that partition and the sum of the enrollments。 We run the query and
    we see the expected result。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在查找每个州的大学生总入学人数。现在我们数据库里恰好只有三个州和四所大学，但这个查询的作用是，它会将大学关系表按州划分成多个分区，然后在每个分区或组内，它会返回该分区的州名以及入学人数的总和。我们运行查询后，看到预期的结果。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_11.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_11.png)'
- en: Here's a more complicated group by query。 In this case we're grouping by two
    attributes。 we also have a join involved and we're going to compute two aggregate
    functions in our result。 What this query computes is for each college and major
    combination。 the minimum and maximum GPAs for the students who have applied to
    that college。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更复杂的“group by”查询。在这种情况下，我们按两个属性进行分组，还涉及了连接操作，并且在结果中计算两个聚合函数。这个查询计算的是每个大学和专业的组合，申请该大学的学生的最低和最高GPA。
- en: As usual before we do the aggregation let's replace the query with one where
    we can see the groups explicitly。 I'll put GPA here and instead of grouping I'll
    order by and we run the query and we see for Berkeley biology we actually only
    have one applicants。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在进行聚合之前，我们先将查询替换为一个可以明确显示分组的查询。我将在这里放入GPA，改为按GPA排序，我们运行查询后，看到伯克利大学的生物学专业实际上只有一名申请者。
- en: For Berkeley CS we have two， I think Stanford CS has the largest number of applicants
    at three。 Once we put the aggregation back each of these combinations of college
    and major is going to be considered individually and for each one we'll compute
    the minimum and maximum GPA。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于伯克利大学的计算机科学专业，我们有两个申请者，我想斯坦福大学计算机科学专业的申请人数最多，有三个。一旦我们把聚合操作加回去，每个大学和专业的组合都会被单独考虑，对于每一个组合，我们将计算最低和最高的GPA。
- en: Let's go ahead and do that。 All those parentheses。 Okay， change this to group
    by。 run the query and here we see for Berkeley biology the minimum and maximum
    is the same because we saw that there was only one。 Student who applied to Berkeley
    biology， Stanford CS we had three。 we can see the spread of their GPAs and so
    forth for each college major combination。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行操作。所有这些括号。好吧，将其更改为按大学名称分组。运行查询后，我们看到，对于伯克利大学的生物学专业，最低和最高GPA是相同的，因为我们看到只有一名学生申请了伯克利大学生物学专业。对于斯坦福大学的计算机科学专业，我们有三名学生。我们可以看到他们的GPA分布，以及每个大学专业组合的情况。
- en: Now what if we were interested in finding information about the spread of GPAs
    for each college and major？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们对每个大学和专业的GPA分布感兴趣呢？
- en: What the difference is between the minimum and the maximum。 So let's suppose
    in fact what we wanted to find was the largest spread but let's take that in steps。
    I'm going to take this current query here and I'm just going to slap it into the
    front clause。 So now in the front clause I'm going to have a relation we'll call
    it M that's going to have the college major combinations in the minimum and maximum
    GPA。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值之间的差异。假设我们实际上要找的是最大的差距，但我们一步步来。我将把当前的查询放入前置子句中。所以现在在前置子句中，我将有一个关系，称为
    M，它将包含大学和专业组合以及最低和最高 GPA。
- en: This M is going to now have the result that we see below。 Now once we have that
    result to work with in the select clause we can access the attributes here。 Let
    me call this one M and this one M X and if we write just M X minus M N here what
    we're going to get is a list of the spreads of the minimum and maximum GPA for
    each college and major。 So we see many of them are zero。 Those are all of the
    combinations that had just one student but in some cases we actually have a spread。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个 M 会显示我们下面看到的结果。一旦我们有了这个结果，在 `select` 子句中就可以访问这些属性。让我称它为 M 和 M X，如果我们在这里写下
    `M X - M N`，我们将得到每个大学和专业的最低和最高 GPA 的差距列表。所以我们看到很多是零。这些都是只有一个学生的组合，但在某些情况下，确实有差距。
- en: What we want to find is the largest spread。 Watch this。 It's very cute。 We just
    simply put a max function right here。 Run the query and we find that the largest
    spread between men and max is approximately one。 Our next sequence of queries
    introduces some subtleties of the group by clause。 What our query finds is the
    number of colleges that have been applied for the number of colleges that have
    been applied to by each student。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找的是最大的差距。看这个，挺有趣的。我们只需要在这里加一个最大值函数（max）。运行查询后，我们发现男女之间的最大差距大约是1。接下来的查询序列介绍了
    `group by` 子句的一些细节。我们的查询查找的是每个学生申请的大学数量。
- en: So the query joins student and apply。 It groups the result for the student ID
    on the student ID and then for each student ID find the number of distinct colleges
    in that group。 So once again just to illustrate let's take away the aggregation。
    Let's replace the group by by an order by just so we can see the data that we're
    working on。 And run the query and we see that student one two three has four applications
    to Stanford。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以查询连接了学生和申请数据。它根据学生 ID 对结果进行分组，然后在每个学生 ID 下找出该组中不同大学的数量。因此，再次说明，我们可以去掉聚合操作。我们用一个排序（order
    by）替代分组（group by），这样就能看到我们正在处理的数据。运行查询后，我们看到学生一二三申请了斯坦福大学四次。
- en: Berkeley and Cornell three distinct colleges。 Two three four has one and so
    forth。 So now let's return to our original query group by student。 We'll count
    the distinct college names。 Run the query and we get the expected answer。 Student
    one two three applied to three distinct colleges two three four to one and so
    forth。 Maybe we'd like to have the student's name and the result as well。 That's
    easy to do。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 伯克利和康奈尔是三所不同的大学。二三四有一所，以此类推。所以现在让我们回到原始查询，按学生分组。我们将计算不同的大学名称。运行查询后，我们得到了预期的答案。学生一二三申请了三所不同的大学，二三四申请了一所，以此类推。也许我们还想把学生的姓名和结果一起显示。这个很容易做到。
- en: We just add the student name to the select clause and we run the query and now
    we've added Amy is one two three。 Bob is two three four and so forth。 That worked
    out fine in this case but we're going to see in a moment where it's simply adding
    a attribute to the select clause in the case of a group by does something a little
    strange。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将学生姓名添加到 `select` 子句中，然后运行查询，现在我们就添加了 Amy 是一二三，Bob 是二三四，以此类推。在这种情况下没问题，但稍后我们会看到，单纯地在
    `select` 子句中添加一个属性，在使用 `group by` 时会产生一些奇怪的效果。
- en: In fact the only reason that it worked nicely in this case is that when we group
    by the student ID within each group we have the same student name。 Let's see that
    let's just take a look at that。 Again we'll replace the group by with an order
    by。 We are sorting by student ID and we see for the first group which is one two
    three we have all Amy's for the three four five group we have all Craig's and
    so on。 So when we put student name in the select clause for a group by query it
    was okay because for each group we had the same name of the student。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，之所以在这种情况下能正常工作，唯一的原因是当我们按学生 ID 分组时，在每个组内我们有相同的学生姓名。让我们看看，先看一下这个情况。我们将“group
    by”替换成“order by”。我们按学生 ID 排序，我们看到对于第一个组（ID 一二三），所有成员都是 Amy；对于三四五组，所有成员都是 Craig，依此类推。所以当我们在分组查询的
    SELECT 子句中放入学生姓名时，它是没问题的，因为对于每个组我们都有相同的学生姓名。
- en: That's not the case we should presumably get an error but let's see what happens。
    So let's say that we're interested now not only in finding the student name in
    our query but we're further going to add a college name。 So let's go back to the
    original query。 Think college name。 Let's add college name in our result and let's
    go back to grouping by student。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的结果，通常我们应该得到一个错误，但让我们看看会发生什么。所以假设我们现在不仅想在查询中找到学生姓名，还进一步添加大学名称。让我们回到原始查询，加入大学名称。我们将大学名称加到结果中，并且继续按学生进行分组。
- en: Now for each student we're going to return the for each group which is identified
    by the student ID we're going to return the ID the name the number of distinct
    colleges and then a college。 Let's run the query and we do get a result we don't
    get an error so we've got Amy one two three she applied to three distinct colleges
    but for whatever reason the system decided to tell us about Stanford。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于每个学生，我们将根据学生 ID 返回每个组的信息，包括 ID、姓名、不同大学的数量和一个大学。让我们运行这个查询，结果是正常的，没有错误，所以我们得到了
    Amy，ID 是一二三，她申请了三所不同的大学，但不知为何系统决定告诉我们关于斯坦福大学的信息。
- en: Craig applied to two colleges and the system tells us about MIT。 Let's go back
    again revert now to our order by form of this query and take away the aggregation。
    And when we run the query we see there's Amy and she did apply to four different
    colleges but when we put the college name in the grouping query it chose to tell
    us about Stanford。 What this system is actually doing is when we include in the
    select clause of a grouping query again if we go back to group by and we put in
    the select clause an attribute that's not one of the grouping attributes it actually
    chooses a random value from the group to include。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Craig 申请了两所大学，系统告诉我们关于 MIT 的信息。让我们再回去，恢复到我们查询的“order by”形式，并去掉聚合操作。当我们运行查询时，我们看到
    Amy，她确实申请了四所不同的大学，但当我们把大学名称放入分组查询时，系统选择告诉我们关于斯坦福大学的信息。系统实际上在做的是，当我们在分组查询的 SELECT
    子句中加入一个非分组属性时，它会随机选择该组中的一个值来返回。
- en: In the case of the student name the random value was always the same because
    the student name is always the same for the same student ID。 In the case of the
    college it chose a random value among the colleges。 I personally am not crazy
    about this behavior among the three open source database systems that we've been
    using for our demos two of them allow this behavior sequel light and my sequel
    I happen to be using my sequel today。 If we were using Postgres it would actually
    throw an error in this case。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在学生姓名的情况下，随机值总是相同的，因为对于相同的学生 ID，学生姓名总是相同的。而在大学名称的情况下，它从各大学中选择了一个随机值。就个人而言，我并不太喜欢这种行为，在我们演示中使用的三种开源数据库系统中，有两种允许这种行为，分别是
    SQLite 和 MySQL，我今天恰好使用的是 MySQL。如果我们使用的是 Postgres，它实际上会在这种情况下抛出一个错误。
- en: Let's go back to the original query that finds a number of colleges applied
    to by each student。 Here it is as we originally wrote it and here's the result。
    Now there may be some students in the database who haven't applied to any college
    at all and they're not going to be represented in our result because they're not
    going to be in the results of the join and we don't see any zero counts here。
    What if we wanted to actually list the student IDs of students who haven't applied
    anywhere and include a zero in the result。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到原始查询，查询每个学生申请的大学数量。这里是我们最初写的查询，下面是查询结果。现在，数据库中可能有些学生根本没有申请任何大学，他们不会出现在我们的结果中，因为他们不会出现在连接的结果中，而且我们没有看到任何零计数的情况。如果我们想要列出那些没有申请任何大学的学生
    ID，并在结果中显示零该怎么办呢？
- en: This is actually one of my favorite queries to give as an exercise or an exam
    question in my class because it takes a little innovation to figure out how to
    write it。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我最喜欢用作课堂练习或考试题的查询之一，因为它需要一点创新才能搞明白如何编写。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_13.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_13.png)'
- en: The way we write it actually is by using the union operator which I hope you
    remember from a previous video。 We're going to take the union of the students
    who have applied somewhere in the number of places they've applied together with
    the students who haven't applied anywhere and for those students we're going to
    put a zero in the result directly。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的写法实际上是通过使用`union`操作符来实现的，希望你还记得在之前的视频中提到过。我们将把那些已经申请过某些学校的学生与那些没有申请任何学校的学生联合起来，对于没有申请任何学校的学生，我们将直接在结果中显示零。
- en: So let me just write the beginnings of this so we're going to find those students
    who haven't applied anywhere at all。 So those are the students whose SID is not
    in at all the set of SID's in the apply relation。 So that finds the students who
    didn't apply anywhere。 For each student will return their student ID and then
    we want to have a zero in the result。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先写下这个的开头部分，我们要找出那些根本没有申请过任何学校的学生。所以这些学生的SID不在`apply`关系中的所有SID集合中。这样就找到了那些没有申请任何学校的学生。对于每个学生，我们将返回他们的学号，然后我们希望在结果中显示一个零。
- en: Very simple to do。 We simply write zero。 We run the query and now if we scroll
    down we'll see that in addition to all the students who have applied somewhere
    we get zeros in the result for the students who haven't applied anywhere。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。我们只需要写零。我们运行查询，然后如果向下滚动，我们将看到除了所有已经申请过的学生，我们还会看到没有申请过任何地方的学生的结果中有零。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_15.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_15.png)'
- en: The last clause that we're going to introduce in this video is the having clause
    and the having clause is also only used in conjunction with aggregation。 What
    the having clause allows us to do is apply conditions to the result of aggregate
    functions。 So the having clause is applied after the group by clause and it allows
    us to check conditions that involve the entire group。 In contrast the where clause
    applies to one tuple at a time。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本视频中，我们将介绍的最后一个子句是`having`子句，`having`子句也仅在与聚合操作一起使用时才有意义。`having`子句允许我们对聚合函数的结果应用条件。因此，`having`子句是在`group
    by`子句之后应用的，它允许我们检查涉及整个分组的条件。与此相比，`where`子句一次只对一个元组应用条件。
- en: So this particular query is finding colleges that have fewer than five applicants。
    So we look at the apply relation we group it by college name so we're going to
    have one group for each college。 Then we're only going to keep those groups where
    the number of tuples in the group is less than five indicating that we have fewer
    than five applicants to the college。 We'll run the query and we'll see that Berkeley
    and MIT each have fewer than five applicants。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询实际上是在寻找申请人数少于五个的大学。我们查看`apply`关系，并按学校名称进行分组，这样每个学校就有一个分组。然后我们只保留那些分组中元组数少于五个的组，这表示该大学的申请人数少于五人。我们运行查询后，将看到伯克利和麻省理工学院每所学校的申请人数都少于五个。
- en: So presumably Cornell and Stanford have greater than or equal to five applicants
    and you can check that by examining the data。 Now it is possible to write this
    same query without the having clause and in fact without the grouping clause and
    let me show you how that's done。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设康奈尔和斯坦福的申请人数都大于或等于五个，你可以通过检查数据来确认这一点。现在，实际上是可以在没有`having`子句的情况下写出同样的查询，事实上也不需要分组子句，让我展示一下如何实现。
- en: We're going to select again the C name from apply and here's what we're going
    to do。 We're going to add an attribute there。 We're going to a table variable。
    We're going to raise this whole business and we're going to find all applicants。
    So all applications where let me just type this out for you。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次选择`apply`中的`C name`，接下来我们要做的是在这里添加一个属性。我们将创建一个表变量。我们将提升整个操作，然后找到所有的申请人。所有的申请记录中，让我为你输入一下。
- en: Five is greater than the count from apply A2 where A2。C name equals five。 C
    name equals A1。C name。 And let's take a look at what this is doing。 So what we're
    doing here is we're looking at each application record and we're checking whether
    the number of other applications to the same college。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 五大于`apply A2`中的计数，其中`A2.C name`等于五，`C name`等于`A1.C name`。让我们来看看这到底在做什么。所以我们在这里做的事情是，我们查看每一条申请记录，并检查是否有其他的申请记录是针对同一所大学的。
- en: We're going to find all the applications the same college。 We're going to count
    them and we're going to see if that number is less than five。 So it's a little
    bit non-intuitive。 Now remember the result should be Berkeley MIT。 Let's run the
    query and we do get Berkeley MIT。 We again get duplicates however。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找到同一学院的所有申请记录。我们将对它们进行计数，并查看这个数量是否小于五。所以这有点不直观。现在记住，结果应该是伯克利和麻省理工。我们运行查询，确实得到了伯克利和麻省理工。我们再次得到了重复的记录。
- en: The reason is that we're checking this condition for each application record。
    So for each application to Berkeley we check the condition that may be many of
    them and for each one to MIT and so on。 Of course as usual we can add distinct。
    We can run the query and now we get the result。 It does happen actually that every
    query that can be written with a group by in a having clause can be written in
    another form。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是我们在检查每个申请记录的条件。所以对于每一个申请到伯克利的记录，我们检查这个条件，可能有很多个类似的记录，对于每一个申请到麻省理工的记录也是如此，依此类推。当然，像往常一样，我们可以添加`distinct`。我们可以运行查询，现在得到结果。事实上，任何可以在`group
    by`和`having`子句中写的查询，都可以用另一种形式来表示。
- en: Sometimes it can be extremely contorted but another sort of complicated exercise
    I like to give sometimes in my class is to prove the fact that you can write every
    group by having query without using those clauses。 Now let's go back to our original
    form of the query where we use the group by in the having。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时它可能非常复杂，但在我的课堂上，我喜欢给学生一个更复杂的练习，证明你可以在不使用`group by`和`having`子句的情况下编写每个`group
    by having`查询。现在让我们回到查询的原始形式，其中使用了`group by`和`having`。
- en: So we'll just get rid of all this。 I'm sorry I'm such a terrible typist。 Group
    by college name having count star less than five。 And we'll run the query we'll
    get the same result。 What if we were interested not in those colleges that have
    fewer than five applications but rather those colleges that have fewer than five
    applications。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们就把这些都去掉。抱歉，我打字很糟糕。`group by`按学院名称分组，`having count(*) < 5`。我们运行查询，得到相同的结果。如果我们感兴趣的不是那些申请少于五次的学院，而是那些有少于五个申请的学院呢？
- en: It's a subtle point but instead of counting the number of apply tuples for each
    college what we want to count is the number of distinct student IDs that appear
    in the group of apply tuples for that college。 So again now we're looking for
    the number of colleges who have fewer than five distinct people distinct students
    applying to them。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的要点，但我们不想计算每个学院的`apply`元组的数量，而是要计算在该学院的`apply`元组分组中出现的不同学生ID的数量。所以现在我们在查找的是那些有少于五个不同学生申请的学院数量。
- en: And now we see that one more college joins the group so Cornell had more than
    five applications or at least five applications but it has fewer than five applicants。
    Here's our grand finale query。 It has a having clause in group by and in addition
    it has a sub query within the having clause that also uses aggregation。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，另外一所学院加入了分组，所以康奈尔有超过五个申请，或者至少有五个申请，但它的申请人数少于五个。这里是我们的最终查询。它有一个`having`子句和`group
    by`，此外，它在`having`子句中还有一个子查询，并且这个子查询也使用了聚合。
- en: What this query finds is all majors represented in the database where the maximum
    GPA of a student applying for that major is lower than the average GPA in the
    database。 So we join student and apply and we group by the major so we can look
    at each major one at a time。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询找到的是数据库中所有专业，其中申请该专业的学生的最高GPA低于数据库中的平均GPA。所以我们连接了`student`和`apply`表，并按专业进行分组，这样我们就可以一次查看一个专业。
- en: Within the major we find the maximum GPA of a student applying for that major
    and we check whether it's lower than the average GPA in the student relation。
    We run the query and we discover that bioengineering and psychology at this point
    in time are garnering applicants whose highest GPA is lower than the average in
    the database。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业内，我们找出申请该专业的学生的最大GPA，并检查它是否低于学生表中的平均GPA。我们运行查询，发现生物工程和心理学在当前时刻的申请者的最高GPA低于数据库中的平均GPA。
- en: Of course that does not represent reality。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不代表现实情况。
- en: '![](img/a153f67db14c8401cb375180fc02a97d_17.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a153f67db14c8401cb375180fc02a97d_17.png)'
