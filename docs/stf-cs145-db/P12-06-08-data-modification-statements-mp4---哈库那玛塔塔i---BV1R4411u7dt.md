# P12：06-08-data-modification-statements.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

在最后一个视频中，我们将学习 SQL 的修改语句。包括插入数据、删除数据和更新现有数据的语句。

![](img/ab0f0335a6c4ca1215b811cb8be15663_1.png)

插入数据有两种方法。第一种方法允许我们通过指定实际值将一个元组插入到数据库中。就是这里的命令。我们说“插入到一个表中”，我们指定元组的值，命令的结果将是将一个新元组插入到表中并赋予该值。另一种方法是通过数据库上的查询运行 SELECT 语句。

该 SELECT 语句将生成一组元组，只要这组元组的模式与表相同，我们就可以将所有元组插入到表中。所以这就是插入数据的两种方法，我们很快会在演示中看到它们。要删除数据，我们有一个相对简单的命令。

它说我们从表中删除，条件为真的时候。所以这个条件与我们在 SELECT 语句中看到的条件类似，表中满足此条件的每个元组都会被删除。现在这个条件可能相当复杂，它可以包含子查询。

它可以包括对其他表的聚合等等，我们将在演示中看到。最后，我们感兴趣的是更新现有数据。这是通过一个命令完成的。与删除命令类似，它也只作用于一个表。它对表中的每个元组进行条件评估，当条件为真时。

我们不会删除元组，而是修改元组。我们取这里指定的属性，然后将其重新赋值为该表达式的结果。正如我们在演示中看到的，这里的条件可以非常复杂。它可以包含子查询等等。而这个表达式也可以相当复杂。

它可以涉及对其他表或同一表的查询。最后，我想提到的是，我们实际上可以更新元组中的多个属性。所以如果我们正在更新一个表，仍然是完全相同的，单个表，通过条件来识别需要更新的元组，但现在我们可以同时更新任意数量的属性。

每个通过评估表达式并将该表达式的结果赋给属性。像往常一样，我们的演示将使用简单的学院招生数据库，包括学院、学生和申请。

![](img/ab0f0335a6c4ca1215b811cb8be15663_3.png)

像往常一样，我们有四个学院，一堆学生，还有一堆学生申请到这些学院。我们将首先看到一些插入命令，然后是一些删除命令，最后是一些更新命令。正如我提到的，插入命令有两种不同的形式。一种是通过指定值一次插入一个元组。

另外一个是使用子查询插入元组的方式。所以我们先从简单的开始。让我们向数据库中添加一所新的大学——卡内基梅隆大学。我们通过说我们要插入到大学表，使用关键字values，然后简单列出我们要插入的值：大学的名称，所在州。

然后是注册情况。我们运行查询，现在来查看大学关系。我们去大学表。好了，现在我们看到卡内基梅隆大学已经被添加到我们的数据库中。

![](img/ab0f0335a6c4ca1215b811cb8be15663_5.png)

现在让我们进行一些更复杂的插入命令。既然卡内基梅隆大学已经在我们的数据库中，我们就让一些学生进行申请。我们将让那些尚未申请过任何学校的学生，申请卡内基梅隆大学的计算机科学专业。让我一步一步来。我们首先找出那些还没有申请任何学校的学生。

这回顾了我们之前看到的内容。我们将找到那些ID不在子查询中、子查询选择了所有在申请关系中的ID的学生。我们运行查询，发现有四个学生还没有申请任何学校。

接下来，我们要做的是将这个查询转化为构造我们想要插入到申请关系中的元组的查询。提醒一下，申请关系包含学生的ID、大学名称、申请的专业和决策。所以我们将构造学生的ID，当然，我们希望他们申请卡内基梅隆大学，申请计算机科学专业。目前先这样做。

假设我们不知道决策是什么，所以我们会为决策设置一个空值。现在运行这个查询，我们可以看到对于四个学生，我们已经构建了一个元组。四个元组，准备插入到申请关系中。它们具有适当的模式。现在我们已经准备好运行这个查询了。

我们说插入到申请表，然后运行查询，我们将看到四个元组被插入到申请关系中。我们去查看这个关系。

![](img/ab0f0335a6c4ca1215b811cb8be15663_7.png)

再试一次。这里我们有申请表，现在我们看到我们有了四个新的元组，提醒一下，在这个用户界面中，空白单元格用来表示空值。

![](img/ab0f0335a6c4ca1215b811cb8be15663_9.png)

现在让我们为卡内基梅隆大学做点更多的操作。我们找到那些已经在其他大学申请了电气工程专业，并且被拒绝的学生，让他们申请卡内基梅隆大学，并且立刻接受他们。所以，我会一步一步地操作。首先，我们会找到那些在其他大学申请电气工程专业的学生。

所以我们将其改为 N，其中主修专业为 EE。我们希望那些被拒绝的学生，所以决策为 no。这样我们就有了 YN 作为我们的决策。现在让我们检查一下这类学生有多少。我们在这里运行查询。现在我们看到有两个学生，如果我们回去查看申请关系。

我们会发现，确实他们申请了 EE 并且被拒绝了。现在让我们将这个转换为一个查询，构造出我们想要插入到申请关系中的元组。我们需要学生ID，我们希望他们申请卡内基梅隆大学。请原谅我一贯的打字速度。这次他们将申请 EE，并且我们会立即接受他们。

所以让我们检查一下那个查询。现在我们已经生成了两个元组，准备插入到申请关系中。我们说 insert into apply，使用子查询。我们运行它，看到插入了两行。让我们去查看一下，并且我们需要刷新。

![](img/ab0f0335a6c4ca1215b811cb8be15663_11.png)

然后我们往下看，发现这两位学生确实申请了 EE，并且已经被接受。现在让我们来探讨一下 delete 命令。在这个例子中，我们将找到所有申请了超过两个不同专业的学生，并且我们将决定这些学生是不可靠的。

我们将完全从数据库中删除他们。现在让我们首先形成一个查询，找到那些申请超过两个专业的学生。就是这个查询。你可能要记住 group by 和 having 子句。所以说，我们去申请关系表，按照 SID 分组或分区。

所以我们将考虑每个学生的申请集。我们将统计每个组中不同专业的数量。如果这个数量大于二，我们将返回该学生的 ID。现在我们来看一下他们申请了多少个专业。

所以我们在数据库中找到有两个学生申请了三个专业。我们不喜欢这些学生，所以我们要把他们删除掉。这是我们操作的方式。我们说从学生表中删除，其中，提醒一下，删除命令的格式是 delete from 表 where。

然后你可以有一个简单的条件，也可以有一个复杂的条件。这个是一个复杂的条件。我们将说他们的 SID 在……并且我们将其转化为一个子查询。这里我们不需要进行去重计数。在……，让我稍微把这个格式调整得更好，表示在申请超过两个专业的学生ID集合中。

所以如果一切顺利，我们应该删除学生 345 和 876。让我们运行查询。我们确实删除了两行。让我们回去看看学生记录，我们应该发现 345 和 876 已经没有了，确实如此。现在我们从学生表中删除了他们，但我们还没有从申请关系中删除他们。

所以我们可以完全照原样写出相同的删除语句，只需从apply中删除即可。现在我想提到的是，并非所有数据库系统都允许这种特定的删除。有些数据库系统不允许这样的删除，它们只允许删除命令，其中子查询包含你正在删除的相同关系。虽然这可能有些棘手，但有些数据库系统允许，例如Postgres就是支持的。这就是我们今天运行的系统。

所以我们将运行查询，这次影响了8行数据。我们发现有8个申请来自那些申请了两个以上不同专业的学生。再次强调，这些仍然是相同的学生，但我们可以返回并检查apply关系。如果我们检查，我们会发现876和345已经从apply关系中消失。

现在回到我们的查询，正如我之前提到的，有些数据库系统不支持这种形式的删除，因此在这些系统中执行这种删除操作会更为复杂。通常的做法是创建一个临时表，将这个子查询的结果放入临时表中，然后从apply中删除学生ID存在于临时表中的记录。

你可以尝试在SQLite或MySQL中运行这个操作，看看是否能得到相同的结果。让我们再看一个删除的例子。在这个例子中，我们决定删除任何没有计算机科学专业申请者的学院，因为它们可能不值得保留在数据库中。

我们将首先执行select命令，然后将其转化为delete命令。因此，这个select命令会查找那些其学院名称不在apply关系中，且专业是计算机科学的学院。换句话说，这会找到所有没有人申请计算机科学的学院。我们运行查询后发现，康奈尔大学没有人申请计算机科学。

如果我们现在想删除元组，操作非常简单。我们只需要说从college中删除，然后其余部分与之前一样，即查找那些没有人申请计算机科学的学院。我们运行查询，成功执行，如果我们现在回去查看我们的college关系，我们会看到康奈尔大学已经消失。

![](img/ab0f0335a6c4ca1215b811cb8be15663_13.png)

最后，让我们来看一些更新命令。在第一个命令中，我们将找到那些GPA低于3.6并且申请了卡内基梅隆大学的学生。我们将接受这些学生，但他们的专业将变为经济学专业。让我们首先找到那些申请了卡内基梅隆大学且GPA低于3.6的学生。

这是查询。再一次，这是之前视频的回顾。我们在apply关系中查找，其中学院是卡内基梅隆大学，且学生ID属于那些GPA低于3.6的学生。我们运行查询后发现有两个这样的申请。现在我们要做的是更新apply关系，并且我们将接受这些学生，但他们的专业将是经济学。

我们将select改为update，这是我们将更新apply关系。我们将更新每个满足条件的元组。我们知道正是这两个元组，我们将这些学生的decision字段设置为yes，并将major字段设置为经济学。我们运行查询。

![](img/ab0f0335a6c4ca1215b811cb8be15663_15.png)

更新成功，现在我们查看apply关系，发现这两名学生已经申请了经济学专业，并且已经被接受。

![](img/ab0f0335a6c4ca1215b811cb8be15663_17.png)

这是一个更复杂且具有高度动机的更新命令。在这个命令中，我们将找到那些GPA最高并且申请EE专业的学生，然后把他们的专业从EE改为CSE，即计算机科学与工程，而不是让他们浪费时间在电气工程上。好了，让我们来看一下这个查询，它将找到我们要修改的申请记录。

这个查询是之前视频的一个优秀复习示例，因为它包含了三层嵌套子查询。所以我们的目标再次是找到那些申请EE专业的学生。这里是那些申请EE专业的学生，但我们希望他们的GPA是所有申请EE专业的学生中最高的。所以在最里面，我们找到了这些申请EE的学生，他们的学生ID为90的学生。

然后我们向外展开一层，找出所有申请EE专业的学生的GPA。现在我们找出所有GPA至少与最高EE专业申请者相等的学生。最后，我们找出所有申请EE且GPA最高的学生。呼，好了，让我们运行查询，看看是谁。我们发现是学生1和学生2。

这三个学生实际上已经申请了三次EE（电气工程）专业，分别是斯坦福大学、康奈尔大学和卡内基梅隆大学。所以现在我们已经识别出了这些学生，将这个命令转换为更新操作其实相对简单。我们更新了apply，并且将专业从EE改为CSEE。CSEE就是计算机科学与电子工程专业。就是这样。我们运行查询，成功执行，然后返回并查看apply关系，刷新数据。

![](img/ab0f0335a6c4ca1215b811cb8be15663_19.png)

在这里，我们看到学生1到3现在已经申请了CSEE专业，而不是EE专业，在这三所大学中。让我们再来看几个稍显愚蠢，但展示一些功能的更新示例。在这个例子中，我们将给每个学生一个最高的GPA，并且选择数据库中最小的高中。这展示了在set命令中，等号右侧可以是一个子查询。

在这里我们正在更新每个学生，没有where子句。这意味着每个表都将满足条件。对于每个学生，我们将他们的GPA设置为数据库中最大GPA的值。同时，我们将他们的高中规模设置为数据库中最小高中规模的值。

我们运行查询，然后查看学生关系，现在我们会看到每个学生的GPA是3.9，每个学生的高中规模是200。这就是我们之前数据库中的最大值和最小值。我们最后的查询表明我们今天心情很好。

让我们进入我们的申请关系，并接受所有人。这个非常简单的查询只需要执行更新操作，apply表没有where条件，所以每个学生都会满足查询条件。我们将决策设为y。这样我们就能让许多学生开心了。接下来让我们查看apply关系，现在我们会看到所有人都已经被接受。

![](img/ab0f0335a6c4ca1215b811cb8be15663_21.png)

它。
