# P26：15-03-nonlinear-mutual-recursion.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

在这个视频中，我们将进一步探讨 SQL 语言中递归涉及的一些问题。

![](img/43771b425ce5b32b6ff32a64b8cd4e6c_1.png)

首先，提醒一下 SQL 如何实现递归。SQL 中有一个 `WITH` 语句，可以指定递归定义的关系。我们说 `WITH RECURSIVE`，然后定义一组关系，在这些关系中，定义关系的查询可能会涉及到关系本身。这就是递归的由来。然后在最后， 

最终结果是一个查询，它可能涉及到那些递归定义的关系，也可能涉及到数据库中的其他表。正如我们在前一个视频和演示中看到的，递归定义的关系在 `WITH` 语句中的结构通常是先有一个不涉及递归定义关系的基本查询，再与递归查询联合。我们看到了很多这种形式的例子。我想在这个视频中谈的第一件事就是所谓的线性递归。

线性递归指定了在 R 的递归定义中，假设它采取基本查询联合递归查询的形式。在递归查询中，只有一个对递归定义关系 R 的引用。那么我们来看一个例子，来理解线性递归和非线性递归。

我们在介绍递归时使用的第一个例子是从一个只有父子关系的基本表中找到祖先关系。所以这是一个基本的闭包操作，查询我们想要运行的是找到所有 Mary 的祖先。

这是我们写的查询。它的形式确实有一个基本查询，这里说的是，如果我们有一个父关系，它也是一个祖先关系。然后递归发生在联合的第二部分，在那里我们连接递归定义的祖先关系和父关系，以便我们能将祖先扩展一个代。

现在这个查询确实具有线性递归，因为我们在这里只有一个递归定义关系的实例，即祖先关系。所以让我们看看当这个查询执行时，底层发生了什么。我们从父表开始，这里有父子关系，假设我们有比如说 Sue 和 John，John 和 Mary，例如在我们的父表中。然后在实际的第一次迭代中，

这里的基本查询会运行，它将父表复制到祖先表中。所以现在我们有了 Sue 和 John，John 和 Mary，以及父表中的其他任何内容，都在祖先表中了。随着迭代的进行，我们实际上是在将父表和祖先表进行连接，以便在祖先表中获取更多的元组。例如，我们看到这里的 Sue 和 John 这对元组。

将与John和Mary元组连接，这样我们就会在祖先表中得到Sue和Mary。迭代继续，直到没有新的元组可以添加到祖先表中，然后我们就完成了递归定义的关系，可以继续执行`WITH`语句中的最终查询。

再次提醒，当我说“我们”时，实际上是指系统，所有这些当然是在系统执行递归定义的`WITH`语句时由系统完成的。现在，让我们看一下同一查询的非线性表达式。这里就是它。我们看到的主要变化就在这里。

在递归部分，我们不再将父节点与祖先节点连接，而是将祖先关系的两个实例连接起来。让我们看看当我们以这种方式表达递归时，执行过程中会发生什么。所以，我们再次通过将父表的内容复制到祖先表中作为基本查询的一部分，而我已经在这里展示过了。

但现在我们不再在迭代过程中将父表与祖先表连接，而是实际上将祖先表与自身连接，以生成新的元组。例如，我们将祖先表中的前两个元组进行连接，Sue，John 和 John Mary，以获得线性递归中得到的相同元组。

这将是包含Sue和Mary的元组。只是一个简短的提醒，我本来打算早些说的，但事实是我们在递归中有这两个指向祖先的引用，这使得它变成了非线性。好的，那这两个查询有什么不同呢？

为什么我们可能更倾向于使用某种查询形式而非另一种呢？顺便说一下，听我说，我们确实可以得到线性和非线性版本的查询的等效结果。好了，下面是非线性和线性查询在这个特定查询中的一些优缺点，实际上，通常当我们可以用两种方式表达一个查询时，都是适用的。首先，非线性版本有一些优点。比如查询看起来更简洁。

如果你回去看这两个查询，非线性版本在某种程度上更对称，甚至比线性版本表达起来稍微简短一些。

![](img/43771b425ce5b32b6ff32a64b8cd4e6c_3.png)

其次，非线性版本实际上比线性版本更快收敛到固定点，即最终状态。我将稍微抽象地展示这一点，因为它实际上非常重要。所以我将创建这个抽象的例子，父子关系，完全线性的，只是为了说明。

所以我们这里有一个人，他是这里这个人的父母，而这个人又是这里这个人的父母，依此类推。我们将其扩展到八级深度。所以这是我们父表的抽象表示。现在，让我们看看祖先是如何计算的。首先，我们将为父关系中的每个元组添加一个祖先元组。

所以紫色的是添加到祖先中的元组。然后在第二次迭代中，我们将这些元组与它们自身结合。抱歉，我们将祖先元组与父母元组结合。因此，每个祖先元组可以通过扩展一个元素来形成新元组。这将给我们所有的元组配对。

抱歉，已经有点拥挤了，但我认为你会明白我的意思。在下一次迭代中，我们将再次获取祖先元组，并通过与父母元组结合将它们扩展一个元素。所以第二次迭代后，我们将得到所有三代关系。所以，所有的曾祖父母关系。好的，这有点乱，但你可以真正看到发生了什么。每次迭代时。

我们会向祖先中添加一代。现在让我们想想当我们使用非线性版本时会发生什么。在第一步后，我们将祖先与自身结合，而不是将祖先与父母结合。就像第一步一样，现在我将它们标记为红色。

祖先关系将与父母关系完全相同。第二步也是一样。我们将祖先与自身结合。但由于每个祖先只有父母关系，我们将在迭代的第二步中再次获取所有的配对。

差异从第三步开始。现在我们将祖先与自身结合。所以我们将像之前一样将这两个步骤的祖先与单一的祖先连接，目的是获取所有的三代关系，但我们也会将二代与二代相连接。换句话说，我们将祖父母关系与祖父母关系结合，并且在同一迭代中得到结果。

四代关系。正如你所看到的，非线性版本的收敛速度更快。现在这个例子非常小，所以不那么明显。但线性版本需要进行线性次数的迭代才能收敛到最终的递归定义关系内容。而当我们使用非线性版本时，实际上是对数时间复杂度。所以对于一个大型数据库。

它可以显著加速。那么非线性递归的缺点是什么呢？最大的缺点是它更难实现，或者说更难高效地实现。因此，实际上 SQL 标准只要求线性递归，而我们一直使用的 Postgres 系统也只支持线性递归。

让我们回到我们的 RIT 递归语句的基本形式，以引入一个不同的话题——互递归。互递归，如我在之前的视频中提到的，是其中一个递归定义的关系不直接引用自身，而是引用另一个递归定义的关系，而那个关系又引用回第一个。

或者我们甚至可以有三个、四个或更多的循环。所以这个想法是，我们不能单独查看这些节点来看到递归，但它们结合在一起时是递归的，并且它们必须以某种方式同时计算。所以我将在这里使用的例子是所谓的中心节点和权威节点。

中心节点和权威节点算法实际上是一个用于网页搜索的算法，用于为网页节点添加注释，以便进行搜索。它是在谷歌的PageRank算法大约同时开发的。我想我们可以看出哪一个最终获胜了。但中心节点和权威节点其实非常有趣，尤其是在它所做的事情方面。

让我先定义中心节点和权威节点的含义，然后展示如何在包含链接结构的数据库中使用互递归和SQL来计算中心节点和权威节点，基本上是一个图。所以这是一个小图，我们假设每个节点都有一个编号。

假设它关联着一个我们称为link的关系，它只是告诉我们图的边，即源节点和目标节点。因此，在一个图中，我们将指定一些节点为中心节点，另一些节点为权威节点，并且我们将定义中心节点为一个指向至少一些节点的节点，假设是这样。

三个权威节点。类似地，我们将说权威节点是一个至少被三个中心节点指向的节点。顺便提一句，这些数字，三和三，不必相同。我还想提到的是，在一个图中，比如说表示网页的图，我们不会期望大量的节点是中心节点和权威节点。

很多节点将是普通节点。但这仅仅是为了说明问题，同时也有助于教授你关于中心节点和权威节点的概念，这是相当有趣的。现在，你已经可以看到互递归如何适应这个图景了。那么我们该如何开始呢？实际上，你能开始的唯一方式就是先有一些节点被预先指定为中心节点和权威节点。

比如，如果我们把这三个中间节点预先指定为权威节点，那么我们就可以计算出节点一是一个中心节点。所以我们还假设我们的数据库中有两个或更多的关系。其中一个给出了预先指定为中心节点的节点集合，另一个则是预先指定为权威节点的节点集合。

我们的任务是写一个查询，根据这个互递归定义，计算出所有的中心节点和权威节点。

![](img/43771b425ce5b32b6ff32a64b8cd4e6c_5.png)

所以这是执行此操作的查询。顺便提一下，你肯定已经注意到我在这个视频中并没有做递归查询的现场演示。Postgres系统不支持非线性递归，而且它也不是SQL标准的一部分。SQL标准只在有限的形式中支持互递归，但Postgres目前也不支持。

我使用了这里的漂亮界面来获取查询的着色效果，但这些查询目前无法在我们使用的系统上运行。好了，回到我们实际的查询上。这是一个用于计算中心节点和权威节点的查询，前提是我们有一组初始的中心节点和初始的权威节点。

然后我们有链接关系，它给出了我们图的结构。因此，我们将计算两个关系，分别是包含中心节点的中心节点关系，和包含权威节点的权威节点关系，它们之间会有相互递归。

![](img/43771b425ce5b32b6ff32a64b8cd4e6c_7.png)

所以我们先来看一下中心节点，我们会发现中心节点和权威节点的查询结构非常，非常相似。因此，中心节点的基本情况是，位于中心节点起始关系中的节点也属于中心节点关系，当然。然后这里的递归查询有点复杂。所以我们将找到的是链接关系中的元素。

其中目标是一个权威节点。因此，我们将找到所有指向权威节点的源节点。我们按源节点进行分组，逐一考虑每个节点，然后计算它在指向权威节点的链接中出现的次数。因此，这将给我们提供指向至少三个权威节点的节点。

这就是我们对中心节点的定义。现在，在这里，当然，我们指的是权威性。权威关系本身是一个递归定义的关系。权威关系非常相似。正如我所说，我们从将节点添加到权威起始关系的基本情况开始。然后我们考虑链接关系中的目标，而不是源节点，要求至少有三个源节点是中心节点。

这就是我们下面的定义。因此，这将给我们提供被至少三个中心节点指向的元素。当然，在这里我们使用的是中心节点，它也是一个递归定义的关系。所以你可以认为这两个关系是相辅相成的。你可以把这个系统看作是一个迭代地不断添加中心节点和权威节点，直到两者都没有更多节点可以添加为止。

现在，这种关于中心节点和权威节点的定义及计算允许一个节点既是中心节点又是权威节点。如果图的结构导致这种结果，那是没有问题的。但假设我们不希望节点既能是中心节点又能是权威节点，我们希望每个节点只能是其中之一。为了实现这一点，我们需要修改查询，不让已经是权威节点的节点成为中心节点，或者不让已经是中心节点的节点成为权威节点。

所以让我们继续修改查询，以加入这个附加的约束。这里是查询，顺便提醒一下，虽然目前无法执行这些查询，但你仍然可以从我们的网站下载它们。这个查询与之前的一个不同之处在于，定义中心时多了一个额外的条件，在这里说明，如果节点已经在权威中，我不会将它加入中心。同时，类似的条件也适用。

我在权威中增加了一个条件，如果节点已经是中心，我不会将它加入到权威中。现在假设我们有以下图结构。我们有一个节点，它还没有被标记为中心或权威。假设这个节点被三个已经被标记为中心的节点指向。

此外，这个节点还指向三个已经被标记为权威的节点。所以根据我们的定义，这个节点可以是一个中心，因为它指向三个权威节点，它也可以是一个权威，因为它被三个中心节点指向。

![](img/43771b425ce5b32b6ff32a64b8cd4e6c_9.png)

但我们现在给出的查询将不允许我们将这个节点同时标记为中心和权威。为了明确起见，在之前的查询中，我们会将这个节点同时放入中心关系和权威关系中。但现在由于这里的条件，我们无法再这样做。所以实际上，这个节点最终是成为中心还是权威，实际上取决于我们这个宽度语句中的哪个分支先被执行。

如果我们首先考虑节点作为中心的可能性，那么它将被放入中心关系中，并且不允许被放入权威关系中。另一方面，如果我们首先定义一个节点为权威，那么当我们寻找计算中心关系时，它就不会被允许作为中心。所以你可以将其看作一种非确定性行为，或者如果你对理论感兴趣的话，这是一种递归的非唯一固定点。

这被认为是不好的事情。通常情况下，数据库人员在运行查询时希望得到一个一致的答案。他们希望查询能够返回确定性的结果。因此，实际上，在SQL标准中是不允许这种互递归的。

这个问题的核心在于，一个递归定义的关系依赖于另一个关系，并且是负向依赖的。因此，这种负向依赖造成了问题。实际上，我们即使没有互递归，也可以有负向依赖。我们可以定义一个关系，它依赖于自身以及一个子查询。

这也是不被允许的。所以这就完成了枢纽和权威的示例。再一次，我们首先要展示的是互递归，它可以非常强大。其次，我们要展示的是一个限制，即我们不能在递归定义的关系中进行负向子查询。我在这段视频中最后要提到的一点，虽然它没有出现在视频标题中，因为我们主要聚焦于非线性和互递归。

递归与聚合。让我先展示一个简单的抽象示例。所以我们有一个关系P，它只包含一个属性。我们可以假设它是整数类型的。我们将在我们的`with recursive`语句中计算一个递归定义的关系R，R包含P中的元组以及P属性值的总和。我将它表示为P的总和。那么我们在SQL中是这样写的。我们有我们的基本情况。

也就是说，P中的元组也在R中。然后我们进行递归部分的联合，这表示在R中，我还希望包含R中元组的总和。那么假设P开始时有两个元组，值分别是1和2。那么这个查询计算出的R是什么呢？显然，基于第一部分的内容，1和2确实在R中。

然后根据第二部分，在第一次迭代中，R也应该包含R的总和。总和是三，但一旦我们把三放进去，R的总和就不再是三了。R的总和变成了六。那么我们是否应该把三去掉，改成六呢？但现在R的总和变成了六、七九等等。所以我们可以看到这个问题。

基于这种递归，R应该包含什么没有明确的定义。因此，实际上，SQL标准不允许递归与聚合一起使用，并且任何系统都不支持这种做法。总结一下我们关于递归的两段视频内容，SQL已经将递归引入标准，作为`with`语句的一部分。

递归关键字是与`with`一起使用，还是与递归定义的关系一起使用，这一点有些不一致。但无论如何，基本思想是一样的。当我们有这个语句时，我们可以编写引用正在定义的关系的查询。我们还可以在`with`语句中定义的查询之间进行互递归。

最终，结果是运行最终查询，这可能涉及递归定义的关系。将递归引入SQL确实扩展了它的表达能力。有些查询如果没有递归无法编写。它们通常涉及某种类型的无界计算。例如，计算航班数量或祖先的任何深度。这些查询通常带有传递闭包的性质。如果没有递归，计算递归定义关系所需的迭代必须写在数据库外部。

必须以某种形式写成代码。我们已经看到，SQL递归的基本功能是线性递归，其中查询中只会有一个递归定义的关系实例来定义关系。我们可以用线性递归写很多内容，它非常具有表现力，能够表达我们可能希望在递归SQL中执行的大多数自然查询。但是，SQL还有扩展功能，存在非线性递归。

我们看到，非线性递归可以生成更简洁的查询，且收敛速度更快，但实际上更难以高效实现。然后是互递归，其中R1可能是基于R2定义的，而R2又是基于R1定义的。我们看到一个有趣的例子，在其中我们希望使用互递归。

在适当的地方。最后，关于禁止的内容，递归子查询。我的意思是，在子查询中引用递归定义的关系，这在SQL标准中是允许的，但我们使用的Postgres系统并不支持。当在子查询中引用递归定义的关系时，结果是负面的。

这有点像非存在（non-exists）或者否定（not），而这在SQL标准中是被禁止的。我们看到这可能会导致不明显的行为，最终结果可能是非确定性的。最后，聚合也会在递归中引发复杂性，并且同样是被禁止的。那些被禁止的特性其实在自然情况下并不经常出现。

再次强调，线性递归的基本功能确实允许我们表达很多非常好的查询，并且扩展了SQL语言的表现力。

![](img/43771b425ce5b32b6ff32a64b8cd4e6c_11.png)
