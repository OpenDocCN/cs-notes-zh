- en: P16：08-02-xpath-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P16：08-02-xpath-demo.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: In this video， we'll demonstrate X-Path by running a number of queries over
    our bookstore data。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本视频中，我们将通过对我们的书店数据运行一系列查询来演示 X-Path。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_1.png)'
- en: Let's first take a look at the data。 We've expanded it slightly over what we've
    been using in previous videos。 but it continues to have pretty much the same structure。
    We have a number of books。 Books have attributes， ISBN， price， sometimes in addition。
    They have a title sub-element。 authors with first name and last name。 So we have
    our first course book and our complete book。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看数据。我们稍微扩展了之前视频中使用的数据，但它的结构基本保持不变。我们有许多书籍，书籍有属性，如 ISBN、价格，有时还包括其他内容。它们有标题子元素，作者包括名和姓。所以我们有我们的第一本教材和完整书籍。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_3.png)'
- en: And our complete book also has a remark， as you may recall。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的完整书籍也有一个备注，正如你可能记得的那样。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_5.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_5.png)'
- en: Then I've added a couple more books。 I've added Hector and Jeff's Database Hints
    by Jeffrey Elman and Hector Garcia Molina。 with a remark， an indispensable companion
    to your textbook。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我添加了几本书。我添加了 Jeffrey Elman 和 Hector Garcia Molina 的《数据库提示》，并附有备注，这是你课本的不可或缺的伴侣。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_7.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_7.png)'
- en: I've also added Jennifer's economical database hints for that。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了 Jennifer 的经济型数据库提示。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_9.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_9.png)'
- en: At a mere price of $25， you get some hints。 And then finally。 just to demonstrate
    certain expressions。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 只需花费$25，你就能获得一些提示。然后最后，为了演示某些表达式。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_11.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_11.png)'
- en: I've inserted three magazines to national geographics and a Newsweek。 And finally。
    a magazine called Hector and Jeff's Database Hints。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我还插入了三本杂志，包括《国家地理》和《新闻周刊》。最后，我还插入了一本名为《Hector 和 Jeff 的数据库提示》的杂志。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_13.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_13.png)'
- en: So with this data in mind， let's move to the queries。 We'll start with simple
    queries and get more complicated as we proceed。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，记住这些数据后，我们来处理查询。我们将从简单的查询开始，随着进展逐渐变得复杂。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_15.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_15.png)'
- en: In this window， we'll be putting our X-Path expressions in the upper pane。 then
    we'll execute the query and we'll see the results in the lower pane。 The way X-Path
    works。 the first part of every expression， specifies the document over which the
    X-Path expression is to be evaluated。 So we have the data that you saw in a document
    called bookstoreQ。xml。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口中，我们将在上方窗格中输入我们的 X-Path 表达式，然后执行查询，结果将在下方窗格中显示。X-Path 的工作原理是，每个表达式的第一部分指定了要在其上评估
    X-Path 表达式的文档。因此，我们有你在名为 bookstoreQ.xml 的文档中看到的数据。
- en: and you'll see in each of our expressions that we begin by specifying that document。
    and then move ahead to the rest of the X-Path expression。 Our first expression
    is a very simple path expression。 It says navigate through the XML by going first
    to the root element called Bookstore。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，在我们的每个表达式中，我们首先指定该文档，然后继续进行其余的 X-Path 表达式。我们的第一个表达式是一个非常简单的路径表达式。它的意思是通过首先进入名为
    Bookstore 的根元素来浏览 XML。
- en: then look at all the book-sub elements of Bookstore and finally all the titles
    of elements。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后查看所有书店（Bookstore）下的书籍子元素，最后是所有元素的标题。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_17.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_17.png)'
- en: Let's run the query and we'll see our result below。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行查询，然后在下方查看结果。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_19.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_19.png)'
- en: So as we can see， our result here is actually written in XML， a little header
    appears。 and then we see the four titles of books that are in our database。 Now
    let's modify our path expression。 Instead of only getting book titles。 let's get
    book or magazine titles。 We do that by extending our middle matching element here
    to use a sort of regular expression like syntax。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们所看到的，我们这里的结果实际上是以 XML 形式书写的，出现了一个小的头部，然后我们看到了数据库中四本书的标题。现在，让我们修改我们的路径表达式。不仅获取书籍标题，而是获取书籍或杂志的标题。我们通过扩展中间匹配元素来使用类似正则表达式的语法来做到这一点。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_21.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_21.png)'
- en: book or magazine， and we put it in parentheses。 So now it says match any path
    in the data that starts at the bookstore element。 follows either a book or magazine
    sub-element， and then finally a title sub-element。 When we run the query， we see
    now that we get not only the titles of our books。 but also the titles of our magazines。
    So far we've mentioned element names explicitly in our path expressions。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍或杂志，我们将它放在括号中。现在它表示匹配数据中从书店元素开始的任何路径，跟随书籍或杂志的子元素，最后是标题子元素。当我们运行查询时，我们现在看到的不仅是我们书籍的标题，还有杂志的标题。到目前为止，我们在路径表达式中明确提到了元素名称。
- en: but as I mentioned in the introductory video， we can also use what's known as
    a wildcard symbol。 the symbol star。 Star says to match any element name。 So now
    we're going to start again with bookstore， match any element below bookstore。
    and finally find title sub-elements below those any elements。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我在介绍视频中提到的，我们还可以使用所谓的通配符符号——星号符号。星号表示匹配任何元素名称。所以现在我们将重新从书店开始，匹配书店下的任何元素，最后找到那些元素下的标题子元素。
- en: Now it so happens that the only elements below bookstore are books and magazines。
    so when we run the query， we will get exactly the same result。 So far we've been
    navigating with the single slash operator。 which tells us to go one element at
    a time。 We're at a particular element。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在恰好在书店下方的唯一元素是书籍和杂志。所以当我们运行查询时，我们将得到完全相同的结果。到目前为止，我们一直在使用单斜杠操作符进行导航，告诉我们一次处理一个元素。我们处在一个特定的元素上。
- en: and then we match sub-elements with the specific tag that we typed。 There's
    also the double slash operator。 As you recall from the introductory video。 double
    slash says match myself， or any descendants of myself to any length。 So if I put
    a double slash title， what we'll be matching is any title element anywhere at
    all in the XML tree。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过我们输入的特定标签匹配子元素。还有一个双斜杠操作符。如你在介绍视频中记得的，双斜杠表示匹配我自己，或者我自己所有的后代元素，直到任何长度。所以如果我输入双斜杠标题，那么我们匹配的将是XML树中任何位置的标题元素。
- en: We run the query， and again we get exactly the same result。 because we had already
    been getting all of the titles。 which were sub-elements of books or magazines。
    Now let's get something a little different。 Let's put slash slash star。 Now that's
    kind of a wild thing to put。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行查询，再次得到完全相同的结果，因为我们已经得到了所有书籍或杂志的子元素——标题。现在让我们做些不同的事情。让我们输入双斜杠星号。那可是一个非常野的东西。
- en: because it says I'm going to match any element in the entire tree。 and furthermore
    it can be of any element type。 Let's run the query and see what happens。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它表示我将匹配整个树中的任何元素，而且它可以是任何类型的元素。让我们运行查询，看看会发生什么。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_23.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_23.png)'
- en: What we get is a huge result。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个巨大的结果。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_25.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_25.png)'
- en: Let me just scroll down so you can see the result。 In fact。 what we're getting
    is every element at every level of the tree， including all of its sub-elements。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向下滚动，这样你就能看到结果。实际上，我们得到的是树中每个层级的所有元素，包括它的所有子元素。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_27.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_27.png)'
- en: So in fact the first element in our result is our entire tree， because it's
    our bookstore element。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们结果中的第一个元素是我们的整个树结构，因为它是我们的书店元素。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_29.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_29.png)'
- en: and we'll go all the way down to the end of the bookstore。 The next element
    in our result is some children of the bookstore， so we get the book elements。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会一直走到书店的最底部。接下来是我们结果中的一些书店子元素，所以我们得到了书籍元素。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_31.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_31.png)'
- en: And we're also going to get their children in the answer， and as we keep scrolling
    down。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在答案中得到它们的子元素，并且随着我们继续向下滚动。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_33.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_33.png)'
- en: we'll see that we get every element of the entire database。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到我们得到了整个数据库中的每一个元素。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_35.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_35.png)'
- en: So that's not a useful query， but it does demonstrate the constructs。 the double
    slash matching any element in the tree， and the star matching any tag of any element。
    Now let's turn to attributes。 Let's suppose we're interested in returning all
    the ISBN numbers in the database。 So we'll go back to saying bookstore， book sub-elements，
    and then we'll get the attribute ISBN。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个有用的查询，但它确实展示了构造方法，双斜杠表示匹配树中的任何元素，星号表示匹配任何元素的标签。现在，让我们转向属性。假设我们有兴趣返回数据库中的所有ISBN号码。我们将回到说书店、书籍子元素，然后获取ISBN属性。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_37.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_37.png)'
- en: So we type at sign and ISBN。 Let's run the query， and we get an error。 It turns
    out that attributes cannot be what's called serialized in order to return them
    in an XML-looking result。 So what we need to do actually is obtain the data from
    the attribute itself， and once we do that。 we'll see that we're getting the answer
    that we desire。 So we'll ask for the data of the attribute。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们输入@符号和ISBN。让我们运行查询，结果出现了一个错误。原来，属性不能被序列化以便返回类似XML的结果。因此，我们实际上需要做的是从属性本身获取数据，一旦我们这么做，就会看到我们得到了想要的答案。所以我们会请求属性的数据。
- en: run the query， and now we see we have all the ISBN numbers。 Now the attribute
    data is just strings。 so we're returning the ISBN numbers as a set of strings
    with blanks between them。 So some of these are sort of peculiarities of how X-Path
    works。 Again。 we were not able to return an attribute because it didn't know how
    to structure the result。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询，现在我们看到所有的ISBN号码。现在，属性数据只是字符串。所以我们将ISBN号码作为一组字符串返回，中间有空格。其实这些是X-Path工作方式的一些特殊情况。再说一次，我们不能返回属性，因为它不知道如何构造结果。
- en: but once we extracted the data from the attribute， it returned it as string
    values。 So far。 we've only seen path expressions with no conditions involved，
    so let's throw in a condition。 Let's say that we're interested in returning books
    that cost less than $90。 So what we're going to do here is navigate to the book。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一旦我们从属性中提取了数据，它会将其作为字符串值返回。到目前为止，我们只看到了没有涉及条件的路径表达式，所以让我们加入一个条件。假设我们有兴趣返回价格低于$90的书籍。那么我们在这里要做的是导航到书籍。
- en: and then we're going to use the square bracket， which says start evaluating
    a condition at the current point of the navigation。 So the condition that I'm
    going to put is that the price of the book is less than $90。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用方括号，它表示从当前导航点开始评估条件。所以我要设置的条件是书籍的价格低于$90。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_39.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_39.png)'
- en: We'll run that query， and we'll see that we have two books， our three books，
    I apologize。 whose price is less than $90。 Now here we return the book that satisfied
    the condition。 What if what we actually want to return is the title of the book
    whose price is less than $90？
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行该查询，然后我们会看到有两本书，或者说三本书，我道歉，它们的价格低于$90。现在，我们返回了满足条件的书籍。如果我们实际上想要返回的是价格低于$90的书籍的标题呢？
- en: What we can do is after evaluating this condition on the book。 we can actually
    continue our navigation。 So we just put /title here， it says find the books。 only
    keep the ones that match the condition， and then continue navigating down to their
    titles。 and return that as the result of the query。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是，在评估了书籍的条件后，实际上可以继续进行导航。所以我们只需在这里加上/title，它表示找到书籍，保留那些符合条件的，然后继续向下导航到它们的标题，并将其作为查询结果返回。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_41.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_41.png)'
- en: We run the query and we see our result。 Now another type of condition that we
    can put in square brackets is an existence condition instead of a comparison。
    If we put， for example， just the label remark inside our square brackets。 that
    says that we should match books that have a remark。 So putting an element name
    in square brackets is an existence condition on that。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行查询，并看到我们的结果。现在，我们可以在方括号中放入另一种类型的条件——存在条件，而不是比较条件。如果我们例如仅在方括号中放入标签remark，它表示我们应该匹配那些有remark的书籍。所以将元素名称放入方括号中就是对该元素的存在条件。
- en: so the element existing。 Once we've isolated the books that have a remark。 we'll
    return the title of those books。 We run the query and we discover that two of
    our books have a remark。 You can go back and check the data and you'll see that's
    indeed the case。 Let's get a little bit more complicated now。 Let's get rid of
    this query and put in a whole new one。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以元素存在。一旦我们隔离出有备注的书籍，我们将返回这些书籍的标题。我们运行查询，发现有两本书有备注。你可以回去检查数据，确认确实是这样。现在让我们稍微复杂一点。我们先去掉这个查询，换成一个全新的查询。
- en: In this query we're going to find the titles of books where the price is less
    than $90 and where Omen is one of the authors。 So now we have in our square brackets
    a longer condition。 This is less than $90 and there exists and implicitly this
    is an exist。 There exists a sub path from the book author/author/last name where
    the value of that is Omen。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们将查找价格低于90美元且Omen是其中一位作者的书籍标题。所以现在我们在方括号中有了一个更长的条件。这个条件是价格低于90美元，并且存在一个路径——这是隐含的存在——存在一个从书籍的author/author/last
    name子路径，其值为Omen。
- en: If we satisfy both of those conditions then we'll return the title of the book。
    So we run the query and we discover two books that are less than $90 where Omen
    is one of the authors。 Now let's expand this query by adding another condition。
    We want not only the last name of the author to be Omen but the first name to
    be Jeffrey。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们满足这两个条件，那么我们将返回书籍的标题。所以我们运行查询，发现了两本价格低于90美元且其中一位作者是Omen的书籍。现在让我们通过添加另一个条件来扩展这个查询。我们不仅要作者的姓氏是Omen，还要名字是Jeffrey。
- en: So now we're looking for books where Jeffrey Omen is one of the authors and
    the books are less than $90。 So we run the query and we get the same result not
    surprisingly since Omen is always paired with Jeffrey。 But actually this is not
    doing quite what we're expecting and I'm going to explain why by demonstrating
    some changes。 Let's say that we change our query to not look for Jeffrey Omen
    as an author but to look for Jeffrey Widdham。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们在寻找的是Jeffrey Omen是作者之一且书籍价格低于90美元的书籍。我们运行查询，得到相同的结果，这并不令人惊讶，因为Omen总是和Jeffrey配对。但是实际上，这个查询并没有完全达到我们的预期，我将通过展示一些修改来解释原因。假设我们改变查询，不再寻找Jeffrey
    Omen作为作者，而是寻找Jeffrey Widdham。
- en: Hopefully we'll get no answers but when we run the query we see we still get
    a book。 The first course in database systems。 So the two authors of that book
    if you look back at the data are Jeffrey Omen and Jennifer Widdham。 So let's see
    why that book was returned in this query。 The reason is if we look closely at
    this condition what we're saying is we're looking for books for the prices less
    than $90 and there exists an author's author/last name path where the value is
    Widdham and there exists an author's author first name。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们不会得到任何答案，但当我们运行查询时，我们看到仍然有一本书被返回。那就是《数据库系统第一课程》。回到数据中查看这本书的两个作者是Jeffrey
    Omen和Jennifer Widdham。那么我们来看看为什么这本书会在这个查询中被返回。原因是如果我们仔细观察这个条件，我们会发现我们在寻找的是价格低于90美元的书籍，并且存在一个作者的author/last
    name路径，其值是Widdham，且存在一个作者的first name路径，其值是Jeffrey。
- en: Where the value is Jeffrey。 Well that in fact is true。 We have one author whose
    last name is Widdham and another author whose first name is Jeffrey。 Let's try
    to formulate the correct query now。 So instead of matching the entire path to
    the last name and then the entire path to the first name separately through the
    authors sub elements。 What we want to do is we want to look at each author at
    a time and within that author look at the last name and first name together。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是对的。我们有一位作者的姓氏是Widdham，另一位作者的名字是Jeffrey。现在让我们尝试制定正确的查询。所以，我们不再分别匹配整个路径的姓氏和名字，而是希望逐一查看每个作者，并在该作者内部同时查看姓氏和名字。
- en: So to modify our query to do that we're going to use a condition within the
    condition specifically within the author/author will look at the last name and
    the first name。 This syntax error is temporary once we finish the query everything
    will look good。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了修改我们的查询，我们将在条件内使用条件，特别是在author/author部分，我们将查看姓氏和名字。这个语法错误是暂时的，等我们完成查询后，一切都会正常。
- en: So we put a second bracket there and let me show again what I've done。 I've
    said we're looking for books where the price is less than 90 and there exists
    an author/author sub element where the last name is Widdham and the first name
    is Jeffrey。 Hopefully we'll get an empty answer here。 We execute the query and
    indeed we do。 Now our original goal was to have Jeffrey Omen。 So finally we'll
    change Jeffrey Omen run the query and now we get the correct answer。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里放了第二个方括号，让我再展示一下我做了什么。我说我们在寻找那些价格低于90并且存在一个作者/作者子元素的书籍，这个作者的姓氏是Widdham，名字是Jeffrey。希望我们能得到一个空的答案。我们执行查询，结果确实如此。现在我们最初的目标是找出Jeffrey
    Omen。因此，最后我们会把Jeffrey Omen改成，运行查询，现在我们得到了正确的答案。
- en: Incidentally it's a very common mistake when we have a condition to put a slash
    before the condition。 If we did that we'd get a syntax error。 When we write the
    square bracket it essentially acts like a slash so when we reference a sub element
    name within a square bracket we're implicitly navigating to that sub element。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这是一种很常见的错误，当我们有一个条件时，我们往往会在条件前面加上斜杠。如果我们这么做，会得到语法错误。当我们编写方括号时，它实际上起到了斜杠的作用，所以当我们在方括号内引用子元素名称时，我们实际上是隐式地导航到那个子元素。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_43.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_43.png)'
- en: Next we're going to try a similar query with a twist。 We're going to try to
    find books where Omen is an author and Widdham is not an author。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将尝试一个稍微不同的类似查询。我们要尝试查找那些Omen是作者而Widdham不是作者的书籍。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_45.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_45.png)'
- en: So we navigate to books as usual and we look for cases where there's an author's
    author last name equals Omen and there's an author's author last name not equal
    to Widdham。 Now you may already detect that this is not the correct query but
    let's go ahead and run and we see that we got three books but we know the first
    two books Widdham is an author。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们像往常一样导航到书籍，查找那些作者的姓氏是Omen，而作者的姓氏不是Widdham的情况。现在你可能已经发现这不是正确的查询，但我们还是继续运行，结果显示我们得到了三本书，但我们知道前两本书中Widdham是作者。
- en: So as you may have detected this is not correct what this asks for are books
    where there's an author whose last name is Omen and there's some author whose
    last name is not Widdham。 Well in fact every book with Omen as an author has some
    author whose last name is not Widdham that would be Omen。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你可能已经察觉到的，这并不正确，这个查询要求的是书籍中有一个姓氏为Omen的作者，并且有一些姓氏不是Widdham的作者。事实上，每本书中有Omen作为作者，都会有一个姓氏不是Widdham的作者，那就是Omen。
- en: So even if I took away this condition and ran the query again I'll get exactly
    the same result。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以即使我去掉这个条件，再次运行查询，我也会得到完全相同的结果。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_47.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_47.png)'
- en: Well actually I got a syntax error。 Whoops I forgot to erase the and so let's
    get rid of that run the query and now we do in fact get the exact same result。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我遇到了一个语法错误。哎呀，我忘了删除那个，所以下去这个，运行查询，现在我们确实得到了完全相同的结果。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_49.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_49.png)'
- en: So as a reminder we were trying to find books where Omen is an author and Widdham
    is not。 In fact we do not have constructs yet to write that query。 A little later
    in the demo we'll see how we can write it in a kind of tricky fashion but for
    what we've seen so far with path expressions and conditions we're unable to write
    that specific query。 So far we've seen two types of conditions in brackets。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，作为提醒，我们之前是在尝试查找那些Omen是作者而Widdham不是作者的书籍。实际上，我们还没有构建出能够写出这个查询的结构。稍后在演示中我们会看到如何以一种稍微复杂的方式来写这个查询，但截至目前，我们所见到的路径表达式和条件，我们无法写出这个特定的查询。到目前为止，我们已经看过了括号中使用的两种条件类型。
- en: We saw comparisons and we saw existence constraints where we check to see whether
    a particular sub element existed。 As you might remember from the intro we can
    also put numbers inside square brackets and those numbers tell us to return the
    nth sub element。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看过比较操作，也看过存在性约束，即检查某个子元素是否存在。正如你从介绍中可能记得的，我们也可以在方括号中放入数字，这些数字告诉我们返回第n个子元素。
- en: Specifically if we look at this query we're using slash slash to navigate directly
    to author's elements and then we want to return the second author sub element
    of each author's element。 So we run the query and we'll see if we looked at our
    data that Jennifer Widdham。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，如果我们看这个查询，我们使用双斜杠直接导航到作者元素，然后我们希望返回每个作者元素的第二个作者子元素。所以我们运行查询，我们会看到，如果查看我们的数据，我们会看到Jennifer
    Widdham。
- en: Jeffrey Omen and Hector Garcia Molina each appear once as the second author
    of a book or a magazine。 If we change this to three we'll be returning third authors
    only and we can see only Jennifer Widdham is a third author。 If we change this
    to ten hopefully we'll get an empty result and in fact we do。 Now let's take a
    look at some built-in functions and predicates。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jeffrey Omen 和 Hector Garcia Molina 每个人都作为书籍或杂志的第二作者出现一次。如果我们把这个改为三，我们只会返回第三作者，而且我们可以看到只有
    Jennifer Widdham 是第三作者。如果我们改为十，希望得到空结果，实际上确实得到了。现在，让我们来看一些内建函数和谓词。
- en: In this query we're going to find all books where there's a remark about the
    book that contains the word "great"。 So we're going to navigate using slash slash
    directly to book elements and within the book element we'll have a condition that
    invokes this built-in predicate contains which I mentioned in the introductory
    video which looks at two strings and checks whether the first string contains
    the second one。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们将查找所有书籍，其中有一个关于书的备注，包含“great”一词。所以我们将使用斜杠斜杠直接导航到书籍元素，在书籍元素中，我们会有一个条件，调用这个内建谓词
    contains，正如我在介绍视频中提到的，它会比较两个字符串，并检查第一个字符串是否包含第二个字符串。
- en: So if we have a book where there's a remark which is a string that contains
    the word "great" then the book matches the condition and we'll return the title
    of the book。 We run the query and we see that we have one book that has a remark
    containing the word "great"。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们有一本书，其中有一个备注，它是一个包含“great”一词的字符串，那么这本书就会符合条件，我们将返回书的标题。我们运行查询，看到我们有一本书，它的备注包含了“great”一词。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_51.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_51.png)'
- en: Our next query does something kind of new。 I like to call this query a self-join
    but that's probably because I'm a relationally biased person。 What it's actually
    doing is querying sort of two instances of our bookstore data at once and joining
    them together。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个查询做了一些新鲜的事情。我喜欢称这个查询为自连接，但这可能是因为我偏向关系型思维。实际上，它正在查询我们书店数据的两个实例，并将它们连接在一起。
- en: So we'll see that our doc bookstore appears twice in this expression。 Let me
    explain what this expression is doing。 It's finding all magazines where there's
    a book that has the same title as the magazine and here's how it does it。 So our
    first path expression navigates two magazines and then it extracts it in the condition
    the title of the magazines。 The magazine will match if the title equals some book
    title and so to find the book titles we need to go back to the top of the document
    so we get a second instance of the document and we find book titles。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们会看到我们的 doc bookstore 在这个表达式中出现了两次。让我解释一下这个表达式在做什么。它在查找所有杂志，这些杂志中有一本书，它的标题与杂志的标题相同，下面是它是如何实现的。我们第一个路径表达式导航到杂志，然后在条件中提取杂志的标题。如果杂志的标题等于某本书的标题，它就会匹配。所以为了找到书的标题，我们需要返回到文档的顶部，因此我们会得到文档的第二个实例，并找到书的标题。
- en: Now when we have the equals here this equals is implicitly existentially quantified。
    That means that even though we're doing equals on what's effectively a set the
    condition is satisfied if some element of the set is equal to the first title。
    There's a lot of implicit existential quantification going on inequality in x
    path and in x query as well as we'll see later on。 In any case let's run the query
    and we will get back the fact that the magazine called Hector and Jeff's database
    hints has the same title as a book and if you look back in the data you'll see
    what's going on。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在这里使用等号时，这个等号是隐式存在量化的。这意味着，尽管我们对实际上是一个集合的东西进行等值比较，条件是满足的，只要集合中的某个元素等于第一个标题。XPath
    和 XQuery 中有很多隐式的存在量化，稍后我们会看到。无论如何，让我们运行查询，我们会返回事实，名为 Hector 和 Jeff's database
    hints 的杂志与一本书的标题相同，如果你回顾数据，你会看到发生了什么。
- en: So back in the data you'll see we do have a book of the same name。 We saw one
    example of a built-in predicate contains this example shows another built-in function
    in this case the name function and it also shows our first example of a navigation
    axis。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在数据中你会看到我们确实有一本同名的书。我们看到一个内建谓词的例子，包含了这个例子，它展示了另一个内建函数，这次是名称函数，并且它也展示了我们的第一个导航轴的例子。
- en: We're going to use the parent axis。 What this query is going to find is all
    elements whose parent element tag is not bookstore or book。 Of course this is
    just for demonstration purposes is not really that useful of a query。 We just
    walk through the construction of the query。 We're starting with our bookstore
    and then we're using slash slash star which finds all elements。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用父轴。这个查询要查找的是所有其父元素标签不是书店或书籍的元素。当然，这只是为了演示目的，实际上这个查询并没有多大用处。我们只是演示查询的构造过程。我们从书店元素开始，然后使用斜杠斜杠星号，这会找到所有元素。
- en: We saw slash slash star earlier when we ran the query we saw that it matched
    every element in the book in the database。 Now since we've already put in bookstore
    we're not going to match the bookstore element itself but we'll match every child
    of the bookstore element。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到过`// *`，当我们运行查询时，我们看到它匹配了数据库中所有的元素。现在，由于我们已经放入了书店元素，我们将不会匹配书店元素本身，而是匹配书店元素的所有子元素。
- en: So what the condition looks for is the tag of the parent of the current element
    and it sees if it's bookstore or book and we return the element if it's neither
    bookstore nor book as the parent tag。 Here's how we find the parent tag。 So name
    is a built-in function name operates on an element and it returns the tag of that
    element。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件查找的是当前元素的父标签，并检查它是否是书店或书籍，如果既不是书店也不是书籍，我们就返回该元素。下面是如何找到父标签的方法。`name`是一个内置函数，`name`作用于一个元素，并返回该元素的标签。
- en: The element we want to look at is the parent of the current element and the
    way we do that is with the parent navigation axis which is parent colon colon。
    Finally the star is matching the tag of the parent。 So here we say match any tag
    of the parent extract the tag and check if it's bookstore or book。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的元素是当前元素的父元素，我们使用的是父导航轴，即`parent::`。最后，星号匹配父元素的标签。所以这里我们说匹配任何父元素的标签，提取该标签并检查它是否是书店或书籍。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_53.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_53.png)'
- en: So when we run the query we'll see that we get back a lot of data but all of
    them are elements in the database whose parent is not the bookstore or book。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们运行查询时，我们会看到返回了很多数据，但它们都是父元素不是书店或书籍的数据库元素。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_55.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_55.png)'
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_56.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_56.png)'
- en: Here's another example of a navigation axis。 In this case we're using following
    sibling。 Following sibling says that if we're at a specific point in the tree
    we should match every sibling so every other element at the same level that's
    later in the document that follows the current sibling。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个导航轴的示例。在这种情况下，我们使用了`following sibling`（后续兄弟）。`following sibling`表示，如果我们在树中的某个特定位置，我们应该匹配每个兄弟元素，也就是文档中紧随当前兄弟元素之后的同一级别的所有其他元素。
- en: So let's walk through this expression and see what we're doing。 What this expression
    is looking for is all books and magazines that have a non-unique title。 In other
    words all books or magazines where some other book or magazine has the same title。
    So we navigate down to books or magazine elements。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们逐步解析这个表达式，看看我们在做什么。这个表达式的目标是查找所有标题不是唯一的书籍和杂志。换句话说，查找所有有其他书籍或杂志拥有相同标题的书籍或杂志。所以我们导航到书籍或杂志元素。
- en: This is what we saw in one of our earlier path expressions。 We'll match any
    book or magazine element。 And then we want to find one where the title is equal
    to some title of a later sibling。 Now our books and magazines are all at the same
    level in our data so when we do a following sibling we're going to be matching
    all other books and magazines that appear after the current one。 And again this
    star says that we can match an element of any type。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在路径表达式中看到的内容。我们会匹配任何书籍或杂志元素。然后，我们希望找到标题等于某个后续兄弟元素标题的元素。现在，我们的书籍和杂志都在数据中的同一级别，因此，当我们使用`following
    sibling`时，我们将匹配所有出现在当前元素之后的书籍和杂志。同样，星号表示我们可以匹配任何类型的元素。
- en: We get a quiver only book or magazine in here because we know they're all books
    or magazines and we'll do that in a moment but now let's just focus on running
    the query。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果只会是书籍或杂志，因为我们知道它们都是书籍或杂志，我们稍后会做这件事，但现在让我们专注于运行查询。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_58.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_58.png)'
- en: So we execute the query and we find two answers。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们执行查询，得到两个结果。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_60.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_60.png)'
- en: We find Hector and Jeff's database hints which is a book because we had a magazine
    of the same title and we find national geographic which is a magazine because
    there's another magazine of the same title。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了Hector和Jeff的数据库提示，它是一本书，因为我们有一本同名的杂志；我们还找到了《国家地理》，它是一本杂志，因为有另一本文字相同的杂志。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_62.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_62.png)'
- en: So actually this query was somewhat incomplete and that was our fault。 The way
    we wrote the query we said that we want to return book or magazine elements when
    a later one has the same title so that doesn't actually return all of the ones
    with non-unique titles。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以实际上这个查询有点不完整，这是我们的错误。我们写查询时说要返回标题相同的书籍或杂志元素，但这个查询并没有返回所有具有非唯一标题的元素。
- en: It only returns the first instance of each one with a non-unique title。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它只返回每个非唯一标题的第一个实例。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_64.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_64.png)'
- en: Let's modify the query to do the right thing。 What we need to do is not only
    check whether the title equals the following sibling title of some book or magazine
    but whether it might also equal a preceding one。 We add title equals the same
    construct using the preceding sibling axis/slur title。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改查询以做正确的事情。我们需要做的不仅仅是检查标题是否等于某本书或杂志的下一个兄弟标题，还需要检查它是否可能等于前一个标题。我们添加了标题相等的构造，使用了preceding
    sibling轴/slur标题。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_66.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_66.png)'
- en: Here we go and now when we run the query we see that we get Hector and Jeff's
    database hints and national geographic but we also get another instance of national
    geographic and another instance of Hector and Jeff's database hints。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看，运行查询后，我们看到Hector和Jeff的数据库提示和《国家地理》都被返回了，但我们也得到了另一篇《国家地理》和另一篇Hector和Jeff的数据库提示。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_68.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_68.png)'
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_69.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_69.png)'
- en: So now we have the correct answer。 We don't only get the first instance of duplicated
    titles but we get both of them。 Now to show the use of this star we were matching
    any book or magazine as the following sibling。 What if all we were interested
    in is cases where there's a book that has the same title but not a magazine and
    we can do the same thing here。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了正确的答案。我们不仅仅得到了重复标题的第一个实例，还得到了所有的重复实例。现在要展示这个星号的使用，我们匹配任何书籍或杂志作为下一个兄弟元素。如果我们只关心有一本书与其他杂志有相同标题的情况，我们可以在这里做同样的事情。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_71.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_71.png)'
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_72.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_72.png)'
- en: In that case we shouldn't get national geographic anymore。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们就不应该再获取《国家地理》了。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_74.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_74.png)'
- en: Let's run the query and indeed all we get in fact is Hector and Jeff's database
    hints as a magazine because that was only the only instance where there was an
    actual book that had the same title。 As opposed to matching books or magazines
    with the star。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行查询，确实我们得到的所有结果实际上是Hector和Jeff的数据库提示作为一本杂志，因为这是唯一一个确实有相同标题的书。与匹配书籍或杂志的星号不同。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_76.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_76.png)'
- en: Don't take a look at this query yet。 Let me explain what I'm doing before you
    try to untangle the syntax to do it。 As I mentioned earlier expath revolves around
    implicit existential quantification。 So when we are looking for example for an
    author whose name is Omen implicitly we will match the path if any author has
    the last name Omen。 In general most of expath revolves around matching sets of
    values and then returning things if any element of that set matches the condition。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 先别看这个查询。让我在你试图解开语法之前先解释一下我在做什么。正如我之前提到的，expath涉及隐式存在量化。所以当我们在寻找作者时，如果某个作者的姓是Omen，我们会匹配任何具有Omen姓氏的路径。一般来说，大多数expath的操作都围绕着匹配一组值，然后返回集合中符合条件的元素。
- en: What if we want to do universal quantification in other words for all。 That
    turns out to be more complicated but we can do it in a tricky fashion。 So what
    we're going to do with this query is we're going to find books where every author's
    first name includes J。 If we wrote it in the fashion that we might be tempted
    to where we just say book author/author first name includes J。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要做全称量化，也就是说“对所有”，这就更复杂了，但我们可以通过一个巧妙的方法来实现。所以，在这个查询中，我们将查找所有作者的名字中都包含J的书籍。如果我们按照可能的方式写这个查询，可能会尝试这样写：`book
    author/author first name contains J`。
- en: Then we'll get books where some author's first name contains J。 To get books
    where all author's first name contains J is more difficult and the way we're going
    to do it is it's kind of a cluge。 We're going to use the built in function count。
    So here's what we're doing in this query。 We're finding all books where the number
    of authors whose first name includes J is the same as the number of authors of
    the book without a condition。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将获取一些作者的名字中包含J的书籍。要获取所有作者的名字中都包含J的书籍则更加困难，我们要做的方法有点像是变通法。我们将使用内建函数count。所以在这个查询中，我们正在查找所有书籍，其中作者的名字包含J的数量与该书的作者总数相等，且没有附加条件。
- en: So specifically under book we count the number of matches of an author's author
    sub element where the built in function。 the built in predicate contains is true
    where the first name contains J。 And so we're counting the number of authors whose
    first name contains J and we're setting that equal to the count of the first name
    sub elements。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在book元素下，我们统计一个作者的author子元素中匹配的数量，其中内建函数contains为真，且该作者的名字包含J。因此，我们在计算名字中包含J的作者数量，并将其设置为与first
    name子元素的数量相等。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_78.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_78.png)'
- en: We'll run the query and we will find indeed that there are two books where all
    of the authors' first name includes J。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行查询，确实找到了两本书，所有这些书的作者名字中都包含J。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_80.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_80.png)'
- en: We can use a related trick to write the query we tried to write earlier but
    failed to find books where all men is an author and whittom is not an author。
    So with the implicit existential what happened before is that we found books where
    there was an author whose name was Omen and then there was an author whose last
    name was not whittom。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个相关的技巧，来编写我们之前尝试但没有成功的查询，目的是查找那些所有作者都是男性且Whittom不是作者的书籍。所以在隐式存在的情况下，之前发生的是我们找到了一个名叫Omen的作者，然后又找到了一个姓氏不是Whittom的作者。
- en: And of course we still got everything back。 What we want to find is books where
    there's a last name that's Omen and where none of the authors had the last name
    of whittom。 That's effectively again a universal quantification or for all。 For
    all of the authors their last name is not whittom。 Since we don't have a for all
    construct and expat where again going to use the count trick。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们依然找回了所有结果。我们真正想找到的是那些有一个姓氏为Omen的作者，并且所有作者的姓氏都不是Whittom的书籍。实际上这又是一个全称量化，或者说是“对所有”。对于所有的作者，他们的姓氏都不是Whittom。由于我们没有“对所有”这种构造，且在Expat中也没有，所以我们将再次使用count技巧。
- en: So in this query we're looking for books where one of the authors' last name
    is Omen and the number of authors using count again。 the number of authors' last
    name is whittom is zero。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这个查询中，我们正在查找那些其中一个作者的姓氏为Omen，且使用count函数来统计作者姓氏为Whittom的数量为零的书籍。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_82.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_82.png)'
- en: So now we've expressed that query， we run it and we get the correct answer。
    That concludes our demonstration of expat。 We've shown a large number of constructs
    and we've written some fairly complicated queries。 On the other hand we certainly
    have not covered the entire expat language。 If you're interested in our many online
    materials we'll also provide data and we encourage you to experiment on your own。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经表达了这个查询，运行后我们得到了正确的答案。这就结束了我们关于Expat的演示。我们展示了许多构造，并且编写了一些相当复杂的查询。另一方面，当然我们也没有覆盖整个Expat语言。如果你对我们的众多在线资料感兴趣，我们也将提供数据，并鼓励你自己进行实验。
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_84.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_84.png)'
- en: '![](img/a3f43e46c606e8e4248c1148c66b1de1_85.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f43e46c606e8e4248c1148c66b1de1_85.png)'
