# P20：11-03-referential-integrity.mp4 - 哈库那玛塔塔i - BV1R4411u7dt

这个视频介绍了一种非常重要的约束类型，叫做参照完整性。作为提醒，数据库中的完整性约束限制了允许的数据范围，超出了数据库结构和数据类型本身所限制的范围。现在，参照完整性这个术语是指数据库中出现的引用的完整性。

在关系型数据库中，一个元组到另一个元组的引用通过指定值来实现。参照完整性规定这些值必须有效。这有点类似于如果我们在数据库中使用指针时，没有悬空指针的情况。我们将看到一些例子。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_1.png)

所以让我们看一下我们用来做所有演示的简单示例数据库，包含学生、大学和申请大学的学生。假设比如我们有一位学生123，他申请了斯坦福大学的某个专业，假设是计算机科学专业，决定为“通过”。当我们有这个元组时。

这里SID字段中的值123可能指的是一位实际学生的值。例如，123可能是学生Mary，拥有某个GPA和高中记录。此外，C名称或大学名称属性中的Stanford值，可能是指大学表中的大学名称。

所以我们应该期望在这里有一个斯坦福的值。这个小的完整性讨论的是这些值如何引用其他表中的相应值。具体来说，如果我们有从关系R的属性A到。

另一个关系S的属性B，这表示关系R中的A列中的每个值必须在关系S的B列中有对应的值。所以，如果我们查看我们的示例，我们会说我们将拥有来自apply表的SID列到学生表的SID列的参照完整性。

我们期望出现在这个列中的每个值在另一个列中也有对应的值。同样，我们将从大学名称属性到大学表中的大学名称属性拥有参照完整性。同样，我们希望每个出现在此列中的值也出现在那一列中。现在我们可能会有一个违规情况，例如，如果我们有一个555申请斯坦福大学的。

一些专业和一些决定，如果我们在学生表中没有555，那么这里就会被视为参照完整性违规。最后，我们可能有123，它是有效的，因为在这里我们有123号学生，但如果123正在申请耶鲁大学，而我们在这里没有耶鲁大学，那么我们同样会有参照完整性违规。

现在让我提到，引用完整性是有方向性的。所以我们谈到这个SID引用学生表中的SID。我们也可以有引用完整性反向的情况，但那是不同的情况。那意味着每个学生必须申请某个地方，每个学生ID的值。

必须出现在申请表中。在这个特定的例子中，我们可能不会这么做。我们可能允许学生还没有申请任何地方，或者允许学院没有人申请的情况。而在这种情况下，引用完整性的最合理方向是从申请到学生，以及从申请到学院。但这也只是其中之一。

如果我们愿意的话，也可以在两个方向上都有外键。现在，来看看关于引用完整性约束的更多细节。引用属性，在这个例子中引用属性是A，通常被称为外键。实际上，引用完整性常常被称为外键约束。

即使在SQL语法中，我们也会看到使用外键这个术语。第二，当我们有一个引用属性，在这个例子中我们谈的是属性B，因此我们有R.A到S.B。引用属性通常要求是其表的主键，或者至少被指定为唯一。这个要求更多的是为了高效实现，而不是别的原因。

但这是SQL标准和大多数系统中的要求。第三，可能存在由多个属性组成的外键，就像键本身可以由多个属性组成一样。例如，在我们的学院关系中，学院名称与州名一起构成主键，而不是单独的学院名称。

如果是这种情况，那么我们的申请表可能会多出一列，指定州名，这样我们就知道学生申请的是哪个学院。在这种情况下，我们会将这两个属性一起作为外键，引用学院表中的学院名称和州名。

我们将在演示中看到多属性外键约束的例子。现在，让我们来讨论如何强制执行引用完整性约束。首先，想想哪些操作可能会违反约束。并不是所有可能的修改都会违反约束。再举个例子，假设我们有R.A引用S.B。

比如在这里，我们有申请表引用学生，申请表引用学院。所以，确实，如果我们向引用关系中插入元组，例如在申请表中插入元组，这可能会违反引用完整性。如果SID或C name的值在引用关系中没有匹配的值。

反过来说，如果我们从引用关系中删除数据，例如删除某个学生，那么这可能会导致违反约束。比如说我们有值1 2 3，这个值在应用记录中引用了它，一旦这个元组被删除，引用1 2 3的记录就会成为一个悬空指针。当然，如果我们更新引用的值，任何一个列的更新都有可能导致违反约束。

如果新值在参考表中不存在，或者我们更新了被引用的值，这也可能导致违反约束。在SQL标准中，以及所有实现中，如果我们向引用表插入数据或更新引用表的数据，导致违反引用完整性约束，那么会生成一个错误，并且该修改会被禁止。

就像违反其他类型的约束一样，修改是被禁止的。然而，对于参考表，如表S，或者在我们的案例中是表student和表college，如果有违反约束的修改，如果引用完整性最初是使用一些特殊选项定义的，那么数据库系统是可能允许的。

自动修改引用表，以确保约束不被违反。让我们更详细地讨论一下这个问题。首先讨论从被引用表中删除数据。假设我们有学生编号1 2 3，可能在几个地方都有该学生的记录，然后我们在学生表中也有学生编号1 2 3。

目前引用完整性是好的，一切正常，但假设我们删除了编号为1 2 3的元组。实际上，依赖于我们最初设置引用完整性约束的方式，可能会发生三种不同的情况。默认行为叫做“restrict”，这实际上是一个关键字。

默认情况下，如果我们对参考表进行删除操作并导致约束违反，那么我们会生成一个错误，就像我之前说的那样，修改会被禁止。另有两个选项稍微有点不同。其中一个叫做“set null”，它的意思是如果我们删除参考表中的某个元组。

如果我们没有生成错误，而是把引用元组（在这个案例中是这两个带有1 2 3的元组）的SID去掉，并且用null替代这些SID，这在引用完整性角度上是被认为可以接受的，外键列中可以存在null值，这将自动发生。

第三种可能性被称为级联删除（cascade）。让我们设置一些数据，假设我们有两个三四，申请了斯坦福大学，斯坦福大学在这里。现在假设我们再次删除这个元组，那么这将导致一个引用完整性约束的违反，涉及到斯坦福值。

所以级联在删除操作中的含义是，如果我们删除了这个元组，那么我们将简单地删除所有有引用值的元组。因此，这个元组也会被删除。之所以叫级联，是因为有时候你可以设置一个完整的引用完整性约束链，所以我们在这里有apply表引用college表。

但也许我们有其他表格引用了apply表，甚至还有其他表格引用了这个表。如果我们从college表删除了一个元组，导致我们从apply表删除一个元组，如果这里有一个引用该元组的元组，我们可能会在这里进行删除，然后继续删除，依此类推。通常，级联更新只会进行一步，但我们将在演示中看到一个例子，它会。

设置一个级联更新，它会传播到某个距离。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_3.png)

现在，更新有类似的三种选项。让我们清空这些内容，重新设置一些示例数据。假设我们有学生一二三申请了斯坦福大学，我们这里有一二三。如果我们尝试更新这个一二三为四五六，restrict命令会说这是不允许的，因为这样会。

留下一个悬挂指针，并生成一个错误。set null命令类似于删除，如果这个值被更改为四五六，任何一二三的值都会被设置为null。所以在这种情况下，我们将学生表中的一二三更改为四五六，然后这里的一二三将被更改为null。最有趣的情况可能是更新的级联情况。

它说，如果我们更新一个引用值，那么我们也会更新所有引用该值的地方。所以假设我们这里有斯坦福大学，实际上我们必须保证引用完整性约束是正确的。现在假设有人过来，说我认为斯坦福拼写错了，应该是Stanford，其实这就是。

斯坦福常见的拼写错误，第一个拼写是正确的，但是如果有人做了这个更改，如果我们在引用完整性约束中设置了级联选项，适用于apply C name和college C name之间，那么这个更新会传播到所有引用值的地方。所以在这种情况下，自动更新apply表中所有的Stanford。

到斯坦福。现在让我们看看引用完整性是如何实际运作的。我们创建我们的三个表，创建college表，以college name作为主键；创建student表，以student ID作为主键，这样我们就可以在apply表中引用这两个属性，确保引用完整性约束。

当我们创建申请表时，我们将指定属性和关键字。`references`表示我们正在为学生表中的学生 ID 属性设置一个引用完整性约束，类似地，我们将声明学院名称属性，设置一个引用完整性约束指向学院表的学院名称属性。

我们将继续创建这些表格。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_5.png)

现在让我们尝试填充我们的表格。如果我们犯了个错误，尝试先插入申请记录，但学生表或学院表没有数据，那么当我们尝试插入例如学生 123 申请斯坦福时，我们会遇到引用完整性违规，因为没有学生 123，也没有学院斯坦福，同样，学生 234 申请伯克利时也是如此。

所以我们看到错误，接下来我们需要做的是首先插入学生的元组，然后插入学院的元组，最后插入申请的元组。所以我们先插入两个学生，123 和 234，以及两个学院，斯坦福和伯克利。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_7.png)

这样做没问题，现在我们继续插入申请的元组。这次一切应该都能正常工作，确实如此。除了插入引用表，我们还需要关注更新操作。所以作为提醒，让我们来看一下我们已经有的学生。

我们有学生 123 和 234，并且在申请表中，学生 123 和 234 各自申请了一所学院。现在我们将更新学生 ID 为 123 的申请记录。第一次更新尝试将学生 ID 设置为 345，但会出现引用完整性违规，因为没有学生 ID 为 345。第二次更新将会更成功。

它将更新学生 ID 为 234 的申请记录。我们将执行这些更新操作，并看到第二个更新操作成功了。到目前为止，我们查看了对引用表的修改，但我们也需要关注对被引用表的修改。在我们的例子中，指的就是学生表和学院表。

例如，假设我们尝试从学院表中删除学院名称为斯坦福的记录。如果我们试图删除该元组，我们将得到一个错误，因为我们确实有一个申请记录，其中包含斯坦福的值，并且因此引用了我们试图删除的元组。同样，我们也可以尝试删除一些学生的元组。

让我们回过头来看一下我们的申请关系，现在我们看到在申请表中的学生 ID 都是 234。所以删除学生 ID 为 123 的记录应该没问题，因为没有任何记录引用它，但删除学生 ID 为 234 的记录就不行，实际上，当我们运行命令时，我们看到第一个删除操作生成了错误。

第二个更新操作成功了。那么更新引用表呢？

假设我们决定将伯克利大学改名为伯瑟克利大学。我们尝试更新该学院名称，但当我们运行命令时，会遇到一个错误，因为我们确实有一个应用元组正在引用名为伯克利的值。最后，虽然我们一直在讨论数据级别的修改，但参照完整性依然重要。

约束还对删除表格施加了限制。例如，如果我们尝试删除学生表格，我们将再次遇到参照完整性约束，因为那样会导致应用表中引用不存在的数据，而该表现在已经不存在。你可以看到错误信息提示：无法删除学生表格，因为其他对象正在依赖它。

当前正在依赖该数据。因此，当我们设置参照完整性约束时，如果我们想删除表格，我们必须先删除应用表，然后再删除被引用的表格。现在，我们将设置应用表，来实验一些自动机制，处理参照完整性违规情况。具体来说，我们仍然保持学生 ID 到学院表的相同参照完整性约束。

学生表和学院名称到学院表的参照完整性约束，而对于学生 ID 的参照完整性约束，我们将指定，如果删除一个学生，则将任何引用该学生 ID 的值设为 null，我们使用“on delete”关键字来指定删除操作的行为。该选项告诉我们，当对被引用的表进行删除时，我们应使用“set null”选项。

对于学院名称的引用，我们将指定，如果在学院表中更新了学院名称，且该表上有更新操作，我们将使用级联选项。作为提醒，更新操作的含义是，如果我们更改了学院名称，则会将这一更改传播到所有在应用表中引用该名称的学院。

我本可以指定更多选项。我本可以为学生 ID 和学院名称分别指定“on update”选项和“on delete”选项。因此，理论上可以有四个选项。如果我省略了这些选项，它们将使用默认的限制选项，该选项表示，如果执行了会引发参照完整性违规的修改，则会产生错误，并且该修改不会执行。

就像我们在之前的例子中看到的那样，操作不会执行。所以让我们先创建表格，然后进行一些修改实验。我们先开始向学生表中添加更多学生。如果我们查看，我们的应用表现在是空的，因为我们刚刚创建了它。

我们的学院表中有斯坦福大学和伯克利大学，而我们的学生表现在有三个元组。学生 ID 分别是 1, 2, 3，2, 3, 4 和 2, 3, 5。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_9.png)

我们将向申请表插入五个元组，并且所有元组都将符合引用完整性约束。我们只会插入学生一二三、二三四、三四五，他们只能申请斯坦福或伯克利。所以我们已经插入了这些值，现在我们将进行一些修改，看看会发生什么。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_11.png)

我们将从学生表中删除所有ID大于200的学生。回头看那个表，我们会看到学生二三四和三四五将被删除。现在记住，我们已经指定了“删除时设置为null”的应用表的引用完整性约束。具体来说，当我们查看应用表时，关于这些学生的引用将会是。

删除的记录应该在我们执行更新时自动设置为null，并且在我们执行删除命令时也是如此。我们将继续进行删除操作。刷新后，我们查看申请表，发现这些值并没有被设置为null。如果我们查看学生表，我们将看到只剩下。

学生一二三离开了。现在让我们测试一下级联更新。作为提醒，当我们设置大学名称的引用完整性约束时，我们提到过，如果我们更新大学表中的大学名称，我们应该使用级联将这些更新传播到申请表中的所有引用。

所以我们再次尝试将伯克利的名称改为“berserkley”，这次它应该允许我们这样做，并且应该将所有指向伯克利的申请更新为“berserkley”。我们将继续执行命令，查看申请表，并且一刷新，我们就会看到伯克利已经变更为berserkley。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_13.png)

这个例子相当复杂，它将展示我们在之前的例子中没有看到的一些功能。我们将使用一个简单的表T，只有三个属性A、B和C，并且我们将说A和B一起是该表的主键。在这个例子中，我们将演示表内引用完整性。

所以，表内引用完整性。我们将演示涉及多个属性外键和主键的引用完整性，并且我们将演示一个真正的级联操作，其中包括级联删除，这将传播到多个元组。因此，引用完整性通常意味着有一个引用表，然后。

引用值存在于不同的表中，但在单个表内实现引用完整性并没有问题。例如，在一个属性的情况下，我可能有属性B，其中B中的每个值必须出现在A的值中，这就会是一个表内的引用完整性约束。在这种情况下，事情稍微复杂一些，因为我使用的是属性对。

我的引用完整性约束。具体来说，我将让属性B和C一起引用属性A和B。语法上，要在表定义中声明多属性的引用完整性约束，我必须将其放在最后，因为我不能像声明多属性键那样，将其附加到单个属性上，正如这里也展示的那样。

语法是在表定义的末尾，我声明将使用外键约束，并且属性B和C一起具有引用完整性约束，引用同一表中的属性A和B。然后我将指定“删除级联”选项。意味着如果我删除一个元组，如果删除某个元组，那么任何其他引用该元组的元组也会被删除。

该元组的AB值及其BC值将被自动删除。所以让我们创建表格，插入数据，然后看看表格。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_15.png)

并预测当我们实际删除一个元组时会发生什么。以下是插入操作后表T的内容。我们可以看到A和B组合在一起确实构成了一个键，所有的AB组合都是唯一的，此外，每个BC组合在同一个表中都有相应的AB值。

所以除了第一个元组外，每个BC组合都会引用前一个元组的AB组合。因此，这里有1 1引用表1中的1 1，或2 1引用元组2中的2 1，依此类推。所以我们表中的引用完整性约束保持完好。接下来，我们将通过运行一个命令来删除第一个元组。

这表示删除A值为1的元组。当我们删除元组1时，因为我们已经设置了级联删除，我们将需要删除任何引用1 1的元组。所以将是元组2。所以在删除元组1之后，引用完整性约束的执行将删除元组2。当元组2被删除时，2 1的值将消失，因此引用元组2的元组3也会被删除。

然后元组4（引用3的元组）将被删除，以此类推，直到整个表为空。所以这是我们删除第一个元组的删除命令。我们运行命令后，返回查看表格，刷新后我们会看到表格确实为空。这样，我们就完成了引用完整性约束的演示。

引用完整性在关系数据库的部署中其实是非常常见的。设计关系模式的自然方式通常是一个表的列中的值引用另一个表的列中的值，通过设置引用完整性约束，系统本身会监控数据库，确保其始终保持一致性。

![](img/c5ce711d5929e2bef0a7f5441f6e5ab4_17.png)
