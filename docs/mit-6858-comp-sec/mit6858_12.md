# TCP/IP 安全

**注意：** 这些讲座笔记略有修改，来自 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的内容。

## 网络安全的威胁模型

+   对手可以拦截/修改网络流量。

+   对手可以发送数据包。

+   对手完全控制自己的机器。

+   对手可以参与协议（通常）。

    +   通常不可行将坏人排除在大型系统之外。

窃听数据包。

+   重要的是要记住，但相对来说已经被很好地理解。

+   通过网络发送的任何数据都可以被对手观察。

发送/伪造数据包。

+   IP 允许发送方构造任意数据包。

+   特别是，发送方可以填写任何源地址。

+   可以假装数据包来自任何地址。

+   对手可以利用这个做什么？

## 回顾一下"TCP/IP 协议套件中的安全问题"

[论文在这里](http://css.csail.mit.edu/6.858/2014/readings/lookback-tcpip.pdf)

+   易受攻击：触发某些实现中的错误。

+   作者对这类问题不太感兴趣。

+   相反，希望看看**"协议级问题"**。

+   什么是协议级问题？

    +   设计固有的问题。

    +   正确的实现会有这个问题。

+   为什么这么重要？

    +   可以修复实现中的错误。

    +   要修复协议级错误，可能需要更改协议！

        +   可能与现有系统不兼容。

        +   （正如我们将看到的，有时可能提出兼容的修复方法。）

## TCP 序列号攻击

+   标准握手（第 2 页右侧的图）：

    +   `C: 源=C, 目的=S, SYN(SNc)`

    +   `S: 源=S, 目的=C, SYN(SNs), ACK(SNc)`

    +   `C: 源=C, 目的=S, ACK(SNs)`

    +   `C: 源=C, 目的=S, 数据(SNc), ACK(SNs)`

+   对手如何知道数据来自客户端？

    +   只有客户端应该能够接收第二条消息。

    +   因此，**只有客户端应该知道序列号**。

    +   第三条消息将被拒绝，除非具有正确的 SNs 值。

+   假设对手 A 想要模拟从 C 到 S 的连接。（假设 A 知道 C 的 IP 地址--在实践中通常不是大问题。）

    +   `A: 源=C, 目的=S, SYN(SNc)`

    +   `S: 源=S, 目的=C, SYN(SNs), ACK(SNc)` -- 但这将发送到 C，而不是 A

    +   `A: 源=C, 目的=S, ACK(SNs)` -- 但如何猜测 SNs？

    +   `A: 源=C, 目的=S, 数据(SNc)`

+   对手从哪里获取 SNs？

    +   TCP 规范建议了一种选择它们的特定方式。

    +   特别是，以大约恒定的速率增加：每秒约 250,000 个。

    +   为什么这么具体？

        +   与重用连接（源/目的端口号）的微妙交互。

        +   希望避免旧数据包（来自过去的连接）干扰新连接。

        +   参考：RFC 1185 附录

    +   如果对手知道最近的序列号，就可以猜测下一个序列号。

        +   实现实际上会每秒增加 ISN，使其易于猜测。

+   S 发送给 C 的真实数据包发生了什么（第二个数据包）？

    +   C 会假设数据包来自旧连接，发送`RST`作为响应。

    +   即使发送了`RST`，对手也可以在`RST`到达之前尝试竞争。

    +   幸运的是，还有另一个奇怪的错误；稍后会讨论。

+   但是为什么序列号攻击会变成安全问题？

### 1. 伪造依赖 IP 地址的应用程序的连接

+   例如，伯克利远程访问工具：rlogin、rsh、rcp。

+   如果连接来自“受信任”系统，则允许无密码登录。

    +   要求连接来自受信任的源端口（512-1023）。

        +   为什么有这个要求？

    +   受信任的 rlogin/rsh/rcp 程序发送客户端的用户名。

    +   如果用户名与服务器上的帐户相同，则无需密码。

    +   例如："rsh athena.dialup.mit.edu ls"。

+   对 TCP 层提供的内容做出了错误的假设。

    +   *假设来自 IP 地址的 TCP 连接意味着它确实来自该主机。*

+   如果对手可以猜测 SN，则可以模拟来自受信任主机的连接。

    +   使用 rsh 发出任何命令。

    +   可以更改用户的.rhosts 文件以允许从攻击者主机登录。

    +   然后直接连接，而无需模拟连接。

+   基于主机的身份验证似乎是一个糟糕的计划。

    +   特别是依赖于主机上的“受信任”与“不受信任”端口。

    +   今天仍在使用：例如，用于传出邮件的 SMTP。

+   实际上，rlogin 身份验证甚至更糟：他们通过主机名进行身份验证。

    +   主机名从哪里来？反向 DNS 查找。

    +   例如，18.26.4.9：查找 9.4.26.18.in-addr.arpa 的 PTR 记录。

    +   该域的所有者可以将 PTR 记录设置为任何主机名！

        +   （可以稍微改进：检查主机是否解析为相同的地址。）

    +   类似的问题出现在日志文件中：记录解析（不受信任）主机名。

### 2. 拒绝服务攻击：连接重置

+   一旦我们知道 SNc，就可以发送一个 RST 数据包。

+   更糟糕的是：服务器将接受任何在窗口内的 SNc 值的 RST 数据包。

+   具有大窗口（~32K=2¹⁵）时，只需要 2³²/2¹⁵ = 2¹⁷ 次猜测。

连接重置有多糟糕？

+   此类攻击的一个目标是 BGP 路由器之间的 TCP 连接。

+   导致路由器假定链路故障，可能会影响几分钟的流量。

+   解决方案：

    +   TTL 黑客（255）：通过在 TCP 数据包中设置`TTL = 1`，确保 BGP 节点只与直接邻居通信

    +   MD5 头部身份验证（非常专门用于路由器之间的链接）。

### 3. 劫持现有连接

+   类似地，还可以向现有连接中注入数据。

+   对手只需要知道当前的 SNc。

如何缓解这个问题？

+   基线：不要依赖 IP 地址进行身份验证。

    +   在更高级别使用加密/身份验证。

    +   下一讲：Kerberos。

    +   但是，我们仍然希望为 TCP 解决当前的情况。

+   ISP 可以过滤其客户发送的数据包。

    +   今天经常为小客户执行，但不一致。

    +   对于具有复杂网络、多重主机等的客户来说并不直接。

如何修补 TCP？

+   不能以完全随机的方式选择 ISN，而不违反 TCP 规范。

    +   可能会破坏连接（端口）重用的保证。

    +   ISN 是 32 位，意味着在约 2¹⁶ = 65,000 个连接后，您可能会发生冲突并重用与旧连接匹配的 ISN。

        +   旧连接的数据包可能被解释为新连接的一部分

    +   因此，最好 ISNs *递增* 以环绕方式递增，以使碰撞变得不太可能。

+   随机增量？

    +   应保留增量速率（~250k/秒）。

    +   没有大量的随机性（比如，每次增加低 8 位）。

+   旁注：必须小心我们如何生成随机数！

    +   常见 PRNG：线性同余生成器：`R_k = A*R_{k-1}+B mod N`。

    +   不安全：给定一个伪随机值，可以猜测下一个！

    +   有许多更好的密码学安全 PRNG 可用。

        +   理想情况下，使用内核内置的 PRNG（/dev/random，/dev/urandom）

        +   参考：http://en.wikipedia.org/wiki/Fortuna_(PRNG)，或任何流密码，如 http://en.wikipedia.org/wiki/RC4

+   然而，不同的源/目的地对的 SN 值永远不会相互作用！

+   因此，可以为每个源/目的地对选择使用随机偏移量来选择 ISN。

    +   不错的技巧：`ISN = ISN_oldstyle + F(srcip, srcport, dstip, dstport, secret)`

    +   `F`是某个伪随机函数；大致上，可以认为是 SHA1。

    +   不需要额外的状态来跟踪每个连接的 ISNs。

序列号攻击仍然相关吗？

+   大多数操作系统实现了上述每个连接 ISN 的解决方法。

    +   参考：Linux `secure_tcp_sequence_number` in `net/core/secure_seq.c`

+   但其他协议遭受几乎相同的问题--例如，DNS。

    +   DNS 在 UDP 上运行，没有序列号，只有端口，目的端口固定（53）。

    +   如果对手知道客户端正在进行查询，可以伪造响应。

        +   只需要猜测 src 端口，通常是可预测的。

    +   问题在 2008 年变得流行，尽管在此之前 djb 已经很好地理解了。

        +   参考：http://cr.yp.to/djbdns/forgery.html

        +   参考：http://unixwiz.net/techtips/iguide-kaminsky-dns-vuln.html

    +   解决方案：仔细利用所有可能的随机性！

        +   DNS 查询包含 16 位查询 ID，并且可以随机化约 16 位 src 端口。

    +   解决方案：部署 DNSSEC（签名的 DNS 记录，包括缺失记录）。

        +   一个问题：密钥分发（谁被允许为每个域签名？）

        +   另一个问题：名称枚举（以签署“没有这样的名称”响应）。

        +   部分通过 NSEC3 缓解：http://tools.ietf.org/html/rfc5155

        +   采用缓慢，没有太多升级的动力，非微不足道的成本。

        +   成本包括性能和管理（密钥/证书管理）。

## SYN 洪水攻击

+   请注意，服务器在接收到 SYN 数据包时必须存储一些状态。

    +   它需要存储发送给该客户端的`SN_s`序列号

    +   被称为半开放连接：回复了 SYN-ACK，等待 ACK。

+   如果它从许多来源接收到 SYN 消息会怎样？

    +   许多实现尝试为所有半开放连接保留状态。

    +   但最终会耗尽内存，必须拒绝连接！

+   恼人的问题：我们甚至不知道我们为谁保留状态！

    +   对手可能有一个单一主机，并从许多 src IP 生成 SYN。

+   拒绝服务攻击：客户端+服务器资源之间存在巨大的不对称性。

    +   客户端伪造一个单个数据包（少于 1 毫秒）。

    +   服务器会浪费内存直到连接超时（几分钟）。

防御 SYN 洪水攻击：SYN cookies。

+   **思路：** 使服务器无状态，直到收到第三个数据包（ACK）。

+   这为什么很棘手？

    +   需要确保对手无法从任何源地址捏造一个连接。

    +   以前，这是通过存储 ISNs 并期望在 ACK 中收到来实现的。

+   使用一点密码学来实现类似的目标。

+   将服务器端状态编码到序列号中。

    +   ISNs = `MAC_k（源/目的地址+端口，时间戳）|| 时间戳`

    +   时间戳是粗粒度的（例如，分钟）。

    +   服务器存储秘钥`k`，不与其他人共享。

        +   详细参考：http://cr.yp.to/syncookies.html

+   当发送 SYN-ACK 响应时，服务器计算如上述的序列号。

+   服务器可以通过验证 ACK 的序列上的哈希（MAC）来验证状态是否完整。

    +   不太理想：需要考虑时间戳内的重放攻击。

+   另一个问题：如果第三个数据包丢失，没有人会重传。

    +   只有在服务器先发言的协议中才会有问题。

    +   因为服务器不再保留连接状态，所以它不知道有一个*悬挂连接*，所以在等待客户端的 ACK 太久后，它永远不会重新传输其 SYN 消息给客户端。

    +   同样，客户端不会知道其 ACK 数据包丢失了（它从未被 ACK 回来，而且由于客户端正在等待服务器发送第一个消息（假设），客户端也不会发送任何其他数据）。 

    +   在 DoS 攻击的情况下可能不是一个大问题。

另一个 DoS 攻击向量：带宽放大。

+   向网络的广播地址发送 ICMP 回显请求（ping）数据包。

    +   例如，18.26.7.255。

    +   以前，你会从网络上的所有机器收到 ICMP 回显回复。

    +   如果你伪造一个来自受害者地址的数据包怎么办？受害者会收到所有回复。

    +   在一个快速网络上找到一个有 100 台机器的子网：100 倍放大！

        +   参考：http://en.wikipedia.org/wiki/Smurf_attack

+   我们能修复这个问题吗？

    +   路由器现在阻止“定向广播”（发送到广播地址的数据包）。

+   现代变种：DNS 放大。

    +   DNS 也是一个请求-响应服务。

    +   服务器可能会用一个小查询发送回一个大响应。

    +   使用 DNSSEC，响应包含大量签名，所以它们甚至更大！

    +   由于 DNS 运行在 UDP 上，源地址完全未经验证。

        +   参考：http://blog.cloudflare.com/deep-inside-a-dns-amplification-ddos-attack

+   我们能修复 DNS 攻击吗？

    +   实际上相当困难！根域名服务器必须回答任何人的查询。

+   如果我们有机会从头开始重新设计 DNS 会怎样？

    +   一个可能的计划：查询必须和响应一样大（需要填充）。

    +   一般技术：迫使客户端至少花费同样多的工作。

TCP 拥塞控制。

+   接收方可以通过 ACK 未接收的段来促使发送方加速。

+   或者发送更多的 ACK（例如，每个字节发送一个 ACK 而不是每个数据包）。

路由协议：对参与者过于信任。

+   ARP：在单个以太网网络内。

    +   要发送 IP 数据包，需要路由器/下一跳的以太网 MAC 地址。

    +   地址解析协议（ARP）：广播一个请求目标 MAC 地址的请求。

    +   任何人都可以监听广播，发送回复；没有认证。

    +   对手可以冒充路由器，拦截数据包，甚至在交换网络上。

    +   潜在解决方案：让交换机负责 ARP。

        +   没有广泛部署：需要仔细管理 MAC/IP 地址。

+   DHCP：同样，在一个以太网网络中。

    +   客户端通过发送广播请求来请求 IP 地址。

    +   服务器响应，没有认证（一些规范存在但并不广泛使用）。

        +   如果你刚刚插入一个网络，可能不知道会发生什么。

    +   很多字段：IP 地址，路由器地址，DNS 服务器，DNS 域列表，..

    +   对手可以冒充网络上的新客户端的 DHCP 服务器。

        +   可以选择他们的 DNS 服务器，DNS 域，路由器等。

    +   同样，对服务器的 DoS 攻击：请求大量租约，来自许多 MAC 地址。

    +   解决方案：让交换机负责 DHCP（将请求转发给真实服务器）。

        +   没有广泛部署：需要仔细的交换机配置。

        +   在无线网络上更加复杂。

+   BGP：全球范围内（类似于论文中描述的 RIP 攻击）。

    +   任何 BGP 参与者路由器都可以宣布到一个前缀的路由。

    +   如果对手有一个路由器怎么办？可以宣布任何前缀或路由。

    +   这个问题还有意义吗？

        +   垃圾邮件发送者经常利用这一点：宣布一个未使用的地址，并发送垃圾邮件。

        +   绕过 IP 级别的垃圾邮件发送者黑名单：选择几乎任何 IP！

    +   如何解决？

        +   SBGP：对路由公告进行加密签名。

        +   必须知道谁被允许宣布每个特定的 IP 前缀。

        +   需要有人为每个 IP 前缀分发密钥/证书。

        +   引导问题很棘手；也会有一些性能开销。

        +   有些进展，但仍未广泛部署。

还有许多其他问题。

+   像重定向这样的 ICMP 消息：没有认证，基本上现在不再使用。

+   暴露太多信息（netstat，SNMP，finger）：大部分已修复。identd（“认证服务”）：设计不佳，没有真正的认证。

+   电子邮件：真正的问题，但目前没有实际解决方案。

    +   认证与授权。

    +   例如，PGP 无法解决垃圾邮件问题。

+   协议中的密码：仅支持密码并不是很好。

    +   我们将在几周后讨论替代方案。

+   FTP 数据传输协议。

    +   服务器连接回客户端以向客户端发送文件。

    +   客户端告诉服务器要使用的 IP 地址和端口号。

    +   可以用来从服务器的 IP 进行端口扫描。

    +   可以用来从服务器的 IP 发送任何流量（嵌入文件中）。

        +   例如，回到 IP 认证问题：rlogin，垃圾邮件等。

对手如何知道你正在运行什么软件/协议？

+   探测：

    +   检查系统是否在一个众所周知的端口上监听。

    +   协议/系统通常会发送初始的横幅消息。

    +   nmap 可以通过测量各种实现特定的细节来猜测操作系统。

        +   参考：http://nmap.org/book/man-os-detection.html

+   使用 DNS 查找 IP 地址的主机名；可能会给出一些提示。

+   猜测：假设系统存在漏洞，尝试利用漏洞。

对手如何知道要攻击的系统的 IP 地址？

+   使用 traceroute 查找沿途的路由器，用于 BGP 攻击。

+   也可以扫描整个互联网：只有 2³² 个地址。

    +   1 Gbps（100 MB/s）的网络链路，64 字节最小数据包。

    +   每秒约 1.5 百万个数据包。

    +   `2³² = 40 亿`个数据包在约 2500 秒内，或 45 分钟内。

    +   [zmap](https://zmap.io/)：这个的实现

为什么 TCP/IP 层的安全性如此不足？

+   从历史上看，设计者并没有太担心安全性。

    +   即使 Bellovin 也说：“1989 年的互联网是一个更友好的地方”。

    +   最初的互联网有一小部分相对可信赖的用户。

    +   设计要求随时间改变。

+   端到端论点在实践中发挥作用。

    +   无论如何必须在应用层提供安全性。

    +   在传输层上的事情足够“好”，可以让应用程序正常工作。

+   一些修复确实被添加，但仅针对最严重的问题/更容易的解决方案。

如何提高安全性？

+   对 TCP 实现的协议兼容修复。

+   防火墙。

    +   部分修复，但被广泛使用。

    +   问题：对手可能在防火墙网络内。

    +   问题：很难确定数据包是否“恶意”。

    +   问题：即使对于存在的字段（源/目的地），也很难进行身份验证。

    +   TCP/IP 的设计与防火墙过滤技术不太匹配。

    +   例如，IP 数据包分段：TCP 端口在一个数据包中，有效载荷在另一个数据包中。

+   在 TCP/IP 之上实现安全性：SSL/TLS，Kerberos，SSH 等。

    +   注意：这篇论文在加密与认证方面并不清晰。

    +   下一讲将更详细地讨论 Kerberos。

+   使用密码学（加密、签名、MAC 等）。

    +   这是一个相当困难的问题：协议设计，密钥分发，信任等。

+   有些安全性很难在顶层提供：DoS 抵抗，路由。

+   部署替代协议：SBGP，DNSSEC。
