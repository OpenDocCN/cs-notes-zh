# Tor

**注意：** 这些讲座笔记是从 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的笔记中稍作修改的。

## 论文的目标是什么（或 Tor 的目标是什么）？

+   为了客户端的匿名性，他们想要连接到互联网上的服务器。

+   对于希望为用户提供服务的服务器的匿名性。

+   什么是匿名性？

    +   对手无法确定哪些用户正在与哪些服务器通信。

    +   对手（最有可能）知道用户，服务器是通过 Tor 进行通信的。

    +   换句话说，Tor 并不是为了防止对手找到 Tor 用户而设计的。

## 如何实现匿名性？

+   必须加密要匿名的人的流量。

    +   否则，对手会查看数据包并弄清楚发生了什么。

+   但加密并不足够：仍然可以追踪加密数据包的去向。

+   将一个用户的流量与其他用户的流量混合（或“掩盖流量”）。

    +   一个用户的匿名性需要有许多其他像第一个用户一样的用户。

    +   如果所有其他用户只运行 BitTorrent，那么维基百科用户很容易被发现。

    +   如果所有其他用户使用 Firefox，那么 Chrome 用户很容易被发现。

    +   ...

+   对手将无法确定哪个用户发起了什么连接。

+   混合组件必须更改数据包（例如，加密/解密）。

    +   否则，可以查找相同数据包稍后出现的位置。

+   因此，方法是：通过加密/解密的中间人中继流量。

## 为什么我们需要多个节点？

+   可扩展性：处理比单个节点更多的流量。

+   妥协：攻击者了解有关受损节点的直接客户端的信息。

    +   有许多独立节点，这只影响了一小部分流量。

    +   使用洋葱路由，攻击者必须妥协链中的所有节点。

+   流量分析：攻击者可以相关联传入/传出的流量。

    +   可以查看数据包之间的时间间隔或数据包的数量。

    +   链接使时间/数据量分析攻击更难实施。

+   攻击者仍然能够成功吗？

    +   是的，如果他们观察或者妥协足够多的节点。

    +   例如，可能足以观察第一个和最后一个节点。

    +   攻击者还可以注入时间信息（通过延迟数据包）进行分析。

## 主要思想：洋葱路由

+   网络中的洋葱路由器（ORs）的网格。

+   假设：客户端知道所有 ORs 的公钥。

+   客户端选择通过这个网络的某条路径。

+   洋葱路由的天真草人（不完全是 Tor）：

    +   客户端依次在路径中的每个 OR 的公钥中加密消息。

    +   将消息发送到路径中的第一个 OR，该 OR 解密并中继，依此类推。

    +   “出口节点”（路径中的最后一个 OR）将数据发送到真实网络中。

+   为什么这是一个好的设计？

    +   每个 OR 都知道前一个和下一个跳跃，而不知道最终源或目的地。

    +   通过两个 ORs，妥协一个 OR 并不会破坏匿名性。

## 在哪个级别应该中继事物？

+   可以在任何级别进行--IP 数据包，TCP 连接，应用级别（HTTP）

+   优势/劣势是什么？

    +   低级别（IP）：更一般，更少的应用程序更改，适用于更多应用程序。

    +   更高级别（TCP，HTTP）：更高效（单个 TCP 帧的开销，而不是存储单个 TCP 帧的多个 IP 帧的开销），更匿名。

+   Tor 做了什么？

    +   使用 SOCKS 进行 TCP 级中继，拦截 libc 调用。

    +   效率的例子：不需要 TCP 流量控制，Tor 进行重传

    +   丢失通用性的例子：UDP 无法工作，无法进行路由跟踪，..

    +   Tor 如何处理 DNS，如果不支持 UDP？

        +   SOCKS 可以捕获目的地的主机名，而不仅仅是 IP 地址

        +   出口节点执行 DNS 查找，建立 TCP 连接

+   丢失在较低层的匿名性的例子？

    +   如果我们使用 IP，将泄漏大量 TCP 信息（序列号，时间戳）

    +   如果我们使用 TCP，将泄漏各种 HTTP 头和 cookie。

    +   如果我们使用 HTTP，可以通过 Javascript，Flash 等违反匿名性。

        +   Javascript 环境中有许多可识别的特征。

        +   浏览器版本，历史嗅探，本地网络地址/服务器..

    +   “协议规范化”：在更高级别协议中修复所有自由度。

        +   在实践中很难做到；特定于应用程序的代理很有用（例如，Privoxy）。

        +   浏览器“识别”的演示：https://panopticlick.eff.org/

## Tor 设计

+   OR 的网格：每个 OR 通过 SSL/TLS 连接到其他每个 OR。

    +   不需要 CA 签名的 SSL/TLS 证书。

    +   Tor 有自己的公钥检查计划，使用目录服务器。

    +   OR 主要由志愿者运行：例如，MIT 运行几个。

+   终端用户运行实现 SOCKS 的洋葱代理（OP）。

+   OR 有两个公钥：身份密钥和洋葱密钥。

+   身份密钥在目录中注册，签署 OR 状态。

+   Onion 密钥由 OP 用于连接 OR，建立电路。

    +   客户端从目录下载 OR 列表。

    +   选择一系列 OR 形成电路，依次联系每个 OR。

+   客户端建立电路是昂贵的。- 为什么要这样做？

    +   任何单个服务器可能被 compromise，无法信任它。

    +   无法避免信任客户端机器。

+   为什么我们需要洋葱密钥以及身份密钥？

    +   可能能够保护身份密钥免受长期损害。

    +   每个 OR 使用身份密钥签署其当前的洋葱密钥。

+   Tor 为什么需要目录？

    +   需要有人批准 OR。

        +   否则攻击者可以创建许多 OR，监视流量。

    +   目录是否会损害匿名性？

        +   不，不需要在线查询。

    +   如果一个目录被 compromise 了怎么办？

        +   客户端需要大多数目录同意。

    +   如果许多目录被 compromise 了怎么办？

        +   攻击者可以注入许多 OR，监视流量。

    +   如果目录不同步怎么办？

        +   攻击者可能根据目录信息缩小用户身份范围。

        +   看到一组目录消息的用户将使用特定的 OR。

### 术语：电路和流。

+   电路：客户端建立的通过 OR 列表的路径。

    +   电路存在一段时间（也许几分钟）。

    +   定期打开新的电路以防止攻击。

+   流实际上是一个 TCP 连接。

    +   许多流在同一电路上运行（每个具有单独的流 ID）。

    +   流是一个重要的优化：无需重建电路。

+   Tor 为什么需要电路？

+   如果电路存在时间很长会出现什么问题？

    +   对手可能将多个流关联到一个电路中。

    +   将单个用户的连接与不同站点联系起来，破坏匿名性。

### Tor 电路

+   电路是 OR 序列，以及共享的（对称 AES）密钥。

    +   ORs `c_1, c_2, .., c_n`

    +   键 `k_1, k_2, .., k_n`

+   单元格格式：

    +   `+---------+---------------+-----------+`

    +   `| 电路 | 控制/中继 | - 数据 |`

    +   `+---------+---------------+-----------+`

    +   `2 字节 + 1 字节 + 509 字节`

+   将"Circuit"和"Control/Relay"字段视为链路层头部。

    +   电路 ID 是每对 OR 之间的。

    +   用于在 OR 之间的同一 TLS 连接上多路复用许多电路。

    +   控制消息是"链路本地的"：仅发送给直接邻居。

    +   中继消息是"端到端的"：沿着电路中继。

+   为什么所有流量都是固定大小的单元格？

    +   使流量分析更加困难。

+   控制命令是什么？

    +   填充：保持活动或链路填充。

    +   create/created/destroy：创建和销毁电路。

+   中继数据包中有哪些中继命令（DATA 中有什么）？

    +   如果中继数据包目标是当前节点：

    +   `+----------+--------+-----+-----+-----------+`

    +   `| StreamID | Digest | Len | CMD | RelayData |`

    +   `+----------+--------+-----+-----+-----------+`

    +   `2 字节 + 6 字节+ 2 + 1 + 498 字节`

    +   如果中继数据包目标是另一个节点：

    +   `+-------------------------------------------+`

    +   `| 加密的、不透明的数据 + + + + + |`

    +   `+-------------------------------------------+`

    +   `+ + + + 509 字节`

+   TCP 数据的 CMD 字段是"中继数据"。

+   其他值如"relay begin"等用于建立流。

### OP 如何通过电路发送数据？

+   如上所述组成中继数据包（尚未加密）。

+   计算有效的校验和（摘要）。

    +   摘要基于应解密数据包的目标 OR。

    +   哈希是通过某个键的函数和与该 OR 交换的所有消息进行的。

        +   防止重放攻击和主动攻击

    +   摘要的前 2 个字节为零，其他 4 个字节来自哈希。

+   使用`AES(k_n)`加密，然后使用`AES(k_{n-1}), .., AES(k_1)`加密。

+   发送加密单元格到第一个 OR（`c_1`）。

    +   （OP 通过电路接收数据的逆过程。）

### OR 如何处理中继数据包？

+   如果来自 OP 的方向，解密并远离 OP 转发。

+   如果不是来自 OP 的方向，加密并转发至 OP

### OR 如何知道中继数据包是否适用于它？

+   验证校验和：如果匹配，则很可能适用于当前 OR。

+   优化：摘要的前 2 个字节应为零。

    +   如果前两个字节不为零，则可以跳过哈希：不是我们的数据包。

+   如果校验和不匹配，则不适用于此 OR，继续中继。

+   美好的特性：

    +   数据包大小与路径长度无关。

    +   只有最后一个 OR 知道目的地。

### 如何建立一个新的流？

+   OP 通过电路发送"relay begin"。- 包含目标主机名、端口。

+   谁选择流 ID？- OP 可以在其电路中选择任意流 ID。

### 什么是"漏水管"拓扑？

+   OP 可以向其电路中的任何 OR 发送中继消息（不仅仅是最后一个 OR）。

+   可以通过任何 OR 构建流（即，TCP 连接），以防止流量分析。

### 初始化电路

+   OP 选择要用于其电路的 OR 序列。

    +   为什么要让 OP 这样做？- 抵抗其他 OR“转移”电路。

+   连接到第一个 OR，发出“创建”操作以创建电路。

    +   创建包括 DH 密钥交换消息。

    +   创建响应包括 DH 密钥交换回复。

+   密钥交换协议：

    +   [OP，OR 同意素数 p，生成器 g]

    +   OP 选择随机 x。

    +   OP 发送`E_{PK_OR}(g^x)`。

    +   OR 选择随机 y。

    +   OR 计算`K=g^xy`。

    +   OR 回复`g^y, H(K || "handshake")`。

    +   OP 计算`K=g^xy`。

+   我们如何在这里验证各方身份？

    +   第一个 DH 消息使用 OR 的洋葱密钥加密。

    +   DH 响应中密钥的哈希证明向客户端证明正确的 OR 解密了消息。

    +   服务器不验证客户端-匿名性！

+   前向保密：是什么？如何实现？

+   密钥新鲜度：为什么？如何实现？

+   谁选择电路 ID？

    +   TLS 连接的客户端端点（而不是整个电路的 OP）。

    +   每个电路对于其穿越的每个链接具有不同的电路 ID。

+   控制数据包中的数据是什么？

    +   控制操作（创建，销毁）或响应（例如，已创建）。

    +   参数（例如，DH 密钥交换数据）。

+   对于每个后续 OR，OP 通过电路发送“中继扩展”消息。

    +   在“中继扩展”单元中包含相同的 DH 密钥交换消息。

    +   在电路结束时，“中继扩展”转变为“创建”。

    +   客户端最终获得每个电路中每个 OR 的共享（对称 AES）密钥。

+   Tor 为什么有单独的控制单元和中继单元？

    +   确保单元始终具有固定大小。

    +   旧电路中的最后一个 OR 需要知道新 OR 和电路 ID。

### 每个通过 OR 的电路保留哪些状态？

+   电路中两个方向（从 OP 到 OR）的电路 ID 和相邻 OR。

+   与此电路和此 OR 的 OP 共享密钥。

+   每个电路的 SHA-1 状态。

### 我们能否避免在网络中存储所有这些状态？

+   没有每个单元中的可变长度路径描述符。

+   出口节点同样需要路径描述符才能知道如何发送回去。

+   中间节点需要执行公钥加密（昂贵）。

### Tor 为什么需要出口策略？

+   防止滥用（例如，匿名发送垃圾邮件）。

+   出口策略类似于防火墙规则（例如，不能连接到端口 25）。

    +   每个出口节点在打开新连接时检查出口策略。

+   为什么在目录中发布出口策略，以及其他节点信息？

    +   不用于强制执行。

    +   OP 需要知道哪些出口节点可能有效。

### 如果 Tor 不进行完整性检查会怎样？

+   需要完整性以防止标记攻击。

+   攻击者入侵内部节点，损坏数据包。

+   损坏的数据包最终会被发送出去，可以观察它们的去向。

### Tor 如何防止重放攻击？

+   每个校验和实际上是 OP 和 OR 之间所有先前单元的校验和。

+   再次发送相同数据的校验和将不同。

+   运行良好，因为底层传输是可靠的（SSL/TLS 在 TCP 上）。

### 匿名服务

+   隐藏服务由公钥命名（伪 DNS 名称“publickey.onion”）。

+   为什么要在介绍点和会面点之间分开？

    +   避免在介绍点上放置流量负载。

    +   避免介绍点传输已知非法数据。

+   分割可以防止这两个问题。

    +   Bob（服务）有一个介绍点（IP）。

    +   Alice 选择一个会面点（RP），告诉 Bob 的 IP 关于 RP。

    +   介绍点不中继数据。

    +   会面点不知道它正在中继的数据是什么

+   为什么 Bob 要连接回 Alice？

    +   准入控制，将负载分散到许多会面点。

+   什么是会面点 cookie？-让 Bob 向 Alice 的 RP 证明它是 Bob。

+   什么是授权 cookie？

    +   一些可能会促使 Bob 回复的东西，否则他不会回复。

    +   或许是大多数人不知道的秘密词语。

    +   限制对 Bob 服务器的 DoS 攻击（只需发送许多 cookie）。

    +   存储在主机名中：cookie.pubkey.onion。

+   最终状态：两个电路连接到 RP，之间有一个流连接。

    +   RP 从一个电路的流中获取中继单元，并

    +   将它们发送到另一个电路中的流中。

    +   使用 Alice 和 Bob 之间共享的密钥（DH）加密桥接数据。

    +   每个人都可以控制自己的匿名级别。

    +   两个电路的完整路径都不知道。

### 使用 Tor 时可能会遇到的潜在问题？

+   应用层泄漏（Javascript，HTTP 头，DNS，..）

    +   使用应用级代理（例如，Privoxy 剥离许多 HTTP 头）。

+   基于 Tor 客户端行为的指纹识别（新电路打开的频率）。

+   时间/量分析（部分防御是运行自己的 Tor OR）。

+   对网站进行指纹识别：流行网站的请求次数和文件大小。

    +   固定大小单元的量化有所帮助。

+   恶意 OR：加入网络，广告大量带宽，开放出口政策。

### 运行 OR 的好处/风险？

**好处：**

+   更多的匿名性

**风险：**

+   资源使用

+   在线攻击（DoS，入侵，..）

+   离线攻击（例如，机器被执法部门扣押）

### 阻止 Tor 有多难？

+   从目录中找到 OR IP 列表，阻止所有流量到它们。

+   如何防御这种攻击？

+   向不同的客户端透露不同的 OR？

    +   允许基于使用的 OR 对客户端进行指纹识别。

+   保持一些未列出的 OR？

    +   只将未列出的 OR 用作第一跳，以避免指纹识别。

    +   Tor 有“桥接”节点的概念，这是一个未列出的 OR。

+   如何找到这些未列出的“桥接”OR？

    +   希望合法用户找到它们，但不让对手枚举它们。

    +   Tor 采取的方法：特殊的桥接目录。

    +   向每个 IP（通过 HTTP）或电子邮件地址（通过电子邮件）透露 3 个桥接。

    +   仅在 24 小时后向相同客户端地址透露新的桥接。

    +   可以按 IP 限制速率，找到尝试枚举桥接数据库的尝试等。

    +   对于电子邮件，对手更容易创建虚假身份（电子邮件地址）。

    +   Tor 信任 3 个邮件提供商来限制注册（gmail，yahoo，mit）。

### 你会使用 Tor 吗？它适用于哪些应用程序？

+   可能对所有流量使用速度太慢（高延迟）。

+   但不幸的是，这意味着只有敏感流量会通过 Tor 传输。

+   可能存在可信攻击，因此对抗非常强大的对手不是很好。

+   或许是避免拒绝服务攻击的好方法（即，转移到 Tor 上）。

+   据说，谷歌使用 Tor 来检查服务器是否特殊处理谷歌的 IP 地址。

### Tor 有多活跃？

+   现在比论文描述的使用更加活跃。

    +   ~3000 个公共 ORs，~1000 个出口节点，~1000 个桥接节点，~2GB/s 的 OR 带宽。

    +   8-9 (?) 个目录服务器，约 1600 个目录镜像。

+   困难问题：分发入口点 IP 地址，批准 ORs，..

+   有些 BitTorrent 使用，但并不压倒性：主要是因为对于大文件来说太慢了。

### 另一种方法：DC-nets（“用餐密码学家网络”）。

+   N 个参与者，但假设只有一个发送者（不知道是谁）。

+   每对参与者共享一个秘密比特位。

+   要传输“0”比特位，发送所有秘密的异或值。- 否则，发送相反的值。

+   所有传输都是公开的：为了恢复比特位，对所有人的传输进行异或运算。

+   可以建立发送多个比特位，使用冲突检测协议等。

+   在性能方面代价高昂，但提供比 Tor 更强大的安全性。

+   查看 Dissent OSDI 2012 论文，了解基于 DCnet 的系统的更多细节。

### 参考：

+   [Tor 项目指标](https://metrics.torproject.org/)

+   [Tor 共识健康](https://consensus-health.torproject.org/)

+   [部署低延迟匿名性的挑战](https://svn.torproject.org/svn/projects/design-paper/challenges.pdf)

+   [一个抗阻塞匿名系统的设计](https://svn.torproject.org/svn/projects/design-paper/blocking.pdf)

+   [用餐密码学家问题](http://en.wikipedia.org/wiki/Dining_cryptographers_problem)

+   [数字中的异议：使强大的匿名性扩展](http://dedis.cs.yale.edu/2010/anon/papers/osdi12.pdf)
