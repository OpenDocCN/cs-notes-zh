# 内存认证（Marten van Dijk 的笔记）

**阅读：** R. Elbaz, D. Champagne, C. Gebotys, R.B. Lee, N. Potlapally 和 L. Torres, "内存认证的硬件机制：现有技术和引擎综述", 计算机科学交易, pp. 1-22, 2009.

**模型（假设、安全需求、可能的攻击）：**

什么是内存认证？验证处理器从给定地址读取的数据是否是它最后写入该地址的数据。

为什么需要内存认证？能够破坏内存空间的对手可以影响受信任计算平台执行的计算。假设：提供包括内存在内的防篡改环境成本太高。受信任的计算平台是具有有限片上存储的单芯片安全处理器。它对所有物理攻击具有抵抗力，包括侵入性攻击。每当敏感计算完成时，需要验证计算过程中片外内存操作序列的真实性。请注意，根据应用程序的不同，这可能会经常发生，或者有时发生。这导致不同的认证策略（基于树或非基于树）。

有一个对所有物理攻击具有抵抗力的单芯片处理器是现实的吗？可能只有对成本不太高的所有物理攻击具有抵抗力是可以接受的。这排除了由普通黑客执行的攻击。我们不试图防范由有权访问昂贵实验室的工程师执行的攻击。所需的安全性（及其成本）是业务模型的一部分。

数据完整性指的是检测任何对数据的敌对破坏或篡改的能力。它与内存认证有什么关系？内存认证意味着数据完整性。

内存认证的目标是防范篡改片外内存内容的主动攻击。这些主动攻击是什么？欺骗：现有内存块被替换为任意伪造的内存块。拼接/重定位：将地址 A 处的内存块替换为地址 B 处的内存块。重放：在给定地址处记录的内存块在以后的某个时间点插入到同一地址处。

什么是软件攻击？软件攻击是由受损操作系统或恶意应用程序执行的主动攻击。即使操作系统内核被设计为将敏感应用程序与恶意软件隔离，我们也不能信任操作系统。目前，我们不会考虑软件攻击。

还有哪些安全需求值得关注？访问控制；应用程序不应能够访问彼此的特定数据。数据保密性；加密敏感数据以确保隐私。

为什么这些需求还不够？攻击者可能操纵加密数据。因此，我们还需要内存认证。

加密敏感数据是否真的确保隐私？内存访问模式的相关性如何？这可能泄露有关应用程序性质以及与其共享内存的其他应用程序之间的关系的信息。

**解决方案（基于树的解决方案和非基于树的解决方案）：**

内存认证的一个天真解决方案是什么？在芯片存储器中存储整个内存的摘要。不可接受。

下一个最佳解决方案是什么？存储每个内存块（缓存块）的摘要，参见图 3(a)。减少内存带宽开销，但需要太多（昂贵）的芯片内存。

什么是稍微更好的解决方案？在芯片内存上使用随机数成本更低，参见图 3(b)。如果随机数生成器超出范围，需要重置密钥 k 并更新所有内存（这可以在空闲时间完成）。随机数生成器需要输出唯一的随机数吗？不同地址的随机数需要不同吗？不需要，如果我们将每个 MAC 计算为密钥 k、随机数 N 和地址 A 的函数。因此，我们可以使用较小的随机数，从而减少芯片内存。当特定地址的较小随机数用尽时，该地址在重置密钥 k 之前无法使用。如果我们使用 16 位的较小随机数，可以使用随机随机数吗？不可以，以 1/2¹⁶ 的概率会导致冲突，可能会导致攻击。我们需要确定性随机数：对于每次更新，只需将相应的随机数递增 1。

如何添加数据保密性？将 MAC 替换为加密 E，参见图 3(c)。

什么技巧可以改进当前的解决方案？具有哈希（Merkle 树）、MAC + 随机数或 E + 随机数的完整性树。参见图 5。它是如何工作的？Merkle 树更新过程是顺序的：在更新下一个分支节点之前，必须完成分支中新哈希节点的计算。PAT 读取和更新过程是可并行化的，它是如何工作的？一个中间节点存储其子节点中存储的随机数的 MAC，这些都是事先已知的。中间节点不存储其子节点中存储的 MAC 的 MAC（这将类似于 Merkle 树）。TEC-Tree 使用加密，不存储随机数。在更新期间如何检索随机数？使用解密。读取和更新的混合是否可并行化？不可以。

我们如何找到父节点的地址？使用树遍历，导致（公式 1）。

如何利用缓存以提高性能？树读取和更新过程在遇到缓存的哈希或根时终止。

什么是盆景 Merkle 树？使用许多使用计数器/随机数的较小树。存储它们的根。使用特殊树保护计数器，并存储其中间节点和叶子。参见图 6。注意声明“每次本地计数器翻转时都需要对整个页面进行加密处理”。不要担心此方法的细节。只需注意与我们在图 3(b)中呈现的解决方案的讨论的相似性。

如果操作系统不可信，我们需要做什么？构建一个完整性树，仅覆盖属于应用程序的页面，并且只能在应用程序本身运行时更新。页表将页面的虚拟地址映射到其物理地址。分支接种攻击会破坏与给定内存块的虚拟地址对应的物理地址，参见图 7。因此，我们需要在虚拟地址空间上构建一棵树。受保护应用程序生成的虚拟地址用于遍历树。存在哪些缺点？不可扩展：需要大量的内存容量（为初始化期间定义的 2⁶⁴ 字节叶节点的物理页框分配，以及为非叶树节点分配内存），以及大量的初始化开销（初始化这样的树需要太长时间）。我们还需要为每个需要保护的应用程序引入一个完整的树，而不是一个单独的树来保护物理内存中的所有软件。我们如何尝试部分克服这些问题？引入一个新的硬件单元，在一个缩小的地址空间上构建一个完整性树，该空间仅包含应用程序执行所需的页面（随着应用程序内存占用的增加而动态增长）。

无树结构的内存认证：Lhash 专为需要在一系列内存操作之后进行完整性检查的应用程序设计（与树方案中的每个内存操作进行检查相反）。它使用多重集哈希函数在运行时维护内存位置的写入和读取日志，称为 WriteHash 和 ReadHash。这些日志存储在芯片上。在初始化时，WriteHash 计算在需要认证的内存区域中属于内存块的内存块上。当执行芯片外写入或从缓存中驱逐脏缓存块时，WriteHash 在运行时更新。WriteHash 随时反映芯片外内存状态。当执行芯片外读取或将块带入缓存时，ReadHash 会更新。要检查一系列操作的完整性，需要读取属于内存区域的所有块，之后 ReadHash 应该等于 WriteHash。

多重集哈希函数的要求：压缩（保证我们可以将哈希存储在有限的内存中）、可比性（一个比较哈希的概率算法，因为多重集不总是哈希到相同的值）、增量性（将多重集的哈希相加得到多重集的并集的哈希）、以及多重集碰撞抗性（计算上不可行找到两个不同的多重集哈希到相似哈希的）。

**相关主题：**

相关主题：数据认证对称多处理器：需要考虑在缓存到缓存传输中进行总线事务认证，这在缓存一致性协议中是必需的，参见图 8。

相关主题：如何利用不受信任的服务器为大量目录提供可信存储，其中每个目录中的文件可能由几个不同设备访问和更新，这些设备可能在不同时间离线，并且除了通过不受信任的服务器（在不受信任的网络上）之外，它们可能无法相互通信。多用户网络文件系统 SUNDR 提供了对分叉攻击的保护，这是一种攻击形式，其中服务器使用重放攻击使不同用户对系统的当前状态有不同的视图。然而，它并不会*立即*检测到分叉攻击。相反，它提供*分叉一致性*，这基本上确保系统服务器要么行为正确，要么其故障或恶意行为将在稍后的某个时刻被检测到，当用户能够相互通信时（例如，每天晚上一次）。如果不受信任的服务器具有可以信任的时间戳设备（例如，通过使用嵌入式可信平台模块），则可以立即检测到分叉和重放攻击。

相关主题：云存储。客户端希望确保其数据的副本存在。检索性证明（POF）是服务器生成的包含证据的短消息，证明客户端数据的正确版本存储在服务器上。这使客户能够有效地检查其数据是否得到充分备份（查看有关 T-mobile 数据丢失的最新消息！）。

相关主题：稀疏内存。通过使用经过身份验证的搜索树，可以生成一个证明，证明对应于加密地址的叶子不存在。这可以防止存储值的存在性被否认（稀疏内存所需），重放攻击和未经授权的访问。
