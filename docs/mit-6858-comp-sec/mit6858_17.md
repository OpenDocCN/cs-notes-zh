# 私密浏览模式

**注意：** 这些讲座笔记是从 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的笔记稍作修改而来。

## 私密浏览：目标、定义、威胁模型

隐私的目标是什么？

+   模糊的理想：（某个）用户的活动与许多其他用户的活动不可区分。

+   今天我们将讨论网络浏览器隐私的问题。

    +   由于网络应用程序非常复杂且可能生成大量可追踪的状态，因此对于私密浏览的定义并不明确。

    +   浏览器根据用户需求和其他浏览器供应商的做法更新其私密浏览实现。

    +   由于用户依赖私密浏览模式，他们对其期望更高...并且更多的实现缺陷浮出水面！

浏览器所谓的“私密浏览”是什么意思？

+   论文将此形式化为两个独立的威胁模型+攻击：

    1.  一个本地攻击者在浏览会话结束后拥有您的机器，并希望发现您访问过哪些网站。

    1.  一个网络攻击者入侵了您联系的网络服务器，并希望将您跨私密和/或正常会话进行关联。

+   如果两个攻击者合作，他们更容易识别用户。

    +   例如：本地攻击者要求服务器检查服务器访问日志中的本地 IP 地址。

    +   因此，对这两种攻击单独进行安全防护具有实际价值。

### 威胁 1：本地攻击者

+   *假设：* 攻击者在会话结束后控制用户的机器，并希望了解用户在私密浏览模式下访问了哪些网站。

+   *安全目标：* 攻击者不能了解这些网站！

+   非目标

    +   不关心为*未来*的私密浏览会话实现隐私。

        +   攻击者可能修改机器上的软件（例如安装键盘记录器）并跟踪未来的浏览活动。

        +   这也是为什么我们假设攻击者在私密浏览开始*之前*无法访问机器。

    +   隐藏使用私密浏览的事实。

        +   通常被称为“合理否认”。

        +   论文指出这很难实现，但没有解释原因。在后面的讲座中，我们将讨论一些潜在原因。

私密会话可以泄漏哪些持久的客户端状态？（持久性指的是“存储在本地磁盘上”。）

1.  JavaScript 可访问的状态：Cookies，DOM 存储

1.  浏览器缓存

1.  访问地址的历史记录

1.  配置状态：新的客户端证书，更新的保存密码数据库，书签

1.  下载的文件

1.  新插件/浏览器扩展

...以及：

+   所有私密浏览实现都试图防止持久泄漏到 1、2 和 3\. 但是，4、5 和 6 在私密会话结束后通常仍然存在。

+   网络活动可能留下持久的证据--DNS 解析记录！

    +   要解决这个问题，私密浏览模式需要在会话结束时刷新 DNS 缓存。然而，这很棘手，因为刷新缓存通常需要在您的机器上具有管理员权限（您希望浏览器具有管理员权限吗？）并删除所有 DNS 状态，而不是特定用户生成的状态。

+   在私密浏览期间，内存中的对象也可能被分页到磁盘上！

*演示：*

```
 Open Firefox in Private Browsing Mode
    Visit http://pdos.csail.mit.edu/
    sudo gcore $(pgrep firefox)
    strings core.* | grep -i pdos

      // -e l: Look for string using the
      //       character encoding 16-bit
      //       little-endian.
      // -a:   Scan all of the file.
      // -t:   Print the offset within
      //       the file. 
```

数据生命周期是一个比私密浏览更广泛的问题！

+   例子：如果泄露了加密密钥或密码可能会有问题。[参考链接](http://css.csail.mit.edu/6.858/2010/readings/chow-shredding.pdf)

*演示：*

```
 cat memclear.c
     cat secret.txt
     make memclear
     ./memclear &
     sudo gcore $(pgrep memclear)
     strings core.* | grep secret 
```

数据存在于哪里？

+   进程内存：堆，栈。

    +   终端滚动回溯

    +   I/O 缓冲区，X 事件队列，DNS 缓存，代理服务器，...

    +   语言运行时会复制数据（例如，在 Python 中的不可变字符串）

+   文件，文件备份，SQLite 数据库

+   交换文件，休眠文件

+   内核内存：

    +   IO 缓冲区：键盘，鼠标输入

    +   释放的内存页面

    +   网络数据包缓冲区

    +   管道缓冲区包含进程间发送的数据

    +   随机数生成器输入（包括再次输入按键）。

攻击者如何获取剩余数据的副本？

+   文件本身可能包含多个版本（例如，Word 曾支持此功能）。

+   如果程序在释放内存或程序关闭时不擦除内存，可能会泄漏信息：

    +   例如：在旧版 Linux 内核中，当创建新目录时，最多可以泄漏 4 KB 的内核内存到磁盘。

    +   例如：如果内核/VMM 不擦除内存页面，那么来自进程 X 的信息可能泄漏到使用 X 旧内存页面的进程 Y 中。

+   核心转储

+   直接访问机器

+   闪存 SSD 实现日志记录--它们不会立即擦除旧数据！

+   盗取的磁盘，或者只是处理旧磁盘 [参考链接: http://news.cnet.com/2100-1040-980824.html]

我们如何处理数据生命周期问题？

+   清空未使用的内存[会有一些性能降低]。

+   在难以清零的地方加密数据（例如，在 SSD 上）。

    +   安全删除密钥意味着数据无法再解密！

    +   例如：OpenBSD 交换使用加密，每次启动时生成新的加密密钥。

    +   与磁盘 I/O 相比，加密的 CPU 成本是适度的。

### 威胁 2：网络攻击者

+   *假设：*

    +   攻击者控制用户访问的网站。

    +   攻击者无法控制用户的机器。

    +   攻击者希望检测用户访问网站的情况。

+   *安全目标：*

    +   攻击者无法识别用户。

    +   攻击者无法确定用户是否使用私密浏览模式。

防御网络攻击者非常困难！

+   识别用户意味着什么？

    +   同一用户从不同私密浏览会话中访问链接。

    +   用户从私密浏览和公共浏览会话中访问链接。

+   识别用户的简单方法：IP 地址。

    +   合理概率上，来自相同 IP 地址的请求是同一用户。

    +   下一讲，我们将讨论 Tor。Tor 保护 TCP 连接源（即用户的 IP）的隐私。但是，Tor 并不能解决实现私密浏览的其他挑战。

+   即使用户使用 Tor，Web 服务器仍然可以通过分析她的浏览器运行时的独特特征来识别她！

*浏览器指纹演示：*

```
 -  Open Chrome, go to http://panopticlick.eff.org/
 -  Open the same web site in private
          browsing mode. 
```

+   隐私的良好思考方式：用户的匿名集是什么？即，在哪个最大的用户集中，某个用户是无法区分的？

    +   Panopticlick 显示，对于大多数用户，此集合很小，因为用户倾向于具有唯一的本地设置，如字体、插件等。

+   网络攻击者如何确定您是否在使用私密浏览模式？

    +   论文描述了基于链接颜色的历史嗅探攻击。

        +   攻击者页面在 iframe 中加载 URL，然后创建到该 URL 的链接，并查看链接是否为紫色（私密会话不存储历史记录）。

        +   由于浏览器不再向 JavaScript 公开链接颜色，此攻击不再有效！[请参阅几堂课前讨论的历史嗅探攻击讨论。]

    +   但是，攻击者可能有其他方法来判断您是否在使用私密模式。

        +   例如：公共模式的 Cookie 无法被私密模式页面看到。因此，如果您在公共模式下访问页面，然后在私密模式下访问，页面可以检测到缺少预期的 Cookie。

## 方法

我们如何为私密浏览提供更强的保证？（暂时忽略 IP 地址隐私，或者假设用户使用 Tor。）

+   方法 1：**虚拟机级隐私**

    +   *计划：*

        +   每个私密浏览会话在单独的虚拟机中运行。

        +   确保在私密浏览结束后删除虚拟机。

        +   确保没有虚拟机状态最终出现在磁盘上[禁用分页？安全释放？]。

    +   **优势：**

        +   对本地攻击者和网络攻击者提供强有力的保证。

        +   应用程序无需更改，只需安全删除虚拟机。

    +   **缺点：**

        +   为私密浏览启动单独的虚拟机是繁重的。

        +   使用不便：用户更难保存私密浏览中的文件，使用书签等。

    +   可用性和隐私之间存在固有的权衡！

+   方法 2：**操作系统级隐私**

    +   *计划：* 在操作系统内核级别实现类似的保证。

        +   一个进程可以在“隐私域”中运行，之后将被删除。

    +   **优势超过虚拟机**：更轻量级。

    +   **相对于虚拟机的缺点：**更难正确实现，因为操作系统内核管理了大量状态。

是否有方法可以对使用这些方法的用户进行去匿名化？

+   也许虚拟机本身是独一无二的！因此，我们需要确保所有用户拥有类似的虚拟机。

    +   这限制了用户可以定制虚拟机的程度。

+   也许 VMM 或主机计算机引入了一些独特性。

    +   *例如：* TCP 指纹识别：TCP 协议允许实现设置一些参数（例如，初始数据包大小，初始 TTL）。

    +   像 nmap 这样的工具向远程服务器发送精心制作的数据包；可以高度可能性地猜测远程操作系统！

+   用户仍然是共享的！因此，攻击者可能会：

    +   检测用户的击键时序。

    +   检测用户的写作风格。这被称为笔迹学。[参考](http://33bits.org/2012/02/20/is-writing-style-sufficient-to-deanonymize-material-posted-online/)

浏览器为什么要实现自己的私密浏览支持？

+   主要原因是可部署性：用户不必在自定义虚拟机或操作系统中运行其浏览器。

    +   Native Client 有类似的动机。

+   另一个原因是可用性：私密模式中生成的某些类型的状态应该能够在会话结束后持续存在。（例如：下载的文件）。

    +   这是一个危险的计划！浏览器是复杂的软件，因此很难找到架构中允许某些类型的状态（但不允许其他类型）持久存在的清晰界限。

我们如何对这些类型的状态进行分类？论文指出我们应该考虑是谁发起了状态更改（第 2.1 节）。

1.  *由网站发起，无用户交互：* cookies，历史记录，缓存。

    +   保持在会话内，会话结束时删除。

1.  *由网站发起，需要用户交互：* 客户端证书，保存的密码。

    +   不清楚什么是最佳策略；浏览器倾向于持久存储此状态，可能是因为用户必须明确授权该操作。

1.  *由用户发起：* 书签，文件下载。

    +   与上述相同：浏览器倾向于持久存储此状态，因为用户授权了该操作

    +   ...但请注意，存储此状态可能会泄露用户使用私密浏览模式的事实！

        +   *例如：* 在 Firefox 和 Chrome 中，书签存储在 SQLite 数据库中。在私密浏览模式下生成的书签将对`last_visit_count`等元数据有空值[参考](http://homepages.cs.ncl.ac.uk/feng.hao/files/DPM13.pdf)

1.  *与会话无关：* 浏览器更新，证书吊销列表更新。

    +   将其视为在公共模式和私密模式之间共享的单个全局状态。

浏览器实际上实现了什么？

+   每个浏览器当然都是不同的。

+   此外，某些状态在一个方向上“泄露”，但在另一个方向上不会！私密模式和公共模式状态之间没有严格的分区。

*问答：*

+   **Q:** 如果公共状态泄露到私密状态会发生什么？

+   **A:** 网络攻击者更容易将私密会话与公共会话关联起来。

    +   *例如：* 在公共模式下安装的客户端 SSL 证书可以识别私密模式中的用户。

+   **Q:** 如果私密状态泄露到公共状态会发生什么？

+   **A:** 这对于网络攻击者和本地攻击者都有帮助：观察公共会话的状态将会泄露关于私人会话的信息！

+   **Q:** 用户在私密模式会话中时状态应该如何处理？

+   **A:** 大多数浏览器允许状态在私密模式会话中持久存在（见表 3）。

    +   "否"表示网络攻击者可能能够检测到私密模式浏览！

    +   **Q:** 为什么允许在私密浏览模式下使用 cookies？

    +   **问：** 对用户来说，在隐私浏览模式下能够创建临时会话很方便---浏览器将在私密会话结束时删除相关的 cookie。

+   **问：** 私密模式会话之间的状态应该如何处理？

+   **答：** 理想情况下，每个私密会话应该从零开始---如果状态在多个私密会话之间传递，这会增加用户被指纹识别的可能性！然而，由于某些类型的状态可以从私密到公共传递，某些类型的状态可以从公共到私密传递，因此某些类型的状态确实可以在私密模式会话之间持续存在。[例如：证书、下载的项目。]

    +   因此，将每个私密模式会话视为与单个公共模式共享某些状态。

### 浏览器扩展

浏览器扩展和插件是特殊的。

+   它们是可以访问敏感状态的特权代码。

+   它们不受同源策略或其他浏览器安全检查的限制。

+   此外，它们通常是由浏览器供应商之外的人开发的！

    +   因此，它们可能不了解私密模式的语义，或者可能错误地实现了预期的策略。

    +   然而，插件可能在不久的将来会灭绝！HTML5 提供了新功能，为以前需要 Flash、小程序、Silverlight 等的功能提供了本机支持。[参考](http://msdn.microsoft.com/en-us/library/ie/hh968248(v=vs.85).aspx)

        +   多媒体：`<video>`，`<audio>`

        +   图形：`<canvas>` WebGL

        +   离线存储：DOM 存储

        +   网络：Web sockets，CORS

## 当前的私密浏览模式

该论文是在 2010 年撰写的---私密浏览的当前状态如何？

+   仍然很难正确实现私密浏览！

    +   *例如：* 2014 年 1 月的 Firefox 漏洞修复：pdf.js 扩展允许公共 cookie 泄漏到私密模式的 HTTP 获取中。[参考](https://github.com/mozilla/pdf.js/issues/4234)

        +   该扩展没有检查私密浏览模式是否已启用！

    +   *例如：* 2011 年的 Firefox 漏洞：如果您在隐私浏览模式下访问页面，然后关闭窗口，您可以转到 about:memory 并找到关于您所关闭的窗口的信息（例如，about:memory 将列出窗口的 URL）。[参考](https://bugzilla.mozilla.org/show_bug.cgi?id=709326)

        +   问题在于窗口对象是惰性垃圾回收的，因此关闭窗口不会强制窗口进行同步垃圾回收。

        +   当潜在解决方案比最初预期的更复杂时，该漏洞被“降级处理”；作为回应，一位开发者说：“这听起来很令人难过。这几乎可以破坏诸如 sessionstore 忘记关闭的私密窗口等功能的目的。”

+   现成的取证工具可以找到私密浏览器会话的证据。

    +   *例如:* Magnet 的 Internet Evidence Finder [[1]](http://www.magnetforensics.com/how-private-is-internet-explorers-inprivate-browsing-first-define-private/)，[[2]](http://www.magnetforensics.com/how-does-chromes-incognito-mode-affect-digital-forensics/)，可以找到 IE、Chrome 和 Firefox 的私密会话痕迹。

        +   在私密会话期间，IE 将对象存储在文件系统中。这些对象在私密会话关闭时被删除，但存储空间并未被擦除，因此私人数据仍然存在于未分配的磁盘空间中。

        +   Chrome 和 Firefox 在私密浏览期间使用内存中的 SQLite 数据库，因此在文件系统中留下较少的痕迹。然而，像所有浏览器一样，它们在页面文件中留下痕迹。
