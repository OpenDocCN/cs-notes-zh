# 污点跟踪

**注意：** 这些讲座笔记是从2014年6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的笔记上稍作修改的。

## 安卓安全策略

这篇论文试图解决什么问题？

+   应用程序可以外泄用户的私人数据并发送到某个服务器。

+   高层次方法：跟踪哪些数据是敏感的，并防止其离开设备！

+   为什么安卓权限不够用？

    +   安卓权限控制应用程序是否可以读取/写入数据，或访问设备或资源（例如，互联网）。

    +   使用安卓权限，很难指定关于*特定*类型数据的策略。 （*例子：* “即使应用程序有网络访问权限，也不应该能够通过网络发送用户数据”）。

    +   **Q:** 啊哈！如果我们从不安装既读取数据又具有网络访问权限的应用程序呢？

    +   **A:** 这将阻止一些明显的泄漏，但也会破坏许多合法的应用程序！ （*例子：* 电子邮件应用程序）

        +   信息仍然可以通过侧信道泄漏。 （*例子：* 浏览器缓存泄漏了一个对象是否在过去被获取过）

        +   应用程序可以勾结！ （*例子：* 没有网络权限的应用程序可以将数据传递给具有网络权限的应用程序。）

        +   恶意应用程序可能会欺骗另一个应用程序发送数据。 （*例子：* 发送一个意图到 Gmail 应用程序？）

安卓恶意软件实际上做了什么？

+   用位置或IMEI进行广告。 （IMEI是每台设备的唯一标识符。）

+   窃取凭据：将您的联系人列表、IMEI、电话号码发送到远程服务器。

+   将您的手机变成一个僵尸，使用您的联系人列表发送垃圾邮件/短信！ ['Sophisticated' Android malware hits phones](http://www.bbc.com/news/technology-30143283)

+   防止数据外泄是有用的，但仅靠污点跟踪是不足以防止设备被黑客攻击的！

## TaintDroid 概述

*TaintDroid* 跟踪敏感信息在系统中传播的过程。

+   *TaintDroid* 区分信息源和信息汇

    +   源生成敏感数据：*例子：* 传感器、联系人、IMEI

    +   汇点暴露敏感数据：*例子：* 网络。

+   *TaintDroid* 使用32位位向量表示污点，因此最多可以有32个不同的污点来源。

+   大致上，污点从赋值的右手边流向左手边。

*例子：*

```
int lat = gps.getLatitude();
                // The lat variable is now
                // tainted!

Dalvik VM is a register-based machine,
so taint assignment happens during the
execution of Dalvik opcodes [see Table 1].

   move_op dst src          // dst receives src's taint
   binary_op dst src0 src1  // dst receives union of src0
                            // and src1's taint 
```

有趣的特殊情况，数组：

```
 char c = //. . . get c somehow.
   char uppercase[] = ['A', 'B', 'C', . . .];
   char upperC = uppercase[c];
                     // upperC's taint is the
                     // union of c and uppercase's
                     // taint. 
```

+   为了最小化存储开销，一个数组接收一个单一的污点标记，其所有元素都具有相同的污点标记。

+   **Q:** 为什么将数组或IPC消息仅关联一个标签是安全的？

+   **A:** 估计污点应该是安全的。 这可能会导致误报，但不会导致漏报。

+   另一个特殊情况：本地方法（即，内部VM方法如 `System.arraycopy()`，以及通过JNI公开的本地代码）。

    +   **问题：** 本地代码不经过 Dalvik 解释器，所以 *TaintDroid* 无法自动传播污点！

    +   **解决方案：**手动分析本机代码，提供其污点行为的摘要。

        +   实际上，需要指定如何将参数的污点复制到返回值。

        +   **问：**这种扩展效果如何？

        +   **答：**作者认为这对内部 VM 函数（例如，`arraycopy`）效果不错。对于“简单”调用，分析可以自动化---如果只传递整数或字符串，则将输入污点的并集分配给返回值。

+   IPC 消息类似于数组：每个消息与一个污点相关联，该污点是组成部分的污点的并集。

    +   从传入消息中提取的数据被分配为该消息的污点。

+   每个文件都与一个存储在文件元数据中的单个污点标志相关联。

    +   与数组和 IPC 消息一样，这是一个保守的方案，可能会导致误报。

污点标记在内存中是如何表示的？

+   五种东西需要有污点标记：

    1.  方法中的局部变量

    1.  方法参数

    1.  对象实例字段

    1.  静态类字段

    1.  数组

+   基本思想：将变量的标志存储在变量附近。

    +   **问：**为什么？

    +   **答：**保留空间局部性---这有望改善缓存行为。

    +   对于生活在堆栈上的方法参数和局部变量，立即在变量旁边分配污点标志。

*例子：*

```
 .
                 .
        |        .         |
        +------------------+
        |     local0       |
        +------------------+
        | local0 taint tag |
        +------------------+
        |     local1       |
        +------------------+
        | local1 taint tag |
        +------------------+
                 .
                 .
                 .

    _TaintDroid_ uses a similar approach
    for class fields, object fields,
    and arrays -- put the taint tag
    next to the associated data. 
```

因此，鉴于所有这些，*TaintDroid*中的基本思想很简单：当敏感数据通过系统流动时标记污点，并在数据试图通过网络离开时发出警报！

作者发现应用程序的各种不当行为：

+   将位置数据发送给广告商

+   将用户的电话号码发送到应用服务器

*TaintDroid*的信息流规则可能导致反直觉/有趣的结果。想象一个应用程序实现自己的链表类。

```
 class ListNode{
        Object data;
        ListNode next;
    } 
```

假设应用程序将受污染的值分配给“data”字段。如果我们计算列表的长度，长度值是否受污染？

向链表添加元素涉及：

1.  分配一个`ListNode`

1.  分配给`data`字段

1.  修补`next`指针

请注意，**步骤 3**不涉及受污染的数据！因此，“next”指针是受污染的，这意味着计算列表中元素数量不会生成受污染的长度值。

*TaintDroid*的性能开销是多少？

+   用于存储污点标记的额外内存。

+   分配额外的 CPU 成本来分配、传播、检查污点标记。

+   开销似乎适中：内存开销约为 3--5%，CPU 开销为 3--29%

    +   然而，在手机上，用户非常关心电池寿命：29% 的 CPU 性能下降可能是可以接受的，但电池寿命下降 29% 是不好的。

## 问题和答案

**问：**为什么不在 x86 指令或 ARM 指令级别跟踪污点？

**答：**这太昂贵了，而且误报太多。

+   *例子:* 如果内核数据结构被错误地分配了污点，那么污点将错误地流向用户模式进程。这会导致污点爆炸：无法确定哪个状态*真正*受到敏感数据的影响。

+   这可能发生的一种方式是如果堆栈指针或断点指针被错误地标记。一旦发生这种情况，污点会迅速扩散：

    +   本地变量访问被指定为相对于断点指针的偏移量。

    +   `pop`等堆栈指令使用堆栈指针。

    +   [毫无意义的污点？评估指针污点的实用性](http://www.ssrg.nicta.com.au/publications/papers/Slowinska_Bos_09.pdf)

**Q:** 污点跟踪似乎很昂贵---我们不能只检查输入和输出以查找已知敏感值吗？

**A:** 这可能作为一种启发式方法，但对于对手来说很容易绕过它。

+   有许多编码数据的方式，例如，URL编码、二进制与文本格式等。

## 隐式流

如描述的，污点跟踪无法检测*隐式流*。

隐式流发生在一个受污染的值影响另一个变量而不直接分配给该变量时。

```
 if (imei > 42) {
         x = 0;
     } else {
         x = 1;
     } 
```

我们可以尝试通过网络泄露IMEI的信息，而不是分配给`x`！

隐式流通常是由于受污染的值影响控制流而产生的。

可以尝试通过给程序计数器（PC）分配一个污点标记来捕捉隐式流，更新它与分支测试的污点，并将PC的污点分配给if-else子句内的值，但这可能会导致很多误报。

*例子:*

```
 if (imei > 42) {
         x = 0;
     } else {
         x = 0;
     }

     // The taint tracker thinks that
     // x should be tagged with imei's
     // taint, but there is no information
     // flow! 
```

## 应用程序

污点跟踪的有趣应用：跟踪数据副本。

+   通常希望确保敏感数据（密钥、密码）及时擦除。

+   如果我们不担心性能，我们可以使用x86级别的污点跟踪来查看敏感信息如何在机器中流动。[参考](http://www-cs-students.stanford.edu/~blp/taintbochs.pdf)

+   基本思想：创建一个x86模拟器，解释完整系统（操作系统+应用程序）中的每个x86指令。

+   您会发现软件通常会保存比必要时间更长的数据。例如，按键数据会保留在：

    +   键盘设备驱动程序的缓冲区

    +   内核的随机数生成器

    +   X服务器的事件队列

    +   用于传递包含按键消息的消息的内核套接字/管道缓冲区

    +   终端应用程序的`tty`缓冲区

    +   等等...

### Tightlip

*TaintDroid*检测敏感数据泄漏，但需要Java VM的语言支持--VM必须实现污点标记。我们能否在没有受管运行时支持的情况下跟踪敏感信息泄漏？如果我们想要检测遗留的C或C++应用程序中的泄漏怎么办？

+   一种方法：使用[TightLip系统](https://www.usenix.org/legacy/event/nsdi07/tech/full_papers/yumerefendi/yumerefendi.pdf)中引入的双重进程

+   **步骤1**: 定期，*Tightlip*运行一个守护进程，扫描用户的文件系统，并查找类似邮件文件、文字处理文档等敏感信息。

    +   对于这些文件中的每一个，*Tightlip* 生成文件的影子版本。影子版本是非敏感的，并包含清洁后的数据。

    +   *Tightlip* 将每种类型的敏感文件与专门的清洁器相关联。 *示例:* 电子邮件清洁器用等量的虚拟字符覆盖 to: 和 from: 字段。

+   **第二步**：在稍后的某个时刻，一个进程开始执行。最初，它不接触任何敏感数据。如果它接触到敏感数据，那么 *Tightlip* 会生成一个复制者进程。

    +   复制者是原始进程的沙盒版本。

        +   继承大部分状态从原始进程...

        +   ...但读取清洁后的数据而不是敏感数据

    +   *Tightlip* 让两个进程并行运行，并观察这两个进程所做的系统调用。

    +   如果复制者与原始进程做出相同的系统调用并带有相同的参数，那么很可能输出不依赖于敏感数据。

+   **第三步**：如果系统调用发散，复制者试图进行网络调用，*Tightlip* 将标记潜在的敏感数据泄漏。

    +   在这一点上，*Tightlip* 或用户可以终止进程，失败网络写入，或执行其他操作。

+   *Tightlip* 的优点：

    +   适用于传统应用程序

    +   需要对标准操作系统进行轻微更改，以比较系统调用的顺序及其参数

    +   低开销（基本上是运行额外进程的开销）

+   *Tightlip* 的局限性

    +   清洁器位于受信任的计算基础上。

        +   他们必须捕捉所有敏感数据的实例。

        +   他们还必须生成合理的虚拟数据--否则，复制者可能会在格式不正确的输入上崩溃！

    +   如果复制者从多个来源读取敏感数据，并且发生系统调用分歧，*Tightlip* 无法判断原因。

### 分散式信息流控制

*TaintDroid* 和 *Tightlip* 假设开发人员不提供任何帮助...但如果开发人员愿意在其代码中明确添加污点标签呢？

```
 int {Alice --> Bob} x;  // Means that x is controlled
                          // by the principal Alice, who
                          // allows that data to be seen
                          // by Bob. 
```

*输入通道:* 读取值获取通道的标签。

*输出通道:* 通道上的标签必须与写入值上的标签匹配。

+   静态（即编译时）检查可以捕捉许多涉及不当数据流的错误。

    +   粗略地说，标签就像编译器可以推理的强类型。

    +   静态检查比动态检查要好得多：运行时失败（或其缺失）可能是一种隐蔽通道！

+   更多细节，请参阅[Jif paper](http://pmg.csail.mit.edu/papers/iflow-sosp97.pdf)
