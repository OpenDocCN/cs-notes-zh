# SGX 和 Haven

为什么我们要阅读这篇论文？**待办事项：**哪篇论文？SGX 还是 Haven？

+   先进的硬件隔离机制

    +   我们对隔离机制的巡回的最后一篇论文

+   在实践中相关的强大威胁模型

    +   许多桌面电脑运行恶意软件

    +   恶意软件可能控制整个操作系统

+   使用尖端技术（英特尔 SGX）

    +   但是，对于 SGX 尚无部署经验

    +   可能存在设计和实现缺陷

    +   第一批硬件已经推出（参见下面的参考资料）

## SGX 目标

+   即使操作系统被入侵，应用程序仍然可以保持秘密

    +   也许不是整个操作系统被入侵

    +   但也许攻击者正在运行键盘记录器

+   目标应用程序：

    +   登录到您的银行

        +   安全：操作系统/键盘记录器无法窃取您的密码+PIN 以登录

    +   用于受版权保护内容的视频/音乐播放器（DRM）

        +   安全：操作系统无法窃取解密内容的密钥

*雄心勃勃的目标：*

+   应用程序依赖于操作系统

    +   如何防御恶意操作系统？

+   操作系统接口很广

    +   如何检查应用程序是否操作系统行为适当？

+   “Iago”攻击的机会很多

    +   查看论文"Iago Attacks: Why the System Call API is a Bad Untrusted RPC Interface" 这里或我们的首页。

*Iago 攻击：不受信任的操作系统可以用来攻击应用程序的攻击*

+   操作系统修改`getpid()`和`time()`以返回不同的数字，相同的数字

    +   `getpid()`和`time()`经常用于生成伪随机数

+   操作系统可能混淆运行 SSL 的服务器

    +   操作系统可以记录成功连接的数据包

    +   操作系统可能导致 SSL 的下一个实例使用相同的服务器随机数

        +   通过为`time()`和`getpid()`返回与早期连接相同的值

    +   操作系统可以重放数据包

        +   SSL 服务器认为这是一个新连接，但实际上不是

        +   可能发起中间人攻击

+   操作系统修改`mmap()`以映射一个由操作系统控制的物理页面到应用程序堆栈上

    +   `malloc()`调用`mmap()`

    +   操作系统可以运行任意代码

    +   操作系统可以读取应用程序的秘密（例如 SSL 连接的私钥）

+   **教训：**简单的系统调用（例如，getpid 和 time）可能会引起问题

    +   应用程序必须以防御性方式编写

    +   防止遗留应用程序受恶意操作系统攻击似乎很困难

针对恶意操作系统的防御研究很多

+   一些使用 TPM 或延迟启动

+   一些使用受信任的虚拟化程序

+   一些使用特殊处理器

+   影响不大---主要是一项具有挑战性的智力活动

+   现在英特尔的 Skylake 包括**SGX**（参见下面的参考资料）

    +   它提供硬件机制来帮助防御 Iago 攻击

## SGX 威胁模型

+   攻击者控制操作系统

+   攻击者可以观察处理器和内存之间的流量

    +   除了处理器之外的每个组件都是不受信任的

+   英特尔是可信任的

    +   芯片正常工作

    +   私钥没有泄露

+   侧信道无法被利用

**SGX：软件保护扩展**

+   **飞地：**进程内的受信任执行环境

    +   处理器确保飞地内存对操作系统、BIOS 等不可访问

+   **证明**

    +   处理器使用内置于芯片中的私钥对飞地内容进行签名

    +   验证器使用英特尔的公钥来检查签名

+   **密封**

    +   在终止时对飞地进行密封和稍后解封的方案

    +   **待办事项：** 他们是否指的是类似于“分页”或停止，保存到磁盘，然后恢复并继续运行的操作？

### 飞地

+   Haven 论文中的图 1

+   `ECREATE`创建一个空飞地

    +   起始虚拟地址和大小

+   *EPC：* 飞地页面缓存

    +   物理内存中的区域

    +   处理器的内存加密接口

        +   写入/读取到/从 EPC 时进行加密/解密

        +   也受完整性保护

    +   `EADD`用于向飞地添加 EPC 页面

+   处理器维护一个映射（*EPCM*），对于每个 EPC 页面记录：

    +   页面类型（REG，...），飞地 ID，页面的虚拟地址和权限

    +   EPCM 仅对处理器可访问

    +   在每次飞地页面访问时，都要查阅地图

        +   页面是否处于飞地模式？

        +   页面是否属于飞地？

        +   页面是否为访问的虚拟地址？

        +   访问是否符合页面权限？

+   将 EPC 页面分页到外部存储

    +   操作系统执行`EWD`将页面驱逐到缓冲区

        +   加密，版本号等。

    +   操作系统可以将缓冲区写入外部存储

    +   操作系统执行`ELDB`将加密页面加载到 EPC 中

        +   使用版本号检测回滚攻击

起始飞地（`EXTEND`，`EINIT`）：

+   处理器保留了飞地构建方式的加密日志 _ `EXTEND`将 256 字节区域添加到日志

+   日志包含内容（代码，数据，堆栈，堆），每个页面的位置，安全标志

+   `EINIT`以`SIGSTRUCT`作为参数

    +   由密封机构（飞地编写者）签名

    +   包括：飞地的预期签名哈希和飞地所有者的公钥

    +   `EINIT`验证签名和哈希

    +   飞地身份存储在`SECS`中

**证明：** 远程方可以验证飞地是否运行正确的代码

+   飞地使用`EGETKEY`获取其密钥

    +   用于加密和密封的密钥

+   `EREPORT`生成一个签名报告

    +   报告包含日志的哈希和飞地的公钥

        +   公共数据是否在报告中由飞地提供？

    +   此报告可以传达给另一个飞地

    +   接收飞地可以使用飞地中的公钥验证报告

+   *特殊的报价飞地*可以使用处理器的私钥创建一个签名的“报价”

    +   使用组签名密钥，以便无法识别个体处理器

进入/退出飞地：

+   使用 ENTER 和线程控制结构（TCS）进入

+   退出：EEXIT，中断或异常

+   使用 ERESUME 恢复飞地

受保护的银行客户端（假设和简化）

+   **目标：** 防止操作系统窃取用户的密码

+   假设从键盘到飞地有一个安全路径（Intel ME？）

+   客户端下载银行应用程序并运行

+   银行应用程序创建带有代码+数据的飞地

    +   代码包括从键盘读取，SSL 等。

    +   生成一个报价

    +   连接到服务器，建立安全通道（例如 SSL），并发送报价

+   服务器验证报价

    +   服务器知道客户端启动的软件是否正确

    +   即不是某个可能将用户密码通过电子邮件发送给对手的恶意客户端

+   服务器发送挑战

    +   客户端使用密码通过 SSL 响应挑战

    +   飞地内的密码，加密

    +   操作系统无法窃取

+   服务器检查挑战

## SGX 安全讨论

+   评估安全性困难

    +   带有 SGX 的处理器刚刚可用

    +   没有部署经验

+   TCB

    +   处理器

    +   处理器的制造

    +   英特尔的私钥

+   伊阿戈攻击

    +   操作系统能在 enclave 内部读写数据吗？

        +   处理器的 EPC 阻止了这一点

    +   操作系统能重新映射内存吗？

        +   处理器的 EPCM 防止此攻击

    +   操作系统能混淆应用程序吗？

        +   客户端必须小心编写，依赖于少量操作系统功能

        +   客户端需要可靠的随机源来实现 SSL

            +   `RDRAND`

        +   客户端必须能够发送和接收数据包

            +   检查结果

+   侧信道攻击

    +   威胁模型排除了，但在实践中可能存在

    +   超线程

    +   共享 L3 缓存

    +   多插槽

## Haven

+   使用 SGX 在云中安全地执行未修改的 Windows 应用程序

+   安全地意味着不信任云提供商

+   Haven 是一个研究项目

### 威胁模型

+   系统管理员控制云软件

+   远程攻击者可能控制云软件

+   操作系统可能发起“伊阿戈”攻击

    +   可能向 Haven 传递任意值

    +   可能中断 Haven 的执行

+   硬件实现正确

    +   SGX 是正确的

### 计划：受保护的执行

+   在云中运行应用程序，其安全性相当于在自己的硬件上运行应用程序

    +   不信任云软件

+   提供一个应用程序环境，使其能够与不受信任的软件交互

    +   应用程序需要发送数据包

    +   应用程序需要存储文件

    +   ...

    +   应用程序需要操作系统

+   挑战

    +   如何在主机操作系统之上实现操作系统，同时仍然能够抵抗伊阿戈攻击

Haven 建立在两个组件之上

+   英特尔 SGX

+   Drawbridge

    +   在 libOS 实现 Win32 的顶部提供一个小接口

    +   小接口保护主机操作系统免受应用程序影响（类似于本机客户端）

    +   Haven 保护应用程序免受主机操作系统的影响

### Haven 设计（图 2）

+   实现 Drawbridge 的 API，以防范伊阿戈攻击

+   Shield 模块在 enclave 内部实现 API

    +   使用窄、不受信任的 API 与主机操作系统交互

    +   不受信任的 API 是 drawbridge API 的子集（见图 3）

+   在 Shield 和主机内核之间的不受信任的运行时隧道

    +   启动时也需要

+   主机内核包含 SGX 驱动程序和 drawbridge 主机

    +   drawbridge 主机使用 OS 调用实现窄 API

Shield 服务

+   虚拟内存

    +   enclave 从 0 开始（处理应用程序、libos 的空指针引用）

    +   跟踪应用程序/libos 使用的内存页面

    +   从 enclave 中添加/删除内存页面

        +   验证更改是否正确

    +   从不允许主机选择虚拟内存地址

    +   不允许应用程序和 libos 在 enclave 外部分配页面

+   存储

    +   最终实验室

+   线程

    +   用户级调度（例如，以便互斥量起作用）

    +   在启动时将线程复用到固定数量的线程上

        +   在开始时分配固定数量的 TCS

+   杂项

    +   用于可信随机源的 `RDRAND`

    +   没有 fork

    +   没有地址空间随机化

### 讨论

+   Haven 能运行未修改的应用程序吗？

    +   没有 fork--Windows 上的小问题？

    +   不能将 enclave 页面映射到多个虚拟地址

        +   需要修改应用程序

+   安全性？

    +   对不受信任接口进行模糊测试？

## 参考资料

1.  [Iago 攻击](https://cseweb.ucsd.edu/~hovav/dist/iago.pdf "Iago 攻击")

1.  [SGX 概述](http://www.pdl.cmu.edu/SDI/2013/slides/rozas-SGX.pdf "SGX 概述")

1.  [SGX 指令概述](https://software.intel.com/sites/default/files/article/413936/hasp-2013-innovative-instructions-and-software-model-for-isolated-execution.pdf "SGX 指令概述")

1.  [SGX 硬件](https://jbeekman.nl/blog/2015/10/sgx-hardware-first-look/ "SGX 硬件")

1.  [SGX 安全讨论](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/january/intel-software-guard-extensions-sgx-a-researchers-primer/ "SGX 安全讨论")

1.  [抽象桥](http://research.microsoft.com/pubs/141071/asplos2011-drawbridge.pdf "抽象桥")
