# OKWS

**注意：** 这些讲座笔记略有修改，来自 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的笔记。

今天的讲座：如何在 Unix 上构建一个安全的 Web 服务器。我们实验室 Web 服务器 zookws 的设计灵感来自于 OKWS。

## 特权分离

+   大型安全理念

+   将系统分割成各自具有特权的模块

    +   **想法：** 如果一个模块被破坏，那么其他模块就不会被破坏

+   经常使用：

    +   虚拟机（例如，在自己的虚拟机中运行网站）

    +   SSH（分离 sshd、agent）

+   挑战：

    +   模块需要共享

    +   需要操作系统支持

    +   需要仔细使用操作系统正确设置事物

    +   性能

## OKWS

+   特权分离的有趣案例研究

    +   服务之间有很多共享

        +   严格的分区不起作用

    +   大量的代码

+   在 OKcupid 之外并不广泛使用

    +   许多网站都有他们的特权分离计划

    +   但没有描述他们计划的论文

### 背景：Unix 中的安全和保护

+   典型的主体：用户 ID、组 ID（32 位整数）。

    +   每个进程都有一个用户 ID（uid）和一组组 ID（gid + grouplist）。

    +   出于大多是历史原因，一个进程有一个 gid +额外的组列表。

    +   超级用户主体（root）由`uid=0`表示，绕过大多数检查。

+   Unix 中的对象+操作是什么，操作系统如何进行访问控制？

    +   文件、目录。

        +   文件操作：读、写、执行、更改权限，..

        +   目录操作：查找、创建、删除、重命名、更改权限，..

        +   每个 inode 都有一个所有者用户和组。

        +   每个 inode 对于用户、组、其他人都有读、写、执行权限。

        +   通常表示为写入基数 8（八进制）的位向量；

            +   八进制很好用，因为每个数字是 3 位（读、写、执行）。

        +   谁可以更改文件的权限？

            +   只有用户所有者（进程 UID）。

        +   对文件进行硬链接：需要对文件有写权限。

            +   可能的理由：配额。

            +   可能的理由：防止将`/etc/passwd`硬链接到具有全局可写`/var/mail`的`/var/mail/root`。

        +   目录的执行意味着能够查找名称（但不能 ls）。

        +   检查进程打开文件`/etc/passwd`：

            +   必须能够在`/`中查找`'etc'`，在`/etc`中查找`'passwd'`。

            +   必须能够打开`/etc/passwd`（读或读写）。

        +   假设你想要文件对 group1 和 group2 的交集可读。

            +   在 Unix 中是否可能实现这一点？

    +   文件描述符。

        +   文件打开时执行的文件访问控制检查。

        +   一旦进程有一个打开的文件描述符，就可以继续访问。

        +   进程可以传递文件描述符（通过 Unix 域套接字）。

    +   进程。

        +   你可以对一个进程做什么？

            +   调试（ptrace），发送信号，等待退出并获取状态，

        +   调试，发送信号：必须具有相同的 UID（几乎）。

            +   各种例外，在实践中这变得棘手。

        +   等待/获取退出状态：必须是该进程的父进程。

    +   内存。

        +   一个进程通常不能命名另一个进程的内存。

        +   例外：调试机制。

        +   例外：内存映射文件。

    +   网络。

        +   操作。

            +   绑定到一个端口。

            +   连接到某个地址。

            +   读/写连接。

            +   发送/接收原始数据包。

        +   规则：

            +   只有 root（UID 0）可以绑定到低于 1024 的端口；

            +   （例如，任意用户不能在端口 80 上运行 Web 服务器。）

            +   只有 root 可以发送/接收原始数据包。

            +   任何进程都可以连接到任何地址。

            +   只能读取/写入进程具有文件描述符的连接上的数据。

        +   此外，防火墙施加自己的检查，与进程无关。

+   进程的主体是如何设置的？

    +   系统调用：`setuid()`、`setgid()`、`setgroups()`。

    +   只有 root（UID 0）可以调用这些系统调用（粗略估计）。

+   用户 ID、组 ID 列表从哪里获取？

    +   在典型的 Unix 系统上，登录程序以 root（UID 0）身份运行。

    +   检查提供的用户密码是否与`/etc/shadow`中的匹配。

    +   根据`/etc/passwd`找到用户的 UID。

    +   根据`/etc/group`找到用户的组。

    +   在运行用户的 shell 之前调用`setuid()`、`setgid()`、`setgroups()`。

+   在切换到非 root 用户后如何重新获得权限？

    +   可以使用文件描述符传递（但必须编写专门的代码）

    +   内核机制：*setuid/setgid 二进制文件*。

        +   当执行二进制文件时，将进程 UID 或 GID 设置为二进制文件所有者。

        +   通过文件权限中的特殊位指定。

        +   例如，`su` / `sudo` 二进制文件通常是 setuid root。

        +   即使您的 shell 不是 root，也可以运行`"su otheruser"`。

        +   `su` 进程会检查密码，如果正确则以`otheruser`身份运行 shell。

        +   Unix 上有许多这样的程序，因为通常需要 root 权限。

    +   为什么 setuid 二进制文件在安全方面可能是个坏主意？

        +   对手（二进制调用者）操纵进程的许多方法。

        +   在 Unix 中，执行的进程会继承环境变量、文件描述符等。

        +   setuid 程序可能使用的库不够谨慎

        +   历史上存在许多漏洞（例如传递`$LD_PRELOAD`，..）

+   如何防止恶意程序利用 setuid-root 二进制文件？

    +   内核机制：*chroot*

        +   通过路径名打开文件时更改`/`的含义。

        +   不能在 chroot 树之外命名文件（例如 setuid 二进制文件）。

    +   例如，OKWS 使用 chroot 将程序限制在`/var/okws/run`中，..

    +   内核还确保`/../`不允许从 chroot 中逃脱。

    +   为什么只允许 root 使用 chroot？

        +   setuid 二进制文件（如`su`）可能会混淆`/etc/passwd`的内容。

        +   许多内核实现（无意中？）允许递归调用`chroot()`以从 chroot 监狱中逃脱，因此 chroot 对于以 root 身份运行的进程来说不是一种有效的安全机制。

    +   为什么 chroot 没有被修复以限制根进程在该目录中？

        +   Root 可以写入内核内存，加载内核模块，访问磁盘扇区，..

## 背景：传统的 Web 服务器架构（Apache）

+   Apache 运行`N`个相同的进程，处理 HTTP 请求。

+   所有进程都以用户`'www'`身份运行。

+   应用程序代码（例如 PHP）通常在每个`N`个 Apache 进程中运行。

+   任何对操作系统状态（文件、进程等）的访问都由`www`的 UID 执行。

+   存储：SQL 数据库，通常一个连接具有对整个数据库的完全访问权限。

    +   数据库主体是整个应用程序。

+   问题：如果任何组件被攻破，对手将获得所有数据。

+   Web 应用可能会发生哪种攻击？

    +   无意中的数据泄露（获取页面源代码，隐藏文件，..）

    +   远程代码执行（例如，Apache 中的缓冲区溢出）

    +   有 bug 的应用程序代码（难以编写安全的 PHP 代码），例如 SQL 注入

    +   对 Web 浏览器的攻击（跨站脚本攻击）

## 回到 OKWS：他们的应用/动机是什么？

+   约会网站：担心数据保密性。

+   不太担心对手闯入并发送垃圾邮件。

+   大量的服务器端代码执行：匹配，配置文件更新，...

+   必须在用户之间共享（例如匹配）-- 不能只是分区。

+   对整体计划的良好总结：

    +   *"最容易受攻击的方面对攻击者最无用"*

### 为什么这么难？

+   Unix 使降低权限变得棘手（chroot，UID，..）

+   应用程序需要以复杂的方式共享状态。

+   Unix 和 SQL 数据库没有细粒度的共享控制机制。

### OKWS 如何分割 Web 服务器？

+   论文中的图 1。

+   这个 Web 服务器中的请求是如何流动的？

    +   `okd -> oklogd`

        +   `-> pubd`

        +   `-> svc -> dbproxy`

        +   `-> oklogd`

+   这种设计如何映射到物理机器？

    +   可能有许多前端机器（`okld`，`okd`，`pubd`，`oklogd`，`svc`）

    +   几台 DB 机器（`dbproxy`，DB）

### 这些组件如何互动？

+   `okld`为每个服务设置`socketpair`s（双向管道）。

    +   一个用于控制 RPC 请求的套接字对（例如，“获取新的日志套接字对”）。

    +   用于日志记录的一个套接字对（`okld`首先通过 RPC 从`oklogd`获取它）。

    +   对于 HTTP 服务：一个用于转发 HTTP 连接的套接字对。

    +   对于`okd`：HTTP 服务的套接字对的服务器端 FD（HTTP+RPC）。

+   `okd`监听一个单独的套接字以接收控制请求（*repub*，*relaunch*）。

    +   在图 1 中似乎是端口 11277，但在 OKWS 代码中是 Unix 域套接字。

    +   对于*repub*，`okd`与`pubd`通信以生成新模板，

        +   然后通过 RPC 控制通道将生成的模板发送给每个服务。

+   服务通过 TCP 与 DB 代理通信（通过端口号连接）。

### OKWS 如何在图 1 中的组件之间强制隔离？

+   每个服务作为单独的 UID 和 GID 运行。

+   chroot 用于将每个进程限制在单独的目录中（几乎）。

+   组件通过管道（或者说 Unix 域套接字对）进行通信。

+   用于传递 HTTP 连接的文件描述符传递。

+   `okld`的目的是什么？

+   为什么`okld`不同于`okd`？

+   为什么`okld`需要以 root 身份运行？（端口 80，chroot/setuid。）

+   `okld`启动服务需要什么？

    +   创建套接字对

    +   获取新的`oklogd`套接字

    +   `fork`，`setuid/setgid`，`exec`服务

    +   将控制套接字传递给`okd`

+   `oklogd`的目的是什么？

+   `pubd`的目的是什么？

+   为什么我们需要数据库代理？

    +   确保每个服务在受损时无法获取其他数据。

        +   DB 代理协议由应用程序开发人员定义，取决于应用程序的要求。

        +   一个可能常见的代理类型是模板化的 SQL 查询。

        +   代理强制执行整体查询结构（选择、更新），

            +   但允许客户端填写查询参数。

    +   20 字节令牌是从哪里来的？

        +   作为服务的参数传递。

    +   谁检查令牌？

        +   DB 代理有令牌列表（和允许的查询？）。

    +   谁生成令牌？

        +   不清楚；系统管理员手动？

    +   令牌泄露会怎样？

        +   受损组件可能会发出查询。

+   表 1：为什么所有服务和`okld`都在同一个 chroot 中？

    +   这是一个问题吗？

    +   我们如何决定？

        +   那里有哪些可读写文件？

    +   可读性：包含服务代码的共享库。

    +   可写：每个服务都可以写入自己的`/cores/<uid>`。

    +   配置文件在哪里？`/etc/okws_config`，由`okld`保存在内存中。

    +   `oklogd`和`pubd`有单独的 chroots，因为它们具有重要状态：

        +   `oklogd`的 chroot 包含日志文件，希望确保它没有被修改。

        +   `pubd`的 chroot 包含模板，希望避免泄露它们（？）。

+   为什么 OKWS 需要为每个服务单独的 GID？

    +   需要执行二进制文件，但文件所有权允许 chmod。

    +   解决方案：二进制文件由 root 所有，服务是组所有者，模式 0410。

    +   为什么是 0410（用户读取，组执行），而不是 0510（用户读取和执行）？

+   为什么不按用户处理？

    +   每个用户是否严格更好？

    +   用户 X 服务？

    +   对于 okcupid 来说，每个服务的隔离可能是有道理的。

        +   （即，也许他们需要在用户之间进行大量共享？）

    +   每个用户隔离需要为每个用户分配 UID，使`okld`变得复杂。

        +   并降低性能（尽管对于某些用例可能仍然可以接受）。

### OKWS 是否实现了其目标？

+   OKWS 解决了典型 Web 攻击列表中的哪些攻击，以及如何解决？

    +   除了 XSS 之外的大多数问题都已解决。

    +   通过使用专门的模板例程，XSS 在某种程度上得到解决。

+   每个组件被损坏的影响是什么，以及“攻击面”是什么？

    +   `okld`：对 Web 服务器机器的根访问权限，但也许没有对数据库的访问权限。

        +   攻击面：很小（除了 svc 退出之外没有用户输入）。

    +   `okd`：拦截/修改所有用户 HTTP 请求/响应，窃取密码。

        +   攻击面：解析 HTTP 请求的第一行；控制请求。

    +   `pubd`：损坏模板，利用可能利用某些服务中的错误？

        +   攻击面：从 okd 获取模板的请求。

    +   `oklogd`：损坏/忽略/删除/伪造日志条目。

        +   攻击面：来自 okd、okld、svcs 的日志消息。

    +   `service`：向用户发送垃圾，访问 svc 的数据（模块化 dbproxy）。

        +   攻击面：来自用户的 HTTP 请求（+来自 okd 的控制消息）。

    +   `dbproxy`：访问/更改其所连接的数据库中的所有用户数据。

        +   攻击面：来自授权服务的请求。

            +   未经授权服务的请求（易于丢弃）。

+   一旦单个服务被损坏，操作系统内核就成为攻击面的一部分。

    +   Linux 内核漏洞很少见，但每年仍然会出现几次。

+   OKWS 假设开发人员在设计层面做正确的事情（也许在实现层面不是）：

    +   将 Web 应用程序拆分为单独的服务（而不是全部放在一个服务中）。

    +   为 DB 代理定义精确的协议（否则任何服务都可以获取任何数据）。

+   性能？

    +   似乎比大多数替代方案更好。

    +   在负载下性能更好（因此在一定程度上抵抗 DoS 攻击）

+   OKWS 与 Apache 相比如何？

    +   总体而言，更好的设计。

    +   `okld`以 root 身份运行，与 Apache 中没有任何东西相比，但可能不重要。

    +   两者都没有很好的解决客户端漏洞（XSS 等）

+   对手如何试图破坏类似 OKWS 系统？

    +   利用 C++代码中的缓冲区溢出或其他漏洞。

    +   在某个`dbproxy`中找到 SQL 注入攻击。

    +   在服务代码中找到逻辑错误。

    +   发现跨站脚本漏洞。

### OKWS 有多成功？

+   论文中描述的问题仍然相当普遍。

+   okcupid.com 仍在运行 OKWS，但似乎没有被其他网站使用。

+   C++可能不是编写 Web 应用程序的好选择。

    +   对于许多 Web 应用程序，获得 C++性能可能并不关键。

    +   设计应该适用于其他语言（Python 等）。

    +   实际上，6.858 实验室中的`zookws`受 OKWS 启发，运行 Python 代码。

+   对于典型的 Web 应用程序，DB 代理的想法并没有起飞。

    +   但是 DB 代理对于限制服务可以访问的数据至关重要。

    +   为什么？

        +   需要开发人员定义这些 API：额外的工作，会妨碍。

    +   很难提前精确定义允许的 DB 查询。

        +   (尽管如果很困难，可能是安全策略模糊的标志。)

+   Apache 的特权分离工作（尽管仍然难以使用）。

    +   Unix 使非根用户难以操作用户 ID。

    +   性能是一个问题（为每个请求运行一个单独的进程）。

+   `scripts.mit.edu`有类似的设计，以不同的 UID 运行脚本。

    +   主要担心将用户相互隔离。

    +   偏执的 Web 应用程序开发人员可以为每个组件创建单独的锁。

+   敏感系统在更粗粒度上进行分区。

    +   信用卡处理公司将信用卡数据与其他所有数据分开。

    +   使用虚拟机或物理机器隔离来分割应用程序、数据库等。

### 你如何将现代 Web 应用程序框架与 OKWS 集成？

+   需要帮助 okd 找出如何将请求路由到服务。

+   需要实现 DB 代理，或其变体，以保护数据。

    +   取决于应用代码对静态分析的适应性。

    +   或者需要要求程序员为服务注释可以运行的查询。

+   需要确保应用代码可以在单独的进程中运行（可能没问题）。

## 参考资料

+   [`css.csail.mit.edu/6.858/2014/readings/setuid.pdf`](http://css.csail.mit.edu/6.858/2014/readings/setuid.pdf)

+   [`httpd.apache.org/docs/trunk/suexec.html`](http://httpd.apache.org/docs/trunk/suexec.html)
