# 介绍

**注意：**这些讲座笔记略有修改，来源于 2014 年 6.858 课程网站上发布的内容[课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)。

## 什么是安全性？

+   在对手存在的情况下实现某个目标。

    +   许多系统连接到互联网，而互联网上存在对手。

        +   因此，许多系统的设计可能需要考虑安全性。

        +   即，在有对手的情况下系统是否能正常工作？

+   高层次的安全性思考计划：

    +   **政策：**您想要实现的目标。

        +   例如，只有艾丽丝应该读取文件`F`。

        +   *常见目标：*保密性，完整性，可用性。

    +   **威胁模型：**对攻击者可能做什么的假设。

        +   例如可以猜测密码，但无法物理抓取文件服务器。

        +   最好假设攻击者可以做某事。

    +   **机制：**系统提供的旋钮，帮助维护政策。

        +   例如，用户帐户，密码，文件权限，加密。

    +   **最终目标：**在威胁模型内部，对手无法违反政策。

        +   请注意，目标与机制无关。

+   为什么安全性很难？**这是一个负面目标。**

    +   对比：检查是否实现了积极目标很容易，例如，艾丽丝实际上可以读取文件`F`。更难的是检查*没有可能的方式让艾丽丝读取文件`F`*。

        +   你甚至如何开始列举艾丽丝可能读取文件的所有可能方式？艾丽丝可以利用多少层次的漏洞来获取文件`F`的访问权限。

    +   需要保证政策，假设威胁模型。

    +   很难想象攻击者可能如何入侵的所有可能方式。

    +   现实的威胁模型是开放式的（几乎是负面模型）。

    +   最弱的环节很重要。

    +   迭代过程：设计，根据需要更新威胁模型等。

## 如果我们无法实现完美的安全性，那有什么意义呢？

+   在这门课程中，我们将推动每个系统的边界，看看它何时会崩溃。

    +   每个系统可能都会有一些导致妥协的破坏点。

    +   这并不一定意味着系统没有用：这取决于上下文。

    +   重要的是了解系统能做什么，以及系统不能做什么。

+   实际上，必须管理安全风险与收益。

    +   更安全的系统意味着某些妥协的风险（或后果）更小。

    +   不安全的系统可能需要手动审计以检查攻击等。

    +   攻击成本越高，将有更多的对手被阻止。

+   更好的安全性通常使新功能变得实用和安全。

    +   假设你想在系统上运行某些应用程序。

    +   大公司有时会禁止用户在其台式机上安装未经批准的软件，部分原因是出于安全考虑。

    +   浏览器中的 Javascript 是隔离的，这使得运行新代码/应用程序而无需手动检查/批准变得可以接受（或虚拟机，或本地客户端，或更好的操作系统隔离机制）。

    +   同样，VPN 使得减轻允许员工从互联网的任何地方连接到公司网络的风险变得实际可行。

## 出现问题的原因之一：政策问题

+   *例子：* [萨拉·佩林的电子邮件账户](http://en.wikipedia.org/wiki/Sarah_Palin_email_hack "萨拉·佩林的电子邮件被盗")。

    +   雅虎电子邮件账户有用户名、密码和安全问题。

    +   用户可以通过提供用户名和密码登录。

    +   如果用户忘记密码，可以通过回答安全问题来重置。

    +   安全问题有时比密码更容易猜到。

    +   一些对手猜到了萨拉·佩林的高中、生日等信息。

    +   政策总结为：可以使用密码或安全问题登录。

        +   （无法强制执行“只有用户忘记密码，然后...”）

+   *例子：* [马特·霍南在亚马逊、苹果、谷歌等处的账户](http://www.wired.com/gadgetlab/2012/08/apple-amazon-mat-honan-hacking/all/)

    +   Gmail 密码重置：向备用电子邮件地址发送验证链接。

        +   谷歌贴心地打印了备用电子邮件地址的一部分。

        +   马特·霍南的备用地址是他的苹果`@me.com`账户。

    +   苹果密码重置：需要账单地址，信用卡的最后 4 位数字。

        +   地址可能很容易获取，但如何获取用户信用卡号的 4 位数字？

    +   亚马逊：可以向账户添加信用卡，无需密码。

    +   亚马逊密码重置：提供用户的任意一张信用卡号。

        +   哈哈。

    +   亚马逊：不会打印信用卡号... 但会打印最后 4 位数字！

+   *例子：* [Twitter 的`@N`账户劫持。](https://medium.com/p/24eb09e026dd)

    +   对于合法用户来说，有时很难证明他们拥有一个账户！

+   如何解决？

    +   仔细思考政策声明的含义。

    +   一些政策检查工具可以帮助，但需要一种指定不良内容的方法。

    +   在分布式系统中很困难：不知道每个人在做什么。

## 出了什么问题 #2：威胁模型/假设问题

+   *例子：* 未考虑人为因素。

    +   钓鱼攻击。

    +   用户收到一封要求续订电子邮件账户、转账或...的电子邮件。

    +   技术支持接到一个声音很像用户的电话要求重置密码。

        +   ["橡皮管解密"](https://en.wikipedia.org/wiki/Rubber-hose_cryptanalysis)

+   *例子：* 计算假设随时间变化。

    +   麻省理工学院的 Kerberos 系统使用 56 位 DES 密钥，自 20 世纪 80 年代中期以来。

    +   当时，似乎可以假设对手无法检查所有 2⁵⁶ 个密钥。

    +   不再合理：[现在大约需要 100 美元](https://www.cloudcracker.com/dictionaries.html)。

        +   几年前，6.858 期末项目表明可以在一天内获取任何密钥。

+   *例子：* 所有 SSL 证书 CA 都是完全受信任的。

    +   要连接到启用 SSL 的网站，Web 浏览器会验证证书。

    +   证书是服务器主机名和加密密钥的组合，

        +   由某些受信任的证书颁发机构（CA）签名。

    +   浏览器信任的证书颁发机构（CA）长列表（数百个）。

    +   如果任何 CA 受到损害，对手可以拦截 SSL 连接。

        +   为任何服务器主机名创建一个“伪造”证书。

    +   2011 年，两个 CA 受到损害，为许多域（谷歌、雅虎、Tor 等）签发了伪造证书，显然在伊朗使用。

        +   [`en.wikipedia.org/wiki/DigiNotar`](http://en.wikipedia.org/wiki/DigiNotar)

        +   [`en.wikipedia.org/wiki/Comodo_Group`](http://en.wikipedia.org/wiki/Comodo_Group)

    +   2012 年，一家 CA 无意中签发了一个适用于任何域的根证书。

        +   [`www.h-online.com/security/news/item/Trustwave-issued-a-man-in-the-middle-certificate-1429982.html`](http://www.h-online.com/security/news/item/Trustwave-issued-a-man-in-the-middle-certificate-1429982.html)

+   *例子：*假设你的硬件是可信的。

    +   如果 NSA 是你的对手，结果可能并不是一个好的假设。

        +   [`www.schneier.com/blog/archives/2013/12/more_about_the.html`](https://www.schneier.com/blog/archives/2013/12/more_about_the.html)

+   *例子：*假设密码学中有良好的随机性。

    +   需要高质量的随机性来生成无法被猜测的密钥。

    +   问题：嵌入式设备、虚拟机可能没有太多的随机性。

    +   结果，许多密钥相似或容易被猜测攻击。

        +   [挖掘你的 P 和 Q：检测网络设备中普遍存在的弱密钥](https://factorable.net/weakkeys12.extended.pdf)

+   *例子：*颠覆军事操作系统安全。

    +   在 80 年代，军方鼓励研究安全操作系统。

    +   操作系统被破坏的一个意想不到的方式：

        +   对手获取了开发系统的访问权限，修改了操作系统代码。

+   *例子：*颠覆防火墙。

    +   对手可以连接到防火墙后面的不安全无线网络。

    +   对手可以欺骗防火墙后面的用户来禁用防火墙。

        +   可能只需点击链接`http://firewall/?action=disable`就足够了。

        +   或者也许在 CNN.com 购买广告，指向那个 URL（有效）？

+   *例子：*断开与互联网连接的机器安全吗？

    +   Stuxnet 蠕虫通过 USB 驱动器上的特制文件传播。

+   如何解决？

    +   更明确的威胁模型，以了解可能存在的弱点。

    +   更简单、更通用的威胁模型。

    +   更好的设计可能会消除/减少对某些假设的依赖。

        +   例如，不依赖完全信任 CA 的替代信任模型。

        +   例如，不容易受到钓鱼攻击的身份验证机制。

## 问题出在哪里 #3：机制问题--漏洞

+   安全机制中的漏洞（例如，操作系统内核）会导致漏洞。

+   如果应用程序正在执行安全性，应用程序级别的错误会导致漏洞。

+   *例子：*[苹果的 iCloud 密码猜测速率限制。](https://github.com/hackappcom/ibrute)

    +   人们经常选择弱密码；通常可以在几次尝试（1K-1M）后猜中。

    +   大多数服务，包括苹果的 iCloud，会对登录尝试进行速率限制。

    +   苹果的 iCloud 服务有许多 API。

    +   一个 API（“查找我的 iPhone”服务）忘记实现速率限制。

    +   对手可以多次尝试猜测密码。

        +   可能和他们发送数据包的速度一样快：`>> M/day.`

+   *例子：*[花旗集团信用卡网站缺失访问控制检查。](http://www.nytimes.com/2011/06/14/technology/14security.html)

    +   花旗银行允许信用卡用户在线访问他们的账户。

    +   登录页面要求输入用户名和密码。

    +   如果用户名和密码正确，将重定向到账户信息页面。

    +   账户信息页面的 URL 包含一些数字。

    +   结果这些数字与用户的账号相关。

    +   更糟糕的是，服务器没有检查您是否已登录到该帐户。

    +   对手尝试不同的数字，获取不同人的账户信息。

    +   可能是错误的威胁模型：与现实世界不匹配？

        +   如果对手通过浏览器浏览网站，系统是安全的。

        +   如果对手自己合成新的 URL，系统就不安全了。

    +   很难说开发人员是否有错误的威胁模型，或者有错误的机制。

+   *例子：* [安卓的 Java `SecureRandom`弱点导致比特币被盗。](https://bitcoin.org/en/alert/2013-08-11-android)

    +   拥有所有者私钥的任何人都可以花费比特币。

    +   许多安卓上的比特币钱包应用使用了 Java 的`SecureRandom` API。

    +   结果系统有时忘记了给 PRNG 种子！

    +   结果，一些比特币密钥很容易被猜到。

    +   对手搜索可猜测的密钥，花费任何相应的比特币。

+   *例子：* 沙箱中的漏洞（[NaCl](https://developer.chrome.com/native-client)，Javascript，Java 运行时）。

    +   允许对手逃离隔离，执行他们本不应执行的操作。

+   *例子：* Moxie 的 SSL 证书名称检查漏洞

    +   空字节与长度编码。

+   *例子：* 缓冲区溢出（见下文）。

## 案例研究：缓冲区溢出

+   考虑一个网络服务器。

    +   通常情况下，网络服务器的代码负责安全性。

    +   例如，检查可以访问哪些 URL，检查 SSL 客户端证书，..

    +   因此，服务器代码中的漏洞可能导致安全妥协。

+   威胁模型是什么，策略是什么？

    +   假设对手可以连接到网络服务器，提供任何输入。

    +   策略有点模糊：只执行程序员意图的操作？

    +   例如，不希望对手窃取数据，绕过检查，安装后门。

+   考虑来自某个网络服务器的简化示例代码：

`webserver.c:`

```
 int read_req(void) {
        char buf[128];
        int i;
        gets(buf);
        i = atoi(buf);
        return i;
    } 
```

+   编译器在内存布局方面生成了什么？

    +   x86 栈：

        +   栈向下增长。

        +   `%esp`指向栈上最后（最底部）有效的内容。

        +   `%ebp`指向调用者的`%esp`值。

`read_req() stack layout:`

```
 +------------------+
    entry %ebp ----> | .. prev frame .. |
                     |                  |
                     |                  |
                     +------------------+
    entry %esp ----> |  return address  |
                     +------------------+
    new %ebp ------> |    saved %ebp    |
                     +------------------+
                     |     buf[127]     |
                     |       ...        |
                     |      buf[0]      |
                     +------------------+
                     |        i         |
    new %esp ------> +------------------+
                     |       ...        |
                     +------------------+ 
```

+   调用者的代码（比如，`main()`）：

    +   调用`read_req()`

`read_req()`的汇编代码：

```
 push    %ebp
    mov     %esp -> %ebp
    sub     168, %esp        # stack vars, etc
    ...
    mov     %ebp -> %esp
    pop     %ebp
    ret 
```

+   对手如何利用这段代码？

    +   提供长输入，覆盖超出缓冲区的栈上数据。

    +   有趣的数据：返回地址，被`ret`使用。

    +   可以将返回地址设置为缓冲区本身，在其中包含一些代码。

+   对手如何知道缓冲区的地址？

    +   如果一台机器的内存是另一台的两倍会发生什么？

    +   幸运的是对手，虚拟内存使事情更加确定。

    +   对于给定的操作系统和程序，地址通常是相同的。

+   如果栈向上增长，而不是向下，会发生什么？

    +   查看`gets()`的栈帧。

+   一旦对手执行代码，他们可以做什么？

    +   使用进程的任何权限。

    +   经常利用溢出来更容易地进入系统。

        +   最初在 Unix 上，运行 shell `/bin/sh`（因此称为“shell 代码”）。

    +   如果进程以 `root` 或 `Administrator` 运行，可以做任何事情。

    +   即使不是，仍然可以发送垃圾邮件，读取文件（Web 服务器，数据库），..

    +   可以攻击防火墙后面的其他机器。

+   为什么程序员会写出这样的代码？

    +   旧代码，未暴露在互联网上。

    +   程序员没有考虑安全性。

    +   许多标准函数曾经是不安全的（`strcpy`，`gets`，`sprintf`）。

    +   即使是安全版本也有陷阱（`strncpy` 不会在末尾加上空字符）。

+   更一般地说，任何内存错误都可能转化为漏洞。

    +   在释放后继续使用内存（*释放后使用*）。

        +   如果写入，覆盖新的数据结构，例如函数指针。

        +   如果读取，可能会调用一个已损坏的函数指针。

    +   两次释放相同的内存（*双重释放*）。

        +   可能会导致 `malloc()` 之后再次返回相同的内存。

    +   将栈指针递减到栈的末尾之外，进入其他内存。

        +   [利用运行在 Linux 上的 Xorg 服务器中的大内存管理漏洞](http://www.invisiblethingslab.com/resources/misc-2010/xorg-large-memory-attacks.pdf)

    +   一个字节的错误写入可能导致受损。

        +   [glibc __gconv_translit_find() 漏洞](http://www.openwall.com/lists/oss-security/2014/08/26/2)

    +   甚至可能不需要覆盖返回地址或函数指针。

        +   可以足以读取敏感数据，如加密密钥。

        +   可以通过改变一些位来满足需求（例如`int isLoggedIn`，`int isRoot`）。

## 如何避免机制问题？

+   减少安全关键代码的数量。

    +   不要依赖整个应用程序来执行安全性。

    +   将在实验 2 中进行。

+   避免安全关键代码中的错误。

    +   例如，不要使用 `gets()`，而是使用 `fgets()` 可以限制缓冲区长度。

    +   使用常见、经过充分测试的安全机制（*"机制的经济性"*）。

    +   审计这些常见的安全机制（有很多动力这样做）。

    +   避免开发可能存在错误的新的一次性机制。

    +   良好的机制支持多种用途、策略（更有动力进行审计）。

+   常见机制的示例：

    +   操作系统级别的访问控制（但是，通常可以更好）。

    +   网络防火墙（但是，通常可以更好）。

    +   加密，加密协议。
