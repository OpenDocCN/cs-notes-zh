# RSA 的侧信道攻击

**注意：** 这些讲义略有修改自 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html) 上发布的讲义，时间为 2014 年。

## 侧信道攻击

+   历史上，担心电磁信号泄露。[NSA TEMPEST](http://cryptome.org/nsa-tempest.pdf)。

+   广泛地，系统可能需要担心许多意外的方式

+   信息可能会被泄露。

*示例设置：* 服务器（例如，Apache）有一个 RSA 私钥。

+   服务器使用 RSA 私钥（例如，解密来自客户端的消息）。

+   服务器的计算信息泄露给客户端。

已经研究了许多信息泄漏：

+   解密需要多长时间。

+   解密如何影响共享资源（缓存、TLB、分支预测器）。

+   CPU 本身的辐射（射频、音频、功耗等）。

侧信道攻击不一定与加密相关。

+   例如，操作时间与密码中哪个字符不正确有关。

+   或时间与你和某个用户在 Facebook 上有多少共同好友有关。

+   或加载页面在浏览器中需要多长时间（取决于是否被缓存）。

+   或基于点阵打印机的声音恢复打印文本。[参考](https://www.usenix.org/conference/usenixsecurity10/acoustic-side-channel-attacks-printers)

+   但对密码或密钥的攻击通常是最具破坏性的。

对手可以分析信息泄漏，用它来重建私钥。

+   目前，本文描述的系统上的侧信道攻击是罕见的。

    +   例如，Apache web 服务器运行在某个连接到互联网的机器上。

    +   通常存在其他一些漏洞，更容易利用。

    +   慢慢地成为一个更大的关注点：新的侧信道（虚拟机）、更好的攻击。

+   侧信道攻击更常用于攻击受信任/嵌入式硬件。

    +   例如，芯片在智能卡上运行加密操作。

    +   通常这些具有较小的攻击面，没有太多其他方式可以进入。

    +   如论文所述，一些密码协处理器设计用于避免此类攻击。

*"远程时间攻击是实际的"* 论文的贡献是什么？[参考](http://css.csail.mit.edu/6.858/2014/readings/brumley-timing.pdf)

+   时间攻击已知已久。

+   本文：可能通过网络攻击标准的 Apache web 服务器。

+   使用了许多关于时间攻击的先前工作的观察/技术。

+   要理解这是如何工作的，首先让我们看一些 RSA 的内部..

## RSA：高级计划

+   选择两个随机素数，`p` 和 `q`。

    +   让 `n = p*q`。

+   今天一个合理的密钥长度，即 `|n|` 或 `|d|`，是 2048 位。

+   欧拉函数 `phi(n)`：与 `n` 互质的 `Z_n^*` 元素的数量。

    +   **定理** [此处无证明]：`a^(phi(n)) = 1 mod n`，对所有的 `a` 和 `n`。

+   那么，如何加密和解密？

    +   选择两个指数 `d` 和 `e`，使得 `m^(e*d) = m (mod n)`，这

        +   意味着 `e*d = 1 mod phi(n)`。

    +   加密将是 `c = m^e (mod n)`；解密将是 `m = c^d (mod n)`。

+   如何获得这样的 `e` 和 `d`？

    +   对于 `n=pq`，`phi(n) = (p-1)(q-1)`。

    +   如果我们知道`phi(n)`，很容易计算`d=1/e`。[扩展欧几里得算法](http://en.wikipedia.org/wiki/Modular_multiplicative_inverse)

    +   在实践中，选择小的`e`（例如，65537），使加密更快。

+   公钥是`(n, e)`。

+   私钥原则上是`(n, d)`。

    +   **注意：**`p`和`q`必须保密！

    +   否则，对手可以像我们上面做的那样从`e`计算`d`。

    +   知道`p`和`q`对快速解密也很有帮助。

    +   因此，在实践中，私钥也包括`(p, q)`。

RSA 在“安全”使用上有些棘手--如果直接使用 RSA，请小心！

+   密文是可乘的。

    +   `E(a)*E(b) = a^e * b^e = (ab)^e`。

    +   可以让对手操纵加密，生成新的加密。

+   RSA 是确定性的。

    +   加密相同的明文每次都会生成相同的密文。

    +   对手可以知道何时重新加密相同的内容。

+   通常通过在加密前对消息进行“填充”来解决。[OAEP](http://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding)

    +   取明文消息位，加上明文前后的填充位。

    +   加密组合位（总位数必须小于`|n|`位）。

    +   填充包括随机性，以及固定位模式。

    +   有助于检测篡改（例如，密文乘法）。

## 如何实现 RSA？

+   **关键问题：**快速模指数运算。

    +   一般来说，是二次复杂度。

+   两个 1024 位数相乘很慢。

+   计算 1024 位数的模很慢（1024 位除法）。

### 优化 1：赛里斯剩余定理（CRT）。

+   回想一下 CRT 的原理：

    +   如果`x==a1 (mod p)`和`x==a2 (mod q)`，其中`p`和`q`是互质的，

    +   那么就有一个唯一解`x==a (mod pq)`。

        +   并且，有一种高效的算法来计算`a`。

+   假设我们想要计算`m = c^d (mod pq)`。

+   可以计算`m1 = c^d (mod p)`，以及`m2 = c^d (mod q)`。

+   然后使用 CRT 从`m1`、`m2`计算`m = c^d (mod n)`；这是唯一且快速的。

+   计算`m1`（或`m2`）比直接计算`m`快约 4 倍（~二次）。

+   使用 CRT 从`m1`和`m2`计算`m`的速度与忽略不计。

+   因此，大约加速 2 倍。

### 优化 2：重复平方和滑动窗口。

+   计算`c^d`的朴素方法：将`c`乘以自身，`d`次。

+   更好的方法，称为重复平方：

    +   `c^(2x) = (c^x)²`

    +   `c^(2x+1) = (c^x)² * c`

    +   要计算`c^d`，首先计算`c^(floor(d/2))`，然后使用上述方法计算`c^d`。

    +   递归应用，直到计算到`c⁰ = 1`。

    +   平方次数：`|d|`（表示`d`所需的位数）。

    +   乘法次数：`d`中的 1 位数。

+   更好的方法（有时），称为*滑动窗口*：

    +   `c^(2x) = (c^x)²`

    +   `c^(32x+1) = (c^x)³² * c`

    +   `c^(32x+3) = (c^x)³² * c³`

    +   ...

    +   `c^(32x+z) = (c^x)³² * c^z`，通常情况下（其中`z<=31`）。

    +   可以预先计算所有必要的`c^z`幂的表，存储在内存中。

    +   选择 2 的幂常数（例如，32）取决于使用情况。

        +   成本：额外内存，额外时间来预先计算幂。

    +   注意：仅预先计算`c`的奇数次幂（对于偶数使用第一条规则）。

    +   OpenSSL 使用 32（具有 16 个预先计算的条目的表）。

### 优化 3：蒙哥马利表示。

+   每次（平方或乘法后）都进行`mod p`减少是昂贵的。

    +   典型实现：进行长除法，找到余数。

    +   难以避免减少：否则，值会呈指数增长。

+   理念（由彼得·蒙哥马利提出）：在另一种表示中进行计算。

    +   将基数（例如`c`）提前转换为不同的表示。

    +   在这种表示中执行模运算（会更便宜）。

    +   完成后将数字移回原始表示。

    +   理想情况下，减少的节省应超过移位的成本。

+   蒙哥马利表示：将所有内容乘以某个因子 R。

    +   `a mod q <-> aR mod q`

    +   `b mod q <-> bR mod q`

    +   `c = a*b mod q <-> cR mod q = (aR * bR)/R mod q`

    +   每个在蒙哥马利空间中的乘法（或平方）需要除以`R`。

+   蒙哥马利表示中模乘法为何更便宜？

    +   选择`R`使得除以`R`更容易：`R = 2^|q|`（1024 位密钥为`2⁵¹²`）。

    +   因为我们除以`R`，通常不需要进行`mod q`。

        +   `|aR| = |q|`

        +   `|bR| = |q|`

        +   `|aR * bR| = 2|q|`

        +   `|aR * bR / R| = |q|`

    +   如何便宜地除以`R`？

        +   仅当低位为零时才有效。

    +   *观察：* 因为我们关心值`mod q`，所以`q`的倍数并不重要。

    +   *技巧：* 向被除以`R`的数字添加`q`的倍数，使低位为 0。

        +   例如，假设`R=2⁴ (10000)`，`q=7 (111)`，将`x=26 (11010)`除以 R。

        +   `x+2q = (二进制) * 101000`

        +   `x+2q+8q = (二进制) 1100000`

        +   现在，可以轻松地除以`R`：结果是二进制 110（或 6）。

        +   通常，总是可能的：

        +   `q`的最低位为 1（`q`是质数），因此可以"击倒"任何位。

        +   要"击倒"比特`k`，添加`2^k * q`

        +   要击倒低位`l`，添加`q*(l*(-q^-1) mod R)`

        +   然后，除以`R`意味着简单地丢弃低零位。

+   *一个仍未解决的问题：* 结果将会`< R`，但可能会`> q`。

    +   如果结果恰好大于`q`，需要减去`q`。

    +   这被称为"额外减少"。

    +   计算`x^d mod q`时，`Pr[额外减少] = (x mod q) / 2R`。

        +   这里，假设`x`已经处于蒙哥马利形式。

        +   *直觉：* 随着我们乘以更大的数字，将更频繁地溢出。

### 优化 4：高效乘法。

+   如何将 512 位数字相乘？

+   表示：将其分解为 32 位值（或任何硬件支持的值）。

+   Naive 方法：逐对乘以所有 32 位组件。

    +   就像你在纸上逐位相乘数字一样。

    +   如果两个数字分别具有`n`和`m`个组件，则需要`O(nm)`时间。

    +   如果两个数字接近，则为`O(n²)`。

+   **卡拉兹巴乘法：** 假设两个数字具有相同数量的组件。

    +   `O(n^log_3(2)) = O(n¹.585)`时间。

    +   将两个数字（`x`和`y`）分成两个组件（`x1`，`x0`和`y1`，`y0`）。

        +   `x = x1 * B + x0`

        +   `y = y1 * B + y0`

        +   例如，将 64 位数字分成 32 位组件时，`B=2³²`。

    +   Naive: `x*y = x1y1 * B² + x0y1 * B + x1y0 * B + x0y0`

        +   四次乘法：`O(n²)`

    +   更快：`x*y = x1y1 * (B²+B) - (x1-x0)(y1-y0) * B + x0y0 * (B+1)`

        +   ... `= x1y1 * B² + ( -(x1-x0)(y1-y0) + x1y1 + x0y0 ) * B + x0y0`

        +   只需三次乘法，以及几次加法。

    +   递归应用此算法以继续分割为更多的一半。

        +   有时被称为 "递归乘法"。

    +   有意义地更快（没有隐藏的大常数）

        +   对于 1024 位密钥，"`n`" 这里是 16 (512/32)。

        +   `n² = 256`

        +   `n¹.585 = 81`

+   乘法算法需要决定何时使用 Karatsuba 而不是 Naive。

    +   两种情况很重要：*两个大数* 和 *一个大数 + 一个小数*。

    +   OpenSSL：如果组件数量相等，则使用 Karatsuba，否则使用 Naive。

    +   在一些中间情况下，Karatsuba 也可能胜出，但 OpenSSL 忽略了它，

        +   根据这篇论文。

## SSL 如何使用 RSA？

+   服务器的 SSL 证书包含公钥。

+   服务器必须使用私钥来证明其身份。

+   客户端使用服务器的公钥加密后向服务器发送随机位。

+   服务器解密客户端的消息，使用这些位生成会话密钥。

    +   实际上，服务器还验证消息填充。

    +   然而，仍然可以测量直到服务器以某种方式响应的时间。

服务器上 **解密流水线** 的图示：

```
 * CRT             * To Montgomery             * Modular exp
        --> * c_0 = c mod q  --> * c'_0 = c_0*R mod q  --> * m'_0 = (c'_0)^d mod q
       /
      /                                            * Use sliding window for bits
     /                                               * of the exponent d

    c                                              * Karatsuba if c'_0 and q have
                                                     * same number of 32-bit parts
     \
      \                                            * Extra reductions proportional
       \                                             * to ((c'_0)^z mod q) / 2R;
        -->  ...                                     * z comes from sliding window 
```

+   然后，计算 `m_0 = m'_0/R mod q`。

+   然后，使用 CRT 结合 `m_0` 和 `m_1` 得到 `m`。

+   然后验证 `m` 中的填充。

+   最后，以某种方式使用有效载荷（SSL 等）。

## 为 Brumley 论文中描述的攻击设置

+   受害者 Apache HTTPS 网络服务器使用 OpenSSL，在内存中有私钥。

+   连接到斯坦福校园网络。

+   对手控制校园网络上的某些客户端机器。

+   对手向服务器发送特制的消息中的密文。

    +   服务器解密密文，找到垃圾填充，返回错误。

    +   客户端测量响应时间以获取错误消息。

    +   利用响应时间猜测 `q` 的位。

+   总体响应时间大约为 5 毫秒。

    +   请求之间的时间差大约为 10 微秒。

+   什么导致时间变化？

    +   Karatsuba 与 Naive

    +   额外的减少

+   一旦猜测足够多的 `q` 位，就可以因式分解 `n=p*q`，从 `e` 计算 `d`。

+   大约 1M 次查询似乎足以获取 1024 位密钥的 512 位 `p` 和 `q`。

    +   只需猜测 `p` 和 `q` 的前 256 位，然后使用另一种算法。

## Brumley 论文中的攻击

+   查看 *远程定时攻击是可行的* 论文，详细内容请参考末尾的 *参考文献* 部分。

+   让 `q = q_0 q_1 .. q_N`，其中 `N = |q|`（比如，对于 1024 位密钥，假设为 512 位）。

+   假设我们知道 `q` 的高阶位 `j` 个数字（从 `q_0` 到 `q_j`）。

+   构造两个近似值的 `q`，猜测 `q_{j+1}` 是 0 或 1：

    +   `g = q_0 q_1 .. q_j 0 0 0 .. 0`

    +   `g_hi = q_0 q_1 .. q_j 1 0 0 .. 0`

+   让服务器执行模幂运算 (`g^d`) 来猜测。

    +   我们知道 `g` 必然小于 `q`。

    +   如果 `g` 和 `g_hi` 都小于 `q`，花费的时间不应该有太大变化。

    +   如果 `g_hi` 大于 `q`，花费的时间可能会明显变化。

        +   `g_hi mod q` 很小。

        +   较少时间：Montgomery 中减少额外的减少。

        +   更多时间：从卡拉茨巴切换到普通乘法。

    +   知道所花费的时间可以告诉我们 0 还是 1 是正确的猜测。

+   如何让服务器对我们的猜测执行模指数运算？

    +   将我们的猜测发送给服务器，就好像它是随机性的加密。

    +   一个问题：服务器将把我们的消息转换为蒙哥马利形式。

    +   由于蒙哥马利的`R`是已知的，将(`g/R mod n`)作为消息发送给服务器。

+   如何确定时间差应该是正数还是负数？

    +   论文似乎暗示这并不重要：只需寻找大的差异。

    +   图 3a 显示了每个比特猜测的测量时间差异。

    +   卡拉茨巴与普通乘法发生在 32 位边界处。

    +   前 32 位：额外的约简占主导地位。

    +   接下来的位：卡拉茨巴与普通乘法的支配。

    +   在某个时刻，额外的约简再次占主导地位。

+   如果两种效应的时间差抵消会发生什么？

    +   图 3，关键 3。

    +   更大的邻域会稍微改变平衡，揭示非零间隙。

+   论文如何获得准确的测量结果？

    +   客户机使用处理器的时间戳计数器（在 x86 上为`rdtsc`）。

    +   进行多次测量，取中位数值。

        +   不清楚为什么要中位数；最小值似乎才是真正的计算时间。

    +   一个问题：由于滑动窗口，对`g`的乘法相对较少。

    +   解决方案：通过获取与`g`接近的值进行更多的乘法运算（对`g_hi`同样适用）。

    +   具体来说，探测`g`的“邻域”（`g, g+1, .., g+400`）。

+   为什么要探测`g`的 400 个值的邻域，而不是测量`g` 400 次？

    +   考虑我们试图处理的噪音类型。

    +   (1) 与计算无关的噪音（例如中断，网络延迟）。

        +   当我们多次测量相同的事物时，这种情况可能会消失。

        +   参见论文中的图 2a。

    +   (2) 与计算相关的“噪音”。

        +   例如，通过滑动窗口将`g³`和`g_hi³`相乘需要不同的时间。

        +   重复的测量将返回相同的数值。

        +   不会帮助确定是通过`g`还是`g_hi`进行更多的约简。

        +   参见论文中的图 2b。

    +   邻域值平均出第二种噪音。

    +   由于邻域值相邻，仍具有大致相同数量的约简。

## 如何避免这些攻击？

+   解密时间的定时攻击：RSA 盲化。

    +   选择随机的`r`。

    +   将密文乘以`r^e mod n`：`c' = c*r^e mod n`。

    +   由于 RSA 的乘法性质，`c'`是`m*r`的加密。

    +   解密密文`c'`以获取消息`m'`。

    +   将明文除以`r`：`m = m'/r`。

    +   根据布鲁姆利的论文，OpenSSL 的 CPU 开销约为 10%。

+   使所有代码路径在执行时间方面可预测。

    +   困难，编译器将努力消除不必要的操作。

    +   阻止了高效的特殊情况算法。

    +   难以预测执行时间：指令不是固定时间的。

+   我们能否剥夺对精确时钟的访问？

    +   对于我们控制的机器上的单线程攻击者是可以的。

    +   可以向合法计算添加噪音，但攻击者可能会进行平均。

    +   可以对合法计算进行量化，但会有一定的性能成本。

    +   但通过"睡眠"量化，吞吐量仍然可能泄漏信息。

### 我们应该对这些攻击感到多么担忧？

+   开发利用程序相对棘手（但这是一个一次性问题）。

+   可能会注意到服务器上的攻击（许多连接请求）。

    +   尽管在繁忙的 Web 服务器集群上可能不那么容易？

+   对手必须在网络方面靠近。

    +   对于对手来说并不是一个大问题。

    +   可以对更多查询进行平均，共同定位附近（Amazon EC2），

        +   在附近的机器人或浏览器上运行等。

+   对手可能需要知道 OpenSSL 的版本、优化标志等。

    +   依赖这样的防御措施是个好主意吗？

    +   这会带来多大的障碍？

+   如果对手发动攻击，后果相当严重（密钥泄露）。

## 其他类型的时序攻击

+   **用于猜测密码的页面错误时序** [Tenex 系统]

    +   假设内核提供了一个系统调用来检查用户的密码。

        +   逐字节检查密码，当发现不匹配时返回错误。

    +   对手对齐密码，使第一个字节位于页面末尾，

        +   密码的其余部分在下一页。

    +   以某种方式安排第二页被交换到磁盘。

        +   或者完全取消映射下一页（使用等效的`mmap`）。

    +   测量猜测密码时返回错误所需的时间。

        +   如果花费了很长时间，内核必须从磁盘中读取第二页。

            +   或者，如果取消映射，如果崩溃，那么内核会尝试读取第二页。

        +   意味着第一个字符是正确的！

    +   可以在`256*N`次尝试中猜出一个`N`字符的密码，而不是`256^N`次。

+   **缓存分析攻击：** 处理器的缓存由所有进程共享。

    +   例如：访问滑动窗口的一个倍数会将其带入缓存。

    +   在缓存中必然会驱逐其他内容。

    +   恶意进程可能会用大数组填充缓存，观察被驱逐的内容。

    +   根据被驱逐的偏移量猜测指数(`d`)的部分。

+   缓存攻击在"移动代码"中可能会有问题。

    +   在您的桌面或手机上运行的 NaCl 模块、Javascript、Flash 等。

+   **网络流量时序/分析攻击**。

    +   即使数据被加密，其密文大小仍然与明文大小相近。

    +   最近的论文表明可以通过大小、时序推断出许多关于 SSL/VPN 流量的信息。

    +   例如，Fidelity 允许客户通过 SSL 网站管理股票。

        +   网站为每支股票显示某种饼图图像。

        +   用户的浏览器请求所有用户的股票图像。

        +   对手可以枚举所有股票饼图图像，知道大小。

        +   可以根据数据传输的大小推断用户拥有的股票。

    +   类似于本学期早些时候客座讲座中提到的 CRIME 攻击。

## 参考资料

+   [远程时序攻击是实际的](http://css.csail.mit.edu/6.858/2014/readings/brumley-timing.pdf)

+   [为了好玩和利润而缺失缓存](http://css.csail.mit.edu/6.858/2014/readings/ht-cache.pdf)

+   [AES 的高效缓存攻击及对策](http://www.tau.ac.il/~tromer/papers/cache-joc-20090619.pdf)

+   [离开我的笔记本电脑：针对个人电脑的物理侧信道密钥提取攻击](http://www.tau.ac.il/~tromer/papers/handsoff-20140731.pdf)

+   [跨虚拟机侧信道及其用于提取私钥](http://www.cs.unc.edu/~reiter/papers/2012/CCS.pdf)

+   [Ed25519：高速高安全性签名](http://ed25519.cr.yp.to/)
