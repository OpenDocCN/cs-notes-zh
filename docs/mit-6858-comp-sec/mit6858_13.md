# Kerberos

**注意：**这些讲座笔记略有修改自 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的笔记。

## Kerberos 设置

+   分布式架构，从单一的分时系统演变而来。

+   许多提供服务的服务器：远程登录、邮件、打印、文件服务器。

+   许多工作站，一些是公共的，一些是私有的。

+   每个用户登录到自己的工作站，拥有根访问权限。

+   对手可能也有自己的工作站。

+   当时的替代方案：rlogin、rsh。

+   目标：允许用户通过向服务器进行身份验证来访问服务。

+   其他用户信息通过 Hesiod、LDAP 或其他目录分发。

+   广泛使用：Microsoft Active Directory 使用 Kerberos（v5）协议。

## 信任模型是什么？

+   所有用户、客户端、服务器都信任 Kerberos 服务器。

+   其他机器之间没有先验信任。

+   网络是不受信任的。

+   用户信任本地机器。

## Kerberos 架构

+   中央 Kerberos 服务器，被所有各方信任（或至少在 MIT 被所有方信任）。

+   用户、服务器之间有一个他们与 Kerberos 共享的私钥。

+   Kerberos 服务器跟踪每个人的私钥。

+   Kerberos 使用密钥实现客户端、服务器之间的相互*身份验证*。

    +   术语：用户、客户端、服务器。

    +   客户端和服务器知道彼此的名称。

    +   客户端确信自己正在与服务器通信，反之亦然。

+   Kerberos 不提供授权（用户能否访问某些资源）。

    +   应用程序需要决定这一点。

为什么我们需要这个可信的 Kerberos 服务器？

+   用户不需要在每台服务器上设置帐户、密码等。

## 总体架构图

```
 +-----------------------+
                  c, tgs         |                       |
  [ User: Kc ]  <-------->  [ Kerberos ]                 |
       ^      \                  |           Database:   |
       |       \                 |             c: Kc     |
       V        \    s           |             s: Ks     |
 [ Server: Ks ]  \-------->   [ TGS ]                    |
                                 |         KDC           |
                                 +-----------------------+ 
```

## Kerberos 构造

从论文中得到的基本 Kerberos 构造：

+   **票证**，`T_{c,s} = { s, c, addr, timestamp, life, K_{c,s} }`

    +   通常使用`K_s`加密

+   **验证器**，`A_c = { c, addr, timestamp }`

    +   通常使用`K_{c,s}`加密

Kerberos 协议机制：

+   对 Kerberos 数据库有两个接口：“Kerberos”和“TGS”协议。

+   相当相似；少许差异：

    +   在 Kerberos 协议中，可以指定任何`c`、`s`；客户端必须知道`K_c`。

    +   在 TGS 协议中，客户端的名称是隐式的（来自票证）。

    +   客户端只需知道`K_{c,tgs}`来解密响应（而不是`K_c`）。

+   客户端机器最初从哪里获取`K_c`？

    +   对于用户，使用密码派生，实际上是使用哈希函数。

+   为什么我们需要这两个协议？为什么不只使用“Kerberos”协议？

    +   **客户端机器在获得 TGS 票证后可以忘记用户密码。**

    +   我们可以只存储`K_c`并忘记用户密码吗？等效于密码。

命名

+   Kerberos 的关键之处：密钥与主体名称之间的映射。

+   每个主体名称由`(名称、实例、领域)`组成

    +   通常写作`名称.实例@领域`

+   哪些实体有主体？

    +   用户：名称是用户名，实例用于特殊权限（按照惯例）。

    +   服务器：名称是服务名称，实例是服务器的主机名。

    +   TGS：名称是'krbtgt'，实例是领域名称。

+   这些名称在哪里使用/名称在哪里重要？

    +   用户记住他们的用户名。

    +   服务器根据主体名称执行访问控制。

    +   客户端选择他们期望与之交流的主体。

        +   类似于浏览器期望 HTTPS 的特定证书名称

+   何时可以重复使用名称？

    +   对于用户名：确保没有 ACL 包含该名称，很困难。

    +   对于服务器（假设不在任何 ACL 上）：确保用户忘记服务器名称。

    +   必须更改密钥，以确保旧票据对新服务器无效。

## 获取初始票据："Kerberos" 协议

+   客户端发送一对主体名称 `(c, s)`，其中 `s` 通常是 `tgs`。

+   服务器回复 `{ K_{c,s}, { T_{c,s} }_{K_s} }_{K_c}`

+   Kerberos 服务器如何验证客户端？

    +   不需要 -- 愿意回应任何请求。

+   客户端如何验证 Kerberos 服务器？

    +   解密响应并检查票据是否有效。

    +   只有 Kerberos 服务器会知道 `K_c`。

+   这种方式与将密码发送到服务器相比有何优劣之处？

    +   密码不会通过网络发送，但更容易被暴力破解。

+   为什么从 Kerberos/TGS 服务器的响应中两次包含密钥？

    +   响应中的 `K_{c,s}` 给予客户端访问这个共享密钥的权限。

    +   票据中的 `K_{c,s}` 应该让服务器确信密钥是合法的。

**一般弱点：** Kerberos 4 假设加密提供消息完整性。

+   有一些攻击可以让对手篡改密文。

+   没有明确的 MAC 意味着没有明确定义的方法来检测篡改。

+   一次性解决方案：kprop 协议包括校验和，难以匹配。

+   弱点使得对手相对容易“伪造”票据。

    +   参考：http://web.mit.edu/kerberos/advisories/MITKRB5-SA-2003-004-krb4.txt

**一般弱点：** 对手可以发动离线猜测密码攻击。

+   典型密码的熵不高。

+   任何人都可以向 KDC 请求使用用户密码加密的票据。

+   然后尝试离线暴力破解用户密码：易于并行化。

+   更好的设计：要求客户端与服务器互动以进行每次登录尝试。

**一般弱点：** DES 硬编码到设计中，数据包格式。

+   当 DES 变得太弱时，难以切换到另一个加密系统。

+   DES 密钥空间太小：密钥仅为 56 位，2⁵⁶ 并不算大。

+   现在破解 DES 很便宜（$20--$200 通过 https://www.cloudcracker.com/）。

+   对手如何利用这个弱点破解 Kerberos？

## 向服务器进行身份验证："TGS" 协议

+   客户端发送 `( s, {T_{c,tgs}}_{K_tgs}, {A_c}_{K_{c,tgs}} )`

+   服务器回复 `{ K_{c,s}, { T_{c,s} }_{K_s} }_{K_{c,tgs}}`

+   服务器如何根据票据对客户端进行身份验证？

    +   使用服务器的密钥解密票据。

    +   使用 `K_{c,s}` 解密验证器。

    +   只有 Kerberos 服务器可以生成票据（知道 `K_s`）。

    +   只有客户端可以生成验证器（知道 `K_{c,s}`）。

+   为什么票据中包含 `c`？`s`？`addr`？`life`？

    +   服务器可以从票据中提取客户端的主体名称。

    +   Addr 试图防止被盗票据在另一台机器上被使用。

    +   生命周期同样试图限制被盗票据的损害。

+   网络协议如何使用 Kerberos？

    +   使用`K_{c,s}`加密/认证所有消息。

    +   邮件服务器命令、发送到打印机的文档、shell I/O 等。

    +   例如，在邮件服务器协议中的“DELETE 5”。

+   谁生成认证器？

    +   对于每个新连接，客户端。

+   为什么客户端需要发送认证器，除了票据之外？

    +   向服务器证明对手没有重放旧消息。

    +   服务器必须在内存中保留最近的几个认证器，以检测重放。

+   Kerberos 如何使用时间？如果时钟错误会发生什么？

    +   防止被盗票据永久使用。

    +   限制重放缓存的大小。

    +   如果时钟错误，对手可以使用旧票据或重放消息。

+   客户端如何认证服务器？为什么这很重要？

    +   连接到文件服务器：想知道您获取的是合法文件。

    +   解决方案：服务器在接收到客户端的票据和认证器后可以发送`{ timestamp + 1 }_{K_{c,s}}`。

**一般弱点：**相同的密钥`K_{c,s}`用于许多事情

+   对手可以用`K_{c,s}`替换任何消息为其他消息。

+   例如：跨多个会话的消息。

    +   认证器不证明`K_{c,s}`是新鲜的！

    +   对手可以将新的认证器与旧消息拼接在一起。

    +   Kerberos v5 每次都使用新的会话密钥，在认证器中发送。

+   例如：不同方向的消息

    +   Kerberos v4 在数据包中包含了一个方向标志`(c->s 或 s->c)`

    +   Kerberos v5 使用单独的密钥：`K_{c->s}, K_{s->c}`

如果用户连接到错误的服务器（MITM /网络钓鱼攻击的类比）会发生什么？

+   如果服务器拦截数据包，了解用户连接到哪个服务。

+   如果用户意外输入 ssh malicious.server 会发生什么？

    +   服务器了解用户的主体名称。

    +   服务器没有获取用户的 TGS 票据或`K_c`。

    +   无法冒充用户给其他人。

如果 KDC 宕机会发生什么？

+   无法登录。

+   无法获取新票据。

+   可以继续使用现有的票据。

认证到 Unix 系统。

+   访问本地文件、进程时不涉及 Kerberos 协议。

+   如果使用 Kerberos 登录，用户必须呈现合法的票据。

+   如果用户使用用户名/密码（本地或通过 SSH 使用密码）登录会发生什么？

    +   用户知道自己提供的密码是否合法。

    +   服务器毫无所知。

+   服务器可能受到攻击：

    +   用户通过 SSH 连接，输入用户名和密码。

    +   创建看起来合法的 Kerberos 响应，使用密码加密。

    +   服务器无法判断此响应是否真正合法。

+   解决方案（如果服务器保持状态）：服务器需要自己的主体、密钥。

    +   首先获取用户的 TGS，使用用户的用户名和密码。

    +   然后使用 TGS 获取服务器主体的票据。

    +   如果用户伪造了 Kerberos 服务器，第二个票据将不匹配。

在应用程序中使用 Kerberos。

+   论文建议使用特殊函数封装消息，有 3 个安全级别。

+   对应用程序需要适度更改。

    +   对于灵活性、性能很好。

    +   不利于采用。

    +   开发人员很难理解微妙的安全保证。

+   或许更好的抽象：安全通道（SSL/TLS）。

## 更改密码服务（管理界面）

+   Kerberos 协议如何确保客户端知道密码？为什么？

    +   票证中的特殊标志指示使用哪个接口获取它。

    +   更改密码服务仅接受使用`K_c`获得的票证。

    +   确保客户端知道旧密码，不仅仅是拥有票证。

+   客户端如何更改用户的密码？

    +   连接到更改密码服务，将新密码发送到服务器。

## 复制

+   一个主服务器（支持密码更改），零个或多个从服务器。

+   所有服务器都可以发出票证，只有主服务器可以更改密钥。

+   为什么要这样分割？

    +   只有一个主服务器确保一致性：不能有冲突的更改。

+   主服务器定期更新从服务器（在撰写本文时，大约每小时一次）。

    +   更近期的实现具有增量传播：较低的延迟（但不是 0）。

+   这个有多可扩展？

    +   对称加密（DES，AES）很快--在当前硬件上为 O（100MB / sec）。

    +   票证很小，O（100 字节），因此可以支持每秒 1M 张票证。

    +   通过添加从服务器轻松扩展。

+   潜在问题：密码更改需要一段时间才能传播。

+   对手在用户更改密码后仍然可以一段时间使用窃取的密码。

+   要了解如何正确进行复制，请参加 6.824。

## Kerberos 数据库的安全性

+   主服务器和从服务器在这种设计中非常敏感。

+   受损的主/从服务器意味着所有密码/密钥都必须更改。

+   必须物理安全，Kerberos 服务器软件中没有错误，在服务器机器上的任何其他网络服务中也没有错误等。

+   我们能做得更好吗？SSL CA 基础设施略好一些，但并不多。

    +   当我们谈论浏览器安全/HTTPS 时，将更详细地研究它。

+   大多数集中式身份验证系统都遭受这些问题。..并且全球唯一的自由形式名称需要一些受信任的映射机构。

为什么 Kerberos 没有使用公钥加密？

+   当时太慢了：VAX 系统，10MHz 时钟。

+   政府出口限制。

+   专利。

网络攻击。

+   Kerberos 服务器上的离线密码猜测攻击。

    +   Kerberos v5 防止客户端请求任何主体的票证。

    +   必须在请求中包含`{ timestamp }_{K_c}，证明知道 K_c。`

    +   当时仍然容易受到网络嗅探器的密码猜测攻击。

    +   有更好的替代方案：SRP，PAKE。

+   对手可以使用窃取的票证做什么？

+   对手可以使用窃取的`K_c`做什么？

+   对手可以使用窃取的`K_s`做什么？

    +   记住：在 Kerberos 中，两方共享每个密钥（并依赖于它）！

+   如果`K_c`被泄露后密码更改后会发生什么？

    +   可以解密所有后续交换，从初始票证开始

    +   甚至可以解密密码更改请求，获取新密码！

+   如果对手稍后弄清您的旧密码怎么办？

    +   如果对手保存了旧数据包，可以解密所有内容。

    +   可以类似地获取当前密码。

前向保密（避免密码更改问题）。

+   抽象问题：在两方之间建立共享秘密。

+   Kerberos 方法：某人选择秘密，加密并发送。

+   弱点：如果加密密钥被窃取，可以稍后获取秘密。

+   Diffie-Hellman 密钥交换协议：

    +   两方选择自己的秘密部分。

    +   互发消息。

    +   消息不必保密，只需经过身份验证（无篡改）。

    +   两方使用彼此的消息重建共享密钥。

    +   对手无法通过观察网络消息重建密钥。

+   Diffie-Hellman 的细节：

    +   素数 p，生成器 g mod p。

    +   Alice 和 Bob 各自选择一个随机的、秘密的指数（a 和 b）。

    +   Alice 和 Bob 向彼此发送（g^a mod p）和（g^b mod p）。

    +   每个参与方计算（g^(ab) mod p）=（g^a^b mod p）=（g^b^a mod p）。

    +   使用（g^(ab) mod p）作为秘密密钥。

    +   假设离散对数（从（g^a mod p）中恢复 a）很困难。

Kerberos 中的跨域。

+   领域之间共享密钥。

+   Kerberos v4 仅支持成对的跨域（无过境）。

Kerberos 不能解决什么问题？

+   客户端、服务器或 KDC 机器可能会受到威胁。

+   访问控制或组（由服务实现）。

+   微软“扩展”了 Kerberos 以支持组。

    +   实际上用户的组列表包含在票据中。

+   代理问题：Kerberos 中仍然没有很好的解决方案，但 ssh-agent 很好。

+   工作站安全性（可以木马登录，并且实际上确实发生过）。

    +   基于智能卡的方法并没有起飞。

    +   谷歌身份验证器使用的两步验证（基于时间的 OTP）。

    +   共享桌面系统并不那么普遍：每个人都有自己的手机、笔记本电脑，..

后续步骤。

+   Kerberos v5 修复了 v4 中的许多问题（一些被提及），被广泛使用（MS AD）。

+   OpenID 是一个类似的协议，用于 Web 应用程序的身份验证。

    +   通过 HTTP 请求传递类似的消息。
