# 用户认证

**注意：** 这些讲座笔记略有修改，来自 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的内容。

**核心挑战：** 人类用户如何向程序证明其身份？

+   是否有任何完全主导密码的解决方案？

+   乍一看，密码似乎很糟糕。

    +   低熵`-->`容易让攻击者猜到它们。

    +   用于密码的备用安全问题也具有低熵。

    +   用户经常为多个站点使用相同的密码。

+   正如今天课堂上的论文所述，*"密码继续在所有其他终端用户认证方法上占主导地位，这对安全研究人员来说是一个重大尴尬。"*

+   但是...是否实际上有一种认证方案完全主导密码？

+   今天讲座的计划：

    1.  查看当前密码方案的工作原理。

    1.  讨论认证方案的理想属性。

    1.  查看其他认证方案与密码的比较。

## 密码

密码是用户和服务器之间共享的秘密。

+   **天真的实现：** 服务器有一个将用户名映射到明文密码的表。

+   **问题：** 如果攻击者入侵服务器，可以恢复所有用户/密码对。

+   **改进方案：** 服务器存储此表：`user_name --> hash(user_password)`

+   用户客户端向服务器提供明文密码，服务器对明文进行哈希并进行表查找。

+   **优势：** 哈希函数难以反转，因此攻击者难以执行暴力攻击。然而...

+   **问题：** 攻击者不必对所有可能的密码启动低效的暴力搜索 -- 实际用作密码的字符串集相当小！

    +   偏斜分布：前`5000`个密码值覆盖`20%`的用户。

    +   雅虎密码研究：经验法则密码包含`10-20 bits`的熵。

    +   哈希函数优化性能；这有助于攻击者！

        +   *例子：* 一台笔记本电脑可以以每秒约`2M SHA1 ops/sec`的速度计算 SHA1。即使密码具有`20 bits`的熵，也可以每秒破解一个帐户。

+   服务器可以使用计算成本昂贵的*密钥派生函数*（例如，PBKDF2 或 BCrypt）。

    +   这些函数具有可调整的成本，因此它们可以任意缓慢。

    +   例如：可以使哈希成本为 1 秒 -- 比 SHA1 慢`O(1M)`倍。

    +   内部通常使用慢哈希进行重复哈希。

    +   **问题：** 对手可以构建"彩虹表"。

        +   密码到哈希映射表。

        +   计算成本高昂，但允许攻击者之后有效地反转哈希。

        +   为了最大化成本/效益权衡，攻击者只需为常见密码字典构建一个彩虹表。

        +   大致：1 秒昂贵的哈希`|-> 1M 秒 = 10 天`来哈希常见密码。之后，可以非常快速地破解任何密码数据库中的常见密码。

+   **更好的解决方案：** 服务器可以使用*密码盐*。

    +   在密码哈希中输入一些额外的随机性：H(salt, pw)。

    +   盐值从哪里来？它以明文形式存储在服务器上。

    +   **Q：** 如果对手也能破解盐，为什么这样做更好？

    +   **A：** 攻击者无法使用单个彩虹表来检查哈希匹配 -- 相同密码使用不同盐将具有不同的哈希值！

    +   **最佳实践：**

        +   选择一个长的随机盐。

        +   每次用户更改密码时选择一个新的盐。

客户端应该如何将密码传输到服务器？

+   **不好的主意：** 明文发送密码。

+   **稍微好一点：** 通过加密连接发送密码。

    +   **缺点：** 连接可能被假冒服务器的攻击者拦截（加密并不一定意味着服务器已经向客户端进行了身份验证！）。中间人攻击者然后可以使用窃取的密码冒充用户。

        +   **Q：** 如果客户端发送密码的哈希而不是原始密码呢？

        +   **A：** 并不会为我们提供额外的权力，因为哈希仍然可以被攻击者重放。

        +   **故事寓意：** 加密和哈希并不会自动增加安全性 -- 你需要考虑你想要实现的安全性质，并具体的加密和哈希可以实现这些目标的方式。

+   **更好的主意：** 挑战/响应协议。

*例子：*

```
 Client             Server

        Hi, I'm Alice.
       ---------------->

          Challenge C
       <----------------

        H(C || password)
       ----------------->

                     - Server checks whether the
                       response is H(C || password). 
```

+   忽略中间人（MITM）攻击，服务器现在确信用户是 Alice。

+   如果服务器是攻击者并且之前不知道密码，那么攻击者仍然不知道密码。

    +   **Q：** 我们如何防止服务器基于`H()`值进行暴力猜测密码？

    +   **A1：** 昂贵的哈希+盐。

    +   **A2：** 允许客户端也选择一些随机性：防范彩虹表。

+   为了避免在服务器上存储真实密码，使用类似[SRP](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)的协议。

+   **高级思想：** 给定安全参数`g`，客户端计算`v = g^(hash(salt, password))`并将`v`和`salt`发送到服务器。客户端和服务器可以利用对`g`和`v`的共享知识建立临时密钥（该协议利用了攻击者难以执行模`N`下的离散对数的事实；RSA 也利用了这一观察结果）。

+   实施挑战/响应通常意味着改变客户端和服务器。

为了防止暴力破解攻击，我们可以实施*反锤击防御*。

+   *例子：* 限制密码猜测次数；在太多错误猜测后实施超时期。

+   限制猜测速率非常重要，因为密码的熵很低！

    +   许多网站对密码施加要求（例如长度，使用标点等特殊字符）。

    +   实际上，重要的是*熵*！格式要求很少转化为更高的熵。

    +   一个称职的字典攻击者可以模拟密码约束并生成彩虹表；即使有约束，人们仍会选择符合先验字符分布的密码。

    +   *Telepathwords:* [`telepathwords.research.microsoft.com/`](https://telepathwords.research.microsoft.com/)

        +   当您输入潜在的密码字母时，尝试使用启发式猜测下一个字母！

            +   常见密码（例如，通过密码数据库泄漏）

            +   来自网站的流行短语

            +   用户在选择字符时常见的偏见（例如，使用相邻键来输入相邻的密码字符）

+   Kerberos v4 和 v5 在没有预身份验证的情况下容易受到离线猜测的影响：[`www.gnu.org/software/shishi/wu99realworld.pdf`](http://www.gnu.org/software/shishi/wu99realworld.pdf)

    +   任何人都可以向 KDC 请求使用用户密码加密的票证，即 KDC 不会验证请求（尽管响应将使用`K_c`加密）。

    +   攻击者可以尝试暴力破解猜测用户的密码--这很容易并行化。由于票据授予票据具有已知格式，攻击者可以确定解密何时成功。

    +   在 Kerberos v5 中，票证请求者必须在请求中包含`{ timestamp }_{K_c}`，以证明对`K_c`的了解。

**密码恢复**非常重要，但经常被忽视。

+   人们经常关注密码的熵，但如果恢复问题可以用来重置密码，密码认证方案的强度为`min(password_entropy, recovery_question_entropy)`。

+   恢复问题通常很容易被猜到。在一个著名的例子中，有人通过猜测萨拉·佩林的安全问题的答案获得了对她的雅虎地址的访问权限。

    +   固有低熵（*"你最喜欢的颜色是什么？" "你最好朋友的名字是什么？"*）

    +   通过社交媒体资料泄露的答案（*"你最喜欢的电影是什么？"*）

    +   自动生成的问题通常很容易回答（*"5 + 5 等于多少？"*）

## 取代密码的追求

在今天的阅读中，作者提出了一堆可以用来评估认证方案的因素（目标是确定密码是否像它们看起来那样糟糕）。作者考虑了三个高级指标：可用性、部署性和安全性。

+   **可用性：**用户与认证方案交互的难易程度如何？

    +   *易学性：*

        +   "不了解方案的用户可以轻松地弄清楚并学会它。"

        +   这是密码方案如此受欢迎的一个关键原因！

    +   *不经常出现的错误：*

        +   "用户必须执行的登录任务通常在由合法和诚实的用户执行时成功。"

        +   这是用户选择易于猜测密码的重要原因。

    +   *用户可扩展性：*

        +   "使用方案登录数百个帐户不会增加用户的负担。"

        +   ...解释了为什么人们经常重复使用密码或为基本密码创建一个简单的每个站点唯一化方案。

    +   *轻松从认证令牌丢失中恢复：*

        +   密码的优势在于它们易于重置。

    +   *无需携带*

        +   密码的另一个优势。

+   **可部署性：** 将身份验证方法整合到实际系统中有多容易？

    +   *与服务器兼容：*

        +   "在验证者端，该方案与基于文本的密码兼容。提供者不必更改其现有的身份验证设置以支持该方案。"

    +   *与浏览器兼容：*

        +   "用户不必更改他们的客户端以支持该方案。如果方案要求安装插件或任何需要管理员权限的软件，则无法提供这种好处。"

    +   *易访问：*

        +   "能够使用密码的用户不会因残疾或其他身体（非认知）状况而无法使用该方案。"

    +   可部署性非常困难：很难让用户或服务器大规模更新！

    +   密码在这一类别中表现良好，默认情况下，因为作者将“可部署性”定义为系统与当前密码基础设施整合程度。然而，密码在下一个类别中表现不佳……

+   **安全性：** 身份验证方案可以防范哪些攻击？

    +   *对物理观察具有弹性：*

        +   "在观察用户进行一次或多次身份验证后，攻击者无法冒充用户。如果方案只能通过重复观察 10-20 次以上才能被破解，我们授予准弹性对物理观察的方案。攻击包括肩窥、拍摄键盘、录制按键声音或热成像键盘。"

        +   密码未通过此测试，例如，可以通过拍摄键盘或录制按键声音来捕获密码。

    +   *对有针对性的冒充具有弹性：*

        +   "通过利用个人细节（出生日期、亲属姓名等）的知识，熟人（或熟练的调查员）无法冒充特定用户。个人知识问题是在这一点上失败的典型方案。"

        +   作者表示密码是“准抗性”的，因为他们找不到任何研究表明您的朋友或熟人可以轻松猜出您的密码。

    +   *对受限制的猜测具有弹性：*

        +   "一个攻击者的猜测速率受到验证者的限制，不能成功猜测出大部分用户的秘密……缺乏这种好处意味着惩罚那些经常让用户选择的秘密从一个小而众所周知的子集中选择的方案。"

        +   密码失败是因为熵值低 + 分布倾斜。

    +   *对不受限制的猜测具有弹性：*

        +   “只受可用计算资源限制的猜测速率的攻击者无法成功猜测出大部分用户的秘密。例如，如果一个能够尝试每个账户最多 2⁴⁰ 甚至 2⁶⁴ 次猜测的攻击者仍然只能达到不到 1%的账户，我们可能会授予这一好处。缺乏这一好处旨在惩罚那些凭证空间不足以抵御来自一个小而众所周知的子集的暴力搜索的方案。”

        +   密码失败是因为它们具有低熵和偏斜分布。

    +   *对内部观察具有弹性：*

        +   “攻击者无法通过拦截用户设备内的用户输入（例如，通过键盘记录恶意软件）或窃听证明者和验证者之间的明文通信来冒充用户（我们假设攻击者也可以击败 TLS，也许通过 CA）。这惩罚了那些不具备重放抵抗性的方案，无论是因为它们发送静态响应还是因为它们的动态响应对策可以通过少数观察被破解。这一好处假定通用设备（如软件可更新的个人计算机和手机）可能包含恶意软件，但专门用于该方案的硬件设备可以做到无恶意软件。”

        +   密码失败是因为它们是静态令牌：一旦你有了一个，你可以使用它直到它过期或被撤销。

    +   *对网络钓鱼具有弹性：*

        +   “模拟有效验证器的攻击者（包括通过 DNS 操纵）无法收集以后可以用来冒充用户向实际验证器进行身份验证的凭据。这惩罚了允许网络钓鱼者让受害者在类似网站上进行身份验证，然后将收集的凭据用于真正网站的方案。”

        +   密码失败：网络钓鱼攻击非常普遍！

    +   *无信任第三方：*

        +   “该方案不依赖于一个可信任的第三方（除了证明者和验证者），后者在遭受攻击或变得不可信任时，可能会危及证明者的安全或隐私。”

        +   这一属性提出了一个重要观点：如果我们可以信任一个方当来存储密码、运行密码服务器等，许多身份验证问题将变得更容易。然而，单点故障是不好的，因为攻击者可以将所有精力集中在那一点上！

    +   *对其他验证者泄露具有弹性：*

        +   “验证者可能泄露的任何信息都不能帮助攻击者冒充用户向另一个验证者进行身份验证。这惩罚了那些在一个提供者内部欺诈或对一个后端的成功攻击危及用户在其他网站账户的方案。”

            +   这一属性与无信任第三方有关。为了避免中心化故障点，我们希望引入一些分布式身份验证的概念：然而，这是否意味着系统的强度仅取决于其最薄弱的环节？

                +   回想一下 HTTPS，以及一个糟糕的证书颁发机构如何说服浏览器接受任意站点的伪证书。安全性取决于最不安全的 CA 的强度！

            +   作者表示，密码失败是因为人们经常在不同网站上重复使用密码。

## 生物特征识别

**生物特征识别：** 利用个人外貌或行为的独特方面。

+   密钥空间有多大？

    +   *指纹：* ~13.3 位。

    +   *虹膜扫描：* ~19.9 位。

    +   *语音识别：* ~11.7 位。

    +   因此，熵的位数大致与密码相同。

### 生物特征识别与密码

```
 Usability metric     Passwords        Biometrics
    ---                  ---              ---
    Easy-to-learn:       Yes              Yes
    Infrequent errors:   Quasi-yes        No
    Scalable for users:  No               Yes
    Easy recovery:       Yes              No
    Nothing to carry:    Yes              Yes

                       Usability score: 3.5 vs 3    

    Deployability metric Passwords        Biometrics
    ---                  ---              ---
    Server-compatible:   Yes              No
    Browser-compatible:  Yes              No
    Accessible:          Yes              Quasi-yes (entering biometrics is error-prone)    

                       Deployability score: 3 vs 0.5

    Security metric         Passwords        Biometrics
    ---                     ---              ---
    Res-to-Phys-Obs:        No               Yes
    Res-to-Trgtd-Imp:       Quasi-yes        No (e.g., replaying voice recording, lifting fingerprints from surfaces)
    Res-to-Thrtld-Guess:    No               Yes
    Res-to-UnThrtld-Guess:  No               No (key space isn't much bigger than that of passwords)
    Res-to-Internal-Obv:    No               No (captured biometric data can be replayed)
    Res-to-Phishing:        No               No
    No-trusted-3rd-Party:   Yes              Yes
    Res-Other-Ver-Leaks:    No               No (same biometrics are used by all verifiers)

                        Security score: 1.5 vs 3 
```

因此，最终得分是 8 对 6.5。当然，每个类别可以分配非单位权重，但关键是生物特征识别并不明显比密码“更好”！

有些目标似乎很难同时实现。

```
 Memorywise-Effortless + Nothing-to-Carry.
    Memorywise-Effortless + Resilient-to-Theft.
         // Either the user remembers something, or
         // it can be stolen (except for biometrics).

    Server-Compatible + Resilient-to-Internal-Observation.
    Server-Compatible + Resilient-to-Leaks-from-Other-Verifiers.
         // Server compatible means sending a password.
         // Passwords can be stolen on user machine,
         // replayed by one server to another. 
```

## 多因素认证（MFA）：深度防御

+   需要用户使用两种或更多身份验证机制进行身份验证。

+   机制应涉及不同的模态！

    +   您所知道的东西（例如，密码）

    +   您拥有的东西（例如，手机，硬件令牌）

    +   您是什么（例如，生物特征）

+   思路是攻击者必须窃取/破坏多个身份验证机制才能冒充用户（例如，攻击者可能猜测密码，但无法访问用户的手机）。

+   例如：谷歌的双因素认证需要密码加上一个可以通过短信接收授权码的手机。

+   例如：AWS 的双因素认证需要密码和一个“MFA 设备”（运行身份验证应用程序的智能手机，或专用安全令牌或安全卡）。[Amazon MFA](http://aws.amazon.com/iam/details/mfa/)

+   多因素认证是个好主意，但实证研究表明，如果用户除了密码外还提供第二个身份验证因素，用户会选择更弱的密码！

## 家庭作业问题

家庭作业问题的潜在答案是什么？哪些因素很重要？

+   登录公共 Athena 机器？

    +   对内部观察具有弹性：在机器上轻松安装恶意软件。

    +   对物理观察具有弹性？+ MIT ID 可能是一个值得利用的好东西（将其用作智能卡）。

    +   生物特征识别？不受信任的终端，可能不是一个很好的计划。

+   从网吧访问 Facebook？

    +   在这里不是一个好主意使用密码管理器。

    +   数据的敏感程度有多高？

        +   可能被用于认证到其他网站！（要么是“使用 Facebook 登录”，要么是通过回答个人安全问题来重置密码。）

+   从 ATM 取款？

    +   安全性非常重要。

        +   对物理观察具有弹性。

        +   对盗窃具有弹性。

    +   可能是可信的终端：生物特征识别可能值得考虑。（然而，在实践中，银行可能不想信任终端。）

    +   您可能还关心对个别交易进行身份验证！

        +   防止对手使用被盗的凭证进行不同的、由攻击者选择的操作。

        +   例如：也许用户只需使用密码就能查看余额，但如果她想要取款，她就需要使用手机进行双因素认证。

## 结论

论文结论：没有一个认证方案明显优于密码！例如，根据作者的说法，CAP 读卡器在安全性方面得分完美！

+   CAP 读卡器是由万事达卡设计用来保护在线银行交易。

+   用法：

    1.  将您的信用卡插入看起来像手持计算器的 CAP 读卡器中。

    1.  输入 PIN 码（绕过键盘记录器！）。

    1.  读卡器与卡片的嵌入式处理器通信，输出一个 8 位数码，用户将其提供给网站。

*分析：*

```
 CAP reader
        Easy-to-learn:      Yes
        Infrequent errors:  Quasi-yes
        Scalable for users: No (users require card+PIN per verifier)
        Easy recovery:      No
        Nothing to carry:   No
                            Score: 1.5

                            CAP reader
       Server-compatible:   No
       Browser-compatible:  Yes
       Accessible:          No (blind people can't read 8-digit code)
                            Score: 1

                            CAP reader
    Res-to-Phys-Obs:        Yes\
    Res-to-Trgtd-Imp:       Yes \__ One-time codes!
    Res-to-Thrtld-Guess:    Yes /
    Res-to-UnThrtld-Guess:  Yes/
    Res-to-Internal-Obv:    Yes     Dedicated device
    Res-to-Phishing:        Yes     One-time codes
    No-trusted-3rd-Party:   Yes     Each site is its own verifier
    Res-Other-Ver-Leaks:    Yes     One-time codes
                            Score: 8 
```

+   因此，`密码=8`，`CAP 读卡器=10.5`。然而，CAP 读卡器没有占领世界的原因（请参阅低可用性和可部署性得分）。

+   在实践中，可部署性和可用性通常比安全性更重要。

    +   迁移成本（编码+调试工作，用户培训）让开发人员感到紧张！

    +   方案越不可用，用户就越会抱怨（并尝试选择更容易受攻击者攻击的认证令牌）。

+   一些情况可能会给不同的评估指标分配不同的权重。

    +   *例子*：在军事基地上，基于硬件的令牌的安全性优势可能超过可用性和可部署性的问题。
