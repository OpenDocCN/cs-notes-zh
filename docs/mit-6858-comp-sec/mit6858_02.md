# 缓冲区溢出，松散的边界

**注意：** 这些讲座笔记略有修改，来自 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)。

## 缓冲区溢出攻击回顾

在上一讲中，我们看了执行缓冲区溢出攻击的基础知识。该攻击利用了几个观察结果：

+   系统软件通常用 C 编写（操作系统、文件系统、数据库、编译器、网络服务器、命令外壳和控制台实用程序）

+   C 本质上是高级汇编语言，所以...

    +   暴露原始指针到内存

    +   不对数组执行边界检查（因为硬件不这样做，而 C 希望让你尽可能接近硬件）

+   攻击还利用了关于 x86 代码如何工作的架构知识：

    +   栈增长的方向

    +   栈变量的布局（尤其是数组和函数的返回地址）

`read_req.c:`

```
 void read_req() {
      char buf[128];
      int i;
      gets(buf);
      //. . . do stuff w/buf . . .
    } 
```

编译器在内存布局方面生成了什么？x86 栈看起来像这样：

```
 %esp points to the last (bottom-most) valid thing on
  the stack.

  %ebp points to the caller's %esp value.

                     +------------------+
    entry %ebp ----> | .. prev frame .. |
                     |                  |  |
                     |                  |  | stack grows down
                     +------------------+  |
    entry %esp ----> |  return address  |  v
                     +------------------+
    new %ebp ------> |    saved %ebp    |
                     +------------------+
                     |     buf[127]     |
                     |       ...        |
                     |      buf[0]      |
                     +------------------+
    new %esp ------> |        i         |
                     +------------------+ 
```

对手如何利用这段代码？

+   提供长输入，覆盖缓冲区后的栈数据。

+   **关键观察 1：** 攻击者可以覆盖*返回地址*，使程序跳转到攻击者选择的位置！

+   **关键观察 2：** 攻击者可以将返回地址设置为缓冲区本身，在其中包含一些 x86 代码！

攻击者在执行代码后可以做什么？

+   利用进程的任何权限！如果进程以 root 或管理员身份运行，它可以在系统上做任何想做的事情。即使进程不以 root 身份运行，它也可以发送垃圾邮件、读取文件，有趣的是，攻击或破坏防火墙后面的其他机器。

+   嗯，但为什么操作系统没有注意到缓冲区已经溢出？

    +   就操作系统而言，没有发生任何奇怪的事情！请记住，粗略地说，操作系统只在 Web 服务器进行 IO 或 IPC 时才被调用。除此之外，操作系统基本上只是坐下来让程序执行，依靠硬件页表防止进程篡改彼此的内存。然而，页表保护无法防止进程“针对自身”发起的缓冲区溢出，因为溢出的缓冲区、返回地址和所有相关内容都在进程的有效地址空间内。

    +   在本讲座的后面，我们将讨论操作系统*可以*采取的措施使缓冲区溢出更加困难。

## 修复缓冲区溢出

**方法 #1：** 避免 C 代码中的错误。

+   难以或不可能实现。

+   程序员应仔细检查缓冲区、字符串、数组等的大小。特别是，程序员应使用考虑到缓冲区大小的标准库函数（`strncpy()` 而不是 `strcpy()`，`fgets()` 而不是 `gets()` 等）。

+   现代版本的 `gcc` 和 Visual Studio 在程序使用不安全函数（如 gets()）时会发出警告。一般来说，**你不应该忽略编译器警告。** 将警告视为错误！

+   **好处：** 首先避免问题！

+   **坏处：** 很难确保代码是无错误的，特别是如果代码库很大。此外，应用程序本身可能定义不使用`fgets()`或`strcpy()`作为基本操作的缓冲区操作函数。

**方法 2：** 构建工具来帮助程序员找到错误。

+   例如，我们可以使用静态分析在编译之前找到源代码中的问题。想象一下，如果你有这样一个函数：

`foo.c：`

```
 void foo(int *p) {
        int offset;
        int *z = p + offset;
        if(offset > 7){
            bar(offset);
        }
    } 
```

+   通过静态分析控制流，我们可以知道 offset 在未初始化的情况下被使用。

+   `if`语句还限制了我们可能传播到 bar 的偏移量。

+   我们将在后续讲座中更多地讨论静态分析。

+   提供随机输入的“模糊器”可以有效地发现错误。请注意，模糊化可以与静态分析结合以最大化代码覆盖率！

+   **坏处：** 很难证明完全没有错误，尤其是对于像 C 这样的不安全代码。

+   **好处：** 即使是部分分析也是有用的，因为程序应该变得更少有错误。例如，松散的边界检查可能无法捕捉所有内存错误，但它可以检测到许多重要类型。

**方法 3：** 使用内存安全语言（JavaScript，C＃，Python）。

+   **好处：** 通过不向程序员暴露原始内存地址，并通过自动处理垃圾回收来防止内存损坏错误。

+   **坏处：** 低级运行时代码**确实**使用原始内存地址。因此，运行时核心仍然需要正确。例如，*堆喷射攻击*：

    +   [NOZZLE：防御堆喷射代码注入攻击](https://www.usenix.org/legacy/event/sec09/tech/full_papers/ratanaworabhan.pdf)

    +   [撰写利用教程第 11 部分：堆喷射揭秘](https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/)

+   **坏处：** 仍然有很多使用不安全语言（FORTRAN 和 COBOL）的遗留代码。

+   **坏处：** 也许你需要访问低级硬件功能（例如，你正在编写设备驱动程序）

+   **坏处：** 性能比调优良好的 C 应用程序差？

    +   过去是一个更大的问题，但硬件和高级语言变得更好了。

        +   JIT 编译万岁！

        +   [asm.js](http://asmjs.org/faq.html)的性能接近本机 C++性能的 2 倍！

        +   使用谨慎的编码来避免关键路径中的垃圾回收抖动。

        +   也许你是一个不懂得如何选择合适工具的坏人/ *语言沙文主义者*。如果你的任务是 I/O 绑定的，原始计算速度就不那么重要了。另外，不要成为那个用 C 语言编写文本处理程序的笨蛋。

上述 3 种方法都是有效且广泛使用的，但在实践中缓冲区溢出仍然是一个问题。

+   大量/复杂的用 C 语言编写的遗留代码非常普遍。

+   即使是用 C/C++编写的新代码也可能存在内存错误。

尽管存在有缺陷的代码，我们如何减轻缓冲区溢出？

+   在“传统”缓冲区溢出中发生了两件事：

    +   对手控制执行（程序计数器）。

    +   对手执行一些恶意代码。

+   这两个步骤存在哪些困难？

    +   需要覆盖一个代码指针（稍后被调用）。常见目标是使用堆栈上的缓冲区的返回地址。在实践中，任何内存错误都可能起作用。函数指针，C++ vtables，异常处理程序等。

    +   需要一些有趣的代码在进程的内存中。这通常比#1 更容易，因为：

        +   在缓冲区中放置代码很容易，因此

        +   进程中已经包含了许多可能被利用的代码。

        +   然而，攻击者需要将这段代码放在可预测的位置，以便攻击者可以将代码指针设置为指向恶意代码！

### 缓解方法 1：金丝雀（例如，StackGuard，gcc 的 SSP）

+   理念：覆盖代码指针是可以接受的，只要我们在调用之前捕捉到它。

+   较早的一个系统：StackGuard

    +   在进入时在堆栈上放置一个金丝雀，在返回前检查金丝雀值。

    +   通常需要源代码；编译器插入金丝雀检查。

    +   **Q：** 堆栈图中的金丝雀在哪里？ **A：** 金丝雀必须放在堆栈上返回地址的“前面”，这样任何溢出重写返回地址也将重写金丝雀。

`堆栈布局：`

```
 |                  |
                     +------------------+
    entry %esp ----> |  return address  |    ^
                     +------------------+    |
    new %ebp ------> |    saved %ebp    |    |
                     +------------------+    |
                     |     CANARY       |    | Overflow goes
                     +------------------+    | this way.
                     |     buf[127]     |    |
                     |       ...        |    |
                     |      buf[0]      |    |
                     +------------------+
                     |                  | 
```

+   **Q：** 假设编译器总是将金丝雀设为 4 个字节的`'a'`字符。这有什么问题吗？

+   **A：** 对手可以在缓冲区溢出中包含适当的金丝雀值！

+   因此，金丝雀必须要么难以猜测，要么可以容易猜测但仍然能够抵御缓冲区溢出。以下是这些方法的示例。

    +   *"终结符金丝雀"*：四个字节（0，CR，LF，-1）

    +   理念：许多 C 函数将这些字符视为终结符（例如，`gets()`，`sprintf()`）。因此，如果金丝雀与这些终结符之一匹配，那么进一步的写入将不会发生。

    +   在程序初始化时生成随机金丝雀：今天更常见（但是，你需要良好的随机性！）。

堆栈金丝雀不会捕捉到哪些类型的漏洞？

+   在金丝雀之前覆盖函数指针变量。

+   攻击者可以覆盖数据指针，然后利用它进行任意内存写入。

`数据指针示例：`

```
 int *ptr = ...;
    char buf[128];
    gets(buf);  // Buffer is overflowed, and overwrites ptr.
    *ptr = 5;   // Writes to an attacker-controlled address!
              // Canaries can't stop this kind of thing. 
```

+   堆对象溢出（函数指针，C++ vtables）。

+   `malloc`/`free`溢出

`malloc 示例：`

```
 int main(int argc, char **argv) {
        char *p, *q;

        p = malloc(1024);
        q = malloc(1024);
        if(argc >= 2)
            strcpy(p, argv[1]);
        free(q);
        free(p);
        return 0;
    } 
```

+   假设属于`p`和`q`的两个内存块在内存中是相邻/附近的。

+   假设`malloc`和`free`表示内存块如下：

`malloc 内存块：`

```
 +----------------+  
        |                |     
        |   App data     |     
        |                |      Allocated memory block
        +----------------+     
        |   size         |     
        +----------------+  

        +----------------+
        |   size         |
        +----------------+
        |  ...empty...   |
        +----------------+  
        |   bkwd ptr     |     
        +----------------+          
        |   fwd ptr      |      Free memory block
        +----------------+     
        |   size         |     
        +----------------+ 
```

+   因此，在`p`的缓冲区溢出将覆盖`q`内存块中的大小值！为什么这是一个问题？

    +   当`free()`合并两个相邻的空闲块时，需要操作`bkwd`和`fwd`指针...

    +   ...并且指针计算使用大小来确定空闲内存块结构的位置！

`free()`内部： 

```
 p = get_free_block_struct(size);
    bck = p->bk;
    fwd = p->fd;
    fwd->bk = bck;  // Writes memory!
    bck->fd = fwd;  // Writes memory! 
```

+   空闲内存块表示为 C `struct`；通过破坏大小值，攻击者可以强制`free()`在位于攻击者控制的内存中的伪造`struct`上操作，并具有攻击者控制的值用于前向和后向指针。

+   如果攻击者知道`free()`如何更新指针，他可以使用该更新代码将任意值写入任意位置。例如，攻击者可以覆盖返回地址。

    +   实际细节更加复杂；如果你对血腥细节感兴趣，请访问[这里](http://www.win.tue.nl/~aeb/linux/hh/hh-11.html)

    +   高层次的观点是，栈金丝雀不会阻止这种攻击，因为攻击者正在“越过”金丝雀并直接写入返回地址！

### 缓解方法 2: 边界检查

+   **总体目标：** 通过检查指针是否在范围内来防止指针误用。

+   **挑战：** 在 C 语言中，很难区分有效指针和无效指针。例如，假设一个程序分配了一个字符数组... `char x[1024];`

+   ... 以及该数组中的某个位置的指针，例如，`char *y = &x[107];`

+   增加`y`以访问后续元素是否可以？

    +   如果`x`代表一个字符串缓冲区，也许是。

    +   如果`x`代表一个网络消息，也许不。

    +   如果程序使用联合体，情况会变得更加复杂。

`联合体示例:`

```
 union u{
        int i;
        struct s{
            int j;
            int k;
        };
    };

    int *ptr = &(u.s.k); // Does this point to valid data? 
```

+   **问题** 是，在 C 语言中，*指针不会编码关于该指针的预期使用语义的信息*。

+   因此，很多工具不会尝试猜测这些语义。相反，这些工具的目标并不像“完全正确”的指针语义那样高远：这些工具只是强制执行堆对象和栈对象的内存边界。在高层次上，这是目标：

    +   对于从`p`派生出的指针`p'`，`p'`只能被解引用以访问属于`p`的有效内存区域。

+   *强制执行内存边界*是一个比*强制“完全正确”指针语义*更**弱**的目标。程序仍然可以通过恶意方式践踏其内存而自掘坟墓（例如，在联合体示例中，应用程序可能会写入指针，尽管未定义）。

+   然而，边界检查仍然很有用，因为它可以防止*任意*内存覆写。程序只能践踏其内存，如果该内存实际上已分配！*这在 C 语言世界中被认为是进步。*

+   边界检查的一个缺点是通常需要对编译器进行更改，并且必须使用新编译器重新编译程序。如果只能访问二进制文件，则这是一个问题。

#### 有哪些实现边界检查的方法？

**边界检查方法 #1: 电子围栏**

+   这是一个旧方法，其优点在于简单。

+   **思路：** 将每个堆对象与一个守卫页对齐，并使用页表确保对守卫页的访问导致故障。

`电子围栏:`

```
 +---------+
    | Guard   |
    |         |  ^
    +---------+  | Overflows cause a page exception
    |  Heap   |  |
    |  obj    |  |
    +---------+ 
```

+   这是一种方便的调试技术，因为堆溢出会立即导致崩溃，而不是悄无声息地破坏堆并在未来某个不确定的时间导致失败。

+   重要优势：无需源代码即可运行：无需更改编译器或重新编译程序！

    +   你*确实*需要重新链接它们，以便它们使用实现电子围栏的新版本的`malloc`。

+   主要缺点：巨大的开销！每页只有一个对象，并且您有一个未用于“真实”数据的虚拟页面的开销。

+   摘要：电子围栏可以作为调试技术很有用，并且可以防止堆对象的一些缓冲区溢出。然而，电子围栏无法保护堆栈，并且内存开销太高，无法在生产系统中使用。

**边界检查方法＃2：**胖指针

+   **想法：**修改指针表示以包含边界信息。现在，指针包括关于生存在该内存区域中的对象的边界信息。

`示例：`

```
 Regular 32-bit pointer  
     +-----------------+
     | 4-byte address  |
     +-----------------+

    Fat pointer (96 bits)
     +-----------------+----------------+---------------------+
     | 4-byte obj_base | 4-byte obj_end | 4-byte curr_address |
     +-----------------+----------------+---------------------+ 
```

+   您需要修改编译器并重新编译程序以使用胖指针。编译器生成的代码会在它解引用地址超出自己的`base ... end`范围的指针时中止程序。

`示例：`

```
 int *ptr = malloc(sizeof(int) * 2);
        while(1){
            *ptr = 42;       <----------|
            ptr++;                      |
        }                               |
          ______________________________|
         |

    This line checks the current address of the pointer and
    ensures that it's in-bounds. Thus, this line will fail
    during the third iteration of the loop. 
```

+   **问题＃1：**检查所有指针解引用可能很昂贵。C 社区讨厌昂贵的东西，因为 C 就是关于速度速度速度。

+   **问题＃2：**胖指针与许多现有软件不兼容。

    +   你不能将胖指针传递给未修改的库。

    +   你不能在固定大小的数据结构中使用胖指针。例如，`sizeof(that_struct)`将会改变！

    +   *对胖指针的更新不是原子的*，因为它们跨越多个字。一些程序假设指针写入是原子的。

#### 边界检查方法＃3：影子数据结构

**想法：**使用影子数据结构来跟踪边界信息（[Jones and Kelly](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.3156)，[Baggy bounds](https://www.usenix.org/legacy/event/sec09/tech/full_papers/akritidis.pdf)）。

+   对于每个分配的对象，存储对象的大小。例如：

    +   记录传递给 malloc 的值：

        +   `char *p = malloc(mem_size);`

    +   对于静态变量，值由编译器确定：

        +   `char p[256];`

    +   对于每个指针，我们需要对两个操作进行干预：

        1.  指针算术：`char *q = p + 256;`

        1.  指针解引用：`char ch = *q;`

    +   **Q：** 为什么我们需要对解引用进行干预？不能只进行算术吗？

    +   **A：** 无效指针并不总是一个错误！例如，数组最后一个元素之外的一个元素的指针可能被用作循环中的停止测试。应用程序还可以执行一些愚蠢的操作，如：

        +   模拟从 1 开始的数组

        +   计算 p+(a-b)为(p+a)-b

        +   生成稍后检查有效性的 OOB 指针

    +   因此，仅仅创建无效指针不应该导致程序失败。

    +   **Q：** 为什么我们需要对算术进行干预？不能只进行解引用吗？

    +   **A：** 干预算术是允许我们跟踪指针的来源并设置 OOB 位的原因。没有 OOB，我们将无法确定派生指针何时超出其基本对象的边界。

+   **挑战 1:** 我们如何找到常规指针（即在边界内的指针）的边界信息？

    +   *天真:* 使用哈希表或区间树将地址映射到边界。

        +   好: 空间高效（仅存储正在使用的指针的信息，而不是所有可能的地址）。

        +   不好: 查找慢（每次查找多次内存访问）。

    +   *天真:* 使用数组存储*每个*内存地址的边界信息。

        +   好: 快速！

        +   不好: 内存开销很高。

+   **挑战 2:** 我们如何强制越界指针解引用失败？

    +   *天真:* 对每个指针解引用进行检测。

        +   好: 哦，它有效。

        +   不好: 昂贵。我们必须为每次解引用执行额外的代码！

#### Baggy bounds 方法：5 个技巧

+   **Trick 1:** 将每个分配向上舍入为 2 的幂，并将分配的起始对齐到该 2 的幂。

+   **Trick 2:** 将每个范围限制表示为`log_2(alloc_size)`。

    +   对于 32 位指针，只需要 5 位来表示可能的范围：我们只能分配 32 种不同大小的对象：`2¹ = 2 字节，2² = 4 字节...，2³¹ 字节或 2³² 字节`，并且我们存储分配大小的以 2 为底的对数，这是一个介于 1 和 32 之间的数字，因此我们只需要 5 位来表示它。

+   **Trick 3:** 在线性数组中存储限制信息：每个条目一个字节的快速查找。此外，我们可以使用虚拟内存按需分配数组！

+   **Trick 4:** 以插槽粒度（例如，16 字节）分配内存：**更少的数组条目。**

    +   这意味着**最小分配大小**为 16 字节

    +   ...而且，由于指针将对齐到其分配大小边界，这意味着指针的最后 4 位都是零

`示例:`

```
 slot_size = 16

    p = malloc(16);  -->  table[p/slot_size] = 4;
    p = malloc(32);  -->  table[p/slot_size] = 5;
                     \->  table[(p/slot_size) + 1] = 5; 
```

+   **Trick 4 (续):**

    +   现在，给定一个已知的好指针`p`，和一个派生指针`p'`，我们可以通过检查这两个指针的地址位中是否有相同的前缀，并且它们只在它们的`e`个最低有效位上有所不同，其中`e`等于*分配大小*的对数，来测试`p'`是否有效。

`示例:`

```
 C code
    ------ 
    p' = p + i;

    Bounds check
    ------------
    size = 1 << table[p >> log_of_slot_size];
    base = p & ~(size - 1);
    (p' >= base) && ((p' - base) < size)

    Optimized bounds check
    ----------------------
    (p^p') >> table[p >> log_of_slot_size] == 0 
```

+   **Trick 5:** 使用虚拟内存系统来防止越界解引用：在 OOB 指针中设置最高有效位，然后将地址空间上半部分的页面标记为不可访问。这样，我们就不必对指针解引用进行检测以防止错误的内存访问！

**示例代码**（假设`slot_size=16`）

```
 char *p = malloc(44);     //Note that the nearest power of 2 (i.e.,
                              //64 bytes) are allocated. So, there are
                              //64/(slot_size) = 4 bounds table entries
                              //that are set to log_2(64) = 6.

    char *q = p + 60;         //This access is ok: It's past p's object
                              //size of 44, but still within the baggy
                              //bounds of 64.
    char *r = q + 16;         //r is now at an offset of 60+16=76 from
                              //p. This means that r is (76-64)=12 bytes
                              //beyond the end of p. This is more than
                              //half a slot away, so baggy bounds will
                              //raise an error.

    char *s = q + 8;          //s is now at an offset of 60+8=68 from p.
                              //So, s is only 4 bytes beyond the baggy
                              //bounds, which is les than half a slot
                              //away. No error is raised, but the OOB
                              //high-order bit is set in s, so that s
                              //cannot be dereferenced.
    char *t = s - 32;         //t is now back inside the bounds, so
                              //the OOB bit is cleared. 
```

对于 OOB 指针，高位被设置（如果 OOB 在半个插槽内）。- 通常，操作系统内核位于上半部分，通过分页硬件保护自身。- **问:** 为什么越界是半个插槽？

那么作业问题的答案是什么？

```
 char *p = malloc(256);
    char *q = p + 256;
    char ch = *q;  // Does this raise an exception?
                   // Hint: How big is the baggy bound for p? 
```

#### Baggy bounds 论文勘误

Baggy bounds 论文中的一些错误：

+   图 3，显式边界检查应该生成如下大小：

    +   `size = 1 << table[p >> log_of_slot_size]`

+   图 3，优化的边界检查应该是：

    +   `(p^p') >> table[p >> log_of_slot_size] == 0`

+   图 5 和 18，指针算术代码应该是以下之一：

    +   `char *p = &buf[i];`

    +   `char *p = buf + i;`

## Baggy bounds（续）

**注意：** 这些讲座笔记是从 2014 年 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)上发布的笔记中稍作修改而来。

**示例代码：**（假设`slot_size = 16`） 

```
 char *p = malloc(44); // Note that the nearest power of 2 (i.e.,
                          // 64 bytes) are allocated. So, there are
                          // 64/(slot_size) = 4 bounds table entries
                          // that are set to log_2(64) = 6.
    char *q = p + 60;     // This access is ok: It's past p's object
                          // size of 44, but still within the baggy
                          // bounds of 64.
    char *r = q + 16;     // ERROR: r is now at an offset of 60+16=76
                          // from p. This means that r is (76-64)=12
                          // beyond the end of p. This is more than
                          // half a slot away, so baggy bounds will
                          // raise an error.
    char *s = q + 8;      // s is now at an offset of 60+8=68 from p.
                          // So, s is only 4 bytes beyond the baggy
                          // bounds, which is less than half a slot
                          // away. No error is raised, but the OOB
                          // high-order bit is set in s, so that s
                          // cannot be derefernced.
    char *t = s - 32;     // t is now back inside the bounds, so
                          // the OOB bit is cleared. 
```

对于越界指针，高位被设置（如果在半个插槽内越界）。

+   通常，操作系统内核位于上半部分，通过分页硬件保护自身。

+   **Q:** 为什么要为越界分配半个插槽？

那么作业问题的答案是什么？

```
 char *p = malloc(255);
    char *q = p + 256;
    char ch = *q;  // Does this raise an exception?
                   // Hint: How big is the baggy bound for p? 
```

宽松边界检查是否必须检测*每个*内存地址计算和访问？

+   *不*，静态分析可以证明某些地址始终是安全的。但是，某些地址计算是“不安全”的，因为无法静态确定其值的边界。这些不安全的变量需要检查。

处理函数调用参数有点棘手，因为 x86 调用约定是固定的，即硬件期望栈上的某些内容放在特定位置。

+   但是，我们可以将不安全的参数复制到一个单独的区域，并确保复制的参数对齐和受保护。

+   **Q:** 我们是否必须在函数返回时用复制的值覆盖原始参数？

+   **A:** 不，因为在 C 语言中一切都是按值传递的！

### 宽松边界检查如何确保与现有库的二进制兼容性？

特别是，宽松边界代码如何与由未经检测的代码分配的内存指针交互？

+   **解决方案：** 边界表中的每个条目都初始化为值 31，这意味着相应的指针具有 2³¹ 的内存边界（这是所有可寻址内存）。

    +   在*经过检测*的代码中进行内存分配时，边界条目如前所述设置，并在释放内存时重置为 31。

    +   分配给未经检测的代码的内存永远不会改变边界表条目的默认值 31；因此，当经过检测的代码与这些指针交互时，边界错误永远不会发生

*例子：*

```
 Contiguous range of
    memory used for the
    heap

    +-------------------+
    |                   |
    |                   |
    | Heap allocated by |
    |   uninstrumented  |---+
    |       code        |    \      Bounds table
    |                   |     \
    +-------------------+      \   +-----------+
    |                   |       +->|           |
    |                   |          | Always 31 |
    | Heap allocated by |          |           |
    | instrumented code |          +-----------+
    |                   |          | Set using |
    |                   |--------->| baggy bnds|
    +-------------------+          +-----------+ 
```

+   这一切意味着什么？

    +   无法检测在未经检测的代码中生成的越界指针。

    +   无法检测传递给库的越界指针何时再次进入边界内。

        +   **Q:** 为什么？

        +   **A:** 因为未经检测的代码中没有指针检查可以清除高位越界位！

        +   **Q:** 为什么要检测`strcpy()`和`memcpy()`？

        +   **A:** 否则，这些函数就是未经检测的代码，并且会遇到我们刚刚讨论过的相同问题。例如，现成的`strcpy()`不能确保目标有足够的空间来存储源！

### 宽松位如何利用 64 位地址空间？

可以摆脱存储边界信息的表，并将其放入指针中。

```
 Regular pointer       
    +---------------+-------+------------------------+
    |      zero     |  size |   supported addr space |
    +---------------+-------+------------------------+
            21          5             38

  OOB pointer
    +--------+------+-------+------------------------+
    | offset | size |  zero |   supported addr space |
    +--------+------+-------+------------------------+
        13      5       8             38 
```

这类似于一个胖指针，但具有以下优点……

1.  标记指针与常规指针大小相同

1.  对它们的写入是原子的

……以便不破坏程序员的期望，并且数据布局保持不变。

还要注意，使用标记指针，我们现在可以跟踪远离基本指针多得多的越界指针。这是因为现在我们可以使用偏移量标记指针，指示它们距离基本指针有多远。在 32 位世界中，如果没有额外的数据结构，我们无法跟踪越界偏移量！

### 在 baggy bounds 系统中仍然可以发动缓冲区溢出攻击吗？

是的，*因为这个世界充满了悲伤。*

+   可能会利用未经检测的库中的漏洞。

+   可能会利用时间漏洞（使用后释放）。

+   混合缓冲区和代码指针

*例子：*

```
 struct {
        char buf[256];
        void (*f) (void);
    } my_type; 
```

请注意`*f`不是分配的类型，因此在调用期间与其解引用相关联的边界检查不存在。因此，如果`s.buf`溢出（例如，由未经检测的库中的错误引起），并且`s.f`被损坏，那么对`f`的调用不会导致边界错误！

重新排列 f 和 buf 会有帮助吗？

+   可能会破坏依赖结构布局的应用程序。

+   如果这是一个（`struct my_type`）数组，可能不会有帮助。

### 一般来说，边界检查的成本是什么？

+   边界信息的空间开销（胖指针或 baggy bounds 表）。

+   Baggy bounds 还会为 buddy 分配器使用的额外填充内存增加空间开销（尽管所有流行的动态内存分配算法都会有一定程度的开销）。

+   指针算术和解引用的 CPU 开销。

+   虚警！

    +   未使用的越界指针。

    +   临时超出边界指针超过`slot_size/2`。

    +   指针到整数的转换和反向转换。

    +   将越界指针传递给未经检查的代码（高地址位被设置，因此如果未经检查的代码使用该指针进行算术运算，可能会导致混乱）。

+   需要大量编译器支持。

因此，baggy bounds 检查是一种减轻有缺陷代码中缓冲区溢出的方法。

## 实现边界检查的更多方法

### 方法 4：非可执行内存（AMD 的 NX 位，Windows DEP，W^X 等）

+   现代硬件允许为内存指定读取、写入和执行权限。（R、W 权限很久以前就有了；执行权限是最近才有的。）

+   可以将堆栈标记为不可执行，这样对手就无法运行他们的代码。

+   更一般地，一些系统执行“W^X”，意味着所有内存要么可写，要么可执行，但不能同时。 （当然，既不可写也不可执行也是可以的。）

    +   **优势：** 可能无需进行任何应用程序更改即可运行。

    +   **优势：** 硬件一直在监视你，不像操作系统。

    +   **缺点：** 动态生成代码更困难（尤其是使用 W^X）。

        +   像 Java 运行时、Javascript 引擎这样的 JIT 会即时生成 x86 代码。

        +   可以通过先写入，然后更改为可执行来解决问题。

### 方法 5：随机化内存地址（ASLR，堆栈随机化等）

+   观察：许多攻击在 shellcode 中使用硬编码地址！[攻击者抓取一个二进制文件并使用 gdb 来找出东西的位置。]

+   因此，我们可以使攻击者难以猜测有效的代码指针。

    +   堆栈随机化：将堆栈移动到随机位置，并/或在堆栈变量之间放置填充。这使得攻击者更难确定：

        +   当前帧的返回地址位于何处

        +   攻击者的 shellcode 缓冲区将位于何处

    +   随机化整个地址空间（地址空间布局随机化）：随机化堆栈、堆、DLL 的位置等。

        +   依赖于很多代码是可重定位的这一事实。

        +   动态加载器可以为每个库、程序选择随机地址。

        +   对手不知道 system()等函数的地址。

    +   这仍然可以被利用吗？

        +   对手可能猜测随机性。特别是在 32 位机器上，没有太多的随机位（例如，1 位属于内核/用户模式划分，12 位不能被随机化，因为内存映射页面需要与页面边界对齐等）。

        +   例如，攻击者可能进行缓冲区溢出并尝试用`usleep(16)`的地址覆盖返回地址，然后查看连接是否在 16 秒后挂起，或者是否崩溃（在这种情况下，服务器会使用相同的 ASLR 偏移量 fork 一个新的 ASLR 进程）。 `usleep()`可能在 2¹⁶ 或 2²⁸ 个地方之一。[更多细节](https://cseweb.ucsd.edu/~hovav/dist/asrandom.pdf)。

        +   ASLR 在 64 位机器上更实用（很容易有 32 位的随机性）。

+   对手可能提取随机性。

    +   程序可能生成包含指针的堆栈跟踪或错误消息。

    +   如果对手可以运行一些代码，他们可能能够提取真实地址（JIT 编译的代码？）。

    +   Flash 的字典（哈希表）中的可爱地址泄漏：

        +   让受害者访问您的 Flash 启用页面（例如，购买广告）。

        +   哈希表在内部计算键的哈希值。

        +   整数的哈希值是整数本身。

        +   对象的哈希值是其内存地址。

        +   遍历哈希表是从最低哈希键到最高哈希键进行的。

        +   因此，攻击者创建一个字典，插入一个包含 shellcode 的字符串对象，然后向字典中插入一堆数字。

        +   通过遍历字典，攻击者可以确定字符串对象位于何处，看看对象引用落在哪些整数之间！

        +   现在，用 shellcode 地址覆盖代码指针并绕过 ASLR！

+   对手可能不关心确切要跳转到哪里。

    +   例如："堆喷洒"：填充内存以便随机跳转是可以的！

+   对手可能利用一些未随机化的代码（如果存在这样的代码）。

+   随机化的一些其他有趣用途：

    +   系统调用随机化（每个进程有自己的系统调用号码）。

    +   指令集随机化，以便攻击者不能轻易确定特定程序实例的"shellcode"是什么样子。

        +   *例子：* 想象一下，处理器有一个特殊的寄存器来保存“解码密钥”。每个特定应用程序的安装都与一个随机密钥相关联。应用程序中的每条机器指令都与该密钥进行异或运算。当操作系统启动进程时，它设置解码密钥寄存器，处理器使用此密钥解码指令后再执行它们。

### 实际上使用了哪些缓冲区溢出防御措施？

+   gcc 和 MSVC 默认启用栈保护。

+   Linux 和 Windows 默认包含 ASLR 和 NX。

+   由于：

    +   性能开销

    +   需要重新编译程序

    +   误报：安全工具中的常见主题：误报阻止了工具的采用！通常，一些遗漏但没有误报比零遗漏但有误报更好。

## 返回导向编程（ROP）

ASLR 和 DEP 是非常强大的防御技术。

+   DEP 防止攻击者执行自己选择的栈代码。

+   ASLR 可以防止攻击者确定 shellcode 或返回地址的位置。

+   但是，如果攻击者能够找到位于已知位置的具有已知功能的预先存在的代码呢？那么，攻击者可以调用该代码来做坏事。

    +   当然，预先存在的代码并不是*故意*恶意，因为它是应用程序的正常部分。

    +   但是，攻击者可以传递意外的参数给该代码，或者跳转到代码的中间并仅执行该代码的所需部分。

这种攻击称为*返回导向编程*，或*ROP*。为了理解 ROP 的工作原理，让我们看一个具有安全漏洞的简单 C 程序。[示例改编自此处](http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html)。

```
 void run_shell(){
        system("/bin/bash");
    }

    void process_msg(){
        char buf[128];
        gets(buf);
    } 
```

假设系统不使用 ASLR 或栈保护，但使用了 DEP。`process_msg()`存在明显的缓冲区溢出，但攻击者无法利用此溢出在`buf`中执行 shellcode，因为 DEP 使栈不可执行。然而，`run_shell()`函数看起来很诱人... 攻击者如何执行它？

+   攻击者反汇编程序并找出`run_shell()`的起始地址在哪里。

+   攻击者发起缓冲区溢出，并用`run_shell()`的地址覆盖`process_msg()`的返回地址。砰！攻击者现在可以访问以应用程序权限运行的 shell。

*例子：*

```
 +------------------+
    entry %ebp ----> | .. prev frame .. |
                     |                  |  
                     |                  |
                     +------------------+
    entry %esp ----> |  return address  | ^    <--Gets overwritten 
                     +------------------+ |       with address of
    new %ebp ------> |    saved %ebp    | |       run_shell()
                     +------------------+ |
                     |     buf[127]     | |
                     |       ...        | |
                     |      buf[0]      | |
    new %esp ------> +------------------+ 
```

这是我们已经看过的缓冲区溢出的直接扩展。但是我们如何向我们要跳转到的函数传递参数呢？

```
 char *bash_path = "/bin/bash";

   void run_cmd(){
       system("/something/boring");
   }

   void process_msg(){
       char buf[128];
       gets(buf);
   } 
```

在这种情况下，我们要传递的参数已经位于程序代码中。程序中还存在一个对`system()`的调用，但该调用并未传递我们想要的参数。

我们知道`system()`必须与我们的程序链接。因此，使用我们可靠的朋友 gdb，我们可以找到`system()`函数的位置以及 bash_path 的位置。

要使用`bash_path`参数调用`system()`，我们必须设置堆栈，以便在跳转到它时，`system()`期望堆栈上有这些内容：

```
 |        ...       |
                 +------------------+
                 |     argument     |  The system() argument.
                 +------------------+
    %esp ---->   |    return addr   |  Where system() should 
                 +------------------+  ret after it has
                                       finished. 
```

因此，缓冲区溢出需要设置一个看起来像这样的堆栈：

```
 +------------------+
    entry %ebp ----> | .. prev frame .. |
                     |                  |
                     |                  |
                     | *  - - - - - - - | ^
                     |                  | | Address of bash_path 
                     + *  - - - - - - - | |
                     |                  | | Junk return addr for system()
                     +------------------+ |
    entry %esp ----> |  return address  | | Address of system()
                     +------------------+ | 
    new %ebp ------> |    saved %ebp    | | Junk
                     +------------------+ |
                     |     buf[127]     | |
                     |       ...        | | Junk
                     |      buf[0]      | |
    new %esp ------> +------------------+ | 
```

本质上，我们所做的是为`system()`调用设置了一个虚假的调用帧！换句话说，我们模拟了编译器如果真的想要设置一个对`system()`的调用会做什么。

如果字符串`"/bin/bash"`不在程序中怎么办？

+   我们可以将该字符串包含在缓冲区溢出中，然后使`system()`的参数指向该字符串。

    ```
     |    h\0           | ^
                     | *  - - - - - - - | |
                     |    /bas          | |
                     | *  - - - - - - - | |
                     |    /bin          | |  <--------------------+
                     | *  - - - - - - - | |                       |
                     |                  | | Address of bash_path--+
                     + *  - - - - - - - | |
                     |                  | | Junk return addr from system()
                     +------------------+ |
    entry %esp ----> |  return address  | | Address of system()
                     +------------------+ | 
    new %ebp ------> |    saved %ebp    | | Junk
                     +------------------+ |
                     |     buf[127]     | |
                     |       ...        | | Junk
                     |      buf[0]      | |
    new %esp ------> +------------------+ | 
    ```

请注意，在这些示例中，我一直假设攻击者使用了来自`system()`的无用返回地址。然而，攻击者也可以将其设置为有用的内容。

实际上，通过将其设置为有用的内容，攻击者可以链接调用在一起！

**目标：**我们想要多次调用`system("/bin/bash")`。假设我们找到了三个地址：

+   `system()`的地址

+   字符串"/bin/bash"的地址

+   这些 x86 操作码的地址：

    ```
     pop %eax    //Pops the top-of-stack and puts it in %eax
      ret         //Pops the top-of-stack and puts it in %eip 
    ```

这些操作码是“小工具”的一个示例。小工具是预先存在的指令序列，可以串联在一起创建一个利用。请注意，有一些[用户友好的工具](http://www.exploit-db.com/download_pdf/17049/)可以帮助您从现有二进制文件中提取小工具（例如，msfelfscan）。

```
 |                  | ^
                     + *  - - - - - - - + |
                     |                  | | Address of bash_path -+ Fake calling
                     + *  - - - - - - - + |                       | frame for
         (4)         |                  | | Address of pop/ret  * + system()
                     + *  - - - - - - - + | 
         (3)         |                  | | Address of system()
                     + *  - - - - - - - + |
         (2)         |                  | | Address of bash_path -+ Fake calling
                     + *  - - - - - - - + |                       | frame for
         (1)         |                  | | Address of pop/ret  * + system()
                     +------------------+ |
    entry %esp ----> |  return address  | | Address of system()
                     +------------------+ | 
    new %ebp ------> |    saved %ebp    | | Junk
                     +------------------+ |
                     |     buf[127]     | |
                     |       ...        | | Junk
    new %esp ------> |      buf[0]      | |
                     +------------------+ | 
```

那么，这是如何工作的呢？记住，返回指令弹出栈顶并将其放入%eip。

+   溢出的函数通过发出`ret`来终止。`ret`弹出栈顶（`system()`的地址）并将`%eip`设置为它。`system()`开始执行，`%esp`现在在（1），并指向`pop/ret`小工具。

+   `system()`执行完毕并调用`ret`。`%esp`从（1）->（2），因为`ret`指令弹出栈顶并将其分配给`%eip`。`%eip`现在是`pop/ret`小工具的开始。

+   `pop/ret`小工具中的 pop 指令从栈中丢弃`bash_path`变量。`%esp`现在在（3）。我们仍然在`pop/ret`小工具中！

+   `pop/ret`小工具中的`ret`指令弹出栈顶并将其放入`%eip`。现在我们再次在`system()`中，并且`%esp`在（4）。

等等。

基本上，我们创建了一种新类型的机器，它由堆栈指针驱动，而不是常规指令指针！随着堆栈指针沿着堆栈移动，它执行的小工具的代码来自预先存在的程序代码，数据来自缓冲区溢出创建的堆栈数据。

这种攻击规避了 DEP 保护--我们没有生成任何新代码，只是调用了现有的代码！

## 栈读取：打败金丝雀

假设：

+   远程服务器存在缓冲区溢出漏洞。

+   服务器崩溃并重新启动，如果金丝雀值设置为不正确的值。

+   当服务器重新启动时，canary 不会重新随机化，ASLR 也不会重新随机化，例如，因为服务器使用 Linux 的 PIE 机制，并且使用 `fork()` 来创建新的工作进程而不是 `execve()`。

因此，要确定一个 8 字节的 canary 值：

```
 char canary[8];
    for(int i = 1; i <= 8; i++){  //For each canary byte . . .
        for(char c = 0; c < 256; c++){  //. . . guess the value.
            canary[i-1] = c;
            server_crashed = try_i_byte_overflow(i, canary);
            if(!server_crashed){
                //We've discovered i-th byte of the
                //the canary!
                break;
            }
        }
    } 
```

此时我们已经有了 canary，但请记住，该攻击假设服务器在崩溃后使用相同的 canary。

猜测一个字节的正确值平均需要 128 次猜测，因此在 32 位系统上，我们只需要 `4*128=512` 次猜测来确定 canary（在 64 位系统上，我们需要 `8*128=1024` 次）。

+   比在 canary 上进行暴力破解攻击要快得多（在具有 16/28 位 ASLR 随机性的 32/64 位系统上，预期猜测次数为 `2¹⁵` 或 `2²⁷`）。

+   暴力破解攻击可以使用我们之前讨论过的 `usleep(16)` 探测。

+   Canary 读取可以扩展到读取缓冲区溢出可以覆盖的任意值！

因此，我们已经讨论了如果服务器在重新生成时不更改 canaries，我们如何能够击败随机化的 canaries。我们还展示了如何使用 gdb 和 gadgets 来执行程序中预先存在的函数，使用攻击者控制的参数。但是如果服务器使用 ASLR 呢？这将阻止您使用离线分析来找到预先存在的函数的位置？

这就是今天讲座论文讨论的内容。该论文假设我们使用的是 64 位机器，所以从现在开始，在本讲座中我们也将假设如此。在这次讨论中，主要的变化是函数参数现在是通过寄存器传递而不是通过栈传递。

## 盲目返回导向编程

### 步骤 1：找到一个 stop gadget

+   stop gadget 是指指向会挂起程序但不会崩溃的代码的返回地址。

+   一旦攻击者能够击败 canaries，他就可以覆盖溢出函数的返回地址并开始猜测 stop gadget 的位置。如果客户端网络连接突然关闭，猜测的地址不是 stop gadget。如果连接保持打开，那么该 gadget 就是 stop gadget。

### 步骤 2：找到弹出栈中条目的 gadgets

+   一旦你有了一个 stop gadget，你可以用它来找到其他将栈中条目弹出并存入寄存器的 gadgets。

+   定位栈弹出 gadgets 的三个构建块：

    +   *probe:* 潜在的栈弹出 gadget 的地址

    +   *stop:* stop gadget 的地址

    +   *crash:* 非可执行代码的地址（0x0）

*示例:* 找到一个弹出栈中一个元素的 gadget。

```
 sleep(10)
                          ^       ^
    +--- pop rax         /         \
    |    ret            /           \
    |     \--->[stop]  0x5....     0x5....
    |          [trap]  0x0         0x0    <-----------------+
    +----------[probe] 0x4...8     0x4...c -->xor rax, rax  | Crash!
                                              ret           |
                                                 \__________| 
```

当你这样做很多次后，你将拥有一系列弹出栈中一个元素然后返回的 gadgets。然而，你不会知道这些 gadgets 将弹出的值存储在哪个 *寄存器* 中。

+   你需要知道哪些寄存器用于存储数据，以便您可以发出系统调用。每个系统调用都期望其参数在一组特定的寄存器中。

+   请注意，我们也不知道 `syscall()` 库函数的位置。

### 步骤 3：找到 syscall() 并确定 pop gadgets 使用哪些寄存器

+   `pause()`是一个不带参数的系统调用（因此忽略寄存器中的所有内容）。

+   要找到`pause()`，攻击者在栈上链接所有的`"pop x; ret"`小工具，将`pause()`的系统调用号作为每个小工具的"参数"推送进去。在链的底部，攻击者放置了`syscall()`的猜测地址。

    ```
     |                  | ^
                     + *  - - - - - - - + |
                     |                  | | Guessed addr of syscall() 
                     + *  - - - - - - - + | 
                     |                  | | ...
                     + *  - - - - - - - + | 
                     |                  | | Sys call # for pause
                     + *  - - - - - - - + |
                     |                  | | Address of pop rsi; ret //Gadget 2
                     + *  - - - - - - - + | 
                     |                  | | Sys call # for pause
                     +------------------+ |
    entry %esp ----> |  return address  | | Address of pop rdi; ret //Gadget 1
                     +------------------+ | 
    new %ebp ------> |    saved %ebp    | | Junk
                     +------------------+ |
                     |     buf[127]     | |
                     |       ...        | | Junk
    new %esp ------> |      buf[0]      | |
                     +------------------+ | 
    ```

因此，在这个链的末端，弹出小工具已经将`pause()`的系统调用号放入了一堆寄存器中，希望包括`rax`，这是`syscall()`查找系统调用号的寄存器。

一旦这个超级小工具引发了暂停，我们就知道已确定了`syscall()`的位置。现在我们需要确定哪个小工具将栈顶弹出到`rax`中。攻击者可以通过逐步尝试一个小工具并查看是否可以调用`pause()`来弄清楚这一点。

要识别任意的`"pop x; ret"`小工具，可以使用与您试图找到的`x`寄存器相关的其他系统调用的技巧。

因此，这个阶段的结果是知道`"pop x; ret"`小工具，`syscall()`的位置。

### 第 4 步：调用 write()

现在我们想要在服务器与攻击者客户端之间的网络套接字上调用写入调用。我们需要以下小工具：

```
 pop rdi; ret (socket)
    pop rsi; ret (buffer)
    pop rdx; ret (length)
    pop rax; ret (write syscall number)
    syscall 
```

我们必须猜测套接字的值，但这在实践中相当容易，因为 Linux 将进程限制为同时打开 1024 个文件描述符，并且新文件描述符必须是可用的最低文件描述符（因此猜测一个小文件描述符在实践中效果很好）。

要测试我们是否猜对了文件描述符，只需尝试写入并查看是否收到任何内容！

一旦我们有了套接字号码，我们发出一个写入请求，发送的数据是指向程序的`.text`段的指针！这使得攻击者可以读取程序的代码（虽然已随机化，但现在完全为攻击者所知！）。现在攻击者可以直接找到更强大的小工具，并利用这些小工具打开一个 shell。

## 防御 BROP 攻击

+   每次崩溃后重新随机化 canaries 和地址空间！

    +   使用`exec()`代替`fork()`来创建进程，因为`fork()`会将父进程的地址空间复制给子进程。

    +   有趣的是，Windows 不容易受到 BROP 攻击的影响，因为 Windows 没有`fork()`的等效功能。

+   崩溃后休眠？

    +   现在 BROP 攻击是一种拒绝服务攻击！

+   边界检查？

    +   高达 2 倍的性能开销...

## 有关 ROP 和 x86 调用约定的更多信息

+   [x86 调用约定简介](http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html)

+   [返回导向编程简介](http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html)

+   [深入了解 ROP：返回导向编程的快速介绍](http://www.slideshare.net/saumilshah/dive-into-rop-a-quick-introduction-to-return-oriented-programming)

+   [返回导向编程：系统、语言和应用](https://cseweb.ucsd.edu/~hovav/dist/rop.pdf)
