# 嵌套映射

## 序列中的嵌套映射

在前一小节中，我们看到如何结合 `enumerate`、`map`、`filter` 和 `accumulate` 来生成更复杂的函数。在本小节中，我们将探讨一个嵌套映射的例子：在列表上两次调用 `map`。

## 棋盘网格

![](img/checker.png)

Jack 是一个大力支持国际象棋的人。他想要编写一个函数，将一个 4x4 的棋盘上所有的坐标列出来。更具体地说，他想要一个输出如下的函数：

```
( (1 . 1) (1 . 2) (1 . 3) (1 . 4)
  (2 . 1) (2 . 2) (2 . 3) (2 . 4)
  (3 . 1) (3 . 2) (3 . 3) (3 . 4)
  (4 . 1) (4 . 2) (4 . 3) (4 . 4) ) 
```

请注意，坐标被表示为一对 `x` 和 `y` 坐标，并且代码输出了一个这样的坐标列表。我们将逐步介绍 Jack 如何使用我们已经学到的列表操作技术编写这个函数。

## 棋盘网格：第一行

![](img/checker.png)

首先，让我们考虑问题的一个小部分，并逐步解决：让我们编写一些代码，返回来自第一行的坐标列表，即 `( (1 . 1) (2 . 1) (3 . 1) (4 . 1) )`。我们如何实现这个呢？嗯，我们注意到 x 坐标从 1 开始到 4 结束，而 y 坐标始终为 1。因此，如果我们有一个列表 `(1 2 3 4)`，我们可以将每个元素与 1 进行 `cons`。我们可以写成这样：

```
> (map (lambda (x) (cons x 1))
     (enumerate 1 4))
((1 . 1) (2 . 1) (3 . 1) (4 . 1)) 
```

到目前为止一切顺利。Jack 很高兴。

## 棋盘网格：所有行

![](img/checker.png)

所以我们有一些代码返回了第一行的坐标列表。由于只有 4 行，我们可以在技术上为每行都复制一个。

```
(map    (lambda (x) (cons x **1**))
        (enumerate 1 4))

(map    (lambda (x) (cons x **2**))
        (enumerate 1 4))

(map    (lambda (x) (cons x **3**))
        (enumerate 1 4))

(map    (lambda (x) (cons x **4**))
        (enumerate 1 4)) 
```

这一切都很好，但我们知道复制和粘贴代码通常是一个坏主意。（如果棋盘是 1000x1000 呢？）我们想要保留相似的部分，并尽可能地少改变。注意到从 row1、row2、row3 和 row4 的代码中唯一的区别是你与之 `cons` 的数字。我们可以应用之前的方法： 

```
(map (lambda (y) (map (lambda (x) (cons x y))
                      (enumerate 1 4)))
     (enumerate 1 4)) 
```

注意内部 lambda 如何处理单行中的每个瓦片，而外部 lambda 则处理棋盘中的每一行。万岁！我们完成了，对吧？

## 棋盘网格：展开

![](img/checker.png)

运行我们当前代码时，我们得到了这个：

```
> (map (lambda (y)
        (map (lambda (x) (cons x y))
             (enumerate 1 4)))
      (enumerate 1 4))
( ((1 . 1) (2 . 1) (3 . 1) (4 . 1))
  ((1 . 2) (2 . 2) (3 . 2) (4 . 2))
  ((1 . 3) (2 . 3) (3 . 3) (4 . 3))
  ((1 . 4) (2 . 4) (3 . 4) (4 . 4)) ) 
```

这看起来与我们期望的结果非常相似：

```
( (1 . 1) (2 . 1) (3 . 1) (4 . 1)
  (1 . 2) (2 . 2) (3 . 2) (4 . 2)
  (1 . 3) (2 . 3) (3 . 3) (4 . 3)
  (1 . 4) (2 . 4) (3 . 4) (4 . 4) ) 
```

有什么不同吗？我们当前的代码返回了一个坐标列表的列表。我们想要的是一个坐标列表。那么我们如何“展开”这个列表呢？我们可以调用 `accumulate`，并用 `append`：

```
(accumulate append
            nil
            (map (lambda (y)
                    (map (lambda (x) (cons x y))
                (enumerate 1 4))
            (enumerate 1 4)) 
```

## 展平映射

用 `append` 调用 `accumulate` 是如此常见，以至于我们将这个过程实现为 `flatmap`：

```
(define (flatmap proc seq)
  (accumulate append nil (map proc seq))) 
```

使用这个定义，我们最终可以编写出 Jack 想要的函数：

```
(flatmap (lambda (y)
             (map (lambda (x) (cons x y))
                  (enumerate 1 4)))
         (enumerate 1 4)) 
```

## 要点

当你想要遍历某个列表并匹配它们的元素时，嵌套映射是很有用的。为了正确编写函数，强烈建议像我们在这里做的那样将问题分解。`flatmap` 是一个“展平”列表的函数。
