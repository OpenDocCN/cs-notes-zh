# 树递归

## 一个新类的问题

有一些问题我们尚未明确描述递归模式。考虑以下问题：

> 我想爬一段有`n`步的楼梯。每次我可以迈出 1 步或 2 步。我可以以多少种不同的方式爬上这段楼梯？

例如，当`n`为 5 时，有 8 种可能的方式：

`1 1 1 1 1

2 1 1 1

1 2 1 1

1 1 2 1

1 1 1 2

1 2 2

2 1 2

2 2 1`

为了解决这个问题，我们必须引入一种称为*树递归*的模式。树递归只是用来描述在递归情况下多次进行递归调用的短语。为什么我们需要在这里这样做？考虑上面问题的一个解决方案：

```
(define (count-stairs n)
  (cond [(= n 1) 1]
        [(= n 2) 2]
        [else (+ (count-stairs (- n 1))
                 (count-stairs (- n 2)) ]) )) 
```

将程序分解，有三个部分需要考虑

+   有两种基本情况，有两种不同的结果。

    +   如果只有一步要爬，那么只有一种方式（通过迈出那一步）

    +   如果有两步要爬，那么有确切两种方式（一步一步，或者两步）

+   否则，通过将问题分解为两个世界，问题变得更小

    +   在第一个世界中，我们走一步，因此步数减少了一步

    +   在第二个世界中，我们走两步，因此步数减少了两步

+   对这些较小问题进行两次递归调用，我们得到这些较小问题的答案，并将它们相加得到原始问题的答案。

`count-stairs`是*树递归*的，因为每当它被调用时，递归调用会分支出并形成一个倒置的树。例如，`(count-stairs 5)`: ![一个倒置的树](img/(count-stairs 5).png)

## 计算找零

让我们考虑一个更难的问题：

> 有多少种不同的方式可以找零$1.00，给定半美元、25 美分、10 美分、5 美分和 1 美分？更一般地说，我们能否编写一个函数来计算使用任何货币面额的任何给定金额的找零方式数量？

我们以与上面类似的方式解决问题。通过仔细思考问题陈述，我们可以注意到我们必须跟踪两件事：我们当前的金额是多少，以及我们必须使用哪些硬币（我们可以在一个句子中跟踪这一点，例如`'(50 25 10 5 1)`）。从那里，我们可以观察到关于我们基本情况的一些事情：

+   如果金额恰好为 0，我们应该将其视为一种找零的方式

    +   这可能看起来有些违反直觉，但对于$0，有且仅有一种找零的方法--不使用任何硬币。

+   如果金额小于 0，我们应该将其视为 0 种找零的方式。

    +   你不能为负数金额找零！

+   如果我们用完了要使用的硬币，我们应该将其视为 0 种找零的方式。

    +   一旦我们考虑递归情况，这将变得更直观。

对于递归情况，我们再次必须进行两次递归调用。这两次递归调用将我们的问题分成两个世界：

+   在一个世界中，我们使用最大的硬币（`(50 25 10 5 1)`中的`第一个`）

    +   为什么硬币是那个顺序？因为这样更容易推理。句子可以按不同顺序排列，虽然这会影响计算，但不会影响结果。

+   在另一个世界中，我们再也不使用最大的硬币了。

    +   例如，如果我们再也不使用半美元，我们的新句子应该是`(25 10 5 1)`。

当我们将这个转换成代码时，我们得到以下结果：

```
(define (count-change amount)
  (cc amount `(50 25 10 5 1)))

(define (cc amount kinds-of-coins)
  (cond [(= amount 0) 1]
        [(or (< amount 0) (empty? kinds-of-coins)) 0]
        [else (+ (cc amount
                     (bf kinds-of-coins))
                 (cc (- amount
                        (first kinds-of-coins))
                     kinds-of-coins))] )) 
```

## 对于时间效率

树递归过程通常需要指数时间来计算。我们为什么要使用它们呢？

+   有些问题通过递归地思考更容易解决。尝试用另一种语言编写使用 for 循环的找零问题。

+   有些问题非常难以解决，意味着我们已知的最快算法在运行时间上仍然是*指数级*的。

+   结果我们可以优化树递归过程而不改变其形状，这是我们稍后会在课程中涵盖的内容。

## 进一步阅读

+   [SICP 1.2.2 树递归](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.2.2)

+   [SICP 1.2.2 例子：找零问题](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_Temp_52)
