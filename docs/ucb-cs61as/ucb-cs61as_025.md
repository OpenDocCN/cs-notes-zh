# 第 1 课介绍

## 函数式编程

在这节课中，我们将深入探讨函数式编程和递归。一个递归过程通过使问题变得稍微小一些然后调用自身来解决一个大问题。当它调用自身时，它再次使问题变得更小。这种过程一直持续，直到问题变得足够小以至于可以轻松解决。

如果你以前从未使用过递归，递归可能会很难适应。在编写递归程序时要记住的一些事项包括：

1.  记得要有一个基本情况。你的递归应该达到一个不再需要调用自身来获得答案的点。在某个时候，问题应该变得足够简单，只需输出一个答案。

1.  总是让问题变小。每当你进行递归调用时，确保你的参数比开始时要小。如果不是，那么你可能会陷入一些恶性无限循环中。

1.  最后，相信递归！不要过度思考问题。如果你的递归有意义并且遵循了提示 1 和 2，那么你可能有一个有效的代码。你并不总是需要追踪递归以确保你的过程按照你的期望工作。

## 先决条件和预期内容

对于这节课，你应该了解 Racket 的基础知识并掌握正确的语法。

在这节课中，你将学习递归。

## 阅读材料

这节课的相关阅读材料如下：

+   [SICP 1.1 - 编程的要素](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%25_sec_1.1)

+   [讲座笔记](https://docs.google.com/document/d/1_E7HFl1F0L-CCkL3UJfBtdhMwIRuMHuMzy05ByYn7Fk/edit)

如果你想要更多资源，请查看单元 0 的所有阅读材料。

## 函数

在我们讨论计算机科学中的函数之前，让我们先谈谈数学中的函数。在数学中，一个函数 [mathjaxinline]f(x)[/mathjaxinline] 接受一个输入 [mathjaxinline]x[/mathjaxinline]，对这个 [mathjaxinline]x[/mathjaxinline] 做一些"操作"，然后返回一个新值。对于函数接受的每个 [mathjaxinline]x[/mathjaxinline]，它只返回一个值，并且每次都返回*相同的值*。例如，如果 [mathjaxinline]f(x) = x + 2[/mathjaxinline]，每次我们将 4 代入 [mathjaxinline]f(x)[/mathjaxinline]，我们都会得到 6。在任何情况下，我们都不会输入 4 而得到 5、7 或任何不是 6 的值。

在计算机科学中也是一样的！一个函数被定义为一个[过程](https://preview.edge.edx.org/courses/uc-berkeley/cs61as- 1x/SICP/wiki/cs61as-1x/procedure/)，其输出取决于输入--也就是说，当给定某个输入（们）给一个函数时，它每次都返回相同的输出。

```
(define (square x)
  (* x x)) 
```

是一个函数，因为无论我们输入什么，我们总是得到输入乘以它自己。

除了函数外，Racket 还有一种更一般的数据类型称为*过程*。过程类似于函数，但并不一定要对于每个输入返回相同的输出。例如，`square`是一个函数，但`random`不是，因为对于相同的输入，我们每次调用`random`都可能得到不同的输出。

澄清一下：在 Racket 中，**所有函数都是过程，但并非所有过程都是函数**。

以下是本小节涵盖的一些内容：

1.  函数--它们是什么，如何定义它们。

1.  原始过程

1.  特殊形式

接下来呢？

开始下一小节 1！
