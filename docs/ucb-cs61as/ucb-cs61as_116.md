# 第 10 课简介

## 先决条件和期望

在继续之前，您应该了解如何操作列表。考虑复习`map`和`filter`等关键过程。

在本节中，我们将学习有关流及其一些应用的知识。

## 读物

本课程基于[SICP 3.5](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5)。

## 流介绍

我们对赋值作为建模工具有了很好的理解，也对赋值引起的复杂问题有了一定的认识。现在是时候问问我们是否可以以不同的方式去做事情，以避免其中一些问题。在本节中，我们探讨了一种基于称为流的数据结构的替代建模状态的方法。正如我们将看到的，流可以减轻建模状态的一些复杂性。

让我们退一步，回顾这种复杂性的根源。为了模拟现实世界的现象，我们做出了一些看似合理的决定：我们用具有局部变量的计算对象来模拟具有局部状态的现实世界对象。我们将现实世界中的时间变化与计算机中的时间变化相对应。我们通过对模型对象的局部变量进行赋值来实现计算机中模型对象的状态变化。

是否有另一种方法？我们能否避免将计算机中的时间与建模世界中的时间相对应？我们必须使模型随时间变化以模拟变化世界中的现象吗？以数学函数的角度思考这个问题。我们可以将数量 x 随时间的变化行为描述为时间的函数 x(t)。如果我们一瞬间地专注于 x，我们会认为它是一个变化的数量。然而，如果我们专注于值的整个时间历史，我们并不强调变化-函数本身并不改变。

如果时间以离散步骤来衡量，那么我们可以将时间函数建模为（可能是无限的）序列。在本节中，我们将看到如何通过代表被建模系统的时间历史的序列来建模变化。为了实现这一点，我们引入了称为流的新数据结构。从抽象的角度来看，流只是一个序列。然而，我们会发现，将流的直接实现作为列表（如第 2.2.1 节中）并不能充分展现流处理的强大功能。作为替代方案，我们引入了延迟评估技术，这使我们能够将非常大（甚至是无限的）序列表示为流。

流处理使我们能够建模具有状态的系统，而无需使用赋值或可变数据。这具有重要的理论和实际意义，因为我们可以构建避免引入赋值固有缺陷的模型。另一方面，流框架也带来了自己的困难，关于哪种建模技术会导致更模块化和更易维护的系统的问题仍然是开放的。

## 列表效率低下

自第四课以来，我们一直使用列表来表示序列。但是列表表示法也有缺点。操作这些列表序列需要我们的程序在每个步骤中构造和复制数据结构（可能很大）。

让我们看看这个实际操作。这个过程是以我们熟悉和喜爱的迭代风格编写的：

```
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0)) 
```

这个第二个过程利用了`accumulate`、`filter`和`enumerate-interval`。

```
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b)))) 
```

在进行计算时，第一个程序只需要存储正在累积的总和。相比之下，第二个程序中的`filter`在`enumerate-interval`构造完整个区间的数字列表之前无法进行任何测试。`filter`生成另一个列表，然后传递给`accumulate`，最后被折叠成一个总和。

第一个程序不需要这样大的中间存储，我们可以将其视为逐步枚举间隔，每生成一个质数就将其加到总和中。

这是列表效率低下的另一个例子：

```
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000)))) 
```

尽管我们只想要第二个质数，但这段代码生成了一个巨大的整数列表和一个巨大的质数列表！

## 为什么要用流？

使用流，我们可以操纵序列而不会产生操纵列表序列的成本。使用流，我们可以兼得两全：我们可以优雅地构建程序作为序列操作，同时实现增量计算的效率。基本思想是只部分构造流，并将部分构造传递给消费流的程序。如果消费者尝试访问尚未构造的流的一部分，流将自动构造足够多的自身来生成所需的部分，从而保持整个流存在的幻觉。换句话说，尽管我们将编写程序，好像我们正在处理完整的序列，但我们的流实现设计为自动透明地将流的构造与其使用交错。
