# HOFs - 将过程作为参数

**高阶函数**（**HOF**）是一个执行以下一项或两项操作的函数：

+   将一个函数作为参数。

+   将一个函数作为输出返回。

在我们深入之前，让我们快速复习一下。

## 重新审视替换模型

你应该已经非常熟悉定义这样的函数：

```
(define (f x)
  (plus1 x)) 
```

在这个函数定义中，`f`的参数是`x`，它被作为参数传递给内置过程`plus1`。如果我们从第 1 课中恢复我们的替换模型，我们可以说对`f`的调用，比如`(f 5)`，将通过以下步骤进行评估：

```
-> (f 5)
-> (plus1 5)
6 
```

参数`5`被替换到`f`的主体中，我们调用`plus1`得到`6`。好吧，这太容易了。但是，如果我们不将`x`作为主体中的函数参数，而是将其作为*函数*呢？

## 一个简单的高阶函数

让我们看一个例子。

```
(define (f g)
  (g 2)) 
```

你看到了`g`在前面吗？嗯。如果这次我们调用`(f 5)`会发生什么？

```
-> (f 5)
-> (5 2)
; application: not a procedure;
;  expected a procedure that can be applied to arguments
;   given: 5
; [,bt for context] 
```

糟糕。看起来我们需要给`f`传递一个过程。

```
-> (f square)
-> (square 2)
4 
```

我们也可以将`f`传递给一个 lambda 函数！

```
-> (f (lambda (x) (* x x)))
-> ((lambda (x) (* x x)) 2)
-> (* 2 2)
-> 4 
```

看那个！我们刚刚定义了一个函数`f`，它接受一个过程`g`作为参数，并将`g`��用于`2`。这就是你的第一个高阶函数。尝试一下，看看你是否可以定义自己的过程，接受其他过程作为参数。

## 将函数作为参数传递的用途

现在我们已经看到函数如何被传递，让我们实际探讨一下这如何有用。

考虑以下三个函数：

```
(define (sum-doubles a b)
  (if (> a b)
      0
      (+ (* 2 a) (sum-doubles (+ a 1) b))))    

(define (sum-squares a b)  
  (if (> a b)
      0
      (+ (square a) (sum-squares (+ a 1) b))))

(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))
```

这三个函数分别计算 a 和 b 之间所有整数的双倍、平方和立方的和。

例如，`(sum-squares 5 8)`计算 5² + 6² + 7² + 8²。

定义这三个函数似乎有点多余。你是否注意到这三个函数在定义上几乎相同，除了代码中的下划线部分？是时候建立一些抽象了。

我们知道，对于这三个函数中的每一个，我们对`a`和`b`之间的每个元素应用某种操作。因此，我们不再为每个操作定义一个特定的函数，而是将其抽象化并放入函数参数中！

因此，我们不再为每个可能的运算符专门定义`sum-[op]`函数，而是只有一个名为`sum`的通用函数：

```
(define (sum fn a b)
  (if (> a b)
      0
      (+ (fn a) (sum fn (+ a 1) b))))
```

我们在上面的代码中划出了主要的差异。在这个`sum`的定义中，我们将一些输入函数`fn`应用于`a`和`b`之间的每个数字，正如你在递归调用中所看到的。

现在，我们可以这样做：

```
(sum (lambda (x) (* 2 x)) 5 8) 
```

和这个：

```
(sum square 5 8) 
```

还有这个：

```
(sum cube 5 8) 
```

只编写了一个过程`sum`，我们就获得了上面所有三个过程的功能。多么划算啊！

如果愿意，可以使用`sum`重新定义初始的三个过程如下：

```
(define (sum-squares a b)
  (sum square a b))

(define (sum-cubes a b)
  (sum cube a b))

(define (sum-doubles a b)
  (sum (lambda (x) (* 2 x)) a b)) 
```

在你的作业中，我们将通过一个非常有用且广为人知的高阶函数`accumulate`进一步抽象`sum`。**确保你理解`accumulate`的工作原理，因为你将在未来的练习中用到它！**
