# 递归是如何工作的

## 分解递归

让我们看看递归如何神奇地找到任何数字的阶乘。我们在下面复制了代码：

```
(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1))))) 
```

当`n`为`0`时，`factorial`返回`1`，否则返回`n`和`n - 1`的阶乘的乘积。

每个递归过程都使用条件语句，并且需要两种情况：

+   **基本情况：** 这种情况结束递归。递归过程的任何输入最终都会达到基本情况。

+   **递归情况：** 这种情况减小了问题的规模。递归情况总是尝试将问题变小，直到达到基本情况。

递归过程中可以有多个基本情况或递归情况，但为了使任何过程正确和递归，至少必须有一个基本情况和一个递归情况。

在我们的`factorial`过程中有一个基本情况和一个递归情况。你能识别出它们吗？

**检验你的理解**

当`n`为`0`时，是`factorial`的*基本情况*。考虑这个没有基本情况的`factorial`的替代定义：

```
(define (factorial n)
  (* n (factorial (- n 1))))
```

这个替代定义有什么问题吗？

我们在`factorial`内部调用`factorial`的第二种情况是*递归情况*。请注意，递归调用解决的是一个比我们最初给定的问题更小的问题（即`(factorial (- n 1))`）。考虑`factorial`的另一种定义：

```
(define (factorial n)
  (if (= n 0)
      1
      (factorial n)))
```

这个替代定义有什么问题？

对于你编写的每个递归过程，以下哪些陈述必须成立？选择所有适用的。

## 信仰的飞跃

此时，你可能仍然在想一个函数如何可以根据自身来定义。如果在定义`factorial`的过程中使用`factorial`，那么不应该会出现一个错误，说`factorial`还未定义吗？为了使其正常工作，你必须相信它可以工作。从某种意义上说，这是一种*信仰的飞跃*。

信仰的飞跃实际上是编写递归过程的一种技术。我们必须想象你正在编写的过程已经可以解决比当前正在解决的问题更小的问题。因此，当你考虑如何计算`(factorial 5)`时，想象`(factorial 4)`已经被解决。这将防止你的思维陷入无限循环。

在第 0-2 课时，我们提到了定义过程的一个重要属性，即在定义时不会评估过程体。这是递归可以工作的技术原因。因此，`define`是一个特殊形式，不会评估其参数，并且保持过程体不被评估。只有在定义之外调用过程时才会评估过程体。

**检验你的理解**

下列哪些表达式在 Racket 中会导致错误？选择所有适用的。

将每个表达式输入 Racket 解释器中，看看会发生什么。

## 重新审视`factorial`

让我们再次看看`factorial`的定义。

```
(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1))))) 
```

如果我们想要计算`(factorial 6)`，那么我们会到达`if`语句的 else 情况，并将问题简化为`(* 6 (factorial 5))`。为了进一步简化这个问题，我们需要计算`(factorial 5)`。因此，我们得到`(* 5 (factorial 4))`。如果我们将这个替换到原始表达式中，我们得到`(* 6 (* 5 (factorial 4)))`。再经过几次递归调用，我们会得到类似这样的东西：

```
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 (* 1 (factorial 0))))))) 
```

我们应该如何处理`(factorial 0)`？这是基本情况，我们应该返回`1`。因此，我们得到这个表达式：

```
(* 6 (* 5 (* 4 (* 3 (* 2 (* 1 1)))))) 
```

这只是一系列嵌套的乘法表达式，我们可以很容易地从内向外简化：

```
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720 
```

在 Racket 中，有一个非常有用的过程叫做`trace`，它接受一个过程作为参数，并在调用该过程时返回该过程的过程。

在您的 Racket 解释器中，在定义`factorial`过程后键入`(trace factorial)`，然后调用`(factorial 6)`。你看到了什么？如果您不再想要跟踪该过程，只需键入`(untrace factorial)`。

## 例子：斐波那契数列

考虑计算斐波那契数列，其中每个数字是前两个数字的和：

\begin{align} 0, 1, 1, 2, 3, 5, 8, 13, 21 \end{align}

一般来说，斐波那契数可以通过以下规则定义：

\begin{align} Fib(n) = \begin{cases} 0, & \text{如果 n = 0} \\ 1, & \text{如果 n = 1} \\ Fib(n - 1) + Fib(n - 2), & \text{其他情况} \end{cases} \end{align}

我们可以立即将这个定义转换为一个递归过程，用于计算斐波那契数：

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2)))))) 
```

考虑调用`(fib 2)`时会发生什么。该过程进行两次递归调用`(fib 1)`和`(fib 0)`，分别返回`1`和`0`。这些数字相加，过程返回`1`。

也许你会想知道是否真的有必要有两个单独的基本情况。考虑一下，如果我们省略了`n`为`1`时的基本情况会发生什么。`(fib 1)`会调用`(+ (fib 0) (fib -1))`。`(fib 0)`会返回`0`，但`(fib -1)`永远不会达到基本情况，过程会无限循环。

## 例子：Pig Latin

也许你熟悉 Pig Latin，这是一个语言游戏，根据一组简单的规则改变英语单词：取英语单词的第一个辅音（或辅音簇）并将其移动到单词的末尾，然后在单词后附加“ay”。例如，“pig”变为“igpay”，“trash”变为“ashtray”，“object”变为“objectay”。

我们可以使用递归和辅助过程在 Racket 中编写 Pig Latin：

```
(define (pigl wd)
  (if (pl-done? wd)
      (word wd 'ay)
      (pigl (word (bf wd) (first wd)))))

(define (pl-done? wd)
  (vowel? (first wd)))

(define (vowel? letter)
  (member? letter '(a e i o u))) 
```

作为提醒，`member?`是一个 Racket 原始过程，它接受两个参数，一个字母和一个单词，并在字母在单词中时返回 true。

当找到元音时，Pig Latin 结束，因此基本情况是当`pl-done?`返回 true 时，它只是在单词末尾连接“ay”。否则，在递归情况下，它调用自身与单词的`butfirst`和单词的第一个的连接。想想如果单词不包含元音会发生什么。

使用你的 Racket 解释器尝试这个`pigl`的实现。不要忘记利用`trace`过程！

## 示例：`sum-sent`

假设我们有一个数字句子，如下所示：

```
(define sent '(1 2 3 4 5)) 
```

我们想要定义一个名为`sum-sent`的过程，它可以找到`sent`中所有数字的总和，但我们也希望`sum-sent`能够找到*任何*数字句子的总和。由于输出取决于输入句子的大小，我们将不得不使用递归！

让我们跨出信任的一步。想象一下`sum-sent`已经知道如何计算除第一个数字外的所有数字的句子，例如，`'(2 3 4 5)`。要找到这个，我们只需调用`(sum-sent (bf sent))`，并且我们应该相信它会给我们正确的总和。鉴于此，我们知道：

```
(sum-sent '(1 2 3 4 5)) ==> (+ 1 (sum-sent '(2 3 4 5))) 
```

如果我们将这个推广到任何数字句子，这就给我们了递归情况：

```
(+ (first sent) (sum-sent (bf sent))) 
```

**测试你的理解**

当我们停在这里并将`sum-sent`定义如下时会发生什么？

```
(define (sum-sent sent)
  (+ (first sent) (sum-sent (bf sent))))
```

我们缺少基本情况！为了解决这个问题，我们必须添加一个处理空句子的情况。谓词`empty?`可用于检查空句子。这是`sum-sent`的完成版本：

```
(define (sum-sent sent)
  (if (empty? sent)
      0
      (+ (first sent) (sum-sent (bf sent))))) 
```

**测试你的理解**

假设我们有一个负数句子，`'(-1 -3 -4 -6)`。Racket 会输出什么？使用上面`sum-sent`的代码运行此示例，而不要将其输入到解释器中。然后，使用解释器检查你的工作。

随意在 Racket 解释器中尝试更多与`sum-sent`相关的示例。如果递归令人困惑，尝试查看`trace`输出。

## 练习

**测试你的理解：`count-ums`**

当你教课时，如果你说“嗯”太多次，人们会分心。编写一个名为`count-ums`的过程，它以单词句子作为参数，并计算该句子中“嗯”出现的次数：

```
-> (count-ums '(today um we are going to um talk about the um combining method))
3
```

递归地编写`count-ums`。

**提示＃1：** 当句子为空时会发生什么？

**提示＃2：** 当句子的第一个单词是“嗯”时会发生什么？

**提示＃3：** 当句子的第一个单词不是“嗯”时会发生什么？

**测试你的理解：`倒计时`**

编写一个名为`countdown`的过程，它接受一个数字，并按以下方式工作：

```
-> (countdown 10)
'(10 9 8 7 6 5 4 3 2 1 blastoff!)
-> (countdown 3)
'(3 2 1 blastoff!)
-> (countdown 1)
'(1 blastoff!)
-> (countdown 0)
'blastoff!
```
