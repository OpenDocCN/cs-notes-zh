# 如何绘制环境图

## EnvDraw

EnvDraw 是一个很酷的程序，你可以在你的课程账户上运行它来帮助你绘制环境图。要使用它：

1.  在终端中键入 `envdraw`。（如果这行不通，首先 SSH 进入 torus，然后再键入命令。）然后此命令应该会打开一个 STk 解释器。

1.  在解释器中，输入 `(envdraw)`。

1.  你应该会看到一个新的 EnvDraw 窗口打开。在 `EnvDraw>` 提示符下，尝试定义 `square` 函数。然后，看看 EnvDraw 窗口会发生什么！

## 概述

现在你要开始绘制你自己的环境图了！我们将从基础开始逐步构建。你需要确保在完成本课程时你已经了解了前面所有的规则。

我们在本节中向你展示的所有示例环境图都来自 EnvDraw 程序。

## 定义

让我们从在 Scheme 中定义一个变量并查看相应的环境图开始。具体来说，我们将尝试绘制以下图表：

```
(define x 3) 
```

第一步始终是绘制全局环境。确保对其进行标记！接下来，我们需要弄清楚如何处理 `define`。通过查看前面部分的规则，你应该了解到 `define` 将一个新的绑定添加到当前帧。让我们将其绘制出来：

![](img/define_x_3.PNG)

就是这么简单！只需在全局环境中写上 "x" 并用箭头指向 3。 （注意：在这门课程的你自己的环境图中，你不需要写 "[other bindings]"。EnvDraw 会为了完整性而这样做。）

现在我们要开始定义过程了。当你在 STk 解释器中输入以下代码时会发生什么？我们将继续前面图表的工作。

```
(define (square x) (* x x)) 
```

我们要做的第一件事是更改上面的代码，使其使用 lambda：

```
(define square (lambda (x) (* x x))) 
```

注意，此表达式现在具有与 `(define x 3)` 相同的所有基本部分。因此，我们遵循完全相同的过程：在全局框架中写上 "square" 并画一个指向 lambda 的箭头。我们将 lambda 绘制为双气泡。第一个气泡指向参数和主体。第二个气泡指向定义环境，或者在看到 lambda 时的当前环境。这就是你的图表现在应该的样子。

![](img/define_square.PNG)

现在你完成了！回顾一下，首先你需要画 lambda。使第一个气泡指向参数和主体，第二个指向定义环境。接下来，只需在全局环境中简单地写上 "square" 并使其指向 lambda。

在下一节中，我们将介绍如何实际调用我们刚刚定义的 `square` 函数。

在这些示例中，有一个非常重要的点我们忽略了：`define` 并不总是将事物添加到全局环境中。相反，它将其添加到*当前帧*（在上述情况下恰好是全局环境）。我们将在后面的部分中详细介绍如何确定当前帧。

## 应用原始过程

现在，让我们为以下内容绘制环境图：

```
(define y (+ 3 4)) 
```

与之前的示例不同之处在于，在我们为`y`赋值之前，我们必须首先将`+`过程应用于`3`和`4`。你可以假设所有原始过程都是通过魔法应用的。对于它们不需要绘制任何内容。因此，完整的环境图将简单地如下所示：

![](img/define_y_3_4.PNG)

## 应用用户定义的过程

假设我们现在想要实际调用我们之前定义的`square`函数。我们将使用以下代码调用它：

```
(square 5) 
```

要调用用户定义的过程，我们按照以下步骤进行：

1.  创建一个带有过程形式参数的框架，将其绑定到实际参数值。

![](img/square_5_a.png)

1.  用这个新框架扩展过程的定义环境。

![](img/square_5_b.png)

1.  使用新框架作为当前框架，评估过程主体。

最后一步实际上并不涉及更改环境图。相反，这是当我们最终找到调用的值时。要评估`square`的主体，我们必须首先弄清楚`x`的值。我们总是使用变量的*第一个可用*绑定。这意味着我们在当前环境中查找`x -> 5`的绑定，而不是在全局环境中查找`x -> 3`的绑定。一旦我们弄清楚了`x`的值，我们将其乘以自身（记住，你可以假设这是通过魔法完成的）。现在我们完成了！我们将`5`乘以自身，得到`25`的答案。

记住，只有复合过程调用才会创建一个新的环境！

## 原子表达式

评估原子表达式的技巧（例如找���符号的值）取决于确定哪个框架是当前框架。在我们深入讨论之前，请记住评估原子表达式的规则是：

1.  数字、字符串、#t 和 #f 是自求值的。

1.  如果表达式是一个符号，找到第一个可用的绑定。（也就是说，在当前环境中查找；如果找不到，则在“当前环境”之前的环境中查找；直到找到全局环境为止。）

所有的辛苦工作都在上面的第 2 种情况中。回想一下我们上一节的环境图：

![](img/square_5_b.png)

记住，只有在调用**用户定义的过程**时才会绘制新的环境。因此，当前环境只有在你在另一个函数的范围内时才会与全局环境不同。虽然这是一个非常重要的观点，但现在不要太担心。确保你理解到目前为止的所有示例。我们将在课程的后面介绍更复杂的例子。

**测试你的理解**

回想一下，我们迄今为止的环境图如下：![](img/square_5_b.png) 如果我现在在解释器中输入`x`，它的值将是多少？

我现在错误地定义函数`cube`如下：

```
(define (cube x) (* y y y))
```

首先，绘制与此定义对应的环境图。将此定义添加到我们迄今为止绘制的环境图中。

绘制从评估代码中得到的结果环境图：

```
(cube 2)
```

它输出什么？

## 免费加载框架

此时，我们的环境图现在有三个框架，全局框架，E1 和 E2。 E1 和 E2 是通过对`square`和`cube`的调用创建的。然而，一旦这些函数返回（或完成），我们创建的框架 E1 和 E2 就变得无用！它们不再可达，它们的绑定也不再重要。

这并不总是这样。在接下来的章节中，我们将讨论一些使这些框架在初始过程调用之后仍然有用的代码。

## 使用`set!`

现在让我们看看如何处理`set!`。你可能记得`set!`会改变*第一个可用*绑定。记住，我们通过查看当前框架，然后查看“在”该框架后面的框架来找到第一个可用绑定。

**测试你的理解**

让我们试一试！从头开始，绘制与以下代码行对应的环境图：

```
(define x 3)
(define (change x n)
  (set! x n))
(change x 5)
```

`x`的值是多少？

你如何修复`change`过程，使全局环境中的`x`值改变？指出所有可能的修复方法。

## 使用`let`

使用`let`往往会让很多学生感到困扰。但不要绝望！每当你在使用`let`时遇到困难时，请记住这些简单的规则：

1.  将`let`转换为 lambda 语句加调用。

例如，你可以重写

```
(let ((x 7)
      (y 10))
    (+ x y)) 
```

作为

```
((lambda (x y) (+ x y)) 7 10) 
```

1.  绘制相应的`lambda`。记住，`lambda`只是一个带有正确箭头的双气泡。

1.  使用适当的参数调用`lambda`。记住，这包括绘制新框架并将形式参数绑定到实际参数值。

如果你能记住这些简单的规则，你就不会有任何困难！

**测试你的理解**

为以下代码绘制环境图：

```
(let ((x 7)
      ( y 10))
    (+ x y))
```

现在让我们尝试一些更复杂的东西。为以下代码绘制结果环境图：

```
(define (make-withdraw initial-amount)
    (let ((balance initial-amount))
        (lambda (amount)
            (if (>= balance amount)
                (begin (set! balance (- balance amount))
                       balance)
                "Insufficient funds"))))
(define W1 (make-withdraw 100))
(W1 50)
```

## 要点

此时，你已经掌握了绘制任何环境图所需的一切知识，无论多么复杂！当我们在未来解决问题时，不要忘记基础！即使是最复杂的代码片段也可以归结为简单的规则。

如果到目前为止有任何一件事你不理解，请寻求帮助！环境图是许多学生觉得困难的主题之一。

## 接下来是什么？

利用我们对评估环境模型的新认识，在下一节中，我们将通过巧妙地使用 lambda 和 let 来实现面向对象编程。

## 对于测验

当你参加第 8 次测验时，你可以携带一份[环境图规则](https://docs.google.com/document/d/1GbRF9rB9TtFbf--89MBDEHzygF2E5_E2wpLBh4rb4Z4/edit)的副本**以及**你的双面作弊纸。
