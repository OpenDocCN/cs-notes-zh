# 评估组合

## 评估是什么意思？

当我们在解释器中键入类似`(+ 2 3)`的 Racket 表达式时，我们作为人类立即知道这实际上就是`5`。但计算机所看到的只是开括号、加号、两、三、闭括号。它是如何从 Racket 表达式得到值`5`的呢？它*评估*表达式并从中得到值`5`。它是如何评估的呢？

## 解释器如何评估事物

解释器评估事物的方式一开始可能有点令人困惑，但很快就会讲得通。要评估一个 Racket 表达式，首先要评估表达式的子表达式。换句话说，你首先要完全评估操作数，然后应用运算符。当你到达一个过程调用时，将运算符应用于操作数并重复。请注意，评估是递归的--为了评估一个表达式，我们需要首先评估其子表达式。为了评估子表达式，我们需要评估*它们的*子表达式，依此类推，直到达到一个过程。

## 例子：一个递归树

让我们尝试评估以下表达式：

`(* (+ 2 (* 4 6))`

`(+ 3 5 7))`

这是一个相当复杂的表达式，如果没有递归，将很难评估。评估这需要应用评估规则四次。如果我们将评估过程表示为一棵树，那么就会变得更容易理解。这棵树，不像真实的树，它的根在空中，它的分支伸入地面。

每个组合由一个具有对应子表达式的分支的节点表示。末端分支是运算符或数字。我们可以想象操作数的值向上游动，从树的底部开始，在每个分支处进行评估，并导致一个新值，该值在更高级别进一步评估。

![递归树](img/ec7ad933748d031f908ecb610b8aa307.jpg)

[wiki entry](https://edge.edx.org/courses/uc-berkeley/cs61as-1x/SICP/wiki/cs61as-1x/eval/)中对 eval 给出了更详细的解释，并将在关于替换模型的部分进一步解释。

## 定义？

那么`define`呢？原来，普通的评估规则对`define`不起作用，因为`(define x 3)`不将`define`应用于两个参数；它实际上将`x`的值存储为 3。Define 是所谓的[特殊形式](https://edge.edx.org/courses/uc-berkeley/cs61as-1x/SICP/wiki/cs61as-1x/special-form/)，特殊形式是评估规则的唯一例外。

以下哪个不是 Racket 中的原始函数？
