# 第 14 课简介

## 简介

在这节课中，我们将讨论并发的基础知识。

## 先决条件

你应该了解赋值和可变数据。

## 阅读材料

本课大部分内容基于[这些笔记](http://inst.eecs.berkeley.edu/~cs61as/reader/notes.pdf#page=64)和[SICP 3.4](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%_sec_3.4)。

## 并发简介

在第 3 单元中，我们看到了具有*局部状态*的计算对象作为建模工具的强大功能。但是这种能力是有代价的。

通过引入赋值，我们被迫将*时间*引入到我们的计算模型中。在引入赋值之前，我们所有的程序都是无时无刻的，即任何具有值的表达式总是具有相同的值。相比之下，回想一下在 SICP 3.1.1 节开头介绍的模拟从银行账户中提取现金并返回余额的示例：

```
> (withdraw 25)
75
> (withdraw 25)
50 
```

这里对同一表达式的连续求值会产生不同的值。这种行为源于赋值语句（在本例中是对变量`balance`的赋值）的执行，它界定了值改变的时间点。求值表达式的结果不仅取决于表达式本身，还取决于求值是在这些时间点之前还是之后发生的。以具有局部状态的计算对象构建模型迫使我们面对时间作为编程中的一个基本概念。

我们可以进一步构建计算模型以匹配我们对物理世界的感知。世界中的对象不是按顺序逐个更改的。相反，我们将它们视为同时行动——一次全部。因此，通常将系统建模为同时执行的计算过程的集合是很自然的。就像我们可以通过组织具有单独局部状态的对象来使程序模块化一样，通常适当将计算模型分成单独且并发地演变的部分。

除了使程序更加模块化外，并发计算还可以提供比顺序计算更快的速度优势。顺序计算机一次只执行一个操作，因此执行任务所需的时间与执行的总操作数量成正比。然而，如果可以将问题分解为相对独立且仅需要偶尔通信的部分，那么可能可以将部分分配给单独的计算处理器，从而产生与可用处理器数量成正比的速度优势。

不幸的是，在并发存在的情况下，赋值引入的复杂性变得更加棘手。并发执行的事实，无论是因为世界是并行运行的还是因为我们的计算机是，并且在我们对时间的理解中引入了额外的复杂性。
