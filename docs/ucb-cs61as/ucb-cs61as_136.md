# 正常次序和应用次序

## 惰性评估器

要开始，请获取我们的惰性评估器版本：

```
cp ~cs61as/lib/lazy.scm . 
```

现在我们已经将评估器表达为一个 Lisp 程序，我们可以通过简单修改评估器来尝试语言设计中的替代选择。实际上，新语言通常是通过首先编写一个将新语言嵌入到现有高级语言中的评估器来发明的。

例如，如果我们希望与 Lisp 社区的另一位成员讨论对 Lisp 的某个方面的拟议修改，我们可以提供一个体现了该变化的评估器。接收者然后可以尝试新的评估器，并将评论作为进一步的修改发送回来。高级别实现基础不仅使得测试和调试评估器更加容易；此外，嵌入还使设计者能够从底层语言中提取功能，就像我们的嵌入式 Lisp 评估器使用底层 Lisp 的原语和控制结构一样。设计者只有在以后（如果有的话）才需要费力地在低级语言或硬件中构建完整的实现。

在本节和下一节中，我们探讨了一些提供显著额外表达能力的 Scheme 变体。

## 正常和应用次序的回顾

在第 1 课中，我们开始讨论求值模型时，我们注意到 Scheme 是一种应用次序语言，即，当应用过程时，Scheme 过程的所有参数都会被求值。相比之下，正常次序语言会延迟求值过程参数，直到实际的参数值被需要。延迟求值过程参数直到最后可能的时刻（例如，直到它们被原始操作所需要）被称为惰性求值。

考虑以下过程

```
(define (try a b)
  (if (= a 0) 1 b)) 
```

在 Scheme 中，评估 `(try 0 (/ 1 0))` 会生成一个错误。使用惰性求值，不会出现错误。评估该表达式会返回 1，因为参数 `(/ 1 0)` 永远不会被求值。

利用惰性求值的一个例子是定义一个过程 `unless`

```
(define (unless condition usual-value exceptional-value)
    (if condition
        exceptional-value
        usual-value)) 
```

它可用于表达式中，如下所示

```
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0")
               0)) 
```

在应用次序语言中，这种做法行不通，因为通常值和异常值都会在调用 `unless` 之前被求值。惰性求值的一个优点是，一些过程（例如 `unless`）可以进行有用的计算，即使它们的一些参数的求值会产生错误或不会终止。

**测试您的理解**

考虑以下情况

```
> (define (double x) (+ x x))
double
> (double (+ 2 1))
6
```

在应用次序中，`+` 会被调用多少次？

在正常次序中，`+` 会被调用多少次？

## 严格与非严格

如果在进入过程体之前对参数进行求值，则称该过程在该参数上是**非严格**的。如果在进入过程体之前对参数进行求值，则称该过程在该参数上是**严格**的。在纯应用顺序语言中，所有过程在每个参数上都是严格的。在纯正常顺序语言中，所有复合过程在每个参数上都是非严格的，原始过程可以是严格的或非严格的。还有一些语言（参见[SICP Exercise 4.31](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_thm_4.31)）允许程序员对他们定义的过程的严格性进行详细控制。

一个引人注目的例子是一个可以有用地变为非严格的过程是`cons`（或者，一般来说，几乎任何数据结构的构造函数）。即使元素的值未知，我们也可以进行有用的计算，将元素组合成数据结构并对生成的数据结构进行操作。例如，计算列表的长度而不知道列表中各个元素的值是完全有意义的。我们将在后面的课程中利用这个想法，将第 11 课的流实现为由非严格`cons`对形成的列表。
