# 向量

## 向量

到目前为止，我们主要是成对编程，我们用它们来创建链表。我们使用列表来表示**序列**，这是一种抽象数据类型。虽然列表很棒，但它们有一个很大的缺点 - 引用列表的第 n 个元素需要`Θ(n)`的时间，因为我们必须调用`cdr` `n`次。

我们希望能够在常数时间（`Θ(1)`）内引用序列的第 n 个元素。在 Scheme 中，**向量**提供了这样做的机制。如果你在 Java 或其他类似 C 的语言中编程过，这本质上与数组的概念相同。

不幸的是，向量有一个缺点。在一个链表中（这基本上是你这学期一直在使用的列表结构），在列表末尾添加元素只需要`Θ(1)`的时间，因为我们只需在列表末尾`cons`。然而，在向量中添加元素需要`Θ(n)`的时间，其中`n`是向量的长度。

## 向量的工作原理

向量是如何工作的？是什么黑魔法让你能够在常数时间内引用元素？事实上，原来并不是黑魔法。

当你创建一个向量时，你必须指定你想要的向量大小。创建大小为 n 的向量会分配一个 n 大小的内存块。由于我们知道第一个内存块的地址，我们可以将 k 添加到该地址以获得向量的第 k 个元素。这就是我们如何在常数时间内访问任何元素的方式！

不利之处在于，为了将所有元素放在单个内存块中，我们必须一次性分配整个块。这就是为什么向向量添加元素需要`Θ(n)`的时间 - 我们必须分配一个新的内存块（即创建一个新数组）并复制所有旧元素！

## 向量原语

**注意：向量从 0 开始索引。**

这意味着第一个元素被称为第 0 个元素。这意味着在向量`#(1 2 3 4)`中，1 位于第 0 个索引，2 位于第 1 个索引，依此类推。

一些向量原语类似于列表的原语：

| 向量 | 列表 |
| --- | --- |
| `(vector a b c d...)` | `(list a b c d...)` |
| `(vector-ref vec n)` | `(list-ref lst n)` |
| `(vector-length vec)` | `(length lst)` |

但是`cons`和`append`呢？由于向量添加元素需要`Θ(n)`的时间，所以没有原语可以在向量末尾添加元素。不过，有不同的构造器。

正如之前讨论的，向量的主要弱点之一是我们在创建时必须声明向量的长度。因此，创建长度为`len`的空向量的方法是`(make-vector len)`。如果你希望所有元素最初都设置为某个值，你可以使用`(make-vector len val)`。

到目前为止，我们可以创建一个带有空元素或所有相同元素的向量。这并不是很有用。那么，我们如何改变向量的元素呢？我们使用变异！具体来说，我们使用 `(vector-set! vec n value)` 来将向量的第 n 个元素设置为特定值。这类似于 `set-car!` 和 `set-cdr!`。

**注意：** 存在将两种类型之间转换的过程 `list->vector` 和 `vector->list`。但是，在课程和作业中，您不会使用这些过程，因为本课程的目的是学习向量。

## 向量编程

当您使用向量进行编程时，通常会使用迭代过程来循环遍历向量。以下是一些使用向量编码的示例，让您可以尝试一下。

这是列表的 `map` 函数：

```
(define (map fn lst) 
    (if (null? lst) 
        '() 
        (cons (fn (car lst)) 
              (map (cdr lst))))) 
```

现在让我们为向量编写相同的函数，称为 `vector-map`：

```
(define (vector-map fn v) 
    (define (loop newvec i) 
        (if (< i 0) 
            newvec 
           (begin (vector-set! newvec i (fn (vector-ref v i))) 
                  (loop newvec (- i 1))))) 
    (loop (make-vector (vector-length v))
          (- (vector-length v) 1))) 
```

这比列表的 `map` 要复杂得多！首先，我们的 `vector-map` 有一个额外的索引变量 `i`，始终跟踪我们在向量中的位置。我们还必须知道我们向量的长度，因为这是我们的函数知道何时停止的方式。

列表的 `map` 是通过递归完成的，而向量的 `vector-map` 是通过迭代完成的。在学期初，我们提到递归通常被认为比迭代更优雅。希望您现在明白为什么了。

**检验您的理解**

编写一个函数 `vector-addup`，它接受一个数字向量并返回所有数字的总和。在 STk 中测试一下以检查您的答案。

## 向量 vs. 列表

这里是列表和向量过程的运行时间比较。

| 操作 | 列表 | 向量 |
| --- | --- | --- |
| 查找第 n 个元素 | `(list-ref lst n)` 运行时间为 Θ(n) | `(vector-ref vec n)` 运行时间为 Θ(1) |
| 添加元素 | `cons` 运行时间为 Θ(1) | `N/A` 运行时间为 Θ(n) |
| 查找长度 | `(length lst)` 运行时间为 Θ(n) | `(vector-length vec)` 运行时间为 Θ(1) |

表示序列没有一种最佳方式 - 向量和列表适用于不同的情况。如果您要经常添加和删除序列中的元素，最好使用列表，因为 `cons` 运行时间为常数。另一方面，如果您将有固定数量的元素但计划更改许多元素，则向量更好，因为 `vector-ref` 运行时间为常数。

## 示例：洗牌

假设我们有一副牌，我们想要洗牌。什么样的序列最适合表示这个过程？

首先，让我们使用一个列表，并使用变异来洗牌。

```
(define (list-shuffle! lst) 
    (if (null? lst) 
        '() 
        (let ((index (random (length lst)))) 
          (let ((pair ((repeated cdr index) lst)) 
                (temp (car lst))) 
            (set-car! lst (car pair)) 
            (set-car! pair temp) 
            (list-shuffle! (cdr lst)) 
            lst)))) 
```

这样做可以达到我们想要的效果，但非常慢 - Θ(n²) 时间。事实上，任何基于列表的解决方案都会花费 Θ(n²) 时间，因为找到一个随机元素需要 Θ(n) 时间，而我们必须这样做 n 次。

让我们尝试相同的方法，但使用向量而不是列表。

```
(define (vector-shuffle! vec) 
    (define (loop n) 
        (if (= n 0) 
            vec 
            (let ((index (random n)) 
                  (temp (vector-ref vec (- n 1))))  
              (vector-set! vec (- n 1) (vector-ref vec index)) 
              (vector-set! vec index temp) 
              (loop (- n 1)) 
    (loop (vector-length vec))) 
```

这本质上是相同的算法，但是在向量上执行而不是在列表上执行。然而，这需要Θ(n)的时间，因为它执行 n 个常量时间操作，由于`vector-ref`是在常量时间内完成的。

## 测验提示

与向量一起工作可能一开始会感觉有些不同，特别是有了所有新的函数。我们强烈建议在你的备忘单上写下我们使用的各种函数原语（例如`make-vect`，`vector-ref`等），以及你将在作业练习中定义的辅助程序（例如`vector-append`）和[这些笔记](http://www-inst.eecs.berkeley.edu/~cs61as/reader/notes.pdf#61)（例如`vector-map`）。
