# 表示序列

在我们开始实际的数据抽象之前，让我们先谈谈我们将用来存储数据的数据结构：**对**。到目前为止，我们知道存储信息的唯一方法是使用句子。在本节中，我们将介绍使用**对**来组合和存储数据的概念。对是多才多艺且易于构建的，因为它们可以相互嵌套以创建**列表**，这些数据结构与第 1 课中的句子非常相似。

## 对

一般来说，我们作为人类往往本能地将事物视为多个项目的集合或组合。一本书是纸上的文字集合。沙拉是叶子和其他美味食物的组合。现在，让我们改变这种观点。在 Racket 中，以及在计算机科学中的很多领域，事物被**对**表示。那么，如果一对只是两个项目，我们要如何存储多个项目呢？事实证明，一对的第二个项目通常是指向另一对的**指针**！而且，如果我们让一对指向其他一对，再指向其他一对，我们可以在这种数据结构中存储尽可能多的信息。这很好地遵循了计算机科学中的规则，即任何事物都可以用二进制表示。

## 创建对

在 Racket 中，我们使用函数`cons`创建一对，该函数接受两个任意类型的参数并返回一个*对*。为了在视觉上表示这一点，我们可以将一对看作一个有两半的盒子：

![](img/04_empty_pair.png)

第一半被称为对的`car`，而第二半是`cdr`。它们各自有相应的同名**选择器**。过程`car`和`cdr`都以一对作为其唯一参数，并分别返回该对中的第一个和第二个项目。

让我们看下面的例子，我们创建了数字`3`和`4`的一对：

```
-> (cons 3 4)
(3 . 4) ;; notice how there is a period between 3 and 4
-> (car (cons 3 4))
3
-> (cdr (cons 3 4))
4 
```

在视觉上，这对会看起来像这样：

![](img/04_pair_3_4.png)

这种视觉表示被称为**盒子和指针图**，是在未来更复杂时理解对的极其有用的工具。

让我们看另一个例子：

```
-> (cons 'hello 'world)
(hello . world)
-> (define greeting (cons 'hello 'world))
greeting ;; store the pair into a variable called greeting
-> (car greeting)
hello
-> (cdr greeting)
world 
```

正如你所看到的，对可以存储**任何**类型的数据 - 数字、单词、过程，甚至*更多的对*！

**测试你的理解**

编写一个名为 func-pair 的过程，它接受一个 car 是一个参数的函数且 cdr 是一个数字的对。func-pair 返回当我们将该函数调用到该数字时返回的值。

首先在 Racket 解释器中尝试一下。然后，检查下面的答案。

对存储其他对是很常见的，因为这样可以让我们在一个对中存储尽可能多的信息。让我们看看这个**嵌套对**示例的盒子和指针图会是什么样子：

```
-> (cons (cons 1 2) 4)
((1 . 2) . 4) 
```

注意这对的`car`是另一对，`(cons 1 2)`，而`cdr`是`4`。在这种情况下，这应该是我们绘制盒子和指针图的方式：

![](img/04_pair_124.png)

你可以想象我们可以以多少种方式存储大量数据！

**测试你的理解**

给定以下代码片段：

```
(define z (cons (cons 1 2) 4))
```

以下表达式将返回什么？看看你是否可以在没有 Racket 解释器的情况下弄清楚，然后点击相应的气泡查看正确答案。

我们也可以让一对的`cdr`指向*空列表*，写作`'()`。例如，我们可以这样做：

```
-> (cons 1 '())
(1) 
```

![box-pointer](img/04_list_1.png)

这有什么用呢？我们何时会想要将"nothing"存储到我们的对中？让我们耐心等待并看看下一个例子。假设我们在解释器中键入以下内容：

```
-> (cons 1 (cons 2 '())) 
```

尝试自己绘制框和指针图，然后猜测 Racket 会打印出什么。然后，用解释器检查你的工作。

实际输出是否符合你的预期？你可能认为表达式会返回类似`(1 . (2 . ()))`的内容。相反，你得到了`(1 2)`。这是因为 Racket 有一种巧妙的方法简化嵌套对！由于`(cons a (cons b (cons c (cons ...))))`这种格式经常使用，每次 Racket 看到一个句点后跟着一个开括号，它会简化表达式如下：

```
(1 ~~. (~~2 ~~. ())~~)
(1 2)
```

这里有一些练习问题供你尝试。对于以下每个表达式，请尝试绘制相应的框和指针图，然后写出 Racket 解释器将打印出什么：

```
(cons 4 5)
(cons (cons 2 (cons 4 5)) (cons 6 7))
(cons 3 (cons (cons 1 4) (cons 5 '())))
(cons 1 (cons 2 (cons 3 '()))) 
```

以下表达式将返回什么？如果卡住了，请绘制一个框和指针图。

```
(car (cons 4 5))
(car (cdr (car (cons (cons (cons 4 5) (cons 6 7)) (cons 1 (cons 2 3))))))
(cdr (cdr (cdr (cons 1 (cons 2 (cons 3 '())))))) 
```

## 一些简写

一系列`car`和`cdr`可能非常丑陋。在我们的 Racket 解释器中，有一种内置的简写表示法可以执行多次调用`car`和/或`cdr`。

`(car (cdr a))`等同于`(cadr a)`。

`(car (cdr (car (car a))))`等同于`(cadaar a)`。

注意在第一个例子中，如果我们取某个序列`a`的`cadr`，我们首先取`a`的`cdr`，然后取从中返回的内容的`car`。一般来说，你可以从一串`car`和`cdr`中提取`a`和`d`，并将它们以相同的顺序在一个`c`和一个`r`之间连接在一起。你可以做到`cxxxxr`（4 个`x`），其中`x`是`a`或`d`。

## 列表

**测试你的理解**

使用`cons`写出一个表达式，以便 Racket 打印出(5 6 7 8)。点击下面以显示答案。

反复使用这种`cons`模式可能会变得相当乏味。因为这种情况如此常见，Racket 还有另一个内置过程可以为我们创建嵌套的`cons`：`list`。`list`接受任意数量的任何类型的参数，并将其作为嵌套的`cons`或`list`返回。例如：

```
-> (cons 5 (cons 6 (cons 7 (cons 8 '()))))
(5 6 7 8)
-> (list 5 6 7 8) ;; this is identical to the expression above!
(5 6 7 8)

-> (list 'hello 'world 5 #t)
(hello world 5 #t) 
```

我们可以使用以下递归定义正式定义`list`：**列表要么是空列表，写作`'()`，要么是其`cdr`是另一个列表的对。**请注意，这意味着如果我们不断地取任何列表的`cdr`，我们最终将始终得到空列表。

我们可以通过简单地将每个列表重写为嵌套的`cons`来为列表绘制框和指针图。例如，`(list 1 2 3)`的框和指针图与`(cons 1 (cons 2 (cons 3 '())))`的相同：

![](img/04_list_123.png)

因此，我们学到了一个非常重要的关键思想：**每个列表都是一对。**但反之并不成立 - 并非所有的对都是列表。`(cons 1 2)`是一对，但它不是一个列表。

## Append

现在我们几乎拥有在 Racket 中表示集合和序列所需的所有工具了！我们缺少的是一种轻松地将两个列表组合在一起的方法。例如，假设我们有列表`(list 1 2 3)`和`(list 4 5 6)`，我们想将它们组合成一个形如`(list 1 2 3 4 5 6)`的大列表。Racket 有一个过程可以为我们做到这一点：`append`。给定任意数量的列表，`append`将返回一个包含其参数列表所有元素的列表。

在上面的例子中调用`append`时，使用框和指针图看起来是这样的。

我们从两个列表`(1 2 3)`和`(4 5 6)`开始：

![box-pointer](img/04_append1.png)

然后，我们移除第一个列表末尾的空指针，并将其指向第二个列表的开头：

![box-pointer](img/04_append2.png)

## Append：幕后

这里是`append`在幕后是如何工作的。记得我们关于列表的递归定义告诉我们列表的最后一个`cdr`总是指向空列表吗？首先，`append`获取它的第一个参数列表，并沿着`cdr`指针直到找到列表的最后一对。然后，它用要`append`的第二个参数列表替换那个最后一对指向的`cdr`的值。这对你来说可能听起来像一堆废话。看看下面的例子，可能会更清楚一些：

```
-> (define list1 (list 1 2 3 4))
list1 ;; the last pair of list1 is (4 . ())
-> (define list2 (list 5 6 7 8))
list2 ;; the last pair of list2 is (8 . ())
-> (define list3 (list 9 10 11 12))
list3
-> (append list1 list2 list3) ;; we take the cdr of list1's last pair, which is the empty list '(), and point it to list2\. then, we take the cdr of list2's last pair, which is also '(), and point it to list3.
(1 2 3 4 5 6 7 8 9 10 11 12) 
```

只有除了最后一个参数外其他参数都是列表时`append`才会起作用。你能解释为什么最后一个参数不必是列表吗？当你调用`append`时，最后一个参数不是列表时 Racket 会返回什么？

**检验你的理解**

以下哪个调用`append`会出错？
