![](img/a94abeb85355b2398cb0ce5d0e9938b1_0.png)

# 编译原理课程 P8：词法分析中的前瞻问题 🔍

![](img/a94abeb85355b2398cb0ce5d0e9938b1_2.png)

在本节课中，我们将学习词法分析中的一个核心挑战：前瞻。我们将通过分析历史上几种编程语言（如Fortran和PL/1）中出现的具体例子，来理解为什么在从左到右扫描源代码时，有时需要“向前看”几个字符才能正确识别一个词素（Token），以及为什么现代语言设计会尽量避免这种情况。

---

## Fortran中的空格规则与前瞻问题 📜

上一节我们介绍了词法分析的基本概念，本节中我们来看看一个经典的例子：Fortran语言。Fortran有一个有趣的词法规则：**空格不重要**。这意味着源代码中的空格可以被忽略，不会改变程序的含义。

例如，变量名 `var one` 和 `varone` 在Fortran中被视为完全相同的标识符。这个规则源于早期使用穿孔卡输入程序的年代，旨在减少因意外添加空格而导致的错误。

然而，这个规则给词法分析器带来了挑战。请看以下两个Fortran代码片段：

```
DO 5 I = 1, 25
```

```
DO 5 I = 1. 25
```

这两个片段几乎完全相同，唯一的区别是第一个使用逗号 `,`，第二个使用句号 `.`。但这个微小的差异导致了完全不同的解释：

*   第一个片段是一个 `DO` 循环（类似于现代语言的 `for` 循环）。`DO` 是关键字，`5` 是循环结束的标签，`I` 是循环变量，`1, 25` 表示循环范围。
*   第二个片段是一个赋值语句。`DO5I` 是一个变量名（因为空格被忽略），`=` 是赋值符，`1.25` 是一个浮点数。

当词法分析器从左到右扫描，读到字符序列 `D-O-空格-5` 时，它无法立即判断 `DO` 是一个独立的关键字，还是变量名 `DO5I` 的一部分。**唯一能区分它们的方法是向前查看下一个字符是逗号还是句号**。这就是一个典型的需要**前瞻**才能做出词法判断的例子。

---

## 词法分析的目标与前瞻的必要性 🎯

词法分析的核心目标是：**将输入的字符流分割成一系列有意义的词素，并为每个词素赋予一个标记（Token）**。

这个过程通过**从左到右扫描**输入流来完成。由于这种扫描方式，分析器经常需要查看当前字符之后的字符（即“前瞻”），以确定：
1.  当前词素在哪里结束。
2.  下一个词素从哪里开始。

![](img/a94abeb85355b2398cb0ce5d0e9938b1_4.png)

以下是几个需要前瞻的常见情况：

![](img/a94abeb85355b2398cb0ce5d0e9938b1_6.png)

*   **区分关键字与标识符**：例如，在C语言中，扫描到字符 `e` 时，需要前瞻以判断它是标识符 `e` 的开头，还是关键字 `else` 的开头。
*   **区分单符号与双符号操作符**：例如，扫描到 `=` 时，需要前瞻以判断它是一个单独的赋值符 `=`，还是等于比较符 `==` 的第一部分。

![](img/a94abeb85355b2398cb0ce5d0e9938b1_8.png)

**前瞻总是需要的，但语言设计的一个关键目标是将其限制在最小、固定的范围内**，这能极大地简化词法分析器的实现。

---

## PL/1：未保留关键字带来的挑战 🤯

为了进一步理解前瞻的复杂性，我们看看PL/1语言。PL/1的一个设计特点是：**关键字不是保留字**。这意味着关键字（如 `IF`, `THEN`, `ELSE`）也可以被用作变量名或函数名。

这导致了非常令人困惑的代码，例如：
`IF THEN THEN ELSE = ELSE; ELSE ELSE = THEN;`

在这行代码中，`IF`、`THEN`、`ELSE` 既可能作为关键字，也可能作为变量名。词法分析器在扫描时，无法仅根据局部字符序列来判断它们的角色，必须依赖对整个语句语法的理解，这可能需要大量的、甚至无限的前瞻。

另一个PL/1的例子是：
`DECLARE (ARG1, ARG2, ..., ARGN)`

仅看这个片段，`DECLARE` 可能是一个关键字（声明语句），也可能是一个数组名（数组引用）。要确定它的真实角色，词法分析器可能需要扫描完整个很长的参数列表 `(ARG1, ARG2, ..., ARGN)`，并查看后面是否跟着等号 `=` 或其他符号。**这理论上可能需要无限的前瞻**。

![](img/a94abeb85355b2398cb0ce5d0e9938b1_10.png)

Fortran和PL/1的这些历史经验告诉我们，糟糕的词法设计会让分析变得异常困难。

---

## 现代语言中的类似问题：C++模板 🧩

前瞻问题在现代语言中并未完全消失。一个著名的例子是C++中的嵌套模板与流操作符的冲突。

考虑以下C++代码：
`std::vector<std::list<int>> myList;`

![](img/a94abeb85355b2398cb0ce5d0e9938b1_12.png)

设计者的本意是声明一个“`int`列表的向量”。然而，`>>` 在C++中也是右移操作符和流输入操作符。早期的许多C++词法分析器会简单地将 `>>` 识别为一个独立的操作符标记，从而导致语法错误。

这个问题的**解决方案**是：词法分析器需要在特定上下文（模板参数列表内）中，将连续的 `>` 解释为两个独立的闭括号标记。对于程序员来说，在C++11标准之前，通常的变通方法是**在`>>`之间插入一个空格**：`std::vector<std::list<int> > myList;`。

这个例子说明，即使在新语言中，词法分析和语法分析的界限有时也会变得模糊，需要协同工作来解决歧义。

---

## 总结 📝

![](img/a94abeb85355b2398cb0ce5d0e9938b1_14.png)

本节课中我们一起学习了词法分析中的“前瞻”问题。

*   **核心任务**：词法分析器负责将字符流分割为词素并分配标记，主要通过从左到右扫描实现。
*   **核心挑战**：由于扫描是顺序的，分析器经常需要**前瞻**后续字符，才能确定当前词素的边界和类型。
*   **设计目标**：优秀的编程语言设计应力求**最小化所需的预读量**，最好将其限制为一个很小的常数，这能极大简化词法分析器的构建。
*   **历史教训**：像Fortran（忽略空格）和PL/1（未保留关键字）这样的设计，会导致严重的、有时是无限的前瞻需求，应引以为戒。
*   **现代体现**：即使在C++这样的现代语言中，类似嵌套模板 `>>` 的歧义问题仍然存在，需要通过更精巧的词法-语法分析协作来解决。

![](img/a94abeb85355b2398cb0ce5d0e9938b1_16.png)

理解前瞻问题，能帮助我们更好地领会编译器前端的设计思路，以及编程语言本身的设计哲学。