# 管理闪存

CS 140 的讲座笔记

2014 年春季

约翰·奥斯特豪特

+   本主题的阅读来自*操作系统：原理与实践*：第 12.2 节。

+   固态（半导体）存储，取代许多应用中的磁盘（例如手机和其他设备）。主要优势：

    +   非易失性（不像 DRAM）：即使设备断电，值仍然保持不变

    +   比磁盘更好：

        +   没有移动部件，因此更可靠

        +   更快的访问

        +   更抗震击

    +   比磁盘贵 5-10 倍

    +   比 DRAM 便宜 5-10 倍

+   两种风格，NAND 和 NOR；NAND 是今天最流行的：

    +   今天的总芯片容量高达 8 G 字节

    +   存储��为*擦除单元*（通常为 256 K 字节），这些单元被细分为*页*（通常为 512 字节或 4 K 字节）

    +   存储以页为单位读取

    +   两种写入方式：

        +   擦除：将擦除单元中的所有位设置为 1。

        +   写入：修改单个页，只能将位清除为 0（写入 1 没有效果）。

        +   可以重复写入以清除更多位。

    +   *磨损*：一旦一页被擦除多次（通常约为 10 万次，在一些新设备中低至 1 万次），它就不再可靠地存储信息。

+   典型的闪存性能：

    +   读取性能：20-100 微秒延迟，100-500 M 字节/秒。

    +   擦除时间：2 毫秒

    +   写入性能：200 微秒延迟，100-200 M 字节/秒。

+   实际上，大多数闪存设备都打包了一个*闪存转换层*（FTL）：

    +   管理闪存设备的软件

    +   通常提供类似磁盘的接口（读取和写入块）

    +   与现有文件系统软件一起使用

+   FTL 是有趣的软件组件，但今天大多数 FTL 并不是很好：

    +   牺牲性能

    +   浪费容量

+   FTL 的一种可能方法：*直接映射*（例如，一些廉价的闪存棒）

    +   虚拟块 *i* 存储在闪存设备的第 *i* 页上

    +   读取很简单

    +   要写入虚拟块 *i*：

        +   读取包含页 *i* 的擦除单元

        +   擦除整个单元

        +   用修改后的页重写擦除单元

    +   这种方法有什么问题？

+   要避免这些问题，必须在闪存中将虚拟块号与物理位置分开，以便给定的虚拟块可以随着时间在闪存中占据不同的页。

+   保留一个*块映射*，将虚拟块映射到物理页

    +   读取必须首先查找块映射中的物理位置

    +   对于写入：

        +   找到一个空闲和擦除的页

        +   将虚拟块写入该页

        +   更新块映射到新位置

        +   标记前一页的虚拟块为自由

    +   这引入了额外的问题

        +   如何管理映射（是否存储在闪存设备上？）

        +   如何管理空闲空间（例如磨损平衡）

+   一种方法：将块映射保留在内存中，在启动时重建：

    +   不要将块映射存储在闪存设备上

    +   闪存上的每一页包含额外的页头：

        +   虚拟块号

        +   自由/已用位（1 => 自由）

        +   预验证/有效位（1 => 预验证）

        +   有效/废弃位（1 => 有效）

    +   F-P-O 位跟踪页面的生命周期：

        +   刚擦除：1-1-1

        +   即将写入数据：0-1-1

        +   成功写入块：0-0-1

        +   块已删除（新副本写入其他位置）：0-0-0

        +   为什么需要 0-1-1 状态？

    +   在启动时，读取闪存内存的全部内容以重建块映射（8GB 需要 32 秒，128GB 需要 512 秒）。

+   为了减少块映射的内存利用率，将块映射存储在闪存中，部分缓存在内存中

    +   每个闪存页的标头指示该页是数据页还是映射页。

    +   在内存中保留映射页的位置（映射-映射）

    +   在启动时扫描闪存以重新创建映射-映射

    +   在写入期间，必须写入新的映射页和新的数据页。

    +   有些读取可能需要 2 个闪存操作。

+   废弃的块堆积在擦除单元中，这降低了有效容量。

+   解决方案：*垃圾回收*

    +   找到具有许多空闲页的擦除单元。

    +   将活动页复制到干净的擦除单元（更新块映射）。

    +   擦除并重新使用旧擦除单元

    +   注意：必须始终保留至少一个干净的擦除单元用于垃圾回收！

+   磨损平衡：

    +   希望所有擦除单元的擦除速度大致相同。

    +   使用垃圾回收在“热”和“冷”页面之间移动数据。

+   很难同时实现良好的性能、良好的利用率和长寿命：

    +   如果闪存设备利用率为 90%，写入成本将增加 10 倍：

        +   为了为一个新页面腾出空间，必须垃圾回收 10 个旧页面。

        +   9 仍然有效，必须被复制。

        +   写入 1 个新页面

        +   总计：读取 9 次，写入 10 次才能写入 1 个新页面！

        +   这被称为 *写放大*。

    +   低利用率使得写入更便宜，但浪费空间。

    +   频繁的垃圾回收（例如因为高利用率）也会更快地耗损设备。

    +   理想情况：热数据和冷数据

        +   有些擦除单元只包含从不修改的数据（“冷”数据），因此它们总是满的，从不需要进行垃圾回收。

        +   其他擦除单元包含的数据很快被覆盖；我们可以等待所有页面都被覆盖，然后免费进行垃圾回收。

        +   有方法鼓励这种双峰分布。

+   将闪存内存作为带有 FTL 的类磁盘设备整合是低效的：

    +   复制：

        +   操作系统已经为文件保留了各种索引结构：

        +   这些等同于块映射

        +   如果操作系统可以直接管理闪存，它可以将块映射与文件索引合并。

    +   缺乏信息：

        +   FTL 不知道操作系统何时释放了一个块；只有在块被重写时才发现。

        +   因此，FTL 在垃圾回收期间可能会重写已失效的块！

        +   较新的闪存设备提供了 *trim* 命令，允许操作系统指示删除（但必须修改操作系统文件系统）。

+   更好的长期解决方案：专门为闪存设计的新文件系统。

    +   许多有趣的问题和设计替代方案

    +   已被研究团队探索，但没有广泛使用的实现

    +   需要绕过 FTL 的能力

    +   有趣的机会
