# 文件系统崩溃恢复

CS 140 课程讲义

春季 2014

约翰·奥斯特豪特

+   从《操作系统：原理与实践》这个主题的阅读材料：第十四章直到第 14.1 节。

+   问题：崩溃可能发生在任何地方，甚至在关键部分的中间：

    +   丢失数据：在主存储器中缓存的信息可能尚未写入磁盘。

        +   例如原始 Unix：最多 30 秒的更改

    +   不一致：

        +   如果修改涉及多个块，当一些块已写入磁盘但其他块尚未写入时，可能会发生崩溃。

        +   例子：

            +   添加块到文件：空闲列表已更新以指示块正在使用，但文件描述符尚未写入指向块。

            +   创建文件的链接：新目录条目引用文件描述符，但文件描述符中的引用计数未更新。

    +   理想情况下，我们希望像原子操作一样，多块操作要么完全发生，要么根本不发生。

## 方法#1：在重新启动期间检查一致性，修复问题

+   例如：Unix fsck（"文件系统检查"）

    +   每次系统启动时都会执行 fsck。

    +   检查磁盘是否干净关闭；如果是，则无需进行更多工作。

    +   如果磁盘没有干净关闭（例如，系统崩溃、断电等），则扫描磁盘内容，识别不一致之处，修复它们。

    +   例如：文件中的块也在空闲列表中

    +   例如：文件描述符的引用计数与目录中的链接数不匹配

    +   例如：块在两个不同的文件中

    +   例如：文件描述符的引用计数> 0，但在任何目录中都没有引用。

+   fsck 的限制：

    +   恢复磁盘一致性，但不能防止信息丢失；系统最终可能无法使用。

    +   安全问题：一个块可能从密码文件迁移到其他随机文件。

    +   可能需要很长时间：今天读取中等大小磁盘中的每个块需要 1.5 小时。在 fsck 完成之前无法重新启动系统。随着磁盘变大，恢复时间会增加。

## 方法#2：有序写入

+   通过按特定顺序进行更新来防止某些类型的不一致。

    +   例如，当向文件添加块时，首先写回空闲列表，以便它不再包含文件的新块。

    +   然后编写文件描述符，参考新块。

    +   崩溃后系统状态如何？

    +   一般来说：

        +   在初始化指向的块之前永远不要写入指针（例如，间接块）。

        +   在将所有现有指针置空之前，永远不要重复使用资源（inode、磁盘块等）。

        +   在设置新指针之前，永远不要清除对活动资源的最后一个指针（例如 mv）。

+   结果：重新启动时无需等待 fsck

+   问题：

    +   可能会泄漏资源（在后台运行 fsck 以回收泄漏的资源）。

    +   需要大量同步元数据写入，这会减慢文件操作速度。

+   改进：

    +   实际上不同步写入块，而是在缓冲区缓存中记录依赖关系。

    +   例如，在向文件添加块后，在文件描述符块和空闲列表块之间添加依赖关系。

        +   当需要将文件描述符写回磁盘时，请确保空闲列表块已经被首先写入。

    +   很难做到正确：可能最终出现块之间的循环依赖。

## 方法#3：预写式日志记录

+   也称为*日志文件系统*。

+   在 Linux ext3 和 NTFS（Windows）中实现。

+   与数据库系统中的日志类似；允许在重新启动期间快速纠正不一致性。

    +   在执行操作之前，在一个特殊的只追加日志文件中记录有关操作的信息；在修改任何其他块之前将此信息刷新到磁盘。

    +   例如：向文件添加一个块

        +   日志条目：“我将在块索引 93 处向文件描述符 862 添加块 99421”

    +   然后实际块更新可以稍后进行。

    +   如果发生崩溃，请重放日志以确保所有更新都已在磁盘上完成。

    +   保证一旦操作开始，它最终会完成。

    +   问题：日志随时间增长，因此恢复可能很慢。

    +   解决方案：检查点

        +   偶尔停止并刷新所有脏块到磁盘。

        +   一旦完成此操作，日志就可以被清除。

    +   通常日志仅用于元数据（空闲列表、文件描述符、间接块），而不用于实际文件数据。

+   日志记录的优势：

    +   恢复速度更快。

    +   消除诸如在文件之间混淆的块之类的不一致性。

    +   日志可以在磁盘的一个区域中本地化，因此写入速度更快（无需寻道）。

    +   元数据写入可以延迟很长时间，以获得更好的性能。

+   日志记录的缺点：

    +   每个元数据操作之前同步磁盘写入。

## 仍然存在问题

+   在崩溃后仍然可能丢失最近写入的数据

    +   解决方案：应用程序可以使用 fsync 强制数据写入磁盘。

+   磁盘故障

    +   大型数据中心中问题的最大原因之一

    +   解决方案：复制或备份副本（例如，磁带上）

+   磁盘写入不是原子性的：

    +   如果在崩溃时正在写入块，则可能会使其处于不一致状态（既不是旧内容也不是新内容）。

    +   在扇区级别，不一致性是可检测的；崩溃后，扇区将是

        +   旧内容

        +   新内容

        +   无法读取的垃圾

    +   但是，块通常是多个扇区。崩溃后：

        +   块的第 0-5 扇区可能包含新内容。

        +   块的第 6-7 扇区可能包含旧内容。

    +   例如：追加到日志

        +   如果向现有日志块添加新的日志条目，崩溃可能导致块中的旧信息丢失。

    +   解决方案：

        +   复制日志写入（如果崩溃损坏其中一个日志，则另一个仍将是安全的）。

        +   添加校验和和/或版本以检测不完整的写入。

+   结论：

    +   为了获得最高性能，必须放弃一些崩溃恢复能力。

    +   必须决定要从中恢复哪些类型的故障。
