# 需求分页

CS 140 的讲座笔记

2014 年春季

约翰·奥斯特豪特

+   *操作系统：原理与实践*这一主题的阅读材料：第九章。

+   *需求分页*：进程的虚拟地址空间不需要一次性全部加载到主内存中。每个页面可以是以下情况之一：

    +   在内存中（物理页框）

    +   在磁盘上（*后备存储*）

## 页错误

+   当进程引用位于后备存储器中的页面时会发生什么？

    +   对于位于后备存储器中的页面，页表条目中的存在位被清除。

    +   如果不存在设置，则对页面的引用会导致陷入操作系统。

    +   这些陷阱称为*页错误*。

    +   要处理页面错误，操作系统

        +   找到内存中的一个空闲页框

        +   从后备存储器中读取页面到页框中

        +   更新页面表条目，设置存在

        +   恢复线程的执行

+   操作系统如何确定生成错误的页面？

    +   x86：硬件保存导致故障的虚拟地址（CR2 寄存器）

    +   在早期的机器上，操作系统只获得故障指令的地址，必须模拟指令并尝试每个地址找到生成故障的地址。

+   在页面错误后重新启动进程执行很棘手，因为错误可能发生在指令的中间。

    +   如果指令是幂等的，只需重新启动错误指令（硬件在页面错误期间保存指令地址）。

    +   非幂等指令更难重新启动：

        ```
        MOV +(SP), R2

        ```

    +   没有硬件支持，可能无法安全地在页面错误后恢复进程。硬件必须跟踪副作用：

        +   页面错误期间是否撤消所有副作用？

        +   保存关于副作用的信息，用于重新启动“中间”的指令。

## 页面获取

+   一旦基本的页面错误机制运行起来，操作系统需要做出两个调度决策：

    +   页面获取：何时将页面带入内存。

    +   页面替换：要从内存中抛出的页面。

+   总体目标：使物理内存看起来比实际更大。

    +   *局部性*：大多数程序大部分时间使用其代码和数据的一小部分。

    +   保留正在使用的信息在内存中。

    +   在磁盘上的*分页文件*（也称为后备存储或交换空间）中保留未使用的信息

    +   理想情况下：分页产生具有主存性能和磁盘成本/容量的内存系统！

+   大多数现代操作系统使用*需求获取*：

    +   开始进程时不加载页面，直到引用它时才将页面加载到内存中。

    +   进程的页面分为三组：

        +   只读代码页面：在需要时从可执行文件中读取。

        +   初始化的数据页面：首次访问时，从可执行文件中读取。一旦加载，保存到分页文件中，因为内容可能已更改。

        +   未初始化的数据页面：首次访问时，只需将内存清除为所有零。在分页时，保存到分页文件中。

+   预取：尝试预测何时需要页面，并提前加载它们以避免页面错误。

    +   需要预测未来，所以很难做到。

    +   一种方法：当发生页面错误时，读取多个页面而不仅仅是一个（如果程序按顺序访问内存，则胜出）。

## 页面替换

+   一旦所有内存都被使用，每次发生页面错误时都需要丢弃一个页面。

+   随机：随机选择任意页面（效果出奇的好！）

+   先进先出（FIFO）：丢弃在内存中存在时间最长的页面。

+   MIN：最佳算法要求我们预测未来。

+   最近最少使用（LRU）：利用过去来预测未来。

+   实现 LRU：需要硬件支持来跟踪最近使用的页面。

    +   完美的 LRU？

        +   为每个页面保留一个硬件寄存器，在每次内存引用时将系统时钟存储到该寄存器中。

        +   为选择放置页面，扫描所有页面以找到最老的时钟。

        +   在分页的早期，硬件成本过高；此外，在替换过程中扫描所有页面也很昂贵。

        +   没有机器实际实现过这一点。

    +   当前计算机采用一种高效的近似方法。只需找到一个旧页面，不一定是最老的。

+   *时钟算法*（也称为*二次机会*算法）：为每个页面帧保留*引用位*，硬件在读取或写入页面时设置引用位。选择放置页面的方法：

    +   按顺序（循环方式）遍历页面。

    +   如果下一个页面已被引用，则不要替换它；只需清除引用位并继续到下一个页面。

    +   如果自上次检查以来未引用该页面，则替换该页面。

+   *脏位*：每个页面帧一个位，当页面被修改时由硬件设置。如果替换了脏页面，则必须在重用其页面帧之前将其写入磁盘。

+   时钟算法通常会额外偏好脏页面。例如，如果页面的引用位未设置，但脏位已设置，则现在不要替换此页面，而是清除脏位并开始将页面写入磁盘。

+   空闲页面池：许多系统保留一个小的干净页面列表，这些页面可以立即用于替换。

    +   在替换过程中，选择在空闲池中存在时间最长的页面，然后运行替换算法以向空闲池添加新页面。

    +   空闲池中的页面的当前位关闭，因此对这些页面的任何引用都会导致页面错误

    +   如果发生页面错误，且页面在空闲池中，则将其从空闲池中移除并重新投入使用；比从磁盘读取要快得多。

    +   如果我们做出了不良的页面替换决策，提供了额外的恢复机会。

+   当系统中有多个进程运行时如何实现页面替换？

    +   *全局替换*：所有进程的所有页面都被合并到一个替换池中。每个进程与所有其他进程竞争页面帧。

    +   *每进程替换*：每个进程都有一个单独的页面池。一个进程中的页面错误只能替换该进程的一个页面帧。这消除了其他进程的干扰。

    +   不幸的是，每个进程的替换会产生一个新的调度困境：为每个进程分配多少页框？如果这个决定做错了，可能会导致内存使用效率低下。

    +   大多数系统使用全局替换。
