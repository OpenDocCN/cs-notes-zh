# 死锁

CS 140 课堂笔记

2014 年春季

John Ousterhout

+   从*操作系统：原理与实践*中关于此主题的阅读：第 6.1-6.2 节。

+   死锁问题：

    +   线程经常需要同时持有多个锁。

    +   简单示例：

        ```
        Thread A               Thread B
        lock_acquire(l1);      lock_acquire(l2);
        lock_acquire(l2);      lock_acquire(l1);
        ...                    ...
        lock_release(l2);      lock_release(l1);
        lock_release(l1);      lock_release(l2);

        ```

    +   死锁定义：

        +   一组线程都被阻塞了。

        +   每个线程都在等待另一个线程拥有的资源。

        +   由于所有线程都被阻塞，没有一个能释放它们的资源。

+   死锁的四个条件：

    +   有限访问：资源不能共享。

    +   无抢占。一旦分配，资源就不能被收回。

    +   多个独立请求：线程不会一次性请求所有资源（在等待时持有资源）。

    +   请求和所有权图中的循环性。

+   复杂性：

    +   死锁可能发生在任何导致等待的事物上：

        +   锁

        +   网络消息

        +   磁盘驱动器

        +   内存空间耗尽

    +   死锁可能发生在不同的资源（例如锁）或单个资源的部分（内存页）上。

    +   一般来说，不知道线程将需要哪些资源。

+   解决方案＃1：死锁检测

    +   确定系统何时发生死锁

    +   通过终止其中一个线程来打破死锁

    +   在操作系统中通常不实用，但在数据库系统中经常使用，其中事务可以重试

+   解决方案＃2：死锁预防：消除死锁的必要条件之一

    +   不允许独占访问？对大多数应用程序来说不合理。

    +   创建足够的资源，使其永远不会用完？对于像磁盘空间这样的东西可能有效，但用于同步的锁数量是有意限制的。

    +   允许抢占？对一些资源有效，但对另一些资源无效（例如，无法抢占锁）。

    +   要求线程同时请求所有资源；要么全部获取，要么全部等待。

        +   实现起来有些棘手：必须等待几个事物而不锁定任何一个。

        +   对线程不方便：难以提前预测需求。可能需要线程过度分配资源以确保安全。

    +   打破循环性：所有线程按相同顺序请求资源（例如，总是先锁 l1 再锁 l2）。这是操作系统中最常用的方法。
