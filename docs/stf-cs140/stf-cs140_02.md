# 线程、进程和调度

CS 140 课程讲义

2014 年春季

约翰·奥斯特豪特

+   从*操作系统：原理与实践*这个主题的阅读：第四章。

## 线程和进程

+   线程：一个顺序执行流

    +   按顺序执行一系列指令（一次只发生一件事）。

+   进程：一个或多个线程，以及它们的执行状态。

    +   执行状态：一切可能影响或受线程影响的东西：

        +   代码、数据、寄存器、调用堆栈、打开文件、网络连接、当天时间等。

    +   进程状态的一部分是线程私有的

    +   部分信息在进程中所有线程之间共享

+   操作系统进程模型的演变：

    +   早期操作系统支持一次只能运行一个进程的单线程（*单任务*）。它们运行批处理作业（一次一个用户）。

    +   一些早期个人计算机操作系统使用单任务处理（例如 MS-DOS），但这些系统今天几乎听都没听说过。

    +   到了 20 世纪 70 年代末，大多数操作系统都是*多任务*系统：它们支持多个进程，但每个进程只有一个线程。

    +   在 20 世纪 90 年代，大多数系统转换为*多线程*：每个进程内有多个线程。

+   进程和程序是一样的吗？

## 调度

+   几乎所有计算机今天都可以同时执行多个线程：

    +   每个处理器芯片通常包含多个*核心*

    +   每个核心包含一个完整的 CPU，能够执行线程

    +   许多现代处理器支持*超线程*：每个物理核心表现得好像实际上是两个核心，因此它可以���时运行两个线程（例如，在一个线程等待缓存未命中时执行另一个线程）。

    +   例如，一个服务器可能包含 2 个 Intel Xeon E5-2670 处理器，每个处理器有 8 个支持 2 路超线程的核心。总体而言，这台计算机可以同时运行 32 个线程。

    +   可能有比核心更多的线程

    +   在任何给定时间，大多数线程不需要执行（它们正在等待某些事情）。

+   操作系统使用*进程控制块*来跟踪每个进程：

    +   每个线程的执行状态（保存的寄存器等）

    +   调度信息

    +   有关此进程使用的内存信息

    +   有关打开文件的信息

    +   会计和其他杂项信息

+   在任何给定时间，一个线程处于以下 3 种状态之一：

    +   运行中

    +   阻塞：等待事件（磁盘 I/O，传入网络数据包等）

    +   就绪：等待 CPU 时间

+   *调度程序*：运行在每个核心上的操作系统的最内部部分：

    +   运行一个线程一段时间

    +   保存它的状态

    +   加载另一个线程的状态

    +   运行它...

+   *上下文切换*：通过首先保存旧进程的状态，然后加载新线程的状态来更改当前在核心上运行的线程。

+   注意：调度程序本身不是一个线程！

+   核心一次只能做一件事。如果一个线程正在执行，调度程序不是：操作系统失去了控制。操作系统如何重新获得核心的控制？

+   陷阱（发生在当前线程中导致控制权转移到操作系统的事件）：

    +   系统调用。

    +   错误（非法指令，寻址违规等）。

    +   页面错误。

+   中断（发生在当前线程之外的事件，导致状态切换到操作系统）：

    +   在键盘上键入的字符。

    +   完成磁盘操作。

    +   定时器：确保操作系统最终获得控制。

+   调度程序如何决定下一个要运行的线程？

    +   计划 0：从前面搜索进程表，运行第一个准备好的线程。

    +   计划 1：将准备好的线程链接成队列。调度程序从队列中获取第一个线程。当线程准备就绪时，插入到队列的末尾。

    +   计划 2：为每个线程分配优先级，根据优先级组织队列。或者，可能有多个队列，每个队列对应一个优先级类。

## 进程创建

+   操作系统如何创建进程：

    +   将代码和数据加载到内存中。

    +   创建和初始化进程控制块。

    +   使用调用堆栈创建第一个线程。

    +   为线程提供“保存状态”的初始值

    +   使调度程序知道线程；调度程序“恢复”到新程序的起始点。

+   UNIX 中用于进程创建的系统调用：

    +   fork 复制当前进程，带有一个线程。

    +   exec 用给定可执行文件的代码和数据替换内存。不返回（"返回"到新程序的起始点）。

    +   waitpid 等待给定进程退出。

    +   例子：

        ```
        int pid = fork();
        if (pid == 0) {
            /* Child process  */
            exec("foo");
        } else {
            /* Parent process */
            waitpid(pid, &status, options);
        }

        ```

    +   优点：可以在调用 exec 之前修改进程状态（例如更改环境，打开文件）。

    +   缺点：浪费工作（大部分 forked 状态被丢弃）。

+   Windows 中用于进程创建的系统调用：

    +   CreateProcess 结合了 fork 和 exec

        ```
        BOOL CreateProcess(
            LPCTSTR lpApplicationName,
            LPTSTR lpCommandLine,
            LPSECURITY_ATTRIBUTES lpProcessAttributes,
            LPSECURITY_ATTRIBUTES lpThreadAttributes,
            BOOL bInheritHandles,
            DWORD dwCreationFlags,
            PVOID lpEnvironment,
            LPCTSTR lpCurrentDirectory,
            LPSTARTUPINFO lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
        );

        ```

    +   必须传递父子进程之间任何状态更改的参数。

+   Pintos 中的进程创建：exec 结合了 UNIX 的 fork 和 exec。
