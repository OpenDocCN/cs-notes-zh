# 动态存储管理

CS 140 的讲座笔记

2014 年春季

约翰·奥斯特豪特

+   本主题的阅读材料来自*操作系统：原理与实践*：无。

+   静态内存分配简单方便，但并不适用于所有情况。

+   动态存储管理中的两个基本操作：

    +   分配给定字节数

    +   释放先前分配的块

+   动态存储分配的两种一般方法：

    +   堆栈分配（分层）：受限制，但简单高效。

    +   堆分配：更通用，但实现更困难，效率较低。

## 堆栈分配

+   当内存分配和释放部分可预测时，可以使用堆栈：内存释放的顺序与分配相反。

+   例子：过程调用。X 调用 Y 再次调用 Y。

+   堆栈还可用于许多其他用途：树遍历，表达式求值，自顶向下递归下降解析器等。

+   基于堆栈的组织将所有空闲空间集中在一个地方。

## 堆分配

+   当分配和释放不可预测时必须使用堆分配

+   内存由已分配区域和空闲区域（或空洞）组成。最终会有许多空洞。

+   目标：重复使用空洞中的空间，使空洞数量少，大小大。

+   *碎片化*：由于许多小空洞而导致内存使用效率低下。堆栈分配是完美的：所有空闲空间都在一个大空洞中。

+   堆分配器必须跟踪未使用的存储：*空闲列表*。

+   *最佳适配*：保持空闲块的链接列表，在每次分配时搜索整个列表，选择最接近满足分配需求的块，保存多余部分以备后用。在释放操作期间，合并相邻的空闲块。

+   *首次适配*：只需扫描列表以找到足够大的第一个空洞。释放多余部分。释放时还要合并。大多数首次适配实现都是旋转首次适配。

+   问题：随着时间的推移，空洞往往会碎片化，接近最小分配对象的大小

+   *位图*：自由列表的替代表示，如果存储以固定大小的块（例如磁盘块）出现，则很有用。

    +   保持大数组位，每个块一个位。

    +   如果位为 0，则表示块正在使用中，如果位为 1，则表示块是空闲的。

+   *池*：为每个常用大小保留单独的链接列表。

    +   分配快速，无碎片化。

    +   这有什么问题吗？

## 存储回收

+   我们如何知道何时可以释放动态分配的内存？

    +   当一个块只在一个地方使用时很容易。

    +   当信息被共享时，回收变得困难：直到所有用户完成后才能回收。

    +   通过存在指向数据的*指针*来指示使用。没有指针，无法访问（找不到）。

+   回收中的两个问题：

    +   悬空指针：最好不要在仍在使用时回收存储。

    +   内存泄漏：存储“丢失”，因为没有人释放它，即使它再也不能被使用。

+   *引用计数*：记录每个内存块的未解引用指针数量。当数量为零时，释放内存。例如：Smalltalk，Unix 中的文件描述符。

+   *垃圾回收*：存储空间不是显式释放（使用 free 操作），而是隐式释放：只需删除指针。

    +   当系统需要存储空间时，它会搜索所有指针（必须能够找到它们所有！）并收集未使用的内容。

    +   如果结构是循环的，那么这是回收空间的唯一方法。

    +   垃圾收集器通常会*压缩*内存，将对象移动以合并所有空闲空间。

+   实现垃圾回收的一种方法：*标记和复制*：

    +   必须能够找到所有对象。

    +   必须能够找到所有指向对象的指针。

    +   第一步：标记。遍历所有静态分配和过程局部变量，寻找指针（*根*）。标记指向的每个对象，并递归标记它指向的所有对象。编译器必须保存关于结构中指针位置的信息以便合作。

    +   第二步：复制和压缩。遍历所有对象，将活动对象复制到连续内存中；然后释放任何剩余空间。

+   垃圾回收通常很昂贵：

    +   在使用垃圾回收的系统中，占用 10-20%的 CPU 时间。

    +   内存使用效率低：过度分配 2-5 倍。
