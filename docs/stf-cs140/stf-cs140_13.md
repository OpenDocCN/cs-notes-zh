# 链接器和动态链接

CS 140 的讲座笔记

2014 年春季

约翰·奥斯特豪特

+   来自*操作系统：原理与实践*这个主题的阅读材料：无。

+   当进程运行时，它的内存是什么样子？一组称为*部分*的区域。 Linux 和其他 Unix 系统的基本内存布局：

    +   代码（或 Unix 术语中的“文本”）：从位置 0 开始

    +   数据：立即在代码上方开始，向上增长。

    +   栈：从最高地址开始，向下增长

+   参与管理进程内存的系统组件：

    +   编译器和汇编器：

        +   为每个包含该源文件信息的源代码文件生成一个*目标文件*。

        +   信息是不完整的，因为每个源文件通常引用其他源文件中定义的一些内容。

    +   链接器：

        +   将一个程序的所有目标文件合并为一个单独的目标文件。

        +   链接器的输出是完整且自给自足的。

    +   操作系统：

        +   将目标文件加载到内存中。

        +   允许多个不同的进程同时共享内存。

        +   为进程在启动后获取更多内存提供设施。

    +   运行时库：

        +   与操作系统一起工作，提供动态分配例程，例如 C 中的 malloc 和 free。

+   链接器（或链接编辑器，在 Unix 中为 ld，在 Windows 上为 LINK）：将程序的许多独立部分组合在一起，重新组织存储分配。通常由编译器隐式调用。

+   链接器的三个功能：

    +   将程序的所有部分组合在一起。

    +   找出一个新的内存组织，使所有部分都能组合在一起（组合类似的部分）。

    +   触及地址，以便程序可以在新的内存组织下运行。

+   结果：存储在新的名为*可执行文件*的目标文件中的可运行程序。

+   链接器必须解决的问题：

    +   汇编器在单独组装文件时不知道外部对象的地址。例如 printf 例程在哪里？

        +   汇编器只是为每个未知地址在目标文件中放置零。

    +   汇编器不知道它正在组装的东西将在内存中的位置。

        +   假设事物从地址零开始，让链接器重新排列。

+   每个目标文件由以下组成：

    +   *部分*，每个部分包含一种不同类型的信息。

        +   典型的部分：代码（“文本”）和数据。

        +   对于每个部分，目标文件包含部分的大小和当前位置，以及初始内容（如果有）。

    +   *符号表*：变量或过程的名称和当前位置，可以在其他目标文件中引用。

    +   *重定位记录*：关于在此目标文件中引用的地址的信息，链接器在知道最终内存分配后必须调整的信息。

    +   用于调试的附加信息（例如，从源文件中的行号到代码部分中位置的映射）。

+   链接器执行三次传递：

    +   第 1 步：读取部分大小，计算最终内存布局。

    +   第 2 步：读取所有符号，创建内存中完整的符号表。

    +   第 3 步：读取部分和重定位信息，更新地址，写出新文件。

## 动态链接

+   最初，所有程序都是以*静态*方式链接的，如上所述：

    +   所有外部引用都已经 *解析*

    +   每个程序都是完整的

+   自 20 世纪 80 年代末以来，大多数系统都支持*共享库*和*动态链接*：

    +   对于常见的库包，只在内存中保留一个副本，供所有进程共享。

    +   在运行时不知道库加载在哪里；必须在程序运行时动态解析引用。

+   实现动态链接的一种方式：*跳转表*。

    +   如果被链接的文件中有任何共享库，链接器实际上不会在最终程序中包含共享库代码。相反，它包含两个实现动态链接的内容：

        +   跳转表：一个数组，其中每个条目都是一个包含无条件分支（跳转）的单个机器指令。

            +   对于程序使用的共享库中的每个函数，跳转表中都有一个条目，该条目将跳转到该函数的开头。

        +   动态加载器：在启动时调用的库包，用于填充跳转表。

    +   对于指向共享库中函数的重定位记录，链接器会替换跳转表条目的地址：当调用函数时，调用者将“调用”跳转表条目，该条目将调用重定向到真正的函数。

    +   最初，所有跳转表条目都跳转到零（未解析）。

    +   当程序启动时，动态加载库被调用：

        +   它调用操作系统的 mmap 函数将每个共享库加载到内存中。

        +   它会为共享库中每个函数的正确地址填充跳转表。
