# 虚拟机监视器

CS 140 讲座笔记

2014 年春季

约翰·奥斯特豪特

+   来自*操作系统：原理与实践*第 10.2 节的本主题阅读。

+   操作系统为进程提供的抽象是什么？

    +   （虚拟）内存

    +   底层机器的指令集的一个子集

    +   大多数（但不是全部）的硬件寄存器

    +   一组具有特定参数的用于文件 I/O 等的内核调用。

    +   整体上：底层机器的一部分设施，通过操作系统实施的额外机制进行增强。

+   如果我们为进程实施了一个与底层硬件*完全*相同的抽象会怎样：

    +   底层机器的完整指令集

    +   物理内存

    +   内存管理单元（页表等）

    +   I/O 设备

    +   陷阱和中断

    +   没有预定义的系统调用

+   这种抽象被称为*虚拟机*：

    +   对于一个“进程”，它看起来好像拥有自己的私有机器。

    +   多个“进程”可以共享单个机器，每个进程都认为自己在运行自己的私有机器。

    +   这个操作系统被称为*虚拟机监视器*。

    +   可以在虚拟机内运行完整的操作系统：称为*客户操作系统*。

    +   每个虚拟机可以运行不同的客户操作系统。

## 实施虚拟机监视器

+   一种方法：模拟

    +   编写模拟指令执行的程序，类似于 Bochs。

    +   同样模拟内存，I/O 设备。

    +   示例：

        +   使用一个大文件来保存“磁盘”的内容

        +   模拟内核/用户位、中断向量等。

    +   问题：太慢了

        +   CPU/内存的减速 100 倍

        +   I/O 减速 2 倍

+   更好的方法：使用 CPU 模拟自身。

    +   像用户进程一样运行虚拟机客户操作系统（在非特权模式下）。

    +   大多数指令以 CPU 的全速执行。

    +   任何“异常”都会导致陷入虚拟机监视器，后者会模拟适当的行为。

+   特殊情况：

    +   特权指令（例如 HALT）：

        +   由于虚拟机运行在用户模式下，这些导致“非法指令”陷入 VMM。

        +   VMM 捕获这些陷阱，模拟适当的行为。

    +   客户操作系统中的内核调用：

        +   在客户操作系统下运行的用户程序发出内核调用指令。

        +   陷阱总是进入 VMM（而不是客户操作系统）。

        +   VMM 分析陷阱指令，模拟对客户操作系统的系统调用：

            +   将 VMM 栈中的陷阱信息移动到客户操作系统的栈中

            +   在客户操作系统的内存中找到中断向量

            +   切换模拟模式为“特权”

            +   从 VMM 返回到客户操作系统中的中断处理程序。

        +   当客户操作系统从系统调用返回时，也会陷入到 VMM 中（用户模式下的非法指令）；VMM 模拟返回到客户用户级别。

    +   I/O 设备：

        +   客户操作系统写入 I/O 设备寄存器

        +   VMM 已经安排好包含页面出错

        +   VMM 接收页面故障，识别地址为 I/O 设备寄存器

        +   VMM 模拟指令及其对模拟 I/O 设备的影响

        +   当实际 I/O 操作完成时，VMM 模拟中断进入客户操作系统

        +   为了更好的性能，编写新的设备驱动程序，直接调用 VMM（使用系统调用）。

    +   虚拟内存：VMM 使用页表模拟客户操作系统中的虚拟内存映射。

        +   三级内存：

            +   客户虚拟地址空间

            +   客户物理地址空间

            +   VMM 物理内存

        +   客户操作系统创建页表，但实际硬件不使用这些页表。

        +   VMM 管理真实页表，每个虚拟机一个集合。这些被称为*影子页表*。

        +   VMM 管理物理内存

        +   最初所有（影子）页表条目的 present 都为 0。

        +   当发生页错误时，VMM 找到物理页和相应的客户页表条目。两种可能性：

            +   在客户页表条目中 present 为 0：这个故障必须反映到客户操作系统：

                +   为客户操作系统模拟页错误（类似于内核调用）。

                +   客户操作系统调用 I/O 将页面加载到客户物理内存中。

                +   客户操作系统在客户页表条目中将 present 设置为 1。

                +   客户操作系统从页错误返回，再次陷入 VMM（类似于从内核调用返回）。

                +   VMM 看到客户页表条目中的 present 为 1，找到相应的物理页，创建影子页表中的条目。

                +   VMM 从原始页错误返回，导致客户应用程序重试引用。

            +   在客户页表条目中 present 为 1：客户操作系统认为页面存在于客户物理内存中（但 VMM 可能已经将其交换出去）。

                +   VMM 定位相应的物理页，如果需要，将其加载到内存中。

                +   VMM 在影子页表中创建条目。

                +   VMM 从原始页错误返回，导致客户应用程序重试引用。

                +   在这种情况下，页错误对客户操作系统是不可见的。

        +   如果客户操作系统修改其页表，导致页错误，VMM 更新影子页表以匹配。

+   潜在问题：

    +   VMM 必须陷入任何需要模拟的行为。

        +   特殊内存位置？使用页错误。

        +   特殊指令？必须陷入

    +   病态情况：

        +   在用户模式和内核模式下都有效的指令

        +   但是，在用户模式下行为不同

        +   例子：“读取处理器状态”（其中内核/用户模式位在状态字中）

    +   *可虚拟化*：没有这种特殊情况的机器

    +   直到最近，很少有机器是完全可虚拟化的（例如，直到最近的 x86）

+   *动态二进制翻译*：不可虚拟化机器的解决方案：

    +   VMM 分析在虚拟机中执行的所有代码

    +   用陷阱替换不可虚拟化指令

    +   非常棘手：如何找到所有代码？

+   在实践中，VMM 增加了多少额外开销？

    +   CPU 密集型应用程序：< 5%

    +   I/O 密集型应用程序：约 30%

## 虚拟机的历史/用途

+   IBM 在 1960 年代末发明

+   原始用法：

    +   每个用户一个虚拟机

    +   每个用户运行不同的客户操作系统

    +   单个共享硬件平台

+   兴趣在 20 世��80 年代和 90 年代消失：

    +   每个用户有一个私人机器

+   由斯坦福大学的 Mendel Rosenblum 和研究生们重新发明，并实用化，形成了 VMware。

+   软件开发：

    +   需要在不同的操作系统版本上测试软件：

    +   每个操作系统版本保留一个虚拟机。

    +   使用一台机器测试所有版本。

+   数据中心：

    +   问题：许多机器，每台只运行一个应用程序

        +   需要单独的机器进行隔离：应用程序崩溃可能导致整台机器崩溃

        +   大多数应用程序只需要机器资源的一小部分。

    +   解决方案：数据中心整合

        +   每个应用程序一个虚拟机

        +   在一台机器上运行多个虚拟机

        +   减少机器数量

+   封装：

    +   VMM 可以将虚拟机的整个状态封装在一个文件中。

    +   可以保存、继续、恢复旧状态。

    +   数据中心示例：

        +   可以在机器之间迁移虚拟机以平衡负载

    +   软件开发：

        +   测试可能破坏机器的状态

        +   解决方案：

            +   在虚拟机中运行测试

            +   始终从保存的虚拟机配置开始测试

            +   测试后丢弃虚拟机状态

            +   结果：可重现的测试

+   还有许多其他用途：

    +   在同一台机器上运行 MacOS 和 Windows

    +   安全性：可以监视虚拟机内外的所有通信。
