# 并发性

CS 140 课程讲义

2014 年春季

约翰·奥斯特豪特

+   本主题的阅读材料来自*操作系统：原理与实践*：第五章至第 5.1 节。

## 独立和协作线程

+   独立线程：不能影响或被宇宙的其他部分影响的线程。

    +   它的状态不会以任何方式被其他线程共享。

    +   确定性：仅由输入状态确定结果。

    +   可重现的。

    +   可以停止并继续而没有不良影响（只是时间变化）。

+   有许多不同的方式可以在计算机上执行一组独立线程：

    +   单任务处理：每个线程在下一个开始之前运行完成。

    +   一个核心上的多任务处理，由多个线程共享。调度顺序会影响行为吗？

    +   多核心的多任务处理（多处理）：在单独的核心上并行运行线程。

        +   给定线程一次只在一个核心上运行。

        +   一个线程可能在不同时间在不同核心上运行（移动状态，假设处理器是相同的）。

        +   从线程的角度来看，无法区分一个核心和多个核心。

+   协作线程：共享状态的线程。

    +   行为是*不确定的*：取决于相对执行顺序，无法提前预测。

    +   行为可能是*不可重现*的。

+   例子：一个线程向控制台窗口写入“ABC”，另一个同时写入“CBA”。

+   为什么允许线程合作？

+   协作线程的基本假设是某些操作的顺序是无关紧要的；某些操作与其他某些操作无关。例如：

    +   线程 1：A = 1;

        线程 2：B = 2;

    +   线程 1：A = B+1;

        线程 2：B = 2*B;

## 原子操作

+   在我们讨论任何关于协作线程的事情之前，我们必须知道某些操作是*原子*的：它要么完全发生而没有中断，要么根本不发生。不能在中间被中断。

    +   几乎所有系统中的引用和赋值都是原子的。A=B 将始终读取 B 的干净值，并为 A 设置一个干净值（但对于数组或记录来说不一定是真的）。

    +   在单处理器系统中，中断之间的任何操作都是原子的。

    +   如果没有原子操作，你无法创建一个。幸运的是，硬件设计者给了我们原子操作。

    +   如果你有任何原子操作，你可以用它来生成更高级的结构，并使并行程序正确运行。这是我们在这门课上要采取的方法。

## “牛奶太多”问题

+   基本问题：

    ```
              Person A                       Person B
    3:00      Look in fridge: no milk
    3:05      Leave for store
    3:10      Arrive at store                Look in fridge: no milk
    3:15      Leave store                    Leave home
    3:20      Arrive home, put milk away     Arrive at store
    3:25                                     Leave store
    3:30                                     Arrive home: too much milk!

    ```

+   正确的行为是什么？

+   更多定义：

    +   *同步*：使用原子操作确保协作线程的正确操作。

    +   *临界区*：代码段或操作集合，在其中一次只能执行一个线程。例如购物。

    +   *互斥*：用于创建临界区的机制。

+   通常，通过 *锁定* 机制来实现互斥：阻止其他人做某事。例如，在购物之前，在冰箱上留个便条：如果有备注就不要购物。

+   第一次尝试计算机化购买牛奶（假设原子读写）：

    ```
    1 if (milk == 0) {
    2   if (note == 0) {
    3     note = 1;
    4     buy_milk();
    5     note = 0;
    6   }
    7 }

    ```

+   第二次尝试：更改备注的意义。如果没有备注，A 就买，如果有备注，B 就买。

    ```
    Thread A
    1 if (note == 0) {
    2   if (milk == 0) {
    3     buy_milk();
    4   }
    5   note = 1;
    6 }

    Thread B
    1 if (note == 1) {
    2   if (milk == 0) {
    3     buy_milk();
    4   }
    5   note = 0;
    6 }

    ```

+   第三次尝试：A 和 B 使用单独的备注。

    ```
    Thread A
    1 noteA = 1;
    2 if (noteB == 0) {
    3   if (milk == 0) {
    4     buy_milk();
    5   }
    6 }
    7 noteA = 0;

    Thread B
    1 noteB = 1;
    2 if (noteA == 0) {
    3   if (milk == 0) {
    4     buy_milk();
    5   }
    6 }
    7 noteB = 0;

    ```

+   第四次尝试：只需找到一种方法来决定当两者都留下备注时谁来买牛奶（必须有人留下来确保任务完成）：

    ```
    Thread B
    1 noteB = 1;
    2 while (noteA == 1) {
    3   // do nothing;
    4 }
    5 if (milk == 0) {
    6 	buy_milk();
    7 }
    8 noteB = 0;

    ```

    +   这个解决方案有效，但有两个缺点：

        +   不对称（且复杂）的代码。

        +   当 B 在等待时，它在消耗资源（*忙等待*）。

    +   要了解一个没有忙等待的对称解决方案，请参阅[彼得森算法](http://en.wikipedia.org/wiki/Peterson%27s_algorithm)。
