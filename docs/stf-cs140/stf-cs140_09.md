# 文件系统

CS 140 课程讲义

2014 年春季

约翰·奥斯特豪特

+   《操作系统：原理与实践》这一主题的阅读：第十一章，第 13.3 节（直至第 561 页）。

+   现代文件系统解决的问题：

    +   磁盘管理：

        +   快速访问文件（最小化寻址）

        +   用户之间共享空间

        +   高效利用磁盘空间

    +   命名：用户如何选择文件？

    +   保护：用户之间的隔离，受控共享。

    +   可靠性：信息必须在操作系统崩溃和硬件故障时幸存。

+   文件：存储在持久存储设备（如磁盘）上的命名字节集合。

+   文件访问模式：

    +   顺序：信息按顺序处理，一个字节接着一个字节。

    +   随机访问：可以直接寻址文件中的任何字节，而无需通过其前导。例如，需求分页的数据集，还有数据库。

    +   键控（或索引）：搜索具有特定内容的块，例如哈希表，关联数据库，字典。通常由数据库提供，而不是操作系统。

+   要考虑的问题：

    +   大多数文件很小（几千字节或更少），因此每个文件的开销必须很低。

    +   大多数磁盘空间用于大文件。

    +   许多 I/O 操作用于大文件，因此大文件的性能必须良好。

    +   文件可能随时间不可预测地增长。

## 文件描述符

+   包含有关文件的信息的操作系统数据结构（在 Linux 中称为*inode*）

    +   与文件数据一起存储在磁盘上。

    +   在文件打开时保留在内存中。

+   文件描述符中的信息：

    +   文件占用的扇区

    +   文件大小

    +   访问时间（最后读取，最后写入）

    +   保护信息（所有者 ID，组 ID 等）

+   磁盘扇区应如何用于表示文件的字节？

+   *连续分配*（也称为“基于范围的”）：像分段内存一样分配文件（连续的扇区运行）。保留未使用磁盘区域的空闲列表。创建文件时，让用户指定其长度，一次性分配所有空间。描述符包含位置和大小。

    +   优点：

        +   易于访问，顺序和随机

        +   简单

        +   少量寻址

    +   缺点：

        +   碎片化将使磁盘空间难以有效利用；大文件可能不可能

        +   难以预测文件创建时的需求。例如：IBM OS/360。

+   *链接文件*：

    +   将磁盘分成固定大小的块（512 字节？）

    +   保持所有空闲块的链接列表。

    +   在文件描述符中，只需保留指向第一个块的指针。

    +   文件的每个块包含指向下一个块的指针。

    +   优点？

    +   缺点？示例（或多或少）：TOPS-10，Xerox Alto。

+   Windows FAT：

    +   类似于链接分配，但不要将链接保留在块本身。

    +   将所有文件的链接保存在称为*文件分配表*的单个表中

        +   表在正常操作期间驻留在内存中

        +   每个 FAT 条目是文件中下一个块的磁盘扇区号

        +   “文件中的最后一个块”，“空闲块”的特殊值

        +   文件描述符存储文件中第一个块的编号，大小

    +   最初，每个 FAT 条目为 16 位。

    +   FAT32 支持更大的磁盘：

        +   每个条目有 28 位扇区号

        +   磁盘地址指向*簇*：相邻扇区的组合。

        +   簇大小为 2-32 K 字节；对于任何特定的磁盘分区是固定的。

    +   优点？

    +   缺点？

+   *索引文件*：为每个��件保留一个块指针数组。

    +   文件创建时必须声明最大长度。

    +   分配数组来保存指向所有块的指针，但不分配块。

    +   在文件写入时动态填充指针。

    +   优点？

    +   缺点？

+   *多级索引*（4.3 BSD Unix）：

    +   块大小为 4 K 字节。

    +   文件描述符=14 个块指针，初始为 0（“无块”）。

    +   前 12 个指向数据块（*直接块*）。

    +   下一个条目指向一个*间接块*（包含 1024 个 4 字节块指针）。

    +   最后一个条目指向一个*双间接块*。

    +   文件的最大长度是固定的，但很大。

    +   直接块在需要时才分配。

    +   优点？

## 块缓存

+   使用主存的一部分来保留最近访问的磁盘块。

+   最近最少使用替换。

+   经常引用的块（例如，大文件的间接块）通常在缓存中。

+   这解决了对大文件的慢速访问问题。

+   最初，块缓存是固定大小的。

+   随着内存变得更大，块缓存也变得更大。

+   许多系统现在统一块缓存和虚拟内存页池：任何页面都可以用于任何一个，基于最近最少使用的访问。

+   当缓存中的块被修改时会发生什么？

    +   *同步写入*：立即写入磁盘。

        +   安全：如果机器崩溃，数据不会丢失。

        +   速度慢：进程无法继续直到磁盘 I/O 完成。

        +   可能是不必要的：

            +   对同一块进行许多小写入。

            +   一些文件被快速删除（例如，临时文件）。

    +   *延迟写入*：不立即写入磁盘：

        +   等待一段时间（30 秒？）以防有更多对块的写入或块被删除。

        +   快速：写入立即返回。

        +   危险：系统崩溃后可能丢失数据。

## 空闲空间管理

+   管理磁盘的空闲空间：许多早期系统只是使用一个空闲块的链表。

    +   每个块包含许多指向空闲块的指针，以及指向下一个指针块的指针。

    +   开始时，空闲列表是排序的，因此文件中的块是连续分配的。

    +   空闲列表很快变得混乱，因此文件分布在整个磁盘上。

+   4.3 BSD 对空闲空间的处理方法：*位图*：

    +   维护一个位数组，每个块对应一个位。

    +   1 表示块是空闲的，0 表示块正在使用。

    +   在分配期间，搜索位图以找到与文件的上一个块接近的块。

    +   如果磁盘未满，这通常运行得相当好。

    +   如果磁盘几乎满了，这将变得非常昂贵，并且不会产生很多局部性。

    +   解决方案：不要让磁盘填满！

        +   假装磁盘容量比实际容量少 10%。

        +   如果磁盘使用率达到 90%，告知用户磁盘已满，并禁止写入更多数据。

## 块大小

+   许多早期文件系统（例如 Unix）使用的块大小为 512 字节（一个扇区）。

    +   I/O 效率低：更多不同的传输，因此更多的寻道。

    +   更庞大的文件描述符：只有 128 个指针在一个间接块中（指针将占据磁盘空间的 1%）。

+   增加块大小（例如，在 FAT32 中使用 2KB 簇）？

+   4.3BSD 解决方案：多个块大小

    +   大块为 4 K 字节；大多数块都很大

    +   *碎片*是 512 字节的倍数，适合放在一个大块内

    +   文件中的最后一个块可能是一个碎片。

    +   一个大块可以容纳来自多个文件的碎片。

    +   空闲块的位图基于碎片。

## 磁盘调度

+   如果有几个磁盘 I/O 等待执行，最佳执行顺序是什么？

    +   目标是最小化寻道时间。

+   *先来先服务*（FCFS，FIFO）：简单，但对优化寻址没有帮助。

+   *最短寻道时间优先*（SSTF）：

    +   选择下一个请求尽可能靠近上一个请求。

    +   有助于最小化寻址，但可能导致某些请求饥饿。

+   *扫描*（"电梯算法"）。

    +   与 SSTF 相同，只是磁头在磁盘上沿着一个方向移动。

    +   一旦到达磁盘边缘，就寻找到最远处的块并重新开始。
