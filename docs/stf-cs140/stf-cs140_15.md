# 保护

CS 140 讲座笔记

2014 年春季

约翰·奥斯特豪特

+   *操作系统：原理与实践*中此主题的阅读：无。

+   保护：防止系统意外或故意滥用的机制。

    +   事故：通常更容易解决（使它们不太可能发生）

    +   恶意滥用：要消除的难度更大（不能留下任何漏洞，不能使用概率）。

+   保护机制的三个方面：

    +   身份验证：确定每个操作背后的负责任方（*主体*）。

    +   授权：确定哪些主体被允许执行哪些操作。

    +   访问执行：结合身份验证和授权以控制访问。在这些领域中的任何微小缺陷都可能危及整个保护机制。

## 身份验证

+   通常使用*密码*：

    +   用于建立用户身份的秘密信息。

    +   密码应该相对较长和晦涩（只有难以猜测才有用）。

    +   密码数据库是一个漏洞，必须小心保护；例如，不要以直接可读形式存储密码（使用单向转换）。

+   另一种身份验证形式：徽章或钥匙。

    +   不必保密。

    +   可以被盗取，但所有者会知道是否被盗。

    +   不应该是可伪造或可复制的。

+   悖论：密钥必须便宜制作，难以复制。

+   身份验证完成后，必须保护主体的身份免受篡改，因为系统的其他部分将依赖于它。

+   登录后，您的用户 ID 与在该登录下执行的每个进程相关联：每个进程从其父进程继承用户 ID。

## 授权

+   目标：确定哪些主体可以在哪些对象上执行哪些操作。

+   逻辑上，授权信息表示为*访问矩阵*：

    +   每个主体一行。

    +   每个对象一列。

    +   每个条目指示该主体对该对象可以做什么。

+   在实践中，完整的访问矩阵会太庞大，因此以两种压缩方式之一存储：访问控制列表或功能。

+   *访问控制列表*（ACL）：按列组织。

    +   对于每个对象，存储关于允许哪些用户执行哪些操作的信息。

    +   最一般的形式：<用户，特权>对的列表。

    +   为简单起见，用户可以组织成组，一个整个组的单个 ACL 条目。

    +   ACL 可以非常通用（Windows）或简化（Unix）。

    +   UNIX：每个文件 9 位：

        +   所有者，组，任何人

        +   读取，写入，执行权限对以上每个权限

        +   此外，用户“root”对所有内容���具有所有权限

    +   ACL（访问控制列表）简单且几乎在所有文件系统中使用。

+   *功能*：按行组织。

    +   对于每个用户，指示可以访问哪些对象以及以何种方式。

    +   与每个用户一起存储一个<对象，特权>对列表。这称为*功能列表*。

    +   通常，功能也充当对象的名称：不能命名未在您的功能列表中引用的对象。

+   基于 ACL 的系统鼓励对象的可见性：共享的公共命名空间。

+   能力系统不鼓励可见性；命名空间默认为私有。

+   能力已经在试图保持安全的实验系统中使用过。然而，它们被证明难以使用（共享事物痛苦），因此它们在管理文件等对象方面大多已经不受青睐。

## 访问强制执行

+   系统的某部分必须负责执行访问控制并保护身份验证和授权信息。

+   系统的这部分拥有完全的权限，因此应尽可能小而简单。例如：设置页表的系统部分。

+   一种可能的方法：*安全内核*

    +   操作系统的内部层强制执行安全性；只有这一层拥有完全的权限。

    +   大多数操作系统没有安全内核：整个操作系统拥有无限的权限。

## 杂项问题

+   *权限放大*

    +   一种机制，使被调用者获得比其调用者更多（或不同的）权限。

    +   简单示例：内核调用

    +   另一个例子：Unix *设置用户标识*（setuid）：

        +   每个文件都有一个额外的保护位"s"（用于 setuid）。

        +   通常，每个进程都以创建它的进程相同的用户标识运行。

        +   如果一个可执行文件被调用时设置了 setuid，那个进程的有效用户标识将更改为可执行文件的所有者。

        +   典型用法：将用户设置为 root 以安全且受控的方式执行受保护的操作。

+   要使所有这些机制都能够正常运行，且没有任何可以被恶意分子利用的漏洞是极其困难的。学习 CS 155 可以了解更多。
