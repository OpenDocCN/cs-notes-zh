- en: 1.4 Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 数组
- en: 原文：[https://introcs.cs.princeton.edu/python/14array](https://introcs.cs.princeton.edu/python/14array)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/14array](https://introcs.cs.princeton.edu/python/14array)
- en: A *data structure* is a way to organize data that we wish to process with a
    computer program. A *one-dimensional array* (or *array*) is a data structure that
    stores a sequence of (references to) objects. We refer to the objects within an
    array as its *elements*. The method that we use to refer to elements in an array
    is *numbering* and then *indexing* them. If we have *n* elements in the sequence,
    we think of them as being numbered from 0 to *n* - 1\. Then, we can unambiguously
    specify one of them by referring to the *i*th element for any integer *i* in this
    range.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据结构*是一种组织我们希望用计算机程序处理的数据的方式。*一维数组*（或*数组*）是一种存储对象序列（引用）的数据结构。我们将数组中的对象称为其*元素*。我们用来引用数组中的元素的方法是*编号*，然后*索引*它们。如果我们有*
    n *个元素在序列中，我们认为它们从0到* n *-1编号。然后，我们可以通过引用该范围内的任何整数*i*的第*i*个元素来明确指定其中的一个。'
- en: 'A *two-dimensional array* is an array of (references to) one-dimensional arrays.
    Whereas the elements of a one-dimensional array are indexed by a single integer,
    the elements of a two-dimensional array are indexed by a pair of integers: the
    first specifying a row, and the second specifying a column.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*二维数组*是一个（引用）一维数组的数组。一维数组的元素由单个整数索引，而二维数组的元素由一对整数索引：第一个指定行，第二个指定列。'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Arrays in Python
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的数组
- en: The simplest way to create an array in Python is to place comma-separated literals
    between matching square brackets. For example, the code
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建数组的最简单方法是在匹配的方括号之间放置逗号分隔的文字。例如，代码
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: creates an array `SUITS[]` with four strings, and creates arrays `x[]` and `y[]`,
    each with three floats.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含四个字符串的数组`SUITS[]`，并创建包含三个浮点数的数组`x[]`和`y[]`。
- en: 'Given two vectors of the same length, their *dot product* is the sum of the
    products of their corresponding components. If we represent the two vectors as
    one-dimensional arrays `x[]` and `y[]` that are each of length n, their dot product
    is easy to compute:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 给定相同长度的两个向量，它们的*点积*是它们对应分量的乘积之和。如果我们将两个向量表示为长度为n的一维数组`x[]`和`y[]`，它们的点积很容易计算：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For example, following trace shows the computation of the dot product of two
    vectors of length 3\.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下跟踪显示了计算长度为3的两个向量的点积。
- en: '![](../Images/e114ab4627575c0526ed48dbadceb1b9.png)'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/e114ab4627575c0526ed48dbadceb1b9.png)'
- en: '![Array Data Structure](../Images/200f6a897c59649a78a6e9fd1bfe9574.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![数组数据结构](../Images/200f6a897c59649a78a6e9fd1bfe9574.png)'
- en: It is useful to think of references to the elements in an array as stored contiguously,
    one after the other, in your computer's memory, as shown in the diagram at the
    right for the `SUITS[]` array defined above.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组中元素的引用连续存储在计算机内存中，如上图所示，对于上面定义的`SUITS[]`数组。
- en: Zero-based indexing.
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于零的索引。
- en: We always refer to the first element of an array a[] as a[0], the second as
    a[1], and so forth. It might seem more natural to refer to the first element as
    a[1], the second element as a[2], and so forth, but starting the indexing with
    0 has some advantages and has emerged as the convention used in most modern programming
    languages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是将数组a[]的第一个元素称为a[0]，第二个称为a[1]，依此类推。可能更自然的是将第一个元素称为a[1]，第二个元素称为a[2]，依此类推，但从0开始索引有一些优势，并且已经成为大多数现代编程语言使用的约定。
- en: Array length.
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组长度。
- en: 'You can access the length of an array using Python''s built-in `len()` function:
    `len(a)` is the number of elements in `a[]`. In Python, we can use the `+=` operator
    to append elements to an array. For example, if `a[]` is the array `[1, 2, 3]`,
    then the statement `a += [4]` extends it to `[1, 2, 3, 4]`. More generally, we
    can make an array of `n` floats, with each element initialized to `0.0`, with
    the code'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Python内置的`len()`函数访问数组的长度：`len(a)`是`a[]`中元素的数量。在Python中，我们可以使用`+=`运算符将元素附加到数组。例如，如果`a[]`是数组`[1,
    2, 3]`，那么语句`a += [4]`将其扩展为`[1, 2, 3, 4]`。更一般地，我们可以使用以下代码创建一个包含`n`个浮点数的数组，其中每个元素初始化为`0.0`，
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bounds checking.
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界检查。
- en: You must be careful when programming with arrays. It is your responsibility
    to use legal indices when accessing an array element.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数组编程时必须小心。在访问数组元素时使用合法索引是您的责任。
- en: Mutability.
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变性。
- en: '![](../Images/13c3ece2115d0c03d8d81ee3bae3030c.png)An object is *mutable* if
    its value can change. Arrays are mutable objects because we can change their elements.
    For example, if we create an array with the code `x = [.30, .60, .10]`, then the
    assignment statement `x[1] = .99` changes it to the array `[.30, .99, .10]`. An
    object-level trace of this operation is shown at the right.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象是*可变*的，那么它的值可以改变。数组是可变对象，因为我们可以改变它们的元素。例如，如果我们用代码`x = [.30, .60, .10]`创建一个数组，那么赋值语句`x[1]
    = .99`将把它改变为数组`[.30, .99, .10]`。这个操作的对象级跟踪显示在右侧。
- en: 'The following code reverses the order of the elements in an array a[]:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码颠倒了数组a[]中元素的顺序：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An informal trace ![](../Images/7281aa8c0eb3fe39c04e0d43de548f96.png)of this
    code for a seven-element array `[3, 1, 4, 1, 5, 9, 2]` is shown at the right.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包含七个元素的数组`[3, 1, 4, 1, 5, 9, 2]`，这段代码的非正式跟踪显示在右侧。
- en: Iteration.
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代。
- en: 'The following code iterates over all elements of an array to compute the average
    of the floats that it contains:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码遍历数组的所有元素以计算其中包含的浮点数的平均值：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Python also supports iterating over the elements in an array without referring
    to the indices explicitly. To do so, put the array name after the `in` keyword
    in a `for` statement, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python还支持在不显式引用索引的情况下迭代数组中的元素。为此，在`for`语句中的`in`关键字后放置数组名称，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Built-in functions.
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置函数。
- en: Python has several built-in functions that can take arrays as arguments. We
    have already discussed the `len()` function. As another example, if the elements
    of `a[]` are numeric, then sum(a) computes their sum, so that we can compute their
    average with `float(sum(a)) / len(a)` instead of using either of the loops just
    described. Other useful built-in functions that can take arrays as arguments are
    `min()` for computing the minimum and `max()` for computing the maximum.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个可以接受数组作为参数的内置函数。我们已经讨论了`len()`函数。举个例子，如果`a[]`的元素是数字，那么`sum(a)`会计算它们的和，因此我们可以使用`float(sum(a))
    / len(a)`来计算它们的平均值，而不是使用刚刚描述的任何一个循环。其他有用的可以接受数组作为参数的内置函数有用于计算最小值的`min()`和用于计算最大值的`max()`。
- en: Writing an array.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入数组。
- en: You can write an array by passing it as an argument to `stdio.write()` or `stdio.writeln()`.
    Each object in the array is converted to a string.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将数组作为参数传递给`stdio.write()`或`stdio.writeln()`来写入数组。数组中的每个对象都会被转换为一个字符串。
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Array Aliases and Copies
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组别名和复制
- en: Before looking at programs that use arrays, it is worthwhile to examine two
    fundamental array-processing operations in more detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看使用数组的程序之前，值得更详细地研究两个基本的数组处理操作。
- en: Aliasing.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名。
- en: '![Aliasing an array](../Images/46ee1209f80c593e59c1b862423f3922.png)If `x[]`
    and `y[]` are arrays, the statement `x = y` causes `x` and `y` to reference the
    same array. This result has an effect that is perhaps unexpected, at first, because
    it is natural to think of `x` and `y` as references to two independent arrays.
    For example, after the assignment statements'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![数组别名](../Images/46ee1209f80c593e59c1b862423f3922.png)如果`x[]`和`y[]`是数组，则语句`x
    = y`会导致`x`和`y`引用同一个数组。这个结果可能一开始会让人感到意外，因为自然而然地会认为`x`和`y`是指向两个独立数组的引用。例如，在赋值语句之后'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`y[1]` is also `.99`, even though the code does not refer directly to `y[1]`.
    This situation — whenever two variables refer to the same object — is known as
    *aliasing*, and is illustrated in the object-level trace at the right.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`y[1]`也是`.99`，即使代码没有直接引用`y[1]`。这种情况——当两个变量引用同一个对象时——被称为*别名*，并在右侧的对象级别跟踪中进行了说明。'
- en: Copying and slicing.
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制和切片。
- en: '![](../Images/4e1ce3311743e66750be1e765eac2cd0.png)So how do we make a copy
    `y[]` of a given array `x[]`? One answer to this question is to iterate through
    `x[]` to build `y[]`, as in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4e1ce3311743e66750be1e765eac2cd0.png)那么我们如何复制给定数组`x[]`的副本`y[]`？对于这个问题的一个答案是通过遍历`x[]`来构建`y[]`，就像以下代码中所示：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This situation is illustrated in the object-level trace at the right.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在右侧的对象级别跟踪中进行了说明。
- en: Copying an array is such a useful operation that Python provides language support
    for a more general operation known as *slicing*, The expression `a[i:j]` evaluates
    to a new array whose elements are `a[i], ..., a[j-1]`. Moreover, the default value
    for `i` is 0 and the default value for `j` is `len(a)`, so `y = x[:]` is equivalent
    to the code given earlier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数组是一个非常有用的操作，Python为更一般的操作提供了语言支持，称为*切片*，表达式`a[i:j]`评估为一个新数组，其元素为`a[i], ...,
    a[j-1]`。此外，`i`的默认值为0，`j`的默认值为`len(a)`，因此`y = x[:]`等同于前面给出的代码。
- en: '* * *'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: System Support for Arrays
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的系统支持
- en: Python code for processing arrays can take many forms. We describe each briefly
    for context.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理数组的Python代码可以采用多种形式。我们简要描述每种形式以便理解上下文。
- en: Python's built-in `list` data type.
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python内置的`list`数据类型。
- en: 'In its most basic form, an array supports four core operations: creation, indexed
    access, indexed assignment, and iteration. In this booksite, we use Python''s
    built-in `list` data type for arrays because it supports these basic operations.
    We consider more elaborate operations supported by Python''s `list` data type
    in Chapter 4.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，数组支持四个核心操作：创建、索引访问、索引赋值和迭代。在这个书站中，我们使用Python的内置`list`数据类型来表示数组，因为它支持这些基本操作。我们将在第4章中考虑Python的`list`数据类型支持的更复杂的操作。
- en: Python's `numpy` module.
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python的`numpy`模块。
- en: 'Python''s built-in `list` data type can have severe performance problems. For
    that reason, scientists and engineers often use a Python extension module called
    `numpy` for processing huge arrays of numbers, because that module uses a lower-level
    representation that avoids many of the inefficiencies in the standard Python representation.
    See Appendix: `numpy` for an overview of the `numpy` module.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置的`list`数据类型可能会存在严重的性能问题。因此，科学家和工程师经常使用一个名为`numpy`的Python扩展模块来处理大量的数字数组，因为该模块使用了一个避免了标准Python表示中许多低效的表示的底层表示。请参阅附录：`numpy`以获取`numpy`模块的概述。
- en: Our `stdarray` module.
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的`stdarray`模块。
- en: 'Earlier we introduced the booksite `stdio` module. Now, we introduce another
    booksite module: the `stdarray` module. Its primary purpose is to define functions
    for processing arrays.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们介绍了书站`stdio`模块。现在，我们介绍另一个书站模块：`stdarray`模块。它的主要目的是定义用于处理数组的函数。
- en: 'A fundamental operation that is found in nearly every array-processing program
    is to create an array of *n* elements, each initialized to a given value. As we
    have seen, you can do this in Python with code like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个数组处理程序中都会找到的一个基本操作是创建一个包含*n*个元素的数组，每个元素都初始化为给定值。正如我们所见，你可以使用类似以下代码在Python中实现这一点：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Such code is so common that Python even has a special shorthand notation for
    it: the code `a = [0.0]*n` is equivalent to the code just given. Rather than repeat
    such code throughout the book, we will use code like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码是如此常见，以至于Python甚至为其提供了一个特殊的简写表示法：代码`a = [0.0]*n`等同于刚刚给出的代码。为了避免在整本书中重复这样的代码，我们将使用类似这样的代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For consistency, `stdarray` also includes a `create2D()` function, which we
    will examine later in this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致，`stdarray`还包括一个`create2D()`函数，我们将在本节稍后讨论。
- en: '![Stdarray API](../Images/2cc2d66e674cfef0900458c157bd23f2.png)'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stdarray API](../Images/2cc2d66e674cfef0900458c157bd23f2.png)'
- en: '* * *'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Sample Applications of Arrays
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的示例应用
- en: Next, we consider a number of applications that illustrate the utility of arrays
    and also are interesting in their own right.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑一些应用程序，这些应用程序说明了数组的实用性，并且本身也很有趣。
- en: Representing playing cards.
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示扑克牌。
- en: 'Suppose that we want to compose programs that process playing cards. We might
    start with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写处理扑克牌的程序。我们可能从以下代码开始：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, we might use these two arrays to write a random card name, such
    as `Queen of Clubs`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用这两个数组来编写一个随机的卡片名称，比如`梅花皇后`，如下所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A more typical situation is when we compute the values to be stored in an array.
    For example, we might use the following code to initialize an array of length
    52 that represents a deck of playing cards, using the two arrays just defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更典型的情况是当我们计算要存储在数组中的值时。例如，我们可以使用以下代码初始化一个长度为52的数组，表示一副扑克牌，使用刚刚定义的两个数组：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exchange.
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交换。
- en: 'Frequently, we wish to exchange two elements in an array. Continuing our example
    with playing cards, the following code exchanges the cards at indices `i` and
    `j`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，我们希望在数组中交换两个元素。继续我们的扑克牌示例，以下代码交换索引`i`和`j`处的卡片：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Shuffle
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 洗牌
- en: '. The following code shuffles our deck of cards:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 。以下代码洗牌我们的牌组：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Proceeding from left to right, we pick a random card from deck[i] through deck[n-1]
    (each card equally likely) and exchange it with deck[i].
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右进行，我们从deck[i]到deck[n-1]中随机选择一张卡片（每张卡片等概率），并将其与deck[i]交换。
- en: Sampling without replacement.
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无放回抽样。
- en: In many situations, we want to draw a random sample from a set such that each
    element in the set appears at most once in the sample. The program [sample.py](sample.py.html)
    takes command-line arguments `m` and `n` and creates a permutation of size `n`
    whose first `m` elements constitute a random sample.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望从一个集合中随机抽取一个样本，以便集合中的每个元素在样本中最多出现一次。程序[sample.py](sample.py.html)接受命令行参数`m`和`n`，并创建一个大小为`n`的排列，其中前`m`个元素构成一个随机样本。
- en: Precomputed values.
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预先计算的值。
- en: 'Another application of arrays is to save values that you have computed for
    later use. As an example, suppose that you are composing a program that performs
    calculations using small values of the harmonic numbers. An efficient approach
    is to save the values in an array, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的另一个应用是保存您已计算的值以供以后使用。例如，假设您正在编写一个使用调和数小值进行计算的程序。一种高效的方法是将这些值保存在数组中，如下所示：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we waste one slot in the array (element 0) to make harmonic[1] correspond
    to the first harmonic number 1.0 and harmonic[i] correspond to the ith harmonic
    number. This method is not effective if we need values for huge n, but it is very
    effective if we need values for small n many different times.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在数组中浪费了一个槽位（元素0），以使harmonic[1]对应于第一个调和数1.0，而harmonic[i]对应于第i个调和数。如果我们需要大量n的值，这种方法并不有效，但如果我们需要多次获取小n的值，这种方法非常有效。
- en: Simplifying repetitive code.
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化重复代码。
- en: 'As an example of another simple application of arrays, consider the following
    code fragment, which writes the name of a month given its number (1 for January,
    2 for February, and so forth):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数组的另一个简单应用的例子，考虑以下代码片段，根据月份的数字（1代表一月，2代表二月，依此类推）写出月份的名称：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A more compact alternative is to use an array of strings holding the month
    names:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更紧凑的替代方案是使用一个包含月份名称的字符串数组：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This technique would be especially useful if you needed to access the name of
    a month by its number in several different places in your program. Note that we
    intentionally waste one slot in the array (element 0) to make `MONTHS[1]` correspond
    to January, as required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在程序中的多个不同位置通过其数字访问月份的名称，这种技术将特别有用。请注意，我们故意浪费了数组中的一个槽位（元素0），以使`MONTHS[1]`对应于一月，如所需。
- en: '![](../Images/bdc96ebdc3d0e502cb98eccdc7cbd430.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bdc96ebdc3d0e502cb98eccdc7cbd430.png)'
- en: Coupon collector.
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集优惠券。
- en: 'Suppose that you have a deck of cards and you pick cards at random (with replacement)
    one by one. How many cards do you need to turn up before you have seen one of
    each suit? That is an example of the famous *coupon collector* problem. In general,
    suppose that a trading card company issues trading cards with n different possible
    cards: how many do you have to collect before you have all n possibilities, assuming
    that each possibility is equally likely for each card that you collect? The program
    [couponcollector.py](couponcollector.py.html) is an example program that simulates
    this process. See the textbook for details.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一副牌，并且你逐个随机选择卡片（有放回地）。在你看到每种花色之前，你需要翻开多少张卡片？这是著名的*收集优惠券*问题的一个例子。一般来说，假设一个交易卡公司发行了具有n种不同可能卡片的交易卡：在你收集到所有n种可能性之前，你需要收集多少张卡片，假设每张卡片收集时每种可能性都是等概率的？程序[couponcollector.py](couponcollector.py.html)是一个模拟这一过程的示例程序。详细信息请参阅教科书。
- en: Sieve of Eratosthenes.
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼筛法。
- en: The prime counting function *π*(*n*) is the number of primes less than or equal
    to *n*. For example *π*(17) = 7 since the first seven primes are 2, 3, 5, 7, 11,
    13, and 17\. Program [primesieve.py](primesieve.py.html) takes a command line
    integer n and computes *π*(*n*) using the [Sieve of Eratosthenes](http://mathworld.wolfram.com/SieveofEratosthenes.html).
    See the textbook for details.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 素数计数函数*π*(*n*)是小于或等于*n*的素数的数量。例如*π*(17) = 7，因为前七个素数是2、3、5、7、11、13和17。程序[primesieve.py](primesieve.py.html)接受一个命令行整数n，并使用[埃拉托斯特尼筛法](http://mathworld.wolfram.com/SieveofEratosthenes.html)计算*π*(*n*)。详细信息请参阅教科书。
- en: '* * *'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Two-Dimensional Arrays
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二维数组
- en: '![](../Images/c7dde38383471de0cf1aa29eec1f8ccb.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c7dde38383471de0cf1aa29eec1f8ccb.png)'
- en: In many applications, a convenient way to store information is to use a table
    of numbers organized in a rectangular table and refer to rows and columns in the
    table. The mathematical abstraction corresponding to such tables is a *matrix*;
    the corresponding data structure is a *two-dimensional array*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，存储信息的一种便捷方式是使用一个以矩形表格组织的数字表，并引用表中的行和列。对应于这种表格的数学抽象是*矩阵*；相应的数据结构是*二维数组*。
- en: Initialization.
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化。
- en: The simplest way to create a two-dimensional array is to place comma-separated
    one-dimensional arrays between matching square brackets. For example, this matrix
    of integers having two rows and three columns
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建二维数组的最简单方法是在匹配的方括号之间放置逗号分隔的一维数组。例如，以下具有两行三列的整数矩阵
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'could be represented in Python using this array of arrays:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下数组表示在Python中：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We call such an array a *2-by-3* array. More generally, Python represents an
    *m*-by-*n* array as an array that contains *m* objects, each of which is an array
    that contains *n* objects. For example, this Python code creates an *m*-by-*n*
    array `a[][]` of floats, with all elements initialized to 0.0:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这样的数组为*2乘3*数组。更一般地，Python将*m*乘*n*数组表示为包含*m*个对象的数组，每个对象都是包含*n*个对象的数组。例如，以下Python代码创建了一个浮点数的*m*乘*n*数组`a[][]`，其中所有元素都初始化为0.0：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As for one-dimensional arrays, we use the self-descriptive alternative `stdarray.create2D(m,
    n, 0.0)` from our booksite module `stdarray` throughout this booksite.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维数组，我们在整个本站使用了自描述的替代方案`stdarray.create2D(m, n, 0.0)`，该方案来自我们的本站模块`stdarray`。
- en: Indexing.
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引。
- en: When `a[][]` is a two-dimensional array, the syntax `a[i]` denotes a reference
    to its `i`th row. The syntax `a[i][j]` refers to the object at row `i` and column
    `j`. To access each of the elements in a two-dimensional array, we use two nested
    `for` loops. For example, this code writes each object of the *m*-by-*n* array
    `a[][]`, one row per line.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当`a[][]`是一个二维数组时，语法`a[i]`表示对其第`i`行的引用。语法`a[i][j]`指的是第`i`行和第`j`列的对象。为了访问二维数组中的每个元素，我们使用两个嵌套的`for`循环。例如，以下代码将*m*乘*n*数组`a[][]`的每个对象写入，每行一个。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code achieves the same effect without using indices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码实现了相同的效果，而不使用索引：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/df81a47071dbd1e5ced8f4147b806b14.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/df81a47071dbd1e5ced8f4147b806b14.png)'
- en: Matrix operations.
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵操作。
- en: 'Typical applications in science and engineering involve representing matrices
    as two-dimensional arrays and then implementing various mathematical operations
    with matrix operands. For example, we can *add* two *n*-by-*n* matrices `a[][]`
    and `b[][]` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学和工程中的典型应用涉及将矩阵表示为二维数组，然后使用矩阵操作数实现各种数学运算。例如，我们可以如下*相加*两个*n*乘*n*的矩阵`a[][]`和`b[][]`：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similarly, we can *multiply* two matrices. Each element `c[i][j]` in the product
    of `a[][]` and `b[][]` is computed by taking the dot product of row `i` of `a[][]`
    with column `j` of `b[][]`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以*相乘*两个矩阵。矩阵`a[][]`和`b[][]`的乘积中每个元素`c[i][j]`是通过计算`a[][]`的第`i`行与`b[][]`的第`j`列的点积得到的。
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ragged arrays.
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不规则数组。
- en: 'There is actually no requirement that all rows in a two-dimensional array have
    the same length. An array with rows of nonuniform length is known as a *ragged
    array*. The possibility of ragged arrays creates the need for taking more care
    in crafting array-processing code. For example, this code writes the contents
    of a ragged array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，并不要求二维数组中的所有行具有相同的长度。行长不一的数组称为*不规则数组*。不规则数组的可能性需要在编写数组处理代码时更加小心。例如，以下代码写入了一个不规则数组的内容：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that the equivalent code that does not use indices works equally well
    with both rectangular and ragged arrays:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不使用索引的等效代码对于矩形数组和不规则数组同样有效：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Multidimensional arrays.
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组。
- en: The same notation extends to allow us to compose code using arrays that have
    any number of dimensions. Using arrays of arrays of arrays..., we can create three-dimensional
    arrays, four-dimensional arrays, and so forth, and then refer to an individual
    element with code like `a[i][j][k]`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的表示法扩展到允许我们��用任意维数的数组来组合代码。使用数组的数组的数组...，我们可以创建三维数组、四维数组等，然后使用诸如`a[i][j][k]`的代码引用单个元素。
- en: 'Example: self-avoiding random walks.'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：避免自我随机漫步。
- en: The program [selfavoid.py](selfavoid.py.html) is an application of two-dimensional
    arrays to chemistry. See the textbook for details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[selfavoid.py](selfavoid.py.html)是将二维数组应用于化学的一个示例。有关详细信息，请参阅教科书。
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** Why do Python string and list indices start at 0 instead of 1?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 为什么Python字符串和列表的索引从0开始而不是从1开始？'
- en: '**A.** That convention originated with machine-language programming, where
    the address of an array element would be computed by adding the index to the address
    of the beginning of an array. Starting indices at 1 would entail either a waste
    of space at the beginning of the array or a waste of time to subtract the 1\.
    Here''s [Edsger Dijkstra''s explanation](http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 这种约定起源于机器语言编程，其中计算数组元素的地址是通过将索引加到数组开头的地址来完成的。从1开始的索引要么会导致在数组开头浪费空间，要么会浪费时间来减去1。这里是[Edsger
    Dijkstra的解释](http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF)。'
- en: '**Q.** What happens if I use a negative integer to index an array?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 如果我使用负整数索引数组会发生什么？'
- en: '**A.** The answer may surprise you. Given an array `a[]`, you can use the index
    `-i` as shorthand for `len(a)-i`. For example, you can refer to the last element
    in the array with `a[-1]` or `a[len(a)-1]` and the first element with `a[-len(a)]`
    or `a[0]`. Python raises an `IndexError` at run time if you use an index outside
    of the range `-len(a)` through `len(a)-1`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 答案可能会让你惊讶。给定一个数组`a[]`，您可以使用索引`-i`作为`len(a)-i`的简写。例如，您可以用`a[-1]`或`a[len(a)-1]`引用数组中的最后一个元素，用`a[-len(a)]`或`a[0]`引用第一个元素。如果您使用范围在`-len(a)`到`len(a)-1`之外的索引，Python会在运行时引发`IndexError`。'
- en: '**Q.** Why does the slice `a[i:j]` include `a[i]` but exclude `a[j]`?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 为什么切片`a[i:j]`包括`a[i]`但不包括`a[j]`？'
- en: '**A.** The notation is consistent with ranges defined with `range()`, which
    includes the left endpoint but excludes the right endpoint. It leads to some appealing
    properties: `j-i` is the length of the subarray (assuming no truncation); `a[0:len(a)]`
    is the entire array; `a[i:i]` is the empty array; and a`[i:j] + a[j:k]` is the
    subarray `a[i:k]`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 这种表示法与使用`range()`定义的范围一致，其中包括左端点但不包括右端点。它导致一些吸引人的特性：`j-i`是子数组的长度（假设没有截断）；`a[0:len(a)]`是整个数组；`a[i:i]`是空数组；`a[i:j]
    + a[j:k]`是子数组`a[i:k]`。'
- en: '**Q.** What happens when I compare two arrays `a[]` and `b[]` with `(a == b)`?'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 当我用`(a == b)`比较两个数组`a[]`和`b[]`时会发生什么？'
- en: '**A.** It depends. For arrays (or multidimensional arrays) of numbers, it works
    as you might expect: the arrays are equal if each has the same length and the
    corresponding elements are equal.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这取决于情况。对于数字数组（或多维数组），它的工作方式如你所期望的：如果每个数组具有相同的长度且对应元素相等，则数组相等。'
- en: '**Q.** What happens when a random walk does not avoid itself?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 当随机漫步不避免自身时会发生什么？'
- en: '**A.** This case is well understood. It is a two-dimensional version of the
    gambler''s ruin problem, as described in Section 1.3.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这种情况很容易理解。这是一个二维版本的赌徒破产问题，如1.3节所述。'
- en: '**Q.** Which pitfalls should I watch out for when using arrays?'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 使用数组时应该注意哪些陷阱？'
- en: '**A.** Remember that creating an array takes time proportional to the length
    of the array. You need to be particularly careful about creating arrays within
    loops.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 记住，创建数组所需的时间与数组的长度成正比。在循环内创建数组时要特别小心。'
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Compose a program that creates a one-dimensional array `a` containing exactly
    1000 integers, and then attempts to access `a[1000]`. What happens when you run
    the program?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，创建一个包含恰好1000个整数的一维数组`a`，然后尝试访问`a[1000]`。运行程序时会发生什么？
- en: Given two vectors of length `n` that are represented with one-dimensional arrays,
    compose a code fragment that computes the *Euclidean distance* between them (the
    square root of the sum of the squares of the differences between corresponding
    elements).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定用一维数组表示的长度为`n`的两个向量，编写一个代码片段，计算它们之间的*欧几里德距离*（对应元素之间差的平方和的平方根）。
- en: 'Compose a code fragment that reverses the order of a one-dimensional array
    of floats. Do not create another array to hold the result. *Hint*: Use the code
    provided earlier in this web page for exchanging two elements.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，反转一个浮点数一维数组的顺序。不要创建另一个数组来保存结果。*提示*：使用本网页早期提供的代码交换两个元素。
- en: '*Solution:*'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What is wrong with the following code fragment?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段有什么问题？
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Solution*: Initially `a` is the empty array. Subsequently no elements are
    appended to the array. Thus `a[0]`, `a[1]`, and so forth do not exist. The attempts
    to use them in an assignment statement will raise an `IndexError` at run time.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：最初`a`是空数组。随后没有元素附加到数组中。因此，`a[0]`，`a[1]`等等不存在。在赋值语句中尝试使用它们将在运行时引发`IndexError`。'
- en: Compose a code fragment that writes the contents of a two-dimensional array
    of bools, using `*` to represent `True` and a space to represent `False`. Include
    row and column numbers.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，使用`*`表��`True`，空格表示`False`，写出一个布尔值的二维数组的内容。包括行号和列号。
- en: What does the following code fragment write?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段写出了什么？
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What is `a[]` afater executing the following code fragment?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码片段后`a[]`是什么？
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compose a program that takes an integer command-line argument `n` and writes
    `n` poker hands (five cards each) from a shuffled deck, separated by blank lines.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行参数`n`中接受一个整数，并从洗牌后的牌组中写出`n`个扑克手（每个五张牌），用空行分隔。
- en: '*Solution*: See [deal.py](deal.py.html).'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[deal.py](deal.py.html)。'
- en: 'Compose code fragments to create a two-dimensional array `b[][]` that is a
    copy of an existing two-dimensional array `a[][]`, under each of the following
    assumptions:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码片段创建一个二维数组`b[][]`，它是现有二维数组`a[][]`的副本，在以下每种假设下：
- en: '`a` is square.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`是方阵的。'
- en: '`a` is rectangular.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`是矩形的。'
- en: '`a` may be ragged.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`可能是不规则的。'
- en: Your solution to (b) should work for (a), and your solution to (c) should work
    for both (b) and (a).
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你对(b)的解决方案应该适用于(a)，你对(c)的解决方案应该适用于(b)和(a)。
- en: 'Compose a code fragment to write the *transposition* (rows and columns changed)
    of a two-dimensional array. For the example, when given this two-dimensional array
    of integers:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，写出一个二维数组的*转置*（行和列交换）。例如，给定这个整数二维数组：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'your code should write this:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的代码应该写出这个：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compose a code fragment to transpose a square two-dimensional array `b[][]`
    in place without creating a second array.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，就地转置一个方阵二维数组`b[][]`，而不创建第二个数组。
- en: '*Solution.* See [transpose.py](transpose.py.html).'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。参见[transpose.py](transpose.py.html)。'
- en: Compose a code fragment to create a two-dimensional array `b[][]` that is the
    transpose of an existing *m*-by-*n* array `a[][]`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，创建一个二维数组`b[][]`，它是现有*m*乘*n*数组`a[][]`的转置。
- en: Compose a program that computes the product of two square matrices of boolean
    values, using the `or` operation instead of `+` and the `and` operation instead
    of `*`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，计算两个布尔值方阵的乘积，使用`or`操作代替`+`，使用`and`操作代替`*`。
- en: Compose a program that accepts an integer *n* from the command line and creates
    an *n*-by-*n* boolean array `a` such that `a[r][c]` is `True` if `r` and `c` are
    relatively prime (have no common factors other than 1), and `False` otherwise.
    Then write the array (see a previous exercise in this section of the booksite)
    using `*` to represent `True` and a space to represent `False`. Include row and
    column numbers. *Hint:* Use sieving.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行接受一个整数*n*，创建一个*n*乘*n*的布尔数组`a`，使得`a[r][c]`为`True`，如果`r`和`c`是互质的（除了1没有其他公因数），否则为`False`。然后使用`*`表示`True`，空格表示`False`写出数组（参见书站本节中的先前练习）。包括行号和列号。*提示*：使用筛法。
- en: 'Compose a code fragment to multiply two rectangular matrices of floats that
    are not necessarily square. *Note*: For the dot product to be well-defined, the
    number of columns in the first matrix must be equal to the number of rows in the
    second matrix. Write an error message if the dimensions do not satisfy this condition.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，用于乘法计算两个不一定是方阵的浮点数矩阵。*注意*：为了使点积有明确定义，第一个矩阵的列数必须等于第二个矩阵的行数。如果维度不满足此条件，请写出错误消息。
- en: Modify [selfavoid.py](selfavoid.py.html) to calculate and write the average
    length of the paths as well as the dead-end probability. Keep separate the average
    lengths of escape paths and dead-end paths.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[selfavoid.py](selfavoid.py.html)以计算并写入路径的平均长度以及死胡同的概率。保持逃逸路径和死胡同路径的平均长度分开。
- en: Modify [selfavoid.py](selfavoid.py.html) to calculate and write the average
    area of the smallest axis-oriented rectangle that encloses the path. Keep separate
    statistics for escape paths and dead-end paths.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[selfavoid.py](selfavoid.py.html)以计算并写入包围路径的最小轴向矩形的平均面积。为逃逸路径和死胡同路径保持统计数据分开。
- en: Creative Exercises
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Dice simulation.** The following code computes the exact probability distribution
    for the sum of two dice:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**骰子模拟。** ���下代码计算两个骰子点数之和的精确概率分布：'
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After this code completes, `probabilities[k]` is the probability that the dice
    sum to `k`. Run experiments to validate this calculation simulating *n* dice throws,
    keeping track of the frequencies of occurrence of each value when you compute
    the sum of two random integers between 1 and 6\. How large does *n* have to be
    before your empirical results match the exact results to three decimal places?
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码完成后，`probabilities[k]` 是骰子点数为 `k` 的概率。运行实验验证这个计算，模拟 *n* 次掷骰子，跟踪每个值出现的频率，当你计算两个介于
    1 和 6 之间的随机整数的和时。在你的经验结果与精确结果匹配到小数点后三位之前，*n* 必须有多大？
- en: '**Longest plateau.** Given an array of integers, compose a program that finds
    the length and location of the longest contiguous sequence of equal values where
    the values of the elements just before and just after this sequence are smaller.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长高原。** 给定一个整数数组，编写一个程序，找到最长连续相等值序列的长度和位置，其中该序列前后的元素值较小。'
- en: '**Empirical shuffle check.** Run computational experiments to check that our
    shuffling code works as advertised. Compose a program that takes integer command-line
    arguments *m* and *n*, does *n* shuffles of an array of size *m* that is initialized
    with `a[i] = i` before each shuffle, and writes an *m*-by-*m* table such that
    row `i` gives the number of times `i` wound up in position `j` for all `j`. All
    entries in the array should be close to *n*/*m*.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经验洗牌检查。** 运行计算实验以检查我们的洗牌代码是否按照广告宣传的那样工作。编写一个程序，接受整数命令行参数 *m* 和 *n*，对一个大小为
    *m* 的数组进行 *n* 次洗牌，每次初始化为 `a[i] = i`，并写入一个 *m*×*m* 的表，其中第 `i` 行给出了 `i` 最终在所有 `j`
    位置上出现的次数。数组中的所有条目应接近于 *n*/*m*。'
- en: '**Bad shuffling.** Suppose that you choose a random integer between 0 and *n*-1
    in our shuffling code instead of one between `i` and `n-1`. Show that the resulting
    order is not equally likely to be one of the *n*! possibilities. Run the test
    of the previous exercise for this version.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**糟糕的洗牌。** 假设在我们的洗牌代码中选择一个介于 0 和 *n*-1 之间的随机整数，而不是介于 `i` 和 `n-1` 之间的随机整数。证明所得到的顺序不可能是
    *n*! 种可能性之一。对这个版本运行上一个练习的测试。'
- en: '*Partial solution:* When *n* = 3, all 3! = 6 outcomes are possible, but some
    are more likely:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案*：当 *n* = 3 时，有 3! = 6 种可能性，但有些更有可能：'
- en: '| ABC | ACB | BAC | BCA | CAB | CBA |'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ABC | ACB | BAC | BCA | CAB | CBA |'
- en: '| 4/27 | 5/27 | 6/27 | 4/27 | 5/27 | 3/27 |'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 4/27 | 5/27 | 6/27 | 4/27 | 5/27 | 3/27 |'
- en: '**Music shuffling.** You set your music player to shuffle mode. It plays each
    of the *n* songs before repeating any. Compose a program to estimate the likelihood
    that you will not hear any sequential pair of songs (that is, song 3 does not
    follow song 2, song 10 does not follow song 9, and so on).'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**音乐洗牌。** 你将音乐播放器设置为随机模式。它在重复任何歌曲之前播放 *n* 首歌曲。编写一个程序来估计你不会听到任何连续一对歌曲的可能性（即，歌曲
    3 不会跟在歌曲 2 后面，歌曲 10 不会跟在歌曲 9 后面，依此类推）。'
- en: '**Minima in permutations.** Compose a program that takes an integer *n* from
    the command line, generates a random permutation, writes the permutation, and
    writes the number of left-to-right minima in the permutation (the number of times
    an element is the smallest seen so far). Then compose a program that takes integers
    *m* and *n* from the command line, generates *m* random permutations of size *n*,
    and writes the average number of left-to-right minima in the permutations generated.
    *Extra credit*: Formulate a hypothesis about the number of left-to-right minima
    in a permutation of size *n*, as a function of *n*.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列中的极小值。** 编写一个程序，从命令行接受一个整数 *n*，生成一个随机排列，写入排列，并写入排列中从左到右的极小值的数量（元素是迄今为止看到的最小值的次数）。然后编写一个程序，从命令行接受整数
    *m* 和 *n*，生成大小为 *n* 的 *m* 个随机排列，并写入所生成排列中从左到右的极小值的平均数量。*额外奖励*：提出一个关于大小为 *n* 的排列中从左到右的极小值数量的假设，作为
    *n* 的函数。'
- en: '**Inverse permutation.** Compose a program that accepts a permutation of the
    integers 0 to *n*-1 from *n* command-line arguments and writes its inverse. (If
    the permutation is an array `a[]`, its inverse is the array `b[]` such that `a[b[i]]`
    = `b[a[i]]` = `i`.) Be sure to check that the input is a valid permutation.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆排列。** 编写一个程序，从 *n* 个命令行参数中接受整数范围为 0 到 *n*-1 的排列，并写入其逆排列。（如果排列是一个数组 `a[]`，其逆排列是数组
    `b[]`，使得 `a[b[i]]` = `b[a[i]]` = `i`。）确保检查输入是否是有效的排列。'
- en: '*Solution*: See [inversepermutation.py](inversepermutation.py.html).'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[inversepermutation.py](inversepermutation.py.html)。'
- en: '**Hadamard matrix.** The *n*-by-*n* Hadamard matrix *H[n]* matrix is a boolean
    matrix with the remarkable property that any two rows differ in exactly *n*/2
    elements. (This property makes it useful for designing *error-correcting codes*.)
    *H*[1] is a 1-by-1 matrix with the single element `True`, and for *n* > 1, *H*[2*n*]
    is obtained by aligning four copies of *H[n]* in a large square, and then inverting
    all of the elements in the lower right *n*-by-*n* copy, as shown in the following
    examples (with `T` representing `True` and `F` representing `False`, as usual).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哈达玛矩阵。** *n*×*n* 哈达玛矩阵 *H[n]* 是一个布尔矩阵，具有显著的特性，即任意两行在恰好 *n*/2 个元素上不同。（这个特性使其在设计*纠错码*时非常有用。）*H*[1]
    是一个 1×1 的矩阵，其中单个元素为 `True`，对于 *n* > 1，*H*[2*n*] 是通过将四个 *H[n]* 的副本对齐在一个大正方形中获得的，然后反转右下角的所有元素，如下例所示（其中
    `T` 代表 `True`，`F` 代表 `False`，如常）。'
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compose a program that takes one command-line argument *n* and writes *H[n]*.
    Assume that *n* is a power of 2.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个命令行参数*n*，并写出*H[n]*。假设*n*是2的幂。
- en: '*Solution*: See [hadamard.py](hadamard.py.html).'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[hadamard.py](hadamard.py.html)。'
- en: '**Rumors.** Alice is throwing a party with n other guests, including Bob. Bob
    starts a rumor about Alice by telling it to one of the other guests. A person
    hearing this rumor for the first time will immediately tell it to one other guest,
    chosen at random from all the people at the party except Alice and the person
    from whom they heard it. If a person (including Bob) hears the rumor for a second
    time, he or she will not propagate it further. Compose a program to estimate the
    probability that everyone at the party (except Alice) will hear the rumor before
    it stops propagating. Also calculate an estimate of the expected number of people
    to hear the rumor.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谣言。** 爱丽丝正在与其他n位客人举办派对，包括鲍勃。鲍勃向其中一位其他客人传播关于爱丽丝的谣言。第一次听到这个谣言的人会立即将其告诉另一位客人，从所有在派对上的人中（除了爱丽丝和他们听到谣言的人）随机选择一个。如果一个人（包括鲍勃）第二次听到这个谣言，他或她将不会再传播它。编写一个程序来估计在谣言停止传播之前每个在派对上的人（除了爱丽丝）都会听到谣言的概率。还计算一下预计会听到谣言的人数。'
- en: '**Find a duplicate.** Given an array of *n* elements with each element between
    1 and *n*, compose a code fragment to determine whether there are any duplicates.
    You do not need to preserve the contents of the given array, but do not use an
    extra array.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找重复项。** 给定一个包含*n*个元素的数组，每个元素介于1和*n*之间，编写一个代码片段来确定是否存在任何重复项。你不需要保留给定数组的内容，但不要使用额外的数组。'
- en: '**Minesweeper.** Compose a program that takes three command-line arguments
    *m*, *n*, and *p* and produces an *m*-by-*n* boolean array where each element
    is occupied with probability *p*. In the minesweeper game, occupied cells represent
    bombs and empty cells represent safe cells. Write the array using an asterisk
    for bombs and a period for safe cells. Then, replace each safe square with the
    number of neighboring bombs (above, below, left, right, or diagonal) and write
    the result, as in this example.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扫雷。** 编写一个程序，接受三个命令行参数*m*、*n*和*p*，并生成一个*m*乘*n*的布尔数组，其中每个元素以概率*p*被占据。在扫雷游戏中，被占据的单元格代表炸弹，空单元格代表安全单元格。用星号表示炸弹，用句点表示安全单元格。然后，用相邻炸弹的数量（上、下、左、右或对角线）替换每个安全方块，并写出结果，如下例所示。'
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Try to express your code so that you have as few special cases as possible to
    deal with, by using an (*m*+2)-by-(*n*+2) boolean array.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽量表达你的代码，使得尽可能少处理特殊情况，通过使用一个(*m*+2)-by-(*n*+2)的布尔数组。
- en: '*Solution*: See [minesweeper.py](minesweeper.py.html).'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[minesweeper.py](minesweeper.py.html)。'
- en: '**Self-avoiding walk length.** Suppose that there is no limit on the size of
    the grid. Run experiments to estimate the average walk length.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**避免自我行走长度。** 假设网格大小没有限制。运行实验估计平均步行长度。'
- en: '**Three-dimensional self-avoiding walks.** Run experiments to verify that the
    dead-end probability is 0 for a three-dimensional self-avoiding walk and to compute
    the average walk length for various values of *n*.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三维避障步行。** 运行实验以验证三维避障步行的死胡同概率为0，并计算各个*n*值的平均步行长度。'
- en: '**Random walkers.** Suppose that `n` random walkers, starting in the center
    of an *n*-by-*n* grid, move one step at a time, choosing to go left, right, up,
    or down with equal probability at each step. Compose a program to help formulate
    and test a hypothesis about the number of steps taken before all cells are touched.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机行走者。** 假设有`n`个随机行走者，从一个*n*乘*n*的网格中心开始，每次移动一步，选择向左、向右、向上或向下的概率相等。编写一个程序来帮助制定并测试有关在所有单元格都被触及之前所需步数的假设。'
- en: '*Solution*: See [randomwalkers.py](randomwalkers.py.html).'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[randomwalkers.py](randomwalkers.py.html)。'
- en: '**Bridge hands.** In the game of bridge, four players are dealt hands of 13
    cards each. An important statistic is the distribution of the number of cards
    in each suit in a hand. Which is the most likely, 5-3-3-2, 4-4-3-2, or 4-3-3-3?
    Compose a program to help you answer this question.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**桥牌手。** 在桥牌游戏中，四名玩家每人发13张牌。一个重要的统计数据是每手中每种花色的牌数分布。5-3-3-2，4-4-3-2或4-3-3-3哪种可能性最大？编写一个程序来帮助你回答这个问题。'
- en: '**Birthday problem.** Suppose that people continue to enter an empty room until
    a pair of people share a birthday. On average, how many people will have to enter
    before there is a match? Run experiments to estimate the value of this quantity.
    Assume birthdays to be uniform random integers between 0 and 364.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**��日问题。** 假设人们继续进入一个空房间，直到有一对人共享生日。平均需要多少人进入才会有匹配？运行实验估计这个数量的值。假设生日是在0到364之间均匀随机的整数。'
- en: '*Solution*: See [birthday.py](birthday.py.html) and [birthdays.py](birthdays.py.html).'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[birthday.py](birthday.py.html)和[birthdays.py](birthdays.py.html)。'
- en: '**Coupon collector.** Run experiments to validate the classical mathematical
    result that the expected number of coupons needed to collect *n* values is about
    *nH[n]*. For example, if you are observing the cards carefully at the blackjack
    table (and the dealer has enough decks randomly shuffled together), you will wait
    until about 235 cards are dealt, on average, before seeing every card value.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收集优惠券。** 运行实验验证经典数学结果，即收集*n*个值所需的期望优惠券数量约为*nH[n]*。例如，如果你在二十一点桌上仔细观察牌（并且庄家有足够多的随机洗在一起的牌组），平均需要发出约235张牌，才能看到每张牌的价值。'
- en: '**Riffle shuffle.** Compose a program to rearrange a deck of *n* cards using
    the Gilbert-Shannon-Reeds model of a riffle shuffle. First, generate a random
    integer *r* according to a *binomial distribution*: flip a fair coin *n* times
    and let *r* be the number of heads. Now, divide the deck into two piles: the first
    *r* cards and the remaining *n* - *r* cards. To complete the shuffle, repeatedly
    take the top card from one of the two piles and put it on the bottom of a new
    pile. If there are *n*[1] cards remaining in the first pile and *n*[2] cards remaining
    in the second pile, choose the next card from the first pile with probability
    *n*[1] / (*n*[1] + *n*[2]) and from the second pile with probability *n*[2] /
    (*n*[1] + *n*[2]). Investigate how many riffle shuffles you need to apply to a
    deck of 52 cards to produce a (nearly) uniformly shuffled deck.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**洗牌。** 编写一个程序，使用Gilbert-Shannon-Reeds模型的洗牌方法重新排列一副*n*张牌。首先，根据*二项分布*生成一个随机整数*r*：抛掷一个公平硬币*n*次，让*r*为正面的次数。现在，将牌分成两堆：前*r*张牌和剩下的*n*
    - *r*张牌。为了完成洗牌，反复从两堆中的一堆顶部取一张牌并放在一个新堆的底部。如果第一堆剩余*n*[1]张牌，第二堆剩余*n*[2]张牌，从第一堆选择下一张牌的概率为*n*[1]
    / (*n*[1] + *n*[2])，从第二堆选择的概率为*n*[2] / (*n*[1] + *n*[2])。研究需要对一副52张牌的牌组应用多少次洗牌才能产生一个（几乎）均匀洗牌的牌组。'
- en: '**Binomial coefficients.** Compose a program that builds and writes a two-dimensional
    ragged array `a` such that `a[n][k]` contains the probability that you get exactly
    `k` heads when you toss a fair coin `n` times. Take a command-line argument to
    specify the maximum value of `n`. These numbers are known as the *binomial distribution*:
    if you multiply each element in row *k* by 2*^n*, you get the *binomial coefficients*
    (the coefficients of *x^k* in (*x*+1)*^n*) arranged in *Pascal''s triangle*. To
    compute them, start with `a[n][0] = 0.0` for all `n` and `a[1][1] = 1.0`, then
    compute values in successive rows, left to right, with `a[n][k] = (a[n-1][k] +
    a[n-1][k-1])/2.0`.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二项式系数。** 编写一个程序，构建并写入一个二维不规则数组`a`，使得`a[n][k]`包含在你抛掷一个公平硬币`n`次时恰好获得`k`个正面的概率。接受一个命令行参数来指定`n`的最大值。这些数字被称为*二项分布*：如果你将第*k*行中的每个元素乘以2*^n*，你将得到*二项式系数*（(*x*+1)*^n*中*x^k*的系数）在*帕斯卡三角形*中排列。要计算它们，从所有`n`开始，`a[n][0]
    = 0.0`，`a[1][1] = 1.0`，然后按照从左到右的顺序计算连续行中的值，`a[n][k] = (a[n-1][k] + a[n-1][k-1])/2.0`。'
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
