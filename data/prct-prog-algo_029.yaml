- en: 5.4   Computability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4   可计算性
- en: 原文：[https://introcs.cs.princeton.edu/java/54computability](https://introcs.cs.princeton.edu/java/54computability)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/54computability](https://introcs.cs.princeton.edu/java/54computability)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在进行重大改造。
- en: 'In David Hilbert''s famous 1900 address to the International Congress of Mathematics,
    he asserted:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在大卫·希尔伯特于1900年对国际数学大会的著名演讲中，他断言：
- en: Take any definite unsolved problem, such as the question as to the irrationality
    of the Euler-Mascheroni constant γ, or the existence of an infinite number of
    prime numbers of the form 2^n+1. However, unapproachable these problems may seem
    to us and however helpless we stand before them, we have, nevertheless, the firm
    conviction that their solution must follow by a finite number of purely logical
    processes.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拿任何明确未解决的问题来说，比如欧拉-马斯克罗尼常数γ的无理性问题，或者形式为2^n+1的无限个素数是否存在的问题。无论这些问题对我们来说看起来多么难以接近，我们在它们面前多么无助，我们仍然坚信，它们的解决必须通过有限数量的纯逻辑过程来实现。
- en: 'Now that we have a clear notion of an algorithm (the Turing machine), we will
    see that some computational problems cannot be solved, regardless of the amount
    of resources available. If an algorithm exists to solve a particular problem,
    that problem is said to be *solvable*; otherwise the problem is *unsolvable*.
    We give several natural examples of unsolvable problems. Unsolvable problems arise
    in many areas including: cellular automata, chaos theory, combinatorics, operations
    research, statistics, physics, compiler theory, knot theory, logic, set theory,
    and topology. Note that unsolvability is a very strong statement about a problem
    - it says not only that scientists have not discovered an algorithm for the problem,
    but that such a discovery is impossible.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对算法（图灵机）有了清晰的概念，我们将看到一些计算问题无论可用资源量如何都无法解决。如果存在解决特定问题的算法，则该问题被称为*可解*；否则该问题被称为*不可解*。我们给出几个自然的不可解问题的例子。不可解问题出现在许多领域，包括：元胞自动机、混沌理论、组合数学、运筹学、统计学、物理学、编译器理论、结论论、逻辑、集合论和拓扑学。请注意，不可解性是关于问题的一个非常强烈的陈述
    - 它不仅表示科学家们尚未发现该问题的算法，而且这样的发现是不可能的。
- en: '**Halting problem.** The halting problem is the most famous of all unsolvable
    problems, and it was the first one classified as such. The input to the *halting
    problem* is a Turing machine and its input. The goal is to determine whether or
    not that Turing machine will ever reach the halt state. This is more difficult
    than it appears because very simple Turing machines, often referred to as [busy
    beavers](index.php?c=beaver), may perform remarkably complex actions. An *N-state
    busy beaver* is a Turing machine defined on N states over the binary alphabet
    (0 and 1) that when started with an all zero tape, leaves as many 1''s on the
    tape as possible before halting. Finding busy beavers for even modest size values
    of N is a surprisingly daunting task. The following 8-state Turing machine leaves
    4,098 ones on the tape and halts after 47,176,870 steps.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**停机问题。** 停机问题是所有不可解问题中最著名的，也是第一个被归类为不可解的问题。*停机问题*的输入是一个图灵机及其输入。目标是确定该图灵机是否会达到停机状态。这比看起来要困难，因为非常简单的图灵机，通常被称为[忙碌的海狸](index.php?c=beaver)，可能执行非常复杂的动作。*N状态忙碌的海狸*是一个在二进制字母（0和1）上定义的N状态图灵机，当以全零磁带启动时，在停机前尽可能多地在磁带上留下1。为了找到即使对于较小的N值也能找到忙碌的海狸是一个令人惊讶的艰巨任务。以下这台8状态图灵机在磁带上留下4,098个1，并在47,176,870步之后停机。'
- en: '![](../Images/01cfbabb07b820b3261a2ebd5cefd129.png)'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/01cfbabb07b820b3261a2ebd5cefd129.png)'
- en: However, it is not a busy beaver. In fact, [Marxen and Buntrock](http://www.drb.insel.de/~heiner/BB/)
    have an 8-state Turing machine (when converted to our Minsky style notation) that
    leaves over 10^(47) ones on the tape after more than 10^(95), and an astonishing
    9-state Turing machine that leaves over 10^(865) ones on the tape, and halts after
    over 10^(1730) steps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它并不是一个忙碌的海狸。事实上，[Marxen and Buntrock](http://www.drb.insel.de/~heiner/BB/)有一台8状态的图灵机（转换为我们的Minsky风格符号后），在超过10^(95)步之后，在磁带上留下超过10^(47)个1，还有一台令人惊讶的9状态图灵机，在超过10^(1730)步之后，在磁带上留下超过10^(865)个1，并停止运行。
- en: '**Halting problem in Java.** We can recast the Halting problem in terms of
    the Java programming language. Here, the goal is to write a program, say `Halt.java`,
    that determines whether or not some static method, say `mystery`, goes into an
    infinite loop on some specific input `x`. This would be a powerful debugging tool.
    We''ve all written programs that go into infinite loops. The possibility of an
    infinite loop in your code usually signifies a bug. An infinite loop in a commercial
    piece of software could lead to angry customers, or worse. It would sure be nice
    if the Java compiler could warn us if our function might go into an infinite loop.
    To see why this is such a daunting task, consider program [Perfect.java](Perfect.java.html).
    It searches for an odd [perfect number](http://mathworld.wolfram.com/PerfectNumber.html):
    a number that equals the sum of its proper divisors (e.g., 28 is perfect since
    28 = 1 + 2 + 4 + 7 + 14). Does the program halt (assuming we never run into overflow
    problems)? If so, how long do we have to wait until we can conclude that it is
    in an infinite loop? We can type in the code and see what happens. If the program
    terminates, we can safely answer yes. The main obstacle is determining when to
    say no. Suppose we do stop the program at some point (Ctrl-c) and answer no. Maybe
    if we had left the program running just a bit longer it would have halted on its
    own. Despite intensive research, no one knows whether `Perfect.java` terminates.
    Mathematicians have proved that it will not terminate until n is at least 10^(300).
    This is an extreme example, but it highlights the fact that there is no easy way
    to tell whether a given program will terminate just by looking at it. In contrast,
    the program [Cube.java](Cube.java.html) searches for a positive integer-valued
    solution to 313(a³ + b³) = c³. It turns out that `Cube.java` does halt (assuming
    we never run into overflow problems), but not until c is greater than 10^(1000).
    Indeed, we could pose mathematical problems like Fermat''s Last Theorem in the
    same way (see Exercise XYZ). If the halting problem were solvable, then mathematics
    would be easy.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java中的停机问题。** 我们可以用Java编程语言重新表述停机问题。在这里，目标是编写一个程序，比如`Halt.java`，来确定某个静态方法，比如`mystery`，在某个特定输入`x`上是否进入无限循环。这将是一个强大的调试工具。我们都写过进入无限循环的程序。代码中可能存在无限循环的可能通常表示一个bug。商业软件中的无限循环可能导致愤怒的客户，甚至更糟。如果Java编译器能够警告我们的函数可能进入无限循环，那将是很好的。要了解为什么这是一项艰巨的任务，请考虑程序[Perfect.java](Perfect.java.html)。它搜索一个奇数[完美数](http://mathworld.wolfram.com/PerfectNumber.html)：一个等于其真因子之和的数（例如，28是完美的，因为28
    = 1 + 2 + 4 + 7 + 14）。这个程序是否停机（假设我们不会遇到溢出问题）？如果是，我们需要等多久才能得出它进入无限循环的结论？我们可以输入代码并查看结果。如果程序终止，我们可以安全地回答是。主要障碍是确定何时回答否。假设我们在某个时刻停止程序（Ctrl-c）并回答否。也许如果我们让程序运行更长一点，它会自行停机。尽管进行了大量研究，但没有人知道`Perfect.java`是否会停机。数学家已经证明，直到n至少为10^(300)时它才会停机。这是一个极端的例子，但它突显了通过查看给定程序是否终止没有简单方法。相比之下，程序[Cube.java](Cube.java.html)搜索一个正整数解313(a³
    + b³) = c³。事实证明，`Cube.java`会停机（假设我们不会遇到溢出问题），但直到c大于10^(1000)。事实上，我们可以以相同的方式提出类似费马大定理的数学问题（参见练习XYZ）。如果停机问题是可解的，那么数学将变得容易。'
- en: '**The halting problem is unsolvable.**   We sketch below a mind-blowing proof
    that no algorithm to solve the halting problem exists or could ever exist. The
    idea behind the proof is inspired by the following paradox. Is the following statement
    true or false? *This sentence is false.* The essence of this paradox is caused
    by self-reference. The TM "formalizes an old argument about why you can never
    have perfect introspection: because if you could, then you could determine what
    you were going to do ten seconds from now, and then do something else." (Scott
    Aaronson) The crucial idea in our Halting proof is to feed a program itself as
    input.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**停机问题是不可解的。** 我们在下面概述了一个令人震惊的证明，证明不存在或���远不存在解决停机问题的算法。这个证明的思想受到以下悖论的启发。以下陈述是真还是假？*这个句子是假的。*这个悖论的本质是由自指引起的。TM“形式化了一个关于为什么你永远无法拥有完美内省的旧论点：因为如果你可以，那么你可以确定十秒后你将要做什么，然后做其他事情。”（斯科特·亚伦森）我们停机证明的关键思想是将一个程序本身作为输入。'
- en: '**Barber''s Paradox.** Suppose Barry is a Barber who claims that he shaves
    all (and only those) people in the town who do not shave themselves, and that
    Barber lives in the town and is clean-shaven. Does Barry shave himself? We can
    prove by contradiction that such a barber cannot exist.... We now apply the same
    logic reasoning to Java programs...'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**理发师悖论。** 假设巴里是一个理发师，他声称他给镇上所有（而且只有那些）不给自己剃须的人剃须，并且理发师住在镇上，自己是刮得干净的。巴里会给自己剃须吗？我们可以通过反证法证明这样一个理发师是不存在的...现在我们将同样的逻辑推理应用到Java程序中...'
- en: '*Informal proof.* Since the Java programming language is equivalent to Turing
    machines, it suffices to show that we can''t write a Java program to solve the
    halting problem. We consider programs that take some arbitrary input (say from
    `stdin`). We denote the result of a program `P` run with input `x` by `P(x)`.
    We use the mathematical technique of proof by contradiction, or *reductio ad absurdum*.
    Suppose, for the sake of contradiction, that there exists such a halting program
    `Halt(P, x)`. (We will show that this leads to an obvious contradiction, and therefore,
    we must conclude that no such program exists.) It takes two inputs: a program
    `P` and its input `x`. Program `Halt(P, x)` outputs `yes` if `P(x)` halts, and
    `no` otherwise. Note that by our hypothesis, `Halt(P, x)` itself always halts
    for any pair of inputs.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*非正式证明。* 由于Java编程语言等价于图灵机，我们只需证明我们无法编写一个Java程序来解决停机问题。我们考虑接受一些任意输入（比如来自`stdin`）的程序。我们用反证法或*归谬法*这种数学技巧。假设，为了矛盾，存在这样一个停机程序`Halt(P,
    x)`。（我们将展示这导致一个明显的矛盾，因此我们必须得出结论，这样的程序不存在。）它接受两个输入：一个程序`P`和它的输入`x`。程序`Halt(P, x)`在`P(x)`停机时输出`yes`，否则输出`no`。注意，根据我们的假设，对于任何一对输入，`Halt(P,
    x)`本身总是停机的。'
- en: Now, the fun begins. Create a new program `Strange(P)` that takes as input a
    single program `P`. This new program calls the halting program with `P` as *both*
    inputs, i.e., `Halt(P, P)`. [Refer back to Turing machine that creates a copy
    of its input.] It may seem odd to take a program as input, but this is rather
    common. Compilers do exactly this; they read in a Java program as input, and output
    a machine language program. As Marvin Minsky observes, you don't need to worry
    much about why we'd want to perform such an introverted computation. But, you
    can gain some intuition by considering a computational biologist who wants to
    create a complete description of their own genome! There is nothing at all absurd
    about this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，乐趣开始了。创建一个新程序`Strange(P)`，它以单个程序`P`作为输入。这个新程序调用带有`P`作为*两个*输入的停机程序，即，`Halt(P,
    P)`。[回顾一下���建其输入副本的图灵机。]将程序作为输入可能看起来有点奇怪，但这是相当常见的。编译器就是这样做的；它们读取Java程序作为输入，并输出一个机器语言程序。正如Marvin
    Minsky所观察到的，你不需要太担心为什么我们想要执行这样一种内向的计算。但是，通过考虑一个计算生物学家想要创建自己基因组的完整描述，你可以获得一些直觉！这一点一点都不荒谬。
- en: 'Now, we design the program `Strange(P)` so that it promptly halts if `Halt(P,
    P)` outputs `no`. Otherwise, we make `Strange(P)` go into an infinite loop. In
    Java, the code for `Strange(P)` might look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们设计程序`Strange(P)`，以便如果`Halt(P, P)`输出`no`，则它立即停机。否则，我们让`Strange(P)`进入无限循环。在Java中，`Strange(P)`的代码可能如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In summary
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: If `P(P)` does not halt, then `Strange(P)` halts.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`P(P)`不停机，那么`Strange(P)`就会停机。
- en: If `P(P)` halts, then `Strange(P)` does not halt.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`P(P)`停机，那么`Strange(P)`就不会停机。
- en: 'Now, we perform the crucial step: give program `Strange(P)` *itself* as input,
    i.e., set `P = Strange`. Let''s see what crazy thing happens. Statements (a) and
    (b) now reduce to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们执行关键步骤：将程序`Strange(P)`*本身*作为输入，即，设置`P = Strange`。让我们看看会发生什么疯狂的事情。语句(a)和(b)现在简化为：
- en: If `Strange(Strange)` does not halt, then `Strange(Strange)` halts.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Strange(Strange)`不停机，那么`Strange(Strange)`就会停机。
- en: If `Strange(Strange)` halts, then `Strange(Strange)` does not halt.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Strange(Strange)`停机，那么`Strange(Strange)`就不会停机。
- en: Both cases lead to a contradiction. The only thing we can conclude is that our
    hypothesis that program `Halt(P, x)` exists is impossible. That is, the halting
    problem is unsolvable!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都导致矛盾。我们唯一能得出的结论是我们假设程序`Halt(P, x)`存在是不可能的。也就是说，停机问题是不可解的！
- en: A poetic proof.
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一首诗意的证明。
- en: Here's a [poem](halting-poem.html) that proves the undecidability of the halting
    problem in verse! In the poetic proof, the program `Strange()` is replaced by
    `Q()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一首[诗](halting-poem.html)，以诗歌的形式证明了停机问题的不可判定性！在诗意的证明中，程序`Strange()`被替换为`Q()`。
- en: '**Diagonalization argument.**   This proof is an example of a *diagonalization
    argument*: we imagine a 2D grid with the rows indexed by programs P, the columns
    indexed by inputs x, and Halt(P, x) is the result of running the halting program
    on P(x). The diagonal entries correspond to Halt(P, P). The essence of the proof
    is determining which row corresponds to the program Strange. The contradiction
    arises because we constructed Strange to differ with each row in the grid (specifically
    on each diagonal entry).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**对角线化论证。** 这个证明是对*对角线化论证*的一个例子：我们想象一个二维网格，行由程序P索引，列由输入x索引，Halt(P, x)是在P(x)上运行停机程序的结果。对角线条目对应于Halt(P,
    P)。证明的本质是确定哪一行对应于程序Strange。矛盾之处在于我们构造Strange使其与网格中的每一行不同（特别是在每个对角线条目上）。'
- en: '**Consequences.**   As part of the correctness proof of any deterministic algorithm,
    we must argue that it terminates after a finite number of steps. There are important
    classes of programs where it''s easy to tell, but the undecidability of the halting
    problem precludes a general rule or formula. Each proof of correctness may require
    an entirely new idea (e.g., the odd perfect number program), and there is no way
    to (fully) automate the process.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**后果。** 作为任何确定性算法正确性证明的一部分，我们必须证明它在有限步骤后终止。有一些重要的程序类别，可以轻松判断，但停机问题的不可判定性排除了一般规则或公式。每个正确性证明可能需要一个全新的想法（例如，奇完美数程序），而且没有办法（完全）自动化这个过程。'
- en: Why debugging is hard? The following are undecidable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么调试很难？以下是不可判定的。
- en: '*Self-halting problem.* Given a program that takes one input, does it terminate
    when given itself as input?'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自停机问题。* 给定一个接受一个输入的程序，当给定自身作为输入时是否终止？'
- en: '*Totality problem.* Given a program that takes one input, does it halt on *all*
    inputs. 3x+1 problem.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全体性问题。* 给定一个接受一个输入的程序，它是否在*所有*输入上停机。3x+1问题。'
- en: '*Program equivalence problem.* Given two program that takes one input each,
    do they produce the same result on every input.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序等价性问题。* 给定两个分别接受一个输入的程序，它们在每个输入上是否产生相同的结果。'
- en: '*Dead code elimination.* Will a particular piece of code ever get executed?'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*死代码消除。* 特定代码是否会被执行？'
- en: '*Variable initialization.* Is a variable initialized before it is first referenced?'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变量初始化。* 变量在首次引用之前是否被初始化？'
- en: '*Memory management.* Will a variable ever be referenced again?'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存管理。* 变量是否会再次被引用？'
- en: '**Other unsolvable problems.** Here are some more example of unsolvable problems:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他不可解问题。** 以下是一些更多的不可解问题的例子：'
- en: '*Rice''s theorem.*  Meta-theorem that says any nontrivial property of input/output
    of a Turing machine is undecidable. Nontrivial means some programs have that property
    and some don''t. Does a Turing machine halt on all inputs? For infinitely many
    inputs? For no inputs? On at least two input strings of different lengths? Is
    set of strings accepted is a regular language? Do two Turing machines halt for
    exactly the same inputs?'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*赖斯定理。* 说任何图灵机的输入/输出的非平凡性质都是不可判定的元定理。非平凡意味着一些程序具有该属性，而一些程序没有。图灵机在所有输入上是否停机？在无限多个输入上是否停机？在没有输入上是否停机？在至少两个不同长度的输入字符串上是否停机？被接受的字符串集是否是正则语言？两个图灵机是否对完全相同的输入停机？'
- en: '*Chaitin''s number.*   What is the probability that a Turing machine M will
    halt on a random input?'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*柴田数。* 图灵机M在随机输入上停机的概率是多少？'
- en: '*Hilbert''s tenth problem.*   To gain some historical perspective, we relay
    the famous story of Hilbert''s tenth problem. In 1900, David Hilbert [addressed](http://aleph0.clarku.edu/~djoyce/hilbert/toc.html)
    the International Congress of Mathematicians in Paris and posed 23 problems as
    a challenge for the upcoming century. Hilbert''s tenth problem was *to devise
    a process according to which it can be determined by a finite number of operations
    whether* a given multivariate polynomial has an integral root. For example, the
    polynomial f(x,y,z) = 6x³yz² + 3xy² - x³ - 10 has an integral root since f(5,3,0)
    = 0, whereas the polynomial f(x,y) = x² + y² - 3 does not have one. The problem
    dates back two thousand years to Diophantine, and it arises in diverse areas including:
    physics, computational biology, operations research, and statistics. At the time,
    there was no rigorous definition of an algorithm; consequently the existence of
    unsolvable problems was not even contemplated. In the 1970''s Hilbert''s 10th
    problem was resolved in a very surprising way: Yuri Matiyasevich proved that it
    is unsolvable. That is, it is *impossible* to create a program (say, in Java)
    that will read in an arbitrary multivariate polynomial as input, and return the
    appropriate yes-no answer! The problem is decidable if there is only one variable,
    but is undecidable even if there are 13 variables.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*希尔伯特的第十个问题。* 为了获得一些历史视角，我们重述希尔伯特第十个问题的著名故事。1900年，大卫·希尔伯特在巴黎国际数学家大会上[提出](http://aleph0.clarku.edu/~djoyce/hilbert/toc.html)了23个问题，作为即将到来的世纪的挑战。希尔伯特的第十个问题是*设计一个过程，根据这个过程可以通过有限次操作确定给定的多元多项式是否有整数根*。例如，多项式f(x,y,z)
    = 6x³yz² + 3xy² - x³ - 10有一个整数根，因为f(5,3,0) = 0，而多项式f(x,y) = x² + y² - 3没有整数根。这个问题可以追溯到两千年前的丢番图方程，它涉及到物理学、计算生物学、运筹学和统计学等多个领域。当时，算法没有严格的定义；因此，甚至没有考虑到不可解问题的存在。在20世纪70年代，希尔伯特的第十个问题以一种非常令人惊讶的方式得到解决：尤里·马季亚塞维奇证明了它是不可解的。也就是说，*不可能*创建一个程序（比如，在Java中），它可以读取任意多元多项式作为输入，并返回适当的是-否答案！如果只有一个变量，这个问题是可判定的，但即使有13个变量，它也是不可判定的。'
- en: '*Roots of a function of one variable.*   Hilbert''s 10th problem is decidable
    if it is a function of a single variable. However, if we allow trigonometric functions,
    then the problem becomes undecidable again. Given a rational function f(x) of
    a single variable x comprised of polynomial (addition, multiplication, composition)
    and sine terms, does there exist an x* such that f(x*) = 0? [Richardson''s theorem](http://mathworld.wolfram.com/RichardsonsTheorem.html)
    is slightly weaker but more famous and earlier - it assumes f(x) is a function
    built from rational numbers, π, ln 2, the variable x, addition, multiplication,
    composition, sine, exponential, and absolute value functions. Reference: [Paul
    Wang](http://portal.acm.org/citation.cfm?doid=321850.321856).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一元函数的根。* 如果是单变量函数，希尔伯特的第十个问题是可判定的。然而，如果允许三角函数，那么问题再次变得不可判定。给定一个由多项式（加法、乘法、组合）和正弦项组成的单变量x的有理函数f(x)，是否存在一个x*使得f(x*)
    = 0？[Richardson''s theorem](http://mathworld.wolfram.com/RichardsonsTheorem.html)
    稍微弱一些但更著名和更早 - 它假设f(x)是由有理数、π、ln 2、变量x、加法、乘法、组合、正弦、指数和绝对值函数构建的函数。参考：[Paul Wang](http://portal.acm.org/citation.cfm?doid=321850.321856)。'
- en: '*Definite integration.*   The root-finding problem can be leveraged to show
    that definite integration is also undecidable. Given a definite integral of a
    function f(x) involving only polynomial and trigometric functions, is the integral
    of f(x) from -∞ to +∞ convergent (does the limit exist)? Hence we can''t expect
    a symbolic algebra package (Maple or Mathematica) to always tell us the answer
    when we type in a definite integral. Undecidable even f(x) = [(x² + 1)g²(x)]^(-1),
    where g(x) is a rational function involving polynomials and sine terms.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定积分。* 根查找问题可以用来证明定积分也是不可判定的。给定一个仅涉及多项式和三角函数的函数f(x)的定积分，f(x)从-∞到+∞的积分是否收敛（极限是否存在）？因此，当我们输入一个定积分时，我们不能期望符号代数软件（如Maple或Mathematica）总是告诉我们答案。即使f(x)
    = [(x² + 1)g²(x)]^(-1)，其中g(x)是涉及多项式和正弦项的有理函数，也是不可判定的。'
- en: '*Post''s correspondence problem.*   The following unsolvable puzzle involving
    strings was first analyzed by Emil Post in the 1940''s. The input to the problem
    is `N` different card types. Each card type contains two strings, one on the top,
    one on the bottom. The puzzle is to arrange the cards so that the top and bottom
    strings are the same (a `yes` instance) or to report that it''s impossible (a
    `no` instance). You are allowed to use an arbitrary number of each card type.
    Here''s a `yes` instance of the problem with 4 card types:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*波斯特对应问题。* 这个涉及字符串的不可解谜题最早由Emil Post在1940年代分析。问题的输入是`N`种不同的卡片类型。每种卡片类型包含两个字符串，一个在顶部，一个在底部。谜题是将卡片排列成顶部和底部字符串相同（一个`yes`实例），或报告不可能（一个`no`实例）。你可以使用任意数量的每种卡片类型。这是一个有4种卡片类型的`yes`实例：'
- en: '![Post''s Correspondence Problem](../Images/ee3dc4eae3bd9c821e3d8d4792aef95e.png)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![波斯特对应问题](../Images/ee3dc4eae3bd9c821e3d8d4792aef95e.png)'
- en: and a corresponding solution that uses cards 1, 3, 0, 2, and a second copy of
    card 1.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及使用卡片1、3、0、2和第二份卡片1的对应解决方案。
- en: '![Post''s Correspondence Problem](../Images/d3d24047095769e641568bb022166a1b.png)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![波斯特对应问题](../Images/d3d24047095769e641568bb022166a1b.png)'
- en: 'The top string and bottom string are each `abababababa`. Here''s a `no` instance
    with 4 cards:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顶部字符串和底部字符串分别为`abababababa`。这是一个有4张卡片的`no`实例：
- en: '![Post''s Correspondence Problem](../Images/e65b3b095473dbd602303e802b306fab.png)'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![波斯特对应问题](../Images/e65b3b095473dbd602303e802b306fab.png)'
- en: Why is it a `no` instance? In a `yes` instance, the top and bottom leftmost
    characters of the leftmost card in the solution must match. In this example, no
    card's leftmost top and bottom characters match. Hence, there is no possible way
    to line the cards up appropriately. In general, such a simple explanation may
    not exist. Here's a [challenging 11 card instance](pcp/pcp.php) created by Andrew
    Appel.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么这是一个`no`实例？在一个`yes`实例中，解决方案中最左边的卡片的最上方和最下方的字符必须匹配。在这个例子中，没有一张卡片的最左边的顶部和底部字符匹配。因此，没有可能将卡片适当地排列。一般来说，这样一个简单的解释可能不存在。这里有一个由Andrew
    Appel创建的[具有挑战性的11张卡片实例](pcp/pcp.php)。
- en: Incredibly, it is impossible to write a Java program that reads in a sequence
    of `N` card types, and is always able to correctly report whether or not such
    an arrangement is possible. Of course, on some inputs (like the two above) the
    program may be able to return the correct answer. But, on some inputs the program
    is doomed to fail. Note that if you were restricted to using only one card of
    each type, then the problem could be solved by trying all possibilities, since
    the number of possibilities would be finite (although very large). Solvability
    refers to whether a computation can be done at all, not how much time it would
    take.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 令人难以置信的是，不可能编写一个Java程序，读取一系列`N`种卡片类型，并始终能够正确报告这样的排列是否可能。当然，在某些输入（如上面的两个输入）上，程序可能能够返回正确答案。但是，在某些输入上，程序注定会失败。请注意，如果您只能使用每种类型的一张卡片，那么问题可以通过尝试所有可能性来解决，因为可能性的数量是有限的（尽管非常大）。可解性指的是计算是否可以完成，而不是需要多长时间。
- en: '*Program equivalence problem.*   The *program equivalence problem* is to identify
    whether or not two programs produce identical output, given the same input. Clearly
    a grader in an introductory computer science class would appreciate such a program.
    More significantly, this would be immensely useful in testing a new program (e.g.,
    a new, but intricate, sorting algorithm) by comparing it to a well-tested and
    bug-free version (e.g., brute-force search). Again, this problem is unsolvable.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序等价问题。* *程序等价问题* 是确定两个程序在给定相同输入时是否产生相同输出的问题。显然，初级计算机科学课程的评分员会欣赏这样的程序。更重要的是，通过将其与经过充分测试且无错误的版本（例如，暴力搜索）进行比较，可以在测试新程序（例如，一个新的但复杂的排序算法）时发现其是否存在问题。同样，这个问题是不可解的。'
- en: '*Uninitialized variables.*   The Java compiler sometimes complains that you
    may be accessing a local variable before it has been initialized. The programmer
    can sometimes guarantee that a variable is initialized, but the compiler is not
    "smart" enough to realize it. In the example below, a will be initialized to 17
    because the length of an array is always nonnegative.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未初始化的变量。* Java编译器有时会抱怨您可能在变量初始化之前访问局部变量。程序员有时可以保证变量已初始化，但编译器并不“聪明”到能意识到这一点。在下面的示例中，a将被初始化为17，因为数组的长度始终是非负的。'
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why can't the compiler figure this out on its own? In this case, it could. But
    in general, determining whether a variable has been initialized in undecidable.
    The compiler acts conservatively, using "sufficient" but not "necessary" tests.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么编译器不能自行解决这个问题？在这种情况下，它可以。但一般来说，确定变量是否已初始化是不可判定的。编译器会保守地行事，使用“足够”但不是“必要”的测试。
- en: '*Optimizing compilers (Reference: Appel paper).* An *optimizing compiler* is
    a compiler that analyzes your program, removing any useless code and variables.
    Dead-code elimination: does control flow ever reach this point in program? Register
    allocation: starting from this point, can value in register x affect the result
    of the computation? Load/store scheduling: are these two references aliased (can
    they contain pointers to the same memory location)?'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化编译器（参考：Appel论文）。* 优化编译器是一种分析您的程序，删除任何无用代码和变量的编译器。死代码消除：程序是否会到达程序中的这一点？寄存器分配：从这一点开始，寄存器x中的值是否会影响计算结果？加载/存储调度：这两个引用是否别名（它们是否可能包含指向相同内存位置的指针）？'
- en: '*Data compression.*   Given a string *s*, find the shortest (measured in number
    of characters) program that will output *s*. This problem is of fundamental importance
    in information theory and data compression. It is a formal statement of Occam''s
    Razor -- *find the simplest explanation that fits the facts.* The Mandelbrot set
    is a beautiful example of a complex picture that can be generated with a simple
    program. It would be nice to have a formal method that guarantees to find such
    a concise description.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据压缩。* 给定一个字符串*s*，找到输出*s*的最短（以字符数衡量）程序。这个问题在信息论和数据压缩中具有基本重要性。这是奥卡姆剃刀的一个正式陈述——*找到适合事实的最简单解释*。曼德勃罗集是一个美丽的例子，它可以用一个简单的程序生成一个复杂的图片。有一个正式的方法可以保证找到这样一个简洁的描述将是很好的。'
- en: '*Virus recognition.*  Informally, Fred Cohen defines a computer virus as *a
    program that is able to infect other programs by modifying them to include a possibly
    evolved copy of itself.* He also provides a rigorous definition involving Turing
    machines, and shows that that determining whether or not a given program is a
    virus is unsolvable.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*病毒识别。* Fred Cohen非正式地将计算机病毒定义为*能够通过修改其他程序以包含可能进化的自身副本来感染其他程序的程序*。他还提供了涉及图灵机的严格定义，并表明确定给定程序是否为病毒是不可解的。'
- en: '*Ambiguity in grammar.*   Given a context free grammar, is it ambiguous?'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语法中的歧义。* 给定一个上下文无关文法，它是否具有歧义？'
- en: '*Matrix mortality problem.*   Given a finite set of N-by-N matrices with integer
    elements, can they be multiplied in some order (possibly repeating the same matrix
    more than once) to yield the zero matrix? (Undecidable already for a set of 15
    or more 3-by-3 matrices, or a set of two 45-by-45 matrices.)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*矩阵死亡问题。* 给定一个具有整数元素的N×N矩阵的有限集合，它们是否可以按某种顺序相乘（可能重复相同矩阵多次）以产生零矩阵？（对于15个或更多3×3矩阵的集合，或两个45×45矩阵的集合，这个问题已经是不可判定的。）'
- en: '*Polygonal tilings.*   Given a polygon, not necessarily regular or convex,
    is it possible to tile the whole plane with copies of that shape? Yes for rectangle,
    right triangle, or hexagon.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多边形铺砖。* 给定一个多边形，不一定规则或凸，是否可能用该形状的副本铺满整个平面？对于矩形，直角三角形或六边形是可以的。'
- en: '*Wang tilings.*   Given a set of [Wang tiles](http://en.wikipedia.org/wiki/Wang_tile)
    can you arrange copies of the tiles to cover the infinite plane?'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*王瓷砖。* 给定一组[Wang tiles](http://en.wikipedia.org/wiki/Wang_tile)，你能否安排瓷砖的副本覆盖无限平面？'
- en: '*Self-assembly of infinite ribbons.*   Self-assembly = "process by which objects
    autonomously come together to form complex structures." [Reference.](http://www.usc.edu/dept/molecular-science/focs6.pdf)
    Applications to circuit fabrication, DNA computing, nano-robotics. Given a set
    of tiles, can you arrange copies of the tiles to form an infinite ribbon?'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无限带自组装。* 自组装 = “物体自主聚集形成复杂结构的过程。”[参考。](http://www.usc.edu/dept/molecular-science/focs6.pdf)
    应用于电路制造，DNA计算，纳米机器人。给定一组瓷砖，你能否安排瓷砖的副本形成无限带？'
- en: '*Group theory.*  Testing whether a finitely presented group is commutative
    an undecidable problem. Testing whether it is finite, free, or simple are also
    undecidable problems.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*群论。* 测试有限呈现群是否可交换是一个不可判定的问题。测试它是否有限，自由或简单也是不可判定的问题。'
- en: '*Topology.*  Testing whether two polyhedra (represented by their triangulations)
    are homeomorphic is undecidable. Testing whether two two n-Manifolds (using Poincare''s
    and Veblen''s definition) are homeomorphic is undecidable for n > 3.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拓扑学。* 测试两个多面体（通过它们的三角剖分表示）是否同胚是不可判定的。测试两个n维流形（使用庞加莱和维布伦的定义）是否同胚对于n > 3是不可判定的。'
- en: '*Queueing theory.*  (Gamarnik) Is a homogeneous random walk in dimension d
    stable? Arriving jobs must be processed along some path in a graph. Jobs wait
    in a buffer if the processor is busy. Inter-arrival times and processing times
    are known. Scheduling policy is stable if there is a fixed upper bound on the
    number of parts in the system at all times. Is a generalized priority scheduling
    policy stable?'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排队论。* （Gamarnik）在维度d中，均匀随机行走是否稳定？到达的作业必须沿着图中的某条路径进行处理。如果处理器忙碌，作业将在缓冲区等待。到达时间和处理时间是已知的。如果系统中零件数量始终存在固定的上限，则调度策略是稳定的。广义优先级调度策略是否稳定？'
- en: '*Control theory.*  Global asymptotic stability of certain discrete time dynamical
    systems (hybrid systems, piecewise affine systems) in control theory (Blondel,
    Henzinger).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制论。* 控制论中某些离散时间动力系统（混合系统，分段仿射系统）的全局渐近稳定性（Blondel，Henzinger）。'
- en: '*Wave equation.*  Reference: Pour-El and Richards. The solution u(x, y, z,
    t) to the wave equation in three dimensions is unique determined by the initial
    conditions and du/dt at time t = 0. Even if the initial data are computable values,
    the solution can attain a non-computable value at a computable point in space-time.
    Can''t numerically solve some differential equations.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*波动方程。* 参考：Pour-El和Richards。三维波动方程的解u(x, y, z, t)由初始条件和时间t = 0时的du/dt唯一确定。即使初始数据是可计算值，解在可计算时空点可能达到一个不可计算值。有些微分方程无法数值求解。'
- en: '*Dynamical systems.*  Reference: Christopher Moore. Given a generalized shift
    Φ, is Φ chaotic?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动力系统。* 参考：克里斯托弗·摩尔。给定一个广义移位Φ，Φ是否混沌？'
- en: '**Implications.**   The existence of unsolvable problems has profound consequences
    in both computation and philosophy. First, it says there are some languages that
    cannot be recognized by any computer. That is, all computers have intrinsic limitations.
    These problems can be of enormous practical significance, including Hilbert''s
    10th problem. We must work within the limitations of computers by recognizing
    and avoiding unsolvable problems. Second, the whole assertion that *logic can
    solve any problem* is intrinsically false. If the human brain operates equivalently
    to a machine, then according to the Church-Turing thesis, the human brain would
    be no more powerful than a Turing machine. Hence, humans would be incapable of
    solving problems like the Halting problem. Humans may have fundamental limitations,
    just like computers. Others would view this differently. Rosenbloom concludes
    *man can never eliminate the necessity of using his own cleverness, no matter
    how cleverly he tries.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**影响。** 无解问题的存在在计算和哲学上有深远的影响。首先，它表明有些语言任何计算机都无法识别。也就是说，所有计算机都有固有的限制。这些问题可能具有巨大的实际意义，包括希尔伯特的第十个问题。我们必须在计算机的限制内工作，通过识别和避免无解问题。其次，*逻辑可以解决任何问题*的整体断言是本质上错误的。如果人脑的运作等同于机器，那么根据丘奇-图灵论题，人脑将不会比图灵机更强大。因此，人类无法解决像停机问题这样的问题。人类可能具有基本限制，就像计算机一样。其他人可能会有不同看法。罗森布卢姆得出结论*人永远无法消除使用自己的聪明才智的必要性，无论他多么聪明地尝试*。'
- en: Intuitively, computability tells us that to determine what a program actually
    does, you have to run the program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，可计算性告诉我们要确定程序实际执行的操作，必须运行程序。
- en: '**Computable numbers.** One of Turing''s main interests was in defining computable
    number - those numbers whose digits can be described by a mechanical process.
    For example, it is possible to write a Turing machine that leaves the digits of
    π (3, 1, 4, 1, 5, etc) on some designated (write-once) part of the tape. Even
    though π is irrational, after a finite number of steps the first N digits are
    printed on the special part of the tape. Other examples of computable numbers
    include all integers, all rational numbers, sqrt(2), all algebraic numbers, sin(10),
    and erf(.4), the zeros of the Bessel function, etc. This includes pretty much
    all numbers that arise in scientific computing.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**可计算数。** 图灵的主要兴趣之一是定义可计算数 - 那些数字的位数可以通过机械过程描述。例如，可以编写一个图灵机，在磁带的某个指定（只写一次）部分留下π的数字（3,
    1, 4, 1, 5等）。即使π是无理数，在有限步骤后，前N位数字会打印在磁带的特殊部分上。其他可计算数的例子包括所有整数，所有有理数，sqrt(2)，所有代数数，sin(10)，erf(.4)，贝塞尔函数的零点等。这基本上包括所有在科学计算中出现的数字。'
- en: '**Countable and uncountable numbers.** A decision problem is a subset of strings
    over the some alphabet. There are countably many Turing machines (like the integers),
    but uncountably many decision problems (like the real numbers). Hence, virtually
    all decision problems are undecidable. This argument establishes the existence
    of undecidable problems, but does not construct any specific one like our proof
    of the undecidability of the halting problem. Similarly, there are only a countably
    infinite number of computable numbers, but uncountably many irrational numbers.
    Thus, most irrational numbers are not computable. Fortunately, the problems and
    numbers we encounter most often in science and engineering are decidable. Of course,
    this may be because those are exactly the ones with which we know how to cope!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**可数和不可数的数字。** 决策问题是某个字母表上的字符串的子集。有可数多个图灵机（如整数），但有不可数多个决策问题（如实数）。因此，几乎所有决策问题都是不可判定的。这个论证确立了不可判定问题的存在，但没有构造任何特定的问题，就像我们证明了停机问题的不可判定性一样。同样，只有可数无限多个可计算数，但有不可数多个无理数。因此，大多数无理数是不可计算的。幸运的是，在科学和工程中我们经常遇到的问题和数字是可判定的。当然，这可能是因为这些问题正是我们知道如何应对的问题！'
- en: '**Godel''s incompleteness theorem.** Turing undecidability result was anticipated
    by one of the most shocking blows that shook the very foundations of mathematics.
    In 1931, Kurt Godel proved that the most widely accepted mathematical formalization
    of the natural numbers (Principia Mathematica) was either incomplete (not every
    true statement could be proved true) or was inconsistent (some false statements
    could be proved true). Godel''s incompleteness theorem applies to any formal mathematical
    system rich enough to include [Peano''s axioms](http://en.wikipedia.org/wiki/Peano_axioms)
    of arithmetic.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**哥德尔的不完备性定理。** 图灵不可判定性结果是数学基础受到的最震惊的打击之一。1931年，库尔特·哥德尔证明了自然数的最广泛接受的数学形式化（数学原理）要么是不完备的（不是每个真实陈述都能被证明为真），要么是不一致的（一些假陈述可以被证明为真）。哥德尔的不完备性定理适用于任何足够丰富以包括[皮亚诺公理](http://en.wikipedia.org/wiki/Peano_axioms)的算术的形式数学系统。'
- en: '**Negative results.** One of the distinguishing features of computer science
    that sets it apart from other sciences is the concept of "lower bounds" and "negative
    results." We see this with undecidability. We will also see it with NP-completeness
    and its derivatives, and lower bounds for sorting. Some of the great achievements
    in the social and physical sciences have dealt with impossibility results. There
    is Heisenberg''s uncertainty principle in quantum mechanics, Arrow''s impossibility
    theorem in economics, and Carnot''s theorem in thermodynamics. In mathematics,
    there is Abel''s impossibility theorem for finding the roots of 5th degree polynomials,
    the impossibility of trisecting an angle with a straight-edge and compass, proving
    Euclid''s Parallel Postulate and the existence of non-Euclidean geometry, the
    irrationality of the square root of 2, Lindenman''s proof that π is transcendental.
    Outside of mathematic logic (e.g, Goedel''s theorem), there are few disciplines
    with formal methodologies for proving such negative results.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**负面结果。** 计算机科学与其他科学的一个区别特征是“下界”和“负面结果”的概念。我们在不可判定性中看到这一点。我们还将在NP完全性及其衍生物以及排序的下界中看到这一点。社会和物理科学中的一些伟大成就涉及到不可能性结果。在量子力学中有海森堡的不确定性原理，在经济学中有阿罗不可能定理，在热力学中有卡诺定理。在数学中，有关于寻找5次多项式根的不可能性定理，用直尺和圆规三等分角度的不可能性，证明欧几里得平行公设和非欧几里得几何的存在，根号2的无理性，林登曼证明π是超越数的。除了数学逻辑（例如，哥德尔的定理）之外，很少有学科有形式化方法来证明这样的负面结果。'
- en: Exercises
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Creative Exercises
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: (Hopcroft, Motwani, and Ullman.) For each of the two instances to the PCP, either
    find a solution or argue why no such solution is possible.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （霍普克罗夫特，莫特瓦尼和乌尔曼。）对于两个PCP实例中的每一个，要么找到一个解决方案，要么说明为什么不可能有这样的解决方案。
- en: '[PRE2]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Answer*: A solution to the first instance is bababaababb (2-0-2-1-1-3). The
    second instance has no solution. Observe that all cards have at least as many
    b''s on the bottom as on the top. We must start with card 1, which has one more
    b on the bottom than on the top.'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：第一个实例的解决方案是bababaababb（2-0-2-1-1-3）。第二个实例没有解决方案。请注意，所有卡片底部至少有与顶部相同数量的b。我们必须从卡片1开始，底部比顶部多一个b。'
- en: '**Solvable instance of PCP.** The PCP problem is undecidable even if the only
    allowable symbols are 0 and 1\. Devise an algorithm that determines whether a
    PCP problem is a yes instance assuming that the only allowable symbol is 1. *Hint*:
    requires some number theory.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PCP的可解实例。** 即使只允许的符号是0和1，PCP问题也是不可判定的。设计一个算法，假设只允许的符号是1，确定PCP问题是否是一个是实例。*提示*：需要一些数论。'
- en: '**3x + 1 function.** It is not always easy to tell whether or not a specific
    function terminates on all inputs, even if the function is only a few lines long.
    For example, consider whether or not the following *Collatz function* terminates
    for input `x`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3x + 1函数。** 即使函数只有几行，有时也不容易判断特定函数是否在所有输入上终止。例如，考虑以下*Collatz函数*对输入`x`是否终止。'
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On many inputs, including 8 and 7, the program terminates:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在许多输入中，包括8和7，程序终���：
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At first glance, this appears like a simple problem. To determine whether or
    not a program terminates on any specific input, it is tempting to run the program
    with the given input and see what happens. If the program terminates, we can safely
    answer `yes`. The main obstacle is deciding when to stop and say `no`. Suppose
    we do stop the program at some point and answer `no`. Maybe, if we had left the
    programming running just a bit longer, it would have terminated. There is no way
    to know for sure.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个简单的问题。要确定程序是否在任何特定输入上终止，诱人的做法是运行具有给定输入的程序并查看发生了什么。如果程序终止，我们可以安全地回答`yes`。主要障碍是决定何时停止并说`no`。假设我们在某个时刻停止程序并回答`no`。也许，如果我们让程序运行更长一点，它就会终止。没有办法确定。
- en: '**196 problem.** Given a positive integer, reverse the digits and add it to
    the original number. Repeat until you get a palindrome. For example, if we start
    with 5280, the reverse is 825, so the next number is 5280 + 825 = 6105\. The next
    number is 6105 + 5016 = 11121. The last number is 11121 + 12111 = 23232 since
    it is a palindrome. This [reverse and add](http://mathworld.wolfram.com/Reverse-Then-AddSequence.html)
    algorithm terminates quickly for most integers. Nobody knows whether it terminates
    for 196, although it is known not to terminate in the first 9 million iterations.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**196问题。** 给定一个正整数，将数字颠倒并加到原数上。重复此过程直到得到一个回文数。例如，如果我们从5280开始，颠倒是825，所以下一个数是5280
    + 825 = 6105。下一个数是6105 + 5016 = 11121。最后一个数是11121 + 12111 = 23232，因为它是一个回文数。这种[颠倒并加](http://mathworld.wolfram.com/Reverse-Then-AddSequence.html)算法对大多数整数快速终止。没有人知道它是否对196终止，尽管已知在前900万次迭代中没有终止。'
- en: '**Fermat style problem.** Is there a positive integer-valued solution to 313(a³
    + b³) = c³? Write a program [Cube.java](Cube.java.html) that enumerates all integers
    a, b, and c and checks for a solution to the equation. Does the program halt (assuming
    no overflow)? *Answer*: yes, but don''t wait around since the smallest counterexample
    has more than 1,000 digits!'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**费马风格问题。** 是否存在一个正整数解来满足313(a³ + b³) = c³？编写一个名为[Cube.java](Cube.java.html)的程序，枚举所有整数a、b和c，并检查方程的解。该程序是否会停止（假设没有溢出）？
    *答案*：是的，但不要等待，因为最小的反例有超过1,000位数！'
- en: '**Fermat''s last theorem.** In 1XYZ Fermat conjectured that that there are
    no positive integers a, b, c, and n such that a^n + b^n = c^n for n > 2. Write
    a program Fermat.java to search for a counterexample and terminate if it finds
    one. Enumerate over all tuples a, b, c, and n in increasing order of c^n. In 19XY
    Andrew Wiles proved Fermat''s last theorem, which implies that Fermat.java will
    never terminate, assuming no overflow.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**费马大定理。** 在1XYZ年，费马猜想不存在正整数a、b、c和n，使得a^n + b^n = c^n，其中n > 2。编写一个名为Fermat.java的程序来搜索反例，并在找到一个时终止。按照c^n的增序枚举所有元组a、b、c和n。在19XY年，安德鲁·怀尔斯证明了费马大定理，这意味着假设没有溢出，Fermat.java永远不会终止。'
- en: '**Quine.** A quine is a program that when executes prints itself as output.
    Write a Java program [Quine.java](Quine.java.html) that is a quine. [Reference](http://knet.ro/lsantha/).
    Here is a list of [quines](http://www.nyx.net/~gthompso/quine.htm) in many languages.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自指程序。** 自指程序是一个执行时打印自身作为输出的程序。编写一个名为[Quine.java](Quine.java.html)的Java程序，它是一个自指程序。[参考](http://knet.ro/lsantha/)。这里是许多语言中的[自指程序](http://www.nyx.net/~gthompso/quine.htm)列表。'
- en: '**Pangram.** Write a computer program to create true sentence of the form "This
    computer-generated pangram contains _ a''s, _ b''s, ... " where the blanks are
    replaced by English words for the numbers.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全字母句。** 编写一个计算机程序，创建形式为“这个计算机生成的全字母句包含_个a，_个b，...”的真实句子，其中空白处用英文数字代替。'
- en: This computer-generated pangram contains six a's, one b, three c's, three d's,
    thirty-seven e's, six f's, three g's, nine h's, twelve i's, one j, one k, two
    l's, three m's, twenty-two n's, thirteen o's, three p's, one q, fourteen r's,
    twenty-nine s's, twenty-four t's, five u's, six v's, seven w's, four x's, five
    y's, and one z.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个计算机生成的全字母句包含六个a，一个b，三个c，三个d，三十七个e，六个f，三个g，九个h，十二个i，一个j，一个k，两个l，三个m，二十二个n，十三个o，三个p，一个q，十四个r，二十九个s，二十四个t，五个u，六个v，七个w，四个x，五个y和一个z。
- en: 'Reference: [here](http://rec-puzzles.org/new/sol.pl/language/english/sentences/self.ref/self.ref.letters)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考：[这里](http://rec-puzzles.org/new/sol.pl/language/english/sentences/self.ref/self.ref.letters)
- en: '**Self-halting problem.** Self-halting problem: given a program that takes
    one input, does it terminate when given itself as input? Prove that this problem
    is undecidable by following a similar argument as for the halting problem.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自停机问题。** 自停机问题：给定一个接受一个输入的程序，当给定自身作为输入时，它是否终止？通过类似于停机问题的论证证明这个问题是不可判定的。'
- en: '**Totality problem.** The *totality problem* is to decide whether an arbitrary
    Turing machine halts on *all* inputs. Such a program would enable us automatically
    detect for the possibility of infinite loops in our Java programs. Prove that
    the totality problem is undecidable by showing that you could solve the halting
    problem if you had a program TOTALITY(P) that returns `true` or `false` depending
    on whether the Turing machine P halts on all inputs.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全体性问题。** *全体性问题*是决定任意图灵机是否在*所有*输入上停机。这样的程序将使我们能够自动检测Java程序中的无限循环的可能性。通过展示如果有一个返回`true`或`false`的程序TOTALITY(P)，取决于图灵机P是否在所有输入上停机，证明全体性问题是不可判定的。'
- en: '*Solution*: suppose we want to solve the halting problem, e.g., to know whether
    the Turing machine Q halts on input x. Create a new machine P that takes an arbitrary
    input, ignores it, and runs Q on x. Now, P halts on all inputs if and only if
    Q halts on input x. Thus, we could use P to solve the halting problem.'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：假设我们想解决停机问题，例如，知道图灵机Q在输入x上是否停机。创建一个新机器P，它接受任意输入，忽略它，并在x上运行Q。现在，只有当Q在输入x上停机时，P才会在所有输入上停机。因此，我们可以使用P来解决停机问题。'
- en: '**Program equivalence problem.** Prove that the program equivalence problems
    in undecidable. Program equivalence problem: given two programs P and Q, do they
    produce the same result for all possible input values. Such a program means that
    an optimizing compiler cannot guarantee to find the optimally efficient program
    since there may be better versions, but the compiler can''t be sure that they
    are equivalent.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**程序等价问题。** 证明程序等价问题是不可判定的。程序等价问题：给定两个程序P和Q，它们对所有可能的输入值产生相同的结果吗？这样的程序意味着优化编译器无法保证找到最优效率的程序，因为可能有更好的版本，但编译器无法确定它们是否等价。'
- en: '*Solution*: We will restrict attention to Turing machines with no output -
    either they halt or don''t halt. We can easily construct a Turing machine Q that
    always halts and outputs nothing. Then PEQ(P, Q) outputs true if and only if P
    halts for all possible input values. Thus, if we had a subroutine PEQ(P, Q) we
    could solve the totality problem, which is undecidable. Hence PEQ(P, Q) is as
    well.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：我们将注意力限制在没有输出的图灵机上 - 它们要么停机，要么不停机。我们可以轻松构造一个总是停机且不输出任何内容的图灵机 Q。然后 PEQ(P,
    Q) 仅在 P 对所有可能的输入值停机时输出 true。因此，如果我们有一个 PEQ(P, Q) 子程序，我们就可以解决全面性问题，这是不可判定的。因此 PEQ(P,
    Q) 也是如此。'
- en: '**Busy beavers and computability.** The busy beaver function B(n) is defined
    to be the maximal number of ones that an n-state Turing machine over the binary
    alphabet can leave on an initially blank tape, while still halting. The functions
    B(n) is not computable: it is not possible to write a computer program that will
    take in an integer n and return B(n). Jeffrey Shallit''s handout provides a [rigorous
    proof](http://www.undergrad.math.uwaterloo.ca/~cs360/beaver.ps) of this statement.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**繁忙的海狸和可计算性。** 繁忙的海狸函数 B(n) 被定义为 n 状态图灵机在二进制字母表上可以在初始空白磁带上留下的最大数量的 1，同时仍然停机。函数
    B(n) 是不可计算的：不可能编写一个计算机程序，输入一个整数 n 并返回 B(n)。 Jeffrey Shallit 的讲义提供了对这一陈述的[严格证明](http://www.undergrad.math.uwaterloo.ca/~cs360/beaver.ps)。'
- en: '**A consequence.** Our proof of the undecidability of the Halting problem uses
    a Turing machines whose input is a representation of itself. In fact, the Halting
    problem is undecidable even if the input to the Turing machine is blank (all 0''s).
    Such machines are called *Blank Tape Turing Machines*. Furthermore, the problem
    is undecidable even if we only allow a two symbol alphabet (0 and 1). We leverage
    the non-computability of B(n) to establish this fact.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个结果。** 我们对停机问题不可判定性的证明使用了一个输入为自身表示的图灵机。事实上，即使图灵机的输入为空（全为 0），停机问题也是不可判定的。这样的机器被称为*空白磁带图灵机*。此外，即使我们只允许两个符号的字母表（0
    和 1），问题也是不可判定的。我们利用 B(n) 的不可计算性来证明这一事实。'
- en: For the sake of contradiction, let's assume that we can decide whether or not
    any Turing machine M halts when started with a blank tape. Given such a decider,
    we'll show how to compute B(n).
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了推导矛盾，让我们假设我们可以判断任何图灵机 M 在空白磁带上启动时是否停机。鉴于这样的决策者，我们将展示如何计算 B(n)。
- en: '[PRE5]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This procedure will terminate since there are only finitely many n-state Turing
    machines (and we can enumerate them in an orderly manner), and we only simulate
    the actions of those Turing machines that halt. This procedure computes B(n) since
    all n-state Turing machines that halt are considered. This construction implies
    that we have a method for computing B(n). Since computing B(n) is undecidable,
    our original assumption that we could decide whether a Turing machine halts must
    be invalid. Thus, it is impossible to write a computer program to decide whether
    a Turing machine will halt, even if the Turing machine begins with an empty tape
    and it works over the binary alphabet.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该过程将终止，因为只有有限数量的 n 状态图灵机（我们可以按顺序列出它们），而我们只模拟那些停机的图灵机的操作。该过程计算 B(n)，因为所有停机的 n
    状态图灵机都被考虑。这个构造意味着我们有一种计算 B(n) 的方法。由于计算 B(n) 是不可判定的，我们最初的假设，即我们可以判断图灵机是否停机，必须是无效的。因此，即使图灵机以空白磁带开始并且在二进制字母表上工作，也不可能编写一个计算机程序来判断图灵机是否会停机。
- en: '**Amoeba growth.** Suppose that you start with one amoeba in a jar. Every minute,
    each amoeba turns into 0 (dies), 1 (does nothing), 2 (splits into two), or 3 (splits
    into three) amoeba with probability 25%. What is the probability that the amoeba
    population eventually goes extinct? Write a Java program to simulate this experiment.
    How do you know when to stop and conclude that the population will not die out?
    *Answer*: using probability theory, can compute that extinction probability =
    sqrt(2) - 1\. Using Java, no easy answer.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变形虫生长。** 假设你在一个罐子里开始有一只变形虫。每分钟，每只变形虫以 25% 的概率变成 0（死亡）、1（不做任何事）、2（分裂成两只）或
    3（分裂成三只）只变形虫。变形虫种群最终灭绝的概率是多少？编写一个 Java 程序来模拟这个实验。你如何知道何时停止并得出结论说种群不会灭绝？*答案*：使用概率论，可以计算灭绝概率
    = sqrt(2) - 1。使用 Java，没有简单答案。'
- en: '**60-minute halting problem.** Is it possible to write a program that takes
    as input another program and its input and determines whether or not it will halt
    in less than 60 minutes (say on a machine that performs one machine instruction
    per second)?'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**60分钟停机问题。** 是否可能编写一个程序，接受另一个程序及其输入作为输入，并确定它是否会在不到 60 分钟内停机（比如在每秒执行一条机器指令的机器上）？'
- en: '**Pell''s equation.** Pell''s equation is to find an integer solution (x, y)
    to the equation x^2 - Dy^2 = 1, where D is a positive integer. Find the small
    positive integer solution to x^2 - 991y^2 - 1 = 0. *Answer*: x = 1, y = 0 is a
    trivial solution, but the smallest positive position is x = 379516400906811930638014896080,
    y = 12055735790331359447442538767.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**佩尔方程。** 佩尔方程是找到方程 x^2 - Dy^2 = 1 的整数解 (x, y)，其中 D 是正整数。找到方程 x^2 - 991y^2
    - 1 = 0 的最小正整数解。*答案*：x = 1, y = 0 是一个平凡解，但最小正整数解是 x = 379516400906811930638014896080，y
    = 12055735790331359447442538767。'
- en: '**Archimedes cattle problem.** Following problem arose in the solution of [Archimedes
    cattle problem](http://www.andrews.edu/~calkins/profess/cattle.htm), a numerical
    problem that defied mathematicians for over 200 years until advent of the computer
    age. Find smallest positive integral solution to x^2 - 4729494y^2 = 1. Answer:
    x = 109931986732829734979866232821433543901088049, y = 50549485234315033074477819735540408986340.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阿基米德的牛问题。** 在[阿基米德的牛问题](http://www.andrews.edu/~calkins/profess/cattle.htm)的解决中出现了以下问题，这是一个数值问题，在计算机时代之前困扰数学家超过
    200 年。找到方程 x^2 - 4729494y^2 = 1 的最小正整数解。答案：x = 109931986732829734979866232821433543901088049，y
    = 50549485234315033074477819735540408986340。'
