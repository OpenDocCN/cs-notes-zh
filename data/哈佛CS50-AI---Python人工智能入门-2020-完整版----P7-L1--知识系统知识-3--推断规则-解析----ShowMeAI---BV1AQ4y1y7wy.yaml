- en: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P7：L1- 知识系统知识 3 (推断规则，解析) - ShowMeAI -
    BV1AQ4y1y7wy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P7：L1- 知识系统知识 3 (推断规则，解析)](https://example.org)
    - ShowMeAI - BV1AQ4y1y7wy'
- en: idea of inference rules some sort of，rules that we can apply to take。knowledge
    that already exists and，translate it into new forms of knowledge。and the general
    way we'll structure an，inference rule is by having a horizontal。line here anything
    above the line is，going to represent a premise something。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 推断规则的想法是一种可以应用的规则，以将已经存在的知识转化为新的知识形式。我们构建推断规则的通用方式是通过在这里有一条水平线，线上的任何东西代表一个前提，即我们知道是真的，然后线下的任何东西就是我们在应用逻辑后能够得出的结论。
- en: that we know to be true and then，anything below the line，we'll be the conclusion
    that we can。arrive at after we apply the logic or，from the inference role that
    we're going。to demonstrate so we'll do some of these，inference rules as by demonstrating
    them。in English first but then translating，them into the world of propositional。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将通过首先用英语展示这些推断规则，然后将其翻译到命题世界来做一些这些推断规则。
- en: logic so you can see what those，inference rules actually look like so。for example
    let's imagine that I have，access to two pieces of information I。know for example
    that if it is raining，then Harry is inside for example and。let's say I also know
    it is raining then，most of us could reasonably then look at。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑，所以你可以看到这些推断规则实际上是什么样的。因此，比如说，假设我有两条信息，我知道，比如说如果下雨，那么哈里在里面，假设我也知道现在在下雨，那么我们中的大多数人可以合理地得出。
- en: this information and conclude that all，right Harry must be inside this。inference
    rule is known as modus ponens，and it's phrased more formally in logic。as this
    if we know that alpha implies，beta in other words if alpha then beta。and we also
    know that alpha is true then，we should be able to conclude that beta。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息得出结论，哈里必须在里面。这条推断规则被称为**前件肯定**，在逻辑中更正式的表述是：如果我们知道alpha蕴含beta，换句话说，如果alpha为真，那么beta也为真，我们也知道alpha是真的，那么我们应该能够得出beta的结论。
- en: is also true we can apply this inference，rule to take these two pieces of。information
    and generate this new piece，of information notices this is a totally。different
    approach from the model，checking approach where the approach was。look at all of
    the possible worlds and，see what's true in each of these worlds。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 也是真的，我们可以应用这个推断规则来获取这两条信息并生成这个新的信息。注意，这与模型检查的方法完全不同，后者的方法是查看所有可能的世界，看看在这些世界中什么是真实的。
- en: here we're not dealing with any specific，world we're just dealing with the。knowledge
    that we know and what，conclusions we can arrive at based on。that knowledge that
    I know that a，implies B and I know a and the。conclusion is B and this should seem，like
    a relatively obvious rule but of。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们并不处理任何特定的世界，而是处理我们知道的知识，以及基于这些知识我们能够得出的结论。我知道a蕴含b，而我知道a，结论是b，这似乎是一个相对明显的规则，但。
- en: course if alpha then beta and we know，alpha then we should be able to conclude。that
    beta is also true and that's going，to be true for many but maybe even all。of the
    inference rules that we'll take a，look at you should be able to look at。them and
    say yeah of course that's going，to be true but it's putting these all。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果alpha为真，那么beta也为真，如果我们知道alpha，那么我们应该能够得出结论，beta也是真的，这对许多甚至所有的推断规则都适用，你应该能够查看它们并说，当然，这将是正确的，但把这些全部放在一起。
- en: together figuring out the right，combination of inference rules that can。be applied
    that ultimately is going to，allow us to generate interesting。knowledge inside
    of our AI so that's，modus ponens this application of。implication that if we know
    alpha and we，know that alpha implies beta then we can。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一起弄清楚可以应用的推断规则的正确组合，这最终将使我们能够在我们的人工智能中生成有趣的知识，所以这是前件肯定，即如果我们知道alpha，我们知道alpha蕴含beta，那么我们可以。
- en: conclude beta let's take a look at，another example，fairly straightforward something
    like。Harry is friends with Ron and Hermione，based on that information we can。reasonably
    conclude Harry is friends，with Hermione that must also be true and。this inference
    rule is known as and，elimination in the what and elimination。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子，比较直接，比如哈里是罗恩和赫敏的朋友，根据这些信息，我们可以合理地得出哈里也是赫敏的朋友，这必须也是真的，这条推断规则被称为**与消除**。
- en: says is that if we have a situation，where alpha and beta are both true I。have
    information alpha and beta well，then just alpha is true or likewise just。beta
    is true but if I know that both，parts are true then one of those parts。must also
    be true again something，obvious from the point of view of human。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个情况，其中 α 和 β 都为真。我有信息 α 和 β，那么仅 α 为真，或者仅 β 为真。但如果我知道两部分都为真，那么其中一部分也必须为真，这从人类的角度来看显而易见。
- en: intuition but a computer needs to be，told this kind of information to be able。to
    apply the inference rule we need to，tell the computer that this is an。inference
    world that you can apply so，the computer has access to it and is。able to use it
    in order to translate，information from one form to another in。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉，但计算机需要被告知这种信息才能应用推理规则。我们需要告诉计算机，这是一个可以应用的推理世界，以便计算机能够访问它，并能够使用它将信息从一种形式转换为另一种形式。
- en: addition to that let's take a look at，another example of an inference rule。something
    like it is not true that Harry，did not pass the test bit of a tricky。sentence
    to parse will read it again it，is not true or it is false that Harry。did not pass
    the test well if it is，false that Harry did not pass the test。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，让我们看一个推理规则的另一个例子。像“哈利没有通过测试”这句话有点棘手。我们再读一遍，“哈利没有通过测试”是错误的，或者说是假的。如果哈利没有通过测试的说法是假的。
- en: then the only reasonable conclusion is，that Harry did pass the test and so this。instead
    of being and elimination is what，we call double negation elimination but。if we
    have two negatives inside of our，premise then we can just remove them。altogether
    they cancel each other out，one turns true to false and the other。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么唯一合理的结论是哈利通过了测试，因此这并不是一种消去，而是我们称之为双重否定消去。但如果我们在前提中有两个否定，那么我们可以将它们一起去掉，它们相互抵消，一个把真变为假，另一个。
- en: one turns false back into true phrased a，little bit more formally we say that
    if。the premise is not not alpha then the，conclusion we can draw is just alpha
    we。can say that alpha is true we'll take a，look at a couple more of these if I
    have。![](img/095e2b3aefae6b2653b5fbc4884dafae_1.png)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个把假变成真的，正式一点说，如果前提不是不是 α，那么我们可以得出的结论就是 α，我们可以说 α 为真。接下来我们再看几个这样的例子。
- en: it is raining then Harry is inside how，do i reframe this well this one is a。little
    bit trickier but if I know if it，is raining then Harry is inside then I。conclude
    one of two things must be true，either it is not raining or Harry is。inside and
    this one's trickier so let's，think about it a little bit this first。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下雨，那么哈利在里面。我该如何重新表述这个呢？这个有点棘手，但如果我知道如果下雨，那么哈利在里面，那么我得出两个必须为真的结论，要么没有下雨，要么哈利在里面。
- en: premise here if it is raining then Harry，is inside is saying that if I know
    that。it is raining then Harry must be inside，so what is the other possible case
    well。if Harry is not inside then I know that，it must not be raining so one of
    those。two situations must be true either it's，not raining or it is raining in
    which，case Harry is inside。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下雨，那么哈利在里面，这意味着如果我知道下雨，那么哈利必须在里面。那么还有什么其他可能的情况呢？如果哈利不在里面，那么我知道，肯定没有下雨，因此这两种情况必须成立：要么没有下雨，要么下雨，这样哈利就会在里面。
- en: so the conclusion I can draw is either，it is not raining or it is raining so。therefore
    Harry is inside and so this is，a way to translate if-then statements。into or statements
    and this is known as，implication elimination and this is。similar to what we actually
    did in the，beginning when we were first looking at。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我能得出的结论是，要么没有下雨，要么下雨，因此哈利在里面。这是一种将如果-那么语句转换为或语句的方法，这被称为蕴含消去。这类似于我们一开始所做的。
- en: those very first sentences about Harry，and Hagrid and Dumbledore and phrased
    a。little bit more formally this says that，if I have the implication alpha implies。beta
    that I can draw the conclusion that，either not alpha or beta because there。are
    only two possibilities either alpha，is true or alpha is not true so one of。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哈利、海格和邓布利多的那几句话，更正式地说，这表示如果我有一个蕴含关系，α 蕴含 β，那么我可以得出结论，要么不是 α，要么是 β，因为只有两种可能：要么
    α 为真，要么 α 不为真。
- en: those possibilities is alpha is not true，but if alpha is true well then we can，true。so
    either alpha is not true or alpha is，true in which case beta is also true so。this
    is one way to turn an implication，into just a statement about or in。addition to
    eliminating implications we，can also eliminate by conditionals as。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些可能性中，α不成立，但如果α成立，那么我们可以得出结论。所以，要么α不成立，要么α成立，此时β也成立。这是一种将蕴含转化为关于“或”的陈述的方式。
- en: well so let's take an English example，something like it is raining if and only。if
    Harry is inside and this if and only，if really sounds like that by。conditional
    that double arrow sign that，we saw in propositional logic not too。long ago and
    what does this actually，mean if we were to translate this well。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们举一个英语例子，比如“如果且仅如果哈利在里面，那么下雨”。这种“如果且仅如果”听起来像我们在命题逻辑中看到的双条件符号，这实际上意味着如果我们要翻译这个。
- en: this means that if it is raining then，Harry is inside and if Harry is inside。then
    it is raining that this implication，goes both ways and this is what we would。call
    by conditional elimination that I，can take a by conditional a if and only。if B
    and translate that into something，like this a implies B and B implies a so。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果下雨，那么哈利在里面；如果哈利在里面，那么下雨。这种含义是双向的，这就是我们所说的双条件消去，我可以将双条件“A当且仅当B”翻译成类似“A蕴含B，且B蕴含A”。
- en: many of these inference rules are taking，logic that uses certain symbols and。turning
    them into different symbols，taking an implication and turning it。into an or or
    taking a by conditional，and turning it into implication and。another example of
    it would be something，like this it is not true that both Harry。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多推理规则是将使用某些符号的逻辑转化为不同的符号，将一个蕴含转化为“或”，或者将一个双条件转化为蕴含。另一个例子是：如果说“哈利和罗恩都未通过测试”。
- en: and Ron passed the test well all right，how do we translate that what does that。mean
    well if it is not true that both of，them passed the test，well then the reasonable
    conclusion we。might draw is that at least one of them，passed the test so the conclusion
    is。either Harry did not pass the test or，run did not pass the test or both this。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果哈利和罗恩都通过了测试，合理的结论是至少有一个人通过了测试，因此结论是：要么哈利没有通过，要么罗恩没有通过，或两者都没有通过。
- en: is not an exclusive or but if it is true，that it is not true that both Harry
    and。Ron passed the test well then either，Harry didn't pass the test or Ron didn't。pass
    the test and this type of law is，one of de Morgan's laws quite famous in。logic
    where the idea is that we can turn，in and into an or we can say we can take。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是排他性“或”，但如果确实不成立哈利和罗恩都通过了测试，那么要么哈利没有通过，要么罗恩没有通过，这种类型的法则就是德摩根法则，在逻辑中非常著名，意在说明我们可以将“且”转换为“或”。
- en: this and that both Harry and Ron passed，the test and turn it into an or by。moving
    the knots around so if it is not，true that Harry and Ron passed the test。well
    then either Harry did not pass the，test or Ron did not pass the test either。and
    the way we framed that more formally，using logic is to say this if it is not。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将“哈利和罗恩都通过了测试”转化为“或”，通过重新排列关系。如果不成立哈利和罗恩都通过测试，那么要么哈利没有通过，要么罗恩没有通过。我们更正式地框定这个逻辑是说，如果不成立。
- en: true that alpha and beta well then，either not alpha or not beta the way I。like
    to think about this is that if you，have a negation in front of an end。expression
    you move the negation in，words so to speak moving the negation。into each of these
    individual sentences，and then flip the end into an or so the。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于α和β来说，如果α不成立，那么要么非α要么非β。我的思考方式是，如果你在一个“且”表达前有否定，那么你就向内移动否定，翻转“且”为“或”。
- en: negation moves inwards and the end flips，into an or so I go from not a and B
    to。not a or not B and there's actually a，reverse of de Morgan's law that goes
    in。the other direction for something like，this if I say it is not true that Harry。or
    Ron passed the test meaning neither。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 否定向内移动，最后翻转为“或”，所以我从“非A且B”变为“非A或非B”，而实际上，存在德摩根定律的反向情况，例如，如果我说“哈利或罗恩未通过测试”，这意味着两者都未通过。
- en: '![](img/095e2b3aefae6b2653b5fbc4884dafae_3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/095e2b3aefae6b2653b5fbc4884dafae_3.png)'
- en: of them passed the test well then in，conclusion I can draw is that Harry did。not
    pass the test and Ron did not pass，the test so in this case instead of。turning
    an and into an or we're turning，an or into an and but the idea is the。same and
    this again is another example，of de Morgan's laws and the way that。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 他们通过了测试，那么我可以得出的结论是，哈利没有通过测试，而罗恩也没有通过测试。因此，在这种情况下，我们不是将与转变为或，而是将或转变为与，但想法是相同的，这再次是德摩根定律的另一个例子。
- en: works is that if I have not A or B this，time the same logic is going to apply。I'm
    going to move the negation in words，and I'm going to flip this time flip the，or
    in to an end。so if not a or B meaning it is not true，that a or b or alpha or beta
    then I can。say not alpha and not beta moving the，negation in words in order to
    make that。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理是，如果我有非 A 或 B，那么这次相同的逻辑将适用。我将把否定移入文字，并且这次我将把或转换为与。因此，如果不是 A 或 B，这意味着 A
    或 B 或 alpha 或 beta 不是正确的，那么我可以说非 alpha 和非 beta，将否定移入文字以使其成立。
- en: conclusion so those are de Morgan's laws，and a couple other inference rules
    that。are worth just taking a look at，one is the distributive law that works。this
    way so if I have alpha and beta or，gamma well then much in the same way。that you
    can use in math use，distributive laws to distribute operands。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是德摩根定律，还有一些其他值得关注的推理规则，其中一个是以这种方式工作的分配律。所以如果我有 alpha 和 beta 或 gamma，那么与数学中一样，你可以使用分配律来分配操作数。
- en: like addition and multiplication I can，do a similar thing here where I can say。if
    alpha and beta or gamma then I can，say something like alpha and beta or。alpha
    and gamma that I've been able to，distribute this and sign throughout this。expression
    so this is an example of the，distributive property or the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 像加法和乘法一样，我可以在这里做类似的事情，我可以说，如果 alpha 和 beta 或 gamma，那么我可以说像 alpha 和 beta 或者 alpha
    和 gamma 这样的内容，我已经能够在这个表达式中分配和分配这个符号。这是分配律的一个例子。
- en: distributive law as applied to logic in，much the same way that you would。distribute
    like a multiplication over，the addition of something for example。this works the
    other way too so if for，example I have alpha or beta and gamma I。can distribute
    the or throughout the，expression I can say alpha or beta and。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将分配律应用于逻辑，就像你会将乘法分配到某个东西的加法上一样。例如，这种方式也可以反过来使用，所以例如，如果我有 alpha 或 beta 和 gamma，我可以将或分配到整个表达式中，我可以说
    alpha 或 beta 和。
- en: alpha or gamma so the distributive law，works in that way too and it's helpful。if
    I want to take an ore and move it，into the expression and we'll see an。example
    soon of why it is that we might，actually care to do something like that。all right
    so now we've seen a lot of，different inference rules and the。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: alpha 或 gamma，因此分配律也以这种方式起作用，如果我想将或移入表达式中，这将是有帮助的。我们将很快看到一个示例，说明为什么我们可能真的关心这样做。好吧，所以现在我们已经看到了很多不同的推理规则。
- en: question now is how can we use those，inference rules to actually try and draw。some
    conclusions to actually try and，prove something about entailment proving。they
    given some initial knowledge base，we would like to find some way to prove。that
    a query is true well one way to，think about it is actually to think back。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何使用这些推理规则来尝试得出一些结论，实际上尝试证明关于蕴含的某些内容。在给定一些初始知识库的情况下，我们希望找到某种方法来证明一个查询是真实的。那么一种思考方式是回顾。
- en: to what we talked about last time when，we talked about search problems recall。again
    that search problems have some，sort of initial State they have actions。that you
    can take from one state to，another as defined by a transition model。that tells
    you how to get from one state，to another we talked about testing to。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上次讨论的内容是关于搜索问题的回顾。搜索问题有某种初始状态，它们有可以从一个状态转换到另一个状态的动作，这些动作由转移模型定义，该模型告诉你如何从一个状态转移到另一个状态，我们也讨论了测试。
- en: see if you're at a goal and then some，path cost function to see you know how。many
    steps did you have to take or how，costly was the solution that you found。now that
    we have these inference rules，that take some set of sentences in。propositional
    logic and get us some new，set of sentences in propositional logic。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 查看你是否达到目标，然后用某种路径成本函数来查看你知道你需要走多少步，或者你找到的解决方案有多昂贵。现在我们有这些推理规则，这些规则将一些命题逻辑中的句子集变换为新的命题逻辑句子集。
- en: we can actually treat those sentences or，those sets of sentences as states inside。of
    a search problem so if we want to，prove that some query is true prove that。some
    logical theorem is true we can，treat theorem proving，as a form of a search problem
    I can say。that we begin in some initial state，where that initial state is the。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以将这些句子或这些句子的集合视为搜索问题中的状态，因此如果我们想证明某个查询是真的，证明某个逻辑定理是真的，我们可以将定理证明视为一种搜索问题。我可以说我们从某个初始状态开始，那个初始状态是。
- en: knowledge base that I begin with the set，of all of the sentences that I know
    to。be true what actions are available to me，well the actions are any of the。inference
    rules that I can apply at any，given time the transition model just。tells me after
    I apply the inference，rule here is the new set of all of the。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始的知识库是我知道的所有句子的集合。可用的行动是什么呢？可用的行动是我在任何时候可以应用的推理规则。过渡模型告诉我，在我应用推理规则之后，这里是我所有的新知识集合。
- en: knowledge that I have which will be the，old set of knowledge plus some。additional
    inference that I've been able，to draw much is in the same way we saw。what we got
    when we applied those，inference rules and got some sort of。conclusion that conclusion
    gets added to，our knowledge base and our transition。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是旧知识集合加上一些我能够得出的附加推理，这与我们上次看到的应用推理规则得出某种结论的方式是一样的。这个结论被添加到我们的知识库中，成为我们的过渡。
- en: model will encode that what is the goal，test well our goal test is you know。checking
    to see if we have proved the，statement we're trying to prove if the。thing we're
    trying to prove is inside of，our knowledge base and the path cost。function the
    thing we're trying to，minimize is maybe the number of。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 模型将编码目标测试。我们的目标测试就是检查我们是否已经证明了我们想要证明的陈述，如果我们试图证明的事情在我们的知识库中，路径成本函数我们试图最小化的可能是步骤数量。
- en: inference rules that we needed to use，the number of steps so to speak inside。of
    our proof and so here we've been able，to apply the same types of ideas that we。saw
    last time with search problems to，something like trying to prove something。about
    knowledge by taking our knowledge，and framing it in terms that we can。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用的推理规则，所谓的步骤数量，也就是在我们的证明中。因此在这里，我们能够应用与上次看到的搜索问题相同的思路，去证明一些关于知识的事情，通过将我们的知识以我们能够。
- en: understand as a search problem with an，initial state with actions with a。transition
    model so this shows up a，couple of things one being how versatile。search problems
    are that they can be the，same types of algorithms that we use to。solve a maze
    or figure out how to get，from point A to point B inside of。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其理解为一个搜索问题，具有初始状态、行动和过渡模型。因此这展示了几个事情，其中之一是搜索问题的多功能性，它们可以是我们用来解决迷宫或弄清楚如何从A点到B点的相同类型的算法。
- en: driving directions for example can also，be used as a theorem proving method
    of。taking some sort of starting knowledge，base and trying to prove something about。that
    knowledge so this yet again is a，second way in addition to model checking。to try
    and prove that certain statements，are true but it turns out there's yet。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶指示例如也可以用作一种定理证明方法，从某种起始知识库出发，尝试证明一些关于该知识的事情。因此，这再次是除了模型检查之外的第二种方法，来证明某些陈述为真，但事实证明还有更多。
- en: another way that we can try and apply，inference and we'll talk about this now。which
    is not the only way but certainly，one of the most common which is known as。resolution
    and resolution is based on，another inference rule that we'll take a。look at now
    quite a powerful inference，rule that will let us prove anything。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种我们可以尝试应用推理的方法，我们现在将讨论这一点，这不是唯一的方法，但肯定是最常见的之一，称为**归结**。归结基于另一种我们将要看的推理规则，这是一个相当强大的推理规则，能够让我们证明任何事情。
- en: that can be proven about a knowledge。![](img/095e2b3aefae6b2653b5fbc4884dafae_5.png)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以证明关于知识的事情。![](img/095e2b3aefae6b2653b5fbc4884dafae_5.png)
- en: base and it's based on this basic idea，let's say I know that either Ron is in。the
    Great Hall or Hermione is in the，library，and let's say I also know that Ron is。not
    in the Great Hall based on those two，pieces of information。what can I conclude
    well I could pretty，reasonably conclude that Hermione must。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个基本思想，假设我知道要么罗恩在大餐厅，要么赫敏在图书馆，假设我还知道罗恩不在大餐厅。基于这两条信息，我能得出什么结论呢？我可以相当合理地得出赫敏必须。
- en: be in the library how do I know that，well it's because these two statements。these
    two what we'll call complementary，literals literals that complement each。other
    they're opposites of each other，seem to conflict with each other this。sentence
    tells us that either Ron is in，library，so if we know that Ron is not in the。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在图书馆，我怎么知道的呢？因为这两个陈述，这两个我们称之为互补的文字，互补的文字彼此相反，似乎相互冲突。这句话告诉我们，要么罗恩在图书馆，所以如果我们知道罗恩不在。
- en: Great Hall that conflicts with this one，which means Hermione must be in the。library
    and this we can frame as a more，general rule known as the unit。resolution rule
    a rule that says that if，we have P or Q and we also know not P。well then from
    that we can reasonably，conclude Q but if P or Q are true and we。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个大礼堂相冲突，这意味着赫敏必须在图书馆，而我们可以将其框架为一个更一般的规则，称为单元分辨率规则，该规则表示如果我们有P或Q并且我们还知道非P，那么我们可以合理地得出结论Q，但如果P或Q为真，且我们。
- en: know that P is not true the only，possibility is for Q to then be true and。this
    it turns out is quite a powerful，inference rule in terms of what it can。do in
    part because we can quickly start，to generalize this rule this Q right。here doesn't
    need to just be a single，propositional symbol it could be。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 知道P不是真的，唯一的可能性就是Q为真，而这被证明是一个相当强大的推理规则，因为它的作用部分在于我们可以迅速开始概括这个规则，这个Q在这里不需要仅仅是一个单一的命题符号，它可以是。
- en: multiple all chained together in a，single Clause as we'll call it so if I。had
    something like P or q1 or q2 or q3，so on and so forth up until QN。so I had n different
    other variables and，I have not P well then what happens when。these two complement
    each other is that，these two clauses resolve so to speak to。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多个相互链接在一个单一的子句中，我们称之为子句，如果我有类似P或q1或q2或q3，依此类推，一直到QN。所以我有n个不同的其他变量，并且我有非P，那么当这两个互补时，会发生什么呢？是这两个子句解决了。
- en: produce a new clause that is just q1 or，q2 all the way up to QN and in an or
    the。order of the arguments in the order，doesn't actually matter the P doesn't。need
    to be the first thing it could have，been in the middle but the idea here is。that
    if I have P in one clause and not P，in the other clause well then I know。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 产生一个新子句，仅仅是q1或q2，一直到QN，或者参数的顺序实际上并不重要，P不需要是第一项，它可以在中间，但这里的想法是，如果我在一个子句中有P，在另一个子句中有非P，那么我知道。
- en: that one of these remaining things must，be true I've resolved them in order
    to。produce a new Clause but it turns out we，can generalize this idea even further
    in。fact and just display even more power，that we can have with this resolution。![](img/095e2b3aefae6b2653b5fbc4884dafae_7.png)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的这些东西之一必须为真，我已经解决了它们以产生一个新的子句，但事实证明我们甚至可以进一步概括这个想法，实际上，并展示我们在这个分辨率上可以拥有的更强大的能力。![](img/095e2b3aefae6b2653b5fbc4884dafae_7.png)
- en: rule so let's take another example let's，say for instance that I know the same。piece
    of information that either Ron is，in the Great Hall or Hermione is in the，library。and
    the second piece of information I，know is that Ron is not in the Great。Hall or
    Harry is sleeping so it's not，just a single piece of information I。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 规则，所以我们再举一个例子，假设我知道同样的信息，要么罗恩在大礼堂，要么赫敏在图书馆。而我知道的第二条信息是，罗恩不在大礼堂，或者哈利在睡觉，所以这不仅仅是一条信息，我。
- en: have two different closets and we'll，moment，what do I know here well again for
    any。propositional symbol like Ron is in the，Great Hall there are only two。possibilities
    either Ron is in the Great，Hall in which case based on resolution。we know that
    Harry must be sleeping or，Ron is not in the Great Hall in which。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个不同的情况，我们将会，稍后讨论，我在这里知道什么呢？同样对于任何命题符号，比如罗恩在大礼堂，只有两种可能性：要么罗恩在大礼堂，在这种情况下根据分辨率，我们知道哈利必须在睡觉，要么罗恩不在大礼堂。
- en: case we know based on the same rule that，Hermione must be in the library based
    on。those two things in combination I can，say based on these two premises that
    I。can conclude that either Hermione is in，the library or Harry is sleeping so。again
    because these two conflict with，each other I know that one of these two。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据同样的规则，我们知道赫敏必须在图书馆，基于这两者的结合，我可以说基于这两个前提，我可以得出结论，赫敏要么在图书馆，要么哈利在睡觉。所以再次因为这两者相互冲突，我知道这两者中有一个。
- en: must be true and you can take a closer，look and try and reason through that。logic
    make sure you convince yourself，that you believe this conclusion stated。more generally
    we can name this，resolution rule by saying that if we。know P or Q is true and
    we also know，that not P or R is true we resolve these。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些内容必须为真，你可以仔细查看并尝试推理，确保你相信这个结论。更一般地说，我们可以通过声明，如果我们知道 P 或 Q 为真，同时我们也知道非 P
    或 R 为真，我们可以解决这些问题。
- en: two clauses together to get a new Clause，Q or R that either Q or R must be true。and
    again much is in the last case Q and，R don't need to just be single。propositional
    symbols it could be，multiple symbols so if I had a rule that。had a P or q1 or
    q2 or q3 so on and so，forth up until Q n where n is just some。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个子句组合在一起以得到一个新的子句，Q 或 R，其中 Q 或 R 必须为真。再说一次，在最后的情况下，Q 和 R 不需要仅仅是单个命题符号，它们可以是多个符号，所以如果我有一个规则，其中有
    P 或 q1 或 q2 或 q3 依此类推，一直到 Q n，其中 n 只是某个数字。
- en: number and likewise I had not P or R 1，or R 2 so on and so forth up until R
    M。where m again is just some other number，I can resolve these two clauses together。to
    get one of these must be true q1 or，q2 up until QN or r1 or r2，up until RM and
    this is just a。generalization of that same rule we saw，before each of these things
    here are。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我有非 P 或 R1 或 R2 等，直到 R M，其中 m 也是某个数字。我可以将这两个子句组合在一起，以便得到其中一个必须为真的结果 q1 或
    q2 直到 QN 或 r1 或 r2 直到 RM，这只是我们之前看到的同一规则的概括。
- en: we're gonna call a clause where a clause，is formally defined as a disjunction
    of。literals where a disjunction means it's，a bunch of things that are connected。with
    or disjunction means things，connected with or conjunction。meanwhile stings connected
    with and and，a literal is either a propositional。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称之为子句，子句被正式定义为文字的析取，其中析取意味着多个事物通过“或”连接在一起，析取意味着通过“或”连接的事物，而结合则是通过“和”连接的，文字则是命题符号。
- en: symbol or the opposite of a，propositional symbol so if something。like P or Q
    or not P or not Q those are，all propositional symbols or not of the。propositional
    symbols and we call those，literals so a clause is just something。like this P or
    Q or R for example，meanwhile what this gives us an ability。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 符号或命题符号的反面，例如 P 或 Q 或非 P 或非 Q，这些都是命题符号或命题符号的反面，我们称之为文字。所以一个子句就像这样 P 或 Q 或 R，例如，同时这赋予了我们一种能力。
- en: to do is it gives us an ability to turn，logic any logical sentence into。something
    called conjunctive normal form，a conjunctive normal form sentence is a。logical
    sentence that is a conjunction，of clauses recall again conjunction。means things
    are connected to one，another using and and so a conjunction。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以使我们能够将任何逻辑句子转换为称为合取范式的东西，合取范式句子是一个逻辑句子，它是多个子句的结合。再提醒一下，结合意味着事物通过“和”连接在一起。
- en: of clauses means it is an end of，individual clauses each of which has ORS。in
    it so something like this a or B or C，and D or not e and F or G everything in。parentheses
    is one clause all of the，clauses are connected to each other。using an and and
    everything in the，clause is separated using an or and this。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 子句的组合意味着这是多个独立子句的结合，每个子句中都有“或”。所以像这样 A 或 B 或 C，和 D 或非 E 和 F 或 G，所有在括号中的内容都是一个子句，所有子句通过“和”连接在一起，子句中的所有内容通过“或”分隔。
- en: is just a standard form that we can，translate a logical sentence into that。just
    makes it easy to work with and easy，to manipulate and it turns out that we。can
    take any sentence in logic and turn，it into conjunctive normal form just by。applying
    some inference rules and，transformations to it so we'll take a。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 合取范式只是我们可以将逻辑句子转换为的标准形式，这使得操作和处理都变得简单。结果是，我们可以通过应用一些推理规则和变换将任何逻辑句子转换为合取范式。
- en: look at how we can actually do that so，what is the process for taking a logical。formula
    and converting it into，conjunctive normal form otherwise known。as CNF well the
    process looks a little，something like this we need to take all。of the symbols
    that are not part of，conjunctive normal form the by。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何实际做到这一点，那么，将逻辑公式转换为合取范式（也称为 CNF）的过程是什么呢？这个过程看起来大概是这样的，我们需要将所有不属于合取范式的符号分开。
- en: conditionals and the implications and so，forth and turn them into something
    that。is more closely like conjunctive normal，form so the first step will be to。eliminate
    by conditionals those if and，only if double arrows and we know how to。eliminate
    by conditionals because we saw，there was an inference rule to do just。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 条件句和蕴涵等等，将它们转变为更接近合取范式的东西。所以第一步将是消除条件句，那些“如果和仅当”的双箭头，我们知道如何消除条件句，因为我们看到有一个推理规则。
- en: that anytime I have an expression like，alpha if and only if beta I can turn。that
    into alpha implies beta and beta，implies alpha，based on that inference rule we
    saw。before likewise in addition to，eliminating by conditionals，I can eliminate
    implications as well the。if-then arrows and I can do that using，the same inference
    rule we saw before to。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我有表达式像“α当且仅当β”时，我可以将其转变为“α蕴涵β”和“β蕴涵α”，根据我们之前看到的推理规则。同样，除了消除条件句，我也可以消除蕴涵和“如果-那么”箭头，使用我们之前看到的相同推理规则。
- en: taking alpha implies beta and turning，that into not alpha or beta because that。is
    logically equivalent to this first，thing here then we can move not inwards。because
    we don't want knots on the，outsides of our expressions conjunctive。normal form
    requires that it's just，claws and claws and claws and claws any。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将“α蕴涵β”转变为“非α或β”，因为这在逻辑上等价于这里的第一个东西，然后我们可以将“非”移入。因为我们不希望结点在表达式的外部，合取范式要求仅有子句。
- en: knots need to be immediately next to，propositional symbols but we can move。those
    knots around using demorgan's laws，by taking something like not a and B and。turn
    it into not a or not B for example，using demorgan's laws to manipulate that。and
    after that all we'll be left with，our ands and ORS and those are easy to。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结点需要紧邻，命题符号，但我们可以移动这些结点。我们可以使用德摩根定律，将像“非A和B”这样的东西转变为“非A或非B”，例如，通过使用德摩根定律来操控。之后我们剩下的就是与和或，容易处理。
- en: deal with we can use the distributive，law to distribute the ORS so that the。ORS
    end up on the inside of the，expression so to speak and the ands end。up on the
    outside so this is the general，pattern for how we'll take a formula and。convert
    it in the conjunctive normal，form and let's now take a look at an。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分配律来分配或，使得或最终位于表达式内部，且与位于外部。这是我们如何将公式转变为合取范式的一般模式。现在让我们看看一个例子。
- en: example of how we would do this and，explore then why it is that we would。want
    to do something like this here's，how we can do it let's take this formula。for
    example P or Q implies R and I'd，like to convert this into conjunctive。normal
    form where it's all ands of，clauses and every clause is a。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何做到这一点的例子，接着探讨一下我们为什么要这样做。我们可以这样做，让我们以这个公式为例：“P或Q蕴涵R”，我想将其转换为合取范式，其中都是子句的与。
- en: disjunctive clause it's ORS together so，what's the first thing I need to do
    well。this is an implication so let me go，ahead and remove that implication using。the
    implication inference rule I can，turn P or Q into P or Q implies R into。not P
    or Q or R so that's the first step，I've gotten rid of the implication and。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 析取子句是将或连接在一起，所以我需要做的第一件事是什么？这是一个蕴涵，所以让我去掉这个蕴涵，使用蕴涵推理规则，我可以将P或Q转变为P或Q蕴涵R，变为“非P或Q或R”，所以这是第一步，我已经去掉了蕴涵。
- en: next I can get rid of the knot on the，outside of this expression too I can。move
    the knots inwards so they're closer，to the literals themselves by using。demorgan's
    laws and de Morgan's law says，that not P or Q is equivalent to not P。and not Q
    again here just applying the，inference rules that we've already seen。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我可以去掉这个表达式外部的结点，我可以将结点移入，使它们更靠近字面量，使用德摩根定律。德摩根定律表示“非P或Q”等价于“非P和非Q”，再次应用我们已经见过的推理规则。
- en: in order to translate these statements，and now I have two things that are。separated
    by an or where this thing on，the inside is an and，what I'd really like to Smoove
    the or so。the ORS are on the inside because，conjunctive normal form means I need。claws
    and claws and claws and claws and，sort of do that I can use the。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了翻译这些语句，现在我有两个通过“或”分开的东西，其中内部是一个与。我真的希望将“或”移动到内部，因为合取范式意味着我需要多个子句，所以可以使用。
- en: distributive law if I have not P and not，Q or R I can distribute the or R to
    both。of these to get not P or R and not Q or，R using the distributive law and
    this。now here at the bottom is in conjunctive，normal form，it is a conjunction
    and end of。disjunctions of clauses that just are，separated by ORS so this process
    can be。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分配律，如果我有 not P 和 not Q 或 R，我可以将或 R 分配给这两个，以得到 not P 或 R 和 not Q 或 R，使用分配律，而在这里底部就是合取范式，它是合取和析取的子句，只由
    ORS 分隔。因此这个过程可以是。
- en: used by any formula to take a logical，sentence and turn it into this。conjunctive
    normal form where I have，claws and claws and claws and claws and。claws and so
    on so why is this helpful，why do we even care about taking all。these sentences
    and converting them into，this form it's because once they're in。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 被任何公式使用，以将逻辑句子转换为这种形式。合取范式，我有爪子和爪子和爪子和爪子等等。那么，为什么这有帮助呢？我们为什么要关心将所有这些句子转换为这种形式？这是因为一旦它们进入。
- en: this form where we have these clauses，these clauses are the inputs to the。resolution
    inference rule that we saw a，moment ago that if I have two clauses。where there's
    something that conflicts，or something complementary between those。two clauses
    I can resolve them to get a，new Clause to draw a new conclusion and。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式，其中我们有这些子句，这些子句是我们刚才看到的解析推理规则的输入。如果我有两个子句，其中有一些冲突或互补的东西，我可以解析它们以得到一个新子句，从而得出一个新结论。
- en: we call this process inference by，resolution using the resolution rule to。draw
    some sort of inference and it's，based on the same idea that if I have P。or Q this
    clause and I have not P or R，that I can resolve these two clauses。together to
    get Q or R as the resulting，clause a new piece of information that I。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个过程为通过解析推理，使用解析规则来得出某种推理，基于同样的想法，如果我有 P 或 Q 这个子句，并且我有 not P 或 R，那么我可以将这两个子句合并，得到
    Q 或 R 作为结果子句，这是一条新的信息。
- en: didn't have before now a couple of key，points that are worth noting about this。before
    we talk about the actual，algorithm one thing is that let's。imagine we have P or
    Q RS and I also，have not P or R or s the resolution rule。says that because this
    P conflicts with，this not P we would resolve to put。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前有几个关键点值得注意。在我们讨论实际算法之前，有一点是让我们想象我们有 P 或 Q RS，我也有 not P 或 R 或 s。解析规则说，因为这个
    P 与这个 not P 冲突，我们将解析以放入。
- en: everything else together to get Q or s，or R or s but it turns out that this
    SS。is redundant or s here and or s there it，doesn't change the meaning of the。sentence
    so in resolution when we do，this resolution process will usually。also do a process
    known as factoring，where we take any duplicate variables。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有其他内容结合起来得到 Q 或 s 或 R 或 s，但事实证明，这个 SS 是多余的，或 s 在这里，或 s 在那里，并没有改变句子的含义。因此，在解析时，当我们进行这个解析过程时，通常也会进行一个称为因式分解的过程，其中我们处理任何重复的变量。
- en: that show up and just eliminate them so，Q or s or R or s just becomes Q。R or
    s the s only needs to appear once，no need to include it multiple times now。![](img/095e2b3aefae6b2653b5fbc4884dafae_9.png)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显示出来并消除它们，因此 Q 或 s 或 R 或 s 仅变为 Q。R 或 s，s 只需出现一次，不需要多次包含。现在。![](img/095e2b3aefae6b2653b5fbc4884dafae_9.png)
- en: one final question worth considering is，what happens if I try to resolve P and。not
    P together if I know that P is true，and I know that not P is true。well resolution
    says I can merge these，clauses together and look at everything。else well in this
    case there is nothing，else so I'm left with what we might call。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的最后一个问题是，如果我尝试将 P 和 not P 一起解析，如果我知道 P 是真的，而我知道 not P 是真的。那么解析说我可以将这些子句合并在一起，并查看其他所有内容。在这种情况下，没有其他内容，所以我只剩下我们可能称之为。
- en: the empty clause and left with nothing，and the empty clause is always false
    the。empty clause is equivalent to just being，false and that's pretty reasonable。because
    it's impossible for both P and，not P to both hold at the same time P is。either
    true or it's not true which means，that if P is true then this must be。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 空子句只剩下空，空子句始终是假的。空子句等同于只是假的，这很合理，因为不可能同时满足 P 和 not P。P 要么是真的，要么不是真的，这意味着如果 P
    为真，那么这必须是。
- en: false and if this is true then this must，be false there's no way for both of。these
    to hold at the same time so if，ever I try and resolve these two it's a。contradiction
    and I'll end up getting，this empty clause where the empty clause。I can call equivalent
    to false and this，idea that if I resolve these two。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假如这是假的，那么如果这是对的，这就必须是假的，这两者不可能同时成立。所以如果我尝试解决这两个，它就是一个矛盾，我最终得到这个空子句，而空子句我可以称之为等同于假，这个想法是如果我解决这两个。
- en: contradictory terms I get the empty。![](img/095e2b3aefae6b2653b5fbc4884dafae_11.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 矛盾的术语让我得到了空的。![](img/095e2b3aefae6b2653b5fbc4884dafae_11.png)
- en: clause this is the basis for our，inference by resolution algorithm here's。how
    we're going to perform inference by，resolution at a very high level we want。to
    prove that our knowledge base entails，some query alpha that based on the。knowledge
    we have we can prove，conclusively that alpha is going to be。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 子句，这是我们解析推理算法的基础。我们将如何以非常高的层次进行解析推理呢？我们想证明我们的知识库蕴含某个查询α，基于我们拥有的知识，我们可以确凿地证明α将会。
- en: true how are we going to do that well in，order to do that we're going to try
    to。prove that if we know the knowledge and，not alpha that that would be a。contradiction
    and this is a common，technique in computer science more。generally this idea of
    proving something，by contradiction if I want to prove that。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的情况，我们将如何做到这一点呢？为了做到这一点，我们将尝试证明，如果我们知道知识和非α，这将是一个矛盾。这在计算机科学中是一种常见的技术，更多地是证明某些事情的反证法。如果我想证明。
- en: something is true I can do so by first，assuming that it is false and showing。that
    it would be contradictory showing，that it leads to some contradiction and。if the
    thing I'm trying to prove if when，I assume it's false leads to a。contradiction
    then it must be true and，that's the logical approach or the idea。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 某些东西为真，我可以先假设它为假并展示这将导致矛盾，证明它会导致某种矛盾。如果我想证明的事情在我假设它为假时导致矛盾，那么它必须为真，这就是逻辑的方法或想法。
- en: behind it proof by contradiction and，that's what we're going to do here we。want
    to prove that this query alpha is，true so we're going to assume that it's。not
    true we're going to assume not alpha，and we're going to try and prove that it。prediction
    if we do get a contradiction，well then we know that our knowledge。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其背后的证明方法是反证法，这就是我们在这里要做的。我们想证明查询α为真，因此我们将假设它不为真，我们将假设非α，并尝试证明它。如果得出矛盾，那么我们知道我们的知识。
- en: entails the query alpha if we don't get，a contradiction there is no entailment。this
    is this idea of a proof by，contradiction of assuming the opposite。of what you're
    trying to prove and if，you can demonstrate that that's the。contradiction then
    what you're proving，must be true but more formally how do we。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有得到矛盾，那么查询α就没有蕴含。这就是反证法的理念，假设你试图证明的事情的反面，如果你能证明这就是矛盾，那么你所证明的必须为真，但更正式地说我们该如何。
- en: actually do this how do we check that，knowledge base and not alpha is going
    to。lead to a contradiction well here is。![](img/095e2b3aefae6b2653b5fbc4884dafae_13.png)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上该怎么做，我们如何检查知识库和非α不会导致矛盾呢？好吧，这里是。![](img/095e2b3aefae6b2653b5fbc4884dafae_13.png)
- en: where resolution comes into play to，determine if our knowledge base entails。some
    query alpha we're gonna convert，knowledge base and not alpha to。conjunctive normal
    form that form where，we have a whole bunch of clauses that。are all ANDed together
    and when we have，these individual clauses now we can keep。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 解析在这里发挥作用，以确定我们的知识库是否蕴含某个查询α。我们将把知识库和非α转换为合取范式，那种所有子句都用AND连接在一起的形式，当我们有这些个别的子句时，我们现在可以继续。
- en: checking to see if we can use resolution，to produce a new clause right we can。take
    any pair of clauses and check is，of each other，or complimentary to each other
    in both。of them for example I have a P in one，clause and a naught P in another
    clause。we're an R in one clause and then not，are in another clause if ever I have。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们是否可以使用解析生成新的子句。我们可以任意选择一对子句，检查它们是否互相包含或是互为补充。例如，在一个子句中有P，而在另一个子句中有非P；在一个子句中有R，而在另一个子句中有非R。
- en: that situation where once I convert to，conjunctive normal form and I have a。whole
    bunch of clauses I see two clauses，that I can resolve to produce a new。Clause
    then I'll do so this process，occurs in a loop I'm gonna keep checking。to see if
    I can use resolution to，produce a new Clause and keep using。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那种情况是，一旦我转换为合取范式，我有一大堆子句，我看到两个子句可以解析生成一个新的子句，我就会这样做。这个过程循环进行，我会不断检查是否可以使用解析生成新的子句并持续使用。
- en: those new clauses to try to generate，more new clauses after that now it just。so
    may happen that eventually we may，produce the empty Clause the clause we。were
    talking about before if I resolve，PIA and not P together that produces the。empty
    clause and the empty clause we，know to be false because we know that。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成更多的新子句，然后再继续。可能最终我们会产生空子句，我们之前谈论过的那个子句，如果我将A和非P一起解决，就会产生空子句，而空子句我们知道是错误的，因为我们知道。
- en: there's no way for both P and not P to，both simultaneously be true so if ever。we
    produce the empty clause then we have，a contradiction and if we have a。contradiction
    that's exactly what we，were trying to do in a fruit by。contradiction if we have
    a contradiction，then we know that our knowledge base。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能同时使P和非P都为真，因此如果我们产生空子句，那么我们就有了矛盾，如果我们有矛盾，这正是我们在通过矛盾的方式所要做的。如果我们有矛盾，那么我们知道我们的知识基础。
- en: must entail this query alpha we know，that alpha must be true and it turns out。and
    we won't go into the proof here but，you can show that otherwise if you don't。produce
    the empty clause，then there is no entailment if we run。into a situation where
    there are no more，new clauses to add we've done all the。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 必须蕴含这个查询α，我们知道α必须为真，结果证明了这一点。我们在这里不深入证明，但你可以展示，如果你没有生成空子句，那么就没有蕴含。如果我们遇到没有更多新子句可添加的情况，我们已经做完了所有。
- en: resolution that we can do and yet we，still haven't produced the empty closet。then
    there is no entailment in this case，and this now is the resolution algorithm。and
    it's very abstract looking，especially this idea of like what does。it even mean
    to have the empty clause so，let's take a look at an example actually。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行解析，但仍然没有产生空子句，在这种情况下就没有蕴含。这就是解析算法，它看起来非常抽象，特别是像“空子句”究竟意味着什么这样的概念，所以我们来看一个例子。
- en: try and prove some entailment by using，this inference by resolution process
    so。here's our question we have this，knowledge base here's the knowledge that。we
    know a or B and not B or C and not C，and we want to know if all of this。entails
    a so this is our knowledge base，here this whole log thing and our query。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过这个解析推理过程来证明某种蕴含，因此这是我们的问题，我们有这个知识基础，这就是我们知道的A或B和非B或C和非C，我们想知道这一切是否蕴含A，这就是我们的知识基础，整个逻辑内容和我们的查询。
- en: alpha is just this propositional symbol，a so what do we do well first we want
    to。prove by contradiction so we want to，first assume that a is false and see if。that
    leads to some sort of contradiction，so here's what we're going to start with。a
    or B and not B or C and not C this is，our knowledge base and we're going to。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: α只是这个命题符号A，那么我们该怎么做呢？首先，我们想要通过矛盾来证明，因此我们要假设A为假，看看是否会导致某种矛盾。那么我们将从A或B和非B或C和非C开始，这就是我们的知识基础。
- en: assume not a we're going to assume that，the thing we're trying to prove is in。fact
    false and so this is now in，conjunctive normal form and I have four。different
    clauses I have a or B I have，not B or C I have not seen and I have。not a and now
    I can begin to just pick，two clauses that I can resolve and apply。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要假设，我们要证明的事情实际上是错误的，因此这现在是合取范式，我有四个不同的子句：我有A或B，我有非B或C，我有非C，我还有非A，现在我可以开始选择两个可以解决并应用的子句。
- en: the resolution rule to them and so，looking in these four clauses I see。alright
    these two clauses are ones I can，resolve I can resolve them because there。are
    complementary literals that show up，in them there's a C here and a Nazi here。so
    just looking at these two clauses if，I know that not B or C is true and I。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些四个子句，我看到这两个子句是我可以解决的，因为它们中出现了互补的文字，这里有C，那里有非A。因此，仅查看这两个子句，如果我知道非B或C为真，我就可以将它们解决。
- en: know that C is not true well then I can，resolve these two clauses to say all。right
    not B that must be true I can，generate this new Clause as a new piece。of information
    that I now know to be，true and all right now I can repeat this。process do the
    process again can I use，resolution again to get some new。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道C为假，那么我可以将这两个子句解决，得出非B必须为真。我可以生成这个新子句作为我现在知道的一个新信息，现在我可以重复这个过程，看看是否可以再次使用解析得到一些新结果。
- en: conclusion well it turns out I can I can，use that new Clause I just generated。along
    with this one here there are，complementary literals this B is。complementary to
    or conflicts with this，not B over here and so if I know that a。or B is true and
    I know that B is not，true well then the only remaining。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，我可以使用我刚生成的新子句，和这个子句一起，这些是互补的字面量，这个B与这里的非B互补或冲突，因此如果我知道A或B为真，而B不为真，那么唯一剩下的。
- en: possibility is that a must be true so，now we have a that is a new clause that。I've
    been able to generate and now I can，do this one more time I'm looking for。two
    clauses that can be resolved and you，might programmatically do this by just。looping
    over all possible pairs of，clauses and checking for complementary。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性是A必须为真，所以现在我们得到了一个新的子句，我能够生成的，现在我可以再做一次，我在寻找可以解决的两个子句，您可能通过编程方式只需循环遍历所有可能的子句对并检查互补。
- en: literals in each and here I can say all，right I found two clauses not a an a。that
    conflict with each other and when I，resolve these two together well this is。the
    same as when we were resolving P and，not P from before when I resolve these。two
    clauses together I get rid of the，A's and I'm left with the empty clause。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个字面量在这里，我可以说，好吧，我找到了两个相互冲突的子句，不A和A。当我将这两个子句一起解决时，这与之前解决P和非P时是相同的，当我将这两个子句结合时，我消除了A，剩下了空子句。
- en: and the empty clause we know to be false，which means we have a contradiction。which
    means we can safely say that this，whole knowledgebase does entail a that。if this
    sentence is true that we know，that a for sure，is also true so this now using inference。by
    resolution is an entirely different，way to take some statement and try and。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而空子句我们知道是假的，这意味着我们有一个矛盾，这意味着我们可以安全地说，这整个知识库确实蕴含A，如果这个句子是真的，那么我们知道A肯定也是真的，所以现在使用推理通过分辨是一种完全不同的方式来尝试证明某个陈述实际上是真的，而不是枚举所有可能的世界。
- en: prove that it is in fact true instead of，enumerated all of the possible worlds。that
    we might be in in order to try to，figure out in which cases is the。knowledgebase
    true and in which case is，our query true instead we use this。resolution algorithm
    to say let's keep，trying to figure out what conclusions we。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能身处其中，以便试图找出在何种情况下知识库为真，何种情况下我们的查询为真，而是使用这个分辨算法来说，让我们继续尝试找出我们。
- en: can draw and see if we reach a，contradiction and if we reach a，contradiction
    and that tells us。something about whether our knowledge，actually entails the query
    or not and it。turns out there are many different，algorithms that can be used for
    instrum。inference what we've just looked at here，are just a couple of them and
    in fact。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以绘制并查看是否达到矛盾，如果我们达到了矛盾，这告诉我们一些关于我们的知识是否确实蕴含查询的事情。实际上，有许多不同的算法可以用于推理。我们刚刚看过的只是其中的几个，实际上。
- en: all of this is just based on one，particular type of logic it's based on。propositional
    logic where we have these，individual symbols and we connect them。using and and
    or and not and implies and，by conditionals but propositional logic。is not the
    only kind of logic that，exists and in fact we see that there are。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都仅基于一种特定类型的逻辑，它是基于命题逻辑，在这里我们有这些个体符号，我们通过“和”、“或”、“非”和“蕴含”以及条件连接它们，但命题逻辑并不是唯一存在的逻辑类型，事实上我们看到还有其他逻辑。
- en: limitations that exist in propositional，logic especially as we saw in examples。like
    with the mastermind example or with，the example with the logic puzzle where。we
    had different Hogwarts house people，that belonged to different houses and we。were
    trying to figure out who belonged，to which houses there were a lot of。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 命题逻辑中存在的局限性，尤其是在我们在像主脑示例或逻辑难题的例子中看到的，比如我们有来自不同霍格沃茨学院的人，试图找出谁属于哪个学院，这里有很多。
- en: different propositional symbols that we，needed in order to represent some fairly。basic
    ideas so now as a final topic that，we'll take a look at just before we end。class
    today is one final type of logic，different from propositional logic known。as first-order
    logic which is a little，bit more powerful than propositional。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要不同的命题符号来表示一些相当基本的想法，因此现在作为我们在结束今天的课堂之前要看的一最后一个主题，是一种与命题逻辑不同的逻辑类型，称为一阶逻辑，这比命题逻辑要强大一些。
- en: '![](img/095e2b3aefae6b2653b5fbc4884dafae_15.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/095e2b3aefae6b2653b5fbc4884dafae_15.png)'
- en: logic and it's going to make it easier，for us to express certain types of ideas。in
    propositional logic if we think back，to that puzzle with the people and the。Hogwarts
    houses we had a whole bunch of，symbols in every symbol could only be。true or false
    right we had a symbol for，Minerva Gryffindor which was either true。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑将使我们更容易表达某些类型的想法。在命题逻辑中，如果我们回想起那个关于人和霍格沃茨学院的难题，我们有一堆符号，每个符号只能为真或假，对吧，我们有一个符号代表米奈娃格兰芬多，这个符号要么为真。
- en: if Minerva was in Gryffindor and false，otherwise and likewise for Minerva。Hufflepuff
    the Minerva ravenclaw and，Minerva Slytherin and so forth but this。was starting
    to get quite redundant that，we wanted some way to be able to express。that there's
    a relationship between，these propositional symbols that Minerva。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果米奈娃在格兰芬多则为真，否则为假，对米奈娃赫奇帕奇、米奈娃拉文克劳和米奈娃斯莱特林同样如此，但这开始变得相当冗余，我们希望找到某种方法来表达这些命题符号之间的关系，即米奈娃。
- en: shows up in all of them and also I would，have liked to have not have had so
    many。different symbols to represent what，really was a fairly straightforward。problem
    so first-order logic will give，us a different way of trying to deal。with this
    idea by giving us two，different types of symbols we're gonna。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中都会出现，而且我希望不必有那么多不同的符号来表示实际上是一个相当简单的问题，所以一阶逻辑将为我们提供一种不同的方式来处理这个想法，给我们两种不同类型的符号。
- en: have constant symbols that are going to，represent objects like people or houses。and
    then predicate symbols which you can，think of as relations or functions that。take
    an input and evaluate them to like，true or false for example that tell us。whether
    or not some property of some，constant or some pair of constants or。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常量符号将代表像人或房屋这样的对象。然后是谓词符号，可以想象成关系或函数，它们接受输入并评估为真或假，例如告诉我们某些常量或一对常量的某些属性是否存在。
- en: multiple constants actually holds so，we'll see an example of that in just a。moment
    but for now in this same problem，our constant symbols might be objects。things
    like people or houses some，Minerva pomona Horace Gilderoy those are。all constant
    symbols and as are my four，houses Gryffindor Hufflepuff Ravenclaw。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 多个常量实际上成立，所以我们稍后会看到一个例子，但目前在这个同样的问题中，我们的常量符号可能是对象，比如人或房屋，像米奈娃、波莫纳、霍拉斯、吉德罗伊，这些都是常量符号，我的四个学院格兰芬多、赫奇帕奇、拉文克劳也是。
- en: and Slytherin predicates meanwhile these，predicate symbols are going to be。properties
    that might hold true or false，of these individual constants so person。might hold
    true of Minerva but it would，be false for Gryffindor because。Gryffindor is not
    a person and house，wood is going to hold true for ravenclaw。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 和斯莱特林谓词，同时这些谓词符号将是可能对这些单个常量成立或不成立的属性，因此“人”可能对米奈娃成立，但对格兰芬多则为假，因为格兰芬多不是一个人，而“学院”则会对拉文克劳成立。
- en: but it's not going to hold true for，Horace for example because Horace is a。person
    and belongs to meanwhile is going，to be some relation that is going to，relate。people
    to their houses and it's going to，only tell me when someone belongs to a。house
    or does not so let's take a look，at some examples of what a sentence in。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但这对霍拉斯不成立，因为霍拉斯是一个人，而他属于的同时将会有某种关系，将人与他们的学院联系起来，只告诉我某人是否属于一个学院，所以让我们看看一些在。
- en: first order logic might actually look，like a sentence might look like。something
    like this person Minerva with，Minerva in parentheses and person being。a predicate
    symbol Minerva being a，constant symbol this sentence in first。order logic effectively
    means Minerva is，a person or the person property applies。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一阶逻辑可能看起来像一个句子，可能看起来像这样：“人 米奈娃”，其中米奈娃在括号中，“人”是一个谓词符号，米奈娃是一个常量符号，这个一阶逻辑中的句子实际上意味着米奈娃是一个人，或者“人”属性适用。
- en: to the Minerva object so if I want to，say something like Minerva as a person。here
    is how I express that idea using，first-order logic，meanwhile I can say something
    like House。Gryffindor - likewise express the idea，that Gryffindor is a house I
    can do that。this way and all of the same logical，connectives that we saw in propositional。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于米奈娃对象，所以如果我想说米奈娃作为一个人，这里是我如何使用一阶逻辑表达这个想法，同时我可以说像格兰芬多的学院 - 同样表达了格兰芬多是一个学院的想法，我可以这样做，使用我们在命题逻辑中看到的所有相同的逻辑联接词。
- en: logic those are going to work here - so，and or implication by conditional not
    in。fact I can use not to say something like，not house Minerva and this sentence
    and。first-order logic means something like，Minerva is not a house it is not true。that
    the house property applies to，Minerva meanwhile in addition to some of。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑将在这里起作用——所以，和或蕴涵通过条件否定。在事实上，我可以使用否定来说一些，比如，不是房子米涅瓦，而这个句子和。第一阶逻辑意味着一些，比如，米涅瓦不是一所房子，它不是真的。房子属性适用于米涅瓦，同时还包括一些。
- en: these predicate symbols that just take a，single argument some of our predicate。symbols
    are going to express binary，relations relations between two of its。arguments so
    I could say something like，belongs to and then to inputs in the。Nerva and Gryffindor
    to express the idea，that Minerva belongs to Gryffindor and。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些谓词符号只接受一个，单一的参数，我们的一些谓词符号将表达二元，关系，两个参数之间的关系。因此我可以说一些，比如，属于，然后输入米涅瓦和格里芬多，以表达米涅瓦属于格里芬多的想法。
- en: so now here's the key difference but or，one of the key differences between this。and
    propositional logic in propositional，logic I needed one symbol for Minerva。Gryffindor
    and one symbol for Minerva，Hufflepuff and one symbol for all the。other people's
    Gryffindor and Hufflepuff，variables in this case I just need one。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里是关键的区别，但是或，两个之间的关键区别之一。这和命题逻辑中，在命题逻辑中，我需要一个符号表示米涅瓦。格里芬多和一个符号表示米涅瓦，赫奇帕奇，以及所有。其他人的格里芬多和赫奇帕奇，在这种情况下我只需要一个。
- en: symbol for each of my people and one，symbol for each of my houses and then I。can
    express as a predicate something，like belongs to and say belongs to。Minerva Gryffindor
    to express the idea，that Minerva belongs to Gryffindor house。so already we can
    see that first-order，logic is quite expressive in being able。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我每个人的符号和每个房子的一个符号，然后我。可以表达为一个谓词，比如属于，并说属于。米涅瓦格里芬多，以表达米涅瓦属于格里芬多的想法。因此我们可以看到，第一阶逻辑在能够。
- en: to express these sorts of sentences，using the existing constant symbols and。predicates
    that already exist while，minimizing the number of new symbols。that I need to create
    I can just，eight symbols four people four houses。instead of sixteen symbols for
    every，possible combination of each but，first-order logic。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的常量符号和。谓词来表达这些句子，同时，最小化我需要创建的新符号数量。我只需要八个符号，四个人，四个房子。而不是每个可能组合的十六个符号，但，第一阶逻辑。
- en: gives us a couple of additional features，that we can use to express even more。complex
    ideas and these more feet，additional features are generally known。as quantifiers
    and there are two main，quantifiers and first-order logic。![](img/095e2b3aefae6b2653b5fbc4884dafae_17.png)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们提供一些额外的功能，可以用来表达更复杂的。想法，这些额外的功能通常被称为量词，第一阶逻辑有两个主要的量词。![](img/095e2b3aefae6b2653b5fbc4884dafae_17.png)
- en: the first of which is Universal，quantification Universal quantification。lets
    me express an idea like something，is going to be true for all values of a。variable
    like for all values of X some，statement is going to hold true so what。might a
    sentence an Universal，quantification look like well we're。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是全称量化，全称量化。让我表达一个想法，比如某件事，对于变量的所有值都将为真。比如，对于所有 X 的值，某个陈述将为真，那么一个全称的句子，量化看起来像什么呢，好吧，我们。
- en: gonna use this upside down a to mean for，all so upside down a X means for all。values
    of X where X is any object this，is going to hold true it belongs to X。gryffindor
    implies not belongs to X，Hufflepuff so let's try and parse this。out this means
    that for all values of X，if this holds true if X belongs to。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我要用这个倒置的 A 表示对于，所有，所以倒置的 A X 意味着对于所有。X 的值，其中 X 是任何对象，这将成立，它属于 X。格里芬多意味着不属于 X，赫奇帕奇，所以我们来试着解析一下。这意味着对于所有
    X 的值，如果这成立，如果 X 属于。
- en: Gryffindor then this does not hold true，X does not belong to hufflepuff。so translate
    it into English this，sentence is saying something like for。all objects X if X
    belongs to Gryffindor，then X does not belong to Hufflepuff for。example or a phrase
    even more simply，anyone in Gryffindor is not in。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 格里芬多，那么这不成立，X 不属于赫奇帕奇。所以翻译成英语，这个句子是说，对于所有对象 X，如果 X 属于格里芬多，那么 X 不属于赫奇帕奇，例如，或者更简单的说法，任何在格里芬多的人不在。
- en: Hufflepuff simplified way of saying the，same thing so this Universal。quantification
    lets us express an idea，like something is going to hold true for。all values of
    a particular variable in，addition a universal quantification。though we also have
    existential，quantification whereas Universal。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**赫奇帕奇**更简化地说同样的事情。因此，这种普遍量化让我们表达一个想法，比如某些东西将在特定变量的所有值上成立。此外，普遍量化中我们还有存在量化。'
- en: quantification said something is going，to be true for all values of a variable。existential
    quantification says that，some expression is going to be true for。some value of
    a variable at least one，value of the variable so let's take a。look at a sample
    sentence using，existential quantification one such。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 量化表示某些东西在一个变量的所有值上都将成立，存在量化则表示某个表达在至少一个变量的某个值上将成立。让我们看看使用存在量化的示例句子。
- en: sentence looks like this there exists an，X this backwards e stands for exists
    and。here we're saying there exists an X such，that house X and belong。to Minerva
    X in other words there exists，some object X where X is a house and。Minerva belongs
    to X or phrased a little，more succinctly in English I'm here just。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 句子看起来像这样：存在一个X，这个倒过来的e代表存在。这里我们说存在一个X，使得X是一个房子，且米涅尔瓦属于X。换句话说，存在某个对象X，X是一个房子，而米涅尔瓦属于X，或者更简洁地用英语表达，我只是。
- en: saying Minerva belongs to a house，there's some object that is a house and。Minerva
    belongs to a house and combining，this Universal and existential。quantification
    we can create far more，sophisticated logical statements than we。were able to just
    using propositional，logic I could combine these to say。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 说**米涅尔瓦**属于一个房子，这里有一个物体是一个房子。米涅尔瓦属于一个房子，通过结合这个普遍和存在的量化，我们可以创造出比仅使用命题逻辑更复杂的逻辑语句。
- en: something like this for all X person X，implies there exists a Y such that house。Y
    and belongs to X Y all right so a lot，of stuff going on there a lot of symbols。let's
    try and parse it out and just，understand what it's saying here we're。saying that
    for all values of X if X is，a person then this is true so in other。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样，对所有X，若X是一个人，则存在一个Y，使得Y是一个房子，且属于X。好吧，这里发生了很多事情，有很多符号。让我们试着解析一下，理解它在说什么。我们说对于所有X的值，如果X是一个人，那么这是正确的。
- en: words I'm saying for all people and we，call that person X this statement is。going
    to be true what statement is true，of all people well there exists a Y that。is
    a house so there exists some house，and X belongs to Y in other words I'm。saying
    that for all people out there，there exists some house such that X the。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我说对于所有人，我们称那个人为X，这个陈述将会是正确的。那么对所有人来说，什么陈述是正确的呢？那就是存在一个Y，是一个房子。也就是说，存在某个房子，且X属于Y。换句话说，我在说，对于所有人，存在某个房子，使得X。
- en: person belongs to Y the house so spray，is more succinctly I'm saying that every。person
    belongs to a house and for all X，if X is a person then there exists a。house that
    X belongs to and so we can，now express a lot more powerful ideas。using this idea
    now a first-order logic，and it turns out there are many other。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人属于Y这个房子，因此更简洁地说，我在说每个人都属于一个房子，对于所有X，如果X是一个人，那么存在一个房子，X属于它。因此我们现在可以使用这个想法来表达更多强大的概念，现在第一阶逻辑也证明了有许多其他。
- en: kinds of logic out there there's，second-order logic another higher-order，logic。each
    of which allows us to express more，and more complex ideas but all of it in。this
    case is really in pursuit of the，same goal which is the representation of。knowledge
    we want our AI agents to be，able to know information to represent。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有各种逻辑，第二阶逻辑和更高阶逻辑，每种逻辑都允许我们表达越来越复杂的想法，但在这种情况下，所有的追求其实都是同一个目标，那就是知识的表示。我们希望我们的AI代理能够了解信息，表示。
- en: that information whether that's using，propositional logic or first-order logic。or
    some other logic and then be able to，reason based on that to be able to draw。conclusions
    make inferences figure out，whether there's some sort of entailment。relationship
    as by using some sort of，inference algorithm something like。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息，无论是使用命题逻辑、第一阶逻辑，还是其他逻辑，然后能够基于此推理，得出结论，进行推断，弄清楚是否存在某种蕴含关系，借助某种推理算法。
- en: inference by resolution or model，checking or any number of these other。algorithms
    so that we can use in order，to take information that we know and，translate it
    to a dish。conclusions so all of this has helped us，to create AI that is able to
    represent。information about what it knows and what，it doesn't know next time though
    we'll。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解析或模型检查等推理，或任何其他算法，我们能够使用已知的信息并将其转化为**结论**。所有这些都帮助我们创造出能够表示关于其所知和所不知道的信息的AI，下次我们将…
- en: take a look at how we can make our AI，even more powerful by not just encoding。information
    that we know for sure to be，true and not to be true but also to take。a look at
    uncertainty to look at what，happens if AI thinks that something。might be probable
    or maybe not very，probable or somewhere in between those。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们如何通过不仅仅编码我们确定为**真实**和**不真实**的信息，还要关注不确定性，使我们的AI变得更加强大，看看如果AI认为某件事情可能是**可能的**或可能不是**很可能**，或者介于这两者之间会发生什么。
- en: two extremes all in the pursuit of，trying to build our intelligence systems。![](img/095e2b3aefae6b2653b5fbc4884dafae_19.png)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在追求构建我们的智能系统的过程中，涵盖了这两个极端。![](img/095e2b3aefae6b2653b5fbc4884dafae_19.png)
