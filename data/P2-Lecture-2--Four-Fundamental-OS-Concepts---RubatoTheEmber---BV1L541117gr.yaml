- en: P2：Lecture 2： Four Fundamental OS Concepts - RubatoTheEmber - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P2：第二讲：操作系统的四个基本概念 - RubatoTheEmber - BV1L541117gr
- en: Okay everybody， welcome back to 162。 I'm going to be giving lecture two， finishing
    some of。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，大家好，欢迎回到162课堂。我将进行第二讲，继续讲解上一节未完成的内容。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_1.png)'
- en: the things we were starting last time。 And if you remember last time we talked
    about。 operating systems pretty much in general and we asked ourselves what it
    was exactly that。 an operating system was。 And I tried to indicate to you that
    it's， there are lots of different。 operating systems and different people would
    disagree with each other on this。 But these。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我们开始讨论的内容。如果你还记得，上一节我们大致讲了操作系统，并且我们问了自己，操作系统究竟是什么。然后我试图向你们说明，操作系统有很多种，不同的人对此会有不同的看法。但这些。
- en: three functions of referee， illusionist and glue are pretty common across a
    wide variety。 of operating systems and many of them have all three。 Okay， where
    the referee is actually。 managing resources， the illusionist is providing that
    illusion of infinite memory and perfect。 hardware resources。 And the glue consists
    of a whole series of common services like file， systems。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 裁判、魔术师和粘合剂这三种功能在各种操作系统中都很常见，许多操作系统都具备这三者。好的，裁判实际上是在管理资源，魔术师则提供了无限内存和完美硬件资源的幻象。而粘合剂则由一系列常见服务组成，比如文件系统。
- en: etc。 that are there to help make programming the machine much better。 We also。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，这些都能帮助我们更好地进行机器编程。我们也。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_3.png)'
- en: talked， started talking about protection in general， that's going to be one
    of our first。 major detail topics but we're going to touch on it lightly today。
    And here what I show。 is that there's the hardware underneath， the operating system
    up above is basically providing。 that virtual machine view to the processes。 Okay，
    and the processes which we're going。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始谈论一般的保护问题，这将是我们第一个详细讨论的主题之一，不过今天我们会简单提及。这里我展示的是，硬件在下面，操作系统在上面，基本上为进程提供了虚拟机视图。好的，进程就是我们接下来要讨论的内容。
- en: to talk in more detail today and in additional detail as we go on are really
    these virtual。 containers that have a view of perfect hardware underneath them
    and they think that they have。 the whole machine。 So here I have a brown and a
    green process， the brown process thinks。 it has all of the memory， all of the
    file system， all of the sockets and threads， the。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们要更详细地讨论，并且在未来几周会进一步深入讨论的内容，实际上是这些虚拟容器，它们认为自己有完美的硬件底层，并认为自己拥有整个机器。所以在这里，我展示了一个棕色进程和一个绿色进程，棕色进程认为自己拥有所有的内存、所有的文件系统、所有的套接字和线程，进程。
- en: green one thinks similarly and it's up the operating system to really basically
    provide。 that illusion。 And in terms of protection， of course the important part
    here is for instance。 this green process， while it's running， could attempt to
    access the memory of the brown， process。 it could attempt to access OS memory，
    it could attempt to access parts of the storage。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色的进程类似地认为，操作系统的职责就是提供这种幻象。至于保护问题，当然这里的关键部分是，例如这个绿色进程，在运行时，可能会试图访问棕色进程的内存，可能会试图访问操作系统的内存，也可能会试图访问存储的一部分。
- en: that it's not supposed to。 And in all of those cases， what ends up happening
    is the operating。 system essentially stops that from happening and then causes
    a segmentation fault and basically。 boots the process out。 So that's the protection
    piece。 And we're going to talk a lot about。 that as we go on the next couple of
    weeks。 And there'll be many different ways to do that。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它不应该这么做。在所有这些情况下，最终发生的事是，操作系统基本上阻止了这种情况发生，然后会导致一个分段错误，并基本上把进程强行退出。所以这就是保护机制。我们将在接下来的几周中详细讨论这一点，会有许多不同的方法来实现这一点。
- en: kind of protection， but I'll show you a fairly simple first thoughts at that
    today even。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是某种形式的保护，今天我会先给你们展示一个相对简单的思路。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_5.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_5.png)'
- en: The thing that we didn't quite get to last time and I wanted to mention now
    is really。 the complexity of all of this。 So you saw that picture of the world
    as a single machine， you know。 single huge computer that I showed last time。 And
    that's a lot of hardware that。 somehow has to be tamed。 And if you look at applications，
    they really have a variety。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上次没有完全讲到的，现在我想提一下的是真正的复杂性。你看到了上次我展示的世界作为单一机器的画面，那个单一的大型计算机。那是一大堆硬件，必须以某种方式加以驯服。如果你看看应用程序，它们实际上有各种各样的需求。
- en: of software modules， they run on a bunch of different devices or machines， they
    implement。 different hardware architectures， they run competing applications，
    they fail in unexpected， ways。 they might be under attack。 And really that complexity
    of both what the applications。 are trying to do and all the underlying hardware
    is tremendous。 Okay， and it's not feasible。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件模块运行在各种不同的设备或机器上，实施不同的硬件架构，运行竞争的应用程序，以意想不到的方式发生故障，可能会受到攻击。实际上，无论是应用程序想做什么，还是所有底层硬件的复杂性，都非常巨大。好吧，这其实是不切实际的。
- en: to test all the combinations。 I mean， how could you possibly test an application
    against。 the machine with a one terabyte SSD and a two terabyte spinning storage
    and six gigabytes。 of memory and a hundred gigabytes of memory。 You just can't
    do that and all combinations。 are just not possible。 And so we're really going
    are going to have to figure out how。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试所有组合几乎是不可能的。我的意思是，你怎么可能测试一个应用程序与一个配备1TB固态硬盘、2TB旋转存储、6GB内存和100GB内存的机器的兼容性呢？你根本做不到，而且所有的组合是不可能的。所以，我们真的得弄清楚如何去做。
- en: to design things correctly from the beginning。 And， you know， let's accept it
    now。 It's not。 a question about whether they're bugs or not。 There will always
    be bugs。 It's a question。 about how serious they are and， you know， what type
    of bugs they are。 And we're going to。 try to do bug management in a sense as well
    as we go out throughout the term。 And one of。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就正确设计这些东西是非常复杂的。而且，你知道，让我们现在接受这一点。问题不在于是否会有bug，而是bug的严重性以及它们的类型。我们将在整个学期中尽力进行bug管理。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_7.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_7.png)'
- en: the things that leads to complexity is parallelism。 And this is why， of course，
    we're going to。 spend a bunch of time talking about synchronization primitives
    in a couple of weeks。 But what I。 wanted to mention， here's a good example from
    2027。 The Intel Skylake has cores that can。 have 28 cores。 There's even a 56 core
    version up to 56 threads。 So there's two threads per。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 导致复杂性的原因是并行性。正因如此，当然，我们将在接下来的几周里花大量时间讨论同步原语。但是我想提一下，这是一个来自2027年的好例子。英特尔的Skylake处理器拥有最多28个核心，甚至有56核版本，可以支持最多56个线程。所以每个核心有两个线程，此外还有许多不同的安全指令和图形指令。
- en: core and lots of different security instructions and graphics instructions。
    There are 28 megabytes。 of cache at the L2 level。 There's 38。5 megabytes of cache
    at the L3 level。 Directory-based cache。 coherence。 There's lots of different types
    of networks， including a mesh network on chip。 and fast off-chip networks， DRAM
    connections up to 1。5 terabytes。 And so this is complex。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在L2级别有28MB的缓存，在L3级别有38.5MB的缓存。采用基于目录的缓存一致性技术。还存在多种类型的网络，包括芯片内的网状网络和快速的芯片外网络，DRAM连接可以达到1.5TB。这一切都非常复杂。
- en: even of itself。 And this is like a single node。 So when we tie all that together，
    things。 get really interesting， right？ But parallelism is fundamental these days。
    And in addition to。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是单个节点也是如此。所以当我们将这一切连接起来时，事情就变得非常有趣，对吧？但并行性是当今的基础。除了并行性，
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_9.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_9.png)'
- en: that parallelism， a modern chip typically has a chipset that goes with it。 So
    what you。 see here at the top is an example of an Intel chip family processor
    with a bunch of cores， on it。 It has direct connections to memory and PCI express
    for high-speed communication。 And then there's typically a direct media interface
    connection to the chip sets underneath。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现代芯片通常还配有一个芯片组。所以你在顶部看到的是一个英特尔芯片家族的处理器示例，拥有多个核心。它与内存和PCI Express有直接连接，以进行高速通信。然后，通常还有一个直接的媒体接口连接到下面的芯片组。
- en: And the chip set potentially handles all the other interesting aisle。 So from
    the standpoint。 of the processor， we have high bandwidth memory channels。 We've
    got really high-speed IO for。 graphics。 We've got this direct media interface
    down to this secondary chipset used to be。 called the Southbridge， for instance。
    But not anymore。 But anyway， off of that， we have。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片组可能处理所有其他有趣的部分。所以从处理器的角度来看，我们有高带宽内存通道。我们有非常高速的I/O用于图形。我们有这个直接媒体接口连接到这个二级芯片组，曾经被称为南桥。例如，但现在不再是了。但无论如何，从那儿我们有。
- en: PCI Express。 We've got SATA for disk。 We've got USB for other types of IO。 We
    have Ethernet， IO。 PCIe， RAID， et cetera。 All sorts of really interesting things
    all tied into that one CPU。 So if you look at， you know， this itself is interesting。
    This is very interesting。 Lots。 of complexity。 And， you know， I like this graph。
    You guys should all take a look。 You。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express。我们有SATA用于硬盘。我们有USB用于其他类型的I/O。我们有以太网，I/O，PCIe，RAID等等。各种各样非常有趣的东西都连接到这个CPU上。所以如果你看看，嗯，这本身就很有趣。这非常有趣。复杂性很高。而且，你知道，我很喜欢这个图表。你们都应该看看。你们。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_11.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_11.png)'
- en: can go to information is beautiful。net/visualization/millionlines of code and
    take a look at some of the code。 counts over the years。 Okay。 And what's interesting
    here is if you look at a newer version of something。 so like Linux 2。2 versus
    Linux 3。1， it's always bigger。 So there's a lot more software for each。 next generation。
    Right。 And so more and more memory， more and more complexity with each， generation。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问 information is beautiful.net/visualization/millionlinesofcode，查看多年来一些代码的数量统计。好的。有趣的是，如果你看看某个版本的更新内容，比如Linux
    2.2与Linux 3.1，通常是越来越大。所以每一代的程序都更多。对吧。也就是说，每一代都需要更多的内存，更多的复杂性。
- en: A car is starting to get very complicated。 100 million lines of code。 Actually。
    it would be interesting to see what a Tesla is like。 And so， you know， that complexity。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一辆车开始变得非常复杂。1亿行代码。实际上，看到一辆特斯拉是怎样的会很有趣。你知道，那种复杂性。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_13.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_13.png)'
- en: leaks in to the operating system if you don't design it correctly。 And you get
    blue screens。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有正确设计它，漏洞就会渗透到操作系统中。然后你会看到蓝屏。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_15.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_15.png)'
- en: Okay。 Mouse base pairs。 The question is what's a mouse base pair？ So this is
    actually the。 DNA of a mouse。 Okay。 So we're not getting all that far away。 Okay。
    From that complexity。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。鼠标碱基对。问题是，什么是鼠标碱基对？这实际上是小鼠的DNA。好的，所以我们并没有离这个复杂性太远。好的。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_17.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_17.png)'
- en: The third party device drivers， which are the parts of an operating system that
    access。 the outside world， are some of the most unreliable parts of operating
    systems。 Okay。 And the reason。 for that is they're not written well， necessarily
    they're written quickly to support a new device。 and they're not written by Microsoft
    or Apple or whoever your operating system comes from。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方设备驱动程序，作为操作系统的一部分，负责访问外部世界，是操作系统中最不可靠的部分之一。好的。其原因是，它们并不是写得很好，通常是快速编写以支持新设备，并且它们不是由微软、苹果或你的操作系统供应商编写的。
- en: And as a result， they tend to be the things that crash the system。 Okay。 And
    basically。 there are clean interfaces from the operating system to the device。
    And that's an attempt。 to provide a clean interface so that third parties can
    write this type of code。 And that。 ironically can lead to more crashes under some
    of circumstances。 And we're going to spend。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，它们往往是导致系统崩溃的原因。好的。基本上，从操作系统到设备之间有着干净的接口。这是一次尝试，提供一个干净的接口，使得第三方可以编写这类代码。讽刺的是，在某些情况下，这反而会导致更多的崩溃。我们将花时间。
- en: a lot of time talking about device drivers later in the term。 And there's all
    sorts of， holes。 Okay。 See， if you don't have enough complexity from everything
    that's working properly。 now you've got security holes。 Okay。 And a great example
    from 2017 was the infamous meltdown。 bug where it was discovered that despite
    all of the protection in the hardware and the。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 后期我们会花很多时间讨论设备驱动程序。并且存在各种各样的漏洞。好的。看，如果你没有足够的复杂性来保证一切正常工作，现在你就会有安全漏洞。好的。2017年一个很好的例子是臭名昭著的Meltdown漏洞，当时发现尽管硬件上有所有保护措施。
- en: proper use in the operating system of that hardware， you ended up with the ability
    for。 user level programs to drain secure information out of the kernel。 Okay。
    And so if you think。 about that， it's like， well， I did everything I could。 And
    there was this weird hole in the。 hardware that nobody knew about。 And even surprised
    a bunch of famous computer architects。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中正确使用这些硬件，你最终得到了用户级程序能够从内核中提取安全信息的能力。好的。所以如果你考虑一下，那就像是，我做了我能做的一切，但硬件中有一个没人知道的奇怪漏洞，甚至让一些著名的计算机架构师都感到惊讶。
- en: like Dave Patterson and John Hennessy。 So complexity is always there。 And at
    best， we。 have to manage it。 Okay。 And then things like versions queue on libraries
    can lead to all。 sorts of problems。 Okay。 Data breaches， denial of service attacks，
    timing channels。 There。 was the heart bleed SSL bug， so on。 So all of these exploits
    are there if you're not careful。 Okay。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像Dave Patterson和John Hennessy。所以复杂性总是存在的。在最好的情况下，我们必须管理它。好的。然后像版本队列、库等问题会导致各种各样的问题。好的。数据泄露、拒绝服务攻击、时序通道。比如心脏出血SSL漏洞，等等。所以如果你不小心，所有这些漏洞都会存在。好的。
- en: And so， and I see a comment in the chat that it was a really cool exploit。 And
    yes。 Altong was cool as an exploit。 And we'll actually talk about that a little
    later in the term。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我看到聊天中有个评论，说这是一个非常酷的漏洞。是的，Altong作为漏洞确实很酷。我们实际上会在学期后期讨论这个。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_19.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_19.png)'
- en: So back to what the OS is supposed to do。 So we have all of this complexity。
    And really。 the OS is out there trying to tame the underlying hardware and provide
    a clean virtual machine。 abstraction。 And so here's the hardware underneath。 We
    have the physical machine interfaces， which。 are， you know， they're what they're
    are， their buses， their interfaces to disks。 We have an。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到操作系统应该做什么。我们有这么多复杂性。实际上，操作系统在努力驯服底层硬件，并提供一个干净的虚拟机抽象。所以这里是底层的硬件。我们有物理机器接口，它们就是它们的样子，它们的总线，它们与磁盘的接口。我们有一个。
- en: operating system on top of it， which then turns all of these imperfect physical
    interfaces。 or limited physical interfaces into a nice clean programming abstraction
    so that the。 abstract machine interface up top can be used by applications。 Okay。
    And I gave you the。 simplest one to think about is this this illusion of infinite
    memory。 So maybe you only have。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统在其上运行，然后将所有这些不完美的物理接口或有限的物理接口转化为一个干净的编程抽象，以便上面的抽象机器接口可以被应用程序使用。好的。我给你最简单的思考方式就是这种无限内存的错觉。所以也许你只有。
- en: 16 gigabytes of memory on your laptop， but the operating system gives you the
    illusion。 that's that there's a lot more memory。 And it does that through a paging
    and various other。 virtual memory techniques， which we will talk about。 But that's
    the function of the operating。 system is provide this virtual or abstract machine
    interface that's more perfect than， the hardware。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你的笔记本上有16GB内存，但操作系统给你一种错觉，认为内存远远更多。它通过分页和各种其他虚拟内存技术来实现这一点，我们稍后会讨论。但操作系统的功能是提供这个虚拟或抽象的机器接口，它比硬件更完美。
- en: Okay。 So the processor underlying becomes a clean thread。 The memory underlying。
    becomes a clean address space。 The disks at SSDs， which are just block based storage
    become， files。 Okay。 Networks lead to sockets， which give you sort of the ability
    to have a stream。 that's sent perfectly from one part of the world to another
    machines become processes。 Okay。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么底层的处理器变成了一个干净的线程。底层的内存变成了一个干净的地址空间。磁盘和SSD，这些只是基于块的存储，变成了文件。好的。网络通向套接字，套接字给你提供了一种能力，能够完美地从世界的一部分发送流到另一台机器，机器变成了进程。好的。
- en: And so all sorts of interesting things here， but this is basically the OS as
    an illusionist。 to remove the software hardware quirks and give us a better， a
    better abstraction。 Okay。 And you pick any OS area and there are many of them
    and we're going to have an interesting。 sample this term like file systems， virtual
    memory， networking， scheduling。 And you can。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有各种有趣的东西，但基本上这是操作系统作为一名魔术师，去除软件硬件的怪癖，给我们一个更好的抽象。好的。你可以选择任何操作系统领域，我们有很多领域，我们将在本学期有一个有趣的示例，比如文件系统、虚拟内存、网络、调度等等。
- en: ask the question of what's the hardware interface that we need to handle。 That's
    the physical。 reality。 And what's the software interface we want to provide？ And
    that's the nicer abstraction。 And so we will we will play with that hardware interface
    versus natural abstraction idea throughout。 the term。 Okay。 So today we have four
    fundamental OS concepts， which we want to get across just。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提出的问题是，我们需要处理的硬件接口是什么？那是物理现实。而我们希望提供的软件接口是什么？那是更为优雅的抽象。因此，我们将在整个学期中探索硬件接口与自然抽象之间的关系。好的。今天我们有四个基本的操作系统概念，我们希望传达这些概念。
- en: to dive in and start going。 Okay。 One of them is this idea of a thread。 And
    a thread is。 a virtual execution context fully describes program state of an executing
    program。 It's。 got the counter。 It's got registers。 It's got execution flags。
    It's got stack。 Okay。 And。 this thread， however， is a virtual entity as you'll
    see in a bit。 This is not necessarily。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨并开始行动。好的。第一个概念是线程。线程是一个虚拟执行上下文，完整描述了正在执行程序的程序状态。它有计数器，有寄存器，有执行标志，还有栈。好的。然而，这个线程是一个虚拟实体，稍后你会看到，这不一定是。
- en: running on a CPU at all times and it's not even running necessarily on the same
    CPU。 So this thread is an entity of itself。 Okay。 And hopefully we'll get to where
    we'll be thinking。 in terms of threads rather than CPUs。 And we have some interesting
    discussion on on。 the Piazza actually after lecture one about that idea。 We'll
    get some there of that today。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它始终在 CPU 上运行，并且不一定运行在同一个 CPU 上。因此，线程本身是一个独立的实体。好的。希望我们能达到一个阶段，我们会从线程而非 CPU 的角度来思考。实际上，在第一次讲座之后，我们在
    Piazza 上有过一些关于这个概念的有趣讨论。今天我们也会进一步讨论这个话题。
- en: So another idea which we're going to want to talk about is the address space
    with or。 without translation。 And an address space essentially the set of memory
    addresses that。 the program sees for reading and writing。 And it may actually
    be distinct from the physical。 machine。 So once again， the address space is a
    virtualized idea。 And a third thing is。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一个我们想讨论的概念是带有或不带有翻译的地址空间。地址空间本质上是程序在读写时所看到的内存地址集。它实际上可能与物理机器是不同的。因此，地址空间是一个虚拟化的概念。第三个概念是。
- en: now going to be a process。 And so a process is a combination of a protected
    address space。 and one or more threads。 Okay。 And so a process is really this
    executing instance of a program。 in its own protected environment with multiple
    potentially things running。 Okay。 And then。 finally we're going to introduce some
    hardware。 And this hardware idea is dual mode operation。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将变成一个进程。所以一个进程是一个受保护的地址空间和一个或多个线程的组合。好的。因此，进程实际上是程序的一个执行实例，处于它自己的受保护环境中，可能有多个任务在运行。好的。最后，我们将引入一些硬件。这个硬件的概念是双模式操作。
- en: which leads to protection and that dual mode operation is really that there
    are certain。 things that can only be done by the system。 Okay。 And so the way
    we distinguish that running。 in the system versus not is going to be a bit at
    least possibly more bits but at least。 one bit in the hardware that says whether
    we're in system mode or user mode。 Okay。 And。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带来了保护问题，而双模式操作的真正含义是，某些事情只能由系统来完成。好的。我们区分系统模式和非系统模式的方式，将会是硬件中至少一个位，可能更多的位，用来指示我们是处于系统模式还是用户模式。好的。
- en: we're going to show you more about how that works。 But the simple idea there
    is that when。 you're in system mode， the hardware will allow more access to things
    than when you're。 in user mode and that will lead us to be able to provide a nice
    clean virtual abstraction。 We call that dual mode because there's two modes there。
    Okay。 Now， so let's look at the。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示更多关于它是如何工作的。但简单的想法是，当你处于系统模式时，硬件允许你比在用户模式下有更多的访问权限，这将使我们能够提供一个干净、清晰的虚拟抽象。我们称之为双模式，因为有两种模式。好的。那么，现在让我们来看看。
- en: bottom line。 What's the bottom line？ Well， the OS is helping us run programs。
    That's。 our important aspect here， right？ And so here's， you know， here's Joe。
    He's typing away。 And。 he comes up with a program。 He's going to type a bunch
    of stuff into his editor。 And。 then the compiler is actually going to produce
    a binary version of these instructions that。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是什么？结论是什么？操作系统帮助我们运行程序。这是我们在这里要关注的重要方面，对吧？所以这是 Joe，他正在打字。他写出了一个程序，他将一些内容输入到编辑器中。然后编译器实际上会生成这些指令的二进制版本。
- en: is going to be executable on a CPU。 And it's going to have data。 It's going
    to have instructions。 in binary mode。 And typically it's in a file called a。out，
    which is the result of the compiler。 And potentially the linker。 Okay。 And once
    that exists and that might sit on your sit on， your disk。 then when we want to
    execute it， we take this executable and it gets loaded， into memory。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将会在 CPU 上执行。它将包含数据。它将包含指令。以二进制模式。通常，它存储在一个名为 a.out 的文件中，这是编译器的结果，可能还有链接器的结果。好的。一旦这个文件存在，它可能会保存在你的磁盘上，然后当我们想要执行它时，我们就会取出这个可执行文件，将它加载到内存中。
- en: And that's the point at which it becomes executing。 Okay。 So a program is。 the
    potential for execution。 Once it gets loaded into a process， it becomes an executing，
    process。 Okay。 And we can have many instances of the same executable running at
    the same。 time in different processes。 And you'll see that as we go along as well。
    But if you notice， here。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是程序开始执行的时刻。好的。所以，程序是潜在的可执行文件。一旦它加载到进程中，就成为一个正在执行的进程。好的。我们可以在不同的进程中同时运行同一个可执行文件的多个实例。你会在接下来的过程中看到这一点。但是如果你注意到，
- en: here's a typical address space for a process where the address space is kind
    of， remember。 I said it was all the addresses that can be accessed。 And it's sort
    of from， zero up to FFFF。 Typically， there are instructions at the low part of
    memory， the low addresses。 and then data on top of that， heap， etc。 And then at
    the top， there's the OS space， which。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个进程的典型地址空间，地址空间大致上，记得我说过，它包括所有可以访问的地址。通常，从零开始，到 FFFF。低地址部分通常存储指令，数据位于其上面，堆等等。然后在顶部，是操作系统空间。
- en: is protected。 And then we grow down from there for our stack。 Now， there's a
    question about。 where the linker is。 I haven't shown you here， but this， think
    of this as a combination compiling。 and linking to produce the final executable。
    And the linker is really taking individual。 things that you compiled plus some
    libraries and putting them together into a single entity。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是受保护的。然后，我们从那里向下扩展以创建栈。现在，有一个问题是，链接器在哪里。我没有在这里展示，但可以把它想象成是一个结合了编译和链接的过程，生成最终的可执行文件。链接器实际上是在将你编译的各个部分和一些库文件结合起来，形成一个整体。
- en: And we'll see a lot more of that as we go on。 All right。 So once we've loaded
    things。 into memory and we're in a process， we create the stack and the heap。
    So the stack is the。 grows down to give us the ability to have recursive processes。
    And the heap grows up。 for allocation like memory。 And so as a result， we will
    basically have a completely executing。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在接下来的过程中看到更多的内容。好的。一旦我们将数据加载到内存中，并且处于进程中，我们就创建栈和堆。栈是向下增长的，允许我们进行递归调用。堆则是向上增长，用于分配内存。因此，最终我们将拥有一个完全执行的进程。
- en: process。 Okay。 And how does it become executing？ Well， we load the program counter。
    And we。 are in the processor to point at a starting instruction in the process。
    And then we tell。 the processor to go。 And at that point， it will start executing。
    And we typically don't。 do this in system mode。 We make sure that at the time
    we say go， it's in user mode。 And。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。好的。那么它是如何开始执行的呢？我们加载程序计数器。然后我们让处理器指向进程中的一个起始指令。接着我们告诉处理器开始执行。从那时起，它就开始执行了。通常，我们不会在系统模式下进行这个操作。我们确保在发出开始执行指令时，它是在用户模式下。
- en: as a result， this will be a nice protected entity。 And this notion of when we're
    in user， mode。 when we're in system mode， just don't worry about the exact details
    because we'll。 give you more and more details as we go on。 We're trying to get
    the high level idea here。 So are there questions？ So how much memory is allocated
    per process？ It's a good question。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，这将是一个受保护的实体。当我们处于用户模式时，当我们处于系统模式时，不必太担心细节，因为我们会随着进度给出更多细节。我们现在要传达的是一个高层次的概念。那么，有问题吗？每个进程分配多少内存？这是一个好问题。
- en: So the answer is the bare minimum on most and most good operating systems only
    allocates。 as little as it needs。 So it basically allocates instructions in data。
    There's typically no。 actual DRAM allocated for heap or stack。 But the address
    space is here。 Okay。 So that's。 where you got to start thinking about the virtual
    versus the physical。 So physically。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以答案是，大多数操作系统会尽量只分配最基本的内存需求。它基本上只分配指令和数据。通常不会为堆或栈分配实际的 DRAM。但地址空间是存在的。好的。所以这里，你需要开始考虑虚拟地址与物理地址的区别。物理上，
- en: we don't get much memory when we start up。 Virtually， we have all of these addresses。
    And what will happen is as the program tries to use parts of the address space
    that aren't。 backed by real memory， they'll be trapped into the operating system
    and the operating。 system will allocate some more memory for it and then return
    to the user。 And so therefore。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动时不会获得太多内存。虚拟上，我们有所有这些地址。接下来会发生的是，当程序尝试使用未映射到实际内存的地址空间部分时，它们会被操作系统捕获，操作系统会为其分配更多内存，然后返回给用户。因此。
- en: with a modern operating system， we can start by giving processes as little as
    we need to。 start with。 And then it'll automatically adapt as the program starts
    running。 All right。 And of course， the OS once everything is running will provide
    services through the notion of。 system calls， which we'll talk about a little
    bit later。 Okay。 Good。 Any other questions？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代操作系统，我们可以从给定进程最小需要的资源开始。然后，当程序开始运行时，它会自动适应。好的。当然，一旦一切都运行起来，操作系统将通过系统调用提供服务，我们稍后会讨论这些。好的。还有其他问题吗？
- en: And Anthony is actually giving some good details about linkage there。 So there's
    static。 linking and dynamic linking。 We'll talk about those also later。 Okay。
    So now let's pull back。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 安东尼实际上提供了一些关于链接的好细节。所以有静态链接和动态链接。我们稍后也会讨论这些。好的。那么现在让我们后退一点。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_21.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_21.png)'
- en: out of the depth of your memory from 61 C。 So if you remember what's inside
    a processor。 So system calls， by the way， are that transfer of control into the
    kernel， a controlled transfer。 And again， we will talk more about those as we
    go on。 So if you look here， we typically。 have a program counter， okay， which
    is a register inside the processor。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从你在61 C课程中学到的内存深度来看。如果你记得处理器内部的内容。顺便说一下，系统调用是将控制权转移到内核的过程，是一种受控的转移。我们将继续深入讨论这些内容。所以，如果你看到这里，我们通常会有一个程序计数器，它是处理器内的一个寄存器。
- en: And then we have instructions， in memory， which is in the address space of the
    process and data as well。 And the program， counter points at the next instruction
    to execute。 And it's going to be up to the actual processor， to pull that instruction
    out of memory and decode it and decide what to do with it。 Okay。 And so for instance，
    once we've fetched the instruction， then it'll be decoded。 And that。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在内存中有指令，这些指令位于进程的地址空间中，还有数据。程序计数器指向下一条待执行的指令。接下来，实际的处理器会从内存中提取该指令，解码它，并决定如何处理。好的。例如，一旦我们获取了指令，它将被解码。然后。
- en: decoded instruction will then work on the data path that might pull things out
    of registers。 and it tells the ALU to do a multiply or whatever。 And the results
    might be stored into memory。 or memory might be pulled out， data might be pulled
    out of memory。 And then we go and execute。 the next instruction。 Okay。 And so
    this is the continuous loop of fetch， decode， execute。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后的指令将会在数据路径上工作，可能会从寄存器中提取数据，并指示算术逻辑单元（ALU）进行乘法运算或其他操作。结果可能会被存储到内存中，或者从内存中提取数据。然后我们执行下一条指令。好的。所以这就是取指、解码、执行的连续循环。
- en: memory right back。 Okay。 And this hopefully will remind you a little bit of
    61 C。 There。 is a question here about what happens if there's a memory safety
    violation in a program。 So。 we're going to need to get much more detail about
    exactly what that means。 But I showed。 you in a couple of previous slides that
    idea where the green process tried to access memory。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后返回内存。好的。希望这能提醒你一些61 C课程的内容。这里有个问题是，如果程序中发生内存安全违规会怎样。那么，我们需要更详细地了解这意味着什么。但我在前几张幻灯片中展示了，绿色进程试图访问内存的那个概念。
- en: of the brown process。 And that memory access violation was flagged with a segmentation
    fault。 And the green process was dumped。 Okay。 And that'll be one of many responses
    that we can， get。 So。 you know， and basically the processor is going to walk the
    PC through a series of。 instructions as the execution occurs。 And that's how we
    get a program to run。 Okay。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在棕色进程中。并且该内存访问违规被标记为段错误（segmentation fault）。然后绿色进程被转储。好吧。这将是我们可以得到的许多响应之一。所以，你知道，本质上，处理器将在执行过程中通过一系列的指令来推进程序计数器（PC）。这就是我们让程序运行的方式。好的。
- en: Now the first concept here that I mentioned was the thread of control。 And a
    thread is。 really a single unique execution context consisting of a program counter
    registers， execution。 flags， a stack， memory state。 Okay。 And you need to think
    of this as a virtual version， of this。 So the 61 C idea was there's this processor
    thing and it's executing instructions。 Okay。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提到的第一个概念是控制线程。线程实际上是一个唯一的执行上下文，包含程序计数器、寄存器、执行标志、栈和内存状态。好的，你需要把它当作这个的虚拟版本来看待。所以61C的想法是，处理器正在执行指令。好的。
- en: But excuse me， just having that processor thing executing instructions is too
    low level。 to build a modern environment on top of it。 And so instead we're going
    to virtualize that。 idea with a thread。 So a thread is something that has its
    program counter。 So it knows。 where is next instructions coming from。 But because
    it's virtual， it could actually be。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，抱歉，仅仅让那个处理器执行指令的做法太低级，无法在其上构建现代环境。所以，我们将用线程来虚拟化这个概念。线程是有程序计数器的东西，因此它知道下一条指令来自哪里。但由于它是虚拟的，实际上它可以是。
- en: unloaded from the physical processor for a little while and then loaded back
    and start。 executing again。 And so the thread maintains its identity even when
    it doesn't have the。 view of the CPU。 And that's going to be helpful for us。 Okay。
    And a thread is basically executing。 on a processor or core when it's resident。
    Okay。 When it's in the processor registers。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理处理器卸载一会儿，然后重新加载并重新开始执行。所以即使线程没有访问CPU，它也能保持自己的身份。这对我们来说是有帮助的。好的。线程本质上是在处理器或核心上执行的，当它常驻时。好的，当它在处理器寄存器中。
- en: Now by the way， let me clear one thing up here for the first several weeks。
    We are going。 to be talking about processors or cores independently。 And we're
    going to be thinking about machines， with exactly one core or processor for now。
    Okay。 So don't worry about multi core。 Okay。 We want to understand single core
    first。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，让我澄清一下，接下来的几周里，我们将独立地讨论处理器或核心。我们现在会考虑每台机器只有一个核心或处理器。好的，所以不要担心多核。好的，我们首先要理解单核。
- en: And so I'm going to use the word processor。 I might， use the word core。 These
    are going to be essentially interchangeable in the next several weeks。 Okay。 But
    anyway。 the thread is actually executing when it's running in the processor registers。
    So if you look back here， you could say， well， this could be thought of as a thread
    that's。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将使用“处理器”这个词，可能也会使用“核心”这个词。接下来的几周里，这两个词基本可以互换使用。好的。无论如何，线程实际上是在处理器寄存器中执行的。所以，如果你回头看一下，你可以说，嗯，这可以被看作是一个处于寄存器中的线程，或者有指针指向内存中结果要存储的位置。
- en: running right now because it's program counters in the real program counter
    of the processor。 Okay。 And what resident really means here is the registers hold
    all the state， the root。 state or context of the thread。 The registers have the
    program counter loaded。 It's currently。 executing instructions from there。 The
    program counter points at the next instruction in memory。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正在运行，因为它的程序计数器位于处理器的真实程序计数器中。好的。那么这里“常驻”真正的意思是寄存器保存所有状态，线程的根状态或上下文。寄存器中加载了程序计数器，程序目前正在从那里执行指令。程序计数器指向内存中下一个指令。
- en: All the instructions are stored in memory so that as the processor or core starts
    executing。 and pulling instructions， it can pull them out of memory。 Okay。 So
    that's those instructions。 we want actually are in memory。 And it includes intermediate
    values for ongoing computations。 in the actual registers。 So we might have added
    two things together and the result is。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的指令都存储在内存中，这样处理器或核心开始执行时，就可以从内存中取出指令。好的。所以我们真正需要的指令就在内存中。它还包括正在计算中的中间值，这些值保存在实际的寄存器中。比如我们可能加了两个数，它们的结果是。
- en: in a register or there are pointers to places in memory where the results are
    going。 And。 the stack pointer in the physical hardware is actually holding the
    address of the top。 of stack for the thread， which is in memory。 And everything
    else is in memory。 So this is。 an executing thread。 And so if you want to think
    about 61C again for a moment， an executing。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，物理硬件中的栈指针实际上保存着线程栈顶的地址，这个栈是在内存中的。其他的一切都在内存中。所以这是一个正在执行的线程。如果你想再想一想61C，正在执行的线程。
- en: thread or a loaded thread or a resident thread is an example of something running
    like you。 thought of in 61C。 Okay。 A thread is suspended or not executing when。
    its state isn't in the processor。 Okay。 And so this is like if you took the thing
    that。 from 61C and you just unloaded it all and put it aside in memory somewhere
    and what we'll。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 线程或加载线程或驻留线程是一个运行中的示例，就像你在61C中思考的那样。好吧，当线程被挂起或不执行时，它的状态不在处理器中。所以，这就像是你把61C中的东西完全卸载并放到某个内存位置一样，我们将。
- en: call a thread control block， it's still a thread。 It's just not running。 Okay。
    And at， that point。 something else is running。 Okay。 So the processor state is
    pointing somewhere。 else at a different thread。 Okay。 Is that clear to everybody
    here？ Okay。 So again， back。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为线程控制块，它依然是一个线程，只不过它没有在运行。好的。此时，其他东西正在运行。所以处理器状态指向了另一个线程。明白吗？好的。那么，我们再回到。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_23.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_23.png)'
- en: to your 61C。 So we are going to keep this virtual machine idea in our brain。
    I just wanted。 to show this other slide of here's a processor or a core。 We're
    going to do the fetch execute， loop。 We got a bunch of registers loaded。 The execution
    sequence fetches the instruction， at the PC。 decodes it， executes it， writes the
    results back and goes to the next instruction。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 向你的61C学习。我们将继续保持虚拟机的概念。我只是想展示这个图，看看这是一个处理器或核心。我们将执行取指-执行循环。我们有一堆寄存器加载好了。执行序列会取出程序计数器指向的指令，解码它，执行它，写回结果，然后跳到下一条指令。
- en: So for end repeat， this is a wash and repeat kind of scenario。 So for instance，
    if the program。 counter here is pointing at instruction zero， we'll execute it，
    then we'll go on to instruction。 one， we'll go on to instruction two， three， four。
    Okay。 And keep in mind， so there's a。 question here in this class is core， the
    processor or execution unit within the processor。 You。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，结束并重复，这就是一个洗净再来、循环往复的场景。例如，如果程序计数器指向指令零，我们将执行它，然后跳到指令一，继续指令二、三、四。好的。请记住，在这门课中有一个问题是，核心、处理器或执行单元是否是同一个东西。
- en: know， I know Anthony gave one answer to that。 Let's not be too confused about
    that for now。 So processor could be a bunch of cores and that's sometimes an entity
    the way they work， at it。 We're going to talk about just a processor is executing
    only one core and only having， one core。 So there's no confusion there for now。
    Okay。 So just think whenever I say core， processor。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了，我知道安东尼对此给出了一个答案。现在暂时不要对这个感到困惑。处理器可以是多个核心的集合，有时候它们的工作方式就像一个实体。我们现在讨论的只是一个处理器，它只执行一个核心，并且只有一个核心。所以暂时不要对此感到困惑。好吧。所以每当我提到核心时，请理解为处理器。
- en: I'm thinking about something with exactly one execution pipeline in it。 Okay。
    And the other thing I wanted to say here， and don't we're getting in depth here
    about。 suspending here and I don't want to quite get there yet。 Anthony can answer
    that if he likes。 But let's hold that question there for a couple of weeks。 Okay，
    make a lot more sense。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我在考虑的是一个仅包含一个执行管道的东西。好吧。另一个我想说的事情是，别急着深入探讨这里的挂起问题，等一会儿再讨论。如果安东尼愿意，他可以回答。但是我们先把这个问题搁置一两周。好的，那样会更有意义。
- en: So here's our execution sequence。 The PC is busy executing。 There's a set of
    registers。 that represent the thread and are loaded at any given time。 And this
    is the view， for， instance。 from 61 C， which is like a simple risk processor where
    there's a set of registers。 that are very straightforward and there's many of
    them。 If you look， that's kind of like。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的执行序列。程序计数器正在忙于执行。有一组寄存器代表线程，并且在任何给定时刻都已加载。这就是比如61C的视图，它像一个简单的RISC处理器，拥有一组非常直接的寄存器，而且它们非常多。如果你看，那有点像。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_25.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_25.png)'
- en: risk five。 Okay。 So we have a bunch of registers， some of which are the next
    program counter。 some of which are the stack pointer and so on。 And the set of
    instructions that can be。 run are simple。 There are ads and subtracts and so on。
    This class， we're going to bite。 off the complexity of a modern machine that's
    more likely to be in your laptop。 Okay。 Like， an x86。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 风险五。好的。我们有一堆寄存器，其中一些是下一个程序计数器，还有一些是堆栈指针等等。可以执行的指令集很简单。有加法、减法等等。在这门课上，我们将突破现代计算机的复杂性，这种计算机更可能存在于你的笔记本电脑中。好吧，像是x86架构。
- en: And so if you notice， some interesting things about the x86 is it's got a lot
    more。 different types of registers and a lot fewer of them。 Okay。 So there are
    registers for segments。 There are registers for control and tags and so on。 There's
    a bunch of other registers。 And so we're going to we're going to look at some
    of these going on because the environment。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你注意到，x86 架构有很多不同类型的寄存器，但它们的数量比较少。好的，这里有段寄存器用于段操作，还有一些寄存器用于控制和标记等等。还有许多其他的寄存器。所以我们将看看这些寄存器的作用，因为这个环境
- en: in which the PintoOS operating system that we're using in this class operates
    is an x86。 environment。 Okay。 And section is going to cover the architecture a
    lot more detail。 Okay。 And I will too as time goes on。 But what I want to focus
    on right now， so let's pull。 everybody's mind back to this， is how can we possibly
    have a single core or a single。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个课程中使用的 PintoOS 操作系统运行在 x86 环境下。好的，接下来的部分会更详细地介绍架构。我也会在后续深入讲解。但我现在要重点讲的是，大家把注意力集中在这里：我们如何可能只有一个核心或一个。
- en: processor but have many threads that look like they're running at the same time。
    Okay。 And we're going to get this view of a bunch of virtual CPUs or threads all
    sharing the， same memory。 And this is going to be the programmer's view of a process。
    Okay。 So assume， a single core。 Now。 the question is how do we provide this illusion？
    Well， we multiplex。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器有许多线程，看起来像是同时运行的。好的，我们将得到一组虚拟 CPU 或线程的视图，所有线程共享相同的内存。这就是程序员对进程的视图。所以假设只有一个核心。现在问题是，我们如何提供这种错觉？我们通过多路复用来实现。
- en: And so think of threads as virtual cores。 And here's time moving to the right。
    And what。 we're going to do is we're going to run virtual CPU one for a little
    while。 And then number。 two for a little while， number three for a little while。
    And then we're going to go back。 to number one and so on。 And we're going to basically
    load the contents of a thread。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以可以将线程看作虚拟核心。这里时间向右移动。接下来我们要做的是，我们将先运行虚拟 CPU 一段时间，然后是第二个虚拟 CPU 一段时间，再是第三个虚拟
    CPU 一段时间。然后我们会回到第一个虚拟 CPU，依此类推。基本上，我们将把线程的内容加载到处理器中。
- en: into a processor。 We're going to run it for a little while， then we're going
    to unload， it。 We're going to load the next one。 And we're just going to keep
    doing this over and over， again。 And if we do this with a fine enough granularity，
    then essentially it's going to。 appear that these are all running simultaneously，
    even though only one of them is actually running。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会运行一段时间，然后卸载它。接着加载下一个线程。我们将不断地重复这个过程。如果我们用足够精细的粒度来进行操作，那么从表面上看，所有线程似乎是同时运行的，尽管实际上只有一个线程在处理器上运行。
- en: at any given time。 Okay。 So the contents of a virtual core here is what we've
    been calling。 a thread。 Program counter， stack pointer， registers， etc。 Where
    is the thread？ Well， it's。 on the real physical core， like here during magenta
    time， CPU one or thread one is actually。 loaded in the physical core or saved
    in a chunk of memory when it's not running called。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一个虚拟核心的内容就是我们一直在说的一个线程。程序计数器、堆栈指针、寄存器等。线程在哪里？它实际上是在真实的物理核心上，就像在品红色时间中，CPU
    一或线程一实际上被加载到物理核心上，或者在不运行时保存到一块内存中，这块内存叫做。
- en: the thread control block。 Okay。 And it's going to be up to the operating system
    that's doing。 the scheduling to be swapping these guys in and out over and over
    again in order to give。 us that illusion。 Okay。 And I'm going to just， I'm repeating
    this multiple times just to。 make sure we're all on the same page， because this
    is fairly simple。 But if you don't quite。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 线程控制块。好的，操作系统负责调度，并负责反复将这些线程交换进出，以便给我们这种错觉。好的，我会重复多次这个过程，只是为了确保大家都在同一页面，因为这个概念比较简单。如果你还不太明白。
- en: catch what's going on here， then what we do afterwards is going to be confusing。
    So any。 other questions？ So is good。 The great question in the slack here is the
    execution time for。 each thread the same。 And the answer is， doesn't have to be。
    In fact， we're going to have a。 whole unit on schedulers， where we're going to
    vary the amount of time a thread gets based。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有掌握这里发生的事情，那么后面的内容会显得很混乱。那么，其他问题呢？问题是好的。这里在 Slack 中的一个大问题是：每个线程的执行时间是否相同？答案是，不必相同。事实上，我们会有一个专门的单元讨论调度程序，在那里我们会根据不同的情况改变线程的时间分配。
- en: on priorities， or we're going to vary it based on real time requirements。 So
    the simplest。 thing you could do is just give every thread the same amount of
    time。 But that's absolutely。 not required。 And just to give you a good idea why
    that might not even work is it's possible。 that CPU one runs for a little while，
    and then it has to talk to a disk or network， which。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基于优先级，或者我们将根据实时要求进行调整。所以你能做的最简单的事情就是给每个线程相同的时间。但这绝对不是必须的。为了让你更清楚为什么这可能行不通，假设
    CPU 一运行了一段时间，然后它必须与磁盘或网络进行通信。
- en: is going to take， you know， milliseconds or seconds。 It can't run。 And so it
    makes no。 sense to waste the CPU waiting for all that stuff externally。 So that
    will be a good reason。 to switch to another one。 Okay。 And what does it mean for
    the CPU to be idle？ What it means。 is there are no threads that are runnable right
    now because they're all waiting for， idle。 Okay。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要几毫秒或几秒钟。它不能运行。所以，让 CPU 等待这些外部内容毫无意义。因此，切换到另一个线程是一个很好的理由。好吧。那么，CPU 空闲意味着什么呢？它的意思是，目前没有任何线程可运行，因为它们都在等待，空闲。好吧。
- en: that would be a good example of an idle CPU。 Okay， does that make sense？ Now，
    I'm assuming here。 by the way， by this slide that we have three runnable threads。
    And so that's why I'm showing three of them alternating。 Now， so this illusion，
    let's continue。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个很好的空闲 CPU 示例。好吧，理解了吗？现在，顺便提一下，我假设在这张幻灯片中我们有三个可运行的线程。因此，我才会显示它们交替运行。现在，让我们继续探讨这个幻觉。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_27.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_27.png)'
- en: this for a moment。 So consider， for instance， at time one， virtual CPU one's
    on the real core。 CPU two's back in memory at time two， virtual CPU one is on
    the core is in memory and CPU。 two is on in the core， etc。 Okay。 So what happens
    to go from T one to T two？ Well， if you think。 about it， something had to take
    over and unload thread one and load thread two。 What is that？ Well。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停一下。那么，考虑一下，例如，在时刻一，虚拟 CPU 一在实际核心上。CPU 二在时刻二回到内存中，虚拟 CPU 一在核心上，CPU 二在内存中，等等。好吧。那么，从
    T 一到 T 二发生了什么？嗯，如果你思考一下，肯定有某些东西接管并卸载了线程一，然后加载了线程二。这是什么呢？嗯。
- en: it's the operating system。 And so between thread one and thread two at this
    boundary。 the OS ran somehow。 And it saved the PC stack pointers， all the stuff
    of the CPU is thread。 out to memory and then loaded stuff from CPU two's thread
    back into memory。 All right。 And。 you might， if you're thinking about this carefully，
    start asking yourself， well， how the heck。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 是操作系统。所以，在线程一和线程二之间的这个边界，操作系统以某种方式运行了。它保存了程序计数器、堆栈指针，以及所有的 CPU 线程内容到内存中，然后将
    CPU 二线程的内容从内存加载回 CPU。好吧。并且，如果你仔细思考，可能会问自己，嗯，怎么可能。
- en: did the OS get control because the user's running here， right？ Suppose that
    CPU one's。 doing my favorite thing of all time， which is it's busy computing the
    last digit of pi。 then it's not going to give the OS any second give it the time
    of day because it's working。 on that last digit。 And so really， what has to happen
    is some intervention here。 Okay。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统是如何获得控制的，因为用户正在运行这里，对吧？假设 CPU 一正在做我最喜欢的事情，也就是忙着计算 pi 的最后一位数字。那么它不会把任何时间分给操作系统，因为它正在计算最后一位数字。所以，实际上，必须在这里进行某种干预。好吧。
- en: And we'll get， we'll learn a lot more about that。 But the simplest intervention
    is a timer。 goes off into the OS。 And the OS then grabs control away from T one
    and gives it to T two。 Okay。 And by the way， as an important part of 162， you
    have to know why computing the。 last digit of pi is important。 Okay。 And that
    was basically to remove the malicious entity。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学到更多关于这一点的内容。但最简单的干预是定时器触发后进入操作系统。然后操作系统从 T 一 中夺取控制并交给 T 二。好吧。顺便说一下，作为 162
    课程的重要部分，你必须知道为什么计算 pi 的最后一位数字很重要。好吧。这基本上是为了移除恶意实体。
- en: from the enterprise computer back in the original days。 The only way that Spock
    could get the。 computer back was he started all the memory banks working on computing
    the last digit。 of pi and that saved the day。 So you guys need to remember that。
    That's your history， for today。 All right。 Now， does the timer have its own thread
    or process？ That's a good question。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 来自早期企业计算机的图像。唯一让斯波克能够恢复计算机的方法是，他让所有的内存银行开始计算 pi 的最后一位数字，这才挽救了局面。所以你们需要记住这一点。这就是今天的历史。好吧。现在，定时器是否有自己的线程或进程？这是个好问题。
- en: And the answer is it doesn't have to。 It only has to have something that takes
    over to run。 when the timer goes off。 So most of the time， it may not be running
    at all。 And it's probably。 when it starts running， it'll be running in an interrupt
    context， not necessarily a full-blown。 thread。 And we will get into that in a
    lot more detail。 Okay。 So keep that answer in the。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，它不需要。它只需要有某些东西在计时器触发时接管运行。所以大多数时候，它可能根本不在运行。当它开始运行时，它可能是在一个中断上下文中运行，并不一定是一个完整的线程。我们会详细讨论这个问题。好的。所以保持这个答案在心中。
- en: back of your brain and ask me more in a little bit， well， not today， but a couple
    of lectures。 Okay。 So what triggered this switch？ So I just talked about a timer，
    but there's other things。 like CPU one could have voluntarily yielded the CPU。
    And a great example is a system call。 Hi。 I want to do IO。 Okay。 I'm yielding
    the CPU because the IO is going to go on and the， timer。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 保留在你脑海中的问题，稍后再问我，好吧，不是今天，可能在几节课后。好的。那么是什么触发了这个切换呢？我刚才讲过计时器，但还有其他原因。例如，CPU 之一可能自愿放弃了
    CPU。一个很好的例子是系统调用。你好，我想做 I/O。好的，我放弃了 CPU，因为 I/O 将进行，而计时器。
- en: not the timer， the scheduler then takes over and loads CPU too while that IO
    is going， on。 So that's a voluntary， that's IO。 There's also the ability to say，
    okay， give somebody。 else a chance。 Other things we'll discuss。 Okay。 But we have
    to have some way to take over， control。 Now， the question is， can I repeat how
    the OS takes back control？ And if you look。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不是计时器，调度程序接管了控制，并在 I/O 操作进行时也会加载 CPU。所以这是一个自愿的过程，这是 I/O。也可以选择给其他任务一个机会。其他我们稍后讨论的内容。好的。但我们必须有某种方式来接管控制权。现在，问题是，我能否重复操作系统如何重新获取控制权？如果你看一下规范。
- en: down here at the very last bullet， it gives you all the ways the OS can take
    control。 The。 simplest for you to remember from today is a timer goes off inside
    the OS and it grabs。 control away from thread one。 Okay。 And because the OS is
    running at an interrupt level and。 the thread is running at user level， then the
    answer is no， the OS is able to steal it away。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的最后一条内容，它为你列出了操作系统如何控制的所有方式。今天最简单记住的一点是，操作系统内的计时器触发后，会从线程一中抢夺控制权。好的。因为操作系统是在中断级别运行，而线程是在用户级别运行，所以答案是：不行，操作系统能够抢夺它的控制权。
- en: and the thread one can't prevent that from happening。 And that's important。
    So multiple。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 线程一无法阻止这种情况发生。这很重要。所以多个。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_29.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_29.png)'
- en: threads of control now， let's talk more about that。 So we call that typically
    multi programming。 And if you look， the， here we have a bunch of processes， for
    instance， running on top， of the OS。 And those processes each have their own little
    chunk of the DRAM。 And when they're， running。 they need to have the illusion that
    they have 100% of the memory。 And so we're。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在谈谈控制线程的问题。通常我们称之为多任务处理。如果你看一下这里，我们有一堆进程在操作系统上运行。每个进程都有自己的一小块内存。当它们运行时，需要有一种假象，认为它们拥有
    100% 的内存。所以我们。
- en: going to have to do something to this DRAM to give that illusion that， for instance，
    when。 the green processor is running， it has all of the memory because clearly
    there are lots。 of different processes in memory。 Okay。 And good question here
    in the chat， which is basically。 since the threads like a virtual CPU， why do
    modern CPUs have a specific number of threads。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 必须对 DRAM 做一些处理，以产生那种假象。例如，当绿色处理器运行时，它拥有全部内存，因为显然内存中有许多不同的进程。好的。聊天室中的一个好问题基本上是：既然线程就像虚拟
    CPU，为什么现代 CPU 会有特定数量的线程？
- en: in the spec。 And the answer is that the number of threads quoted in a CPU spec
    are the number。 of hardware threads。 And that is the number of simultaneous things
    that we can， simultaneous。 threads of control that can be running at the same
    time， literally in the hardware。 Okay。 So again。 for now， let's not worry about
    the hardware threads or multiple cores and we'll， get back to that。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，CPU 规格中列出的线程数是硬件线程的数量。这是我们能够同时运行的控制线程的数量，实际上是在硬件层面上。好的。那么现在，我们暂时不考虑硬件线程或多个核心，我们稍后会回到这一点。
- en: I promise。 Okay。 Now， if you look， the thread control block holds the。 contents
    of the registers when the thread's not running， what other information？ Well。
    it's going to have things like the registers， it's going to have things like the
    program， counter。 as I mentioned， stack pointers， all of that stuff。 Where's the
    thread control， block stored？
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我保证。好了，如果你看看线程控制块，它保存了线程未运行时的寄存器内容，其他信息呢？它会有诸如寄存器、程序计数器，正如我提到的，栈指针等等。那么，线程控制块存储在哪里？
- en: It's going to be in the kernel for now。 Can toss， which is this operating。 system
    that we're going to be programming and working with and modifying， you can start。
    doing things by reading， for instance， thread dot H and thread dot C in the process
    control。 structures when you start your first project， project zero。 So you get
    a chance to actually。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它目前会在内核中。可以开始做一些事情，比如阅读`thread.h`和`thread.c`，这是在进程控制结构中，当你开始第一个项目，项目零时，你可以通过阅读这些文件来开始。这样你就有机会实际操作。
- en: start looking at that code very soon and you can start seeing how some of the
    things。 I'm talking about are implemented。 Okay。 The question about what's user
    level or interrupt， level。 why don't we hold off for a moment on too many detailed
    questions there。 Just think。 of user level is less priority than kernel level
    or interrupt level。 Okay。 We'll get to。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 很快你就可以开始查看代码了，开始看到我所讲解的某些内容是如何实现的。好的。关于什么是用户级别或中断级别的问题，我们稍后再处理太多的详细问题。只需记住，用户级别的优先级低于内核级别或中断级别。好的，我们稍后会讲到。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_31.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_31.png)'
- en: these in a lot more detail later。 So now let's talk about a little in minestribia。
    All of， you。 both those who are in the class and those who are still on the wait
    list ought to be doing。 homework zero。 Okay。 It's due next Wednesday and it， you
    know， so you need to be going on， it。 And it's important because it's going to
    help you get your VM environment set up。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 后续会更详细讲解这些。所以现在让我们谈谈一些琐事。所有人，不论是已经注册的同学还是仍在等待名单上的同学，都应该做作业零。好的，它的截止日期是下周三，所以你需要开始做它。而且它很重要，因为它将帮助你设置你的虚拟机环境。
- en: and get familiar with tools and some of the other things， both homework zero
    and project， zero。 which is going to be next Monday。 So all of these things are
    important for getting。 going right away because when the projects， the real projects
    start up and your groups。 are ready to go， which is going to happen in the third
    week， you need to have gotten。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 并熟悉工具以及其他一些内容，包括作业零和项目零，项目零将在下周一开始。因此，所有这些内容对于尽快开始非常重要，因为当项目，真正的项目启动时，并且你的组已经准备好，第三周会发生这一切，你需要已经完成了这些准备。
- en: all this preliminary stuff done。 So even if you're thinking you can still get
    in the class。 and kind of waiting， you should be doing this homework。 If you're
    unless you withdraw from。 the class and are not on the wait list and certainly
    not in the class， you should be。 doing this homework。 Okay。 And moving forward，
    we finally got our section sorted out。 So all。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些初步工作。所以即使你觉得你仍然能进入这门课，并且在等待中，你也应该做这个作业。除非你退课了并且不再在等待名单上，当然也不是在这门课上，你应该做这个作业。好的。接下来，我们终于整理好了我们的分组。所以所有的。
- en: of our sections starting next week are going to be on Friday。 I know that we
    had this weirdness。 with Wednesdays and Thursdays and so on。 But the reason it's
    important to have everything。 on Friday and they're going to be spread throughout
    the day is that we can make sure that the。 sections can cover details from the
    two lectures in the week and that everybody gets the same。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从下周开始，我们的大部分小组会安排在星期五。我知道我们之前有些奇怪的安排，比如星期三和星期四。但这样安排的重要性在于，我们可以确保小组能够覆盖本周两次讲座的细节，并且每个人都能得到相同的内容。
- en: lectures before section。 So that's going to make things much clearer。 Okay。
    And watch。 for updates on Piazza and on our website。 Okay。 Slipt days。 So you
    get some number of， slip days。 Good question there。 Let me back up。 So there's
    a question of do we sign up。 for sections or can we go to any first two weeks？
    You're welcome to go to any offered， sections。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在小组前的讲座。所以这将使事情变得更加清晰。好的。请注意，Piazza和我们网站上的更新。好的。滑动天数。你会得到一些滑动天数。这里有个好问题。让我倒回去。关于是否需要注册小组，或者前两周可以去任何一个小组的问题？你可以去任何提供的小组。
- en: Okay。 When you sign up for groups， which is going to be the beginning of the，
    third week。 we will assign sections based on preferences from you guys such that
    all。 four of your group members have to be in the same section or at least with
    the same TA。 It's going to be important so that that TA can know about you and
    your group members。 Okay。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。当你们报名加入小组时，即将在第三周开始，我们会根据你们的偏好分配小节，以确保你们四个小组成员都在同一个小节，或者至少由同一个助教负责。这一点非常重要，因为这样助教就能了解你们和你们小组的成员。好的。
- en: And so you're going to actually sign up for groups and give some preferences
    and then。 we're going to assign you sections。 Okay。 But for now， first two weeks，
    any section is， fine。 So back to slip days。 So you have three slip days for homeworks
    and four slip days。 for projects which you can use any way you want。 But don't
    use them up right away because。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你们将实际报名加入小组并给出一些偏好，之后我们会根据这些偏好为你们分配小节。好的。但是现在，前两周，任何小节都可以。回到补交天数。所以你们有三天补交期用于作业，四天补交期用于项目，完全可以根据自己的需要使用。但是不要马上就用掉，因为。
- en: there's no credit for late homeworks or projects when you start running out
    of slip days。 Okay。 So that's very important。 These are not meant to make up for
    starting really late， although。 you could do that occasionally。 They're there
    for kind of contingencies。 If something doesn't。 quite work out or somebody has
    a problem or gets injured or gets sick。 Okay。 And Saturday。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始用完补交天数时，作业或项目将不再给予延期成绩。好的。这非常重要。这些补交天数并不是用来弥补开始得太晚的，尽管你偶尔可以这么做。它们是为了应对突发情况。如果有什么没有顺利进行，或者有人有问题，受伤或生病的情况下。好的。至于星期六。
- en: is an optional review。 Okay。 And Zoom link is either TBA or beyond Piazza， maybe
    recorded。 Okay。 Friday is the drop day and that's a week from this Friday， week
    from tomorrow。 Please drop before then if you're going to drop。 That way we can
    make sure that everybody。 who wants to get in and could get in can get in。 Okay。
    Because it's going to be hard after。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可选的复习环节。好的。Zoom链接可能会在之后公布，或者通过Piazza发布，可能会录制。好的。星期五是退选截止日期，从这个星期五算起，一周后。请在那之前退选，如果你打算退选的话。这样我们可以确保每个想加入并能够加入的人都能顺利加入。好的。因为之后就很难再退选了。
- en: the drop day to drop it。 So please drop sooner rather than later。 All right。
    Any questions？
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 退选截止日期过后就很难再进行退选。所以请尽早退选，而不是等到最后。好，大家有问题吗？
- en: Let's see。 Do I have it up？ That was the last one。 And by the way， our final
    class size。 has been set。 We're not going to be adding any more sections。 We have
    11 of them now。 And。 we're not going to go for any larger class sizes either。
    So， you know， I think we're getting。 down toward our final enrollment。 So we are
    going for all Friday sections。 Okay。 So we're。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。我有打开吗？这是最后一个。顺便提一下，我们的最终班级人数已经确定。我们不会再增加更多的小节了。现在有11个小节。我们也不打算增加更大的班级规模。所以，你们知道的，我想我们快接近最终的注册人数了。我们将选择所有的星期五小节。好的。所以我们。
- en: no longer doing Thursday。 And again， that's important from a course content
    standpoint。 All right。 Once again， I want to remind you of the collaboration policy。
    We're going to。 explain a concept to somebody in another group conceptually。 Okay。
    Discussing algorithms。 conceptually。 Okay。 Discussing approaches to debugging
    without specific details might， be okay。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不再进行星期四的课程。再说一遍，从课程内容的角度来看，这是很重要的。好的。我再次提醒大家合作政策。我们可以向其他小组解释概念性的内容。好的。概念性地讨论算法。好的。讨论调试方法时不涉及具体细节，可能可以。
- en: Searching online for generic algorithms like hash tables。 Okay。 All right。 These
    are。 kind of allowed collaborations。 Sharing code for test cases with another
    group。 Not okay。 Copying or reading another group's code or test cases。 Not okay。
    Copying or reading your。 friends code。 Not okay。 Okay。 You can't search for online
    code or test cases from prior years。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在线搜索如哈希表这样的通用算法是可以的。好的。好了，这些算是允许的合作。与其他小组共享测试用例的代码。不好。复制或阅读其他小组的代码或测试用例。不好。复制或阅读你朋友的代码。不好。好的。你不能搜索来自过去年份的在线代码或测试用例。
- en: We actually test for that。 Okay。 We have running， you know， we have running
    checks to make sure。 that people are not doing that。 So don't do it because if
    you get snared in， you know。 collaboration， failure here， you're going to， it's
    going to be problematic for everybody。 And we just don't want to deal with it。
    Okay。 Helping somebody in another group to debug。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上会对这一点进行检查。好的。我们有实时检查，确保没有人这么做。所以不要做这件事，因为如果你被抓到进行违规合作，会给大家带来麻烦。我们真的不希望处理这些问题。好的。帮助另一个小组的人调试。
- en: their code。 Not okay。 Okay。 So we're comparing all the project submissions against
    prior years。 and online solutions and we'll take actions if we find matches。 And
    don't， you know， don't。 put a friend in a bad position by asking them to help
    you with something。 Okay。 Don't。 ask them for their code。 That just， it turns
    out bad for both of you。 Okay。 All right。 Okay。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的代码。不好。好吧。所以我们会将所有的项目提交与往年的项目和在线解决方案进行对比，如果发现匹配的地方我们会采取行动。不要，别。让朋友陷入困境，帮你做一些事情。好吧。别问他们要代码。这只会，结果对你们俩都不好。好吧。好的。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_33.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_33.png)'
- en: So let's look at the second concept of address space here。 And are there any
    testing frameworks。 that you'll use throughout the semester？ That's good question。
    We're going to start by making。 sure you learn GDB。 And we may， we may give you
    some more unit testing options as time。 goes on here。 That's a good question。
    And we'll see what we can do。 Okay。 But definitely。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们来看看地址空间的第二个概念。你们整个学期会使用哪些测试框架吗？这是个好问题。我们会从确保你们学会GDB开始。随着时间推移，我们可能会给你们更多的单元测试选项。好的问题。我们看看能做什么。好吧。但肯定的。
- en: want to get good at GDB。 So I mentioned earlier the address space。 And here's
    the example。 of an address space with 32-bit addresses， let's say。 So that would
    mean that there's。 32 bits of digits here。 These are hex。 So that would be eight
    hex digits。 And from zero zero。 to FFFF， that's an address space。 Okay。 It's all
    the addresses that a 32-bit processor。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 想要掌握GDB。所以我之前提到过地址空间。这里是一个例子，假设是32位地址的地址空间。那意味着这里有32位的数字。这些是十六进制的。所以有8个十六进制数字。从00到FFFF，这是一个地址空间。好吧。这是32位处理器的所有地址。
- en: could conceivably access。 And notice that this is a virtual idea。 Okay。 So just
    because。 they can access all 32 bits doesn't mean that all 32 bits are valid or
    even backed by DRAM。 Okay。 So this is the view of a thread as it's running。 Okay。
    And so an address space set。 of accessible addresses in state。 For a 32-bit processor，
    it's about 4 billion addresses。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象访问。请注意，这只是一个虚拟的概念。好吧。所以仅仅因为它们可以访问所有32位并不意味着所有32位都是有效的，甚至不一定由DRAM支持。好吧。这是一个线程在运行时的视图。好吧。所以一个地址空间集就是在状态下可以访问的地址集合。对于一个32位的处理器，它大约有40亿个地址。
- en: For a 64-bit processor， it's considerably bigger。 Okay。 It's 18 quintillion
    addresses。 And what happens when a thread that's running reads your rights from
    an address？ And the， answer is。 well， you can maybe it'll act like regular memory
    and you could read or write， to memory。 Perhaps you write to it but nothing happens
    because it's read only but it's set。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个64位的处理器，它要大得多。好吧。它有18亿亿个地址。那么当一个线程在运行时，从某个地址读取或写入会发生什么？答案是，嗯，可能它就像普通内存一样，你可以读取或写入到内存。也许你写入它，但什么都没有发生，因为它是只读的，但它已经设置好了。
- en: up to ignore your rights。 Okay。 Perhaps it causes an IO operation。 It's possible
    to read。 or write from an address that'll actually cause something to appear on
    a screen。 Okay。 That's memory map。 I owe。 We'll talk a lot about that。 Perhaps
    it causes an exception， or a fault。 Okay。 And that would be you're trying to access
    parts of the memory space。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略你的权限。好吧。也许它会导致一个I/O操作。可能从一个地址读取或写入，实际上会导致屏幕上显示一些东西。好吧。这就是内存映射I/O。我们将深入讨论这个。也许它会引发一个异常或故障。好吧。那意味着你试图访问内存空间的某些部分。
- en: that you're not allowed to and you get a page fault。 It maybe it communicates
    with another， program。 Okay。 So there， and that's an interesting thing we'll call
    shared memory in a moment。 or actually in a couple of lectures where you read
    and write and address and it appears。 in somebody else's address space。 Okay。
    So the address space is the set of addresses。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有权限访问，结果会发生页面错误。可能它会和另一个程序通信。好吧。所以，这里有一个有趣的点，我们稍后会称其为共享内存。或者实际上在几节课后，你会看到在某些地址上进行读写时，这些地址会出现在其他人的地址空间中。好吧。所以地址空间就是一组地址集合。
- en: you can address and what happens when you try to read or write them is up to
    the operating。 system and how it's configured things。 And we'll talk a lot more
    about how you do that。 Okay。 But so in a picture， let me show you。 Here's the
    processor registers。 Here's the， program counter。 It points to some address instruction
    in the address space。 Here's， the stack pointer。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问的地址，以及你尝试读取或写入它们时发生的情况，取决于操作系统和它的配置方式。我们将深入讨论如何做到这一点。好吧。现在，给你们看一张图。这里是处理器寄存器。这里是程序计数器。它指向地址空间中的某个地址指令。这里是堆栈指针。
- en: It's pointing to the stack at the bottom of the stack。 Okay。 And what's， in
    the code segment？ Well。 instructions。 What's in the static data segment？ Well，
    data that， was in your C program statically。 Okay。 What's in the stack segment？
    Well， hopefully， and， we'll talk more about this next time。 but you remember what
    a stack is。 So the stack is， the set of local variables。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它指向栈的底部。好的。那么，代码段中有什么呢？嗯，指令。静态数据段中有什么呢？嗯，就是在你的 C 程序中静态定义的数据。好的，栈段中有什么呢？嗯，希望我们下次会更详细地讨论这个。你还记得栈是什么吧？所以栈就是一组局部变量。
- en: And typically when you call a procedure， you allocate a new stack。 segment to
    handle all the local variables。 And when you return from the procedure， the。 stack
    is popped off。 And what I'm showing you here is the typical mode in which the
    stack。 is growing downward。 So the stack pointer starts at a FFFF。 And as you
    push things on， the stack。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你调用一个过程时，会分配一个新的栈段来处理所有的局部变量。当你从过程返回时，栈会被弹出。我要给你展示的是栈增长的典型模式。所以栈指针从 FFFF
    开始，当你压入东西时，栈会增长。
- en: it grows downward。 And as you pop them off the stack， it grows up。 Okay。 What's，
    in the heap？ Well。 the heap is dynamically allocated memory。 Okay。 So how is it
    allocated？ Well。 typically by calling something like Malick， how big is it？ Well，
    it depends on。 how much allocation you've done。 You know， how many times have
    you called Malick， which。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它是向下增长的。当你从栈中弹出数据时，它会向上增长。好的，堆中有什么呢？嗯，堆是动态分配的内存。好的，那么它是如何分配的呢？嗯，通常是通过调用像 malloc
    这样的函数，那么它有多大呢？嗯，这取决于你进行了多少分配。你知道，你调用 malloc 的次数有多少。
- en: will ultimately call S break and the underlying system。 But， you know， how much
    is in the。 heap depends on how much you ask for。 And then there's this hole in
    the middle， okay。 And。 that hole is going to be kind of interesting to us in a
    few lectures because， you know。 what happens when you try to push something on
    the stack and there's no physical memory， underneath。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最终将调用 S 中断和底层系统。但你知道，堆中有多少内容取决于你请求了多少。然后中间有个空洞，好的。这个空洞在接下来的几讲中会变得有些有趣，因为你知道，当你尝试在栈上压入某些内容，而底层没有物理内存时，会发生什么。
- en: that's going to cause a page fault。 And the OS can do a couple of things。 like
    it could add more memory or it could cause a segmentation fault。 So we're going。
    to talk a lot more about that as well。 Okay。 Questions？ So good question。 What
    is stack overflow？
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致页面错误。操作系统可以做几件事情，例如它可以增加更多内存，或者它可能会引发段错误。所以我们也会详细讨论这个问题。好的，问题来了？好问题。什么是栈溢出？
- en: Well， stack overflow is going to be when you allocate， so much stack， because
    you go push， push。 push， push， push， push， that the OS decides， that it can't
    give you anymore。 And then you'd say that the stack is overflowed。 And if the，
    OS catches it properly。 the worst that would happen is your program， your process
    would， be killed。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，栈溢出就是当你分配了过多的栈空间，因为你不断地压栈，直到操作系统决定不能再分配更多空间时，你就会遇到栈溢出的情况。如果操作系统正确处理了它，最糟糕的结果就是你的程序或进程会被终止。
- en: What's a little less fortunate is if the stack grows into the heap and the。
    right protection isn't there。 And then you silently overwrite some of your data。
    And the。 reason that's worse is because you don't actually get a fault out of
    it。 You just get。 really weird behavior。 Okay。 We'll talk more again about these
    ideas。 Okay。 Can the heap。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不太幸运的情况是，如果栈扩展到堆，并且没有适当的保护，那么你就会悄悄覆盖掉一些数据。而更糟糕的是，发生这种情况时，你并不会收到错误提示。你只是会遇到一些非常奇怪的行为。好的，我们稍后会再次讨论这些概念。好的，堆可以。
- en: overflow too？ Yes。 So let's talk about our previous discussion of threads。 So
    very simple。 multi programming was what we did there。 Okay。 All the virtual CPUs
    share the same memory。 IO devices， et cetera。 They're all in the same address
    space。 The magenta thread can。 can overwrite or look at the blue cyan threads
    values。 Okay。 And each thread is therefore not。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生溢出吗？是的。那么让我们来谈谈之前讨论的线程问题。非常简单，多道程序设计就是我们在做的事情。好的。所有虚拟 CPU 都共享同一块内存、IO 设备等，它们都在同一地址空间内。品红色线程可以覆盖或者查看蓝色和青色线程的值。好的。因此，每个线程都不是独立的。
- en: protected of the others。 Can it overwrite the OS？ Well， that's a good question。
    Not in a。 lot of operating systems， but certainly in the original ones it did。
    Okay。 Is this scenario。 unusable because it's possible for threads to overwrite
    each other or the operating system？ Well。 this approach was used with no protection
    in the early days of computing。 It's often。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 保护了其他部分。它能覆盖操作系统吗？这是个好问题。在很多操作系统中不能，但在最早期的操作系统中确实能。好的。那么这个场景不可用的原因是线程可能会相互覆盖，或者覆盖操作系统吗？嗯，这种方式在计算机早期没有保护的情况下被使用过。它仍然常常。
- en: used still in embedded applications。 Some of the early Mac OS versions or Windows
    3。1 or。 Windows 95 actually had this level of protection where there was just
    very simple multiplexing。 there wasn't any protection。 And as a result， it was
    possible for threads to overwrite parts。 of the address space that contain the
    operating system。 Risky。 Okay。 There was that question。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式应用中使用。早期的一些 Mac OS 版本，或者 Windows 3.1、Windows 95 实际上采用了这种简单的多路复用保护方式，根本没有任何保护。因此，线程有可能覆盖包含操作系统的地址空间的某些部分。这是有风险的。好的。正如我之前提到的。
- en: earlier about how does the OS make sure that it gets control again？ Well， if
    you have no。 protection， it's possible for a user thread to overwrite the code
    that was supposed to do， that。 And as a result， basically that timer interrupt
    might go off and the wrong things。 might happen and it wouldn't take control back。
    So that's an issue。 So simple multiplexing。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候提到的，操作系统如何确保重新获得控制？嗯，如果没有保护，用户线程可能会覆盖本该执行这些操作的代码。结果就是，计时器中断可能会触发，但却发生了错误，无法重新获得控制。所以这是一个问题。简单的多路复用。
- en: that I told you about has no protection， but the operating system really has
    to protect， itself。 as you might imagine， for lots of reasons。 Like reliability。
    We know if we're compromising。 the operating system that generally causes it to
    crash at minimum， security， if you limit。 the scope of what threads can do， then
    they can't steal information from other threads。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保护，但是操作系统必须保护自己。你可以想象，有很多原因需要这样做。比如可靠性。如果我们妥协操作系统，通常会导致它崩溃，至少是崩溃，安全性方面，如果限制线程的操作范围，它们就不能从其他线程中窃取信息。
- en: that are supposed to really be separate processes。 Privacy could one running
    program steal keys。 in another one。 For fairness， could each thread limit its
    appropriate share of system resources。 limit the share of other system resources
    by overwriting the operating system and basically。 never giving up the CPU。 So
    all of these things mean that the operating system needs something。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私方面，可能一个正在运行的程序偷取另一个程序中的密钥。公平性方面，每个线程可能会限制自己合适的系统资源份额，覆盖操作系统来限制其他系统资源的份额，并且基本上永远不放弃
    CPU。所以所有这些都意味着操作系统需要一些东西。
- en: better than simple multiplexing。 Okay。 And it also must protect user programs
    from one。 another so that different programs can't overwrite each other。 So what
    can the hardware do？ Well。 it can start adding some hardware。 Okay， we can start
    adding some hardware to prevent。 violations of privacy and security。 And here's
    a particularly simple one， which we're just。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 比简单的多路复用要好。好的。那么它还必须保护用户程序不互相干扰，确保不同的程序不能相互覆盖。那硬件能做什么呢？嗯，它可以开始添加一些硬件。好的，我们可以开始增加一些硬件来防止隐私和安全的侵犯。这里有一个特别简单的例子，我们称之为指向最低地址的基址。
- en: going to call base and bound。 And the idea is this address space I'm showing
    you is the。 set of all D RAM， physical D RAM options。 And it is operating system，
    which is in gray here。 and a particular thread that we want to be running in a
    protected mode down here， which。 is the yellow piece。 And what the base and bound
    idea is is that there's a special register。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称之为基址和边界。这个地址空间的概念是，我展示给你的是所有 D RAM 物理 D RAM 选项的集合。它是操作系统，这里是灰色部分。还有一个我们希望在受保护模式下运行的特定线程，位于这里的黄色部分。基址和边界的概念是存在一个特殊寄存器。
- en: called the base that points to the lowest address。 Now I've got this reverse
    from earlier， by。 the way， so smaller addresses are up。 But this， the base is
    pointing to the lowest address。 that yellow is allowed to access。 And the bound
    is pointing at the highest part that the。 yellow is allowed to access。 And as
    a result， if we could somehow make this prevent things。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我从之前的内容倒过来了，所以较小的地址在上面。但这个基址指向的是黄色部分可以访问的最低地址。边界指向的是黄色部分可以访问的最高地址。结果是，如果我们能够以某种方式防止那些本应是独立进程的事情发生。
- en: running in user mode from accessing the gray thing at all， then we can prevent
    the yellow。 thing from overwriting the operating system。 And so， for instance，
    here's an example where。 we have program addresses pointing at data。 And if we
    have the CPU try to access， say， address 1010。 what we're going to do is we're
    going to ask ourselves， is it larger than the， base？
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 防止用户模式下的程序访问灰色区域，那么我们可以防止黄色区域覆盖操作系统。因此，例如，这里有一个示例，其中程序地址指向数据。如果我们让CPU尝试访问比如说地址1010，我们要做的是问自己，它是否大于基址？
- en: And if you notice 1010 is larger than 1010， so the answer is yes。 Okay， is it
    lower， than the bound？
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到1010大于1010，那么答案是肯定的。好的，它是否小于界限？
- en: The answer is yes， in which case we go ahead and actually allow the access。
    So just by having these two registers and a couple of hardware comparison things
    that。 cause exceptions to happen， suddenly we can protect。 Okay， very simple protection
    base， and bound。 Okay， so however， if you notice the simple version of this program
    on the disk。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，在这种情况下我们继续允许访问。因此，仅通过这两个寄存器和一些硬件比较机制，这些机制会引发异常，我们就能实现保护。好的，非常简单的保护机制——基址和界限。好的，那么如果你注意到磁盘上的这个程序的简单版本。
- en: actually sort of thinks it's got address zero for the code and some higher address
    for stack。 stuff and really an address for static data goes 0010 on the file system。
    And so when。 we load it into memory， we're going to have to dynamically translate
    all of the addresses。 that were here into their new position where notice the
    code was at all zeros here， but。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它认为代码的地址是零，堆栈的地址是较高的地址，静态数据的地址在文件系统中是0010。因此，当我们将其加载到内存中时，我们需要动态转换所有地址，将它们映射到新的位置。请注意，代码在这里的地址全是零，但是。
- en: now it's at all one zeros are zero。 And so there's a dynamic loader that changes
    all。 the addresses inside the code to be consistent to operate at a base of one
    zeros are zero。 And if we do that， then we can use base and bound to allow execution。
    So if you look here。 so how can the address space live in the or how can the OS
    live in an address space when。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它全是零。所以有一个动态加载器，它会将代码中的所有地址转换为与基址一致的地址（即全零）。如果我们这样做，那么就可以使用基址和界限来允许执行。所以你看这里。那么，操作系统如何在地址空间中存在呢？
- en: the OS itself is the one providing the abstract of address spaces。 Well， I just
    showed you， here。 It's the magic of protection。 So here the OS is running here。
    It's going to be all。 the code down here where the gray is。 And I've prevented
    whenever I'm in user mode。 Notice。 I don't have user mode yet。 But when I'm in
    user mode， the base and bound registers are。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统本身提供地址空间的抽象。好吧，我刚刚向你展示了这里。它是保护的魔法。所以这里操作系统在运行。所有的代码都在这里，灰色的区域。我在用户模式下时，防止了任何操作。注意，我还没有进入用户模式。但是当我进入用户模式时，基址和界限寄存器就会。
- en: going to be set and enforced。 And as a result， the user code won't be able to
    mess up the。 operating system。 And so it's protected。 And so these base and bound
    registers as is asked。 in the in the chat are dynamically set。 Each time a thread
    is started executing。 So when。 we decide a thread is ready to execute， we set
    the base and bound registers then。 Okay。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将会设置并强制执行。因此，用户代码将无法破坏操作系统。所以它得到了保护。因此，正如在聊天中提到的，这些基址和界限寄存器是动态设置的。每次线程开始执行时，都会进行设置。所以当我们决定一个线程准备好执行时，我们会设置基址和界限寄存器。
- en: So this protects the OS and isolates the program and requires a relocating loader，
    however。 which can somehow translate the addresses as they were on disk into the
    way they are in， memory。 And notice by the way， this will make sense in a moment。
    There's nothing special。 like addition or wherever on the hardware path。 For those
    of you who have taken a hardware， class。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这保护了操作系统并隔离了程序，需要一个重定位加载器，然而，这个加载器能够将磁盘上的地址转换为内存中的地址。顺便说一下，这会在稍后讲解时变得有意义。硬件路径中没有特别的地方，比如加法或其他什么。对于那些上过硬件课程的人来说。
- en: there's no delay introduced when we try to read from the heap by this particular。
    mechanism because they're really the address goes straight out to memory。 Okay。
    We'll have。 a better type of protection， which is going to add a little bit of
    hardware latency there。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试通过这种特定机制从堆中读取时，不会引入任何延迟，因为地址会直接发送到内存。好的。我们将有一种更好的保护类型，这将增加一些硬件延迟。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_35.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_35.png)'
- en: in just a few slides。 So what is relocation？ So you might remember this from
    61C。 So here's。 an example of an assembly mode instruction jump and link where
    that gets translated into。 binary where the opcode， 000， 000， 011 is at the top。
    And the address of the print def。 gets put into the lower part of the binary instruction。
    And when we load it， when we compile， it。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是重定位？你可能还记得在61C课上学过这个。这里是一个汇编语言指令跳转和链接的例子，它被翻译成二进制，其中操作码000 000 011在上方，打印定义的地址被放入二进制指令的下半部分。当我们加载它，编译它时。
- en: it looks like this in on disk with the x is replaced by binaries。 But when we
    finally， load it。 at that point it needs to be translated and linked properly
    to go where it belongs in， memory。 And so at that point， we do what's called relocation，
    which is we relocate all。 of these addresses that were filled in either at the
    time that we do loading or at the time。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它在磁盘上的样子是这样的，x被二进制替换掉。但是当我们最终加载它时，那时它需要被正确地转换和链接到它在内存中的正确位置。所以在那个时刻，我们做的是所谓的重定位，我们将所有这些地址重新定位，无论是在加载时还是在。
- en: that we do linking。 Those are two possibilities。 Okay。 And the addresses in
    the executable on。 disk are as if everything was loaded in memory at 000。 And
    when we link it or load it into， memory。 at that point we're going to translate
    to its new position。 Okay。 So let me show you。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行链接。那是两种可能性。好的。并且在磁盘上的可执行文件中的地址，就好像所有东西都加载到内存中的000位置。当我们进行链接或加载到内存时，那个时刻我们会转换到它的新位置。好的。让我在接下来的几张幻灯片中展示给你。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_37.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_37.png)'
- en: something that's a little bit less complicated for the software by putting a
    little complexity。 into the hardware。 And if you notice， if you think back to
    what I showed you earlier， the。 only thing I've done here is I've added an adder
    here。 Okay。 And this is a hardware adder。 And what it means is that when the program
    addresses come out of the CPU， they go through。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一些复杂性放入硬件中，使软件稍微简单一些。如果你注意到，回想一下我之前展示的内容，我在这里做的唯一一件事就是添加了一个加法器。好的。这是一个硬件加法器。它的意思是，当程序的地址从CPU输出时，它们会经过
- en: an adder before they go to DRAM。 Okay。 And if you think about that， I'll set
    a base address。 still of 10000。 But now when the CPU tries to access address 0010000，
    we add the base。 to it and now we access address 1010000。 And suddenly we've translated
    the CPU's view to。 the physical view。 So this is actually a type of virtual memory。
    Okay。 Where we do translation。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们访问DRAM之前加一个加法器。好的。如果你考虑这个问题，我会设置一个基地址，仍然是10000。但是现在，当CPU尝试访问地址0010000时，我们会把基地址加到它上面，这样我们就访问到了1010000。突然间，我们就将CPU的视图转换成了物理视图。所以这实际上是一种虚拟内存。好的，里面我们做了转换。
- en: on the fly。 Okay。 And this is going to give us an illusion of memory。 It's not
    going to。 be a very good one toward the infinite illusion though， but it does
    give us an illusion。 Okay。 And hopefully this makes sense to everybody。 So now
    the way that the binary looks on disk。 and the way it looks in memory is the same。
    We've just loaded this off of disk and put it。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时。好的。这将给我们一种记忆的错觉。但它并不会是一个很好的错觉，尤其是在无限错觉的情况下，不过它确实给了我们一种错觉。好的，希望大家都能理解。那么现在，二进制文件在磁盘上的表现与在内存中的表现是一样的。我们只是把它从磁盘加载到内存中。
- en: into memory。 And we can execute it as if it were at zero because it's the program
    or the。 CPU thinks it's at zero。 And we address it on the fly in its real spot
    by adding a base。 address to it。 Okay。 This is hardware relocation rather than
    the software case where the software。 had to change its location。 Now can the
    program touch the OS here？ And the answer is no because。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像它位于零地址一样执行它，因为它是程序，或者说CPU认为它位于零地址。我们通过在其真实位置上加上基地址，动态地访问它。好的。这是硬件重定位，而不是软件中的情况，软件需要更改其位置。那么程序能接触到操作系统吗？答案是否定的，因为。
- en: it would have to give a negative address that would go below yellow and it can't
    do that。 Or it would have to give an address that's so big that it wraps around。
    It's also not。 allowed to do that because it's trapped between the base and it's
    trapped here with the bound。 Okay。 So this is still protecting the OS into this
    little yellow chunk of physical memory。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须提供一个负地址，这个地址会低于黄色区域，而它无法做到这一点。或者它必须提供一个如此大的地址，以至于会发生地址回绕。它也不能这么做，因为它被限制在基地址和绑定区之间。好的。所以这仍然是在保护操作系统，位于这小段黄色物理内存中。
- en: Can it touch other programs？ Well the answer is that's going to be no too because
    if you。 imagine a green one up here this CPU can only use addresses that when
    added to the base go。 between one zero zero and one one zero zero and nothing
    else is going to be touchable。 So all the other programs and the operating system
    are all protected。 Now the good question。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它能接触到其他程序吗？答案是不能，因为如果你想象一下这里的绿色区域，CPU只能使用那些当加到基址后，落在100到1100之间的地址，其他的无法访问。所以所有其他的程序和操作系统都是被保护的。现在是一个好问题。
- en: here on the chat is is this a hardware delay？ Yes。 But in a modern type of CMOS
    this extra。 adder is essentially almost unnoticeable。 So many other things in
    there。 So this extra。 little hardware delay is not going to change the cycle time
    in any reasonable way。 And。 the benefit or if it did you want to slow the cycle
    time down the benefit of this is huge。 Okay。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的聊天中提到的是：这是不是硬件延迟？是的。但在现代CMOS类型中，这个额外的加法器几乎是不可察觉的。还有许多其他东西在里面。所以这个额外的小硬件延迟不会以任何合理的方式改变周期时间。如果它改变了周期时间，你也希望能减慢周期时间，这样做的好处是巨大的。好的。
- en: Because it means that the same code from the disk can be loaded into memory
    and directly。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这意味着同样的代码可以从磁盘加载到内存，并直接运行。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_39.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_39.png)'
- en: executed。 And by the way we're not going to worry about these kind of hardware
    delays。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了。顺便说一下，我们不必担心这些硬件延迟问题。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_41.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_41.png)'
- en: very much in this class。 We'll mention them occasionally。 That's more for 152。
    Now the。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这门课中我们会偶尔提到它们。更多的是在152课程中讲解。现在。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_43.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_43.png)'
- en: x86 is a very interesting architecture with a whole bunch of what are called
    segments。 Okay。 And segment registers to define them。 For instance the code segment
    has basically。 a pointer to the beginning of one of these chunks and a link。 So
    it's very much like base。 in bound where however instead of just one base in bound
    we have potentially many with。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: x86是一种非常有趣的架构，具有大量所谓的**段**。好的。并且使用段寄存器来定义它们。例如，代码段基本上有一个指向这些块开始的指针，并且有一个链接。所以它非常像基址和界限，然而我们不止有一个基址和界限，而是有多个。
- en: different functionalities like code， data， stack and so on。 Okay。 And we'll
    get much。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的功能，如代码、数据、栈等等。好的。我们将会得到更多。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_45.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_45.png)'
- en: more into segments as we go。 But just keep in mind that the idea there is lots
    of base。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续深入，分段的概念会更清晰。但要记住的是，那里有许多基址。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_47.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_47.png)'
- en: in bounds each with a sort of a function that it's allowed to have。 Okay。 Now
    a slightly。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个基址都有一种它允许的功能。好的。现在稍微有点不同的是。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_49.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_49.png)'
- en: different idea from that simple one I introduced you here is fully general address
    based translation。 And here what happens is the addresses come out of the processor
    and they're translated。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与我在这里介绍的简单方法不同，这是一个完全通用的基于地址的转换方法。在这里，地址从处理器中输出，并进行转换。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_51.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_51.png)'
- en: to physical addresses。 And by the way you could say that happened here right？
    Came out of。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为物理地址。顺便提一下，你可以说它发生在这里，对吗？从这里出来。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_53.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_53.png)'
- en: the processor got translated to physical addresses。 But we're much more general
    whereas in the。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器将被转换为物理地址。但我们更为通用，而在此情况下。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_55.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_55.png)'
- en: previous case they were linearly arrayed from the base to the bound。 Here we
    can put an arbitrarily。 translator in here and so the virtual addresses can be
    all over the place in physical memory。 And so that's going to bring us to another
    61C idea which you got briefly which was the。 page virtual address space。 And
    so this translator in the case of paging is a very specific one。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，它们是从基址到界限线性排列的。在这里，我们可以在其中放入一个任意的转换器，所以虚拟地址可以在物理内存的任何地方。因此，这将引导我们进入另一个61C的概念，你简要了解过，那就是**分页虚拟地址空间**。在分页的情况下，这个转换器是一个非常特定的。
- en: where it moves things around and moves them around but it does so in granularity
    of one， page。 A very good question here that I think just showed up in the chat
    was the registers。 in risk 5 and the ones in x86 are the same physical registers
    in the CPU but assigned to。 different functions。 You can't really think of it
    that way。 An x86 CPU and a risk 5 CPU。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 它会移动某些内容，但它是以页面为单位进行的。这里有一个非常好的问题，我觉得刚刚在聊天中出现了，就是 RISC 5 和 x86 中的寄存器是同一物理寄存器，只是被分配给了不同的功能。你不能真的那样理解。x86
    CPU 和 RISC 5 CPU。
- en: are totally different。 And there's no simple way for you just to flip a switch
    and one becomes。 the other。 So they both have registers they both have similar
    functionality but they're。 very different in their implementation and it's not
    like those registers of the x86 became。 registers in the risk 5 by flipping a
    switch。 And this is so page virtual address space getting。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不同。没有简单的方式可以让你翻个开关，一个变成另一个。所以它们都有寄存器，都有类似的功能，但它们在实现上非常不同，不是说 x86 的那些寄存器通过翻开关就变成了
    RISC 5 中的寄存器。这就是页面虚拟地址空间的情况。
- en: back to this idea here。 The question was is this software but no it's hardware
    translation。 It's up to the software to set up the translation but then the hardware
    does it。 Okay。 And all。 the pages here are the same size so it's easy to place
    each page in memory。 The hardware。 translates addresses using a page table。 Okay。
    Every page has a base and bound but they're。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这个问题。问题是，这是不是软件？但不是，它是硬件翻译。软件负责设置翻译，但实际翻译是由硬件完成的。好的，所有页面的大小是相同的，因此很容易将每个页面放入内存中。硬件通过页表翻译地址。好的，每个页面都有一个基地址和界限，但是它们。
- en: all the same size。 Okay。 And special hardware register is point to the page。
    We're going。 to treat the memory as a page size frame。 A whole bunch of page size
    frames。 Okay。 And。 this is another quick CS 161 C review。 And the idea here is
    the translator that I just。 told you about is really called a page table。 And
    what will happen is an address will come。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大小都是相同的。好的，特殊的硬件寄存器指向这个页面。我们将把内存当作页面大小的框架来处理。大量的页面大小框架。好的，这是另一个快速的 CS 161 C
    复习。这里的想法是，我刚才提到的翻译器其实叫做页表。接下来会发生的是，地址将会。
- en: out of the processor and we'll take that address and we'll look up in the page
    table where that。 address is in physical memory。 And so for a given address there'll
    be a frame address。 here that's in blue that will point to a particular page in
    DRAM and we'll basically。 divide that virtual address into both a page number
    and an offset。 And that page number。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从处理器中取出该地址，然后在页表中查找该地址在物理内存中的位置。所以对于一个给定的地址，会有一个框架地址，这里是蓝色的，它指向 DRAM 中的某个特定页面，我们基本上会将虚拟地址分为页面编号和偏移量。而这个页面编号。
- en: having been translated into the blue we then take the offset and that tells
    us how far。 into the blue。 Okay。 So hopefully this is ringing a bell for people。
    But notice for。 instance that addresses here are in the same order as in the virtual
    address space。 That。 order once it's translated to physical order doesn't have
    to have anything like the same， ordering。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻译成蓝色后，我们再取偏移量，它告诉我们到蓝色页面的偏移量。好的，希望这能让大家有所启发。但请注意，例如这里的地址按虚拟地址空间中的顺序排列。一旦翻译成物理顺序，它们的顺序就不一定是一样的。
- en: So the blue frame could be here in physical memory in the green frame up there。
    The processor running in virtual space thinks that everything is pulled together
    in a nice。 clean order but in fact the page table can scramble them all over in
    memory and it turns。 out this is going to be very helpful for management。 Okay。
    So this is actually a really， good thing。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，蓝色的框架可以在物理内存中，而上面的绿色框架则在虚拟空间中。处理器在虚拟空间中运行时认为所有内容都整齐有序，但实际上页表可能会把它们打乱在内存中，结果证明，这对于管理非常有帮助。好吧，这实际上是一个非常好的事情。
- en: Okay。 So instructions operate on virtual addresses。 Instruction addresses are。
    virtual loads and stored data addresses are virtual。 They're translated through
    the page。 table to physical addresses and the physical addresses are the ones
    that are looked up in， DRAM。 Okay。 And any page of the address space can be in
    any place in memory。 So this is an。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，指令在虚拟地址上操作。指令地址是虚拟的，加载和存储的数据地址也是虚拟的。它们通过页表转换为物理地址，物理地址就是在 DRAM 中查找的地址。好的，任何一个地址空间的页面都可以放在内存中的任何位置。所以这是一个。
- en: alternative to the base and bound I just showed you。 Okay。 And the question
    is will a locality。 be compromised in any way？ Let's hold off that question a
    little bit because there's a question。 even at what you mean by locality。 Just
    keep in mind that for the processor to access in。 the processors we're talking
    about for the processor to access here versus here there's。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才给你展示的基址和界限的替代方案。好的。问题是，局部性会受到任何影响吗？让我们稍微停一下这个问题，因为甚至对“局部性”一词的定义都有问题。请记住，对于我们讨论的这些处理器，处理器在这里与在这里访问时。
- en: not a difference in speed unless the memory isn't loaded。 Okay。 And we're not
    going to。 get into two level virtual memory right now either hold off on that
    question please。 Good。 that you know to ask that but we'll deal with it later。
    Okay。 All right。 And there's a special。 register called a page table address that
    points to the base of the page table。 So notice what's。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除非内存没有加载，否则速度没有差异。好的。现在我们不会讨论两级虚拟内存的问题，请稍后再问。很好，你知道要问这个问题，但我们会在稍后处理它。好的。还有一个特殊的寄存器叫做页表地址，它指向页表的基址。请注意，什么是。
- en: cool about this is if different processes have different address spaces then
    what I can do is。 just by when I'm ready to switch from process magenta to process
    cyan all I have to do is in。 addition to load saving and loading registers I just
    changed the page table base address and。 suddenly that new thread that we just
    swapped in has a completely different set of physical。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷的是，如果不同的进程有不同的地址空间，那么当我准备从品红色进程切换到青色进程时，我所需要做的就是，除了加载和保存寄存器外，我只需要更改页表的基地址。突然间，我们刚刚交换进来的新线程就有了一套完全不同的物理。
- en: addresses available to it。 Okay。 So that's going to lead to the third concept
    of a process which is。 going to be an execution environment with restricted rights。
    Okay。 Where there's a protected address， space with one or more threads in it
    it owns some memory so that's the address space it owns。 file descriptor file
    descriptors file system context etc。 It's going to encapsulate one or。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的地址空间。好的。这将引出进程的第三个概念，那就是具有受限权限的执行环境。好的。这里有一个受保护的地址空间，里面有一个或多个线程，它拥有一些内存，所以这就是它拥有的地址空间，文件描述符、文件系统上下文等等。它将封装一个或。
- en: more threads sharing process resources。 Okay。 So a program when it's loaded
    into memory and。 starts executing is a process。 Okay。 And so complex applications
    can actually fork themselves。 into multiple processes that's one possibility。
    Okay。 And that would have multiple of these things。 all working on behalf of the
    process each of which has its own protected address space。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 共享进程资源的线程更多。好的。所以，当一个程序加载到内存并开始执行时，它就是一个进程。好的。复杂的应用程序实际上可以将自己分叉成多个进程，这是一种可能性。好的。这将有多个这样的东西，所有这些东西都代表进程在工作，每个都有自己的受保护的地址空间。
- en: Furthermore a single protected address space can have one or more threads。 Okay。
    So why are。 processes useful they're protected from each other。 So think back
    to the slides I showed you。 at the beginning of the lecture。 Brown green。 The
    brown process protected from the green process。 Why they each have their own address
    space either worked out through base and bound or more likely。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个受保护的地址空间可以包含一个或多个线程。好的。那么，为什么进程有用呢？它们彼此之间是相互保护的。所以，回想一下我在讲座开始时展示的幻灯片。棕色和绿色。棕色进程被绿色进程保护。为什么？因为它们各自有自己的地址空间，这要么通过基址和界限来实现，要么更可能是。
- en: in a modern processor by its page table。 They each have the page table be in
    memory and so when we。 switch from brown to green and back again we're altering
    the page table address in addition to。 loading registers in。 And as a result when
    we go from brown to green and back again they're fully。 protected in their own
    address space where they can't mess up each other unless we decide to let them。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代处理器中，通过其页表来实现。它们每个都有页表存在内存中，因此当我们从棕色切换到绿色并再切换回来时，我们除了加载寄存器外，还会改变页表地址。结果，当我们从棕色切换到绿色并再切换回来时，它们完全被保护在各自的地址空间中，除非我们决定允许它们，否则它们无法互相干扰。
- en: Okay。 All right。 Does the OS build the page table？ Yes。 Okay。 And I'm gonna
    and the page table is a。 long lived thing that kind of exists from the creation
    of the process to the to the death of the。 process。 And for now we're gonna say
    absolutely the page table is in the operating system。 Okay。 You guys will know
    when you could ask me that question again it might give you a different answer。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，操作系统构建页面表吗？是的。好的，页面表是一个长期存在的东西，从进程创建到进程终止都存在。现在我们可以说，页面表绝对存在于操作系统中。好的，你们会知道，当你再次问我这个问题时，我可能会给出不同的答案。
- en: but it won't be for a month or so。 Okay。 So the OS is definitely controlling
    the page table。 And if。 you notice why do we want processes well because the processes
    are protected from each other the OS。 is protected from them。 Okay。 Why is that？
    Well let's go back to this。 If the only parts of memory are， parts that are in
    the page table that I can access then if it's not if it doesn't have a pointer
    in the。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能要等一个月左右。好的，操作系统肯定控制着页面表。如果你注意到，为什么我们需要进程呢？因为进程彼此之间是被保护的，操作系统也被保护不受它们的影响。好的，为什么呢？好吧，回到这个问题。如果内存中的唯一部分是我可以访问的页面表中的部分，那么如果没有指针指向。
- en: page table there's no way for this processor running in that process to go through
    the page table and。 touch a part of memory that's supposed to be only accessible
    to the OS。 Okay。 So the reason OS is。 protected is there just aren't any pointers
    that are accessible to the virtual process that can。 access OS。 Okay。 Another
    good question are the threads in a process protected from each other or。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 页面表中，运行在该进程中的处理器无法通过页面表访问到本应仅操作系统可访问的内存区域。好的，操作系统之所以受到保护，是因为虚拟进程中没有任何可以访问操作系统的指针。好的，另一个好问题是，进程中的线程是否受到彼此保护？
- en: not？ No。 That's a feature。 Okay。 So the threads inside of a process are not
    protected from each。 other and that's good because they're sharing concurrency
    and memory with each other to get some。 job done rapidly。 And so they're not protected
    by each other but that's by design。 And the reason we， don't think of that as
    a security violation is because we assume that you wrote your program to。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不，线程之间没有保护，这是一个特性。好的，进程内部的线程彼此之间没有保护，这是好的，因为它们共享并发性和内存，以便快速完成某些任务。所以它们之间没有保护，但这是有意为之。我们之所以不认为这是安全漏洞，是因为我们假设你已经编写了程序以。
- en: work properly and you wrote it to use those threads and have those threads collaborate
    with each other。 properly and therefore they aren't protected from one another
    but boy they're protected from somebody。 else's threads。 Okay。 Now here's a view
    that I just said of a single threaded and a multi threaded。 process。 So for instance
    a single threaded process has a code and data and files in it and。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 工作正常，你编写了程序以使用这些线程，并让这些线程彼此协作。正确，因此它们彼此之间没有保护，但它们被保护免受其他人线程的干扰。好的。现在这是我刚刚提到的单线程和多线程进程的视图。例如，单线程进程中有代码、数据和文件。
- en: registers and stack and a single thread of control。 And so when that process
    gets put to sleep there's。 only one thread running that needs to be put to sleep。
    A multi threaded process has a bunch of threads。 Okay。 Each of which has registers
    and stack of their own。 That's the part that makes it uniquely a。 thread but they
    also have code and data that's shared。 So typically a multi threaded process has
    a。 huge chunk of code and the threads are running around inside that code but
    that code is all part。 of the same linked image。 Okay。 So threads encapsulate
    the concurrency aspect。 Okay。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器、栈和单一控制线程。因此，当该进程进入休眠时，只有一个线程需要被休眠。多线程进程有很多线程。好的，每个线程都有自己的寄存器和栈。这是使它独特地成为线程的部分，但它们也有共享的代码和数据。所以典型的多线程进程有一大块代码，线程们在这段代码中四处运行，但这些代码都属于同一个链接映像。好的，所以线程封装了并发性方面。好的。
- en: They're the active， component， the executing component of a process。 The address
    space encapsulates protection。 It's the， passive component or the box。 Okay。 I
    like to think of the address space is the box that we shove， these things in。
    The threads are busy running around in that box。 Okay。 And that box that protection。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是活跃的组成部分，是过程的执行组件。地址空间封装了保护机制。它是被动组件，或者说是盒子。好吧，我喜欢把地址空间看作是我们把这些东西塞进去的盒子。线程们在那个盒子里忙着四处跑。好的，那个盒子提供了保护。
- en: prevents bad deep programs from crashing the system。 Good question is the heap
    shared by different。 threads？ Yes。 So typically there's one heap。 Okay。 So code
    data files heap all one heap。 The reason we， need to have multiple stacks is because
    each thread is all busy running。 It's own sort of recursive， routines and so on。
    And so it needs its own stack。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 防止恶意深度程序崩溃系统。好问题是堆是否被不同的线程共享？是的。通常会有一个堆。好的，代码、数据、文件、堆——都是一个堆。我们需要多个堆栈的原因是，因为每个线程都在忙于运行自己的递归例程等等。所以它需要自己的堆栈。
- en: And of course it has its own registers because it's， doing actual execution。
    Okay。 And how are multiple stacks set up？ Well， this is all part of both the。
    process allocation will give you at least one register and stack。 And then when
    you make new threads， there'll be more of them。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它有自己的寄存器，因为它在执行实际的操作。好的。那么，多个堆栈是如何设置的呢？其实，这部分内容与进程分配有关，它会为你提供至少一个寄存器和堆栈。然后，当你创建新线程时，会有更多的堆栈。
- en: And all of that is done typically at user level or can be done in the， kernel。
    We'll talk about both of those as an option。 Okay。 So we'll get to we'll get to
    more how to build a。 process and make it run as we go on。 So protection and isolation
    together are important。 So why do we， need processes just to remind you for reliability？
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些通常是在用户层完成的，或者可以在内核中完成。我们将讨论这两者作为选择。好的，我们将逐步了解如何构建一个进程并使其运行。所以，保护和隔离是一起重要的。那么，为什么我们需要进程呢？只是提醒一下，这是为了可靠性。
- en: Because bugs can only overwrite the memory of， processes they're in。 So that's
    good。 Security and privacy。 Molishes are compromised processes can't， look at
    other processes data。 Okay。 And fairness to some extent。 So by confining threads
    to a process。 and those processes are protected and manipulated by the operating
    system， it means the operating。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因为错误只能覆盖进程所在的内存区域。所以这是好的，安全和隐私。恶意程序受到限制的进程不能查看其他进程的数据。好的，在某种程度上是公平的。所以通过将线程限制在一个进程中，并且这些进程受到操作系统的保护和管理，意味着操作系统。
- en: system can make sure that no one process can steal all of the resources and
    prevent other。 processes from running。 Okay。 So the protection environment of
    the process with proper scheduling in the。 OS is what lets us build a modern operating
    system where we can guarantee that even malicious things。 that are running can't
    prevent others from running or prevent or steal information。 Okay。 Now the。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 系统可以确保没有一个进程能窃取所有资源并阻止其他进程运行。好的。所以，操作系统中的进程保护环境和适当的调度使我们能够构建现代操作系统，在其中我们可以保证即使是恶意进程也不能阻止其他进程的运行，或防止或窃取信息。好的，现在这个。
- en: mechanisms to make this all work， we've already showed you this idea of address
    translation。 But if。 you think about it， why can't we let a process change the
    page table pointer on its own？ Okay。 Well。 can anybody figure that out？ So why
    can't we let the process that's running change its own。 page table？ And Rizal，
    I'll get to your question in a second here。 Can anybody think about why we。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切工作的机制，我们已经向你展示了地址转换的概念。但如果你仔细想想，为什么我们不能让进程自行更改页表指针呢？好的，有人能弄明白为什么吗？那么，为什么我们不能让正在运行的进程更改它自己的页表呢？Rizal，我会很快回答你的问题。有人能想出为什么我们。
- en: can't let a process change its own page table？ Yeah。 If it could change its
    own page table。 not protected， right？ It could point it at the OS or another process。
    Okay。 And so clearly。 when we're running inside the process， it can't touch the
    page table。 Okay。 And so that means that。 we have to have something about the
    hardware that has those two modes I mentioned that make sure。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不能让进程更改自己的页表？是的，如果它能更改自己的页表，那就不受保护，对吧？它可能将页表指向操作系统或其他进程。好的，显然，在进程内部运行时，它不能触碰页表。好的，这意味着我们必须有一些硬件，它具有我之前提到的两种模式，确保。
- en: that when you're running as a process， you can't mess with the page table and
    only can mess with。 the page table when you go into the operating system， which
    is kernel code that's been vetted。 and is known to be not malicious， at least
    we hope。 Okay。 Now the question here about which I want。 to answer briefly， what's
    the advantage of multi-threading in a single core？
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以进程的形式运行时，你不能随意修改页表，只有进入操作系统时才能修改页表，也就是经过审核且已知无害的内核代码，至少我们希望它是这样的。好的，现在我想简要回答一个问题：在单核中，多线程有什么优势？
- en: And the answer is one of concurrency。 Okay。 So it's not about getting performance
    out of parallelism。 but it's allowing you to have， many things that are starting
    and stopping and waiting on events。 Okay。 And you'll be much more， sophisticated
    about that as you go forward。 So there's a lot of use for multi-threading， even
    when there's only a single core。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是并发。好的。所以这并不是关于从并行性中获取性能，而是允许你有许多事情在开始、停止和等待事件。好的。随着你向前推进，你将会变得更加精通。即使只有一个单核，线程并发也有很大的用途。
- en: And it's not about making things faster， but about dealing with。 the fact that
    you want to overlap computation and IO in an important way。 Okay。 And also making
    sure， that when one thread is waiting， it's not blocking everybody else。 And so
    the fourth concept for today， which we're going to end up with quickly here。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是为了让事情更快，而是为了处理这样一个事实：你想要在一个重要的方式上重叠计算和输入输出。好的。而且还要确保，当一个线程在等待时，不会阻塞其他所有线程。所以今天的第四个概念，我们会很快结束这一部分。
- en: is that hardware has to provide at least two modes， kernel mode user mode or
    supervisor mode。 Okay。 Certain operations prohibited when you're in user， mode。
    Okay。 Like changing the page table pointer。 etc。 And there has to be， when you're
    in user mode， you can't do those things。 And there has to be very carefully controlled
    transitions from user， mode to kernel mode。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件必须提供至少两种模式，内核模式、用户模式或监控模式。好的。在用户模式下有某些操作是被禁止的。好的。比如更改页表指针等。而且在用户模式下，必须有一些严格控制的过渡，不能进行这些操作。用户模式到内核模式的过渡必须非常小心地控制。
- en: So in that case， system calls， interrupts， exceptions， are all examples of。
    transitioning from user mode into kernel mode in a controlled way， which is not
    only going to go。 to kernel mode， but it's also going to make sure that the only
    code that's allowed to run is code。 that's vetted and belongs in the operating
    system。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，系统调用、中断、异常，都是从用户模式到内核模式的过渡的例子，这种过渡是经过严格控制的，它不仅仅是进入内核模式，还确保只有经过审核并属于操作系统的代码才能运行。
- en: So we can't obviously allow the user code to just。 go to kernel mode because
    then it can run anything it wants。 And so we have to control the transitions，
    into kernel mode。 So one example we've mentioned already today was the system
    call idea， which is。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以显然我们不能允许用户代码直接进入内核模式，因为那样它就可以执行任何它想执行的操作。因此，我们必须控制进入内核模式的过渡。我们今天已经提到过的一个例子就是系统调用的概念。
- en: the user process is running along and user mode。 And then it says， hey。 I need
    to do a read from disk。 So it's going to make a system call， which is going to
    do two things。 One， it's going to enter a very， well-defined piece of code， which
    represents the read system call。 And two， that transition is going， to also have
    a transition to kernel mode。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 用户进程正在用户模式下运行。然后它说，嘿，我需要从磁盘读取数据。于是它会进行系统调用，这将做两件事。第一，它会进入一个非常明确定义的代码段，这段代码代表着读取系统调用。第二，这个过渡也会将过渡到内核模式。
- en: So I'm showing it here where there's a single bit， the user。 mode bit is a register
    in the processor。 And we're running up here with the user mode bit set to one。
    But then when we do a system call， we transition to a user to the bit being set
    to zero。 And so now。 the code that's only kernel code is running with a lot of
    privileges。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我展示的是，其中有一个单独的位，用户模式位，它是处理器中的一个寄存器。我们在这里运行时，用户模式位被设置为1。但是当我们执行系统调用时，我们将过渡到用户模式，并将该位设置为0。于是，现在只有内核代码在运行，并且具有很多特权。
- en: and it can do whatever it needs， to， including maybe altering the page tables。
    And then when it returns to the user code， which is like， a return from a function
    call。 but it's a special function call， we will then go back to user mode。 after
    we're inside the user process。 Okay。 So for example， we can now start talking
    about a。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以做任何它需要做的事情，包括可能改变页表。然后当它返回到用户代码时，就像从函数调用返回一样，但这是一个特殊的函数调用，我们将返回到用户模式，回到用户进程内。好的。所以例如，我们现在可以开始讨论一个。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_57.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_57.png)'
- en: diagram like this。 Here's the typical unit system structure。 And by the way，
    I'm running a tiny bit。 late。 If you guys will hold on for another five minutes，
    I want to make sure that we keep a couple。 of things going here。 Okay。 But if
    you look， we can imagine things running at user mode。 These are。 pieces of applications
    and standard libraries that are all up here running without special privilege。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图所示。这是典型的单元系统结构。顺便说一句，我有点晚了。如果你们能再等五分钟，我想确保我们能继续进行几件事。好的。但如果你看，我们可以想象东西在用户模式下运行。这些是应用程序和标准库的各个部分，全部运行在这里，没有特殊权限。
- en: And they can be built by you， linked by you， or other users， any way you want。
    Kernel mode are things that are running with high priority。 And this represents
    things that have to。 be done perfectly。 Okay， they have to be done in a way that's
    not buggy， doesn't allow people to。 have security violations， whatever。 So that's
    important。 Okay。 And so we need to make sure this。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以由你构建，或者由你链接，或者由其他用户构建，按任何你想要的方式。内核模式则是以较高优先级运行的内容。这代表了必须完美执行的任务。好的，必须以一种没有漏洞、不会让人们发生安全违规的方式来完成。所以这很重要。好的。所以我们需要确保这些代码都是完全正确的。好的。
- en: code is all perfectly correct。 Okay。 And if you look now at the hardware， okay，
    that's the lowest。 level。 And typically， kernel mode， only the kernel mode things
    are allowed to actually access。 the hardware。 And that's partially because they
    have the kernel mode bit set。 And the hardware will。 only talk to things when
    the kernel mode bit is set。 Okay。 So we can start looking at the structure。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在看看硬件，好的，那是最低的层次。通常情况下，只有内核模式的程序才能真正访问硬件。这部分是因为它们设置了内核模式标志。硬件只会与内核模式标志被设置时的东西进行通信。好的。所以我们可以开始看看这个结构。
- en: of a typical system this way。 Okay。 So for instance， here now let's look at
    what we've got。 We've got。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 典型系统是这样的。好的。那么现在，我们来看一下我们得到的东西。我们得到了。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_59.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_59.png)'
- en: hardware is this brick wall。 Here's our software。 So we have the core as things
    that are running in。 the carefully vetted kernel mode。 User mode is all the stuff
    that you produced or regular users。 produced。 And what happens is the kernel will
    exact a process。 You'll learn how to do this when。 you do the shell。 It execs
    it， which is loaded into memory off of disk。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件就是这堵砖墙。这是我们的软件。所以我们有核心部分，运行在经过严格审查的内核模式下。用户模式则是你或者普通用户生产的所有内容。发生的情况是，内核会执行一个进程。你们在做Shell时会学到如何做到这一点。它执行这个进程，将其从磁盘加载到内存中。
- en: and then starts it running at， user mode in the startup routine of that file。
    Okay。 That's main typically。 Okay。 And it runs for a， while。 And later when it's
    done。 it'll the process will exit。 And that process will be shut down and， we'll
    be back in kernel mode。 Okay。 Now， meanwhile， from the beginning to the end， things
    can happen， like， well。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会在该文件的启动例程中以用户模式启动。好的，这就是通常的主流程。好的。它会运行一段时间。然后，当它完成时，进程会退出。然后该进程会被关闭，我们将回到内核模式。好的。现在，在这个过程中，从开始到结束，可能会发生一些事情，比如说，嗯。
- en: we could make a system call into kernel mode， and that will get returned back
    to user。 mode when we're done。 Or we could have an interrupt。 So an interrupt
    is an event coming from outside， like a timer that forces from user mode into
    kernel mode。 where stuff will happen。 And then， eventually might access the hardware，
    for instance。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行系统调用进入内核模式，然后在完成后返回用户模式。或者我们可以有一个中断。所以中断是一种来自外部的事件，比如定时器，它将会从用户模式强制切换到内核模式，在那里会发生一些事情。然后，最终可能会访问硬件，例如。
- en: and then eventually return after the interrupt's done。 So that could happen
    if a network packet comes in， etc。 Okay。 And then finally， an exception might。
    be an example where you try to divide by zero， in which case we might enter the
    kernel。 And if。 it's an unrecoverable one， like divide by zero， then we might
    kill off the process。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在中断完成后最终返回。所以如果网络数据包进入，等等，可能会发生这种情况。好的。最后，异常可能是你尝试除以零，这种情况下我们可能会进入内核。如果它是不可恢复的错误，比如除以零，那么我们可能会终止该进程。
- en: If it's a different， type of exception， like a page fault， which we'll learn
    a lot about later。 then it will return。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是不同类型的异常，比如页错误，我们稍后会学习很多关于它的内容。那么它会返回。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_61.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_61.png)'
- en: properly for execution。 Okay。 All right。 So there are different additional layers
    of protection in。 modern systems。 And so for instance， there can be something
    even higher privilege than the operating。 system like the hypervisor。 Okay。 These
    are additional layers of protection where we have what are。 typically called virtual
    machines that let you run an operating system on top of them， where the。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正确执行。好吧。所以现代系统中有不同的保护层。例如，操作系统之上可能会有更高权限的东西，比如虚拟机监控器。好吧。这些是额外的保护层，我们可以在其上运行操作系统的虚拟机，虚拟机使我们能够在它们之上运行操作系统。
- en: operating system thinks it's got full control of the machine。 But the hypervisor
    is multiplexing。 underneath。 Okay。 And that's what you're actually playing with
    right now， is you're getting set up。 with your virtual machines。 Okay。 Now， is
    the OS running in user mode by default？ So again。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统认为它完全控制了机器。但虚拟机监控器正在进行多路复用。其底层是这样的。好吧。而这就是你现在正在操作的部分，你正在进行设置。设置你的虚拟机。好吧。那么，操作系统默认是在用户模式下运行吗？所以，再次问一下。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_63.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_63.png)'
- en: that's a good question to get close to finishing on。 If you look at this for
    a moment。 we have stuff， kernel mode things， which might be the OS， which run
    at kernel mode。 And so there's the code that， touches the hardware and does highly
    privileged things。 Then we have user mode， which is your user， programs that are
    not running that special code。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题，适合接近结尾。如果你看这一点，我们有一些内核模式的东西，这些可能是操作系统，它们在内核模式下运行。因此，这里有接触硬件并执行高度特权操作的代码。然后我们有用户模式，它是你的用户程序，这些程序并不执行特殊的代码。
- en: So the one answer to the is the OS running in user。 mode is the OS is really
    always running in kernel mode。 Okay。 It may not always be actually getting。 cycles
    out of the CPU， though， because it may be in this instance here， where we made
    a here。 we're running in user mode。 And if there's only one CPU， then the OS isn't
    running at all， right。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于操作系统是否在用户模式下运行的一个答案是，操作系统实际上总是运行在内核模式下。好吧。虽然它不一定总是占用 CPU 的周期，因为它可能处于这样的实例中：在这里，我们处于用户模式。如果只有一个
    CPU，那么操作系统根本就不运行，对吧。
- en: isn't running。 The moment we have a system fall into the kernel， now we transition
    into kernel mode。 And now the user mode code isn't running。 And the kernel mode
    code is running， where running means。 has the CPU。 Okay。 Hopefully that's helpful。
    We'll get more of this as we go on。 So I think。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不在运行。我们一旦有了系统进入内核，系统就会转换到内核模式。此时用户模式的代码不再运行，内核模式的代码开始运行，运行意味着占用了 CPU。好吧。希望这有帮助。我们后面会继续讲这个内容。所以我想。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_65.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_65.png)'
- en: I'll give you this last example here。 Okay， I promised five minutes。 So just
    let's look at this。 For instance， let me just show you。 Let's use base and bound。
    Here's the operating system。 Here's two processes。 And we're going to have this
    illusion of processes。 And notice that when。 we're running the operating system，
    we're in system mode。 That's why this is on。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你最后一个例子。好吧，我承诺五分钟。那么我们来看看这个。例如，让我来展示一下。我们使用基本地址和边界。这里是操作系统。这里是两个进程。我们将构建一个进程的幻象。请注意，当我们运行操作系统时，我们处于系统模式。因此，这个开关是打开的。
- en: So this is not a user， mode bit。 This is system mode bit。 The program counters
    pointing into the operating system。 The。 stack pointer is pointing into the stack
    and the OS kernel mode is running。 Now what we're going to do， is we want to start
    running something else like the yellow code。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这不是一个用户模式位。这是系统模式位。程序计数器指向操作系统。栈指针指向栈，操作系统内核模式正在运行。现在我们要做的是，想要开始运行其他内容，比如黄色代码。
- en: So we're about to return from interrupt。 And to do that。 we set up pointers
    to the yellow code in special registers so that when we do a， return to user。
    what happens is the PC gets switched over to the yellow code。 The base and bounds
    will。 now be enforced because the system mode is zero。 So only when we're in system
    mode zero or kernel。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们即将从中断返回。为了做到这一点，我们将指针设置到黄色代码所在的特殊寄存器中，这样当我们执行返回到用户模式时，程序计数器（PC）就会切换到黄色代码。基本地址和边界将会被强制执行，因为系统模式为零。所以只有在我们处于系统模式零或者内核模式时。
- en: mode or excuse me user mode does base and bound get used whereas when we're
    out of kernel mode。 the kernel is free to do whatever it wants。 Okay。 All right。
    So next time I'm going to talk about。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 模式，抱歉，我是说用户模式时，基本地址和边界会被使用，而当我们处于内核模式时，内核可以自由地做任何它想做的事情。好吧。好吧，下次我将讨论。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_67.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_67.png)'
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_68.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_68.png)'
- en: different types of kernel mode transfers。 So in conclusion， today we talked
    about four fundamental。 OS concepts。 Thread， which is a virtualized CPU。 It's
    an execution context fully describes。 a program state program counter registers
    execution flag stack。 And it can be multiplexed。 So there。 can be many more threads
    than there are actual CPU's or cores。 An address space with or without。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的内核模式切换。总之，今天我们讨论了四个基本的操作系统概念。线程，它是一个虚拟化的 CPU。它是一个执行上下文，完全描述了程序的状态，包括程序计数器、寄存器、执行标志和堆栈。并且它可以进行多路复用。因此，线程的数量可以超过实际
    CPU 或核心的数量。地址空间有或没有。
- en: translation is a protected box。 It's the set of all memory addresses accessible
    to the program for。 reader write。 So for a 32 bit CPU， for instance， it's four
    billion values。 Okay。 And it may be distinct， from the physical machine。 That's
    when we start having translations。 We talked about a process， which combines threads
    and address spaces into a useful idea。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译是一个受保护的框架。它是程序可访问的所有内存地址的集合，供读写使用。例如，对于一个 32 位的 CPU，它有四十亿个地址值。好了，它可能与物理机器不同。这就是我们开始进行地址转换的原因。我们讨论了进程，它将线程和地址空间结合成一个有用的概念。
- en: which is a protected address space， with one or more threads。 And then we also
    finally talked about the need for hardware to have two。 modes system and user
    so that we can enforce that certain hardware can't be touched by the user。 in
    order to give us our full protection。 All right。 I have gone over。 Thank you for
    bearing with me。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个受保护的地址空间，包含一个或多个线程。然后我们还讨论了硬件需要有两种模式：系统模式和用户模式，以便我们可以强制执行某些硬件不能被用户访问，以确保我们的完全保护。好了，我已经讲完了，谢谢大家的耐心听讲。
- en: I， hope that everybody has a good rest of their evening and stay safe。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望大家晚上过得愉快，保重身体。
- en: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_70.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80deaa59936768fb1fcdc3b7bf8785ea_70.png)'
