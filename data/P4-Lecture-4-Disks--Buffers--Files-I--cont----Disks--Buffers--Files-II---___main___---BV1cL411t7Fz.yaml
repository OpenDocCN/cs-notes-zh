- en: P4：Lecture 4 Disks, Buffers, Files I (cont) + Disks, Buffers, Files II - ___main___
    - BV1cL411t7Fz
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P4：讲座 4 磁盘、缓冲区、文件 I（续）+ 磁盘、缓冲区、文件 II - ___main___ - BV1cL411t7Fz
- en: of 186。 So just a few announcements to begin with。 So first of all。 the second
    vitamin will be released today after lecture that will be due next Thursday。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 186号。所以，首先有一些公告。第一，第二次作业将会在讲座结束后发布，截止时间是下周四。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_1.png)'
- en: The first project will be due this Thursday。 I hope you guys are enjoying and
    having fun and writing good sequel queries。 And there will also be a project office
    hour and also party tonight between seven to nine Pacific time。 So the project
    party is actually something new that we are trying out on the on the TA website。
    It's actually something that we try to encourage you guys to work with each other
    and also try to find project partners。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目将在本周四截止。我希望你们都在享受、玩得开心并且写出优秀的 SQL 查询。今晚在太平洋时间7点到9点之间，还会有一个项目答疑时间和聚会。所以，项目聚会实际上是我们在助教网站上尝试的新形式。我们鼓励你们相互合作，并且寻找项目合作伙伴。
- en: So hopefully that might work。 And if you guys have any feedback about that feature。
    just let us know as well because that's something that is relatively new。 And
    as you may know。 we try to post weekly announcements on PS sub in the beginning
    of the weeks。 just to tell you guys like， you know， keep track of things and like，
    you know。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个方法可行。如果你们对这个功能有任何反馈，也请告诉我们，因为这是一个相对新的尝试。正如你们所知，我们会在每周初发布每周公告，确保大家能够跟上进度，了解事项。
- en: mentioned deadlines and so on and so forth。 So please make sure that you also
    check that out as well in addition to announcements during classes。 Okay， so going
    back to the material。 So last week we were talking about。 different components
    in a database management system。 Right。 So we have this kind of layered approach
    where you see all these different。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 提到了截止日期等等，请确保在课堂之外也查看这些内容，除了课堂上的公告。好了，回到材料部分。上周我们在讨论数据库管理系统中的不同组件。对吧。所以我们采用了这种分层方法，展示了所有这些不同的。
- en: top going from top down parsing the input query all the way down to managing
    disc buffers in the file system for which the data is actually stored。 So we started
    off by talking about the lower the lowest the most the lowest component in a database
    management system。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部到底部解析输入查询，一直到管理文件系统中的磁盘缓冲区，数据实际上就存储在这里。所以我们从谈论数据库管理系统中最底层的组件开始。
- en: basically talking about the disk。 And then last Thursday。 I was talking about
    this kind of hierarchy that you guys may already be familiar with right so we
    go all the way from the fastest kind of。 data retrieval mechanism by storing things
    in registers that are local to CPUs all the way down to this right and even like
    you to take right if you can't give you a kind of old fashioned right。 So the
    difference between the time that it takes to retrieve data is tremendous right
    you can see that here everything from 0。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上是在讲磁盘。然后，上周四我讲了这种你们可能已经熟悉的层次结构。所以我们从最快速的数据检索机制开始，通过将数据存储在与CPU本地相关的寄存器中，一直到最底层，甚至像传统的写入操作，虽然它可能是“过时的”写入方式。所以，检索数据所需的时间差异是巨大的。你可以看到这里的差距，从
    0 开始。
- en: 5 nanoseconds all the way down to like you know 20 milliseconds right so that's
    actually a lot of。 substantial time difference between between these between different
    layers in the hierarchy。 And then I also started mentioning about the different
    components of a disc which consists of platters and a simply of arms or otherwise
    known as these。 arm assembly with disc heads and basically the disc has spin around
    as the platters go around it and then the area right or the or the circle that
    is basically marked by the by the disc has is basically known as the。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从 5 纳秒到 20 毫秒，这中间的时间差非常大。所以这些不同层次之间的时间差非常显著。而且我还开始提到磁盘的不同组件，包括盘片和臂组件，或者说这些由磁盘头组成的臂组件。基本上，磁盘会旋转，盘片围绕它转动，而磁盘上标记的区域，或者说磁盘上的圆圈部分，就被称为。
- en: cylinder。 Now each we basically talk about reading things from from in terms
    of sectors。 So basically， as we spin to like a specific area that we want to read
    on the platter。 Then basically lower down the disc head and then read data out
    underneath basically underneath that underneath the disc head and then the area
    that is the arc being swept right it's basically known as the sector。 So if this
    is all like kind of sounding foreign to you。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 圆柱体。现在，我们基本上在讲解如何从**扇区**中读取数据。所以基本上，当我们旋转到唱片上我们想要读取的特定区域时，然后将磁头降低，读取位于其下方的数据，然后扫过的区域就是**扇区**。如果这些概念对你来说有些陌生。
- en: I mean one good analogy is actually the turntable which some of you may have
    already been really with right so in this analogy basically see that the vinyl
    disc right is our platter。 This assembly is basically known also called the arm
    assembly and then you know and at the very tip of it right is basically the disc
    reading head。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我想一个不错的类比其实是唱盘，可能你们中的一些人已经很熟悉了。所以在这个类比中，我们可以看到黑胶唱片就是我们的磁碟。这个组件也被称为臂组装，在它的最尖端，基本上是磁头。
- en: So it's actually this exact same thing that we have here。 except that you can
    imagine now we basically growing 3D。 So we have multiple layers of these platters
    right so that's what you see on the previous picture。 So we again have the same
    set of platters we have the same setting， same armor， sample。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其实这和我们现在所看到的完全相同。只不过可以想象，我们现在是3D的结构。所以我们有多个层次的这些磁碟，这就是你在前面图片中看到的。我们仍然有相同的磁碟，设置、臂组装、样本。
- en: same kind of disc head right except that in the in the old style right like
    you know we're talking about these vinyl records as opposed to。 magnetic platters
    but the but the mechanism is pretty much the same so like how do we actually read
    right well we have to basically just like the turntable we have to basically spin。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的磁头，除了在旧式的情况中，我们讲的是这些黑胶唱片，而不是磁碟，但其机制基本是相同的。那么我们到底是怎么读取的呢？其实我们必须像唱盘一样，旋转磁碟。
- en: The arm assembly right to the right place move the head to the place that we
    actually want to read right and then lower the disc heads to basically touch the
    record。 So the same thing also happens in the magnetic disc right so here。 Basically
    we break it down to three different components in terms of the time that it takes
    to to read this block。 First we have the sick time right as I said this is basically
    moving the arm right to the position where we actually want to read。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 臂组装部分会移动到正确的位置，然后将磁头移到我们实际想要读取的位置，接着将磁头降低，基本上接触到唱片。所以在磁盘的情况也是一样的，在这里。基本上我们将其分解为三个不同的部分，根据读取这个区块所需的时间。首先，我们有**寻道时间**，正如我所说，这基本上是将臂移动到我们实际想要读取的位置。
- en: Then we have the rotation of the layer because we basically need to wait for
    the platter to go to get to the sector that we actually want to read I mean just
    like in the vinyl record case right。 And then finally the time that it takes to
    transfer data I once we lowered the disc reading head just like in good old fashioned
    turntables。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是层的旋转，因为我们基本上需要等待磁碟旋转到我们实际想要读取的扇区，正如黑胶唱片的情况一样。最后是传输数据所需的时间，一旦我们将磁头降低，就像经典的唱盘一样。
- en: Now the first the last part like you know in terms of transfer time we can't
    really control right because like you know we have to read the data off from the
    platter so that。 We can't really control anything but the first two part here
    is what we would really try to minimize right because that's strictly overhead
    right we don't really need that in any possible。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一部分，比如说在传输时间方面，我们其实无法控制，因为我们必须从磁碟上读取数据。我们无法控制任何事情，但前面提到的两部分是我们真正想要最小化的，因为它们严格来说是开销，我们不需要这些任何多余的操作。
- en: But then of course like things don't always work out that way。 So these are
    the basic components that you need to know about magnetic disc when we talk about
    reading them。 So how about flash right or solid this stripe right some of you
    already have probably like you saw this drive on your laptop for instance。 So
    the technology is different here so first of all they are not organized into platters
    they actually organized into cells so one of them I highlighted here in red so
    that's basically a cell on a solid disc drive。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，事情并不总是按预期的那样发展。因此，这些是你在谈论磁盘读取时需要知道的基本组件。那么闪存呢？或者说固态硬盘呢？你们中的一些人可能已经在自己的笔记本电脑上看过这种硬盘了。所以这里的技术不同，首先它们不是按盘片的方式组织的，而是按单元格组织的，我在这里用红色标出了其中一个，这基本上就是固态硬盘上的一个单元格。
- en: And then with the current generation of technology using nandex。 It's different
    in the sense that we can actually perform random reads and writes so we're not
    like the turntable thing where we have to wait for the platter to turn to the
    right place and then lower this cat and all that all that good stuff so that's
    actually gone。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在当前一代使用NAND闪存技术的设备中，它的不同之处在于我们可以进行随机的读取和写入。所以我们不再像旋转盘那样等待磁盘旋转到正确的位置，然后再将磁头放下，所有这些操作都已经不再需要了。
- en: Except that the reads and writes actually at different granularity。 So we can
    do really fine green weeds in terms of individual cells but then for writes it's
    actually preferable that we do like you know multiple cells at the same time。
    That's just like you know the background technology for solid this solid state
    drives。 And another thing you need to know about this is that the route while
    the week is actually really fast because like again right we don't have to wait
    for the arm there's no arm assembly we're not moving anything。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取和写入实际上是不同粒度的这一点。我们可以对单个单元格进行非常细粒度的读取，但对于写入，实际上最好是一次写入多个单元格。这就像固态硬盘（SSD）的背景技术一样。还有一点你需要知道的是，读取虽然非常快，但写入也很快，因为我们不需要等待机械臂的移动，也没有机械装配，我们不在移动任何东西。
- en: We're not waiting for things to be spinning around so that's great and it's
    also quite predictable right because we're just retrieving data from any of the
    cells and then all the cells basically have read。 A mechanism attached to them
    already so we're not waiting for anything to be spinning。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要等待东西旋转，这点很好，而且它也非常可预测，因为我们只是从任意一个单元格中检索数据，然后所有单元格基本上都有读取机制，所以我们不需要等待任何东西旋转。
- en: That's great but then right unfortunately actually it's not that predictable
    in terms of time。 Why well it turns out that every single cell that we have on
    a solid state disc or flash drive actually can only be written。 For its limited
    number of times the typical number that you get these days is around like 3000
    times for instance before they would just fail。 Fail in a sense of like not being
    able to erase it right because if we want to write it write something to it we
    first have to erase whatever that is on there and then like you know write the
    new values right。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但遗憾的是，从时间上来说其实并不是那么可预测。为什么呢？事实证明，我们在固态硬盘或闪存驱动器上每个单元格的写入次数是有限的。现在的典型数量大约是3000次左右，超过这个次数后它就会失败。失败的意思是不能再擦除它了，因为如果我们要向其中写入数据，首先必须擦除原来的数据，然后再写入新数据。
- en: So turns out that like you know that is we can't do that infinitely we can only
    do that for a finite number of times。 So when a cell actually dies right or like
    you know cannot be raised anymore。 Then we actually need to find another cell
    that is available to write the data to。 So that is a process known as we're leveling
    and just because of the fact that we can predict you know which cell is going
    to fail right so when we try to write a bunch of data we might actually ended
    up like you're jumping around。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，事实证明我们不能无限次地做这个操作，只能做有限次数。当一个单元格“死掉”或无法再擦除时，我们实际上需要找到另一个可用的单元格来写入数据。这是一个被称为“均衡写入”的过程，正因为我们不能预测哪个单元格会失败，所以当我们尝试写入大量数据时，可能会跳来跳去。
- en: Quite a few cells before actually finding places for them。 So that's why like
    right times actually it's not that predictable in general for solid for flash
    drives。 Any questions so far。 I have a question。 Yeah。 So does that mean that
    solid state drives have like a very low lifespan then because I'm guessing between
    two and three thousand years like that that's going to happen in the story。 Very
    low what。 Very low like lifespan like well they like if I have a solid state drive
    does that mean it'll probably fail within a few years。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到足够的存储位置之前，实际上会有很多单元被擦写。这就是为什么在一般情况下，对于固态硬盘来说，擦写次数并不那么可预测。有任何问题吗？我有一个问题。是的。那是不是意味着固态硬盘的使用寿命非常短，因为我猜测两千到三千年之类的，硬盘可能就会坏掉。非常短？非常短的使用寿命？就是说，如果我有一个固态硬盘，是否意味着它可能会在几年内就坏掉？
- en: Not really because of the fact that you actually have tons and tons of cells
    and they saw this drive。 And there's actually also redundancy built into it。 So
    typically when they announced when they tell you that you know this is let's say
    one terabyte storage right there actually is typically more than cells that are
    enough to hold one terabyte of data because they will really have redundancy in
    place。 So but yeah I mean eventually things will die off right because of the
    fact that like you know things cannot be we cannot rewrite them infinitely。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其实不是，因为你实际上有大量的存储单元，而且这些硬盘通常内置冗余机制。因此，通常当他们告诉你存储是比如说1TB的时候，实际上存储单元是比1TB数据所需的多一些，因为它们会有冗余。所以，但最终还是会坏掉，因为你知道，存储单元不能无限次地重写。
- en: Oh， cool。 Thank you。 Yeah。 Any other questions。 Hi does it cause lots of time
    to erase the information that we write on the SSD。 So it depends on the technology
    that we're talking about for NAND GAKES。 I mean usually it doesn't take that much
    time to erase compared to let's say like magnetic disks。 And for the purpose of
    this class you pretty much don't need to worry about that。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，酷。谢谢。是的。还有其他问题吗？嘿，擦除我们写入SSD上的信息会花费很多时间吗？这取决于我们讨论的技术，比如NAND GAKES。我的意思是，通常擦除的时间并不像磁盘那样长。而且在本课程中，你基本上不需要担心这个问题。
- en: I mean just like you know need to know about the only thing that you probably
    need to keep in mind is just that like you know with them right can take different
    amount of time。 And right in particular can be unpredictable。 Okay， thank you。
    Oh yes I have questions。 Yes。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，就像你知道的，你唯一需要记住的事情可能就是，它们的擦写时间可能会不同，尤其是写入时间，特别是写入时间可能是不可预测的。好的，谢谢。哦，是的，我有问题。是的。
- en: Pansita。 Compared to the disk mechanical well which one would last longer in
    the same amount of use。 So that's really hard to say usually flash drives like
    if you compare one individual cell I mean that's usually with tier with basically。
    tier down more quickly than let's say like a magnetic disk right if that's your
    point of comparison。 But like with technology advancing these days it's really
    hard to tell because like you know we have newer generations of flash this every
    year。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pansita。与机械硬盘相比，在相同的使用条件下，哪个会更耐用？这个问题很难回答，通常闪存驱动器如果你比较单个单元的话，它的衰退速度会比磁盘要快一些，如果你拿它与磁性硬盘做对比的话。但随着技术的进步，现在真的很难说，因为你知道我们每年都有更新的闪存技术。
- en: And also there are more and more redundancy mechanisms built into it so that
    like you know they actually can tolerate quite a bit of these errors。 So it's
    really hard to say I guess that's the bottom line。 I see。 Thank you。 Cool。 Okay。
    so for the purpose of this class right that's all you need to know and as I said
    last time on Thursday if you're interested in this there's actually。 quite a number
    of classes that you can take both in the computer science and also in the electrical
    engineering department here。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 而且现在有越来越多的冗余机制内置在其中，这样它们就可以容忍更多的错误。所以很难说，我想这就是底线。我明白了。谢谢。酷。好的。所以对于本课程而言，你只需要了解这些。就像我上次在星期四说的，如果你对这个感兴趣，实际上有很多课程你可以参加，既有计算机科学的，也有电气工程系的课程。
- en: You can actually go and design your own memory as well there are actually a
    classes that you can take to actually learn about those techniques。 Okay， so like
    you know for us right we want to talk about this space management so now that
    you know like how they're like the technology fundamentals of this right how do
    we actually talk about managing this space。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上也可以自己设计内存，实际上有一些课程可以帮助你学习这些技术。好吧，像你知道的那样，对于我们来说，我们想讨论的是空间管理。所以现在你知道了这些技术的基本原理，我们该如何讨论如何管理这些空间呢？
- en: Well， so we first talk about writing and writing chunks of data right chunks
    of bikes basically。 And as you can imagine writing things that are sequentially
    to a right mix to each other is usually usually the fastest。 And they are actually
    for different reasons right for for a magnetic disc。 The reason is because like
    you know we are literally waiting for the arm to spin around right think about
    the wine。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们首先谈论的是写入数据块，基本上是数据块的写入。正如你所想的那样，将顺序数据写入到相邻的位置通常是最快的。实际上，这有不同的原因。对于磁盘来说，原因是因为我们实际上在等待磁头旋转，就像想象一下唱片的转动一样。
- en: the vinyl record again right。 So obviously we can read things that next to each
    other or we can write things that needs that next to each other that's great right
    because then we're not waiting for the for the armor assembly to move or and we're
    not waiting for like you know that this cat to kind of raise。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提到黑胶唱片的例子，对吧？显然，我们可以读取相邻的数据，或者写入相邻的位置，这很好，因为那样我们就不需要等待磁头的移动，或者不需要等待磁碟的提升。
- en: Raise up and then like you're lower again right at the appropriate spot so that's
    why that's great and then for the for the right right I mean on and a similar
    reason for the right on。 Sorry similar reason for reading sequential stuff on
    a flash disc as well。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 抬起，然后像你在适当的地方再次降低对吧？所以这就是为什么它很棒，然后对于右边的部分，我的意思是，类似的原因也适用于闪存磁盘上读取顺序数据。
- en: because reading things in a sequential way turns out to be faster than compared
    to let's say like if you need to write to。 Non consecutive places in the flash
    this right just because of the fact that there's where leveling that I was talking
    to you earlier。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为顺序读取比起随机写入（例如写入闪存磁盘中非连续的位置）要更快，原因是正如我之前跟你们提到的，闪存有磨损均衡机制。
- en: So those are basically some of the principles， so what people usually do right
    is they basically try to predict behavior。 Since we know that like you know reading
    and writing sequentially it's good。 So how did you do that so they do that by
    basically trying to you know cash things that might be used in the near future
    so that's something called prefetching。 They try to cash data that has been frequently
    used right in hoping that they might get reused like very quickly so that's caching。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些基本上是一些原理，那么人们通常怎么做呢？他们基本上会尝试预测行为。既然我们知道顺序读取和写入是比较好的，那么他们是怎么做到的呢？他们通过尝试缓存可能在不久的将来会被使用的内容来实现这一点，这就叫做预取。它们会尝试缓存那些频繁使用的数据，希望它们能够很快被重复使用，这就叫做缓存。
- en: And then they also try to buffer rights right such that like you know we might
    end up even though initially we are seemingly writing to random this blocks but
    then if we collect enough of them。 we might actually end up writing in a sequential
    way and that's great right so that's called buffering rights。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们还会尝试缓存写入操作，确保即使我们最初似乎在写入到随机的块中，但如果我们收集足够多的数据块，最后可能会以顺序的方式写入，这是很好的，这叫做缓冲写入。
- en: so we'll see some of these techniques as we actually go for a long in the class。
    But then for for now like you know let's try to unify right because they're all
    these different this technologies out there。 I mean like let's just try to come
    up with some common terminology。 such that we can talk about them。 So we're going
    to use block as the basic unit of transfer for all kinds of different disc so
    it doesn't matter whether this is magnetic or whether this is SSD or something
    else。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在实际上课时会看到一些这些技术。但现在，像你知道的那样，我们先尝试统一一下吧，因为现在有这么多不同的技术存在。我是说，让我们尽量想出一些共同的术语，以便我们能谈论这些技术。所以我们将使用“块”作为所有不同磁盘的基本传输单元，因此无论是磁性硬盘还是固态硬盘，或者其他类型的磁盘，都没关系。
- en: And you know typical numbers range from like you know 64 kilobytes and your
    book says like you know four kilobytes I mean that's somewhat arbitrary I would
    say。 So every technology is different and every kind of device is different I
    mean for now we just want some common terminology such that we can talk about
    things together。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，典型的数字范围大概是64千字节，而你的书中提到的是4千字节，我觉得这有点随意。每种技术和每种设备都是不同的。现在我们只想要一些共同的术语，这样我们才能一起讨论这些问题。
- en: And then like you know just to confuse ourselves right so people also use this
    term called page which is basically a synonym for block。 You might see that happening
    in like you know different textbooks so just to just to be aware and some textbooks
    even use page as the unit of memory of main memory right so just to be even more
    confusing。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了让自己更加困惑，人们还使用了“页面”这个术语，实际上它是块（block）的同义词。你可能会在不同的教科书中看到这种情况，所以要注意一下。有些教科书甚至把页面当作主内存的单位来使用，这样就更容易让人困惑了。
- en: But we'll make sure that the context is clear when we actually use this term
    in different in different ways。 but for now we just treat these two synonyms。
    Okay。 so for a database managed system management system right what we call disk
    space management is really the way that we try to manage all these disks blocks
    that are available for us right to read and write data。 It maps pages to actual
    physical locations on the disk right so the so the abstraction that we expose
    to the higher level is basically reading and writing on pages。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们会确保在不同的语境中使用这个术语时，语境是明确的。现在，我们把这两个术语视作同义词。好的，对于一个数据库管理系统来说，我们所说的磁盘空间管理，实际上就是我们管理所有可用于读写数据的磁盘块的方式。它将页面映射到磁盘上的实际物理位置。因此，我们向上层暴露的抽象就是基本的页面读写操作。
- en: But then underline the cover in the implementation we need to figure out right
    and you're where exactly are we going to write onto onto the disk and vice versa
    right we also need to be able to load pages by looking up like you're where a
    specific page actually lives on the disk and then load it accordingly into memory。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在实现中需要重点考虑，我们需要弄清楚到底应该在哪里写入磁盘，反之亦然，我们还需要能够通过查找具体的页面在磁盘上的位置来加载页面，然后根据需要加载到内存中。
- en: So and so forth， so high levels and basically use this interface to read them
    write a page and they can also use this to figure out like how many pages to allocate
    and the so on so forth。 So there are different things that we need to worry about
    for this space this space management。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如此等等，高级别的基本上使用这个接口来读取它们，写入一个页面，它们也可以利用这个接口来确定分配多少页面，等等等等。所以我们需要关注的是这一空间，这一空间的管理。
- en: So here's like common mechanism a common medium for which we would use this
    component。 So here。 let's say like you know sailors is the name of a table that
    we would try to put that we would like to read。 So the way that we implement。
    Or we utilize them this kind of like disk space management component is by first
    trying to start from a page inside of the sailors table。 Let's say the very first
    page in the in the table because we want to read all the tools from it。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个常见的机制或媒介，我们会使用这个组件。例如，假设“sailors”是我们要读取的表的名称。我们实现或使用这种磁盘空间管理组件的方式是，首先从“sailors”表中的一个页面开始。假设是该表中的第一个页面，因为我们想要读取其中的所有数据。
- en: We get to a page and then we basically go through a loop right that says like
    you know for each of the page that we read。 We'll just do some processing。 This
    can be like you know filtering or whatever query that we're trying to accomplish。
    And then we just call next page to fetch us the next page that we want to process
    and then then the process goes on until we are done right done can be like you
    know the query has completed or we have written everything back to the disk whatever
    that means。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个页面后，基本上会进入一个循环，这个循环会遍历每个我们读取的页面。我们会进行一些处理，比如过滤或其他我们想要完成的查询。然后我们调用“下一页”来获取我们想要处理的下一页，直到处理完成。完成的标准可以是查询完成，或者所有数据已经写回到磁盘，等等。
- en: The thing to notice here is basically that we are assuming here that next page
    right this call is fast。 And that echoes back to what I was saying earlier right
    we're assuming that writing sequential pages is good for different kinds of this。
    So that's why the interface that we're exposed to the higher level in the system
    is basically this you know get a pointer。 So like the first page or whatever page
    that we want followed by a bunch of next page calls right。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的事情是，我们假设下一页（即这个调用）是快速的。这和我之前说的呼应，我们假设顺序写入页面对不同类型的设备是有效的。所以我们暴露给系统更高层的接口基本上是这样的，你知道，获取指针。比如说我们想要的第一页或任何其他页面，接着是一个接一个的下一页调用。
- en: So this is the API that we'll see and this is the common idiom that you also
    see when people try to utilize the space management components。 That makes sense。
    Okay， okay， so now let's talk about like how to actually implement right so given
    that this is what we this is the API that we're exposing to the higher layers
    I mean how do we actually implement the actual mechanism underlying the covers
    right。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们会看到的 API，这也是当人们尝试使用空间管理组件时常见的做法。这是有道理的。好，现在我们来谈谈如何实现。既然这是我们暴露给更高层的 API，那我们究竟该如何实现这个底层机制呢？
- en: There are two proposals here that I want to mention for this class。 So the first
    one is we talk to the storage device directly。 So if we have a magnetic disk then
    like you know we just go and like you know figure out like you know how to move
    the arm you know how to how much to spin and then when to actually lower the the
    read head and then like transfer data for example right。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我想提到两个建议。第一个是我们直接与存储设备进行交互。所以如果我们有一个磁盘驱动器，那么我们就去了解如何移动磁臂，如何控制旋转速度，以及何时降低读写头，然后转移数据，举个例子。
- en: So that's easy that's great。 In fact that's actually really good right if you
    actually know your device well。 So you can actually implement your own device
    driver right specialized for the database management system that we're building。
    So that's awesome。 The downside however is that like you know each of these divide
    each type of devices tend to have their own API in terms of like you're moving
    arms or like you're reading a cell right on a flash drive or finding another one
    to actually put something to。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很简单，很棒。事实上，如果你非常了解你的设备，那其实真的很不错。所以你可以实际实现你自己的设备驱动程序，专门为我们正在构建的数据库管理系统量身定制。这太棒了。然而，缺点是每种设备，每种类型的设备往往都有自己的
    API，比如你在移动磁臂，或者在读取闪存驱动器上的一个单元，或者找到另一个位置来存储数据。
- en: So like you know you basically need to master all these different APIs and also
    implements it efficiently。 So and then also right what happens if you add something
    new to it right so now we need basically need basically need to change our disk
    management component right。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你基本上需要掌握所有这些不同的 API，并且高效地实现它们。那么如果我们往系统中加入新东西，会发生什么呢？所以现在我们基本上需要更改我们的磁盘管理组件。
- en: So that's one downside。 The upside of course is that like you know this is highly
    specialized so we can get really good performance of it if you know how to do
    that。 So we can talk to the operating system。 When talk to the operating system
    because the operating system is already managing the file system for us。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个缺点。当然，优点是，这种方式是高度专门化的，所以如果你知道如何操作，它可以带来非常好的性能。所以我们可以与操作系统进行交互。和操作系统交互的原因是操作系统已经为我们管理了文件系统。
- en: So in a sense we're kind of like shielded away from all these low level device
    like you know driver management issues right by using the operating system。 So
    actually bypass the OS in the sense that we don't want the OS to be managing the
    files for us per se。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上来说，通过使用操作系统，我们把自己从这些低层设备驱动管理问题中隔离开了。所以，实际上我们是在绕过操作系统，我们不希望操作系统为我们直接管理文件。
- en: because the OS might be actually you know writing back parts of the file or
    like you know reading or prefashing different parts of the file while we are trying
    to process a query。 And the operating system probably doesn't know what kind of
    query or what kind of processing we would like to do right on a given file。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作系统可能实际上会在我们尝试处理查询时，写入文件的某些部分，或者读取或预取文件的不同部分。而且操作系统可能并不知道我们在某个给定的文件上想要执行什么样的查询或处理。
- en: Another opportunity another proposal to implement this management system here
    is to basically say that will bypass the OS by just asking the OS to just give
    me a humongous file on an empty disk。 and then we pretend to be the owner of that
    file for the time being for the time remaining。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现这个管理系统的方案是基本上通过要求操作系统给我一个巨大的文件存储在空磁盘上，从而绕过操作系统。然后，我们暂时假装自己是这个文件的拥有者，直到剩余的时间结束。
- en: So as long as we're processing queries we just pretend to the OS that like you
    look I mean we are managing that this like a huge huge file on our own。 Don't
    touch it。 Don't we don't send anything back to the disk will do that explicitly
    by calling like you know the OS interfaces。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以只要我们在处理查询，我们就假装告诉操作系统，看，我的意思是，我们正在管理这个巨大的文件。不要碰它。我们不会把任何数据返回到磁盘，我们会通过调用操作系统接口明确地做到这一点。
- en: And like you know don't prefetch anything will tell you what to that right so
    and so forth。 So in some sense we're just like hijacking the OS in that sense
    by doing our own this manage this management。 And this is this can be great right
    because now we have abstracted from like the low level device driver details。
    And we are just basically doing our own management at the block level at the page
    level if you will right for your basically management on file。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你知道的，不要预取任何东西，我们会告诉你该怎么做，诸如此类。所以在某种意义上，我们通过进行自己的磁盘管理，实际上是劫持了操作系统。而且这可以非常好，因为现在我们从低级设备驱动程序的细节中抽象出来。我们基本上在做自己的块级管理，页面级管理，如果你愿意的话，就像是文件管理。
- en: So that's like another way you can imagine implementing the disk space management
    system。 And you know this file right might as well span across multiple disk or
    even machines that we want to right as long as the operating system provides an
    interface to actually allocate for a file that looks that way。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是另一种实现磁盘空间管理系统的方式。而且，你知道，这个文件可能跨越多个磁盘甚至机器，只要操作系统提供了接口来为这样的文件分配空间。
- en: Then we just tell the operating system to just cut like you know shut up and
    then we'll just like you know manage the whole thing on our own。 So in summary
    like you know just now what we're talking about is just basically some very simple
    technology about like saw state and also magnetic disk。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就告诉操作系统，闭嘴，然后我们就自己管理整个事情。总的来说，我们刚才讨论的就是一些非常简单的技术，涉及到磁带和磁性磁盘。
- en: And then I started talking about the cost of doing different things right so
    the thing to remember is basically that accessing the disk can be very dramatic
    in terms of cost compared to like you know read accessing data from the registered
    local to the CPU。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我开始讨论做不同事情的成本问题。所以需要记住的一点是，访问磁盘的成本相较于从寄存器本地读取数据到CPU中可能非常高。
- en: And also we just talk about like very briefly about different interfaces that
    the disk storage manager can expose and also a little bit about how to implement
    them。 And then that's it。 So now I'll switch over to a bit here。 And if you have
    any questions please feel free to raise your hand。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要讨论了磁盘存储管理器可以暴露的不同接口，并简要介绍了如何实现这些接口。然后就这些。现在我将切换到其他内容。如果你有任何问题，请随时举手。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_3.png)'
- en: Perfectly clear。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 非常清楚。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_5.png)'
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_6.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_6.png)'
- en: Yes， read things and sequences good yes。 Okay， can you folks hear me。 Okay，
    all right。 Okay。 so carrying on where I'll then left things。 Okay， so we are talking
    about how now that we know what's happening at the bottom layer so basically in
    terms of a relation that may be stored across many different files managed by
    a file system。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，读取顺序很重要，是的。好，大家能听到我吗？好，行。那么，接下来我们继续之前的内容。我们正在讨论现在我们已经知道底层发生了什么，基本上在关系中，数据可能存储在多个由文件系统管理的文件中。
- en: So given that abstraction from a database perspective you may imagine the following
    sort of subdivision so each table or each relation is stored in one or more OS
    files。 And each file may contain many pages right so we talked about how pages
    and blocks are analog so each file would contain many pages of data。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库的角度来看，考虑到这种抽象，你可以想象以下几种划分方式：每个表或每个关系存储在一个或多个操作系统文件中。每个文件可能包含多个页面。我们之前讨论过页面和块是类似的，所以每个文件会包含许多数据页。
- en: And each page contains many records。 Okay， so， and so again records a synonym
    for tuple。 And so each page will contain many such records。 So this notion of
    pages or blocks is basically the common currency that's understood by multiple
    layers of a database system。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面包含许多记录。好吧，因此，“记录”是元组（tuple）的同义词。因此，每个页面将包含许多这样的记录。因此，这种页面或块的概念基本上是数据库系统多个层次之间共享的“通用货币”。
- en: On the disk it's sort of managed by this disk space manager it's sort of allocating
    pages to disks to to to to to files on disk。 So these are read or written to these
    files on the disk。 So this could be again a solid state drive disk or hard drive。
    In memory it's managed by the buffer manager。 Right。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘上，它由磁盘空间管理器进行管理，磁盘空间管理器负责将页面分配到磁盘上的文件。因此，这些页面会被读入或写入磁盘文件中。这些文件可以是固态硬盘（SSD）或传统硬盘（HDD）。在内存中，它由缓冲区管理器进行管理。没错。
- en: so it's managed by the buffer manager and higher levels of the database system
    beyond the buffer manager everything above operate on data in memory。 So in order
    to operate on a data operate on a page。 you need to first bring it into memory
    to operate on it。 So the buffer managers role is to sort of bring the page in。
    So once a page is in the buffer。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它由缓冲区管理器管理，数据库系统的更高层次则操作内存中的数据。为了操作数据，操作的是页面。你需要先将页面加载到内存中才能操作它。因此，缓冲区管理器的角色就是将页面加载进来。一旦页面进入缓冲区，
- en: it can sort of operate on it。 Okay， so next， let's talk about sort of how these
    how given relation is laid out across different pages in a given file。 Alright，
    so let's talk about the single table for now so we can let's not worry about multiple
    tables the same ideas apply for multiple tables so a single table for now。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以操作这些内容。好吧，接下来，让我们讨论一下如何在给定文件的不同页面之间布局给定的关系。好吧，现在我们先讨论单一表格，所以我们先不担心多个表格，多个表格的相同概念也适用。所以现在讨论一个单一表格。
- en: And we'll talk about the notion of a database file and this is an abstraction
    that captures the information for a single table。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论数据库文件的概念，这是一个抽象，表示单个表格的信息。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_8.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_8.png)'
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_9.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_9.png)'
- en: And here we're talking about a collection this file contains a collection of
    pages of blocks and each of these pages of blocks contain a collection of records。
    So， for higher layers of the database system， they basically can sort of use sort
    of。 they don't need to worry about where the pages are on this they can use higher
    level abstractions to refer to information across pages。 So， for example， fetch
    a specific record by referring to the quote unquote record ID and record ID is
    a pointer which is encoding the pair of information。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们讨论的是一个集合，这个文件包含一组页面或块，每个页面或块包含一组记录。因此，对于数据库系统的更高层次，它们基本上可以使用更高层次的抽象来引用页面上的信息，而不需要担心页面具体的位置。例如，可以通过引用所谓的记录ID来获取特定记录，记录ID是一个指针，编码了包含信息的配对。
- en: which is the page ID and the location within a page。 Another important API call
    that we may want is just can all of the records so and when you're scanning all
    of the records you may additionally have some conditions on the record should
    be retrieved。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它的标识符是页面ID以及页面中的位置。我们可能需要的另一个重要API调用是扫描所有记录。在扫描所有记录时，你可能还会对需要检索的记录施加一些条件。
- en: So， you want all of the students who is GPA is greater than 3。5 right so that
    could be a condition that you may have on the records that are retrieved。 So this
    is the read API the then you have the update API so you may want to insert delete
    or modify records。 So we were talking about a single table for now and a single
    table could span multiple operating system files and in fact even machines。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你想要获取所有GPA大于3.5的学生，对吧？这可能就是你在检索记录时可能施加的条件。这是读取API，然后你会有更新API，你可能需要插入、删除或修改记录。我们现在只讨论一个单一表格，一个表格可能跨越多个操作系统文件，实际上甚至可能跨越多个机器。
- en: but let's not worry about all of that for now let's talk about a single file
    which contains multiple pages of records。 So， before before we get into the details
    of how these pages are laid out。 there are multiple different database file structure
    so information for a given relation could be stored across multiple different
    modalities。 And we're going to be talking primarily about one modality for now
    which is the on ordered heap file。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在不必担心这些细节，我们先谈论一个包含多个页面记录的单一文件。在深入探讨这些页面如何布局之前，有多种不同的数据库文件结构，因此给定关系的信息可以通过多种不同的方式存储。我们现在将主要讨论一种方式——无序堆文件。
- en: And the unordered heap file is basically has no real constraint as to where
    the records are placed across pages it's kind of unordered。 Again， remember that
    relation is a multi set so this kind of matches are sort of abstraction of a multi
    set。 And then if you want to make access a little bit more efficient。 you could
    for example cluster your data based on some meaningful ways to the records and
    pages are grouped in some meaningful way。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 无序堆文件基本上没有对记录在页面上的放置位置做出实际约束，它是无序的。再说一遍，记住关系是一个多重集合，所以这种匹配有点类似于多重集合的抽象。如果你想提高访问效率，你可以例如基于某些有意义的方式对数据进行聚类，使得记录和页面以某种有意义的方式分组。
- en: or you could be even more strict about it and sort it based on some attribute
    for example。 Right。 so for example you could sort the student records based on
    the Calnet ID。 In addition to sort of storing the records themselves。 you could
    also have index file these are typically auxiliary structures that allow you to
    retrieve records or pages more efficiently。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以更严格一些，根据某个属性进行排序。例如，你可以根据Calnet ID对学生记录进行排序。除了存储记录本身之外，你还可以有索引文件，这些通常是辅助结构，允许你更高效地检索记录或页面。
- en: And so they may in some cases contain the records themselves or point to the
    records in other files。 Okay， so for now we are not going to be worrying about
    these other three modalities of cluster sorted and index files you'll just worry
    about the unordered equals。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们在某些情况下可能包含记录本身，或者指向其他文件中的记录。好了，现在我们不必担心这些其他三种聚类、排序和索引文件的方式，你只需要关注无序堆文件。
- en: We'll come back to indexes in the next class。 Okay。 so on order he files so
    this is basically the abstraction that we want is a collection of records in no
    particular order。 This is not to be confused with a deep data structure that you
    may have learnt about in your algorithms class just trying to ensure efficient
    max and men and maintain this max and men in the face of inserts and delete so
    this is not what we are talking about here。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节课回到索引的内容。好的，那么文件顺序的问题，基本上我们想要的抽象是无特定顺序的记录集合。这与您在算法课上可能学到的深度数据结构不同，我们这里只是为了确保高效的最大值和最小值操作，并在插入和删除时保持这些最大值和最小值，这并不是我们现在要讨论的内容。
- en: So don't confuse the two。 So this is basically a collection of records in no
    particular order。 And in such a file you have allocation and the allocation of
    pages as the file strings or growth so as new records are added or deleted you
    may have more pages added or deleted。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不要混淆这两者。基本上，这是一个无特定顺序的记录集合。在这样的文件中，随着文件的扩展，页面的分配也会发生变化，因此在新增或删除记录时，可能会增加或删除更多的页面。
- en: And so to support sort of actions that are happening on within a relation we
    need to do several things。 We need to capture where all the pages exist for a
    given file。 We need to capture the amount of free information that's present in
    a given page so that we can figure out whether to insert a new record or not。
    And we need to keep track of the records within a page。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了支持在关系中发生的各种操作，我们需要做几件事。我们需要捕获给定文件中所有页面的位置。我们需要捕获每个页面中存在的空闲信息量，以便确定是否插入新记录。我们还需要跟踪页面中的记录。
- en: So let's start with the highest level of abstraction。 So let's talk about the
    pages within file。 So a heap， heap file and let's say we are implementing this
    as a list。 So for implementing a heap file as a list， we may consider having one
    special header page is basically the start pointer to your list。 And then this
    header page is the， so the location of the heap file。 So basically this entire
    file。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们从最高层次的抽象开始。我们来谈谈文件中的页面。一个堆文件，假设我们将其实现为一个列表。为了将堆文件实现为列表，我们可以考虑有一个特殊的头页，它基本上是指向列表的起始指针。然后这个头页是堆文件的位置，也就是说，整个文件的位置。
- en: as well as the where the header page is within that file could be stored somewhere
    as quote unquote meta data。 So this could be stored as data about the data in
    a place that's called the system catalog。 So the database system catalog is just
    a location where you store data about your data。 So for example， you may store
    information about schemas for various relations you mean the store information
    about。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以及页头页面在文件中的位置，可以作为所谓的元数据存储在某个地方。所以这可以作为关于数据的数据存储在系统目录中。数据库系统目录就是存储有关你数据的数据的地方。例如，你可能存储关于各种关系的模式信息，意味着存储信息。
- en: for example， things like this。 So how does a page。 how which files are referenced
    in your fall for a given relation and where does a header page exist。 for example。
    Right。 So this could be one possible location to store where this header page
    exists within this file。 Okay， so the header page is basically just telling you
    the start of this link list and then you have two separate link list。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像这样的事情。那么，一个页面是如何工作的呢？在给定的关系中，哪些文件被引用，页头页面存在的位置在哪里？例如，明白吧。所以，这可能是存储此页头页面在文件中位置的一个可能位置。好的，所以页头页面基本上只是告诉你这个链表的起始位置，然后你有两个独立的链表。
- en: one link list of pages that are full。 So this is this link list， and another
    link list。 which are pages that are have free space。 Okay， so again。 and you might
    want to have forward and backward pointers so that as pages are added or deleted。
    you could sort of maintain that correctly。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一条已满页面的链表。所以这是这条链表，另外一条链表，是那些有空闲空间的页面。好的，再次强调，你可能需要前后指针，这样当页面被添加或删除时，你可以正确地维护这些指针。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_11.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_11.png)'
- en: And so this header page has pointers， sorry， to the start of the full page list
    as well as the free page list。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个页头页面有指针，抱歉，指向已满页面列表的开始以及空闲页面列表的开始。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_13.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_13.png)'
- en: And each page， each data page has a pointer to the next page in the list as
    well as the previous page in the list in this case。 and this is the first page
    points back to the header。 So why have I split this up into full pages and free
    pages？ Well。 the benefit of doing that is that if I want to insert some new record。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面，每个数据页都有指向列表中下一个页面以及前一个页面的指针，在这种情况下，第一个页面指向页头。那么，为什么我要将这些分成已满页面和空闲页面呢？好处在于，如果我想插入一些新记录。
- en: I only need to look at these pages as opposed to these pages， right， so that
    I allow。 I sort of don't need to look at these full pages because I know that
    I won't be able to fit my new record within that。 I can only fit it within those
    that have free space。 Yes。 Question。 Oh yeah sorry。 you kind of just answered
    my question but I guess another question is once a page fills up on the free space
    link list。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要查看这些页面，而不是这些页面，对吧，这样我就不需要查看这些已满页面，因为我知道我无法在其中容纳新记录。我只能将其放入那些有空余空间的页面中。是的。问题。哦，对不起，你刚刚回答了我的问题，但我想另一个问题是，一旦空闲空间链表中的页面填满了会怎样？
- en: Do you have to move that up to the full pages and what's like the kind of cost
    associated with that。 Right， so， so the cost associated we haven't really talked
    about the cost but I mean。 we can talk about conceptually what would that look
    like right。 So well you would have to if you have if you if you have a data page
    that was originally in the free space list and you want to move it to the full。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将其移动到已满页面吗？这会带来什么样的成本？对吧，嗯，关于成本我们还没有真正讨论，但我们可以从概念上讨论一下这会是什么样子。好吧，你必须，如果你有一个最初在空闲空间链表中的数据页面，想要将其移动到已满。
- en: full pages list， you would have to basically sort of make sure that the pointer
    is now point to the right thing。 Right， so for example， if I wanted to move this
    page to the full pages list。 I would need to update the pointers for the previous
    page， as well as a page that's next。 And then once I find an appropriate space
    to put this in。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 已满页面列表，你基本上需要确保指针指向正确的地方。对吧，例如，如果我想将这个页面移动到已满页面列表，我需要更新前一个页面和下一个页面的指针。一旦我找到一个合适的位置来放置它。
- en: I could put it at the end of this list or I could put it at the start of this
    list。 Again。 I would have to update the pointers for the page before and after
    right so it's sort of basically I would say you would need to update order of
    four pages and their pointers in order to make this change。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以把它放到这个列表的末尾，或者把它放到这个列表的开头。再次强调，我必须更新前后页面的指针，对吧？所以基本上我可以说，你需要更新四个页面及其指针的顺序，才能完成这个更改。
- en: But let's talk about why this is actually not a great solution。 Okay。 so why
    is this not a great solution。 Well， if I wanted to find a page that has enough
    data to store a specific record。 And then I have no option but to go down this
    list of pages with free space until I can find one that has enough space to store
    my specific record。 And I have no way out right so and that's basically the only
    way to do this if I have this simple link link list implementation。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们来谈谈为什么这实际上不是一个很好的解决方案。好吧，为什么这不是一个很好的解决方案呢？嗯，如果我想找到一个页面，它有足够的空间来存储特定的记录。然后我只能按照这个空闲空间的页面列表一个一个查找，直到我找到一个有足够空间来存储我的记录的页面。而且没有其他方法可以做这个，对吧？所以这基本上是我如果采用这个简单的链表实现时唯一的做法。
- en: So， so that's the downside of this approach。 Well， so how do I。 how do I think
    about this one one downside here is that I am sort of treating I am looking at
    the pages with the data to determine whether there is free space or not。 but I
    can pull that information， about which pages have free space into a separate sort
    of page。 which is called a page directory。 Okay。 And so this page directory can
    have multiple such header pages。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是这种方法的缺点。那么，我该如何思考这个问题呢？一个缺点是，我有点是在查看包含数据的页面，以确定是否有空闲空间，但我可以将关于哪些页面有空闲空间的信息，提取到一个单独的页面中，这个页面叫做页面目录。好吧。因此，这个页面目录可以包含多个这样的头页面。
- en: Each page encoding a pointer to a given page as well as the free space that
    exists in that page。 So it's encoding pairs， the pointer and the space。 And so
    this directory can have many such header pages， each of which have basically these
    pointers。 Okay， pointers in the space information。 Now the benefit of doing this
    is that you can pack a lot of information about a lot of pages within a single
    header page。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面编码指向给定页面的指针以及该页面中存在的空闲空间。因此，它编码的是指针和空间的配对。所以这个目录可以有多个这样的头页面，每个页面基本上包含这些指针。好吧，指针和空间信息。现在，这么做的好处是，你可以在单个头页面中打包关于许多页面的信息。
- en: because you're not storing any data in these header pages you're simply storing
    information about the pages。 the pointer to the pages in the space in the pages。
    So there can be multiple such header pages these header pages are actually access
    pretty often so they may be in cash more often than not so they will be in memory。
    And finding a page to fit a record requires far fewer fewer page loads than in
    the link list。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你并没有在这些头页面中存储任何数据，只是存储关于页面的信息，指向页面的指针以及页面中的空间。所以可以有多个这样的头页面，这些头页面实际上访问得相当频繁，因此它们可能会比其他页面更常出现在缓存中，所以它们会在内存中。而找到一个合适的页面来存放记录所需的页面加载次数，比在链表中要少得多。
- en: Remember the link list I just had to follow the chain of pointers until I found
    a page which had enough space。 Here， I have one header page that can reveal the
    free space of many pages。 So it has basically information about a lot more pages。
    but I'm not storing any data in these header pages。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我刚才提到的链表吗？我必须跟随指针链，直到找到一个有足够空间的页面。现在，我有一个头页面，它可以显示多个页面的空闲空间。所以它基本上包含了更多页面的信息，但我并没有在这些头页面中存储任何数据。
- en: I'm just storing the amount of free space for a bunch of pages。 You can in fact
    sort of push this idea even further by organizing this page directory in a more
    quote unquote optimized way so you can try to compress it。 you can order the pointers
    based on the amount of free space in each page。 But all of these approaches don't
    necessarily offer a lot of additional benefits beyond this simple idea of using
    a page directory and header pages。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是在存储一堆页面的空闲空间量。实际上，你可以将这个思路推得更远，通过以一种更“优化”的方式来组织页面目录，从而尝试进行压缩。你可以根据每个页面中的空闲空间量来排序指针。但所有这些方法并不一定能提供比使用页面目录和头页面这一简单方法更多的附加收益。
- en: So page directory and header pages are often sufficient for our purposes。 Okay。
    so the highest level of abstraction here is a table is encoded as files which
    are collection of pages。 and then a page directory provides locations of pages
    and the free space in each page so that we can basically add new pages。 So we
    can add new records to those pages if we have it。 Let's talk about the page layout
    then。 Okay。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以页面目录和头页通常足以满足我们的需求。好的。所以这里的最高抽象层次是一个表格，它被编码为文件，文件是页面的集合。然后，页面目录提供了页面的位置以及每个页面中的空闲空间，以便我们基本上可以添加新页面。所以如果有新的记录，我们可以将它们添加到这些页面中。接下来我们来谈谈页面布局。好的。
- en: And to talk about page layout， I need to talk about how we will be able to depict
    a page given that we have limited screen real estate。 And so in memory or disk
    data is stored in linear order。 And you can remember that as you're reading things
    from your disk head it's reading things in a sequential order along the circumference
    right so off the off the of the bladder or the sector。 And that's how it's sort
    of read。 Now this information doesn't necessarily fit nicely and screen because
    I don't have the ability to go horizontal so the my cue is I'm going to turn this
    linear order into a rectangle so it's going to be basically this way。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论页面布局，我需要说明如何在有限的屏幕空间中展示页面。内存或磁盘上的数据是按线性顺序存储的。你可以记住，当你从磁盘读取数据时，它是按顺序读取的，沿着圆周的方向，也就是磁道或者扇区。就是这样读取的。现在，这些信息不一定能很好地适配屏幕，因为我无法横向展示，所以我的思路是将这种线性顺序转化为矩形的形式，基本上是这样展示的。
- en: and then I'll go to the start of this and so on。 Okay。 so I'm going to just
    this is just a convention for us to be able to represent these pages without me
    having to go off the page off the page in the sense that it's off the slide rather
    than a page。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将回到这一点，依此类推。好的，这只是一个约定，用来表示这些页面，而不用让我跳出页面（跳出幻灯片）的情况。
- en: All right， so let's talk about how a page looks like so the first part about
    a page that we need to think about is the header。 So the header is talking about
    is encoding information about what is contained within a page。 And again this
    is meta data because data about the data so it may contain various bits of information
    like what are the number of records in this page with the amount of free space。
    You may have a next or last point or you may have a pointer you may have a bit
    maps and slot table we'll talk about how whether any of these are needed and which
    of these are needed as we go on。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们来谈谈页面的样子。页面的第一部分是我们需要考虑的头部。头部是关于编码页面内容的信息。再次强调，这是元数据，因为它是关于数据的数据，所以它可能包含各种信息，比如页面中记录的数量和空闲空间的大小。你可能有下一个或上一个指针，或者你可能有指针、位图和槽表，我们将讨论这些是否需要，以及哪些需要。
- en: But the first thing I wanted to just say is that we may have a header just like
    we had header pages in the in the page directory。 which are pointing to pages
    we may have a page header that encodes information about the records within a
    page。 And in the sense， like as you go drill down， you still maintain that same
    sort of like structure of there being a header portion which is encoding metadata
    about the data。 Okay， so we have some decisions to make the first decision to
    make is whether we have records which are fixed length records or variable length
    records。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但我首先想说的是，我们可能会有一个头部，就像我们在页面目录中有头页那样，指向页面，我们也可能有一个页面头部，它编码了页面中记录的信息。在这个意义上，随着你逐步深入，你仍然保持相同的结构，即有一个头部部分，编码着关于数据的元数据。好的，所以我们有一些决策要做，第一项决策是我们是否有固定长度记录或可变长度记录。
- en: And we've been updated to you but there are ways to sort of encode a variable
    length field into a fixed length field and we'll talk about that later。 But for
    now let's talk about whether you have fixed length records or variable length
    records as a possible decision that has been made and given to you so for example。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新过你，但有方法将可变长度字段编码为固定长度字段，稍后我们会讨论。但现在我们来谈谈你是拥有固定长度记录还是可变长度记录，这是一个可能的决策，并且已经提供给你了。例如。
- en: if you don't have any strengths it's just integers and floats。 So。 this is a
    record that is fixed length record because you know the amount of storage required
    for each of those fields。 On the other hand， if you have a lot of strengths it
    would be available length record。 especially if you use VARCAER which is syntax
    that we learned about when we talked about the data definition language。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有任何字符串类型，那就是整数和浮点数。这是一个固定长度的记录，因为你知道每个字段所需的存储量。另一方面，如果你有很多字符串，它将是可变长度的记录，特别是如果你使用VARCAER，这是一种我们在讨论数据定义语言时学到的语法。
- en: Okay， so that's a first decision which is the record length。 The second decision
    is whether we want to use a packed layout which is basically the records are packed
    together or it has free space between the record。 So that's the second decision
    packed on that。 And so the kinds of considerations that we have are we want to
    be able to find the records based on a record ID and record ID is encoded as a
    page and a location within the page and we'll talk about what this location means
    for each of these page structures that we're going to be considering。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是第一个决策，即记录长度。第二个决策是我们是否想使用打包布局，也就是记录紧密排列在一起，还是记录之间有空闲空间。这个就是第二个决策，打包方式。我们需要考虑的因素是，我们希望能够根据记录ID找到记录，而记录ID被编码为页面ID和页面内位置，我们会讨论这些页面结构中每种位置的含义。
- en: And we need to make sure that we can add and delete records efficiently and
    the overhead involved in each of these。 Okay， so let's consider the first alternative。
    So the first alternative was to pack records in a dense way。 Right。 And this is
    for fixed length records as opposed to variable length records is actually the
    simplest possible scheme that you can have。 So if you have， if you're packing
    records densely you basically have this page header and then you have the first
    record and then the second record the third record and the fourth record and so
    on。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保能够高效地添加和删除记录，并考虑到每个操作所涉及的开销。好的，那么让我们考虑第一种替代方案。第一种替代方案是将记录密集打包。对，这适用于固定长度的记录，相对于可变长度的记录，这实际上是你能拥有的最简单的方案。所以，如果你将记录密集打包，你基本上会有这个页面头部，然后是第一条记录，第二条记录，第三条记录，第四条记录，依此类推。
- en: It just laid out in sequence。 So what is the record ID look like well the record
    ID is basically encoded as two parts of page ID in the location on the page。 Here
    the location on the page is basically can be captured entirely using the information
    corresponding to the record number in the page。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是按顺序排列。那么，记录ID是什么样的呢？记录ID基本上被编码为页面ID和页面位置的两部分。这里页面的位置基本上可以通过页面中与记录编号对应的信息完全捕获。
- en: And once we have the record number we can actually figure out exactly where
    the record is going to be within the page by using simple arithmetic。 Right， so
    you use an offset from the start of the page to figure out where that record is
    going to be in the page。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了记录编号，我们实际上可以通过简单的算术运算确定记录在页面中的确切位置。对，通过使用从页面开始的偏移量，可以计算出该记录在页面中的位置。
- en: So it would be basically the header size plus the record size times n minus
    one if I am trying to find the nth record in the page。 So for example， the first
    record begins here so it's basically header plus record size times one minus one
    which is zero。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上就是页头大小加上记录大小乘以n减去1，如果我试图找到页面中的第n条记录。例如，第一条记录从这里开始，所以基本上是页头加记录大小乘以1减去1，结果是0。
- en: Right， so it's just a header and the second record will be， sorry， second record
    would begin here。 third record begin here and so on。 And simple arithmetic to
    get to that point。 Okay。 so how do we deal with additions and deletions。 Well，
    additions are easy。 we simply append at the end of the page if we have free space。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对， 所以这只是一个标题，第二条记录会从这里开始，抱歉，第二条记录会从这里开始，第三条记录从这里开始，依此类推。通过简单的算术可以得出这一点。好的，那么我们如何处理添加和删除呢？嗯，添加很简单。如果我们有空闲空间，我们只需将记录追加到页面末尾。
- en: If you have a free space we can just add a new record at the end of the page。
    Now deletion is a bit more challenging。 So let's say we delete page two。 So this
    is page two。 Page two record three， right， which means I want to delete this record。
    Okay。 so I can go ahead and delete that record now on a free space。 Since this
    is a packed layout。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有空闲空间，我们可以直接在页面末尾添加新记录。删除则有点挑战性。假设我们删除第二页。所以这是第二页。第二页的第三条记录，意味着我要删除这条记录。好的，所以我现在可以删除这条记录并释放空间。由于这是一个密集布局。
- en: I need to reorganize。 Okay， so this record which is page two record four。 now
    need to move back and become page two record three。 Right。 since this is a packed
    representation。 So the pack representation means that I need to rearrange and
    the record ID which originally I was talking about page two record four。 now needs
    to be updated to page two record three。 So now the downside of that is that if
    I'm using page two record four as my identifier for that record and I'm referring
    to it in other files。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要重新组织。好的，所以这个记录是页面二记录四，现在需要移动回并变成页面二记录三，对吧？因为这是一个打包表示。所以打包表示意味着我需要重新排列原本我所说的页面二记录四，现在需要更新为页面二记录三。所以，这样的缺点是，如果我把页面二记录四作为该记录的标识符，并且我在其他文件中引用它。
- en: I now need to update that。 So that's not ideal。 Right， so if that information
    is in other files。 I need to go and update that information in those other files
    as well。 Okay。 so that's a downside of this packed representation。 Now let's talk
    about the unpack representation and see whether that helps alleviate some of these
    issues。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我需要更新这个。所以这并不是理想的，对吧？所以如果那些信息在其他文件中，我也需要去更新那些文件中的信息。好的。那就是这种打包表示法的一个缺点。现在我们来谈谈解包表示法，看看它是否能缓解一些这些问题。
- en: but before that， do I have any questions。 Shiro。 Yeah。 I just want to make sure
    so the page here we're talking about does it has anything to do with the actual
    page in the memory。 where there's like page tables and to all these and stuff。
    No。 so this is basically we are talking about like the granularity at which you
    are writing and reading information from disk。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但在此之前，我有任何问题吗？Shiro。是的。我只是想确认一下，我们讨论的这个页面是否与内存中的实际页面有关。那里的确有页面表和其他一些东西。没有。所以，基本上我们讨论的是你从磁盘上读取和写入信息时的粒度。
- en: Right， so， so this is the page and that's sort of the common currency that both
    the sort of the upper layers of the database system as well as the lower layers
    from the disk manager is going to talk in。 So it's basically the currency that
    you're going to be talking about。 Okay。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对，所以，这就是页面，它是上层数据库系统和下层磁盘管理器之间的共同货币。所以，它基本上是你将要使用的交换单位。好的。
- en: so it's the same page as in the operating systems page。 Right。 Yeah， yeah， okay，
    it depends。 but yes。 Okay， for sure。 Thank you。 So you said that when we're doing
    the heap that it like checks all the pages and goes and it does this whole inefficient
    kind of check through。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它和操作系统中的页面是一样的，对吧？是的，是的，好的，视情况而定，但肯定是。好的，谢谢。所以你说当我们使用堆时，它会检查所有页面并执行一个非常低效的检查过程，对吗？
- en: but does that mean that it's also a very like inefficient storage structure
    just in terms of space because I could see a scenario in which。 the page isn't
    completely full， but it would just keep not being able to be written into because
    there's not a space in it。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是否意味着它也是一种非常低效的存储结构，尤其是在空间上，因为我可以想象一种情况，页面并没有完全填满，但由于没有足够的空间，它就无法继续写入。
- en: but if we rearrange the data in a different way kind of like you were talking
    about with the packing thing。 It could fit so does that mean that he was just
    like inefficient in terms of storing things as well。 So， are you talking about
    the， the， the heap file in general。 Are you like the way that when there's the
    header file and then it split into two and then there is the free pages and the
    full pages and the free pages seem like an inefficient way to store things just
    in terms of like。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们以不同的方式重新排列数据，就像你之前提到的打包问题一样。它可以适配。那么这是否意味着他在存储东西方面也很低效呢？那么，你是在讨论堆文件吗？你是指有一个头文件，然后被分成两部分，其中有空闲页面和已满页面，空闲页面看起来就像是存储东西的一种低效方式，是吗？
- en: the space， I could see a scenario in my head where there'd be a lot of space
    that we wouldn't use that otherwise we could allocate differently。 Yeah， so there
    could be benefits that you could， for example。 gain from periodically reorganizing
    the information in the free pages。 especially if there's a lot of sort of deletions。
    So you could。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 空间，我能在脑海中想象出一种情况，会有很多空间我们不会使用，原本我们可以以不同的方式分配这些空间。是的，所以你可能会从定期重新组织空闲页面中的信息中受益，特别是如果有大量删除操作。这样你就可以。
- en: you could gain some sort of benefits from doing that we're going to be actually
    talking about some defragmentation issues and fragmentation issues in a little
    bit so hopefully we'll come back to that concern。 I don't think necessarily that
    that is an issue that only affects that particular scheme I think it affects the
    page directory scheme as well。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会从中获得一些好处，我们接下来会讨论一些碎片整理问题和碎片化问题，所以希望我们能回到这个问题。我不认为这是一个仅仅影响这个特定方案的问题，我认为它同样影响页面目录方案。
- en: So， you have， if， for example， you have a lot of data， so for example。 if you
    added a lot of records， and so you allocated a lot of pages。 and then you deleted
    half of those records now you have， let's say half of those pages being empty。
    each of those， pages that you originally allocated are now half of them are empty。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你有很多数据，例如，如果你添加了很多记录，并且分配了很多页面，然后删除了其中一半记录，那么你现在有，假设是其中一半页面为空。你最初分配的每个页面现在有一半是空的。
- en: or rather sort of like half of the records in each of those pages are now deleted。
    you could have sort of compressed it down to half as many pages， but you can't
    because you。 unless you sort of decide to do this， to be a defragmentation。 right
    so that scheme is not going to be unique to the。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者说，这些页面中的大约一半记录现在已被删除。你可以将它们压缩成只有一半数量的页面，但你不能这样做，除非你决定进行碎片整理，对吧？所以，这个方案对于这个情况并不是独特的。
- en: the link list scheme I think it's going to affect this scheme as well。 the page
    directory scheme as well。 Awesome， thank you so much。 Yeah。 so I have one question
    about the delay， so like you mentioned before。 so if we delay the page to record
    three， then we're going to rearrange the page to record for rights。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 链表方案，我认为这个方案也会受到影响。页面目录方案也会受到影响。太棒了，非常感谢。是的。我有一个关于延迟的问题，正如你之前提到的。如果我们将页面延迟到记录3，那么我们将重新排列页面为记录4，对吧？
- en: So how about the record like the page to record five， because now we have。 arranged
    the record for now help us to record five。 do we also rewinding the record file
    to become the record for because yes so that's my question。 Yeah， so so basically
    if you end up deleting a record。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么像页面到记录5这样的记录怎么办，因为现在我们已经安排好了记录，现在帮我们安排记录5。我们是否也需要将记录文件回滚，以便成为记录5呢？是的，这是我的问题。是的，基本上，如果你最终删除了一个记录。
- en: the record IDs for all subsequent records in that page need to be updated， right。
    And therefore any。 any other information that's stored in other pages that refer
    to that record ID also need to be updated so you're right。 So basically not just
    record for record fire record six。 any other records in that page also need to
    be updated。 Okay， thank you。 Felix。 Hey， so Jerry。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在该页面中，所有后续记录的记录ID需要更新，对吧？因此，任何存储在其他页面并引用该记录ID的信息也需要更新，所以你说得对。所以基本上，不仅是记录文件6的记录，页面中的其他记录也需要更新。好的，谢谢你，Felix。嘿，Jerry。
- en: partially answered my question but considering deletion， is there anything stopping
    us from like。 kind of like just patting that area I'm walking as invalid or does
    the page layout like required that like records。 like， records must be like， like
    valid records must be consecutive。 Okay。 so basically the idea that you're talking
    about is what I'm going to be talking about next so just hold that thought。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题部分得到了回答，但考虑到删除的情况，是否有任何因素阻止我们？例如，将该区域标记为无效，或者页面布局是否要求记录必须是有效记录且必须连续？好的。所以你提到的基本概念是我接下来要讲的内容，先记住这个想法。
- en: Thank you。 Okay， all right， so I guess that's it in terms of questions if there
    are any questions from the chat that require answering。 Please raise your hand。
    I'm not following chat that closely。 Okay。 all right so following up on Felix's
    suggestion， which is to basically indicate that record has been deleted。 Let's
    not by indicating that that record region has been that record has been deleted。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。好的，所有问题就这样吧。如果聊天中有任何需要回答的问题，请举手。我没有非常密切关注聊天。好的。那么，跟进Felix的建议，就是基本上指示记录已经被删除。我们通过指示该记录区域已经被删除来实现。
- en: We don't need to necessarily move the other records up。 And thereby avoid having
    to update the record IDs of all of those records so using that idea。 How do we
    actually implement that well one way to implement it is to have a bitmap。 which
    is encoding whether or not a record within a page。 Again。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一定需要将其他记录向上移动，从而避免更新所有这些记录的记录 ID。因此，使用这个思路，我们如何实际实现呢？一种实现方法是使用位图，它编码了页面中记录是否存在。再次强调。
- en: we are talking about fixed length records， whether this record is valid or not。
    So that's what this bit map is encoding。 And so a bitmap is denoting these slots。
    each slot corresponding to a record。 And a record ID is well then correspond to
    again page ID location and page in the page location page here is going to be
    talking about the slot ID。 So inserting is simple。 We find the first empty slot
    in the bitmap。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在讨论固定长度记录，无论该记录是否有效。因此，这个位图就是在编码这一点。位图表示这些插槽，每个插槽对应一条记录。记录 ID 就是对应于页面 ID
    位置和页面内位置。这里的页面将讨论插槽 ID。所以插入很简单。我们找到位图中的第一个空插槽。
- en: And then we insert a record there。 Deletion is also simple。 We simply clear
    the bit。 So in this case， if I wanted to delete record three， I would simply clear
    this bit。 And I have now deleted my record。 Now the benefit of doing this is that
    all of these records record four record five record six。 seven， so on。 They don't
    need to be moved up。 Their record IDs don't need to be updated。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在这里插入一条记录。删除也很简单。我们只需清除那个位。因此，在这种情况下，如果我想删除第三条记录，我只需要清除这个位。现在，我已经删除了记录。这样做的好处是，这些记录（记录四、记录五、记录六、记录七等等）不需要移动。它们的记录
    ID 也不需要更新。
- en: And so therefore no reorganization is needed。 So it's basically just indicating
    whether or not a record is valid。 And you may get that in a very efficient bitmap。
    So bitmap is just a zero one can be stored extremely compactly。 Okay， so this
    is the unpack representation for fixed length records。 Now let's talk about variable
    length records。 Now what happens with the variable length records well。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不需要重新组织。它基本上只是表示记录是否有效。你可以通过一个非常高效的位图来表示这一点。位图只是一个零一的表示，可以极其紧凑地存储。好的，这是固定长度记录的解包表示。现在我们来谈谈可变长度记录。那么，可变长度记录会发生什么呢？
- en: you also need to understand how long a record is going to be。 And so we are
    going to try figuring out how to encode variable length records。 We've already
    seen that fact is in great for fixed length records。 So we're going to consider
    the unpack case。 And so here are the considerations that we need to worry about。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解记录的长度。因此，我们将尝试弄清楚如何编码可变长度的记录。我们已经看到，固定长度记录的情况非常好。现在，我们将考虑解包的情况。那么，这里是我们需要关注的几个考虑因素。
- en: Well， we need to figure out where each record begins。 And we need to figure
    out how long that record is。 We also need to figure out what happens when we add
    and delete records。 Okay。 so to figure out how to deal with variable length records。
    The first thing that we're going to do is to move the metadata。 The header to
    a footer。 Okay。 so we're going to move it to the end。 We'll talk about why this
    makes sense in a little bit。 And then we're going to have slots。 Okay， so this
    is a slot directory。 The first slot in the slot directory is simply a pointer
    to the start of the free space。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们需要弄清楚每条记录的开始位置。我们还需要弄清楚每条记录的长度。我们还需要弄清楚在添加和删除记录时会发生什么情况。好的，为了弄清楚如何处理可变长度记录，我们要做的第一件事是将元数据，也就是头部，移到尾部。好的，我们将它移到末尾。稍后我们会谈到为什么这么做是有道理的。然后我们会有插槽。好的，这是一个插槽目录。插槽目录中的第一个插槽只是一个指向空闲空间起始位置的指针。
- en: So it's basically saying from this point on。 You have free space。 Okay， so that's
    a blue arrow。 And then you have a bunch of slots。 So this is record ID one record
    ID two record ID three record ID four。 Okay， so this is page two record four，
    for example。 And that each slot is encoding two bits of information。 It's encoding
    the size of the record。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它基本上是在说，从此位置开始，你有了空闲空间。好的，这就是蓝色箭头。然后你有一堆插槽。所以这是记录 ID 一、记录 ID 二、记录 ID 三、记录
    ID 四。好的，这就是第二页的记录四。例如，每个插槽编码了两位信息，它编码了记录的大小。
- en: And it's encoding the pointer to the start of the record。 So here record four
    starts at this point and then has， let's say， 12 bytes。 Okay。 so two bits of information，
    the length and the pointer to the beginning of the record。 And you are storing
    these record IDs in reverse order。 So it's increasing in this direction。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它编码了指向记录开始位置的指针。这里记录四从这一点开始，然后是，假设，12个字节。好的，两个信息，长度和指向记录开始的指针。你将这些记录ID按倒序存储。所以它在这个方向上递增。
- en: So this is one， two， three， four。 And so the record ID is simply the length，
    the location。 the slot table from the right。 Let's talk about deletion。 Let's
    say I want to delete the fourth record on the page。 I simply get rid of the information
    in that particular slot。 So it was this lot。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个，二，三，四。所以记录ID实际上就是长度和位置，来自右侧的槽表。我们来谈谈删除。假设我要删除页面上的第四条记录。我只需要删除该特定槽中的信息。所以就是这个槽。
- en: And I get rid of this zero of this record， for example。 So I don't need to。
    I set the pointer for this slot to be now。 So it doesn't point to anything anymore。
    Now the benefit of this， this deletion approach is that I don't need to update
    the pointers to any other records。 There's no internal reorganization needed。
    I， if I delete a record。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我把这个记录的零清除掉。例如，我不需要做什么。我将这个槽的指针设置为“现在”。所以它不再指向任何地方了。这个删除方法的好处是，我不需要更新其他记录的指针。不需要进行任何内部重组。如果我删除一条记录。
- en: I don't need to move the locations of the other records。 And now do I need to
    update the any other external pointers。 So the same。 I can refer to the record
    IDs in the same way without having to worry about these deletions。 So。 after I
    delete this record ID， which is record ID five is still going to stay record ID
    five。 Okay。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要移动其他记录的位置。现在我是否需要更新任何其他外部指针？答案是一样的。我可以以相同的方式引用记录ID，而不必担心这些删除。因此，在我删除这个记录ID之后，记录ID五仍然会保持为记录ID五。好的。
- en: so record page two record five。 Okay， how do I do an insert。 So one approach
    is to simply put it at the end of this or the start of this free space。 So remember
    that the start of the free space is indicated by this blue arrow。 So I can just
    put the record here。 The second thing that I need to do is to find a slot。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么记录页面二，记录五。好的，如何进行插入呢？一种方法是将其直接放置在这个自由空间的末尾或开始处。所以记住，自由空间的起始位置由这个蓝色箭头指示。所以我可以把记录放在这里。我需要做的第二件事是找到一个槽。
- en: Here I had this empty slot。 And then add a pointer to the start of that record。
    And also encode the length of that record。 So I create a pointer link pair in
    the next open slot in my slot directory。 I also then need to update my free space
    pointer。 Right。 so the blue arrow which was here previously， now needs to be whoops。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我有一个空槽，然后添加一个指针指向该记录的起始位置。同时编码该记录的长度。所以我在我的槽目录中的下一个空槽里创建一个指针-链接对。接着，我还需要更新我的自由空间指针。对吧？所以之前这里的蓝色箭头现在需要指向谁？
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_15.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_15.png)'
- en: Okay。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_17.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_17.png)'
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_18.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_18.png)'
- en: Sorry， I didn't want to go here。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，我不想走这一步。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_20.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_20.png)'
- en: Okay。 All right， so I needed to update the blue arrow。 which was my pointer
    to the start of free space to the end of this new record that I just added。 So
    that's why I needed to update this free space pointer。 And as I mentioned previously，
    I for this。 this slot that just got filled， I need to provide a pointer to the
    start of that record and also fill in the length of that record。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好的，那么我需要更新蓝色箭头，之前是我的自由空间起始指针，现在它需要指向我刚刚添加的这条新记录的末尾。所以这就是为什么我需要更新这个自由空间指针。正如我之前提到的，对于这个刚填充的槽，我需要提供指向该记录开始位置的指针，并填写该记录的长度。
- en: Now one issue is that if you delete a bunch of if you keep adding records to
    the end。 So basically at the start of the free space， you could have a lot of
    records that got deleted previously。 and they still occupying space in this page。
    So how do we deal with this issue。 so this is an issue of fragmentation。 And so
    one approach to this issue of fragmentation is to basically recognize the data
    on the page。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一个问题是，如果你删除了一些记录，同时你不断地在末尾添加记录。基本上在自由空间的开始处，你可能会有很多之前已被删除的记录，它们仍然占用着该页面上的空间。那么我们该如何处理这个问题呢？这是一个碎片化问题。解决这个碎片化问题的一种方法是基本上识别页面上的数据。
- en: Right， so you basically move this record， which is occupying this space to this
    location。 if there's space in that location。 And if I move that record to that
    location。 I need to update the pointer for that record in the slot directory。
    as well as the start of the free space。 Okay， so that's how I would move this
    record and basically deal with the fragmentation issue。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对，你基本上是把这个占据了该空间的记录移动到这个位置。如果那个位置有空间的话。如果我把这个记录移动到那个位置，我需要更新槽位目录中该记录的指针，并更新空闲空间的起始位置。好，这就是我如何移动这个记录并基本上解决碎片化问题的方法。
- en: Now this movement is actually okay， it's safe because the only thing that it's
    affecting is this particular slot。 It's only affecting that slot。 Any other slot
    is fine， because the record IDs。 at least externally refer to the page number
    and the slots and the slots are not changing。 And therefore， it doesn't impact
    any external files。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种移动实际上是安全的，因为它只会影响这个特定的槽位。它只影响这个槽位。任何其他槽位都没问题，因为记录的ID至少在外部是引用页面号和槽位的，而槽位并没有改变。因此，这不会影响任何外部文件。
- en: So now one question is when should I reorganize。 Right。 so one option is I reorganize
    and basically defragment on every delete。 Or I can wait until the fragmentation
    is so bad that I can't add any additional records and then I reorganize。 So usually
    this approach， which is kind of a lazy approach is preferred。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在有一个问题是我应该什么时候进行重新组织？对吧？一种选择是我在每次删除时进行重新组织和基本的碎片整理。或者，我可以等到碎片化严重到无法再添加其他记录时再进行重新组织。因此，通常这种懒散的方法是首选。
- en: And especially if the page doesn't get a lot of new records。 So this sort of
    lazy approach of just doing it when you absolutely need to is often preferred。
    rather than reorganizing on every delete， which is very aggressive and often not
    necessary。 especially if the page doesn't get more records。 Now what if we need
    more slots sometimes when you try to insert a record and you're。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是当页面没有太多新记录时。因此，这种懒惰的方法——只在绝对需要时才进行操作——通常是首选的。这样做比在每次删除时进行重新组织要好，因为后者非常激进，且通常没有必要，尤其是当页面没有更多记录时。那么，如果我们有时需要更多槽位呢？当你尝试插入一条记录，而你只有五个槽位时，我们该如何添加这些新的槽位呢？我们来讨论一下。
- en: you have only let's say five slots in the slot directory。 where would you add
    these new slots let's talk about that。 So to track these slots。 we need additional
    metadata in the footer。 The first bit of information is we can store the number
    of slots in the slot directory here we are storing five because there are five
    slots。 And we are going to also be able to tell based on the number of slots and
    based on what is present in each of these slots whether they're empty or full。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪这些槽位，我们需要在页脚中添加额外的元数据。第一项信息是我们可以在槽位目录中存储槽位的数量。在这里，我们存储了五，因为有五个槽位。我们还能够根据槽位的数量以及每个槽位中存储的内容，判断它们是空的还是满的。
- en: Right。 If the full slots is basically equal to the number of slots。 If every
    slot is full。 And you need to add something more than you extend the slot directory。
    Right， so in this case。 I decided to extend the slot directory because I added
    an additional record I had five slots I wanted to add one more。 So I added an
    additional additional record。 Once again， as always。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对。如果所有槽位基本上都被填满，也就是说每个槽位都已满，且你需要添加更多内容时，你就扩展槽位目录。对吧？所以在这种情况下，我决定扩展槽位目录，因为我添加了一个额外的记录。我原本有五个槽位，现在想再添加一个。所以我又添加了一个额外的记录。再一次，像往常一样。
- en: I point to the start of the record and then I encode the information amount
    of bytes for that record so let's say 16 bytes。 And so that's what is stored in
    my slot directory。 And I updated the。 the start of the free space pointer case
    so all of those have been updated。 The last thing that I need to update is this
    number of slots information and so I can update that and I can add six。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我指向记录的开始位置，然后我编码记录的字节数，例如16字节。所以这些信息存储在我的槽位目录中。我更新了空闲空间指针的起始位置，因此所有这些都已经更新。最后我需要更新的是槽位数量信息，我可以更新它并增加六。
- en: So to extend the slot directory it's pretty straightforward。 The slots grow
    from the end of the page inward。 While the records grow from the beginning of
    the beginning of the page inward。 So once they meet in the middle， you know that
    you can't add any more information to the page。 So this records growing down slots
    growing up allows both of them to grow with some latitude。 Right。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，要扩展插槽目录其实很简单。插槽从页面的末端向内增长，而记录从页面的开头向内增长。一旦它们在中间相遇，就意味着你不能再往页面中添加任何信息了。所以，记录向下增长，插槽向上增长，允许它们都能有一定的扩展空间。对吧？
- en: so if you have a lot more slots than records then or the records are fairly
    small you have the slot directory cannot buy more space。 If the records are fairly
    large and you have more records the records can occupy more space。 So basically
    you have these， you have the direction of growth from both sides。 allowing you
    to sort of give latitude to growth from from the record standpoint as well as
    from the slot sample。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果插槽比记录多得多，或者记录比较小，那么插槽目录无法获得更多的空间。如果记录相对较大，并且记录数量较多，那么记录就会占据更多的空间。基本上，你有两个方向的增长，这样可以让你在记录方面和插槽方面都能有一定的扩展空间。
- en: Okay， there's a question。 Yes。 Again， with asking a question right。 I was asking
    a question about when we like earlier on in more about how we recognize the slots。
    So things when we're doing and let's see if we're doing like a fixed lens slots
    and if something is free like how do we keep track of which slots are free to
    have a big map or what。 Yeah， so you could， for example， encode a bitmap to encode
    which slots are free or not another approach which is a bit more crude is to just
    go and check at the pointer for that slot is now the pointer for that slot is
    now then you can determine if that slot is empty。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，有个问题。是的，重新来过，问问题时要问对。我的问题是关于我们之前提到的如何识别插槽的。所以，当我们在做类似固定镜头插槽的事情时，如果某个插槽是空的，我们如何跟踪哪些插槽是空的？是通过一个大地图吗？或者是什么呢？嗯，你可以，例如，使用位图来编码哪些插槽是空的，或者另一种稍微粗糙一点的方法是直接检查该插槽的指针，查看插槽的指针现在是什么。如果插槽的指针现在是空的，那么你就可以确定该插槽是空的。
- en: Right， so the bitmap approach is a perfectly fine approach like you said。 or
    you could just go down the list of slots and then and check。 Okay， thank you。
    Yeah。 so a lot of the sort of trade offs and costs and benefits of these different
    strategies seem really reminiscent of memory allocators。 That's a memory allocators。
    Would you say that's like a fair comparison to compare to allocating records on
    a page versus allocating like this lots of memory on a memory page or does that
    statement miss some trade offs that are different between those two cases。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对，所以位图方法是一个完全可行的方法，正如你所说的，或者你也可以直接遍历插槽列表进行检查。好的，谢谢。那么，很多这些策略的权衡和成本效益似乎都与内存分配器非常相似。你认为这是否像在页面上分配记录与在内存页面上分配大量内存之间的差异？还是这个说法忽略了一些在这两种情况下不同的权衡呢？
- en: So I think it's a fair statement to make and it is， it is sort of。 it's no surprise
    that it should be reminiscent because in some sense one thing that is notable
    about database pages is that we use the same layout on disk as it is in memory。
    Right， so the same information is encoded in the same way in memory as it is on
    disk。 So。 so in some sense the same considerations apply right so thinking about
    in memory allocation is very applicable here because we are treating the information
    in the same way whether it's in memory or in disk。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个公平的说法，而且它是有道理的。其实这并不奇怪，因为在某种意义上，数据库页面的一个显著特点是，我们在磁盘上使用的布局与内存中的布局是相同的。对吧？因此，相同的信息在内存中的编码方式与在磁盘上的编码方式是一样的。所以，从某种意义上来说，相同的考虑因素也适用。所以，考虑内存分配的方式在这里非常适用，因为我们无论是在内存中还是在磁盘中，都是以相同的方式处理这些信息。
- en: And the benefit of that is that we don't need to pay any serialization deceralization
    costs as I will mention later to encode information on disk separately from how
    it's encoded memory。 So， this again like I said this currency of thinking about
    the page as a common unit which is treated in memory just as it is in disk is
    a fair metaphor。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是我们不需要支付任何序列化和反序列化的成本，正如我稍后提到的，信息在磁盘上的编码方式与在内存中的编码方式是分开的。所以，正如我所说，把页面看作一个共同的单元，并且在内存中就像在磁盘上一样处理它，这是一种相当贴切的隐喻。
- en: And like you brought up that's why in in memory pages are treated just like
    they would be in disk and so memory allocators。 and that's a fair sort of point
    of comparison because the idea of fragmentation defragmentation all of that and
    garbage collection all of that applies as well。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你提到的，正因为如此，在内存中页面的处理方式就像它们在磁盘中一样，所以内存分配器也类似。这是一个合理的比较点，因为碎片化、碎片整理以及垃圾回收等问题都适用。
- en: Great thanks。 Any other questions Felix。 Any other questions about this in this
    model。 because it's just like， it's just our assumption that like the footage
    only consists of like slot directories the freestack pointer and like the slot
    directory counter because like in the picture it kind of looks like it's overriding
    something。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，谢谢！Felix，还有其他问题吗？在这个模型中还有其他问题吗？因为我们只是做了一个假设，就像我们假设页脚只包含插槽目录、自由堆栈指针和插槽目录计数器，因为在图片中它看起来像是覆盖了某些东西。
- en: Like is there like no no sensitive mad at so left of like the slots。 And I didn't
    follow。 can you repeat。 Oh， so in this model is， are the only things in our footer
    like the slot director。 the slots the freestack pointer and the slot directory
    counter。 because like in the picture you kind of see it's like kind of like shifting
    to left。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就像是没有敏感数据被放在这些插槽的左边。然后我没有跟上。你能再重复一遍吗？哦，所以在这个模型中，我们页脚里唯一的东西是插槽目录、插槽的自由堆栈指针和插槽目录计数器。因为就像在图片中你可以看到，它有点像是向左移动了。
- en: So are we all right， is there any sensitive data left or no。 So， so I mean。
    so the thing here is that I'm not dictating where my records and where my footer
    begins and that's a benefit of the scheme。 And so that's all automatically captured。
    I don't need to pre allocate this much amount of space for the record just much
    a model space for the footer。 And that dynamically grows as we add or delete records。
    And so that's kind of the。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们没问题吧，是否还有敏感数据留下来？所以，我的意思是，事情是这样的，我并没有指定我的记录和页脚从哪里开始，而这是这种方案的一个优点。所以这些都会自动捕捉到。我不需要为记录预分配这么多空间，只需为页脚预分配一定的空间。然后，随着我们添加或删除记录，这个空间会动态增长。所以，这就是这个方案的特点。
- en: so there's no pre allocated area that is that I would say is the footer so there's
    nothing。 even though in my picture appears as if 16 is overriding something there's
    no such thing。 I mean 16 was allocated in an area that was free prior to this
    otherwise it wouldn't have been allocated otherwise you would have never added
    an additional record here if there wasn't space。 So that's how I would think about
    this does it make sense。 Yeah， that helps a lot。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以没有预先分配的区域，我会说这就是页脚，所以没有任何东西。尽管在我的图片中看起来像是16覆盖了某些东西，但实际上并没有这样的事情。我的意思是，16是在一个之前是空闲的区域分配的，否则它就不会被分配，否则如果没有空间，你也不会在这里添加额外的记录。所以我会这样理解这个问题，这样理解对吗？嗯，明白了，这帮助很大。
- en: I guess that connects to my same question。 So is there like， I mean。 perhaps
    we're going to cover this like in the next slide or something。 but is there anything
    like we have to do like， in regards to like handling when we don't have enough
    space in our footer or for a footer like slides of a record。 We expect。 So we，
    so we would ensure that the footer would never collide with the record so we would
    never insert a record when there's a danger of that happening。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这与我的问题是相关的。是不是有什么，我们需要做的事情，比如说，处理页脚空间不足的情况，或者在插槽中的记录空间不足时？我们是否有任何类似的预期？所以，我们会确保页脚永远不会与记录冲突，因此我们永远不会在存在这种冲突风险的情况下插入记录。
- en: And if we end up with a case where we wanted to insert a record is no free space
    left in that page we may consider based on the number of null pointers we may
    consider reorganizing the reorganizing the page right so basically defragmenting
    the page。 So to ensure that there is this all of the free space at the end of
    the record list as opposed to in between。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到一个想插入记录的情况，页面上没有剩余的空闲空间，我们可能会根据空指针的数量考虑重新组织页面，也就是基本上进行页面碎片整理。所以，确保所有的空闲空间都位于记录列表的末尾，而不是中间。
- en: So on the other like on the other example if we had a bunch of very small records
    is there and we fill up our footer like spots。 Can our footer expand。 Yeah， so
    this is going to be a really。 really corner case right because I mean it's rare
    that records are going to be that small that the footer is going to be larger
    than the records but yes certainly photo the photo can expand。 Right， the photo
    can and will expand as records are added certainly as new records are added you
    would expect the record the area that's allocated for the records in the area
    that's allocated for the footer to both expand。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果我们有一堆非常小的记录，我们填满了页脚的空间。那页脚能扩展吗？是的，这将是一个非常特殊的情况，因为很少有记录会小到让页脚比记录还要大，但当然，页脚是可以扩展的。对，页脚可以并且会扩展，随着新记录的加入，你会发现为记录分配的区域和为页脚分配的区域都会扩展。
- en: Because you're adding additional slot you're adding additional records both
    of them are going to expand。 Right， thank you。 Okay， so I think I should keep
    going because I'm running out of time。 All right。 so that's what I wanted to say
    about growing slots。 I think I already covered this。 So this is the summary for
    slotted pages。 So this， this。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在添加额外的槽位和记录，它们都会扩展。对，谢谢。那么，我想我应该继续，因为时间不多了。好吧，这是我想说的关于槽位扩展的内容。我想我已经讲过这个了。所以，这是关于有槽位页面的总结。就是这样。
- en: this idea is known as slotted pages because a page with slots。 Slotted pages
    are great。 It is sort of a good compromise for variable length records for sure
    but also for fixed rank records。 And this is because fixed length records often
    have null fields。 And if you have null fields these null values can be squashed
    and sort of indicated using a flag avoiding the full attribute length storage。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念被称为有槽位的页面，因为页面中有槽位。有槽位的页面非常好。它确实是处理变长记录的一个不错的折衷方案，同样也适用于固定长度记录。这是因为固定长度记录通常包含空字段。如果你有空字段，这些空值可以通过标志来表示，从而避免存储整个属性长度。
- en: So if you have an int but that it can be null， you might want to sort of compress
    that and store it using a flag instead of storing the entire thing as this occupying
    the same amount of information irrespective of whether it's a null or not。 If
    you have only non null fields that can be benefits to this fixed length format
    without the overhead of the pointers and so on because the bitmap approach is
    often cheaper in that particular special case。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个整数，但它可能为空，你可能想对其进行压缩，使用一个标志存储它，而不是存储整个数据，这样无论它是否为空，都占用相同的存储空间。如果你只有非空字段，那么这种固定长度格式就可以节省存储空间，不需要指针等额外开销，因为位图方法在这种特殊情况下通常更为高效。
- en: Okay， so we went from files to pages pages。 We talked about pages and records
    within pages。 Now let's talk about how a record looks like。 So， each record in
    a table or a relation has a fixed combination of types。 This is determined by
    the schema。 And so the， like I mentioned also earlier to a question the relation
    database is used the same page format for data on disk or in memory。 And this
    is because you want to save cost of conversion this serialization deserialization
    cost of converting objects in memory to disk you don't want to pay that that cost。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们从文件讲到页面。我们讨论了页面和页面内的记录。现在让我们来谈谈记录是怎样的。每个表或关系中的记录都有一组固定的类型组合。这是由模式决定的。正如我之前也提到的，关系型数据库在磁盘或内存中的数据使用相同的页面格式。这是因为你想节省转换的成本——即序列化和反序列化的成本，不想支付将内存中的对象转换到磁盘上的成本。
- en: The other bit that I wanted to say here is that the system catalog the database
    system catalog is storing the schema and therefore it's storing the combination
    of types per relation。 That way you can avoid storing the type information with
    the records and thereby save some space。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里提到的另一点是，系统目录（数据库系统目录）存储着模式，因此它存储着每个关系的类型组合。这样，你就可以避免将类型信息与记录一起存储，从而节省空间。
- en: So you don't need to encode the type information of the record you store that
    separately store it once you're done。 This system catalog usually in most database
    systems is just another table。 And if you're interested we can sort of share the
    table names for that I believe in SQLite it's called SQLite Master。 So what would
    be our goal for encoding this record format what are our objectives the first
    thing is we want to access fields quickly。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你不需要编码记录的类型信息，你可以将类型信息单独存储，等你完成后再存储。这个系统目录在大多数数据库系统中通常是另外一个表。如果你有兴趣，我们可以分享这些表的名称，我相信在
    SQLite 中它叫做 SQLite Master。那么我们对编码这种记录格式的目标是什么？我们的目标首先是快速访问字段。
- en: So why do we want to access fields quickly well often you're not interested
    in the entire record you're interested in components within the record。 So if
    you say select GPA from student you're interested only in the GPA not the rest。
    So you want fast access to the fields。 The second goal is that you want the record
    to be compact so as much as possible you want records to be compact so that you
    can store more records on a page and store for your pages right in a file。 So
    we talk about two cases the fixed length case and then the variable length is
    a fixed length case is easy。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们要快速访问字段呢？通常你并不关心整个记录，你只关心记录中的某些组件。所以，如果你说选择 GPA 从学生表中，你只关心 GPA，而不是其他内容。因此，你希望能够快速访问这些字段。第二个目标是，你希望记录尽可能紧凑，以便你可以在一页中存储更多的记录，并在文件中存储更多的页。所以我们讨论了两种情况：固定长度和可变长度，固定长度的情况很简单。
- en: So that's a good one to start with。 So if you have a fixed length record。 So
    let's say an integer a double boolean another integer in a character with length
    seven。 So even the I feel is easy right we can just do arithmetic and then you
    can retrieve the I feel so for example。 if I want to retrieve this boolean value
    I can skip over the first 12 bytes and then get to this。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个很好的开始。如果你有一个固定长度的记录。例如，假设一个整数，一个双精度浮点数，一个布尔值，另一个整数和一个长度为 7 的字符。即使是 I feel
    也很简单，我们可以直接做算术运算，然后你可以获取 I feel。所以，例如，如果我想获取这个布尔值，我可以跳过前 12 个字节，然后获取到这个值。
- en: So I can make it more compact in certain cases so if all fields are non null
    I have no way of compacting right if the fields are do admit nulls then I have
    to apply variable length scheme so it feels have nulls。 It's essentially like
    variable length。 So let's talk about the variable length scheme。 Okay。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在某些情况下，我可以使它更紧凑。如果所有字段都不为空，我就无法进行压缩；如果字段允许为空，那么我就必须应用可变长度方案。字段允许为空时，本质上就像可变长度一样。接下来我们讨论可变长度方案。好吧。
- en: so what happens if the fields are variable length so in addition to your car
    and in int and int you also have bar car so this was our way of encoding variable
    length strings。 So one approach is to store it with padding right so you basically
    store this Bob and pad it such that it occupies a string of some predetermined
    length let's say 20。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果字段是可变长度的，会发生什么呢？除了你的字符型和整数型，你还可能有一个 bar 字符串。这是我们编码可变长度字符串的一种方式。所以一种方法是通过填充来存储它，也就是说，你基本上存储这个
    Bob，并填充它，使其占据某个预定长度的字符串，比如说 20。
- en: And then this big street which is the Bob's address presumably is fired up to
    length 18。 So you've determined upfront that 20 and 18 is enough as a cut off
    for the length for these two strings。 Now the downside of this is pretty straightforward。
    The first is that you have to firstly account for the largest possible string
    more strings may not be that large so this is going to be wasteful。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这条大街（假设是 Bob 的地址）被扩展到了长度 18。所以你已经预先确定了 20 和 18 作为这两个字符串的长度截断值。现在，这种做法的缺点是非常直接的。首先，你必须首先考虑到可能的最大字符串，其他字符串可能不会那么长，因此这会导致浪费。
- en: Or you are more conservative or you're more aggressive but you'll end up having
    to rearrange as soon as a larger string comes so this is going to be inefficient。
    So this approach of padding is not a great approach。 Another approach that you
    may consider is a use commas so some delimiter to separate these these fields。
    The downside of that approach is that it's harder to determine where one field
    ends and then the other field begins。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可能更加保守，或者更为激进，但你最终会在遇到更大的字符串时不得不重新安排数据，因此这将变得低效。所以这种填充的方法并不是一个很好的方案。你可能考虑的另一种方法是使用逗号，或者其他分隔符来分隔这些字段。这样做的缺点是，确定一个字段的结束位置和另一个字段的起始位置变得更加困难。
- en: So if you want to look up the I feel it's a lot harder。 And it's also hard to
    ensure sometimes that commas are not part of the string so if commas are part
    of the string then you need to find a way to escape them and it's more painful。
    So how do we deal with variable length records well the approach that we're going
    to be using is a per record header。 So record header which is going to point to
    the start or the end in this case the end of each of these variable length fields。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想查找，我觉得这会更加困难。而且有时确保逗号不是字符串的一部分也很困难，如果逗号是字符串的一部分，你需要找到一种方法来转义它们，这会更加麻烦。那么我们如何处理可变长度记录呢？我们将采用的方法是每条记录一个头部。所以记录头将指向这些可变长度字段的开始或结束，在这种情况下是结束。
- en: So here you have one pointer to the end of the first variable length field。
    And here you have a pointer to the end of the second variable length field。 And
    so using the fact that you have some fixed length fields followed by variable
    length fields you know exactly where this variable length field begins and ends。
    And this variable length field begins and ends because you have you know the length
    of the fixed length portion and you know when each of these strings and all these
    variable length fields。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有一个指针指向第一个可变长度字段的末尾。这里你有一个指针指向第二个可变长度字段的末尾。通过利用固定长度字段后跟可变长度字段的事实，你可以准确知道每个可变长度字段的开始和结束位置。这个可变长度字段的开始和结束你知道，因为你知道固定长度部分的长度，并且知道这些字符串和所有可变长度字段的结束位置。
- en: So this is the approach that we're going to adopt which is a record header approach。
    This record header approach gives easy access to fields and is almost as compact
    as you can expect。 Expect modular the header to the fixed length fields are encoded
    as is the variable length fields you do and go to a little bit of extra information
    in these pointers。 And the same approach can be used to squash fixed length null
    fields with many null values as well。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将采用的方案，即记录头方案。这个记录头方案使得访问字段变得更加简便，几乎是你能期望的最紧凑形式。可以预期，头部到固定长度字段的编码方式与可变长度字段一样，只是需要在这些指针中加入一些额外的信息。同样的方法也可以用于压缩包含多个空值的固定长度空字段。
- en: So， even so when you think about fixed length fields。 If you allow now they
    essentially end up being like variable length field so you can use the approach
    for squash in them。 So here's the overview of our approach for representing information。
    So given a relation。 These relation is encoded in a file， which are represent
    one or more files on disk。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使在考虑固定长度字段时，如果你现在允许它们，它们实际上最终会变成类似于可变长度字段的形式，因此你可以使用压缩方法来处理它们。下面是我们用于表示信息的方案概述。给定一个关系，这些关系被编码到一个文件中，这些文件代表磁盘上的一个或多个文件。
- en: Each file contains many pages。 And a given record is represented using this
    encoding encoding format with a record header and as well as fixed length and
    variable length fields。 The header allows you to point to the ends of these fields。
    And then bringing both of these together is the slotted page idea。 which is basically
    encoding a page level header， which is encoding information about where the records
    lie within this page。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件包含多个页面。一个给定的记录使用这种编码格式表示，包括记录头和固定长度及可变长度字段。头部允许你指向这些字段的结尾。然后，将这两者结合起来就是插槽页的概念，基本上是编码一个页面级别的头部，该头部编码了记录在页面中的位置。
- en: And the one thing that I've not shown here is a page directory。 So that is another
    bit of metadata。 which is encoding information about which pages have free space。
    So overall that is the summary of the representation portion。 The way I like to
    think about it is at every year of extraction。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 而我在这里没有展示的一件事是页面目录。那是另一种元数据，编码了有关哪些页面有空闲空间的信息。所以总体而言，这就是表示部分的总结。我喜欢将其看作是在每年提取时的方式。
- en: there is a notion of a header and a notion of the details。 And if you think
    about it in that way。 it becomes a lot easier to understand。 So， like I said。
    a database file contains pages and records within those pages and we talked about
    these heap files to unordered records。 And you have the page directory allowing
    you to locate these pages efficiently。 The page layout。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个头部的概念，也有一个细节的概念。如果你以这种方式考虑它，就会更容易理解。所以，正如我所说，一个数据库文件包含页面，而这些页面内包含记录，我们谈论了这些堆文件（heap
    files）用于无序记录。并且你有页面目录，可以高效地定位这些页面。页面布局。
- en: we talked about the fixed length approach， both packed and unpacked。 And for
    variable length。 we only talked about the unpacked approach using started pages
    with intra page reorganization once the page becomes full。 for example。 We also
    talked about the record format。 allowing access to the field and also the dealing
    with null values。 Any questions at this point。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了固定长度方法，包括压缩格式和解压格式。对于可变长度，我们只讨论了使用起始页和在页面满时进行页面内部重组的解压方法。例如，我们还讨论了记录格式，允许访问字段并处理空值。到目前为止，有什么问题吗？
- en: Ian。 Yeah， so on every slide where we talk about the record formats for variable
    lengths record。 So you mentioned that we could store the data with delimiter，
    like commas。 but it's not a good way to do it。 So can you kind of elaborate on
    how we would do it with commas because it doesn't make sense to me。 Sure。 So imagine
    if so let's see。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 伊恩。是的，所以在我们讨论可变长度记录格式的每一张幻灯片上，你提到我们可以使用分隔符存储数据，比如逗号，但这不是一种好方法。你能详细说明一下如何使用逗号吗？因为这对我来说没有意义。好的，假设这样吧。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_22.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_22.png)'
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_23.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_23.png)'
- en: Okay。 So here you could， for example， and could this as Bob， comma， big treat，
    and then you could。 if you wanted to be， if you wanted to add some more indications
    that this is the start of a string and of a string could use quotation marks。
    And then you could do M 329。 For 703 or something， right。 So you do need to have
    a way to distinguish that this comma is different from this comma。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以在这里，你可以比如说，把它表示为“Bob，逗号，大街”，然后如果你想更明确地标示这是字符串的开始，你可以用引号包围它。然后你可以做“M 329，703”之类的。对，所以你确实需要有办法区分这个逗号和那个逗号。
- en: this comma is a delimiter while this comma is part of a string。 So one way to
    do it would be to escape these strings with quotation marks earlier lost whatever
    I wrote。 But yeah， so that's one way to do it。 There are other ways， of course。
    but it's basically you want to ensure that there's a unique way to read a record。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逗号是分隔符，而这个逗号是字符串的一部分。所以一种做法是用引号来转义这些字符串，之前写的已经丢失了。对，当然还有其他方式，但基本上你需要确保有一种独特的方式来读取记录。
- en: The downside of this approach is fairly obvious right if I have Bob， comma，
    big street。 Comma something something something I don't know where within this
    record to look at if I wanted to find the second field。 right。 So basically in
    this byte representation。 I don't know that this is where I need to start reading
    and then I need to read this long。 This many bytes to get the second field so
    that's harder to do in this representation。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是显而易见的，如果我有“Bob，逗号，大街”，逗号什么什么，我就不知道在哪个位置开始查找第二个字段。对吧。所以基本上，在这种字节表示中，我不知道从哪里开始读取，然后我需要读取这么多字节才能得到第二个字段，所以在这种表示方式下很难做到这一点。
- en: So using comma， we still have to scan sort of the entire scene。 Yeah。 you still
    have to scan through the entire thing or you need to find another way of encoding
    the location for each of these fields which ends up looking like a header。 right，
    and in which case you might as well just use a header you don't need the delimiter
    is anymore。 Okay， thank you。 Lewis。 Lewis， you're still muted if you want to ask
    a question。 Okay。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用逗号时，我们仍然需要扫描整个场景。是的，你仍然需要扫描整个内容，或者你需要找到一种其他方法来编码每个字段的位置，这最终看起来像是一个头部。对吧，届时你可以直接使用头部，不再需要分隔符。好的，谢谢，路易斯。路易斯，如果你想提问的话，你还没有解除静音。
- en: I think we should probably not start the next topic。 If any of you still have
    questions feel free to hang back。 Thank you all for showing up。 Thanks everyone
    see you Thursday。 [ Silence ]。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得我们可能不该开始下一个话题。如果你们还有问题，欢迎留下来。感谢大家的到场。谢谢大家，星期四见。[沉默]。
- en: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_25.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a5b3b541b188bb8f3a47a75d4449fd_25.png)'
