- en: Side-channel attacks on RSA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSA 的侧信道攻击
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 这些讲义略有修改自 6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)
    上发布的讲义，时间为 2014 年。'
- en: Side channel attacks
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧信道攻击
- en: Historically, worried about EM signals leaking. [NSA TEMPEST](http://cryptome.org/nsa-tempest.pdf).
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史上，担心电磁信号泄露。[NSA TEMPEST](http://cryptome.org/nsa-tempest.pdf)。
- en: Broadly, systems may need to worry about many unexpected ways in which
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛地，系统可能需要担心许多意外的方式
- en: information can be revealed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息可能会被泄露。
- en: '*Example setting:* a server (e.g., Apache) has an RSA private key.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例设置：* 服务器（例如，Apache）有一个 RSA 私钥。'
- en: Server uses RSA private key (e.g., decrypt message from client).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器使用 RSA 私钥（例如，解密来自客户端的消息）。
- en: Something about the server's computation is leaked to the client.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的计算信息泄露给客户端。
- en: 'Many information leaks have been looked at:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 已经研究了许多信息泄漏：
- en: How long it takes to decrypt.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密需要多长时间。
- en: How decryption affects shared resources (cache, TLB, branch predictor).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密如何影响共享资源（缓存、TLB、分支预测器）。
- en: Emissions from the CPU itself (RF, audio, power consumption, etc).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 本身的辐射（射频、音频、功耗等）。
- en: Side-channel attacks don't have to be crypto-related.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 侧信道攻击不一定与加密相关。
- en: E.g., operation time relates to which character of password was incorrect.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，操作时间与密码中哪个字符不正确有关。
- en: Or time related to how many common friends you + some user have on Facebook.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或时间与你和某个用户在 Facebook 上有多少共同好友有关。
- en: Or how long it takes to load a page in browser (depends if it was cached).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或加载页面在浏览器中需要多长时间（取决于是否被缓存）。
- en: Or recovering printed text based on sound from dot-matrix printer. [Ref](https://www.usenix.org/conference/usenixsecurity10/acoustic-side-channel-attacks-printers)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或基于点阵打印机的声音恢复打印文本。[参考](https://www.usenix.org/conference/usenixsecurity10/acoustic-side-channel-attacks-printers)
- en: But attacks on passwords or keys are usually the most damaging.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但对密码或密钥的攻击通常是最具破坏性的。
- en: Adversary can analyze information leaks, use it to reconstruct private key.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可以分析信息泄漏，用它来重建私钥。
- en: Currently, side-channel attacks on systems described in the paper are rare.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，本文描述的系统上的侧信道攻击是罕见的。
- en: E.g., Apache web server running on some Internet-connected machine.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，Apache web 服务器运行在某个连接到互联网的机器上。
- en: Often some other vulnerability exists and is easier to exploit.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常存在其他一些漏洞，更容易利用。
- en: 'Slowly becoming a bigger concern: new side-channels (VMs), better attacks.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢慢地成为一个更大的关注点：新的侧信道（虚拟机）、更好的攻击。
- en: Side-channel attacks are more commonly used to attack trusted/embedded hw.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧信道攻击更常用于攻击受信任/嵌入式硬件。
- en: E.g., chip running cryptographic operations on a smartcard.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，芯片在智能卡上运行加密操作。
- en: Often these have a small attack surface, not many other ways to get in.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常这些具有较小的攻击面，没有太多其他方式可以进入。
- en: As paper mentions, some crypto coprocessors designed to avoid this attack.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如论文所述，一些密码协处理器设计用于避免此类攻击。
- en: What's the *"Remote timing attacks are practical"* paper's contribution? [Ref](http://css.csail.mit.edu/6.858/2014/readings/brumley-timing.pdf)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*"远程时间攻击是实际的"* 论文的贡献是什么？[参考](http://css.csail.mit.edu/6.858/2014/readings/brumley-timing.pdf)'
- en: Timing attacks known for a while.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间攻击已知已久。
- en: 'This paper: possible to attack standard Apache web server over the network.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文：可能通过网络攻击标准的 Apache web 服务器。
- en: Uses lots of observations/techniques from prior work on timing attacks.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了许多关于时间攻击的先前工作的观察/技术。
- en: To understand how this works, first let's look at some internals of RSA..
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，首先让我们看一些 RSA 的内部..
- en: 'RSA: high level plan'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSA：高级计划
- en: Pick two random primes, `p` and `q`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择两个随机素数，`p` 和 `q`。
- en: Let `n = p*q`.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `n = p*q`。
- en: A reasonable key length, i.e., `|n|` or `|d|`, is 2048 bits today.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天一个合理的密钥长度，即 `|n|` 或 `|d|`，是 2048 位。
- en: 'Euler''s function `phi(n)`: number of elements of `Z_n^*` relatively prime
    to `n`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧拉函数 `phi(n)`：与 `n` 互质的 `Z_n^*` 元素的数量。
- en: '**Theorem** [no proof here]: `a^(phi(n)) = 1 mod n`, for all `a` and `n`.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定理** [此处无证明]：`a^(phi(n)) = 1 mod n`，对所有的 `a` 和 `n`。'
- en: So, how to encrypt and decrypt?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，如何加密和解密？
- en: Pick two exponents `d` and `e`, such that `m^(e*d) = m (mod n)`, which
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择两个指数 `d` 和 `e`，使得 `m^(e*d) = m (mod n)`，这
- en: means `e*d = 1 mod phi(n)`.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意味着 `e*d = 1 mod phi(n)`。
- en: Encryption will be `c = m^e (mod n)`; decryption will be `m = c^d (mod n)`.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密将是 `c = m^e (mod n)`；解密将是 `m = c^d (mod n)`。
- en: How to get such `e` and `d`?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获得这样的 `e` 和 `d`？
- en: For `n=pq`, `phi(n) = (p-1)(q-1)`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `n=pq`，`phi(n) = (p-1)(q-1)`。
- en: Easy to compute `d=1/e`, if we know `phi(n)`. [Extended Euclidean algorithm](http://en.wikipedia.org/wiki/Modular_multiplicative_inverse)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们知道`phi(n)`，很容易计算`d=1/e`。[扩展欧几里得算法](http://en.wikipedia.org/wiki/Modular_multiplicative_inverse)
- en: In practice, pick small `e` (e.g., 65537), to make encryption fast.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实践中，选择小的`e`（例如，65537），使加密更快。
- en: Public key is `(n, e)`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥是`(n, e)`。
- en: Private key is, in principle, `(n, d)`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥原则上是`(n, d)`。
- en: '**Note:** `p` and `q` must be kept secret!'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意：**`p`和`q`必须保密！'
- en: Otherwise, adversary can compute `d` from `e`, as we did above.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，对手可以像我们上面做的那样从`e`计算`d`。
- en: Knowing `p` and `q` also turns out to be helpful for fast decryption.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道`p`和`q`对快速解密也很有帮助。
- en: So, in practice, private key includes `(p, q)` as well.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，在实践中，私钥也包括`(p, q)`。
- en: RSA is tricky to use "securely" -- be careful if using RSA directly!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RSA在“安全”使用上有些棘手--如果直接使用RSA，请小心！
- en: Ciphertexts are multiplicative
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密文是可乘的。
- en: '`E(a)*E(b) = a^e * b^e = (ab)^e`.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E(a)*E(b) = a^e * b^e = (ab)^e`。'
- en: Can allow adversary to manipulate encryptions, generate new ones.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以让对手操纵加密，生成新的加密。
- en: RSA is deterministic
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA是确定性的。
- en: Encrypting the same plaintext will generate the same ciphertext each time.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密相同的明文每次都会生成相同的密文。
- en: Adversary can tell when the same thing is being re-encrypted.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手可以知道何时重新加密相同的内容。
- en: Typically solved by "padding" messages before encryption. [OAEP](http://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常通过在加密前对消息进行“填充”来解决。[OAEP](http://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding)
- en: Take plaintext message bits, add padding bits before and after plaintext.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取明文消息位，加上明文前后的填充位。
- en: Encrypt the combined bits (must be less than `|n|` bits total).
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密组合位（总位数必须小于`|n|`位）。
- en: Padding includes randomness, as well as fixed bit patterns.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充包括随机性，以及固定位模式。
- en: Helps detect tampering (e.g. ciphertext multiplication).
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于检测篡改（例如，密文乘法）。
- en: How to implement RSA?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现RSA？
- en: '**Key problem:** fast modular exponentiation.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键问题：**快速模指数运算。'
- en: In general, quadratic complexity.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，是二次复杂度。
- en: Multiplying two 1024-bit numbers is slow.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个1024位数相乘很慢。
- en: Computing the modulus for 1024-bit numbers is slow (1024-bit divison).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算1024位数的模很慢（1024位除法）。
- en: 'Optimization 1: Chinese Remainder Theorem (CRT).'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化1：中国剩余定理（CRT）。
- en: 'Recall what the CRT says:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下CRT的原理：
- en: if `x==a1 (mod p)` and `x==a2 (mod q)`, where `p` and `q` are relatively prime,
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x==a1 (mod p)`和`x==a2 (mod q)`，其中`p`和`q`是互质的，
- en: then there's a unique solution `x==a (mod pq)`.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么就有一个唯一解`x==a (mod pq)`。
- en: and, there's an efficient algorithm for computing `a`
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且，有一种高效的算法来计算`a`。
- en: Suppose we want to compute `m = c^d (mod pq)`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们想要计算`m = c^d (mod pq)`。
- en: Can compute `m1 = c^d (mod p)`, and `m2 = c^d (mod q)`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以计算`m1 = c^d (mod p)`，以及`m2 = c^d (mod q)`。
- en: Then use CRT to compute `m = c^d (mod n)` from `m1`, `m2`; it's unique and fast.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用CRT从`m1`、`m2`计算`m = c^d (mod n)`；这是唯一且快速的。
- en: Computing `m1` (or `m2`) is ~4x faster than computing `m` directly (~quadratic).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算`m1`（或`m2`）比直接计算`m`快约4倍（~二次）。
- en: Computing `m` from `m1` and `m2` using CRT is ~negligible in comparison.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CRT从`m1`和`m2`计算`m`的速度与忽略不计。
- en: So, roughly a 2x speedup.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，大约加速2倍。
- en: 'Optimization 2: Repeated squaring and Sliding windows.'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化2：重复平方和滑动窗口。
- en: 'Naive approach to computing `c^d`: multiply `c` by itself, `d` times.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算`c^d`的朴素方法：将`c`乘以自身，`d`次。
- en: 'Better approach, called repeated squaring:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的方法，称为重复平方：
- en: '`c^(2x) = (c^x)^2`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c^(2x) = (c^x)^2`'
- en: '`c^(2x+1) = (c^x)^2 * c`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c^(2x+1) = (c^x)^2 * c`'
- en: To compute `c^d`, first compute `c^(floor(d/2))`, then use above for `c^d`.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要计算`c^d`，首先计算`c^(floor(d/2))`，然后使用上述方法计算`c^d`。
- en: Recursively apply until the computation hits `c^0 = 1`.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归应用，直到计算到`c^0 = 1`。
- en: 'Number of squarings: `|d|` (the number of bits needed to represent `d`)'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方次数：`|d|`（表示`d`所需的位数）。
- en: 'Number of multiplications: number of 1 bits in `d`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法次数：`d`中的1位数。
- en: 'Better yet (sometimes), called *sliding window*:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的方法（有时），称为*滑动窗口*：
- en: '`c^(2x) = (c^x)^2`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c^(2x) = (c^x)^2`'
- en: '`c^(32x+1) = (c^x)^32 * c`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c^(32x+1) = (c^x)^32 * c`'
- en: '`c^(32x+3) = (c^x)^32 * c^3`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c^(32x+3) = (c^x)^32 * c^3`'
- en: '...'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...'
- en: '`c^(32x+z) = (c^x)^32 * c^z`, generally (where `z<=31`)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c^(32x+z) = (c^x)^32 * c^z`，通常情况下（其中`z<=31`）。'
- en: Can pre-compute a table of all necessary `c^z` powers, store in memory.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以预先计算所有必要的`c^z`幂的表，存储在内存中。
- en: The choice of power-of-2 constant (e.g., 32) depends on usage.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择2的幂常数（例如，32）取决于使用情况。
- en: 'Costs: extra memory, extra time to pre-compute powers ahead of time.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本：额外内存，额外时间来预先计算幂。
- en: 'Note: only pre-compute odd powers of `c` (use first rule for even).'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意：仅预先计算`c`的奇数次幂（对于偶数使用第一条规则）。
- en: OpenSSL uses 32 (table with 16 pre-computed entries).
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL使用32（具有16个预先计算的条目的表）。
- en: 'Optimization 3: Montgomery representation.'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化3：蒙哥马利表示。
- en: Reducing `mod p` each time (after square or multiply) is expensive.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次（平方或乘法后）都进行`mod p`减少是昂贵的。
- en: 'Typical implementation: do long division, find remainder.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型实现：进行长除法，找到余数。
- en: 'Hard to avoid reduction: otherwise, value grows exponentially.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以避免减少：否则，值会呈指数增长。
- en: 'Idea (by Peter Montgomery): do computations in another representation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理念（由彼得·蒙哥马利提出）：在另一种表示中进行计算。
- en: Shift the base (e.g., `c`) into different representation upfront.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基数（例如`c`）提前转换为不同的表示。
- en: Perform modular operations in this representation (will be cheaper).
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种表示中执行模运算（会更便宜）。
- en: Shift numbers back into original representation when done.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成后将数字移回原始表示。
- en: Ideally, savings from reductions outweigh cost of shifting.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，减少的节省应超过移位的成本。
- en: 'Montgomery representation: multiply everything by some factor R.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙哥马利表示：将所有内容乘以某个因子R。
- en: '`a mod q <-> aR mod q`'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a mod q <-> aR mod q`'
- en: '`b mod q <-> bR mod q`'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b mod q <-> bR mod q`'
- en: '`c = a*b mod q <-> cR mod q = (aR * bR)/R mod q`'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c = a*b mod q <-> cR mod q = (aR * bR)/R mod q`'
- en: Each mul (or sqr) in Montgomery-space requires division by `R`.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个在蒙哥马利空间中的乘法（或平方）需要除以`R`。
- en: Why is modular multiplication cheaper in Montgomery repr.?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙哥马利表示中模乘法为何更便宜？
- en: 'Choose `R` so division by `R` is easy: `R = 2^|q|` (`2^512` for 1024-bit keys).'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择`R`使得除以`R`更容易：`R = 2^|q|`（1024位密钥为`2^512`）。
- en: Because we divide by `R`, we will often not need to do `mod q`.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们除以`R`，通常不需要进行`mod q`。
- en: '`|aR| = |q|`'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|aR| = |q|`'
- en: '`|bR| = |q|`'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|bR| = |q|`'
- en: '`|aR * bR| = 2|q|`'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|aR * bR| = 2|q|`'
- en: '`|aR * bR / R| = |q|`'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|aR * bR / R| = |q|`'
- en: How do we divide by `R` cheaply?
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何便宜地除以`R`？
- en: Only works if lower bits are zero.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当低位为零时才有效。
- en: '*Observation:* since we care about value `mod q`, multiples of `q` don''t matter.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*观察：* 因为我们关心值`mod q`，所以`q`的倍数并不重要。'
- en: '*Trick:* add multiples of `q` to the number being divided by `R`, make low
    bits 0.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技巧：* 向被除以`R`的数字添加`q`的倍数，使低位为0。'
- en: For example, suppose `R=2^4 (10000)`, `q=7 (111)`, divide `x=26 (11010)` by
    R.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，假设`R=2^4 (10000)`，`q=7 (111)`，将`x=26 (11010)`除以R。
- en: '`x+2q = (binary) * 101000`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x+2q = (二进制) * 101000`'
- en: '`x+2q+8q = (binary) 1100000`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x+2q+8q = (二进制) 1100000`'
- en: 'Now, can easily divide by `R`: result is binary 110 (or 6).'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，可以轻松地除以`R`：结果是二进制110（或6）。
- en: 'Generally, always possible:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，总是可能的：
- en: Low bit of `q` is 1 (`q` is prime), so can "shoot down" any bits.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`的最低位为1（`q`是质数），因此可以"击倒"任何位。'
- en: To "shoot down" bit `k`, add `2^k * q`
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要"击倒"比特`k`，添加`2^k * q`
- en: To shoot down low-order bits `l`, add `q*(l*(-q^-1) mod R)`
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要击倒低位`l`，添加`q*(l*(-q^-1) mod R)`
- en: Then, dividing by `R` means simply discarding low zero bits.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，除以`R`意味着简单地丢弃低零位。
- en: '*One remaining problem:* result will be `< R`, but might be `> q`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个仍未解决的问题：* 结果将会`< R`，但可能会`> q`。'
- en: If the result happens to be greater than `q`, need to subtract `q`.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果恰好大于`q`，需要减去`q`。
- en: This is called the "extra reduction".
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这被称为"额外减少"。
- en: When computing `x^d mod q`, `Pr[extra reduction] = (x mod q) / 2R`.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算`x^d mod q`时，`Pr[额外减少] = (x mod q) / 2R`。
- en: Here, `x` is assumed to be already in Montgomery form.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，假设`x`已经处于蒙哥马利形式。
- en: '*Intuition:* as we multiply bigger numbers, will overflow more often.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直觉：* 随着我们乘以更大的数字，将更频繁地溢出。'
- en: 'Optimization 4: Efficient multiplication.'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化4：高效乘法。
- en: How to multiply 512-bit numbers?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将512位数字相乘？
- en: 'Representation: break up into 32-bit values (or whatever hardware supports).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示：将其分解为32位值（或任何硬件支持的值）。
- en: 'Naive approach: pair-wise multiplication of all 32-bit components.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Naive方法：逐对乘以所有32位组件。
- en: Same as if you were doing digit-wise multiplication of numbers on paper.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像你在纸上逐位相乘数字一样。
- en: Requires `O(nm)` time if two numbers have `n` and `m` components respectively.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个数字分别具有`n`和`m`个组件，则需要`O(nm)`时间。
- en: '`O(n^2)` if the two numbers are close.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个数字接近，则为`O(n^2)`。
- en: '**Karatsuba multiplication:** assumes both numbers have same number of components.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卡拉兹巴乘法：** 假设两个数字具有相同数量的组件。'
- en: '`O(n^log_3(2)) = O(n^1.585)`time.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(n^log_3(2)) = O(n^1.585)`时间。'
- en: Split both numbers (`x` and `y`) into two components (`x1`, `x0` and `y1`, `y0`).
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个数字（`x`和`y`）分成两个组件（`x1`，`x0`和`y1`，`y0`）。
- en: '`x = x1 * B + x0`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x = x1 * B + x0`'
- en: '`y = y1 * B + y0`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y = y1 * B + y0`'
- en: E.g., `B=2^32` when splitting 64-bit numbers into 32-bit components.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，将64位数字分成32位组件时，`B=2^32`。
- en: 'Naive: `x*y = x1y1 * B^2 + x0y1 * B + x1y0 * B + x0y0`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Naive: `x*y = x1y1 * B^2 + x0y1 * B + x1y0 * B + x0y0`'
- en: 'Four multiplies: `O(n^2)`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四次乘法：`O(n^2)`
- en: 'Faster: `x*y = x1y1 * (B^2+B) - (x1-x0)(y1-y0) * B + x0y0 * (B+1)`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快：`x*y = x1y1 * (B^2+B) - (x1-x0)(y1-y0) * B + x0y0 * (B+1)`
- en: '... `= x1y1 * B^2 + ( -(x1-x0)(y1-y0) + x1y1 + x0y0 ) * B + x0y0`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '... `= x1y1 * B^2 + ( -(x1-x0)(y1-y0) + x1y1 + x0y0 ) * B + x0y0`'
- en: Just three multiplies, and a few more additions.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需三次乘法，以及几次加法。
- en: Recursively apply this algorithm to keep splitting into more halves.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归应用此算法以继续分割为更多的一半。
- en: Sometimes called "recursive multiplication".
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时被称为 "递归乘法"。
- en: Meaningfully faster (no hidden big constants)
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有意义地更快（没有隐藏的大常数）
- en: For 1024-bit keys, "`n`" here is 16 (512/32).
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 1024 位密钥，"`n`" 这里是 16 (512/32)。
- en: '`n^2 = 256`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n^2 = 256`'
- en: '`n^1.585 = 81`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n^1.585 = 81`'
- en: Multiplication algorithm needs to decide when to use Karatsuba vs. Naive.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法算法需要决定何时使用 Karatsuba 而不是 Naive。
- en: 'Two cases matter: *two large numbers*, and *one large + one small number*.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种情况很重要：*两个大数* 和 *一个大数 + 一个小数*。
- en: 'OpenSSL: if equal number of components, use Karatsuba, otherwise Naive.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL：如果组件数量相等，则使用 Karatsuba，否则使用 Naive。
- en: In some intermediate cases, Karatsuba may win too, but OpenSSL ignores it,
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些中间情况下，Karatsuba 也可能胜出，但 OpenSSL 忽略了它，
- en: according to this paper.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据这篇论文。
- en: How does SSL use RSA?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 如何使用 RSA？
- en: Server's SSL certificate contains public key.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的 SSL 证书包含公钥。
- en: Server must use private key to prove its identity.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器必须使用私钥来证明其身份。
- en: Client sends random bits to server, encrypted with server's public key.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用服务器的公钥加密后向服务器发送随机位。
- en: Server decrypts client's message, uses these bits to generate session key.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器解密客户端的消息，使用这些位生成会话密钥。
- en: In reality, server also verifies message padding.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，服务器还验证消息填充。
- en: However, can still measure time until server responds in some way.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，仍然可以测量直到服务器以某种方式响应的时间。
- en: 'Figure of **decryption pipeline** on the server:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上 **解密流水线** 的图示：
- en: '[PRE0]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, compute `m_0 = m'_0/R mod q`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，计算 `m_0 = m'_0/R mod q`。
- en: Then, combine `m_0` and `m_1` using CRT to get `m`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用 CRT 结合 `m_0` 和 `m_1` 得到 `m`。
- en: Then verify padding in `m`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后验证 `m` 中的填充。
- en: Finally, use payload in some way (SSL, etc).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，以某种方式使用有效载荷（SSL 等）。
- en: Setup for the attack described in Brumley's paper
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Brumley 论文中描述的攻击设置
- en: Victim Apache HTTPS web server using OpenSSL, has private key in memory.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受害者 Apache HTTPS 网络服务器使用 OpenSSL，在内存中有私钥。
- en: Connected to Stanford's campus network.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到斯坦福校园网络。
- en: Adversary controls some client machine on campus network.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手控制校园网络上的某些客户端机器。
- en: Adversary sends specially-constructed ciphertext in msg to server.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手向服务器发送特制的消息中的密文。
- en: Server decrypts ciphertext, finds garbage padding, returns an error.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器解密密文，找到垃圾填充，返回错误。
- en: Client measures response time to get error message.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端测量响应时间以获取错误消息。
- en: Uses the response time to guess bits of `q`.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用响应时间猜测 `q` 的位。
- en: Overall response time is on the order of 5 msec.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体响应时间大约为 5 毫秒。
- en: Time difference between requests can be around 10 usec.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求之间的时间差大约为 10 微秒。
- en: What causes time variations?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么导致时间变化？
- en: Karatsuba vs. Naive
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Karatsuba 与 Naive
- en: extra reductions
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的减少
- en: Once guessed enough bits of `q`, can factor `n=p*q`, compute `d` from `e`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦猜测足够多的 `q` 位，就可以因式分解 `n=p*q`，从 `e` 计算 `d`。
- en: About 1M queries seem enough to obtain 512-bit `p` and `q` for 1024-bit key.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约 1M 次查询似乎足以获取 1024 位密钥的 512 位 `p` 和 `q`。
- en: Only need to guess the top 256 bits of `p` and `q`, then use another algorithm.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需猜测 `p` 和 `q` 的前 256 位，然后使用另一种算法。
- en: Attack from Brumley's paper
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Brumley 论文中的攻击
- en: See the *Remote timing attacks are practical* paper cited in the *References*
    section at the end for more details.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 *远程定时攻击是可行的* 论文，详细内容请参考末尾的 *参考文献* 部分。
- en: Let `q = q_0 q_1 .. q_N`, where `N = |q|` (say, 512 bits for 1024-bit keys).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `q = q_0 q_1 .. q_N`，其中 `N = |q|`（比如，对于 1024 位密钥，假设为 512 位）。
- en: Assume we know some number `j` of high-order bits of `q` (`q_0` through `q_j`).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们知道 `q` 的高阶位 `j` 个数字（从 `q_0` 到 `q_j`）。
- en: 'Construct two approximations of q, guessing `q_{j+1}` is either 0 or 1:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造两个近似值的 `q`，猜测 `q_{j+1}` 是 0 或 1：
- en: '`g = q_0 q_1 .. q_j 0 0 0 .. 0`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g = q_0 q_1 .. q_j 0 0 0 .. 0`'
- en: '`g_hi = q_0 q_1 .. q_j 1 0 0 .. 0`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_hi = q_0 q_1 .. q_j 1 0 0 .. 0`'
- en: Get the server to perform modular exponentiation (`g^d`) for both guesses.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让服务器执行模幂运算 (`g^d`) 来猜测。
- en: We know `g` is necessarily less than `q`.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道 `g` 必然小于 `q`。
- en: If `g` and `g_hi` are both less than `q`, time taken shouldn't change much.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `g` 和 `g_hi` 都小于 `q`，花费的时间不应该有太大变化。
- en: If `g_hi` is greater than `q`, time taken might change noticeably.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `g_hi` 大于 `q`，花费的时间可能会明显变化。
- en: '`g_hi mod q` is small.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_hi mod q` 很小。'
- en: 'Less time: fewer extra reductions in Montgomery.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少时间：Montgomery 中减少额外的减少。
- en: 'More time: switch from Karatsuba to normal multiplication.'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多时间：从卡拉茨巴切换到普通乘法。
- en: Knowing the time taken can tell us if 0 or 1 was the right guess.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道所花费的时间可以告诉我们0还是1是正确的猜测。
- en: How to get the server to perform modular exponentiation on our guess?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让服务器对我们的猜测执行模指数运算？
- en: Send our guess as if it were the encryption of randomness to server.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的猜测发送给服务器，就好像它是随机性的加密。
- en: 'One snag: server will convert our message to Montgomery form.'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题：服务器将把我们的消息转换为蒙哥马利形式。
- en: Since Montgomery's `R` is known, send (`g/R mod n`) as message to server.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于蒙哥马利的`R`是已知的，将(`g/R mod n`)作为消息发送给服务器。
- en: How do we know if the time difference should be positive or negative?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定时间差应该是正数还是负数？
- en: 'Paper seems to suggest it doesn''t matter: just look for large diff.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文似乎暗示这并不重要：只需寻找大的差异。
- en: Figure 3a shows the measured time differences for each bit's guess.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图3a显示了每个比特猜测的测量时间差异。
- en: Karatsuba vs. normal multiplication happens at 32-bit boundaries.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡拉茨巴与普通乘法发生在32位边界处。
- en: 'First 32 bits: extra reductions dominate.'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前32位：额外的约简占主导地位。
- en: 'Next bits: Karatsuba vs normal multiplication dominates.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的位：卡拉茨巴与普通乘法的支配。
- en: At some point, extra reductions start dominating again.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个时刻，额外的约简再次占主导地位。
- en: What happens if the time difference from the two effects cancels out?
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两种效应的时间差抵消会发生什么？
- en: Figure 3, key 3.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图3，关键3。
- en: Larger neighborhood changes the balance a bit, reveals a non-zero gap.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大的邻域会稍微改变平衡，揭示非零间隙。
- en: How does the paper get accurate measurements?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文如何获得准确的测量结果？
- en: Client machine uses processor's timestamp counter (`rdtsc` on x86).
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户机使用处理器的时间戳计数器（在x86上为`rdtsc`）。
- en: Measure several times, take the median value.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行多次测量，取中位数值。
- en: Not clear why median; min seems like it would be the true compute time.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不清楚为什么要中位数；最小值似乎才是真正的计算时间。
- en: 'One snag: relatively few multiplications by `g`, due to sliding windows.'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题：由于滑动窗口，对`g`的乘法相对较少。
- en: 'Solution: get more multiplications by values close to `g` (+ same for `g_hi`).'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：通过获取与`g`接近的值进行更多的乘法运算（对`g_hi`同样适用）。
- en: Specifically, probe a "neighborhood" of `g` (`g, g+1, .., g+400`).
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体来说，探测`g`的“邻域”（`g, g+1, .., g+400`）。
- en: Why probe a 400-value neighborhood of `g` instead of measuring `g` 400 times?
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要探测`g`的400个值的邻域，而不是测量`g` 400次？
- en: Consider the kinds of noise we are trying to deal with.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑我们试图处理的噪音类型。
- en: (1) Noise unrelated to computation (e.g. interrupts, network latency).
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (1) 与计算无关的噪音（例如中断，网络延迟）。
- en: This might go away when we measure the same thing many times.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们多次测量相同的事物时，这种情况可能会消失。
- en: See Figure 2a in the paper.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见论文中的图2a。
- en: (2) "Noise" related to computation.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (2) 与计算相关的“噪音”。
- en: E.g., multiplying by `g^3` and `g_hi^3` in sliding window takes diff time.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，通过滑动窗口将`g^3`和`g_hi^3`相乘需要不同的时间。
- en: Repeated measurements will return the same value.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的测量将返回相同的数值。
- en: Will not help determine whether mul by `g` or `g_hi` has more reductions.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会帮助确定是通过`g`还是`g_hi`进行更多的约简。
- en: See Figure 2b in the paper.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见论文中的图2b。
- en: Neighborhood values average out 2nd kind of noise.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻域值平均出第二种噪音。
- en: 'Since neighborhood values are nearby, still has ~same # reductions.'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于邻域值相邻，仍具有大致相同数量的约简。
- en: How to avoid these attacks?
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何避免这些攻击？
- en: 'Timing attack on decryption time: RSA blinding.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密时间的定时攻击：RSA盲化。
- en: Choose random `r`.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择随机的`r`。
- en: 'Multiply ciphertext by `r^e mod n`: `c'' = c*r^e mod n`.'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密文乘以`r^e mod n`：`c' = c*r^e mod n`。
- en: Due to multiplicative property of RSA, `c'` is an encryption of `m*r`.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于RSA的乘法性质，`c'`是`m*r`的加密。
- en: Decrypt ciphertext `c'` to get message `m'`.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密密文`c'`以获取消息`m'`。
- en: 'Divide plaintext by `r`: `m = m''/r`.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将明文除以`r`：`m = m'/r`。
- en: About a 10% CPU overhead for OpenSSL, according to Brumley's paper.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据布鲁姆利的论文，OpenSSL的CPU开销约为10%。
- en: Make all code paths predictable in terms of execution time.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使所有代码路径在执行时间方面可预测。
- en: Hard, compilers will strive to remove unnecessary operations.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 困难，编译器将努力消除不必要的操作。
- en: Precludes efficient special-case algorithms.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止了高效的特殊情况算法。
- en: 'Difficult to predict execution time: instructions aren''t fixed-time.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以预测执行时间：指令不是固定时间的。
- en: Can we take away access to precise clocks?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否剥夺对精确时钟的访问？
- en: Yes for single-threaded attackers on a machine we control.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们控制的机器上的单线程攻击者是可以的。
- en: Can add noise to legitimate computation, but attacker might average.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以向合法计算添加噪音，但攻击者可能会进行平均。
- en: Can quantize legitimate computations, at some performance cost.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对合法计算进行量化，但会有一定的性能成本。
- en: But with "sleeping" quantization, throughput can still leak info.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但通过"睡眠"量化，吞吐量仍然可能泄漏信息。
- en: How worried should we be about these attacks?
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应该对这些攻击感到多么担忧？
- en: Relatively tricky to develop an exploit (but that's a one-time problem).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发利用程序相对棘手（但这是一个一次性问题）。
- en: Possible to notice attack on server (many connection requests).
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会注意到服务器上的攻击（许多连接请求）。
- en: Though maybe not so easy on a busy web server cluster?
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管在繁忙的Web服务器集群上可能不那么容易？
- en: Adversary has to be close by, in terms of network.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手必须在网络方面靠近。
- en: Not that big of a problem for adversary.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于对手来说并不是一个大问题。
- en: Can average over more queries, co-locate nearby (Amazon EC2),
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对更多查询进行平均，共同定位附近（Amazon EC2），
- en: Run on a nearby bot or browser, etc.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在附近的机器人或浏览器上运行等。
- en: Adversary may need to know the version, optimization flags, etc of OpenSSL.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手可能需要知道OpenSSL的版本、优化标志等。
- en: Is it a good idea to rely on such a defense?
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖这样的防御措施是个好主意吗？
- en: How big of an impediment is this?
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会带来多大的障碍？
- en: If adversary mounts attack, effects are quite bad (key leaked).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对手发动攻击，后果相当严重（密钥泄露）。
- en: Other types of timing attacks
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的时序攻击
- en: '**Page-fault timing for password guessing** [Tenex system]'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于猜测密码的页面错误时序** [Tenex系统]'
- en: Suppose the kernel provides a system call to check user's password.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设内核提供了一个系统调用来检查用户的密码。
- en: Checks the password one byte at a time, returns error when finds mismatch.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐字节检查密码，当发现不匹配时返回错误。
- en: Adversary aligns password, so that first byte is at the end of a page,
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手对齐密码，使第一个字节位于页面末尾，
- en: Rest of password is on next page.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码的其余部分在下一页。
- en: Somehow arrange for the second page to be swapped out to disk.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以某种方式安排第二页被交换到磁盘。
- en: Or just unmap the next page entirely (using equivalent of `mmap`).
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者完全取消映射下一页（使用等效的`mmap`）。
- en: Measure time to return an error when guessing password.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量猜测密码时返回错误所需的时间。
- en: If it took a long time, kernel had to read in the second page from disk.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果花费了很长时间，内核必须从磁盘中读取第二页。
- en: Or, if unmapped, if crashed, then kernel tried to read second page. ]
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，如果取消映射，如果崩溃，那么内核会尝试读取第二页。
- en: Means first character was right!
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意味着第一个字符是正确的！
- en: Can guess an `N`-character password in `256*N` tries, rather than `256^N`.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在`256*N`次尝试中猜出一个`N`字符的密码，而不是`256^N`次。
- en: '**Cache analysis attacks:** processor''s cache shared by all processes.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存分析攻击：** 处理器的缓存由所有进程共享。'
- en: 'E.g.: accessing one of the sliding-window multiples brings it in cache.'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：访问滑动窗口的一个倍数会将其带入缓存。
- en: Necessarily evicts something else in the cache.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缓存中必然会驱逐其他内容。
- en: Malicious process could fill cache with large array, watch what's evicted.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意进程可能会用大数组填充缓存，观察被驱逐的内容。
- en: Guess parts of exponent (`d`) based on offsets being evicted.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据被驱逐的偏移量猜测指数(`d`)的部分。
- en: Cache attacks are potentially problematic with "mobile code".
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存攻击在"移动代码"中可能会有问题。
- en: NaCl modules, Javascript, Flash, etc running on your desktop or phone.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的桌面或手机上运行的NaCl模块、Javascript、Flash等。
- en: '**Network traffic timing / analysis attacks**.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络流量时序/分析攻击**。'
- en: Even when data is encrypted, its ciphertext size remains ~same as plaintext.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使数据被加密，其密文大小仍然与明文大小相近。
- en: Recent papers show can infer a lot about SSL/VPN traffic by sizes, timing.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近的论文表明可以通过大小、时序推断出许多关于SSL/VPN流量的信息。
- en: E.g., Fidelity lets customers manage stocks through an SSL web site.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，Fidelity允许客户通过SSL网站管理股票。
- en: Web site displays some kind of pie chart image for each stock.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站为每支股票显示某种饼图图像。
- en: User's browser requests images for all of the user's stocks.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的浏览器请求所有用户的股票图像。
- en: Adversary can enumerate all stock pie chart images, knows sizes.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手可以枚举所有股票饼图图像，知道大小。
- en: Can tell what stocks a user has, based on sizes of data transfers.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以根据数据传输的大小推断用户拥有的股票。
- en: Similar to CRIME attack mentioned in guest lecture earlier this term.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于本学期早些时候客座讲座中提到的CRIME攻击。
- en: References
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[Remote timing attacks are practical](http://css.csail.mit.edu/6.858/2014/readings/brumley-timing.pdf)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[远程时序攻击是实际的](http://css.csail.mit.edu/6.858/2014/readings/brumley-timing.pdf)'
- en: '[Cache missing for fun and profit](http://css.csail.mit.edu/6.858/2014/readings/ht-cache.pdf)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为了好玩和利润而缺失缓存](http://css.csail.mit.edu/6.858/2014/readings/ht-cache.pdf)'
- en: '[Efficient Cache Attacks on AES, and Countermeasures](http://www.tau.ac.il/~tromer/papers/cache-joc-20090619.pdf)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AES的高效缓存攻击及对策](http://www.tau.ac.il/~tromer/papers/cache-joc-20090619.pdf)'
- en: '[Get Your Hands Off My Laptop: Physical Side-Channel Key-Extraction Attacks
    on PCs](http://www.tau.ac.il/~tromer/papers/handsoff-20140731.pdf)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[离开我的笔记本电脑：针对个人电脑的物理侧信道密钥提取攻击](http://www.tau.ac.il/~tromer/papers/handsoff-20140731.pdf)'
- en: '[Cross-VM Side Channels and Their Use to Extract Private Keys](http://www.cs.unc.edu/~reiter/papers/2012/CCS.pdf)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跨虚拟机侧信道及其用于提取私钥](http://www.cs.unc.edu/~reiter/papers/2012/CCS.pdf)'
- en: '[Ed25519: high-speed high-security signatures](http://ed25519.cr.yp.to/)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ed25519：高速高安全性签名](http://ed25519.cr.yp.to/)'
