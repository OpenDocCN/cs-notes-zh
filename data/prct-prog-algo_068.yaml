- en: 2.2 Modules and Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 模块和客户端
- en: 原文：[https://introcs.cs.princeton.edu/python/22module](https://introcs.cs.princeton.edu/python/22module)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/22module](https://introcs.cs.princeton.edu/python/22module)
- en: 'Each program that you have composed so far consists of Python code that resides
    in a single .py file. For large programs, keeping all the code in a single file
    is restrictive and unnecessary. Fortunately, it is easy in Python to call a function
    that is defined in another file. This ability has two important consequences:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你编写的每个程序都包含在一个单独的 .py 文件中的 Python 代码。对于大型程序来说，将所有代码放在一个文件中是受限制且不必要的。幸运的是，在
    Python 中很容易调用另一个文件中定义的函数。这种能力有两个重要的后果：
- en: It enables code reuse. One program can use code that is already written and
    debugged, not by copying the code, but just by calling it. By doing so, you essentially
    can extend Python — you can define and use your own set of operations on data.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了代码重用。一个程序可以使用已经编写和调试过的代码，而不是复制代码，只需调用它。通过这样做，你实际上可以扩展 Python —— 你可以定义并使用自己的一组数据操作。
- en: It enables modular programming. You can not only divide a program into functions,
    as just described in Section 2.1, but also keep them in different files, grouped
    together according to the needs of the application. Modular programming is important
    because it allows us to independently compose and debug parts of big programs
    one piece at a time, leaving each finished piece in its own file for later use
    without having to worry about its details again.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了模块化编程。你不仅可以将程序分成函数，就像在第 2.1 节中描述的那样，还可以将它们保存在不同的文件中，根据应用程序的需求进行分组。模块化编程很重要，因为它允许我们独立地逐步组合和调试大型程序的部分，将每个完成的部分留在自己的文件中以供以后使用，而无需再担心其细节。
- en: '* * *'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Using Functions in Other Programs
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在其他程序中使用函数
- en: 'To refer to a function in one Python program that is defined in another, we
    use the same mechanism that we have been using to call functions in our `std*`
    modules and Python''s `math` and `random` modules. In this section, we describe
    this basic Python language mechanism. To do so, we distinguish two types of Python
    programs:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用另一个 Python 程序中定义的函数，我们使用与调用`std*`模块和 Python 的`math`和`random`模块中的函数相同的机制。在本节中，我们描述这种基本的
    Python 语言机制。为此，我们区分两种类型的 Python 程序：
- en: A *module* contains functions that are available for use by other programs.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*模块*包含其他程序可用的函数。
- en: A *client* is a program that makes use of a function in a module.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*客户端*是使用模块中函数的程序。
- en: 'There are five (simple) steps that you need to take to create and use a module.
    We illustrate the complete process with the module [gaussian.py](gaussian.py.html),
    which is a modularized version of [gauss.py](../21function/gauss.py.html) (from
    Section 2.1) for computing the Gaussian distribution functions, and the client
    [gaussiantable.py](gaussiantable.py.html), which uses the module to compute and
    write a table of values. These are the five steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用模块需要执行五个（简单）步骤。我们用模块 [gaussian.py](gaussian.py.html) 和客户端 [gaussiantable.py](gaussiantable.py.html)
    来说明完整的过程，其中模块是计算高斯分布函数的模块化版本，而客户端使用该模块来计算并写入值表。这是五个步骤：
- en: '*In the client: import the module.* The client [gaussiantable.py](gaussiantable.py.html)
    contains the statement `import gaussian`; now it can call any function defined
    in the module [gaussian.py](gaussian.py.html).'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在客户端中：导入模块。* 客户端 [gaussiantable.py](gaussiantable.py.html) 包含语句`import gaussian`；现在它可以调用在模块
    [gaussian.py](gaussian.py.html) 中定义的任何函数。'
- en: '*In the client: qualify function calls to the module.* The client [gaussiantable.py](gaussiantable.py.html)
    uses the function call `gaussian.cdf(score, mu, sigma)` to call the `cdf()` function
    that is defined in the module [gaussian.py](gaussian.py.html).'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在客户端中：限定对模块的函数调用。* 客户端 [gaussiantable.py](gaussiantable.py.html) 使用函数调用`gaussian.cdf(score,
    mu, sigma)`来调用在模块 [gaussian.py](gaussian.py.html) ��定义的`cdf()`函数。'
- en: '*In the module: compose a test client.* The module [gaussian.py](gaussian.py.html)
    contains a `main()` function that takes three command-line arguments, calls the
    functions in the module, and writes the results to standard output.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在模块中：编写一个测试客户端。* 模块 [gaussian.py](gaussian.py.html) 包含一个`main()`函数，接受三个命令行参数，调用模块中的函数，并将结果写入标准输出。'
- en: '*In the module: eliminate arbitrary global code.* We cannot leave arbitrary
    global code in [gaussian.py](gaussian.py.html) because Python will execute it
    every time the module is imported. Instead, we put our test code in a `main()`
    function, as just described. Now, we can arrange for Python to call `main()` when
    we execute `gaussian.py` from the command line (and only then), using the following
    incantation:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在模块中：消除任意全局代码。* 我们不能在 [gaussian.py](gaussian.py.html) 中留下任意全局代码，因为 Python
    每次导入模块时都会执行它。相反，我们将测试代码放在一个`main()`函数中，就像刚才描述的那样。现在，我们可以安排 Python 在我们从命令行执行`gaussian.py`时调用`main()`（仅在那时），使用以下咒语：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Make the module accessible to the client.* Python needs to be able to find
    the file [gaussian.py](gaussian.py.html) when it processes the `import gaussian`
    statement in [gaussiantable.py](gaussiantable.py.html). The simplest way for you
    to proceed is to place the [gaussian.py](gaussian.py.html) and [gaussiantable.py](gaussiantable.py.html).
    The Q & A at the end of this section describes an alternative approach.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使模块对客户端可访问。* Python 需要能够在处理`import gaussian`语句时找到文件 [gaussian.py](gaussian.py.html)。你继续进行的最简单方法是将
    [gaussian.py](gaussian.py.html) 和 [gaussiantable.py](gaussiantable.py.html) 放在一起。本节末尾的问答描述了另一种方法。'
- en: In summary, the functions in the module [gaussian.py](gaussian.py.html) are
    available for use by any other program via an `import gaussian` statement. In
    contrast, the client [gaussiantable.py](gaussiantable.py.html) contains arbitrary
    global code and is not intended for use by other programs. We use the term *script*
    to refer to such code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，模块 [gaussian.py](gaussian.py.html) 中的函数可通过`import gaussian`语句供任何其他程序使用。相反，客户端
    [gaussiantable.py](gaussiantable.py.html) 包含任意全局代码，不打算供其他程序使用。我们使用术语*脚本*来指代这样的代码。
- en: This diagram summarizes the flow of control between the [gaussiantable.py](gaussiantable.py.html)
    client, the [gaussian.py](gaussian.py.html) module, and the standard `math` module.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图总结了[gaussiantable.py](gaussiantable.py.html)客户端、[gaussian.py](gaussian.py.html)模块和标准`math`模块之间的控制流。
- en: '![](../Images/bfb9c7ad81dd68ca2f4e06d4e93c827d.png) <alt of="" control="" in=""
    a="" modular="" program=""></alt>'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![](../Images/bfb9c7ad81dd68ca2f4e06d4e93c827d.png) <alt of="" control="" in=""
    a="" modular="" program=""></alt>'
- en: Modular programming.
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化编程。
- en: The potential effect of programming by defining multiple files, each an independent
    module with multiple functions, is another profound change in our programming
    style. Generally, we refer to this approach as *modular programming*. The key
    benefit of modular programming is that encourages us to break a computation up
    into smaller parts that can be individually debugged and tested. Generally, you
    should compose every program by identifying a reasonable way to divide the computation
    into separate parts of a manageable size and implement each part as if someone
    will want to use it later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义多个文件，每个文件都是一个独立的模块，具有多个函数，编程的潜在影响是我们编程风格的另一个深刻变化。通常，我们将这种方法称为*模块化编程*。模块化编程的关键好处在于鼓励我们将计算分解为可以单独调试和测试的较小部分。通常情况下，你应该通过确定一个合理的方式将计算分解为可管理大小的独立部分，并实现每个部分，就好像有人以后会想要使用它一样。
- en: '* * *'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Modular Programming Abstractions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化编程抽象
- en: Next, we describe abstractions that serve as the basis of modular programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述作为模块化编程基础的抽象。
- en: '![Modular programming abstractions](../Images/1fa629df7e528ce82a666fa32670f053.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![模块化编程抽象](../Images/1fa629df7e528ce82a666fa32670f053.png)'
- en: Implementations.
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现。
- en: 'We use the generic term *implementation* to describe code that implements a
    set of functions that are intended for reuse. A Python module is an implementation:
    we refer to the set of functions collectively with a name module and keep them
    in a file module.py. The guiding principle in module design is to provide to clients
    the functions that they need and no others.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用通用术语*实现*来描述实现一组旨在重复使用的函数的代码。Python模块就是一个实现：我们用一个名为module的名称来集体引用一组函数，并将它们保存在一个名为module.py的文件中。模块设计的指导原则是向客户提供他们需要的函数，而不是其他函数。
- en: Clients.
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端。
- en: We use the generic term *client* to refer to a program that makes use of an
    implementation. We say that a Python program (a script or a module) that calls
    a function that is defined in a file named `*module*.py` is a client of `*module*`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用通用术语*客户端*来指代使用实现的程序。我们说调用一个在名为`*module*.py`的文件中定义的函数的Python程序（脚本或模块）是`*module*`的客户端。
- en: Application programming interfaces (APIs).
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）。
- en: 'Programmers normally think in terms of a contract between the client and the
    implementation that is a clear specification of what the implementation is to
    do. You have been able to compose programs that are clients of `math` and `random`
    and other standard Python modules because of an informal contract (an English-language
    description of what they are supposed to do) along with a precise specification
    of the signatures of the functions that are available for use. Collectively, this
    information is known as an *application programming interface (API)*. The same
    mechanism is effective for user-defined modules. The API allows any client to
    use the module without having to examine the code that defines the module. When
    we compose a new module, we always provide an API. For example, this is the API
    for our [gaussian.py](gaussian.py.html) module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常以客户端和实现之间的合同来思考，这是对实现要做什么的明确规范。你已经能够组成作为`math`和`random`等标准Python模块的客户端的程序，因为有一个非正式的合同（对它们应该做什么的���语描述）以及可供使用的函数的签名的精确规范。总体而言，这些信息被称为*应用程序编程接口（API）*。对于用户定义的模块，相同的机制是有效的。API允许任何客户端使用模块，而无需检查定义模块的代码。当我们组成一个新模块时，我们总是提供一个API。例如，这是我们的[gaussian.py](gaussian.py.html)模块的API：
- en: '![Gaussian API](../Images/cc4ab3763e405e2d547a9a4445c7e4c2.png)'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![高斯API](../Images/cc4ab3763e405e2d547a9a4445c7e4c2.png)'
- en: 'How much information should an API contain? In this booksite, we stick to a
    principle that parallels our guiding design principle: provide to client programmers
    the information they need and no more.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: API应包含多少信息？在这个书站中，我们坚持一个与我们的设计原则相一致的原则：向客户程序员提供他们需要的信息，而不是更多。
- en: Private functions.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有函数。
- en: 'Sometimes we wish to define in a module a helper function that is not intended
    to be called directly by clients. We refer to such a function as a *private function*.
    By convention, Python programmers use an underscore as the first character in
    the name of a private function. For example, the following is an alternative implementation
    of the `pdf()` function from gaussian.py that calls the private function _phi():'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在一个模块中定义一个不打算由客户端直接调用的辅助函数。我们将这样的函数称为*私有函数*。按照惯例，Python程序员在私有函数名称的第一个字符中使用下划线。例如，以下是从gaussian.py中调用私有函数_phi()的pdf()函数的另一种实现：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We do not include private functions in APIs because they are not part of the
    contract between clients and implementations. Indeed, a leading underscore in
    the name of a function signals clients not to call the function explicitly. (Regrettably,
    Python has no mechanism for enforcing this convention.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在API中包含私有函数，因为它们不是客户端和实现之间的合同的一部分。实际上，函数名称中的下划线信号告诉客户不要显式调用该函数。（遗憾的是，Python没有强制执行这种约定的机制。）
- en: Libraries.
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库。
- en: A *library* is a collection of related modules. For example, Python has a standard
    library (which includes the modules `random` and `math`) and many extension libraries
    (such as `NumPy` for scientific computing and `Pygame` for graphics and sound).
    Also, for this book, we provide a booksite library (which includes the modules
    `stdio` and `stddraw`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*库*是一组相关的模块。例如，Python 有一个标准库（其中包括模块 `random` 和 `math`）和许多扩展库（如用于科学计算的 `NumPy`
    和用于图形和声音的 `Pygame`）。此外，对于这本书，我们提供了一个书站库（其中包括模块 `stdio` 和 `stddraw`）。'
- en: Documentation.
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档。
- en: The APIs of all standard, extension, and booksite modules are available through
    the built-in `help()` function in interactive Python. As illustrated below, all
    you need to do is type `python` (to enter interactive Python), then enter the
    statement `import module` (to load the module), then type `help(module)` to see
    the API for module. The APIs of the standard and extension Python modules also
    are available in another form through the [online Python documentation](https://docs.python.org/3/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准、扩展和书站模块的 API 都可以通过交互式 Python 中内置的 `help()` 函数获得。如下所示，你只需要输入 `python`（进入交互式
    Python），然后输入语句 `import module`（加载模块），然后输入 `help(module)` 来查看模块的 API。标准和扩展 Python
    模块的 API 也可以通过[在线 Python 文档](https://docs.python.org/3/)以另一种形式获得。
- en: '![Accessing Python documentation](../Images/2297c8656ca799ae917cab9e0221d28c.png)'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![访问 Python 文档](../Images/2297c8656ca799ae917cab9e0221d28c.png)'
- en: Next, we present the APIs for our `stdrandom` module (for generating random
    numbers), our `stdarray` module (for one- and two-dimensional arrays), and our
    `stdstats` module (for statistical calculations). We also describe some interesting
    clients of these modules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍我们的 `stdrandom` 模块（用于生成随机数）、`stdarray` 模块（用于一维和二维数组）和 `stdstats` 模块（用于统计计算）的
    API。我们还描述了这些模块的一些有趣的客户端。
- en: '* * *'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Random Numbers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机数
- en: The `stdrandom.py` module is for generating random numbers from various distributions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdrandom.py` 模块用于从各种分布生成随机数。'
- en: '![Stdrandom API](../Images/4c3208a64b0fcf1fc1e0213fa9e8b3b4.png)'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stdrandom API](../Images/4c3208a64b0fcf1fc1e0213fa9e8b3b4.png)'
- en: API design.
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 设计。
- en: We make certain assumptions about the objects passed to each function in `stdrandom`.
    For example, we assume that clients will pass to `stdrandom.bernoulli()` a float
    between 0.0 and 1.0, and to `stdrandom.discrete()` an array of nonnegative numbers
    (not all of which are zero). Such assumptions are part of the contract between
    the client and the implementation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对传递给 `stdrandom` 中每个函数的对象做出了一些假设���例如，我们假设客户端将一个介于 0.0 和 1.0 之间的浮点数传递给 `stdrandom.bernoulli()`，并且将一个非负数数组（其中不是所有元素都为零）传递给
    `stdrandom.discrete()`。这些假设是客户端和实现之间的合同的一部分。
- en: Unit testing.
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试。
- en: We implement `stdrandom` without reference to any particular client, but it
    is good programming practice to include a basic test client `main()` that, at
    a minimum,
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现 `stdrandom` 时没有参考任何特定的客户端，但将一个基本的测试客户端 `main()` 包含其中是良好的编程实践，至少要
- en: Exercises all the code.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试所有代码。
- en: Provides some assurance that the code is working.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一些保证代码正常工作的保证。
- en: Takes an argument from the command line to allow flexibility in testing.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行接受参数以允许灵活测试。
- en: Although it is not intended for clients, we use `main()` when debugging, testing,
    and improving the functions in a module. This practice is call *unit testing*.
    Proper unit testing can be a significant programming challenge in itself. In this
    particular case, it is appropriate to do more extensive testing in a separate
    client to check that the numbers have many of the same properties as truly random
    numbers drawn from the cited distributions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不是为客户端设计的，但在调试、测试和改进模块中的函数时，我们使用 `main()`。这种实践被称为*单元测试*。适当的单元测试本身可能是一个重要的编程挑战。在这种特殊情况下，适合在一个单独的客户端中进行更广泛的测试，以检查这些数字是否具有与从引用分布中真正随机抽取的数字相同的属性。
- en: Stress testing.
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压力测试。
- en: An extensively used module such as `stdrandom` should also be subject to stress
    testing, where we make sure that it does not fail unexpectedly, even when the
    client does not follow the contract or makes some assumption that is not explicitly
    covered. What should `stdrandom.discrete()` do if some array elements are negative?
    What if the argument is an array of length 0? What should `stdrandom.uniform()`
    do if the second argument is less than (or equal to) the first argument? Such
    cases are sometimes referred to as *corner cases*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被广泛使用的模块，比如 `stdrandom`，也应该经受压力测试，确保即使客户端不遵循合同或做出一些未明确涵盖的假设时，它也不会出现意外失败。如果一些数组元素为负数，`stdrandom.discrete()`
    应该怎么办？如果参数是长度为 0 的数组呢？如果第二个参数小于（或等于）第一个参数，`stdrandom.uniform()` 应该怎么办？这些情况有时被称为*边界情况*。
- en: '* * *'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Array-Processing API
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组处理 API
- en: In Section 1.4 we saw the utility of functions that create one-dimensional arrays
    of a specified length and two-dimensional arrays with a specified number of rows
    and columns. Thus, we introduced the `stdarray` module from the booksite library,
    and specifically its functions for creating and initializing arrays `stdarray.create1D()`
    and `stdarray.create2D()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1.4 节中，我们看到了创建指定长度的一维数组和指定行列数的二维数组的函数的实用性。因此，我们引入了书站库中的 `stdarray` 模块，特别是它的用于创建和初始化数组的函数
    `stdarray.create1D()` 和 `stdarray.create2D()`。
- en: 'Moreover, we have seen and will continue to see many examples where we wish
    to read values from standard input into an array and write values from an array
    to standard output. Accordingly, we have included in the `stdarray` module functions
    for reading arrays of integers, floats, and booleans from standard input and for
    writing them to standard output — thus complementing the `stdio` module. Here
    is the full API for `stdarray`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经看到并将继续看到许多例子，我们希望从标准输入中读取值到数组中，并将值从数组写入标准输出。因此，我们在 `stdarray` 模块中包含了从标准输入读取整数、浮点数和布尔数组并将它们写入标准输出的函数，从而补充了
    `stdio` 模块。这是 `stdarray` 的完整 API：
- en: '![Stdarray API](../Images/2cc2d66e674cfef0900458c157bd23f2.png)'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stdarray API](../Images/2cc2d66e674cfef0900458c157bd23f2.png)'
- en: We have adopted the convention that arrays appearing on standard input include
    the dimension(s) and appear in the order indicated, as illustrated in the diagram
    below. The `read*()` functions expect this format, and the `write*()` functions
    produce output in this format.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用的约定是标准输入中出现的数组包括维度，并按照指示的顺序出现，如下图所示。`read*()`函数期望这种格式，而`write*()`函数以这种格式生成输出。
- en: '![File formats for arrays](../Images/ec8517423641aba7d140a97c37549d25.png)'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![数组的文件格式](../Images/ec8517423641aba7d140a97c37549d25.png)'
- en: For arrays of booleans, our file format uses `0` and `1` values instead of `False`
    and `True`. This convention is much more economical for large arrays. More important,
    patterns in the data are much easier to spot with this file format.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布尔数组，我们的文件格式使用`0`和`1`值，而不是`False`和`True`。这种约定对于大数组来说更加经济。更重要的是，使用这种文件格式更容易发现数据中的模式。
- en: '* * *'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Iterated Function Systems
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代函数系统
- en: 'An [iterated function system](http://www.cut-the-knot.org/ctk/ifs.shtml) (IFS)
    is a general way to produce fractals like the Sierpinski triangle and the Barnsley
    Fern. As a first example, consider the following simple process: start by plotting
    a point at one of the vertices of an equilateral triangle. Then pick one of the
    three vertices at random and plot a new point halfway between the point just plotted
    and that vertex. Continue performing the same operation.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[迭代函数系统](http://www.cut-the-knot.org/ctk/ifs.shtml)（IFS）是产生分形图像如谢尔宾斯基三角形和巴恩斯利蕨的一般方法。作为第一个例子，考虑以下简单过程：从等边三角形的一个顶点开始绘制一个点。然后随机选择三个顶点中的一个，并在刚刚绘制的点和该顶点之间的中点绘制一个新点。继续执行相同的操作。'
- en: '![A random process](../Images/c388dafdf422670b2fea8e7d0efa15b1.png)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![一个随机过程](../Images/c388dafdf422670b2fea8e7d0efa15b1.png)'
- en: The program [sierpinski.py](sierpinski.py.html) simulates this process. Below
    are snapshots after 1000, 10000, and 100000 steps. You might recognize the figure
    as the [Sierpinski triangle](http://mathworld.wolfram.com/SierpinskiSieve.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[sierpinski.py](sierpinski.py.html)模拟了这个过程。以下是1000、10000和100000步后的快照。您可能会认出这个图形是[谢尔宾斯基三角形](http://mathworld.wolfram.com/SierpinskiSieve.html)。
- en: '![A random process?](../Images/90c71f02780233666de958cbdd7c93f6.png)'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![一个随机过程？](../Images/90c71f02780233666de958cbdd7c93f6.png)'
- en: 'The program [ifs.py](ifs.py.html) is a data-driven version program that simulates
    a generalization of this process. See the textbook for details. You can run it
    on any of these input files: [barnsley.txt](barnsley.txt), [binary.txt](binary.txt),
    [coral.txt](coral.txt), [culcita.txt](culcita.txt), [cyclososus.txt](cyclosorus.txt),
    [dragon.txt](dragon.txt), [fishbone.txt](fishbone.txt), [floor.txt](floor.txt),
    [koch.txt](koch.txt), [sierpinski.txt](sierpinski.txt), [spiral.txt](spiral.txt),
    [swirl.txt](swirl.txt), [tree.txt](tree.txt), or [zigzag.txt](zigzag.txt).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[ifs.py](ifs.py.html)是一个数据驱动版本的程序，模拟了这个过程的一般化。详情请参阅教科书。您可以在以下任何输入文件上运行它：[barnsley.txt](barnsley.txt),
    [binary.txt](binary.txt), [coral.txt](coral.txt), [culcita.txt](culcita.txt),
    [cyclososus.txt](cyclosorus.txt), [dragon.txt](dragon.txt), [fishbone.txt](fishbone.txt),
    [floor.txt](floor.txt), [koch.txt](koch.txt), [sierpinski.txt](sierpinski.txt),
    [spiral.txt](spiral.txt), [swirl.txt](swirl.txt), [tree.txt](tree.txt), 或 [zigzag.txt](zigzag.txt)。
- en: '![Examples of iterated function systems](../Images/8e79629e66ef4d4aa1c7ed709f6ee2e8.png)'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![迭代函数系统示例](../Images/8e79629e66ef4d4aa1c7ed709f6ee2e8.png)'
- en: 'The ability to produce such realistic diagrams so easily suggests intriguing
    scientific questions: What does computation tell us about nature? What does nature
    tell us about computation?'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 能够如此轻松地产生如此逼真的图表，引发了有趣的科学问题：计算告诉我们关于自然的什么？自然告诉我们关于计算的什么？
- en: '* * *'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Statistics
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准统计
- en: The `stdstats.py` module is for statistical calculations and basic visualizations,
    as articulated in the following API. See the textbook for details.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdstats.py`模块用于统计计算和基本可视化，如下所示的API。详情请参阅教科书。'
- en: '![The stdstats API](../Images/041a279d5fa1d406ff055b042e775d22.png)'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![stdstats API](../Images/041a279d5fa1d406ff055b042e775d22.png)'
- en: Bernoulli trials.
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伯努利试验。
- en: 'Program [bernoulli.py](bernoulli.py.html) is an example `stdstats.py` client.
    It counts the number of heads found when a fair coin is flipped *n* times and
    compares the result with the predicted Gaussian distribution function. According
    to the [Central Limit Theorem](http://mathworld.wolfram.com/CentralLimitTheorem.html),
    the resulting histogram is extremely well approximated by the Gaussian distribution
    with mean *n*/2 and variance *n*/4\. This is the output of the command `python
    bernoulli.py 20 100000`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[bernoulli.py](bernoulli.py.html)是一个`stdstats.py`客户端示例。它计算在抛掷公平硬币*n*次时找到的正面数，并将结果与预测的高斯分布函数进行比较。根据[中心极限定理](http://mathworld.wolfram.com/CentralLimitTheorem.html)，结果直方图极好���近似于均值为*n*/2和方差为*n*/4的高斯分布。这是命令`python
    bernoulli.py 20 100000`的输出：
- en: '![The stdstats API](../Images/7f47da26a86081c76846792863a71fc1.png)'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![stdstats API](../Images/7f47da26a86081c76846792863a71fc1.png)'
- en: '* * *'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Modular Programming Benefits
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化编程的好处
- en: The module implementations that we have developed illustrate modular programming.
    Instead of composing a new program that is self-contained in its own file to address
    a new problem, we break up each task into smaller, more manageable subtasks, then
    implement and independently debug code that addresses each subtask. The [ifs.py](ifs.py.html)
    and [bernoulli.py](bernoulli.py.html) programs exemplify modular programming because
    they are relatively sophisticated computations that are implemented with several
    relatively small modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '我们开发的模块实现展示了模块化编程。我们不是将一个新程序组合成一个自包含的文件来解决新问题，而是将每个任务分解为更小、更易管理的子任务，然后实现和独立调试解决每个子任务的代码。[ifs.py](ifs.py.html)和[bernoulli.py](bernoulli.py.html)程序展示了模块化编程，因为它们是相对复杂的计算，使用了几个相对较小的模块。 '
- en: '![Dependency graph for the clients and modules in this section](../Images/24f881ba56010092d746348c476cd121.png)'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![本节中客户端和模块的依赖图](../Images/24f881ba56010092d746348c476cd121.png)'
- en: 'We emphasize modular programming throughout this booksite because it has many
    important benefits, including the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个书站强调模块化编程，因为它有许多重要的好处，包括以下内容：
- en: '*Programs of a reasonable size.* No large task is so complex that it cannot
    be divided into smaller subtasks.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合理规模的程序。* 没有一个大任务是如此复杂，以至于不能分解为更小的子任务。'
- en: '*Debugging.* With modular programming and our guiding principle of keeping
    the scope of variables local to the extent possible, we severely restrict the
    number of possibilities that we have to consider when debugging. Equally important
    is the idea of a contract between client and implementation. Once we are satisfied
    that an implementation is meeting its end of the bargain, we can debug all its
    clients under that assumption.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试。* 通过模块化编程和我们的指导原则，尽可能将变量的作用域局限在本地，我们严格限制了在调试时需要考虑的可能性数量。同样重要的是客户端和实现之间的契约概念。一旦我们确信实现满足了约定的要求，我们就可以在这个假设下调试所有的客户端。'
- en: '*Code reuse.* Once we have implemented libraries such as StdStats and StdRandom,
    we do not have to worry about writing code to compute averages or standard deviations
    or to generate random numbers again — we can simply reuse the code that we have
    written.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码重用。* 一旦我们实现了诸如StdStats和StdRandom之类的库，我们就不必担心再次编写代码来计算平均值或标准差或生成随机数 —— 我们可以简单地重用我们编写的代码。'
- en: '*Maintenance.* Like a good piece of writing, a good program can always be improved.
    Supppose that while developing a new client, you find a bug in some module. With
    modular programming, fixing that bug amounts to fixing bugs in all of the module''s
    clients.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*维护。* 像一篇好的文章一样，一个好的程序总是可以改进的。假设在开发新客户端时，您发现某个模块中有一个错误。通过模块化编程，修复该错误相当于修复所有模块的客户端中的错误。'
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: '**Q.** How can I make a booksite module (such as `stdio` or `stdrandom`) available
    to my Python programs?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何使一个书站模块（如`stdio`或`stdrandom`）可供我的Python程序使用？'
- en: '**A.** If you followed the step-by-step instructions on the booksite for installing
    Python, all of our standard modules (including `stdio`, `stddraw`, `stdarray`,
    `stdrandom`, and `stdstats`) should already be available for use in your Python
    programs.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 如果您按照书站上的逐步说明安装Python，那么我们所有的标准模块（包括`stdio`、`stddraw`、`stdarray`、`stdrandom`和`stdstats`）应该已经可以在您的Python程序中使用。'
- en: '**Q.** How can I make non-standard and non-booksite modules (such as `gaussian`)
    available to my Python programs?'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何使非标准和非书站模块（如`gaussian`）可供我的Python程序使用？'
- en: '**A.** Let''s be specific. Suppose you''ve composed a program named `myprogram.py`,
    and `myprogram.py` imports `gaussian`. The issue is how you can make the `gaussian`
    module available to `myprogram.py`. In other words, the issue is how you can tell
    Python where to find the `gaussian.py` file while it is executing `myprogram.py`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 让我们具体一点。假设您编写了一个名为`myprogram.py`的程序，并且`myprogram.py`导入了`gaussian`。问题是如何使`gaussian`模块对`myprogram.py`可用。换句话说，问题是在执行`myprogram.py`时如何告诉Python在哪里找到`gaussian.py`文件。'
- en: The easiest approach is to place `gaussian.py` in the same directory as `myprogram.py`.
    However, using that approach you might end up with multiple copies of `gaussian.py`
    — one copy in each directory that contains a `gaussian.py` client. That approach
    would make the `gaussian.py` code difficult to maintain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是将`gaussian.py`放在与`myprogram.py`相同的目录中。然而，使用这种方法，您可能会在每个包含`gaussian.py`客户端的目录中得到多个副本的`gaussian.py`
    —— 每个目录中都有一个副本。这种方法会使`gaussian.py`代码难以维护。
- en: An alternative approach is to place a single copy of `gaussian.py` in some directory,
    and then *set the `PYTHONPATH` environment variable* to contain that directory.
    Subsequently, Python looks for files in that directory whenever it encounters
    an `import` statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将`gaussian.py`的一个副本放在某个目录中，然后*设置`PYTHONPATH`环境变量*以包含该目录。随后，每当Python遇到`import`语句时，它会在该目录中查找文件。
- en: 'The mechanism for setting the `PYTHONPATH` environment variable depends upon
    the operating system that you''re using. Suppose your computer is running Mac
    OS X or Linux. Further suppose you place `gaussian.py` in the directory `/Users/yourusername/common`.
    Then these commands are appropriate:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`PYTHONPATH`环境变量的机制取决于您使用的操作系统。假设您的计算机正在运行Mac OS X或Linux。进一步假设您将`gaussian.py`放在目录`/Users/yourusername/common`中。然后这些命令是适当的：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `export` command sets the value of the `PYTHONPATH` variable to `/Users/yourusername/common`.
    So during the execution of the subsequent `python myprogram.py` command, Python
    looks in the `/Users/yourusername/common` directory when handling `import` statements,
    and so finds the `gaussian.py` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`命令将`PYTHONPATH`变量的值设置为`/Users/yourusername/common`。因此，在执行后续的`python
    myprogram.py`命令时，Python在处理`import`语句时会查找`/Users/yourusername/common`目录，从而找到`gaussian.py`文件。'
- en: 'Generalizing, on Mac OS X and Linux systems the value of the `PYTHONPATH` variable
    is a sequence of directories separated by colons. So after you issue this command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在Mac OS X和Linux系统上，`PYTHONPATH`变量的值是由冒号分隔的一系列目录。因此，在您发出这个命令之后：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Python looks in `*directory1*`, then `*directory2*`, and then `*directory3*`
    to find `.py` files when handling `import` statements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`import`语句时，Python会先查找`*directory1*`，然后查找`*directory2*`，最后查找`*directory3*`中的`.py`文件。
- en: 'On the other hand, suppose your computer is running Microsoft Windows. Further
    suppose you place `gaussian.py` in the directory `c:\Users\yourusername\common`.
    Then these commands are appropriate:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，假设您的计算机正在运行Microsoft Windows。进一步假设您将`gaussian.py`放在目录`c:\Users\yourusername\common`中。然后这些命令是适当的：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `set` command sets the value of the `PYTHONPATH` variable to `c:\Users\yourusername\common`.
    So during the execution of the subsequent `python myprogram.py` command, Python
    looks in the `c:\Users\yourusername\common` directory when handling `import` statements,
    and so finds the `gaussian.py` file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`命令将`PYTHONPATH`变量的值设置为`c:\Users\yourusername\common`。因此，在执行后续的`python
    myprogram.py`命令时，Python在处理`import`语句时会查找`c:\Users\yourusername\common`目录，从而找到`gaussian.py`文件。'
- en: 'Generalizing, on Microsoft Windows systems the value of the `PYTHONPATH` variable
    is a sequence of directories separated by semicolons. So after you issue this
    command::'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在 Microsoft Windows 系统上，`PYTHONPATH` 变量的值是由分号分隔的一系列目录。因此，在发出这个命令后：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Python looks in `*directory1*`, then `*directory2*`, and then `*directory3*`
    to find `.py` files when handling `import` statements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `import` 语句时，Python 会先查找 `*directory1*`，然后是 `*directory2*`，最后是 `*directory3*`
    中的 `.py` 文件。
- en: '**Q.** I tried to import the `gaussian` module, but got the following error
    message. What''s wrong?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我尝试导入 `gaussian` 模块，但收到以下错误消息。出了什么问题？'
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**A.** You did not make `gaussian` available to Python, as described above.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 你没有像上面描述的那��让 `gaussian` 对 Python 可用。'
- en: '**Q.** I tried to call `gaussian.pdf()` but I got the following error. What''s
    wrong?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我尝试调用 `gaussian.pdf()`，但收到以下错误。出了什么问题？'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**A.** You left out the `import gaussian` statement.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 你忘记了 `import gaussian` 语句。'
- en: '**Q.** Is there a keyword that identifies a `.py` file as a module (and not
    a script)?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 有一个关键字可以识别 `.py` 文件是一个模块（而不是脚本）吗？'
- en: '**A.** No. Technically, the key point is to avoid arbitrary global code using
    the patterns described earlier in this section. If you avoid arbitrary global
    code in a `.py` file, so that the `.py` file can be imported into some other `.py`
    file, then we call it a module. Pragmatically, however, there is a bit of a conceptual
    leap in this viewpoint, because it is one thing to sit down to create a `.py`
    file that you will run (and perhaps run again sometime later with different data),
    but quite another thing to create a `.py` file that you will rely on much later
    in the future, and still another thing to create a `.py` file for someone else
    to use in the future.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不。从技术上讲，关键是避免使用前面描述的模式中的任意全局代码。如果你避免在一个 `.py` 文件中使用任意全局代码，以便该 `.py`
    文件可以被导入到其他 `.py` 文件中，那么我们称之为一个模块。然而，从实用的角度来看，这种观点有一定的概念性飞跃，因为创建一个 `.py` 文件来运行（也许以后会用不同的数据再次运行），和创建一个
    `.py` 文件以后在未来依赖它，以及为将来的其他人创建一个 `.py` 文件是完全不同的事情。'
- en: '**Q.** How do I develop a new version of a module that I have been using for
    a while?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何开发一个我已经使用了一段时间的模块的新版本？'
- en: '**A.** With care. Any change to the API might break any client program, so
    it is best to work in a separate directory. Of course, with this approach you
    are working with a copy of the code. If you are changing a module that has a lot
    of clients, you can appreciate the problems faced by companies putting out new
    versions of their software. If you just want to add a few functions to a module,
    go ahead: that is usually not too dangerous.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 谨慎处理。对 API 的任何更改都可能破坏任何客户端程序，所以最好在一个单独的目录中工作。当然，使用这种方法时，你是在使用代码的副本。如果你要对一个有很多客户端的模块进行更改，你就能体会到公司发布软件新版本时面临的问题。如果你只想向一个模块添加一些函数，那就继续：通常不太危险。'
- en: '**Q.** How do I know that an implementation behaves properly? Why not automatically
    check that it satisfies the API?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我怎么知道一个实现是否行为正常？为什么不自动检查它是否符合 API？'
- en: '**A.** We use informal specifications because composing a detailed specification
    is not much different from composing a program. Moreover, a fundamental tenet
    of theoretical computer science says that doing so does not even solve the basic
    problem because there is no way in general to check that two different programs
    perform the same computation.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 我们使用非正式规范，因为撰写详细规范与撰写程序没有太大区别。此外，理论计算机科学的一个基本原则是，这样做甚至不能解决基本问题，因为通常没有办法检查两个不同的程序是否执行相同的计算。'
- en: '**Q.** I notice that files whose names are suffixed with `.pyc` are appearing
    when I run the programs from this section. For example, when I issue the command
    `python gaussiantable.py`, I notice that Python automatically creates a file named
    `gaussian.pyc`. What are these `.pyc` files?'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我注意到当我运行本节中的程序时，出现了文件名后缀为 `.pyc` 的文件。例如，当我发出命令 `python gaussiantable.py`
    时，我注意到 Python 自动创建了一个名为 `gaussian.pyc` 的文件。这些 `.pyc` 文件是什么？'
- en: '**A.** As noted in Section 1.1, whenever Python executes a program, it translates
    the program into an internal (not human-readable) form that is more amenable to
    execution. That internal form is called *bytecode*. When you import a module for
    the first time, Python compiles the code and stores the resulting bytecode in
    a `.pyc` file. This makes the module load faster because Python does not need
    to recompile it each time (but it does not make running the program any faster).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 如第 1.1 节所述，每当 Python 执行一个程序时，它会将程序转换为一种更适合执行的内部（不可读）形式，称为*字节码*。当你第一次导入一个模块时，Python
    会编译代码并将生成的字节码存储在一个 `.pyc` 文件中。这使得模块加载更快，因为 Python 不需要每次重新编译它（但这并不会使程序运行更快）。'
- en: When a program consists of only one file, Python discards the file's bytecode
    after execution is complete. However, when a program consists of multiple files
    — that is, when a program consists of a client file and modules — Python does
    not discard the bytecode that it generates for the modules. Instead it stores
    that bytecode in `.pyc` files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序只包含一个文件时，Python 在执行完成后会丢弃文件的字节码。然而，当一个程序由多个文件组成，也就是说，当一个程序由一个客户端文件和模块组成时，Python
    不会丢弃为模块生成的字节码。相反，它会将该字节码存储在 `.pyc` 文件中。
- en: For example, recall that [gaussiantable.py](gaussiantable.py.html) depends upon
    [gaussian.py](gaussian.py.html). So when you issue the command `python gaussiantable.py
    1019 209`, Python translates [gaussiantable.py](gaussiantable.py.html) into bytecode.
    It also translates [gaussian.py](gaussian.py.html) into bytecode. Eventually it
    discards the former; but it saves the latter in the file `gaussian.pyc`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回想一下 [gaussiantable.py](gaussiantable.py.html) 依赖于 [gaussian.py](gaussian.py.html)。所以当你发出命令
    `python gaussiantable.py 1019 209` 时，Python 将 [gaussiantable.py](gaussiantable.py.html)
    转换为字节码。它也将 [gaussian.py](gaussian.py.html) 转换为字节码。最终它会丢弃前者；但它会保存后者在名为 `gaussian.pyc`
    的文件中。
- en: 'Python''s rationale is this: Since [gaussian.py](gaussian.py.html) was used
    as a module in this program, it''s likely that it will be used in the future as
    a module in other programs. So Python saves the bytecode version of [gaussian.py](gaussian.py.html)
    in `gaussian.pyc` to avoid the translation overhead if the module indeed is reused.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python的理念是：由于[gaussian.py](gaussian.py.html)在这个程序中被用作模块，很可能将来会在其他程序中作为模块使用。因此，Python将[gaussian.py](gaussian.py.html)的字节码版本保存在`gaussian.pyc`中，以避免在模块确实被重用时的翻译开销。
- en: It's fine to delete `.pyc` files at any time; Python will regenerate them when
    appropriate. It also is fine *not* to delete `.pyc` files because if you edit
    a `.py` file after Python has generated the corresponding `.pyc` file, Python
    will regenerate the `.pyc` file automatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随时删除`.pyc`文件都是可以的；Python会在适当时重新生成它们。如果你编辑了一个`.py`文件，Python生成了相应的`.pyc`文件，那么不删除`.pyc`文件也是可以的，因为Python会自动重新生成`.pyc`文件。
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Compose a module that implements the hyperbolic trigonometric functions based
    on the definitions sinh(*x*) = (*e*^(*x*) - *e*^(-*x*))/2 and cosh(*x*) = (*e*^(*x*)
    + *e*^(-*x*))/2, with tanh(*x*), coth(*x*), sech(*x*), and csch(*x*) defined in
    a manner analogous to standard trigonometric functions.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个基于定义sinh(*x*) = (*e*^(*x*) - *e*^(-*x*))/2和cosh(*x*) = (*e*^(*x*) + *e*^(-*x*))/2的双曲三角函数的模块，其中tanh(*x*),
    coth(*x*), sech(*x*), 和csch(*x*)的定义方式类似于标准三角函数。
- en: 'Compose a test client for both `stdstats` and `stdrandom` that checks that
    all of the methods in both modules operate as expected. Take a command-line argument
    `n`, generate `n` random numbers using each of the functions in `stdrandom`, and
    write their statistics. *Extra credit*: Defend the results that you get by comparing
    them to those that are to be expected from mathematical analysis.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`stdstats`和`stdrandom`编写一个测试客户端，检查这两个模块中的所有方法是否按预期运行。使用命令行参数`n`，使用每个`stdrandom`函数生成`n`个随机数，并写出它们的统计数据。*额外加分*：通过与数学分析预期的结果进行比较来证明你得到的结果。
- en: Develop a client that does stress testing for `stdrandom`. Pay particular attention
    to `discrete()`. For example, are the probabilities nonnegative? Are they all
    zero?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个为`stdrandom`进行压力测试的客户端。特别关注`discrete()`。例如，概率是否为非负？是否全部为零？
- en: Compose a function that takes floats `ymin` and `ymax` (with `ymin` strictly
    less than `ymax`) and a `float` array `a[]` as arguments and linearly scales the
    elements in `a[]` so that they are all between `ymin` and `ymax`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受浮点数`ymin`和`ymax`（其中`ymin`严格小于`ymax`）以及一个`float`数组`a[]`作为参数，并线性缩放`a[]`中的元素，使它们都在`ymin`和`ymax`之间。
- en: Compose a [gaussian.py](gaussian.py.html) and `stdstats.py` client that explores
    the effects of changing the mean and standard deviation on the Gaussian distribution
    curve. Create one plot with curves having a fixed mean and various standard deviations
    and another with curves having a fixed standard deviation and various means.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个[gaussian.py](gaussian.py.html)和`stdstats.py`客户端，探索改变均值和标准差对高斯分布曲线的影响。创建一个曲线固定均值和各种标准差的图，另一个曲线固定标准差和各种均值的图。
- en: Add to `stdrandom.py` a function `maxwellBoltzmann()` that returns a random
    value drawn from a *Maxwell-Boltzmann distribution* with parameter σ. To produce
    such a value, return the square root of the sum of the squares of three Gaussian
    random variables with mean 0 and standard deviation σ. (The speeds of molecules
    in an ideal gas have a Maxwell-Boltzmann distribution.)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stdrandom.py`中添加一个函数`maxwellBoltzmann()`，返回从参数σ的*Maxwell-Boltzmann分布*中抽取的随机值。为了产生这样的值，返回三个均值为0，标准差为σ的高斯随机变量的平方和的平方根。（理想气体中分子的速度具有Maxwell-Boltzmann分布。）
- en: Modify [bernoulli.py](bernoulli.py.html) to animate the bar graph, replotting
    it after each experiment, so that you can watch it converge to the normal distribution.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[bernoulli.py](bernoulli.py.html)，为条形图添加动画效果，在每次实验后重新绘制，以便观察其收敛到正态分布。
- en: Modify [bernoulli.py](bernoulli.py.html) to add a command-line argument *p*
    that specifies the probability that a biased coin comes up heads. Run experiments
    to get a feeling for the distribution corresponding to a biased coin. Be sure
    to try values of *p* that are close to 0 and close to 1.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[bernoulli.py](bernoulli.py.html)，添加一个命令行参数*p*，指定有偏硬币出现正面的概率。运行实验，以了解与有偏硬币对应的分布。一定要尝试接近0和接��1的*p*值。
- en: 'Compose a module `matrix.py` that implements the following API for vectors
    and matrices (see Section 1.4):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个模块`matrix.py`，为向量和矩阵实现以下API（参见第1.4节）：
- en: '![Matrix API](../Images/db6060f1a8a89b0359bdd07f42523bdf.png)'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![矩阵API](../Images/db6060f1a8a89b0359bdd07f42523bdf.png)'
- en: '*Solution*: See [matrix.py](matrix.py.html).'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[matrix.py](matrix.py.html)。'
- en: 'Compose a client of `matrix.py` (from the previous exercise) which uses the
    following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`matrix.py`的客户端（来自上一个练习），使用以下代码：
- en: '[PRE8]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That code performs the same calculation as [markov.py](../16pagerank/markov.py.html)
    (from section 1.6).
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该代码执行与[markov.py](../16pagerank/markov.py.html)（来自第1.6节）相同的计算。
- en: In practice, mathematicians and scientists use mature libraries such as `NumPy`
    (or special-purpose matrix-processing languages such as `Matlab`) for such tasks
    because they are likely to be more efficient, accurate, and robust than anything
    you could compose yourself. The [NumPy Appendix](../appendix_numpy/) describes
    how to use `NumPy`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实践中，数学家和科学家使用成熟的库，如`NumPy`（或专用矩阵处理语言如`Matlab`）来执行这些任务，因为它们可能比你自己编写的任何东西更有效、准确和稳健。[NumPy附录](../appendix_numpy/)描述了如何使用`NumPy`。
- en: Compose a client of `matrix.py` (from the previous two exercises) named `markovsquaring.py`
    that implements the version of [markov.py](../16pagerank/markov.py.html) (from
    Section 1.6) but is based on squaring the matrix, instead of iterating the vector-matrix
    multiplication.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`matrix.py`的客户端（来自前两个练习），命名为`markovsquaring.py`，实现了基于矩阵平方而不是迭代向量-矩阵乘法的版本的[markov.py](../16pagerank/markov.py.html)（来自第1.6节）。
- en: Redesign [randomsurfer.py](../16pagerank/randomsurfer.py.html) (from Section
    1.6) using the `stdarray` and `stdrandom` modules.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新设计[随机冲浪者.py](../16pagerank/randomsurfer.py.html)（来自第1.6节）使用`stdarray`和`stdrandom`模块。
- en: '*Partial solution:*'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案：*'
- en: '[PRE9]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a function `exp()` to `stdrandom.py` that takes an argument λ and returns
    a random number from the *exponential distribution* with rate λ. *Hint*: If *x*
    is a random number uniformly distributed between 0 and 1, then -ln *x* / λ is
    a random number from the exponential distribution with rate λ.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`stdrandom.py`添加一个函数`exp()`，它接受一个参数λ，并返回一个从速率为λ的*指数分布*中随机数。*提示*：如果*x*是均匀分布在0和1之间的随机数，则-ln
    *x* / λ是从速率为λ的指数分布中的随机数。
- en: '* * *'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Sicherman dice.** Suppose that you have two six-sided dice, one with faces
    labeled 1, 3, 4, 5, 6, and 8 and the other with faces labeled 1, 2, 2, 3, 3, and
    4\. Compare the probabilities of occurrence of each of the values of the sum of
    the dice with those for a standard pair of dice. Use `stdrandom` and `stdstats`.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Sicherman骰子。** 假设你有两个六面骰子，一个面标有1、3、4、5、6和8，另一个面标有1、2、2、3、3和4。比较这两个骰子的和的每个值发生的概率与标准骰子的概率。使用`stdrandom`和`stdstats`。'
- en: '*Solution*: Dice with these properties are called [Sicherman dice](https://en.wikipedia.org/wiki/Sicherman_dice):
    they produce sums with the same frequency as regular dice (2 with probability
    1/36, 3 with probability 2/36, and so on).'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：具有这些属性的骰子称为[Sicherman骰子](https://en.wikipedia.org/wiki/Sicherman_dice)：它们产生与常规骰子相同频率的和（2的概率为1/36，3的概率为2/36，依此类推）。'
- en: '**Craps.** Here are the rules for a *pass bet* in the game of *craps*: Roll
    two 6-sided dice, and let *x* be their sum.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Craps.** 这里是*craps*游戏中*pass bet*的规则：掷两个6面骰子，让*x*为它们的和。'
- en: If *x* is 7 or 11, you win.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*为7或11，则获胜。
- en: If *x* is 2, 3, or 12, you lose.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*为2、3或12，则失败。
- en: Otherwise, repeatedly roll two the dice until their sum is either *x* or 7.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，重复掷两个骰子，直到它们的和为*x*或7。
- en: If their sum is *x*, you win.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们的和为*x*，则获胜。
- en: If their sum is 7, you lose.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们的和为7，则失败。
- en: Compose a modular program to estimate the probability of winning a pass bet.
    Modify your program to handle loaded dice, where the probability of a die landing
    on 1 is taken from the command line, the probability of landing on 6 is 1/6 minus
    that probability, and 2-5 are assumed equally likely. *Hint:* Use `stdrandom.discrete()`.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个模块化程序来估计获胜*pass bet*的概率。修改你的程序以处理有偏骰子，其中骰子落在1上的概率来自命令行，落在6上的概率为1/6减去该概率，2-5被假定为等概率。*提示*：使用`stdrandom.discrete()`。
- en: '**Dynamic histogram.** Suppose that the standard input stream is a sequence
    of floats. Compose a program that takes an integer `n` and two floats `l` and
    `r` from the command line and uses `stdstats` to plot a histogram of the count
    of the numbers in the standard input stream that fall in each of the `n` intervals
    defined by dividing `(l, r)` into `n` equal-sized intervals. Use your program
    to add code to your solution to Exercise 2 (from earlier in this section) to plot
    a histogram of the distribution of the numbers produced by each function, taking
    `n` from the command line.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态直方图。** 假设标准输入流是一系列浮点数。编写一个程序，从命令行获取一个整数`n`和两个浮点数`l`和`r`，并使用`stdstats`绘制一个直方图，显示标准输入流中落入将`(l,
    r)`分成`n`个等大小区间的每个区间中数字的计数。使用你的程序为你之前在本节中的练习2的解决方案添加代码，以绘制每个函数产生的数字分布的直方图，从命令行获取`n`。'
- en: '**Tukey plot.** A *Tukey plot* is a data visualization that generalizes a histogram,
    and is appropriate for use when each integer in a given range is associated with
    a set of `y` values. For each integer *i* in the range, we compute the mean, standard
    deviation, 10th percentile, and 90th percentile of all the associated *y*-values;
    draw a vertical line with *x*-coordinate *i* running from the 10th percentile
    *y* value to the 90th percentile *y* value; and then draw a thin rectangle centered
    on the line that runs from one standard deviation below the mean to one standard
    deviation above the mean. Suppose that the standard input stream is a sequence
    of pairs of numbers where the first number in each pair is an int and the second
    a double value. Compose a `stdstats` and `stddraw` client that takes an integer
    `n` from the command line and, assuming that all the integers on the standard
    input stream are between 0 and `n-1`, uses `stddraw` to make a Tukey plot of the
    data.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Tukey图。** *Tukey图*是一种概括直方图的数据可视化，适用于当给定范围内的每个整数与一组`y`值相关联时。对于范围内的每个整数*i*，我们计算所有相关*y*值的均值、标准差、第10百分位数和第90百分位数；画一条从第10百分位数*y*值到第90百分位数*y*值的垂直线；然后画一个细长矩形，以均值下方一个标准差到均值上方一个标准差为中心。假设标准输入流是一��列数对，其中每对中的第一个数是一个整数，第二个数是一个双精度值。编写一个`stdstats`和`stddraw`客户端，从命令行获取一个整数`n`，假设标准输入流中的所有整数都在0到`n-1`之间，使用`stddraw`绘制数据的Tukey图。'
- en: '**IFS.** Experiment with various inputs to [ifs.py](ifs.py.html) to create
    patterns of your own design like the Sierpinksi triangle, Barnsley fern, or other
    examples. You might begin by experimenting with minor modifications to the given
    inputs.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IFS.** 尝试使用各种输入来实验[ifs.py](ifs.py.html)以创建自己设计的图案，如谢尔宾斯基三角形、巴恩斯利蕨或其他示例。你可以从对给定输入进行微小修改开始实验。'
- en: '**IFS matrix implementation.** Compose a version of [ifs.py](ifs.py.html) that
    uses `matrix.multiply()` (as developed in a previous exercise in this section)
    instead of the equations that compute the new values of `x` and `y`.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IFS矩阵实现。** 编写一个使用`matrix.multiply()`（如本节中的一个先前练习中开发的）而不是计算`x`和`y`的新值的方程的[ifs.py](ifs.py.html)版本。'
- en: '**Stress test.** Compose a client that does stress testing for `stdstats.py`.
    Work with a classmate, with one person composing code and the other testing it.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**压力测试。** 编写一个客户端对`stdstats.py`进行压力测试。与同学合作，一人编写代码，另一人测试。'
- en: '**Gamblers ruin.** Compose a `stdrandom.py` client to study the gamblers ruin
    problem (see [gambler.py](../13flow/gambler.py.html) from Section 1.3, and the
    exercises at the end of that section). *Note*: Defining a function for the experiment
    is more difficult than for [bernoulli.py](bernoulli.py.html) because a function
    cannot return two values. But remember that a function can return a single array
    that contains two values.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**赌徒困境。** 编写一个`stdrandom.py`客户端来研究赌徒困境问题（参见第1.3节中的[gambler.py](../13flow/gambler.py.html)和该节末尾的练习）。*注意*：为实验定义一个函数比[bernoulli.py](bernoulli.py.html)更困难，因为函数不能返回两个值。但请记住，函数可以返回一个包含两个值的单个数组。'
- en: '**Module for properties of integers.** Compose a module based on the functions
    that we have considered in this book for computing properties of integers. Include
    functions for determining whether a given integer is prime; whether two integers
    are relatively prime; computing all the factors of a given integer; the greatest
    common divisor and least common multiple of two integers; Eulers totient function
    (see the *Euler''s Totient Function* exercise in Section 2.1); and any other functions
    that you think might be useful. Create an API, a client that performs stress testing,
    and clients that solve several of the exercises earlier in this book.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整数属性模块。** 基于本书中考虑的用于计算整数属性的函数，编写一个模块。包括确定给定整数是否为质数的函数；两个整数是否互质；计算给定整数的所有因子；两个整数的最大公约数和最小公倍数；欧拉函数（参见第2.1节中的*欧拉函数*练习）；以及你认为可能有用的其他函数。创建一个API，一个执行压力测试的客户端，以及解决本书前面几个练习的客户端。'
- en: '**Voting machines.** Compose a `stdrandom.py` client (with appropriate functions
    of its own) to study the following problem: Suppose that in a population of 100
    million voters, 51% vote for candidate A and 49% vote for candidate B. However,
    the voting machines are prone to make mistakes, and 5% of the time they produce
    the wrong answer. Assuming the errors are made independently and at random, is
    a 5% error rate enough to invalidate the results of a close election? What error
    rate can be tolerated?'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**投票机。** 编写一个`stdrandom.py`客户端（具有适当的函数），研究以下问题：假设在一个拥有1亿选民的人口中，51%的选民投票给候选人A，49%的选民投票给候选人B。然而，投票机容易出错，有5%的概率给出错误答案。假设错误是独立且随机发生的，5%的错误率足以使紧密选举的结果无效吗？可以容忍多少错误率？'
- en: '**Poker analysis.** Compose a `stdrandom.py` and `stdstats.py` client (with
    appropriate functions of its own) to estimate the probabilities of getting one
    pair, two pair, three of a kind, a full house, and a flush in a five-card poker
    hand via simulation. Divide your program into appropriate functions and defend
    your design decisions. *Extra credit*: Add straight and straight flush to the
    list of possibilities.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扑克分析。** 编写一个`stdrandom.py`和`stdstats.py`客户端（具有适当的函数），通过模拟估计在五张扑克牌手中获得一对、两对、三条、满堂和同花的概率。将程序分解为适当的函数，并捍卫你的设计决策。*额外加分*：将顺子和同花顺添加到可能性列表中。'
- en: '**Music module.** Develop a module based on the functions in [playthattunedeluxe.py](../21function/playthattunedeluxe.py.html)
    (from Section 2.1) that you can use to compose client programs to create and manipulate
    songs.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**音乐模块。** 开发一个基于[playthattunedeluxe.py](../21function/playthattunedeluxe.py.html)中的函数的模块（来自第2.1节），你可以用来编写客户端程序来创建和操作歌曲。'
- en: '**Animated plots.** Compose a program that takes a command-line argument `m`
    and produces a bar graph of the `m` most recent floats on standard input. Use
    the same animation technique that we used for bouncingball.py (from Section 1.5):
    erase, redraw, show, and wait briefly. Each time your program reads a new number,
    it should redraw the whole graph. Since most of the picture does not change as
    it is redrawn slightly to the left, your program will produce the effect of a
    fixed-size window dynamically sliding over the input values. Use your program
    to plot a huge time-variant data file, such as stock prices.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画绘图。** 编写一个程序，接受一个命令行参数`m`，并在标准输入上生成最近`m`个浮点数的条形图。使用我们在第1.5节中用于`bouncingball.py`的相同动画技术：擦除、重绘、显示，并稍作等待。每次程序读取一个新数字时，应重新绘制整个图形。由于大部分图像在稍微向左重新绘制时不会改变，因此你的程序将产生一个固定大小窗口动态滑过输入值的效果。使用你的程序绘制一个庞大的时变数据文件，如股票价格。'
- en: '**Array plot module.** Develop your own plot functions that improve upon those
    in `stdstats.py`. Be creative! Try to make a plotting module that you think you
    will use for some application in the future.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数组绘图模块。** 开发自己的绘图函数，改进`stdstats.py`中的函数。要有创意！尝试创建一个你认为将来会用到的绘图模块。'
