- en: 2.4 Priority Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 优先队列
- en: 原文：[https://algs4.cs.princeton.edu/24pq](https://algs4.cs.princeton.edu/24pq)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/24pq](https://algs4.cs.princeton.edu/24pq)
- en: 'Many applications require that we process items having keys in order, but not
    necessarily in full sorted order and not necessarily all at once. Often, we collect
    a set of items, then process the one with the largest key, then perhaps collect
    more items, then process the one with the current largest key, and so forth. An
    appropriate data type in such an environment supports two operations: *remove
    the maximum* and *insert*. Such a data type is called a *priority queue*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序要求我们按顺序处理具有键的项目，但不一定是完全排序的顺序，也不一定一次处理所有项目。通常，我们收集一组项目，然后处理具有最大键的项目，然后可能收集更多项目，然后处理具有当前最大键的项目，依此类推。在这种环境中，一个适当的数据类型支持两个操作：*删除最大*和*插入*。这样的数据类型称为*优先队列*。
- en: API.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API。
- en: Priority queues are characterized by the *remove the maximum* and *insert* operations.
    By convention, we will compare keys only with a `less()` method, as we have been
    doing for sorting. Thus, if records can have duplicate keys, *maximum* means *any*
    record with the largest key value. To complete the API, we also need to add constructors
    and a *test if empty* operation. For flexibility, we use a generic implementation
    with a generic type `Key` that implements `Comparable`.![Priority queue API](../Images/de7c1e2e54f448a22fd1c5a30011b0e1.png)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列的特点是*删除最大*和*插入*操作。按照惯例，我们将仅使用`less()`方法比较键，就像我们对排序所做的那样。因此，如果记录可以具有重复的键，*最大*意味着具有最大键值的*任何*记录。为了完善API，我们还需要添加构造函数和*测试是否为空*操作。为了灵活性，我们使用一个实现了`Comparable`的通用类型`Key`的通用实现。![优先队列API](../Images/de7c1e2e54f448a22fd1c5a30011b0e1.png)
- en: Program [TopM.java](TopM.java.html) is a priority queue client that takes a
    command-line argument *M*, reads transactions from standard input, and prints
    out the *M* largest transactions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[TopM.java](TopM.java.html)是一个优先队列客户端，它接受一个命令行参数*M*，从标准输入读取交易，并打印出*M*个最大的交易。
- en: Elementary implementations.
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本实现。
- en: The basic data structures that we discussed in [Section 1.3](../13stacks) provide
    us with four immediate starting points for implementing priority queues.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1.3节](../13stacks)中讨论的基本数据结构为我们提供了四个立即的实现优先队列的起点。
- en: '*Array representation (unordered).* Perhaps the simplest priority queue implementation
    is based on our code for pushdown stacks. The code for *insert* in the priority
    queue is the same as for *push* in the stack. To implement *remove the maximum*,
    we can add code like the inner loop of selection sort to exchange the maximum
    item with the item at the end and then delete that one, as we did with `pop()`
    for stacks. Program [UnorderedArrayMaxPQ.java](UnorderedArrayMaxPQ.java.html)
    implements a priority queue using this approach.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组表示（无序）。* 也许最简单的优先队列实现是基于我们的推入栈代码。优先队列中*插入*的代码与栈中的*推入*相同。要实现*删除最大*，我们可以添加类似于选择排序的内部循环的代码，将最大项与末尾的项交换，然后删除那个，就像我们对栈的`pop()`所做的那样。程序[UnorderedArrayMaxPQ.java](UnorderedArrayMaxPQ.java.html)使用这种方法实现了一个优先队列。'
- en: '*Array representation (ordered).* Another approach is to add code for *insert*
    to move larger entries one position to the right, thus keeping the entries in
    the array in order (as in insertion sort). Thus the largest item is always at
    the end, and the code for *remove the maximum* in the priority queue is the same
    as for *pop* in the stack. Program [OrderedArrayMaxPQ.java](OrderedArrayMaxPQ.java.html)
    implements a priority queue using this approach.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组表示（有序）。* 另一种方法是添加*插入*的代码，将较大的条目向右移动一个位置，从而保持数组中的条目有序（就像插入排序一样）。因此，最大的项始终在末尾，优先队列中*删除最大*的代码与栈中的*弹出*相同。程序[OrderedArrayMaxPQ.java](OrderedArrayMaxPQ.java.html)使用这种方法实现了一个优先队列。'
- en: '*Linked-list representations (unordered and reverse-ordered).* Similarly, we
    can start with our linked-list code for pushdown stacks, either modifying the
    code for `pop()` to find and return the maximum or the code for `push()` to keep
    items in reverse order and the code for `pop()` to unlink and return the first
    (maximum) item on the list.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链表表示（无序和反向有序）。* 类似地，我们可以从我们的推入栈的链表代码开始，修改`pop()`的代码以找到并返回最大值，或者修改`push()`的代码以保持项目以相反顺序，并修改`pop()`的代码以取消链接并返回列表中的第一个（最大）项目。'
- en: '![Priority queue array implementations](../Images/6aa42aefa056037b199ee4668e7675b8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![优先队列数组实现](../Images/6aa42aefa056037b199ee4668e7675b8.png)'
- en: All of the elementary implementations just discussed have the property that
    *either* the *insert* or the *remove the maximum* operation takes linear time
    in the worst case. Finding an implementation where *both* operations are guaranteed
    to be fast is a more interesting task, and it is the main subject of this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有刚讨论的基本实现都具有*插入*或*删除最大*操作在最坏情况下需要线性时间的特性。找到一个保证两个操作都快速的实现是一个更有趣的任务，也是本节的主要内容。
- en: Heap definitions.
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆定义。
- en: The *binary heap* is a data structure that can efficiently support the basic
    priority-queue operations. In a binary heap, the items are stored in an array
    such that each key is guaranteed to be larger than (or equal to) the keys at two
    other specific positions. In turn, each of those keys must be larger than two
    more keys, and so forth. This ordering is easy to see if we view the keys as being
    in a binary tree structure with edges from each key to the two keys known to be
    smaller.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉堆*是一种数据结构，可以高效支持基本的优先队列操作。在二叉堆中，项目存储在一个数组中，使得每个键都保证大于（或等于）另外两个特定位置的键。反过来，这两个键中的每一个必须大于另外两个键，依此类推。如果我们将键视为在具有从每个键到已知较小键的两个键的边的二叉树结构中，这种排序是很容易看到的。'
- en: '**Definition.** A binary tree is *heap-ordered* if the key in each node is
    larger than (or equal to) the keys in that nodes two children (if any).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义。** 如果每个节点中的键大于（或等于）该节点的两个子节点（如果有的话）中的键，则二叉树是*堆有序*的。'
- en: '**Proposition.** The largest key in a heap-ordered binary tree is found at
    the root.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** 堆有序二叉树中最大的键位于根节点。'
- en: We can impose the heap-ordering restriction on any binary tree. It is particularly
    convenient, however, to use a *complete* binary tree like the one below.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对任何二叉树施加堆排序限制。然而，使用像下面这样的*完全*二叉树特别方便。
- en: '![Heap representations](../Images/2d9e7e07ec338ef11d5e2892f24fb62d.png)We represent
    complete binary trees sequentially within an array by putting the nodes with *level
    order*, with the root at position 1, its children at positions 2 and 3, their
    children in positions 4, 5, 6 and 7, and so on.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![堆表示](../Images/2d9e7e07ec338ef11d5e2892f24fb62d.png)我们通过*层级顺序*在数组中顺序表示完全二叉树，根位于位置
    1，其子节点位于位置 2 和 3，它们的子节点位于位置 4、5、6 和 7，依此类推。'
- en: '**Definition.** A *binary heap* is a set of nodes with keys arranged in a complete
    heap-ordered binary tree, represented in level order in an array (not using the
    first entry).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义。** *二叉堆*是一组按照完全堆排序的二叉树中的键排列的节点集合，在数组中按层级顺序表示（不使用第一个条目）。'
- en: '![Heap representations](../Images/1069511eeff607185ad0e767d4fe97fc.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![堆表示](../Images/1069511eeff607185ad0e767d4fe97fc.png)'
- en: 'In a heap, the parent of the node in position k is in position k/2; and, conversely,
    the two children of the node in position k are in positions 2k and 2k + 1. We
    can travel up and down by doing simple arithmetic on array indices: to move up
    the tree from a[k] we set k to k/2; to move down the tree we set k to 2*k or 2*k+1\.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆中，位置为 k 的节点的父节点在位置 k/2；反之，位置为 k 的节点的两个子节点在位置 2k 和 2k + 1。我们可以通过对数组索引进行简单算术来上下移动：从
    a[k] 向上移动树，我们将 k 设置为 k/2；向下移动树，我们将 k 设置为 2*k 或 2*k+1。
- en: Algorithms on heaps.
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆上的算法。
- en: We represent a heap of size *n* in private array `pq[]` of length *n* + 1, with
    `pq[0]` unused and the heap in `pq[1]` through `pq[n]`. We access keys only through
    private helper functions `less()` and `exch()`. The heap operations that we consider
    work by first making a simple modification that could violate the heap condition,
    then traveling through the heap, modifying the heap as required to ensure that
    the heap condition is satisfied everywhere. We refer to this process as *reheapifying*,
    or *restoring heap order*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在长度为 *n* + 1 的私有数组 `pq[]` 中表示大小为 *n* 的堆，其中 `pq[0]` 未使用，堆在 `pq[1]` 到 `pq[n]`
    中。我们仅通过私有辅助函数 `less()` 和 `exch()` 访问键。我们考虑的堆操作通过首先进行可能违反堆条件的简单修改，然后通���遍历堆，根据需要修改堆以确保堆条件在任何地方都得到满足来工作。我们将这个过程称为*重新堆化*，或*恢复堆顺序*。
- en: '*Bottom-up reheapify (swim).* If the heap order is violated because a node''s
    key becomes larger than that node''s parents key, then we can make progress toward
    fixing the violation by exchanging the node with its parent. After the exchange,
    the node is larger than both its children (one is the old parent, and the other
    is smaller than the old parent because it was a child of that node) but the node
    may still be larger than its parent. We can fix that violation in the same way,
    and so forth, moving up the heap until we reach a node with a larger key, or the
    root. ![Bottom-up heapify (swim)](../Images/edc1590f61b319544077f3b000a3d800.png)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自底向上重新堆化（上浮）*。如果堆顺序被违反，因为一个节点的键变大于该节点的父节点的键，那么我们可以通过将节点与其父节点交换来向修复违规迈进。交换后，节点比其两个子节点都大（一个是旧父节点，另一个比旧父节点小，因为它是该节点的子节点），但节点可能仍然比其父节点大。我们可以以相同的方式修复该违规，依此类推，向上移动堆，直到到达具有较大键的节点，或根节点。![自底向上堆化（上浮）](../Images/edc1590f61b319544077f3b000a3d800.png)'
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Top-down heapify (sink).* If the heap order is violated because a node''s
    key becomes smaller than one or both of that node''s children''s keys, then we
    can make progress toward fixing the violation by exchanging the node with the
    larger of its two children. This switch may cause a violation at the child; we
    fix that violation in the same way, and so forth, moving down the heap until we
    reach a node with both children smaller, or the bottom. ![Top-down heapify (sink)](../Images/6b860b47d51101f9886af0322400ee77.png)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自顶向下堆化（下沉）*。如果堆顺序被违反，因为一个节点的键变小于一个或两个子节点的键，那么我们可以通过将节点与其两个子节点中较大的一个交换来向修复违规迈进。这种交换可能导致子节点违规；我们以相同的方式修复该违规，依此类推，向下移动堆，直到到达两个子节点都较小或底部的节点。![自顶向下堆化（下沉）](../Images/6b860b47d51101f9886af0322400ee77.png)'
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Heap representations](../Images/1085225cde5915777e82e16b25c57c1f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![堆表示](../Images/1085225cde5915777e82e16b25c57c1f.png)'
- en: Heap-based priority queue.
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于堆的优先队列。
- en: These `sink()` and `swim()` operations provide the basis for efficient implementation
    of the priority-queue API, as diagrammed below and implemented in [MaxPQ.java](MaxPQ.java.html)
    and [MinPQ.java](MinPQ.java.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `sink()` 和 `swim()` 操作为优先队列 API 的高效实现提供了基础，如下图所示，并在 [MaxPQ.java](MaxPQ.java.html)
    和 [MinPQ.java](MinPQ.java.html) 中实现。
- en: '*Insert.* We add the new item at the end of the array, increment the size of
    the heap, and then swim up through the heap with that item to restore the heap
    condition.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入*。我们在数组末尾添加新项，增加堆的大小，然后通过该项向上游走以恢复堆的条件。'
- en: '*Remove the maximum.* We take the largest item off the top, put the item from
    the end of the heap at the top, decrement the size of the heap, and then sink
    down through the heap with that item to restore the heap condition.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除最大值*。我们将顶部的最大项取出，将堆的末尾项放在顶部，减少堆的大小，然后通过该项向下沉入堆中以恢复堆的条件。'
- en: '![Heap operations](../Images/bcd7d14e37e5ad5d727a7860617d343b.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![堆操作](../Images/bcd7d14e37e5ad5d727a7860617d343b.png)'
- en: '**Proposition.** In an *n*-item priority queue, the heap algorithms require
    no more than 1 + lg *n* compares for *insert* and no more than 2 lg *n* compares
    for *remove the maximum*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** 在一个包含 *n* 项的优先队列中，堆算法对*插入*最多需要 1 + lg *n* 次比较，对*移除最大值*最多需要 2 lg *n*
    次比较。'
- en: Practical considerations.
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际考虑。
- en: We conclude our study of the heap priority queue API with a few practical considerations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以几个实际考虑结束对堆优先队列 API 的研究。
- en: '*Multiway heaps.* It is not difficult to modify our code to build heaps based
    on an array representation of complete heap-ordered ternary or *d*-ary trees.
    There is a tradeoff between the lower cost from the reduced tree height and the
    higher cost of finding the largest of the three or *d* children at each node.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多路堆*。修改我们的代码以构建基于完整堆排序三元或*d*元树的数组表示并不困难。在降低树高度的较低成本和在每个节点找到三个或*d*个子节点中最大成本��间存在权衡。'
- en: '*Array resizing.* We can add a no-argument constructor, code for array doubling
    in `insert()`, and code for array halving in `delMax()`, just as we did for stacks
    in Section 1.3. The logarithmic time bounds are *amortized* when the size of the
    priority queue is arbitrary and the arrays are resized.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组调整*。我们可以添加一个无参数构造函数，在`insert()`中添加数组加倍的代码，在`delMax()`中添加数组减半的代码，就像我们在第1.3节中为堆栈所做的那样。当优先队列的大小是任意的且数组被调整大小时，对数时间界是*摊销的*。'
- en: '*Immutability of keys.* The priority queue contains objects that are created
    by clients but assumes that the client code does not change the keys (which might
    invalidate the heap invariants).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*键的不可变性*。优先队列包含由客户端创建的对象，但假设客户端代码不会更改键（这可能会使堆的不变性无效）。'
- en: '*Index priority queue.* In many applications, it makes sense to allow clients
    to refer to items that are already on the priority queue. One easy way to do so
    is to associate a unique integer index with each item.![Index Priority queue API](../Images/86651f5598e56caf001ce5716bb54fb9.png)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*索引优先队列*。在许多应用中，允许客户端引用已经在优先队列中的项目是有意义的。一种简单的方法是为每个项目关联一个唯一的整数索引。![索引优先队列 API](../Images/86651f5598e56caf001ce5716bb54fb9.png)'
- en: '[IndexMinPQ.java](IndexMinPQ.java.html) is a heap-based implementation of this
    API; [IndexMaxPQ.java](IndexMaxPQ.java.html) is similar but for maximum-oriented
    priority queues. [Multiway.java](Multiway.java.html) is a client that merges together
    several sorted input streams into one sorted output stream.'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[IndexMinPQ.java](IndexMinPQ.java.html) 是这个API的基于堆的实现；[IndexMaxPQ.java](IndexMaxPQ.java.html)
    类似，但用于面向最大的优先队列。[Multiway.java](Multiway.java.html) 是一个客户端，将几个排序的输入流合并成一个排序的输出流。'
- en: Heapsort.
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆排序。
- en: We can use any priority queue to develop a sorting method. We insert all the
    keys to be sorted into a minimum-oriented priority queue, then repeatedly use
    *remove the minimum* to remove them all in order. When using a heap for the priority
    queue, we obtain *heapsort*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何优先队列来开发排序方法。我们将所有要排序的键插入到面向最小的优先队列中，然后重复使用*删除最小值*按顺序删除它们。当使用堆作为优先队列时，我们获得*堆排序*。
- en: 'Focusing on the task of sorting, we abandon the notion of hiding the heap representation
    of the priority queue and use `swim()` and `sink()` directly. Doing so allows
    us to sort an array without needing any extra space, by maintaining the heap within
    the array to be sorted. Heapsort breaks into two phases: *heap construction*,
    where we reorganize the original array into a heap, and the *sortdown*, where
    we pull the items out of the heap in decreasing order to build the sorted result.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 着眼于排序任务，我们放弃了隐藏优先队列的堆表示的概念，并直接使用`swim()`和`sink()`。这样做允许我们在不需要任何额外空间的情况下对数组进行排序，通过在要排序的数组内维护堆。堆排序分为两个阶段：*堆构造*，在这个阶段我们将原始数组重新组织成堆，和*sortdown*，在这个阶段我们按递减顺序从堆中取出项目以构建排序结果。
- en: '*Heap construction.* We can accomplish this task in time proportional to *n*
    lg *n*,by proceeding from left to right through the array, using `swim()` to ensure
    that the entries to the left of the scanning pointer make up a heap-ordered complete
    tree, like successive priority queue insertions. A clever method that is much
    more efficient is to proceed from right to left, using `sink()` to make subheaps
    as we go. Every position in the array is the root of a small subheap; `sink()`
    works or such subheaps, as well. If the two children of a node are heaps, then
    calling `sink()` on that node makes the subtree rooted there a heap.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆构造*。我们可以在时间上按比例完成这项任务*n* lg *n*，通过从数组的左侧到右侧进行，使用`swim()`来确保扫描指针左侧的条目组成一个堆排序完整树，就像连续的优先队列插入一样。一个更有效的巧妙方法是从右到左进行，使用`sink()`来随着我们的前进制作子堆。数组中的每个位置都是一个小子堆的根；`sink()`也适用于这样的子堆。如果一个节点的两个子节点是堆，那么在该节点上调用`sink()`会使根在那里的子树成为堆。'
- en: '*Sortdown.* Most of the work during heapsort is done during the second phase,
    where we remove the largest remaining items from the heap and put it into the
    array position vacated as the heap shrinks.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sortdown*。在堆排序期间，大部分工作是在第二阶段完成的，在这个阶段我们从堆中移除剩余的最大项目，并将其放入数组位置中，随着堆的缩小而腾出。'
- en: '![Trace of heapsort](../Images/b96ebedbca6d10677073c3df1cd14fec.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![堆排序的跟踪](../Images/b96ebedbca6d10677073c3df1cd14fec.png)'
- en: '[Heap.java](Heap.java.html) is a full implementation of heapsort. Below is
    a trace of the contents of the array after each sink.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[Heap.java](Heap.java.html) 是堆排序的完整实现。下面是每次下沉后数组内容的跟踪。'
- en: '![Trace of heapsort](../Images/88ba1841f63688481ee015ff0841a3f7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![堆排序的跟踪](../Images/88ba1841f63688481ee015ff0841a3f7.png)'
- en: '**Proposition.** Sink-based heap construction is linear time.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** 基于sink的堆构造是线性时间的。'
- en: '**Proposition.** Heapsort users fewer than 2 *n* lg *n* compare and exchanges
    to sort n items.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** 堆排序使用少于2 *n* lg *n* 次比较和交换来对n个项目进行排序。'
- en: Most items reinserted into the heap during sortdown go all the way to the bottom.
    We can thus save time by avoiding the check for whether the item has reached its
    position, simply promoting the larger of the two children until the bottom is
    reached, then moving back up the heap to the proper position. This idea cuts the
    number of compares by a factor of 2 at the expense of extra bookkeeping.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在sortdown期间重新插入堆中的大多数项目都会一直到底部。因此，我们可以通过避免检查项目是否已到达其位置来节省时间，简单地提升两个子节点中较大的一个，直到到达底部，然后沿着堆向上移动到正确的位置。这个想法通过增加额外的簿记来减少了比较次数。
- en: Exercises
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Suppose that the sequence
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设序列
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (where a letter means *insert* and an asterisk means *remove the maximum*) is
    applied to an initially empty priority queue. Give the sequence of values returned
    by *remove the maximum* operations.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （其中字母表示*插入*，星号表示*删除最大值*）应用于最初为空的优先队列。给出*删除最大值*操作返回的值序列。
- en: '*Solution.* R R P O T Y I I U Q E U (E left on PQ)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。R R P O T Y I I U Q E U（PQ上剩下E）'
- en: 'Criticize the following idea: to implement *find the maximum* in constant time,
    why not keep track of the maximum value inserted so far, then return that value
    for *find the maximum*?'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批评以下想法：为了在常数时间内实现*查找最大值*，为什么不跟踪迄今为止插入的最大值，然后在*查找最大值*时返回该值？
- en: '*Solution.* Will need to update the maximum value from scratch after a *remove-the-maximum*
    operation.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。在*删除最大值*操作后，需要从头开始更新最大值。'
- en: 'Provide priority queue implementations that support *insert* and *remove the
    maximum*, one for each of the following underlying data structures: unordered
    array, ordered array, unordered linked list, and ordered linked list. Give a table
    of the worst-case bounds for each operation for each of your four implementations
    from the previous exercise.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供支持*插入*和*删除最大值*的优先队列实现，每种实现对应一个基础数据结构：无序数组、有序数组、无序链表和有序链表。给出您在上一个练习中四种实现的每个操作的最坏情况下界的表格。
- en: '*Partial solution.* [OrderedArrayMaxPQ.java](OrderedArrayMaxPQ.java.html) and
    [UnorderedArrayMaxPQ.java](UnorderedArrayMaxPQ.java.html)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案*。[OrderedArrayMaxPQ.java](OrderedArrayMaxPQ.java.html)和[UnorderedArrayMaxPQ.java](UnorderedArrayMaxPQ.java.html)'
- en: Is an array that is sorted in decreasing order a max-oriented heap.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序为降序的数组是否是面向最大值的堆。
- en: '*Answer.* Yes.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*。是的。'
- en: 'Suppose that your application will have a huge number of *insert* operations,
    but only a few *remove the maximum* operations. Which priority-queue implementation
    do you think would be most effective: heap, unordered array, ordered array?'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您的应用程序将有大量*插入*操作，但只有少量*删除最大值*操作。您认为哪种优先队列实现最有效：堆、无序数组、有序数组？
- en: '*Answer.* Unordered array. Insert is constant time.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*。无序数组。插入是常数时间。'
- en: 'Suppose that your application will have a huge number of *find the maximum*
    operations, but a relatively small number of *insert* and *remove the maximum*
    operations. Which priority queue implementation do you think would be most effective:
    heap, unordered array, ordered array?'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您的应用程序将有大量*查找最大值*操作，但相对较少的*插入*和*删除最大值*操作。您认为哪种优先队列实现最有效：堆、无序数组、有序数组？
- en: '*Answer.* Ordered array. Find the maximum is constant time.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*。有序数组。在常数时间内找到最大值。'
- en: What is the minimum number of items that must be exchanged during a *remove
    the maximum* operation in a heap of size *n* with no duplicate keys? Give a heap
    of size 15 for which the minimum is achieved. Answer the same question for two
    and three successive *remove the maximum* operations.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个没有重复键的大小为*n*的堆中，*删除最大值*操作期间必须交换的最小项数是多少？给出一个大小为15的堆，使得最小值得以实现。对连续两次和三次*删除最大值*操作，回答相同的问题。
- en: '*Partial answer*: (a) 2.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分答案*：(a) 2。'
- en: Design a linear-time certification algorithm to check whether an array `pq[]`
    is a min-oriented heap.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计一个线性时间的认证算法来检查数组`pq[]`是否是一个面向最小值的堆。
- en: '*Solution.* See the `isMinHeap()` method in [MinPQ.java](MinPQ.java.html).'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。参见[MinPQ.java](MinPQ.java.html)中的`isMinHeap()`方法。'
- en: Prove that sink-based heap construction uses at most 2*n* compares and at most
    *n* exchanges.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明基于下沉的堆构建最多使用2*n*次比较和最多*n*次交换。
- en: '*Solution.* It suffices to prove that sink-based heap construction uses fewer
    than *n* exchanges because the number of compares is at most twice the number
    of exchanges. For simplicity, assume that the binary heap is *perfect* (i.e.,
    a binary tree in which every level is completely filled) and has height *h*.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。只需证明基于下沉的堆构建使用的交换次数少于*n*次，因为比较次数最多是交换次数的两倍。为简单起见，假设二叉堆是*完美*的（即每一层都完全填满的二叉树）且高度为*h*。'
- en: '![Alternate heapify analysis](../Images/98ab74dc5f0f48643d5188dfd339837e.png)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![堆调整分析](../Images/98ab74dc5f0f48643d5188dfd339837e.png)'
- en: 'We define the *height* of a node in a tree to be the height of the subtree
    rooted at that node. A key at height *k* can be exchanged with at most *k* keys
    beneath it when it is sunk down. Since there are 2^(*h*−*k*) nodes at height *k*,
    the total number of exchanges is at most: $$ \begin{eqnarray*} h + 2(h-1) + 4(h-2)
    + 8(h-3) + \ldots + 2^h (0) & = & 2^{h+1} - h - 2 \\ & = & n - (h+1) \\ & \le
    & n \end{eqnarray*} $$'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义树中节点的*高度*为以该节点为根的子树的高度。当一个高度为*k*的键被下沉时，它最多可以与其下面的*k*个键交换。由于在高度*k*处有2^(*h*−*k*)个节点，总交换次数最多为：$$
    \begin{eqnarray*} h + 2(h-1) + 4(h-2) + 8(h-3) + \ldots + 2^h (0) & = & 2^{h+1}
    - h - 2 \\ & = & n - (h+1) \\ & \le & n \end{eqnarray*} $$
- en: The first equality is for a nonstandard sum, but it is straightforward to verify
    that the formula holds via mathematical induction. The second equality holds because
    a perfect binary tree of height *h* has 2^(*h*+1) − 1 nodes.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个等式是针对非标准求和的，但通过数学归纳法很容易验证该公式成立。第二个等式成立是因为高度为*h*的完美二叉树有2^(*h*+1) − 1个节点。
- en: Proving that the result holds when the binary tree is not perfect requires a
    bit more care. You can do so using the fact that the number of nodes at height
    *k* in a binary heap on *n* nodes is at most ceil(*n* / 2^(*k*+1)).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明当二叉树不完美时结果成立需要更加小心。您可以使用以下事实来证明：在具有*n*个节点的二叉堆中，高度为*k*的节点的数量最多为ceil(*n* / 2^(*k*+1))。
- en: '*Alternate solution.* We define the *height* of a node in a tree to be the
    height of the subtree rooted at that node.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*替代解决方案*。我们定义树中节点的*高度*为以该节点为根的子树的高度。'
- en: First, observe that a binary heap on *n* nodes has *n* − 1 links (because each
    link is the parent of one node and every node has a parent link except the root).
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，观察到一个具有*n*个节点的二叉堆有*n* − 1个链接（因为每个链接是一个节点的父节点，每个节点都有一个父链接，除了根节点）。
- en: Sinking a node of height *k* requires at most *k* exchanges.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下沉一个高度为*k*的节点最多需要*k*次交换。
- en: We will charge *k* links to each node at height *k*, but not necessarily the
    links on the path taken when sinking the node. Instead, we charge the node the
    *k* links along the path from the node that goes left–right–right–right–.... For
    example, in the diagram below, the root node is charged the 4 red links; the blue
    node is charged the 3 blue links; and so forth.![Alternate heapify analysis](../Images/e14cd694cc91c2b8e3a0a20aafd5655b.png)
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将对每个高度为*k*的节点收取*k*个链接，但不一定是在下沉节点时所采取的路径上的链接。相反，我们对从节点沿着左-右-右-右-...路径的*k*个链接收费。例如，在下图中，根节点收取4个红色链接；蓝色节点收取3个蓝色链接；依此类推。![备用堆化分析](../Images/e14cd694cc91c2b8e3a0a20aafd5655b.png)
- en: Note that no link is charged to more than one node. (Links obtained by following
    only right links from the root are not charged to any node.)
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，没有链接会被收费超过一个节点。（仅通过从根节点向右链接获得的链接不会被收费给任何节点。）
- en: Thus, the total number of exchanges is at most *n*. Since there are at most
    2 compares per exchange, the number of compares is at most 2*n*.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，总交换次数最多为*n*。由于每次交换最多有2次比较，因此比较次数最多为2*n*。
- en: Creative Problems
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意问题
- en: '**Computational number theory.** Write a program [CubeSum.java](CubeSum.java.html)
    that prints out all integers of the form \(a^3 + b^3\) where \(a\) and \(b\) are
    integers between 0 and \(nsorted order, without using excessive space. That is,
    instead of computing an array of the \(n^2\) sums and sorting them, build a minimum-oriented
    priority queue, initially containing \((0^3, 0, 0), (1^3 + 1^3, 1, 1), (2^3 +
    2^3, 2, 2), \ldots, (n^3 + n^3, n, n)\). Then, while the priority queue is nonempty,
    remove the smallest item \(i^3 + j^3,\; i, \; j)\), print it, and then, if \(j
    < n\), insert the item \((i^3 + (j+1)^3,\; i,\; j+1)\). Use this program to find
    all distinct integers \(a, b, c\), and \(d\) between 0 and \(10^6\) such that
    \(a^3 + b^3 = c^3 + d^3\), such as \(1729 = 9^3 + 10^3 = 1^3 + 12^3\).'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算数论。** 编写一个程序[CubeSum.java](CubeSum.java.html)，打印出所有形式为\(a^3 + b^3\)的整数，其中\(a\)和\(b\)是介于0和\(n\)之间的整数，按排序顺序打印，而不使用过多的空间。也就是说，不要计算一个包含\(n^2\)个和并对它们进行排序的数组，而是构建一个最小导向的优先队列，最初包含\((0^3,
    0, 0), (1^3 + 1^3, 1, 1), (2^3 + 2^3, 2, 2), \ldots, (n^3 + n^3, n, n)\)。然后，在优先队列非空时，移除最小项\(i^3
    + j^3,\; i, \; j)\)，打印它，然后，如果\(j < n\)，插入项\((i^3 + (j+1)^3,\; i,\; j+1)\)。使用这个程序找到所有介于0和\(10^6\)之间的不同整数\(a,
    b, c\)和\(d\)，使得\(a^3 + b^3 = c^3 + d^3\)，例如\(1729 = 9^3 + 10^3 = 1^3 + 12^3\)。'
- en: '**Find the minimum.** Add a `min()` method to [MaxPQ.java](MaxPQ.java.html).
    Your implementation should use constant time and constant extra space.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找最小值。** 在[MaxPQ.java](MaxPQ.java.html)中添加一个`min()`方法。你的实现应该使用恒定的时间和额外的空间。'
- en: '*Solution*: add an extra instance variable that points to the minimum item.
    Update it after each call to `insert()`. Reset it to `null` if the priority queue
    becomes empty.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：添加一个额外的实例变量，指向最小项。在每次调用`insert()`后更新它。如果优先队列变为空，则将其重置为`null`。'
- en: '**Dynamic-median finding.** Design a data type that supports *insert* in logarithmic
    time, *find the median* in constant time, and *remove the median* in logarithmic
    time.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态中位数查找。** 设计一个数据类型，支持对数时间的*插入*，常数时间的*查找中位数*，以及对数时间的*删除中位数*。'
- en: '*Solution*. Keep the median key in v; use a max-oriented heap for keys less
    than the key of v; use a min-oriented heap for keys greater than the key of v.
    To insert, add the new key into the appropriate heap, replace v with the key extracted
    from that heap.'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 将中位数键保留在v中；对于小于v键的键，使用一个最大导向的堆；对于大于v键的键，使用一个最小导向的堆。要插入，将新键添加到适当的堆中，用从该堆中提取的键替换v。'
- en: '**Lower bound.** Prove that it is impossible to develop an implementation of
    the MinPQ API such that both insert and delete the minimum guarantee to use ~
    *n* log log *n* compares.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下界。** 证明不可能开发一个MinPQ API的实现，使得插入和删除最小值都保证使用~*n* log log *n*比较。'
- en: '*Solution.* This would yield an *n* log log *n* compare-based sorting algorithm
    (insert the *n* items, then repeatedly remove the minimum), violating the proposition
    of Section 2.3.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 这将产生一个*n* log log *n*比较排序算法（插入*n*个项目，然后重复删除最小值），违反了第2.3节的命题。'
- en: '**Index priority-queue implementation.** Implement [IndexMaxPQ.java](IndexMaxPQ.java.html)
    by modifying [MaxPQ.java](MaxPQ.java.html) as follows: Change `pq[]` to hold indices,
    add an array `keys[]` to hold the key values, and add an array `qp[]` that is
    the inverse of `pq[]` — `qp[i]` gives the position of `i` in `pq[]` (the index
    `j` such that `pq[j]` is `i`). Then modify the code to maintain these data structures.
    Use the convention that `qp[i]` is `-1` if `i` is not on the queue, and include
    a method `contains()` that tests this condition. You need to modify the helper
    methods `exch()` and `less()` but not `sink()` or `swim()`.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**索引优先队列实现。** 通过修改[MaxPQ.java](MaxPQ.java.html)来实现[IndexMaxPQ.java](IndexMaxPQ.java.html)：将`pq[]`更改为保存索引，添加一个数组`keys[]`来保存键值，并添加一个数组`qp[]`，它是`pq[]`的逆——`qp[i]`给出`i`在`pq[]`中的位置（索引`j`，使得`pq[j]`是`i`）。然后修改代码以维护这些数据结构。使用约定，如果`i`不在队列中，则`qp[i]`为`-1`，并包括一个测试此条件的方法`contains()`。您需要修改辅助方法`exch()`和`less()`，但不需��修改`sink()`或`swim()`。'
- en: Web Exercises
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: '**Best, average, and worst case of heapsort.** What''s are the best case, average
    case, and worst case number of compares for heapsorting an array of length *n*?'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆排序的最佳、平均和最差情况。** 对于对长度为*n*的数组进行堆排序，最佳情况、平均情况和最差情况的比较次数分别是多少？'
- en: '*Solution.* If we allow duplicates, the best case is linear time (*n* equal
    keys); if we disallow duplicates, the best case is ~ *n* lg *n* compares (but
    the best case input is nontrivial). The average and worst case number of compares
    is ~ 2 *n* lg *n* compares. See [The Analysis of Heapsort](../references/papers/heapsort-sedgewick.pdf)
    for details.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 如果允许重复项，最佳情况是线性时间（*n*个相等的键）；如果不允许重复项，最佳情况是~*n* lg *n*比较（但最佳情况输入是非平凡的）。平均情况和最差情况的比较次数是~2
    *n* lg *n*比较。详细信息请参阅[堆排序的分析](../references/papers/heapsort-sedgewick.pdf)。'
- en: '**Best and worst case of heapify.** What is the fewest and most number of compares/exchanges
    needed to heapify an array of *n* items?'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆化的最佳和最差情况。** 对于*n*个项目的数组进行堆化所需的最少和最多比较/交换次数是多少？'
- en: '*Solution.* Heapifying an array of *n* items in descending order requires 0
    exchanges and *n* − 1 compares. Heapifying an array of *n* items in ascending
    order requires ~ *n* exchanges and ~ *2n* compares.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 对包含*n*个项目的数组进行降序堆化需要0次交换和*n* − 1次比较。对包含*n*个项目的数组进行升序堆化需要~ *n*次交换和~
    *2n*次比较。'
- en: '**Taxicab numbers.** Find the smallest integers that can be expressed as the
    sum of cubes of integers in two different ways (1,729), three different ways (87,539,319),
    four different ways (6,963,472,309,248), five different ways (48,988,659,276,962,496),
    and six different ways (24,153,319,581,254,312,065,344). Such integers are named
    [Taxicab numbers](http://mathworld.wolfram.com/TaxicabNumber.html) after the famous
    Ramanujan story. The smallest integers that can be expressed as the sum of cubes
    of integers in seven different ways is currently unknown. Write a program [Taxicab.java](Taxicab.java.html)
    that reads in a command line parameter N and prints out all nontrivial solutions
    of a³ + b³ = c³ + d³. such that a, b, c, and d, are less than or equal to N.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**出租车数。** 找到可以用两种不同方式的整数立方和表示的最小整数（1,729），三种不同方式（87,539,319），四种不同方式（6,963,472,309,248），五种不同方式（48,988,659,276,962,496），以及六种不同方式（24,153,319,581,254,312,065,344）。这样的整数被命名为[出租车数](http://mathworld.wolfram.com/TaxicabNumber.html)以纪念著名的拉马努金故事。目前尚不清楚可以用七种不同方式表示为整数立方和的最小整数。编写一个程序[Taxicab.java](Taxicab.java.html)，该程序读取一个命令行参数N，并打印出所有非平凡解a³
    + b³ = c³ + d³，其中a、b、c和d小于或等于N。'
- en: '**Computational number theory.** Find all solutions to the equation a + 2b²
    = 3c³ + 4d⁴ for which a, b, c, and d are less than 100,000\. *Hint*: use one min
    heap and one max heap.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算数论。** 找到方程a + 2b² = 3c³ + 4d⁴的所有解，其中a、b、c和d小于100,000。*提示*：使用一个最小堆和一个最大堆。'
- en: '**Interrupt handling.** When programming a real-time system that can be interrupted
    (e.g., by a mouse click or wireless connection), it is necessary to attend to
    the interrupts immediately, before proceeding with the current activity. If the
    interrupts should be handled in the same order they arrive, then a FIFO queue
    is the appropriate data structure. However, if different interrupts have different
    priorities (e.g., ), then we need a priority queue.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中断处理。** 在编写可以被中断的实时系统时（例如，通过鼠标点击或无线连接），需要立即处理中断，然后再继续当前活动。如果中断应按照到达的顺序处理，则FIFO队列是适当的数据结构。然而，如果不同的中断具有不同的优先级（例如，），则需要优先级队列。'
- en: '**Simulation of queueing networks.** M/M/1 queue for double parallel queues,
    etc. Difficult to analyze complex queueing networks mathematically. Instead use
    simulation to plot distribution of waiting times, etc. Need priority queue to
    determine which event to process next.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排队网络的模拟。** M/M/1队列用于双并行队列等。数学上难以分析复杂的排队网络。因此使用模拟来绘制等待时间分布等。需要优先级队列来确定下一个要处理的事件。'
- en: '**Zipf distribution.** Use the result of the previous exercise(s) to sample
    from the [Zipfian distribution](http://en.wikipedia.org/wiki/Zipf''s_law) with
    parameter s and *n*. The distribution can take on integer values from 1 to *n*,
    and takes on value k with probability 1/k^s / sum_(i = 1 to *n*) 1/i^s. Example:
    words in Shakespeare''s play Hamlet with s approximately equal to 1.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Zipf分布。** 使用前面练习的结果从具有参数s和*n*的[Zipf分布](http://en.wikipedia.org/wiki/Zipf''s_law)中进行抽样。该分布可以取1到*n*之间的整数值，并以概率1/k^s
    / sum_(i = 1 to *n*) 1/i^s取值k。例如：莎士比亚的戏剧《哈姆雷特》中的单词，s约等于1。'
- en: '**Random process.** Begin with *n* bins, each consisting one ball. Randomly
    select one of the *n* balls and move the ball to a bin at random such that the
    probability that a ball is placed in a bin with *m* balls is *m*/*n*. What is
    the distribution of balls that results after many iterations? Use the random sampling
    method described above to make the simulation efficient.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机过程。** 从*n*个箱子开始，每个箱子包含一个球。随机选择其中一个*n*个球，并将球随机移动到一个箱���中，使得球被放置在具有*m*个球的箱子中的概率为*m*/*n*。经过多次迭代后，结果是什么样的球分布？使用上述描述的随机抽样方法使模拟更有效率。'
- en: '**Nearest neighbors.** Given *n* vectors x[1], x[2], ..., x[N] of length *m*
    and another vector *x* of the same length, find the 20 vectors that are closest
    to *x*.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最近邻。** 给定长度为*m*的*n*个向量x[1]、x[2]、...、x[N]和另一个相同长度的向量*x*，找到距离*x*最近的20个向量。'
- en: '**Circle drawn on a piece of graph paper.** Write a program to find the radius
    of a circle, centered on the origin, that touches 32 points with integer x- and
    y- coordinates. Hint: look for a number than can be expressed as the sum of two
    squares in several different ways. Answer: there are two Pythagorean triples with
    hypotenuse 25: 15^2 + 20^2 = 25^2, 7^2 + 24^2 = 25^2 yielding 20 such lattice
    points; there are 22 different Pythagorean triples with hypotenuse 5,525; this
    leads to 180 lattice points. 27,625 is smallest radius that touches more than
    64. 154,136,450 has 35 Pythagorean triples.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在一张图纸上画圆。** 编写一个程序来找到以原点为中心，与整数x和y坐标的32个点相切的圆的半径。提示：寻找一个可以用几种不同方式表示为两个平方和的数字。答案：有两个勾股三元组的斜边为25：15^2
    + 20^2 = 25^2，7^2 + 24^2 = 25^2，得到20个这样的格点；有22个不同的斜边为5,525的勾股三元组；这导致180个格点。27,625是比64更多的最小半径。154,136,450有35个勾股三元组。'
- en: '**Perfect powers.** Write a program [PerfectPower.java](PerfectPower.java.html)
    to print out all perfect powers that can be represented as 64-bit `long` integers:
    4, 8, 9, 16, 25, 27, .... A perfect power is a number that can be written as a^b
    for integers a and b ≥ 2.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完美幂。** 编写一个程序[PerfectPower.java](PerfectPower.java.html)来打印所有可以表示为64位`long`整数的完美幂：4,
    8, 9, 16, 25, 27, .... 完美幂是可以写成a^b的数字，其中a和b ≥ 2为整数。'
- en: '**Floating point additions.** Add up *n* floating-point numbers, avoiding roundoff
    error. Delete smallest two: add two each other, and reinsert.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**浮点加法。** 添加*n*个浮点数，避免舍入误差。删除最小的两个：将它们相加，然后重新插入。'
- en: '**First-fit for bin packing.** 17/10 OPT + 2, 11/9 OPT + 4 (decreasing). Use
    max tournament tree in which players are N bins and value = available capacity.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**首次适应装箱。** 17/10 OPT + 2, 11/9 OPT + 4（递减）。使用最大锦标赛树，其中选手是N个箱子，值=可用容量。'
- en: '**Stack with min/max.** Design a data type that supports push, pop, size, min,
    and max (where min and max are the minimum and maximum items on the stack). All
    operations should take constant time in the worst case.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有最小/最大值的栈。** 设计一个数据类型，支持推入、弹出、大小、最小值和最大值（其中最小值和最大值是栈上的最小和最大项目）。所有操作在最坏情况下应该花费常数时间。'
- en: '*Hint:* Associate with each stack entry the minimum and maximum items currently
    on the stack.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示：*将每个栈条目与当前栈上的最小和最大项目关联起来。'
- en: '**Queue with min/max.** Design a data type that supports enqueue, dequeue,
    size, min, and max (where min and max are the minimum and maximum items on the
    queue). All operations should take constant amortized time.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有最小/最大值的队列。** 设计一个数据类型，支持入队、出队、大小、最小值和最大值（其中最小值和最大值是队列上的最小和最大项目）。所有操作应该在常摊时间内完成。'
- en: '*Hint:* do the previous exercise and simulate a queue with two stacks.'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示：*完成前面的练习，并模拟使用两个栈的队列。'
- en: '**2^i + 5^j.** Print numbers of the form 2^i * 5^j in increasing order.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2^i + 5^j。** 按升序打印形式为2^i * 5^j的数字。'
- en: '**Min-max heap.** Design a data structure that supports min and max in constant
    time, insert, delete min, and delete max in logarithmic time by putting the items
    in a single array of size *n* with the following properties:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小-最大堆。** 设计一个数据结构，通过将项目放入大小为*n*的单个数组中，支持常数时间内的最小值和最大值，以及对数时间内的插入、删除最小值和删除最大值，具有以下属性：'
- en: The array represents a complete binary tree.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组表示一个完全二叉树。
- en: The key in a node at an even level is less than (or equal to) the keys in its
    subtree; the key in a node at an odd level is greater than (or equal to) the keys
    in its subtree.Note that the maximum value is stored at the root and the minimum
    value is stored at one of the root's children.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶数级别节点中的键小于（或等于）其子树中的键；奇数级别节点中的键大于（或等于）其子树中的键。请注意，最大值存储在根节点，最小值存储在根节点的一个子节点中。
- en: '*Solution.* [Min-Max Heaps and Generalized Priority Queues](http://cg.scs.carleton.ca/~morin/teaching/5408/refs/minmax.pdf)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* [最小-最大堆和广义优先队列](http://cg.scs.carleton.ca/~morin/teaching/5408/refs/minmax.pdf)'
- en: '**Range minimum query.** Given a sequence of *n* items, a [range minimum query](http://en.wikipedia.org/wiki/Range_Minimum_Query)
    from index i to j is the index of the minimum item between i and j. Design a data
    structure that preprocesses the sequence of *n* items in linear time to support
    range minimum queries in logarithmic time.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**范围最小查询。** 给定一个包含*n*个项目的序列，从索引i到j的[范围最小查询](http://en.wikipedia.org/wiki/Range_Minimum_Query)是i和j之间最小项目的索引。设计一个数据结构，在线性时间内预处理*n*个项目的序列，以支持对数时间内的范围最小查询。'
- en: Prove that a complete binary tree with *n* nodes has exactly ceiling(*n*/2)
    leaf nodes (nodes with no children).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明具有*n*个节点的完全二叉树恰好有*ceiling(n/2)*个叶节点（没有子节点的节点）。
- en: '**Max-oriented priority queue with min.** What is the order of growth of the
    running time to find a *minimum* key in a *maximum*-oriented binary heap.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有最小值的最大导向优先队列。** 在最大导向的二叉堆中查找*最小*键的运行时间增长顺序是什么。'
- en: '*Solution*: linear—the minimum key could be in any of the ceiling(*n*/2) leaf
    nodes.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：*线性—最小键可能在任何一个*ceiling(n/2)*个叶节点中。'
- en: '**Max-oriented priority queue with min.** Design a data type that supports
    *insert* and *remove-the-maximum* in logarithmic time along with both *max* an
    *min* in constant time.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有最小值的最大导向优先队列。** 设计一个数据类型，支持对数时间内的*插入*和*删除最大值*，以及常数时间内的*最大值*和*最小值*。'
- en: '*Solution.* Create a max-oriented binary heap and also store the minimum key
    inserted so far (which will never increase unless this heap becomes empty).'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 创建一个最大导向的二叉堆，并存储迄今为止插入的最小键（除非此堆变为空，否则永远不会增加）。'
- en: '**kth largest item greater than x.** Given a maximum oriented binary heap,
    design an algorithm to determine whether the kth largest item is greater than
    or equal to x. Your algorithm should run in time proportional to k.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大于x的第k个最大项目。** 给定一个最大导向的二叉堆，设计一个算法来确定第k个最大项目是否大于或等于x。你的算法应该在与k成比例的时间内运行。'
- en: '*Solution*: if the key in the node is greater than or equal to x, recursively
    search both the left subtree and the right subtree. Stop when the number of node
    explored is equal to k (the answer is yes) or there are no more nodes to explore
    (no).'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：*如果节点中的键大于或等于x，则递归搜索左子树和右子树。当探索的节点数等于k时停止（答案是是），或者没有更多节点可探索时（否）。'
- en: '**kth smallest item in a min-oriented binary heap.** Design a k log k algorithm
    to find the kth smallest item in a min-oriented binary heap H containing *n* items.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小导向二叉堆中的第k个最小项目。** 设计一个k log k算法，找到包含*n*个项目的最小导向二叉堆H中的第k个最小项目。'
- en: '*Solution.* Build a new min-oriented heap H''. We will not modify H. Insert
    the root of H into H'' along with its heap index 1\. Now, repeatedly delete the
    minimum item x in H'' and insert into H'' the two children of x from H. The kth
    item deleted from H'' is the kth smallest item in H.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 构建一个新的最小导向堆H''。我们不会修改H。将H的根插入H''中，同时插入其堆索引1。现在，重复删除H''中的最小项目x，并将x的两个子项从H插入H''。从H''中删除的第k个项目是H中第k小的项目。'
- en: '**Randomized queue.** Implement a `RandomQueue` so that each operation is guaranteed
    to take at most logarithmic time. *Hint*: can''t afford array doubling. No easy
    way with linked lists to locate a random element in O(1) time. Instead, use a
    complete binary tree with explicit links.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机队列。** 实现一个`RandomQueue`，使得每个操作都保证最多花费对数时间。*提示：*不能承受数组加倍。使用链表无法以O(1)时间定位随机元素。相反，使用具有显式链接的完全二叉树。'
- en: '**FIFO queue with random deletion.** Implement a data type that supports the
    following operations: *insert an item*, *delete the item that was least recently
    added*, and *delete a random item*. Each operation should take (at most) logarithmic
    time in the worst case.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有随机删除的FIFO队列。** 实现一个支持以下操作的数据类型：*插入一个项目*，*删除最近添加的项目*，和*删除一个随机项目*。每个操作在最坏情况下应该花费（最多）对数时间。'
- en: '*Solution*: Use a complete binary tree with explicit links; assign the long
    integer priority *i* to the *i*th item added to the data structure.'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：*使用具有显式链接的完全二叉树；为添加到数据结构中的第i个项目分配长整型优先级*i*。'
- en: '**Top k sums of two sorted arrays.** Given two sorted arrays a[] and b[], each
    of length *n*, find the largest k sums of the form a[i] + b[j].'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两个排序数组的前k个和。** 给定两个长度为*n*的排序数组a[]和b[]，找到形式为a[i] + b[j]的最大k个和。'
- en: '*Hint*: Using a priority queue (similar to the taxicab problem), you can achieve
    an O(*k* log *n*) algorithm. Surprisingly, it is possible to do it in O(*k*) time
    but the [algorithm](http://www.sciencedirect.com/science/article/pii/0022000082900484)
    is complicated.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：使用优先队列（类似于出租车问题），您可以实现一个O(*k* log *n*)算法。令人惊讶的是，可以在O(*k*)时间内完成，但是[算法](http://www.sciencedirect.com/science/article/pii/0022000082900484)比较复杂。'
- en: '**Empirical analysis of heap construction.** Empirically compare the linear-time
    bottom-up heap construction versus the naive linearithmic-time top-down heap construction.
    Be sure to comprae it over a range of values of *n*. [LaMarca and Ladner](http://www.lamarca.org/anthony/pubs/heaps.pdf)
    report that because of cache locality, the naive algorithm can perform better
    in practice than the more clever approach for large values of *n* (when the heap
    no longer fits in the cache) even though the latter performs many fewer compares
    and exchanges.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆构建的实证分析。** 通过实证比较线性时间的自底向上堆构建和朴素的线性对数时间的自顶向下堆构建。一定要在一系列*n*值上进行比较。[LaMarca和Ladner](http://www.lamarca.org/anthony/pubs/heaps.pdf)报告称，由于缓存局部性，对于大*n*值（当堆不再适合缓存时），朴素算法在实践中可能表现更好，即使后者执行的比较和交换要少得多。'
- en: '**Empirical analysis of multiway heaps.** Empirically compare the performance
    of 2- 4- and 8-way heaps. [LaMarca and Ladner](http://www.lamarca.org/anthony/pubs/heaps.pdf)
    suggest several optimizations, taking into account caching effects.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多路堆的实证分析。** 实证比较2-、4-和8路堆的性能。[LaMarca和Ladner](http://www.lamarca.org/anthony/pubs/heaps.pdf)提出了几种优化方法，考虑了缓存效果。'
- en: '**Empirical analysis of heapsort.** Empirically compare the performance of
    2- 4- and 8-way heapsort. [LaMarca and Ladner](http://www.lamarca.org/anthony/pubs/heaps.pdf)
    suggest several optimizations, taking into account caching effects. Their data
    indicates that an optimized (and memory-tuned) 8-way heapsort can be twice as
    fast as classic heapsort.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆排序的实证分析。** 实证比较2-、4-和8路堆排序的性能。[LaMarca和Ladner](http://www.lamarca.org/anthony/pubs/heaps.pdf)提出了几种优化方法，考虑了缓存效果。他们的数据表明，经过优化（并调整内存）的8路堆排序可以比经典堆排序快两倍。'
- en: '**Heapify by insertions.** Suppose that you bulid a binary heap on *n* keys
    by repeatedly inserting the next key into the binary heap. Show that the total
    number of compares is at most ~ *n* lg *n*.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过插入堆化。** 假设您通过反复将下一个键插入二叉堆来在*n*个键上构建二叉堆。证明总比较次数最多为~ *n* lg *n*。'
- en: '*Answer*: the number of compares is at most lg 1 + lg 2 + ... + lg *n* = lg
    (*n*!) ~ *n* lg *n*.'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：比较次数最多为lg 1 + lg 2 + ... + lg *n* = lg (*n*!) ~ *n* lg *n*。'
- en: '**Heapify lower bound. (Gonnet and Munro)** Show that any compare-based algorithm
    for building a binary heap on *n* keys takes at least ~1.3644 N in the worst case.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆化下界。（Gonnet和Munro）**证明任何基于比较的二叉堆构建算法在最坏情况下至少需要~1.3644 N次比较。'
- en: '*Answer*: use an information theoretic argument, ala sorting lower bound. There
    are n! possible heaps (permutation of the N integers) on *n* distinct keys, but
    there are many heaps that correspond to the same ordering. For example, there
    are two heaps (c a b and c b a) that correspond to the 3 elements a < b < c. For
    a perfect heap (with n = 2^h - 1), there are A(h) = n! / prod((2^k-1)^(2^(h-k)),
    k=1..h) heaps corresponding to the *n* elements a[0] < a[1] < ... < a[n-1]. (See
    [Sloane sequence A056971](https://oeis.org/A056971).) Thus, any algorithm must
    be able to output one of P(h) = prod((2^k-1)^(2^(h-k)), k=1..h) possible answers.
    Using some fancy mathematics, you can argue that lg P(h) ~ 1.3644 *n*.'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：使用信息论论证，类似于排序下界。对于n个不同键的n!个可能堆（N个整数的排列），但有许多堆对应于相同的排序。例如，有两个堆（c a b和c
    b a），对应于3个元素a < b < c。对于完美堆（n = 2^h - 1），有A(h) = n! / prod((2^k-1)^(2^(h-k)),
    k=1..h)个堆对应于*n*个元素a[0] < a[1] < ... < a[n-1]。（参见[Sloane序列A056971](https://oeis.org/A056971)。）因此，任何算法必须能够输出P(h)
    = prod((2^k-1)^(2^(h-k)), k=1..h)可能的答案之一。使用一些花哨的数学，��可以证明lg P(h) ~ 1.3644 *n*。'
- en: '*Note*: The lower bound can be improved to ~ 3/2 *n* (Carlsson–Chen) using
    an adversary argument; the best-known algorithm for the problem takes ~ 1.625
    *n* compares in the worst case (Gonnet and Munro).'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*注意*：通过对手论证，下界可以改进为~ 3/2 *n*（Carlsson–Chen）；该问题的最佳已知算法在最坏情况下需要~ 1.625 *n*次比较（Gonnet和Munro）。'
- en: '**Stock exchange matching engine.** Continuous limit order book: traders continuously
    post bids to buy or sell stock. A limit order means that a buyer (seller) places
    an order to buy (sell) a specified amount of a given stock at or below) (at or
    above) a given price. The order book displays buy and sell orders, and ranks them
    by price and then by time. Matching engine matches compatible buyers and sellers;
    if there are multiple possible buyers, break ties by choosing the buyer that placed
    the bid earliest. Use two priority queues for each stock, one for buyers and one
    for sellers.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**股票交易撮合引擎。** 连续限价订单簿：交易员不断发布买入或卖出股票的竞价。限价订单意味着买方（卖方）以指定价格或以下（或以上）的价格下达购买（出售）一定数量给定股票的订单。订单簿显示买单和卖单，并按价格然后按时间对其进行排名。匹配引擎匹配兼容的买家和卖家；如果存在多个可能的买家，则通过选择最早下单的买家来打破平局。为每支股票使用两个优先队列，一个用于买家，一个用于卖家。'
- en: '[Electronic Trading in Financial Markets](http://faculty.haas.berkeley.edu/hender/ITpro.pdf).'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[金融市场电子交易](http://faculty.haas.berkeley.edu/hender/ITpro.pdf)。'
- en: '**Random binary heap.** Suppose that you fill an array of length n with a random
    permutation of the integers 1 to n. What is the probability that the resulting
    array is a minimum-oriented binary heap for n = 5 and 6?'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机二叉堆。** 假设您用1到n的整数的随机排列填充长度为n的数组。对于n = 5和6，生成的数组是最小定向二叉堆的概率是多少？'
- en: '*Solution*:1/15 and 1/36, respectively. Here is a [nice discussion](http://11011110.livejournal.com/326418.html)
    of the problem.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：分别为1/15和1/36。这里有一个[很好的讨论](http://11011110.livejournal.com/326418.html)。'
