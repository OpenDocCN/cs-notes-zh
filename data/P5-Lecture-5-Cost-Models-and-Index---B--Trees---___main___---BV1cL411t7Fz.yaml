- en: P5：Lecture 5 Cost Models and Index + B+ Trees - ___main___ - BV1cL411t7Fz
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P5：第五讲 成本模型和索引 + B+ 树 - ___main___ - BV1cL411t7Fz
- en: say lecture of 186。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 说到186讲座。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_1.png)'
- en: So today we're going to talk about cost models and indexing。 And before that。
    I'd love to have you guys keep using the chat， window， by the way。 I think we
    got a lot of excellent questions in the chat。 And if you even want to crack some
    jokes there， I mean， that's all we find too。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们将讨论成本模型和索引。在此之前，我希望大家继续使用聊天窗口，顺便提一下。我认为我们在聊天中收到了很多很棒的问题。如果你们甚至想在那里开些玩笑，我觉得那也很好。
- en: as long as it's appropriate， for this class， that's OK。 So yeah。 and then I
    think we might be still using Piazza， this lecture or not， either way。 Me good。
    I want to first consider it up。 We'll create a thread soon。 OK， either way。 Yeah。
    so feel free to ask questions there as well。 I mean， or we might actually move
    you over there。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 只要这对这门课来说是合适的，那就没问题。所以，是的。我认为我们可能仍然会使用Piazza进行这次讲座，无论如何。没问题。我先考虑一下。我们很快会创建一个讨论帖。好吧，无论如何。是的，所以也可以随时在那里提问。我的意思是，或者我们可能会将你们移到那里去。
- en: if it kind of becomes the longest question， just to make sure that we don't
    lose any of the threats。 And again， if you feel comfortable， please try to turn
    on your video。 It's nice to see your faces。 And also， it's nice to see when someone
    actually nods， and seemingly hoping to be--。 we're basically hoping that you're
    actually， getting the material。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个问题变成了最长的问题，确保我们不会丢失任何信息。如果你觉得舒服，请尽量开启视频。看到你们的面孔很好。而且也很高兴看到有人点头，似乎在希望——我们基本上希望你们能够理解材料。
- en: And so we can get some visual cue。 That would be awesome。 And of course， if
    we try to crack jokes。 then it's always good to have someone actually smile， right，
    a little bit。 So cool。 OK。 so let's start it， right？ So let's get started。 So
    last time that Ditio was basically。 talking about different types of file organization，
    right？ So that's where we are。 So earlier。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以得到一些视觉提示，那将是很棒的。当然，如果我们尝试开玩笑，那么最好有人能露出笑容，对吧，稍微笑一笑。所以很酷。好吧，那我们开始吧，对吧？让我们开始吧。所以下次Ditio基本上是在讲不同类型的文件组织方式，对吧？这就是我们的位置。所以早些时候。
- en: I mentioned in the last lecture， about disk space management， and then we also。
    covered file organization。 So as a recap， right？ So last time， we were talking
    about different ways。 to organize tuples in a file。 One of the examples is a heap
    file， basically。 as an unordered collection of records or tuples。 And then， like
    you actually remember。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上次讲座中提到过磁盘空间管理，之后我们也讨论了文件组织方式。所以回顾一下，对吧？上次我们讨论了如何在文件中组织元组的不同方法。其中一个例子是堆文件，基本上是一个无序的记录或元组集合。然后，就像你们记得的那样。
- en: from the disk lecture， these devices， that we talked to only expose， read， and
    write。 as the only API， right？ So basically， that's what we'll be working with。
    So why am I bringing these two points up？ Well， because today， we actually。 want
    to ask the question of what is the cost。 Cost in terms of when we try to actually
    do something。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘讲座中，我们讨论过的这些设备，仅仅暴露了读和写，作为唯一的API，对吧？所以基本上，这就是我们将要使用的内容。那么，我为什么要提这两点呢？嗯，今天我们实际上想要问的问题是：成本是什么？成本是指当我们尝试做一些操作时的成本。
- en: databases， right？ So that's what I mean when I say， like， cost in terms of doing
    insertions。 deletions， or modifications， or even something as simple as just fetch
    a record。 by a particular ID or a particular attribute， right？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库，对吧？所以当我说“插入、删除或修改的成本，甚至仅仅通过特定ID或特定属性获取记录的成本”时，这就是我所说的意思，对吧？
- en: And we also want to look into what happens when we try， to scan all the records
    in terms of cost。 Why do we care about cost？ Well， for one thing， right？ As you
    also remember， from the last lecture。 there are actually many ways that we， can
    use to store tuples in a file， right？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想看看当我们尝试扫描所有记录时，成本会是什么样子。为什么我们关心成本？嗯，首先，对吧？你们也记得上次讲座的内容。实际上有很多方法，我们可以用来存储文件中的元组，对吧？
- en: Do people remember what else did we actually cover besides， keep file in the
    last lecture？
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 人们还记得我们上次讲座除了最后提到的保持文件，我们实际上讲了什么吗？
- en: This is a quiz。 No， I'm kidding。 Somebody？ Yes， sort of files， right？ OK。 so
    that's like another one of them， right？ So， you know， this is just one of the
    other options。 So besides keep files， they're sort of files。 And then， like， you
    know。 today and also in the next lecture， we will also talk about clustered files
    and indexes as well。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小测验。不，我开玩笑的。有人吗？是的，某种文件类型，对吧？好的。所以这是其中的另一个，右？所以，你知道，这只是其他选项之一。所以除了保留文件之外，还有另一种文件类型。然后，像，今天以及下一讲，我们还将讨论聚簇文件和索引。
- en: So we have all these different ways to store data。 Then it makes sense for us
    to try to figure out。 like， you know， what is the best way， right， to do it， right？
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有这么多种存储数据的方式。那么我们试图弄清楚，像，知道什么是最好的方法，对吧？这是有意义的。
- en: And this is usually optimized against a given query workload。 Because if we
    don't know what kind of queries or what kind。 of operations will be invoking on
    these different types of files。 then it's really hard for us to compare each one
    of them， right？ So in the context of this class。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这会针对给定的查询工作负载进行优化。因为如果我们不知道会在这些不同类型的文件上执行什么样的查询或操作，那么我们真的很难比较它们每一个，对吧？所以在本课程的背景下。
- en: we're always， going to be talking about， like， you know， let's say we want to
    do insertion。 Let's say we want to do， like， you know， scanning of all the records
    or something， right？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是会讨论，比如说，我们想做插入操作。比如说，我们想做，像，扫描所有记录之类的事情，对吧？
- en: And then we're going to talk about later on， but how do we actually get that
    kind of workflow information。 right？ Or how do we know that we want to run， like，
    you know， scans and， like， you know， why not。 like， you know， find a particular
    tuple， for example。 So for a big picture， right。 in terms of talking about a cost，
    so we basically want to have a way to estimate the cost associated。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们稍后会讨论，但我们如何获得那种工作流信息，对吧？或者我们怎么知道我们要运行，像，你知道的，扫描，和，像，你知道的，为什么不呢？比如说，找到一个特定的元组。所以从大体来看，对吧。在谈论成本时，我们基本上是想找到一种估算与之相关的成本的方式。
- en: with each of these types of data access。 And again， right， data access， in this
    case。 mean anything from finding and inserting an individual record。 deleting
    or modifying or even or basically looking。 up different types of data that we
    have stored in the files。 OK。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种数据访问类型，再说一次，数据访问，在这种情况下。意味着从查找和插入单个记录，到删除或修改，甚至是基本上查找我们存储在文件中的不同类型数据之类的任何操作。好吧。
- en: And we just want big picture estimates， right， because in this case。 we're not
    trying to drill down into， like， you know， the tiny， like， you know， most accurate
    costs。 right？ We're not trying to measure against， like， you know， external to
    millisecond level。 We're really just trying to get a brief estimate such。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想要大致的估算，对吧？因为在这种情况下。我们不是想深入到，像，你知道的，最精确的成本。对吧？我们不是在与，像，外部毫秒级别进行比较。我们实际上只是想得到一个简短的估算，比如。
- en: that we can use that to decide which type of files should we be using， when
    we try to store data。 for example。 So， but then it still makes sense to be a little
    bit of discipline， right？
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来决定我们应该使用哪种类型的文件，当我们尝试存储数据时。例如。那么，尽管如此，保持一些纪律性也是有意义的，对吧？
- en: So what do we mean by that？ So by that， we mean we want to be able to clearly
    state the type。 of assumptions that we want up front and then try， to have a systematic
    way to estimate costs。 And this actually is going to form the foundation for query
    optimization， which will take place in。 I guess， in about two weeks when we talk，
    about， like。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们说的是什么意思呢？我们意思是，我们希望能够清楚地陈述我们事先希望做出的假设类型，然后尝试以一种系统化的方式来估算成本。实际上，这将为查询优化打下基础，而查询优化将在大约两周后，当我们讨论时进行。
- en: how to optimize queries given all these different types of files， and operations
    and whatnot。 And。 you know， as I said， right， we need a way， we're ready to be
    able to compare them before deciding which one is the best。 So that's what we
    are going to be focusing on for the first half of this class today。 Does that
    make sense？ Show of hands。 Thumbs up？ Yes？ [ Inaudible ]， No？ Cool。 Okay。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在所有这些不同类型的文件和操作等情况下优化查询。然后，你知道，正如我所说的，对吧，我们需要一种方法，准备好在决定哪个最好之前进行比较。所以这是我们今天这堂课前半部分的重点。明白吗？举手。竖大拇指？是的？[听不清]，不？酷。好的。
- en: So now let's talk about， like， let's be a little bit quantitative， right？
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在我们来谈谈，像，稍微定量一些，对吧？
- en: What do we mean by a cost model？ So again， we're trying to get some rough estimate
    of the cost associated。 with， like， any of these data operations on the files。
    So let's be a little bit mathematical about this。 So we're going to define three
    different values here。 So B stands for the number of data blocks that we have
    in a file。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说的成本模型是什么意思？所以我们再次尝试对与这些数据操作相关的成本进行粗略估算。所以我们来稍微做点数学。我们将在这里定义三个不同的值。B代表文件中数据块的数量。
- en: So we already covered the concept of blocks or pages， right， in the last lecture。
    And then we're going to use the capital letter R to represent the number of records。
    that we have in each of the blocks。 And then D as the average time that it takes
    to read or write to the disk blocks。 So these are really rough estimates， right？
    For instance， like， you know。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在上一节课已经讲过了块或页面的概念。然后我们将使用大写字母R来表示每个块中记录的数量。D则表示读取或写入磁盘块的平均时间。所以这些只是粗略估计，对吧？例如，如果我们要……
- en: depending on what type of files that we're dealing with。 the number of records
    per block can be different， right？ So， but for now we're just kind of like。 you're
    using this as kind of like a broad overview， or broad way of computing costs as
    an estimate。 So this is the picture to remind you， right？ So we are now going
    to represent each of these files here in black。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们处理的文件类型，每个块的记录数可能不同，对吧？所以，现在我们只是把它作为一个大致的概览，或者说是计算成本的广泛方法估算。所以这张图是用来提醒你，对吧？所以现在我们要在这里用黑色表示每个文件。
- en: And then we'll basically have number of different blocks or pages per file。
    And then each of these blocks basically consists of records， right？ So this is
    as a reminder。 So our goal here is to be able to compute the average case for
    these different types。 of workloads that we'll talk about。 Workloads again， right？
    Talking about insertions， deletions。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每个文件基本上会有不同数量的块或页面。每个块基本上由记录组成，对吧？所以这是一个提醒。所以我们的目标是能够计算这些不同类型工作负载的平均情况。再次强调，工作负载，对吧？我们在谈论插入、删除操作。
- en: modifications or scanning or search for particular records。 What are the assumptions？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 修改、扫描或搜索特定记录。假设是什么？
- en: So now we'll completely ignore like， you know， the difference between sequential
    and random， IO。 So ignore what I said， like in the last lecture about like， oh，
    there's actually this like。 extra benefit if you are reading or writing things
    sequentially。 Throw that away for now。 We're also going to completely ignore anything
    about caching or prefetching or anything like， that。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们完全忽略了顺序和随机IO之间的差异。所以忽略我在上节课说的内容，例如，哦，如果你是顺序读写，确实会有额外的好处。暂时抛开这个。我们也会完全忽略任何与缓存、预取等相关的内容。
- en: So we'll assume that we'll always need to bring things into memory fresh from
    the disk。 So no cache。 we're not recording， we're not prefetching anything。 And
    then we're also going to completely ignore any costs associated with actually
    performing。 the operation， right？ So for example， if we want to like， you know。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们假设每次都需要将数据从磁盘加载到内存中。没有缓存，我们不做记录，也不做预取操作。然后我们也会完全忽略与执行操作本身相关的成本，对吧？例如，如果我们想要……
- en: fetch a particular tuple or record， we need， to check with the thing that we
    brought into memory。 actually satisfy our criteria， right？ So and then that definitely
    like， you know， cost something。 right？ It's not free， right？ So， you know， running
    CPU computation actually takes time。 But for now。 let's just completely ignore
    that。 And then like， you know。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 获取某个特定的元组或记录，我们需要检查我们加载到内存中的内容是否符合我们的标准，对吧？所以这肯定会有成本，对吧？它不是免费的，对吧？所以，运行CPU计算确实需要时间。但现在，我们暂时完全忽略这一点。然后……
- en: we will always assume that data needs to be brought into memory before， they
    can be operated on。 So we cannot operate things directly on the disk。 Everything
    has to be brought into memory before we can operate on them。 And likewise， right？
    That also means if we make modifications， for example， we update anything。 then
    we also， need to write it back to the disk afterwards。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终假设数据必须先加载到内存中，才能进行操作。所以我们不能直接在磁盘上操作数据。一切必须先加载到内存中才能操作。同样，这也意味着，如果我们做了修改，比如更新了某些内容，我们也需要之后将其写回磁盘。
- en: So that is going to be a trend in all of these。 And we claim that this is good
    enough to just show us different trends for different types。 of files。 And we
    think this is too easy for you。 We visit these assumptions after the class， right？
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是所有这些内容的一个趋势。我们声称，这已经足够好，能够展示不同类型文件的不同趋势。我们认为这对你们来说太简单了。我们会在课后重新审视这些假设，对吧？
- en: And then I challenge you to like， you know， try to eliminate one of these assumptions
    and。 do the calculations that I'll show you in the next few slides and then you'll
    get a sense。 of how easy or how difficult this will be。 Okay。 So more assumptions
    about the type of operations that we're working with。 So for now， we're just going
    to assume that we're just going to insert a single record。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我挑战你们，像你们知道的，试着去消除这些假设之一，然后做出我将在接下来的几张幻灯片中展示的计算，然后你会大致了解这将有多容易或多困难。好吧。所以关于我们正在处理的操作类型的更多假设。现在，我们只假设我们将插入一条记录。
- en: or delete a single record every single time。 So if we're inserting a bunch of
    records。 we'll do this multiple times。 You know， you guys will know the truth。
    And then for like， you know。 finding records， we're going to assume that there's
    only one， exact record that we will match。 So you might be looking for， let's
    say， like， you know， the student record with student。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者每次都删除一条记录。所以如果我们插入一堆记录，我们会多次执行这个操作。你们会知道真相的。然后对于像，嗯，查找记录的操作，我们假设只有一条完全匹配的记录。所以你可能在查找，假设是，像，嗯，某个学生的记录。
- en: ID equals to something， right？ Or you might be looking for a sailor's， right？
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ID等于某个值，对吧？或者你可能在找一个水手的记录，对吧？
- en: We'll say ID equals to something else。 So for now。 we are just assuming that
    there's only one record that will match， even though， in reality。 there can be
    multiple。 And then for heap files， we're just going to assume that we're always
    going to append。 to the end。 So that's what we also talked about in the last lecture。
    And for sort of files。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说ID等于其他某个值。所以现在，我们只是假设只有一条记录会匹配，尽管实际上可能有多条记录。而对于堆文件，我们假设我们总是会将记录追加到末尾。这也是我们在上节课中讨论过的内容。对于排序文件也是如此。
- en: we're always going to assume that we sort according to the search， key。 So think
    of this as like the thing that we're searching over。 The SIDs。 the both IDs and
    all that other stuff。 And as I said， right。 if you want a bigger challenge or
    you think this is too easy for， you， I mean， like， you know。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是假设我们会根据搜索关键字进行排序。可以把它想象成我们正在搜索的内容。比如SID，ID以及其他相关信息。正如我所说的，如果你想要更大的挑战，或者觉得这对你来说太简单，我是说，你知道的。
- en: feel free to try to relax these assumptions and then we work。 the kind of computation
    that we'll be going through。 And then you'll see， like， you know。 you'll get a
    deeper understanding。 And also big hints， right？ This might be on the test。 Okay。
    Okay。 So let's go through these operations， right？ So like， you know。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以尝试放宽这些假设，然后我们将进行相关计算。然后你会看到，像，嗯，你会有更深的理解。而且还有很大的提示，对吧？这可能会出现在考试中。好吧，好吧。现在我们来看看这些操作，嗯？所以，像你知道的。
- en: this is just how we're going to represent things for the next couple， of slides。
    So heap file。 as you recall， is unordered， right？ So now we're basically seeing
    a bunch of different pages and then。 like， you know， for， now， we just assume
    the records are just numbers。 So you see that in the heap file case， this is completely
    unordered versus in this case。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们接下来几张幻灯片中要展示的内容。所以堆文件，正如你们记得的，是无序的，对吧？所以现在，我们基本上看到了一堆不同的页面，然后像你知道的，现在我们假设记录只是数字。所以在堆文件的情况下，你会看到这是完全无序的，而在这种情况下则不一样。
- en: since we're only storing a number or sort of file， we're just going to be just
    sorting。 by that particular number。 So。 And then just as a reminder， right？ So
    in this case。 we have five different blocks。 We have two records per block and
    then we're just going to assume some number for D。 which， is the time that it
    takes to read and write。 Okay。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只存储一个数字或者排序文件，我们就会根据那个特定的数字进行排序。所以。然后只是提醒一下，嗯？在这种情况下，我们有五个不同的块。每个块有两个记录，然后我们假设某个数字D，即读取和写入所需的时间。好。
- en: So here's kind of here's the type of table that we want to be able to fill in，
    like， you， know。 within the next 15， 20 minutes。 Okay。 So we have two different
    operations that we want to do。 And then we want to compute how long it would actually
    take in terms of these parameters， here。 Oh。 okay。 First one， this is a woman。
    Let's say we want to scan all the records， right？
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们想要填充的表格类型，你知道的。在接下来的15到20分钟内。好的。所以我们有两种不同的操作要做。然后我们想要计算在这些参数下，实际需要多少时间。哦，好的，第一个，这是一位女士。假设我们想扫描所有记录，对吧？
- en: So just to illustrate， right？ So the first one， when we are trying to go through
    the heap file。 right， you can basically， see the red bar here。 I'm just representing
    like a finger， right？
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以只是为了说明，对吧？第一个，当我们尝试浏览堆文件时，你基本上可以看到这里的红色条。我只是代表一个手指，对吧？
- en: We're basically scanning through everything。 And then for the sort file。 we're
    also scanning through everything as well。 So in this case。 what do you guys think
    will be the cost in terms of the number of this。 a number of data blocks that
    we'll need to read。 Okay。 Great。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是在扫描所有内容。然后对于排序文件，我们也在扫描所有内容。所以在这种情况下，你们觉得我们需要读取的这些数据块数量的成本是多少？好的，太棒了。
- en: So I'm seeing the feel free to just yell as well， right？ Or you can also type
    in the chat window。 So I'm saying people's death， great。 Saying that like， you
    know。 we'll basically read through everything， right？ So there's no escape。 We
    want to scan everything。 So obviously you need to read all the blocks， right？
    No escape to it。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我看到你可以随意大喊，是吧？或者你也可以在聊天窗口里输入。所以我在说人们的死亡，很棒。就是说，像是，你知道的。我们基本上会浏览所有的内容，对吧？所以没有逃避的余地。我们要扫描所有内容。所以显然你需要阅读所有的块，对吧？没有逃避的余地。
- en: So we'll basically be reading the number of data blocks。 And then since each
    of them requires D。 right， they have average time to read them， then， the total
    cost here is just going to be B times D。 By the way， we're just using time as
    a unit of measurement here， as the so-called cost， right？
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们基本上会读取数据块的数量。然后由于每个块都需要D，对吧，它们的平均读取时间，那么，总成本将是B乘以D。顺便说一下，我们这里只是将时间作为测量单位，作为所谓的成本，对吧？
- en: So if you're running things on AWS， for instance， we might actually care more
    about like money。 right？ The amount of dollars that you need and also like， you
    know， do the operation， right？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你在 AWS 上运行这些操作，例如，我们可能更关心的是钱，对吧？你需要多少美元，以及如何执行这个操作，对吧？
- en: But for now， for simplicity， we're just going to use time。 Any questions about
    this one so far？
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了简化起见，我们现在只使用时间。到目前为止，有什么问题吗？
- en: This is the simplest one。 Okay。 Not then let's go on。 So now let's say I want
    to do equality search。 right？ Okay。 What about equality？ What is equality search，
    right？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的情况。好的。然后我们继续。那么现在假设我想做等值查找，对吧？好的。那么等值查找是什么呢？
- en: So let's say I would like to find the record with the number eight in it， right？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以假设我想找一个包含数字八的记录，对吧？
- en: So I hope I convinced you that this is the one that we are trying to look for，
    right？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我希望我已经说服你们，这是我们要寻找的内容，对吧？
- en: And not it works， we're trying to read the final page in this file here， right？
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它是怎么工作的，我们试图读取文件中的最后一页，对吧？
- en: So then one of the students， Ankit says， can we slow down a tiny bit？ So Ankit。
    do you want to ask a question？ Yeah。 Was there something that was not clear？ It's
    clear。 I just need to write everything down。 Oh， okay。 Sorry。 Okay。 Okay。 All
    right。 So going back to this。 right？ So okay。 I see an asking a question about
    average case or worst case。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有个学生，安基特说，能不能稍微慢一点？安基特，你想提问吗？是的，有什么不清楚的吗？很清楚。我只是需要把所有的内容写下来。哦，好吧。抱歉。好的。好的。那么回到这个，对吧？所以好的，我看到有人在问关于平均情况还是最坏情况的问题。
- en: So we actually care more about average case in this case。 So you see why in
    just a second。 Okay。 So going back to this， right？ So we would like to fetch the
    record with the number eight in it。 So what do we do in the heap file case？ I
    mean， we just scan everything， right？ I mean。 there's no other way out。 I mean，
    that's the， that's the way that's we basically need to scan it and we find it。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下，我们实际上更关心的是平均情况。稍后你会明白为什么。好的，回到这个，对吧？所以我们想要获取一个包含数字八的记录。那么在堆文件的情况下我们该怎么做呢？我的意思是，我们只能扫描所有内容，对吧？没有别的办法。我的意思是，这是唯一的方式，我们基本上需要扫描它然后找到它。
- en: And let's try to actually do the average K analysis。 So first of all。 what do
    you guys think is the worst case here， right？ The worst case is the case where
    what？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做一下平均K分析。首先，你们认为这里的最坏情况是什么？对吧？最坏情况是怎么样的？
- en: When eight is at the very end。 Yeah。 When eight is at the very end， right？
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当八号页面在最后时。对，当八号页面在最后时，对吧？
- en: So basically we just need to scan through everything。 So the cost obviously
    is just going to be B times D as well， right？
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，我们需要扫描所有内容。所以显然，成本就是B乘以D，对吧？
- en: But that's actually go for the average here， right？ Because like， you know，
    in the worst case。 everything is kind of like， you need to read， everything。 So
    not that interesting。 So that also goes back to the question of why are we caring
    more about the average case， here。 So what is the average case， right？ So let's
    introduce a little bit more math。 So first of all。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，这就是这里计算平均值的方法，对吧？因为在最坏的情况下，所有的内容都像是我们需要阅读的内容。所以没什么特别有趣的。那么这也回到我们为什么更关心平均情况的问题。那么，平均情况是什么呢？对吧？所以我们再引入一点数学。首先。
- en: I'm going to say like P of I is the probability that a particular key， right。
    or record in this case is actually located in a particular page。 So we have B
    pages here。 Every one of them is like fair equal chance of like， you know， having
    the record that we're。 trying to look for。 So the probability that is that the
    thing that we're looking for is actually on the page on。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我将说P(I)是某个特定的键，或者说记录，出现在特定页面的概率。我们这里有B页，每一页都有同等的概率包含我们要找的记录。所以，所寻记录在某页的概率就是我们要找的内容在该页的概率。
- en: page number I， right， for instance， it's just one over B equal probability across
    other， pages。 And then we're going to call T of I to be the number of pages that
    we actually need to， touch。 right， or read in order to get to page number I。 So
    for the first page。 then we just read one of the pages and we get to it。 For a
    second page， we need to read two pages。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 页面编号I，比如说，它只是B的倒数，表示各个页面的概率相同。然后我们定义T(I)为我们实际需要触及或阅读的页面数，以便达到第I页。对于第一页，我们只需要读取一页就能到达。对于第二页，我们需要阅读两页。
- en: right， because we always start from the very， left or the beginning of the file。
    And then if we need to go all the way to the last， then we need to read everything。
    So what is the average here？ So the average is just going to be an expected value。
    You might remember from your math class， right？ It's just going to be multiplying
    the number of pages that we need to read if the record。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对，因为我们总是从文件的最左边或开头开始。如果我们需要一直读到最后，我们就需要读取所有内容。那么这里的平均值是什么呢？平均值实际上就是一个期望值。你可能还记得你在数学课上学过，对吧？它就是将我们需要读取的页面数与记录相乘。
- en: actually is on the I've page by the probability that the thing or the record
    that we're actually。 looking for is actually in the I've page。 So it's a concrete
    example， right。 in this case we're looking for the fifth page here， right， the
    last page。 So the number of pages that we need to touch is in this case going
    to be five。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们正在寻找的是第五页，对吧？最后一页。所以我们需要触及的页面数是五。
- en: And then the probability is going to be one over B， right， because or one over
    a one fifth， I guess。 Oops。 In this case， right， so that's the probability。 So
    this basically gives us one of the terms。 right， and the expected value here。
    But then we need to sum over all the possibilities， right。 because the record
    that we're looking， for could have been the first page or the second page。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后概率将是B的倒数，对吧？因为是1/5的概率，我猜。哦，这种情况，对吧。所以这就是概率。这个基本上给了我们其中的一个项。对吧，这是期望值。但接下来我们需要对所有可能的情况求和，因为我们要找的记录可能是第一页，也可能是第二页。
- en: so and so forth。 So that's why we are summing everything from one all the way
    up to B。 where B as we recall， is a number of pages。 Does that make sense？ Okay。
    so if you actually crank out the math， right， so like， you know， T's of I is just，
    like， you know。 I， right， because for the fifth page， we read， like， you know，
    we need。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如此类推。所以这就是为什么我们需要从1加到B进行求和。我们记得，B是页面的数量。这样理解吗？好，如果你真正计算这个数学问题，T(I)就等于I。因为对于第五页，我们需要读取，嗯，我们需要。
- en: to touch five different pages。 If it was a 10 page， then we need to touch 10
    different pages。 So the first time here should be self explanatory， and then I
    over B is just like you're repeating。 this number here that I talked to you earlier。
    And then if I did my math correctly。 this turns out to be this exact expression，
    which。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 需要翻阅5页。如果是10页，那我们就得翻阅10页。所以第一次应该不言自明，然后I over B就像是你在重复。我之前和你说过的这个数字。然后如果我计算没错，这个结果正是这个表达式。
- en: by engineering approximation is basically going to be B over two。 So this actually
    matches our intuition， right， what is it saying is that， like， you know。 on average，
    we basically need to go through， like， you know， cost wise， be over two in order。
    not to find， like， you know， the record that we want to look for。 Or in other
    words， like， you know。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 工程近似值基本上是B除以2。所以这实际上符合我们的直觉，对吧，意思是，像你知道的，平均来说，我们基本上需要翻阅，大约是B除以2的页数，才能找到我们想要的记录。换句话说，像你知道的。
- en: we pretty much needs to go through half of the file。 in order to actually find
    the thing that we wanted。 Okay。 By the way。 if you actually want to get the time
    out of it， right， then we basically measured。 that we basically multiply this
    number by D， but I'm just not showing you here for simplicity。 Okay。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上需要翻阅文件的一半才能找到我们想要的东西。好吧，顺便说一下，如果你真想得到具体时间的话，我们基本上是通过把这个数字乘以D来计算的，不过我为了简化没有在这里展示。
- en: So this B over two numbers going to show up again and again， right， so make
    sure that you。 understand this， right？ So， you know， just to repeat， and on average。
    we're basically expecting we need to go through， half of the file in order to
    find the thing that we want。 Okay。 So let's go through another example。 So in
    this case。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个B除以2的数字会一遍又一遍地出现，对吧，确保你理解这一点。对吧？所以你知道，重复一下，平均而言，我们基本上预计需要翻阅文件的一半才能找到我们想要的东西。好吧。那么我们来看看另一个例子。所以在这种情况下。
- en: we have to sort a file which is likely more tricky， right？
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须排序一个文件，这可能更复杂，对吧？
- en: How are we going to find the number eight here， right？
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们怎么找到数字8呢，对吧？
- en: So we're basically going to start from the middle because we can use binary
    search， right？ I mean。 this is sorted。 So you guys remember from 61 B， right，
    this algorithm called binary search。 So we don't have to start from the middle。
    We can actually start in the， sorry。 we don't have to start from the very left
    or the beginning， of the file。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们基本上从中间开始，因为我们可以使用二分查找，对吧？我是说，文件已经排好序了。所以你们还记得61 B吗？那个算法叫二分查找。所以我们不必从最左边开始。我们实际上可以从中间开始，抱歉，我们不需要从文件的最左边或开始处。
- en: we can actually start somewhere in the middle because we're going to use binary，
    search for it。 And as a reminder， right， the way that it works is we start from
    the middle and then we choose。 which way to go。 And in this case， since eight
    is， is greater than， you know， the middle page here。 right？ So we're going to
    basically go to the right。 So in the next step。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以从中间某个地方开始，因为我们将使用二分查找。提醒一下，二分查找的工作原理是，我们从中间开始，然后选择。我们要走哪个方向。在这种情况下，由于8比中间页要大，对吧？所以我们基本上会往右走。那么接下来的步骤是。
- en: you'll see that we are moving to the right， right？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们正在向右移动，对吧？
- en: And then we'll basically find the one that we want， right？ And that's it。 So
    now let's first figure out what is the worst case here。 The worst case here is
    basically we need to touch every single page in order to find the， page。 in order
    to find the record that we want。 And then from 61 B， you remember that， like，
    you know。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们基本上会找到我们想要的那个，对吧？就这样。那么现在我们先弄清楚这里的最坏情况是什么。这里的最坏情况基本上是我们需要翻阅每一页才能找到我们想要的记录。然后从61
    B开始，你记得吧，就像，你知道的。
- en: the number of jumps that we need， to do is basically lock base to be。 But then
    now what about the average case here， right？ The average case here， again， is
    like。 you know， on average， how many pages do we actually， expect to touch？ Is
    that also lock base to be。 right？ So let's actually try to go through this first
    argument that pictorically。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的跳跃次数基本上是以B为底的对数。但那么，平均情况如何呢，对吧？这里的平均情况再次是，像，知道的，平均来说，我们预计翻阅多少页？它也是以B为底的对数，对吧？那么我们实际上尝试通过这个第一个图示来解释。
- en: So here I have symbolized each of these records， right， from the previous page
    as different， colors。 just as a demonstration。 And you'll notice that we actually
    now have more records than the last page。 right？ So don't worry about that for
    now。 This is just for illustration purposes。 So again。 in binary search case，
    we basically start from the page in the middle。 So in this case。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，我已经用不同的颜色表示了每个记录，就像上一个页面一样，只是作为示范。你会注意到我们实际上现在有比上一页更多的记录，对吧？所以暂时不用担心这个，这只是为了说明。再一次，在二分查找的情况下，我们基本上是从中间的页面开始。所以在这种情况下。
- en: the page here in blue。 And then we basically choose to go either left or right，
    right？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色页面在这里。然后我们基本上选择向左或向右跳，对吧？
- en: Everything on the right， on the record that we're looking for。 So let's say
    we're going to the right。 So then we basically move to the teal page， right？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的所有内容，记录我们要找的。所以假设我们要向右跳。那么我们基本上就移动到青绿色页面，对吧？
- en: Because we start from here。 So the range is basically the range of values。 the
    range of pages that we have here to the， right of the blue page。 And then we just
    choose to basically just jump to the middle of that whole range。 Yeah？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们从这里开始。所以范围基本上是右边的页面范围，页面值的范围。然后我们就选择基本上跳到那个整个范围的中间，对吧？
- en: And then we go the same process again， right？ Unless this is basically the page
    that we're looking for by just by now trying to go through。 the rest of the pages
    here， right？ So the right of this， let's say。 and then we'll also jump to the
    middle。 So now we jump over to the white page， for instance。 and then we see if
    the record that， we want is actually in the white page， right？
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再进行一遍相同的过程，对吧？除非这基本上就是我们正在寻找的页面，通过现在尝试遍历其他页面来找到的页面，对吧？比如说，接下来我们要做的是右边的页面，然后我们也会跳到中间。现在我们跳到白色页面，例如，接着我们看看我们想要的记录是否实际上在白色页面上，对吧？
- en: And then if it's not， then we jump again， right？ And in this case。 we basically
    went all the way down to the leaf。 So now we basically ended up on the black page。
    assuming that we go left from the white one。 So hopefully this is a reminder，
    right？
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果没有，我们再跳一次，对吧？在这种情况下，我们基本上是一路跳到叶子节点。所以现在我们基本上到达了黑色页面，假设我们从白色页面向左跳。希望这能成为一个提醒，对吧？
- en: From 61B in terms of like， you know， how we actually do binary search in terms
    of a number。 of page blocks here。 So if B is the number of data blocks。 then I
    claim that the average number of reads of， pages that we wanted is this humongous
    expression。 So you might ask， like， you know， what is going on here， right？ So
    let me explain。 So again， right。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从61B开始，关于我们如何在页面块的数字上做二分查找。所以如果B是数据块的数量，那么我声称我们想要的页面的平均读取次数是这个庞大的表达式。所以你可能会问，发生了什么，对吧？让我来解释。所以再一次，对吧。
- en: we have B number of data blocks that I'm showing you on the page here。 So it's
    equally likely that the value that we look， the record that we're looking for。
    is located in any of these pages。 So that's why， again， right， it's one over B
    is the probability。 But what about the cost， right， that we need in order to access
    that particular page？
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有B个数据块，我在页面上展示给你们。所以查找我们需要的记录，位于这些页面中的任何一个的可能性是一样的。因此，这就是为什么概率是1除以B。但成本呢？为了访问那个特定页面，我们需要的成本是多少？
- en: So unlike in the heap file， right， where it's just like， you know， it's just
    a number of。 pages to the left， right？ So in the heap file cases， everything is
    unordered。 So we're just reading the fifth page from the start， then the cost
    is just going to be， five。 But in this case， it's not， right， because of the fact
    that we are now jumping around in， the file。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不同于堆文件，对吧，它就像是，知道吗，它只是左侧的若干页面，对吧？所以在堆文件的情况下，一切都是无序的。我们只是从开始读第五个页面，那么成本就是五。但在这种情况下，不是的，对吧，因为我们现在在文件中跳来跳去。
- en: So for the first page， for instance， for the blue page， right， the cost associated
    with that。 is just one， right？ Because we just need one single discrete。 we can
    bring that into memory and then we can， we and then we can just check， right。
    where the record is actually located there。 But then for the second， for the second
    one， right。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以以第一个页面为例，对于蓝色页面，成本就是一，对吧？因为我们只需要一个单独的页面，我们可以把它载入内存，然后我们就能检查，记录实际上位于哪里。但对于第二个，第二个页面呢？
- en: so the one in teal here， right， how， many steps do we actually need to go through
    and also get to that page？
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个青绿色的页面上，对吧，我们实际上需要经过多少步骤才能到达那个页面？
- en: Raise your hand。 What do you guys think？ Or type it？ Two， right？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 举手。你们觉得怎么样？或者打字告诉我？两个，对吧？
- en: Because we need to first go to the blue one and then now we jump to the teal
    one， right？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要先去蓝色的页面，然后现在我们跳到青色的页面，对吧？
- en: So therefore， the number of pages that we need to go through is actually two。
    But then remember。 there are actually two teal pages here， right？ So we can have
    jumped to the left or we could have jumped to the right。 right， from the blue，
    one。 So therefore， the probability that we actually will get to one of that。 that
    we actually get， to the page that we want is actually one over B times two。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要经过的页面数实际上是两个。但请记住，这里实际上有两个青色的页面，对吧？所以我们可以跳到左边，或者我们可以跳到右边，对吧？从蓝色页面开始。所以因此，我们实际上到达我们想要的页面的概率是1除以B乘以2。
- en: because there's actually two pages， that is possible， right？ That where the
    record actually resides。 And then each one of them requires two I/O's， right，
    or two reads in order to get to it。 So that's why we multiply that number by two。
    So going down that level， right？
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为实际上有两个可能的页面，对吧？就是记录实际所在的地方。然后每一个都需要两个I/O操作，或者两个读取才能到达。所以这就是为什么我们将那个数字乘以2。所以这样向下走那一层，对吧？
- en: So for the next thing， so now for the white pages， for the white pages， right？
    So same idea。 So now we're basically going to go down like， you know， three levels
    on the top， right？
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下一个步骤，现在是关于白色页面的，白色页面，对吧？同样的思路。所以现在我们基本上会向下走三层，对吧？
- en: We need to read the blue one， the teal one， and then all the way down to the
    white one。 so that we get to that page， okay？ And then you can count from this
    picture， right？
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要读取蓝色页面、青色页面，然后一直读取到白色页面，这样我们就能到达那个页面，好吗？然后你可以从这个图像中数一下，对吧？
- en: That we have four different white pages in this file here， right？ So therefore，
    the expat of value。 right， for the white pages is basically going to be three，
    times the I over B multiplied by four。 right， because we have four different possibilities。
    And then likewise for the black one。 So you're getting kind of confused about
    this linear representation of the pictures。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个文件中有四个不同的白色页面，对吧？因此，白色页面的期望值实际上是3，乘以I除以B再乘以4，对吧，因为我们有四种不同的可能性。然后同样的情况对于黑色页面。所以如果你对这种线性表示的图像感到困惑。
- en: Let me try to draw it like in another way as a typical binary tree that you
    see， that。 you have probably seen from 61 B， right？ So for the first level for
    the blue one。 which basically costs one green。 And also get to， because that's
    the first one that we'll try。 right in the dead middle， of the file。 And then
    for everything in the second level requires two I/O's。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我尝试以另一种方式绘制它，作为你们可能在61 B中见过的典型二叉树，对吧？所以对于蓝色页面的第一层，实际上成本是一个绿色页面。并且也到达，因为这是我们首先尝试的页面，对吧，位于文件的正中间。然后第二层的每个页面都需要两个I/O操作。
- en: right， or two reads。 First have to go through the blue and then have to go to
    the teal。 And then likewise， right， for each of these other levels。 So can people。
    do people remember from 61 B， how many levels do we expect from a binary。 tree
    or a binary search tree？ If the total number of things that we are trying to put
    into it is B。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对，或者两次读取。首先必须经过蓝色页面，然后再去青色页面。然后同样的，针对这些其他的层级。那么大家还记得从61 B的内容吗？如果我们试图放入的总数是B，二叉树或二叉查找树预计会有多少层？
- en: Awesome。 Yeah， it's log base 2B， right， remember？ So even though in computer
    science I know we only talk about base two stuff。 but then like， you know， sometimes
    for people who are not in the field。 you basically need to remind， them， okay？
    So it's log base 2B， right？
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。是的，log以2为底的B，对吧，记得吗？即使在计算机科学中我知道我们只讨论二进制的东西，但有时对于那些不在这个领域的人，你基本上需要提醒他们，好吗？所以是log以2为底的B，对吧？
- en: So this is going to be the formula that we'll be able to derive in terms of
    the total average。 cost when we try to find a record in a bind in a sort of file。
    So we're going to sum from level one all the way up to log base 2B， right， which
    is basically。 the total number of levels that you expect， right？ And then again。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们能够推导出的公式，用来计算在一个二进制排序文件中查找记录的平均总成本。所以我们将从第一层开始加总，一直到log以2为底的B，对吧，这基本上就是你预期的总层数，对吧？然后再一次。
- en: we're going to multiply the number of disc weights that we need for each， of
    the levels。 which in this case is I， right？ I is just like the levels， right？
    So if this for teal one is two。 for the white one is three， so on and so forth。
    And then the probability that the record that we're looking for is actually located
    in one。 of the pages at that level is going to be two to the i minus one divided
    by b。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将乘以每个层级所需的磁盘访问次数。在这种情况下是i，对吧？i就像是层次，对吧？所以如果这对于蓝色的一个是二，白色的一个是三，依此类推。那么我们要找的记录在某一层次的页面中的概率就是二的i减一次方除以b。
- en: And you can work out the math， right？ So， you know， for the first one， for the
    blue page here。 right？ It's just going to be one over b。 There's only one。 But
    the second level here is going to be two divided by b， as I showed you on the
    previous， slide。 right， right here。 So that's just like， you know， two to the
    i minus one divided by b。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以算出数学公式，对吧？所以，你知道，对于第一个，蓝色页面这里，对吧？它就是一除以b。只有一个。但第二层次这里将是二除以b，正如我在前面的幻灯片上展示的，对吧，正是这里。所以这就像是，嗯，二的i减一次方除以b。
- en: I'm not going to bore you with the math here， so you can basically take a look
    at this and。 then at the end we'll get an expression like this。 And then， again，
    right。 engineering approximation tells us that we can ignore this term， right。
    because b minus one divided by b is kind of just like， you know， one。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会让你们厌烦这些数学内容，所以你们可以基本上看一下这个。然后最终我们将得到像这样的表达式。然后，再次提醒，对吧，工程近似告诉我们我们可以忽略这个项，对吧。因为b减一除以b就像，嗯，1。
- en: And then by another approximation， you can basically think of this as something
    like， you know。 log two base b approximately。 Right？ So again， I'm not showing
    the actual time that it takes to do an actual read-a。 right？ And then if you actually
    want the full time formula， right， so we'll just basically just。 multiply that
    by b here。 So on the previous page， I'll show you the number of this grid， right。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过另一个近似，你基本可以把这个看作是，嗯，类似于以2为底的对数b。对吧？所以我再次强调，我没有展示实际读取操作所需的时间，对吧？然后，如果你想要完整的时间公式，对吧，我们基本上只需要把这个乘以b。所以在前一页，我会给你展示这个网格的数字，对吧。
- en: so as you can see， here。 And it's approximately log base to b。 So we can already
    see a difference。 right， between heap file and sort of file and keep， that in
    mind， right？
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里。它大约是以b为底的对数。所以我们已经可以看到差异了，对吧，堆文件和排序文件之间有区别，记住这一点，对吧？
- en: So now we're basically going to see differences between these two files， which
    will basically。 help us to decide when to use which type。 Okay。 So now let's go
    on to the next one。 So now we have range search。 What do I mean by range search？
    So in this case。 let's say we want to find all the records between seven and nine。
    And then for a heap file， again。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们基本上要看到这两种文件之间的区别，这将基本上帮助我们决定何时使用哪种类型。好的。接下来我们来看下一个。那么我们有范围搜索。范围搜索是什么意思呢？举个例子，假设我们要找到所有介于七和九之间的记录。那么对于堆文件，还是一样的。
- en: right， we， I claim that we always want to need to scan， through everything。
    Can someone tell us why？
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对， 我说我们总是需要扫描所有内容。有人能告诉我们为什么吗？
- en: Anyone？ Yeah， then sorry， Carlos， yes。 Yeah， basically what people have said，
    they're unsorted。 We don't know the ordering， so we need to go through all of
    them to find it。 Yeah， exactly。 We don't know the ordering， right？ So I want to
    find everything from seven to nine。 So it's not sufficient to just like， you know，
    stop after we find seven， right？ Or like， you know。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有人吗？是的，然后抱歉，Carlos，没错。是的，基本上人们说的，他们是无序的。我们不知道顺序是什么，所以我们需要遍历所有的记录才能找到。没错，正是这样。我们不知道顺序，对吧？所以我要找到七到九之间的所有记录。所以仅仅在找到七之后停下来是不够的，对吧？或者像，嗯。
- en: we've， after we found 10， right， because how do you know where something。 in
    between my actually exists， right， which in this case it is。 Okay。 So we can't
    actually do this。 So always need to scan everything。 And then， you know， what
    about sort of file， right？
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在找到10之后，对吧，因为你怎么知道某个值是否存在于我的范围内呢？这个值是否实际存在呢？对，这个问题。好的，所以我们不能实际做到这一点。我们总是需要扫描所有的内容。然后，怎么样呢，排序文件呢？
- en: Same question。 So we won't do that。 Then how do we actually do it？
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的问题。所以我们就不做了。那么我们到底该如何做呢？
- en: Do people have suggestions about how to actually go about doing this for a heap
    file？
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有人有建议如何在堆文件中实际执行此操作吗？
- en: I know we can scan everything。 Yes。 But like， you know， let's try to be a liberal
    smart idea， right？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我们可以扫描所有的内容。是的。但是，嗯，像这样，让我们尝试一个更聪明的思路，对吧？
- en: So like， you know， what else can we actually do？ Or what better ways can we
    actually do in order to find it？
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你知道的，我们还可以做些什么呢？或者我们可以做些什么更好的方法来查找它？
- en: Yeah， right？ So we can find the first one and then find the last one， right？
    Yeah。 So we can。 so in fact， here's another proposal， right？ Just like， you know，
    you can do binary search twice。 Yes。 Or you can also just like， you know， do this，
    right？
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，对吧？所以我们可以找到第一个，然后找到最后一个，对吧？是的。所以我们可以。实际上，这里还有另一种提议，对吧？就像，你知道的，你可以进行两次二分查找。是的。或者你也可以像这样做，对吧？
- en: So first find where the starting point is and then just scan the rest， right？
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先找到起始点，然后扫描其余的部分，对吧？
- en: Because this thing is sort of sorted， right？ So we actually don't need to run
    the binary search again since we found the starting point。 right？ In this case，
    seven， then we just scan everything to the right until the end of the file or。
    until like， you know， where we actually want to stop， right？ In this case， nine。
    So we're basically just like， you know， stop right here， for example。 Okay。 What
    does that mean？
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个东西是有序的，对吧？所以我们实际上不需要再进行二分查找，因为我们已经找到了起始点，对吧？在这种情况下，七，然后我们只需要扫描到右边，直到文件的末尾，或者直到你知道的，我们实际想停下的地方，对吧？在这种情况下，是九。所以我们基本上就像这样，你知道的，在这里停下。例如，好吧。那意味着什么？
- en: So that basically means we just need to find the beginning of the range and
    then we just。 scan right until we stop。 So what is the cost going to be？
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着我们只需要找到范围的开始，然后我们只需扫描右边直到停止。那么成本是多少呢？
- en: So you remember that I was kind of like telling you guys about this B over two
    number， right？
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你记得我有跟你们提过这个B除以二的数字，对吧？
- en: So B over two is like the average， the number of pages that we expect to scan，
    right？
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以B除以二就是我们预计需要扫描的页面数量，对吧？
- en: In order to like， you know， do searches in this case， right？ So in this case。
    we're going to invoke that here。 So the actually， hold onto that thought。 So like
    in this case。 the cost is actually just going to be the cost that it takes to。
    first do the binary search to locate the start and just scan everything to the
    right， right？
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了像这样进行查找，对吧？所以在这种情况下，我们将在这里调用它。实际上，保持这个想法。那么在这种情况下，成本实际上只是进行二分查找以定位起始点，然后扫描右边的所有内容的成本，对吧？
- en: And then I'm going to just wave my hands and say like， your number of pages
    that we need。 to scan to the right is this magic variable called pages here。 So
    it depends on where your range actually ends， right？ So you can approximate that
    as B over two。 if you feel like， like， you know， this is on， average， like， you
    know。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我就会挥挥手，说我们需要扫描到右边的页面数量是这个神奇的变量，叫做页面（pages）。所以它取决于你的范围实际结束的地方，对吧？所以如果你觉得可以的话，可以将其近似为B除以二。如果你认为，这在平均情况下是这样的，你知道的。
- en: where the number of pages that we need to scan or you can also。 use something
    more exact if you actually know the number of pages for a particular query。 when
    you actually try to do the range search。 But in the general formula。 it's just
    going to be like， you know， the cost that it takes。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需要扫描的页面数量，或者如果你知道某个特定查询的页面数量，也可以使用更精确的方法。当你实际进行范围查找时。但在一般公式中，它只会是你知道的，所需的成本。
- en: to first locate the starting point and then just the number of pages that we
    need to scan。 until the until we get to the end point。 Any questions about range
    search？ So again。 you see the difference between these two， right？ So like， you
    know。 the heap file is basically just going to be constant in terms of the。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定位起始点，然后扫描所需的页面数量，直到我们到达终点。关于范围查找有问题吗？再说一次，你能看到这两者的区别，对吧？所以，你知道的，堆文件的成本基本上是常数。
- en: cost that it takes versus sort of file， it can actually be quite a bit more
    efficient， already。 Okay， so now if no questions， then let's go on to insertion。
    So we also want to insert right into these case into into into these two different
    types， of files。 So how do we actually do it？ For heap file， right， so you remember
    from the last lecture， you know。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样计算所需的成本，与文件的大小相比，实际上可能已经更高效了。好吧，所以现在如果没有问题，那我们继续讲插入操作。所以我们也想在这两种不同类型的文件中插入。那么我们怎么做呢？对于堆文件，你知道的，记得上次讲座时提到过。
- en: you can insert， in like， you know， different places， right？ But then for the
    purpose of this class。 just to make things simple， we're always going to。 assume
    that we're going to insert to the very end or the last or the last page。 So with
    that assumption， the cost associated with insertion into heap file， I claim， it's。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不同的位置插入，对吧？但是为了本课程的目的，为了简化事情，我们总是假设我们将插入到最后，或者最后一页。所以在这个假设下，插入堆文件的相关成本，我认为是。
- en: just going to be too multiplied by D。 So can people try to think about like
    why we have this magic number two here？
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就是说，它将是2乘以D。那么大家能否思考一下为什么这里有这个神奇的数字2呢？
- en: Why is it not just D？ I mean， like， you know， we just stick it to the end of
    file， right？ Yeah。 great。 Okay， so it's both read and write， right？ So this is
    actually going to be a killer for a lot of these different operations。 So unlike
    the previous type of operations， where we only scanning things or reading things。
    from the disk， right？ In this case， we're actually making modifications。 So remember。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它不是D呢？我的意思是，你知道，我们不是把它直接加到文件末尾吗？对吧？是的。很好。好吧，所以它既是读取又是写入，对吧？因此，这实际上会对很多不同的操作造成巨大的影响。所以与之前只扫描或读取磁盘上的数据的操作不同，在这种情况下，我们实际上是在进行修改。所以记住。
- en: what I said in the very beginning of the lecture， if we actually make modifications。
    it's not sufficient。 So just end in the main memory。 we need to actually write
    it all the way back to the disk。 So therefore， in this case。 the cost is not just
    going to be one single page read。 It's also writing it afterwards。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我在讲座一开始说过，如果我们实际上进行了修改，光在主内存中是远远不够的。我们需要把它全部写回到磁盘。所以因此，在这种情况下，成本不仅仅是一次单独的页面读取。还包括之后的写入操作。
- en: writing it back afterwards。 So that's why it's going to be two times D。 D again
    is the average amount of time that it takes to read or write to the disk of a
    single， page。 Okay。 Question。 Hi， sorry， can you repeat it again？ Because I quite
    not get why it's too here。 Okay。 Yeah， it's because we need to both read and write，
    right？ So it's going to cost us like， you know。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后的写入操作。所以这就是为什么它会是2倍的D。D再次是指读取或写入单个页面到磁盘的平均时间。好吧。有问题吗？嗨，抱歉，你能再重复一遍吗？因为我没完全理解为什么是2。好的。是的，因为我们需要同时进行读取和写入，对吧？所以它将花费我们，嗯，你知道的。
- en: one page， right， one disk read to read in the last， page here， right？ So we're
    trying to insert 4。5。 right？ So it's going to cost us at least one read to read
    that last page， put it into that page。 in memory， right？ And then we need to write
    it back to the disk。 So therefore。 that is going to cost us another operation，
    another disk， right？ So therefore， the total。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一页，对吧，一次磁盘读取，读取最后一页，对吧？所以我们试图插入4.5，对吧？所以这将至少花费我们一次读取操作，读取那最后一页，将其放入内存中，对吧？然后我们还需要将其写回磁盘。所以这将再花费我们一次操作，再次进行磁盘操作，对吧？因此，总体的成本是。
- en: it's going to be two pages in terms of number of pages。 Okay。 So you mean that
    we need to write both in a memory and also the disk。 So we need two pages。 Yeah。
    because otherwise， if you just write a memory， what if you turn off your machine
    afterwards， right？
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及两页的页面数。好吧。也就是说，你的意思是我们需要同时写入内存和磁盘。所以我们需要两页。对，因为如果你只写入内存，之后如果关机怎么办，对吧？
- en: Okay， thank you。 Yeah。 So we need to make it persistent。 So therefore。 we need
    to write it back to the file。 So therefore， that's why this is going to be two。
    Yeah。 Any other questions？ Okay。 Okay。 Thank you， Kari。 So let's go on， right？
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，谢谢。是的。所以我们需要让它持久化。因此，我们需要将其写回文件。所以这就是为什么会是2。嗯。还有其他问题吗？好的。好的，谢谢，Kari。那么我们继续吧，对吧？
- en: So now let's talk about what would happen if we try to insert into a sort of
    file。 Same idea， right？
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在让我们来讨论如果我们尝试插入到一个排序文件会发生什么。思路一样，对吧？
- en: So basically， try to now run what， yeah， what should we run in this case？ What
    should we do first？
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，现在我们要运行什么，嗯，应该在这种情况下运行什么呢？我们应该先做什么？
- en: Binary search， right？ I mean， like， no， yeah， I mean， that's kind of like the
    theme， right？
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找，对吧？我的意思是，嗯，不，嗯，我的意思是，这有点像主题，对吧？
- en: So this whole class， right， for a sort of file binary search， right？ Why？
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这整个类，嗯，类似于文件二分查找，对吧？为什么？
- en: Because we want to find out where to actually put the record in。 We want to
    maintain the sort order。 right？ So in this case， we're not， we can't just append
    it to the end， right？
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要找出记录到底放在哪里。我们想要保持排序，对吧？所以在这种情况下，我们不能只是把它附加到文件末尾，对吧？
- en: Because that will break the sort of file。 So we actually want to run binary
    search first。 which in this case would help us identify the， place that we actually
    want to insert the record。 So from previous couple of slides， you can already，
    you might remember that the cost is。 just going to be lock base to be， right？
    And then multiply that by B in terms of。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因为那样会破坏排序文件。所以我们实际上想先进行二分查找。在这种情况下，它可以帮助我们确定我们实际上要插入记录的位置。所以从前几张幻灯片来看，你可能已经记得成本是。只是会是对数基数为2，再乘以B的。
- en: and then we get the actual time associated with， finding the record。 Now that's
    not enough， right？
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到与查找记录相关的实际时间。但这还不够，对吧？
- en: Because we actually need to stick the record that we want to insert。 In this
    case， 4。5。 and then write back everything afterwards， right？ Everything in this
    case， meaning like， you know。 all the other pages to the right of， it until the
    end， right？ Because we are shifting it。 which basically shifting by inserting
    a new rack， by inserting， a new record and then like。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们实际上需要插入我们想要插入的记录。在这种情况下，4.5。然后将之后的所有内容写回，对吧？在这种情况下，“所有内容”是指，像你知道的那样，右侧的所有页面，直到最后，对吧？因为我们要进行移位。基本上是通过插入一个新的记录来移位，然后像这样。
- en: you know， writing back all the other subsequent pages associated， in this file
    here。 Does that make sense？ So just to repeat， right？ So in this case， we start
    with， you know。 5 and 6 on one page， 7， 8 on another page， so and so forth。 We're
    trying to insert 4。5。 So we need to put it in the same page as 5， right？ Because
    we want to maintain this sorted order。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道的，需要写回与此文件相关的其他所有后续页面。这样说清楚了吗？所以再重复一下，对吧？在这种情况下，我们从，知道的，5和6在一页上，7和8在另一页上，以此类推。我们要插入4.5。所以我们需要将它放到与5同一页上，对吧？因为我们想保持排序顺序。
- en: We cannot have gaps in between， except at the very end， right？ In this case，
    you have a。 we have a gap here。 But then we've otherwise， we need to basically
    put it into the page with 5 and then shift everything。 over to a different page，
    right？ And then we need everything from 6 all the way to 10。 And then write everything
    back to the disk， right？ So remember。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在中间有间隙，除了在最末尾，对吧？在这种情况下，你会看到这里有一个间隙。但除此之外，我们需要基本上把它放到包含5的页面，然后将所有内容移到另一个页面，对吧？然后我们需要从6一直到10的内容。然后将所有内容写回磁盘，对吧？所以记住。
- en: you always need to write everything back to the disk。 Yeah？
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是需要将所有内容写回磁盘。对吧？
- en: So what is going to be the cost associated with that？ So finding the record。
    I already told you it's going to be log base to be， you know， times。 D or if you
    care about the timing。 And then insertion， right？
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，与此相关的成本是什么呢？找记录。我已经告诉过你了，它将是对数基数2，乘以D，或者如果你关心时间的话。然后是插入，对吧？
- en: And shifting the rest of the file is just， it's going to be， be divided by 2，
    which again。 I'm invoking this average number of pages that we need to touch，
    right？
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 移动文件的其余部分就只是，分成两部分，这样的话。我再次提到的是，我们需要触及的页面的平均数量，对吧？
- en: From the earlier part of the lecture。 And then， you know。 multiply by that by
    D and also multiply that by 2。 2 because of the fact that we need to both read
    and write， just like on the previous， in。 the previous case。 So therefore， the
    total cost is just going to be these three things multiplied together。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从讲座的前部分。然后，你知道的，将它乘以D，并且还要乘以2。2是因为我们需要同时进行读写，就像之前的情况一样。所以因此，总成本将是这三者相乘的结果。
- en: for the insertion and the shifting。 So it's good。 It's just going to be B multiplied
    by D。 And then the total cost is going to be addition of these two terms。 So and
    then if you work out the math， it's going to be this number here that you are
    seeing。 at the bottom of the screen。 So now we have like， you know。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入和移位。所以，它就是B乘以D。然后总成本将是这两项的总和。所以如果你算一下数学，它就是你在屏幕底部看到的这个数字。所以现在我们有了，知道的。
- en: complete this picture here for the insertion， right？ So you can see that for
    heap file。 it's just going to be like， you know， one single， one。 single read
    and one single write because we're always appending to the end of the file。 And
    then for sort of files， actually， we need to do more work， right？
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完善这个插入的过程，对吧？所以你可以看到，对于堆文件，它只是一个简单的，单一的读取和单一的写入，因为我们总是将内容追加到文件的末尾。而对于排序文件，我们实际上需要做更多的工作，对吧？
- en: So the fact that we need to run binary search and then also shift everything
    over。 So we can already see that there's a tradeoff， right？
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要运行二分查找，然后还要移位操作。我们已经可以看到，这之间存在权衡，对吧？
- en: It's not the case that sort of file always wins， right？ I mean， in fact， if
    that's the case。 then why do we bother teaching you guys about heap， file？ So
    I just teach you guys like， you know。 the best optimal thing and then that will
    hit。 But in this case， actually， that's not true。 So that's why we basically want
    to run through the analysis for both of these cases。 Okay。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说排序文件总是优于堆文件，对吧？我的意思是，事实上，如果真是那样的话，那我们为什么还要教你们堆文件呢？所以我只是教你们，像你知道的，最优的解决方案，然后那样会成功。但实际上，在这种情况下，情况并非如此。所以我们基本上希望对这两种情况都进行分析。好的。
- en: And then what about for deletion， right？ For deletion， the story is similar。
    So for the heap file case， it's also just going to be like， you know， scanning
    through everything。 because we need to find what it is。 And then like， you know，
    and then， you know。 basically delete the record and then write， things back， right？
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那删除呢，对吧？对于删除，情况类似。所以对于堆文件的情况，也只是像你知道的，扫描所有内容。因为我们需要找出它的位置。然后，像你知道的，删除记录并把数据写回去，对吧？
- en: So the average time that it takes to find the record， I claim from the previous
    slides is。 going to be beat over two in terms of number of reads， average case。
    Worst case， of course。 it's everything。 Average case， in this case， is going to
    be beat divided by two。 And then we delete the record from the page and then we
    write it back。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以找到记录所花的平均时间，我从之前的幻灯片中提出的说法是。大约是以2为底的B，按读取次数的平均情况来算。最坏情况，当然，是全部。平均情况下，在这种情况下，应该是B除以2。然后我们从页面中删除记录，然后再把它写回去。
- en: So that's why you see this one number here， right？
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是为什么你会看到这里有一个数字，对吧？
- en: So we read everything until we find it and then we stole away the record and
    then we。 write back that page onto the disk。 And then for the sort of file， right？
    It's also a similar story。 So we first， again， run binary search to find out where
    the record is actually located。 do the actual deletion and then， like， you know，
    write back all the other pages because。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们读取所有内容直到找到它，然后我们把记录偷走，然后把那一页写回磁盘。至于排序文件，对吧？情况也类似。所以我们首先，再次运行二分查找来找出记录实际的位置，进行实际的删除，然后，像你知道的，写回其他所有页面，因为。
- en: now we are also going to shift everything over。 So the cost of binary search，
    again。 is log base 2B and then， like， you know， now we need， to deal with， like，
    you know。 shifting everything over and then writing it back。 It's a question。
    Carlos。 I'm a little bit confused as to why the plus one。 I know you already explained
    it。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也需要将所有内容移位。所以二分查找的成本再次是以2为底的对数B，然后，像你知道的，我们现在还需要处理移位操作，并将其写回。这个问题。Carlos。我有点困惑为什么是加一。我知道你已经解释过了。
- en: but if you could explain it。 Sure。 Yeah。 So it's plus one because of the fact
    that we need to write back this empty page to the。 disk， right？ So we toss away
    4。5， but then we need to record it into， like， you know， into the file。 right？
    We remove it in memory。 That's not enough。 But we need to write back the empty
    page to the file so that we are sure that we get。 we've got right， we have gotten
    rid of it。 Thank you。 Sure。 Okay。 So yeah。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你能解释一下。好的。是的。加一是因为我们需要将这个空页写回磁盘，对吧？所以我们丢弃了4.5，但然后我们需要把它记录到，像你知道的，文件里，对吧？我们在内存中删除它，这还不够。但我们需要把空页写回文件，以确保我们确实已经去除了它。谢谢。好的，没问题。是的。
- en: so here basically is similar。 So we need to first find out where it is and then
    shift everything over。 So shifting everything over is just going to be， like，
    you know， be over to the multiplied。 by two as in the same case in insertion。
    So the total cost， again。 is just going to be adding these two terms together，
    which， as you will see on the。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里基本上类似。我们首先需要找出它的位置，然后将所有内容移位。移位操作将会是，就像你知道的，乘以二，和插入时的情况相同。所以总成本再次是将这两个项加在一起，就像你在。
- en: on the slide here is just going to be the same thing for the sort。 five and
    both insertion and deletion for similar purposes。 Yes， Carrie。 Carlos。 do you
    have a question or？ No， no， no， that was from previous。 Hi。 so I want to know
    that when you delete a file just in the middle of the heap file。 So do you。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这张幻灯片上的内容将会是排序操作的相同内容，同时也适用于插入和删除操作，目的是类似的。是的，Carrie。Carlos，你有问题吗？没有，那个是之前的问题。嗨。所以我想知道，当你删除一个文件时，如果它正好在堆文件的中间，你是否需要...
- en: I mean， do you also need to move the file that's behind that deleted file to。
    the front because it just delayed a file in the middle of the heap file？ Okay。
    For now。 the assumption is we're not going to， we're just going to leave it as
    a gap。 So you remember for the next lecture that that's okay。 That's okay， right？
    For the heap files。 Yeah。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，当你删除堆文件中间的文件时，是否需要将它后面的文件移动到前面？因为你只是删除了堆文件中的一个文件？好的，暂时假设我们不会这么做，我们就直接把它留空一个空隙。你记住，下次课的时候这没问题，对吧？这没问题，对吧？对于堆文件来说，嗯。
- en: so for this， for， for the person， this， we're just going to assume that you
    don't have。 to shift everything over。 But I was claimed that even if we shift
    everything over， you was。 you should still know by now， how to actually do that，
    do that analysis to， right？ Okay， thank you。 Yeah。 Okay， great。 So now we have
    seen like， you know， the flu glory， right？ Of like， you know。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们就假设你不需要将所有内容都移动。不过我声明，甚至即使我们将所有文件都移动，你应该现在已经知道如何进行这类分析了，对吧？好的，谢谢。嗯，好的，非常好。那么现在我们已经看到类似的情况了，你知道的，流畅的辉煌。
- en: doing all these different types of operations for these two different types，
    of files。 The next question to ask is actually， can we do better than the runtime
    estimates that。 we have here？ The answer turns out to be yes。 I mean， that's why
    we actually like， you know。 talk one to talk about indexes。 But before we will
    talk about the actual type of indexes that we'll go through in this。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两种不同类型的文件进行各种操作。接下来的问题是，实际上我们能否做得比这里的运行时间估算更好？答案结果是肯定的。我的意思是，这就是我们为什么要谈论索引的原因之一。但是，在我们讨论实际的索引类型之前，我们先要介绍一下这个概念。
- en: class， let's just first review what do we mean by indexes。 So it's actually
    not that foreign of a concept。 We actually all know about this kind of indexes
    in our daily lives。 So some of you might be actually old enough to like， you know，
    see something like this。 It's basically a yellow page phone book that I pulled
    up from the， from， put down from。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 课程开始之前，我们先回顾一下索引到底是什么意思。其实这个概念并不陌生。我们在日常生活中其实都接触过这种类型的索引。所以你们当中有些人可能已经足够老了，知道像这样的东西。它基本上是一本我从网络上下载的黄页电话簿。
- en: the internet。 It's definitely something that is like historical artifact now，
    right？
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它绝对可以算作一种历史遗物，对吧？
- en: But essentially the phone book is just an index， right？ It's just a way for
    us to look up like。 you know， given name， right？ Tell me the phone number of that
    person。 So that's one type of indexing。 You can already， you also see indexes
    at the。 at the end of your textbook， for instance， right？ I mean， that basically
    looks up like， you know。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但本质上，电话簿只是一个索引，对吧？它只是我们用来查找的方式，比如说，知道一个人的名字后，告诉我那个人的电话号码。所以，这是一种索引方式。你也可以在教科书的末尾看到类似的索引，比如说，它基本上是查找某个话题或作者的名字，然后告诉你该话题在哪一页。
- en: a topic name or an author name and then basically， just tells you which page，
    right？
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这样的索引——话题名称或者作者名称，然后基本上告诉你该话题所在的页码。
- en: That particular topic is in。 So those are the type of indexing and it's no different
    in the case of databases as well。 But then of course in databases， we care a lot
    about efficiency。 So it's not sufficient。 Just have something that we can use
    to look up things。 We want to be able to do it in a quick way。 right？ I mean，
    obviously for this product catalog， for instance， right， you definitely don't
    want。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些就是索引的类型，在数据库的情况也没有什么不同。但在数据库中，我们当然非常关注效率。所以，单纯拥有某种可以用来查找的东西是不够的。我们希望能够快速地进行查找。比如说，显然对于这个产品目录，你肯定不希望...
- en: to look through the entire index and also find the thing that you want， right？
    I mean。 if that's the case， I mean， why bother using the index？ I mean， just scan
    through everything。 So obviously we need a mechanism that allows us to both have
    the ability to look things。 up by a key and also like， you know， do it efficiently。
    So we've actually seen this before。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅整个索引，并找到你想要的东西，对吧？我的意思是，如果是这种情况，我的意思是，为什么要使用索引呢？我就是说，直接扫描所有内容就行了。所以显然，我们需要一种机制，既能让我们通过关键字查找东西，又能高效地做到这一点。所以我们实际上之前已经见过这个。
- en: So we've seen actual different different types of data structures in memory。
    For instance。 we have different types of search trees。 We have different types
    of hash tables and you recall all these things hopefully from。 your 61 B experience，
    right？ But then now we're not talking about a memory。 We're actually talking about
    this base data structures， right？
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过实际的不同类型的内存数据结构。例如，我们有不同类型的搜索树，我们有不同类型的哈希表，希望你能从你的 61B 经验中回忆起这些内容，对吧？但现在我们不谈论内存了，我们实际上是在谈论这些基础数据结构，对吧？
- en: Because we are actually storing things on the disk。 So obviously if we want
    to store an index on the disk， then how do we actually store。 like a hash table
    or binary search tree onto the disk， right？ So that's basically the question。
    And again， right？ In this class， we modeled this as this pages。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们实际上是把东西存储在磁盘上。所以显然，如果我们想把索引存储在磁盘上，那么我们如何将像哈希表或二叉搜索树这样的结构存储到磁盘上，对吧？所以这基本上就是问题所在。再说一次，对吧？在这门课上，我们将其建模为页面。
- en: So basically we want to have some sort of paginated data structure that we use
    to represent。 indexes。 And we have also seen this before when we were talking
    about the SQL in the SQL lecture。 right？ So you remember this sailors table that
    I was using in the lecture slide， right？
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上我们想要一种分页的数据结构来表示索引。而我们之前在 SQL 课程中谈到过这个，对吧？所以你记得我在课件中使用的那个水手表，对吧？
- en: So we're declaring things as a with a primary key。 So now you know， right？
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们声明某些东西时，会使用主键。所以现在你知道了，对吧？
- en: You're aware of this primary。 What do we mean by primary key， right？
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道这个主键，对吧？我们所说的主键是什么意思，对吧？
- en: So when we're talking about SQL， we're talking about like how you can use that
    to look up the。 rest of the record because this is supposedly a unique identifier。
    In this case， like， you know。 the sailor ID is a unique identifier。 That's great。
    But then， you know， how do we actually store。 right？ This data and how do we store
    the sailors？ Theta， right？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们谈论 SQL 时，我们是在谈论如何使用它来查找其余的记录，因为这应该是一个唯一标识符。在这种情况下，像水手 ID 就是一个唯一标识符。这很好。但是你知道的，接下来我们怎么存储这些数据？我们如何存储水手的数据，对吧？
- en: Because we want to maintain this index on the sailor ID。 So that's what we'll
    be talking about for the rest of this class。 So formally speaking。 an index is
    just a data structure that we can use to look up or modify。 things quickly based
    on a search key。 So look up， we've already seen different examples in the previous
    slides。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要维护基于水手 ID 的索引。所以这就是我们接下来要讲的内容。所以正式来说，索引只是一个数据结构，我们可以用它来根据搜索键快速查找或修改内容。所以查找，我们已经在之前的幻灯片中看过不同的例子。
- en: right？ So you know， it can be looking up by equality， right？
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？所以你知道，它可以通过等式来查找，对吧？
- en: I'm finding the sailor with ID equals to 42。 It can be looking up by a geometric
    region。 I'm trying to look up like， you know， all the fires that are going on
    right now in the， stage。 right？ Given a latitude and longitude， for instance。
    And you can also just like in the primary case。 primary key case when we were
    talking about， SQL， the search key， right？
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在查找 ID 等于 42 的水手。它可以通过几何区域来查找。我正在尝试查找当前在舞台上的所有火灾，对吧？比如给定一个纬度和经度。例如，你也可以像我们在主键的情况下讨论
    SQL 时那样，使用搜索键，对吧？
- en: Or the key that we used to look up can be actually any combination of columns。
    And I'm just pulling things up from the previous lecture， right？ The first or
    second lecture here。 where you can also combine not just first name， but also。
    last names together in order to form a search key。 And then like， you know。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来查找的键实际上可以是任意列的组合。我只是从上一讲中提取了一些内容，对吧？在这里，你可以将名字和姓氏组合起来，形成一个搜索键。然后像你知道的那样。
- en: the question that we want to ask again， right， is how do we actually。 want to
    store the data associated with， you know， the index， right？ I mean。 one option
    obviously is to store the index completely separate from the rest of， the data。
    but then we might be able to do actually better than that。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要再次问的问题是，我们实际上希望如何存储与索引相关的数据，对吧？我的意思是，一种明显的选择是将索引与其余数据完全分开存储，但我们也许可以做得比这个更好。
- en: So we'll see what happens in need of these cases。 So for today。 we're just going
    to assume that we now need to store， you know， K， which。 is the key that we're
    trying to look up， whatever that is。 And we say ID can be a combination of first
    name， common last name。 And then some record ID。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将看看这些情况的需求会发生什么。那么今天，我们将假设现在我们需要存储你知道的，K，这就是我们要查找的键，不管它是什么。我们可以说，ID可以是名字、常见的姓氏的组合，然后是一些记录
    ID。
- en: which we can then use， right？ To look up the actual record or the data associated
    with it。 So for instance， we can imagine storing the index as a completely separate
    in this completely。 separate file from the actual data itself。 And then the index
    in that in this case can just store like。 you know， which record number， that
    we need to look up and which file it actually resides in， right？
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就可以使用它，来查找实际的记录或与之相关的数据。例如，我们可以想象将索引完全存储在与实际数据完全分开的文件中。那么在这种情况下，索引就可以仅仅存储，比如你知道的，哪个记录号是我们需要查找的，和它实际所在的文件，对吧？
- en: And then given that information， we can now go to the actual file where the
    tuple resides。 and then load that page onto the disk and then go on to the rest
    of the query processing。 And likewise， right， how do we actually want to do modification
    in this case， right？ Again。 we want to do really quick insertion and deletion，
    not just in the base table， itself。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据这些信息，我们现在可以去实际存放元组的文件，然后将该页面加载到磁盘上，接着继续进行查询处理。同样的，如何实际进行修改呢，对吧？再次强调，我们希望能够非常快速地进行插入和删除，不仅仅是在基础表中。
- en: but also in the index， right？ Because every time when we update the actual data。
    we also need to modify the associated， index as well， right？ Otherwise。 they will
    go out of sync and then that's back。 So these are the kinds of things that we
    want to talk about in this class。 So and as I said， there are many types of index
    of data structures available。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在索引中，对吧？因为每次当我们更新实际数据时，我们也需要修改相关的索引，对吧？否则，它们会不同步，然后出现问题。所以这些都是我们在这门课中要讨论的内容。正如我所说，数据结构的索引有很多种类型。
- en: We'll focus on the B plus tree for the rest of this lecture， which this year
    will now go， through。 But before that， can I answer any other questions？ Oh， was
    everything crystal clear？ Going once。 Really？ Should we go for a pop quiz now？
    Oh， someone asked in the chat。 Okay。 You repeat the question， please。 So an index
    does not have the actual data。 Okay。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将集中讲解 B+ 树，这是我们今年接下来的内容。但在这之前，我能回答其他问题吗？哦，大家都完全明白了吗？一次，真的？我们现在来个小测验吗？哦，有人在线问了问题。好，请重复一下问题。好，索引没有实际数据，对吧？
- en: that's a great question， Billy。 So it depends。 And that's actually what we'll
    be talking about in today's lecture and also in next week's。 lecture。 The short
    answer is it depends。 It can be either one。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题，Billy。所以这取决于情况。实际上，这就是我们今天的讲座以及下周讲座要讨论的内容。简短的回答是，这取决于情况。它可以是任意一种。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_3.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_3.png)'
- en: Okay， so no， no other questions。 I'm going to stop sharing and I'm going to
    let the T I take over from here。 Give me a second。 So to find a rope。 Right， so
    Nicholas was asking the question of， like， you know。 how do we actually use the，
    index？ So one way to use the index。 as I was saying earlier is to assume that
    the index is storing， a key and also the record number。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没有其他问题。我将停止共享，接下来让T I接管。稍等一下。所以要找到一根绳子。对了，Nicholas在问一个问题，比如，我们如何实际使用这个索引？所以正如我之前所说的，使用索引的一种方式是，假设索引存储一个键和记录号。
- en: And if that's the case， then we first look up in the index and then， like， you
    know， the。 index will return us the record number and the page and the file name
    for which the two。 poll that we actually want to look up resides。 And then we
    just use the algorithms that we were talking about earlier to actually fetch。
    the two poll that we interested。 But that's one way。 But that's not the only way。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，那么我们首先在索引中查找，然后，像你知道的那样，索引会返回记录号、页面和文件名，这些是我们实际想要查找的两条记录所在的地方。然后我们只需要使用我们之前讨论的算法来实际获取我们感兴趣的两条记录。但这是一种方法，但不是唯一的方法。
- en: It depends on where the data actually is stored with the index or not。 Any other
    questions about things for now while we wait for the T to get set up？ Okay， go
    for it。 Can you see and hear me？ Okay。 Yeah。 Right。 So we're talking about indexes。
    just carrying off from where Alvin left us。 So as Alvin said。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它取决于数据实际是存储在索引中还是不在索引中。现在我们在等待T设置好时，还有没有其他问题？好的，开始吧。你能看到我和听到我吗？好的。是的。对的。所以我们在讨论索引。接着Alvin给我们的讲解。正如Alvin所说。
- en: indexes are a class of data structures that allow a lookup by a specific。 key
    and also support efficient modification。 Right。 so you want to be able to add
    and delete records by key and also look up data by key。 Right。 So you want to
    be able to identify data by key。 Okay。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是一类数据结构，它允许通过特定的键进行查找，同时也支持高效的修改。对吧？所以你需要能够通过键添加和删除记录，也能够通过键查找数据。对吧？所以你需要能够通过键来识别数据。好的。
- en: so let's start by sort of a simple idea and see why the simple idea fails and。
    then we'll try to get to the eventual indexing structure that we're going to be
    talking about。 today， which is B plus three indexes。 Okay。 So let's start with
    the simple input heap file。 And then let's say instead of using an index， I'm
    just going to sort my heap file and sort。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们先从一个简单的想法开始，看看为什么这个简单的想法会失败，然后我们会尝试讨论今天要讲的最终索引结构，即B+树索引。好的，所以我们从简单的输入堆文件开始。然后假设不使用索引，我只是对我的堆文件进行排序。
- en: of to make sure that there is space to add potentially new records。 I can leave
    some space in each of my pages。 Right。 So I have my heap file sorted in the way
    that Alvin described when he talked about this。 sorted files。 So I could just
    store these pages in this sequential order。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保有空间可以添加潜在的新记录，我可以在每一页中留下些空余空间。对吧？所以我按照Alvin描述的方式对我的堆文件进行排序。排序后的文件。我可以按照这种顺序存储这些页面。
- en: So it's basically stored in the order that it's sorted， allowing me to access
    these pages。 in sequence。 Okay， so let's say I do that。 Now as we also described，
    as Alvin did with。 showed with the math， maintenance becomes painful。 Right。 so
    as we add new records or delete records， this becomes problematic。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它基本上按照排序的顺序存储，允许我按顺序访问这些页面。好的，假设我做到了这一点。正如我们之前所描述的，正如Alvin通过数学所展示的，维护变得非常痛苦。对吧？所以随着新记录的添加或删除，这变得有问题。
- en: And this leads to B updates where B is a total number of blocks in the worst
    case。 Right。 So you end up moving everything down or moving everything up in the
    worst case。 Okay。 So。 and we also talked about this step of binary search。 Right。
    So let's say you want to find some specific record。 You can certainly do a binary
    search。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就导致了B次更新，其中B是最坏情况下的块总数。对吧？所以在最坏的情况下，你最终需要将所有内容往下移动或者往上移动。好的。然后我们也讨论了这个二分查找的步骤。对吧？所以假设你想查找某个特定的记录，你当然可以进行二分查找。
- en: And we also did this sort of， sort of math to show that this is log two of B
    where B is。 a number of blocks。 And you might want to multiply that by D。 D is
    a time if you want to compute the time， as opposed to the number of pages read。
    Now there are two downsides of this approach。 Right。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也做了类似的数学推导，表明这是B的对数，B是块的数量。如果你想计算时间，而不是读取的页面数量，可能还要乘上D。D是时间。如果你想计算时间，而不是读取的页面数量。现在，这种方法有两个缺点。对吧？
- en: So the first downside is that this is a fan out of two， which means it's a very
    deep tree。 Right。 So this is a deep tree and there's lots of IOS。 The second downside
    is that you're actually reading entire records just to read the key。 during search。
    Right。 So you're not， you're reading a whole page of filled with records just
    to determine whether。 you're reading the right page or not and whether you should
    go be going left or you should。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以第一个缺点是这是一个二叉树的展开，这意味着它是一个非常深的树。对吧？所以这是一个深树，且有很多的IOS操作。第二个缺点是你在查找过程中实际上是读取整个记录才能读取键。对吧？所以你不是直接读取键，而是需要读取一整页，里面充满了记录，仅仅为了判断你是否在读正确的页面，是否应该往左走，或者应该往右走。
- en: be going right。 So there's a lot of redundant data that's being read。 We would
    much prefer this to be log of K as opposed to log of B because K is a number。
    of keys and this is likely to be much smaller than B。 Right。 Because B is likely
    to be very large because often you don't just have the keys as part。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧。所以有大量冗余数据被读取。我们更希望这能够是 K 的对数，而不是 B 的对数，因为 K 是键的数量，而这个数可能远小于 B。对吧，因为 B 很可能非常大，因为通常不仅仅有键作为一部分。
- en: of your record。 You have a lot of other attributes as well。 Right。 Okay。 So
    let's try to fix these assumptions。 Okay。 So let's say we do the first。 we make
    the first relaxation， which is we don't store， we use， a heap file as Alvin mentioned。
    So we don't store the pages， the records in a sorted fashion。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你的记录中，还有很多其他属性。对吧？好的。那么让我们尝试修复这些假设。好的。假设我们做了第一个放宽条件，即我们不存储，正如 Alvin 所提到的，我们使用堆文件。因此，我们不以排序的方式存储记录。
- en: We keep that as is we have basically very compact key lookup pages in addition
    and we。 lay these out sequentially。 Okay。 And so these key lookup pages basically
    maintain a key to record ID mapping。 This should be page ID and then there should
    be slot ID rather than record ID。 So it's basically telling you or just imagine
    this to be the record within the page。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持原样，基本上我们有非常紧凑的键查找页面，并且我们将它们按顺序排列。好的。所以这些键查找页面基本上维持了一个键到记录 ID 的映射。这里应该是页面
    ID，然后应该是槽 ID，而不是记录 ID。所以它基本上是告诉你，或者你可以想象这就是页面中的记录。
- en: So the slot within the page。 So so this key here， for example。 is pointing to
    this particular page page three and this。 particular slot within that page that
    allows me to retrieve the corresponding record。 Okay。 So now that I have this
    basically this set of compact key lookup pages， I don't need to。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以页面中的槽。例如，这个键，这里指向这个特定的页面页面三，以及该页面中的特定槽，这让我能够检索到相应的记录。好的。所以现在我基本上拥有这组紧凑的键查找页面，我不需要再…
- en: sort my heap file anymore。 I can just store this and forget about sorting my
    heap file。 However。 I have， okay， before I get to that， I can still use a binary
    search on these key。 lookup pages if I wanted to find something。 So if I wanted
    to find the page corresponding and the records corresponding to 27。 I would， then
    do a binary search， maybe start here and then move to the left or maybe move to
    the。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不再对我的堆文件进行排序了。我可以直接存储这些内容，而不必担心排序我的堆文件。然而，在此之前，我仍然可以在这些键查找页面上使用二分查找，如果我想找到某些东西。所以，如果我想找到与
    27 对应的页面和记录，我会进行二分查找，可能从这里开始，然后移到左边，或者可能移到右边。
- en: right and then eventually identify the record and the page corresponding to
    27。 Now this still suffers from the same downside as in the previous slide because
    this is still。 going to be a deep tree because the fan out is going to be two。
    So there's still going to be lots of files and we'll see how to fix that in a
    little bit。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对，最终识别与 27 对应的记录和页面。现在，这仍然存在与前一张幻灯片相同的缺点，因为这仍然会是一个深树，因为分支度是 2。所以仍然会有很多文件，我们稍后会看到如何修复这个问题。
- en: The other downside is that maintaining these key lookup pages is a pain， right？
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，维护这些键查找页面是很麻烦的，对吧？
- en: I'm basically storing all of these in sequence and I have， if I want to insert
    new keys and。 therefore new records， I have to in the worst case， push all of
    my pages down， right？
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我基本上是按顺序存储所有这些，如果我想插入新的键，因此新的记录，我必须在最坏的情况下，将所有页面往下推，对吧？
- en: So this maintenance is a pain in the face of inserts or deletes。 Bhavana， you
    have a question？ Yeah。 so I was wondering why you said K is much less than B because
    in your picture over。 here it looks like the number of keys is greater than the
    number of pages。 Sure， so in this case。 I haven't actually shown all of the records
    corresponding to my 1， 2， 3， 4， 5， 6， 7， 8， 9， 10， 11。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在插入或删除的情况下，这种维护是一个痛苦。Bhavana，你有什么问题吗？是的，我想知道你为什么说 K 远小于 B，因为在你的图中，看起来键的数量大于页面的数量。好的，实际上，在这个情况下，我并没有展示所有与我的
    1，2，3，4，5，6，7，8，9，10，11 相对应的记录。
- en: 12， 13， 14， 15， 16， 17。 So there are at least 17 keys and therefore there should
    be 17 pages。 I'm not showing all of them here。 So that's the first observation。
    The second observation is that typically records are a lot longer than two attributes。
    You might have 20， 50 attributes and so you might not be able to pack that many
    records， in a page。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 12，13，14，15，16，17。所以至少有 17 个键，因此应该有 17 页。我这里没有展示所有的。所以这是第一个观察。第二个观察是，通常记录比两个属性要长得多。你可能有
    20 个，50 个属性，因此你可能无法在一页中装下这么多记录。
- en: On the other hand， if all that you're storing is a key and a pointer to a page
    and the slot。 within that page， you can pack a lot more， right？ So just three
    bits of information。 three bits being used in loose sense but the key， the。 page
    ID and the slot ID and you're doing that for each of the keys that are in one
    of these， pages。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你存储的只是一个键和一个指向页面的指针以及页面中的槽位，你可以装下更多的记录，对吧？所以仅仅是三个位的信息。三个位是宽泛地说，但这里指的是键、页面ID和槽位ID，而你对每个在这些页面中的键都这么做。
- en: On the other hand， here for each record you might have 50 attributes， right？
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于每个记录，你可能有50个属性，对吧？
- en: So there might not be as many records that you can pack in and therefore B is
    likely to。 be much larger than K。 So I think I'm not clear on the meaning of these
    variables。 So B is the number of pages？ Total number of blocks， yes。 That your
    data is stored in， right？
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能无法装下太多的记录，因此B可能会大大大于K。所以我想我不太清楚这些变量的含义。所以B是页面数量？总块数，是的。是你数据存储的块数，对吧？
- en: So your records are stored in。 And so imagine， imagine， think about it in the
    following way， right？
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你的记录是存储在。想象一下，想一想以下方式，对吧？
- en: Let's say I have a student table and I'm indexing the student table based on
    the student name。 The student table also has 50 other attributes， right？
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个学生表，我根据学生姓名为这个学生表建立索引。这个学生表还有50个其他的属性，对吧？
- en: Now take the number of just doing back of envelope calculation， the number of
    pages that you would。 need to store this entire student table is going to take
    50 times as much， let's say。 as just storing the student names， right？ So that
    would be the kind of order magnitude difference that we're talking about。 That's
    the difference between K and B， right？ K is order of number of distinct values
    in your key while B is likely to be much larger。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们做一个简单的估算，存储整个学生表所需要的页面数量将是存储学生姓名所需的数量的50倍，假设是这样。对吧？这就是我们所说的数量级差异。这就是K和B之间的区别，对吧？K是你键值中不同值的数量级，而B通常会大得多。
- en: because you have to store all of your data。 Okay， okay。 Great。 Any other questions？
    Okay， all right。 So this still has the same issue， right？ So it still has the
    same issue of the maintenance of these key lookup pages which are stored。 in sequence
    is still going to be expensive。 So how do we fix this？ Okay。 so let's apply the
    same idea that we applied to these unsorted heap files to the。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你需要存储所有的数据。好的，好的。很好。还有其他问题吗？好，好的。那么，这仍然有相同的问题，对吧？所以它仍然有相同的问题，那就是存储这些按顺序排列的键查找页面的维护仍然是昂贵的。那么我们该怎么解决这个问题呢？好的。那么，让我们将应用到这些无序堆文件上的相同思路应用到这个问题上。
- en: key lookup pages and see how far we can push that。 So we can basically have。
    instead of having just one set of key lookup pages， we can have。 lookup pages
    for these lookup pages and then look up pages for the lookup pages for the。 lookup
    pages and so on， right？ And now that I have these lookup pages and look up pages
    for the lookup pages。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 键查找页面，看看我们能把它推进多远。所以我们基本上可以做的是，Instead of having just one set of key lookup
    pages， we can have lookup pages for these lookup pages and then look up pages
    for the lookup pages for the lookup pages and so on， right？ And now that I have
    these lookup pages and look up pages for the lookup pages.
- en: I no longer， require that these lookup pages are laid out in sequence， right？
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我不再要求这些查找页面按照顺序排列，对吧？
- en: So it basically have sort of， have eliminated that need and now my pages can
    be anywhere， right？
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它基本上已经消除了这个需求，现在我的页面可以放在任何地方，对吧？
- en: These pages， so this page which is basically a key lookup page or key lookup
    page to a。 key lookup page to a key lookup page is basically can be stored anywhere。
    Likewise。 this can be stored anywhere。 This can be stored anywhere as long as
    the correct pointers are maintained。 Okay。 And if this is sort of reminiscent
    of a binary search tree， well， it certainly does look like。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些页面，所以这个页面基本上是一个键查找页面或键查找页面到键查找页面到键查找页面，可以存储在任何地方。同样，这个可以存储在任何地方。只要正确的指针被维护着，任何地方都可以存储。好的。如果这让你想起了二叉搜索树，那确实看起来像是。
- en: that and we'll connect that back to the binary search tree in a little bit once
    we see how。 this kind of index structure is used。 Okay。 So that's a basic idea。
    Again。 if you don't follow how this structure works， let's really get into that。
    Don't worry about it。 The other thing that I've done in my illustration here is
    that I fixed the fan out so that the。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们稍后会将其与二叉搜索树联系起来，一旦我们了解这种索引结构是如何使用的。好的。这就是基本的想法。再说一遍，如果你没有理解这个结构是如何工作的，我们稍后会深入探讨。别担心。我在这张插图中做的另一件事是，我修复了扇出，确保它是合适的。
- en: fan out is much is larger than two in practice the indexing structure that we're
    going to。 be talking about the fan out is going to be much， much larger than two。
    Okay。 So the idea of just having lookup pages and then look up pages for the lookup
    pages and。 so on is essentially the idea behind the plus trees and the plus trees
    basically make it， really。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，扇出要大于二，我们即将讨论的索引结构中，扇出会比二大得多。好的。所以，仅仅使用查找页面，然后为查找页面查找页面，以此类推，基本上就是加号树背后的想法，而加号树基本上使得它非常高效。
- en: really efficient to add and delete records to maintain it and doing it all while。
    providing the same is symptotic guarantees and also fixing the fan out。 Right。
    So it has a higher fan out that allows us to not have a very deep tree。 It instead
    is a very wide tree and we'll talk about all of this when we introduce the， first。
    Billy。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 非常高效地添加和删除记录来维护它，同时确保提供相同的渐近保证，并且修复扇出。对吧？因此，它的扇出更高，这使得我们不需要一个非常深的树。它实际上是一个非常宽的树，我们将在介绍第一部分时讨论所有这些内容。
- en: you have a question？ Yes。 So how exactly does 27 on the bottom most row map
    to page three exactly？
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你有问题吗？是的。那么，最底行的 27 如何精确地映射到页面三呢？
- en: Yeah。 So it would basically be， so this is a key， right？
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以基本上是，这就是一个关键字，对吧？
- en: 27 is a key and here you have this record corresponding to two attributes， 27，
    which is。 first attribute and Joe being the second attribute。 And so this in this
    particular implementation and we'll talk about various implementations。 later
    in this particular implementation。 This location in this page also has a pointer
    to this particular record within this particular。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 27 是一个关键字，在这里你有这个记录，包含两个属性，27 是第一个属性，Joe 是第二个属性。所以在这个特定的实现中，我们稍后会讨论各种实现方式。在这个特定的实现中，这个页面中的这个位置也有指向这个特定记录的指针。
- en: page。 So it's basically encoding the page ID in this case page ID three and
    the slot ID within。 the page。 So I'm being a little sloppy here， but it's a slot
    ID within the page and we talked about。 the slotted page layout， right？ And so
    a record ID is basically a record pointer is basically the combination of the。
    page ID and the slot ID。 And that's really what this 27 is pointing to。 Okay。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 页面。所以基本上是在这种情况下编码页面 ID，即页面 ID 为三，以及页面中的槽 ID。所以我这里有点不严谨，但其实是在页面中的槽 ID，我们之前谈过过槽式页面布局，对吧？因此，记录
    ID 本质上是记录指针，是页面 ID 和槽 ID 的组合。这就是 27 所指向的内容。好的。
- en: So this 27 has like the page number that you already kind of knows what the
    page number， is。 No。 it's pointing to that page number。 It doesn't。 So here as
    you can see 24 actually none of these other ones are in this picture。 but， let's
    say let's imagine for a second that this is 24。 24 could certainly be pointing
    to a different page。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个 27 有类似页面编号的内容，你已经大致知道了页面编号，不对，它指向的就是这个页面编号。并不是。所以在这里，你可以看到 24 其实没有其他任何内容出现在这个图片中，但假设我们假设一下，这是
    24。24 当然可能指向另一个页面。
- en: So it doesn't mean that this corresponds neatly to a single page。 It could be
    all over the place。 Does that make sense？ Okay。 So you do need to maintain the
    page ID in addition to the slot ID within that page。 Okay。 Thank you。 Okay。 Any
    other questions？ All right。 So moving on。 Let's talk about the B plus tree。 So
    the B plus tree is really an indexing structure that is trying to deal with all
    of the issues。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这并不意味着它与单一页面完美对应。它可能分散在各处。明白了吗？好的。所以你确实需要维护页面 ID，以及页面中的槽 ID。好的，谢谢。好的。还有其他问题吗？好的。那么接下来，我们讨论
    B+ 树。B+ 树实际上是一种索引结构，旨在处理所有这些问题。
- en: we talked about in the variance that we talked about before this。 B plus tree
    is ubiquitous。 You see it everywhere。 It is a very powerful indexing structure。
    It is a dynamic tree index。 It allows you to modify add and delete records very
    effectively。 It's always balanced。 So that's a nice guarantee that the B plus
    tree provides and it maintains this balanced。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的方差就是指这个。B+ 树无处不在，你到处都能看到它。它是一种非常强大的索引结构，是一种动态树索引。它允许你非常有效地修改、添加和删除记录。它始终保持平衡。所以这是B+
    树提供的一个很好的保证，它保持这种平衡。
- en: nature even as data is inserted or deleted。 It also has high fan out which means
    that these trees are wider rather than deeper。 And this is important because if
    the path to the leaf is shorter， that means there are， fewer I/Os。 Right。 So if
    you have a long path to a leaf， that means there are more I/Os。 You don't want
    that。 The last property here that I want to mention is that it supports efficient
    insertion and， deletion。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据被插入或删除，B+ 树也能保持其结构的稳定性。它还具有较高的分支因子，这意味着这些树的宽度较大，而不是深度较深。这一点很重要，因为如果到叶节点的路径较短，就意味着I/O操作更少。对吧？所以，如果你到叶节点的路径较长，就意味着会有更多的I/O操作。你肯定不希望这样。这里我想提到的最后一个特点是它支持高效的插入和删除操作。
- en: You want to add or delete records based on the key you certainly can do so。
    And one interesting sort of nuance about the B plus tree is that it doesn't grow
    at the， leaf。 It actually grows the root。 And so that we'll see why that is the
    case in a little bit。 So why B plus and where does plus come from？ The terms of
    those are previous incarnation of the B plus tree called the B tree which。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想基于关键字添加或删除记录，你当然可以这么做。B+ 树的一个有趣的细节是，它并不是在叶节点处增长，而是在根节点处增长。所以我们稍后会看到为什么会这样。那么，为什么是
    B+ 树？“+” 代表什么呢？这些术语来源于 B+ 树的前身叫做 B 树。
- en: stores data in the intermediate nodes as well。 B plus tree store data entries。
    So basically pointers to the records in the leaves only。 And this is because it's
    helpful with range search and we'll talk about why that is the。 case in a little
    bit。 So almost always these days B trees are not used。 B plus trees are used。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 中间节点也存储数据。B+ 树存储的是数据条目，基本上是指向叶子中记录的指针。这是因为它在范围查询时非常有用，我们稍后会谈到为什么会是这种情况。所以现在几乎总是使用
    B+ 树，而不是 B 树。
- en: So this is the one that we're going to be studying。 Okay。 now let's talk about
    how to read the plus trees。 Okay， let's let's start with this interior node。 So
    this interior node as you can see has sorry， I'll go back or I go back。 Okay。
    so this interior node has pointers as you can see to the these would be the leaf，
    pages。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们要研究的那个节点。好的，现在我们来谈谈如何读取 B+ 树。好的，我们从这个内部节点开始。正如你所看到的，抱歉，我得退回去。好的，这个内部节点正如你看到的那样，有指向这些叶子页的指针。
- en: So I'm coloring them in gray and the ones that have the blue and light blue
    ones are。 the interior nodes。 So here the way to read this would be that this
    pointer between five and 13 corresponds。 to the fact that the values below this
    pointer in this leaf page have values key values greater。 than or equal to five
    and less than 13。 Okay， and that's only true for this example。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我把它们标成灰色，而那些蓝色和浅蓝色的部分是内部节点。这里的读取方法是，5 和 13 之间的指针表示在这个指针下方的叶子页面中的值的关键字大于或等于
    5 且小于 13。好的，这对这个例子是成立的。
- en: So this is five， seven and eight。 Okay， so then for this case， you have a pointer
    to this leaf。 Here this pointer points to values that lie between 13 on the one
    end and there is no。 upper bound on the other end because this slot has been not
    filled。 Okay。 Likewise， in this case。 you have an upper bound but no lower bound。
    So you have values that are less than five。 Okay。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是 5、7 和 8。好的，那么在这种情况下，你有一个指向这个叶子页面的指针。这里的指针指向的值介于 13 和另一个端点之间，而另一个端点没有上界，因为这个槽位还没有填满。好的。同样，在这个例子中，你有一个上界但没有下界。所以你有小于
    5 的值。
- en: and that's only true of these two values。 Okay， so this is one way of reading
    an interior node in a B plus tree。 Let's talk about another way of reading an
    interior node in a B plus tree， which is to。 think about an interior node as a
    pair of values and pointers。 Okay。 so this is one pair of value and pointer。 This
    is another pair of value and pointer。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅适用于这两个值。好的，这是读取 B+ 树内部节点的一种方式。接下来我们来谈谈另一种读取 B+ 树内部节点的方法，那就是把一个内部节点看作一对值和指针。好的，这是其中一对值和指针。这是另一对值和指针。
- en: This is a third combination of value and pointer。 And so what does this value
    and pointer actually mean？
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是值和指针的第三种组合。那么这个值和指针实际上是什么意思呢？
- en: Well， the value and pointer you。 So each interior node has a bunch of values
    and pointers and this light gray value here。 is not shown。 It can be effectively
    omitted， which is why it's omitted in to save space in these interior。 nodes，
    but you can imagine it to be zero in this case and that'll work for our example。
    So like I said， these interior nodes are combination of values and pointers。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，值和指针。每个内部节点有一堆值和指针，这里浅灰色的值没有显示。它可以被有效地省略，这就是为什么它在这些内部节点中被省略以节省空间，但你可以把它想象成在这个例子中是零，这对我们的例子是有效的。就像我说的，这些内部节点是值和指针的组合。
- en: So it's a key value and a pointer and the guarantee that the B plus tree is
    providing， is that K L。 which is the key value is less than or equal to K， which
    is the keys for。 all of the keys in the that is in the sub tree pointed to by
    the pointer。 Okay。 so if in this case this sub tree， which is pointed to by this
    pointer， all of the。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它是一个键值和一个指针，B+ 树提供的保证是，K L，即键值，必须小于或等于 K，也就是该指针指向的子树中的所有键。好的，如果在这种情况下，这个子树，它指向的这个指针，所有的。
- en: values are greater than or equal to zero。 Right， so this simple example in this
    particular case。 all of the values in this sub tree are， greater than or equal
    to five。 Likewise， for this pointer。 all the values are greater than or equal
    to 30。 Okay。 so this is another way of reading an interior node in a B plus tree
    and we'll be。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 值大于或等于零。对吧，所以在这个简单的例子中，在这个特定情况下，这个子树中的所有值都大于或等于五。同样地，对于这个指针，所有的值都大于或等于 30。好的，这也是另一种方式来读取
    B+ 树中的内部节点，我们将会继续。
- en: using both the piece representations in the following。 So I was just illustrating
    what this sub tree looks like for the case where I'm talking。 about five and the
    pointer corresponding to five。 Okay。 so here's how an entire B plus tree looks
    like。 Let's not worry about these pointers at the bottom for now。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下的片段表示法。所以我只是说明当我谈论五和对应五的指针时，这个子树的样子。好的，那么整个 B+ 树的样子是这样的。现在暂时不需要担心底部的这些指针。
- en: Let's talk about the structure of the tree and the values within each of the
    nodes。 So these are the interior nodes， these are leaf nodes。 And then the occupancy
    guarantee that the B plus tree provides is that each interior。 node is at least
    partially full。 Okay， and the guarantee that it provides it's it's between D to
    two D。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈树的结构以及每个节点中的值。这里是内部节点，那里是叶子节点。然后，B+ 树提供的占用保证是每个内部节点至少部分填满。好的，提供的保证是，节点的数量介于
    D 和 2D 之间。
- en: Okay， so two D plus one is a max number of pointers in the interior node。 In
    this case。 2D plus one is five。 Okay， and the guarantee that a B plus tree provides
    is that the number of entries in each。 intermediate node is going to be between
    two and four。 Again。 it maintains this guarantee as insertions and deletions happen。
    And so this D value。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以 2D+1 是内部节点中指针的最大数量。在这种情况下，2D+1 等于五。好的，B+ 树提供的保证是每个中间节点中的条目数量会介于二和四之间。同样，它在插入和删除发生时保持这个保证。所以这个
    D 值。
- en: which is the lower bond， is the known as the referred to as the order， of the
    tree。 Okay。 so it's referred to as the order of the tree。 So one exception for
    this rule is the root。 So the root doesn't need to obey this guarantee。 And as
    you can see in this example。 the root has only one value， doesn't have two values。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是下界，称为树的阶。好的，所以它被称为树的阶。所以这个规则的一个例外是根节点。根节点不需要遵循这个保证。正如你在这个例子中看到的，根节点只有一个值，没有两个值。
- en: All of the other interior nodes have two values。 I think the clavocation。 So
    in this case。 the interior node does not include the root node， right？ Is that
    the convention you're using？ I。 so the， I was referring to a root node as part
    of the interior node， but I did mention。 that the root node does not have to obey
    this。 So maybe it's better to call the interior nodes the nose and not the root
    nor the leaves。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他的内部节点都有两个值。我认为这是键的位置。所以在这种情况下，内部节点不包括根节点，对吧？这是你们使用的约定吗？是的，我把根节点当作内部节点的一部分，但我确实提到过，根节点不需要遵循这个规则。所以也许更好把内部节点称为“节点”，而不是根节点或叶子节点。
- en: Yeah， I guess we could call it that way。 Dependent depends on the convention。
    So I was just referring to interior nodes as being all the nodes that are not
    the leaf， nodes。 but we could separate it out as being root node， everything in
    the middle and then， leaf node。 That's also fine。 Any other questions？ There's
    a question about why is the equals to two。 Okay。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我想我们可以这么说。取决于惯例。所以我刚才是指内部节点，作为所有非叶子节点。但我们也可以把它分开，分别称为根节点，中间的所有节点以及叶子节点。这样也可以。还有其他问题吗？有一个问题是为什么值等于二。好的。
- en: so in this case， the backward computation that you can do is you can look at。
    You want each node to be half full。 You have four slots in terms of values and
    five pointers and you therefore want it to。 be half full and therefore you want
    it to have two values。 Okay。 so that's a guarantee that the B plus tree is providing。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下，你可以做的反向计算是，你可以查看。你希望每个节点都至少是半满的。你有四个槽位用于值，五个指针，因此你希望它是半满的，因而你希望它有两个值。好的。这个保证就是B+树提供的。
- en: So the root doesn't need to obey this and therefore it has just one value。 It
    could have。 So that's the only node， the only node in the interior of the tree
    that can dissipate。 this invariant。 Okay。 So the same deal holds for the leaf
    nodes by the way， at least。 So these leaf nodes have to be at least half full
    again， like these interior nodes。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所以根节点不需要遵守这个规则，因此它只有一个值。它可以有更多值。所以这是树内部唯一能够**消散**这个不变性的节点。好的。那么相同的规则也适用于叶子节点，至少是这样。所以这些叶子节点必须至少是半满的，就像这些内部节点一样。
- en: The deal value for the leaf nodes may differ in this particular instance， the
    value is， the same。 So again， all of these leaf nodes have at least two values
    or two keys and their pointers。 to the records。 Okay， so each of these leaf nodes
    also obey the same invariant。 And these invariants， which is every node is at
    least half full is except for the root。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子节点的处理值在这个特定实例中可能不同，当前值是相同的。所以再次强调，所有这些叶子节点都至少有两个值或者两个键，以及它们指向记录的指针。好的，所以这些叶子节点也遵守相同的不变性。这些不变性，指的是每个节点至少半满，根节点除外。
- en: is maintained throughout。 Okay。 So the other property of a B plus tree， which
    we。 if you go back to the very first slide， the leaf pages at the bottom don't
    need to be stored in。 in sequence， right？ So they could be stored in arbitrary
    pages。 In this particular example。 the first leaf node is stored in page two，
    the second is stored， in page three。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性是始终保持的。好的。B+树的另一个特性是，如果你回到第一张幻灯片，底部的叶页面不需要按顺序存储，对吧？因此，它们可以存储在任意页面中。在这个特定的例子中，第一个叶子节点存储在页面2，第二个存储在页面3。
- en: Then I have my interior node， which is stored in page four。 And then I have
    page five here。 page six here， page seven， here page eight page nine。 There is
    no constraint that says that these leaf nodes need to be stored in， in sequence，
    on disk。 On the other hand， because we are not showing them in sequence， it is
    helpful to have these。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是我的内部节点，存储在页面4。接着是页面5，页面6，页面7，页面8，页面9。没有规定这些叶子节点需要按顺序存储在磁盘上。另一方面，因为我们没有按顺序显示它们，所以有这些。
- en: pointers， allowing us to traverse these leaf nodes in order。 So the next and
    previous pointers will help examining them in sequence。 And we'll talk about why
    that's useful。 Okay， so let's talk about this fan out and how it impacts B plus
    trees as we increase。 the number of levels。 So in this particular example， I have，
    I'm being my， my。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 指针，允许我们按顺序遍历这些叶子节点。所以**下一个**和**上一个**指针将有助于按顺序检查它们。我们稍后会讨论为什么这很有用。好的，那么让我们来谈谈这个扇出和它如何影响B+树，当我们增加层数时。以这个特定的例子来说，我，**我**的。
- en: the order of my tree is two and， my fan out is five。 And therefore the number
    of records that I can support is 20。 Okay。 so I have five pointers here and each
    of these leaf pages can store four records。 So therefore this B plus tree can
    support 20 records。 Okay。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我的树的阶数是2，**我的扇出**是5。因此，我可以支持的记录数是20。好的。所以这里有五个指针，每个叶页面可以存储四个记录。所以这个B+树可以支持20条记录。好的。
- en: so each of these would point to a specific record。 Let's increase this a little
    bit。 So let's say I have a height three plus tree。 And so once again， the fan
    out， so the D is two。 so the order of this B plus tree is， unchanged。 And the
    fan out is once again， five。 And so I have five pointers out from the root node
    to intermediate or internal nodes。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些指针每个都指向一个特定的记录。让我们稍微增加一下这个值。假设我有一个高度为三的 B+ 树。所以再次强调，扇出度 D 是 2。因此，这棵 B+ 树的阶数保持不变。扇出度再次是
    5。所以，从根节点到中间节点或内部节点有五个指针。
- en: And from each of them， I have pointers out to five。 And from each of them。 I
    have pointers out to five。 Okay， so it's basically five times five times five
    times four because each of the leaf pages。 is 0。24 records。 Okay， so contain information
    about four keys。 So in total， I have 500 records。 information about 500 records
    or equivalently 500 keys。 Okay， any questions about this？ Okay。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从每个节点，我有五个指针。而从每个节点，我又有五个指针。好吧，基本上是五乘五乘五乘四，因为每个叶子页包含 0.24 条记录。好吧，这样包含四个键的相关信息。所以总的来说，我有
    500 条记录，或者说 500 个键的相关信息。好，有什么问题吗？好。
- en: So let's do some back of the envelope math to understand how B plus trees look
    in practice。 D is equal to two is a very unrealistic number。 So that is highly
    unlikely that you would have nodes in your real world B plus trees that。 have
    only four slots。 It's more typical to have a lot more slots。 The pages， for example。
    may be order of a few hundred kilobytes。 And let's say I assume like 40 bytes
    for this value and pointer pair。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们做一些简单的数学计算，来理解 B+ 树在实际中的表现。D 等于 2 是一个非常不现实的数字。所以在现实世界中的 B+ 树，节点只有 4 个槽位的情况是非常不可能的。通常来说，槽位会多得多。例如，页面的大小可能是几百千字节。假设每个值和指针对大约占
    40 字节。
- en: Right。 Remember that one way of thinking about these internal nodes is as a
    collection of value。 pointer pairs。 Now what this translates to roughly is basically
    around 3200 value pointer pairs per page。 So per internal node， for example。 And
    so this would roughly correspond to 2D or 2D plus one。 Let's piece sloppy and
    say that's 2D。 Okay。 And so since that's our 2D。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对了，记住，一种思考内部节点的方式是将其视为一组值-指针对。那么，粗略地说，这大约对应每页 3200 个值-指针对。所以每个内部节点，举个例子来说。然后，这大致对应于
    2D 或 2D+1。我们不那么精确地假设是 2D。好吧。所以既然是 2D。
- en: so the order is going to be D is going to be 1600。 And let's also assume that
    in a real world B plus tree， I have 2/3 of my entries filled， out。 Again。 we are
    being sloppy here and saying that this is what I expect each of my internal。 nodes
    to have in terms of its occupancy。 So I'm just going to be sloppy and say。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所以阶数是 D，将是 1600。再假设在现实世界的 B+ 树中，我的 2/3 的条目已被填充。再次提醒，我们在这里有点草率，假设每个内部节点的占用情况是这样的。所以我就草率地假设一下。
- en: let's say 2/3 of these entries are filled out。 So if 2/3 of these entries are
    filled out。 then the average fan out is going to be around， 2100。 Now as what
    that means in practice is that if I have a B plus tree of height one， then。 I
    can support lookups of around 4。5 million records。 And if it's a B plus tree of
    height two。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 2/3 的这些条目已被填充。如果这些条目有 2/3 被填满，那么平均的扇出度大约是 2100。实际上，这意味着如果我有一棵高度为 1 的 B+ 树，那么我可以支持大约
    450 万条记录的查询。如果是高度为 2 的 B+ 树。
- en: then I can support up to 10 billion records。 So this is a large increase。 And
    this is already a pretty large number of records for a fairly small B plus tree。
    And this is all because the fan out is super wide。 So you have in the max fan
    out here is like 3000。 But here we are assuming sort of a more modest 2/3 of that，
    right？ 2/3 filling。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我可以支持最多 100 亿条记录。所以这是一个大幅增加。而且，这对于一棵相对较小的 B+ 树来说，已经是相当大量的记录了。这一切都因为扇出度非常大。所以最大扇出度大约是
    3000。但在这里我们假设填充度为其 2/3，对吧？
- en: so which is around 2000 as opposed to 3200。 Even with that。 you can support
    a large number of records with a fairly shallow tree。 So B plus trees of depth
    five and six are not even necessary in such examples， right？
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，和 3200 相比，大约是 2000。即使如此，你也可以支持大量记录，同时保持树的深度较小。所以在这种情况下，深度为 5 和 6 的 B+ 树实际上并不需要，对吧？
- en: Unless you have a very， very large data set， right？ So even with a depth of。
    even with the height of 2， so 2 sets of internal nodes and then， a bunch of leaf
    nodes。 you can support 10 billion records。 Okay。 Any questions about this？ So
    Ditya。 there's a question about what D here refers to the height of the tree or
    the， number of entries。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有一个非常非常大的数据集，对吧？即使是高度为2，也就是有两层内部节点，然后是一堆叶子节点，你也可以支持100亿条记录。好吧，有没有关于这个的问题？Ditya，有人问这个D到底指的是树的高度，还是条目数。
- en: right？ And I think it's the height of the tree， right？ It is referring to the
    D or sorry。 the height。 Can you repeat the question， Evan？ Like people are asking
    about like what is D here refers to？
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？我认为这是树的高度，对吧？它是指D，或者说是高度。你能重复一下问题吗，Evan？人们在问这个D指的是什么？
- en: Oh， the D here， this D， this D refers to the order of the tree。 So it is basically
    the occupancy guarantee that the B plus tree provides for the internal， nodes。
    We're talking about the previous slide， the one with the D plus tree。 We were
    asking about what that， because the height of the tree was three， but we were。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这里的D，这个D，指的是树的阶。基本上，它是B+树为内部节点提供的占用保证。我们正在讨论上一张幻灯片，那个包含D+树的。我们在问这个问题，因为树的高度是三，但我们在讨论的是。
- en: asking what the D is equal to。 Oh， the D is still two， right？ So it's still
    the order of the tree。 It's basically ensuring that you have two， not for the
    root node。 For all the internal nodes。 you have at least two values filled in。
    So is the occupancy， is the minimum occupancy， right？
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在问D等于什么。哦，D仍然是2，对吧？所以它仍然是树的阶。它基本上确保你至少有两个值填充在所有内部节点中，而不是根节点。所以这是占用，最小占用，对吧？
- en: It is not the height of the tree， right？ Yeah， D is not referring to the height
    of the tree。 It's just the order of the tree， at least in the convention that
    I've been following。 So in this particular， if we are talking specifically about
    the example that I had here， let's work。 through this math， right？ I have one
    root node， right， so which has two， one， four， four。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是树的高度，对吧？是的，D不是指树的高度。它只是树的阶，至少在我遵循的约定中是这样。所以在这个具体的例子中，如果我们特别讨论我这里的例子，让我们来做一下这个数学计算，对吧？我有一个根节点，对吧，根节点有两个，1，4，4。
- en: let's say pointers out， and， then each of them has two， one， four， four pointers
    out。 And then I have each of these being leaf nodes， right？
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有指针向外，然后每个都有两个，1，4，4个指针向外。然后我有每个都是叶子节点，对吧？
- en: And so I guess I'm defining height a bit loosely。 Sorry， did I make a mistake
    here？ No， sorry。 I was making， I'm referring to this one and not this one。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想我在有些地方稍微宽松地定义了高度。抱歉，我在这里是不是犯了个错误？不，抱歉，我指的是这个，而不是那个。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_5.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_5.png)'
- en: Okay， let me scratch that and try again。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我重新开始，重新试一次。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_7.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_7.png)'
- en: Oops， keep。 Okay。 Okay， so scratch this， try again。 Okay， so height one， I have
    a root。 And I only have leaf pages， right？ So my fan out is around 2，000 from
    the root， and then around 2。000 from each of the leaf， pages。 So this is a tree
    of height one。 I'm just counting the internal nodes or the part of the tree that
    is internal as opposed。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，继续。好吧，好吧，重新开始，重新尝试。好的，所以高度是1，我有一个根节点。我只有叶子页，对吧？所以我的扇出从根节点开始大约是2,000，然后从每个叶子页开始大约是2,000。所以这是一个高度为1的树。我只是在计算内部节点，或者说树的内部部分，而不是。
- en: to the leaf， which why I'm calling this height。 I could instead talk about the
    depth and then call this two if I'd like。 And so this tree which has one level
    which corresponds to the root node and then one level。 which corresponds to the
    leaf nodes can support 2，000 times 2，000 roughly records， right？
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到达叶子节点，这就是我为什么称它为高度。如果我愿意，我也可以称之为深度，称它为2。这样，这棵树只有一层，这一层对应根节点，然后有一层。对应叶子节点，它可以支持大约2,000乘2,000的记录，对吧？
- en: And this tree which has three levels， the root and then one level of internal
    nodes， and。 then one level of leaf nodes can support 2，000 times 2，000 times 2，000，
    right？ Roughly。 And so this is roughly order of 10 billion records， let's say。
    Okay。 Does that make sense？
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 而这棵树有三层，根节点，然后一层内部节点，再然后一层叶子节点，它可以支持2,000乘2,000乘2,000的记录，对吧？大约。大致上说，这大约是100亿条记录。明白了吗？
- en: There's a question about like how that's 21， 44 comes about。 Okay。 So here I
    was being a little like I said， I was being a little sloppy。 So I have 3。200 overall
    slots。 Okay。 So that is my 2D。 That's a total number of things that I can point
    to。 I'm making an assumption and I'm saying， let's say two thirds of those are
    full。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有人问21，44是如何得到的。好的，所以我之前说得有点随便。我的总插槽是3200。好的。所以这是我的2D，这是我可以指向的所有内容的总数。我做了一个假设，假设其中三分之二的插槽已满。
- en: And so that's why I went from 3，000 to 2，000 roughly。 So why 3，200 2D？ Well。
    that is so I have if I went， okay， so going back to this， I have the page， the
    size。 of a page and then the number amount of information that I can encode in
    that page， right？
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是为什么我从3200减到大约2000的原因。那么为什么是3200 2D呢？嗯，那是因为我，如果我回到这个话题，我有一个页面的大小，然后我可以在这个页面中编码的信息量，对吧？
- en: So let's say the number of value pointer pairs that I can encode in a page for
    each of them。 I require 40 bytes。 And just dividing 128 kilobytes by 40 bytes
    gives me 3，200 slots。 That is the total number of slots that I have that I can
    use to point at other stuff。 That's a maximum number of slots。 So that is my 2D
    or 2D plus one if you want to count the pointers。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我可以在每个页面中编码的值指针对的数量，我需要40字节。将128千字节除以40字节，得到3200个插槽。这是我可以使用的总插槽数，用于指向其他内容。这是插槽的最大数量。所以这就是我的2D，或者如果你想计算指针的话，就是2D加一。
- en: So that's roughly the order of 2D。 Okay。 Again， I'm being very sloppy here。
    I just want to give you a sense for the magnitude， but hopefully you're getting
    that。 So the main takeaway from this is not 67% or 21， 4， 4 or 2D or 3，200 or
    9， 8， 5， 5， 4， 0， 1， 9， 8。 4。 It is a fact that with a very shallow tree， you
    can access a lot of records。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这大致是2D的阶数。好的，再次说明，我这里说得很随便。我只是想让你对规模有个大致的了解，但希望你能理解。所以这里的主要结论不是67%或21，4，4，或2D或3200或9，8，5，5，4，0，1，9，8，4。而是一个事实：用一个非常浅的树，你可以访问大量记录。
- en: So you don't need a very deep tree to get to a lot of records。 So that's the
    main point here。 It's okay if the details you don't get。 Carlos。 Hi， I just wanted
    to clarify what D is。 So D is。 is it the maximum or the minimum occupancy for
    a internal node？ It's the， it's a minimum occupancy。 right？ And it's typically
    half。 So basically the guarantee that you're providing is that the order of the
    tree。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你不需要一个很深的树结构就能访问很多记录。这是这里的主要点。如果你没有完全理解细节也没关系。Carlos，嗨，我只是想澄清一下什么是D。所以D是内部节点的最大占用率还是最小占用率？它是最小占用率，对吧？通常是半个占用率。所以基本上你提供的保证是树的阶数。
- en: which is the， minimum occupancy is half of the number of slots that you have。
    So it's， so your。 the number of slots in this， these examples have been four and
    you guarantee。 that there are at least two。 Okay， got it。 And then the next question
    you have fast is the chosen given or just random。 it's random。 We choose it when
    we are designing a big plus tree。 Right。 And。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，最小占用率是你拥有的插槽数的一半。所以，在这些例子中，插槽的数量是四个，并且你保证至少有两个插槽是满的。好的，明白了。那么接下来的问题是，选择的D值是给定的还是随机的？是随机的。我们在设计一个大加树时选择它。对的。
- en: and we'll talk about in the next set of slides， we'll talk about how we might
    want。 to pick that differently for the leaf pages and for the internal pages and
    all that。 But overall。 the way to think about D is it's the order， it's defined
    as the order of the， tree。 It is a guarantee that the D plus tree keeps maintaining。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的幻灯片中，我们将讨论如何为叶子页面和内部页面选择不同的编码方式等等。但总的来说，D的定义是树的阶数。它是一个保证，D加树保持的性质。
- en: It's typically half of the size of the half of the number of slots in the node，
    be it the。 leaf node or an internal node。 Isn't that 2D plus one rule only apply
    to the internal nodes and the root node。 So as in like the leaf nodes， the ones
    at the very end can have like any number of entries。 Yeah。 so， well， no， so I
    think the， the， the， so the internal nodes have a certain number。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它是节点中插槽数量一半的大小，无论是叶子节点还是内部节点。难道2D加一规则只适用于内部节点和根节点吗？所以像叶子节点那样，最末端的节点可以有任何数量的条目。对的。所以，嗯，不是的，我认为，嗯，内部节点有一个特定数量。
- en: of values and a certain number of pointers。 Right。 So the number of values is
    2D。 The fan out is 2D plus one， right， because you have one corresponding to the
    left and。 right for each of the values。 Right。 So you have， so in this particular
    case， you have one， two。 three， four， five pointers， and just four values， one，
    two， three， four。 Right。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 值的数量和一定数量的指针。对吧。所以值的数量是2D。扇出是2D加一，对吧，因为你每个值都有一个对应的左边和右边的指针。对。所以在这个特定的例子中，你有一个，两个，三个，四个，五个指针，而只有四个值，一个，两个，三个，四个。对吧。
- en: So between every two values and to the left of and the right of the right most
    value。 So that's why you have 2D and 2D plus one corresponding to the number of
    values and the。 number of pointers。 Now the leaf ones are distinct， right。 So
    leaf ones you have these keys and then pointers to the records directly。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在每两个值之间，左边和右边的最右侧值之间。所以这就是为什么你会有2D和2D加一，分别对应值的数量和指针的数量。现在，叶节点是不同的，对吧。所以叶节点你有这些键值，然后是指向记录的指针。
- en: And so it is basically the pointers is equivalent is you have a one to one correspondence
    between。 the pointers to the records and the keys themselves。 So in this particular
    example， the 2D。 which is the size of the leaf was again， four and。 the guarantee
    that we were providing was that half of this would be occupied。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，指针就相当于你有一个一对一的对应关系，指向记录的指针和键值本身。所以在这个特定的例子中，2D，即叶节点的大小，仍然是四个。我们提供的保证是其中一半将被占用。
- en: Then the number of records of any B plus tree would just be 2D plus one to the
    power of height。 of the tree times 2D。 Is that it？ Like I said， yes。 Okay。 Thank
    you。 Mm-hmm。 That's exactly what is happening here。 Right。 So we can add to the
    height of the tree times times four。 which is 2D。 Yep。 So why is there 2D？ I don't
    understand what's the difference between this and the former example with the。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 那么任何B+树的记录数将是2D加一的高度次方再乘以2D。是这样吗？像我说的，嗯。好的。谢谢。嗯嗯。这里发生的事情正是如此。对。所以我们可以将树的高度乘以四。就是2D。嗯。那为什么是2D？我不明白这个和之前的例子有什么不同。
- en: 2D。 So if you think about like， yeah， yeah。 If you think about the values that
    are in the internal node or the leaf node。 let's say， there are the same number
    of values， right。 So you have 2D in the internal node and 2D in the leaf node。
    Now the number of pointers in the internal node is one， the number of values plus
    one。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 2D。所以，如果你考虑一下，嗯，嗯。如果你考虑内部节点或叶节点中的值，假设它们的数量是相同的，对吧。那么你在内部节点中有2D，在叶节点中也有2D。现在，内部节点中的指针数量是一个，即值的数量加一。
- en: While the leaf node you have the number of pointers is the same as number of
    values。 So that's why the internal nodes， it's basically you have five in this
    case。 It is 2D plus one to the power of the height times 2D， which is the number
    of pointers。 from the leaf node。 That makes sense。 Should I need Peter root node
    or so， so， so。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 而在叶节点中，你有的指针数量和值的数量是一样的。所以这就是为什么内部节点在这个例子中基本上有五个。它是2D加一的高度次方再乘以2D，就是指针的数量。来自叶节点。这有道理吗？我需要定义根节点吗，还是，还是。
- en: the root is coming from， right？ So like the internal nodes all have five and
    you're saying the leaf one only has four。 Has four。 Yes。 Oh， okay。 So， so， so
    when we define D is to the leaf nodes only have four elements。 And why is it why
    is it four？ Because the structure of the leaf is very different， right？
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点来自哪里，对吧？所以像内部节点都有五个，而你说叶节点只有四个。四个。是的。哦，好吧。所以，当我们定义D时，叶节点只有四个元素。为什么是四个？因为叶节点的结构与其他节点非常不同，对吧？
- en: So the structure， so the leaf， so the internal nodes have pointers corresponding。
    So if you look at the an internal node， it is basically saying for， let's say
    this is， value V1， V2。 V3， V4。 So this is pointing to stuff that is less than
    V1。 This is pointing to stuff that is between V1 and V2 less than or equal to
    V1 and then， less than V2。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所以结构，叶节点，内部节点有相应的指针。所以如果你看一个内部节点，它基本上是说，假设这是值V1，V2，V3，V4。那么这个指针指向小于V1的内容。这个指针指向介于V1和V2之间的内容，小于或等于V1，然后小于V2。
- en: Sorry， greater than or equal to V1 less than V2。 And likewise for these pointers。
    so there is one plus the number of the values。 On the other hand， the leaf basically
    has keys V1。 V2， V3， V4。 And each of those keys directly has a pointer to the
    record， right？ So it's not。 you don't have one plus the number of values。 You
    have the same as the number of values。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，大于或等于V1小于V2。同样对于这些指针。因此，它是一个加上值的数量。另一方面，叶子节点基本上有键V1，V2，V3，V4。每个键直接指向记录，对吧？所以不是。你没有一个加上值的数量。你有的和值的数量一样。
- en: So it's like a different structure， basically。 Yeah， that's one way to think
    about it。 It's a different structure。 And often， I mean， the pointers might look
    different too， right？
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它基本上是一个不同的结构。是的，这是一种思考方式。它是一个不同的结构。而且，通常，我的意思是，指针也可能看起来不同，对吧？
- en: So it depends。 And we'll talk about various ways to design the leaf pages later。
    So there are three alternatives that you could use。 We'll talk about that later
    as well。 Thank you。 Now， we are assuming all the leaf nodes are four。 Not necessarily。
    This is the max number of records， right， in this case。 So in fact， leaf nodes，
    again。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这取决于情况。稍后我们会讨论设计叶子页面的不同方式。你可以使用三种替代方案。我们稍后也会讨论这些。谢谢你。现在，我们假设所有的叶子节点都是四个。并不一定。这是最大记录数，对吧，在这种情况下。所以实际上，叶子节点，再次强调。
- en: you have a similar guarantee of them being half full。 Professor。 could you clarify
    the convention for height？ So in this case， in this picture。 the height 3 is like
    you have two layers in interior nodes。 and then you have one layer for the leaves。
    On the next slide， it was like you had。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你对它们半满的保证是类似的。教授，您能解释一下高度的约定吗？所以在这种情况下，在这张图中，高度3就像是你在内部节点有两层，然后你有一层用于叶子节点。下一张幻灯片就像是你有。
- en: the next slide at the bottom is the height of， one gave like 2，144 squared。
    which is kind of like you just had your leaf nodes。 So like is the height。 the
    total number of interior nodes plus the leaf， like layer from， the leaf node nodes
    or is it？
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张幻灯片的底部是1的高度，像2，144的平方。这就像是你只把叶子节点留在那。那就是高度。总的来说，内节点的数量加上叶子节点层次，从叶子节点的节点来看，还是吗？
- en: Yeah， I think I got confused in the next slide。 But basically， what I was trying
    to indicate is you。 the height is everything except for， the leaf nodes。 So the
    leaf nodes is a separate layer。 So in this case， you have three layers of nodes
    to the root。 So this is one layer。 this is a second layer， and then there's a
    third layer。 So it's 5 to the power of 3 times 4。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我想我在下一张幻灯片时搞混了。但基本上，我想表示的是，高度是指除了叶子节点以外的所有内容。所以叶子节点是一个单独的层次。因此，在这种情况下，你有三层节点到根节点。所以这是第一层，这是第二层，然后是第三层。所以是5的3次方乘以4。
- en: which is for the leaf nodes， right？ So that is for this slide。 And then for
    this slide， I had。 for height 1， I have basically， I have the root node and， that's
    it， right？
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对叶子节点的，对吧？所以就是这一张幻灯片的内容。然后对于这一张幻灯片，我有。对于高度1，我基本上只有根节点，就这些，对吧？
- en: So there's nothing else in the tree and everything else is a leaf node。 And
    so that's when you can support。 So it's the same convention in both slides that's
    just got confused。 Correct， thank you。 I think the water。 Yeah， so I want to ask。
    what point will we discuss the trade-offs between using a B+， tree instead of
    a B3？
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所以树中没有其他内容，其他的一切都是叶子节点。就是这样，才可以支持。所以这两张幻灯片的约定是一样的，只是我搞混了。没错，谢谢你。我想水。是的，所以我想问一下，我们什么时候讨论使用B+树代替B3树的权衡？
- en: We will talk about that when we talk about basically how you use B+ tree to
    fetch data。 so especially range-predicate。 So at the highest level。 if you want
    to basically find values that lie within a certain range。 then it's efficient
    to have all of the pointers to the data at the bottom， because as soon。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在讨论如何使用B+树来获取数据时谈论这个，尤其是范围谓词。所以在最高层次上，如果你基本上想找到位于某个范围内的值，那么把所有指向数据的指针放到底部是高效的，因为一旦。
- en: as you find the first page that matches， then you can just scan。 That helps
    you avoid having to go back up the tree and come back down。 Awesome， thank you。
    Okay。 Just to clear my understanding， so in the case that if we're following the
    convention。 from the previous slide for a height 1 B+ tree， we're a fan-out of
    2144。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到匹配的第一页，就可以直接扫描。那可以帮助你避免必须回到树的上层然后再下来。太棒了，谢谢你。好的。为了澄清我的理解，如果我们遵循上一张幻灯片的约定，对于一个高度为1的B+树，我们的扇出是2144。
- en: And we assume the maximum records would be that 2144 times 3200， right？ No。
    so the maximum number of records would be 3200， right？ Because that's 2D times
    3200， roughly。 Maybe this should be 3200 plus 3200 and 1 times 3200 or something。
    But that's roughly the order of mine。 I do。 The maximum records also assumes that
    every fan-out is also the maximum number of like a page。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设最大记录数是2144乘以3200，对吗？不。所以最大记录数是3200，对吗？因为那是2D乘以3200，大约是这样。也许这应该是3200加3200，再加上1次3200之类的。但是大体上是这个数量级。我知道。最大记录数也假设每次分支都是最大数量的页面。
- en: Thank you。 Yeah， Warren， did you have another question or was that the whole
    question？
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。是的，沃伦，你还有其他问题吗，还是这就是全部问题？
- en: That was the whole question。 Okay。 All right。 Let's see you folks on Tuesday。
    Do you have time for one more question？ Sure。 So this was just a question that
    already was answered。 which was the size of K versus the， size of B， like a couple
    of slides ago。 I didn't quite follow that。 So my intuition is that each block
    can contain multiple records。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个问题。好的。好了。我们周二见。你们还有时间问一个问题吗？当然。那么这是一个已经回答过的问题，就是关于K的大小与B的大小，就像几张幻灯片之前提到的。我没有完全理解。我的直觉是每个块可以包含多个记录。
- en: So that makes me think that K would be greater than B。 So what was I missing
    here？ Yeah， so I mean。 okay。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这让我觉得K应该大于B。那么我在这里错过了什么？是的，我的意思是，好吧。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_9.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_9.png)'
- en: So I think that same K can， so just like the data blocks can contain multiple
    records。 the key blocks can also contain multiple keys。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我认为那个相同的K可以...就像数据块可以包含多个记录一样，键块也可以包含多个键。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_11.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_11.png)'
- en: So here I was trying to convey that you could store。 There is a lot fewer。 So
    again。 going back to my students example， and you have the keys corresponding
    to student， names。 and you have a lot more attributes。 There's a limited number
    of records you will be able to pack into a given page。 and therefore， you may
    need to have a lot of pages。 On the other hand， here these pages。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，我试图传达的是，你可以存储的东西要少得多。再说一次。回到我的学生例子，你有对应学生名字的键，并且有很多属性。你能够放入给定页面的记录数量是有限的，因此你可能需要很多页面。另一方面，这些页面。
- en: these key lookup pages， all you need to store is， basically the keys and the
    pointers。 And that's it。 You don't need to worry about anything else。 You don't
    need to store the remaining attributes。 So there's a lot more keys that you can
    pack into a given page。 On the other hand， you can't pack as much information
    into a given page corresponding。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些关键查找页面中，你基本上只需要存储键和值指针。就这样。你不需要担心其他任何事情。你不需要存储剩余的属性。因此，你可以在给定的页面中放入更多的键。另一方面，你不能将太多信息放入相应的页面中。
- en: to the data because you have to store all the attributes。 Okay。 So which part
    of that is not clear？
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 至于数据，因为你必须存储所有的属性。好的。那么哪部分不清楚呢？
- en: Well， so your answer just now was kind of sound like it was like records per
    page versus。 keys per page。 But then I thought the comparison was between the
    total number of keys and the total number。 of pages。 Yeah。 So but that's what
    it influences。 If you can pack more keys into a page。 you need fewer pages to
    store all the keys。 If you can pack more records。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以你刚才的回答听起来像是每页的记录数与每页的键数之间的比较。但我以为比较的是键的总数与页面的总数。对。所以那是它的影响。如果你能在一个页面中放入更多的键，你就需要更少的页面来存储所有的键。如果你能放入更多的记录。
- en: if you can pack only fewer records within a page， then you。 need more blocks
    and therefore B will be larger。 That's the order magnitude difference that we're
    talking about。 So K was basically number of keys。 And I was making the claim that，
    hey， let's say you have。 I don't know， that's the case， but how do I say this？
    Okay。 So K is the number of keys。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只能在页面内放入更少的记录，那么你需要更多的块，因此B会更大。这就是我们所说的数量级差异。因此，K基本上是键的数量。我在做出这个声明时，嘿，假设你有...我不知道，这是情况，但我该怎么说呢？好的。K是键的数量。
- en: The number of pages that you would need to store the information corresponding
    to these。 K keys is likely to be a lot smaller than the number of pages that you
    would need to。 store information about all of the records。 And so at least at
    that level， hopefully it is clear。 Okay。 Yeah。 Question about K and B in this
    page， right？
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的页面数来存储与这些 K 键对应的信息，可能远远小于你需要的页面数来存储所有记录的信息。所以至少在这个层面，希望这是清楚的。好的，嗯，关于这一页中的
    K 和 B 的问题，对吧？
- en: What is the example for K and B in this page？ Here I was。 I guess I was conveying
    the total number of keys here。 Order of 40。 But I've not actually shown all the
    pages of data。 So I can't really make that claim。 I don't know how many pages
    of data it would be。 So I don't know what B is going to be for this example。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这一页中 K 和 B 的例子是什么？这里我猜我在传达的是这里的总键数，约 40。但我实际上没有展示所有数据页。所以我不能真的做出那个声明。我不知道需要多少数据页。所以我不知道在这个例子中
    B 会是多少。
- en: Well， so K is still the number of keys that we want to store， right？
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，K 仍然是我们想要存储的键的数量，对吧？
- en: And then B is the number of pages that is needed， right？ Nathan， does that answer
    your question？
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 B 是需要的页面数，对吧？Nathan，这回答你的问题了吗？
- en: Okay。 Yes。 Okay。 Sorry， I have another question。 Sure。 So here。 I would say
    that B plus three in the index or in the note that do not contain any， records，
    right？
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是的。抱歉，我有另一个问题。没问题。那么在这里，我会说索引中的 B 加三是指那些不包含任何记录的节点，对吧？
- en: Shall I say it again？ So in those intermediate notes， they do not contain any
    records。 But why not？
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我再说一遍吗？所以在那些中间节点中，它们不包含任何记录。那为什么不呢？
- en: I mean， isn't that just like if some records is in the intermediate notes， then
    we can just。 get the record and we don't need to traverse down to the leaf note。
    Yeah。 So that is a tradeoff。 right？ There is a benefit to looking to not having
    to get additional pages and traverse down。 But I think in most cases， the benefits
    of being able to look up records in sequence。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，如果某些记录在中间节点中，那我们可以直接获取该记录，而不需要向下遍历到叶节点。对，这就是一种权衡，对吧？有一个好处是你不必额外获取页面并向下遍历。但我认为在大多数情况下，按顺序查找记录的好处更大。
- en: for a rain scan， outweighed the benefits that come from sort of looking up records
    and intermediate。 nodes。 Okay。 And we'll talk about the rain scan in the next
    lecture。 Oh， I see。 And also。 if you actually store the record in the interior
    note， then you are reducing the。 number of pointers that you can actually store，
    right？ So the fan out is actually going to be lower。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于范围扫描，权衡考虑到从中间节点查找记录的好处。好的，我们将在下节课讨论范围扫描。哦，我明白了。而且，如果你真的将记录存储在内部节点中，那么你就减少了实际上可以存储的指针数量，对吧？所以分支因子实际上会更低。
- en: Yeah。 So storing the record is usually a bad idea because you're reducing the
    amount of space。 that you have for storing other things。 But assuming what you
    meant was a pointer to the record rather than record itself。 even， that is a bad
    idea。 Or at least it's not as good as being able to support rain scans。 Okay。
    So， so there's a tradeoff between like how to choose the fan out， how big the
    fan should， be， right？
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。所以存储记录通常不是一个好主意，因为你减少了存储其他事物的空间。但假设你的意思是存储指向记录的指针，而不是记录本身，那么即使如此，这也是个坏主意。或者至少它不如支持范围扫描那么好。好的，所以，这里有一个权衡，如何选择分支因子，分支因子的大小应该是多少，对吧？
- en: Yeah。 Yes。 I mean， that is determined based on the amount of data that you have。
    In fact。 the project that you're going to be doing， you're going to determine
    the fan。 out based on the kind of information that you're storing。 I see。 Okay。
    One last question。 So how do we assign the index here are just index like somehow
    reflect some orders in the。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错。我的意思是，这取决于你拥有的数据量。事实上，你要做的项目中，你将根据存储的信息类型来确定分支因子。我明白了。好的，最后一个问题。那么我们如何分配索引，这些索引是否在某种程度上反映了某些顺序？
- en: records or like how are they generated？ Sorry， I'm not sure I follow。 So the
    index here。 say the 17 in the root， the five and 13， how are they generated？ Are
    they reflect some orders or？
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是怎么生成的，或者说，它们是怎么生成的？抱歉，我不太明白你的意思。那么这里的索引，比如根节点中的 17，5 和 13，它们是怎么生成的？它们是否反映了某种顺序，还是……？
- en: No， it's reflecting some attribute in your relation， right？
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 不，它反映了你关系中的某个属性，对吧？
- en: So you're basically trying to retrieve the data corresponding to some attribute
    in your， relation。 So， Alvin mentioned sort of why your content， what an index
    actually does， right？ And it。 it is basically to support efficient access corresponding
    to some attribute。 So that attribute could be a string like the name。 It could
    be some number。 For example。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你基本上是在尝试检索与你的关系中的某个属性对应的数据。所以，Alvin提到过为什么你的内容，索引实际上是做什么的，对吧？它基本上是为了支持对应某个属性的高效访问。所以这个属性可以是像名字这样的字符串，也可以是某个数字。例如。
- en: it could be based on， I don't know， student ID。 It could be based on something
    else， right？
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以基于，我不知道，学生ID。也可以基于其他什么东西，对吧？
- en: It could be anything。 No， but it's typically an attribute in your relation。
    Or something that you think is a primary key， right？ And in SQL， for instance。
    Yeah。 Okay。 But see the， like the index， some of the index are not the attributes
    in any of the records。 You can construct indexes based on combinations of values
    in attributes for a given record。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是任何东西。不，但通常它是你关系中的一个属性。或者你认为是主键的东西，对吧？比如在SQL中。是的。好的。但是看，像索引，有些索引并不是任何记录中的属性。你可以基于给定记录中属性值的组合来构建索引。
- en: So these are known as composite indexes。 So you can certainly do that。 You can
    actually even store partial indexes and things like that。 Things get fairly complicated。
    but it's usually corresponding to some particular attribute in。 your relation
    of combination of attributes in some way。 Okay。 All right。 Yeah。 Yeah。 So for
    now。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为复合索引。所以你当然可以这么做。你甚至可以存储部分索引之类的东西。事情变得相当复杂，但通常对应于你的关系中的某个特定属性或某种方式的属性组合。好，好的。是的。暂时是这样。
- en: just think of it as like， you know， the， the， the value of the key that you。
    have defined in your table， right？ So in a sandwich example， that will be。 so
    what you see here will be like the sailor ID， right？ Like 17， right？ Yeah。 So
    basically。 what do you， what do you want to use to retrieve your data？ Right。
    Think about it that way。 I mean。
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 就把它当作你在表中定义的键的值，对吧？所以在三明治的例子中，那就是你看到的海员ID，对吧？像17，对吧？是的。所以基本上。你想用什么来检索你的数据？对吧？以这种方式来考虑。我是说。
- en: that's another way of thinking about it。 What you're uniquely determining。 what
    uniquely determines the rows of your relation。 So a key or what you might need
    to use to retrieve your data。 Right。 So if you want to often retrieve your data
    corresponding to student ID， then use that。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种思考方式。你唯一确定的是什么，唯一决定你关系中行的是什么。所以一个键或者你可能需要用来检索数据的东西，对吧？所以如果你经常想根据学生ID来检索数据，那么就使用它。
- en: as your use that to construct your index， for example。 Okay。 Got it？ Okay。 All
    right。 Yeah。 Sounds good。 Alvin， you want to sync up briefly？ Okay， sure。 Okay。
    Okay。 All right。 Thanks。 everyone。 See you guys next week。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用它来构建索引时，例如。好，明白了吗？好，好的。对。听起来不错。Alvin，你想稍微同步一下吗？好的，当然。好的。好的。好的，谢谢大家。下周见。
- en: '![](img/b69a04ef8bb90699b5facc602c0655d9_13.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69a04ef8bb90699b5facc602c0655d9_13.png)'
- en: Bye， folks。 next week。 Bye folks。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 再见，大家，下周见。再见大家。
