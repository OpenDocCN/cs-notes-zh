- en: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P11：L3- 优化算法 1 (优化，局部搜索，Hill Climbing)
    - ShowMeAI - BV1AQ4y1y7wy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-AI ｜ Python人工智能入门(2020·完整版) - P11：L3- 优化算法 1 (优化，局部搜索，爬山算法) - ShowMeAI
    - BV1AQ4y1y7wy
- en: '![](img/12696b090026272c3abe48d2abb04c6f_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12696b090026272c3abe48d2abb04c6f_0.png)'
- en: '[Music]，okay welcome back everyone to an，introduction to artificial intelligence。with
    Python and now so far we''ve taken a，look at a couple of different types of。problems
    we''ve seen classical search，problems where we''re trying to get from。an initial
    state to a goal by figuring，out some optimal path we''ve taken a look。'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[音乐]，欢迎大家回到关于人工智能的介绍，使用Python。目前为止，我们已经看过几种不同类型的问题，我们看到经典的搜索问题，在这些问题中，我们试图从初始状态到达目标，通过找出一些最佳路径。'
- en: at adversarial search where we have a，game playing agent that it's trying to。make
    the best move we've seen，knowledge-based problems when we're。trying to use logic
    and inference to be，able to figure out and draw some。additional conclusions and
    we've seen，some probabilistic models as well where。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在对抗性搜索中，我们有一个游戏代理，它试图做出最佳移动。我们已经看到基于知识的问题，当我们试图使用逻辑和推理来弄清楚并得出一些额外结论时，我们也看过一些概率模型。
- en: we might not have certain information，about the world but we want to use the。knowledge
    about probabilities that we do，have to be able to draw some conclusions。today
    we're going to turn our attention，to another category of problems。generally known
    as optimization problems，where optimization is really all about。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能没有关于世界的某些信息，但我们希望利用我们拥有的概率知识来得出一些结论。今天我们将把注意力转向另一类问题，通常被称为优化问题，优化实际上是关于。
- en: choosing the best option from a set of，possible options and we've already seen。an
    optimization in some contexts like，game playing where we're trying to。create an
    AI that chooses the best move，out of a set of possible moves but what。we'll take
    a look at today is a category，of types of problems and algorithms to。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从一组可能的选项中选择最佳选项，我们已经在某些上下文中看到了一些优化，比如游戏玩法，我们试图创建一个选择最佳移动的人工智能，在一组可能的移动中。但今天我们要看的是一类问题和算法。
- en: solve them that can be used in order to，deal with a broader range of potential。optimization
    problems and the first of，the algorithms that we'll take a look at。![](img/12696b090026272c3abe48d2abb04c6f_2.png)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的算法可以用于处理更广泛的潜在优化问题，而我们将要看看的第一个算法是。![](img/12696b090026272c3abe48d2abb04c6f_2.png)
- en: is known as a local search and local，search differs from search algorithms。we've
    seen before in the sense that the，search algorithms we've looked at so far。which
    are things like breadth-first，search or a-star search for example。generally maintain
    a whole bunch of，different paths that were simultaneously。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为局部搜索，局部搜索与我们之前看到的搜索算法不同，因为到目前为止，我们看到的搜索算法，比如广度优先搜索或A*搜索，通常会维持一大堆不同的路径，同时。
- en: exploring and we're looking at a bunch，of different paths at once trying to。find
    our way to the solution on the，other hand in local search this is going。to be
    a search algorithm that's really，just going to maintain a single node。looking
    at a single state and will，generally run this algorithm by。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索时，我们同时查看一堆不同的路径，试图找到解决方案。另一方面，在局部搜索中，这将是一个搜索算法，实际上只会维持一个单一节点，查看一个单一状态，并通常通过运行此算法。
- en: maintaining that single node and then，moving ourselves to one of the。neighboring
    nodes throughout this search，process and this is generally useful in。context not
    like these problems which，we've seen before like a maze solving。situation where
    we're trying to find our，way from the initial state to the goal。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 维持那个单一节点，然后在整个搜索过程中将自己移动到邻近的节点，这在上下文中通常是有用的，不像我们之前看到的那些问题，比如迷宫求解情况，我们试图从初始状态找到目标。
- en: by following some path but local search，is most applicable when we really don't。care
    about the path at all and all we，care about is what the solution is and。in the
    case of a solving a maze the，solution was always obvious you could。point to the
    solution you know exactly，what the goal is and the real question。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了通过某些路径来进行搜索，但局部搜索最适用于我们根本不在乎路径的情况，我们关心的只是解决方案。在解决迷宫的情况下，解决方案总是显而易见的，你可以指向解决方案，你确切知道目标是什么，真正的问题是。
- en: is what is the path to get there but，local search is going to come up in。cases
    where figuring out exactly what，the solution is exactly what the goal，looks like
    is。the heart of the challenge and to give，an example of one of these kinds of。problems
    we'll consider a scenario where，we have two types of buildings for。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到达那里需要什么路径？但是局部搜索在这种情况下会出现，其中准确找出解决方案的目标是什么正是挑战的核心。为了举一个这样的例子的例子，我们将考虑一个场景，其中有两种类型的建筑。
- en: example we have houses and hospitals and，our goal might be in a world that's。formatted
    as this grid where we have a，whole bunch of houses a house here house。here two
    houses over there maybe we want，to try and find a way to place two。hospitals on
    this map so maybe a，hospital here and a hospital there and。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有房屋和医院，我们的目标可能是在这样一个网格格式的世界中，其中有很多房屋，一个房屋在这里，一个房屋在这里，两个房屋在那边，可能我们想要找到一种方法在这张地图上放置两个医院。
- en: the problem now is we want to place two，hospitals on the map but we want to
    do。so with some sort of objective and our，objective in this case is to try and。minimize
    the distance of any of the，houses from a hospital so you might。imagine all right
    what's the distance，from each of the houses to their nearest。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是我们想在地图上放置两个医院，但我们希望有某种目标，而我们在这种情况下的目标是尽量减少任何房屋到医院的距离。因此，你可能想知道，从每个房屋到最近医院的距离是多少。
- en: hospital there are a number of ways we，could calculate that distance but one。way
    is using a heuristic we've looked at，before which is the Manhattan distance。this
    idea of how many rows and columns，would you have to move inside of this。grid layout
    in order to get to a，hospital for example and it turns out if。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在医院之间，我们可以有多种方式来计算距离，但一种方法是使用我们之前提到的启发式，即曼哈顿距离。这种方法是计算在这个网格布局中，你需要移动多少行和列才能到达医院，例如，如果。
- en: you take each of these four houses and，figure out all right how close are they。to
    their nearest hospital you get，something like this where this house is。three away
    from a hospital this house is，six away and these two houses are each。four away
    and if you add all those，numbers up together you get a total cost。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拿这四个房屋，看看它们离最近的医院有多近，你会得到这样的结果：这所房屋离医院三单位，这所房屋离医院六单位，而这两所房屋各离医院四单位。如果将这些数字加起来，你会得到一个总成本。
- en: of 17 for example so for this particular，configuration of hospitals a hospital。here
    and a hospital there that state we，might say has a cost of 17 and the goal。of
    this problem now that we would like，to apply a search algorithm to figure。out
    is can you solve this problem to，find a way to minimize that cost。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以17为例，所以在这个特定的医院配置中，一个医院在这里，另一个医院在那，这种状态我们可以说其成本为17。现在我们希望应用搜索算法来解决这个问题，找出如何最小化这个成本。
- en: minimize the total amount if you sum up，all of the distances from all the houses。to
    the nearest hospital how can we，minimize that final value and if we。think about
    this problem a little bit，more abstract abstracting away from this。specific problem
    and thinking more，generally about problems like it you can。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将所有房屋到最近医院的距离加起来，总体量如何最小化？如果我们稍微抽象化一下这个问题，从这个具体问题中抽离，考虑更普遍的类似问题。
- en: often formulate these problems by，thinking about them as a state space。landscape
    as will seem Colin here in，this diagram of a state space landscape。each of these
    vertical bars represents a，particular state that our world could be。in so for
    example each of these vertical，bars represents a particular。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过将这些问题视为状态空间来构造这些问题。正如科林在这个状态空间景观的图示中所展示的那样，每个垂直条代表我们世界中可能的一个特定状态。
- en: configuration of two hospitals and the，height of this vertical bar is generally。going
    to represent some function of that，state some value of that state so maybe。in
    this case the height of the vertical，bar wrappers，and what is the cost of this
    particular。configuration of hospital ism in terms，of what is the sum total of
    all the。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 两个医院的配置，垂直条的高度通常表示那个状态的一些函数，某个值。因此，也许在这种情况下，垂直条的高度代表这个特定医院配置的成本。
- en: distances from all of the houses to，their nearest hospital and generally。speaking
    when we have a state-space，landscape we want to do one of two。things we might
    be trying to maximize，the value of this function trying to。find a global maximum
    so to speak of，this state space landscape a single。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有房屋到其最近医院的距离，通常而言，当我们有一个状态空间时，我们想做两件事情之一：我们可能试图最大化这个函数的值，试图找到一个全球最大值，可以说这个状态空间的单个。
- en: state whose value is higher than all of，the other states that we could possibly。choose
    from and generally in this case，maximum，we'll call the function that we're。trying
    to optimize them some objective，function some function that measures for。any given
    state how good is that state，such that we can take any state pass it。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的值高于我们可能选择的所有其他状态，通常在这种情况下，我们将称之为最大值，我们要优化的函数称为某个目标函数，这是一个衡量给定状态的好坏的函数，以便我们可以传递任何状态。
- en: in to the objective function and get a，value for how good that state is and。ultimately
    what our goal is is to find，one of these states that has the highest。possible
    value for that objective，function an equivalent but reversed。problem is the problem
    of finding a，global minimum some state that has a。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输入到目标函数中，并获得该状态的好坏值，最终我们的目标是找到这些状态中的一个，使其在该目标函数下具有最高的可能值。而等价但反向的问题是寻找全局最小值的问题，即找到某个状态，其具有。
- en: value after you pass it into this，function that is lower than all of the。other
    possible values that we might，choose from and generally speaking when。we're trying
    to find a global minimum we，call the function that we're calculating。a cost function
    generally each state has，some sort of cost whether that cost is a。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将其传递到这个函数后，得到的值低于我们可能选择的所有其他值，一般而言，当我们试图寻找全局最小值时，我们称之为正在计算的函数为成本函数，通常每个状态都有某种成本，无论该成本是。
- en: monetary cost or a time cost or in the，case of the houses and hospitals we've。been
    looking at just now a distance cost，in terms of how far away each of the。houses
    is from a hospital and we're，trying to minimize the cost find the。state that has
    the lowest possible value，of that cost so these are the general。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 货币成本或时间成本，或者在我们刚才看的房屋和医院的情况下，是距离成本，衡量每个房屋距离医院的远近，我们要尽量减少成本，找到具有最低可能成本值的状态，这些是一般情况。
- en: types of ideas we might be trying to go，for within a state space landscape。trying
    to find a global maximum or，trying to find a global minimum and how。exactly do
    we do that will recall that，in local search we generally operate。this algorithm
    by maintaining just a，single state just some current state。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能在状态空间中尝试的一些想法，试图找到全局最大值或全局最小值，我们到底是如何做到的，将会回忆起，在局部搜索中，我们通常通过维持一个单一状态来操作这个算法，也就是某个当前状态。
- en: represented inside of some node may be，inside of a data structure where we're。keeping
    track of where we are currently，and then ultimately what we're going to。do is
    from that state move to one of its，neighbor States so in this case。represented
    in this one dimensional，space by just the state immediately to。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个节点内部表示的状态可能是在一个数据结构中，我们在其中跟踪当前的位置，最终我们要做的就是从该状态移动到它的一个邻居状态，在这种情况下，这个状态在一维空间中由紧邻的状态表示。
- en: the left or to the right of it but for，any different problem you might define。what
    it means for there to be a neighbor，of a particular state in the case of a。hospitals
    for example that we were just，looking at a neighbor might be moving。one hospital
    one space to the left or to，the right or up or down some state that。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 向左或向右移动，但对于任何不同的问题，你可能会定义某个状态的邻居的含义，例如在我们刚才查看的医院案例中，邻居可能是将一个医院移动一个空间到左边或右边，或者上下移动某个状态。
- en: is close to our current state but，slightly different，and as a result might have
    a slightly。different value in terms of its，objective function or in terms of its。cost
    function so this is going to be our，general strategy in local search to be。able
    to take a state maintaining some，current node and move where we're。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接近我们当前的状态，但略有不同，因此在其目标函数或成本函数上可能有略微不同的值，所以这将是我们在局部搜索中的一般策略，以便能够保持一个状态，维持某个当前节点并移动到我们。
- en: looking at in the state space landscape，in order to try to find a global maximum。or
    a global minimum somehow and perhaps，the simplest of algorithms that we could。use
    to implement this idea of local，search is an algorithm known as hill。climbing
    and the basic idea of hill，climbing is let's say I'm trying to。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态空间的景观中，试图找到一个全局最大值或全局最小值。也许我们可以用来实现这个局部搜索理念的最简单算法是一个称为爬山算法的算法，爬山算法的基本思路是，假设我在尝试。
- en: maximize the value of my state I'm，trying to figure out where the global。maximum
    is I'm gonna start at a state，and generally what hill climb is go is。going to
    do is it's going to consider，the neighbors of that state that from。this state
    you know alright I could go，left or I could go right and this。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化我的状态值，我试图弄清楚全局最大值在哪里。我将从某个状态开始，通常爬山算法将考虑那个状态的邻居，从这个状态出发，我知道我可以向左或向右走。
- en: neighbor happens to be higher and this，neighbor happens to be lower and in hill。climbing
    if I'm trying to maximize the，value I'll generally pick the highest。one I can
    between the state to the left，and right of me this one is higher so。we'll go ahead
    and move myself to，consider that state instead and then。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邻居的值较高而另一个邻居的值较低，在爬山算法中，如果我试图最大化值，我通常会选择我能找到的最高值，在我左边和右边的状态中，较高的状态是这个。所以我们会前进，考虑这个状态。
- en: I'll repeat this process continually，looking at all of my neighbors and。picking
    the highest neighbor doing the，same thing looking at my neighbors。picking the
    highest of my neighbors，until I get to a point like right here。where I consider
    both of my neighbors，and both of my neighbors have a lower，value than I do。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不断重复这个过程，查看我的所有邻居，选择邻居中值最高的，做同样的事情，查看我的邻居，选择邻居中值最高的，直到我达到像这里的某个点，在那里我考虑了我的两个邻居，而这两个邻居的值都低于我。
- en: this current state has a value that is，higher than any of its neighbors and
    at。![](img/12696b090026272c3abe48d2abb04c6f_4.png)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态的值高于其任何邻居的值，且在此处！[](img/12696b090026272c3abe48d2abb04c6f_4.png)
- en: that point the algorithm terminates and，I can say all right here I have now。found
    the solution and the same thing，works in exactly the opposite way for。trying to
    find a global minimum but the，algorithm is fundamentally the same if。I'm trying
    to find a global minimum and，say my current state starts here I'll。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此时算法终止，我可以说，好吧，我现在找到了这个解决方案，反过来同样的过程适用于寻找全局最小值，但算法的基本原理是相同的。如果我试图寻找全局最小值，假设我当前的状态从这里开始，我会。
- en: continually look at my neighbors pick，the lowest value that I possibly can。until
    I eventually hopefully find that，global minimum a point at which when I。look at
    both of my neighbors they each，have a higher value and I'm trying to。minimize
    the total score or cost or，value that I get as a result of。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不断查看我的邻居，选择我能找到的最低值。直到我最终希望找到全局最小值，这个点在我查看两个邻居时，它们的值都更高，而我试图最小化总分或成本或结果值。
- en: calculating some sort of cost function，so we can formulate this graphical idea。in
    terms of pseudocode and the，pseudocode for hill climbing might look。like this
    we define some function called，hill climb，that takes as input the problem that。we're
    trying to solve and generally，we're going to start in some。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 计算某种成本函数，所以我们可以用伪代码将这个图形概念公式化，爬山算法的伪代码可能看起来像这样：我们定义一个名为hill climb的函数，它接受我们试图解决的问题作为输入，通常我们会从某个地方开始。
- en: sort of initial state so I'll start with，a variable called current that is。keeping
    track of my initial state like，an initial configuration of hospitals。and maybe
    some problems lend themselves，to an initial state someplace where you。begin in
    other cases maybe not in which，case we might just randomly generate。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一种初始状态，所以我将从一个名为current的变量开始。这个变量用于跟踪我的初始状态，就像医院的初始配置一样。也许有些问题适合于某个初始状态，在那里你可以开始，而在其他情况下则不一定，在这种情况下，我们可能会随机生成。
- en: some initial state just by choosing two，locations four hospitals at random for。example
    and figuring out from there how，we might be able to improve but that。initial state
    we're going to store，inside of current and now here comes our。loop some repetitive
    process we're gonna，do again and again until the algorithm。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些初始状态，举例来说，可以随机选择两个地点，四个医院，然后从那里开始考虑如何改善，但我们要存储的初始状态将放在current里面。现在我们进入循环，这个重复的过程我们会不断进行，直到算法。
- en: terminates and what we're going to do is，first say let's figure out all of the。neighbors
    of the current state from my，state what are all of the neighboring。states for
    some definition of what it，means to be a neighbor and I'll go ahead。and choose
    the highest-valued，of all of those neighbors and save it。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 终止，我们要做的是，首先说，让我们弄清楚当前状态的所有邻居，从我的状态，所有的邻居状态是什么，基于某种定义的邻居的意思，我将选择所有邻居中价值最高的，并保存它。
- en: inside of this variable called neighbor，so keep track of the highest-valued。neighbor
    this is in the case where I'm，trying to maximize the value in the case。where I'm
    trying to minimize the value，you might imagine here you'll pick the。neighbor with
    the lowest possible value，but these ideas are really fundamentally。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个名为邻居的变量中，跟踪最高价值的邻居，这是我试图最大化价值的情况。在我试图最小化价值的情况下，你可以想象你会选择具有最低可能值的邻居，但这些想法在根本上。
- en: interchangeable and it's possible in，some cases there might be multiple。neighbors
    that each have an equally high，value or an equally low value in the。minimizing
    case and in that case we can，just choose randomly from among them。just choose
    one of them and save it，inside of this variable neighbor and。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以互换的，在某些情况下，可能有多个邻居具有同样高或同样低的值。在最小化的情况下，我们可以随机选择其中一个，选择其中一个并将其保存在这个变量邻居中。
- en: then the key question to ask is is this，neighbor better than my current state。and
    if the neighbor the best neighbor，that I was able to find is not better。than my
    current state well then the，algorithm is over and I'll just go ahead。and return
    the current state if none of，my neighbors are better but I may as。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么要问的关键问题是，这个邻居是否比我当前的状态更好。如果我能找到的最佳邻居不比我当前的状态更好，那么算法就结束了，我将返回当前状态，如果没有一个邻居比我更好，我可能。
- en: well stay where I am is the general，logic of the hill climbing algorithm but。otherwise
    if the neighbor is better then，I may as well move to that neighbor so。you might
    imagine setting current equal，to neighbor where the general idea is if。I'm at
    a current state and I see a，neighbor that is better than me then。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，停留在我所在的位置是爬山算法的一般逻辑，但如果邻居更好，我就可以移动到那个邻居。你可以想象将当前状态设置为邻居，基本思路是，如果我处于一个当前状态，并且看到一个比我更好的邻居。
- en: I'll go ahead and move there and then，I'll repeat the process continually。moving
    to a better neighbor until I，reach a point at which none of my。neighbors are better
    than I am and at，that point we'd say the algorithm can。just terminate there so
    let's take a，look at a real example of this with。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续移动到那里，然后不断重复这个过程，移动到更好的邻居，直到我达到一个点，此时没有一个邻居比我更好，在那个点我们可以说算法就可以终止了。那么我们来看一个实际的例子。
- en: these houses and hospitals so we've seen，now that if we put the hospitals in。these
    two locations that has a total，cost of 17 and now we need to define if。we're going
    to implement this hill，climbing algorithm what it means to take。this particular
    configuration of，hospitals this particular state and get。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些房子和医院，所以我们现在已经看到，如果我们将医院放在这两个位置，总成本为17，现在我们需要定义，如果我们要实现这个爬山算法，这意味着要取这个特定配置的医院，这个特定状态并获得。
- en: a neighbor of that state and a simple，definition of neighbor might be just。let's
    pick one of the hospitals and move，it by one square the left or right or up。or
    down for example and that would mean，we have six possible neighbors from this。particular
    configuration we could take。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态的一个邻居，邻居的简单定义可能是，选择一个医院，并将其移动一个方块，向左、向右、向上或向下，例如，这意味着我们从这个特定配置中有六个可能的邻居。
- en: '![](img/12696b090026272c3abe48d2abb04c6f_6.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12696b090026272c3abe48d2abb04c6f_6.png)'
- en: this hospital and move it to any of，these three possible square ism or we。take
    this hospital and move it to any of，those three possible squares and each of。those
    would generate a neighbor and what，I might do is say alright here is the。locations
    and the distances between each，of the houses and their nearest hospital。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个医院可以移动到这三个可能的方块中的任何一个，或者我们将这个医院移动到那些三个可能的方块，每一个都会生成一个邻居。我可能会说，好吧，这里是位置和每个房子到最近医院的距离。
- en: let me consider all of the neighbors and，see if any of them can do better than
    a。cost of 17 and it turns out there are a，couple of ways that we could do that
    and。it doesn't matter if we randomly choose，among all the ways that are the best
    but。one such possible way is by taking a，look at this hospital here and。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我考虑所有邻居，看看是否有任何一个能够使成本低于17。结果发现，有几种方式可以做到这一点，随机选择其中任何一种最佳方式都没关系，但其中一种可能的方法是看看这里的这家医院。
- en: considering the directions in which it，might move if we hold this Hospital。constant
    if we take this hospital and，move it one square up for example that。doesn't really
    help us it gets closer to，the house up here but it gets further。away from the
    house down here and it，doesn't really change anything for the。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到如果我们保持这家医院不变，它可能会朝哪个方向移动。如果我们将这家医院向上移动一个单位，例如，这实际上并没有帮助它更靠近上面的房子，但却离下面的房子更远，并且对整体并没有改变什么。
- en: two houses along the left-hand side but，if we take this hospital on the right。and
    move it one square down it's the，opposite problem it gets further away。from the
    house up above and it gets，closer to the house down below the Abril。idea the goal
    should be to be able to，take this hospital and move it one。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们将右侧的这家医院向下移动一个单位，问题就正好相反，它会离上面的房子更远，但却更靠近下面的房子。因此，目标应该是能够将这家医院移动一个单位。
- en: square to the left by moving at one，square to the left we move it closer to。both
    of these houses on the right，without changing anything about the。houses on the
    left for them this，hospital is still the closer one so they。aren't affected so
    we're able to improve，the situation by picking a neighbor that。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 向左移动一个单位，我们使它更接近右侧的这两栋房子，而不改变左侧房子的情况。对他们而言，这家医院仍然是更近的一个，因此他们并没有受到影响，因此我们能够通过选择一个邻居来改善情况。
- en: results in a decrease in our total cost，and so we might do that move ourselves。from
    this current state to a neighbor by，just taking that hospital and moving it。and
    at this point there's not a whole，lot that can be done with this hospital。but
    there's still other optimizations we，can make other neighbors we can move to。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们总成本的减少，因此我们可能会自己将状态从当前状态移动到一个邻居，只需将这家医院移动一下。在这一点上，这家医院实际上能做的事情并不多，但我们仍然可以进行其他优化，移动到其他邻居。
- en: that are going to have a better value if，we consider this hospital for example
    we。might imagine that right now it's a bit，far up that both of these houses that。are
    a little bit lower so we might be，able to do better by taking this。hospital and
    moving it one Square down，moving it down so that now instead of a。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这家医院，我们可能想象现在它的位置稍微高于这两栋房子，因此我们可能通过将这家医院向下移动一个单位来做得更好。
- en: cost of 15 we're down to a cost of 13，for this particular configuration and
    we，can do even better by。the hospital and moving it one Square to，the left now
    instead of a cost of 13 we。have a cost of 11 because this house is，one away from
    the hospital。this one is four away this one is three，away and this one is also
    three away so。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，成本从15降到了13，对于这种特定配置来说，我们甚至可以更好地将医院向左移动一个单位，这样成本从13降到了11，因为这栋房子离医院只有1个单位，这栋房子离4个单位，这栋房子离3个单位，而这栋房子也是离3个单位。
- en: we've been able to do much better than，that initial cost that we had using the。initial
    configuration just by taking，every state and asking ourselves the。question can
    we do better by just making，small incremental changes moving to a。neighbor moving
    to a neighbor and moving，to a neighbor after that and now at this。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够在使用初始配置的情况下，做到比最初的成本好得多，仅仅通过询问自己一个问题：通过做小的增量变化，移动到一个邻居，移动到另一个邻居，我们能否做得更好？现在在这个。
- en: point we can potentially see that at，this point the algorithm is going to。terminate
    there's actually no neighbor，we can move to that is going to improve。the situation
    get us a cost that is less，than 11 because if we take this hospital。and move it
    up or to the right well，that's going to make it further away if。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们可以看到，算法可能会终止，因为实际上没有邻居可以移动到并改善情况，使我们的成本低于11。如果我们将这家医院向上或向右移动，那将使它距离左侧的两栋房子更远。
- en: we take it and move it down that doesn't，really change the situation it gets。further
    away from this house but closer，to that house and likewise the same。story was
    true for this hospital any，neighbor we move it to up left down or。right is either
    going to make it further，away from the houses and increase the。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把它移动到下方，这并没有真正改变情况，它离这栋房子更远，但离那栋房子更近。同样，这个医院的情况也是如此，我们无论移动到上、左、下还是右的任何邻居，都会使其离房子更远，并增加。
- en: cost or it's gonna have no effect on the，cost whatsoever and so the question
    we。might now ask is is this the best we，could do is this the best placement of。the
    hospital's we could possibly have，and it turns out the answer is no。because there's
    a better way that we，could place these hospitals and in。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 成本上，或者它根本不会对成本产生任何影响。因此，我们现在可能会问，这是我们能做到的最好的吗？这是我们能够拥有的医院的最佳位置吗？结果答案是否定的，因为有更好的方法可以放置这些医院。
- en: particular there are a number of ways，you could do this but one of the ways
    is。by taking this hospital here and moving，it to this square for example moving
    it。diagonally by one square which was not，part of our definition of neighbor we。can
    only move left right up or down，but this is in fact better it has a。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有许多方法可以做到这一点，但其中一种方法是把这个医院移动到这个方格，例如对角线移动一个方格，这并不是我们邻居定义的一部分，我们只能向左、右、上或下移动，但实际上这更好，它有一个。
- en: total cost of nine it is no closer to，both of these houses and as a result the。total
    cost is less but we weren't able，to find it because in order to get there。we had
    to go through a state that，actually wasn't any better than the。current state that
    we had been on，previously and so this appears to be a。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总成本为九，它离这两栋房子都没有更近，因此，总成本较低，但我们无法找到它，因为要到达那里，我们必须经过一个状态，而那个状态实际上并不比我们之前所处的当前状态更好，因此这似乎是一个。
- en: limitation or a concern you might have，as you go about trying to implement a。hill
    climbing algorithm is that it might，not always give you the optimal solution。if
    we're trying to maximize the value of，any particular state we're trying to。find
    the global maximum a concern might，be that we could get stuck at one of the。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试实施爬山算法时，可能会有一个限制或顾虑，即它可能并不总是给你最优解。如果我们试图最大化任何特定状态的值，试图找到全局最大值，可能会担心我们会卡在某个。
- en: local Maxima highlighted here in blue，where a local Maxima is any state whose。value
    is higher than any of its，neighbors if we ever find ourselves。at one of these
    two states when we're，trying to maximize the value of the。state we're not going
    to make any，changes we're not going to move left or。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里用蓝色突出显示的局部最大值，局部最大值是指任何状态，其值高于任何邻居。如果我们发现自己处于这两个状态中的任何一个，当我们试图最大化状态值时，我们不会做出任何改变，我们不会向左或。
- en: right we're not going to move left here，because those states are worse but yet。we
    haven't found the global optimum we，haven't done as best as we could do and。likewise
    in the case of the hospital is，what were ultimately trying to do is。find a global
    minimum find a value that，is lower than all of the others but we。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里向左移动，因为那些状态更糟，但我们还没有找到全局最优解，我们没有做到最好。同样，在医院的案例中，我们最终想要做的是找到一个全局最小值，找到一个低于其他所有值的值，但我们。
- en: have the potential to get stuck at one，of the local minimum any of these states。whose
    value is lower than all of its，neighbors but still not as low as the。local minimum
    and so the takeaway here，is that it's not always going to be the。case that when
    we run this naive，hill-climbing algorithm that we're，always going to find the
    optimal。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会在局部最小值之一的状态中卡住，这些状态的值低于所有邻居，但仍然不如局部最小值低。因此，这里要记住的是，当我们运行这个简单的爬山算法时，并不总是能够找到最优解。
- en: solution there are things that could go，wrong if we started here for example
    and。tried to maximize our value as much as，possible we might move to the highest。possible
    neighbor move to the highest，possible neighbor move to the highest。possible neighbor
    and stop and never，realize that there's actually a better。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案。如果我们从这里开始，尽可能地尝试最大化我们的价值，可能会出错，我们可能会移动到最高的邻居，移动到最高的邻居，再移动到最高的邻居，然后停下来，永远不会意识到实际上有一个更好的。
- en: state way over there that we could have，gone to instead and other problems you。might
    imagine just by taking a look at，this state space landscape are these。various
    different types of plateaus，something like this flat local maximum。here we're
    all six of these states each，have the exact same value and so in the。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个状态空间景观，可能会想象到各种不同类型的**平坦区**，例如，这里的局部最大值，其中六个状态的值完全相同。
- en: case of the algorithm we showed before，none of the neighbors are better so we。might
    just get stuck at this flat local，maximum and even if you allowed yourself。to
    move to one of the neighbors it，wouldn't be clear which neighbor you。would ultimately
    move to and you could，get stuck here as well and there's。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前展示的算法中，没有任何邻居更好，所以我们可能会卡在这个平坦的局部最大值，甚至如果允许自己移动到一个邻居，也不清楚最终会移动到哪个邻居，可能会在这里卡住。
- en: another one over here this one is called，a shoulder it's not really a local。maximum
    because there's still places，where we can go higher not a local。minimum because
    we can go lower so we，can still make progress but it's still。this flat area where
    if you have a local，search algorithm there's potential to。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个变体称为**随机爬山**，另一个则称为**肩部**，这并不是真正的局部最大值，因为我们仍然可以走向更高的地方，也不是局部最小值，因为我们可以下降，因此仍然可以取得进展，但这仍然是一个平坦区域。
- en: '![](img/12696b090026272c3abe48d2abb04c6f_8.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12696b090026272c3abe48d2abb04c6f_8.png)'
- en: get lost here unable to make some upward，or downward progress depending on。whether
    we're trying to maximize or，minimize it and therefore another。potential for us
    to be able to find the，solution that might not actually be the。optimal solution
    and so because of this，potential the potential that hill。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里迷失，无法向上或向下取得进展，具体取决于我们是在最大化还是最小化，因此我们可能无法找到实际上不是最佳解的解决方案。
- en: climbing has to not always find us the，optimal result it turns out there are
    a。number of different varieties and，variations on the hill climbing。algorithm
    that help to solve the problem，better depending on the context and。depending on
    the specific type of，problem some of these variants might be。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 攀登并不总是能为我们找到**最佳结果**，实际上有许多不同的种类和变体的爬山算法，可以帮助根据上下文和特定问题类型更好地解决问题。
- en: more applicable than others but we've，taken a look at so far，is a version of
    hill climbing generally。called steepest ascent hill climbing，where the idea of
    steepest ascent hill。climbing is we are going to choose the，highest-valued neighbor
    in the case。where we're trying to maximize or the，lowest valued neighbor in cases
    where。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止我们所考虑的更适用的是一种通常称为**最陡上升爬山**的版本，最陡上升爬山的想法是我们将选择在试图最大化时值最高的邻居，或者在试图最小化时值最低的邻居。
- en: we're trying to minimize but generally，speaking if I have five neighbors and。they're
    all better than my current state，I will pick the best one of those five。now sometimes
    that might work pretty，well it's sort of a greedy approach of。trying to take the
    best operation at any，particular time step but a might not。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，如果我有五个邻居，而他们都比我当前的状态好，我会选择这五个邻居中最好的一个。有时这可能效果很好，这是一种贪婪的方法，试图在任何特定时间步骤中采取最佳操作，但也可能不行。
- en: always work there might be cases where，actually I want to choose an option that。is
    slightly better than me but maybe not，the best one because that later on might。lead
    to a better outcome ultimately so，there are other variants we might。consider of
    this basic hill climbing，algorithm one is known as stochastic。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变体并不总是有效，可能会出现我想选择一个稍微好一点的选项，而不一定是最好的选项，因为这可能会导致最终更好的结果。
- en: hill climbing and in this case we choose，randomly from all of our higher value。neighbors
    so if I'm at my current state，and there are five neighbors that are。all better
    than I am rather than，choosing the best one as steepest a。sudden would do stochastic
    will just，choose randomly from one of them。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择所有更高值邻居中的一个是另一种可能性，所以如果我在当前状态，并且有五个邻居都比我好，那么与选择最佳的最陡上升相比，随机选择将从其中一个中随机选择。
- en: thinking that if it's better then it's，better and maybe there's a potential
    to。make forward progress even if it is not，locally the best option I could possibly。choose
    first-choice hill climbing ends，up just choosing the very first highest。valued
    neighbor that it follows behaving，on a similar idea rather than consider。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 认为如果它更好，那就更好，并且或许有可能向前推进，即使它不是我可能选择的局部最佳选项。首选爬山最终只是选择第一个最高价值的邻居，类似于这种想法，而不是考虑。
- en: all of the neighbors as soon as we find，a neighbor that is better than our。current
    state we'll go ahead and move，there so maybe some efficiency。improvements there
    and maybe has the，potential to find a solution that the。other strategies weren't
    able to find，and with all of these variants we still。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到一个比当前状态更好的邻居，我们就会去那里，也许能在这里提高一些效率，或许能找到其他策略无法找到的解决方案，尽管所有这些变体我们仍然。
- en: suffer from the same potential risk this，risk that we might end up at a local。minimum
    or a local maximum and we can，reduce that risk by repeating the。process multiple
    times so one variant of，hill climbing is random restart hill。climbing where the
    general idea is will，conduct hill climbing multiple times if。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 面临着相同的潜在风险，即我们可能会陷入局部最小值或局部最大值，我们可以通过多次重复该过程来降低这种风险。因此，爬山的一种变体是随机重启爬山，其中一般思路是如果。
- en: we apply its steepest ascent hill，climbing for example will start at some。random
    state try and figure out how to，solve the problem and figure out what is。the local
    maximum or local minimum we，get to and then we'll just randomly。restart and try
    again choose a new，starting configuration try and figure。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用其最陡上升爬山，例如将从某个随机状态开始，尝试找出如何解决问题，并确定我们到达的局部最大值或局部最小值，然后我们将随机重启并重试，选择新的起始配置并尝试找出。
- en: out what the local maximum or minimum is，and do this some number of times and。then
    after we've done at some number of，times we can pick the best one out of。all of
    the ones that we've taken a look，at so there's another option we have。access to
    as well and then although I，said the general，local search will usually just keep。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 找出局部最大值或最小值，并进行一定次数的重复，然后在我们查看过的所有选项中选择最佳的一个，所以我们还有另一个选择可以访问。虽然我提到一般的局部搜索通常只会保持。
- en: track of a single node and then move to，one of its neighbors there are variants。of
    hill climbing that are known as local，beam searches where rather than keep。track
    of just one current best state，we're keeping track of K highest valued。neighbors
    such that rather than starting，at one random initial configuration I。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪一个单一节点，然后移动到其邻居之一。存在一种称为局部束搜索的爬山变体，其中我们不仅跟踪一个当前最佳状态，而是跟踪 K 个最高价值的邻居，因此我们不会仅从一个随机初始配置开始。
- en: might start with three or four or five，randomly generate all the neighbors and。then
    pick like the three or four or five，best of all of the neighbors that I find。and
    continually repeat this process with，the idea being that now I have more。options
    that I'm considering more ways，that I could potentially navigate myself。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能从三个、四个或五个随机生成所有邻居，然后选择我找到的所有邻居中最好的三、四或五个，并不断重复这个过程，想法是我现在考虑了更多选项，有更多的方式我可以潜在地导航。
- en: to the optimal solution that might exist，for a particular problem so let's now。take
    a look at some actual code that can，implement some of these kinds of ideas。something
    like steepest ascent hill，climbing for example for trying to solve。a this hospital
    problem so I'm going to。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最终找到某个特定问题的最优解，所以现在让我们看看一些可以实现这些想法的实际代码，比如最陡上升爬山，以解决这个医院问题，因此我将。
- en: '![](img/12696b090026272c3abe48d2abb04c6f_10.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12696b090026272c3abe48d2abb04c6f_10.png)'
- en: go ahead and go into my hospital's，directory where I've actually set up the。basic
    framework for solving this type of，problem I'll go ahead and go into。hospitals
    PI and we'll take a look at，the code we've created here I've defined。a class that
    is going to represent the，state space so the space has a height。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进入我医院的目录，在这里我实际上建立了一个解决这类问题的基本框架。接下来，我将进入医院的 PI，我们来看看我们在这里创建的代码。我定义了一个类，用于表示状态空间，因此该空间具有高度。
- en: and a width and also some number of，hospitals so you can configure how big。is
    your map how many hospitals should go，here we have a function for adding a new。house
    to the state space and then some，functions that are going to get me all。of the
    available spaces for if I want to，like randomly place hospitals in。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个宽度，还有一些医院数量，所以你可以配置你的地图有多大，应该有多少医院。这里我们有一个添加新医院到状态空间的函数，然后一些函数将为我获取所有可用的空间，如果我想随机放置医院的话。
- en: particular locations and here now is the，hill climbing algorithm so what are
    we。gonna do in the hill climbing algorithm，well we're going to start by randomly。initializing
    where the hospitals are，going to go we don't know where the。hospitals should actually
    be so let's，just randomly place them so here I'm。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是爬山算法。那么我们在爬山算法中要做什么呢？我们将开始随机初始化医院的位置，我们不知道医院实际应该在哪里，所以我们就随机放置它们。
- en: running a loop for each of the hospitals，that I haven't I'm going to go ahead
    and。add a new hospital at some random，location so I basically get all of the。available
    space ISM and I randomly，choose one of them as where I would like。to add this
    particular hospital I have，some logging output and generating some。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我没有的每个医院运行循环，我会随机在某个位置添加一所新医院，所以我基本上获得所有可用空间，并随机选择其中一个作为我希望添加这所特定医院的位置。我有一些日志输出和生成。
- en: images which we'll take a look at a，little bit later but here is the key。idea
    so I'm going to just keep repeating，this algorithm I could specify a maximum。of
    how many times I wanted to run or I，could just run it up until it hits a。local
    maximum or local minimum and now，we'll basically consider all of the。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图片，我们稍后会看一下，但这里是关键想法，我会一直重复这个算法。我可以指定一个最大运行次数，或者我可以一直运行直到达到局部最大值或局部最小值，现在我们基本上会考虑所有当前的情况。
- en: hospitals that could potentially move so，consider each of the two hospitals
    and。more hospitals if they're more than that，and consider all of the places where。that
    hospital could move to some，neighbor of that hospital that we can。move the neighbor
    to and then see you，know is this going to be better than。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这两所医院以及更多医院（如果有的话），并考虑该医院可以移动到的一些地方，即该医院的邻居，我们可以将邻居移动到的地方，然后看看这是否会比特定位置更好。
- en: where we were currently so if it is，going to be better then we'll go ahead。and
    update our best neighbor and keep，track of this new best neighbor that we。found
    and then afterwards we can ask，ourselves the question if best neighbor。cost is
    greater than or equal to the，cost of the current set of hospitals。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这会更好，那么我们就更新最佳邻居，跟踪我们找到的新最佳邻居，然后之后我们可以问自己，如果最佳邻居的成本大于或等于当前医院集合的成本。
- en: meaning if the cost of our best neighbor，is greater than the current cost meaning。our
    best neighbor is worse than our，current state well then we shouldn't。make any
    changes at all and we should，just go ahead and return the current set。of hospitals
    but otherwise if we can，update our hospitals in order to change。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们最佳邻居的成本大于当前成本，意味着我们最佳邻居比当前状态更差，那么我们就不应该做任何更改，我们应该直接返回当前的医院集合。否则，如果我们可以更新医院以改变。
- en: them to one of the best neighbors and if，there are multiple that are all。equivalent
    I'm here using random choice，if they go ahead and choose one randomly。so this
    is really just a Python，implementation of that same idea that we。were just talking
    about this idea of，taking a current state some current set。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们连接到最佳邻居之一，如果有多个都是等效的，我这里使用随机选择，如果他们随机选择一个。那么这实际上只是一个Python实现，我们刚才讨论的这个想法，采用当前状态的一些当前医院集合。
- en: of hospitals and generating all of the，neighbors looking at all the ways we。could
    take one hospital and move it one，Square to the left or right or up or。down and
    then figuring out based on all，of that information which is the best。neighbor
    or the set of all the best，neighbors and then choosing from one of。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成所有邻居，查看我们可以将一所医院向左、向右、向上或向下移动一个单位的所有方式，然后根据所有这些信息找出哪个是最佳邻居，或者所有最佳邻居的集合，并从中选择一个。
- en: those and each time we go ahead and，generate an image in order to do that。and
    so now what we're doing is if we，look down at the bottom I'm going to。randomly
    generate a space with height 10，and width 20 and I'll say go ahead and。put three
    hospitals somewhere in the，space I'll randomly generate 15 houses。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们生成一个图像以实现这一点。因此，现在如果我们看看底部，我将随机生成一个高度为10、宽度为20的空间，并说去随机放置三个医院在这个空间中，我将随机生成15栋房子。
- en: that I just go ahead and add in random，locations and now I'm going to run this。![](img/12696b090026272c3abe48d2abb04c6f_12.png)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将随机位置添加进去，现在我要运行这个程序。![](img/12696b090026272c3abe48d2abb04c6f_12.png)
- en: hill climbing algorithm in order to try，and figure out where we should place。those
    hospitals so we'll go ahead and，run this program by running Python。hospitals and
    we see that we started our，initial state had a cost of 72 but we。were able to
    continually find neighbors，that were able to decrease that cost。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用爬山算法来尝试确定我们应该将医院放置在哪里，因此我们将运行这个程序，通过运行Python来处理医院。我们看到初始状态的成本为72，但我们能够不断找到能够降低成本的邻居。
- en: decrease to 69 66 63 so on and so forth，all the way down to 53 as the best。![](img/12696b090026272c3abe48d2abb04c6f_14.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 距离降到了69、66、63，依此类推，最终降到53，成为最佳方案。![](img/12696b090026272c3abe48d2abb04c6f_14.png)
- en: neighbor we were able to ultimately find，and we can take a look at what that。![](img/12696b090026272c3abe48d2abb04c6f_16.png)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居，最终我们能够找到的，我们可以看看那个。![](img/12696b090026272c3abe48d2abb04c6f_16.png)
- en: looked like by just opening up these，files so here for example was the。initial
    configuration we randomly，selected a location for，each of these 15 different houses
    and。then randomly selected locations for one，two three hospitals that were just。located
    somewhere inside of this state，space and if you add up all the。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开这些文件可以看到，例如，最初的配置是我们随机选择了这15栋不同房子的一个位置，然后随机选择了一个、两个、三个医院的位置，这些医院就位于这个状态空间的某个地方。如果将所有的距离加起来...
- en: distances from each of the houses to，their nearest hospital you get a total。cost
    of about 72 and so now the question，is what neighbors can we move to that。improve
    the situation and it looks like，the first one the algorithm found was by。taking
    this house that was over there on，the right and just moving it to the left。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从每栋房子到最近医院的距离总共约为72，现在的问题是我们能移动到哪些邻居来改善情况，算法首先找到的一个邻居是将那栋位于右侧的房子向左移动。
- en: and that probably makes sense because if，you look at the houses in that general。area
    really these five houses look thick，they're probably the ones that are going。to
    be closest to this hospital over here，moving it to the left decreases the。total
    distance at least to most of these，houses though it does increase that。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是有道理的，因为如果你看看那个地区的房子，这五栋房子看起来相对密集，它们可能是离这家医院最近的，向左移动会减少大部分房子的总距离，尽管这会增加...
- en: distance for one of them and so we're，able to make these improvements to the。situation
    but continually finding ways，that we can move these hospitals around。until we
    eventually settle at this，particular state that has a cost of 53。or we figured
    out a position for each of，the hospital ISM and now none of the。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个的距离，因此我们能够对情况进行这些改进，但不断寻找能够移动医院的方法，直到我们最终在这个特定状态上稳定下来，其成本为53，或者我们找到了每个医院的位置，而现在没有...
- en: neighbors that we could move to are。![](img/12696b090026272c3abe48d2abb04c6f_18.png)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移动到的邻居是。![](img/12696b090026272c3abe48d2abb04c6f_18.png)
- en: actually going to improve the situation，we can take this hospital and this。hospital
    on that hospital and look at，each of the neighbors and none of those。are going
    to be better than this，particular configuration and again。that's not to say that
    this is the best，we could do there might be some other。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上要改善这种情况，我们可以拿这家医院和另一家医院进行比较，看看每个邻居，结果没有任何一个邻居比这个特定的配置更好。再说一次，这并不是说这是最佳方案，我们可能还有其他选择。
- en: configuration of hospitals that is a，global minimum and this might just be a。local
    minimum that is the best of all of，its neighbors that may be not the best。in the
    entire possible state space and，you could search through the entire。state space
    by considering all of the，possible configurations for hospitals。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 医院的配置是一个全局最小值，而这可能只是一个局部最小值，是所有邻居中最好的，但在整个可能的状态空间中可能不是最佳的。你可以通过考虑所有可能的医院配置来搜索整个状态空间。
- en: but ultimately that's going to be very，time intensive especially as our state。space
    gets bigger and there might be，more and more possible states it's going。to take
    quite a long time to look，through all of them and so being able to。use these sort
    of local search，algorithms can often be quite good for。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但从根本上来说，这将非常耗时，尤其是当我们的状态空间变得更大时，可能会有越来越多的可能状态，查看所有状态将需要相当长的时间，因此能够使用这些局部搜索算法通常是非常有效的。
- en: trying to find the best solution we can，do and especially if we don't care about。doing
    the best possible and we just care，about doing pretty good and finding a。pretty
    good placement of those hospitals，then these methods can be particularly。powerful
    but of course we can try and，mitigate some of this concern by instead。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找到我们能做到的最佳解决方案，尤其是如果我们不在乎做到最好，而只关心找到一个不错的医院布局，那么这些方法可能特别强大，但当然我们可以尝试通过使用其他方法来缓解一些担忧。
- en: of using hill climbing to use random，restart this idea of rather than just。hill
    climb one time we can hill climb，multiple times and say try hill climbing。a whole
    bunch of times on the exact same，map and figure out what is the best one，that
    we。been able to find and so i've here，implemented a function for random。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用爬山算法，而是随机重启这个想法，意思是我们可以进行多次爬山，而不是仅仅一次，在完全相同的地图上尝试爬山，找出我们能找到的最佳结果，因此我在这里实现了一个随机重启的函数。
- en: restart that restarts some maximum，number of times and what we're going to。do
    is repeat that number of times this，process i've just go ahead and run the。hill-climbing
    algorithm figure out what，the cost is of getting from all the。houses to the hospitals
    and then figure，out is this better than we've done so。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随机重启一些最大次数，我们将重复这个过程，我刚刚运行爬山算法，计算从所有房屋到医院的费用，然后确定这是否比我们迄今为止的结果更好。
- en: far so I can try this exact same idea，we're instead of running hill-climbing。i'll
    go ahead and run random restart and。![](img/12696b090026272c3abe48d2abb04c6f_20.png)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我可以尝试这个相同的想法，而不是运行爬山算法，我将运行随机重启，并且！[](img/12696b090026272c3abe48d2abb04c6f_20.png)
- en: I'll randomly restart maybe 20 times for，example and we'll go ahead and now
    I'll。remove all the images and then rerun the，program and now we started by finding
    a。original state when we initially ran，hill-climbing the best cost we were able，to
    find was 56。each of these iterations is a different，iteration of the hill climbing
    algorithm。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我将随机重启大约20次，例如，现在我将移除所有图像，然后重新运行程序，最初运行爬山时我们找到的最佳成本是56。每次迭代都是爬山算法的不同迭代。
- en: we're running hill climbing not one time，but 20 times here each time going until。we
    find a local minimum in this case and，we look and see each time did we do。better
    than we did the best time we've，done so far from 56 to 46 this one was。greater
    so we ignored it this one was 41，which was less so we went ahead and kept。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是运行爬山算法一次，而是在这里进行20次，每次都寻找局部最小值，看看每次是否比我们迄今为止的最佳时间更好，从56到46，这一次更高，所以我们忽略了，而41更低，所以我们继续保持。
- en: that one and for all of the remaining 16，times that we tried to implement hill。climbing
    and we tried to run the hill，climbing algorithm we couldn't do any。better than
    that 41 again maybe there is，a way to do better that we just didn't。find but it
    looks like that way ended up，being a pretty good solution to the。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试实施爬山算法的16次中，最后一次却没有做到比41更好，或许有更好的方法我们没有找到，但看来这条路最终成为了一个相当不错的解决方案。
- en: '![](img/12696b090026272c3abe48d2abb04c6f_22.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12696b090026272c3abe48d2abb04c6f_22.png)'
- en: problem that was attempt number three，starting from counting in zero so we can。take
    a look at that open up number three，and this was the state that happened to。![](img/12696b090026272c3abe48d2abb04c6f_24.png)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是这是尝试的第三次，从零开始计数，我们可以看看打开第三次，这就是发生的状态。！[](img/12696b090026272c3abe48d2abb04c6f_24.png)
- en: have a cost of 41 that after running the，hill climbing algorithm on some。particular
    random initial configuration，of hospitals this is what we found was。the local
    minimum in terms of trying to，minimize the cost and it looks like we。did pretty
    well that this hospital is，pretty close to this region this one is。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 经过对一些特定随机初始医院配置运行爬山算法后，费用为41，这就是我们找到的局部最小值，试图最小化成本，看起来我们做得相当不错，这家医院距离这个区域很近。
- en: pretty close to these houses here this，hospital looks about as good as we can。do
    for trying to capture those houses，over on that side and so these sorts of。algorithms
    can be quite useful for，trying to solve these problems but the。real problem with
    many of these，different types of hill climbing。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 离这些房子相当近的这家医院，看起来是我们能做的，尽量捕捉到那边的房子，所以这类算法对于解决这些问题相当有用，但是许多不同类型的爬山算法的真正问题在于。
- en: '![](img/12696b090026272c3abe48d2abb04c6f_26.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12696b090026272c3abe48d2abb04c6f_26.png)'
- en: steepest ascent stochastic first choice，and so forth is that they never make
    a。move that makes our situation worse，right they're always going to take。ourselves
    in our current state look at，the neighbors and consider。can we do better than
    our current state，and move to one of those neighbors which。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 陡峭上升、随机选择等算法，从不做出会让我们情况更糟的移动，对吧？它们总是会查看当前状态的邻居，考虑我们是否能比当前状态做得更好，并移动到那些邻居中的一个。
- en: of those neighbors we choose might vary，among these various different types
    of。algorithms but we never go from a，current position to a position that is。worse
    than our current position and，ultimately that's what we're going to。need to do
    if we want to be able to find，a global maximum or a global minimum。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的邻居可能会因这些不同类型的算法而有所不同，但我们从不会从当前位置移动到一个比当前更糟的位置，最终，如果我们想找到一个全局最大值或全局最小值，这正是我们需要做到的。
- en: because sometimes if we get stuck we，want to find some way of dislodging。ourselves
    from our local maximum or，local minimum in order to find the。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有时候如果我们遇到瓶颈，我们想找到一些方法来摆脱我们在局部最大值或局部最小值的困境，以便找到。
