- en: Lecture 7
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7讲
- en: 原文：[https://cs50.harvard.edu/python/notes/7/](https://cs50.harvard.edu/python/notes/7/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/python/notes/7/](https://cs50.harvard.edu/python/notes/7/)
- en: '[Regular Expressions](#regular-expressions)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式](#regular-expressions)'
- en: '[Case Sensitivity](#case-sensitivity)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大小写敏感](#case-sensitivity)'
- en: '[Cleaning Up User Input](#cleaning-up-user-input)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[清理用户输入](#cleaning-up-user-input)'
- en: '[Extracting User Input](#extracting-user-input)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提取用户输入](#extracting-user-input)'
- en: '[Summing Up](#summing-up)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Regular Expressions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Regular expressions or “regexes” will enable us to examine patterns within our
    code. For example, we might want to validate that an email address is formatted
    correctly. Regular expressions will enable us to examine expressions in this fashion.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式或“regexes”将使我们能够检查代码中的模式。例如，我们可能想要验证电子邮件地址的格式是否正确。正则表达式将使我们能够以这种方式检查表达式。
- en: 'To begin, type `code validate.py` in the terminal window. Then, code as follows
    in the text editor:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在终端窗口中输入 `code validate.py`。然后，在文本编辑器中按照以下方式编写代码：
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that `strip` will remove whitespace at the beginning or end of the input.
    Running this program, you will see that as long as an `@` symbol is inputted,
    the program will regard the input as valid.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`strip` 方法将移除输入字符串开头或结尾的空白字符。运行此程序，您将看到只要输入了 `@` 符号，程序就会将其视为有效。
- en: 'You can imagine, however, that one could input `@@` alone and the input could
    be regarded as valid. We could regard an email address as having at least one
    `@` and a `.` somewhere within it. Modify your code as follows:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以想象，然而，有人可能会输入 `@@` 独自存在，并且输入可能会被视为有效。我们可以认为电子邮件地址至少包含一个 `@` 和一个 `.`。修改您的代码如下：
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that while this works as expected, our user could be adversarial, typing
    simply `@.` would result in the program returning `valid`.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，虽然这符合预期，但我们的用户可能是敌意的，简单地输入 `@.` 就会导致程序返回 `valid`。
- en: 'We can improve the logic of our program as follows:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以改进程序的逻辑如下：
- en: '[PRE2]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the `strip` method is used to determine if `username` exists and
    if `.` is inside the `domain` variable. Running this program, a standard email
    address typed in by you could be considered `valid`. Typing in `malan@harvard`
    alone, you’ll find that the program regards this input as `invalid`.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `strip` 方法是如何用来判断 `username` 是否存在以及 `.` 是否在 `domain` 变量中的。运行此程序，您输入的标准电子邮件地址可能会被认为是
    `valid`。单独输入 `malan@harvard`，您会发现程序将此输入视为 `invalid`。
- en: 'We can be even more precise, modifying our code as follows:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以更加精确，修改我们的代码如下：
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how the `endswith` method will check to see if `domain` contains `.edu`.
    Still, however, a nefarious user could still break our code. For example, a user
    could type in `malan@.edu` and it would be considered valid.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `endswith` 方法将检查 `domain` 是否包含 `.edu`。然而，恶意用户仍然可以破坏我们的代码。例如，一个用户可以输入 `malan@.edu`，它将被认为是有效的。
- en: Indeed, we could keep iterating upon this code ourselves. However, it turns
    out that Python has an existing library called `re` that has a number of built-in
    functions that can validate user inputs against patterns.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实上，我们可以自己不断迭代此代码。然而，结果证明，Python 有一个名为 `re` 的现有库，它包含许多内置函数，可以验证用户输入与模式是否匹配。
- en: One of the most versatile functions within the library `re` is `search`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库 `re` 中最通用的函数之一是 `search`。
- en: 'The `search` function follows the signature `re.search(pattern, string, flags=0)`.
    Following this signature, we can modify our code as follows:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search` 函数遵循以下签名 `re.search(pattern, string, flags=0)`。根据此签名，我们可以修改我们的代码如下：'
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice this does not increase the functionality of our program at all. In fact,
    it is somewhat a step back.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这并没有增加程序的功能。事实上，这有点像是退步。
- en: 'We can further our program’s functionality. However, we need to advance our
    vocabulary around `validation`. It turns out that in the world of regular expressions
    there are certain symbols that allow us to identify patterns. At this point, we
    have only been checking for specific pieces of text like `@`. It so happens that
    many special symbols can be passed to the interpreter for the purpose of engaging
    in validation. A non-exhaustive list of those patterns is as follows:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以进一步扩展程序的功能。然而，我们需要在 `validation` 方面扩展我们的词汇。结果证明，在正则表达式的世界中，有一些符号允许我们识别模式。到目前为止，我们只检查了特定的文本片段，如
    `@`。事实上，许多特殊符号可以传递给解释器，用于进行验证。以下是一些模式的非详尽列表：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implementing this inside of our code, modify yours as follows:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的代码中实现此功能，修改如下：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that we don’t care what the username or domain is. What we care about
    is the pattern. `.+` is used to determine if anything is to the left of the email
    address and if anything is to the right of the email address. Running your code,
    typing in `malan@`, you’ll notice that the input is regarded as `invalid` as we
    would hope.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们不在乎用户名或域名是什么。我们关心的是模式。`.+` 用于确定电子邮件地址左侧是否有任何内容，以及电子邮件地址右侧是否有任何内容。运行你的代码，输入
    `malan@`，你会发现输入被认为是 `无效` 的，正如我们所希望的。
- en: 'Had we used a regular expression `.*@.*` in our code above, you can visualize
    this as follows: ![State Machine.](../Images/457f40ae965d89a74683c5efd7cc4935.png
    "cs50pWeek7Slide8.png")'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在上面的代码中使用了正则表达式 `.*@.*`，你可以这样可视化它：![状态机](../Images/457f40ae965d89a74683c5efd7cc4935.png
    "cs50pWeek7Slide8.png")
- en: Notice the depiction of the `state machine` of our regular expression. On the
    left, the interpreter begins evaluating the statement from left to right. Once
    we reach `q1` or question 1, the interpreter reads time and time again based on
    the expression handed to it. Then, the state is changed looking now at `q2` or
    the second question being validated. Again, the arrow indicates how the expression
    will be evaluated time and time again based upon our programming. Then, as depicted
    by the double circle, the final state of state machine is reached.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意正则表达式的 `状态机` 描述。在左侧，解释器从左到右开始评估语句。一旦我们到达 `q1` 或第一个问题，解释器就会根据提供的表达式反复读取。然后，状态改变，现在正在查看
    `q2` 或正在验证的第二个问题。再次，箭头指示表达式将根据我们的编程反复评估。然后，如双圆圈所示，达到状态机的最终状态。
- en: 'Considering the regular expression we used in our code, `.+@.+`, you can visualize
    it as follows: ![State Machine.](../Images/ba63eb4167867402adececc751c7be07.png
    "cs50pWeek7Slide10.png")'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到我们在代码中使用的正则表达式 `.+@.+`，你可以这样可视化它：![状态机](../Images/ba63eb4167867402adececc751c7be07.png
    "cs50pWeek7Slide10.png")
- en: Notice how `q1` is any character provided by the user, including ‘q2’ as 1 or
    more repetitions of characters. This is followed by the ‘@’ symbol. Then, `q3`
    looks for any character provided by the user, including `q4` as 1 or more repetitions
    of characters.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `q1` 是用户提供的任何字符，包括作为 1 或多个字符重复的 `'q2'`。然后是 `@` 符号。接着，`q3` 寻找用户提供的任何字符，包括作为
    1 或多个字符重复的 `q4`。
- en: The `re` and `re.search` functions and ones like them look for patterns.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re` 和 `re.search` 函数以及类似的函数寻找模式。'
- en: 'Continuing our improvement of this code, we could improve our code as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续改进我们的代码，我们可以这样改进我们的代码：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice, however, that one could type in `malan@harvard?edu` and it could be
    considered valid. Why is this the case? You might recognize that in the language
    of validation, a `.` means any character!
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，然而，你可以输入 `malan@harvard?edu` 并被认为是有效的。这是为什么？你可能会意识到，在验证的语言中，`.` 表示任何字符！
- en: 'We can modify our code as follows:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以修改我们的代码如下：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how we utilize the “escape character” or `\` as a way of regarding the
    `.` as part of our string instead of our validation expression. Testing your code,
    you will notice that `malan@harvard.edu` is regarded as valid, where `malan@harvard?edu`
    is invalid.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何利用“转义字符”或 `\` 将 `.` 视为字符串的一部分，而不是验证表达式的一部分。测试你的代码，你会发现 `malan@harvard.edu`
    被认为是有效的，而 `malan@harvard?edu` 是无效的。
- en: 'Now that we’re using escape characters, it’s a good time to introduce “raw
    strings”. In Python, raw strings are strings that *don’t* format special characters—instead,
    each character is taken at face-value. Imagine `\n`, for example. We’ve seen in
    an earlier lecture how, in a regular string, these two characters become one:
    a special newline character. In a raw string, however, `\n` is treated not as
    `\n`, the special character, but as a single `\` and a single `n`. Placing an
    `r` in front of a string tells the Python interpreter to treat the string as a
    raw string, similar to how placing an `f` in front of a string tells the Python
    interpreter to treat the string as a format string:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们正在使用转义字符，是时候介绍“原始字符串”了。在 Python 中，原始字符串是不格式化特殊字符的字符串——相反，每个字符都被当作字面值。例如，想象一下
    `\n`。我们在之前的讲座中看到，在一个普通字符串中，这两个字符变成一个：一个特殊的换行符。然而，在原始字符串中，`\n` 被视为不是 `\n` 这个特殊字符，而是单个
    `\` 和单个 `n`。在字符串前放置一个 `r` 告诉 Python 解释器将字符串视为原始字符串，类似于在字符串前放置一个 `f` 告诉 Python
    解释器将字符串视为格式化字符串：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we’ve ensured the Python interpreter won’t treat `\.` as a special character.
    Instead, simply as a `\` followed by a `.`—which, in regular expression terms,
    means matching a literal “.”.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经确保 Python 解释器不会将 `\.` 视为特殊字符。相反，它只是一个 `\` 后跟一个 `.`——在正则表达式中，这意味着匹配一个字面量的
    “.”。
- en: You can imagine still how our users could create problems for us! For example,
    you could type in a sentence such as `My email address is malan@harvard.edu.`
    and this whole sentence would be considered valid. We can be even more precise
    in our coding.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象我们的用户仍然可能给我们制造麻烦！例如，你可以输入一个句子，如 `My email address is malan@harvard.edu.`，整个句子都会被视为有效。我们可以使我们的编码更加精确。
- en: 'It just so happens we have more special symbols at our disposal in validation:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好我们还有更多特殊符号可供使用：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can modify our code using our added vocabulary as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用我们添加的词汇表按如下方式修改我们的代码：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice this has the effect of looking for this exact pattern matching to the
    start and end of the expression being validated. Typing in a sentence such as
    `My email address is malan@harvard.edu.` now is regarded as invalid.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这会使得验证表达式在开始和结束处寻找这个精确的模式匹配。输入一个句子，如 `My email address is malan@harvard.edu.`，现在被视为无效。
- en: We propose we can do even better! Even though we are now looking for the username
    at the start of the string, the `@` symbol, and the domain name at the end, we
    could type in as many `@` symbols as we wish! `malan@@@harvard.edu` is considered
    valid!
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提议我们可以做得更好！尽管我们现在正在寻找字符串开头的用户名、`@` 符号和结尾的域名，但我们可以输入任意多的 `@` 符号！`malan@@@harvard.edu`
    被视为有效！
- en: 'We can add to our vocabulary as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以按如下方式扩展我们的词汇表：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using these newfound abilities, we can modify our expression as follows:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些新获得的能力，我们可以按如下方式修改我们的表达式：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that `^` means to match at the start of the string. All the way at the
    end of our expression, `$` means to match at the end of the string. `[^@]+` means
    any character except an `@`. Then, we have a literal `@`. `[^@]+\.edu` means any
    character except an `@` followed by an expression ending in `.edu`. Typing in
    `malan@@@harvard.edu` is now regarded as invalid.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `^` 表示匹配字符串的开始。在我们的表达式的末尾，`$` 表示匹配字符串的末尾。`[^@]+` 表示除了 `@` 之外的任何字符。然后，我们有一个字面量
    `@`。`[^@]+\.edu` 表示除了 `@` 之外的任何字符，后面跟着以 `.edu` 结尾的表达式。输入 `malan@@@harvard.edu`
    现在被视为无效。
- en: 'We can still improve this regular expression further. It turns out there are
    certain requirements for what an email address can be! Currently, our validation
    expression is far too accommodating. We might only want to allow for characters
    normally used in a sentence. We can modify our code as follows:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以进一步改进这个正则表达式。结果证明，电子邮件地址有一些特定的要求！目前，我们的验证表达式过于宽容。我们可能只想允许在句子中通常使用的字符。我们可以按如下方式修改我们的代码：
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that `[a-zA-Z0-9_]` tells the validation that characters must be between
    `a` and `z`, between `A` and `Z`, between `0` and `9` and potentially include
    an `_` symbol. Testing the input, you’ll find that many potential user mistakes
    can be indicated.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `[a-zA-Z0-9_]` 告诉验证，字符必须在 `a` 到 `z`、`A` 到 `Z`、`0` 到 `9` 之间，并且可能包括一个 `_` 符号。测试输入，你会发现许多潜在的用户错误可以被指示出来。
- en: 'Thankfully, common patterns have been built into regular expressions by hard-working
    programmers. In this case, you can modify your code as follows:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运的是，程序员们已经将常见的模式内置到正则表达式中。在这种情况下，你可以按如下方式修改你的代码：
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that `\w` is the same as `[a-zA-Z0-9_]`. Thanks, hard-working programmers!
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `\w` 与 `[a-zA-Z0-9_]` 相同。感谢辛勤工作的程序员们！
- en: 'Here are some additional patterns we can add to our vocabulary:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些额外的模式我们可以添加到我们的词汇表中：
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we know that there are not simply `.edu` email addresses. We could modify
    our code as follows:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们知道不仅仅是 `.edu` 电子邮件地址。我们可以按如下方式修改我们的代码：
- en: '[PRE17]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the `|` has the impact of an `or` in our expression.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `|` 在我们的表达式中具有 `or` 的影响。
- en: 'Adding even more symbols to our vocabulary, here are some more to consider:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的词汇表中添加更多符号，以下是一些需要考虑的：
- en: '[PRE18]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Case Sensitivity
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大小写敏感性
- en: 'To illustrate how you might address issues around case sensitivity, where there
    is a difference between `EDU` and `edu` and the like, let’s rewind our code to
    the following:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了说明如何处理关于大小写敏感性的问题，其中 `EDU` 和 `edu` 以及类似的情况之间存在差异，让我们将我们的代码回滚到以下状态：
- en: '[PRE19]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how we have removed the `|` statements provided previously.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们已经移除了之前提供的 `|` 语句。
- en: Recall that within the `re.search` function, there is a parameter for `flags`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，在 `re.search` 函数中，有一个名为 `flags` 的参数。
- en: 'Some built-in flag variables are:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内置的标志变量是：
- en: '[PRE20]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Consider how you might use these in your code.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑你如何在你的代码中使用这些。
- en: Therefore, we can change our code as follows.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们可以按照以下方式更改我们的代码。
- en: '[PRE21]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how we added a third parameter `re.IGNORECASE`. Running this program
    with `MALAN@HARVARD.EDU`, the input is now considered valid.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们添加了第三个参数`re.IGNORECASE`。运行这个程序，输入`MALAN@HARVARD.EDU`，现在输入被认为是有效的。
- en: Consider the following email address `malan@cs50.harvard.edu`. Using our code
    above, this would be considered invalid. Why might that be?
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下电子邮件地址`malan@cs50.harvard.edu`。使用我们上面的代码，这将被认为是无效的。为什么可能是这样？
- en: Since there is an additional `.`, the program considers this invalid.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于多了一个额外的`.`，程序认为这是无效的。
- en: It turns out that we can, looking at our vocabulary from before, we can group
    together ideas.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，我们可以从之前的学习词汇中，将一些想法分组在一起。
- en: '[PRE22]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can modify our code as follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式修改我们的代码：
- en: '[PRE23]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how the `(\w+\.)?` communicates to the interpreter that this new expression
    can be there once or not at all. Hence, both `malan@cs50.harvard.edu` and `malan@harvard.edu`
    are considered valid.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`(\w+\.)?`告诉解释器这个新表达式可以出现一次或根本不出现。因此，`malan@cs50.harvard.edu`和`malan@harvard.edu`都被认为是有效的。
- en: 'Interestingly enough, the edits we have done so far to our code do not fully
    encompass all the checking that could be done to ensure a valid email address.
    Indeed, here is the full expression that one would have to type to ensure that
    a valid email is inputted:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 趣味的是，我们到目前为止对代码所做的编辑并没有完全涵盖所有可以做的检查以确保有效的电子邮件地址。确实，以下是确保输入有效电子邮件地址时必须输入的完整表达式：
- en: '[PRE24]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are other functions within the `re` library you might find useful. `re.match`
    and `re.fullmatch` are ones you might find exceedingly useful.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`库中还有其他你可能觉得有用的函数。`re.match`和`re.fullmatch`是你可能会发现极其有用的。'
- en: You can learn more in Python’s documentation of [re](https://docs.python.org/3/library/re.html).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[re](https://docs.python.org/3/library/re.html)文档中了解更多信息。
- en: Cleaning Up User Input
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理用户输入
- en: You should never expect your users to always follow your hopes for clean input.
    Indeed, users will often violate your intentions as a programmer.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你永远不应该期望你的用户总是遵循你对干净输入的期望。实际上，用户经常会违反程序员的本意。
- en: There are ways to clean up your data.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有方法可以清理你的数据。
- en: 'In the terminal window, type `code format.py`. Then, in the text-editor, code
    as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中，输入`code format.py`。然后，在文本编辑器中，按照以下方式编写代码：
- en: '[PRE25]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we have created, essentially, a “hello world” program. Running this
    program and typing in `David`, it works well! However, typing in `Malan, David`
    notice how the program does not function as intended. How could we modify our
    program to clean up this input?
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们实际上创建了一个“hello world”程序。运行这个程序并输入`David`，它运行得很好！然而，输入`Malan, David`时，你会注意到程序并没有按预期工作。我们如何修改我们的程序来清理这个输入？
- en: Modify your code as follows.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的代码。
- en: '[PRE26]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how `last, first = name.split(", ")` is run if there is a `,` in the
    name. Then, the name is standardized as first and last. Running our code, typing
    in `Malan, David`, you can see how this program does clean up at least one scenario
    where a user types in something unexpected.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`last, first = name.split(", ")`在名字中有`,`时执行。然后，名字被标准化为first和last。运行我们的代码，输入`Malan,
    David`，你可以看到这个程序至少清理了一个用户输入意外内容的情况。
- en: 'You might notice that typing in `Malan,David` with no space causes the interpreter
    to throw an error. Since we now know some regular expression syntax, let’s apply
    that to our code:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会注意到，在`Malan,David`中不输入空格会导致解释器抛出错误。既然我们现在知道了某些正则表达式语法，让我们将其应用到我们的代码中：
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that `re.search` can return a set of matches that are extracted from
    the user’s input. If matches are returned by `re.search`. Running this program,
    typing in `David Malan` notice how the `if` condition is not run and the name
    is returned. If you run the program by typing `Malan, David`, the name is also
    returned properly.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`re.search`可以返回一组从用户输入中提取的匹配项。如果`re.search`返回匹配项，运行这个程序，输入`David Malan`，注意`if`条件没有执行，并且返回了名字。如果你通过输入`Malan,
    David`运行程序，名字也会正确返回。
- en: 'It just so happens that we can request specific groups back using `matches.group`.
    We can modify our code as follows:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好我们可以使用`matches.group`请求特定的组。我们可以按照以下方式修改我们的代码：
- en: '[PRE28]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how, in this implementation, `group` is not plural (there is no `s`).
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在这个实现中，`group`不是复数（没有`s`）。
- en: 'Our code can be further tightened as follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将代码进一步优化如下：
- en: '[PRE29]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how `group(2)` and `group(1)` are concatenated together with a space.
    The first group is that which is left of the comma. The second group is that which
    is right of the comma.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`group(2)`和`group(1)`是如何用空格连接在一起的。第一个组是逗号左边的部分。第二个组是逗号右边的部分。
- en: 'Recognize still that typing in `Malan,David` with no space will still break
    our code. Therefore, we can make the following modification:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然要注意，如果输入`Malan,David`时没有空格，这仍然会破坏我们的代码。因此，我们可以进行以下修改：
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice the addition of the `*` in our validation statement. This code will now
    accept and properly process `Malan,David`. Further, it will properly handle `
    David,Malan `with many spaces in front of` David`.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在验证语句中添加了`*`。现在这段代码将接受并正确处理`Malan,David`。此外，它还将正确处理前面有多个空格的` David,Malan
    `。
- en: 'It is very common to utilize `re.search` as we have in the previous examples,
    where `matches` is on a line of code after. However, we can combine these statements:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们非常常见地使用`re.search`，其中`matches`是在代码行之后的。然而，我们可以组合这些语句：
- en: '[PRE31]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how we combine two lines of our code. The walrus `:=` operator assigns
    a value from right to left and allows us to ask a boolean question at the same
    time. Turn your head sideways and you’ll see why this is called a walrus operator.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何合并两行代码。walrus `:=` 操作符从右向左赋值，同时允许我们提出一个布尔问题。侧过头来看，你就会明白为什么这被称为walrus操作符。
- en: You can learn more in Python’s documentation of [re](https://docs.python.org/3/library/re.html).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[re](https://docs.python.org/3/library/re.html)文档中了解更多信息。
- en: Extracting User Input
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取用户输入
- en: So far, we have validated the user’s input and cleaned up the user’s input.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经验证了用户的输入并清理了用户的输入。
- en: 'Now, let’s extract some specific information from user input. In the terminal
    window, type `code twitter.py` and code as follows in the text editor window:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们从用户输入中提取一些具体信息。在终端窗口中，输入`code twitter.py`，然后在文本编辑器窗口中按如下方式编写代码：
- en: '[PRE32]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that if we type in `https://twitter.com/davidjmalan`, it shows exactly
    what the user typed. However, how would we be able to extract just the username
    and ignore the rest of the URL?
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果我们输入`https://twitter.com/davidjmalan`，它将显示用户输入的确切内容。然而，我们如何能够只提取用户名并忽略URL的其余部分？
- en: 'You can imagine how we would simply be able to get rid of the beginning of
    the standard Twitter URL. We can attempt this as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象我们如何简单地去除标准Twitter URL的开头部分。我们可以尝试如下操作：
- en: '[PRE33]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how the `replace` method allows us to find one item and replace it with
    another. In this case, we are finding part of the URL and replacing it with nothing.
    Typing in the full URL `https://twitter.com/davidjmalan`, the program effectively
    outputs the username. However, what are some shortcomings of this current program?
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`replace`方法如何允许我们找到一项并将其替换为另一项。在这种情况下，我们正在找到URL的一部分并将其替换为空。输入完整的URL `https://twitter.com/davidjmalan`，程序实际上输出了用户名。然而，这个当前程序有哪些不足之处？
- en: 'What if the user simply typed `twitter.com` instead of including the `https://`
    and the like? You can imagine many scenarios where the user may input or neglect
    to input parts of the URL that would create strange output by this program. To
    improve this program, we can code as follows:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户只是简单地输入`twitter.com`而没有包括`https://`等，会怎样？你可以想象出许多场景，用户可能会输入或遗漏输入URL的部分，这会导致程序输出奇怪的结果。为了改进这个程序，我们可以按如下方式编写代码：
- en: '[PRE34]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice how we utilize the `removeprefix` method. This method will remove the
    beginning of a string.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何利用`removeprefix`方法。这个方法将移除字符串的开头部分。
- en: Regular expressions simply allow us to succinctly express the patterns and goals.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式仅仅允许我们简洁地表达模式和目标。
- en: Within the `re` library, there is a method called `sub`. This method allows
    us to substitute a pattern with something else.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`re`库中，有一个名为`sub`的方法。这个方法允许我们用其他内容替换模式。
- en: The signature of the `sub` method is as follows
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`方法的签名如下'
- en: '[PRE35]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice how `pattern` refers to the regular expression we are looking for. Then,
    there is a `repl` string that we can replace the pattern with. Finally, there
    is the `string` that we want to do the substitution on.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`pattern`指的是我们正在寻找的正则表达式。然后是一个`repl`字符串，我们可以用它来替换模式。最后是我们要进行替换的`string`。
- en: 'Implementing this method in our code, we can modify our program as follows:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的代码中实现此方法后，我们可以按如下方式修改我们的程序：
- en: '[PRE36]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how executing this program and inputting `https://twitter.com/davidjmalan`
    produces the correct outcome. However, there are some problems still present in
    our code.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意执行此程序并输入 `https://twitter.com/davidjmalan` 会产生正确的结果。然而，我们的代码中仍然存在一些问题。
- en: 'The protocol, subdomain, and the possibility that the user inputted any part
    of the URL after the username are all reasons that this code is still not ideal.
    We can further address these shortcomings as follows:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议、子域以及用户可能在用户名之后输入URL任何部分的可能性，这些都是此代码仍然不是最佳方案的原因。我们可以进一步解决这些缺点，如下所示：
- en: '[PRE37]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how the `^` caret was added to the url. Notice also how the `.` could
    be interpreted improperly by the interpreter. Therefore, we escape it using a
    `\` to make it `\.` For the purpose of tolerating both `http` and `https`, we
    add a `?` to the end of `https?`, making the `s` optional. Further, to accommodate
    `www` we add `(www\.)?` to our code. Finally, just in case the user decides to
    leave out the protocol altogether, the `http://` or `https://` is made optional
    using `(https?://)`.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在url中添加了 `^` 上标。注意 `.` 也可能被解释器错误地解释。因此，我们使用 `\` 来转义它，使其变为 `\.`。为了容忍 `http`
    和 `https`，我们在 `https?` 的末尾添加一个 `?`，使 `s` 可选。此外，为了适应 `www`，我们在代码中添加 `(www\.)?`。最后，以防用户决定完全省略协议，我们将
    `http://` 或 `https://` 设置为可选，使用 `(https?://)`。
- en: Still, we are blindly expecting that what the user inputted a url that, indeed,
    has a username.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然盲目地期望用户输入的URL确实包含用户名。
- en: Using our knowledge of `re.search`, we can further improve our code.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用我们对 `re.search` 的了解，我们可以进一步改进我们的代码。
- en: '[PRE38]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how we are searching for the regular expression above in the string provided
    by the user. In particular, we are capturing that which appears at the end of
    the URL using `(.+)$` regular expression. Therefore, if the user fails to input
    a URL without a username, no input will be presented.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何在用户提供的字符串中搜索上述正则表达式的。特别是，我们使用 `(.+)$` 正则表达式捕获URL末尾出现的内容。因此，如果用户没有输入不带用户名的URL，则不会显示任何输入。
- en: 'Even further tightening up our program, we can utilize our `:=` operator as
    follows:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步收紧我们的程序，我们可以利用我们的 `:=` 操作符如下：
- en: '[PRE39]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that the `?:` tells the interpreter it does not have to capture what
    is in that spot in our regular expression.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `?:` 告诉解释器它不需要捕获正则表达式中的那个位置的内容。
- en: 'Still, we can be more explicit to ensure that the username inputted is correct.
    Using Twitter’s documentation, we can add the following to our regular expression:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以更加明确地确保输入的用户名是正确的。使用Twitter的文档，我们可以在我们的正则表达式中添加以下内容：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that the `[a-z0-9_]+` tells the interpreter to only expect `a-z`, `0-9`,
    and `_` as part of the regular expression. The `+` indicates that we are expecting
    one or more characters.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `[a-z0-9_]+` 告诉解释器只期望 `a-z`、`0-9` 和 `_` 作为正则表达式的一部分。`+` 表示我们期望一个或多个字符。
- en: You can learn more in Python’s documentation of [re](https://docs.python.org/3/library/re.html).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[re](https://docs.python.org/3/library/re.html)文档中了解更多信息。
- en: Summing Up
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Now, you’ve learned a whole new language of regular expressions that can be
    utilized to validate, clean up, and extract user input.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了一种全新的正则表达式语言，可以用来验证、清理和提取用户输入。
- en: Regular Expressions
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Case Sensitivity
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分大小写
- en: Cleaning Up User Input
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理用户输入
- en: Extracting User Input
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取用户输入
