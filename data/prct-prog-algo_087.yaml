- en: 1.4   Analysis of Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4   算法分析
- en: 原文：[https://algs4.cs.princeton.edu/14analysis](https://algs4.cs.princeton.edu/14analysis)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/14analysis](https://algs4.cs.princeton.edu/14analysis)
- en: 'As people gain experience using computers, they use them to solve difficult
    problems or to process large amounts of data and are invariably led to questions
    like these:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着人们在使用计算机方面的经验增加，他们用计算机来解决困难问题或处理大量数据，不可避免地会引发这样的问题：
- en: '*How long will my program take?*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我的程序需要多长时间？*'
- en: '*Why does my program run out of memory?*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么我的程序会耗尽内存？*'
- en: Scientific method.
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 科学方法。
- en: 'The very same approach that scientists use to understand the natural world
    is effective for studying the running time of programs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家用来理解自然界的方法同样适用于研究程序的运行时间：
- en: '*Observe* some feature of the natural world, generally with precise measurements.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*观察*自然界的某些特征，通常是通过精确的测量。'
- en: '*Hypothesize* a model that is consistent with the observations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*假设* 一个与观察一致的模型。'
- en: '*Predict* events using the hypothesis.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用假设*预测*事件。
- en: '*Verify* the predictions by making further observations.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过进一步观察*验证*预测。
- en: '*Validate* by repeating until the hypothesis and observations agree.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重复直到假设和观察一致来*验证*。
- en: The experiments we design must be *reproducible* and the hypotheses that we
    formulate must be *falsifiable*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的实验必须是*可重复的*，我们制定的假设必须是*可证伪的*。
- en: Observations.
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察。
- en: Our first challenge is to determine how to make quantitative measurements of
    the running time of our programs. [Stopwatch.java](Stopwatch.java.html) is a data
    type that measures the elapsed running time of a program.![stopwatch API](../Images/eb851a68937e3be9fcd8758438772bb9.png)[ThreeSum.java](ThreeSum.java.html)
    counts the number of triples in a file of *N* integers that sums to 0 (ignoring
    integer overflow). [DoublingTest.java](DoublingTest.java.html) generates a sequence
    of random input arrays, doubling the array size at each step, and prints the running
    times of `ThreeSum.count()` for each input size. [DoublingRatio.java](DoublingRatio.java.html)
    is similar but also output the ratios in running times from one size to the next.![loglog
    plot of running time](../Images/419879ebb7433d723fba083a7250cf53.png)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个挑战是确定如何对程序的运行时间进行定量测量。[Stopwatch.java](Stopwatch.java.html) 是一种测量程序运行时间的数据类型。![秒表
    API](../Images/eb851a68937e3be9fcd8758438772bb9.png)[ThreeSum.java](ThreeSum.java.html)
    计算一个包含 *N* 个整数的文件中总和为 0 的三元组的数量（忽略整数溢出）。[DoublingTest.java](DoublingTest.java.html)
    生成一系列随机输入数组，每一步将数组大小加倍，并打印 `ThreeSum.count()` 的运行时间。[DoublingRatio.java](DoublingRatio.java.html)
    类似，但还输出从一个大小到下一个大小的运行时间比率。![运行时间的对数图](../Images/419879ebb7433d723fba083a7250cf53.png)
- en: Mathematical models.
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学模型。
- en: 'The total running time of a program is determined by two primary factors: the
    cost of executing each statement and the frequency of execution of each statement.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序的总运行时间由两个主要因素决定：执��每个语句的成本和每个语句的执行频率。
- en: '*Tilde approximations.* We use tilde approximations, where we throw away low-order
    terms that complicate formulas. We write *~ f(N)* to represent any function that
    when divided by *f(N)* approaches 1 as *N* grows. We write *g(N) ~ f(N)* to indicate
    that *g(N) / f(N)* approaches 1 as *N* grows.![tilde approximations](../Images/eb1844e39b170a1095ec45d7c3c0c45d.png)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*波浪线近似。* 我们使用波浪线近似，其中我们丢弃复杂化公式的低阶项。我们写 *~ f(N)* 来表示任何函数，当除以 *f(N)* 时，随着 *N*
    的增长趋近于 1。我们写 *g(N) ~ f(N)* 来表示当 *N* 增长时，*g(N) / f(N)* 趋近于 1。![波浪线近似](../Images/eb1844e39b170a1095ec45d7c3c0c45d.png)'
- en: '*Order-of-growth classifications.* Most often, we work with tilde approximations
    of the form *g(N) ~ a f(N)* where *f(N) = N^b log^c N* and refer to *f(N)* as
    the The *order of growth* of *g(N)*. We use just a few structural primitives (statements,
    conditionals, loops, nesting, and method calls) to implement algorithms, so very
    often the order of growth of the cost is one of just a few functions of the problem
    size *N*.![order-of-growth classifications](../Images/def2e557e026537a8e559a384a2ec2b1.png)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*增长顺序分类。* 我们通常使用形式为 *g(N) ~ a f(N)* 的波浪线近似，其中 *f(N) = N^b log^c N*，并将 *f(N)*
    称为 *g(N)* 的*增长顺序*。我们只使用几个结构原语（语句、条件、循环、嵌套和方法调用）来实现算法，因此成本的增长顺序往往是问题大小 *N* 的几个函数之一。![增长顺序分类](../Images/def2e557e026537a8e559a384a2ec2b1.png)'
- en: '*Cost model.* We focus attention on properties of algorithms by articulating
    a *cost model* that defines the basic operations. For example, an appropriate
    cost model for the 3-sum problem is the number of times we access an array entry,
    for read or write.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*成本模型。* 我们通过阐明定义基本操作的*成本模型*来关注算法的属性。例如，对于 3-sum 问题，一个适当的成本模型是我们访问数组条目的次数，无论是读取还是写入。'
- en: '**Property.** The order of growth of the running time of [ThreeSum.java](ThreeSum.java.html)
    is N^3.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**性质。** [ThreeSum.java](ThreeSum.java.html) 的运行时间增长顺序为 N^3。'
- en: '**Proposition.** The brute-force 3-sum algorithm uses *~ N^3 / 2* array accesses
    to compute the number of triples that sum to 0 among *N* numbers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** 暴力 3-sum 算法使用*~ N^3 / 2* 数组访问来计算在 *N* 个数字中总和为 0 的三元组的数量。'
- en: Designing faster algorithms.
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计更快的算法。
- en: One of the primary reasons to study the order of growth of a program is to help
    design a faster algorithm to solve the same problem. Using mergesort and binary
    search, we develop faster algorithms for the 2-sum and 3-sum problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 研究程序增长顺序的一个主要原因是帮助设计更快的算法来解决相同的问题。使用归并排序和二分查找，我们为 2-sum 和 3-sum 问题开发了更快的算法。
- en: '*2-sum.* The brute-force solution [TwoSum.java](TwoSum.java.html) takes time
    proportional to N^2. [TwoSumFast.java](TwoSumFast.java.html) solves the 2-sum
    problem in time proportional to N log N time.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2-sum.* 暴力解决方案 [TwoSum.java](TwoSum.java.html) 需要的时间与 N^2 成正比。[TwoSumFast.java](TwoSumFast.java.html)
    在时间上与 N log N 成正比地解决了 2-sum 问题。'
- en: '*3-sum.* [ThreeSumFast.java](ThreeSumFast.java.html) solves the 3-sum problem
    in time proportional to N^2 log N time.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3-sum.* [ThreeSumFast.java](ThreeSumFast.java.html) 在时间上与 N^2 log N 成正比地解决了
    3-sum 问题。'
- en: Coping with dependence on inputs.
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理对输入的依赖。
- en: For many problems, the running time can vary widely depending on the input.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多问题，运行时间可能会根据输入而有很大的变化。
- en: '*Input models.* We can carefully model the kind of input to be processed. This
    approach is challenging because the model may be unrealistic.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入模型.* 我们可以仔细地对要处理的输入类型进行建模。这种方法具有挑战性，因为模型可能是不现实的。'
- en: '*Worst-case performance guarantees.* Running time of a program is less than
    a certain bound (as a function of the input size), no matter what the input. Such
    a conservative approach might be appropriate for the software that runs a nuclear
    reactor or a pacemaker or the brakes in your car.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最坏情况性能保证.* 程序的运行时间小于某个界限（作为输入大小的函数），无论输入是什么。这种保守的方法可能适用于运行核反应堆、心脏起搏器或汽车刹车的软件。'
- en: '*Randomized algorithms.* One way to provide a performance guarantee is to introduce
    randomness, e.g., quicksort and hashing. Every time you run the algorithm, it
    will take a different amount of time. These guarantees are not absolute, but the
    chance that they are invalid is less than the chance your computer will be struck
    by lightning. Thus, such guarantees are as useful in practice as worst-case guarantees.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机算法.* 提供性能保证的一种方法是引入随机性，例如快速排序和哈希。每次运行算法时，它都会花费不同的时间。这些保证并不是绝对的，但它们无效的几率小于你的计算机被闪电击中的几率。因此，这些保证在实践中与最坏情况的保证一样有用。'
- en: '*Amortized analysis.* For many applications, the algorithm input might be not
    just data, but the sequence of operations performed by the client. Amortized analysis
    provides a worst-case performance guarantee on a *sequence* of operations.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*摊销分析.* 对于许多应用程序，算法的输入可能不仅仅是数据，还包括客户端执行的操作序列。摊销分析提供了对*操作序列*的最坏情况性能保证。'
- en: '**Proposition.** In the linked-list implementation of `Bag`, `Stack`, and `Queue`,
    all operations take constant time in the worst case.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题.** 在`Bag`、`Stack`和`Queue`的链表实现中，所有操作在最坏情况下都需要常数时间。'
- en: '**Proposition.** In the resizing-array implementation of `Bag`, `Stack`, and
    `Queue`, starting from an empty data structure, any sequence of *N* operations
    takes time proportional to *N* in the worst case (amortized constant time per
    operation).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题.** 在`Bag`、`Stack`和`Queue`的调整大小数组实现中，从空数据结构开始，任何长度为*N*的操作序列在最坏情况下需要与*N*成比例的时间（摊销每个操作的常数时间）。'
- en: Memory usage.
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存使用。
- en: To estimate how much memory our program uses, we can count up the number of
    variables and weight them by the number of bytes according to their type. For
    a *typical* 64-bit machine,
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要估算我们的程序使用了多少内存，我们可以计算变量的数量，并根据它们的类型按字节加权。对于*典型*的64位机器，
- en: '*Primitive types.* the following table gives the memory requirements for primitive
    types.![memory requirements for primitive types](../Images/d72d4771bd107163334f6620d058a355.png)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始类型.* 下表给出了原始类型的内存需求。'
- en: '*Objects.* To determine the memory usage of an object, we add the amount of
    memory used by each instance variable to the overhead associated with each object,
    typically 16 bytes. Moreover, the memory usage is typically padded to be a multiple
    of 8 bytes (on a 64-bit machine).![memory requirement of Integer](../Images/a05c5b3a215b8887262d2b30cbcd1502.png)
    ![memory requirement of Date](../Images/0dd6a7baa6e384821da604ab32b2d2a3.png)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象.* 要确定对象的内存使用量，我们将每个实例变量使用的内存量加到与每个对象相关联的开销上，通常为16字节。此外，内存使用量通常会填充为8字节的倍数（在64位机器上）。![Integer的内存需求](../Images/a05c5b3a215b8887262d2b30cbcd1502.png)
    ![Date的内存需求](../Images/0dd6a7baa6e384821da604ab32b2d2a3.png)'
- en: '*References.* A reference to an object typically is a memory address and thus
    uses 8 bytes of memory (on a 64-bit machine).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参考文献.* 对象的引用通常是一个内存地址，因此在64位机器上使用8字节的内存。'
- en: '*Linked lists.* A nested non-static (inner) class such as our `Node` class
    requires an extra 8 bytes of overhead (for a reference to the enclosing instance).![memory
    requirement of Node](../Images/35adbdc31e12c537791f79e636e4023d.png)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链表.* 嵌套的非静态（内部）类，比如我们的`Node`类，需要额外的8字节开销（用于引用封闭实例）。![Node的内存需求](../Images/35adbdc31e12c537791f79e636e4023d.png)'
- en: '*Arrays.* Arrays in Java are implemented as objects, typically with extra overhead
    for the length. An array of primitive-type values typically requires 24 bytes
    of header information (16 bytes of object overhead, 4 bytes for the length, and
    4 bytes of padding) plus the memory needed to store the values.![memory requirement
    of arrays](../Images/09149479ff71f0c747a3c0417420b92c.png)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组.* Java中的数组被实现为对象，通常需要额外的开销来存储长度。原始类型值的数组通常需要24字节的头信息（16字节的对象开销，4字节的长度，和4字节的填充），再加上存储值所需的内存。![数组的内存需求](../Images/09149479ff71f0c747a3c0417420b92c.png)'
- en: '*Strings.* A Java 7 string of length *N* typically uses 32 bytes (for the `String`
    object) plus 24 + 2*N* bytes (for the array that contains the characters) for
    a total of 56 + 2*N* bytes.![memory requirement of String](../Images/473b238343cba579c4150be658f5c2d8.png)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串.* Java 7中长度为*N*的字符串通常使用32字节（用于`String`对象），再加上24 + 2*N*字节（用于包含字符的数组），总共为56
    + 2*N*字节。![String的内存需求](../Images/473b238343cba579c4150be658f5c2d8.png)'
- en: Depending on context, we may or may not count the memory references by an object
    (recursively). For example, we count the memory for the `char[]` array in the
    memory for a `String` object because this memory is allocated when the string
    is created. But, we would not ordinarily count the memory for the `String` objects
    in a `StackOfStrings` object because the `String` objects are created by the client.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，我们可能会或不会递归地计算对象的内存引用。例如，我们会计算`String`对象中的`char[]`数组的内存，因为这段内存是在创建字符串时分配的。但是，我们通常不会计算`StackOfStrings`对象中`String`对象的内存，因为这些`String`对象是由客户端创建的。
- en: Q + A
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** How do I increase the amount of memory and stack space that Java allocates?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**问.** 如何增加Java分配的内存和堆栈空间？'
- en: '**A.** You can increase the amount of memory allotted to Java by executing
    with `java -Xmx200m Hello` where 200m means 200 megabytes. The default setting
    is typically 64MB. You can increase the amount of stack space allotted to Java
    by executing with `java -Xss200k Hello` where 200k means 200 kilobytes. The default
    setting is typically 128KB. It''s possible to increase both the amount of memory
    and stack space by executing with `java -Xmx200m -Xss200k Hello`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 你可以通过使用 `java -Xmx200m Hello` 来增加分配给 Java 的内存量，其中 200m 表示 200 兆字节。默认设置通常为
    64MB。你可以通过使用 `java -Xss200k Hello` 来增加分配给 Java 的堆栈空间量，其中 200k 表示 200 千字节。默认设置通常为
    128KB。你可以通过使用 `java -Xmx200m -Xss200k Hello` 来同时增加内存和堆栈空间的量。'
- en: '**Q.** What is the purpose of padding?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 填充的目的是什么？'
- en: '**A.** Padding makes all objects take space that is a mulitple of 8 bytes.
    This can waste some memory but it speeds up memory access and garbage collection.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 填充使所有对象占用的空间是 8 字节的倍数。这可能会浪费一些内存，但可以加快内存访问和垃圾回收速度。'
- en: '**Q.** I get inconsistent timing information in my computational experiments.
    Any advice?'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我在我的计算实验中得到了不一致的时间信息。有什么建议吗？'
- en: '**A.** Be sure that you computation is consuming enough CPU cycles so that
    you can measure it accurately. Generally, 1 second to 1 minute is reasonable.
    If you are using huge amounts of memory, that could be the bottleneck. Consider
    turning off the HotSpot compiler, using `java -Xint`, to ensure a more uniform
    testing environment. The downside is that you are no long measuring exactly what
    you want to measure, i.e., actual running time.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 确保你的计算消耗足够的 CPU 周期，以便你可以准确地测量它。通常，1 秒到 1 分钟是合理的。如果你使用了大量内存，那可能是瓶颈。考虑关闭
    HotSpot 编译器，使用 `java -Xint`，以确保更统一的测试环境。缺点是你不再准确地测量你想要测量的内容，即实际运行时间。'
- en: '**Q.** Does the linked-list implementation of a stack or queue really guarantee
    constant time per operation if we take into account garbage collection and other
    runtime processes?'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果考虑垃圾回收和其他运行时进程，链表实现的栈或队列是否真的保证每次操作的常数时间？'
- en: '**A.** Our analysis does not account for many system effects (such as caching,
    garbage collection, and just-in-time compilation)—in practice, such effects are
    important. In particular, the default Java garbage collector achieves only a constant
    amortized time per operation guarantee. However, there are *real-time* garbage
    collectors that guarantee constant time per operation in the worst case. [Real
    time Java](http://en.wikipedia.org/wiki/Real_time_Java) provides extensions to
    Java that provide worst-case performance guarantees for various runtime processes
    (such as garbage collection, class loading, Just-in-time compilation, and thread
    scheduling).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 我们的分析没有考虑许多系统效应（如缓存、垃圾回收和即时编译）-在实践中，这些效应很重要。特别是，默认的 Java 垃圾收集器仅保证每次操作的摊销常数时间。然而，有*实时*垃圾收集器保证最坏情况下每次操作的常数时间。[实时
    Java](http://en.wikipedia.org/wiki/Real_time_Java)提供了 Java 的扩展，为各种运行时进程（如垃圾回收、类加载、即时编译和线程调度）提供最坏情况下的性能保证。'
- en: Exercises
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: 'Give the order of growth (as a function of *N*) of the running times of each
    of the following code fragments:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出以下代码片段的运行时间的增长顺序（作为 *N* 的函数）：
- en: '[PRE0]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Answer*: linear (N + N/2 + N/4 + ...); linear (1 + 2 + 4 + 8 + ...); linearithmic
    (the outer loop loops lg N times).'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：线性（N + N/2 + N/4 + ...）；线性（1 + 2 + 4 + 8 + ...）；线性对数级（外部循环循环 lg N 次）。'
- en: Creative Problems
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意问题
- en: '**4-sum.** Develop a brute-force solution [FourSum.java](FourSum.java.html)
    to the 4-sum problem.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**4-求和。** 对[FourSum.java](FourSum.java.html)问题开发一个蛮力解决方案。'
- en: '**Local minimum in an array.** Write a program that, given an array `a[]` of
    *n* distinct integers, finds a *local minimum*: an index `i` such that both`a[i]
    < a[i-1]` and `a[i] < a[i+1]` (assuming the neighboring entry is in bounds). Your
    program should use ~ 2 lg *n* compares in the worst case.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数组中的局部最小值。** 编写一个程序，给定一个由 *n* 个不同整数组成的数组 `a[]`，找到一个*局部最小值*：一个索引 `i`，使得`a[i]
    < a[i-1]` 和 `a[i] < a[i+1]`（假设相邻条目在范围内）。在最坏情况下，你的程序应该使用 ~ 2 lg *n* 次比较。'
- en: '*Answer*: Examine the middle value `a[n/2]` and its two neighbors `a[n/2 -
    1]` and `a[n/2 + 1]`. If `a[n/2]` is a local minimum, stop; otherwise search in
    the half with the smaller neighbor.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：检查中间值 `a[n/2]` 及其两个邻居 `a[n/2 - 1]` 和 `a[n/2 + 1]`。如果 `a[n/2]` 是局部最小值，则停止；否则在较小邻居的一半中搜索。'
- en: '**Local minimum in a matrix.** Given an *n*-by-*n* array `a[]` of *n*² distinct
    integers, design an algorithm that runs in time proportional to *n* log *n* to
    find a *local minimum*: an pair of indices `i` and `j` such that `a[i][j] < a[i+1][j]`,
    `a[i][j] < a[i][j+1]`, `a[i][j] < a[i-1][j]`, and `a[i][j] < a[i][j-1]` (assuming
    the neighboring entry is in bounds).'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**矩阵中的局部最小值。** 给定一个由 *n*² 个不同整数组成的 *n*×*n* 数组 `a[]`，设计一个算法，其运行时间与 *n* log *n*
    成正比，以找到一个*局部最小值*：一对索引 `i` 和 `j`，使得 `a[i][j] < a[i+1][j]`，`a[i][j] < a[i][j+1]`，`a[i][j]
    < a[i-1][j]`，以及 `a[i][j] < a[i][j-1]`（假设相邻条目在范围内）。'
- en: '*Hint*: Find the minimum entry in row `n/2`, say `a[n/2][j]`. If it''s a local
    minimum, then return it. Otherwise, check it''s two vertical neighbors `a[n/2-1][j]`
    and `a[n/2+1][j]`. Recur in the half with the smaller neighbor.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：找到第 `n/2` 行中的最小条目，称为 `a[n/2][j]`。如果它是局部最小值，则返回它。否则，检查它的两个垂直邻居 `a[n/2-1][j]`
    和 `a[n/2+1][j]`。在较小邻居的一半中进行递归。'
- en: '*Extra credit*: Design an algorithm that takes times proportional to *n*.'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*额外奖励*：设计一个算法，其运行时间与 *n* 成正比。'
- en: '**Bitonic search.** An array is *bitonic* if it is comprised of an increasing
    sequence of integers followed immediately by a decreasing sequence of integers.
    Write a program that, given a bitonic array of *n* distinct `int` values, determines
    whether a given integer is in the array. Your program should use ~ 3 log *n* compares
    in the worst case.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双峰搜索。** 如果一个数组由一个递增的整数序列紧接着一个递减的整数序列组成，则该数组是*双峰*的。编写一个程序，给定一个由 *n* 个不同 `int`
    值组成的双峰数组，确定给定的整数是否在数组中。在最坏情况下，你的程序应该使用 ~ 3 log *n* 次比较。'
- en: '*Answer*: Use a version of binary search, as in [BitonicMax.java](BitonicMax.java.html),
    to find the maximum (in ~ 1 lg *n* compares); then use binary search to search
    in each piece (in ~ 1 lg *n* compares per piece).'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*: 使用二分查找的一个版本，如[BitonicMax.java](BitonicMax.java.html)中所示，找到最大值（在~ 1 lg
    *n*次比较中）；然后使用二分查找在每个片段中搜索（每个片段在~ 1 lg *n*次比较中）。'
- en: '**Binary search with only addition and subtraction.** [[Mihai Patrascu](http://people.csail.mit.edu/mip/probs.html)]
    Write a program that, given an array of *n* distinct integers in ascending order,
    determines whether a given integer is in the array. You may use only additions
    and subtractions and a constant amount of extra memory. The running time of your
    program should be proportional to log *n* in the worst case.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**只使用加法和减法的二分查找。** [[Mihai Patrascu](http://people.csail.mit.edu/mip/probs.html)]
    编写一个程序，给定一个按升序排列的包含*n*个不同整数的数组，确定给定的整数是否在数组中。你只能使用加法和减法以及恒定数量的额外内存。你的程序在最坏情况下的运行时间应与log
    *n*成比例。'
- en: '*Answer*: Instead of searching based on powers of two (binary search), use
    Fibonacci numbers (which also grow exponentially). Maintain the current search
    range to be [i, i + F(k)] and keep F(k), F(k-1) in two variables. At each step
    compute F(k-2) via subtraction, check element i + F(k-2), and update the range
    to either [i, i + F(k-2)] or [i + F(k-2), i + F(k-2) + F(k-1)].'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*: 不要基于二的幂（二分查找）进行搜索，而是使用斐波那契数（也呈指数增长）。保持当前搜索范围为[i, i + F(k)]，并将F(k)、F(k-1)保存在两个变量中。在每一步中，通过减法计算F(k-2)，检查元素i
    + F(k-2)，并将范围更新为[i, i + F(k-2)]或[i + F(k-2), i + F(k-2) + F(k-1)]。'
- en: '**Binary search with duplicates.** Modify binary search so that it always returns
    the smallest (largest) index of a key of an item matching the search key.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带有重复项的二分查找。** 修改二分查找，使其始终返回与搜索键匹配的项的键的最小（最大）索引。'
- en: '**Throwing eggs from a building.** Suppose that you have an *N*-story building
    and plenty of eggs. Suppose also that an egg is broken if it is thrown off floor
    *F* or higher, and unbroken otherwise. First, devise a strategy to determine the
    value of *F* such that the number of broken eggs is *~ lg N* when using *~ lg
    N* throws, then find a way to reduce the cost to *~ 2 lg F* when *N* is much larger
    than *F*.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从建筑物上扔鸡蛋。** 假设你有一座*N*层的建筑物和大量的鸡蛋。假设如果鸡蛋从第*F*层或更高处扔下，就会摔碎，否则不会。首先，设计一种策略来确定*F*的值，使得在使用*~
    lg N*次扔鸡蛋时破碎的鸡蛋数量为*~ lg N*，然后找到一种方法将成本降低到*~ 2 lg F*，当*N*远大于*F*时。'
- en: '*Hint*: binary search; repeated doubling and binary search.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*: 二分查找；重复加倍和二分查找。'
- en: '**Throwing two eggs from a building.** Consider the previous question, but
    now suppose you only have two eggs, and your cost model is the number of throws.
    Devise a strategy to determine *F* such that the number of throws is at most 2
    sqrt(√ *N*), then find a way to reduce the cost to *~c √ F* for some constant
    c.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从建筑物上扔两个鸡蛋。** 考虑前面的问题，但现在假设你只有两个鸡蛋，你的成本模型是扔鸡蛋的次数。设计一种策略，确定*F*，使得扔鸡蛋的次数最多为2
    sqrt(√ *N*)，然后找到一种方法将成本降低到*~c √ F*，其中c是一个常数。'
- en: '*Solution to Part 1*: To achieve 2 * sqrt(N), drop eggs at floors sqrt(N),
    2 * sqrt(N), 3 * sqrt(N), ..., sqrt(N) * sqrt(N). (For simplicity, we assume here
    that sqrt(N) is an integer.) Let assume that the egg broke at level k * sqrt(N).
    With the second egg you should then perform a linear search in the interval (k-1)
    * sqrt(N) to k * sqrt(N). In total you will be able to find the floor F in at
    most 2 * sqrt(N) trials.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*第一部分的解决方案*: 为了达到2 * sqrt(N)，在sqrt(N)、2 * sqrt(N)、3 * sqrt(N)、...、sqrt(N) *
    sqrt(N)层放置鸡蛋。（为简单起见，我们假设sqrt(N)是一个整数。）假设鸡蛋在第k * sqrt(N)层摔碎。用第二个鸡蛋，你应该在区间(k-1)
    * sqrt(N)到k * sqrt(N)中进行线性搜索。总共，你最多需要进行2 * sqrt(N)次试验就能找到楼层F。'
- en: '*Hint for Part 2*: 1 + 2 + 3 + ... k ~ 1/2 k^2.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*第二部分的提示*: 1 + 2 + 3 + ... k ~ 1/2 k^2。'
- en: '**Hot or cold.** Your goal is the guess a secret integer between 1 and *N*.
    You repeatedly guess integers between 1 and *N*. After each guess you learn if
    it equals the secret integer (and the game stops); otherwise (starting with the
    second guess), you learn if the guess is *hotter* (closer to) or *colder* (farther
    from) the secret number than your previous guess. Design an algorithm that finds
    the secret number in *~ 2 lg N* guesses. Then, design an algorithm that finds
    the secret number in *~ 1 lg N* guesses.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**热还是冷。** 你的目标是猜测一个介于1和*N*之间的秘密整数。你反复猜测介于1和*N*之间的整数。每次猜测后，你会得知它是否等于秘密整数（游戏停止）；否则（从第二次猜测开始），你会得知猜测是*更热*（更接近）还是*更冷*（距离更远）比你之前的猜测。设计一个算法，在*~
    2 lg N*次猜测中找到秘密数字。然后，设计一个算法，在*~ 1 lg N*次猜测中找到秘密数字。'
- en: '*Hint*: use binary search for the first part. For the second part, first design
    an algorithm that solves the problem in *~1 lg N* guesses assuming you are permitted
    to guess integers in the range -*N* to 2*N*.'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*: 第一部分使用二分查找。对于第二部分，首先设计一个算法，在*~1 lg N*次猜测中解决问题，假设你被允许在范围-*N*到2*N*中猜测整数。'
- en: Web Exercises
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: Let f be a monotonically increasing function with f(0) < 0 and f(N) > 0\. Find
    the smallest integer i such that f(i) > 0. Devise an algorithm that makes O(log
    N) calls to f().
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设f是一个单调递增的函数，满足f(0) < 0且f(N) > 0。找到最小的整数i，使得f(i) > 0。设计一个算法，使得对f()的调用次数为O(log
    N)。
- en: '**Floor and ceiling.** Given a set of comparable elements, the *ceiling* of
    x is the smallest element in the set greater than or equal to x, and the *floor*
    is the largest element less than or equal to x. Suppose you have an array of N
    items in ascending order. Give an O(log N) algorithm to find the floor and ceiling
    of x.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**上下取整。** 给定一组可比较的元素，x的*上取整*是集合中大于或等于x的最小元素，*下取整*是小于或等于x的最大元素。假设你有一个按升序排列的包含N个项的数组。给出一个O(log
    N)的算法，找到x的上取整和下取整。'
- en: '**Rank with lg N two-way compares.** Implement `rank()` so that it uses ~ 1
    lg N two-way compares (instead of ~ 1 lg N 3-way compares).'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用lg N两路比较进行排名。** 实现`rank()`，使其使用~ 1 lg N两路比较（而不是~ 1 lg N三路比较）。'
- en: '**Identity.** Given an array `a` of N distinct integers (positive or negative)
    in ascending order. Devise an algorithm to find an index `i` such that `a[i] =
    i` if such an index exists. Hint: binary search.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**身份。** 给定一个按升序排列的包含 N 个不同整数（正数或负数）的数组 `a`。设计一个算法来找到一个索引 `i`，使得 `a[i] = i`，如果这样的索引存在的话。提示：二分查找。'
- en: '**Majority.** Given an array of N strings. An element is a *majority* if it
    appears more than N/2 times. Devise an algorithm to identify the majority if it
    exists. Your algorithm should run in linearithmic time.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多数派。** 给定一个包含 N 个字符串的数组。如果一个元素出现次数超过 N/2 次，则称其为*多数派*。设计一个算法来识别多数派是否存在。你的算法应在线性对数时间内运行。'
- en: '**Majority.** Repeat the previous exercise, but this time your algorithm should
    run in linear time, and only use a constant amount of extra space. Moreover, you
    may only compare elements for equality, not for lexicographic order.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多数派。** 重复上一个练习，但这次你的算法应在线性时间内运���，并且只使用恒定数量的额外空间。此外，你只能比较元素是否相等，而不能比较字典顺序。'
- en: '*Answer*: if a and b are two elements and a != b, then remove both of them;
    majority still remains. Use N-1 compares to find candidate for majority; use N-1
    comparisons to check if candidate really is a majority.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：如果 a 和 b 是两个元素且 a != b，则移除它们两个；多数派仍然存在。使用 N-1 次比较找到多数派的候选者；使用 N-1 次比较检查候选者是否真的是多数派。'
- en: '**Second smallest.** Give an algorithm to find the smallest and second smallest
    elements from a list of N items using the minimum number of comparisons. *Answer*:
    you can do it in ceil(N + lg(N) - 2) comparisons by building a tournament tree
    where each parent is the minimum of its two children. The minimum ends up at the
    root; the second minimum is on the path from the root to the minimum.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第二小元素。** 给出一个算法，使用最少的比较次数从 N 个项目的列表中找到最小和第二小的元素。*答案*：通过构建一个锦标赛树，在 ceil(N
    + lg(N) - 2) 次比较中完成。每个父节点都是其两个子节点中的最小值。最小值最终在根节点处；第二小值在根节点到最小值的路径上。'
- en: '**Find a duplicate.** Given an array of N elements in which each element is
    an integer between 1 and N, write an algorithm to determine if there are any duplicates.
    Your algorithm should run in linear time and use O(1) extra space. *Hint*: you
    may destroy the array.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找重复项。** 给定一个包含 N 个元素的数组，其中每个元素是介于 1 和 N 之间的整数，请编写一个算法来确定是否存在任何重复项。你的算法应在线性时间内运行，并使用
    O(1) 额外空间。*提示*：你可以破坏数组。'
- en: '**Find a duplicate.** Given an array of N+1 elements in which each element
    is an integer between 1 and N, write an algorithm to find a duplicate. Your algorithm
    should run in linear time, use O(1) extra space, and may not modify the original
    array. *Hint*: pointer doubling.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找重复项。** 给定一个包含 N+1 个元素的数组，其中每个元素是介于 1 和 N 之间的整数，请编写一个算法来查找重复项。你的算法应在线性时间内运行，使用
    O(1) 额外空间，并且不得修改原始数组。*提示*：指针加倍。'
- en: '**Finding common elements.** Given two arrays of N 64-bit integers, design
    an algorithm to print out all elements that appear in both lists. The output should
    be in sorted order. Your algorithm should run in N log N. *Hint*: mergesort, mergesort,
    merge. *Remark*: not possible to do better than N log N in comparison based model.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找共同元素。** 给定两个包含 N 个 64 位整数的数组，设计一个算法来打印出两个列表中都出现的所有元素。输出应按排序顺序排列。你的算法应在
    N log N 时间内运行。*提示*：归并排序，归并排序，合并。*备注*：在基于比较的模型中，不可能比 N log N 更好。'
- en: '**Finding common elements.** Repeat the above exercise but assume the first
    array has M integers and the second has N integers where M is much less than N.
    Give an algorithm that runs in N log M time. *Hint*: sort and binary search.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找共同元素。** 重复上述练习，但假设第一个数组有 M 个整数，第二个数组有 N 个整数，其中 M 远小于 N。给出一个在 N log M 时间内运行的算法。*提示*：排序和二分查找。'
- en: '**Anagrams.** Design a O(N log N) algorithm to read in a list of words and
    print out all anagrams. For example, the strings "comedian" and "demoniac" are
    anagrams of each other. Assume there are N words and each word contains at most
    20 letters. Designing a O(N^2) algorithms should not be too difficult, but getting
    it down to O(N log N) requires some cleverness.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变位词。** 设计一个 O(N log N) 算法来读取一个单词列表，并打印出所有的变位词。例如，字符串 "comedian" 和 "demoniac"
    是彼此的变位词。假设有 N 个单词，每个单词最多包含 20 个字母。设计一个 O(N^2) 的算法应该不难，但将其降至 O(N log N) 需要一些巧妙的方法。'
- en: '**Search in a sorted, rotated array.** Given a sorted array of n distinct integers
    that has been rotated an unknown number of positions, e.g., 15 36 1 7 12 13 14,
    write a program [RotatedSortedArray.java](RotatedSortedArray.java.html) to determine
    if a given integer is in the list. The order of growth of the running time of
    your algorithm should be log n.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在排序、旋转数组中搜索。** 给定一个包含 n 个不同整数的排序数组，该数组已经旋转了未知数量的位置，例如，15 36 1 7 12 13 14，请编写一个程序
    [RotatedSortedArray.java](RotatedSortedArray.java.html) 来确定给定的整数是否在列表中。你的算法的运行时间增长应为对数级别。'
- en: '**Find the jump in the array.** Given an array of n integers of the form 1,
    2, 3, ..., k-1, k+j, k+j+1, ..., n+j, where 1 <= k <= n and j > 0, design a logarithmic
    time algorithm to find the integer k. That is, the array contains the integers
    1 through n, except that at some point, all remaining values are increased by
    j.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找到数组中的跳跃。** 给定一个由 n 个整数组成的数组，形式为 1, 2, 3, ..., k-1, k+j, k+j+1, ..., n+j，其中
    1 <= k <= n 且 j > 0，请设计一个对数时间算法来找到整数 k。也就是说，数组包含整数 1 到 n，只是在某个点上，所有剩余值都增加了 j。'
- en: '**Find the missing integer.** An array `a[]` contains all of the integers from
    0 to N, except 1\. However, you cannot access an element with a single operation.
    Instead, you can call `get(i, k)` which returns the kth bit of `a[i]` or you can
    call `swap(i, j)` which swaps the ith and jth elements of `a[]`. Design an O(N)
    algorithm to find the missing integer. For simplicity, assume N is a power of
    2.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找到缺失的整数。** 一个数组 `a[]` 包含从 0 到 N 的所有整数，除了 1。但是，你不能通过单个操作访问一个元素。相反，你可以调用 `get(i,
    k)`，它返回 `a[i]` 的第 k 位，或者你可以调用 `swap(i, j)`，它交换 `a[]` 的第 i 和第 j 个元素。设计一个 O(N) 算法来找到缺失的整数。为简单起见，假设
    N 是 2 的幂。'
- en: '**Longest row of 0s.** Given an N-by-N matrix of 0s and 1s such that in each
    row no 0 comes before a 1, find the row with the most 0s in O(N) time.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长的 0 行。** 给定一个由 0 和 1 组成的 N×N 矩阵，使得在每行中 0 不会出现在 1 之前，找到具有最多 0 的行，并在 O(N)
    时间内完成。'
- en: '**Monotone 2d array.** Give an n-by-n array of elements such that each row
    is in ascending order and each column is in ascending order, devise an O(n) algorithm
    to determine if a given element x in the array. You may assume all elements in
    the n-by-n array are distinct.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单调二维数组。** 给定一个n×n的元素数组，使得每行按升序排列，每列也按升序排列，设计一个O(n)的算法来确定数组中是否存在给定元素x。你可以假设n×n数组中的所有元素都是不同的。'
- en: 'You are in the middle of a road, but there is a duststorm obscuring your view
    and orientation. There is a shelter in only one direction, but you cannot see
    anything until you are right in front of it. Devise an algorithm that is guaranteed
    to find the shelter. Your goal is to minimize the amount you have to walk. *Hint*:
    some kind of doubling back-and-forth strategy.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你站在一条路中间，但有一场尘暴遮挡了你的视线和方向。只有一个方向有庇护所，但直到你站在它面前才能看到任何东西。设计一个能够找到庇护所的算法，保证能找到。你的目标是尽量减少步行的距离。*提示*：某种来回走动的策略。
- en: Improve the following code fragment by as big a constant factor as you can for
    large n. Profile it to determine where is the bottleneck. Assume `b[]` in an integer
    array of length `n`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过尽可能大的常数因子改进以下代码片段，以适应大规模n。通过性能分析确定瓶颈在哪里。假设`b[]`是一个长度为`n`的整数数组。
- en: '[PRE3]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**In-place permutation.** Write a program `Permutation.java` that includes
    functions that take an array and a permutation (or inverse permutation) and rearranges
    the elements in the array according to the permutation (or inverse permutation).
    Do it *in-place*: use only a constant amount of extra memory.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原地置换。** 编写一个程序`Permutation.java`，其中包含接受数组和置换（或逆置换）的函数，并根据置换（或逆置换）重新排列数组中的元素。*原地操作*：只使用恒定量的额外内存。'
- en: '**Sum of three.** Given three sets A, B, and C of at most N integers each,
    determine whether there exists a triple a in A, b in B, and c in C such that a
    + b + c = 0.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三数之和。** 给定三个集合A、B和C，每个集合最多包含N个整数，确定是否存在三元组a在A中，b在B中，c在C中，使得a + b + c = 0。'
- en: '*Answer*: Sort B in increasing order; sort C in decreasing order; for each
    a in A, scan B and C for a pair that sums to -a (when the sum is too small, advance
    in B, when the sum is too large, advance in C).'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：按升序对B进行排序；按降序对C进行排序；对于A中的每��a，扫描B和C，找到一个对，使得它们的和为-a（当和太小时，在B中前进，当和太大时，在C中前进）。'
- en: '**SumOfTwo.** Given two sets A and B of at most N integers each, determine
    whether the sum of any two distinct integers in A equals an integer in B.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两数之和。** 给定两个集合A和B，每个集合最多包含N个整数，确定A中任意两个不同整数的和是否等于B中的一个整数。'
- en: '**Contiguous sum.** Given a list of real numbers and a target value V, find
    a contiguous block (of any length) whose sum is as close to V as possible.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连续和。** 给定一组实数和目标值V，找到一个连续块（任意长度），其和尽可能接近V。'
- en: '*Brute force*: compute the sum of each contiguous block by brute force. This
    takes O(N^3) time.'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*暴力法*：通过暴力法计算每个连续块的总和。这需要O(N^3)的时间。'
- en: '*Partial sums*: compute all partial sums s[i] = a[0] + a[1] + ... + a[i] so
    that contiguous blocks have a sum of the form s[j] - s[i]. This takes O(N^2) time.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分和*：计算所有部分和s[i] = a[0] + a[1] + ... + a[i]，以便连续块的和形式为s[j] - s[i]。这需要O(N^2)的时间。'
- en: '*Sort and binary search*: form the partial sums as above and then sort them
    in ascending order. For each i, binary search for the s[j] that is as close to
    s[i] as possible. This takes O(N log N) time.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*排序和二分查找*：按上述方式形成部分和，然后按升序对它们进行排序。对于每个i，二分查找尽可能接近s[i]的s[j]。这需要O(N log N)的时间。'
- en: '**Linear equation with 3 variables.** For some fixed linear equation in 3 variables
    (say with integer coefficients), given N numbers, do any 3 of them satisfy the
    equation? Design a quadratic algorithm for the problem. *Hint*: see quadratic
    algorithm for 3-sum.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三变量的线性方程。** 对于三个变量的固定线性方程（例如整数系数），给定N个数字，其中任意三个是否满足方程？为该问题设计一个二次算法。*提示*：参见三数之和的二次算法。'
- en: '**Convolution 3-sum.** Given N real numbers, determine whether there exists
    indices i and j such that a[i] + a[j] = a[i+j]. Design a quadratic algorithm for
    the problem. *Hint*: see quadratic algorithm for 3-sum.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**卷积三数之和。** 给定N个实数，确定是否存在索引i和j，使得a[i] + a[j] = a[i+j]。为该问题设计一个二次算法。*提示*：参见三数之和的二次算法。'
- en: '**Find a majority item.** Given a arbitrarily long sequence of items from standard
    input such that one item appears a strict majority of the time, identify the majority
    item. Use only a constant amount of memory.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找到主要项。** 给定一个从标准输入中任意长的项序列，其中一个项出现的次数严格占多数，识别主要项。只使用恒定量的内存。'
- en: '*Solution.* Maintain one integer counter and one variable to store the current
    champion item. Read in the next item and (i) if the item equals the champion item,
    increment the counter by one. (ii) else decrement the counter by one and if the
    counter reaches 0 replace the champion value with the current item. Upon termination,
    the champion value will be the majority item.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 维护一个整数计数器和一个变量来存储当前的冠军项。读取下一个项，如果该项等于冠军项，则将计数器加一。(ii) 否则将计数器减一，如果计数器达到0，则用当前项替换冠军值。终止时，冠军值将是主要项。'
- en: '**Memory of arrays.** [MemoryOfArrays.java](MemoryOfArrays.java.html). Relies
    on [LinearRegression.java](LinearRegression.java.html).'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数组的记忆。** [MemoryOfArrays.java](MemoryOfArrays.java.html)。依赖于[LinearRegression.java](LinearRegression.java.html)。'
- en: '**Memory of strings and substrings.** [MemoryOfStrings.java](MemoryOfStrings.java.html).
    Relies on [LinearRegression.java](LinearRegression.java.html) and [PolynomialRegression.java](PolynomialRegression.java.html).
    Depends on whether you are using Java 6 or Java 7.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符串和子字符串的记忆。** [MemoryOfStrings.java](MemoryOfStrings.java.html)。依赖于[LinearRegression.java](LinearRegression.java.html)和[PolynomialRegression.java](PolynomialRegression.java.html)。取决于你使用的是Java
    6还是Java 7。'
- en: '**Memory of a stack and queue.** What is the memory usage of a stack of N items
    as a function of N?'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**栈和队列的记忆。** 作为N个项的栈的内存使用量是N的函数吗？'
- en: '*Solution.* 32 + 40N (not including memory for referenced objects). [MemoryOfStacks.java](../13stacks/MemoryOfStacks.java.html).'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 32 + 40N（不包括引用对象的内存）。[MemoryOfStacks.java](../13stacks/MemoryOfStacks.java.html)。'
- en: '**Analysis of Euclid''s algorithm.** Prove that Euclid''s algorithm takes at
    most time proportional to *N*, where *N* is the number of bits in the larger input.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欧几里得算法的分析。** 证明欧几里得算法的时间复杂度最多与*N*成正比，其中*N*是较大输入中的位数。'
- en: '*Answer*: First we assume that p > q. If not, then the first recursive call
    effectively swaps p and q. Now, we argue that p decreases by a factor of 2 after
    at most 2 recursive calls. To see this, there are two cases to consider. If q
    ≤ p / 2, then the next recursive call will have p'' = q ≤ p / 2 so p decreases
    by at least a factor of 2 after only one recursive call. Otherwise, if p / 2 <
    q < p, then q'' = p % q = p - q < p / 2 so p'''' = q'' < p / 2 and p will decrease
    by a factor of 2 or more after two iterations. Thus if p has N bits, then after
    at most 2N recursive calls, Euclid''s algorithm will reach the base case. Therefore,
    the total number of steps is proportional to N.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：首先我们假设p > q。如果不是，则第一个递归调用实际上会交换p和q。现在，我们要证明在至多2次递归调用后，p会减少一半。为了证明这一点，有两种情况需要考虑。如果q
    ≤ p / 2，则下一个递归调用将有p'' = q ≤ p / 2，因此在仅一次递归调用后，p至少减少了一半。否则，如果p / 2 < q < p，则q''
    = p % q = p - q < p / 2，因此p'''' = q'' < p / 2，经过两次迭代后，p将减少一半或更多。因此，如果p有N位，则在至多2N次递归调用后，欧几里得算法将达到基本情况。因此，总步数与N成正比。'
- en: '**Find the duplicate.** Given a sorted array of N+2 integers between 0 and
    N with exactly one duplicate, design a logarithmic time algorithm to find the
    duplicate.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找重复项。** 给定一个包含0到N之间的N+2个整数的排序数组，其中恰好有一个重复项，设计一个对数时间复杂度的算法来找到重复项。'
- en: '*Hint* binary search.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示* 二分查找。'
- en: Given an array `a[]` of n real numbers, design a linear-time algorithm to find
    the maximum value of `a[j] - a[i]` where `j` ≥ `i`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个包含n个实数的数组`a[]`，设计一个线性时间算法来找到`a[j] - a[i]`的最大值，其中`j` ≥ `i`。
- en: '*Solution*:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE4]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Given an array `a[]` of n real numbers, design a linear-time algorithm to find
    the maximum value of `|a[j] - a[i]| + |j - i|`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个包含n个实数的数组`a[]`，设计一个线性时间算法来找到`|a[j] - a[i]| + |j - i|`的最大值。
- en: '*Hint*: create two arrays b[] and c[] of length n, with b[i] = a[i] - i and
    c[i] = a[i] + i.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：创建两个长度为n的数组b[]和c[]，其中b[i] = a[i] - i，c[i] = a[i] + i。'
