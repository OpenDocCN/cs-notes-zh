- en: P4：Lecture 4： Fork (Con't), Introduction to  I O (Everything is a File!) - RubatoTheEmber
    - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P4：讲座 4：`fork`（续），I/O 介绍（万物皆文件！） - RubatoTheEmber - BV1L541117gr
- en: Okay， welcome back everybody to 162。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎大家回到 162 课。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_1.png)'
- en: We're going to pick up where we left off last time briefly and finish our discussion
    of。 fork and then move on。 And so if you remember last time we were talking about
    how to create new processes。 And basically the mechanism that we talked about
    was fork。 This is going to be one of several mechanisms for getting parallelism
    and concurrency that we're going to discuss over this term。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上次的内容继续，简要地完成对 `fork` 的讨论，然后继续。所以上次如果你记得，我们在谈论如何创建新进程。基本上我们讨论的机制是 `fork`。这将是我们本学期讨论的几个并行性和并发性机制之一。
- en: And if you remember fork was a call that was function call that was a little
    weird relative to anything else you've ever seen before。 So what fork does is
    it you call fork in one process and it returns in two different ones。 Okay。 so
    you have a parent process you call fork。 It creates a child process。 which is
    identical to the parent one and then both of them return from the fork system
    call。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，`fork` 是一个调用，相比于你之前见过的任何其他调用，它有点奇怪。所以 `fork` 做的是，在一个进程中调用 `fork`，然后它会在两个不同的进程中返回。好的。所以你有一个父进程，你调用
    `fork`。它会创建一个与父进程完全相同的子进程，然后它们都从 `fork` 系统调用返回。
- en: And if you notice， one of them will return something bigger than zero and the
    other will return something equal to zero。 If it's bigger than zero， that's going
    to be the original parent process。 And the number you get back is the process
    ID for the child。 If you get zero then the process knows that it was the child
    process that it's in and it can call get PID and get parent PID and all of those
    to find out kind of what's parent is and what。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，返回的其中一个值会大于零，另一个会等于零。如果大于零，那么这个值将是原始的父进程。你得到的数字是子进程的进程 ID。如果返回零，那么进程就知道它是子进程，并可以调用
    `get PID` 和 `get parent PID` 等来找到父进程的 ID。
- en: it's ideas。 Only if you get something less than zero then you know that the
    fork process failed and you're still running in the parent and the number that
    you get back tells you something about an error code。 Okay， and the key thing
    about fork is that the state of the original process ends up duplicated in both
    the parent and the child。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个概念。只有当你得到一个小于零的值时，你才知道 `fork` 过程失败了，并且你仍然在父进程中运行，返回的数字告诉你某种错误代码。好的，关于 `fork`
    的关键是，原始进程的状态最终会在父进程和子进程中都被复制。
- en: So if there are gigabytes of memory。 In one case in the parent when you fork
    the child will have gigabytes of memory。 Okay， and that may seem kind of excessive
    except that what's going to happen is we're going to show you how that's actually
    not too expensive because really we're not going to copy all of the memory we're
    just going to copy the page tables and in the parent and the child so that we
    can sort of。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果有数 GB 的内存。在父进程中，当你调用 `fork` 时，子进程将会有数 GB 的内存。好的，这看起来可能有点过于庞大，除非你明白实际发生的事情是，我们不会复制所有的内存，我们只是复制了父进程和子进程的页表，这样我们就能做到。
- en: duplicate the memory without actually having to duplicate anything。 That'll
    make for another discussion。 So， so remember two processes are there after fork
    and both of them return from fork。 And so what I'm showing you here is what happens
    right after we call fork。 the value that comes back is an integer。 Okay， it's
    a PID T actually but it's that's really an integer and both the child and the
    parent process start from that same spot。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 复制内存时并不需要实际复制任何内容。这个问题将会是另一个讨论的话题。所以，记住，在 `fork` 之后有两个进程存在，并且它们都会从 `fork` 返回。所以我在这里展示的是我们调用
    `fork` 后发生的事情。返回的值是一个整数。好的，实际上是一个 PID T，但它本质上是一个整数，父进程和子进程都从同一个地方开始。
- en: If， and then they start running。 And what you'll see is that the parent will
    notice that CP IDs greater than zero start running in this point。 The child will
    notice that CP ID is equal to zero start running in this point。 And at that from
    that point on then that the executions of the two processes diverge。 And you can
    do something completely different in the parent than from the child。 Okay。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，然后它们开始运行。你会看到，父进程会注意到进程 ID 大于零的进程从这个点开始运行。子进程会注意到进程 ID 等于零的进程从这个点开始运行。从那时起，两个进程的执行将会分岔。父进程和子进程可以做完全不同的事情。好的。
- en: now the question in this chat there does this， you know， the parent and the
    child share the memory。 So the answer is yes and no。 And so I don't want to get
    too much in the subtleties you should think of this as if they get complete copies。
    The way this is really going to work is we're going to set everything read only。
    And the moment one of them tries to write then we'll copy and so it'll still look
    exactly like they have their own separate copies。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个聊天中的问题是，父进程和子进程共享内存吗？答案是既是又不是。所以我不想过多讲解其中的细节，你应该将其视为它们各自获得了完整的副本。实际上，它将会是，我们将所有内容设置为只读，只有当其中一个进程尝试写入时，才会复制内存，这样它们看起来就像是有各自的独立副本。
- en: but it's a lot cheaper than copying all the memory。 Okay。 we'll talk more about
    that in a couple of lectures。 So。 I want to see if there are any questions on
    this basic idea here。 and then we're going to go a little forward on it。 Okay。
    to one process calls for two of them returned from four。 All right， now。 here's
    a good challenge for you guys。 So here is a program。 Notice what it does is it
    has an integer that's declared that's a global variable。 It calls for the parent
    will run in one arm of the L of the F the child or run in the other and I'm ignoring
    errors here for a moment。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它比复制所有内存要便宜得多。好的，我们将在接下来的几节课中进一步讨论这个问题。那么，我想知道大家是否对这个基本概念有任何问题？如果没有，我们将继续往下讲。好的，假设有一个进程调用了两个子进程返回四。好了，现在，给大家一个很好的挑战。这里有一个程序。注意它的功能，它声明了一个整数作为全局变量。它调用时，父进程会在`L`的一个分支中运行，子进程会在另一个分支中运行，我暂时忽略错误处理。
- en: Question is， what do we see on the screen if this runs because it looks like
    I the two eyes uses of I are kind of interfering with each other when I'm going
    up one of them's going down the two processes are running at same time potentially
    what happens。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，如果这个程序运行时，我们在屏幕上看到的是什么？因为看起来`I`的两个使用是相互干扰的，一个在递增，另一个在递减，两个进程同时运行，会发生什么？
- en: Very good。 So somebody said in chat wait， isn't it the fact the processes are
    protected from each other。 Yes。 Good answer。 So if you notice， yes， the parent
    had a global variable I。 And when we duplicate they both have a global variable
    I but it's a different global variable because it's a completely different address
    space。 So in fact， these two processes will do their loops perfectly happily with
    I going up and one and down in the other。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好。所以有人在聊天中问，等等，进程不应该是彼此隔离的吗？是的，回答得很好。你可以注意到，父进程有一个全局变量`I`，当我们复制它时，两个进程都拥有一个全局变量`I`，但是它们是不同的全局变量，因为它们位于完全不同的地址空间。所以，实际上，这两个进程会完美地进行它们的循环，一个进程让`I`递增，另一个进程让`I`递减。
- en: The thing that we'll see that's going to be a little non deterministic is since
    they're both printing to the same standard out and we'll get to that later in
    the lecture。 then you'll see some interleaving from the two of them but there
    won't be any confusion about I。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到的一个非确定性因素是，它们都在打印到相同的标准输出，因此稍后我们将在讲座中讨论这个问题。你会看到两个进程的输出会交替出现，但不会产生混淆。
- en: Okay。 So， so basically I is is literally the execution graph is forking into
    two completely unrelated things。 Yes。 That was to we talked about exit last time
    that was for。 I want to give you a couple more sort of process management pieces
    here before we before we move on to the next topic。 So what I've shown you so
    far gives you new processes but they're kind of duplicates of the each other and
    that hasn't seen too useful yet if you want to make a bunch of new processes。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，基本上，我所说的“`I`”就是执行图的分支，它分裂成两个完全不相关的部分。是的，关于我们上次讨论的`exit`，它是分支的一个例子。接下来，我想给大家讲一些更多关于进程管理的内容，然后再进入下一个话题。到目前为止，我展示的给你们的是新的进程，但它们基本上是彼此的复制品，这在你需要创建大量新进程时可能并不太有用。
- en: Okay。 To do that we're going to have the exact system call and wait is going
    to help parents understand about children finishing execution。 So let's look at
    the exact first。 So the exact system call and there's a bunch of different variants
    of that so I'm going to call them exact generically。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。为了做到这一点，我们将使用精确的系统调用，而`wait`将帮助父进程了解子进程何时完成执行。我们先来看一下精确的部分。精确的系统调用有很多不同的变体，所以我将把它们通称为精确调用。
- en: You can do a man on exec to find out all the different versions。 but what's
    going to happen here is if you notice we start off with fork。 When we're in the
    parent。 all we're going to do is we're going to execute weight which is going
    to just wait until the child exits and I'll say more about that in the next slide。
    And the child is going to do something interesting it's going to make an array
    of of character strings and notice this is LS dash L and then a no。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`man exec`来查看所有不同的版本。但这里会发生的事情是，如果你注意到，我们从`fork`开始。当我们在父进程中时，我们要做的就是执行`wait`，它会一直等待直到子进程退出，我会在下一张幻灯片中详细讲解。子进程将做一些有趣的事情，它将创建一个包含字符串的数组，并且注意到这是`ls
    -l`，然后是一个数字。
- en: So it's an array with two strings and a no。 And the exact V system call is going
    to have its first argument slash bin slash LS and the second argument is going
    to be this array of arguments。 Okay， and what's interesting about this is we for
    to create two processes the parent just spin weights。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个包含两个字符串和一个数字的数组。准确的V系统调用将会把第一个参数设置为`/bin/ls`，第二个参数将是这个参数数组。好，令人感兴趣的是，父进程创建了两个进程，父进程只是等待。
- en: It's actually just waiting for a moment。 The child doesn't exec。 And what that
    does is it looks this program up on the file system and it replaces everything
    that was in the process with the contents of the new program and it starts at
    running。 Okay， so assuming there are no errors。 What we just did here is we forked
    off a new process。 a child process。 We started it running the LS program。 And
    the parent is waiting。 Okay。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上只是在等待一段时间。子进程没有执行`exec`。而这会在文件系统中查找这个程序，并用新程序的内容替换进程中的一切，然后开始运行。好，假设没有错误。我们刚刚做的是创建了一个新进程，一个子进程，开始运行`LS`程序，父进程则在等待。好。
- en: and so now you can start to see how like your shell might work。 where the shell
    has its parent which has the little prompt that puts down there and processes
    what you type。 And all of the things you spawn off to run get put in their own
    process as child processes。 Okay。 and so what exec does is assuming there's no
    failure。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你可以开始看到你的shell是如何工作的。shell有一个父进程，显示提示符并处理你输入的内容。你启动的所有程序都会作为子进程放入它们自己的进程中。好。所以`exec`做的事情是，假设没有失败的情况下。
- en: Exact will throw out all the memory that's in an existing process and it'll
    start a new program running in that process。 So the process sticks around the
    contents of the address space of that process changes。 And the only reason that
    you would ever return from exec is if there was an error。 Okay。 And then what
    about this weight system call so there are lots of versions of weight you can
    look that up。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`会丢弃现有进程中的所有内存内容，并开始在该进程中运行一个新程序。所以，进程仍然存在，但是该进程的地址空间内容发生了变化。而你只有在出现错误时才会从`exec`返回。好，那么`wait`系统调用是怎么回事呢？其实有很多版本的`wait`，你可以查找更多信息。'
- en: The simplest one that I told you about here is trying to address an interesting
    problem you can imagine。 So if the parent starts a child process and the child
    process ends。 the parent wants to know what was the success of that process。 Was
    there a successful return was there an error， etc。 And so weight basically lets
    us do that。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提到的最简单的例子是试图解决一个有趣的问题，你可以想象一下。假设父进程启动了一个子进程，子进程结束了。父进程希望知道该进程的执行结果。是成功返回，还是出现错误，等等。所以，`wait`系统调用基本上就是让我们做到这一点。
- en: And so if you notice down here the child is basically executing something。 And
    then it doesn't exit 42 which since that's not zero is technically an error。 The
    parent does a weight and it gives the address of an integer variable for a return
    value。 And this weight system call will wait until the child exits at which point
    this exit will get the exit code will get put into the variable that we've put
    forward。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你注意到这里，子进程基本上在执行某些内容。然后它没有退出42，因为42不是零，技术上来说这是一个错误。父进程调用`wait`并传递一个整数变量的地址来获取返回值。这个`wait`系统调用将等待直到子进程退出，此时退出代码将被放入我们提供的变量中。
- en: And the weight system call will return and we can see what the return value
    was from the child。 Okay。 Yeah， and so the， and the question about back here whoops
    is that yes the ARGS are basically just like the arguments to LS。 And that's essentially
    how the arguments to LS get put in there。 Okay。 Now。 so again this weight system
    call waits for the child to exit gets its value and then moves forward。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`wait`系统调用将返回，我们可以查看子进程的返回值是什么。好的，嗯，关于这里的问题，哎呀，ARGS基本上就像是LS命令的参数。那就是LS命令的参数是如何被放入的。好了。接下来，`wait`系统调用会等待子进程退出，获取其返回值，然后继续执行。
- en: Okay。 And so the reason you can think that this needs to be more complicated。
    And so the reason why it's not clear is because if a child exits a long time before
    the parents ready to execute weight。 clearly that process has to sit around with
    its return code， even though it's done。 so that the parent can eventually get
    the weight status。 Okay。 And so if that's the case。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以你可以理解，为什么这需要更加复杂的操作。之所以不清楚，是因为如果一个子进程在父进程准备执行`wait`之前就已经退出了，显然这个进程必须保留其返回代码，尽管它已经完成，以便父进程最终可以获得退出状态。好的，如果是这样的话。
- en: then that process that was a child， but doesn't have a isn't running anymore
    is what's called a zombie process and it'll sit around until somebody executes
    weight。 Now there's a good question about what happens if you have multiple children
    that are spawned off this weight system call this version will wait for the next
    one to exit。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，那个曾经是子进程，但现在不再运行的进程就被称为僵尸进程，它会一直存在，直到某个进程执行了`wait`系统调用。现在有一个很好的问题，如果你有多个子进程从这个`wait`系统调用派生出来，这个版本将会等待下一个子进程退出。
- en: There's a bunch of other ones where you can even say wait for this particular
    process ID to exit。 etc。 So there's much more sophisticated ones that you can
    do。 The other question here is does the exec the process here have access to all
    the parents memory。 And the answer is no。 So what happens is there's a child's
    memory。 Okay。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他的调用，你甚至可以指定等待某个特定进程ID退出，等等。所以你可以做更复杂的操作。另一个问题是，这个`exec`进程是否可以访问父进程的所有内存。答案是否定的。发生的情况是，子进程会有自己的内存。好的。
- en: which is a copy but separate from the parents and exec will essentially overwrite
    everything with the new execution image。 Okay。 And so here's a， here's a typical
    what I call the shell pattern。 So this is what you typically see in your shell。
    After you've typed your command。 we fork off a new process。 The child goes off
    and exec executes that process with an exec。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是父进程的一个副本，但与父进程是分开的，`exec`将会用新的执行镜像覆盖一切。好的。所以这里是我称之为shell模式的典型示例。这是你在shell中通常看到的情况。在你输入命令之后，我们会派生出一个新进程。子进程去执行`exec`命令，运行那个进程。
- en: The parent does a wait and waits for it to finish。 Okay。 And that's what you
    typically see when you type a command on the shell you hit return something happens
    and then it gives you back to the shell。 That would be this。 Now， in a different
    pattern where you want to start a child and then go on。 let it run and go on to
    do something else in the shell。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程执行`wait`并等待子进程完成。好的，这就是你通常在命令行中输入命令后所看到的现象。你按下回车键后，某些事情发生，然后它把控制权交还给命令行。那就是这个情况。现在，在另外一种模式下，你希望启动一个子进程，然后继续执行，允许它运行，并继续在命令行中做其他事情。
- en: That's going to be a case where we don't do wait， but we just move on。 Okay。
    So the question is。 where is the status variable coming from if you look in this
    particular code。 notice it's the exit code。 So when the child exits with exit
    42。 that is the status code that gets returned into the status variable。 Okay。
    All right。 And then last。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个我们不执行`wait`，而是直接继续执行的情况。好的。那么问题是，如果你查看这个特定代码，状态变量是从哪里来的。注意，它是退出代码。所以当子进程以退出代码42退出时，这就是返回到状态变量的状态码。好的，明白了。然后，最后。
- en: I want to talk about。 So we were talking about starting， stopping， managing
    processes。 The last thing， that's from the standpoint kind of of a parent。 The
    system needs to be able to control processes that are already running。 And so
    that's basically the so called kill。 Action。 Okay。 And basically。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我想谈一谈。我们之前谈到了启动、停止和管理进程。从父进程的角度来看，系统需要能够控制那些已经在运行的进程。所以基本上就是所谓的`kill`操作。好的，基本上。
- en: I'm going to show you an example here。 So typically， if you hit like control
    C。 That's actually going to send a signal that's going to be an interrupt signal
    to the process that's running。 And you want to， we have a more general idea here
    where we can send signals to any process。 And it's kind of like a user level version
    of an interrupt。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里给你展示一个例子。通常情况下，如果你按下Ctrl+C，实际上会发送一个信号，这是一个中断信号，发送到正在运行的进程。你想要的，我们这里有一个更通用的想法，我们可以向任何进程发送信号。这有点像中断的用户级版本。
- en: And you're going to actually get to play with this in your projects。 But I want
    to just show you a particularly simple example of what you can do。 So when you
    hit control C， the default thing is that the system will catch that control C
    and throw it off and kill it。 Okay。 However， if you want to do something different，
    you can do this。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在你的项目中实际操作这个。但我只想展示一个特别简单的例子，展示你可以做什么。所以当你按下Ctrl+C时，默认情况下，系统会捕获这个Ctrl+C并终止它。好的，然而，如果你想做一些不同的事情，你可以这样做。
- en: So notice that the main procedure actually sets up a SIG action， which you can
    look at this code。 I don't want to go in great detail right now。 But the SIG，
    SIG action has a handler。 which is a program， which is a function that you've
    actually registered already。 So here's the signal callback handler that you've
    put in your code。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以注意，主要的过程实际上是设置了一个SIG动作，你可以查看这段代码。我现在不想详细讲解。但是SIG，SIG动作有一个处理器，它是一个程序，是你已经注册的一个函数。所以这是你在代码中放入的信号回调处理器。
- en: you register that as a handler to be called on SIG it。 And so when you hit control
    C。 it'll now call this instead of the default systems version。 And in this case。
    it'll say caught signal and then die。 But you could have it say caught signal
    ignoring and return immediately。 And that means the control C wouldn't do anything
    except keep saying caught signal。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你把它注册为在收到SIG时调用的处理器。所以当你按下Ctrl+C时，它将调用这个，而不是系统的默认版本。在这种情况下，它会显示“捕获到信号”，然后退出。但你也可以让它显示“捕获到信号，忽略”，并立即返回。这样Ctrl+C就不会做任何事，只会一直显示“捕获到信号”。
- en: So there's lots of flexibility there with signals。 Okay。 All right。 And then
    there's a bunch of different signals that SIG and SIG into control C。 There's
    a SIG term。 which is the kill shell command。 And then there's like SIG kill and
    SIG stop。 which are uncatcheable signals。 SIG kill is what you get with kill minus
    15 for kill minus nine。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在信号方面有很多灵活性。好的，然后有很多不同的信号，像SIG和SIG interrupt控制C。还有SIG term，这是kill shell命令。然后还有SIG
    kill和SIG stop，这是无法捕获的信号。SIG kill是通过kill -15或者kill -9得到的。
- en: You get these extreme signals that are not catchable。 Okay。 So I guess I'm not
    entirely understanding the question here why just the status variable。 This is
    a code and the selected variable so status in this case。 So status。 the word status
    here is just because I said status notice that my city and status this could be
    a variable of any name。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到这些无法捕获的极端信号。好的。所以我想我还不完全理解这个问题，为什么仅仅是状态变量？这是一个代码和选定的变量，所以在这个例子中是状态。所以状态，这里的状态一词只是因为我说了状态，注意到我的城市和状态，这可以是任何名称的变量。
- en: So this could be weight。 Fred， if you wanted， I don't know if that answers your
    question。 whatever you， whatever you feel like calling that variable in the parent
    you can do it。 Okay。 All right， so moving on now if you remember last time and
    the time before actually we showed you this figure。 which kind of gave you an
    idea of the difference between user mode and kernel mode。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这可能是wait。Fred，如果你愿意，我不知道这是否回答了你的问题。无论你，如何命名父进程中的那个变量都可以。好的，接下来，如果你记得上次以及上上次，我们给你展示了这个图，它大致展示了用户模式和内核模式之间的区别。
- en: So the kernel mode is the set of high priority things that are inside the kernel
    and they have direct access to the hardware and they have to be perfect。 Okay。
    The user mode are the things that are written by users and other people and may
    have bugs in them and typically what the kernel is doing is it's providing the
    process of traction and making sure that the protections of the file system。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以内核模式是内核中一组高优先级的东西，它们可以直接访问硬件，必须是完美的。好的，用户模式是用户和其他人编写的东西，可能存在缺陷，通常内核的工作是提供进程抽象，并确保文件系统的保护。
- en: and all of those other things are maintained by the operating system。 All of
    that's inside the kernel。 The user mode is the thing that is running most of your
    programs。 but is running inside a process address space and protected from all
    the other ones and all the other ones are protected from it。 Okay。 So， the， the
    difference between the kernel and the shell is a question the shell is just a
    program running in user mode that you're running on your own。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他的东西都由操作系统维护。所有这些都在内核里面。用户模式是运行大多数程序的地方，但它运行在一个进程地址空间内，并且与其他进程隔离，其他进程也被保护不受它的影响。好吧。所以，内核和shell之间的区别是，shell只是一个运行在用户模式下的程序，你是在自己的系统上运行它。
- en: but it's asking the kernel to start up new process。 So the kernel is this core
    bit of the operating system that handles the file system and the scheduling and
    all of that sort of stuff and is essentially always there。 Okay， the shell is
    just a user mode program like every other one it's just it's been set up to process
    your commands and use those to launch programs running。 Okay， and again if there
    with respect to wait if there's multiple children then wait we'll just wait for
    the next one to exit。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但它请求内核启动一个新的进程。所以内核是操作系统的核心部分，处理文件系统、调度以及所有相关事务，并且基本上始终存在。好吧，shell只是一个像其他程序一样的用户模式程序，只不过它被设置用来处理你的命令，并利用这些命令启动程序的运行。好吧，再说一次，如果有多个子进程，那么wait会等待下一个进程退出。
- en: And then you can run it again and again。 Okay， so the other thing to note by
    the way is this there's two things shown in user mode here kind of the applications
    in the standard libraries。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以一遍又一遍地运行它。好吧，顺便说一下，另外需要注意的是，这里展示的用户模式中有两个东西，分别是应用程序和标准库。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_3.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_3.png)'
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_4.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_4.png)'
- en: So the standard libraries are a set of wrappers around the system call interface
    to make it somewhat easier to use and just the raw system call interface。 And
    so if you look here at this idea of kind of the narrow waste of the system call
    interface puts the library like a lib C is a good example of that on top of the
    system call interface。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以标准库是围绕系统调用接口的一个包装集，使得它比原始的系统调用接口稍微更易于使用。如果你看这里这种系统调用接口的狭窄空间，像lib C这样的库是将其放置在系统调用接口之上的一个很好的例子。
- en: and the things inside a lib C are somewhat easier to use。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在lib C中的内容相对来说更容易使用。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_6.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_6.png)'
- en: than just the raw system calls。 And so most people who are programming in see
    at least link with lib C and so they don't use system calls directly what they
    do is they use lib C which uses system calls。 Okay。 And so， for instance， I had
    this picture earlier and I just wanted to clarify so typically you have a library
    like a library。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接使用原始的系统调用。所以大多数用C语言编程的人至少会链接lib C，因此他们不会直接使用系统调用，而是使用lib C，lib C内部会使用系统调用。好吧。所以，举个例子，我之前展示了这张图片，我只是想澄清一下，通常你会有像lib
    C这样的库。
- en: and you can see that there's a library。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里有一个库。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_8.png)'
- en: And to clarify so typically you have a library like lib C that is linked into
    your application this is showing a bunch of different applications grew green
    yellow orange with the lib C and the lib C gives a nice clean easy interface up
    to the application。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，通常你会有像lib C这样的库，它被链接到你的应用程序中，这里展示的是一堆不同的应用程序，绿色、黄色、橙色与lib C一起使用，而lib C则为应用程序提供了一个简洁、易用的接口。
- en: And it calls the OS typically， and most of the library code runs inside of the
    user mode with occasional call outs to system calls inside the OS。 Yeah， as Anthony
    says about weight I know that's a great interest to a bunch of people but do man
    wait and you'll see there are lots of different versions of it。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常会调用操作系统，并且大部分库代码运行在用户模式中，偶尔会调用操作系统中的系统调用。是的，正如Anthony所说的关于wait，我知道这对许多人来说是一个重要话题，但使用man
    wait，你会看到它有很多不同的版本。
- en: Many that do， you know， non blocking things that let you say， well wait for
    this particular process。 etc。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多它所做的事情，你知道，是非阻塞的，可以让你说，等待这个特定的进程，等等。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_10.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_10.png)'
- en: Okay。 So， this idea here of wrapping things around the system call interface
    is a very standard thing because that system call interfaces extremely powerful
    because it's like a function call into the kernel and out。 but it's very stripped
    down it's kind of the bare minimum that you need。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，这里将事物封装在系统调用接口中的想法是非常标准的，因为系统调用接口非常强大，它就像是一个进入内核的函数调用，但是它非常精简，是你所需的最基本的部分。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_12.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_12.png)'
- en: Okay。 And we're going to today today we're going to talk a lot about going across
    that system call interface。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。今天我们将讨论很多关于如何跨越那个系统调用接口的内容。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_14.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_14.png)'
- en: And I'm going to give you some good examples of where lib C comes into play
    to provide a cleaner wrapper around the actual calls into the system call interface。
    Okay， and this should help set you up quite well for project number one。 And so
    the first idea for the day here is that everything is a file。 Okay。 and this is
    a very you Unix idea。 And it got adopted and standardized as posits and I'll say
    what posits is a moment but it's a standardization of a lot of Unix。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给你一些很好的例子，说明 lib C 如何发挥作用，为实际调用系统调用接口提供一个更干净的封装。好的，这应该能很好地帮助你为项目一做好准备。所以，今天的第一个想法是“一切皆文件”。好的，这是一个非常
    Unix 的想法。它被采纳并标准化为 POSIX，我稍后会说一下 POSIX 是什么，但它是 Unix 的大量标准化内容。
- en: And the idea behind this is it is an identical interface for files devices，
    regular files on disk。 networking， interprocess communication， all of those， everything
    looks like a file。 Okay。 And so a lot of this type of communication， things that
    go across that system call interface are based on system calls like open read
    right close。 which you're going to become very familiar with by the end of the
    term。 Okay。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个背后的想法是它是一个相同的接口，适用于文件、设备、磁盘上的常规文件、网络、进程间通信，所有这些，一切看起来都像是文件。好的。所以，这种类型的通信，跨越那个系统调用接口的东西，通常基于像
    `open`、`read`、`write`、`close` 这样的系统调用。到学期结束时，你将非常熟悉这些。好的。
- en: and there's an additional part of this interface which we haven't talked about
    yet， called I octals。 and the I octals are kind of or I could all I've heard people
    say。 although that's a little strange sounding to me。 But the I octal interface
    lets you do customize stuff to interfaces when you can't quite shoehorn everything
    into open read writer close。 And this typically an I octal interface that lets
    you do some additional configuration to those things and we'll talk about a few
    I octal calls over the term。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口还有一个我们还没有讨论的附加部分，叫做 I/O 控制（I octals）。I/O 控制，或者我听人们说的 I octal，虽然这对我来说听起来有点奇怪。但
    I/O 控制接口允许你在不能完全将所有内容都强行装入 `open`、`read`、`write`、`close` 时，对接口进行定制。通常，这是一个 I/O
    控制接口，它让你对这些东西进行一些额外的配置，稍后我们会在学期中讨论一些 I/O 控制的调用。
- en: but basically imagine that open read right and close are what you do for everything，
    almost。 And the idea that everything is a file was actually kind of radical when
    it was originally proposed。 and you can see this in the one of their early papers
    from 1974 from Richie and Thompson called the Unix time sharing system。 And I
    actually posted this on the resources page， if you're curious about it it's one
    of its actually the first paper we read in 262 a so you can get a little bit of
    of an interesting flavor for what a graduate computer systems it's like。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但基本上，想象一下 `open`、`read`、`write` 和 `close` 几乎是你对所有事物所做的事情。而“一切皆文件”的想法，实际上在最初提出时是有些激进的。你可以在
    Richie 和 Thompson 于 1974 年发表的早期论文《Unix 时间共享系统》中看到这一点。如果你感兴趣，我已经把这篇文章发布在资源页面上，它实际上是我们在
    262A 课程中阅读的第一篇论文，你可以从中感受到一些有趣的味道，了解一下研究生计算机系统的样子。
- en: And this idea of everything's a file was powerful enough that now we don't even
    think of it as radical。 and it even got adopted as a standardized interface so
    I wanted to say what POSIX is so POSIX is the so called portable operating system
    interface for Unix。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: “一切皆文件”的这个想法非常强大，以至于现在我们甚至不再认为它是激进的，它甚至被采纳为一个标准化接口。所以我想说一下什么是 POSIX，POSIX 是所谓的便携操作系统接口，用于
    Unix。
- en: It's an interface for application programmers， specifically it's a system called
    interface。 and it was created to kind of bring order to the fact that there were
    many different flavors of Unix spread all over the place and they all had slightly
    different system。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它是为应用程序开发人员提供的接口，特别是一个系统调用接口。它的创建旨在解决 Unix 的不同版本在全球范围内广泛存在且略有不同的问题。
- en: call interfaces。 And so what happened was they adopted a more standardized version
    called POSIX。 and some of the POSIX interfaces are even available in Windows。
    even though Windows is not a Unix operating system that still has POSIX interfaces。
    And so when I talk about Unix system calls and so on。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调用接口。因此，发生的事情是，他们采用了一个更标准化的版本，叫做POSIX。一些POSIX接口甚至在Windows中也能找到，尽管Windows不是一个Unix操作系统，但它仍然有POSIX接口。所以当我谈论Unix系统调用等内容时。
- en: mostly I'm talking about things that are standardized in POSIX and if I'm not，
    I will。 I will clarify。 So let's look at this ever present file system abstraction。
    So a file is a named collection of data in a file system， for instance。 So POSIX
    file data is a sequence of bytes could be text or binary or serialized objects
    it doesn't really matter。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我是在讲那些在POSIX中标准化的东西，如果不是，我会做出澄清。那么，让我们来看看这个始终存在的文件系统抽象。文件是文件系统中一个命名的数据集合。例如，POSIX文件数据是一个字节的序列，可以是文本、二进制或序列化对象，实际上并不重要。
- en: and the operating system doesn't care so the operating system doesn't have any
    interest in how you format your data it's just going to give you kind of a bag
    of。 bytes that are sequenced， and it's up to you to interpret them。 Okay。 and
    there's only one example of a file type that's actually processed directly by
    the Unix file system and that's directories are in a special format。 And we'll
    get to that later in the term but for now a file is a sequence of bytes。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统并不关心数据的格式，因此操作系统对你如何格式化数据并不感兴趣，它只会给你一个按顺序排列的字节包，接下来由你来解释它们。好了，唯一一个由Unix文件系统直接处理的文件类型就是目录，它们采用一种特殊格式。稍后我们会讨论这个问题，但现在可以理解为，文件是字节的序列。
- en: It doesn't matter what the bytes represent。 Okay， and then there's file metadata
    like size。 modification time， owner， security information， all of that stuff，
    which。 you'll you'll get a good flavor for as you start using this interface a
    lot more。 A directory is really just another special file containing pointers
    to files and other directories with names。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 字节表示的内容并不重要。好吧，然后还有文件的元数据，比如大小、修改时间、所有者、安全信息等等，这些内容在你开始更频繁地使用这个接口时会有更深刻的理解。目录实际上只是另一个特殊文件，包含指向文件和其他目录的指针，并且这些指针有名称。
- en: Okay。 And so each directory sort of provides a mapping between the file name
    and。 either a directory or a file that's represented there。 And if you trace your
    way from the root directory， which is the very top level。 through a set of directories
    to a file you're actually hopping your way through the。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，每个目录都提供了一个映射，映射文件名和其所代表的目录或文件。如果你从根目录（即最顶层）开始，沿着一系列目录追溯到一个文件，实际上你是在通过这些目录跳跃。
- en: route directory， which is a file to the next directory， which is a file to the
    next directory。 which is a file to the final file， which is not a directory。 That
    tracing of the path is something that we're going to talk a lot about when we
    get into file systems in several weeks。 Okay。 But you've all used this so you're
    familiar with this idea。 And inside of Unix。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录是一个指向下一个目录的文件，下一个目录又是一个文件，依此类推，直到最后一个文件，它不是一个目录。我们将在几周后深入讨论文件系统时详细探讨这种路径追踪。你们都已经使用过这种方式，所以对这个概念应该很熟悉。在Unix中。
- en: every process actually has its own current working directory。 which is kind
    of the directory path for files that are being used by that process。 So there's
    a system call change directory， that can you be used to set the current working
    directory。 And absolute paths， which are things that start with a slash kind of
    ignore the current working directory。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程实际上都有自己的当前工作目录，这是该进程正在使用的文件的目录路径。系统有一个调用接口叫做更改目录，可以用来设置当前的工作目录。而绝对路径是以斜杠开头的路径，它们不依赖于当前的工作目录。
- en: So this one is at root file system slash home slash osuki slash six。 CS 6162
    or relative paths are things with dots in them。 Okay。 or in some cases with tilde's
    those are relative to the current working directory。 So if you just say index，
    HTML， that's really current working directory slash index dot HTML。 Okay。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，像“/home/osuki/six/CS6162”这样的路径就是根文件系统下的路径，而相对路径是带有点（dot）符号的路径，或者在某些情况下带有波浪符（tilde），这些路径是相对于当前工作目录的。例如，如果你说“index.html”，实际上指的是当前工作目录下的“index.html”。
- en: Now， what about this interface to files and so what I want to do today is we're
    going to do a really quick tour of the levels of the stack for IO starting with
    the high level of streams。 which is buffered IO and that's in libc down through
    the low level， through the Cisco interface。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，文件的接口怎么样呢？今天我想做的是，我们将快速浏览 I/O 栈的各个层级，从流的高层开始，这就是缓冲 I/O，它在 libc 中，然后是低层，一直到
    Cisco 接口。
- en: We're not going to say a lot about file systems right now but we're also going
    to say a little bit about IO device drivers。 just so you can get a flavor of all
    these interesting pieces of the stack that we're going to cover as the term goes
    on。 So at the highest level。 Okay， we have what are called streams。 Okay。 and
    the C high level API operates on stream。 So stream is an as a sequence of bytes
    that isn't really formatted in any particular way。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会谈论很多关于文件系统的内容，但我们也会稍微提到一些 I/O 设备驱动程序，只是让你们了解这些栈中有趣的部分，我们将随着学期的进展逐步涵盖。好了，在最高层，我们有被称为流的东西。好的，C
    的高层 API 操作于流。因此，流是一个字节序列，并没有以特定的方式进行格式化。
- en: And it's got a position associated with it。 I've got this little arrow here。
    And there is an F open and F close routine。 These are a lot of these are in libc
    to open a file or close a file。 And notice that there's a special F in front of
    here F open F close。 So these aren't open and close。 So these are the F versions
    or the stream versions。 And so F open takes a file name。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个与之相关的位置。我在这里画了一个小箭头。这里有 F open 和 F close 例程。这些大多在 libc 中，用于打开文件或关闭文件。注意，这里有一个特殊的
    F 在前面，F open 和 F close。所以这些不是一般的 open 和 close，而是 F 版本，或者说是流版本。因此，F open 接受一个文件名。
- en: which could either be an absolute path， or something relative to current working
    directory。 And then some mode bits。 And it returns something called a file star
    which is a is a structure that you don't look into。 but is a stream that you can
    read and write from。 And then when you're done you F close you close by giving
    it back the file star。 Now remember what this means is there is some structure
    of a file capital file and it returns a pointer to that。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是一个绝对路径，也可以是相对于当前工作目录的路径。然后是一些模式位。它返回一个叫做 file star 的东西，它是一个你不需要深入了解的结构，但它是一个你可以读写的流。当你完成时，你使用
    F close 关闭它，返回 file star。那么记住，这意味着有一个文件结构，它返回一个指向该结构的指针。
- en: And then the definitions are for this standard I/O dot H include all the definitions
    you need for this。 Okay， now the question here about what's a stream I'm going
    to say more in a moment okay but it's really just like I said it's an。 unformatted
    sequence of bytes that are kind of streaming along and you're going to read them。
    Just read a whole sequence of bytes okay it's going to be a stream of bytes。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义是针对这个标准 I/O 点 H，包含你所需要的所有定义。好了，现在关于什么是流的问题，我稍后会进一步说明，但实际上就像我说的，它是一个未格式化的字节序列，就像在流动一样，你将读取它们。就是读取一个完整的字节序列，没错，它是一个字节流。
- en: And it's going to be like a river。 Okay， these mode bits are really something
    that you give it a string。 a pointer to a set of characters。 And there's a lot
    of mode possibilities here so if you give it an R。 it'll be read only if you give
    it a W it's right only if you give it an A you're opening it for a pending。 which
    is starting at the end， et cetera。 Now， now the question about are the permissions
    stored in metadata for files。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像一条河流。好的，这些模式位实际上是你传递给它的一个字符串，一个字符集的指针。这里有很多模式选项，如果你给它一个 R，它是只读的，如果你给它一个 W，它是只写的，如果你给它一个
    A，它是追加的，即从文件末尾开始等等。现在，关于文件权限是否存储在元数据中的问题。
- en: So， I'm going to say yes for things that are of the power of Unix。 We're going
    to actually look at the fat file system as our first one where permissions are
    a little bit less cleanly defined but for now it's actually。 part of the metadata。
    Okay。 And so an open stream is actually represented by a pointer to a file structure
    so look what comes back from F open is a file star。 Okay。 And how do you get an
    error back so this is going to be an essential question that I'm going to want
    to train you guys and Anthony's going to want to train you guys very well by the
    end of the term。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我想说对于 Unix 系统的功能来说，答案是肯定的。我们将首先查看 FAT 文件系统，它的权限定义不太清晰，但目前它实际上是元数据的一部分。好了。所以，打开的流实际上由一个指向文件结构的指针表示，因此，从
    F open 返回的是一个 file star。好的。那么，如何返回错误呢？这个问题将是我想要训练大家的关键问题，Anthony 也会想要在学期结束时将其训练好。
- en: Whenever you execute a system function of some sort you always ask yourself
    what's the error condition。 And here the error condition would be that rather
    than getting a pointer to a file structure you get back a null which are zero。
    Okay， in which case the F open failed and you shouldn't go anywhere with it。 Okay。
    And in class I'll say more about this later， I will probably not always in fact
    frequently won't look at the error cases because that would just make my slides
    messy。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你执行某种系统功能时，你总是要问自己，错误条件是什么？在这里，错误条件是，如果你没有得到一个文件结构的指针，而是得到了一个空值（即零）。好的，这时`F
    open`失败了，你不应该继续进行。好的，课堂上我稍后会讲更多内容，可能并不总是，事实上，通常我不会去看错误情况，因为那样会让我的幻灯片显得杂乱无章。
- en: but you as budding system programmers should always think about errors。 And
    what's the error return。 And let's look at some of what we got with the stream
    interface so among other things。 there are some free standard streams that are
    always open for reading and writing。 So that's the standard input standard output
    and standard error。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为有志向的系统程序员，你应该时刻考虑错误。错误的返回值是什么？我们来看看流接口的部分内容，除此之外，还有一些总是处于打开状态的标准流，用于读写。这些就是标准输入、标准输出和标准错误。
- en: So standard in if you read from it that's the normal source of input。 Okay。
    which if you don't do anything else is typically like the keyboard。 Okay。 standard
    out is an output stream and if you don't do anything special will just print on
    your screen。 Standard error also prints on your screen but typically errors go
    to standard error。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以标准输入，如果你从中读取，那就是正常的输入源。好的，通常情况下，如果你什么都不做，它通常是键盘。标准输出是一个输出流，如果你不做特殊处理，它会直接在屏幕上打印。标准错误也会打印到屏幕上，但通常错误信息会发送到标准错误。
- en: So standard out in standard error， unless you change them are interleaved， typically。
    and they go on the same screen。 Okay。 Unlike a regular file where I have to execute
    F open to get this in every process。 you automatically have standard in standard
    out and standard error ready to go。 Okay。 And basically。 they enable composition
    and Unix in an interesting way。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，标准输出和标准错误，除非你改变它们，通常是交错的，它们会显示在同一个屏幕上。好的。不同于普通文件，我必须执行`F open`才能读取每个进程。你自动就有了标准输入、标准输出和标准错误，随时可以使用。好的，基本上，它们以一种有趣的方式使得Unix的组合变得可能。
- en: So one thing you might not have done yet but you should in your in your Unix
    environment is if you say like cat。 which means dump out the contents of hello。text
    and you put this little， vertical bar。 which is a pipe symbol and then you say
    grep world。 What you're really doing is you're taking the output of this process。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还没有做过，但应该在你的Unix环境中做的事是，如果你输入`cat`，它意味着输出`hello.text`的内容，然后你输入一个小竖线（即管道符），再输入`grep
    world`。你真正做的是，将这个进程的输出传递给第二个进程。
- en: The shell will start two processes。 The output of the first one goes to standard
    out。 The input of the second one for looking for matches comes from standard in
    but the little pipe symbol actually connects together the standard out of this
    process。 to the standard in of this process automatically。 And as a result。 what
    this will do is it'll take all the contents of hello。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Shell会启动两个进程，第一个进程的输出会传递到标准输出。第二个进程的输入来自标准输入，用于查找匹配项，但小管道符实际上自动将第一个进程的标准输出连接到第二个进程的标准输入。因此，结果就是它会获取`hello`文件的所有内容。
- en: text and send it to grep to look for the world world， the word world exclamation
    point in that file。 Okay。 And so we're actually connecting up standard ins and
    standard outs with the shell and that's going to be something that you get to
    do with the shell homework。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文本并将其发送给`grep`，以便在该文件中查找单词“world”，即“world！”这个单词。好的。所以我们实际上是通过Shell连接标准输入和标准输出，这也是你将在Shell作业中做的事情。
- en: Okay。 So that's something to look forward to。 Now。 Let's look。 So the good question
    here is in the chat if it was just grep what would happen。 So the answer is that
    really the way you would do this is you would say grep world and then you'd say
    the file name and so then grep actually has two arguments that you use。 Okay，
    if you just said grep quote world on the line by itself。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么这是值得期待的。现在，我们来看一下。聊天中的一个好问题是，如果只是使用`grep`，会发生什么？答案是，实际上你会这样做：你会说`grep world`，然后给出文件名，然后`grep`实际上有两个参数要使用。好的，如果你只是说`grep`并单独输入`world`，会怎样呢？
- en: it would pause there because it'd be waiting for standard input。 So you would
    actually end up with a with a failure in that case okay because you really need
    to have a file to to grep from。 Okay， but get that a try。 Okay。 And it's actually
    what will really happen。 Well。 you give it a try see what happens。 Okay。 So now
    we're going to。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它会在那里暂停，因为它在等待标准输入。所以在这种情况下，你实际上会遇到一个失败。好的，因为你确实需要一个文件来进行`grep`操作。好的，试试看。好的。这实际上就是会发生的情况。好了，你试试，看看会发生什么。好的。那么现在我们要做的是。
- en: So there was another question here about what does the greater than symbol do
    we're not we're not going to get too in depth into the into the details here until
    you get a little bit later but if you if I were to put a greater than symbol。
    After all of this and then put a file name what it says is take the standard out
    from that grep process and dump it into a file。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个问题，关于大于号（`>`）符号的作用是什么，我们暂时不会深入讨论细节，直到稍后，但如果我在所有这些后面加上一个大于号（`>`），然后加上一个文件名，它的意思是将来自`grep`进程的标准输出重定向到一个文件中。
- en: So the greater than symbol， rather than the bar actually allows you to redirect
    into a file。 So part of what the shell homework is going to be is you get to learn
    how to make vertical bar and greater than and less than symbols work properly
    by tying together processes。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，大于号（`>`）符号，而不是竖线（`|`），实际上允许你将输出重定向到一个文件中。所以，部分的shell作业就是你要学习如何正确使用竖线、大于号和小于号符号，通过将多个进程串联起来。
- en: So that's actually what you get to do。 So let's look at something that's not
    standard it in standard out so if they let's suppose that we had a file on disk
    and we wanted to do stuff with it well once we opened it。 Then we've got the we
    can put the file star for that file we've opened here and now we can do reads
    and rights of single characters or strains。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这实际上就是你需要做的事情。那么我们来看一下不是标准输入输出的情况。如果我们假设有一个文件在磁盘上，并且我们想对它做一些操作，一旦我们打开了它。那么我们就可以拿到我们打开的文件的文件指针，现在我们可以进行单个字符或字符串的读写操作。
- en: Okay。 And this will return this will put F put C will try to put the value on
    to a stream so this is a right。 And it'll either return the character or an error。
    Here's a read for instance of string will actually read up till or this will excuse
    me F put as this will actually put a string onto the file all the way up to the
    no。 And then there's other ones like this okay so these are character oriented
    getting okay。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这个操作将返回并尝试将值写入流中，所以这是一个写操作。它将返回字符或错误。例如，这里有一个读取字符串的操作，它实际上会读取直到某个位置，或者说，抱歉，`Fput`实际上是将字符串写入文件，直到没有更多内容为止。然后还有其他类似的操作，这些都是面向字符的I/O操作。
- en: And you can do man so I'm going to want you to start looking at man。 And then
    giving a command and that'll actually give you exact details about what these
    do。 Okay。 another version so but let's look at it one example just you see so
    notice how I opened input。text this is all relative to the current working directory。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`man`命令。所以我希望你开始学习使用`man`命令，然后输入一个命令，这样就能给你提供这些命令的详细信息。好的，另外一种方式，让我们看一个例子。注意，我是如何打开`input.text`文件的，这一切都是相对于当前工作目录的。
- en: I get that input file star I have an output file output file star notice that
    the input one is open for reading the output ones open for writing。 And then what
    I do is I get a character from from the input file。 And as long as that character
    is not EOF I write it to the output file I get the next one and I keep in the
    loop so that'll basically transfer everything from the input file to the output
    file。 And then I close the two okay and this is doing character by character IO。
    Okay。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到输入文件指针`file_star`，然后有一个输出文件`output_file_star`，注意输入文件是以只读方式打开的，而输出文件是以写入方式打开的。然后我从输入文件中获取一个字符，只要那个字符不是`EOF`，我就把它写入输出文件，然后获取下一个字符，继续循环。这样就会将输入文件的所有内容转移到输出文件中。最后关闭两个文件。这是在做字符逐个读取和写入的I/O操作。
- en: so in that previous example by the way the question is was cat and grapped two
    different children processes at the same time yes。 Okay so now those were single
    character or bite oriented IO we also have block oriented IO again notice they
    all have F in front of them that's important。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在前面的例子中，顺便提一下，问题是`cat`和`grep`是否会同时启动两个不同的子进程？是的。好的，那么那些是面向单个字符或字节的I/O操作，我们也有面向块的I/O操作，再次注意它们前面都有F，这一点很重要。
- en: So in addition to the file star of the open file we in this case we actually
    give a pointer to a buffer and the size of elements that we want and how many
    of them we want to read or write。 And this will read a whole bunch of things at
    once。 Okay， and that will be that's buffered。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以除了文件指针之外，在这个情况下我们实际上传递一个指向缓冲区的指针，以及我们想要的元素大小和我们想要读取或写入的数量。这个操作会一次性读取一大堆数据。好了，这样就是有缓冲的操作。
- en: Bigger IO okay and it into a buffer that you specified and so this void star
    is really just a pointer to a buffer that you've pre allocated of an arbitrary
    type that's kind of what void star means and see you get used to this as well。
    And so with F read I can read a big chunk of data at once rather than a single
    character and with F right I can write a big chunk of things rather than a single
    character at a time。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的IO操作，好的，将其放入你指定的缓冲区中，所以这个`void*`实际上只是一个指向你预先分配的缓冲区的指针，缓冲区的类型可以是任意的，这就是`void*`的含义，你也会习惯这种用法。通过`F
    read`，我可以一次读取一大块数据，而不是单个字符，使用`F write`，我可以一次写入一大块数据，而不是逐个字符地写。
- en: And you can imagine this has a lot lower overhead and so you'd want to do buffer
    reader right you can't。 Okay， and so here's another example of using the buffer
    read and write versions and notice what I've done here or the read F right and
    F read versions and notice I define my buffer size here as a constant for 1024。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，这样的开销要小得多，所以你肯定会想使用缓冲区读取操作，对吧？好的，这是另一个使用缓冲区读写版本的例子，注意我在这里做了什么，或者说是`read
    F`、`write F`和`F read`版本的使用，注意我在这里定义了缓冲区大小作为常量1024。
- en: And down inside the main here I declare a buffer of size 1024 that's what this
    means it's a character buffer。 And so then what I'm going to do is I read into
    that buffer。 That's a pointer to buffer of maximum size buffer size， a bunch of
    elements of size。 whatever character is。 Okay， and the， and from the input file。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我声明了一个大小为1024的缓冲区，这就是这个意思，它是一个字符缓冲区。然后，我要做的是将数据读取到这个缓冲区中。这是一个指向缓冲区的指针，最大大小为`buffer
    size`，一个元素的大小是字符的大小。好了，从输入文件读取数据。
- en: And that comes back as a link that tells us what length was come back with and
    it's either non zero or zero if it's zero the files done if it's non zero。 then
    I go ahead and write the buffer out that many items and I keep looping。 So this
    is now doing a much better copy from input that text to output。 that text where
    we potentially grabbing things in 1024 by chunks it's much more efficient。 Okay，
    so。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它会返回一个链接，告诉我们返回了多少长度，如果是零，文件结束，如果不是零，那么我就继续将缓冲区的数据按数量写出，并继续循环。这样现在从输入文本到输出文本的复制效率大大提高，可能会一次读取1024个字节，效率更高。好了。
- en: here， we're still doing everything is still a stream but we're doing block oriented
    IO here and it was character oriented IO in the previous one so we're all still
    streaming。 Alright， and again check your errors so always assistant programmers。
    you should be really writing things like this where we get the input from F open，
    if the inputs， no。 we do something else because we failed you do not want to pass
    no。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们依然在做所有的操作都是流式的，但是我们在做基于块的IO，而之前是基于字符的IO，所以我们依然在进行流式操作。好了，再次强调，检查错误，始终做程序员助手。你应该真正写出像这样的代码，从`F
    open`获取输入，如果输入是`no`，我们做其他的事情，因为失败了，你不想传递`no`。
- en: You want to pass no into one like F read if this were no then this thing would
    fail in a bad way okay and you wouldn't necessarily know why。 Alright， always
    check errors， always start by saying man。 give the command see what the error
    return is like。 That's not error checking in class。 but that doesn't mean that
    you shouldn't check that。 Alright， so that's the high level API。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你想通过将`no`变成一个类似于F的读取方式，如果它是`no`，那么这个操作就会以一种不好的方式失败，好的，你可能并不一定知道为什么。好了，始终检查错误，始终从输出错误返回是什么样子开始命令。那不是类中的错误检查，但并不意味着你不应该检查它。好了，这就是高层API。
- en: There are a bunch of other things like you can do F seek to set the pointer
    to a particular part in the file。 Okay， so F seek you can set it relative to the，
    the current position so here's the current position of the file。 you can seek
    to an offset from there you can seek to an offset from the beginning。 And thereby
    you can go to different parts of the file to read different parts randomly as
    you will。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他的事情，比如你可以使用`F seek`将指针设置到文件中的特定位置。好了，`F seek`你可以相对于当前位置设置它，下面是文件的当前位置，你可以从这里偏移，或者从文件开头偏移。通过这种方式，你可以随机读取文件的不同部分。
- en: Okay， but if you don't seek， then each read， whether it's a。 whether it's a
    character oriented get see or a block oriented read will actually just work its
    way slowly because it advances the pointer as you go。 Okay， so now what I've just
    described with streams is actually a good example of Lib C wrapping an interface
    around the low level descriptors for you。 Okay， and the reason that this is helpful。
    A particularly good reason is if we go back to this example of getting one character
    at a time and writing one character at a time。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但如果你不进行搜索（seek），那么每次读取，无论是字符定向的 `getchar` 还是块定向的读取（block read），都会慢慢地进行，因为它会随着你前进而推进指针。好的，现在我刚刚描述的流（streams）其实是
    Lib C 为你封装低级描述符的一个很好的示例。好的，这个封装的原因特别有用。一个特别好的原因是，如果我们回到每次读取一个字符，写入一个字符的例子。
- en: you can imagine this is horribly inefficient。 In general。 because what happens
    is if you made a system call for every character that you were getting。 you got
    to go into the kernel that's got a lot of overhead it's got to go find the character
    bring it back。 And so this would be her horrendously inefficient。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，这样的做法是非常低效的。一般来说，因为发生的事情是，如果你为每一个字符调用一次系统调用，你就得进入内核，这会有很多开销，它得去找到字符并把它取回来。所以这会是非常低效的。
- en: except we're using the streaming versions because we've got F here。 And what
    happens is F get see is actually running it user level inside the kernel， excuse
    me。 running it user level inside the process。 And this file descriptor actually
    has a chunk of memory that it has reserved in user level for for buffering。 So
    when you do F get see the first time it actually goes into the kernel grabs a
    chunk of data like a thousand 24 bytes and puts it into the user level buffer。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只不过我们使用的是流版本，因为这里有 F。发生的事情是，`Fgetc` 实际上是在内核中以用户级别运行，抱歉，是在进程中的用户级别运行。这个文件描述符实际上在用户级别为缓冲区保留了一块内存。所以当你第一次调用
    `Fgetc` 时，它实际上会进入内核，抓取一块数据，比如1024字节，并把它放到用户级别的缓冲区中。
- en: And then each F gets see from that point on until we run out of that data is
    really efficient because it's in user level。 So the streaming is really about
    automatic buffering in a way in live see without you having to worry about it。
    Okay。 So， but that's implemented at the low level by actually using the real system
    calls here's open create close and this is not a misspelling。 of create by the
    way， these are system calls directly that go into the kernel。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，直到数据用完之前，每次调用 `Fgetc` 都非常高效，因为它是在用户级别处理的。所以流处理实际上就是在 Lib C 中实现了自动缓冲，省去了你必须担心它的麻烦。好的。所以，这在低级别是通过实际使用系统调用来实现的，这些调用包括
    `open`、`create` 和 `close`，而且这不是拼写错误，`create` 这个词是正确的，它们是直接进入内核的系统调用。
- en: And here I give a file named open and some flags in a mode， for instance。 and
    it opens the file for me but it returns an integer not a file star that means
    it's returning a file descriptor。 Okay。 And that file descriptor integer is something
    that I'm then going to use from that point on when I'm reading and writing。 And
    I'll show you that in a moment。 Okay。 But so what to notice from this。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我给出了一个名为 `open` 的文件以及一些标志和模式，比如。它为我打开了文件，但返回的是一个整数，而不是文件指针（file pointer），这意味着它返回的是一个文件描述符。好的。这个文件描述符整数是我从此以后在读写时要使用的东西。稍后我会给你展示。好的。那么要注意的是这一点。
- en: There are some flags like read， write， create， etc。 And more bits like permissions
    that I need for when I'm writing， you know。 what's the user group other permissions
    that I want to put in that file。 Notice that return from open， assuming that it's
    not an error which would be negative return。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些标志，如读取（read）、写入（write）、创建（create）等。还有一些像权限（permissions）这样的位，我需要在写入时使用，你知道的，用户组和我想在文件中设置的其他权限。注意，`open`
    返回的结果，假设它不是错误（即不会是负值返回）。
- en: What I get back is an integer file descriptor that is an integer。 Okay。 And
    the other thing I want to point out is this open doesn't have an F in front of
    it。 It's open without an F。 Okay。 And so if the air if what comes back from opens
    negative it's an error。 Otherwise it's a file descriptor。 Okay。 And just like，
    just like in the buffered stream versions。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到的是一个整数类型的文件描述符。好的。还有我要指出的另一件事是，`open` 前面没有加 F，它是没有 F 的 `open`。好的。如果从 `open`
    返回的是负值，那就是错误。否则它就是一个文件描述符。好的。就像缓冲流版本一样。
- en: the， the un buffered low level versions also have file descriptors that are
    integers for standard in standard out on standard error。 But since they're integers，
    what we know is there zero is standard in one is standard out and to a standard
    error。 And every process typically starts with those values assigned to something。
    And so standard in。 which is， which is zero is assigned to grab stuff from your
    keyboard and standard out and standard error typically set up to send things to
    the screen。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 非缓冲的低级版本也有文件描述符，标准输入、标准输出和标准错误都用整数表示。但是因为它们是整数，我们知道 0 是标准输入，1 是标准输出，2 是标准错误。每个进程通常从这些值开始分配。标准输入（即
    0）用于从键盘获取内容，标准输出和标准错误通常设置为将内容输出到屏幕。
- en: Okay。 And there are macros that you want to use。 You don't want to say 012 because
    that's bad programming style。 You want to say standard in file， no， etc。 And these
    macros are defined in another include file。 you understand。h。 Okay。 All right。
    Now， so the difference between the F buffered versions and the un buffered versions
    is the un buffered versions don't have that buffer in memory。 Okay。 So they're，
    they don't have that efficiency of asking the kernel for more than the user currently
    wanted so that they can be more efficient。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。你应该使用宏。你不应该写 012，因为那是糟糕的编程风格。你应该写标准输入文件、标准输出文件等等。这些宏在另一个包含文件中定义。明白了吗？好的。现在，缓冲版本和非缓冲版本的区别在于，非缓冲版本没有那个内存中的缓冲区。好的。所以它们没有请求内核返回比用户当前需要更多数据的效率。
- en: Okay。 But this is the direct interface into the kernel。 So， so notice。 for instance
    that read now doesn't have an F in front of it because I'm using the low level
    interface。 I put the file descriptor as the first argument。 And then I have a
    buffer and a size。 which is the maximum number of characters that I can get back。
    Okay。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。但这是直接进入内核的接口。所以，注意。例如，现在的 `read` 前面没有 F，因为我使用的是低级接口。我将文件描述符作为第一个参数，然后是一个缓冲区和大小，大小是我可以返回的最大字符数。好的。
- en: And that's a read and reads will read up to the maximum size I asked for， but
    it might be less。 Okay。 And the， um， notice the fact here that what comes back
    from read is one of two possibilities。 either it's a zero， in which case， not
    only was nothing read。 but the file is done where at the end of file。 Otherwise。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `read`，`read` 会读取最多我请求的最大大小，但它可能少于这个数。好的。并且，注意这里的事实，`read` 返回的结果有两种可能性：要么是
    0，这种情况下不仅没有读取任何内容，文件已经读取完毕，也就是到达文件末尾。否则，
- en: it's some number greater than one to tell me how many characters I got。 Okay。
    And it actually might be less than what I asked for。 So if I asked for 20。 it
    might give me back one。 And you have to keep that in mind。 Okay。 So it returns
    up to maximum size。 And so if you're expecting more。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个大于 1 的数字，告诉我我读到了多少个字符。好的。它实际上可能少于我要求的数量。所以如果我要求 20，它可能只给我 1 个。你需要记住这一点。好的。所以它返回最多最大大小。所以如果你期望更多的话，
- en: you may have to do this in a loop。 Okay。 And as is usual， if it's negative，
    it's an error。 Okay。 And writing has a similar idea。 Notice the file is crypto
    is the first argument。 It's an integer。 I have the buffer and how much I want
    to write， and it returns number of bytes written。 And in this case， if the only
    reason it would return less than the total number of bytes I asked for is typically
    an error。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要在一个循环中进行此操作。好的。通常来说，如果返回值是负数，则表示出错。好的。写入也有类似的概念。注意，文件 `crypto` 是第一个参数，它是整数，我有缓冲区和我要写入的字节数，它返回写入的字节数。在这种情况下，唯一会返回少于我请求的字节数的原因通常是出错。
- en: but you should do man on， right as well。 Okay。 And the reason that a file descriptor
    is an integer。 Well， because it's going to be a look up in a table inside the
    kernel。 So everybody。 I'm going to have you back up for a moment and think about
    what we said about interrupt handlers。 right？ The interrupt handler had a vector，
    and we took the interrupt number and that told us a very clean entry point into
    the kernel。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你也应该查阅手册，明白吗？好的。文件描述符是整数的原因是什么？因为它将在内核中的表格中进行查找。所以，大家，我让你们稍微回想一下我们之前说的关于中断处理程序的内容。对吗？中断处理程序有一个向量，我们通过中断号来确定一个非常清晰的入口点进入内核。
- en: And so that was one way of being secure against the user doing something crazy。
    This example where the file descriptor is just an integer is the same idea where
    it gives me back an integer and then I pass a data integer to the kernel when
    I'm busy reading and writing。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一种防止用户做出疯狂操作的方式。这个例子中，文件描述符只是一个整数，它的思路是相同的，返回一个整数，然后我在读取和写入时将一个数据整数传递给内核。
- en: And the kernel， the kernel is not trusting a file star， which is a buffer and。
    a user space that might be bogus。 It's only got an integer and it can directly
    check and see whether that integer is good or not。 Okay。 But anyway， so read，
    write， seek。 Okay。 All right。 these are all versions of what we just saw in a
    buffering sense。 Okay。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 而内核不信任文件指针，它只是一个缓冲区，可能是用户空间中无效的。它只有一个整数值，并且可以直接检查这个整数是否有效。好吧。但无论如何，读取、写入、定位。好吧。这些都是我们刚才在缓冲的意义上看到的版本。好。
- en: And so here's a simple example of I open a file for reading。 Okay。 And。 and
    then I have some permission bits here。 And I read it。 Okay。 I close it and then
    I write it to standard out。 So this is a very simple example。 Okay。 How many bytes
    does this program read well it's going to read up to 1000 right。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个简单的例子，我打开一个文件进行读取。好吧。然后我这里有一些权限位。接着我读取它。好吧。我关闭它，然后将其写入标准输出。所以这是一个非常简单的例子。好吧。这个程序读取了多少字节呢？它将读取最多1000字节。
- en: And then the difference a file descriptor which you see right here is the thing
    that comes back from open that is a file descriptor。 Okay。 It's an integer zero。
    It's a positive integer。 If you ever get back a negative here you know there's
    a problem。 Okay。 So。 I want to emphasize something here， which is this design
    pattern that we've been talking about both at the low and the high level。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，文件描述符的不同之处在于，它是从打开操作中返回的内容，它是一个文件描述符。好吧。它是一个整数零或者一个正整数。如果你得到的是一个负数，那么就知道有问题了。好吧。所以，我想强调一下这里的内容，那就是我们一直在讨论的低级和高级的设计模式。
- en: the low level design pattern is you always open before use。 Okay。 so notice
    we always did open so open is the thing or F open if you're using the streaming
    versions。 And then the thing that checks permissions and make sure you have permission
    to use something and assuming open returns without error。 then， then you no longer
    have to check the permissions because now you have a file descriptor that you
    can keep using for reading and writing。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 低级设计模式是你在使用之前总是先打开。好吧，所以注意我们总是做了打开操作，因此打开是关键，或者如果你使用的是流式版本，则是F打开。接着，检查权限的部分会确保你有权限使用某个文件，并假设打开操作没有出错。那么，你就不需要再检查权限，因为现在你拥有了一个文件描述符，可以继续用于读写。
- en: And assuming that you use it the way you said you wanted to saying you wanted
    to read or wanted to write it should work。 Okay， and so we do all the permissions
    checking first and then all the subsequent reads and rights don't do permission
    checking。 So if you look here for instance， we did the permission checking at
    this point。 And then now when we do read we only give the file descriptor and
    we don't have to say anymore about what's the file name or any of that stuff because
    open now has a working file descriptor and we just。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你按照自己说的方式来使用——比如说你想读取或者写入，它应该会工作。好吧，因此我们首先进行所有的权限检查，然后所有后续的读写操作都不再做权限检查。所以如果你看看这里，例如我们在这个时刻做了权限检查。然后现在，当我们进行读取时，我们只需要提供文件描述符，而不需要再说文件名或者其他任何事情，因为打开操作现在已经有了一个有效的文件描述符，我们就直接使用它。
- en: do not。 Okay， and it's an index the file descriptors and index into internal
    tables and we'll talk a lot more about that as we go further。 Okay。 And so the
    pattern here is we always open first。 It's bite oriented so it doesn't matter
    whether I grab a big chunk of of bites or not。 I'm guessing it is bite so I sort
    of say I want a thousand 24 bites， or I want one bite。 Okay。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要。好吧，它是一个索引，文件描述符是内部表格中的一个索引，我们将进一步讨论这一点。好吧。所以这里的模式是我们总是先打开。它是基于字节的，因此不管我是否抓取了大块的字节都无关紧要。假设它是字节，因此我可能会说我想要1024字节，或者我只需要一个字节。好。
- en: it doesn't care。 Oh， it doesn't care what it is or what those bites represent
    it's just giving me bites back or taking bites for rights。 We close it explicitly。
    Okay。 So， reads inside the kernel are actually buffered。 So because a disk as
    you'll learn a lot later in the term takes things in thousand 24 or four thousand
    ninety six bite chunks。 It doesn't even make sense to try to read a bite from
    a disk。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它不在乎。哦，它不在乎这是什么，或者那些字节代表什么，它只是给我字节，或者为写入字节而取字节。我们明确地关闭它。好吧。所以，内核中的读取其实是有缓冲的。因为磁盘，正如你将在本学期稍后学到的，通常以1024或4096字节为一块来处理。甚至从磁盘读取一个字节都没有意义。
- en: So in the low level interface where you you're using the system calls and you
    asked for a couple of bites。 The kernel actually has its own cache， which we'll
    talk about， about。 So。 we'll talk about the buffer cache， which is storing chunks
    of things off of disk and feeding them to the user in a way that lets it look
    like everything is bite oriented。 So that's the everything's a file。 Everything's
    a bite oriented file and it doesn't matter that the underlying storage is block
    based we give that illusion of everything's a file and it's all bite oriented。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在低级接口中，当你使用系统调用并请求几个字节时，内核实际上有它自己的缓存，我们稍后会讲到。我们会讲到缓冲区缓存，它存储来自磁盘的一块块数据，并以一种让它看起来像是字节导向的方式喂给用户。所以这就是“一切都是文件”。一切都是字节导向的文件，底层存储是基于块的，我们给了它一个一切都是文件，且一切都是字节导向的假象。
- en: So， I'm not sure if we're in the kernel because you can't write a single bite
    to a disk either。 Okay。 And so all of that stuff is buffered inside of the kernel。
    And this buffering is sort of part of global buffer management across the whole
    machine。 And to make things complicated perhaps is that buffering is done by the
    operating system。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我不确定我们是否在内核中，因为你也不能向磁盘写入单个字节。好吧。所以所有这些都在内核内进行缓冲。而这个缓冲算是一种在整个机器上的全局缓冲管理。为了让事情变得复杂一点，缓冲是由操作系统完成的。
- en: The stream buffering is done by the user level library and those two buffers
    could cause you trouble if you weren't careful and remembering。 what's buffered
    where。 Okay。 But you'll get used to that。 Don't worry。 And we'll make sure that
    makes sense in addition。 So there's a bunch of other low level operations。 I mentioned
    the iocthal interface for changing， you know， resolutions and terminal。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲由用户级库完成，这两个缓冲区如果你不小心并且不记得缓冲的地方，可能会让你遇到麻烦。好吧。但你会习惯的。别担心。我们也会确保这一切都能让你理解。此外，还有许多其他低级操作。我提到了
    iocthal 接口，用来改变分辨率和终端等。
- en: and the bug rates and stuff。 There's ways of duplicating descriptors which you'll
    get to learn a lot about for your shell。 So for instance， I can take an old one
    and I can say take that file descriptor and take this new one and make that new
    one a duplicate of the old one。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以及错误率之类的。有一些方法可以复制描述符，稍后你会学到很多关于你 shell 的内容。举个例子，我可以取一个旧的文件描述符，然后说，取这个文件描述符，把这个新的文件描述符作为旧文件描述符的副本。
- en: et cetera。 There are pipes which are ways of communicating between processes
    you'll learn about those。 There's ways of locking files there's ways of memory
    mapping files so that you can share between processes。 Ways of doing asynchronous
    IO all sorts of stuff。 But the key thing here is that remember everything is a
    file。 Okay， in the way that I interact with it across the system call interface。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。这里有管道，它们是进程间通信的一种方式，你将会了解它们。还有文件锁定的方式，文件内存映射的方式，这样你就可以在进程间共享数据。异步IO的方式，各种各样的东西。但是这里的关键点是，记住一切都是文件。好吧，以我通过系统调用接口与之交互的方式来看。
- en: Everything has an open read right close pretty much everything。 And even if
    I'm talking to a network or I'm talking to a file or I'm talking to a pipe with
    another process all of those things I'm reading and writing is if it were a file
    and that's the。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都有打开、读取、写入、关闭，几乎所有的东西。即使我在和网络通信，或者在和一个文件通信，或者在和另一个进程通过管道通信，所有这些我读取和写入的东西都像是文件一样，而这就是。
- en: that's the title of today's lecture is that everything is a file。 Yes， even
    a mouse is a file。 Okay。 you can open the open the stream on the slash dev part
    of the file system and there you can find a raw port to read from。 Okay， so what's
    the difference between high and low level API。 So I'm presenting him in the same
    lecture because I want you to always say does it have an F in front of it or not。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 今天讲座的标题是：一切皆文件。是的，连鼠标也是一个文件。好的，你可以打开文件系统中的/ dev部分的流，在那里你可以找到一个原始端口进行读取。好的，那么高级和低级API之间有什么区别呢？我将它们放在同一讲座中，因为我希望你们始终思考：它前面有没有一个F。
- en: Is it an F open or is it an open am I mixing file stars with integers。 I want
    you to at least know that both of them are there so that you don't。 So you at
    least can hope to not mix them up。 Okay。 but if you look at the high level streaming
    interface。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它是F open还是open，我是不是将文件指针和整数混淆了。我希望你们至少知道它们两者都存在，这样你就不会混淆。好的，但是如果你查看高级流接口。
- en: What happens is the F read function is actually in lib C and has a whole bunch
    of stuff that runs at user level。 Like a normal function and it might occasionally
    make a system call where I have there's sort of assembly headers and stuff that
    you get to learn about in project one。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，F read函数实际上在lib C中，并且有一大堆在用户级别运行的内容。就像一个普通函数，它可能偶尔会进行系统调用，其中包含一些汇编头文件等内容，这些你会在项目一中学到。
- en: And then I call into the kernel which does some stuff for me and then I exit
    the kernel and I do more stuff at user level。 So I'm kind of like I'm wrapping
    this kernel interface with interesting user level stuff like buffering that I
    talked about in the streams。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我调用内核，内核为我做一些事情，接着我退出内核，做更多的用户级别的操作。所以我有点像是在用一些有趣的用户级别的东西（比如流中的缓冲）来封装这个内核接口。
- en: And that's how I get a high level streaming reads rights opens F read F right
    F open。 The low level one is basically just kind of the raw interface to the kernel。
    So this is the raw system call so I read as this raw system call。 an F read does
    a bunch of other stuff for buffering and so on。 Okay。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我如何获得高级的流式读取、写入、打开F read、F write、F open。低级的基本上就是直接与内核交互的原始接口。所以这是一个原始的系统调用，我作为这个原始的系统调用进行读取。F
    read会做一些其他的缓冲操作等等。好的。
- en: and so really the high level API is make it more useful for people by wrapping
    stuff around it。 Okay。 As Anthony basically is stating in the chat there。 you
    should take a look at slash damn slash it's got all sorts of weird files in there
    you can do all sorts of stuff with if you're the super user。 So I just want to
    do one last thing to keep in mind all the buffering so streams are buffered and
    user memory。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，实际上，高级API通过在其周围包装内容，使其对人们更有用。好的，正如Anthony在聊天中所说的，你应该查看一下/ damn /，里面有各种奇怪的文件，如果你是超级用户，你可以做很多事情。所以我只想做一件最后的事情，记住所有的缓冲，因此流是缓存在用户内存中的。
- en: So for instance， print F being a streaming interface actually takes it basically
    takes a you know beginning of line that I sleep for a little while I say end of
    line。 And there's enough buffering in this that it waits at user level until the
    slash and which is the new line comes up and then it sends the。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，print F作为一个流接口，实际上是这样的，它基本上接收一个行首，我休眠一会儿，然后说行尾。这个过程中有足够的缓冲，它会在用户级别等待，直到遇到换行符（即斜杠n），然后它才会发送。
- en: the resulting line out to the screen。 And if I use the very low level things
    where for instance I write to the standard out beginning of line and sleep and
    then say end of line。 what will happen is you'll actually see beginning of line，
    and wait 10 seconds and say end of line。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会在屏幕上显示出来。如果我使用非常低级的操作，比如我写入标准输出的行首并且休眠，然后说行尾。那么发生的事情是你会看到行首，等待10秒钟，然后才会显示行尾。
- en: And the reason for this is that there's buffering happening at user level in
    this case。 Okay。 So what I mentioned in the buffer cache inside the kernel fortunately
    is invisible to users。 Okay。 so it's there， and you occasionally have to flush
    to push something out to disk but it's mostly something you can can ignore the
    buffering at the user level with the streaming interfaces you have to be a little
    more careful about。 Okay， so I'm running administrative a little late today so
    my office hours。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是，在这种情况下，缓冲是在用户级别进行的。好的。所以我提到的内核中的缓冲缓存对用户来说是不可见的。好的，它在那里，你偶尔需要刷新以将某些内容推送到磁盘，但大多数时候你可以忽略用户级别的缓冲。对于流式接口，你需要稍微小心一些。好的，我今天行政事务稍微晚了一点，所以我的办公时间。
- en: I think for now we're going to do one to two on Tuesday and Wednesday。 So I
    picked a class day and a non class day in the hopes that people will be able to
    come to those。 And I may。 I don't know if I'll do zoom up I may post a zoom link。
    We'll see how that goes my no next week in theory we're in the office so。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得现在我们打算在星期二和星期三进行一次到两次会议。所以我挑了一个上课的日子和一个不上课的日子，希望大家能够参加。我可能会做一次 Zoom 会议，或者我会发布一个
    Zoom 链接。我们看看下周的情况，理论上下周我们会在办公室。
- en: there's nobody left on the wait list so everybody that's going to be in the
    class is in the class。 And so tomorrow is drop deadline。 So you should make sure
    that if there are any friends of yours that might have been in the class and forgot
    they stayed in there but decided they were leaving。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在等候名单上没有人了，所以所有将参加这门课的人都已经在课上了。明天是退课的最后期限。所以请确保，如果有你们的朋友可能忘了退课但最终决定不继续上课，赶紧处理。
- en: Make sure they drop by tomorrow。 Okay， I every term， somebody at the end of
    the term comes and says。 Oh， Professor Kubie you know I forgot to drop it and
    now I'm got trouble trying to petition this and it doesn't always work。 So please
    make sure that they drop it and you drop if you're planning to drop。 Otherwise。
    Otherwise you should start forming your groups。 Okay。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 确保他们明天来一趟。好吧，每个学期结束时，总有人会来找我说，哦，库比教授，我忘记退课了，现在遇到麻烦，想申请退课，但是并不总是能通过。所以请确保他们退课，如果你打算退课，也请退掉。否则，你应该开始组建小组了。好的。
- en: I would say you know who's going to be in the class。 You need groups of four。
    We have the link for group formation up there and for saying kind of which sections
    you'd like to be in。 And so let's get that done。 Okay。 The other thing is if you
    notice carefully on the website and this is going to become more important as
    we go forward with more complicated stuff。 There are readings in your textbook
    that you should take a look at and I know that some people like to read as a way
    of really learning something in depth and so you know you should take a chance
    to try to read the chapters before the class to help you navigate some of the
    stuff we're going to be talking about。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说，你们需要确定谁会参加这门课。你们需要四人一组。我们有一个小组形成的链接，你们可以选择想参加的讨论课。快去完成这个任务吧。好的。另一件事是，如果你仔细看网站，会发现随着我们逐渐深入，更复杂的内容，网站上会有一些你们教材里的阅读材料，你们应该去看看。我知道有些人喜欢通过阅读来深入学习，所以你们应该利用课前的时间看看章节，帮助你们理解我们接下来会讨论的内容。
- en: Okay。 And you should be going to sections last week and this week， there are
    tomorrow on Friday。 because there is， there are some pieces of information that
    we're trying to give you in these early sections to get you ready to do ready
    to go on the projects and。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。你们应该去参加上周和这周的讨论课，明天和周五也有，因为在这些早期的讨论课中，我们尝试向你们提供一些信息，帮助你们为项目做好准备。
- en: there are no assignments or restrictions on which section to go to so go for
    it next Friday。 we will have groups assigned and that point you'll have your section
    you should be going to。 and the group sign up is operational， all four of you
    in your group should be going to the same section or if you can't do that for
    some reason。 go to a section two sections that have the same TA。 Okay。 All right。
    I think， and then midterm one。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于讨论课没有任何作业或限制，大家可以去任何一个讨论课。所以，去吧，下一周五，我们将分配小组，届时你们就会有自己固定的讨论课。小组报名系统已经启用，你们小组里的所有人应该去同一个讨论课，或者如果因为某些原因不能去同一个课，可以去两个有相同助教的讨论课。好的。好吧，我想，接下来是期中考试一。
- en: two， three， we have all of the， the days are fixed。 The time is seven to nine。
    And now it's just about dealing with conflicts and so on。 and we'll talk about
    other things as we go on in terms of conflicts。 I didn't put this on my slides。
    but I do want to say as a matter of course we're opening up to reality right it's
    it's about time for us to be。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 二三，所有的日期已经确定。时间是七点到九点。现在就剩下处理冲突等问题了。关于冲突的其他事情我们会在接下来的过程中讨论。我没有把这些放到幻灯片上，但我想说的是，作为一个常规事项，我们需要面对现实了，差不多是时候了。
- en: Doing things next week in person。 And so please if you're sick。 don't come to
    class okay don't go to your section and whatever we will have ways that will describe
    for you to make up for things that you might have missed。 etc。 Please don't come
    to class okay we want to make sure that everybody stays safe and healthy。 Okay。
    And we will not have versions of， you know， checking for people attending and
    so on。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下周会进行面对面的课程。如果你生病了，请不要来上课，也不要去上你的辅导班。我们会有方式帮你补上可能错过的内容等。请不要来上课，我们希望确保每个人都能保持安全和健康。好的，我们不会检查大家是否到场等情况。
- en: that would convince you that you need to come sick to class so if you feel like
    you're sick and you have to come to class。 Don't do it first you could ask your
    TA if there's something you're not sure about how to make it up。 Okay。 So I think
    that's all my administer V。 I know Anthony was going to give you some off of the
    office hours to。 I didn't manage to get them from him in advance but I will， we'll
    post them on the website and。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这会让你相信你需要生病时也来上课，如果你觉得自己生病了必须来上课，请不要这么做。你可以问一下你的助教是否有不确定的地方，看看如何补救。好的，关于我的管理工作就这些了。我知道安东尼会给你们一些办公时间。我之前没能从他那提前得到这些信息，但我会把它们发布到网站上。
- en: And he can post them in the chat if he likes。 All right。 So， so the going back。
    There was a couple of questions on this last slide。 One is how are rights buffered。
    So the answer about buffering rights is they're buffered both at the high level
    and the lower level。 The high level。 What happens is rights if you write a couple
    of characters they go into a buffer in in user memory。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他愿意的话，可以把它们发到聊天里。好了，回到正题。上一张幻灯片上有几个问题。一个是关于写操作是如何缓冲的。关于缓冲写操作的回答是，它们在高层和低层都被缓冲。在高层，发生的情况是，如果你写入几个字符，它们会进入用户内存中的缓冲区。
- en: And so they don't miss you know you write a couple of bytes to the file it may
    not even go to this until you flush and close。 Okay， so you got to be careful
    there because what the high level buffering is trying to do is eliminate too many
    cross。 Into the kernel and back because crossings into the kernel are expensive。
    So that's one way things are written so you write little characters at a time
    with F right。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你写了几字节到文件，可能直到你刷新（flush）和关闭文件，它们才会真正写入磁盘。好的，所以你需要小心，因为高级缓冲的目的是减少内核之间来回的交互次数，因为进入内核的操作是昂贵的。这是写入的一种方式，你通过`F
    right`一次写入一个小字符。
- en: And then eventually you say a flush then it'll get pushed down into the the
    disk with a single F right。 Okay， this also happens inside the kernel and there
    it's more transparent to you。 and that you'll write a bunch of single characters
    with a system， call across each one of them。 They'll be buffered in inside the
    kernel and you'll need to make sure that they're flushed out to disk。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最终你会说一个刷新（flush），然后它会被推送到磁盘，通过一个单独的`F right`。好的，这个过程也发生在内核内部，对你来说更加透明。你将通过系统写入一堆单个字符，依次调用它们。它们会被缓存在内核内部，你需要确保它们被刷新到磁盘上。
- en: If you want to make sure they're on disk but other than that you won't know
    a lot about that lower level。 but you need to know the buffers there。 The other
    question is why does this delay so this is a buffered case here we print beginning
    of line goes into the buffer and user space and because print F is waiting for
    a slash and before it sends things out。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保它们在磁盘上，但除此之外，你不会知道太多低层次的细节。但你需要知道缓冲区的存在。另一个问题是，为什么会有延迟，这里是一个缓冲的情况，我们的打印行开始会进入用户空间中的缓冲区，因为`printf`在等待一个斜杠（/），在发送内容之前。
- en: And nothing happens until you do an end of line and put the the backslash and
    which is a new line and then it'll actually go to the screen。 Okay。 So let's go
    a little lower。 Okay。 So we're going to look at the system call interface so I
    gave you some actual examples of system calls read right。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 直到你写入行结束符，并插入一个反斜杠和换行符（new line），它才会真正显示到屏幕上。好的，那我们再往下看。好的，我们来看看系统调用接口，我给你们一些系统调用的实际例子，比如`read`和`write`。
- en: you know about for that's another system call。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道的，`for`是另一个系统调用。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_16.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_16.png)'
- en: So we were to look at the， for instance， the Linux system call reference there's
    a lot of them right so if you look here。 There's exit for read right open etc。
    These are all numbered。 Okay。 why are the system calls numbered。 We have numbers
    for system calls rather than function pointers。 Yep。 So we do this because we're
    indexing into a vector。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你查看例如Linux系统调用的参考文档，会看到有很多的系统调用，比如退出、读取、打开等等。这些都有编号。好的，为什么系统调用有编号？我们为什么为系统调用使用编号，而不是函数指针？没错。所以我们这么做是因为我们在一个向量表中进行索引。
- en: because we cannot trust the user to say a generic function call。 Oh。 I know
    where forks address is turn it in。 So we need to get into the kernel switching
    into kernel mode but then starting at the beginning of a well defined vetted function
    like for a read。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不能信任用户仅仅说一个通用的函数调用。哦，我知道哪里有fork的地址，把它交给它。所以我们需要进入内核，切换到内核模式，然后从一个明确定义的、经过验证的函数开始，比如读取函数。
- en: And that's why everything's got a number。 Okay， and so the actual system call
    is a special type of synchronous trap that gives kind of this the call number。
    And it looks gives looked up in a vector table。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么一切都有一个编号。好的，实际的系统调用是一个特殊类型的同步陷阱，它传递一个调用号。并且它会在一个向量表中查找。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_18.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_18.png)'
- en: Okay， so as far as the read and write interface that we've been talking about
    above the system call level we've been talking about descriptor numbers。 Okay。
    Below， by the way， there's more than 255 system calls。 So we have a descriptor
    number which is a integer at the high level below。 There's actually a descriptor
    of the file that you've opened in a structure that's in kernel memory that the
    user can't look at。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于我们上面谈到的读取和写入接口，在系统调用层面，我们一直在谈论描述符号。好的。顺便提一下，系统调用的数量远远不止255个。所以我们有一个描述符号，它是一个整数，在更高层次下。实际上，在内核内存中有一个结构体，它表示你已经打开的文件，这个结构体是用户看不见的。
- en: Okay。 And so there's an integer at the top level and inside the descriptor is
    actually a structure that points at the file。 And this integer that the user knows
    about is indexed into a table to find this underlying structure。 Okay。 And we're
    not going to go in great detail。 But if you were to look in the Linux kernel or
    you look into Pintos kernel you'd see that there is a file structure。 And so，
    you know， the user can't look at it and for now there's at least two very important
    things so one is。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以在顶层有一个整数，而描述符内实际上是一个指向文件的结构体。用户所知道的这个整数通过索引进入一个表来查找这个底层结构。好的。我们不会深入讨论。但如果你查看Linux内核，或者查看Pintos内核，你会发现有一个文件结构体。所以，用户无法看到它，且至少有两个非常重要的部分，一个是。
- en: where is the file on disk if it's a file， file system disk file。 And that's
    an I know pointer and we're going to talk about that when we get into how file
    systems are made。 And that's the current position so every time you read a bite
    that that position inside the kernel advances automatically so that a subsequent
    read will be beyond which you've already gotten it so you can just do a bunch
    of reads to read from the beginning to the end of the file。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个文件，文件在磁盘上的位置在哪里，文件系统磁盘文件。这是一个已知的指针，我们将在讨论文件系统是如何构建的时候讲到它。这就是当前位置，所以每次你读取一个字节，内核中的位置都会自动前进，这样后续的读取就会超出已经读取的部分，你可以进行一系列读取，从文件的开始读取到文件的末尾。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_20.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_20.png)'
- en: Okay。 Now， So， for system call to driver。 Let's look at what happens so when
    you execute the read system call。 It actually goes into the kernel。 It looks up
    the file structure for that read。 And then it calls some internal function like
    this VFS read will talk about the virtual file system interface later in the term。
    So， we'll give you a flavor that here's this file star which we just showed you
    there that the kernel knows about。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么，系统调用到驱动程序的过程是怎么样的呢？让我们看看，当你执行读取系统调用时，它实际上会进入内核。它查找该读取的文件结构体。然后它会调用一些内部函数，比如VFS读取，我们将在本学期稍后讨论虚拟文件系统接口。所以，我们会给你一个概念，展示这个我们刚才提到的文件结构体，内核知道它的存在。
- en: And here the parameters the user asked about。 Okay。 read up to count bytes from
    the file put it into a buffer all of these things have been sanity checked and
    will be further sanity checked inside the kernel。 And then make sure you're allowed
    to read the file。 We make sure that the file has read methods okay so every file
    actually has a set of operations you're allowed to do and if you try to read to
    something that doesn't have a read option then you'll fail。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用户询问的参数。好的，从文件中读取最多`count`字节的数据并放入缓冲区，所有这些内容都已经进行了合理性检查，并将在内核内进一步检查。然后确保你被允许读取文件。我们确保文件有读取方法。好的，所以每个文件实际上都有一组你可以执行的操作，如果你尝试读取一个没有读取选项的文件，你将会失败。
- en: And you know what's an example of that well that might be a an output stream
    like a serial link you can't read from an output link and so it wouldn't have
    a read method and so if you try to read from it it would fail。 Also we check that
    the buffer has proper permissions because we don't trust the user to give us a
    good buffer。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道那是什么例子吗？那可能是一个输出流，比如串行连接，你不能从输出连接中读取，因此它就不会有读取方法。如果你尝试读取它，它会失败。我们还会检查缓冲区是否具有适当的权限，因为我们不相信用户提供的缓冲区是好的。
- en: We check whether we're reading from a valid range in the file。 And then we get
    to the actual reading。 Okay， and there's a table of functions and if the。 If that
    particular type of file if it's device driver allows you to do a synchronous read。
    then it'll go ahead and use that function。 Otherwise it'll go and build a synchronous
    read out of the asynchronous read。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查是否正在从文件中的有效范围读取数据。然后进入实际的读取操作。好的，这里有一个函数表，如果该特定类型的文件，如果它的设备驱动允许你执行同步读取，那么它就会使用这个函数。否则，它将会基于异步读取构建一个同步读取。
- en: Okay， you don't have to worry about the all details I'm just giving you a flavor。
    Okay。 and then there's a notification that says oh somebody read this and that's
    to the parent of that file。 And we'll update some bytes read by the current tasks
    that's a little bit of statistics and some other statistics and then we'll exit。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你不需要担心所有的细节，我只是给你一个大致的概念。好的，然后有一个通知，表示“哦，有人读取了这个”，这是给文件的父进程的。我们会更新当前任务读取的字节数，这是一些统计信息和其他统计信息，然后退出。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_22.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_22.png)'
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_23.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_23.png)'
- en: Okay， so when you call a system call read something like this is going to get
    executed in the kernel at kernel level。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，当你调用系统调用读取时，类似这样的操作将在内核级别执行。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_25.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_25.png)'
- en: Okay。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_27.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_27.png)'
- en: Now， let's look back here notice I mentioned this file。 This is a take the file
    itself pointer。 Look at its f op sub field and then look at the read inside of
    that。 This is actually the device driver for that type of file， whatever it is。
    If it's on the file system， it might be a disk device driver， or it might be a
    file system。 Okay。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到这里，注意我提到过这个文件。这是一个获取文件本身指针的操作。查看它的f op子字段，然后查看其中的读取方法。这实际上是该类型文件的设备驱动，无论它是什么。如果它是在文件系统上，它可能是一个磁盘设备驱动，或者它可能是一个文件系统。好的。
- en: these are all lots of different options。 It could be referencing a mouse as
    people asked earlier。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是很多不同的选项。它可能会引用鼠标，正如大家早前提到的。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_29.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_29.png)'
- en: Okay， so the device driver actually has a structure like this， called the file
    operations structure。 And every time a new device is put into the system。 A file
    operations is registered with the device driver that basically tells the kernel
    how to do all these things。 How do you read？ How do you write？ How do you do different
    things。 Okay。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，设备驱动实际上有一个像这样的结构，叫做文件操作结构。每当一个新设备被加入系统时，都会注册一个文件操作到设备驱动中，基本上告诉内核如何执行所有这些操作。如何读取？如何写入？如何执行其他操作。好的。
- en: So it's essential to our idea that everything's a file。 because the way we're
    able to make everything a file and have the same open read right。 close interface
    is every type of device we could care about every type of thing that we could
    try to。 read right close open from all register of file operation。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于我们的想法，所有东西都是文件，这是至关重要的。因为我们能够将所有东西都当作文件，并且拥有相同的打开、读取、写入、关闭接口的方式是：我们可以关注的每一种设备类型，或者我们可以尝试进行读取、写入、关闭、打开操作的所有东西，都会注册文件操作。
- en: And so the kernel just can do the same thing。 You give it a read。 it'll go into
    that VFS read routine。 And it automatically knows which device driver to ask for
    data back from。 Is it the disk？ Is it your mouse？ Is it the network。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，内核实际上可以做同样的事情。你给它一个读取请求，它会进入那个 VFS 读取例程。它自动知道应该向哪个设备驱动程序请求数据。是磁盘吗？是你的鼠标吗？是网络吗？
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_31.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_31.png)'
- en: Okay。 So what is a device driver？ So device driver is this device specific code
    in the kernel that interacts directly with the device hardware。 It gives you this
    standard interface of open read right close。 And an I octal system call to do
    special things to the device。 Okay。 And device drivers typically are divided into
    two pieces which you'll also get to play with。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么，什么是设备驱动程序？设备驱动程序是内核中与设备硬件直接交互的特定于设备的代码。它为你提供了一个标准接口——打开、读取、写入、关闭。还有一个
    I/O 控制系统调用，用来对设备执行特殊操作。好的，设备驱动程序通常分为两个部分，你们也会接触到。
- en: There's the top half， which comes in from the user in the system call level
    and gives you open close read right。 I octal strategy， etc。 And then there's the
    bottom half。 which is handling interrupts from the device itself。 And so all the
    interrupt handlers from that device will run in the bottom half。 Okay。 And I，
    again。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上半部分来自用户并在系统调用级别工作，提供打开、关闭、读取、写入、I/O 控制、策略等。然后是下半部分，负责处理来自设备本身的中断。因此，所有来自该设备的中断处理程序都会在下半部分运行。好的，我再次强调。
- en: this is this lecture is about flavors of how this all kind of ties together。
    If you think about read from a file here。 Okay。 What you see here is the user
    program is about to do a read。 And so it's going to request some IO by making
    a system call。 And that system call， if we do a read。 it's possible that the contents
    of that read are already cash in the kernels buffer cash。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本讲座是关于这一切如何相互联系的不同方式。如果你考虑从文件读取。好的，你看到的是用户程序即将进行读取。因此，它将通过发起系统调用请求一些 I/O 操作。如果我们执行读取操作，可能该读取的内容已经缓存在内核的缓存中。
- en: in which case， if the answer is the data is already there。 then we'd have this
    quick path back out of the kernel。 We just copy stuff out of the cash。 adjust
    the pointers and move back up and all as well。 But if not。 we may need to ask
    the disk device to， to start a read， and we're going to put the process to sleep。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果数据已经在那里，那么我们就会有一个快速的路径从内核返回。我们只需要从缓存中复制数据，调整指针，然后顺利返回。但如果没有，我们可能需要请求磁盘设备开始读取，并且我们会将进程挂起。
- en: And what that really means is the kernel half of a user process gets put to
    sleep while the device is busy。 Okay， and we're going to talk a lot more about
    scheduling and putting things to sleep next time。 But imagine that if you have
    a user process is trying to read from disk that's a long latency operation。 And
    here's a number that hopefully by the end of the term you'll guys will have automatically
    but if you ask how many instructions does it take to do a disk read。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着，用户进程的一半会在设备繁忙时被挂起。好的，我们下次会详细讨论调度和挂起的内容。但是想象一下，如果一个用户进程正在尝试从磁盘读取，那是一个长延迟操作。这里有一个数字，希望到学期结束时你们会自动知道，如果问到进行磁盘读取需要多少条指令。
- en: Okay。 Well， it depends a lot on the circumstances but a number to keep in mind
    is a million instructions worth of time。 Okay， to do a discrete that's a lot。
    And so we don't want to waste all that time waiting for the disk and so the fact
    that we put the process to sleep。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，嗯，这很大程度上取决于具体情况，但一个需要记住的数字是，一百万条指令的时间。好的，进行一次离散操作需要这么多时间，这非常长。所以我们不希望浪费所有时间等待磁盘，因此我们将进程挂起。
- en: mean somebody else can work。 Okay， and so at the top half of the device driver
    may put us to sleep。 And then we have set up the disk to read and so really the
    hardware is kind of implicitly monitoring and waiting for interrupts but somebody
    else is running。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着其他人可以工作。好的，设备驱动程序的上半部分可能会让我们进入休眠状态。然后我们设置磁盘进行读取，因此，硬件隐式地监控并等待中断，但其他部分正在运行。
- en: And eventually， it interrupt comes and that interrupt handler will run and it
    will wake up the process that was sleeping。 Okay， and then it'll return from interrupt
    and the scheduler will take over and notice that that process should run again。
    It'll copy the stuff out of the buffers from the device driver， et cetera。 It'll
    transfer to the user's buffers and complete。 Okay。 So files。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，中断会到来，中断处理程序将运行，唤醒那个正在休眠的进程。好的，然后它会从中断返回，调度器会接管，并注意到该进程应该重新运行。它会从设备驱动程序的缓冲区中复制数据，等等。然后将数据传输到用户缓冲区并完成操作。好的。文件。
- en: so the thing that this is glossing over file system for a moment。 Okay。 so think
    about this as reading from a device that doesn't have something complicated like
    a file system in it。 but rather， you know， like a raw disk or any other thing
    like that。 So this is this is handling read and remember everything looks like
    a file。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个过程略过了文件系统的部分。好，想象一下这是从一个没有复杂文件系统的设备读取数据，而是像原始磁盘或者其他类似的设备。所以，这是在处理读取操作，记住，所有东西看起来都像是一个文件。
- en: So it's read the read system call。 Once we get to the file system。 the file
    system is kind of what's in here with this， this blue kind of question mark here。
    Okay。 so the idea of the file system and the file interface kind of gets handled
    up here。 Okay。 but we'll get to that later。 So， the last thing。 Okay， good。 I
    like that comment。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是读取系统调用。一旦我们进入文件系统，文件系统就像这里的这个蓝色问号。好的，文件系统和文件接口的概念就是在这里处理的。好的，但我们稍后会讨论这一部分。最后一件事。好的，我喜欢那个评论。
- en: So there's comment in the chat。 So the OS isn't really pulling， pulling， I/O
    devices。 but kind of giving it an alert。 Yes。 What we do is we set up everything
    so that the process is。 is waiting on a weight cue for an event， which is an interrupt
    in this case from the device。 So it's sleeping on a weight cue associated with
    this device。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天中有个评论说，操作系统并没有真正轮询I/O设备，而是给它发出一个警报。是的，我们做的是设置所有东西，使得进程在等待队列上等待一个事件，这个事件在这个案例中是来自设备的中断。因此，进程在与设备相关联的等待队列中休眠。
- en: And the hardware itself will cause an interrupt that will wake that process
    up and take it off of the weight cue and put it back ready to run。 So yes， so
    the OS does not have to be polling to wait for devices in this way I've described
    it here。 Okay， so last but not least， let's push this idea that everything's a
    file even further。 So what about communication。 So， suppose that one process opens
    a file for writing and the other one opens it for reading。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件本身会引发一个中断，唤醒该进程并将其从等待队列中移除，重新置为准备运行状态。所以，是的，操作系统不需要像我在这里描述的那样轮询来等待设备。好，最后但同样重要的是，让我们将“所有事物都是文件”这一观点推得更远。那么，关于通信呢？假设一个进程打开文件进行写入，而另一个进程则以读取模式打开它。
- en: Can we communicate between processes like that？ Certainly。 Right。 We can write
    to the file here。 And this guy can read from the file and data will go through
    the file system and get transferred to the other guy。 And we've just communicated
    between two processes。 Now。 what if we only write data once and read it only once。
    So this is really like a cue。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样在进程间进行通信吗？当然可以。对吧？我们可以在这里写入文件，另一个进程可以从文件中读取，数据会通过文件系统传输给另一个进程。我们就这样在两个进程间进行了通信。现在，如果我们只写一次数据，并且只读取一次数据。这就真正像一个队列。
- en: And this is a little wasteful because we're filling up the disk with something
    that isn't going to be read again。 Right。 Because this is a cue。 And so then we
    can start thinking about a cue。 And in fact。 the typical example you like to think
    about is the network。 So a good example of that is we have cues on either side
    of the network。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点浪费，因为我们正在把数据写入磁盘，但这些数据不会再被读取，对吧？因为这就像一个队列。因此，我们可以开始考虑一个队列。事实上，你通常会想到的典型例子是网络。例如，我们在网络的两端都有队列。
- en: And we set them up and the client writes to that cue。 And it goes across the
    network into another cue on the server side and the server reads from it。 Okay，
    so these are connected cues over the Internet。 But notice the interface is still
    looks like a file。 Okay。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置好它们，客户端向队列写入数据，这些数据通过网络传输到服务器端的另一个队列，服务器从中读取。好的，这些是通过互联网连接的队列。但请注意，接口看起来仍然像一个文件。好的。
- en: we're reading and writing file descriptors。 So the question might be。 what's
    the analog of open here。 All right。 What's the name space。 How are they connected
    in time。 All of this stuff。 We're going to have to figure out。 But the simple
    idea is everything's a file。 And in fact， we can go more with this。 Right。 We
    can think of a client server on a single machine where the client issues a right
    of a request。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在读写文件描述符。所以问题可能是，这里的 open 类似物是什么？好的，名称空间是什么？它们如何在时间上连接？所有这些东西，我们得弄明白。但简单的概念是，一切都是文件。事实上，我们可以继续这样想。对吧？我们可以把一个单一机器上的客户端-服务器看作是客户端发起一个写请求。
- en: Okay， and then it waits for the response。 The server running on the same machine
    reads that request services it sends it back。 And we through a read， we wake up
    and go forward。 Okay。 so this would be fine on a single machine but voila， let's
    put the network in there。 Okay。 Now。 that sounds good。 All right， this is starting
    to look like like a web server so far。 Right。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，然后它等待响应。运行在同一台机器上的服务器读取请求，处理后发送回去。通过读取，我们唤醒并继续进行。好的，这在单台机器上是可行的，但瞧，加入网络后怎么样？好的。现在听起来不错。好，这开始看起来像是一个网页服务器了，对吧？
- en: So the socket abstraction is really this idea of a cue that goes across from
    goes across from one endpoint to another。 And those endpoints can actually span
    the network。 Okay。 So for instance。 when we have sockets on either side， there
    can actually be the network in here。 And one process opens a socket on one side。
    The other process opens on the other side。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，套接字抽象实际上是一个队列的概念，从一个终端点传递到另一个终端点。这些终端点实际上可以跨越网络。好的。例如，当我们在两侧都有套接字时，这中间其实可以包含网络。而一个进程在一端打开套接字，另一个进程在另一端打开。
- en: And we have some way of connecting the two。 And if we do that。 then we'll be
    able to write on one side and read on the other and it will just work。 Okay。 Now
    sockets are this idea of an endpoint for communication。 which are cues for temporarily
    holding results。 These cues don't have to be across the network。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有某种方式连接这两者。如果我们做到这一点，那么我们就能在一方写入，在另一方读取，它就会正常工作。好的。现在，套接字是通信的终端点的概念，它们是暂时存储结果的队列。这些队列不一定非要跨网络。
- en: They could be on the same machine。 They could be across the network。 And in
    fact， we could。 we could have the same two client server kind of sets of code。
    one of which is running at one point on the same machine and another point on
    different machines。 And we're going to talk a lot about that level of flexibility
    later in the term as well。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以在同一台机器上，也可以跨网络。实际上，我们可以……我们可以让这两个客户端-服务器代码集相同，其中一个在同一台机器上运行，而另一个在不同的机器上运行。我们稍后会深入讨论这种灵活性。
- en: So two sockets connected over the internet or over a network gives us inter
    procedural or inter process communication over the network。 Okay， and we still
    don't know how to open or what the name space is。 Okay。 And a good question in
    the chat is， well， if I go to do a read and there isn't anything there。 what happens。
    The answer is yes， it'll get put to sleep until the data comes。 Okay。 Exactly。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过互联网或网络连接的两个套接字为我们提供了网络上的进程间或进程内部的通信。好，我们还是不知道如何打开它或名称空间是什么。好的。聊天中的一个好问题是，如果我去做一个读取操作，而那边没有数据，怎么办？答案是，没问题，它会进入休眠状态，直到数据到来。好的，没错。
- en: All right。 Now， right now， this is actually。 So the question in the chat is
    how does it contrast if we were trying to do this without everything being a file。
    So， in Unix， you don't do this without everything being a file。 Okay， here in
    Unix。 this is exactly the interface。 And this， in this case， the sockets are not
    storing stuff on disk。 they're just cues that are passing from one across the
    network to the other。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，实际上，这正是如此。聊天中的问题是，如果我们尝试不通过将一切视为文件来实现，情况会如何？所以，在 Unix 中，你不能做到不把一切都视为文件。好的，在
    Unix 中，正是这样一个接口。在这种情况下，套接字并没有将内容存储到磁盘，它们只是传递数据的队列，从一端到另一端。
- en: But the interface that's right and read look exactly like the file interface
    and that's the idea that everything's a file is the interface is the same。 Okay。
    Can two processes share a socket to processes can have two ends of a socket。 Okay。
    we're going to look at different ways of communicating later。 Okay。 so more details
    so a socket's an abstraction for one endpoint of a network connection， for instance。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，写入和读取的接口看起来和文件接口完全一样，这就是一切都像文件一样的思想，接口也是相同的。好吧。两个进程能共享一个套接字吗？两个进程可以拥有套接字的两个端点。好吧。我们稍后会看不同的通信方式。好吧。更多细节，套接字是网络连接一个端点的抽象，例如。
- en: most operating systems provided， even if they don't have the rest of the Unix
    I， I， O， API。 Okay。 they were first introduced in BSD Unix。 Okay。 And 4。2 and
    what was interesting was 4。2 BSD was such a big deal。 This was in the days before
    everybody had the internet in the way that we're talking about it now that what
    happened was there were at Berkeley。 they were actually producing the 4。2 release
    the final version of it copying it on tapes。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都提供套接字功能，即使它们没有 Unix I/O API 的其他部分。好吧。它们最早是在 BSD Unix 中引入的。好吧。4.2 版本很重要的是，4.2
    BSD 是一个大事件。这是在每个人都没有像现在这样使用互联网的日子里发生的事情。当时，伯克利大学正在发布 4.2 版本的最终版本，将其复制到磁带上。
- en: And there were runners sitting at Berkeley waiting to get the tapes to run them
    back to their companies。 And， you know， and load them onto their machines。 So
    this was a really lots of excitement with 4。2 BSD sockets were just one of the
    many things there。 Okay。 And it's the same abstraction for lots of types of network，
    including no network。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当时有很多人在伯克利等着拿到磁带，将其带回公司，然后将其加载到他们的机器上。所以，4.2 BSD 版本带来了极大的兴奋，套接字只是其中的一个重要部分。好吧。它是很多类型网络的相同抽象，包括没有网络的情况。
- en: So it's local within the machine， the internet TCP IP UDP IP work with sockets。
    and even things that nobody uses anymore。 There's types of networking like OSI
    and Apple Talk and IPX and all of these things that also use sockets。 Okay。 So
    it looks just like a file with a file descriptor with read and write。 Okay。 Now。
    not all the， not all the file type calls make sense like you can't else seek on
    a socket。 Okay。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它在机器内部是本地的，互联网的 TCP、IP、UDP、IP 都与套接字配合使用。甚至是一些现在没人再使用的东西。还有像 OSI、Apple Talk
    和 IPX 等类型的网络，也都使用套接字。好吧。所以它看起来就像一个具有读写权限的文件描述符的文件。好吧。现在，不是所有的文件类型调用都能正确工作，比如你不能在套接字上执行
    seek 操作。好吧。
- en: but you can read and write to it。 And how can you use sockets to give you real
    applications？ Well。 it's a byte stream。 And the real applications typically have
    to wrap something else on top of it。 like a messaging facility or a remote procedure
    call facility that can basically serialize and encode things。 et cetera。 And we
    will， we'll spend time talking about that later in the term as well。 But for now。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以读写它。那么，如何使用套接字来实现实际应用呢？好吧，它是一个字节流。实际应用通常需要在其上封装其他内容，比如消息传递功能或远程过程调用功能，这些功能基本上可以序列化和编码数据，等等。我们将在本学期稍后时间详细讨论这个问题。但现在。
- en: we're just communicating bytes。 So here's a simple example of an echo server。
    Clients is hello world web server goes hello world。 Okay， kind of a silly one。
    Here's how it looks。 Here's the two sockets。 Let's assume they've been connected。
    So at the client， we're going to echo。 But before that happens， the server starts
    up and goes to sleep on a week on a read。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通信字节。所以这是一个简单的回显服务器示例。客户端发送 hello world，服务器回应 hello world。好吧，这是一个挺傻的例子。它是这样的。这里是两个套接字。假设它们已经连接。那么在客户端，我们要进行回显。但在那之前，服务器启动并进入等待读取状态。
- en: That's a blocking read。 The client potentially this F get S is actually getting
    a string from the user that the user is going to type hello world。 And then it
    will use that resulting buffer， write it to the socket。 It'll then go and execute
    a read， which is going to cause it to wait。 So it's waiting for the echo。 So it
    wrote the value out to the network and it's going to wait。 And meanwhile。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个阻塞读取。客户端可能通过 `fgets` 从用户那里获取一个字符串，用户会输入 hello world。然后它将使用这个结果缓冲区，写入到套接字。接着，它将执行读取操作，这将导致它等待。所以它在等待回显。它把值写入了网络，然后等待。与此同时。
- en: the data goes out from the sockets to the server side。 The server is going to
    take it。 It's going to print it on its own screen。 It's going to send it back。
    So go across the network。 it'll wake up the client and voila， we've just echoed
    and then we will repeat on both sides。 Okay。 Now， good question。 It's a string
    guaranteed to come back in chunks， all at once or in chunks。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从套接字发送到服务器端。服务器会接收它，打印到自己的屏幕上，然后发送回去。数据通过网络传输，唤醒客户端，然后，哇，我们刚刚进行了回显，然后双方都会重复这一过程。好的，现在，问题来了。字符串是否保证一次性返回，还是会分块返回？
- en: In fact， it's not guaranteed to come back all at once。 And so you actually have
    to execute read multiple times potentially to look for that null at the end。 Good
    question。 So here's a fairly simple， really quick set of code。 I'm assuming the
    sockets are already open because I haven't shown you how to do that yet。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它并不保证一次性返回。因此，实际上你可能需要执行多次读取，来寻找末尾的空值。好问题。那么这里有一段相对简单、快速的代码。我假设套接字已经打开，因为我还没向你展示如何做到这一点。
- en: But here we have the right on one side and the read on the other and notice
    I'm not checking in a loop like I should with read。 That's a good question。 But
    then I take the result and assuming there are no errors。 I write it back and I
    get my echo。 Okay， echo echo echo。 So what assumptions are we making here we're
    assuming it's reliable。 So when you write to it。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们有一边的写入和另一边的读取，注意我没有像应该做的那样在循环中检查读取操作。这是一个好问题。但接着，我会获取结果，假设没有错误发生。我将它写回去，然后得到我的回显。好了，回显回显回显。那么我们在这里做了什么假设呢？我们假设它是可靠的。所以当你写入它时。
- en: you get it back。 And so there's nothing lost。 And so that's a special type of
    socket。 We need to set up a TCP socket to the other side。 We're assuming everything's
    in order so that gets helped by a TCP socket as well。 And when are things ready？
    Well， we're going to rely on read going to sleep。 If there's no bytes ready。 So
    how do we create sockets。 Well。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你会把它拿回来。所以没有丢失任何内容。这是一种特殊类型的套接字。我们需要设置一个TCP套接字与另一方连接。我们假设一切正常，所以这也得到了TCP套接字的帮助。那么什么时候准备好呢？我们将依赖于读取操作去休眠。如果没有字节准备好。那么我们怎么创建套接字呢？嗯。
- en: file systems basically provide a collection of permanent objects。 And， you know。
    so it's easy to open a file。 But sockets are a little funny， right？
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统基本上提供了一组永久性的对象。而且，你知道，打开文件是很容易的。但是套接字有点奇怪，对吧？
- en: So it's a two way communication between processes on completely different machines。
    So we have to have some way to rendezvous between our desire to make a connection
    and somebody's remote desire to provide service。 And so that's going to be a question
    of how do we name the objects were opening。 And how do these completely independent
    programs know that the other one wants to talk to them。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是两个完全不同机器上的进程之间的双向通信。所以我们必须有某种方式在我们想要建立连接的愿望和某个远程提供服务的愿望之间进行对接。所以问题就变成了，我们如何命名我们正在打开的对象。以及这些完全独立的程序如何知道另一个程序想要与它们通信。
- en: Okay， and I'm going to finish this up but let's just keep in mind。 What is the
    namespace here。 And we have file systems。 The namespace is just the set of all
    possible path names right。 In the case of communicating over the network the day
    space is something like host names or IP addresses。 And also port numbers so given
    IP address represents a machine。 So port number represents a service。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我将完成这部分内容，但让我们先保持思考。这里的命名空间是什么？我们有文件系统，命名空间就是所有可能路径名的集合，对吧？在网络通信的情况下，命名空间就像是主机名或IP地址。还有端口号，所以给定的IP地址代表一台机器，而端口号则代表一个服务。
- en: Okay， and well， so typically if you're connecting to somebody you're actually
    connecting to a combination of the IP address and port。 All right， and so this
    is the last thing we're going to talk about today。 Bear with me for two slides。
    So here's how we actually set up a socket。 And the server side starts by creating
    what's called a server socket。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，通常，如果你连接到某个人，实际上是连接到IP地址和端口的组合。好吧，今天我们要讨论的最后一件事就是这个。请再忍耐我两张幻灯片。那么我们实际是如何设置套接字的呢？服务器端通过创建一个所谓的服务器套接字来开始。
- en: And that server socket executes a listen。 And that listens as I'm listening
    for somebody who wants to connect it my IP address with this port that everybody
    knows about。 Could be the echo port。 It could be the web server port。 Okay。 later
    the client does a connection request saying hi here's my address here's a port
    I've got。 I'd like to connect。 If the circuit the server socket accepts。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后那个服务器套接字执行了一个监听。这个监听的作用是，我在等待有谁想要连接到我的IP地址和大家都知道的这个端口上。可能是回声端口，也可能是Web服务器端口。好的，稍后客户端发起连接请求，说“你好，这是我的地址，这是我有的端口。我想连接。”如果服务器套接字接受了连接请求。
- en: then it makes a brand new socket with a connection。 Okay。 so basically that
    connection is now a set of connected sockets。 And that's the green ones。 And that
    yellow connection is actually defined uniquely by a five tuple。 What is that five
    tuple the source IP address， the destination IP address。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它创建了一个全新的套接字并建立了连接。好的，基本上那个连接现在是一组连接的套接字。这些是绿色的套接字。那个黄色的连接实际上是通过五元组来唯一定义的。这个五元组包括源IP地址、目标IP地址。
- en: the source port number the destination port number， and the， protocol which
    in this case is TCP。 Okay， the client port which is needed for uniqueness is often
    randomly chosen。 And that port which is well known is typically something like
    80 for the web or 443， etc。 Okay。 All right， so we need to finish。 So in conclusion
    the system call interface is a narrow waste between user programs in the kernel。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 源端口号、目标端口号和协议，在这个情况下是TCP。好的，客户端端口号为了确保唯一性，通常是随机选择的。而那个知名的端口通常是80（Web端口）或者443等。好的，那么，我们需要结束了。总的来说，系统调用接口是用户程序与内核之间的一个狭窄接口。
- en: Streaming IO is a stream of bytes。 Most of the streaming functions start with
    F like F3。 And we have a little bit of a level IO which is the actual kernel interface。
    Okay， system calls。 We talked about composition。 We talked about what the device
    drivers are and how they work。 And the file abstraction is basically used for
    everything。 Okay。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 流式输入输出（Streaming IO）是一系列字节。大多数流式函数以F开头，比如F3。我们还有一种稍微底层的输入输出，它是真正的内核接口。好的，系统调用。我们讨论了组合方式，讨论了设备驱动程序是什么以及它们是如何工作的。而文件抽象基本上用于所有的内容。好的。
- en: and then we finally finished up with sockets which will pick up next time。 Sorry，
    I went over。 I hope you all have a good evening。 And we will see you later。 Ciao。
    [ Silence ]。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们终于完成了关于套接字的内容，下次我们会继续讲解。抱歉，我讲得有点超时了。希望大家度过一个愉快的晚上，我们下次见。再见。[沉默]。
- en: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_33.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c0e1f5f8864879bc09f46bc086ef0_33.png)'
