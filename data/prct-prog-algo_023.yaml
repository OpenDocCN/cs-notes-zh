- en: 4.4   Symbol Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4   符号表
- en: 原文：[https://introcs.cs.princeton.edu/java/44st](https://introcs.cs.princeton.edu/java/44st)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/44st](https://introcs.cs.princeton.edu/java/44st)
- en: A *symbol table* is a data type that we use to associate *values* with *keys*.
    Clients can store (*put*) an entry into the symbol table by specifying a key–value
    pair and then can retrieve (*get*) the value corresponding to a particular key.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号表*是一种数据类型，我们用它来将*值*与*键*关联起来。客户端可以通过指定键-值对将条目存储（*put*）到符号表中，然后可以检索（*get*）与特定键对应的值。'
- en: API.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API。
- en: A symbol table is a collection of key–value pairs. We use a generic type `Key`
    for keys and a generic type `Value` for values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表是一组键-值对。我们为键使用通用类型`Key`，为值使用通用类型`Value`。
- en: '![symbol table API](../Images/f9009b8b51c7b2a10271364260c5b365.png)'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![符号表API](../Images/f9009b8b51c7b2a10271364260c5b365.png)'
- en: 'This API reflects several design decisions:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此API反映了几个设计决策：
- en: '*Immutable keys.* We assume the keys do not change their values while in the
    symbol table.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变键。* 我们假设键在符号表中不会改变其值。'
- en: '*Replace-the-old-value policy.* If a key–value pair is inserted into the symbol
    table that already associates another value with the given key, we adopt the convention
    that the new value replaces the old one.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*替换旧值策略。* 如果将一个已经将另一个值与给定键关联的键-值对插入符号表中，我们采用新值替换旧值的约定。'
- en: '*Not found.* The method `get()` returns `null` if no value is associated with
    the specified key.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未找到。* 如果指定的键没有关联的值，则方法`get()`返回`null`。'
- en: '*Null keys and null values.* Clients are not permitted to use `null` as either
    a key or value. This convention enables us to implement `contains()` as follows:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*空键和空值。* 客户端不允许使用`null`作为键或值。这个约定使我们能够实现`contains()`如下：'
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Remove.* We also include in the API a method for removing a key (and its associated
    value) from the symbol table because many applications require such a method.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除。* 我们还在API中包含了一个方法，用于从符号表中移除一个键（及其关联的值），因为许多应用程序需要这样的方法。'
- en: '*Iterating over key–value pairs.* The `keys()` method provides clients with
    a way to iterate over the key–value pairs in the data structure.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遍历键-值对。* `keys()`方法为客户端提供了一种遍历数据结构中键-值对的方法。'
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Hashable keys.* Java includes direct language and system support for symbol-table
    implementations. Every class inherits an `equals()` method (which we can use to
    test whether two keys are the same) and a `hashCode()` method (which we will examine
    later).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可哈希键。* Java包括对符号表实现的直接语言和系统支持。每个类都继承了一个`equals()`方法（我们可以用它来测试两个键是否相同）和一个`hashCode()`方法（稍后我们将对其进行检查）。'
- en: '*Comparable keys.* In many applications, the keys have a natural order and
    implement the `Comparable` interface. When this is the case, we can support a
    whole host of new operations.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可比较键。* 在许多应用程序中，键具有自然顺序并实现了`Comparable`接口。在这种情况下，我们可以支持一系列新操作。'
- en: '![ordered symbol table operations](../Images/44d40051f838054e19c37bbcf635e784.png)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![有序符号表操作](../Images/44d40051f838054e19c37bbcf635e784.png)'
- en: The most commonly used key types are `String` and `Integer`, which are immutable,
    hashable, and comparable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的键类型是`String`和`Integer`，它们是不可变的、可哈希的和可比较的。
- en: Symbol table clients.
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号表客户端。
- en: We consider two prototypical examples. Both rely on our reference symbol-table
    implementation [ST.java](ST.java.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了两个典型示例。两者都依赖于我们的参考符号表实现[ST.java](ST.java.html)。
- en: '*Dictionary lookup.* The most basic kind of symbol-table client builds a symbol
    table with successive *put* operations to support *get* requests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字典查找。* 最基本的符号表客户端通过连续的*put*操作构建一个符号表，以支持*get*请求。'
- en: '![dictionary applications](../Images/db828b9739a130b844dc7fa3a0d4a0ec.png)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![字典应用](../Images/db828b9739a130b844dc7fa3a0d4a0ec.png)'
- en: '[Lookup.java](Lookup.java.html) builds a set of key–value pairs from a file
    of comma-separated values and then prints values corresponding to keys read from
    standard input. The command-line arguments are the file name and two integers,
    one specifying the field to serve as the key and the other specifying the field
    to serve as the value.'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Lookup.java](Lookup.java.html)从逗号分隔值文件构建一个键-值对集合，然后打印与从标准输入读取的键对应的值。命令行参数是文件名和两个整数，一个指定用作键的字段，另一个指定用作值的字段。'
- en: '*Indexing.* [Index.java](Index.java.html) is a prototypical example of a symbol
    table client that uses an *intermixed* sequence of calls to `get()` and `put()`:
    it reads in a sequence of strings from standard input and prints a sorted list
    of integers specifying the positions where each string appeared in the input.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*索引。* [Index.java](Index.java.html)是一个符号表客户端的典型示例，它使用`get()`和`put()`的交错调用序列：它从标准输入读取一系列字符串，并打印一个排序的整数列表，指定每个字符串在输入中出现的位置。'
- en: '![indexing applications](../Images/4feab3c032a5a577377f73a85175773d.png)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![索引应用](../Images/4feab3c032a5a577377f73a85175773d.png)'
- en: Elementary implementations.
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本实现。
- en: 'We briefly consider two elementary implementations, based on two basic data
    structures that we have encountered: resizing arrays and linked lists.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要考虑了两种基本实现，基于我们遇到的两种基本数据结构：调整大小的数组和链表。
- en: '*Sequential search.* Perhaps the simplest implementation is to store the key–value
    pairs in an unordered linked list (or array) and use *sequential search*. When
    searching for a key, we examine each node (or element) in sequence until either
    we find the specified key or we exhaust the list (or array). [SequentialSearchST.java](SequentialSearchST.java.html)
    implements a symbol table using this strategy.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顺��搜索。* 也许最简单的实现是将键-值对存储在无序链表（或数组）中，并使用*顺序搜索*。在搜索键时，我们按顺序检查每个节点（或元素），直到找到指定的键或耗尽列表（或数组）。[SequentialSearchST.java](SequentialSearchST.java.html)使用这种策略实现了一个符号表。'
- en: '![unordered linked list symbol-table](../Images/4d65fa096137876f92e7849c250d9447.png)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![无序链表符号表](../Images/4d65fa096137876f92e7849c250d9447.png)'
- en: Such an implementation is not feasible for use by typical clients because, for
    example, *get* takes linear time when the search key is not in the symbol table.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样的实现对于典型客户端的使用是不可行的，例如，当搜索键不在符号表中时，*获取*需要线性时间。
- en: '![sorted array symbol-table](../Images/535f417cc993c719c4f6a9b4d37daff6.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![排序数组符号表](../Images/535f417cc993c719c4f6a9b4d37daff6.png)'
- en: '*Binary search.* Alternatively, we might use a sorted (resizing) array for
    the keys and a parallel array for the values. Since the keys are in sorted order,
    we can search for a key (and its associated value) using *binary search*. [BinarySearchST.java](BinarySearchST.java.html)
    implements a symbol table using this strategy.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二分查找。* 或者，我们可以使用一个排序（可调整大小）数组来存储键，以及一个并行数组来存储值。由于键是按排序顺序排列的，我们可以使用*二分查找*来搜索键（及其相关值）。[BinarySearchST.java](BinarySearchST.java.html)使用这种策略实现了符号表。'
- en: The *get* operation is fast (logarithmic), but the *put* operation typically
    takes linear time because each time a new key is inserted, larger keys must be
    shifted one position higher in the array.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*获取*操作很快（对数级），但*插入*操作通常需要线性时间，因为每次插入新键时，较大的键必须向数组中的更高位置移动一个位置。'
- en: 'To implement a symbol table that is feasible for use with clients such as `Lookup`
    and `Index`, we need a data structure that is more flexible than either linked
    lists or resizing arrays. Next, we consider two examples of such data structures:
    the hash table and the binary search tree.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个符号表，以便与`Lookup`和`Index`等客户端一起使用，我们需要一种比链表或调整大小数组更灵活的数据结构。接下来，我们考虑两个这样的数据结构的示例：哈希表和二叉搜索树。
- en: Hash tables.
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希表。
- en: A *hash table* is a data structure in which we use a *hash function* to divide
    the keys into *m* groups, which we expect to be able equal in size. For each group,
    we keep the keys in an unordered linked list and use sequential search.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希表*是一种数据结构，我们使用*哈希函数*将键分成*m*组，我们期望每组的大小相等。对于每组，我们将键保存在一个无序链表中，并使用顺序搜索。'
- en: '*Representation.* We maintain an array of *m* linked lists, with element *i*
    containing a linked list of all keys whose hash value is *i* (along with their
    associated values).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表示。* 我们维护一个包含*m*个链表的数组，其中第*i*个元素包含所有哈希值为*i*的键的链表（以及它们的相关值）。'
- en: '![](../Images/462c9ae3106193b6e91ebe8b89b64a26.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/462c9ae3106193b6e91ebe8b89b64a26.png)'
- en: '*Hash functions.* As we saw in Section 3.3, every Java class has a `hashCode()`
    method that maps objects to integers. We use the *hash function*'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希函数。* 正如我们在第3.3节中看到的，每个Java类都有一个`hashCode()`方法，将对象映射到整数。我们使用*哈希函数*'
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'to convert the *hash code* into a *hash value* between 0 and *m*−1. Here are
    the hash codes and hash values for *n* = 12 strings when *m* = 5:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将*哈希码*转换为0到*m*−1之间的*哈希值*。以下是当*m*=5时，*n*=12个字符串的哈希码和哈希值：
- en: '![](../Images/c3a041f3144db252e99fdfffc3378787.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/c3a041f3144db252e99fdfffc3378787.png)'
- en: '*Search.* To search for a key:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索。* 要搜索键：'
- en: Compute its hash value to identify its linked list.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算其哈希值以识别其链表。
- en: Iterate over the nodes in that linked list, checking for the search key.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历该链表中的节点，检查搜索键。
- en: If the search key is in the linked list, return the associated value; otherwise,
    return null.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果搜索键在链表中，则返回相关值；否则返回null。
- en: '*Insert.* To insert a key–value pair:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入。* 要插入键-值对：'
- en: Compute the hash value of the key to identify its linked list.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算键的哈希值以识别其链表。
- en: Iterate over the nodes in that linked list, checking for the key.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历该链表中的节点，检查键。
- en: If the key is in the linked list, replace the value currently associated with
    the key with the new value; otherwise, create a new node with the specified key
    and value and insert it at the beginning of the linked list.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键在链表中，则用新值替换当前与键关联的值；否则，创建一个具有指定键和值的新节点，并将其插入到链表的开头。
- en: '*Implementation.* [HashST.java](HashST.java.html) is a full implementation.
    It uses a resizing array to ensure that the average number of keys per linked
    list is between 1 and 8.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现。* [HashST.java](HashST.java.html)是一个完整的实现。它使用调整大小数组来确保每个链表中的平均键数在1和8之间。'
- en: '*Analysis of running time.* Assuming the hash function reasonably distributes
    the keys, [HashST.java](HashST.java.html) achieves constant (amortized) time performance
    for both *put* and *get*.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时间分析。* 假设哈希函数合理地分布键，[HashST.java](HashST.java.html)实现了*插入*和*获取*的常数（摊销）时间性能。'
- en: Binary search trees.
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树。
- en: 'A binary tree is defined recursively: it is either empty (null) or a node containing
    links to two disjoint binary trees. We refer to the node at the top as the *root*
    of the tree, the node referenced by its left link as the *left subtree*, and the
    node referenced by its right link as the *right subtree*. Nodes whose links are
    both null are called *leaf nodes*. The *height* of a tree is the maximum number
    of links on any path from the root node to a leaf node.![binary tree](../Images/f82825a6f8e40f772d403f292553a97d.png)
                   ![binary search tree](../Images/f821a0559a4be823b3aa14b37cbc30a2.png)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是递归定义的：它要么为空（null），要么是一个包含指向两个不同二叉树的链接的节点。我们将顶部的节点称为树的*根*，由其左链接引用的节点称为*左子树*，由其右链接引用的节点称为*右子树*。链接都为null的节点称为*叶节点*。树的*高度*是从根节点到叶节点的任意路径上的链接数的最大值。![二叉树](../Images/f82825a6f8e40f772d403f292553a97d.png)
                   ![二叉搜索树](../Images/f821a0559a4be823b3aa14b37cbc30a2.png)
- en: 'A *binary search tree* is a binary tree that contains a key–value pair in each
    node and for which the keys are in *symmetric order*: The key in a node is larger
    than the key of every node in its left subtree and smaller than the key of every
    node in its right subtree.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉搜索树*是一种二叉树，每个节点包含一个键-值对，并且键处于*对称顺序*：节点中的键大于其左子树中每个节点的键，小于其右子树中每个节点的键。'
- en: '*Representation.* To implement BSTs, we start with a class for the node abstraction,
    which has references to a key, a value, and left and right BSTs. The key type
    must be comparable (to specify an ordering of the keys) but the value type is
    arbitrary.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表示.* 要实现BST，我们从节点抽象的类开始，该类具有对键、值和左右BST的引用。键类型必须是可比较的（以指定键的排序），但值类型是任意的。'
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![BST representation](../Images/1dde64ed6b0abbdac5af3249a18b7140.png)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![BST表示](../Images/1dde64ed6b0abbdac5af3249a18b7140.png)'
- en: '*Search.* Suppose that you want to *search* for a node with a given key in
    a BST. A recursive algorithm is immediately evident:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索.* 假设您想在BST中*搜索*具有给定键的节点。递归算法立即显而易见：'
- en: If the tree is empty, terminate the search as unsuccessful.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果树为空，则以失败结束搜索。
- en: If the search key is equal to the key in the node, terminate the search as successful
    (by returning the value associated with the key).
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果搜索键等于节点中的键，则以成功结束搜索（通过返回与键关联的值）。
- en: If the search key is smaller than the key in the node, search (recursively)
    in the left subtree.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果搜索键小于节点中的键，则在左子树中搜索（递归）。
- en: If the search key is greater than the key in the node, search (recursively)
    in the right subtree.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果搜索键大于节点中的键，则在右子树中搜索（递归）。
- en: '![search in a BST](../Images/0abcc82cda8e3d0f7c50d2ac03767507.png)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![在BST中搜索](../Images/0abcc82cda8e3d0f7c50d2ac03767507.png)'
- en: '*Insert.* Suppose that you want to insert a new node into a BST. The logic
    is similar to searching for a key, but the implementation is trickier. The key
    to understanding it is to realize that only one link must be changed to point
    to the new node, and that link is precisely the link that would be found to be
    null in an unsuccessful search for that key.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入.* 假设您想将新节点插入BST中。逻辑与搜索键类似，但实现更加棘手。理解它的关键是意识到只需更改一个链接以指向新节点，并且该链接恰好是在对该键进行不成功搜索时发现为null的链接。'
- en: '![inserting into a BST](../Images/bbb7e74ba12c34d5e2bfc32d0951b57e.png)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![插入到BST中](../Images/bbb7e74ba12c34d5e2bfc32d0951b57e.png)'
- en: '*Implementation.* [BST.java](BST.java.html) is a full symbol-table implementation
    based on these two recursive algorithms.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现.* [BST.java](BST.java.html)是基于这两个递归算法的完整符号表实现。'
- en: Performance characteristics of BST.
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BST的性能特征。
- en: The running times of algorithms on BSTs are ultimately dependent on the shape
    of the trees, and the shape of the trees is dependent on the order in which the
    keys are inserted.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在BST上的运行时间最终取决于树的形状，而树的形状取决于键的插入顺序。
- en: '*Best case.* In the best case, the tree is perfectly balanced (each node has
    exactly two non-null children), with about lg *n* links between the root and each
    leaf node. In such a tree, the cost of every *put* operation and *get* request
    is proportional to lg *n* or less.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳情况.* 在最佳情况下，树是完美平衡的（每个节点恰好有两个非空子节点），根节点和每个叶节点之间大约有lg *n*个链接。在这样的树中，每个*put*操作和*get*请求的成本与lg
    *n*或更少成正比。'
- en: '![best case binary search tree](../Images/02e8ae0bdb2d467383237b2889499243.png)'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![最佳情况二叉搜索树](../Images/02e8ae0bdb2d467383237b2889499243.png)'
- en: '*Average case.* A classic mathematical derivation shows that the expected number
    of key compares is ~ 2 ln *n* for a random *put* or *get* in a tree built from
    *n* randomly ordered keys.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平均情况.* 经典的数学推导表明，在从*n*个随机排序的键构建的树中，对于随机*put*或*get*，预期的关键比较次数约为~ 2 ln *n*。'
- en: '![average case binary search tree](../Images/cf2e910c407b68c2f1c46a8379e106be.png)'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![平均情况二叉搜索树](../Images/cf2e910c407b68c2f1c46a8379e106be.png)'
- en: '*Worst case.* In the worst case, each node (except one) has exactly one null
    link, so the BST is essentially a linked list with an extra wasted link, where
    where *put* operations and *get* requests take linear time. Unfortunately this
    worst case is not rare in practice—it arises, for example, when we insert the
    keys in order.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最坏情况.* 在最坏情况下，每个节点（除一个外）都有一个空链接，因此BST本质上是一个带有额外浪费链接的链表，其中*put*操作和*get*请求需要线性时间。不幸的是，这种最坏情况在实践中并不罕见——例如，当我们按顺序插入键时就会出现。'
- en: '![worst case binary search tree](../Images/e7398439b295fa58687e3b1a2ccb1bf1.png)
                ![worst case binary search tree](../Images/c7ffcbb398273ce1ca2ecc005dde94d3.png)
                ![worst case binary search tree](../Images/bc7ed2ec0cc24fc2e2ef76cbddf4c2f8.png)'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![最坏情况二叉搜索树](../Images/e7398439b295fa58687e3b1a2ccb1bf1.png)             ![最坏情况二叉搜索树](../Images/c7ffcbb398273ce1ca2ecc005dde94d3.png)
                ![最坏情况二叉搜索树](../Images/bc7ed2ec0cc24fc2e2ef76cbddf4c2f8.png)'
- en: '*Red–black trees.* Remarkably, there are BST variants that eliminate this worst
    case and guarantee logarithmic performance per operation. balanced. One popular
    variant is known as a *red–black tree*.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*红黑树.* 令人惊讶的是，有BST变体可以消除这种最坏情况，并保证每次操作的对数性能。平衡。一种流行的变体称为*红黑树*。'
- en: Traversing a BST.
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历BST。
- en: 'Perhaps the most basic tree-processing function is known as *tree traversal*:
    given a (reference to) a tree, we want to systematically process every node in
    the tree. For linked lists, we accomplish this task by following the single link
    to move from one node to the next. For trees, however, we have decisions to make,
    because there are *two* links to follow. Recursion comes immediately to the rescue.
    To process every node in a BST:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最基本的树处理函数被称为*树遍历*：给定一个（对）树，我们希望系统地处理树中的每个节点。对于链表，我们通过跟随单个链接来从一个节点移动到下一个节点来完成此任务。然而，对于树，我们需要做出决策，因为有*两个*链接要跟随。递归立即提供帮助。要处理BST中的每个节点：
- en: Process every node in the left subtree.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理左子树中的每个节点。
- en: Process the node at the root.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理根节点。
- en: Process every node in the right subtree.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理右子树中的每个节点。
- en: 'This approach is known as *inorder* tree traversal because it processes the
    nodes in a BST in *key-sorted order*. The following method prints the keys in
    the BST rooted at its argument in ascending order:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为*中序*树遍历，因为它按*键排序顺序*处理BST中的节点。以下方法按升序打印其参数根节点的BST中的键：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![inorder traversal of a BST](../Images/b7eff8361bd6b8f2420aa2bf082cfb57.png)
    This code serves as the basis for the `keys()` method in [BST.java](BST.java.html),
    which returns all keys in the symbol table, as an iterable.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![二叉搜索树的中序遍历](../Images/b7eff8361bd6b8f2420aa2bf082cfb57.png) 这段代码作为[BST.java](BST.java.html)中`keys()`方法的基础，该方法返回符号表中的所有键，作为一个可迭代对象。'
- en: Ordered symbol table operations.
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有序符号表操作。
- en: The flexibility of BSTs and the ability to compare keys enable the implementation
    of many useful additional operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的灵活性和比较键的能力使得可以实现许多有用的额外操作。
- en: '*Minimum and maximum.* To find the smallest key in a BST, follow the left links
    from the root until `null` is reached. The last key encountered is the smallest
    in the BST. The same procedure, albeit following the right links, leads to the
    largest key in the BST.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最小值和最大值.* 要找到二叉搜索树中最小的键，从根节点开始沿着左链接直到达到`null`。最后遇到的键是二叉搜索树中最小的。同样的过程，尽管是沿着右链接，会导致二叉搜索树中最大的键。'
- en: '*Size and subtree size.* To keep track of the number of nodes in a BST, keep
    an extra instance variable `n` in [BST.java](BST.java.html) that counts the number
    of nodes in the tree. Alternatively, keep an extra instance variable *size* in
    each `Node` that counts the number of nodes in the subtree rooted at each node.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大小和子树大小.* 要跟踪二叉搜索树中节点的数量，[BST.java](BST.java.html)中保持一个额外的实例变量`n`，用于计算树中节点的数量。或者，保持每个`Node`中一个额外的实例变量*size*，用于计算每个节点根节点的子树中节点的数量。'
- en: '*Range search and range count.* With a recursive method like `traverse()`,
    we can return an iterable for the keys falling between two given values. If we
    maintain an instance variable each node having the size of the subtree root at
    each node, we can *count* the number of keys falling between two given values
    in time proportional to the height of the BST.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*范围搜索和范围计数.* 使用像`traverse()`这样的递归方法，我们可以返回两个给定值之间的键的可迭代对象。如果我们在每个节点中维护一个实例变量，表示每个节点根节点的子树的大小，我们可以在时间上与二叉搜索树的高度成正比地*计算*两个给定值之间的键的数量。'
- en: '*Order statistics and ranks.* If we maintain an instance variable in each node
    having the size of the subtree rooted at each node, we can implement a recursive
    method that returns the *k*th smallest key in time proportional to the height
    of the BST. Similarly, we can compute the *rank* of a key, which is the number
    of keys in the BST that are strictly smaller than the key.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顺序统计和排名.* 如果我们在每个节点中维护一个实例变量，表示每个节点根节点的子树的大小，我们可以实现一个递归方法，在时间上与二叉搜索树的高度成正比，返回第*k*小的键。同样地，我们可以计算一个键的*排名*，即二叉搜索树中严格小于该键的键的数量。'
- en: The reference implementation [ST.java](ST.java.html) implements our [ordered
    symbol-table API](http://introcs.cs.princeton.edu/java/code/javadoc/ST.html) for
    comparable keys. It delegates operations to [java.util.TreeMap](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html),
    a symbol-table implementation based on red–black trees.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 参考实现[ST.java](ST.java.html)实现了我们的[有序符号表API](http://introcs.cs.princeton.edu/java/code/javadoc/ST.html)用于可比较的键。它将操作委托给[java.util.TreeMap](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html)，这是一个基于红黑树的符号表实现。
- en: Set data type.
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合数据类型。
- en: 'A *set* is a collection of distinct keys, like a symbol table with no values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一个包含不同键的集合，就像一个没有值的符号表：'
- en: '![set API](../Images/c267ecb8c855ea786255e5dce56d32f4.png)'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![设置API](../Images/c267ecb8c855ea786255e5dce56d32f4.png)'
- en: The reference implementation [SET.java](SET.java.html) implements our [ordered
    SET API](http://introcs.cs.princeton.edu/java/code/javadoc/SET.html) for comparable
    keys. [DeDup.java](DeDup.java.html) is a client that reads a sequence of strings
    from standard input and prints the first occurrence of each string (thereby removing
    duplicates).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 参考实现[SET.java](SET.java.html)实现了我们的[有序SET API](http://introcs.cs.princeton.edu/java/code/javadoc/SET.html)用于可比较的键。[DeDup.java](DeDup.java.html)是一个客户端，从标准输入读取一系列字符串并打印每个字符串的第一次出现（从而删除重复项）。
- en: Exercises
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Develop an implementation [BinarySearchST.java](BinarySearchST.java.html) of
    the symbol-table API that maintains parallel arrays of keys and values, keeping
    them in key-sorted order. Use binary search for *get* and move larger key–value
    pairs to the right one position for *put* (use a resizing array to keep the array
    length proportional to the number of key–value pairs in the table). Test your
    implementation with [Index.java](Index.java.html), and validate the hypothesis
    that using such an implementation for `Index` takes time proportional to the product
    of the number of strings and the number of distinct strings in the input.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个实现[BinarySearchST.java](BinarySearchST.java.html)的符号表API，该API维护键和值的并行数组，保持它们按键排序的顺序。使用二分查找进行*get*操作，并将较大的键-值对移动到右边一个位置进行*put*操作（使用调整大小的数��以保持数组长度与表中键-值对数量成正比）。使用[Index.java](Index.java.html)测试你的实现，并验证使用这样的实现对`Index`进行操作所需的时间与输入中字符串数量和不同字符串数量的乘积成正比的假设。
- en: Develop an implementation [SequentialSearchST.java](SequentialSearchST.java.html)
    of the symbol-table API that maintains a linked list of nodes containing keys
    and values, keeping them in arbitrary order. Test your implementation with [Index.java](Index.java.html),
    and validate the hypothesis that using such an implementation for `Index` takes
    time proportional to the the product of the number of strings and the number of
    distinct strings in the input.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个实现[SequentialSearchST.java](SequentialSearchST.java.html)的符号表API，该API维护一个包含键和值的节点链表，保持它们的任意顺序。使用[Index.java](Index.java.html)测试你的实现，并验证使用这样的实现对`Index`进行操作所需的时间与输入中字符串数量和不同字符串数量的乘积成正比的假设。
- en: Implement the method `contains()` for [HashST.java](HashST.java.html).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[HashST.java](HashST.java.html)实现`contains()`方法。
- en: Implement the method `size()` for [HashST.java](HashST.java.html).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[HashST.java](HashST.java.html)实现`size()`方法。
- en: Implement the method `keys()` for [HashST.java](HashST.java.html).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[HashST.java](HashST.java.html)实现`keys()`方法。
- en: Modify [HashST.java](HashST.java.html) to add a method `remove()` that takes
    `Key` argument and removes that key (and the corresponding value) from the symbol
    table, if it exists.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[HashST.java](HashST.java.html)，添加一个名为`remove()`的方法，接受`Key`参数，并从符号表中删除该键（以及相应的值），如果存在的话。
- en: Modify [HashST.java](HashST.java.html) to use a resizing array so that the average
    length of the list associated with each hash value is between 1 and 8.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[HashST.java](HashST.java.html)，使用调整大小的数组，使得与每个哈希值关联的列表的平均长度在1和8之间。
- en: True or false. Given a BST, let *x* be a leaf node, and let *p* be its parent.
    Then either (1) the key of *p* is the smallest key in the BST larger than the
    key of *x* or (2) the key of *p* is the largest key in the BST smaller than the
    key of *x*.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假。给定一个BST，让*x*为叶节点，*p*为其父节点。那么要么（1）*p*的键是大于*x*的键且在BST中最小的键，要么（2）*p*的键是小于*x*的键且在BST中最大的键。
- en: '*Solution*: true.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：真。'
- en: Modify [BST.java](BST.java.html) to add methods `min()` and `max()` that return
    the smallest (or largest) key in the table (or `null` if no such key exists).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[BST.java](BST.java.html)，添加方法`min()`和`max()`，返回表中最小（或最大）的键（如果不存在这样的键，则返回`null`）。
- en: Modify [BST.java](BST.java.html) to add methods `floor()` and `ceiling()` that
    take as argument a key and return the largest (smallest) key in the symbol table
    that is no larger (no smaller) than the specified key (or `null` if no such key
    exists).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[BST.java](BST.java.html)，添加方法`floor()`和`ceiling()`，以键作为参数，返回符号表中不大于（不小于）指定键的最大（最小）键（如果不存在这样的键，则返回`null`）。
- en: Modify [BST.java](BST.java.html) a method `size()` that returns the number of
    key–value pairs in the symbol table. Use the approach of storing within each `Node`
    the number of nodes in the subtree rooted there.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[BST.java](BST.java.html)，添加一个返回符号表中键值对数量的方法`size()`。使用在每个`Node`中存储根节点的子树中节点数量的方法。
- en: Modify [BST.java](BST.java.html) to add a method `rangeSearch()` that takes
    two keys as arguments and returns an iterable over all keys that are between the
    two given keys. The running time should be proportional to the height of the tree
    plus the number of keys in the range.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[BST.java](BST.java.html)，添加一个名为`rangeSearch()`的方法，以两个键作为参数，并返回介于两个给定键之间的所有键的可迭代对象。运行时间应与树的高度和范围内键的数量成比例。
- en: 'Modify [BST.java](BST.java.html) to add a method `rangeCount()` that takes
    two keys as arguments and returns the number of keys in the BST between the two
    specified keys. Your method should take time proportional to the height of the
    tree. *Hint*: First work the previous exercise.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[BST.java](BST.java.html)，添加一个名为`rangeCount()`的方法，以两个键作为参数，并返回BST中介于两个指定键之间的键的数量。您的方法应该花费与树的高度成比例的时间。*提示*：先完成前一个练习。
- en: Write an [ST.java](ST.java.html) client [GPA.java](GPA.java.html) that creates
    a symbol table mapping letter grades to numerical scores, as in the table below,
    and then reads from standard input a list of letter grades and computes their
    average (GPA).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个[ST.java](ST.java.html)客户端[GPA.java](GPA.java.html)，创建一个符号表，将字母等级映射到数字分数，如下表所示，然后从标准输入读取字母等级列表并计算它们的平均值（GPA）。
- en: '[PRE5]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Binary Tree Exercises
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二叉树练习
- en: '*This list of exercises is intended to give you experience in working with
    binary trees that are not necessarily BSTs. They all assume a `Node` class with
    three instance variables: a positive `double` value and two `Node` references.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个练习列表旨在让您体验与不一定是BST的二叉树一起工作。它们都假设有一个`Node`类，其中包含三个实例变量：一个正的`double`值和两个`Node`引用。*'
- en: Two binary trees are *isomorphic* if only their key values differ (they have
    the same shape). Implement a linear-time static method `isomorphic()` that takes
    two tree references as arguments and returns `true` if they refer to isomorphic
    trees, and `false` otherwise. Then implement a linear-time static method `eq()`
    that takes two tree references as arguments and returns `true` if they refer to
    identical trees (isomorphic with same key values), and `false` otherwise.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个二叉树只有键值不同（它们具有相同的形状），则它们是*同构*的。实现一个线性时间的静态方法`isomorphic()`，以两个树引用作为参数，并在它们引用同构树时返回`true`，否则返回`false`。然后实现一个线性时间的静态方法`eq()`，以两个树引用作为参数，并在它们引用相同的树（具有相同键值的同构树）时返回`true`，否则返回`false`。
- en: '[PRE6]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add a linear-time method `isBST()` to [BST.java](BST.java.html) that returns
    `true` if the tree is a BST, and `false` otherwise.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[BST.java](BST.java.html)中添加一个线性时间方法`isBST()`，如果树是BST，则返回`true`，否则返回`false`。
- en: 'Add a method `levelOrder()` to [BST.java](BST.java.html). that prints the keys
    in *level order*: first print the root; then the nodes one level below the root,
    left to right; then the nodes two levels below the root (left to right); and so
    forth. *Hint*: Use a `Queue<Node>`.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[BST.java](BST.java.html)中添加一个名为`levelOrder()`的方法，按*层次顺序*打印键：首先打印根节点；然后按从左到右的顺序打印根节点下一级的节点；然后按从左到右的顺序打印根节点下两级的节点；依此类推。*提示*：使用`Queue<Node>`。
- en: Compute the value returned by `mystery()` on some sample binary trees, and then
    formulate a hypothesis about its behavior and prove it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`mystery()`在一些示例二叉树上返回的值，然后提出关于其行为的假设并加以证明。
- en: '[PRE7]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Solution*: Returns 0 for any binary tree.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：对于任何二叉树，返回0。'
- en: Creative Exercises
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Spell checking.** Write a `SET` client [SpellChecker.java](SpellChecker.java.html)
    that takes as command-line argument the name of a file containing a dictionary
    of words, and then reads strings from standard input and prints out any string
    that is not in the dictionary.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拼写检查。**编写一个`SET`客户端[SpellChecker.java](SpellChecker.java.html)，以命令行参数形式接受包含单词字典的文件名，然后从标准输入读取字符串，并打印出不在字典中的任何字符串。'
- en: '**Spell correction.** Write an `ST` client [SpellCorrector.java](SpellCorrector.java.html)
    that serves as a filter that replaces commonly misspelled words on standard input
    with a suggested replacement, printing the result to standard output. Take as
    a command-line argument the name of a file that contains common misspellings and
    corrections. Use the file [misspellings.txt](misspellings.txt), which contains
    many common misspellings.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拼写校正。** 编写一个`ST`客户端[SpellCorrector.java](SpellCorrector.java.html)，作为一个过滤器，用建议的替换词替换标准输入中常见的拼写错误，并将结果打印到标准输出。以一个包含常见拼写错误和更正的文件的文件名作为命令行参数。使用文件[misspellings.txt](misspellings.txt)，其中包含许多常见的拼写错误。'
- en: '**Set operations.** Add methods `union()` and `intersection()` to [SET.java](SET.java.html)
    that takes two sets as arguments and return the union and intersection, respectively,
    of those two sets.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集合操作。** 在[SET.java](SET.java.html)中添加方法`union()`和`intersection()`，接受两个集合作为参数，并分别返回这两个集合的并集和交集。'
- en: '**Frequency symbol table.** Develop a data type [FrequencyTable.java](FrequencyTable.java.html)
    that supports the following operations: `increment()` and `frequencyOf()`, both
    of which take string arguments. The data type keeps track of the number of times
    the `increment()` operation has been called with the given string as argument.
    `The increment()` operation increments the count by 1, and the `count()` operation
    returns the count, possibly 0. Clients of this data type might include a web-traffic
    analyzer, a music player that counts the number of times each song has been played,
    phone software for counting calls, and so forth.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**频率符号表。** 开发一个支持以下操作的数据类型[FrequencyTable.java](FrequencyTable.java.html)：`increment()`和`frequencyOf()`，两者都接受字符串参数。数据类型跟踪使用给定字符串作为参数调用`increment()`操作的次数。`increment()`操作将计数增加1，`count()`操作返回计数，可能为0。此数据类型的客户端可能包括网页流量分析器、计算每首歌曲播放次数的音乐播放器、计数电话的电话软件等。'
- en: '**Order statistics.** Add to [BST.java](BST.java.html) a method `select()`
    that takes an integer argument *k* and returns the *k*th smallest key in the BST.
    Maintain the subtree sizes in each node. The running time should be proportional
    to the height of the tree.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顺序统计。** 在[BST.java](BST.java.html)中添加一个名为`select()`的方法，该方法接受一个整数参数*k*并返回BST中第*k*小的键。在每个节点中维护子树大小。运行时间应与树的高度成比例。'
- en: '**Rank query.** Add to [BST.java](BST.java.html) a method `rank()` that takes
    a key as an argument and returns the number of keys in the BST that are strictly
    smaller than `key`. Maintain the subtree sizes in each node. The running time
    should be proportional to the height of the tree.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排名查询。** 在[BST.java](BST.java.html)中添加一个名为`rank()`的方法，该方法以一个键作为参数并返回BST中严格小于`key`的键数。在每个节点中维护子树大小。运行时间应与树的高度成比例。'
- en: '**Sparse vectors.** A *d*-dimensional vector is *sparse* if its number of nonzero
    values is small. Your goal is to represent a vector with space proportional to
    its number of nonzeros, and to be able to add two sparse vectors in time proportional
    to the total number of nonzeros. Implement a class ADTs [SparseVector.java](SparseVector.java.html)
    that supports the following API:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稀疏向量。** 如果一个*d*维向量的非零值个数很少，则称其为*稀疏*向量。你的目标是用与其非零值个数成比例的空间表示向量，并且能够在时间与总非零值个数成比例的情况下添加两个稀疏向量。实现一个支持以下API的类ADTs
    [SparseVector.java](SparseVector.java.html)：'
- en: '![sparse vector API](../Images/e3767ca57b517aec26f97a7697a861e6.png)'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![稀疏向量API](../Images/e3767ca57b517aec26f97a7697a861e6.png)'
- en: '**Sparse matrices.** An *n*-by-*n* matrix is *sparse* if its number of nonzeros
    is proportional to *n* (or less). Your goal is to represent a matrix with space
    proportional to *n*, and to be able to add and multiply two sparse matrices in
    time proportional to the total number of nonzeros (perhaps with an extra log *n*
    factor). Implement a class [SparseMatrix.java](SparseMatrix.java.html) that supports
    the following API:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稀疏矩阵。** 如果一个*n*×*n*矩阵的非零元素个数与*n*成比例（或更少），则称其为*稀疏*矩阵。你的目标是用与*n*成比例的空间表示矩阵，并且能够在时间与总非零元素个数成比例的情况下添加和相乘两个稀疏矩阵（可能还带有额外的对数*n*因子）。实现一个支持以下API的类[SparseMatrix.java](SparseMatrix.java.html)：'
- en: '![sparse matrix API](../Images/aff7b8b10daeeaae4a530b9255f3070c.png)'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![稀疏矩阵API](../Images/aff7b8b10daeeaae4a530b9255f3070c.png)'
- en: Web Exercises
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: '**Functions on trees.** Write a function `count()` that takes a `Node` `x`
    as an argument returns the number of nodes in the subtree rooted at `x` (including
    `x`). The number of elements in an empty binary tree is 0 (base case), and the
    number of elements in a non-empty binary tree is equal to one plus the number
    of elements in the left subtree plus the number of elements in the right subtree.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**树上的函数。** 编写一个函数`count()`，接受一个名为`Node`的参数`x`并返回以`x`为根的子树中节点的数量（包括`x`）。空二叉树中元素的数量为0（基本情况），非空二叉树中元素的数量等于左子树中元素的数量加上右子树中元素的数量再加1。'
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Random element.** Add a symbol table function `random()` to a BST that returns
    a random element. Assume that the nodes of your BST have integer size fields that
    contain the number of elements in the subtree rooted at that node. The running
    time should be proportional to the length of the path from the root to the node
    returned.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机元素。** 在BST中添加一个符号表函数`random()`，返回一个随机元素。假设BST的节点具有整数大小字段，其中包含根节点到返回节点的路径长度中的元素数。运行时间应与从根到返回节点的路径长度成比例。'
- en: '**Markov language model.** Create a data type that supports the following two
    operations: `add` and `random`. The `add` method should insert a new item into
    the data structure if it doesn''t yet exists; if it already exists, it should
    increase its frequency count by one. The `random` method should return an element
    at random, where the probabilities are weighted by the frequency of each element.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**马尔可夫语言模型。** 创建一个支持以下两个操作的数据类型：`add`和`random`。`add`方法应在数据结构中插入新项（如果尚不存在）；如果已存在，则应将其频率计数增加一。`random`方法应随机返回一个元素，其中各元素的概率由每个元素的频率加权。'
- en: '**Bayesian spam filter.** Follow the ideas in [A Plan for Spam](http://www.paulgraham.com/antispam.html).
    Here is a place to get [test data](http://nexp.cs.pdx.edu/~psam/cgi-bin/view/PSAM/WebHome).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**贝叶斯垃圾邮件过滤器。** 参考[A Plan for Spam](http://www.paulgraham.com/antispam.html)中的想法。这里是获取[测试数据](http://nexp.cs.pdx.edu/~psam/cgi-bin/view/PSAM/WebHome)的地方。'
- en: '**Symbol table with random access.** Create a data type that supports inserting
    a key–value pair, searching for a key and returning the associated value, and
    deleting and returning a random value. *Hint*: combine a symbol table and a randomized
    queue.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有随机访问的符号表。** 创建一个支持插入键值对、搜索键并返回相关值、删除并返回随机值的数据类型。*提示*：结合符号表和随机队列。'
- en: '**Random phone numbers.** Write a program that takes a command line input N
    and prints N random phone numbers of the form (xxx) xxx-xxxx. Use a symbol table
    to avoid choosing the same number more than once. Use this [list of area codes](../data/phone-na.csv)
    to avoid printing out bogus area codes.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机电话号码。** 编写一个程序，接受命令行输入N，并打印N个形式为(xxx) xxx-xxxx的随机电话号码。使用符号表以避免选择相同号码超过一次。使用这个[区号列表](../data/phone-na.csv)以避免打印虚假区号。'
- en: '**Unique substrings of length L.** Write a program that reads in text from
    standard input and calculate the number of unique substrings of length L that
    it contains. For example, if the input is `cgcgggcgcg` then there are 5 unique
    substrings of length 3: `cgc`, `cgg`, `gcg`, `ggc`, and `ggg`. Applications to
    data compression. *Hint*: use the string method `substring(i, i + L)` to extract
    ith substring and insert into a symbol table. Test it out on the first [million
    digits of π](../data/pi-1million.txt). or [10 million digits of π](../data/pi-10million.txt).'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**长度为L的唯一子字符串。** 编写一个程序，从标准输入中读取文本并计算其包含的长度为L的唯一���字符串的数量。例如，如果输入是`cgcgggcgcg`，那么长度为3的唯一子字符串有5个：`cgc`、`cgg`、`gcg`、`ggc`和`ggg`。应用于数据压缩。*提示*：使用字符串方法`substring(i,
    i + L)`提取第i个子字符串并插入符号表。在第一个[π的百万位数](../data/pi-1million.txt)或[π的一千万位数](../data/pi-10million.txt)上进行测试。'
- en: '**The great tree–list recursion problem**. A binary search tree and a circular
    doubly linked list are conceptually built from the same type of nodes - a data
    field and two references to other nodes. Given a binary search tree, rearrange
    the references so that it becomes a circular doubly-linked list (in sorted order).
    Nick Parlante describes this as [one of the neatest recursive pointer problems
    ever devised](http://cslibrary.stanford.edu/109/TreeListRecursion.html). *Hint*:
    create a circularly linked list A from the left subtree, a circularly linked list
    B from the right subtree, and make the root a one node circularly linked list.
    Them merge the three lists.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伟大的树-列表递归问题**。二叉搜索树和循环双向链表在概念上是由相同类型的节点构建的 - 一个数据字段和对其他节点的两个引用。给定一个二叉搜索树，重新排列引用，使其成为一个循环双向链表（按排序顺序）。Nick
    Parlante将其描述为[有史以来设计的最整洁的递归指针问题之一](http://cslibrary.stanford.edu/109/TreeListRecursion.html)。*提示*：从左子树创建一个循环链接列表A，从右子树创建一个循环链接列表B，并使根节点成为一个节点的循环链接列表。然后合并这三个列表。'
- en: '**Password checker.** Write a program that reads in a string from the command
    line and a dictionary of words from standard input, and checks whether it is a
    "good" password. Here, assume "good" means that it (i) is at least 8 characters
    long, (ii) is not a word in the dictionary, (iii) is not a word in the dictionary
    followed by a digit 0-9 (e.g., hello5), (iv) is not two words separated by a digit
    (e.g., hello2world)'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密码检查器。** 编写一个程序，从命令行读取一个字符串和从标准输入读取一个单词字典，并检查它是否是一个“好”密码。在这里，假设“好”意味着（i）至少有8个字符长，（ii）不是字典中的单词，（iii）不是字典中的单词后跟一个数字0-9（例如，hello5），（iv）不是由一个数字分隔的两个单词（例如，hello2world）。'
- en: '**Reverse password checker.** Modify the previous problem so that (ii) - (v)
    are also satisfied for reverses of words in the dictionary (e.g., olleh and olleh2world).
    *Simple solution*: insert each word and its reverse into the symbol table.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反向密码检查器。** 修改前一个问题，使得（ii）-（v）也适用于字典中单词的反向（例如，olleh和olleh2world）。*简单解决方案*：将每个单词及其反向插入符号表。'
- en: '**Cryptograms.** Write a program to read in a cryptogram and solve it. A cryptogram
    is ancient form of encryption known as a substitution cipher in which each letter
    in the original message is replaced by another letter. Assuming we use only lowercase
    letters, there are 26! possibilities, and your goal is to find one that results
    in a message where each word is a valid word in the dictionary. Use [Permutations.java](../23recursion/Permutations.java.html)
    and backtracking.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密码学。** 编写一个程序来读取密码并解密。密码是一种古老的加密形式，称为替换密码，其中原始消息中的每个字母都被另一个字母替换。假设我们只使用小写字母，有26!种可能性，你的目标是找到一个结果，其中每个单词都是字典中的有效单词。使用[Permutations.java](../23recursion/Permutations.java.html)和回溯。'
- en: '**Frequency counter.** Write a program [FrequencyCounter.java](FrequencyCounter.java.html)
    that reads in a sequence of strings from standard input and *counts* the number
    of times each string appears.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**频率计数器。** 编写一个程序[FrequencyCounter.java](FrequencyCounter.java.html)，从标准输入中读取一系列字符串，并*计算*每个字符串出现的次数。'
- en: '**Unordered array symbol table.** Write a data type [SequentialSearchArrayST](SequentialSearchArrayST.java.html)
    that implements a symbol table using an (unordered) resizing array.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无序数组符号表。** 编写一个数据类型[SequentialSearchArrayST](SequentialSearchArrayST.java.html)，使用（无序）调整大小的数组实现符号表。'
- en: '**Nonrecursive BST.** Write a data type [IterativeBST.java](IterativeBST.java.html)
    that implements a symbol table using a BST, but uses non-recursive versions of
    `get()` and `put()`.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非递归二叉搜索树。** 编写一个数据类型[IterativeBST.java](IterativeBST.java.html)，使用二叉搜索树实现符号表，但使用非递归版本的`get()`和`put()`。'
- en: '**Exception filter.** The client program [ExceptionFilter.java](ExceptionFilter.java.html)
    reads a sequence of strings from a allowlist file specified as a command-line
    argument, then it prints all words from standard input not in the allowlist.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**异常过滤器。** 客户端程序[ExceptionFilter.java](ExceptionFilter.java.html)从指定为命令行参数的允许列表文件中读取一系列字符串，然后打印标准输入中不在允许列表中的所有单词。'
- en: '**Tree reconstruction.** Given the following traversals of a binary tree (only
    the elements, not the null nodes), can you can you reconstruct the tree?'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**树重建。** 给定二叉树的以下遍历（只有元素，没有空节点），你能重建这棵树吗？'
- en: Preorder and inorder.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先序遍历和中序遍历。
- en: Postorder and inorder.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后序遍历和中序遍历。
- en: Level order and inorder.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 层序遍历和中序遍历。
- en: Preorder and level order.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先序遍历和层序遍历。
- en: Preorder and postorder.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先序遍历和后序遍历。
- en: '*Solutions*:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: Yes. Scan the preorder from left to right, and use the inorder traversal to
    identify the left and right subtrees.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以。从左到右扫描先序遍历，并使用中序遍历来识别左右子树。
- en: Yes. Scan the postorder from right to left.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以。从右到左扫描后序遍历。
- en: Yes. Scan the level order from left to right.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以。从左到右扫描层序遍历。
- en: No. Consider two trees with A as the root and B as either the left or right
    child. The preorder traversal of both is AB and the level order traversal of both
    is AB.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不行。考虑两棵以 A 为根节点，B 为左或右子节点的树。它们的先序遍历都是 AB，层序遍历也都是 AB。
- en: No. Same counterexample as above.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不行。与上面相同的反例。
- en: Give the preorder traversal of some BST (not including null nodes), can you
    reconstruct the tree?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定某个二叉搜索树的先序遍历（不包括空节点），你能重建这棵树吗？
- en: '*Solution*: Yes. It is equivalent to knowing preorder and inorder.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：可以。这等同于知道先序遍历和中序遍历。'
- en: '**Highlighting browser hyperlinks.** Browsers typically denote hyperlinks in
    blue, unless they''ve already been visited, in which case they''re depicted in
    purple Write a program `HyperLinkColorer.java` that reads in a list of web addresses
    from standard input and output `blue` if it''s the first time reading in that
    string, and `purple` otherwise.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**突出显示浏览器超链接。** 浏览器通常用蓝色表示超链接，除非已经访问过，此时用紫色表示。编写一个程序 `HyperLinkColorer.java`，从标准输入中读取网址列表，如果是第一次读取该字符串，则输出
    `blue`，否则输出 `purple`。'
- en: '**Spam blocklist.** Insert known spam email addresses into a [SET.java](SET.java.html)
    data type, and use it to blocklist spam.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垃圾邮件黑名单。** 将已知的垃圾邮件地址插入到 [SET.java](SET.java.html) 数据类型中，并使用它来阻止垃圾邮件。'
- en: '**Inverted index of a book.** Write a program that reads in a text file from
    standard input and compiles an alphabetical index of which words appear on which
    lines, as in the following input. Ignore case and punctuation.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**书籍的倒排索引。** 编写一个程序，从标准输入中读取文本文件，并编制一个按字母顺序排列的索引，显示哪些单词出现在哪些行中，如下所示的输入。忽略大小写和标点符号。'
- en: '[PRE9]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Hint*: create a symbol table whose key is a `String` that represents a word
    and whose value is a `Sequence<Integer>` that represents the list of pages on
    which the word appears.'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：创建一个符号表，其键是表示单词的 `String`，值是表示单词出现的页码列表的 `Sequence<Integer>`。'
- en: '**Randomly generated identities.** The files [names20k.csv](names20k.csv) and
    The file [names20k-2.csv](names20k-2.csv) each contain 20,000 randomly generated
    identities (number, gender, first name, middle initial, last name, street address,
    city, state, zip code, country, email address, telephone number, mother''s maiden
    name, birthday, credit card type, credit card number, credit card expiration date,
    Social security number) from [fakenamegenerator.com](http://www.fakenamegenerator.com/index.php).'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机生成的身份信息。** 文件 [names20k.csv](names20k.csv) 和文件 [names20k-2.csv](names20k-2.csv)
    每个包含 20,000 个从 [fakenamegenerator.com](http://www.fakenamegenerator.com/index.php)
    随机生成的身份信息（编号、性别、名字、中间名、姓氏、街道地址、城市、州、邮编、国家、电子邮件地址、电话号码、母亲的婚前姓、生日、信用卡类型、信用卡号、信用卡到期日）。'
- en: '**Distance between zip codes.** Write a data type [Location.java](Location.java.html)
    that represents a named location on the surface of the earth (a name, latitude,
    and longitude). Then, write a client program [that takes the name of a ZIP code
    file (such as](Postal.java.html) [zips.txt](zips.txt)) as a command-line argument,
    reads the data from the file, and stores it in a symbol table. Then, repeatedly
    read in pairs of ZIP codes from standard input and output the great-circle distance
    between them (in statute miles). This distance is used by the post office to calculate
    shipping rates.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**邮编之间的距离。** 编写一个表示地球表面上命名位置（名称、纬度和经度）的数据类型 [Location.java](Location.java.html)。然后，编写一个客户端程序，接受
    ZIP 文件名（例如 [zips.txt](zips.txt)）作为命令行参数，从文件中读取数据，并将其存储在符号表中。然后，重复从标准输入中读取 ZIP
    码对，并输出它们之间的大圆距离（以英里为单位）。这个距离用于邮局计算运费。'
- en: Prove that the expected number of key comparisons for a random *put* or *get*
    in a BST build from randomly ordered keys is ~ 2 ln N.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明从随机排序的键构建的 BST 中进行随机 *put* 或 *get* 的预期关键比较次数为 ~ 2 ln N。
- en: Run experiments to validate the claims in the text that the *put* operations
    and *get* requests for Lookup and Index are logarithmic in the size of the table
    when using `BST`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行实验来验证文本中关于使用 `BST` 时 *put* 操作和 *get* 请求的索引和查找在表大小对数级别的声明。
- en: '**Database joins.** Given two tables, an [inner join](http://en.wikipedia.org/wiki/Join_(SQL))
    finds the "intersection" between the two tables.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据库连接。** 给定两个表，[内连接](http://en.wikipedia.org/wiki/Join_(SQL)) 找到两个表之间的“交集”。'
- en: '[PRE10]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The inner join on department ID is as follows.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部门 ID 的内连接如下。
- en: '[PRE11]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Actor and actress aliases.** Given this 10MB file containing a [list of actors
    (with canonical name) and their aliases](../data/aka-names.list), write a program
    that reads in the name of an actor from standard input and prints out his canonical
    name.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**演员和女演员的别名。** 给定包含 [演员列表（带有规范名称）及其别名](../data/aka-names.list) 的 10MB 文件，编写一个程序，从标准输入中读取演员的名称，并打印出他的规范名称。'
- en: '**Molecular weight calculator.** Write a program [MolecularWeight.java](MolecularWeight.java.html)
    that reads in a list of [elements and their molecular weights](elements.csv),
    and then prompts the user for the molecular description of a chemical compound
    (e.g., CO.2 or Na.Cl or N.H4.N.O3 = ammonium nitrate) and prints out its molecular
    weight.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分子量计算器。** 编写一个程序 [MolecularWeight.java](MolecularWeight.java.html)，从 [elements.csv](elements.csv)
    中读取元素及其分子量的列表，然后提示用户输入化学化合物的分子描述（例如，CO.2 或 Na.Cl 或 N.H4.N.O3 = 硝酸铵），并输出其分子量。'
