- en: Lecture 7
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7讲
- en: 原文：[https://cs50.harvard.edu/web/notes/7/](https://cs50.harvard.edu/web/notes/7/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/web/notes/7/](https://cs50.harvard.edu/web/notes/7/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[Testing](#testing)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试](#testing)'
- en: '[Assert](#assert)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[断言](#assert)'
- en: '[Test-Driven Development](#test-driven-development)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试驱动开发](#test-driven-development)'
- en: '[Unit Testing](#unit-testing)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[单元测试](#unit-testing)'
- en: '[Django Testing](#django-testing)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Django测试](#django-testing)'
- en: '[Client Testing](#client-testing)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[客户端测试](#client-testing)'
- en: '[Selenium](#selenium)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Selenium](#selenium)'
- en: '[CI/CD](#cicd)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[持续集成/持续部署](#cicd)'
- en: '[GitHub Actions](#github-actions)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub Actions](#github-actions)'
- en: '[Docker](#docker)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Docker](#docker)'
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we’ve discussed how to build simple web pages using HTML and CSS, and
    how to use Git and GitHub in order to keep track of changes to our code and collaborate
    with others. We also familiarized ourselves with the Python programming language,
    started using Django to create web applications, and learned how to use Django
    models to store information in our sites. We then introduced JavaScript and learned
    how to use it to make web pages more interactive, and talked about using animation
    and React to further improve our User Interfaces.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何使用HTML和CSS构建简单的网页，以及如何使用Git和GitHub来跟踪我们代码的变化并与他人协作。我们还熟悉了Python编程语言，开始使用Django创建Web应用程序，并学习了如何使用Django模型在我们的网站上存储信息。然后我们介绍了JavaScript，并学习了如何使用它使网页更加互动，还讨论了使用动画和React来进一步改进我们的用户界面。
- en: Today, we’ll learn about best practices when if comes to working on and launching
    larger projects.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将学习关于在处理和发布大型项目时的最佳实践。
- en: Testing
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: One important part of the software development process is the act of **Testing**
    the code we’ve written to make sure everything runs as we expect it to. In this
    lecture, we’ll discuss several ways that we can improve the way we test our code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发过程中的一个重要部分是**测试**我们所编写的代码，以确保一切按预期运行。在本讲座中，我们将讨论几种我们可以改进测试代码的方法。
- en: Assert
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言
- en: One of the simplest ways we can run tests in Python is by using the `assert`
    command. This command is followed by some expression that should be `True`. If
    the expression is `True`, nothing will happen, and if it is `False`, an exception
    will be thrown. Let’s look at how we could incorporate command to test the `square`
    function we wrote when first learning Python. When the function is written correctly,
    nothing happens as the `assert` is `True`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中运行测试的最简单方法之一是使用`assert`命令。此命令后面跟一个应该为`True`的表达式。如果表达式为`True`，则不会发生任何事情，如果为`False`，则会抛出异常。让我们看看我们如何将命令集成到测试我们在学习Python时编写的`square`函数中。当函数编写正确时，由于`assert`为`True`，所以不会发生任何事情
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And then when it is written incorrectly, an exception is thrown.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编写错误，则会抛出异常。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Test-Driven Development
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: As you begin building larger projects, you may want to consider using **test-driven
    development**, a development style where every time you fix a bug, you add a test
    that checks for that bug to a growing set of tests that are run every time you
    make changes. This will help you to make sure that additional features you add
    to a project don’t interfere with your existing features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建更大的项目时，你可能想要考虑使用**测试驱动开发**，这是一种开发风格，每次修复一个错误时，你都会添加一个测试来检查该错误，并将其添加到一个不断增长的测试集中，每次你进行更改时都会运行这些测试。这将帮助你确保你添加到项目中的新功能不会干扰现有的功能。
- en: 'Now, let’s look at a slightly more complex function, and think about how writing
    tests can help us to find errors. We’ll now write a function called `is_prime`
    that returns `True` if and only if its input is prime:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个稍微复杂一些的函数，并思考编写测试如何帮助我们找到错误。我们现在将编写一个名为`is_prime`的函数，该函数在其输入是质数时返回`True`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s take a look at a function we’ve written to test our `prime` function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们编写的测试`prime`函数的函数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we can go into our python interpreter and test out some values:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以进入我们的Python解释器并测试一些值：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see from the output above that 5 and 10 were correctly identified as
    prime and not prime, but 25 was incorrectly identified as prime, so there must
    be something wrong with our function. Before we look into what is wrong with our
    function though, let’s look at a way to automate our testing. One way we can do
    this is by creating a **shell script**, or some script that can be run inside
    our terminal. These files require a `.sh` extension, so our file will be called
    `tests0.sh`. Each of the lines below consists of
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中我们可以看到，5 和 10 被正确地识别为质数和非质数，但 25 被错误地识别为质数，所以我们的函数肯定有问题。在我们查看函数的问题之前，让我们看看一种自动化测试的方法。我们可以这样做的一种方法是通过创建一个
    **shell 脚本**，或者可以在我们的终端中运行的脚本。这些文件需要 `.sh` 扩展名，所以我们的文件将被称为 `tests0.sh`。下面每一行都包含
- en: A `python3` to specify the Python version we’re running
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `python3` 指定我们正在运行的 Python 版本
- en: A `-c` to indicate that we wish to run a command
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-c` 表示我们希望运行一个命令'
- en: A command to run in string format
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个以字符串格式运行的命令
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can run these commands by running `./tests0.sh` in our terminal, giving
    us this result:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在终端中运行这些命令，通过运行 `./tests0.sh`，得到这个结果：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unit Testing
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Even though we were able to run tests automatically using the above method,
    we still might want to avoid having to write out each of those tests. Thankfully,
    we can use the Python `unittest` library to make this process a little bit easier.
    Let’s take a look at what a testing program might look like for our `is_prime`
    function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们能够使用上述方法自动运行测试，但我们仍然可能希望避免逐个编写这些测试。幸运的是，我们可以使用 Python 的 `unittest` 库使这个过程变得容易一些。让我们看看我们的
    `is_prime` 函数的测试程序可能是什么样子。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that each of the functions within our `Tests` class followed a pattern:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们 `Tests` 类中的每个函数都遵循了一个模式：
- en: The name of the functions begin with `test_`. This is necessary for the functions
    to be run automatically with the call to `unittest.main()`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称以 `test_` 开头。这对于函数在调用 `unittest.main()` 时自动运行是必要的。
- en: Each test takes in the `self` argument. This is standard when writing methods
    within Python classes.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试都接受 `self` 参数。这是在 Python 类中编写方法时的标准做法。
- en: The first line of each function contains a **docstring** surrounded by three
    quotation marks. These are not just for the code’s readability. When the tests
    are run, the comment will be displayed as a discription of the test if it fails.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数的第一行包含一个由三个引号包围的 **文档字符串**。这些不仅是为了代码的可读性。当测试运行时，如果测试失败，注释将作为测试的描述显示。
- en: The next line of each of the functions contained an assertion in the form `self.assertSOMETHING`.
    There are many different assertions you can make including `assertTrue`, `assertFalse`,
    `assertEqual`, and `assertGreater`. You can find these ones and more by checking
    out the [documentation](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数的下一行包含了一个形式为 `self.assertSOMETHING` 的断言。你可以做出很多不同的断言，包括 `assertTrue`、`assertFalse`、`assertEqual`
    和 `assertGreater`。你可以通过查看 [文档](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual)
    来找到这些以及其他断言。
- en: 'Now, let’s check out the results of these tests:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查这些测试的结果：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After running the tests, `unittest` provides us with some useful information
    about what it found. In the first line, it gives us a series of `.`s for successes
    and `F`s for failures in the order our tests were written.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，`unittest` 会提供一些关于它发现的有用信息。在第一行，它按测试编写的顺序给出了成功的一系列 `.` 和失败的一系列 `F`。
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, for each of the tests that failed, we are then given the name of the
    function that failed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于每个失败的测试，我们还会得到失败函数的名称：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'the descriptive comment we provided earlier:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提供的描述性注释：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And a traceback for the exception:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以及异常的跟踪信息：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, we are given a run through of how many tests were run, how much
    time they took, and how many failed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了一个关于运行了多少个测试、花费了多少时间以及有多少失败的概述：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let’s take a look at fixing the bug in our function. It turns out that
    we need to test one additional number in our `for` loop. For example, when `n`
    is `25`, the square root is `5`, but when that is one argument in the `range`
    function, the `for` loop terminates at the number `4`. Therefore, we can simply
    change the header of our `for` loop to:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何修复我们函数中的错误。结果是，我们需要在我们的 `for` 循环中测试一个额外的数字。例如，当 `n` 是 `25` 时，平方根是
    `5`，但当它是 `range` 函数的一个参数时，`for` 循环在数字 `4` 处终止。因此，我们可以简单地改变 `for` 循环的头部为：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, when we run the tests again using our unit tests, we get the following
    output, indicating that our change fixed the bug.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次使用我们的单元测试运行测试时，我们得到以下输出，表明我们的更改修复了错误。
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These automated tests will become even more useful as you work to optimize this
    function. For example, you might want to use the fact that you don’t need to check
    all integers as factors, just smaller primes (if a number is not divisible by
    3, it is also not divisible by 6, 9, 12, …), or you may want to use more advanced
    probabilistic primality tests such as the [Fermat](https://en.wikipedia.org/wiki/Fermat_primality_test)
    and [Miller-Rabin](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
    primality tests. Whenever you make changes to improve this function, you’ll want
    the ability to easily run your unit tests again to make sure your function is
    still correct.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对这个函数进行优化，这些自动化测试将变得更加有用。例如，你可能想利用这样一个事实，即你不需要检查所有整数作为因子，只需检查较小的质数（如果一个数不能被3整除，它也不能被6、9、12等整除），或者你可能想使用更高级的概率性质数测试，如[Fermat](https://en.wikipedia.org/wiki/Fermat_primality_test)和[Miller-Rabin](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)质数测试。无论何时你修改此函数以改进它，你都需要能够轻松地再次运行你的单元测试，以确保你的函数仍然正确。
- en: Django Testing
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django测试
- en: 'Now, let’s look at how we can apply the ideas of automated testing when creating
    Django applications. While working with this, we’ll be using the `flights` project
    we created when we first learned about Django models. We’re first going to add
    a method to our `Flight` model that verifies that a flight is valid by checking
    for two conditions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在创建Django应用程序时如何应用自动化测试的理念。在处理这个项目时，我们将使用我们在第一次学习Django模型时创建的`flights`项目。我们首先将向我们的`Flight`模型添加一个方法，该方法通过检查两个条件来验证航班是否有效：
- en: The origin is not the same as the destination
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起点与目的地不同
- en: The duration is greater than 0 minutes
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续时间大于0分钟
- en: 'Now, our model could look something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的模型可能看起来像这样：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to make sure our application works as expected, whenever we create
    a new application, we are automatically given a `tests.py` file. When we first
    open this file, we see that Django’s [TestCase](https://docs.djangoproject.com/en/4.0/topics/testing/overview/)
    library is automatically imported:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的应用程序按预期工作，每次我们创建一个新的应用程序时，我们都会自动获得一个`tests.py`文件。当我们第一次打开这个文件时，我们看到Django的[TestCase](https://docs.djangoproject.com/en/4.0/topics/testing/overview/)库被自动导入：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One advantage to using the `TestCase` library is that when we run our tests,
    an entirely new database will be created for testing purposes only. This is helpful
    because we avoid the risk of accidentally modifying or deleting existing entries
    in our databse and we don’t have to worry about removing dummy entries that we
    created only for testing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TestCase`库的一个优点是，当我们运行测试时，将仅用于测试目的创建一个全新的数据库。这很有帮助，因为我们避免了意外修改或删除数据库中现有条目的风险，我们也不必担心移除仅用于测试而创建的虚拟条目。
- en: 'To start using this library, we’ll first want to import all of our models:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这个库，我们首先想要导入我们所有的模型：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And then we’ll create a new class that extends the `TestCase` class we just
    imported. Within this class, we’ll define a `setUp` function that will be run
    at the start of the testing process. In this function, we’ll probably want to
    create. Here’s what our class will look like to start:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将创建一个新的类，该类扩展了我们刚刚导入的`TestCase`类。在这个类中，我们将定义一个`setUp`函数，该函数将在测试过程开始时运行。在这个函数中，我们可能想要创建。我们的类将如下所示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have some entries in our testing database, let’s add some functions
    to this class to perform some tests. First, let’s make sure our `departures` and
    `arrivals` fields work correctly by attempting to count the number of departures
    (which we know should be 3) and arrivals (which should be 1) from airport `AAA`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们测试数据库中有了一些条目，让我们向这个类添加一些函数来执行一些测试。首先，让我们确保我们的`departures`和`arrivals`字段工作正常，通过尝试计算从机场`AAA`出发的航班数量（我们知道应该是3）和到达数量（应该是1）：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also test the `is_valid_flight` function we added to our `Flight` model.
    We’ll begin by asserting that the function does return true when the flight is
    valid:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试我们添加到`Flight`模型中的`is_valid_flight`函数。我们将首先断言当航班有效时，该函数确实返回true：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let’s make sure that flights with invalid destinations and durations
    return false:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保具有无效目的地和持续时间的航班返回false：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, to run our tests, we’ll run `python manage.py test`. The output for this
    is almost identical to the output we saw while using the Python `unittest` library,
    although it also logs that it is creating and destroying a testing database:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了运行我们的测试，我们将运行`python manage.py test`。这个输出的结果几乎与使用Python `unittest`库时的输出相同，尽管它也记录了它正在创建和销毁测试数据库：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can see from the above output that there are times when `is_valid_flight`
    returned `True` when it should have returned `False`. We can see, upon further
    inspection of our function, that we made the mistake of using `or` instead of
    `and`, meaning that only one of the flight requirements must be filled for the
    flight to be valid. If we change the function to this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中我们可以看到，有时`is_valid_flight`在应该返回`False`的时候返回了`True`。进一步检查我们的函数后，我们发现错误在于使用了`or`而不是`and`，这意味着只有当飞行要求中的一项被满足时，航班才被认为是有效的。如果我们把函数改为这样：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then run the tests again with better results:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次运行测试，并得到更好的结果：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Client Testing
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Client Testing
- en: 'When creating web applications, we will probably want to check not just whether
    or not specific functions work, but also whether or not individual web pages load
    as intended. We can do this by creating a `Client` object in our Django testing
    class, and then making requests using that object. To do this, we’ll first have
    to add `Client` to our imports:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Web应用程序时，我们可能不仅想要检查特定函数是否工作，还想要检查单个Web页面是否按预期加载。我们可以通过在我们的Django测试类中创建一个`Client`对象，然后使用该对象进行请求来实现这一点。为了做到这一点，我们首先必须将`Client`添加到我们的导入中：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example, let’s now add a test that makes sure that we get an HTTP response
    code of 200 and that all three of our flights are added to the context of a response:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在让我们添加一个测试来确保我们得到HTTP响应代码200，并且我们的三个航班都被添加到响应的上下文中：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can similarly check to make sure we get a valid response code for a valid
    flight page, and an invalid response code for a flight page that doesn’t exist.
    (Notice that we use the `Max` function to find the maximum `id`, which we have
    access to by including `from django.db.models import Max` at the top of our file)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地检查以确保我们得到有效页面的有效响应代码，以及不存在页面的无效响应代码。（注意，我们使用`Max`函数来找到最大的`id`，我们通过在文件顶部包含`from
    django.db.models import Max`来访问它）
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, let’s add some testing to make sure the passengers and non-passengers
    lists are being generated as expected:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些测试以确保乘客和非乘客列表被按预期生成：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we can run all of our tests together, and see that at the moment we have
    no errors!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以一起运行所有的测试，看到目前我们没有错误！
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Selenium
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium
- en: So far, we’ve been able to test out the server-side code we’ve written using
    Python and Django, but as we’re building up our applications we’ll want the ability
    to create tests for our client-side code as well. For example, let’s think back
    to our `counter.html` page and work on writing some tests for it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够使用Python和Django测试我们编写的服务器端代码，但随着我们构建应用程序，我们还将想要为我们的客户端代码创建测试。例如，让我们回顾一下我们的`counter.html`页面，并为其编写一些测试。
- en: 'We’ll begin by writing a slightly different counter page where we include a
    button to decrease the count:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始编写一个稍微不同的计数页面，其中包含一个用于减少计数的按钮：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now if we wish to test this code, we could just open up our web browser, click
    the two buttons, and observe what happens. This, however, would become very tedious
    as you write larger and larger single page applications, which is why several
    frameworks have been created that help with in-browser testing, one of which is
    called [Selenium](https://www.selenium.dev/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们想测试这段代码，我们只需打开我们的网页浏览器，点击两个按钮，观察发生了什么。然而，随着你编写越来越大的单页应用程序，这会变得非常繁琐，这就是为什么有几个框架被创建出来以帮助进行浏览器内测试，其中一个叫做[Selenium](https://www.selenium.dev/)。
- en: Using Selenium, we’ll be able to define a testing file in Python where we can
    simulate a user opening a web browser, navigating to our page, and interacting
    with it. Our main tool when doing this is known as a **Web Driver**, which will
    open up a web browser on your computer. Let’s take a look at how we could start
    using this library to begin interacting with pages. Note that below we use both
    `selenium` and `ChromeDriver`. Selenium can be installed for python by running
    `pip install selenium`, and `ChromeDriver` can be installed by running `pip install
    chromedriver-py`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Selenium，我们可以在Python中定义一个测试文件，在那里我们可以模拟用户打开一个网络浏览器，导航到我们的页面，并与它交互。我们在做这件事时使用的主要工具被称为**Web
    Driver**，它将在您的计算机上打开一个网络浏览器。让我们看看我们如何开始使用这个库来与页面进行交互。注意，以下我们使用了`selenium`和`ChromeDriver`。Selenium可以通过运行`pip
    install selenium`来为Python安装，而`ChromeDriver`可以通过运行`pip install chromedriver-py`来安装
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The above code is all of the basic setup we need, so now we can get into some
    more interesting uses by employing the Python interpreter. One note about the
    first few lines is that in order to target a specific page, we need that page’s
    **Uniform Resource Identifier (URI)** which is a unique string that represents
    that resource.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们需要的所有基本设置，因此现在我们可以通过使用Python解释器来探索一些更有趣的用途。关于前几行的一个注意事项是，为了针对特定的页面，我们需要该页面的**统一资源标识符（URI**），这是一个唯一的字符串，代表该资源。
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let’s take a look at how we can use this simulation to create automated
    tests of our page:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用这个模拟来创建我们页面的自动化测试：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if we run `python tests.py`, our simulations will be carried out in the
    browser, and then the results of the tests will be printed to the console. Here’s
    an example of what this might look like when we have a bug in the code a test
    fails:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行 `python tests.py`，我们的模拟将在浏览器中执行，然后测试结果将被打印到控制台。以下是一个示例，当代码中存在错误且测试失败时，它可能看起来是这样的：
- en: '![failed selenium test](../Images/d585dec8593971ca29cf0696c5c578ff.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![失败的Selenium测试](../Images/d585dec8593971ca29cf0696c5c578ff.png)'
- en: CI/CD
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD
- en: '**CI/CD**, which stands for **Continuous Integration and Continuous Delivery**,
    is a set of software development best practices that dictate how code is written
    by a team of people, and how that code is later delivered to users of the application.
    As the name implies, this method consists of two main parts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**CI/CD**，代表**持续集成和持续交付**，是一套软件开发最佳实践，它规定了由一组人员编写的代码，以及该代码如何随后交付给应用程序的用户。正如其名所示，这种方法由两个主要部分组成：'
- en: 'Continuous Integration:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成：
- en: Frequent merges to the main branch
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主分支上的频繁合并
- en: Automated unit testing with each merge
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次合并时进行自动单元测试
- en: 'Continuous Delivery:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付：
- en: Short release schedules, meaning new versions of an application are released
    frequently.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短发布周期，意味着应用程序的新版本会频繁发布。
- en: 'CI/CD has become more and more popular among software development teams for
    a number of reasons:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD由于以下原因在软件开发团队中越来越受欢迎：
- en: When different team members are working on different features, many compatibility
    issues can arise when multiple features are combined at the same time. Continuous
    integration allows teams to tackle small conflicts as they come.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不同的团队成员正在开发不同的功能时，当多个功能同时结合时，可能会出现许多兼容性问题。持续集成允许团队在出现冲突时解决小问题。
- en: Because unit tests are run with each Merge, when a test fails it is easier to
    isolate the part of the code that is causing the problem.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于单元测试是在每次合并时运行的，因此当测试失败时，更容易隔离导致问题的代码部分。
- en: Frequently releasing new versions of an application allows developers to isolate
    problems if they arise after launch.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常发布新版本的应用程序允许开发者在发布后隔离可能出现的问题。
- en: Releasing small, incremental changes allows users to slowly get used to new
    app features rather than being overwhelmed with an entirely different version
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步发布小而渐进的变化，使用户能够逐渐适应新的应用程序功能，而不是被一个全新的版本所淹没
- en: Not waiting to release new features allows companies to stay ahead in a competitive
    market.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不等待发布新功能使公司能够在竞争激烈的市场中保持领先。
- en: GitHub Actions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: One popular tool used to help with continuous integration is known as [GitHub
    Actions](https://github.com/features/actions). GitHub Actions will allow us to
    create workflows where we can specify certain actions to be performed every time
    someone pushes to a git repository. For example, we might want to check with every
    push that a style guide is adhered to, or that a set of unit tests is passed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于帮助持续集成的流行工具被称为 [GitHub Actions](https://github.com/features/actions)。GitHub
    Actions 允许我们创建工作流程，其中我们可以指定每次有人向 git 仓库推送时需要执行的操作。例如，我们可能希望在每次推送时检查是否遵循了样式指南，或者是否通过了一组单元测试。
- en: 'In order to set up a GitHub action, we’ll use a configuration language called
    **YAML**. YAML structures its data around key-value pairs (like a JSON object
    or Python Dictionary). Here’s an example of a simple YAML file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 GitHub Action，我们将使用一种名为 **YAML** 的配置语言。YAML 将其数据结构化为键值对（类似于 JSON 对象或 Python
    字典）。以下是一个简单的 YAML 文件示例：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s look at an example of how we would configure a YAML file (which
    takes the form `name.yml` or `name.yaml`) that works with GitHub Actions. To do
    this, I’ll create a `.github` directory in my repository, and then a `workflows`
    directory inside of that, and finally a `ci.yml` file within that. In that file,
    we’ll write:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个配置 YAML 文件（其形式为 `name.yml` 或 `name.yaml`）的例子，这个文件与 GitHub Actions
    一起工作。为此，我将在我的仓库中创建一个 `.github` 目录，然后在其中创建一个 `workflows` 目录，最后在这个目录中创建一个 `ci.yml`
    文件。在这个文件中，我们将编写：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since this is our first time using GitHub Actions, let’s go through what each
    part of this file is doing:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次使用 GitHub Actions，让我们看看这个文件的每个部分都在做什么：
- en: First, we give the workflow a `name`, which in our case is Testing.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们给工作流程一个 `name`，在我们的例子中是 Testing。
- en: Next, with the `on` key, we specify when the workflow should run. In our case,
    we wish to perform the tests every time someone pushes to the repository.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用 `on` 键，我们指定工作流程应该在何时运行。在我们的情况下，我们希望在有人向仓库推送时执行测试。
- en: The rest of the file is contained within a `jobs` key, which indicates which
    jobs should be run at every push.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的其余部分包含在 `jobs` 键中，它指示每次推送时应运行哪些工作。
- en: In our case, the only job is `test_project`. Every job must define two componenets
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下，唯一的工作是 `test_project`。每个工作都必须定义两个组件
- en: The `runs-on` key specifies which of GitHub’s virtual machines we would like
    our code to be run on.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runs-on` 键指定我们希望我们的代码在 GitHub 的哪个虚拟机上运行。'
- en: The `steps` key provides the actions that should occur when this job is run
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps` 键提供了在运行此工作时应发生的操作'
- en: In the `uses` key we specify which GitHub action we wish to use. `actions/checkout@v2`
    is an action written by GitHub that we can use.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `uses` 键中，我们指定我们希望使用哪个 GitHub Action。`actions/checkout@v2` 是 GitHub 编写的我们可以使用的操作。
- en: The `name` key here allows us to proide a description of the action we’re taking
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`name` 键允许我们提供对所采取操作的描述
- en: After the `run` key, we type the commands we wish to run on GitHub’s server.
    In our case we wish to install Django and then run the testing file.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `run` 键之后，我们输入希望在 GitHub 服务器上运行的命令。在我们的例子中，我们希望安装 Django 然后运行测试文件。
- en: 'Now, let’s open up our repository in GitHub and take a look at some of the
    tabs near the top of the page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 GitHub 中打开我们的仓库，并查看页面顶部附近的一些标签页：
- en: '**Code**: This is the tab that we’ve been using most frequently, as it allows
    us to view the files and folders within our directory.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：这是我们使用频率最高的标签页，因为它允许我们查看目录中的文件和文件夹。'
- en: '**Issues**: Here we can open and close issues, which are requests for bug fixes
    or new features. We can think of this as a to-do list for our application.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：在这里，我们可以打开和关闭问题，这些问题是请求修复错误或新功能。我们可以将其视为我们应用程序的待办事项列表。'
- en: '**Pull Requests**: Requests from people who wish to merge some code from one
    branch into another one. This is a useful tool, as it allows people to perform
    **code reviews** where they comment and provide suggestions before code is integrated
    into the master branch.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取请求**：希望将某个分支的代码合并到另一个分支的人的请求。这是一个有用的工具，因为它允许人们在代码集成到主分支之前进行 **代码审查**，并发表评论和提供建议。'
- en: '**GitHub Actions**: This is the tab we’ll use when working on continuous integration,
    as it provides logs of the actions that have taken place after each push.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub Actions**：这是我们进行持续集成时使用的标签页，因为它提供了每次推送后发生的操作日志。'
- en: 'Here, let’s imagine that we pushed our changes *before* we fixed the bug we
    had in the `is_valid_flight` function in `models.py` within our `airport` project.
    We can now navigate to the **GitHub Actions** tab, click on our most recent push,
    click on the action that failed, and view the log:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，让我们假设我们在修复 `models.py` 文件中 `airport` 项目内的 `is_valid_flight` 函数中的错误之前，已经推送了我们的更改。我们现在可以导航到
    **GitHub Actions** 选项卡，点击我们最近的推送，点击失败的操作，并查看日志：
- en: '![action](../Images/abd420062892a0c33c8af5ffc54b781d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![action](../Images/abd420062892a0c33c8af5ffc54b781d.png)'
- en: 'Now, after fixing the bug, we could bush again and find a better outcome:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在修复了错误之后，我们可以再次尝试并找到更好的结果：
- en: '![action success](../Images/e55ecd17b60624084d9b819987b28cfa.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![action success](../Images/e55ecd17b60624084d9b819987b28cfa.png)'
- en: Docker
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: Problems can arise in the world of software development when the configuration
    on your computer is different than the one your application is being run on. You
    may have a different version of Python or some additional packages installed that
    allow the application to run smoothly on your computer, while it would crash on
    your server. To avoid these problems, we need a way to make sure everyone working
    on a project is using the same environment. One way to do this is to use a tool
    called **Docker**, which is a containerization software, meaning it creates an
    isolated environment within your computer that can be standardized among many
    collaborators and the server on which your site is run. While Docker is a bit
    like a **Virtual Machine**, they are in fact different technologies. A virtual
    machine (like the one used on GitHub Actions or when you launch an [AWS](./) server)
    is effectively an entire virtual computer with its own operating system, meaning
    it ends up taking a lot of space wherever it is running. Dockers, on the other
    hand, work by setting up a container within an existing computer, therefore taking
    up less space.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的世界中，当你的电脑配置与应用程序运行时的配置不同时，可能会出现问题。你可能有一个不同的 Python 版本或安装了一些额外的包，这些包允许应用程序在你的电脑上顺利运行，而它在服务器上可能会崩溃。为了避免这些问题，我们需要确保所有参与项目的人都使用相同的环境。一种方法是通过使用名为
    **Docker** 的工具来实现，这是一个容器化软件，意味着它可以在你的电脑中创建一个隔离的环境，可以在许多协作者和运行你网站的服务器之间标准化。虽然 Docker
    有点像 **虚拟机**，但它们实际上是不同的技术。虚拟机（如 GitHub Actions 或当你启动 [AWS](./) 服务器时使用的）实际上是一个完整的虚拟计算机，具有自己的操作系统，这意味着它在任何运行的地方都会占用很多空间。另一方面，Docker
    通过在现有计算机中设置容器来工作，因此占用的空间更少。
- en: 'Now that we have an idea of what a Docker container is, let’s take a look at
    how we can configure one on our computers. Our first step in doing this will be
    to create a **Docker File** which we’ll name `Dockerfile`. Inside this file, we’ll
    provide instructions for how to create a **Docker Image** which describes the
    libraries and binaries we wish to include in our container. Here’s an example
    of what our `Dockerfile` might look like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Docker 容器的概念，让我们看看如何在我们的电脑上配置一个。我们做这件事的第一步将是创建一个名为 `Dockerfile` 的
    **Docker 文件**。在这个文件中，我们将提供创建 **Docker 镜像** 的指令，该镜像描述了我们希望在容器中包含的库和二进制文件。以下是我们
    `Dockerfile` 可能的样子示例：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we’ll take an in-depth look at what the above file actually does:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将深入探讨上述文件实际上做了什么：
- en: '`FROM python3`: this shows that we are basing this image off of a standard
    image in which Python 3 is installed. This is fairly common when writing a Docker
    File, as it allows you to avoid the work of re-defining the same basic setup with
    each new image.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM python3`: 这表明我们是以安装了 Python 3 的标准镜像为基础构建这个镜像。这在编写 Docker 文件时相当常见，因为它允许你避免在每个新镜像中重新定义相同的基本设置。'
- en: '`COPY . /usr/src/app`: This shows that we wish to copy everything from our
    current directory (`.`) and store it in the `/usr/src/app` directory in our new
    container.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY . /usr/src/app`: 这表明我们希望将当前目录（`.`）中的所有内容复制到新容器中的 `/usr/src/app` 目录。'
- en: '`WORKDIR /usr/src/app`: This sets up where we will run commands within the
    container. (A bit like `cd` on the terminal)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /usr/src/app`: 这设置了我们在容器内运行命令的位置。（有点像终端上的 `cd` 命令）'
- en: '`RUN pip install -r requirements.txt`: In this line, assuming you’ve included
    all of your requirements to a file called `requirements.txt`, they will all be
    installed within the container.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN pip install -r requirements.txt`: 在这一行中，假设你已经将所有需求包含在一个名为 `requirements.txt`
    的文件中，它们都将被安装到容器内。'
- en: '`CMD ["python3", "manage.py", "runserver", "0.0.0.0:8000"]`: Finally, we specify
    the command that should be run when we start up the container.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["python3", "manage.py", "runserver", "0.0.0.0:8000"]`：最后，我们指定了启动容器时应运行的命令。'
- en: 'So far in this class, we’ve only been using SQLite as that’s the default database
    management system for Django. In live applications with real users though, SQLite
    is almost never used, as it is not as easily scaled as other systems. Thankfully,
    if we wish to run a separate server for our database, we can simply add another
    Docker container, and run them together using a feature called **Docker Compose**.
    This will allow two different servers to run in separate containers, but also
    be able to communicate with one another. To specify this, we’ll use a YAML file
    called `docker-compose.yml`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个课程中，我们只使用了SQLite，因为它是Django的默认数据库管理系统。然而，在实际的用户应用程序中，SQLite几乎从不使用，因为它不像其他系统那样容易扩展。幸运的是，如果我们希望为我们的数据库运行一个单独的服务器，我们只需添加另一个Docker容器，并使用一个称为**Docker
    Compose**的功能将它们一起运行。这将允许两个不同的服务器在不同的容器中运行，同时还能相互通信。为了指定这一点，我们将使用一个名为`docker-compose.yml`的YAML文件：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the above file we:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的文件中，我们：
- en: Specify that we’re using version 3 of Docker Compose
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定我们使用Docker Compose的版本3。
- en: 'Outline two services:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述两个服务：
- en: '`db` sets up our database container based on an image already written by Postgres.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db`根据Postgres已经编写好的镜像设置我们的数据库容器。'
- en: '`web` sets up our server’s container by instructing Docker to:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web`通过指示Docker设置我们的服务器容器：'
- en: Use the Dockerfile within the current directory.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前目录中使用Dockerfile。
- en: Use the specified path within the container.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中使用指定的路径。
- en: Link port 8000 within the container to port 8000 on our computer.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器内的端口8000链接到我们电脑上的端口8000。
- en: Now, we’re ready to start up our services with the command `docker-compose up`.
    This will launch both of our servers inside of new Docker containers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用命令`docker-compose up`启动我们的服务。这将启动我们两个服务器，并在新的Docker容器内运行。
- en: At this point, we may want to run commands within our Docker container to add
    database entries or run tests. To do this, we’ll first run `docker ps` to show
    all of the docker containers that are running. Then, well find the `CONTAINER
    ID` of the container we wish to enter and run `docker exec -it CONTAINER_ID bash
    -l`. This will move you inside the `usr/src/app` directory we set up within our
    container. We can run any commands we wish inside that container and then exit
    by running `CTRL-D`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可能想要在我们的Docker容器中运行命令来添加数据库条目或运行测试。为此，我们首先运行`docker ps`来显示所有正在运行的Docker容器。然后，我们将找到我们想要进入的容器的`CONTAINER
    ID`，并运行`docker exec -it CONTAINER_ID bash -l`。这将把你移动到我们在容器内设置的`usr/src/app`目录中。我们可以在那个容器内运行任何我们想要的命令，然后通过运行`CTRL-D`来退出。
- en: That’s all for this lecture! Next time, we’ll working on scaling up our projects
    and making sure they are secure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课的内容就到这里！下次，我们将致力于扩展我们的项目并确保它们的安全性。
