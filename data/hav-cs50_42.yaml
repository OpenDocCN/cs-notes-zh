- en: Lecture 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 讲
- en: 原文：[https://cs50.harvard.edu/r/notes/4/](https://cs50.harvard.edu/r/notes/4/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/r/notes/4/](https://cs50.harvard.edu/r/notes/4/)
- en: '[Welcome!](#welcome)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欢迎回来！](#welcome)'
- en: '[dplyr](#dplyr)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[dplyr](#dplyr)'
- en: '[`select`](#select)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`（#select）'
- en: '[`filter`](#filter)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`（#filter）'
- en: '[Pipe Operator](#pipe-operator)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[管道操作符](#pipe-operator)'
- en: '[`arrange`](#arrange)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrange`（#arrange）'
- en: '[`distinct`](#distinct)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`（#distinct）'
- en: '[Writing Data](#writing-data)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[写入数据](#writing-data)'
- en: '[`group_by`](#group_by)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_by`（#group_by）'
- en: '[`summarize`](#summarize)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summarize`（#summarize）'
- en: '[`ungroup`](#ungroup)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ungroup`（#ungroup）'
- en: '[tidyr](#tidyr)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[tidyr](#tidyr)'
- en: '[Tidy Data](#tidy-data)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[整洁数据](#tidy-data)'
- en: '[Normalizing](#normalizing)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[标准化](#normalizing)'
- en: '[Pivoting](#pivoting)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[旋转](#pivoting)'
- en: '[stringr](#stringr)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[stringr](#stringr)'
- en: '[Summing Up](#summing-up)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Welcome!
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎回来！
- en: Welcome back to CS50’s Introduction to Programming with R!
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎回到 CS50 的 R 编程入门课程！
- en: Today, we will be learning about tidying data. Indeed, you can imagine many
    times when tables and data may not be in the shape one would hope!
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将学习如何整理数据。确实，你可以想象出很多次，表格和数据可能不会是人们希望的样子！
- en: '*Packages* are bits of code created by developers that we can install and load
    into our R programs. These packages can give one functionality within R that does
    not come natively.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包* 是开发者创建的代码片段，我们可以将其安装并加载到我们的 R 程序中。这些包可以在 R 中提供一些原生不包含的功能。'
- en: Packages are stored in R’s *library*. As such, you can load packages with the
    `library` function.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包存储在 R 的 *library* 中。因此，你可以使用 `library` 函数来加载包。
- en: dplyr
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dplyr
- en: '[dplyr](https://dplyr.tidyverse.org/) is a package within the [tidyverse](https://www.tidyverse.org/)
    that includes functions to manipulate data.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[dplyr](https://dplyr.tidyverse.org/) 是 [tidyverse](https://www.tidyverse.org/)
    中的一个包，它包含用于操作数据的函数。'
- en: Within dplyr, a data set called `storms` is included, which includes observations
    of storm data from [NOAA](https://www.noaa.gov/), the United States’ National
    Oceanic and Atmospheric Administration.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 dplyr 中，包含了一个名为 `storms` 的数据集，它包含了来自美国国家海洋和大气管理局 [NOAA](https://www.noaa.gov/)
    的风暴数据观测。
- en: After loading dplyr or the tidyverse, the `storms` data set can be loaded by
    simply typing `storms` in the R console.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加载 dplyr 或 tidyverse 之后，只需在 R 控制台中输入 `storms` 即可加载 `storms` 数据集。
- en: Upon typing `storms` notice that a *tibble* is displayed. A *tibble* is tidyverse’s
    “reimagining” of R’s data frame. Notice how rows, row numbers, and various columns
    are included and labeled. Further, notice the text color that is employed in the
    *tibble*.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你输入 `storms` 时，注意会显示一个 *tibble*。*tibble* 是 tidyverse 对 R 的数据框的“重新构想”。注意行、行号和各种列是如何包含并标记的。此外，注意
    *tibble* 中使用的文本颜色。
- en: '`select`'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`select`'
- en: 'Let’s locate the strongest storm in the data set. First, let’s remove the columns
    we don’t need. Consider the following program:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们定位数据集中最强的风暴。首先，让我们删除我们不需要的列。考虑以下程序：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice how the `select` function within dplyr allows one to determine which
    columns will be included in a data frame or tibble. `select`’s first argument
    is the data frame (or tibble) to operate on: `storms`. `select`’s second argument
    is the vector of columns to be selected. In this case, however, a `!` is employed:
    a `!` indicates that the proceeding column names are instead to be excluded. Alternatively,
    a `-` has the same functionality. Running this code will simplify the tibble by
    removing the above columns.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 dplyr 中的 `select` 函数允许你确定哪些列将包含在数据框或 tibble 中。`select` 的第一个参数是要操作的（数据框或
    tibble）：`storms`。`select` 的第二个参数是要选择的列的向量。然而，在这种情况下，使用了 `!`：一个 `!` 表示后面的列名将被排除。或者，`-`
    也有相同的功能。运行此代码将通过删除上述列来简化 tibble。
- en: Typing out all these columns is a bit cumbersome!
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出所有这些列有点繁琐！
- en: 'Helper functions like `contains`, `starts_with`, or `ends_with` can help with
    this. Consider the following code:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像这样的辅助函数 `contains`、`starts_with` 或 `ends_with` 可以帮助完成这项工作。考虑以下代码：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how `ends_with` is employed to exclude all columns that end with *diameter*.
    Less code is employed, but the result is the same as before.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `ends_with` 被用来排除所有以 *diameter* 结尾的列。使用的代码更少，但结果与之前相同。
- en: '`filter`'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`filter`'
- en: Another helpful function is `filter`, which can be used to filter rows from
    the data frame.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个有用的函数是 `filter`，它可以用来从数据框中筛选行。
- en: 'Consider the following code:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the only rows included are those that include `hurricane` in the
    `status` column.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，只有包含 `status` 列中 `hurricane` 的行被包含在内。
- en: Notice how the latest examples have dropped the `dplyr::` syntax in the first
    example. Turns out you don’t need to name the specific package in which a function
    is defined, unless two or more packages define a function with the same name.
    In that case, you’ll need to remove ambiguity by specifying which package’s function
    you want to use.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意最新的示例在第一个示例中已经删除了 `dplyr::` 语法。结果是，你不需要命名定义函数的特定包，除非两个或多个包定义了具有相同名称的函数。在这种情况下，你需要通过指定想要使用哪个包的函数来消除歧义。
- en: Pipe Operator
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道操作符
- en: 'In R, the *pipe operator* is signified by `|>`, which allows one to “pipe”
    data into a specific function. For example, consider the following code:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 R 中，*管道操作符* 用 `|>` 表示，允许将数据“管道”到特定的函数中。例如，考虑以下代码：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how `storms` is piped to `select`, implicitly becoming `select`’s first
    argument. Then, notice how the return value of `select` is piped to `filter`,
    implicitly becoming `filter`’s first argument. When you use the pipe operator,
    you can avoid nesting function calls and write your code more sequentially.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `storms` 是如何被管道到 `select` 的，隐式地成为 `select` 的第一个参数。然后，注意 `select` 的返回值是如何被管道到
    `filter` 的，隐式地成为 `filter` 的第一个参数。当你使用管道操作符时，你可以避免嵌套函数调用，并按顺序编写代码。
- en: '`arrange`'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`arrange`'
- en: 'Now let’s use the `arrange` function to sort our rows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们使用 `arrange` 函数来排序我们的行：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how the return value of the `select` function is piped to `filter`, the
    return value of which is then piped to `arrange`. The rows in the resulting data
    frame are arranged in descending order by value of the `wind` column.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `select` 函数的返回值是如何被管道到 `filter` 的，然后 `filter` 的返回值又被管道到 `arrange`。结果数据框中的行按
    `wind` 列的值降序排列。
- en: '`distinct`'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`distinct`'
- en: You may notice that this tibble includes many rows of the same storm. Because
    this data includes many observations of the same storms, this is not a surprise.
    However, would it not be nice to be able to find only *distinct* storms?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会注意到这个 tibble 包含许多相同风暴的行。因为这个数据包含许多相同风暴的观测，所以这并不奇怪。然而，不是很好奇能够找到只有 *distinct*
    飓风吗？
- en: The `distinct` function allows one to get back distinct items in our tibble.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct` 函数允许我们在 tibble 中获取独特的项目。'
- en: Distinct returns distinct rows finding duplicate rows and returning the first
    row from the set of duplicates.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Distinct returns distinct rows, finding duplicate rows and returning the first
    row from the set of duplicates.
- en: By default, `distinct` will consider rows to be duplicate only if *all* values
    in a row match *all* values in another row.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`distinct` 只在行的所有值与另一行的所有值完全匹配时才将行视为重复。
- en: 'However, you can tell `distinct` which values to consider when determining
    whether rows are duplicates. Consider the following code that leverages this ability:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，你可以告诉 `distinct` 在确定行是否重复时考虑哪些值。考虑以下利用这一功能的代码：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that `distinct` is told to only look at the `name` and `year` of each
    storm to determine if it is a distinct item. `.keep_all = TRUE` tells `distinct`
    to still return all the columns for each row.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `distinct` 被告知只查看每个风暴的 `name` 和 `year` 以确定它是否是独特项目。`.keep_all = TRUE` 告诉
    `distinct` 仍然返回每行的所有列。
- en: Writing Data
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入数据
- en: It’s possible for us to save our data for later in a CSV file.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将数据保存到 CSV 文件中以便以后使用。
- en: 'Consider the following code:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how the result of the first block of code is stored as `hurricanes`.
    To store `hurricanes` as a CSV file, `select` first chooses 3 particular columns
    (`year`, `name`, and `wind`) which are written to a file named `hurricanes.csv`.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意第一个代码块的结果被存储为 `hurricanes`。要将 `hurricanes` 保存为 CSV 文件，`select` 首先选择 3 个特定的列（`year`、`name`
    和 `wind`），并将它们写入名为 `hurricanes.csv` 的文件中。
- en: '`group_by`'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`group_by`'
- en: Let’s now find the most powerful hurricane in each year.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们来找出每年最强大的飓风。
- en: 'Consider the following code:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how `hurricanes.csv` is read into `hurricanes`. Then, the function `group_by`
    is employed to group together all hurricanes in each year. For each group, the
    group is arranged in descending order by `wind` using `arrange(desc(wind))`. Finally,
    `slice_head` is used to output the top row from each group. Thus, the strongest
    storm from each year is presented.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意如何将 `hurricanes.csv` 读取到 `hurricanes` 中。然后，使用 `group_by` 函数将每年所有的飓风分组在一起。对于每个组，使用
    `arrange(desc(wind))` 按照风速降序排列。最后，使用 `slice_head` 输出每个组的顶部行。因此，展示了每年最强的风暴。
- en: '`slice_max` selects the largest values within a variable. Consider how this
    can be employed in our code:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice_max` 在变量中选择最大值。考虑一下我们如何在代码中应用这一点：'
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that `hurricanes` is grouped by `year`. Then, the highest value of `wind`
    is presented using `slice_max`. Doing so eliminates the need for `arrange(desc(wind))`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`hurricanes`是按`year`分组的。然后，使用`slice_max`展示了`wind`的最高值。这样做消除了对`arrange(desc(wind))`的需求。
- en: '`summarize`'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`summarize`'
- en: 'What if we wanted to know the number of hurricanes each year? Consider the
    following code:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想知道每年有多少次飓风？考虑以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how the function `summarize`, employing `n`, counts the number of rows
    in each group.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到函数`summarize`使用`n`来计算每个组中的行数。
- en: '`ungroup`'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ungroup`'
- en: 'Looking at our `hurricanes` data frame, you will notice that there are groups
    present. Indeed, these groups are by `year`. There will be times in future activities
    where you may wish to ungroup items within your data. Accordingly, consider the
    following:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们的`hurricanes`数据框，你会注意到存在分组。实际上，这些分组是根据`year`进行的。在未来的活动中，你可能会希望取消数据中的分组。因此，考虑以下内容：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the `ungroup` command is employed to remove the groups of the tibble.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`ungroup`命令被用来移除tibble的分组。
- en: tidyr
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tidyr
- en: dplyr is quite useful when data is already well organized.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据已经很好地组织时，dplyr非常有用。
- en: What about situations where the data is not already well organized?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据尚未很好地组织的情况，又该如何处理？
- en: For that, the tidyr package can be useful!
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这一点，tidyr包可能很有用！
- en: Tidy Data
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整洁数据
- en: According to the philosophy of the tidyverse, there are three principles that
    guide what we would call *tidy data*.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据tidyverse的哲学，有三个原则指导我们所说的*整洁数据*。
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When evaluating data, best to look at the above three principles to see if they
    are observed.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在评估数据时，最好查看上述三个原则，看看它们是否被观察到。
- en: Normalizing
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正常化
- en: '*Normalizing* is the process of converting data such that they fulfill the
    aforementioned principles.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正常化*是将数据转换为满足上述原则的过程。'
- en: Normalizing can also refer to converting data such that they fulfill better
    design principles beyond the above guidelines.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常化也可以指将数据转换为满足上述指南之外更好的设计原则。
- en: 'Download the `students.csv` file from the course files and place it in your
    working directory. Create new code as follows:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从课程文件中下载`students.csv`文件并将其放置在你的工作目录中。创建以下新代码：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that this code loads a CSV file called `students.csv` and stores these
    values in `students`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这段代码加载了一个名为`students.csv`的CSV文件，并将这些值存储在`students`中。
- en: Examining this data, you may see how they do not follow the principles we mentioned
    previously. Which principles do you observe not being followed?
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查这些数据，你可能看到它们并没有遵循我们之前提到的原则。哪些原则没有被遵循？
- en: Pivoting
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: 'In the `students` data set, you might notice there are row values that should
    instead be column names: “major” and “GPA.” To be clear, this data set violates
    the second principle of tidy data: each way a student can vary is *not* a column.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`students`数据集中，你可能会注意到有一些行值本应该是列名：“major”和“GPA”。为了清楚起见，这个数据集违反了整洁数据的第二个原则：学生的任何变化方式*都不是*一列。
- en: We can *pivot* the data set to turn those variables into columns, thanks to
    `pivot_wider`! `pivot_wider` transforms a data set that is “longer” than it should
    be (i.e., one with variables as row values) and makes it “wider” (i.e., turns
    those variables into columns).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过`pivot_wider`将数据集旋转，将这些变量转换为列。`pivot_wider`将一个“更长”的数据集（即具有变量作为行值的数据集）转换为“更宽”的数据集（即将这些变量转换为列）。
- en: '`pivot_wider` will transform the `students` data set from the below:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pivot_wider`会将`students`数据集从以下内容转换：'
- en: '![`students` before pivoting](../Images/b2abe2d0d26093da0fd1d68a9802293f.png)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![转换前的`students`](../Images/b2abe2d0d26093da0fd1d68a9802293f.png)'
- en: 'into the following:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转换为以下内容：
- en: '![`students` after pivoting](../Images/7ba32632526b205660d8d18e34b724bf.png)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![转换后的`students`](../Images/7ba32632526b205660d8d18e34b724bf.png)'
- en: 'But how? Consider the following usage:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但如何操作呢？考虑以下用法：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice how `pivot_wider` takes several arguments, explained here:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`pivot_wider`有几个参数，这里进行解释：
- en: The first is the data set to operate on, `students`.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一是要操作的数据集，`students`。
- en: The second argument, `id_cols`, specifies which column should ultimately be
    unique in the transformed data set. Notice how, before `pivot_wider`’s transformation,
    there are duplicate values in the `student` column. After `pivot_wider`’s transformation,
    there are unique values in the `student` column.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数，`id_cols`，指定了在转换后的数据集中哪一列应该是唯一的。注意，在`pivot_wider`的转换之前，`student`列中存在重复值。在`pivot_wider`的转换之后，`student`列中存在唯一值。
- en: The third argument, `names_from`, specifies which column contains values that
    should instead be variables (columns). Notice how the values in the `attribute`
    column become columns themselves after `pivot_wider`’s transformation.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数，`names_from`，指定了包含应作为变量（列）的值的列。注意`pivot_wider`转换后，`attribute`列中的值是如何变成列的。
- en: Finally, the fourth argument, `values_from`, specifies the column from which
    to populate the values of the new columns. Notice how the values in the `value`
    column are used to populate the new columns after `pivot_wider`’s transformation.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，第四个参数，`values_from`，指定了填充新列值的列。
- en: Because our data is so much more tidy, we can do so much more with the data!
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的数据如此整洁，我们可以用数据做更多的事情！
- en: 'Consider the following:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how this program leverages `pivot_wider` and tidyr to discover the average
    GPA of the students. `GPA` in `students` is converted to a numeric value. Then,
    pipe syntax is used to find the mean of the GPAs.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个程序是如何利用`pivot_wider`和tidyr来发现学生的平均GPA。`students`中的`GPA`被转换为数值。然后，使用管道语法来找到GPA的平均值。
- en: stringr
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stringr
- en: The process we described above works well when the values themselves are clean.
    However, what about when the values themselves aren’t tidy?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们上面描述的过程在数值本身干净的情况下效果很好。然而，当数值本身不整洁时怎么办呢？
- en: '`stringr` offers us a means by which to tidy strings. Download `shows.csv`
    from the course files and place this file in your working directory. Consider
    the following program:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringr`为我们提供了一种整理字符串的方法。从课程文件中下载`shows.csv`并将其放置在你的工作目录中。考虑以下程序：'
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how shows are grouped by `show`. Then, the number of `votes` is computed.
    Finally, the `votes` are sorted in descending order.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到节目是如何按`show`分组。然后，计算`votes`的数量。最后，按降序排列`votes`。
- en: 'Looking at the result of this program, you can see that there are many versions
    of *Avatar: The Last Airbender*. We should probably address the whitespace issues
    first.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察这个程序的结果，你可以看到有多个版本的*《阿凡达：最后的气宗》*。我们可能首先应该解决空白问题。
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how `str_trim` is used to remove whitespace in the front or end of each
    record. `str_squish` is then used to remove extra whitespace *between* the characters.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`str_trim`是如何用来移除每条记录的前后空白。然后，`str_squish`用来移除字符之间的额外空白。
- en: 'While all this is very good, there are still some inconsistencies with capitalization.
    We can resolve as follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这一切都非常好，但在大写方面仍然存在一些不一致。我们可以这样解决：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how `str_to_title` is used to force title casing on each string.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`str_to_title`是如何用来强制每个字符串使用标题大小写的。
- en: 'Finally, we can address spelling variants of *Avatar: The Last Airbender*:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以解决*《阿凡达：最后的气宗》*的拼写变体问题：
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice how `str_detect` is used to locate instances of `Avatar`. Each of these
    is converted to `Avatar: The Last Airbender`.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意`str_detect`是如何用来定位`Avatar`实例。每个这些都被转换为`Avatar: The Last Airbender`。'
- en: While these tools can be quite helpful, consider cases where you may need to
    employ caution and not overwrite correct entries. For example, there are many
    movies called *Avatar*! How do we know whether voters didn’t mean to vote for
    those movies?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这些工具非常有帮助，但考虑你可能需要谨慎行事，不要覆盖正确的条目。例如，有许多名为*《阿凡达》*的电影！我们如何知道投票者不是有意为这些电影投票？
- en: Summing Up
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this lesson, you learned how to tidy data in R. Specifically, you learned
    three new packages, which are each part of the tidyverse:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何在R中整理数据。具体来说，你学习了三个新的包，它们都是tidyverse的一部分：
- en: dplyr
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dplyr
- en: tidyr
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tidyr
- en: stringr
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stringr
- en: See you next time when we discuss how to visualize our data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 次次见，届时我们将讨论如何可视化我们的数据。
