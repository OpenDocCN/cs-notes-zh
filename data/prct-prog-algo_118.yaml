- en: 6.6   Intractability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6   难解性
- en: 原文：[https://algs4.cs.princeton.edu/66intractability](https://algs4.cs.princeton.edu/66intractability)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/66intractability](https://algs4.cs.princeton.edu/66intractability)
- en: This section under construction. The goal of complexity theory is to understand
    the nature of efficient computation. We have learned about analysis of algorithms,
    which enables us to classify *algorithms* according to the amount of resources
    they will consume. In this section, we will learn about a rich class of *problems*
    for which nobody has been able to devise an efficient algorithm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在建设中。复杂性理论的目标是理解高效计算的本质。我们已经学习了算法分析，这使我们能够根据它们消耗的资源量对*算法*进行分类。在本节中，我们将学习一个丰富的*问题*类别，至今还没有人能够设计出高效的算法。
- en: Computational complexity.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算复杂性。
- en: As digital computers were developed in the 1940s and 1950s, the Turing machine
    served as the theoretical model of computation. In the 1960s Hartmanis and Stearns
    proposed measuring the time and memory needed by a computer as a function of the
    input size. They defined complexity classes in terms of Turing machines and proved
    that some problems have "an inherent complexity that cannot be circumvented by
    clever programming." They also proved a formal version ([time hierarchy theorem](http://en.wikipedia.org/wiki/Time_hierarchy_theorem))
    of the intuitive idea that if given more time or space, Turing machines can compute
    more things. In other words, no matter how hard a problem is (time and space requirements),
    there are always harder problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字计算机在 1940 年代和 1950 年代的发展，图灵机成为计算的理论模型。在 1960 年代，Hartmanis 和 Stearns 提出了将计算机所需的时间和内存作为输入大小的函数来衡量。他们以图灵机为基础定义了复杂性类，并证明了一些问题具有“无法通过巧妙编程规避的固有复杂性”。他们还证明了直观观念的一个正式版本（[时间层次定理](http://en.wikipedia.org/wiki/Time_hierarchy_theorem)），即如果给予更多时间或空间，图灵机可以计算更多事物。换句话说，无论问题有多难（时间和空间要求），总会有更难的问题。
- en: Computational complexity is the art and science of determining resource requirements
    for different *problems*. Computational complexity deals with assertions about
    *any* conceivable algorithm for a problem. Making such statements is significantly
    more challenging than understanding the running time of one particular algorithm
    for the problem since we must reason about all possible algorithms (even those
    not yet discovered). This makes computational complexity an exciting, yet daunting,
    field of study. We will survey some of its most important ideas and practical
    outgrowths.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复杂性是确定不同*问题*的资源需求的艺术和科学。计算复杂性涉及对*任何*可能的问题算法的断言。做出这样的断言比理解问题的一个特定算法的运行时间要困难得多，因为我们必须推理所有可能的算法（甚至是尚未发现的算法）。这使得计算复杂性成为一个令人兴奋但又令人望而生畏的研究领域。我们将概述一些其最重要的思想和实际产物。
- en: Polynomial time.
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式时间。
- en: We have analyzed the running time of an algorithm as a function of its input
    size. When solving a given problem, we prefer an algorithm that takes 8 N log
    N steps to one that takes 3 N² steps, since when N is large, the first algorithm
    is significantly faster than the first. The second algorithm will ultimately solve
    the same problem (but it might take hours instead of seconds). In contrast, an
    exponential time algorithm has a different qualitative behavior. For example,
    a brute force algorithm for the TSP might take N! steps. Even if each electron
    in the universe (10^(79)) had the power of today's fastest supercomputer (10^(12)
    instructions per second), and each worked for the life of the universe (10^(17)
    seconds) on solving the problem, it would barely make a dent in solving a problem
    with N = 1,000 since 1000! >> 10^(1000) >> 10^(79) * 10^(12) * 10^(17). Exponential
    growth dwarfs technological change. We refer to any algorithm whose running time
    is bounded by a polynomial in the input size (e.g., N log N or N^2) as a *polynomial-time*
    algorithm. We say that a problem is *intractable* if there is no polynomial-time
    algorithm for the problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了算法的运行时间作为其输入大小的函数。在解决给定问题时，我们更喜欢一个需要 8 N log N 步的算法，而不是需要 3 N² 步的算法，因为当
    N 很大时，第一个算法比第二个算法快得多。第二个算法最终会解决相同的问题（但可能需要几小时而不是几秒）。相比之下，指数时间算法具有不同的定性行为。例如，对于TSP的暴力算法可能需要
    N! 步。即使宇宙中的每个电子（10^(79)）都具有今天最快超级计算机（每秒 10^(12) 条指令）的能力，并且每个电子在解决问题上工作了宇宙寿命（10^(17)
    秒），也几乎无法解决 N = 1,000 的问题，因为 1000! >> 10^(1000) >> 10^(79) * 10^(12) * 10^(17)。指数增长使技术变革相形见绌。我们将任何运行时间受输入大小多项式限制的算法（例如
    N log N 或 N^2）称为*多项式时间*算法。如果问题没有多项式时间算法，则称该问题为*难解*问题。
- en: Create log-log scale plot of N, N³, N⁵, N^(10), 1.1^N, 2^N, N! as in Harel p.
    74.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 N、N³、N⁵、N^(10)、1.1^N、2^N、N! 的对数对数比例图，如 Harel 第 74 页所示。
- en: As programmers gained more experience with computation, it became evident that
    polynomial-time algorithms were useful and exponential-time algorithms were not.
    In a very [influential paper](../papers/edmonds.pdf), Jack Edmonds referred to
    polynomial algorithms as "good algorithms" and argued that polynomial time is
    a good surrogate for efficient computation. Kurt Godel wrote [a letter to von
    Neumann (p. 9)](http://www.cs.berkeley.edu/~luca/cs172/sipser92history.pdf) in
    1956 that contains the (implicit) notion that polynomiality is a desirable feature.
    Earlier (1953), von Neumann recognized the qualitative difference between polynomial
    and exponential algorithms. The idea of classifying problems according to polynomial
    and exponential time profoundly changed the way people thought about computational
    problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序员对计算的经验增加，人们逐渐意识到多项式时间算法是有用的，而指数时间算法则不是。在一篇非常有影响力的论文中，Jack Edmonds 将多项式算法称为“好算法”，并认为多项式时间是高效计算的一个很好的替代。Kurt
    Godel 在 1956 年给 von Neumann 写了一封信（第 9 页），其中包含了多项式性是一个可取特征的（隐含）概念。早在 1953 年，von
    Neumann 就认���到了多项式和指数算法之间的定性差异。根据多项式和指数时间对问题进行分类的想法深刻地改变了人们对计算问题的看法。
- en: NP.
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NP。
- en: Informally we define a *search problem* as a computational problem where we
    are looking for a solution among a (potentially huge) number of possibilities,
    but such that when we find a solution, we can easily check that it solves our
    problem. Given an instance I of a *search problem* (some input data specifying
    the problem), our goal is to find a solution S (an entity that meets some pre-specified
    criterion) or report that no such solution exists. To be a search problem, we
    require that it be easy to *check* that S is indeed a solution. By easy, we mean
    polynomial-time in the size of the input I. The complexity class *NP* is the set
    of all search problems. Here are a few examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，我们将*搜索问题*定义为一个计算问题，我们在（可能巨大的）可能性中寻找解决方案，但是当我们找到解决方案时，我们可以轻松检查它是否解决了我们的问题。给定*搜索问题*的一个实例I（指定问题的一些输入数据），我们的目标是找到一个解决方案S（符合某些预先指定标准的实体）或报告不存在这样的解决方案。为了成为搜索问题，我们要求很容易*检查*
    S 是否确实是一个解决方案。在这里，我们指的是在输入I的大小上是多项式时间。复杂性类*NP*是所有搜索问题的集合。以下是一些例子。
- en: '*Linear systems of equations.* Given a system of linear equations Ax = b, find
    a solution x that satisfies the equations (if one exists). The problem is in NP
    because if we are given a purported solution x, we can check that Ax = b by plugging
    in x and verifying each equation.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性方程组。*给定线性方程系统Ax = b，找到满足方程的解x（如果存在）。这个问题属于NP，因为如果我们得到一个所谓的解x，我们可以通过将x代入并验证每个方程来检查Ax
    = b。'
- en: '*Linear programming.* Given a system of linear inequalities Ax ≤ b, find a
    solution x that satisfies the inequalities (if one exists). The problem is in
    NP because if we are given a purported solution x, we can check that Ax ≤ b by
    plugging in x and verifying each inequality.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性规划。*给定线性不等式系统Ax ≤ b，找到满足不等式的解x（如果存在）。这个问题属于NP，因为如果我们得到一个所谓的解x，我们可以通过将x代入并验证每个不等式来检查Ax
    ≤ b。'
- en: '*Integer linear programming.* Given a system of linear inequalities Ax ≤ b,
    find a binary (0/1) solution x that satisfies the inequalities (if one exists).
    The problem is in NP because if we are given a purported solution x, we can check
    that Ax ≤ b by plugging in x and verifying each inequality.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数线性规划。*给定线性不等式系统Ax ≤ b，找到满足不等式的二进制（0/1）解x（如果存在）。这个问题属于NP，因为如果我们得到一个所谓的解x，我们可以通过将x代入并验证每个不等式来检查Ax
    ≤ b。'
- en: While it is easy to check a proposed solution to all three problems, how difficult
    is it to *find* a solution from scratch?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查对这三个问题的提议解决方案很容易，但是从头开始找到解决方案有多困难？
- en: 'Remark: our definition of NP is slightly non-standard. Historically, complexity
    classes were defined in terms of decision problems (yes-no problems). For example,
    given a matrix *A* and a vector *b*, does there exist a solution *x* such that
    *Ax* = *b*?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：我们对NP的定义略有不同。在历史上，复杂性类别是根据决策问题（是-否问题）来定义的。例如，给定矩阵*A*和向量*b*，是否存在解*x*使得*Ax*
    = *b*？
- en: P.
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P。
- en: 'The complexity class P is the set of all search problems solvable in polynomial-time
    (on a deterministic Turing machine). As before, we define P in terms of search
    problems (instead of decision problems). It captures most of the problems that
    we can solve in practice on real machines. We list a few examples below:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性类P是所有可以在多项式时间内解决的搜索问题的集合（在确定性图灵机上）。与以前一样，我们根据搜索问题（而不是决策问题）来定义P。它涵盖了我们可以在实际机器上解决的大多数问题。以下列出了一些例子：
- en: '| Problem | Description | Algorithm | Instance | Solution |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 描述 | 算法 | 实例 | 解决方案 |'
- en: '| GCD | Find the greatest common divisor of two integers x and y. | Euclid''s
    algorithm (Euclid, 300 BCE) | 34, 51 | 17 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| GCD | 找到两个整数x和y的最大公约数。 | 欧几里得算法（欧几里得，公元前300年） | 34, 51 | 17 |'
- en: '| STCONN | Given a graph G and two vertices s and t, find a path from s to
    t. | BFS or DFS (Theseus) |  |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| STCONN | 给定图G和两个顶点s和t，找到从s到t的路径。 | BFS或DFS（Theseus） |  |  |'
- en: '| SORT | Find permutation that puts elements in ascending order. | Mergesort
    (von Neumann, 1945) | 2.3 8.5 1.2 9.1 2.2 0.3 | 5 2 4 0 1 3 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| SORT | 找到将元素按升序排列的排列。 | 归并排序（冯·诺伊曼，1945） | 2.3 8.5 1.2 9.1 2.2 0.3 | 5 2
    4 0 1 3 |'
- en: '| PLANARITY | Given a graph G, draw it in the plane so that no two edges cross.
    | (Hopcroft-Tarjan, 1974) |  |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| PLANARITY | 给定一个图G，在平面上画出它，使得没有两条边相交。 | （Hopcroft-Tarjan, 1974） |  |  |'
- en: '| LSOLVE | Given a matrix A and a vector b, find a vector x such Ax = b. |
    Gaussian elimination (Edmonds, 1967) | x+y=1 2x+4y=3 | x = 1/2 y = 1/2 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| LSOLVE | 给定矩阵A和向量b，找到一个向量x使得Ax = b。 | 高斯消元（Edmonds, 1967） | x+y=1 2x+4y=3
    | x = 1/2 y = 1/2 |'
- en: '| LP | Given a matrix A and a vector b, find a vector x such that Ax ≤ b? |
    Ellipsoid algorithm (Khachiyan, 1979) | x+y≤1 2x+4y≤3 | x = 0 y = 0 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| LP | 给定矩阵A和向量b，找到一个向量x使得Ax ≤ b？ | 椭球算法（Khachiyan, 1979） | x+y≤1 2x+4y≤3 |
    x = 0 y = 0 |'
- en: '| DIOPHANTINE | Given a (sparse) polynomial of one variable with integer coefficients,
    find an integral root? | (Smale et. al, 1999) | x⁵ - 32 | x = 2 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| DIOPHANTINE | 给定一个具有整数系数的（稀疏）一元多项式，找到一个整数根？ | （Smale等，1999） | x⁵ - 32 | x
    = 2 |'
- en: Extended Church-Turing Thesis.
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展的丘奇-图灵论断。
- en: 'In the mid 1960s Cobham and Edmonds independently observed that the set of
    problems solvable in a polynomial number of steps remains invariant over a very
    wide range of computational models, from deterministic Turing machines to RAM
    machines. The extended Church-Turing thesis asserts that the Turing machine is
    as efficient as any physical computing device. That is, P is the set of search
    problems solvable in polynomial-time *in this universe*. If some piece of hardware
    solves a problem of size N in time T(N), the extended Church-Turing thesis asserts
    that a deterministic Turing machine can do it in time T(N)^k for some fixed constant
    k, where k depends on the particular problem. Andy Yao expresses the broad implications
    of this thesis:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在1960年代中期，Cobham和Edmonds独立观察到，在一个广泛的计算模型范围内，可以在多项式步骤内解决的问题集保持不变，从确定性图灵机到RAM机。扩展的丘奇-图灵论题断言图灵机与任何物理计算设备一样高效。也就是说，P是在这个宇宙中可以在多项式时间内解决的搜索问题的集合。如果某个硬件解决了大小为N的问题，时间为T(N)，扩展的丘奇-图灵论题断言确定���图灵机可以在时间T(N)^k内解决它，其中k是某个固定常数，k取决于特定问题。Andy
    Yao表达了这个论题的广泛含义：
- en: They imply that at least in principle, to make future computers more efficient,
    one only needs to focus on improving the implementation technology of present-day
    computer designs.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们暗示，至少从原理上讲，要使未来的计算机更加高效，只需要专注于改进现代计算机设计的实现技术。
- en: In other words, any *reasonable* model of computation can be efficiently simulated
    on a (probabilistic) Turing machine. The extended Church-Turing thesis is true
    for all known physical general purpose computers. For random access machines (e.g.,
    your PC or Mac) the constant k = 2\. So, for example, if a random access machine
    can perform a computation in time N^(3/2), then a Turing machine can do the same
    computation in time N³.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何*合理*的计算模型都可以在（概率性）图灵机上高效模拟。对于所有已知的物理通用计算机，扩展的丘奇-图灵论题都是成立的。对于随机访问机器（例如您的PC或Mac），常数k
    = 2。因此，例如，如果随机访问机器可以在时间N^(3/2)内执行计算，则图灵机可以在时间N³内执行相同的计算。
- en: Does P = NP?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P = NP吗？
- en: One of the most profound scientific questions of our time is whether [P = NP](http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP).
    That is, can all search problems be solved in polynomial time? Clay Foundation
    offers a [1 million dollar millennium prize](http://www.claymath.org/millennium/)
    for solving it. Here are some speculations on [when the question will be resolved](http://www.cs.umd.edu/~gasarch/papers/poll.ps).
    The overwhelming consensus is that P != NP, but nobody has been able to prove
    it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个时代最深刻的科学问题之一是[P = NP](http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP)。也就是说，所有搜索问题是否都能在多项式时间内解决？Clay
    Foundation为解决这个问题提供了[100万美元的千禧奖](http://www.claymath.org/millennium/)。以下是一些关于[何时解决这个问题的猜测](http://www.cs.umd.edu/~gasarch/papers/poll.ps)。压倒性的共识是P
    != NP，但没有人能够证明。
- en: '[Video](http://youtube.com/watch?v=t_bO9LilNpE) of Homer Simpson pontificating
    over P = NP, with accompanying music Erased by Paradise Lost.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[视频](http://youtube.com/watch?v=t_bO9LilNpE)中荷马·辛普森对P = NP进行演讲，伴随着《失乐园》的音乐。'
- en: Godel's letter to von Neumann anticipated the P = NP question. He recognized
    that if P = NP (satisfiability is in P), it "would have consequences of the greatest
    importance" since then "the mental work of a mathematician concerning Yes-or-No
    questions could be completely replaced by a machine." He asked for which combinatorial
    problems was there a more efficient alternative to exhaustive search.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 哥德尔写给冯·诺伊曼的信预见了P = NP问题。他意识到如果P = NP（可满足性在P中），那么“将会有最重要的后果”，因为那时“数学家关于是或否问题的思维工作可以完全被机器取代”。他询问哪些组合问题存在更有效的替代方案以避免穷举搜索。
- en: NP-completeness.
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NP完全性。
- en: 'Informally, NP-complete problems are the "hardest" problems in NP; they are
    the ones most likely to not be in P. Define: a problem is *NP-complete* if (i)
    it is in NP and (ii) every problem in NP polynomial reduces to it. Defining the
    concept of NP-completeness does not mean that such problems exist. In fact, the
    existence of NP-complete problems is an amazing thing. We cannot prove a problem
    is NP-complete by presenting a reduction from each NP problem since there are
    infinitely many of them. In the 1960s, Cook and Levin proved that SAT is NP-complete.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，NP完全问题是NP中“最难”的问题；它们最有可能不在P中。定义：如果（i）它在NP中且（ii）每个NP问题都可以多项式归约到它，则问题是*NP完全*的。定义NP完全性的概念并不意味着这样的问题存在。事实上，NP完全问题的存在是一件令人惊奇的事情。我们无法通过从每个NP问题进行归约来证明问题是NP完全的，因为它们有无限多个。在1960年代，Cook和Levin证明了SAT是NP完全的。
- en: 'This is an example of universality: if we can solve any NP-complete, then we
    can solve any problem in NP. Unique scientific discovery giving common explanation
    to all sorts of problems. It is even more amazing that there exist "natural" problems
    that are NP-complete.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是普遍性的一个例子：如果我们可以解决任何NP完全问题，那么我们就可以解决NP中的任何问题。独特的科学发现为所有类型的问题提供了共同的解释。更令人惊讶的是，存在着“自然”的NP完全问题。
- en: The impact of NP-completeness on the natural sciences has been undeniable. One
    the first NP-complete problems were discovered, intractability "spread like a
    shockwave through the space of problems", first in computer science, and then
    to other scientific disciplines. Papadimitriou lists 20 diverse scientific disciplines
    that were coping with internal questions. Ultimately, scientists discovered their
    inherent complexity after realizing that their core problems were NP-complete.
    NP-completeness is mentioned as a keyword in 6,000 scientific papers per year.
    "Captures vast domains of computational, scientific, mathematical endeavors, and
    seems to roughly delimit what mathematicians and scientists had been aspiring
    to compute feasibly." [Papadimitriou] Few scientific theories have had such a
    breadth and depth of influence.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: NP完全性对自然科学的影响是不可否认的。一旦发现了第一个NP完全问题，难以解决性质就像“冲击波一样在问题空间中蔓延”，首先是在计算机科学中，然后传播到其他科学学科。帕帕迪米特里奥列出了20个不同的科学学科，它们正在应对内部问题。最终，科学家们在意识到他们的核心问题是NP完全问题后，发现了它们固有的复杂性。每年有6000篇科学论文中提到NP完全性作为一个关键词。它“涵盖了计算、科学、数学努力的广泛领域，并似乎粗略地界定了数学家和科学家一直渴望可行计算的范围。”[帕帕迪米特里奥]很少有科学理论有如此广泛和深远的影响。
- en: '**Some NP-complete problems.** Since the discovery that SAT is NP-complete,
    tens of thousands of problems have been identified as NP-complete. In 1972, Karp
    showed that 21 of the most infamous problem s in discrete mathematics were [NP-complete](http://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems),
    including `Tsp`, `Knapsack`, `3Color`, and `Clique`. The failure of scientists
    to find an efficient algorithm for these 21 problems, despite being unaware that
    they were NP-complete, was among the first evidence suggesting that P != NP. Below
    we list a sampling of some NP-complete problems. Here are some more [NP-complete
    problems](http://en.wikipedia.org/wiki/List_of_NP-complete_problems). This is
    only meant to illustrate their diversity and pervasiveness.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些NP完全问题。** 自从发现SAT是NP完全以来，已经确定了成千上万个问题是NP完全的。1972年，卡普尔表明离散数学中最臭名昭著的21个问题是[NP完全的](http://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems)，包括`Tsp`，`Knapsack`，`3Color`和`Clique`。科学家未能为这21个问题找到有效算法，尽管他们不知道这些问题是NP完全的，这是最早表明P
    != NP的证据之一。下面列出了一些NP完全问题的样本。这里还有一些[NP完全问题](http://en.wikipedia.org/wiki/List_of_NP-complete_problems)。这只是为了说明它们的多样性和普遍性。'
- en: '*Bin Packing.* You have n items and m bins. Item i weighs w[i] pounds. Each
    bin can hold at most W pounds. Can you pack all n items into the m bins without
    violating the given weight limit?'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bin Packing.* 你有n个物品和m个箱子。第i个物品重w[i]磅。每个箱子最多可以容纳W磅。你能否将所有n个物品装入m个箱子中，而不违反给定的重量限制？'
- en: 'This problem has many industrial applications. For example, UPS may need to
    ship a large number of packages (items) from one distribution center to another.
    It wants to put them into trucks (bins), and use as few trucks as possible. Other
    NP-complete variants allow volume requirements: each 3-dimensional package takes
    up space and you also have to worry about arranging the packages within the truck.'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个问题有许多工业应用。例如，UPS可能需要从一个配送中心将大量包裹（物品）运送到另一个中心。它希望将它们放入卡车（箱子）中，并尽可能少地使用卡车。其他NP完全变体允许体积要求：每个三维包裹占用空间，你还必须担心如何在卡车内安排包裹。
- en: '*Knapsack*. You have a set of n items. Item i weighs w[i] pounds and has benefit
    b[i]. Can you select a subset of the items that have total weight less than or
    equal to W and total benefit greater than or equal to B? For example, when you
    go camping, you must select items to bring based on their weight and utility.
    Or, suppose you are burglarizing a home and can only carry W pounds of loot in
    your knapsack. Each item i weighs w[i] pounds has a street value of b[i] dollars.
    Which items should you steal?'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Knapsack*. 你有一组n个物品。第i个物品重w[i]磅，具有利益b[i]。你能否选择一些物品的子集，使得总重量小于或等于W，总利益大于或等于B？例如，当你去露营时，你必须根据它们的重量和效用选择要带的物品。或者，假设你正在入室行窃，只能在你的背包中携带W磅的赃物。每个物品i重w[i]磅，有b[i]美元的市场价值。你应该偷哪些物品？'
- en: '*Subset Sum*. Given n integers does there exists a subset of them that sum
    exactly to B? For example, suppose the integers are {4, 5, 8, 13, 15, 24, 33}.
    If B = 36 then the answer is yes (and 4, 8, 24 is a certificate). If B = 14 the
    answer is no.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Subset Sum*. 给定n个整数，是否存在一个子集，其和恰好为B？例如，假设这些整数是{4, 5, 8, 13, 15, 24, 33}。如果B
    = 36，则答案是yes（且4, 8, 24是一个证明）。如果B = 14，则答案是no。'
- en: '*Partition.* Given n integers, can you divide them into two subsets so that
    each subset sums to the same number? For example, suppose the integers are {4,
    5, 8, 13, 15, 24, 33}. Then the answer is `yes`, and {5, 13, 33} is a certificate.
    Load balancing for dual processors.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Partition.* 给定n个整数，你能将它们分成两个子集，使得每个子集的和相等吗？例如，假设这些整数是{4, 5, 8, 13, 15, 24,
    33}。那么答案是`yes`，{5, 13, 33}是一个证明。双处理器的负载平衡。'
- en: '*Integer linear programming.* Given an integer matrix A and an integer vector
    b, does there exist an integer vector x such that Ax ≤ b? This is a central problem
    in operations research since many optimization problems can be formulated in this
    way. Note the contrast to the linear programming problem presented above where
    we are looking for a *rational* vector instead of an *integer* vector. The line
    between problems which are tractable and problems which are intractable can be
    very subtle.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数线性规划.* 给定一个整数矩阵A和一个整数向量b，是否存在一个整数向量x使得Ax ≤ b？这是运筹学中的一个核心问题，因为许多优化问题可以用这种方式表达。请注意，与上面提出的线性规划问题形成对比，我们在这里寻找的是一个*有理数*向量而不是一个*整数*向量。可解问题和难解问题之间的界限可能非常微妙。'
- en: '*SAT.* Given n Boolean variables x[1], x[2], ..., x[N] and a logical formula,
    is there an assignment of truth variables that makes the formula *satisfiable*,
    i.e., true? For example, suppose the formula is'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SAT.* 给定n个布尔变量x[1]，x[2]，...，x[N]和一个逻辑公式，是否存在一个真值变量的赋值使得公式是*可满足*的，即为真？例如，假设公式是'
- en: (x[1]' + x[2] + x[3]) (x[1] + x[2]' + x[3]) (x[2] + x[3]) (x[1]' + x[2]' + x[3]')
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (x[1]' + x[2] + x[3]) (x[1] + x[2]' + x[3]) (x[2] + x[3]) (x[1]' + x[2]' + x[3]')
- en: Then, the answer is yes and (x[1], x[2], x[3]) = (true, true, false) is a certificate.
    Many applications to electronic design automation (EDA), including testing and
    verification, logic synthesis, FPGA routing, and path delay analysis. Application
    to AI, including knowledge base deduction and automatic theorem proving.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，答案是yes，(x[1]，x[2]，x[3]) = (true，true，false)是一个证书。许多应用于电子设计自动化（EDA），包括测试和验证，逻辑综合，FPGA布线和路径延迟分析。应用于人工智能，包括知识库推理和自动定理证明。
- en: 'Exercise: given two circuits C1 and C2, design a new circuit C such that some
    setting of input values makes C output true if and only if C1 and C2 are equivalent.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：给定两个电路C1和C2，设计一个新电路C，使得一些输入值的设置使得C输出为真当且仅当C1和C2等价。
- en: '*3-SAT.* Given n Boolean variables x[1], x[2], ..., x[N] and a logical formula
    in conjunction normal form (product-of-sums) with exactly 3 distinct literals
    per clause, is there an assignment of truth variables that makes the formula satisfiable?'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3-SAT。* 给定n个布尔变量x[1]，x[2]，...，x[N]和一个逻辑公式（合取范式）的逻辑公式，每个子句恰好有3个不同的文字，是否存在一个真值变量的赋值使得公式可满足？'
- en: '*Clique*. Given n people and a list of pairwise friendships. Is there a group
    or *clique* of k people such that every possible pair of people within the group
    are friends? It is convenient to draw the *friendship graph*, where we include
    a node for each person and an edge connecting each pair of friends. In the following
    example with n = 11 and k = 4, the answer is `yes`, and {2, 4, 8, 9} is a certificate.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*团。* 给定n个人和一组成对友谊关系。是否存在一个由k个人组成的团或*团*，使得团内每对可能的人都是朋友？在绘制*友谊图*时很方便，其中我们为每个人包括一个节点，并连接每对朋友的边。在以下示例中，n
    = 11，k = 4，答案是`yes`，{2, 4, 8, 9}是一个证书。'
- en: '*Longest path*. Given a set of nodes and pairwise distances between nodes,
    does there exists a simple path of length at least L connecting some pair of nodes?'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最长路径。* 给定一组节点和节点之间的距离，是否存��一条长度至少为L的简单路径连接某对节点？'
- en: '*Machine Scheduling*. Your goal is to process n jobs on m machines. For simplicity,
    assume each machine can process any one job in 1 time unit. Also, there can be
    *precedence constraints*: perhaps job j must finish before job k can start. Can
    you schedule all of the jobs to finish in L time units?'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器调度。* 你的目标是在m台机器上处理n个作业。为简单起见，假设每台机器可以在1个时间单位内处理任何一个作业。此外，可能存在*优先约束*：也许作业j必须在作业k开始之前完成。你能安排所有作业在L个时间单位内完成吗？'
- en: 'Scheduling problems have a huge number of applications. Jobs and machines can
    be quite abstract: to graduate Princeton you need to take n different courses,
    but are unwilling to take more than m courses in any one semester. Also, many
    courses have prerequisites (you can''t take COS 226 or 217 before taking 126,
    but it is fine to take 226 and 217 at the same time). Can you graduate in L semesters?'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调度问题有大量的应用。工作和机器可能相当抽象：为了毕业普林斯顿，你需要修读n门不同的课程，但不愿意在任何一个学期修读超过m门课程。此外，许多课程有先修课程（在修读126之前不能修读COS
    226或217，但可以同时修读226和217）。你能在L个学期内毕业吗？
- en: '*Shortest Common Superstring*. Given the genetic alphabet { a, t, g, c } and
    N DNA fragments (e.g., ttt, atggtg, gatgg, tgat, atttg) is there a DNA sequence
    with K or fewer characters that contains every DNA fragment? Suppose K = 11 in
    the above example; then the answer is `yes` and `atttgatggtg` is a certificate.
    Applications to computational biology.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最短公共超字符串。* 给定基因字母表{ a，t，g，c }和N个DNA片段（例如，ttt，atggtg，gatgg，tgat，atttg），是否存在一个包含K个或更少字符的DNA序列，其中包含每个DNA片段？假设在上面的示例中K
    = 11；那么答案是`yes`，`atttgatggtg`是一个证书。应用于计算生物学。'
- en: '*Protein folding.* Proteins in organism *fold* in three dimensional dimensional
    space in a very specific way, to their *native state*. This geometric pattern
    determines the behavior and function of a protein. One of the most widely used
    folding models is the two dimensional hydrophilic-hydrophobic (H-P) model. In
    this model, a protein is a sequence of 0s and 1s, and the problem is to embed
    it into a 2-d lattice such that the number of pairs of adjacent 1s in the lattice,
    but not in the sequence (its energy), is minimized. For example, the sequence
    011001001110010 is embedded in the figure below in such a way that there are 5
    new adjacent pairs of 1s (denoted by asterisks).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蛋白质折叠。* 生物体内的蛋白质以非常特定的方式在三维空间中*折叠*到它们的*天然状态*。这种几何图案决定了蛋白质的行为和功能。最广泛使用的折叠模型之一是二维亲水-疏水（H-P）模型。在这个模型中，蛋白质是一个由0和1组成的序列，问题是将其嵌入到一个二维格子中，使得格子中相邻的1对数，但不在序列中（它的能量），被最小化。例如，序列011001001110010被嵌入到下图中，以便有5对新的相邻的1（用星号表示）。'
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Minimizing the H-P energy of a protein is NP-hard. (Papadimitriou, et al.) It
    is well accept by biologists that proteins fold to minimize their energies. A
    version of Levinthal's paradox asks how it is possible that proteins are able
    to efficiently solve apparently intractable problems.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小化蛋白质的H-P能量是NP难题。（Papadimitriou等）生物学家普遍认为蛋白质折叠是为了最小化它们的能量。Levinthal悖论的一个版本问如何可能蛋白质能够有效地解决表面上看起来棘手的问题。
- en: '*Integration.* Given integers a[1], a[2], ..., a[N], does the following integral
    equal 0?'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*积分。* 给定整数a[1]，a[2]，...，a[N]，以下积分是否等于0？'
- en: '![Integration](../Images/ec8837165bdfff7d34b3aa39202ebc65.png)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![积分](../Images/ec8837165bdfff7d34b3aa39202ebc65.png)'
- en: If you see this integral in your next Physics course, you should not expect
    to be able to solve it. This should not come as a big surprise because in Section
    7.4 we consider a version of integration that is undecidable.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在下一门物理课程中看到这个积分，你不应该期望能够解决它。这不应该让人感到惊讶，因为在第7.4节中，我们考虑了一个不可判定的积分版本。
- en: '*Crossword puzzle*. Given an integer N, and a list of valid words, is it possible
    to assign letters to the cells of an N-by-N grid so that all horizontal and vertical
    words are valid? No easier if some of the squares are black as in a crossword
    puzzle.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*填字游戏.* 给定一个整数N和一个有效单词列表，是否可以将字母分配给一个N×N的网格的单元格，以便所有水平和垂直单词都是有效的？如果一些方格是黑色的，像填字游戏一样，是否更容易？'
- en: '*Theorem.* Given a purported theorem (such as one for the Riemann Hypothesis),
    can you prove it is true using at most n symbols in some formal system such as
    Zermelo-Fraenkel set theory?'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定理.* 给定一个假设的定理（比如黎曼猜想），你能否在某种形式系统（如策梅洛-弗伦克尔集合论）中使用最多n个符号证明它是真的？'
- en: '*Tetris.*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*俄罗斯方块.*'
- en: '*Minesweeper.*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扫雷.*'
- en: '*Regular expressions.* Give two regular expressions over the unary alphabet
    { 1 }, do they represent different languages? Give two NFAs, do they represent
    different languages? It may not be apparent that either problem is even decidable
    since we don''t have an obvious bound on the size of the smallest string that
    is in one language but not the other. [Note that the corresponding inequivalence
    problem for DFAs is polynomial solvable.] The reason why we phrase the problem
    as inequivalence instead of equivalence is that it is easy to check that the two
    entities are non-equivalent by demonstrating a string s. In fact, if the two languages
    are different, then the smallest string is polynomial in the size of the input.
    Thus, we can use the efficient algorithms from Section 7.xyz to check whether
    s is recognized by an RE or accepted by an NFA. However, to argue that two REs
    are equivalent, we would need an argument that guarantees that all strings in
    one are in the other, and vice versa. [It is possible to devise an (exponential)
    algorithm to test whether two REs or NFAs are equivalent, although this should
    not be obvious.]'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式.* 给定两个在一元字母表{ 1 }上的正则表达式，它们表示不同的语言吗？给定两个NFA，它们表示不同的语言吗？也许很难确定这两个问题是否可判定，因为我们没有对一个语言中最小字符串的大小有明显的界限，而不在另一个语言中。[请注意，对于DFA的对应不等价问题是多项式可解的。]
    我们将问题表述为不等价而不是等价的原因是，通过展示一个字符串s，很容易检查这两个实体是否不等价。实际上，如果两个语言不同，那么最小字符串在输入大小的多项式中。因此，我们可以使用第7.xyz节中的高效算法来检查s是否被RE识别或被NFA接受。然而，要证明两个RE等价，我们需要一个保证所有字符串都在另一个中的论证，反之亦然。[可以设计一个（指数级）算法来测试两个RE或NFA是否等价，尽管这并不明显。]'
- en: '*Lemmings.* Is it possible to guide a tribe of green-haired lemming creatures
    to safety in a level of the game Lemmings?'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旅鼠.* 在游戏旅鼠的一个关卡中，是否可能引导一群绿发旅鼠生物安全到达目的地？'
- en: '*Multinomial minimization over unit hypercube.* Given a multinomial of N variables,
    is the minimum <= C, assuming all variables are bounded between 0 and 1. Classic
    calculus problem: min f(x) = ax^2 + bx + c over [0, 1]. Derivative at x = ?? is
    0, but minimum occurs at boundary.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单位超立方体上的多项式最小化.* 给定N个变量的多项式，是否最小值<= C，假设所有变量都在0和1之间。经典微积分问题：在[0, 1]上，min f(x)
    = ax^2 + bx + c。在x = ??处的导数为0，但最小值出现在边界处。'
- en: '*Quadratic Diophantine equations.* Given positive integers a, b, and c, are
    there positive integers x and y such that ax² + by = c?'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次丢番图方程.* 给定正整数a、b和c，是否存在正整数x和y，使得ax² + by = c？'
- en: '*Knot theory.* Which knots on a 3-dimensional manifold bound a surface of genus
    ≤ g?'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结实论.* 在三维��形上哪些结实限制了一个genus ≤ g的表面？'
- en: '*Bounded Post Correspondence Problem.* Given a post correspondence problem
    with N cards and an integer K &le N, is there a solution that uses at most K cards?
    Recall it is undecidable if there is no limit on K.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有界后对应问题.* 给定一个具有N张卡片的后对应问题和一个整数K &le N，是否存在一个使用最多K张卡片的解？请注意，如果K没有限制，那么这是不可判定的。'
- en: '*Nash equilibria.* Cooperative game theory. Given a 2-player game, find a Nash
    equilibrium that maximizes the payoff to player 1. Do more than one NE exist?
    Is there a NE that is Pareto optimal? NE that maximizes social welfare.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纳什均衡.* 合作博弈论。给定一个2人游戏，找到最大化玩家1收益的纳什均衡。是否存在多个NE？是否存在一个帕累托最优的NE？最大化社会福利的NE。'
- en: '*Quadratic congruence.* Given positive integers a, b, and c, is there a positive
    integer x < c such that x² = a (mod b)?'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次同余.* 给定正整数a、b和c，是否存在一个小于c的正整数x，使得x² = a (mod b)？'
- en: '*Ising model in 3d.* Simple mathematical model of phase transitions, e.g.,
    when water freezes or when cooling iron becomes magnetic. Computing lowest energy
    state is NP-hard. Solvable in polynomial time if graph is planar, but 3d lattice
    is nonplanar. Holy grail of statistical mechanics for 75 years before proved NP-hard.
    Establishing NP-completeness means that physicists won''t spend another 75 years
    attempting to solve the unsolvable.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3D中的伊辛模型.* 相变的简单数学模型，例如，当水结冰或冷却铁变成磁性时。计算最低能量状态是NP难的。如果图是平面的，则可以在多项式时间内解决，但3D晶格是非平面的。在被证明NP难之前，统计力学的圣杯已经存在了75年。建立NP完全性意味着物理学家不会再花75年时间试图解决不可解的问题。'
- en: '*Bandwidth minimization*. Given an N-by-N matrix A and an integer B, is it
    possible to permute the rows and columns of A such that A[ij] = 0 if |i - j| >
    B. Useful for numerical linear algebra.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带宽最小化.* 给定一个N×N矩阵A和一个整数B，是否可以重新排列A的行和列，使得A[ij] = 0，如果|i - j| > B。对数值线性代数很有用。'
- en: '*Voting and social choice.* NP-hard for an individual to manipulate a voting
    scheme known as [single transferable vote](http://www.isye.gatech.edu/~jjb/papers/stv.pdf).
    NP-hard to determine who has won an election in a scheme seriously proposed by
    Lewis Carroll (Charles Dodgson) in 1876. In Carroll''s scheme, the winner is the
    candidate who with the fewest pairwise adjacent changes in voters'' preference
    rankings becomes the Condercet winner (a candidate who would beat all other candidates
    in a pairwise election). Shapley-Shubik voting power. Computing the [Kemeny optimal
    aggregation](http://www10.org/cdrom/papers/577/).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*投票和社会选择。* 对于个人来说，操纵称为[单一可转移选票](http://www.isye.gatech.edu/~jjb/papers/stv.pdf)的投票方案是NP难的。在1876年，刘易斯·卡罗尔（查尔斯·道奇森）提出的一种方案中，确定谁赢得了选举是NP难的。在卡罗尔的方案中，获胜者是通过在选民偏好排名中进行最少的两两相邻变化的候选人成为康德塞特赢家（在两两选举中击败所有其他候选人的候选人）。夏普利-舒比克投票权。计算[Kemeny最优聚合](http://www10.org/cdrom/papers/577/)。'
- en: Coping with intractability.
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对难解性。
- en: 'The theory of NP-completeness says that unless P = NP, there are some important
    problems for which we can''t create an algorithm that simultaneously achieves
    the following three properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: NP完全性理论表明，除非P = NP，否则有一些重要问题无法创建同时实现以下三个属性的算法：
- en: Guarantee to solve the problem in polynomial-time.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证在多项式时间内解决问题。
- en: Guarantee to solve the problem to optimality.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证解决问题的最优性。
- en: Guarantee to solve arbitrary instances of the problem.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证解决问题的任意实例。
- en: When we encounter an NP-complete problem, we must relax one of the three requirements.
    We will consider solutions to the TSP problem that relax one of the three goals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到NP完全问题时，我们必须放宽三个要求中的一个。我们将考虑解决放宽了三个目标之一的TSP问题的解决方案。
- en: Complexity theory deals with worst-case behavior. This leaves open the possibility
    of designing algorithms that run quickly on some instances, but take a prohibitive
    amount of time on others. For example, [Chaff](http://www.princeton.edu/pr/pwb/01/0305/1b.shtml)
    is a program that can solve many real-world SAT instances with 10,000 variables.
    Remarkably, it was developed by two undergraduates at Princeton. The algorithm
    does not guarantee to run in polynomial time, but the instances we're interested
    in may be "easy."
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性理论处理最坏情况的行为。这留下了设计算法的可能性，这些算法在某些实例上运行速度快，但在其他实例上需要大量时间。例如，[Chaff](http://www.princeton.edu/pr/pwb/01/0305/1b.shtml)是一个可以解决许多具有10,000个变量的实际SAT实例的程序。令人惊讶的是，它是由普林斯顿大学的两名本科生开发的。该算法不能保证在多项式时间内运行，但我们感兴趣的实例可能是“简单的”。
- en: 'Sometimes we may be willing to sacrifice the guarantee on finding the optimal
    solution. Many heuristic techniques (simulating annealing, genetic algorithms,
    Metropolis algorithm) have been designed to find "nearly optimal" solutions to
    the TSP problem. Sometimes it is even possible to prove how good the resulting
    solution will be. For example, Sanjeev Arora designed an *approximation algorithm*
    for the Euclidean TSP problem that guarantees to find a solution that costs at
    most, say 1%, above the optimum. Designing approximation algorithms is an active
    area of research. Unfortunately, there are also non-approximability results of
    the form: if you can find an approximation algorithm for problem X that guarantees
    to get within a factor of 2 of the optimum, then P = NP. Thus, designing approximation
    algorithms for some NP-complete problems is not possible.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能愿意牺牲找到最优解的保证。许多启发式技术（模拟退火、遗传算法、Metropolis算法）已被设计用于找到“几乎最优”的解决方案。有时甚至可以证明最终解决方案的优良程度。例如，Sanjeev
    Arora设计了一种*近似算法*用于欧几里德TSP问题，保证找到的解决方案的成本最多比最优解高1%。设计近似算法是一个活跃的研究领域。不幸的是，也有一些不可近似性结果，即：如果您可以为问题X找到一个近似算法，保证可以达到最优解的2倍，则P
    = NP。因此，为一些NP完全问题设计近似算法是不可能的。
- en: If we are trying to solve a special class of TSP problems, e.g., where the points
    lie on the boundary of a circle or the vertices of an M-by-N lattice, then we
    can design efficient (and trivial) algorithms to solve the problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图解决TSP问题的特殊类，例如，点位于圆的边界上或M×N格点的顶点上，则我们可以设计高效（且平凡）的算法来解决问题。
- en: '**Exploiting intractability.** Having intractability problems is occasionally
    a good thing. In Section XYZ, we will exploit intractable problems to design cryptographic
    systems.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用难解性。** 有时难解性问题是一件好事。在第XYZ节中，我们将利用难解性问题设计密码系统。'
- en: '**Between P and NP-complete.** Most natural problems in NP are now known to
    be in P or NP-complete. If P != NP, then there are provably some NP problems that
    are neither in P or NP-complete. Like "dark matter we have not developed means
    of observing." A few notable unclassified problems in the netherworld: factoring,
    and subgraph isomorphism.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**介于P和NP完全之间。** 现在已知大多数NP中的自然问题属于P或NP完全。如果P != NP，则可以证明有一些NP问题既不属于P也不属于NP完全。就像“我们还没有观察手段的暗物质”。在地下世界中有一些显著的未分类问题：因子分解和子图同构。'
- en: '*Factoring.* Best known algorithm is 2^O(n^1/3 polylog(n)) - number field sieve.
    Believed by experts not to be in P.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*因子分解。* 已知的最佳算法是2^O(n^1/3 polylog(n)) - 数域筛法。专家认为不属于P。'
- en: '*Precedence constrained 3-processor scheduling.* Given a set of unit length
    tasks, and a precedence order, find the shortest schedule on 3 parallel machines.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*受限优先级的3处理器调度。* 给定一组单位长度的任务和一个优先级顺序，在3台并行机器上找到最短的调度。'
- en: '*Turnpike problem.* Given N(N-1)/2 positive numbers (not necessarily distinct),
    does there exist a set of N points on the line such that these numbers are the
    pairwise distances of the N points. Intuition: points are exits on I-95\. Problem
    first arose in 1930s in the context of x-ray crystallography. Also known as the
    *partial digest problem* in molecular biology.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转角问题。* 给定N(N-1)/2个正数（不一定不同），是否存在一组N个点在直线上，使得这些数字是N个点的两两距离。直觉：点是I-95上的出口。问题首次出现在1930年代的X射线晶体学背景中。在分子生物学中也被称为*部分消化问题*。'
- en: '*Boolean formula dualization.* Given a monotone CNF formula and a monotone
    DNF formula, are they equivalent? (a + b)(c + d) = ac + ad + bc + bd. Naively
    applying De Morgan''s law leads to exponential algorithm because of redundancy.
    Best algorithm O(n^(log n / log log n)).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔公式对偶化。* 给定一个单调 CNF 公式和一个单调 DNF 公式，它们是否等价？(a + b)(c + d) = ac + ad + bc +
    bd。简单地应用德摩根定律会导致指数级算法，因为存在冗余。最佳算法为 O(n^(log n / log log n))。'
- en: '*Stochastic games.* White, Black and Nature alternate moving a token on the
    edges of a directed graph, starting at the start state s. White''s goal is to
    move the token to a goal state t. Black''s goal is to prevent the token from ever
    reaching t. Nature moves the tokens at random. Given a digraph, a start state
    s, and a goal state t,, does White have a strategy which will make the token reach
    t with probability ≥ 1/2? Problem is in NP intersect co-NP, but not known to be
    in P. Believed to be in P, we just haven''t found a polynomial-time algorithm.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机游戏。* 白色、黑色和自然轮流在有向图的边上移动一个令牌，从起始状态 s 开始。白色的目标是将令牌移动到目标状态 t。黑色的目标是阻止令牌到达
    t。自然以随机方式移动令牌。给定一个有向图、一个起始状态 s 和一个目标状态 t，白色是否有一种策略使得令牌到达 t 的概率 ≥ 1/2？该问题属于 NP
    交 co-NP，但尚不清楚是否属于 P。人们相信它属于 P，只是我们还没有找到一个多项式时间算法。'
- en: Other complexity classes.
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他复杂度类。
- en: The complexity classes P, NP, and NP-complete are the three most famous complexity
    classes. Scott Aaronson's website [The Complexity Zoo]( http://www.complexityzoo.com)
    contains a comprehensive list of other complexity classes that are useful in classifying
    problems according to their computational resources (time, space, parallelizability,
    use of randomness, quantum computing). We describe a few of the most important
    ones below.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度类 P、NP 和 NP-完全是三个最著名的复杂度类。Scott Aaronson 的网站[The Complexity Zoo](http://www.complexityzoo.com)包含了其他复杂度类的全面列表，这些类对问题根据其计算资源（时间、空间、可并行性、随机性使用、量子计算）进行分类。我们在下面描述了一些最重要的类。
- en: '*PSPACE.* The complexity class PSPACE = problems solvable by a Turing machine
    using polynomial space. PSPACE-complete = in PSPACE and every other problem in
    PSPACE can be reduced to it in polynomial time.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PSPACE.* 复杂度类 PSPACE = 可以使用多项式空间的图灵机解决的问题。PSPACE-完全 = 在 PSPACE 中，且可以在多项式时间内将所有其他问题归约为它。'
- en: Here is a complexity version of the halting problem. Given a Turing machine
    that is limited to n tape cells, does it halt in at most k steps? The problem
    is PSPACE-complete, where n is encoded in unary. This means that unless P = PSPACE,
    we are unlikely to be able to tell whether a given program, running on a computer
    with n units of memory, will terminate before k steps substantially faster than
    the trivial method of running it for k steps and seeing what happens.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是停机问题的一个复杂版本。给定一个被限制在 n 个磁带单元上的图灵机，在最多 k 步内是否会停机？该问题是 PSPACE-完全的，其中 n 以一元编码。这意味着除非
    P = PSPACE，否则我们不太可能能够判断一个给定程序在具有 n 个内存单元的计算机上运行是否会在 k 步之前终止，比简单地运行它 k 步并观察发生的情况要快得多。
- en: 'Bodlaender: given a graph with vertices 1, ..., N, two players alternate in
    labeling the vertices red, green, or blue. The first player to label a vertex
    the same color as one of its neighbors loses. Determining whether there is a winning
    strategy for the first player is PSPACE-complete.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bodlaender：给定一个具有顶点 1, ..., N 的图，两名玩家轮流标记顶点为红色、绿色或蓝色。第一个标记一个与其邻居相同颜色的顶点的玩家失败。确定第一个玩家是否有获胜策略是
    PSPACE-完全的。
- en: Versions of many conventional games are provably intractable; this partially
    explains their appeal. Also natural generalizations of Othello, Hex, Geography,
    Shanghai, Rush Hour, go-moku, Instant Insanity, and Sokoban are PSPACE-complete.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多传统游戏的变体被证明是棘手的；这在一定程度上解释了它们的吸引力。此外，黑白棋、六角、地理、上海、赛车、五子棋、瞬间疯狂和推箱子的自然推广都是 PSPACE-完全的。
- en: '[Eppstein''s list of hard games](http://www.ics.uci.edu/~eppstein/cgt/hard.html).'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Eppstein 的困难游戏列表](http://www.ics.uci.edu/~eppstein/cgt/hard.html)。'
- en: Is a given string a member of a context sensitive grammar?
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个给定的字符串是否是上下文敏感文法的成员？
- en: Do two regular expressions describe different languages? PSPACE-complete even
    over the binary alphabet and if one of the regular expressions is `.*`.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个正则表达式是否描述不同的语言？即使在二进制字母表上也是 PSPACE-完全的，如果其中一个正则表达式是`.*`。
- en: Another example that can be made rigorous is the problem of moving a complicated
    object (e.g., furniture) with attachments that can move and rotate through an
    irregularly shaped corridor.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个可以严格化的例子是移动一个复杂对象（例如家具），其附件可以通过不规则形状的走廊移动和旋转。
- en: Another example arises in parallel computing when the challenge is to determine
    whether a deadlock state is possible within a system of communicating processors.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个例子出现在并行计算中，当挑战是确定在一个通信处理器系统中是否可能存在死锁状态时。
- en: Note PSPACE = NPSPACE (Savitch's theorem).
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 PSPACE = NPSPACE（Savitch 定理）。
- en: '*EXPTIME.* The complexity class EXPTIME = all decision problem solvable in
    exponential time on deterministic Turing machine. Note P ⊆ NP ⊆ PSPACE ⊆ EXPTIME,
    and, by the time hierarchy theorem, at least one inclusion is strict, but unknown
    which one (or more). It is conjectured that all inclusions are strict.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EXPTIME.* 复杂度类 EXPTIME = 所有在确定性图灵机上以指数时间可解决的决策问题。注意 P ⊆ NP ⊆ PSPACE ⊆ EXPTIME，并且根据时间层次定理，至少有一个包含是严格的，但不知道是哪一个（或多个）。有人推测所有包含都是严格的。'
- en: Roadblock from Harel p. 85.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harel 的 Roadblock 第 85 页。
- en: 'Natural generalization of chess, checkers, Go (with Japanese style ko termination
    rule), and Shogi are EXPTIME-complete. Given a board position, can the first player
    force a win? Here N is the size of the board, and the running time is exponential
    in N. One reason that these problems are harder from a theoretical standpoint
    than Othello (and other PSPACE-complete games) is that they can take an exponential
    number of moves. Checkers (aka English draughts on an N-by-N board): player can
    have an exponential number of moves at a given turn because of jump sequences.
    [[pdf](../papers/checkers.pdf)] Note: depending on termination rules, checkers
    can either be PSPACE-complete or EXPTIME-complete. For EXPTIME-complete, we assume
    the "forced capture rule" where a player must make a jump (or sequence of jumps)
    if available.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际象棋、跳棋、围棋（采用日本式劫争终结规则）和将棋的自然泛化都是EXPTIME完全问题。给定一个棋盘局面，第一位玩家能否强迫获胜？这里N是棋盘大小，运行时间与N呈指数关系。这些问题比奥赛罗（和其他PSPACE完全游戏）在理论上更难的一个原因是它们可能需要指数次数的移动。跳棋（在N×N棋盘上的英式跳棋）：玩家在某一回合可以有指数次数的移动，因为可以进行跳跃序列。[[pdf](../papers/checkers.pdf)]
    注意：根据终结规则的不同，跳棋可能是PSPACE完全或EXPTIME完全。对于EXPTIME完全，我们假设“强制捕获规则”，即如果有可用的跳跃（或跳跃序列），玩家必须进行跳跃。
- en: 'Here is a complexity version of the halting problem. Given a Turing machine,
    does it halt in at most k steps? Alternatively, given a fixed Java program and
    a fixed input, does it terminate in at most k steps? The problem is EXPTIME-complete.
    Here the running time is exponential in the binary representation of k. In fact,
    no turing machine can guarantee to solve it in, say, O(k / log k) steps. Thus,
    brute force simulation is essentially best possible: provably, the problem cannot
    be solved substantially faster than the trivial method of running the Turing machine
    for the first k steps and seeing what happens.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是停机问题的一个复杂性版本。给定一个图灵机，在最多k步内是否会停机？或者，给定一个固定的Java程序和一个固定的输入，在最多k步内是否会终止？这个问题是EXPTIME完全的。这里的运行时间与k的二进制表示成指数关系。事实上，没有图灵机可以保证在O(k
    / log k)步内解决它。因此，暴力模拟基本上是最佳的方法：可以证明，这个问题不能比运行图灵机的前k步并观察发生了什么更快地解决。
- en: An EXPTIME-complete problem cannot be solved in polynomial-time on a deterministic
    Turing machine - it does not depend on the P ≠ NP conjecture.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个EXPTIME完全问题在确定性图灵机上不能在多项式时间内解决 - 这与P ≠ NP猜想无关。
- en: '*EXPSPACE.* EXPSPACE-complete: given two "extended" regular expressions, do
    they represent different languages? By extended, we allow a squaring operation
    (two copies of an expression). Stockmeyer and Meyer (1973). Or, more simply set
    intersection (Hunt, 1973). Word problem for Abelian groups (Cardoza, Lipton, Meyer,
    1976), Vector Addition Subsystem.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EXPSPACE.* EXPSPACE完全问题：给定两个“扩展”正则表达式，它们是否表示不同的语言？通过扩展，我们允许一个平方操作（表达式的两个副本）。Stockmeyer和Meyer（1973）。或者更简单的集合交集（Hunt，1973）。阿贝尔群的字问题（Cardoza，Lipton，Meyer，1976），向量加法子系统。'
- en: 'The [Vector Addition Subsystem](http://rjlipton.wordpress.com/2009/04/08/an-expspace-lower-bound/)
    is EXPSAPCE-hard: given a nonnegative vector s and a set of arbitrary vectors,
    v1, v2, ..., vn, a vector x is reachable from s if it is either (i) the vector
    s or (ii) the vector y + vi where y is reachable. The VAS problem is to determine
    whether a given vector x is reachable.'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[向量加法子系统](http://rjlipton.wordpress.com/2009/04/08/an-expspace-lower-bound/)是EXPSAPCE难题：给定一个非负向量s和一组任意向量v1、v2、...、vn，如果向量x是从s可达的，则它要么是（i）向量s，要么是可达的向量y
    + vi，其中y是可达的。VAS问题是确定给定向量x是否可达。'
- en: '*DOUBLE-EXPTIME.* The class DOUBLE-EXPTIME is the set of all decision problems
    solvable in doubly exponential time. A remarkable example is determining whether
    a formula in [first order Presburger arithmetic](http://en.wikipedia.org/wiki/Presburger_arithmetic)
    is true. Presburger arithmetic consists of statements involving integers with
    + as the only operation (no multiplication or division). It can model statements
    like the following: if x and y are integer such that x &le y + 2, then y + 3 >
    x. In 1929 Presburger proved that his system is consistent (can''t prove a contradiction
    like 1 > 2) and complete (every statement can be proven true or false). In 1974,
    Fischer and Rabin proved that any algorithm that decides the truth of a Presburger
    formula requires at least 2^((2^(cN))) time for some constant c, where N is the
    length of the formula.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DOUBLE-EXPTIME.* DOUBLE-EXPTIME类是在双指数时间内可解决的所有决策问题。一个显著的例子是确定[first order
    Presburger arithmetic](http://en.wikipedia.org/wiki/Presburger_arithmetic)中的一个公式是否为真。Presburger算术包括涉及只有+作为操作的整数的语句（没有乘法或除法）。它可以模拟以下语句：如果x和y是整数，使得x
    ≤ y + 2，则y + 3 > x。1929年，Presburger证明了他的系统是一致的（不能证明矛盾，比如1 > 2）和完备的（每个语句都可以被证明为真或假）。1974年，Fischer和Rabin证明了任何决定Presburger公式真实性的算法都需要至少2^((2^(cN)))时间，其中c是一个常数，N是公式的长度。'
- en: '*Non-elementary.* More than 2^2^2^...^2^N for any finite tower. Given two regular
    expressions that allow squaring and complementation, do they describe different
    languages?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非初等.* 对于任何有限的塔，超过2^2^2^...^2^N。给定允许平方和补集的两个正则表达式，它们是否描述不同的语言？'
- en: Other types of computational problems.
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的计算问题。
- en: We focus on search problems since this is a very rich and important class of
    problems for scientists and engineers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于搜索问题，因为这是科学家和工程师非常丰富和重要的问题类别。
- en: '*Search problems.* This is the version we have considered in detail. Technically,
    FP = polynomial-time function problems, FNP = polynomial-time function problems
    on nondeterministic Turing machine. FP problems can have any output that can be
    computed in polynomial time (e.g., multiplying two numbers or finding the solution
    to Ax = b).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索问题.* 这是我们详细考虑的版本。技术上，FP = 多项式时间函数问题，FNP = 非确定性图灵机上的多项式时间函数问题。FP问题可以有任何可以在多项式时间内计算的输出（例如，两个数字相乘或找到Ax
    = b的解）。'
- en: '*Decision problems.* Traditionally, complexity theory is defined in terms of
    yes/no problems, e.g., Does there exist a solution to Ax &le b? Definition of
    reduction is cleaner (no need to deal with output). Classes P and NP traditionally
    defined in terms of decision problems. Typically the search problem reduces to
    the decision problem (and this is known to be true for all NP-complete problems).
    Such search problems are referred to as *self-reducible*. The P = NP question
    is equivalent to the FP = FNP question.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*决策问题。* 传统上，复杂性理论是以是/否问题来定义的，例如，Ax &le b 是否存在解？规约的定义更清晰（无需处理输出）。P 类和 NP 类传统上是以决策问题来定义的。通常搜索问题归约为决策问题（对于所有
    NP 完全问题都已知为真）。这样的搜索问题被称为*自可归约*。P = NP 问题等价于 FP = FNP 问题。'
- en: '*Total functions.* Occasionally, a decision problem is easy, while the corresponding
    search problem is (believed to be) hard. For example, there may be a theorem asserting
    that a solution is guaranteed to exist, but the theorem does not provide any hint
    as to how to find one efficiently.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全函数。* 有时，一个决策问题很容易，而相应的搜索问题（被认为）很难。例如，可能有一个定理断言解肯定存在，但该定理并未提供如何高效找到解的任何提示。'
- en: '[subset sum example](http://theory.lcs.mit.edu/classes/6.042/spring04/handouts/numbers.shtml).
    Given N numbers, find two (disjoint) subsets of these N numbers that sum to exactly
    the same value. If N = 77 and all the numbers are at most twenty-one decimal digits
    long, then by the pigeonhole principle, at least two subsets must sum to the same
    value. This is because there are 2^77 subsets but at most 1 + 77 * 10^21 < 2^77
    possible sums. Or decision = composite, search = factor.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[子集和示例](http://theory.lcs.mit.edu/classes/6.042/spring04/handouts/numbers.shtml)。给定
    N 个数字，找出这些 N 个数字的两个（不相交）子集，使它们的和恰好相等。如果 N = 77，且所有数字最多为二十一位十进制数，则根据鸽巢原理，至少有两个子集的和相等。这是因为有
    2^77 个子集，但最多有 1 + 77 * 10^21 < 2^77 种可能的和。或者决策 = 复合，搜索 = 因子。'
- en: John Nash proved that *Nash equilibria* always exist in a normal form game of
    two or more players with specified utilities. Proof was nonconstructive, so unclear
    how to find such an equilibria. Proved to be *PPAD-complete* - the analog of NP-complete
    for problems known to have solutions.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰·纳什证明了在具有指定效用的两个或更多玩家的正常形式游戏中，*纳什均衡*总是存在。证明是非构造性的，因此不清楚如何找到这样的均衡。被证明是*PPAD-完全*
    - 已知具有解的问题的 NP-完全问题的类比。
- en: General equilibrium theory is foundation of microeconomics. Given an economy
    with k commodities, each of N agents has an initial endowment of the commodities.
    Each agent also as a utility function for each commodity. The [Arrow-Debreu theorem](http://en.wikipedia.org/wiki/Arrow_Debreu)
    asserts that under suitable technical conditions (e.g., utility functions are
    continuous, monotonic, and strictly concave) there exist a (unique) set of *market
    prices* such that each agent sells all their goods and buys the optimal bundle
    using this money (i.e., supply equals demand for every commodity). But how does
    market compute it? The proof relies on a deep theorem from topology (Kakutani's
    fixed point theorem) and no efficient algorithm is currently known. Economists
    assume that the market finds the equilibrium prices; Adam Smith used the metaphor
    of [the invisible hand](http://en.wikipedia.org/wiki/Invisible_hand) to describe
    this social mechanism.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义均衡理论是微观经济学的基础。给定一个有 k 种商品的经济体，每个 N 个代理人都有这些商品的初始禀赋。每个代理人还为每种商品有一个效用函数。[阿罗-德布鲁定理](http://en.wikipedia.org/wiki/Arrow_Debreu)断言，在适当的技术条件下（例如，效用函数连续、单调且严格凹），存在一组（唯一的）*市场价格*，使得每个代理人都卖掉所有商品，并用这笔钱购买最佳组合（即，每种商品的供求平衡）。但市场是如何计算的呢？证明依赖于拓扑学中的一个深刻定理（卡库塔尼不动点定理），目前尚不知道任何有效的算法。经济学家假设市场找到了均衡价格；亚当·斯密用[看不见的手](http://en.wikipedia.org/wiki/Invisible_hand)的比喻来描述这种社会机制。
- en: Generalization of 15-slider puzzle. Testing whether solution exists is in P,
    but finding shortest solution is intractable. [Ratner-Warmuth, 1990]
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15-滑块拼图的推广。测试解是否存在在 P 中，但找到最短解是棘手的。[Ratner-Warmuth, 1990]
- en: '*Optimization problems.* Sometimes we have optimization problems, e.g., TSP.
    Given an NP problem and a cost function on solutions, the goal for a given instance
    is to find the *best* solution for it (e.g find the shortest TSP tour, the minimum
    energy configuration, etc.) Sometimes hard to formulate as a search problem (find
    the shortest TSP tour) since not clear how to efficiently check that you have
    optimal tour. Instead, we rephrase as: given a length L, find a tour of length
    at most L. Then binary search for optimal L.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化问题。* 有时我们有优化问题，例如，TSP。给定一个 NP 问题和一个解的成本函数，对于给定的实例，目标是找到其*最佳*解（例如找到最短的 TSP
    旅行路线，最小能量配置等）。有时很难表述为搜索问题（找到最短的 TSP 旅行路线），因为不清楚如何有效地检查是否有最优路线。相反，我们重新表述为：给定长度
    L，找到长度最多为 L 的旅行路线。然后二分搜索最优 L。'
- en: '*Counting problems.* Given an NP problem, find the number of solutions for
    it. For example, given a CNF formula, how many satisfying assignments does it
    have? Includes many problems in statistical physics and combinatorics. Formally,
    the class of problems is known as [#P](http://en.wikipedia.org/wiki/Sharp-P).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计数问题。* 给定一个 NP 问题，找出其解的数量。例如，给定一个 CNF 公式，它有多少满足的赋值？包括统计物理和组合数学中的许多问题。从形式上讲，这类问题被称为[#P](http://en.wikipedia.org/wiki/Sharp-P)。'
- en: '*Strategic problems.* Given a game, find an optimal strategy (or best move)
    for a player. Includes many problems in economics and board games (e.g., chess,
    go).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*战略问题。* 给定一个游戏，为玩家找到一个最佳策略（或最佳移动）。包括经济学和棋盘游戏中的许多问题（例如，国际象棋，围棋）。'
- en: Output polynomial time.
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出多项式时间。
- en: Some problems involve more output than a single bit of information. For example,
    outputting a solution to the Towers of Hanoi problem requires at least 2^N steps.
    This requirement is not because the solution is inherently hard to compute, but
    rather because there are 2^N symbols of output, and it takes one unit of time
    to write each output symbol. Perhaps a more natural way to measure efficiency
    is a function both of the input size and of the output size. A classic electrical
    engineering problem with DFAs is to build a DFA from a RE that uses the minimum
    number of states. We would like an algorithm that is polynomial in the size of
    the input RE (number of symbols) and also in the size of the output DFA (number
    of states). Unless P = NP, designing such an algorithm is impossible. In fact,
    it's not even possible to design a polynomial algorithm that gets the answer within
    a constant (or even polynomial) number of states! Without the theory of NP-completeness,
    researchers would waste time following unpromising research directions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有些问题涉及的输出比单个位的信息更多。例如，输出汉诺塔问题的解至���需要 2^N 步。这个要求不是因为解本质上难以计算，而是因为有 2^N 个输出符号，并且每个输出符号需要一个单位的时间来写入。也许更自然的衡量效率的方法是输入大小和输出大小的函数。一个具有
    DFAs 的经典电气工程问题是从 RE 构建一个使用最少状态的 DFA。我们希望的算法在输入 RE 的大小（符号数量）和输出 DFA 的大小（状态数量）上都是多项式的。除非
    P = NP，否则设计这样的算法是不可能的。事实上，甚至不可能设计一个在常数（甚至多项式）数量的状态内得出答案的多项式算法！没有 NP 完全性理论，研究人员将浪费时间追随没有前途的研究方向。
- en: Other lower bounds.
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他下界。
- en: '*Information theoretic.* In Section X.Y we saw that insertion uses at most
    N^2 compares to sort N items, and mergesort uses at most N log N compares. A natural
    question to ask is whether we can do better, perhaps one that uses at most 5N
    compares or even 1/2 N log N compares. To make the question more precise, we must
    explicitly state our computational model (decision tree). Here, we assume that
    we only access the data through the `less()` function. A remarkable theorem due
    to X says that no (comparison based) sorting algorithm can guarantee to sort every
    input of N distinct elements in fewer than ~ N log N compares. To see why, observe
    that each compare (call to `less`) provides one bit of information. In order to
    identify the correct permutation, you need log N! bits, and log N! ~ N log N.
    This tells us that mergesort is (asymptotically) the best possible sorting algorithm.
    No sorting algorithm in existence (or even one not yet imagined) will use substantially
    fewer compares.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息论的。* 在第 X.Y 节中，我们看到插入最多使用 N^2 次比较来对 N 个项目进行排序，而归并排序最多使用 N log N 次比较。一个自然的问题是我们是否可以做得更好，也许最多使用
    5N 次比较，甚至 1/2 N log N 次比较。为了使问题更加明确，我们必须明确陈述我们的计算模型（决策树）。在这里，我们假设我们只通过 `less()`
    函数访问数据。由 X 提出的一个引人注目的定理表明，没有（基于比较的）排序算法可以保证在少于 ~ N log N 次比较中对 N 个不同元素的每个输入进行排序。要理解原因，观察到每次比较（调用
    `less`）提供一位信息。为了识别正确的排列，您需要 log N! 位信息，而 log N! ~ N log N。这告诉我们，归并排序是（渐近地）最佳的排序算法。不存在任何排序算法（甚至是尚未想象的算法）会使用更少的比较。'
- en: '*3-Sum hard.* Given a set of N integers, do any three of them sum to 0? Quadratic
    algorithm exists (see exercise xyz), but no subquadratic algorithm known. 3-SUM
    linear reduces to many problems in computational geometry. (find whether set of
    points in the plane have 3 that are collinear, decide whether a set of line segments
    in the plane can be split into two subsets by a line, determining whether a set
    of triangles cover the unit square, can you translate a polygon P to be completely
    inside another polygon Q, robot motion planning).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3-Sum 困难。* 给定一组 N 个整数，其中任意三个数相加是否等于 0？存在二次算法（参见练习 xyz），但没有已知的次二次算法。3-SUM 线性归约到计算几何中的许多问题。（查找平面上的点集是否有
    3 个共线，决定平面上的线段集是否可以被一条线分成两个子集，确定一组三角形是否覆盖单位正方形，您是否可以将多边形 P 移动到完全位于另一个多边形 Q 内部，机器人运动规划）。'
- en: Brute force TSP takes N! steps. Using dynamic programming, can get it down to
    2^N. Best lower bound = N. Essence of computational complexity = trying to find
    matching upper and lower bounds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 蛮力 TSP 需要 N! 步。使用动态规划，可以将其减少到 2^N。最佳下界 = N。计算复杂性的本质 = 尝试找到匹配的上界和下界。
- en: Circuit complexity.
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路复杂性。
- en: There are other ways to define and measure computational complexity. A Boolean
    circuit of n inputs can compute any Boolean function of n variables. We can associate
    the set of binary strings of size n for which the circuit outputs 1 as the set
    of strings in the language. We need one circuit for each input size n. Shannon
    (1949) proposed the size of the circuit as a measure of complexity. It is known
    that a language has *uniformly* polynomial circuits if and only if the language
    is in P.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他定义和衡量计算复杂性的方法。具有 n 个输入的布尔电路可以计算 n 个变量的任何布尔函数。我们可以将电路输出 1 的大小为 n 的二进制字符串集合与语言中的字符串集合相关联。我们需要一个用于每个输入大小
    n 的电路。Shannon（1949）提出了电路大小作为复杂性的度量。已知，如果语言在 P 中，则语言具有*均匀*多项式电路。
- en: Physical and analog computation.
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理和模拟计算。
- en: The P = NP question is a mathematical question regarding the capabilities of
    Turing machines and classical digital computers. We might also wonder whether
    the same is true for analog computers. By *analog*, we mean any "deterministic
    physical device that uses a fixed number of physical variables to represent each
    problem variable." Internal state represented by continuous variables instead
    of discrete. E.g., soap bubbles, protein folding, quantum computing, gears, time
    travel, black holes, etc.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: P = NP 问题是关于图灵机和经典数字计算机能力的数学问题。我们也可以思考模拟计算机是否也是如此。*模拟* 意味着任何“确定性物理设备，使用固定数量的物理变量来表示每个问题变量。”
    内部状态由连续变量而非离散变量表示。例如，肥皂泡沫，蛋白质折叠，量子计算，齿轮，时间旅行，黑洞等。
- en: '[Vergis, Steiglitz, and Dickinson](../papers/vergis-steiglitz-dickinson.pdf)
    proposed an analog form of the Strong Church-Turing thesis:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vergis, Steiglitz, and Dickinson](../papers/vergis-steiglitz-dickinson.pdf)
    提出了强克尔图灵论文的模拟形式：'
- en: Any finite analog computer can be simulated *efficiently* by a digital computer,
    in the sense that the time required by the digital computer to simulate the analog
    computer is bounded by a polynomial function of the resources used by the analog
    computer.
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何有限的模拟计算机都可以被数字计算机*高效*模拟，即数字计算机模拟模拟计算机所需的时间受限于模拟计算机使用的资源的多项式函数。
- en: 'The resources of the analog computer could be time, volume, mass, energy, torque,
    or angular momentum. Reference: [The Physics of Analog Computation](http://www.cs.princeton.edu/courses/archive/fall04/cos576/papers/vergis_steiglitz_dickinson86.pdf)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟计算机的资源可以是时间、体积、质量、能量、扭矩或角动量。参考：[模拟计算的物理学](http://www.cs.princeton.edu/courses/archive/fall04/cos576/papers/vergis_steiglitz_dickinson86.pdf)
- en: Any reasonable model of computation (e.g., not involving exponential parallelism)
    can be simulated in polynomial time by a Turing machine (supplemented by a hardware
    random number generator).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合理的计算模型（例如，不涉及指数并行性）都可以通过图灵机（辅以硬件随机数生成器）在多项式时间内模拟。
- en: 'Reference: [Scott Aaronson](../papers/aaronson.pdf). Can yield new insights
    into physics. One day "the presumed intractability of NP-complete problems might
    be taken as a useful constraint in the search for new physical theories" just
    like the second law of thermodynamics. Still can be falsified by experiment, but
    don''t waste time looking...'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[斯科特·阿伦森](../papers/aaronson.pdf)。可以为物理学提供新的见解。有一天，“NP完全问题的被假定为难以解决可能被视为寻找新物理理论的有用约束”，就像热力学第二定律一样。仍然可以通过实验证伪，但不要浪费时间...
- en: '*Soap bubbles.* Folklore that you can solve Steiner tree problem. In reality,
    only finds a local minimum, and may take a while to do so.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*肥皂泡。* 传说你可以解决斯坦纳树问题。实际上，只能找到一个局部最小值，并且可能需要一段时间才能找到。'
- en: '*Quantum computing.* One speculative model of computation - quantum computers
    - might be capable of solving some problems in a polynomial time that a deterministic
    Turing machine cannot do. Peter Shor discovered an N^3 algorithm for factoring
    N-digit integers, but the best known algorithm on a classical computer takes time
    exponential in N. Same idea could lead to a comparable speedup in simulating quantum
    mechanical systems. This explains the recent excitement in quantum computation,
    as it could result in a paradigm shift for computing. However, quantum computers
    do not yet violate the extended Church-Turing thesis since we don''t yet know
    how to build them. (Difficult to harness because much of the quantum information
    seems to be easily destroyed by its interactions with the outside world, i.e.,
    decoherence.) Moreover, it is still possible that someone might discover a polynomial-time
    algorithm for factoring on a classical computer, although most experts suspect
    that this is not possible. Grover''s algorithm: search in sqrt(N) time instead
    of N.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子计算。* 一种推测性的计算模型 - 量子计算机 - 可能能够在确定性图灵机无法做到的多项式时间内解决一些问题。彼得·肖尔发现了一个用于分解N位整数的N^3算法，但在经典计算机上已知的最佳算法需要指数时间。同样的想法可能导致在模拟量子力学系统时获得可比较的加速。这解释了量子计算引起的最近激动，因为它可能导致计算的范式转变。然而，量子计算机尚未违反扩展的丘奇-图灵论题，因为我们尚不知道如何构建它们。（难以利用，因为许多量子信息似乎很容易被与外界的相互作用所破坏，即退相干。）此外，仍然有可能有人在经典计算机上发现一个多项式时间算法来分解，尽管大多数专家认为这是不可能的。格罗弗的算法：在sqrt(N)时间内搜索而不是N。'
- en: Richard Feynman showed in 1982 that classical computers cannot simulate quantum
    mechanical systems without slowing down exponentially (crux of argument is that
    Turing machines have locality of reference whereas quantum mechanics includes
    "exploit spooky action at a distance"). A quantum computer might be able to get
    around this problem. Feynman quote with respect to building a computer to simulate
    physics...
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理查德·费曼在1982年表明，经典计算机无法模拟量子力学系统而不会指数级减速（争论的关键在于图灵机具有局部性，而量子力学包括“利用远距作用”）。量子计算机可能能够解决这个问题。费曼关于建造一个模拟物理的计算机的引用...
- en: '"The rule of simulation that I would like to have is that the number of computer
    elements required to simulate a large physical system is only to be proportional
    to the space-time volume of the physical system. I don''t want to have an explosion."'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我想要的模拟规则是，用于模拟大型物理系统所需的计算机元素数量仅与物理系统的时空体积成正比。我不想出现爆炸。”
- en: Rephrase in terms of modern complexity theory by replacing "proportional to"
    by "bounded by a polynomial function of".
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用“受限于”替换“与...成正比”来重新表述现代复杂性理论。
- en: Deutsch-Jozsa give algorithm that is provably exponentially faster on a quantum
    computer than on a deterministic Turing machine. (Though exponential gap does
    not exist if the Turing machine has access to a hardware random number generator
    and can be wrong with negligible probability. Quantum computers can generate true
    randomness. )
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 德乔萨提出的算法在量子计算机上的运行速度被证明比确定性图灵机快得多。（尽管如果图灵机可以访问硬件随机数生成器并且可以以可忽略的概率出错，指数差距就不存在。量子计算机可以生成真正的随机性。）
- en: PRIMES and COMPOSITE.
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 素数和合数。
- en: 'It is easy to convince someone that a number is composite by producing a factor.
    Then, the person just has to check (by long division) that you did not lie to
    them. Marin Mersenne conjectured that numbers of the form 2^p - 1 are prime for
    p = 2, 3, 5, 7, 13, 17, 19, 31, 67, 127 and 257. His conjecture for p = 67 was
    disproved by F. N. Cole over two hundred and fifty years later in 1903. According
    to E. T. Bell''s book *Mathematics: Queen and Servant of Science*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个因子很容易说服某人一个数字是合数。然后，这个人只需通过长除法检查你是否对他们撒谎。马林·梅森猜想形如2^p - 1的数字对于p = 2, 3,
    5, 7, 13, 17, 19, 31, 67, 127和257是素数。他对p = 67的猜想在两百五十多年后的1903年被F·N·科尔推翻。根据E·T·贝尔的书籍*数学：科学的女王和仆人*
- en: In the October meeting of the AMS, Cole announced a talk "On the Factorisation
    of Large Numbers". He walked up to the blackboard without saying a word, calculated
    by hand the value of 2^(67), carefully subtracted 1. Then he multiplied two numbers
    (which were 193707721 and 761838257287). Both results written on the blackboard
    were equal. Cole silently walked back to his seat, and this is said to be the
    first and only talk held during an AMS meeting where the audience applauded. There
    were no questions. It took Cole about 3 years, each Sunday, to find this factorization,
    according to what he said.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 AMS 的十月会议上，Cole 宣布了一个关于“大数的因式分解”的讲座。他默不作声地走到黑板前，手算出了 2^(67) 的值，仔细地减去 1。然后他将两个数相乘（分别是
    193707721 和 761838257287）。黑板上写下的两个结果是相等的。Cole 默默地走回座位，据说这是 AMS 会议中唯一一次观众鼓掌的讲座。没有问题。根据他所说，Cole
    花了大约 3 年的每个星期日来找到这个因式分解。
- en: For the record 2^(67) - 1 = 193707721 × 761838257287 = 147573952589676412927.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 记录上 2^(67) - 1 = 193707721 × 761838257287 = 147573952589676412927。
- en: Q + A
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q + A
- en: '**Q.** Are polynomial algorithms always useful?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 多项式算法总是有用吗？'
- en: '**A.** No, algorithms that take N^(100) or 10^(100) N² steps are as useless
    in practice as exponential ones. The constants that arise in practice are usually
    sufficiently small that polynomial-time algorithms scale to huge problems, so
    polynomiality often serves as a surrogate for useful in practice.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不，需要 N^(100) 或 10^(100) N² 步的算法在实践中与指数算法一样无用。实践中产生的常数通常足够小，使得多项式时间算法适用于巨大问题，因此多项式性通常作为实践中有用的替代品。'
- en: '**Q.** Why is the class of all search problems named NP?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么所有搜索问题的类别被命名为 NP？'
- en: '**A.** The original definition of NP was in terms of *nondeterministic* Turing
    machines: NP is the set of all decision problems that can be solved in polynomial-time
    on a nondeterministic Turing machine. Roughly speaking, the difference between
    a deterministic and nondeterministic Turing machine is that the former operates
    like a conventional computer, performing each instruction in sequence, forming
    a computational path; a nondeterministic Turing machine can "branch off" where
    each branch can execute a different statement in parallel, forming a computational
    tree (If any path in the tree leads to a YES, then we accept; if all paths lead
    to NO, we reject.) This is where the N in NP comes from. It turns out the two
    definitions are equivalent, but the certificate one is now more widely used. (Also,
    Karp''s 1972 paper uses the polynomial-time verifiability definition.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** NP 的最初定义是基于*非确定性*图灵机的：NP 是所有可以在非确定性图灵机上多项式时间内解决的决策问题的集合。粗略地说，确定性和非确定性图灵机之间的区别在于前者像传统计算机一样运行，按顺序执行每个指令，形成一个计算路径；非确定性图灵机可以“分支”，其中每个分支可以并行执行不同的语句，形成一个计算树（如果树中的任何路径导致
    YES，则我们接受；如果所有路径导致 NO，则我们拒绝。）这就是 NP 中的 N 来源。事实证明这两个定义是等价的，但现在更广泛使用证书的定义。（此外，Karp
    的 1972 年论文使用了多项式时间可验证性的定义。）'
- en: '**Q.** What is the complexity class NP-hard?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 复杂度类 NP-难是什么？'
- en: '**A.** Several competing definitions. We define a problem (decision, search,
    or optimization) problem to be NP-hard if solving it in polynomial time would
    imply P = NP. Definition implicitly uses Turing reduction (extended to search
    problems).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 几个竞争性定义。我们定义一个问题（决策、搜索或优化）问题为 NP-难，如果在多项式时间内解决它将意味着 P = NP。定义隐含地使用图灵归约（扩展到搜索问题）。'
- en: '**Q.** What''s so hard about factoring an integer N in polynomial time - can''t
    I just divide all potential factors less than N (or √N) into x and see if any
    have a remainder of zero?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 在多项式时间内对整数 N 因式分解有什么困难之处 - 我不能只将小于 N（或 √N）的所有潜在因子分成 x 并查看是否有余数为零吗？'
- en: '**A.** The algorithm is correct, but remember it takes only lg N bits to represent
    the integer N. Thus, for an algorithm to be polynomial in the input size, it must
    be polynomial in lg N, and not N.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 算法是正确的，但请记住只需 lg N 位来表示整数 N。因此，为了使算法在输入大小上是多项式的，它必须在 lg N 中是多项式的，而不是
    N。'
- en: '**Q.** How is it possible that checking whether an integer is composite is
    solvable in polynomial time, yet finding its factors is not known (or believed)
    to be?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 检查一个整数是否为合数可以在多项式时间内解决，但找到它的因子却未知（或被认为）不可解吗？'
- en: '**A.** There are ways to prove a number is composite without getting your hands
    on any of its factors. A famous theorem from number theory (Fermat''s little theorem)
    implies that if you have two integers a and p such that (i) a is not a multiple
    of p and (ii) a^(p-1) != 1 (mod p), then p is not prime.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 有方法证明一个数是合数而不需要得到它的任何因子。数论中的一个著名定理（费马小定理）暗示，如果你有两个整数 a 和 p，使得（i）a 不是
    p 的倍数且（ii）a^(p-1) != 1 (mod p)，那么 p 不是质数。'
- en: '**Q.** Is there a decision problem that is polynomial solvable on a quantum
    computers, but *provably* not in P?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 是否存在一个在量子计算机上多项式可解的决策问题，但*可以证明*不在 P 中？'
- en: '**A.** This is an open research problem. FACTOR is a candidate, but there is
    no proof that FACTOR is not in P, although this is widely believed to be outside
    P.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这是一个未解决的研究问题。FACTOR 是一个候选项，但没有证据表明 FACTOR 不在 P 中，尽管普遍认为它不在 P 中。'
- en: '**Q.** Does NP = EXPTIME?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** NP = EXPTIME 吗？'
- en: '**A.** The experts believe no, but have been unable to prove it.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 专家们认为不是，但他们无法证明。'
- en: '**Q.** Suppose someone proves P = NP. What would be the practical consequences?'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设有人证明 P = NP。这将有什么实际后果？'
- en: '**A.** It depends on how the question is resolved. Obviously, it would be a
    remarkable theoretical breakthrough. In practice, it might have dramatic significance
    if the proof of P = NP established a fast algorithm for an important NP-complete
    problem. If the proof results in an 2^100 N^117 algorithm for the TSP (and the
    constant and exponent could not be reduced), it would not have little practical
    impact. It could also be that someone proves P = NP by indirect means, thereby
    yielding no algorithm at all!'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这取决于问题是如何解决的。显然，如果证明 P = NP，那将是一个显著的理论突破。在实践中，如果 P = NP 的证明为一个重要的 NP
    完全问题建立了一个快速算法，那可能具有重大意义。如果证明导致旅行商问题的一个 2^100 N^117 的算法（且常数和指数无法减少），那将没有太大的实际影响。也可能有人通过间接手段证明
    P = NP，从而根本没有算法！'
- en: '**Q.** Suppose someone proves P != NP. What would be the practical consequences?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设有人证明 P != NP。这将会有什么实际后果？'
- en: '**A.** It would be a remarkable theoretical breakthrough and solidify the foundation
    of much of computational complexity.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这将是一个显著的理论突破，并巩固了计算复杂性的许多基础。'
- en: '**Q.** Suppose P = NP. Does that mean deterministic TM are the same as non-deterministic
    TM?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设 P = NP。这是否意味着确定性图灵机与非确定性图灵机相同？'
- en: '**A.** Not quite. For example, even if P = NP, a non-deterministic TM may be
    able to solve a problem in time proportional to N^2, where the best deterministic
    one would take N^3\. If P = NP, it just means that the two types of machines solve
    the same set of decision problems in polynomial time, but it says nothing about
    the degree of the polynomial.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不完全是这样。例如，即使 P = NP，非确定性图灵机可能能够在与最佳确定性图灵机相比为 N^3 的时间内解决问题。如果 P = NP，这只是意味着这两种类型的机器在多项式时间内解决相同的决策问题，但它并不说明多项式的次数。'
- en: '**Q.** Where can I learn more about NP-completeness?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我在哪里可以了解更多关于 NP 完全性的知识？'
- en: '**A.** The authoritative reference remains Garey and Johnson *Computers and
    Intractability: A Guide to the Theory of NP-completeness*. Many of the most important
    subsequent discoveries are documented in David Johnson''s [NP-completeness column](http://www.research.att.com/~dsj/columns/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 权威参考仍然是 Garey 和 Johnson 的《计算机与难解性：NP 完全性理论指南》。许多最重要的后续发现都记录在 David Johnson
    的[NP 完全性专栏](http://www.research.att.com/~dsj/columns/)中。'
- en: Exercises
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Suppose that X is NP-complete, X poly-time reduces to Y, and Y poly-time reduces
    to X. Is Y necessarily NP-complete?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 X 是 NP 完全的，X 多项式时间归约到 Y，Y 多项式时间归约到 X。那么 Y 是否一定是 NP 完全的？
- en: '*Answer*: No, since Y may not be in NP. For example if X = CIRCUIT-SAT and
    Y = CO-CIRCUIT-SAT then X and Y satisfy the conditions, but it is unknown whether
    Y is in NP. Note that the answer depends on our definition of poly-time reduction
    (to be Turing reductions and not Karp reductions).'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：不是，因为 Y 可能不在 NP 中。例如，如果 X = CIRCUIT-SAT，Y = CO-CIRCUIT-SAT，那么 X 和 Y 满足条件，但未知
    Y 是否在 NP 中。请注意，答案取决于我们对多项式时间归约的定义（应为图灵归约而不是 Karp 归约）。'
- en: Explain why the optimization version of the vertex cover problem is not necessarily
    a search problem.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释为什么顶点覆盖问题的优化版本不一定是一个搜索问题。
- en: '*Answer*: There does not appear to be an efficient way to certify that a purported
    solution is the best possible (even though we could use binary search on the search
    version of the problem to find the best solution).'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：目前似乎没有有效的方法来证明一个所谓的解决方案是最佳的（即使我们可以在问题的搜索版本上使用二分搜索来找到最佳解决方案）。'
- en: Web Exercises
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: '**Subset sum.** Given N positive integers and a target value V, determine if
    there is a subset whose sum is exactly V. Divide the integers into 4 equal groups.
    Enumerate and store all of the subset sums in each group by brute force. Let A,
    B, C, and D denote the subset sums of the four groups. The goal is to find integers
    a, b, c, and d such that a + b + c + d = V, where a is in A, b is in B, c is in
    C, and d is in D. Now, use a heap to enumerate the sums a + b where a is in A
    and b is in B. Simultaneously, use another heap to enumerate the sums c + d in
    decreasing order, where c is in C and d is in D.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子集和。** 给定 N 个正整数和一个目标值 V，确定是否存在一个子集，其和恰好为 V。将整数分成 4 个相等的组。通过蛮力法列举和存储每组中的所有子集和。让
    A、B、C 和 D 分别表示四个组的子集和。目标是找到整数 a、b、c 和 d，使得 a + b + c + d = V，其中 a 在 A 中，b 在 B
    中，c 在 C 中，d 在 D 中。现在，使用一个堆来列举 a 在 A 中，b 在 B 中的和。同时，使用另一个堆以递减顺序列举 c 在 C 中，d 在 D
    中的和。'
- en: '**Sum of square roots.** What is the minimum nonzero difference between two
    [sums of square roots of integers](http://cs.smith.edu/~orourke/TOPP/P33.html)?
    Given n and k, find the minimum positive value of'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平方根之和。** 两个[整数平方根之和](http://cs.smith.edu/~orourke/TOPP/P33.html)之间的最小非零差是多少？给定
    n 和 k，找到'
- en: '[PRE1]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where ai and bi are between 0 and n. For example r(20, 2) = √10 + √11 - √5
    - √18 and r(20, 3) = √5 + √6 + √18 - √4 - √12 - √12. Hint: enumerate all 2^(n/2)
    sums of square roots of the first n/2 integers and let that set be A, enumerate
    all 2^(n/2) sums of square roots of the last n/2 integers and let that be B. Now
    enumerate sums of a + b in sorted order, where a is in A and b is in B. Look for
    sums whose difference is very tiny.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 ai 和 bi 在 0 和 n 之间。例如 r(20, 2) = √10 + √11 - √5 - √18 和 r(20, 3) = √5 + √6
    + √18 - √4 - √12 - √12。提示：列举前 n/2 个整数的平方根之和的 2^(n/2) 种可能，并将该集合命名为 A，列举后 n/2 个整数的平方根之和的
    2^(n/2) 种可能，并将其命名为 B。现在按排序顺序列举 a 在 A 中，b 在 B 中的和，其中 a 在 A 中，b 在 B 中。寻找差异非常微小的和。
- en: '**Dividing diamonds.** Given N (around 36) class D diamonds, divide them into
    two groups so that they are as close in total weight to each other as possible.
    Assume the weights are real numbers (measured in carats).'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**划分钻石。** 给定 N（大约36）类 D 钻石，将它们分成两组，使它们的总重量尽可能接近。假设重量是实数（以克拉为单位）。'
- en: '**Hamilton path in DAG.** Given a directed acyclic graph G, give an O(n+m)-time
    algorithm to test whether or not it is Hamiltonian. Hint: topological sort.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DAG 中的哈密顿路径。** 给定一个有向无环图 G，给出一个 O(n+m) 时间复杂度的算法来测试它是否是哈密顿图。提示：拓扑排序。'
- en: Which of the following can we infer from the fact that the traveling salesperson
    problem is NP-complete, if we assume that P is not equal to NP?
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果假设 P 不等于 NP，从旅行推销员问题是 NP 完全的这一事实中我们可以推断出以下哪些？
- en: There does not exist an algorithm that solves arbitrary instances of the TSP
    problem.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不存在一个能解决 TSP 问题的任意实例的算法。
- en: There does not exist an algorithm that efficiently solves arbitrary instances
    of the TSP problem.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不存在一个能高效解决 TSP 任意实例的算法。
- en: There exists an algorithm that efficiently solves arbitrary instances of the
    TSP problem, but no one has been able to find it.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个高效解决任意 TSP 实例的算法，但没有人能找到它。
- en: The TSP is not in P.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: TSP 不在 P 中。
- en: All algorithms that are guaranteed to solve the TSP run in polynomial time for
    some family of input points.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有保证解决 TSP 的算法对于某些输入点族都在多项式时间内运行。
- en: All algorithms that are guaranteed to solve the TSP run in exponential time
    for all families of input points.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有保证解决 TSP 的算法对于所有输入点族都运行在指数时间内。
- en: '*Answer*: (b) and (d) only.'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：(b) 和 (d)。'
- en: Which of the following can we infer from the fact that PRIMALITY is in NP but
    not known to be NP-complete, if we assume that P is not equal to NP?
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果假设 P 不等于 NP，从 PRIMALITY 在 NP 中但不知道是否 NP 完全这一事实中我们可以推断出以下哪些？
- en: There exists an algorithm that solves arbitrary instances of PRIMALITY.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个能解决任意 PRIMALITY 实例的算法。
- en: There exists an algorithm that efficiently solves arbitrary instances of PRIMALITY.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个能高效解决任意 PRIMALITY 实例的算法。
- en: If we found an efficient algorithm for PRIMALITY, we could immediately use it
    as a black box to solve TSP.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们找到 PRIMALITY 的一个高效算法，我们可以立即将其用作黑盒来解决 TSP。
- en: '*Answer*: We can infer only (a) since all problems in P are decidable. If P
    != NP, then there are problems in NP that are neither in P or NP-complete. PRIMALITY
    could be one of them (although this was recently disproved). Part (c) cannot be
    inferred since we don''t know if PRIMALITY is NP-complete.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：我们只能推断 (a)，因为所有 P 中的问题都是可判定的。如果 P != NP，那么有些 NP 中的问题既不在 P 中也不是 NP 完全的。PRIMALITY
    可能是其中之一（尽管最近已被证明不是）。部分 (c) 不能被推断，因为我们不知道 PRIMALITY 是否是 NP 完全的。'
- en: Which of the following are NP-complete?
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是 NP 完全的？
- en: The brute force TSP algorithm.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蛮力 TSP 算法。
- en: The quicksort algorithm for sorting.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于排序的快速排序算法。
- en: The Halting problem.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停机问题。
- en: Hilbert's 10th problem.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希尔伯特的第十个问题。
- en: '*Answer*: None. NP-completeness deals with *problems* not specific algorithm
    for problems. The Halting problem and Hilbert''s 10th problem are undecidable,
    so they are not in NP (and all NP-complete problems are in NP).'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：无。NP 完全性涉及*问题*而不是问题的具体算法。停机问题和希尔伯特的第十个问题是不可判定的，因此它们不在 NP 中（所有 NP 完全问题都在
    NP 中）。'
- en: Let X and Y be two decision problems. Suppose we know that X reduces to Y. Which
    of the following can we infer?
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 X 和 Y 是两个决策问题。假设我们知道 X 可归约到 Y。我们可以推断以下哪些？
- en: If Y is NP-complete then so is X.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Y 是 NP 完全的，则 X 也是。
- en: If X is NP-complete then so is Y.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 X 是 NP 完全的，那么 Y 也是。
- en: If Y is NP-complete and X is in NP then X is NP-complete.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Y 是 NP 完全的且 X 在 NP 中，则 X 是 NP 完全的。
- en: If X is NP-complete and Y is in NP then Y is NP-complete.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 X 是 NP 完全的且 Y 在 NP 中，则 Y 是 NP 完全的。
- en: X and Y can't both be NP-complete.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: X 和 Y 不能同时是 NP 完全的。
- en: If X is in P, then Y is in P.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 X 在 P 中，那么 Y 也在 P 中。
- en: If Y is in P, then X is in P.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Y 在 P 中，那么 X 也在 P 中。
- en: '*Answer:* (d) and (g) only. X reduces to Y means that if you had a black box
    to solve Y efficiently, you could use it to solve X efficiently. X is no harder
    than Y.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：(d) 和 (g)。X 可归约到 Y 意味着如果你有一个能高效解决 Y 的黑盒，你可以用它来高效解决 X。X 不比 Y 更难。'
- en: 'Show that CIRCUIT-SAT reduces to CIRCUIT-DIFF. *Hint*: create a circuit with
    N inputs that always outputs 0.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明 CIRCUIT-SAT 可归约到 CIRCUIT-DIFF。*提示*：创建一个具有 N 个输入的电路，总是输出 0。
- en: Show that CIRCUIT-DIFF reduces to CIRCUIT-SAT.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明 CIRCUIT-DIFF 可归约到 CIRCUIT-SAT。
- en: 'Show that DETERMINANT is in NP: given an N-by-N integer matrix A, is det(A)
    = 0?'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明 DETERMINANT 在 NP 中：给定一个 N×N 的整数矩阵 A，det(A) = 0 吗？
- en: '*Solution:* certificate is a nonzero vector x such that Ax = 0.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解法*：证书是一个非零向量 x，使得 Ax = 0。'
- en: 'Show that FULL-RANK is in NP: given an N-by-N integer matrix A, is det(A) ≠
    0?'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明 FULL-RANK 在 NP 中：给定一个 N×N 的整数矩阵 A，det(A) ≠ 0 吗？
- en: '*Solution:* certificate is an N-by-N inverse matrix B such that AB = I.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解法*：证书是一个 N×N 的逆矩阵 B，使得 AB = I。'
- en: '**Search problems vs. decision problems.** We can formulate a search problem
    using a corresponding decision problem. For example, the problem of finding the
    prime factorization of an integer N can be formulate using the decision problem:
    given two integers N and and L, does N have a nontrivial factor strictly less
    than L. The search problem is solvable in polynomial time if and only if the corresponding
    decision problem is. To see why, we can efficiently find the smallest factor p
    of N by using different values of L along with binary search. Once we have the
    factor p, we can repeat the process on N/p.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索问题 vs. 决策问题。** 我们可以使用相应的决策问题来制定一个搜索问题。例如，找到整数 N 的素因子分解问题可以使用决策问题来制定：给定两个整数
    N 和 L，N 是否有一个严格小于 L 的非平凡因子。如果相应的决策问题可在多项式时间内解决，那么搜索问题也可以。为了理解原因，我们可以通过使用不同的 L
    值和二分查找来高效地找到 N 的最小因子 p。一旦我们有了因子 p，我们可以对 N/p 重复这个过程。'
- en: Usually we can show that the search problem and the decision problem are equivalent
    up to polynomial factors in running time. Papadimitriou (Example 10.8) gives an
    interesting counterexample to the rule. Given N positive integers such that their
    sum is less than 2^N - 1, find two subsets whose sum is equal. For example, the
    10 numbers below sum to 1014 < 1023.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常我们可以证明搜索问题和决策问题在运行时间上等价于多项式因子。Papadimitriou（示例 10.8）给出了一个有趣的反例。给定 N 个正整数，它们的和小于
    2^N - 1，找到两个和相等的子集。例如，下面的 10 个数字的和为 1014 < 1023。
- en: 23 47 59 88 91 100 111 133 157 205
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 23 47 59 88 91 100 111 133 157 205
- en: 'Since there are more subsets of N integers (2^N) than numbers between 1 and
    1014, there must be two different subsets with the same sum. But nobody know a
    polynomial time algorithm for *finding* such a subset. On the other hand, the
    natural decision problem is trivial solvable in constant time: are there two subsets
    of numbers that sum to the same value?'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 N 个整数的子集（2^N）比 1 到 1014 之间的数字更多，必然存在两个不同的子集具有相同的和。但没有人知道一个多项式时间算法来 *找到* 这样的子集。另一方面，自然的决策问题在常数时间内是易解的：是否存在两个和相同的数字子集？
- en: '**Pratt''s primality certificate.** Show that PRIMES is in NP. Use Lehmer''s
    theorem (Fermat''s Little Theorem Converse) which asserts that an integer p >
    1 is prime if and only if there exists an integer x such that x^(N-1) = 1 (mod
    p) and x^((p-1)/d) ≠ 1 (mod p) for all prime divisors d of p-1. For example, if
    N = 7919, then the prime factorization of p-1 = 7918 = 2 × 37 × 107. Now x = 7
    satisfies 7^(7918) = 1 (mod 7919), but 7^(7918/2) ≠ 1 (mod 7919), 7^(7918/37)
    ≠ 1 (mod 7919), 7^(7918/107) ≠ 1 (mod 7919). This proves that 7919 is prime (assuming
    that you recursively certify that 2, 37, and 107 are prime).'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**普拉特素性证书。** 证明 PRIMES 属于 NP。使用莱默定理（费马小定理的逆定理），它断言大于 1 的整数 p 是素数当且仅当存在一个整数
    x，使得 x^(N-1) = 1 (mod p) 且 x^((p-1)/d) ≠ 1 (mod p) 对于 p-1 的所有素数因子 d 都成立。例如，如果
    N = 7919，那么 p-1 的素因子分解为 7918 = 2 × 37 × 107。现在 x = 7 满足 7^(7918) = 1 (mod 7919)，但
    7^(7918/2) ≠ 1 (mod 7919)，7^(7918/37) ≠ 1 (mod 7919)，7^(7918/107) ≠ 1 (mod 7919)。这证明了
    7919 是素数（假设你递归地证明了 2、37 和 107 是素数）。'
- en: '**Pell''s equation.** Find all positive integer solutions to Pell''s equation:
    x^2 - 92y^2 = 1. *Solution*: (1151, 120), (2649601, 276240), etc. There are infinitely
    many solutions, but each successive one is about 2300 times the previous one.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**佩尔方程。** 找到佩尔方程 x^2 - 92y^2 = 1 的所有正整数解。*解答*：(1151, 120), (2649601, 276240)，等等。有无穷多解，但每个连续的���大约是前一个解的
    2300 倍。'
- en: '**Pell''s equation.** In 1657, Pierre Fermat challenged his colleagues with
    the following problem: given a positive integer c, find a positive integer y such
    that cy² is a perfect square. Fermat used c = 109\. It turns out the smallest
    solution is (x, y) = (158,070,671,986,249, 15,140,424,455,100). Write a program
    [Pell.java](Pell.java.html) that reads in an integer c and finds the smallest
    solution to Pell''s equation: x² - c y² = 1. Try c = 61. The smallest solution
    is (1,766,319,049, 226,153,980). For c = 313, the smallest solution is ( 3,218,812,082,913,484,91,819,380,158,564,160).
    The problem is provably unsolvable in a polynomial number of steps (as a function
    of the number of bits in the input c) because the output may require exponentially
    many bits!'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**佩尔方程。** 在 1657 年，皮埃尔·费马向他的同事们提出了以下问题：给定一个正整数 c，找到一个正整数 y，使得 cy² 是一个完全平方数。费马使用了
    c = 109。结果表明最小解为 (x, y) = (158,070,671,986,249, 15,140,424,455,100)。编写一个程序 [Pell.java](Pell.java.html)，读入一个整数
    c，并找到佩尔方程的最小解：x² - c y² = 1。尝试 c = 61。最小解为 (1,766,319,049, 226,153,980)。对于 c =
    313，最小解为 ( 3,218,812,082,913,484,91,819,380,158,564,160)。该问题在多项式步数内是无法解决的（作为输入
    c 位数的函数），因为输出可能需要指数级的位数！'
- en: '**3-COLOR reduced to 4-COLOR.** Show that 3-COLOR polynomial reduces to 4-COLOR.
    *Hint*: given an instance G of 3-COLOR, create an instance G'' of 4-COLOR by adding
    a special vertex x to G and connecting it to all of the vertices in G.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-COLOR 归约到 4-COLOR。** 证明 3-COLOR 多项式归约到 4-COLOR。*提示*：给定一个 3-COLOR 实例 G，通过向
    G 添加一个特殊顶点 x 并将其连接到 G 中的所有顶点，创建一个 4-COLOR 实例 G''。'
- en: '**3-SAT is self-reducible.** Show that 3-SAT is self-reducible. That is, given
    an oracle that answers whether or not any 3-SAT formula is satisfiable, design
    an algorithm that can find a satisfying assignment to a 3-SAT formula (assuming
    it is satisfiable). Your algorithm should run in polynomial time plus a polynomial
    number of calls to the oracle.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-SAT 是自可归约的。** 证明 3-SAT 是自可归约的。也就是说，给定一个回答任意 3-SAT 公式是否可满足的预言机，设计一个算法可以找到一个满足条件的
    3-SAT 公式（假设它是可满足的）。你的算法应在多项式时间内运行，再加上多项式次调用预言机。'
- en: '**3-COLOR is self-reducible.** Show that 3-COLOR is self-reducible. That is,
    given an oracle that answers whether or not any graph G is 3-colorable, design
    an algorithm that can 3-color a graph (assuming it is 3-colorable). Your algorithm
    should run in polynomial time plus a polynomial number of calls to the oracle.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-COLOR 是自可归约的。** 证明 3-COLOR 是自可归约的。也就是说，给定一个回答任意图 G 是否可 3-染色的预言机，设计一个算法可以对图进行
    3-染色（假设它是可 3-染色的）。你的算法应在多项式时间内运行，再加上多项式次调用预言机。'
