- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P7：L3- 算法（结构体、搜索与排序）2 - ShowMeAI - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P7：L3- 算法（结构体、搜索与排序）2 - ShowMeAI - BV1Hh411W7Up
- en: do everything。![](img/c1a3243d8952685a8f2dc571e948dab7_1.png)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 做一切。![](img/c1a3243d8952685a8f2dc571e948dab7_1.png)
- en: all right we are back so to recap，we have a couple different algorithms，search。binary
    search is clearly the winner from，all measures we've seen thus far。the catch is
    that the data needs to be，sorted in advance to order to。in order to apply that
    algorithm so，let's just give ourselves a working。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们回来了，简单回顾一下，我们有几种不同的算法，搜索。二分查找显然是所有衡量标准中，胜出者。关键在于数据需要，提前排序，以便应用该算法，所以，让我们给自己一个可行的。
- en: model for what it means to sort，something well as always if you think of，solved。it's
    got input and output and the goal，is to take that input and produce that。output
    well what's the input it's going，to be a whole bunch of unsorted values。and the
    goal of course is to get sorted，values so the interesting part of the，in the middle。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于排序某样东西的模型，像往常一样，如果你想到了，解决。它有输入和输出，目标是将该输入转换为。输出，那么输入是什么呢？它将是一堆未排序的值。目标当然是得到已排序的，值，所以有趣的部分在于，中间。
- en: but just to be even more concrete if we，think now in terms of this。unsorted
    input as being an array of，input because after all that's perhaps，thus far。to
    pass around a bunch of values at once，using just one variable name。we might have
    an array like this，63852741，which seems to be indeed randomly，ordered that is
    unsorted。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了更加具体，如果我们现在考虑这个。未排序的输入作为一个输入数组，因为毕竟这或许，至今。为了同时传递一堆值，仅使用一个变量名。我们可能有一个这样的数组，63852741，这似乎确实是随机，排序的，即未排序。
- en: and we want to turn that into an，three four five，six seven eight so eight numbers
    this。![](img/c1a3243d8952685a8f2dc571e948dab7_3.png)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想把它变成，三四五，六七八，所以八个数字，这。![](img/c1a3243d8952685a8f2dc571e948dab7_3.png)
- en: time instead of seven，but the goal this time is not to search，them per se but
    to sort them。but before i get ahead of myself could，someone push back，on this
    whole intellectual exercise。we're about to do，with sorting in the first place
    like，could someone make an argument as to。why we might not want to bother using，bother，sorting
    the elements and heck let's just。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 时间不是七，而这次的目标不是搜索，值本身，而是对它们进行排序。但在我自言自语之前，有人能对此整个智力练习，提出反对意见吗？我们即将进行，排序的事情，比如，有人能争论一下。为什么我们可能不想费心使用，费心，排序这些元素，反正就让我们这样。
- en: use linear search，to find some element whether it's a，number behind a door。![](img/c1a3243d8952685a8f2dc571e948dab7_5.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性查找，找到某个元素，无论它是否是，门后面的一个数字。![](img/c1a3243d8952685a8f2dc571e948dab7_5.png)
- en: a name in an array like when might we，want to just use linear search。![](img/c1a3243d8952685a8f2dc571e948dab7_7.png)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中一个名字，比如我们什么时候可能会，想要使用线性查找。![](img/c1a3243d8952685a8f2dc571e948dab7_7.png)
- en: and not bother sorting uh sophia what do。![](img/c1a3243d8952685a8f2dc571e948dab7_9.png)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 而且不需要去排序，呃，索非亚，我们该做什么。![](img/c1a3243d8952685a8f2dc571e948dab7_9.png)
- en: that might，terms of，like if we can find something versus，linear search we know
    we can find it。okay quite fair i will concede that，implementing binary search
    not in pseudo，code。is actually more difficult because you，have to deal with rounding
    especially if，an odd number。of doors versus an even number of doors，or an array
    of those lengths。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在某种程度上，比如如果我们能找到某个东西，而线性查找我们知道我们可以找到它。好的，公正，我承认，实施二分查找并非伪，代码。实际上更困难，因为你必须处理四舍五入，特别是如果是奇数。门与偶数门，或这些长度的数组。
- en: honestly you've got to deal with these，rounding up，because any time you divide
    something by。two you might get a fractional value or，you might get a whole number
    so we've。![](img/c1a3243d8952685a8f2dc571e948dab7_11.png)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，你必须处理这些，四舍五入，因为每当你将某物除以。二时，你可能得到一个小数值，或者，你可能得到一个整数，所以我们。![](img/c1a3243d8952685a8f2dc571e948dab7_11.png)
- en: got to make some decisions so it's，totally solvable，and humans for decades have
    been writing。code that implements binary search it's。![](img/c1a3243d8952685a8f2dc571e948dab7_13.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做出一些决策，所以这是完全可解决的，人类几十年来一直在编写。实现二分查找的`code`。![](img/c1a3243d8952685a8f2dc571e948dab7_13.png)
- en: totally possible，there's libraries you can use but it's，definitely more challenging
    and you open。yourselves up to risk，but let me stipulate that that's okay i，i am
    good enough。at this point in my progression where i，pretty sure i could implement
    it。correctly so correctness is not my，concern。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可能，你可以使用库，但这确实更具挑战性，而且你会面临风险，但让我声明这是可以的，我，我在我的进程中，已经足够好到，我相当确定我能正确实施它。所以正确性不是我的，担忧。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_15.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_15.png)'
- en: sorting，an array of elements and what might，motivate me to ah。![](img/c1a3243d8952685a8f2dc571e948dab7_17.png)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 排序，一个元素数组，是什么可能让我动机啊。![](img/c1a3243d8952685a8f2dc571e948dab7_17.png)
- en: just use linear search it's so simple，can anyone propose why olivia what do。if
    the name of the game is efficiency，then，you might as well just uh just search
    it。versus sort it which would be，extra expense yeah really well said if。you've
    got a relatively small data set，and your computer operates at a billion。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就用线性搜索吧，它太简单了，谁能提出为什么，奥利维亚，如果游戏的目标是效率，那么，你不妨直接搜索，而不是排序，这会额外花费一些开销。是的，真的说得好，如果你有一个相对较小的数据集，而你的计算机的处理速度达到十亿。
- en: operations per second for instance，my god who cares if your code sucks and，it's
    a little bit slow。just do it the inefficient way why，because it's going to take
    you maybe a。few minutes to implement the simpler，algorithm like linear search。even
    though it's going to take longer to，run whereas it might take you tens of。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒操作次数，例如，天啊，如果你的代码糟糕且有点慢谁在乎呢？只需用不高效的方式去做，为什么呢？因为实现一个更简单的算法，比如线性搜索，可能只需几分钟。尽管它的运行时间会更长，而这可能需要你花费数十分钟。
- en: minutes maybe an hour or so to not only，write but debug something like the，fancier
    algorithm。like binary search at which point you，might have spent more time。![](img/c1a3243d8952685a8f2dc571e948dab7_19.png)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要几分钟，甚至一个小时，不仅要编写，还要调试像更复杂的算法。比如二分搜索，此时你可能花了更多的时间。![](img/c1a3243d8952685a8f2dc571e948dab7_19.png)
- en: writing the code the faster code than，you would have just，running the slower
    code and i can speak。![](img/c1a3243d8952685a8f2dc571e948dab7_21.png)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码比运行慢代码更快，你只需这样做，我可以说。![](img/c1a3243d8952685a8f2dc571e948dab7_21.png)
- en: to this personally back in grad school，some of the research i was doing。involved
    analysis of very large data。![](img/c1a3243d8952685a8f2dc571e948dab7_23.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起我研究生时期，我所做的一些研究涉及到非常大数据的分析。![](img/c1a3243d8952685a8f2dc571e948dab7_23.png)
- en: sets and i had to write code in order to，analyze this data，and i could have
    spent hours days even。writing the best designed，algorithm i could to analyze the
    data as，efficiently as possible。or frankly i could write the crappy，version of
    the code go to sleep for。![](img/c1a3243d8952685a8f2dc571e948dab7_25.png)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集合，我必须编写代码来分析这些数据，我可能花了几个小时、几天，甚至。编写我能设计的最佳算法，以尽可能高效地分析数据。或者说，我可以写一个糟糕的版本的代码，然后去睡觉。![](img/c1a3243d8952685a8f2dc571e948dab7_25.png)
- en: eight hours and my code will just，produce the output i want by morning。![](img/c1a3243d8952685a8f2dc571e948dab7_27.png)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 八个小时，我的代码将在早上生成我想要的输出。![](img/c1a3243d8952685a8f2dc571e948dab7_27.png)
- en: and that is a very real world reasonable，trade-off to make and indeed this is。going
    to be thematic in the weeks，that proceed in the course where there's。going to
    be this trade-off and quite，often the trade-off is going to be time。or complexity
    or the amount of space or，memory that you're using。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常现实且合理的权衡，确实，在接下来的几周里，这将成为课程的主题。将会有这种权衡，而这种权衡往往是时间、复杂性，或者你所使用的空间或内存量。
- en: and part of the um the art of being a，programmer，is trying to decide where the
    line is do。![](img/c1a3243d8952685a8f2dc571e948dab7_29.png)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 而成为程序员的艺术之一，就是尝试决定界限在哪里。![](img/c1a3243d8952685a8f2dc571e948dab7_29.png)
- en: you exert more effort up front to make a，better faster more efficient algorithm。![](img/c1a3243d8952685a8f2dc571e948dab7_31.png)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在前期投入更多的努力，以创造一个更好、更快、更高效的算法。![](img/c1a3243d8952685a8f2dc571e948dab7_31.png)
- en: or do maybe cut some corners there so，resource。![](img/c1a3243d8952685a8f2dc571e948dab7_33.png)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或许在那里可以稍微简化一些，所以资源。![](img/c1a3243d8952685a8f2dc571e948dab7_33.png)
- en: challenging，problems so we for the course's problem，sets and labs will always
    prescribe。what's most important but in a few weeks，time with one of our problem
    sets will。you implement your very own spell，checker and among the goals of that，minimize。the
    amount of time your code is taking，to run and also to minimize the amount，of space
    or memory。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战性问题，因此我们在课程的问题集和实验室中总是会规定。最重要的是什么，但在几周后，你将会实现你自己的拼写检查器，其中的目标之一是。最小化你的代码运行所需的时间，以及最小化占用的空间或内存。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_35.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_35.png)'
- en: running，and so we'll begin to appreciate those，trade-offs ever more。but indeed
    it's the case and i really，like olivia's formulation of it。if your data set is
    pretty small it's，probably not worth writing the fastest。best designed algorithm
    as possible just，write it the simple way the correct way。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行，所以我们会越来越欣赏这些权衡。但确实如此，我真的很喜欢奥利维亚的说法。如果你的数据集很小，可能不值得编写最快、最好设计的算法，只需简单而正确地编写即可。
- en: and get the answer quickly and move on。![](img/c1a3243d8952685a8f2dc571e948dab7_37.png)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 快速得到答案并继续前进。![](img/c1a3243d8952685a8f2dc571e948dab7_37.png)
- en: but that's not going to be the case for，a lot of problems they're saying most，problems
    in life。![](img/c1a3243d8952685a8f2dc571e948dab7_39.png)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是许多问题的情况，他们说大多数生活中的问题。![](img/c1a3243d8952685a8f2dc571e948dab7_39.png)
- en: if you're building facebook or instagram，or whatsapp or any of today's most，popular
    services。that are getting thousands millions of，new pieces of data at a time。you
    can't just linearly search all of，your friends or connections on linkedin。efficiently
    you can't just。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建Facebook、Instagram、WhatsApp或任何今天最受欢迎的服务，它们在短时间内获取成千上万的新数据。你不能仅仅线性搜索你在LinkedIn上的所有朋友或连接，高效地进行，你不能这样做。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_41.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_41.png)'
- en: linearly search the billions of web，pages that google，and microsoft index in
    their search。![](img/c1a3243d8952685a8f2dc571e948dab7_43.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索谷歌和微软在其搜索中索引的数十亿网页。![](img/c1a3243d8952685a8f2dc571e948dab7_43.png)
- en: it and，undoubtedly the more successful your，programs are and your code are。your
    websites your apps whatever the，case may be the more important design，does come
    into play so。is not to search，these doors once the goal is not to，search these
    light bulbs once the goal。is not to search the phone book once，but rather again
    and again and again and。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 而且无疑，你的程序、代码、网站、应用程序等越成功，设计就越重要。因此，目标不是一次性搜索这些门，目标不是一次性搜索这些灯泡，目标不是一次性搜索电话簿，而是一次又一次。
- en: if that's going to be the case，then we probably should spend a little。more time
    and a little more complexity，up front getting our code not only right，but also
    efficient。so that we can benefit from that，efficiency again and again and again。over
    time so how might we go about，sorting some numbers so，in fact let me see to do
    this if we can。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，我们可能应该花更多的时间和一点复杂性，提前让我们的代码不仅正确，而且高效。这样我们才能从这种效率中一次又一次地受益。
- en: maybe get a hand from brian，in back brian do you mind helping with，sorting。yeah
    absolutely so i've got eight，be，you go ah**d，and uh could you sort these eight，order。so
    we'll take these，sorted order yeah，indeed i agree and now let's take some。critique
    from the audience some，observations would someone mind，explaining how brian just
    sorted。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也许让布莱恩帮忙，布莱恩，你愿意帮忙排序吗？是的，当然可以，我有八个数字，你可以开始排序这八个数字。我们将把它们按照排序顺序放好，确实，我同意，现在让我们听听观众的意见，有人愿意解释一下布莱恩是如何排序的吗？
- en: those eight numbers what did brian，just do step by step in order to get to，that
    end result，sorted。so what did he do peter what'd you see，happen，uh he went through
    them step by step and。if they weren't in，ended up doing it，until they were all
    in the correct yeah。he kept step by step kind of looking for，small values and
    moving them to the left。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这八个数字，布莱恩是如何一步一步地达到最终结果进行排序的呢？彼得，你看到他做了什么，呃，他一步一步地检查，如果它们没有排好，就一直进行下去，直到它们全部正确。他不断地寻找小值并将其移动到左边。
- en: and looking for big values and moving，them to the right so effectively。selecting
    numbers one at a time and，let's see this，maybe in more slow motion if you will。brian
    and if you could be a little more，doing，i see you've already reset the numbers。to
    their original，unsorted order why don't we go ah**d and，start a little more methodically
    and。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 并寻找大值并将其移动到右边，因此有效地一次选择一个数字。如果你愿意，布莱恩，我们可以看看更慢一点的过程。如果你能更有条理地进行，我看到你已经将数字重置为它们的原始无序状态，为什么我们不更有条理地开始呢。
- en: could you go ah**d and for us，more slowly this time select the，smallest value。because
    i do think per peter it's going，to need to end up at the far left。uh yeah sure
    so i'm looking at the，numbers and the one is the smallest。so i now have the smallest
    value all，right so you did that really quickly but。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你能再慢一点，选择最小的值吗？因为我认为，彼得，它需要放在最左边。呃，当然可以，我正在看这些数字，1是最小的。好的，我现在有了最小值，你做得很快，但。
- en: i feel like you took the liberty of，being a human who can kind of have this，once。but
    be a little more computer-like if，you could and if these eight numbers are，technically
    an array。kind of like my seven doors out here，such that you can only look at one，number
    at a time。can you be even more methodical and，deliberate this time in telling
    us how。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得你太随意了，作为一个人可以有这种感觉。但如果你能更像计算机一点，如果这八个数字实际上是一个数组。就像我这里的七扇门一样，每次只能看一个数字。你能不能更有条理、更谨慎地告诉我们如何。
- en: you found the smallest number to put，into place，sure i guess since the computer
    can only。look at one number at a time i would，start at the left side of this array。and
    work my way through the right，looking at each number one at a time。so i might
    start with the six and say，okay this right now is the。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到最小的数字放入位置，当然，我想既然计算机一次只能看一个数字，我会从这个数组的左侧开始。然后逐步向右查看每个数字。所以我可能从六开始，问，好的，现在这是。
- en: smallest number i've looked at so far，but then i look at the next number and，six
    so。now the three that's the smallest number，keep looking，the eight is bigger than
    the three so i。don't need to worry about that the five，is bigger than three，the
    two is smaller than the three so。that now is the smallest number i found，so far，but
    i'm not done yet so i'll keep。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我目前看到的最小数字，但我再看下一个数字，六。所以现在的三是最小数字，继续查看，八比三大，所以我。无需担心，五也比三大，二比三小，所以。现在这是我找到的最小数字，但我还没完成，所以我会继续。
- en: looking the seven is bigger than the two，the four is bigger than the two。but
    the one is smaller than the two so，now i've made my way all the way to the，end
    of the array。and one i can say is the smallest number，that i've found okay so
    what i'm hearing。is you're doing all of these comparisons，also similar to what
    peter implied。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 看看七比二大，四比二大。但一比二小，所以我现在已经走到了数组的尽头。可以说一是我找到的最小数字，好的，所以我听到的是你在做这些比较，和彼得暗示的也很相似。
- en: and you keep checking is this smaller is，this smaller is this smaller and you're。keeping
    track of the currently smallest，number you've seen，yeah that sounds about right
    all right。so you found it and i think it belongs，at the beginning so how do we
    put this，into place now。yeah so i want to put it at the，beginning there's not
    really space for。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在检查这个小吗？这个小吗？这个小吗？你在跟踪当前看到的最小数字。是的，听起来没错。所以你找到了，我觉得它应该放在开头。那么我们现在如何将其放入位置？是的，我想把它放在开头，但没有真正的空间。
- en: it so i could make space for it just by，like shifting these numbers over。okay
    wait wait but i feel like you're，just now you're doubling the amount of，work i
    i feel like。don't don't do all that that feels like，you're going to do more steps
    than we。need what else could we do here，okay so the other option is it needs to。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我可以通过将这些数字移动来为它腾出空间。好的，等等，但我觉得你刚才增加了工作量。我觉得。不要这样做，那感觉你要做更多步骤，比我们需要的多。我们还可以做些什么？好的，另一个选项是它需要。
- en: go in this spot like this first spot in，the array so i could just put it there。but
    if i do that i'm going to have to，take the six which is there right now，and pull
    the six out。all right place but the six isn't yeah i，agree but i think that's
    okay right。because this these numbers started，randomly and so the six is in the
    wrong。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样在数组的第一个位置，所以我可以把它放在那里。但如果这样做，我必须把现在在那里的六拿出来。好的位置，但六不在。我同意，但我认为这样没关系。因为这些数字是随机开始的，所以六在错误的位置。
- en: place anyway i don't think we're making，the problem any worse by just moving
    it。elsewhere and indeed it's a lot faster i，would think to just swap two numbers，move
    one to the other。and vice versa then shift all of those，numbers in between，yeah
    so i took the one out of the。position at the very end of the array，all the way
    on the right hand side so i。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我认为通过仅仅移动它，我们并没有让问题变得更糟。事实上，我认为交换两个数字，把一个移动到另一个，反之亦然，然后移动之间的所有数字，这样会更快。是的，所以我把一从数组的最末尾位置拿出来，全部在右侧，所以我。
- en: guess i could take the six，and just put it there because that's，number。yeah
    and it's not exactly in the right，space but again it's no worse off so i。like
    that all right but now the fact，that the one is in the right place and。indeed
    you've illuminated it to，indicate as much i feel like we can。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我可以把六放在那里，因为那是，数字。是的，虽然不完全在正确的位置，但没关系，所以我。喜欢这样，但现在这个一在正确的位置上，而且你确实照亮了它，表明这一点，我觉得我们可以。
- en: pretty much ignore the one henceforth，and now just select the next smallest。element
    so can you walk us through that，yeah so i guess i'd repeat the same。process i
    start with the three that's，the smallest number i've found so far。and i'd keep
    looking the eight is bigger，the three，the two is smaller than the three so。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从此基本上忽略这个一，现在只选择下一个最小的元素。所以你能带我们走过这个过程吗？是的，我想我会重复同样的过程，我从三开始，这是我目前找到的最小数字。我会继续寻找，八更大，三，二比三小。
- en: i'll remember that two that's the，smallest thing i've seen so far。and then i
    just need to check to see if，there's anything smaller than the two。and i look
    at the seven the four and the，six none of those are smaller than the。two so the
    two i can say，is the next smallest number for the，then。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我会记住二是我见过的最小的数字。然后我只需要检查一下是否有比二更小的。我看看七、四和六，这些都没有比二小，所以我可以说二是下一个最小的数字。
- en: that needs to go in the second spot so，i'll need to pull the three out。and i
    guess i can take the three and，just put it into this open spot where，there's available
    space。yeah and i feel like it's it's starting，to become clear that we're inside
    some。kind of loop because you pretty much，told the same story again but with a。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那个需要放在第二个位置，所以我需要把三拿出来。我想我可以把三放到这个空位置，那里有可用的空间。是的，我觉得这开始变得清晰了，我们进入了一种循环，因为你几乎又讲了同样的故事，但换了一种方式。
- en: different number do you mind just，continuing the algorithm to the end and。select
    the next smallest next smallest，next smallest and get this sorted。sure so we got
    the eight five is smaller，than that three is smaller than that。and then the rest
    of the number is seven，***** those are all bigger。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数字，你介意继续算法直到结束，选择下一个最小的、下一个最小的、下一个最小的并使其排序吗？当然，所以我们得到了八，五比那个小，三比那个小，然后剩下的数字是七，*****
    这些都是更大的。
- en: so the three that's going to go into，sorted position here and i'll take the，eight
    and swap it。now i'm going to look at the 5 8 and 7，the 5，but the 6 is bigger so
    the 4 that's the。smallest number i've seen so far，so the 4 that's going to go
    into place，and i'll swap it with the 5。and now i've got the 8 the seven is，smaller
    than the eight so i'll remember。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以三将放入已排序的位置，我会把八换掉。现在我会看 5、8 和 7，5，但六更大，所以四是我目前见过的最小数字，所以四将放在这个位置，我会把它和五交换。现在我有了八，七比八小，所以我会记住。
- en: that five is smaller than that，but the six is bigger so the five that's，going
    to be the next number。and now i'm left with seven eight is，bigger so seven is
    still the smallest。i've seen but six is smaller，last，two and between the last
    two the eight。and the seven the seven is smaller，so the seven is going to go in
    this spot。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 五比那个小，但六比那个大，所以五将是下一个数字。现在我剩下七，八更大，所以七仍然是我见过的最小的，但六比最后两个小，而在最后两个之间，八和七，七是更小的，所以七将放在这个位置。
- en: and at this point i've only got one，number left，so that number must be in sorted。position
    and now i would say that，this is a sorted array of numbers nice，so it it。seems
    definitely seems to be correct it，felt a little slow but of course the，we。using
    an actual array and if if you，don't mind making an observation it，looks like if
    we have eight。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我只剩下一个数字，所以这个数字必须在已排序的位置上，现在我可以说这是一个已排序的数字数组，看起来确实是正确的，感觉有点慢，但当然我们使用的是实际的数组，如果你不介意观察一下，看起来如果我们有八。
- en: numbers to begin with or n more，did，n minus one comparisons because you。you
    kept comparing numbers again，actually you did n comparisons。you looked at the
    first number and then，you compared it again and again and。again at all of the
    other possible，values in order to find the smallest，element。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始有多少个数字，或者说 n 个数字，进行了 n 减 1 次比较，因为你一直在比较数字，其实你做了 n 次比较。你看了第一个数字，然后又一遍一遍地比较了所有其他可能的值，以找到最小的元素。
- en: yeah because for each of the numbers in，see，is it smaller than the smallest
    thing，smaller。then i needed to remember that yeah so，in each pass you considered。every
    number so a total of n numbers，first until you found the number one you，be clear
    with n。minus one numbers thereafter and then，after that n minus two numbers n。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，因为对于每一个数字，我要看看它是否比最小的那个小。然后我需要记住这一点，所以在每一轮中，你考虑了每个数字，总共 n 个数字，首先直到你找到了一个数字，接下来要清楚
    n 减 1 的数字，然后是 n 减 2 的数字。
- en: minus three numbers dot dot dot all the，way down to one final number。so i think
    this is correct and i think，that's a pretty deliberate way。of sorting these elements
    a little more，deliberately than your first approach。brian which i might describe
    as a little，more organic you kind of did it like。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 减去三个数字……一直到最后一个数字。所以我认为这是正确的，我认为，这是一种相当有意识的方式。来对这些元素进行排序，比起你最初的方法，布莱恩我可能会描述为更有机一点，你有点像。
- en: more like a human just kind of，eyeballing things and moving things。around but
    if we were to translate this，into code recall that we have to be ever，so precise。and
    so let me consider altogether how，exactly we might translate what brian，did ultimately
    to。again pseudo code so what he did is，actually an algorithm that has a name，it's
    called selection。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更像是人类，只是稍微观察一下，然后移动东西。但如果我们要把这个，翻译成代码，请记住我们必须非常，精确。所以让我考虑一下，究竟如何将布莱恩所做的，最终再翻译成。伪代码，所以他所做的实际上是一个有名字的算法，叫做选择。
- en: sort why well it's sorting the elements，ultimately and it's doing so by having。brian
    or really the computer，again and again，and once you found each such small，just
    ignoring it。indeed every time brian lit up a number，he didn't need to keep comparing
    it。so the amount of work we he was doing，was decreasing each iteration。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 排序，为什么呢？因为最终它是在排序这些元素，而是通过让，布莱恩或实际上是计算机，一次又一次地进行操作，一旦你找到了每个这样的小，实际上忽略它。确实，每次布莱恩亮起一个数字，他并不需要继续比较它。所以我们所做的工作量，在每次迭代中都在减少。
- en: n numbers then n minus 1 then n minus 2，n minus 3 and so forth，and so we can
    think about the running。time of this algorithm，as uh being manifest in its actual，pseudo
    code so how might we define the。pseudo code well let me propose that we，think
    of it like this，for i from 0 to n minus 1。 now。undoubtedly this is。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: n 个数字，然后 n 减 1，然后 n 减 2，n 减 3，等等，所以我们可以把这个算法的运行。时间视为它实际的伪代码。那么我们该如何定义这个。伪代码呢？让我提议我们把它想象成这样，从
    0 到 n 减 1 的 i。现在，毫无疑问这是。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_45.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_45.png)'
- en: probably the most cryptic looking line，screen，but again this is the kind of
    thing that，just。instincts with code we've seen and see，how you can write a for
    loop。for loops typically by convention start，counting at zero，but if you have
    n elements you don't。want to count up through，n you want to count up 2 n or，equivalently
    up through n minus 1。 so。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是最难懂的行，屏幕，但再说一次，这正是我们本能地使用代码看到的类型，看看你如何写一个 for 循环。for 循环通常按惯例从零开始计数，但如果你有
    n 个元素，你并不想，数到 n，而是想数到 2 n，或者等效地数到 n 减 1。所以。
- en: from 0 to n minus 1。all right now what do i want to do on，the next on the first
    iteration，item。and the last item so this is not quite，obvious i think at first
    glance but i do。think it's a fair characterization of，what brian did，because if
    i is initialized to zero that。the first，number on the very left of the the shelf，and
    what he then did was she found the。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从 0 到 n 减 1。好吧，现在在第一次迭代中，我想要做什么，项。和最后一项，所以这一点在第一眼看上去并不是很明显，但我认为这公正地描述了，布莱恩所做的，因为如果
    i 初始化为零，那么就是架子上最左边的第一个，数字，而他接下来做的是找到。
- en: smallest element，between the ith item the first item zero，and the last item
    so that's kind of a。very fancy way of saying brian find the，smallest element among，all
    n elements then what he did。was small swap the smallest item with，the ith item
    so we just did that，switcheroo，everything。over he instead just made room for it
    by，swapping it with the，value that was in its wrong place but。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最小元素，在第 i 个项与第一个项零之间，以及最后一个项，所以这有点像是。非常花哨的说法，布莱恩找到了，所有 n 个元素中的最小元素，然后他所做的就是将最小项与，第
    i 个项交换，所以我们就这样，交换了一切。他只是通过将它与，错误位置中的值交换来为它腾出空间，但。
- en: now in the next iteration of this loop，consider how a for loop works you do
    an，i plus plus。implicitly in pseudocode that's what's，happening here so now i
    equals one，item。item one zero indexed and the last item，so this is a fancy way
    of saying brian，check all of the。n elements again except for the first，because
    now you're starting at location。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这个循环的下一次迭代中，考虑一下 for 循环是如何工作的，你执行 i 加 1。在伪代码中，这正是这里发生的事情，所以现在 i 等于 1，项。项
    1 零索引和最后一项，所以这是一种花哨的说法，布莱恩再次检查所有的。n 个元素，除了第一个，因为现在你是从位置开始的。
- en: one instead of location zero，and now the algorithm proceeds so you。could write
    this code in different ways，in english like pseudocode but this。seems to be a
    reasonable formulation of，exactly that algorithm。but let's see it a little more
    visually，the，humans moving around the numbers let me。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从位置一而不是零，现在算法继续进行。所以你可以用不同的方式用英文写出这段代码，就像伪代码，但这似乎是对该算法的合理表述。让我们更直观地看看，人类在数字中移动，让我。
- en: go ah**d and use this visualization and，we'll put a link on the course's website。if
    you'd like to play with this as well，this is just someone's visualization of。an
    array of numbers but this time rather，than represent the numbers as symbols，decimal
    digits。now this person is using vertical bars，like a bar chart and what this means
    is。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用这个可视化，我们将在课程网站上放一个链接。如果你也想尝试一下，这只是某人的数字数组的可视化，但这次不是用符号、十进制数字来表示数字。现在这个人使用垂直条，就像条形图一样，这意味着。
- en: that a small bar is like a small number，and a big bar is a big number so the。goal
    here is to sort these bars，which equivalently might as well be，numbers from short
    bars。over to tall bars left to right and i'm，going to go ah**d and along the top
    of。the menu here i can choose my sorting，algorithm and the one we just described。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 小条就像小数字，大条就像大数字，所以目标是对这些条进行排序，这也可以看作是从短条到高条的数字排序，从左到右。我将继续在菜单顶部选择我的排序算法，就是我们刚刚描述的那个。
- en: recall was selection sort，notice，it takes a moment i think to wrap your。mind
    around what's happening here，but notice that this pink line is going，from left
    to right。because that's essentially what brian，was doing he was walking back and
    forth。back and forth back and forth through，that shelf of numbers，looking for
    the next smallest number and。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下选择排序，注意一下，我想要花点时间理解这里发生的事情，但注意这条粉色线是从左到右移动的。因为这正是布莱恩所做的，他在数字架上来回走，寻找下一个最小的数字。
- en: he kept putting the smallest number，over on the left where it belongs and。![](img/c1a3243d8952685a8f2dc571e948dab7_47.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 他把最小的数字放在左边，正好在它应该的位置上。![](img/c1a3243d8952685a8f2dc571e948dab7_47.png)
- en: indeed that's why in this visualization，you see the small numbers beginning
    to。be put into place on the left，as we keep swooping through but notice，the colored
    bar。keeps starting later and later more，rightward and more right where just like，brian
    was not re。tracing his steps as soon as he lit up，the numbers he left them alone。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，这就是为什么在这个可视化中，你看到小数字开始被放置在左边，我们不断地扫描，但注意，彩色条逐渐向右移动，就像布莱恩不再回头一样，一旦他点亮了数字，就让它们保持不变。
- en: and voila all of these numbers are now，sorted so that's just a graphical way
    of。thinking about the same algorithm but，how efficient or inefficient was that。well
    let's see if we can apply some，numbers here but there's also ways to do，which
    will do。too so if the first time through the，shelf of numbers，he had eight numbers
    at his disposal he。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 瞧，这些数字现在都已排序，这只是以图形化的方式来思考相同的算法，但那样效率如何呢？让我们看看能否在这里应用一些数字，但还有其他的方法可以做到，所以如果第一次通过数字时，他有八个数字可用，他。
- en: had a look at all eight numbers in order，so that's，end steps initially the next
    time he did。a pass through the shelf，he ignored the brightly lit number one，because
    it was already in place by。definition of what he had already done，so now he had
    n minus one steps to go。then he did another n minus two steps，then n minus three
    n minus four n minus。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 查看所有八个数字的顺序，所以这是最初的结束步骤，下次他经过货架时，他忽略了已经被点亮的数字一，因为根据他已经做过的定义，它已经在正确的位置上。现在他只需进行n减一的步骤。然后他进行了n减二的步骤，接着是n减三、n减四。
- en: five dot dot dot all the way down to the，final step，where he just had to find
    and leave。alone the number eight，because that was the biggest number so，one single
    step so this。is uh some kind of series here，mathematically you might recall。something
    like this at like the back of，your math book or in high school or back。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从五，一直到最后一步，他只需找到并留在原地的数字八，因为这是最大的数字，所以只需一步。这是某种数学序列，你可能会记得在数学书的最后一页或高中的时候。
- en: at your physics textbook or the like，it turns out that this actually sums up，to
    this formula here。n times n plus 1 divided by 2。and if，that's not familiar you
    don't remember。that no big deal just let me stipulate，we began，where we had the
    series of n plus n。minus one plus n minus two plus n minus，three dot dot dot，simply
    sums up ultimately to the more。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的物理教科书或类似的书籍中，结果证明这实际上归结为这个公式。n 乘以 n 加 1 除以 2。如果你对此不熟悉，没关系，只要让我说明，我们开始于 n
    加 n，减去 1，加 n 减去 2，加 n 减去 3，依此类推，最终简单地归结为更简洁的 n 乘以 n 加 1 除以 2。
- en: succinct n，times n plus one divided by two this of，squ*red plus，propose。gives
    us yes this n squ*red divided by 2，plus n over 2。so if we really wanted to，be
    nitpicky。this is the total number of steps or，operations or，seconds however we
    want to measure。brian's running time，this seems to be the precise，mathematical
    formula therefore。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 squ*red 加上提议，给我们的是是的，这个 n squ*red 除以 2，加上 n 除以 2。所以如果我们真的想要斤斤计较，这是总步骤数或操作数或秒，无论我们想如何衡量，布赖恩的运行时间，这似乎是精确的数学公式。
- en: but at the beginning of this week we，considered again the sort of big o。notation
    with a wave of the hand we care，more about the order of magnitude on。which an
    algorithm operates i really，don't care about these，these uh divided by 2 and n
    over 2。because which of these factors is going，to matter as n gets big。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在本周初，我们再次考虑了那种大 O 符号，挥一挥手，我们更关心的是算法运行的数量级，我真的不在乎这些，分之二和 n 除以二，因为当 n 变大时，哪一个因素会重要。
- en: the bigger the phone book gets the more，doors we have，the more light bulbs we
    have the more。numbers we have on the shelf，n is going to keep getting bigger and。bigger
    and bigger and given that which，is the dominant factor，rung shin if we could call
    in someone。here which of these factors，n squ*red divided by 2 or n divided by
    2，problems。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 电话簿越大，我们拥有的门越多，灯泡越多，架子上的数字越多，n 会不断变得越来越大，考虑到这个主导因素，如果我们可以请来某个人，哪一个因素，n squ*red
    除以 2 还是 n 除以 2，问题。
- en: get bigger and bigger as n gets bigger，and bigger，dominates，the，no problem it
    would be the n squ*red。yeah n squ*red right if you take，any number for n and you
    squ*re it，that's going to be bigger。certainly in the long run than just，doing
    n divided by two and so with our。big o notation we could describe the，running
    time of brian's，on the order of n。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 n 的增大，变得越来越大，主导着，没有问题的将是 n squ*red。是的，n squ*red 对于任何 n 的值，你只需将其平方，结果会比仅仅做
    n 除以 2 的值大得多，因此在我们的大 O 符号中，我们可以描述布赖恩的运行时间在 n 的数量级上。
- en: squ*red yes i'm ignoring some numbers，and yes if we really wanted to be。nitpicky
    and count up every single step，that brian took，yes it's n squ*red divided by two
    plus n。over two but again，if you think about the problem over time，and n getting
    really large sort of。facebook size twitter size google size，what's really going
    to dominate，mathematically is this。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: squ*red 是的，我忽略了一些数字，是的，如果我们真的想要斤斤计较并计算布赖恩每一步，确实是 n squ*red 除以二加上 n 除以二，但再说一次，如果你考虑这个问题的时间，以及
    n 变得非常大，类似 Facebook、Twitter 和 Google 的规模，数学上真正主导的就是这个。
- en: this bigger factor here that's what's，going to make the total number of steps。way
    bigger than just those smaller，ordered terms so in big o notation。selection sort
    would seem to be on the，order of n squ*red so if we consider our，chart from before。where
    we had the upper bounds on our，searching algorithms，both linear and binary this
    one。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里更大的因素会使总步骤数远远大于那些较小的有序项，所以在大 O 符号中，选择排序似乎是在 n squ*red 的数量级上。所以如果我们考虑之前的图表，其中我们对线性和二分搜索算法的上界进行了划分，这个是。
- en: unfortunately is that really the tip。![](img/c1a3243d8952685a8f2dc571e948dab7_49.png)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这真的是个小问题。![](img/c1a3243d8952685a8f2dc571e948dab7_49.png)
- en: top of this particular list of running，times and there's infinitely many more。these
    are just a subset of the more，common formulas that a computer。scientist might
    use and think about，selection sort is kind of a top the list。and being number
    one on this list is bad，n squ*red is certainly much slower than，constant time。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定运行时间列表的顶部，还有无数更多的。这些只是计算机科学家可能使用和思考的更常见公式的子集，选择排序算是列表的顶部，排在第一位显然是糟糕的，n squ*red
    绝对比常数时间慢得多。
- en: or one step so i wonder if we could be，if we could do a little better i wonder。if
    we could do a little better，and peter actually did say something。else earlier
    which was about like，comparing two numbers and fixing，that。let me propose that
    we brian return to，you for a look at an algorithm that，might be called instead。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者说一步，所以我在想我们是否可以做得更好，我想知道。彼得实际上之前说过一些其他的事情，关于比较两个数字并修复它。让我建议我们让布莱恩回到你这里，看看可能会被称为其他算法的东西。
- en: bubble sort bubble sort being a，different algorithm this one that。tries to fix
    problems more locally so in，fact brian if you look at the numbers。that are in
    front of you which you've，location，i feel like this really if we focus on，small。numbers
    like last time we tried to solve，thing，what if we just look at pairs of numbers。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序，冒泡排序是一种不同的算法，它试图更局部地修复问题。实际上，布莱恩，如果你看看你面前的数字，你的位置，我感觉如果我们关注小数字，就像上次我们试图解决的问题那样，如果我们只看数字对。
- en: that are adjacent to one another，can we maybe make some little tweaks and，for
    instance。brian six and three what can you what，observation can you make there
    for us。yeah sure so six and three that's the，first pair of numbers in the array。and
    if i want the array to be sorted i，want the smaller numbers to be on the，right。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那些相邻的数字，我们可以稍微做一些小的调整，比如说。布莱恩，六和三，你能给我们什么观察？是的，当然可以，六和三是数组中的第一对数字。如果我想让数组被排序，我希望较小的数字在右边。
- en: so just looking at this pair i can tell，you that the six and three are out of。order
    the three should be on the left，and the six should be on the right。all right so
    let's go ah**d and do that，those two，and just fix a small little problem and。now
    let's repeat this process right，our algorithms so，six and eight is the next such
    pair what，those。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以只看这一对，我可以告诉你六和三是乱序的，三应该在左边，而六应该在右边。好的，那我们来做吧，修复这两个，只修复一个小问题。现在让我们重复这个过程，对吧，我们的算法，所以六和八是下一个这样的对，那是什么呢？
- en: that particular pair seems okay because，the six is smaller and it's already
    on。the left side so i think i can leave，this pair alone all right how about，eight
    and five。uh the eight is bigger than the five so，i'm going to swap these two the
    five。should be on the left of the eight，all right and eight and two same thing。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 那一对似乎没问题，因为六比较小，而且它已经在左边，所以我想我可以让这一对保持不变。好吧，八和五呢？呃，八比五大，所以我要交换这两个，五应该在八的左边。好的，八和二也是一样的情况。
- en: here the eight is bigger so the eight's，gonna be swapped with the two。all right
    eight and seven the eight is，bigger than the seven so the eight i。should switch
    with the seven，all right eight and four eight and four。same thing eights bigger
    than the four，and eight and one i can do it one last。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里八比二大，所以八要和二交换。好的，八和七，八比七大，所以我应该和七交换，好的，八和四也是一样，八比四大，八和一我可以最后再做一次。
- en: time the eight's bigger than the one，and i've made that swap and with a nice。dramatic
    flourish if you step off to the，side voila，not sorted in fact it doesn't really。look
    all that much better but，i do think brian's done something smart。here brian can
    you speak to at least，some of the marginal improvements。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这次八比一大，我已经交换了，并且有一个很不错的戏剧性效果，如果你走到一边，瞧，实际上没有排序，事实上，看起来并没有好多少，但我确实认为布莱恩做了一些聪明的事情。布莱恩，你能谈谈至少一些边际改善吗？
- en: that you've made yeah so there are some，improvements at least the one originally，moved
    back。one spot and the other improvement i，think is that the 8 originally was way，somewhere。but
    because the 8 is the biggest number，i kept switching it over and over again。until
    it made it all the way to the end，and so now actually i think this 8 is in，number。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你做出的改进是的，至少有一些改善，最初的一个向后移动了一格，而我认为另一个改善是，八最初在某个地方。但因为八是最大的数字，我不断地将它交换，直到它完全到达了末尾。所以现在实际上我认为这个八是在正确的位置。
- en: and it ended up moving its way all the，way to the right side of the array。yeah
    and this is where this algorithm，that we'll see the rest of in just a，moment gets
    its name。bubble sort alludes to the fact that the，biggest numbers start。bubbling
    their way up to the top of or，the end of the list at the at the right，but notice。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它最终移动到了数组的右侧。是的，这就是我们稍后会看到的算法的名称来源。冒泡排序暗示着最大的数字开始。逐渐上升到列表的顶部或末尾，注意。
- en: as brian does too the number one only，moved over one position so there's。clearly
    more work to be done and that's，misordered，as well but we have improved things
    the。eight is in place，and one is closer to being in place so，how might we proceed
    next well brian。let's continue to solve some small bite，size problems let's start
    at the。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如布赖恩所做的那样，数字一只移动了一位，所以显然还有更多的工作要做，那也是错位的，但我们已经改善了一些，八在位置上，而一更接近于到达位置。那么接下来我们可能怎么做呢？好吧，布赖恩。让我们继续解决一些小的、易处理的问题，从。
- en: beginning again three and six，sure the three and the six those seem to。be in
    order so i'll leave those alone，six and five，six and five are out of the order
    so。it to the right，six and two those are out of order as，well so i'll swap the
    two and the six。six and seven six and seven are okay，they're in order seven and
    four。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次开始，三个和六，确保这三个和六看起来是有序的。所以我就不动它们，六和五，六和五是不对的，所以。要往右移动，六和二也是不对的，所以我将二和六交换。六和七，六和七是好的，它们是有序的，七和四。
- en: those are out of order so i'll switch，the four and the seven seven and one。and
    those two are out of order as well，seven，has made its way to the sorted position。as
    well indeed so now we're making some，progress seven has bubbled its way up to。the
    top of the list stopping，just before the eight whereas the one，location。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那些是不对的，所以我将四和七、七和一交换。那两个也不对，七已经到达排序位置。确实如此，现在我们正在取得一些进展，七已经冒泡到列表的顶部，停在八之前，而一的位置。
- en: so i bet brian if we keep doing this，again and again，and again so long as the
    list remains in。part unsorted i think we'll probably get，to the finish line do
    you want to take。it from here and sort the rest，yeah sure so i just repeat the
    process。again the three and the five are okay，and the two and the five are out
    of。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我敢打赌，布赖恩，如果我们不断这样做，只要列表保持部分未排序，我想我们可能会到达终点。你想接手并排序剩下的部分吗？好的，当然，所以我再重复一遍这个过程。三和五是好的，而二和五是不对的。
- en: order so i'll swap them the five and the，six those are fine as a pair。the ***
    and the *** are out of order，those and，the six and the one those are out of。order
    as well so i'll swap those and now，the six，that i can say is in its correct。position
    and i'll repeat it again the，three and the two are out of order。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将它们交换，五和六作为一对是好的。***和***是不对的，六和一也是不对的，所以我将它们交换，现在六，我可以说是处于正确的位置，我再重复一遍，三和二是不对的。
- en: so those get switched the three and the，five are okay the five and the four
    are。out of order so those get switched，and then the five and the one need to be，switched
    as well。so there's the five in sorted position，and now i'm left with these four
    the two。and the three are okay the three and the，four are okay but the four and
    the one，are out of order。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们被交换，三和五是好的，五和四是不对的，所以它们被交换，然后五和一也需要交换。所以现在五在排序位置，而我剩下的四个，二和三是好的，三和四是好的，但四和一是不对的。
- en: so those get switched and now the four，that's in its place，the two and the three
    are okay but the。those，and now the three goes into its sorted，place and then finally
    the last pair to。consider is just the two and the one，uh those are out of order
    so i'll swap。those now the two's in place，and one is the only remaining number
    so。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们被交换，现在四在它的位置上，二和三是好的，但。那些，现在三进入了它的排序位置，然后最后一对需要考虑的就是二和一，呃，它们是不对的，所以我将它们交换。现在二在位置上，而一是唯一剩下的数字。
- en: i can say that that one's in place two，and now i think we have a sorted array。again
    nice so it felt like this was a，fundamentally different approach but we。still
    got to the same end point，so that really now invites the question。as to whether
    bubble sort was better or，worse or maybe no different。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以说那个在位置上，二，现在我认为我们有一个排序好的数组。不错，所以这感觉像是一种根本不同的方法，但我们。仍然达到了相同的终点，这确实引发了一个问题。泡排序是否更好，还是更糟，或者也许没有区别。
- en: but notice too that we've solved the，same problem fundamentally differently。the
    first time we took the more human，natural intuition of just。find the smallest
    element all right do，it again do it again do it again this。time we sort of viewed
    the problem，about，it would seem what does it mean for the。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但也要注意，我们从根本上用不同的方式解决了同样的问题。第一次我们采用了更人性化、自然的直觉，只是找到最小的元素，好的，重复一遍，重复一遍，这次我们从不同的角度看待问题。
- en: list to be unsorted and as peter noted，it's when things are out of order like。that
    very basic primitive，where something is out of order suggests，way。just fix all
    of the tiny bite-sized，loop，if we repeat that intuition it's going。to pay off
    eventually，by fixing fixing fixing fixing all of，the little problems。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表未排序，正如彼得指出的，当事情像这样失序时，非常基本的原始状态表明了一种方式。只需修复所有微小的循环，如果我们重复这个直觉，它最终会通过修复所有小问题而得到回报。
- en: until the big one itself would seem to，go away well let me return to the，visualization
    from before。re-randomize the bars short bar is small，number big bar is big number。and
    let me go ah**d and run the bubble，sort algorithm this time with this。visualization
    and you'll notice now，colored，two，again，and you'll see this time that the bars。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 直到大的一次似乎会消失，让我回到之前的可视化。重新随机化条形，短条形是小数字，大条形是大数字。让我去运行气泡排序算法，你会注意到，现在的颜色是两个，再次，你会看到这次条形。
- en: are being a little smart and they're not，going all the way to the end every
    time。just like brian illuminated the numbers，and stopped looking at the eight
    and the，place。but he and this visualization do indeed，keep returning to the beginning。doing
    another pass another pass and，another pass，so if we think ahead to the analysis
    of，consider。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它们表现得有点聪明，并且不是每次都走到最后。就像布莱恩照亮了数字，停止查看8和位置一样。但是他和这个可视化确实会返回到开始，进行另一次遍历，再一次遍历。
- en: well how many total comparisons are。![](img/c1a3243d8952685a8f2dc571e948dab7_51.png)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总共进行了多少次比较呢？![](img/c1a3243d8952685a8f2dc571e948dab7_51.png)
- en: there this time，it would seem that the very first time，through the bars or equivalently
    the。very first time through the shelf，brian in this visualization did like n。minus
    1 comparison so n minus 1，comparisons from left to right out of n。elements you
    can compare n minus 1，adjacencies，three，n minus four and minus five until just。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这次似乎是第一次，通过条形或者同样的，通过货架，布莱恩在这个可视化中进行了n-1次比较，从左到右比较n个元素的n-1个相邻元素，直到n-4和n-5。
- en: two or one remains，and at that point you're done so even，though this algorithm
    fundamentally took。same goal，it sorted the elements successfully，let's consider
    how。it was implemented in code and whether，it's actually a little faster。or a
    little slower and let's set one，final bar in fact two，bound。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当剩下两个或一个时，你就完成了。虽然这个算法在根本上达到相同的目标，但它成功地对元素进行了排序。让我们考虑它在代码中的实现，以及它是否真的快一点或慢一点，让我们设置一个最终的边界，实际上是两个。
- en: on selection sort just so that we have，something to compare this against let's。also
    consider for a moment，sort，in terms of a lower bound best case，scenario with selection。sort
    if you have n elements and you keep，looking for the next smallest element。again
    and again and again，really，our friend here's for instance the chart。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择排序中，我们有一些可以比较的内容。让我们考虑一下选择排序在最佳情况下的下限场景，如果你有n个元素，并且不断寻找下一个最小元素，实际上，这里我们的朋友就是这个图表。
- en: of where we left off in terms of omega，and notation before，linear search and
    binary search could。very well get lucky，and take just one step if you happen to，looking
    for，as we've。implemented it both with brian and with，the visualization。![](img/c1a3243d8952685a8f2dc571e948dab7_53.png)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的Omega符号中，线性搜索和二分搜索可能会非常幸运，只需一步，如果你正好在寻找，正如我们在布莱恩和可视化中实现的那样。![](img/c1a3243d8952685a8f2dc571e948dab7_53.png)
- en: unfortunately it's none so good with the，naively，every time he searched for
    a number。started the left，and went all the way to the right，started the left one
    all the way to the。right to be fair，he did ignore the numbers that were，already
    in place so we didn't keep。looking at the one he didn't keep，place，and again，touching
    those numbers multiple times。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不好，因为每次他搜索一个数字时，都是从左到右。公平地说，他确实忽略了已经到位的数字，所以我们没有继续查看那个他没有保持在的位置的数字，而是多次触碰那些数字。
- en: each so again even though you and i the，humans could look at those numbers and。be
    like obviously there's the one，obviously there's the two，obviously there's the
    three brian had to。do it much more methodically，and in fact even if that list
    of numbers。were perfectly sorted he would have，wasted just as much time in fact
    brian，if you don't mind，again。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以即使你和我，人类可以看这些数字并且觉得，显然这是一个，显然这是两个，显然这是三个，布莱恩必须以更系统的方法来处理，事实上，即使那串数字是完美排序的，他也会浪费同样多的时间，事实上，布莱恩，如果你不介意，再说一遍。
- en: brian if we start with a sorted list，this is kind of a nice，perversion to consider
    if you will。algorithmically when analyzing an，algorithm sometimes you want to
    consider。best cases and worst cases，and there would seem to be nothing，better
    than heck the list is already。sorted you got lucky there's really no，work to be
    done，the worst case is the list is maybe。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱恩，如果我们从一个已排序的列表开始，这是一种有趣的扭曲，供你考虑。从算法的角度来看，在分析算法时，有时你想考虑最佳情况和最坏情况，而似乎没有比已经排序的列表更好的情况了，你运气真好，实际上没有工作要做，最坏情况是列表可能是。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_55.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_55.png)'
- en: completely backwards and that's a huge，amount of work to be done。![](img/c1a3243d8952685a8f2dc571e948dab7_57.png)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完全相反，这是一项巨大的工作量要完成。![](img/c1a3243d8952685a8f2dc571e948dab7_57.png)
- en: unfortunately selection sort doesn't，really optimize for that lucky case。where
    they're already sorted so brian i，see you've resorted the numbers for us，from
    left to right。if we were to re-execute selection sort，as before，how would you
    go about finding the。smallest number so we decided earlier，that to find the smallest
    number i need。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，选择排序并没有真正优化这个幸运的情况，即它们已经排序。所以布莱恩，我看到你已经将数字从左到右重新排序。如果我们像之前那样重新执行选择排序，你会如何去找最小的数字。我们之前决定，要找最小的数字，我需要。
- en: to look at all the numbers from left to，right in the array，and each time check
    to see if i found。something smaller so i would start with，seen so far，but i would
    have to keep looking because。maybe there's a zero or a negative，number later on
    i need to check to see。if there's anything smaller，so i would check the two is
    bigger the，all bigger。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右查看数组中的所有数字，每次检查是否找到更小的东西，所以我会从目前为止看到的开始，但我必须继续查看，因为可能后面会有零或负数，我需要检查是否有更小的东西，所以我会检查二是否更大，所有的都更大。
- en: so it turns out i was right all along，the one was the smallest number。and it's
    already in place so now that，number is in place，and then to find the next smallest。number
    what would you have done i would，do the same thing two is the smallest，number
    i found so far。and then i would look through all the，than the two，and i would
    look at three four five six。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所以结果证明我一直是对的，那个是最小的数字，已经在正确的位置，所以现在，那个数字在正确的位置，然后要找到下一个最小的数字，你会怎么做，我会做同样的事，二是我目前找到的最小数字。然后我会查看所有数字，除了二，我会查看三、四、五、六。
- en: seven eight nothing smaller than the two，so i'd go back to the two and say okay。that
    number must now be，in its sorted position indeed and that，story would be the same
    for the three。for the four the for the five like，nowhere in selection sort，pseudo
    code or actual code is there any。sort of intelligence of，if the numbers are already
    sorted quit。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 七、八，没有比二更小的，所以我会回到二，说明那个数字现在必须在它的排序位置上，确实如此，而这个故事对于三、四、五也是一样的，选择排序的伪代码或实际代码中并没有任何智能，去判断数字是否已经排序，如果已经排序就停止。
- en: like there was no opportunity to short，circuit and abort that algorithm earlier。brian
    would literally be doing the same，work whether they're all sorted from the。get-go
    or completely，unsorted and even backwards and so，very，highly so now we're hoping
    bubble sort。indeed does so toward that end let's，take a look at some proposed
    pseudo code，for bubble sort。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像没有机会提前中断并终止这个算法，布莱恩实际上会做同样的工作，无论它们从一开始就是完全排序还是完全未排序，甚至是反向的，所以，非常，非常希望冒泡排序确实会朝着这个方向发展，让我们来看看一些提议的冒泡排序伪代码。
- en: assuming that the input is is anything，whether sorted or unsorted the pseudo。code's
    always going to look like this，to n。![](img/c1a3243d8952685a8f2dc571e948dab7_59.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设输入可以是任何内容，无论是已排序还是未排序，伪代码总是会像这样，直到n。![](img/c1a3243d8952685a8f2dc571e948dab7_59.png)
- en: minus 1，goes from the first element to the last，so 0 to n minus 2，goes from
    the first element to the。second to last，why am i doing that we'll see in just
    a，is if the i，order，clever。if you think about all of these numbers，as being in
    an array or behind doors。if you iterate from zero to n minus two，that's like going
    from the first door to。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个元素到最后一个元素，范围是0到n减2，表示从第一个元素到倒数第二个，为什么我这样做呢？我们马上就会看到，如果i的顺序，聪明。如果你考虑所有这些数字都在一个数组中或在门后面，如果你从零迭代到n减二，那就像从第一扇门到。
- en: the second to last door but that's good，because my condition is checking door
    i，and i plus one。so if i start at the beginning here and，i only iterate，up to
    this door that's a good thing。because when i compare door，to compare door，is compare，this
    door i against door i plus one。which doesn't even exist and indeed，that's going
    to be an error that。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二扇门，但这很好，因为我的条件是检查门i和i加一。因此，如果我从这里的开始处开始，并且我只迭代到这扇门，那是好事。因为当我比较门时，门的比较是将门i与门i加一进行比较，而这并不存在，确实，这将导致一个错误。
- en: probably all of you make at some point，touching，memory that is going one or
    more spaces。too far in the array，even though you didn't allocate memory，possibility。so
    this would seem to be a pretty smart，actually，as performant as might be ideal。with
    bubble sort suppose the list，you uh，uh sort and restart numbers too many。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你们所有人在某个时候都会遇到，涉及到一个或多个空间的内存问题。尽管没有分配内存，但数组中的某个位置可能会超出范围。所以这看起来似乎很聪明，实际上表现得可能与理想的状态一样好。以冒泡排序为例，假设这个列表，你，呃，排序并重启数字太多了。
- en: times do you mind giving us a sorted，list one more time real quick。in a moment
    i want to see if we consider，that same sorted list as before this，time with bubble
    sort。![](img/c1a3243d8952685a8f2dc571e948dab7_61.png)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你介意再给我们一次排序的列表吗？我想看看我们是否考虑到，和之前相同的已排序列表，这次使用冒泡排序。![](img/c1a3243d8952685a8f2dc571e948dab7_61.png)
- en: can we do fundamentally better i have，this code saying repeat until。sorted so
    how might this change so brian，you've got the sorted numbers again。this should
    be a good case but selection，sort did not benefit from this。input even though
    we could have gotten，lucky bubble sort what would your，thought process be here。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否从根本上做得更好？我有这段代码，说的是重复直到。排序，所以这可能会有什么变化？布莱恩，你又得到了已排序的数字。这应该是一个好例子，但选择排序并没有从这个输入中受益，尽管我们可能会幸运地使用冒泡排序，你的思维过程会是怎样的？
- en: so the thought process for bubble sort，was to go through each of the pairs one。at
    a time and see if i need to make a，swap for that particular pair。so i'd look at
    the one and the two if，them，the two and the three are okay i don't。need to make
    a swap there the three and，are okay，same with the five and the six and the，eight。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以冒泡排序的思维过程，是一次检查每一对，看是否需要为那一对做交换。所以我会看一下一和二，如果二和三是可以的，我就不需要在这里交换，三和四也可以，同样五和六，以及八。
- en: so i made it with my way through all the，any swap because，every pair that i
    looked at they were。each other，indeed and so it would be foolish and so，obvious
    this time if brian。literally retraced those steps and did，it again with n minus
    one elements and。then did it again with n minus two，elements i mean if he didn't
    do。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我完成了对所有，任何交换的遍历，因为每一对我查看的都是彼此，确实如此，因此这次如果布莱恩真的回顾了这些步骤，并在n减1个元素中再次执行，然后在n减2个元素中再执行，那就太愚蠢了。
- en: any work any swaps the first pass he's，literally wasting his own time by even。doing
    another pass or another pass and，code，this repeat until sorted even though it。doesn't
    translate perfectly into a for，loop or a while loop in c，it kind of says intuitively
    what he。should do repeat until sorted brian has，already identified the fact。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何工作、任何交换，在第一次遍历中，他实际上是在浪费自己的时间，甚至再做一次遍历或另一遍，代码，这个重复直到排序，尽管它并不完全可以转换成C语言中的for循环或while循环，但直观上它表达了他应该做什么：重复直到排序，布莱恩已经识别出这个事实。
- en: by nature of him not having made any，swaps that this list is sorted。therefore
    he can just stop and this loop，again，we can map this to c light code a little。more
    explicitly，we can by default say do the following n，minus 1 times。because among
    n elements you can look at，n minus 1 total pairs，but notice。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他没有进行任何交换，这个列表就是已排序的。因此，他可以停止这个循环，我们可以将其更明确地映射到C语言代码中，我们可以默认说执行以下操作n减1次。因为在n个元素中，你可以查看n减1总对，但请注意。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_63.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_63.png)'
- en: i can add an additional line of code，here which might say。![](img/c1a3243d8952685a8f2dc571e948dab7_65.png)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在这里添加一行额外的代码，可能会说。![](img/c1a3243d8952685a8f2dc571e948dab7_65.png)
- en: this i can say an additional line of，code whereby，if no swaps quit。from the
    algorithm altogether so so long，as brian is keeping track of how many。swaps he
    made or didn't make，through one pass as with a variable，called counter or whatever。he
    can simply abort this algorithm early，and certainly then，save us some time so
    with that said。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这我可以说是增加一行代码，如果没有交换则完全退出算法，只要布赖恩跟踪他在一次遍历中做了多少交换或者没有做多少交换，使用一个叫做计数器的变量，他可以简单地提前中止这个算法，这样确实可以为我们节省一些时间。
- en: let's consider for just a moment what，the running time of bubble sort might
    be。in terms of an upper bound in the worst，case if you will，well in the case of
    bubble sort notice。something，doing something，n minus 1 time so again repeat n
    minus 1，times literally says。do the following n minus 1 times the for，loop here
    which is just a different way。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时考虑一下冒泡排序的运行时间。在最坏情况下的上界，如果你注意到冒泡排序，做某些事情，n-1次，所以再次重复n-1次，字面上说。执行以下操作n-1次的for循环，这只是一种不同的方式。
- en: in pseudocode of expressing a similar，idea but giving us a variable this time。for
    i from 0 to n minus 1 n minus 2，is a total number of n minus 1。comparisons so
    this is an n minus 1，thing inside the repeat and an n minus 1。outside the repeat
    so i think what that，gives me is n minus 1 things。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪代码中表达类似的思想，但这次给我们一个变量。对于i从0到n-1，n-2，总共是n-1次比较，因此这是一个n-1的事情，出现在repeat内部和repeat外部。所以我认为这给我的是n-1个事情。
- en: times n minus 1 times so now if i just，kind of foil this sort of in high school。or
    middle school math，n squ*red minus 1n minus 1n plus 1。we，can combine like terms
    n。squ*red minus 2n plus 1。but per our，discussion earlier，this is really getting
    into the weeds。who cares about the 2n or the 1，the dominant factor as n gets large
    is，definitely going to be the n。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: n-1次乘以n，所以现在如果我将这个稍微整理一下，像高中或初中的数学，n² - 1n - 1n + 1。我们可以合并同类项，得出n² - 2n + 1。但根据我们之前的讨论，这真的有些复杂。谁在乎2n或1，当n变大时，主导因素肯定是n。
- en: squ*red so it would seem that bubble，and the formulas，is going to have an upper
    bound of n。squ*red steps，so in that sense it is equivalent to，selection sort it
    is no better，fundamentally。it's what we would say asymptotically，large，this formula
    is for all intents and，sort。formula even though they differ slightly，in in terms
    of their lower order terms。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序和公式似乎会有n²步的上界，所以在这个意义上，它与选择排序是等价的，从根本上来说并没有更好。我们可以说从渐近的角度来看，这个公式在所有意图和目的上是相同的，尽管它们在低阶项上略有不同。
- en: for all intents and purposes ah they're，on the order of n squ*red both。but if
    we consider a lower bound perhaps，even though bubble sort has the same。upper bound
    running time，if we consider a lower bound as with，this smarter code。where brian
    might actually have the，wherewithal to notice wait a minute i，didn't do any swaps。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就所有意图和目的而言，它们的复杂度大约是n²，但如果我们考虑一个下界，尽管冒泡排序有相同的上界运行时间，如果我们考虑一个下界，使用这个更智能的代码，布赖恩可能会注意到等一下，我没有进行任何交换。
- en: i'm just going to exit out of this，looping prema，early not even prematurely
    but early。because it would be fruitless to keep，doing more and more work，we can
    then whittle down this running。time i think，not quite as good as omega of one
    which，was constant time。like you cannot conclude definitively，that an array is
    sorted。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是打算退出这个循环，提前结束，而不是过早结束。因为继续做更多工作是没有意义的，我们可以逐步减少这个运行时间。我认为，这并不如常数时间的Ω(1)那么好。就像你不能确定一个数组是已排序的。
- en: unless you minimally look at all of the，elements once so constant time is。completely
    naive and unrealistic，you can't look at one element or two or。three and say yes
    this is sorted you've，elements，at least once so this would seem to。suggest that
    the omega notation for that，is the lower bound on bubble sorts，running time。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你至少看过所有元素一次，所以常数时间是完全天真和不现实的，你不能只看一个元素、两个或三个就说是已排序的，必须至少看过元素一次。因此，这似乎暗示了冒泡排序运行时间的Ω符号是它的下界。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_67.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_67.png)'
- en: if we're clever and don't retrace our，steps unnecessarily is in。omega of n or
    technically it's n minus，one steps right because if you've got n。elements and
    you compare，these two these two these two these two。that's n minus one total comparisons
    but，who cares about the minus one it's on，the order of。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们聪明一点，不要不必要地重走我们之前的步骤，这个复杂度是Ω(n)，或者从技术上讲是n-1步，因为如果你有n个元素，比较这两个、这两个、这两个、这两个，总共是n-1次比较。但谁在乎减去的1呢？它是n的阶数。
- en: n or omega of n notation here，so to recap selection sort selects the，and again。unfortunately
    based on how it's，code，it's in big o of n squ*red but it's also，always going to。take
    the same amount of time，asymptotically that is as n gets large，better。it would
    seem in terms of the upper，bound it's going to take as many as n。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 n 或 omega 的 n 表示法，所以总结一下选择排序选择了，再一次。不幸的是，根据它的代码，它是大 O 的 n 平方，但它总是会在渐近意义上花费相同的时间，随着
    n 的增大，看起来更好。在上界方面，它将花费多达 n 的时间。
- en: squ*red steps too but it's at least，marginally better when it comes to using，something
    like uh。an input that's already sorted it can，self uh short circuit，squ*red is
    bad。like n squ*red is really going to add up，quickly if you've got。n squ*red and
    n is a million or n is a，billion i mean my god that's a lot of。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 平方步骤太多，但至少在使用像已经排序的输入时，它可以自我短路。平方是不好的，像 n 平方会迅速累积，如果你有 n 平方而 n 是一百万或者 n 是十亿，天哪，那可真是一大堆零。
- en: zeros that's a lot of steps，in the total running time of your，algorithm can
    we do better。can we do better and it turns out we can，and we'll consider one final
    algorithm。today that does fundamentally better，just like in week zero，we sort
    of latched on to binary search。and again today，is just fundamentally better than
    linear，speak its。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的算法的总运行时间中，有很多步骤，我们能做得更好吗？我们能做得更好吗？结果证明我们可以，今天我们将考虑一个最后的算法，它从根本上做得更好，就像在零周时，我们稍微接触到二分查找一样，而今天，显然比线性查找要好得多。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_69.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_69.png)'
- en: different i，think we can do fundamentally better，than bubble sort and selection
    sort and，sort。might be the sort of thing that i was，using in grad school just
    to rip up the。code quickly and then go to sleep，it's not going to work well for
    very。large data sets and frankly it wouldn't，have worked well if i didn't want
    to。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们可以比冒泡排序和选择排序做得根本更好，排序可能是我在研究生院用来快速编写代码然后去睡觉的东西，但对于非常大的数据集，它不会工作，坦白说，如果我不想的话，它也不会工作。
- en: just sleep through the problem，rather we want to do things as，efficiently as
    we can from the get-go。and let me propose that we leverage a，technique，and this
    is a technique that you can use。in almost any programming language，recursion，quite
    simply is the ability for a，function。to call itself up until now we have not，seen
    any examples of this，we've seen functions calling other。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只是睡过这个问题，相反，我们希望从一开始就尽可能高效地完成事情。让我提议我们利用一种技术，这是一种你几乎可以在任何编程语言中使用的技术，递归，简单来说就是一个函数调用自己。到目前为止，我们还没有看到任何示例，我们看到的是函数调用其他函数。
- en: functions main，keeps calling printf main has started to，call sterling main。called
    stir comp compare earlier today，but we've never seen main called main。and people
    don't do that so that's not，going to solve a problem。but we can implement our
    own functions。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数主，不断调用 printf 主已经开始调用 sterling 主。早些时候主调用了 stir comp compare，但我们从未见过主调用主。人们不会那样做，所以这并不能解决问题。但我们可以实现自己的函数。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_71.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_71.png)'
- en: and have our own functions，call themselves now this would seem to。be a bad idea
    in principle if a function，calls itself my god where does it end。it would seem
    to just do something，forever and then something bad probably。![](img/c1a3243d8952685a8f2dc571e948dab7_73.png)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有我们的函数可以调用自己，这在原则上看起来似乎是个坏主意。如果一个函数调用自己，天哪，这会到哪里结束呢？似乎会永远做某件事，然后可能会出问题。![](img/c1a3243d8952685a8f2dc571e948dab7_73.png)
- en: happens and it could and that's the，danger of using recursion you can screw，it
    up easily。but it's also a very powerful technique，because it allows us to think
    about。potential solutions to problems in a，very interesting and dare say。elegant
    way so we're not only going to，be able to achieve correctness but also。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会发生，这就是使用递归的危险，你很容易搞砸。但是这也是一种非常强大的技术，因为它让我们以一种非常有趣的，敢说优雅的方式思考潜在的问题解决方案。所以我们不仅能够实现正确性，而且还。
- en: better design because of better，efficiency it would seem here。so let me propose
    this recall this code，from week zero which was the pseudo code。for finding someone
    in a phone book，and recall that among the features of，this pseudocode。were these
    lines here go back to line，three and we describe those in week zero。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的设计因为更好的效率，看起来在这里是这样。所以让我提议回顾一下这段代码，来自零周的伪代码。用于在电话簿中查找某人的伪代码的特点之一，就是这些行，这里回到第三行，我们在零周时描述过。
- en: as being representative of loops uh a，happen again，and again but you know what
    there's a，code。to use a technique known as recursion，call，iterative it is purely
    loop-based it。tells me literally go back to this line，go back to this line go
    back to this。line there's no calling yourself，but what if i changed week 0 pseudo
    code。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为循环的代表，发生了一次又一次。但你知道吗，有一种技术叫做递归，称为迭代，它完全是基于循环。它字面意思是让我回到这一行，回到这一行，回到这一行，没有自我调用。但如果我改变第零周的伪代码呢？
- en: to be a little more like this，let me go ah**d and get rid of not just，that one
    line。but two lines in both of those，conditions，and let me quite simply say instead
    of。open to the middle of the left half of，the book and then go back。to line three
    or open to the middle of，the right half of the book and then go，back to line three。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更像这样，让我去掉的不仅仅是那一行，而是这两行条件。让我简单地说，而不是打开书的左半边中间，然后返回到第三行，或打开书的右半边中间，然后返回到第三行。
- en: why don't i just more elegantly say，search left half of book search right，half
    of book。now immediately i can shorten the code a，little bit，but i claim that by
    just saying search，of book i。claim that this is enough information to，implement
    the very same algorithm but，it's not using a loop。per se it's going to induce
    me the human，and again，but there's other ways to do things。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我不更优雅地说，搜索书的左半边，搜索书的右半边。现在我可以立刻缩短一些代码，我声称通过只说搜索书，这就是足够的信息来实现同样的算法，但它并不是使用循环。人类会再次参与，但还有其他的方法来做事情。
- en: again and again not by way of a for loop，or a while loop or a do while loop。or
    a repeat block or a forever block you，can actually use recursion。and recursion
    again is this technique，where a function can call itself。and if we consider after
    all the pseudo，code we are looking at is the pseudo，code for searching。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，而不是通过 for 循环、while 循环或 do while 循环。或者重复块或永久块，你实际上可以使用递归。递归是这种技术，函数可以调用自身。如果我们考虑一下，毕竟我们正在看的伪代码是搜索的伪代码。
- en: and on lines seven and nine now i am，literally saying，search left half of book
    and search。right half of book，this is already even in pseudocode form，an example
    of recursion。here i have in 11 lines of code an，algorithm or a function，and nine。i
    have a lines of code that literally，specifically，search half of the phone book
    and that's。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七行和第九行，我现在字面上说，搜索书的左半边和搜索右半边。这甚至在伪代码形式中，已经是递归的一个例子。在这里，我用11行代码实现了一个算法或函数，九行代码字面上具体搜索电话簿的一半。
- en: where recursion really works its magic，it would be foolish and incorrect and。completely
    counterproductive，to just have a function call itself with。the same input with
    the same input with，the same input because you'd have to be。kind of crazy to expect
    different output，if the input is constantly the same but。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 递归真正发挥作用的地方，简单直接调用函数自身，输入相同是愚蠢且错误的。因为如果输入始终相同，期待不同的输出简直是疯狂。
- en: that's not what we did in week zero and，that's not what we're doing now。if you
    use the same function or，equivalently algorithm，smaller，and smaller it's probably
    okay that a。function is calling itself，code in there，that very intelligently says
    if you're，pages。quit you need to have a so-called base，case you need some line
    of code。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们在第零周做的，也不是我们现在正在做的。如果你使用相同的函数或等效算法，越来越小，函数调用自身可能是可以的，代码中非常智能地说如果你在页面上。你需要一个所谓的基本情况，需要一些代码。
- en: that's going to notice wait a minute，there's no more problem to be solved。quit
    now and so how can we map this to，actual code，well let's consider something very。familiar
    from week one recall when you，reconstructed one of mario's pyramids。looked a little
    something，like this and let's consider that this，is a pyramid of blocks of bricks。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那个会注意到，等等，这里没有更多的问题需要解决。现在退出，那么我们怎么将这映射到实际的代码呢？好吧，让我们考虑一些非常熟悉的东西。回想一下你重建马里奥金字塔时的样子。看起来有点像这样，让我们考虑这是一个砖块金字塔。
- en: that's of height four y4 well there's uh，one then two then three。then four bricks
    from top to bottom so，the total height here is four。but let me ask the question
    a little，how do you go，about printing a pyramid of height four。well it turns out
    that this simple mario，rid of the，unnecessary background is a recursive。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这高度是四的，y4，那么从上到下有一砖、两砖、三砖、四砖，所以这里的总高度是四。但让我问一个问题，你怎么去打印高度为四的金字塔？结果证明，这个简单的马里奥去掉了不必要的背景是递归的。
- en: structure of some sort it's a recursive，physical structure why，well notice that
    this structure this。brick this pyramid，is kind of defined in terms of itself，why
    well how do you make a pyramid of。height four，i would argue a little obnoxiously
    a，little circularly well you create a。pyramid of height three，and then you add
    an additional row of，bricks all right。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种递归的物理结构，为什么呢？好吧，注意这个结构，这个砖块，这个金字塔在某种程度上是用自身来定义的，为什么？好吧，如何制作一个高度为四的金字塔，我会有点恼人地、循环地争论，你创建一个高度为三的金字塔，然后再加上一行砖块，好的。
- en: well let's continue that logic all right，fine how do you build。a pyramid of
    height three well you sort，of smile and say well you build a，pyramid of height
    two。and then you add one more layer all，right fine how do you build a pyramid
    of，height two well。you build a pyramid of height one and，then you add one more
    layer，well how do you build a pyramid of。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们继续这个逻辑，好吧，如何构建一个高度为三的金字塔？好吧，你微笑着说，你需要建造一个高度为二的金字塔。然后再加上一层，好吧，如何构建一个高度为二的金字塔？你建造一个高度为一的金字塔，然后再加上一层，如何构建一个高度为。
- en: height one well you just put the stupid，like brick down you have a base case。where
    you sort of state the obvious and，just do something，once you hard code the logic
    but notice。what's kind of，mind-bending or kind of obnoxious in a，human interaction。like
    you're just defining the answer in，thing，but that's okay because the pyramid，smaller。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 高度为一，你只需把这个愚蠢的砖块放下，你有一个基本情况，在这里你有点陈述了显而易见的事情，只需做一次，你硬编码逻辑，但请注意，什么是有点让人费解或恼人的在人际互动中。就像你只是用事物定义答案，但没关系，因为金字塔更小。
- en: until i can handle that one special case，and so we can do this just for fun
    with，instance。if i want to build a pyramid of height，four how do i do it well
    i can build a。pyramid of height three，all right let me go ah**d and build a，pyramid
    of height three uh。how do i build a pyramid of height three，all right well i build
    a pyramid of，okay。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我能处理那个特殊的情况，所以我们可以为乐趣做这个实例。如果我想建造一个高度为四的金字塔，我该怎么做？好吧，我可以建造一个高度为三的金字塔，好吧，让我去啊**d**建造一个高度为三的金字塔，呃，我该如何建造一个高度为三的金字塔，好吧，我建造一个金字塔，好的。
- en: how do i build a pyramid of height two，height，one how do i do that well you
    just put。the brick down and so here's where，things kind of bottom out and it's
    no，longer a cyclical argument。you eventually just do some actual work，but in my
    mind i have to remember。all of the instructions you just gave me，or i gave myself，i
    had to build a pyramid of height four。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我该如何构建一个高度为二的金字塔，高度为一，我该怎么做？好吧，你只需放下砖块，所以这里的事情有点停滞不前，不再是循环的论证。你最终只是做一些实际的工作，但在我心里，我必须记住你刚刚给我的所有指示，或者我给自己的指示，我必须建立一个高度为四的金字塔。
- en: no three nope two nope one，now i'm actually doing that so here's，the pyramid
    of height one。how do i now build the pyramid of height，two well rewind in the
    story。to build a pyramid of height two you，build a pyramid of height one。and then
    you add one more layer so i，think to add one more layer。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不，三，不，二，不，一，现在我真的在做这个，所以这是高度为一的金字塔。我现在该如何构建高度为二的金字塔？好吧，回顾一下故事。要构建一个高度为二的金字塔，你需要建造一个高度为一的金字塔。然后再加一层，所以我想再加一层。
- en: i essentially need to do this all right，now i have a pyramid of height two。but
    wait a minute the story began with，how do i build a pyramid of height three。well
    you take a pyramid of pipe two，which i have here and you add an。additional layer
    so i've gotta build，this additional layer，i'm gonna go ah**d and give myself the。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我基本上需要做到这一切，现在我有一个高度为二的金字塔。但是等一下，故事开始于，我该如何建立一个高度为三的金字塔。好吧，你需要一个高度为二的金字塔，我这里有一个，然后再加上一层额外的层，所以我得构建这一额外的层，我要去啊**d**给自己一个结构。
- en: layer the layer，the layer and then i'm gonna put the，it，and voila it's a pyramid
    of height 3 now。well how did i get here well let me keep，rewinding in the story
    the very first。question i asked myself was how do you，build a pyramid of height
    4。well the answer was build a pyramid of，height 3 great that's done。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 层，层，然后我将把它放上去，瞧，这就是高度为三的金字塔。好吧，我是怎么到这里的？让我继续回顾这个故事，我问自己的第一个问题是如何建造一个高度为四的金字塔。好吧，答案是建造一个高度为三的金字塔，太好了，完成了。
- en: then add one additional layer and if i，had more hands i could do this a little。more
    elegantly but let me go ah**d and，just lay this out，here's the new level of height
    three。and now i'm going to go of with four，now i'm gonna go and put the pyramid
    of。height three on top of it，until voila i have this form here，cyclical。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再加上一层额外的层，如果我有更多的手，我可以做得更优雅，但让我去啊**d**，把这个铺出来，这就是高度为三的新层。现在我要去做四，现在我要把高度为三的金字塔放在上面，直到瞧，我有这个形式在这里，循环的。
- en: in that every time i ask myself to build，a pyramid of a certain height。i kind
    of punted and said no build a，pyramid of this height no build a。pyramid of this
    height no build a，pyramid of this height，but the magic of that algorithm。little
    more work，build a layer do a little more work，building of。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我要求自己构建一定高度的金字塔时，我总是推迟说，不，构建这个高度的金字塔，不，构建这个高度的金字塔，不，构建这个高度的金字塔，但这个算法的魔力是多做一点工作，构建一层，再多做一点工作。
- en: layer after layer after layer that the，pyramid itself the end goal。actually
    emerges so you could implement，the same thing with a for loop or a。while loop
    and frankly you did it was a，slightly different shape。for problem set one but
    you did the same，thing using a loop and you kind of had。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一层又一层，金字塔本身的最终目标实际上出现了，因此你可以用 for 循环或 while 循环来实现同样的东西，坦率地说，你确实这样做了，只是形状稍有不同，但你用循环做了同样的事情，你有点。
- en: to do it that way at least，as we prescribed it because with printf，you have
    to print。from the top of the screen to the bottom，yet，to sort of print a layer
    and then go。back on top so i'm kind of taking some，real world liberties here by
    lifting。these things up and moving them around，you would have to be a little。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们规定的方式进行，因为使用 printf，你必须从屏幕顶部打印到底部，然而，得先打印一层，然后再回到顶部，所以我在这里有点对现实世界的自由裁量，抬起这些东西并移动它们，你必须有一点。
- en: more clever in code but the idea is the，same and so even physical objects like，this
    can have some。recursive definition to them and so we，present this sort of goofy
    example。because this notion of recursion is sort，of a fundamental programming
    technique。that you can leverage now to solve，way，and i think for this we need
    one final。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中更聪明，但想法是相同的，因此即使是像这样的物理对象，也可以有一些递归定义，因此我们展示了这个有点搞笑的例子，因为递归的概念是一种基本的编程技术，你可以利用它来解决问题，我认为为了这个我们需要最后一个。
- en: visualization of merge sort with both，brian's help and the computers。and merge
    sort is going to be an，algorithm whose pseudocode is dare say。the simplest we've
    seen thus far but，deceptively simple，the pseudocode for merge sort quite。simply
    is this，sort the left half of numbers sort the，right half of numbers。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在布莱恩的帮助和计算机的帮助下可视化归并排序，归并排序将是一个算法，它的伪代码可以说是到目前为止最简单的，但却具有欺骗性，归并排序的伪代码非常简单，就是对左半部分数字进行排序，对右半部分数字进行排序。
- en: merge the sorted halves and notice even，unfair，like here's an algorithm for
    sorting and。yet i'm literally using the word sort，in my algorithm for sorting
    it's like in。english if you're asked to define a word，and you literally use the
    word in the。definition like that rarely flies，because you're just sort of making
    a。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 合并已排序的两部分，注意即使不公平，这里有一个排序算法，然而我在我的排序算法中字面上使用了“排序”这个词，就像在英语中，如果你被要求定义一个词，而你字面上在定义中使用这个词，这种情况很少成立，因为你只是制造了一个。
- en: circular argument but in code it's okay，that's doing something a little。differently
    and so long as the problem，indeed it is，this pseudo code is not saying sort the。numbers
    sort the numbers，sort the numbers no it's dividing the，problem in half。and then
    solving the other half as well，iteration，now i will disclaim we're going to need。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 循环论证，但在代码中没关系，这样做有点不同，只要问题确实是，这个伪代码并不是在说排序数字，而是将问题分成两半，然后解决另一半，迭代，现在我会免责声明，我们将需要。
- en: that so-called base case again，i'm going to have to do something stupid，but
    necessary and say。if there's only one number quit it's，sorted that's the so-called。base
    case the recursive case is where，the function calls itself。but this is indeed
    our third and final，sorting algorithm called merge sort。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的基本情况，再次，我需要做一些愚蠢但必要的事情，假设只有一个数字，就可以停止，它是排序的，这就是所谓的基本情况，递归情况是函数调用自身。但这确实是我们的第三个也是最终的排序算法，称为归并排序。
- en: and we'll focus here really on the，juiciest pieces，one this notion of merging
    so in fact。brian can we cut over to you，just so we can define before we look at，the
    merge sort algorithm itself。what do we even mean when we say merge，sorted have
    so for instance brian has on，his shelf here。two arrays of size four in the first，array
    on the left are four，right side，four numbers two。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里真正关注的是最精华的部分，一个就是合并的概念，因此布莱恩，我们能不能转到你这边，这样我们可以在查看归并排序算法本身之前先定义一下，当我们说合并已排序的部分时，我们究竟是什么意思？例如，布莱恩的架子上有两个大小为四的数组，左边的第一个数组有四个右边的四个数字。
- en: is sorted，and the right is sorted but now brian i，would like you to merge。these
    sorted halves tell us what that，means sure so if i have a。left half that's sorted
    from smallest to，largest and have a right half that's。also sorted from smallest
    to largest，i want to merge them into a new list。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 左边是已排序的，右边也是已排序的，但现在布赖恩，我希望你合并这些已排序的部分，告诉我们这是什么意思。当然，如果我有一个从最小到最大排序的左半部分，还有一个同样从最小到最大排序的右半部分，我想将它们合并成一个新的列表。
- en: that has all of the same numbers，also from smallest to largest and i，guess where
    i could start here。is that the smallest number of the，combined array，needs to
    begin with either the smallest。number of the left half，or the smallest number
    of the right half。because on the left the smallest number，is the three，and on
    the right the smallest number is。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合数组的所有数字也都是从最小到最大，我想我可以从这里开始。最小的数字需要从左半部分的最小数字或右半部分的最小数字开始。因为在左边，最小的数字是三，而在右边，最小的数字是。
- en: the one one of those two has got to be，the smallest number for the entire array。and
    between the three and the one the，one is smaller so i would take that one。and
    that's going to be the first number，the smallest number，of the merged two halves
    and then i。guess i would repeat the process again，the three，on on the right side
    the smallest number。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个数字中，必须有一个是整个数组的最小数字。在三和一之间，一更小，所以我会取那一个。这将是合并两个半部分的第一个数字，最小的数字，然后我想我会再次重复这个过程，右边的三是最小的数字。
- en: is the two and between the three and the，two the two is smaller。so i would take
    the two and that's going，to be the next number，so i'm slowly building up this
    sorted。array that is the result of combining，the left，to the four on the right
    between the。three and the four the three is smaller，so we'll take the three and
    we'll put，that one into position。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是二，在三和二之间，二更小。所以我会取二，这将是下一个数字。我正在慢慢构建这个已排序的数组，这是将左边与右边的四结合的结果。在三和四之间，三更小，所以我们取三，并将其放入位置。
- en: now i'm comparing the five on the left，with the four on the right。between the
    five and the four the four，is smaller so that one goes into，position。and now i'm
    comparing the five on the，left with the seven on the right。the five is smaller
    so the five goes，next next i'm comparing，the six on the left with the seven on。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我在将左边的五与右边的四进行比较。在五和四之间，四更小，所以它进入了位置。接下来，我将左边的五与右边的七进行比较。五更小，所以五放在了下一个位置。接下来我在比较左边的六与右边的七。
- en: the right the six is still smaller，so that one is going to go next now i'm。comparing
    the eight and the seven the，only two numbers left，the seven is the smaller between
    the two。so i'll take the seven，and put that into place and now i'm only，put。into
    the merging of the two halves and，that's the number eight。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的六仍然更小，所以这个数字将下一个。我现在在比较八和七，只有两个数字剩下，七在这两者中更小。因此，我会取七并放入位置，现在我只需放入两个半部分的合并，这就是数字八。
- en: so that number is going to take up the，final position and now i've taken these。two
    halves each of which was originally，sorted and made one complete array that。has
    all of those numbers in sorted order，indeed and consider what we've done，physically。kind
    of defined a helper function our，own custom function if you will，mean to。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个数字将占据最后的位置，现在我已经取了这两个半部分，每个部分最初都是已排序的，组成一个完整的数组，所有这些数字都按顺序排列。确实，考虑一下我们所做的，实际上定义了一个助手函数，我们自己的自定义函数，意味着。
- en: merge two arrays specifically merge to，sorted arrays because why well that's
    a。building block that i think we're going，to want in this merge sort algorithm
    so。just like in actual c code you might，have defined a function。that does some
    small task so have we now，verbally and physically define the，notion of merging。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个数组，特别是合并两个已排序的数组，因为为什么呢？这是一个我认为我们在这个归并排序算法中想要的构建块。因此，就像在实际的C代码中，你可能会定义一个执行一些小任务的函数，我们现在也以口头和实际的方式定义了合并的概念。
- en: the mind bending part here is that sort，left half of numbers and sort right。half
    of numbers is kind of already，implemented there's nothing more for，brian or me
    to define。all that remains is for us to execute，this algorithm focusing especially
    on。these three highlighted lines of code，and let me disclaim that of the。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里令人费解的部分是，排序的左半部分和排序的右半部分已经被实现，没有更多的工作要让布赖恩或我来定义。剩下的就是我们执行这个算法，特别关注这三行高亮的代码，并让我声明的是。
- en: algorithms we've looked at thus far，odds are this will be the one that。doesn't
    really sink in as quickly as the，others even if the others might have。taken you
    a moment a day a week，to settle in or maybe you're still not。quite there yet that's
    fine merge sort，is a bit of a mind-bending one because。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看的算法，可能这个是最不容易快速理解的。即使其他算法可能让你花了一天、一周去消化，或者也许你还没有完全掌握，这都没关系。归并排序是个让人头疼的，因为它似乎是魔法般的工作，但实际上它更智能地工作。你将开始获得各种原始数据，以便我们最终能解决问题。
- en: it seems to sort of work magically，but it really just works more。intelligently
    and you'll begin to get，kinds of primitives，so that we can ultimately indeed solve。kindly，put
    the numbers again on the top shelf，and he has put them into their original。unsorted
    order just like for selection，sort and bubble sore，and brian i'd like to propose
    now that。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 乖乖地把数字放回最上面的架子上，他把它们放回原来的无序状态，就像选择排序和冒泡排序一样。布赖恩，我现在想提议的是……
- en: we execute this merge sort algorithm and，if you don't mind all recite allowed
    at。first the few steps so here is one array，of size 8 with unsorted numbers the
    goal，sort。and recall that merge sort essentially，is just three steps，sort left
    half sort right half merge。sorted halves so brian，looking at those numbers there
    could you，numbers。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行这个归并排序算法，如果你不介意，我先复述一下最初的几个步骤。这是一个大小为8的无序数组，目标是排序。请记住，归并排序本质上就是三个步骤：排序左半部分、排序右半部分、合并已排序的两半。布赖恩，看着那些数字，你能……
- en: all right so there are eight numbers the，left half would be these four numbers
    so，i will sort those。except i'm not really sure how do i now，sort these four numbers，yeah
    so granted we've seen selection。to regress，to those older slower algorithms brian
    i，can kind of be a little clever here。well i'm giving you a sorting algorithm，so
    now you effectively have a smaller。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以这里有8个数字，左半部分是这四个数字，所以我将对这些进行排序。只是我现在不太确定如何排序这四个数字。是的，考虑到我们已经看过选择排序，回到那些较旧的、较慢的算法，布赖恩，我可以在这里稍微聪明一点。好吧，我给你一个排序算法，所以现在你实际上有一个更小的。
- en: problem an array of size 4，and i'm pretty sure we can use the same。algorithm
    merge sort by sorting left，the sorting，sorted halves so could you go ah**d and。sort
    the left half of these four numbers，all right so i have these four numbers i。want
    to sort the left half that's，these two numbers so now i need to，right now。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是一个大小为4的数组，我很确定我们可以使用相同的**算法**归并排序，通过对左半部分进行排序，接着对已排序的两半进行排序。那么你能帮我**排序**这四个数字的左半部分吗？好的，我有这四个数字，我想排序左半部分，也就是这两个数字，现在我需要做的就是这样。
- en: us with human intuition might obviously，know what we have to do here but again。let's
    apply the algorithm sort left half，sort right half merge sorted halves。brian could
    you sort the right half of，this array of size two。so i got the array of two so
    i'll first，sort the left half of the array of two，which is the six。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们凭借人类的直觉，显然知道我们该怎么做，但再说一遍。让我们应用算法，排序左半部分、排序右半部分、合并已排序的两半。布赖恩，你能排序这个大小为2的数组的右半部分吗？我得到的数组是2，所以我先对这个大小为2的数组的左半部分进行排序，也就是6。
- en: and this is where the base case in white，on the slide comes into play。if only
    one number quit so brian i can，let you off the hook，that list of size one with
    the number。six is sorted，so that's step one of three done brian，could you sort
    the right half of that。array of size two，the right half is the number three，is
    done，good so think about where we are in the。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是幻灯片中基础案例发挥作用的地方。如果只有一个数字，那就停了。布赖恩，我可以让你松一口气，那个大小为1的列表里有个数字6，已经排好了，所以这是三步中的第一步完成了。布赖恩，你能排序那个大小为2的数组的右半部分吗？右半部分是数字3，已经完成，好的。想想我们在故事中的位置。
- en: story we've sorted the left half，and we've sorted the right half even，have done。any
    useful work yet but now the magic，happens brian，you now have two arrays of size
    one。could you merge them together all right，so i'm going to merge these two together。between
    the six and the three the three，first，and then i'll take the six and that one，of
    size。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经排序了左半部分，排序了右半部分，甚至还没有做任何有用的工作，但现在魔法发生了，布赖恩，你现在有两个大小为1的数组。你能把它们合并在一起吗？好的，我要将这两个合并在一起。先把3放进去，然后把6放进去。
- en: two that is now done all right and this，is where you now need to start，brain
    as。is the things pile up how did we get to，this point we started with a list of，size
    eight。we then looked at the left half which，was an array of size four。we then
    looked at the left half of that，which was an array of size two。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数字现在已经完成了，好的，现在是时候开始动脑筋了。事情堆积起来，我们是怎么到达这一点的？我们开始时有一个大小为8的列表。然后我们查看左半部分，发现它是一个大小为4的数组。接着我们查看那部分的左半，发现它是一个大小为2的数组。
- en: then two arrays of size one then we，think，now if i rewind in that story brian
    you。need to sort the right half，of the left half of the original numbers，four。the
    right half of the left half is now，going to be these two numbers。and so now to
    sort those two i guess i，would repeat the process again look at。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有两个大小为一的数组，然后我们，想，现在如果我倒回那段故事，布莱恩你。需要对原始数字的左半部分的右半部分进行排序，四。左半部分的右半部分现在是，这两个数字。所以现在要排序这两个，我想我，会再次重复这个过程看。
- en: numbers individually i would look at the，left half of these two。which is the
    eight that one's done and，the five that one's done as well。all right so step three
    of three then is，merge those two sorted halves。all right so between the eight
    and the，five the five is smaller so that one，will go in first。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我单独看这两个的左半部分。是八，那一个完成了，还有五，那一个也完成了。好的，所以第三步是，合并这两个已排序的部分。好的，所以在八和五之间，五更小，所以那个，先放进去。
- en: and then the eight will go after that，and now i have a second array。of size
    two that is also now sorted，remind，just now，the left。half and the right half of
    the left half，so i think the third and final step at。this part of the story is
    brian，which now，is of size two all right i have two。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后八会在后面，现在我有第二个大小为二的数组，它现在也是已排序的，提醒一下，现在，左。半部分和左半部分的右半部分，所以我认为这个故事的第三个也是最后一个步骤是布莱恩，现有的大小为二，好的我有两个。
- en: arrays of size two each of which is，sorted that i need to merge，so i'm gonna
    compare the smallest。numbers from each i'm gonna compare the，three and the five，the
    three is smaller so that one will go。in first now between these two arrays i，have
    a six and a five to compare。the five is smaller so that one i go，next between
    the six and the eight the，six is smaller。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个大小为二的已排序数组，我需要合并，所以我将比较每个的最小数字。我会比较，三和五，三更小，所以那个会先放。现在在这两个数组之间，我有一个六和一个五要比较。五更小，所以我接下来会看六和八，六更小。
- en: and i'm left with just the eight so if，we go back to the original story of。eight
    numbers that i was sorting i think，i have now sorted the left half of the。left
    four numbers from that original，array indeed so if you're playing along。at home
    think about you've got all these，thoughts probably kind of piling up in。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我剩下的只有八个，如果，回到我正在排序的原始八个数字，我想，我现在已经排序了原始数组的左半部分四个数字，确实如此，所以如果你在家里玩，想想你有这些，想法可能堆积在一起。
- en: your mind that's indeed supposed to be，the case and admittedly it's hard to。keep
    track of all of that，together，doing the same thing now by sorting the。right half
    all the way to completion，brian if you could，all right so the right half we got
    four。numbers i'm going to start by sorting，the left half of the right half。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你心里确实应该是这样的，坦白说，很难。跟踪所有这些，做同样的事情，现在通过排序右半部分直到完成，布莱恩如果你可以，好的，所以右半部分我们得到了四。个数字我将开始对，右半部分的左半部分进行排序。
- en: which is these two numbers here to do，that i'll repeat the same process so。it's
    the left half of these two numbers，which is just the two，that one's done it's
    only one number。same thing with the right half the seven，is only one number so
    it's done。and now i'll merge the sorted halves，together between the two and the
    seven，the two is smaller。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这两个数字，要做到这一点我会重复同样的过程。它是这两个数字的左半部分，只有两个，那一个完成了，它只有一个数字。右半部分同样，七只有一个数字，所以也完成了。现在我会将已排序的部分合并，两个和七之间，两个更小。
- en: and then the seven so here now is the，left half of the right half。an array of
    size two that is sorted and，i'll do the same thing with the right，half of the
    right half。starting with the left half which is，four that's done the one is done。and
    now to merge these two together i'll，compare them and say the one is smaller。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是七，所以这里现在是，右半部分的左半部分。一个已排序的大小为二的数组，我会对右半部分的右半部分做同样的事情。从左半部分开始是，四，已经完成，那个一也完成了。现在要把这两个合并，我会比较它们，发现那个一更小。
- en: so we'll put the one down and then the，four，so now i have two sorted arrays
    each of，size two。that i now need to backtrack and now，merge together to form an
    array of size。four so i'll compare the two and the one，between those two the one
    is smaller。then i'll compare the two with the four，the two is smaller，then i'll
    compare the seven with the。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们把一放下，然后是四，所以现在我有两个大小为二的已排序数组。我现在需要回溯并且，合并在一起形成一个大小为四的数组，所以我会比较这两个之间的那个，一是更小的。然后我会把两个与四进行比较，两个更小，然后我会比较七和。
- en: four the four is smaller and then，last number，and put that in the final spot
    and so，numbers。i've now sorted the left half and i've，sorted the right half，and
    now that's brings us to our third。and very final step，could you brian merge the
    sordid halves，yeah and i think this is actually an。example we've seen already
    and what i'm，going to do in order to sort these two。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 四个元素中，四是较小的那个，然后是最后一个数字，将其放入最终的位置，所以数字。我现在已经对左半边进行了排序，对右半边也进行了排序，现在我们进入第三个也是最后一步，你能把这两个排序的半部分合并吗？是的，我认为这实际上是一个我们已经看到的例子。为了对这两个半部分进行排序。
- en: halves is just take the smaller number，from each half and compare them again，one。the
    one that's the smallest number so，that goes into place，then between the three
    and the two the。two is smaller，so we'll take that and put that into，the four，comparing。the
    five with the four the four is，smaller so the four goes into place。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需从每个半部分取出较小的数字，再次进行比较。较小的数字放入合适的位置，然后在三和二之间，二较小，所以我们取出二并将其放入四中，进行比较。将五与四进行比较，四较小，因此四放入合适的位置。
- en: next now i'm comparing the five with the，seven the five is smaller。so that one
    goes into place i'm next，comparing the six with the seven。so the six is smaller
    that goes next and，and the seven，the seven is the smaller of the two so。that one
    goes next，and at this point i only have one number，left which is the eight。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我在比较五和七，五较小。因此，它进入合适的位置。接下来我在比较六和七，六较小，所以六进入下一位，七则是两个中较小的数字，所以它接着进入。此时我只剩下一个数字，即八。
- en: and so that one's going to go into its，sorted position at the，end of the array
    indeed so even though。it felt like we weren't really doing，it all sort of come，came
    together when we started merging。and merging and merging these lists and，using，top
    to bottom，effectively。dividing that list up we started with a，list of eight and
    we essentially took it。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，一个数字会在数组的末尾进入其排序位置，尽管感觉我们并没有真的在做，但当我们开始合并、合并、再合并这些列表，并有效地自上而下地划分列表时，这一切都聚在了一起。我们从一个八个元素的列表开始，然后本质上进行了处理。
- en: to two lists of size four，size one，and while it wasn't exactly in that。order
    if you rewind and analyze all of，went from eight，to two fours to four twos to
    eight ones。and that's why he moved those numbers，from the top shelf，twos，the numbers。he
    moved them three times total and on，each of those shelves，how many numbers did
    he have to merge。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 两个大小为四、一个大小为一的列表，尽管它并不是完全按照那个顺序，如果你回放并分析所有内容，数字从八变成两个四，再到四个二，最后到八个一。这就是他为什么将这些数字从顶层架子上移动，即二的原因。他总共移动了三次，在每个架子上，他需要合并多少数字。
- en: together on each of those shelves he，first，inserted the smallest number then
    the。second smallest then the third smallest，but unlike selection sort，halves。so
    he was just plucking them off one at，back and forth，he was constantly taking from
    the。beginning of each of those half，let's say，n steps because he was merging in
    all n。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个架子上，他首先插入最小的数字，然后是第二小的数字，再到第三小的数字，但与选择排序不同，半部分。他只是在不断地从每个半部分的开头取出数字，假设是n步，因为他在合并所有n。
- en: elements of that shelf，but how many times did he merge n，elements together well
    he did that three。total times，but if you think about binary search and，really
    the process of divide and conquer。more generally any time you divide，something
    in half and half and half。as he was doing from eights to fours to，twos to ones，that's
    a logarithm that's log base two。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那个架子的元素，但他合并n个元素的次数是多少？他总共做了三次，但如果你考虑二分查找，以及更广泛的分而治之的过程。每当你将某样东西分成一半，再一半、再一半，就像他从八到四、到二、到一的过程，这就是对数，底数为二的对数。
- en: and indeed that is wonderfully the，height of this shelf，if you have eight elements
    on the shelf。the number of additional shelves brian，used three，is exactly what
    you get by doing the。math log base two，of eight which is to say brian did n，things
    log n times and again with the。wave of the hand computer scientists，don't bother
    mentioning the base uh with，log n。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这正好是这个架子的高度，如果你在架子上有八个元素。布赖恩使用的额外架子数为三，正好是通过计算得到的，底数为二的对数，八的对数，也就是说布赖恩做了n次，log
    n次，再加上计算机科学家挥手表示的不提及底数的log n。
- en: brian did n things log n times and so if，we consider then，the asymptotic complexity
    of this。algorithm that is to say the running，time of this algorithm，it performs。strictly
    better than selection sort and，bubble sort，n times log n and even again if you're
    a。little rusty on logarithms，log n we have seen as of week zero in，binary search
    is definitely，times。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱恩进行了 n 次操作，每次 log n 次，因此如果我们考虑该算法的渐近复杂性，也就是算法的运行时间，它的表现严格优于选择排序和冒泡排序，复杂度为
    n log n，甚至再次强调，如果你对对数有些生疏，我们在零周的二分查找中看到 log n 确实是相乘的。
- en: n n log n is n times log n which is，indeed mathematically better than。n squ*red
    as with merge sort though if，we consider the lower bound，low。as omega of n turns
    out merge sort，is a little bit like selection sword in。that it doesn't optimize
    itself，and get your out of the algorithm early，it's always。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: n log n 是 n 乘以 log n，这在数学上确实优于 n 的平方。虽然在考虑下界时，归并排序有点像选择排序，因为它并没有自我优化，早早退出算法，它始终是在合并这些部分。
- en: n log n so it's lower bound omega，of n log n and that might not be。acceptable
    sometimes you might have，certain data inputs where maybe。it tends to be sorted
    and you don't want，with bubble sore。![](img/c1a3243d8952685a8f2dc571e948dab7_75.png)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: n log n 所以它的下界是 omega(n log n)，这有时可能不可接受，你可能会有某些数据输入，可能趋向于已排序，而你不想使用冒泡排序。![](img/c1a3243d8952685a8f2dc571e948dab7_75.png)
- en: but honestly as n gets large the，probability that the input，to your sorting
    algorithm is just by。chance going to be sorted，is probably so so low that you're
    just。better off in the general case using an，algorithm like merge sort that's
    n log n。always we can see this visually using，our bars too，and notice just as
    brian was dividing。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但老实说，随着 n 的增大，输入到你的排序算法中的数据，偶然间恰好已排序的概率是非常非常低的，因此在一般情况下，使用像归并排序这样的算法（其复杂度为 n
    log n）会更好。我们也可以通过我们的条形图直观地看到这一点，并注意到，就像布莱恩在分割时所做的。
- en: and conquering the problem in half and，half and half and then，reconstituting
    the array by merging。those halves you can kind of see that，visually here，there's
    a lot more going on and it's。going to seem in a moment，that everything just kind
    of magically，worked but you can see in the faded。purple bars，halves and then。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过将问题一分为二，再合并这些部分，你可以在视觉上看到，实际上这里发生了很多事情，过一会儿，这一切看似神奇地运作，但你可以在淡紫色的条形图中看到这些部分。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_77.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_77.png)'
- en: merging those halves together and this，visualization was a little different。it
    did not have the luxury of three，shelves it just moved top to bottom top。to bottom
    and honestly brian could have，been a little more optimal there。we wanted to make
    clear how many total，no，reason he couldn't have just moved the。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 合并这些部分的可视化稍有不同。它没有三层存储的奢侈，只是从上到下移动。老实说，布莱恩在这里可以更优化一些。我们想清楚地说明总共需要多少，实际上他完全可以直接移动。
- en: numbers down then back up then back down，then back up，and indeed that's the
    price you pay with。merge sort even though，n log n is better than n squ*red and，ergo
    merge sort is arguably better than。selection sort and bubble sort，you pay a price
    and this speaks to the，trade-off i mentioned earlier。almost always when you do
    something，better in code，or solve a problem more intelligently。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 数字上下波动，确实这就是使用归并排序所付出的代价，尽管 n log n 优于 n 的平方，因此归并排序可以说优于选择排序和冒泡排序，你付出了代价，这表明我之前提到的权衡。几乎总是，当你在代码中做得更好，或者更智能地解决问题时。
- en: you have paid a price，maybe you spent more time as the human，writing the code
    because it was harder。and took more sophistication，that is a cost maybe you had
    to use，actually more space，shelf。in order to implement merge sort if，will need，at
    least a second array to temporarily。put the numbers into，as you merge things back
    and forth if，three。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能付出了代价，也许你作为人类编写代码时花费了更多时间，因为这更复杂，需要更多的技巧，这是一种成本，也许你需要使用更多的空间，暂时存放数字，以便在合并时来回移动，如果是三。
- en: separate arrays or four separate arrays，but it suffices per the graphical。representation
    of merge sort，to just use a second array now that。might not seem like such a big
    deal but，implicitly you need twice as much space。and that might be a big deal，if
    you've got a million things to sort，and you now need two arrays。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 分开的数组或四个分开的数组，但根据归并排序的图形表示，只使用第二个数组就足够了。现在这可能看起来没什么大不了，但隐含地你需要两倍的空间，这在你有一百万个需要排序的东西时可能是个大问题，现在你需要两个数组。
- en: that's two million chunks of memory that，you need and maybe that's not tenable。so
    there too there's going to be a，trade-off and maybe while slower。selection sort
    of bubbles or maybe it's，better because it's a little more，efficient with space。it's
    going to depend on what you care，about and what you want to optimize for。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要两百万块内存，可能这并不可行。因此，这里也会有权衡，可能选择排序或气泡排序速度更慢，但也许因为它在空间上更有效，具体取决于你关心什么，以及你想优化什么。
- en: and honestly money is sometimes a factor，in the real world，maybe it's better
    to write slightly，buy。twice as many servers or twice as much，memory for your computer，it
    depends there on what resource is。time，your your your wallet or some other，resource
    altogether so we'll continue to。see these kinds of trade-offs，but perhaps the
    most mind-blowing thing，we can do。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，金钱有时是一个因素，在现实世界中，也许稍微多花点钱，购买两倍数量的服务器或两倍的计算机内存是更好的选择，这取决于资源的情况，时间、你的钱包或其他资源。因此我们会继续看到这些权衡，但也许最令人震惊的是，我们可以做到的事情。
- en: as we wrap up here share a few，visualizations of，how these algorithms actually
    compare。and one last piece of jargon is this one，final greek symbol theta it turns
    out。that thanks to selection sort，more，term of art here this theta notation。anytime
    an algorithm has both the same，time，you can actually describe it in just one。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，我分享一些如何这些算法实际比较的可视化，最后一个术语是这个，最终的希腊符号 theta，结果证明，得益于选择排序，更具体的术语是这个 theta
    符号。任何时候当一个算法具有相同的时间，你实际上可以用一个来描述它。
- en: sentence instead of two，in terms of theta notation so because，selection sort
    was in both big o of n。squ*red and omega of n squ*red，you can actually just say
    ah it's in。theta of n squ*red it's always n squ*red，either in the upper bound
    or in the。lower bound same thing for merge sort，it's in theta of n log n，we cannot
    use theta for bubble sort。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 theta 符号中用一个句子而不是两个，因此因为选择排序在大 O 记号中是 n 的平方，同时也是 omega 的 n 的平方，你实际上可以简单地说，它在
    theta 的 n 的平方中，无论是上界还是下界，归并排序也是如此，它在 theta 的 n log n 中，而我们不能为气泡排序使用 theta。
- en: or for binary search or for linear，search because they had different。upper and
    lower bounds but let me go，ahead now，and prepare a final demonstration this。time
    using some random inputs，so you'll see here a video comparing，sort。all together
    all three of them start，with random data，but let's just see what it means for
    an。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索或线性搜索因为它们有不同的上下界，但让我现在继续，准备一个最终演示，这次使用一些随机输入，你会看到这里有一个视频比较排序。所有三者都从随机数据开始，但让我们看看这对一个算法意味着什么。
- en: algorithm to be an n，squ*red in the worst case or an n log n，close。let's go
    ah**d and with a dramatic，flourish now，compare selection sort merge sort and。selection
    sorts on the top bubble sorts，on the bottom merge sorts in the middle，already，[Music]。done
    and meanwhile，we have some very trendy music we can，listen to which is really
    just there to。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏情况下，算法是 n 的平方或接近 n log n。让我们以戏剧性的方式，现在比较选择排序、归并排序和气泡排序，选择排序在上面，气泡排序在下面，归并排序在中间，已经，[音乐]。完成，同时我们有一些非常时尚的音乐可以听，实际上只是为了让气氛更好。
- en: distract us from the fact，at how slow n squ*red actually is，in practice and
    notice there's not that。many bars here there's maybe like a，hundred or so bars
    like，n is a hundred that's not even a big。value when we're talking about the，the
    world，these are trivial sizes and yet my god。we're still waiting for selection
    sort，and bubble sort to finish and so you can。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忽视在实践中，n 的平方是多么缓慢，注意这里没有多少条，这里也许只有一百条，像 n 是一百，这在我们谈论的世界中并不算大值，这些都是微不足道的大小，但天哪，我们仍在等待选择排序和气泡排序完成。
- en: see here that it really matters when you，exercise a little bit more。cleverness
    and you leverage a more，efficient algorithm and finally，selection sort is done。bubble
    sort's still taking a little，longer here and this is going to depend，or unlucky。![](img/c1a3243d8952685a8f2dc571e948dab7_79.png)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，运用更多的智慧，利用更高效的算法时，事情真的很重要，最后，选择排序已经完成。气泡排序仍在这里花费更长的时间，这将取决于运气。
- en: but i think it's convincing that merge，sort has won in this case，let's consider
    a more concrete case。suppose that in the worst case the lists，the arrays are originally。completely
    backwards let's consider how，these algorithms function instead。now we want to
    go from smallest to，largest you can still see merge sort。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但我认为很有说服力的是，归并排序在这种情况下赢了，让我们考虑一个更具体的例子。假设在最坏情况下，列表或数组最初完全相反，让我们考虑这些算法的功能，现在我们想从最小到最大，你仍然可以看到归并排序。
- en: sort of taking half bytes out of this，problem again and again and，reconstituting
    the solution。boom that's n log n even with just this，few bars and you can really
    see bubble。sorts big elements are bubbling up，selection sorts small elements are。percolating
    their way down to the left，but my god i don't have enough words to。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 反复从这个问题中提取出一半的字节，然后重构解决方案，哇，这就是 n log n，即使只有这几条信息，你也可以真正看到冒泡排序中大元素的上浮，而选择排序中小元素的向左渗透，但我的天，我没有足够的词语来描述。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_81.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_81.png)'
- en: get us to the finish line with these，and even though we've only looked today。at
    two searches linear and binary，and three sorts selection uh bubble。and merge sort
    there are so many other，to searching，and generally speaking when sorting data。you're
    not going to write the code，yourself you may very well do that in a，class in a
    lab。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 带我们到达终点线，尽管我们今天只看了两种搜索：线性和二进制，以及三种排序：选择、冒泡和归并排序，但还有很多其他的搜索，通常来说，在排序数据时，你并不会自己写代码，你可能会在课堂上或实验室中这样做。
- en: but in the real world again you're going，other，humans correct implementations
    of。commonly used functions，so that you can stand on their shoulders，so to speak
    and focus really on the。problems you care about，and not on these more commodity
    type，problems that have surely been solved。by other people before you and just
    to，give you a glimpse then。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但在现实世界中，你会发现其他人对常用功能的正确实现，以便你可以“站在他们的肩膀上”，真正关注你关心的问题，而不是这些已经被其他人解决的更常见的问题，只是给你一个瞥见。
- en: we'll abort bubble sort there which is，going to take quite too long here is
    one。final visualization this one more，acoustical in nature，that also associates
    sounds with each of。these algorithms so if you're more of an，can you perhaps，hear
    now in closing the differences in。![](img/c1a3243d8952685a8f2dc571e948dab7_83.png)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里中止冒泡排序，因为这会花费太多时间，这里有一个最终的可视化，这个更具声学性质的可视化也将声音与这些算法关联起来，所以如果你更能“听到”这些差异。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_84.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_84.png)'
- en: that was an algorithm called insertion。![](img/c1a3243d8952685a8f2dc571e948dab7_86.png)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种叫做插入排序的算法。![](img/c1a3243d8952685a8f2dc571e948dab7_86.png)
- en: sort，and again in this pulsing you can kind，of hear the redundant work the redundant。work
    the redundant work，which is why n squ*red really starts to，add up when you're
    doing so many。superfluous comparisons again and again，this now is selection sort
    so notice，that the small elements。are ending up at the left。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 排序，再次在这种脉动中，你可以隐约听到冗余工作，冗余工作，冗余工作，这就是为什么 n² 在进行如此多的多余比较时会累加，这现在是选择排序，所以注意小元素最终位于左侧。
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_88.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_88.png)'
- en: '![](img/c1a3243d8952685a8f2dc571e948dab7_89.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a3243d8952685a8f2dc571e948dab7_89.png)'
- en: '[Music]。![](img/c1a3243d8952685a8f2dc571e948dab7_91.png)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[音乐]。![](img/c1a3243d8952685a8f2dc571e948dab7_91.png)'
- en: perhaps the most gratifying that then。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这就是最令人满意的部分。
