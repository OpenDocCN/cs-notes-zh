- en: 3.3   Designing Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3   设计数据类型
- en: 原文：[https://introcs.cs.princeton.edu/java/33design](https://introcs.cs.princeton.edu/java/33design)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/33design](https://introcs.cs.princeton.edu/java/33design)
- en: In this section we discuss *encapsulation*, *immutability*, and *inheritance*,
    with particular attention to the use of these mechanisms in *data-type design*
    to enable modular programming, facilitate debugging, and write clear and correct
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论*封装*、*不可变性*和*继承*，特别关注这些机制在*数据类型设计*中的应用，以实现模块化编程，促进调试，并编写清晰和正确的代码。
- en: Encapsulation.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装。
- en: The process of separating clients from implementations by hiding information
    is known as *encapsulation*. We use encapsulation to enable modular programming,
    facilitate debugging, and clarify program code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隐藏信息将客户端与实现分离的过程被称为*封装*。我们使用封装来实现模块化编程��促进调试，并澄清程序代码。
- en: '*Complex numbers revisited.* ![polar representation](../Images/0747bc2d9355e592411282422db02eaa.png)
    [Complex.java](Complex.java.html) has the same API as [Complex.java](../32class/Complex.java.html),
    except that it represents a complex number using *polar coordinates* \(r (\cos
    \theta + i \sin \theta)\) instead of *Cartesian coordinates* as \(x + iy\).  The
    idea of encapsulation is that we can substitute one of these programs for the
    other without changing client code.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复数再探.* ![极坐标表示](../Images/0747bc2d9355e592411282422db02eaa.png) [Complex.java](Complex.java.html)
    与 [Complex.java](../32class/Complex.java.html) 具有相同的API，只是它使用*极坐标* \(r (\cos \theta
    + i \sin \theta)\) 而不是*笛卡尔坐标* \(x + iy\) 表示复数。封装的思想是我们可以将其中一个程序替换为另一个而不改变客户端代码。'
- en: '*Private.* When you declare an instance variable (or method) to be `private`,
    you are making it impossible for any client (code in another class) to directly
    access that instance variable (or method). This helps enforce encapsulation.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有.* 当你将一个实例变量（或方法）声明为`private`时，你使得任何客户端（另一个类中的代码）无法直接访问该实例变量（或方法）。这有助于强制封装。'
- en: '*Limiting the potential for error.* Encapsulation also helps programmers ensure
    that their code operates as intended. To understand the problem, consider [Counter.java](Counter.java.html),
    which encapsulates a single integer and ensures that the only operation that can
    be performed on the integer is *increment by 1*.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*限制错误的潜力.* 封装还帮助程序员确保他们的代码按预期运行。要理解这个问题，考虑[Counter.java](Counter.java.html)，它封装了一个单个整数，并确保唯一可以对该整数执行的操作是*加1*。'
- en: '![Counter API](../Images/425bb62facc3778099b32924bb7ff3e3.png)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![计数器API](../Images/425bb62facc3778099b32924bb7ff3e3.png)'
- en: 'Without the `private` modifier, a client could write code like the following:'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有`private`修饰符，客户端可以编写如下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the `private` modifier, code like this will not compile.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`private`修饰符，像这样的代码将无法编译。
- en: Immutability.
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性。
- en: '![Immutable and mutable data types](../Images/d9ca53c7d0d086d77e7b3b10ed75ceff.png)
    An object from a data type is *immutable* if its data-type value cannot change
    once created. An *immutable data type* is one in which all objects of that type
    are immutable.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![不可变和可变数据类型](../Images/d9ca53c7d0d086d77e7b3b10ed75ceff.png) 如果一个数据类型的对象一旦创建就不能改变其数据类型值，则该对象是*不可变*的。一个*不可变数据类型*是其中所有对象都是不可变的数据类型。'
- en: '*Advantages of immutability.* We can use immutable objects in assignment statements
    (or as arguments and return values from methods) without having to worry about
    their values changing. This makes immutable type easier to reason about and debug.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变性的优势.* 我们可以在赋值语句中使用不可变对象（或作为方法的参数和返回值）而不必担心它们的值会改变。这使得不可变类型更容易推理和调试。'
- en: '*Cost of immutability.* The main drawback of immutability is that a new object
    must be created for every value.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变性的代价.* 不可变性的主要缺点是必须为每个值创建一个新对象。'
- en: '*Final.* When you declare an instance variable as `final`, you are promising
    to assign it a value only once. This helps enforce immutability.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最终.* 当你将一个实例变量声明为`final`时，你承诺只分配一次值。这有助于强制不可变性。'
- en: '*Reference types.* The `final` access modifier does not guarantee immutability
    for instance variables of mutable types. In such cases, you must make a *defensive
    copy*.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用类型.* `final` 访问修饰符不能保证可变类型的实例变量是不可变的。在这种情况下，你必须进行*防御性拷贝*。'
- en: Spatial vectors.
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间向量。
- en: '![Vector](../Images/0032311a95197dd29f29960fa72a53b2.png)  A *spatial vector*
    is an abstract entity that has a *magnitude* and a *direction*.  A sequence of
    *n* real numbers suffices to specify a vector in *n*-dimensional space. We use
    a boldface letter like \( \boldsymbol{x} \) to denote the vector \( ( x_0, x_1,
    \; \ldots, \; x_{n-1}) \).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![向量](../Images/0032311a95197dd29f29960fa72a53b2.png)  一个*空间向量*是一个具有*大小*和*方向*的抽象实体。
    一系列*n*个实数足以指定*n*维空间中的一个向量。我们使用粗体字母如\( \boldsymbol{x} \)表示向量\( ( x_0, x_1, \; \ldots,
    \; x_{n-1}) \)。'
- en: '*API.* The basic operations on vectors are to add two vectors, multiply a vector
    by a scalar, compute the dot product of two vectors, and to compute the magnitude
    and direction, as follows:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API.* 向量的基本操作是将两个向量相加，将一个向量乘以一个标量，计算两个向量的点积，以及计算大小和方向，如下所示：'
- en: '*Addition*: \( \boldsymbol{x} + \boldsymbol{y} = ( x_0 + y_0, x_1 + y_1, \;
    \ldots, \; x_{n-1} + y_{n-1}) \)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法*: \( \boldsymbol{x} + \boldsymbol{y} = ( x_0 + y_0, x_1 + y_1, \; \ldots,
    \; x_{n-1} + y_{n-1}) \)'
- en: '*Vector scaling*: \( \alpha \boldsymbol{x} = (\alpha x_0, \alpha x_1, \; \ldots,
    \; \alpha x_{n-1}) \)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向量缩放*: \( \alpha \boldsymbol{x} = (\alpha x_0, \alpha x_1, \; \ldots, \; \alpha
    x_{n-1}) \)'
- en: '*Dot product* \( \boldsymbol{x} \cdot \boldsymbol{y} = x_0y_0 + x_1y_1 + \,
    \ldots \, + x_{n-1}y_{n-1} \)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*点积* \( \boldsymbol{x} \cdot \boldsymbol{y} = x_0y_0 + x_1y_1 + \, \ldots \,
    + x_{n-1}y_{n-1} \)'
- en: '*Magnitude*: \( \left | \boldsymbol{x} \right | = \sqrt{x_0^2 + x_1^2 + \,
    \ldots \, + x_{n-1}^2} \)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大小*: \( \left | \boldsymbol{x} \right | = \sqrt{x_0^2 + x_1^2 + \, \ldots
    \, + x_{n-1}^2} \)'
- en: '*Direction*: \( \boldsymbol{x} \,/\, \left | \boldsymbol{x} \right | = (x_0
    \,/\, \left | \boldsymbol{x} \right |, x_1 \,/\, \left | \boldsymbol{x} \right
    |, \; \ldots, \; x_{n-1} \,/\, \left | \boldsymbol{x} \right |) \)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方向*: \( \boldsymbol{x} \,/\, \left | \boldsymbol{x} \right | = (x_0 \,/\,
    \left | \boldsymbol{x} \right |, x_1 \,/\, \left | \boldsymbol{x} \right |, \;
    \ldots, \; x_{n-1} \,/\, \left | \boldsymbol{x} \right |) \)'
- en: 'These basic mathematical definitions lead immediately to an API:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些基本的数学定义立即导致了一个API：
- en: '![Vector API](../Images/ccb39170a5f0e8c2263d0481300effab.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![向量API](../Images/ccb39170a5f0e8c2263d0481300effab.png)'
- en: '*Implementation.* [Vector.java](Vector.java.html) is an immutable data type
    that implements this API. Internally, it uses an array of length *n* to store
    the Cartesian coordinates.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现。*[Vector.java](Vector.java.html)是一个不可变的数据类型，实现了这个 API。在内部，它使用长度为*n*的数组来存储笛卡尔坐标。'
- en: '*The this reference.* Within an instance method (or constructor), the `this`
    keyword gives us a way to refer to the object whose instance method (or constructor)
    is being called. For example, the `magnitude()` method in Vector uses the `this`
    keyword in two ways: to invoke the `dot()` method and as the argument to the `dot()`
    method.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*this引用。*在实例方法（或构造函数）中，`this`关键字为我们提供了一种引用调用的对象的方式。例如，Vector中的`magnitude()`方法以两种方式使用`this`关键字：调用`dot()`方法和作为`dot()`方法的参数。'
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interface inheritance (subtyping).
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口继承（子类型化）。
- en: Java provides the `interface` construct for declaring a relationship between
    otherwise unrelated classes, by specifying a common set of methods that each implementing
    class must include. Interfaces enable us to write client programs that can manipulate
    objects of varying types, by invoking common methods from the interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`interface`构造用于声明否则无关的类之间的关系，通过指定每个实现类必须包含的一组公共方法。接口使我们能够编写客户端程序，可以通过调用接口的公共方法来操作不同类型的对象。
- en: '*Defining an interface.* [Function.java](Function.java.html) defines an interface
    for real-valued functions of a single variable.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义接口。*[Function.java](Function.java.html)为单变量实值函数定义了一个接口。'
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The body of the interface contains a list of *abstract methods*. An abstract
    method is a method that is declared but does not include any implementation code;
    it contains only the method signature. You must save a Java interface in a file
    whose name matches the name of the interface, with a `.java` extension.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口的主体包含一个*抽象方法*列表。抽象方法是声明但不包含任何实现代码的方法；它只包含方法签名。您必须将Java接口保存在与接口名称匹配的文件中，扩展名为`.java`。
- en: '*Implementing an interface.* To write a class that implements an interface,
    you must do two things.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现接口。*要编写一个实现接口的类，您必须做两件事。'
- en: Include an `implements` clause in the class declaration with the name of the
    interface.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类声明中包含一个`implements`子句，其中包含接口的名称。
- en: Implement each of the abstract methods in the interface.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口中的每个抽象方法。
- en: For example, [Square.java](Square.java.html) and [GaussianPDF.java](GaussianPDF.java.html)
    implements the `Function` interface.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，[Square.java](Square.java.html)和[GaussianPDF.java](GaussianPDF.java.html)实现了`Function`接口。
- en: '*Using an interface.* An interface is a reference type. So, you can declare
    the type of a variable to be the name of an interface. When you do so, any object
    you assign to that variable must be an instance of a class that implements the
    interface. For example, a variable of type `Function` may store an object of type
    `Square` or `GaussianPDF`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用接口。*接口是一个引用类型。因此，您可以声明变量的类型为接口的名称。当您这样做时，分配给该变量的任何对象必须是实现接口的类的实例。例如，类型为`Function`的变量可以存储类型为`Square`或`GaussianPDF`的对象。'
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When a variable of an interface type invokes a method declared in the interface,
    Java knows which method to call because it knows the type of the invoking object.
    This powerful programming mechanism is known as *polymorphism* or *dynamic dispatch*.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当接口类型的变量调用接口中声明的方法时，Java知道调用哪个方法，因为它知道调用对象的类型。这种强大的编程机制称为*多态*或*动态分派*。
- en: '*Plotting functions.* [FunctionGraph.java](FunctionGraph.java.html) plots the
    graph of a real-valued function *f* in the interval [*a*, *b*] by sampling the
    function at *n* + 1 evenly spaced points. It works for any sufficiently smooth
    function `f` that implements the `Function` interface.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制函数。*[FunctionGraph.java](FunctionGraph.java.html)通过在*n*+1个均匀间隔的点上对函数进行采样，在区间[*a*,
    *b*]中绘制实值函数*f*的图形。它适用于任何实现`Function`接口的足够平滑的函数`f`。'
- en: '![plotting a function graph](../Images/6413348270fbdc0917bf7ac7889bcc4b.png)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![绘制函数图](../Images/6413348270fbdc0917bf7ac7889bcc4b.png)'
- en: '*Numerical integration.* [RectangleRule.java](RectangleRule.java.html) estimates
    the integral of a positive real-valued function *f* in an interval (*a*, *b*)
    using the *rectangle rule*. It works for any sufficiently smooth function `f`
    that implements the `Function` interface.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数值积分。*[RectangleRule.java](RectangleRule.java.html)使用*矩形法则*估计在区间(*a*, *b*)中的正实值函数*f*的积分。它适用于任何实现`Function`接口的足够平滑的函数`f`。'
- en: '![rectangle rule](../Images/3244b4f0c7bf2b0e53736bdc61c0afc0.png)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![矩形法则](../Images/3244b4f0c7bf2b0e53736bdc61c0afc0.png)'
- en: '*Lambda expressions.* To simplify syntax, Java provides a powerful functional
    programming feature known as *lambda expressions*. You should think of a lambda
    expression as a block of code that you can pass around and execute later. In its
    simplest form, a lambda expression consists of the three elements:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Lambda表达式。*为了简化语法，Java提供了一个强大的函数式编程特性，称为*lambda表达式*。您应该将lambda表达式视为可以传递并稍后执行的代码块。在其最简单的形式中，lambda表达式由三个元素组成：'
- en: A list of parameters variables, separated by commas, and enclosed in parentheses
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由逗号分隔的参数变量列表，括在括号中
- en: The *lambda operator* `->`
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lambda运算符* `->`'
- en: A single expression, which is the value returned by the lambda expression
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一表达式，这是 lambda 表达式返回的值
- en: 'For example, the following lambda expression implements the hypotenuse function:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下lambda表达式实现了斜边函数：
- en: '![anatomy of a lambda expression](../Images/9fd3e4ec1fb6072a7fbddb64ab41f0dc.png)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![lambda表达式的解剖](../Images/9fd3e4ec1fb6072a7fbddb64ab41f0dc.png)'
- en: 'Our primary use of lambda expressions is as a concise way to implement a *functional
    interface* (an interface with a single abstract method). Specifically, you can
    use a lambda expression wherever an object from a functional interface is expected.
    For example, all of the following expressions implement the [Function.java](Function.java.html)
    interface:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们主要使用 lambda 表达式作为实现*函数接口*（具有单个抽象方法的接口）的简洁方式。具体来说，您可以在需要函数接口对象的任何地方使用 lambda
    表达式。例如，以下所有表达式都实现了[Function.java](Function.java.html)接口：
- en: '![functional interface](../Images/60babd1236056ffeb2c0b388240fec46.png)'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![函数接口](../Images/60babd1236056ffeb2c0b388240fec46.png)'
- en: Consequently, you can can integrate the square function with the call `integrate(x
    -> x*x, 0, 10, 1000)`, bypassing the need to define a separate `Square` class.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，您可以通过调用 `integrate(x -> x*x, 0, 10, 1000)` 来集成平方函数，而无需定义一个单独的`Square`类。
- en: '*Built-in interfaces.* Java includes three built-in interfaces that we will
    consider later this book.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内置接口.* Java 包含三个内置接口，我们将在本书后面考虑。'
- en: The interface [java.util.Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)
    defines an order in which to compare objects of the same type, such as alphabetical
    order for strings or ascending order for integers.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口[java.util.Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)定义了一种比较同一类型对象的顺序，例如字符串的字母顺序或整数的升序。
- en: The interfaces [java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)
    and [java.lang.Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)
    enable clients to iterate over the items in a collection, without relying on the
    underlying representation.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口[java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)和[java.lang.Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)使客户端能够在不依赖底层表示的情况下遍历集合中的项。
- en: Implementation inheritance (subclassing).
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现继承（子类化）。
- en: 'Java also supports another inheritance mechanism known as *subclassing*. The
    idea is to define a new class (*subclass*, or *derived class*) that inherits instance
    variables (state) and instance methods (behavior) from another class (*superclass*,
    or *base class*), enabling code reuse. Typically, the subclass redefines or *overrides*
    some of the methods in the superclass. For example, Java provides an elaborate
    inheritance hierarchy for GUI components:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还支持另一种继承机制，称为*子类化*。其思想是定义一个新类（*子类*或*派生类*），从另一个类（*超类*或*基类*）继承实例变量（状态）和实例方法（行为），实现代码重用。通常，子类会重新定义或*覆盖*超类中的一些方法。例如，Java
    为 GUI 组件提供了一个复杂的继承层次结构：
- en: '![Java inheritance hierarchy for GUI elements](../Images/79cf04ee6b9dff0a5b4b6be15a4f5766.png)'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Java GUI 元素的继承层次结构](../Images/79cf04ee6b9dff0a5b4b6be15a4f5766.png)'
- en: In this book, we avoid subclassing because it works against encapsulation and
    immutability (e.g., the [fragile base class problem](https://en.wikipedia.org/wiki/Fragile_base_class)
    and the [circle–ellipse](https://en.wikipedia.org/wiki/Circle-ellipse_problem)
    problem).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们避免使用子类化，因为它违反了封装性和不可变性（例如，[脆弱基类问题](https://en.wikipedia.org/wiki/Fragile_base_class)和[圆-椭圆问题](https://en.wikipedia.org/wiki/Circle-ellipse_problem)）。
- en: '*Java''s Object superclass.* Certain vestiges of subclassing are built into
    Java and therefore unavoidable. Specifically, every class is a subclass of [java.lang.Object](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html).
    When programming in Java, you will often override one or more of these inherited
    methods:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java 的 Object 超类.* Java 中内置了一些子类化的遗留问题，因此不可避免。具体来说，每个类都是[java.lang.Object](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html)的子类。在
    Java 编程中，您经常会重写其中一个或多个继承的方法：'
- en: '![Object API](../Images/df6e17af8ade51966127aea05c279980.png)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![对象 API](../Images/df6e17af8ade51966127aea05c279980.png)'
- en: '*String conversion.* Every Java class inherits the [`toString()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--)
    method, so any client can invoke `toString()` for any object. This convention
    is the basis for Java’s automatic conversion of one operand of the string concatenation
    operator `+` to a string whenever the other operand is a string.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串转换.* 每个 Java 类都继承了[`toString()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--)
    方法，因此任何客户端都可以为任何对象调用 `toString()`。这个约定是 Java 自动将字符串连接运算符 `+` 的一���操作数转换为字符串的基础，只要另一个操作数是字符串。'
- en: '*Reference equality.* If we test equality with `(x == y)`, where `x` and `y`
    are object references, we are testing whether they have the same identity: whether
    the *object references* are equal.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用相等性.* 如果我们用 `(x == y)` 测试相等性，其中 `x` 和 `y` 是对象引用，我们正在测试它们是否具有相同的标识：即*对象引用*是否相等。'
- en: '*Object equality.* ![Overriding toString(), equals(), and hashCode()](../Images/6c5cf9c2d17d3b8e2682ef5d49e46dbd.png)
    The purpose of the [`equals()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-)
    method is to test whether two *objects* are equal (correspond to the same data-type
    value). It must implement an *equivalence relation*:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象相等性.* ![重写 toString()、equals() 和 hashCode()](../Images/6c5cf9c2d17d3b8e2682ef5d49e46dbd.png)
    [`equals()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-)
    方法的目的是测试两个*对象*是否相等（对应于相同的数据类型值）。它必须实现一个*等价关系*：'
- en: 'Reflexive: `x.equals(x)` is `true`.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自反性：`x.equals(x)` 为 `true`。
- en: 'Symmetric: `x.equals(y)` is `true` if and only if `y.equals(x)` is `true`.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称性：当且仅当 `x.equals(y)` 为 `true` 时，`y.equals(x)` 也为 `true`。
- en: 'Transitive: if `x.equals(y)` is `true` and `y.equals(z)` is `true`, then `x.equals(z)`
    is `true`.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递性：如果 `x.equals(y)` 为 `true` 且 `y.equals(z)` 为 `true`，则 `x.equals(z)` 为 `true`。
- en: 'In addition, the following two properties must hold:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，以下两个属性必须成立：
- en: Multiple calls to `x.equals(y)` return the same truth value, provided neither
    object is modified between calls.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次调用 `x.equals(y)` 返回相同的真值，前提是在调用之间没有修改任何对象。
- en: '`x.equals(null)` returns `false`.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x.equals(null)` 返回 `false`。'
- en: Overriding the `equals()` method is unexpectedly intricate because its argument
    can be a reference to an object of any type (or `null`).
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重写 `equals()` 方法是意外复杂的，因为它的参数可以是任何类型的对象引用（或 `null`）。
- en: '*Hashing.* The purpose of the [`hashCode()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--),
    method is to support *hashing*, which is a fundamental operation that maps an
    object to an integer, known as a *hash code*. It must satisfy the following two
    properties:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希。* [`hashCode()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)方法的目的是支持*哈希*，这是一种将对象映射到整数（称为*哈希码*）的基本操作。它必须满足以下两个属性：'
- en: If `x.equals(y)` is `true`, then `x.hashCode()` is equal to `y.hashCode()`.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x.equals(y)`为`true`，则`x.hashCode()`等于`y.hashCode()`。
- en: Multiple calls of `x.hashCode()` return the same integer, provided the object
    is not modified between calls.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次调用`x.hashCode()`返回相同的整数，前提是对象在调用之间没有被修改。
- en: 'Typically, we use the hash code to map an object `x` to an integer in a small
    range, say between `0` and `m-1`, using this *hash function*:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，我们使用哈希码将对象`x`映射到一个小范围内的整数，比如在`0`和`m-1`之间，使用这个*哈希函数*：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Objects whose values are not equal can have the same hash function value but
    we expect the hash function to divide `n` typical objects from the class into
    `m` groups of roughly equal size.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值不相等的对象可以具有相同的哈希函数值，但我们期望哈希函数将`n`个典型对象分成大致相等大小的`m`组。
- en: '*Wrapper types.* ![Wrapper types](../Images/31ae0730f9e7379357052b0abf192a65.png)
    The `toString()`, `hashCode()`, and `equals()` methods apply only to reference
    types, not primitive types. For example, the expression `x.hashCode()` works if
    `x` is a variable of type `Integer` but not if it is of type `int`. For situations
    where we wish want to represent a value from a primitive type as an object, Java
    supplies built-in reference types known as *wrapper types*, one for each of the
    eight primitive types.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包装类型。* ![包装类型](../Images/31ae0730f9e7379357052b0abf192a65.png) `toString()`，`hashCode()`和`equals()`方法仅适用于引用类型，而不适用于基本类型。例如，如果`x`是`Integer`类型的变量，则表达式`x.hashCode()`有效，但如果是`int`类型则无效。在我们希望将基本类型的值表示为对象的情况下，Java提供了内置的引用类型，称为*包装类型*，每个基本类型对应一个。'
- en: '*Autoboxing and unboxing.* Java automatically converts between values from
    a wrapper type and the corresponding primitive type, so that you can write code
    like the following:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动装箱和拆箱。* Java自动在包装类型和相应的基本类型之间进行转换，因此您可以编写如下代码：'
- en: '[PRE5]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Application: data mining.'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序：数据挖掘。
- en: We consider a *data mining* application in which the goal is to associate with
    each document a vector known as a *sketch* so that so that documents that are
    different have sketches that are different and documents that are similar have
    sketches that are similar. Our API abstracts away this notion into the method
    `similarTo()`, which is a real number between 0 (not similar) and 1 (similar).
    The parameters *k* and *d* control the quality of the sketch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑一个*数据挖掘*应用程序，其目标是为每个文档关联一个称为*草图*的向量，以便不同的文档具有不同的草图，而相似的文档具有相似的草图。我们的API将这个概念抽象成方法`similarTo()`，它是一个介于0（不相似）和1（相似）之间的实数。参数*k*和*d*控制草图的质量。
- en: '![Sketch API](../Images/c6313d389eedbb7a12e46cddd6181d4e.png)'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![草图API](../Images/c6313d389eedbb7a12e46cddd6181d4e.png)'
- en: '*Computing sketches.* ![Sketch of DNA](../Images/2e814bb10b353352802ebe70fd3d1b07.png)
    [Sketch.java](Sketch.java.html) uses a simple frequency count approach to compute
    the sketch of a text document. In its simplest form, it counts the number of time
    each *k*-gram (substring of length *k*) appears in the text. The sketch that we
    use is the direction of the vector defined by these frequencies.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算草图。* ![DNA的草图](../Images/2e814bb10b353352802ebe70fd3d1b07.png) [Sketch.java](Sketch.java.html)
    使用简单的频率计数方法来计算文本文档的草图。在其最简单的形式中，它计算文本中每个*k*-gram（长度为*k*的子字符串）出现的次数。我们使用的草图是由这些频率定义的向量的方向。'
- en: '*Hashing.* For ASCII text strings there are 128 different possible values for
    each character, so there are 128^(*k*) possible *k*-grams. For efficiency, [Sketch.java](Sketch.java.html)
    uses *hashing*. That is, instead of counting the number of times each *k*-gram
    appears, we hash each *k*-gram to an integer between 0 and *d*−1 and count the
    number of times each hash value appears.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希。* 对于ASCII文本字符串，每个字符有128个不同的可能值，因此有128^(*k*)个可能的*k*-gram。为了提高效率，[Sketch.java](Sketch.java.html)使用*哈希*。也就是说，我们不是计算每个*k*-gram出现的次数，而是将每个*k*-gram哈希到0到*d*-1之间的整数，并计算每个哈希值出现的次数。'
- en: '*Comparing sketches.* [Sketch.java](Sketch.java.html) uses the *cosine similarity
    measure* to compare two sketches:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较草图。* [Sketch.java](Sketch.java.html) 使用*余弦相似度度量*比较两个草图：'
- en: \( x \cdot y = x_0y_0 + x_1y_1 + \; \ldots \; + x_{d-1}y_{d-1} \)
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \( x \cdot y = x_0y_0 + x_1y_1 + \; \ldots \; + x_{d-1}y_{d-1} \)
- en: It is a real number between 0 and 1.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是一个介于0和1之间的实数。
- en: '*Comparing all pairs.* [CompareDocuments.java](CompareDocuments.java.html)
    prints the cosine similarity measure for all pairs of documents on an input list.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较所有对。* [CompareDocuments.java](CompareDocuments.java.html) 打印输入列表中所有文档对的余弦相似度度量。'
- en: '![text documents](../Images/fd4da740f9535894bda439b8bda97674.png)'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![文本文档](../Images/fd4da740f9535894bda439b8bda97674.png)'
- en: Design by contract.
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 契约式设计。
- en: We briefly discuss two Java language mechanisms that enable you to verify assumptions
    about your program while it is running—exceptions and assertions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了两种Java语言机制，使您能够在程序运行时验证对程序的假设 - 异常和断言。
- en: '*Exceptions.* An *exception* is a disruptive event that occurs *while* a program
    is running, often to signal an error. The action taken is known as *throwing an
    exception*. Java includes an elaborate inheritance hierarchy of predefined exceptions,
    several of which we have encountered previously.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异常。* *异常*是程序运行时发生的中断事件，通常用于表示错误。所采取的行动称为*抛出异常*。Java包括一个预定义异常的复杂继承层次结构，我们之前遇到过其中的几个。'
- en: '![Java exceptions](../Images/67eb76023dce2c3e9939a903fa9e1e91.png)'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Java异常](../Images/67eb76023dce2c3e9939a903fa9e1e91.png)'
- en: 'It is good practice to use exceptions when they can be helpful to the user.
    For example, in [Vector.java](Vector.java.html), we should throw an exception
    in `plus()` if the two vectors to be added have different dimensions:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当它们对用户有帮助时，使用异常是一个好的实践。例如，在[Vector.java](Vector.java.html)中，如果要相加的两个向量具有不同的维度，我们应该在`plus()`中抛出一个异常：
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Assertions.* An *assertion* is a boolean expression that you are affirming
    is true at some point *during* the execution of a program. If the expression is
    false, the program will throw an `AssertionError`, which typically terminates
    the program and reports an error message. For example, in [Counter.java](Counter.java.html),
    we might check that the counter is never negative by adding the following assertion
    as the last statement in `increment()`:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*断言.* 一个*断言*是一个布尔表达式，你在程序执行的某个时刻确认为真。如果表达式为假，程序将抛出一个`AssertionError`，通常会终止程序并报告一个错误消息。例如，在[Counter.java](Counter.java.html)中，我们可以通过在`increment()`的最后一条语句中添加以下断言来检查计数器永远不会为负：'
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By default, assertions are disabled, but you can enable them from the command
    line by using the `-enableassertions` flag (`-ea` for short). Assertions are for
    debugging only; your program should not rely on assertions for normal operation
    since they may be disabled.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，断言是禁用的，但您可以通过在命令行中使用`-enableassertions`标志（简写为`-ea`）来启用它们。断言仅用于调试；您的程序不应依赖断言进行正常操作，因为它们可能被禁用。
- en: In the *design-by-contract* model of programming, the designer expresses conditions
    about the behavior of the program using assertions.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*设计契约*编程模型中，设计者使用断言表达关于程序��为的条件。
- en: '*Precondition.* A condition that the client promises to satisfy when calling
    a method.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前置条件.* 客户在调用方法时承诺满足的条件。'
- en: '*Postcondition.* A condition that the implementation promises to achieve when
    returning from a method.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后置条件.* 实现在从方法返回时承诺实现的条件。'
- en: '*Invariant.* A condition that the implementation promises to satisfy while
    the method is executing.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不变量.* 在方法执行时，实现承诺满足的条件。'
- en: Exercises
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Give an implementation of `minus()` for [Vector.java](Vector.java.html) solely
    in terms of the other `Vector` methods, such as `direction()` and `magnitude()`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用其他`Vector`方法（如`direction()`和`magnitude()`）为[Vector.java](Vector.java.html)提供`minus()`的实现。
- en: '*Solution*:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*:'
- en: '[PRE8]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a `toString()` method to [Vector.java](Vector.java.html) that returns the
    vector components, separated by commas, and enclosed in matching parentheses.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[Vector.java](Vector.java.html)添加一个`toString()`方法，返回以逗号分隔的向量分量，并用匹配的括号括起来。
- en: Creative Exercises
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Statistics.** Develop a data type for maintaining statistics for a set of
    real numbers. Provide a method to add data points and methods that return the
    number of points, the mean, the standard deviation, and the variance.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**统计.** 开发一个数据类型，用于维护一组实数的统计信息。提供一个添加数据点的方法和返回点数、均值、标准差和方差的方法。'
- en: $$ \begin{eqnarray*} \bar x &=& \frac{1}{n} \sum_i x_i \\ s^2 &=& \frac{\sum_i
    (x_i - \mu)^2}{n-1} \;\; = \;\; \frac{n \sum_i x_i^2 - (\sum_i x_i)^2}{n(n-1)}
    \end{eqnarray*} $$
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \begin{eqnarray*} \bar x &=& \frac{1}{n} \sum_i x_i \\ s^2 &=& \frac{\sum_i
    (x_i - \mu)^2}{n-1} \;\; = \;\; \frac{n \sum_i x_i^2 - (\sum_i x_i)^2}{n(n-1)}
    \end{eqnarray*} $$
- en: 'Develop two implementations: [OnePass.java](OnePass.java.html) whose instance
    values are the number of points and the sum of the values, and the sum of the
    squares of the values, [TwoPass.java](TwoPass.java.html) that keeps an array containing
    all the points. For simplicity, you may take the maximum number of points in the
    constructor. Your first implementation is likely to be faster and use substantially
    less space, but is also likely to be susceptible to roundoff error.'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开发两种实现：[OnePass.java](OnePass.java.html)，其实例值为点数和值的总和，以及值的平方和，[TwoPass.java](TwoPass.java.html)，它保留一个包含所有点数的数组。为简单起见，您可以在构造函数中取最大点数。您的第一个实现可能会更快，占用的空间也会大大减少，但也可能容易受到舍入误差的影响。
- en: '*Solution*: [StableOnePass.java](StableOnePass.java.html) is a well-engineered
    alternative that is is numerically stable and does not require an array to store
    the elements.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: [StableOnePass.java](StableOnePass.java.html)是一个精心设计的替代方案，它在数值上是稳定的，不需要数组来存储元素。'
- en: $$ \begin{eqnarray*} m_0 &=& 0 \\ s_0 &=& 0 \\ m_n &=& m_{n-1} + \frac{1}{n}
    \; (x_n - m_{n-1}) \\ s_n &=& s_{n-1} + \frac{n-1}{n} \; (x_n - m_{n-1})^2 \\
    \bar x &=& m_n \\ s^2 &=& \frac{1}{n-1} s_n \end{eqnarray*} $$
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \begin{eqnarray*} m_0 &=& 0 \\ s_0 &=& 0 \\ m_n &=& m_{n-1} + \frac{1}{n}
    \; (x_n - m_{n-1}) \\ s_n &=& s_{n-1} + \frac{n-1}{n} \; (x_n - m_{n-1})^2 \\
    \bar x &=& m_n \\ s^2 &=& \frac{1}{n-1} s_n \end{eqnarray*} $$
- en: '**Genome.** Develop a data type to store the genome of an organism. Biologists
    often abstract away the genome to a sequence of nucleotides (A, C, G, or T). The
    data type should support the method `addNucleotide()`, `nucleotideAt()`, as well
    as `isPotentialGene()`. Develop three implementations.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基因组.** 开发一个数据类型来存储生物体的基因组。生物学家经常将基因组抽象为核苷酸序列（A、C、G 或 T）。数据类型应支持方法`addNucleotide()`，`nucleotideAt()`，以及`isPotentialGene()`。开发三种实现。'
- en: Use one instance variable of type `String`, implementing `addCodon()` with string
    concatenation. Each method call takes time proportional to the length of the current
    genome.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个`String`类型的实例变量，使用字符串连接实现`addCodon()`。每次方法调用的时间与当前基因组的长度成正比。
- en: Use an array of characters, doubling the length of the array each time it fills
    up.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符数组，每次填满时将数组长度加倍。
- en: Use a boolean array, using two bits to encode each codon, and doubling the length
    of the array each time it fills up.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔数组，使用两位来编码每个密码子，并在每次填满时将数组长度加倍。
- en: '*Solution*: [StringGenome.java](StringGenome.java.html), [Genome.java](Genome.java.html),
    and [CompactGenome.java](CompactGenome.java.html).'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: [StringGenome.java](StringGenome.java.html), [Genome.java](Genome.java.html),
    和 [CompactGenome.java](CompactGenome.java.html).'
- en: '**Encapsulation.** Is the following class immutable?'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**封装.** 以下类是否是不可变的？'
- en: '[PRE9]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Solution*: No, because Java''s [java.util.Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html)
    is mutable. To correct, make a defensive copy of the date in the constructor and
    make a defensive copy of the date before returning to the client.'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：不行，因为Java的 [java.util.Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html)
    是可变的。要纠正，需要在构造函数中对日期进行防御性拷贝，并在返回给客户端之前对日期进行防御性拷贝。'
- en: '**Date.** Design an implementation of Java''s [java.util.Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html)
    API that is immutable and therefore corrects the defects of the previous exercise.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日期。** 设计一个不可变的Java [java.util.Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html)
    API的实现，从而纠正上一个练习的缺陷。'
- en: '*Partial solution*: [Date.java](Date.java.html).'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案*：[Date.java](Date.java.html)。'
- en: Web Exercises
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: Add methods to [Genome.java](Genome.java.html) to test for equality and return
    the reverse-complemented genome.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [Genome.java](Genome.java.html) 中添加方法来测试相等性并返回反向互补的基因组。
- en: Add methods to [Date.java](Date.java.html) to check which season (Spring, Summer,
    Fall, Winter) or astrological sign (Pisces, Libra, ...) a given date lies. Be
    careful about events that span December to January.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [Date.java](Date.java.html) 中添加方法来检查给定日期属于哪个季节（春季、夏季、秋季、冬季）或星座（双鱼座、天秤座，...）。要注意跨越十二月至一月的事件。
- en: Add a method `daysUntil()` to [Date.java](Date.java.html) that takes a `Date`
    as an argument and returns the number of days between the two dates.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [Date.java](Date.java.html) 中添加一个`daysUntil()`方法，该方法以`Date`作为参数，并返回两个日期之间的天数。
- en: Create an implementation [Date2.java](Date2.java.html) that represents a date
    a single integer that counts the number of days since January 1, 1970. Compare
    to [Date.java](Date.java.html).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现 [Date2.java](Date2.java.html)，它将日期表示为自1970年1月1日以来的天数。与 [Date.java](Date.java.html)
    进行比较。
- en: Create a `Rectangle` ADT that represents a rectangle. Represent a rectangle
    by two points. Include a constructor, a `toString` method, a method for computing
    the area, and a method for drawing using our graphics library.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表矩形的`Rectangle` ADT。通过两个点来表示一个矩形。包括一个构造函数，一个`toString`方法，一个计算面积的方法，以及一个使用我们的图形库绘制的方法。
- en: Repeat the previous exercise, but this time represent a `Rectangle` as the lower
    left endpoint and the width and height.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一个练习，但这次将`Rectangle`表示为左下端点和宽度和高度。
- en: Repeat the previous exercise, but this time represent a `Rectangle` as the center
    and the width and height.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一个练习，但这次将`Rectangle`表示为中心点、宽度和高度。
- en: '**Sparse vector.** Create a data type for sparse vectors. Represent a sparse
    vector by an array of indices (of nonzeros) and a parallel array of the corresponding
    nonzero values. Assume the indices are in ascending order. Implement the dot product
    operation.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稀疏向量。** 创建一个稀疏向量的数据类型。通过非零索引数组和相应的非零值并行数组来表示稀疏向量。假设索引按升序排列。实现点积运算。'
- en: '**Copy constructor.** Only needed if data type is mutable. Otherwise, assignment
    statement works as desired.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拷贝构造函数。** 只有在数据类型是可变的情况下才需要。否则，赋值语句可以按预期工作。'
- en: '[PRE10]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Define an interface [DifferentiableFunction.java](DifferentiableFunction.java.html)
    for twice-differentiable function. Write a class [Sqrt.java](Sqrt.java.html) that
    implements the function f(x) = c - x^2.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为两次可微函数定义一个接口 [DifferentiableFunction.java](DifferentiableFunction.java.html)。编写一个实现函数f(x)
    = c - x^2 的类 [Sqrt.java](Sqrt.java.html)。
- en: Write a program [Newton.java](Newton.java.html) that implements Newton's method
    to find a real root of a sufficiently smooth function, given that you start sufficiently
    close to a root. When method converges, it does so quadratically. Assume that
    it takes a `DifferentiableFunction` as argument.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 [Newton.java](Newton.java.html)，实现牛顿法来找到一个充分光滑函数的实根，假设你从一个足够接近根的地方开始。当方法收敛时，它会呈二次收敛。假设它以`DifferentiableFunction`作为参数。
- en: '**Generating random numbers.** Different methods to generate a random number
    from the standard Gaussian distribution. Here, encapsulation enables us to replace
    one version with another that is more accurate or efficient. Trigonometric method
    is simple, but may be slow due to calling several transcendental functions. More
    importantly, it suffers from numerical stability problems when x1 is close to
    0. Better method is alternate form of Box-Muller method. [reference](http://en.wikipedia.org/wiki/Box-Muller_transform).
    Both methods require two values from a uniform distribution and produce two values
    from the Gaussian distribution with mean 0 and standard deviation 1\. Can save
    work by remembering the second value for the next call. (This is how it is implemented
    in `java.util.Random`.) Their implementation is the polar method of Box-Muller,
    saving the second random number for a subsequent call. (See Knuth, ACP, Section
    3.4.1 Algorithm C.)'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成随机数。** 从标准高斯分布中生成随机数的不同方法。在这里，封装使我们能够用更准确或更有效的方法替换一个版本。三角方法简单，但由于调用多个超越函数可能会很慢。更重要的是，当x1接近0时，它会遇到数值稳定性问题。更好的方法是Box-Muller方法的另一种形式。[参考链接](http://en.wikipedia.org/wiki/Box-Muller_transform)。这两种方法都需要两个来自均匀分布的值，并产生两个均值为0，标准差为1的高斯分布值。可以通过记住第二个值以节省工作量。
    （这就是在`java.util.Random`中实现的方式。）它们的实现是Box-Muller的极坐标方法，保存第二个随机数以供后续调用。（参见Knuth，ACP，第3.4.1节算法C。）'
- en: '**LAX airport shutdown.** On September 14, 2004 Los Angeles airport was [shut
    down](http://msdn.microsoft.com/library/default.asp?url= /library/en-us/sysinfo/base/gettickcount.asp)
    due to software breakdown of a radio system used by air traffic controllers to
    communicate with pilots. The program used a Windows API function call `GetTickCount()`
    which returns the number of milliseconds since the system was last rebooted. The
    value is returned as a 32 bit integer, so after approximately 49.7 days it "wraps
    around." The software developers were aware of the bug, and instituted a policy
    that a technician would reboot the machine every month so that it would never
    exceed 31 days of uptime. Oops. LA Times blamed the technician, but the developers
    are more to blame for shoddy design.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**洛杉矶机场关闭。** 2004年9月14日，洛杉矶机场由于空中交通管制员与飞行员通信的无线电系统软件故障而被关闭。该程序使用了一个Windows
    API函数调用`GetTickCount()`，它返回自系统上次启动以来的毫秒数。该值以32位整数返回，因此大约在49.7天后会"环绕"。软件开发人员意识到了这个错误，并实施了一个政策，即每个月技术人员会重新启动机器，以确保其运行时间不超过31天。糟糕。洛杉矶时报指责了技术人员，但更应该责备开发人员的糟糕设计。'
- en: '**Polar representation of points.** Re-implement the [Point.java](Point.java.html)
    data type using polar coordinates.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**点的极坐标表示。** 使用极坐标重新实现[Point.java](Point.java.html)数据类型。'
- en: '*Solution*: [PointPolar.java](PointPolar.java.html).'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[PointPolar.java](PointPolar.java.html)。'
- en: '**Spherical coordinates.** Represent a point in 3D space using Cartesian coordinates
    \((x, y, z)\) or spherical coordinates \((r, \theta, \phi)\). To convert from
    one to the other, use'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**球坐标系。** 使用笛卡尔坐标\((x, y, z)\)或球坐标\((r, \theta, \phi)\)表示三维空间中的点。要从一个坐标系转换到另一个坐标系，使用以下公式'
- en: $$ \begin{array}{lllllll} r &=& \sqrt{x^2 + y^2 + z^2} &\hspace{.3in} & x &=&
    r \cos \theta \sin \phi \\ \theta &=& \tan^{-1}(y/x) & & y &=& r \sin \theta \sin
    \phi \\ \phi &=& \cos^{-1}(z/r) & & z &=& r \cos \phi \\ \end{array} $$
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \begin{array}{lllllll} r &=& \sqrt{x^2 + y^2 + z^2} &\hspace{.3in} & x &=&
    r \cos \theta \sin \phi \\ \theta &=& \tan^{-1}(y/x) & & y &=& r \sin \theta \sin
    \phi \\ \phi &=& \cos^{-1}(z/r) & & z &=& r \cos \phi \\ \end{array} $$
- en: '**Colors.** Can represent in RGB, CMYK, or HSV formats. Natural to have different
    implementations of same interface.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**颜色。** 可以用RGB、CMYK或HSV格式表示。自然而然地会有相同接口的不同实现。'
- en: '**ZIP codes.** Implement an ADT that represents a USPS ZIP code. Support both
    the original 5 digit format and the newer (but optional) ZIP+4 format.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**邮政编码。** 实现一个表示美国邮政服务ZIP码的ADT。支持原始的5位数字格式和更新的（但可选的）ZIP+4格式。'
