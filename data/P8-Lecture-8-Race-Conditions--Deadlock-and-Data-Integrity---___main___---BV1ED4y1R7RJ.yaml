- en: P8：Lecture 8 Race Conditions, Deadlock and Data Integrity - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P8：讲座8 竞争条件、死锁和数据完整性 - ___main___ - BV1ED4y1R7RJ
- en: All right， so welcome。 We have a presentation which you've probably heard when
    you were in 1Six B or 1Six X and。 1S7 and you're hearing it again。 This is Sonia。
    She is one of the CS198 section leader coordinators and she is going to talk to
    you about section。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎大家。我们有一个介绍，可能你们在1Six B或者1Six X时听过，1S7你们也听过，这次你们还会听到。这是Sonia，她是CS198小组负责人协调员之一，她将向你们介绍小组负责人工作。
- en: leading。 How many section leaders do we have in here？ All right。 A whole bunch
    of you。 So people with your hands up， other people can ask questions of you as
    well。 Feel free to chime in if you have comments about this。 Look， when you were
    in 1Six A。 1Six B or 1Six X， there are these section leaders and they。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 领导。这里有多少位小组负责人？好吧，举手的人有很多。那么，举手的人，其他人也可以向你们提问。如果你有关于此的评论，随时可以插话。看，当你们在1Six A、1Six
    B或者1Six X的时候，那里有这些小组负责人，他们。
- en: were possibly quite important to your life。 It is an awesome opportunity。 I'm
    not going to steal Sonia's thunder， but I think it's a great opportunity to actually。
    give something back to computer science and also improve your own skills。 Trust
    me。 when you teach something， you learn it much better than you do when you're
    just， like in a class。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工作可能对你们的生活非常重要。这是一个很棒的机会。我不想抢Sonia的风头，但我觉得这是一个真正很好的机会，能回馈计算机科学，也能提升你们自己的技能。相信我，当你教别人时，你学得比仅仅上课时要好得多。
- en: All right。 Over to Sonia。 Cool。 So who here has taken a 106 class here at Stanford？
    Nice。 Vast majority。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来是Sonia。很酷。那么这里有多少人参加过斯坦福的106课程？不错，大多数人。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_1.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_1.png)'
- en: Almost everybody。 So a lot of you know what section leaders are。 but they are
    undergraduate TAs who lead， sections。 And for this round of applications。 we're
    looking for people like you who have completed， 106B and X。 So we're looking for
    people from all sorts of different backgrounds。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个人。所以你们大部分都知道小组负责人是什么，但他们是本科助教，负责带领小组。对于这一轮的申请，我们在寻找像你们这样已经完成106B和X课程的人。所以我们欢迎各个不同背景的人申请。
- en: Like if you're a conflict major， great。 We want you。 I guess if you're a CS
    major。 which I'm sure there are lots of you in 110， we also want， you to apply。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是冲突专业的，太好了。我们需要你。应该说，如果你是计算机科学专业的，当然我知道110课上有很多这样的同学，我们同样欢迎你们申请。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_3.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_3.png)'
- en: So do apply。 What do section leaders do？ You teach a 50 minute section。 You
    help students in the lair and teach them like good debugging strategies。 You grade
    assignments。 You hold interactive grading sessions。 So you get lots of one-on-one
    time with your students and you grade things and you get。 paid 17， 15 hours starting
    salary actually next year it'll be $18 an hour starting salary。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请一定要申请。小组负责人做什么呢？你将带领一个50分钟的小组课程。你会帮助学生解决问题，并教他们一些好的调试策略。你还要批改作业，主持互动评分会议。所以你会有大量的与学生一对一的时间，并且批改作业，还能拿到薪水，起薪是17.15美元每小时，实际上明年起薪将会是18美元每小时。
- en: And more of a seniority。 And you get to be part of a really cool community who
    has lots of fun doing things。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的是资历问题。你将成为一个真正酷的社区的一部分，大家在这里做事情都很开心。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_5.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_5.png)'
- en: So time and requirements， you'll need to section lead for two quarters。 So if
    you want to study abroad， that's totally fine。 We're cool with you deferring that。
    Just let us know when you're applying。 And then in your very first quarter。 we
    want you to take CS 198 for three or four years。 And then we're going to Monday
    meetings。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，时间和要求，你们需要担任小组负责人两学期。所以如果你想出国留学，完全没问题。我们很支持你们推迟这个。只要在申请时告诉我们就行。然后在你们的第一学期，我们希望你们修CS
    198，为期三到四年。接下来我们会有周一的会议。
- en: which are every Monday for 30 to 6 p。m。 And attend workshops in the very first
    four weeks that you're a section leader。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 会议时间是每周一，下午3点到6点。并且在你成为小组负责人后的前四周，参加工作坊。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_7.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_7.png)'
- en: Just because we want to get you oriented。 So why section lead？ Well。 teaching
    is the biggest and most valuable way as Chris said to master a subject。 And it
    actually helps you develop a lot of skills that come in use later in life if you。
    want to go into management or if you want to just talk or if you want to be a
    mentor。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以想让你们了解这一点，是为了让你们有个更好的定位。那么，为什么是小组负责人呢？嗯，正如Chris所说，教学是掌握一门学科的最大和最有价值的方式。它实际上还帮助你培养许多将来在生活中派上用场的技能，无论是你想进入管理层，还是想进行公开演讲，或是想成为一名导师。
- en: Teaching is a really great way to hone those skills。 You also get an opportunity
    to work directly with students more so than in other TAShips。 that are available
    to you here at Stanford。 Because you've got these 15 minute interactive grading
    sessions with your students after every。 single assignment， you really get to
    develop a relationship with them and play an important。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 教学是提升这些技能的绝佳方式。你还将有机会直接与学生合作，远超过你在斯坦福其他助教岗位上能获得的机会。因为每次作业后，你都有15分钟与学生进行互动评分，你真的可以与他们建立关系，并在他们的学习过程中扮演重要角色。
- en: role in their education and their love of computer science。 You get to be participating
    in fun events and you also get to join an awesome group of。 people who really
    care about teaching well and teaching CS。 And then leave your mark on campus。
    You can make a significant distance in a student's life。 So keep that in mind。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的教育和对计算机科学的热爱中扮演角色。你可以参加有趣的活动，还可以加入一个非常棒的团队，大家都很关心如何做好教学，尤其是计算机科学的教学。然后在校园里留下你的印记。你能在学生的生活中产生重大影响。所以，请记住这一点。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_9.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_9.png)'
- en: These are some of the fun events that we do。 We dress up and help people debug
    their code and we also eat breakfast。 And then we also have corporate partnerships
    and we do special events just for section， leaders。 So yeah， we cooked things
    at Google and went on to boats in the bay once upon a time。 And also you can be
    like one of these people if you're a section leader。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们举办的一些有趣活动。我们会打扮起来，帮助人们调试代码，同时还一起吃早餐。我们还有企业合作关系，专门为小组负责人举办特别活动。所以，没错，我们曾经在Google做过烹饪活动，还曾乘船游览过海湾。此外，如果你是小组负责人，你也可以成为这些人之一。
- en: All of these were section leaders here at Stanford。 So I encourage you to become
    the next mayor on Zohami。 So the applications are open right now and they are
    due this Thursday at 11。59 PM。 And you can access them at cs198。stanford。edu。
    Any questions？ Awesome。 Great。 We'll apply。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些人曾是斯坦福的小组负责人。所以我鼓励你成为下一个Zohami市长。现在申请已经开放，截止时间是本周四晚上11点59分。你可以在cs198.stanford.edu上申请。有什么问题吗？太棒了。很好。我们会申请。
- en: Hope to see you soon。 Actually， can I add one last thing？
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 希望很快见到你。实际上，我可以再说一件事吗？
- en: If you have applied before in the past and didn't you， you can apply it。 Hope
    to see you soon。 I'd say that we really would love for you to apply again。 And
    in our interview process。 we care about making you better teachers。 So we're happy
    to provide you feedback。 So many section leaders don't get it until they apply
    two or three or four times。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前申请过但没有成功，你可以再次申请。希望很快见到你。我想说，我们真的很希望你再次申请。在我们的面试过程中，我们关注的是帮助你成为更好的老师。所以我们很乐意给你反馈。很多小组负责人直到申请两次、三次甚至四次才成功。
- en: So I encourage you to keep applying and keep asking for feedback if you're interested
    in。 it but it hasn't worked out for you in the past。 Cool。 All right。 Thank you
    so much。 All right。 I think section leaders a great opportunity all around。 And
    like I said。 if you've applied before and didn't get it for some reason， don't
    let。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我鼓励你继续申请并不断寻求反馈，如果你有兴趣，但过去没有成功的话。太棒了。好的，非常感谢。好的，我认为小组领导是一个很棒的机会。如我所说，如果你以前申请过但因某种原因没有成功，不要灰心。
- en: that discourage you too much because many people try lots of time before they
    get it。 And that's the way it goes。 All right。 Thanks， Tony。 Okay。 So how's the
    assignment？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让这些让你太沮丧，因为许多人在成功之前都会尝试很多次。这就是过程。好了，谢谢Tony。好，作业怎么样了？
- en: What are we up to now？ How's assignment three going？ Going all right。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在进展如何？作业三进行得怎么样？还算顺利。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_11.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_11.png)'
- en: It's such a tricky one。 I would say it's probably one of the longer ones， believe
    it or not。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当棘手的问题。我会说这可能是其中一个最长的，信不信由你。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_13.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_13.png)'
- en: There's lots of moving parts to it。 And I promised you I would talk about it
    today。 But I didn't prepare anything to talk about today。 Here's what I'll do。
    I totally blanked that I was going to tell you about this。 The assignment。 Most
    of you。 many of you have already started it。 If you haven't， please do it soon。
    Here's what I'll do。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多部分需要处理。我曾答应你们今天会谈论这个话题，但我今天没有准备任何内容来谈论这个。这样吧，我完全忘记了我本来要告诉你们这件事——作业。你们中的大多数人，很多人已经开始做了。如果还没开始，请尽快做。这样吧，我会做的。
- en: I'll tell you when I get home today， Ally is going to remind me this because
    she's going。 to send me an email anyway and she's going to send me an email about
    that。 Remind me in that to do a little video this afternoon about that。 Okay。
    I'll post it this evening。 Okay。 But anyway， that'll be about the assignment。
    Sorry， I didn't prepare that now。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我等会儿到家会告诉你，Ally会提醒我这件事，因为她会发邮件给我，反正她会发邮件告诉我这件事。提醒我下午做个视频关于这个。好的，我今天晚上会发出去。好的。不过无论如何，那将是关于作业的。抱歉，我现在还没有准备好这个。
- en: And where did this go？
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那这个去哪了？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_15.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_15.png)'
- en: Are the box closed？ It did close。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子关了吗？它关了。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_17.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_17.png)'
- en: All right。 So we are on to we're still talking about signals and signals can
    be tricky。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们继续，我们还是在谈论信号，信号可能很棘手。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_19.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_19.png)'
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_20.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_20.png)'
- en: Okay。 Processes which need with processes when they run with signals tend to
    have lots of race。 conditions and we want to avoid those race conditions。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。进程在运行时需要与信号配合，往往会有很多竞争条件，我们想要避免这些竞争条件。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_22.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_22.png)'
- en: If we can， we have to talk about some of the places those happen， some of the
    times those。 happen and how to actually remove those race conditions or make it
    so that the race conditions。 don't happen because our logic is correct。 So that's
    what we're trying to do。 Speaking of not being correct， last Wednesday I misled
    you a bit and I apologize about that。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我们需要讨论一下这些问题发生的一些地方、发生的时间，以及如何实际上消除这些竞争条件，或者让这些竞争条件不会发生，因为我们的逻辑是正确的。所以这就是我们想要做的。说到不正确，上周三我有点误导了你们，为此我感到抱歉。
- en: One of the CAs was watching the video and goes， "I don't think you were right
    at the。 end there when you said this thing。"， And I went back and thought about
    it and I went， "Oh。 I can see why。"， Yes， that was wrong。 I can see what you're
    talking about。 Here's what I said。 I don't know if you remember this example from
    last week but what we did was we had， my pen。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个CA在看视频时说：“我觉得你在最后说的那句话不对。”我回去想了想，才发现，“哦，我明白为什么了。”是的，那个是错的。我明白你说的意思了。就是我说的这个。我不知道你是否记得上周的这个例子，但我们做的是我们有，我的笔。
- en: is not working again。 Hold on one second。 I'm going to try this one more time。
    This and this。 I swear it was working before。 It might be。 There we go。 Let's
    try that。 So。 the example that we worked on last week was this example where we
    had a SIGCHILD that。 was that we had。 We signaled it and it's a special function
    that we call and this is how the signal handler's。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 又不行了。等一下，我再试一次。这个和这个。我发誓之前它是能用的。可能是。好了，我们试试这个。 所以，上周我们做的例子就是这个例子，我们有一个SIGCHILD信号。就是我们有这个信号，然后是一个我们调用的特殊函数，这就是信号处理函数的工作原理。
- en: work。 We say signal and then the type of signal and then the signal handling
    function。 What I said for this one， this was the one that printed out the job
    list and it said。 we had a problem with it to begin with。 First thing we said，
    "Wait a minute。 Sometimes when we add a job to the job list， it will say job removed
    from the job list before。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 工作。我们说信号，然后是信号的类型，再然后是信号处理函数。对于这个，我说的是那个打印出作业列表的，它说：我们一开始就遇到过问题。我们首先说，“等一下，有时候当我们将一个作业添加到作业列表时，它会说作业在之前已经从作业列表中移除。”
- en: it even gets to job is added to the job list because we've got this specifically，
    because。 we've got this crazy sleep in there。 We're saying before you even add
    it to the job list。 do some other stuff basically sleep。 By the time that wakes
    up。 the parent adds it to the job list after the process has already， ended。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至没有达到作业被添加到作业列表的步骤，因为我们有这段特别的代码，正因为我们在其中加了这个疯狂的睡眠。我们说在你把它添加到作业列表之前，做一些其他事情，基本上就是休眠。等到它醒来时，父进程已经在进程结束后将其添加到了作业列表。
- en: called the signal handler and said that it was removed。 We didn't like that。
    When we have our logic so that a job gets removed from some job list before it
    gets added。 that's not really a good thing。 That just logically doesn't make sense。
    Why？
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不喜欢那样。我们设置的逻辑是，在任务被添加之前，它会从某个任务列表中移除。那样做其实不太好。从逻辑上讲，这不成立。为什么？  '
- en: I didn't break our program because our program wasn't really breakable in that
    sense。 But it doesn't look right and if we had added more to it to actually add
    and remove jobs。 it doesn't make any sense to remove it before it's added。 What
    we did was we said， "Oh， all right。 There's this SIG PROC MASK system call which
    will allow us to block a signal and we in this。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '我没有破坏我们的程序，因为我们的程序在这个意义上根本不可破坏。但它看起来不对，如果我们在程序中添加了更多内容来实际添加和移除任务，在任务被添加之前移除它是没有任何意义的。我们做的是，我们说，“哦，好吧。有这个
    SIG PROC MASK 系统调用，它允许我们屏蔽信号，我们在这里就做了这个。”  '
- en: case we're going to block the set of signals which includes just the child process
    which。 means that that signal handler will not get called until we unblock those。"。
    That's what's happening with this system。 We're basically saying， "Okay， look。
    now we're saying only unblock after we print out our， message in the parent anyway。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '因为我们将会屏蔽一组信号，其中仅包括子进程的信号。这意味着，直到我们解除屏蔽，这个信号处理器才会被调用。"这就是这个系统的运作方式。我们基本上是在说，"好吧，现在我们说，在父进程打印出消息后才解除屏蔽。"  '
- en: after we print out that we've added the job list。"， What I said in lecture the
    other day was， "Hey。 what happens if the child ends up sending， if the child let's
    say sends a message that says。 or the child process does this exec， cvp？"， Where
    is it here？ And in the， let's see。 I'm missing it here。 Oh， you know what？ Yeah，
    here it is。 Done here。 What is this？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们打印出已添加任务列表之后，"我在前几天的讲座中说过，‘嘿，假如子进程最终发送了一个消息，假如子进程做了 exec，cvp 呢？’"，它在哪里？嗯，让我看看。我这里缺少它了。哦，你知道吗？对，这里是。就在这里。这个是什么？  '
- en: What if that process had its own children with the child signal handler to call
    them？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '如果那个进程有自己的子进程并且有子进程的信号处理器呢？  '
- en: What we get this weird job removed from job list when it wasn't even part of
    our program？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '我们为什么会遇到这个奇怪的任务被从任务列表中移除，而它甚至不属于我们的程序呢？  '
- en: And the answer I said was， "Oh， it depends， we would have to check it out and
    we'd have。 to block the signal。"， No， I was wrong on that。 Here's what happens
    and this is actually critical to understanding the actual workings。 of this system。
    When you call exec cvp， your entire program that is already running in that child
    process。 is destroyed。 The new program is what starts running。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '我当时的回答是，“哦，情况取决，我们得检查一下，必须屏蔽信号。”不，我当时说错了。事实是，这实际上对理解这个系统的实际运作非常关键。当你调用 exec
    cvp 时，原本已经在子进程中运行的整个程序会被销毁。新的程序才会开始运行。  '
- en: So there is no longer a signal handler for the actual child process you created
    because。 by the time you do execvp， there are no more functions in that original
    process to begin， with。 So it doesn't really matter that the child has children
    process。 Now。 it does matter for block signals。 The signals get blocked across
    the exec cvp boundary as well。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '所以不再有实际子进程的信号处理器，因为当你执行 execvp 时，原进程中的函数已经不存在了。所以实际上不重要，子进程是否有子进程。现在，屏蔽信号是重要的。这些信号会跨越
    exec cvp 边界被屏蔽。  '
- en: So we do want to remove the signal right。 Let's see。 We want to unblock when
    we go into the child。 So the child， if the child's program did have its own children，
    it wouldn't automatically。 have those children signal blocked。 Does that hopefully
    clear things up a little bit？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '所以我们确实想要移除信号，对吧？让我们看看。我们希望在进入子进程时解除屏蔽信号。这样，如果子进程的程序有自己的子进程，它们的信号就不会被自动屏蔽。这样应该能稍微理清一些事情吧？  '
- en: The big idea is that exec cvp destroys everything in your original program so
    it's not like。 anything in the original program can get called again。 So that's
    what's happening there。 Okay。 All right。 So hang on。 Now this won't clear。 I think
    this tablet is not long for this world。 Hang on a sec。 Clear。 Okay。 We're going
    to do this。 And then clear。 There we go。 Okay。 All right。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '关键思想是，exec cvp 会摧毁你原始程序中的一切，所以原程序中的任何内容都无法再次调用。所以，这就是这里发生的情况。好了。好吧。稍等一下。这台平板电脑快不行了。稍等一会。清除。好。我们来做这个。然后清除。好了。  '
- en: Back to here。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这里。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_24.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_24.png)'
- en: So we're going to keep talking about some signals。 Okay。 The two signal question？
    No？ Yeah。 When you call exec cvp， does that trigger itself？
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将继续讨论一些信号。 好的。 两个信号的问题？ 没有？ 是的。 当你调用 `exec cvp` 时，它会触发自己吗？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_26.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_26.png)'
- en: When you call exec cvp， that does not trigger the significant child。 Oh， and
    this was a good quick。 That's a good point that I forgot to mention。 Somebody
    on Piazza said， "Oh， when exec cvp happens。 you get a whole new process。 No ID
    and all that。 You don't。 It's actually the same process ID that you started with
    in your child。"， Okay。 So to your question。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `exec cvp` 时，它不会触发重要的子进程。 哦，这是一个很好的问题。 这是我忘记提到的一个好点子。 有人在 Piazza 上说，“哦，当
    `exec cvp` 发生时，你会得到一个全新的进程，新的进程 ID 之类的。” 但你不会。 它实际上是你在子进程中启动时使用的相同的进程 ID。 好的。
    所以回答你的问题。
- en: when exec cvp happens， the child is still alive throughout the running， of that
    program。 When that program ends， the child itself ends。 Does that help？
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `exec cvp` 发生时，子进程在程序运行期间仍然是活着的。 当该程序结束时，子进程本身也结束。 这样有帮助吗？
- en: I thought that when you call the thing， it says it doesn't return。 When you
    do exec cvp。 it does not return， but it's still the child process。 And when that
    ends。 that's when your child handler gets called。 Good question。 All right。 So
    the other day I did mention two new kinds of system calls called kill and raise。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我以为当你调用这个时，它说它不会返回。 当你做 `exec cvp` 时，它不会返回，但它仍然是子进程。 当它结束时，才会调用你的子进程处理程序。 好问题。
    好的。 所以前几天我提到了两种新的系统调用，叫做 `kill` 和 `raise`。
- en: Kill is a way to send a signal to another process or your own process， but you
    would use raise。 for that generally。 And you can send all the different signals。
    and that's how you actually do it to notify， the other process that you actually
    are sending it to some signal。 You use the kill command。 Now， unfortunately， because
    of the naming。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill` 是一种向另一个进程或你自己的进程发送信号的方式，但你通常会使用 `raise`。 你可以发送所有不同的信号。 这就是你实际上怎么做的，用来通知另一个进程，你确实向它发送了某个信号。
    你使用 `kill` 命令。 现在，不幸的是，由于命名问题。'
- en: kill is not really named particularly well。 But let me just show you an example
    of how we might do this。 Let's do this first。 Man to kill。 Let's see。 So it's
    these two。 I always get these wrong。 These two handlers right here。 Okay。 And
    these two include Vim test kill dot， say。 actually we'll do test raise， we'll
    send it， to ourselves。 Let's see。 Okay。 That。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill` 的命名其实不是特别好。 但让我给你展示一个我们如何做到的例子。 先做这个。 `Man to kill`。 让我们看看。 所以是这两个。
    我总是搞错这两个。 这两个处理程序就在这里。 好的。 然后这两个包含的 `Vim test kill dot`，假设。 实际上我们会做 `test raise`，我们将它发送给自己。
    让我们看看。 好的。'
- en: And we will also pound include STD I O dot H。 Okay。 Int main。 All right。 Print
    F。 I am about to terminate my own process。 Sad face。 Okay。 And then we are going
    to use the raise command or the raise system call。 The raise system call just
    takes a signal that you want it。 So if we send say kill， that actually。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将包括 `STD I O dot H`。 好的。 `Int main`。 好的。 `Print F`。 我将终止我自己的进程。 伤心的表情。 好的。
    然后我们将使用 `raise` 命令或 `raise` 系统调用。 `raise` 系统调用只需要一个你想要的信号。 所以如果我们发送比如 `kill`，那实际上。
- en: we can say return zero， but we will never get， there。 Then we get there。 This
    will already be terminated。 And that should actually do it。 Let's see。 Make test
    raise。 Okay。 Test raise kill。 All right。 What happened was we sent a signal to
    our own process using the raise system call and。 it just terminated the process。
    Okay。 We could have called it。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说返回零，但我们永远不会到达那里。 然后我们到达那里。 这个将已经被终止。 那应该就可以了。 看看。 `Make test raise`。 好的。
    `Test raise kill`。 好的。 发生的事情是我们使用 `raise` 系统调用向我们自己的进程发送了一个信号。 它只是终止了进程。 好的。 我们本可以调用它。
- en: We could have done other ones as well。 But that one will do that。 We did for
    instance。 let's try a different one。 Sig stop。 I think that might be the one。
    I think that's the one。 Make test raise。 Oh， maybe it's not。 See。 Does it save
    an entire different sig？ Sig？ Did I spell it？
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来也可以做其他的。但是那个就能做到。 比如我们试试另一个。 `Sig stop`。 我想那可能是那个信号。 我想就是那个。 `Make test
    raise`。 哦，可能不是。 看看。 它保存了一个完全不同的信号吗？ `Sig`？ 我拼对了吗？
- en: Oh， it's not s t。 Oh， okay。 Of course。 Of course， I thought maybe they removed
    that。 Oh， too。 Maybe if I spell it right。 How about that？
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，它不是 `s t`。 哦，好吧。 当然。 当然，我以为他们可能删除了那个。 哦，对。 也许如果我拼对了。 怎么样？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_28.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_28.png)'
- en: There we go。 Oh， it's even in red。 Okay。 So， oops。 Make。 Come on。 Ah， faster。
    Sometimes the best lay plans。 Okay。 Test raise。 Okay。 Stop。 And then it actually
    stopped it。 So it is still running as it turns out。 Well， it's not running anymore
    because the program actually。 well， it will when I do this， it will actually say
    go back into it and end immediately。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，搞定。哦，它甚至显示为红色。好的。哦，哎呀。快点。啊，快点。计划赶不上变化。好的。测试抛出。好的。停止。然后它实际上停止了。所以它实际上还是在运行，结果是这样。嗯，它现在不再运行了，因为程序实际上。嗯，当我执行这个命令时，它会实际上说回到程序并立即结束。
- en: But Sig stop pauses your program， right？ And actually you use that for the Python
    program you're using in this week's assignment。 actually does that。 So the Sig
    stop， which you can send to yourself。 pauses your program in temporarily。 I think
    although I think it's a slightly different one that we're using。 Why is it just
    a FG command？ FG。 Good question。 The question is why is it FG continues to program？
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Sig stop会暂停你的程序，对吧？实际上你在本周的作业中使用了这个功能。它实际上就是这么做的。所以，Sig stop，你可以发送给自己，暂时暂停你的程序。我认为，尽管我觉得我们使用的是一个稍微不同的命令。为什么它只是一个FG命令？FG。好问题。问题是，为什么FG继续执行程序？
- en: So once you have a background process， you can actually see all the different
    jobs。 FG puts one of them back in the foreground for you。 FG puts foreground。
    That's where it goes。 Okay。 So if we， if we do test raise again and then it's
    in there， if I type， if I type jobs， I， believe。 yeah， there we go。 Just tells
    you there's one stop job。 I can run the other one too。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，一旦你有了后台进程，你实际上可以看到所有不同的任务。FG会将其中一个任务放回到前台给你。FG放到前台。就是这么做的。好的。所以如果我们再次执行测试抛出，并且它在那里，如果我输入，如果我输入jobs，我，相信。是的，搞定。它告诉你有一个停止的任务。我也可以运行另一个任务。
- en: And then now there's two stop jobs like that。 And so if I put。 I can put one
    one back and then put the other one back and now that just， starts and back up
    again。 Question 10。 Sleep keeps it in the foreground but sleep also put it in
    the background。 Sleep does keep it in the foreground。 So if we types just sleep
    like 10。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后现在有两个类似的停止任务。所以如果我放置，我可以把一个放回去，再把另一个放回去，现在它就会开始并重新启动。第10个问题。Sleep让它保持在前台，但sleep也会把它放到后台。Sleep确实会保持它在前台。所以如果我们输入的是sleep
    10。
- en: it will keep it in the foreground and just not be running。 the program necessarily
    but not give back the problem， not give back the terminal access， to it。 Yeah。
    Good question。 Okay。 Yes。 If you， good question。 So if you。 your question is if
    I'm like the child， my call， SIG stop on the parent does。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它会保持在前台，只是不一定会运行程序，但不会把问题返回给终端，不会给它返回终端访问权限。是的。好问题。好的。是的。如果你，好的问题。那么如果你。你的问题是如果我是子进程，调用SIG
    stop，父进程会怎么做？
- en: the child affect the child or the exact CV。 If you're， no， doesn't affect that
    at all。 Once you have two processes， they can work independently of each other
    almost completely。 Right？
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程会影响子进程还是精确的CV？如果你，嗯，不，不会有任何影响。一旦你有了两个进程，它们几乎可以完全独立地工作。对吧？
- en: If the parent can end first， the child can end first or completely independently
    in that， sense。 Yeah。 That's the， all right。 So that's the， uh， kiss， or the kill
    system call and the， uh。 raise system call and they， just are used to actually
    send these signals。 Okay。 All right。 Let's move on to， uh， some more signal handling
    especially handling things like race conditions。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程可以先结束，子进程也可以先结束，或者在那个意义上它们可以完全独立。是的。这就是，好的。所以这就是，嗯，kill系统调用和，嗯。raise系统调用，它们只是用来发送这些信号的。好的。好了。让我们继续，嗯，更多的信号处理，特别是处理像竞争条件这样的情况。
- en: and another thing called spinning which is what we want to avoid and I will
    show you what。 that means as we get to it。 So remember the job， well， this is
    the program we just looked at。 the job list， uh， program， that we had。 The reason
    we needed the fixed version was to have that， uh。 SIG proc mask blocking our，
    SIG child until the time when we wanted it to actually work。 Okay。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种叫做自旋的东西，我们要避免它，我会在后面展示它意味着什么。所以记住这个任务，嗯，这是我们刚才看的程序。任务列表，嗯，程序，我们使用的。我们需要固定版本的原因是要有那个，嗯。SIG
    proc mask来阻止我们的SIG child，直到我们想让它实际工作的时候。好的。
- en: The SIG， the， the processes， okay， do have some control over SIG child signals。
    Um。 and when you use the signal handling， the parent shouldn't need to do anything
    special。 to like handle children anymore outside of the actual， uh， outside of
    the actual signal， handler。 Okay。 Um， so and by the way， signals when you block
    them， you might think to yourself， oh， that。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SIG信号，进程是可以控制SIG子进程信号的。嗯。当你使用信号处理时，父进程不需要做任何特殊的事情，来处理子进程，除非是实际的信号处理程序。好的。顺便说一下，当你阻塞信号时，你可能会想，“哦，那个……”
- en: sounds draconian and whatever。 It's all about your process。 It's not like you're
    blocking things for other processes。 I mean， unless you exec CVP and so forth。
    but potentially or ostensibly you know what， you're doing when you're writing
    your own program。 Um。 so it does seem somewhat draconian to do this。 Like I'm
    blocking this whole signal from happening。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是专制，什么的。其实都是关于你的进程。这并不像是你在阻塞其他进程的事情。我的意思是，除非你执行了`exec`，等等，但从某种程度上说，你知道你在写自己的程序。所以做这件事似乎有点专制，像是我在阻塞整个信号的发生。
- en: Well， you're writing the program so you get， you get control over that。 Okay。
    All right。 So let's look at， remember the simple shell example and in fact， again，
    you're going to。 write a much more advanced shell， um， that we had。 Here's what
    it looks like。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你在编写程序，所以你对它有控制权。好的。那么，让我们回顾一下，记得简单的Shell示例吗？实际上，你将编写一个更高级的Shell，嗯，这就是它的样子。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_30.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_30.png)'
- en: Okay。 I'll blow this up here。 All right。 So let's see， uh， the simple shell，
    um。 function actually does what it forks off of it。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我放大一下。好的。那么让我们看一下，嗯，简单的Shell函数实际上会做什么，它会从这里分叉出去。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_32.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_32.png)'
- en: Actually， this is， there's other stuff in here too， but it basically forks off
    as code that。 we don't have in there to initialize it man。 Uh， forks off in a
    process that you type in a command for and then if you type the ampersand。 on
    it on the end， it's in the background and so it ends up in the background and
    you get。 your shell prompt back。 If not， we've got this interesting weight PID
    in here for foreground processes actually。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里有其他内容，但基本上它会分叉成一个代码，我们没有在这里初始化。嗯，它会分叉成一个进程，你输入命令，然后如果你在后面加上“&”符号，它就会在后台运行，最终你会返回到命令行提示符。如果没有，我们会看到这个有趣的PID，用于前台进程。
- en: because the shell is waiting for the child to end。 When the child processes
    in the foreground。 the parent process wants to wait for it。 So that's why we have
    the weight PID here。 Okay。 Well。 once we have signal handling， maybe we want to
    change this a little bit。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Shell正在等待子进程结束。当子进程在前台时，父进程希望等待它。所以这就是我们在这里使用`wait PID`的原因。好的。那么，一旦我们有了信号处理，也许我们想要稍微改变一下。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_34.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_34.png)'
- en: Okay。 Because we don't， we haven't had signal handling before。 So we did it
    in this kind of。 this method where we've got， oh， we're going to just wait PID。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为我们之前没有信号处理。所以我们采取了这种方法，我们有，哦，我们只会等待PID。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_36.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_36.png)'
- en: And by the way， when does the background process get cleaned up in this program？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便问一下，后台进程什么时候会在这个程序中被清理？
- en: I'm seeing some head shaking。 Yeah， the background process doesn't get cleaned
    up in this program。 Okay。 So that's kind of an error on our part。 We didn't even
    know how signals work before。 So we didn't have signal handler。 So it was going
    to be impossible to actually do this。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到有人在摇头。是的，这个程序中的后台进程并没有被清理。好的，这就是我们的一部分错误。我们之前甚至不知道信号是如何工作的。所以我们没有信号处理程序。这样做就不可能实现。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_38.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_38.png)'
- en: But you see how there is no weight PID for the background process。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以看到，后台进程并没有等待PID。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_40.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_40.png)'
- en: The background process prints the command that's in the background and then
    it goes back and。 prints another terminal and then it never again cleans up that
    process。 Okay。 Which actually means that it turns out that the， as long as that
    shell is running， that。 process is still not cleaned up。 Okay。 So it's kind of，
    I mean。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 后台进程打印后台的命令，然后它返回，打印另一个终端，然后它再也不会清理这个进程。好吧。这实际上意味着，只要那个 shell 还在运行，那么这个进程就一直没有被清理。好吧。所以它有点，嗯。
- en: it's kind of an error in the sense that it's like not freeing memory。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像一个错误，因为它没有释放内存。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_42.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_42.png)'
- en: that should be free and so forth。 So we want to avoid that if we can。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那应该是免费的，等等。所以如果我们能避免的话，我们想避免这种情况。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_44.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_44.png)'
- en: Okay。 So let's change this。 Okay。 So let's actually look at our simple shell
    program again。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。所以让我们改变这个。好吧。所以让我们实际上再看一下我们的简单 shell 程序。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_46.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_46.png)'
- en: Simple shell dot c。 Okay。 There are， let's see。 Let's see。 Do we have the actual，
    yeah。 This is the original here。 Okay。 And what we're going to do is we are going
    to add a couple things to this。 Okay。 We're going to， actually let me not use
    this one。 Let's do simple shell with redundancy。 Which is a， there we go。 Okay。
    So now we're going to have a reprocess for our simple shell。 Okay。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 shell dot c。好吧。我们来看看。我们来看一下。我们有实际的，嗯，是的。这是原始的。好吧。接下来我们要做的是给这个程序添加一些东西。好吧。我们要，实际上让我不使用这个。让我们做一个带有冗余的简单
    shell。是的，那里就可以。好吧。现在我们将为我们的简单 shell 重新处理。好吧。
- en: And we are going to， actually this is here。 I mean， now， gotten all that in
    there。 Okay。 We are going to change this so that we actually use that signal handler
    in our program。 Okay。 So what we want to do， okay， is we want to do the same basic
    thing as before。 Okay。 We're going to fork。 Okay。 And we are going to， oh， absolutely
    wrong。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做的是，实际上这就是这里。我是说，现在，已经把所有的都加进去了。好吧。我们要改变这个，使得我们实际上在程序中使用那个信号处理器。好吧。所以我们要做的是，嗯，我们要做的事情跟之前一样。好吧。我们要进行
    fork。好吧。然后我们要，哦，完全错了。
- en: We should probably keep track of it。 P-I-D-T-P-I-D equals fork。 Okay。 We're
    going to fork in our process here。 Okay。 If we are the child， okay。 What are we
    going to do？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能应该追踪它。P-I-D-T-P-I-D 等于 fork。好吧。我们将在这里进行进程的 fork。好吧。如果我们是子进程，嗯，我们将怎么做？
- en: We are going to exact CVP， argv0， and argv。 Now by the way， this is not error
    checking。 In fact。 let's do at least a little bit of error checking in here。 In
    other words。 if the exact CVP command fails， which could be just because we typed
    the wrong， command。 that would be bad。 Okay。 But so what we want to do is let's
    just print F， I don't know， %S， command。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将精确获取 CVP，argv0 和 argv。顺便说一下，这里没有进行错误检查。实际上，我们至少做一点错误检查。换句话说，如果精确获取 CVP 命令失败，可能是因为我们输入了错误的命令。那就糟糕了。好吧。所以我们要做的就是，先打印
    F，我不知道，%S，命令。
- en: and then， not found or something like that。 Okay。 And then X at zero and something
    like that。 Thank you。 I need to tell what's going to be asked。 Do I， by the way，
    let's see， argv0。 Do I。 by the way， need to have some if statement in here to
    see whether or not the command， was not found。 Why not？ Because it will never
    get there if exact CVP actually works。 Destroys the entire program。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，未找到或者类似的错误信息。好吧。然后是 X 在零处，类似这样的。谢谢。我需要告诉他们将会问什么问题。顺便说一下，让我们看看，argv0。我需要，顺便问一下，是否需要在这里加一些
    if 语句，看看命令是否没有找到。为什么不呢？因为如果精确获取 CVP 成功了，它将摧毁整个程序，根本不会到达那里。
- en: Okay。 So anyway， so that's that。 All right。 Now we're going to have if is background。
    Okay。 What we're going to do is we're going to just do the same thing as before。
    Print F。 Okay。 %D， %S。 and， okay， come PID command。 Okay。 And we are going to
    do that。 Okay。 And this will get handled by the signal handler， which we haven't
    installed yet。 Okay。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。所以不管怎样，情况就是这样。好了。现在我们有了 if 是后台。好吧。我们要做的就是跟之前一样。打印 F。好吧。%D，%S。然后，好的，进程 ID
    命令。好吧。然后我们将这样做。好吧。这将由信号处理器处理，但我们还没有安装它。好吧。
- en: But what we want to do is if it's not in the background， okay， we want to call
    this other。 function called wait for the background process。 And I'll show you
    how that works in a minute。 Process， PID， and that。 Okay。 And， let's see。 Do I
    need one more in here？ Yep。 Okay。 And so。 so that's that。 Let's install a signal
    handler。 We're going to have a signal handler。 Oh。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们想要做的是，如果它不在后台，好的，我们想要调用另一个函数，叫做等待后台进程。我一会儿会展示它是怎么工作的。进程，PID，以及这个。好的。让我们看看，我需要再加一个吗？嗯。好的。那么，这就是了。让我们安装一个信号处理器。我们将有一个信号处理器。哦。
- en: I guess I didn't put it up here already。 We're going to have a signal handler
    for reap processes。 Okay。 The reap processes signal is going to do the following。
    Okay。 While true。 and things we've done a number of times for these signals。 Okay。
    While true， PID， PID equals wait。 PID， negative one， because we don't know which
    one we're， waiting for。 W no hang。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我没有把它放到上面。我们将有一个信号处理器来回收进程。好的。回收进程的信号将做以下操作。好的。一直循环。我们做了很多次这些信号的操作。好的。一直循环，PID，PID
    等于等待。PID，负一，因为我们不知道我们在等待哪个。W 无挂起。
- en: because we don't want it to actually wait for the return， because we don't like。
    it when it waits long in a signal handler anyway， and we don't have to do this
    anyway。 If PID is less than or equal to zero， break， that means we either have
    it still running。 or something's across still running， or we don't have any left。
    Okay。 And if PID equals， well。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望它实际上等待返回，因为我们不喜欢。它在信号处理器里等太久，而且我们也不必这样做。如果 PID 小于或等于零，跳出循环，这意味着我们要么它还在运行，要么其他进程还在运行，或者我们没有剩下任何进程。好的。如果
    PID 等于，嗯。
- en: we are going to add a new variable， okay， to see which if we have， our child
    process。 Okay。 I'm going to call it FGID。 Okay。 And I'm just going to actually
    reset it to zero。 which is clearing it。 Or a brown process。 Okay。 This product，
    because we have the FPG。 we have to actually make it a global variable。 Okay。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个新变量，好的，来查看我们是否有子进程。好的。我将它命名为 FGID。好的。我将它实际设置为零。这是清除它。或者说是一个后台进程。好的。这个产品，因为我们有
    FPG。我们必须将它设为全局变量。好的。
- en: So we have to do something like static PIDTFG PID， oops， sorry， FG， am I doing
    a PID？ Yeah。 because we do FGPID foreground PID rather。 Okay。 Foreground PID。
    All right。 And we actually will set it equal to zero， and it's got to be global
    because we need a。 way to communicate between our signal handler and our own。
    Yes？ Hang on。 Over。 Thank you。 Right。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们得做一些类似静态 PIDTFG PID， 哎，抱歉， FG，我在做 PID 吗？是的。因为我们做的是 FGPID 前台 PID。好的。前台 PID。没问题。实际上我们会将它设为零，它必须是全局的，因为我们需要一种方式在我们的信号处理器和我们自己的程序之间进行通信。是吗？等一下。结束。谢谢。好的。
- en: There。 We'll get there。 There we go。 Okay。 So anyway， point。 Did I not do it
    right？ Yep。 Oh。 FPGID。 How's that？ Oh my gosh。 I'm losing it today。 Anybody have
    those kind of days？ FPGND， process ID。 That's what it is。 All right。 Oh man。 Okay。
    Thank you for keeping me honest。 Okay。 So anyway。 now what have we done？ We have，
    we've said， okay， we've got this foreground process ID that we have to set in。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 会的。我们会做到的。好吧。总之，重点。是我没有做对吗？嗯。哦。FPGID。这样怎么样？哦天哪。今天我有点失常。有人也有这种日子吗？FPGND，进程 ID。就是它。好了。哦，天哪。谢谢你保持我清醒。好的。那么，接下来我们做了什么？我们已经说了，好吧，我们有这个必须设置的前台进程
    ID。
- en: our， in another function that we are about to create。 Okay。 Let's create a function。
    Static void。 wait for foreground process。 PIDTPID。 Okay。 In here， what we want
    to do is。 let's see if I get this right。 F， G， P， I， D， equals the PID that we
    have。 Okay。 And then while F。 G， P， I， D， equals PID， we're going to do this weird
    thing where we're just。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将创建的另一个函数中。好的。让我们创建一个函数。静态 void。等待前台进程。PIDTPID。好的。在这里，我们想要做的是。让我看看我能不能做对。F，G，P，I，D，等于我们有的
    PID。好的。然后当 F，G，P，I，D 等于 PID 时，我们将做一件奇怪的事情，我们只是。
- en: going to sit here and kind of wait。 Okay。 By waiting。 we're doing this thing
    called spinning as it turns out。 Okay。 So let's actually test this。 But this is
    basically， here's what happens。 Okay。 We're going to， if we're a background process。
    we're just going to let the signal handler， take care of it。 Okay。 When it ends。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在这里坐着，稍微等一下。好的。通过等待，我们其实是在做一种叫做旋转的事情。好的。那么让我们实际上测试一下这个。基本上，事情是这样发生的。好的。如果我们是后台进程，我们就让信号处理器来处理它。好的。等它结束。
- en: If we're the foreground process， we are also going to basically let the， the
    back or。 the process handle。 Yeah。 So， if we're in C++， could you use this to
    do that？
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是前台进程，我们也基本上会让后台或其他进程来处理。是的。那么，如果我们在 C++ 中，能不能用这个来做呢？
- en: I don't believe you even could do that。 You might be able to。 I'm not sure。
    So。 we're using that now， especially because we're in C。 Yeah。 Good question。
    Okay。 All right。 So。 I think that is about it。 Let's see。 At this point， right。
    So let's try it and see what happens。 And make simple shell with redundancy。 Okay。
    All right。 Simple shell with redundancy。 Okay。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认为你能够做到这一点。你可能可以做到。我不确定。所以。我们现在正在使用这个，特别是因为我们在使用C语言。是的。好问题。好的。好。那我想差不多就是这些了。让我们看看。此时，对吧。所以我们试试看看会发生什么。并且创建一个有冗余的简单shell。好的。好的。有冗余的简单shell。好的。
- en: So we can do LS and it gives us back our prompt after that。 We could do LS。
    Let's just make this do up here。 LS。 Ampersand。 Okay。 And it should have put our
    little command down here all the way up the top。 Lots of stuff here。 There it
    is。 It printed out。 Simple。 It printed out the PID that just relaunched and then
    it immediately printed a prompt back。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以做LS，它会在之后给我们返回提示符。我们可以做LS。让我们让它做这个。LS。&。好的。它应该把我们的小命令放在这里，一直放到顶部。这里有很多东西。找到了。它打印出来了。很简单。它打印出了刚刚重新启动的PID，然后立刻打印出了提示符回来。
- en: for us to do that。 Let's do one that's a little more reasonable。 Let's do， if
    we just do sleep 10。 it will sleep for 10 seconds in the foreground。 Okay。 And
    then when the， when the， when the signal。 when the child ends in this case， we
    actually， get the signal hang on。 We can do sleep 10 in the background and then
    now it's sleeping。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们继续操作。让我们做一个更合理的例子。如果我们只做sleep 10，它将在前台睡眠10秒。好的。然后，当，信号，当子进程结束时，在这种情况下，我们实际上会，得到信号，稍等。我们可以在后台做sleep
    10，然后现在它在睡眠中。
- en: And if we type PS actually we can see there's our sleep right there， our sleep
    command right， there。 In the background， we don't have too many issues。 In the
    foreground， well if we do this。 let's do sleep 100。 So it's just going to sleep
    100。 What is our program doing？
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入PS，实际上我们可以看到我们的sleep就在这里，我们的sleep命令就在这里。在后台，我们没有太多问题。在前台，嗯，如果我们这样做。让我们做一下sleep
    100。所以它将睡眠100秒。我们的程序在做什么呢？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_48.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_48.png)'
- en: Let's go back and look at our program here because it's still sleeping by the
    way。 Okay。 Our program has now gone into， let's see。 Whoops， hang on。 Is this
    one in here？ Let's see。 Oh no。 you know what？ I might have jumped。 I might have
    jumped ahead a little bit。 Yeah。 I went to the wrong one。 This is with the race，
    with the race condition。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到这里看看我们的程序，因为顺便提一句，它现在还在睡眠中。好的。我们的程序现在已经进入了，咱们看看。哎呀，稍等一下。这个在这里吗？让我们看看。哦不，你知道吗？我可能跳过了一点。我可能提前跳了一点。是的。我跳到了错误的地方。这个是关于竞态条件的，关于竞态条件的。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_50.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_50.png)'
- en: If， let me， let me go ahead and show you that one here。 In this case。 what's
    happening is we're doing this sleep here， okay， or not sleep this spinning， here，
    okay。 which is happening because we are in the foreground process， the shell is。
    would be the foreground process and the sleep is the foreground process so it's
    got to wait。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，让我，先给你展示一下这个。在这种情况下。发生的事情是我们在做这个睡眠，好的，或者说不是睡眠，是在进行这个旋转，好的。因为我们处于前台进程中，shell是前台进程，而sleep也是前台进程，所以它必须等待。
- en: for that， right？
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，对吧？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_52.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_52.png)'
- en: Now， I think we're still sleeping here， okay， look， yeah， we're still sleeping
    for 100。 If I open up another terminal here and go to the same myth， myth 55，
    all right， and whoops。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想我们还是在睡眠中，好的，看看，是的，我们还是在睡眠100秒。如果我在这里打开另一个终端并进入相同的 myth，myth 55，好的，哎呀。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_54.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_54.png)'
- en: yes， and then type this command called htop。 Notice something up there。 There's
    one process。 this is the htop program， I think I've shown you this before， shows，
    all， maybe I haven't。 shows all the different processors on the computer we're
    running on。 and it shows how much each core is being used。 One of them is 100%。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，然后输入一个叫做htop的命令。注意到上面有什么。那是一个进程。这是htop程序，我想我以前展示过这个，展示了，所有，可能我没有。展示了我们正在运行的计算机上所有不同的处理器。它显示了每个核心的使用情况。其中一个已经达到100%。
- en: the others are like almost nothing。 One of them is 100%， guess whose program
    it is？ Oh， it's simple。 so with redundancy at 100% CPU， which is my program， okay。
    Well， why is that the case？ Well。 it's because it's spinning and it's actually
    sitting in this while loop going， and it finally。 ended by the way， and then now
    it's back to zero when the sleep 100 ended， okay。 Well。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的几乎没有什么。它们中的一个是 100%，猜猜这是哪个程序？哦，很简单。所以，当 CPU 达到 100% 时的冗余是我的程序，好的。那么，为什么会这样？嗯。因为它在旋转，实际上它卡在这个
    while 循环中运行，最终，它结束了，顺便说一下，现在当 sleep 100 结束时，它回到了零，好的。嗯。
- en: why is that bad？ Well， it's bad because unfortunately there's some poor like
    107 students sitting over in。 next to the on a myth machine going， why is my terminal
    like stalled right now， right？
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么那样不好？嗯，那不好，因为不幸的是，有些可怜的像 107 的学生正坐在旁边的一个 Myth 机器前，想着，为什么我的终端现在卡住了，对吧？
- en: Because you're running your 100% CPU thing。 Now， there's eight cores and they're
    not really because there's lots of other cores doing。 other things， but the machine
    might be heating up a little bit more and it's using that core。 that it shouldn't
    be， right？ We shouldn't be able to actually do that， okay。 And the question is
    why？ Like how do we get around that？ We will get to that， okay。 Oh， by the way。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你正在运行 100% CPU 的程序。现在有八个核心，它们实际上没有完全利用，因为还有很多其他核心在做其他事情，但机器可能会变热一点，使用了不应该使用的核心，对吧？我们本不应该这样做，好的。那么问题是为什么？我们该如何避免这种情况？我们会解决这个问题的，好的。哦，顺便说一下。
- en: you can run， I'll have to install Htop。 You can't run it。 I installed it locally
    from my own machine， and I'll install it and send you guys an email。 about how
    to run that， okay。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行，我需要安装 Htop。你不能运行它。我从我的机器上本地安装了它，我会安装并发送一封电子邮件给你们，关于如何运行它，好的。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_56.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_56.png)'
- en: The original one here that I skipped， okay， looks like this， this is if we wanted
    to remove。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳过的原始版本，看起来是这样的，如果我们想移除它的话。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_58.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_58.png)'
- en: all the， or reap all the processes， okay， with this strange， with this extra
    weight， PID in here。 okay。 So this is kind of what we had before， all right。 We
    had this before where instead of。 or now we're actually capturing the child process，
    okay。 This gets reaped up here， okay， and the。 like it always， or like it would
    because we're， using the signal handler。 But down here。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的，或者回收所有进程，好的，带着这个奇怪的，额外的 weight PID 在这里。好的。这是我们之前的情况，好吧。我们之前是这样做的，而现在我们实际上在捕获子进程，好的。这个在这里被回收，好的，像往常一样，或者像我们使用信号处理程序时那样。但在这里。
- en: we have this strange like situation where we're calling weight PID without W-No，
    hang。 which means this is going to sit here and wait for the child to end， but
    we're handling。 it up in the reap processes。 In fact， that happens first。 The
    signal handler will get called immediately， handle the signal， it will return
    the correct。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这种奇怪的情况，我们在没有 W-No 的情况下调用 weight PID，等等。这意味着它将会在这里等待子进程结束，但我们在回收进程时已经处理了它。事实上，这个过程会先发生。信号处理程序会立即被调用，处理信号，它会返回正确的结果。
- en: PID for the child process。 And then the parent， which is down here in weight
    PID。 actually the weight PID called down， here finishes with an error that says
    there are no more children left。 Isn't that a little strange？ Let me rephrase
    it again。 Down here。 we have said if the child is the foreground， we want to wait
    for it to end。 But instead of letting。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程的 PID。然后是父进程，它在这里通过 weight PID 调用，实际上 weight PID 会在这里完成并报错，提示没有更多的子进程了。这是不是有点奇怪？让我再说一遍。这里我们说，如果子进程是前台进程，我们想等待它结束。但我们并没有让。
- en: well， we're letting the signal handler clean up the weight PID， clean up the
    child。 and then this one is getting kind of redundant because it actually gets。
    called after the child handler cleans it up。 And then this one happens and you
    go， oh。 that seems a little logically on。 And you're like， no， this one's going
    to fail。 Now it works。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们让信号处理程序清理 weight PID，清理子进程。然后这个就变得有点多余了，因为它实际上会在子进程处理完后被调用。然后这个问题出现了，你会觉得，哦，这看起来有点不合逻辑。你会想，不，这个会失败。现在它工作了。
- en: but we'd like to do it a little bit better， which is why we kind of handled。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们希望做得更好，这也是我们处理的原因。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_60.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_60.png)'
- en: the previous， or we kind of did it the other way。 What questions do you have
    on this one for a sec？
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的，或者我们有点做错了方向。你对此有什么问题吗？
- en: Spinning is bad。 I'll show you what the， yeah， I jumped ahead and we did the
    spinning one first。 But the spinning is not good because it's a really tight，
    I'll show you what the spinning。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 自旋是坏的。我会给你看看，嗯，我提前跳过了，我们先做了自旋的那个。但自旋不好，因为它是一个非常紧密的循环，我会给你看看自旋是怎样的。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_62.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_62.png)'
- en: one does。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个做的事情。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_64.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_64.png)'
- en: And right here， what's happening here？ It's basically checking this global variable
    FGPID。 And if the entire time the child process is running， they are not the same
    because we。 set it equal to the， we set FGPID equal to zero and then the PID is
    the PID for the process。 And it just does this while loop again and again and
    again and again and again and again。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里发生了什么？它基本上是在检查这个全局变量FGPID。如果子进程在运行期间，它们的值始终不相同，因为我们把它设置为零，然后PID就是该进程的PID。它就是这样一次又一次地运行这个while循环。
- en: and that's wasting processing time。 Because it's thinking it's trying to do
    something and the only reason the compiler actually allows。 this to happen is
    because we have a global variable in there。 Otherwise the compiler would go， wait。
    this function is not changing it。 How can it ever not be one thing and it will
    just do it once。 So turn that while we're in an if statement and then not even
    run the way we want。 If you're in 107。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就浪费了处理时间。因为它认为自己在做某件事，而编译器之所以允许这种情况发生，是因为我们有一个全局变量在这里。否则，编译器会认为，等一下，这个函数并没有改变它。那它怎么可能不是一个固定的值呢？所以编译器只会执行一次。如果我们把它放在if语句里，甚至不会按我们希望的那样运行。如果你在107。
- en: if you took 107E you'd know all about that and we can deal with this， it， actually
    compilers says。 oh global variables， I don't optimize for those。 Does that answer
    your question about what spinning is？
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上过107E课程，你就知道这一切了，编译器会说，哦，全局变量，我不会对这些进行优化。这回答了你关于自旋是什么的问题吗？
- en: It's this tight little loop that's doing stuff that doesn't do any good for
    us。 We'd rather the process be off the process or altogether and have the kernel
    wait like。 make it actually do what it should be doing。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个紧密的小循环，它做了一些对我们没有帮助的事情。我们宁愿进程结束，或者完全结束，让内核等待，就像。让它真正做应该做的事。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_66.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_66.png)'
- en: Okay。 So that's that。 To be this other， to the previous one that I skipped here。
    with this one where we have。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，明白了。那么接下来是我跳过的那个，之前的那个。这里是这个，我们有。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_68.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_68.png)'
- en: this little wait PID， we definitely want to not have that wait PID happen once。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的wait PID，我们确实不希望它只发生一次。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_70.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_70.png)'
- en: We want it to happen or twice。 We want it to happen just once and let the signal
    handler take care of all of it。 Question。 You do not have to put volatile before
    the global variable。 Good question。 And if you've never heard about volatile，
    it basically just means that， oh， this variable。 is special， don't optimize it
    out because you don't know what's going on with it。 But no。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望它发生一次或两次。我们希望它只发生一次，然后让信号处理程序处理所有的事情。问题。你不需要在全局变量前加volatile。好问题。如果你从未听说过volatile，它基本上意味着，这个变量很特殊，不要优化掉它，因为你不知道它会发生什么。但并不需要。
- en: you don't need to for global variable， at least for this compiler reason。 Yeah。
    Okay。 So other questions on this one。 You get why we don't like to have wait PID
    in two places。 By the way， last quarter we asked a midterm exam question where
    the students could， if。 they wanted to， put the wait PID in two places and we
    took points off。 So be careful。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局变量，你不需要，至少在这个编译器的情况下，不需要。好的。那么对这个有其他问题吗？你明白为什么我们不希望在两个地方都有wait PID吗？顺便提一下，上个学期我们在期中考试时有一个问题，学生如果愿意的话，可以把wait
    PID放在两个地方，我们会扣分。所以要小心。
- en: You can do it like we just showed you before where there's one wait PID。 I'll
    show you how to get rid of that race condition in a second。 Okay。 But here's the
    race condition one。 What's nice about this？
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像我们之前展示的那样，只有一个wait PID。我会在稍后展示如何消除那个竞争条件。好的，但这里是竞争条件的例子。这个有什么好处呢？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_72.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_72.png)'
- en: Well， okay， we're not actually doing any more wait PID。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们其实并没有再做任何wait PID。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_74.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_74.png)'
- en: In fact， wait for foreground process。 The wait for foreground process function
    does not have any wait PID in it。 It's got this strange spinning loop which we
    want to try to avoid。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，等待前台进程。等待前台进程函数中没有任何等待PID的内容。它有一个奇怪的旋转循环，我们希望避免这个问题。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_76.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_76.png)'
- en: But all of the children do get handled up here。 Now， more critically。 we actually
    have a bigger bug than the spin。 The spin isn't going to do anything except make
    your computer warm up a little more。 make the fans come on and make like your
    computer have less of a long lifespan because。 it's doing more work。 Right？ That's
    not the biggest deal in the world。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但是所有的子进程都在这里被处理了。现在，更关键的是，我们实际上有一个比旋转更严重的错误。旋转并不会做任何事，除了让你的电脑稍微变热，让风扇启动，并使得你的电脑寿命变短，因为它做了更多的工作，对吧？这不是世界上最大的事情。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_78.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_78.png)'
- en: The biggest deal in the world is there's an actual race condition in here。 Okay？
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上最大的事情是这里确实存在一个实际的竞争条件。明白了吗？
- en: Anybody see where the race condition might be？
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有人看到竞争条件可能出现在哪里吗？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_80.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_80.png)'
- en: Race conditions happen when you're doing something where like you're forking
    and various things。 can happen before other things。 What do you think？ Anybody
    see a race condition here？ Yeah。 Yeah。 Yeah。 Yeah。 Yeah。 Yeah。 Yeah。 You're setting
    up the FBAG F in the second hand。 And you're checking it in wait for foreground
    process。 Why is that a race condition？
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件发生在你执行一些操作时，比如你在进行分叉，许多事情可能会在其他事情之前发生。你怎么看？有人看出这里有竞争条件吗？是的，是的，是的，是的，是的，是的，是的。你在第二手中设置FBAG
    F，然后在等待前台进程时检查它。为什么这是一个竞争条件？
- en: What could happen first？ Like what could happen here？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 什么会先发生？像这里会发生什么？
- en: Let's think about the two different possibilities。 So you have an idea？ Go ahead。
    Yeah。 The while up is not going to ever end， right？ If you have a slightly off。
    slightly like interesting situation here。 Okay。 So let's walk through this。 F
    we fork。 Okay。 And then we exact CVP。 What if that was really fast？
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两种不同的可能性。你有个想法吗？去吧。是的。这个while循环永远不会结束，对吧？如果这里有一个稍微不正常的、稍微有趣的情况。好吧，让我们一起走一遍这个过程。F我们分叉。好吧，然后我们执行CVP。如果这真的很快怎么办？
- en: We did something that was super duper fast and the child ended。 Okay。 Well。
    we would get up here into reaper process。 Let's pretend that before we ever even
    get to wait for foreground process。 Okay。 We actually go and immediately the child
    ends and we go up here and we reap the process。 Okay。 So what happens？ Well， it
    goes and it says， all right， well， let's see。 In this case actually。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一件超级快的事情，子进程结束了。好吧。那么，我们就会来到回收进程的步骤。假设我们甚至在等待前台进程之前就进入了这个步骤。好吧，我们实际上去执行并且立刻结束了子进程，然后我们回收了这个进程。那么会发生什么呢？好吧，它会去执行，好的，那么让我们看看。在这个情况下，实际上会发生什么。
- en: depending on what the previous PID would be， it wouldn't actually， matter。 So
    I guess it doesn't matter if it doesn't immediately。 But what happens if it doesn't
    here？
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的PID是什么，其实并不重要。所以我猜如果它不立即发生也无所谓。但是如果它不在这里发生会怎样？
- en: And this is what you were saying。 If it doesn't right after this line right
    here。 So this line right here， okay， sets F， P， or F。 Let's see。 Is it going to
    be before that or after？
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你说的。如果它没有在这一行之后立刻执行。那么这行代码，好的，设置了F，P，或者F。我们看看，是在那之前还是之后？
- en: I'm getting this mixed up now。 It is。 This is why race is just a hard。 It's
    always tough to remember exactly where it is。 If FGPID is set to PID and then
    FGPID equals here， right。 If the signal handler was called before that and gets
    down here and sets the FPGID to zero。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在有点混乱了。这就是为什么竞争条件很难处理。记住具体位置总是很难。如果FGPID被设置为PID，然后FGPID在这里等于，好的。如果信号处理程序在那之前被调用，并且到达这里并将FGPID设置为零。
- en: at this point we would then set FGPID to PID and then this while it would never
    end because。 we would never get this set to zero again。 That's the issue。 Okay。
    So basically we're saying that there's the race condition。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们将FGPID设置为PID，然后这个while循环将永远不会结束，因为我们永远无法将其重新设置为零。这就是问题所在。好的。所以基本上我们在说这里存在一个竞争条件。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_82.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_82.png)'
- en: Let me see。 Let me read it off here。 It's probably easier to hear。 If the foreground
    process finishes and reprocesses is invoked before normal execution flow updates。
    FGPID。 If that happens， this is just going to spin forever。 So again。 we could
    end up here because the child process has already been reaped basically。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我看看。让我读一下这里。听起来可能更容易理解。如果前台进程结束，而重新处理被调用在正常执行流程更新FGPID之前。如果发生这种情况，它将永远循环。因此，我们可能会遇到这种情况，因为子进程已经被收割了。
- en: between this line and or right before this line。 Right before this line。 The
    child process gets reaped。 It changes the PID to zero and then we updated here
    going to this while loop no more jobs。 to actually reap。 Right。 So that's probably
    that's the issue right there。 That would be a bad race condition to have。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行和这一行之间，或者就在这一行之前。就在这一行之前。子进程被收割。它将PID改为零，然后我们更新这里进入这个while循环，不再有作业。其实是要进行收割。对吧。所以问题应该出在这里。那应该是一个很糟糕的竞争条件。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_84.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_84.png)'
- en: So how do we deal with this race condition？ Okay。 What we want to do is we want
    to actually remove that race condition using a different type。 of actually before
    we even do that。 Let's actually， let's actually， yeah。 We want to。 Yes。 We'll
    do this one。 We'll do this one right now。 This is where we're going to block the
    child appropriately like we did before so that we。 don't actually need to so we
    don't actually have that race condition at all。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何处理这个竞争条件呢？好的。我们想要做的是，实际上我们想要使用一种不同的方法来消除这个竞争条件。事实上，在我们做这个之前。让我们实际做这个，嗯。我们要做的就是。好的。我们现在就做这个。这是我们将正确阻塞子进程信号的地方，就像之前那样，以便我们不需要，实际上我们完全避免了这个竞争条件。
- en: Just like what we did kind of before。 Okay。 So let's see。 Let's do it the same
    one in here again。 Oh， actually let's do it in different here。 Let's do it in
    simple shell with just leave the spin for now because that's not actually。 the
    most important one。 Okay。 We'll leave the spin in there now and we will reprocesses
    is not going to change。 Okay。 What we need to do down here is we need to block
    the signals like we said before。 In fact。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样。好的。让我们看看。我们在这里再做一次。哦，实际上让我们换个地方做。在简单的shell中就做，暂时保留旋转，因为这并不是最重要的部分。好的。我们现在保留旋转，我们会重新处理，不会改变。好的。我们需要在这里做的是，如之前所说，阻塞信号。事实上。
- en: we're going to have instead of doing the blocking like one line at a time where。
    to set up the empty set and then set it to be or actually declare the signal set
    and then。 set it the empty set and so forth。 Let's have little functions that
    do that。 I'll show you those functions in a minute。 Okay。 So we are going to do
    this where。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再像以前那样逐行阻塞信号，而是设置一个空的信号集，然后设置它为空集合，等等。我们会有一些小的函数来完成这些操作。我稍后会向你展示这些函数。好的。所以我们将做这个。
- en: We are going to block the signals。 Okay。 Right after we get right before we
    do the fork。 Okay。 Let's block the child signal。 Okay。 All right。 There's a function
    that's going to do this。 I'll show you that in a second。 Okay。 We're going to
    block before we fork。 So therefore， the child。 the signal handler can't get called
    in the parent process while， the signal is blocked。 Okay。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将阻塞信号。好的。在我们执行分叉之前。好的。让我们阻塞子进程信号。好的。这里有一个函数将会完成这个操作。我会在稍后展示给你。好的。我们将分叉之前进行阻塞。这样一来，在父进程中，信号处理程序就不能在信号被阻塞时被调用了。好的。
- en: All right。 Then we are going to fork。 If the PID is zero， it's the child。 We
    don't care if that signals blocked。 In fact， we want it to not be blocked。 So
    we're going to call unblocked SIG child which is the other function that we're
    going。 to show you in a second。 Okay。 And then we are going to also unblock it
    if it is a background process because we don't。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们接下来要进行分叉。如果PID是零，那么就是子进程。我们不在乎信号是否被阻塞。事实上，我们希望它不被阻塞。所以我们将调用未阻塞的SIG子进程，这是我们马上要展示的另一个函数。好的。然后，如果它是后台进程，我们还会解除它的阻塞，因为我们不想。
- en: care about like there's no need to worry about the actual blocking there。 That's
    not where the problem is。 Okay。 It was the foreground process that we had the
    problem。 Okay。 Unblock SIG child here。 Okay。 It's a background process or the
    background process。 So we don't。 they're not going to be that issue。 Okay。 And
    then we've got wait for foreground process。 Well。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心实际的阻塞问题。问题不在于这里。好的。是前台进程出了问题。好的。解除SIG子进程的阻塞。好的。是后台进程或者背景进程。所以我们不需要担心。它们不会出现那个问题。好的。然后我们有等待前台进程。嗯。
- en: let's look at wait for foreground process。 It's after we do the setting here
    where we want to unblock the SIG child again。 This should now like we're only
    lifting this after FGPID is set。 Okay。 That's what's happening here。 We've now
    got the blocking happening until the point where we don't need it anymore。 Now
    we can't get the， we won't have that raised condition。 Yes。 So when we。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看等待前台进程。就是在我们在这里设置之后，我们想要再次解除SIG子进程的阻塞。现在看起来我们只是在FGPID设置后才解除阻塞。好的。这里发生的就是这个情况。我们现在在不再需要阻塞的地方解除了阻塞。现在我们不会再出现那个竞态条件了。是的。我们就是这样做的。
- en: before we had the blocking of the blocking and FGPID is， is it all？ Uh huh。
    Which is how that people are narrow in the first place。 How can like we ever wait
    for the condition on this before we set it to FGPID？ Let's see。 Your question
    is how do we actually race condition on it here because， well， let's see。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行阻塞之前，阻塞和FGPID的设置，是全部吗？嗯嗯。那就是人们一开始为什么会变得很狭隘。我们怎么能在设置FGPID之前，等到这个条件呢？让我们看看。你的问题是，我们到底是如何在这里引发竞态条件的，因为，嗯，看看吧。
- en: When we are doing。 So this is in here until we call wait for foreground process。
    And then if people get a wait for it。 And then， because it'll never be。 Right。
    So what happens when。 what's that？ Sorry。 Say again。 When it。 When we first call
    it FGPID is zero。 And then it's a little bit of a little bit of a little bit of
    a little bit of a little bit。 Right。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在做的时候。所以这里一直到我们调用等待前台进程。如果有人等待它。那么，因为它永远不会被满足。对吧。那么，发生了什么呢？那是什么？抱歉，再说一遍。那是怎样的？当我们第一次调用时，FGPID是零。然后它会变成一小段时间，一点点的变化。对吧？
- en: And then we call it a foreground process。 Right。 If the child leaves partially
    before that。 how do we have a rate of interest？ Right。 That is a good question。
    The question is when do we。 or how do we actually have the race condition in there
    at all？ Let me check one thing here。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用它作为前台进程。对吧。如果子进程在之前部分退出。我们怎么会有竞态条件呢？对吧。这是个好问题。问题是，我们什么时候会有竞态条件呢？或者我们怎么在这里引发竞态条件？让我检查一下。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_86.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_86.png)'
- en: I'm just making sure I don't， I didn't miss setting it。 Actually。 let's go back
    up in here and look again。 I think that's actually a good question。 Hang on。 Okay。
    We are not setting it there， are we？ Oh， and the parent we're setting it， we're
    setting PID here。 Right。 We're setting the PID here。 Right。 Okay。 And then FGPID
    is still there。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是确保我没有错过设置它。实际上，让我们再回头看一遍。我觉得这是个好问题。等一下。我们没有在这里设置它，是吗？哦，我们在父进程那里设置了，它在这里设置了PID。对吧。我们在这里设置了PID。对吧。好的。然后FGPID仍然在那里。
- en: Let me get back to you on that。 I know this is a race condition。 You're right。
    There's either one line missing or I'm not making it through quite correctly。
    Good catch on that。 Yep。 I think that if you want to bring position occurs because
    of these processes， signal handler。 the ability to pull points。 So even though
    that different doesn't execute like designing a player again。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再回头检查一下。我知道这是一个竞态条件。你说得对。可能是漏掉了一行，或者我没完全正确地理解。不错，发现得好。嗯。我认为如果你想指出是由于这些进程、信号处理程序的能力来触发的。所以即使它不同，也不能像设计玩家一样再次执行。
- en: Google never， says to zero after the end。 Right。 Good point。 Okay。 So here's
    the answer。 Good answer over there。 Okay。 The idea gets， or reprocesses gets called
    once when the child ends。 Okay。 All right。 Let's assume that the， let's assume
    that FGPID is still zero。 Right。 Well。 it's not going to reset it。 It doesn't
    actually， it's already， FGPID is already zero。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Google永远不会，结束后设置为零。对。好点子。好的。这里是答案。很好的答案。好的。这个想法是，当子进程结束时，重处理会被调用一次。好的。好的。让我们假设FGPID仍然是零。对吧。嗯。它不会重置它。实际上，FGPID已经是零了。
- en: So this is going to end。 Okay。 If that ends and then we set it here and then
    we do this while， well。 it's already ended， and then that's where it is。 Yeah。
    Thank you for that clarification。 Yeah。 The race condition is in the case where
    we're waiting for the foreground process and it's， already。 it's already happened
    that the child is finished。 It was so fast that the child finished and then all
    of a sudden we're waiting。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就要结束了。好吧。如果结束了，我们在这里设置它，然后再执行while循环，实际上它已经结束了，然后就是这样。是的，谢谢你的澄清。是的。竞态条件发生在我们等待前台进程时，而子进程已经结束。它的速度非常快，子进程结束了，突然间我们还在等待。
- en: We're not doing that。 Yeah。 Good call。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不这么做。是的。好判断。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_88.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_88.png)'
- en: Good call。 Now， why does this fix the situation？ Okay。 This fixes the situation。
    This is the one that I just typed up here。 This fixes the situation because we're
    not actually allowing this。 wait the child handler， to get caught until after
    the actual FGPID sets equal to PID。 In which case it will get unset by the child
    handler and then we will go out of the while。 Yes。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 好判断。现在，为什么这样可以解决问题？好吧。这样就解决了问题。这就是我刚才在这里输入的内容。这样解决问题是因为我们实际上没有允许这个。等待子进程处理器，直到实际的FGPID设置为PID之后才会被捕获。那时，它会被子进程处理器重置，然后我们将跳出while循环。是的。
- en: Question。 Do you imagine a blocking works so that the child process is pretty
    much finished but then。 you can kind of place this holding on sending out the
    signal？ Yes。 Good question。 How does blocking work？ Does the child process just
    wait around if it can't send the signal？
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 问题。你认为阻塞是怎么工作的？也就是说，子进程几乎完成了，但你可以保持信号不发送吗？是的。好问题。阻塞是如何工作的？如果子进程不能发送信号，它会一直等吗？
- en: It's the kernel that's sending the signal and the kernel knows that the child
    process， ends。 It wants to send a signal to your parent process but your parent
    process says I'm not accepting。 that signal now so the kernel will just wait until
    it gets on block and then send the signal。 The child finishes and doesn't and
    it's fine。 It just hasn't gotten cleaned up yet but the child is done and then
    eventually the parent。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 是内核在发送信号，内核知道子进程已经结束。它想发送信号给父进程，但父进程表示现在不接受信号，所以内核会等到信号解除阻塞后再发送。子进程完成了，不影响，一切正常。只是还没清理完，但子进程已经结束，最后父进程也会处理。
- en: says now you can send the signal and then that's when the kernel says okay here's
    your。 signal immediately at that point。 Good questions。 All right。 Stuff is tricky。
    Other questions on this one？ Let's get real。 Oh here's those two signals or those
    two functions actually there's three functions here。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 他说现在你可以发送信号了，这时内核就会说好吧，马上就给你信号。好问题。好了，事情确实很复杂。还有其他问题吗？我们开始讨论更具体的内容吧。哦，这里是那两个信号，或者说其实有三个函数。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_90.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_90.png)'
- en: You can do toggle SIGCHILD block which is a little more advanced or you can
    and this one。 we are calling from block SIGCHILD and we are calling from block
    SIGCHILD。 Okay。 What is it doing？
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用切换SIGCHILD屏蔽，这有点更复杂，或者你也可以像这样，调用解除屏蔽SIGCHILD。好吧。它在做什么？
- en: It's setting the signal set to some mask or setting it's creating it and then
    it's emptying。 it so it's basically initializing it and then we are adding the
    mask itself。 We're adding SIGCHILD to the mask by doing add set and then we are
    either blocking or。 unblocking depending on how we call this function the signal。
    That's it。 Yeah。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它设置信号集为某个屏蔽，或者在创建信号集后再清空它。基本上就是初始化信号集，然后我们添加屏蔽。我们通过添加SIGCHILD到屏蔽中来实现，之后根据调用该函数的方式，信号可能被阻塞或解除阻塞。就这样。是的。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_92.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_92.png)'
- en: Why do we call block SIGCHILD before we fork？ Are you saying we could call it
    after we fork？ Yeah。 This is a good question。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在fork之前调用阻塞SIGCHILD？你是说我们可以在fork之后再调用它吗？是的，这是个好问题。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_94.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_94.png)'
- en: We probably could do this。 Well no we can't actually it turns out we can't。
    Here's what happens。 Remember we're talking about a race condition here that could
    happen really fast。 If we wait to block down like after the in the parent yes
    the parent will be the only。 thing that gets blocked but it might already be too
    late。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以这样做。不过不行，实际上我们做不到。发生了什么呢？记住，我们这里讨论的是一个可能发生非常迅速的竞争条件。如果我们等待阻塞，比如在父进程中，父进程会是唯一被阻塞的。但是可能已经太晚了。
- en: The child might have already ended and called the signal and the signal hand
    or sent the。 signal handler happened。 Yeah。 So we have to block before even fork
    because we don't want the child to end before we can。 allow the parent to be ready
    for it。 Good question。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程可能已经结束并调用了信号，或者信号处理程序已经执行了。是的。所以我们必须在分叉之前就进行阻塞，因为我们不希望子进程在我们准备好之前就结束。好问题。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_96.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_96.png)'
- en: Got a very good question on that。 Any others on this one？ Okay。 Let's take care
    of that spinning issue that we had。 So the race condition is gone。 We want to
    do the unblocking in the child because we don't like having that signal block。
    in the child but we already set it in before we fork so it is set。 Let's unblock
    it。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有个非常好的问题。还有其他问题吗？好的。让我们处理我们之前遇到的旋转问题。所以竞争条件消失了。我们想在子进程中解除阻塞，因为我们不希望信号被阻塞在子进程中，但我们已经在分叉之前设置了它，因此它已被设置。现在让我们解除阻塞。
- en: Then we still need to deal with this spinning。 We could do something like this。
    We could say while FGPID equals PCCLE SPEDI sleep or micro sleep as this one is
    called， for 100。000 microseconds。 Then that would actually work okay。 I believe
    micro sleep actually does not wake up when a signal happens。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们仍然需要处理这个旋转。我们可以做类似这样的操作。我们可以说，当FGPID等于PCCLE SPEDI时，休眠或微休眠（如这个名称所示），持续100,000微秒。这样应该就能正常工作。我相信微休眠实际上在信号发生时不会唤醒。
- en: That would kind of not be the best thing anyway but we would just wait and then
    the。 child would end and then eventually sleep would wake up and we go， "Oh， we
    changed anything。 and then we do that。"， The sleep at least takes it off the processor。
    So that would work。 It's just not particularly elegant。 It would work though。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那可能不是最好的方法，但我们可以等待，然后子进程结束，最终休眠会唤醒，然后我们说，“哦，我们没有做任何更改。”然后我们执行这个操作。至少休眠会让它从处理器上移开。所以那样可以工作，只是它不特别优雅，但它确实能工作。
- en: So we really want to keep the OS like the OS can figure out when our child process
    ends。 So we might as well utilize that。 What else could we do？
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们确实想让操作系统来处理，操作系统可以判断我们的子进程何时结束。所以我们不妨利用这一点。我们还能做些什么呢？
- en: There is a pause function which actually would also have， might work。 The pause
    function forces the process to sleep until some unblock signal arrives。 Well，
    that's nice。 This says， "Okay， so now we are going to just wait until an unblock
    signal arrives。"。 The problem here though is that we have a situation， another
    situation where we have。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个暂停函数，它实际上也可能有效。暂停函数强制进程睡眠，直到收到某个解除阻塞的信号。嗯，这很好。这表示，“好了，现在我们将等待直到解除阻塞的信号到来。”不过，问题在于我们又遇到了另一种情况。
- en: a race condition and we could end up in this thing called deadlock。 That's the
    situation that we would have had in the previous race condition too where， well。
    it's a little bit different。 It's basically one process is waiting on the other
    which is waiting on the other process。 and now we have two processes kind of waiting
    on each other。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个竞争条件，我们可能会陷入所谓的死锁。这是我们之前在竞争条件中也可能遇到的情况，嗯，虽然稍有不同。基本上，一个进程在等待另一个进程，而另一个进程也在等待第一个进程。现在我们有两个进程相互等待。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_98.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_98.png)'
- en: That's considered deadlock where you don't have to have some logic that actually
    figures， that out。 So you could try doing this with a pause but that might put
    it into a situation where you。 won't actually， if we had the following， if， again，
    if the signal arrives after the FGPID。 equals PID but before the call to pause，
    well， then what's happening。 The pause says， "Okay。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这被认为是死锁，在这种情况下你需要有一些逻辑来解决这个问题。所以你可以尝试使用暂停函数，但那可能会把它引入一个我们无法真正解决的情况。如果发生以下情况，如果信号在FGPID等于PID之后到达，但在调用暂停之前，那么会发生什么呢？暂停函数会说，“好吧。”
- en: I'm waiting for the signal handler saying， 'Oh， I've already。 been hit it so
    it's not going to actually end up working。'。 And you could try doing some like
    unblock and then block but you still got the problem。 because between unblock，
    SIGCHILD and pause， isn't there some time for something else， to happen？
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我在等待信号处理程序说，'哦，我已经处理过了，所以它实际上不会执行下去。' 你可以尝试做一些像解除阻塞然后再阻塞，但你依然会遇到问题。因为在解除阻塞SIGCHILD信号和pause之间，不是有一些时间可以让其他事情发生吗？
- en: Yeah。 So we want a way to make something work so that we say basically， 'Look，
    we know you're。 going to be put off the CPU。 We know this process is going to
    wait。 We know we have to unblock some signals。 Let's make it so that that happens
    after we are guaranteed that the process is already。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。所以我们想要一种方法来确保某些事情能正常工作，基本上我们说，'看，我们知道你将会被从CPU中移除。我们知道这个进程将会等待。我们知道我们必须解锁一些信号。让我们确保这件事发生，在我们保证进程已经发生之后。'
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_100.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_100.png)'
- en: off the CPU。'， Okay。 How do we do that？ Well， we have this other system call
    called SIGSPEND。 And SIGSPEND does the following。 SIGSPEND says， 'Oh， okay。 We
    are going to unblock signals。'， Okay。 Or I guess we're going to basically set
    this other block set which we can make the empty， set。 Here we remove the process
    from the CPU so that it can't have this weird deadlock condition。 Okay。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 被从CPU移除。' 好的。我们怎么做呢？好吧，我们有另一个系统调用叫做SIGSPEND。SIGSPEND的操作是这样的。SIGSPEND说，'哦，好吧，我们将解除信号的阻塞。'
    好吧，或者我猜我们基本上是设置另一个阻塞集，我们可以把它设为空集。在这里我们将进程从CPU中移除，以避免发生这种奇怪的死锁情况。好的。
- en: So that's what's happening here。 What we do is we say this。 We set up another
    signal set and we make it empty and we actually just set it to empty。 but don't
    change anything。 Here's what happens。 Okay。 We say， 'While FGPID equals PID。 we
    are going to say SIGSPEND on the empty set。'， Now remember， at this point。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是发生的情况。我们做的是这样：我们设置另一个信号集，并将其设为空，实际上我们就是把它设为空，但不改变任何东西。发生的情况是这样的。好的，我们说，'当FGPID等于PID时，我们将对空集执行SIGSPEND操作。'
    现在记住，到此为止。
- en: didn't we already blocked the signal for SIGCHILD？ It's already been blocked
    before。 We did it before。 We even forked。 Okay。 So the SIGCHILD is blocked。 When
    you say SIGSPEND， it says。 'Oh， okay。 I'm going to unblock all the signals after
    I push the processor off the processor and。 therefore it's going to wait until
    that child actually happens and then when the child happens。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 难道我们不是已经阻塞了SIGCHILD信号吗？它之前已经被阻塞了。我们之前做过。我们甚至执行了fork操作。好的，SIGCHILD信号被阻塞了。当你说SIGSPEND时，它会说，'哦，好吧。在我将处理器从CPU上移除之后，我会解除所有信号的阻塞。因此，它会等待，直到子进程实际发生，然后当子进程发生时，'
- en: the SIGSPEND wakes up after the process the child handler happens。 Question。
    [inaudible]， It un。 Good question。 It blocks。 It says， 'Set the signal set that's
    blocked to this set。'， Right？
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: SIGSPEND会在子进程处理程序发生后唤醒。问题是，[听不清]，它解除阻塞。好问题。它阻塞。它说，'将阻塞的信号集设置为这个集。' 对吗？
- en: So when you say 'Set it to the empty set，' it means no signals are blocked。
    Now you might have a situation where you need some signals to remain blocked and
    you can， do that。 But in this case， we're basically saying， 'Okay， fine。 Well。
    the SIGCHILD is blocked before this while loop。 Get into the while loop SIGCHILD
    is still blocked。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你说'将其设为空集'时，意味着没有信号被阻塞。现在你可能会遇到一种情况，需要某些信号保持被阻塞，你可以这样做。但在这种情况下，我们基本上是在说，'好的，没问题。SIGCHILD在这个while循环之前已经被阻塞。进入while循环后，SIGCHILD依然被阻塞。'
- en: You call the SIGSPEND system call and it goes， 'Oh， okay。 I am now taking the
    CPU。 the processor off and waiting until that SIGCHILD happens。 Now I'm unblocking
    and so if the SIGCHILD happens， it will be able to run in the child。 handler and
    then after it finishes， it will come and stop this SIGSPEND。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用SIGSPEND系统调用，它会说，'哦，好吧。我现在将CPU从处理器上移除，等待直到SIGCHILD发生。现在我解除阻塞，所以如果SIGCHILD发生，它将能够在子进程处理程序中运行，然后在完成后，它会停止这个SIGSPEND。'
- en: Go back in the while loop and then we will have already changed FGPAD to have
    changed。 FGPAD back to zero and we're done。 Okay？ Now I'm seeing some people going，
    'No， what's going on？'。 Seeing a few different， like， 'What's happening here？'。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回到while循环，然后我们就已经改变了FGPAD，将FGPAD改回零，这样我们就完成了。好的？现在我看到一些人说，'不，发生了什么？'看到一些不同的反应，像是，'这里发生了什么？'。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_102.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_102.png)'
- en: What questions？ Yeah， yeah。 Yeah。 [inaudible]， Yeah， SIGCHILD is kind of like
    pause in that it says。 'Okay， wait until it's blocked。 The SIGCHILD handle happens
    and returns and then you can keep going。 Wait for some signal basically。 [inaudible]，
    This one， yeah。 So the SIGSPEND is a little bit strange。 It says， 'Set this block
    signals to this set which we are unblocking。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 什么问题？是的，是的。是的。[听不清]，是的，SIGCHILD有点像暂停，它会说：“好，等到它被阻塞。SIGCHILD处理程序发生并返回，然后你就可以继续了。”基本上是等一个信号。[听不清]，这个，嗯，是的。所以SIGSPEND有点奇怪。它说：“将此块信号设置为这个集合，我们正在解除阻塞。”
- en: We're unblocking the SIGCHILD in this case because of this empty set and we're
    saying。 'Unblock that SIGCHILD after we've moved to the process， off-process so
    there's no race。 condition there anymore。'， So it will now unblock it。 The child
    handler will just wait until the child handler happens。 Child handler will do
    its thing。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在解除阻塞SIGCHILD，因为这个空集合，我们说：“解除阻塞SIGCHILD，在我们将进程移出处理器后，这样就没有竞争条件了。”所以它现在会解除阻塞。子处理程序会等待直到子处理程序发生。子处理程序会做它的事。
- en: Change FGPAD to B zero and then it will return。 This line will say， 'Oh。 we've
    now got that signal so now we're going to go back up here， and change that。'，
    Okay？
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将FGPAD更改为零，然后它将返回。这一行会说，“哦，我们现在已经得到了那个信号，所以现在我们会回到这里，进行更改。”好吗？
- en: Now you might be asking yourself one sec。 You might be asking yourself， 'Wait。
    why do we even need this while loop in here？'， Because if we're going to wait
    for the signal。 why do we even need to do that？ It turns out that any signal that
    gets handled will cause this SIGCHE SPEND to end。 And so you need to， you want
    to say， 'Oh， well， in that case let's make sure that we。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问自己，等等。你可能会问自己：“等等，为什么我们这里还需要这个while循环？”因为如果我们要等待信号，为什么还要做这个？结果发现，任何被处理的信号都会导致SIGCHE
    SPEND结束。所以你需要，或者说，你想说：“哦，那既然如此，我们确保……”
- en: check again to see if our condition that we were supposed to set got set。 If
    not。 we'll just loop again and do another SIGCHE SPEND。 Question。 That was your
    question。 There you go。 I asked it before you got to it。 Yeah？ [inaudible]， Yeah，
    let's see what's happening here。 Remember。 we， well， okay， what have we done here？
    We are a foreground process。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查，看看我们应该设置的条件是否已被设置。如果没有，我们就会继续循环，再次执行SIGCHE SPEND。问题。那是你的问题。给你了。我在你问之前就问了。是吗？[听不清]，是的，让我们看看这里发生了什么。记住，我们，嗯，好吧，我们在这里做了什么？我们是一个前台进程。
- en: which means the parent needs to wait for the foreground process， to end。 Okay？
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着父进程需要等待前台进程结束。好吗？
- en: We have blocked the signal child handler at this point。 We've come into here，
    okay。 and the signal child， the child could have ended already， but it's been
    blocked。 So it's not a race condition in that sense。 We now say， okay， great。
    FGPID equals PID。 So we're saying that there's a foreground process。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们此时已经阻塞了信号子处理程序。我们已经进入这里，好的。信号子处理程序，子进程可能已经结束，但它被阻塞了。所以从这个角度来说，这不是竞争条件。我们现在说，好，太好了，FGPID等于PID。所以我们说这里有一个前台进程。
- en: We want to set these two equal and then the child handler will unset， like，
    unset FGPAD。 Okay？ Well。 then we say， okay， we're setting up the signal set to
    be this empty set。 We say。 while FGPID equals PID， is that going to be true the
    first time through， even though。 the child has ended？ Yeah， it will be true the
    first time through， which is fine。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想将这两个设置为相等，然后子处理程序会解除设置，比如，解除FGPAD。好吗？好吧。然后我们说，好，我们将信号集设置为空集。我们说，while FGPID等于PID，第一次执行时这个条件会成立吗，即使子进程已经结束？是的，第一次执行时它会成立，这没问题。
- en: Then we will do SIG suspend， which is going to push the parent process off the
    processor。 because it's waiting for the child process to end。 Okay？ That handler
    to happen。 It calls。 it unblocks the signal after the process is off the processor。
    At that point， the child has ended。 it calls signal handler， changes FGPID to
    be zero。 Well， and then it ends and it wakes up here。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会做SIG suspend，这将会把父进程推到处理器外，因为它在等待子进程结束。好吗？让那个处理程序发生。它调用，处理完后解除信号阻塞，进程从处理器中移除。此时，子进程已经结束。它调用信号处理程序，将FGPID更改为零。然后它结束并在这里醒来。
- en: it goes back in this while loop and says， oh， okay， now I've got zero is not
    equal to the PID。 I can end and then I can unblock SIG， child again。 By the way。
    when it comes out of this SIG suspend， it reblocks the things that it would， block
    before。 And that's the only， the good thing about that is so this while loop will
    actually work， again。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它回到这个`while`循环中，看到“哦，好吧，现在我发现PID不等于0了。我可以结束并且再次解除阻塞SIG child。”顺便提一下，当它退出这个SIG
    suspend时，它会重新阻塞之前阻塞的信号。这样做的好处是，这个`while`循环实际上可以再次正常工作。
- en: Lots of good， like， questions on this。 Yeah， good question。 Do I mean when I
    push off the processor。 push back in the OS scheduler， we haven't talked， about
    the schedule itself， but yes。 it basically means put the parent process to sleep。
    And when the parent process is to sleep。 there's nothing else happening in the
    actual code， here until that signal gets handled。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 很多很好的问题，像是这个问题。是的，好问题。我是指当我把处理器推离时，推回到操作系统调度器，我们还没有讨论调度本身，但确实。它基本上意味着将父进程置于休眠状态。当父进程处于休眠状态时，直到信号被处理之前，实际代码中不会发生任何其他事情。
- en: Why does the really unblock SIG child？ We have to， because when SIG suspend
    ends。 it unblocks the signals。 It puts back the original set。 Yes， good question。
    So it reblocks in that case， reblocks the signals。 Yeah。 Yeah。 Well。 the while
    loop ever iterate more in one time。 Let's see。 It shouldn't for this one child
    process。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要真正解除阻塞SIG child？我们必须这么做，因为当SIG suspend结束时，它解除阻塞信号。它恢复了原始的信号集。是的，好的问题。所以它在这种情况下会重新阻塞信号。是的，是的。那么，`while`循环会在一次中迭代更多次吗？让我们看看。对于这个子进程来说，不应该。
- en: Yeah。 Now， unless some other signal came in and then it happened to un-suspended。
    So it could happen more than once if another signal came in that happened to un-suspended。
    Does that-- does the suspend happen until any signal gets handled？ Yeah。 Now。
    if you were making this much more robust and you care about other signals， you
    might。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。现在，除非有其他信号进入并且恰好使得它恢复执行。所以，如果有其他信号进入并且恰好使得它恢复执行，可能会发生多次。这是否意味着暂停会一直持续，直到某个信号被处理？是的。现在。如果你要让它更健壮，并且关心其他信号的话，你可能需要考虑。
- en: not want to make it just the empty set and so forth， but we don't care about
    any other。 signals right now。 That's fine。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不想让它仅仅是空集合等等，但现在我们不关心其他信号。那没问题。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_104.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_104.png)'
- en: Okay。 That's a lot of stuff。 That one thing。 You will use this extensively in
    the assignment three farm。 which you are going to， which you're， working on now
    in that assignment four。 Not extensively。 but you use some of these as you go
    through these。 Okay？
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这是很多内容。那件事，你将在作业三中广泛使用它，你现在正在做的作业四中，虽然不算广泛，但在做这些的时候会用到一些这些内容。好的？
- en: It's hard to reason about these things sometimes。 Okay。 Let's do this。 What
    I wanted to do is go through a couple questions。 Now， unfortunately。 you have
    a midterm and a week and a half。 Unfortunately。 Nobody likes midterms。 We don't
    like grading them。 You guys don't like taping them。 We should just get rid of
    them。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候确实很难推理这些事情。好的。让我们来做这个。我想做的是看几个问题。现在，不幸的是，你们有一个期中考试，一周半后。不幸的是，没有人喜欢期中考试。我们不喜欢批改它们，你们不喜欢做它们。我们应该干脆取消期中考试。
- en: But there's lots of barriers to that。 But if you have good ideas， certainly
    let me know。 Let's go through a couple of questions。 We have about 15 minutes，
    so we can get through these。 I think。 Let's go through a couple of questions related
    to signal handling that you might see on the。 midterm。 In fact， the two questions
    are from previous midterms。 Okay？ So， here's the problem。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但这有很多障碍。不过，如果你有好的想法，当然可以告诉我。我们来看几个问题。我们大约有15分钟，所以我们可以完成这些。我想。我们来讨论几个你可能会在期中考试中看到的信号处理相关的问题。事实上，这两个问题来自之前的期中考试。好的？那么，这里是问题。
- en: Consider this program and its execution。 Okay。 Assume that all processes run
    to completion and all system calls and all print F succeed。 et cetera。 Don't worry
    about any errors in this case。 And assume that all calls to print F are atomic。
    Atomic means that it happens without anything else being able to interrupt it。
    Okay？ So， in other words， if you're printing out ghost or pirate， which is what
    we're printing。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个程序及其执行。好的。假设所有进程都运行到完成，所有的系统调用和所有的`printf`都成功，等等。这个情况下，不必担心任何错误。并且假设所有的`printf`调用都是原子的。原子操作意味着它发生时不会被其他任何事情打断。好的？换句话说，如果你正在打印“ghost”或“pirate”，这就是我们正在打印的内容。
- en: out here， you can't have it interrupted in the middle of the。 Pre-enter the
    P and pirate。 It's not like a signal is going to happen。 Okay？ And， like， interrupt
    it。 Okay？
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你不能在中途被打断。预先进入 P 和 pirate。它不像信号会发生。好吧？并且像，打断它。好吧？
- en: This is actually more or less true for print F。 Okay？ Print F will print out
    its whole， like。 stuff before any other print F can get in there and， print stuff
    out。 So。 it's generally a good assumption in this case。 It's not true for C out。
    which is why we had to write a little external function for， C out to make that
    work。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上对 `printf` 来说或多或少是对的。好吧？`printf` 会先打印出它的所有内容，然后其他任何 `printf` 才能进入并打印内容。所以，这通常是一个不错的假设。在这种情况下，`printf`
    是对的。对于 `cout` 来说就不成立，这就是为什么我们必须为 `cout` 写一个小的外部函数来让它工作。
- en: But that's what you have to assume here。 Okay？ You just can't assume anything
    about scheduling or how long a time slice is or whatever。 You can just look at
    this and go， "Hey， what can happen in this program？
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但你必须假设这里的情况。好吧？你不能假设任何关于调度的事情，或者时间片有多长之类的。你只能看着这个并说，“嘿，这个程序中会发生什么？”
- en: What conditions could this program happen if anything happened in any order
    according。 to the rules that we have for our processes？"， Okay？ Here is the program。
    Let me do this。 Let me bump this up and go to this program here。 Okay？ We've got
    a main function。 It sets up a SIG user 1 signal。 That's just a signal that we
    can use for whatever we want。 Okay？
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们为进程设置的规则，如果程序中的任何事件以任何顺序发生，可能会发生什么情况？好吧？这里是程序。让我做一下这个。让我把它放大，然后转到这个程序。好吧？我们有一个主函数。它设置了一个
    SIG 用户 1 信号。那只是一个我们可以用来做任何事情的信号。好吧？
- en: We can send a SIG user 1 to another process。 In fact。 we're going to send it
    to our child in this case。 Okay？ We。 The back function is the function that we
    are actually calling as our signal handler。 Then we're printing pirate and then
    we're exiting。 Okay？ First question， by the way。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向另一个进程发送 SIG 用户 1。事实上，在这个例子中，我们将它发送给我们的子进程。好吧？我们。回调函数是我们实际调用的信号处理器函数。然后我们打印
    pirate，然后退出。好吧？顺便问一下，第一个问题。
- en: Is this function happen in the parent or the child？ In the parent。 Okay？
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是在父进程还是子进程中发生的？在父进程。好吧？
- en: It's not happening in the child。 Sorry。 The pen's who gets called。 Right？
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是在子进程中发生的。抱歉。笔者是谁被调用了。对吧？
- en: Depends who gets it as it turns out。 So that's a trick question I suppose。 Right？
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于谁接收它，事实证明。所以这应该是一个陷阱问题，对吧？
- en: What if it was a SIG child handler but it's not a SIG child handler， it's anything
    that。 ignores a SIG user 1 handler which means we are sending it。 So， pens who
    is calling it。 And who's receiving it。 Okay？ We are setting up the signal handler。
    The fork means that both the parent and the child will have a signal handler。
    But in this case。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个 SIG 子进程处理器，但它不是一个 SIG 子进程处理器，它是任何忽略 SIG 用户 1 处理器的东西，这意味着我们正在发送它。那么，笔者谁在调用它？而谁在接收它？好吧？我们正在设置信号处理器。`fork`
    意味着父进程和子进程都会有一个信号处理器。但在这种情况下。
- en: as you'll see it's just。 It turns out it's just the child that's actually getting
    a signal。 Okay？
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，实际上是子进程在接收到信号。好吧？
- en: All right。 Okay。 So then it's going to fork and then if we're the child。 we're
    going to print ghost and return， zero。 And then if we're the parent。 we're going
    to send the kill signal with SIG user 1 to the。 child and then we're going to
    print ninja and then return zero。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那好。然后它将进行 `fork`，然后如果我们是子进程，我们将打印 ghost 并返回零。然后如果我们是父进程，我们将向子进程发送一个带有 SIG
    用户 1 的 kill 信号，然后我们将打印 ninja 并返回零。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_106.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_106.png)'
- en: Okay？ All right。 Can you say then what does kill exactly the。 Yeah， good question。
    What does kill exactly do？ It sends a signal to a process。 Would the send SIG
    user 1 or send SIG to it？ In this case it sends SIG user 1 to the process PID。
    Kill is not a good name for the function。 Okay。 So raise it to the send sort of
    style。 Yeah。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧？好吧。那么你能说出 `kill` 到底做了什么吗？是的，好的问题。`kill` 到底做了什么？它向一个进程发送一个信号。它会发送 SIG 用户 1
    还是发送 SIG 到它？在这个例子中，它向进程 PID 发送 SIG 用户 1。`kill` 这个函数名字不太好。好吧。所以可以把它理解为发送信号的样式。是的。
- en: Raise means send it to ourselves。 Yeah。 Kill means send it somewhere else。 Say
    kill。 get PID and send it to yourself。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise` 意味着将其发送给我们自己。是的。`kill` 意味着将其发送到其他地方。比如 `kill`，获取 PID 并将其发送给自己。'
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_108.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_108.png)'
- en: But raise does that for you。 All right。 Now， question is， right yes or no。 if
    there's a possible output here。 Okay。 And we can go through this and check and
    see。 is it possible for any of these outputs to， happen？ Okay。 Well， let's see。
    What would make it true that ghost ninja and then pirate happens？ Okay。 Let's
    see。 No。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`raise`会帮你做到这一点。好了，现在问题是，是否可能在这里产生输出。好的。我们可以逐步检查，看看是否有可能出现这些输出？好的。让我们看看。什么会让幽灵、忍者然后是海盗依次发生？好的。看看吧。没有。
- en: for ghost ninja， I'll make it big there。 Okay。 For ghost ninja and pirate to
    happen。 Well。 how do we get ghost first？ Okay。 We fork and then this happens immediately。
    Could that happen before anything else happens？ Sure。 It looks like ghost could
    be printed immediately。 Okay。 Then for ninja to happen， okay。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于幽灵和忍者，我会把它写大点。好的，要让幽灵、忍者和海盗依次发生。好吧，怎么才能先发生幽灵呢？好，我们分叉后，这个立即发生。这个能在其他事情发生之前就发生吗？当然。看起来幽灵可以立即被打印。好的，接下来要发生忍者的情况，好的。
- en: we send a kill signal。 From parent， we send a SIG user signal using the kill
    system call。 We send SIG user， okay， to the child， okay。 And this can return immediately
    by the way。 It doesn't wait for the child to do anything。 It just sends it in
    returns。 Could we send off that signal and then really quickly print ninja？ Sure。
    In the child。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送一个`kill`信号。从父进程发送，我们使用`kill`系统调用发送`SIGUSER`信号。我们发送`SIGUSER`，好，给子进程，好的。顺便提一下，这可以立即返回。它不会等子进程做任何事情。它只是发送信号然后返回。我们能先发送这个信号然后非常快速地打印忍者吗？当然可以。在子进程中。
- en: we have now had our signal handler called。 So can we print pirate and then end？
    Yeah。 So I think this one is fine。 Anybody have any questions why it's not？ Yeah。
    That doesn't have to have the kill signal or like the kill call to turn before
    the child。 is done or not。 Oh， good question。 This would have to happen between
    after this and before this。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经调用了信号处理程序。那么我们可以先打印海盗然后结束吗？是的。所以我认为这个是没问题的。有人有问题为什么不行吗？是的。它不需要`kill`信号或类似的调用在子进程完成之前先触发。哦，好问题。这必须发生在这个和这个之间。
- en: Yeah， that could happen。 We don't say there's no reason it couldn't in this
    case， right？
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实可以发生。我们没有说在这种情况下不可能发生，对吧？
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_110.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_110.png)'
- en: We're looking at there's no reason that couldn't happen。 Okay。 Let's look about
    pirate and then ninja。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在考虑没有理由这不可能发生。好的，让我们看看海盗和忍者。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_112.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_112.png)'
- en: Let's see if that one's possible。 Okay。 For pirate to happen。 we would have
    to fork send a kill signal before the child gets a， chance to print ghost。 Is
    that possible？ Sure。 It seems possible， right？ And then that will get。 we'll call
    the child's signal handler， print a pilot， print pirate， which is good。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种情况是否可能。好，想让海盗事件发生，我们必须先分叉并在子进程有机会打印幽灵之前发送一个`kill`信号。那可能吗？当然，似乎是可能的，对吧？然后，这将触发子进程的信号处理程序，打印一个海盗，打印海盗，这很好。
- en: And then that'll end。 And then we get， we're still over here。 Then we could
    have ninja print at some point。 That makes sense。 Okay。 I think that's plausible。
    I think that's a couple plausible ones。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后那将结束。然后我们仍然在这里。然后我们可能会在某个时刻打印忍者。那有道理。好的，我认为这是合理的。我认为这几种情况都很有可能。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_114.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_114.png)'
- en: Let's look at the next one。 I'll make this done。 How about ninja and ghost？
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 看下一个问题。我要完成这个。忍者和幽灵怎么样？
- en: What if bat returned instead of exited， then you would definitely get ghost
    at some point， in there。 right？ Because it exits， right， and doesn't return， it
    exits the actual signal， the child itself。 It closes， it's terminates the child
    process by using exit。 Good question。 Good call。 Okay。 Let's look at the next
    one。 Ninja and ghost。 How could ninja happen before ghost？ Well。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bat`返回而不是退出，那么你肯定会在某个时刻遇到幽灵，没错吧？因为它是退出的，对吧，它并没有返回，它退出了实际信号，即子进程本身。它关闭了，使用`exit`终止了子进程。好问题。好选择。好了，让我们看下一个问题。忍者和幽灵。为什么忍者会先于幽灵发生呢？嗯。
- en: we could get down here， let's say that the child is just slow right now。 We
    get down here and we send this signal。 Okay。 So， how could it happen that this
    signal。 which is going to signal the child， say， pirate， could it happen that
    this signals and then gets up here and then this prints and returns。 but then
    this never happens？ No， I don't think that could happen。 Right？
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在子进程比较慢，我们可以到这里，我们发送这个信号。好的。那么，如何发生这种情况呢？这个信号，理论上是会触发子进程执行海盗的，这个信号在这里触发然后上升，打印出来返回后，但接下来的这个永远不会发生？不，我不认为这种情况会发生。对吧？
- en: Because the minute this signal handler happens， it stops everything happening
    down here。 So if you were to get that case， right， where you were trying to get
    ghost happening， right， well。 this has to happen before this happens and therefore
    you're going to get the signal。 called up here and you're going to end up getting
    pirate before you're going to get ghost。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一旦信号处理程序发生，它会停止下面所有的事情。所以如果你碰到那种情况，对吧，试图让 ghost 发生，对，那么这必须在这个发生之前，所以你会在这里调用信号，然后你最终会先得到
    pirate，而不是 ghost。
- en: So it's not really possible for ghost to happen without having the pirate happening
    if， you call。 say， if you do a signal first。 So no， I don't think that。 Yeah？
    We know that， we know that。 but the call to show has to happen right there， but
    we can。 actually know anything about when this title actually misses。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所以没有真的可能在没有 pirate 发生的情况下发生 ghost，如果你先发送信号。所以不，我不认为是这样的。对？我们知道，我们知道。但调用 show
    必须在那里发生，我们不能。实际上不知道这个标题到底什么时候会错过。
- en: The signal is like what if you send the signal， the ninja gets printed out and
    then the cross。 and then when the child crosses out the print is out there， it's
    that there's some reason。 it hasn't received the signal user yet。 Right。 So the
    signal happens immediately。 It's the next thing that happens。 So even if it got
    to print ghost。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 信号就像是你发送信号，忍者被打印出来，然后是十字架。然后当子进程退出时，打印仍然会在那里，原因是它还没有接收到信号。对。所以信号会立即发生。这是接下来发生的事情。所以即使它已经打印了
    ghost。
- en: it would still have the signal called actually and then， have to go up and print
    pirate。 So I think you're not really going to get， remember we can't say that，
    oh， these two are。 going to happen next to each other， right？ But we can say that
    the signal will definitely。 if that got printed， right， well， by the time， back
    I printed， if this had already been printed。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然会收到信号，实际上，然后必须打印 pirate。所以我认为你不会真的得到，记住我们不能说，哦，这两件事会紧接着发生，对吧？但我们可以说，信号肯定会发生。如果它打印了，那对，等我打印完，如果这已经打印了。
- en: that signal had already been sent。 So the fact that signal got sent at all means
    that even if this printed。 it would have to， then go and do the pirate because
    it would never get to the return zero。 Does that help？ Yeah。 Yeah。 Yeah。 Yeah。
    Yeah。 Yeah。 Yeah。 Yeah。 Yeah。 So signal handler stops。 Because， again， this is
    kind of my question earlier， which one is happening， this happening。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 信号已经发送了。所以信号已发送这一事实意味着，即使这个被打印了，它也必须接着做 pirate，因为它永远不会到达 return zero。这样有帮助吗？对。对。对。对。对。对。对。对。对。所以信号处理程序停止了。因为，再次，这其实是我之前的问题，哪个在发生，这在发生。
- en: is happening in the child in this case。 The signal handler， the child is one
    process。 It can't have two things going on at once。 So it's either doing the signal
    handler or it's doing the rest of the program。 And if it's doing the signal handler，
    the rest of the program is not happening。 Yeah。 What if you had ghost and then
    it returned and then you tried to send it to signal handler？
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，子进程正在发生什么？信号处理程序，子进程是一个进程。它不能同时做两件事。所以它要么在处理信号，要么在执行程序的其余部分。如果它正在处理信号，程序的其他部分就不会发生。对。如果你先有了
    ghost，然后它返回了，你试图发送它到信号处理程序，会发生什么？
- en: If you had ghost and then it returned， so returning from main is going to call
    a closed， program。 It may take an instruction or two after that， actually。 But
    I guess there's that。 but that wouldn't happen in this program。 You see why？ Because
    you send this kill signal。 even if it's too late to do this ghost one， it's going，
    to happen before the return。 Okay。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有 ghost 然后它返回，返回主函数将调用关闭程序。实际上可能再执行一到两条指令。但是我猜那样的情况不会发生在这个程序中。你明白为什么吗？因为你发送了
    kill 信号。即使太晚去做 ghost，它会在返回之前发生。好。
- en: Because that， because it happens， the instant you send it and it's not like
    the return， the。 problem， the kernel is going， oh， I guess there's a signal I'm
    sending it immediately， to the child。 If it did return， if after printf goes，
    if it did return， there is some time in there。 still where the signal handler
    could still get it， still happen， but probably not very， long。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它，发生的瞬间你发送信号，并不像返回那样。问题是，内核会说，哦，我猜有一个信号，我立刻把它发送到子进程。如果它返回了，如果 printf 运行后，它确实返回了，那么其中还是有一些时间，信号处理程序仍然能接收到它，依然会发生，但可能不会持续很长时间。
- en: Return goes， your return does not like immediately stop the program。 No， exit
    does。 Exit's like we're done。 Yeah。 In the second one， why wouldn't it go since
    you're getting it？
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回时，你的返回并不会立即停止程序。不，退出才会。退出就像是我们结束了。是的。在第二种情况下，为什么它不会去呢，既然你得到了它？
- en: Why wouldn't ghost print after ninja？ Let's see， pirate does exit the。 it actually
    stops the child from happening， being， it， terminates the child completely immediately。
    Process is done。 Yes。 Good question。 Yeah。 So the second one， why would you return
    zero also？ Again。 returning zero does， it does work eventually， but there's actually
    a little bit。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么忍者之后不会打印鬼？我们来看，海盗确实退出了。它实际上阻止了子进程的发生，结束了它，完全终止了子进程。进程完成。是的。好问题。是的。那么第二种情况，为什么你还会返回零呢？再次说明，返回零最终是有效的，但实际上还有一点时间。
- en: of time between return zero and the end of the program。 There's some more cleanup
    that's actually involved。 You actually propagate。 it's actually a different path
    through the， going back to the shell as， it turns out。 It's not returning， a function
    calls mean。 When you say exit。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回零和程序结束之间的时间里，还涉及一些清理工作。你实际上是在传播。实际上，这是一条不同的路径，通过返回 shell，如实际情况所示。它并不是返回，函数调用意味着。当你说退出时。
- en: it actually never returns to that calling function as it turns out。 It just
    ends it immediately。 More or less。 I mean， there's still a little bit of time
    in there， but it ends it immediately。 You can think of it that way。 But it does
    not return from the。 I guess the bigger thing is it does not return so that， this
    could ever get printed。 In other words。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它永远不会返回到那个调用函数，事实证明。它只是立即结束了。或多或少。我的意思是，里面仍然有一点时间，但它立即结束了。你可以这么理解。但它并没有从中返回。我猜更大的问题是，它不返回，以至于**这个**永远不会被打印出来。换句话说。
- en: exit zero never makes it， it means it never makes it back to the parent， at
    all。 so this couldn't get printed。 Right？ Okay。 All right， we've got two ones。
    Let's look at the other ones here。 Could we do ninja pirate ninja？ No， that's
    silly。 Ninja pai。 Ninja pai， you can't get to， you're not going to get to there。
    Could you get ninja pirate ghost？
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 退出零永远不会到达，它意味着永远不会返回到父进程，完全不会。因此，**这个**不会被打印出来。对吧？好吧。好了，我们有两个。让我们看看这里的其他问题。我们能做忍者海盗忍者吗？不，那太傻了。Ninja
    pai。Ninja pai，你无法到达那里。你能做忍者海盗鬼吗？
- en: Ninja pai。 This is what we were kind of talking about before， right？ Ninja pirate
    ghost。 Well。 ninja and then pirate and you'll never get back to here if you have
    set the， if the， pirate happens。 you'll never get back to the other part of the
    job process。 Yes， no， no， yes， yes， no， no， no。 There we go。 All right， there's
    another one that I don't have time to do today， but another midterm。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Ninja pai。 这是我们之前讨论过的，对吧？Ninja pirate ghost。好吧，先是忍者，然后是海盗，如果海盗发生了，你将永远无法回到这里。如果设定了海盗，程序的其他部分将无法再返回。是的，不，不，是的，是的，不，不，不。好了。好吧，还有一个我今天没有时间做的，但这是另一个期中考试题目。
- en: and we'll start with this one on Wednesday。 It's another race condition one。
    Feel free to look at it if you want to， but it's another one from the midterm。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在星期三从这里开始。这是另一个竞态条件问题。如果你想的话，随时可以看看它，但这是期中考试中的另一个题目。
- en: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_116.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d56cf3cf36e03a3d35caf5aa63c69_116.png)'
- en: See you guys Wednesday。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 星期三见。
