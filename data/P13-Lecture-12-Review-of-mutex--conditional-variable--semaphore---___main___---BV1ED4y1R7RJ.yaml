- en: P13：Lecture 12 Review of mutex, conditional variable, semaphore - ___main___
    - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P13：第12讲 互斥量、条件变量和信号量的复习 - ___main___ - BV1ED4y1R7RJ
- en: Okay， we might as well get started。 Welcome。 So the midterm is over。 I hope
    everybody did alright。 I'll have a couple， comments about that。 And then Stanford
    Shell。 I hope that's going okay。 As I said， there's like， if you haven't really
    gotten going on it， get going soon。 It's a。 those of you who did who have started
    it， you realize there's just lots of parts to it。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以开始了。欢迎大家。那么期中考试已经结束了，希望大家都做得还不错。接下来我会有几点关于考试的评论。然后是斯坦福 Shell，希望大家进展顺利。如我所说，如果你还没有开始，赶紧开始吧。对于已经开始的同学，你们应该意识到，这个作业有很多部分。
- en: and lots of things to think about。 And there's been lots of Piazza questions。
    lots of questions about the assignment。 So I hope that's going alright。 And we
    will。 have lots of officers this week。 And when did they say it was due Wednesday
    night or。 Thursday night？ Did you say make it Thursday night？ So you said， let's
    talk in a。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多要思考的东西。并且有很多关于 Piazza 的问题，很多关于作业的问题。所以希望大家都没问题。我们这周会有很多助教。考试的截止时间是星期三晚上，还是星期四晚上？你说是星期四晚上对吧？那我们就说，稍后再讨论。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_1.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_1.png)'
- en: couple days。 We'll see。 So the midterm， a couple comments on that。 You should
    have。 gotten your midterm scores back。 If you didn't， please let me know so we
    can。 make sure that happens。 Overall， I was pretty pleased with it。 I think the，
    there。 were a couple questions on there that I knew would be difficult。 And there
    were a couple。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几天前。我们看看。关于期中考试，我有几点评论。你们应该已经收到了期中成绩。如果没有，请告诉我，这样我们可以确保分数能够发放。总体来说，我对结果还是挺满意的。我认为，里面有几个问题我知道会比较难。还有几个问题。
- en: questions that I thought， hey， everybody should do alright on this。 And most
    people， did。 The answers to the file system stuff。 I mean， I think that was hopefully，
    relatively open ended。 but straightforward。 Most people did okay。 Problem one
    D。 Actually， problem one。 I think was the most challenging problem， which it was，
    kind of meant to be。 One D。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为应该每个人都能做好的问题，结果大部分同学确实做得不错。关于文件系统的题目，我觉得应该算是比较开放的，但也挺直接的。大多数人做得还不错。问题1D，实际上问题1是最具挑战性的问题，这也是它的设计目的之一。1D题。
- en: let's go kind of in reverse order here。 One D was the， question about， hey。
    how do you deinterleave these outputs？ Is it possible to， really deinterleave
    these outputs？
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们倒着顺序讲。第一题是关于“如何将这些输出去交织？”的问题。真的能去交织这些输出吗？
- en: The answer is not really。 The way we set up the， input and output such that
    they had to track each other directly made it really。 impossible no matter what
    solution you came up with。 Unless you were allowed to。 collect all the data first
    and then pipe it to one， then pipe it to the other and， so forth。 And my。 the
    idea for this problem was you don't know how much data。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 答案其实并不是很明显。我们设置输入输出的方式使得它们必须直接关联在一起，这样无论你想出的解决方案是什么，都几乎不可能实现，除非允许你先收集所有数据，再传输到一个输入，接着传到另一个输出，依此类推。我的思路是这个问题的关键在于你不知道有多少数据。
- en: there is coming in and you're not allowed to store it all before you start piping。
    away and it's not possible。 Very few people got that part correct for D， but that's，
    okay。 That happens on exams。 Definitely go and look at it。 If you do have， questions
    about， hey。 I don't really understand what the answer is all about。 Trust me。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据正在进来，但你不允许在开始传输之前把它全部存储好，这样做是不可行的。很少有人在D题部分做对了，但没关系，考试中总会有这样的情况。一定要去看看，如果你对答案有疑问，别担心，我会帮助你理解。
- en: we had some TAs during grading who were like scratching their heads going， oh，
    wait a minute。 what is this？ And they did it all on the board and they convinced，
    themselves eventually。 So it was a difficult， difficult problem。 For the actual
    code， for that， two things。 First thing。 you know how we can use the pipe to and
    then you， have like FDS and then O， Clo， ex。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在评分时，一些助教开始头痛，想“等等，这是什么？”他们在黑板上做了演示，最后自己也明白了。所以这是一个很有挑战性的问题。至于实际代码，涉及两个问题。首先，你知道我们怎么用管道去做，然后你有像
    FDS 和 O，Clo，ex 这样的东西。
- en: EC or whatever it is。 You know how you do that， and then you don't have to close
    some。 but you might have to close others or whatever。 We didn't even worry about
    that。 All right。 for the exam。 There were too many， like corner cases where you
    could have done one or the other and we just pretended。 everybody used O that
    pipe to and we pretended that everyone closed everything。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: EC 或者其他东西。你知道怎么做，然后你就不必关闭一些，但你可能需要关闭其他的或者什么的。我们当时根本没有担心这些。好了，考试时。这里有太多像是边缘案例，你可能做其中之一或者另一个，我们只是装作没事。大家都用了
    O 管道，我们假装每个人都关掉了所有东西。
- en: inside the children correctly。 There were two pipes you had to close correctly
    or。 two five the scriptures you had to close correctly outside of the children
    and that。 one we cared about。 But inside the children， if you went and if you
    said， oh， I'm not。 sure I got that right， that's okay。 We didn't worry about that。
    The other thing。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在子进程内部正确处理。你必须正确关闭两个管道，或者说，正确关闭两个脚本，这些是我们在乎的。但是在子进程内部，如果你去了，假设你说，哦，我不确定自己做对了，那也没关系。我们不为此担心。还有其他的事。
- en: that people tended to miss quite frequently was we didn't say you should wait。
    PID for the children to end the program。 But let's just go look at the program。
    the actual question again。 Okay， and or I should say let's look at the actual
    code。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大家经常忽略的一点是，我们没有说你应该等待 PID，直到子进程结束。我们还是来看看程序，实际问题是什么。好的，或者我应该说，我们来看看实际代码。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_3.png)'
- en: that you may or may not have typed up to。 Remind me later。 There we go and then
    there we go。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经或者没有输入的部分。稍后提醒我。好了，然后接着。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_5.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_5.png)'
- en: Then two output。cc。 Okay， so you wrote all this for the actual pipes and so
    forth。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后两个输出。cc。好的，你为实际的管道等写了所有这些。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_7.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_7.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_8.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_8.png)'
- en: You did all that and you were writing where？ You were writing in Maine， right？
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你做了所有这些，而你写的地方在哪里？你是写在主程序中，对吗？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_10.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_10.png)'
- en: You were writing the actual main part of this program which called the dual
    echo。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在编写这个程序的主要部分，叫做双回声。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_12.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_12.png)'
- en: down here， okay， which called the dual echo down here and that was what you
    did。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，好的，这里叫做双回声，这是你所做的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_14.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_14.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_15.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_15.png)'
- en: And then Maine ended。 And Maine ended and if you forgot the weight PID， this
    is what。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后主程序结束。如果你忘记了加权 PID，就会发生这种情况。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_17.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_17.png)'
- en: it should have looked like by the way。 Let's see。 Two output。 Let's do the same。
    example to do sort and then I'll pipe in a little test， test input。 Okay， so that。
    was actually relatively nice in that it did sort and WC in the word count actually。
    did come first but it didn't have to。 It could have come somewhere in the middle。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是这样的。让我们看看。两个输出。做同样的例子来排序，然后我会管道一个小的测试输入。好了，这其实相对不错，因为它确实排序了，并且 WC（单词计数）实际上先执行了，但也不一定。它可以在中间任何地方执行。
- en: That was the interleaving part。 But you'll notice that the prompt didn't come
    back until。 after both children finished。 That's what you want in programs。 You
    want your。 programs to end nicely such that the prompt comes back。 Well， if we
    took out those。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那是交错部分。但是你会注意到，提示并没有在两个子进程完成之前返回。这才是你在程序中想要的。你希望程序能够正确结束，让提示能够返回。好了，如果我们去掉那些。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_19.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_19.png)'
- en: two weight PIDs， right， let's see what might happen。 Okay， it's not guaranteed
    to happen but。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 两个加权 PID，好的，来看看到底会发生什么。好吧，这并不能保证一定会发生，但是。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_21.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_21.png)'
- en: let's see what happens here。 I'll put， oops， put， there we go。 Two output and
    let's do the same thing。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里会发生什么。我会放，哎呀，放，这样就好了。两个输出，做同样的事情。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_23.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_23.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_24.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_24.png)'
- en: before。 Let's do it up at the top of the screen。 There we go。 Okay， look。 So
    here's what happened。 Up here we got the prompt back and then the program went
    and then it just sits here like， that。 Is that a nicely behaved program？ No， not
    very nice。 So we kind of expected you to go， oh。 if I'm writing the main and I
    want and I'm doing this two output thing for children。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前。我们把它放在屏幕顶部。好了，看这里。发生了什么。上面我们得到了提示，然后程序就开始执行，然后就停在这里了，像这样。那是一个行为良好的程序吗？不，挺差劲的。所以我们大概是希望你能意识到，哦，如果我在写主程序并且做这两个输出的事情来处理子进程。
- en: you should wait for the children。 So I apologize to people who didn't pick that
    up but。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该等待子进程。所以，我对没有理解这一点的人表示抱歉。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_26.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_26.png)'
- en: you kind of should get that that that's the what you want to do。 All right。
    If you have， other。 there are regrade requests still open。 We're relatively strict
    about regrade requests。 and that you can't like for the pro and con when you go，
    well， I really meant this。 and try to explain away what you really meant。 If it
    wasn't on the page， that's it。 The other， one。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该理解这就是你想做的事情。好的。如果你有其他问题，仍然有一些重新评分请求。我们对重新评分请求相对严格，你不能仅仅因为有正反两面，就说“我其实是这个意思”，并试图解释你真正的意思。如果没有出现在页面上，那就算了。还有，另一个问题。
- en: there were some people who were saying， ah， I wrote 125 words and you took off
    points and， whatever。 I kind of， you know， kind of warned you that the point，
    we thought those。 answers could be well within 100 words。 And so if you made，
    if you made a few more， we didn't。 care that much。 And if you do want to regrade
    requests， I'll go count your words and make。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人说，啊，我写了125个单词，你扣了分，什么的。我有点提醒过你们，答案应该控制在100个单词左右。所以如果你写了多一点，我们并不介意。如果你确实想要重新评分请求，我会去数一下你的单词数并做出相应处理。
- en: a decision but like 120 probably too much in that case。 Question。 >> [inaudible]
    >> Good question。 The question is， hey， wait a minute。 I didn't know about this，
    pipe filling up business。 Is that the way right works or is that the pipe thing？
    It actually is， a pipe。 It's a built in Linux issue is that pipes can fill up。
    They only make so much。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个决策，但在这种情况下，120可能太多了。问题。 >> [听不清] >> 好问题。问题是，嘿，等一下。我不知道这个管道填满的事儿。那是对的吗？还是管道的事？实际上是的，它是一个管道。它是一个内置的Linux问题，管道会填满。它们只有这么多空间。
- en: space for the pipe in Linux。 And so what all it does， it generally doesn't break
    things。 Although if you don't understand that like this code， it would break our
    code if we tried。 the D interleave because we never really talked about that。
    No。 We didn't talk about that in。 the sense that there might have been a piazza
    question about it。 Maybe it was last quarter。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，管道的空间。它的作用是，通常不会打破东西。虽然如果你不了解的话，就像这段代码，如果我们尝试并行解交错，它会破坏我们的代码，因为我们从未真正讨论过这个。没有。我们没有从这个角度讨论过。可能在Piazza上有过一个问题。也许是上个学期的事。
- en: But the point is that the pipes can fill up。 What do they do？ They just block
    until things。 lessen up again。 And if for some reason you're doing something walky
    like that program and。 trying to collect all the data at once， that can be a problem。
    So that's kind of why I gave。 it on the exam was， hey， here's something new。 Oh，
    what do you think about this？ Oh， now。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但关键是，管道会填满。它们会怎么做？它们会阻塞，直到情况稍微好转。如果因为某种原因你做了一些奇怪的事情，比如那个程序，试图一次性收集所有数据，那可能会是个问题。所以我在考试中给了这个题目，是为了让大家知道，“嘿，这是个新问题，你怎么看？”
- en: the pipes can fill up。 What do you think about it？ That's kind of why I put
    it on there。 Is this what I mean？ No， you didn't know the pipes could fill up。
    No， what I'm saying is。 you might have known that。 The midterm said it。 Oh， yeah，
    yeah， there was a section。 Oh， sorry。 Yeah， sorry。 The Mitch， go back and read
    the midterm。 It did say that that was the whole， point of。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可能会填满。你觉得怎么样？这就是我为什么把它放在那里。是这个意思吗？不，你不知道管道会填满。不是，我是说，你可能知道。期中考试上说过。哦，是的，确实有一部分。哦，抱歉。是的，抱歉。米奇，回去看一下期中考试。它确实说了，那个就是重点。
- en: yeah， the pipes could fill up。 Sorry， you didn't read that question。 One of
    the pipes could not physically close the file。 No， good question to when the pipes。
    fill up is a closed file。 No， no， it just blocks on it and says， oh， if you want
    to write。 more data， I can't accept more data。 I'm just going to block you from
    writing more data until。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，管道可能会满。抱歉，你没有读到那个问题。一个管道可能无法物理上关闭文件。没有，问题很好，当管道填满时文件会关闭吗？不，不会，管道会阻塞并说，哦，如果你想写入更多数据，我不能接受更多数据，直到。
- en: somebody else reads and then you'll be able to block。 I'm doing it。 We're going
    to see an。 example of something similar to that in threading today where there's
    this， there's this， reader。 writer， kind of dance that has to happen where you've
    only got so much space and you need。 to figure that part out。 So good question
    on that。 Very good question。 Yeah。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人阅读后，你就可以阻塞。我会做的。今天我们会看到一个类似的例子，关于线程中的情况，这里有一个读写者的“舞蹈”，必须进行一些操作，因为你只有有限的空间，你需要弄清楚该如何处理。这个问题问得很好，非常好。
- en: A little more technical question about main。 Yes。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于主函数的一个更技术性的问题。是的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_28.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_28.png)'
- en: So in my phone， I have four loop。 You had a four loop。 It's kind of around this。
    Okay， that。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在我的手机上，我有一个循环。你有一个循环。它大致围绕这个展开。好的，那个。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_30.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_30.png)'
- en: probably could work。 Sure。 It's still such that I didn't get that。 Oh， put a
    regurg question。 if you think that's right。 That's a doing the weight PID in a
    loop where you check for all。 the children waiting is perfectly legitimate。 You
    absolutely could do that。 So put a regurg。 question for that。 Any other questions
    on the？ I don't want to get into too many details。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是可行的。当然，它仍然是这样，我没搞明白。哦，放一个回溯问题。如果你认为那是对的。那是做循环中等待 PID 的问题，你检查所有子进程的等待是完全合法的。你绝对可以这么做。所以为此放一个回溯问题。还有其他关于这个问题的问题吗？我不想进入太多的细节。
- en: about the exam， but if you do think we graded it incorrectly， please let us
    know。 As I said。 we're trying to be fair in the regrade process， but we're going
    to be， you know， we're going。 to be not going to just let you kind of redo your
    test and the regrade process。 You've been。 through that。 Okay。 All right。 And
    as I said， overall， pretty good on the midterm。 I think。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于考试，如果你认为我们批改错了，请告诉我们。正如我说的，我们会尽力做到公平，但我们也不会让你重新做测试并在重新评分过程中作弊。你们都经历过这个过程了。好了，明白了。正如我所说，期中考试整体来说还不错，我认为。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_32.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_32.png)'
- en: it was a challenging midterm， but overall people did all right。 And if you didn't
    do so great。 feel free to email me and we can chat about going forward and trying
    to pick things up， a little。 And you've also got the final and other assignments
    and so forth。 Okay。 All right。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这次期中考试很有挑战性，但总体来说大家表现还不错。如果你发挥得不好，随时可以给我发邮件，我们可以讨论一下如何改进，稍微提升一下。而且你们还要准备期末考试和其他作业等等。好的，明白了。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_34.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_34.png)'
- en: So I know you're all thinking about Stanford Shell， which has nothing to do
    with threading。 but I did figure that last week you were all thinking， Oh my gosh，
    I got this midterm coming。 up and we went over， we went over mutexes and then
    CVs and semaphores and it was all wicked， fast。 And what I wanted to do is kind
    of go back and just kind of review what they are。 Let。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你们都在想斯坦福 Shell，它和线程没什么关系。但我发现上周你们都在想，天啊，我有期中考试要来了，我们复习了互斥锁、条件变量和信号量，都讲得非常快。我想做的是回过头来复习一下这些内容。让我。
- en: you get all the questions out that you might still have about those or new questions
    or。 and then we'll see a couple more small examples。 Okay。 I'm not going to actually
    do any like。 live like stuff today。 I just have some examples and we'll go over
    them as we go。 Okay。 So in。 threading， we have to have this ability to handle
    race conditions。 We have to have the。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把你可能还有的问题或者新问题提出来。然后我们再看几个小的例子。好的，今天我不会做实际的现场操作。我只会提供一些例子，我们在讨论时一一讲解。好的。在多线程中，我们必须具备处理竞态条件的能力。我们必须有这个能力。
- en: ability for two or more threads to to either act in a similar section of code
    or act on a。 data structure in a way that won't corrupt the data structure。 And
    this is just something。 that you have to deal with。 Race conditions happen all
    the time when you're doing this。 threads just like， just like multi crossing。
    We have a different， a few different ways of。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使得两个或多个线程能够在同一段代码中或以不会破坏数据结构的方式操作数据结构。这是你必须处理的问题。竞态条件在做这些操作时总是会发生。线程就像，多线程交叉。我们有几种不同的方法来解决这个问题。
- en: doing that。 We kind of walked through them last week。 The main one is， and this
    is the kind。 of the underlying one for most of these is a mutex。 Okay。 A mutex
    and we'll go over the， details。 I'll just kind of list through here。 The mutex
    is the first one we learned about， and we'll。 we'll see examples of that in a
    minute。 A conditioned variable， any mutex has。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 做这些事情。我们上周大致讲过这些。主要的那个是，这是大多数这些情况的基础，就是互斥锁。好的，我们将讲解细节。我会在这里列出这些内容。互斥锁是我们学到的第一个，我们稍后会看到它的例子。条件变量，任何互斥锁都有。
- en: no ability for two threads to signal another thread that they're done。 Right。
    Now the。 signaling can happen by the fact that one thread will actually release
    the lock and the。 other thread will gain the lock。 So that is in some sense a
    signal， but it's not a， distinct like。 Hey， anybody who's waiting， go ahead and
    continue。 So there has to be some。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有能力让两个线程相互通知另一个线程它们已经完成。对，现在，信号可以通过其中一个线程释放锁，另一个线程获得锁的方式发生。从某种意义上说，这是一个信号，但它不是那种明确的，像“嘿，任何正在等待的人，都可以继续”的信号。所以必须有一些。
- en: ability to do that if you don't want to busy wait or， or if you don't want to
    just have。 a regular straight up lock。 Okay。 This is particularly important when
    you have multiple， things。 trying to access a particular data， a particular like
    section of code， and it。 could be more than one。 You can't really handle that
    directly with a mutex。 So that's where。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想进行忙等，或者不想仅仅使用常规的锁，这项能力就非常重要。好的，这在你有多个实体试图访问某个特定的数据或特定代码段时尤为重要，可能不止一个。你不能仅仅用互斥锁直接处理这种情况。所以这时候就需要。
- en: a conditioned variable， any comes in。 And then there are all sorts of things
    you can do。 with a conditional variable， any that we happen to do a lot， namely
    waiting for permits and， saying。 Hey， here's a whole bunch of thread or a whole
    bunch of permits that a bunch of。 threads can work at once。 And so what we said
    was， well， let's， we can use a， conditioned variable。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量，于是就出现了。接着，你可以用条件变量做各种各样的事情，其中我们常做的一件事就是等待许可，并且说，“嘿，这里有一大堆许可，很多线程可以同时工作。”所以我们说，嗯，我们可以使用一个条件变量。
- en: any， but let's actually， let's actually build it up such that we。 build it into
    this other thing called a semaphore， which is a different type of， data structure。
    Fairly easy to build has some nuances that we'll talk about later， today。 And
    it allows you to。 whoops， allows you to go ahead and build more structures a，
    little easier than a conditional。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何，但实际上，让我们来一步步构建它，将其构建为另一种数据结构——信号量，它是一种不同类型的。相对容易构建，但有一些细微之处，我们稍后会讨论。它允许你，哎呀，它允许你构建更多的结构，比条件变量更容易一些。
- en: a conditioned variable， any。 Okay。 So let's review these。 Okay。 Let's review
    all of them。 In fact。 the， let's see， here we go， maybe not。 There we go。 Okay。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量，任何。好的，来复习一下这些内容。好的，实际上，让我们复习所有的内容。实际上，让我看看，可能不行。好了。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_36.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_36.png)'
- en: So the mutex， okay。 And you can use these slides as kind of a reference to if
    you'd like。 The mutex is a， it's a lock。 Okay。 And it has two things you can do
    with it。 You can say。 either lock or unlock。 And what happens is when a thread
    takes this mutex and locks it， if no。 one else is locked it yet， it gets that
    and it moves on to the next line of code。 Okay。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以互斥锁，好。你可以把这些幻灯片当作参考，互斥锁是一种锁。好的，它有两个操作。你可以说，要么锁定，要么解锁。当一个线程获取到这个互斥锁并锁定它时，如果没有其他线程已经锁定它，它就可以拿到锁并继续执行下一行代码。好的。
- en: And it's that straightforward。 If another thread comes in and attempts to use
    the lock， but the。 first， the first thread is still using it， then what happens
    is the， the second thread。 blocks until the other thread unlocks it。 Okay。 And
    that's the big details there that you。 should care about。 Okay。 You have to pass
    a mutex by reference or by pointer。 Why？ Because they。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。如果另一个线程进来并尝试使用锁，但第一个线程仍在使用它，那么发生的情况是，第二个线程会阻塞，直到第一个线程解锁。好了。这些就是你应该关注的重点。你必须通过引用或指针传递互斥锁。为什么？因为它们。
- en: actually need to share the same mutex。 It can't be a copy of a mutex because
    then the data。 wouldn't be shared。 And that's how it works。 And by the way， under
    the hood， if you take。 a parallel processing class or you take maybe an operating
    systems class， they might talk。 about it uses atomic instructions under the hood
    to create the mutex so that two threads。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上需要共享相同的互斥锁。不能是互斥锁的副本，因为那样数据就无法共享了。这就是它的工作原理。顺便提一下，如果你上过并行处理课程或操作系统课程，他们可能会提到，底层是通过原子指令来创建互斥锁，以便两个线程能够共享。
- en: can't get it at the same time。 So there's a little more hardware support and
    operating system。 support for doing this。 But that's basically how it works。 Okay。
    The thread obtains to lock。 and then executes the next line of code。 If it， if
    the other thread can't get it because the。 lock is already taken， the code waits
    and then until the lock is unlocked。 The only thread。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无法同时获取它。所以在硬件和操作系统方面会有更多支持来执行这个操作。但基本上就是这样。好了，线程获取锁之后，会执行下一行代码。如果另一个线程无法获取锁，因为锁已经被占用了，代码就会等待，直到锁被解锁。只有线程。
- en: available to， the only thread allowed to unlock is the one that locked it。 Okay。
    It's all。 it's undefined behavior if another thread tries to unlock a lock thread
    and it wasn't the。 one that did it。 Yeah。 Question。 Go ahead。 I'm listening。 I'm
    trying to get this tablet。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 只有锁定它的线程才能解锁。好了。如果另一个线程尝试解锁一个线程，但它并不是锁定它的那个线程，那就是未定义行为。是的。问题。继续，我在听。我正在尝试弄清楚这个平板。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_38.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_38.png)'
- en: thing working。 Yeah。 You don't remember your question？ Oh， okay。 What's that？
    Okay。 All， right。 So let's see。 I'm going to try this one more time with the tablet
    and see if it。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 工作正常。是的。你不记得你的问题了？哦，好的。那是什么？好的。那么，让我们再试一次，我要用这个平板试试，看看它是否。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_40.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_40.png)'
- en: were。 Go ahead。 What's your question？ Is that the boot waiting or is that like
    okay？
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。继续。你的问题是什么？是等待启动，还是可以继续？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_42.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_42.png)'
- en: Oh， that is okay waiting。 Okay。 Good question。 The question was， "Is that busy
    waiting or。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，等待是可以的。好的，问题很好。问题是，“那是忙碌等待吗，还是？”
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_44.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_44.png)'
- en: is it okay waiting？" That is okay waiting。 But it is， but it doesn't always
    solve all。 of our problems。 Right。 So the permits part can't really do that one
    mutex or even just。 a few mutexes because as we saw with the traveling， or the
    traveling philosopher， I'm mixing my。 my big problems in the world with the， with
    the dining philosophers， you can't， you have。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 等待是可以的吗？" 是的，等待是可以的。但它并不总是能解决我们所有的问题。对吧？所以许可证部分不能真的做那种单一的互斥锁，甚至几个互斥锁。因为正如我们在旅行中的哲学家问题中看到的，我把世界上的大问题和用餐哲学家问题混在了一起，你无法，你必须。
- en: to have the ability to say， "Oh， I'm limiting it to so many people being able
    to do this。 So many threads doing something with that。" So it's， you have to，
    you have to wait on， that。 Okay。 All right。 So。 Other question？ Yes。 Eva。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有能力说，“哦，我限制了只有这么多人能做这件事。所以很多线程会做这件事。”所以，你必须，你必须等待那个。好了。其他问题？是的，Eva。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_46.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_46.png)'
- en: What is the text look like in terms of boxers or friends？ Sure。 The same problem。
    [inaudible]。 It's an interesting question。 The question is， "What is going on
    with when， when there's。 locks and file descriptors？" Remember， a lock has no
    information about the rest of the， system。 Okay。 If a thread， if two threads happen
    to be working on the same file descriptor。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文本在拳击手或者朋友之间看起来是什么样的？当然。是一样的问题。[听不清]。这是一个有趣的问题。问题是，“当有锁和文件描述符时，发生了什么？”记住，锁并没有关于系统其余部分的信息。好了，如果两个线程碰巧在同一个文件描述符上工作。
- en: if one thread reads a bit， the other thread will read later in the file descriptor，
    but， there's no。 they， they could read at the same time and it would just interleave
    it as， as， is necessary。 But yeah， if you want to read only apart from one thread
    and then something， from another thread。 having a mutex is perfectly fine and
    you can order it that way if you want， to。 But yeah。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程读取某个位置，另一个线程会稍后在文件描述符中读取，但没有冲突。它们可以同时读取，程序会按需交替执行。但是，如果你想从一个线程中读取，然后从另一个线程读取，使用互斥锁是完全可以的，你可以按需要进行排序。但是，是的。
- en: there's no， no other reason。 Remember， mutexes are relatively simple。 You either
    hold the lock or you don't and anybody， any other thread that tries to get the
    lock。 can't while you're holding it。 That's the， the whole business with a， with
    a mutex。 Okay。 All right。 Let's move on to， oh， let's see。 A couple other things
    about it。 Oh， you should。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有，没有其他原因。记住，互斥锁相对简单。你要么持有锁，要么不持有，任何其他线程尝试获取锁时，无法在你持有锁的情况下获取。互斥锁就是这么回事。好了，接下来，我们来看看，哦，关于它的其他一些事情。哦，你应该。
- en: try to hold a mutex for as short a time as possible。 Okay。 Why？ Because if other
    threads。 are trying to access that lock and you're still holding it because you're
    doing something， else。 if it doesn't matter to your， if it doesn't matter to your
    logic that the lock is still， held。 release it earlier。 Sometimes it's inevitable
    and you have to release it， you know， later。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量将互斥锁持有的时间缩短。好了，为什么？因为如果其他线程正在尝试访问那个锁，而你仍在持有它做其他事情，如果这对你的逻辑没有影响，你可以提前释放它。有时候是不可避免的，你不得不稍后释放它。
- en: on because you're still using that data structure， but you want to really hold
    them for as short。 a time as possible。 Okay。 Let's see。 Deadlock， which is when
    two threads are kind of waiting。 on each other， that's not really possible with
    a mutex， with a single mutex because either。 one lock or one thread has it or
    not， it's not like they both can have it。 If you have。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你仍在使用那个数据结构，但你希望尽可能短地持有它们。好了，让我们看看。死锁，是指两个线程相互等待，这在使用单个互斥锁时是不可行的，因为只有一个线程可以持有它，不能同时由两个线程持有。如果你有。
- en: multiple mutexes， that's when we start getting into the deadlock problem， which
    is why we have。 to go on to figure out other ways of doing this。 Okay。 So one
    nice， very nice helper class。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 多个互斥锁，这就是我们开始遇到死锁问题的时候，这也是我们必须继续研究其他方法的原因。好了。那么有一个很好的，非常好的辅助类。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_48.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_48.png)'
- en: that's the easiest class in the entire world is this thing called a lock guard。
    And a lock。 guard is as simple as this。 It has two methods， a constructor and
    a destructor， the constructor。 locks the lock， the destructor unlocks the lock
    and that's it。 There are no other functions。 no other variables， nothing。 Okay。
    Just， you know， locks that are unlocks it and that's， it。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上最简单的类就是这个叫做锁保护（lock guard）的东西。锁保护就是这么简单。它有两个方法，一个是构造函数，一个是析构函数，构造函数锁定锁，析构函数解锁锁，仅此而已。没有其他功能，没有其他变量，什么都没有。好了，就这样，锁定后解锁，就这么简单。
- en: It takes a mutex as its parameter， so I guess that's the one variable it may
    hold as a reference。 to the mutex。 And what it's nice for is if you know that
    you are going to use a lock and。 then like leave a function or leave a while，
    the whole function， you might as well put a。 lock guard around it so you don't
    have to remember to unlock before you leave。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它将互斥锁作为参数，所以我想这是它作为引用持有的唯一变量。它的好处是，如果你知道你将使用锁，然后离开一个函数或 `while` 循环，整个函数，你最好围绕它放一个锁保护，这样你就不需要记得在离开之前解锁了。
- en: It'll happen automatically， for you。 And it's nice in cases where you have conditional
    behavior where maybe your。 insides on while loop and you return from that while
    you're great， the lock gets unlocked， for you。 You don't have to remember to do
    it。 Or if you're out， if you break out of the。 while loop and then leave the function，
    the lock， the mutex will get unlocked for you as， well。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动为你处理。在需要条件行为的情况下，它非常有用，比如当你在 `while` 循环中，而你从循环中返回时，锁会为你自动解锁。你无需记得去做。如果你跳出
    `while` 循环然后离开函数，锁也会为你解锁。
- en: This is a very nice convenience class to use。 If you know that you have to do
    that。 Sometimes you can't get away from it because you do need to unlock。 And
    again， don't keep。 don't put a lock guard at the top of your function just because
    it's nice to use。 If you。 know that there's other things you're going to be doing
    in that function that other threads。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常方便的类。如果你知道必须这么做。有时候你无法避免它，因为确实需要解锁。而且再次提醒，不要仅仅因为它好用，就在函数的开头放上锁保护。如果你知道函数中还有其他操作，可能会被其他线程打断。
- en: might want that lock。 That would be a bad use of it。 Okay？ But you'll see more
    examples。 of doing this。 Okay？ All right。 That's a lock guard。 Now， a conditional
    variable， any。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会想要那个锁。这会是一个不好的用法。明白吗？但你会看到更多的例子。好吗？好了，这就是锁保护。现在是条件变量`any`。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_50.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_50.png)'
- en: This is the one that's a little trickier to understand。 Let's review what it
    does。 Okay？
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个稍微有点难理解。我们来回顾一下它的功能。好吗？
- en: It works in conjunction with a mutex。 So you have a mutex and then a conditional
    variable。 any has the ability to wait for a signal based on that mutex。 Okay？
    So， based on that， okay？
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它与互斥锁一起工作。所以你有一个互斥锁，然后条件变量`any`能够基于该互斥锁等待信号。明白吗？所以，基于这个原理，明白了吗？
- en: So basically what it does is it takes the mutex and you lock the mutex and then
    you。 do a wait on that mutex which is this conditional variable， any that uses
    the mutex。 The conditional variable， any， will push you off the processor because
    you're waiting for。 something to happen and then it will unlock the lock。 So it's
    very similar to SIG suspend。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上它的工作原理是：它获取互斥锁，然后你在这个互斥锁上执行等待操作，这个条件变量`any`使用的是这个互斥锁。条件变量`any`会把你从处理器中移除，因为你在等待某些事情发生，然后它会解锁。因此，它和SIG
    suspend非常相似。
- en: in that case。 Okay？ You can think of it as an analogous to that。 But the user
    should always。 lock the mutex first。 Then you're generally going to check some
    condition。 Okay？ And you。 are going to， if the condition is met， you are going
    to go on to the next bit of code。 So this is where conditional variable， any，
    could be a little bit easier to use。 We will。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下。你可以把它想象成类似的情况。但用户应该始终先锁定互斥锁。然后你通常会检查一些条件。好吗？如果条件满足，你就会继续执行下一段代码。所以，这就是条件变量`any`可能稍微容易使用的地方。我们将会继续讨论。
- en: make it easier to use in a minute。 Okay？ And when you get this notification，
    the， thread， the。 the wait function tries to reacquired that lock。 It may not
    be possible because two。 threads are waiting and if they both get a signal at
    the same time， which often happens。 when we do conditional variable， any notify
    all， CV notify all。 When those two get that。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会让它更容易使用。好吗？当你收到通知时，线程中的等待函数会尝试重新获取那个锁。这可能不可行，因为两个线程在等待，如果它们同时收到信号，通常会发生这种情况。这就是我们在使用条件变量`any
    notify all`时常见的情形。当这两个线程同时接收到信号时。
- en: signal at the same time， they race to acquire the lock。 One of them gets it。
    The other one。 just continues waiting。 Okay？ So that's the deal with conditional
    variable， any's， and， their。 their ability to， to do that。 And when the wait，
    on， when the wait comes out of the。 wait that you are not， you now have the， you
    have the lock again。 So when you get a signal。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同时发出信号，它们竞相获取锁。一个线程获取到锁，另一个则继续等待。明白了吗？这就是条件变量`any`的工作方式，它们的能力就是这样。当等待条件满足后，你就会重新获取锁。所以当你收到信号时，情况就是这样。
- en: once you get the wait， then you actually acquire the lock again。 So you should
    unlock it later。 Okay？ That's how the conditional variable， any works。 We use
    this often to do permitting。 where you say I have these x number of permits and
    I have those number of， you know， y number。 of threads， which is more than x，
    trying to access this and I say only that many can do， it。 Okay？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了等待信号，你就会重新获取锁。所以你应该稍后解锁它。明白吗？这就是条件变量`any`的工作原理。我们常常用它来做许可控制。比如你说我有x个许可，而有y个线程，数量大于x，试图访问这个资源，我只允许这么多线程去访问。明白了吗？
- en: And the general idea is you're going to have something you're waiting on， the，
    permits in this case。 while it's equal to zero， you're going to just keep waiting。
    And the， the。 the other function will say， increment the number of permits and
    then notify everybody。 Okay？
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总体的思路是你会等待某些东西，在这个例子中是许可。当许可数为零时，你就会一直等待。然后，另一个函数会说，增加许可数量，并通知所有人。明白吗？
- en: That's how， and then that's when you would check， you would try to acquire the，
    lock。 you'd acquire the lock， you'd recheck the permits， see that it's one， go
    out of， that thing。 and then you would decrement the permits because now you've
    got your holding， one。 So the conditional variable， any， if you understand it，
    you go， oh， I see what's going， on here。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，然后在那时你会检查，你会尝试获取锁。你会获取锁，然后重新检查许可数，看到它是1，跳出那个东西。然后你会递减许可数，因为现在你持有了1个。所以条件变量`any`，如果你理解它，你会明白，哦，我明白这里发生了什么。
- en: There's lots of， you know， lots of nuance to say， or lots of incrementing and。
    decrementing because you're trying to keep track of this one variable， which is
    a permits。 type variable。 Okay？ So that's， that's what you have to do。 That's
    what the conditional， variable。 any does。 Because of this weight being a really，
    or because of this while loop being， really common。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多，你知道，有很多细微的差别，或者有很多递增和递减，因为你试图跟踪这个变量，它是一个许可类型变量。好吗？所以那就是，你必须做的事情。这就是条件变量`any`的作用。因为这个权重非常常见，或者因为这个`while`循环非常常见。
- en: well， they built into a conditional variable， any， the weight into another variable。
    or they built that， while loop into a second version of weight， which works like
    this， it。 takes the mutex， just like the regular conditional variable， any weight，
    and then it takes a。 predicate， which means a function that returns true or false。
    Okay？ That's the while condition。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，他们把条件变量`any`的权重内嵌到另一个变量中，或者他们把`while`循环内嵌到第二个版本的权重中，它是这样工作的，先获取互斥锁，就像常规的条件变量`any`等待一样，然后它接受一个谓词，即一个返回`true`或`false`的函数。好吗？这就是`while`条件。
- en: and it actually does it in the opposite way， which is， you can read it like
    this。 Okay？ And。 this is important。 If you read it， it basically this down here，
    and often we make that function。 into a lambda function because we can。 Otherwise，
    we'd have to call it as a separate function。 which sometimes is a little awkward。
    But in this case， we just call， do it as a lambda， function。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上是以相反的方式做的，你可以这样阅读它。好吗？这是很重要的。如果你读它，基本上是下面这样，通常我们会把那个函数转换成一个`lambda`函数，因为我们可以。否则，我们就必须把它作为一个单独的函数调用，这有时会有点尴尬。但在这种情况下，我们直接调用它作为`lambda`函数。
- en: We say like in this case， C V weight on the mutex， on mutex M， we pass in the。
    number of permits so that we can access it。 This is in the capture clause。 And
    then we， say。 return permits greater than zero。 So you can say， wait until permits
    is greater than， zero。 That's basically what this is saying。 Okay？ I like to use
    that， that， like， until， in this case。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，在这种情况下，`C V`在互斥锁`M`上等待，我们传入许可数，以便我们可以访问它。这是在捕获子句中。然后我们说，返回许可数大于零。所以你可以说，等待直到许可数大于零。基本上这就是它的意思。好吗？我喜欢在这种情况下使用`until`。
- en: wait until permits is greater than zero。 Because it's really while not。 permits
    is greater than zero， keep waiting。 That's kind of what it really is。 But in this，
    case。 we just think， I just think of it as like， okay， well， when permits becomes
    greater， than zero。 that's when I can exit this wait。 Okay？ That's what we're
    looking for， the， untill part of that。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 等待直到许可数大于零。因为实际上是当许可数不大于零时，持续等待。那基本上就是它的意思。但在这种情况下，我只是把它想象成，好吧，许可数大于零时，我就可以退出等待。好吗？那就是我们要寻找的，`until`部分。
- en: Okay？ So that's how conditional variable n is work。 You'll see， those in lab
    this week。 and you will practice using those a bit in lab。 Okay？ But again， you
    still have to。 with using these conditional variable n is you still have to do
    the things。 like keep track of the permits directly yourself。 Okay？ And that's
    maybe or maybe not what you。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？所以这就是条件变量`n`的工作方式。你们本周在实验中会看到它们，并且会在实验中稍微练习一下。好吗？但再说一次，使用这些条件变量`n`时，你仍然需要像直接自己跟踪许可数这样的事情。好吗？也许是，也许不是你想要的。
- en: want to do。 If you don't want to do that， well， we have another way。 Okay？ The
    next thing。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你想做的。如果你不想做那个，嗯，我们有另一种方式。好吗？接下来。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_52.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_52.png)'
- en: we're going to look at is the semaphore class。 So a semaphore is also relatively
    low level。 although for whatever reason， it's not built into C++ for us。 Okay？
    Why？ Could be because。 it's actually really easy to build。 We'll take a look at
    the code again in a second。 But second of all， once we build it， we can use it
    and we will allow you to use it for。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的是信号量类。所以信号量也是相对低级的，尽管不知道为什么它没有被内建到 C++ 中。好吧？为什么？可能是因为它其实非常容易构建。我们马上再看看代码。但是第二个原因是，一旦我们构建了它，我们可以使用它，并且允许你在剩下的作业中使用它。
- en: the rest of the assignments。 We've already built it for you and I'll show you
    that。 But here's how it works。 It takes away all of that increment and decrement
    the permits。 and does it for you。 It's very nice。 Okay？ It's really easy to set
    up a semaphore。 Okay？
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为你构建好了，我会展示给你看。但它是这样工作的。它移除了所有的递增和递减许可，并为你完成这些。非常好。好吧？设置信号量真的很容易。好吧？
- en: You basically say semaphore permits five and that says there are five permits。
    Okay？ And。 if you do permits dot wait， what it does is it looks and goes， oh，
    how many of the five。 have been used？ Oh， none of them？ Okay。 You get one。 And
    it gives you one and then it。 decrements the permits。 Now four are available。
    All the way down to zero。 When there are。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你说 semaphore permits 五，这意味着有五个许可。好吧？然后，如果你执行 permits dot wait，它会查看，哦，五个许可中有多少个被使用了？哦，没用过一个？好吧。你得到一个。然后它给你一个，并且减少许可。现在剩下四个。一直减少到零。当有。
- en: zero available， it just waits。 Okay？ And then when you say permits dot signal，
    that。 is you giving up the permit， telling anyone else waiting for the permit
    to， waiting。 for the semaphore， I have released one， go fight for the one I just
    released。 Okay？ And。 the only time that actually signal gets sent is when you
    go from zero to one because。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用为零，它就会等待。好吧？然后当你说 permits dot signal 时，那就是你放弃许可，告诉任何其他等待许可的人，等待信号量，我已经释放了一个，去争夺我刚刚释放的那个。好吧？而且，唯一会发送信号的时刻是从零到一的时候，因为。
- en: that's the only way it matters。 Otherwise it will always be able to get the
    permit。 Okay？
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是唯一重要的地方。否则，它总是能获得许可。好吧？
- en: So that's how that works。 You can think of a mutex as a special case of a semaphore。
    with one permit， kind of。 Okay？ You shouldn't， in fact， if you go look at this
    up on like。 stack overflow， there's lots of people saying， don't think of it that
    way。 That's not a good， way。 It's not exactly the same。 Some people have said，
    oh， this is exactly the same。 It's not， really。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是它的工作原理。你可以把 mutex 看作是信号量的一个特例，带有一个许可，差不多。好吧？你不应该，事实上，如果你去查找，比如 Stack Overflow
    上，有很多人说，不要这么想。这不是一个好方法。它并不完全一样。有些人说哦，这是完全一样的。其实并不是。
- en: But you can think of it as being one permit， except that now you can actually
    do。 a signal when you're done with it。 And the interesting thing about a semaphore
    is you。 can signal from， well， you don't have to be the one acquiring the lock
    to signal。 Like。 that's the big difference there。 Mutex， the only person， the
    only thread that can unlock。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以把它看作是一个许可，只不过现在你实际上可以在完成后发出信号。而信号量的有趣之处在于，你可以发出信号，即使你不是获得锁的那个。就这是其中的一个大区别。mutex，唯一能够解锁的是持有锁的那个线程。
- en: the mutex is the one that locked it。 That's kind of the other difference there。
    Okay？ Now。 a couple things we didn't talk about， semaphores。 What would a semaphore。
    initialized with zero mean？ What do you guys think？ If I do the semaphore， initialized
    to one。 it would mean there's one permit。 And if I do a semaphore， two threads，
    fighting for it。 And one。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: mutex 是锁定它的那个。那就是另一种区别。好吧？现在，有几件事我们没有谈到，信号量。一个初始化为零的信号量意味着什么？你们觉得呢？如果我做一个信号量，初始化为一，它意味着有一个许可。如果我做一个信号量，两个线程在争夺它。然后其中一个。
- en: they both try to get it， one will get it， then when that one， signals， the other
    one will get it。 What would a semaphore with permits of zero mean？ What， do you
    think， Cosner？ [inaudible]， Well。 so it's a good question。 The question is， would
    it just hang？ If you had two threads。 trying to get there， it would， they would
    both wait。 Until what？ What do you think？ [inaudible]。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都试图获取它，一个会获得它，然后当那个发出信号时，另一个会获得它。一个许可为零的信号量意味着什么？你觉得呢，Cosner？[听不清]，好吧。所以这是个好问题。问题是，如果它只是挂起呢？如果有两个线程在争取，它们会都等待。直到什么？你觉得呢？[听不清]。
- en: Only the parent can access the data。 Not quite。 You're on the right track。 Somebody
    else has to do something。 What do we say locks for mutex？
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只有父线程可以访问数据。不完全是。你在正确的轨道上。别人需要做一些事情。我们说互斥锁用来做什么？
- en: The only thing that can release the mutex is to unlock it， is the one that locked
    it。 Is that true for semaphores？ No。 Anybody can signal on a semaphore。 Right？
    So this。 so you're getting there。 Anybody else want to take a step at what this，
    actually means？
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一能释放互斥锁的就是那个锁定它的线程。这对于信号量也适用吗？不。任何人都可以对信号量进行信号操作，对吧？所以这样，你慢慢理解了。还有人想尝试解释一下这到底意味着什么吗？
- en: This is actually an interesting case。 Yeah， go ahead。 [inaudible]， Yeah。 you're
    waiting for some other thread to signal you。 And it doesn't matter if the other
    thread。 never needed to wait for that permit necessarily。 Right？ It's just a way
    to say， hey。 let some other signal， some other thread signal me。 Is that what
    you're going to say as well？ Yeah。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个有趣的案例。是的，继续。 [听不清]，是的，你在等待其他线程给你信号。无论其他线程是否必须等待那个许可都无关紧要，对吧？这只是表示，嘿，让其他信号，其他线程给我发信号。这也是你要说的吗？是的。
- en: there you go。 Okay， so that's what it is here。 We don't have any permits necessarily。
    Okay？
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。好的，这就是它的样子。我们不一定有许可证。好吗？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_54.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_54.png)'
- en: The permit wait means you just have to wait for a signal which can come from
    any other thread。 I'm going to show you an example of where this is another case
    of this where it's actually more interesting。 Yeah。 [inaudible]， Yeah， any thread
    can say permits。signal。 Okay？
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证等待意味着你只需要等待一个信号，这个信号可以来自任何其他线程。我将展示一个例子，说明这是另一个更有趣的情况。是的。[听不清]，是的，任何线程都可以发出许可证信号。好吗？
- en: It doesn't matter that it didn't have any locked begin with。 It might be that
    your logic says， hey。 this thread， this one thread needs to wait for something。
    In fact。 I'm going to show you an example in a second where it actually is useful。
    But it might say this thread needs to wait for a whole bunch of other stuff to
    happen and it's going to。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否没有任何锁定开始时并不重要。可能是你的逻辑说，嘿，某个线程，只有这个线程需要等待某些事情。事实上，我马上会给你展示一个例子，说明它实际上是有用的。但它可能会说，这个线程需要等待一大堆其他事情发生，然后它会继续。
- en: one of them is going to signal it。 When it finishes， it just waits。 It doesn't
    have a permit necessarily。 It doesn't need to lock anything until it just needs
    to get the signal。 It's really what it needs to do。 Okay？ I'll see that in a second。
    My next question is what if you then it said permits negative number？ What does
    that mean？
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个线程会发信号。当它完成时，它会等待。它不一定有许可。它不需要锁定任何东西，直到它需要获取信号。实际上，它只需要做这个。好吧？稍后我会展示给你。我的下一个问题是，如果它说许可证为负数呢？那是什么意思？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_56.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_56.png)'
- en: Let's look at the code too。 What are you going to say？ What are you going to
    say？ Yeah。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码。你打算怎么说？你打算怎么说？是的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_58.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_58.png)'
- en: '[inaudible]， Yeah， that''s exactly where that many different threads need to
    signal before it can actually do anything。 Let''s go look at the actual code for
    semaphore。 I''ve got to remember where it is。'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，是的，正是这样，许多不同的线程需要发信号才能实际执行任何操作。让我们去看看信号量的实际代码。我得记住它在哪儿。'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_60.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_60.png)'
- en: Let's see， slash user， slash class， CS110。 I think it's local source， I believe，
    and then threads。 There it is。 Okay。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，slash user，slash class，CS110。我想它是本地源，我相信，然后是线程。就在那里。好的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_62.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_62.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_63.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_63.png)'
- en: Semaphore。cc and you can all go look at this。 Okay。 Let's look at how this actually
    works。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Semaphore.cc，你们都可以去看看这个。好的。让我们看看它是如何工作的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_65.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_65.png)'
- en: By the way， it's got a bunch。 It's got a CV in there。 It's got a conditional
    variable because that's how we built it。 Let's look at the weight and the signal。
    Okay。 Weight does the following。 Okay。 Weight has this new text that it actually
    tries to acquire because it does need to update that value。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，它里面有很多东西。它有一个条件变量（CV）。它有一个条件变量，因为我们就是这么构建的。让我们看看权重和信号。好吧。权重做了以下事情。好吧。权重有这段新文本，它实际上尝试获取，因为它确实需要更新那个值。
- en: Okay。 So you have to have that lock in there in some case， in some sense。 Okay。
    Then it does a CV weight and it does basically wait until the value is greater
    than zero。 Okay。 And then it decrements the value once it actually acquires that
    lock。 Okay。 That's what weight does。 What does signal do？ Well， signal acquires
    the lock。 Okay。 And then increments the value。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以在某些情况下，你必须有那个锁。好的。然后它会执行一个条件变量的等待，基本上是等到那个值大于零。好的。然后它会在实际获得锁后减少那个值。好的。这就是`wait`的作用。`signal`是做什么的呢？嗯，`signal`会获取锁。好的。然后递增那个值。
- en: And then if the value becomes one， it notifies everyone。 Okay。 Yeah。 [inaudible]。
    MutexM is a class variable。 Yep。 It's a class。 If you look at， let's see if I
    can do this。 Actually。 we'll do it here。 Let's see。 It's there。 Include。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果值变为1，它就会通知所有人。好的。是的。[听不清]。`MutexM`是一个类变量。对。它是一个类。如果你看一下，嗯，我看看能不能做到。实际上，我们在这里做。看看。就在那。包含。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_67.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_67.png)'
- en: Some four dot eight。 There we go。 It is a， there it is。 It's a class variable。
    Right。 So when you create this， when you create the class， now you've got the
    mutex in there。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大约是四点八。好了，就是这样。它是一个，那里它就是了。它是一个类变量。对。 所以当你创建这个，创建类时，现在你已经有了互斥量。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_69.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_69.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_70.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_70.png)'
- en: So it's shared between the functions。 Okay。 All right。 So that's how signal
    and weight work。 Well。 notice that if the value， it's only， it's really only either
    incrementing or decrementing that value。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它在函数之间是共享的。好的。好吧。这就是`signal`和`wait`的工作原理。嗯。注意，如果值，它实际上只能递增或递减那个值。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_72.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_72.png)'
- en: So if you start that value off at some negative number， well， it's going to
    take a whole。 but that number kind of minus one number of signals to get up to
    one to actually。 to actually notify the weighting threads that it's actually been
    done。 Okay。 So what might this。 what is a， an example of when you might need this？
    Well， what if we did the final？
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你把这个值设为负数，那它就需要一段时间。但这个数字需要减去一个信号，才能增加到一，实际上，来通知等待的线程它已经完成了。好的。那么，什么时候你可能需要这个呢？嗯，如果我们做的是最后一步呢？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_74.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_74.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_75.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_75.png)'
- en: Okay。 Let's say we had a program where we had 10 threads we're creating and
    they each need to do something。 And then one more thread needs to wait for it
    to actually proceed with its thing。 Now。 you could do something like join all
    the 10 other threads and then do the next thing if you wanted to。 but maybe you
    want to keep those threads going。 Maybe you don't want to。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。假设我们有一个程序，里面创建了10个线程，它们每个都需要做某些事情。然后，还有一个线程需要等待，直到它继续做它的事情。现在，你可以做一些事情，比如将其他10个线程都加上`join`，然后做接下来的事情，如果你愿意的话。但也许你想让这些线程继续运行。也许你不想这么做。
- en: maybe you want to do other logic that's going to eventually， you know。 do something
    else in those threads or something like that。 So what you can do in this case
    is you can say， let's actually go and create these threads and then each thread
    does its thing。 In this case， it's just going to do a see out。 And then it's going
    to send a signal on that seven for it。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想做其他逻辑，最终，你知道的，做些其他事情或者在这些线程中做类似的事情。所以在这种情况下，你可以这样做：我们实际创建这些线程，然后每个线程执行它自己的任务。在这里，它只是会输出一个`cout`，然后它会在信号量上发出一个信号。
- en: And these， these thread has no idea which like number it's incrementing。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 而这些线程根本不知道它们正在递增哪个数字。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_77.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_77.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_78.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_78.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_79.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_79.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_80.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_80.png)'
- en: It's because look， I'm done with my stuff。 I'm signaling anybody cares。 I'm
    done。 And it signals it。 Right。 And then the read after 10 function here。 Well，
    it just waits。 And because we。 we started out this semaphore in this case， negative
    nine。 Okay。 Once there's 10 things that happen。 it gets incremented to one。 And
    that's when the signal， the way it happens。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就是因为，看，我已经完成了我的任务。如果有谁在乎，我会发出信号。我做完了。然后它发出了信号。对。然后这里的`read after 10`函数呢。嗯，它只会等待。因为我们一开始把这个信号量设置为负9。好的。等到发生了10件事情后，它就会递增到1。然后信号就会发出，事情也就发生了。
- en: And that's when the actual semaphore will allow the， like to continue。 By the
    way。 bring you back down to zero as it turns out。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实际的信号量就会允许线程继续执行。顺便提一下，最终会将信号量的值降到零。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_82.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_82.png)'
- en: But that's a way to do a signal like that through a thread that makes it so
    that you can do 10 things in a row。 And the last one gets to work last like that。
    So let's try this。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就是通过线程传递信号的方式，它让你可以依次完成10件事。最后一件事会最后执行。我们试试这个。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_84.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_84.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_85.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_85.png)'
- en: Let's see。 My lecture。 Red。 CPP。 I think it is negative semaphore。 Okay。 So
    it's negative semaphore which should be exactly what I just said it is。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我的讲座文件，应该是Red.CPP。我想它应该就是负数信号量。好的，确实是负数信号量，正是我刚才所说的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_87.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_87.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_88.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_88.png)'
- en: And there's where， by the way， there's where we're creating the semaphore negative
    nine。 Okay。 And then passing that semaphore is reference into all the other。 all
    the 11 threads we happen to have。 And negative semaphore， there we go。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，顺便说一句，我们在这里创建了一个值为负9的信号量。好的。然后将这个信号量的引用传递给所有其他线程——我们有11个线程。负数信号量，就是这样。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_90.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_90.png)'
- en: So the threads， they all did in their own order， which they're going to。 Each
    one signaled after it got done。 And then when the last one received all those
    signals。 it proceeded。 And that's how it worked。 Okay。 So questions on the new
    kind of way we might use。 So we're going to see an example in a second。 A bigger
    example in a minute。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些线程，它们都按照各自的顺序执行，依次完成。每个线程在完成后会发送信号。然后当最后一个线程收到所有这些信号后，它才会继续执行。这就是它的工作方式。好了，关于这种新方法的使用方式，大家有什么问题吗？我们稍后会看到一个例子。过一会儿会有一个更大的例子。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_92.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_92.png)'
- en: Alright。 Three different types。 Mutex， conditional variable， any semaphore。
    We will use conditional variable any less frequently because we've got semaphore。
    You will still use mutexes a lot。 You use those two much more than conditional
    variable any on its own。 Although you may have a reason to use that at some point。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，三种不同的类型。互斥量（Mutex），条件变量，任意信号量。我们会更少使用条件变量，因为我们有信号量。你仍然会经常使用互斥量。你会使用这两个远多于单独使用条件变量，尽管你可能在某个时刻有理由使用条件变量。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_94.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_94.png)'
- en: Okay。 Let us talk about another pattern here。 So here's a pattern that's going
    to come up occasionally。 And this is going to leverage the fact that we can use
    like zero， not necessarily negative。 but we can use zero for our semaphore to
    go。 Okay。 It also can be kind of a way to not have to use thread join until you
    absolutely need to。 Okay。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来讨论另一个模式。这里有一个模式，它偶尔会出现。它将利用我们可以使用零（不一定是负数，但我们可以使用零）作为信号量的事实。好的，它也可以是一个方法，在绝对需要时才使用线程连接（join）。好的。
- en: So here's what we're going to do。 We're going to look at a program that has
    two threads that are both acting on a particular data structure。 One of the threads
    is writing things to it。 The other thread is going to read from it。 Okay。 And
    it's in fact going to read the data that was just written。 Okay。 It's very similar
    to a pipe。 Okay。 In fact， pipes may use some of this kind of under the hood as
    well。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们接下来要做的就是，查看一个程序，它有两个线程，两个线程都在操作一个特定的数据结构。其中一个线程在写入数据，另一个线程会从中读取数据。好的，实际上它会读取刚刚写入的数据。好的，这很像管道。好的，实际上，管道也可能在后台使用类似的机制。
- en: But it's very similar to the idea of you're writing some data and another one's
    reading the data from that data structure。 Okay。 It's kind of like a web server
    and a client where the client to the web server like you type in www。google。com。
    That request goes out to the Google server and Google gives you back the data。
    There's kind of a handshake there where you're requesting something and then the
    data has to come back。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但这与写入一些数据然后另一个线程从该数据结构中读取数据的想法非常相似。好的，这就像一个Web服务器和客户端的关系，客户端向Web服务器发送请求，比如输入www.google.com。这个请求会发到Google服务器，然后Google返回数据。这中间有一个握手的过程，你在请求某些数据，然后数据必须返回给你。
- en: It's kind of like that。 And we will do more of that。 If we get time today。 we'll
    see another example of that as well。 And as I said， it's kind of like a pipe。
    Okay。 Here's the initial program that I will zoom up and we'll look at in a little
    bit of detail。 Okay。 How many people remember， well， you remember cues from CS106B？
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么回事。如果今天有时间的话，我们还会做更多的操作。我们也会看到另外一个例子。就像我说的，它有点像管道。好的，这是初始程序，我将放大一部分，我们会稍微详细看一下。好的，有多少人记得，嗯，你们记得
    CS106B 中的队列吗？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_96.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_96.png)'
- en: You ever talk about like a circular cue or a circular buffer？ You may remember
    those。 Okay。 Well。 some people do。 And if you took 170， you definitely don't know
    those because I know it's part of the assignments。 Here's what a circular buffer
    is。 Let me actually un-zoom and draw a little bit here。 I can。 Hey。 look at that。
    So， one from last time。 Okay， clear。 Okay。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你有谈到过像是循环队列或循环缓冲区吗？你可能记得这些。好的，好吧，有些人记得。如果你修过170课程，你肯定不知道这些，因为我知道它是作业的一部分。这个就是循环缓冲区的概念。让我实际上缩小视图并在这里稍微画一下。我可以，嘿，看这个。所以，上次的内容。好了，清除。好了。
- en: My horrible drawing skills will come back again。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我的糟糕画画技能又回来了。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_98.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_98.png)'
- en: Okay。 So a circular buffer is simply like this。 You can model it like this anyway。
    You can think of it as a circle if you want to。 But a circular buffer is like
    if you start writing here。 the next place you're going to write is here， then
    here， then here， then here， then here， then here。 then here。 And then you just
    wrap around and continue to write here。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，循环缓冲区就像这样。你可以把它建模成这样，或者你想的话，你可以把它想成一个圆形。循环缓冲区的作用是，如果你从这里开始写入，下一个写入的地方就在这里，然后是这里，然后是这里，然后是这里，然后是这里，然后是这里。然后你就回绕过来继续在这里写。
- en: So you need a head and a tail more or less。 Okay。 In fact。 you can keep track
    of that in your program with just a mod operator to keep track of where in the
    actual circular buffer is。 So you can have the buffer partially filled or whatever。
    The next place you write is here。 And let's say that one's filled， that one's
    filled， that one's filled。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你需要一个头和尾，差不多是这样。事实上，你可以在程序中通过一个模运算符来追踪实际循环缓冲区的位置。所以你可以让缓冲区部分填充或者其他什么情况。你接下来写的地方就是这里。如果这个位置填满了，那个位置也填满了，那个位置也填满了。
- en: I guess if you're next when you're writing is here， this was not filled yet。
    And so forth。 But the idea is， let me erase that like this。 So let's say that
    everybody else up to here。 Let's say it was like this was filled。 Let's say that
    was filled。 That was filled。 We're about to write here。 We would then fill this
    one。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你如果是接着写的，当前位置是这里，这个位置还没填满。以此类推。但重点是，给我擦掉它，像这样。假设其他的已经填充到这里。假设这是填充了的。那个也填充了。这个也填充了。我们准备写到这里。接着我们会填充这个位置。
- en: We would then fill this one and then come over here。 And this would be the next
    one。 Then we'd fill this one。 And then we would， the next one would be filled
    with over here and so forth。 If you ever get to the end where it's completely
    filled。 you should not continue to write to it because it's too full。 That's a
    circular buffer。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们填充这个位置，再到这个位置。接下来填充这里，然后下一个位置就填充在这里，以此类推。如果你遇到缓冲区已经填满的情况，你就不应该继续写入，因为它已经太满了。这就是循环缓冲区。
- en: And it makes it nice instead of having to create nodes at each time and walk
    through them one at a time。 You just have one array and go through it in a circular
    way。 Okay。 Anyway。 that's what a circular buffer is。 So what we're going to do
    is we're going to write a little program or look at a little program that has
    this circular buffer where one of the threads is going to be doing the writing。
    And the other thread is going to be doing the reading。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它的优点是，你不需要每次都创建节点并一个一个地遍历它们。你只需要一个数组，然后以循环的方式遍历它。好的，反正这就是循环缓冲区的概念。所以我们要做的是写一个小程序，或者查看一个有循环缓冲区的程序，其中一个线程将负责写入，另一个线程将负责读取。
- en: And it's going to hopefully keep track of who's writing where such that and
    reading so that it doesn't ever trample on the other one or read data that might
    not be available yet。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它将希望能够追踪谁在什么地方写入，以及谁在读取，以确保不会相互干扰，也不会读取尚未可用的数据。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_100.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_100.png)'
- en: Okay。 So what does that mean in terms of this program？ Well。 let's just look
    at how the program is implemented so far。 Okay。 We have a writer。 which basically
    is going to write random characters。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么这对程序意味着什么呢？嗯，让我们先看看目前程序是如何实现的。好的。我们有一个写入者，它基本上会写入随机字符。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_102.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_102.png)'
- en: It's going to randomly add a character and it's going to randomly put it's going
    to put that character into the buffer one after the other。 And it's only an eight
    buffer with eight positions in it。 But we're going to do this 320 times。 Okay，
    so it's going to write right and then wrap around and write right right right
    right right right right right。 Now， if everything went correct went well， the
    reading and writing would happen at the exact same rate so that you could do that。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它将随机添加一个字符，并且会随机地将字符一个接一个地放入缓冲区。缓冲区只有八个位置。但我们将执行这个操作320次。好的，所以它会写入然后回绕，继续写入，写入，写入，写入，写入，写入，写入。如果一切顺利，读取和写入会以相同的速度发生，这样你就可以做到这一点。
- en: And then the writer might be a little bit ahead of a reader and they would keep
    going in that circular pattern。 That would be ideal。 Okay， but it's a very simple
    like thing that's happening here。 It's just taking that random character， putting
    it somewhere in the buffer。 And then when the i variable gets bigger than bigger
    than seven。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，写入者可能会稍微超前于读取者，他们会继续沿着那个循环模式进行。这是理想的情况。好的，但这里发生的其实是非常简单的事情。它只是把那个随机字符放到缓冲区的某个位置，然后当`i`变量大于七时，继续执行。
- en: it wraps back around to the beginning and keeps going。 And it just does that
    320 times putting the data in there。 Okay， that's what it does。 No one it's done。
    It says or actually each time it says that it's put that data in there。 Okay。
    The reader does the kind of the reverse。 It goes through and it reads the data
    one character of time and then just wraps around and keeps reading data。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它会回绕到开始，并继续执行。它就这样做320次，把数据写入其中。好的，这就是它所做的。每次执行时，它都会说它已经把数据写入其中。好的。读取者则执行相反的操作。它遍历并逐个字符地读取数据，然后回绕继续读取数据。
- en: Okay， so in a perfect world， the writer might be one or two steps ahead of the
    reader and everything would work perfectly。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在一个完美的世界里，写入者可能会比读取者领先一两步，一切都会完美地工作。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_104.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_104.png)'
- en: Okay， and these are in different threads so you might think， oh， there's a raised
    condition here。 Ah， there is。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些是在不同的线程中，所以你可能会想，哦，这里有一个竞态条件。嗯，确实有。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_106.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_106.png)'
- en: Let's actually look at it here。 Okay， this is called confused reader writer。
    Okay。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际看看这里的情况。好的，这叫做混乱的读写者。好的。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_108.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_108.png)'
- en: And remember it's taking random characters and then writing them and then reading
    those random characters out。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，它是先取随机字符，然后写入，再把那些随机字符读取出来。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_110.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_110.png)'
- en: So it's going to look a little funny here at first。 I will actually stop it
    while because it's doing that。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所以最开始这里看起来会有点奇怪。我会实际停止它，因为它正在做那个操作。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_112.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_112.png)'
- en: Let's look at what's happening here。 Okay， so the writer is ready to write and
    the reader is ready to read。 And the writer publishes S。 Okay， well the reader
    and then the reader consumes sphin。 What's going on with that？ And then it says
    the reader consumes G and then the writer wrote in J and the reader consumed at。
    Well， what's happening here is the reader is trying to read before the writer
    has ever even written anything and whatever the garbage was in there to begin
    with is what gets read out。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。好的，写入者准备好写入，读取者准备好读取。然后写入者发布了S。好的，读取者接着消费了sphin。那么发生了什么？接着它说读取者消费了G，写入者写入了J，读取者消费了at。那么这里发生了什么呢？实际上是读取者在写入者还没有写入任何内容之前就开始尝试读取，而最开始缓冲区中存在的垃圾数据就是被读取出来了。
- en: Okay， and so eventually and then it reads consumed data with like nothing and
    blah blah。 I can't even write it。 Eventually you might see some of the data getting
    in there but it's all garbled and the writer is writing over parts and it's not
    working the way we want it to。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，最终它读取了消耗的数据，像是空的，等等，我甚至无法写下来。最终你可能会看到一些数据进去了，但它们都被弄乱了，写入者覆盖了某些部分，它的工作方式不是我们想要的。
- en: Are they writing to and reading from the same file？
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是在同一个文件里读写的吗？
- en: They're writing to and reading from the same buffer which is just a charged
    dog buffer。 You don't worry about any cursor。 You don't worry about any cursor。
    We kind of are worrying about the cursor。 Let me go back to the drawing again。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在同一个缓冲区进行读写操作，这只是一个充电的狗形缓冲区。你不需要担心任何游标。你不需要担心任何游标。我们有点儿在担心游标。让我再回到图示。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_114.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_114.png)'
- en: Let me actually redo the drawing like this。 Here is the buffer。 Let's do it
    in a little more。 Let's say that one， two， three， four， five。 Let's only say there's
    six places。 Let's say that this is where the first read is going to happen but
    it's also where the first write is going to happen。 Let's call this the read head
    and the right head there。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我实际重新画一下这个图。这里是缓冲区。我们再做一点更多的事情。假设有一，二，三，四，五。假设只有六个位置。假设这里是第一次读取发生的地方，但也是第一次写入发生的地方。我们叫它读取头和写入头。
- en: Where is the last thing that could possibly get read？ It turns out this is well。
    like if you go all wrap all the way around but that's kind of a nuance。 But for
    now let's think about it。 Let's say that the writer tries to read first。 Well
    it's going to read garbage here。 So that's going to be garbage if it gets ahead。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后可能会被读取的东西在哪里？事实证明，这就是——如果你绕一圈回去的话，不过这有点微妙。但现在我们先考虑这个问题。假设写入者先尝试读取。好，它会在这里读取垃圾。所以如果它提前读取了，那就是垃圾。
- en: Let's say the writer did get to write A。 Okay the writer writes A and then the
    writer writes B and then the writer writes C and D。 Let's say the reader is nice
    and starts reading now。 Well the reader will read A and then be here and the reader
    will read B and B there and then B there and the reader will read D。 et cetera。
    And let's say E， F and then it comes around here and reads G。 Well good。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设写入者确实写了A。好，写入者写了A，然后写入者写了B，再写了C和D。假设读取者很友好，现在开始读取。那么读取者会读取A，然后到这里，读取者会读取B，然后到B这里，然后B这里，接着读取者会读取D，依此类推。假设是E，F，然后它绕到这里读取G。好。
- en: Let's say the reader for some reason stalls reading right here。 Well this is
    G and then this is going to be H and then this is going to be I。 it's going to
    be J before the reader ever reads it。 So that's the big issue here。 Okay if they're
    not in perfect sync they're going to be in trouble。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设由于某种原因，读取者在这里停下了读取。那么这里是G，接下来是H，然后是I，接着是J，直到读取者读取它。所以这是一个大问题。如果它们不完全同步，可能会出问题。
- en: Okay now the perfect sync is actually a little bit nuanced as well。 To be perfectly
    sync how many things can get read before anything's written？ Zero right？
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在完美同步其实是有点微妙的。要完美同步，多少数据可以在写入前被读取？零，对吧？
- en: You have to write something before you can read any of it。 So things can be
    written before something must be read。 The max number of things right？
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须先写入一些东西，才能读取它。所以，某些东西必须在读取之前被写入。最大数量的东西，对吧？
- en: So you could write all the way to the end here before going back but if the
    instant you go back if nothing's been read yet you'd better wait。 Okay so that's
    going to be the idea of what we're going to do with this program here。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以一直写到最后，再返回去，但如果你一回去什么都没读取过，那你最好等一下。好吧，这就是我们将在这个程序中要做的事情。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_116.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_116.png)'
- en: Okay so anyway we go back and we look at it again and we go out。 So we go back
    to the completely garbled。 Nobody's in the right order。 It should have been。 it
    should have read SJCNN。 Let's see there's an SJCNN。 It did read it starting down
    there but eventually there's not necessarily in sync。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以不管怎样，我们再看一遍，然后我们出去。所以我们回到了完全混乱的状态。没有任何东西是按顺序的。它应该是。它应该读取SJCNN。我们来看看，确实有SJCNN。它从那里开始读取，但最终它不一定是同步的。
- en: A bunch of stuff got read first and whatever。 Not so good。 Okay how can we fix
    this？
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一堆东西先被读取了，不管怎样。不好。好吧，我们怎么修复这个问题？
- en: Well there are different ways of fixing it。 Okay you could。 you probably could
    use a couple of mutexes maybe if you wanted to and try to set it up like that。
    That's the one way of doing it。 One， the way I want to show you is by using two
    semaphores。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以修复它。好吧，你可以，可能你可以使用几个互斥量，也许如果你想这样做并尝试设置它。这是一种做法。我要给你展示的方式是使用两个信号量。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_118.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_118.png)'
- en: Okay what we're going to do is we're going to， this is actually kind of what
    we just went through。 Why it's broken。 There's nothing basically， there's nothing
    that tells the reader that a slot can be read from yet。 And there's nothing to
    tell the writer that all the slots are full。 That's the big problem。 Okay all
    right so what can we do？ Well we can have two semaphores。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们将要做的是，这实际上是我们刚刚经历的过程。为什么它会坏掉。基本上没有任何东西能告诉读者某个位置可以读取了。而且没有任何东西告诉写入器所有位置都已满。这就是大问题。好吧。那么我们能做什么呢？我们可以使用两个信号量。
- en: Okay if we have an eight character buffer we can initialize an empty buffers
    to eight。 In other words it starts out with eight empty buffers。 There's eight
    spots that are empty。 So far so good。 Okay and then we can also set up a semaphore
    that says full buffers。 Well how many are full initially？ Zero。 So let's do a
    semaphore starting at zero which is that weird case where it's always going to
    require a signal to at least get going。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我们有一个 8 个字符的缓冲区，我们可以将空缓冲区初始化为 8。换句话说，它一开始有 8 个空缓冲区。有 8 个空的位置。目前一切正常。好的，然后我们还可以设置一个信号量，表示满缓冲区。那么最初有多少是满的？零。所以我们做一个从零开始的信号量，这是那个奇怪的情况，始终需要一个信号才能开始。
- en: Because it started with no permits available and it's， that's what's happening
    there。 Okay so we can do that。 We can set up the semaphore full buffers and empty
    buffers。 The full buffers， if you say a semaphore with no parameter it starts
    at zero。 Okay if you do an empty buffer， if you do the parameter here that's how
    many permits there basically are。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它一开始没有许可可用，那就是发生的事情。好吧，我们可以这么做。我们可以设置信号量满缓冲区和空缓冲区。满缓冲区，如果你说一个没有参数的信号量，它会从零开始。好吧，如果你做一个空缓冲区，如果你在这里做参数，那么这就是基本上有多少许可的意思。
- en: And this one says there's eight empty buffers。 Then you have to of course pass
    both the full and empty into both the reader and the writer because they're both
    going to be handling both reader and writer。 One's going to be waiting and then
    signaling the other and the other's going to be waiting and the other one and
    signaling the first one。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个信号量表示有 8 个空缓冲区。然后你必须当然将满缓冲区和空缓冲区都传递给读者和写入器，因为它们都会处理读者和写入器。一个会等待并向另一个发信号，而另一个会等待并向第一个发信号。
- en: So that's where we're going to have to be working on。 Let's see how this works
    in the actual functions。 So what do we have？
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要在这里工作。让我们看看这个在实际功能中是如何运作的。那么我们有什么呢？
- en: All right we've got the full and the empty semaphores here。 Okay we are still
    going to do the same logic as before。 We're just going to do the for loop through
    the entire buffer。 The first thing the writer is going to do is it's going to
    wait on the empty buffers。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们有了满缓冲区和空缓冲区的信号量。好的，我们仍然会做和之前一样的逻辑。我们只会通过整个缓冲区执行 for 循环。写入器做的第一件事就是它会等待空缓冲区。
- en: But we initialize those to eight and for a semaphore if the count is eight permits
    will it wait at all？
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将这些初始化为 8，对于信号量，如果计数为 8，许可会等待吗？
- en: No it says great。 I can start writing。 And so boom it starts writing and then
    it tries to wait again and now there's seven available and boom it starts writing
    and that's that。 And we'll keep going。 After it writes a character it signals
    the full "hey there's a character I just wrote"。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它说很好，我可以开始写了。然后砰，它开始写入，然后它再次尝试等待，现在有七个可用的缓冲区，砰，它开始写入，就这样。我们会继续。当它写入一个字符时，它会向满缓冲区发信号：“嘿，我刚刚写了一个字符”。
- en: So that increments the full counter in the semaphore to one and it signals because
    it incremented to one and it signals the other thread。 Hey there's something available
    I just put something there。 Okay。 All right let's look at the reader。 The reader
    does kind of the opposite。 It still goes through the loop and does it starts by
    waiting for full。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它将信号量中的满缓冲区计数器递增到 1，并且它发出信号，因为它递增到 1，并且它向另一个线程发信号。嘿，有东西可用，我刚刚放入了一些东西。好吧。好了，我们来看读者。读者做的是相反的事情。它仍然会通过循环，首先等待满缓冲区。
- en: Well nothing's full at the beginning so reader has to wait at least one iteration
    of the writer putting something in there because the semaphore it's using starts
    out at zero。 Okay。 But then it immediately gets a signal once the first thing
    goes into the writer or runs the writer writes one and it originally immediately
    gets a signal and can read it immediately。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时没有任何东西是满的，所以读者必须至少等一次写者插入一个东西，因为它使用的信号量从零开始。好的。但是一旦第一个东西写入，信号量就会立即被触发，读者可以立刻读取。
- en: It might be just one step behind because maybe the writer hasn't written the
    next one yet and then it then it does that the wait again but it will do it immediately
    when there is a spot available。 And there may be many depending on how many the
    writer wrote in。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会稍微滞后一步，因为可能写者还没有写下一个东西，然后它会再次等待，但只要有位置，它会立即执行。而且这个过程可能会有很多次，取决于写者写了多少东西。
- en: There might be there might be many in there up to eight。 Okay。 And then let's
    see。 And then it signals empty saying hey I just emptied one and that's when the
    the empty which the writer when it's waiting could end up going forward。 Okay。
    So this one by the way will do this up to eight times without the reader doing
    anything。 And we can test that as we go and then it will it should work。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 里面可能会有很多项，最多到八个。好了，我们来看一下。然后它发出信号说“空了”，意思是我刚刚清空了一个，这时空的信号会通知写者继续。好了，顺便提一句，它最多会这样做八次，而读者什么都不做。我们可以继续测试这个，应该是有效的。
- en: So this is now how the semaphores are going to be useful to us to keep everything
    in order。 And then actually look at that one。 This one is just called reader writer
    the correct one so I'll let that go in there for a bit。 And let me just zoom up
    to the top here。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在信号量如何帮助我们保持一切有序。然后我们来看看这个。这个只是叫做读写者的正确示例，我会让它运行一会儿。让我放大到顶部。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_120.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_120.png)'
- en: Okay。 The readers or the writers writer writing the readers ready to read。 Great。
    The writer published a well guess what the reader immediately consumed a。 And
    there's by the way I shouldn't have said this to the sentence before。 There's
    random sleeping going on here too so that that this is you know why it is just
    one after the other because there's some random sleeping going on here。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，读者或写者在写作，读者准备好读取了。太好了，写者发布了一个，猜猜读者立刻消费了a。顺便说一下，我不应该在前面的句子里说这个，这里也有随机休眠，所以这就是为什么它们是一个接一个执行的原因。
- en: The reader got a in order and then why goes in and then why comes out and then
    W。 I。 Q。 W。 Well it must have been that the reader went to sleep for a while because
    the writer got a chance to put four new things into the reader W。 I。 Q。 W。 But
    what gets read out。 Oh good W。 I。 Q。 W。 Gets read out。 So we know it's going to
    be in order there。 And then it continues going through。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 读者按照顺序获取了a，然后y进入，y出来，再到W.I.Q.W。一定是读者睡了一会儿，因为写者有机会插入四个新的东西到读者W.I.Q.W。但是读出来的是什么呢？哦，W.I.Q.W。被读取。所以我们知道这里一定是按顺序的。接下来它继续进行。
- en: I'm not sure we get to a point where we might get to a point where eight things
    go in and it waits that long but we can we can do that but anyway it is definitely
    going to do it in order。 Okay。 Make sense。 Everybody why that's the case。 It doesn't
    go back and look at the code again and remember go look at the semaphore code
    and see how that actually works as well。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定，可能会出现一种情况，八个项目会进入，但它会等待这么久，虽然我们可以这样做，但它肯定会按顺序执行。明白吗？大家为什么是这样？不明白的可以再看一次代码，记得去看看信号量的代码，看看它是如何工作的。
- en: All right let's look at the code yeah。 Does it matter if you join the reader
    writer first。 Yeah good question does it matter if you let's actually look at
    the the actual code here because I didn't put that in the one main again down
    here。 Does it matter which one you join first I don't believe it does why because
    as long as they all get to finish then the buffers will be will be filled in that
    case right。 If you try to actually。 Let's see if you try to wait on the reader
    first。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们来看一下代码。加入读写者的顺序有关系吗？是的，问题很好，加入哪个先并不重要，为什么呢？因为只要它们都能完成，缓冲区就会被填满，对吧？如果你尝试先等待读者那边。
- en: There might get that the writer ends up let's see tried to wait on the read
    it might be might be that you have to do it in order just because you have to
    write before you can read and if you wait on the let's see if you waited on the
    reader first you might end up not being able to read it all and therefore。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是作家最后结束了，让我们看看试着等一下读者，可能是你必须按顺序做，因为你必须先写才能读，如果你先等读者，你可能就完全无法读取它了，因此。
- en: I don't think about it more yeah I don't think about it more but I don't think
    it's actually a race just in that case the final waiting it might be I'll get
    back to you on that。 Yeah good question yeah。 Yeah so I mean we can try it I don't
    know that's a good we can absolutely try it but I don't know that it's going to
    prove our case will prove the negative but let's try it。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有再想它了，嗯，我没有再想它，但我认为在这种情况下它并不是一场比赛，最终的等待可能是，我会回来告诉你。嗯，好问题，是的。所以，我的意思是我们可以试试，但我不知道这是否能证明我们的观点，证明否定，但我们还是试试看。
- en: Okay and then read a writer there we go okay let's just see if it goes all the
    way through it would only happen near the end we would care because one would
    end before the other。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，然后再读写器，好了，让我们看看它是否能够完全通过，这种情况通常发生在接近结束时，我们会在意，因为一个会先结束。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_122.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_122.png)'
- en: But no again not only think about it I don't think it's possible for if one
    ends and it's waiting for the other who cares if it's waiting for the first one
    and hasn't ended yet who cares so if the data hasn't come the other one wouldn't
    have ended yet so I think it doesn't matter。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不，再想一下，我觉得如果一个结束而另一个还在等待，那又怎么样呢，如果它在等待第一个而还没结束，那又怎么样呢？所以，如果数据还没有到来，另一个应该还没结束，所以我认为这无关紧要。
- en: I'm pretty sure I'll confirm that but it did finish so at least we know that
    it can work but again these sorts of things don't。 Let it let's do this though
    let's put in on just a little bit more waiting we'll put in let's see let's put
    a let's put us。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定我会确认这一点，但它确实完成了，所以至少我们知道它是可以工作的，但这些事情通常不会。让我们这样做吧，让我们稍微再等一下，我们再看看，看看我们能不能放进去。
- en: Let's put a little sleep for in here for like three seconds right before it
    even starts to try to read。 This is going to mean that the writer is going to
    try to put it's going to put eight things in there and then hopefully it will
    wait。 Let's see if that works。 Okay there we go so it's put one two three four
    five six seven eight things in there and then it went going after the reader finally
    woke up and I'm going to start reading some things。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里稍微加个暂停，等三秒钟才开始尝试读取。这意味着写入器会尝试放进去八个东西，然后希望它会等待。我们来看看能不能成功。好了，它放入了一二三四五六七八个东西，然后它在读者终于唤醒后继续运行，我开始读取一些内容。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_124.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_124.png)'
- en: That's how that works。 And the other way if we put the if we put it in the writer
    or rather in the yeah if we put it in the before the writer what's going to happen
    here。 What do you think if I put the sleep there what's going to happen now。 What
    do you think it should wait three seconds before doing almost anything right because
    the yeah I think that's a good good good answer。 Make reader writer and then we're
    going to there we go okay there everybody's ready then finally the writer starts
    writing up three seconds then boom it goes。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样工作的。另一方面，如果我们把它放在写入器之前，或者更准确地说，如果我们把它放在写入器之前，发生什么情况？你认为如果我在这里放个暂停，会发生什么？你认为它应该在做几乎任何事情之前等待三秒钟，对吧？是的，我认为这是个很好的回答。让我们创建读者写入器，然后好吧，大家都准备好了，最后写入器开始写作，三秒钟后，砰，它就开始了。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_126.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_126.png)'
- en: Okay nothing's ever written the reader can't bother to or can't do the reading
    in question。 Good question how does it get nine there let's actually run in this
    case and see what happens if we get a whole bunch of it。 Did it do nine or it
    might just be probably just a race condition would who would write in reading
    that's my guess。 It can't read nine without nine with it can't read nine a row
    because there aren't nine spots right but it's probably the last right the reads
    already printing out or isn't printing out yet or something like that so it's
    just a race condition there。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，什么都没有写，读者无法处理或者无法完成需要的读取任务。好问题，怎么会有九个呢？我们其实可以跑一下看看会发生什么，如果我们得到一堆数据。它是做了九个吗？可能只是一个竞争条件，谁在写谁在读，这是我的猜测。它不能在没有九个的情况下读取九个，因为没有九个位置，但很可能是最后一个写入的，读取已经打印出来了，或者还没有打印出来，或者类似的原因，所以这只是一个竞争条件。
- en: If it were like 20 I'd be a little suspect but I think eight or nine or ten
    not one two three four five seven nine yeah last one and it did do two S's at
    the end so that wasn't a weird。 So I think it's just that the it's probably just
    a race condition there it's also that maybe the writer's got a little more is
    writing a little faster than the reader anyway and the readers doesn't never quite
    catches up until the last part goes out finally I can read all the rest of the
    data。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是20个的话我可能会有点怀疑，但八个、九个或者十个，倒是不会怀疑，1，2，3，4，5，7，9，最后是那个，确实做了两个S的结尾，所以没有什么奇怪的。总的来说，我觉得这只是一个竞争条件的问题，可能是因为写入的速度比读取的速度快，反正读者总是赶不上，直到最后一部分输出时，才终于能读取到其余的数据。
- en: There's no questions。 Do you have more questions？ No you're sure？ Okay。 Anybody
    else？ All right。 So that's the that reader writer paradigm。 Let's reach out。 All
    right。 I think we have time to take a look we may not get to the whole thing but
    let's take a look at this thing called myth buster。 Okay this is a Jerry Kane
    special it's called myth buster because what all it does is it basically you ever
    log on to a myth and you go wow there's a thousand other people on here and it's
    really slow and it's kind of annoying and maybe it'd be kind of nice to know which
    myth has the least number of like CS one ten people slamming it。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 没有问题。你有更多问题吗？你确定吗？好。还有其他人吗？好，那么这是读写者范式。让我们继续。好，我觉得我们有时间看看，可能不会看完，但我们来看看这个叫做神话粉碎者的东西。好的，这是一个杰瑞·凯恩的特别项目，叫做神话粉碎者，因为它的功能就是，当你登录一个神话时，你会发现哇，那里有一千个其他人在用，而且非常慢，挺烦人的，也许了解一下哪个神话的CS
    110用户最少，感觉会更好。
- en: Okay。 Well that's what this myth buster does。 Okay basically goes to all I guess
    10 or 12 myth machines and it queries them using a kind of a wonky hack to actually
    see how many threads for people in this class are using that。 Now I also think
    it should check one oh seven or just in threads in general but whatever it checks
    this class。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这就是神话粉碎者的作用。它基本上会访问所有的神话机器，可能是10台或12台，然后通过一种有点怪异的hack查询它们，看看这个班级的学生使用了多少线程。我还觉得它应该检查一下107号机，或者只检查线程，但不管怎样，它检查的是这个班级的。
- en: Okay。 Now I'll show you it running before you anything else。 Okay。 Myth buster
    let's do it concurrent that's the one we don't love but okay。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我先展示一下它的运行情况，然后再说其他的。好的。神话粉碎者，我们就让它并发运行吧，这是我们不太喜欢的那个，但也没关系。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_128.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_128.png)'
- en: Okay so holy smokes who's using all these processes。 What is this？
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，天呐，谁在使用这些进程？这是什么情况？
- en: Machine and there's a little race cushion there anyway with a number of least
    oh no machine least loaded by CS machine number process and least loaded machine
    74 so if you were to use it you would want to log on a myth 52 but I'm actually
    really curious myth 65。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 机器上也有一点竞争条件，没错，最少的机器是CS机器号最少加载的机器74，所以如果你要使用它，你应该登录到神话52上，但我现在真的很好奇神话65。
- en: As to say it's myth 65。 Myth 65 h top let's see。 Okay somebody's let's see so
    there's that let's see factor Python factor。 Who is this？ Emma you have a hand。
    Okay so you left a whole bunch of factors like going in your program possibly
    when you when you started。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 是神话65。神话65，查看h top。好的，有人在看，让我看看，看看因子Python因子。这个是谁？Emma，你有问题吗？好的，看起来你在程序中留下了很多因子，可能是你启动程序时的操作。
- en: I don't mean to call him out but she's happy to look good we could there are
    thousands of them so you said it's not alone I guarantee you that there there's
    some more。 Okay there's some more。 All right let's see if we can find a bunch
    more。 Yeah there's a bunch more so so yeah so you should kill all your processes
    so I literally when I when I ran this earlier I noticed some of these and I'm
    going to have to write a little note to next quarter make it so that every time
    you submit it just kills all your outstanding processes that are still running
    on whatever myth going you have because。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是故意点名批评他，但她很高兴看起来不错，我们可以，成千上万的这些人，所以你说的并不孤单，我向你保证，还有更多。好的，还有更多。好了，让我们看看能不能再找到更多。是的，还有一大堆，所以你应该终止你所有的进程。所以实际上，当我之前运行这个时，我注意到其中的一些，我得写一个小笔记给下个季度，让每次提交时都能终止所有你仍在运行的进程，不管你在哪个
    myth 环境中。
- en: that's it so anyway that's you guys are all doing that and those poor 107 students
    can't use the myth machines because you're neither can you so Emma what you can
    do by the way is you can say I think kill all Python it will kill all your Python
    things on that。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，反正你们都在做这些，那些可怜的107个学生无法使用 Myth 机器，因为你们自己也不能用。所以Emma，顺便说一下，你可以说“kill all
    Python”，它会终止你所有的Python进程。
- en: that machine I believe you can try that and see if it see if it works and maybe
    it will do that and if we're all nice we can do that the good news the good news
    by the way is that all these processes while they are taking up memory they should
    all have tea under the status which actually means stopped so they're not actually
    spinning which is good so thank you for not like running spin。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 那台机器我相信你可以试试看，看看它是否有效，也许它能做到，如果我们都很友好，我们可以做到。顺便说一下，好消息是，所有这些进程虽然占用了内存，但它们的状态应该都是“T”（即停止状态），这意味着它们实际上并没有在不断循环，这很好，谢谢你们没有让它们一直运行。
- en: But but yeah that the it they're generally not good to like happen sitting there
    doing nothing until the machine reboots that's kind of what's going to happen
    so anyway but anyway that's what myth buster does and myth buster runs somewhat
    slowly in that it has to pull each。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但对，通常情况下它们并不好，比如说就那样坐着什么都不做直到机器重启，这大概是会发生的情况，不管怎么样，这就是 Myth Buster 做的事情，而且 Myth
    Buster 的运行有些慢，因为它必须拉取每个。
- en: And so that's the concurrent ones this is the fast one the sequential ones ones
    going to be slowly that was nice fast one sequential one is going to be slowly
    because it has to do each one in order and it's just got to go and do this query
    and thing some of the myth machines by the way are down or like not available
    for us is aging into for whatever reason and it has a two second time out on that
    so it has to wait for that。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是并行处理的，速度快的那种，顺序处理的那种会很慢，因为它必须按顺序处理每一个，它必须去执行这个查询，而一些 myth 机器顺便说一下，可能因为某些原因出现故障，无法使用，它对这种情况有2秒的超时设置，因此必须等到超时。
- en: And so this mean well the concurrent one which was much faster did it in threads。
    Okay just said oh I'm going to have a different thread asking this myth machine
    how many threads or how many processes and if it takes a little while great some
    other ones are still going to be running。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这意味着，嗯，并行的那种，速度快得多，是用线程处理的。好的，基本上就是说，我会开一个不同的线程，询问这个 myth 机器有多少个线程或多少个进程，如果需要一点时间也没关系，其他的一些线程还会继续运行。
- en: You'll notice it's out of order we could figure out how to order it a little
    bit better but you have 56 52 58 etc。 This one at least is in order and some are
    missing because it's not they're not like myth 57 is down or whatever but maybe
    it should just say myth 57 is down。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到它是乱序的，我们可以找办法让它更有序一点，但你会看到56，52，58等。至少这个是有序的，虽然有些缺失，因为它们不是像 myth 57 那样挂掉，但也许应该直接说
    myth 57 挂掉了。
- en: But the point is that you do it concurrently it's slow once you have threading
    you can wait for all those servers to reply to you or for a broken down you can
    do that。 So let's take a look at some of the code for this。 Okay here's the various
    data structures we're going to have。 I happen to make an idea list of all the
    student's soonets in the class。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但重点是你要并行处理，虽然慢，但一旦有了线程，你可以等待所有服务器的回复，或者处理故障。我们来看看这部分代码。好的，这是我们要使用的各种数据结构。我恰好列出了班上所有学生的列表。
- en: And that's what it's asking for so reads that file and then it checks the Smith
    machine against all those names。 It just looks for the process numbers。 Okay it
    has a set of all this that's a set it reads that you can read this to file it's
    got a map that counts the processes for each for each myth to how many processes
    it has。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它所要求的，所以它读取那个文件，然后检查Smith机器与所有这些名字的匹配。它只是查找进程号。好的，它有一个所有这些的集合，这是一个集合，它读取这个文件，它有一个计算每个神话的进程数的映射，告诉你每个神话有多少个进程。
- en: Okay compile the process count map is going to pass in those two details and
    in there we're going to do all the threading and then it's going to publish the
    least loaded data so that's how the program is going to work。 Okay let's see how
    I already mentioned all these things went over those things see anything important
    there that we need to know。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，编译进程计数地图将传入这两个细节，然后我们将在其中进行所有的线程操作，然后它将发布最少负载的数据，这就是程序的工作方式。好，让我们看看我已经提到的这些东西，回顾一下这些，看看有没有什么重要的东西我们需要知道。
- en: Nope I think we talked about it all。 The details are in a get num processes。
    Okay this is where it actually goes and gets the for like myth 54 it gets the
    processes and then it checks them all against the students in the class based
    on their username。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我想我们已经讨论过了。细节在`get num processes`中。嗯，这就是它实际去获取的地方，比如神话54，它获取进程，然后根据用户名检查它们与班级中的学生是否匹配。
- en: Okay and this is how it would work in the sequential version。 Okay it's pretty
    straightforward basically goes through each myth。 Okay from 51 to 56 and then
    it counts number of processes in each one by calling this getting on process。
    Well that's the slow part because you've got 10 different product 12 and processes
    10 different myths and each one could be stalling。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是它在顺序版本中如何工作的。基本上它逐一处理每个神话。好，从51到56，然后它通过调用这个获取进程来统计每个神话中的进程数。嗯，这就是慢的部分，因为你有10个不同的产品12个进程，10个不同的神话，每个神话可能都会卡住。
- en: Okay so that's what we're going to have to try to avoid。 This is what we showed
    you at working already。 Okay the point is that each call spends most of its time
    waiting around for the myth machine to respond to it。 Whenever you log in a myth
    and you're waiting well that's what your program has to do too。 Right it can't
    go on to anything else if you if you do it sequentially so that's the that's the
    big deal。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是我们需要避免的情况。这是我们已经展示给你们的工作原理。嗯，关键是每个调用大部分时间都在等待神话机器的响应。每当你登录到一个神话并等待时，嗯，你的程序也必须做这个。对，它不能继续做其他事情，如果你按顺序执行的话，所以这是关键所在。
- en: Okay so when you're counting these what you want to do instead is do it in friends。
    Okay so let's see how this might work。 Well we're going to have account CS 110
    processes again。 We're still going to pass in the num we're still going to pass
    in the set of students and we're still going to set pass in the process count
    map and this or I guess this time we're going to pass it in and not just get a
    return value。 Now we're going to have a mutex to lock on the process count map。
    Why？
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以当你在计数这些时，你要做的不是顺序执行，而是用线程处理。好，让我们看看这如何工作。嗯，我们将再次计算CS 110的进程。我们仍然将传入num，我们仍然将传入学生集合，我们仍然将传入进程计数地图，这次我们将传入而不是仅仅得到返回值。现在我们将使用一个互斥锁来锁定进程计数地图。为什么？
- en: Because you don't want different threads trying to update the map at the same
    time。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你不希望不同的线程同时更新地图。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_130.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_130.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_131.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_131.png)'
- en: Okay you might think well why does it matter if two threads with two different
    myths updates the map at the same time。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你可能会想，为什么两个线程在两个不同的神话中同时更新地图有什么关系呢？
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_133.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_133.png)'
- en: Well do you remember how maps are built under the hood back to CS 110 or 106
    B days。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在幕后是如何构建地图的吗？回到CS 110或者106 B的日子。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_135.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_135.png)'
- en: Remember how maps are generally some like maps are generally built if it's a
    regular old map you know it's a tree yeah and if you have a tree and if it's a
    balanced tree well that means that you have to actually move nodes around when
    you're inserting。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 记得一般情况下地图是如何构建的吗？如果是普通的地图，你知道它是树形结构，如果你有一棵树，而且如果是平衡树，那意味着在插入时你必须实际移动节点。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_137.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_137.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_138.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_138.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_139.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_139.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_140.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_140.png)'
- en: and that would be bad if two things tried to insert at the same time they'd
    be moving things around and it would go haywire。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个元素同时尝试插入，就会很糟糕，它们会互相移动，最终导致混乱。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_142.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_142.png)'
- en: And an unordered set is using a hash table which also might cause similar issues
    especially if you have hash collisions and so forth。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 无序集合使用哈希表，这也可能引发类似的问题，特别是如果发生哈希冲突等情况。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_144.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_144.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_145.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_145.png)'
- en: So either way you don't want two threads to try to write to that map at the
    same time so you lock around the map but the map writing is very quick。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所以无论如何，你不希望两个线程同时写入那个映射，所以你会在映射周围加锁，但映射的写入非常快。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_147.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_147.png)'
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_148.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_148.png)'
- en: Writing to the map or reading from it very very quick。 Okay so we can we can
    do that we can not worry too much about that。 Okay in fact we're just going to
    do a lock guard around it。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 写入映射或读取它是非常非常快的。好的，所以我们可以做到这一点，不用太担心。事实上，我们只会在它周围加一个锁保护。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_150.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_150.png)'
- en: Okay we're going to change the up we're going to let's see we're going to do
    the actual count process or get number process in here。 Once we get the number
    of processes we're going to if the count is greater than zero we're going to update
    the minute count number and put it in the map。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们要更改，我们要……我们来看看，我们将要在这里进行实际的计数过程或者获取数量的过程。一旦我们得到进程的数量，如果计数大于零，我们将更新分钟计数并将其放入映射中。
- en: And that's a very short this this whole section here is very short to update
    the map。 This is the part that takes a long time。 If you're trying to wait that's
    the part that takes a long time but if you're doing it in 12 different threads
    to 12 different machines it's actually fine。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分非常简短，更新映射的部分。这个部分需要花很长时间。如果你在等待，那部分确实是耗时的，但如果你在12个不同的线程、12台不同的机器上进行处理，实际上是没问题的。
- en: Okay but you have to lock around updating that map for everybody。 And then we
    have permits in here this is so that we don't slam all the myths at once I guess
    it's not a big deal for 12 different myths having 12 different threads。 But in
    this case how many did we set up here did we did we say how many we set up we're
    I guess we're going to we're going to see how many so here we go。 So we're going
    to say only allow eight threads to go to time。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但你必须在更新映射时对其加锁，以确保所有人都能安全操作。然后我们在这里有许可证，这样我们就不会一次性处理所有线程。我想，处理12个不同的线程在12台不同的机器上并不是一个大问题。但在这种情况下，我们设置了多少线程？我们是不是说过要设置多少个线程？我猜我们要看看具体设置了多少。好了，所以我们说只允许同时运行八个线程。
- en: That's just kind of nice when you're doing networking things to limit it to
    some reasonable amount but we could get away with thousands if we really wanted
    to in this case but there's only 12 minutes or something。 So that's that。 Okay
    and then we signal on the end there we let's see when do we actually get the permits。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在做网络操作时，限制到一个合理的范围是挺好的，虽然在这种情况下我们实际上可以处理成千上万的请求，但时间只有12分钟左右。所以就是这样。好了，然后我们在结束时发出信号，看看我们什么时候实际获得许可。
- en: I don't see a permit's weight in there so。 Oh it's down here。 Let's see。 Oh
    right okay when we're actually send setting up the threads that's when we're doing
    it。 We will see a different model next week for a different model for this in
    this case this is where we're setting up the threads down here。 Okay so how are
    we doing that we're saying eight permits and we are going through and if we only
    we're only going to launch eight threads at a time when one of those threads。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有看到许可的等待在那里。所以……哦，它在这里。让我们看看。哦，对了，好的，当我们实际上设置线程时，就是在这个时候。我们下周会看到一个不同的模型，这个模型是我们在这里设置线程的地方。好的，那么我们是怎么做的呢？我们说允许八个许可，然后我们会遍历，如果我们只……我们一次只会启动八个线程，当其中一个线程……
- en: Finishes it will signal this to start the next thread。 We are not joining on
    any threads until all the way at the end。 Okay those threads will end but we're
    only allowing eight to kind of go at the same time。 At some point there will probably
    be nine threads going at this time because the signal is going to happen and another
    thread is going to get spun up and then this one's going to close。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后它会发信号启动下一个线程。我们直到最后才会对任何线程进行 `join`。好吧，这些线程会结束，但我们只允许最多八个线程同时运行。到某个时候，可能会有九个线程在运行，因为信号会触发，另一个线程会启动，然后这个线程会关闭。
- en: So in this case we could have an off by one but it doesn't matter but now there's
    nine threads instead of just eight。 Yeah。 Oh sorry yeah I didn't tell you about
    that one。 So in this case I guess there wouldn't be there probably doesn't after
    the thread just as a thread ends。 The semaphore allows you to say on thread exit
    do the actual semaphore releasing。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下，我们可能会遇到“多一个”的问题，但这没关系，现在有九个线程，而不是仅仅八个。是的，哦，对不起，没告诉你这一点。所以在这种情况下，我猜在线程结束后，应该没有问题。信号量允许你在线程退出时释放信号量。
- en: I don't know the magic that has to go into that we could probably look it up
    in the actual cut。 Let's go look it up real quick。 But yes if you want the if
    you want the signal to happen after the thread is when the thread is closing down
    that's what you would use for it。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道需要什么魔法才能做到这一点，可能可以在实际代码中查找。让我们快速查找一下。但没错，如果你想要在线程关闭时发信号，这就是你需要使用的方式。
- en: Good answer on there good question on that。 User class CS110 local source threads
    semaphore。cc。 Okay let's look for on thread exit。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的回答，关于这个问题。用户类 CS110 本地源线程信号量。cc。好了，接下来让我们看看线程退出时的情况。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_152.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_152.png)'
- en: Okay here we go。 Let's see。 Yeah so it looks like there needs to be some p thread
    magic going on there to basically say hey do this when the threads exiting and
    you can do that。 So it's a little bit of a little bit of under the hood magic
    happening there with leveraging that we're using threads to do all this。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们来看看。是的，看起来需要一些 pthread 的魔法来基本上说“嘿，线程退出时做这个”，然后你就可以这么做。所以，这里发生了一些背后的魔法，利用线程来做这一切。
- en: You do not need to know that for anything specifically just know that if you
    want to exit the thread or if you want to send that signal as the thread shutting
    down that's when to do it。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要专门了解这些内容，只需要知道，如果你想在线程关闭时退出或者发出信号，应该在那时执行。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_154.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_154.png)'
- en: Good question。 The question is that thread won't shut down until join。 It will
    shut down it won't get cleaned up until join。 So in other words it still stops
    and it's no longer taking up any cycles on the processor。 It's just waiting the
    operating system just the thread manager is waiting to clean it up until you join
    it。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的问题。问题是，线程在调用 `join` 之前不会关闭。它会关闭，但在调用 `join` 之前不会被清理。所以换句话说，线程停止运行了，但它不再占用处理器的任何周期。它只是等待，操作系统线程管理器会等到你调用
    `join` 才会清理它。
- en: Yeah other questions on this。 Alright let's see。 Think。 Yeah let's see。 I think
    the myths concurrently。 What does that do for us？
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，关于这个问题的其他问题吗？好吧，让我们看看。嗯，看看。我的意思是，竞争性执行的迷思。那对我们有什么帮助？
- en: That allows us to wait on the dumb flow network or the connection to happen。
    Okay because we've got lots of them happening。 Your computer has the ability to
    send lots of messages to different machines all at once。 That's fine。 It's got
    its own waiting and de-interleaving happening with that。 But as far as you're
    concerned your program can send as many messages it wants to different servers。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以等待流网络或连接的完成。好吧，因为我们有很多连接在发生。你的电脑有能力同时向不同的机器发送很多消息。没问题。它有自己的等待和解交错机制。但就你来说，程序可以向不同的服务器发送任意多的消息。
- en: In this case all the different myths at the same time through various threads。
    Okay。 They semaphore limits the number of threads and yeah here's the on thread
    exit that we talked about。 It's an overloaded version of signal。 It schedules
    after the entire thread is exited so that makes it so there's not nine threads
    at once going。 Although maybe for a very short amount of time but not long anyway。
    And that's it。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有不同的神话同时通过多个线程运行。好的。它的信号量限制了线程的数量，是的，这是我们讨论过的线程退出的内容。它是信号的一个重载版本。在整个线程退出之后，它才会调度，这样就避免了九个线程同时运行。虽然也许在非常短的时间内会有，但总的来说不会持续很久。就这样。
- en: You can see the concurrent one versus let's do this。 Let's do it in two different
    windows。 So let's do it this way。 Alright so I guess it's a little it's interesting
    that I'm running this on the myths and checking。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到并行的和让我们这样做的区别。让我们在两个不同的窗口中做。就这样做吧。好的，所以我猜有点有趣的是，我在运行这些神话并进行检查。
- en: '![](img/821506c5840d2c6177d1553f2ba392e4_156.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821506c5840d2c6177d1553f2ba392e4_156.png)'
- en: all the myths so it's a little。 Okay I think we can do it this way。 Here's what
    I'll do。 Let's do it。 Yeah I want to make this window a little smaller。 And okay
    so we're going to run myth buster。 Let's do the sequential on this side and then。
    Let's see。 Let's let's go。 Let's do the myth buster concurrent on this side。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的神话，所以有点儿。好的，我想我们可以这样做。接下来我会这样做。我们开始吧。是的，我想把这个窗口缩小一点。好的，所以我们将运行神话破解者。让我们在这一边做顺序的，然后。让我们看看。让我们开始吧。我们在这一边做神话破解者并行的。
- en: Now try to hit return and then really quickly hit the other one。 We could time
    that if we wanted to but I said okay ready boom boom。 Okay and the myths buster
    sequential on is still going while the other one's already done。 Alright did it
    all on threads all once this is the other one still one after the other after
    the other after the other。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着按回车键，然后迅速按另一个键。如果我们想要的话，我们可以计时，但我说好了，准备好，砰砰。好的，顺序的神话破解者仍在运行，而另一个已经完成了。好的，它所有的任务都在线程中完成，而这个则是一个接一个地完成。
- en: Alright what questions do you have about this stuff？
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你对这些内容有什么问题吗？
- en: You see how this threading you're going to have to think about race conditions
    a lot。 There's lots of cool models that we can do。 Next week we're going to or
    this week and then next we're going to talk about some other cool problems where
    we're modeling bigger ideas。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了吗，这个线程，你得经常考虑竞态条件。我们可以做很多很酷的模型。下周我们要讨论一些其他有趣的问题，讨论我们如何建模更大的概念。
- en: The particular one is an ice cream shop kind of fun。 They were going to model
    that allows you to do threads that are waiting on other threads and using this
    whole idea of permits and so forth。 Question。 If you don't specify a myth it checks
    all of them in this case。 Like umber as a day time。 Oh if you just yeah yeah good
    question if you this is just about logging on to the myths in general。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特别的例子是一个冰淇淋店，挺有趣的。他们将建模一个允许你使用等待其他线程的线程，并使用这种许可的想法等等。问题是，如果你没有指定某个神话，它会检查所有的神话，在这种情况下。比如说，“
    umber ”是一个白天时间。哦，如果你只… 是的，是的，好的问题，如果你，这只是关于一般登录到神话的内容。
- en: If you just say SSH myth it will pick one there is a load balancer that's doing
    exactly what our program just did kind of。 Basically it says who is busy right
    now now I think it's kind of continually looking at who's busy。 It's kind of got
    connections that are open all the time going who's busy who's busy and it tries
    to send you to the one that's least busy。 Right it can't figure out if I've got
    all those crosses stopped though so sometimes that won't。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只输入 SSH 神话，它会选择一个，实际上有一个负载均衡器在做我们程序刚刚做的事情。基本上，它会说谁现在忙，接着我想它会持续查看谁忙。它有持续开放的连接，一直在看谁忙，谁忙，然后尽量把你送到那个最不忙的。对，它无法判断我是不是所有的那些交叉点都停了，因此有时候它会失败。
- en: But no it definitely it's doing the exact same thing it's really doing more
    or less the same thing for you。 Yeah good question。 Alright any other questions
    think we'll get out here a couple minutes early。 Alright we'll see you Wednesday。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但不，它确实在做完全相同的事情，实际上它为你做的几乎是相同的事情。是的，好问题。好的，还有其他问题吗？我们可能会提前几分钟离开。好的，我们周三见。
