- en: 2.3 Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 递归
- en: 原文：[https://introcs.cs.princeton.edu/python/23recursion](https://introcs.cs.princeton.edu/python/23recursion)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/23recursion](https://introcs.cs.princeton.edu/python/23recursion)
- en: The idea of calling one function from another immediately suggests the possibility
    of a function calling *itself*. The function-call mechanism in Python supports
    this possibility, which is known as *recursion*. Recursion is a powerful general-purpose
    programming technique, and is the key to numerous critically important computational
    applications, ranging from combinatorial search and sorting methods methods that
    provide basic support for information processing (Chapter 4) to the Fast Fourier
    Transform for signal processing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个函数调用另一个函数的想法立即引出了函数调用*自身*的可能性。Python中的函数调用机制支持这种可能性，这被称为*递归*。递归是一种强大的通用编程技术，是许多至关重要的计算应用的关键，从组合搜索和排序方法（提供信息处理的基本支持（第4章））到用于信号处理的快速傅里叶变换。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Your First Recursive Program
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个递归程序
- en: 'The "HelloWorld" program for recursion is to implement the *factorial* function,
    which is defined for positive integers `n` by the equation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的"HelloWorld"程序是实现*阶乘*函数，对于正整数`n`，它由以下方程定义：
- en: '*n*! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*n*! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1'
- en: '*n*! is easy to compute with a `for` loop, but an even easier method, used
    in [factorial.py](factorial.py.html) is to use the following recursive function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 用`for`循环计算*n*!很容易，但更简单的方法是使用以下递归函数，[factorial.py](factorial.py.html)中使用了这种方法：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can persuade yourself that it produces the desired result by noting that
    `factorial()` returns 1 = 1! when *n* is 1 and that if it properly computes the
    value
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说服自己它会产生期望的结果，注意到`factorial()`在*n*为1时返回1 = 1!，并且如果它正确计算值
- en: (*n*-1)! = (*n*-1) × (*n*-2) × ... × 2 × 1
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (*n*-1)! = (*n*-1) × (*n*-2) × ... × 2 × 1
- en: then it properly computes the value
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它正确计算值
- en: '*n*! = *n* × (*n*-1)! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*n*! = *n* × (*n*-1)! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1'
- en: We can trace this computation in the same way that we trace any sequence of
    function calls.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像追踪任何函数调用序列一样追踪这个计算过程。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `factorial()` implementation exhibits the two main components that are required
    for every recursive function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`factorial()`实现展示了每个递归函数所需的两个主要组成部分。
- en: The *base case* returns a value without making any subsequent recursive calls.
    It does this for one or more special input values for which the function can be
    evaluated without recursion. For `factorial()`, the base case is `n = 1`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况*在不进行任何后续递归调用的情况下返回一个值。这是为了一种或多种特殊输入值，函数可以在没有递归的情况下进行评估。对于`factorial()`，基本情况是`n
    = 1`。'
- en: The *reduction step* is the central part of a recursive function. It relates
    the function at one (or more) inputs to the function evaluated at one (or more)
    other inputs. Furthermore, the sequence of parameter values must *converge* to
    the base case. For `factorial()`, the reduction step is `n * factorial(n-1)` and
    `n` decreases by one for each call, so the sequence of parameter values converges
    to the base case of `n = 1`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少步骤*是递归函数的核心���分。它将一个（或多个）输入处的函数与另一个（或多个）输入处的函数相关联。此外，参数值序列必须*收敛*到基本情况。对于`factorial()`，减少步骤是`n
    * factorial(n-1)`，每次调用`n`减少一次，因此参数值序列收敛到`n = 1`的基本情况。'
- en: '* * *'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Mathematical Induction
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学归纳
- en: Recursive programming is directly related to *mathematical induction*, a technique
    for proving facts about discrete functions. Proving that a statement involving
    an integer `n` is true for infinitely many values of *n* by mathematical induction
    involves two steps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 递归编程与*数学归纳*直接相关，这是一种用于证明关于离散函数的事实的技术。通过数学归纳证明涉及整数`n`的陈述对无限多个*n*值成立涉及两个步骤。
- en: The *base case* is to prove the statement true for some specific value or values
    of *n* (usually 0 or 1).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况*是为了证明某些特定值或值的陈述对*n*（通常为0或1）成立。'
- en: The *induction step* is the central part of the proof. For example, we typically
    assume that a statement is true for all positive integers less than *n*, then
    use that fact to prove it true for *n*.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*归纳步骤*是证明的核心部分。例如，我们通常假设一个陈述对小于*n*的所有正整数都成立，然后利用这个事实来证明它对*n*也成立。'
- en: 'Such a proof suffices to show that the statement is true for all *n*: we can
    start at the base case, and use our proof to establish that the statement is true
    for each larger value of *n*, one by one.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的证明足以表明该陈述对所有*n*值都成立：我们可以从基本情况开始，并使用我们的证明逐个证明该陈述对每个更大的*n*值都成立。
- en: '* * *'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Euclid's Algorithm
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧几里得算法
- en: The *greatest common divisor (gcd)* of two positive integers is the largest
    integer that divides evenly into both of them. For example, the greatest common
    divisor of 102 and 68 is 34 since both 102 and 68 are multiples of 34, but no
    integer larger than 34 divides evenly into 102 and 68.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 两个正整数的*最大公约数（gcd）*是能够整除它们的最大整数。例如，102和68的最大公约数是34，因为102和68都是34的倍数，但没有比34更大的整数能够整除102和68。
- en: 'We can efficiently compute the gcd using the following property, which holds
    for positive integers `p` and `q`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下性质高效地计算最大公约数，该性质适用于正整数`p`和`q`：
- en: '*If p > q, the gcd of p and q is the same as the gcd of q and p % q.*'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果p > q，则p和q的最大公约数与q和p % q的最大公约数相同。*'
- en: The function `gcd()` in [euclid.py](euclid.py.html) is a compact recursive function
    whose reduction step is based on this property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[euclid.py](euclid.py.html)中的`gcd()`函数是一个紧凑的递归函数，其减少步骤基于这个性质。'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '* * *'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Towers of Hanoi
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汉诺塔
- en: 'No discussion of recursion would be complete without the ancient *Towers of
    Hanoi* problem. We have three poles and *n* discs that fit onto the poles. The
    discs differ in size and are initially arranged on one of the poles, in order
    from largest (disc *n*) at the bottom to smallest (disc 1) at the top. The task
    is to move the stack of discs to another pole, while obeying the following rules:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没有讨论递归就不完整的话题是古老的*汉诺塔*问题。我们有三根柱子和*n*个适合放在柱子上的盘子。盘子的大小不同，最初排列在其中一根柱子上，从最大的盘子*n*到最小的盘子1。任务是将盘子堆移到另一根柱子上，同时遵守以下规则：
- en: Move only one disc at a time.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次只移动一个盘子。
- en: Never place a disc on a smaller one.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将一个盘子放在一个较小的盘子上。
- en: To solve the problem, our goal is to issue a sequence of instructions for moving
    the discs. We assume that the poles are arranged in a row, and that each instruction
    to move a disc specifies its number and whether to move it left or right. If a
    disc is on the left pole, an instruction to move left means to wrap to the right
    pole; if a disc is on the right pole, an instruction to move right means to wrap
    to the left pole.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我们的目标是发出一系列指令来移动盘子。我们假设柱子是排成一排的，并且每个移动盘子的指令都指定了它的编号以及是向左还是向右移动。如果一个盘子在左柱上，那么向左移动的指令意味着移到右柱；如果一个盘子在右柱上，那么向右移动的指令意味着移到左柱。
- en: 'Recursion provides the plan that we need, based on the following idea: first
    we move the top *n*-1 discs to an empty pole, then we move the largest disc to
    the other empty pole (where it does not interfere with the smaller ones), and
    then we compete the job by moving the *n*-1 discs onto the largest disc. The [towersofhanoi.py](towersofhanoi.py.html)
    program is a direct implementation of that plan.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 递归提供了我们需要的计划，基于以下想法：首先我们将顶部的*n*-1个盘子移动到一个空柱子上，然后我们将最大的盘子移动到另一个空柱子上（这样它就不会干扰较小的盘子），然后我们通过将*n*-1个盘子移动到最大的盘子上来完成工作。[towersofhanoi.py](towersofhanoi.py.html)程序是该计划的直接实现。
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exponential Time
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数时间
- en: '![exponential growth](../Images/938fdb6e176f7cff0dbb9076aeb490e4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![指数增长](../Images/938fdb6e176f7cff0dbb9076aeb490e4.png)'
- en: 'One legend says that the world will end when a certain group of monks solves
    the Towers of Hanoi problem in a temple with 64 golden discs on three diamond
    needles. We can estimate the amount of time until the end of the world (assuming
    that the legend is true). If we define the function *T*(*n*) to be the number
    of move directives issued by `towersofhanoi.py` to move *n* discs from one peg
    to another, then the recursive code implies that *T*(*n*) must satisfy the following
    equation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个传说说，当一群特定的僧侣在一个寺庙里用三根金针上的64个金盘解决汉诺塔问题时，世界将会终结。我们可以估计到世界末日的时间（假设传说是真实的）。如果我们定义函数*T*(*n*)为`towersofhanoi.py`发出的移动*n*个盘子从一个柱子到另一个柱子的指令数量，那么递归代码意味着*T*(*n*)必须满足以下方程：
- en: '*T*(*n*) = 2 *T*(*n* - 1) + 1 for *n* > 1, with *T*(1) = 1'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*T*(*n*) = 2 *T*(*n* - 1) + 1 for *n* > 1, with *T*(1) = 1'
- en: Such an equation is known in discrete mathematics as a *recurrence relation*.
    We can often use them to derive a closed-form expression for the quantity of interest.
    For example, *T*(1) = 1, *T*(2) = 3, *T*(3) = 7, and *T*(4) = 15\. In general,
    *T*(*n*) = 2^(*n*) - 1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的方程在离散数学中被称为*递归关系*。我们经常可以使用它们推导出所关心的数量的封闭形式表达式。例如，*T*(1) = 1，*T*(2) = 3，*T*(3)
    = 7，*T*(4) = 15。一般来说，*T*(*n*) = 2^(*n*) - 1。
- en: Knowing the value of *T*(*n*), we can estimate the amount of time required to
    perform all the moves. If the monks move discs at the rate of one per second,
    it would take more than one week for them to finish a 20-disc problem, more than
    31 years to finish a 30-disc problem, and more than 348 centuries for them to
    finish a 40-disc problem (assuming that they do not make a mistake). The 64-disc
    problem would take more than 5.8 billion centuries.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 知道*T*(*n*)的值，我们可以估计执行所有移动所需的时间。如果僧侣们每秒移动一个盘子，那么完成一个20盘子问题将需要超过一周的时间，完成一个30盘子问题将需要超过31年的时间，完成一个40盘��问题将需要超过348个世纪的时间（假设他们不犯错误）。64盘子问题将需要超过58亿个世纪的时间。
- en: '* * *'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Gray Code
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格雷码
- en: 'The playwright Samuel Beckett wrote a play called *Quad* that had the following
    property: Starting with an empty stage, characters enter and exit one at a time,
    but each subset of characters on the stage appears exactly once. The play had
    four characters and there are 2⁴ = 16 different subsets of four elements; hence
    the title. How did Beckett generate the stage directions for this play? How would
    we do it for 5 actors, or more?'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 剧作家塞缪尔·贝克特写了一部名为*Quad*的戏剧，具有以下特点：从一个空舞台开始，角色一个接一个地进入和退出，但舞台上的每个角色子集都只出现一次。这部戏剧有四个角色，有2⁴
    = 16种不同的四个元素子集；因此得名。贝克特是如何为这部戏剧生成舞台指示的？我们如何为5位演员或更多演员做到这一点？
- en: '| ![Gray code representations](../Images/b0e061fba5db48825073246abc8e08c7.png)
    |  | ![2-, 3-, and 4-bit Gray codes](../Images/bbd92b4dd7b1530237ef0f915aa75545.png)
    |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![格雷码表示](../Images/b0e061fba5db48825073246abc8e08c7.png) |  | ![2位、3位和4位格雷码](../Images/bbd92b4dd7b1530237ef0f915aa75545.png)
    |'
- en: An *n*-bit *Gray code* is a list of the 2^(*n*) different *n*-bit binary numbers
    such that each entry in the list differs in precisely one bit from its predecessor.
    Gray codes directly apply to Beckett's problem because we can interpret each bit
    as denoting whether the integer corresponding to its bit position is in the subset.
    Changing the value of a bit from 0 to 1 corresponds to an integer entering the
    subset; changing a bit from 1 to 0 corresponds to and integer exiting the subset.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*n*位的*格雷码*是一个包含2^(*n*)个不同的*n*位二进制数的列表，使得列表中的每个条目与其前一个条目恰好在一位上不同。格雷码直接适用于贝克特的问题，因为我们可以将每一位解释为其位位置对应的整数是否在子集中。将一位的值从0改为1对应于一个整数进入子集；将一位的值从1改为0对应于一个整数退出子集。
- en: 'How do we generate a Gray code? A recursive plan that is very similar to the
    one that we used for the Towers of Hanoi problem is effective. The *n* bit binary
    reflected Gray code is defined recursively as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何生成格雷码？一个递归计划，与我们用于汉诺塔问题的计划非常相似，是有效的。*n*位二进制反射格雷码的定义如下递归地进行：
- en: the *n*-1 bit code, with 0 prepended to each word, followed by
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*-1位代码，每个单词前面加0，然后是'
- en: the *n*-1 bit code in reverse order, with 1 prepended to each word.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*n*-1位代码按相反顺序排列，每个单词前面加上1。
- en: The 0-bit code is defined to be null, so the 1-bit code is 0 followed by 1\.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 0位代码被定义为空，因此1位代码是0后跟1。
- en: The recursive definition leads, after some careful thought, to the implementation
    in [beckett.py](beckett.py.html) for writing Beckett's stage directions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些仔细思考，递归定义导致了在[beckett.py](beckett.py.html)中实现贝克特舞台指示的实现。
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Recursive Graphics
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归图形
- en: 'Simple recursive drawing schemes can lead to pictures that are remarkably intricate.
    For example, an *H-tree of order n* is defined as follows: The base case is null
    for *n* = 0\. The reduction step is to draw, within the unit square three lines
    in the shape of the letter H four H-trees of order *n*-1, one connected to each
    tip of the H with the additional provisos that the H-trees of order *n*-1 are
    centered in the four quadrants of the square, halved in size. Program [htree.py](htree.py.html)
    takes a command-line argument `n`, and plots an order *n* H-tree using standard
    draw.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的递归绘图方案可能导致非常复杂的图片。例如，*n*阶H树的定义如下：当*n*=0时，基本情况为空。减少步骤是在单位正方形内绘制三条H形状的线，四个*n*-1阶H树，每个H形状的顶端连接到H的一个顶端，附加条件是*n*-1阶H树位于正方形的四个象限的中心，尺寸减半。程序[htree.py](htree.py.html)接受一个命令行参数`n`，并使用标准绘图绘制一个*n*阶H树。
- en: '| ![htree 1](../Images/c3ed4edf61ea3ca596d5ecf00bf3511f.png) | ![htree 2](../Images/1a8232d62b444aff139b3a8508dc2be6.png)
    | ![htree 3](../Images/b942420950f82948387919d9aee0eabd.png) | ![htree 4](../Images/3436d0cfb6f0833018f5aac682bc598f.png)
    | ![htree 5](../Images/5d6ca3619e95c5a86a988cd0b8701433.png) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| ![htree 1](../Images/c3ed4edf61ea3ca596d5ecf00bf3511f.png) | ![htree 2](../Images/1a8232d62b444aff139b3a8508dc2be6.png)
    | ![htree 3](../Images/b942420950f82948387919d9aee0eabd.png) | ![htree 4](../Images/3436d0cfb6f0833018f5aac682bc598f.png)
    | ![htree 5](../Images/5d6ca3619e95c5a86a988cd0b8701433.png) |'
- en: '* * *'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Brownian Bridge
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布朗桥
- en: 'An H-tree is a simple example of a *fractal*: a geometric shape that can be
    divided into parts, each of which is (approximately) a reduced size copy of the
    original. The study of fractals plays an important and lasting role in artistic
    expression, economic analysis, and scientific discovery. Artists and scientists
    use them to build compact models of complex shapes that arise in nature and resist
    description using conventional geometry, such as clouds, plants, mountains, riverbeds,
    human skin, and many others. Economists also use fractals to model function graphs
    of economic indicators.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: H树是*分形*的一个简单示例：一个几何形状，可以被分成部分，每个部分（大致上）是原始形状的缩小副本。对分形的研究在艺术表达、经济分析和科学发现中起着重要而持久的作用。艺术家和科学家使用它们来构建复杂形状的紧凑模型，这些形状在自然界中出现，并且难以用传统几何描述，如云、植物、山脉、河床、人类皮肤等。经济学家也使用分形来建模经济指标的函数图。
- en: 'Program [brownian.py](brownian.py.html) produces a function graph that approximates
    a simple example known as a *Brownian bridge* and closely related functions. You
    can think of this graph as a random walk that connects two points, from (*x*[0],
    *y*[0]) to (*x*[1], *y*[1]), controlled by a few parameters. The implementation
    is based on the *midpoint displacement method*, which is a recursive plan for
    drawing the plot within an interval [*x*[0], *x*[1]]. The base case (when the
    size of the interval is smaller than a given tolerance) is to draw a straight
    line connecting the two endpoints. The reduction case is to divide the interval
    into two halves, proceeding as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[brownian.py](brownian.py.html)生成一个函数图，近似一个称为*布朗桥*的简单示例和密切相关的函数。您可以将这个图形看作是连接两点的随机漫步，从(*x*[0]，*y*[0])到(*x*[1]，*y*[1])，由几个参数控制。该实现基于*中点位移法*，这是一个用于在区间[*x*[0]，*x*[1]]内绘制图形的递归计划。基本情况（当区间大小小于给定容差时）是��制连接两个端点的直线。减少情况是将区间分成两半，然后继续如下：
- en: Compute the midpoint (*x*[*m*], *y*[*m*]) of the interval.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算区间的中点（*x*[*m*]，*y*[*m*]）。
- en: Add to the `y`-coordinate of the midpoint a random value *δ*, chosen from the
    Gaussian distribution with mean 0 and given variance.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中点的`y`坐标上加上一个从均值为0且给定方差的高斯分布中选择的随机值*δ*。
- en: Recur on the subintervals, dividing the variance by a given scaling factor *s*.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子区间上进行递归，通过给定的缩放因子*s*来减少方差。
- en: 'The shape of the curve is controlled by two parameters: the *volatility* (initial
    value of the variance) controls the distance the graph strays from the straight
    line connecting the points, and the *Hurst exponent* controls the smoothness of
    the curve. We denote the Hurst exponent by *H* and divide the variance by 2^(2*H*)
    at each recursive level. When *H* is 1/2 (divide by 2 at each level) the standard
    deviation is constant throughout the curve: in this situation, the curve is a
    Brownian bridge. These images show the output generated by the commands `python
    brownian.py 1`, `python brownian.py .5`, and `python brownian.py .05`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的形状由两个参数控制：*波动性*（方差的初始值）控制图形偏离连接点的直线的距离，*赫斯特指数*控制曲线的平滑度。我们用*H*表示赫斯特指数，并在每个递归级别将方差除以2^(2*H*)。当*H*为1/2（每个级别除以2）时，标准差在整个曲线上保持恒定：在这种情况下，曲线是一个布朗桥。这些图像显示了由命令`python
    brownian.py 1`、`python brownian.py .5`和`python brownian.py .05`生成的输出。
- en: '| ![Brownian bridge](../Images/f68c09b7605aa0186306f5df9ad635ad.png) | ![Brownian
    bridge](../Images/114230a603be3f1fd0f2eb194bd18644.png) | ![Brownian bridge](../Images/715f81008644e03f7bf0f0902cac534e.png)
    |'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![布朗桥](../Images/f68c09b7605aa0186306f5df9ad635ad.png) | ![布朗桥](../Images/114230a603be3f1fd0f2eb194bd18644.png)
    | ![布朗桥](../Images/715f81008644e03f7bf0f0902cac534e.png) |'
- en: '* * *'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Pitfalls of Recursion
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归的陷阱
- en: With recursion, you can compose compact and elegant programs that fail spectacularly
    at runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归，您可以编写简洁而优雅的程序，在运行时引起惊人的失败。
- en: '**Missing base case**. This recursive function is supposed to compute Harmonic
    numbers, but is missing a base case:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺少基本情况**。这个递归函数应该计算调和数，但缺少一个基本情况：'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you call this function, it will repeatedly call itself and never return.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这个函数，它将不断调用自身而永远不会返回。
- en: '**No guarantee of convergence.** Another common problem is to include within
    a recursive function a recursive call to solve a subproblem that is not smaller.
    For example, this recursive function will go into an infinite recursive loop if
    it is invoked with an argument n having any value other than 1:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**不保证收敛。** 另一个常见问题是在递归函数中包含一个递归调用来解决一个不比原问题更小的子问题。例如，如果使用任何值而不是1调用参数n来调用此递归函数，它将进入无限递归循环：'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Excessive space requirements.** Python needs to keep track of each recursive
    call to implement the function abstraction as expected. If a function calls itself
    recursively an excessive number of times before returning, the space required
    by Python for this task may be prohibitive. For example, this recursive function
    correctly computes the nth harmonic number. However, we cannot use it for large
    *n* because the recursive depth is proportional to *n*, and this creates a `StackOverflowError`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**过度空间需求。** Python需要跟踪每个递归调用以按预期实现函数抽象。如果一个函数在返回之前递归调用自身过多次，Python为此任务所需的空间可能是禁止的。例如，这个递归函数正确计算第n个调和数。然而，我们不能用它来计算大的*n*，因为递归深度与*n*成正比，这会导致`StackOverflowError`。'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Wrong way to compute Fibonacci numbers](../Images/2607a96b65fea126267c99324a64e48e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![计算斐波那契数的错误方法](../Images/2607a96b65fea126267c99324a64e48e.png)'
- en: '**Excessive recomputation.** The temptation to write a simple recursive program
    to solve a problem must always be tempered by the understanding that a simple
    program might require exponential time (unnecessarily), due to excessive recomputation.
    For example, the Fibonacci sequence'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**过度重复计算。** 编写一个简单的递归程序来解决问题的诱惑必须始终受到这样的理解的限制，即简单程序可能需要指数时间（不必要地），因为存在过度重复计算。例如，斐波那契数列'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: is defined by the formula *F*[*n*] = *F*[*n*-1] + *F*[*n*-2] for *n* ≥ 2 with
    *F*[0] = 0 and *F*[1] = 1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由公式*F*[*n*] = *F*[*n*-1] + *F*[*n*-2]定义，其中*n* ≥ 2，*F*[0] = 0，*F*[1] = 1。
- en: 'A novice programmer might implement this recursive function to compute numbers
    in the Fibonacci sequence:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个初学者程序员可能会实现这个递归函数来计算斐波那契数列中的数字：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, this program is spectacularly inefficient! For example, consider what
    the function does to compute `fib(7)` = 13\. It first computes `fib(6)` = 8 and
    `fib(5)` = 5\. To compute `fib(6)`, it recursively computes `fib(5)` = 5 again
    and `fib(4)` = 3\. Things rapidly get worse because both times it computes `fib(5)`,
    it ignores the fact that it already computed `fib(4)`, and so forth. The number
    of times this program computes `fib(1)` when computing `fib(n)` is precisely *F*[*n*].
    The mistake of recomputation is compounded, exponentially. No imaginable computer
    will ever be able to do that many calculations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个程序效率极低！例如，考虑计算`fib(7)` = 13的函数。它首先计算`fib(6)` = 8和`fib(5)` = 5。为了计算`fib(6)`，它递归计算`fib(5)`
    = 5和`fib(4)` = 3。事情迅速变得更糟，因为两次计算`fib(5)`时，它忽略了已经计算过`fib(4)`，依此类推。当计算`fib(n)`时，这个��序计算`fib(1)`的次数恰好是*F*[*n*]。重复计算的错误成倍增加。任何想象得到的计算机都无法执行那么多次计算。
- en: Incidentally, a systematic technique known as *memoization* allows us to avoid
    this pitfall while still taking advantage of the compact recursive description
    of a computation. In memoization, we maintain an array that keeps track of the
    values we have computed so that we can return those values and make recursive
    calls only for new values. This technique is a form of *dynamic programming*,
    a well-studied technique for organizing computations that you will learn if you
    take courses in algorithms or operations research.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，一种称为*记忆化*的系统技术允许我们避免这种陷阱，同时仍然利用计算的紧凑递归描述。在记忆化中，我们维护一个数组，以跟踪我们已经计算的值，这样我们可以返回这些值，并仅对新值进行递归调用。这种技术是*动态规划*的一种形式，这是一种组织计算的良好技术，如果你学习算法或运筹学课程，你将学到的。
- en: '* * *'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** Are there situations when iteration is the only option available to
    address a problem?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 有没有情况下迭代是解决问题的唯一选择？'
- en: '**A.** No, any loop can be replaced by a recursive function, though the recursive
    version might require excessive memory.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 不，任何循环都可以用递归函数替代，尽管递归版本可能需要过多的内存。'
- en: '**Q.** Are there situations when recursion is the only option available to
    address a problem?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 有没有情况下递归是解决问题的唯一选择？'
- en: '**A.** No, any recursive function can be replaced by an iterative counterpart.
    In Section 4.3, we will see how compilers produce code for function calls by using
    a data structure called a *stack*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 不，任何递归函数都可以用迭代方式替代。在第4.3节中，我们将看到编译器如何通过使用称为*栈*的数据结构为函数调用生成代码。'
- en: '**Q.** Which should I prefer, recursion or iteration?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 我应该更喜欢递归还是迭代？'
- en: '**A.** Whichever leads to the simpler, more easily understood, or more efficient
    code.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 任何导致更简单、更易理解或更高效代码的方式。'
- en: '**Q.** I get the concern about excessive space and excessive recomputation
    in recursive code. Anything else to be concerned about?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 我理解递归代码中过度空间和过度重复计算的担忧。还有其他需要关注的问题吗？'
- en: '**A.** Be extremely wary of creating arrays in recursive code. The amount of
    space used can pile up very quickly, as can the amount of time required for memory
    management.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 在递归代码中极度谨慎地创建数组。使用的空间量可能会非常迅速地增加，内存管理所需的时间也会增加。'
- en: '* * *'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: What happens if you run `factorial()` with negative value of `n`? With a large
    value, say 35?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你用负值的`n`运行`factorial()`会发生什么？用一个大值，比如35呢？
- en: Compose a recursive program that computes the value of *ln*(*n*!).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归程序，计算*ln*(*n*!)的值。
- en: 'Give the sequence of integers written by a call to `ex233(6)`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出调用`ex233(6)`时写出的整数序列：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Give the value of `ex234(6)`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出`ex234(6)`的值：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Criticize the following recursive function:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批评以下递归函数：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Solution*: The base case will never be reached. A call to `ex235(3)` will
    result in calls to `ex235(0)`, `ex235(-3)`, `ex235(-6)`, and so forth until the
    "maximum depth exceeded" run-time error occurs.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：基本情况永远不会被触发。调用`ex235(3)`将导致调用`ex235(0)`、`ex235(-3)`、`ex235(-6)`等，直到发生"超出最大深度"的运行时错误。'
- en: Given four positive integers `a`, `b`, `c`, and `d`, explain what value is computed
    by `gcd(gcd(a, b), gcd(c, d))`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定四个正整数`a`、`b`、`c`和`d`，解释`gcd(gcd(a, b), gcd(c, d))`计算的值是什么。
- en: Explain in terms of integers and divisors the effect of the following Euclid-like
    function.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用整数和除数的术语解释以下类似欧几里得函数的效果。
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Solution.* Returns whether `p` and `q` are relatively prime.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。返回`p`和`q`是否互质。'
- en: 'Consider the following recursive function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下递归函数：
- en: '[PRE12]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What are the values of `mystery(2, 25)` and `mystery(3, 11)`? Given positive
    integers `a` and `b`, describe what value `mystery(a, b)` computes. Answer the
    same question, but replace `+` with `*` and replace `return 0` with `return 1`.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mystery(2, 25)`和`mystery(3, 11)`的值是多少？给定正整数`a`和`b`，描述`mystery(a, b)`计算的值。用`*`替换`+`，用`return
    1`替换`return 0`回答相同的问题。'
- en: '*Solution.* 50 and 33\. It computes `a*b`. If you replace `+` with `*`, it
    computes `a^b`.'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：50和33。它计算`a*b`。如果你用`*`替换`+`，它计算`a^b`。'
- en: Compose a recursive program `ruler.py` to plot the subdivisions of a ruler using
    `stddraw` as in the [ruler.py](../12types/ruler.py.html) program from Section
    1.2.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归程序`ruler.py`，使用`stddraw`绘制标尺的划分，就像第1.2节中的[ruler.py](../12types/ruler.py.html)程序一样。
- en: Solve the following recurrence relations, all with *T*(1) = 1\. Assume *n* is
    a power of two.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决以下递归关系，均满足*T*(1) = 1。假设*n*是2的幂。
- en: '*T*(*n*) = *T*(*n*/2) + 1'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T*(*n*) = *T*(*n*/2) + 1'
- en: '*T*(*n*) = 2*T*(*n*/2) + 1'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T*(*n*) = 2*T*(*n*/2) + 1'
- en: '*T*(*n*) = 2*T*(*n*/2) + *n*'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T*(*n*) = 2*T*(*n*/2) + *n*'
- en: '*T*(n) = 4*T*(*n*/2) + 3'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T*(n) = 4*T*(*n*/2) + 3'
- en: Prove by induction that the minimum possible number of moves needed to solve
    the Towers of Hanoi puzzle satisfies the same recurrence as the number of moves
    used by our recursive solution.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过归纳证明，解汉诺塔谜题所需的最小移动次数满足我们递归解决方案使用的移动次数相同的递归关系。
- en: Prove by induction that the recursive program given above makes exactly *F*[*n*]
    recursive calls to `fib(1)` when computing `fib(n)`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过归纳证明，上面给出的递归程序在计算`fib(n)`时对`fib(1)`进行了恰好*F*[*n*]次递归调用。
- en: Prove that the second argument to `gcd()` decreases by at least a factor of
    two for every second recursive call, then prove that `gcd(p, q)` uses at most
    log[2]*n* recursive calls, where *n* is the larger of *p* and *q*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明`gcd()`的第二个参数在每第二次递归调用时至少减少一半，然后证明`gcd(p, q)`最多使用log[2]*n*次递归调用，其中*n*是*p*和*q*中较大的一个。
- en: Modify `htree.py` to animate the drawing of the H-tree.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`htree.py`���动画显示H树的绘制。
- en: '![Animated h-tree](../Images/39c8c4e203a2ebfdfcab9deac295cf57.png)'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![动画H树](../Images/39c8c4e203a2ebfdfcab9deac295cf57.png)'
- en: Next, rearrange the order of the recursive calls (and the base case), view the
    resulting animation, and explain each outcome.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，重新排列递归调用的顺序（和基本情况），查看结果动画，并解释每个结果。
- en: '* * *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Binary representation.** Compose a program that takes a positive integer
    *n* (in decimal) from the command line and writes its binary representation. Recall
    that in Section 1.3 we used the method of subtracting out powers of 2\. Instead,
    use the following simpler method: repeatedly divide 2 into *n* and read the remainders
    backwards. First, compose a `while` loop to carry out this computation and write
    the bits in the wrong order. Then, use recursion to write the bits in the correct
    order.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二进制表示。** 编写一个程序，从命令行接受一个正整数*n*（十进制），并写出它的二进制表示。回想一下，在第1.3节中，我们使用了减去2的幂的方法。相反，使用以下更简单的方法：反复将2除以*n*，并倒序读取余数。首先，编写一个`while`循环执行这个计算，并以错误的顺序写出位。然后，使用递归以正确的顺序写出位。'
- en: '*Solution*: See [binaryconverter.py](binaryconverter.py.html).'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：见[binaryconverter.py](binaryconverter.py.html)。'
- en: '**A4 paper.** The width-to-height ratio of paper in the [ISO format](http://www.cl.cam.ac.uk/~mgk25/iso-paper.html)
    is the square root of 2 to 1\. Format A0 has an area of 1 square meter. Format
    A1 is A0 cut with a vertical line into two equal halves, A2 is A1 cut with a horizontal
    line into in two halves, and so on. Write a program that takes a command-line
    argument *n* and uses `stddraw` to show how to cut a sheet of A0 paper into 2^(*n*)
    pieces. Here''s a nice [illustration of A size formats](http://upload.wikimedia.org/wikipedia/commons/b/b7/A_size_illustration.png).'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**A4纸。** [ISO格式](http://www.cl.cam.ac.uk/~mgk25/iso-paper.html)纸张的宽高比是2的平方根比1。A0格式的面积为1平方米。A1格式是将A0垂直切成两等份，A2是将A1水平切成两等份，依此类推。编写一个程序，接受一个命令行参数*n*，并使用`stddraw`显示如何将一张A0纸切成2^(*n*)份。这里有一个漂亮的[A尺寸格式示意图](http://upload.wikimedia.org/wikipedia/commons/b/b7/A_size_illustration.png)。'
- en: '**Permutations.** Compose a program that takes a command-line argument *n*
    and writes all *n*! permutations of the *n* letters starting at a (assume that
    `n` is no greater than 26). A *permutation* of *n* elements is one of the *n*!
    possible orderings of the elements. As an example, when *n* = 3 you should get
    the following output. Do not worry about the order in which you enumerate them.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列。** 编写一个程序，接受一个命令行参数*n*，并写出从a开始的*n*!个排列的*n*个字母（假设`n`不大于26）。*n*个元素的排列是元素的*n*!种可能的排序之一。例如，当*n*=3时，你应该得到以下输出。不用担心你枚举它们的顺序。'
- en: '[PRE13]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Solution*: See [permutations.py](permutations.py.html).'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：见[permutations.py](permutations.py.html)。'
- en: '**Permutations of size *k*.** Modify your solution to the previous exercise
    so that it takes two command-line arguments *n* and *k*, and writes all *P*(*n*,
    *k*) = *n*! / (*n*-*k*)! permutations that contain exactly *k* of the *n* elements.
    Below is the desired output when *k* = 2 and *n* = 4\. You need not write them
    in any particular order.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大小为*k*的排列。** 修改你之前练习的解决方案，使其接受两个命令行参数*n*和*k*，并写出包含*n*个元素中恰好*k*个的*n*! / (*n*-*k*)!排列。当*k*=2且*n*=4时，以下是期望的输出。你不需要按任何特定顺序写出它们。'
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Solution*: See [perm.py](perm.py.html).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：见[perm.py](perm.py.html)。'
- en: '**Combinations.** Compose a program that takes one integer command-line argument
    *n* and writes all 2^(*n*) *combinations* of any size. A combination is a subset
    of the *n* elements, independent of order. As an example, when *n* = 3 you should
    get the following output.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组合。** 编写一个程序，接受一个整数命令行参数 *n*，并写出任意大小的所有 2^(*n*) *组合*。组合是 *n* 个元素的子集，与顺序无关。例如，当
    *n* = 3 时，你应该得到以下输出。'
- en: '[PRE15]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the first element written is the empty string (subset of size 0).
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，第一个写出的元素是空字符串（大小为 0 的子集）。
- en: '*Solution*: See [combinations.py](combinations.py.html).'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 参见 [combinations.py](combinations.py.html)。'
- en: '**Combinations of size `k`.** Modify your solution to the previous exercise
    so that it takes two command-line arguments *n* and *k*, and writes all *C**(n*,
    *k*) = *n*! / (*k*! * (*n*-*k*)!) *combinations* of size *k*. For example, when
    *n* = 5 and *k* = 3 you should get the following output.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大小为 `k` 的组合。** 修改你之前练习的解决方案，使其接受两个命令行参数 *n* 和 *k*，并写出所有大小为 *k* 的 *C**(n*,
    *k*) = *n*! / (*k*! * (*n*-*k*)!) *组合*。例如，当 *n* = 5 且 *k* = 3 时，你应该得到以下输出。'
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Solution*: See [comb.py](comb.py.html).'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 参见 [comb.py](comb.py.html)。'
- en: '**Hamming distance.** The Hamming distance between two bit strings of length
    *n* is equal to the number of bits in which the two strings differ. Compose a
    program that takes an integer *k* and a bit string *s* from the command line,
    and writes all bit strings that have Hamming distance at most *k* from *s*. For
    example if *k* is 2 and *s* is 0000 then your program should write:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汉明距离。** 两个长度为 *n* 的比特串之间的汉明距离等于这两个串中不同的比特数。编写一个程序，从命令行接受一个整数 *k* 和一个比特串 *s*，并写出与
    *s* 的汉明距离最多为 *k* 的所有比特串。例如，如果 *k* 为 2，*s* 为 0000，则你的程序应该写出：'
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Hint*: choose *k* of the *n* bits in *s* to flip.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*: 选择 *s* 中的 *n* 位中的 *k* 位进行翻转。'
- en: '**Recursive squares.** Compose a program to produce each of the following recursive
    patterns. The ratio of the sizes of the squares is 2.2:1\. To draw a shaded square,
    draw a filled gray square, then an unfilled black square.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**递归方块。** 编写一个程序来生成以下递归图案。方块大小的比例为 2.2:1。要绘制一个阴影方块，先绘制一个填充的灰色方块，然后是一个未填充的黑色方块。'
- en: '| ![](../Images/84ea47fc520362efa19ee7fe093ebd72.png) | ![](../Images/4b5a9b292b61ca6bb9ad851f123df731.png)
    | ![](../Images/95575c922f02cb3ef1ff49e6365a3ef9.png) | ![](../Images/75a5acb259f4112db5e0a1cdb2636b42.png)
    |'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
  zh: '| ![](../Images/84ea47fc520362efa19ee7fe093ebd72.png) | ![](../Images/4b5a9b292b61ca6bb9ad851f123df731.png)
    | ![](../Images/95575c922f02cb3ef1ff49e6365a3ef9.png) | ![](../Images/75a5acb259f4112db5e0a1cdb2636b42.png)
    |'
- en: '| ![](../Images/7d9550b3af8284e66a563d4cb6fedb11.png) | ![](../Images/43519ae4e5ee974eaf460c59556276ec.png)
    | ![](../Images/9b6373f947301245661d48dfb666c3e2.png) | ![](../Images/a3bd5bf4e15b0f9d922d58648161224a.png)
    |'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
  zh: '| ![](../Images/7d9550b3af8284e66a563d4cb6fedb11.png) | ![](../Images/43519ae4e5ee974eaf460c59556276ec.png)
    | ![](../Images/9b6373f947301245661d48dfb666c3e2.png) | ![](../Images/a3bd5bf4e15b0f9d922d58648161224a.png)
    |'
- en: '| ![](../Images/f5757b88ff729bf3e506ca924d9e86ae.png) | ![](../Images/4fb704e173a67519fc558b58418a8010.png)
    | ![](../Images/b7685f4ac2b3d02c87838c04e2663e62.png) | ![](../Images/32fec4c578cf37ccc67731cf363cd81d.png)
    |'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
  zh: '| ![](../Images/f5757b88ff729bf3e506ca924d9e86ae.png) | ![](../Images/4fb704e173a67519fc558b58418a8010.png)
    | ![](../Images/b7685f4ac2b3d02c87838c04e2663e62.png) | ![](../Images/32fec4c578cf37ccc67731cf363cd81d.png)
    |'
- en: '| ![](../Images/a03dc5dedb6595f00ffc14516c3797f7.png) | ![](../Images/56eddbdeca4aca351d0c00dab3219c78.png)
    | ![](../Images/7c035dd9d3443560c3e1435c56e8e7fa.png) | ![](../Images/bfe8dbbcf5f16647fdc8c5c3face91c0.png)
    |'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
  zh: '| ![](../Images/a03dc5dedb6595f00ffc14516c3797f7.png) | ![](../Images/56eddbdeca4aca351d0c00dab3219c78.png)
    | ![](../Images/7c035dd9d3443560c3e1435c56e8e7fa.png) | ![](../Images/bfe8dbbcf5f16647fdc8c5c3face91c0.png)
    |'
- en: '*Solution*: See [recursivesquares.py](recursivesquares.py.html) for a solution
    to part a.'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 参见 [recursivesquares.py](recursivesquares.py.html) 以获取第 a 部分的解决方案。'
- en: '**Pancake flipping.** You have a stack of *n* pancakes of varying sizes on
    a griddle. Your goal is to rearrange the stack in descending order so that the
    largest pancake is on the bottom and the smallest one is on top. You are only
    permitted to flip the top *k* pancakes, thereby reversing their order. Devise
    a scheme to arrange the pancakes in the proper order by using at most 2*n* - 3
    flips.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**煎饼翻转。** 你有一堆在煎锅上大小不同的 *n* 块煎饼。你的目标是重新排列这些煎饼，使最大的煎饼在底部，最小的在顶部。你只能翻转顶部的 *k*
    块煎饼，从而颠倒它们的顺序。设计一个方案，通过最多 2*n* - 3 次翻转将煎饼排列成正确的顺序。'
- en: '*Hint*: you can [try out strategies](http://www.cut-the-knot.org/SimpleGames/Flipper.shtml)
    here.'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*: 你可以在这里[尝试策略](http://www.cut-the-knot.org/SimpleGames/Flipper.shtml)。'
- en: '**Gray code.** Modify `beckett.py` to write the Gray code, not just the sequence
    of bit positions that change.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**格雷码。** 修改 `beckett.py` 以写出格雷码，而不仅仅是变化的位位置序列。'
- en: '*Solution*: See [graycode.py](graycode.py.html).'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 参见 [graycode.py](graycode.py.html)。'
- en: '**Towers of Hanoi variant.** Consider the following variant of the Towers of
    Hanoi problem. There are 2*n* discs of increasing size stored on three poles.
    Initially all of the discs with odd size (1, 3, ..., 2*n*-1) are piled on the
    left pole from top to bottom in increasing order of size; all of the discs with
    even size (2, 4, ..., 2*n*) are piled on the right pole. Compose a program to
    provide instructions for moving the odd discs to the right pole and the even discs
    to the left pole, obeying the same rules as for Towers of Hanoi.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汉诺塔变种。** 考虑汉诺塔问题的以下变种。有 2*n* 个递增大小的圆盘存放在三根柱子上。最初，所有奇数大小的圆盘（1, 3, ..., 2*n*-1）按大小递增的顺序从顶部到底部堆叠在左柱上；所有偶数大小的圆盘（2,
    4, ..., 2*n*）堆叠在右柱上。编写一个程序，为将奇数圆盘移动到右柱和偶数圆盘移动到左柱提供指令，遵守与汉诺塔相同的规则。'
- en: '**Animated Towers of Hanoi.** Compose a program that uses `stddraw` to animate
    a solution to the Towers of Hanoi problem, moving the discs at a rate of approximately
    1 per second.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汉诺塔动画。** 编写一个使用 `stddraw` 的程序，以每秒大约移动一个盘子的速度动画显示解决汉诺塔问题的过程。'
- en: '*Solution*: See [animatedhanoi.py](animatedhanoi.py.html).'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 参见 [animatedhanoi.py](animatedhanoi.py.html)。'
- en: '**Sierpinski triangles.** Compose a recursive program to draw the *Sierpinski
    gasket*. As with `htree.py`, use a command-line argument to control the depth
    of recursion.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谢尔宾斯基三角形。** 编写一个递归程序来绘制 *谢尔宾斯基地毯*。与 `htree.py` 一样，使用一个命令行参数来控制递归的深度。'
- en: '| ![Sierpinski triangle](../Images/2065f570826dc0c2202b64d2bb777fe7.png) |
    ![Sierpinski triangle](../Images/dd0b7ae0b3555d26a04c6048ed104773.png) | ![Sierpinski
    triangle](../Images/fab7963c2bc03de38f58002c92e9c06b.png) | ![Sierpinski triangle](../Images/c4dc38fe3b42fbf14ccc7af8a8b9f59e.png)
    |'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![谢尔宾斯基三角形](../Images/2065f570826dc0c2202b64d2bb777fe7.png) | ![谢尔宾斯基三角形](../Images/dd0b7ae0b3555d26a04c6048ed104773.png)
    | ![谢尔宾斯基三角形](../Images/fab7963c2bc03de38f58002c92e9c06b.png) | ![谢尔宾斯基三角形](../Images/c4dc38fe3b42fbf14ccc7af8a8b9f59e.png)
    |'
- en: '| ![Sierpinski triangle](../Images/604e180b643069181ec0e309117846cf.png) |
    ![Sierpinski triangle](../Images/e730d56b1b86f07d1c26e73cb7e4ff19.png) | ![Sierpinski
    triangle](../Images/01168b3d68969b70be2be7ffca8a7fd2.png) | ![Sierpinski triangle](../Images/fff92ac380765c8e1f22fc1f3942fc31.png)
    |'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![谢尔宾斯基三角形](../Images/604e180b643069181ec0e309117846cf.png) | ![谢尔宾斯基三角形](../Images/e730d56b1b86f07d1c26e73cb7e4ff19.png)
    | ![谢尔宾斯基三角形](../Images/01168b3d68969b70be2be7ffca8a7fd2.png) | ![谢尔宾斯基三角形](../Images/fff92ac380765c8e1f22fc1f3942fc31.png)
    |'
- en: '**Binomial distribution.** Estimate the number of recursive calls that would
    be used by the code'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二项分布。**估计代码将使用的递归调用次数'
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'to compute `binomial(100, 50)`. Develop a better implementation that is based
    on memoization. *Hint*: see the *Binomial coefficients* exercise in Section 1.4.'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算 `binomial(100, 50)`。开发一个基于记忆化的更好的实现。*提示*：参见第 1.4 节中的 *二项式系数* 练习。
- en: '**A strange function.** Consider McCarthy''s 91 function:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个奇怪的函数。**考虑麦卡锡的 91 函数：'
- en: '[PRE19]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Determine the value of `mcCarthy(50)` without using a computer. Give the number
    of recursive calls used by `mcCarthy()` to compute this result. Either prove that
    the base case is reached for all positive integers *n* or give a value of *n*
    for which this function goes into an infinite recursive loop.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定在不使用计算机的情况下 `mcCarthy(50)` 的值。给出 `mcCarthy()` 用于计算此结果所使用的递归调用次数。证明对于所有正整数
    *n* 都会达到基本情况，或者给出一个使该函数进入无限递归循环的 *n* 值。
- en: '**Collatz function.** Consider the following recursive function in [collatz.py](collatz.py.html),
    which is related to a famous unsolved problem in number theory, known as the [Collatz
    problem](http://mathworld.wolfram.com/CollatzProblem.html) or the *3n + 1 problem*.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Collatz 函数。**考虑以下递归函数在 [collatz.py](collatz.py.html) 中，它与一个著名的未解决的数论问题有关，即
    [Collatz 问题](http://mathworld.wolfram.com/CollatzProblem.html) 或 *3n + 1 问题*。'
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For example, a call to `collatz(7)` writes the sequence of 17 integers
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，调用 `collatz(7)` 会写出 17 个整数的序列
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: after 17 function calls. Compose a program that takes a command-line argument
    *m* and returns the value of *n* < *m* for which the number of recursive calls
    for `collatz(n)` is maximized. The unsolved problem is that no one knows whether
    the function terminates for all positive values of *n* (mathematical induction
    is no help because one of the recursive calls is for a larger value of the argument).
    Develop a better implementation that is based on memoization.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 17 次函数调用之后。编写一个程序，接受一个命令行参数 *m*，并返回对于 `collatz(n)` 的递归调用次数最多的 *n* < *m* 的值。未解决的问题是没有人知道该函数是否对所有正值的
    *n* 终止（数学归纳法无助，因为其中一个递归调用是针对参数值更大的情况）。开发一个基于记忆化的更好的实现。
- en: '**Recursive tree.** Compose a program that takes a command-line argument *n*
    and produces tree-like recursive patterns like these for *n* equal to 1, 2, 3,
    4, and 8:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**递归树。**编写一个程序，接受一个命令行参数 *n*，并为 *n* 等于 1、2、3、4 和 8 时生成类似树状递归模式的程序：'
- en: '![Recursive trees](../Images/3a92c64d501fb8895038b1c7475b4541.png)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![递归树](../Images/3a92c64d501fb8895038b1c7475b4541.png)'
- en: '**Brownian island.** Benoit Mandelbrot asked the famous question *How long
    is the coast of Britain?* Modify `brownian.py` to compose a program that plots
    [Brownian islands](http://swiss.csail.mit.edu/~rauch/islands/), whose coastlines
    resemble that of Great Britain. The modifications are simple: first, change `curve()`
    to add a gaussian to the *x* coordinate as well as to the *y* coordinate; second,
    change `main()` to draw a curve from the point at the center of the canvas back
    to itself. Experiment with various values of the arguments to get your program
    to produce islands with a realistic look.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布朗尼亚岛。**Benoit Mandelbrot 提出了著名问题 *英国海岸有多长？* 修改 `brownian.py` 以编写一个绘制 [布朗尼亚岛](http://swiss.csail.mit.edu/~rauch/islands/)
    的程序，其海岸线类似于英国的海岸线。修改很简单：首先，将 `curve()` 更改为在 *x* 坐标和 *y* 坐标上添加高斯；其次，将 `main()`
    更改为从画布中心点绘制一条曲线回到自身。尝试使用各种参数值，使您的程序产生外观逼真的岛屿。'
- en: '![Brownian island](../Images/aff29185fc15188fd0ac852102138ffe.png)'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![布朗尼亚岛](../Images/aff29185fc15188fd0ac852102138ffe.png)'
- en: '*Solution*: See [brownianisland.py](brownianisland.py.html).'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见 [brownianisland.py](brownianisland.py.html)。'
