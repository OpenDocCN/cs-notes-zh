- en: 1.3 Conditionals and Loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 条件语句和循环
- en: 原文：[https://introcs.cs.princeton.edu/python/13flow](https://introcs.cs.princeton.edu/python/13flow)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/13flow](https://introcs.cs.princeton.edu/python/13flow)
- en: 'We use the term *flow of control* to refer to the sequence of statements that
    are executed in a program. All of the programs that we have examined to this point
    have a simple flow of control: the statements are executed one after the other
    in the order given. Most programs have a more complicated structure where statements
    may or may not be executed depending on certain conditions (conditionals), or
    where groups of statements are executed multiple times (loops).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语*控制流*来指代程序中执行的语句序列。到目前为止，我们检查过的所有程序都具有简单的控制流：语句按给定顺序依次执行。大多数程序具有更复杂的结构，其中语句可能会根据某些条件（条件语句）而执行或不执行，或者一组语句会多次执行（循环）。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '`if` Statements'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: Most computations require different actions for different inputs. Program [flip.py](flip.py.html)
    uses an `if-else` statement to write the results of a coin flip. The table below
    summarizes some typical situations where you might need to use an `if` or `if-else`
    statement.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算需要针对不同的输入采取不同的操作。程序[flip.py](flip.py.html)使用`if-else`语句来编写硬币翻转的结果。下表总结了一些典型情况，您可能需要使用`if`或`if-else`语句。
- en: '![](../Images/f51e4db5ceecc56fde8dcd25cf84c8b3.png)'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/f51e4db5ceecc56fde8dcd25cf84c8b3.png)'
- en: 'Note that in Python indentation is meaningful. For example, consider these
    two code fragments:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Python中缩进是有意义的。例如，考虑这两个代码片段：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If `x` is greater than or equal to 0, then both fragments write 'not negative'.
    If `x` is less than 0, then the code on the left writes 'negative' but the code
    on the right writes nothing at all.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`大于或等于0，则两个片段都写出'not negative'。如果`x`小于0，则左侧的代码写出'negative'，但右侧的代码根本不写出任何内容。
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '`while` Statements'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`语句'
- en: Many computations are inherently repetitive. The `while` statement enables us
    to perform a group of statements many times. This enables us to express lengthy
    computations without composing lots of code. The program [tenhellos.py](tenhellos.py.html)
    writes "Hello, World" ten times. The program [powersoftwo.py](powersoftwo.py.html)
    accepts a command-line argument `n` and writes all of the powers of 2 less than
    or equal to `n`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算本质上是重复的。`while`语句使我们能够多次执行一组语句。这使我们能够表达冗长的计算而不需要编写大量代码。程序[tenhellos.py](tenhellos.py.html)会写出"Hello,
    World"十次。程序[powersoftwo.py](powersoftwo.py.html)接受一个命令行参数`n`，并写出所有小于或等于`n`的2的幂。
- en: Incidentally, in Python we can abbreviate an assignment statement of the form
    `i = i + 1` with the shorthand notation `i += 1`. The same notation works for
    other binary operators, including `-`, `*`, and `/`. For example, most programmers
    would use `power *= 2` instead of `power = 2 * power` in [powersoftwo.py](powersoftwo.py.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在Python中，我们可以用简写符号`i += 1`来缩写形式为`i = i + 1`的赋值语句。相同的符号也适用于其他二元运算符，包括`-`、`*`和`/`。例如，大多数程序员会使用`power
    *= 2`而不是`power = 2 * power`在[powersoftwo.py](powersoftwo.py.html)中。
- en: '* * *'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '`for` Statements'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`语句'
- en: 'Many loops follow the same basic scheme: initialize an index variable to some
    value and then use a `while` loop to test an exit condition involving the index
    variable, using the last statement in the `while` loop to modify the index variable.
    Python''s `for` statement is a direct way to express such loops. For example,
    the following two lines of code are equivalent to the corresponding lines of code
    in [tenhellos.py](tenhellos.py.html):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多循环遵循相同的基本方案：将索引变量初始化为某个值，然后使用`while`循环测试涉及索引变量的退出条件，使用`while`循环中的最后一个语句修改索引变量。Python的`for`语句是表达这种循环的直接方式。例如，以下两行代码等同于[tenhellos.py](tenhellos.py.html)中相应的代码行：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If `range()` has only one argument, then the start value of the range value
    defaults to 0\. For example, the following `for` loop is an improvement over the
    `while` loop in [powersoftwo.py](powersoftwo.py.html):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`range()`只有一个参数，则范围值的起始值默认为0。例如，以下`for`循环比[powersoftwo.py](powersoftwo.py.html)中的`while`循环更好：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The table below summarizes some typical situations where you might need to use
    a `while` or `for` statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了一些典型情况，您可能需要使用`while`或`for`语句。
- en: '![](../Images/cd8b2b031c978e54be6cfc496356b506.png)'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/cd8b2b031c978e54be6cfc496356b506.png)'
- en: '* * *'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Nesting
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套
- en: We can nest `if`, `while`, or `for` statements within other `if`, `while`, or
    `for` statements. As an example, [divisorpattern.py](divisorpattern.py.html) has
    a `for` loop whose nested statements are a `for` loop (whose nested statement
    is an `if` statement) and a `stdio.writeln()` statement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在其他`if`、`while`或`for`语句中嵌套`if`、`while`或`for`语句。例如，[divisorpattern.py](divisorpattern.py.html)有一���`for`循环，其嵌套语句是一个`for`循环（其嵌套语句是一个`if`语句）和一个`stdio.writeln()`语句。
- en: 'As a second example of nesting, consider a tax preparation program that contains
    this code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为嵌套的第二个示例，考虑一个包含以下代码的税务准备程序：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Python allows an `if` statement to contain `elif` ("else if") clauses. Using
    `elif` clauses yields this more compact code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许`if`语句包含`elif`（"else if"）子句。使用`elif`子句会产生更紧凑的代码：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '* * *'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Applications
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用
- en: The ability to program with conditionals and loops immediately opens up the
    world of computation to us.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用条件语句和循环进行编程立即为我们打开了计算世界的大门。
- en: '![Harmonic](../Images/c329a5897240fe0865ffe53495e7a07d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![谐波](../Images/c329a5897240fe0865ffe53495e7a07d.png)'
- en: Finite sum.
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有限和。
- en: The computational paradigm used by [powersoftwo.py](powersoftwo.py.html) is
    one that you will use frequently. It uses two variables — one as an index that
    controls a loop and the other to accumulate a computational result. The program
    [harmonic.py](harmonic.py.html) uses the same paradigm to evaluate the finite
    sum *H[n]* = 1 + 1/2 + 1/3 + ... + 1/*n*. These numbers are known as the *harmonic
    numbers*. ![Newton](../Images/3bc40f709ee47cd5d1e1ff59c1cc8f97.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[powersoftwo.py](powersoftwo.py.html)使用的计算范式是您经常会使用的范式之一。它使用两个变量 — 一个作为控制循环的索引，另一个用于累积计算结果。程序[harmonic.py](harmonic.py.html)使用相同的范式来计算有限和*H[n]*
    = 1 + 1/2 + 1/3 + ... + 1/*n*。这些数字被称为*调和数*。![牛顿](../Images/3bc40f709ee47cd5d1e1ff59c1cc8f97.png)'
- en: Computing the square root.
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算平方根。
- en: How is the `math.sqrt()` function implemented? The program [sqrt.py](sqrt.py.html)
    illustrates one technique. It uses a special case of a general computational technique
    that was developed by Isaac Newton and Joseph Raphson and is widely known as *Newton's
    method*. To compute the square root of a positive number *t*, start with the estimate
    *t* = *c*. If *t* is equal to *c* / *t*, then *t* is equal to the square root
    of *c*, so the computation is complete. If not, refine the estimate by replacing
    *t* with the average of *t* and *c* / *t*. Each time we perform this update, we
    get closer to the desired answer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.sqrt()`函数是如何实现的？程序[sqrt.py](sqrt.py.html)演示了一种技术。它使用了艾萨克·牛顿和约瑟夫·拉夫逊开发的一般计算技术的一个特例，被广泛称为*牛顿法*。要计算正数*t*的平方根，从估计*t*
    = *c*开始。如果*t*等于*c* / *t*，那么*t*等于*c*的平方根，计算完成。如果不是，则通过用*t*和*c* / *t*的平均值替换*t*来改进估计。每次执行此更新时，我们都会更接近所需的答案。'
- en: Number conversion.
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字转换。
- en: The program [binary.py](binary.py.html) writes the binary (base 2) representation
    of the decimal number typed as the command line argument. It is based on decomposing
    the number into a sum of powers of two. For example, the binary representation
    of 106 is 1101010, which is the same as saying that 106 = 64 + 32 + 8 + 2, or
    in binary, 1101010 = 1000000 + 100000 + 1000 + 10\. To compute the binary representation
    of *n*, we consider the powers of 2 less than or equal to *n* in decreasing order
    to determine which belong in the binary decomposition (and therefore correspond
    to a 1 bit in the binary representation). ![Gambler](../Images/22f356a25c42e820e30695409eb60d0a.png)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[binary.py](binary.py.html)将作为命令行参数键入的十进制数的二进制（基数2）表示写入。它基于将数字分解为二的幂的和。例如，106的二进制表示是1101010，这意味着106
    = 64 + 32 + 8 + 2，或者用二进制表示，1101010 = 1000000 + 100000 + 1000 + 10。要计算*n*的二进制表示，我们按递减顺序考虑小于或等于*n*的2的幂，以确定哪些属于二进制分解（因此对应于二进制表示中的1位）。![赌徒](../Images/22f356a25c42e820e30695409eb60d0a.png)
- en: Monte Carlo simulation.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟。
- en: Our next example is representative of a widely used class of programs, where
    we use computers to simulate what might happen in the real world, so that we can
    make informed decisions in all kinds of complicated situations. Suppose a gambler
    makes a series of fair $1 bets, starting with $50, and continue to play until
    she either goes broke or has $250\. What are the chances that she will go home
    with $250, and how many bets might she expect to make before winning or losing?
    Program [gambler.py](gambler.py.html) is a simulation that can help answer these
    questions. It accepts three command-line arguments, the initial stake ($50), the
    goal amount ($250), and the number of times we want to simulate the game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个示例代表了一类广泛使用的程序，我们在其中使用计算机模拟真实世界可能发生的情况，以便在各种复杂情况下做出明智的决策。假设一个赌徒进行一系列公平的$1赌注，从$50开始，并继续玩直到她破产或拥有$250。她带着$250回家的机会有多大，以及在赢或输之前她可能会做多少赌注？程序[gambler.py](gambler.py.html)是一个可以帮助回答这些问题的模拟。它接受三个命令行参数，初始赌注($50)，目标金额($250)，以及我们想要模拟游戏的次数。
- en: Factoring.
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 因式分解。
- en: A *prime* is an integer greater than 1 whose only positive divisors are 1 and
    itself. The prime factorization of an integer is the multiset of primes whose
    product is the integer. For example, 3757208 = 2*2*2*7*13*13*397\. The [factors.py](factors.py.html)
    program computes the prime factorization of any given positive integer. We can
    stop looking for factors when `factor`*`factor` is greater than `n` because if
    an integer `n` has a factor, it has one less than or equal to the square root
    of `n`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*素数*是大于1的整数，其唯一的正因子是1和它本身。一个整数的素数分解是其乘积为该整数的素数的多重集。例如，3757208 = 2*2*2*7*13*13*397。[factors.py](factors.py.html)程序计算任何给定正整数的素数分解。当`factor`*`factor`大于`n`时，我们可以停止寻找因子，因为如果整数`n`有一个因子，那么它小于或等于`n`的平方根。'
- en: '* * *'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Loop and a Half
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 半循环
- en: 'Suppose we want a loop that repeatedly does the following: execute some sequence
    of statements, exit the loop if some loop-termination condition is satisfied,
    and execute some other sequence of statements. That is, we want to position the
    loop-control condition in the middle of the loop, not at the beginning. This is
    known as a *loop and a half* because you must go partway through the loop before
    reaching the loop-termination test. Python provides the `break` statement for
    this purpose. When Python executes a `break` statement, it immediately exits the
    (innermost) loop.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个循环，重复执行以下操作：执行一些语句序列，如果满足某个循环终止条件，则退出循环，并执行一些其他语句序列。也就是说，我们希望将循环控制条件放在循环中间，而不是在开头。这被称为*半循环*，因为你必须在达到循环终止测试之前走过循环的一部分。Python提供`break`语句来实现这一目的。当Python执行`break`语句时，它立即退出（最内层）循环。
- en: '![Break](../Images/0834bd43d8f17c079a099c8dba4b6172.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![中断](../Images/0834bd43d8f17c079a099c8dba4b6172.png)'
- en: For example, consider the problem of generating a point that is randomly distributed
    in the unit disk. Since we always want to generate at least one point, we compose
    a `while` loop whose loop-continuation condition is always satisfied, generate
    the random point (*x*, *y*) in the 2-by-2 square, and use a `break` statement
    to terminate the loop if (*x*, *y*) is in the unit disk.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑生成一个在单位圆盘中随机分布的点的问题。由于我们总是希望生成至少一个点，我们构建一个`while`循环，其循环继续条件总是满足，生成2x2方形中的随机点(*x*,
    *y*)，并使用`break`语句来终止循环，如果(*x*, *y*)在单位圆盘中。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** What is the difference between `=` and `==`?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `=`和`==`之间有什么区别？'
- en: '**A.** We repeat this question here to remind you that you should not use `=`
    when you really mean `==` in a conditional expression. The statement `x = y` assigns
    `y` to `x`, whereas the expression `x == y` tests whether the two variables currently
    are equal. In some programming languages, this difference can wreak havoc in a
    program and be difficult to detect. In Python, assignment statements are not expressions.
    For example, if we were to make the mistake of typing `cash = goal` instead of
    `cash == goal` in [gambler.py](gambler.py.html), the compiler would find the bug
    for us:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 我们在这里重复这个问题，提醒您在条件表达式中不要使用`=`而应该使用`==`。语句`x = y`将`y`赋给`x`，而表达式`x ==
    y`测试当前两个变量是否相等。在某些编程语言中，这种差异可能会在程序中造成混乱并难以检测。在Python中，赋值语句不是表达式。例如，如果我们在[gambler.py](gambler.py.html)中犯了错误，将`cash
    = goal`而不是`cash == goal`，编译器会为我们找到错误：'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Q.** What happens if I leave out the colon in an `if`, `while`, or `for`
    statement?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我在`if`、`while`或`for`语句中省略冒号会发生什么？'
- en: '**A.** Python raises a `SyntaxError` at compile time.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python在编译时会引发`SyntaxError`。'
- en: '**Q.** What are the rules for indenting statement blocks?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 缩进语句块的规则是什么？'
- en: '**A.** Each statement in a block must have the same indentation; if it does
    not, Python will raise an `IndentationError` at compile time. Python programmers
    commonly use a four-space indentation scheme, which we follow throughout this
    book.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 块中的每个语句必须具有相同的缩进；如果没有，Python会在编译时引发`IndentationError`。Python程序员通常使用四个空格的缩进方案，我们在本书中遵循这种方式。'
- en: '**Q.** Should I use tab characters to indent my code?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我应该使用制表符来缩进我的代码吗？'
- en: '**A.** No, you should avoid placing tab characters in your `.py` files. Many
    editors, however, offer the option of automatically placing a sequence of spaces
    into your program when you type the <Tab> key; it''s appropriate to use that option
    when composing Python programs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不可以，在`.py`文件中避免使用制表符。然而，许多编辑器在您按下<Tab>键时提供自动将一系列空格放入程序中的选项；在编写Python程序时使用该选项是合适的。'
- en: '**Q.** Can I spread a long statement over multiple lines?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以将一条长语句分布在多行吗？'
- en: '**A.** Yes, but some care is needed because of the way Python treats indentation.
    If the expression that spans multiple lines is enclosed inside parentheses (or
    square brackets or curly braces), then there is no need to do anything special.
    For example, this is a single statement that is spread over three lines:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但是由于Python处理缩进的方式，需要一些小心。如果跨越多行的表达式被括在括号（或方括号或大括号）中，则不需要做任何特殊处理。例如，这是一条跨越三行的单个语句：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, if there is no implied line continuation, you must use the backslash
    character at the end of each line to be continued.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有暗示的行继续，你必须在每行末尾使用反斜杠字符以继续。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Q.** Suppose I want to skip over some of code in a loop in some cases, or
    suppose that I want the body of a conditional statement to be empty, so that no
    statement is executed. Does Python have language support for such things?'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设我想在某些情况下跳过循环中的一些代码，或者假设我希望条件语句的主体为空，以便不执行任何语句。Python 是否支持这样的语言特性？'
- en: '**A.** Yes, Python provides the `continue` and `pass` statements, respectively,
    for these conditions. However, situations in which they are really necessary are
    rare, and we do not use them in this booksite. Also, there is no `switch` statement
    in Python (for mutually exclusive alternatives), though one is commonly found
    in other languages, and no `goto` statement (for unstructured control flow).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，Python分别为这些情况提供了`continue`和`pass`语句。然而，真正需要它们的情况很少，我们在本书中不使用它们。此外，Python中没有`switch`语句（用于互斥的替代方案），尽管在其他语言中通常可以找到一个，也没有`goto`语句（用于非结构化控制流）。'
- en: '**Q.** Can I use a non-boolean expression in an `if` or `while` statement?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以在`if`或`while`语句中使用非布尔表达式吗？'
- en: '**A.** Yes, but this is probably not a good idea. Expressions that evaluate
    to zero or the empty string are considered `False`; all other numeric and string
    expressions are considered `True`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 可以，但这可能不是一个好主意。评估为零或空字符串的表达式被视为`False`；所有其他数字和字符串表达式被视为`True`。'
- en: '**Q.** Are there cases where I must use a `for` statement but not a `while`
    statement, or vice versa?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 是否有必须使用`for`语句而不使用`while`语句的情况，反之亦然？'
- en: '**A.** You can use a `while` statement to implement any kind of loop, but,
    as defined here, you can use a `for` statement only for the kind of loop that
    iterates over a finite sequence of integers. Later (Sections 1.4, 3.3, and 4.4),
    we will consider other ways to use the `for` statement.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 您可以使用`while`语句来实现任何类型的循环，但是，如此定义，您只能使用`for`语句来迭代有限整数序列的循环。稍后（第1.4、3.3和4.4节），我们将考虑使用`for`语句的其他方法。'
- en: '**Q.** Can I use the built-in `range()` function to create a sequence of integers
    with a step size of some value other than 1?'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以使用内置的`range()`函数来创建步长不为1的整数序列吗？'
- en: '**A.** Yes, `range()` supports an optional third argument step, which defaults
    to 1\. That is, `range(start, stop, step)` produces the sequence of integers `start`,
    `start` + `step`, `start` + 2 * `step`, and so forth. If `step` is a positive
    integer, the sequence continues as long as `start` + i * `step` is less than `stop`;
    if `step` is a negative integer, the sequence continues as long as `start` + i
    * step is greater than `stop`. For example, `range(0, -100, -1)` returns the integer
    sequence 0, -1, -2, ..., -99.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，`range()`支持一个可选的第三个参数步长，默认为1。也就是说，`range(start, stop, step)`生成整数序列`start`、`start`
    + `step`、`start` + 2 * `step`等。如果`step`是正整数，则序列会继续，直到`start` + i * `step`小于`stop`；如果`step`是负整数，则序列会继续，直到`start`
    + i * `step`大于`stop`。例如，`range(0, -100, -1)`返回整数序列0, -1, -2, ..., -99。'
- en: '**Q.** Can I use floats as arguments to `range()`?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以将浮点数用作`range()`的参数吗？'
- en: '**A.** No, all arguments must be integers.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不行，所有参数必须是整数。'
- en: '**Q.** Can I change the loop-index variable within a `for` loop?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以在`for`循环中更改循环索引变量吗？'
- en: '**A.** Yes, but it will not affect the sequence of integers produced by `range()`.
    For example, the following loop writes the 100 integers from 0 to 99:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但它不会影响`range()`生成的整数序列。例如，以下循环写入从0到99的100个整数：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Q.** In a `for` loop, what is the value of the loop-control variable after
    the loop terminates?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 在`for`循环中，循环控制变量在循环终止后的值是多少？'
- en: '**A.** It is the last value of the loop-control variable during the loop. Upon
    termination of the for loop above, `i` refers to the integer 109\. Using the loop-control
    variable after the termination of a for loop is generally considered poor style,
    so we do not do so in any of our programs.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 它是循环结束时的循环控制变量的最后一个值。在上面的for循环终止后，`i`指的是整数109。在for循环终止后使用循环控制变量通常被认为是不良风格，因此我们在任何程序中都不这样做。'
- en: '**Q.** My program is stuck in an infinite loop. How do I stop it?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我的程序陷入了无限循环。我该如何停止它？'
- en: '**A.** Type `Ctrl-c`. That is, hold down the key labeled `Ctrl` or `control`
    and press the `c` key. For Windows Command Prompt type `Ctrl-z`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 输入`Ctrl-c`。也就是，按住标有`Ctrl`或`control`的键，然后按`c`键。对于Windows命令提示符，请输入`Ctrl-z`。'
- en: '**Q.** Is there an example for when the following `for` and `while` loops are
    not equivalent?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 是否有一个示例表明以下`for`和`while`循环不等价？'
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**A.** Yes. Hint: Use a `continue` statement.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。提示：使用`continue`语句。'
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Compose a program that takes three integer command-line arguments and writes
    `'equal'` if all three are equal, and `'not equal'` otherwise.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受三个整数命令行参数，如果三个数都相等则写入`'equal'`，否则写入`'not equal'`。
- en: Compose a more general and robust version of [quadratic.py](../12types/quadratic.py.html)
    (from Section 1.2) that writes the roots of the polynomial *ax²*bx + *c*, writes
    an appropriate error message if the discriminant is negative, and behaves appropriately
    (avoiding division by zero) if *a* is zero.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个更通用和健壮的版本的[quadratic.py](../12types/quadratic.py.html)（来自第1.2节），该程序写入多项式*ax²*bx
    + *c*的根，如果判别式为负则写入适当的错误消息，并且如果*a*为零则适当地行为（避免除以零）。
- en: Write a code fragment that takes two float command-line arguments, and writes
    `True` if both are strictly between 0 and 1 and `False` otherwise.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，接受两个浮点数命令行参数，如果两者都严格介于0和1之间则写入`True`，否则写入`False`。
- en: Improve your solution to the "wind chill" exercise from Section 1.2 by adding
    code to check that the values of the command-line arguments fall within the ranges
    of validity of the formula, and also adding code to write an error message if
    that is not the case.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加代码来检查命令行参数的值是否在公式有效范围内，并添加代码来写入错误消息（如果不在范围内），改进第1.2节中“风寒”练习的解决方案。
- en: What is the value of `j` after each of the following code fragments is executed?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行以下代码片段后，`j`的值是多少？
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Redesign [tenhellos.py](tenhellos.py.html) to compose a program that accepts
    the number of lines to write as a command-line argument. You may assume that the
    argument is less than 1000\. *Hint*: consider using `i % 10` and `i % 100` to
    determine whether to use `st`, `nd`, `rd`, or `th` for writing the `i`th Hello.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新设计[tenhellos.py](tenhellos.py.html)以编写一个接受要写入的行数作为命令行参数的程序。您可以假设参数小于1000。*提示*：考虑使用`i
    % 10`和`i % 100`来确定写入第`i`个Hello时是否使用`st`、`nd`、`rd`或`th`。
- en: 'Compose a program that, using one `for` loop and one `if` statement, writes
    the integers from 1000 (inclusive) to 2000 (exclusive) with five integers per
    line. *Hint*: use the `%` operator.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用一个`for`循环和一个`if`语句，每行写入从1000（包括）到2000（不包括）的整数，每行写入五个整数。*提示*：使用`%`运算符。
- en: '*Solution*: See [fiveperline.py](fiveperline.py.html).'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[fiveperline.py](fiveperline.py.html)。'
- en: Generalizing the "uniform random numbers" exercise from Section 1.2, compose
    a program that accepts an integer `n` as a command-line argument, uses `random.random()`
    to write `n` uniform random numbers between 0 and 1, and then writes their average
    value, their minimum value, and their maximum value.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第1.2节中的“均匀随机数”练习进行泛化，编写一个程序，接受一个整数`n`作为命令行参数，使用`random.random()`写入`n`个介于0和1之间的均匀随机数，然后写入它们的平均值、最小值和最大值。
- en: Describe what happens when you invoke [rulern.py](rulern.py.html) with an argument
    that is too large. For example, try executing the command `python rulern 100`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述当使用一个太大的参数调用[rulern.py](rulern.py.html)时会发生什么。例如，尝试执行命令`python rulern 100`。
- en: Compose a program that writes a table of the values of log *n*, *n*, *n* log
    *n*, *n*², and *n*³ for *n* = 2, 4, 8, 16, 32, 64, 128\. Use tabs (`'\t'` characters)
    to line up columns.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，为*n* = 2, 4, 8, 16, 32, 64, 128时，写入*log n*, *n*, *n* log *n*, *n*²和*n*³的值表。使用制表符（`'\t'`字符）对齐列。
- en: '*Solution*: See [functiongrowth.py](functiongrowth.py.html).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[functiongrowth.py](functiongrowth.py.html)。'
- en: What are `m` and `n` after the following code is executed?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行以下代码后，`m`和`n`是什么？
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Solution*: Run the program [digitreverser.py](digitreverser.py.html).'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：运行程序[digitreverser.py](digitreverser.py.html)。'
- en: What does this code write?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码会写入什么？
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Solution*: Run the program [fibonacci.py](fibonacci.py.html).'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：运行程序[fibonacci.py](fibonacci.py.html)。'
- en: Compose a program that takes a command-line argument `n` and writes all the
    positive powers of 2 less than or equal to `n`. Make sure that your program works
    properly for all values of `n`. (Your program should write nothing if `n` is negative
    or zero.)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个命令行参数`n`，并写出小于或等于`n`的所有正数的2的幂。确保您的程序对所有`n`的值都能正常工作。（如果`n`为负数或零，则您的程序不应写出任何内容。）
- en: Expand your solution to the "Continuously compounded interest" exercise from
    Secction 1.2 to write a table giving the total amount paid and the remaining principal
    after each monthly payment.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展您对第1.2节中“连续复利”练习的解决方案，编写一个表格，列出每次月付款后支付的总金额和剩余本金。
- en: Compose a version of divisorpattern.py that uses `while` loops instead of `for`
    loops.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个使用`while`循环而不是`for`循环的divisorpattern.py版本。
- en: Unlike the harmonic numbers, the sum 1/1² + 1/2² + ... + 1/*n*² does converge
    to a constant as *n* grows to infinity. (Indeed, the constant is π²/6, so this
    formula can be used to estimate the value of π.) Which of the following `for`
    loops computes this sum? Assume that `n` is the integer 1000000 and `total` is
    a float initialized to 0.0.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与调和数不同，和1/1² + 1/2² + ... + 1/*n*²随着*n*增长到无穷大时会收敛到一个常数。 （实际上，该常数是π²/6，因此可以使用此公式来估计π的值。）以下哪个`for`循环计算这个和？假设`n`是整数1000000，`total`是初始化为0.0的浮点数。
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Show that [sqrt.py](sqrt.py.html) implements Newton''s method for finding the
    square root of *c*. *Hint*: Use the fact that the slope of the tangent to a (differentiable)
    function *f*(*x*) at *x* = *t* is *f*''(*t*) to find the equation of the tangent
    line and then use that equation to find the point where the tangent line intersects
    the *x*-axis to show that you can use Newton''s method to find a root of any function
    as follows: at each iteration, replace the estimate *t* by *t* - *f*(*t*) / *f''*(*t*).'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明[sqrt.py](sqrt.py.html)实现了用于找到*c*的平方根的牛顿法。*提示*：使用切线的斜率等于函数*f*(*x*)在*x* = *t*处的导数*f*'(*t*)来找到切线方程，然后使用该方程找到切线与*x*轴相交的点，以显示您可以使用牛顿法来找到任何函数的根，方法如下：在每次迭代时，将估计值*t*替换为*t*
    - *f*(*t*) / *f*'(*t*)。
- en: 'Using Newton''s method, develop a program that takes integers n and k as command-line
    arguments and writes the kth root of n (*Hint*: See the previous exercise.)'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用牛顿法，开发一个程序，该程序将整数n和k作为命令行参数，并写出n的第k个根（*提示*：参考前一个练习）。
- en: Modify [binary.py](binary.py.html) to create a program that takes `i` and `k`
    as command-line arguments and converts `i` to base `k`. Assume that `k` is an
    integer between 2 and 16\. For bases greater than 10, use the letters `A` through
    `F` to represent the 11th through 16th digits, respectively.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[binary.py](binary.py.html)以创建一个程序，该程序将`i`和`k`作为命令行参数，并将`i`转换为基数`k`。假设`k`是介于2和16之间的整数。对于大于10的基数，使用字母`A`到`F`分别表示第11到第16位数字。
- en: Compose a program named that accepts a positive integer command-line argument
    `n`, places the binary representation of `n` into a string, and then writes the
    string.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为的程序，接受一个正整数命令行参数`n`，将`n`的二进制表示放入一个字符串中，然后写出该字符串。
- en: '*Solution*: See [binary2.py](binary2.py.html).'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[binary2.py](binary2.py.html)。'
- en: Compose a version of [gambler.py](gambler.py.html) that uses two nested `while`
    loops or two nested `for` loops instead of a `while` loop inside a `for` loop.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个版本的[gambler.py](gambler.py.html)，该版本使用两个嵌套的`while`循环或两个嵌套的`for`循环，而不是在`for`循环内部使用`while`循环。
- en: Write a program that traces a gambler's ruin simulation by writing a line after
    each bet that has one asterisk corresponding to each dollar held by the gambler.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，通过在每次下注后写一行来跟踪赌徒破产模拟，每个星号对应赌徒所持有的每一美元。
- en: Modify [gambler.py](gambler.py.html) to take an extra command-line argument
    that specifies the (fixed) probability that the gambler wins each bet. Use your
    program to try to learn how this probability affects the chance of winning and
    the expected number of bets. Try a value of *p* close to 0.5 (say, 0.48).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[gambler.py](gambler.py.html)以接受额外的命令行参数，指定赌徒每次下注赢得的（固定）概率。使用您的程序尝试了解这个概率如何影响获胜的机会和预期下注次数。尝试一个接近0.5的*p*值（例如，0.48）。
- en: 'Modify [gambler.py](gambler.py.html) to take an extra command-line argument
    that specifies the number of bets the gambler is willing to make, so that there
    are three possible ways for the game to end: the gambler wins, loses, or runs
    out of time. Add to the output to give the expected amount of money the gambler
    will have when the game ends. *Extra credit*: Use your program to plan your next
    trip to Monte Carlo.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[gambler.py](gambler.py.html)以接受额外的命令行参数，指定赌徒愿意进行的下注次数，以便游戏以三种可能的方式结束：赌徒赢了、输了或时间用尽。添加输出以给出赌徒在游戏结束时预期拥有的金额。*额外奖励*：使用您的程序计划下次前往蒙特卡洛的旅行。
- en: Modify [factors.py](factors.py.html) to write just one copy of each of the prime
    divisors.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[factors.py](factors.py.html)以仅写出每个质因数的一个副本。
- en: Run quick experiments to determine the impact of using the termination condition
    `factor <= n` instead of `factor*factor <= n` in [factors.py](factors.py.html).
    For each method, find the largest *n* such that when you type in an *n* digit
    number, the program is sure to finish within 10 seconds.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行快速实验，以确定在[factors.py](factors.py.html)中使用终止条件`factor <= n`而不是`factor*factor
    <= n`的影响。对于每种方法，找到最大的*n*，以便当您输入一个*n*位数时，程序肯定会在10秒内完成。
- en: Compose a program that takes one integer command-line argument `n` and writes
    a two dimensional `n`-by-`n` checker board pattern with alternating spaces and
    asterisks, like the following 4-by-4 pattern.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个整数命令行参数`n`，并写出一个二维`n`×`n`的棋盘图案，交替使用空格和星号，就像以下4×4的图案一样。
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compose a program that accepts two integers `x` and `y` from the command-line,
    and finds and writes the greatest common divisor (gcd) of `x` and `y` using *Euclid''s
    algorithm*, which is an iterative computation based on the following observation:
    if `x > y`, then if `y` divides `x`, the gcd of `x` and `y` is `y`; otherwise
    the gcd of `x` and `y` is the same as the gcd of `x % y` and `y`.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行接受两个整数`x`和`y`，并使用*欧几里德算法*找到并写出`x`和`y`的最大公约数(gcd)，这是一种基于以下观察的迭代计算：如果`x
    > y`，那么如果`y`整除`x`，则`x`和`y`的最大公约数是`y`；否则`x`和`y`的最大公约数与`x % y`和`y`的最大公约数相同。
- en: Compose a program that takes one command-line argument `n` and writes an `n`-by-`n`
    table such that there is an `*` in row `i` and column `j` if the gcd of `i` and
    `j` is 1 (`i` and `j` are relatively prime), and a space in that position otherwise.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个命令行参数`n`，并写出一个`n`×`n`表格，如果`i`和`j`的最大公约数是1（`i`和`j`是互质的），则在第`i`行和第`j`列中有一个`*`，否则在该位置有一个空格。
- en: Compose a program that generates a point that is randomly distributed in the
    unit disk, but without using a `break` statement. Compare your solution to the
    one given at the end of this section.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，生成一个在单位圆盘中随机分布的点，但不使用`break`语句。将你的解决方案与本节末尾给出的解决方案进行比较。
- en: 'Compose a program that writes the coordinates of a random point (*a*, *b*,
    *c*) on the surface of a unit sphere. To generate such a point, use *Marsaglia''s
    method*: Start by picking a random point (*x*, *y*) in the unit disk using the
    method described at the end of this section. Then, set *a* to 2 x sqrt(1 - *x*²
    - *y*²), *b* to 2 y sqrt(1 - *x*² - *y*²), and *c* to 1 - 2 (*x*² + *y*²).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，写出单位球面上一个随机点(*a*, *b*, *c*)的坐标。要生成这样一个点，使用*Marsaglia方法*：首先，在单位圆盘中选择一个随机点(*x*,
    *y*)，方法如本节末尾所述。然后，将*a*设置为2 x sqrt(1 - *x*² - *y*²)，将*b*设置为2 y sqrt(1 - *x*² -
    *y*²)，将*c*设置为1 - 2 (*x*² + *y*²)。
- en: '* * *'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Ramanujan''s taxi.** S. Ramanujan was an Indian mathematician who became
    famous for his intuition for numbers. When the English mathematician G. H. Hardy
    came to visit him in the hospital one day, Hardy remarked that the number of his
    taxi was 1729, a rather dull number. To which Ramanujan replied, "No, Hardy! No,
    Hardy! It is a very interesting number. It is the smallest number expressible
    as the sum of two cubes in two different ways." Verify this claim by composing
    a program that takes a command line argument `n` and writes all integers less
    than or equal to `n` that can be expressed as the sum of two cubes in two different
    ways. In other words, find distinct positive integers *a*, *b*, *c*, and *d* such
    that *a*³ + *b*³ = *c*³ + *d*³. Use four nested `for` loops.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拉马努金的出租车。** S.拉马努金是一位印度数学家，以他对数字的直觉而闻名。有一天，英国数学家G.H.哈代来医院看望他时，哈代说他的出租车号码是1729，一个相当乏味的数字。拉马努金回答说：“不，哈代！不，哈代！这是一个非常有趣的数字。它是可以用两种不同方式的两个立方数之和来表示的最小数字。”通过编写一个程序验证这一说法，该程序接受一个命令行参数`n`，并写出所有小于或等于`n`的整数，这些整数可以用两种不同方式的两个立方数之和来表示。换句话说，找到不同的正整数*a*,
    *b*, *c*和*d*，使得*a*³ + *b*³ = *c*³ + *d*³。使用四个嵌套的`for`循环。'
- en: '*Solution*: See [ramanujanwhile.py](ramanujanwhile.py.html) and [ramanujanfor.py](ramanujanfor.py.html).'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请参见[ramanujanwhile.py](ramanujanwhile.py.html)和[ramanujanfor.py](ramanujanfor.py.html)。'
- en: Now, the license plate 87539319 seems like a rather dull number. Determine why
    it's not.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，车牌号87539319似乎是一个相当乏味的数字。确定它为什么不是。
- en: '**Checksums.** The International Standard Book Number ([ISBN](http://mathworld.wolfram.com/ISBN.html))
    is a 10 digit code that uniquely specifies a book. The rightmost digit is a *checksum*
    digit which can be uniquely determined from the other 9 digits from the condition
    that 10*d*[10] + 9*d*[9] + ... + 2*d*[2] + *d*[1] must be a multiple of 11 (here
    *d[i]* denotes the *i*th digit from the right). The checksum digit *d*[1] can
    be any value from 0 to 10: the ISBN convention is to use the value ''X'' to denote
    10\. *Example*: the checksum digit corresponding to 020131452 is 5 since is the
    only value of *d*[1] between 0 and and 10 for which 10*0 + 9*2 + 8*0 + 7*1 + 6*3
    + 5*1 + 4*4 + 3*5 + 2*2 + *d*[1] is a multiple of 11\. Compose a program that
    takes a 9-digit integer as a command-line argument, computes the checksum, and
    writes the 10-digit ISBN number. It''s OK if the program doesn''t write any leading
    0''s.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**校验和。** 国际标准书号([ISBN](http://mathworld.wolfram.com/ISBN.html))是一个10位代码，可以唯一指定一本书。最右边的数字是一个*校验和*数字，可以根据其他9位数字唯一确定，条件是10*d*[10]
    + 9*d*[9] + ... + 2*d*[2] + *d*[1]必须是11的倍数（这里*d[i]*表示从右边数第*i*位数字）。校验和数字*d*[1]可以是0到10之间的任何值：ISBN约定使用值''X''表示10。*示例*:
    对应于020131452的校验和数字是5，因为它是0到10之间的唯一值，使得10*0 + 9*2 + 8*0 + 7*1 + 6*3 + 5*1 + 4*4
    + 3*5 + 2*2 + *d*[1]是11的倍数。编写一个程序，接受一个9位整数作为命令行参数，计算校验和，并写出10位ISBN号码。如果程序不写任何前导0，那也没关系。'
- en: '*Solution*: See [isbn.py](isbn.py.html).'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请参见[isbn.py](isbn.py.html)。'
- en: '**Counting primes.** Compose a program that takes a command-line argument `n`
    and writes the number of primes less than `n`. Use it to write the number of primes
    less than 10 million. *Note:* if you are not careful to make your program efficient,
    it may not finish in a reasonable amount of time. Later in Section 1.4, you will
    learn about a more efficient way to perform this computation called the *Sieve
    of Eratosthenes*.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算素数。** 编写一个程序，接受一个命令行参数`n`，并写出小于`n`的素数数量。使用它来计算小于1000万的素数数量。*注意:* 如果你不小心让你的程序变得高效，它可能无法在合理的时间内完成。在第1.4节中，你将学习一种更有效的计算方法，称为*埃拉托斯特尼筛法*。'
- en: '**2D random walk.** A two dimensional [random walk](http://en.wikipedia.org/wiki/Random_walk)
    simulates the behavior of a particle moving in a grid of points. At each step,
    the random walker moves north, south, east, or west with probability 1/4, independently
    of previous moves. Compose a program that takes a command-line argument `n` and
    estimates how long it will take a random walker to hit the boundary of a 2`n`+1-by-2`n`+1
    square centered at the starting point.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二维随机漫步。** 二维[随机漫步](http://en.wikipedia.org/wiki/Random_walk)模拟了一个粒子在点阵中移动的行为。在每一步中，随机漫步者以
    1/4 的概率向北、南、东或西移动，与之前的移动无关。编写一个程序，接受一个命令行参数 `n`，并估计一个随机漫步者击中以起始点为中心的一个 2`n`+1×2`n`+1
    正方形边界需要多长时间。'
- en: '**Median-of-5.** Compose a program that takes five distinct integers from the
    command line and writes the median value (the value such that two of the other
    integers are smaller and two are larger). *Extra credit*: Solve the problem with
    a program that compares values fewer than seven times for any given input.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**五数中位数。** 编写一个程序，从命令行获取五个不同的整数，并写出中位数（即其他两个整数较小，另外两个整数较大的值）。*额外加分*：使用比给定输入少于七次比较值的程序解决该问题。'
- en: '**Exponential function.** Assume that `x` is a float. Compose a code fragment
    that uses the Taylor series expansion to assign *e*^x = 1 + *x* + *x*²/2! + *x*³/3!
    + ... to `total`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指数函数。** 假设 `x` 是一个浮点数。编写一个代码片段，使用泰勒级数展开将 *e*^x = 1 + *x* + *x*²/2! + *x*³/3!
    + ... 赋值给 `total`。'
- en: '*Solution*: The purpose of this exercise is to get you to think about how a
    library function like `math.exp()` might be implemented in terms of elementary
    operators. Try solving it, then compare your solution with the one developed here.
    We start by considering the problem of computing one term. Suppose that `x` is
    a float and `n` is an integer. The following code assigns *x*^(*n*) / *n*! to
    `term` using the direct method of having one loop for the numerator and another
    loop for the denominator, then dividing the results:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：这个练习的目的是让你思考一个类似 `math.exp()` 这样的库函数如何通过基本运算符实现。尝试解决它，然后将你的解决方案与这里开发的解决方案进行比较。我们首先考虑计算一个项的问题。假设
    `x` 是一个浮点数，`n` 是一个整数。以下代码使用直接方法为 `term` 赋值 *x*^(*n*) / *n*!，其中分子和分母分别有一个循环，然后将结果相除：'
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A better approach is to use just a single for loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是只使用一个 for 循环：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Besides being more compact and elegant, the latter solution is preferable because
    it avoids inaccuracies caused by computing with huge numbers. For example, the
    two-loop approach breaks down for values like *x* = 10 and *n* = 100 because 100!
    is too large to represent accurately as a float.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更紧凑和优雅外，后一种解决方案更可取，因为它避免了由于使用巨大数字进行计算而引起的不准确性。例如，对于像 *x* = 10 和 *n* = 100
    这样的值，两个循环的方法会出现问题，因为 100! 太大，无法准确表示为浮点数。
- en: 'To compute *e^x*, we nest this `for` loop within a `while` loop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 *e^x*，我们将这个 `for` 循环嵌套在一个 `while` 循环中：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`while`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`total`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`total`'
- en: '`(term > 0)`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`(term > 0)`'
- en: '`for`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`while`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`while`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`'
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Experimental analysis.** Run experiments to determine the relative costs
    of `Math.exp()` and the following three methods from Exercise 2.3.36 for the problem
    of computing *e^x*: the direct method with nested loops, the improved method with
    a single loop, and the latter with the loop continuation condition `(term > 0)`.
    For each method, use trial-and-error with a command line argument to determine
    how many times your computer can perform the computation in 10 seconds.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实验分析。** 运行实验以确定计算 *e^x* 问题时 `Math.exp()` 和来自练习 2.3.36 的以下三种方法的相对成本：具有嵌套循环的直接方法，具有单个循环的改进方法，以及具有循环继续条件
    `(term > 0)` 的后者。对于每种方法，使用命令行参数进行试错，以确定您的计算机在 10 秒内可以执行多少次计算。'
- en: '**Trigometric functions.** Compose programs that compute sin *x* and cos *x*
    using the Taylor series expansions:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三角函数。** 编写程序，使用泰勒级数展开计算 sin *x* 和 cos *x*：'
- en: sin *x* = *x* - *x*³/3! + *x*⁵/5! - *x*⁷/7! + ...
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sin *x* = *x* - *x*³/3! + *x*⁵/5! - *x*⁷/7! + ...
- en: cos *x* = 1 - *x*²/2! + *x*⁴/4! - *x*⁶/6! + ...
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cos *x* = 1 - *x*²/2! + *x*⁴/4! - *x*⁶/6! + ...
- en: '*Partial solution*: See [sine.py](sine.py.html).'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案*：参见 [sine.py](sine.py.html)。'
- en: '**Pepys''s problem.** In 1693 Samuel Pepys asked Isaac Newton which is more
    likely: getting 1 at least once when rolling a fair die six times or getting 1
    at least twice when rolling it 12 times. Compose a program that could have provided
    Newton with a quick answer.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**皮皮斯问题。** 在 1693 年，塞缪尔·皮皮斯问艾萨克·牛顿，掷一个公平骰子六次至少得到一个 1 的概率和掷它十二次至少得到两个 1 的概率哪个更大。编写一个程序，可以为牛顿提供一个快速答案。'
- en: '**Game simulation.** In the 1970s game show *Let''s Make a Deal*, a contestant
    is presented with three doors. Behind one of them is a valuable prize. After the
    contestant chooses a door, the host opens one of the other two doors (never revealing
    the prize, of course). The contestant is then given the opportunity to switch
    to the other unopened door. Should the contestant do so? Intuitively, it might
    seem that the contestant''s initial choice door and the other unopened door are
    equally likely to contain the prize, so there would be no incentive to switch.
    Compose a program to test this intuition by simulation. Your program should take
    a command-line argument `n`, play the game `n` times using each of the two strategies
    (switch or do not switch), and write the chance of success for each of the two
    strategies. Or you can [play the game here](http://www.stat.sc.edu/~west/javahtml/LetsMakeaDeal.html).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**游戏模拟。** 在 1970 年代的游戏节目 *让我们来做个交易* 中，一个参赛者面前有三扇门。其中一扇门后面有一个有价值的奖品。在参赛者选择一扇门后，主持人会打开其他两扇门中的一扇（当然不会透露奖品）。然后参赛者有机会换到另一扇未打开的门。参赛者应该这样做吗？直观上，参赛者最初选择的门和另一扇未打开的门被认为是同等可能包含奖品的，因此没有换门的动机。编写一个程序通过模拟来测试这种直觉。您的程序应该接受一个命令行参数
    `n`，使用两种策略（换门或不换门）玩 `n` 次游戏，并写出两种策略的成功概率。或者您可以[在这里玩游戏](http://www.stat.sc.edu/~west/javahtml/LetsMakeaDeal.html)。'
- en: '*Solution*: See [montehall.py](montehall.py.html).'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见 [montehall.py](montehall.py.html)。'
- en: '**Chaos.** Compose a program to study the following simple model for population
    growth, which might be applied to study fish in a pond, bacteria in a test tube,
    or any of a host of similar situations. We suppose that the population ranges
    from 0 (extinct) to 1 (maximum population that can be sustained). If the population
    at time *t* is *x*, then we suppose the population at time *t* + 1 to be *rx*(1-*x*),
    where the parameter *r*, known as the *fecundity parameter*, controls the rate
    of growth. Start with a small population — say, *x* = 0.01 — and study the result
    of iterating the model, for various values of *r*. For which values of *r* does
    the population stabilize at *x* = 1 - 1/*r* ? Can you say anything about the population
    when *r* is 3.5? 3.8? 5?'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**混沌。** 编写一个程序来研究以下简单的人口增长模型，该模型可以应用于研究池塘中的鱼、试管中的细菌或类似情况。我们假设人口从0（灭绝）到1（可维持的最大人口）范围内。如果时间为*t*时的人口为*x*，那么我们假设时间为*t*
    + 1时的人口为*r*x*(1-*x*)，其中参数*r*，称为*生育参数*，控制增长速率。从一个小的人口开始 — 比如，*x* = 0.01 — 并研究模型的迭代结果，对于不同的*r*值。在哪些*r*值下，人口会稳定在*x*
    = 1 - 1/*r*？当*r*为3.5时，你能说些什么？3.8？5？'
- en: Biologists model population growth of fish in a pond using the [logistic equation](http://mathworld.wolfram.com/LogisticEquation.html).
    Investigate some of its chaotic behavior.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生物学家使用[Logistic方程](http://mathworld.wolfram.com/LogisticEquation.html)来模拟池塘中鱼类的人口增长。研究一些混沌行为。
- en: '**Euler''s sum-of-powers conjecture**. In 1769 Leonhard Euler formulated a
    generalized version of Fermat''s Last Theorem, conjecturing that at least *n*
    *n*th powers of positive integers are needed to obtain a sum that is itself an
    *n*th power, for *n* > 2\. Compose a program to disprove Euler''s conjecture (which
    stood until 1967), using a quintuply nested loop to find four positive integers
    whose 5th powers sum to the 5th power of another positive integer. That is, find
    five integers *a*, *b*, *c*, *d*, and *e* such that *a*⁵ + *b*⁵ + *c*⁵ + *d*⁵
    = *e*⁵.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欧拉的幂求和猜想**。1769年，莱昂哈德·欧拉提出了费马大定理的一个广义版本，猜想至少需要*n*个正整数的*n*次幂来得到一个本身也是*n*次幂的和，对于*n*
    > 2。编写一个程序来反驳欧拉的猜想（直到1967年仍然有效），使用五重嵌套循环来找到四个正整数，它们的5次幂之和等于另一个正整数的5次幂。也就是说，找到五个整数*a*、*b*、*c*、*d*和*e*，使得*a*⁵
    + *b*⁵ + *c*⁵ + *d*⁵ = *e*⁵。'
- en: '**Dragon curves.** This exercise is a generalization of the "dragon curves"
    exercise from Section 1.2\. Compose a program that takes an integer command-line
    argument `n` and writes the instructions for drawing a dragon curve of order `n`.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**龙曲线。** 这个练习是从第1.2节的“龙曲线”练习推广而来。编写一个程序，接受一个整数命令行参数`n`，并编写绘制一个阶为`n`的龙曲线的指令。'
- en: '*Solution*: See [dragon2.py](dragon2.py.html).'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[dragon2.py](dragon2.py.html)。'
