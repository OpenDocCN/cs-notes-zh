- en: Lecture 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3讲
- en: 原文：[https://cs50.harvard.edu/sql/notes/3/](https://cs50.harvard.edu/sql/notes/3/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/sql/notes/3/](https://cs50.harvard.edu/sql/notes/3/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[Database Schema](#database-schema)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库模式](#database-schema)'
- en: '[Inserting Data](#inserting-data)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[插入数据](#inserting-data)'
- en: '[Questions](#questions)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions)'
- en: '[Other Constraints](#other-constraints)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[其他约束](#other-constraints)'
- en: '[Inserting Multiple Rows](#inserting-multiple-rows)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[插入多行](#inserting-multiple-rows)'
- en: '[Questions](#questions-1)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-1)'
- en: '[Deleting Data](#deleting-data)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[删除数据](#deleting-data)'
- en: '[Questions](#questions-2)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-2)'
- en: '[Updating Data](#updating-data)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更新数据](#updating-data)'
- en: '[Triggers](#triggers)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[触发器](#triggers)'
- en: '[Creating a “Sell” Trigger](#creating-a-sell-trigger)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建“卖出”触发器](#creating-a-sell-trigger)'
- en: '[Creating a “Buy” Trigger](#creating-a-buy-trigger)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建“购买”触发器](#creating-a-buy-trigger)'
- en: '[Questions](#questions-3)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-3)'
- en: '[Soft Deletions](#soft-deletions)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[软删除](#soft-deletions)'
- en: '[Fin](#fin)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结束](#fin)'
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Last week, we learned how to create our own database schema. In this lecture,
    we’ll explore how to add, update, and delete data in our databases.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上周，我们学习了如何创建自己的数据库模式。在本讲中，我们将探讨如何在数据库中添加、更新和删除数据。
- en: The Boston MFA (Museum of Fine Arts) is a century-old museum in Boston. The
    MFA manages a vast collection of historical and contemporary artifacts and artwork.
    They likely use a database of some kind to store data about their art and artifacts.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波士顿MFA（美术博物馆）是波士顿一个拥有一个世纪历史的博物馆。MFA管理着大量历史和当代艺术品和文物的收藏。他们可能使用某种类型的数据库来存储有关他们的艺术和文物的数据。
- en: When a new artifact is added to their collection, we can imagine they would
    insert the corresponding data to their database. Similarly, there are use cases
    in which data might need to be read, updated or deleted.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个新的艺术品被添加到他们的收藏中时，我们可以想象他们会将相应的数据插入到他们的数据库中。同样，也存在一些用例，其中可能需要读取、更新或删除数据。
- en: We will focus now on the creation (or insertion) of data in a Boston MFA database.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们将专注于在波士顿MFA数据库中创建（或插入）数据。
- en: Database Schema
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库模式
- en: Consider this schema that the MFA might use for its collection.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到MFA可能用于其收藏的此架构。
- en: '!["MFA Collections Table containing IDs, titles of artwork and other information"](../Images/1d4a6ad032325ea7543c7f7885755730.png)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![包含ID、艺术品标题和其他信息的MFA收藏表](../Images/1d4a6ad032325ea7543c7f7885755730.png)'
- en: Each row of data contains the title for a piece of artwork along with the `accession_number`
    which is a unique ID used by the museum internally. There is, too, a date indicating
    when the art was acquired.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行数据包含一件艺术品的标题以及`accession_number`，这是博物馆内部使用的唯一ID。还有一个表示艺术品获取日期的日期。
- en: The table contains an ID which serves as the primary key.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中包含一个ID，用作主键。
- en: We can imagine that the database administrator of the MFA runs an SQL query
    to insert each of these pieces of artwork into the table.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以想象，MFA的数据库管理员运行一个SQL查询，将每一件艺术品插入到表中。
- en: To understand how this works, let us first create a database called `mfa.db`.
    Next, we read the schema file `schema.sql` into the database. This schema file,
    already given to us, helps us create the table `collections`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了理解这是如何工作的，让我们首先创建一个名为`mfa.db`的数据库。接下来，我们将模式文件`schema.sql`读入数据库。此模式文件已经提供给我们，帮助我们创建`collections`表。
- en: To confirm that the table has been created, we can select from the table.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确认表已创建，我们可以从表中选择。
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should give us an empty result, because the table doesn’t have any data
    yet.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会得到一个空的结果，因为表还没有任何数据。
- en: Inserting Data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入数据
- en: The SQL statement `INSERT INTO` is used to insert a row of data into a given
    table.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT INTO` SQL语句用于将一行数据插入到指定的表中。'
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that this command requires the list of columns in the table that
    will receive new data and the values to be added to each column, in the same order.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，这个命令需要指定将接收新数据的表中的列列表以及要添加到每个列中的值，顺序相同。
- en: Running the `INSERT INTO` command returns nothing, but we can run a query to
    confirm that the row is now present in `collections`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`INSERT INTO`命令不会返回任何内容，但我们可以运行一个查询来确认该行现在已存在于`collections`表中。
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can add more rows to the database by inserting multiple times. However, typing
    out the value of the primary key manually (as 1, 2, 3 etc.) might result in errors.
    Thankfully, SQLite can fill out the primary key values automatically. To make
    use of this functionality, we omit the ID column altogether while inserting a
    row.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过多次插入来向数据库添加更多行。然而，手动输入主键值（如1、2、3等）可能会导致错误。幸运的是，SQLite可以自动填充主键值。为了使用此功能，在插入行时我们可以完全省略ID列。
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can check that this row has been inserted with an `id` of 2 by running
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来检查这一行是否已插入，其`id`为2：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the way SQLite fills out the primary key values is by incrementing
    the previous primary key—in this case, 1.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意SQLite填充主键值的方式是通过递增前一个主键值——在这种情况下，是1。
- en: Questions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: If we delete a row with the primary key 1, will SQLite automatically assign
    a primary key of 1 to the next inserted row?
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们删除具有主键1的行，SQLite是否会自动将主键1分配给下一个插入的行？
- en: No, SQLite actually selects the highest primary key value in the table and increments
    it to generate the next primary key value.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，SQLite实际上会选择表中最高的主键值并将其递增以生成下一个主键值。
- en: Other Constraints
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他约束
- en: Opening the file `schema.sql` will pull up the schema for the database.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件`schema.sql`将显示数据库的模式。
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is specified that the accession number is unique. If we try to insert a
    row with a repeated accession number, we will trigger a error that looks like
    `Runtime error: UNIQUE constraint failed: collections.accession_number (19)`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '规定访问编号必须是唯一的。如果我们尝试插入一个具有重复访问编号的行，将会触发一个看起来像`Runtime error: UNIQUE constraint
    failed: collections.accession_number (19)`的错误。'
- en: This error informs us that the row we are trying to insert violates a constraint
    in the schema—specifically the `UNIQUE` constraint in this scenario.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，我们正在尝试插入的行违反了模式中的约束——具体来说，在这个场景中是`UNIQUE`约束。
- en: Similarly, we can try to add a row with a `NULL` title, violating the `NOT NULL`
    constraint.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们可以尝试添加一个具有`NULL`标题的行，违反了`NOT NULL`约束。
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On running this, we will again see an error that looks like `Runtime error:
    NOT NULL constraint failed: collections.title (19)`.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '运行此命令后，我们又将看到类似`Runtime error: NOT NULL constraint failed: collections.title
    (19)`的错误。'
- en: In this manner, the schema constraints are guardrails that protect us from adding
    rows that do not follow the schema of our database.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式，模式约束是保护我们免于添加不符合我们数据库模式的行的护栏。
- en: Inserting Multiple Rows
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入多行
- en: We may need to insert more than one row at a time while writing into a database.
    One way to do this is to separate out the rows using commas in the `INSERT INTO`
    command.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向数据库写入时，我们可能需要一次插入多行。一种方法是在`INSERT INTO`命令中使用逗号分隔行。
- en: '!["Inserting multiple rows at once separated by commas"](../Images/ff24439bb0c509f1c81bf0ee7ee4a194.png)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一次插入多行，使用逗号分隔](../Images/ff24439bb0c509f1c81bf0ee7ee4a194.png)'
- en: Inserting multiple rows at once in this manner allows the programmer some convenience.
    It is also a faster, more efficient way of inserting rows into a database.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式一次插入多行允许程序员获得一些便利。这同样是一种更快、更高效地将行插入数据库的方法。
- en: Let us now insert two new paintings into the `collections` table.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们将两幅新的画作插入到`collections`表中。
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The museum may not always know exactly when a painting was acquired, hence it
    is possible for the `acquired` value to be `NULL`, as is the case for the first
    painting we just inserted.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 博物馆可能并不总是确切知道一幅画是在何时获得的，因此`acquired`值可能是`NULL`，正如我们刚刚插入的第一幅画的情况。
- en: To see the updated table, we can select all rows from the table as always.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看更新的表，我们可以像往常一样选择表中的所有行。
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our data could also be stored in a [comma-separated values](https://en.wikipedia.org/wiki/Comma-separated_values)
    format, or CSV. Observe in the following example how the values in each row are
    separated by a comma.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据也可以以[逗号分隔值](https://en.wikipedia.org/wiki/Comma-separated_values)格式或CSV存储。观察以下示例，可以看到每行的值是通过逗号分隔的。
- en: '!["Paintings data in comma-separated values format"](../Images/e789fafb524dd0bc004121131620fa3c.png)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![以逗号分隔的值格式的画作数据](../Images/e789fafb524dd0bc004121131620fa3c.png)'
- en: SQLite makes it possible to import a CSV file directly into our database. To
    do this, we need to start from scratch. Let us leave this database `mfa.db` and
    then remove it.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite使得直接将CSV文件导入我们的数据库成为可能。为此，我们需要从头开始。让我们离开这个数据库`mfa.db`然后将其删除。
- en: We already have a CSV file called `mfa.csv` that contains the data we need.
    On opening up this file, we can note that the first row contains the column names,
    which match exactly with the column names of our table `collections` as per the
    schema.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经有一个名为 `mfa.csv` 的 CSV 文件，其中包含我们需要的数据。打开这个文件后，我们可以注意到第一行包含列名，这些列名与我们的表 `collections`
    的模式中的列名完全匹配。
- en: First, let us create again the database `mfa.db` and read the schema file as
    we did earlier.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们再次创建数据库 `mfa.db` 并像之前一样读取模式文件。
- en: Next, we can import the CSV by running a SQLite command.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过运行 SQLite 命令来导入 CSV 文件。
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first argument, `--csv` indicates to SQLite that we are importing a CSV
    file. This will help SQLite parse the file correctly. The second argument indicates
    that the first row of the CSV file (the header row) needs to be skipped, or not
    inserted into the table.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个参数 `--csv` 告诉 SQLite 我们正在导入一个 CSV 文件。这将帮助 SQLite 正确解析文件。第二个参数表示 CSV 文件的第一个行（标题行）需要被跳过，或者不插入到表中。
- en: We can select all the data from the `collections` table to see that every painting
    from `mfa.csv` has been successfully imported into the table.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过查询 `collections` 表来查看所有数据，以确认 `mfa.csv` 中的每一幅画都已成功导入到表中。
- en: The CSV file we just inserted contained primary key values (1, 2, 3 etc.) for
    each row of data. However, it is more likely that CSV files we work with will
    not contain the ID or primary key values. How can we have SQLite insert them automatically?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚刚插入的 CSV 文件包含了每行数据的唯一键值（1, 2, 3 等）。然而，我们处理的大多数 CSV 文件可能不会包含 ID 或主键值。我们如何让
    SQLite 自动插入它们？
- en: 'To try this out, let’s open up `mfa.csv` in our codespace and delete the `id`
    column from the header row, along with the values in each column. This is what
    `mfa.csv` should look like once we finish editing:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了尝试这个方法，让我们在我们的代码空间中打开 `mfa.csv` 并删除标题行中的 `id` 列，以及每个列中的值。编辑完成后，`mfa.csv` 应该看起来像这样：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will also delete all the rows that are already within the `collections` table.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将删除 `collections` 表中已经存在的所有行。
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we want to import this CSV file into a table. However, the `collections`
    table (as per our schema) must have four columns in every row. This new CSV file
    contains only three columns for every row. Hence, we cannot proceed to import
    in the same way we did before.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们想要将这个 CSV 文件导入到一个表中。然而，根据我们的模式，`collections` 表的每一行都必须有四个列。这个新的 CSV 文件中的每一行只有三个列。因此，我们无法像以前那样继续导入。
- en: 'To successfully import the CSV file without ID values, we will to use a temporary
    table:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要成功导入没有 ID 值的 CSV 文件，我们将需要使用一个临时表：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how we don’t use the argument `--skip 1` with this command. This is because
    SQLite is capable of recognizing the very first row of CSV data as the header
    row, and converts those into the column names of the new `temp` table.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在这个命令中没有使用 `--skip 1` 参数。这是因为 SQLite 能够识别 CSV 数据的第一行作为标题行，并将其转换为新 `temp`
    表的列名。
- en: We can see the data within the `temp` table by querying it.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过查询 `temp` 表来查看其中的数据。
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we will select the data (without primary keys) from `temp` and move it
    to `collections`, which was the goal all along! We can use the following command
    to achieve this.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将从 `temp` 表中选择数据（不包含主键）并将其移动到 `collections` 表中，这正是我们的目标！我们可以使用以下命令来实现这一点。
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this process, SQLite will automatically add the primary key values in the
    `id` column.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此过程中，SQLite 将自动在 `id` 列中添加主键值。
- en: Just to clean up our database, we can also drop the `temp` table once we’re
    done moving data.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了清理我们的数据库，我们也可以在移动数据后删除 `temp` 表。
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Questions
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Can we place columns in specific positions while inserting into a table?
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能否在插入表时将列放置在特定的位置？
- en: While we can change the ordering of values in the `INSERT INTO` command, we
    usually can’t change the ordering of the column names themselves. The order of
    column names follows the same order used while creating the table.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们可以更改 `INSERT INTO` 命令中值的顺序，但我们通常不能更改列名的顺序。列名的顺序遵循创建表时使用的相同顺序。
- en: What happens if one of the multiple rows we are trying to insert violates a
    table constraint?
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们尝试插入的多行中的任意一行违反了表约束，会发生什么？
- en: While trying to insert multiple rows into a table, if even one of them violates
    a constraint, the insertion command will result in an error and none of the rows
    will be inserted!
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试将多行插入到表中时，如果其中任意一行违反了约束，插入命令将导致错误，并且不会插入任何行！
- en: After inserting data from the CSV, one of the cells was empty and not `NULL`.
    Why did this happen?
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在从CSV文件插入数据后，其中一个单元格为空且不是`NULL`。为什么会发生这种情况？
- en: When we imported data from the CSV file, one of the `acquired` values was missing!
    This was interpreted as text and hence, read into the table as an empty text value.
    We can run queries on the table after importing to convert these empty values
    into `NULL` if required.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们从CSV文件导入数据时，`acquired`值中的一个缺失了！这被解释为文本，因此被读取到表中作为空文本值。我们可以在导入后运行查询，将这些空值转换为`NULL`，如果需要的话。
- en: Deleting Data
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据
- en: We saw previously that running the following command deleted all rows from the
    table `collections`. (We don’t want to actually run this command now or we’ll
    lose all the data in the table!)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前看到运行以下命令从`collections`表中删除了所有行。（我们现在实际上不想运行这个命令，否则我们会丢失表中的所有数据！）
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also delete rows that match specific conditions. For example, to delete
    the painting “Spring outing” from our table `collections` we can run:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以删除符合特定条件的行。例如，要从我们的`collections`表中删除“春游”画作，我们可以执行以下命令：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To delete any paintings with the date acquired as `NULL` we can run
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除任何获得日期为`NULL`的画作，我们可以执行以下命令：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we always do, we will make sure the deletion worked as expected by selecting
    all data from the table.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和我们通常做的那样，我们将通过从表中选择所有数据来确保删除操作按预期工作。
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We see that the “Spring outing” and “Imaginative landscape” paintings are not
    in the table anymore.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到“春游”和“想象风景”画作不再在表中。
- en: To delete rows pertaining to paintings older than 1909, we can run
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除1909年之前的画作相关行，我们可以执行以下命令：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `<` operator here, we are finding the paintings acquired **before**
    January 1, 1909\. These are the paintings that will be deleted on running the
    query.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`<`运算符，我们正在查找1909年1月1日之前获得的画作。这些是在运行查询时将被删除的画作。
- en: There might be cases where deleting some data could impact the integrity of
    a database. Foreign key constraints are a good example. A foreign key column references
    the primary key of a different table. If we were to delete the primary key, the
    foreign key column would have nothing to reference!
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在删除某些数据会影响数据库完整性的情况。外键约束是一个很好的例子。外键列引用不同表的主键。如果我们删除主键，外键列将没有任何可引用的内容！
- en: Consider now an updated schema for the MFA database, containing information
    not just about artwork but also artists. The two entities Artist and Collection
    have a many-to-many relationship—a painting can be created by many artists and
    a single artist can also create many pieces of artwork.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在考虑MFA数据库的更新模式，它不仅包含关于艺术品的信息，还包含艺术家信息。艺术家和收藏两个实体之间存在多对多关系——一幅画可以由许多艺术家创作，而单个艺术家也可以创作许多艺术品。
- en: '!["Updated schema with artist and collection entities"](../Images/f58f93a48e8212621493f29a34edc06f.png)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![包含艺术家和收藏实体的更新模式](../Images/f58f93a48e8212621493f29a34edc06f.png)'
- en: Here is a database implementing the above ER Diagram.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个实现上述ER图的数据库。
- en: '!["Three tables: artists, created, collections"](../Images/a46c676e9328b03f588d06f29f307160.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三张表：艺术家、创建时间、收藏](../Images/a46c676e9328b03f588d06f29f307160.png)'
- en: The `artists` and `collections` tables have primary keys—the ID columns. The
    `created` table references these IDs in its two foreign key columns.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`artists` 和 `collections` 表具有主键——ID列。`created` 表通过其两个外键列引用这些ID。'
- en: Given this database, if we choose to delete the unidentified artist (with the
    ID 3), what would happen to the rows in the table `created` with an `artist_id`
    of 3? Let’s try it out.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定这个数据库，如果我们选择删除未知的艺术家（ID为3），那么`created`表中具有`artist_id`为3的行会发生什么？让我们试一试。
- en: After opening up `mfa.db`, we can now see the updated schema by running the
    `.schema` command. The `created` table does indeed have two foreign key constraints,
    one for the artist ID and one for the collection ID.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在打开`mfa.db`后，现在我们可以通过运行`.schema`命令来查看更新的模式。`created`表确实有两个外键约束，一个针对艺术家ID，一个针对收藏ID。
- en: Now, we can try to delete from the `artists` table.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试从`artists`表中删除数据。
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On running this, we get an error very similar to ones we have seen before in
    this class: `Runtime error: FOREIGN KEY constraint failed (19)`. This error notifies
    us that deleting this data would violate the foreign key constraint set up in
    the `created` table.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行此命令时，我们得到一个与我们在本课程中之前看到的非常相似的错误：`运行时错误：外键约束失败（19）`。这个错误通知我们，删除这些数据将违反在`created`表中设置的外键约束。
- en: How do we ensure that the constraint is not violated? One possibility is to
    delete the corresponding rows from the `created` table before deleting from the
    `artists` table.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何确保约束不被违反？一种可能性是在从`artists`表删除之前，先从`created`表中删除相应的行。
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This query effectively deletes the artist’s *affiliation* with their work. Once
    the affiliation no longer exists, we can delete the artist’s data without violating
    the foreign key constraint. To do this, we can run
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个查询有效地删除了艺术家与其作品之间的*关联*。一旦关联不再存在，我们就可以在不违反外键约束的情况下删除艺术家的数据。为此，我们可以运行
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In another possibility, we can specify the action to be taken when an ID referenced
    by a foreign key is deleted. To do this, we use the keyword `ON DELETE` followed
    by the action to be taken.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一种可能性中，我们可以指定当通过外键引用的ID被删除时采取的操作。为此，我们使用关键字`ON DELETE`后跟要执行的操作。
- en: '`ON DELETE RESTRICT`: This restricts us from deleting IDs when the foreign
    key constraint is violated.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON DELETE RESTRICT`：这限制我们在外键约束违反时删除ID。'
- en: '`ON DELETE NO ACTION`: This allows the deletion of IDs that are referenced
    by a foreign key and nothing happens.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON DELETE NO ACTION`：这允许删除由外键引用的ID，但不会发生任何操作。'
- en: '`ON DELETE SET NULL`: This allows the deletion of IDs that are referenced by
    a foreign key and sets the foreign key references to `NULL`.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON DELETE SET NULL`：这允许删除由外键引用的ID，并将外键引用设置为`NULL`。'
- en: '`ON DELETE SET DEFAULT`: This does the same as the previous, but allows us
    to set a default value instead of `NULL`.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON DELETE SET DEFAULT`：这与之前的行为相同，但允许我们设置默认值而不是`NULL`。'
- en: '`ON DELETE CASCADE`: This allows the deletion of IDs that are referenced by
    a foreign key and also proceeds to cascadingly delete the referencing foreign
    key rows. For example, if we used this to delete an artist ID, all the artist’s
    affiliations with the artwork would also be deleted from the `created` table.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON DELETE CASCADE`：这允许删除由外键引用的ID，并继续级联删除引用的外键行。例如，如果我们使用此方法删除艺术家ID，所有艺术家与艺术品的关联也会从`created`表中删除。'
- en: The latest version of the schema file implements the above method. The foreign
    key constraints now look like
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新版本的架构文件实现了上述方法。外键约束现在看起来像
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now running the following `DELETE` statement will not result in an error, and
    will cascade the deletion from the `artists` table to the `created` table:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在运行以下`DELETE`语句不会导致错误，并将级联删除从`artists`表传播到`created`表：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To check that this cascading deletion worked, we can query the `created` table:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查级联删除是否工作，我们可以查询`created`表：
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We observe that none of the rows have an ID of 3 (the ID of the artist deleted
    from the `artists` table).
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们观察到没有行具有ID 3（从`artists`表中删除的艺术家ID）。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: We just deleted an artist with the ID of 3\. Is there any way to make the next
    inserted row have an ID of 3?
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们刚刚删除了ID为3的艺术家。有没有办法让下一个插入的行具有ID 3？
- en: By default, as we discussed before, SQLite will select the largest ID present
    in the table and increment it to obtain the next ID. But we can use the `AUTOINCREMENT`
    keyword while creating a column to indicate that any deleted ID should be repurposed
    for a new row being inserted into the table.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，正如我们之前讨论的，SQLite将选择表中存在的最大ID并递增以获得下一个ID。但我们在创建列时可以使用`AUTOINCREMENT`关键字来指示任何被删除的ID应重新用于表中插入的新行。
- en: Updating Data
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据
- en: We can easily imagine scenarios in which data in a database would need to be
    updated. Perhaps, in the case of the MFA database, we find out that the painting
    “Farmers working at dawn” originally mapped to an “Unidentified artist” was actually
    created by the artist Li Yin.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松想象出数据库中的数据需要更新的场景。也许，在MFA数据库的案例中，我们发现原本映射到“未知的艺术家”的画作“黎明时分劳作的农民”实际上是由艺术家李银创作的。
- en: We can use the update command to make changes to say, the affiliation of a painting.
    Here is the syntax of the update command.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用更新命令来更改，比如说，一幅画的关系。以下是更新命令的语法。
- en: '!["Update command syntax"](../Images/f4d431ce171f05cc1c883af7cf6854a7.png)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更新命令语法](../Images/f4d431ce171f05cc1c883af7cf6854a7.png)'
- en: Let’s change this affiliation for “Farmers working at dawn” in the `created`
    table using the above syntax.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们使用上述语法在`created`表中更改“黎明时分劳作的农民”的关联。
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first part of this query specifies the table to be updated. The next part
    retrieves the ID of Li Yin to set as the new ID. The last part selects the row(s)
    in `created` which will be updated with the ID of Li Yin, which is the painting
    “Farmers working at dawn”!
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询的第一部分指定了要更新的表。下一部分检索李因的 ID 以设置为新的 ID。最后一部分选择 `created` 中的行（多行），这些行将更新为李因的
    ID，即画作“黎明时分劳作的农民”！
- en: Triggers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发器
- en: A **trigger** is a SQL statement that runs automatically in response to another
    SQL statement, such as an `INSERT`, `UPDATE`, or `DELETE`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**是一个 SQL 语句，在响应另一个 SQL 语句（如 `INSERT`、`UPDATE` 或 `DELETE`）时自动运行。'
- en: Triggers are useful for maintaining data consistency and automating tasks across
    related tables.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器对于维护数据一致性和在相关表之间自动化任务非常有用。
- en: Creating a “Sell” Trigger
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建“销售”触发器
- en: Consider the MFA database with a `collections` table and a new `transactions`
    table.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑包含一个 `collections` 表和一个新的 `transactions` 表的 MFA 数据库。
- en: '[PRE28]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When artwork is sold (deleted from `collections`), we want it automatically
    logged in `transactions` with an action of “sold”.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当艺术品被出售（从 `collections` 中删除）时，我们希望它自动在 `transactions` 中记录为“销售”动作。
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This trigger runs before a row is deleted from `collections`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个触发器在从 `collections` 中删除行之前运行。
- en: '**OLD** is a special keyword that refers to the row being deleted.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OLD** 是一个特殊的关键字，它指的是即将被删除的行。'
- en: '`OLD."title"` accesses the title column of the row about to be deleted.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OLD."title"` 访问即将被删除的行的标题列。'
- en: The trigger automatically inserts a record into `transactions` with the action
    “sold”.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器自动在 `transactions` 中插入一条记录，动作标记为“销售”。
- en: Creating a “Buy” Trigger
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建“购买”触发器
- en: When artwork is bought (inserted into `collections`), we want it logged in `transactions`
    with an action of “bought”.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当艺术品被购买（插入到 `collections`）时，我们希望它在 `transactions` 中记录为“购买”动作。
- en: '[PRE30]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This trigger runs after a new row is inserted into `collections`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个触发器在 `collections` 中插入新行之后运行。
- en: '**NEW** is a special keyword that refers to the row being inserted.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NEW** 是一个特殊的关键字，它指的是正在插入的行。'
- en: '`NEW."title"` accesses the title column of the newly inserted row.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW."title"` 访问新插入行的标题列。'
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Can we have multiple SQL statements inside a trigger?
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 触发器内可以包含多个 SQL 语句吗？
- en: Yes, you can have multiple statements inside the `BEGIN` and `END` blocks, separated
    by semicolons.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，你可以在 `BEGIN` 和 `END` 块内包含多个语句，用分号分隔。
- en: Soft Deletions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软删除
- en: '**Soft deletion** (or a **soft delete**) means marking data as deleted rather
    than actually removing it from the database.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软删除**（或**软删除**）意味着将数据标记为已删除，而不是真正从数据库中移除它。'
- en: 'For example, we could add a `deleted` column to the `collections` table with
    a default value of 0:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `collections` 表中添加一个 `deleted` 列，默认值为 0：
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To “delete” a row, we would update the `deleted` column to 1:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要“删除”一行，我们会更新 `deleted` 列为 1：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, to query only non-deleted rows:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，为了查询仅非删除行：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This way, data can be recovered if needed and maintains a complete historical
    record.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样，如果需要的话，数据可以被恢复，并且保持完整的历史记录。
- en: However, it’s still important to comply with data privacy regulations that require
    data to be truly deleted.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，遵守要求数据真正被删除的数据隐私法规仍然很重要。
- en: Fin
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束
- en: This brings us to the conclusion of Lecture 3 about Writing in SQL!
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就带我们来到了关于 SQL 写作的第三讲结束！
