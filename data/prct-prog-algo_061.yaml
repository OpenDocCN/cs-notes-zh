- en: 1.2 Built-in Types of Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 数据的内置类型
- en: 原文：[https://introcs.cs.princeton.edu/python/12types](https://introcs.cs.princeton.edu/python/12types)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/12types](https://introcs.cs.princeton.edu/python/12types)
- en: A *data type* is a set of values and a set of operations defined on those values.
    Many data types are built into the Python language. In this section, we consider
    Python's built-in data types `int` (for integers), `float` (for floating-point
    numbers), `str` (for sequences of characters) and `bool` (for true-false values).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型*是一组值和在这些值上定义的一组操作。许多数据类型内置于Python语言中。在本节中，我们考虑Python内置的数据类型`int`（用于整数）、`float`（用于浮点数）、`str`（用于字符序列）和`bool`（用于真假值）。'
- en: '![Basic Built-In Data Types](../Images/50e0a3e3eb3c358a5904fce92f81dd40.png)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![基本内置数据类型](../Images/50e0a3e3eb3c358a5904fce92f81dd40.png)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Definitions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义
- en: 'To talk about data types, we need to introduce some terminology. To do so,
    we start with the following code fragment:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论数据类型，我们需要介绍一些术语。为此，我们从以下代码片段开始：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code creates three *objects*, each of type `int`, using the *literals*
    `1234` and `99` and the *expression* `a + b`, and *binds* *variables* `a`, `b`,
    and `c` to those objects using *assignment statements*. The end result is that
    variable `c` is bound to an object of type `int` whose value is `1333`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了三个类型为`int`的*对象*，使用*字面值*`1234`和`99`以及*表达式*`a + b`，并使用*赋值语句*将*变量*`a`、`b`和`c`绑定到这些对象。最终结果是变量`c`绑定到一个类型为`int`、值为`1333`的对象。
- en: Objects.
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象。
- en: All data values in a Python program are represented by *objects* and relationships
    among objects. An object is an in-computer-memory representation of a value from
    a particular data type. Each object is characterized by its *identity*, *type*,
    and *value*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序中的所有数据值都由*对象*和对象之间的关系表示。对象是特定数据类型的值在计算机内存中的表示。每个对象由其*标识*、*类型*和*值*特征化。
- en: The *identity* uniquely identifies an object. You should think of it as the
    location in the computer's memory (or memory address) where the object is stored.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标识*唯一标识一个对象。你应该将其视为计算机内存中对象存储的位置（或内存地址）。'
- en: The *type* of an object completely specifies its behavior — the set of values
    it might represent and the set of operations that can be performed on it.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的*类型*完全指定了其行为——它可能表示的值集合和可以对其执行的操作集合。
- en: The *value* of an object is the data-type value that it represents.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的*值*是它所代表的数据类型值。
- en: Each object stores one value; for example, an object of type `int` can store
    the value `1234` or the value `99` or the value `1333`. Different objects may
    store the same value. For example, one object of type `str` might store the value
    `'hello'`, and another object of type `str` also might store the same value `'hello'`.
    We can apply to an object any of the operations defined by its type (and only
    those operations). For example, we can multiply two `int` objects but not two
    `str` objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象存储一个值；例如，类型为`int`���对象可以存储值`1234`、值`99`或值`1333`。不同对象可能存储相同的值。例如，一个类型为`str`的对象可能存储值`'hello'`，另一个类型为`str`的对象也可能存储相同的值`'hello'`。我们可以对对象应用其类型定义的任何操作（仅限于这些操作）。例如，我们可以将两个`int`对象相乘，但不能将两个`str`对象相乘。
- en: Object references.
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象引用。
- en: An *object reference* is nothing more than a concrete representation of the
    object's identity (the memory address where the object is stored). Python programs
    use object references either to access the object's value or to manipulate the
    object references themselves.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象引用*只不过是对象标识（对象存储的内存地址）的具体表示。Python程序使用对象引用来访问对象的值或操作对象引用本身。'
- en: Literals.
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面值。
- en: A *literal* is a Python-code representation of a data-type value. It creates
    an object with the specified value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面值*是数据类型值的Python代码表示。它创建一个具有指定值的对象。'
- en: Operators.
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符。
- en: An *operator* is a Python-code representation of a data-type operation. For
    example, Python uses `+` and `*` to represent addition and multiplication for
    integers and floating-point numbers; Python uses `and`, `or`, and `not` to represent
    boolean operations; and so forth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作符*是Python代码中数据类型操作的表示。例如，Python使用`+`和`*`表示整数和浮点数的加法和乘法；Python使用`and`、`or`和`not`表示布尔操作；等等。'
- en: Identifiers.
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符。
- en: 'An *identifier* is a Python-code representation of a name. Each identifier
    is a sequence of letters, digits, and underscores, the first of which is not a
    digit. The following keywords are reserved and you cannot use them as identifiers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*是一个名称的Python代码表示。每个标识符是一个字母、数字和下划线的序列，第一个不是数字。以下关键字是保留的，你不能将它们用作标识符：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Variable](../Images/6012b40051af7943536d89c1036e0d8e.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![变量](../Images/6012b40051af7943536d89c1036e0d8e.png)'
- en: Variables.
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量。
- en: A *variable* is a name for an object reference. We use variables to keep track
    of changing values as a computation unfolds. We use diagrams like the one at right
    to show the binding of a variable to an object. ![Anatomy of an Expression](../Images/0210f07be6e464baf22ec59668860b86.png)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是对象引用的名称。我们使用变量来跟踪随着计算的展开而变化的值。我们使用像右侧的图表来显示变量与对象的绑定。![表达式的解剖](../Images/0210f07be6e464baf22ec59668860b86.png)'
- en: Expressions.
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式。
- en: An *expression* is a combination of literals, variables, and operators that
    Python evaluates to produce an object. Each operand can be any expression, perhaps
    within parentheses. For example, we can compose expressions like `4 * (x - 3)`
    or `5 * x - 6` and Python will understand what we mean.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*是由文字、变量和操作符组合而成的，Python评估后会产生一个对象。每个操作数可以是任何表达式，可能在括号内。例如，我们可以组合表达式如`4
    * (x - 3)`或`5 * x - 6`，Python会理解我们的意思。'
- en: Operator precedence.
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符优先级。
- en: 'An expression is shorthand for a sequence of operations. Python''s *precedence
    rules* specify the order in which the operations should be applied. For arithmetic
    operations, multiplication and division are performed before addition and subtraction,
    so that `a - b * c` and `a - (b * c)` represent the same sequence of operations.
    When arithmetic operators have the same precedence, they are left associative,
    which means that `a - b - c` and `(a - b) - c` represent the same sequence of
    operations. You can use parentheses to override the rules, so you can write `a
    - (b - c)` if that is what you want. For full details see [Appendix A: Operator
    Precedence in Python](../appendix_precedence).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是一系列操作的简写。Python的*优先级规则*指定应用操作的顺序。对于算术运算，乘法和除法在加法和减法之前执行，因此`a - b * c`和`a
    - (b * c)`表示相同的操作序列。当算术运算符具有相同的优先级时，它们是左结合的，这意味着`a - b - c`和`(a - b) - c`表示相同的操作序列。您可以使用括号覆盖规则，因此如果您想要，可以编写`a
    - (b - c)`。有关完整详情，请参阅[附录A：Python中的运算符优先级](../appendix_precedence)。
- en: Assignment statements.
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值语句。
- en: 'An *assignment statement* is a directive to Python to bind the variable on
    the left side of the = operator to the object produced by evaluating the expression
    on the right side. For example, when we write `c = a + b`, we are expressing this
    action: "associate the variable `c` with the sum of the values associated with
    the variables `a` and `b`."'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*赋值语句*是对Python的指令，将=运算符左侧的变量绑定到右侧表达式评估产生的对象。例如，当我们写`c = a + b`时，我们表达了这个动作：“将变量`c`与变量`a`和`b`关联的值的和关联起来。”'
- en: Informal trace.
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非正式追踪。
- en: '![Trace](../Images/8e6dde2b4136f7417811a4d4ece04f6f.png)An effective way to
    keep track of the values associated with variables is to use a table like the
    one at right, with one line giving the values after each statement has been executed.
    Such a table is called a *trace*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![追踪](../Images/8e6dde2b4136f7417811a4d4ece04f6f.png)跟踪与变量关联的值的有效方法是使用右侧的表格，其中一行给出每个语句执行后的值。这样的表称为*追踪*。'
- en: Object-level trace.
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象级别的追踪。
- en: 'For a more complete understanding, we sometimes keep track of objects and references
    in traces. The object-level trace at right illustrates the full effect of our
    three assignment statements: ![TraceFormal](../Images/8348c214392c562b564ea94cf22add6a.png)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更全面地理解，我们有时会在追踪中跟踪对象和引用。右侧的对象级别追踪说明了我们的三个赋值语句的全部效果：![追踪形式](../Images/8348c214392c562b564ea94cf22add6a.png)
- en: The statement `a = 1234` creates an `int` object whose value is `1234`; it then
    binds the variable `a` to this new int object.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句`a = 1234`创建一个值为`1234`的`int`对象；然后将变量`a`绑定到这个新的`int`对象。
- en: The statement `b = 99` creates an int object whose value is `99`; it then binds
    the variable `b` to this new `int` object.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句`b = 99`创建一个值为`99`的`int`对象；然后将变量`b`绑定到这个新的`int`对象。
- en: The statement `c = a + b` creates the int object whose value is `1333` as the
    sum of the value of the `int` object bound to `a` and the value of the `int` object
    bound to `b`; it then binds the variable `c` to the new `int` object.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句`c = a + b`创建值为`1333`的`int`对象，作为绑定到`a`的`int`对象的值和绑定到`b`的`int`对象的值的和；然后将变量`c`绑定到新的`int`对象。
- en: '* * *'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Strings
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: The `str` data type represents strings, for use in text processing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`数据类型表示字符串，用于文本处理。'
- en: '![Str Data Type](../Images/f4736aed039e1c6e012186a3cdf8efe2.png)'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![字符串数据类型](../Images/f4736aed039e1c6e012186a3cdf8efe2.png)'
- en: '![Ruler](../Images/d699e251e32cf294c2122790f39c2976.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![标尺](../Images/d699e251e32cf294c2122790f39c2976.png)'
- en: The value of a `str` object is a sequence of characters. You can specify a `str`
    literal by enclosing a sequence of characters in matching single quotes. You can
    concatenate two strings using the operator `+`. As an example, [ruler.py](ruler.py.html)
    computes a table of values of the ruler function that describes the relative lengths
    of the marks on a ruler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`对象的值是一系列字符。您可以通过将一系列字符括在匹配的单引号中来指定`str`文字。您可以使用运算符`+`连接两个字符串。例如，[ruler.py](ruler.py.html)计算了描述标尺上标记相对长度的标尺函数值的表。'
- en: Converting numbers to strings for output.
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数字转换为字符串以进行输出。
- en: 'Python provides the built-in function `str()` to convert numbers to strings.
    Our most frequent use of the string concatenation operator is to chain together
    the results of a computation for output with `stdio.write()` and `stdio.writeln()`,
    often in conjunction with the `str()` function, as in this example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了内置函数`str()`来将数字转换为字符串。我们最常用的字符串连接运算符是将计算结果与`stdio.write()`和`stdio.writeln()`一起链在一起进行输出，通常与`str()`函数一起使用，就像这个例子中一样：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If `a` and `b` are `int` objects whose values are `1234` and `99`, respectively,
    then that statement writes the line of output `1234 + 99 = 1333`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`和`b`是值分别为`1234`和`99`的`int`对象，则该语句写出输出行`1234 + 99 = 1333`。
- en: Converting strings to numbers for input.
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将字符串转换为数字以进行输入。
- en: Python also provides built-in functions to convert strings (such as the ones
    we type as command-line arguments) to numeric objects. We use the Python built-in
    functions `int()` and `float()` for this purpose. If the user types `1234` as
    the first command-line argument, then the code `int(sys.argv[1])` evaluates to
    the `int` object whose value is `1234`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了内置函数来将字符串（例如我们作为命令行参数键入的字符串）转换为数字对象。我们使用Python内置函数`int()`和`float()`来实现这一目的。如果用户将`1234`键入为第一个命令行参数，则代码`int(sys.argv[1])`评估为值为`1234`的`int`对象。
- en: '* * *'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Integers
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: The `int` data type represents integers or natural numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`数据类型表示整数或自然数。'
- en: '![Int Data Type](../Images/b8b24f8e09a3cb310d191cfa95bcdcd5.png)'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![整数数据类型](../Images/b8b24f8e09a3cb310d191cfa95bcdcd5.png)'
- en: Python includes operators for common arithmetic operations on integers, including
    `+` for addition, `-` for subtraction, `*` for multiplication, `//` for floored
    division, `%` for remainder, and `**` for exponentiation. All of these operators
    are defined just as in grade school (keeping in mind that the floored division
    operator results in an integer). Program [intops.py](intops.py.html) illustrates
    basic operations for manipulating `int` objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包括用于整数的常见算术运算符，包括加法`+`，减法`-`，乘法`*`，向下取整除法`//`，取余`%`和指数运算`**`。所有这些运算符都与小学定义的一样（请记住，向下取整除法运算符的结果是整数）。程序[intops.py](intops.py.html)演示了操作`int`对象的基本操作。
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Division in Python 2.
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 2 中的除法。
- en: In Python 3, the `/` operator has the same behavior as the floating-point division
    operator when both its operands are integers. In Python 2, the `/` operator has
    the same behavior as the floored division operator `//` when both its operands
    are integers. For example, `17 / 2` evaluates to `8.5` in Python 3 and to `8`
    in Python 2\. For compatibility among Python versions, we do not use the `/` operator
    with two `int` operands in this booksite. |
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，当两个操作数都是整数时，`/`运算符的行为与浮点除法运算符相同。在 Python 2 中，当两个操作数都是整数时，`/`运算符的行为与向下取整除法运算符`//`相同。例如，在
    Python 3 中，`17 / 2`的结果为`8.5`，在 Python 2 中为`8`。为了在不同版本的 Python 中保持兼容性，在本书站点中不使用带有两个`int`操作数的`/`运算符。
- en: '* * *'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Floating-Point Numbers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: The `float` data type is for representing floating-point numbers, for use in
    scientific and commercial applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`数据类型用于表示浮点数，用于科学和商业应用。'
- en: '![Float Data Type](../Images/ca6bcdf5288a45ffc225e6afb1b82a49.png)'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![浮点数据类型](../Images/ca6bcdf5288a45ffc225e6afb1b82a49.png)'
- en: Python includes operators for common arithmetic operations on floats, including
    + for addition, - for subtraction, * for multiplication, / for division, and **
    for exponentiation. Program [floatops.py](floatops.py.html) illustrates the basic
    operations for manipulating `float` objects. Program [quadratic.py](quadratic.py.html)
    shows the use of `float` objects in computing the two roots of a quadratic equation
    using the quadratic formula.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包括用于浮点数的常见算术运算符，包括加法`+`，减法`-`，乘法`*`，除法`/`和指数运算`**`。程序[floatops.py](floatops.py.html)演示了操作`float`对象的基本操作。程序[quadratic.py](quadratic.py.html)展示了使用二次方程公式计算二次方程的两个根时使用`float`对象。
- en: We use floating-point numbers to represent real numbers, but they are decidedly
    not the same as real numbers! There are infinitely many real numbers, but we can
    represent only a finite number of floating-point numbers in any digital computer.
    For example, `5.0/2.0` evaluates to `2.5` but `5.0/3.0` evaluates to `1.6666666666666667`.
    Typically, floating-point numbers have 15–17 decimal digits of *precision*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用浮点数来表示实数，但它们与实数并不相同！实数有无限多个，但我们只能在任何数字计算机中表示有限数量的浮点数。例如，`5.0/2.0`的结果为`2.5`，但`5.0/3.0`的结果为`1.6666666666666667`。通常，浮点数具有15-17位的*精度*。
- en: Note the use of the `math.sqrt()` function in the [quadratic.py](quadratic.py.html)
    program. The standard `math` module defines trigonometric functions, logarithm/exponential
    functions, and other common mathematical functions. To use the `math` module,
    place the statement `import math` near the beginning of the program and then call
    functions using syntax such as `math.sqrt(x)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[quadratic.py](quadratic.py.html)���序中使用`math.sqrt()`函数。标准的`math`模块定义三角函数，对数/指数函数和其他常见的数学函数。要使用`math`模块，请在程序开头附近放置语句`import
    math`，然后使用语法调用函数，例如`math.sqrt(x)`。
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Booleans
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The `bool` data type has just two values: `True` and `False`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`数据类型只有两个值：`True`和`False`。'
- en: '![Bool Data Type](../Images/f42cabd8eb0f4912c0b24646b9ee05f3.png)'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Bool数据类型](../Images/f42cabd8eb0f4912c0b24646b9ee05f3.png)'
- en: 'The apparent simplicity is deceiving — booleans lie at the foundation of computer
    science. The most important operators defined for booleans are the *logical ooperators*:
    `and`, `or`, and `not`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看起来很简单，但布尔值是计算机科学的基础。对于布尔值定义的最重要运算符是*逻辑运算符*：`and`，`or`和`not`：
- en: '`a` and `b` is `True` if both operands are `True`, and `False` if either is
    `False`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`和`b`都是`True`，则`a`和`b`为`True`，如果其中一个为`False`，则`a`和`b`为`False`。
- en: '`a` or `b` is `False` if both operands are `False`, and `True` if either is
    `True`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`或`b`都是`False`，则`a`或`b`为`False`，如果其中一个为`True`，则`a`或`b`为`True`。
- en: '`not a` is `True` if `a` is `False`, and `False` if `a` is `True`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`为`False`，则`not a`为`True`，如果`a`为`True`，则`not a`为`False`。
- en: 'We can formally specify the definition of each operation using truth tables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用真值表正式指定每个操作的定义：
- en: '![Boolean operators](../Images/450d6ca06d9a122100d8e5b6cc457cfd.png)'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![布尔运算符](../Images/450d6ca06d9a122100d8e5b6cc457cfd.png)'
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Comparisons
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: The comparison operators `==`, `!=`, `<`, `<=`, `>`, and `>=` are defined for
    both integers and floats, and evaluate to a boolean result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符`==`，`!=`，`<`，`<=`，`>`和`>=`对整数和浮点数都定义，并计算为布尔结果。
- en: '![](../Images/4e02906da68392a72f69b28a72a8effa.png)'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/4e02906da68392a72f69b28a72a8effa.png)'
- en: The program [leapyear.py](leapyear.py.html) shows the use of boolean expressions
    and comparison operations to compute whether a given year is a leap year. Section
    1.3 of this booksite describes more common uses of the comparison operators.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[leapyear.py](leapyear.py.html)展示了使用布尔表达式和比较运算来计算给定年份是否为闰年。本书站点的第1.3节描述了比较运算符的更常见用法。
- en: '* * *'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Functions and APIs
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和APIs
- en: '![Api](../Images/2964e30b7dbaf2796aa7fdb8e9e3c37b.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Api](../Images/2964e30b7dbaf2796aa7fdb8e9e3c37b.png)'
- en: 'As we have seen, many programming tasks involve using *functions*. We distinguish
    three kinds of functions: *built-in functions* (such as `int()`, `float()`, and
    `str()`) that you can use directly in any Python program, *standard functions*
    (such as `math.sqrt()`) that are defined in a Python standard module and are available
    in any program that imports the module, and booksite functions (such as `stdio.write()`
    and `stdio.writeln()`) that are defined in this booksite modules and available
    for you to use after you have made them available to Python and imported them.
    We describe some more useful functions in this section. In later chapters, you
    will learn not just how to use other functions, but how to define and use your
    own functions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，许多编程任务涉及使用*函数*。我们区分三种函数：*内置函数*（如 `int()`、`float()` 和 `str()`）可以直接在任何
    Python 程序中使用，*标准函数*（如 `math.sqrt()`）在 Python 标准模块中定义，并在导入模块的任何程序中可用，以及书站函数（如 `stdio.write()`
    和 `stdio.writeln()`）在本书站模块中定义，并在你将它们提供给 Python 并导入它们后可供你使用。我们在本节中描述了一些更有用的函数。在后面的章节中，你将学习不仅如何使用其他函数，还将学习如何定义和使用自己的函数。
- en: For convenience, we summarize the functions that you need to know how to use
    in tables like the one shown on the right. Such a table is known as an *application
    programming interface (API)*. The table below shows some typical function calls.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，我们总结了你需要了解如何使用的函数，就像右侧显示的表格所示。这样的表格称为*应用程序���程接口（API）*。下面的表格显示了一些典型的函数调用。
- en: '* * *'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Type Conversion
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: We often find ourselves converting data from one type to another using one of
    the following approaches.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要使用以下方法之一将数据从一种类型转换为另一种类型。
- en: Explicit type conversion.
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式类型转换。
- en: Call functions such as `int()`, `float()`, `str()`, and `round()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数，如 `int()`、`float()`、`str()` 和 `round()`。
- en: '![Type conversion API](../Images/5dbb12bca9ae78946f2eeb4c75fdb10e.png)'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![类型转换 API](../Images/5dbb12bca9ae78946f2eeb4c75fdb10e.png)'
- en: Implicit type conversion (from integer to float).
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式类型转换（从整数到浮点数）。
- en: You can use an integer where a float is expected, because Python automatically
    converts integers to floats when appropriate. For example, `10/4.0` evaluates
    to `2.5` because `4.0` is a float and both operands need to be of the same type;
    thus, `10` is converted to a float and then the result of dividing two floats
    is a float. This kind of conversion is called *automatic promotion* or *coercion*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要浮点数时，你可以使用整数，因为 Python 会在适当的时候自动将整数转换为浮点数。例如，`10/4.0` 的结果是 `2.5`，因为 `4.0`
    是浮点数，两个操作数需要是相同的类型；因此，`10` 被转换为浮点数，然后两个浮点数相除的结果是浮点数。这种转换称为*自动提升*或*强制转换*。
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Interactive Python
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式 Python
- en: If you issue the command `python` (that is, the word `python` stand-alone, with
    no following file name) in your terminal window, Python identifies itself and
    writes a `>>>` prompt. At that point you can type a Python statement and Python
    will execute it. Or, you can type a Python expression and Python will evaluate
    it and write the resulting value. Or, you can type `help()` to get access to Python's
    extensive interactive documentation. This is a convenient way to test new constructs
    and access documentation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在终端窗口中输入命令 `python`（即，单独输入单词 `python`，后面没有文件名），Python 会识别自身并显示 `>>>` 提示符。此时你可以输入一个
    Python 语句，Python 将执行它。或者，你可以输入一个 Python 表达式，Python 将评估它并输出结果值。或者，你可以输入 `help()`
    来访问 Python 的广泛交互式文档。这是一个方便的测试新构造和访问文档的方式。
- en: '![InteractivePython1](../Images/2828a17c80c6751c06262b0dec6f3199.png) ![InteractivePython2](../Images/a05292f8cb7153ced84277b1f1affb9d.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![交互式 Python1](../Images/2828a17c80c6751c06262b0dec6f3199.png) ![交互式 Python2](../Images/a05292f8cb7153ced84277b1f1affb9d.png)'
- en: '* * *'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Q & A: Strings'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答：字符串
- en: '**Q.** How does Python store strings internally?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python 如何在内部存储字符串？'
- en: '**A.** Strings are sequences of characters that are encoded with Unicode, a
    modern standard for encoding text. Unicode supports over 100,000 different characters,
    including more than 100 different languages plus mathematical and musical symbols.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 字符串是使用 Unicode 编码的字符序列，Unicode 是一种现代文本编码标准。Unicode 支持超过 100,000 个不同的字符，包括
    100 多种不同的语言以及数学和音乐符号。'
- en: '**Q.** Which data type does Python provide for characters?'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python 提供哪种数据类型用于字符？'
- en: '**A.** Python has no special data type for characters. A character is simply
    a string consisting of one element, such as `''A''`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python 没有专门的字符数据类型。字符只是由一个元素组成的字符串，比如 `''A''`。'
- en: '**Q.** Can I compare strings using comparison operators such as `==` and <
    or built-in functions such as `max()` and `min()`?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以使用比较运算符（如 `==` 和 <）或内置函数（如 `max()` 和 `min()`）来比较字符串吗？'
- en: '**A.** Yes. Informally, Python uses *lexicographic order* to compare two strings,
    like words in a book index or dictionary. For example, `''hello''` and `''hello''`
    are equal, `''hello''` and `''goodbye''` are unequal, and `''goodbye''` is less
    than `''hello''`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。非正式地，Python 使用*词典顺序*来比较两个字符串，就像书索引或字典中的单词一样。例如，`''hello''` 和 `''hello''`
    相等，`''hello''` 和 `''goodbye''` 不相等，`''goodbye''` 小于 `''hello''`。'
- en: '**Q.** Can I use matching double quotes for string literals instead of single
    quotes?'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以使用匹配的双引号来表示字符串文字，而不是单引号吗？'
- en: '**A.** Yes. For example, `''hello''` and `"hello"` are identical literals.
    Double quotes are useful to specify a string that contains single quotes, so that
    you don''t need to escape them. For example, `''Python\''s''` and `"Python''s"`
    are identical string literals. You can also use matching triple quotes for multiline
    strings. For example, the following creates a two-line string and assigns it to
    the variable `s`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。例如，`''hello''` 和 `"hello"` 是相同的文字。双引号可用于指定包含单引号的字符串，这样你就不需要转义它们。例如，`''Python\''s''`
    和 `"Python''s"` 是相同的字符串文字。你也可以使用匹配的三引号来表示多行字符串。例如，以下代码创建一个两行字符串并将其赋值给变量 `s`：'
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this booksite, we do not use double or triple quotes to delimit string literals.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书站点中，我们不使用双引号或三引号来界定字符串文字。
- en: '| **Strings in Python 2.** Python 2 uses ASCII instead of Unicode to encode
    characters. ASCII is a legacy standard that supports 128 characters, including
    the English alphabet, numbers, and punctuation. Python 2 offers a separate data
    type unicode for strings composed of Unicode characters, but many Python 2 libraries
    do not support it. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **Python 2中的字符串。** Python 2使用ASCII而不是Unicode来编码字符。ASCII是一个支持128个字符的传统标准，包括英文字母、数字和标点符号。Python
    2为由Unicode字符组成的字符串提供了一个单独的数据类型unicode，但许多Python 2库不支持它。 |'
- en: '* * *'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Q & A: Integers'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q & A：整数
- en: '**Q.** How does Python store integers internally?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python是如何在内部存储整数的？'
- en: '**A.** The simplest representation is for small positive integers, where the
    binary number system is used to represent each integer with a fixed amount of
    computer memory.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 最简单的表示是对于小的正整数，使用二进制数系统将每个整数表示为固定数量的计算机内存。'
- en: '**Q.** What''s the binary number system?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 什么是二进制数系统？'
- en: '**A.** In the binary number system, we represent an integer as a sequence of
    bits. A bit is a single binary (base 2) digit — either 0 or 1 — and is the basis
    for representing information in computers. In this case the bits are coefficients
    of powers of 2\. Specifically, the sequence of bits *b[n]b[n-1]...b[2]b[1]b[0]*
    represents the integer'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在二进制数系统中，我们将整数表示为一系列位。一个位是一个单一的二进制（基数2）数字 —— 要么是0，要么是1 —— 是计算机中表示信息的基础。在这种情况下，位是2的幂的系数。具体来说，位序列*b[n]b[n-1]...b[2]b[1]b[0]*表示整数'
- en: '*b[n]2^n + b[n-1]2^(n-1) + ... + b[2]2² + b[1]2¹ + b[0]2⁰*'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*b[n]2^n + b[n-1]2^(n-1) + ... + b[2]2² + b[1]2¹ + b[0]2⁰*'
- en: For example, 1100011 represents the integer
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，1100011表示整数
- en: 99 = 1 · 64 + 1 · 32 + 0 · 16 + 0 · 8 + 0 · 4 + 1 · 2 + 1 · 1.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 99 = 1 · 64 + 1 · 32 + 0 · 16 + 0 · 8 + 0 · 4 + 1 · 2 + 1 · 1。
- en: The more familiar decimal number system is the same except that the digits are
    between zero and 9 and we use powers of 10\. Converting a number to binary is
    an interesting computational problem that we will consider in the next section.
    For small integers, Python uses a fixed number of bits, typically dictated by
    a basic design parameter of your computer —usually 32 or 64\. For example, the
    integer 99 might be represented with the 32 bits `00000000000000000000000001100011`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更熟悉的十进制数系统与此相同，只是数字在0到9之间，我们使用10的幂。将一个数字转换为二进制是一个有趣的计算问题，我们将在下一节中考虑。对于小整数，Python使用固定数量的位，通常由计算机的基本设计参数决定
    —— 通常是32或64。例如，整数99可能用32位表示为`00000000000000000000000001100011`。
- en: '**Q.** How about negative numbers?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 负数呢？'
- en: '**A.** Small negative numbers are handled with a convention known as *two''s
    complement*, which we need not consider in detail. The definition of "small" depends
    on the underlying computer system. On older 32-bit machines, "small" typically
    covers the range -2147483648 (-2^(31)) to 2147483647 (2^(31) - 1). On newer 64-bit
    machines, "small" typically covers the range -2^(63) to 2^(63) - 1, in which case
    "small" is not so small! If an integer is not "small," then Python automatically
    uses a more elaborate representation whose range is limited only by the amount
    of memory available on your computer system. Note that details of these internal
    representations are hidden from your programs, so you can use them in systems
    with different representations without having to change them.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 小的负数使用一种称为*二进制补码*的约定处理，我们不需要详细考虑。"小"的定义取决于底层计算机系统。在旧的32位机器上，“小”通常涵盖范围为-2147483648（-2^(31)）到2147483647（2^(31)
    - 1）。在新的64位机器上，“小”通常涵盖范围为-2^(63)到2^(63) - 1，这种情况下，“小”并不那么小！如果一个整数��是“小”，那么Python会自动使用一个更复杂的表示，其范围仅受计算机系统上可用内存量的限制。请注意，这些内部表示的细节对于您的程序是隐藏的，因此您可以在具有不同表示的系统中使用它们，而无需更改它们。'
- en: '**Q.** What does the expression `1/0` evaluate to in Python?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 在Python中，表达式`1/0`的结果是什么？'
- en: '**A.** It raises a `ZeroDivisionError` at run time. Note: The easiest way to
    answer such questions is to use Python''s interactive mode. Try it!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在运行时引发`ZeroDivisionError`。注意：回答这类问题最简单的方法是使用Python的交互模式。试试看！'
- en: '**Q.** How do the floored division operator `//` and remainder operator `%`
    work on negative operands?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 负操作数上的地板除法运算符`//`和余数运算符`%`是如何工作的？'
- en: '**A.** Try them and see! `-47 // 5` evaluates to `-10` and `-47 % 5` evaluates
    to `3`. Generalizing, the floored division operator `//` yields the floored quotient;
    that is, the quotient is rounded toward minus infinity. The behavior of the remainder
    operator `%` is more complicated. In Python, if `a` and `b` are integers, then
    the expression `a % b` evaluates to an integer that has the same sign as `b`.
    This implies that `b * (a // b) + a % b == a` for any integers `a` and `b`. In
    some other languages (such as Java), the expression `a % b` evaluates to an integer
    that has the same sign as `a`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 试一试！`-47 // 5`的结果是`-10`，`-47 % 5`的结果是`3`。一般来说，地板除法运算符`//`产生地板商；也就是说，商向负无穷大取整。余数运算符`%`的行为更复杂。在Python中，如果`a`和`b`是整数，则表达式`a
    % b`的结果是一个与`b`具有相同符号的整数。这意味着对于任何整数`a`和`b`，都有`b * (a // b) + a % b == a`。在一些其他语言（如Java）中，表达式`a
    % b`的结果是一个与`a`具有相同符号的整数。'
- en: '**Q.** How does the exponentiation operator `**` work with negative operands?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 指数运算符`**`如何处理负操作数？'
- en: '**A.** Try it out and see for yourself. Note that the `**` operator has higher
    precedence than a unary plus/minus operator on its left but lower precedence than
    a unary plus/minus operator on its right. For example, `-3**4` evaluates to `-81`
    (and not `81`). Also, it can result in an object of a different type. For example,
    `10**-2` evaluates to the float `0.01` and `(-10)**(10**-2)` evaluates to a complex
    number in Python 3 (but raises a run-time error in Python 2).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 亲自尝试一下。请注意，`**`运算符比左侧的一元加/减运算符具有更高的优先级，但比右侧的一元加/减运算符具有更低的优先级。例如，`-3**4`的结果是`-81`（而不是`81`）。此外，它可能导致不同类型的对象。例如，`10**-2`的结果是浮点数`0.01`，而`(-10)**(10**-2)`在Python
    3中的结果是一个复数（但在Python 2中会引发运行时错误）。'
- en: '**Q.** Why does `10^6` evaluate to `12` instead of `1000000`?'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么`10^6`的结果是`12`而不是`1000000`？'
- en: '**A.** The `^` operator is not an exponentiation operator, which you must have
    been thinking. Instead, it is an operator that we do not use in this book. You
    want the literal `1000000`. You could use the expression `10**6`, but it is wasteful
    to use an expression (which requires evaluation at run time) when a literal would
    suffice.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** `^`运算符不是指数运算符，你可能一直在想。相反，它是一个我们在本书中不使用的运算符。你想要的是字面值`1000000`。你可以使用表达式`10**6`，但在只需字面值时使用表达式（需要在运行时评估）是浪费的。'
- en: '| **Integers in Python 2**. Python 2 supports two separate types for integers
    — `int` (for small integers) and `long` (for larger integers). Python 2 automatically
    promotes from type `int` to `long` whenever necessary. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **Python 2中的整数**。Python 2支持两种不同类型的整数 — `int`（用于小整数）和`long`（用于较大整数）。Python
    2会在必要时自动从`int`类型提升为`long`类型。'
- en: '* * *'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Q & A: Floating point numbers'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q & A：浮点数
- en: '**Q.** Why is the type for real numbers named `float`?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么实数的类型被命名为`float`？'
- en: '**A.** The decimal point can "float" across the digits that make up the real
    number. In contrast, with integers the (implicit) decimal point is fixed after
    the least significant digit.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 小数点可以在构成实数的数字之间“浮动”。相比之下，对于整数，（隐式）小数点在最低有效数字之后是固定的。'
- en: '**Q.** How does Python store floating-point numbers internally?'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python如何在内部存储浮点数？'
- en: '**A.** Generally, Python uses the representation that is natural for the underlying
    computer system. Most modern computer systems store floating-point numbers as
    defined by the IEEE 754 standard. That standard specifies that a floating-point
    number is stored using three fields: sign, mantissa, and exponent. If you are
    interested, see the the Wikipedia [IEEE floating point]( http://en.wikipedia.org/wiki/IEEE_floating_point)
    page for more details. The IEEE 754 standard also specifies how special floating-point
    values — positive zero, negative zero, positive infinity, negative infinity, and
    `NaN` (not a number) — should be handled. For example, it specifies that `-0.0/3.0`
    should evaluate to `-0.0`, `1.0/0.0` should evaluate to positive infinity, and
    `0.0/0.0` should evaluate to `NaN`. You can use the (rather unusual) expressions
    `float(''inf'')` and `float(''-inf'')` for positive and negative infinity in some
    simple calculations, but Python does not conform to this part of the IEEE 754
    standard. For example, in Python, `-0.0/3.0` correctly evaluates to `-0.0`, but
    both `1.0/0.0` and `0.0/0.0` raise a `ZeroDivisionError` at run time.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 一般来说，Python使用对底层计算机系统自然的表示。大多数现代计算机系统按照IEEE 754标准存储浮点数。该标准规定浮点数使用三个字段存储：符号、尾数和指数。如���你感兴趣，可以查看维基百科的[IEEE浮点数](http://en.wikipedia.org/wiki/IEEE_floating_point)页面了解更多细节。IEEE
    754标准还规定了如何处理特殊浮点值 — 正零、负零、正无穷大、负无穷大和`NaN`（不是一个数字）。例如，它规定`-0.0/3.0`应该评估为`-0.0`，`1.0/0.0`应该评估为正无穷大，`0.0/0.0`应该评估为`NaN`。你可以在一些简单计算中使用（相当不寻常的）表达式`float(''inf'')`和`float(''-inf'')`表示正无穷大和负无穷大，但Python不符合IEEE
    754标准的这一部分。例如，在Python中，`-0.0/3.0`正确评估为`-0.0`，但`1.0/0.0`和`0.0/0.0`都会在运行时引发`ZeroDivisionError`。'
- en: '**Q.** Fifteen digits for floating-point numbers certainly seems enough to
    me. Do I really need to worry much about precision?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 浮点数的十五位数字对我来说肯定足够了。我真的需要太在意精度吗？'
- en: '**A.** Yes, because you are used to mathematics based on real numbers with
    infinite precision, whereas the computer always deals with approximations. For
    example, in IEEE 754 floating point, the expression `(0.1 + 0.1 == 0.2)` evaluates
    to `True` but `(0.1 + 0.1 + 0.1 == 0.3)` evaluates to `False`! Pitfalls like this
    are not at all unusual in scientific computing. Novice programmers should avoid
    comparing two floating-point numbers for equality.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 可以，因为你习惯于基于具有无限精度的实数的数学，而计算机总是处理近似值。例如，在IEEE 754浮点数中，表达式`(0.1 + 0.1
    == 0.2)`评估为`True`，但`(0.1 + 0.1 + 0.1 == 0.3)`评估为`False`！在科学计算中遇到这样的陷阱并不罕见。初学者程序员应避免将两个浮点数进行相等比较。'
- en: '**Q.** It is annoying to see all those digits when writing a float. Is it possible
    to get `stdio.write()` and `stdio.writeln()` to write just two or three digits
    after the decimal point?'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 写入浮点数时看到所有那些数字很烦人。是否可以让`stdio.write()`和`stdio.writeln()`只写入小数点后的两三个数字？'
- en: '**A.** The booksite function `stdio.writef()` is one way to do the job — it
    is similar to the basic formatted writing function in the C programming language
    and many other modern languages, as discussed in Section 1.5\. Until then, we
    will live with the extra digits (which is not all bad, since doing so helps us
    to get used to the different types of numbers).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** booksite函数`stdio.writef()`是一种方法 — 它类似于C编程语言和许多其他现代语言中的基本格式化写入函数，如1.5节所讨论的那样。在那之前，我们将接受额外的数字（这并不全是坏事，因为这样做有助于我们适应不同类型的数字）。'
- en: '**Q.** Can I apply the floored division operator `//` to two float operands?'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以将地板除法运算符`//`应用于两个浮点操作数吗？'
- en: '**A.** Yes, it produces the floored division of its operands. That is, the
    result is the quotient in which digits after the decimal place are removed. We
    do not use the floored division operator on floats in this book.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，它产生其操作数的地板除法。也就是说，结果是商，小数点后的数字被移除。我们在本书中不对浮点数使用地板除法运算符。'
- en: '**Q.** What does `round()` return if the fractional part of its argument is
    `0.5`?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果其参数的小数部分为`0.5`，`round()`会返回什么？'
- en: '**A.** In Python 3, it returns the nearest even integer, so `round(2.5)` is
    `2`, `round(3.5)` is `4`, and `round(-2.5)` is `-2`. But in Python 2, the `round()`
    function rounds away from zero (and returns a float), so `round(2.5)` is `3.0`,
    `round(3.5)` is `4.0`, and `round(-2.5)` is `-3.0`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在Python 3中，它返回最接近的偶数，因此`round(2.5)`是`2`，`round(3.5)`是`4`，`round(-2.5)`是`-2`。但在Python
    2中，`round()`函数远离零四舍五入（并返回一个浮点数），因此`round(2.5)`是`3.0`，`round(3.5)`是`4.0`，`round(-2.5)`是`-3.0`。'
- en: '**Q.** Can I compare a `float` to an `int`?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以比较`float`和`int`吗？'
- en: '**A.** Not without doing a type conversion, but remember that Python does the
    requisite type conversion automatically. For example, if `x` is the integer `3`,
    then the expression `(x < 3.1)` evaluates to `True` because Python promotes the
    integer `3` to generate the float `3.0` and then compares `3.0` with `3.1`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 没有进行类型转换的话是不行的，但要记住Python会自动进行必要的类型转换。例如，如果`x`是整数`3`，那么表达式`(x < 3.1)`的结果是`True`，因为Python将整数`3`提升为生成浮点数`3.0`，然后将`3.0`与`3.1`进行比较。'
- en: '**Q.** Are there functions in Python''s `math` module for other trigonometric
    functions, such as arc sine, hyperbolic sine, and secant?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python的`math`模块中是否有其他三角函数，如反正弦、双曲正弦和正割函数？'
- en: '**A.** Yes, Python''s `math` module includes inverse trigonometric functions
    and hyperbolic functions. However, there are no functions for secant, cosecant,
    and cotangent because you could use `math.sin()`, `math.cos()`, and `math.tan()`
    to compute them easily. Choosing which functions to include in an API is a tradeoff
    between the convenience of having every function that you need and the annoyance
    of having to find one of the few that you need in a long list. No choice will
    satisfy all users, and the Python designers have many users to satisfy. Note that
    there are plenty of redundancies even in the APIs that we have listed. For example,
    you could use `math.sin(x) / math.cos(x)` instead of `math.tan(x)`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，Python的`math`模块包括反三角函数和双曲函数。然而，没有正割、余割和余切函数，因为你可以使用`math.sin()`、`math.cos()`和`math.tan()`来轻松计算它们。选择在API中包含哪些函数是方便性和烦恼之间的权衡：方便性在于拥有你需要的每个函数，而烦恼在于必须在一个长列表中找到你需要的少数几个函数。没有选择会满足所有用户，Python设计者有很多用户要满足。请注意，即使在我们列出的API中也有很多冗余。例如，你可以使用`math.sin(x)
    / math.cos(x)`代替`math.tan(x)`。'
- en: '* * *'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q & A
- en: '**Q.** What happens if I access a variable that I haven''t bound to an object?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我访问一个未绑定到对象的变量会发生什么？'
- en: '**A.** Python will raise a `NameError` at run time.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python会在运行时引发`NameError`。'
- en: '**Q.** How can I determine the type of a variable?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何确定一个变量的类型？'
- en: '**A.** That''s a trick question. Unlike variables in many programming languages
    (such as Java), a Python variable does not have a type. Instead, it is the object
    to which a variable is bound that has a type. You can bind the same variable to
    objects of different types, as in this code fragment:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这是一个诡计问题。与许多编程语言（如Java）中的变量不同，Python变量没有类型。相反，变量绑定的对象才有类型。你可以将同一个变量绑定到不同类型的对象，就像这个代码片段中：'
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, for clarity, it's usually a bad idea to do so.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了清晰起见，通常这样做是一个坏主意。
- en: '**Q.** How can I determine the type, identity, and value of an object?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何确定一个对象的类型、标识和值？'
- en: '**A.** Python provides built-in functions for this purpose. The function `type()`
    returns the type of an object; the function `id()` returns the identity of an
    object; the function `repr()` returns an unambiguous string representation of
    an object.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python提供了用于此目的的内置函数。函数`type()`返回对象的类型；函数`id()`返回对象的标识；函数`repr()`返回对象的一个明确的字符串表示。'
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will rarely use these functions in ordinary programming, but you may find
    them useful when debugging.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常编程中你很少会使用这些函数，但在调试时可能会发现它们很有用。
- en: '**Q.** Is there a difference between `=` and `==` ?'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `=`和`==`之间有什么区别？'
- en: '**A.** Yes, they are quite different! The first specifies an assignment to
    a variable, and the second is a comparison operator that produces a boolean result.
    Your ability to understand this answer is a sure test of whether you understood
    the material in this section. Think about how you might explain the difference
    to a friend.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，它们是完全不同的！第一个指定对变量的赋值，第二个是一个比较运算符，产生一个布尔结果。你能理解这个答案是对你是否理解本节内容的一个确定测试。想想你如何向朋友解释这个区别。'
- en: '**Q.** Will `a < b < c` test whether the three numbers `a`, `b`, and `c` are
    in order?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `a < b < c`会测试这三个数字`a`、`b`和`c`是否按顺序排列吗？'
- en: '**A.** Yes, Python supports arbitrary chaining of comparisons such as `a <
    b < c` that behave according to standard mathematical conventions. However, in
    many programming languages (such as Java) the expression `a < b < c` is illegal
    because the subexpression `a < b` evaluates to a boolean and that boolean is then
    compared with a number, which is meaningless. We do not use chained comparisons
    in this book; instead we prefer expressions such as `(a < b) and (b < c)`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，Python支持任意链式比较，比如`a < b < c`，它们遵循标准的数学约定。然而，在许多编程语言（如Java）中，表达式`a
    < b < c`是非法的，因为子表达式`a < b`评估为布尔值，然后将该布尔值与一个数字进行比较，这是没有意义的。我们在��书中不使用链式比较；相反，我们更喜欢像`(a
    < b) and (b < c)`这样的表达式。'
- en: '**Q.** Will `a = b = c = 17` set the three variables to 17?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `a = b = c = 17`会将这三个变量设置为17吗？'
- en: '**A.** Yes, even though Python assignment statements are not expressions, Python
    supports arbitrary chaining of assignment statements. We do not use chained assignments
    in the book because many Python programmers consider it poor style.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 可以，尽管Python赋值语句不是表达式，但Python支持任意链式赋值语句。我们在书中不使用链式赋值，因为许多Python程序员认为这是不好的风格。'
- en: '**Q.** Can I use the logical operators `and`, `or`, and `not` with operands
    that are not booleans?'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以在不是布尔值的操作数上使用逻辑运算符`and`、`or`和`not`吗？'
- en: '**A.** Yes, but for clarity it''s usually a bad idea to do so. In this context,
    Python considers `0`, `0.0`, and the empty string `''''` to mean `False`, and
    any other integer, float, or string to mean `True`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但为了清晰起见，通常这样做是一个坏主意。在这种情况下，Python认为`0`、`0.0`和空字符串`''''`表示`False`，而任何其他整数、浮点数或字符串表示`True`。'
- en: '**Q.** Can I use arithmetic operators with boolean operands?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以在布尔操作数上使用算术运算符吗？'
- en: '**A.** Yes, but again it''s bad form to do so. When you use boolean operands
    with arithmetic operators, they are promoted to integers: `0` for `False` and
    `1` for `True`. For example, `(False - True - True) * True` evaluates to the `int`
    value `-2`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但再次这样做通常是不好的。当你将布尔操作数与算术运算符一起使用时，它们会被提升为整数：`False`为`0`，`True`为`1`。例如，`(False
    - True - True) * True`的结果是`int`值`-2`。'
- en: '**Q.** Can I name a variable `max`?'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以将变量命名为`max`吗？'
- en: '**A.** Yes, but if you do, then you won''t be able to use the built-in function
    `max()`. The same holds for `min()`, `sum()`, `float()`, `eval()`, `open()`, `id()`,
    `type()`, `file()`, and other built-in functions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但如果这样做，你就无法使用内置函数`max()`。对于`min()`、`sum()`、`float()`、`eval()`、`open()`、`id()`、`type()`、`file()`和其他内置函数也是如此。'
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Suppose that `a` and `b` are integers. What does the following sequence of statements
    do? Draw an object-level trace of this computation.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`a`和`b`是整数。以下语句序列做什么？绘制该计算的对象级跟踪。
- en: '[PRE6]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Solution*: The sequence sets `a`, `b`, and `t` to the original value of `a`.'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* 该序列将`a`、`b`和`t`设置为`a`的原始值。'
- en: Compose a program that uses `math.sin()` and `math.cos()` to check that the
    value of *cos² θ + sin² θ* is approximately `1.0` for any θ entered as a command-line
    argument. Just write the value. Why are the values not always exactly `1.0`?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用`math.sin()`和`math.cos()`来检查对于任何作为命令行参数输入的θ，*cos² θ + sin² θ*的值是否大约为`1.0`。只需写出值。为什么这些值不总是完全等于`1.0`？
- en: '*Solution (from Hassan Alam and Lee Jong Gil):*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案（来自Hassan Alam和Lee Jong Gil）：*'
- en: '[PRE7]'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose that `a` and `b` are booleans. Show that this expression evaluates
    to `True`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`a`和`b`是布尔值。展示这个表达式的计算结果为`True`：
- en: '[PRE8]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Suppose that `a` and `b` are integers. Simplify the following expression:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`a`和`b`是整数。简化以下表达式：
- en: '[PRE9]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Solution:* `a == b`'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* `a == b`'
- en: What does each of these statements write? Explain each outcome.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个语句会写入什么？解释每个结果。
- en: '[PRE10]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Explain how to use [quadratic.py](quadratic.py.html) to find the square root
    of a number.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释如何使用[quadratic.py](quadratic.py.html)来找到一个数的平方根。
- en: '*Solution:* To find the square root of `c`, find the roots of `x² + 0x - c`.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* 要找到`c`的平方根，找到`x² + 0x - c`的根。'
- en: What does `stdio.writeln((1.0 + 2 + 3 + 4) / 4)` write?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stdio.writeln((1.0 + 2 + 3 + 4) / 4)`会写入什么？'
- en: Suppose that `a` is `3.14159`. What do each of these statements write? Explain
    each outcome.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`a`是`3.14159`。每个语句会写入什么？解释每个结果。
- en: '[PRE11]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Describe the effect of writing `sqrt` instead of `math.sqrt` in [quadratic.py](quadratic.py.html).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述在[quadratic.py](quadratic.py.html)中写入`sqrt`而不是`math.sqrt`的效果。
- en: Does (math.sqrt(2) * math.sqrt(2) == 2) evaluate to True or False?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(math.sqrt(2) * math.sqrt(2) == 2)`的计算结果是True还是False？'
- en: Compose a program that takes two positive integers as command-line arguments
    and writes `True` if either evenly divides the other.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取两个正整数，如果其中一个可以整除另一个，则写入`True`。
- en: 'Compose a program that takes three positive integers as command-line arguments
    and writes `False` if any one of them is greater than or equal to the sum of the
    other two and `True` otherwise. (Note: This computation tests whether the three
    numbers could be the lengths of the sides of some triangle.)'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取三个正整数，并在任何一个大于或等于另外两个之和时写入`False`，否则写入`True`。（注意：这个计算测试这三个数字是否可以是某个三角形的边长。）
- en: 'Give the value of `a` after the execution of each of the following sequences:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行以下序列后，`a`的值是多少：
- en: '[PRE12]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A physics student gets unexpected results when using the code
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个物理学生在使用代码时得到了意外的结果
- en: '[PRE13]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: to compute values according to the formula *F = Gm[1]m[2] / r²*. Explain the
    problem and correct the code.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据公式*F = Gm[1]m[2] / r²*计算值。解释问题并纠正代码。
- en: '*Solution:* The code divides by `r`, and then multiplies by `r`. Instead it
    should divide by `r` squared. Use parentheses:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* 代码除以`r`，然后乘以`r`。实际上应该除以`r`的平方。使用括号：'
- en: '[PRE14]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or use the exponentiation operator:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者使用乘方运算符：
- en: '[PRE15]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or, better still for the sake of clarity, use both parentheses and the exponentiation
    operator:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，为了更清晰起见，同时使用括号和乘方运算符：
- en: '[PRE16]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Suppose that `x` and `y` are two floats that represent the Cartesian coordinates
    of a point *(x, y)* in the plane. Give an expression that evaluates to the distance
    of the point from the origin.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`x`和`y`是表示平面上点*(x, y)*的两个浮点数。给出一个表达式，计算出点到原点的距离。
- en: '*Solution:* `math.sqrt(x*x + y*y)`'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* `math.sqrt(x*x + y*y)`'
- en: Compose a program that takes two integers `a` and `b` from the command line
    and writes a random integer between `a` and `b`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取两个整数`a`和`b`，然后写入一个介于`a`和`b`之间的随机整数。
- en: Compose a program that writes the sum of two random integers between 1 and 6
    (such as you might get when rolling dice).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，写入两个介于1和6之间的随机整数的和（例如掷骰子时可能得到的值）。
- en: '*Solution*: See [sumoftwodice.py](sumoftwodice.py.html).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案:* 参见[sumoftwodice.py](sumoftwodice.py.html)。'
- en: Compose a program that takes a float `t` from the command line and writes the
    value of *sin(2t) + sin(3t)*.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取一个浮点数`t`，然后写入*sin(2t) + sin(3t)*的值。
- en: 'Compose a program that takes three floats *x[0]*, *v[0]*, and *t* from the
    command line, evaluates *x[0] + v[0]t - Gt² / 2*, and writes the result. (*Note*:
    *G* is the constant 9.80665\. This value is the displacement in meters after *t*
    seconds when an object is thrown straight up from initial position *x[0]* at velocity
    *v[0]* meters per second.)'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取三个浮点数*x[0]*、*v[0]*和*t*，计算*x[0] + v[0]t - Gt² / 2*的值，并写入结果。（*注意*：*G*是常数9.80665。这个值是物体从初始位置*x[0]*以速度*v[0]*米每秒向上抛出后*t*秒后的位移。）
- en: Compose a program that takes two integers `m` and `d` from the command line
    and writes `True` if day *d* of month *m* is between March 20 and June 20, and
    False otherwise. (Interpret *m* with 1 for January, 2 for February, and so forth.)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取两个整数`m`和`d`，如果月份`m`的第`d`天在3月20日和6月20日之间，则写入`True`，否则写入`False`。（将`m`解释为1代表一月，2代表二月，依此类推。）
- en: '*Solution*: See [spring.py](spring.py.html).'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* 参见[spring.py](spring.py.html)。'
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Continuously compounded interest.** Compose a program that calculates and
    writes the amount of money you would have if you invested it at a given interest
    rate compounded continuously, taking the number of years *t*, the principal *P*,
    and the annual interest rate *r* as commmand-line arguments. The desired value
    is given by the formula *pe^(rt)*.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连续复利。** 编写一个程序，计算并写出以给定利率连续复利投资后的金额，将年数*t*、本金*P*和年利率*r*作为命令行参数。所需值由公式*pe^(rt)*给出。'
- en: '**Wind chill.** Given the temperature *t* (in Fahrenheit) and the wind speed
    *v* (in miles per hour), the National Weather Service defines the effective temperature
    (the [wind chill](http://www.nws.noaa.gov/om/windchill/index.shtml)) to be:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**风寒。** 给定温度*t*（华氏度）和风速*v*（英里/小时），国家气象局定义有效温度��[风寒](http://www.nws.noaa.gov/om/windchill/index.shtml)）为：'
- en: '| *w* = 35.74 + 0.6215 *t* + (0.4275 *t* - 35.75) *v*^(0.16) |'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *w* = 35.74 + 0.6215 *t* + (0.4275 *t* - 35.75) *v*^(0.16) |'
- en: 'Compose a program that takes two floats `t` and `v` from the command-line and
    writes the wind chill. *Note*: the formula is not valid if *t* is larger than
    50 in absolute value or if *v* is larger than 120 or less than 3 (you may assume
    that the values you get are in that range).'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行接受两个浮点数`t`和`v`，并写出风寒。*注意*：如果*t*的绝对值大于50或者*v*大于120或小于3，则该公式无效（您可以假设您得到的值在这个范围内）。
- en: '*Solution*: See [windchill.py](windchill.py.html).'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[windchill.py](windchill.py.html)。'
- en: '![Polar](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Polar](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)'
- en: '**Polar coordinates.** Compose a program that converts from Cartesian to [polar
    coordinates](http://mathworld.wolfram.com/PolarCoordinates.html). Your program
    should accept two floats `x` and `y` from the command-line and write the polar
    coordinates *r* and *θ*. Use the Python function `math.atan2(y, x)`, which computes
    the arctangent value of *y/x* that is in the range from *-π* to `π`.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**极坐标。** 编写一个程序，将笛卡尔坐标转换为[极坐标](http://mathworld.wolfram.com/PolarCoordinates.html)。您的程序应该从命令行接受两个浮点数`x`和`y`，并写出极坐标*r*和*θ*。使用Python函数`math.atan2(y,
    x)`，计算*y/x*的反正切值，范围为*-π*到`π`。'
- en: '*Solution*: See [polar.py](polar.py.html).'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[polar.py](polar.py.html)。'
- en: '**Gaussian random numbers.** One way to generate a random number taken from
    the Gaussian distribution is to use the *Box-Muller* formula:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高斯随机数。** 生成服从高斯分布的随机数的一种方法是使用*Box-Muller*公式：'
- en: '| *Z* = sin(2 π *v*) (-2 ln *u*)^(1/2) |'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *Z* = sin(2 π *v*) (-2 ln *u*)^(1/2) |'
- en: where *u* and *v* are real numbers between 0 and 1 generated by the `random.random()`
    function. Compose a program that writes a standard Gaussian random variable.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中*u*和*v*是由`random.random()`函数生成的0到1之间的实数。编写一个程序，写出一个标准高斯随机变量。
- en: '**Order check.** Compose a program that takes three floats `x`, `y`, and `z`
    as command-line arguments and writes `True` if the values are strictly ascending
    or descending (`x < y < z` or `x > y > z`), and `False` otherwise.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顺序检查。** 编写一个程序，将三个浮点数`x`、`y`和`z`作为命令行参数，并在值严格递增或递减（`x < y < z`或`x > y > z`）时写出`True`，否则写出`False`。'
- en: '**Day of the week.** Compose a program that accepts a date as input and writes
    the day of the week on which that date falls. Your program should accept three
    command-line arguments: `m` (month), `d` (day), and `y` (year). For `m` use 1
    for January, 2 for February, and so forth. For output write 0 for Sunday, 1 for
    Monday, 2 for Tuesday, and so forth. Use the following [formulas for the Gregorian
    calendar](https://www.tondering.dk/claus/cal/julperiod.php):'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**星期几。** 编写一个程序，接受日期作为输入，并写出该日期所在的星期几。您的程序应该接受三个命令行参数：`m`（月份），`d`（日期）和`y`（年份）。对于`m`，使用1表示一月，2表示二月，依此类推。对于输出，写出0表示星期日，1表示星期一，2表示星期二，依此类推。使用以下[公历日历公式](https://www.tondering.dk/claus/cal/julperiod.php)：'
- en: '| *y[0]* = *y* - (14 - *m*) / 12 *x* = *y[0]* + *y[0]/4* - *y[0]*/100 + *y[0]*/400'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| *y[0]* = *y* - (14 - *m*) / 12 *x* = *y[0]* + *y[0]/4* - *y[0]*/100 + *y[0]*/400'
- en: '*m[0]* = *m* + 12 * ((14 - *m*) / 12) - 2'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*m[0]* = *m* + 12 * ((14 - *m*) / 12) - 2'
- en: '*d[0]* = (*d* + *x* + (31**m[0]*)/ 12) mod 7 |'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*d[0]* = (*d* + *x* + (31**m[0]*)/ 12) mod 7 |'
- en: For example, on what day of the week was August 2, 1953?
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，1953年8月2日是星期几？
- en: '| *y* = 1953 - 0 = 1953 *x* = 1953 + 1953/4 - 1953/100 + 1953/400 = 2426'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| *y* = 1953 - 0 = 1953 *x* = 1953 + 1953/4 - 1953/100 + 1953/400 = 2426'
- en: '*m* = 8 + 12*0 - 2 = 6'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*m* = 8 + 12*0 - 2 = 6'
- en: '*d* = (2 + 2426 + (31*6) / 12) mod 7 = 2443 mod 7 = 0 (Sunday)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*d* = (2 + 2426 + (31*6) / 12) mod 7 = 2443 mod 7 = 0 (星期日)'
- en: '|'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|'
- en: '*Solution*: See [day.py](day.py.html).'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[day.py](day.py.html)。'
- en: '**Uniform random numbers.** Compose a program that writes five uniform random
    floats between 0 and 1, their average value, and their minimum and maximum value.
    Use the built-in `max()` and `min()` functions.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**均匀随机数。** 编写一个程序，写出五个介于0和1之间的均匀随机浮点数，它们的平均值以及最小值和最大值。使用内置的`max()`和`min()`函数。'
- en: '*Solution*: See [stats1.py](stats1.py.html).'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[stats1.py](stats1.py.html)。'
- en: '**Mercator projection.** The [Mercator projection](http://en.wikipedia.org/wiki/Mercator_projection)
    is a conformal (angle preserving) projection that maps latitude *φ* and longitude
    *λ* to rectangular coordinates *(x, y)*. It is widely used — for example, in nautical
    charts and in the maps that you print from the web. The project is defined by
    the equations:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**墨卡托投影。** [墨卡托投影](http://en.wikipedia.org/wiki/Mercator_projection)是一种保角（保持角度）投影，将纬度*φ*和经度*λ*映射到矩形坐标*(x,
    y)*。它被广泛使用，例如在航海图和从网络打印的地图中。该投影由以下方程定义：'
- en: '| *x* = λ - λ[0] *y* = 1/2 * ln((1 + sin(φ)) / (1 - sin(φ))) |'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| *x* = λ - λ[0] *y* = 1/2 * ln((1 + sin(φ)) / (1 - sin(φ))) |'
- en: where λ[0] is the longitude of the point in the center of the map. Compose a
    program that accepts λ[0] and the latitude and longitude of a point from the command
    line and writes its projection.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其中λ[0]是地图中心点的经度。编写一个程序，接受λ[0]以及从命令行接受的点的纬度和经度，并写出其投影。
- en: '**Color conversion.** Several different formats are used to represent color.
    For example, the primary format for LCD displays, digital cameras, and web pages,
    known as the RGB format, specifies the level of red (R), green (G), and blue (B)
    on an integer scale from 0 to 255\. The primary format for publishing books and
    magazines, known as the CMYK format, specifies the level of cyan (C), magenta
    (M), yellow (Y), and black (K) on a real scale from 0.0 to 1.0\. Compose a program
    that converts RGB to CMYK. Accept three integers —r, g, and b —from the command
    line and write the equivalent CMYK values. If the RGB values are all 0, then the
    CMY values are all 0 and the K value is 1; otherwise, use these formulas:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**颜色转换。** 有几种不同的格式用于表示颜色。例如，LCD 显示器、数码相机和网页的主要格式，称为 RGB 格式，指定了红色（R）、绿色（G）和蓝色（B）的级别，范围从
    0 到 255 的整数。出版书籍和杂志的主要格式，称为 CMYK 格式，指定了青色（C）、品红色（M）、黄色（Y）和黑色（K）的级别，范围从 0.0 到 1.0
    的实数。编写一个程序，将 RGB 转换为 CMYK。从命令行接受三个整数 —— r、g 和 b —— 并写入相应的 CMYK 值。如果 RGB 值都为 0，则
    CMY 值都为 0，K 值为 1；否则，使用以下公式：'
- en: '| *w* = max(*r*/255, *g*/255, *b*/255) |'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *w* = max(*r*/255, *g*/255, *b*/255) |'
- en: '| *c* = (*w* - *r*/255) / *w* |'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *c* = (*w* - *r*/255) / *w* |'
- en: '| *m* = (*w* - *g*/255) / *w* |'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *m* = (*w* - *g*/255) / *w* |'
- en: '| *y* = (*w* - *b*/255) / *w* |'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *y* = (*w* - *b*/255) / *w* |'
- en: '| *k* = 1 - *w* |'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *k* = 1 - *w* |'
- en: 'Here''s an example run:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个示例运行：
- en: '[PRE17]'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Great Circle](../Images/13904e699cc9ff92fd2aa41c22eda0b4.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![大圆](../Images/13904e699cc9ff92fd2aa41c22eda0b4.png)'
- en: '**Great circle.** Compose a program that takes four float command-line arguments
    `x1`, `y1`, `x2`, and `y2` (the latitude and longitude, in degrees, of two points
    on the earth) and writes the great-circle distance between them. The great-circle
    distance `d` (in nautical miles) is given by the formula derived from the law
    of cosines:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大圆。** 编写一个程序，接受四个浮点命令行参数 `x1`、`y1`、`x2` 和 `y2`（地球上两点的纬度和经度，以度为单位），并计算它们之间的大圆距离。大圆距离
    `d`（以海里为单位）由根据余弦定理推导的公式给出：'
- en: '| *d = 60 * arccos(sin(x[1]) * sin(x[2]) + cos(x[1]) * cos(x[2]) * cos(y[1]
    - y[2]))* |'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *d = 60 * arccos(sin(x[1]) * sin(x[2]) + cos(x[1]) * cos(x[2]) * cos(y[1]
    - y[2]))* |'
- en: Note that this equation uses degrees, whereas Python's trigonometric functions
    use radians. Use `math.radians()` and `math.degrees()` to convert between the
    two. Use your program to compute the great-circle distance between Paris (48.87°
    N, -2.33° W) and San Francisco (37.8° N, 122.4° W).
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，此方程式使用的是度数，而 Python 的三角函数使用的是弧度。使用 `math.radians()` 和 `math.degrees()` 在两者之间进行转换。使用您的程序计算巴黎（48.87°
    N，-2.33° W）和旧金山（37.8° N，122.4° W）之间的大圆距离。
- en: 'Note: the shape of the earth is more like a flattened spheroid than a sphere,
    so the formula above is only an approximation (up to around 0.5% error). Also,
    this formula is [unreliable for small distances](http://www.movable-type.co.uk/scripts/GIS-FAQ-5.1.html)
    because the inverse cosine function is ill-conditioned.'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：地球的形状更像是一个扁平的椭球体，而不是一个球体，因此上面的公式只是一个近似值（误差约为 0.5%）。此外，这个公式对于小距离是[不可靠的](http://www.movable-type.co.uk/scripts/GIS-FAQ-5.1.html)，因为反余弦函数是病态的。
- en: 'Here is the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula):'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是[Haversine公式](http://en.wikipedia.org/wiki/Haversine_formula)：
- en: '| *a = sin²((L2-L1)/2) + cos(L1) * cos(L2) * sin²((G2-G1)/2) c = 2 * arcsin(min(1,
    sqrt(a))) # distance in radians distance = 60 * c # nautical miles* |'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *a = sin²((L2-L1)/2) + cos(L1) * cos(L2) * sin²((G2-G1)/2) c = 2 * arcsin(min(1,
    sqrt(a))) # 以弧度表示的距离 distance = 60 * c # 海里* |'
- en: The Haversine formula is accurate for most distances, but it suffers from rounding
    errors when the points are (nearly) antipodal. The following [formula](http://en.wikipedia.org/wiki/Great-circle_distance#The_formula)
    is accurate for all distances.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Haversine 公式对大多数距离是准确的，但当点（几乎）是对极点时，会出现舍入误差。以下[公式](http://en.wikipedia.org/wiki/Great-circle_distance#The_formula)对所有距离都是准确的。
- en: '| *delta = G1 - G2 p1 = cos(L2) * sin(delta) p2 = cos(L1) * sin(L2) - sin(L1)
    * cos(L2) * cos(delta) p3 = sin(L1) * sin(L2) + cos(L1) * cos(L2) * cos(delta)
    distance = 60 * atan2(sqrt(p1*p1 + p2*p2), p3)* |'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *delta = G1 - G2 p1 = cos(L2) * sin(delta) p2 = cos(L1) * sin(L2) - sin(L1)
    * cos(L2) * cos(delta) p3 = sin(L1) * sin(L2) + cos(L1) * cos(L2) * cos(delta)
    distance = 60 * atan2(sqrt(p1*p1 + p2*p2), p3)* |'
- en: This [Kahan reference](http://www.cs.berkeley.edu/~wkahan/Math128/angle.pdf)
    provides more details.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的[Kahan参考](http://www.cs.berkeley.edu/~wkahan/Math128/angle.pdf)提供了更多细节。
- en: '*Solution*: See [greatcircle.py](greatcircle.py.html).'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[大圆.py](greatcircle.py.html)。'
- en: '**Three-sort.** Compose a program that accepts three integers from the command
    line and writes them in ascending order. Use the built-in `min()` and `max()`
    functions.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三排序。** ��写一个程序，从命令行接受三个整数，并按升序写出它们。使用内置的 `min()` 和 `max()` 函数。'
- en: '*Solution*: See [threesort.py](threesort.py.html).'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[三排序.py](threesort.py.html)。'
- en: '![Dragon curves](../Images/b939c3d8907b68a54c185cc9b3b899d8.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![龙曲线](../Images/b939c3d8907b68a54c185cc9b3b899d8.png)'
- en: '**Dragon curve.** Compose a program to write the instructions for drawing the
    [dragon curves](http://www.jimloy.com/fractals/dragon.htm) of order 0 through
    5\. The instructions are strings of the characters `F`, `L`, and `R`, where `F`
    means "draw line while moving 1 unit forward", `L` means "turn left", and `R`
    means turn right. A dragon curve of order `n` is formed when you fold a strip
    of paper in half `n` times, then unfold to right angles. The key to solving this
    problem is to note that a curve of order *n* is a curve of order *n-1* followed
    by an *L* followed by a curve of order *n-1* traversed in reverse order, and then
    to figure out a similar description of the reverse curve.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**龙曲线。** 编写一个程序，以绘制[龙曲线](http://www.jimloy.com/fractals/dragon.htm)的指令，从 0
    到 5 阶。指令是由字符 `F`、`L` 和 `R` 组成的字符串，其中 `F` 表示“向前移动 1 个单位时画线”，`L` 表示“向左转”，`R` 表示向右转。当您将一条纸折叠
    n 次，然后展开成直角时，就形成了 n 阶龙曲线。解决这个问题的关键是注意到 n 阶曲线是 n-1 阶曲线后跟一个 *L*，然后是以相反顺序遍历的 n-1
    阶曲线，然后找出相反曲线的类似描述。'
- en: '*Solution*: See [dragon1.py](dragon1.py.html).'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[龙1.py](dragon1.py.html)。'
