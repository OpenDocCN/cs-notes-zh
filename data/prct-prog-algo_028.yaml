- en: 5.3   Universality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 通用性
- en: 原文：[https://introcs.cs.princeton.edu/java/53universality](https://introcs.cs.princeton.edu/java/53universality)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/53universality](https://introcs.cs.princeton.edu/java/53universality)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在大力施工中。
- en: One of the crowning scientific achievements of the 20th century was formalizing
    the notion of *computation*. In this section we address the fundamental question
    of what is computable in this Universe. Surprising revelation of 20th century
    is that a general purpose computer is capable of performing any computation that
    any other computer can. Perhaps the most important idea in all of computer science.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪最重要的科学成就之一是形式化*计算*的概念。在本节中，我们探讨了这个宇宙中什么是可计算的这个基本问题。20世纪的惊人发现是，通用计算机能够执行任何其他计算机可以执行的计算。也许这是计算机科学中最重要的思想。
- en: Disruptive technology which ignited the Computer Revolution. Universality helps
    explain the rapid adoption of the World Wide Web. People already used computers
    for number crunching and word processing prior to existence of Web. Universal
    computer was easily adaptable to dealing with Web protocols, MP3 files, and digital
    photos. Once technology become available, people could immediately harness its
    power. (Much slower adoption during Industrial Revolution, etc.) "One could hardly
    imagine an analogue of this process for the television - it would be as though
    millions of Americans had been induced to buy large inert boxes for their living
    rooms, and a decade later someone dreamed up the technology to begin broadcasting
    pictures to them. But this is more or less what happened with the Web." (Kleinberg-Papadimitriou)
    We can only imagine what new technologies will emerge in the next few decades,
    but we can be certain that our universal computer will be capable of taking full
    advantage of it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 点燃计算机革命的颠覆性技术。通用性有助于解释世界各地网页的快速采用。在Web存在之前，人们已经使用计算机进行数字计算和文字处理。通用计算机很容易适应处理Web协议、MP3文件和数字照片。一旦技术可用，人们就可以立即利用其力量。（工业革命等过程采用速度较慢。）“很难想象电视的这个过程的类比
    - 就好像数百万美国人被诱使购买他们客厅里的大型惰性盒子，十年后有人梦想出开始向他们广播图片的技术。但这与Web发生的情况差不多。”（Kleinberg-Papadimitriou）我们只能想象未来几十年会出现什么新技术，但我们可以肯定我们的通用计算机将能够充分利用它。
- en: 'No need for separate machines for processing images and text. One universal
    machine for all tasks. This is in stark contrast to most other areas. For example,
    there is no all-purpose universal cooking device. Instead we have separate pieces
    of equipment for slicing, blending, mixing, baking, boiling, grilling, roasting,
    toasting, brewing, and radiating. One possible exception in the natural sciences:
    genome (can change a few symbols in the genome and create a new organism, much
    like writing a new computer program).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要单独的机器来处理图像和文本。一个通用机器适用于所有任务。这与大多数其他领域形成鲜明对比。例如，没有通用的烹饪设备。相反，我们有用于切片、混合、搅拌、烘烤、煮沸、烤、烤面包、烘烤、酿造和辐射的单独设备。在自然科学中可能有一个例外：基因组（可以改变基因组中的几个符号并创建新的生物体，就像编写新的计算机程序一样）。
- en: 'Many different types of computational devices: Cray supercomputer, Dell PC,
    iMac, Palm Pilot, XBox, Tivo, Turing machine, TOY machine, Java programming language,
    Microsoft Excel, Java cell phone, quantum Turing machine, Perl programming language.
    Is there any fundamental difference between what these things can do and what
    a Gaggia espresso maker can do?'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同类型的计算设备：Cray超级计算机、戴尔个人电脑、iMac、Palm Pilot、XBox、Tivo、图灵机、TOY机、Java编程语言、Microsoft
    Excel、Java手机、量子图灵机、Perl编程语言。这些东西能做的事情与Gaggia浓缩咖啡机能做的事情有根本区别吗？
- en: Turing machines are equivalent in power to TOY and Java. Can simulate any Turing
    machine with a Java program, can simulate TOY with a Turing machine, can simulate,
    Java with a TOY machine. Same idea works for C, C++, C#, Python, Excel, Outlook.
    Also Mac, PC, Cray, ENIAC, Konrad Zuse's Z3 (but not proved until 1998), Palm
    pilot. And TiVo, Xbox, Java cell phone/ But not DFA, Gaggia espresso maker, or
    this [Tinker Toy computer](http://www.rci.rutgers.edu/~cfs/472_html/Intro/TinkertoyComputer/TinkerToy.html)
    that MIT students built to play Tic-Tac-Toe.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机在功能上等同于TOY和Java。可以用Java程序模拟任何图灵机，可以用图灵机模拟TOY，可以用TOY机模拟Java。同样的想法适用于C、C++、C#、Python、Excel、Outlook。还有Mac、PC、Cray、ENIAC、康拉德·祖斯的Z3（但直到1998年才被证明）、Palm
    pilot。还有TiVo、Xbox、Java手机/但不包括DFA、Gaggia浓缩咖啡机，或者MIT学生们为了玩井字游戏而制作的[Tinker Toy计算机](http://www.rci.rutgers.edu/~cfs/472_html/Intro/TinkertoyComputer/TinkerToy.html)。
- en: There is an implicit assumption that the TOY machine and the Java programming
    language have an unbounded amount of memory (*extensible storage*). Otherwise
    the TM is strictly more powerful. Is this assumption reasonable? If infinity scares
    you, you could think of having a service contract. If you need more memory, you
    just go out and order some more over the Internet. We implicitly think of stack/queue
    as infinite, even though memory will eventually run out. The Turing machine is
    a model of computing, not of computers. Thus, we do not restrict the size of the
    machine's tape.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: TOY机和Java编程语言有一个无限的存储量（*可扩展存储*）的隐含假设。否则，TM就会严格更强大。这个假���合理吗？如果无限让你感到恐惧，你可以考虑签订服务合同。如果需要更多内存，你只需上网订购一些。我们默认认为栈/队列是无限的，尽管内存最终会用完。图灵机是计算的模型，而不是计算机的模型。因此，我们不限制机器带的磁带的大小。
- en: 'Java programs are written to handle inputs of any length. You may not be able
    to execute the program with a large input on a machine with limited memory, but
    you can execute the program on a machine with a larger memory. Turing machines
    model programs, rather than machines: the existence of a fast Java program for
    a given problem is equivalent to the existence of a fast Turing machine for the
    same problem.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序编写为处理任意长度的输入。您可能无法在内存有限的计算机上执行大输入的程序，但您可以在内存更大的计算机上执行该程序。图灵机模拟程序，而不是机器：对于给定问题存在一个快速的Java程序等价于存在一个相同问题的快速图灵机。
- en: 'Informally, an *algorithm* is a step-by-step procedure for solving a problem.
    Formally, we define an algorithm as a Turing machine. Each Turing machine is capable
    of performing a single algorithm, e.g., testing whether an integer is prime. In
    this sense, Turing machines are analogous to computer programs (software) rather
    than computers (hardware). Knuth: "An algorithm is an abstract concept unrelated
    to physical laws of the universe." This means that we might need to build a separate
    Turing machine for each algorithm that we would like to execute. This is highly
    impractical!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，*算法*是解决问题的逐步过程。形式上，我们将算法定义为图灵机。每个图灵机能够执行单个算法，例如，测试一个整数是否为质数。在这个意义上，图灵机类似于计算机程序（软件）而不是计算机（硬件）。Knuth：“算法是与宇宙物理定律无关的抽象概念。”这意味着我们可能需要为我们想要执行的每个算法构建一个单独的图灵机。这是非常不切实际的！
- en: '**Universal Turing machine.**  A [Universal Turing machine](http://mathworld.wolfram.com/UniversalTuringMachine.html)
    is a specific Turing machine that can simulate the behavior of any Turing machine
    (including itself!). This enables a Turing machine to answer questions about other
    Turing machines (or itself). Alan Turing described such a machine: its existence
    means that there is a single Turing machine, the UTM, that is capable of running
    any algorithm. The key idea is to think of the description of a Turing machine
    itself as data. For example, we can encode the Turing machine illustrated below'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用图灵机。**  [通用图灵机](http://mathworld.wolfram.com/UniversalTuringMachine.html)是一种特定的图灵机，可以模拟任何图灵机的行为（包括自身！）。这使得图灵机能够回答关于其他图灵机（或自身）的问题。艾伦·图灵描述了这样一台机器：它的存在意味着有一台单独的图灵机，即UTM，能够运行任何算法。关键思想是将图灵机的描述本身视为数据。例如，我们可以对下面所示的图灵机进行编码'
- en: '![Turing machine for equal number of 0''s and 1''s](../Images/8e84ff66123059347fdbfffa2111b494.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![0和1数量相等的图灵机](../Images/8e84ff66123059347fdbfffa2111b494.png)'
- en: with a table as follows. We label each of the five states 0 to 5. We include
    a row for the index of each state along with its label (left, right, yes, no,
    or halt). We include a row of four symbols for each transition arrow to denote
    the current state, input symbol, next state, and write symbol, respectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其中包含以下表格。我们将每个状态标记为0到5。我们为每个转换箭头包括一个行，用于表示每个状态的索引以及其标签（左、右、是、否或停止）。我们为每个转换箭头包括一行四个符号，分别表示当前状态、输入符号、下一个状态和写入符号。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can concatenate the table into a single string over the alphabet {0,
    1, 2, 3, 4, 5, x, #}.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们可以将表连接成一个关于字母表{0, 1, 2, 3, 4, 5, x, #}的单个字符串。'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and initialize the tape with this input. Since the original Turing machine itself
    also has an input, e.g., the integer whose primality we want to check, we append
    this input to the end of the Turing machine description, separating it by a new
    symbol.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并用这个输入初始化磁带。由于原始图灵机本身也有一个输入，例如，我们想要检查其质数性质的整数，我们将这个输入附加到图灵机描述的末尾，用一个新符号分隔。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We might also append the start state and the initial position of the tape head.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以附加起始状态和磁带头的初始位置。
- en: A *universal Turing machine* takes as input the description of a Turing machine
    (along with the initial tape contents of the Turing machine), and simulates the
    input on that Turing machine. Thus, the UTM can simulate the behavior of any individual
    TM. In modern terms, the UTM is an *interpreter* - it performs a step-by-step
    simulation of any Turing machine. Program and data are the same thing - a program
    (Turing machine) is nothing more than a sequence of symbols that looks like any
    other data. When input to a UTM, the program "becomes alive" and begins to compute.
    (similar for downloading programs from the Web and email viruses - just data until
    you double-click them and feed them to your operating system for execution).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用图灵机*接受图灵机的描述作为输入（以及图灵机的初始磁带内容），并在该图灵机上模拟输入。因此，通用图灵机可以模拟任何单个TM的行为。用现代术语来说，通用图灵机是一个*解释器*
    - 它对任何图灵机进行逐步模拟。程序和数据是一回事 - 程序（图灵机）只不过是一个看起来像其他数据的符号序列。当输入到通用图灵机时，程序“变得活跃”并开始计算。（从Web下载程序和电子邮件病毒类似
    - 只是数据，直到你双击它们并将它们提供给操作系统执行）。'
- en: Building such a UTM appears to be a daunting task. Alan Turing described the
    first such Turing machine in his 1937 paper. In 1962, Minsky discovered a remarkable
    7-state UTM that executes using a four symbol alphabet, but it is rather complicated
    to describe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 建立这样一个通用图灵机似乎是一项艰巨的任务。艾伦·图灵在他的1937年论文中描述了第一台这样的图灵机。1962年，明斯基发现了一台使用四个符号字母表执行的令人惊奇的7状态UTM，但描述起来相当复杂。
- en: '**General purpose computers.**   First articulated by Ada Lovelace. She described
    Babbage''s Analytic Engine as suited for "developing and tabulating any function
    whatever... the engine [is] the material expression of any indefinite function
    of any degree of generality and complexity." She described its use for to scientific
    computing, including trigonometric functions and Bernoulli numbers. She also championed
    the idea that it could be used to produce music and graphics. General purpose
    computers are analogous to universal Turing machines: they are capable of running
    different algorithms without requiring any hardware modifications. This is possible
    because modern day microprocessors are based upon the *von Neumann architecture*.
    In this model, computer programs and data are stored in the same main memory.
    This means that the contents of memory can be treated as a machine instruction
    or data, depending on the context. This is exactly analogous to the tape contents
    of the UTM which consists of both a program (the original TM) and its data (the
    tape contents of the original TM). Alan Turing''s work on UTM anticipated the
    development of general purpose computers, and can be viewed as the invention of
    software!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用计算机。** 首次由艾达·洛芙莱斯（Ada Lovelace）阐述。她将巴贝奇的分析引擎描述为适合“开发和制表任何函数...引擎[是]任何不确定性功能的材料表达，无论其一般性和复杂性程度如何。”她描述了它在科学计算中的用途，包括三角函数和伯努利数。她还提倡它可以用于制作音乐和图形。通用计算机类似于通用图灵机：它们能够运行不同的算法，而无需进行任何硬件修改。这是可能的，因为现代微处理器基于*冯·诺伊曼结构*。在这种模型中，计算机程序和数据存储在同一主存储器中。这意味着内存内容可以视为机器指令或数据，取决于上下文。这与UTM的磁带内容完全类似，其中包含程序（原始TM）和数据（原始TM的磁带内容）。艾伦·图灵关于UTM的工作预示了通用计算机的发展，并可以看作是软件的发明！'
- en: Church-Turing thesis.
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丘奇-图灵论题。
- en: 'In 1936, Alonzo Church and Alan Turing independently proposed models of computation
    that they believed embodied the notion of computation by a mechanic procedure.
    Church invented the [lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus)
    to study notions of computability while Turing used his Turing machines. Although
    both models appear very different from one another, Turing later showed that were
    equivalent in that they each pick out the same set of mathematical functions.
    They arrived at the same conclusion, which we express in terms of Turing machines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 1936年，阿隆佐·丘奇（Alonzo Church）和艾伦·图灵（Alan Turing）独立提出了计算模型，他们认为这些模型体现了机械过程的计算概念。丘奇发明了[λ演算](http://en.wikipedia.org/wiki/Lambda_calculus)来研究可计算性概念，而图灵则使用他的图灵机。尽管这两种模型看起来非常不同，但图灵后来证明它们是等价的，因为它们都选择了相同的数学函数集。他们得出了相同的结论，我们用图灵机的术语表达：
- en: '*Turing machines can do anything that can be described by a purely mechanical
    process.*'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*图灵机可以执行任何可以用纯机械过程描述的事情。*'
- en: In other words, any process that can be performed by an idealized mathematician
    can be simulated on a Turing machine. This thesis was subsequently extended to
    assert that all (physically harnessable) processes of the universe can be simulated
    by a Turing machine, and this is the version we will consider as the Church-Turing
    thesis. This reduces the study of computation to the study of Turing machines,
    rather than an infinite number of potential computing devices. It means that we
    don't have to seek more powerful machines; our only recourse is to exploit the
    power of existing machines or create new machines that do things faster. The converse
    of the thesis also has profound consequences. It says that if something can't
    be done on a Turing machine, then we can't do it using any purely mechanical process.
    We will explore the consequences in Section 7.6 when we discover that there are
    some problems that Turing machines can't solve. Note that the Church-Turing thesis
    is not a mathematical statement, and is not subject to rigorous proof. It is a
    statement about the physically realizable universe. However, like any good scientific
    theory, the Church-Turing thesis is subject to refutation. If someone exhibited
    a strictly more powerful model of computation that was physically harnessable,
    we would dismiss the Church-Turing thesis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何理想数学家可以执行的过程都可以在图灵机上模拟。随后，这个论题被扩展为断言宇宙中所有（物理上可利用的）过程都可以由图灵机模拟，这是我们将考虑的丘奇-图灵论题的版本。这将计算研究简化为图灵机的研究，而不是无限数量的潜在计算设备。这意味着我们不必寻找更强大的机器；我们唯一的选择是利用现有机器的能力或创建新的能够更快地完成任务的机器。这个论题的逆命题也具有深远的影响。它表明，如果某件事在图灵机上无法完成，那么我们无法使用任何纯机械过程来完成它。当我们发现有些问题图灵机无法解决时，我们将在第7.6节探讨其后果。请注意，丘奇-图灵论题不是一个数学命题，也不受严格证明的约束。它是关于现实可实现宇宙的陈述。然而，像任何良好的科学理论一样，丘奇-图��论题也可能被推翻。如果有人展示了一个严格更强大的计算模型，而且这个模型是物理上可利用的，我们将否定丘奇-图灵论题。
- en: The thesis is equivalent to saying that any general-purpose programming language
    is sufficient to express any algorithm.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论题等同于说任何通用编程语言都足以表达任何算法。
- en: '**Universality.**  The Church-Turing thesis implies a *universality* among
    different models of computation. There is ample support suggesting this universality.
    Adding new capabilities to a Turing machine does not make it more powerful in
    terms of the languages it can accept or the functions it can compute.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**普适性。** 丘奇-图灵论题暗示了不同计算模型之间的*普适性*。有大量支持表明这种普适性。向图灵机添加新功能并不会使其在接受的语言或计算的函数方面更强大。'
- en: '| Modified Turing Machine | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 修改的图灵机 | 描述 |'
- en: '| Multiple heads | Two or more independent tape heads |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 多个磁头 | 两个或更多独立的磁头 |'
- en: '| Multiple tapes | Two or more tapes |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 多个磁带 | 两个或更多磁带 |'
- en: '| Multidimensional tape | Two dimensional tape |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 多维磁带 | 二维磁带 |'
- en: '| Nondeterministic | NFA controls the tape instead of DFA |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 非确定性 | NFA控制磁带而不是DFA |'
- en: '| Probabilistic | Can flip fair coins. Accept input if most of coin flips lead
    to accept state |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 概率性 | 可以抛硬币。如果大多数硬币翻转导致接受状态，则接受输入 |'
- en: '| Editable | Can insert and delete symbols on the tape |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 可编辑 | 可以在磁带上插入和删除符号 |'
- en: The definition of a Turing machine is very robust. The following restrictions
    do not affect a Turing machine's power (when applied individually to a standard
    Turing machine).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机的定义非常健壮。以下限制不会影响图灵机的能力（当分别应用于标准图灵机时）。
- en: '| Modified Turing Machine | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 修改图灵机 | 描述 |'
- en: '| One-way infinite | Tape is unbounded in one direction only |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 单向无限 | 磁带只在一个方向上是无限的 |'
- en: '| Binary | Tape alphabet consists of only two symbols |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 磁带字母表只包含两个符号 |'
- en: '| Two state | DFA that controls the tape has two states |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 两状态 | 控制磁带的DFA具有两个状态 |'
- en: '| Non-erasing | Turing machine which can never re-write a symbol once it''s
    written to the tape |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 非擦除 | 一旦写入磁带，就永远不能重新写入符号的图灵机 |'
- en: '| Time-reversible | Previous state can always be uniquely determined from the
    current state and tape contents. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 可逆时间 | 前一个状态总是可以从当前状��和磁带内容唯一确定。 |'
- en: Mathematicians, computer scientists, biologists, and physicists have considered
    numerous other models of computation. The following is a partial list of such
    models that have all been shown to be equivalent in power to the Turing machine,
    thereby providing additional support for the Church-Turing thesis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家、计算机科学家、生物学家和物理学家已经考虑了许多其他计算模型。以下是一些已被证明与图灵机在能力上等效的模型的部分列表，从而进一步支持了丘奇-图灵论题。
- en: '| Universal Model of Computation | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 通用计算模型 | 描述 |'
- en: '| Post Formal Systems Emil Post, 1920s | String replacement rules designed
    to prove mathematical statements from a set of axioms. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 波斯特形式系统 埃米尔·波斯特，1920年代 | 旨在从一组公理中证明数学命题的字符串替换规则。 |'
- en: '| Untyped Lambda Calculus Alonzo Church, 1936 | A method to define and manipulate
    functions. Basis of functional programming languages, including Lisp and ML |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 无类型λ演算 阿隆佐·邱奇，1936 | 一种定义和操作函数的方法。是函数式编程语言的基础，包括Lisp和ML |'
- en: '| Universal Turing Machines Alan Turing, 1936 | A Turing machine that can simulate
    the behavior of any other Turing machine. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 通用图灵机 阿兰·图灵，1936 | 可以模拟任何其他图灵机行为的图灵机。 |'
- en: '| General Recursive Functions Herbrand, 1932'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| 一般递归函数 哈布兰德，1932'
- en: Kurt Godel, 1934 | Functions dealing with computation on the natural numbers.
    |
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 库尔特·哥德尔，1934 | 处理自然数上的计算的函数。 |
- en: '| Partial Recursive Functions Alonzo Church, 1932'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '| 部分递归函数 阿隆佐·邱奇，1932'
- en: Stephen Kleene, 1935 | Functions dealing with computation on the natural numbers.
    |
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂芬·克林，1935 | 处理自然数上的计算的函数。 |
- en: '| Markov Algorithms Andrei Markov, 1960 | Apply string replacement rules sequentially
    in a prespecified order. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 马尔可夫算法 安德烈·马尔可夫，1960 | 按照预定顺序依次应用字符串替换规则。 |'
- en: '| Unrestricted Grammars Noam Chomsky, 1950s | Apply string replacement rules
    sequentially in arbitrary order until a certain stopping condition is satisfied.
    Used by linguists to describe natural languages. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 无限制文法 诺姆·乔姆斯基，1950年代 | 按任意顺序依次应用字符串替换规则，直到满足某种停止条件。被语言学家用来描述自然语言。 |'
- en: '| Tag Systems Emil Post, 1921, 1935, 1965 | As long as the string consists
    of at least k letters: read the first letter, delete the first k letters, and
    append a string to the end depending on the first letter. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 标记系统 埃米尔·波斯特，1921年，1935年，1965年 | 只要字符串至少包含k个字母：读取第一个字母，删除前k个字母，并根据第一个字母附加一个字符串。
    |'
- en: '| Extended L-Systems Aristid Lindenmayer, 1976 | Apply string replacement rules
    in parallel. Biologists use to model the growth of plants. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 扩展L-系统 阿里斯蒂德·林登迈尔，1976 | 并行应用字符串替换规则。生物学家用于模拟植物生长。 |'
- en: '| Semi-Thue Systems Axel Thue, 1910 | Apply string replacement rules in arbitrary
    order. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 半图灵系统 阿克塞尔·图厄，1910 | 按任意顺序应用字符串替换规则。 |'
- en: '| Horn Clause Logic Alfred Horn, 1951 | Logic based system for theorem proving.
    Forms basis of Prolog language. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 霍恩子句逻辑 阿尔弗雷德·霍恩，1951 | 基于逻辑的定理证明系统。构成Prolog语言的基础。 |'
- en: '| 1D Cellular Automata Matthew Cook, 1983'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1D元胞自动机 马修·库克，1983'
- en: Stephen Wolfram, 2002 | A one dimensional boolean array of cells whose values
    change according to the state of adjacent cells. Corresponds to finite impulse
    response digital filters. |
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂芬·沃尔夫拉姆，2002 | 一个一维布尔数组，其单元格的值根据相邻单元格的状态而改变。对应于有限冲激响应数字滤波器。 |
- en: '| 2D Cellular Automata John von Neumann, 1952'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2D元胞自动机 约翰·冯·诺伊曼，1952'
- en: John Conway, 1960s | A two dimensional boolean array of cells whose values change
    according to the state of adjacent cells. The most famous example is Conway's
    Game of Life. |
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·康威，1960年代 | 一个二维布尔单元格数组，其值根据相邻单元格的状态而改变。最著名的例子是康威的生命游戏。 |
- en: '| Post Machines Emil Post, 1936 | A DFA plus a queue. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 波斯特机器 埃米尔·波斯特，1936 | 一个DFA加上一个队列。 |'
- en: '| Two Stack Machines | A DFA plus two stacks. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 两栈机 | 一个DFA加上两个栈。 |'
- en: '| Two Register Machines Shepardson-Sturgis, 1963'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| 两寄存器机器 谢泼德森-斯特吉斯，1963'
- en: Marvin Minsky, 1961 | A DFA plus two integer counters which it can increment,
    decrement, and test against zero. |
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 马文·明斯基，1961 | 一个DFA加上两个整数计数器，它可以递增、递减，并与零进行比较。 |
- en: '| Programming Languages | Java, C, C++, Perl, Python, PHP, Lisp, PostScript,
    Excel, ... |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 编程语言 | Java, C, C++, Perl, Python, PHP, Lisp, PostScript, Excel, ... |'
- en: '| Random Access Machines | Finitely many registers plus memory that can be
    accessed with an integer address. Includes TOY and virtually all modern day microprocessors.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 随机访问机 | 有限数量的寄存器加上可以用整数地址访问的内存。包括TOY和几乎所有现代微处理器。 |'
- en: '| Pointer Machines | Finitely many registers plus memory that can be accessed
    as a linked list. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 指针机 | 有限数量的寄存器加上可以作为链表访问的内存。 |'
- en: '| Quantum Turing Machines Richard Feynman, 1965'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '| 量子图灵机 理查德·费曼，1965'
- en: David Deutsch, 1985 | Computes using the superposition of quantum states. |
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·迪奥特，1985 | 使用量子态叠加进行计算。 |
- en: '| Billiard Ball Computer Fredkin-Toffoli, 1982 | Indistinguishable billiard
    balls move in the plane, making elastic collisions with each other and internal
    barriers. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 台球计算机 Fredkin-Toffoli, 1982 | 不可区分的台球在平面上移动，彼此之间和内部障碍物弹性碰撞。 |'
- en: '| Particle Machines | Information is carried through space by particles, and
    computation occurs when particles collide. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 粒子机器 | 信息通过粒子在空间中传递，计算发生在粒子碰撞时。 |'
- en: '| Filter Automata Park-Steiglitz-Thurston, 1985 | Cellular automata that use
    newly computed values as soon as they are available. Corresponds to infinite impulse
    response digital filters. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器自动机 Park-Steiglitz-Thurston, 1985 | 使用新计算值一旦可用即刻使用的元胞自动机。对应于无限冲激响应数字滤波器。
    |'
- en: '| Generalized Shift Maps Christopher Moore, 1990 | A single classical particle
    moving in a 3D potential well made of parabolic mirrors. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 广义移位映射 Christopher Moore, 1990 | 一个在由抛物面镜组成的三维势阱中移动的单个经典粒子。 |'
- en: '| DNA Computers Len Adleman, 1994 | Compute using biological operations on
    strands of DNA. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| DNA 计算机 Len Adleman, 1994 | 使用 DNA 链上的生物操作进行计算。 |'
- en: '| Shift-like Dynamical Systems Christopher Moore, 1981 | Dynamics based computing
    using chaos theory. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 类移位动力系统 Christopher Moore, 1981 | 使用混沌理论的基于动力学的计算。 |'
- en: '| Dynamical Systems Sinha-Ditto, 1998 | Dynamics based computing using chaos
    theory. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 动力系统 Sinha-Ditto, 1998 | 使用混沌理论的基于动力学的计算。 |'
- en: '| Dynamical Systems | Hybrid systems, piecewise affine systems, saturated linear
    systems. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 动力系统 | 混合系统、分段仿射系统、饱和线性系统。 |'
- en: '| Soliton Collision Systems Ken Steiglitz, 2000 | Time-gated Manakov spatial
    solitons in a homogeneous medium. A gateless computer without spatially fixed
    gates. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 孤立子碰撞系统 Ken Steiglitz, 2000 | 在均匀介质中的时间门控 Manakov 空间孤立子。一种没有空间固定门的无门计算机。
    |'
- en: '| High-Level Petri Nets Carl Petri, 1962 | Generalization of automata for concurrently
    occurring events. Applications to management, manufacturing, communication protocols,
    fault tolerant systems. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 高级 Petri 网 Carl Petri, 1962 | 用于同时发生事件的自动机的泛化。应用于管理、制造、通信协议、容错系统。 |'
- en: '**Interactive computation.** Perhaps the most natural form of computation is
    as a calculator - transforming an input into an output. A Turing machines does
    not accept external input when it computes; this prevents it from directly modeling
    many natural processes. Our computers perform many operations that are not as
    natural to put into this framework. For example, your operating system, user interfaces,
    word processor, video game, soccer-playing robots, networks, sensors. These all
    involve interactions or communications with the program by an external agent (a
    person or another program). *Interaction machines* are natural generalizations
    of Turing machines that accept synchronous or asynchronous input streams.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互式计算。** 或许最自然的计算形式是作为计算器 - 将输入转换为输出。当图灵机计算时，它不接受外部输入；这阻止了它直接模拟许多自然过程。我们的计算机执行许多不太适合放入这个框架的操作。例如，你的操作系统、用户界面、文字处理器、视频游戏、踢足球的机器人、网络、传感器。所有这些都涉及与程序的外部代理（人或其他程序）的交互或通信。*交互机器*
    是图灵机的自然推广，它接受同步或异步输入流。'
- en: Why doesn't this violate Church-Turing thesis? One could argue that the external
    agents themselves could be simulated by a Turing machine!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这不违反了丘奇-图灵论题？有人可能会争辩说外部代理本身可以被图灵机模拟！
- en: '**Physics of computation.** In their landmark paper [Conservative Logic](http://www.digitalphilosophy.org/download_documents/ConservativeLogic.pdf),
    Fredkin and Toffoli argue that computation is a physical process and is ultimately
    governed by physical principles. They propose a number of axioms to which all
    computational process are subjected. Turing''s goal was to invent a machine that
    captured the essence of computation, while still being subject to the laws of
    physics. Fredkin and Toffoli discuss how Turing machines implicitly embody these
    first three axioms.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算的物理学。** 在他们具有里程碑意义的论文[保守逻辑](http://www.digitalphilosophy.org/download_documents/ConservativeLogic.pdf)中，Fredkin
    和 Toffoli 论证计算是一个物理过程，最终受物理原则支配。他们提出了一些所有计算过程都受到的公理。图灵的目标是发明一台捕捉计算本质的机器，同时仍受物理定律约束。Fredkin
    和 Toffoli 讨论了图灵机如何隐含地体现这前三个公理。'
- en: '*The speed of propagation of information is bounded.* In physics, *action at
    a distance* is limited by the speed of light. With Turing machines, the tape head
    only moves to the left or right one cell at a time. Therefore causality effects
    can only propagate through local interactions.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息传播速度受限。* 在物理学中，*远距作用* 受到光速的限制。对于图灵机，磁带头每次只能向左或向右移动一个单元。因此，因果效应只能通过局部相互作用传播。'
- en: '*The amount of information which can be encoded in the state of a finite system
    is bounded.* In physics, thermodynamical and quantum-physical considerations suggest
    such limitations. For example, the [holographic principle](http://en.wikipedia.org/wiki/Holographic_principle)
    is a conjecture about quantum thermodynamics that place a limit ([10^69 bits per
    square meter](http://arxiv.org/abs/hep-th/0203101)) on the amount of information
    per surface area (*not* volume) of space-time. With Turing machines, each cell
    only contains one of three possible symbols.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有限系统状态中可以编码的信息量受限。* 在物理学中，热力学和量子物理的考虑表明存在这样的限制。例如，[全息原理](http://en.wikipedia.org/wiki/Holographic_principle)是一个关于量子热力学的猜想，它对时空表面积上的信息量设定了一个限制（每平方米[10^69
    位](http://arxiv.org/abs/hep-th/0203101)）。对于图灵机，每个单元只包含三种可能的符号之一。'
- en: '*It is possible to construct macroscopic, dissipative physical devices which
    perform in a recognizable and reliable way the logical functions AND, OR, and
    FAN-OUT.* This means that it is possible to fabricate Turing machines out of physical
    parts, and run them reliably.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可以构建宏观、耗散性物理设备，以可识别和可靠地执行逻辑函数 AND、OR 和 FAN-OUT。* 这意味着可以用物理部件制造图灵机，并可靠地运行它们。'
- en: Deutsch proposed the *Church-Turing Principle* that asserts that the Universe
    is capable of containing a universal machine that can simulate the universe itself.
    This connects the notions of computability with physics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 迪奥特提出了*丘琴原理*，它断言宇宙能够包含一个能够模拟宇宙本身的通用机器。这将计算性概念与物理学联系起来。
- en: '**Zuse-Fredkin thesis.** Around 1960 Edward Fredkin first posited the radical
    notion that the Universe is a (universal) cellular automata, a kind of highly
    parallel computing device. In the late 1960, Konrad Zuse independently proposed
    that the Universe is being computed on a computer, possibly a cellular automata.
    He referred to this as *Rechnender Raum* or *Computing Cosmos.*. This controversial
    thesis became know as the *Zuse-Fredkin thesis*. From a physics viewpoint, it
    is a universal Theory of Everything. It is certainly true that many complex systems
    can be explained by simple discrete processes. It remains a fascinating open scientific
    question as to whether it is cellular automata or some other process that is responsible
    for such complexity in nature. Although the Church-Turing thesis has been widely
    accepted, the more far-reaching Zuse-Fredkin thesis has remained in relatively
    obscurity and has not yet been widely accepted. One of the main challenges is
    [reconciling it with quantum physics](http://digitalphysics.org/Publications/Petrov/Pet02a2/Pet02a2.htm).
    Also, it is hard to verify, and has not yet proved useful in making accurate predictions
    about the universe that could not be made using traditional methods. The Konrad-Zuse
    thesis is the cornerstone of two emerging disciplines - Digital Mechanics and
    [Digital Physics](http://digitalphysics.org). It has deep philosophical ramifications.
    For example, if the Universe is a CA, then we humans, together with our logical
    thoughts, are *algorithms* executing in some space-time region of the CA. Following
    on the work of Zuse, Fredkin, and many others, in his book [A New Kind of Science](http://www.wolframscience.com/nksonline/),
    Steve Wolfram promotes the theory that the entire universe is a massive computational
    process, and that such physical processes are best understood by investigating
    simple model of computation like cellular automata.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**祖斯-弗雷德金论**。大约在1960年，爱德华·弗雷德金首次提出了一个激进的观念，即宇宙是一个（通用的）元胞自动机，一种高度并行的计算设备。在1960年代末，康拉德·祖斯独立提出了宇宙是在计算机上计算的观点，可能是一个元胞自动机。他将其称为*Rechnender
    Raum*或*Computing Cosmos*。这一颇具争议的论点被称为*祖斯-弗雷德金论*。从物理学的角度来看，这是一个涵盖一切的普适理论。许多复杂系统可以用简单的离散过程来解释是事实。关于自然界中这种复杂性是由元胞自动机还是其他过程负责的问题，仍然是一个迷人的开放科学问题。尽管图灵-丘琴论被广泛接受，但更具深远意义的祖斯-弗雷德金论仍然相对默默无闻，尚未被广泛接受。其中一个主要挑战是[将其与量子物理相协调](http://digitalphysics.org/Publications/Petrov/Pet02a2/Pet02a2.htm)。此外，这一理论很难验证，尚未证明在利用传统方法无法做出的关于宇宙的准确预测方面有用。康拉德·祖斯论是两个新兴学科——数字力学和[数字物理学](http://digitalphysics.org)的基石。它具有深刻的哲学意义。例如，如果宇宙是一个元胞自动机，那么我们人类以及我们的逻辑思维就是在元胞自动机的某个时空区域中执行的*算法*。在祖斯、弗雷德金和许多其他人的研究基础上，史蒂夫·沃尔夫勃罗姆在他的书[一种新的科学](http://www.wolframscience.com/nksonline/)中提倡整个宇宙是一个巨大的计算过程，并且这样的物理过程最好通过研究元胞自动机等简单的计算模型来理解。'
- en: 'Digital physics: universe is the output of a deterministic computer.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数字物理学：宇宙是一个确定性计算机的输出。
- en: '**Universal limits on computation.** The Hawking-Bekenstein bound postulates
    that there is a limit to the amount of information (number of quantum states or
    number of bits that can be encoded) I that a sphere of radius R with a given energy
    E can hold: I &le 2 π E R / (ℏ c ln 2), where ℏ = Plank''s constant and c is the
    speed of light. Alternatively, using E = mc², &le k M R, where M = mass of region
    and k is approximately 2.57686 × 10^(43) bits / (m kg). The maximum processing
    speed is bounded by the minimum time for a state transition which is bounded by
    the time for light to cross the region of radius R = π E / (ℏ ln 2) bits / sec.
    The [Bekenstein bound](../../papers/bekenstein.pdf) is based on black hole physics.
    This implies, that in theory, Turing machines, with their arbitrary size tape,
    only exist in our imagination (if they are to have finite size and bounded energy).
    Though in practice, they serve is an excellent model of reality.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算的普遍限制**。霍金-贝肯斯坦界限假设一个半径为R、能量为E的球体能够容纳的信息量（量子态数或可编码的比特数）存在一个限制：I &le 2 π
    E R / (ℏ c ln 2)，其中ℏ为普朗克常数，c为光速。另一种表达方式是使用E = mc²，&le k M R，其中M为区域的质量，k约为2.57686
    × 10^(43)比特/(m千克)。最大处理速度受限于状态转换的最短时间，这个时间受限于光穿过半径为R的区域所需的时间：π E / (ℏ ln 2)比特/秒。[贝肯斯坦界限](../../papers/bekenstein.pdf)基于黑洞物理学。这意味着，理论上，图灵机，以其任意大小的磁带，只存在于我们的想象中（如果它们具有有限大小和有界能量）。尽管在实践中，它们是现实的极好模型。'
- en: Q. Suppose a human brain stores 10^(16) bits, has a mass of 1kg, and is approximately
    spherical with a radius of 10cm. Compare its efficiency to the Bekenstein bound.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 问：假设人类大脑存储了10^(16)比特，质量为1千克，大致呈球形，半径为10厘米。将其效率与贝肯斯坦界限进行比较。
- en: This tighter bound is based on This [physics paper](http://arxiv.org/abs/astro-ph/0404510)
    by Krauss and Starkmann suggests that if the Universe is accelerating, then there
    is an inherent limit on the total amount of information that can be processed,
    even infinitely far into the future. The estimated limit is approximately 10^(120)
    bits, so there is no need for immediate concern! This [Nature paper](../../papers/lloyd.pdf)
    by Seth Lloyd puts quantitative bounds on the rate at which a 1kg computer occupying
    a volume of 1 liter can compute and how much memory it can access.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更严格的界限基于Krauss和Starkmann的[物理论文](http://arxiv.org/abs/astro-ph/0404510)，该论文表明，如果宇宙正在加速，那么即使在未来无限遥远的情况下，可以处理的信息总量也存在固有限制。估计的限制约为10^(120)比特，因此目前无需担心！Seth
    Lloyd的这篇[Nature论文](../../papers/lloyd.pdf)对1升容积的1千克计算机的计算速度和可访问的内存量进行了定量限制。
- en: '**Beyond the Church-Turing thesis.** Are there any types of computation that
    cannot be done by a Turing machine, but that can be done using some other kind
    of physical or abstract machine? Yes. We consider a few representative examples
    of so called [hyper-computation](http://arxiv.org/pdf/math.LO/0209332).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**超越教堂-图灵论题。** 是否有任何类型的计算无法由图灵机完成，但可以使用其他类型的物理或抽象机器完成？是的。我们考虑了一些所谓的[超级计算](http://arxiv.org/pdf/math.LO/0209332)的代表性例子。'
- en: These models of computation are capable of solving problems (e.g., the halting
    problem) that cannot be solved using Turing machines. These are not known to violate
    the Church-Turing thesis because we do not know how to build such machines.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算模型能够解决一些问题（例如，停机问题），这些问题无法使用图灵机解决。我们不知道如何构建这样的机器，因此不违反教堂-图灵论题。
- en: '*Oracle Turing machines.* A Turing machine endowed with an oracle to answer
    questions, e.g., to the halting problem. Such models of computation are strictly
    more powerful than a Turing machine, but we haven''t the vaguest clue as to how
    to build such machines. As such, they do not (currently) violate the Church-Turing
    thesis.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Oracle图灵机。* 一种带有用于回答问题的预言的图灵机，例如，用于停机问题。这种计算模型比图灵机更强大，但我们对如何构建这样的机器毫无头绪。因此，它们（目前）不违反教堂-图灵论题。'
- en: '*Turing machine with initial inscription.* Turing machine that starts with
    an infinite number of symbols already on the tape. Again, this leads to a strictly
    more power model of computation than a Turing machine, but we don''t know how
    to build such a machine because it uses an infinite amount of storage.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带有初始铭文的图灵机。* 以无限数量的符号开始的图灵机。同样，这导致了比图灵机更强大的计算模型，但我们不知道如何构建这样的机器，因为它使用了无限的存储空间。'
- en: '*Real-valued Turing machines.* This is an abstract model of computation in
    which each tape cell stores a real value instead of a discrete symbol. The [Blum-Shub-Smale
    model](http://citeseer.ist.psu.edu/170087.html) allows each tape cell to store
    an arbitrary real number, possibly transcendental. Intended to capture continuous
    problems from scientific computing, computational geometry, computer algebra,
    continuous optimization. Such machines manipulate real numbers using infinite
    precision. The basic unit-cost computational steps are: arithmetic operations
    (+, -, *, /), arbitrary constants, and comparison operations or (, = if over real
    field). The inputs and outputs are vectors in R^n. If x is in R^n, then its size
    is n. (Can replace reals with another field, e.g., complex numbers C, but disallow
    ordered comparisons. If field is F_2, recover classic Turing model.) Undecidable
    problems exist under this model: given a complex number z, is it in the Mandelbrot
    set? Does Newton''s method converge, given a starting point x? "NP-complete" problems
    exist under this model: Knapsack problem: given n real numbers, is there a subset
    that sums to exactly 1? Given a degree 4 multivariate polynomial in n variables
    with real coefficients, does it have a real zero? Given a finite set of complex
    multivariate polynomials over n variables, do they have a common zero? However,
    it is unknown whether continuous values truly exist in nature, and if so, whether
    any natural process can harness their power.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实值图灵机。* 这是一种抽象的计算模型，其中每个磁带单元存储实值而不是离散符号。[Blum-Shub-Smale模型](http://citeseer.ist.psu.edu/170087.html)允许每个磁带单元存储任意实数，可能是超越数。旨在捕捉科学计算、计算几何、计算代数、连续优化中的连续问题。这些机器使用无限精度操作实数。基本的单位成本计算步骤包括：算术运算（+，-，*，/），任意常数，比较运算或（，=如果在实数域上）。输入和输出是R^n中的向量。如果x在R^n中，则其大小为n。（可以用另一个域替换实数，例如，复数C，但不允许有序比较。如果域是F_2，则恢复经典图灵模型。）在这个模型下存在不可判定的问题：给定一个复数z，它是否在Mandelbrot集中？给定一个起始点x，牛顿法是否收敛？在这个模型下存在“NP完全”问题：背包问题：给定n个实数，是否存在一个子集的和恰好为1？给定n个变量的实系数的4次多项式，它是否有一个实零点？给定n个变量的复多项式的有限集，它们是否有一个公共零点？然而，目前尚不清楚连续值是否真实存在于自然界中，如果存在，任何自然过程是否能利用它们的力量。'
- en: These models of computation are equivalent to the Turing machine in terms of
    computability, e.g., neither can solve the halting problem. However, these models
    can solve problems that falls outside the spectrum of computing functions and
    deciding languages, e.g., generating truly random numbers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算模型在可计算性方面等同于图灵机，例如，都无法解决停机问题。然而，这些模型可以解决计算函数和确定语言范围之外的问题，例如生成真正的随机数。
- en: '*Probabilistic Turing machine.* A *probabilistic Turing machine* is like a
    nondeterministic Turing machine, except that it choose its next transition uniformly
    at random from the legal choices. A probabilistic Turing machine is equivalent
    in power to a Turing machine in terms of the languages it can decide or the functions
    it can compute. However, a probabilistic Turing machine can generate truly random
    bits, a capability not possible on a conventional Turing machine. Nevertheless,
    there do appear to exist physical processes that produce randomness using quantum
    mechanics or other naturally occurring phenomenon. Supporters of the Zuse-Fredkin
    thesis would argue that nature only generates pseudo-random numbers and these
    could be simulated on a deterministic Turing machine.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*概率图灵机。* 一种*概率图灵机*类似于非确定性图灵机，只是它从合法选择中均匀随机选择下一个转换。在可决定的语言或可计算的函数方面，概率图灵机与图灵机的能力是等价的。然而，概率图灵机可以生成真正的随机位，这是传统图灵机无法实现的。然而，似乎存在利用量子力学或其他自然现象产生随机性的物理过程。支持祖斯-弗雷德金论题的人会认为自然只产生伪随机数，这些可以在确定性图灵机上模拟。'
- en: '*Quantum Turing machines.* Computation is a physical process, yet the Turing
    machine ignores quantum-mechanical effects. Deutsch proposed a quantum Turing
    machine that behaves like a Turing machine, but harnesses the power of quantum
    mechanics to perform computations. A quantum Turing machine is equivalent in power
    to a Turing machine in terms of the languages it can decide or the functions it
    can compute. However, quantum Turing machines open up new modes of computation
    since they can perform tasks other than computing functions and deciding languages.
    One striking example occurs in cryptography. In Chapter 0 we considered a cryptographic
    scheme known as one-time pads. To make them practical, we need an efficient way
    to share a key (string of random bits) between two parties without it being intercepted
    by a third party, or if it is intercepted the two communicating parties should
    be able to detect it. The problem of unconditional secure key distribution is
    provably impossible using classical computers and physics. However, by exploiting
    the Heisenberg uncertainty principle, Bennett and Brassard (1984) devised a scheme
    to solve the problem. The main thesis of the uncertainty principle is that (i)
    any measurement that extracts information from a physical system will necessarily
    change that system and (ii) any measurement that extracts information about a
    certain quantity will necessarily prevent extracting information about a conjugate
    quantity. Bennett and Brasard''s scheme sends each qubit (the quantum equivalent
    of a bit) using a single photon. The photon is altered as soon as it is read for
    the first time, so it cannot be intercepted without detection. While we don''t
    yet know how to build quantum Turing machines, scientists have developed specialized
    cryptography circuits to implement Bennet and Brasard''s scheme and have used
    it to securely distribute keys across 15 kilometers of fiber optical cable.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子图灵机*。计算是一个物理过程，但图灵机忽略了量子力学效应。德沃斯提出了一种行为类似于图灵机但利用量子力学来进行计算的量子图灵机。量子图灵机在决定语言或计算函数方面与图灵机的能力相当。然而，量子图灵机开辟了新的计算模式，因为它们可以执行除计算函数和决定语言之外的任务。一个引人注目的例子出现在密码学中。在第0章中，我们考虑了一种称为一次性密码本的加密方案。为了使它们实用，我们需要一种有效的方法在两个方之间共享密钥（一串随机位），而不被第三方拦截，或者如果被拦截，两个通信方应该能够检测到。使用经典计算机和物理学是不可能实现无条件安全密钥分发的。然而，通过利用海森堡不确定性原理，本内特和布拉萨德（1984年）设计了一个解决方案来解决这个问题。不确定性原理的主要论点是（i）从物理系统中提取信息的任何测量都必然会改变该系统，（ii）提取关于某一数量的信息的任何测量都必然会阻止提取关于共轭数量的信息。本内特和布拉萨德的方案使用单个光子发送每个量子位（比特的量子等价物）。光子在第一次被读取时就会被改变，因此不能被拦截而不被检测到。虽然我们还不知道如何构建量子图灵机，但科学家们已经开发了专门的密码学电路来实现本内特和布拉萨德的方案，并已经用它们安全地在15公里的光纤电缆上分发密钥。'
- en: Levin's [Tale of One-way Functions](http://arxiv.org/pdf/cs.CR/0012023) is a
    counterpoint to hyper-computation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 莱文的[Tale of One-way Functions](http://arxiv.org/pdf/cs.CR/0012023)是对超级计算的一个对立观点。
- en: Exercises
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: '**Conway''s game of life.** Universality. Here''s Martin Gardner''s [article](http://ddi.cs.uni-potsdam.de/HyFISCH/Produzieren/lis_projekt/proj_gamelife/ConwayScientificAmerican.htm)
    from Scientific American in 1970.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**康威的生命游戏**。普适性。这是马丁·加德纳在1970年发表在《科学美国人》上的[文章](http://ddi.cs.uni-potsdam.de/HyFISCH/Produzieren/lis_projekt/proj_gamelife/ConwayScientificAmerican.htm)。'
- en: '**Cellular automata.** [Cellular automata](http://mathworld.wolfram.com/CellularAutomaton.html)
    are computer simulations that try to emulate the laws of nature. They are used
    to model biological, chemical, and physical processes including: ferromagnetism
    according to Ising mode, forest fire propagation, nonlinear chemical reaction-diffusion
    systems, turbulent flow, biological pigmentation patterns, breaking of materials,
    growth of crystals, and growth of plants and animals. They are also used in image
    processing, [computer graphics](http://madeira.cc.hokudai.ac.jp/RD/takai/automa.html),
    design of massively parallel hardware, cryptography, and art.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**元胞自动机**。[元胞自动机](http://mathworld.wolfram.com/CellularAutomaton.html)是试图模拟自然规律的计算机模拟。它们用于模拟生物、化学和物理过程，包括：根据伊辛模型的铁磁性、森林火灾传播、非线性化学反应扩散系统、湍流流动、生物色素图案、材料断裂、晶体生长以及植物和动物的生长。它们还用于图像处理、[计算机图形学](http://madeira.cc.hokudai.ac.jp/RD/takai/automa.html)、大规模并行硬件设计、密码学和艺术。'
- en: A one-dimensional cellular automaton is an array of cells that evolves over
    time according to a set of rules based on the state of adjacent cells. At a given
    time t, each cell is either alive or dead. Rule 90 says that cell i is alive at
    time t if exactly one of its neighbors (cell i-1 or cell i+1) is alive at time
    t-1. Program [Cellular.java](Cellular.java.html) simulates the behavior of this
    cellular automaton using two Boolean arrays. Array element cells[i] is true if
    cell i is alive in the current time t, and false otherwise; array element old[i]
    is true if cell i is alive in the previous time step t-1, and false otherwise.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一维元胞自动机是一个随时间演化的细胞数组，根据相邻细胞的状态和一组规则进行演化。在给定时间t，每个细胞要么是活的，要么是死的。规则90表示细胞i在时间t处于活动状态，如果其相邻细胞（细胞i-1或细胞i+1）在时间t-1处于活动状态。程序[Cellular.java](Cellular.java.html)使用两个布尔数组模拟了这种元胞自动机的行为。数组元素cells[i]在当前时间t中为true，如果细胞i在当前时间t中是活的，则为true；否则为false；数组元素old[i]在上一个时间步骤t-1中为true，如果细胞i在上一个时间步骤t-1中是活的，则为true；否则为false。
- en: '**Cellular automata.** Here''s a nice review of [cellular automata](http://cscs.umich.edu/~crshalizi/notebooks/cellular-automata.html).
    Here''s the [Cellular Automata FAQ](http://cafaq.com/). Give 1d universal automaton.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**元胞自动机**。这里有一篇关于[元胞自动机](http://cscs.umich.edu/~crshalizi/notebooks/cellular-automata.html)的好评。这里是[元胞自动机FAQ](http://cafaq.com/)。给出1d通用自动机。'
- en: '**Firing squad synchronization problem.** The [firing squad problem](http://mathworld.wolfram.com/FiringSquadProblem.html)
    was first proposed by Mynhill in 1957 and solve by Moore in 1962 in the context
    of finite state machines. You have a 1D cellular automata with 2^n identical cells,
    each which can take on one of a finite number of colors. They all run at the same
    speed, and each can only communicate with its immediate neighbors. All cells are
    initially white. Design the machines so that after a "start" signal is given to
    the first machine (the general), all machines (the soldiers) turn a special "firing"
    color for the first time at time t. You don''t know the size of the array ahead
    of time, so your solution must not depend on n. *Hint*: try to find the middle
    cell.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开火小队同步问题。** [开火小队问题](http://mathworld.wolfram.com/FiringSquadProblem.html)最初由迈尔希尔在1957年提出，并由摩尔在1962年在有限状态机的背景下解决。您有一个具有2^n个相同单元格的一维元胞自动机，每个单元格可以采用有限数量的颜色之一。它们都以相同的速度运行，每个单元格只能与其相邻的单元格通信。所有单元格最初都是白色的。设计机器，使得在向第一个机器（将军）发出“开始”信号后，所有机器（士兵）在时间t第一次变为特殊的“开火”颜色。您事先不知道数组的大小，因此您的解决方案不得依赖于n。*提示*：尝试找到中间单元格。'
- en: '**Zebra stripes.** Produce a picture of synthetic zebra stripes by simulating
    a 2D cellular automaton using turtle graphics.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**斑马条纹。** 通过使用乌龟图形模拟2D元胞自动机来生成合成斑马条纹的图片。'
- en: 'Start by creating an N-by-N grid of cells, initializing each to black or white
    at random. Then, run 10 phases, where each phase iterates through the N-by-N cells
    one at a time, updating the color (black or white) of cell (i, j) as follows:'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个N×N的单元格网格，随机初始化每个单元格为黑色或白色。然后，运行10个阶段，每个阶段依次遍历N×N单元格，更新单元格(i, j)的颜色（黑色或白色）如下：
- en: For each neighboring cell (i', j') that is black such that |i - i'| = 0 or 1
    and |j - j'| <= 3, add 2.0 to a running total.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个黑色相邻单元格(i', j')，使得|i - i'| = 0或1且|j - j'| <= 3，将2.0添加到一个累加总和中。
- en: For each neighboring cell (i', j') that is black such that |i - i'| = 2 or 3
    and |j - j'| <= 3, subtract 1.2 from the running total.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个黑色相邻单元格(i', j')，使得|i - i'| = 2或3且|j - j'| <= 3，从累加总和中减去1.2。
- en: If the running total exceeds 1.4, color (i, j) black; otherwise color it white.Write
    a program [Zebra.java](Zebra.java.html) to illustrate the results of the cellular
    automaton.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果累加总和超过1.4，则将(i, j)着色为黑色；否则将其着色为白色。编写一个程序[Zebra.java](Zebra.java.html)来说明元胞自动机的结果。
- en: Experiment with a different weighting function (e.g., 2.0 and -0.4) and use
    the Manhattan distance function |i - i'| + |j - j'| instead of the one above.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用不同的加权函数（例如2.0和-0.4），并使用曼哈顿距离函数|i - i'| + |j - j'|代替上面的函数。
- en: '**Paterson worms.** [Paterson worms](http://www.accessv.com/~sven/worms/) are
    a recreation puzzle discovered by John Conway and popularized by Marvin Gardner,
    much like Conway''s Game of Life. Write a program `PatersonWorm.java` that animates
    Patterson worms in Turtle graphics.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**帕特森蠕虫。** [帕特森蠕虫](http://www.accessv.com/~sven/worms/)是由约翰·康威发现并由马文·加德纳广泛推广的一种重现谜题，类似于康威的生命游戏。编写一个程序`PatersonWorm.java`，在乌龟图形中展示帕特森蠕虫的动画。'
- en: '**Lindenmayer systems.** Apply the replacement rule `F -> F+F--F+F` to the
    initial string `F+F--F+F` in parallel. For example, after one application the
    string becomes `F+F--F+F--F+F--F+F--F+F--F+F`. If you interpret `F` as go 1 step
    forward, `+` as rotate 60 degrees clockwise and `-` as rotate 60 degrees counterclockwise,
    this sequence of commands draw the Koch snowflake. Write a program [Lindenmayer.java](Lindenmayer.java.html)
    that takes a command line argument N and prints the commands for generating the
    Koch curve of order N. *Hint*: use the string library method `replaceAll`.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**林登迈尔系统。** 将替换规则`F -> F+F--F+F`并行应用于初始字符串`F+F--F+F`。例如，一次应用后，字符串变为`F+F--F+F--F+F--F+F--F+F--F+F`。如果将`F`解释为向前走1步，`+`解释为顺时针旋转60度，`-`解释为逆时针旋转60度，这个命令序列绘制了科赫雪花。编写一个程序[Lindenmayer.java](Lindenmayer.java.html)，它接受一个命令行参数N，并打印生成N阶科赫曲线的命令。*提示*：使用字符串库方法`replaceAll`。'
- en: '**Lindenmayer system to generate trees.** Write a program [LSystem.java](LSystem.java.html)
    that creates tree-like graphics using the Lindenmayer system: XYZ.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用林登迈尔系统生成树。** 编写一个程序[LSystem.java](LSystem.java.html)，使用林登迈尔系统创建类似树的图形：XYZ。'
- en: '**Lindenmayer system interpreter.** Write a program that reads in the description
    of a Lindenmayer system and plots the resulting pattern.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**林登迈尔系统解释器。** 编写一个程序，读取林登迈尔系统的描述并绘制生成的图案。'
- en: '**Ackermann''s function.** The Ackermann function A(m, n) is a deceptively
    simple function that plays a crucial role in the analysis of algorithms and complexity
    theory. It''s defined recursively as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阿克曼函数。** 阿克曼函数A(m, n)是一个看似简单但在算法分析和复杂性理论中起着关键作用的函数。它的递归定义如下：'
- en: A(0, n) = n + 1
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: A(0, n) = n + 1
- en: A(m, 0) = A(m - 1, 1)
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: A(m, 0) = A(m - 1, 1)
- en: A(m, n) = A(m - 1, A(m, n - 1))
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: A(m, n) = A(m - 1, A(m, n - 1))
- en: Write a program [Ackermann.java](Ackermann.java.html) that takes two command
    line parameters M and N and computes A(M, N).
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Ackermann.java](Ackermann.java.html)，接受两个命令行参数M和N，并计算A(M, N)。
- en: 'What happens when you compute A(3, 9)? Answer: stack overflow error.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算A(3, 9)时会发生什么？答案：堆栈溢出错误。
- en: 'What is A(5, 5)? Answer: too many digits to ever print out. Here is [A(4, 2)](http://www.kosara.net/thoughts/ackermann42.html).
    To see how devastatingly fast this function grows, consider the following equivalent
    definition:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: A(5, 5)是多少？答案：数字太多，无法打印出来。这里是[A(4, 2)](http://www.kosara.net/thoughts/ackermann42.html)。要看到这个函数增长的速度有多快，请考虑以下等价定义：
- en: '*A*(0, *n*) = *n* + 1'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A*(0, *n*) = *n* + 1'
- en: '*A*(1, *n*) = 2 + (*n* + 3) - 3'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A*(1, *n*) = 2 + (*n* + 3) - 3'
- en: '*A*(2, *n*) = 2 × (*n* + 3) - 3'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A*(2, *n*) = 2 × (*n* + 3) - 3'
- en: '*A*(3, *n*) = 2 ^(*n* + 3) - 3'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A*(3, *n*) = 2 ^(*n* + 3) - 3'
- en: '*A*(4, *n*) = 2^(2^(...²)) - 3        (*n* + 3 terms in the tower)'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A*(4, *n*) = 2^(2^(...²)) - 3        （塔中有*n* + 3个项）'
- en: '...'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...'
- en: '**Buck''s function.** Buck''s function is defined recursively as:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**巴克函数。** 巴克函数的递归定义如下：'
- en: '[PRE3]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calculate by hand f(1, n), f(2, n), f(3, n), and f(4, n) as a function of n.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 手动计算f(1, n)，f(2, n)，f(3, n)和f(4, n)作为n的函数。
- en: '*Answer*: 2 + n, 2n, 2^n, 2^(2^(2^(...²))) (n terms in the tower).'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*: 2 + n, 2n, 2^n, 2^(2^(2^(...²)))（塔中有n个项）。'
- en: '**Cellular automata sand pile.** Model sand falling into a pile using a [cellular
    automata model](http://schuelaw.whitman.edu/JavaApplets/SandPileApplet/).'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**元胞自动机沙堆。** 使用[元胞自动机模型](http://schuelaw.whitman.edu/JavaApplets/SandPileApplet/)模拟沙子堆积。'
- en: '**Schelling segregation model.** Investigate the [Schelling Segregation Model
    (SSM)](http://www.econ.iastate.edu/tesfatsi/demos/schelling/schellhp.htm). "Among
    first constructive model of a dynamic system capable of self-organization." Modeled
    an integrated environment where each agent has a slight preference for one''s
    neighbors to be of the same kind could lead to segregation. For every colored
    cell, if greater than 1/3 (or some other threshold) of neighbors are a different
    color, move to a randomly selected cell (or have each cell take a random walk).
    (or perhaps examine all cells within some neighborhood, with weight proportional
    to 1/d). Schelling won the 2005 Nobel Prize in Economics. Green turtles and red
    turtles. Preferences ripple through a pond. Even if turtles start out wanting
    only 30% similarity, they end up with around 70%. Here''s a [demo](http://ccl.northwestern.edu/netlogo/models/run.cgi?Segregation.650.479).'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谢林分离模型。** 研究[谢林分离模型（SSM）](http://www.econ.iastate.edu/tesfatsi/demos/schelling/schellhp.htm)。"首个能够自组织的动态系统的建设性模型。"
    模拟了一个整合环境，其中每个代理人都略微偏好邻居是相同类型的可能导致分离。对于每个有颜色的单元，如果超过1/3（或其他阈值）的邻居是不同颜色的，则移动到随机选择的单元（或让每个单元进行随机行走）。
    （或者也许检查所有在某个邻域内的单元，权重与1/d成比例）。谢林获得了2005年的诺贝尔经济学奖。 绿色乌龟和红色乌龟。 偏好通过池塘传播。 即使乌龟最初只希望相似度达到30％，最终也会达到约70％。
    这里有一个[演示](http://ccl.northwestern.edu/netlogo/models/run.cgi?Segregation.650.479)。'
