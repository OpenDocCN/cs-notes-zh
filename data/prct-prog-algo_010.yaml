- en: 2.1   Static Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1   静态方法
- en: 原文：[https://introcs.cs.princeton.edu/java/21function](https://introcs.cs.princeton.edu/java/21function)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/21function](https://introcs.cs.princeton.edu/java/21function)
- en: The Java construct for implementing functions is known as the *static method*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实现函数的Java构造称为*静态方法*。
- en: Using and defining static methods.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用和定义静态方法。
- en: The use of static methods is easy to understand. For example, when you write
    `Math.abs(a-b)` in a program, the effect is as if you were to replace that code
    with the *return value* that is produced by Java's `Math.abs()` method method
    when passed the expression `a-b` as an *argument*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法很容易理解。例如，当你在程序中写入 `Math.abs(a-b)` 时，效果就好像你将该代码替换为Java的 `Math.abs()` 方法在传递表达式
    `a-b` 作为*参数*时产生的*返回值*。
- en: '*Flow-of-control.* [Harmonic.java](Harmonic.java.html) comprises two static
    methods: `harmonic()` to compute harmonic numbers and and `main()` to interact
    with user.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制流.* [Harmonic.java](Harmonic.java.html) 包括两个静态方法：`harmonic()` 用于计算谐波数，`main()`
    用于与用户交互。'
- en: '![harmonic numbers](../Images/10522b75497279c18e11ab9e654d53b6.png)            
    ![function-call trace](../Images/5902e6217e718db114f7b4f274de7c56.png)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![谐波数](../Images/10522b75497279c18e11ab9e654d53b6.png)             ![函数调用跟踪](../Images/5902e6217e718db114f7b4f274de7c56.png)'
- en: '*Function-call trace.* One simple approach to following the flow of control
    through function calls is to imagine that each function prints its name and argument
    value when it is called and its return value just before returning, with indentation
    added on calls and subtracted on returns.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数调用跟踪.* 跟踪函数调用的控制流的一种简单方法是想象每个函数在被调用时打印其名称和参数值，在返回之前打印其返回值，并在调用时添加缩进并在返回时减少缩进。'
- en: '*Static method definition.* The first line of a static method definition, known
    as the *signature*, gives a name to the method and to each *parameter variable*.
    It also specifies the *type* of each parameter variable and the *return type*
    of the method. Following the signature is the *body* of the method, enclosed in
    curly braces. The body consists of the kinds of statements we discussed in Chapter
    1. It also can contain a *return statement*, which transfers control back to the
    point where the static method was called and returns the result of the computation
    or *return value*. The body may declare *local variables*, which are variables
    that are available only inside the method in which they are declared.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态方法定义.* 静态方法定义的第一行，称为*签名*，为方法和每个*参数变量*指定名称。它还指定了每个参数变量的*类型*和方法的*返回类型*。在签名之后是方法的*主体*，用大括号括起来。主体由我们在第1章中讨论过的各种语句组成。它还可以包含一个*return语句*，它将控制传回静态方法被调用的点，并返回计算结果或*返回值*。主体可能声明*局部变量*，这些变量仅在声明它们的方法中可用。'
- en: '![anatomy of a static method](../Images/155497e24152938c2acdb00857f6d9df.png)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![静态方法解剖](../Images/155497e24152938c2acdb00857f6d9df.png)'
- en: '*Function calls.* A static method call is nothing more than the method name
    followed by its arguments, separated by commas and enclosed in parentheses. A
    method call is an expression, so you can use it to build up more complicated expressions.
    Similarly, an argument is an expression—Java evaluates the expression and passes
    the resulting value to the method. So, you can write code like `Math.exp(-x*x/2)
    / Math.sqrt(2*Math.PI)` and Java knows what you mean.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数调用.* 静态方法调用只是方法名称后跟其参数，用逗号分隔并用括号括起来。方法调用是一个表达式，因此你可以用它来构建更复杂的表达式。同样，参数是一个表达式—Java评估表达式并将结果值传递给方法。因此，你可以编写像
    `Math.exp(-x*x/2) / Math.sqrt(2*Math.PI)` 这样的代码，Java知道你的意思。'
- en: '![anatomy of a static method call](../Images/a73cbe98ca3793c89559895d3720301d.png)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![静态方法调用解剖](../Images/a73cbe98ca3793c89559895d3720301d.png)'
- en: Properties of static methods.
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法的属性。
- en: '*Multiple arguments.* Like a mathematical function, a Java static method can
    take on more than one argument, and therefore can have more than one parameter
    variable.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多个参数.* 像数学函数一样，Java静态方法可以接受多个参数，因此可以有多个参数变量。'
- en: '*Multiple methods.* You can define as many static methods as you want in a
    `.java` file. These methods are independent and can appear in any order in the
    file. A static method can call any other static method in the same file or any
    static method in a Java library such as `Math`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多个方法.* 你可以在一个`.java`文件中定义任意多个静态方法。这���方法是独立的，可以以任何顺序出现在文件中。一个静态方法可以调用同一文件中的任何其他静态方法或Java库中的任何静态方法，如`Math`。'
- en: '*Overloading.* Static methods whose signatures differ are different static
    methods. Using the same name for two static methods whose signatures differ is
    known as *overloading*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重载.* 签名不同的静态方法是不同的静态方法。对两个签名不同的静态方法使用相同的名称称为*重载*。'
- en: '*Multiple return statements.* You can put `return` statements in a method wherever
    you need them: control goes back to the calling program as soon as the first `return`
    statement is reached.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多个返回语句.* 你可以在方法中放置`return`语句，无论何时需要它们：一旦到达第一个`return`语句，控制就会返回给调用程序。'
- en: '*Single return value.* A Java method provides only one return value to the
    caller, of the type declared in the method signature.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单个返回值.* Java方法仅向调用者提供一个返回值，类型与方法签名中声明的类型相同。'
- en: '*Scope.* The *scope* of a variable is the part of the program that can refer
    to that variable by name. The general rule in Java is that the scope of the variables
    declared in a block of statements is limited to the statements in that block.
    In particular, the scope of a variable declared in a static method is limited
    to that method''s body. Therefore, you cannot refer to a variable in one static
    method that is declared in another.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作用域.* 变量的*作用域*是程序中可以通过名称引用该变量的部分。在Java中的一般规则是，声明在语句块中的变量的作用域仅限于该块中的语句。特别地，在静态方法中声明的变量的作用域仅限于该方法的主体。因此，你不能在一个静态方法中引用在另一个方法中声明的变量。'
- en: '![scope](../Images/3c280de39d60aa5cac3e30ee18360f10.png)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![作用域](../Images/3c280de39d60aa5cac3e30ee18360f10.png)'
- en: '*Side effects.* A *pure function* is a function that, given the same arguments,
    always returns the same value, without producing any observable *side effects*,
    such as consuming input, producing output, or otherwise changing the state of
    the system. The function `harmonic()` is an example of a pure function. However,
    in computer programming, we often define functions whose *only* purpose is to
    produce side effects. In Java, a static method may use the keyword `void` as its
    return type, to indicate that it has no return value.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*副作用。* 一个*纯函数*是一个函数，给定相同的参数，总是返回相同的值，而不产生任何可观察的*副作用*，比如消耗输入、产生输出或者改变系统的状态。函数
    `harmonic()` 是一个纯函数的例子。然而，在计算机编程中，我们经常定义函数的*唯一*目的是产生副作用。在 Java 中，一个静态方法可以使用关键字
    `void` 作为其返回类型，以指示它没有返回值。'
- en: '[FunctionExamples.java](FunctionExamples.java.html) gives a number of examples.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[FunctionExamples.java](FunctionExamples.java.html) 给出了一些例子。'
- en: Implementing mathematical functions.
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现数学函数。
- en: '![Gaussian distribution function and cumulative distribution function](../Images/f961302ed91566f87abcccdb590a620a.png)
    We now consider two important functions that play an important role in science,
    engineering, and finance. The *Gaussian (normal) distribution function* is characterized
    by the familiar bell-shaped curve and defined by the formula:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![高斯分布函数和累积分布函数](../Images/f961302ed91566f87abcccdb590a620a.png) 现在我们考虑两个在科学、工程和金融中起重要作用的函数。*高斯（正态）分布函数*
    以熟悉的钟形曲线为特征，并由以下公式定义：'
- en: $$ \phi(x) \;=\; \frac{1}{\sqrt{2 \pi}} e^{-x^2/2} $$
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \phi(x) \;=\; \frac{1}{\sqrt{2 \pi}} e^{-x^2/2} $$
- en: and the *cumulative Gaussian distribution function* \(\Phi(z)\) is defined to
    be the area under the curve defined by \(\phi(x)\) above the *x*-axis and to the
    left of the vertical line *x* = *z*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 累积高斯分布函数 \(\Phi(z)\) 被定义为曲线 \(\phi(x)\) 在 *x* 轴上方且在垂直线 *x* = *z* 左侧的面积。
- en: '*Closed form.* In the simplest situation, we have a closed-form mathematical
    equation defining our function in terms of functions that are implemented in the
    `Math` library. This is the case for \(\phi(x)\).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*闭式形式。* 在最简单的情况下，我们有一个以 `Math` 库中实现的函数为基础的闭式数学方程来定义我们的函数。这适用于 \(\phi(x)\)。'
- en: '*No closed form.* Otherwise, we may need a more complicated algorithm to compute
    function values. This situation is the case for \(\Phi(z)\), for which no closed-form
    expression exists. For small (respectively large) *z*, the value is extremely
    close to 0 (respectively 1); so the code directly returns 0 (respectively 1);
    otherwise the following Taylor series approximation is an effective basis for
    evaluating the function:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无闭式形式。* 否则，我们可能需要一个更复杂的算法来计算函数值。这种情况适用于 \(\Phi(z)\)，对于它没有闭式表达式。对于小（或大）的 *z*，值非常接近于
    0（或 1）；因此代码直接返回 0（或 1）；否则以下泰勒级数逼近是评估函数的有效基础：'
- en: $$ \begin{eqnarray*} \Phi(z) &= & \int_{-\infty}^{z} \phi(x) dx \\ & = & \frac{1}{2}
    \;+\; \phi(z) \; \left(z \;+\; \frac{z^3}{3} \;+\; \frac{z^5}{3 \cdot 5} \;+\;
    \frac{z^7}{3 \cdot 5 \cdot 7} \;+\; \ldots \;\; \right) \end{eqnarray*} $$
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \begin{eqnarray*} \Phi(z) &= & \int_{-\infty}^{z} \phi(x) dx \\ & = & \frac{1}{2}
    \;+\; \phi(z) \; \left(z \;+\; \frac{z^3}{3} \;+\; \frac{z^5}{3 \cdot 5} \;+\;
    \frac{z^7}{3 \cdot 5 \cdot 7} \;+\; \ldots \;\; \right) \end{eqnarray*} $$
- en: '[Gaussian.java](Gaussian.java.html) implements both of these static methods.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[Gaussian.java](Gaussian.java.html) 实现了这两个静态方法。'
- en: Using static methods to organize code.
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态方法来组织代码。
- en: With the ability to define functions, we can better organize our programs by
    defining functions within them when appropriate. For example, [Coupon.java](Coupon.java.html)
    is a version of [CouponCollector.java](../14array/CouponCollector.java.html) that
    better separates the individual components of the computation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义函数的能力，我们可以在适当时候在程序中定义函数来更好地组织我们的程序。例如，[Coupon.java](Coupon.java.html) 是
    [CouponCollector.java](../14array/CouponCollector.java.html) 的一个版本，更好地分离了计算的各个组件。
- en: Given *n*, compute a random coupon value.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定 *n*，计算一个随机优惠券值。
- en: Given *n*, do the coupon collection experiment.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定 *n*，进行优惠券收集实验。
- en: Get *n* from the command line, and then compute and print the result.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行获取 *n*，然后计算并打印结果。
- en: '*Whenever you can clearly separate tasks in programs, you should do so.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*每当你可以清晰地在程序中分离任务时，你应该这样做。*'
- en: Passing arguments and returning values.
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数和返回值。
- en: Next, we examine the specifics of Java's mechanisms for passing arguments to
    and returning values from functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细研究 Java 传递参数和从函数返回值的机制。
- en: '*Pass by value.* You can use parameter variables anywhere in the code in the
    body of the function in the same way you use local variables. The only difference
    between a parameter variable and a local variable is that Java evaluates the argument
    provided by the calling code and initializes the parameter variable with the resulting
    value. This approach is known as *pass by value*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值传递。* 你可以在函数体中的任何代码中使用参数变量，就像使用局部变量一样。参数变量和局部变量之间唯一的区别是，Java 评估调用代码提供的参数并用结果值初始化参数变量。这种方法称为*值传递*。'
- en: '*Arrays as arguments.* When a static method takes an array as an argument,
    it implements a function that operates on an arbitrary number of values of the
    same type.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组作为参数。* 当一个静态方法以数组作为参数时，它实现了一个操作相同类型任意数量值的函数。'
- en: '*Side effects with arrays.* It is often the case that the purpose of a static
    method that takes an array as argument is to produce a side effect (change values
    of array elements).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组的副作用。* 经常情况下，接受数组作为参数的静态方法的目的是产生副作用（改变数组元素的值）。'
- en: '*Arrays as return values.* A static method can also provide an array as a return
    value.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组作为返回值。* 静态方法也可以提供数组作为返回值。'
- en: '[ArrayFunctionExamples.java](ArrayFunctionExamples.java.html) gives a number
    of examples of arrays as arguments to and return values from functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[ArrayFunctionExamples.java](ArrayFunctionExamples.java.html) 给出了一些关于数组作为参数和返回值的函数的例子。'
- en: Superposition of sound waves.
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声波的叠加。
- en: 'Notes like concert A have a pure sound that is not very musical, because the
    sounds that you are accustomed to hearing have many other components. Most musical
    instruments produce *harmonics* (the same note in different octaves and not as
    loud), or you might play chords (multiple notes at the same time). To combine
    multiple sounds, we use *superposition*: simply add the waves together and rescale
    to make sure that all values stay between −1 and 1.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像A调这样的音符具有纯净的声音，不太具有音乐性，因为您习惯听到的声音还有许多其他成分。大多数乐器产生*谐波*（不同八度的相同音符，但不那么响亮），或者您可能演奏和弦（同时演奏多个音符）。要组合多个声音，我们使用*叠加*：简单地将波形相加并重新缩放，以确保所有值保持在−1和1之间。
- en: '![Superposition of sound waves](../Images/d0fdbd08c2c84e8b854b8c58c81b8cac.png)'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![声波的叠加](../Images/d0fdbd08c2c84e8b854b8c58c81b8cac.png)'
- en: '[PlayThatTuneDeluxe.java](PlayThatTuneDeluxe.java.html) is a version of [PlayThatTune](../15inout/PlayThatTune.java.html)
    that encapsulates the sound wave calculation and adds harmonics.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[PlayThatTuneDeluxe.java](PlayThatTuneDeluxe.java.html)是[PlayThatTune](../15inout/PlayThatTune.java.html)的一个版本，封装了声波计算并添加了谐波。'
- en: '![Flow of control of static methods](../Images/666a26697cffbc30a3b47b8fb597892a.png)'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![静态方法的控制流](../Images/666a26697cffbc30a3b47b8fb597892a.png)'
- en: 'Here a few sample data files (created by various students):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例数据文件（由各个学生创建）：
- en: '[Ascale.txt](Ascale.txt)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[音阶.txt](Ascale.txt)'
- en: '[elise.txt](elise.txt)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[伊莉莎白.txt](elise.txt)'
- en: '[StairwayToHeaven.txt](StairwayToHeaven.txt)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通往天堂的阶梯.txt](StairwayToHeaven.txt)'
- en: '[firstcut.txt](firstcut.txt)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[初稿.txt](firstcut.txt)'
- en: '[looney.txt](looney.txt)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[疯狂的.txt](looney.txt)'
- en: '[National_Anthem.txt](National_Anthem.txt)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[国歌.txt](National_Anthem.txt)'
- en: '[arabesque.txt](arabesque.txt)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阿拉伯舞曲.txt](arabesque.txt)'
- en: '[entertainer.txt](entertainer.txt)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[艺人.txt](entertainer.txt)'
- en: '[freebird.txt](freebird.txt)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自由鸟.txt](freebird.txt)'
- en: '[tomsdiner.txt](tomsdiner.txt)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[tomsdiner.txt](tomsdiner.txt)'
- en: Exercises
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Write a static method `max3()` that takes three `int` arguments and returns
    the value of the largest one. Add an overloaded function that does the same thing
    with three `double` values.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`max3()`，它接受三个`int`参数，并返回最大值。添加一个重载函数，使用三个`double`值执行相同的操作。
- en: '*Solution*:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Write a static method `majority()` that takes three `boolean` arguments and
    returns `true` if at least two of the arguments are `true`, and `false` otherwise.
    Do not use an `if` statement.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`majority()`，它接受三个`boolean`参数，并在至少两个参数为`true`时返回`true`，否则返回`false`。不要使用`if`语句。
- en: '*Solution*:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Write a static method `eq()` that takes two `int` arrays as arguments and returns
    `true` if the arrays have the same length and all corresponding pairs of elements
    are equal, and `false` otherwise.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`eq()`，它接受两个`int`数组作为参数，并在数组长度相同且所有对应元素相等时返回`true`，否则返回`false`。
- en: '*Solution.* [ArraysEquals.java](ArrayEquals.java.html).'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。[ArraysEquals.java](ArrayEquals.java.html)。'
- en: Write a static method `sqrt()` that takes a `double` argument and returns the
    square root of that number. Use Newton's method (see [Sqrt.java](../13flow/Sqrt.java.html))
    to compute the result.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`sqrt()`，它接受一个`double`参数，并返回该数字的平方根。使用牛顿法（参见[Sqrt.java](../13flow/Sqrt.java.html)）来计算结果。
- en: '*Solution*: [Newton.java](Newton.java.html).'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[Newton.java](Newton.java.html)。'
- en: Consider the static method `cube()` below.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑下面的静态方法`cube()`。
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How many times is the following `for` loop iterated?
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下`for`循环迭代了多少次？
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Answer*: Just 1,000 times.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：只有1,000次。'
- en: Creative Exercises
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Black–Scholes option valuation.** The [Black–Scholes](http://en.wikipedia.org/wiki/Black-Scholes)
    formula supplies the theoretical value of a European call option on a stock that
    pays no dividends, given the current stock price s, the exercise price x, the
    continuously compounded risk-free interest rate r, the volatility σ, and the time
    (in years) to maturity t. The value is given by the formula'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Black–Scholes期权估值。** [Black–Scholes](http://en.wikipedia.org/wiki/Black-Scholes)公式提供了不支付股息的股票上的欧式看涨期权的理论价值，给定当前股价`s`、行权价`x`、连续复利风险无息率`r`、波动率`σ`和到期时间（年）`t`。该值由以下公式给出'
- en: $$\Phi(a) - s x e^{-rt} \, \Phi(b)$$
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$\Phi(a) - s x e^{-rt} \, \Phi(b)$$
- en: where
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中
- en: $$ a = \frac{\ln(s/x) + (r + \sigma^2 / 2) t}{\sigma \sqrt{t}}, \;\; b = a -
    \sigma \sqrt{t} $$
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ a = \frac{\ln(s/x) + (r + \sigma^2 / 2) t}{\sigma \sqrt{t}}, \;\; b = a -
    \sigma \sqrt{t} $$
- en: Write a program [BlackScholes.java](BlackScholes.java.html) that takes s, x,
    r, sigma, and t from the command line and prints the Black-Scholes value.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[BlackScholes.java](BlackScholes.java.html)，从命令行获取`s`、`x`、`r`、`sigma`和`t`，并打印出Black-Scholes值。
- en: '**Calendar.** Write a program [Calendar.java](Calendar.java.html) that takes
    two integer command-line arguments `m` and `y` and prints the monthly calendar
    for the month `m` and year `y`, as in this example:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日历。** 编写一个程序[Calendar.java](Calendar.java.html)，它接受两个整数命令行参数`m`和`y`，并打印出月份`m`和年份`y`的月度日历，如下例所示：'
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Hint:* See [LeapYear.java](../12types/LeapYear.java.html) and Exercise 1.2.29.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：参见[LeapYear.java](../12types/LeapYear.java.html)和练习1.2.29。'
- en: '**Horner''s method.** Write a class [Horner.java](Horner.java.html) with a
    method `evaluate()` that takes a floating-point number `xp[]` as arguments and
    returns the result of evaluating the polynomial whose coefficients are the elements
    in `p[]` at `x`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**霍纳法**。编写一个类[Horner.java](Horner.java.html)，其中包含一个名为`evaluate()`的方法，该方法以浮点数数组`xp[]`作为参数，并返回在`x`处评估多项式的结果，其中`p[]`中的元素是系数：'
- en: $$p_0 + p_1x^1 + p_2x^2 + \; \ldots \; + p_{n-2}x^{n-2} + p_{n-1}x^{n-1}$$
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$p_0 + p_1x^1 + p_2x^2 + \; \ldots \; + p_{n-2}x^{n-2} + p_{n-1}x^{n-1}$$
- en: 'Use *Horner''s method*, an efficient way to perform the computations that is
    suggested by the following parenthesization:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*霍纳法*，这是一种执行计算的高效方法，建议使用以下括号化：
- en: $$p_0 + x (p_1 + x (p_2 + \; \ldots \; + x(p_{n-2} + x p_{n-1}) \ldots))$$
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$p_0 + x (p_1 + x (p_2 + \; \ldots \; + x(p_{n-2} + x p_{n-1}) \ldots))$$
- en: Write a test client with a static method `exp()` that uses `evaluate()` to compute
    an approximation to e^x, using the first *n* terms of the Taylor series expansion
    \(e^x = 1 + x + x^2/2! + x^3/3! + \ldots\) Your client should take a command-line
    argument `x` and compare your result against that computed by `Math.exp()`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个测试客户端，其中包含一个使用`evaluate()`计算近似值e^x的静态方法`exp()`，使用泰勒级数展开式的前*n*项\(e^x = 1
    + x + x^2/2! + x^3/3! + \ldots\)。您的客户端应该接受一个命令行参数`x`，并将您的结果与`Math.exp()`计算的结果进行比较。
- en: '**Benford''s law.** The American astronomer Simon Newcomb observed a quirk
    in a book that compiled logarithm tables: the beginning pages were much grubbier
    than the ending pages. He suspected that scientists performed more computations
    with numbers starting with 1 than with 8 or 9, and postulated the first digit
    law, which says that under general circumstances, the leading digit is much more
    likely to be 1 (roughly 30%) than the digit 9 (less than 4%). This phenomenon
    is known as [Benford''s law](http://mathworld.wolfram.com/BenfordsLaw.html) and
    is now often used as a statistical test. For example, IRS forensic accountants
    rely on it to discover [tax fraud](http://courses.nus.edu.sg/course/mathelmr/080498sci-benford.htm).
    Write a program [Benford.java](Benford.java.html) that reads in a sequence of
    integers from standard input and tabulates the number of times each of the digits
    1–9 is the leading digit, breaking the computation into a set of appropriate static
    methods. Use your program to test the law on some tables of information from your
    computer or from the web. Then, write a program to foil the IRS by generating
    random amounts from $1.00 to $1,000.00 with the same distribution that you observed.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本福德定律。** 美国天文学家西蒙·纽康布观察到一本编制对数表的书中的一个怪现象：开始的页面比结束的页面脏得多。他怀疑科学家们更多地使用以1开头的数字进行计算，而不是8或9，提出了第一位数定律，该定律指出在一般情况下，领先数字更有可能是1（大约30%）而不是数字9（不到4%）。这种现象被称为[本福德定律](http://mathworld.wolfram.com/BenfordsLaw.html)，现在经常被用作统计测试。例如，美国国税局的法务会计师依靠它来发现[税务欺诈](http://courses.nus.edu.sg/course/mathelmr/080498sci-benford.htm)。编写一个程序[Benford.java](Benford.java.html)，从标准输入读取一系列整数，并制表显示1-9中每个数字作为领先数字的次数，将计算分解为一组适当的静态方法。使用您的程序在计算机或网络上的一些信息表上测试该定律。然后，编写一个程序通过生成从$1.00到$1,000.00的随机金额来破坏国税局，使其具有您观察到的相同分布。'
- en: Web Exercises
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: '**Diamond tile.** Write a program [DiamondTile.java](DiamondTile.java.html)
    that takes a command-line argument N and creates an N-by-N tile of diamonds. Include
    static methods `diamond()` and `filledDiamond()`.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**菱形瓷砖。** 编写一个程序[DiamondTile.java](DiamondTile.java.html)，接受一个命令行参数N，并创建一个N×N的菱形瓷砖。包括静态方法`diamond()`和`filledDiamond()`。'
- en: '**Hexagonal tile.** Write a program [HexTile.java](HexTile.java.html) that
    takes a command-line argument N and creates an N-by-N tile of hexagons. Include
    static methods `hexagon()` and `filledHexagon()`.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**六边形瓷砖。** 编写一个程序[HexTile.java](HexTile.java.html)，接受一个命令行参数N，并创建一个N×N的六边形瓷砖。包括静态方法`hexagon()`和`filledHexagon()`。'
- en: '**Inverse Gaussian cumulative distribution.** Suppose SAT math scores are normally
    distributed with mean 500 and standard deviation. Estimate how high student must
    score in order to be among the top 10%. To do this you need to find the value
    *z* for which Φ(z, 500, 100) = 0.9. *Hint:* use binary search.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆高斯累积分布。** 假设SAT数学成绩服从均值500和标准差的正态分布。估计学生必须获得多高的分数才能成为前10%。为了做到这一点，您需要找到值*z*，使得Φ(z,
    500, 100) = 0.9。*提示:* 使用二分查找。'
- en: '**SAT scores.** A prominent northeastern university receives 20,000 student
    applications. Assume that the SAT scores of these individuals is normally distributed
    with mean 1200 and standard deviation 100\. Suppose the university decides to
    admit the 5,000 students with the best SAT scores. Estimate the lowest score that
    will still be admitted.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SAT成绩。** 一所著名的东北大学收到2万份学生申请。假设这些个体的SAT成绩服从均值1200和标准差100的正态分布。假设大学决定录取SAT成绩最好的5000名学生。估计仍然会被录取的最低分数。'
- en: '**Voting machines.** Suppose that in a population of 100 million voters, 51%
    vote for candidate A and 49% vote for candidate B. However, the voting machines
    are prone to make mistakes, and 5% of the time they produce the wrong answer.
    Assuming the errors are made independently and at random, is a 5% error rate enough
    to invalidate the results of a close election? What error rate can be tolerated?'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**投票机。** 假设在一个拥有1亿选民的人口中，51%投票给候选人A，49%投票给候选人B。然而，投票机容易出错，有5%的概率产生错误答案。假设错误是独立且随机发生的，5%的错误率足以使紧密选举的结果无效吗？可以容忍什么错误率？'
- en: '**Gambler''s histogram.** Write a program `RandomWalk.java` that takes one
    command line parameter M and simulates a gambler starting with M who places exactly
    M one dollar bets.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**赌徒的直方图。** 编写一个程序`RandomWalk.java`，接受一个命令行参数M，并模拟一个从M开始的赌徒，下注正好M美元。'
- en: Produce a histogram of the amount of money the gambler ends up with by running
    this experiment N times.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个实验N次，生成赌徒最终赢得的金额的直方图。
- en: The amount of money the gambler ends up with follows a binomial distribution
    with mean M and variance N/4\. The distribution can be approximated by a normal
    distribution with the same mean and variance. Produce a histogram for the fraction
    of time you'd expect the gambler to end up with the amount in each histogram bin.Organize
    your program up into several functions.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 赌徒最终赢得的金额遵循二项分布，均值为M，方差为N/4。该分布可以用具有相同均值和方差的正态分布来近似。生成一个直方图，显示您预期赌徒最终在每个直方图箱中获得的金额的比例。将您的程序组织成几个函数。
- en: '**Statistical sampling.** Write a program [Sampling.java](Sampling.java.html)
    takes a random sample of N people and asks them a yes/no question. Compute a 95%
    confidence interval.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**统计抽样。** 编写一个程序[Sampling.java](Sampling.java.html)，随机抽取N个人并向他们提出一个是/否问题。计算95%的置信区间。'
- en: '**Blackjack.** Write a program `Blackjack.java` that plays the [basic strategy](http://www.blackjackcenter.com/blackjack3.html)
    or write a program `BlackjackCounter.java` that implements the [high-low card
    counting system](http://www.blackjackcenter.com/blackjack4.html).'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二十一点。** 编写一个程序`Blackjack.java`来玩[基本策略](http://www.blackjackcenter.com/blackjack3.html)，或者编写一个程序`BlackjackCounter.java`来实现[高低计数系统](http://www.blackjackcenter.com/blackjack4.html)。'
- en: '**Wavelets.** Applications to computer vision, human vision, speech processing,
    compressing the FBI fingerprint database, filtering noisy data, detecting self-similarity
    in time series, sound synthesis, computer graphics, medical imaging, analyzing
    the clumping of galaxies, and analyzing turbulence. The *Haar function* is definite
    by Φ(x) = 1 if 0 ≤ x < 1/2, Φ(x) = -1 if 1/2 ≤ x < 1, and Φ(x) = 0 otherwise.
    For integer m and n, the *Haar basis function* Φ[m,n](x) = 2^(-m/2) Φ(2^(-m)x
    - n). Write a program `Haar.java` that takes two integer input M and N, and one
    real input x and prints Φ[m,n](x). Or maybe plot it?'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**小波。** 应用于计算机视觉、人类视觉、语音处理、压缩FBI指纹数据库、过滤嘈杂数据、检测时间序列中的自相似性、声音合成、计算机图形学、医学成像、分析星系的聚集以及分析湍流。*Haar函数*由Φ(x)
    = 1（如果0 ≤ x < 1/2）、Φ(x) = -1（如果1/2 ≤ x < 1）和Φ(x) = 0（否则）定义。对于整数m和n，*Haar基函数*Φ[m,n](x)
    = 2^(-m/2) Φ(2^(-m)x - n)。编写一个程序`Haar.java`，它接受���个整数输入M和N，一个实数输入x，并打印Φ[m,n](x)。或者可能绘制它？'
- en: '**Baccarat.** [Baccarat](http://www.robohoo.com/baccarat.html) is a simple
    card game which has been romanticized in James Bond movies. When the player is
    dealt nine, the croupier proclaims "neuf a la banque". Write a program that determines
    your chance of winning....'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Baccarat.** [百家乐](http://www.robohoo.com/baccarat.html)是一种简单的纸牌游戏，在詹姆斯·邦德电影中被浪漫化。当玩家得到九时，庄家宣布“neuf
    a la banque”。编写一个程序来确定你赢得胜利的机会......'
- en: '**Collinear points.** Write a function'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**共线点。** 编写一个函数'
- en: '[PRE5]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: that returns `true` if the three points (x1, y1), (x2, y2), and (x3, y3) lie
    on the same line, and `false` otherwise.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果三个点（x1，y1），（x2，y2）和（x3，y3）在同一条直线上，则返回`true`，否则返回`false`。
- en: '**Gauss error function.** The [error function](http://en.wikipedia.org/wiki/Error_function)
    is a function that arises in probability, statistics, and solutions to differential
    equations. For example, Φ(z) = 1/2 + (1 + erf(z / sqrt(2))), where Φ(z) is the
    Gaussian cumulative distribution function defined above.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高斯误差函数。** [误差函数](http://en.wikipedia.org/wiki/Error_function)是在概率、统计和微分方程解决方案中出现的函数。例如，Φ(z)
    = 1/2 + (1 + erf(z / sqrt(2)))，其中Φ(z)是上面定义的高斯累积分布函数。'
- en: '![Error function](../Images/cf9d3ae1284212a5bfaf77eb1241b920.png)'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![误差函数](../Images/cf9d3ae1284212a5bfaf77eb1241b920.png)'
- en: 'The integral has no closed form solution in terms of [elementary functions](http://en.wikipedia.org/wiki/Elementary_function_%28differential_algebra%29)
    so we resort to approximations. When `z` is nonnegative, the Chebyshev fitting
    estimate below is accurate to 7 significant digits:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[初等函数](http://en.wikipedia.org/wiki/Elementary_function_%28differential_algebra%29)的术语中，积分没有封闭形式的解，因此我们求助于近似。当`z`为非负时，下面的切比雪夫拟合估计精确到7个有效数字：
- en: '![Chebyshev approximation to error function](../Images/51e6ed548e51d94c1cdfe775fe181824.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![切比雪夫逼近误差函数](../Images/51e6ed548e51d94c1cdfe775fe181824.png)'
- en: If *z* is negative, use the identity *erf(z) = -erf(-z)*. A particularly efficient
    way to implement it is via a judicious use of parentheses known as *Horner's method*.
    Write a function `erf()` in [ErrorFunction.java](ErrorFunction.java.html) takes
    one real input `z` and computes the *error function* using the formula above.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果*z*为负数，则使用*erf(z) = -erf(-z)*的恒等式。实现它的一种特别有效的方法是通过一种称为*霍纳方法*的括号的巧妙使用。编写一个函数`erf()`在[ErrorFunction.java](ErrorFunction.java.html)中，它接受一个实数输入`z`并使用上述公式计算*误差函数*。
- en: '**Haversine.** Write a function `haversine()` that takes one `double` argument
    `θ` and returns haversine(θ) = (sin(θ/2))^2.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Haversine。** 编写一个函数`haversine()`，它接受一个`double`参数`θ`并返回haversine(θ) = (sin(θ/2))^2。'
- en: '**Soil temperature.** (Cleve Moler) Suppose the soil temperature is uniformly
    Ti (20 degrees C) at the surface and beneath. A cold front moves in and the surface
    temperature Ts (-15 C) remains for the foreseeable future. The temperature T(x,
    t) at time t seconds of the soil at x meters beneath the surface is given by T(x,
    t) = Ts + (Ti - Ts) erf(x / 2 sqrt(alpha t)), where alpha (0.138 * 10^-6 m^2 /
    s) is the thermal conductivity of the soil. What is the temperature at 10 meters
    after 30 days of exposure to these conditions? How long until water freezes (0
    degrees) at 5 meters beneath the surface? How deep to dig a water main so that
    it can withstand 60 days of exposure to these conditions without freezing?'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**土壤温度。** （克利夫·莫勒）假设土壤温度在表面和下面均匀为Ti（20摄氏度）。一股冷锋来袭，表面温度Ts（-15摄氏度）在可预见的未来保持不变。在暴露于这些条件下30天后，10米深处的土壤温度是多少？在表面以下5米处水结冰需要多长时间？挖掘水管的深度是多少，以便在这些条件下暴露60天而不结冰？'
- en: '**Craps.** Calculate the probability of winning a *pass bet* in craps. Here
    are the rule for a pass bet. Roll two 6-sided dice, and let *x* be their sum.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Craps.** 计算在craps中赢得*pass bet*的概率。以下是pass bet的规则。掷两个6面骰子，让*x*为它们的和。'
- en: if *x* is 7 or 11, you win instantly
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*为7或11，则立即获胜
- en: if *x* is 2, 3, or 12, you lose instantly
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*为2、3或12，则立即失败
- en: otherwise, repeatedly roll two dice until their sum is either *x* or 7
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，重复掷两个骰子，直到它们的和为*x*或7
- en: if their sum is *x*, you win
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们的和为*x*，则获胜
- en: if their sum is 7, you lose
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们的和为7，则失败
- en: 'Program [Craps.java](Craps.java.html) takes a command line parameter N and
    simulates N pass bets. The program''s organization benefits from two helper functions:
    `sumOfTwoDice` and `winsPassBet`. Both functions have one interesting feature
    - they do not take any input arguments. The first function simulate the throw
    of two dice. This returns an integer between 2 and 12, but not all values are
    equally likely. To simulate the probabilities correctly, we call `StdRandom.random(6)`
    twice and one to generate a number between 1 and 6\. Then, we add the two values.
    The second function returns a `boolean` value: `true` if we win the pass bet and
    `false` otherwise. This function has several `return` statements. As soon as the
    first one is executed, the function terminates with the given return value.'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序[Craps.java](Craps.java.html)接受一个命令行参数N，并模拟N次通过投注。该程序的组织受益于两个辅助函数：`sumOfTwoDice`和`winsPassBet`。这两个函数都有一个有趣的特点-它们不接受任何输入参数。第一个函数模拟掷两个骰子。这返回一个介于2和12之间的整数，但并非所有值都是等概率的。为了正确模拟概率，我们调用`StdRandom.random(6)`两次，一次生成1到6之间的数字。然后，我们将这两个值相加。第二个函数返回一个`boolean`值：如果我们赢得通过投注，则返回`true`，否则返回`false`。该函数有几个`return`语句。一旦执行第一个语句，函数将终止并返回给定的返回值。
- en: '**Musical scale.** Using the function `note()`, write a program [Scale.java](Scale.java.html)
    to play a major scale.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**音阶。**使用函数`note()`，编写一个程序[Scale.java](Scale.java.html)来演奏一个大调音阶。'
- en: '**Primality testing.** Create a function `isPrime()` that takes an integer
    argument N and returns true or false depending on whether N is prime.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**素数测试。**创建一个名为`isPrime()`的函数，它接受一个整数参数N，并根据N是否为素数返回true或false。'
- en: '[PRE6]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Electronic funds transfer routing number check.** Given a 9 digit EFT routing
    number a[1]a[2]a[3]a[4]a[5]a[6]a[7]a[8]a[9] the check equation is'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电子资金转账路由号检查。**给定一个9位EFT路由号a[1]a[2]a[3]a[4]a[5]a[6]a[7]a[8]a[9]，检查方程式为'
- en: 3 a[1] + 7a[2] + a[3] + 3a[4] + 7a[5] + a[6] +3a[7] +7a[8] +a[9] mod 10 = 0
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3 a[1] + 7a[2] + a[3] + 3a[4] + 7a[5] + a[6] +3a[7] +7a[8] +a[9] mod 10 = 0
- en: '[Check digit reference](http://www.augustana.ab.ca/~mohrj/algorithms/checkdigit.html).'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[校验位参考](http://www.augustana.ab.ca/~mohrj/algorithms/checkdigit.html)。'
- en: Write a static method `nint()` that takes a real number as a parameter and returns
    the nearest integer. Do not use any Math library function, instead use casting.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`nint()`，它接受一个实数作为参数，并返回最接近的整数。不要使用任何Math库函数，而是使用强制转换。
- en: Write a static method `int mod(int a, int n)`, where `a` is an integer and `n`
    is a positive integer, and returns a mod n. This corresponds to `a % n` when `a`
    is positive, but if `a` is negative, `a % n` returns a non-positive integer.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`int mod(int a, int n)`，其中`a`是整数，`n`是正整数，并返回模n。当`a`为正数时，这对应于`a % n`，但如果`a`为负数，则`a
    % n`返回一个非正整数。
- en: '**Present value.**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现值。**'
- en: Write a method `fv` that computes the amount of money you will have if you invest
    C dollars today at the compound interest rate of r per period, in T periods. The
    formula for the *future value* is given by C*(1 + r)^T.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`fv`的方法，计算如果您以复利利率r每期投资C美元，T期后您将拥有的金额。*未来价值*的公式为C*(1 + r)^T。
- en: Write a method `pv` that computes the amount of money that would have to be
    invested now, at the compound interest rate r per period, to obtain a cash flow
    of C in T periods. The formula for the *present value* is given by C/(1 + r)^T.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`pv`的方法，计算现在必须投资多少金额，以每期复利利率r获得T期内的现金流。*现值*的公式为C/(1 + r)^T。
- en: The ACT is another standardized test. Assume that test scores follow a Gaussian
    distribution with mean 18 and standard deviation 6. Also assume that the test
    takers for SAT and ACT are indistinguishable. Which is better, an SAT score of
    620 or ACT of 26?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ACT是另一种标准化测试。假设测试分数遵循均值为18，标准差为6的高斯分布。还假设参加SAT和ACT考试的考生是无法区分的。620分的SAT分数和26分的ACT哪个更好？
- en: 'Write a program [Factorial.java](Factorial.java.html) that takes one integer
    command line input n and prints out n! = 1 * 2 * ... * n. Write a function that
    has the following signature:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Factorial.java](Factorial.java.html)，接受一个整数命令行输入n，并打印出n! = 1 * 2 * ...
    * n。编写一个具有以下签名的函数：
- en: '[PRE7]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What is the largest value of n that your function can handle without overflow?
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的函数能处理的最大n值是多少，而不会发生溢出？
- en: What is wrong with the following function?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数有什么问题？
- en: '[PRE8]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Answer*: The function is declared to return a value of type `int`. The first
    return statement is wrong since it returns nothing. The second return statement
    is wrong since it returns a value of type `double`.'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：该函数声明要返回类型为`int`的值。第一个返回语句是错误的，因为它不返回任何内容。第二个返回语句是错误的，因为它返回类型为`double`的值。'
- en: What does the following do?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码是做什么的？
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Answer*: It prints `17` twice. A function cannot change the value of a primitive
    type variable in another function.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：它两次打印`17`。一个函数无法改变另一个函数中的基本类型变量的值。'
- en: Write a function that takes three real arguments, x, y, and s, and plots an
    equilateral triangle centered on (x, y) with side length s. Call the function
    a number of times in `main` to produce an entertaining pattern.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受三个实数参数x、y和s，并绘制以(x, y)为中心，边长为s的等边三角形。在`main`中多次调用该函数以产生一个有趣的图案。
- en: Which of the following functions returns the minimum of its four inputs? Which
    is easiest to understand and verify that it is correct?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数中哪个返回其四个输入中的最小值？哪个最容易理解和验证其正确性？
- en: '[PRE10]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How would you go about testing whether one of the functions in the previous
    exercise does what it claims to do?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将如何测试前一个练习中的函数是否按照其所声称的那样工作？
- en: '*Answer*: you can''t hope to test it on every conceivable input since there
    are 2^(128) different possible inputs. Instead, test it on all 4! = 24 cases depending
    on whether a < b, a < c, ..., c < d. Or all 4^4 permutations of 0, 1, 2, and 3.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：你无法希望在每种可能的输入上进行测试，因为有2^(128)种不同的可能输入。相反，根据a < b，a < c，...，c < d的24种情况中的每一种，测试所有4！=
    24种情况。或者测试0、1、2和3的所有4^4种排列。'
- en: What's wrong with the following method call?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下方法调用有什么问题？
- en: '[PRE11]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It re-declare the variable `y` when calling `sqrt()`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用`sqrt()`时重新声明变量`y`。
- en: '**Sawtooth.** Write a program [SawTooth.java](SawTooth.java.html) to plot 2/pi
    [sin(1t)/1 + sint(2t)/2 + sin(3t)/3 + ... ]. As you plot more and more terms,
    the wave converges to a [sawtooth wave](http://en.wikipedia.org/wiki/Sawtooth_wave).
    Then play it using standard audio.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**锯齿波。** 编写一个程序 [SawTooth.java](SawTooth.java.html) 来绘制 2/pi [sin(1t)/1 + sint(2t)/2
    + sin(3t)/3 + ... ]。随着绘制更多项，波形会收敛到一个 [锯齿波](http://en.wikipedia.org/wiki/Sawtooth_wave)。然后使用标准音频播放它。'
- en: '**Square wave.** Plot 4/pi [sin(1*2*pi*t)/1 + sint(3*2*pi*t)/3 + sin(5*2*pi*t)/5
    + ... ]. As you plot more and more terms, the wave converges to a [square wave](http://en.wikipedia.org/wiki/Square_wave).
    Then play it using standard audio.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**方波。** 绘制 4/pi [sin(1*2*pi*t)/1 + sint(3*2*pi*t)/3 + sin(5*2*pi*t)/5 + ...
    ]。随着绘制更多项，波形会收敛到一个 [方波](http://en.wikipedia.org/wiki/Square_wave)。然后使用标准音频播放它。'
- en: Write a program to print the lyrics to Old McDonald.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来打印 Old McDonald 的歌词。
- en: '[PRE12]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Write a static method `maxwellBoltzmann()` that returns a pseudo-random value
    from a *Maxwell-Boltzmann distribution* with parameter σ. To produce such a value,
    take the sum of the squares of three Gaussian random variables with mean 0 and
    standard deviation σ, and return the square root. The speeds of molecules in an
    ideal gas have a Maxwell-Boltzmann distribution, where the parameter σ is related
    to XYZ.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法 `maxwellBoltzmann()`，它返回一个从 *Maxwell-Boltzmann 分布* 中伪随机值，参数为 σ。为了生成这样的值，取三个均值为
    0，标准差为 σ 的高斯随机变量的平方和，然后返回平方根。理想气体中分子的速度具有 Maxwell-Boltzmann 分布，其中参数 σ 与 XYZ 有关。
- en: Write a static method `reverse1()` that takes a string array as an argument
    and creates a new array with the entries in reverse order (and does not change
    the order of the entries in the argument array). Write a static method `reverse2()`
    that takes a string array as an argument and reverses its entries. Put your code
    in a program [Reverse.java](Reverse.java.html).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法 `reverse1()`，它以字符串数组作为参数，并创建一个按相反顺序排列的新数组（不改变参数数组中的顺序）。编写一个静态方法 `reverse2()`，它以字符串数组作为参数，并颠倒其条目。将你的代码放在一个名为
    [Reverse.java](Reverse.java.html) 的程序中。
- en: Which function gets called by `f(1, 2)` if I have two overloaded functions
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我有两个重载函数时，`f(1, 2)`调用哪个函数？
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Solution.* Ordinarily, Java''s type promotion rules would promote either `int`
    argument to `double`. However, in this case, that would result in two matching
    overloaded signatures. Since Java can''t resolve the ambiguity, [Overloaded.java](Overloaded.java.html)
    results in a compile-time error.'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。通常，Java 的类型提升规则会将任一 `int` 参数提升为 `double`。然而，在这种情况下，这将导致两个匹配的重载签名。由于
    Java 无法解决这种歧义，[Overloaded.java](Overloaded.java.html) 导致编译时错误。'
- en: '**Gaussian random values.** Experiment with the following method for generating
    random variables from the Gaussian distribution, which is based on generating
    a random point in the unit circle and using a form of the [Box-Muller transform](http://en.wikipedia.org/wiki/Box-Muller_transform).
    (see Exercise 1.2.27 and the discussion of do-while at the end of Section 1.3).'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高斯随机值。** 尝试使用以下方法生成服从高斯分布的随机变量，该方法基于在单位圆内生成一个随机点，并使用一种 [Box-Muller 变换](http://en.wikipedia.org/wiki/Box-Muller_transform)
    的形式。（参见练习 1.2.27 和第 1.3 节末尾关于 do-while 的讨论）。'
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Take a command-line argument N and generate N random numbers, using an array
    a[20] to count the numbers generated that fall between i*.05 and (i+1)*.05 for
    i from 0 to 19\. Then use `StdDraw` to plot the values and to compare your result
    with the normal bell curve.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受一个命令行参数 N，并生成 N 个随机数，使用数组 a[20] 计算生成的数字落在 i*.05 和 (i+1)*.05 之间的次数，其中 i 从 0
    到 19。然后使用 `StdDraw` 绘制这些值，并将结果与正态钟形曲线进行比较。
- en: '*Remark*: This method is preferred over the one described in Exercise XYZ for
    both efficiency and accuracy. Although it involves a loop, the do-while loop is
    executed only 4 / π = 1.273 times on average. This reduces the overall expected
    number of calls to transcendental functions.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*备注*：这种方法在效率和准确性上优于练习 XYZ 中描述的方法。虽然涉及循环，但 do-while 循环平均只执行 4 / π = 1.273 次。这减少了对超越函数的整体预期调用次数。'
