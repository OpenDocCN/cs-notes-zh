- en: 2.1 Defining Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 定义函数
- en: 原文：[https://introcs.cs.princeton.edu/python/21function](https://introcs.cs.princeton.edu/python/21function)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/21function](https://introcs.cs.princeton.edu/python/21function)
- en: 'You have been composing code that calls Python functions since the beginning
    of this booksite. In this section, you will learn how to define and call your
    own functions. Functions support a key concept that will pervade your approach
    to programming from this point forward: *Whenever you can clearly separate tasks
    within a computation, you should do so*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书站点的开始，您一直在编写调用Python函数的代码。在本节中，您将学习如何定义和调用自己的函数。函数支持一个关键概念，从现在开始将贯穿您的编程方法：*每当您可以清晰地将计算中的任务分开时，您都应该这样做*。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Using and Defining Functions
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用和定义函数
- en: The effect of calling a Python function is easy to understand. For example,
    when you place `math.sqrt(a-b)` in a program, the effect is as if you had replaced
    that code with the return value that is produced by Python's `math.sqrt()` function
    when passed the expression `a-b` as an argument. If you think about what the system
    has to do to create this effect, you will see that it involves changing a program's
    *control flow*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 调用Python函数的效果很容易理解。例如，当您在程序中放置`math.sqrt(a-b)`时，效果就好像您用Python的`math.sqrt()`函数传递表达式`a-b`作为参数时替换了该代码的返回值。如果您考虑系统为实现此效果所必须做的工作，您将看到它涉及更改程序的*控制流*。
- en: 'You can define a function using a `def` statement that specifies the function
    signature, followed by a sequence of statements that constitute the function.
    For example, [harmonicf.py](harmonicf.py.html) defines a function named `harmonic()`
    that takes an argument `n` and computes the `n`th harmonic number (as described
    in Section 1.3). It also illustrates the typical structure of a Python program,
    having three components:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`def`语句定义函数，该语句指定函数签名，后跟构成函数的一系列语句。例如，[harmonicf.py](harmonicf.py.html)定义了一个名为`harmonic()`的函数，该函数接受一个参数`n`并计算第`n`个调和数（如第1.3节中所述）。它还说明了Python程序的典型结构，包括三个组件：
- en: A sequence of `import` statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列`import`语句
- en: A sequence of *function definitions*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列*函数定义*
- en: Arbitrary *global code*, or the body of the program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意*全局代码*，或程序的主体
- en: Python executes the global code when we invoke the program by typing `python
    harmonicf.py` on the command line; that global code calls the `harmonic()` function
    defined earlier. (For purposes of illustration, we have made the user-interaction
    part of the program a bit more complicated than in Section 1.3.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在命令行上键入`python harmonicf.py`调用程序时，Python执行全局代码；该全局代码调用了先前定义的`harmonic()`函数。（为了说明，我们使程序的用户交互部分比第1.3节中更复杂。���
- en: '![Control flow](../Images/42bb3946ff29fd57df3486bca11d48f8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![控制流程](../Images/42bb3946ff29fd57df3486bca11d48f8.png)'
- en: Control flow.
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流程。
- en: The diagram shown at the right illustrates the flow of control for the command
    `python harmonicf.py 1 2 3`. First, Python processes the `import` statements,
    thus making all of the features defined in the `sys` and `stdio` modules available
    to the program. Next, Python processes the definition of the `harmonic()` function
    at lines 4 through 8, but does not execute the function — Python executes a function
    only when it is called. Then, Python executes the first statement in the global
    code after the function definition, the `for` statement, which proceeds normally
    until Python begins to execute the statement `value = harmonic(arg)`, starting
    by evaluating the expression `harmonic(arg)` when `arg` is 1\. To do so it transfers
    control to the `harmonic()` function — the flow of control passes to the code
    in the function definition. Python initializes the "parameter" variable `n` to
    1 and the "local" variable `total` to 0.0 and then executes the `for` loop within
    `harmonic()`, which terminates after one iteration with total equal to 1.0\. Then,
    Python executes the `return` statement at the end of the definition of `harmonic()`,
    causing the flow of control to jump back to the calling statement `value = harmonic(arg)`,
    continuing from where it left off, but now with the expression `harmonic(arg)`
    replaced by 1.0\. Thus, Python assigns 1.0 to `value` and writes it to standard
    output. Then, Python iterates the loop once more, and calls the `harmonic()` function
    a second time with `n` initialized to 2, which results in 1.5 being written. The
    process is then repeated a third time with `arg` (and then `n`) equal to 4, which
    results in 2.083333333333333 being written. Finally, the for loop terminates and
    the whole process is complete. As the diagram indicates, the simple code masks
    a rather intricate flow of control. ![Informal trae with function call/return](../Images/4593b51b852ccdfeafebb560676e20e1.png)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧显示的图表说明了命令`python harmonicf.py 1 2 3`的控制流程。首先，Python处理`import`语句，从而使程序中定义的`sys`和`stdio`模块中的所有功能可用。接下来，Python处理了第4到8行中`harmonic()`函数的定义，但不执行该函数
    — Python只有在调用函数时才执行函数。然后，Python执行函数定义后全局代码中的第一条语句，即`for`语句，直到Python开始执行语句`value
    = harmonic(arg)`，从`arg`为1开始正常进行。为此，它将控制传递给`harmonic()`函数 — 控制流程传递到函数定义中的代码。Python将“参数”变量`n`初始化为1，将“局部”变量`total`初始化为0.0，然后执行`harmonic()`中的`for`循环，该循环在一次迭代后终止，总和等于1.0。然后，Python执行`harmonic()`定义末尾的`return`语句，导致控制流跳回到调用语句`value
    = harmonic(arg)`，从离开的地方继续，但现在表达式`harmonic(arg)`被替换为1.0。因此，Python将1.0赋给`value`并将其写入标准输出。然后，Python再次迭代循环，并第二次调用`harmonic()`函数，其中`n`初始化为2，结果为1.5。然后，该过程再次重复，`arg`（然后`n`）等于4，结果为2.083333333333333。最后，`for`循环终止，整个过程完成。正如图表所示，简单的代码掩盖了相当复杂的控制流程。![带有函数调用/返回的非正式跟踪](../Images/4593b51b852ccdfeafebb560676e20e1.png)
- en: Informal function call/return trace.
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非正式函数调用/返回跟踪。
- en: One simple approach to following the control flow through function calls is
    to imagine that each function writes its name and argument(s) when it is called
    and its return value just before returning, with indentation added on calls and
    subtracted on returns. The result enhances the process of tracing a program by
    writing the values of its variables, which we have been using since Section 1.2\.
    An informal trace for our example is shown at right.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数调用跟踪控制流的一个简单方法是想象每个函数在被调用时写下其名称和参数，以及在返回之前写下其返回值，调用时增加缩进，返回时减少缩进。这个结果通过写入变量的值来增强程序的追踪过程，我们从第1.2节开始一直在使用。我们的示例的非正式追踪如右侧所示。
- en: Basic terminology.
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本术语。
- en: 'There are several concepts rolled up in the idea of a mathematical function
    and there are Python constructs corresponding to each, as summarized in this table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数的概念中包含了几个概念，对应于每个概念在Python中都有相应的构造，如下表所总结的：
- en: '![Function terminology](../Images/31a5ddf3b870ee87db5ba1b1ad6e5919.png)'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![函数术语](../Images/31a5ddf3b870ee87db5ba1b1ad6e5919.png)'
- en: When we use a symbolic name in a formula that defines a mathematical function
    (such as *f*(*x*) = 1 + *x* + *x*²), the symbol *x* is a placeholder for some
    input value that will be substituted into the formula to determine the output
    value. In Python, we use a *parameter variable* as a symbolic placeholder and
    we refer to a particular input value where the function is to be evaluated as
    an *argument*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在定义数学函数的公式中使用符号名称（例如*f*(*x*) = 1 + *x* + *x*²）时，符号*x*是某个输入值的占位符，将被替换到公式中以确定输出值。在Python中，我们使用*参数变量*作为符号占位符，并将要评估函数的特定输入值称为*参数*。
- en: '![Anatomy of a function definition](../Images/e7619165b0e2364fbc373bc7f16009c4.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![函数定义的解剖](../Images/e7619165b0e2364fbc373bc7f16009c4.png)'
- en: Function definition.
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数定义。
- en: The first line of a function definition, known as its *signature*, gives a name
    to the function and to each parameter variable. The signature consists of the
    keyword `def`; the function name; a sequence of zero or more parameter variable
    names separated by commas and enclosed in parentheses; and a colon. The indented
    statements following the signature define the function body. The function body
    can consist of the kinds of statements that we discussed in Chapter 1\. It also
    can contain a return statement, which transfers control back to the point where
    the function was called and returns the result of the computation or return value.
    The body may also define *local variables*, which are variables that are available
    only inside the function in which they are defined. ![Anatomy of a function call](../Images/6ba6c19a8926b071bb1134e02e18286e.png)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的第一行，也称为*签名*，为函数和每个参数变量赋予名称。签名由关键字`def`、函数名称、由逗号分隔并括在括号中的零个或多个参数变量名称序列以及冒号组成。缩进的语句跟在签名后面定义函数体。函数体可以包含我们在第1章讨论过的各种语句。它还可以包含一个返回语句，将控制转移到调用函数的地方，并返回计算结果或返回值。函数体还可以定义*局部变量*，这些变量仅在定义它们的函数内部可用。![函数调用的解剖](../Images/6ba6c19a8926b071bb1134e02e18286e.png)
- en: Function calls.
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数调用。
- en: As we have seen throughout, a Python function call is nothing more than the
    function name followed by its arguments, separated by commas and enclosed in parentheses.
    Each argument can be an expression, which is evaluated and the resulting value
    passed as input to the function. When the function finishes, the return value
    takes the place of the function call as if it were the value of a variable (perhaps
    within an expression).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一直看到的，Python函数调用只是函数名称后跟其参数，用逗号分隔并括在括号中。每个参数可以是一个表达式，它被评估并将结果值作为输入传递给函数。当函数完成时，返回值取代函数调用的位置，就像它是一个变量的值（可能在表达式中）。
- en: Multiple arguments.
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个参数。
- en: Like a mathematical function, a Python function can have more than one parameter
    variable, so it can be called with more than one argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 像数学函数一样，Python函数可以有多个参数变量，因此可以用多个参数调用它。
- en: Multiple functions.
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个函数。
- en: You can define as many functions as you want in a .py file. The functions are
    independent, except that they may refer to each other through calls. However,
    the definition of a function must appear before any global code that calls it.
    That is the reason that a typical Python program contains (1) `import` statements,
    (2) function definitions, and (3) arbitrary global code, in that order.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一个.py文件中定义任意数量的函数。这些函数是独立的，除非它们通过调用相互引用。但是，函数的定义必须出现在调用它的任何全局代码之前。这就是典型的Python程序包含（1）`import`语句，（2）函数定义和（3）任意全局代码的原因，按照这个顺序。
- en: Multiple return statements.
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个返回语句。
- en: 'You can put `return` statements in a function wherever you need them: control
    goes back to the calling program as soon as the first `return` statement is reached.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在函数中放置`return`语句，无论何时需要它们：一旦到达第一个`return`语句，控制就会返回到调用程序。
- en: Single return value.
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个返回值。
- en: A Python function provides only one return value to the caller (or, more precisely,
    it returns a reference to one object). This policy is not as restrictive as it
    might seem, because Python data types can contain more information than a single
    number, boolean, or string. For example, you will see later in this section that
    you can use arrays as return values. ![Scope of local and parameter variables](../Images/4a2a8c52ed26f31945f753d598009f0e.png)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数仅向调用者提供一个返回值（或更准确地说，它返回一个对象的引用）。这一政策并不像看起来那么严格，因为Python数据类型可以包含比单个数字、布尔值或字符串更多的信息。例如，您将在本节后面看到，您可以将数组用作返回值。![局部和参数变量的作用域](../Images/4a2a8c52ed26f31945f753d598009f0e.png)
- en: Scope.
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域。
- en: 'The *scope* of a variable is the set of statements that can refer to that variable
    directly. The scope of a function''s local and parameter variables is limited
    to that function; the scope of a variable defined in global code — known as a
    global variable — is limited to the `.py` file containing that variable. Therefore,
    global code cannot refer to either a function''s local or parameter variables.
    Nor can one function refer to either the local or parameter variables that are
    defined in another function. When a function defines a local (or parameter) variable
    with the same name as a global variable (such as `i` in [harmonicf.py](harmonicf.py.html)),
    the variable name in the function refers to the local (or parameter) variable,
    not the global variable. While code in a function can refer to global variables,
    it should not do so: all communication from a caller to a function should take
    place via the function''s parameter variables, and all communication from a function
    to its caller should take place via the function''s return value.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的*作用域*是可以直接引用该变量的语句集合。函数的局部和参数变量的作用域仅限于该函数；在全局代码中定义的变量的作用域（称为全局变量）仅限于包含该变量的`.py`文件。因此，全局代码不能引用函数的局部或参数变量。一个函数也不能引用另一个函数中定义的局部或参数变量。当一个函数使用与全局变量相同名称的局部（或参数）变量定义变量时（例如`harmonicf.py`中的`i`），函数中的变量名称指的是局部（或参数）变量，而不是全局变量。虽然函数中的代码可以引用全局变量，但不应该这样做：调用者到函数的所有通信应该通过函数的参数变量进行，函数到调用者的所有通信应该通过函数的返回值进行。
- en: Default arguments.
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认参数。
- en: A Python function may designate an argument to be optional by specifying a default
    value for that argument. If you omit an optional argument in a function call,
    then Python substitutes the default value for that argument. We have already encountered
    a few examples of this feature. You can specify an optional argument with a default
    value in a user-defined function by putting an equals sign followed by the default
    value after the parameter variable in the function signature. You can specify
    more than one optional argument in a function signature, but all of the optional
    arguments must follow all of the mandatory arguments. The `harmonic()` function
    in the table shown below uses a default argument.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数可以通过为该参数指定默认值来指定一个参数为可选。如果在函数调用中省略了可选参数，则Python会用默认值替换该参数。我们已经遇到了这个特性的几个例子。您可以通过在函数签名中的参数变量后面放置一个等号，然后是默认值，来在用户定义的函数中指定一个带有默认值的可选参数。您可以在函数签名中指定多个可选参数，但所有可选参数必须在所有必选参数之后。下表中的`harmonic()`函数使用了一个默认参数。
- en: Side effects.
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副作用。
- en: 'A *pure function* is a function that, given the same arguments, always returns
    the same value, without producing any observable *side effects*, such as consuming
    input, producing output, or otherwise changing the state of the system. In computer
    programming it is also useful to define functions that do produce side effects.
    In fact, we often define functions whose only purpose is to produce side effects.
    An explicit return statement is optional in such a function: control returns to
    the caller after Python executes the function''s last statement. Functions with
    no specified return value actually return the special value `None`, which is usually
    ignored. The `drawTriangle()` function in the table shown below has side effects,
    and does not return a value.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯函数*是一个函数，给定相同的参数，总是返回相同的值，而不产生任何可观察的*副作用*，如消耗输入、产生输出或以其他方式改��系统的状态。在计算机编程中，定义产生副作用的函数也是有用的。事实上，我们经常定义的函数的唯一目的是产生副作用。在这样的函数中，显式的返回语句是可选的：在Python执行函数的最后一个语句后，控制返回给调用者。没有指定返回值的函数实际上返回特殊值`None`，通常被忽略。下表中的`drawTriangle()`函数具有副作用，并且不返回值。'
- en: Type checking.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型检查。
- en: In mathematics, the definition of a function specifies both the domain and the
    range. For example, for the harmonic numbers, the domain is the positive integers
    and the range is the positive real numbers. In Python, we do not specify the types
    of the parameter variables or the type of the return value. As long as Python
    can apply all of the operations within a function, Python executes the function
    and returns a value. If Python cannot apply an operation to a given object because
    it is of the wrong type, it raises a run-time error to indicate the invalid type.
    This flexibility is a popular feature of Python (known as *polymorphism*) because
    it allows us to define a single function for use with objects of different types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，函数的定义同时指定了定义域和值域。例如，对于调和数，定义域是正整数，值域是正实数。在Python中，我们不需要指定参数变量的类型或返回值的类型。只要Python可以在函数内执行所有操作，Python就会执行该函数并返回一个值。如果Python无法对给定对象执行操作，因为它的类型不正确，Python会引发运行时错误以指示无效类型。这种灵活性是Python的一个受欢迎特性（称为*多态性*），因为它允许我们为不同类型的对象定义一个单一函数来使用。
- en: The table below summarizes our discussion by providing examples of function
    definitions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了我们的讨论，提供了函数定义的示例。
- en: '![Function Examples](../Images/5c751a690a6bc78c27d9313dc6c82e50.png)'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![函数示例](../Images/5c751a690a6bc78c27d9313dc6c82e50.png)'
- en: '* * *'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Implementing Mathematical Functions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现数学函数
- en: '![Gaussian probability functions](../Images/6f8efab66d251aa2a4b1afa3853ee4a0.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![高斯概率函数](../Images/6f8efab66d251aa2a4b1afa3853ee4a0.png)'
- en: 'We now consider two important functions that play an important role in science,
    engineering, and finance. The Gaussian (normal) distribution function is characterized
    by the familiar bell-shaped curve and defined by the formula:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑两个在科学、工程和金融中起重要作用的重要函数。高斯（正态）分布函数以熟悉的钟形曲线为特征，并由以下公式定义：
- en: '![Function Examples](../Images/d7eb739b1856a95431e2bcdad41f9ba3.png)'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![函数示例](../Images/d7eb739b1856a95431e2bcdad41f9ba3.png)'
- en: and the cumulative Gaussian distribution function Φ(z) is defined to be the
    area under the curve defined by φ(x) above the x-axis and to the left of the vertical
    line *x* = *z*. Functions to calculate φ and Φ are not available in Python's `math`
    module, so we develop our own implementations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 累积高斯分布函数Φ(z)被定义为在由上述x轴和左侧垂直线*x* = *z*定义的曲线下的面积。计算φ和Φ的函数在Python的`math`模块中不可用，因此我们开发自己的实现。
- en: Closed form.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭式形式。
- en: In the simplest situation, we have a closed-form mathematical formula defining
    our function in terms of functions that are implemented in Python's `math` module.
    This is the case for φ, so a function `pdf()` corresponding to the mathematical
    definition is easy to implement. For convenience, [gauss.py](gauss.py.html) uses
    the default arguments μ = 0 and σ = 1 and actually computes φ(*x*, μ, σ) = φ((*x*
    - μ) / σ) / σ
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，我们有一个闭式数学公式，用Python的`math`模块中实现的函数来定义我们的函数。这是φ的情况，因此很容易实现与数学定义对应的函数`pdf()`。为了方便起见，[gauss.py](gauss.py.html)使用默认参数μ
    = 0和σ = 1，并实际计算φ(*x*, μ, σ) = φ((*x* - μ) / σ) / σ
- en: No closed form.
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有闭式形式。
- en: 'If no formula is known, we may need a more complicated algorithm to compute
    function values. This situation is the case for Φ — no closed-form expression
    exists for this function. A Taylor series approximation to the ratio of Φ and
    φ turns out to be an effective basis for evaluating the function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有已知的公式，我们可能需要一个更复杂的算法来计算函数值。这种情况适用于Φ —— 该函数没有闭式表达式。Φ的泰勒级数逼近比率结果是评估函数的有效基础：
- en: '![Taylor approximation to Phi(z)](../Images/77e77ee58d3316001a1d82ec8a866720.png)'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![对Phi(z)的泰勒逼近](../Images/77e77ee58d3316001a1d82ec8a866720.png)'
- en: This formula readily translates to the Python code for the function `cdf()`
    in [gauss.py](gauss.py.html). For small (respectively large) *z*, the value is
    extremely close to 0 (respectively 1), so the code directly returns 0 (respectively
    1); otherwise, it uses the Taylor series to add terms until the sum converges.
    Again, for convenience, [gauss.py](gauss.py.html) actually computes Φ(*z*, μ,
    σ) = Φ((*z* - μ) / σ), using the defaults μ = 0 and σ = 1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式很容易转换为Python代码中的函数`cdf()`，在[gauss.py](gauss.py.html)中。对于小（分别大）的*z*，该值非常接近0（分别1），因此代码直接返回0（分别1）；否则，它使用泰勒级数添加项，直到总和收敛。同样，为了方便起见，[gauss.py](gauss.py.html)实际计算Φ(*z*,
    μ, σ) = Φ((*z* - μ) / σ)，使用默认值μ = 0和σ = 1。
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Using Functions to Organize Code
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数来组织代码
- en: 'With the ability to define functions, we can better organize our programs by
    defining functions within them when appropriate. For example, [coupon.py](coupon.py.html)
    is a version of [couponcollector.py](../14array/couponcollector.py.html) (from
    Section 1.4) that better separates the individual components of the computation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义函数的能力，我们可以在适当时在程序中定义函数来更好地组织程序。例如，[coupon.py](coupon.py.html)是[couponcollector.py](../14array/couponcollector.py.html)（来自第1.4节）的一个版本，更好地分离了计算的各个组件：
- en: Given *n*, compute a random coupon value.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定*n*，计算一个随机优惠券价值。
- en: Given *n*, do the coupon collection experiment.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定*n*，进行优惠券收集实验。
- en: Get *n* from the command line, then compute and write the result.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行获取*n*，然后计算并写入结果。
- en: '*Whenever you can clearly separate tasks within a computation, you should do
    so.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论何时你可以清晰地在计算中分离任务，你都应该这样做。*'
- en: '* * *'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Passing Arguments and Returning Values
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数和返回值
- en: Next, we examine the specifics of Python's mechanisms for passing arguments
    to and returning values from functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究Python传递参数和从函数返回值的具体机制。
- en: Call by object reference.
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象引用调用。
- en: You can use parameter variables anywhere in the body of the function in the
    same way as you use local variables. The only difference between a parameter variable
    and a local variable is that Python initializes the parameter variable with the
    corresponding argument provided by the calling code. We refer to this approach
    as *call by object reference*. One consequence of this approach is that if a parameter
    variable refers to a mutable object and you change that object's value within
    a function, then this also changes the object's value in the calling code (because
    it is the same object). Next, we explore the ramifications of this approach. ![Immutability](../Images/6c7b4c535d71ecb5bf84f85738109548.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在函数体中的任何地方使用参数变量，就像使用局部变量一样。参数变量和局部变量之间唯一的区别是，Python会用调用代码提供的相应参数初始化参数变量。我们称这种方法为*对象引用调用*。这种方法的一个后果是，如果参数变量引用可变对象，并且在函数内部更改了该对象的值，那么这也会在调用代码中更改对象的值（因为它是同一个对象）。接下来，我们将探讨这种方法的后果。![不可变性](../Images/6c7b4c535d71ecb5bf84f85738109548.png)
- en: Immutability and aliasing.
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性和别名。
- en: As discussed in Section 1.4, arrays are *mutable* data types, because we can
    change array elements. By contrast, a data type is *immutable* if it is not possible
    to change the value of an object of that type. The other data types that we have
    been using (`int`, `float`, `str`, and `bool`) are all immutable. In an immutable
    data type, operations that might seem to change a value actually result in the
    creation of a new object, as illustrated in the simple example at right. First,
    the statement `i = 99` creates an integer 99, and assigns to `i` a reference to
    that integer. Then `j = i` assigns `i` (an object reference) to `j`, so both `i`
    and `j` reference the same object — the integer 99\. Two variables that reference
    the same object are said to be *aliases*. Next, `j += 1` results in `j` referencing
    an object with value 100, but it does not do so by changing the value of the existing
    integer from 99 to 100! Indeed, since `int` objects are immutable, no statement
    can change the value of that existing integer. Instead, that statement creates
    a new integer 1, adds it to the integer 99 to create another new integer 100,
    and assigns to `j` a reference to that integer. But `i` still references the original
    99\. Note that the new integer 1 has no reference to it in the end — that is the
    system's concern, not ours. ![Immutability in a function call](../Images/9bbda89a7c51c5b2d6a359d9e33cc63d.png)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1.4节所讨论的，数组是*可变*数据类型，因为我们可以更改数组元素。相比之下，如果无法更改该类型对象的值，则数据类型是*不可变*的。我们一直在使用的其他数据类型（`int`、`float`、`str`和`bool`）都是不可变的。在不可变数据类型中，可能看起来会更改值的操作实际上会导致创建一个新对象，如右侧简单示例所示。首先，语句`i
    = 99`创建一个整数99，并将引用分配给`i`。然后`j = i`将`i`（一个对象引用）分配给`j`，因此`i`和`j`都引用相同的对象——整数99。引用同一对象的两个变量称为*别名*。接下来，`j
    += 1`导致`j`引用一个值为100的对象，但它并没有通过更改现有整数从99更改为100！实际上，由于`int`对象是不可变的，没有语句可以更改现有整数的值。相反，该语句创建一个新整数1，将其添加到整数99以创建另一个新整数100，并将引用分配给`j`。但`i`仍然引用原始的99。请注意，新整数1最终没有引用它——这是系统的问题，不是我们的问题。![在函数调用中的不可变性](../Images/9bbda89a7c51c5b2d6a359d9e33cc63d.png)
- en: Integers, floats, booleans, and strings as arguments.
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数、浮点数、布尔值和字符串作为参数。
- en: 'Whenever you pass arguments to a function, the arguments and the function''s
    parameter variables become aliases. In practice, this is the predominant use of
    aliasing in Python. For purposes of illustration, suppose that we need a function
    that increments an integer (our discussion applies to any more complicated function
    as well). A programmer new to Python might try this definition:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您将参数传递给函数时，参数和函数的参数变量成为别名。在实践中，这是Python中别名的主要用法。为了说明，假设我们需要一个增加整数的函数（我们的讨论也适用于任何更复杂的函数）。一个刚接触Python的程序员可能尝试这样定义：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and then expect to increment an integer `i` with the call `inc(i)`. Code like
    this would work in some programming languages, but it has no effect in Python,
    as shown in the figure at right.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后期望使用调用`inc(i)`来增加整数`i`。这样的代码在某些编程语言中可以工作，但在Python中没有效果，如右侧的图所示。
- en: To increment variable `i`, we could use the definition
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要增加变量`i`，我们可以使用以下定义
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and call the function with the assignment statement `i = inc(i)`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用赋值语句`i = inc(i)`调用该函数。
- en: The same holds true for any immutable type. A function cannot change the value
    of an integer, a float, a boolean, or a string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何不可变类型也是如此。函数无法更改整数、浮点数、布尔值或字符串的值。
- en: Arrays as arguments.
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组作为参数。
- en: 'When a function takes an array as an argument, it implements a function that
    operates on an arbitrary number of objects. For example, the following function
    computes the mean (average) of an array of floats or integers:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数将数组作为参数时，它实现了一个操作任意数量对象的函数。例如，以下函数计算浮点数或整数数组的平均值：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Exchanging two elements in an array](../Images/3dd2989ff090169045b64a46661ad45e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![在数组中交换两个元素](../Images/3dd2989ff090169045b64a46661ad45e.png)'
- en: Side effects with arrays.
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组时的副作用。
- en: 'Since arrays are mutable, it is often the case that the purpose of a function
    that takes an array as argument is to produce a side effect (such as changing
    the order of array elements). A prototypical example of such a function is one
    that exchanges the elements at two given indices in a given array. We can adapt
    the code that we examined at the beginning of Section 1.4:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是可变的，通常情况下，接受数组作为参数的函数的目的是产生副作用（例如更改数组元素的顺序）。这样一个函数的典型例子是一个在给定数组中交换两个给定索引处的元素的函数。我们可以调整我们在第1.4节开头检查的代码：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A formal trace of a call on this function is shown on the right.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用的正式跟踪显示在右侧。
- en: 'A second prototypical example of a function that takes an array argument and
    produces side effects is one that randomly shuffles the elements in the array,
    using the version of the algorithm that we examined in Section 1.4 (and the `exchange()`
    function just defined):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个典型的例子是一个接受数组参数并产生副作用的函数，该函数随机打乱数组中的元素，使用我们在第1.4节中检查的算法版本（以及刚刚定义的`exchange()`函数）：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Arrays as return values.
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为返回值的数组。
- en: 'A function can return an array. For example, consider the following function,
    which returns an array of random floats:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回一个数组。例如，考虑以下函数，它返回一个随机浮点数数组：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The table below concludes our discussion of arrays as function arguments by
    highlighting some typical array-processing functions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了我们对数组作为函数参数的讨论，突出了一些典型的数组处理函数。
- en: '![Arrays as function arguments](../Images/72e714c44f66fa574b877c3534cf5f63.png)'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![数组作为函数参数](../Images/72e714c44f66fa574b877c3534cf5f63.png)'
- en: '* * *'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Superposition of Sound Waves
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声波的叠加
- en: '![Superposing waves to make composite sounds](../Images/94a4dafe6d8d62c4911eceb14d8f83f1.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![叠加波形以产生复合声音](../Images/94a4dafe6d8d62c4911eceb14d8f83f1.png)'
- en: 'Notes like concert A have a pure sound that is not very musical, because the
    sounds that you are accustomed to hearing have many other components. Most musical
    instruments produce harmonics (the same note in different octaves and not as loud),
    or you might play chords (multiple notes at the same time). To combine multiple
    sounds, we use superposition: simply add their waves together and rescale to make
    sure that all values stay between -1 and +1.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像协奏A音这样的音符具有纯净的声音，不太具有音乐性，因为你习惯听到的声音有许多其他成分。大多数乐器会产生谐波（不同八度的相同音符，但不那么响亮），或者你可能演奏和弦（同时演奏多个音符）。为了合并多个声音，我们使用叠加：简单地将它们的波形相加并重新调整比例，以确保所有值保持在-1和+1之间。
- en: 'The program [playthattunedeluxe.py](playthattunedeluxe.py.html) is a version
    of [playthattune.py](../15inout/playthattune.py.html) (from Section 1.5) that
    encapsulates the sound wave calculation and adds harmonics. Try running [playthattunedeluxe.py](playthattunedeluxe.py.html)
    repeatedly with its standard input redirected to each of these data files (created
    by various students): [elise.txt](elise.txt), [ascale.txt](ascale.txt), [stairwaytoheaven.txt](stairwaytoheaven.txt),
    [entertainer.txt](entertainer.txt), [firstcut.txt](firstcut.txt), [freebird.txt](freebird.txt),
    and [looney.txt](looney.txt).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[playthattunedeluxe.py](playthattunedeluxe.py.html)是[playthattune.py](../15inout/playthattune.py.html)（来自第1.5节）的一个版本，封装了声波计算并添加了谐波。尝试反复运行[playthattunedeluxe.py](playthattunedeluxe.py.html)，并将其标准输入重定向到这些数据文件中的每一个（由不同学生创建）：[elise.txt](elise.txt)、[ascale.txt](ascale.txt)、[stairwaytoheaven.txt](stairwaytoheaven.txt)、[entertainer.txt](entertainer.txt)、[firstcut.txt](firstcut.txt)、[freebird.txt](freebird.txt)和[looney.txt](looney.txt)。
- en: '![Flow of control among several functions](../Images/f34cbc603bf2c10792a454d46716c190.png)'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![多个函数之间的控制流](../Images/f34cbc603bf2c10792a454d46716c190.png)'
- en: '* * *'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q & A
- en: '**Q.** Can I use the statement return in a function without specifying a value?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我能在函数中使用没有指定值的return语句吗？'
- en: '**A.** Yes. Technically, it returns the `None` object, which is the sole value
    of the type `NoneType`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。从技术上讲，它返回`None`对象，这是`NoneType`类型的唯一值。'
- en: '**Q.** What happens if a function has one control flow that leads to a `return`
    statement that returns a value but another control flow that reaches the end of
    the function body?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果一个函数有一个控制流导致`return`语句返回一个值，但另一个控制流达到函数体的末尾会发生什么？'
- en: '**A.** It would be poor style to define such a function, because doing so would
    place a severe burden on the function''s callers: the callers would need to know
    under which circumstances the function returns a value, and under which circumstances
    it returns `None`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 定义这样一个函数是不良风格的，因为这会给函数的调用者带来严重负担：调用者需要知道在哪些情况下函数返回一个值，在哪些情况下返回`None`。'
- en: '**Q.** What happens if I compose code in the body of a function that appears
    after the `return` statement?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我在函数体中的代码出现在`return`语句之后会发生什么？'
- en: '**A.** Once a `return` statement is reached, control returns to the caller.
    So any code in the body of a function that appears after a return statement is
    useless; it is never executed. In Python, it is poor style, but not illegal to
    define such a function.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 一旦到达`return`语句，控制权将返回给调用者。因此，在return语句之后出现的函数体中的任何代码都是无效的；它永远不会被执行。在Python中，这是不良风格，但并非非法定义这样的函数。'
- en: '**Q.** What happens if I define two functions with the same name (but possibly
    a different number of arguments) in the same `.py` file?'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我在同一个`.py`文件中定义了两个同名函数（但可能参数个数不同）会发生什么？'
- en: '**A.** This is known as *function overloading*, which is embraced by many programming
    languages. Python, however, is not one of those languages: the second function
    definition will overwrite the first one. You can often achieve the same effect
    by using default arguments.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这被称为*函数重载*，许多编程语言都支持。然而，Python不是其中之一：第二个函数定义将覆盖第一个函数。通常可以通过使用默认参数来实现相同的效果。'
- en: '**Q.** What happens if I define two functions with the same name in different
    files?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我在不同文件中定义了同名的两个函数会发生什么？'
- en: '**A.** That is fine. For example, it would be good design to have a function
    named `pdf()` in [gauss.py](gauss.py.html) that computes the Gaussian probability
    density function and another function named `pdf()` in `cauchy.py` that computes
    the Cauchy probability density function. In Section 2.2 you will learn how to
    call functions defined in different `.py` files.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 没问题。例如，在[gauss.py](gauss.py.html)中有一个名为`pdf()`的函数，用于计算高斯概率密度函数，另一个名为`pdf()`的函数在`cauchy.py`中用于计算柯西概率密度函数。在第2.2节中，你将学习如何调用在不同`.py`文件中定义的函数。'
- en: '**Q.** Can a function change the object to which a parameter variable is bound?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 一个函数能改变参数变量绑定的对象吗？'
- en: '**A.** Yes, you can use a parameter variable on the left side of an assignment
    statement. However, many Python programmers consider it poor style to do so. Note
    that such an assignment statement has no effect in the client.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，你可以在赋值语句的左侧使用参数变量。然而，许多Python程序员认为这样做是不良风格的。请注意，这样的赋值语句对客户端没有影响。'
- en: '**Q.** The issue with side effects and mutable objects is complicated. Is it
    really all that important?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 副作用和可变对象的问题很复杂。这真的那么重要吗？'
- en: '**A.** Yes. Properly controlling side effects is one of a programmer''s most
    important tasks in large systems. Taking the time to be sure that you understand
    the difference between passing arrays (which are mutable) and passing integers,
    floats, booleans, and strings (which are immutable) will certainly be worthwhile.
    The very same mechanisms are used for all other types of data, as you will learn
    in Chapter 3.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。正确控制副作用是程序员在大型系统中最重要的任务之一。花时间确保你理解传递数组（可变的）和传递整数、浮点数、布尔值和字符串（不可变的）之间的区别肯定是值得的。同样的机制也适用于所有其他类型的数据，你将在第3章中学到。'
- en: '**Q.** How can I arrange to pass an array to a function in such a way that
    the function cannot change the elements in the array?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何安排将数组传递给函数，以使函数无法更改数组中的元素？'
- en: '**A.** There is no direct way to do so. In Section 3.3 you will see how to
    achieve the same effect by building a wrapper data type and passing an object
    of that type instead. You will also see how to use Python''s built-in `tuple`
    data type, which represents an immutable sequence of objects.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 没有直接的方法。在第3.3节中，您将看到如何通过构建包装数据类型并传递该类型的对象来实现相同的效果。您还将看到如何使用Python的内置`tuple`数据类型，它表示一组不可变的对象。'
- en: '**Q.** Can I use a mutable object as a default value for an optional argument?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 我可以使用可变对象作为可选参数的默认值吗？'
- en: '**A.** Yes, but it may lead to unexpected behavior. Python evaluates a default
    value only once, when the function is defined (not each time the function is called).
    So, if the body of a function modifies a default value, subsequent function calls
    will use the modified value. Similar difficulties arise if you initialize the
    default value by calling an impure function. For example, after Python executes
    the code fragment'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 可以，但可能会导致意外行为。Python只在函数定义时评估默认值一次（而不是每次调用函数时）。因此，如果函数体修改了默认值，后续函数调用将使用修改后的值。如果通过调用不纯函数来初始化默认值，也会出现类似的困难。例如，在Python执行代码片段后'
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`b[]` and `c[]` are aliases for the same array of length 2 (not 1), which contains
    one float repeated twice (instead of two different floats).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`b[]`和`c[]`是长度为2的相同数组的别名（而不是1），其中包含一个浮点数重复两次（而不是两个不同的浮点数）。'
- en: '* * *'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Compose a function `max3()` that takes three `int` or `float` arguments and
    returns the largest one.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`max3()`，它接受三个`int`或`float`参数，并返回最大的一个。
- en: '*Solution*:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE7]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compose a function `odd()` that takes three `bool` arguments and returns `True`
    if an odd number of arguments are `True`, and `False` otherwise.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`odd()`，它接受三个`bool`参数，并在奇数个参数为`True`时返回`True`，否则返回`False`。
- en: Compose a function `majority()` that takes three `bool` arguments and returns
    `True` if at least two of the arguments are `True`, and `False` otherwise. Do
    not use an `if` statement.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`majority()`，它接受三个`bool`参数，并在至少两个参数为`True`时返回`True`，否则返回`False`。不要使用`if`语句。
- en: '*Solution*: Here are two solutions. The first is concise. The second is silly,
    but does adhere to the rules.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：这里有两个解决方案。第一个简洁。第二个愚蠢，但遵守规则。'
- en: '[PRE8]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compose a function `areTriangular()` that takes three numbers as arguments and
    returns `True` if they could be the sides of a triangle (none of them is greater
    than or equal to the sum of the other two), and False otherwise.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`areTriangular()`，它以三个数字作为参数，并在它们可能是三角形的边（没有一个大于或等于另外两个的和）时返回`True`，否则返回`False`。
- en: 'Compose a function `sigmoid()` that takes a `float` argument `x` and returns
    the `float` obtained from the formula: 1 / (1 - *e*^(-*x*)).'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`sigmoid()`，它接受一个`float`参数`x`，并返回从公式得到的`float`：1 / (1 - *e*^(-*x*))。
- en: Compose function `lg()` that takes an integer `n` as an argument and returns
    the base-2 logarithm of `n`. You may use Python's `math` module.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合函数`lg()`，它以整数`n`作为参数，并返回`n`的以2为底的对数。您可以使用Python的`math`模块。
- en: Compose a function `lg()` that takes an integer `n` as an argument and returns
    the largest integer not larger than the base-2 logarithm of `n`. Do *not* use
    the standard Python `math` module.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`lg()`，它以整数`n`作为参数，并返回不大于`n`的以2为底的对数的最大整数。不要使用标准的Python`math`模块。
- en: Compose a function `signum()` that takes a `float` argument `n` and returns
    -1 if `n` is less than 0, 0 if `n` is equal to 0, and +1 if `n` is greater than
    0.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个函数`signum()`，它接受一个`float`参数`n`，如果`n`小于0，则返回-1，如果`n`等于0，则返回0，如果`n`大于0，则返回+1。
- en: 'Consider this function `duplicate()`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑这个函数`duplicate()`：
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What does the following code fragment write?
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段写了什么？
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Consider this function `cube()`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑这个函数`cube()`：
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How many times is the following `while` loop iterated?
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下`while`循环迭代了多少次？
- en: '[PRE12]'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Solution*: Just 1000 times. A call to `cube()` has no effect on client code.
    It changes the value of its local parameter variable `i`, but that change has
    no effect on the `i` in the `while` loop, which is a different variable. If you
    replace the call to `cube(i)` with the statement `i = i * i * i` (maybe that was
    what you were thinking), then the loop is iterated five times, with `i` taking
    on the values 0, 1, 2, 9, and 730 at the beginning of the five iterations.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：只有1000次。对`cube()`的调用对客户端代码没有影响。它改变了其本地参数变量`i`的值，但这种改变对`while`循环中的`i`没有影响，因为那是一个不同的变量。如果您用语句`i
    = i * i * i`替换对`cube(i)`的调用（也许这是您想的），那么循环将迭代五次，`i`在五次迭代开始时分别取值0、1、2、9和730。'
- en: What does the following code fragment write?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段写了什么？
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Solution*: 0123444444\. Note that the second call to `stdio.write()` uses
    `i`, not `j`. Unlike analogous loops in many other programming languages, when
    the first for loop terminates, the variable `i` is 4 and it remains in scope.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：0123444444。请注意，第二次调用`stdio.write()`使用的是`i`，而不是`j`。与许多其他编程语言中的类似循环不同，当第一个for循环终止时，变量`i`为4，并且仍然在作用域内。'
- en: 'The following *checksum* formula is widely used by banks and credit card companies
    to validate legal account numbers:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的*校验和*公式被银行和信用卡公司广泛用于验证合法的账号号码：
- en: '| *d*[0] + *f*(*d*[1]) + *d*[2] + *f*(*d*[3]) + *d*[4] + *f*(*d*[5]) + *d*[6]
    + ... = 0 (mod 10) |'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *d*[0] + *f*(*d*[1]) + *d*[2] + *f*(*d*[3]) + *d*[4] + *f*(*d*[5]) + *d*[6]
    + ... = 0 (mod 10) |'
- en: The *d[i]* are the decimal digits of the account number and *f*(*d*) is the
    sum of the decimal digits of 2*d* (for example, *f*(7) = 5 because 2 × 7 = 14
    and 1 + 4 = 5). For example, 17327 is valid because 1 + 5 + 3 + 4 + 7 = 20, which
    is a multiple of 10\. Implement the function *f* and compose a program to take
    a 10-digit integer as a command-line argument and print a valid 11-digit number
    with the given integer as its first 10 digits and the checksum as the last digit.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*d[i]*是账号数字的小数位，*f*(*d*)是2*d*的小数位之和（例如，*f*(7) = 5，因为2 × 7 = 14，1 + 4 = 5）。例如，17327是有效的，因为1
    + 5 + 3 + 4 + 7 = 20，这是10的倍数。实现函数*f*并组合一个程序，以一个10位整数作为命令行参数，并打印一个有效的11位数字，其中给定整数作为前10位数字，校验和作为最后一位数字。'
- en: 'Given two stars with angles of declination and right ascension (*d*1, *a*1)
    and (*d*2, *a*2), the angle they subtend is given by the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定两颗星的赤纬和赤经角度(*d*1, *a*1)和(*d*2, *a*2)，它们所夹角度由[Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)给出：
- en: '| 2 arcsin((sin²(*d*/2) + cos(*d*[1]) cos(*d*[2]) sin²(*a*/2))^(1/2)) |'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 2 arcsin((sin²(*d*/2) + cos(*d*[1]) cos(*d*[2]) sin²(*a*/2))^(1/2)) |'
- en: 'where *a*[1] and *a*[2] are angles between -180 and 180 degrees, *d*[1] and
    *d*[2] are angles between -90 and 90 degrees, *a* = *a*[2] - *a*[1], *d* = *d*[2]
    - *d*[1]. Compose a program to take declination and right ascension of two stars
    as command-line arguments and write the angle they subtend. *Hint*: Be careful
    about converting from degrees to radians.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中*a*[1]和*a*[2]是在-180到180度之间的角度，*d*[1]和*d*[2]是在-90到90度之间的角度，*a* = *a*[2] - *a*[1]，*d*
    = *d*[2] - *d*[1]。编写一个程序，接受两颗星的赤纬和赤经作为命令行参数，并写��它们所夹角度。 *提示*：在将度数转换为弧度时要小心。
- en: See the similar exercise from Section 1.2\. Latitude corresponds to declination
    and longitude to ascension.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参见第1.2节中类似的练习。纬度对应于赤纬，经度对应于赤经。
- en: Compose a `readBoolean2D()` function that reads a two-dimensional matrix of
    0 and 1 values (with dimensions) into an array of booleans.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`readBoolean2D()`函数，将一个由0和1值组成的二维矩阵（带有维度）读入一个布尔数组中。
- en: '*Solution*: The body of the function is virtually the same as for the corresponding
    function given in the table earlier in this page for two-dimensional arrays of
    floats:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：该函数的主体与本页早期表中给出的浮点数二维数组的相应函数几乎相同：'
- en: '[PRE14]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Compose a function that takes an array `a[]` of strictly positive floats as
    its argument and rescales the array so that each element is between 0 and 1 (by
    subtracting the minimum value from each element and then dividing each element
    by the difference between the minimum and maximum values). Use the built-in `max()`
    and `min()` functions.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，以一个严格正浮点数数组`a[]`作为参数，并重新调整数组，使每个元素介于0和1之间（通过从每个元素中减去最小值，然后将每个元素除以最小值和最大值之间的差异）。使用内置的`max()`和`min()`函数。
- en: Compose a function `histogram()` that takes an array `a[]` of integers and an
    integer `m` as arguments and returns an array of length `m` whose `i`th entry
    is the number of times the integer `i` appears in the argument array. Assume that
    the values in `a[]` are all between 0 and `m`-1, so that the sum of the values
    in the returned array should be equal to `len(a)`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`histogram()`函数，以一个整数数组`a[]`和一个整数`m`作为参数，并返回一个长度为`m`的数组，其第`i`个条目是参数数组中整数`i`出现的次数。假设`a[]`中的值都在0和`m`-1之间，因此返回数组中值的总和应等于`len(a)`。
- en: Assemble code fragments in this section and in Section 1.4 to develop a program
    that takes an integer `n` from the command line and writes `n` five-card hands,
    separated by blank lines, drawn from a randomly shuffled card deck, one card per
    line using card names like `Ace of Clubs`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节和第1.4节中组装代码片段，开发一个程序，从命令行接受一个整数`n`，并写入`n`个五张卡牌的手，用空行分隔，从一个随机洗牌的卡牌牌组中抽取，每行一张卡牌，使用`Ace
    of Clubs`等卡牌名称。
- en: 'Compose a function `multiply()` that takes two square matrices of the same
    dimension as arguments and returns their product (another square matrix of that
    same dimension). *Extra credit*: Make your program work whenever the number of
    columns in the first matrix is equal to the number of rows in the second matrix.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`multiply()`，它以两个相同维度的方阵作为参数，并返回它们的乘积（另一个相同维度的方阵）。 *额外加分*：使您的程序在第一个矩阵的列数等于第二个矩阵的行数时也能工作。
- en: Compose a function `any()` that takes an array of booleans as its argument and
    returns `True` if *any* of the entries in the array is `True`, and `False` otherwise.
    Compose a function `all()` that takes an array of booleans as its argument and
    returns `True` if *all* of the entries in the array are `True`, and `False` otherwise.
    Note that `all()` and `any()` are Python built-in functions; the goal of this
    exercise is to understand them better by creating your own versions.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`any()`，它以一个布尔数组作为参数，并在数组中的任何条目为`True`时返回`True`，否则返回`False`。编写一个函数`all()`，它以一个布尔数组作为参数，并在数组中的所有条目都为`True`时返回`True`，否则返回`False`。请注意，`all()`和`any()`是Python内置函数；这个练习的目的是通过创建自己的版本来更好地理解它们。
- en: 'Develop a version of `getCoupon()` that better models the situation when one
    of the coupons is rare: choose one value at random, return that value with probability
    1/(1000*n*), and return all other values with equal probability. *Extra credit*:
    How does this change affect the average value of the coupon collector function?'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个更好地模拟当其中一个优惠券稀有时的`getCoupon()`版本：随机选择一个值，以1/(1000*n*)的概率返回该值，并以相等概率返回所有其他值。
    *额外加分*：这种变化如何影响优惠券收集函数的平均值？
- en: Modify [playthattune.py](../15inout/playthattune.py.html) (from Section 1.5)
    to add harmonics two octaves away from each note, with half the weight of the
    one-octave harmonics.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[playthattune.py](../15inout/playthattune.py.html)（来自第1.5节），添加每个音符两个八度的谐波，权重为一个八度谐波的一半。
- en: '* * *'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Birthday problem.** Compose a program with appropriate functions for studying
    the birthday problem (see the related exercise in Section 1.4).'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生日问题。** 编写一个适当的程序来研究生日问题（参见第1.4节中相关的练习）。'
- en: '**Euler''s totient function.** Euler''s totient function is an important function
    in number theory: φ(*n*) is defined as the number of positive integers less than
    or equal to *n* that are relatively prime with *n* (no factors in common with
    *n* other than 1). Compose a function that takes an integer argument *n* and returns
    φ(*n*). Include global code that takes an integer from the command line, calls
    the function, and writes the result.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欧拉函数。** 欧拉函数是数论中的一个重要函数：φ(*n*)被定义为小于或等于*n*且与*n*互质（除了1以外没有其他公因数）的正整数的数量。编写一个函数，接受一个整数参数*n*并返回φ(*n*)。包括从命令行接受一个整数、调用该函数并写入结果的全局代码。'
- en: '**Harmonic numbers.** Compose a program `harmonic.py` that defines three functions
    `harmonic()`, `harmonicSmall()`, and `harmonicLarge()` for computing the harmonic
    numbers. The `harmonicSmall()` function should just compute the sum (as in [harmonic.py](../13flow/harmonic.py.html)),
    the `harmonicLarge()` function should use the approximation H[*n*] = log[*e*](*n*)
    + γ + 1/(2*n*) - 1/(12*n*²) + 1/(120*n*⁴) (the number γ = .577215664901532...
    is known as *Euler''s constant*), and the `harmonic()` function should call `harmonicSmall()`
    for *n* < 100 and `harmonicLarge()` otherwise.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调和数。** 编写一个名为`harmonic.py`的程序，定义三个函数`harmonic()`、`harmonicSmall()`和`harmonicLarge()`来计算调和数。`harmonicSmall()`函数应该只计算总和（如[harmonic.py](../13flow/harmonic.py.html)中所示），`harmonicLarge()`函数应该使用近似公式H[*n*]
    = log[*e*](*n*) + γ + 1/(2*n*) - 1/(12*n*²) + 1/(120*n*⁴)（其中γ = .577215664901532...被称为*欧拉常数*），而`harmonic()`函数应该在*n*
    < 100时调用`harmonicSmall()`，否则调用`harmonicLarge()`。'
- en: '**Gaussian random values.** Experiment with the following functon for generating
    random variables from the Gaussian distribution, which is based on generating
    a random point in the unit circle and using a form of the [Box-Muller transform](http://en.wikipedia.org/wiki/Box-Muller_transform).
    (See the "Gaussian random numbers" exercise at the end of Section 1.2.)'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高斯随机值。** 尝试使用以下函数生成高斯分布的随机变量，该函数基于在单位圆内生成随机点并使用一种形式的[Box-Muller变换](http://en.wikipedia.org/wiki/Box-Muller_transform)。（请参阅第1.2节末尾的“高斯随机数”练习。）'
- en: '[PRE15]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Take a command-line argument `n` and generate `n` random numbers, using an
    array `a[]` of 20 integers to count the numbers generated that fall between `i*.05`
    and `(i+1)*.05` for `i` from 0 to 19\. Then use `stddraw` to plot the values and
    to compare your result with the normal bell curve. *Remark*: This approach is
    faster and more accurate than the one described in the "Gaussian random numbers"
    exercise in Section 1.2\. Although it involves a loop, the loop is executed only
    4/π (about 1.273) times on average. This reduces the overall expected number of
    calls to transcendental functions.'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受一个命令行参数`n`，并生成`n`个随机数，使用一个包含20个整数的数组`a[]`来计算生成的落在`i*.05`和`(i+1)*.05`之间的数字，其中`i`从0到19。然后使用`stddraw`来绘制数值，并将结果与正态钟形曲线进行比较。*备注*：这种方法比第1.2节中描述的“高斯随机数”练习中的方法更快更准确。尽管涉及循环，但平均只执行循环4/π（约1.273）次。这减少了对超越函数的整体预期调用次数。
- en: '**Binary search.** A general method that we study in detail in Section 4.2
    is effective for computing the inverse of a cumulative probability density function
    like `cdf()`. Such functions are continuous and nondecreasing from (0, 0) to (1,
    1). To find the value *x*[0] for which *f*(*x*[0]) = *y*[0], check the value of
    *f*(.5). If it is greater than *y*[0], then *x*[0] must be between 0 and .5; otherwise,
    it must be between .5 and 1\. Either way, we halve the length of the interval
    known to contain *x*[0]. Iterating, we can compute *x*[0] to within a given tolerance.
    Add a function `cfdInverse()` to [gauss.py](gauss.py.html) that uses binary search
    to compute the inverse.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二分查找。** 我们在第4.2节中详细研究的一种通用方法是用于计算类似`cdf()`的累积概率密度函数的逆函数。这些函数是连续的，从(0, 0)到(1,
    1)是非递减的。要找到*f*(*x*[0]) = *y*[0]的值*x*[0]，检查*f*(.5)的值。如果它大于*y*[0]，那么*x*[0]必须在0和.5之间；否则，它必须在.5和1之间。无论哪种方式，我们都将已知包含*x*[0]的区间的长度减半。通过迭代，我们可以在给定的容差内计算*x*[0]。在[gauss.py](gauss.py.html)中添加一个使用二分查找来计算逆函数的函数`cfdInverse()`。'
- en: '*Solution*: See [gaussinv.py](gaussinv.py.html).'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：请参阅[gaussinv.py](gaussinv.py.html)。'
- en: '**Black-Scholes option valuation.** The [Black Scholes](http://en.wikipedia.org/wiki/Black-Scholes)
    formula supplies the theoretical value of a European call option on a stock that
    pays no dividends, given the current stock price *s*, the exercise price *x*,
    the continuously compounded risk-free interest rate *r*, the standard deviation
    σ of the stock''s return (volatility) and the time (in years) to maturity *t*.
    The value is given by the formula *s*Φ(*a*) - *x**e*^(-rt)φ(*b*), where Φ(*z*)
    is the Gaussian cumulative distribution function, *a* = (ln(*s*/*x*) + (*r* +
    σ²/2)*t*)/(σ*t*^(1/2)), and *b* = *a* - σ*t*^(1/2). Compose a program that takes
    `s`, `x`, `r`, `sigma`, and `t` from the command line and writes the Black-Scholes
    value. For now, copy the definitions of the `phi()` and `Phi()` functions from
    [gauss.py](gauss.py.html) into your program. In the next section of the website,
    you''ll learn how to define a function in one `.py` file such that it can be called
    by the code in another `.py` file.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Black-Scholes期权定价。** [Black Scholes](http://en.wikipedia.org/wiki/Black-Scholes)公式提供了不支付股息的股票上的欧式看涨期权的理论价值，给定当前股价*s*，行权价*x*，连续复利无风险利率*r*，股票回报的标准差σ（波动率）和到期时间（年）*t*。该价值由公式*s*Φ(*a*)
    - *x**e*^(-rt)φ(*b*)给出，其中Φ(*z*)是高斯累积分布函数，*a* = (ln(*s*/*x*) + (*r* + σ²/2)*t*)/(σ*t*^(1/2))，*b*
    = *a* - σ*t*^(1/2)。编写一个程序，从命令行获取`s`、`x`、`r`、`sigma`和`t`，并输出Black-Scholes值。目前，将`phi()`和`Phi()`函数的定义从[gauss.py](gauss.py.html)复制到您的程序中。在网站的下一部分，您将学习如何在一个`.py`文件中定义一个函数，以便可以被另一个`.py`文件中的代码调用。'
- en: Myron Scholes won the 1997 Nobel Prize in Economics for the [Black-Scholes paper](http://www.cs.princeton.edu/courses/archive/fall02/cs323/links/blackscholes.pdf).
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Myron Scholes因[Black-Scholes论文](http://www.cs.princeton.edu/courses/archive/fall02/cs323/links/blackscholes.pdf)而获得了1997年的诺贝尔经济学奖。
- en: '*Solution*: See [blackscholes.py](blackscholes.py.html).'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：请参阅[blackscholes.py](blackscholes.py.html)。'
- en: '**Implied volatility.** Typically the volatility is the unknown value in the
    Black-Scholes formula. Write a program that reads `s`, `x`, `r`, `t`, and the
    current price of the option from the command line and uses binary search (see
    a previous exercise in this section) to compute σ.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**隐含波动率。** 通常波动率是Black-Scholes公式中的未知值。编写一个程序，从命令行读取`s`、`x`、`r`、`t`和期权的当前价格，并使用二分查找（请参阅本节中的先前练习）来计算σ。'
- en: '**Horner''s method.** Compose a program with a function `evaluate(x, a)` that
    evaluates the polynomial *a*(*x*) whose coefficients are the elements in the array
    `a[]`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**霍纳方法。** 编写一个带有函数`evaluate(x, a)`的程序，该函数评估多项式*a*(*x*)，其系数是数组`a[]`中的元素：'
- en: '| *a*[0] + *a*[1]*x*¹ + *a*[2]*x*² + ... + *a*[*n*-2]*x*^(*n*-2) + *a*[*n*-1]*x*^(*n*-1)
    |'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *a*[0] + *a*[1]*x*¹ + *a*[2]*x*² + ... + *a*[*n*-2]*x*^(*n*-2) + *a*[*n*-1]*x*^(*n*-1)
    |'
- en: 'Use *Horner''s method*, an efficient way to perform the computations that is
    suggested by the following parenthesization:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 *霍纳法*，这是一种执行计算的高效方法，建议按照以下括号化：
- en: '| *a*[0] + *x* (*a*[1] + *x*( *a*[2] + ... + *x*(*a*[*n*-2] + *x**a*[*n*-1]))...)
    |'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *a*[0] + *x* (*a*[1] + *x*( *a*[2] + ... + *x*(*a*[*n*-2] + *x**a*[*n*-1]))...)
    |'
- en: Then compose a function `exp()` that calls `evaluate()` to compute an approximation
    to *e^x*, using the first *n* terms of the Taylor series expansion *e^x* = 1 +
    *x* + *x*²/2! + *x*³/3! + ... Take an argument `x` from the command line, and
    compare your result against that computed by `math.exp(x)`.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后编写一个函数 `exp()`，调用 `evaluate()` 来计算 *e^x* ���近似值，使用泰勒级数展开的前 *n* 项 *e^x* = 1
    + *x* + *x*²/2! + *x*³/3! + ... 从命令行获取参数 `x`，并将您的结果与由 `math.exp(x)` 计算的结果进行比较。
- en: Include code to check your answer against that computed by `math.exp()`.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括代码来检查您的答案与由 `math.exp()` 计算的答案是否一致。
- en: '*Solution*: See [horner.py](horner.py.html).'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[horner.py](horner.py.html)。'
- en: '**Benford''s law.** The American astronomer Simon Newcomb observed a quirk
    in a book that compiled logarithm tables: the beginning pages were much grubbier
    than the ending pages. He suspected that scientists performed more computations
    with numbers starting with 1 than with 8 or 9, and postulated the first digit
    law, which says that under general circumstances, the leading digit is much more
    likely to be 1 (roughly 30%) than the digit 9 (less than 4%). This phenomenon
    is known as [Benford''s law](http://mathworld.wolfram.com/BenfordsLaw.html) and
    is now often used as a statistical test. For example, IRS forensic accountants
    rely on it to discover tax fraud. Compose a program that reads in a sequence of
    integers from standard input and tabulates the number of times each of the digits
    1-9 is the leading digit, breaking the computation into a set of appropriate functions.
    Use your program to test the law on some tables of information from your computer
    or from the web. Then, compose a program to foil the IRS by generating random
    amounts from $1.00 to $1,000.00 with the same distribution that you observed.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本福德定律。** 美国天文学家西蒙·纽康布观察到一本编制对数表的书中的一个怪现象：开始的页面比结束的页面脏得多。他怀疑科学家们使用以 1 开头的数字进行的计算比使用以
    8 或 9 开头的数字进行的计算要多，并假设了第一位数字定律，该定律表明在一般情况下，领先数字更有可能是 1（大约 30%）而不是数字 9（不到 4%）。这种现象被称为[本福德定律](http://mathworld.wolfram.com/BenfordsLaw.html)，现在经常被用作统计测试。例如，美国国税局的法务会计师依靠它来发现税务欺诈。编写一个程序，从标准输入读取一系列整数，并制表显示数字
    1-9 每个数字作为领先数字的次数，将计算分解为一组适当的函数。使用您的程序在计算机或网络上的一些信息表上测试该定律。然后，编写一个程序通过生成从 $1.00
    到 $1,000.00 的随机金额，使 IRS 无法发现。'
- en: The file [princeton-files.txt](princeton-files.txt) is a list of file sizes
    on a public Unix machine at Princeton. Try running your program on that file.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件[普林斯顿文件.txt](princeton-files.txt)是普林斯顿公共 Unix 机器上文件大小的列表。尝试在该文件上运行您的程序。
- en: '*Solution*: See [benford.py](benford.py.html).'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[benford.py](benford.py.html)。'
- en: '**Binomial distribution.** Compose a function `binomial()` that accepts an
    integer `n`, an integer `k`, and a float `p`, and computes the probability of
    obtaining exactly `k` heads in `n` biased coin flips (heads with probability `p`)
    using the formula'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二项分布。** 编写一个接受整数 `n`、整数 `k` 和浮点数 `p` 的函数 `binomial()`，并计算在进行 `n` 次有偏向正面概率为
    `p` 的硬币翻转时恰好获得 `k` 次正面的概率，使用公式'
- en: '| *f*(*k*, *n*, *p*) = *p*^(*k*)(1 - *p*)^(*n*-*k*)*n*! / (*k*!(*n*-*k*)!)
    |'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *f*(*k*, *n*, *p*) = *p*^(*k*)(1 - *p*)^(*n*-*k*)*n*! / (*k*!(*n*-*k*)!)
    |'
- en: '*Hint*: To avoid computing with huge integers, compute *x* = ln *f*(*k*, *n*,
    *p*) and then return *e^x*. In the global code, take `n` and `p` from the command
    line and check that the sum over all values of `k` between 0 and `n` is (approximately)
    1\. Also, compare every value computed with the normal approximation'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：为了避免使用巨大的整数进行计算，计算 *x* = ln *f*(*k*, *n*, *p*)，然后返回 *e^x*。在全局代码中，从命令行获取
    `n` 和 `p`，并检查在 0 到 `n` 之间的所有 `k` 值的总和是否（大约）为 1。还要将计算的每个值与正态近似进行比较。'
- en: '| *f*(*k*, *n*, *p*) ≈ Φ(*k* + 1/2, *np*, (*np*(1-*p*)^(1/2)) - Φ(*k* - 1/2,
    *np*, (*np*(1-*p*)^(1/2)) |'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *f*(*k*, *n*, *p*) ≈ Φ(*k* + 1/2, *np*, (*np*(1-*p*)^(1/2)) - Φ(*k* - 1/2,
    *np*, (*np*(1-*p*)^(1/2)) |'
- en: '**Coupon collecting from a binomial distribution.** Compose a version of `getCoupon()`
    that uses `binomial()` from the previous exercise to return coupon values according
    to the binomial distribution with *p* = 1/2\. *Hint*: Generate a uniformly distributed
    random number *x* between 0 and 1, then return the smallest value of *k* for which
    the sum of *f*(*n*, *j*, *p*) for all *j* < *k* exceeds *x*. *Extra credit*: Develop
    a hypothesis for describing the behavior of the coupon collector function under
    this assumption.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从二项分布中收集优惠券。** 编写一个使用前一个练习中的 `binomial()` 返回符合 *p* = 1/2 的二项分布的优惠券值的 `getCoupon()`
    版本。*提示*：生成一个介于 0 和 1 之间的均匀分布的随机数 *x*，然后返回所有 *j* < *k* 的 *f*(*n*, *j*, *p*) 的总和超过
    *x* 的最小值 *k*。*额外学分*：为描述在此假设下优惠券收集函数的行为开发一个假设。'
- en: '**Chords.** Compose a version of [playthattunedeluxe.py](playthattunedeluxe.py.html)
    that can handle songs with chords (including harmonics). Develop an input format
    that allows you to specify different durations for each chord and different amplitude
    weights for each note within a chord. Create test files that exercise your program
    with various chords and harmonics, and create a version of *Fur Elise* that uses
    them.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**弦。** 编写一个版本的[playthattunedeluxe.py](playthattunedeluxe.py.html)，可以处理包含和弦（包括谐波）的歌曲。开发一种输入格式，允许您为每个和弦指定不同的持续时间和每个音符内的不同振幅权重。创建测试文件，用各种和弦和谐波测试您的程序，并创建一个使用它们的
    *Elise 之歌* 版本。'
- en: '![Bar code example](../Images/9c64abfb5137c4db950e9882b8e70570.png)'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_IMG
  zh: '![条形码示例](../Images/9c64abfb5137c4db950e9882b8e70570.png)'
- en: '**Postal bar codes.** The [POSTNET barcode](http://en.wikipedia.org/wiki/POSTNET)
    used by the U.S. Postal System to route mail is defined as follows: Each decimal
    digit in the zip code is encoded using a sequence of three half-height and two
    full-height bars. The barcode starts and ends with a full-height bar (the guard
    rail) and includes a checksum digit (after the five-digit zip code or ZIP+4),
    computed by summing up the original digits modulo 10\. Implement the following
    functions:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**邮政条形码。** 美国邮政系统用于路由邮件的[POSTNET条形码](http://en.wikipedia.org/wiki/POSTNET)定义如下：邮政编码中的每个十进制数字都使用三个半高和两个全高的条形码进行编码。条形码以全高的条作为起始和结束（保护栏），并包括一个校验和数字（在五位邮政编码或ZIP+4之后），通过对原始数字取模10来计算。实现以下函数：'
- en: Draw a half-height or full-height bar on `stddraw`.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`stddraw`上绘制半高或全高的条形码。
- en: Given a digit, draw its sequence of bars.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个数字，绘制其条形码序列。
- en: Compute the checksum digit.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算校验和数字。
- en: and a test client that reads in a five- (or nine-) digit ZIP code as the command-line
    argument and draws the corresponding postal bar code.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及一个测试客户端，读取一个五位（或九位）数字的ZIP码作为命令行参数，并绘制相应的邮政条形码。
- en: '| Value | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 值 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| Encoding | `&#124;&#124;╷╷╷` | `╷╷╷&#124;&#124;` | `╷╷&#124;╷&#124;` | `╷╷&#124;&#124;╷`
    | `╷&#124;╷╷&#124;` | `╷&#124;╷&#124;╷` | `╷&#124;&#124;╷╷` | `&#124;╷╷╷&#124;`
    | `&#124;╷╷&#124;╷` | `&#124;╷&#124;╷╷` |'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | `&#124;&#124;╷╷╷` | `╷╷╷&#124;&#124;` | `╷╷&#124;╷&#124;` | `╷╷&#124;&#124;╷`
    | `╷&#124;╷╷&#124;` | `╷&#124;╷&#124;╷` | `╷&#124;&#124;╷╷` | `&#124;╷╷╷&#124;`
    | `&#124;╷╷&#124;╷` | `&#124;╷&#124;╷╷` |'
- en: '**Calendar.** Compose a program that takes two command-line arguments `m` and
    `y` and writes the monthly calendar for the `m`th month of year `y`, as in this
    example:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日历。** 编写一个程序，接受两个命令行参数`m`和`y`，并为年份`y`的第`m`个月写出月历，如下例所示：'
- en: '[PRE16]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Hint:* See [leapyear.py](../12types/leapyear.py.html) and the "Day of the
    week" exercise in Section 1.2.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：参见[leapyear.py](../12types/leapyear.py.html)和第1.2节中的“星期几”练习。'
- en: '*Solution*: See [calendar.py](calendar.py.html).'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[calendar.py](calendar.py.html)。'
- en: '**Fourier spikes.** Compose a program that takes a command-line argument *n*
    and plots the function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**傅里叶尖峰。** 编写一个程序，接受一个命令行参数*n*，并绘制函数：'
- en: '| (cos(*t*) + cos(2*t*) + cos(3*t*) + cos(4*t*) + ... + cos(*nt*)) / *n* |'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cos(*t*) + cos(2*t*) + cos(3*t*) + cos(4*t*) + ... + cos(*nt*)) / *n* |'
- en: 'for 500 equally spaced samples of *t* from -10 to 10 (in radians). Run your
    program for *n* = 5 and *n* = 500\. *Note*: You will observe that the sum converges
    to a spike (0 everywhere except a single value). This property is the basis for
    a proof that any smooth function can be expressed as a sum of sinusoids.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于从-10到10（以弧度为单位）均匀间隔的500个样本的*t*。运行你的程序，*n* = 5和*n* = 500。*注意*：你会发现总和收敛到一个尖峰（除了一个单一值外，其他地方都是0）。这个性质是证明任何光滑函数都可以表示为正弦波的和的基础。
