- en: Lecture 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3讲
- en: 原文：[https://cs50.harvard.edu/web/notes/3/](https://cs50.harvard.edu/web/notes/3/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/web/notes/3/](https://cs50.harvard.edu/web/notes/3/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#introduction)'
- en: '[Web Applications](#web-applications)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Web应用程序](#web-applications)'
- en: '[HTTP](#http)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HTTP](#http)'
- en: '[Django](#django)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Django](#django)'
- en: '[Routes](#routes)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[路由](#routes)'
- en: '[Templates](#templates)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模板](#templates)'
- en: '[Conditionals:](#conditionals)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[条件语句：](#conditionals)'
- en: '[Styling](#styling)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[样式](#styling)'
- en: '[Tasks](#tasks)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[任务](#tasks)'
- en: '[Forms](#forms)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表单](#forms)'
- en: '[Django Forms](#django-forms)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Django表单](#django-forms)'
- en: '[Sessions](#sessions)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[会话](#sessions)'
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we’ve discussed how to build simple web pages using HTML and CSS, and
    how to use Git and GitHub in order to keep track of changes to our code and collaborate
    with others. We also familiarized ourselves with the Python programming language.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何使用HTML和CSS构建简单的网页，以及如何使用Git和GitHub来跟踪代码更改并与他人协作。我们还熟悉了Python编程语言。
- en: Today, we’ll work on using Python’s `Django` framework in order to create dynamic
    applications.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将使用Python的`Django`框架来创建动态应用程序。
- en: Web Applications
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web应用程序
- en: So far, all of the web applications we’ve written have been **static**. This
    means that every single time we open that web page, it looks exactly the same.
    Many websites we visit every day, however, change every time we visit them. If
    you visit the websites of the [New York Times](https://www.nytimes.com/) or [Facebook](https://www.facebook.com/),
    for example, you’ll most likely see different things today than you will tomorrow.
    For large sites like those, it would be unreasonable for employees to have to
    manually edit a large HTML file every time a change is made, which is where **dynamic**
    websites can be extremely useful. A dynamic website is one that takes advantage
    of a programming language (such as Python) to dynamically generate HTML and CSS
    files. During this lecture, we’ll learn how to create our first dynamic applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有Web应用程序都是**静态的**。这意味着每次我们打开那个网页时，它看起来都完全一样。然而，我们每天访问的许多网站在每次访问时都会发生变化。例如，如果你访问了《纽约时报》（https://www.nytimes.com/）或Facebook（https://www.facebook.com/），你今天看到的内容很可能与明天不同。对于像这些大型网站，员工每次更改时手动编辑大型HTML文件是不合理的，这就是**动态网站**非常有用的地方。动态网站是利用编程语言（如Python）动态生成HTML和CSS文件的网站。在本讲中，我们将学习如何创建我们的第一个动态应用程序。
- en: HTTP
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP, or HyperText Transfer Protocol, is a widely-accepted protocol for how
    messages are transfered back and forth across the internet. Typically, information
    online is passed between a client (user) and a server. ![Client and Server](../Images/d7b712ff8baa3bb201f5fc3676d2ba5e.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP，或超文本传输协议，是一种广泛接受的协议，用于在互联网上传输消息。通常，在线信息是在客户端（用户）和服务器之间传递的。![客户端和服务器](../Images/d7b712ff8baa3bb201f5fc3676d2ba5e.png)
- en: In this protocol, the client will send a **request** to the server, that might
    look something like the one below. In the example below, `GET` is simply a type
    of request, one of three we’ll discuss in this course. The `/` typically indicates
    that we’re looking for the website’s home page, and the three dots indicate that
    we could be passing in more information as well. ![Request](../Images/a2f365144c4c3482b28570b643e78e64.png)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此协议中，客户端将向服务器发送一个**请求**，可能看起来像下面的示例。在下面的示例中，`GET`只是一个请求类型，我们将在本课程中讨论的三种类型之一。`/`通常表示我们正在寻找网站的首页，而三个点表示我们还可以传递更多信息。![请求](../Images/a2f365144c4c3482b28570b643e78e64.png)
- en: After receiving a request, a server will then send back an HTTP response, which
    might look something like the one below. Such a response will include the HTTP
    version, a status code (200 means OK), a description of the content, and then
    some additional information. ![Response](../Images/3e800780a29be4da43cab7778f98b5c7.png)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到请求后，服务器将发送一个HTTP响应，可能看起来像下面的示例。这样的响应将包括HTTP版本、状态码（200表示OK）、内容描述以及一些附加信息。![响应](../Images/3e800780a29be4da43cab7778f98b5c7.png)
- en: '200 is just one of many status codes, some of which you may have seen in the
    past: ![Codes](../Images/9177cf529cf839d25a31729e073aed9a.png)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 200只是许多状态码中的一个，其中一些你可能以前见过：![代码](../Images/9177cf529cf839d25a31729e073aed9a.png)
- en: Django
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django
- en: '[Django](https://www.djangoproject.com/) is a Python-based web framework that
    will allow us to write Python code that dynamically generates HTML and CSS. The
    advantage to using a framework like Django is that a lot of code is already written
    for us that we can take advantage of.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[Django](https://www.djangoproject.com/) 是一个基于 Python 的 Web 框架，它将允许我们编写动态生成
    HTML 和 CSS 的 Python 代码。使用像 Django 这样的框架的优势在于，已经为我们编写了很多代码，我们可以利用这些代码。'
- en: To get started, we’ll have to install Django, which means you’ll also have to
    [install pip](https://pip.pypa.io/en/stable/installing/) if you haven’t already
    done so.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要开始，我们必须安装 Django，这意味着如果您还没有这样做，您还必须[安装 pip](https://pip.pypa.io/en/stable/installing/)。
- en: Once you have Pip installed, you can run `pip3 install Django` in your terminal
    to install Django.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您安装了 Pip，您可以在终端中运行 `pip3 install Django` 来安装 Django。
- en: 'After installing Django, we can go through the steps of creating a new Django
    project:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Django 后，我们可以通过以下步骤创建一个新的 Django 项目：
- en: Run `django-admin startproject PROJECT_NAME` to create a number of starter files
    for our project.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `django-admin startproject PROJECT_NAME` 以创建我们项目的一些起始文件。
- en: Run `cd PROJECT_NAME` to navigate into your new project’s directory.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cd PROJECT_NAME` 以进入您的新项目目录。
- en: 'Open the directory in your text editor of choice. You’ll notice that some files
    have been created for you. We won’t need to look at most of these for now, but
    there are three that will be very important from the start:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的文本编辑器中打开该目录。您会注意到已经为您创建了某些文件。现在我们不需要查看这些文件中的大多数，但有三件从开始起就非常重要：
- en: '`manage.py` is what we use to execute commands on our terminal. We won’t have
    to edit it, but we’ll use it often.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manage.py` 是我们在终端上执行命令时使用的。我们不需要编辑它，但我们会经常使用它。'
- en: '`settings.py` contains some important configuration settings for our new project.
    There are some default settings, but we may wish to change some of them from time
    to time.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings.py` 包含了我们新项目的一些重要配置设置。有一些默认设置，但我们可能希望不时地更改其中的一些。'
- en: '`urls.py` contains directions for where users should be routed after navigating
    to a certain URL.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urls.py` 包含了用户在导航到特定 URL 后应被路由到的指示。'
- en: 'Start the project by running `python manage.py runserver`. This will open a
    development server, which you can access by visiting the URL provided. This development
    server is being run locally on your machine, meaning other people cannot access
    your website. This should bring you to a default landing page: ![Landing Page](../Images/80bc5358c8d34971cf0bbfa0fad09a62.png)'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `python manage.py runserver` 启动项目。这将打开一个开发服务器，您可以通过访问提供的 URL 来访问它。这个开发服务器是在您的机器上本地运行的，这意味着其他人无法访问您的网站。这应该会带您到一个默认的着陆页：![着陆页](../Images/80bc5358c8d34971cf0bbfa0fad09a62.png)
- en: Next, we’ll have to create an application. Django projects are split into one
    or more **applications**. Most of our projects will only require one application,
    but larger sites can make use of this ability to split a site into multiple apps.
    To create an application, we run `python manage.py startapp APP_NAME`. This will
    create some additional directories and files that will be useful shortly, including
    `views.py`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个应用。Django 项目分为一个或多个**应用**。我们的大多数项目只需要一个应用，但较大的网站可以利用这种将网站拆分为多个应用的能力。要创建一个应用，我们运行
    `python manage.py startapp APP_NAME`。这将创建一些额外的目录和文件，这些文件将很快变得有用，包括 `views.py`。
- en: Now, we have to install our new app. To do this, we go to `settings.py`, scroll
    down to the list of `INSTALLED_APPS`, and add the name of our new application
    to this list. ![installed apps](../Images/5baab872360d8f604af8c3ac9e046760.png)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须安装我们的新应用。为此，我们进入 `settings.py`，向下滚动到 `INSTALLED_APPS` 列表，并将我们新应用的名称添加到该列表中。![已安装应用](../Images/5baab872360d8f604af8c3ac9e046760.png)
- en: Routes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: 'Now, in order to get started with our application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了开始我们的应用：
- en: 'Next, we’ll navigate to `views.py`. This file will contain a number of different
    views, and we can think of a view for now as one page the user might like to see.
    To create our first view, we’ll write a function that takes in a `request`. For
    now, we’ll simply return an `HttpResponse` (A very simple response that includes
    a response code of 200 and a string of text that can be displayed in a web browser)
    of “Hello, World”. In order to do this, we have include `from django.http import
    HttpResponse`. Our file now looks like:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导航到 `views.py`。这个文件将包含多个不同的视图，我们可以将视图现在视为用户可能希望看到的一页。为了创建我们的第一个视图，我们将编写一个接受
    `request` 的函数。现在，我们将简单地返回一个 `HttpResponse`（一个非常简单的响应，包括一个200的响应代码和一个可以在网页浏览器中显示的文本字符串）。为了做到这一点，我们包含了
    `from django.http import HttpResponse`。我们的文件现在看起来像：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we need to somehow associate this view we have just created with a specific
    URL. To do this, we’ll create another file called `urls.py` in the same directory
    as `views.py`. We already have a `urls.py` file for the whole project, but it
    is best to have a separate one for each individual app.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要以某种方式将我们刚刚创建的视图与一个特定的 URL 关联起来。为此，我们将在与 `views.py` 相同的目录中创建另一个名为 `urls.py`
    的文件。我们已经有了一个整个项目的 `urls.py` 文件，但最好为每个单独的应用程序都保留一个。
- en: 'Inside our new `urls.py`, we’ll create a list of url patterns that a user might
    visit while using our website. In order to do this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新 `urls.py` 中，我们将创建一个用户在使用我们的网站时可能会访问的 URL 模式列表。为了做到这一点：
- en: 'We have to make some imports: `from django.urls import path` will give us the
    ability to reroute URLSs, and `from . import views` will import any functions
    we’ve created in `views.py`.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做一些导入：`from django.urls import path` 将给我们重定向 URL 的能力，而 `from . import views`
    将导入我们在 `views.py` 中创建的任何函数。
- en: Create a list called `urlpatterns`
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `urlpatterns` 的列表
- en: 'For each desired URL, add an item to the `urlpatterns` list that contains a
    call to the `path` function with two or three arguments: A string representing
    the URL path, a function from `views.py` that we wish to call when that URL is
    visited, and (optionally) a name for that path, in the format `name="something"`.
    For example, here’s what our simple app looks like now:'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个期望的 URL，向 `urlpatterns` 列表中添加一个项目，该项目包含对 `path` 函数的调用，该函数有两个或三个参数：一个表示 URL
    路径的字符串，一个在访问该 URL 时希望调用的 `views.py` 中的函数，以及（可选的）该路径的名称，格式为 `name="something"`。例如，这就是我们简单的应用程序现在看起来像：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we’ve created a `urls.py` for this specific application, and it’s time
    to edit the `urls.py` created for us for the entire project. When you open this
    file, you should see that there’s already a path called `admin` which we’ll go
    over in later lectures. We want to add another path for our new app, so we’ll
    add an item to the `urlpatterns` list. This follows the same pattern as our earlier
    paths, except instead of adding a function from `views.py` as our second argument,
    we want to be able to include *all* of the paths from the `urls.py` file within
    our application. To do this, we write: `include("APP_NAME.urls")`, where `include`
    is a function we gain access to by also importing `include` from `django.urls`
    as shown in the `urls.py` below:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经为这个特定应用程序创建了一个 `urls.py` 文件，并且是时候编辑为我们整个项目创建的 `urls.py` 文件了。当你打开这个文件时，你应该会看到已经有一个名为
    `admin` 的路径，我们将在后面的课程中讲解。我们想要为我们的新应用程序添加另一个路径，所以我们将向 `urlpatterns` 列表中添加一个项目。这遵循了我们之前路径相同的模式，除了我们不想将
    `views.py` 中的函数作为第二个参数添加，而是希望能够包含我们应用程序中 `urls.py` 文件内的所有路径。为此，我们写下：`include("APP_NAME.urls")`，其中
    `include` 是我们通过从 `django.urls` 中也导入 `include` 获得的函数，如下面的 `urls.py` 所示：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By doing this, we’ve specified that when a user visits our site, and then in
    the search bar adds `/hello` to the URL, they’ll be redirected to the paths inside
    of our new application.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样做，我们指定了当用户访问我们的网站，然后在搜索栏中添加 `/hello` 到 URL 时，他们将被重定向到我们新应用程序中的路径。
- en: 'Now, when I start my application using `python manage.py runserver` and visit
    the url provided, I’m met with this screen: ![wrong url](../Images/fc235b28104f1dec8b198eb07774dfdb.png)
    But this is because we have only defined the URL `localhost:8000/hello`, but we
    haven’t defined the URL `localhost:8000` with nothing added to the end. So, when
    I add `/hello` to the URL in my search bar: ![Hello, world](../Images/d9ff67c2a74b160e3724d485781f366b.png)
    Now that we’ve had some success, let’s go over what just happened to get us to
    that point:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我使用`python manage.py runserver`启动应用程序并访问提供的URL时，我遇到了这个屏幕：![错误的URL](../Images/fc235b28104f1dec8b198eb07774dfdb.png)
    但这是因为我们只定义了URL `localhost:8000/hello`，但没有定义末尾没有任何内容的URL `localhost:8000`。所以，当我在搜索栏中的URL中添加`/hello`时：![Hello,
    world](../Images/d9ff67c2a74b160e3724d485781f366b.png) 现在我们已经取得了一些成功，让我们回顾一下我们是如何到达这个点的：
- en: When we accessed the URL `localhost:8000/hello/`, Django looked at what came
    after the base URL (`localhost:8000/`) and went to our project’s `urls.py` file
    and searched for a pattern that matched `hello`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们访问URL `localhost:8000/hello/`时，Django查看基本URL（`localhost:8000/`）之后的内容，然后前往我们的项目`urls.py`文件并搜索与`hello`匹配的模式。
- en: It found that extension because we defined it, and saw that when met with that
    extension, it should `include` our `urls.py` file from within our application.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它之所以发现扩展，是因为我们定义了它，并且看到当遇到这种扩展时，它应该`包含`我们应用程序内的`urls.py`文件。
- en: Then, Django ignored the parts of the URL it has already used in rerouting (`localhost:8000/hello/`,
    or all of it) and looked inside our other `urls.py` file for a pattern that matches
    the remaining part of the URL.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Django在重定向时忽略了它已经使用的URL部分（`localhost:8000/hello/`，或者全部），并在我们的其他`urls.py`文件中寻找与URL剩余部分匹配的模式。
- en: It found that our only path so far (`""`) matched what was left of the URL,
    and so it directed us to the function from `views.py` associated with that path.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它发现我们迄今为止的唯一路径（`""`）与URL剩余部分匹配，因此它将我们导向与该路径关联的`views.py`中的函数。
- en: Finally, Django ran that function within `views.py`, and returned the result
    (`HttpResponse("Hello, world!")`) to our web browser.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，Django在`views.py`中运行该函数，并将结果（`HttpResponse("Hello, world!")`）返回到我们的网页浏览器。
- en: Now, if we want to, we can change the `index` function within `views.py` to
    return anything we want it to! We could even keep track of variables and do calculations
    within the function before eventually returning something.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想的话，我们可以将`views.py`中的`index`函数更改为返回我们想要的任何内容！我们甚至可以在函数中跟踪变量并进行计算，然后再返回某些内容。
- en: Now, let’s take a look at how we can add more than one view to our application.
    We can follow many of the same steps within our application to create pages that
    say hello to Brian and David.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何将多个视图添加到我们的应用程序中。我们可以在应用程序内部遵循许多相同的步骤来创建向布莱恩和大卫打招呼的页面。
- en: 'Inside `views.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.py`内部：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside `urls.py` (within our application)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`urls.py`（在我们的应用程序内部）
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, our site remains unchanged when we visit `localhost:8000/hello`, but we
    get different pages when we add `brian` or `david` to the URL: ![Brian](../Images/8c2f62370f5794a6ccf3352d2da2e04c.png)
    ![David](../Images/7c1d3e87fda9ac18616143fd790b12bf.png)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问`localhost:8000/hello`时，我们的网站保持不变，但当我们向URL中添加`brian`或`david`时，我们会得到不同的页面：![布莱恩](../Images/8c2f62370f5794a6ccf3352d2da2e04c.png)
    ![大卫](../Images/7c1d3e87fda9ac18616143fd790b12bf.png)
- en: Many sites are parameterized by items included in the URL. For example, going
    to [www.twitter.com/cs50](https://twitter.com/cs50) will show you all of CS50’s
    tweets, and going to [www.github.com/cs50](https://github.com/cs50) will bring
    you to CS50’s GitHub page. You can even find your own public GitHub repositories
    by navigating to `www.github.com/YOUR_USERNAME`!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站通过URL中包含的项目进行参数化。例如，访问[www.twitter.com/cs50](https://twitter.com/cs50)将显示CS50的所有推文，而访问[www.github.com/cs50](https://github.com/cs50)将带您到CS50的GitHub页面。您甚至可以通过导航到`www.github.com/YOUR_USERNAME`找到您自己的公共GitHub仓库！
- en: 'In thinking about how this is implemented, it seems impossible that sites like
    GitHub and Twitter would have an individual URL path for each of its users, so
    let’s look into how we could make a path that’s a bit more flexible. We’ll start
    by adding a more general function, called `greet`, to `views.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何实现这一点时，似乎不可能GitHub和Twitter这样的网站为每个用户都有一个单独的URL路径，因此让我们看看我们如何创建一个更灵活的路径。我们将从向`views.py`添加一个更通用的函数`greet`开始：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function takes in not only a request, but also an additional argument
    of a user’s name, and then returns a custom HTTP Response based on that name.
    Next, we have to create a more flexible path in `urls.py`, which could look something
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不仅接受一个请求，还接受一个额外的参数，即用户的名称，然后根据该名称返回一个自定义的 HTTP 响应。接下来，我们必须在 `urls.py` 中创建一个更灵活的路径，这可能看起来像这样：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is some new syntax, but essentially what’s going on here is we’re no longer
    looking for a specific word or name in the URL, but any string that a user might
    enter. Now, we can try the site out with a few other URLs: ![harry](../Images/be345d96c0985885731cb3f8bbc84728.png)
    ![connor](../Images/4e2552b9979befe16394a7f556ba3c7d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种新的语法，但本质上这里发生的事情是我们不再寻找 URL 中的特定单词或名称，而是任何用户可能输入的字符串。现在，我们可以尝试使用几个其他的 URL
    来测试网站：![harry](../Images/be345d96c0985885731cb3f8bbc84728.png) ![connor](../Images/4e2552b9979befe16394a7f556ba3c7d.png)
- en: 'I can even make these look a little bit nicer, by augmenting the `greet` function
    to utilize Python’s `capitalize` function that capitalizes a string:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至可以通过增强 `greet` 函数来利用 Python 的 `capitalize` 函数，使其字符串首字母大写，使这些看起来更美观一些：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Harry](../Images/230bb6c995eabb6e956f019e097f9e09.png) ![Connor](../Images/84f2fcc10a3f7ef4016ea3486816f240.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Harry](../Images/230bb6c995eabb6e956f019e097f9e09.png) ![Connor](../Images/84f2fcc10a3f7ef4016ea3486816f240.png)'
- en: This is a great illustration of how any functionality we have in Python can
    be used in Django before being returned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地说明了我们如何在 Python 中拥有的任何功能在返回之前都可以在 Django 中使用。
- en: Templates
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: 'So far, our HTTP Responses, have been only text, but we can include any HTML
    elements we want to! For example, I could decide to return a blue header instead
    of just the text in our `index` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 HTTP 响应只是文本，但我们可以包含我们想要的任何 HTML 元素！例如，我可以在 `index` 函数中决定返回一个蓝色标题而不是纯文本：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Blue](../Images/8d011a456b4064ab714962aebc4dbe3b.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![蓝色](../Images/8d011a456b4064ab714962aebc4dbe3b.png)'
- en: It would get very tedious to write an entire HTML page within `views.py`. It
    would also constitute bad design, as we want to keep separate parts of our project
    in separate files whenever possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `views.py` 中编写整个 HTML 页面会非常繁琐。这也会构成不良设计，因为我们希望在可能的情况下将项目的不同部分保存在不同的文件中。
- en: 'This is why we’ll now introduce [Django’s templates](https://docs.djangoproject.com/en/4.0/topics/templates/),
    which will allow us to write HTML and CSS in separate files and render those files
    using Django. The syntax we’ll use for rendering a template looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们现在要介绍 [Django 的模板](https://docs.djangoproject.com/en/4.0/topics/templates/)，它将允许我们在单独的文件中编写
    HTML 和 CSS，并使用 Django 渲染这些文件。我们将用于渲染模板的语法看起来是这样的：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we’ll need to create that template. To do this, we’ll create a folder called
    `templates` inside our app, then create a folder called `hello` (or whatever our
    app’s name is) within that, and then add a file called `index.html`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建这个模板。为此，我们将在我们的应用中创建一个名为 `templates` 的文件夹，然后在其中创建一个名为 `hello`（或我们应用的名称）的文件夹，最后添加一个名为
    `index.html` 的文件。
- en: '![Files](../Images/06345fe71dfb4c5fe77412eac64ca1c7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![文件](../Images/06345fe71dfb4c5fe77412eac64ca1c7.png)'
- en: 'Next, we’ll add whatever we want to that new file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们想要添加到新文件中的内容：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we visit the main page of our application, we can see the header
    and title have been updated: ![template0](../Images/dfd63be27cf7f52380537a62f90ea609.png)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问我们应用程序的主页时，我们可以看到标题和标题已经更新了：![template0](../Images/dfd63be27cf7f52380537a62f90ea609.png)
- en: 'In addition to writing some static HTML pages, we can also use [Django’s templating
    language](https://docs.djangoproject.com/en/4.0/ref/templates/language/) to change
    the content of our HTML files based on the URL visited. Let’s try it out by changing
    our `greet` function from earlier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写一些静态的 HTML 页面外，我们还可以使用 [Django 的模板语言](https://docs.djangoproject.com/en/4.0/ref/templates/language/)
    来根据访问的 URL 改变我们 HTML 文件的内容。让我们通过更改之前的 `greet` 函数来试一试：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that we passed a third argument into the `render` function here, one
    that is known as the **context**. In this context, we can provide information
    that we would like to have available within our HTML files. This context takes
    the form of a Python dictionary. Now, we can create a `greet.html` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `render` 函数中传递了第三个参数，这个参数被称为 **上下文**。在这个上下文中，我们可以提供我们希望在 HTML 文件中可用的信息。这个上下文以
    Python 字典的形式存在。现在，我们可以创建一个 `greet.html` 文件：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You’ll noticed that we used some new syntax: double curly brackets. This syntax
    allows us to access variables that we’ve provided in the `context` argument. Now,
    when we try it out: ![Template 1](../Images/8773e9ca9ba5901afc826f036a5ef196.png)
    ![Template 2](../Images/ab93e6d151068f37b9261dfc6435d5ce.png)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用了一些新的语法：双大括号。这种语法允许我们访问在 `context` 参数中提供的变量。现在，当我们尝试它时：![模板 1](../Images/8773e9ca9ba5901afc826f036a5ef196.png)
    ![模板 2](../Images/ab93e6d151068f37b9261dfc6435d5ce.png)
- en: 'Now, we’ve seen how we can modify our HTML templates based on the context we
    provide. However, the Django templating language is even more powerful than that,
    so let’s take a look at a few other ways it can be helpful:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了如何根据我们提供的上下文修改我们的 HTML 模板。然而，Django 模板语言比这更强大，所以让我们看看它还有哪些其他方式可以帮助我们：
- en: 'Conditionals:'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句：
- en: 'We may want to change what is displayed on our website depending on some conditions.
    For example, if you visit the site [www.isitchristmas.com](https://www.isitchristmas.com),
    you’ll probably be met with a page that looks like this: ![no](../Images/b6f82fda204c47a108a4f19a4315caca.png)
    But this website will change on Christmas day, when the website will say **YES**.
    To make something like this for ourselves, let’s try creating a similar application,
    where we check whether or not it is New Year’s Day. Let’s create a new app to
    do so, recalling our process for creating a new app:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望根据某些条件更改我们网站上显示的内容。例如，如果您访问网站 [www.isitchristmas.com](https://www.isitchristmas.com)，您可能会看到一个看起来像这样的页面：![无](../Images/b6f82fda204c47a108a4f19a4315caca.png)
    但这个网站在圣诞节那天会改变，届时网站会说 **YES**。为了创建类似的东西，让我们尝试创建一个类似的应用程序，其中我们检查是否是新年第一天。让我们创建一个新的应用程序来完成这个任务，回顾我们创建新应用程序的过程：
- en: run `python manage.py startapp newyear` in the terminal.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行 `python manage.py startapp newyear`。
- en: Edit `settings.py`, adding “newyear” as one of our `INSTALLED_APPS`
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `settings.py`，将“newyear”添加为我们的 `INSTALLED_APPS` 之一
- en: 'Edit our project’s `urls.py` file, and include a path similar to the one we
    created for the `hello` app:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑我们项目的 `urls.py` 文件，并包含一个类似于为 `hello` 应用程序创建的路径：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create another `urls.py` file within our new app’s directory, and update it
    to include a path similar to the index path in `hello`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们新应用程序的目录中创建另一个 `urls.py` 文件，并更新它以包含类似于 `hello` 中索引路径的路径：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create an index function in `views.py`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `views.py` 中创建一个索引函数。
- en: Now that we’re set up with our new app, let’s figure out how to check whether
    or not it’s New Year’s Day. To do this, we can import Python’s [datetime](https://docs.python.org/3/library/datetime.html)
    module. To get a sense for how this module works, we can look at the [documentation](https://docs.python.org/3/library/datetime.html),
    and then test it outside of Django using the Python interpreter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的新应用程序，让我们弄清楚如何检查是否是新年第一天。为此，我们可以导入 Python 的 [datetime](https://docs.python.org/3/library/datetime.html)
    模块。为了了解这个模块的工作方式，我们可以查看 [文档](https://docs.python.org/3/library/datetime.html)，然后使用
    Python 解释器在 Django 之外测试它。
- en: The **Python interpreter** is a tool we can use to test out small chunks of
    Python code. To use this, run `python` in your terminal, and then you’ll be able
    to type and run Python code within your terminal. When you’re done using the interpreter,
    run `exit()` to leave. ![interpreter](../Images/f580598eccbb5aa407303c74e4b5ee25.png)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 解释器** 是一个我们可以用来测试小块 Python 代码的工具。要使用它，请在您的终端中运行 `python`，然后您将能够在终端中输入并运行
    Python 代码。当您完成使用解释器后，运行 `exit()` 退出。![解释器](../Images/f580598eccbb5aa407303c74e4b5ee25.png)'
- en: 'We can use this knowledge to construct a boolean expression that will evaluate
    to True if and only if today is New Year’s Day: `now.day == 1 and now.month ==
    1`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用这个知识来构建一个布尔表达式，该表达式仅在今天是新年第一天时评估为 True：`now.day == 1 and now.month ==
    1`
- en: 'Now that we have an expression we can use to evaluate whether or not it’s New
    Year’s Day, we can update our index function in `views.py`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有一个可以用来评估是否是新年第一天的表达式，我们可以更新 `views.py` 中的索引函数：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s create our `index.html` template. We’ll have to again create a new
    folder called `templates`, a folder within that called `newyear`, and a file within
    that called `index.html`. Inside that file, we’ll write something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的 `index.html` 模板。我们再次需要创建一个名为 `templates` 的新文件夹，该文件夹位于其中，然后是一个名为
    `newyear` 的文件夹，以及一个名为 `index.html` 的文件。在该文件中，我们将编写如下内容：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the code above, notice that when we wish to include logic in our HTML files,
    we use `{%` and `%}` as opening and closing tags around logical statements. Also
    note that Django’s formatting language requires you to include an ending tag indicating
    that we are done with our `if-else` block. Now, we can open up to our page to
    see:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，请注意，当我们希望在 HTML 文件中包含逻辑时，我们使用 `{%` 和 `%}` 作为逻辑语句的开启和关闭标签。此外，请注意 Django
    的格式化语言要求你包含一个结束标签，表示我们已完成 `if-else` 块。现在，我们可以打开我们的页面来查看：
- en: '![No](../Images/55f37db379a5b5bd48a90d34da7b89be.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![No](../Images/55f37db379a5b5bd48a90d34da7b89be.png)'
- en: 'Now, to get a better idea of what’s going on behind the scenes, let’s inspect
    the element of this page:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地了解幕后发生的事情，让我们检查这个页面的元素：
- en: '![Source](../Images/8b5d422b624b6aa802f9f7a3c77c9cc4.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Source](../Images/8b5d422b624b6aa802f9f7a3c77c9cc4.png)'
- en: 'Notice that the HTML that is actually being sent to your web browser includes
    only the NO header, meaning that Django is using the HTML template we wrote to
    create a new HTML file, and then sending it to our web browser. If we cheat a
    little bit and make sure that our condition is always true, we see that the opposite
    case is filled:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实际上发送到你的网页浏览器的 HTML 只包括 NO 标题，这意味着 Django 正在使用我们编写的 HTML 模板来创建一个新的 HTML 文件，并将其发送到我们的网页浏览器。如果我们稍微作弊一下，确保我们的条件始终为真，我们会看到相反的情况被填充：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Yes](../Images/2f59c05a40f18d88ed1186fb10bdee1d.png) ![Source 0](../Images/486eddc03172c5bb7ea1e3b51c5cbfcc.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Yes](../Images/2f59c05a40f18d88ed1186fb10bdee1d.png) ![Source 0](../Images/486eddc03172c5bb7ea1e3b51c5cbfcc.png)'
- en: Styling
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: 'If we want to add a CSS file, which is a *static* file because it doesn’t change,
    we’ll first create a folder called `static`, then create a `newyear` folder within
    that, and then a `styles.css` file within that. In this file, we can add any styling
    we wish just as we did in the first lecture:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加一个 CSS 文件，它是一个 *静态* 文件，因为它不会改变，我们首先创建一个名为 `static` 的文件夹，然后在其中创建一个 `newyear`
    文件夹，最后在该文件夹中创建一个 `styles.css` 文件。在这个文件中，我们可以添加任何我们想要的样式，就像我们在第一节课中做的那样：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, to include this styling in our HTML file, we add the line `{% load static
    %}` to the top of our HTML template, which signals to Django that we wish to have
    access to the files in our `static` folder. Then, rather than hard-coding the
    link to a stylesheet as we did before, we’ll use some Django-specific syntax:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在 HTML 文件中包含这个样式，我们在 HTML 模板顶部添加一行 `{% load static %}`，这向 Django 信号我们希望访问
    `static` 文件夹中的文件。然后，而不是像之前那样硬编码样式表的链接，我们将使用一些 Django 特定的语法：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if we restart the server, we can see that the styling changes were in
    fact applied: ![big no](../Images/952a506dcf65dc9b4e878d7f45fea8e0.png)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新启动服务器，我们可以看到样式更改确实已经应用：![big no](../Images/952a506dcf65dc9b4e878d7f45fea8e0.png)
- en: Tasks
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'Now, let’s take what we’ve learned so far and apply it to a mini-project: creating
    a TODO list. Let’s start by, once again, creating a new app:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们迄今为止学到的知识应用到一个小型项目中：创建一个 TODO 列表。让我们再次创建一个新的应用：
- en: run `python manage.py startapp tasks` in the terminal.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行 `python manage.py startapp tasks`。
- en: Edit `settings.py`, adding “tasks” as one of our `INSTALLED_APPS`
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `settings.py`，将“tasks”添加为我们的 `INSTALLED_APPS` 之一
- en: 'Edit our project’s `urls.py` file, and include a path similar to the one we
    created for the `hello` app:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑我们项目的 `urls.py` 文件，并包含一个类似于为 `hello` 应用创建的路径：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create another `urls.py` file within our new app’s directory, and update it
    to include a path similar to the index path in `hello`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们新应用的目录中创建另一个 `urls.py` 文件，并将其更新为包含一个类似于 `hello` 中的索引路径：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Create an index function in `views.py`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `views.py` 中创建一个索引函数。
- en: Now, let’s begin by attempting to simply create a list of tasks and then display
    them to a page. Let’s create a Python list at the top of `views.py` where we’ll
    store our tasks. Then, we can update our `index` function to render a template,
    and provide our newly-created list as context.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先尝试简单地创建一个任务列表，并将其显示在页面上。让我们在 `views.py` 的顶部创建一个 Python 列表，我们将在这里存储我们的任务。然后，我们可以更新我们的
    `index` 函数以渲染一个模板，并提供我们新创建的列表作为上下文。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s work on creating our template HTML file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们着手创建我们的模板 HTML 文件：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice here that we are able to loop over our tasks using syntax similar to
    our conditionals from earlier, and also similar to a Python loop from Lecture
    2\. When we go to the tasks page now, we can see our list being rendered: ![tasks0](../Images/a5c01778153d09b2e4ae7c27b0e68bcf.png)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，我们能够使用类似于我们之前条件语句的语法，以及类似于第 2 节课中 Python 循环的语法来遍历我们的任务。当我们现在访问任务页面时，我们可以看到我们的列表被渲染：![tasks0](../Images/a5c01778153d09b2e4ae7c27b0e68bcf.png)
- en: Forms
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单
- en: 'Now that we can see all of our current tasks as a list, we may want to be able
    to add some new tasks. To do this we’ll start taking a look at using forms to
    update a web page. Let’s begin by adding another function to `views.py` that will
    render a page with a form for adding a new task:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到所有当前任务作为一个列表，我们可能想要能够添加一些新任务。为此，我们将开始查看如何使用表单来更新网页。让我们首先向 `views.py`
    添加另一个函数，该函数将渲染一个带有添加新任务表单的页面：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, make sure to add another path to `urls.py`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保向 `urls.py` 添加另一个路径：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we’ll create our `add.html` file, which is fairly similar to `index.html`,
    except that in the body we’ll include a form rather than a list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的 `add.html` 文件，它与 `index.html` 非常相似，只是在主体中我们将包含一个表单而不是列表：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, what we’ve just done isn’t necessarily the best design, as we’ve just
    repeated the bulk of that HTML in two different files. Django’s templating language
    gives us a way to eliminate this poor design: [template inheritance](https://tutorial.djangogirls.org/en/template_extending/).
    This allows us to create a `layout.html` file that will contain the general structure
    of our page:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们刚刚所做的不一定是最佳设计，因为我们已经在两个不同的文件中重复了大部分HTML。Django的模板语言为我们提供了一种消除这种糟糕设计的方法：[模板继承](https://tutorial.djangogirls.org/en/template_extending/)。这允许我们创建一个包含我们页面通用结构的
    `layout.html` 文件：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that we’ve again used `{%...%}` to denote some sort of non-HTML logic,
    and in this case, we’re telling Django to fill this “block” with some text from
    another file. Now, we can alter our other two HTML files to look like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们再次使用了 `{%...%}` 来表示某种非HTML逻辑，在这种情况下，我们告诉Django用来自另一个文件的一些文本填充这个“块”。现在，我们可以修改我们其他两个HTML文件，使其看起来像这样：
- en: '`index.html`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`:'
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`add.html`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`add.html`:'
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice how we can now get rid of much of the repeated code by *extending* our
    layout file. Now, our index page remains the same, and we now have an add page
    as well:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在可以通过 *扩展* 我们的布局文件来删除大部分重复的代码。现在，我们的索引页面保持不变，我们现在还有一个添加页面：
- en: '![Add](../Images/ecd21443fdda26bb5b4b2d0c7e7937ac.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![添加](../Images/ecd21443fdda26bb5b4b2d0c7e7937ac.png)'
- en: 'Next, it’s not ideal to have to type “/add” in the URL any time we want to
    add a new task, so we’ll probably want to add some links between pages. Instead
    of hard-coding links though, we can now use the `name` variable we assigned to
    each path in `urls.py`, and create a link that looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每次我们想要添加一个新任务时，在URL中输入“/add”并不是很理想，所以我们可能想要在页面之间添加一些链接。但是，我们不是硬编码链接，现在我们可以使用在
    `urls.py` 中为每个路径分配的 `name` 变量，创建一个看起来像这样的链接：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'where ‘add’ is the name of that path. We can do a similar thing in our `add.html`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 'add' 是该路径的名称。我们可以在 `add.html` 中做类似的事情：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This could potentially create a problem though, as we have a few routes named
    `index` throughout our different apps. We can solve this by going into each of
    our app’s `urls.py` file, and adding an `app_name` variable, so that the files
    now look something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会产生问题，因为我们有多个名为 `index` 的路由分布在不同的应用中。我们可以通过进入每个应用的 `urls.py` 文件，并添加一个 `app_name`
    变量来解决此问题，这样文件现在看起来就像这样：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can then change our links from simply `index` and `add` to `tasks:index`
    and `tasks:add`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将链接从简单的 `index` 和 `add` 改为 `tasks:index` 和 `tasks:add`
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s work on making sure the form actually does something when the user
    submits it. We can do this by adding an `action` to the form we have created in
    `add.html`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保当用户提交表单时表单实际上会做一些事情。我们可以通过向 `add.html` 中创建的表单添加一个 `action` 来做到这一点：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This means that once the form is submitted, we will be routed back to the `add`
    URL. Here we’ve specified that we’ll be using a *post* method rather than a *get*
    method, which is typically what we’ll use any time a form could alter the state
    of that web page.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦表单提交，我们将被路由回 `add` URL。在这里，我们指定我们将使用 *post* 方法而不是 *get* 方法，这通常是我们在表单可能改变该网页状态时使用的方法。
- en: We need to add a bit more to this form now, because Django requires a token
    to prevent [Cross-Site Request Forgery (CSRF) Attack](https://portswigger.net/web-security/csrf).
    This is an attack where a malicious user attempts to send a request to your server
    from somewhere other than your site. This could be a really big problem for some
    websites. Say, for example, that a banking website has a form for one user to
    transfer money to another one. It would be catastrophic if someone could submit
    a transfer from outside of the bank’s website!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对这个表单添加更多内容，因为Django需要一个令牌来防止[跨站请求伪造（CSRF）攻击](https://portswigger.net/web-security/csrf)。这种攻击是指恶意用户试图从你的网站之外发送请求到你的服务器。这对某些网站来说可能是一个大问题。比如说，一个银行网站有一个表单，允许一个用户向另一个用户转账。如果有人能够从银行网站之外提交转账，那将是一场灾难！
- en: To solve this problem, when Django sends a response rendering a template, it
    also provides a **CSRF token** that is unique with each new session on the site.
    Then, when a request is submitted, Django checks to make sure the CSRF token associated
    with the request matches one that it has recently provided. Therefore, if a malicious
    user on another site attempted to submit a request, they would be blocked due
    to an invalid CSRF token. This CSRF validation is built into the [Django Middleware](https://docs.djangoproject.com/en/4.0/topics/http/middleware/)
    framework, which can intervene in the request-response processing of a Django
    app. We won’t go into any more detail about Middleware in this course, but do
    look at the [documentation](https://docs.djangoproject.com/en/4.0/topics/http/middleware/)
    if interested!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，当Django发送响应渲染模板时，它还会提供一个**CSRF令牌**，该令牌在每个新的会话中都是唯一的。然后，当提交请求时，Django会检查请求关联的CSRF令牌是否与它最近提供的令牌匹配。因此，如果另一个网站上的恶意用户试图提交请求，他们将会因为无效的CSRF令牌而被阻止。这种CSRF验证是内置在[Django中间件](https://docs.djangoproject.com/en/4.0/topics/http/middleware/)框架中的，它可以干预Django应用的请求-响应处理。我们在这门课程中不会进一步讨论中间件，但如果感兴趣，请查看[文档](https://docs.djangoproject.com/en/4.0/topics/http/middleware/)！
- en: To incorporate this technology into our code, we must add a line to our form
    in `add.html`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这项技术整合到我们的代码中，我们必须在`add.html`表单中添加一行代码。
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This line adds a hidden input field with the CSRF token provided by Django,
    such that when we reload the page, it looks as though nothing has changed. However,
    if we inspect element, we’ll notice that a new input field has been added: ![CSRF](../Images/2a1d56d40c720cc4350ce8cda98f4194.png)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码添加了一个由Django提供的CSRF令牌的隐藏输入字段，这样当我们重新加载页面时，看起来好像没有变化。然而，如果我们检查元素，我们会注意到添加了一个新的输入字段：![CSRF](../Images/2a1d56d40c720cc4350ce8cda98f4194.png)
- en: Django Forms
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Django表单
- en: 'While we can create forms by writing raw HTML as we’ve just done, Django provides
    an even easier way to collect information from a user: [Django Forms](https://docs.djangoproject.com/en/4.0/ref/forms/api/).
    In order to use this method, we’ll add the following to the top of `views.py`
    to import the `forms` module:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以像刚才那样通过编写原始HTML来创建表单，但Django提供了一个更简单的方法来收集用户信息：[Django表单](https://docs.djangoproject.com/en/4.0/ref/forms/api/)。为了使用这种方法，我们需要在`views.py`的顶部添加以下内容以导入`forms`模块：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can create a new form within `views.py` by creating a Python class
    called `NewTaskForm`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`views.py`中创建一个新的表单，通过创建一个名为`NewTaskForm`的Python类来实现：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let’s go through what’s going on in that class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这个类中发生了什么：
- en: Inside the parentheses after `NewTaskForm`, we see that we have `forms.Form`.
    This is because our new form [inherits](https://www.w3schools.com/python/python_inheritance.asp)
    from a class called `Form` that is included in the `forms` module. We’ve already
    seen how inheritance can be used in Django’s templating language and for styling
    using Sass. This is another example of how inheritance is used to take a more
    general description (the `forms.Form` class) and narrow it down to what we want
    (our new Form). Inheritance is a key part of Object Oriented Programming that
    we won’t discuss in detail during this course, but there are [many online resources](https://www.w3schools.com/python/python_inheritance.asp)
    available to learn about the topic!
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`NewTaskForm`括号后面，我们看到我们使用了`forms.Form`。这是因为我们的新表单[继承自](https://www.w3schools.com/python/python_inheritance.asp)一个名为`Form`的类，该类包含在`forms`模块中。我们已经看到了如何在Django的模板语言和Sass样式中使用继承。这是继承如何被用来从一个更通用的描述（`forms.Form`类）缩小到我们想要的（我们的新表单）的另一个例子。继承是面向对象编程的关键部分，我们在这门课程中不会详细讨论，但关于这个主题有[许多在线资源](https://www.w3schools.com/python/python_inheritance.asp)可供学习！
- en: Inside this class, we can specify what information we would like to collect
    from the user, in this case the name of a task.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个类内部，我们可以指定我们希望从用户那里收集哪些信息，在这种情况下是任务的名称。
- en: We specify that this should be a textual input by writing `forms.CharField`,
    but there are [many other input fields](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#built-in-field-classes)
    included in Django’s form module that we can choose from.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过编写`forms.CharField`来指定这是一个文本输入，但Django的表单模块中包含了[许多其他输入字段](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#built-in-field-classes)，我们可以从中选择。
- en: Within this `CharField`, we specify a `label`, which will appear to the user
    when they load the page. A `label` is just one of [many arguments](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments)
    we can pass into a form field.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个`CharField`中，我们指定一个`label`，当用户加载页面时会显示出来。`label`只是我们可以传递给表单字段的[许多参数](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments)之一。
- en: 'Now that we’ve created a `NewTaskForm` class, we can include it in the context
    while rendering the `add` page:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`NewTaskForm`类，我们可以在渲染`add`页面时将其包含在上下文中：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, within `add.html`, we can replace our input field with the form we just
    created:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`add.html`中，我们可以用我们刚刚创建的表单替换我们的输入字段：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are several advantages to using the `forms` module rather than manually
    writing an HTML form:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`forms`模块而不是手动编写HTML表单有几个优点：
- en: If we want to add new fields to the form, we can simply add them in `views.py`
    without typing additional HTML.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在表单中添加新字段，我们可以在`views.py`中简单地添加它们，而无需编写额外的HTML。
- en: Django automatically performs [client-side validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation),
    or validation local to the user’s machine. meaning it will not allow a user to
    submit their form if it is incomplete.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django自动执行[客户端验证](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation)，或用户机器本地的验证。这意味着它不会允许用户提交不完整的表单。
- en: Django provides simple [server-side validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation),
    or validation that occurs once form data has reached the server.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django提供了简单的[服务器端验证](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation)，或验证在表单数据到达服务器后发生。
- en: In the next lecture, we’ll begin using **models** to store information, and
    Django makes it very simple to create a form based on a model.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一讲中，我们将开始使用**模型**来存储信息，Django使得根据模型创建表单变得非常简单。
- en: 'Now that we have a form set up, let’s work on what happens when a user clicks
    the submit button. When a user navigates to the add page by clicking a link or
    typing in the URL, they submit a `GET` request to the server, which we’ve already
    handled in our `add` function. When a user submits a form though, they send a
    `POST` request to the server, which at the moment is not handled in the `add`
    function. We can handle a `POST` method by adding a condition based on the `request`
    argument our function takes in. The comments in the code below explain the purpose
    of each line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了表单，让我们来处理用户点击提交按钮时会发生什么。当用户通过点击链接或输入URL导航到添加页面时，他们向服务器发送一个`GET`请求，我们已经在`add`函数中处理了它。但是，当用户提交表单时，他们向服务器发送一个`POST`请求，目前这个请求在`add`函数中没有被处理。我们可以通过在函数接收的`request`参数上添加条件来处理`POST`方法。下面代码中的注释解释了每行的目的：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A quick note: in order to redirect the user after a successful submission,
    we need a few more imports:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 简要说明：为了在成功提交后重定向用户，我们需要导入一些额外的模块：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Sessions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话
- en: At this point, we’ve successfully built an application that allows us to add
    tasks to a growing list. However, it may be a problem that we store these tasks
    as a global variable, as it means that all of the users who visit the page see
    the exact same list. In order to solve this problem we’re going to employ a tool
    known as [sessions.](https://docs.djangoproject.com/en/4.0/topics/http/sessions/)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功构建了一个应用程序，允许我们向不断增长的任务列表中添加任务。然而，将任务存储为全局变量可能是一个问题，因为它意味着所有访问页面的用户都会看到完全相同的列表。为了解决这个问题，我们将使用一个称为[sessions](https://docs.djangoproject.com/en/4.0/topics/http/sessions/)的工具。
- en: Sessions are a way to store unique data on the server side for each new visit
    to a website.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是存储在服务器端为每个新访问网站的唯一数据的方式。
- en: To use sessions in our application, we’ll first delete our global `tasks` variable,
    then alter our `index` function, and finally make sure that anywhere else we had
    used the variable `tasks`, we replace it with `request.session["tasks"]`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用会话，我们首先会删除全局`tasks`变量，然后修改我们的`index`函数，最后确保在之前任何使用变量`tasks`的地方，我们都将其替换为`request.session["tasks"]`。
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, before Django will be able to store this data, we must run `python
    manage.py migrate` in the terminal. Next week we’ll talk more about what a migration
    is, but for now just know that the above command allows us to store sessions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Django能够存储这些数据之前，我们必须在终端中运行`python manage.py migrate`。下周我们将更详细地讨论迁移是什么，但现阶段只需知道上述命令允许我们存储会话。
- en: That’s all for this lecture! Next time we’ll be working on using Django to store,
    access, and manipulate data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课的内容就到这里！下次我们将讨论如何使用Django来存储、访问和操作数据。
