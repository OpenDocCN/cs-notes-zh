- en: P16：Lecture 15 Networks and Clients - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P16：第15讲 网络与客户端 - ___主___ - BV1ED4y1R7RJ
- en: Okay， so we are going to continue our discussion about networks。 I hope the
    assignment is going well。 I am going to have some off-sours right after class
    today for an hour。 hour and a half or， so。 So feel free to stop by if you'd like。
    But today we're going to continue working on networks and I think we're going
    to get。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么我们将继续讨论网络。希望作业进展顺利。今天下课后我会有一个小型辅导会，大概一个小时或一个半小时。所以如果你愿意，可以随时过来。但今天我们将继续研究网络，我认为我们将会进一步深入。
- en: to a point today where you go， "Oh， I see what's going on here with the wavy
    internet。 works a little bit。"， And hopefully it will be interesting。 But there
    is a handout because there's tons of code and today is going to be another。 day
    where I'm not going to just like furiously type code。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天你会到达一个点，你会说：“哦，我明白这里的波动互联网是怎么回事了。它确实有效一点。”希望这会很有趣。不过有个讲义，因为有很多代码，今天又是那种我不会只是疯狂输入代码的一天。
- en: I actually did this lecture last quarter and it was a nightmare because it was
    like my。 fingers were cracked by the end of it and people were saying that's a
    ridiculous amount。 of code to put on the board or to try to do live。 So you've
    got a whole bunch of code here。 We will go through it slow enough on the board
    so that you can either take notes or。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我在上个季度做了这次讲座，那简直是噩梦，因为到最后我的手指都快裂开了，人们都说这是一堆荒谬的代码，根本不可能把这些代码写在黑板上或是试图现场做。所以你会看到很多代码。我们会慢慢地在黑板上讲解，让你可以记笔记或者。
- en: ask whatever questions you have。 So hopefully that will work out。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 提出任何问题。所以希望一切能顺利。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_1.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_1.png)'
- en: So let's go back to where we were at the end of Monday's lecture which was to
    say we built。 our first client and the client was as simple as basically saying，
    "Okay， we are going to。 create a client socket and we're going to dig into those
    details。 We're going to do it a little more manually today and you'll see some
    more details but。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们回到周一讲座结束时的地方，也就是我们构建了第一个客户端，这个客户端基本上非常简单，就是说：“好，我们要创建一个客户端套接字，我们会深入了解这些细节。今天我们会做得更手动一些，你会看到更多的细节，但。
- en: there will be details we see today that I don't want you to concentrate on。
    You can look at them and go， "Oh， those are some details but I don't want you
    to think。 about the wheel talk about those next week。"， But that's like how the
    connection is built and then we basically set up a little stream。 to be able to
    in this case to be able to read from the server whatever the server tells。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们会看到一些细节，我不希望你们过于关注。你可以看一下这些细节，心想‘哦，那些是一些细节’，但我不希望你去思考。我们下周再讲这些。”但这就是连接是如何建立的，然后我们基本上设置了一个小的流，以便能够从服务器读取服务器告诉我们的内容。
- en: us and that's it and then we're printing it out。 So this is like the most basic
    server。 Now often you want to actually have some sort of like you want to send
    the server some information。 which we'll do by via the actual URL today and then
    of course you want to get more information。 back maybe in another particular form。
    So we will see how that works with a couple of examples。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，然后我们打印出来。所以这是最基础的服务器。现在通常你可能会希望实际上向服务器发送一些信息，我们今天就通过实际的 URL 来实现，然后当然你还想获取更多的信息，可能是以其他特定的形式返回。我们将通过几个例子来看看如何实现。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_3.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_3.png)'
- en: So the first example we're going to look at and I mentioned it， I talked a little
    bit about。 how it works and I showed you an example on Monday is this WGet function。
    This is built in for Linux and you can see that by typing WGetGoogle。com and it
    will actually。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们要看的第一个例子，我提到过，我在周一的时候稍微谈了一下它是如何工作的，并且展示了一个例子，就是这个 WGet 函数。这个功能是 Linux 内置的，你可以通过输入
    WGetGoogle.com 来看到它实际的。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_5.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_5.png)'
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_6.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_6.png)'
- en: pull down the results of Google。com to a file。 In this case it saves it as index。html
    and that's it。 So there's the Google homepage right there in a file called index。html
    which I just used。 WGet to get。 It's a pretty simple thing。 You need to request
    it from the website。 the website sends it back to you and restore it。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Google.com 下载结果到一个文件中。在这个例子中，它将结果保存为 index.html，就这样。所以这里就是 Google 首页，保存在一个叫做
    index.html 的文件中，我刚刚用 WGet 获取的。这是一个非常简单的操作。你只需要向网站请求，网站会把它发送回来并保存。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_8.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_8.png)'
- en: So that's what we're going to build。 And here's what we're going to do with
    it。 We are going to。 we have to remember the， we're going to build the server
    part as it turns， out。 And the。 in this case rather not the server part， sorry
    we're going to build the client。 part in this case which is going to take a URL
    and it's going to get the URL and break。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要构建的就是这个。接下来我们要做的是，我们必须记住，我们将构建的是客户端部分，而不是服务器部分，抱歉，之前说错了。我们将构建客户端部分，它将接收一个
    URL，并解析它。
- en: it into its parts。 Okay， so that's like Google is not a great example but web。stanford。edu/class110
    is like， what you might pass into it。 And what it needs to do is this is the part
    that you connect to。 web。stanford。edu and the， rest is basically the path name。
    So we need to break that into parts。 So we can actually use the part， a part URL
    function to do this。 Okay。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它将把 URL 拆解成各个部分。好吧，像 Google 并不是一个很好的例子，但 web.stanford.edu/class110 就像是你可能传递给它的
    URL。它需要做的是，连接到 web.stanford.edu 这一部分，剩下的基本上就是路径名。所以我们需要将它拆解成部分。我们可以使用部分 URL 函数来完成这项工作。
- en: and most of our URLs are going to start with HTTP colon colon。 As it turns out
    HTTP that's basically tells you hey you're going to the world wide web。 Most of
    the websites you go to these days are HTTPS which stands for secure which is。
    a much better way of doing it so the data actually comes across encrypted。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数 URL 都会以 HTTP:// 开头。事实证明，HTTP 基本上告诉你“嘿，你正在访问万维网”。如今，你访问的大多数网站都是 HTTPS，代表“安全”，这是一种更好的做法，因为数据实际上是经过加密的。
- en: Because as you may or may not know， I mean when radio signals get sent to the
    router。 unless it's an encrypted site all of the text that's sent back and forth
    is completely， unencrypted。 Now if you have a password or if you have that sort
    of thing they encrypt， you can encrypt。 that in other ways。 But in general HTTP
    sites are not encrypted。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可能知道也可能不知道，我的意思是，当无线电信号发送到路由器时，除非是加密站点，否则来回发送的所有文本都是完全未加密的。如果你有密码，或者有类似的东西，它们是可以加密的，当然，也可以通过其他方式进行加密。但一般来说，HTTP
    网站是不加密的。
- en: it doesn't matter that much for some sites。 But it does mean that you could
    have what's called a man in the middle attack where you。 have， I guess you could
    for HTTPS to some extent， but you could have an attack where。 you think you're
    getting data back from a non-secure site and it's coming from some other site。
    That might not be what you want。 So you should prefer HTTPS。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些网站来说这并不重要。但这意味着你可能会遭遇所谓的中间人攻击，在这种攻击中，你以为从一个不安全的站点获取数据，实际上数据来自另一个站点。这可能不是你想要的。因此，你应该更倾向于使用
    HTTPS。
- en: For now we're just going to do with HTTP because we don't want to deal with
    encryption。 Most of it actually happens at a lower level than what we're dealing
    with anyway。 But for now we're going to go with HTTP。 And the default path is
    just slash。 That means like if you google。com the default path is just slash。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只使用 HTTP，因为我们不想处理加密。实际上，大部分处理发生在我们所处理的层次以下。但现在我们将使用 HTTP。默认路径就是斜杠。这意味着如果你输入
    google.com，默认路径就是斜杠。
- en: So what we're doing in here is we are basically pulling the URL apart and we're
    just saying。 look if it starts with HTTP then we actually need to get the rest
    of it which is what。 this substring line does here。 And then you're then going
    to look for a slash and if you have a slash everything after the。 slash is the
    actual path name。 So that's kind of what it is and the rest is the host part of
    it which is like google。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里做的其实是将 URL 拆解开来，我们只是说，如果它以 HTTP 开头，那么我们实际上需要获取它的其余部分，这就是这行 substring
    代码的作用。然后你会寻找斜杠，如果有斜杠，那么斜杠后面的就是实际的路径名。所以大概就是这样，其余的部分是主机部分，比如 google。
- en: com， or stamp for web。stanford。edu。 That's all this is doing。 Not that much
    to it。 It is returning a pair。 Why is it returning a pair？ Because C++ only allows
    you to return one thing。 And so in this case we're returning we want to return
    both the host and a path。 So we're returning a pair。 You could also return to
    vector or an array or something like that whatever。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: com，或者是 web.stanford.edu 这类的网址，实际上就是这样做的。没什么复杂的，就是返回一个对。为什么返回一个对？因为 C++ 只允许返回一个东西。所以在这种情况下，我们返回的是主机和路径。因此，我们返回一个对。你也可以返回一个向量或数组，或者类似的东西，随便。
- en: But the point is that in this case we're just making a pair sending that back
    and dealing。 with the first and second of the pair。 Okay。 Pretty straightforward。
    And this by the way means if you are trying to use the find on the string if the
    find。 is not found that's string colon colon and pass that means that you are
    going to use。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但关键是，在这种情况下，我们只是传递一个键值对，然后处理这个键值对的第一个和第二个部分。好的，挺直接的。顺便说一下，如果你尝试在字符串上使用find方法，如果没有找到，你会得到string::npos，这意味着你将使用。
- en: the default path which is just slash means that you just said hey I want google。com
    with。 no extra stuff on it。 Okay。 That's that。 Main in this case is just going
    to have one it's going to call one function which is poll。 content which is going
    to actually do the request and get the result back and then save it into。 a file。
    That's what we're doing。 We'll break these up into other little parts as we go。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认路径就是斜杠，这意味着你只是说“嘿，我想要google.com”，没有任何附加的内容。好的。至于这个，主要部分将只调用一个函数，就是poll content，它将实际发起请求，获取结果并保存到文件中。这就是我们要做的。我们会在后续将这些步骤拆分成其他部分。
- en: That's really all we're doing right we're going to a website requesting the
    website and。 then asking for the and then getting the data saving to a file that's
    all W get does。 It turns out。 Okay。 Questions on that？ Yeah。 Awesome。 Yeah。 That's
    like Google。com slash which is your question。 What it's the slash part is the
    default path and that just means there's no extra stuff。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其实我们所做的就是去一个网站，发出请求，接着请求，获取数据并保存到文件，这就是Wget的工作原理。结果是这样的。好吧，有什么问题吗？是的。太棒了。是的。这就像Google.com/，就是你的问题所在。斜杠部分是默认路径，意味着没有额外的内容。
- en: after the you are the actual website you're going to we'll see why that makes
    a difference。 in a little bit but it makes difference for doing like class slash
    class last CS 110 that's。 our class which is a shared website on all the entire
    Stanford web service。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你去到实际的网站后，我们稍后会看到为什么这有区别。这对做类似class/CS 110这种事有影响。这是我们的课程，它是一个共享网站，整个斯坦福的网络服务上都可以访问。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_10.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_10.png)'
- en: Good anybody else？ Okay。 All right。 So poll content is going to do the actual
    like hey we need to set up a client socket。 Okay。 We will see again we'll see
    in a little bit doing some things a little different with this。 one but for now
    we're just going to set up the client socket。 And we are going to then do a little
    error checking if we were to get set up。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，还有其他人吗？好的。那么，poll content将做实际的工作，比如“嘿，我们需要设置一个客户端套接字”。好的，稍后我们会看到一些不同的实现方式。但现在我们只是设置客户端套接字。然后我们将进行一些错误检查，看看是否正确设置。
- en: Then we're setting up a stream and the stream is going to be to actually be
    able to send。 to the to the server to say hey give me the data。 Okay。 So we're
    setting up the stream and then we're issuing a request。 We are going to skip all
    the headers。 Remember when a website comes back it actually gives you a whole
    bunch of details and we're。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们正在设置一个流，这个流将实际向服务器发送请求，说“嘿，给我数据”。好的。所以我们正在设置流，然后发出请求。我们将跳过所有的头部信息。记住，当一个网站响应时，它会返回很多详细信息，我们。
- en: going to look and we're going to see those some of those details a little later
    and those。 details we don't care about for this website you might care about them。
    You can ask for a you can ask for a website to be compressed coming back to you
    if you。 want and so that would be a header saying hey this is a compression I
    chose and then you'd。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会稍后看到一些具体细节，这些细节对我们这个网站来说不重要，但你可能会在其他网站上在意这些。你可以要求网站返回经过压缩的数据，如果你愿意的话。那时，服务器会在头部告知你压缩类型。
- en: have to decompress it yourself but we're not going to worry about that we're
    just going。 raw text back from the server。 Okay。 And then we're going to actually
    have to save it to a file as well。 Okay。 So we're going to create a client socket。
    Okay。 So by the way what we really need for that we need just the first part just
    the URL because。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你得自己解压，但我们现在不需要担心这些，我们直接从服务器拿回原始文本。好的。然后我们还得把它保存到文件中。好的。所以我们将创建一个客户端套接字。顺便说一句，为了这个，我们只需要URL的第一部分，因为。
- en: that's how you set it up。 We don't care that it's slash class slash CS 110 we
    care that it's web。stanford。edu。 That's what we're connecting to on a particular
    port for the internet ports are 80 like that's。 the main internet port。 Sometimes
    you also see 80 80 or 8。000 or whatever those are some kind of default ones but
    the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你如何设置它。我们不在乎它是`/class/CS110`，我们关心的是`web.stanford.edu`。这就是我们要连接的目标，连接到特定的端口上。互联网的端口通常是80端口，那是主要的互联网端口。有时你也会看到80
    80端口，或者8000端口等，这些都是一些默认端口。
- en: world wide web lives on port 80 for servers。 It's just generally where it lives。
    Okay。 And again you can change that if you have a home network that you don't
    want any other。 people to know about you can say hey forward my traffic to a different
    port get my website。 from a different port and people won't necessarily know how
    to connect to it unless they say。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网（World Wide Web）运行在80端口上供服务器使用。这通常就是它所在的位置。好吧。如果你有一个家庭网络，且不希望其他人知道，你可以设置将流量转发到另一个端口，从而使得他人无法直接知道如何连接到它，除非他们知道。
- en: the port number。 That's the way that works。 Okay。 What questions do you have
    on this？ Yes。 What is component？ The components is the pair that we passed in。
    It's the host and the actual path name or path。 Yeah。 Good question。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号就是这样工作的。好的，关于这方面你有什么问题吗？是的，什么是组件？组件就是我们传递的那一对参数。它是主机名和实际的路径名或路径。是的，好的问题。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_12.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_12.png)'
- en: Anybody else？ Alright。 It's still pretty straightforward so far。 Okay。 Now we
    have to start doing the details。 Now remember when I did Talnet the other day。
    Okay。 The Talnet command for internet websites or not the Talnet command the actual
    HTTP request。 is very well defined。 And it starts out with get and then the path
    and then it says what protocol we're using。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他问题吗？好吧，到目前为止还是挺直观的。接下来，我们需要开始处理一些细节。记得我前几天做的Telnet吗？好的，实际上，Telnet命令或者说是实际的HTTP请求非常明确。它以`GET`开始，然后是路径，再到它所使用的协议。
- en: In this case HTTP 1。0 or 1。1 probably doesn't matter which one you use in this
    case。 And then it has this interesting backslash R backslash N。 Well we know what
    backslash， N means。 It means new line。 Well it kind of means new line but really
    it means new line in the sense that it means。 go directly down to the next line。
    The backslash R is what we call a carriage return。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，HTTP 1.0或1.1，使用哪个版本大概没有太大关系。接着，它会有一个有趣的`\r\n`。我们知道`\n`是什么意思，它表示换行。嗯，它其实更准确地说是“换行”，但它的真正含义是“直接跳到下一行”。`\r`是我们所说的回车符。
- en: And a carriage return comes from the typewriter days where when you hit like
    the， well it used。 to be you actually had to hit a little lever that pushed this
    carriage where the paper was。 moving back and forth。 That's what happened in typewriter。
    You should check some out sometime。 Come to my office。 You can see a cool typewriter
    project or a couple of them。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回车（carriage return）这一概念源自打字机时代，当你按下回车键时，实际上是按下一个小杠杆，推动打字机的纸张来回移动。打字机就是这样工作的。你可以找时间看看打字机。来我办公室看看，我有一个很酷的打字机项目，或者几个。
- en: And anyway the carriage return meant that the entire paper would go juke back
    to the other， side。 I guess from your perspective it's our juke back to the other
    side。 And that's what's happening with the backslash R。 Backslash R backslash
    N is what you really should send whenever you are saying I am。 done with a line
    to the server。 It just happens to be that's the way it was that's the way it ends
    up working out。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，回车意味着整个纸张会“嘟嘟”地回到另一侧。从你的角度看，它是“嘟嘟”回到另一侧。这就是`\r`的作用。`\r\n`应该是你每次告诉服务器“我完成这一行了”时应该发送的内容。这就是它的工作方式，它就是这么运作的。
- en: Unix just kind of doesn't really use the backslash R often。 It just means look
    I want to go to the next line and go all the way to the front。 But you do need
    the backslash R in there as well。 Yeah， question？ Why don't you use N to L？
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统通常不会经常使用回车符`\r`。它的意思是“去下一行并回到行首”。但你仍然需要在这里使用回车符`\r`。是的，有问题吗？为什么不使用`\n`来换行？
- en: Good question。 N to L will only send the backslash N as it turns out。 Yeah。
    Good question though。 Backslash N just does the Unix way of doing it just does
    backslash N。 Which is not just what we want。 Okay。 So it does that。 Then the next
    line it says the host that you are on and the actual that takes the host。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。N 到 L 只会发送反斜杠 N，事实证明是这样。是的，虽然是个好问题。反斜杠 N 只是做了 Unix 的方式，就是发送反斜杠 N。这个不是我们想要的。好的。所以它这么做了。然后下一行它会显示你所在的主机，和实际的主机地址。
- en: and then another backslash R backslash N。 Tell that we will send that for you
    by the way， correctly。 And then we send another blank line to say we are done
    with our request and then we flush。 Now we have to flush the actual data which
    means if it is buffered in the system somewhere。 make sure it actually gets to
    the other computer。 Okay。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是另一个反斜杠 R 反斜杠 N。告诉我们会正确地为你发送这个。然后我们发送另一个空行，表示我们已经完成了请求，接着我们刷新。现在我们必须刷新实际的数据，这意味着如果它在系统某处被缓冲，确保它实际到达另一台计算机。好的。
- en: Sometimes if you don't do backslash N when you do print F or the N down sometimes
    the characters。 won't show up until you get that N down。 This is what the flush
    is all about。 It says look make sure the data is sent because otherwise the web
    server will have no idea。 when to respond or not。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果你在做 `printf` 或者 `N` 时没有加反斜杠 N，有时字符不会显示出来，直到你加上那个 N。这就是刷新所做的事情。它说：“看，确保数据已经发送出去，否则
    Web 服务器将不知道何时响应。”
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_14.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_14.png)'
- en: Okay。 Let's do this example again。 Yeah。 Davis。 I'll unplug these。 No the flush
    doesn't check anything it just actually says oh if I've got some buffer data。
    I haven't sent yet make sure it goes out。 That's really what it does。 It just
    says I could buffer it and keep it to myself。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们再次做这个例子。是的，Davis。我会拔掉这些。不是，刷新并不会检查任何东西，它只是实际上说：“哦，如果我有一些缓冲数据，还没发送，确保它发出去。”这才是它的作用。它只是说我可以缓冲它，并保留它给自己。
- en: I'm going to collect it all and send it all at once。 It says look now I want
    you to send it。 Definitely send it now。 That's really sick。 Yeah。 You could have
    flushed earlier。 Sure。 It doesn't really matter。 The member of the web server
    is expecting all of the data。 It won't do anything until it gets all of it。 Good
    question。 Yeah。 Good question。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我要收集所有数据，一次性发送出去。它说，看，现在我想让你发送它。现在一定要发送。太酷了，是的。你本来可以早点刷新，没错，实际上没关系。Web 服务器的成员会期待所有数据，它不会做任何事情，直到接收到所有数据。好问题，是的，好问题。
- en: Why do you need to flush？ It just turns out that there might be a situation
    where without a just the backslash N might not。 actually do the push like actually
    might not say I've got enough data to send and who。 knows but the flush definitely
    says look I'm ready to send the data make sure it goes。 all that goes from this
    point forward。 That's how it works。 That's what？
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要刷新？事实证明，可能会有一种情况，如果没有刷新，单纯的反斜杠 N 可能不会起作用。实际上可能不会说“我有足够的数据可以发送”，谁知道呢，但刷新肯定会说：“看，我准备好发送数据了，确保它发送出去。”从这一点开始，所有内容都会被发送出去。就是这么运作的。这是什么？
- en: It's a safeguard in that sense。 We could try without it and see the words but
    the odds are it might work。 New lines normally send a flush but you just never
    know in this case。 Okay。 You were going to get an O。 Is that a new word？ Yeah。
    Let me show you。 If we do telnet google。com 80。 And then we say get。 We need the
    path name。 So that's the actual path name。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，这是一个安全保障。我们可以试着不使用它，看看会不会有问题，但也许它能工作。新行通常会发送一个刷新，但你永远无法预知，这种情况可能会发生。好的，你会得到一个
    O。那是一个新词吗？是的，让我展示给你看。如果我们做 `telnet google.com 80`，然后我们说 `get`，我们需要路径名。那就是实际的路径名。
- en: I'll show it to you again and you can look at it in the code but I'll show you
    it again。 And then we say we are going to tell it what one slash one point I guess
    one point O in。 this case for our example。 And then we send a return then we say
    host and in this case www。google。com and then you。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我会再次展示给你看，你可以在代码中查看，但我会再展示一次。然后我们说我们要告诉它一个斜杠一，我猜是 1.0，在这个例子中就是这样。然后我们发送一个回车，接着说主机，在这个例子中是
    www.google.com，然后是你。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_16.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_16.png)'
- en: hit a new line and then it gets all out there。 So that is the three things we
    need to send and that's exactly what we're sending in our。 program。 Let's take
    a look。 We're saying get right here。 We're saying。 Every time I connect to my
    this tablet doesn't seem to work when I connect to when I try to。 go back and
    forth between programs。 Don't exactly know why。 But there it goes。 Okay。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点击换行，然后它就会把所有内容输出。那就是我们需要发送的三件事，这也是我们在程序中发送的内容。让我们来看一下。我们在这里说get。我们在说。每次我连接到我的这个平板电脑时，似乎在我尝试在程序之间来回切换时它不起作用。不太知道为什么。但是它还是开始了。好了。
- en: So we do the get and then we do the path which in this case was slash。 There
    was no path for Google and we didn't want the original index dot HTML the original。
    like slash path and then we say oh we're doing HTTP 1。0 new line。 The next line
    we tell it what host we're on。 This is the Google。com www。google。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们先执行get，然后执行路径，在这种情况下是斜杠。Google没有路径，我们也不想使用原始的index dot HTML。原始的路径是斜杠，然后我们说哦，我们正在使用HTTP
    1.0，换行。接下来的那一行我们告诉它我们所在的主机。这是Google.com，www.google。
- en: com and then we send a couple new lines。 The order does matter。 Yeah。 It expects
    it in exactly this order。 Why would you want the host to second？ I don't know。
    That's the way they designed the protocol。 I mean you're already connected to
    Google。com。 You already know you're connected there but then it just says hey
    which particular host。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: com，然后我们发送几个换行。顺序是重要的。是的，它确实按这个顺序来期待。为什么你想要主机放第二位？我不知道。这是他们设计协议的方式。我的意思是，你已经连接到Google.com了。你已经知道你连接到那里，但它仍然会说嘿，哪个特定的主机。
- en: of it might be that the website you're connected to has multiple IP addresses
    but different。 hosts on that IP address。 But。 Yeah like max。 Yeah。 It's something
    else dot Google dot com docs dot Google。 It might be a different one too。 It might
    be that。 Yeah。 So is the double again。 What is tell that part of double again？
    No。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是因为你连接的网站有多个IP地址，但在该IP地址上有不同的主机。但是。是的，比如max。是的。它可能是别的，比如google.com docs.google。也可能是另一个。也有可能是这样。是的。那么这个双重操作呢？告诉那个部分的双重操作？不。
- en: Good question。 Tell that is just a way to connect via the terminal。 That's all
    that is。 W get is the program that's doing this via a network。 We're writing it。
    You'll see how the actual word but we're writing the program W get which asks
    request the website。 gets it， downloads it， saves it to a file。 That's what W
    get does。 Anybody else？ Okay。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。告诉它只是通过终端连接的一种方式。仅此而已。W get是通过网络执行这个操作的程序。我们正在写它。你会看到实际的单词，但我们正在写程序W get，它请求网站，获取它，下载它，保存到文件。这就是W
    get的作用。还有其他人吗？好的。
- en: So that's all the issue request function is going to do。 It basically says hey
    get the request。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是请求函数要做的所有事情。它基本上就是在说嘿，获取请求。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_18.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_18.png)'
- en: And then we need to do what？ We need to skip all these headers。 Skipping the
    headers is relatively straightforward。 You read a bunch of lines until you get
    an empty line。 Okay so there's a whole bunch of the first thing that comes back
    from the web server is。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要做什么？我们需要跳过所有这些头部信息。跳过头部信息相对简单。你读取一堆行，直到遇到空行。好，来自网页服务器的第一部分内容是。
- en: all this header information。 And the way it's defined is header， header， header，
    header， blank line。 the rest is data。 That's all it is。 In this case we don't
    care what those headers are。 We could print them out if we wanted to or we could
    look at them or whatever but for our。 kids we don't care。 So all we're doing is
    doing a whole bunch of get lines and when until the line is empty。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些头部信息。它的定义方式是头部，头部，头部，头部，空行。剩下的就是数据。就是这么简单。在这种情况下，我们不关心这些头部信息是什么。如果我们愿意，可以将它们打印出来，或者查看它们，但对我们来说没关系。所以我们所做的就是执行一堆get操作，直到行为空为止。
- en: we're just going to keep reading them。 Now some servers aren't nice and they
    just send new lines because some people who write。 these things don't realize
    that you also need the backslash R。 We will also if we just get a line that has
    a backslash R on it we will also figure that。 it's just a new line。 It's just
    kind of a hack in that case。 Just to see what's the most question。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是继续读取它们。现在有些服务器不太友好，它们只发送换行，因为有些编写这些程序的人没有意识到你还需要反斜杠R。如果我们只获取一行，其中有反斜杠R，我们也会理解它。那只是一个hack，只是为了看看最常见的问题是什么。
- en: Why are we doing the do with the wild conditions that are just like a straight
    line of the， wild？
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要用带有通配符条件的do，就像一条直线一样，通配符？
- en: Why are we doing it do wild？ I think it probably saves a line of code。 I mean
    you would have to set the， you'd have to basically set the line up to be not empty。
    and then you'd have to set it up to some other way and say it in some default
    value and then。 do wild and then get it。 I mean you could do it short but in this
    case that just saves the line or two of code。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这么做呢？我想这可能是为了节省一行代码。我的意思是，你必须设置它，基本上得设置这一行使其不为空，然后还得以某种其他方式设置它，给它一个默认值，然后……做一个wild操作，再去获取它。我的意思是，你可以把它做得更简短，但在这种情况下，这样做只是节省了几行代码。
- en: So what was the thing with that？ The most interesting thing was that a little
    language but there are other people who are。 familiar with the get that we should
    know？ Yeah so this is a good question。 So why get？
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这件事是什么呢？最有趣的部分是那个小语言，但也有其他人熟悉get，我们应该了解吗？是的，这是个好问题。那么，为什么使用get呢？
- en: Well get is one of the ways you can request information from a web server。 You
    can also do a post which means I'm sending data to the web server like I have
    a file。 I want to send or I name or something else。 You can also do。 there's another
    one that you're going to do for next assignment and， I'm forgetting what it is。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，get是你可以用来从Web服务器请求信息的一种方式。你也可以使用post，这意味着我正在向Web服务器发送数据，比如我有一个文件，我想发送，或者我有一个名字或其他什么。你还可以使用……有另一个方法是你将在下一个作业中使用的，我忘记是什么了。
- en: There's more of them too but it's just part of the language of HTTP。 That's
    all it is。 It's just the HTTP protocol。 One of the things you do is you use get
    or you use post or you use 77。 Chase。 So what happens if you just do /r？ If you
    just do /r and not /n the web server might get confused。 I mean it just might
    go are you done with the line yet？ I don't know。 You know that's why you need。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多这样的情况，但这只是HTTP语言的一部分。就这么简单。它就是HTTP协议。你做的其中一件事就是使用get，或者使用post，或者使用77。追踪。那么如果你只用/r呢？如果你只用/r而不使用/n，Web服务器可能会搞混。我是说，它可能会问你“你这一行已经结束了吗？”。我不知道。你知道，这就是为什么你需要。
- en: The protocol says you have to have both so we send both。 That's the way it works。
    And again this is why when computers talk to each other they need to know exactly
    the。 right information。 This is why we hammer this into you in 106A， in B， in
    107， whatever。 It has to be exactly the same output and it's not just because
    we're being jerks about it。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 协议要求你必须同时有两者，所以我们发送了这两者。这就是它的工作方式。再次强调，这也是为什么当计算机相互通信时，它们需要知道确切的……正确的信息。这就是为什么我们在106A、B、107等课程中一再强调这一点。它的输出必须完全一致，这不仅仅是因为我们对它挑剔。
- en: It's so that computers can。 Because our autograders are computers。 They're trying
    to talk too but you will see this again and again and again。 You need to be exacting
    your output。 So that's the exact thing。 I'm sorry。 What exactly does the header
    remain in content？ The header information contains what kind of data is it sending
    back？
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了让计算机能够……因为我们的自动评分程序是计算机。它们也在试图进行通信，但你会一次又一次地看到这一点。你需要精确你的输出。所以这就是确切的要求。抱歉，头部信息到底包含什么？头部信息包含了它正在返回的是什么类型的数据？
- en: Whether or not， and we'll see this example， we'll see an example of some header
    data we。 care about later。 It's got， whether or not it's compressed。 It's got
    to hold on。 Whether or not the website can ask for the data when it's not on the
    website。 I mean。 so many times a website doesn't just really nearly give data
    to some other computer。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否，我们将看到这个例子，我们稍后会看到一些我们关心的头部数据。它是否压缩了。必须保留。无论网站是否可以在不在网站上的情况下请求数据。我的意思是，很多时候，网站并不会轻易把数据提供给其他计算机。
- en: through certain methods。 In this case the header could tell you。 yeah it's okay
    or maybe we don't want to do that。 Whether it's cached or not。 I mean there's
    lots of different headers。 You can just look up HTTP headers and see the hundreds
    of them that it could be。 Yeah， header it's one line at a time。 One header another
    header another header another。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过某些方法。在这种情况下，头部可以告诉你，嗯，可以，或者也许我们不想这么做。无论它是否被缓存。我的意思是，有很多不同的头部。你可以查找HTTP头部，看看有多少种。是的，头部是一行一行的。一个头部，一个头部，再一个头部，又一个头部。
- en: And then the last one is a blank line。 And then we're into data。 That's just
    a protocol。 Pretty simple。 All things considered。 A whole bunch of headers， new
    line data。 That's all there is to it。 Okay。 All right。 So that's that。 Let's see
    as we go to the next one here。 There we go。 Ooh， that's not what I wanted to do。
    Hold on。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后一行是一个空行。然后我们进入数据部分。这就是协议。说起来很简单。考虑到所有的因素。一堆头部，换行数据。就是这些。好了。好了。我们看一下下一个例子。那就这样。哦，这不是我想要做的。等一下。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_20.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_20.png)'
- en: There we go。 Okay。 So we are going to then look at the get file name function。
    Okay。 And by the way this is all because all like in you can look at the code
    and see what happens。 But it's basically we're just decomposing this into here。
    The get file name is just going to take the path and it's going to convert the
    path to。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们开始吧。好的。那么我们接下来要看看获取文件名的函数。好的。顺便提一下，这一切都是因为你可以查看代码并看到发生了什么。但基本上我们只是将它分解到这里。获取文件名的功能将接受路径，并将路径转换为。
- en: a file name if it's the last part of the path， the file name。 If it doesn't
    have a file name it uses index。html which is like the default file name for web。
    pages。 If you've never done any web， if you've ever done any web writing you'll
    probably have seen。 index。html which is basically the first page you get to on
    a web page。 Normally。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径的最后部分是文件名，就返回文件名。如果没有文件名，它将使用 index.html，作为网页的默认文件名。如果你从未做过网页写作，如果你做过网页写作，可能已经见过
    index.html，它基本上是你访问网页时看到的第一页。通常是这样。
- en: That's the way that works。 Okay。 So it's pretty easy to do。 It just basically
    says look if the path is empty or if you've got a slash at the end just。 return
    index。html。 Okay。 Otherwise you are going to find everything from the last slash。
    This is what the R find does and return that part of it。 That's all there is to
    it。 Okay。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理。好的。所以做起来很简单。它基本上就是说，如果路径为空或者路径末尾有斜杠，就返回 index.html。好的。否则，你会找到最后一个斜杠后的部分。这就是
    R find 的作用，返回那部分。这就是全部。好的。
- en: So just finding the actual file and the anchor。 We're about to write the file
    out。 Okay。 So what do we have to do for saving the payload？ Well we have to read
    in。 Okay。 We're going to be given a file name to save to which we're going to
    get from get file， name。 We're going to be given some stream that we are going
    to be in this case reading from。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以就是找到实际的文件和锚点。我们即将写出文件。好的。那么我们需要做什么来保存有效载荷？我们需要读取。好的。我们将会得到一个文件名，保存到其中，这个文件名将通过获取文件名来获得。我们将会得到一个流，我们将从中读取数据。
- en: That's the network basically。 Okay。 We're going to set this up and get the network
    stream that we're going to be reading from。 so we can read all the data。 Okay。
    And how are we going to do that？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流基本上是网络流。好的。我们将设置并获取我们要读取的网络流，这样我们就可以读取所有的数据。好的。那我们将如何做到这一点？
- en: We are going to basically say while we are not have not read all the data。 This
    is the wild do because we can do that in this case as it turns out for this kind。
    of stream we can do that。 And then we just read all the data。 Right。 We're going
    to read as much as we can into our buffer which is a fixed length。 Why 2014？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上我们会说，直到我们没有读取完所有数据。我们用的是 while do，因为对于这种类型的流，我们可以这样做。然后我们就读取所有数据。对。我们会尽可能多地将数据读取到我们的缓冲区，它的长度是固定的。为什么是2014？
- en: I don't know。 It's made of 2014。 It could be whatever we want。 And then we count
    up all the data and then we write it out to the buffer that we actually。 are sorry
    we write it out to the buffer and then let's see。 Sorry。 We're reading it into
    the buffer。 Sorry。 We're writing the buffer to the output the amount of data that
    we read。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道。它是2014年做的，可能是我们想要的任何东西。然后我们统计所有数据的数量，然后将其写入我们实际的缓冲区，抱歉，是写入缓冲区，然后让我们看看。抱歉。我们是将数据读取到缓冲区。抱歉。我们将缓冲区写入输出，写出我们读取的数据量。
- en: That's all there is to that。 Okay。 And then it's counted up how many bytes so
    we know how many bytes got read。 Yeah。 Right。 Yeah。 That's a good question。 Why
    do we need to get finally and function？
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部。好的。然后统计出多少字节，以便知道读取了多少字节。是的。对。这个问题很有意思。为什么我们需要获取 finally 和 function？
- en: Remember what would the finally and be if I asked for we have got stamped ready
    to use。 slash class slash CS 110 would it be class slash CS 110 that doesn't really
    make sense。 for a file name。 So we just want the last part of it。 So in this case
    we see us 110 which actually wouldn't work for ours because we would have。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果我问最终的结果是什么，假设我们已经准备好使用了。slash class slash CS 110，那会是什么？class slash CS 110
    听起来并不太合适。作为文件名。所以我们只想要它的最后部分。所以在这种情况下，我们看到的是 us 110，但实际上对于我们来说，这并不可行，因为我们会。
- en: to request CS 110 slash but if we did this would be the final just the last
    part of it。 So we got the path which we're going to request but then the final
    name is just the last part。 of the path。 It's a bit you know we're just creating
    that because that's what W get works。 Yeah so what is an I/O sock stream。 Okay。
    This is so you know how you can do see out and you can do that and you can do
    see out。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 CS 110 slash，但是如果我们这么做，那就是最后的部分。所以我们得到了路径，我们要请求的路径，但是最后的名称只是路径的最后部分。你知道的，我们只是创建这个，因为这就是
    `W get` 工作的方式。对，那什么是 I/O sock 流？好的。这是你知道的，像你可以做 `cout`，你可以那样做，你也可以做 `cout`。
- en: stuff and it works。 Well that's a stream and a stream is C plus plus is way
    of saying hey here's some relatively。 easy ways of doing input and output。 I/O
    sock stream is a class that's created to make wrap a network file descriptor into。
    a stream so that it's easy to use。 That's all I have sock。 Just a class that we're
    using to make it easy to do so that we can do things like output。right。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西，它有效。好吧，这就是流，流是 C++ 中表示“嘿，这里有一些相对简单的方法来进行输入输出”的方式。I/O sock 流是一个类，它被创建出来包装网络文件描述符成流，以便更容易使用。就这些，我有的就是
    sock。只是一个类，我们用它来简化操作，这样我们就可以做一些像输出这样的事情。对吧？
- en: We can do things like where we read in from the SS right here SS dot read right
    that's。 like you do that from a stream and so forth。 And it buffers it all for
    you and you don't need to worry about having a while loop that。 does you know
    certain only certain amount of data and so it does all that for you。 David you
    have a question。 [inaudible]， SS dot G count is the amount of data you get you
    got back I believe。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些事情，比如从 SS 读取数据，像这样，`SS.read`。这就像从流中读取数据等等。而且它会为你做所有的缓冲，你不需要担心要有一个 while
    循环去处理，像是只处理一定量的数据，它会为你处理所有这些。David，你有问题吗？[听不清]，`SS.Gcount` 是你获得的返回数据量，我相信。
- en: I believe that's what it is。 So it basically says how much we just read well
    how much did we just read right and then。 it just keeps that updated from the
    read。 All right so these are all kind of helper functions right now that we're
    dealing with。 So let's see was that the only value that was it actually that's
    the we've actually。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为就是这个。所以它基本上会显示我们刚才读了多少，嗯，我们刚才到底读了多少对吧，然后它就会从读取中不断更新这些数据。好了，现在我们正在处理的是一些帮助函数。所以让我们看看，那个值是不是唯一的，实际上就是它，我们实际上有的。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_22.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_22.png)'
- en: done everything and it's a no we didn't miss anything we actually had all of
    it in here。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 做好了所有的事情，没错，我们没有漏掉任何东西，实际上我们都做到了。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_24.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_24.png)'
- en: because we needed to first issue the request we saw how to do here the get request。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要先发出请求，我们已经看到如何在这里发出 `get` 请求。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_26.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_26.png)'
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_27.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_27.png)'
- en: And then we skip all the headers read all those headers and then the new line
    and then。 we save the payload which is everything after the headers。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们跳过所有的头部，读取所有的头部，然后是新的一行，然后。我们保存有效负载，也就是所有头部之后的内容。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_29.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_29.png)'
- en: Did we not have this did I skip the skip headers function。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是不是没有这个？我是不是跳过了跳过头部的功能？
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_31.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_31.png)'
- en: No there it is there it is yeah that's it okay so just read all that。 All right
    that's how that's all we have to do in this case。 And that's it let's check let's
    check it out and see that it works。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不，它就在那儿，没错，就是这样，好的，所以就读取了所有内容。好了，这就是我们在这种情况下要做的全部。就是这样，让我们检查一下，看看它是否工作。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_33.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_33.png)'
- en: Okay let's see see us one ten spring live lecture that out of the way。 Okay
    and then if we do networking and we do wwebget and let's try Google。com right。
    well it says that's two hundred nineteen bytes which means something went wrong
    there。 Let's look at it probably means that it didn't have the right。 Let's see
    them index。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看看这个，看看我们的一十春季直播讲座，先把这个弄清楚。好了，然后如果我们做网络连接，做 `wwebget`，我们试一下 Google.com。对吧？它说是两百一十九个字节，这意味着那里出了点问题。让我们看看，可能意味着它没有正确的东西。看看它们的索引。
- en: html yeah it says it has moved to Google。com/ so we need to do slash。 and oh
    we need to do we need the wwe probably。 There we go now we've got enough bytes
    we've got 46。000 bytes so that actually works。 What was going on if we did the
    if we did without like we did wwebget just Google。com， without the wwew。 Well
    if we look at what it says it says hey that document has moved to wwew。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: html 是的，它显示它已移至 Google.com/，所以我们需要做斜杠。哦，我们还需要做的是，可能需要加上 wwew。好了，现在我们有足够的字节，得到了
    46,000 字节，所以实际上这有效。如果我们没有加 wwew 直接使用 Google.com 会发生什么呢？如果我们看一下它显示的内容，它说嘿，文档已经移至
    wwew。
- en: google。com。 So that's just that's yeah it basically there's a difference between
    Google。com and wwew。google。com， and so Google has set it up such that whenever
    you ask for Google。com it says no no no please， ask for wwew。google。com and your
    browser does it for you。 If you just type Google。com it'll go to Google。com get
    this message back and go oh I got to do。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: google.com。所以这就是它，基本上 Google.com 和 wwew.google.com 之间有区别，所以 Google 已经设置了，当你请求
    Google.com 时，它会说不不不，请求 wwew.google.com，浏览器会为你自动完成。如果你只输入 Google.com，它会转到 Google.com
    获取这个消息，然后说哦，我得做这个。
- en: another request and get the real version back。 It's all that yeah。 Question
    about the save payload function。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个请求并获取实际版本返回。这就是所有的，没错。关于保存有效载荷函数的问题。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_35.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_35.png)'
- en: Yeah let me pull it off the save payload function yes。 What was the turning
    backslash zero for the buffer？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，让我拿出保存有效载荷函数。对了，那个反斜杠零（backslash zero）是用来干什么的？
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_37.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_37.png)'
- en: What does that do？ Ah good question so in this case because we're trying to
    read the question was why is there。 a terminating backslash I guess I skipped
    right over that。 When you you're reading in this actually says hey create the
    entire buffer full of zeros。 what it does in this case so they're all already
    zero so it doesn't mean you don't。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，那个做了什么？啊，好问题，所以在这种情况下，因为我们正在尝试读取，问题是为什么有一个终止的反斜杠。我想我跳过了那部分。当你在读取时，实际上它说嘿，创建一个满是零的完整缓冲区。它在这种情况下做的是这样，所以它们已经是零了，这并不意味着你不需要。
- en: have to put one at the end when you read all the data in so it's already。 Good
    question。 Okay。 Yeah。 Would you also have to close the output？ No。 In this case
    OF stream you don't need to close those like this case。 Yeah I think actually
    I believe it gets closed when it goes out of scope because the way it， works。
    Alright。 Now let's look at how much more interesting and kind of a cool example
    that by the end。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取所有数据时，你必须在末尾加上一个。所以它已经有了。好问题。好吧。是的。你还需要关闭输出吗？不。在这种情况下，对于 OF 流，你不需要关闭它们。像这种情况，是的，我认为实际上它会在超出作用域时自动关闭，因为它的工作方式就是这样。好了，现在我们来看看更有趣且有点酷的示例，直到最后。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_39.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_39.png)'
- en: of I think you'll see that you go oh this is cool and this is how the internet
    works and。 this is how this is not really how you would necessarily create a web
    page but it's pretty。 close as it turns out。 You don't necessarily need to create
    your own web server most of the times when you put。 a page on a server it will
    get run for you by the web server which is already running。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你会看到哦，这很酷，这就是互联网的工作方式。而且，这不是你创建网页的方式，但实际上它非常接近。事实证明，你不一定需要创建自己的 web 服务器。大多数情况下，当你将页面放在服务器上时，web
    服务器会自动为你运行它。
- en: on your computer。 We're going to do a much more lower level version of this
    right now but it basically。 you can kind of see what the web server has to do
    to get your data to shoot it out to。 a some other client that requests it。 Okay。
    What we're going to do we're going to look at we're going to look at an example
    that。 which has which is kind of it's an AP it's got an API associated with it
    right basically。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计算机上。我们现在要做一个更底层的版本，但基本上，你可以看到 web 服务器需要做什么才能获取你的数据并将其传输给请求它的其他客户端。好吧，我们要做的就是，我们要看一个示例，它是一个
    API，基本上有一个与之关联的 API。
- en: an application programming interface which basically means we know what we have
    to send。 to the server and it will give us back data in some form that we can
    understand。 Okay who here has heard of JSON before JSON。 Okay almost everybody
    not quite everybody JSON is a format that's machine readable but。 also pretty
    human readable。 Okay and we'll see the actual format when we get to it but we're
    going to output our。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序接口（API），基本上就是说我们知道需要发送什么数据到服务器，它将以我们能理解的某种格式返回数据。好的，谁听说过JSON？JSON。好的，几乎每个人都听说过，虽然不是每个人。JSON是一种机器可读但也相当人类可读的格式。好的，我们到时会看到实际的格式，但我们将以这种格式输出我们的。
- en: results of what I'm going to show you in this format so that if we wanted to
    and at。 the end I'll show you a little web page I built that uses that we can
    actually get the。 data formatted such that our computer can understand it and
    do something interesting。 with it put it on the screen in an interesting way or
    use it to do some calculations or whatever。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示的结果是这个格式，这样如果我们需要，最终我会展示一个我构建的小网页，利用这个我们可以实际获取格式化的数据，以便我们的计算机可以理解并做些有趣的事情。比如把它显示在屏幕上，或者用来做一些计算，或者其他。
- en: but that's we're going to end up creating。 So what we're going to do is we're
    going to create this little program that uses a program。 called Scrabble Word
    Finder and this program you certainly can go look at it but that's。 a 106B program
    basically takes letters that you might have from a this place grab before。 mostly
    everybody word finder some other like words with friends whatever you have a number。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就是我们最终会创建的。我们要做的是创建这个小程序，它会使用一个叫做Scrabble单词查找的程序。这个程序你当然可以去查看，但它是一个106B程序，基本上是接受你可能有的字母（比如从某个地方抓取的字母）。基本上是任何单词查找程序，像是“朋友连连看”之类的，你拥有一个数字。
- en: of letters and the number of letters you have to use to make words and they're
    all scrambled。 up and this program will find all the words in a dictionary that
    are come from those letters。 Okay that's all it's going to do let me show you
    an example of this let's see Scrabble Word。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字母和你用来组成单词的字母数量，字母都是混合在一起的，这个程序会从这些字母中找到字典中所有可以组成的单词。好的，这就是它要做的。让我给你展示一个例子，看看Scrabble单词。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_41.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_41.png)'
- en: Finder Stanford okay and it will print out all the different words that you
    can make from。 the letters in Stanford okay that's what the program does okay
    and yeah whatever words are。 in the dictionary it will make okay Scrabble Word
    Finder Network okay we'll print out all。 the ones that happen to be words you
    can make from that work and that's what we're going。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 查找斯坦福单词。好的，它会打印出你可以用斯坦福字母组成的所有不同单词。好的，这就是程序做的事情。好的，任何字典中存在的单词它都会生成。好的，Scrabble单词查找网络。好的，它会打印出所有你能从中构成的单词，而这些正是我们要做的。
- en: to use so let's pretend we have a website that wants to do this well we might
    create a。 Stanford we might create a Scrabble Word Finder program that does exactly
    this it takes as。 a parameter into the program the letters and it spits out all
    the words that create from。 those letters okay so what we want to do is we want
    to do a server that uses this program。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个网站，想要实现这个功能。那么我们可能会创建一个斯坦福Scrabble单词查找程序，它正是做这个的，它接收作为参数的字母，然后输出所有由这些字母组成的单词。好的，我们要做的是创建一个使用这个程序的服务器。
- en: or does the same thing except instead of printing it out to the screen it shoots
    it off to our。 client in a form of the client can understand namely JSON format
    okay you might think okay。 let's go into the Scrabble Word Finder program wherever
    it does see out let's set up a network。 connection let's do a client or we'll
    do a little server connection and we'll have an。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者做相同的事情，除了不再输出到屏幕，而是将结果以我们客户端能理解的形式发送出去，即JSON格式。好的，你可能会想，好的，让我们进入Scrabble单词查找程序，不管它在哪里做输出，我们设置一个网络连接，做一个客户端或者我们做一个小的服务器连接，然后就有了一个。
- en: accept and all that you know why would we do that if we've already got a program
    that。 works perfectly well there was a assignment you all did where you used other
    programs and。 got the results from those programs what was that program you wrote
    subprocess right this。 let's leverage subprocess to actually get the words from
    this exact program and our server。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接受所有这些，那我们为什么要这么做呢？如果我们已经有了一个完全能正常工作的程序。你们做过一个作业，使用其他程序并从那些程序获取结果，那个程序你们写的是subprocess，对吧？现在，让我们利用subprocess来实际从这个程序中获取单词并通过我们的服务器。
- en: needs to be this tiny little thing which basically just translates request comes
    in use the Scrabble。 Word Finder get the words send them back to be client and
    a story okay there's a fair。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要是一个非常小的功能，基本上就是：请求到来时，使用Scrabble Word Finder获取单词，然后将其发送回客户端，故事就这样结束了。好的，这很公平。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_43.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_43.png)'
- en: amount of details that we're going to go through as we do this but as you see
    that that's what。 we want to do we don't want to modify the program that already
    works perfectly well if。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经历的细节数量有很多，但正如你所见，这就是我们想做的。我们不想修改已经运行得非常好的程序。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_45.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_45.png)'
- en: we can use a subprocess to do this okay alright here's what JSON looks like
    by the way this。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用子进程来完成这个任务，好的，接下来这是JSON的样子，顺便提一下。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_47.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_47.png)'
- en: is a the results of what we're going to do we're going to run this program let's
    run this。 server let's say it's on port 13133 on myth 54 and when we request myth
    54 colon 13133。 slash lexical we will take lexical and speed those letters into
    our Scrabble Word Finder。 so we need to figure this and we need to parse out the
    various you know parts of this so。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要做的事情的结果，我们将运行这个程序，启动这个服务器，假设它在端口13133上，位于myth 54，当我们请求myth 54:13133/lexical时，我们将把lexical传入Scrabble
    Word Finder，将字母传入。所以我们需要弄清楚这一点，并且需要解析出其中的各个部分。
- en: that we can get the letters from that so we're going to do that and then we're
    going。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中获取字母，所以我们将做这个，然后我们将。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_49.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_49.png)'
- en: to generate something like this we are going to say how long it took to do the
    request we。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成像这样的内容，我们需要说明处理请求花费了多长时间。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_51.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_51.png)'
- en: are going to say whether or not it was cached or not so the assignment not this
    assignment。 but the next assignment in fact the big networking assignment you're
    going to do is a web cache。 program which is actually kind of cool but caching
    in networking basically means if you've。 already done something before don't do
    it again because networking itself is relatively。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将说明它是否已被缓存。所以这不是这个作业，而是下一个作业，实际上是一个非常酷的大型网络作业，你将要做一个Web缓存程序。实际上，缓存的概念在网络中是这样的：如果你之前做过某件事，就不要再做一次，因为网络本身相对来说是。
- en: slow but in this case it's not really that it's really if the program we have
    already。 gotten a bunch of letters and we've already converted them into words
    we might as well。 save those words in case somebody requests those same letters
    again in a cache and we're。 just going to report back whether or not it was cached
    why would the client care about。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这很慢，但在这种情况下，实际上并不是这个问题，真正的原因是我们已经获得了一堆字母，并且已经将它们转换成了单词，既然如此，我们不妨将这些单词保存下来，以防有人再次请求相同的字母，放到缓存里，然后我们只需要报告它是否被缓存，客户端为什么会在乎呢？
- en: this who knows maybe the client cares about it but we're going to tell them
    whether or。 not it was cached and then it's just and then it's just going to be
    an array of all of the。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道呢，或许客户端在乎这个，但是我们将告诉他们它是否被缓存，然后它就会变成一个包含所有内容的数组。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_53.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_53.png)'
- en: words okay so this is actually a little it's basically a map time and then it
    gives the。 time comma cashed false and then possibilities and it's an array this
    is what JSON looks like。 notice it's relatively readable once you understand that
    oh this is what a map looks like in。 JSON you go oh now I can read it that's pretty
    straightforward and your your JavaScript program。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以这其实是一个小小的内容，它基本上是一个映射，时间字段后面接时间，逗号后面是缓存状态false，然后是可能性，它是一个数组，这就是JSON的样子。注意，一旦你明白了哦，这就是JSON中的映射，你就能读懂它了，这非常直观，而且你的JavaScript程序。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_55.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_55.png)'
- en: can read that very easily as it turns out which is what the you're going to
    probably be requesting。 the server the client data from okay all right so that's
    what we're going to end up doing。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明可以非常轻松地读取这个内容，这也是你可能会请求的内容。服务器获取客户端数据，好的，明白了，所以这就是我们最终要做的事情。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_57.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_57.png)'
- en: here by doing this let's see what we how we're going to actually do this we're
    going to leverage。 as I said we're going to leverage sub process to do this and
    it's just going to use it get。 the output and do that do we need to send any data
    into scrap a word finder no which we're。 doing it via the command line so we don't
    actually need to actually say what the letters。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，让我们看看我们到底是如何做到这一点的。正如我所说，我们将利用子进程来完成这个任务，它只会使用它来获取输出并执行。我们需要向“scrap a
    word finder”发送任何数据吗？不，我们通过命令行来进行操作，因此实际上不需要指定字母。
- en: are we could have set the program to do that but we just do a Bible command
    line so it's。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以设置程序来自动完成，但我们只是通过命令行来做这件事。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_59.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_59.png)'
- en: going to be fairly straightforward okay so here's the main function what's the
    main function。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将会是相当直接的，所以这是主函数，主函数是做什么的呢？
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_61.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_61.png)'
- en: do for our server it should look relatively similar to other servers let's see
    let me find。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器应该和其他服务器相似，让我们看看，找找看。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_63.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_63.png)'
- en: this on here so you guys can copy on it is on page three maybe no some page
    eight oh that's。 right it's at the end of the program right on page eight sorry
    on page eight is where the。 actual main is for this okay so what we're doing here
    is we are setting up the server kind of。 like what we've done in the in the past
    okay we are going to create the create that's right。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分你们可以在第三页复制，可能不在第三页，在第八页。哦对了，它在程序的最后部分，没错，就是第八页，抱歉，实际的主函数就在第八页。所以，我们现在在做的事情是设置服务器，就像我们以前做的那样。我们将创建...
    对的，就是这个。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_65.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_65.png)'
- en: and zoomed in here we're going to create the server socket okay we are first
    going to extract。 the port that's actually a relatively easy for easy thing we're
    basically just going to。 get that from the command line all right and we're going
    to get the port number because。 what you can do is you are going when you run
    this you can say what port you want to。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 放大这里，我们将创建服务器套接字。好的，我们首先提取端口，这实际上是一个相对简单的任务。我们基本上会从命令行获取这个端口号。你可以在运行时指定你想使用的端口。
- en: run it on and then we are going to if you don't it's going to have a default
    and then we are。 going to create the server socket okay and then we're going to
    say what we're listening。 on big deal we're going to set up this thing called
    a thread pool remember the reason we're。 doing this is so that we can accept connections
    very quickly up to 16 connections very quickly。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它时，如果没有指定，它将会使用默认值，然后我们将创建服务器套接字。好的，然后我们将指定监听的端口。没什么大不了的，我们将设置一个叫做线程池的东西。记住，我们这样做的原因是为了能非常快速地接受最多16个连接。
- en: and shoot off threads based on those connections okay so it's going to be a
    way to do you will。 build thread pool for the next assignment okay then we're
    going to have a cache and in this。 case the cache is going to be those letters
    mapped to the vector of the strings of the。 result what do you think we're going
    to have to do to the strings to make sure that if we。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据这些连接启动线程。好的，所以你们会为下一个任务构建一个线程池。然后我们将有一个缓存，在这种情况下，缓存将是那些字母映射到结果字符串向量的内容。你认为我们应该对这些字符串做什么，以确保如果我们...
- en: get a B C D and then we get D C B A aren't those going to create the exact same
    set of。 words what should we do to this to the word we get in before putting it
    on a map yeah sort。 it just put it in sort it's all going to do the same but we
    will do that okay then we。 are going to need a mutex because we're dealing with
    threads we're going to need a mutex for。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 获取A B C D，然后我们得到D C B A，难道这些不会创建完全相同的单词集合吗？我们应该对得到的单词做些什么，才能在将它们放入映射之前进行处理？对它们进行排序。只是将它们排序，效果是一样的，但我们还是会这么做。好了，我们还需要一个互斥量，因为我们在处理线程时，需要一个互斥量。
- en: the cache lock here or for the cache basically because if we're reading from
    the cache and。 anybody else is trying to write to it at the exact time that could
    be bad news we might。 get the wrong data it might corrupt something the writing
    might get something might go on。 it probably not going to actually corrupt anything
    but you might get the wrong data or。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是缓存锁，基本上是因为如果我们正在从缓存读取，而其他人恰好在此时写入缓存，这可能会带来麻烦，我们可能会得到错误的数据，或者可能会导致某些内容损坏，写入可能会出现问题。虽然可能不会真的损坏任何东西，但你可能会得到错误的数据。
- en: it may actually end up being in a situation where the state is not known so
    we're going。 to lock anytime we read or write to that cache okay so this is kind
    of the demonstration。 of that okay then we're going to have our regular old while
    loop for our server that's。 going to accept connections okay and we're going to
    do things a little bit differently。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能最终会进入一个状态未知的情况，因此每当我们读取或写入缓存时，都需要加锁。所以这是一个演示。接下来，我们将有一个常规的while循环，用于我们的服务器来接受连接。我们将以不同的方式处理这些事情。
- en: here this is the part where I said don't pay any attention let's just look at
    it and go。 wow we'll learn about that next week we're going to set up a this thing
    called a struct。 socket address underscore in for the actual IP address the reason
    we're going to do this。 is because whenever we get a client we want to actually
    know what IP address it came from。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这是我之前说过的不要过多关注的部分，让我们看一下，先大致了解下，我们下周会学习这个内容。我们将设置一个叫做struct socket address
    _in的东西来获取实际的IP地址。这样做的原因是每当我们得到一个客户端时，我们希望能够知道它是从哪个IP地址连接的。
- en: why might we care about that we want to log it maybe we're maybe we're a program
    who cares。 about Scrabble words the most in the world what I like what regions
    of the world we might。 log that or whatever trust me every website you go to logs
    your data logs your IP address。 logs what you asked for look this is how people
    get collect your data always log in details。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们可能关心这个？我们可能想记录它，或许我们是一个非常关注Scrabble单词的程序，可能会记录它或者其他什么内容。相信我，每一个你访问的网站都会记录你的数据，记录你的IP地址，记录你请求的内容。看，这就是人们如何收集你的数据，始终记录登录细节。
- en: about you in this case we're going to care about what the IP address is okay
    and the。 way we're going to do this is this stuff which I'm not going to go through
    the details now。 but we will see it next week and it's it's basically used to
    get the client IP address。 in this case okay and we are going to once we get it
    by doing all this fancy searching。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们关心的是IP地址是什么。我们将通过这段代码来实现这一点，虽然我现在不会详细讲解，但我们下周会看到，这段代码基本上用于获取客户端的IP地址。
- en: through the the response we're going to say that where we got it from and we
    have to actually。 print it out correctly and so forth but it's basically going
    to say hey received a connection。 request from IP address that's what we care
    about okay then we are going to schedule the。 thread so that we can then go back
    quickly and do another accept and we're going to do。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过响应，我们将说明我们从哪里获取数据，并且我们需要正确地打印出来等等，但基本上会说嘿，接收到来自IP地址的连接请求，这就是我们关心的内容，好吗？然后我们将调度线程，以便能够快速返回并进行另一次接收。
- en: that by by calling our published Scrabble words function which itself will call
    self。 process and we're going to do that we need to pass in the client we're going
    to the file。 script for that pass in the cache by references it turns out and
    passion the cash lock also。 by reference that's what we're going to do okay that's
    the big idea of our program and。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过这些复杂的搜索找到IP地址，我们将通过调用我们已发布的Scrabble单词函数来实现，而该函数本身会调用自处理（self.process）。我们需要做的是传入客户端，我们将为此传入文件脚本，并通过引用传入缓存，缓存锁也通过引用传入。这就是我们要做的，好的，这是我们程序的核心思想。
- en: then everything happens in published Scrabble words where everything starts
    to happen there。 questions on this one no fair asking about the details we'll
    do next week okay all right。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后一切都会在已发布的Scrabble单词中发生，所有的操作都从那里开始。对此有问题吗？别问细节，我们下周会讲解。好的，没问题。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_67.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_67.png)'
- en: so like I said all of this address size I net and top we'll talk about that
    next week it's。 kind of cool okay published Scrabble words is going to rely on
    sub process we're going。 to eventually create JSON output and then we're going
    to see how that works so let's。 take a look and this next function is pretty detailed
    we'll do it line by line it's called。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我之前说的，这一切关于地址大小、I net 和 Top 的内容，我们下周会讨论。这挺酷的，好吗？发布的 Scrabble 单词将依赖于子进程，我们最终将创建
    JSON 输出，然后我们将看到它是如何工作的。所以让我们来看看，接下来的这个函数非常详细，我们会逐行分析，它的名字是。
- en: published Scrabble words and it is on what page seven so I'm very good for it
    okay all。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 发布的 Scrabble 单词，它在第七页，所以我很熟悉这个内容，好了。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_69.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_69.png)'
- en: right so here's what it is you've got it on your thing I'll try to hopefully
    you can。 kind of see it from the back there so here's what we're going to do in
    published Scrabble。 words okay we're going to make it so that we can write to
    the client pretty easily or read。 and write as it turns out from the client pretty
    easily okay we're going to call a function。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，下面是它的内容，你已经看到了，我希望你能从后面看到它。下面是我们在发布 Scrabble 单词时要做的事情。我们将使它变得简单，让我们可以轻松地写入客户端，或者像我们发现的那样，从客户端轻松地读取和写入。我们将调用一个函数。
- en: called get letters which is going to request which is going to take the request
    we've got。 and figure out what the after the slash for the web page that we're
    looking for and use。 those as the letters okay then as we said we're going to
    sort them because we don't care。 what the order is but it's going to make a difference
    for our cash okay we're then going。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做 get letters，这个函数会请求我们获得的请求，找出网页 URL 中斜杠后的部分，并把它们作为字母。然后，正如我们所说，我们将对它们进行排序，因为我们不在乎顺序，但这对我们的缓存来说很重要。接下来我们会。
- en: to time it so why do we care about timing it again this is like our own little
    benefit。 of hey how long do I take to do this maybe it's going to take too long
    or whatever guess。 what the cash one should take much fewer much less time than
    the actually run on the program。 let's hope that that's the case we'll see if
    that's the case as we go okay we're going。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 定时它，那么我们为什么要关心定时呢？这就像是我们的小小好处，嘿，我花了多长时间来做这个，也许它会花太长时间，或者什么的。猜猜看，缓存一次应该比程序实际运行花费的时间要少得多。希望是这样的情况，随着我们的进展，我们将看看是否真的如此，好吗，我们继续。
- en: to just get the time to start and that's how you do that this is kind of what
    I showed。 you last week when we did the time server client similar sort of idea
    here now we're about。 to update the cash or rather we're going to see if our letters
    are in the cash so first。 we lock it then we do a fine on our map okay and then
    we immediately unlock don't lock for。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 获取开始时间，这就是你怎么做的。这是我上周展示给你看的，当时我们做了时间服务器客户端类似的事情。现在我们准备更新缓存，或者更准确地说，我们将检查字母是否在缓存中。首先，我们锁住它，然后在映射上进行查找，然后立刻解锁，不要锁得太长时间。
- en: longer than you have to okay we could have just done a lock guard and for the
    rest of。 the function just been guarding that that variable or the the map but
    we don't want to。 because we want other threats to also be able to read to it
    and other threats to be able。 to update it so don't lock for longer than you have
    to that is a definite style issue。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不要锁得比必要的时间还长。我们本来可以只做一个锁守卫，对函数的其余部分仅保护那个变量或者映射，但是我们不想这么做，因为我们希望其他线程也能读取它，并且其他线程也能更新它。所以不要锁得比必须的时间还长，这是一个明确的风格问题。
- en: that also can just affect your program one time so be very careful about doing
    that okay。 if we were basically coming up with a little Boolean that says whether
    or not we found。 the cash or not or found the string in the cash and we're going
    to create a vector that。 we're going to put those words in if we are cached we're
    done right we basically say great。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这也只会影响你的程序一次，所以要非常小心这样做。我们基本上是创建了一个布尔值，表示我们是否找到了缓存，或者是否在缓存中找到了字符串，然后我们将创建一个向量，把那些单词放进去。如果缓存命中，我们就完成了，对吧？我们基本上说“太好了”。
- en: the words that in the vector are the words from our cache and the story okay
    the way。 find works is it gives you back a pair the second part of the pair of
    the iterator rather。 gives you back an iterator and the second the second thing
    in the iterator is the actual。 vector in that case the value from the map okay
    so it's going to do that otherwise we。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的单词来自我们的缓存，故事好的方式是，find 函数的工作原理是，它给你返回一对，返回对中的第二个部分，迭代器会返回一个迭代器，而迭代器中的第二项是实际的向量，在这种情况下是映射中的值。好的，所以它会这样做，否则我们。
- en: didn't find it in the cash well now we need to actually go and use our subprocess
    so we're。 going to call our subprocess and we're going to set up our subprocess
    command how are。 we going to do that grab a word finders the name of the program
    letters dot c string。 that's the letters we just obtained that's the second parameter
    the first parameter to。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有在缓存中找到，那么我们现在需要使用子进程。所以我们将调用我们的子进程，并且我们将设置子进程命令，我们怎么做呢？抓取一个单词查找器是程序的名称，letters.dot
    c string。这是我们刚刚获取的字母，作为第二个参数，第一个参数是。
- en: our through our program and then no that should look pretty familiar from your
    shift Stanford。 shell okay then we're going to call a function called poll formable
    words and we're going。 to pass in a reference to the vector and we're going to
    pass in the file descriptor we get。 back to subprocess this is basically doing
    saying hey we're going to get all the words。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的程序，然后没有什么特别的应该是你从斯坦福的变化中看到的内容。shell 好的，那么我们将调用一个名为 `poll formable words`
    的函数，我们将传入向量的引用，并且我们将传入从子进程获取到的文件描述符。这基本上是在说，我们要获取所有的单词。
- en: out of subprocess throw them into that vector one line at a time fairly straightforward。
    and don't forget we have to wait till we're done right if you're doing multi processing。
    you have to do wait PID this is this example ties in everything we've done so
    far as it。 turns out okay and then once we get the result back we know we weren't
    cached before we better。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从子进程中获取它们，一次一行放入向量中，十分简单。别忘了，我们必须等到完成，对吧？如果你在做多进程，你必须做等待 PID。这个例子结合了我们到目前为止所做的一切，结果证明是这样的。然后一旦我们得到结果，我们知道之前没有缓存过，我们最好。
- en: put our vector into the cache so we lock our we lock our variable our map we
    lock around。 our map I should say via the cache lock then we update the cache
    with the vector based on。 the key of the letters that have another sorted now
    and that's it we can use a lock guard because。 when this goes out of scope the
    lock comes on really it gets unlocked even we were saying。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 把我们的向量放入缓存中，所以我们锁定我们的变量，锁定我们的映射，我们应该通过缓存锁来锁定映射，然后我们根据字母的键更新缓存，字母已经排序好了。就这样，我们可以使用锁保护，因为当这个作用域结束时，锁会自动释放，即使我们之前是这样说的。
- en: again we purposely previously said to do what oh right all right all right we
    shouldn't。 call subprocess with you can call let's see you can call in this oh
    good question that's。 a question the question is wait we shouldn't we shouldn't
    mix threading and multi processing。 in this case it's actually going to be okay
    because subprocesses we were very careful in。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们之前故意说做什么哦，没错，没错，没错，我们不应该调用子进程，你可以调用，看看，你可以在这个情况下调用，哦，好的问题。问题是等等，我们不应该，我们不应该混合线程和多进程。在这种情况下，它实际上是可以的，因为子进程我们非常小心。
- en: subprocess only to allow the it's still in the same threat in that case okay
    I mean the。 thread now you do have you're right you do have multiple you have
    multiple processes in。 that but we are waiting for it properly and we are doing
    that okay so yeah in this case。 it's all right yeah I think let me look into a
    little more detail and yeah that's a good。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程仅允许它仍在同一个线程中，这种情况下是可以的。好的，我的意思是线程，现在你确实有多个线程，你有多个进程。但是我们在正确等待它，并且我们正在这样做。好的，所以在这种情况下没问题，是的，我想让我看一下更多的细节，是的，这是个不错的。
- en: good point though because we always said don't mix don't mix those in that way
    it does turn。 on it works but it's good question so I'll look into it yeah good
    question yes of course。 we're gonna go down this path now oh yeah why should we
    not usually mix if you are if。 you are in a thread and you're calling multi you're
    calling it you're you're forking off。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这是个好问题，因为我们总是说不要混合，不能以这种方式混合它，虽然它确实能工作，但这是个好问题。所以我会进一步调查一下，是的，好问题，当然，我们现在要沿着这条路走。哦，是的，为什么我们通常不应该混合呢，如果你在一个线程中，并且你调用多线程，你在调用它，你在进行分叉。
- en: a process right well then the thread is now kind of outside your process and
    like it's。 in its own like that the thread has to coordinate now wait wait now
    I've got this other process。 going on but I'm process and I've got thread so it's
    not necessarily a good thing which。 is wild to look up why this actually works
    but the in that sense you don't want to you've。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个进程中，对吧，那么线程现在就算是在进程之外了，就像是它独立出来一样。线程必须协调，现在要等，等一下，我有另一个进程在运行，但我在进程中，线程也在运行，这就不一定是好事了。真是让人疑惑，为什么这样就能工作，但从这个角度看，你并不想这样做。
- en: got a thread manager and a process manager and they don't always work well together
    okay。 in a process you should be able to call threads but we're doing the opposite
    here so I will。 look this up and see why yeah I'm not but otherwise you don't
    it's basically because you've got。 two scheduling things going on that don't like
    to necessarily won't necessarily work well。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个线程管理器和一个进程管理器，它们并不总是能够很好地协同工作。一个进程中你应该能够调用线程，但我们这里做的是相反的，所以我会查一下原因，看看为什么。嗯，我不是这样做的，但总的来说，问题在于你有两个调度机制，它们不一定会很好地协同工作。
- en: together good good question this is a good point for the background right so
    the question。 is go over again why we use the locking here and not the lock guard
    but we're able to use。 the lock guard down here and you're absolutely correct
    your comment was up here we need to。 unlock here before there's any scoping going
    out anything going out of scope nothing here。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一起讨论这个问题，非常好的问题，这是一个很好的背景知识点。所以问题是，再讲一遍，为什么我们在这里使用锁而不是锁守卫？但我们可以在下面使用锁守卫，你完全正确，你的评论是在这里，我们需要在任何作用域结束前解锁。
- en: is going out of scope so if we try to use a lock guard it wouldn't actually
    go out there。 with the lock wouldn't release until somewhere down here where we're
    out of a scope and that's。 not what we want but here because the last thing we're
    about to do is update the cache。 and then to definitely go right out of scope
    we can use the lock guard exactly right yeah。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用锁守卫，它会在作用域外面不能正确释放锁，直到作用域结束后锁才会释放，而这不是我们想要的。但在这里，因为我们接下来的操作是更新缓存，然后要确保它肯定会正确退出作用域，所以我们可以使用锁守卫，没错。
- en: you don't have to you could do lock here unlock after the catch perfectly fine
    you're。 not going to mark that nope it's not a style but issue no it's just add
    to style it's a。 style but it's not a bad thing to do with the lock unlock perfectly
    fine chase you had a。 question no okay I'm gonna hand over here good questions
    on here very good questions but。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必这样做，你可以在 `catch` 后面加上 `lock` 和 `unlock`，这样也完全可以，你并不会因此标记出问题，不，这不是风格问题，只是加了一个风格，它是风格上的选择，但并不是什么不好的做法，`lock`
    和 `unlock` 完全没问题。追问一下，你有问题吗？没有？好，我就交给你了。这里有一些非常好的问题。
- en: that's that's the meat of this here after we get the words out well that's how
    long it。 took so then we get the end time okay then we do a little a couple more
    commands to or。 functions to actually figure out what the duration of the time
    was in seconds this is。 using the another time if time valve struck and in this
    case just it just uses the seconds。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关键部分了，获取到单词之后，就是花了多久的时间。然后我们获取结束时间，好，然后我们执行几个命令或者函数来计算持续时间，单位是秒。这是通过另一个时间函数来计算的，在这种情况下它只是用了秒数。
- en: plus the millisecond or microseconds divided by a million which gives you the
    seconds and。 that's how that works out and then we are going to set up the payload
    now the payload。 in this case is we're gonna basically construct the payload from
    the words from whether or。 not we've been cast or not and from the time and then
    we're passing in this string we want。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 再加上毫秒或者微秒除以一百万，这样就得到了秒数。就是这样运作的。然后我们将设置负载，在这种情况下，我们基本上是根据是否已经处理完成，以及时间来构造负载，然后我们传入这个字符串，我们需要的。
- en: to string that we're gonna send back to the client we have to construct that
    doesn't。 kind of come for free we have to kind of create a JSON string out of
    it okay once we construct。 that payload we then send it using another function
    called send response okay all right。 the payload is a string that we're gonna
    send back to the client and that's JSON you'll。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要发送回客户端的字符串必须自己构造，而不是自动生成的。我们得从中创建一个 JSON 字符串。好，一旦构造好这个负载，我们就会使用一个名为 `send
    response` 的函数发送它。好的，负载是我们要发送回客户端的字符串，它是一个 JSON 格式的。
- en: see it when we build it okay this is a long function other questions very good
    question。 about the multi-threading multiprocessing other questions on this one
    good question。 good question a lot okay yeah the question is hey how does this
    time thing work basically。 up here we are creating a very local variable called
    start it happens to be a type struct。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何构建它。好的，这是一个很长的函数。其他问题？关于多线程、多进程的非常好的问题。其他问题？好的问题，很多问题。是的，问题是：嘿，这个时间是如何工作的？基本上，在这里我们创建了一个非常局部的变量，叫做
    start，它恰好是一个结构体类型。
- en: time value and then we're populating with the current time get time of day we'll
    say。 what time is it right now and populates that and then whenever we and then
    we just keep。 that locally and then later after we do all of our checking or all
    of our creating the。 words and so forth we then say that took this much time we
    do it again we get the time of。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值，然后我们用当前时间填充，获取一天中的时间。我们会说，现在是什么时间，然后填充上这个时间。然后无论何时，我们都会保持这个时间本地保存。接下来，在做完所有检查或创建单词等操作后，我们再说，花了这么多时间，再次获取时间。
- en: day now subtract the two and we get the duration exactly what you would have
    done in the midterm。 again it's time everything again yeah the sock stream at
    the top is for basically reading。 in the data which we will let's see we'll write
    out the data here and then let's see do we。 read it anywhere else or do we already
    have it ready yes the get letters get letters is。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在减去这两者，我们就能得到精确的持续时间，这正是你在期中考试中会做的事情。再说一遍，一切都要用时间来衡量。顶部的 sock 流基本上是用于读取数据的。我们会把数据写出来，接下来看看我们是否在其他地方读取它，或者它是否已经准备好，是的，获取字母就是。
- en: going to read from that one and o string stream is we are going to build up
    a string。 and that's how you do this right it actually it allows you to take a
    string and build it。 up one piece at a time kind of how it works you could do
    it as a regular string but this。 is like a string builder and Java you know you
    might have used a job so you'll see how。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从那个地方读取，o string stream 是我们将构建一个字符串。这就是你如何做的，实际上它允许你逐步构建一个字符串。它的工作原理就像 Java
    中的字符串构建器，你可能用过。你将看到它是如何工作的。
- en: it works you'll see how it works in a minute other questions on this one okay
    let's move。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的，稍后你将看到它是如何工作的。对此还有其他问题吗？好的，让我们继续。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_71.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_71.png)'
- en: on okay so the poll form of a words this is where we need to use the file descriptor。
    we got from our sub process to actually create all those words and put the words
    into a vector。 it's pretty straightforward right we are going to do this which
    is not something you。 may have seen before this is actually creating a it's basically
    creating a data structure。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以词汇的轮询形式，这是我们需要使用从子进程中获得的文件描述符。我们将实际创建所有这些单词并将单词放入一个向量中。这其实很简单，对吧？我们将做这个，这是你之前可能没有见过的，它基本上是在创建一个数据结构。
- en: that allows you to create an input stream for that for C++ it's all that is
    and then we。 read one line at a time from the sub process and after we read one
    line at a time we one。 until we get to the end we then push it into the vector
    all there is to it there and that。 vectors reference so you don't need to return
    or anything all right send response well remember。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你为 C++ 创建一个输入流，仅此而已。然后我们从子进程中一次读取一行，直到读取到最后一行。然后我们将它推入向量中，这就是全部内容。那个向量是按引用传递的，所以你不需要返回或做其他操作。好的，发送响应时，请记住。
- en: we've already constructed the payload we'll see that in a minute okay send response
    does。 the following well it actually is the reverse of the get command okay the
    get function it's。 the server sending data back before when we did the get time
    server we didn't care what。 the format was it was our own special format we now
    want this to be so that a web like a。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了有效负载，稍后会看到。好的，发送响应做了以下操作。它实际上是获取命令的反向操作。它是服务器发送数据回来的过程。之前我们做获取时间服务器时，我们并不关心格式是什么，它是我们自己特殊的格式。现在我们希望它是这样构建的，像一个
    web 服务器一样。
- en: client or a web browser could use our server we're actually raising up the stakes
    here now。 we're saying oh let's do this from our browser so the browser is expecting
    the response to。 be in the following format it's expecting us to say we are using
    HTTP 1。1 slash or 1。1 then。 it says what is the status okay in this case it's
    200 and if you go look up let's see uh。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端或网页浏览器可以使用我们的服务器。现在我们实际上是在提升这个问题的复杂度。我们说，“好吧，让我们从浏览器来做这个事情”，所以浏览器期望收到的响应格式如下。它期待我们说“我们正在使用HTTP
    1.1”或“1.1”，然后它显示状态是什么，好的，在这种情况下是200。如果你去查阅的话，看看…
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_73.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_73.png)'
- en: on this way HTTP 200 it says it says the HTTP HTTP 200 okay status response
    code indicates。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，HTTP 200表示，HTTP 200 OK状态响应码表示。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_75.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_75.png)'
- en: that the request has succeeded so you get back a 200 that says hey your request
    succeeded。 there are lots of things that could go wrong the server could time
    out some reason that。 would be a different command that would be a different one
    the server could have moved。 remember the one we got before which was 300 or whatever
    it says look this means the server。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请求已成功，因此你会收到一个200状态码，表示“嘿，你的请求成功了”。有很多事情可能出错，比如服务器超时，这时会有不同的状态码。服务器也可能已经移动，记得我们之前看到的那个状态码是300，它的意思是服务器。
- en: has moved you can look up the all the uh you can look up all the status codes
    and all。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 已经移动，你可以查阅所有的状态码，所有的。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_77.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_77.png)'
- en: the status codes are right here 200 is okay 201 means it's something's created
    there's。 an accepted you're basically the server sending back to the data to the
    client saying here's。 what's going on right now and it's and generally you're
    looking for 200 which says great everything。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码就在这里，200表示正常，201意味着有某些内容被创建。还有一个是accepted，基本上是服务器向客户端发送数据，告诉你当前发生了什么，通常你会看到200，这表示一切顺利。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_79.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_79.png)'
- en: worked out okay the ones that did redirection is the ones we saw before okay
    and that's the。 one that client errors or 400 saying the client says oh I screwed
    up right or you screwed。 up I get a server saying hey you screwed up you didn't
    ask for the right thing or you。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利，那些执行重定向的状态码就是我们之前看到的状态码，接下来是客户端错误，400表示客户端说“哦，我搞砸了”或者“是你搞砸了”。然后服务器回应：“嘿，你搞砸了，你没有请求正确的东西。”
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_81.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_81.png)'
- en: didn't give them the right form or whatever bad request or unauthorized or whatever
    500s。 are I screwed up the server screwed up which are down here internal server
    error maybe。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 没有给他们正确的表单，或者是错误的请求、未经授权等等。500系列的错误意味着“我搞砸了”或者“服务器搞砸了”，它们通常出现在这里，内部服务器错误可能是其中之一。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_83.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_83.png)'
- en: you gave the wrong issue there's timeouts or whatever there's one that let's
    see there's。 one called I am a teapot which is 418 that one in here there we go
    one of the original。 web servers ever was a little web server that basically said
    whether or not coffee was。 ready in an office sounds pretty banal but that's the
    way things work you know when they。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你给了错误的请求，可能是超时之类的，或者是像418这样的状态码。让我们来看一下，有一个叫“我是一个茶壶”的状态码是418，它出现在这里。嗯，最早的一个网页服务器基本上是说办公室里的咖啡是否准备好，听起来很平常，但这就是事情的运作方式，当时就是这样。
- en: create these things the first web server was this so somebody coded this up
    and said if。 you get 418 back it means you're a teapot why well that's the way
    it goes it's kind。 of an Easter egg it turns out okay all right so so we will
    send back okay we will send back。 the I am using HTTP 1。1 0 200 and then you also
    send an okay which says everything worked。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些东西，第一个网页服务器就是这个。所以某人编写了这个代码并说，如果你收到418，意味着你是一个茶壶。为什么？嗯，这就是事情的运行方式，这算是一个复活节彩蛋。结果证明，这样做没问题。好吧，我们会返回200，表示一切正常，然后你还会收到一个表示一切顺利的回应。
- en: out great and then you send your little back slash our back slash and then you
    send some。 headers now this is where the server is sending headers to the client
    okay the header in this。 case is text slash one of them is called content type
    you will see that all the time。 if you're doing back end server work content type
    is what kind of data am I sending back。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，然后你发送你的小反斜杠，然后你发送一些。头部，这是服务器发送给客户端的头部，好吧，这里的头部是text slash其中一个叫做content type，你在做后端服务器工作时经常会看到它，content
    type是我返回的数据是什么类型。
- en: in this case we're sending text slash JavaScript and they were also saying what
    character set。 we are using which is good because of the computers around the
    world know how to translate what。 we're sending the text slash JavaScript is a
    little weird I looked it up I was I was confused。 about why we're using that why
    we were using that ourselves so I just looked up like what。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们发送的是text slash JavaScript，而且他们还说了我们使用的字符集。这是好事，因为全球的计算机知道如何翻译我们发送的内容。text
    slash JavaScript有点奇怪，我查了一下，我有点困惑。为什么我们要使用这个，为什么我们要自己使用它，所以我就查了一下，像是。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_85.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_85.png)'
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_86.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_86.png)'
- en: whoops what should be the content type what should the content content type
    be for JSON。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，JSON应该是什么样的内容类型呢。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_88.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_88.png)'
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_89.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_89.png)'
- en: and if you look it up there's the first link there of course the stack overflow
    it says。 I've been messing around here are all the ones that I've used seen used
    which one is。 correct when we were using is application slash no it was text slash
    JavaScript so you。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查找一下，当然第一个链接就是Stack Overflow，它说。我一直在这里乱搞，这是我使用过的，看到过的，哪个是。正确的，当我们使用的是application
    slash不，它是text slash JavaScript，所以你。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_91.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_91.png)'
- en: can use that one but somebody says no no no you should use application no sorry
    you should。 use application slash JSON that's what we should be using so we could
    change this and。 do it basically your browser if you can figure it out and it
    knows most of these it will。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个，但有人说不不不，你应该使用application不，抱歉，你应该。使用application slash JSON，那是我们应该使用的，所以我们可以改变它，然后。基本上你的浏览器如果能弄明白，它就知道大多数这些它会。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_93.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_93.png)'
- en: figure it out that's what we're trying to in this case it's saying hey what's
    the format。 of the response going to be and that's what we're doing there okay
    all right then we are。 saying how long the data is so the content length is how
    many bytes am I about to send。 you why do we need to send the data why can't we
    just put a zero at the end it could be binary。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚了，这是我们在尝试的事情，在这种情况下，它说嘿，响应的格式会是什么样的。这就是我们正在做的事情，好吧，接下来我们。说数据有多长，所以内容长度是我要发送多少字节。你为什么需要发送数据，为什么不能直接在结尾加个零，它可能是二进制的。
- en: data it could be a JPEG or some other data that's not text and you can't have
    some particular。 character say when the data is ending you have to send the length
    so the client knows。 to keep reading for that amount of data okay now it could
    read until it ends which is also。 probably fine but it's good to know good to
    send it the data so it knows how much data。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是JPEG或其他不是文本的格式，而且你不能随意使用某些特定。字符来标识数据何时结束，你必须发送长度，这样客户端就知道。继续读取那么多数据，好吧，现在它可以一直读取直到结束，这也可能。没问题，但最好知道要发送数据的大小，这样它就知道数据的多少。
- en: it's expecting okay normally it would just keep reading until nothing's left
    and then。 say oh that's all the data that's that remember after our headers new
    line so we're sending。 that new line there and then we send the entire payload
    and then we flush to make sure that。 it gets sent over the data over the network
    okay so that's going on there questions on。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它在期待好吧，通常它会一直读取，直到没有剩下的，然后。说哦，所有数据都已经发送完了，记住，在我们的头部后面有换行，所以我们发送。了那个换行符，然后发送整个有效载荷，然后刷新以确保。数据通过网络发送过去，好吧，就这样，有问题吗。
- en: this one these functions this response is what we're have to send back so the
    website。 or so the web browser knows what to expect okay all right a couple other
    ones we're going。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个，这些函数，这个响应是我们必须发送回去的，这样网站。或者说网页浏览器就知道该期待什么，好吧，接下来我们要做其他几件事。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_95.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_95.png)'
- en: to look at here the get letters function which is basically getting the letters
    from your。 clients okay how does that work remember if you say if you say myth
    58 slash abcde well。 we need the you need the port number in there too but it's
    the abcde part we want to grab。 off of this so let's see how we do that okay what
    are we going to do we are given the socket。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这里的获取字母功能，基本上就是从客户端获取字母。好的，怎么做呢？记住，如果你说的是 myth 58 /abcde，好吧，你还需要在其中包含端口号，但我们要抓取的是abcde部分。让我们看看我们是怎么做的，好吗？我们将做什么呢？我们获得了套接字。
- en: stream that we already set up this is where we set that up earlier because we're
    about。 to read it we are going to create a method string a path string and a protocol
    string。 because remember there's get and then the path abcde and then the http
    1。1 etc okay so。 we need to do that method path protocol we're going to read them
    in nice thing about a stream。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经设置的流就是这里，我们之前设置它的原因是因为我们要读取它，我们将创建一个方法字符串、路径字符串和协议字符串。因为记得有GET方法，然后是路径abcde，再到http
    1.1等。好的，所以我们需要做的是方法、路径和协议，我们将读取它们，这就是流的一个好处。
- en: is you can do it one after the other boom boom boom to read them in one one
    after the。 other reads it ignores the white space in there or it breaks on the
    white space all right。 and then we need to get the rest which is one more line
    because we know that the we're。 going to have one more line after that okay and
    then we are going to just use the path。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以一个接一个地读取它们，噼里啪啦地连续读取，忽略其中的空白符，或者遇到空白符时就进行分割。好了，然后我们需要获取剩下的部分，也就是再来一行，因为我们知道在那之后我们还会有一行。好的，然后我们就使用路径。
- en: is the only part that we use to do the to get the end of that path to get our
    letters out。 of it so basically we're using the fact that you're sending to a
    particular path and using。 that path as the letters and that's how we're doing
    that okay it's all there is to that return。 pause equals equals string and we
    didn't find anything right what are we going to return。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 是我们唯一需要用来获取路径末尾的部分，从中提取出我们的字母。所以基本上我们利用了你发送到特定路径这一事实，并使用该路径作为字母，这就是我们这么做的方式。好的，就这些。返回值是字符串，如果没有找到任何东西，那么我们要返回什么？
- en: back we're going to return back the entire path otherwise we're going to return
    just。 the stuff after the slash yeah pauses the slash in that case yeah all right
    and then the construct。 payload part is going to do the JSON part now JSON is
    a very particular format it starts。 with a curly brace and it ends with a curly
    brace and inside it's got some fancy things。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回整个路径，否则我们将只返回斜杠后的部分。是的，斜杠在这种情况下是暂停符。好的，然后构建负载部分将处理JSON部分。JSON是一种非常特定的格式，它以大括号开始，并以大括号结束，内部包含一些复杂的内容。
- en: in fact the one that's on the slide here I modified a little bit so that I could
    show。 you something in a few minutes basically generally real JSON actually needs
    another quote around。 all the different parts here so basically needs a quote
    around all the parts and it's。 not reflected here so I guess I should update that
    but basically we're going to say the。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里幻灯片上的那个我稍微修改了一下，以便我能稍后向你展示。基本上，真实的JSON实际上需要在所有不同部分周围加上引号，所以基本上所有部分都需要加上引号，这里没有反映出来，所以我想我应该更新一下。但是基本上，我们将会说返回。
- en: time quit the time whether or not it's cached we're going to put way to her
    false and then。 the entire vector of strings that we got back from yeah when we
    said the status is okay we're。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 时间退出时间，无论它是否被缓存，我们会设置为false，然后是我们从状态“OK”中返回的整个字符串向量。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_97.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_97.png)'
- en: we're saying if we got to this point we're about to send you a good string that's
    what。 means the status is okay so if you're to the point where you've collected
    all your data。 it's good to go and you're ready to send a response back and everything
    looks fine you。 send okay and say yep I'm ready it sounds like you give me a good
    response here it is。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说如果我们已经到了这一点，我们准备发送一个有效字符串，这意味着状态是“OK”。所以如果你已经收集了所有数据，一切准备好，你准备发送响应，且一切看起来都正常，你就发送“OK”，并说“是的，我准备好了，这是给你的有效响应。”
- en: and that's that now if anything else breaks in the middle like the network goes
    down or。 something you just won't get a response and then it'll time out in the
    web browser and， so forth。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。如果中间有什么问题，比如网络断开，或者其他原因，你将无法收到响应，浏览器会超时，等等。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_99.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_99.png)'
- en: Okay good question all right so we are ready to test it and then I want to show
    you a couple。 of other fun things okay so I've got it all written here it's going
    to be it is Scrabble。 Scrabble word finder server I am on myth 59 and oh no oh
    I bet I'm on it if it's okay。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，好问题。那么我们已经准备好进行测试了，我还想展示一些其他有趣的东西。好了，我已经把它都写好了，它会是 Scrabble。Scrabble 单词查找服务器，我在
    myth 59 上，哦不，我猜我在那上面，如果可以的话。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_101.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_101.png)'
- en: let's do one two three four five and see if that way there we go okay so we're
    now on。 one two three four five so if in another window we go to Talmet myth 59
    one two three four five。 okay over here notice it says received your connection
    request from 171。64。15。17 that's。 a log it said that's the that's where we got
    the request from your IP address gets sent。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再做一下 12345，看看这样是否有效。好了，现在我们在 12345 了。所以如果在另一个窗口中我们访问 Talmet myth 59 12345。好的，在这里，注意到它说收到了来自
    171.64.15.17 的连接请求。那就是日志，它说这是我们收到请求的来源，你的 IP 地址被发送。
- en: to whoever it has to of course get sent to whoever your the server is and it
    gets logged。 okay all right so let's do our little get command we want to get
    slash let's say Stanford and。 then we're gonna do HTTP colon slash 1。1 and then
    we want to have like a host myth 59 I。 don't think it just kind of ignores that
    for ours and then that's that and look what we。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个请求需要发送到服务器并进行记录。好的，我们来做一下我们的 `get` 命令，我们想要获取斜杠，然后假设是 Stanford。接着我们会写 HTTP
    colon slash 1.1，然后我们希望像 `host myth 59 I` 这样的一些信息。我认为它只是忽略了这些信息，在我们的情况中就是这样，接着就是这样，看看我们得到了什么。
- en: got back right we got all our words back which is kind of cool right so far
    so good well I。 promised you that we would be able to do this from a web browser
    let's see if that works。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了回来的所有单词，这也挺酷的，对吧？到目前为止都很好。那么我曾经承诺你们，我们可以从一个网页浏览器中做到这一点，看看它是否有效。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_103.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_103.png)'
- en: okay so if I type in myth 59 colon two three four five slash somebody give me
    a bunch of。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果我在浏览器中输入 myth 59 colon two three four five slash。有人给我提供一堆。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_105.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_105.png)'
- en: letters a b c d e f j okay this all works well there's our JSON we got back
    okay it's kind。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 字母 a b c d e f j 好的，这一切都运作得很好，我们收到了我们的 JSON 响应。好了。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_107.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_107.png)'
- en: of small but that's what it is and that's what we got back from our web so we
    created。 a web server we made a web server that actually did this okay now this
    is kind of interesting。 and by the way notice how long it took 0。04 seconds that's
    how long it took to do all that。 if we do the same request again it took 1。5 to
    10 and a negative 5th sets because it was。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就是它的实际情况，这也是我们从网络服务器得到的结果。所以我们创建了一个网络服务器，实际上做到了这一点。好的，现在这有点有趣。顺便说一下，注意它花了多长时间？0.04秒，这就是它执行所有操作所花的时间。如果我们再次执行相同的请求，它花了
    1.5 到 10 毫秒，甚至有时是负 5 毫秒，因为它是。
- en: cached for us we those words were already created for us they were cached our
    server。 just went here you go I don't need to re I don't need to call that sub
    process baloney。 anymore and Eva tells us is probably not a good thing to do anyway
    so it worked that。 that's how that worked okay now you're saying yourself great
    this doesn't look like any。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器已经为我们缓存了这些单词，它们已经被缓存好了。我们的服务器只是直接提供了这些单词，不需要重新运行、也不需要调用那个子进程。Eva 告诉我们，这样做可能不是一个好主意，所以它就这样工作了。这就是它的工作方式。好的，现在你可能会想，这看起来并不是什么大事。
- en: web page I've ever been to right with this stuff so what you can do is you can
    sorry。 that's true okay what you can do is let me open up let me go to okay and
    let me go up。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我访问过的网页是这样做的。所以你可以做的是，你可以，抱歉，是的，没错。那么你可以做的是让我打开，去到，好的，我现在去上面。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_109.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_109.png)'
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_110.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_110.png)'
- en: here and do the same thing here but in this case myth let's see 59 colon one
    three four。 five okay so I didn't put a that time I didn't put natural thing in
    there in JavaScript you。 can actually request websites from JavaScript okay so
    let's actually do that what you can。 do in what's kind of cool about your your
    browser and this is why I was using I was。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再做一次，但是这次是 myth 59 colon one three four five。好的，我这次没有加上那个。我在 JavaScript
    中你实际上可以从 JavaScript 请求网站。好的，那我们就来做一下。你能做的事情，关于你的浏览器其实有一个很酷的功能，我也正是因此使用它。
- en: using Chrome because I happen to know how to use these ones pretty well let's
    see that。 one we can close so let's see this is gonna make this bigger yes I can
    okay we're gonna。 actually use what's called the fetch command to do this so if
    I type fetch that's actually。 has the ability to fetch from a website okay and
    if I type HTTP colon slash slash myth 59。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我恰好知道如何使用这些工具，所以我决定使用 Chrome，看看这个。我们可以关闭这个，那么看看，这个可以变大吗？是的，我可以。好的，我们将实际使用一个叫做
    fetch 的命令来做这个，所以如果我输入 fetch，它实际上有从网站获取数据的能力。好，如果我输入 HTTP://myth59。
- en: dot Stanford dot edu colon one two three four five because we are slash let's
    do uh。 leland let's say we had those letters okay and then method you take the
    method in this。 case what's wrong do I spell it wrong why oh man like that yeah
    sorry sorry I feel bad。 now okay I'm not gonna work here much longer don't tell
    anybody please okay um looks get。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: dot Stanford dot edu colon 一二三四五，因为我们是 slash，让我们做一下呃，leland，假设我们有那些字母，好，然后方法，你采取这个方法。在这种情况下，我拼错了吗？为什么？哦，天哪，像这样，抱歉，抱歉，我现在感觉很糟糕。好吧，我在这里不会工作太久了，别告诉别人，拜托，好，继续。
- en: we're gonna use the get method here I do need it thank you very much syntax
    highlighting。 is nice okay so we're gonna do get in this case okay and then we're
    actually going to。 do a thing called then which is the part of the request that
    says how to do this you do。 not need to know this obvious I'm just showing you
    that it works we're gonna return data。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用 get 方法，我确实需要它，非常感谢，语法高亮很不错。好了，我们在这种情况下会使用 get，然后我们实际上会做一件叫做 then 的事情，这是请求的部分，告诉我们怎么做这个，你不需要了解这些细节，我只是展示给你看它是如何工作的，我们将返回数据。
- en: dot JSON because we know it's JSON that's what we're expecting okay and then
    we do another。 then and in this case this is the one that actually does the response
    okay and what we。 can do is we can print it out console dot log with principle
    log response okay and like。 that and then we can actually catch the error if there's
    an error there shouldn't be in this。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: dot JSON 因为我们知道它是 JSON，这就是我们所期望的。然后我们再做一次。然后在这种情况下，这是那个实际上做出响应的部分，好，我们可以做的是，我们可以通过控制台输出打印它：console
    dot log 和原则性日志响应。像这样，然后我们还可以实际捕捉错误，如果有错误的话，应该没有。
- en: case there might be who knows error and let's see console dot log and whatever
    the error。 is we can do that okay if all goes well let's see there we go it gave
    us the amount of time。 it took and it gave us that and that's that so we just
    wrote a little JavaScript function。 do that again you're saying yourself that
    doesn't look like any webpage I've ever been。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出错了，可能会有谁知道的错误，我们可以看看控制台日志，看看错误是什么。好的，如果一切顺利，我们来看看，好的，给了我们所花的时间，给了我们这些内容，就这样。所以我们刚刚写了一个小的
    JavaScript 函数。再做一次，你自己会想，那看起来不像我见过的任何网页。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_112.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_112.png)'
- en: to okay but what you can do is where do I want to go here I think I put it yeah
    I put。 it on you are web by the way you all can go from your web browser and do
    this I don't。 think they tried that in the last five minutes but what's that oh
    yeah people are doing it。 thank you I guess everybody's doing it you can do that
    I guess you people are doing that。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但你可以做的是，我想去哪里？我觉得我把它放在了这里，是的，我放在那里了。顺便说一句，你们可以从你们的浏览器去做这个，我不认为他们在过去的五分钟内尝试过，不过那是什么？哦，是的，人们在做这个。谢谢，我猜大家都在做，你们可以做这个，我猜你们正在做。
- en: class CS 110 WWW okay let's see it is called Scrabble word finder dot HTML I
    wrote a little。 HTML program to do this and the reason I'm changing it right now
    is because I hard coded。 you shouldn't be this but I hard coded the wrong I didn't
    know it was going to be there。 one one two three or five in there okay and basically
    it's setting up a little webpage。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类别 CS 110 WWW 好，看看它叫做 Scrabble word finder dot HTML，我写了一个小的 HTML 程序来实现这个，而我现在要更改它是因为我硬编码了。你不应该这么做，但我硬编码了错误的内容，我不知道它会在那里。123
    或 5 在这里，好，基本上它是在设置一个小网页。
- en: so if you've done any web were that web step before you'll see I'm just setting
    up a head。 at the title of the webpage and a couple of places to put the details
    and whatever and。 if all goes right we should make this a little bigger whoops
    we should be able to go to web。 dot Stanford dot edu slash class slash CS 110
    slash Scrabble word finder word finder。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你做过任何网页工作，你会看到我只是设置了网页的标题和几个放置细节的地方，等等。如果一切顺利，我们应该能把这个放大一点，哎呀，我们应该能访问 web
    dot Stanford dot edu slash class slash CS 110 slash Scrabble word finder word
    finder。
- en: dot HTML and there we go okay we have our letters and if we type L E L A N D
    correct。 this time right we should get it back and there's our webpage so we created
    a and that。 used by the way that fetch and whatever use the JavaScript and said
    oh I know what these。 things are and it made it into us still a dumb looking web
    page certainly but it now。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: .HTML文件，接下来我们可以继续，好的，我们有了字母，如果我们输入 L E L A N D 正确的话。没错吧，我们应该会得到返回，这就是我们的网页。所以我们创建了一个，顺便说一下，使用了
    fetch 和其他 JavaScript 功能，说“哦，我知道这些是什么”，它将其转化为我们依然看起来很笨的网页，但它现在是可用的。
- en: works just like any other web page that you might might care about okay so what
    other。 weird words in there yeah you can get a Dorns from Leland what's that no
    you can't you're。 right wait a minute this didn't work right yeah wonder what
    happened with that say again。 oh I could stand for no I didn't I did I probably
    did oh my gosh I did you're right。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像任何你可能关心的其他网页一样正常工作，好的，那么里面还有什么奇怪的词吗？嗯，你可以从 Leland 获取 Dorns 吗？那是什么？不，你不能。你说得对，等等，怎么回事，刚才怎么不对了？再说一遍。哦，我可能说错了，不，我没，我应该是做了。哦，我的天，我做错了，你说得对。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_114.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_114.png)'
- en: okay I'll fix I'll fix that wow good call that doesn't make any sense okay yeah
    for some。 reason I heard that it would be easy enough to get why didn't well anyway
    I didn't do it。 so oh there it is right there we'll fix it right now since we
    can it's letters I knew。 I got it out of there I just forgot to do that let's
    see plus let's do this slash plus。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我会修复的，我会修复的，哇，好提醒，这没道理，好的，嗯，某种原因我以为应该能搞定，为什么没做到呢，反正我没做成。哦，找到了，就在那里，现在我们可以修复它，因为我们可以，这就是字母，我知道。我把它拿出来了，只是忘了做那个。让我们看看加号，让我们做这个斜杠加号。
- en: letters okay live changing the website right there let's see if this works better
    okay okay。 okay I don't know that's a good thing when you get applause after you
    make a dumb mistake。 I'm fixing it might be the good thing okay what other question
    you have about this there。 was a lot of code to look through today but it's all
    in there it's a lot of stuff we've。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 字母，好了，实时改变网站，看看这个是否能更好地工作。好的，好的。好的，我不知道这是件好事，当你犯了个愚蠢的错误后还得到掌声。我要修复它，可能这是件好事。好的，你还有什么问题吗？今天有很多代码需要查看，但都在里面，里面有很多东西。
- en: seen over the years I will find out about the multi-processing sets a great
    question and。 then we'll do it yeah yeah， yeah yeah yeah yeah so good question
    if you just type myth 59 the web server is a different。 computer altogether the
    actual Stanford web server is not on the machines we created。 our own little server
    which is kind of cool part right but we created our own little server。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我会了解多进程的问题，提了个好问题。然后我们会做这个，好的，好的，好的，好的，好的。所以如果你只输入 myth 59，网络服务器就会是另一台完全不同的计算机。实际的斯坦福网络服务器并不在我们创建的机器上。我们创建了自己的小服务器，这部分很酷吧？对，但我们创建了自己的小服务器。
- en: the web server that Stanford uses is a professionally built open source but
    professionally built server。 that serves all the regular old Stanford web pages
    that you go to web。stanford。edu that's。 where I put this one but remember this
    one goes to myth 59 and I did a hard code go to。 myth 59 in this okay that's wrong
    this tab is my computer talking directly to myth 59 how。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 斯坦福大学使用的网络服务器是一个专业构建的开源服务器，但它是一个经过专业构建的服务器。它为你访问的所有常规斯坦福网页提供服务，比如你访问的 web.stanford.edu，这就是我放置这个页面的地方。但记住，这个页面是指向
    myth 59 的，我做了一个硬编码，指向 myth 59，好的，这个是错的，这个标签页是我的计算机直接与 myth 59 对话的方式。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_116.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_116.png)'
- en: does no or 59 is it remember the DNS server I mentioned the other day that's
    where the。 domain name server you say go to myth 59 your computer and you're through
    your browser basically。 looks up what is that what IP addresses that connect to
    then it goes directly there this。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我前几天提到的 DNS 服务器吗？就是那个。域名服务器，你让它去访问 myth 59，你的计算机通过浏览器基本上就会查找出那个 IP 地址来进行连接，然后直接到达那里。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_118.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_118.png)'
- en: goes directly to myth 59 if I'm in the website here now I'm on the Stanford
    website which I'm。 gonna talk to the browser is talking to the Stanford website
    the Stanford website and through。 JavaScript and it that comes to me and then
    it tells me the JavaScript I need to go to。 myth 59 directly so basically I'm
    loading the web page from web。stanford。edu which is the。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我现在在斯坦福的网站上，我就在访问斯坦福网站，浏览器正在与斯坦福网站交互，斯坦福网站通过 JavaScript 和它与我互动，然后它告诉我需要去访问
    myth 59。所以基本上我正在从 web.stanford.edu 加载这个网页。
- en: main Stanford website and then I'm myself talking directly to myth 59 on my
    computer。 here to get the actual words you could probably do a different way where
    you had this website。 or my computer talk back to the Stanford website which then
    talks to myth 59 and does a one。 or layer of indirection but in this case we skip
    that in your direction。 So it's a little。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是斯坦福大学的主网站，然后我自己直接在我的电脑上与 myth 59 进行通信。为了获取实际的单词，你也许可以通过另一种方式操作，让这个网站或我的电脑与斯坦福网站进行通信，之后斯坦福网站再与
    myth 59 进行通信，这样就多了一个间接层。但是在这个例子中，我们跳过了这个间接层。
- en: there's a lot going on there。 Yeah。 Yeah the port closing happens in there it
    is it happens。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 那里发生了很多事情。是的，端口关闭就在里面发生了，确实发生了。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_120.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_120.png)'
- en: when the client socket goes out of scope so it's basically back wherever we
    created it。 I think we created it right here so it goes out of scope like down
    here at the end of。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端套接字超出作用域时，它基本上会回到我们创建它的地方。我认为我们就是在这里创建它的，所以它会在这里结束时超出作用域。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_122.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_122.png)'
- en: this function and then it closes it。 That's where the in our case the server
    closes the。 connection to the client。 Okay good questions。 Alright like I said
    I'm glad to do it。 I'm。 sorry now feel free to stop by or after class and ask
    more questions and we'll see you guys。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，然后它关闭了它。这就是我们案例中，服务器关闭与客户端的连接的地方。好的，问题很棒。好吧，正如我所说，很高兴为大家解答。我……抱歉，之后随时可以停下来或者课后过来提问，期待见到大家。
- en: '![](img/f50c184769ea64a2b64fcd4bbac6e714_124.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50c184769ea64a2b64fcd4bbac6e714_124.png)'
