- en: 1.2   Data Abstraction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2   数据抽象
- en: 原文：[https://algs4.cs.princeton.edu/12oop](https://algs4.cs.princeton.edu/12oop)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/12oop](https://algs4.cs.princeton.edu/12oop)
- en: Object-oriented programming.
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程。
- en: Programming in Java is largely based on building data types. This style of programming
    is known as *object-oriented programming*, as it revolves around the concept of
    an *object*, an entity that holds a data type value. With Java's primitive types
    we are largely confined to programs that operate on numbers, but with reference
    types we can write programs that operate on strings, pictures, sounds, or any
    of hundreds of other abstractions that are available in Java's standard libraries
    or on our booksite. Even more significant than libraries of predefined data types
    is that the range of data types available in Java programming is open-ended, because
    you can define your own data types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编程主要基于构建数据类型。这种编程风格被称为*面向对象编程*，因为它围绕着*对象*的概念展开，一个持有数据类型值的实体。使用 Java 的原始类型，我们主要限于操作数字的程序，但使用引用类型，我们可以编写操作字符串、图片、声音或
    Java 标准库或我们的书站上提供的数百种其他抽象的程序。比预定义数据类型库更重要的是，Java 编程中可用的数据类型范围是开放的，因为您可以定义自己的数据类型。
- en: '*Data types.* A *data type* is a set of values and a set of operations on those
    values.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据类型。* *数据类型* 是一组值和对这些值的一组操作。'
- en: '*Abstract data types.* An *abstract data type* is a data type whose internal
    representation is hidden from the client.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象数据类型。* *抽象数据类型* 是一个其内部表示对客户端隐藏的数据类型。'
- en: '*Objects.* An *object* is an entity that can take on a data-type value. Objects
    are characterized by three essential properties: The *state* of an object is a
    value from its data type; the *identity* of an object distinguishes one object
    from another; the *behavior* of an object is the effect of data-type operations.
    In Java, a *reference* is a mechanism for accessing an object.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象。* *对象* 是一个可以取一个数据类型值的实体。对象具有三个基本属性：对象的*状态*是来自其数据类型的值；对象的*标识*区分一个对象与另一个对象；对象的*行为*是数据类型操作的效果。在
    Java 中，*引用*是访问对象的机制。'
- en: '*Applications programming interface (API).* To specify the behavior of an abstract
    data type, we use an *application programming interface* (API), which is a list
    of *constructors* and *instance methods* (operations), with an informal description
    of the effect of each, as in this API for `Counter`:![api for counter](../Images/344b9a06b18c58fbb94d74ac0211ac3f.png)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序编程接口（API）。* 为了指定抽象数据类型的行为，我们使用一个*应用程序编程接口*（API），它是一个*构造函数*和*实例方法*（操作）的列表，每个操作的效果都有一个非正式描述，就像这个`Counter`的
    API 一样：![Counter 的 API](../Images/344b9a06b18c58fbb94d74ac0211ac3f.png)'
- en: '*Client.* A client is a program that uses a data type.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端。* 客户端是使用数据类型的程序。'
- en: '*Implementation.* An implementation is the code that implements the data type
    specified in an API.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现。* 实现是实现 API 中指定的数据类型的代码。'
- en: Using abstract data types.
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用抽象数据类型。
- en: A client does not need to know how a data type is implemented in order to be
    able to use it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不需要知道数据类型是如何实现的才能使用它。
- en: '*Creating objects.* Each data-type value is stored in an object. To create
    (or *instantiate*) an individual object, we invoke a *constructor* by using the
    keyword `new`. Each time that a client uses `new`, the system allocates memory
    space for the object, initializes its value, and returns a reference to the object.![constructor](../Images/746f5c4141d5ccd9aa55cd809fe8618a.png)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建对象。* 每个数据类型值都存储在一个对象中。要创建（或*实例化*)一个单独的对象，我们通过使用关键字`new`来调用一个*构造函数*。每当客户端使用`new`时，系统会为对象分配内存空间，初始化其值，并返回对对象的引用。![构造函数](../Images/746f5c4141d5ccd9aa55cd809fe8618a.png)'
- en: '*Invoking instance methods.* The purpose of an instance method is to operate
    on data-type values. Instance methods have all of the properties of static methods:
    arguments are passed by value, method names can be overloaded, they may have a
    return value, and they may cause side effects. They have an additional property
    that characterizes them: *each invocation is associated with an object*.![instance
    method](../Images/78b0bb3e5e88a4b117f28dd57ebeb198.png)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用实例方法。* 实例方法的目的是操作数据类型的值。实例方法具有静态方法的所有属性：参数按值传递，方法名称可以重载，它们可能有返回值，并且可能会引起副作用。它们具有表征它们的附加属性：*每次调用都与一个对象关联*。![实例方法](../Images/78b0bb3e5e88a4b117f28dd57ebeb198.png)'
- en: '*Using objects.* Declarations give us variable names for objects that we can
    use in code. To use a given data type, we:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用对象。* 声明为我们提供了在代码中可以使用的对象的变量名。要使用给定的数据类型，我们：'
- en: Declare variables of the type, for use in referring to objects
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明类型的变量，用于引用对象
- en: Use the keyword `new` to invoke a constructor that creates objects of the type
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键字`new`来调用创建该类型对象的构造函数
- en: Use the object name to invoke instance methods, either as statements or within
    expressions
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象名称来调用实例方法，可以作为语句或在表达式中
- en: For example, [Flips.java](Flips.java.html) is a [Counter.java](Counter.java.html)
    client that takes a command-line argument `T` and simulate `T` coin flips.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，[Flips.java](Flips.java.html) 是一个 [Counter.java](Counter.java.html) 客户端，它接受一个命令行参数`T`并模拟`T`次硬币翻转。
- en: '*Assignment statements.* An assignment statement with a reference type creates
    a copy of the reference (and does not create a new object). This situation is
    known as *aliasing*: both variables refer to the same object. Aliasing is a common
    source of bugs in Java programs, as illustrated by the following example:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*赋值语句。* 具有引用类型的赋值语句会创建引用的副本（而不会创建新对象）��这种情况被称为*别名*：两个变量都引用同一个对象。别名是 Java 程序中常见的错误来源，如下例所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code prints the string `"2 ones"`.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该代码打印字符串`"2 ones"`。
- en: '*Objects as arguments.* You can pass objects as arguments to methods. Java
    passes a *copy* of the argument value from the calling program to the method.
    This arrangement is known as *pass by value*. If you pass a reference to an object
    of type `Counter`, Java passes a copy of that reference. Thus, the method cannot
    change the original reference (make it point to a different `Counter`), but it
    can change the value of the object, for example by using the reference to call
    `increment()`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象作为参数。* 您可以将对象作为参数传递给方法。Java将调用程序中的参数值的*副本*传递给方法。这种安排称为*按值传递*。如果您将一个指向`Counter`类型对象的引用传递给方法，Java将传递该引用的副本。因此，该方法无法更改原始引用（使其指向不同的`Counter`），但可以更改对象的值，例如通过使用引用调用`increment()`。'
- en: '*Objects as return values.* You can also use an object as a return value from
    a method. The method might return an object passed to it as an argument, as in
    [FlipsMax.java](FlipsMax.java.html), or it might create an object and return a
    reference to it. This capability is important because Java methods allow only
    one return value—using objects enables us to write code that, in effect, returns
    multiple values.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象作为返回值。* 您还可以将对象作为方法的返回值。该方法可能会返回作为参数传递给它的对象，就像[FlipsMax.java](FlipsMax.java.html)中的情况，或者它可能创建一个对象并返回对其的引用。这种能力很重要，因为Java方法只允许一个返回值——使用对象使我们能够编写代码，实际上返回多个值。'
- en: '*Arrays are objects.* In Java, every value of any nonprimitive type is an object.
    In particular, arrays are objects. As with strings, there is special language
    support for certain operations on arrays: declarations, initialization, and indexing.
    As with any other object, when we pass an array to a method or use an array variable
    on the right hand side of an assignment statement, we are making a copy of the
    array reference, not a copy of the array.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组是对象。* 在Java中，任何非原始类型的值都是对象。特别是，数组是对象。与字符串一样，对数组有特殊的语言支持：声明、初始化和索引。与任何其他对象一样，当我们将数组传递给方法或在赋值语句的右侧使用数组变量时，我们只是复制数组引用，而不是数组本身的副本。'
- en: '*Arrays of objects.* Array entries can be of any type. When we create an array
    of objects, we do so in two steps: create the array, using the bracket syntax
    for array constructors; create each object in the array, using a standard constructor
    for each. [Rolls.java](Rolls.java.html) simulates rolling a die, using an array
    of `Counter` objects to keep track of the number of occurrences of each possible
    value.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象数组。* 数组条目可以是任何类型。当我们创建一个对象数组时，需要分两步进行：使用数组构造函数的括号语法创建数组；为数组中的每个对象创建一个标准构造函数。[Rolls.java](Rolls.java.html)
    模拟掷骰子，使用`Counter`对象数组来跟踪每个可能值出现的次数。'
- en: Examples of abstract data types.
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象数据类型的示例。
- en: '*Geometric objects.* A natural example of object-oriented programming is designing
    data types for geometric objects.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*几何对象。* 面向对象编程的一个自然示例是为几何对象设计数据类型。'
- en: '[Point2D.java](Point2D.java.html) is a data type for points in the plane.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Point2D.java](Point2D.java.html) 是用于平面上的点的数据类型。'
- en: '[Interval1D.java](Interval1D.java.html) is a data type for one-dimensional
    intervals.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Interval1D.java](Interval1D.java.html) 是用于一维区间的数据类型。'
- en: '[Interval2D.java](Interval2D.java.html) is a data type for two-dimensional
    intervals.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Interval2D.java](Interval2D.java.html) 是用于二维区间的数据类型。'
- en: '*Information processing.* Abstract data types provide a natural mechanism for
    organizing and processing information. the information'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息处理。* 抽象数据类型提供了一个自然的机制来组织和处理信息。信息'
- en: '[Date.java](Date.java.html) is a data type that represents the day, month,
    and year.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Date.java](Date.java.html) 是一个表示日期、月份和年份的���据类型。'
- en: '[Transaction.java](Transaction.java.html) is a data type that represents a
    customer, a date, and an amount.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Transaction.java](Transaction.java.html) 是一个表示客户、日期和金额的数据类型。'
- en: '*Accumulator.* [Accumulator.java](Accumulator.java.html) defines an ADT that
    provides to clients the ability to maintain a running average of data values.
    For example, we use this data type frequently in this book to process experimental
    results. [VisualAccumulator.java](VisualAccumulator.java.html) in an enhanced
    version that also plots the data (in gray) and the running average (in red).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*累加器。* [Accumulator.java](Accumulator.java.html) 定义了一个ADT，为客户提供了维护数据值的运行平均值的能力。例如，我们在本书中经常使用这种数据类型来处理实验结果。[VisualAccumulator.java](VisualAccumulator.java.html)
    是一个增强版本，还会绘制数据（灰色）和运行平均值（红色）。'
- en: '*Strings.* Java''s `String` data type in an important and useful ADT. A `String`
    is an indexed sequence of `char` values. `String` has dozens of instance methods,
    including the following:![string api](../Images/5fc6fdf8cebc832d05976fd4bfa5a8d1.png)`String`
    has special language support for initialization and concatenation: instead of
    creating and initializing a string with a constructor, we can use a string literal;
    instead of invoking the method `concat()` we can use the `+` operator.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串。* Java的`String`数据类型是一个重要且有用的ADT。`String`是`char`值的索引序列。`String`有几十种实例方法，包括以下内容：![string
    api](../Images/5fc6fdf8cebc832d05976fd4bfa5a8d1.png)`String`有特殊的语言支持用于初始化和连接：我们可以使用字符串字面量来创建和初始化字符串，而不是使用构造函数；我们可以使用`+`运算符来连接字符串，而不是调用`concat()`方法。'
- en: '*Input and output revisited.* A disadvantage of the `StdIn`, `StdOut`, and
    `StdDraw` libraries of Section 1.1 is that they restrict us to working with just
    one input file, one output file, and one drawing for any given program. With object-oriented
    programming, we can define similar mechanisms that allow us to work with *multiple*
    input streams, output streams, and drawings within one program. Specifically,
    our standard library includes the data types [In.java](In.java.html), [Out.java](Out.java.html),
    and [Draw.java](Draw.java.html) that support multiple input and output streams.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入和输出再探讨。* 第1.1节的`StdIn`、`StdOut`和`StdDraw`库的一个缺点是它们限制了我们在任何给定程序中只能使用一个输入文件、一个输出文件和一个绘图。通过面向对象编程，我们可以定义类似的机制，允许我们在一个程序中使用*多个*输入流、输出流和绘图。具体来说，我们的标准库包括支持多个输入和输出流的数据类型[In.java](In.java.html)、[Out.java](Out.java.html)和[Draw.java](Draw.java.html)。'
- en: Implementing abstract data types.
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现抽象数据类型。
- en: We implement ADTs with a Java class, putting the code in a file with the same
    name as the class, followed by the .java extension. The first statements in the
    file declare *instance variables* that define the data-type values. Following
    the instance variables are the *constructor* and the *instance methods* that implement
    operations on data-type values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Java类来实现ADTs，将代码放在与类同名的文件中，后面跟着.java扩展名。文件中的第一条语句声明*实例变量*，定义数据类型的值。在实例变量之后是*构造函数*和*实例方法*，实现对数据类型值的操作。
- en: '*Instance variables.* To define data-type values (the state of each object),
    we declare instance variables in much the same way as we declare local variables.
    There are numerous values corresponding to each instance variable (one for each
    object that is an instance of the data type). Each declaration is qualified by
    a *visibility modifier*. In ADT implementations, we use `private`, using a Java
    language mechanism to enforce the idea that the representation of an ADT is to
    be hidden from the client, and also `final`, if the value is not to be changed
    once it is initialized.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实例变量.* 为了定义数据类型的值（每个对象的状态），我们声明实例变量的方式与声明局部变量的方式非常相似。每个实例变量对应着许多值（对应数据类型的每个实例对象）。每个声明都由*可见性修饰符*修饰。在ADT实现中，我们使用`private`，使用Java语言机制来强制执行ADT的表示应该对客户端隐藏，还可以使用`final`，如果该值在初始化后不会更改。'
- en: '*Constructors.* The constructor establishes an object''s identity and initializes
    the instance variables. Constructors always share the same name as the class.
    We can overload the name and have multiple constructors with different signatures,
    just as with methods. If no other constructor is defined, a default no-argument
    constructor is implicit, has no arguments, and initializes instance values to
    default values. The default values of instance variables are 0 for primitive numeric
    types, `false` for `boolean`, and `null`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数.* 构造函数建立对象的标识并初始化实例变量。构造函数总是与类同名。我们可以重载名称并具有具有不同签名的多个构造函数，就像方法一样。如果没有定义其他构造函数，则隐式存在一个默认无参数构造函数，没有参数，并将实例值初始化为默认值。原始数值类型的默认值为0，`boolean`为`false`，`null`。'
- en: '*Instance methods.* Instance methods specify the data-type operations. Each
    instance method has a return type, a *signature* (which specifies its name and
    the types and names of its parameter variables), and a *body* (which consists
    of a sequence of statements, including a *return* statement that provides a value
    of the return type back to the client). When a client invokes a method, the parameter
    values (if any) are initialized with client values, the statements are executed
    until a return value is computed, and the value is returned to the client. Instance
    methods may be *public* (specified in the API) or *private* (used to organize
    the computation and not available to clients).![anatomy of a class](../Images/f2ba62b6f6a93c8b5b768867b234b4a9.png)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实例方法.* 实例方法指定数据类型的操作。每个实例方法都有一个返回类型，一个*签名*（指定其名称和参数变量的类型和名称），以及一个*主体*（包括一系列语句，包括一个*返回*语句，将返回类型的值提供给客户端）。当客户端调用方法时，参数值（如果有）将用客户端值初始化，语句将执行直到计算出返回值，并将该值返回给客户端。实例方法可以是*public*（在API中指定）或*private*（用于组织计算且不可用于客户端）。![类的解剖图](../Images/f2ba62b6f6a93c8b5b768867b234b4a9.png)'
- en: '*Scope.* Instance methods use three kinds of variables: parameter variables,
    local variables, and instance variables. The first two of these are the same as
    for static methods: parameter variables are specified in the method signature
    and initialized with client values when the method is called, and local variables
    are declared and initialized within the method body. The scope of parameter variables
    is the entire method; the scope of local variables is the following statements
    in the block where they are defined. Instance variables hold data-type values
    for objects in a class, and their scope is the entire class (whenever there is
    an ambiguity, you can use the `this` prefix to identify instance variables).![scope](../Images/e367d827323d269b2efc6b128f5e9c3d.png)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作用域.* 实例方法使用三种类型的变量：参数变量，局部变量和实例变量。前两者与静态方法相同：参数变量在方法签名中指定，并在调用方法时用客户端值初始化，局部变量在方法主体内声明和初始化。参数变量的作用域是整个方法；局部变量的作用域是定义它们的块中的后续语句。实例变量保存类中对象的数据类型值，其作用域是整个类（在存在歧义时，可以使用`this`前缀来标识实例变量）。![作用域](../Images/e367d827323d269b2efc6b128f5e9c3d.png)'
- en: Designing abstract data types.
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计抽象数据类型。
- en: We put important information related to designing data types in one place for
    reference and to set the stage for implementations throughout this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将与设计数据类型相关的重要信息放在一个地方供参考，并为本书中的实现奠定基础。
- en: '*Encapsulation.* A hallmark of object-oriented programming is that it enables
    us to *encapsulate* data types within their implementations, to facilitate separate
    development of clients and data type implementations. Encapsulation enables modular
    programming.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*封装.* 面向对象编程的一个特点是它使我们能够将数据类型封装在其实现中，以促进客户端和数据类型实现的分开开发。封装实现了模块化编程。'
- en: '*Designing APIs.* One of the most important and most challenging steps in building
    modern software is designing APIs. Ideally, an API would clearly articulate behavior
    for all possible inputs, including side effects, and then we would have software
    to check that implementations meet the specification. Unfortunately, a fundamental
    result from theoretical computer science known as the *specification problem*
    implies that this goal is actually impossible to achieve. There are numerous potential
    pitfalls when designing an API:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计APIs.* 在构建现代软件中最重要且最具挑战性的步骤之一是设计APIs。理想情况下，API将清晰地阐明所有可能输入的行为，包括副作用，然后我们将有软件来检查实现是否符合规范。不幸的是，理论计算机科学中的一个基本结果，即*规范问题*，意味着这个目标实际上是不可能实现的。在设计API时存在许多潜在的陷阱：'
- en: Too hard to implement, making it difficult or impossible to develop.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于难以实现，使得开发变得困难或不可能。
- en: Too hard to use, leading to complicated client code.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于难以使用，导致复杂的客户端代码。
- en: Too narrow, omitting methods that clients need.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于狭窄，省略了客户端需要的方法。
- en: Too wide, including a large number of methods not needed by any client.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于广泛，包含许多任何客户端都不需要的方法。
- en: Too general, providing no useful abstractions.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于一般，提供没有用的抽象。
- en: Too specific, providing an abstraction so diffuse as to be useless.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于具体，提供的抽象太过模糊，无用。
- en: Too dependent on a particular representation, therefore not freeing client code
    from the details of the representation.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于依赖特定表示，因此不能使客户端代码摆脱表示的细节。
- en: In summary, provide to clients the methods they need and no others.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总之，为客户端提供他们需要的方法，而不是其他方法。
- en: '*Algorithms and ADTs.* Data abstraction is naturally suited to the study of
    algorithms, because it helps us provide a framework within which we can precisely
    specify both what an algorithm needs to accomplish and how a client can make use
    of an algorithm. For example, our allowlisting example at the beginning of the
    chapter is naturally cast as an ADT client, based on the following operations:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算法和ADT.* 数据抽象自然适合于算法的研究，因为它帮助我们提供一个框架，可以精确指定算法需要完成的任务以及客户端如何使用算法。例如，我们在本章开头的白名单示例自然地被视为ADT客户端，基于以下操作：'
- en: Construct a SET from an array of given values.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定值数组构造一个SET。
- en: Determine whether a given value is in the set.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定给定值是否在集合中。
- en: These operations are encapsulated in [StaticSETofInts.java](StaticSETofInts.java.html)
    and [Allowlist.java](Allowlist.java.html).
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些操作封装在[StaticSETofInts.java](StaticSETofInts.java.html)和[Allowlist.java](Allowlist.java.html)中。
- en: '*Interface inheritance.* Java provides language support for defining relationships
    among objects, known as *inheritance*. The first inheritance mechanism that we
    consider is known as *subtyping*, which allows us to specify a relationship between
    otherwise unrelated classes by specifying in an *interface* a set of common methods
    that each implementing class must contain. We use interface inheritance for *comparison*
    and for *iteration*.![Java interfaces used in this book](../Images/96a2e8b80288d8f2b26f4203a0afa1fe.png)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口继承.* Java提供了语言支持来定义对象之间的关系，称为*继承*。我们考虑的第一种继承机制称为*子类型化*，它允许我们通过在*接口*中指定一组每个实现类必须包含的共同方法来指定否则无关的类之间的关系。我们使用接口继承进行*比较*和*迭代*。![本书中使用的Java接口](../Images/96a2e8b80288d8f2b26f4203a0afa1fe.png)'
- en: '*Implementation inheritance.* Java also supports another inheritance mechanism
    known as *subclassing*, which is a powerful technique that enables a programmer
    to change behavior and add functionality without rewriting an entire class from
    scratch. The idea is to define a new class (*subclass*) that inherits instance
    methods and instance variables from another class (*superclass*). We avoid subclassing
    in this book because it generally works against encapsulation. Certain vestiges
    of the approach are built in to Java and therefore unavoidable: specifically,
    every class is a subclass of [Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html).![Inherited
    methods from Object used in this book](../Images/4207c9ba2f346a59ed043551cf3f3bb6.png)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现继承.* Java还支持另一种继承机制，称为*子类化*，这是一种强大的技术，使程序员能够在不从头开始重写整个类的情况下更改行为和添加功能。这个想法是定义一个��承实例方法和实例变量的新类（*子类*），从另一个类（*超类*）继承。我们在本书中避免使用子类化，因为它通常违反封装。这种方法的某些残留物内置在Java中，因此不可避免：具体来说，每个类都是[Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html)的子类。![本书中使用的Object继承方法](../Images/4207c9ba2f346a59ed043551cf3f3bb6.png)'
- en: '*String conversion.* Every Java type inherits `toString()` from [Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html).
    This convention is the basis for Java''s automatic conversion of one operand of
    the concatenation operator `+` to a `String` whenever the other operand is a `String`.
    We generally include implementations of `toString()` that override the default,
    as in [Date.java](Date.java.html) and [Transaction.java](Transaction.java.html).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串转换.* 每种Java类型都从[Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html)继承了`toString()`。这种约定是Java自动将连接运算符`+`的一个操作数转换为`String`的基础，只要另一个操作数是`String`。我们通常包含重写默认`toString()`的实现，如[Date.java](Date.java.html)和[Transaction.java](Transaction.java.html)。'
- en: '*Wrapper types.* Java supplies built-in reference types known as *wrapper types*,
    one for each of the primitive types:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包装类型.* Java提供了内置的引用类型，称为*包装类型*，每种原始类型对应一个：'
- en: '| **primitive type** | **wrapper type** |'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **基本类型** | **包装类型** |'
- en: '| `boolean` | [Boolean](http://download.oracle.com/javase/6/docs/api/java/lang/Boolean.html)
    |'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `boolean` | [Boolean](http://download.oracle.com/javase/6/docs/api/java/lang/Boolean.html)
    |'
- en: '| `byte` | [Byte](http://download.oracle.com/javase/6/docs/api/java/lang/Byte.html)
    |'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `byte` | [Byte](http://download.oracle.com/javase/6/docs/api/java/lang/Byte.html)
    |'
- en: '| `char` | [Character](http://download.oracle.com/javase/6/docs/api/java/lang/Character.html)
    |'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `char` | [Character](http://download.oracle.com/javase/6/docs/api/java/lang/Character.html)
    |'
- en: '| `double` | [Double](http://download.oracle.com/javase/6/docs/api/java/lang/Double.html)
    |'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `double` | [Double](http://download.oracle.com/javase/6/docs/api/java/lang/Double.html)
    |'
- en: '| `float` | [Float](http://download.oracle.com/javase/6/docs/api/java/lang/Float.html)
    |'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `float` | [Float](http://download.oracle.com/javase/6/docs/api/java/lang/Float.html)
    |'
- en: '| `int` | [Integer](http://download.oracle.com/javase/6/docs/api/java/lang/Integer.html)
    |'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `int` | [Integer](http://download.oracle.com/javase/6/docs/api/java/lang/Integer.html)
    |'
- en: '| `long` | [Long](http://download.oracle.com/javase/6/docs/api/java/lang/Long.html)
    |'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `long` | [Long](http://download.oracle.com/javase/6/docs/api/java/lang/Long.html)
    |'
- en: '| `short` | [Short](http://download.oracle.com/javase/6/docs/api/java/lang/Short.html)
    |'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `short` | [Short](http://download.oracle.com/javase/6/docs/api/java/lang/Short.html)
    |'
- en: Java automatically converts from primitive types to wrapper types (*autoboxing*)
    and back (*auto-unboxing*) when warranted.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java在必要时会自动将基本类型转换为包装类型（*autoboxing*）并在需要时转换回来（*auto-unboxing*）。
- en: '*Equality.* What does it mean for two objects to be equal? If we test equality
    with `(a == b)` where `a` and `b` are reference variables of the same type, we
    are testing whether they have the same identity: whether the *references* are
    equal. Typical clients would rather be able to test whether the *data-type values*
    (object state) are the same. Every Java type inherits the method `equals()` from
    [Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html).
    Java provides natural implementations both for standard types such as `Integer`,
    `Double`, and `String` and for more complicated types such as [java.io.File](http://download.oracle.com/javase/6/docs/api/java/io/File.html)
    and [java.net.URL](http://download.oracle.com/javase/6/docs/api/java/net/URL.html).
    When we define our own data types we need to override `equals()`. Java''s convention
    is that `equals()` must be an *equivalence relation*:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相等性.* 两个对象相等意味着什么？如果我们用 `(a == b)` 测试相等性，其中 `a` 和 `b` 是相同类型的引用变量，我们正在测试它们是否具有相同的标识：是否*引用*相等。典型的客户端更希望能够测试*数据类型值*（对象状态）是否相同。每个
    Java 类型都从 [Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html)
    继承了 `equals()` 方法。Java 为标准类型（如 `Integer`、`Double` 和 `String`）以及更复杂类型（如 [java.io.File](http://download.oracle.com/javase/6/docs/api/java/io/File.html)
    和 [java.net.URL](http://download.oracle.com/javase/6/docs/api/java/net/URL.html)）提供了自然的实现。当我们定义自己的数据类型时，我们需要重写
    `equals()`。Java 的约定是 `equals()` 必须是一个*等价关系*：'
- en: '*Reflexive*: `x.equals(x)` is true.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自反性*: `x.equals(x)` 成立。'
- en: '*Symmetric*: `x.equals(y)` is true if and only if `y.equals(x)` is true.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对称性*: `x.equals(y)` 成立当且仅当 `y.equals(x)` 成立。'
- en: '*Transitive*: if `x.equals(y)` and `y.equals(z)` are true, then so is `x.equals(z)`.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传递性*: 如果 `x.equals(y)` 和 `y.equals(z)` 成立，则 `x.equals(z)` 也成立。'
- en: In addition, it must take an `Object` as argument and satisfy the following
    properties.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，它必须以 `Object` 作为参数，并满足以下属性。
- en: '*Consistent*: multiple invocations of `x.equals(y)` consistently return the
    same value, provided neither object is modified.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致性*: 多次调用 `x.equals(y)` 一致地返回相同的值，前提是没有修改任何对象。'
- en: '*Not null*: `x.equals(null)` returns false.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非空*: `x.equals(null)` 返回 false。'
- en: Adhering to these Java conventions can be tricky, as illustrated for [Date.java](Date.java.html)
    and [Transaction.java](Transaction.java.html).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遵循这些 Java 约定可能会有些棘手，就像 [Date.java](Date.java.html) 和 [Transaction.java](Transaction.java.html)
    中所示的那样。
- en: '*Memory management.* One of Java''s most significant features is its ability
    to *automatically* manage memory. When an object can no longer be referenced,
    it is said to be *orphaned*. Java keeps track of orphaned objects and returning
    the memory they use to a pool of free memory. Reclaiming memory in this way is
    known as *garbage collection*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存管理.* Java 最重要的特性之一是其能够*自动*管理内存。当一个对象不再被引用时，它被称为*孤立的*。Java 跟踪孤立的对象，并将它们使用的内存返回给一个空闲内存池。以这种方式回收内存被称为*垃圾回收*。'
- en: '*Immutability.* An *immutable* data type has the property that the value of
    an object never changes once constructed. By contrast, a *mutable* data type manipulates
    object values that are intended to change. Java''s language support for helping
    to enforce immutability is the `final` modifier. When you declare a variable to
    be `final`, you are promising to assign it a value only once, either in an initializer
    or in the constructor. Code that could modify the value of a `final` variable
    leads to a compile-time error.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变性.* 一个*不可变*的数据类型具有一个特性，即对象的值在构造后永远不会改变。相比之下，*可变*的数据类型操作旨在改变的对象值。Java 为帮助强制实现不可变性提供了
    `final` 修饰符。当你声明一个变量为 `final` 时，你承诺只能在初始化程序或构造函数中为其分配一个值。试图修改 `final` 变量的值的代码会导致编译时错误。'
- en: '[Vector.java](Vector.java.html) is an immutable data type for vectors. In order
    to guarantee immutability, it *defensively copies* the mutable constructor argument.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Vector.java](Vector.java.html) 是一个用于向量的不可变数据类型。为了保证不可变性，它*防御性地复制*了可变的构造函数参数。'
- en: '*Exceptions and errors* are disruptive events that handle unforeseen errors
    *outside* our control. We have already encountered the following exceptions and
    errors:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异常和错误*是处理我们无法控制的意外错误的破坏性事件。我们已经遇到了以下异常和错误：'
- en: '[ArithmeticException](http://download.oracle.com/javase/6/docs/api/java/lang/ArithmeticException.html).
    Thrown when an exceptional arithmetic condition (such as integer division by zero)
    occurs.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ArithmeticException](http://download.oracle.com/javase/6/docs/api/java/lang/ArithmeticException.html)。当发生异常的算术条件（例如整数除以零）时抛出。'
- en: '[ArrayIndexOutOfBoundsException](http://download.oracle.com/javase/6/docs/api/java/lang/ArrayIndexOutOfBoundsException.html).
    Thrown when an array is accessed with an illegal index.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ArrayIndexOutOfBoundsException](http://download.oracle.com/javase/6/docs/api/java/lang/ArrayIndexOutOfBoundsException.html)。当使用非法索引访问数组时抛出。'
- en: '[NullPointerException](http://download.oracle.com/javase/6/docs/api/java/lang/NullPointerException.html).
    Thrown when `null` is used where an object is required.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NullPointerException](http://download.oracle.com/javase/6/docs/api/java/lang/NullPointerException.html)。当需要对象而使用
    `null` 时抛出。'
- en: '[OutOfMemoryError](http://download.oracle.com/javase/6/docs/api/java/lang/OutOfMemoryError.html).
    Thrown when the Java Virtual Machine cannot allocate an object because it is out
    of memory.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OutOfMemoryError](http://download.oracle.com/javase/6/docs/api/java/lang/OutOfMemoryError.html)。当
    Java 虚拟机无法分配对象因为内存不足时抛出。'
- en: '[StackOverflowError](http://download.oracle.com/javase/6/docs/api/java/lang/StackOverflowError.html).
    Thrown when a recursive method recurs too deeply.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[StackOverflowError](http://download.oracle.com/javase/6/docs/api/java/lang/StackOverflowError.html)。当递归方法递归太深时抛出。'
- en: You can also create your own exceptions. The simplest kind is a [RuntimeException](http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html)
    that terminates execution of the program and prints an error message.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以创建自己的异常。最简单的一种是终止程序执行并打印错误消息的 [RuntimeException](http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html)。
- en: '[PRE1]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Assertions* are boolean expressions which verify assumptions that we make
    *within* code we develop. If the expression is false, the program will terminate
    and report an error message. For example, suppose that you have a computed value
    that you might use to index into an array. If this value were negative, it would
    cause an `ArrayIndexOutOfBoundsException` sometime later. But if you write the
    code'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*断言* 是在我们开发的代码中验证我们所做假设的布尔表达式。如果表达式为false，程序将终止并报告错误消息。例如，假设您有一个计算值，可能用于���引到数组中。如果这个值为负，它将在稍后引起`ArrayIndexOutOfBoundsException`。但如果您编写代码'
- en: '[PRE2]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'you can pinpoint the place where the error occurred. By default, assertions
    are disabled.You can enable them from the command line by using the `-enableassertions`
    flag (`-ea` for short). Assertions are for debugging: your program should not
    rely on assertions for normal operation since they may be disabled.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以确定发生错误的地方。默认情况下，断言是禁用的。您可以通过使用`-enableassertions`标志（简写为`-ea`）从命令行启用它们。断言用于调试：您的程序不应依赖断言进行正常操作，因为它们可能被禁用。
- en: Q + A.
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q + A.
- en: Q. Are there any truly immutable classes in Java?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Q. Java中是否有真正的不可变类？
- en: A. If you use reflection, you can access the `private` fields of any class and
    change them. Program [MutableString.java](MutableString.java.html) demonstrates
    how to mutate a `String`. Program [MutableInteger.java](MutableInteger.java.html)
    demonstrates that this is true even if the instance variable is final.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用反射，可以访问任何类的`private`字段并更改它们。程序[MutableString.java](MutableString.java.html)演示了如何改变一个`String`。程序[MutableInteger.java](MutableInteger.java.html)证明了即使实例变量是final，这也是正确的。
- en: Exercises
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Write a [Point2D.java](Point2D.java.html) client that takes an integer value
    N from the command line, generates N random points in the unit square, and computes
    the distance separating the closest pair of points.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个[Point2D.java](Point2D.java.html)客户端，从命令行获取一个整数值N，在单位正方形内生成N个随机点，并计算最近一对点之间的距离。
- en: What does the following code fragment print?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE3]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Solution:*'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：*'
- en: '[PRE4]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A string s is a *circular rotation* of a string t if it matches when the characters
    are circularly shifted by any number of positions; e.g., ACTGACG is a circular
    shift of TGACGAC, and vice versa. Detecting this condition is important in the
    study of genomic sequences. Write a program that checks whether two given strings
    s and t are circular shifts of one another.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个字符串s是字符串t的*circular rotation*，那么当字符被任意数量的位置循环移位时，它们匹配；例如，ACTGACG是TGACGAC的循环移位，反之亦然。检测这种条件在基因组序列研究中很重要。编写一个程序，检查两个给定的字符串s和t是否彼此的循环移位。
- en: '*Solution:* `(s.length() == t.length()) && (s.concat(s).indexOf(t) >= 0)`'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* `(s.length() == t.length()) && (s.concat(s).indexOf(t) >= 0)`'
- en: What does the following recursive function return?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下递归函数返回什么？
- en: '[PRE5]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Solution:* Reverse of the string.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* 字符串的反转。'
- en: Using our implementation of [Date.java](Date.java.html) as a model, develop
    an implementation of [Transaction.java](Transaction.java.html).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的[Date.java](Date.java.html)的实现作为模型，开发一个[Transaction.java](Transaction.java.html)的实现。
- en: Using our implementation of `equals()` in [Date.java](Date.java.html) as a model,
    develop an implementation of `equals()` for [Transaction.java](Transaction.java.html).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在[Date.java](Date.java.html)中的`equals()`的实现作为模型，为[Transaction.java](Transaction.java.html)开发一个`equals()`的实现。
- en: Creative Problems
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意问题
- en: '**Rational numbers.** Implement an immutable data type [Rational.java](Rational.java.html)
    for rational numbers that supports addition, subtraction, multiplication, and
    division.![api for rational numbers](../Images/326bdf1a1c3ca8a918594ae536bb4576.png)You
    do not have to worry about testing for overflow, but use as instance variables
    two `long` values that represent the numerator and denominator to limit the possibility
    of overflow. Use Euclid''s algorithm to ensure that the numerator and denominator
    never have any common factors. Include a test client that exercises all of your
    methods.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有理数。** 为有理数实现一个不可变的数据类型[Rational.java](Rational.java.html)，支持加法、减法、乘法和除法。![有理数的API](../Images/326bdf1a1c3ca8a918594ae536bb4576.png)您不必担心溢出测试，但使用两个表示分子和分母的`long`值作为实例变量，以限制溢出的可能性。使用欧几里得算法确保分子和分母永远没有任何公因数。包括一个测试客户端，测试所有方法。'
- en: '**Sample variance for accumulator.** Validate that the following code, which
    adds the methods `var()` and `stddev()` to [Accumulator.java](Accumulator.java.html)
    to compute the mean, sample variance, and sample standard deviation of the numbers
    presented as arguments to `addDataValue()`.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**累加器的样本方差。** 验证以下代码，为[Accumulator.java](Accumulator.java.html)添加`var()`和`stddev()`方法，计算作为`addDataValue()`参数呈现的数字的均值、样本方差和样本标准差。'
- en: '*Reference:* Here is a good [explanation](http://www.johndcook.com/standard_deviation.html)
    of this one-pass method, that was first discovered by Welford in 1962. This approach
    can be applied to computing the skewness, kurtosis, regression coefficients, and
    Pearson''s correlation coefficient.'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*参考：* 这里有一个很好的[解释](http://www.johndcook.com/standard_deviation.html)这种一次性方法，最早由Welford在1962年发现。这种方法可以应用于计算偏度、峰度、回归系数和皮尔逊相关系数。'
- en: '**Parsing.** Develop the parse constructors for your [Date.java](Date.java.html)
    and [Transaction.java](Transaction.java.html) implementations that take a single
    `String` argument to specify the initialization values, using the formats given
    in the table below.![parsing for Date and Transaction](../Images/95c0298309fe07196f4bda8469fa7ba3.png)'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析。** 为您的[Date.java](Date.java.html)和[Transaction.java](Transaction.java.html)实现开发解析构造函数，使用下表中给出的格式的单个`String`参数指定初始化值。![Date和Transaction的解析](../Images/95c0298309fe07196f4bda8469fa7ba3.png)'
