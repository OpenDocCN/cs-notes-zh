- en: 哈佛 CS50-WEB ｜ 基于Python ／ JavaScript的Web编程(2020·完整版) - P18：L6- web用户接口与交互 1 (用户接口，单页面应用)
    - ShowMeAI - BV1gL411x7NY
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛 CS50-WEB ｜ 基于Python ／ JavaScript的Web编程(2020·完整版) - P18：L6- web用户接口与交互 1 (用户接口，单页面应用)
    - ShowMeAI - BV1gL411x7NY
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_0.png)'
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_1.png)'
- en: welcome back everyone to web programming，with python and javascript，and last
    time we took a look at。javascript that language that ran inside，of a user's web
    browser，client side and allowed us to do a。number of things to make our web pages，more
    interactive，javascript enabled us to display alerts。to be able to manipulate the
    dom the，structure of the web page in order to。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大家欢迎回到使用Python和JavaScript的Web编程，上一节我们关注了在用户的Web浏览器中运行的JavaScript，这让我们能够做很多事情，使我们的网页更具互动性，JavaScript让我们能够显示警报，操纵DOM，调整网页结构。
- en: add content or see what content was，already there and it also let us respond，to
    user events。when a user clicked on a button or，submitted a form or typed something
    into，an input field。we could have javascript functions run，that responded to those
    events。in order to make our web pages more，interactive today we're going to，continue
    that conversation。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 添加内容或查看已有的内容，还能让我们响应用户事件。当用户点击按钮、提交表单或在输入字段中输入内容时，我们可以运行JavaScript函数，响应这些事件，以使我们的网页更具互动性。今天我们将继续这个话题。
- en: in particular taking a look at user，interface design，looking at some common
    paradigms in。terms of user interfaces and how we can，leverage javascript，to be
    able to achieve those goals to。create interactive user interfaces，that will be
    valuable when users are。interacting with our applications，so one of the more common
    paradigms。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是查看用户界面设计，关注一些常见的用户界面范式，以及我们如何利用JavaScript实现这些目标，创建与用户互动时有价值的互动用户界面，因此更常见的范式之一。
- en: especially nowadays in web programming，is the idea of single page applications。thus
    far if we wanted to create a web，application，that has multiple different pages
    we've。generally done that via multiple，different routes in our django web。application
    for example where you go to，slash something to get one page and，slash something
    else。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在现代Web编程中，单页面应用的理念尤为重要。如果我们想创建一个有多个不同页面的Web应用，通常是通过在我们的Django Web应用中使用多个不同的路由来实现，例如你去某个地址可以获取一个页面，而去另一个地址则可以获取另一个页面。
- en: in order to get another page but，commonly using javascript，we have the ability
    to create single。page applications where the entire web，page is really，just a
    single page and then we use。javascript to manipulate the dom to，replace portions
    of the page。with things we want to replace and this，has a number of advantages。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得另一个页面，常用JavaScript的方式，我们可以创建单页面应用，整个网页实际上就是一个单页面，然后我们使用JavaScript来操纵DOM，用我们想替换的内容替换页面的部分，这有很多优势。
- en: one of them being that we only need to，make modifications to the part of the。page
    that is actually changing，if for example you have five different。pages but the
    general layout and，structure of the page is pretty similar。when you switch between
    pages rather，than load an entirely new page。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个是我们只需对实际变化的页面部分进行修改，例如如果你有五个不同的页面，但页面的一般布局和结构相似，当你在页面之间切换时，而不是加载一个全新的页面。
- en: you can just load the part of the page，helpful，for applications that are changing
    quite。frequently so let's take a look now at，how we could implement for example。a
    very simple single page application，so let's imagine for example that we。want
    a single page application，that just displays three different pages，but all included。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以只加载页面的一部分，这对于频繁变化的应用非常有帮助。那么现在我们来看看如何实现一个非常简单的单页面应用，假设我们想要一个只显示三个不同页面的单页面应用，但这些内容都是包含在一个页面中。
- en: in the same page i'll go ahead and，create a new file，that i'll call singlepage。html。inside
    of which we'll include our usual，and inside the body of this page now i'm，going
    to include。three different sections of the page to，represent the three different
    pages。i might want to display to the user so，i'll have a div，whose id is page
    one that maybe just has。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一页面上，我将创建一个新的文件，称为singlepage.html。在这个文件中，我们将包含我们的常规内容，并在这个页面的主体中，我将包括三个不同的部分，以代表我可能希望向用户展示的三个不同页面，因此我将有一个id为page
    one的div，里面可能只是包含一些内容。
- en: a heading that says this is page one and，you could imagine there's more content，on
    these pages。as well a div whose id is page two，we'll say this is page two and
    then one。final div whose id is page three。![](img/6bd7990afce68466d7cd024987b3bfe2_3.png)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个标题，写着这是页面一，你可以想象这些页面上还有更多内容。同样有一个 id 为页面二的 div，我们称之为页面二，然后是一个 id 为页面三的最终
    div。![](img/6bd7990afce68466d7cd024987b3bfe2_3.png)
- en: it has a heading that says this is page，three for example，now right now if i
    were to open up。![](img/6bd7990afce68466d7cd024987b3bfe2_5.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个标题，写着这是页面三，例如，现在如果我打开。![](img/6bd7990afce68466d7cd024987b3bfe2_5.png)
- en: single page。html，what we'd see is we see all three pages，at the same time and
    now that's probably。not what we want，what we really want is by default to。![](img/6bd7990afce68466d7cd024987b3bfe2_7.png)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: single page.html，我们看到的是同时显示所有三个页面，这可能不是我们想要的。我们真正想要的是默认情况下。![](img/6bd7990afce68466d7cd024987b3bfe2_7.png)
- en: hide these pages until we want to view，the pages one at a time for example。so
    one thing i could do is use css to be，able to toggle，whether or not something
    is visible。adding some style tags to my page，to say that by default all of my
    divs，none。meaning they're not visible they're not。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些页面隐藏，直到我们想要查看它们，例如一次查看一个页面。所以我可以做的一件事是使用 CSS 来切换，某个内容是否可见。添加一些样式标签到我的页面，默认情况下，我的所有
    div 都是不可见的。
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_9.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_9.png)'
- en: displayed on the screen，now if i refresh the page i don't，actually see any of
    the three headings。![](img/6bd7990afce68466d7cd024987b3bfe2_11.png)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在屏幕上显示，如果我刷新页面，我实际上看不到三个标题中的任何一个。![](img/6bd7990afce68466d7cd024987b3bfe2_11.png)
- en: that i had there before，but what i'd really like is for some，buttons now to
    allow me to toggle。between these three pages，so i'll give myself three buttons
    one，button that says page one。one button that says page two and one，button that
    says page three for example。and i need some mechanism for these，buttons to know
    when you click on this。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前有的，但是我真的希望现在有一些按钮，让我在这三页之间切换。所以我会给自己三个按钮，一个按钮写着页面一，一个按钮写着页面二，一个按钮写着页面三。例如，我需要某种机制，让这些按钮知道当你点击这个。
- en: button what page should be displayed，so i'll go ahead and use data attributes。which
    we saw last time with javascript，to add some additional information to。these particular
    html elements，where i'll give the first button a data，dash page value。of page
    one the second one a data dash，page value of page two。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮应该显示哪个页面，因此我将继续使用数据属性，我们上次在 JavaScript 中看到过，给这些特定的 HTML 元素添加一些额外的信息，我会给第一个按钮一个
    data dash 页面值为页面一，第二个按钮的值为页面二。
- en: and the third one a data dash page value，of page three，here again just providing
    information so。that later when i write some javascript，i can have the javascript
    code look at。the data dash page attribute，to say that when you click on this，button
    you should let me see。the div whose id is page one that's what，this is going to
    allow us。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个是页面三的 data dash 页面值，这里同样只是提供信息。这样在我稍后写一些 JavaScript 时，可以让 JavaScript 代码查看这个
    data dash 页面属性，来判断当你点击这个按钮时，应该让我看到 id 为页面一的 div，这就是我们要实现的。
- en: to signal so now let's go ahead and，write，to do，is to be able to say i would
    like to。show page one and hide the other two or，show page two，and hide the other
    two or show page。three for example and so to do that i'll，first write a function。that
    will let me do that i'll write a，function called show page，that takes as its argument
    like what。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在让我们继续，写代码，做的就是能够说我想显示页面一，隐藏其他两个，或者显示页面二，隐藏其他两个，或者例如显示页面三。为此，我首先会写一个函数，让我实现这一点，我会写一个名为
    show page 的函数，它的参数就是要显示的页面。
- en: page i want to show，and so what should this function do what，we're going to
    do is we're going to say。document。queryselector，and i want to get the thing that
    has a，particular id。the id of whatever this input happens to，be this page is going
    to represent。the id of the div that i want to show so，i'll say get me the thing
    that has this，id。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我想显示的页面，所以这个函数应该做什么，我们将要做的是使用 document.queryselector，我想获取具有特定 id 的元素。这个页面的 id
    将代表我想显示的 div 的 id，所以我会说获取这个 id 的元素。
- en: and then using a template literal i'll，say all right get me the id，of page whatever
    element has that。particular id，and then i'd like to change its style，property
    which part of the style well i。want to change its display property，and instead
    of none which was the，default here where i said。don't show it at all the other
    option，for a div is，block meaning it shows up as just a。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用模板字面量，我会说好的，获取页面上任意元素的id，并且我想要更改它的样式属性，具体是更改它的显示属性，而不是默认的none。我希望更改为block，这样它就会显示出来。
- en: block that is on the page that is，actually。![](img/6bd7990afce68466d7cd024987b3bfe2_13.png)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 块在页面上实际上。![](img/6bd7990afce68466d7cd024987b3bfe2_13.png)
- en: function，and i can test it in fact if i go into，my browser refresh the page。i
    now see three buttons the buttons，don't do anything just yet。but what i can do
    is in the console if i，actually just try running this i can run。the show page
    function，and say like show page page one for，example。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，我可以在浏览器中刷新页面进行测试。现在我看到三个按钮，这些按钮暂时没有任何作用。但是我可以在控制台中运行这个函数，像是运行显示页面函数，举个例子，显示页面一。
- en: press return and all right page one now，page，page two then page two will become，visible。and
    all right that did half of what i，wanted page two is now visible。but so is page
    one so i probably want it，such that if i ever show a page。i hide the other pages
    first like hide。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车，现在页面一，然后页面二，那么页面二将变得可见。好的，这完成了我想要的一半，页面二现在可见，但页面一也可见。因此我可能想要这样，如果我显示一个页面，首先隐藏其他页面，像是隐藏。
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_15.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_15.png)'
- en: all the pages and then show page two or，hide all the pages，and then show page
    three so how could i。go about doing that，well first i might want to just when
    i，show a page first hide all of the other。pages hide all the pages，so to get all
    the pages i'll do，document。query selector。all get all of the divs which is what，i'm
    using to include enclose the pages。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有页面，然后显示页面二，或者隐藏所有页面，然后显示页面三。那么我该如何进行呢？首先，当我显示一个页面时，我想先隐藏所有其他页面，隐藏所有页面。为了获取所有页面，我会用document.querySelectorAll获取所有的div，这是我用来封装页面的。
- en: and now for each one of those again，effectively creating a loop where i'm。looping
    over each of the divs，for each div let's go ahead and set the。![](img/6bd7990afce68466d7cd024987b3bfe2_17.png)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于每一个，再次有效地创建一个循环，我在遍历每个div，对于每个div，我们就这样设置。![](img/6bd7990afce68466d7cd024987b3bfe2_17.png)
- en: div dot style，dot display property equal to none，and so what this show page
    function is。now doing is it is first，querying for all of the divs which are。simulating
    my pages inside of the single，page application，and for each one of the divs we're
    going。to pass it as input into this，function which is the argument to for。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: div的样式属性设置为none。所以这个显示页面的函数现在首先查询所有的div，它们模拟着我的单页面应用中的页面，对于每一个div，我们将其作为输入传递给这个函数。
- en: each again using this arrow function，notation which is just a shorthand way。of
    expressing a function where i'm here，saying that for each of the divs。we'll go
    ahead and modify its style，property setting display，equal to none meaning don't
    show any of。the divs and then，show only the div that was requested so，now this
    should solve the problem of。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用这个箭头函数的语法，这只是一种简写方式，用于表达一个函数。在这里，我说对于每个div，我们将修改它的样式属性，将显示设置为none，意味着不显示任何div，然后只显示被请求的div，现在这应该解决这个问题。
- en: multiple pages appearing simultaneously，that if i go back to this page and i。click
    or write show page，page one then page one appears，but if i run show page of page
    two。then page two appears but page one。![](img/6bd7990afce68466d7cd024987b3bfe2_19.png)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同时出现多个页面，如果我回到这个页面并点击或输入显示页面一，那么页面一会出现，但如果我运行显示页面二，那么页面二会出现，但页面一。![](img/6bd7990afce68466d7cd024987b3bfe2_19.png)
- en: disappears and likewise when i show page，page three，that shows page three but
    not the other。two so i can manipulate which page is，visible，all via the console
    but now what i'd。like to do is get these buttons to，actually work where if i click
    on one of，the buttons。that has the effect of actually，displaying the requested
    page，so in order to do that well i want to。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 消失，同样，当我显示页面三时，它显示页面三而不显示其他两个，所以我可以通过控制台操控哪个页面是可见的。但现在我希望这些按钮能够真正起作用，当我点击其中一个按钮时，它能实际显示请求的页面。因此，为了做到这一点，我想要。
- en: attach some event listeners to these，buttons，which means i need to wait until
    those。buttons have loaded onto the page，so we'll use document dot add event，listener。dom
    content loaded again waiting until，all of the content on the page。has been loaded
    and then and only then，will i say let's go ahead and query，selector all。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要为这些按钮附加一些事件监听器，这意味着我需要等待这些按钮加载到页面上，所以我们将使用document.addEventListener。等待直到页面上所有内容加载完成，然后我才会说让我们查询选择器所有。
- en: for all of the buttons and for each one，of those buttons，let's go ahead and
    attach an event。listener to each of those buttons so i'm，querying for all of the
    buttons。and saying for each of the buttons i，would like to do this with each button，and
    what i'd like to do。is say button。onclick when the button is，clicked on，go ahead
    and run this function i'd like。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有按钮及每一个按钮，让我们为每个按钮附加一个事件监听器，因此我正在查询所有按钮，并说对每个按钮我想这样做，我想要做的是在按钮被点击时执行这个函数。
- en: to show page，and which page do i want to show well i，want to show whatever page
    is in。the page part of the button's data set，and to get it the current button
    the。button that has been clicked on，recall that when we're inside of an。event
    handler we can take advantage，of the javascript keyword this which。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示页面，我想显示哪个页面呢？我想显示按钮数据集中页面部分的内容，而要获取当前按钮，即被点击的按钮，请记住，当我们在事件处理程序内时，我们可以利用javascript关键字this。
- en: refers to whatever element has received，case，that was clicked on so i can say
    this，dot dataset。![](img/6bd7990afce68466d7cd024987b3bfe2_21.png)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该关键字指的是接收到点击事件的元素，因此我可以说this.dataset。![](img/6bd7990afce68466d7cd024987b3bfe2_21.png)
- en: dot page to mean that all right for each，of the buttons，when the button is clicked
    on we're。saying button。unclick for each of the，buttons，run this function when
    the button is。clicked we'd like to show a page，which page do we want to show we'll
    take。this button the button that received the，event，access its data properties
    accesses data。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 点页面意味着，对于每个按钮，当按钮被点击时，我们会为每个按钮运行这个函数。当按钮被点击时，我们想要显示哪个页面，我们将取这个按钮，即接收到事件的按钮，访问它的数据属性。
- en: page attribute，which are down here either page one or，page two or page three。and
    go ahead and just call the show page，function that we wrote a moment ago。so now
    that we've done that we've，attached these event handlers。to the buttons so now
    if i refresh the。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 页面属性，这里有页面一、页面二或页面三。然后我们就可以调用我们刚才写的show page函数。所以现在我们已经完成了，为按钮附加了这些事件处理程序，所以现在如果我刷新页面。
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_23.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_23.png)'
- en: page i can click on these buttons，and toggle between any of the three，pages。and
    now the interesting thing here is，that we now have the ability to just in，a single
    page。allow myself to simulate the idea of，having multiple pages all enclosed in
    a，single html file。but not needing to consistently make，additional requests to
    a server，in order to get access to that。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上我可以点击这些按钮，切换到任意三个页面之间。现在有趣的是，我们现在可以在一个单一页面中模拟多个页面的概念，所有内容都封装在一个html文件中，但不需要持续向服务器发出额外请求来获取访问权限。
- en: information now sometimes though，it might be reasonable to want to reach。out
    to a server when you need new，information for a page for example。you might imagine
    that each of these，pages contains a lot of text，it's going to be inefficient if。immediately
    we're loading all of that，data into html，and just showing and hiding them when
    we。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时当你需要一个页面的新信息时，联系服务器可能是合理的。例如，你可能想象每个页面包含大量文本，如果我们立即将所有数据加载到html中并显示和隐藏，那将是低效的。
- en: need to because maybe we're loading more，information than the user is ever going。to
    actually care about if they're never，going to look，at page 2 or page 3。so one
    thing we。might imagine doing，is loading this data dynamically last，time when we
    were talking about。javascript we saw how we could use，fetch to say go ahead and
    request some，additional information。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要这样做，因为我们可能加载的信息超过了用户实际上关心的内容，尤其是如果他们从不查看第2页或第3页。所以我们可能想象的一个做法是动态加载这些数据，上次我们讨论的javascript中，我们看到如何使用fetch来请求一些额外的信息。
- en: from a web server last time it was，currency exchange rates but then we used，that
    data that came back。in order to fill in something onto our，page and likewise we
    could do a similar，thing here。that if we have the general structure of，a single
    page，and we want to load new content rather。than load entirely new html content
    and，reload the entire page。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上一次是来自一个网络服务器，货币兑换率，但我们利用返回的数据填充了我们页面上的内容，同样，我们可以在这里做类似的事情，如果我们有一个单页面的总体结构，并且希望加载新内容，而不是完全加载新的HTML内容并重新加载整个页面。
- en: we can just ask our own web server for，what part of the page needs to change。and
    then just replace that part of the，page，and so that's what we'll take a look at。now
    now combining django for our web，server，and javascript for writing the client。side
    code to be able to generate，a single page application and so for。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以询问自己的网络服务器，页面的哪个部分需要更改，然后替换页面的那部分，这就是我们现在要看的内容，现在结合Django作为我们的网络服务器，以及JavaScript用于编写客户端代码，以生成单页面应用。
- en: this we'll go ahead and go into an，example i had in advance，called single page
    one and inside of。single page one，this is just a django application with a，single
    app called single page。and what we'll notice is we'll go to the，urls first，there
    are two urls one default url that。just loads the index function，and then a url
    for loading different。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进入一个我提前准备的示例，叫做单页面一，里面只是一个Django应用程序，包含一个叫做单页面的应用。我们会注意到，首先要查看URLs，里面有两个URLs，一个是默认URL，仅加载索引函数，另一个是加载不同内容的URL。
- en: like sections of a page that i might，want to dynamically load for example so，i
    have section slash。some particular number and if we look at，the views for what
    it is these urls are。actually doing the index function，just returns index。html
    and then what，the section function does。is it first makes sure the number is，between
    one and three and if so。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像是我可能想动态加载的页面部分，例如，我有 `/section/` 加上某个特定数字，如果我们看看这些URL的视图，实际上索引函数只是返回 `index.html`，然后部分函数做的是，它首先确保数字在1到3之间，如果是的话。
- en: responds with one of these just strings。![](img/6bd7990afce68466d7cd024987b3bfe2_25.png)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的是这些字符串之一。
- en: of text for example，so how does this actually work if i go，into。![](img/6bd7990afce68466d7cd024987b3bfe2_27.png)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这实际上是如何工作的呢？如果我进入。
- en: if i go to this url slash section slash，one for example，what i get is this block
    of text and if。i go to slash section slash two，i get that block of text section
    slash。three a different block of text，altogether so just different text。![](img/6bd7990afce68466d7cd024987b3bfe2_29.png)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我访问这个URL `/section/one`，我得到的是这一段文本，如果我去 `/section/two`，我得到的是另一段文本，而 `/section/three`
    则是完全不同的文本，所以只是不同的文本。
- en: and i'd like to incorporate this text，into an existing，into，index。html this
    template that gets。loaded when i go to the default route，and inside of index。html
    what we'll see。is i have a show section function that，behaves very similar to
    the show page，function。we saw from a moment ago but instead，what show section
    is going to do。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将这段文本纳入一个现有的`index.html`模板中，该模板在我访问默认路由时加载，而在`index.html`中，我们会看到我有一个显示部分的函数，其行为与我们刚才看到的显示页面函数非常相似，但不同的是，显示部分将要做的事情。
- en: is it's going to fetch what text i，should display on the page。from my own web
    server i'm fetching from，slash sections，slash fill in a number here number like。one
    or two or three，when i get the response in the past，we've seen how we can convert
    that。response into json data if it's some，structured data，we can also just convert
    the response。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从我的网络服务器获取我应该在页面上显示的文本，我从 `/sections/` 获取数据，填入一个数字，比如一、二或三，当我收到响应时，过去我们已经看到如何将该响应转换为JSON数据，如果它是一些结构化数据，我们也可以直接转换响应。
- en: into plain text，then i'll take that text console。log it，just so we can see it
    in the log output。but then go ahead and query select for，the content of the page
    something that，has an id of content。update its innerhtml and set it equal to，that
    text，so what this entire function is now。doing is it is going to reach out to
    my，server，figure out what text content belongs in。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成纯文本后，我将获取该文本并在控制台中记录它，以便我们在日志输出中看到，但接着会查询选择页面内容，某个ID为content的元素，更新其innerHTML并将其设置为该文本，所以现在这个整个函数正在做的是，它将联系我的服务器，弄清楚哪些文本内容应该在。
- en: the new section，and fill in the part of my page，accordingly，with the text that
    comes back from that。http request，and then down further below inside of，the page
    we'll see that i have。a hello heading three buttons that，toggle between the different
    sec。sections each of them has a data dash，section attribute this time。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新部分将填充页面相应的部分，并根据来自该 HTTP 请求的文本进行填充，然后在页面的下方，我们会看到我有一个“你好”标题和三个按钮，它们在不同的部分之间切换，每个按钮都有一个
    data-section 属性。
- en: for which section should be loaded and，then a div that is initially blank。![](img/6bd7990afce68466d7cd024987b3bfe2_31.png)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用于确定应该加载哪个部分，然后是一个最初为空的 div。![](img/6bd7990afce68466d7cd024987b3bfe2_31.png)
- en: just for the content of the page so，putting this all together now。if i go to
    the default route i see hello，plus three buttons to give me a choice。between three
    different sections，and if i click section one what's going。to happen is javascript
    is going to，query，section slash one ask for the text it，gets that text back。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在把这一切放在一起，如果我访问默认路由，我会看到“你好”，加上三个按钮，给我提供在三个不同部分之间选择的机会，如果我点击第一部分，发生的事情是 JavaScript
    将请求 `section/1` 的文本，它会返回文本。
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_33.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_33.png)'
- en: and it's going to fill it in into the，page section one，section two and section
    three so very。similar to before，but unlike what we had before where all，of the
    text was being loaded into the。html page all at once，now we're using asynchronous
    javascript，to only dynamically load information。when we need it when we click
    on a，section then it's going to make the。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它将填充到页面的第一部分、第二部分和第三部分，所以与之前非常相似，但不同于之前我们所有文本一次性加载到 HTML 页面中，现在我们使用异步 JavaScript
    仅在需要时动态加载信息，当我们点击某个部分时，它将发出请求。
- en: request for what content needs to be，filled in，and it's going to fill it in
    and，heading。and you might imagine in a more complex，website you've got a lot more
    going on。around the edges of this webpage all of，that stays the same we don't
    need to。reload any of that information，we're only reloading the portion of the，page
    that actually changes。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请求需要填充的内容，它将进行填充，并生成标题。你可能想象，在一个更复杂的网站中，网页边缘的内容要多得多，所有这些内容保持不变，我们不需要重新加载任何这些信息，我们仅重新加载实际改变的页面部分。
- en: as we toggle between these various，different section headings，now this seems
    to be an advantage in。some ways that maybe we can be more，efficient，about how
    we run our single page。applications like this one thing，we seem to lose though
    is the notion of，maintaining state。inside of the url that generally the url，gives
    you an indication for what page。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这些不同的部分标题之间切换时，这在某些方面似乎是一种优势，也许我们可以更高效地运行这样的单页应用。但是，我们似乎失去了在 URL 中保持状态的概念，通常
    URL 会给你指示当前页面的信息。
- en: you're on you're on something like，slash one if you're on section one or。slash
    two if you're on section 2，3 for section 3 but of course we're。staying on the
    same page in all of these，examples whenever i click a button，section 1 or 2 or
    3。the url is never changing the url stays，the same，it turns out there's a way
    in javascript。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第一部分，你的 URL 是 `/1`，如果你在第二部分，URL 是 `/2`，第三部分是 `/3`，但当然在所有这些示例中，我们都停留在同一页面，每当我点击一个按钮，无论是第一、第二还是第三部分，URL
    永远不会改变，URL 始终保持不变，结果是 JavaScript 中有一种方法。
- en: to manipulate that url，taking advantage of what's known as the，javascript history
    api。where i can push something to the，history meaning，update the url and actually
    save that。inside the user's browser history，so later on they could potentially
    go，back to that。and to do that i'll show you yet another，example inside，of single
    page two which is very similar。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以更新 URL 的方式操控该 URL，利用所谓的 JavaScript 历史 API，我可以将某些内容推送到历史中，这意味着更新 URL 并实际将其保存到用户的浏览器历史中，这样用户稍后可以潜在地返回到那个位置。为此，我将在类似的单页应用中展示另一个例子。
- en: except inside of index。html i've added a，couple additional things。one is that
    when i click on a button，meaning when i click on section one or。section two or
    section three，i've added this line here history。push，state，what history。push date
    is going to do is，it is going to，basically add a new element to my，browsing history。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `index.html` 内部，我还添加了一些额外的东西。一个是当我点击一个按钮时，也就是说当我点击第一部分、第二部分或第三部分时，我在这里添加了这一行
    `history.pushState`，`history.pushState` 的作用是，基本上会向我的浏览历史中添加一个新元素。
- en: where i first specify any data，associated with the state so in，particular。i'm
    storing a javascript object，representing what section number，is being represented
    here next is a。title parameter that most web browsers，actually ignore so that
    can generally be，the empty string。but the third argument here is what，should go
    in the url，and what i want to go in the url in this。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先指定任何与状态相关的数据，特别是。我存储了一个表示这里所表示的部分编号的javascript对象，下一个是一个标题参数，大多数网页浏览器实际上会忽略，因此通常可以是空字符串。但这里的第三个参数是应该放在url中的内容，我希望放在这个url中。
- en: case is something like section，followed by the section number so i can，two。or
    slash section three for instance and，those will appear，in the url bar when i click
    on a。different page，then what i want to be able to support，is the ability to say
    when i go back。through my history if i click the back，button in my web browser。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 情况是类似于部分，后跟部分编号，例如我可以输入二。或斜杠部分三，例如，当我点击不同的页面时，这些内容将出现在url栏中，然后我希望能够支持的是，当我回顾我的历史时，如果我在网页浏览器中点击后退按钮。
- en: i'd like to go back from section 3 to，section 2，if that was the page i visited。previously
    and there turns out to be an，event handler for that as well，window。onpopstate
    meaning when i pop，something off of the history like go，back in my history。we
    have the ability to take some event，as an argument and if you look at，event。state。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我是之前访问的页面，我想从第3部分返回到第2部分。而且确实有一个事件处理程序，window.onpopstate，这意味着当我从历史记录中弹出某个内容时，比如返回我的历史记录。我们可以将一些事件作为参数，如果你查看事件.state。
- en: section which i've run，console。log on so we can take a look at，it in a moment。we'll
    see what state was stored。![](img/6bd7990afce68466d7cd024987b3bfe2_35.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我在控制台上运行的部分。日志记录，以便我们可以在稍后查看它。我们将看到存储的状态。![](img/6bd7990afce68466d7cd024987b3bfe2_35.png)
- en: associated with that part of the user's，history，and i can go ahead and show
    that section。so all in all when i run this web，application。![](img/6bd7990afce68466d7cd024987b3bfe2_37.png)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户历史的那部分相关联，我可以继续显示该部分。因此，总的来说，当我运行这个网页应用时。![](img/6bd7990afce68466d7cd024987b3bfe2_37.png)
- en: i see hello three sections for buttons，when i click on one of those buttons。not
    only do i see text but i also see in，the url bar，that i'm now on slash section
    one that。has been pushed onto my history，and i've updated the url to reflect that，too
    i click section two。that updates the url as well section，three updates the url
    too，and when i've pushed things onto my。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到三个部分的按钮，当我点击其中一个按钮时。我不仅看到文本，而且在url栏中也看到我现在在斜杠部分一，这已经被推入我的历史中，我也更新了url以反映这一点。我点击第二部分，更新了url，第三部分也更新了url，当我将内容推入我的部分时。
- en: them，so that i can go back if i ever need to，and in fact if i open up the javascript，console
    now。and i go back for example back to。![](img/6bd7990afce68466d7cd024987b3bfe2_39.png)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我就可以在需要时返回，事实上，如果我现在打开javascript控制台。如果我返回，例如返回到。![](img/6bd7990afce68466d7cd024987b3bfe2_39.png)
- en: section two what you'll see，is that what gets logged is the number。two when
    i print out like what is the，current section that's associated with，this url。it's
    saving that state that i should be，loading section number two。and so it does load
    section number two，here，so there's certainly nothing wrong with。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分你会看到的是记录的内容是数字。二当我打印出当前与这个url相关的部分时。它保存了我应该加载第二部分的状态。因此，它确实加载了第二部分，这里当然没有任何问题。
- en: the original paradigm of just，loading different pages dynamically。using django
    like make a request and get，a response，but oftentimes as you begin to imagine。applications
    where a lot of things are，changing on the same page simultaneously。you might imagine
    social networking，websites where a lot of things stay the，you might be。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 原始范式是仅仅动态加载不同的页面。使用django进行请求并获取响应，但通常当你开始想象许多内容在同一页面上同时变化的应用程序时。你可能会想象社交网络网站，其中许多内容保持不变，你可能会。
- en: looking at different parts of the same，page being able to dynamically load。information
    request additional，information，and then display it on the page can。actually be
    quite powerful a way to make，your web pages，a little bit more interactive so that。then
    is how we might build，single page applications taking，advantage of javascript
    to。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 查看同一页面的不同部分，能够动态加载信息，请求额外的信息，然后在页面上显示，这实际上可以是一种非常强大的方式，使你的网页更加互动。因此，这就是我们可能构建单页应用程序的方式，利用javascript来。
- en: asynchronously load，new data and then taking advantage of，this history api。that
    let us add things to the url add，things to the user's browsing history。such that
    we could go back to them later，by listening for window。onpopstate。and it turns
    out that window object that，we get access to in javascript。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 异步加载新数据，然后利用这个历史 API，让我们可以向 URL 添加内容，增加用户的浏览历史，以便我们可以稍后通过监听窗口的 `onpopstate`
    事件回到它们。而且，事实证明，在 JavaScript 中我们访问到的窗口对象。
- en: is quite powerful it represents the，physical window on the computer screen。that
    displays all of their web content，and there are certain properties of that。window
    we can look at，that allow us to enable some interesting。features so for example
    your window is，really described by what the user。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 功能非常强大，它表示计算机屏幕上显示所有网页内容的物理窗口，还有一些窗口的属性可以查看，这使我们能够启用一些有趣的功能。例如，窗口的高度确实由用户的。
- en: actually sees inside of their，window in google chrome or safari or。whatever
    web browser they happen to be，using，and there are a couple of properties。that
    might be of use something like，window。inner with，will represent how wide is the
    window，like。the size of the user's screen for，example to know how many pixels
    wide。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上看到的是他们在 Google Chrome、Safari 或任何他们使用的网页浏览器中的窗口，还有一些可能有用的属性，比如 `window.innerWidth`，它表示窗口的宽度，比如用户屏幕的大小，以了解窗口的宽度是多少像素。
- en: the window happens to be and just as，there's a window。inner width there's，also
    a window。inner height。that represents the height of the window，as well，now window
    represents the physical part。that they're actually seeing，we've also seen another
    variable that。javascript gives us access to and that，is this document，object so
    what is the difference between。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的内宽就像有一个 `window.innerHeight`，它表示窗口的高度。现在窗口表示的是他们实际上看到的物理部分，我们还看到另一个变量，JavaScript
    让我们访问的，就是这个文档对象。那么它们之间有什么区别呢？
- en: the window and the document，well the document generally represents，the entire
    web page。but if web pages are long oftentimes the，web page doesn't fit entirely
    inside of。the window that you generally have to，scroll，through an entire web page
    and the。window is only showing you one portion，of that page in any given time
    so you。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口和文档，文档通常代表整个网页。但是如果网页很长，网页可能不会完全适合窗口，你通常需要滚动整个网页，窗口在任何给定时刻只显示页面的一部分。
- en: can represent the document，as like this big vertical section that。goes beyond
    the window there might be，part of the document that is above the，window。part of
    the document that is below the，window as well，so window。scroll y is another variable。you
    have access to on the window，and window。scrolly represents how many。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以表示文档，像是这个大垂直部分，超出了窗口，文档中可能有一部分在窗口上方，还有一部分在窗口下方，所以 `window.scrollY` 是你可以访问的另一个变量，`window.scrolly`
    表示滚动了多少。
- en: pixels far down have you scrolled，so if you're at the top of the page，window。scrolly
    is zero you haven't，scrolled at all，but as you begin to scroll if you want。to
    know how far the user has scrolled on，a page，you can look at window。scrolly to
    figure。out the number of pixels the user has，scrolled，in the y direction the up
    and down，direction。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动了多少像素，所以如果你在页面顶部，`window.scrolly` 为零，你根本没有滚动，但当你开始滚动时，如果你想知道用户在页面上滚动了多少，你可以查看
    `window.scrolly` 来计算用户在 y 方向上滚动的像素数量。
- en: and the entire height of the page is，represented in，document。body。offset height
    that，represents。how tall the entire height of the，document is and we talk about
    all this。in addition to things like window。inner，height and window。inner with。because
    using all of these values，together you can begin to do some，interesting calculations。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 整个页面的高度在 `document.body.offsetHeight` 中表示，表示文档的整体高度，我们谈论所有这些内容，此外还有 `window.innerHeight`
    和 `window.innerWidth` 等，因为结合使用所有这些值，你可以开始进行一些有趣的计算。
- en: so one thing you might want to detect，for example is，has the user scroll down
    to the bottom。of the page or not，that might be something you care about，knowing
    and it turns out there isn't an。event listener that does this，automatically，but
    we can calculate it in order to try。and figure this out if，inner height is the
    height of the window，scroll y。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能想检测的一件事情，例如，用户是否滚动到页面底部，这可能是你想知道的事情，结果是没有自动执行这个的事件监听器，但我们可以计算来尝试弄清楚，如果
    `innerHeight` 是窗口的高度，而 `scrollY`。
- en: is how far vertically the user has，scrolled and document body offset height。is
    the entire height of the document you，can ask yourself，what needs to be true if
    the user has。scrolled to the bottom of the page，and well if the user is scrolled
    to the。bottom of the page well then，scroll y plus the inner height meaning，the
    amount they've scrolled。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户垂直滚动的距离，而 `document.body.offsetHeight` 是文档的整个高度。你可以问自己，如果用户滚动到页面底部，什么情况需要为真？如果用户已滚动到底部，那么
    `scrollY` 加上 `innerHeight`（也就是他们已滚动的量）。
- en: plus the height of the window that must，be at least or equal to。document body
    offset height meaning the，amount that they scrolled plus the，window。takes you
    down to the bottom of the page，to the end of the page。to however tall the document
    happens to，be and using that mathematical，comparison，reached。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 加上窗口的高度，必须至少等于 `document.body.offsetHeight`，也就是说已滚动的量加上窗口的高度，将你带到页面底部，直到文档的高度，利用这个数学比较。
- en: the bottom of the page and we can，actually try and now put that into，practice。so
    i'll go ahead and open up an example，that i have here，called scroll。html and all
    scroll。html。has right now，is 100 paragraphs inside of the body tag，i have a p。for
    paragraph paragraph one paragraph，two so on and so forth。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 页面底部，我们实际上可以尝试将其付诸实践。所以我将打开一个示例，叫做 `scroll.html`，现在 `scroll.html` 中只有 100 个段落，位于
    body 标签内，我有一个 p 标签，表示段落一、段落二，以此类推。
- en: i have 100 paragraphs inside of the body，of this html page and that's all that。![](img/6bd7990afce68466d7cd024987b3bfe2_41.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个 HTML 页面的 body 内有 100 个段落，这就是全部内容。![](img/6bd7990afce68466d7cd024987b3bfe2_41.png)
- en: really is there right now。![](img/6bd7990afce68466d7cd024987b3bfe2_43.png)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真的在这里。![](img/6bd7990afce68466d7cd024987b3bfe2_43.png)
- en: such that now if i go ahead and open，scroll。html i see，that i have 100 paragraphs
    that i can。scroll through，and what i might like to do is detect，when i've reached
    the bottom of the page。and maybe do something when i do so，something like change
    the color of the。![](img/6bd7990afce68466d7cd024987b3bfe2_45.png)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果我打开 `scroll.html`，我看到有 100 个段落可以滚动，而我想做的就是检测我何时到达页面底部，或许在那时做点什么，比如改变颜色。![](img/6bd7990afce68466d7cd024987b3bfe2_45.png)
- en: page for instance，so how might i go about doing that well，i'm going to need
    some javascript so i'm。going to add some javascript，and i'll add an event listener
    for，window dot on。scroll on scrolling is an event that，listens，for what i'm scrolling
    through the。window and when i scroll through the，window，we'll go ahead and run
    this function。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我该如何做到这一点呢？我将需要一些 JavaScript，因此我将添加一些 JavaScript，并为 `window.onscroll` 添加一个事件监听器。滚动是一个监听我在窗口中滚动的事件，当我在窗口中滚动时，我们将运行这个函数。
- en: i'll just use an arrow function as a，shorthand here，what do i want to calculate
    well i want。to calculate if window dot，inner height meaning the height of the，window
    itself，plus window。scroll y meaning the amount，that i've scrolled，if that is at
    least document。body。offset，height。well that means i must have scrolled to，the
    bottom of the page or maybe even a。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用箭头函数作为简写，我想计算什么呢？我想计算如果 `window.innerHeight`（窗口本身的高度）加上 `window.scrollY`（我已滚动的量）是否至少等于
    `document.body.offsetHeight`。如果是，那么我必须已经滚动到页面底部，或者可能更远。
- en: little bit further if there's a little，wiggle room to scroll past the end of，the
    page。so if this is true well then i've，reached the end of the page，and then we'll
    go ahead and say。document。query selector，body and let's go ahead and change its，style
    in particular change its。background color，and change the background color to green，otherwise
    if we haven't reached the end。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一点点余地可以滚动到页面底部，那么如果这是真的，我就已经到达页面底部。接着我们会执行 `document.querySelector`，选择 body，并改变它的样式，特别是改变它的背景颜色，改为绿色，否则如果我们还没有到达底部。
- en: of the page，and change its background color to white，so what we're now doing
    here is taking。advantage of the properties we know，of this window object saying
    when we。scroll the window let's check to see，if we add this up and at least the。height
    of the entire document，we've reached the end of the page go，ahead and change the
    style of the。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 页面，并将其背景颜色改为白色。因此我们现在做的事情是利用我们对窗口对象的了解，说明当我们滚动窗口时，检查加起来是否至少等于整个文档的高度，如果到达了页面底部，就改变页面的样式。
- en: background to the body accordingly，otherwise change the background to white。or
    leave it at white if it already is，so now if i take a look at this actual。![](img/6bd7990afce68466d7cd024987b3bfe2_47.png)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况更改背景为主体，否则将背景更改为白色，如果它已经是白色的话，所以现在如果我看看这个实际的。
- en: html page and reload scroll。html，we'll see that the background is。initially
    white but as i scroll down，once i reach the bottom we'll see that。the page changes
    to green。![](img/6bd7990afce68466d7cd024987b3bfe2_49.png)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面重新加载scroll.html，我们将看到背景最初是白色，但当我向下滚动，直到我到达底部时，页面将变成绿色。
- en: it's white before i reach the bottom but，as soon as i get to the bottom of the，page。![](img/6bd7990afce68466d7cd024987b3bfe2_51.png)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我到达底部之前是白色，但一旦我到达页面底部。
- en: it turns to green and the reason why is，because the height of the window。height
    of the window here plus however，much i've already scrolled from the top。of the
    page up until now，that together is equal to the entire，height of the document。which
    means we're able to detect the，fact that i've reached the end of the。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它变成绿色，原因是窗口的高度，加上我从页面顶部滚动到现在的高度，这两者之和等于文档的整个高度。这意味着我们能够检测到我已经到达页面的底部。
- en: page and as a result we can change the，color of the background，to green now
    this in itself is not a。particularly，practical use of detecting when we，scroll
    to the end of something we。probably don't usually care about，changing the background
    color when you。reach the end of the page but there，actually are real applications
    and you，might imagine this。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们可以将背景颜色更改为绿色。现在这本身并不是一个特别实用的用途，因为我们通常并不关心在到达页面底部时更改背景颜色，但实际上是有真实的应用场景，你可能会想象到。
- en: in the context of websites that allow，for things like infinite scroll that if。you're
    on a social networking site that，has a whole bunch of posts。you scroll to the
    bottom of the list of，posts and then it generates the new。set of posts as well
    or you're looking，at news articles and you're scrolling，through news articles。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许无限滚动的网站的背景下，如果你在一个社交网站上，有很多帖子，你滚动到帖子列表的底部，然后它会生成一组新的帖子，或者你在查看新闻文章时滚动浏览新闻文章。
- en: and once you reach the bottom it'll load，a whole new set of news articles。without
    you having to go to another page，how is it doing that，well it's a combination
    of the same。about，number one the ability to detect when，you've reached the end
    of the page using。javascript to detect that you're，at the bottom of the page and
    number two。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你到达底部，它会加载一整套新的新闻文章，而无需你去另一个页面，它是如何做到的呢？这结合了两个要素，首先是使用JavaScript检测你已到达页面底部的能力，第二。
- en: to be able to asynchronously，load using javascript load additional。content fetch
    some additional page，that has some additional content some。additional news articles
    some additional，posts and whatnot，and then take that information and。manipulate
    the dom，to add that information to the existing，web page。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 能够异步加载内容，使用JavaScript加载额外的内容，获取一些有附加内容的页面，一些额外的新闻文章、帖子等等，然后利用这些信息来操作DOM，将这些信息添加到现有网页上。
- en: and that ultimately is what's going to，give us this power，to be able to support
    something like。infinite scroll，so let's now go ahead and try and see，what it would
    look like。to implement infinite scroll i've，already started to create a sample，application。inside
    of this application called scroll，and i've got an app called posts inside，of it。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终赋予我们支持无限滚动的能力，所以现在我们来尝试一下实现无限滚动的样子。我已经开始创建一个名为scroll的示例应用，在这个应用中有一个名为posts的应用。
- en: and what the posts app does is it's got，a couple of urls，it's got a default
    url that just loads。an index row and then a post route，that loads this posts view
    and so let's，look at what these do。index all it does is going to load a，file called
    index。html this template。and if i make a request to slash posts i，need to provide
    two arguments。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子应用的功能是，它有几个网址，它有一个默认网址，可以加载一个索引行，然后是一个帖子路由，加载这个帖子视图，所以让我们来看看这些是做什么的。索引的作用就是加载一个名为index.html的文件，这个模板。如果我向/posts发送请求，我需要提供两个参数。
- en: i need to provide a start for what post，i want to start with，an end for what
    post i want to end with。and then it's just going to generate，some sample posts
    that just say like。post number one post number two，so on and so forth in practice
    you could。![](img/6bd7990afce68466d7cd024987b3bfe2_53.png)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要提供一个开始的帖子编号和一个结束的帖子编号，然后它将生成一些示例帖子，比如帖子编号一、帖子编号二，依此类推。在实际操作中你可以。
- en: actually use social network posts，in place of this but this is good just，for
    demonstration purposes。so what this is going to do if i go into。![](img/6bd7990afce68466d7cd024987b3bfe2_55.png)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以使用社交网络帖子来代替这个，但这只是为了演示目的。那么，如果我进入这个。
- en: is that if i go to slash post and say，start equals 1，and end equals 10 for example。then
    i get a javascript object that，looks like this recall that a javascript。object
    is just a convenient format，for passing information back and forth，in json format。and
    what we have here is a json object，with a key called posts，that gives me all of
    the posts post。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我访问/posts并说开始等于1，结束等于10，比如这样，我会得到一个看起来像这样的javascript对象。回想一下，javascript对象只是一个方便的格式，用于在json格式中来回传递信息。我们这里有一个json对象，带有一个名为posts的键，给了我所有的帖子。
- en: number one post number two all the way，up to number ten，and it's giving me those
    posts because i。said start at one end at ten but i could，have specified，other
    numbers as well if i had said。something like uh start at，20 and go to 28 then
    it's going to give。![](img/6bd7990afce68466d7cd024987b3bfe2_57.png)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一帖子到第二帖子，一直到第十个帖子，它给了我这些帖子，因为我说从一开始，到十结束，但如果我说什么，比如从20开始到28结束，它会给我。
- en: me post number 20，through post number 28。i can specify，the range of posts that
    i want。so this now is an api that i have，implemented effectively，that allows someone
    to get access to a。variety of different posts，by hitting this particular url this，endpoint
    so to speak。and passing in parameters passing in，what posts they want to start
    with。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以指定我想要的帖子范围，从帖子编号20到帖子编号28。所以现在这是一个我有效实施的api，允许某人通过访问这个特定的url，传递参数，获取多种不同的帖子，从哪个帖子开始。
- en: and what posts they want to end with and，then they get all of this data。back
    presented to them in json format，that can then be used，and what's nice about this
    is that now。when we're loading posts，rather than have to just guess at how，many
    posts we need to load and then。require someone to go to another page，we can just
    do something like load the，first 20 posts。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 他们希望以什么帖子结束，然后他们将所有这些数据以json格式返回给他们，而这点非常好。现在，当我们加载帖子时，不必仅仅猜测需要加载多少个帖子，然后要求某人去另一个页面，我们可以直接加载前20个帖子。
- en: and now what we'd like to do is if they，reach the end of the page。go ahead and
    load the next 20 posts by，hitting this api endpoint，getting the next 20 posts
    and then。filling that in，into the html page so let's see now how，that actually
    works。in practice by taking a look at that，template in，index。html so go into templates，index。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想做的是，如果他们到达页面底部，继续通过访问这个api端点来加载接下来的20个帖子，获取接下来的20个帖子，然后将其填充到html页面中。让我们看看在实际操作中这是如何工作的，看看index.html中的模板。
- en: html and there's a fair bit of，javascript here，but look at the body first the
    body just。have a has a div for all the posts，that initially is going to be empty
    now。here's what the javascript is going to，do and we'll，walk through it we start
    with the first。post so counter is going to keep track，of what post we need to
    load next by。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: html中有相当多的javascript，但首先看一下主体。主体中有一个用于所有帖子的div，最初将是空的。接下来，javascript将如何执行，我们将逐步解析它。我们从第一帖子开始，所以计数器将跟踪我们需要加载的下一个帖子。
- en: default we're just going to start by，loading post number one，we have a variable
    called quantity。that's going to tell us how many posts，are we going to load at
    a time let's。just say load 20 posts at a time so，start with 1 to 20，then 21 to
    40 41 to 60 so on and so，forth。and when dom content is loaded go ahead，and just
    call this function。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将从加载帖子编号一开始，我们有一个变量叫做数量，它将告诉我们每次要加载多少个帖子。我们就说每次加载20个帖子，所以从1到20，然后21到40，41到60，依此类推。当dom内容加载完成时，就调用这个函数。
- en: that's called load and what the load，function does is it figures out what the。start
    and end should be，it fetches all the new posts uh and then。for each of the posts
    that comes back，we is it figures out what the so we're。asynchronously asking for
    new posts，and what the ad post function does is it。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为加载，而加载函数的作用是确定开始和结束应该是什么，它获取所有新的帖子，然后对于每个返回的帖子，我们异步请求新帖子，而添加帖子函数则负责。
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_59.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_59.png)'
- en: creates a new div，populates the post inside of it and adds，it to the dom。so
    now that we have these parts the，ability to load new posts as by fetching，about。and
    then for each of those posts that，comes back add something new to the dom。as by
    creating a new html element and，inserting it into the page。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的div，填充其中的帖子并将其添加到dom中。因此，现在我们有了这些部分，能够通过获取来加载新帖子。
- en: we have the ability to dynamically load，all of these posts，so if i go not to
    slash posts but just。to this default route，i'll see that we have something like，20
    posts that all show up but just 20。posts。![](img/6bd7990afce68466d7cd024987b3bfe2_61.png)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够动态加载所有这些帖子，所以如果我不去斜杠帖子而只是去这个默认路由，我会看到大约20个帖子全都显示出来，但只有20个帖子。![](img/6bd7990afce68466d7cd024987b3bfe2_61.png)
- en: because every time i call the load，function。![](img/6bd7990afce68466d7cd024987b3bfe2_63.png)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每次我调用加载函数时。![](img/6bd7990afce68466d7cd024987b3bfe2_63.png)
- en: that is going to load the next set of，posts for example，and so what i can do
    is in the console。if i try running，the load function just by calling it，myself
    press return。after a second or so the next set of，posts show up 21，all the way
    through 40。i call load。again the next set of posts show up，41 through 60。 20 posts
    at a time。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载下一组帖子，例如，我可以在控制台中，如果我试着通过自己调用加载函数，按回车，过了一秒钟左右，下一组帖子出现了21，一直到40。我再调用加载，下一组帖子出现了41到60，每次20个帖子。
- en: all using that asynchronous javascript，but now what i'd like to happen。![](img/6bd7990afce68466d7cd024987b3bfe2_65.png)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 全部使用异步JavaScript，但现在我想要发生的事情。![](img/6bd7990afce68466d7cd024987b3bfe2_65.png)
- en: is for all this to happen on its own，without me having to intervene and。manually
    write javascript calls，i would just like to say well the same，type of logic as
    before。window done on scroll let's go ahead and，say，if window。inner height plus，window。scroll。y
    is at leastdocument。body。offset height，meaning if i have scrolled to the end of，the
    page。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这一切都能自行发生，而不需要我干预和手动编写JavaScript调用，我只想说与之前相同的逻辑。窗口在滚动时，让我们说，如果窗口的内高度加上窗口的滚动y至少是文档的主体偏移高度，意味着我已经滚动到了页面的底部。
- en: we'll then just go ahead and call the，load function，that's all these lines are
    doing every。time i scroll we check did we scroll to，the end of the page，and if
    we did scroll to the end of the。page then go ahead and load。![](img/6bd7990afce68466d7cd024987b3bfe2_67.png)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就继续调用加载函数，这些行每次我滚动时都在做的就是检查我们是否滚动到页面底部，如果是，那就去加载。![](img/6bd7990afce68466d7cd024987b3bfe2_67.png)
- en: the next set of posts so now，i refresh the page i see post 1，all the way up
    through post 20。now。watch what happens when i get to post 20，if i scroll to the
    bottom。after a second the next set of posts，appears i scroll to the bottom again
    i'm，at 40。and then after a second the next set，bottom。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组帖子，现在我刷新页面时看到帖子1，一直到帖子20。现在，当我到达帖子20时，注意发生了什么，如果我滚动到底部，过了一秒钟，下一组帖子出现了，我再滚动到底部，我已经到了40。然后过了一秒钟，下一组再次出现。
- en: '![](img/6bd7990afce68466d7cd024987b3bfe2_69.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7990afce68466d7cd024987b3bfe2_69.png)'
- en: more posts are going to load after that，allowing me to effectively implement，this
    idea。of infinite scrolling by taking，advantage of some javascript techniques，where
    i can check。for when i've got to the end of the page，and then dynamically do something
    as a，result of that。something like load some additional，pages onto the screen，and
    so here too a lot of power to be had。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更多帖子将在之后加载，使我能够有效地实现无限滚动的想法，通过利用一些JavaScript技术，在我到达页面底部时检查，然后动态执行某些操作，比如加载额外的页面到屏幕上，这里也有很多的力量。
- en: inside of javascript，and a lot of where the power of user，that the。user interface
    interacts with the user，do，and how the page should interact as a。result something
    like user scrolls to，the end of the page。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript内部，用户界面与用户的互动以及页面如何互动，这里有很多力量，类似于用户滚动到页面底部。
