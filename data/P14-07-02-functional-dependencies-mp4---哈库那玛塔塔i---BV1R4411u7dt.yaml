- en: P14：07-02-functional-dependencies.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P14：07-02-功能依赖.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: This video covers functional dependencies。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本视频涵盖了功能依赖。
- en: '![](img/da741dc1bf43bb59db32d73201d5416a_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da741dc1bf43bb59db32d73201d5416a_1.png)'
- en: First， a quick recap of relational design by decomposition。 The idea is that
    the application designer， writes mega-relations that contain all the information。
    that we want to have and properties of the data that we're storing。 and then the
    system will automatically decompose those， based on the properties that are specified。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，快速回顾一下通过分解进行关系设计的概念。这个思想是，应用设计师编写包含所有信息的超级关系，包含我们要存储的数据的所有属性，然后系统会根据指定的属性自动对这些关系进行分解。
- en: The final set of decomposed relations will satisfy what's called， the normal
    form。 and normal forms are good relations， in the sense that they have no anomalies
    and they don't lose information。 from what was specified in the original mega-relations。
    Now。 the properties themselves are defined either as functional dependencies。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的分解关系集将满足所谓的**范式**，范式是良好的关系，意味着它们没有异常，也不会丢失原始大关系中指定的信息。现在，这些属性本身是通过功能依赖来定义的。
- en: in which case the system will generate Boyce-Cud-normal form relations。 or multi-valued
    dependencies， which we will then yield， fourth normal form relations。 So this
    video。 as you can tell， is about functional dependencies themselves。 And let me
    say that functional dependencies are actually a generally useful concept。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，系统将生成Boyce-Codd范式关系，或者多值依赖，进而产生第四范式关系。所以，如你所见，本视频是关于功能依赖的。让我说，功能依赖实际上是一个非常有用的概念。
- en: '![](img/da741dc1bf43bb59db32d73201d5416a_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da741dc1bf43bb59db32d73201d5416a_3.png)'
- en: in databases， not only for relational design。 So， for functional dependencies，
    as we'll see soon。 are a generalization of the notion of keys， and they allow
    the system to， for example。 store the data more efficiently， when the system knows
    about functional dependencies。 Compression schemes can be used based on functional
    dependencies for storage。 And also。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，不仅仅是关系设计，功能依赖也有广泛的应用。对于功能依赖，正如我们很快就会看到的，它是键概念的推广，它允许系统例如在系统了解功能依赖的情况下，更高效地存储数据。基于功能依赖的压缩方案可以用于存储。并且还有其他的用途。
- en: functional dependencies， as a generalization of keys。 can be used to reason
    about queries and for query optimization， which， as a reminder。 is a very important
    aspect of database systems， which allows declarative queries to be executed。 by
    the system efficiently。 By the way， a third use of functional dependencies is
    for exam questions。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 功能依赖，作为键的推广，可以用来推理查询和进行查询优化，提醒一下，这是数据库系统中一个非常重要的方面，它允许系统高效地执行声明式查询。顺便提一下，功能依赖的第三个用途是用于考试题目。
- en: in database courses， because there's a very nice theory of functional dependencies，
    as you'll see。 and it's quite easy to write questions about them。 So the remainder
    of the video will cover functional dependencies in general， as a general concept。
    and not specifically to relational design， and then later videos will tie functional
    dependencies back to design by decomposition。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库课程中，因为功能依赖有非常好的理论，如你将看到的那样，它也相对容易编写相关问题。因此，本视频的其余部分将涵盖功能依赖作为一个通用概念，而不仅仅是关系设计相关内容，之后的视频将把功能依赖与分解设计联系起来。
- en: As always， we'll be using， as a sample， a college application database， and
    in this case。 I've expanded the information that we're including quite a bit。
    We'll be using these same two relations as examples throughout this video。 and
    subsequent videos on relational design。 In this case， we're going to look at two
    relations。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将使用一个大学申请数据库作为示例，在这个案例中，我扩展了我们要包含的信息量。我们将在本视频以及后续的关系设计视频中，使用这两个关系作为示例。在这个例子中，我们将查看两个关系。
- en: one with information about students， and then a separate one with information
    about where they're applying。 The student information will have a social security
    number， the student's name， their address。 and then three attributes about their
    high school。 We'll assume there's unique codes for high schools。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含学生信息，另一个包含他们申请的学校信息。学生信息将包括社会保障号码、学生姓名、住址，和三项关于他们高中的属性。我们假设每个高中都有唯一的代码。
- en: but then they also have a name and are in a city。 Finally。 the student's GPA
    and a priority field for admissions that we'll see in a moment。 For applications。
    we'll have the student's social security number， the college name they're applying
    to。 the state of the college， the date of application， and the major。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们也有名字，并且在一个城市里。最后，学生的GPA和稍后我们会看到的招生优先级字段。对于申请，我们将有学生的社会安全号码，申请的大学名称，大学所在州，申请日期和专业。
- en: Not all of these attributes will even be used in this video， but like I said。
    this will permeate several videos as our running example。 To motivate functional
    dependencies。 let's focus on the student relation， and specifically on the GPA
    and priority attributes。 Let's suppose that a student's priority is determined
    by their GPA。 For example。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有这些属性都会在这个视频中使用，但正如我所说，这个例子将在多个视频中贯穿始终。为了说明功能依赖的概念，让我们集中讨论学生关系，特别是GPA和优先级这两个属性。假设学生的优先级由他们的GPA决定。例如。
- en: we might have a rule that says if GPA is 3。8， greater than 3。8， then priority
    is one。 If the GPA is。 say， in between， let's say， 3。3 and 3。8， then we'll set
    priority to be equal to。 and let's say if the GPA then is less than 3。3， then
    the priority value is three。 So this relationship is guaranteed in our data， then
    what we can say is that any two。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会有一个规则，表示如果GPA大于3.8，那么优先级为1。如果GPA在3.3和3.8之间，那么我们将优先级设为2。如果GPA小于3.3，那么优先级值为3。所以如果这个关系在我们的数据中是被保证的，那么我们可以说，任何两个。
- en: tuples that have the same priority are guaranteed to have the same GPA。 and
    let's formalize that concept。 So I'm going to write a little logical statement
    here to formalize the concept。 I'm going to use that for all symbol from predicate
    logic。 and I'm going to say if we have any pair of， tuples， so for all t or u，
    those are tuples。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同优先级的元组一定会有相同的GPA。让我们来形式化这个概念。所以我要写一个小的逻辑表达式来形式化这个概念。我会使用谓词逻辑中的全称符号，并且我要说，如果我们有任意一对元组，那么对于所有的t和u，这些都是元组。
- en: in the student relation， then if the student， if the t and u have the same priority，
    so I'll say。 I'm sorry， the same， let me fix that， they have the same GPA， so
    if t。gpa equals u。gpa， then。 and this is the logical implication symbol， then
    t。priority will equal u。priority。 So this logical statement is in fact the definition
    of a functional dependency。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在学生关系中，如果学生t和u具有相同的优先级，我会说，抱歉，应该是相同的GPA。如果t.gpa等于u.gpa，那么这就是逻辑蕴含符号，t.priority就等于u.priority。所以这个逻辑表达式实际上就是功能依赖的定义。
- en: and we would write that functional dependency as gpa arrow priority。 So that
    says the GPA determines the priority， or any two tuples with the same GPA must
    have the same priority。 So that was a specific example。 Now let's generalize our
    definition。 So let me replace gpa in priority here with just two attributes A
    and B of， say， a relation R。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会把这个功能依赖写作gpa箭头priority。所以这意味着GPA决定了优先级，或者说任何两个具有相同GPA的元组必须有相同的优先级。这个是一个具体的例子。现在让我们来概括我们的定义。把这里的gpa和priority替换成两个属性A和B，假设它们属于关系R。
- en: And then we'll also need to modify our definition。 So you can see I've erased
    the specific attributes and relation。 and I'll just say for every t and u in our
    relation R， if t。a equals u。a， then t。b equals u。b。 and that's the definition
    of the functional dependency A determines B for a relation R。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们还需要修改我们的定义。所以你可以看到我已经删除了具体的属性和关系。现在我只说，在我们的关系R中，对于每一对t和u，如果t.a等于u.a，那么t.b就等于u.b。这就是关系R中功能依赖“A决定B”的定义。
- en: Actually I'm going to generalize this definition even further because functional
    dependencies don't always have to have one attribute on each side。 they can actually
    have a set of attributes。 So now I write A1， A2， dot， dot， dot。 An on the left-hand
    side。 These will all be attributes of relation R， and on the right-hand side B1。
    B2， comma， Bm， again attributes of R。 Modifying the formal definition in red。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我将进一步概括这个定义，因为功能依赖不一定每一边都有一个属性。它们实际上可以有一组属性。所以现在我把左边写成A1，A2，点点点，An。这些都是关系R中的属性，而右边则是B1，B2，逗号，Bm，依然是R中的属性。修改后的正式定义如下图所示。
- en: now I can't use the dot notation anymore。 So I'll use a square bracket。 and
    I'll write A1 through An equals u square bracket A1 through An。 So what I'm saying
    here in this case is that the two tuples， t and u。 have the same values for all
    of the attributes A1 through An。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我不能再使用点符号了。所以我将使用方括号，并写A1到An等于方括号A1到An。我在这里想表达的是，在这种情况下，两个元组t和u对于所有属性A1到An的值是相同的。
- en: and if they do then they will also have the same values for B1 through Bm。 We'll
    be getting to some concrete examples soon。 Just one last bit of notation before
    we move on。 For simplicity I'm going to often in the video abbreviate a list of
    attributes or set of attributes by using a bar。 So I'll write A bar to indicate
    a set of attributes A and B bar to indicate a set of attributes B。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们确实相等，那么它们对于B1到Bm的值也将相同。我们很快就会看到一些具体的例子。在继续之前，最后一点符号约定。为了简便起见，我在视频中会经常使用竖线来缩写一组属性或属性集。所以，我会写A
    bar来表示属性集A，B bar来表示属性集B。
- en: And again this is just for convenience。 So we've seen the motivation for a functional
    dependency in a relation。 A functional dependency for a relation is based on knowledge
    of the real world data that's being captured。 And when we specify one， just like
    specifying keys。 all instances of the relation must adhere to the functional dependency。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这仅仅是为了方便。我们已经看到了关系中函数依赖的动机。一个关系的函数依赖是基于对现实世界数据的理解。当我们指定一个依赖关系时，就像指定键一样，关系中的所有实例都必须遵守这个函数依赖。
- en: So just to summarize functional dependencies we say that a set of attributes
    A functionally determines a set of attributes B。 If again any time tuples agree
    in their A values they also agree in their B values。 And let's say that our relation
    here R has the tuples in A。 the tuples in B and also a few more attributes we'll
    call those C。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下函数依赖关系：我们说一组属性A函数性地决定一组属性B。也就是说，每当元组在其A值上相等时，它们的B值也会相等。假设我们的关系R包含A中的元组，B中的元组，还有一些其他的属性，我们称它们为C。
- en: So let me draw a picture of a relation now here that has those attributes in
    it。 So we'll have here。 let's just three columns but again these are multiple
    attributes。 And these are the attributes A。 these are the attributes B and these
    are the attributes C。 And if we put in a couple of tuples then what we'll say
    is if we have two tuples here that have。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我画一个包含这些属性的关系图。我们这里有三个列，但这些列实际上是多个属性。这些是属性A，这些是属性B，而这些是属性C。如果我们插入几个元组，我们会说，如果有两个元组，其值是相同的。
- en: and I'm going to use a bar even for these values in the tuples。 If we have two
    tuples whose A values are the same then their B values must also be the same。
    And we're going to be using this type of template for some reasoning later on。
    But we're not saying their C values have to be the same so we could have C1 and
    then different C values here as well。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将对元组中的这些值使用竖线。如果我们有两个元组，它们的A值相同，则它们的B值也必须相同。我们将在后续的推理中使用这种模板。但我们并不要求它们的C值必须相同，因此我们可以有C1，也可以有不同的C值。
- en: But again if we specify this functional dependency we are saying that every
    instance of our relation must satisfy the condition that if the A values are the
    same then the B values are also the same。 Finally let's come back to our example
    and I think when we start writing functional dependencies for our actual relations
    it'll give you a good idea of what they're really capturing。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们指定这个函数依赖关系，意味着我们的关系中的每个实例都必须满足这样的条件：如果A值相同，则B值也必须相同。最后，让我们回到我们的例子，我认为当我们开始为实际的关系编写函数依赖时，你会更好地理解它们究竟捕捉了什么。
- en: So let's write a few functional dependencies for our student relation based
    on what we expect to be true in the real world。 in the data that we're capturing
    in the relation。 So here's a first example。 social security number functionally
    determines S name， the student's name。 So what we say if we have multiple tuples
    about a particular student they have the same social security number say two tuples
    about student one。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据我们预期在现实世界中捕获的数据，为我们的学生关系写几个函数依赖关系。以下是第一个例子：社会保障号码函数性地决定学生姓名（S name）。所以我们说，如果我们有关于某个学生的多个元组，它们具有相同的社会保障号码，例如学生一的两个元组。
- en: two， three， we're expecting them to have the same name。 In fact we're requiring
    them to have the same name and presumably because one to three is sort of identifying
    the student that would be a natural functional dependency that would hold in this
    case。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 两个和三个，我们预期它们有相同的名称。实际上，我们要求它们有相同的名称，假设一到三可以识别学生，那么这将是一个自然的函数依赖关系，在这种情况下会成立。
- en: And similarly we would expect social security number to determine address although
    we're already making an assumption about the real world here。 If we have this
    particular functional dependency then we're saying a student doesn't move。 They
    don't have multiple addresses every tuple that describes that student by their
    social security number will have the same address。 Let's go to the high school
    and see what might be going on there。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以预期社会安全号码决定地址，尽管我们在这里已经做出了一些关于现实世界的假设。如果我们有这种特定的函数依赖关系，那么我们是在说一个学生不会搬家。每个通过社会安全号码描述学生的元组都会有相同的地址。让我们来看一下高中的情况，看看那里的情况可能是什么样的。
- en: So I mentioned that the high school code， what I'm trying to capture there is
    a unique code for each high school that might be filled in college applications。
    Then we would expect the high school code to determine the high school name。 Every
    time we have the particular high school code。 maybe for different students it
    would have the same name and also it would have the same city。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过高中代码，我在这里想要捕捉的是每所高中的唯一代码，可能会在大学申请中填写。然后我们希望高中代码能够决定高中名称。每当我们遇到特定的高中代码时，可能对于不同的学生，都会有相同的高中名称，并且也会有相同的城市。
- en: So that's an example of a functional dependency with two attributes on the right
    hand side。 Now let's look at one that's a little more complicated which is one
    that has two attributes on the left hand side instead。 That actually turns out
    to be a more interesting case。 In fact in this particular case we can probably
    reverse the arrow and have a functional dependency in the other direction。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有两个属性在右侧的函数依赖的例子。现在让我们看看一个更复杂的例子，它是具有两个属性在左侧的函数依赖。事实证明，这个情况更有趣。实际上，在这个特定的情况下，我们可能可以反转箭头，让它成为另一个方向的函数依赖。
- en: If we have a combination of high school name and high school city。 I'm going
    to assume that's unique。 That there's never two high schools with the same name
    and the same city。 If that's the case， if that's unique then we would expect a
    functional dependency to the high school code。 Anytime we have the same name and
    city we're talking about the same high school so we should have the same code。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有高中名称和高中城市的组合，我假设这是唯一的。也就是说，不会有两所高中在同一城市拥有相同的名称。如果是这种情况，假设它是唯一的，那么我们就可以预期存在一个函数依赖关系，指向高中代码。每当我们遇到相同名称和城市的组合时，我们就是在讨论同一所高中，因此我们应该有相同的代码。
- en: What other examples do we have？ If we assume that there's one GPA for each student
    then we'd have the Social Security number determine the GPA。 And we already talked
    about GPA determines priority。 And another example。 actually if we put these two
    together we should see well if we have the same Social Security number twice then
    we should have the same priority。 And you might be thinking well that's kind of
    a transitive rule that takes these two and produces that one and indeed it is。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有什么其他例子呢？如果我们假设每个学生都有一个GPA，那么社会安全号码将决定GPA。我们已经讨论过，GPA决定优先级。再举一个例子，实际上，如果我们把这两个条件结合在一起，我们应该能看到，如果有两个相同的社会安全号码，那么它们应该有相同的优先级。你可能会想，这有点像是一个传递规则，它把这两个条件结合起来得出这个结论，确实如此。
- en: And we'll talk about rules for functional dependencies later。 And there may
    be more in this case。 Now let's take a look at functional dependencies for our
    apply relation。 Actually this one is a little trickier。 It's even possible there
    are no functional dependencies at all。 It really depends on the real world data，
    the real world constraints。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论函数依赖的规则。在这种情况下，可能会有更多的规则。现在，让我们来看一下我们申请关系的函数依赖。实际上，这个有点复杂，甚至可能根本没有任何函数依赖。这实际上取决于现实世界中的数据和约束条件。
- en: One possibility for example is that every college has a particular single date
    on which it receives its application。 So if that were the case then we'd have
    the college name determine the date。 In other words every application for a particular
    college must have the same date。 Another constraint might be that students are
    only allowed to apply to a single major at each college they apply to。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种可能性是每个学院有一个特定的日期，在这个日期它会收到所有的申请。如果是这样的话，那么学院名称就决定了日期。换句话说，每个特定学院的所有申请必须具有相同的日期。另一个约束可能是学生只能在每个他们申请的学院选择一个专业。
- en: So if that were the case this is another one with two attributes on the left
    hand side we'd say that the Social Security number together with the college implies
    the major。 In other words we cannot have a student and college combination with
    two different majors and that captures that constraint。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果是这种情况，这又是一个左边有两个属性的例子，我们会说社会保障号和学院联合起来可以推导出专业。换句话说，我们不能有一个学生和学院的组合对应两个不同的专业，这就体现了这个约束。
- en: Maybe we have a constraint that students are only allowed to apply to colleges
    in one state。 That seems rather unlikely but I was struggling to find functional
    dependencies for this case。 In that case we'd have this functional dependency
    again saying a student could only apply to colleges in a single state。 For the
    apply relation specifically again it's really the real world constraints that
    drive which functional dependencies hold for the relation。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们有一个约束，规定学生只能申请一个州内的学院。这个约束似乎不太可能，但我在努力找出这种情况下的函数依赖。在这种情况下，我们会有这个函数依赖，表明一个学生只能申请一个州内的学院。对于应用关系而言，实际上是现实世界的约束决定了哪些函数依赖在该关系中成立。
- en: But it's important to understand those constraints so they can be translated
    to functional dependencies which then can drive good relational design。 So I've
    alluded a few times to the fact that functional dependencies generalize the notion
    of keys and let's make that connection explicit now。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但理解这些约束非常重要，这样它们就能转化为函数依赖，从而推动良好的关系设计。之前我曾多次提到函数依赖是如何推广键的概念的，现在我们来明确这一点。
- en: Let's suppose we have a relation R and R has no duplicate tuples。 R has some
    attributes A and it has some other attributes let's call those B。 And let's suppose
    that we have a functional dependency that A determines all of the attributes in
    the relation。 Now let me draw a picture of that。 So here's a relation R with attributes
    A and attributes B and now let's suppose that we have two tuples with the same
    values for A。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个关系R，且R没有重复的元组。R有一些属性A，还有一些其他属性，我们称之为B。假设我们有一个函数依赖，A决定关系中的所有属性。现在让我画个图来表示这个情况。所以这是一个具有属性A和属性B的关系R，现在假设我们有两个元组，它们的A值相同。
- en: So we'll just write those as little A bar and now let's see what happens with
    the B values。 We'll make them B1 bar and B2 bar。 Because we have the functional
    dependency the equal values here for A say that B1 and B2 have to be equal。 So
    B1 equals B2 let's just erase the little one and two but now we've generated duplicate
    tuples。 So what the function of dependency tells us in that case is that these
    two tuples are actually the same or rather we cannot have two separate tuples
    with the same A value。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们就把它们写成小A条，然后看看B值会发生什么。我们将它们写成B1条和B2条。因为我们有函数依赖，A的相等值表明B1和B2必须相等。所以B1等于B2，我们就删掉1和2，但现在我们生成了重复的元组。函数依赖在这种情况下告诉我们，这两个元组实际上是相同的，或者说我们不能有两个具有相同A值的独立元组。
- en: So we cannot have two tuples with the same A values is exactly what it means
    for A to be a key。 Now again this is only the case when we have no duplicates
    in R but if we have no duplicates if a set of attributes determines all the other
    attributes then those attributes are a key。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们不能有两个具有相同A值的元组，这正是A作为键的含义。再说一次，只有在R中没有重复元组时，这种情况才成立，但如果没有重复，如果一组属性决定了关系中的所有其他属性，那么这些属性就是一个键。
- en: So here are a few other definitions related to functional dependencies。 We have
    a notion of a trivial functional dependency。 A functional dependency is trivial
    A to B if B is a subset of A and let's just draw a little picture of what that
    means。 So here we have our attributes A and then we're saying and that's all of
    the attributes here and what we're saying is that B is a subset of A。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个与函数依赖相关的其他定义。我们有一个平凡函数依赖的概念。如果B是A的子集，那么A到B的函数依赖就是平凡的，让我们画一个小图来说明这是什么意思。这里我们有我们的A属性，然后我们说这就是所有这些属性，我们说B是A的子集。
- en: So in other words some portion of these attributes here we'll just mark that
    in purple here are attributes B。 Well it's pretty obvious that if two tuples have
    the same values across their entire expanse here for A's then obviously they're
    also going to have the same values for just this portion here。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这些属性中有一部分，我们用紫色标记，这些就是B属性。显然，如果两个元组在它们的A属性的整个范围内具有相同的值，那么它们在这个部分的值也必然相同。
- en: the B portion。 So that's why it's called the trivial functional dependency。
    So a non-trivial functional dependency is a functional dependency that's not a
    trivial one。 By the way FD is a common abbreviation for functional dependency。
    So if we have A determines B then that is non-trivial if it's not the case that
    B is a subset of A。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: B部分。所以这就是为什么它被称为平凡的函数依赖。非平凡函数依赖是指那些不是平凡的函数依赖。顺便提一下，FD是函数依赖（Functional Dependency）的常见缩写。所以，如果A决定B，那就是非平凡的，前提是B不是A的子集。
- en: Going to our picture let's have here our attributes A and now we're saying there
    are some attributes in B that are not part of A so we can say well maybe B is
    partially part of A but there's some portion that's not part of A。 So let's say
    that these are our B attributes here。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的图示，我们这里有我们的A属性，现在我们说B中的一些属性不是A的一部分，因此我们可以说，也许B部分是A的一部分，但还有一些部分不是A的一部分。那么假设这些就是我们的B属性。
- en: So now our functional dependency is actually saying something。 It's saying if
    we have two attributes that agree in these values then they're also going to agree
    in these values over here。 And the last definition is a completely non-trivial
    functional dependency and that's A determines B where A and B have no intersection
    at all。 So in that case again going back to our picture we'll have our A attributes
    here and then our B attributes are going to be some portion of the remaining attributes。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们的函数依赖实际上在表达一些内容。它的意思是，如果我们有两个属性，它们在这些值上是一致的，那么它们在这里的这些值上也会是一致的。而最后一个定义是完全非平凡的函数依赖，就是A决定B，其中A和B完全没有交集。因此，在这种情况下，再回到我们的图示，我们会有A属性在这里，然后B属性将是剩余属性的一个部分。
- en: And here we're saying a lot。 We're saying if these two have the same value then
    these two have the same value as well。 And the reality is that completely non-trivial
    functional dependencies are the ones that we're most interested in specifying。
    I mentioned that there are some rules that apply to all functional dependencies
    and I'll give a couple of those right now。 The first one is the splitting rule。
    The splitting rule says that if we have a set of attributes that determine another
    set of attributes and this time I'm going to write it out instead of using the
    bar notation。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们说了很多。我们说，如果这两个值相同，那么这两个值也应该相同。实际上，完全非平凡的函数依赖才是我们最感兴趣的部分。我提到过有一些规则适用于所有的函数依赖，我现在给大家列出几个。第一个是分割规则。分割规则说，如果我们有一组属性决定另一组属性，这一次我会写出来而不是使用条形符号。
- en: Then we also have this rule this implies that we have A determines B1 and A
    determines B2 and so on。 In other words we can split the right side of the functional
    dependency and if you think about it this is pretty obvious。 If we say that the
    A when the A values are the same all of the B values have to be the same then
    certainly when the A values are the same the B values have to be the same independently。
    Now you might wonder if the splitting rule also goes the other way。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们还有这个规则，这意味着我们有A决定B1，A决定B2，依此类推。换句话说，我们可以将函数依赖的右边分开。如果你仔细想一想，这其实是显而易见的。如果我们说，当A值相同时，所有的B值必须相同，那么当A值相同时，B值也必须独立地相同。你可能会想，分割规则是否也适用于反向情况。
- en: So let's say we have I'll put the left hand side I'll write out the attributes
    explicitly。 So let's say we have A1 through An determines B then is it from that
    the case that A1 determines B and A2 determines B on its own and so on。 All the
    answer to that is no and I'll give a simple example from our college application
    database。 So let's say that we have the functional dependency high school name
    and high school city determines high school code。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有，我将写出左边的属性。假设我们有A1到An决定B，那么从这个可以推出，A1决定B，A2单独决定B，依此类推。答案是否定的，我将给出一个简单的例子，来自我们的大学申请数据库。假设我们有功能依赖：高中名称和高中城市决定高中代码。
- en: We talked about that one before。 Oops， here that's an arrow there。 So that says
    that when we have a particular name and city combination for a high school that's
    identifying a single high school and so we'll always have the same code。 So that
    makes a lot of sense but it is not the case so I'll put a big X here necessarily
    that if we split the left hand side that high school name alone will determine
    high school code。 So for example I would venture to guess that there's a lot of
    Jefferson high schools all over the country and they won't all be the same high
    school。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过这个问题。哦，注意这里有一个箭头。它表示当我们有一个特定的名字和城市组合来表示一个高中的时候，它是唯一标识一个高中，所以我们将始终拥有相同的代码。这是非常有道理的，但并非如此。因此，我将画一个大X，表示如果我们拆分左边的部分，仅凭高中名字无法决定高中代码。例如，我猜想全国各地有很多名为“杰斐逊”的高中，但它们不会是同一所学校。
- en: So it's really the combination of attributes on the left that together functionally
    determine the right hand side and so we do not then have the splitting rule as
    a general principle。 The combining rule is the inverse of the splitting rule。
    It says if we have a determines b1 and we have a determines b2 and so on up to
    a determines bn then we also have a determines b1 through bn together。 Next we
    have two trivial dependency rules。 Let me remind you what a trivial dependency
    is。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上是左边属性的组合共同决定了右边的内容，因此作为一般原则，我们没有拆分规则。组合规则是拆分规则的反面。它表示，如果我们有a决定b1，并且我们有a决定b2，依此类推，一直到a决定bn，那么我们也有a决定b1到bn的组合。
- en: It's a determines b where b is a subset of a。 So in other words every left hand
    side determines itself or any subset of itself and that's what drives the two
    trivial dependency rules。 One of them says that if we have a determines b then
    we also have a determines a union b。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示a决定b，其中b是a的子集。换句话说，左边的每一项决定它自己或它的任何子集，这就是推动两个基本依赖规则的原因。其一是，如果我们有a决定b，那么我们也有a决定a并集b。
- en: So in other words we can add to the right hand side of every dependency what's
    already on the left hand side。 Sort of as a converse we can also say that if a
    determines b then a determines a intersect b。 Actually this one is also implied
    by the splitting rule so we have two different rules in this case that are doing
    the same thing。 And finally the transitive rule which is the one we alluded to
    earlier。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个基本依赖规则。让我提醒你什么是基本依赖。换句话说，我们可以将左边已经包含的内容添加到每个依赖的右边。作为反向推理，我们也可以说，如果a决定b，那么a决定a与b的交集。实际上，这个规则也由拆分规则所暗示，因此我们在这种情况下有两个不同的规则在做相同的事情。最后是传递规则，这是我们之前提到的。
- en: It says if we have a determines b and we have b determines c then we have a
    determin c。 Now all of these rules can actually be proven formally and I'm going
    to go through a sketch of this particular one。 So here's my relation R and I'll
    have attributes a， b。 c and then let's let d be the left of our attributes。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示，如果我们有a决定b，并且我们有b决定c，那么我们就有a决定c。现在，所有这些规则实际上都可以形式化证明，我将简要展示其中这一条。这里是我的关系R，它有属性a、b、c，然后我们假设d是我们的左边属性。
- en: And my goal is to prove that a determines c and the information I have to prove
    that is these two functional dependencies here。 So to prove that a determines
    c I have to prove that if two tuples have the same a values。 we'll put little
    bars there， then they also have the same c values。 So I need to show that these
    two c values here are going to be the same。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是证明a决定c，而我需要用来证明这一点的信息是这两个函数依赖。为了证明a决定c，我必须证明，如果两个元组具有相同的a值（我们在这儿放上小竖线），那么它们的c值也必须相同。所以，我需要证明这两个c值将是相同的。
- en: So you can see what's going to happen。 Using the first functional dependency
    because these two a values are the same。 I know their b values must be the same。
    And then I just use the second functional dependency and because the two b values
    are the same。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到接下来会发生什么。利用第一个函数依赖关系，因为这两个a值相同，我知道它们的b值也必须相同。接着我使用第二个函数依赖关系，因为这两个b值是相同的。
- en: I then know that the two c values are the same and that has shown that this
    functional dependency holds。 And you can do a similar thing to prove the other
    rules to yourself。 Now I'm going to introduce the concept of closure of attributes。
    Let's suppose we're given a relation， a set of functional dependencies for that
    relation。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这两个c值是相同的，这表明这个函数依赖关系成立。你可以做类似的事情来证明其他规则。现在我要引入属性闭包的概念。假设我们给定了一个关系，以及该关系的一组函数依赖。
- en: and then a set of attributes a bar that are part of that relation。 I'm interested
    in finding all attributes b of the relation such that a bar functionally determines
    b。 And this is what's called the closure and I'll show in a bit why we might want
    to compute that。 Notationally， the closure is written using the plus sign， so
    the closure of a bar is a bar plus。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是关系中属性a条的一组属性。我感兴趣的是找到关系中所有属性b，使得a条函数地决定b。这就是所谓的闭包，我稍后会展示为什么我们可能想计算它。从符号上讲，闭包是用加号表示的，所以a条的闭包就是a条加。
- en: Let me be a little more explicit。 Let me write out a bar because remember whenever
    we write bar we're actually talking about a list of attributes。 So we're going
    to write it as a one through a n and I'm interested in computing the closure of
    that set of attributes。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更明确一些。让我写出a条，因为记住，每当我们写条的时候，我们实际上是在谈论一组属性。所以我们将它写作a1到an，我感兴趣的是计算这组属性的闭包。
- en: In other words， the entire set of attributes that are functionally determined
    by the attributes a one through a n。 And I'm going to give an algorithm for doing
    that。 My algorithm says start with the set itself。 So I'm going to start with
    a one through a n， except I'm not going to close that。 I'm going to leave a little
    space there。 And then I'm going to repeat until there's no change。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，整个属性集是由a1到an这些属性函数地决定的。我将提供一个计算该闭包的算法。我的算法是从集合本身开始。因此，我将从a1到an开始，但我不会直接关闭它。我会留一点空间，然后重复执行，直到没有变化。
- en: I'm going to add attributes to that set until I get to the closure。 So I'm going
    to repeat if a determines b and that will put bars in here and all of a are in
    the set。 then add b to the set。 So I might have my attributes here。 a one through
    a n and it might be the case that a four determines attributes c and d。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向这个集合中添加属性，直到得到闭包。因此，我将重复如果a决定b的过程，这样就会在这里加入条目，且所有的a都在集合中。然后将b添加到集合中。所以我可能会有这样的属性集合：a1到an，并且可能存在a4决定了c和d属性。
- en: So I'll add c and d to the set。 I repeat maybe there's a c goes to e and I'll
    add e to the set and so on。 And when there's no more change， then I've computed
    the complete closure。 Now if you happen to be someone who likes to think in terms
    of rules instead。 what we're effectively doing is applying the combining and transitive
    rules to the attributes in the set until there's no change。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将把c和d添加到集合中。如果可能有c决定了e，那么我就将e添加到集合中，依此类推。当没有更多变化时，我就得到了完整的闭包。现在，如果你是那种喜欢从规则角度思考的人，那么我们实际上是在将合并规则和传递规则应用到集合中的属性上，直到没有变化。
- en: So let's run an example of the closure algorithm。 Let's go to our complete student
    table and let's add three functional dependencies。 One that says this student's
    social security number determines their name。 address and GPA and that would be
    normal。 GPA determines priority and high school code determines high school name
    and high school city。 Again， these are all examples we gave earlier that would
    be natural functional dependencies for this particular relation。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做一个闭包算法的例子。让我们回到完整的学生表，并添加三个函数依赖。一个是表示学生的社会保障号码决定了他们的姓名、地址和GPA，这就是正常情况。GPA决定了优先级，而高中代码决定了高中名称和高中城市。再次提醒，这些都是我们之前给出的示例，作为这个特定关系的自然函数依赖。
- en: Let's suppose that we're interested in computing the closure of the two attributes。
    social security number and high school code。 So in other words。 we want to find
    all attributes in the student relation that are functionally determined by these
    two attributes。 So the algorithm says start with the two attributes themselves。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣计算两个属性的闭包：社会安全号码和高中代码。换句话说，我们希望找到在学生关系中由这两个属性功能决定的所有属性。那么算法说，从这两个属性本身开始。
- en: social security number and high school code， and then add attributes that are
    functionally determined by ones in the set。 So if we start with our first functional
    dependency here。 because we have a social security number that allows us to add
    the student name， the address。 the GPA。 And that's it for that one。 Now let's
    repeat again。 Because we have the GPA。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 社会安全号码和高中代码，然后添加那些由集合中属性功能决定的属性。所以如果我们从第一个功能依赖开始，由于我们有社会安全号码，我们可以添加学生姓名、地址、GPA。到此为止。现在让我们再重复一遍。因为我们有了GPA。
- en: our second functional dependency tells us we can add the priority。 And that's
    it for that one。 And then since we have the high school code in the set。 our third
    one tells us that we can add the high school name and the high school city。 And
    at that point， we certainly know we're done because we've actually got the entire
    relation at this point。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个功能依赖告诉我们，我们可以添加优先级。到此为止。然后，既然我们在集合中已经有了高中代码，我们的第三个依赖告诉我们，可以添加高中名称和高中城市。到那时，我们肯定知道已经完成，因为我们实际上已经得到了整个关系。
- en: Now I didn't pick this particular example at random。 We took two attributes。
    social security number and high school code。 We computed their closure and we
    discovered that they together functionally determined all attributes of the student
    relation。 Now remember just a few slides ago， when a set of attributes functionally
    determined all the attributes。 then those attributes together form a key for the
    relation。 And in fact， if you think about it。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我并不是随便选了这个特定的例子。我们取了两个属性：社会安全号码和高中代码。我们计算了它们的闭包，并发现它们一起功能决定了学生关系中的所有属性。现在记住，就在几张幻灯片之前，当一组属性功能决定了所有属性时，这些属性一起构成了该关系的关键字。事实上，如果你想一想。
- en: social security number and high school code together are a natural key for the
    relation。 A student might go to multiple high schools， but there's no reason to
    have more than one tuple with the combination of a particular student and the
    high school they attended。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 社会安全号码和高中代码一起构成该关系的自然关键字。一个学生可能会去多所高中，但没有理由用某个特定学生和他们就读的高中的组合来表示多个元组。
- en: '![](img/da741dc1bf43bb59db32d73201d5416a_5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da741dc1bf43bb59db32d73201d5416a_5.png)'
- en: So let's formalize a bit this relationship between the notion of closure and
    keys。 Let's suppose we're interested in answering the question。 is a particular
    set of attributes a key for a relation？ We can use closure to do that。 Remember
    we have the relation and we have a set of functional dependencies for the relation。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们正式化一下闭包与关键字之间的关系。假设我们有兴趣回答这个问题：一组特定的属性是否是某个关系的关键字？我们可以用闭包来解决这个问题。记住，我们有关系，并且有该关系的功能依赖集。
- en: So what we do is we compute the closure of a， that's going to give us a set
    of attributes。 and if that equals all attributes， then a is a key。 As a more general
    question。 let's suppose we're given a set of functional dependencies for a relation。
    How can we use it to find all of the keys for the relation？
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们做的是计算`a`的闭包，这将给我们一个属性集合。如果这个集合等于所有属性，那么`a`就是一个关键字。作为一个更一般的问题，假设我们给定了一个关系的功能依赖集，我们如何使用它来找到该关系的所有关键字呢？
- en: So we use the same basic idea of computing closure。 but this time we have to
    do it for every subset of the attributes。 So let's call each subset a bar and
    we just check if the closure of a bar determines all attributes。 And if it does，
    then it's a key。 And by considering every subset of the attributes in our。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们使用相同的基本思想来计算闭包，但这次我们必须对每个属性子集都进行计算。我们可以称每个子集为`bar`，然后检查`bar`的闭包是否决定了所有属性。如果是，那么它就是一个关键字。通过考虑关系中的每个属性子集。
- en: then we're considering every possible key， and we'll just check for each one
    whether it's actually a key。 Now that seems fairly inefficient and actually we
    can be a little more efficient than that。 We can consider these subsets in increasing
    size order。 So for example。 if we determine that a and b together determine all
    attributes。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考虑所有可能的键，并逐一检查每个键是否真的是一个键。现在，这看起来效率比较低，实际上我们可以提高效率。我们可以按递增的大小顺序考虑这些子集。例如，如果我们确定A和B一起决定所有属性。
- en: functionally determine all attributes in the relation， that tells us a， b is
    a key。 And that actually also tells us that every superset of a， b is also a key。
    And if you think about it， that falls out naturally。 So the real algorithm would
    say let's start with single attributes and determine if there are key。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果A、B功能性地确定了关系中的所有属性，这就告诉我们，A，B是一个键。而且这实际上也告诉我们，A，B的任何超集也是一个键。如果你想想，这一点自然成立。所以，真正的算法是，从单一属性开始，确定是否为键。
- en: if a single attribute say c is a key， then so is every superset of c。 and then
    we go to pairs of attributes and so on。 Finally。 let's talk about how we specify
    the set of functional dependencies for a relation。 First。 I'll define a notion
    of one set of functional dependencies following from another one。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单一属性，比如c，是一个键，那么c的所有超集也是一个键。接着，我们考虑属性对，依此类推。最后，来谈谈如何为一个关系指定功能依赖集。首先，我将定义一个概念，表示一个功能依赖集是如何从另一个依赖集中推导出来的。
- en: So let's suppose we have a relation R and we have two sets of functional dependencies
    that aren't identical。 S1 and S2。 We say that S2 follows from S1 if every relation
    instance satisfying S1 also satisfies S2。 As a simple example， suppose S2 is Social
    Security Number determines priority and suppose S1 is the two functional dependencies。
    Social Security Number determines GPA and GPA determines priority。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个关系R，并且有两个功能依赖集S1和S2，它们不完全相同。如果每个满足S1的关系实例也满足S2，那么我们说S2是从S1推导出来的。举个简单的例子，假设S2是“社会安全号码决定优先级”，而S1是两个功能依赖，“社会安全号码决定GPA”和“GPA决定优先级”。
- en: Then it's certainly the case that in， for this example， S2 follows from S1。
    Every time we have a relation that satisfies Social Security Number determines
    GPA and GPA determines priority。 then that relation will also satisfy Social Security
    Number determines priority。 And we kind of proved that actually in an earlier
    part of this video。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，对于这个例子来说，S2确实是从S1推导出来的。每次我们有一个满足“社会安全号码决定GPA”和“GPA决定优先级”的关系时，那么该关系也会满足“社会安全号码决定优先级”。我们实际上在视频的早些部分已经证明了这一点。
- en: So one question you might have is how do we test whether one set of functional
    dependencies follows from another。 That really boils down to testing whether one
    functional dependency follows from a set。 So。 and let me just make this A bar，
    B bar here to make clear they can be sets of attributes。 Because if we have S1
    and S2， then we just check whether every functional dependency in S2 follows from
    the functional dependencies in S1。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会问，如何测试一个功能依赖集是否从另一个依赖集中推导出来。实际上，这归结为测试一个功能依赖是否从一组功能依赖中推导出来。所以，让我在这里将A和B表示为属性集，以便清楚地说明它们可以是属性集。因为如果我们有S1和S2，那么我们只需要检查S2中的每个功能依赖是否从S1中的功能依赖推导出来。
- en: There's actually two ways of going about this test。 One of the ways is to use
    the closure。 We'll compute A plus based on the functional dependencies that are
    in S and then we'll check if B bar B is in the set。 Reminder， computing the closure
    tells us every attribute that's functionally determined by the attributes in A
    based on the functional dependencies in S。 If those include B， then A determines
    B does indeed follow from S。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其实有两种方法来进行这个测试。第一种方法是使用闭包。我们将基于S中的功能依赖计算A的闭包，然后检查B是否在闭包内。提醒一下，计算闭包会告诉我们A中属性根据S中的功能依赖功能性地确定的所有属性。如果这些属性中包含B，那么A确实决定B，这表明A确定B是从S推导出来的。
- en: The second way to check is based on a set of axioms， a set of rules called Armstrong's
    axioms。 We saw some rules for functional dependencies earlier。 but Armstrong's
    axioms are a specific set of rules that are what's called complete。 It's guaranteed
    that if one thing about functional dependencies can be proved from another。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种检查方法是基于一组公理，一组叫做阿姆斯特朗公理的规则。我们之前看过一些关于功能依赖的规则，但阿姆斯特朗公理是一组特殊的规则，它们是所谓的完整规则。可以保证，如果某个功能依赖的性质可以从另一个推导出来，那就一定能通过这些规则证明。
- en: then it can be proved using the Armstrong's axioms。 I'm not going to cover Armstrong's
    axioms in the videos。 but you can look at any of the recommended readings and
    find them there。 You might wonder why did I introduce this notion of one set of
    functional dependencies following from another？
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用**阿姆斯特朗公理**证明这一点。我不会在视频中讲解阿姆斯特朗公理，但你可以查看任何推荐的阅读材料，那里会有相关内容。你可能会想，为什么我要引入一个函数依赖集从另一个函数依赖集派生的概念呢？
- en: For that matter， why did I introduce trivial and non-trivial functional dependencies？
    Well。 I'm going to sum up in one sentence what we're looking for when we specify
    the set of functional dependencies for a relation。 We have a notion of the real-world
    data。 We have our attributes。 but we need to specify the functional dependencies
    in order to get a good design or for some other reasons I mentioned。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我要引入微不足道的和非微不足道的函数依赖呢？嗯，我将用一句话总结我们在为关系指定函数依赖集时所要寻找的内容。我们有现实世界的数据，我们有我们的属性，但我们需要指定函数依赖，以便得到一个良好的设计，或者出于我提到的其他原因。
- en: What we would like to find is a minimal set of completely non-trivial functional
    dependencies such that all functional dependencies that hold on the relation。
    follow from using the technical definition I gave the dependencies in the set。
    Wow。 that seems like a very complicated thing， but the fact is when you start
    specifying functional dependencies。 you'll discover that you will actually get
    this definition pretty naturally。 So to conclude。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要找到的是一个最小的完全非微不足道的函数依赖集，使得关系中所有有效的函数依赖，都能通过我给出的技术定义，从该集合中的依赖推导出来。哇，这看起来是一个非常复杂的事情，但事实上，当你开始指定函数依赖时，你会发现你实际上会很自然地得到这个定义。所以，结论是：
- en: functional dependencies are a generally useful concept in database systems。
    They're a key ingredient of doing relational design by the decomposition。 because
    we use the functional dependencies to get Boyzka normal form。 which is what we'll
    cover in the next video。 But they're also useful for the system to determine how
    to store data。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数依赖是数据库系统中一个普遍有用的概念。它们是通过分解进行关系设计的关键成分，因为我们使用函数依赖来获得**博伊斯-科得范式**，这将在下一个视频中讲解。但它们对系统确定如何存储数据也很有用。
- en: to compress data， and also to reason about query processing。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用于压缩数据，也用于推理查询处理。
- en: '![](img/da741dc1bf43bb59db32d73201d5416a_7.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da741dc1bf43bb59db32d73201d5416a_7.png)'
