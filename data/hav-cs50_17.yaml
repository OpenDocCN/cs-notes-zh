- en: Lecture 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座 3
- en: 原文：[https://cs50.harvard.edu/ai/notes/3/](https://cs50.harvard.edu/ai/notes/3/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/ai/notes/3/](https://cs50.harvard.edu/ai/notes/3/)
- en: Optimization
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Optimization is choosing the best option from a set of possible options. We
    have already encountered problems where we tried to find the best possible option,
    such as in the minimax algorithm, and today we will learn about tools that we
    can use to solve an even broader range of problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是从一组可能选项中选择最佳选项。我们已经在寻找最佳可能选项的问题中遇到过，例如在最小-最大算法中，今天我们将学习我们可以用来解决更广泛范围问题的工具。
- en: Local Search
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部搜索
- en: 'Local search is a search algorithm that maintains a single node and searches
    by moving to a neighboring node. This type of algorithm is different from previous
    types of search that we saw. Whereas in maze solving, for example, we wanted to
    find the quickest way to the goal, local search is interested in finding the best
    answer to a question. Often, local search will bring to an answer that is not
    optimal but “good enough,” conserving computational power. Consider the following
    example of a local search problem: we have four houses in set locations. We want
    to build two hospitals, such that we minimize the distance from each house to
    a hospital. This problem can be visualized as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 局部搜索是一种搜索算法，它保持单个节点并通过移动到相邻节点来搜索。这种算法与我们之前看到的搜索类型不同。例如，在迷宫解决中，我们想要找到到达目标的最快路径，而局部搜索则关注于找到问题的最佳答案。通常，局部搜索会得到一个非最优但“足够好”的答案，从而节省计算能力。考虑以下局部搜索问题的例子：我们有四个位于特定位置的房屋。我们想要建造两家医院，使得每个房屋到医院的距离最小化。这个问题可以如下可视化：
- en: '![Houses and Hospitals](../Images/c1cca516215fe134dffc12703a35cb79.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![房屋和医院](../Images/c1cca516215fe134dffc12703a35cb79.png)'
- en: In this illustration, we are seeing a possible configuration of houses and hospitals.
    The distance between them is measured using Manhattan distance (number of moves
    up, down, and to the sides; discussed in more detail in lecture 0), and the sum
    of the distances from each house to the nearest hospital is 17\. We call this
    the **cost**, because we try to minimize this distance. In this case, a state
    would be any one configuration of houses and hospitals.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个插图上，我们看到的是房屋和医院的一种可能配置。它们之间的距离使用曼哈顿距离（向上、向下和向侧的移动次数；在讲座0中详细讨论）来衡量，每个房屋到最近医院的距离之和是17。我们称之为**成本**，因为我们试图最小化这个距离。在这种情况下，状态可以是房屋和医院的任何一种配置。
- en: Abstracting this concept, we can represent each configuration of houses and
    hospitals as the state-space landscape below. Each of the bars in the picture
    represents a value of a state, which in our example would be the cost of a certain
    configuration of houses and hospitals.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象这个概念，我们可以将房屋和医院的每种配置表示为下面的状态空间景观。图片中的每根条形代表一个状态的值，在我们的例子中，这将是房屋和医院某种配置的成本。
- en: '![State-Space Landscape](../Images/5cb92118a21952fbd93073cb793878fd.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![状态空间景观](../Images/5cb92118a21952fbd93073cb793878fd.png)'
- en: 'Going off of this visualization, we can define a few important terms for the
    rest of our discussion:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个可视化，我们可以为接下来的讨论定义几个重要术语：
- en: An **Objective Function** is a function that we use to maximize the value of
    the solution.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标函数**是我们用来最大化解决方案价值的函数。'
- en: A **Cost Function** is a function that we use to minimize the cost of the solution
    (this is the function that we would use in our example with houses and hospitals.
    We want to minimize the distance from houses to hospitals).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本函数**是我们用来最小化解决方案成本（这是我们将在房屋和医院例子中使用的函数。我们希望最小化房屋到医院的距离）的函数。'
- en: A **Current State** is the state that is currently being considered by the function.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前状态**是函数目前正在考虑的状态。'
- en: A **Neighbor State** is a state that the current state can transition to. In
    the one-dimensional state-space landscape above, a neighbor state is the state
    to either side of the current state. In our example, a neighbor state could be
    the state resulting from moving one of the hospitals to any direction by one step.
    Neighbor states are usually similar to the current state, and, therefore, their
    values are close to the value of the current state.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻状态**是当前状态可以转换到的状态。在上面的单维状态空间景观中，相邻状态是当前状态两侧的状态。在我们的例子中，相邻状态可能是将其中一家医院向任何方向移动一步所得到的状态。相邻状态通常与当前状态相似，因此它们的值接近当前状态的值。'
- en: Note that the way local search algorithms work is by considering one node in
    a current state, and then moving the node to one of the current state’s neighbors.
    This is unlike the minimax algorithm, for example, where every single state in
    the state space was considered recursively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，局部搜索算法的工作方式是考虑当前状态中的一个节点，然后将节点移动到当前状态的一个相邻状态。这与例如最小-最大算法不同，在最小-最大算法中，状态空间中的每个状态都被递归地考虑。
- en: Hill Climbing
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 爬山
- en: Hill climbing is one type of a local search algorithm. In this algorithm, the
    neighbor states are compared to the current state, and if any of them is better,
    we change the current node from the current state to that neighbor state. What
    qualifies as better is defined by whether we use an objective function, preferring
    a higher value, or a decreasing function, preferring a lower value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 爬山是局部搜索算法的一种类型。在这个算法中，将相邻状态与当前状态进行比较，如果其中任何一个更好，我们就将当前节点从当前状态切换到那个相邻状态。什么被认为是更好的，取决于我们是否使用目标函数，偏好更高的值，还是递减函数，偏好更低的值。
- en: 'A hill climbing algorithm will look the following way in pseudocode:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 爬山算法在伪代码中的表现形式如下：
- en: 'function Hill-Climb(*problem*):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 Hill-Climb(*问题*)：
- en: '*current* = initial state of *problem*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当前状态* = *问题*的初始状态'
- en: 'repeat:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'repeat:'
- en: '*neighbor* = best valued neighbor of *current*'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相邻状态* = *当前状态*的最佳值相邻状态'
- en: 'if *neighbor* not better than *current*:'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*相邻状态*不如*当前状态*好：
- en: return *current*
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 *当前状态*
- en: '*current* = *neighbor*'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当前状态* = *相邻状态*'
- en: 'In this algorithm, we start with a current state. In some problems, we will
    know what the current state is, while, in others, we will have to start with selecting
    one randomly. Then, we repeat the following actions: we evaluate the neighbors,
    selecting the one with the best value. Then, we compare this neighbor’s value
    to the current state’s value. If the neighbor is better, we switch the current
    state to the neighbor state, and then repeat the process. The process ends when
    we compare the best neighbor to the current state, and the current state is better.
    Then, we return the current state.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我们从当前状态开始。在某些问题中，我们将知道当前状态是什么，而在其他情况下，我们必须随机选择一个状态作为起点。然后，我们重复以下操作：评估相邻状态，选择具有最佳值的那个。然后，我们将这个相邻状态的值与当前状态的值进行比较。如果相邻状态更好，我们将当前状态切换到相邻状态，并重复这个过程。当我们将最佳相邻状态与当前状态进行比较，且当前状态更好时，过程结束。然后，我们返回当前状态。
- en: 'Using the hill climbing algorithm, we can start to improve the locations that
    we assigned to the hospitals in our example. After a few transitions, we get to
    the following state:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用爬山算法，我们可以开始改进我们示例中分配给医院的地点。经过几次转换后，我们达到以下状态：
- en: '![Houses and Hospitals at Local Minimum](../Images/b9a61b7e1b350c386249775506868383.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![局部最小值处的房屋和医院](../Images/b9a61b7e1b350c386249775506868383.png)'
- en: At this state, the cost is 11, which is an improvement over 17, the cost of
    the initial state. However, this is not the optimal state just yet. For example,
    moving the hospital on the left to be underneath the top left house would bring
    to a cost of 9, which is better than 11\. However, this version of a hill climbing
    algorithm can’t get there, because all the neighbor states are at least as costly
    as the current state. In this sense, a hill climbing algorithm is short-sighted,
    often settling for solutions that are *better* than some others, but not necessarily
    the *best* of all possible solutions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个状态下，成本是11，这比初始状态的17有所改善。然而，这还不是最佳状态。例如，将医院移动到左上角房屋下方，可以将成本降低到9，这比11更好。然而，这个版本的爬山算法无法达到那里，因为所有相邻状态的成本至少与当前状态一样高。从这个意义上说，爬山算法是短视的，通常满足于比其他一些解决方案更好的解决方案，但不一定是所有可能解决方案中的最佳。
- en: '**Local and Global Minima and Maxima**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部和全局极小值与极大值**'
- en: 'As mentioned above, a hill climbing algorithm can get stuck in local maxima
    or minima. A ***local* maximum** (plural: maxima) is a state that has a higher
    value than its *neighboring states*. As opposed to that, a ***global* maximum**
    is a state that has the highest value of *all states* in the state-space.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，爬山算法可能会陷入局部极大值或极小值。一个**局部极大值**（复数：maxima）是一个比其**相邻状态**具有更高值的态。与之相反，一个**全局极大值**是一个在状态空间中所有状态中具有最高值的态。
- en: '![Maxima](../Images/4cf58fffd2d479054fb4f55d59ff38b2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![极大值](../Images/4cf58fffd2d479054fb4f55d59ff38b2.png)'
- en: 'In contrast, a ***local* minimum** (plural: minima) is a state that has a lower
    value than its *neighboring states*. As opposed to that, a ***global* minimum**
    is a state that has the lowest value of *all states* in the state-space.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个**局部最小值**（复数：minima）是一个比其**相邻状态**具有更低值的态。与这相反，一个**全局最小值**是一个在状态空间中所有态中具有最低值的态。
- en: '![Minima](../Images/0cb1f7ed9fa0213039b7fd52ac07a3c0.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![最小值](../Images/0cb1f7ed9fa0213039b7fd52ac07a3c0.png)'
- en: The problem with hill climbing algorithms is that they may end up in local minima
    and maxima. Once the algorithm reaches a point whose neighbors are worse, for
    the function’s purpose, than the current state, the algorithm stops. Special types
    of local maxima and minima include the **flat local maximum/minimum**, where multiple
    states of equal value are adjacent, forming a plateau whose neighbors have a worse
    value, and the **shoulder**, where multiple states of equal value are adjacent
    and the neighbors of the plateau can be both better and worse. Starting from the
    middle of the plateau, the algorithm will not be able to advance in any direction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 爬山算法的问题在于它们可能最终陷入局部最小值和最大值。一旦算法达到一个点，其邻居的值对于函数的目的来说比当前状态更差，算法就会停止。特殊类型的局部最大值和最小值包括**平坦的局部最大值/最小值**，其中多个具有相等值的相邻状态形成一个高原，其邻居的值更差，以及**肩部**，其中多个具有相等值的相邻状态，高原的邻居可以是更好的也可以是更差的。从高原的中间开始，算法将无法向任何方向前进。
- en: '![Flat Local Maximum/Minimum and Shoulder](../Images/28f660e1a03056f7f66b70715b7f716c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![平坦的局部最大值/最小值和肩部](../Images/28f660e1a03056f7f66b70715b7f716c.png)'
- en: '**Hill Climbing Variants**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**爬山法变体**'
- en: Due to the limitations of Hill Climbing, multiple variants have been thought
    of to overcome the problem of being stuck in local minima and maxima. What all
    variations of the algorithm have in common is that, no matter the strategy, each
    one still has the potential of ending up in local minima and maxima and no means
    to continue optimizing. The algorithms below are phrased such that a higher value
    is better, but they also apply to cost functions, where the goal is to minimize
    cost.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于爬山法的局限性，人们已经想到了多种变体来克服陷入局部最小值和最大值的问题。所有算法的变体都有一个共同点，即无论策略如何，每个变体仍然有可能最终陷入局部最小值和最大值，并且没有继续优化的手段。下面的算法表述中，较高的值被视为较好，但它们也适用于成本函数，其目标是最小化成本。
- en: '**Steepest-ascent**: choose the highest-valued neighbor. This is the standard
    variation that we discussed above.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最速上升**：选择最高值的邻居。这是我们上面讨论的标准变体。'
- en: '**Stochastic**: choose randomly from higher-valued neighbors. Doing this, we
    choose to go to any direction that improves over our value. This makes sense if,
    for example, the highest-valued neighbor leads to a local maximum while another
    neighbor leads to a global maximum.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机性**：从更高值的邻居中随机选择。这样做，我们选择走向任何可以提高我们值的方向。例如，如果最高值的邻居导致局部最大值，而另一个邻居导致全局最大值，这样做是有意义的。'
- en: '**First-choice**: choose the first higher-valued neighbor.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首选**：选择第一个更高值的邻居。'
- en: '**Random-restart**: conduct hill climbing multiple times. Each time, start
    from a random state. Compare the maxima from every trial, and choose the highest
    amongst those.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机重启**：多次进行爬山。每次，从一个随机状态开始。比较每次试验的最大值，并选择其中最高的一个。'
- en: '**Local Beam Search**: chooses the *k* highest-valued neighbors. This is unlike
    most local search algorithms in that it uses multiple nodes for the search, and
    not just one.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部束搜索**：选择*k*个最高值的邻居。这与大多数局部搜索算法不同，因为它使用多个节点进行搜索，而不仅仅是单个节点。'
- en: Although local search algorithms don’t always give the best possible solution,
    they can often give a good enough solution in situations where considering every
    possible state is computationally infeasible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然局部搜索算法并不总是给出最佳可能的解决方案，但在考虑所有可能状态在计算上不可行的情况下，它们通常可以给出足够好的解决方案。
- en: Simulated Annealing
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟退火
- en: 'Although we have seen variants that can improve hill climbing, they all share
    the same fault: once the algorithm reaches a local maximum, it stops running.
    Simulated annealing allows the algorithm to “dislodge” itself if it gets stuck
    in a local maximum.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经看到了可以改进爬山法的变体，但它们都存在相同的缺陷：一旦算法达到局部最大值，它就会停止运行。模拟退火允许算法在陷入局部最大值时“摆脱”自己。
- en: 'Annealing is the process of heating metal and allowing it to cool slowly, which
    serves to toughen the metal. This is used as a metaphor for the simulated annealing
    algorithm, which starts with a high temperature, being more likely to make random
    decisions, and, as the temperature decreases, it becomes less likely to make random
    decisions, becoming more “firm.” This mechanism allows the algorithm to change
    its state to a neighbor that’s worse than the current state, which is how it can
    escape from local maxima. The following is pseudocode for simulated annealing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 热处理是将金属加热并允许其缓慢冷却的过程，这有助于使金属变硬。这个过程被用作模拟退火算法的隐喻，该算法从高温开始，更有可能做出随机决策，随着温度的降低，它做出随机决策的可能性降低，变得更加“坚定”。这种机制允许算法将其状态改变为比当前状态更差的邻居状态，这就是它如何逃离局部最大值的原因。以下是对模拟退火算法的伪代码：
- en: 'function Simulated-Annealing(*problem*, *max*):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '函数 Simulated-Annealing(*problem*, *max*):'
- en: '*current* = initial state of *problem*'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当前* = *问题*的初始状态'
- en: 'for *t* = 1 to *max*:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'for *t* = 1 to *max*:'
- en: '*T* = Temperature(*t*)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T* = Temperature(*t*)'
- en: '*neighbor* = random neighbor of *current*'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*邻居* = *当前*的随机邻居'
- en: '*ΔE* = how much better *neighbor* is than *current*'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ΔE* = 相较于*当前*，*邻居*有多好'
- en: 'if *ΔE* > 0:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'if *ΔE* > 0:'
- en: '*current* = *neighbor*'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*current* = *neighbor*'
- en: with probability e^(*ΔE/T*) set *current* = *neighbor*
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以概率 e^(*ΔE/T*) 将*当前*设置为*邻居*
- en: return *current*
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回*当前*
- en: 'The algorithm takes as input a problem and *max*, the number of times it should
    repeat itself. For each iteration, *T* is set using a Temperature function. This
    function returns a higher value in the early iterations (when *t* is low) and
    a lower value in later iterations (when *t* is high). Then, a random neighbor
    is selected, and *ΔE* is computed such that it quantifies how better the neighbor
    state is than the current state. If the neighbor state is better than the current
    state (*ΔE* > 0), as before, we set our current state to be the neighbor state.
    However, when the neighbor state is worse (*ΔE* < 0), we still might set our current
    state to be that neighbor state, and we do so with probability e^(*ΔE/T*). The
    idea here is that a more negative *ΔE* will result in lower probability of the
    neighbor state being chosen, and the higher the temperature *T* the higher the
    probability that the neighbor state will be chosen. This means that the worse
    the neighbor state, the less likely it is to be chosen, and the earlier the algorithm
    is in its process, the more likely it is to set a worse neighbor state as current
    state. The math behind this is as follows: e is a constant (around 2.72), and
    *ΔE* is negative (since this neighbor is worse than the current state). The more
    negative *ΔE*, the closer the resulting value to 0\. The higher the temperature
    *T* is, the closer *ΔE/T* is to 0, making the probability closer to 1.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将问题和一个*max*（算法应重复的次数）作为输入。对于每一次迭代，使用温度函数设置*T*。这个函数在早期迭代（当*t*较低时）返回较高的值，而在后期迭代（当*t*较高时）返回较低的值。然后，选择一个随机邻居，并计算*ΔE*，以量化邻居状态相较于当前状态有多好。如果邻居状态比当前状态好（*ΔE*
    > 0），就像之前一样，我们将当前状态设置为邻居状态。然而，当邻居状态更差（*ΔE* < 0）时，我们仍然可能将当前状态设置为那个邻居状态，并且我们以概率
    e^(*ΔE/T*) 来这样做。这里的想法是，更负的*ΔE*将导致邻居状态被选择的概率更低，而温度*T*越高，邻居状态被选择的概率就越高。这意味着邻居状态越差，被选择的概率就越低，并且算法在处理过程中越早，将更差的邻居状态设置为当前状态的概率就越高。背后的数学原理如下：e是一个常数（大约为2.72），而*ΔE*是负的（因为邻居状态比当前状态差）。*ΔE*越负，得到的结果值越接近0。温度*T*越高，*ΔE/T*越接近0，使得概率越接近1。
- en: '**Traveling Salesman Problem**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**旅行商问题**'
- en: 'In the traveling salesman problem, the task is to connect all points while
    choosing the shortest possible distance. This is, for example, what delivery companies
    need to do: find the shortest route from the store to all the customers’ houses
    and back.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅行商问题中，任务是连接所有点，同时选择最短的可能距离。例如，这就是配送公司需要做的事情：找到从商店到所有客户家并返回的最短路线。
- en: '![Traveling Salesman Problem](../Images/e762b2e3ad8fe21de0922a081e642b7e.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![旅行商问题](../Images/e762b2e3ad8fe21de0922a081e642b7e.png)'
- en: In this case, a neighbor state might be seen as a state where two arrows swap
    places. Calculating every possible combination makes this problem computationally
    demanding (having just 10 points gives us 10!, or 3,628,800 possible routes).
    By using the simulated annealing algorithm, a good solution can be found for a
    lower computational cost.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个相邻状态可能被视为两个箭头交换位置的状态。计算所有可能的组合使得这个问题计算量很大（仅有10个点就给出了10!，即3,628,800条可能的路径）。通过使用模拟退火算法，可以在较低的计算成本下找到良好的解决方案。
- en: Linear Programming
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性规划
- en: Linear programming is a family of problems that optimize a linear equation (an
    equation of the form y = ax₁ + bx₂ + …).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划是一类优化线性方程（形式为y = ax₁ + bx₂ + …的方程）的问题。
- en: 'Linear programming will have the following components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划将包含以下组件：
- en: 'A cost function that we want to minimize: c₁x₁ + c₂x₂ + … + cₙxₙ. Here, each
    x₋ is a variable and it is associated with some cost c₋.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要最小化的成本函数：c₁x₁ + c₂x₂ + … + cₙxₙ。在这里，每个x₋ 是一个变量，它与一些成本c₋相关联。
- en: A constraint that’s represented as a sum of variables that is either less than
    or equal to a value (a₁x₁ + a₂x₂ + … + aₙxₙ ≤ b) or precisely equal to this value
    (a₁x₁ + a₂x₂ + … + aₙxₙ = b). In this case, x₋ is a variable, and a₋ is some resource
    associated with it, and b is how much resources we can dedicate to this problem.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示为变量之和的约束，该和要么小于或等于某个值（a₁x₁ + a₂x₂ + … + aₙxₙ ≤ b），要么精确等于这个值（a₁x₁ + a₂x₂
    + … + aₙxₙ = b）。在这种情况下，x₋ 是一个变量，a₋ 是与之相关的某种资源，b 是我们可以为这个问题投入的资源量。
- en: Individual bounds on variables (for example, that a variable can’t be negative)
    of the form lᵢ ≤ xᵢ ≤ uᵢ.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的个体界限（例如，一个变量不能为负）的形式为 lᵢ ≤ xᵢ ≤ uᵢ。
- en: 'Consider the following example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: 'Two machines, X₁ and X₂. X₁ costs $50/hour to run, X₂ costs $80/hour to run.
    The goal is to minimize cost. This can be formalized as a cost function: 50x₁
    + 80x₂.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两台机器，X₁和X₂。X₁每小时运行成本为50美元，X₂每小时运行成本为80美元。目标是最小化成本。这可以形式化为一个成本函数：50x₁ + 80x₂。
- en: 'X₁ requires 5 units of labor per hour. X₂ requires 2 units of labor per hour.
    Total of 20 units of labor to spend. This can be formalized as a constraint: 5x₁
    + 2x₂ ≤ 20.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X₁每小时需要5个单位的劳动力。X₂每小时需要2个单位的劳动力。总共需要投入20个单位的劳动力。这可以形式化为一个约束：5x₁ + 2x₂ ≤ 20。
- en: 'X₁ produces 10 units of output per hour. X₂ produces 12 units of output per
    hour. Company needs 90 units of output. This is another constraint. Literally,
    it can be rewritten as 10x₁ + 12x₂ ≥ 90\. However, constraints need to be of the
    form (a₁x₁ + a₂x₂ + … + aₙxₙ ≤ b) or (a₁x₁ + a₂x₂ + … + aₙxₙ = b). Therefore,
    we multiply by (-1) to get to an equivalent equation of the desired form: (-10x₁)
    + (-12x₂) ≤ -90.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X₁每小时产生10个单位的产出。X₂每小时产生12个单位的产出。公司需要90个单位的产出。这是另一个约束。实际上，它可以重写为 10x₁ + 12x₂
    ≥ 90。然而，约束需要是形式（a₁x₁ + a₂x₂ + … + aₙxₙ ≤ b）或（a₁x₁ + a₂x₂ + … + aₙxₙ = b）。因此，我们乘以(-1)以得到一个等效方程，其形式是我们想要的：(-10x₁)
    + (-12x₂) ≤ -90。
- en: An optimizing algorithm for linear programming requires background knowledge
    in geometry and linear algebra that we don’t want to assume. Instead, we can use
    algorithms that already exist, such as Simplex and Interior-Point.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划的优化算法需要我们在几何学和线性代数方面的背景知识，我们不希望假设。相反，我们可以使用已经存在的算法，例如单纯形法和内点法。
- en: 'The following is a linear programming example that uses the scipy library in
    Python:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Python中的scipy库的线性规划示例：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Constraint Satisfaction
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 满足约束
- en: Constraint Satisfaction problems are a class of problems where variables need
    to be assigned values while satisfying some conditions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 满足约束问题是需要分配变量值以满足某些条件的问题类别。
- en: 'Constraints satisfaction problems have the following properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 满足约束问题具有以下属性：
- en: Set of variables (x₁, x₂, …, xₙ)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的集合（x₁, x₂, …, xₙ）
- en: Set of domains for each variable {D₁, D₂, …, Dₙ}
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个变量的域集合 {D₁, D₂, …, Dₙ}
- en: Set of constraints C
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束集合 C
- en: Sudoku can be represented as a constraint satisfaction problem, where each empty
    square is a variable, the domain is the numbers 1-9, and the constraints are the
    squares that can’t be equal to each other.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数独可以表示为一个满足约束问题，其中每个空格都是一个变量，域是数字1-9，约束是不能相等的方格。
- en: 'Consider another example. Each of students 1-4 is taking three courses from
    A, B, …, G. Each course needs to have an exam, and the possible days for exams
    are Monday, Tuesday, and Wednesday. However, the same student can’t have two exams
    on the same day. In this case, the variables are the courses, the domain is the
    days, and the constraints are which courses can’t be scheduled to have an exam
    on the same day because the same student is taking them. This can be visualized
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个例子。学生1-4每人从A、B、…、G中选择三门课程。每门课程都需要进行考试，可能的考试日期是星期一、星期二和星期三。然而，同一位学生不能在同一天参加两次考试。在这种情况下，变量是课程，域是日期，约束是哪些课程不能安排在同一天进行考试，因为同一位学生正在学习它们。这可以表示如下：
- en: '![Constraint Satisfaction Setting](../Images/643aeaec0ec30a4c76af47a4280899fa.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![约束满足设置](../Images/643aeaec0ec30a4c76af47a4280899fa.png)'
- en: 'This problem can be solved using constraints that are represented as a graph.
    Each node on the graph is a course, and an edge is drawn between two courses if
    they can’t be scheduled on the same day. In this case, the graph will look this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过表示为图的约束来解决。图上的每个节点代表一门课程，如果两门课程不能在同一天安排，则在这两门课程之间画一条边。在这种情况下，图将看起来像这样：
- en: '![Constraint Satisfaction Constraints](../Images/5b0cc0007f7cf72706bb0df9a9a84502.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![约束满足约束](../Images/5b0cc0007f7cf72706bb0df9a9a84502.png)'
- en: 'A few more terms worth knowing about constraint satisfaction problems:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于约束满足问题，还有一些术语值得了解：
- en: A **Hard Constraint** is a constraint that must be satisfied in a correct solution.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬约束**是必须在正确解中满足的约束。'
- en: A **Soft Constraint** is a constraint that expresses which solution is preferred
    over others.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软约束**是表达相对于其他解决方案更受偏好的约束。'
- en: A **Unary Constraint** is a constraint that involves only one variable. In our
    example, a unary constraint would be saying that course A can’t have an exam on
    Monday {*A ≠ Monday*}.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元约束**是只涉及一个变量的约束。在我们的例子中，一元约束可能是说课程A不能在星期一进行考试（*A ≠ 星期一*）。'
- en: A **Binary Constraint** is a constraint that involves two variables. This is
    the type of constraint that we used in the example above, saying that some two
    courses can’t have the same value {*A ≠ B*}.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二元约束**是涉及两个变量的约束。这是我们上面例子中使用的那种约束，表示某些两门课程不能有相同的值（*A ≠ B*）。'
- en: Node Consistency
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点一致性
- en: Node consistency is when all the values in a variable’s domain satisfy the variable’s
    unary constraints.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 节点一致性是指一个变量的域中的所有值都满足该变量的单元约束。
- en: For example, let’s take two courses, A and B. The domain for each course is
    {*Monday, Tuesday, Wednesday*}, and the constraints are {*A ≠ Mon, B ≠ Tue, B
    ≠ Mon, A ≠ B*}. Now, neither A nor B is consistent, because the existing constraints
    prevent them from being able to take every value that’s in their domain. However,
    if we remove Monday from A’s domain, then it will have node consistency. To achieve
    node consistency in B, we will have to remove both Monday and Tuesday from its
    domain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑两门课程，A和B。每门课程的域是{星期一，星期二，星期三}，约束是{A ≠ Mon，B ≠ Tue，B ≠ Mon，A ≠ B}。现在，A和B都不一致，因为现有的约束阻止它们能够取它们域中的每一个值。然而，如果我们从A的域中删除星期一，那么它将具有节点一致性。为了在B中实现节点一致性，我们必须从它的域中删除星期一和星期二。
- en: Arc Consistency
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弧一致性
- en: Arc consistency is when all the values in a variable’s domain satisfy the variable’s
    binary constraints (note that we are now using “arc” to refer to what we previously
    referred to as “edge”). In other words, to make X arc-consistent with respect
    to Y, remove elements from X’s domain until every choice for X has a possible
    choice for Y.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 弧一致性是指一个变量的域中的所有值都满足该变量的二元约束（注意我们现在使用“弧”来指代我们之前所说的“边”）。换句话说，为了使X相对于Y弧一致，从X的域中删除元素，直到X的每个选择都有一个可能的Y的选择。
- en: 'Consider our previous example with the revised domains: A:{*Tuesday, Wednesday*}
    and B:{*Wednesday*}. For A to be arc-consistent with B, no matter what day A’s
    exam gets scheduled (from its domain), B will still be able to schedule an exam.
    Is A arc-consistent with B? If A takes the value Tuesday, then B can take the
    value Wednesday. However, if A takes the value Wednesday, then there is no value
    that B can take (remember that one of the constraints is A ≠ B). Therefore, A
    is not arc-consistent with B. To change this, we can remove Wednesday from A’s
    domain. Then, any value that A takes (Tuesday being the only option) leaves a
    value for B to take (Wednesday). Now, A is arc-consistent with B. Let’s look at
    an algorithm in pseudocode that makes a variable arc-consistent with respect to
    some other variable (note that csp stands for “constraint satisfaction problem”).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前的例子，其中领域已进行了修改：A:{*周二, 周三*} 和 B:{*周三*}。为了使 A 与 B 弧一致，无论 A 的考试（从其领域）安排在什么日子，B
    仍然能够安排考试。A 是否与 B 弧一致？如果 A 取值为周二，那么 B 可以取值为周三。然而，如果 A 取值为周三，那么 B 就没有可以取的值（记住，约束条件之一是
    A ≠ B）。因此，A 与 B 不弧一致。为了改变这种情况，我们可以从 A 的领域中删除周三。然后，A 取任何值（周二作为唯一选项）都会为 B 留下一个可以取的值（周三）。现在，A
    与 B 弧一致。让我们看看一个伪代码算法，该算法使一个变量相对于另一个变量弧一致（注意，csp 代表“约束满足问题”）。
- en: 'function Revise(*csp, X, Y*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'function Revise(*csp, X, Y*):'
- en: '*revised* = *false*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*revised* = *false*'
- en: 'for *x* in *X.domain*:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'for *x* in *X.domain*:'
- en: 'if no *y* in *Y.domain* satisfies constraint for (*X,Y*):'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'if no *y* in *Y.domain* satisfies constraint for (*X,Y*):'
- en: delete *x* from *X.domain*
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: delete *x* from *X.domain*
- en: '*revised* = true'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*revised* = true'
- en: return *revised*
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: return *revised*
- en: This algorithm starts with tracking whether any change was made to X’s domain,
    using the variable *revised*. This will be useful in the next algorithm we examine.
    Then, the code repeats for every value in X’s domain and sees if Y has a value
    that satisfies the constraints. If yes, then do nothing, if not, remove this value
    from X’s domain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法从跟踪 X 的领域是否发生了任何更改开始，使用变量 *revised*。这将在我们检查的下一个算法中很有用。然后，代码对 X 的领域中的每个值重复执行，并查看
    Y 是否有满足约束的值。如果有，则什么都不做，如果没有，则从 X 的领域中删除此值。
- en: 'Often we are interested in making the whole problem arc-consistent and not
    just one variable with respect to another. In this case, we will use an algorithm
    called AC-3, which uses Revise:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们感兴趣的是使整个问题弧一致，而不仅仅是相对于另一个变量的一个变量。在这种情况下，我们将使用一个名为 AC-3 的算法，该算法使用 Revise：
- en: 'function AC-3(*csp*):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'function AC-3(*csp*):'
- en: '*queue* = all arcs in *csp*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*queue* = all arcs in *csp*'
- en: 'while *queue* non-empty:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'while *queue* non-empty:'
- en: (*X, Y*) = Dequeue(*queue*)
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*X, Y*) = Dequeue(*queue*)
- en: 'if Revise(*csp, X, Y*):'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'if Revise(*csp, X, Y*):'
- en: 'if size of *X*.domain == 0:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'if size of *X*.domain == 0:'
- en: return *false*
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: return *false*
- en: 'for each *Z* in *X*.neighbors - {*Y*}:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'for each *Z* in *X*.neighbors - {*Y*}:'
- en: Enqueue(queue, (*Z,X*))
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enqueue(queue, (*Z,X*))
- en: return true
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: return true
- en: This algorithm adds all the arcs in the problem to a queue. Each time it considers
    an arc, it removes it from the queue. Then, it runs the Revise algorithm to see
    if this arc is consistent. If changes were made to make it consistent, further
    actions are needed. If the resulting domain of X is empty, it means that this
    constraint satisfaction problem is unsolvable (since there are no values that
    X can take that will allow Y to take any value given the constraints). If the
    problem is not deemed unsolvable in the previous step, then, since X’s domain
    was changed, we need to see if all the arcs associated with X are still consistent.
    That is, we take all of X’s neighbors except Y, and we add the arcs between them
    and X to the queue. However, if the Revise algorithm returns false, meaning that
    the domain wasn’t changed, we simply continue considering the other arcs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法将问题中的所有弧添加到队列中。每次考虑一个弧时，它都会将其从队列中删除。然后，它运行 Revise 算法以查看此弧是否一致。如果进行了更改以使其一致，则需要进一步的操作。如果
    X 的领域为空，这意味着此约束满足问题是不可解的（因为 X 没有任何可以取的值，这将允许 Y 在给定约束的情况下取任何值）。如果在之前的步骤中认为问题不可解，那么由于
    X 的领域已更改，我们需要查看与 X 相关的所有弧是否仍然一致。也就是说，我们取 X 的所有邻居（除了 Y），并将它们之间的弧添加到队列中。然而，如果 Revise
    算法返回 false，意味着领域没有更改，我们只需继续考虑其他弧。
- en: While the algorithm for arc consistency can simplify the problem, it will not
    necessarily solve it, since it considers binary constraints only and not how multiple
    nodes might be interconnected. Our previous example, where each of 4 students
    is taking 3 courses, remains unchanged by running AC-3 on it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然弧一致性算法可以简化问题，但它不一定能解决问题，因为它只考虑二元约束，而不是多个节点可能如何相互连接。我们之前的例子，即每个学生选修3门课程，在运行AC-3后保持不变。
- en: 'We have encountered search problems in our first lecture. A constraint satisfaction
    problem can be seen as a search problem:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一节课中遇到了搜索问题。约束满足问题可以看作是一种搜索问题：
- en: 'Initial state: empty assignment (all variables don’t have any values assigned
    to them).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态：空赋值（所有变量都没有分配任何值）。
- en: 'Actions: add a {*variable = value*} to assignment; that is, give some variable
    a value.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作：将一个 {*variable = value*} 添加到赋值中；即给某个变量赋值。
- en: 'Transition model: shows how adding the assignment changes the assignment. There
    is not much depth to this: the transition model returns the state that includes
    the assignment following the latest action.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换模型：显示添加赋值如何改变赋值。这里没有太多深度：转换模型返回最新操作后的包含赋值的状态。
- en: 'Goal test: check if all variables are assigned a value and all constraints
    are satisfied.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标测试：检查所有变量是否分配了值，以及所有约束是否得到满足。
- en: 'Path cost function: all paths have the same cost. As we mentioned earlier,
    as opposed to typical search problems, optimization problems care about the solution
    and not the route to the solution.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径成本函数：所有路径都有相同的成本。正如我们之前提到的，与典型的搜索问题不同，优化问题关心的是解决方案，而不是通往解决方案的路线。
- en: However, going about a constraint satisfaction problem naively, as a regular
    search problem, is massively inefficient. Instead, we can make use of the structure
    of a constraint satisfaction problem to solve it more efficiently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将约束满足问题天真地当作常规搜索问题来处理，效率非常低。相反，我们可以利用约束满足问题的结构来更有效地解决问题。
- en: Backtracking Search
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回溯搜索
- en: 'Backtracking search is a type of a search algorithm that takes into account
    the structure of a constraint satisfaction search problem. In general, it is a
    recursive function that attempts to continue assigning values as long as they
    satisfy the constraints. If constraints are violated, it tries a different assignment.
    Let’s look at the pseudocode for it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯搜索是一种考虑约束满足搜索问题结构的搜索算法。一般来说，它是一个递归函数，尝试在满足约束的情况下继续分配值。如果违反了约束，它将尝试不同的赋值。让我们看看它的伪代码：
- en: 'function Backtrack(*assignment, csp*):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '函数 Backtrack(*assignment, csp*):'
- en: 'if *assignment* complete:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *assignment* 完成：
- en: return *assignment*
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 *assignment*
- en: '*var* = Select-Unassigned-Var(*assignment, csp*)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*var* = Select-Unassigned-Var(*assignment, csp*)'
- en: 'for *value* in Domain-Values(*var, assignment, csp*):'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *value* 在 Domain-Values(*var, assignment, csp*) 中：
- en: 'if *value* consistent with *assignment*:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *value* 与 *assignment* 一致：
- en: add {*var = value*} to *assignment*
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 {*var = value*} 添加到 *assignment*
- en: '*result* = Backtrack(*assignment, csp*)'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*result* = Backtrack(*assignment, csp*)'
- en: 'if *result* ≠ *failure*:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *result* ≠ *failure*：
- en: return *result*
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 *result*
- en: '*remove* {*var = value*} from *assignment*'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *assignment* 中 *remove* {*var = value*}
- en: return failure
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回失败
- en: In words, this algorithm starts with returning the current assignment if it
    is complete. This means that, if the algorithm is done, it will not perform any
    of the additional actions. Instead, it will just return the completed assignment.
    If the assignment is not complete, the algorithm selects any of the variables
    that do not have an assignment yet. Then, the algorithm tries to assign a value
    to the variable, and runs the Backtrack algorithm again on the resulting assignment
    (recursion). Then, it checks the resulting value. If it is not *failure*, it means
    that the assignment worked out, and it should return this assignment. If the resulting
    value is *failure*, then the latest assignment is removed, and a new possible
    value is attempted, repeating the same process. If all possible values in the
    domain returned *failure*, this means that we need to backtrack. That is, that
    the problem is with some previous assignment. If this happens with the variable
    we start with, then it means that no solution satisfies the constraints.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用话来说，这个算法首先检查当前赋值是否完整。这意味着如果算法完成了，它将不会执行任何额外的操作。相反，它将直接返回完成的赋值。如果赋值不完整，算法将选择任何一个尚未赋值的变量。然后，算法尝试给这个变量赋一个值，并在得到的赋值上再次运行回溯算法（递归）。然后，它检查得到的结果。如果结果不是
    *失败*，这意味着赋值成功，应该返回这个赋值。如果结果是 *失败*，那么将移除最新的赋值，并尝试新的可能值，重复相同的过程。如果域中所有可能的值都返回 *失败*，这意味着我们需要回溯。也就是说，问题出在某个前一个赋值上。如果这种情况发生在我们开始的变量上，那么这意味着没有解决方案满足约束。
- en: 'Consider the following course of action:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下行动方案：
- en: '![Backtracking Example](../Images/98c2abbf18ee4d740e6530da9ffa1853.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![回溯示例](../Images/98c2abbf18ee4d740e6530da9ffa1853.png)'
- en: We start with empty assignments (top left). Then, we choose the variable A,
    and assign to it some value, Monday (top right). Then, using this assignment,
    we run the algorithm again. Now that A already has an assignment, the algorithm
    will consider B, and assign Monday to it (bottom left). This assignment returns
    false, so instead of assigning a value to C given the previous assignment, the
    algorithm will try to assign a new value to B, Tuesday (bottom right). This new
    assignment satisfies the constraints, and a new variable will be considered next
    given this assignment. If, for example, assigning also Tuesday or Wednesday to
    B would bring to a failure, then the algorithm would backtrack and return to considering
    A, assigning another value to it, Tuesday. If also Tuesday and Wednesday return
    *failure*, then it means we have tried every possible assignment and the problem
    is unsolvable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从空赋值（左上角）开始。然后，我们选择变量 A，并给它赋一个值，比如周一（右上角）。接着，使用这个赋值，我们再次运行算法。现在 A 已经有了赋值，算法将考虑
    B，并将周一赋给它（左下角）。这个赋值返回 false，所以算法不会在给定的前一个赋值的基础上给 C 赋值，而是尝试给 B 赋一个新的值，周二（右下角）。这个新的赋值满足约束条件，因此将根据这个赋值考虑下一个变量。例如，如果给
    B 赋周二或周三也会导致失败，那么算法将回溯并回到考虑 A，给它赋另一个值，周二。如果周二和周三都返回 *失败*，那么这意味着我们已经尝试了所有可能的赋值，问题是无解的。
- en: In the source code section, you can find an implementation from scratch of the
    backtrack algorithm. However, this algorithm is widely used, and, as such, multiple
    libraries already contain an implementation of it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码部分，你可以找到一个从头开始实现的回溯算法。然而，这个算法被广泛使用，因此多个库已经包含了它的实现。
- en: '**Inference**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**推理**'
- en: Although backtracking search is more efficient than simple search, it still
    takes a lot of computational power. Enforcing arc consistency, on the other hand,
    is less resource intensive. By interleaving backtracking search with inference
    (enforcing arc consistency), we can get at a more efficient algorithm. This algorithm
    is called the **Maintaining Arc-Consistency** algorithm. This algorithm will enforce
    arc-consistency after every new assignment of the backtracking search. Specifically,
    after we make a new assignment to X, we will call the AC-3 algorithm and start
    it with a queue of all arcs (*Y,X*) where Y is a neighbor of X (and not a queue
    of all arcs in the problem). Following is a revised Backtrack algorithm that maintains
    arc-consistency, with the new additions in **bold**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Although backtracking search is more efficient than simple search, it still
    takes a lot of computational power. Enforcing arc consistency, on the other hand,
    is less resource intensive. By interleaving backtracking search with inference
    (enforcing arc consistency), we can get at a more efficient algorithm. This algorithm
    is called the **Maintaining Arc-Consistency** algorithm. This algorithm will enforce
    arc-consistency after every new assignment of the backtracking search. Specifically,
    after we make a new assignment to X, we will call the AC-3 algorithm and start
    it with a queue of all arcs (*Y,X*) where Y is a neighbor of X (and not a queue
    of all arcs in the problem). Following is a revised Backtrack algorithm that maintains
    arc-consistency, with the new additions in **bold**.` '
- en: 'function Backtrack(*assignment, csp*):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`function Backtrack(*assignment, csp*):`'
- en: 'if *assignment* complete:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if *assignment* complete:` '
- en: return *assignment*
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return *assignment*`'
- en: '*var* = Select-Unassigned-Var(*assignment, csp*)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*var* = Select-Unassigned-Var(*assignment, csp*)`'
- en: 'for *value* in Domain-Values(*var, assignment, csp*):'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for *value* in Domain-Values(*var, assignment, csp*):`'
- en: 'if *value* consistent with *assignment*:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if *value* consistent with *assignment*:` '
- en: '**add {*var = value*} to *assignment***'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将** `{*var = value*}` **添加到** `*assignment***`'
- en: '***inferences* = Inference(*assignment, csp*)**'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`***inferences* = Inference(*assignment, csp*)**`'
- en: 'if *inferences* ≠ *failure*:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if *inferences* ≠ *failure*:` '
- en: add *inferences* to *assignment*
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add *inferences* to *assignment*`'
- en: '*result* = Backtrack(*assignment, csp*)'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*result* = Backtrack(*assignment, csp*)`'
- en: 'if *result* ≠ *failure*:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if *result* ≠ *failure*:`'
- en: return *result*
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return *result*`'
- en: '*remove* {*var = value*} **and *inferences*** from *assignment*'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*remove* `{*var = value*}` **and *inferences*** from *assignment*`'
- en: return failure
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return failure`'
- en: The Inference function runs the AC-3 algorithm as described. Its output is all
    the inferences that can be made through enforcing arc-consistency. Literally,
    these are the new assignments that can be deduced from the previous assignments
    and the structure of the constrain satisfaction problem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`The Inference function runs the AC-3 algorithm as described. Its output is
    all the inferences that can be made through enforcing arc-consistency. Literally,
    these are the new assignments that can be deduced from the previous assignments
    and the structure of the constrain satisfaction problem.` '
- en: There are additional ways to make the algorithm more efficient. So far, we selected
    an unassigned variable randomly. However, some choices are more likely to bring
    to a solution faster than others. This requires the use of heuristics. A heuristic
    is a rule of thumb, meaning that, more often than not, it will bring to a better
    result than following a naive approach, but it is not guaranteed to do so.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`There are additional ways to make the algorithm more efficient. So far, we
    selected an unassigned variable randomly. However, some choices are more likely
    to bring to a solution faster than others. This requires the use of heuristics.
    A heuristic is a rule of thumb, meaning that, more often than not, it will bring
    to a better result than following a naive approach, but it is not guaranteed to
    do so.` '
- en: '**Minimum Remaining Values (MRV)** is one such heuristic. The idea here is
    that if a variable’s domain was constricted by inference, and now it has only
    one value left (or even if it’s two values), then by making this assignment we
    will reduce the number of backtracks we might need to do later. That is, we will
    have to make this assignment sooner or later, since it’s inferred from enforcing
    arc-consistency. If this assignment brings to failure, it is better to find out
    about it as soon as possible and not backtrack later.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小剩余值 (MRV)** **是** **一种** **这样的启发式方法**。 **这里的想法是**，如果变量的域被推理所限制，并且现在只剩下一个值（或者甚至两个值），那么通过做出这个赋值，我们将减少以后可能需要回溯的次数。
    **也就是说**，由于它是由强制弧一致性推断出来的，我们迟早需要做出这个赋值。 **如果这个赋值导致失败**，那么最好尽快发现它，而不是稍后回溯。'
- en: '![Minimum Remaining Values](../Images/78ec41dba9207c943aa1bc258c96392e.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![剩余值最小](../Images/78ec41dba9207c943aa1bc258c96392e.png)'
- en: For example, after having narrowed down the domains of variables given the current
    assignment, using the MRV heuristic, we will choose variable C next and assign
    the value Wednesday to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`For example, after having narrowed down the domains of variables given the
    current assignment, using the MRV heuristic, we will choose variable C next and
    assign the value Wednesday to it.` '
- en: The **Degree** heuristic relies on the degrees of variables, where a degree
    is how many arcs connect a variable to other variables. By choosing the variable
    with the highest degree, with one assignment, we constrain multiple other variables,
    speeding the algorithm’s process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**度启发式**依赖于变量的度数，其中度数是一个变量与其他变量连接的弧的数量。通过选择具有最高度的变量，通过一次分配，我们可以约束多个其他变量，从而加快算法的进程。'
- en: '![Degree Heuristic](../Images/a73427e976c7f1bf3b737d36c8536213.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![度启发式](../Images/a73427e976c7f1bf3b737d36c8536213.png)'
- en: For example, all the variables above have domains of the same size. Thus, we
    should pick a domain with the highest degree, which would be variable E.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述所有变量的定义域大小相同。因此，我们应该选择具有最高度的定义域，这将变量E。
- en: Both heuristics are not always applicable. For example, when multiple variables
    have the same least number of values in their domain, or when multiple variables
    have the same highest degree.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种启发式方法并不总是适用。例如，当多个变量的定义域中具有相同的最小值数时，或者当多个变量的度数相同时。
- en: Another way to make the algorithm more efficient is employing yet another heuristic
    when we select a value from the domain of a variable. Here, we would like to use
    the **Least Constraining Values** heuristic, where we select the value that will
    constrain the least other variables. The idea here is that, while in the degree
    heuristic we wanted to use the variable that is more likely to constrain other
    variables, here we want this variable to place the least constraints on other
    variables. That is, we want to locate what could be the largest potential source
    of trouble (the variable with the highest degree), and then render it the least
    troublesome that we can (assign the least constraining value to it).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种提高算法效率的方法是在从变量的定义域中选择一个值时采用另一种启发式方法。在这里，我们希望使用**最小约束值**启发式，即选择将最少约束其他变量的值。这里的想法是，虽然在我们使用度启发式时，我们希望使用更有可能约束其他变量的变量，但在这里我们希望这个变量对其他变量的约束最少。也就是说，我们希望找到可能成为最大潜在问题来源（度最高的变量），然后将其变得尽可能不麻烦（给它分配最小约束值）。
- en: '![Least Constraining Value](../Images/ec333f0c71bdf122f12b53e6dd15389f.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![最小约束值](../Images/ec333f0c71bdf122f12b53e6dd15389f.png)'
- en: For example, let’s consider variable C. If we assign Tuesday to it, we will
    put a constraint on all of B, E, and F. However, if we choose Wednesday, we will
    put a constraint only on B and E. Therefore, it is probably better to go with
    Wednesday.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑变量C。如果我们将其分配给星期二，我们将对B、E和F的所有变量施加约束。然而，如果我们选择星期三，我们只会在B和E上施加约束。因此，选择星期三可能更好。
- en: To summarize, optimization problems can be formulated in multiple ways. Today
    we considered local search, linear programming, and constraint satisfaction.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，优化问题可以用多种方式来表述。今天我们考虑了局部搜索、线性规划和约束满足。
