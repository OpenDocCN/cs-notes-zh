- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P6：L3- 算法（结构体、搜索与排序）1 - ShowMeAI - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P6：L3- 算法（结构体、搜索与排序）1 - ShowMeAI - BV1Hh411W7Up
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_0.png)'
- en: three。![](img/0a07aadb299f2538eddc3c64659844e7_2.png)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 三个。![](img/0a07aadb299f2538eddc3c64659844e7_2.png)
- en: and you'll recall that last week we，which to solve，problems not only problems
    that we had。proposed but problems in your own code，that is to say bugs and recall
    that，those tools involve。help with，cryptic error messages that the compiler，might
    spit out style 50 which gives you。a bit of feedback on the stylization of，your
    code the aesthetics thereof。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得上周我们讨论了解决问题的方法，不仅是我们提出的问题，还有你自己代码中的问题，也就是*错误*。这些工具涉及到帮助你解决编译器可能吐出的神秘错误消息，风格检查工具会给你关于代码风格的一些反馈。
- en: check 50 which checks the correctness of，your code against，the specifications
    in a given problem。set or lab printf，which is a function that exists in some，form
    in almost any programming language。that you might ultimately，learn and this is
    simply a way of，printing out anything you might want。screen，then perhaps the most
    powerful of these，tools was debug 50 which was this。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: check 50会检查你的代码在给定问题集或实验中的正确性，而printf是几乎所有编程语言中都存在的一种函数，这也是你最终可能学到的。这只是打印你想在屏幕上显示的任何内容的一种方式，接下来这些工具中最强大的就是debug
    50。
- en: interactive debugger and even though，this command debug 50，is a little specific
    to cs50 what it。triggers to happen that little side，window where you can see，have
    called。uh during some break point and you can，see the local variables that you
    might。have defined at some point，during the execution of your code that's，a very
    common conventional。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式调试器，尽管这个命令debug 50有些特定于cs50，但它会触发一个小侧窗口，在那里你可以查看在某些断点时调用的内容，以及在代码执行的某个时刻你可能定义的局部变量，这是一个非常常见的约定。
- en: feature of any debugger with most any，language and then lastly recall there，was
    this ddb。duck debugger which of course takes this，physical form if you happen
    to have a，can talk。but i'm so pleased to say that if you，lack that currently，while
    at home cs50 zone kareem and。brenda and sophie have wonderfully added，if you haven't
    noticed already。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何调试器的特性与大多数语言相符，最后回想一下，还有这个ddb鸭子调试器，当然它以这种物理形态存在，如果你恰好有一个可以交谈的鸭子，但我很高兴地说，如果你目前没有，在家时cs50区的Kareem、Brenda和Sophie已经做了很棒的补充，如果你还没有注意到的话。
- en: that same virtual duck to cs50 ide so if，you click in the top corner。![](img/0a07aadb299f2538eddc3c64659844e7_4.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的虚拟鸭子在cs50 ide中，所以如果你点击左上角。![](img/0a07aadb299f2538eddc3c64659844e7_4.png)
- en: you can actually begin to have a chat of，sorts with the rubber duck and while。this
    is certainly a more playful，incarnation of that same idea we really。can't emphasize
    enough the value，of talking through problems when you're，experiencing them in
    code。with someone else or with something else，this particular duck，not all that
    large of a vocabulary but。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以开始和橡皮鸭进行某种对话，虽然这无疑是同一概念的更具玩味的表现形式，但我们真的无法过分强调，和其他人或其他东西谈论代码中的问题时，*讨论问题*的价值。
- en: it's not so much what the other person，says but what you say and what you hear，yourself
    saying。that is undoubtedly the most valuable，part of the process so our thanks
    to。kareem and brenda and sophie on that，recall last week too，that we took a look
    underneath the hood。literally in some sense，at the computer's memory in your laptop，to。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是其他人说了什么，而是你说了什么以及你自己听到自己说的内容，这无疑是这个过程最有价值的部分，因此我们感谢Kareem、Brenda和Sophie。上周我们也仔细看看了电脑的内存，字面意义上在你的笔记本电脑里。
- en: think about this more artistically as，just a grid of，bytes so within that chip
    there's a。whole bunch of bits and if you，look at eight of them at a time there's。a
    whole bunch of bytes and it stands for，reason that we could think of this as，third
    byte。and so forth and sort of chop this up，pictorially into just a whole，memory。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更艺术地思考这个问题，将其视为一个字节网格，在这个芯片内有一堆位，如果你一次查看八个，它们就形成了一堆字节，想象这个作为第三个字节，依此类推，将其形象化分割成一个完整的内存。
- en: and recall that if we zoom in on that，and focus on just one contiguous，array。we
    can do things within this array like，storing a bunch of different values so，recall
    last week。we started by defining a little uh，goofily，multiple variables that were
    almost。identically named like uh scores one，scores two scores three and then we。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，如果我们放大并专注于一个连续的数组。我们可以在这个数组中做一些事情，比如存储一堆不同的值。回想一下上周，我们开始时定义了一些有点傻的、几乎相同名称的多个变量，比如
    scores one、scores two 和 scores three，然后我们。
- en: began to clean up the design of our code，by introducing an array so we can have。just
    one variable called scores，that is of size three and has room for，multiple values，feature。of
    many programming languages being able，to store things contiguously back to。back
    to back to back in a computer's，memory because this very，simple layout this very
    simple feature。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开始通过引入一个数组来清理我们的代码设计，这样我们就可以有一个名为 scores 的变量，大小为三，有空间存储多个值，这是许多编程语言的一个特性，能够在计算机的内存中连续存储数据，因为这个非常简单的布局，这个非常简单的特性。
- en: of the language is going to open up all，sorts of powerful features and in fact。we
    can even revisit some of the some of，the problems we tried to solve，with the raise，last
    week。and that's because even though you and i，can glance at this picture on the
    screen。and see immediately that though there's，seven boxes on the screen there's
    seven。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语言将开启各种强大的特性，实际上。我们甚至可以重温上周我们尝试解决的一些问题。这是因为即使你我可以一眼看清屏幕上的这个图片，并立即看到，尽管屏幕上有七个框，但实际上是七个。
- en: locations in which you can store values，you and i can sort of have this bird's。eye
    view of everything and just see，what's inside that entire array，much more。methodical
    more algorithmic if you will，and so a computer，as powerful as they are can technically。only
    look at one location in an array，at a time so whereas you and i can。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 存储值的位置，你我可以在一定程度上拥有这种鸟瞰视角，看到整个数组内部，方式更为系统，更算法化，如果你愿意，所以尽管计算机非常强大，技术上只能一次查看数组中的一个位置，因此你我可以。
- en: glance at this and sort of take it all，in at once a computer just can't glance。at
    its memory and take in，all at once all of the values they're in，instance。from
    left to right maybe right to left，maybe middle，onward but it has to be an algorithm
    and，really。kind of hide the fact that this array，cannot be seen all at once you
    can only。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一瞥这个并试图一下子理解，计算机无法一眼看清它的内存并一次性接受所有值。它可能从左到右，或从右到左，也可能是中间开始，但它必须是一个算法，确实。某种程度上掩盖了这个数组无法一次性看到的事实，你只能。
- en: look at one location in an array，at a given time and this is going to。have very
    real implications for instance，if we consider that very first problem。in the very
    first week where we tried to，find my phone number in a phone book the，beginning。and
    search from left to right and we，tried a couple of variants thereafter，but the
    problem。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某一时刻查看数组中的一个位置，这将有非常现实的影响。例如，如果我们考虑第一个问题，在第一周我们尝试在电话簿中找到我的电话号码，开始时。并从左到右搜索，我们之后尝试了一些变体，但问题。
- en: quite simply is that of searching and，science，super common certainly for you
    and i as。users on google and the like to search，for things all day long，and so
    certainly searching well。designing a search algorithm well，is certainly a compelling
    feature of so。many of today's tools that you and i use，so if we think of this
    really as a。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，搜索和科学是非常常见的，确实你我作为用户在谷歌等网站上整天搜索东西，因此设计一个优秀的搜索算法无疑是许多今天工具的一个引人注目的特性，你我都在使用。所以如果我们真的把这看作是一个。
- en: problem to solve we've got some input，which for instance might be an array of。numbers
    or maybe an array of web pages，in the case of google。and the goal is to get some
    output so if，the input to the problem is an array。of values the output hopefully
    is going，to be something as simple really。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决的问题是，我们有一些输入，可能是一个数字数组，或者在谷歌的情况下，可能是一个网页数组。目标是得到一些输出，因此如果问题的输入是一个值的数组，输出希望是一些简单的东西。
- en: as a bool yes or no is the value you're，looking for，that value。yes or no true
    or false now within this，black box recall，is going to be some algorithm and that's。where
    today we'll spend most of our time，indeed we won't really introduce that。many
    more features of c we won't，focus again on，ideas just taking for granted now that。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个布尔值，“是”或“否”是你正在寻找的值，即这个值。“是”或“否”，“真”或“假”，现在在这个黑箱中，回想一下，会有一些算法，这就是今天我们大部分时间要讨论的内容，实际上我们不会真正介绍那么多
    C 的其他特性，我们将再次专注于，现在理所当然的想法。
- en: you have some more tools in your toolkit，beyond loops and conditions and boolean。expressions
    we now have this other tool，known as arrays but let's first，introduce some。some
    other terms of art some jargon if，you will related to what we'll call。running
    time so we've alluded to this a，few times when we're thinking about just。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你在工具箱中有更多工具，除了循环、条件和布尔表达式。现在我们有这个被称为数组的其他工具，但首先让我们介绍一些相关术语，关于我们将称之为运行时间的东西。当我们思考这些时，我们提到过几次。
- en: how good or bad an algorithm is，we describe how long it takes to run。that is
    it's running time the running，takes，how many steps it takes how many seconds。it
    takes how many iterations it takes it，doesn't really matter。what your unit of
    measure is maybe it's，else，but running time just refers to how long。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述算法的好坏时，会说明它的运行时间。也就是说，它的运行时间取决于需要多少步骤、多少秒、多少次迭代，这些单位并不重要。运行时间只是指需要多久。
- en: does an algorithm take，and there are ways that we can think，about this a little
    more formally and we。week，but we didn't give it this name this，italicized，o this
    capital o on the screen is。otherwise known as big，o notation and computer scientists
    and，use。literally this symbol to describe the，running times of algorithms or，mathematically
    like a function。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 算法需要多少时间，我们可以更正式地思考这个问题。在这一周，我们没有给它这个名字，这个斜体的 O，屏幕上的大 O 符号被称为大O表示法，计算机科学家们使用这个符号来描述算法的运行时间，或数学上像一个函数。
- en: so recall this picture in fact when we，were searching that phone book。we did
    it sort of good better best we，did it linearly，that is searching one page at a
    time we。did it twice as fast，by doing two pages at a time and then we，did it logarithmically。by
    dividing and conquering in half and，half and half and at the time i proposed，having
    n。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下这个画面，实际上当我们在查找电话簿时。我们是以“好、好点、最好”的顺序进行的，线性搜索，一个页面一个页面地搜索。我们通过每次搜索两页的方式提高了速度，然后我们进行了对数搜索，通过不断对半分割来实现。
- en: pages where n is just a number uh in，computer science vernacular。we might describe
    the running time or，the number of steps involved for that。first algorithm as being
    maybe in the，worst case，n steps if the person you're looking for。in a phone book
    maybe alphabetically has，a last name starting with z。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 页面中 n 只是一个数字，在计算机科学术语中。我们可能会描述第一个算法的运行时间或步骤数，可能在最坏情况下需要 n 步，如果你在电话簿中寻找的人，可能有一个以
    z 开头的姓氏。
- en: in english well the z might be all the，way at the end of the phone book so at。the
    worst case you might be taking，that phone book，the second algorithm though was
    twice as。fast because we went two pages at a time，so we might describe its running
    time as。n divided by two and then the third，algorithm where we divided the problem。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语来说，z 可能位于电话簿的最后，因此在最坏情况下你可能需要查找整个电话簿，而第二个算法却快了两倍，因为我们每次查看两页，所以我们可以将其运行时间描述为
    n/2，然后第三个算法是我们将问题进行了分割。
- en: in half and half and a half，literally throwing half of the problem，away again
    and again，of n。which again is just a mathematical，formula that refers to having
    something。again and again and again and you start，with of course n pages in that
    scenario。well it turns out that a computer，hands，at some of these mathematical
    details。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一直对半分割，实际上是一次又一次地丢弃一半的问题，n。这再次是一个数学公式，指的是不断重复某个操作，当然在这种情况下你一开始有 n 页。结果证明计算机在这些数学细节上表现得相当出色。
- en: indeed we're not going to get into the，habit of writing very。precise mathematical
    formulas what we're，instead going to do is try to get a，sense of the。algorithm
    is，just roughly how fast or how slow it is，but still using some symbology like
    n as。a placeholder and so a computer，scientist would describe the running，time
    of all three。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们不会养成写非常精确的数学公式的习惯，而是会尽量理解算法的概念，粗略地了解它是多么快或多么慢，但仍然使用一些符号，比如 n 作为占位符。因此，计算机科学家会描述三者的运行时间。
- en: of those algorithms from week zero as，being big o，of n or big o of n over two
    or big o of。log base two，of n so big o just means on the order of，it's sort of
    a wave of the hand maybe。it's n minus one，maybe it's n plus one maybe it's even，two
    n but it's on the order of n，notice。this chart there's something kind of，curious
    like these first two algorithms，from week zero。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法来自于零周，作为大O，O(n) 或大O，O(n/2) 或大O，O(log₂(n))，所以大O只是表示在某个顺序上，这可能是一种随意的表示。它是
    n 减 1，也许是 n 加 1，甚至可能是 2n，但它在 n 的顺序上，注意这个图表，这里有些，奇怪的地方，比如这两个算法，来自于零周。
- en: kind of pictorially look pretty much the，same like undoubtedly the yellow line
    is。a little lower and therefore a little，better and a little faster than the red。line
    but they have the same shape and in，fact i bet if we zoomed way out。these two
    straight lines would pretty，axis，to be big enough and tall enough these，the green
    line。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像上看，几乎看起来是一样的，毫无疑问，黄色线略低，因此稍微好一些，稍微快一些，但它们有相同的形状。事实上，我打赌如果我们大幅缩小，这两条直线会变得相当大，足够大且高，这就是绿色线。
- en: is fundamentally different and so this，tendency，to not really quibble over these
    details，zero。was better yes this yellow line is，algorithms，running times on the
    order of n that is。to say a computer scientist tends to，throw away，constant factors
    like the one-half or。the divided by two and they tend to，focus only on the dominant
    factor like。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 是根本不同的，所以这种不纠结细节的倾向，零。是更好的，是的，这条黄色线是算法，其运行时间的量级是**n**。也就是说，计算机科学家往往会忽略常数因子，比如1/2或除以2，他们倾向于只关注主导因子。
- en: which value in that mathematical，expression is going to，grow the most grow the
    fastest and n。divided by 2，n is going to dominate over time the，bigger the phone
    book gets the more，pages you have。it's really n that's going to matter，less so
    than that divided by two and。same thing over here if you're familiar，with and
    remember your logarithms。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个数学表达式中，哪个值会增长得最快，**n**。除以2，**n**会随着时间的推移占主导地位，电话簿越大，你拥有的页面就越多。真正重要的是**n**，而不是除以二的结果。同样，如果你熟悉并记得你的对数。
- en: we don't really have to even care about，2 but，we can just multiply that logarithm
    by。some other number to convert it to any，base we want base 10 base 3 base 7。anything
    so let's just say it's on the，order of log n so this is good because。it means
    we're not really going to waste，time getting really into the weeds。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们其实不需要关心2，但是，我们可以将这个对数乘以其他数字，将其转换为我们想要的任何基数，比如10，3，7。任何基数，所以我们可以说它的量级是**log
    n**，这很好，因为这意味着我们不会浪费时间深入细节。
- en: mathematically when we talk about the，efficiency of algorithms，terms of。the
    variable n in this case if you will，let's zoom out，if i zoom out on this picture
    boom you。begin to see that yeah，these are really starting to look almost。identical
    and if we kept zooming out you，would see that，they're essentially one and the
    same but。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学上，当我们谈论算法的效率时，是以**n**这个变量为基础的。如果你愿意，让我们缩小视野，如果我在这个图像上缩小，你开始看到，确实这些看起来几乎是相同的。如果我们继续缩小，你会看到它们本质上是一回事。
- en: the green one stands out，so that's indeed on the order of log of，n as opposed
    to n itself。so here's a little cheat sheet it turns，within，alg the analysis of
    algorithms we're。![](img/0a07aadb299f2538eddc3c64659844e7_6.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色的那个很突出，所以这确实是以**log n**为量级，而不是**n**本身。所以这里有一个小的备忘单，在算法分析中，我们的确是这样的。![](img/0a07aadb299f2538eddc3c64659844e7_6.png)
- en: going to tend to see some common，formulas like this so we've just seen on，the
    order of n。we've seen on the order of log n it，turns out that very common two，n
    squ*red。and then even big o of one and the last，takes，wonderfully one step or
    maybe two steps。maybe even 10 steps，but a constant number of steps so that's，sort
    of the best case scenario。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到一些常见的公式，像是我们刚刚看到的量级是**n**。我们看到量级是**log n**，结果是非常常见的**2n平方**。然后甚至还有大O的1，最后的情况是，做一步或两步，可能甚至10步，但都是常数步数，所以这算是最好的情况。
- en: at least among these options whereas n，squ*red is going to start to take a long。time
    it's going to start to feel slow，because if you take any value of n and。squ*re
    it that's going to imply，more and more steps so just a bit of，jargon then to start
    off today。whereby we now have this sort of，vocabulary with which to describe。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在这些选项中，而**n平方**会开始需要很长时间，它会开始感觉慢，因为如果你取任何值的**n**并平方它，那将意味着更多的步骤。所以今天开场时先讲一点行话。我们现在有这样的词汇来描述。
- en: the running times of an algorithm in，terms of this big o notation，as。big o refers
    to an upper bound on，running times like uh like how many。steps maximally how much
    time maximally，might an algorithm take，opposite。what's a lower bound on the running
    tom，of an algorithm and we don't need。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的运行时间用这个大O符号来表示。大O表示运行时间的上限，比如说，算法最多可能需要多少步骤，最多需要多少时间，反之，算法的运行时间的下限是什么，我们并不需要。
- en: another picture or other formulas we can，here，just proposes that when describing
    the，algorithm。and you want to come up with a lower，bound like minimally how many
    steps does，my algorithm take。we can use the same mathematical，formulas but we
    connote that with。omega instead of big o so again looks，fancy but it really just
    refers to a。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个图示或其他公式我们可以，在这里，只是提出当描述算法时。你想提出一个下限，例如我的算法最少需要多少步。我们可以使用相同的数学公式，但我们用Ω而不是大O，所以看起来华丽，但实际上它只是指一个。
- en: wave of the hand trying to sort of，ballpark exactly what，thankfully。we've seen
    a few algorithms already，including in that week zero。and now we're going to give
    it a more，formal name linear search is what we did。with that phone book first
    off by，searching it page by page by page。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 手挥动，试图大致估算，幸好。我们已经见过一些算法，包括在零周。现在我们要给它一个更正式的名称，线性搜索就是我们做的。我们通过逐页搜索电话簿来进行的。
- en: looking for my phone number in that，particular example，and so the difference
    today is that。unlike us humans can who can sort of，look down at a phone book page
    and see a。whole bunch of names and numbers at once，unlike a human who can look
    at an array，see。everything at once we need to be more，methodical more deliberate
    today so that，we can translate。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个特定例子中寻找我的电话号码，因此今天的不同之处在于。与能够查看电话簿页面并一次看到许多名字和数字的人类不同，我们需要更加有条理，更加刻意，今天我们才能翻译。
- en: pseudo code，but actual c code and so wonderfully，as we are，on harvard's campus
    this semester we've。been collaborating with，uh the whole team here who are much
    more，could be。on my own here and we have these seven，wonderful doors that were
    previously，took place here。in this theater and we've even，shop，who in back have
    wonderfully，manufactured some delightful。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码，但实际上是C代码，所以很高兴，在哈佛校园这个学期我们与整个团队合作，他们更擅长。独自一人，我有这七扇美妙的门，它们之前出现在这个剧院里，我们甚至有商店，谁在后面制造了一些令人愉快的。
- en: numbers and brought them to life which，is to say that behind each of these，seven
    doors。is a number and this is going to be an，opportunity now to really hammer
    home。the point that when we want to search，for some number in an array。it's pretty
    equivalent to having to，search for a number，door，you and i can't just look at
    all of。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数字，并将它们带入生活，这意味着在这七扇门后面。每扇门后都有一个数字，这将是一个机会，真正强调当我们想在数组中搜索某个数字时。实际上就等同于搜索一个数字门，你我不能只是看所有的。
- en: number is，we have to be more methodical we have to，start searching these doors
    maybe from。left to right maybe from right to left，maybe from the middle on，out
    but we need to come up with an。to code，so for instance suppose i were to search，for
    the number zero，how could we go about searching。methodically these seven，wooden
    doors for the number zero let me，take a suggestion from the。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是，我们必须更加有条理，我们需要从这些门开始搜索，可能从左到右，可能从右到左，也可能从中间向外，但我们需要提出一个。代码的方案，例如假设我要搜索数字零，我们该如何有条理地搜索这七扇木门中的数字零呢？让我听听建议。
- en: audience what approach might you take，here，on my own with these doors any，recommendations。how
    do i begin to find myself the number，zero florence what do you propose。um i would
    propose starting from the，left since zero is one a smaller。number okay good and
    hang in there for，with me for just a moment let me go，proposes。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 听众，你可能在这里采取什么方法，独自面对这些门，有什么建议？我该如何开始找到数字零，佛罗伦萨，你有什么提议？嗯，我会建议从左边开始，因为零是一个较小的数字。好的，等一下，稍等我一下，让我提出。
- en: go ah**d and open the door and hopefully，voila no，it's a number four so it's
    not a zero so。florence what would you propose i do，next，um i would probably，start
    in the middle somewhere if like。one so，okay so maybe it's going down so let me，go
    ah**d and try that so you propose。middle i could go over here and voila，nope that's
    the number two and。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哦**d并打开门，希望能找到，不，这是数字四，所以不是零。那么，佛罗伦萨，你提议我接下来做什么，嗯，我可能会从中间开始，比如一，所以，好的，可能是向下走，所以让我去哦**d并试试，所以你提议。中间，我可以去这里，哇，不，这是数字二。
- en: i wonder where else should i should i，look let me i'm a little curious i'm a。little
    nervous that i ignore these doors，ahead and look here，and nope that's the number
    six it seems。uh let's go ah**d and check in here the，number，down，so florence how
    might i finish searching。for this number what remains，to be done would you say
    probably start，from the right。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我想知道我还应该去哪里看，我有点好奇，也有点紧张，是否忽视了这些门，往前看看，哦不，那是数字六。我们继续看看这里的数字，往下走，所以**弗朗西斯**，我该如何完成对这个数字的搜索？还需要做什么？你会说应该从右边开始。
- en: okay so i could start from the right now，and maybe just go over here。and voila
    and there it is so we found，the number zero so let me ask florence。what was your
    algorithm how did you go，about so successfully finding the number，zero for us，like。by
    going down by one so uh，like if uh the number was not at the，like，don't know。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我可以从右边开始，也许就在这里走过来。瞧，它就在这里，我们找到了数字零。那么让我问**弗朗西斯**，你的算法是什么，你是怎么成功找到数字零的，比如，下降一步，如果数字不在这里，像是，我不知道。
- en: and playfully how did how did that work，out for you going to the middle。better
    worse no different i mean i，i guess uh maybe it helped a little bit。to then go
    all the way to the right，okay yeah we might have gleaned some。information but
    let's go ah**d and take，a look at all of the doors for a moment。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 轻松地问问，你在中间时，这样做效果如何？更好、坏、还是没有区别？我想，可能确实有点帮助，然后一直往右走，好的，是的，我们可能获得了一些信息，但让我们继续看一下所有的门。
- en: there's that four and the six again，here's that eight again over in the，middle
    we had the two。again over here we have a seven uh，for the first time over here
    we have a。five and then of course we have a zero，and if you took all of that in
    honestly。florence you and i we couldn't really，have done any better because these
    door。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那个四和六又来了，那个八又出现在中间，之前有个二，现在这里有个七，第一次在这里出现的五，当然还有零。如果你认真考虑这一切，**弗朗西斯**，你我其实没有做得更好，因为这些门。
- en: these numbers it turns out，are just randomly arranged behind these。doors so
    it wasn't bad at all that you，kind of hopped around，although the downside is if
    you hop。around you know you and i as humans can，pretty easily remember where we've
    been。before but if you think about how we，would translate that to code。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字实际上是随机排列在这些门后面，所以你随意跳动其实并没有什么坏处，尽管缺点是，如果你跳来跳去，你和我作为人类可以相对轻松地记住我们去过哪里，但如果你想一下如何将其转换为代码。
- en: i feel like we're starting to accumulate，a bunch of variables maybe because
    you。have to keep track of that，so frankly maybe the simplest solution，have been。where
    we started in week 0 where we just，take a very simple if naive approach。of starting
    with our array this time of，size seven，behind which are some numbers and if you。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得我们开始积累了一堆变量，可能是因为你得跟踪这些，所以坦白说，最简单的解决方案可能是从第0周开始，我们采取非常简单的天真的方法，从这个大小为七的数组开始，后面有一些数字，如果你。
- en: don't know anything，about those numbers honestly the best，you can do。is just
    that same linear search from，week zero，and just check one at a time the values。behind
    each of these doors and just，hope that eventually you will find it。so this is
    already sort of taking a lot，of time right if i do this linear。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我对那些数字一无所知，坦白说，你能做的最好就是从第零周开始那种线性搜索，一次检查一个值在这些门后，只希望最终能找到。所以，这已经占用了很多时间，如果我这样做线性。
- en: search approach like i did in week 0 i'm，behind，all of those doors i'm going
    to have to。search behind all of those doors so，let's consider a little more formally。exactly
    how i could at least implement，that algorithm because i could take the。approach
    that florence proposed i'm just，kind of jumping around and maybe using a，bit of
    intuition。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索方法就像我在第0周所做的一样，我得在所有这些门后面搜索，所以，让我们更正式地考虑一下，究竟如何至少实现那个算法，因为我可以采取**弗朗西斯**提出的方案，只是跳来跳去，可能用点直觉。
- en: but again that's not really an algorithm，we really need to do something more
    step。by step and in the meantime，let's go ah**d joe and let's close the。curtain
    and see if we can't clean those，up with another problem in a moment，while we consider
    now，so。with linear search i would propose that。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这其实并不算一个算法，我们确实需要更逐步的方法。同时，让我们前进，**乔**，拉上窗帘，看看是否能用另一个问题来解决这些问题，稍后我们再考虑。所以，关于线性搜索，我想提出这个。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_8.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_8.png)'
- en: we could implement it in in pseudocode，first if you will like this。for i from
    zero to n minus one all right，we'll see where we're going with this if。the number
    is behind the ith door，return true otherwise at the very end，translation。into
    pseudocode much like we did with。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在伪代码中实现它，首先如果你喜欢这样。对于 i 从零到 n 减一，好吧，我们看看这将如何进行。如果数字在第 i 个门后面，返回 true，否则在最后。转换成伪代码，像我们之前做的那样。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_10.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_10.png)'
- en: the phone book some time ago，and why though these values because i'm，more like
    c。even though it's still pseudo code so，for i from zero to n，minus one so computer
    scientists tend to。start counting from zero。![](img/0a07aadb299f2538eddc3c64659844e7_12.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 电话簿，早些时候，为什么这些值，因为我更像 c。尽管它仍然是伪代码，所以对于 i 从零到 n 减一，所以计算机科学家倾向于从零开始计数。![](img/0a07aadb299f2538eddc3c64659844e7_12.png)
- en: this case，from zero，on up to n minus one so this is just a，very common way。of
    setting yourself up with a for loop，maybe in c maybe in pseudocode in this，right，condition。number
    is behind the ith door i just，being a colloquial way of saying。what is behind
    the door at location i go，ahead and return true i have found。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从零到 n 减一，这只是一种非常常见的方法。通过设置一个 for 循环，可能是在 c 中，也可能是伪代码，在这个条件下。数字在第 i 个门后面，我只是用一种口语化的方式来说。第
    i 个位置的门后面是什么，继续并返回 true，我找到了。
- en: myself the number i want for instance，the number zero，and then notice that this
    return false。is not part of an，else because i don't want to abort this。![](img/0a07aadb299f2538eddc3c64659844e7_14.png)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要的数字，例如，数字零，然后注意到这个返回 false。并不是 part of an else，因为我不想中止这个。![](img/0a07aadb299f2538eddc3c64659844e7_14.png)
- en: algorithm prematurely and，abort simply because a number is not，behind the current
    door。i essentially want to wait all the way，to the end of the algorithm。![](img/0a07aadb299f2538eddc3c64659844e7_16.png)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 算法过早终止，并且仅仅因为一个数字不在当前门后面。我基本上想等到算法的最后。![](img/0a07aadb299f2538eddc3c64659844e7_16.png)
- en: after i've checked all n doors and if i，have still not，only then。am i going
    to return false so a very，common programming mistake might be to。nest this internally
    and think about，things in terms of ifs and，else's but you don't need to have an。else
    this is kind of a catch-all here，at the very end but now let's consider。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查完所有 n 个门后，如果我仍然没有，只有那时。我要返回 false，所以一个非常常见的编程错误可能是把这个嵌套在内部，考虑事情的 if 和 else，但你不需要有一个
    else。这在最后算是一种通用处理，但现在让我们考虑。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_18.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_18.png)'
- en: search，search，what is the efficiency of leading your。![](img/0a07aadb299f2538eddc3c64659844e7_20.png)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索，搜索，效率如何。！[](img/0a07aadb299f2538eddc3c64659844e7_20.png)
- en: search which is to say how well designed，is this algorithm and we we put i gave。ourselves
    a framework a moment ago，big o notation which is an upper bound。which we can think
    of for now as meaning，like a worst case，in the worst case how many steps might。it
    take me to find，the number zero or any number for that。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索，也就是说这个算法设计得如何，我们给自己设置了一个框架，刚才提到的大 O 表示法，它是一个上限。现在我们可以把它理解为，像是最坏情况，在最坏情况下，我可能需要多少步才能找到，数字零或任何数字。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_22.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_22.png)'
- en: matter among，of n。![](img/0a07aadb299f2538eddc3c64659844e7_24.png)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 事物之间，n 的情况。![](img/0a07aadb299f2538eddc3c64659844e7_24.png)
- en: times log n big o of n big o of log n。![](img/0a07aadb299f2538eddc3c64659844e7_26.png)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 时间 log n，大 O 表示法 n，大 O 表示法 log n。![](img/0a07aadb299f2538eddc3c64659844e7_26.png)
- en: constant，fixed number of steps um brian could we，go ah**d and pull up this question。let
    me go ah**d and pull it up on my，screen as well if you go to our usual，a moment。the
    question now looks，if you go ah**d to polev。com cs50，you will soon see the results
    let me go。ahead and give you a few seconds for。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 常数，固定步数，嗯，布赖恩，我们能否继续并拉出这个问题。让我也在我的屏幕上拉出来，如果你去我们平常的地方，稍等一下。现在的问题看起来，如果你去 polev.com
    cs50，你很快就会看到结果，给你几秒钟时间。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_28.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_28.png)'
- en: what you think an，upper bound is on the running time of，linear search implemented
    with this。pseudocode here，and in the meantime，i'm going to go ah**d and log in
    here as。technical difficulties if you if you，don't mind forgive me，let me pause
    for just a moment while i。can fix something here real fast，this isn't so much
    technical difficulty。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为线性搜索的运行时间的上限是什么，在这里用这个伪代码实现，同时，我要继续并在这里登录。技术问题，如果你不介意，原谅我，让我暂停一下，快速修复一下，这并不是技术问题。
- en: as it is user error on my part for not，having done this in advance so，myself。on
    the internet almost fixed though and，boy won't it be，interesting to see the result
    in just a。all right almost there，we will excise all of this awkwardness，let me
    go ah**d and okay。give me just one second for this to come。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我没有提前完成这项工作，这是我的用户错误，所以我。几乎在网上修复好了，哇，看到结果将会是多么有趣。好吧，差不多到了，我们会去掉所有这些尴尬，让我继续，好吧。给我一秒钟让它出现。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_30.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_30.png)'
- en: all right my apologies all right so，what's an upper bound on the running，time
    of linear。search so it looks like almost all of，you answered big o of，n so 86
    percent of you and that's indeed。![](img/0a07aadb299f2538eddc3c64659844e7_32.png)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我很抱歉，那么线性搜索的运行时间的上界是什么？看起来几乎所有人都回答了 n 的大 O，所以你们中有 86% 的人，这确实是。![](img/0a07aadb299f2538eddc3c64659844e7_32.png)
- en: the case and we can see this in fact in，the context of our whole chart there。whereby
    if we consider the running times，that were，sorry i'm new here，all right fix this
    there we go。okay indeed if we consider now the，to be big o of n，why is that so
    in the worst case the。number i'm looking for 0，might very well be at the end of
    that。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，我们确实可以在我们的整个图表中看到这一点。如果我们考虑运行时间，抱歉，我在这里是新人，好吧，修复一下，这里可以了。好吧，确实，如果我们现在考虑，这应该是
    n 的大 O，为什么呢？在最坏情况下，我正在寻找的数字 0，可能就在最后。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_34.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_34.png)'
- en: list which is going to be on the order，of n steps or in this case precisely。n
    steps so that's one way to think about。![](img/0a07aadb299f2538eddc3c64659844e7_36.png)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的步骤将是 n 步，或者在这种情况下，确切地说是 n 步，这是一种思考方式。![](img/0a07aadb299f2538eddc3c64659844e7_36.png)
- en: question，notation。![](img/0a07aadb299f2538eddc3c64659844e7_38.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 问题，符号。![](img/0a07aadb299f2538eddc3c64659844e7_38.png)
- en: which is a lower bound on the running，time of an algorithm，brian could we go
    ah**d and ask this。![](img/0a07aadb299f2538eddc3c64659844e7_40.png)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个算法运行时间的下界，布莱恩，我们能否继续询问这个。![](img/0a07aadb299f2538eddc3c64659844e7_40.png)
- en: question next at that same url，we'll see a question asking now for。possible
    answers for the running time，for a lower bound on the running time of。linear search
    so let's go ah**d and take，a look at this one here。and in just a moment we'll
    see as the。![](img/0a07aadb299f2538eddc3c64659844e7_42.png)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题，在同一网址，我们将看到一个问题，询问线性搜索运行时间的下界的可能答案，所以让我们继续看看这个。很快我们会看到。![](img/0a07aadb299f2538eddc3c64659844e7_42.png)
- en: responses come in about 75 plus percent，of you are proposing。that it's actually
    omega of one so omega，is a lower bound，one refers to constant time and why is。this
    point。![](img/0a07aadb299f2538eddc3c64659844e7_44.png)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大约有 75% 以上的回复，你们提出。实际上它是 omega 的一，omega 是下界，一指的是常数时间，这一点为什么重要。![](img/0a07aadb299f2538eddc3c64659844e7_44.png)
- en: step，or a constant number of steps why is，that how do you think about this，from。uh
    yeah you can just open it and be，lucky and find it in the first door。yeah so it
    really speaks to just that，you might just get lucky and the number。you're looking
    for might be at the very，first door so the lower bound in the，best case if you
    will。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤，或常数步数，为什么是这样，你怎么想？呃，是的，你可以打开它，走运地在第一扇门找到它。是的，所以这确实表明，你可能只会走运，正在寻找的数字可能就在第一扇门后，所以在最佳情况下的下界。
- en: of this algorithm linear search might，very well be omega of one。![](img/0a07aadb299f2538eddc3c64659844e7_46.png)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索的算法可能确实是 omega 的一。![](img/0a07aadb299f2538eddc3c64659844e7_46.png)
- en: for exactly that reason that you have to，get lucky and the element might be。there
    at the beginning so that's pretty。![](img/0a07aadb299f2538eddc3c64659844e7_48.png)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正是出于这个原因，你必须走运，元素可能在开头就在那里，所以这相当。![](img/0a07aadb299f2538eddc3c64659844e7_48.png)
- en: good we really can't do any better than，that so we have this range now of a。lower
    bound from omega of one。![](img/0a07aadb299f2538eddc3c64659844e7_50.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们真的做不到比这更好了，所以我们现在有一个范围，来自于 omega 的下界。![](img/0a07aadb299f2538eddc3c64659844e7_50.png)
- en: on up to big o of n being an upper bound，on the running time，of linear search
    but of course we have。this other algorithm in our toolkit and，recall from week
    zero。that we looked at binary search although。![](img/0a07aadb299f2538eddc3c64659844e7_52.png)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 直至大 O 的 n 成为线性搜索运行时间的上界，但当然我们还有。这个工具箱中的其他算法，回想一下从零周。我们看过二分搜索，虽然。![](img/0a07aadb299f2538eddc3c64659844e7_52.png)
- en: not necessarily by name it was that，divide and conquer，third algorithm where
    we took the phone，half。again now while i fumbled there joe。![](img/0a07aadb299f2538eddc3c64659844e7_54.png)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并不一定是按名称来分而治之的第三种算法，我们拿起电话，分成两半。再一次，现在我在那里笨拙地处理，而乔在一旁。![](img/0a07aadb299f2538eddc3c64659844e7_54.png)
- en: kindly uh has，uh given us a new set of doors if joe we，doors again。behind which
    we still have some numbers，but i think this time i'm going to be，door's。behind
    there we go so we have our same，seven doors but behind those doors now。is a different
    arrangement of numbers，and suppose this time，i want to find myself the number
    six。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 乔好心地给我们了一组新的门，如果乔，我们再次有门。后面仍然有一些数字，但我想这次我会去找门。好了，后面是我们同样的七扇门，但这次那些门后面是不同的数字排列，假设这次我想找到数字六。
- en: so the number six will change the，problem slightly but i'm going to give。you
    one other ingredient this time，which is going to be key to this working，why were
    florence and i。able to do no better than linear search，before why were florence
    and i able to，do no better than。![](img/0a07aadb299f2538eddc3c64659844e7_56.png)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以数字六会稍微改变问题，但这次我会给你一个关键的要素，这将是这个工作的关键。为什么弗洛伦斯和我之前只能做到线性搜索？为什么弗洛伦斯和我只能做到。![](img/0a07aadb299f2538eddc3c64659844e7_56.png)
- en: randomly searching even last time。![](img/0a07aadb299f2538eddc3c64659844e7_58.png)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上次随机搜索。![](img/0a07aadb299f2538eddc3c64659844e7_58.png)
- en: what was it about the array of numbers，or the array of doors，that didn't not
    allow me previously to。use，um it's because the we didn't know if，the numbers were
    sorted or not。yeah we didn't know if the numbers were，sorted or not and indeed，barring
    that detail florence and i。than say，linear search so this time though joe，has
    kindly sorted。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数组或者门数组有什么特征，让我之前无法使用呢？嗯，因为我们不知道这些数字是否是排序的。是的，我们不知道数字是否排序，而确实，除了那个细节，弗洛伦斯和我。比线性搜索好，所以这次，乔好心地进行了排序。
- en: some numbers behind these doors for us，and so if i want to search for the，number
    six。now i can begin to use a bit of that，information so you know what i'm going。to
    start just like we did with the phone，book and start roughly in the middle and，voila。number
    five all right so we're pretty，close we're pretty close but the thing。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数字在这些门后面，所以如果我想搜索数字六。现在我可以开始利用这些信息，你知道我将开始，就像我们处理电话簿一样，大致从中间开始，瞧。数字五，好吧，所以我们很接近，我们很接近，但问题是。
- en: about binary search recall is that this，is now useful information。if the numbers
    are sorted behind these，doors all of the doors to the left，all of the doors to
    the。right should presumably be larger than，5。now i might kind of，cut a corner
    here and be like well if。this is 5 6 is probably right，next door literally but
    again，algorithmically how might we do this we。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于二分搜索，回想一下这是有用的信息。如果这些门后面的数字是排序的，左边的所有门，右边的所有门应该大于5。现在我可能会在这里走捷径，想如果这是5，6可能就在隔壁，但再次，从算法的角度来看，我们该如何做到这一点呢？
- en: don't want to necessarily，consider these special cases so more，array。of size
    three so let me go ah**d and，apply that same algorithm voila。to the middle now
    i have the number，seven and now it's becoming pretty clear。that if the number
    six is present it's，probably behind this door and indeed，size one，number six。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不想特别考虑这些特殊情况，所以更多的大小为三的数组，所以让我去应用相同的算法，瞧。现在我到中间，得到了数字七，现在变得相当清楚。如果数字六存在，可能在这扇门后面，确实是，大小为一，数字六。
- en: doors，instead of all seven potentially or，maybe all six doors to find my way。to
    that number because i was given this，additional ingredient of all of those，numbers
    being sorted。so it would seem then that you can apply，the better more efficient
    better，search。if only someone like joe would sort the，numbers for you，in advance
    so let's consider now a。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 门，而不是所有七扇门，或者也许六扇门，找到我的数字，因为我得到了这些额外的要素，即所有的数字都是排序的。因此，看来你可以应用更好、更高效的搜索。如果只有像乔这样的人提前为你排序数字，那就好了，所以现在我们来考虑一个。
- en: little more algorithmically how we might，implement this so with binary search
    let。me propose this pseudocode，return true，we found it so if we got lucky then
    we。might very well have found the number，have been done，but that didn't happen
    and in the。general case that probably won't happen，so if the number is less than。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从算法的角度来看，我们可能如何实现这个，因此用二分搜索让我提出这个伪代码，返回真，我们找到了它，所以如果我们运气好，那么我们可能找到了这个数字，完成了，但这没有发生，而在一般情况下，这可能不会发生，所以如果数字小于。
- en: that behind the middle door then just，like with the phone book i'm going to
    go，left half。of the remaining doors in the array else，if the number is greater
    than that，behind the middle door。then like the phone book i'm going to go，phone
    book，but there might still be one final case。potentially，whereby if there's no
    doors left at all，or no doors in the first place。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间门后面，然后就像查电话簿一样，我将去，剩余门的左半部分。如果这个数字大于在中间门后面。然后像电话簿一样，我将去，电话簿，但可能还有一个最终的情况。潜在地，如果根本没有门，或者根本就没有门。
- en: i should at least have this one special，case where i do say，return false for
    instance if six for。whatever reason weren't be，among those doors and i were searching。for
    it i still need to be able to handle，definitively，return false if i'm left with
    no further。doors to search，so here then might be the pseudo code，for this algorithm
    a bit more formally。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我至少应该有一个特殊情况，例如如果六因为某种原因不在那些门中，而我正在搜索。我仍然需要能够明确处理，如果我没有进一步的门可搜索，则返回false。那么这里可能是这个算法的伪代码，更正式一点。
- en: now let's consider the analysis thereof，before where we left off，linear search
    was big o of n linear。search was big o of。![](img/0a07aadb299f2538eddc3c64659844e7_60.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑之前分析的内容，在线性查找为O(n)时。线性查找为O。![](img/0a07aadb299f2538eddc3c64659844e7_60.png)
- en: n this time let's consider where binary，search actually falls，into place by
    asking a different。question i'm going to go ah**d and go，back and ask this question
    now。what's an upper bound on the running，time of，binary search an upper bound
    on the。running time of binary search，and go ah**d and buzz in if you'd like，similarly
    to before。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这次让我们考虑二分查找实际适用的地方，问一个不同的问题。我将继续并回去问这个问题。二分查找的运行时间的上限是什么，二分查找的运行时间的上限是什么，继续并像以前一样发言。
- en: what's an upper bound on the running，time of binary search，and you can see here
    answers are getting。![](img/0a07aadb299f2538eddc3c64659844e7_62.png)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找的运行时间的上限是什么，你可以在这里看到答案在增多。![](img/0a07aadb299f2538eddc3c64659844e7_62.png)
- en: pretty dominant around log n and indeed，that jives with exactly what we did
    in，of n。because that's going to be the maximum，or an array，of a given size and
    split it in half and。you're looking for，at all，meanwhile if we consider now not
    just，the upper bound on this algorithm。so in the worst case binary search takes，big
    o of log n，now let's consider a related question。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在O(log n)附近非常占主导地位，确实与我们在O(n)中的结果一致。因为这将是给定大小数组的最大值，并将其对半分割。你正在寻找，同时如果我们现在考虑的不仅仅是这个算法的上限。那么在最坏的情况下，二分查找的时间复杂度为O(log
    n)，现在让我们考虑一个相关问题。
- en: which is what's a lower bound on the，what's a lower bound，on the running time
    i'll go ah**d and。to some of the，the suggestions thus far in the best，case maybe
    two。you do get lucky and the number you're，looking for six or some other number
    is。smack dab in the middle of the array and，so maybe indeed you can get away with。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是下限，什么是运行时间的下限，我将继续参考到目前为止的一些建议。在最佳情况下，也许是两个。你运气好，正在寻找的数字六或其他某个数字恰好在数组的中间，因此也许确实可以做到。
- en: just one step and indeed a lower bound，on binary search now。![](img/0a07aadb299f2538eddc3c64659844e7_64.png)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一步，确实是二分查找的下限。![](img/0a07aadb299f2538eddc3c64659844e7_64.png)
- en: might very well just be an omega of one，because in that best case。you just get
    lucky and it's right where，you happen to start，in this case in the middle so we
    seem to。have a range there but strictly speaking，it would seem that binary search。is
    better binary search is better than，linear search because as n gets big，difference
    in fact。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可能实际上只是一个Ω(1)，因为在最佳情况下。你运气好，它正好在你开始的地方，在这种情况下在中间，所以我们似乎有一个范围，但严格来说，二分查找似乎比线性查找好，因为当n变大时，差异实际上会变得明显。
- en: recall from week zero we played a little，bit with these light bulbs and right
    now。all sixty-four of these light bulbs are on，and let's consider for a moment
    just to。put this into perspective how long it，would take to use linear search。to
    find one light bulb among these sixty-four 。the light bulb。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下从零周，我们玩了一点这些灯泡，现在这六十四个灯泡都亮着，让我们考虑一下，为了将其放入视角，使用线性查找在这六十四个灯泡中找到一个灯泡需要多长时间。灯泡。
- en: or the number that we're looking for is，way down there at the end but we don't，know
    it in advance。and so sumner if you wouldn't mind，executing linear search on these
    light。bulbs let's just get a feel for，the efficiency or inefficiency of this，algorithm，you'll
    notice。that one light bulb at a time is going，out implying that i've，searched
    that door searched that door。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们正在寻找的数字，在那里的一端，但我们事先并不知道。因此，Sumner，如果你不介意对这些灯泡执行线性搜索，让我们感受一下这个算法的效率或低效，你会注意到，一个灯泡一次亮起，意味着我已经搜索过那扇门，搜索过那扇门。
- en: searched that door，but we've only gotten through ten or so，bulbs and we've got
    another 50 plus。to go and you can see that if we look，inside of these doors one
    per second or，second。it's going to take a long time in fact i，it doesn't seem
    worthwhile to even wait。until the very end so somewhere if you，won mine let's
    bring all the lights back，algorithm。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们搜索了那扇门，但只经过了十个左右的灯泡，还有超过50个灯泡要处理。可以看到，如果我们每秒检查一个灯泡，实际上会花费很长时间，等到最后似乎没有必要。因此，如果你愿意，让我们一起把所有的灯光带回，算法。
- en: this one binary search just to get again，a feel of，what the running time is
    of an algorithm。like binary search that runs in，logarithmic time so in just a
    moment。we'll go ah**d and execute binary search，on these light bulbs the idea
    being that。there's one bulb we care about let's see，how fast we can get down to
    just one。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二分搜索，再次感受一下，像二分搜索这样在对数时间内运行的算法的运行时间。所以，稍后我们将继续执行这些灯泡上的二分搜索，想法是：有一个灯泡我们关心，让我们看看，我们能多快找到这个灯泡。
- en: bulb out of sixty-four 。so sumner on your marks，get set go，and we're done just
    a few steps later。and then we have this soul light bulb，that was so much faster
    and in fact we，did this deliberately。one iteration at a time the algorithm，that
    we just executed with sumners and，matt's help。algorithmically was operating what's，called
    one hertz，one hertz and if you're unfamiliar hertz。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从 64 个灯泡中熄灭。因此，Sumner，准备好，开始，几步之后我们就完成了。然后我们得到了这个灵魂灯泡，它快得多，实际上我们故意这样做。一轮接一轮，刚刚执行的算法，在
    Sumner 和 Matt 的帮助下。算法的运行频率是 1 赫兹，如果你不熟悉赫兹。
- en: is just one something per second it's，very often used in physics。or just in
    discussions of electricity，more generally and indeed in this case，that。first algorithm
    linear search might have，way，to that final light bulb but that second。algorithm
    was logarithmic，and so by going from sixty-four to 32。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒仅表示一次，这在物理学中经常使用，或者更广泛地讨论电力，实际上在这个例子中，那个第一个算法线性搜索可能会到达最后一个灯泡，但第二个算法是对数的，因此从
    64 到 32。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_66.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_66.png)'
- en: to 16 to a to four to two to one we get。![](img/0a07aadb299f2538eddc3c64659844e7_68.png)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到 16 到 4 到 2 到 1，我们得到了。![](img/0a07aadb299f2538eddc3c64659844e7_68.png)
- en: to the final result much faster even，going at the same，pace so in fact if you
    think of your。computer cpu。![](img/0a07aadb299f2538eddc3c64659844e7_70.png)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以更快地得到最终结果，即使以相同的速度运行，所以如果你想象一下你的电脑 CPU。![](img/0a07aadb299f2538eddc3c64659844e7_70.png)
- en: cpus are also measured in hertz，h-e-r-t-z，probably measured in gigahertz which
    is。billions of hertz per second，so your cpu the brain of your computer，literally
    do。one billion things at a time and here we，have this sort of simpler setup of
    just。light bulbs doing one thing，per second your computer can do one。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 也是以赫兹（hertz）为单位测量的，h-e-r-t-z，可能以千兆赫（gigahertz）为单位测量，即每秒数十亿赫兹，因此你的 CPU，电脑的大脑，字面上可以同时做一十亿件事，而在这里，我们有这种更简单的设置，仅仅是每秒做一件事的灯泡，你的电脑可以做到一。
- en: billion of these kinds of operations at，once so just imagine therefore how much。![](img/0a07aadb299f2538eddc3c64659844e7_72.png)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作的数量达到数十亿，因此想象一下究竟有多少。![](img/0a07aadb299f2538eddc3c64659844e7_72.png)
- en: these savings tend to add up over time，problems at once，as opposed to doing
    things like we did。in week zero just one single，step at a time all right well
    let's now。go ah**d and start to translate this to，code we have enough tools in
    our toolkit。in c that i think based on our，discussion of arrays last week we can。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节省时间的优势随着时间的推移而累积，处理多个问题，而不是像我们在第零周那样逐步进行，一次一步。好了，现在让我们继续，将其翻译成代码，我们的工具箱中有足够的工具，我认为基于我们上周对数组的讨论，我们可以。
- en: now actually start to build something，in code on our own so i'm going to go。ahead
    and create a file here in just a，moment in cs50 ide，called for instance numbers。c
    let me go。ahead and translate this to a file，in c code called numbers。c and the
    goal。at hand is just to implement linear，search in code just so that we're no，pseudocode。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实际上开始自己用代码构建一些东西，所以我将继续在`cs50 ide`中创建一个文件，叫做`numbers.c`。让我将其翻译为一个名为`numbers.c`的C代码文件，手头的目标只是实现线性搜索代码，而不是伪代码。
- en: but doing things a little more，concretely so i'm going to go ah**d and，include
    cs50。h。i'm going to go ah**d and include，standardio。h and i'm going to start with，no
    command line arguments。like we left off last week but just with，and i'm going
    to go ah**d and give。myself an array of numbers seven numbers，ahead and say，int
    numbers and then this is a little。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们要更具体一点，所以我将继续并包含`cs50.h`。我将继续并包含`stdio.h`，并且我将从没有命令行参数开始，就像我们上周所做的那样，但只是用，并且我将继续并给自己一个包含七个数字的数组，声明为`int
    numbers`，然后这在计算机的内存中稍微有点右。
- en: it's handy，for creating an array when you know in，advance what numbers you want
    which i do。because i'm going to mimic the doors，that joe kindly set up for us
    here。i'm going to go ah**d and say give me an，array that is equal to，4 6 8 2，7
    5 0。and this is the feature we didn't，see last week if you know in advance the，array。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于在你提前知道想要什么数字时创建数组很方便，而我正是这样做的。因为我要模拟乔为我们设置的这些门。我将继续并要求给我一个等于`4 6 8 2 7 5
    0`的数组。这是我们上周没有看到的特性，如果你提前知道数组的话。
- en: you actually don't have to bother，explicitly，the compiler can figure that out，intelligently
    for you。commas，inside to enumerate from left to right，the values that you want
    to put。into that array so after this line 6 has，executed in my computer i'm going
    to be。left with an array called numbers，inside of which are seven integers，listed
    from left。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上不需要显式地处理，编译器可以智能地为你解决这个问题。用逗号来枚举从左到右你想放入数组的值。所以在第六行执行后，我的计算机中将留下一个名为`numbers`的数组，其中包含七个从左到右列出的整数。
- en: to right in the computer's memory so to，speak in this way now what do i want
    to。do with these numbers well let's，implement linear search，linear search as we
    latched on to。earlier is a searching from left to，convention，tends to go left
    to right so i'm going。to do a standard for loop，for int i get 0 i is less than
    i'm going。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想用这些数字做什么呢？好吧，让我们实现线性搜索，线性搜索如我们之前提到的，通常从左向右进行。所以我将进行一个标准的`for`循环，声明`int i
    = 0`，`i <`我将继续。
- en: to keep it simple for now and hard code，want，and i'm going to do i plus plus
    on each。iteration so i'm pretty sure，that my line eight will induce a for。loop
    that iterates eight total times，and what question do i wanna ask on each，iteration
    well。if the numbers array at location i，equals equals for instance the number
    i。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了简单起见，我将硬编码想要的内容，并在每次迭代时执行`i++`。所以我很确定我的第八行将引发一个总共迭代八次的`for`循环。我想在每次迭代时问什么呢？嗯，如果数字数组在位置`i`等于，例如数字`i`。
- en: was searching for initially let's go，ahead and search for zero，then what do
    i want to do let me go。but useful，knows，and then let me go ah**d and just for，good
    measure let me go ah**d and return。zero and we'll come back to that in just，a
    moment but at the end of this program。i'm also going to do this printf，not found
    with a backslash n and then。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初要搜索的目标是零，然后我想做什么呢？让我去，但有用的知识，然后让我继续并为了好 measure，再返回零，我们稍后会再回到这个问题。但在这个程序结束时，我也会执行这个`printf`，输出`not
    found`并带上换行符。
- en: i'm going to go ah**d and return，one but before we tease apart those，aggregate。here's
    my entire main function and on，line six to recap i initialize the array。just as
    we did very at the very，beginning with a seemingly random。list of numbers behind
    the doors then on，line eight i'm going to iterate with。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我要继续进行并返回，不过在我们拆解这些聚合之前，先来看一下我的整个主函数。在第六行，我初始化了数组，就像我们一开始时用一个看似随机的数字列表那样。
- en: this for loop seven total times，incrementing i in each turn，and then line ten
    just like i was。opening the doors one at a time i'm，going to check if the ith，number
    in this array equals equals the。number i care about，0 with that first demo i'm
    going to，print found。otherwise not else per se but otherwise，if i go through this
    entire loop，checking if if。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个for循环总共进行七次，每次递增i，然后第十行，就像我一个一个打开门一样，我将检查这个数组中的第i个数是否等于我关心的数字，0，基于那个第一次演示，我会打印找到。否则不是else
    per se，而是如果我遍历这个整个循环，检查如果。
- en: if and i never actually find zero i'm，going to have this sort of catch-all at。the
    end that just says no matter what if，you reach line 16，print not found and then
    return one。now this is a bit of a subtlety but，could someone remind us，what's
    going on with the return 0 on。line 13，and the return 1 on line 17。why 0 and 1
    and why am i returning it。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我实际上从未找到零，我会在结尾加上这种“捕获所有”的处理。也就是说，无论如何，如果你到达第16行，就打印未找到，然后返回一。现在这是一个微妙之处，但能有人提醒我们，第13行的返回0和第17行的返回1是怎么回事吗？为什么是0和1，我为什么要返回它。
- en: all what problem is this solving for me，even though most of our programs thus，this
    uh to me，return。or it found it，um and it kind of exits that loop saying，one，is
    like the return false um and it。exited as well exactly and exit really，is the
    operative word in maine。when you are done ready to quit the，program as we've done
    with the word quit。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我什么问题，尽管我们大多数程序因此，这对我来说，返回。或者找到了，嗯，它会退出循环，说明，1，就像返回假一样，嗯，它也确实退出了，确实，退出在main中是一个重要的词。当你准备好退出程序时，就像我们用“退出”这个词一样。
- en: in some of our pseudo code in the past，you can literally return a value and。recall
    at the end of last week we，introduced the fact，that maine always returns an ants
    you。and i have ignored that，for at least a week or two but sometimes。it's useful
    to return an explicit value，whether it's for auto grading purposes。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过去的一些伪代码中，你可以直接返回一个值。回想一下上周末，我们介绍了main总是返回一个答案。对此我至少忽视了一到两周，但有时，返回一个明确的值是有用的，无论是为了自动评分的目的。
- en: whether it's for automated testing of，your code in the real world or just so。it's
    a signal to the user that something，indeed went wrong，so you can return a value
    from main and。as uh demi proposed，zero means all is well and it's a little，counterintuitive
    because thus far。true tends to be a good thing but in，this case zero is a good
    thing all is，well it's success。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是为了自动化测试你的代码在现实世界中的应用，还是仅仅是为了向用户传达确实出了问题的信号，所以你可以从main返回一个值，正如德米所建议的，零意味着一切良好，这有点违反直觉，因为到目前为止，真值往往是件好事，但在这种情况下，零是件好事，一切正常，就是成功。
- en: and if you return any other value for，instance one，that indicates that something
    went wrong。so the reason i'm printing out，after the word found i'm returning zero。is
    so that effectively the program，exits at that point i don't want to keep。going
    again and again if i already found，the number i care about。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你返回任何其他值，例如1，这表示某些事情出了错。所以我在“找到”这个词后打印的原因是，我返回零。有效地说，程序在那一点上退出，我不想在已经找到我关心的数字的情况下，一遍又一遍地继续。
- en: and down here this one admittedly isn't，16，and maybe deleted line 17 the program
    is。going to end anyway but there wouldn't，be that so-called，exit status that we
    discussed last week。briefly whereby you can kind of signal，successful，or unsuccessful
    and the reason that zero。is a good thing，and one or any other number is not，programs
    that you。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这一行诚然不是，16，可能删除第17行，程序将。无论如何会结束，但不会有我们上周讨论的所谓，退出状态。简而言之，你可以通过这种方式传达，成功或失败，而零是一个好的信号，一个或任何其他数字则不是，程序会。
- en: write or that companies in the real，world right when you get those error，error
    codes。there are hundreds thousands of problems，that might happen in a computer
    program。that could be that many error codes that，you see on the screen reasons
    explaining，like，just。one value that the world has decided，means success，so there's
    only one way to get your，many。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 写或现实世界中的公司，当你得到那些错误，错误代码时。可能会有成千上万的问题，发生在计算机程序中。可能会出现那么多的错误代码，你在屏幕上看到的原因解释，比如，仅仅是一个值，世界已经决定，这意味着成功，所以只有一种方法可以得到你的，许多。
- en: millions of ways in which things can go，wrong and that's why，uh humans have
    adopted that particular。now，not just numbers but let's make things，more interesting
    besides the door。suppose that we actually had people's，names behind them well
    let's go ah**d。and write a program this time，that not only searches for numbers
    but。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 事情出错的方式有数百万种，这就是为什么人类采用了这个特定的方法。现在，不仅是数字，让我们让事情变得更有趣，假设我们实际上在后面有人的名字。好吧，让我们继续写一个程序，这次不仅搜索数字。
- en: instead searches for name so i'm going，here，called names。c and i'm going to
    start a。little similarly i'm going to include，cs50。h，at the top i'm going to include
    standard，io at the top。but i'm also this time going to include，string。h which
    we introduced briefly，sturlang。for getting the length of a string and，it turns
    out some other functions。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之的是搜索名字，所以我在这里，称之为names.c。我将以类似的方式开始，我会在顶部包含cs50.h，顶部再包含standard io。这次我还将包括string.h，我们简要介绍过，用于获取字符串长度，以及其他一些函数。
- en: let me go ah**d and declare int main，void as usual and then，inside here i need
    some arbitrary names。let's come up with seven names here，and here too i can declare
    an array just。as i did before but it doesn't have to，store only ins it can store。strings
    instead so i've changed the data，type from into string and i've changed。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续声明int main，void，像往常一样，然后在这里我需要一些随意的名字。让我们想出七个名字，这里我也可以像之前一样声明一个数组，但它不必只存储整数，它可以存储字符串，因此我将数据类型从整数更改为字符串。
- en: the variable name from numbers to names，notation，and maybe。![](img/0a07aadb299f2538eddc3c64659844e7_74.png)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称从数字更改为名称，表示法，可能还有。
- en: charlie and maybe fred and maybe，george and maybe ginny and maybe，percy and
    lastly maybe a name like。ron and it just barely fits on my screen，so with that
    said i now have this array，of names。and beyond there being an perhaps。![](img/0a07aadb299f2538eddc3c64659844e7_76.png)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: charlie，也许还有fred，也许是george，也许是ginny，或许是percy，最后可能是一个像ron这样的名字，它刚好可以放在我的屏幕上。因此，话虽如此，我现在有了这个名字的数组。除此之外，可能还有一些。
- en: obvious pattern to them there's a second，less obvious or maybe obvious pattern
    to。![](img/0a07aadb299f2538eddc3c64659844e7_78.png)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的模式存在，但也有第二个不那么明显或许明显的模式。
- en: them how would you describe the list of，names i arbitrarily just came up。with
    what's a useful characteristic of，them what do you notice about these，names。and
    there's at least two right answers，to this question i think。![](img/0a07aadb299f2538eddc3c64659844e7_80.png)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何描述这些我随意想到的名字列表？它们有什么有用的特征？你注意到这些名字有什么？对此问题，我认为至少有两个正确答案。
- en: what do you notice about these names，uh they're in alphabetical order yes so。beyond
    being the names of the weasley，children in harry potter they're also in。![](img/0a07aadb299f2538eddc3c64659844e7_82.png)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这些名字有什么？嗯，它们是按字母顺序排列的，是的。除了是哈利·波特中韦斯利家孩子的名字之外，它们也在。
- en: alphabetical order and that's the more，salient detail for our purposes。i've
    had the forethought this time to，sort these names in advance。and if i've sorted
    these names that，means implicitly i can use a better，algorithm。than linear search
    i can use for，instance our old binary search。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按字母顺序排列，这对我们的目的来说是更突出的细节。这次我有了先见之明，提前对这些名字进行了排序。如果我已经对这些名字进行了排序，那么这隐含着我可以使用比线性搜索更好的算法，我可以使用例如我们旧的二分搜索。
- en: but let's go ah**d first and just search，them naively for now let's still apply。linear
    search because you know what we，haven't yet done，is necessarily compare strings
    against。one another we've done a lot of，comparisons of numbers like integers。but
    what about names so let me go ah**d，and do this so for int。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们先直接搜索它们，现在还是使用线性搜索，因为你知道我们还没有做的是比较字符串。我们进行了很多整数的比较，但名字呢？所以让我先进行这一操作，对于int。
- en: i gets 0 just like before i less than 7，i plus plus and i'm doing this only，seven
    names。i think we could probably improve the，design of this code too by having。a
    variable or a constant storing that，value but i'm going to keep it simple，now。and
    it turns out for reasons we'll，explore in more detail next week。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: i得到了0，就像之前一样，i小于7，i加加，我仅仅在做这个，七个名字。我想我们或许可以改善这个代码的设计，通过使用一个变量或常量来存储那个值，但我现在想保持简单。结果是，由于一些原因，我们将在下周更详细地探讨。
- en: it is not sufficient to do what we did，before and do something like this if
    i'm，searching for ron。it turns out that in c you can't use，equals equals，int，you
    can for a char we've done both of。those in the past but there's a subtlety，that
    we'll dive into。in more detail next week that means you，can't actually do，this
    and this is curious because if you。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 做之前的事情并不足够，如果我在寻找ron。结果是，在C语言中你不能使用等于等于，int，对于char我们在过去做过这两者，但有一个细微差别，我们将深入探讨。下周会更详细地讨论，这意味着你实际上不能这样做，这很奇怪，因为如果你。
- en: have prior programming experience in，languages like python or the like。you can
    do this so in c you can't，but we'll see next time why but for now。it turns out
    that c can solve this，problem and historically the way you do，this is with a function。so
    inside of the string。h header file，there is not only，a declaration for sterling
    the length of。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有在像python这样的语言中的编程经验。你可以这样做，因此在C语言中你不能，但我们下次会看到原因，而现在。结果是C语言可以解决这个问题，历史上解决这个问题的方法是使用一个函数。因此在string.h头文件中，不仅有声明字符串长度的。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_84.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: 它实际上以ASCII顺序比较字符串，或称为ASCII比较，这是一种有点古怪的描述方式。
- en: a string like last week，there's another function called stir，compare and stir。compare
    for short strcmp allows me to，pass in two strings，one string that i want to compare。against
    another string，so it's not quite the same syntax indeed。it's a little harder to
    read it's not，quite as simple as equals equals。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 像上周提到的字符串，还有另一个函数叫做str_compare，简写为strcmp，允许我传入两个字符串，一个是我想要比较的字符串。
- en: but string compare if we read the，documentation for it will tell us。that this
    compares two strings and it。![](img/0a07aadb299f2538eddc3c64659844e7_86.png)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还有字符串比较，如果我们阅读它的文档，会告诉我们。它比较两个字符串，并且。
- en: returns one of three possible values，if those two strings are equal that is，identically
    the same。letter for letter then this function is，going to return，zero it turns
    out if the first string，string。alphabetically in some sense then this，value，if
    the first string is supposed to come。![](img/0a07aadb299f2538eddc3c64659844e7_88.png)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回三个可能的值之一，如果这两个字符串相等，即完全相同。逐字比较的话，这个函数将返回零。如果第一个字符串在某种意义上按字母顺序排列，那么这个值，如果第一个字符串应该在前面。
- en: after the second string，alphabetically if you will then it's，going to return
    a positive value so。![](img/0a07aadb299f2538eddc3c64659844e7_90.png)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个字符串之后，按字母顺序排列的话，它将返回一个正值。
- en: there's three possible outcomes either，equal to zero，and in fact if you look
    at the，specify。![](img/0a07aadb299f2538eddc3c64659844e7_92.png)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个可能的结果，或者等于零，实际上如果你查看，指定。
- en: what value less than zero or what value，greater than zero。![](img/0a07aadb299f2538eddc3c64659844e7_94.png)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 什么值小于零或什么值大于零。
- en: you have to just check for any negative，value or any positive value。and i also
    told a bit of a white lie a，moment ago this does not check things。alphabetically
    even though it，coincidentally does sometimes。![](img/0a07aadb299f2538eddc3c64659844e7_96.png)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需检查任何负值或任何正值。我刚才也撒了个小谎，这并没有按字母顺序检查，即使它偶然有时会这样。
- en: it actually compares strings in what's，called ascii order，or asciibetically
    which is kind of a。goofy way of describing。![](img/0a07aadb299f2538eddc3c64659844e7_98.png)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所以语法不完全相同，确实有点难以阅读，不像等于等于那么简单。
- en: this function looks at every character，in the two strings from left to right。it
    checks the ascii values of them and，then it compares those ascii values，character
    by character。and if the ascii value is less than the，other then it returns a negative
    value。or vice versa so if you have for，instance the letter a，capital a in the
    string that gets。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从左到右查看两个字符串中的每个字符。它检查它们的ASCII值，然后逐字符比较这些ASCII值。如果ASCII值小于另一个，则返回负值。反之亦然，因此，如果你有，比如字母A，字符串中大写的A。
- en: converted first to 65，and then if you have an a in the other，to 65。and those
    would be equal but of course，character，proceeds，left to right so that stir compare。checks
    every character，in the names for you and it stops when，it hits that terminating
    null。character recall that strings underneath，the hood always，end in c with this
    backslash zero or。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先转换为65，然后如果你在其他地方有一个**A**，也转换为65。它们是相等的，但当然，字符是从左到右进行比较的，因此`strcmp`会检查每个字符，并在遇到结束的空字符时停止。记住，字符串在底层总是以这个反斜杠零`\0`结束。
- en: eight zero bits，so that's how stir comp knows when to，stop comparing values。but
    if i go ah**d and find someone like，unquote，found and like before i'll go ah**d
    and。return like demi-proposed，successful，otherwise if we get all the way to the。bottom
    of my code i'm gonna print out，not found to tell the story that we did，not find
    ron。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有八个零位，因此这就是`strcmp`知道何时停止比较值的方式。但如果我继续**进行**，找某个人，比如说**Unquote**，像之前一样，我会继续**进行**，返回像**Demi**所提出的那样成功。否则，如果我到达代码的底部，我将打印出“未找到”，以告诉故事我们没有找到**Ron**。
- en: in this array even though he does happen，to be there and i'm going to go ah**d，and
    return one。so even though i've hard coded，everything to hard code something in
    a。program means to type it out explicitly，you could imagine using a command line。argument
    like last week to get users，input who would you like to search for。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数组中，尽管他确实在那里，我会继续**进行**，返回1。因此，尽管我把所有内容都硬编码了，硬编码的意思是明确地输入。你可以想象使用命令行参数，就像上周那样获取用户输入，问他们想搜索谁。
- en: you could imagine using getstring to get，users input and ask them who would
    you，like to search for。but for now just for demonstration's，sake i've used only
    ron's name。and if i haven't made any typos let me，go ah**d and type in，make names
    enter so far so good。dot slash names and i'll hopefully we'll，see indeed found，because
    ron is very much in this array。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象使用`getstring`来获取用户输入，并问他们想搜索谁。但现在为了演示，我只用了**Ron**的名字。如果我没有打错，让我继续**进行**，输入`make
    names`，到目前为止还不错，`./names`，希望我们确实能找到，因为**Ron**确实在这个数组中。
- en: of seven，are new here，are again the fact that when we declare，an array of some
    fixed size we don't。strictly need to put a number here，and we have this curly
    brace notation，advance。but perhaps lastly and most powerfully，we do have this
    function in c。called stir compare that will allow us，to actually，store and compare
    strings in this way。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，新定义的数组为七个，我们声明一个固定大小的数组时，实际上不需要严格放一个数字，并且我们有这个大括号表示法。但是或许最后也是最强大的，我们在C中有一个叫做`strcmp`的函数，它将允许我们以这种方式存储和比较字符串。
- en: so let me pause here and just ask if，there's any questions，about how we translated
    these ideas to。code for numbers，and how we translated these ideas to，code for。now
    names each time using linear search，not binary caleb question，i meet myself uh
    yeah。so if would that program still work if，ron for example was like all caps。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在这里暂停，问一下是否有关于我们如何将这些思想转化为数字代码的问题，以及我们如何将这些思想转化为名称代码。每次使用线性搜索而不是二分搜索，**Caleb**问，我会静音。呃，是的，如果**Ron**例如是全大写的，那程序还会有效吗？
- en: like if you're trying to like search，like if like the cases are different。in
    terms of like uppercase lowercase，really good question and let me propose，general。when
    in doubt try it so i'm gonna do，exactly that i do happen to know the。answer but
    suppose i didn't，let me go ah**d and change ron to all，caps just because maybe
    the human。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，如果你试图搜索时，大写和小写不一样。这是个很好的问题，让我提出一个一般性的方法。当有疑问时，就尝试一下，所以我会完全这样做。虽然我确实知道答案，但假设我不知道，让我继续**进行**，把**Ron**改为全大写，只是因为人类的因素。
- en: the caps lock key was on and they typed，it in a little sloppily let me go ah**d。and
    make no other changes，notice that i'm in leaving the original，array alone with
    only a capital r。let me remake this this program make，names dot slash，names and
    voila he's still in fact，oh okay um。uh uh caleb you have just helped me，previous，example
    none of you who should have uh，program。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 大写锁定键是开启的，他们输入时有点马虎，让我继续**进行**。并且不做其他更改，注意我在保持原始**数组**的情况下只把**R**大写。让我重做这个程序，执行`./names`，瞧，他确实还在，哦，好吧。
- en: worked with ron because i didn't，practice literally what i'm preaching so。caleb
    hold that thought for just a，moment so i can rewind a little bit。and fix my apparent
    bug so ron was，indeed found，but he wasn't found because ron was。found i did something
    stupid here，and it's uh perhaps all the more，pedagogically appropriate now to。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与罗恩一起工作是因为我没有真正练习我所宣扬的，所以凯勒，请暂时保持这个想法，这样我可以倒回去一点，修复我显然的错误，所以罗恩确实被找到，但他并不是因为罗恩被找到，我在这里做了一些愚蠢的事情，而现在可能更具教育意义的是。
- en: program，it also says，ron was found in all caps and you know，what let me get
    a little。curious here let me go ah**d and search，for not even ron how about we
    search for。ron's mom molly make names，all right and now just to reveal that i，really
    did do something stupid。dot slash names okay now something's，clearly wrong right，i
    can even search for the father arthur。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 程序，它也说，罗恩以大写字母显示，而你知道，让我稍微好奇一下，让我去搜索，不仅是罗恩，我们怎么搜索罗恩的妈妈莫莉，好的，现在只是想揭示我，确实做了一些愚蠢的事情。点斜杠名字，好的，现在显然有什么不对，对吧，我甚至可以搜索父亲亚瑟。
- en: make names dot slash names it seems that，i wrote you a program that just。literally
    always says found so we，shouldn't have accepted this as correct。can anyone spot
    the bug based on my，definition thus far，meantime this。isn't uh really a bad time
    to open up，the duck and say，uh hello duck i am having a problem。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 制作名字点斜杠名字，似乎我写了一个程序，它只会字面上总是说“找到”，所以我们不应该接受这个作为正确的。根据我到目前为止的定义，有人能发现这个错误吗？同时，这并不是一个真的糟糕的时机去打开鸭子，说，呃，你好鸭子，我遇到了问题。
- en: whereby my program is always，printing found even when，someone is not in the
    array。and i could proceed to explain my logic，to the duck but hopefully sophia。can
    point me at the solution even faster，than the duck，we received from。stir comp
    with something so we need to，that，perfect，so i said the right thing but i，i want
    to check。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我程序的输出总是打印“找到”，即使数组中没有某人。我可以继续向鸭子解释我的逻辑，但希望索非亚能比鸭子更快地指出解决方案，我们收到的。搅拌比较某些东西，所以我们需要这样，完美，所以我说了正确的事情，但我，我想检查。
- en: for equality i literally need to check。![](img/0a07aadb299f2538eddc3c64659844e7_100.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相等，我确实需要检查。![](img/0a07aadb299f2538eddc3c64659844e7_100.png)
- en: the return value，when comparing names bracket i against，ron to equal zero because。only
    in the case when the return value，of stir comp is zero，do i actually have a match。![](img/0a07aadb299f2538eddc3c64659844e7_102.png)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较名字的括号我与罗恩相等时，返回值为零，因为只有在搅拌比较的返回值为零时，我才真正有一个匹配。![](img/0a07aadb299f2538eddc3c64659844e7_102.png)
- en: by contrast if the function returns a，negative value，or the function returns
    a positive value。that means it's not a match that means，the other，or lay after
    the other but the catch，not。always an incorrect syntax to use，whenever you have
    a boolean expression。inside of which is a function call，like this notice that
    the entirety of my，speak。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果函数返回一个负值，或者函数返回一个正值，那就意味着这不是匹配，这意味着其他，或在其他之后，但问题是，并不总是错误的语法，使用布尔表达式时，其中是像这样的函数调用，注意到我的全部发言。
- en: to stir comp i'm passing in two inputs，names bracket i，and quote unquote ron
    and therefore i'm。expecting stir comp to return，output a so-called return value
    that。return value is going to be negative。![](img/0a07aadb299f2538eddc3c64659844e7_104.png)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搅拌比较，我传入两个输入，名字的括号我和引号罗恩，因此我期待搅拌比较返回，一个所谓的返回值，这个返回值将是负的。![](img/0a07aadb299f2538eddc3c64659844e7_104.png)
- en: clear，bill，and name's bracket i or names bracket，zero is bill，bill comma ron
    is effectively what my。input is on the first iteration。![](img/0a07aadb299f2538eddc3c64659844e7_106.png)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰，账单，和名字的括号我或名字的括号，零是账单，账单逗号罗恩实际上是我在第一次迭代中的输入。![](img/0a07aadb299f2538eddc3c64659844e7_106.png)
- en: bill alphabetically and asciibetically，comes before ron which means it should。be
    returning a negative value to me，and the problem with boolean expressions。is as
    implemented in this context，is that only zero is false，any other return value
    is by definition。true or a yes answer whether it's，negative one or positive one，negative
    one million or positive one。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按字母顺序和ASCII顺序，账单在罗恩之前，这意味着它应该返回一个负值给我，而布尔表达式的问题是，在这个上下文中实现的，只有零是假的，任何其他返回值根据定义都是真的，或者是“是”的回答，无论是负一还是正一，负一百万或正一百万。
- en: million any non-zero value in a computer，language like c，is considered true
    also known as *****。![](img/0a07aadb299f2538eddc3c64659844e7_108.png)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机语言中，像C这样的语言中的任何非零值都被视为真，也称为*****。![](img/0a07aadb299f2538eddc3c64659844e7_108.png)
- en: false but，only that value is considered false so，really i was getting。lucky
    at first because my program was，for ron，then when i did it again for caleb and
    i。capitalized ron，i was getting unlucky because suddenly i，knew ron capitalized
    wasn't in the array。and yet i'm still saying he's found but，that's because i didn't
    practice what i。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是错误的，但只有那个值被视为假，所以我实际上一开始很幸运，因为我的程序是为“RON”设计的。然后当我再次为凯勒布执行时，我把“RON”大写，我就不再幸运，因为突然间我知道大写的“RON”不在数组中。然而，我仍然说他被找到了，但那是因为我没有练习我。
- en: preach per sophia is fine，and so if i actually compare this，against zero and
    now caleb we come full。circle to your question，i rebuild this program with make
    names i。now do dot slash names and search for，all caps ron i should now see thankfully。![](img/0a07aadb299f2538eddc3c64659844e7_110.png)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 传教士每个智慧都是好的，所以如果我实际上将这与零进行比较，现在凯勒布我们就回到了你的问题，我用名字重建了这个程序。我现在执行`dot slash names`并搜索所有大写的“RON”，我应该能看到，谢谢。
- en: not found so i wish i could say that was，deliberate but，thus is uh the common
    case of bugs so。here i am 20 years later making bugs in，my code so if you run
    up to a similar，problem this week。rest assured that it never gets，it never ends
    but hopefully you won't。have several hundred people watching you，while you do
    your problem set this week。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 未找到，所以我希望我能说这是故意的，但这实际上是常见的错误情况。所以在这里，我20年后在我的代码中制造错误。如果你这周遇到类似的问题，请放心，它永远不会结束，但希望你在做题时不会有几百人盯着你。
- en: all right any questions then beyond，answer is no it。![](img/0a07aadb299f2538eddc3c64659844e7_112.png)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，还有其他问题吗？答案是没有。
- en: is case sensitive so it does not find，rob，any questions on linear search using，strings。no
    all right well let's go ah**d and do，one final example i think with searching。but
    let's introduce just one other，feature and this one's actually pretty，cool and
    powerful。up until now we've been using data types，like int，and char and float
    and the like and，you'll see now。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是区分大小写的，因此不会找到“ROB”。关于使用字符串的线性搜索有任何问题吗？没有，好吧，让我们继续做一个最终的例子，我认为是关于搜索的。但让我们引入另一个特性，这实际上非常酷且强大。直到现在，我们一直在使用像`int`、`char`和`float`等数据类型，你现在会看到。
- en: that there's actually sometimes reasons，own，custom data types our own types
    that。didn't exist when c itself was invented，so for instance suppose that i want
    to。represent not just a whole bunch of，numbers and not just a whole bunch of。names
    but suppose i want to implement，book of course，contains both names and numbers
    and。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时实际上有理由创建我们自己的自定义数据类型，这些数据类型在C语言发明时并不存在。所以，例如，假设我想表示的不仅仅是一堆数字，而不仅仅是一堆名字，但假设我想实现的书当然包含名字和数字。
- en: suppose i want to combine these two，ideas together，wouldn't it be nice if i
    could have a。data structure，that is a data type that has some，structure to it。that
    can actually store both at once and，in fact wouldn't it be nice if c，i want to
    represent。![](img/0a07aadb299f2538eddc3c64659844e7_114.png)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想将这两个想法结合起来，如果我能有一个数据结构，那将是一个有某种结构的数据类型，能够同时存储两者，那不是很好吗？事实上，如果C语言，我想表示。
- en: a person like in a phone book who has，both a name and a number。i can actually
    implement that end code，by calling that，variable of type person now of course。the
    designers of c did not have the，force site to，create a data type called person
    and。indeed that would be a slippery slope if，they had a data type for every。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像电话簿中的一个人，既有名字又有号码。我实际上可以通过调用那种类型的变量“person”来实现这一点。当然，C语言的设计者并没有强迫创建一个名为“person”的数据类型。实际上，如果他们为每个数据类型都创建一个，那将是一个滑坡。
- en: real world entity you can think of but，this，of phone books，has both a name and
    a number we might。think of it as follows，a name and a number both of type string，but
    a quick check here。why have i now decided somewhat，presumptuously to call phone
    numbers。strings as well we've been talking about，ins behind these doors we've
    been，searching for ins in code。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象的现实世界实体，但这个电话簿既有名字又有号码，我们可以这样理解，一个名字和一个号码都是字符串类型。快速检查一下，为什么我现在有点自作主张地将电话号码称为字符串？我们一直在谈论这些门后面的“ins”，我们一直在代码中搜索“ins”。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_116.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_116.png)'
- en: but why did i just presume to propose，that we instead implement a，numbers。uh
    yeah because because we're not doing，math on it it's like，like a phone number
    could be like。letters for all we care and in fact i，mean like sometimes you see
    like。1-800 contacts or something like that，and maybe we want to allow that。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但我为什么会假设我们改为实现一个，数字呢。呃，是的，因为我们并不是在做，数学，这就像，电话号码可以是字母，随我们怎么想，实际上我，想说有时候你会看到像，1-800
    contacts这样的东西，也许我们想允许这样。
- en: yeah absolutely a phone number despite，its name isn't necessarily just a number。![](img/0a07aadb299f2538eddc3c64659844e7_118.png)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，绝对是一个电话号码，尽管它的名字不一定只是一个数字。![](img/0a07aadb299f2538eddc3c64659844e7_118.png)
- en: it might be 1 800，contacts which is an english word it，might have hyphens in
    it or dashes it。might have parentheses in it it might，there's a lot of，characters
    that we absolutely can。represent and see using strings that we，couldn't represent。![](img/0a07aadb299f2538eddc3c64659844e7_120.png)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能是1 800 contacts，这个是一个英文单词，它可能有连字符或破折号，可能有括号，它可能，有很多，我们绝对可以，表示并使用字符串，但我们无法表示。![](img/0a07aadb299f2538eddc3c64659844e7_120.png)
- en: in c using ants and so indeed even，though in the real world there are these。numbers
    that you and i talk about，once in a while like phone numbers maybe，in the u。s
    social security numbers，credit card numbers those aren't，necessarily values that
    you want to。treat as actual integers and in fact，those of you who did the credit
    problem。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中使用蚂蚁，实际上即使在现实世界中，有这些数字，你我偶尔会提到，比如电话号码，也许，在美国的社会安全号码，信用卡号码，那些不一定是你想要的，处理为实际整数，实际上，你们中那些做了信用问题的人。
- en: and tried to validate credit card，challenges，card number，it probably in retrospect
    might very。well have been easier for you to treat，credit card numbers as strings
    the catch。of course by design is that you didn't，least，in c yet so suppose i want
    to create my。own custom data type that，encapsulates if you will two different，types
    of values a person shall be。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 并尝试验证信用卡，挑战，卡号，回想起来，可能对你来说，把信用卡号视为字符串会更容易，当然设计的陷阱是你没有，至少，在C语言中。所以假设我想创建我自己的自定义数据类型，封装如果你愿意，两个不同的值类型，一个人应该是。
- en: henceforth a name，and a number it turns out that c gives，us this syntax here。this
    is the only juicy piece of new，syntax besides those curly braces a。moment ago
    that we'll see today and see，type def and as the name rather。succinctly suggests
    this allows you to，define a type，and the type will be a structure of some。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从此，名字和数字，结果是C语言给了我们这个语法。这是今天我们将看到的唯一一段新的，语法，除了刚才的花括号。类型定义，正如名字简洁地暗示的，这允许你，定义一个类型，而该类型将是某种结构。
- en: sort so a data structure in a，programming language，is typically a data type
    that has some，structure。it typically has one or more values，inside of it so using，typedef
    and in turn using the struct。keyword we can create our own custom，of，multiple
    other data types so if we want，to keep persons。together as their own custom data
    type，the syntax is a little cryptic here you。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在编程语言中，数据结构通常是一个有某种结构的数据类型。它通常包含一个或多个值，内部使用，`typedef`，并依次使用 `struct` 关键字，我们可以创建我们自己的自定义的，多个其他数据类型。因此，如果我们想要，把人们，作为他们自己的自定义数据类型，语法在这里有点晦涩。
- en: literally do type def struct，open curly brace then one per line you。![](img/0a07aadb299f2538eddc3c64659844e7_122.png)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 字面上输入 `def struct`，打开花括号，然后逐行输入。![](img/0a07aadb299f2538eddc3c64659844e7_122.png)
- en: specify the data types that you want and，the names that you want to give to
    those。data types for instance name and number，and then outside of the closing
    curly。brace you literally put，data type。![](img/0a07aadb299f2538eddc3c64659844e7_124.png)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 指定你想要的数据类型，以及你想要给那些数据类型的名称，例如名字和数字，然后在关闭的花括号外面，你实际上写上，数据类型。![](img/0a07aadb299f2538eddc3c64659844e7_124.png)
- en: that you want to invent so how can we，use this more powerfully well let's go，ahead
    and do things。![](img/0a07aadb299f2538eddc3c64659844e7_126.png)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你想发明的，那么我们如何可以，更强大地使用它呢？好吧，让我们继续做一些事情。![](img/0a07aadb299f2538eddc3c64659844e7_126.png)
- en: the wrong way without this feature first，so as to motivate its existence。![](img/0a07aadb299f2538eddc3c64659844e7_128.png)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有这个功能的情况下，以错误的方式进行，这样可以激励其存在。![](img/0a07aadb299f2538eddc3c64659844e7_128.png)
- en: let me go ah**d and save this file as，phonebook。c，and let me start as always
    with include，cs50。h。and then let me go ah**d and include，standardio。h and then
    lastly let me also，include string。h because i know i'm，a moment，pro function，let
    me go ah**d and give myself。initially for the first version of this，program a
    whole bunch of names。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续将这个文件保存为`phonebook.c`，然后像往常一样以`#include cs50.h`开始。接着让我继续包含`#include stdio.h`，最后让我也包含`#include
    string.h`，因为我知道我需要字符串函数，让我继续为这个程序的第一个版本设置一堆名字。
- en: specifically how about brian comma，david we'll keep it short uh just so as，data
    they're in。then brian and i each have phone numbers，array，before and，uh plus 1
    617 four nine。four nine five one thousand and indeed，there's already motivation
    per kurtz，comment to use。strings because we've got a plus and a，couple of dashes
    in there。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，布赖恩，戴维，我们保持简短，仅仅作为数据而已。他们在这里。然后布赖恩和我各自有电话号码数组，前面是，呃加上1 617 494 951000，确实，库尔茨的评论已经激励我们使用字符串，因为里面有加号和几个短横线。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_130.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_130.png)'
- en: and then my number here so we'll do plus，*****，*****，curly brace semicolon。so
    i've gone ahead and declared two，numbers，and i'm just gonna have a sort of uh。um
    handshake agreement that the first，name and names corresponds to the first，number
    and numbers。the second name and names corresponds to，the second number，in numbers
    you can imagine that working。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我的数字在这里，所以我们做加法，*****，*****，花括号和分号。因此，我已经声明了两个数字，我将进行一种默契协议，确保名字中的第一个与数字中的第一个对应，名字中的第二个与数字中的第二个对应，你可以想象这将如何工作。
- en: well so long as you don't make any，mistakes and you have，just the right number
    in each now let me。than，two i'm going to keep that hard-coded，for now just to
    do the demonstration。and then inside of this loop let me go，ahead and search for
    my phone number for，the end。so if stir compare of names bracket i，equals rather
    comma，david equals equals zero so i'm not。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，只要你不犯任何错误，并且每个元素的数量刚好合适，现在让我。比两个更多的数字，我将暂时保持硬编码，只为演示。然后在这个循环里，让我继续搜索我的电话号码，直到结束。因此，如果`strcmp(names[i],
    "david") == 0`，我就不。
- en: going to make that mistake again，let me go ah**d inside of this loop，inside
    of this condition here。and i'm going to go ah**d and do the，following print out，that
    i found for instance my。number and i'm going to plug that in so，numbers bracket
    i，and then as before i'm going to go ah**d。and return zero and if none of this，array，i'll
    go ah**d and print out as before，not found。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会再犯那个错误了，让我继续在这个循环里，在这个条件里进行下去。我将继续进行打印，比如说我的数字，我将把它插入，所以数字的括号是i，然后像之前一样，我将继续返回零。如果这个数组里没有，我将继续像之前一样打印“未找到”。
- en: with a semicolon and then i'll return，one i could，return a million negative
    million but。you go from one，zero to one to two to three on up if you，have that
    many possible error conditions。all right so i essentially have，implemented in
    c a phone book of sorts，zero。now i'm doing it in code it's a limited，phone book
    it's only got two names and。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以分号结束，然后我将返回1，我可以返回负一百万，但你从1、0到1到2到3，如果有那么多可能的错误条件。好的，所以我在C语言中基本上实现了一个电话簿，算是一个零。现在我在代码中实现它，这是一个有限的电话簿，它只有两个名字。
- en: two numbers but i could certainly，implement this phone book by just using，will。by
    just using the honor system that the，first element in names lines up with the。first
    element in numbers，and so forth now hopefully if i didn't。make any typos let me
    go ah**d and make，phone book all right it compiled okay，dot slash phone book。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个数字，但我当然可以通过使用Honor系统来实现这个电话簿，确保名字的第一个元素与数字的第一个元素对应，依此类推。现在希望如果我没有打错，让我继续做这个电话簿，好的，它编译成功了，运行命令`./phonebook`。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_132.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_132.png)'
- en: and it found what seems to be my number，there so it seems to work correctly。though
    i've tried to pull that one over，you before but i'm pretty sure this one。actually
    works correctly。![](img/0a07aadb299f2538eddc3c64659844e7_134.png)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它找到的似乎是我的号码，所以看起来工作正常。虽然我之前试图将那个号码拉过来，但我很确定这个实际上是正确的。![](img/0a07aadb299f2538eddc3c64659844e7_134.png)
- en: and so we found my name and intern，number，but why is the design of this code
    not。necessarily the best，this is starting to get more subtle，admittedly。and we've
    seen that we can do this，differently but what，rubs you the wrong way about here
    this。is another example of what we might call，code smell like something's a little，funky
    here like。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们找到了我的名字和实习生编号，但为什么这个代码的设计不一定是最好的呢？这开始变得更微妙，确实如此。我们已经看到可以以不同的方式做到这一点，但这里让你感觉不舒服的是，这又是我们可能称之为代码异味的一个例子，感觉有点奇怪。
- en: ah this might not be the best solution，yeah so what i'm guessing is that uh。like
    you know how you made the data，frame before like the new data structure，together。in
    this case we're just banking on the，fact that like we don't screw something。them
    from like the same，linked，yeah which might not be like that's。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，这可能不是最好的解决方案。我想的是，像你之前创建数据框一样，将新的数据结构组合在一起。在这种情况下，我们只寄希望于不从相同的链中搞砸。
- en: exactly the right instinct in general as，great as a programmer as you're maybe。aspiring
    to be you're not all that and，like you're going to make mistakes。and the more
    you can write code that's，yourself，the better off you're going to be the。more
    correct your code is going to be，and the more，more easily you're going to be able
    to。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你的直觉是正确的，作为一个程序员，虽然你可能渴望成为更好，但你并没有那么完美，你会犯错误。而且你编写的代码越是反映出你自己，你的代码就会越正确，你将能够更轻松地。
- en: collaborate successfully if you so，choose in the real world，on real world programming
    projects。whether it's for a research project a，like，generally speaking you should
    not trust，yourself or。other people that with whom you're，writing code you should
    have as many，defense mechanisms in place。exactly along these lines so yes there's，the
    sense that this，is correct but as noted if you screw up。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择在现实世界中合作，参与真实的编程项目，比如一个研究项目，那么一般来说，你不应该完全信任自己或其他与你一起编写代码的人。你应该有尽可能多的防御机制，就像这样，因此，虽然这听起来是对的，但如前所述，如果你出错了。
- en: and maybe you get an off by one error，maybe you transpose two names or two。numbers
    i mean imagine if you've got，dozens of names and numbers hundreds of。names and
    numbers thousands of them，the odds that you you or someone messes。the order up
    at some point，is just probably going to be too too，could sort of。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会遇到错位错误，或者交换了两个名字或两个数字。想象一下，如果你有几十个、几百个，甚至几千个名字和数字，出现顺序错误的几率可能会太高，可能会出现混乱。
- en: keep related data together this is kind，say，my arrays line up i'm just going
    to make。sure to keep them the same length，we can do better let's keep related
    data，together and design。this a little more cleanly and i can do，this by defining
    my own type。that i'll call for instance a person so，at this top of this file。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 保持相关数据在一起，这是我的数组对齐。我只会确保它们长度相同。我们可以做得更好，让我们保持相关数据在一起，并更干净地设计它。我可以通过定义自己的类型来做到这一点，举个例子，称之为“人”。
- en: before main i'm going to go ah**d and，type def a structure，inside of which are
    the two types of。data that i care about，before，notice though here that what i
    have done。here is not give myself an array i've，given myself one name and one
    number。outside of this curly brace i'm going to，give this data type a name which
    i could。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数之前，我将定义一个结构体，其中包含我关心的两种数据类型。请注意，我所做的不是给自己一个数组，而是给自己一个名字和一个数字。在这个花括号外面，我将给这个数据类型一个名字。
- en: call person i could call it anything i，in this case，and now down here i'm going
    to go ah**d。and change this code，a little bit i'm going to go ah**d and，give myself
    an array still。but this time i'm going to give myself，an array of persons，and
    i'm going to call that array。somewhat playfully people，people，in this program
    me and brian now i want。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给它任何名称，在这个例子中。而现在在这里，我将稍微改变一下这个代码，我将仍然给自己一个数组，但这次我将给自己一个“人”的数组，我将以某种俏皮的方式称呼这个数组为“people”。在这个程序中，我和布莱恩现在想要。
- en: to go ah**d and populate this array that，is i want to fill it with values and，just。to
    enable us to actually store values，inside of a structure，if i want to index into
    this array，i do。people bracket zero that's going to give，me the first person，variable
    inside so probably where brian。is supposed to go，the one last piece of syntax
    i need is，how do i go inside of that。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 去填充这个数组，我想用值填充它，以便我们能够实际存储值在结构内。如果我想索引这个数组，我就用`people[0]`，这将给我第一个人变量，所以可能布莱恩应该在这里。我需要的最后一部分语法是，如何进入里面。
- en: structure that person data structure and，access the person's name。i literally
    just do a dot so people，bracket zero gives me the first。person in the people array
    and then the，dot means go inside of it and grab。the person variable i'm going
    to go，ahead and set that name equal to，quote-unquote brian。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化那个个人数据结构，并访问个人的名字。我实际上只需做一个点，因此`people[0]`给我第一个人，然后点表示进入并抓取。我要继续将这个名字设置为“布莱恩”。
- en: the syntax now for his name is almost，identical people bracket zero，six one
    seven。four nine five one thousand semicolon，meanwhile if i want to access a location。for
    myself i'm going to go ah**d and put，location，name will be quote unquote david
    and。then over here i'm going to do，peoplebracket1。number，equals quote unquote
    plus four nine four。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在他的名字的语法几乎是相同的`people[0][617495]`；同时，如果我想访问我的位置，我将继续并设置`location`，名字将是“戴维”，然后在这里我将做`people[1].number
    = "494"`。
- en: six eight two seven，bit verbose，admittedly but you could imagine if we，just
    let our thoughts run。run ahead of ourselves here if you used，getstring you could
    sort of。automatically do this if you used，command line arguments maybe you could，populate
    some of this。we don't just have to hard code that is，into this program，you can
    imagine doing this more。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 六八二七，有点冗长，诚然，但你可以想象，如果我们让思绪自由奔放。如果你使用`getstring`，你可以在某种程度上自动完成这项工作；如果你使用命令行参数，或许可以填充一些内容。我们不必仅仅将它硬编码到这个程序中，你可以想象更灵活的做法。
- en: dynamically using some of our techniques，using getstring and so forth。from week
    one but for now it's just for，demonstrations sake so now if i want to。search this
    new array，this new single array of people，i think my for loop can stay the same。and
    i think i can still use stir compare，but now i need to go inside of not names。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 动态地使用我们的一些技术，使用`getstring`等。从第一周开始，但现在只是为了演示，所以如果我想搜索这个新数组，这个单一的人员数组，我认为我的`for`循环可以保持不变，我仍然可以使用`str_compare`，但现在我需要进入的不是名字。
- en: but people and look for the dot name，field so data structures have fields or。variables
    inside of them，so i'm going to use the dot notation，there too go into the ith。person
    in the people array and compare，unquote david，and then if i have found david in
    this。case myself，go ah**d and access the people array，again but print out using
    printf。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在`people`中查找点名称字段，所以数据结构中有字段或变量，所以我也将使用点表示法，进入`people`数组中的第i个人并比较“戴维”，如果我在这种情况下找到了戴维，继续访问`people`数组，再次用`printf`打印。
- en: the number so again the dot operator is，the only new piece of syntax that's，letting
    us go inside of。this new feature known as a data，structure if i go ah**d and make
    phone。book again after making those changes，all is well it compiled okay and if
    i，run dot slash phone book。again，so here is sort of a seemingly useless，exercise
    and that all i really did was。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次强调，点操作符是唯一的新语法，让我们能够进入这个被称为数据结构的新特性。如果我继续再做一次电话簿，在做完这些更改后，一切正常，编译也没问题，如果我再次运行`./phonebook`。这里似乎是一个无用的练习，我所做的其实就是。
- en: re-implement the same program using more。![](img/0a07aadb299f2538eddc3c64659844e7_136.png)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重新实现同样的程序，使用更多。![](img/0a07aadb299f2538eddc3c64659844e7_136.png)
- en: complicated，but it's now better designed or it's a，step toward being better
    designed。because now i've encapsulated all inside，of one variable。![](img/0a07aadb299f2538eddc3c64659844e7_138.png)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂，但现在设计得更好，或者说是朝着更好的设计迈出了一步。因为现在我将所有内容封装在一个变量中。![](img/0a07aadb299f2538eddc3c64659844e7_138.png)
- en: for instance people bracket zero people，bracket one all of the information we。care
    about with respect to brian，or me or anyone else we might put into。this program
    and indeed this is how。![](img/0a07aadb299f2538eddc3c64659844e7_140.png)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`people[0]`，`people[1]`，所有我们关心的信息都与布莱恩，或我，或任何我们可能放入这个程序的人有关，实际上这就是。![](img/0a07aadb299f2538eddc3c64659844e7_140.png)
- en: programs this is how googles of the，world facebooks of the world store lots。of
    information together consider any of，your social media accounts like。instagram
    or facebook or snapchat and，data，associated with you on all of those。platforms
    not just your username，of posts，also your friends and followers and the。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是谷歌和脸书这样的公司如何存储大量信息的方式，考虑一下你的任何社交媒体账户，如Instagram、Facebook或Snapchat，以及与您在所有这些平台上相关的数据，不仅仅是你的用户名和帖子，还有你的朋友和粉丝。
- en: like so there's a lot of information，that these companies were better for。worse
    or collecting on all of us，big array。![](img/0a07aadb299f2538eddc3c64659844e7_142.png)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些公司收集关于我们的大量信息是有利的或不利的，大数组。![](img/0a07aadb299f2538eddc3c64659844e7_142.png)
- en: with all of our usernames one big array，with all of our passwords one big array。with
    all of our friends，like you can imagine certainly at scale，that's gotta be a bad。design
    to just trust that you're gonna，get the ordering of all of these things。right
    they don't do that，they instead write code in some language，that somehow encapsulates。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的用户名放在一个大数组中，所有的密码放在一个大数组中，所有的朋友，如你所想，确实在规模上这肯定是一个糟糕的设计，只是相信你会正确地排序所有这些东西。他们并没有这样做，而是用某种语言编写代码，某种方式进行封装。
- en: all the information related to me and，brian and you，inside of some kind of data
    structure。and that's what they put in their，database or some other server。on their
    back end so this encapsulation，is a feature we now have in terms of c。and it allows
    us to create our own data，structures that we can then use。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与我、布莱恩和你相关的信息，存储在某种数据结构中。这就是他们放入他们的数据库或其他服务器的内容。在他们的后台，这种封装是我们在C语言中现在拥有的一个特性，它允许我们创建自己的数据结构，随后可以使用。
- en: in order to keep related data，together all right any questions then on。data
    structures or more specifically，type def，and struct the c keywords with which
    you，can create。your own custom types that themselves，uh hi so is it typical to
    define the new，data structure。outside of main like in the header，really good question
    is it typical to，main，immaterial。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将相关数据放在一起，好的，有关数据结构或更具体地说，typedef和struct的任何问题，这些是C语言的关键字，通过它们你可以创建自己的自定义类型，呃，所以在main外定义新的数据结构是否典型，像在头文件中，真是个好问题，它在main外是否典型并不重要。
- en: because i only have one function in this，program maine but as we'll see。this
    week and next week and onward our，programs are going to start to get a，little
    more complicated。by nature of just having more features，and once you have more
    features you。probably have more functions，and when you have more functions you，to。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个程序中我只有一个函数，但正如我们本周、下周及之后将看到的那样，我们的程序会开始变得有些复杂。因为自然而然会有更多的功能，一旦你有更多的功能，你可能会有更多的函数，而当你有更多的函数时，你也会有更多的。
- en: all of those functions and we'll so，we'll begin to see，definition of some of
    these structures。being indeed outside of our own，functions，classes and，header
    files later or will we keep。defining them outside of main，really good question
    might we define our，own uh types。and our own data structures in header，files yes
    eventually we'll do that too。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数，我们将开始看到一些这些结构的定义，实际上是在我们自己的函数、类和头文件之外，或者我们是否会继续在main外定义它们，这真是个好问题，我们是否会在头文件中定义我们自己的类型和数据结构，最终我们会做到这一点。
- en: thus far you and i have only been using，header files that other people wrote。we've
    been using standardio。h string。h，that the authors of c created you've，been using
    cs50。h with wii，the staff wrote it turns out you can，also create your own header
    files your，own。h files。inside of which are pieces of code that。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，你我只使用了别人写的头文件。我们一直在使用标准输入输出头文件（stdio.h）、字符串头文件（string.h），这些是C语言的作者创建的，你一直在使用CS50.h，这是工作人员编写的，结果是你也可以创建自己的头文件，你自己的.h文件，其中包含一些代码。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_144.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_144.png)'
- en: you want to share，across multiple files of your own we're，not quite there yet
    but yes peter。![](img/0a07aadb299f2538eddc3c64659844e7_146.png)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在多个文件中共享你的内容，我们还没有完全到达那里，但没错，彼得。![](img/0a07aadb299f2538eddc3c64659844e7_146.png)
- en: that would be a solution too to this，problem by putting it in one，i was i was
    thinking。takes enough information to solve the，upsets，because i feel there's，misinformation
    i。am a freshman and，i was taking i was so，concentrated and i can't go on go ah**d。on
    the upsets is there anything that i'm，missing，it's a really good question and
    quite，so。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是解决这个问题的一种方案，将其放在一个地方。我当时在想，解决这些问题需要足够的信息，因为我觉得有些误导。我是一名新生，我在专注，但我无法继续。关于这些问题，有没有我遗漏的？这是一个非常好的问题，确实如此。
- en: um indeed recall from week zero this the，the fire hose，uh metaphor that i i
    borrowed from mit's。the case，um there's a lot of new syntax a lot of，new ideas
    all at once but。when it comes to the individual problems，and the problem sets，do
    realize that you should take those。work。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，确实记得从零周的“消防水管”隐喻，这个我借鉴自MIT。这个案例中，有很多新语法和新概念一下子涌现，但当涉及到单独的问题和问题集时，要意识到你应该去完成那些工作。
- en: '![](img/0a07aadb299f2538eddc3c64659844e7_148.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a07aadb299f2538eddc3c64659844e7_148.png)'
- en: complicated，and throughout each of the lectures and，live，or via the examples
    that are pre-made on。the course's website for your review，there's always little
    clues or hints or。examples that you can then do，like，labs and the like will you
    see。additional building blocks as well so，feel free to reach out more individually。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的内容，在每一节讲座中，以及通过课程网站上预先制作的示例进行复习，总是有一些小线索、提示或示例，你可以去做，比如实验室等，你会看到额外的构建块，所以，随时可以更个别地联系我。
- en: afterwards happy to point you at some of，those resources in fact。most recently
    two will you notice on the，course's website what we call。![](img/0a07aadb299f2538eddc3c64659844e7_150.png)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 之后很乐意向你推荐一些资源，实际上最近你会注意到课程网站上我们所称的。![](img/0a07aadb299f2538eddc3c64659844e7_150.png)
- en: shorts which are shorter videos made by，lloyd。![](img/0a07aadb299f2538eddc3c64659844e7_152.png)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: shorts 是由lloyd制作的较短视频。![](img/0a07aadb299f2538eddc3c64659844e7_152.png)
- en: which are literally short videos on very，specific topics so after today。you'll
    see short videos by doug with a，different perspective on linear search，on binary
    search。and on a number of other algorithms as，um i was wondering what the return，values
    that we have。that be，like what's an example of what we would，there are like。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是关于非常特定主题的短视频，所以在今天之后。你会看到Doug制作的短视频，提供对线性搜索、二进制搜索以及其他一些算法的不同视角。嗯，我想知道我们有什么返回值。比如我们有什么示例。
- en: several different cases and we want to，somehow keep track of them。exactly the
    latter so right now honestly。![](img/0a07aadb299f2538eddc3c64659844e7_154.png)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的情况，我们想要以某种方式跟踪它们。实际上正是后者，所以现在说实话。![](img/0a07aadb299f2538eddc3c64659844e7_154.png)
- en: bothering to，spend time returning zero or returning。![](img/0a07aadb299f2538eddc3c64659844e7_156.png)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花时间返回零或返回。![](img/0a07aadb299f2538eddc3c64659844e7_156.png)
- en: because we're not，using the information but what we're，trying to do is sort
    of lay the。![](img/0a07aadb299f2538eddc3c64659844e7_158.png)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有使用信息，但我们想要做的是铺垫。![](img/0a07aadb299f2538eddc3c64659844e7_158.png)
- en: foundation for more complicated programs，and indeed this week and next week
    and。![](img/0a07aadb299f2538eddc3c64659844e7_160.png)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为更复杂的程序打下基础，实际上这周和下周。![](img/0a07aadb299f2538eddc3c64659844e7_160.png)
- en: longer，and as we the course start providing you。![](img/0a07aadb299f2538eddc3c64659844e7_162.png)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 更长的时间，当我们开始提供课程时。![](img/0a07aadb299f2538eddc3c64659844e7_162.png)
- en: with starter code or distribution code，that is lines of code that the staff
    and。![](img/0a07aadb299f2538eddc3c64659844e7_164.png)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随起始代码或分发代码，也就是员工提供的代码行。![](img/0a07aadb299f2538eddc3c64659844e7_164.png)
- en: i write that you then have to build upon，it's going to be a very useful mechanism。to
    be able to signal that this went。![](img/0a07aadb299f2538eddc3c64659844e7_166.png)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我写下的内容是你接下来必须建立的，这将是一个非常有用的机制，以便能够标示出这些内容。![](img/0a07aadb299f2538eddc3c64659844e7_166.png)
- en: wrong or this other thing went wrong，so all we're doing is sort of preparing。for
    that inevitability even。![](img/0a07aadb299f2538eddc3c64659844e7_168.png)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 错误或其他事情出现问题，所以我们所做的只是准备。为了那种不可避免的情况。![](img/0a07aadb299f2538eddc3c64659844e7_168.png)
- en: if right now it doesn't really seem to，be scratching an itch，i was just going
    to ask really quickly。obviously in this code we have，people，so let's say we had
    10 or 20 or even 30。people i know it was a question of the，chat but i just wanted
    to clarify for，myself too。and the the what if being what what，would change or
    what what's the end of，that question。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在似乎没有解决什么问题，我只是想快速问一下。显然在这段代码中我们有人员，所以假设我们有10、20甚至30个人，我知道这是聊天中的一个问题，但我只想为自己澄清一下。然后这个“如果”意味着什么，什么会改变，或者这个问题的结局是什么。
- en: yeah what would change the code or what，problem，ah okay good question so if
    we were to。have more names like a third name or a，tenth name or the like，the only
    things that we would have to。change in this version of the program，is first on
    line 14 the size of the，people。we need to decide in advance that we're，going to
    have 10 people better still。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，什么会改变代码或什么问题，啊，好问题，所以如果我们有更多名字，比如第三个名字或第十个名字，唯一需要在这个版本的程序中更改的事情是，首先在第14行，people的大小。我们需要提前决定我们将有10个人，最好是。
- en: i could for instance allocate myself a，constant up here so let me actually go。up
    here just like we did，in a previous class where we did，something like this const
    inst，to 10。and recall that const means constant，that means this variable can't
    change。int of course means it's an integer the，fact that i've capitalized it is
    just a。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以在这里分配一个常量，所以让我实际上回到这里，就像我们在以前的课程中做的那样，做类似const inst等于10的事情。请记住，const意味着常量，这意味着这个变量不能改变。int当然意味着它是一个整数，我将它大写只是为了。
- en: human convention to make a little，visually clear that this，is a constant just
    so you don't forget。but it has no functional role and then，this of course is just
    a value to assign，to number。then i could go down here on line 16 and，plug in that
    variable so that i don't。have to hard code what people would call，a magic number，which
    is just a number that appears。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 人类习惯使得在视觉上稍微清晰一点，以便你不忘记这是一个常量，但它没有功能作用，然后，这当然只是一个分配给数字的值。然后我可以在第16行下去，插入那个变量，以便我不必硬编码人们所称的神奇数字，这只是一个出现的数字。
- en: seemingly out of nowhere now i've put，all of my special numbers，of my file。and
    now i'm using this variable here and，then what i could do and i alluded to。this
    only verbally before，i could absolutely start hard coding in。for instance montague's
    name and number，others，but honestly this seems kind of stupid。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我似乎突然之间将我所有的特殊数字放到了文件中。现在我在使用这个变量，然后我可以做的事情，我之前只是口头提到过，我可以绝对开始硬编码，例如蒙太古的名字和号码，其他的，但老实说，这似乎有点愚蠢。
- en: if you're just hard-coding all of these，names and numbers and in a few weeks，of
    the same。information in like a spreadsheet or，what's called a csv file comma separated。values
    or even in a proper，database which the the facebooks and，googles of the world
    would use。but what i could do for now is something，like this for int i gets 0，plus。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是硬编码所有这些名字和数字，而在几周后用相同的信息，例如电子表格或称为CSV文件的逗号分隔值，甚至在一个适当的数据库中，像Facebook和Google这样的公司会使用。但我现在可以做的事情是类似这样的，int
    i等于0，加上。
- en: and maybe i could do something like this，people bracket i，dot name equals get
    string。what's the name question mark and then，here i could do people bracket i
    dot，number equals get string。what's their number and i can ask that，question too。![](img/0a07aadb299f2538eddc3c64659844e7_170.png)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我可以这样做，people[i].name = get_string("名字是什么？")，然后在这里我可以做people[i].number = get_string("他们的号码是什么？")，我也可以问那个问题。![](img/0a07aadb299f2538eddc3c64659844e7_170.png)
- en: so now the program is getting to be a，little better designed i'm not，brian。now
    it's dynamic and technically the，the moment，but i could make that dynamic too
    i。could also call getint，or like you did this past week use a，command line argument。and
    parameterize the code so that it can，actually be for two people 10 people。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序设计得更好一些，我不是布莱恩。现在它是动态的，技术上是当前的，但我也可以让它动态，我也可以调用getint，或者像你上周那样使用命令行参数，并将代码参数化，以便它实际上可以适用于两个人或十个人。
- en: whatever you want the program can，dynamically adapt to it for you。other questions
    on structs on types，or the like，no all right so how did we get here，of。searching
    whereby we just want to find，someone in the doors we just want to。find someone
    in the array，we've sort of escalated things pretty。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你想要什么，程序都可以动态适应。关于结构或类型的其他问题吗？没有，好吧，那么我们是如何到达这里的？搜索，我们只是想找一个人在门口，我们只是想在数组中找到某个人，我们在某种程度上将事情升级得很快。
- en: quickly to finding not just numbers or，names but now，names with numbers in the
    form of these。data structures，but to do this efficiently really，requires a smarter
    algorithm like binary。search up until now we've only used，in c code linear search
    even though。![](img/0a07aadb299f2538eddc3c64659844e7_172.png)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 快速找到的不仅仅是数字或名字，而是现在，这些数据结构中带有数字的名字，但要有效地做到这一点，确实需要一个更智能的算法，比如二分查找。到目前为止，我们只在C代码中使用了线性搜索，即使如此。![](img/0a07aadb299f2538eddc3c64659844e7_172.png)
- en: recall that we did have at our disposal，this pseudocode for。![](img/0a07aadb299f2538eddc3c64659844e7_174.png)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆一下我们手头有这个伪代码。![](img/0a07aadb299f2538eddc3c64659844e7_174.png)
- en: binary search but with binary search，sorted，and so if you want to get the speed。benefits
    of searching more quickly，by having sorted numbers somehow someone。![](img/0a07aadb299f2538eddc3c64659844e7_176.png)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找，但是通过二分查找，已排序，所以如果你想获得更快的搜索速度，必须有某种方式将数字排序。
- en: is going to have to do that for us，joe for instance sorted behind the。curtain
    all of these numbers for us，but what algorithm did he use is going，how we can。![](img/0a07aadb299f2538eddc3c64659844e7_178.png)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 必须为我们做到这一点，比如乔就在幕后为我们整理了所有这些数字，但他用了什么算法，这将如何进行。
- en: sort numbers efficiently and indeed if，you're the googles and the facebooks
    and。the instagrams of the world。![](img/0a07aadb299f2538eddc3c64659844e7_180.png)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地对数字进行排序，实际上，如果你是谷歌、脸书和世界上的Instagram。
- en: in users，you surely want to keep that data sorted。![](img/0a07aadb299f2538eddc3c64659844e7_182.png)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户中，你当然希望保持数据排序。
- en: presumably so that you can use，algorithms like binary search to find，information
    quickly when you're。let's go ah**d，here take a five minute break and when，algorithms。for
    sorting that's going to enable us to。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 大概是这样你才能使用像二分查找这样的算法快速找到信息。我们来吧，**休息五分钟**，然后谈谈用于排序的算法，这将使我们能够。
