- en: P21：11-05-triggers-demo-part-1.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P21：11-05-triggers-demo-part-1.mp4 - 哈库那玛塔塔i - BV1R4411u7dt
- en: Now let's see triggers in action。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看触发器的实际效果。
- en: '![](img/7e20830836ab64c4abad011f627b0092_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e20830836ab64c4abad011f627b0092_1.png)'
- en: We're going to cover a number of features in the demonstration， which is going
    to be in two parts。 We'll cover before and after triggers with both insert， delete，
    and update triggering events。 We will not be covering instead of triggers， which
    are used primarily for views。 and so will be covered in the material on views。
    We'll show access to new and old data for the modified data that causes a trigger
    to be activated。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在演示中介绍许多特性，演示将分为两个部分。我们将讲解插入、删除和更新触发事件的前触发器和后触发器。我们不会讲解代替触发器，因为它们主要用于视图，因此会在视图的相关材料中讲解。我们将展示如何访问因触发器激活而修改的数据的旧数据和新数据。
- en: '![](img/7e20830836ab64c4abad011f627b0092_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e20830836ab64c4abad011f627b0092_3.png)'
- en: We'll show trigger conditions and trigger actions。 We'll show some triggers
    that are being used to enforce constraints。 We'll show trigger chaining。 where
    the execution of one trigger activates another trigger。 and we'll show triggers
    that activate themselves and cyclic behavior of triggers。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示触发器的条件和触发器的动作。我们将展示一些用于强制执行约束的触发器。我们还将展示触发器链式执行的情况，即一个触发器的执行激活另一个触发器，并展示触发器自激活及其循环行为。
- en: Conflicts when multiple triggers are activated at the same time。 and finally
    nested trigger invocations， when a trigger has several actions which themselves
    activate other triggers。 The video introducing triggers use the SQL standard。
    It so happens that no database system implements the exact standard。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个触发器同时被激活时的冲突，最后是嵌套触发器调用的情况，即当一个触发器有多个动作，而这些动作又激活了其他触发器。本视频中介绍的触发器使用了 SQL
    标准，但实际上没有任何数据库系统完全实现该标准。
- en: and in fact some systems deviate considerably from the standard。 not only in
    the syntax for specifying triggers， but also the behavior。 meaning one has to
    be very careful to understand the trigger system that one is using。 In terms of
    the primary open source systems at the time of this video。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一些系统在行为上偏离了标准，不仅在指定触发器的语法上有所不同，而且在行为上也有差异，这意味着必须非常小心，理解所使用的触发器系统。在本视频制作时，主要的开源系统是：
- en: Postgres has the most expressive trigger system。 SQLite is a little bit less
    expressive。 and MySQL is considerably more restrictive than the other two。 Let's
    look at some details。 In terms of expressiveness and behavior， Postgres is the
    closest to the standard。 It really does implement the full standard。 It has row
    level and statement level triggers。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres 拥有最具表现力的触发器系统，SQLite 的表现力稍弱，而 MySQL 则比其他两者更为限制。让我们看一下细节。在表现力和行为方面，Postgres
    最接近标准。它确实完全实现了该标准，并且支持行级触发器和语句级触发器。
- en: access to old and new rows and tables。 Unfortunately。 it uses its own cumbersome
    and somewhat awkward syntax。 making it not very suitable for our demonstration。
    SQLite implements row level triggers only。 and it also has immediate activation，
    which is a deviation in behavior from the standard。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 访问旧表和新表的行数据。遗憾的是，它使用了自己繁琐且略显尴尬的语法，这使得它不太适合我们的演示。SQLite 仅实现了行级触发器，而且它还有即时激活，这与标准的行为有所偏离。
- en: As we discussed in the introduction， the standard for triggers says that if
    we have a modification statement that makes many changes。 regardless of whether
    we have a row level or statement level trigger。 we execute triggers at the end
    of the statement。 Whereas in SQLite， we have row level triggers only。 and they're
    activated after each row level change to the database。 As a result。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中讨论的，标准规定，如果我们有一个修改语句进行许多更改，不管是行级触发器还是语句级触发器，我们都会在语句结束时执行触发器。而在 SQLite
    中，我们只有行级触发器，并且它们在每次对数据库进行行级更改后被激活。结果是：
- en: SQLite also does not have access to new table or old table。 Like SQLite。 MySQL
    also has only row level triggers， and they are activated immediately instead of
    at the end of the statement。 They also don't have access to old and new table。
    There are two other significant limitations in MySQL。 One of them is that MySQL
    only permits one trigger per event type。 So， for example。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 也无法访问新表或旧表的数据。像 SQLite 一样，MySQL 也只有行级触发器，并且它们会立即激活，而不是在语句结束时激活。它们也无法访问旧表和新表数据。MySQL
    还有两个其他显著的限制。其中之一是 MySQL 每个事件类型只允许一个触发器。因此，例如：
- en: only one trigger for inserting into a particular table or deleting from a table。
    Furthermore。 there's limited trigger chaining allowed in MySQL。 Now， these features。
    if we want to call them that， do mean that the triggers in MySQL are quite understandable
    in how they behave。 because they're fairly restricted in what they can do， and
    specifically in how they can interact。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL中只有一个触发器用于插入特定表或从表中删除数据。此外，MySQL中允许的触发器链式调用是有限的。现在，如果我们要称这些为“特性”，那么它们意味着MySQL中的触发器行为相对容易理解，因为它们在功能上相对受限，尤其是在它们如何相互作用方面。
- en: For our demo， we'll be using SQLite。 Let me mention a few things about the syntax。
    Since there's row level triggers only， for each row。 although it's allowed to
    be specified in the trigger， is implicit if it's not present。 As I mentioned，
    there's no access to old table or new table， and so as a result。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将使用SQLite。让我提一下关于语法的一些事情。由于SQLite只有行级触发器，所以对于每一行，尽管它可以在触发器中被指定，但如果没有指定，则默认为隐式。正如我所提到的，无法访问旧表或新表，因此会导致一些结果。
- en: SQLite has no referencing clause。 Instead， it pre-binds variables old and new。
    too old row and new row。 We'll see that clearly in the demo。 Finally。 the action
    in SQLite triggers is a begin-end block with any number of SQL statements。 The
    demo is in two parts。 In this part of the demo， we'll be covering the first five
    features。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有引用子句。相反，它预先绑定了变量`old`和`new`，即旧行和新行。在演示中我们将清楚看到这一点。最后，SQLite触发器中的操作是一个包含任意数量SQL语句的begin-end块。演示分为两部分。在演示的第一部分，我们将涵盖前五个特性。
- en: The other three will be covered in the second part。 In the first part of the
    demo。 we'll be using our usual simple college admissions database with the college
    table， student table。 and students applying to colleges。 We'll be starting with
    our usual database， our four colleges。 our set of students， and our set of tuples
    of students applying to colleges。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另外三个特性将在第二部分中讲解。在演示的第一部分，我们将使用我们通常的简单大学招生数据库，包含大学表、学生表，以及学生申请大学的记录。我们将从我们的常规数据库开始，包括四所大学、我们的学生集合，以及学生申请大学的元组集合。
- en: The idea is that we'll be creating several different triggers。 and then we'll
    be modifying the database and see how those triggers behave。 Here's our first
    trigger。 Let me mention that the particular interface we're using does not allow
    us to execute trigger commands from this window。 so we'll actually be executing
    the commands separately。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念是，我们将创建多个不同的触发器，然后修改数据库并查看这些触发器的行为。这里是我们的第一个触发器。需要提到的是，我们使用的特定接口不允许我们从这个窗口执行触发器命令，因此我们将单独执行这些命令。
- en: Our first trigger will intercept insertions into the student table， and we'll
    check the GPA。 If the GPA of the inserted student is greater than 3。3 or less
    than or equal to 3。6。 that student will be automatically applying to Stanford
    for a geology major and applying to MIT for a biology。 Let's look a little closer
    at this syntax。 We give the trigger a name。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个触发器将拦截对学生表的插入操作，我们将检查GPA。如果插入学生的GPA大于3.3或小于等于3.6，那么该学生将自动申请斯坦福大学地质专业，并申请麻省理工学院生物学专业。让我们更仔细地看一下这个语法。我们为触发器指定一个名称。
- en: we specify the triggering event， in this case it's insertions on student。 Next
    we have the option of specifying for each row。 Now as a reminder。 in the SQLite
    system only the for each row option is implemented。 so even if we actually left
    this clause out， it would be a row level trigger。 Furthermore。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定触发事件，在这个例子中是对学生表的插入操作。接下来，我们有一个选项可以为每一行指定触发器。作为提醒，在SQLite系统中，只有“for each
    row”选项被实现，因此即使我们省略了这个子句，它仍然会是一个行级触发器。此外。
- en: SQLite does not have a referencing clause， so in the SQL standard there's the
    new row， old row。 new table， and all of the other things。 In SQLite only new row
    and old row are supported。 and therefore they're bound automatically to the predefined
    variables new and old。 Now remember new and old gives us a way to access the data
    that was modified to trigger that caused the trigger to be activated。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有引用子句，因此SQL标准中有新行、旧行、新表以及其他相关内容。在SQLite中，只有新行和旧行得到支持，因此它们会自动绑定到预定义的变量`new`和`old`。现在请记住，`new`和`old`为我们提供了一种访问修改数据的方式，这些数据触发了触发器的激活。
- en: In the case of an insertion there's only new data that would be the inserted
    row。 If we had an update we'd have both new and old available to us for the modified
    rows。 and if we had a delete， we'd have the new and old to use。 And if we had
    a delete we'd have only old。 and we'll see that in later examples。 In this particular
    example we're going to use new in our trigger condition to reference the insertion
    that caused the trigger to be activated。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入的情况下，只有新数据是插入的行。如果我们有更新操作，我们会同时获得修改行的新旧数据。如果我们有删除操作，我们将获得新旧数据可供使用。而如果是删除操作，我们只会得到旧数据。我们将在后面的示例中看到这些。在这个特定的示例中，我们将在触发器条件中使用`new`来引用触发器激活时插入的内容。
- en: We check if that inserted tuple has a GPA within the range we're looking for。
    If it does then we go ahead and the trigger will go ahead and execute the action。
    The action will insert two new tuples into the apply table。 and it will again
    use the new variable to access the inserted tuple we're working on。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查插入的元组是否满足我们设定的GPA范围。如果满足条件，触发器就会执行相应的操作。该操作将向apply表插入两个新元组，并再次使用new变量来访问我们正在处理的插入元组。
- en: so we'll get that SID for the inserted tuple， insert that together with Stanford。
    Geology and a null decision into apply， and similarly have that new student ID
    applying to MIT。 Biology with a null decision。 We've created the trigger so now
    let's try inserting some new students into our database。 Specifically we'll insert
    111 Kevin whose GPA is in the range that we're looking for for automatic applications。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将为插入的行获取SID，并将其与斯坦福大学、地质学和一个空值决策一起插入到apply表中，同时新学生ID也将应用于MIT大学、生物学以及空值决策。我们已经创建了触发器，现在让我们尝试向数据库插入一些新学生。具体来说，我们将插入111号Kevin，他的GPA在我们设定的自动申请范围内。
- en: and 222 Lori whose GPA is outside of that range。 Let's go ahead and insert those
    tuples and let's take a look at our data。 When we look at our student table we
    see that Kevin and Lori have been inserted。 Now let's take a look at apply。 Here
    we see that student 111 and that was Kevin with the 3。5 GPA has automatically
    been inserted to apply to Stanford in Geology， MIT in Biology。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有222号Lori，她的GPA不在这个范围内。让我们插入这些元组，然后查看我们的数据。当我们查看学生表时，我们看到Kevin和Lori已经被插入。接下来我们看一下apply表。在这里我们看到学生111，也就是GPA为3.5的Kevin，已经被自动插入申请斯坦福的地质学专业和MIT的生物学专业。
- en: and as a reminder， an empty cell indicates a null value。 So our trigger was
    activated by those insertions and it performed insertions into apply for Kevin。
    but again not for Lori because her GPA did not satisfy the trigger condition。
    Now let's make a more dramatic database modification to test out our trigger。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，空单元格表示空值。所以我们的触发器被这些插入操作激活，并将Kevin的申请插入到apply表中，但再次强调，Lori没有被插入，因为她的GPA未满足触发器条件。现在，让我们进行更大范围的数据库修改，来测试我们的触发器。
- en: We're going to essentially copy the entire student table into itself。 so we're
    going to double the size of the student table。 We're going to take each tuple
    and we're going to add a new tuple that's going to be identical except we're going
    to increment the student ID in order to generate a unique ID。 So when we insert
    all of these tuples into the student table again。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基本上把整个学生表复制到自身中，因此我们将使学生表的大小翻倍。我们将提取每一行，并添加一个新行，新行与原行完全相同，唯一的区别是我们将递增学生ID，以生成唯一的ID。因此，当我们将所有这些行再次插入到学生表时。
- en: all of those whose GPA is in the range between 3。3 and 3。6 should have an automatic
    tuple inserted into the apply。 actually two tuples inserted into the apply table
    having them apply to Stanford and MIT。 So here's the insert command。 We're going
    to insert into student the result of a query。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GPA在3.3到3.6之间的学生，应该在apply表中自动插入一个元组，实际上是插入两个元组，分别申请斯坦福大学和MIT大学。所以这是插入命令。我们将插入学生表，并使用查询结果。
- en: That's a reminder how we do that from previous videos。 Our query will select
    from the student all four attributes except it will increment the ID。 So again
    this will double the size of the student table copying every tuple but with a
    new student ID。 So let's go ahead and perform the insertions and now let's look
    at the student table。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从前面的视频中学到的操作方式。我们的查询将从学生表中选择所有四个属性，除了会递增ID。所以这将再次使学生表的大小翻倍，复制每一行，但会生成新的学生ID。接下来我们执行插入操作，然后查看学生表。
- en: So we'll refresh and we see that the table has doubled in size and again we
    incremented the IDs。 What we're most interested in of course is what happened
    to the apply table。 And now we should have a bunch of new applications to Stanford
    and MIT and indeed we do and if we look back we'd see that each of these IDs corresponds
    to a student whose GPA is in the range to satisfy the condition of the trigger。
    We'll leave all these tuples in。 We're going to actually use them in later triggers
    that we're going to see。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们刷新表格，看到表格的大小翻倍了，学号也已递增。当然，我们最关心的是申请表发生了什么。现在我们应该看到一些新的斯坦福和麻省理工的申请记录，的确看到了，如果回头看，我们会发现每个学号都对应一名符合触发器条件的学生，且其
    GPA 在条件范围内。我们会保留所有这些元组，并在之后的触发器中使用它们。
- en: This trigger is very similar， maybe identical to one we saw in the introductory
    video。 This trigger simulates the behavior of cascaded delete when we have a referential
    integrity constraint from the student ID in the apply table to the student ID
    in the student table。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个触发器与我们在介绍视频中看到的非常相似，甚至可能是相同的。这个触发器模拟了级联删除的行为，当我们在申请表中有学生 ID 外键约束，引用学生表中的学生
    ID 时，触发器会生效。
- en: Very specifically it is activated when we have deletions from student and again
    I'm including for each row and I'll do that in every trigger even though if I
    let's say that's not true。 Even though if I left it out the behavior would be
    the same。 So for each row that's deleted from student it has no condition so it
    always executes the action and the action says look and apply for any student
    ID whose ID is equal to the deleted one。 And again we're using this reserved keyword
    old as a reminder that's automatically bound to old row and so it will bind to
    the tuple that's being deleted that activated the trigger。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它会在我们从学生表删除记录时激活，此外我还使用了“for each row”选项，我会在每个触发器中都这样做，尽管如果我省略了这个选项，行为也是一样的。所以，对于每一条从学生表删除的记录，它没有条件，因此始终会执行动作，而动作的内容是查找任何学生
    ID 等于被删除 ID 的申请记录。再次强调，我们使用了这个保留字“old”，它自动绑定到被删除的旧行，因此它会绑定到触发该触发器的已删除元组。
- en: So we'll find any apply records that refer to the deleted student ID and we'll
    delete those apply records as well。 So first let's take a look at our student
    table because what we're going to do is delete from this table every student whose
    ID is greater than 500 so quite a number of these students are going to be deleted
    and then we're going to see that the applications of those students and there's
    quite a large number of applications greater than 500 will be deleted automatically
    by the trigger。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们会查找任何与被删除学生 ID 相关的申请记录，并将这些申请记录也删除。首先，我们来看看我们的学生表，因为我们将从该表中删除所有学号大于 500
    的学生，所以会有相当多的学生被删除，然后我们会看到这些学生的申请记录，且学号大于 500 的申请记录会通过触发器自动删除。
- en: So here's the simple deletion command to remove all students whose ID is greater
    than 500 will run the command and let's go take a look。 So we go to our student
    table and we see indeed that a lot of students have been deleted those with ID's
    greater than 500。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个简单的删除命令，用来删除所有学号大于 500 的学生，运行命令后我们来看看结果。我们进入学生表，确实看到许多学生已被删除，其中学号大于 500
    的学生被删除了。
- en: We go to our apply table and we see similarly but automatically all of the apply
    records with the student ID greater than 500 have been deleted as well。 Now let's
    create a trigger that simulates cascaded update again for referential integrity。
    So let's suppose that we're trying to implement using triggers referential integrity
    from the C-name that appears in apply to the C-name that appears in college。 And
    when we update college names we're going to propagate those updates to any apply
    records that refer to them。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入申请表，看到所有学号大于 500 的申请记录已经自动被删除了。现在让我们创建一个触发器，模拟级联更新以保证参照完整性。所以假设我们试图使用触发器来实现从申请表中的
    C-name 到学院表中的 C-name 的参照完整性。当我们更新学院名称时，触发器将自动将这些更新传播到所有引用该名称的申请记录中。
- en: So let's take a look at this trigger。 This is our first trigger that's activated
    by update command so the event the triggering event here is an update on the college
    table and very specifically we've specified the attribute C-name。 If we left out
    C-name then any update to college would activate this trigger but by putting in
    C-name it's a little more specific and more efficient。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个触发器。这是我们第一个由更新命令触发的触发器，因此触发事件是在大学表上的更新，具体来说，我们指定了属性 C-name。如果我们省略 C-name，那么大学表上的任何更新都会触发这个触发器，但通过指定
    C-name，它变得更加具体，也更高效。
- en: Again for each row would be implicit if we left it out and then let's take a
    look at what our action does。 Similar to the other the previous trigger we don't
    have a condition we update the we run the action automatically。 As a reminder
    we have now the new and old variables since it's an update so each activation
    of this trigger will be for one row new will give us the new value of that row
    old will give us the old value of that row。 So our action is going to update the
    apply table it's going to find college names that refer to the old college name
    and it's going to change them to refer to the new college name。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略每一行的内容，实际上是隐含的，那么让我们来看看我们的操作会做些什么。类似于之前的触发器，我们没有条件，我们自动运行操作。提醒一下，因为这是一个更新，所以我们现在有了新的和旧的变量，每次触发这个触发器都会针对一行，新值会给我们该行的新值，旧值会给我们该行的旧值。因此，我们的操作将会更新应用表，它会查找那些引用旧大学名称的大学名称，并将其更改为引用新的大学名称。
- en: So I would say this is actually a very intuitive trigger easy to understand
    to perform cascaded update。 So let's modify two of the college names in our database。
    We'll change Stanford to the farm and for those of you who aren't aware the farm
    is actually a common nickname for Stanford and we'll change Berkeley to Berserkle
    and I'll let you draw your own conclusions。 So let's go ahead with the update
    and let's take a look at our data now and this time we'll just go straight to
    the apply relation。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我认为这是一个非常直观的触发器，容易理解，用来执行级联更新。那么让我们修改数据库中两个大学的名称。我们将斯坦福大学更改为“农场”，而对于那些不知道的人，“农场”实际上是斯坦福大学的一个常见昵称，我们还会将伯克利大学更改为“Berserkle”，接下来我让你们自己得出结论。那么让我们继续更新并查看我们的数据，这次我们将直接查看应用表。
- en: We'll refresh and we'll see that our references to Berkeley have been changed
    automatically to Berserkle and Stanford to the farm and again I did not run an
    update command on the apply table。 I only ran the update command on the college
    table which has also changed and then the trigger was activated and propagated
    the update to the apply records。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刷新一下，就会看到对伯克利的引用已自动更改为“Berserkle”，斯坦福则变成了“农场”，而且我并没有在应用表上执行更新命令。我只在大学表上执行了更新命令，大学表也发生了变化，触发器被激活并将更新传播到应用记录。
- en: So our previous two triggers simulated referential integrity constraints。 The
    next two triggers we're going to write are going to simulate key constraints。
    Specifically we're going to say that the college name needs to be unique within
    the college table。 So we're going to write triggers that intercept both inserts
    and updates to the college table and if they try to create or update a college
    name that creates a duplicate we're going to disallow that command by raising
    an error。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的两个触发器模拟了引用完整性约束。接下来的两个触发器将模拟键约束。具体来说，我们将要求大学名称在大学表中是唯一的。因此，我们将编写触发器，拦截大学表中的插入和更新操作，如果它们尝试创建或更新一个重复的大学名称，我们将通过引发错误来禁止该命令。
- en: One other difference between our previous triggers is that these are going to
    be activated before the insert rather than after the insert。 So let's take a look。
    We have a trigger that's activated before inserts on college and they do have
    a condition。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的触发器与这个触发器的另一个区别是，它们会在插入之前被激活，而不是在插入之后。那么让我们来看一下。我们有一个在插入之前激活的触发器，针对大学表，并且它们确实有条件。
- en: What it looks for is another college that has the same college name as the one
    we're trying to insert。 So that would be a key violation if we attempt to insert
    a college name that already exists。 In the action we're using a SQLite specific
    construct， "raise ignore"。 so "raise" is an error raised command and "ignore"
    says simply ignore the update that's underway。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它寻找的是另一个大学，那个大学的名称与我们试图插入的大学名称相同。如果我们尝试插入一个已存在的大学名称，就会发生键冲突。在这个操作中，我们使用了一个SQLite特有的构造，“raise
    ignore”。所以“raise”是一个引发错误的命令，而“ignore”则表示简单地忽略正在进行的更新。
- en: So when we try to insert that college， when we try to insert a duplicate college，
    sorry。 the trigger will be activated and "raise ignore" will say disallow that
    insert。 Now we actually have a second trigger hidden underneath here。 This trigger
    handles updates to the college table。 When a college name is updated。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们尝试插入那个大学时，当我们尝试插入一个重复的大学时，对不起，触发器会被激活，“raise ignore”会阻止插入。现在我们实际上有第二个触发器在这里隐藏。这个触发器处理对college表的更新操作。当大学名称被更新时。
- en: similar to the insertion， it checks whether there's already a college with the
    proposed new college name。 and if it is， it again uses the "raise ignore" command。
    Now both of these triggers were specified before the modification。 and that's
    necessary in order to use this particular condition。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于插入操作，它会检查是否已经存在一个具有提议新大学名称的记录。如果存在，它会再次使用“raise ignore”命令。现在这两个触发器在修改之前已经被指定，这是使用此特定条件所必需的。
- en: If we had specified after the modification as our type of triggering event。
    then the condition would have to check something different。 It would have to check
    if we created duplicate college names。 But again。 we're using the before version
    here， which is quite natural。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了修改之后（after）作为触发事件类型，那么条件将必须检查不同的内容。它必须检查是否创建了重复的大学名称。但我们这里使用的是before版本，这是非常自然的。
- en: and the "raise ignore" command also works in tandem with the before。 because
    what it says is to abandon the modification that's underway。 Now I will mention
    that the raising of errors in trigger actions is quite system specific。 So what
    I'm showing you is simply the SQLite version that we would use in the case of
    a before trigger。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “raise ignore”命令也与before触发器配合使用，因为它的作用是放弃正在进行的修改。现在我要提到的是，触发器动作中错误的抛出是非常依赖系统的。所以我向你展示的只是我们在before触发器情况下会使用的SQLite版本。
- en: So now let's make some attempted modifications to college。 As a reminder。 we've
    already changed Stanford to the farm， and Berkeley to berserkly。 So in our first
    two insertion attempts， we'll try to insert Stanford into our college table。 and
    that should actually work because we changed the name Stanford to the farm。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在让我们对college表做一些尝试性的修改。提醒一下，我们已经将Stanford改成了the farm，将Berkeley改成了berserkly。在我们前两次插入尝试中，我们将尝试将Stanford插入到college表中。那应该是可以的，因为我们将Stanford的名称改成了the
    farm。
- en: We'll also try to insert another tuple for MIT， and that should not work because
    that should activate the trigger and detect that MIT would be a duplicate if it
    were inserted。 We'll run the commands。 We don't get any errors。 It's not raising
    an error。 As a reminder。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将尝试为MIT插入另一条元组，这应该不起作用，因为这会激活触发器并检测到，如果插入MIT，它会是一个重复项。我们将执行这些命令。没有出现任何错误。没有抛出错误。作为提醒。
- en: the "raise ignore" command simply stops the command that's underway。 So we'll
    take a look at our college table， and we see that the new Stanford tuple was inserted
    successfully。 but the attempt to insert an MIT tuple was rebuffed by our trigger。
    Now let's try some updates。 As a reminder， we had one trigger that intercepted
    inserts， and another that intercepted updates。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “raise ignore”命令只是停止了正在进行的命令。所以我们查看一下college表，发现新的Stanford元组已经成功插入，但尝试插入MIT元组被触发器拒绝了。现在让我们尝试一些更新。作为提醒，我们有一个触发器拦截插入操作，另一个拦截更新操作。
- en: Let's try to change berserkly back to Berkeley。 We run that， and we go to college。
    and we see that it did in fact change back， no problem because it's not creating
    a key violation。 Now let's try changing the farm back to Stanford。 We'll run that。
    Again， we won't get an error。 but when we go and look at the college table， we'll
    see that the farm is still there。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着将berserkly改回Berkeley。我们执行这个操作，进入college表，发现它确实已经改回了，没有问题，因为它没有造成键值冲突。现在让我们尝试将the
    farm改回Stanford。我们执行这个操作，再次没有出现错误，但当我们查看college表时，会看到the farm仍然存在。
- en: because we inserted the new Stanford tuple， the trigger intercepted our update。
    and didn't allow it to be changed because it would have caused a duplicate value。
    So frustrated by that， let's change the farm to Stanford。 Again。 our favorite
    misspelling of the university。 We'll run the command。 We'll take a look。 And indeed。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们插入了新的Stanford元组，触发器拦截了我们的更新操作，并且没有允许它被更改，因为这会导致重复值。所以对此感到沮丧，让我们将the farm改为Stanford，再次尝试我们最喜欢的大学拼写错误。我们执行命令，查看一下，的确如此。
- en: the farm has now been changed to Stanford because it's not creating a duplicate
    value。 Incidentally。 there were a few things happening behind the scenes while
    we were experimenting with those key triggers。 Don't forget， we defined a trigger
    that intercepts updates on the college name and propagates them to the apply table。
    So while we were changing those college names to experiment with the key triggers。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “the farm”现在已经变回斯坦福，因为它没有创建重复的值。顺便说一下，在我们试验这些关键触发器时，后台发生了一些事情。不要忘记，我们定义了一个触发器，用于拦截大学名称的更新，并将这些更改传播到`apply`表。因此，在我们更改大学名称以实验关键触发器时，
- en: we were also modifying the apply table。 Let's go see what happened to that table。
    We go here and we look at apply， and we see our Berkeley students are still Berkeley。
    While we weren't looking， they changed to berserkly and back to Berkeley。 Our
    Stanford students changed to the farm， and then they changed to Stanford。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在修改`apply`表。我们来看看这个表发生了什么变化。我们来到这里，查看`apply`表，看到我们的伯克利学生仍然是伯克利。就在我们不注意的时候，它们变成了“berserkly”，然后又变回了伯克利。我们的斯坦福学生变成了“the
    farm”，然后又变回了斯坦福。
- en: So in order not to offend my sensibilities， I'll be deleting those students。
    those apply records behind the scenes before we proceed。 Now let's take a look
    at a trigger that does a little more than enforce a constraint。 What this trigger
    is going to do is monitor applications to colleges。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不引起我的不适，在继续之前，我会在后台删除那些学生记录以及它们的申请记录。现在让我们来看一个不仅仅强制执行约束的触发器。这个触发器将监控大学的申请情况。
- en: and when the number of applications to a college exceeds ten。 it's going to
    rename that college to have the college name and then dash done。 indicating that
    we're done with the college。 Specifically。 it will be triggered by insertions
    to apply， since that's what can increase the number of applications。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当申请某个大学的数量超过十个时，它会将该大学的名称更改为大学名后加上“done”符号，表示我们已经完成了对该大学的处理。具体来说，这个操作是通过对`apply`表的插入触发的，因为插入操作会增加申请数量。
- en: And when there's an insertion， it's going to count the number of apply records
    that have applied to that college。 Now this is an after trigger， so it will include
    the one we've inserted。 and new is going to again refer to the inserted table。
    So we'll count the number of applied records to that particular college and see
    if it exceeds ten。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入操作发生时，它会计算该大学已提交申请的记录数。因为这是一个`after`触发器，所以它会包括我们插入的记录。`new`将再次指向插入的表。所以我们将计算特定大学的申请记录数量，并查看是否超过十个。
- en: If it does， it's going to update the college corresponding to the one that's
    being applied to。 and we'll do that again by looking at the new college name。
    and it's going to take that college record and it's going to set its name to be
    the current name。 and this is a concatenation operator with the string done。 Once
    we run it。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足条件，系统将更新申请的大学对应的记录。我们再次通过查看新的大学名称来做到这一点，它将会把该大学的记录更新为当前的名称，并且这是一个与字符串“done”连接的操作。一旦执行，它就会生效。
- en: you will see exactly how it works。 Another thing we'll be demonstrating in this
    example is trigger chaining。 where the activation of one trigger executes an action
    that activates another trigger。 And let me remind you of the first trigger we
    created。 where when we inserted students with a certain GPA。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会看到它是如何工作的。我们在这个示例中还会演示触发器链的应用，其中一个触发器的激活会执行一个操作，从而激活另一个触发器。让我提醒你一下我们创建的第一个触发器，它会在我们插入具有特定GPA的学生时触发。
- en: we automatically inserted apply records for those students to Stanford and MIT。
    So what I'm going to actually do， rather than insert apply records directly to
    experiment with this trigger。 I'm going to insert student records。 Those student
    records， if they have the right GPA。 will activate this trigger， which will automatically
    insert into apply。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为这些学生自动插入了斯坦福和MIT的申请记录。所以我实际上做的，不是直接插入申请记录来测试这个触发器，而是插入学生记录。如果这些学生记录符合条件的GPA，将会激活这个触发器，自动插入申请记录。
- en: and then those insertions will activate our apply trigger。 which will check
    to see if the college now has more than ten applicants。 As a reminder。 our trigger
    that does automatic insertions of applications will be having students apply to
    Stanford and MIT。 So we have no students who have currently applied to Stanford。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这些插入操作将激活我们的`apply`触发器，检查该大学是否有超过十个申请者。提醒一下，我们的触发器会自动插入学生的申请记录到斯坦福和MIT。所以目前还没有学生申请斯坦福。
- en: That's because I deleted those misspelling Stanford and that led us with none，
    but that's fine。 That will help us test our trigger。 Let's see how many students
    we have who have applied to MIT。 We currently have five who have applied to MIT。
    Finally。 let's see how many existing students we have with the GPA that's in range
    for automatic application。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我删除了那些拼写错误的斯坦福记录，导致没有剩下任何数据，但这没关系。这样可以帮助我们测试触发器。让我们看看有多少学生申请了MIT。我们目前有五个学生申请了MIT。最后，让我们看看有多少现有学生的GPA在范围内，符合自动申请的条件。
- en: And the reason I'm checking that is because I'm going to insert copies of those
    students that will activate my trigger and show the trigger chaining。 So I currently
    have six students with GPA's in range。 So if I copy those six students as new
    insertions， then we'll be adding six applications to MIT。 That will bring us to
    a total of eleven and six applications to Stanford。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以检查这一点，是因为我要插入这些学生的副本，这些副本将激活我的触发器并展示触发器链式操作。所以我目前有六个GPA在范围内的学生。如果我将这六个学生复制为新的插入记录，那么我们将会向MIT添加六个申请。这会使得MIT的总申请数达到十一，而斯坦福会有六个新的申请。
- en: bringing us to a total of six。 So if all goes well with the trigger chaining
    and everything else。 when we， after we insert those six new students， we should
    get new apply records that will cause MIT to be done because it's exceeded the
    threshold of ten。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的总数达到了六个。所以，如果触发器链式操作和其他一切顺利，当我们插入这六个新学生后，我们应该会得到新的申请记录，这会导致MIT状态变为已完成，因为申请数已超过十个阈值。
- en: but Stanford not to be done。 So let's see if that all works out as we expect。
    So my insertion command is going to completely replicate the student table。 It's
    going to copy one additional copy of every student。 And as a reminder that will
    insert six new students whose GPA is in range for automatic application。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但斯坦福还没有标记为已完成。所以让我们看看这一切是否按照预期进行。我的插入命令将完全复制学生表。它将复制每个学生的一个额外副本。提醒一下，这将插入六个新的学生，这些学生的GPA在范围内，可以自动申请。
- en: So let's go ahead and run the insert command and let's go straight to our colleges
    and see what happens。 Indeed， MIT is now labeled as done， but Stanford hasn't
    changed。 And let's look at our apply table to understand what happens。 So all
    of the tuples actually starting here were inserted in this round of trigger activation。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行插入命令，然后直接去我们的学校数据表看看会发生什么。确实，MIT现在被标记为已完成，但斯坦福没有变化。让我们看一下我们的申请表，看看发生了什么。实际上，从这里开始的所有数据项都是在这一轮触发器激活过程中插入的。
- en: So we added six students， six of them had GPA's in range。 That gave us 12 applications。
    one each to Stanford and MIT。 These other applications were left over from before。
    Then the fact that MIT went over ten applications meant MIT was relabeled as done。
    and there was a bit more trigger training that happened。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们添加了六个学生，其中六个GPA在范围内。这为我们带来了12个申请，一个是MIT的，一个是斯坦福的。其他申请是之前留下来的。然后，MIT的申请数超过十个，这意味着MIT被标记为已完成，并且发生了一些额外的触发器链式操作。
- en: Don't forget our update propagation trigger， which is still there。 That one
    took MIT done when it was modified and sent it back to modify the values of MIT
    in the apply table。 This might be a good example for you to download and play
    with yourself or rerun the video just to entirely understand what's going on。
    Now let's see if we can cope Stanford to be done as well。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们的更新传播触发器，它仍然存在。该触发器在MIT状态被修改时，将它标记为已完成，并回过头来修改申请表中MIT的值。这可能是一个很好的例子，供你自己下载并进行操作，或者重新观看视频，完全理解发生了什么。现在让我们看看是否也能将斯坦福标记为已完成。
- en: So how many students do we have to apply to Stanford？
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们有多少学生申请了斯坦福呢？
- en: Those are the six applications that occurred as a result of the most recent
    trigger firings。 And how many students do we have with the GPA in range？ Well，
    we have 12 of them。 We have the six that we had originally， and then we copied
    each one of those over in our previous example。 So now if we once again copy our
    student table， insert into student and entire copy。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是由于最近的触发器触发导致的六个申请。然后，我们有多少学生的GPA在范围内呢？我们有12个学生。其中六个是最初的学生，另外我们在之前的示例中复制了每个学生。因此，现在如果我们再次复制学生表，并插入到学生表中，整个复制会被插入。
- en: then we'll be inserting 12 students whose GPA is in range。 Those 12 students
    will automatically apply to Stanford in Berkeley。 That should put Stanford over
    the threshold of 10 and change its name to Stanford dash done。 Let's go ahead
    and execute the command。 And then let's take a look at the college table and see
    where things stand。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会插入12个GPA在有效范围内的学生。这12个学生会自动申请斯坦福和伯克利大学。这应该会使斯坦福的申请数超过10个，并将其名称更改为“Stanford-done”。让我们执行这个命令，然后查看大学表，看看当前的状态。
- en: Indeed， now Stanford is done。 Let's also take a look at the apply table because
    there's some quite interesting things going on here。 So we see all of our tuples
    with MIT done in Stanford done。 And let's just remember what happened。 We insert
    tuples into student。 Those tuples are causing automatic insertions to Stanford
    and MIT。 However， when Stanford or MIT went over threshold over 10 applications。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，现在斯坦福已经完成了。我们还可以看看申请表，因为这里发生了一些相当有趣的事情。所以我们看到所有的元组，斯坦福完成，麻省理工也完成。让我们回忆一下发生了什么。我们将元组插入到学生表中，这些元组导致了斯坦福和麻省理工的自动插入。然而，当斯坦福或麻省理工的申请数超过10个时。
- en: then the name was modified in the college table to the MIT done or Stanford
    done。 And that modification in the college table activated our update propagation
    trigger。 which then had the change in the college table propagate to the change
    in the apply table。 But then at some point along the way we see that we stop having
    MIT done and Stanford done。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，大学表中的名称被修改为“MIT done”或“Stanford done”。这个修改激活了我们的更新传播触发器，这个触发器将大学表中的变更传播到申请表中的变化。但在这个过程中，我们看到最终麻省理工和斯坦福的状态会停止显示“MIT
    done”和“Stanford done”。
- en: and we revert back to MIT and Stanford。 Well， why is that？
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们回到麻省理工和斯坦福。那么，为什么会这样呢？
- en: That's because when we insert the MIT Stanford's automatically and we go back
    and count how many。 there are for MIT and Stanford after we've changed it to dash
    done， we're back to zero。 If we kept going and then we hit the threshold again
    of 10。 then we would see that Stanford done and MIT done change as well。 Sorry。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以如此，是因为当我们插入麻省理工和斯坦福的记录时，我们回去统计麻省理工和斯坦福的数量，在将它们改为“dash done”后，我们回到了零。如果我们继续进行，然后再次达到10个申请的阈值，我们就会看到斯坦福完成和麻省理工完成也发生变化。抱歉。
- en: that Stanford and MIT changed back to Stanford done and MIT done。 So this is
    very complicated。 Again， what I'm really trying to demonstrate here is， well，
    of course。 just the basic behavior of triggers， but also the complexity when triggers
    trigger other triggers that further trigger other triggers and back。 And we'll
    be seeing more of that in the second demonstration video。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 斯坦福和麻省理工会回到“Stanford done”和“MIT done”状态。所以这非常复杂。再次强调，我在这里真正想要展示的是，当然，触发器的基本行为，但也想展示触发器相互触发，进而触发其他触发器并反向触发的复杂性。我们将在第二个演示视频中看到更多这种情况。
- en: but I did want to illustrate it here。 And there's one more point that I want
    to make。 which is that as I mentioned， in SQLite， triggers。 row level triggers
    are activated immediately after each row level change。 That is different from
    the SQL standard。 In the SQL standard。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但我确实想在这里说明这一点。还有一个我要强调的点。正如我之前提到的，在SQLite中，行级触发器会在每次行级变化后立即激活。这与SQL标准不同。在SQL标准中，
- en: even a row level trigger will be activated after the entire statement。 And that's
    what， for example。 Postgres does。 But in SQLite， we're activating immediately。
    and actually in this particular behavior， if you think about it。 it would be somewhat
    different if we were activating the triggers at the end of the entire command。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是行级触发器，在整个语句执行完毕后也会被激活。这就是例如Postgres的行为。但在SQLite中，我们是立即激活的。实际上，在这种特定的行为下，如果你仔细想一想，如果我们在整个命令执行结束时再激活触发器，结果会有些不同。
- en: even if we're doing it one row at a time。 Again， very complicated stuff。 You
    might want to pause and just think about how this works or even better experiment
    yourself。 Let's go back to a simpler trigger。 This one intercepts insertions on
    student before they occur。 and it checks if the high school size is in range。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们是逐行处理的，依然是非常复杂的事情。你可能想暂停一下，思考一下这个过程，或者更好的方法是亲自进行实验。让我们回到一个更简单的触发器。这个触发器在学生表插入之前拦截插入操作，并检查高中规模是否在有效范围内。
- en: If the high school sizes below 100 are greater than 5，000， we're going to assume
    that's an error。 and we're going to ignore it。 We're going to raise our ignore。
    Again。 that's a SQLite specific syntax that says don't perform the modification
    that's underway。 Now。 that occurs before inserts on students。 We also have a trigger，
    don't forget。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高中的人数低于100并且大于5,000，我们会认为这是一个错误。然后我们会忽略它。我们会提高我们的忽略级别。再说一次，这是SQLite特有的语法，表示不要执行正在进行的修改。现在，这发生在对学生的插入之前。我们还有一个触发器，别忘了。
- en: that it occurs after inserts on student。 And that one checks whether the student's
    GPA is in a particular range and inserts the student into the apply table。 And
    we're going to experiment a little bit with how these two triggers interact。 Now。
    I've deleted all the existing data from the student and the apply tables just
    to simplify looking at what happens with these triggers。 Now， let's try inserting
    some students。 All three of the proposed insertions have GPAs that are in range
    for automatic application。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它发生在对学生插入之后。这个触发器检查学生的GPA是否在特定范围内，并将该学生插入到申请表中。我们将稍微实验一下这两个触发器如何交互。现在，我已经删除了学生和申请表中的所有现有数据，以简化查看这些触发器的效果。现在，让我们尝试插入一些学生。所有三次插入的学生GPA都在自动申请的范围内。
- en: However， the second and third students have high school sizes that are out of
    range。 So when we run the three inserts， hopefully the triggers will disallow
    the second and third inserts for their high school being out of range。 And the
    first trigger will activate automatic applications for Nancy。 Actually， you know
    what？
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个和第三个学生的高中人数超出了范围。所以当我们执行三次插入时，希望触发器会因为高中人数超出范围而不允许插入第二个和第三个记录。而第一个触发器将会激活，并为Nancy自动提交申请。其实，你知道吗？
- en: There's a little hint down here of what happened。 We can see that the first
    insertion occurred and the second and third zero rows were affected。 So we can
    already see that it did what we expect， but let's go take a look at the data and
    make sure it did。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小提示，说明发生了什么。我们可以看到第一次插入已经发生，第二行和第三行的零数据被影响了。所以我们已经可以看到它做了我们预期的事情，但让我们再看看数据，确保它确实如此。
- en: So if we refresh the apply， we'll see that in fact there was one application
    to Stanford and one at MIT for 4。4。4。 Let's make sure that's our student。 We have
    a number of different types of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们刷新申请页面，我们会看到实际上有一份申请提交到了斯坦福，一份提交到了MIT，GPA为4.4。让我们确认这就是我们的学生。我们有很多不同类型的工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。我们有很多工具需要处理第一个指令。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。
- en: We have a number of instruments that we had to do with the first instruction。
    We have a number of instruments that we had to do with the first instruction。
    The first instruction is set to a decision of yes， and we have found that。 apply
    record by matching the student ID and the college name。 Once again。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工具需要与第一次指令一起使用。我们有一些工具需要与第一次指令一起使用。第一次指令的决策设置为“是”，我们已经通过匹配学生ID和大学名称找到相应的apply记录。再次确认。
- en: I've deleted all existing students and apply records just to keep the demonstration
    simple。 We're going to insert two students， Amy and Bob。 They both have IGPA's。
    but only Bob's high school size is big enough to grant him automatic admission
    to Berkeley。 Then we're going to have our first student， Amy， apply to Berkeley，
    and our second student， Bob。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经删除了所有现有的学生和申请记录，以保持演示的简洁。我们将插入两名学生，Amy和Bob。他们都有IGPA，但只有Bob的高中规模足够大，能够让他自动被伯克利录取。然后，我们会让第一个学生Amy申请伯克利，第二个学生Bob也申请。
- en: apply to both Berkeley and Stanford。 And we'll see that Bob is going to automatically
    be admitted to Berkeley。 So we've run the query and we take a look at apply and
    we see that we have inserted the three-group apply records。 but only the second
    one and that's Bob's application to Berkeley had a decision that was modified
    to yes。 Our last trigger is also more complex and I guess sort of realistic。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于伯克利和斯坦福大学。我们会看到，Bob将自动被伯克利录取。因此，我们运行了查询，查看apply，我们发现插入了三组apply记录，但只有第二条，也就是Bob申请伯克利的记录，决策被修改为“是”。我们的最后一个触发器也更复杂，我猜它更现实。
- en: What this trigger monitors is enrollments of colleges and at the point that
    an enrollment of a college is increased。 past the threshold of 16，000， then some
    action will be taken on its applications。 The anybody who's applied to EE at that
    college will be deleted from the application table。 and all remaining applications
    where the decision had been yes are going to have the decision set to undecided。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个触发器监控的是大学的注册人数，当某个大学的注册人数超过16,000的阈值时，将会对其申请做出相应的处理。所有申请电气工程（EE）的学生将会从申请表中删除，所有决策为“是”的剩余申请将被设置为“未决定”。
- en: One thing that's interesting about this trigger is it does monitor so the dynamic
    behavior of the database。 and look for a threshold to be passed and that's something
    that triggers can do that simply cannot be done with constraints。 Some of our
    other triggers many of them as you saw were more effectively monitoring static
    constraints。 We set the threshold at 16，000。 We see that Stanford has 15。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个触发器，有一个有趣的地方是它监控数据库的动态行为，并寻找阈值是否被突破，这是触发器可以做到的，而约束条件则无法做到。我们其他的一些触发器，正如你所看到的，它们更多地是监控静态约束条件。我们将阈值设定为16,000。我们看到斯坦福有15。
- en: 000 students and the others aren't very close to the threshold。 For this trigger
    I've also repopulated our database so we have a whole bunch of apply records。
    So let's go ahead and make an update and see what happens。 We're going to increase
    all college enrollments by 2，000。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 000名学生，其他的还离阈值有些距离。对于这个触发器，我还重新填充了我们的数据库，所以我们有很多申请记录。现在让我们进行一次更新，看看会发生什么。我们将所有大学的注册人数增加2,000。
- en: That will cause Stanford to pass the threshold of 16。000 and it should activate
    the trigger and change the apply table。 When we go look at the apply table we
    see that indeed the electrical engineering majors have disappeared and all of
    the other applications to Stanford。 that were formerly yes have now been set to
    undecided。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得斯坦福大学的学生数量超过16,000，并且应该激活触发器并更改申请表。当我们查看申请表时，我们可以看到电气工程专业的学生确实已经消失，所有以前为“是”的其他斯坦福申请现在都已被设置为“未决定”。
- en: That concludes the first half of our demonstration of triggers。 In the next
    video we'll be exploring even further the interesting interactions that triggers
    can have and how they behave。 See you then。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们演示触发器的上半部分。下一段视频我们将进一步探讨触发器可能产生的有趣交互以及它们的行为方式。到时见。
