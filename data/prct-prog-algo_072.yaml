- en: 3.1 Using Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 使用数据类型
- en: 原文：[https://introcs.cs.princeton.edu/python/31datatype](https://introcs.cs.princeton.edu/python/31datatype)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/31datatype](https://introcs.cs.princeton.edu/python/31datatype)
- en: In the first two chapters of this booksite our programs were confined to operations
    on numbers, booleans, and strings. Of course, the reason is that the Python data
    types that we've encountered so far — `int`, `float`, `bool`, and `str` — manipulate
    numbers, booleans, and strings, using familiar operations. In this chapter, we
    begin to consider other data types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书站点的前两章中，我们的程序仅��于对数字、布尔值和字符串的操作。当然，原因是到目前为止我们遇到的Python数据类型 —— `int`、`float`、`bool`和`str`
    —— 使用熟悉的操作操作数字、布尔值和字符串。在本章中，我们开始考虑其他数据类型。
- en: In this section, we focus on client programs that use existing data types, to
    give you some concrete reference points for understanding these new concepts and
    to illustrate their broad reach. We introduce constructors to create objects from
    a data type and methods to operate on their values. We consider programs that
    manipulate electrical charges, colors, images, files, and web pages — quite a
    leap from the built-in data types that we used in previous chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于使用现有数据类型的客户端程序，为您提供一些具体的参考点，以便理解这些新概念并展示它们的广泛应用。我们介绍构造函数以从数据类型创建对象，并介绍操作其值的方法。我们考虑操作电荷、颜色、图像、文件和网页的程序
    —— 这与我们在前几章中使用的内置数据类型相比是一个很大的飞跃。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Methods
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: A *method* is a function associated with a specified object (and, by extension,
    with the type of that object). That is, a method corresponds to a data-type operation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是与指定对象（以及该对象的类型）相关联的函数。也就是说，方法对应于数据类型操作。'
- en: '![Calling a method and then a function](../Images/7aacfc249615223daf66d7eadc952293.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![调用方法然后调用函数](../Images/7aacfc249615223daf66d7eadc952293.png)'
- en: 'We can *call* (or *invoke*) a method by using a variable name, followed by
    the *dot operator* (.), followed by the method name, followed by a list of arguments
    delimited by commas and enclosed in parentheses. As a simple example, Python''s
    built-in `int` type has a method named `bit_length()`, so you can determine the
    number of bits in the binary representation of an `int` value as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用变量名，后跟*点运算符*（.），后跟方法名，后跟由逗号分隔并括在括号中的参数列表来*调用*（或*调用*）方法。举个简单的例子，Python的内置`int`类型有一个名为`bit_length()`的方法，因此您可以如下确定`int`值的二进制表示中的位数：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code writes 159 to standard output, telling you that 3^(100) (a huge integer)
    has 159 bits when expressed in binary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将159写入标准输出，告诉您3^(100)（一个巨大的整数）在二进制表示中有159位。
- en: 'The syntax and behavior of method calls is nearly the same as the syntax and
    behavior of function calls. For example, a method can take any number of arguments,
    those arguments are passed by object reference, and the method returns a value
    to its caller. Similarly, like a function call, a method call is an expression.
    The main difference is syntactic: you invoke a method using a specified object
    and the dot operator. In object-oriented programming we usually prefer method-call
    syntax to function-call syntax because it emphasizes the role of the object.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用的语法和行为几乎与函数调用的语法和行为相同。例如，方法可以接受任意数量的参数，这些参数通过对象引用传递，并且方法将一个值返回给其调用者。类似于函数调用，方法调用也是一个表达式。主要区别在于语法：您使用指定对象和点运算符调用方法。在面向对象编程中，我们通常更喜欢方法调用语法而不是函数调用语法，因为它强调了对象的作用。
- en: The key difference between a function and a method is that a method is associated
    with a specified object. You can think of this specified object as an extra argument
    that gets passed to a function, in addition to the ordinary methods argument.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法之间的关键区别在于方法与指定对象相关联。您可以将这个指定对象视为传递给函数的一个额外参数，除了普通的方法参数。
- en: '![Methods vs. functions](../Images/b025932991933c6e41956c3a5dc1a6bf.png)'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![方法与函数](../Images/b025932991933c6e41956c3a5dc1a6bf.png)'
- en: '* * *'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: String Processing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串处理
- en: Your experience with using `str` demonstrates that you do not need to know how
    a data type is implemented to be able to use it. You know that `str` values are
    sequences of characters and that you can perform the operation of concatenating
    two `str` values to produce a `str` result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`str`的经验表明，您不需要知道数据类型是如何实现的才能使用它。您知道`str`值是字符序列，并且您可以执行连接两个`str`值的操作以产生一个`str`结果。
- en: Python's `str` data type includes many other operations, as documented in the
    API shown below.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`str`数据类型包括许多其他操作，如下所示的API中所述。
- en: '![Str API](../Images/e97ad52d7a8fe81f0b98872cafd00cd5.png)'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Str API](../Images/e97ad52d7a8fe81f0b98872cafd00cd5.png)'
- en: 'The operations in the `str` API can be divided into three categories:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` API中的操作可以分为三类：'
- en: '*Built-in operators* `+`, `+=`, `[]`, `[:]`, `in`, `not in`, and the comparison
    operators, which are characterized by special symbols and syntax'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内置运算符* `+`, `+=`, `[]`, `[:]`, `in`, `not in`，以及特殊符号和语法特征的比较运算符'
- en: A *built-in function* `len()` with standard function-call syntax
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有标准函数调用语法的*内置函数* `len()`
- en: '*Methods* `upper()`, `startswith()`, `find()`, and so forth, which are distinguished
    in the API with a variable name followed by the dot operator'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法* `upper()`、`startswith()`、`find()`等，在API中用变量名后跟点运算符区分开来'
- en: From this point forward, any API that we might consider will have these kinds
    of operations. Next, we consider each of them in turn.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可能考虑的任何API都将具有这些操作。接下来，我们依次考虑每一个。
- en: Built-in operators.
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置运算符。
- en: An operator (or function) that you can apply to more than one type of data is
    said to be *polymorphic*. You have already been using the `+` operator, familiar
    for numbers, for string concatenation. The API tells you that you can use the
    `[]` operator, familiar for arrays, to extract a single character from a string
    and the `[:]` operator to extract a substring from a string.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于多种数据类型的运算符（或函数）称为*多态*。您已经在使用`+`运算符，用于数字，进行字符串连接。API告诉您，您可以使用`[]`运算符，用于数组，从字符串中提取单个字符，并使用`[:]`运算符从字符串中提取子字符串。
- en: Built-in functions.
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置函数。
- en: Python also builds in a number of polymorphic functions, such as the `len()`
    function. Polymorphic functions are like polymorphic operators, but without the
    special syntax.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python还内置了许多多态函数，例如`len()`函数。多态函数类似于多态运算符，但没有特殊的语法。
- en: Methods.
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法。
- en: We include built-in operators and built-in functions for convenience (and to
    conform to Python norms), but most of our effort in creating data types goes into
    developing methods that operate on object values, such as `upper()`, `startswith()`,
    `find()`, and the other methods in the `str` API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含内置运算符和内置函数以方便使用（并符合Python规范），但我们在创建数据类型时的大部分工作都是开发操作对象值的方法，例如`upper()`，`startswith()`，`find()`和`str`
    API中的其他方法。
- en: The table below gives several examples of simple string-processing applications
    that illustrate the utility of the various operations in Python's `str` data type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下表给出了几个简单的字符串处理应用程序示例，展示了Python的`str`数据类型中各种操作的实用性。
- en: '![String processing code](../Images/bf0bf3ca5cf6826ff984306b21522f07.png)'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![字符串处理代码](../Images/bf0bf3ca5cf6826ff984306b21522f07.png)'
- en: The program [potentialgene.py](potentialgene.py.html) is a more substantial
    example of string processing. The program accepts a DNA sequence as a command-line
    argument, and determines whether it corresponds to a potential gene. The textbook
    provides details.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[potentialgene.py](potentialgene.py.html)是一个更为实质性的字符串处理示例。该程序接受DNA序列作为命令行参数，并确定它是否对应于一个潜在的基因。教科书提供了详细信息。
- en: '* * *'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A User-Defined Data Type
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义数据类型
- en: 'As a running example of a user-defined data type, we will consider a data type
    `Charge` for charged particles. In particular, we are interested in a two-dimensional
    model that uses *Coulomb''s law*, which tells us that the electric potential at
    a point due to a given charged particle is represented by *V* = *kq*/*r*, where
    *q* is the charge value, *r* is the distance from the point to the charge, and
    *k* = 8.99 × 10⁹ N m²/C² is a constant known as the electrostatic constant, or
    *Coulomb''s constant*. For consistency, we use SI (Systeme International d''Unites):
    in this formula, N designates newtons (force), m designates meters (distance),
    and C represent coulombs (electric charge). When there are multiple charged particles,
    the electric potential at any point is the sum of the potentials due to each charge.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户定义数据类型的一个运行示例，我们将考虑一个用于带电粒子的数据类型`Charge`。特别地，我们感兴趣的是一个使用*Coulomb定律*的二维模型，该定律告诉我们，由给定带电粒子引起的某点的电势由*V*
    = *kq*/*r*表示，其中*q*是电荷值，*r*是点到电荷的距离，*k* = 8.99 × 10⁹ N m²/C²是一个称为静电常数或*Coulomb常数*的常数。为了保持一致性，我们使用国际单位制（SI）：在这个公式中，N代表牛顿（力），m代表米（距离），C代表库仑（电荷）。当存在多个带电粒子时，任意点的电势是由每个电荷引起的电势之和。
- en: Application programming interface.
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序编程接口。
- en: We specify the behavior of the `Charge` data type by listing its operations
    in an API, deferring the discussion of the implementation until Section 3.2.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在API中列出其操作来指定`Charge`数据类型的行为，将实现的讨论推迟到第3.2节。
- en: '![Charge API](../Images/e557eacb2fb9b790687584395eab1e07.png)'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![电荷 API](../Images/e557eacb2fb9b790687584395eab1e07.png)'
- en: The first entry in the API, which has the same name as the data type, is known
    as a `constructor`. Each call to the `Charge` constructor creates exactly one
    new `Charge` object. The other two entries define the data-type operations. The
    first is a method `potentialAt()`, which computes and returns the potential due
    to the charge at the given point (`x`, `y`). The second is the built-in function
    `str()`, which returns a string representation of the charged particle.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: API中的第一个条目，与数据类型同名，被称为`构造函数`。每次调用`Charge`构造函数都会创建一个新的`Charge`对象。另外两个条目定义了数据类型的操作。第一个是一个名为`potentialAt()`的方法，用于计算并返回给定点（`x`，`y`）处电荷引起的电势。第二个是内置函数`str()`，用于返回带电粒子的字符串表示。
- en: File conventions.
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件约定。
- en: 'The code that defines a user-defined data type resides in a `.py` file. By
    convention, we define each data type in a distinct `.py` file, with the same name
    as the data type (but not capitalized). Thus, the `Charge` data type is found
    in a file named `charge.py`. To compose a client program that uses the `Charge`
    data type, we put the following `import` statement at the top of the client .py
    file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 定义用户定义数据类型的代码位于`.py`文件中。按照惯例，我们在不同的`.py`文件中定义每个数据类型，文件名与数据类型相同（但不大写）。因此，`Charge`数据类型在名为`charge.py`的文件中找到。为了编写一个使用`Charge`数据类型的客户端程序，我们将以下`import`语句放在客户端`.py`文件的顶部：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the format of the `import` statement that we use with user-defined
    data types differs from the format we use with functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们与用户定义数据类型一起使用的`import`语句的格式与我们与函数一起使用的格式不同。
- en: Creating objects.
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象。
- en: '![Creating a Charge object](../Images/3e46097317c4306d14265cc031dbfd9c.png)
    To create an object from a user-defined data type, you call its constructor, which
    directs Python to create a new individual object. You call a constructor just
    as if it were a function, using the name of the data type, followed by the constructor''s
    arguments enclosed in parentheses and separated by commas. For example, `Charge(x0,
    y0, q0)` creates a new `Charge` object with position (`x0`, `y0`) and charge value
    `q0` and returns a reference to the new object. ![Four variables referring to
    three Charge objects](../Images/8686e78c388e01782c6fdd9703782977.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个Charge对象](../Images/3e46097317c4306d14265cc031dbfd9c.png)要创建一个来自用户定义数据类型的对象，您调用其构造函数，该构造函数指示Python创建一个新的独立对象。您调用构造函数就像调用函数一样，使用数据类型的名称，后跟构造函数的参数，括号括起来，用逗号分隔。例如，`Charge(x0,
    y0, q0)`创建一个具有位置(`x0`, `y0`)和电荷值`q0`的新`Charge`对象，并返回对新对象的引用。![四个变量引用三个Charge对象](../Images/8686e78c388e01782c6fdd9703782977.png)'
- en: You can create any number of objects of the same data type. Recall from Section
    1.2 that each object has its own identity, type, and value. So, while any two
    objects reside at distinct places in computer memory, they may be of the same
    type and store the same value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建任意数量的相同数据类型的对象。回想一下第1.2节，每个对象都有自己的标识、类型和值。因此，虽然任何两个对象都驻留在计算机内存中的不同位置，但它们可能是相同类型并存储相同值。
- en: Calling a method.
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法。
- en: As discussed at the beginning of this section, we typically use a variable name
    to identify the object to be associated with the method we intend to call. For
    our example, the method call `c1.potentialAt(.20, .50)` returns a float that represents
    the potential at the query point (0.20, 0.50) due to the `Charge` object referenced
    by `c1`. The distance between the query point and the charge location is 0.34,
    so this potential is 8.99 × 10⁹ × 21.3 / 0.34 = 5.63 × 10^(11).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所讨论的，我们通常使用变量名来标识要与我们打算调用的方法关联的对象。对于我们的示例，方法调用`c1.potentialAt(.20, .50)`返回一个浮点数，表示由`c1`引用的`Charge`对象在查询点(0.20,
    0.50)处的电势。查询点与电荷位置之间的距离为0.34，因此该电势为8.99 × 10⁹ × 21.3 / 0.34 = 5.63 × 10^(11)。
- en: String representation.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串表示。
- en: In any data-type implementation, it is typically worthwhile to include an operation
    that converts an object's value to a string. Python has a built-in function `str()`
    for this purpose, which you have been using from the beginning to convert integers
    and floats to strings for output. Since our `Charge` API has a `str()` implementation,
    any client can call `str()` to get a string representation of a `Charge` object.
    For our example, the call `str(c1)` returns the string `'21.3 at (0.51, 0.63)'`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何数据类型的实现中，通常值得包括一个将对象值转换为字符串的操作。Python有一个内置函数`str()`用于此目的，您从一开始就一直在使用它将整数和浮点数转换为字符串进行输出。由于我们的`Charge`
    API有一个`str()`实现，任何客户端都可以调用`str()`来获取`Charge`对象的字符串表示。对于我们的示例，调用`str(c1)`返回字符串`'21.3
    at (0.51, 0.63)'`。
- en: These mechanisms are summarized in the client [chargeclient.py](chargeclient.py.html),
    which creates two `Charge` objects and computes the total potential due to the
    two charges at a query point taken from the command line.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制在客户端[chargeclient.py](chargeclient.py.html)中总结，该客户端创建两个`Charge`对象，并计算从命令行中取出的查询点处两个电荷的总电势。
- en: Next we consider several more examples of user-defined data types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们考虑几个用户定义数据类型的更多示例。
- en: '* * *'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Color
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: Color is a sensation in the eye attributable to electromagnetic radiation. Since
    we often want to view and manipulate color images on our computers, color is a
    widely used abstraction in computer graphics.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是眼睛中由电磁辐射引起的感觉。由于我们经常希望在计算机上查看和操作彩色图像，颜色在计算机图形学中被广泛使用。
- en: To represent color values, we define a `Color` data type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示颜色值，我们定义了一个`Color`数据类型。
- en: '![Color API](../Images/e2ecc2a0deb137b7b090209c3aeb37db.png)'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Color API](../Images/e2ecc2a0deb137b7b090209c3aeb37db.png)'
- en: '`Color` uses the RGB color model, in which a color is defined by three integers,
    each between 0 and 255, that represent the intensity of the red, green, and blue
    (respectively) components of the color. Other color values are obtained by mixing
    the red, green, and blue components. `Color` has a constructor that takes three
    integer arguments, so that you can compose the code'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`使用RGB颜色模型，其中颜色由三个整数定义，每个整数介于0和255之间，分别表示颜色的红色、绿色和蓝色（分别）分量的强度。通过混合红色、绿色和蓝色分量获得其他颜色值。`Color`有一个构造函数，它接受三个整数参数，因此您可以组成代码'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: to create objects whose values represent pure red and pure blue, respectively.
    We have been using colors in `stddraw` since Section 1.5, but have been limited
    to a set of predefined colors, such as `stddraw.BLACK`, `stddraw.RED`, and `stddraw.PINK`.
    Now you have millions of colors available for your use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代表纯红色和纯蓝色的对象。自第1.5节以来，我们一直在`stddraw`中使用颜色，但一直受限于一组预定义颜色，如`stddraw.BLACK`、`stddraw.RED`和`stddraw.PINK`。现在您可以使用数百万种颜色。
- en: The program [alberssquares.py](alberssquares.py.html) is a `Color` and `stddraw`
    client that allows you to experiment with colors. The program accepts two colors
    from the command line, and displays the colors in the format developed in the
    1960s by the color theorist Josef Albers, who revolutionized the way that people
    think about color.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[alberssquares.py](alberssquares.py.html)是一个`Color`和`stddraw`客户端，允许您对颜色进行实验。该程序从命令行接受两种颜色，并以20世纪60年代由色彩理论家约瑟夫·阿尔伯斯开发的格式显示颜色，彻底改变了人们对颜色的看法。
- en: '| `% python alberssquares.py 9 90 166 100 100 100` | ![](../Images/cf0c1837db33b7131744422f1bedd67e.png)
    |'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python alberssquares.py 9 90 166 100 100 100` | ![](../Images/cf0c1837db33b7131744422f1bedd67e.png)
    |'
- en: '| `% python alberssquares.py 0 174 239 147 149 252` | ![](../Images/85d2e20f9612defdfc438dd5cc5e1e9f.png)
    |'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python alberssquares.py 0 174 239 147 149 252` | ![](../Images/85d2e20f9612defdfc438dd5cc5e1e9f.png)
    |'
- en: Luminance.
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 亮度。
- en: 'The quality of the images on modern displays such as LCD monitors, LED TVs,
    and cellphone screens depends on an understanding of a color property known as
    *monochrome luminance*, or effective brightness. A standard formula for luminance
    is derived from the eye''s sensitivity to red, green, and blue. It is a linear
    combination of the three intensities: if a color''s red, green, and blue values
    are *r*, *g*, and *b*, respectively, then its luminance is defined by this formula:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现代显示器（如LCD��示器、LED电视和手机屏幕）上图像的质量取决于一种称为*单色亮度*或有效亮度的颜色属性的理解。亮度的标准公式源自眼睛对红色、绿色和蓝色的敏感性。它是三种强度的线性组合：如果颜色的红色、绿色和蓝色值分别为*r*、*g*和*b*，则其亮度由以下公式定义：
- en: '| *Y* = 0.299*r* + 0.587*g* + 0.114*b* |'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| *Y* = 0.299*r* + 0.587*g* + 0.114*b* |'
- en: Grayscale.
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灰度。
- en: The RGB color model has the property that when all three color intensities are
    the same, the resulting color is on a grayscale that ranges from black (all 0s)
    to white (all 255s). To print a color photograph in a black-and-white newspaper
    (or a book), we need a function to convert from color to grayscale. A simple way
    to convert a color to grayscale is to replace the color with a new one whose red,
    green, and blue values equal its monochrome luminance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: RGB颜色模型具有这样的特性，当三种颜色强度相同时，所得颜色位于从黑色（全0）到白色（全255）的灰度范围内。要在黑白报纸（或书籍）上打印彩色照片，我们需要一个将彩色转换为灰度的函数。将彩色转换为灰度的简单方法是用其单色亮度等于其红色、绿色和蓝色值的新颜色替换该颜色。
- en: Color compatibility.
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色兼容性。
- en: The luminance value is also crucial in determining whether two colors are compatible,
    in the sense that printing text in one of the colors on a background in the other
    color will be readable. A widely used rule of thumb is that the difference between
    the luminance of the foreground and background colors should be at least 128\.
    For example, black text on a white background has a luminance difference of 255,
    but black text on a (book) blue background has a luminance difference of only
    74.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 亮度值在确定两种颜色是否兼容方面也至关重要，即在另一种颜色的背景上打印文本是否可读。一个广泛使用的经验法则是前景和背景颜色之间的亮度差应至少为128。例如，黑色文本在白色背景上的亮度差为255，但黑色文本在（书籍）蓝色背景上的亮度差仅为74。
- en: Program [luminance.py](luminance.py.html) is a module that we can use to convert
    a color to grayscale and to test whether two colors are compatible, for example,
    when we use colors in `stddraw` applications. The functions in [luminance.py](luminance.py.html)
    illustrate the utility of using data types to organize information. Using the
    `Color` data type and passing objects as arguments makes these implementations
    substantially simpler than the alternative of having to pass around the three
    intensity values. Returning multiple values from a function also would be awkward
    and more error prone without the `Color` data type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[luminance.py](luminance.py.html)是一个模块，我们可以用它将颜色转换为灰度，并测试两种颜色是否兼容，例如，当我们在`stddraw`应用程序中使用颜色时。[luminance.py](luminance.py.html)中的函数说明了使用数据类型组织信息的实用性。使用`Color`数据类型并将对象作为参数传递使得这些实现比传递三个强度值更简单。如果没有`Color`数据类型，从函数返回多个值也会变得笨拙且更容易出错。
- en: '* * *'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Digital Image Processing
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字图像处理
- en: 'We have been using `stddraw` to plot geometric objects (points, lines, circles,
    squares) in a window on the computer screen. The basic abstraction for computer
    displays is the same one that is used for digital photographs and is very simple:
    A *digital image* is a rectangular grid of *pixels* (picture elements), where
    the color of each pixel is individually defined. Digital images are sometimes
    referred to as *raster* or *bitmapped* images.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用`stddraw`在计算机屏幕上的窗口中绘制几何对象（点、线、圆、正方形）。计算机显示的基本抽象与数字照片相同，非常简单：*数字图像*是*像素*（图片元素）的矩形网格，每个像素的颜色都是单独定义的。数字图像有时被称为*光栅*或*位图*图像。
- en: 'Our `Picture` data type, defined in the module `picture.py`, implements the
    digital image abstraction. The set of values is nothing more than a two-dimensional
    array of `Color` values, and the operations are described by this API:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`picture.py`模块中定义的`Picture`数据类型实现了数字图像抽象。值集合只不过是`Color`值的二维数组，操作由此API描述：
- en: '![Picture API](../Images/2cea3282686c358414b4fe9a2e008b96.png)'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Picture API](../Images/2cea3282686c358414b4fe9a2e008b96.png)'
- en: '![Anatomy of a digital image](../Images/c6459a69b5c8456a0ddb93e94ac13dfa.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![数字图像的解剖结构](../Images/c6459a69b5c8456a0ddb93e94ac13dfa.png)'
- en: By convention, (0, 0) is the upper leftmost pixel, so the image is laid out
    as in the customary order for arrays (by contrast, the convention for `stddraw`
    is to have the point (0,0) at the lower-left corner, so that drawings are oriented
    as in the customary manner for Cartesian coordinates).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，(0, 0)是最左上角的像素，因此图像的布局与数组的常规顺序相同（相比之下，`stddraw`的约定是将点(0,0)放在左下角，使得图形的方向与笛卡尔坐标的常规方式相同）。
- en: Using the `Picture` constructor you can create a `Picture` object by reading
    an image from a `.png` or `.jpg` file. Using the `save()` method, you can save
    the images that you create in either `.png` or `.jpg` format; subsequently can
    view the images that you create in the same way that you view photographs or other
    images. In addition, the `stddraw` module supports a `picture()` function that
    allows you to draw a given `Picture` object in the standard drawing window along
    with lines, rectangles, circles, and so forth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Picture`构造函数，您可以通过从`.png`或`.jpg`文件中读取图像来创建`Picture`对象。使用`save()`方法，您可以将创建的图像保存为`.png`或`.jpg`格式；随后可以以查看照片或其他图像的方式查看您创建的图像。此外，`stddraw`模块支持一个`picture()`函数，允许您在标准绘图窗口中绘制给定的`Picture`对象以及线条、矩形、圆等。
- en: '![Stddraw Picture API](../Images/87f47398a27ec28e524d594cc25681cf.png)'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw Picture API](../Images/87f47398a27ec28e524d594cc25681cf.png)'
- en: Grayscale.
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灰度。
- en: The program [grayscale.py](grayscale.py.html) is a filter that takes a file
    name from the command line and produces a grayscale version of that image. It
    creates a new `Picture` object initialized with the color image, then sets the
    color of each pixel to a new `Color` having a grayscale value computed by applying
    the `toGray()` function in [luminance.py](luminance.py.html) to the color of the
    corresponding pixel in the source. Try running it on the files [mandrill.jpg](mandrill.jpg),
    [mandrill.png](mandrill.png), [darwin.jpg](darwin.jpg), and [darwin.png](darwin.png).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[grayscale.py](grayscale.py.html)是一个过滤器，它从命令行接受一个文件名，并生成该图像的灰度版本。它创建一个新的`Picture`对象，初始化为彩色图像，然后将每个像素的颜色设置为通过在[luminance.py](luminance.py.html)中应用`toGray()`函数计算的灰度值的新`Color`。尝试在文件[mandrill.jpg](mandrill.jpg)、[mandrill.png](mandrill.png)、[darwin.jpg](darwin.jpg)和[darwin.png](darwin.png)上运行它。
- en: '| `% python grayscale.py mandrill.jpg` | ![](../Images/fa1c2f84d8682bbfa4bf27ab83d2438e.png)
    |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python grayscale.py mandrill.jpg` | ![](../Images/fa1c2f84d8682bbfa4bf27ab83d2438e.png)
    |'
- en: '| `% python grayscale.py darwin.jpg` | ![](../Images/7e0d9b3bb3b1ee4c06ad57087d04e8da.png)
    |'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python grayscale.py darwin.jpg` | ![](../Images/7e0d9b3bb3b1ee4c06ad57087d04e8da.png)
    |'
- en: Scaling.
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放。
- en: One of the most common image-processing tasks is to make an image smaller or
    larger.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的图像处理任务之一是使图像变小或变大。
- en: '| ![Downscaling](../Images/5d70a460963583e89e2be2729d1d7778.png) | ![Upscaling](../Images/aeed894ccf7f9a76ef347d94e6a30167.png)
    |'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![缩小](../Images/5d70a460963583e89e2be2729d1d7778.png) | ![放大](../Images/aeed894ccf7f9a76ef347d94e6a30167.png)
    |'
- en: The program [scale.py](scale.py.html) takes a filename and the width and height
    of the target image as command-line arguments, and rescales the image to the specified
    size. Try running it on [mandrill.jpg](mandrill.jpg), [mandrill.png](mandrill.png),
    [darwin.jpg](darwin.jpg), and [darwin.png](darwin.png).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[scale.py](scale.py.html)接受文件名和目标图像的宽度和高度作��命令行参数，并将图像重新缩放到指定大小。尝试在[mandrill.jpg](mandrill.jpg)、[mandrill.png](mandrill.png)、[darwin.jpg](darwin.jpg)和[darwin.png](darwin.png)上运行它。
- en: '| `% python scale.py mandrill.jpg 200 200` | ![](../Images/d372fceb00fc79159dd6307ab8b53382.png)
    |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python scale.py mandrill.jpg 200 200` | ![](../Images/d372fceb00fc79159dd6307ab8b53382.png)
    |'
- en: '| `% python scale.py mandrill.jpg 200 100` | ![](../Images/f5f93a538c53add9be5923810618e114.png)
    |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python scale.py mandrill.jpg 200 100` | ![](../Images/f5f93a538c53add9be5923810618e114.png)
    |'
- en: '| `% python scale.py mandrill.jpg 100 200` | ![](../Images/f1fcb190b07fa54ab255528cfe004b57.png)
    |'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python scale.py mandrill.jpg 100 200` | ![](../Images/f1fcb190b07fa54ab255528cfe004b57.png)
    |'
- en: Fade effect.
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渐变效果。
- en: 'The program [fade.py](fade.py.html) is a `Picture`, `Color`, and `stddraw`
    client that uses a linear interpolation strategy to implement a *fade effect*.
    It computes *n* - 1 intermediate images, with each pixel in the *t*th image being
    a weighted average of the corresponding pixels in the source and target. The function
    `blend()` implements the interpolation: the source color is weighted by a factor
    of 1-*t*/*n* and the target color by a factor of *t*/*n* (when *t* is 0, we have
    the source color; when *t* is *n*, we have the target color). Note that [fade.py](fade.py.html)
    assumes that the images have the same width and height; if you have images for
    which this is not the case, you can use [scale.py](scale.py.html) to create a
    scaled version of one or both of them for [fade.py](fade.py.html). Try running
    it on various permutations of [mandrill.jpg](mandrill.jpg), [mandrill.png](mandrill.png),
    [darwin.jpg](darwin.jpg), and [darwin.png](darwin.png).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[fade.py](fade.py.html)是一个`Picture`、`Color`和`stddraw`客户端，使用线性插值策略实现*淡入淡出效果*。它计算*n*
    - 1个中间图像，其中第*t*个图像中的每个像素都是源图像和目标图像中对应像素的加权平均值。函数`blend()`实现了插值：源颜色按1-*t*/*n*的因子加权，目标颜色按*t*/*n*的因子加权（当*t*为0时，我们有源颜色；当*t*为*n*时，我们有目标颜色）。请注意，[fade.py](fade.py.html)假定图像具有相同的宽度和高度；如果您有宽度和高度不同的图像，可以使用[scale.py](scale.py.html)为[fade.py](fade.py.html)创建一个或两个图像的缩放版本。尝试在[mandrill.jpg](mandrill.jpg)、[mandrill.png](mandrill.png)、[darwin.jpg](darwin.jpg)和[darwin.png](darwin.png)的各种排列上运行它。
- en: '| `% python fade.py mandrill.png darwin.png 5` | ![](../Images/f5ac8a4733d68c5752acd8983bd693d3.png)
    | ![](../Images/a3c97c92b09cd57ac39541fb408e04ef.png) | ![](../Images/c20c112ad69342a58c8d638f382a3ad6.png)
    |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python fade.py mandrill.png darwin.png 5` | ![](../Images/f5ac8a4733d68c5752acd8983bd693d3.png)
    | ![](../Images/a3c97c92b09cd57ac39541fb408e04ef.png) | ![](../Images/c20c112ad69342a58c8d638f382a3ad6.png)
    |'
- en: '|  | ![](../Images/8f4a59b25d855d3d775b20cb379f63e0.png) | ![](../Images/0edea51a0da3dffc31c3e379f29a37f8.png)
    | ![](../Images/bbf84e769ed0137233b96e3b4fb6c952.png) |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  | ![](../Images/8f4a59b25d855d3d775b20cb379f63e0.png) | ![](../Images/0edea51a0da3dffc31c3e379f29a37f8.png)
    | ![](../Images/bbf84e769ed0137233b96e3b4fb6c952.png) |'
- en: Potential value visualization.
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 潜在价值可视化。
- en: 'Image processing is also helpful in scientific visualization. Program [potential.py](potential.py.html)
    visualizes the potential values created by a set of charges. It relies on the
    data file [charges.txt](charges.txt). The calculation at the heart of the approach
    is very simple: for each pixel, we compute corresponding (*x*, *y*) values in
    the unit square, then call `potentialAt()` for each charge to find the potential
    at that point due to all of the charges, summing the values returned.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理在科学可视化中也很有帮助。程序[potential.py](potential.py.html)可视化了一组电荷产生的电位值。它依赖于数据文件[charges.txt](charges.txt)。方法的核心计算非常简单：对于每个像素，我们在单位正方形中计算相应的(*x*,
    *y*)值，然后为每个电荷调用`potentialAt()`来找到由于所有电荷而在该点产生的电位，将返回的值相加。
- en: '| `% python potential.py < charges.txt` | ![](../Images/ec1249a164425ca8e6141fdb80f88701.png)
    |'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python potential.py < charges.txt` | ![](../Images/ec1249a164425ca8e6141fdb80f88701.png)
    |'
- en: '* * *'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Input and Output Revisited
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和输出再次访问
- en: '![A bird''s eye view of a Python program (revisited again)](../Images/a7ec5c59ea32a3f16ce07045e601bd9d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![一个Python程序的鸟瞰图（再次访问）](../Images/a7ec5c59ea32a3f16ce07045e601bd9d.png)'
- en: In Section 1.5, you learned how to read and write numbers and text using our
    `stdio` module. When using `stdio`, we are dependent upon the operating system's
    piping and redirection mechanism for access to files, and any one program can
    work with just one input file and one output file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1.5节中，您学会了如何使用我们的`stdio`模块读取和写入数字和文本。在使用`stdio`时，我们依赖于操作系统的管道和重定向机制来访问文件，任何一个程序只能使用一个输入文件和一个输出文件。
- en: In this section we define the data types `InStream` and `OutStream` for input
    streams and output streams, respectively. Rather than being restricted to just
    one input stream and one output stream, we can readily create multiple objects
    of each data type, connecting the streams to various sources and destinations.
    We also get the flexibility to set variables to reference such objects, pass them
    as arguments to or return values from functions or methods, and create arrays
    of them, manipulating them just as we manipulate objects of any data type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们定义了数据类型`InStream`和`OutStream`，分别用于输入流和输出流。与仅限于一个输入流和一个输出流不同，我们可以轻松地创建多个每种数据类型的对象，将流连接到各种来源和目的地。我们还可以灵活地设置变量来引用这些对象，将它们作为参数传递给函数或方法，或从函数或方法返回值，并创建它们的数组，就像我们操作任何数据类型的对象一样。
- en: Input stream data type.
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入流数据类型。
- en: 'Our data type `InStream`, defined in the module `instream.py`, is a more general
    version of the reading aspects of `stdio` that supports reading numbers and text
    from files and websites as well as the standard input stream. This is its API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据类型`InStream`，定义在模块`instream.py`中，是`stdio`读取方面的更通用版本，支持从文件和网站以及标准输入流读取数字和文本。这是它的API：
- en: '![InStream API](../Images/69a3fa567701fbb0330ab64e77352d2a.png)'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![InStream API](../Images/69a3fa567701fbb0330ab64e77352d2a.png)'
- en: When you call the `InStream` constructor with a string argument, the constructor
    first tries to find a file on your local computer with that name. If it cannot
    do so, it assumes the argument is a website name and tries to connect to that
    website. (If no such website exists, it raises an `IOError` at run time.) In either
    case, the specified file or website becomes the source of the input for the `InStream`
    object thus created, and the `read*()` methods will read input from that stream.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用带有字符串参数的`InStream`构造函数时，构造函数首先尝试在本地计算机上找到具有该名称的文件。如果无法找到文件，则假定参数是网站名称，并尝试连接到该网站。（如果不存在这样的网站，它会在运行时引发`IOError`。）在任一情况下，指定的文件或网站将成为创建的`InStream`对象的输入源，并且`read*()`方法将从该流读取输入。
- en: Output stream data type.
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出流数据类型。
- en: Similarly, our data type `OutStream`, defined in the module `outstream.py`,
    is a more general version of the writing aspect of `stdio` that supports writing
    strings to a variety of output streams, including standard output and files. Again,
    the API specifies the same methods as its `stdio` counterpart.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的数据类型`OutStream`，定义在模块`outstream.py`中，是`stdio`写入方面的更通用版本，支持将字符串写入各种输出流，包括标准输出和文件。同样，API指定了与其`stdio`对应物相同的方法。
- en: '![OutStream API](../Images/27a8daf7e353aebc3df3a4cef689cd32.png)'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![OutStream API](../Images/27a8daf7e353aebc3df3a4cef689cd32.png)'
- en: You specify the file that you want to use for output by using the one-argument
    constructor with the file's name as argument. `OutStream` interprets this string
    as the name of a new file on your local computer, and sends its output there.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用文件名作为参数的单参数构造函数来指定要用于输出的文件。`OutStream`将此字符串解释为本地计算机上新文件的名称，并将其输出发送到那里。
- en: File concatenation and filtering.
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件连接和过滤。
- en: 'The program [cat.py](cat.py.html) is a sample client of `InStream` and `OutStream`
    that uses multiple input streams to concatenate several input files into a single
    output file. For example, this command concatenates files [in1.txt](in1.txt) and
    [in2.txt](in2.txt) to create the file `out.txt`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[cat.py](cat.py.html)是`InStream`和`OutStream`的一个示例客户端，使用多个输入流将多个输入文件连接成单个输出文件。例如，此命令将文件[in1.txt](in1.txt)和[in2.txt](in2.txt)连接起来创建文件`out.txt`：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Screen scraping.
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕抓取。
- en: The program [stockquote.py](stockquote.py.html) is a client of the `str` and
    `InStream` data types. It queries a web page, extracts some information, and reports
    the results — a process known as *screen scraping*. Specifically, the program
    accepts as a command-line argument the symbol of a New York Stock Exchange stock
    and writes its current trading price to standard output. For example, if the command-line
    argument is `goog` (the NYSE symbol for Google), the program reads the Web page
    `http://finance.yahoo.com/q?s=goog` using the `InStream` constructor, identifies
    the stock price of Google using `str` methods, and writes the stock price to standard
    output. The program depends on the format of the Yahoo web page; if Yahoo changes
    their web page format, we would need to change our program. Nevertheless, this
    is likely more convenient than maintaining the data ourselves.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[stockquote.py](stockquote.py.html)是`str`和`InStream`数据类型的客户端。它查询一个网页，提取一些信息，并报告结果
    —— 这个过程称为*屏幕抓取*。具体来说，程序接受一个纽约证券交易所股票符号作为命令行参数，并将其当前交易价格写入标准输出。例如，如果命令行参数是`goog`（谷歌的纽约证券交易所符号），程序使用`InStream`构造函数读取网页`http://finance.yahoo.com/q?s=goog`，使用`str`方法识别谷歌的股价，并将股价写入标准输出。该程序依赖于Yahoo网页的格式；如果Yahoo更改其网页格式，我们将需要更改我们的程序。尽管如此，这可能比自己维护数据更方便。
- en: Extracting data.
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取数据。
- en: The program [split.py](split.py.html) uses one `InStream` object and multiple
    `OutStream` objects to split a CSV (comma-separated value) file into separate
    files, one for each comma-delimited field. For example, the command
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[split.py](split.py.html)使用一个`InStream`对象和多个`OutStream`对象将CSV（逗号分隔值）文件拆分为单独的文件，每个文件对应一个逗号分隔的字段。例如，命令
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: splits the file [djia.csv](djia.csv) into files `djia1.txt`, `djia2.txt`, and
    `djia3.txt`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件[djia.csv](djia.csv)拆分为文件`djia1.txt`，`djia2.txt`和`djia3.txt`。
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Memory Management
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: In Python, we create objects by calling a constructor. Each time we create an
    object, Python reserves computer memory for that object. But when and how do we
    destroy objects so that the memory in which they reside can be freed for reuse?
    We will briefly address this question.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们通过调用构造函数来创建对象。每次创建对象时，Python都会为该对象保留计算机内存。但是何时以及如何销毁对象，以便其中的内存可以被释放以供重用？我们将简要讨论这个问题。
- en: Orphaned objects.
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 孤立对象。
- en: '![Orphaning an object](../Images/4df71456ac19499e1efcf957bdc64671.png) The
    ability to bind a variable to a different object creates the possibility that
    a program may have created an object that it can no longer reference. For example,
    consider the three assignment statements in the figure at right. After the third
    assignment statement, not only do `c1` and `c2` refer to the same `Charge` object
    (the one at (.51, .63) with charge value 21.3), but there is also no longer a
    reference to the `Charge` object that was created and used to initialize `c2`.
    Such an object is said to be an *orphan*. Objects can also become orphans when
    variables go out of scope.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![孤立对象](../Images/4df71456ac19499e1efcf957bdc64671.png) 将变量绑定到不同对象的能力会导致程序可能创建一个无法再引用的对象。例如，考虑右侧图中的三个赋值语句。在第三个赋值语句之后，`c1`和`c2`不仅指向相同的`Charge`对象（位于(.51,
    .63)，电荷值为21.3），而且不再有对初始化`c2`时创建和使用的`Charge`对象的引用。这样的对象被称为*孤立对象*。当变量超出范围时，对象也可能成为孤立对象。'
- en: Memory management of objects.
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象的内存管理。
- en: 'Programs tend to create huge numbers of objects but have a need for only a
    small number of them at any given time. Accordingly, programming languages and
    systems need mechanisms to create objects (and allocate memory), and mechanisms
    to destroy objects (and free memory) when the objects become orphans. Most programming
    systems take care of allocating memory for *variables* when they come into existence
    and freeing that memory when they go out of scope. Memory management for *objects*
    is more complicated: Python knows to allocate memory for an object when it is
    created, but cannot know precisely when to free the memory associated with an
    object, because the dynamics of a program in execution determine when an object
    becomes an orphan and so should be destroyed. There is no way for the system to
    predict what a program will do, so it has to monitor what a program is doing and
    take action accordingly.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 程序往往会创建大量的对象，但在任何给定时间只需要其中很���一部分。因此，编程语言和系统需要机制来创建对象（和分配内存），以及在对象成为孤立对象时销毁对象（和释放内存）。大多数编程系统在变量产生时负责为*变量*分配内存，并在变量超出范围时释放该内存。对象的内存管理更为复杂：Python在创建对象时知道要为对象分配内存，但无法准确知道何时释放与对象关联的内存，因为程序执行的动态决定了何时对象成为孤立对象，因此应该被销毁。系统无法预测程序将做什么，因此必须监视程序正在做什么并相应采取行动。
- en: In many languages (such as C and C++), the programmer is responsible for both
    allocating and deallocating memory. Doing so is tedious and notoriously error-prone.
    One of Python's most significant features is its ability to automatically manage
    memory. The idea is to free the programmers from the responsibility of managing
    memory by keeping track of orphaned objects and returning the memory they use
    to a pool of free memory. Reclaiming memory in this way is known as *garbage collection*,
    and Python's type system enables it to perform this operation this efficiently
    and automatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言（如C和C++）中，程序员负责分配和释放内存。这样做既繁琐又容易出错。Python最重要的特性之一是其自动管理内存的能力。其思想是通过跟踪孤立对象并将它们使用的内存返回到空闲内存池中，使程序员免除管理内存的责任。以这种方式回收内存被称为*垃圾回收*，Python的类型系统使其能够高效自动执行此操作。
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** What happens if I call a method that is not defined for a given object?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我调用一个给定对象未定义的方法会发生什么？'
- en: '**A.** Python raises an `AttributeError` at run time.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python在运行时引发`AttributeError`。'
- en: '**Q.** Why can we use `stdio.writeln(x)` instead of `stdio.writeln(str(x))`
    to write an object `x` that is not a string?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么我们可以使用`stdio.writeln(x)`而不是`stdio.writeln(str(x))`来写入一个不是字符串的对象`x`？'
- en: '**A.** For convenience, the `stdio.writeln()` function calls the built-in `str()`
    function automatically whenever a string object is needed.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 为了方便起见，`stdio.writeln()`函数在需要字符串对象时会自动调用内置的`str()`函数。'
- en: '**Q.** I noticed that [potential.py](potential.py.html) calls `stdarray.create1D()`
    to create an array of `Charge` objects, but provides only one argument (the desired
    number of elements). Doesn''t `stdarray.create1D()` require that I provide two
    arguments: the desired number of elements and the initial value of the elements?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我注意到[potential.py](potential.py.html)调用`stdarray.create1D()`来创建一个`Charge`对象数组，但只提供了一个参数（所需元素的数量）。难道`stdarray.create1D()`不需要我提供两个参数吗：所需元素的数量和元素的初始值？'
- en: '**A.** If no initial value is specified, both `stddarray.create1D()` and `stdarray.create2D()`
    use the special value `None`, which refers to no object. Immediately after calling
    `stdarray.create1D()`, [potential.py](potential.py.html) changes each array element
    so it refers to a new `Charge` object.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 如果未指定初始值，`stddarray.create1D()`和`stdarray.create2D()`都使用特殊值`None`，它不指向任何对象。在调用`stdarray.create1D()`后，[potential.py](potential.py.html)会将每个数组元素更改为指向一个新的`Charge`对象。'
- en: '**Q.** Can I call a method with a literal or other expression?'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以用文字或其他表达式调用一个方法吗？'
- en: '**A.** Yes, from the client''s point of view, you can use any expression to
    invoke a method. When Python executes the method call, it evaluates the expression
    and calls the method on the resulting object. For example, `''python''.upper()`
    returns `''PYTHON''` and `(3 ** 100).bit_length()` returns 159\. However, you
    need to be careful with integer literals — for example, `1023.bit_length()` raises
    a `SyntaxError` because Python interprets `1023.` as a floating-point literal;
    instead, you can use `(1023).bit_length()`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，从客户端的角度来看，您可以使用任何表达式来调用方法。当Python执行方法调用时，它会评估表达式并在结果对象上调用方法。例如，`''python''.upper()`返回`''PYTHON''`，`(3
    ** 100).bit_length()`返回159。然而，您需要小心处理整数字面量 - 例如，`1023.bit_length()`会引发`SyntaxError`，因为Python将`1023.`解释为浮点数字面量；相反，您可以使用`(1023).bit_length()`。'
- en: '**Q.** Can I chain together several string method calls in one expression?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以在一个表达式中链接多个字符串方法调用吗？'
- en: '**A.** Yes. For example, the expression `s.strip().lower()` works as expected.
    That is, it evaluates to a new string that is a copy of `s` with leading and trailing
    whitespace removed, and with all remaining characters converted to lowercase.
    It works because (1) each of the methods returns its result as a string and (2)
    the dot operator is left associative, so Python calls the methods from left to
    right.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。例如，表达式`s.strip().lower()`按预期工作。也就是说，它计算为一个新字符串，该字符串是`s`的副本，去除了前导和尾随空格，并将所有剩余字符转换为小写。它之所以有效是因为（1）每个方法将其结果作为字符串返回，（2）点运算符是左结合的，因此Python从左到右调用方法。'
- en: '**Q.** Why red, green, and blue instead of red, yellow, and blue?'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么是红色、绿色和蓝色，而不是红色、黄色和蓝色？'
- en: '**A.** In theory, any three colors that contain some amount of each primary
    color would work, but two different color models have evolved: RGB produces good
    colors on television screens, computer monitors, and digital cameras, and CMYK
    is typically used for the printed page (see the "color conversion exercise in
    Section 1.2). CMYK does include yellow (cyan, magenta, yellow, and black). Two
    different schemes are appropriate because printed inks absorb color; thus, where
    there are two different inks, there are more colors absorbed and fewer reflected.
    In contrast, video displays emit color; thus, where there are two different colored
    pixels, there are more colors emitted.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 理论上，任何包含每种原色一定量的三种颜色都可以使用，但已经发展出了两种不同的颜色模型：RGB在电视屏幕、计算机显示器和数码相机上产生良好的颜色，而CMYK通常用于印刷页面（请参见第1.2节中的“颜色转换练习”）。CMYK包括黄色（青色、品红色、黄色和黑色）。两种不同的方案是合适的，因为印刷油墨吸收颜色；因此，当有两种不同的油墨时，吸收的颜色更多，反射的颜色更少。相反，视频显示器发射颜色；因此，当有两种不同的彩色像素时，发射的颜色更多。'
- en: '**Q.** Is there any problem with creating thousands of `Color` objects, as
    in [grayscale.py](grayscale.py.html)? It seems wasteful.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 创建成千上万个`Color`对象是否会有问题，就像[grayscale.py](grayscale.py.html)中那样？看起来很浪费。'
- en: '**A.** All programming-language constructs come at some cost. In this case
    the cost is reasonable, since the time required to create the `Color` objects
    is tiny compared to the time required to actually draw the picture.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 所有编程语言结构都有一定的成本。在这种情况下，成本是合理的，因为创建`Color`对象所需的时间与实际绘制图片所需的时间相比微不足道。'
- en: '**Q.** Can a data type have two methods (or constructors) with the same name
    but with a different number of arguments?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 一个数据类型是否可以有两个方法（或构造函数）具有相同的名称，但参数数量不同？'
- en: '**A.** No, just as with functions, you cannot have two methods (or constructors)
    with the same name. As with functions, methods (and constructors) can use optional
    arguments with default values. This is how the `Picture` data type creates the
    illusion of having two constructors.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不可以，就像函数一样，不能有两个方法（或构造函数）具有相同的名称。与函数一样，方法（和构造函数）可以使用具有默认值的可选参数。这就是`Picture`数据类型如何创建具有两个构造函数的幻觉。'
- en: '**Q**. When using a linear filter, each pixel becomes a weighted average of
    its 8 neighbors. What do I do when the pixel has less than 8 neighbors because
    it is near the border?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q**. 在使用线性滤波器时，每个像素变为其8个邻居的加权平均值。当像素由于靠近边界而具有少于8个邻居时，我该怎么办？'
- en: '**A**. You could assume the image is toroidal (periodic boundary conditions)
    and make the left boundary wrap around to the right boundary, and the top boundary
    wrap around to the bottom boundary.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**. 您可以假设图像是环形的（周期性边界条件），使左边界环绕到右边界，顶部边界环绕到底部边界。'
- en: '**Q**. Where can I download some test files for image processing?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q**. 我在哪里可以下载一些用于图像处理的测试文件？'
- en: '**A**. [USC SIPI](http://sipi.usc.edu/services/database/database.cgi?volume=misc)
    contains standard test images (including [Mandrill](mandrill.jpg)).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**. [USC SIPI](http://sipi.usc.edu/services/database/database.cgi?volume=misc)包含标准测试图像（包括[Mandrill](mandrill.jpg)）。'
- en: '* * *'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Compose a program that takes a float command-line argument `w`, creates four
    `Charge` objects (each with charge value 1.0) that are each distance `w` in each
    of the four cardinal directions from `(.5, .5)`, and writes the potential at (0.25,
    0.5).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个浮点命令行参数`w`，创建四个`Charge`对象（每个对象的电荷值为1.0），每个对象距离`(0.5, 0.5)`在四个基本方向上各为`w`，并在`(0.25,
    0.5)`处写入电势。
- en: '*Solution*: See [fourchargeclient.py](fourchargeclient.py.html).'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[fourchargeclient.py](fourchargeclient.py.html)。'
- en: Compose a program that takes from the command line three integers between 0
    and 255 that represent red, green, and blue values of a color and then creates
    and shows a 256-by-256 `Picture` of that color.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行获取三个介于0和255之间的整数，表示颜色的红色、绿色和蓝色值，然后创建并显示一个256x256的`Picture`颜色。
- en: Modify [alberssquares.py](albersquares.py.html) to take nine command-line arguments
    that specify three colors and then draws the six squares showing all the Albers
    squares with the large square in each color and the small square in each different
    color.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[alberssquares.py](albersquares.py.html)，以获取指定三种颜色的九个命令行参数，然后绘制六个方块，显示所有具有大方块的Albers方块，每个颜色一个，小方块每个颜色不同。
- en: Compose a program that takes the name of a grayscale picture file as a command-line
    argument and uses `stddraw` to plot a histogram of the frequency of occurrence
    of each of the 256 grayscale intensities.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序将以灰度图片文件的名称作为命令行参数，并使用`stddraw`绘制每个256个灰度强度的频率直方图。
- en: Compose a program that takes the name of a picture file as a command-line argument
    and flips the image horizontally.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，以图片文件的名称作为命令行参数，并水平翻转图像。
- en: Compose a program that takes the name of an picture file as a command-line input,
    and creates three images — on with only the red components, one with only the
    green components, and one with only the blue components.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，以图片文件的名称作为命令行输入，并创建三个图像——一个只有红色分量，一个只有绿色分量，一个只有蓝色分量。
- en: Compose a program that takes the name of an picture file as a command-line argument
    and writes the pixel coordinates of the lower left corner and the upper right
    corner of the smallest bounding box (rectangle parallel to the *x*- and *y*-axes)
    that contains all of the non-white pixels.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序以图片文件的名称作为命令行参数，并写入包含所有非白色像素的最小边界框（与*x*和*y*轴平行的矩形）的左下角和右上角的像素坐标。
- en: Compose a program that takes as command line arguments the name of a picture
    file and the pixel coordinates of a rectangle within the image; reads from standard
    input a list of `Color` values (represented as triples of integers); and serves
    as a filter, printing out those `Color` values for which all pixels in the rectangle
    are background/foreground compatible. (Such a filter can be used to pick a color
    for text to label an image.)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，以图片文件的名称和图像内矩形的像素坐标作为命令行参数；从标准输入中读取`Color`值的列表（表示为整数三元组）；并作为过滤器，打印出那些矩形中所有像素都是背景/前景兼容的`Color`值。（这样的过滤器可用于选择用于标记图像文本的颜色。）
- en: Compose a function `isValidDNA()` that takes a string as input and returns `True`
    if and only if it is comprised entirely of the characters A, C, T, and G.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`isValidDNA()`的函数，以字符串作为输入，并仅当它完全由字符A、C、T和G组成时返回`True`。
- en: 'Compose a function `complementWC()` that takes a DNA string as its argument
    and returns its *Watson-Crick complement*: replace A with T, C with G, and vice
    versa.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`complementWC()`的函数，以DNA字符串作为参数，并返回其*沃森-克里克互补*：将A替换为T，C替换为G，反之亦然。
- en: Compose a function `palindromeWC()` that takes a DNA string as its argument
    and returns `True` if the string is a Watson-Crick complemented palindrome, and
    `False` otherwise. A *Watson-Crick complemented palindrome* is a DNA string that
    is equal to the reverse of its Watson-Crick complement.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`palindromeWC()`的函数，以DNA字符串作为参数，并在该字符串是沃森-克里克互补回文时返回`True`，否则返回`False`。*沃森-克里克互补回文*是一个等于其沃森-克里克互补的字符串的反转的DNA字符串。
- en: Compose a program to check whether an ISBN number is valid (see the "Checksum"
    exercise in Section 1.3), taking into account that an ISBN number can have hyphens
    inserted at arbitrary places.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来检查ISBN号码是否有效（参见第1.3节中的“校验和”练习），考虑到ISBN号码可以在任意位置插入连字符。
- en: What does the following code fragment write?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段写入什么内容？
- en: '[PRE5]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Solution*: ''Hello World''. String objects are immutable — a string method
    returns a new `str` object with the appropriate value, but does not change the
    value of the object that was used to invoke it. This code ignores the objects
    returned and just writes the original string. To update `s`, write `s = s.upper()`
    and `s = s[6:11]`.'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：''Hello World''。字符串对象是不可变的 —— 字符串方法返回一个具有适当值的新`str`对象，但不会更改用于调用它的对象的值。此代码忽略了返回的对象，只是写入原始字符串。要更新`s`，请写入`s
    = s.upper()`和`s = s[6:11]`。'
- en: 'A string `s` is a *circular shift* of a string `t` if it matches when the characters
    are circularly shifted by any number of positions. For example, ACTGACG is a circular
    shift of TGACGAC, and vice versa. Detecting this condition is important in the
    study of genomic sequences. Compose a function that checks whether two given strings
    `s` and `t` are circular shifts of one another. *Hint*: The solution is a one-liner
    with the `in` operator and string concatenation.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符串`s`是字符串`t`的*循环移位*，则当字符按任意位置进行循环移位时它们匹配。例如，ACTGACG是TGACGAC的循环移位，反之亦然。检测这种条件在基因组序列研究中很重要。编写一个函数，检查两个给定的字符串`s`和`t`是否彼此的循环移位。*提示*：解决方案是使用`in`运算符和字符串连接的一行代码。
- en: Given a string site that represents a website URL, compose a code fragment to
    determine its domain type. For example, the domain type for the string `http://introcs.cs.princeton.edu/python`
    is `edu`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定表示网站URL的字符串site，编写一个代码片段来确定其域类型。例如，字符串`http://introcs.cs.princeton.edu/python`的域类型是`edu`。
- en: Compose a function that takes a domain name as argument and returns the reverse
    domain (reverse the order of the strings between periods). For example, the reverse
    domain of `introcs.cs.princeton.edu` is `edu.princeton.cs.introcs`. This computation
    is useful for web log analysis (see the "Reverse domain" creative exercise in
    Section 4.2).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，以域名作为参数，并返回反向域（反转句点之间的字符串顺序）。例如，`introcs.cs.princeton.edu`的反向域是`edu.princeton.cs.introcs`。这种计算对于网络日志分析很有用（参见第4.2节中的“反向域”创意练习）。
- en: What does the following recursive function return?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下递归函数返回什么内容？
- en: '[PRE6]'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Compose a version of [potentialgene.py](potentialgene.py.html) that finds all
    potential genes contained in a long DNA string. Add a command-line argument to
    allow the user to specify a minimum length of a potential gene.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写[potentialgene.py](potentialgene.py.html)的一个版本，找出长DNA字符串中包含的所有潜在基因。添加一个命令行参数，允许用户指定潜在基因的最小长度。
- en: 'Compose a program that takes a start string and a stop string as command line
    arguments and writes all substrings of a given string that start with the first,
    end with the second, and otherwise contain neither. *Note*: Be especially careful
    of overlaps!'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，以起始字符串和停止字符串作为命令行参数，并写入给定字符串的所有子字符串，这些子字符串以第一个字符串开头，以第二个字符串结尾，否则不包含这两个字符串。*注意*：特别注意重叠！
- en: Compose a filter that reads text from an input stream and prints it to an output
    stream, removing any lines that consist only of whitespace.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器，从输入流中读取文本并将其打印到输出流中，删除任何仅由空白组成的行。
- en: Modify [potential.py](potential.py.html) to take an integer *n* from the command
    line and generate *n* random `Charge` objects in the unit square, with potential
    values drawn randomly from a Gaussian distribution with mean 50 and standard deviation
    10.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[potential.py](potential.py.html)，从命令行接受一个整数*n*，并在单位正方形中生成*n*个随机的`Charge`对象，其电位值从均值为50、标准差为10的高斯分布中随机抽取。
- en: Modify [stockquote.py](stockquote.py.html) to take multiple symbols on the command
    line.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[stockquote.py](stockquote.py.html)以在命令行上接受多个符号。
- en: The example file `djia.csv` used for [split.py](split.py.html) lists the date,
    high price, volume, and low price of the Dow Jones stock market average for every
    day since records have been kept. Download this file from the booksite and compose
    a program that plots the prices and volumes, at a rate taken from the command
    line.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于[split.py](split.py.html)的示例文件`djia.csv`列出了自有记录以来每天道琼斯股市平均价格的日期、最高价格、成交量和最低价格。从书站下载这个文件，并编写一个程序，根据命令行中的速率绘制价格和成交量。
- en: Compose a program `merge.py` that takes a delimiter string followed by an arbitrary
    number of file names as command line arguments, concatenates the corresponding
    lines of each file, separated by the delimiter, and then writes the result to
    standard output, thus performing the opposite operation from [split.py](split.py.html).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`merge.py`的程序，它接受一个分隔符字符串，后跟任意数量的文件名作为命令行参数，将每个文件的相应行连接起来，用分隔符分隔，然后将结果写入标准输出，从而执行与[split.py](split.py.html)相反的操作。
- en: Find a website that publishes the current temperature in your area, and compose
    a screen-scraper program `weather.py` so that typing `python weather.py` followed
    by your zip code will give you a weather forecast.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找一个发布你所在地当前温度的网站，并编写一个名为`weather.py`的屏幕抓取程序，这样输入`python weather.py`后跟上你的邮政编码，就能给你一个天气预报。
- en: '* * *'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Picture filtering**. Compose a module `rawpicture.py` with `read()` and `write()`
    functions for use with standard input and standard output. The `write()` function
    takes a `Picture` as argument and writes the picture to standard output, using
    the following format: if the picture is *w*-by-*h*, write *w*, then *h*, then
    *w*h* triples of integers representing the pixel color values, in row major order.
    The `read()` function takes no arguments and returns a `Picture`, which it creates
    by reading a picture from standard input, in the format just described. *Note*:
    The picture filtering will use up much more disk space than the picture — the
    standard formats *compress* this information so that it will not take up so much
    space.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图片过滤**。编写一个名为`rawpicture.py`的模块，其中包含用于标准输入和标准输出的`read()`和`write()`函数。`write()`函数以`Picture`作为参数，并将图片写入标准输出，使用以下格式：如果图片是*w*-by-*h*，则写入*w*，然后*h*，然后*w*h*个整数三元组，表示像素颜色值，按行主要顺序。`read()`函数不带参数，并返回一个`Picture`，它通过从标准输入读取图片来创建，格式如上所述。*注意*：图片过滤将使用比图片更多的磁盘空间
    — 标准格式*压缩*这些信息，以便不会占用太多空间。'
- en: '**Kama Sutra cipher**. Compose a filter that takes two strings as command-line
    arguments (the *key* strings), then reads standard input, substitutes for each
    letter as specified by the key strings, and writes the result to standard output.
    This operation is the basis for one of the earliest known cryptographic systems.
    The condition on the key strings is that they must be of equal length and that
    any letter in standard input must be in one of them. For example, if input is
    all capital letters and the keys are THEQUICKBROWN and FXJMPSVRLZYDG, then we
    make the table.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**卡玛苏特拉密码**。编写一个过滤器，它以两个字符串作为命令行参数（*密钥*字符串），然后读取标准输入，按照密钥字符串指定的方式替换每个字母，并将结果写入标准输出。这个操作是已知的最早的密码系统之一的基础。密钥字符串的条件是它们必须具有相同的长度，并且标准输入中的任何字母必须在其中一个字符串中。例如，如果输入都是大写字母，密钥是THEQUICKBROWN和FXJMPSVRLZYDG，那么我们制作表格。'
- en: '[PRE7]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: which tells us that we should substitute F for T, T for F, H for X, X for H,
    and so forth when copying the input to the output. The message is encoded by replacing
    each letter with its pair. For example, the message MEET AT ELEVEN is encoded
    as QJJF BF JKJCJG. Someone receiving the message can use the same keys to get
    the message back.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉我们，当将输入复制到输出时，我们应该用F替换T，T替换F，H替换X，X替换H，依此类推。消息通过用其对应的字母替换每个字母来编码。例如，消息MEET
    AT ELEVEN被编码为QJJF BF JKJCJG。接收消息的人可以使用相同的密钥将消息还原。
- en: '*Solution*: See [kamasutra.py](kamasutra.py.html).'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[kamasutra.py](kamasutra.py.html)。'
- en: '**Safe password verification**. Compose a function that takes a string as argument
    and returns `True` if it meets the following conditions, `False` otherwise:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安全密码验证**。编写一个函数，以字符串作为参数，并在满足以下条件时返回`True`，否则返回`False`：'
- en: At least eight characters long
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少八个字符长
- en: Contains at least one digit (0-9)
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少包含一个数字（0-9）
- en: Contains at least one uppercase letter
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少包含一个大写字母
- en: Contains at least one lowercase letter
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少包含一个小写字母
- en: Contains at least one character that is neither a letter nor a number
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少包含一个既不是字母也不是数字的字符
- en: Such checks are commonly used for passwords on the web.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些检查通常用于网站上的密码。
- en: '**Color study**. Compose a program that displays the color study shown below,
    which gives Albers squares corresponding to each of the 256 levels of blue (blue-to-white
    in row-major form) and gray (black-to-white in column-major form) that were used
    to print the textbook.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**色彩研究**。编写一个程序，显示下面显示的色彩研究，其中给出了与书中使用的256个蓝色级别（按行主要形式的蓝色到白色）和灰色级别（按列主要形式的黑色到白色）相对应的Albers方块。'
- en: '![Color study](../Images/99f0b99abb34aeb7b2a1171f96cab45e.png)'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![色彩研究](../Images/99f0b99abb34aeb7b2a1171f96cab45e.png)'
- en: '*Solution*: See [colorstudy.py](colorstudy.py.html).'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[colorstudy.py](colorstudy.py.html)。'
- en: '**Entropy**. The *Shannon entropy* measures the information content of an input
    string and plays a cornerstone role in information theory and data compression.
    Given a string of *n* characters, let *f[c]* be the frequency of occurrence of
    character *c*. The quantity *p[c] = f[c] / n* is an estimate of the probability
    that *c* would be in the string if it were a random string, and the entropy is
    defined to be the sum of the quantity -*p[c] log[2] p[c]*, over all characters
    that appear in the string. The entropy is said to measure the *information content*
    of a string: if each character appears the same number times, the entropy is at
    its minimum value. Compose a program that computes and writes to standard output
    the entropy of the string from standard input. Run your program on a web page
    that you read regularly and on a recent paper that you wrote.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**熵**。*香农熵*度量输入字符串的信息内容，在信息理论和数据压缩中起着基石作用。给定一个包含*n*个字符的字符串，让*f[c]*表示字符*c*出现的频率。量*p[c]
    = f[c] / n*是字符*c*在字符串中出现的概率的估计，熵被定义为所有出现在字符串中的字符的数量-*p[c] log[2] p[c]*的总和。熵被认为是字符串的*信息内容*的度量：如果每个字符出现相同次数，熵将达到最小值。编写一个程序，计算并将字符串的熵写入标准输出。在您经常阅读的网页和您最近写的论文上运行您的程序。'
- en: '**Minimize potential**. Compose a function that takes an array of `Charge`
    objects with positive potential as its argument and finds a point such that the
    potential at that point is within 1% of the minimum potential anywhere in the
    unit square. Use a `Charge` object to return this information. Compose a test
    client that callsyour function to write the point coordinates and charge value
    for the data given in the text and for the random charges described in a previous
    exercise in this section.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小化电势**。编写一个函数，该函数接受具有正电势的`Charge`对象数组作为参数，并找到一个点，使得该点的电势与单位正方形中任何位置的最小电势相差不超过1%。使用`Charge`对象返回此信息。编写一个测试客户端，调用您的函数以写入文本中给定数据和本节中描述的随机电荷的点坐标和电荷值。'
- en: '**Slide show**. Compose a program that takes the names of several image files
    as command-line arguments and displays them in a slide show (one every two seconds),
    using a fade effect to black and a fade from black between pictures.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**幻灯片放映**。编写一个程序，该程序以几个图像文件的名称作为命令行参数，并以幻灯片放映的方式显示它们（每两秒显示一个），在图片之间使用淡入淡出效果。'
- en: '**Tile**. Compose a program that takes the name of an image file and two integers
    `m` and `n` as command-line arguments and creates an `m`-by-`n` tiling of the
    picture.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平铺**。编写一个程序，该程序以图像文件的名称和两个整数`m`和`n`作为命令行参数，并创建一个`m`×`n`的图片平铺。'
- en: '**Rotation filter**. Compose a program that takes two command line arguments
    (the name of an image file and a real number θ) and rotates the image θ degrees
    counterclockwise. To rotate, copy the color of each pixel (*s*[*i*], *s*[*j*])
    in the source image to a target pixel (*t*[*i*], *t*[*j*]) whose coordinates are
    given by the following formulas:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**旋转滤镜**。编写一个程序，该程序接受两个命令行参数（图像文件的名称和实数θ），并将图像逆时针旋转θ度。要进行旋转，将源图像中的每个像素(*s*[*i*],
    *s*[*j*])的颜色复制到由以下公式给出的目标像素(*t*[*i*], *t*[*j*）：'
- en: '| *t*[*i*] = (*s*[*i*] - *c*[*i*])cos θ + (*s*[*j*] - *c*[*j*])sin θ + *c*[*i*]
    *t*[*j*] = (*s*[*i*] - *c*[*i*])sin θ + (*s*[*j*] - *c*[*j*])cos θ + *c*[*j*]
    |'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| *t*[*i*] = (*s*[*i*] - *c*[*i*])cos θ + (*s*[*j*] - *c*[*j*])sin θ + *c*[*i*]
    *t*[*j*] = (*s*[*i*] - *c*[*i*])sin θ + (*s*[*j*] - *c*[*j*])cos θ + *c*[*j*]
    |'
- en: 'where (*c*[*i*], *c*[*j*]) is the center of the image. For example, these images
    show a 30 degree rotation:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中(*c*[*i*], *c*[*j*])是图像的中心。例如，这些图像展示了30度的旋转：
- en: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    rotated](../Images/842b227aac8675f9a0a7919c5798d504.png) |'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    旋转](../Images/842b227aac8675f9a0a7919c5798d504.png) |'
- en: '*Solution*: See [rotation.py](rotation.py.html).'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[rotation.py](rotation.py.html)。'
- en: '**Swirl filter**. Creating a swirl effect is similar to rotation, except that
    the angle changes as a function of distance to the center. Use the same formulas
    as in the previous exercise, but compute θ as a function of (*s*[*i*], *s*[*j*]),
    specifically π/256 times the distance to the center. For example:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**漩涡滤镜**。创建漩涡效果类似于旋转，只是角度随着到中心的距离而变化。使用与前一个练习中相同的公式，但将θ计算为(*s*[*i*], *s*[*j*])的函数，具体来说是π/256乘以到中心的距离。例如：'
- en: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    swirled](../Images/1a20170dbac9452f1755418b390255a9.png) |'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    漩涡效果](../Images/1a20170dbac9452f1755418b390255a9.png) |'
- en: '*Solution*: See [swirl.py](swirl.py.html).'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[swirl.py](swirl.py.html)。'
- en: '**Wave filter**. Compose a filter like those in the previous two exercises
    that creates a wave effect, by copying the color of each pixel (*s*[*i*], *s*[*j*])
    in the source image to a target pixel (*t*[*i*], *t*[*j*]), where *t*[*i*] = *s*[*i*]
    and *t*[*j*] = *s*[*j*] + 20 sin(2 π *s*[*j*]/64). Add code to take the amplitude
    (20 in the accompanying figure) and the frequency (64 in the accompanying figure)
    as command-line arguments. Experiment with various values of these parameters.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波浪滤镜**。编写一个类似于前两个练习中的滤镜，创建波浪效果，通过将源图像中的每个像素(*s*[*i*], *s*[*j*])的颜色复制到目标像素(*t*[*i*],
    *t*[*j*），其中*t*[*i*] = *s*[*i*]，*t*[*j*] = *s*[*j*] + 20 sin(2 π *s*[*j*]/64)。添加代码以将振幅（附图中的20）和频率（附图中的64）作为命令行参数。尝试不同的参数值。'
- en: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    waved](../Images/4af57de0bc772ee5a10bbdfad279b39e.png) |'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    波浪效果](../Images/4af57de0bc772ee5a10bbdfad279b39e.png) |'
- en: '*Solution*: See [wave.py](wave.py.html).'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请查看[wave.py](wave.py.html)。'
- en: '**Glass filter**. Compose a program that takes the name of an image file as
    a command-line argument and applies a *glass filter*: set each pixel *p* to the
    color of a random neighboring pixel (whose pixel coordinates are each within 5
    pixels of *p*''s coordinates). For example:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**玻璃滤镜**。编写一个程序，该程序以图像文件的名称作为命令行参数，并应用*玻璃滤镜*：将每个像素*p*设置为随机相邻像素的颜色（其像素坐标在*p*的坐标的5个像素内）。例如：'
- en: '| ![Mandrill](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![Mandrill
    through glass](../Images/026dfe85fa685a30e39b6765c8d80fd1.png) |'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![猴面包树](../Images/00dbe0bf8286f54dd4c0e60d0f88c313.png) |  | ![透过玻璃的猴面包树](../Images/026dfe85fa685a30e39b6765c8d80fd1.png)
    |'
- en: '*Solution*: See [glass.py](glass.py.html).'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[glass.py](glass.py.html)。'
- en: '**Morph**. The example images shown in this section for [fade.py](fade.py.html)
    do not quite line up in the vertical direction (the mandrill''s mouth is much
    lower than Darwin''s). Modify [fade.py](fade.py.html) to add a transformation
    in the vertical dimension that makes a smoother transition.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变形**。本节中显示的示例图像对于[fade.py](fade.py.html)并不完全在垂直方向上对齐（猴面包树的嘴比达尔文的低得多）。修改[fade.py](fade.py.html)，在垂直维度上添加一个变换，使过渡更加平滑。'
- en: '**Clusters**. Compose a program that take the name of a picture file from the
    command line and produces and displays to stddraw a picture with filled circles
    that cover compatible areas. First, scan the image to determine the background
    color (a dominant color that is found in more than half the pixels). Use depth
    first search, as described in Section 2.4, to find contiguous sets of pixels that
    are foreground-compatible with the background. A scientist might use this program
    to study natural scenarios such as birds in flight or particles in motion. Take
    a photo of balls on a billiards table and try to get your program to identify
    the balls and positions.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**聚类**。编写一个程序，从命令行接受图片文件的名称，并生成并显示一个用填充圆覆盖兼容区域的图片。首先，扫描图像以确定背景颜色（在超过一半像素中找到的主导颜色）。使用深度优先搜索，如第2.4节所述，找到与背景兼容的前景像素的连续集。科学家可以使用这个程序来研究自然场景，如飞行中的鸟类或运动中的粒子。拍摄台球桌上的球的照片，并尝试让您的程序识别球和位置。'
- en: '**Digital zoom**. Compose a program `zoom.py` that takes the name of an image
    file and three numbers *s*, *x*, and *y* as command-line arguments and displays
    a picture that zooms in on a portion of the input picture. The numbers are all
    between 0 and 1, with *s* to be interpreted as a scale factor and (*x*, *y*) as
    the relative coordinates of the point that is to be at the center of the output
    image. Use this program to zoom in on your dog or a friend in some digital image
    on your computer.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数字缩放**。编写一个名为`zoom.py`的程序，接受一个图像文件的名称和三个数字*s*、*x*和*y*作为命令行参数，并显示一个放大输入图片一部分的图片。这些数字都在0和1之间，*s*被解释为一个比例因子，(*x*,
    *y*)被解释为输出图像中心点的相对坐标。使用这个程序来放大您计算机上某个数字图像中的狗或朋友。'
