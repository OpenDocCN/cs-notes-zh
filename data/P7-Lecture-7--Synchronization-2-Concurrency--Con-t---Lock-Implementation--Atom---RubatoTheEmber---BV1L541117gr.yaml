- en: P7：Lecture 7： Synchronization 2 Concurrency (Con't), Lock Implementation, Atom
    - RubatoTheEmber - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P7：第7讲：同步 2 并发（续），锁的实现，原子 - RubatoTheEmber - BV1L541117gr
- en: Okay。 Welcome everybody to CS162。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎大家来到CS162课程。
- en: '![](img/53a0bbd96bce73194524f58499453c5d_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53a0bbd96bce73194524f58499453c5d_1.png)'
- en: Real lifestyle， which is always kind of nice。 Today we're going to pick up where
    we left off and start really pushing on implementation。 of threads。 And then we're
    going to move into some of the consequences of threads when we start。 worrying
    about synchronization。 So， if you remember from last time we had this example。
    which always stymies people the， first time they hear it or see it。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的生活方式，总是挺不错的。今天我们将从上次的内容继续，真正开始推进线程的实现。然后我们会讨论线程的一些后果，特别是当我们开始关注同步问题时。所以下次如果你记得上次我们有一个示例，这个示例通常会让第一次听到或看到的人感到困惑。
- en: So let's briefly remember the idea is we have two threads S and T。 The fact
    that there's。 two threads running the same code should not be mysterious to you。
    We could either， you know。 the code is on disk。 We could either have two separate
    processes or we could have two threads within a process。 both of which are starting
    that code。 So that's not mysterious。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们简单回顾一下，理念是我们有两个线程S和T。线程运行相同代码这一事实对你们来说不应该感到神秘。代码可以存储在磁盘上。我们可以有两个独立的进程，也可以在一个进程内有两个线程，它们都在启动这段代码。所以这不是什么神秘的事情。
- en: And remember every thread has its own stack。 So when thread S runs we've got
    A calls B。 B goes into loop with while it calls yield。 That takes us into the
    kernel which calls run new thread which calls switch。 So run new thread is really
    a proxy for our scheduler right now。 It's going to make a decision about which
    thread。 And we're going to have a whole couple。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个线程都有自己的栈。所以当线程S运行时，它调用A，然后A调用B，B进入循环并调用yield。这会把我们带到内核，然后内核调用运行新线程，再调用切换。因此，运行新线程现在实际上是我们调度器的代理。它将决定选择哪个线程。我们将有一个完整的过程。
- en: several lectures on scheduling。 Okay， because that decision of which next thread。
    lots of interesting possibilities。 Okay， if you can think of it。 it's probably
    been done by somebody。 But back to this， run new thread picks a new thread to
    run。 Hence its name。 Then it calls switch and switch does what？ Well it swaps
    the registers in thread S。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几次关于调度的讲座。好的，因为决定下一个线程是什么，会有很多有趣的可能性。好的，如果你能想到的，它可能已经被某人做过了。但回到这个问题，运行新线程选择了一个新的线程来运行。这就是它的名字。然后它调用切换，切换做了什么？嗯，它交换了线程S中的寄存器。
- en: saves them to the TCB and loads the registers from， T。 one of those registers
    happens to be a stack pointer。 So the fact that switch switched S for T means
    poof。 Suddenly we're in T stack。 That's why there's this arrow here。 And then
    we kind of go backwards up the stack。 Okay。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们保存到TCB中，并从T加载寄存器。其中一个寄存器恰好是栈指针。所以切换把S换成T，意味着“砰”，我们突然进入了T的栈。这就是这里有箭头的原因。然后我们就从栈顶向回走。好的。
- en: now this is an imperfect animation that I gave you there but you get the idea
    that。 just as soon as the stack pointer switch suddenly we're in this switch over
    here。 And so when we return from switch we end up returning to run new thread
    which returns。 back to yield which returns to while。 The while loop calls yield，
    yields goes into run new thread。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个不完美的动画，但你们可以明白我的意思：一旦栈指针切换，我们就突然进入了这里的切换状态。所以，当我们从切换返回时，我们最终会返回到运行新线程，然后再返回到yield，再返回到while。while循环调用yield，yield又进入运行新线程。
- en: thread calls switch。 We'll say there's only two threads in the world， switch
    calls。 switches out thread T for， thread S and the whole thing happens again。
    Okay。 and I want to pause here because I know there is already some discussion
    on Piazza。 as though what does this mean？ So go ahead， ask me， what does this
    mean question？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 线程调用切换。我们假设世界上只有两个线程，切换调用将线程T替换为线程S，然后整个过程再次发生。好的，我想在这里暂停一下，因为我知道在Piazza上已经有一些讨论了，大家在问这意味着什么？那你们可以继续问我，这意味着什么？
- en: Presumably something to do with this slide。 What does this mean that the daffodils
    are blooming？ No。 nothing like that but yes。 Good syntax too by the way， what
    did you mean？ I like that。 Okay。 go ahead。 Okay， good question。 The question is
    when I said， when I gave this example。 what did I say we went back up the， stack？
    Okay， good。 So let's answer that。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 推测这和这个幻灯片有什么关系？什么是水仙花开了的意思？不，不是那样，但对，语法也很好，顺便说一句，你什么意思？我喜欢这个。好的，继续。好的，问题来了。当我给出这个例子时，我说我们回到栈上了？好的，好的。那我们就来回答这个问题。
- en: Let's go back to this point。 So you understand the idea that each time we call
    a new procedure we get a new stack frame。 and that's going to be where local variables
    are stored， that's where the return address， is stored。 And so if we only had
    one thread， yes， what would happen is A would call B， B would call， yield。 yield
    would call a new thread， we would switch， which would do nothing and then we return。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到这一点。所以你明白了，每次调用新程序时，我们都会得到一个新的堆栈帧。局部变量就存储在这里，返回地址也存储在这里。所以如果我们只有一个线程，是的，发生的事情是
    A 会调用 B，B 会调用 yield，yield 会调用一个新线程，我们会切换，然后什么都不做，然后返回。
- en: from switch， which would actually erase that switch stack， then we would return
    run from。 new thread which would erase that one and then we would return to yield
    which would erase。 that one and we backed it back in the while loop and then we'd
    do it all over again。 Okay。 So if you get what I just said there， the way to think
    about this whole thing is the moment。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从 switch 开始，它实际上会擦除那个 switch 堆栈，然后我们会从新线程运行，它会擦除那个，然后我们会返回到 yield，它会擦除那个，我们再回到
    while 循环中，然后我们会重新做一遍。好吧。所以如果你明白我刚才说的，思考这个问题的方式是，一旦。
- en: we swap S and T， S is like in the Twilight Zone frozen。 And as soon as we swap
    back。 S just picks up with that return just like I said because， of the way we
    did this。 We made it clean enough that as soon as we swap back to S， it's really
    just like this。 where we return and go back up the stack。 Okay。 Anybody else？
    Yes。 So no。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交换了 S 和 T，S 就像是被冻在了《暮光之区》。当我们交换回来时，S 就像我说的那样，直接从返回处继续，因为我们做得足够干净，一旦我们切换回 S，它真的就像这样，我们返回并回到堆栈中。好吧。还有别人吗？是的。所以没有。
- en: run new thread does not restart from A。 So remember the reason， excuse me， the。
    constraints of this example were that S and T have been running for a long time。
    So T at the point here where we switched to T， T was running before。 And so its
    stack is already like that。 So we're returning to switch not to A。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新线程并不会从 A 重新开始。所以记住，抱歉，嗯，这个例子的限制是 S 和 T 已经运行了很长时间。所以在我们切换到 T 时，T 之前已经在运行了。所以它的堆栈已经是那样了。所以我们是返回到
    switch，而不是返回到 A。
- en: So we return to switch and we return our way back。 up and come back down again
    and return our way back up。 Okay。 This is probably the hardest slide that I'll
    cover in this class。 So it's kind of， kind of。 and I'm going to show you a really
    funny quote in just a little， bit about understanding this。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们回到 switch，然后我们回到我们的路上，往上走，再下来，回到我们的路上，往上走。好吧。这可能是我在这堂课上讲的最难的一张幻灯片。所以它有点，嗯，我很快会展示一个很有趣的引用，帮助你理解这个。
- en: Go ahead。 Right。 So when it's， when we take S all the way down to switch， the
    question was。 and then go， somewhere else， does a suspended thread always look
    exactly like this？ Yes。 Well。 except， I mean， it has to be running this code，
    which， you know， I don't think any of。 you are going to run that code because
    it's boring， but you get the idea， it'll always。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吧。对。所以当我们把 S 完全带到 switch 时，问题是。然后去别的地方，悬挂线程总是看起来像这样吗？是的。嗯，除了，我的意思是，它必须运行这段代码，你知道，我不认为你们任何人会运行那段代码，因为它很无聊，但你明白我的意思，它总是会。
- en: have switch at the very bottom of the stack。 Good。 Okay。 Okay。 Do I dare move
    on？ Yes。 When。 when the kernel calls switch here， all it's doing is it's swapping
    switch swaps the。 registers and then you return from switch， but when you return，
    you've already swapped。 to the different stack。 So when you， as soon as you call
    switch here and then you start returning。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈的最底部有 switch。很好。好的。好的。我敢继续吗？是的。当。嗯，当内核调用 switch 时，所有它做的事情就是交换寄存器，然后你从 switch
    返回，但当你返回时，你已经交换到了不同的堆栈。所以当你在这里调用 switch，然后开始返回时。
- en: you're actually， in a different thread and you return back up that stack。 So
    you haven't changed code any， you're running the same switch code。 It's just here
    in a different stack at that point。 Spooky。 Okay。 Yes。 It's not going to the switch
    code。 It's the same switch code。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上是在一个不同的线程中，然后你回到堆栈中。所以你没有改变任何代码，你运行的还是相同的 switch 代码。只是那时它出现在不同的堆栈中。吓人。好吧。对。它不是去切换代码。它是相同的切换代码。
- en: but it's done as it's changed the stack。 So when the same switch code hits return。
    it does something else than it was going to do， if it stayed on S。 Yes。 Ah。 why
    don't you hold that question for a moment。 That's a good question。 How do we know
    where T is？
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但它已经改变了堆栈。所以当相同的 switch 代码遇到返回时，它做的事情就和留在 S 上时不一样了。是的。啊，为什么不暂时保持这个问题。那是个好问题。我们怎么知道
    T 在哪里？
- en: Okay。 So let me give you guys give me permission to go on the next slide here。
    So let's。 let's just go for a little bit here。 The other thing I wanted to recall
    is exactly what we just did with yield works fine with。 timer interrupts as well。
    So the timer interrupts an involuntary yanking of you from user mode into kernel
    mode。 but， notice that run new thread and switch are down at the bottom。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么让我给你们授权继续到下一张幻灯片。我们继续一下。另一个我想提醒的事情是，**yield**的使用方法同样适用于定时器中断。定时器中断是将你从用户模式强制切换到内核模式的操作。但是，请注意，**运行新线程**和**切换**是在底部的。
- en: And so really at this point it'll switch to TRS or whatever else is ready。 Okay。
    And the other thing we talked last time， which I didn't put back here is how do
    you start。 a thread from scratch？ You got to set up the stack so that when switch
    goes to it。 it thinks it's going to a switch， it's a thing that's running， but
    when it goes to it and returns。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这一点，处理器将切换到TRS或其他已准备好的模式。好的。另一个我们上次讨论过的，但我没有放在这里的是，如何从零开始启动一个线程？你必须设置栈，以便当切换到它时，它认为它是在进行切换，这是正在运行的任务，但当它进入并返回时。
- en: it actually starts with， red running。 Okay。 So it's a simple paradigm across
    a whole bunch of things。 Okay。 So the question is also in the， in the chat here，
    but even if thread T's not run， will we。 still switch back to S given that we
    will start thread T first？ Yes。 So if we were in a situation where T hasn't run
    yet and we did this， what had really happened。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上是从红色运行开始的。好的。这是一个贯穿多种操作的简单范式。好的。所以这里的问题也在聊天室里提到了，即使线程T没有运行，我们是否仍然会切换回S，假设我们会先启动线程T？是的。如果我们处于一个T尚未运行的情况，并且我们进行了此操作，那么实际上发生了什么？
- en: is that's the one instance where switching to it will start from A and run the
    way through。 because we've set it up as a stub and then it'll look like this from
    that point on。 Okay。 I'm going to， I'm going to move forward here。 So on this
    is basically the idea of how we get the scheduler control so that we run。 run
    new thread regularly enough to swap things and make a decision about what to do。
    Okay。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是切换到它并从A开始执行的唯一实例，并且会一直运行到结束。因为我们已经将其设置为一个存根，并且从那时起它会看起来像这样。好的。接下来，我将继续前进。这基本上是我们如何控制调度器的概念，以便我们能够定期地运行新线程并做出决定。
- en: And that's for a whole nother lecture。 Okay。 Now， I wanted to give you a little
    grounding here in actual reality。 So if you were to look inside Pintos， there
    are， there's an x86 processor code there for。 handling x86。 And really this idea
    of there's a kernel stack that gets swapped in as soon as you go。 into kernel
    mode， all of that stuff is supported directly by the x86 registers。 So for instance。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容是另外一堂课的内容。好的。现在，我想给你们提供一些实际的基础。如果你查看Pintos内部，会看到有x86处理器代码用于处理x86相关操作。实际上，这个概念中有一个内核栈，一旦进入内核模式，就会交换到该栈，所有这些操作都由x86的寄存器直接支持。例如：
- en: there's a TSS that's been set up for exceptions and for the processor， level
    zero。 which is a kernel， you put a stack in there so that as soon as you go into，
    the kernel。 that's the stack that gets swapped in。 Okay。 And you'll see that code
    if you start looking at things like TSS dot C and inter stub dot。 tap S。 Okay。
    And so once we get into the kernel， what do we do？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为异常和处理器设置了一个TSS，这个TSS属于处理器的零级（内核级）。你放置一个栈，这样一旦进入内核，它就会交换到那个栈。好的。如果你开始查看像TSS.c和inter_stub.tap
    S这样的文件，你将看到相关代码。好的。那么，一旦我们进入内核，我们该做什么？
- en: We've swapped or we've saved the user's stack and program counter。 We've put
    in the kernel stack and， and a program counter。 And so really this craziness here
    going from blue to red is really using in our case in。 Pintos the features of
    x86 that automatically switch the stacks for us when we make that transition。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经交换了，或者说保存了用户的栈和程序计数器。我们把它们放入内核栈和程序计数器中。所以，实际上这里从蓝色到红色的这一切疯狂的过程，实际上是在使用我们Pintos系统中的x86特性，它能在我们进行模式切换时自动切换栈。
- en: because SIS calls a type of exception。 It's like an interrupt， just like whatever。
    So we have to have preset that up in the kernel so that that switch will happen。
    Okay。 And。 and then when you return out of the kernel and back， that same part
    of the hardware in。 x86 will restore the user's program counter and stack。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为SIS调用是一种异常。它就像中断一样，无论是什么。因此我们必须在内核中预设好，以确保这种切换会发生。好的。当你从内核返回并回到用户模式时，x86的相同硬件部分会恢复用户的程序计数器和栈。
- en: So that's why I go to the trouble or the non trouble of just making this look
    like really。 we're just doing a function call into the kernel。 Okay。 So the user
    stack is growing but when we went from blue to red it was a different stack。 But
    once you've got that set up， you don't have to think about that。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是为什么我会费心或不费心地让它看起来像真的。我们只是在做一个函数调用进入内核。好的。因此，用户栈在增长，但当我们从蓝色变到红色时，它是一个不同的栈。但一旦你设置好这一切，你就不需要再去考虑它了。
- en: You're just procedure calling into the kernel and you're doing stuff and then
    you return。 back out of the kernel。 That little transition is handled by x86 hardware
    for you guys and a lot of other processors。 It's more software related but I want
    you to get to where you're just thinking like your。 procedure calling into the
    kernel and back。 Okay。 So for instance， here's an example。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你只是在调用内核的过程，然后做一些事情，之后再从内核返回。这个小的过渡是由x86硬件为你们处理的，很多其他处理器也是如此。虽然这更多与软件相关，但我希望你能开始理解，就像是你在调用过程进入内核，再从内核返回。好的。例如，下面是一个例子。
- en: here we're running the code and we've got our， the user。 is happily running
    and remember every user thread is actually got a corresponding kernel。 thread
    and it's sitting here waiting。 Okay。 And what happens there is when there's an
    interrupt。 so notice that we have the CS， CIP， that's the code pointer or the
    instruction pointer and then we have a stack pointer。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们正在运行代码，用户也在愉快地运行，记住每个用户线程实际上都有一个对应的内核线程，它正坐在那里等待。好的。而发生的事情是，当有中断发生时，注意到我们有CS、CIP，也就是代码指针或指令指针，然后我们有一个栈指针。
- en: And as soon as we go across that， notice that what happened was the hardware
    switched us。 to the hardware's stack which is down here and the hardware's instruction
    pointer which。 has to do with whatever exception we did。 Okay。 And then at that
    point。 the original user's program counter and stack are actually pushed， onto
    the kernel stack。 Okay。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们跨越那个界限，注意到发生了什么，硬件将我们切换到了硬件的栈，这个栈就在这里，而硬件的指令指针则与我们做的任何异常相关。好的。然后，在那个时刻，原始的用户程序计数器和栈实际上被推送到了内核栈上。好的。
- en: So see what， see what we did there。 So here， here's the user's program counter
    and stack。 And as soon as we make this call into the kernel， those two registers
    are pushed on。 the stack automatically by the hardware。 And now we're set up with
    a program counter and a stack pointer from。 for the kernel。 And now we just keep
    procedure calling in the kernel。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以看看我们做了什么。这里是用户的程序计数器和栈。只要我们进行内核调用，这两个寄存器就会自动被硬件推送到栈上。现在我们就有了内核的程序计数器和栈指针。接下来，我们就继续在内核中进行过程调用。
- en: I had a lot of people ask on Piazza something like， why does the kernel need
    a stack？ Well。 for the same reason the user needs a stack。 Okay。 So you see it's
    got to have some place to put return values and local variables。 Okay。 So， and
    now there's also a page table base register which is going to be the same in。
    this simple instance。 But the fact that we're in the kernel means that the page
    table。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经有很多人在Piazza上问类似的问题，为什么内核需要栈？嗯，原因跟用户需要栈是一样的。好的。所以你看，它必须有地方来存放返回值和局部变量。好的。现在还有一个页表基址寄存器，在这个简单的例子中它是一样的。但我们处于内核模式意味着页表也会。
- en: we'll talk about this， in several lectures later。 But you can mark certain entries
    as only available to the kernel。 And so just by going into kernel mode， suddenly
    the kernel space is available to the kernel。 Okay。 Again， that's a hardware feature。
    All right。 And now we can run。 Okay。 This kernel is busy doing something interesting。
    Maybe it's a read system call or something。 Okay。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的几节讲座中讨论这个问题。但是你可以将某些条目标记为仅对内核可用。因此，只需进入内核模式，内核空间就会突然对内核可用。好的。再说一次，这是一个硬件特性。好了，现在我们可以运行了。好的，这个内核正在忙于做一些有趣的事情。也许它正在执行一个读取系统调用之类的操作。好的。
- en: And then we're getting ready to resume。 And so at that point。 what we're going
    to have to do is undo what we did over here。 which is we got to restore the program
    counter and stack。 Okay。 And that'll be done by this interrupt return。 And now
    we're back running off of the user stack。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们准备恢复。此时，我们需要做的就是撤销我们在这里所做的工作，也就是我们必须恢复程序计数器和栈。好的。这将通过中断返回来完成。现在我们又回到了用户栈上运行。
- en: Question， yes。 Yes。 Now， what's the notion of atomic atomic means uninterruptible。
    And we'll talk about that in a moment。 So saying it does it atomically doesn't
    mean that it's all in one cycle necessarily。 but， it means it's not interruptible。
    Okay。 But it turns out that there are a lot of things much simpler than x86 that
    don't have that。 level of sophistication。 And you don't， there's， there's a small
    set of things you actually need to do atomically。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 问题，是的。是的。现在，原子（atomic）这个概念是什么意思？原子意味着不可中断。我们稍后会讨论这个。所以说它是原子操作并不意味着它一定是在一个周期内完成的，但它意味着它是不可中断的。好吧。但是，事实证明有很多比x86更简单的东西，并没有那么复杂。你不需要做的事情其实只有少数几个需要原子操作的部分。
- en: and the rest of them you could do in software。 Okay。 But I think this is an
    easy way to think about this for now until you get comfortable with。 these ideas。
    Okay。 There's another question。 Yeah。 Good。 How does the hardware know the address
    of the kernel stack？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的可以在软件中完成。好的。但我认为现在把它当做一种简单的方式来理解这些内容，直到你对这些想法感到熟悉。好的。还有其他问题吗？是的。好的。硬件怎么知道内核堆栈的地址？
- en: The answer is if you look in these things， there's called a TSS trap segment
    register that。 actually you put that you store the kernel stack in it so that
    when the hardware does。 do that transition， it knows where to get it from。 And
    you'll be able to look at the C code to see that how that sets up。 Good question。
    Okay。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，如果你查看这些东西，你会看到有一个叫做TSS（陷阱段寄存器）的寄存器。实际上，你会将内核堆栈存储在这个寄存器中，这样当硬件执行转换时，它就知道从哪里获取它。你可以查看C代码，看看它是如何设置的。好问题。好的。
- en: So the kernel stack is preset when you're boot up。 Not quite。 What happens is
    the kernel stack needs to be preset when you switch to a new thread group。 Remember。
    every user threads got a kernel stack。 And so when the scheduler switches。 it's
    going to have to change that out。 Okay。 But essentially you're doing that in advance
    before you return back to user mode。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以内核堆栈是在启动时预设的。还不完全正确。发生的事情是，当你切换到一个新的线程组时，内核堆栈需要被预设。记住，每个用户线程都有一个内核堆栈。所以，当调度器进行切换时，它需要改变这个堆栈。好的。但基本上，你是在返回用户模式之前提前完成这个操作。
- en: Yes。 Which I think is where you're going with that。 Go ahead。 Right here。 Now。
    you were so it's not got its own registers。 It's got its own register values。
    Okay。 So， you know。 it's got its own processor。 And when we do this transition。
    what happened here was the hardware put in the program counter， and stack pointer
    for the kernel。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我想这就是你想要说的。继续。就在这里。现在，你说它没有自己的寄存器。它有自己的寄存器值。好吧。所以，你知道，它有自己的处理器。当我们进行这个转换时，发生的事情是硬件将程序计数器和堆栈指针加载到内核。
- en: And then it also saves the users stuff on that kernel stack。 Okay。 Now。 not
    all hardware does that for you。 X86 does it that way。 Okay。 And that means that
    now we're just running away lower in the stack。 Remember how I had red stuff that
    went down further？
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它还会将用户的内容保存在那个内核堆栈中。好的。现在，并不是所有硬件都会为你完成这个操作。x86硬件是这样做的。好的。这意味着我们现在正运行在更低的堆栈层次。记住，我曾提到的那些红色的内容是更往下的部分吗？
- en: And it was when we return enough that we get back to this point where we do
    an iret。 And there we restore from here off of the stack， we restore the registers
    back to run。 Now the only registers that are affected by this are the ones that
    absolutely get trashed。 when you go into the kernel， namely the program counter
    and the stack pointer。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们返回足够多时，我们会回到这个点，这时会执行iret指令。在这里，我们会从堆栈恢复数据，将寄存器恢复到运行状态。现在，唯一会受到影响的寄存器是那些在进入内核时会被彻底清除的寄存器，即程序计数器和堆栈指针。
- en: It's going to be up to the kernel to save and restore everything else。 Okay。
    So you have to do that correctly。 Good。 Anybody else？ Okay。 Go ahead。 So the page
    stable base register is shared between the kernel and the user because you。 can
    mark entries as only being available to the kernel。 Okay。 Now。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将由内核来保存和恢复其他所有内容。好的。所以你必须正确地执行这个操作。很好。还有其他人吗？好的。继续。页面表基址寄存器在内核和用户之间是共享的，因为你可以将条目标记为仅对内核可用。好的。
- en: at the risk of confusing everything here， I'm going to point out that there
    was some。 pretty crazy things that happened in 2017 where there was something
    called meltdown where。 they figured out how to yank things out of the kernel even
    though they weren't supposed， to。 We'll talk about it later in the term， but the
    net effect was that the number of things。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 冒昧地说，这里有一些可能让你困惑的内容，我要指出2017年发生了一些非常疯狂的事情，当时发生了一个叫做Meltdown的事件，研究人员发现即使不应该这样做，他们也能从内核中“拔出”某些东西。我们稍后在学期中会讨论这个，但它的最终效果是，受影响的事物数量。
- en: of the kernels that's in the user base table or user page table has to be very
    small。 And so today when you switch， you're going to have to actually switch to
    a different page。 table in general， but it used to be like this up until 2017。
    We'll talk much more about that。 Okay。 And I didn't want to go down that path
    yet。 I did want to show you this。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的栈位于用户页表中，这个表必须非常小。因此今天，当你切换时，你必须切换到不同的页表。通常来说，但直到2017年之前，它是这样的。我们稍后会详细讨论这个。好的，我现在不想走这条路。我想先给你展示这个。
- en: So here's a case where we're scheduling and we're going to do a context switch。
    Notice how there was an interrupt， but you only know that because I said there
    was one。 And we're at the same point here。 It looks almost identical to the way
    it was when we did a system call into the kernel。 But what's different is we're
    going to now schedule somebody new。 And at that point。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们正在调度的例子，我们将进行上下文切换。注意到发生了一个中断，但你之所以知道是因为我说了有一个。我们现在在同一点。它看起来几乎和我们做系统调用进入内核时的情况一样。不同之处在于我们现在将调度一个新的进程。到那个时候。
- en: we're scheduling by swapping in a new user thread， kernel stack pair， user，
    stack， kernel stack。 That's why things are green。 And notice the page table base
    registers is definitely different because this is potentially。 a different process。
    And then now we just do the return and now look。 we're running green instead of
    blue。 There we just scheduled。 Okay。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过交换新用户线程、内核栈对、用户栈和内核栈来调度。这就是为什么事情是绿色的原因。注意，页表基址寄存器肯定是不同的，因为这可能是一个不同的进程。然后我们现在就返回，看看，现在我们在运行绿色，而不是蓝色。我们刚才刚刚调度好了。好的。
- en: I'm going to let you ponder that for a moment。 I'm going to show you this in
    a that was kind of a time based thing。 This is more spatial。 So Pintos， the version
    that you start with only has one thread per process。 We actually let you change
    that a little bit later in the term。 But what does that mean？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我让你思考一下这一点。我将向你展示这个，这更像是一个时间相关的东西，而这更是空间相关的。所以Pintos，你开始使用的版本每个进程只有一个线程。稍后我们会让你在学期中更改它一点。那么这意味着什么？
- en: That means that kind of in a process， we've got the user mode here， which is
    below and。 below kernel modes above， so in user mode， there's code data heap stack
    for the user。 And then above is a kernel stack。 But in Pintos， that kernel stack
    is actually a whole page in size 4k and there's a chunk。 at the bottom of that
    page that is the TCB。 Okay。 So they actually put that on the bottom of the page
    and there's a spot to save the stack。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在一个进程中，我们有用户模式在这里，位于下方，内核模式在上方。所以在用户模式下，用户有代码、数据、堆、栈。然后在上面是内核栈。但在Pintos中，这个内核栈实际上是一个4K大小的整个页面，页面底部有一块区域是TCB。好的。所以他们实际上把它放在页面底部，还有一个位置来保存栈。
- en: pointer and that points to the top of the page。 So is this。 are we going to
    use the kernel stack to compute Fibonacci？ Why or why not？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 指针，它指向页面的顶部。那么，这样做是为了使用内核栈计算斐波那契数吗？为什么或为什么不？
- en: Anybody know why I'm asking？ Go ahead。 There you go。 This is an extremely limited
    stack size。 But the kernel screws up and does anything too recursive， it'll overwrite
    the TCB and it'll， be bad。 Okay。 Don't do that。 Okay。 Dr。 it hurts when I overwrite
    my stack。 Don't do that。 Okay。 So what I wanted to show you here is， for instance，
    if we're in a user thread and the。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有人知道我为什么问这个吗？继续。好吧。这是一个非常有限的栈大小。但内核会搞砸，如果做任何递归操作过深，它会覆盖TCB，这样就会很糟糕。好的，不要这么做。好的，博士，覆盖栈的时候很痛，别这么做。好的。所以我想给你展示的是，如果我们在用户线程中，
- en: kernel thread is not functional， but the kernel thread， a kernel threads really
    a stack。 that's paired up with the user thread， then we look like this where the
    instruction pointer。 which is the PC and the stack pointer are pointing into the
    user's space and we've loaded up。 the kernel stack pointer in that special register
    to point at where it's going to be swapped， in。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 内核线程没有功能，但内核线程，本质上是一个与用户线程配对的栈。我们看起来像这样，指令指针（即PC）和栈指针指向用户空间，而我们已经在那个特殊寄存器中加载了内核栈指针，指向将要交换的位置。
- en: So now we're happily computing Fibonacci here。 And if we make a system call。
    the hardware has enough information here to now swap in， the new kernel stack。
    which will be here and go ahead and save stuff。 Okay。 Now， here's a different
    thing to look at。 So notice this has got a kernel thread or kernel stack paired
    with the user thread or， user's stack。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们很高兴地在这里计算斐波那契数列。如果我们发起一个系统调用，硬件这里有足够的信息来交换进新的内核栈，新的内核栈会在这里，并继续保存数据。好吧。那么，接下来我们看另一个不同的情况。注意到这个有一个内核线程或者内核栈与用户线程或者用户栈配对。
- en: No， we've got some things over here with no user component。 There were a lot
    of questions on Piazza。 Well， does the kernel have threads that just do their
    own thing？ Yes。 So here's an example of threads that never go back to user mode
    or never had a user mode。 They run only in the kernel doing， you know， maintenance
    like stuff， flushing out blocks， the disk。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们这里有一些没有用户组件的东西。Piazza上有很多问题。那么，内核是否有只做自己事情的线程？有的。所以这是一个线程的例子，它们从不返回到用户模式，或者说它们从没有用户模式。它们只在内核中运行，做一些维护性的工作，比如刷新磁盘块。
- en: et cetera。 So the nice thing about this is the way we've set this up。 the kernel
    portion of these looks， identical regardless of whether it was a user thread or
    not。 And so the scheduler can schedule between these threads， all the ones that
    have different。 user code associated with them and kernel code。 It's all the same。
    Okay。 What is it？ Well。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。这个设置的好处是，正如我们所设置的那样，内核部分看起来是相同的，不管它是用户线程还是不是。所以调度器可以在这些线程之间调度，这些线程都有不同的用户代码和内核代码。它们是一样的。好吧。那是什么？嗯。
- en: let's look。 Here we go。 We're running inside the kernel。 Okay。 On a kernel thread。
    And here in that case， the program counter and the stack pointer are pointing
    inside the。 kernel and we never return back to where we're pointing at user space。
    Yes。 I see。 Well。 can you see that？ Let's see。 Oh， I guess that， oh， my pointer
    isn't showing up on the screen。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个。我们正在内核中运行。好吧。在一个内核线程上。在这种情况下，程序计数器和栈指针指向内核中，我们永远不会返回到指向用户空间的地方。是的，我明白了。你能看到吗？让我们看看。哦，我的指针似乎没显示出来。
- en: I apologize。 So what I'm referring to here is I'll have to figure out how to
    do that。 But let's see。 Is this laser pointer work？ Let's check this。 Let's try
    this。 Ooh， there we go。 How's that？
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我很抱歉。那么我在这里提到的是，我得想办法怎么做。但我们看看。激光指示器工作吗？我们检查一下。试试看。哦，有了。怎么样？
- en: That's a lot bigger than invisible。 So okay。 So what I'm talking about here。
    thank you for pointing that out， is in this case， notice。 that this is the user's
    stack and we're running over here and the hardware has the kernel stack。 set up
    so that when we make a system call in， we will use that stack。 But in this case。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比不可见的要大得多。所以好吧。那么我在这里讲的内容，谢谢你指出这一点，就是在这种情况下，注意到，这是用户的栈，我们在这里运行，硬件有内核栈设置，当我们发起系统调用时，我们会使用那个栈。但在这种情况下。
- en: we're already running with this stack and notice how the stack pointer。 is pointing
    inside that stack and of course the instruction pointer is pointing in the。 kernel
    code somewhere。 That's an instance of just running something that's going to stay
    in the kernel。 And so now as long as we have a way to switch between the different
    kernel threads with。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这个栈上运行，注意栈指针指向栈内，当然指令指针指向内核代码中的某个位置。这是一个运行在内核中的实例。所以现在，只要我们有办法在不同的内核线程之间切换。
- en: the scheduler， then we'll automatically give CPU time to both the user's threads
    and the。 kernel threads and now the scheduler can do whatever it wants。 Okay，
    which gets us back to policy。 So this is why people call the second half of a
    user thread a kernel thread。 I'm a little bit conflicted as to whether I like
    that terminology。 From this slide。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调度器会自动将CPU时间分配给用户线程和内核线程，现在调度器可以做任何它想做的事。好吧，这就把我们带回了策略的问题。所以这就是为什么人们称用户线程的后半部分为内核线程。我对于是否喜欢这种术语有点犹豫。从这一张幻灯片来看。
- en: it makes perfect sense but oftentimes it's confusing people。 So the other thing
    is just， you know。 every user's stack has a kernel stack。 Okay。 Now we can go
    further with this。 Here's an example of that original thread that just took a
    system call and notice in， this instance。 what's happening is， I don't know if
    you noticed， let's see， here， there。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全可以理解，但常常让人困惑。所以另一件事是，知道每个用户栈都有一个内核栈。好吧。现在我们可以进一步讨论这个。这里是那个原始线程的例子，它刚刚发起了一个系统调用，注意在这个实例中。发生的情况是，我不知道你是否注意到，看看这里，那里。
- en: was really nothing where at the top of the stack， when we get here， we've actually
    pushed。 the user's registers on that kernel stack and now we're busy running into
    kernels。 That would be the example of a system call to do a read。 We're now running
    on that stack。 And then when we return back， we returned across that boundary，
    we're back at the user， level。 Okay。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈顶实际上什么都没有，当我们到达这里时，实际上我们已经将用户的寄存器压入了那个内核栈，现在我们正在内核中运行。这将是一个进行读取的系统调用示例。我们现在正在那个栈上运行。当我们返回时，我们穿越了那个边界，回到了用户层级。好吧。
- en: Now， what does Pintos look like？ Let's see if I can turn this off now without
    too much challenge。 Let's see， what if I just， oh， turned it off。 Let's see， okay，
    no。 Good。 All right， here。 now experts。 So here， let's look briefly at Pintos
    interrupt processing。 So here we have the hardware vector， which when a hardware
    interrupt， such as the timer。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Pintos是什么样的呢？让我看看能不能在不太费劲的情况下关掉它。让我试试，如果我只是，哦，关掉它。好吧，没关系。很好。好了，这里。现在专家们。让我们简单看一下Pintos的中断处理过程。这里我们有硬件向量，当发生硬件中断（比如定时器）时。
- en: which is OX20， that's 32， happens， it goes to a vector set up by the kernel
    that says。 run these instructions。 And those instructions could be unique to the
    vector， but in fact。 in Pintos， what happens， is they just push which interrupt
    it was on the stack and then they call common code。 which saves all the rest of
    the registers。 Remember how I said you have to save all the users' registers。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是OX20，等于32，发生了，它进入了由内核设置的向量，告诉我们执行这些指令。这些指令可能是特定于该向量的，但实际上，在Pintos中，发生的情况是，它们只是把中断的类型压入栈中，然后调用公共代码。这段代码保存了其他所有寄存器。记得我说过，你需要保存所有用户的寄存器。
- en: but the kernel only saves， two of them。 So that's the code that saves them all，
    set up the computer。 the kernel environment， calls， the interrupt handler itself，
    okay。 and that's going to run something to do with the timer。 So here we have
    a situation where we're going to go user to kernel with an interrupt vector。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但是内核只保存了其中的两个。所以这段代码保存了它们所有，设置计算机、内核环境，调用中断处理程序本身，好吧。这将运行与定时器相关的某些操作。所以在这里，我们有一个从用户到内核的中断向量情况。
- en: Here's the interrupt vector。 It points the parts in the code。 And when we get
    that interrupt。 we actually transfer here， and again， I got to show you， this
    laser pointer。 So here again。 after the interrupt， now we've got stack pointer
    and thread running in there。 and we could go ahead and schedule and switch to
    a different stack if we wanted to， just。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是中断向量。它指向代码中的各个部分。当我们接收到中断时，实际上会转移到这里，我得给你们展示一下这个激光指针。所以这里，经过中断后，现在我们有了栈指针和正在运行的线程，并且如果我们想的话，可以继续进行调度并切换到另一个栈。
- en: like with a system call， we could schedule and go to a different stack。 So going
    in there and interrupt， going in with a syst call， whatever， it all looks the。
    same at the kernel level， and that's why it's easy to schedule。 Okay。 So I don't
    want to go too much longer on this because we'll run your brains。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在系统调用中，我们可以进行调度并切换到不同的栈。所以，进入那里并处理中断，进行系统调用，无论如何，在内核层面看起来都一样，这就是为什么调度很容易的原因。好吧，我不想再继续讲下去了，因为这会让你们的大脑爆炸。
- en: We'll start turning into mush， but I did want to point out that once we get
    to this point。 we call the interrupt handler， and that interrupt handler then
    goes ahead and does another dispatch。 inside a pintos of， well， what do I actually
    do with the timer？ And that point。 the timer calls tick and then thread tick，
    which potentially does nothing， in return。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始变得一团糟，但我确实想指出，一旦我们到达这一点，我们调用中断处理程序，然后该处理程序会继续进行另一次调度，在Pintos内部，嗯，我究竟该如何处理定时器？到那时，定时器调用`tick`，然后`thread
    tick`，这可能什么也不做，最后返回。
- en: The timer can go off some number of times and the codes keeps going。 Okay。 or
    thread tick could yield call thread yield， in which case we're going to schedule。
    And in that case， we just switch to another thread by swapping out the instruction
    pointer。 and the stack pointer。 And now when we return back up the path。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器可以触发若干次，代码会继续执行。好吧，或者线程的时钟滴答可能会调用`thread yield`，在这种情况下，我们将进行调度。此时，我们只需通过交换指令指针和栈指针来切换到另一个线程。当我们返回时，回到路径上。
- en: we're now running on this other thread。 So there was s and t。 Okay。 Now。 I'm
    going to let you guys play with that a little bit more on your own， but I wanted。
    you to see this is kind of like the spatial version of all this。 Okay。 Oh， in
    the back。 Yeah。 go ahead。 So the kernel， there is only one TCB。 That's this kind
    of off colored tan thing。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在另一个线程上运行。所以是s和t。好了，现在，我将让你们自己再玩一下这个，但我想让你们看到这就像是所有这些的空间版本。好了，后面。是的，请继续。所以，内核中只有一个TCB。这就是那种偏黄的颜色。
- en: And so that TCB， when you're going to switch to some other kernel thread or
    some other thread。 that's when you save stuff in that TCB。 And so for the kernel
    that's running in the kernel thread。 it just saves it here。 If we're in a user
    thread and we go into the kernel and then we're going to switch to some。 other
    user thread， we also just save our registers into that TCB and then we swap over。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你要切换到其他内核线程或其他线程时，TCB就在这里保存一些信息。因此，对于在内核线程中运行的内核，它只是在这里保存信息。如果我们在用户线程中，然后进入内核，再切换到其他用户线程时，我们也只需将我们的寄存器保存到该TCB中，然后进行交换。
- en: So there's one place。 Good。 Good question。 Yes。 So the kernel does not share
    the same。 So the kernel has access to a whole bunch more stuff than the user does。
    So yeah。 so address space is the set of all addresses and their mappings。 Okay。
    So from that standpoint。 I would say the user's address space is augmented by
    the kernel's。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有一个地方。好的，问题很好。是的。所以内核和用户并不共享相同的。内核能访问的东西比用户多得多。所以，是的。地址空间是所有地址及其映射的集合。好的，从这个角度看，我会说用户的地址空间是通过内核的地址空间来增强的。
- en: address space when you go into the kernel。 So the kernel's address space has
    more stuff in it。 Same number of addresses。 But most of them in the user case
    are not available。 but when you go into the kernel， they're now available。 So
    one thing you could think of that is address space prime or it's a little， when
    you go into。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进入内核时，内核的地址空间包含更多内容。地址的数量相同。但在用户模式下，大部分地址是不可用的，但当你进入内核时，它们现在是可用的。所以你可以认为这是地址空间的“增量”，或者当你进入时，它稍微有所不同。
- en: the kernel， it's a much bigger set of active addresses。 As I just mentioned。
    they can be sharing the same page table， but that page table， most。 of it is turned
    off when you're in the user mode。 Because it's because there is only one kernel。
    Remember， that's our new mantra。 There is only one kernel。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 内核，它的活跃地址集更大。正如我刚才提到的，他们可以共享同一个页表，但当你处于用户模式时，大部分页表是关闭的。因为只有一个内核。记住，这是我们的新口号：只有一个内核。
- en: And the kernel space that's mapped when you're in the kernel is the same for
    everybody。 They have all access to everything。 It's just when you go into user
    space。 you have a much more restricted access to things， and it's a smaller subset。
    Okay。 Good。 So we're not tied up on a dress basis。 All right。 This I wanted to
    give you before we close。 Okay。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在内核中时，内核空间是映射的，对每个人来说都是一样的。他们可以访问所有东西。只是在进入用户空间时，你对事物的访问受到更严格的限制，并且只是一个较小的子集。好的，明白。所以我们并没有被地址限制住。好了，这个我想在我们结束前给你们讲一下。
- en: Dennis Ritchie， one of the founders of Unix wrote the following comment in scheduler
    code。 just like what runs we just said。 It says， if the new process paused because
    it was swapped out。 set the stack level to， the last cell to save you of u_ss。
    AVE。 This means that the return。 which is executed immediately after the call
    to our ARETU actually， returns from the last routine。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Dennis Ritchie，Unix的创始人之一，在调度器代码中写下了以下注释。就像我们刚才所说的那样。它写道，如果新进程因被换出而暂停，设置栈级别为，最后一个单元用来保存u_ss。AVE。这意味着返回。也就是在调用我们的ARETU之后立即执行的返回，实际上是从上一个例程返回。
- en: which did the save u。 You are not expected to understand this。 That's my favorite
    quote in any kernel or anywhere。 Okay。 So， however。 I expect you to understand
    what we just talked about。 But if you're finding it challenging。 just keep in
    mind what Dennis Ritchie wrote inside， Unix。 Okay。 So just give that。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了保存u。你不需要理解这个。这是我在任何内核或其他地方最喜欢的引述。好了，所以，然而。我希望你们理解我们刚刚讨论的内容。但如果你们觉得有挑战性，记住Dennis
    Ritchie在Unix中写的内容。好了，就这么办。
- en: give yourself a little bit of a break there。 Question。 So， okay。 So， okay。 They
    do get saved in the TCB。 When I go into the kernel， see， you see this here。 this
    saves all the registers once we， get kind of into the kernel。 But the registers
    we need to save immediately are really the， let's go back to where I want。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 给自己稍微休息一下。问题。所以，好吧，它们确实会保存在TCB中。当我进入内核时，你看，看到这里了吗？这会在我们进入内核时保存所有寄存器。但我们需要立即保存的寄存器实际上是，嗯，回到我想要的地方。
- en: to go back to here。 The registers we need to save immediately on getting into
    here are the users PC and stack。 pointer and so on。 And they get pushed on the
    stack。 That's why this guy now has two kind of has entries on there。 That's where
    the user's stuff is pushed。 So， when you call into the kernel and you push the
    user's stuff on the kernel stack and。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这里。我们在进入这里时需要立即保存的寄存器是用户的PC和栈指针等等。它们会被推送到栈上。这就是为什么这个家伙现在有两个条目的原因。那是用户的东西被推送到那里。所以，当你调用内核时，你将用户的东西推送到内核栈上。
- en: then you just keep going。 Also to the kernel stack。 Everything's pushed to the
    kernel stack。 By the kernel does the， everything but the program counter and the
    stack pointer。 All gets pushed。 Best way to think about red and blue and red stacks
    is it's just the procedure call and。 we clean up the mess between kernel and user
    but it's all just procedure calling its way。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你继续进行。也推到内核栈上。一切都被推到内核栈上。由内核完成，除了程序计数器和栈指针。所有东西都被推送。理解红栈和蓝栈的最好方式是它们只是过程调用。我们清理内核和用户之间的杂乱，但这只是过程调用的过程。
- en: through and coming back。 Okay。 Good。 Yes， one go ahead。 I mean， where did this
    guy come from？
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番讨论后，回到原点。好的。没错，一个继续。我是说，这家伙是从哪里来的？
- en: Actually， let me just go to the last。 Oops。 And then we do want to move on a
    little bit so we have other things to talk about today。 But if you look here。
    This is set by the kernel in kernel space and the hardware knows where to look。
    Okay。 All right。 Okay。 Let's， let's move on。 So， if you're finding it challenging，
    that's okay。 It is challenging， but we're going to make sure you understand it
    because I， I believe you。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，让我直接跳到最后。哎呀。然后我们确实想继续一点，因为今天我们还有其他事情要讨论。但如果你看这里。这是由内核在内核空间中设置的，硬件知道在哪里查找。好吧。好吧。好了，咱们继续。如果你觉得有挑战，那没关系。它确实有挑战性，但我们会确保你理解，因为我，我相信你。
- en: all can understand that。 Okay。 I believe in you。 So today we want to now talk
    about。 so we've got mechanism for switching between threads。 Woo hoo。 Mechanism。
    The problem is if you go ahead and use that and you do it unwisely， that concurrency
    can。 kill you from a functionality and correctness standpoint。 Okay。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有人都能理解这一点。好吧。我相信你们。那么今天我们要讨论的是……所以我们有一个机制可以在线程之间切换。哇哦，机制。问题是，如果你继续使用它，而且不明智地使用，这种并发可能会从功能性和正确性角度**杀死**你。好吧。
- en: And so we're going to have to start understanding why it's a problem and what
    to do about it。 All right。 You guys ready？ This， by the way， is my favorite Sunday
    cartoon from Dilbert way back in the day。 And it's sort of a， a point at which
    the boss asks everybody around the table。 So tell me about your project。 And one
    guy， the first guy says， my project， the whole new paradigm。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们得开始理解为什么这是个问题，以及该怎么做。好了，大家准备好了吗？顺便说一句，这是我最喜欢的《Dilbert》漫画，来自以前的某个星期天。它是一个点，老板问桌子周围的每个人。所以告诉我你们的项目怎么样。然后第一个人说，我的项目，整个新的范式。
- en: And then there's all this， well， what's a paradigm mean？ And， oh， you know，
    paradigm， paradigm。 you know， as in my project， the whole new paradigm。 And then
    the rest of the frames are， yeah。 mine's a new paradigm too。 And so is mine。 It's
    so is mine。 So， all right。 So we're going to teach you a new paradigm today。 Okay。
    So if you remember。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有这一切，嗯，什么是范式的意思？哦，你知道，范式，范式。就像我的项目，整个新的范式。然后其余的框架是，嗯，我的也是一个新范式。我的也是。我的也是。所以，好吧。今天我们要教你一个新的范式。好吧。所以如果你记得的话。
- en: we kind of gave you this slide where we talked about how the scheduler。 can
    give you lots of different schedules。 Okay。 If we have A， B and C threads， then。
    and we happen to have a bunch of cores and it's， possible they're actually running
    in parallel。 That's what that first thing looks like。 That's multiprocessing。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大致给了你这张幻灯片，讲述了调度程序如何给你很多不同的调度。好吧。如果我们有A、B和C线程，那么。如果我们碰巧有一堆核心，那么它们实际上是并行运行的。这就是第一个样子。这就是多处理。
- en: The other option is a scheduler is going to be switching between them。 And we
    just spent a lot of time talking about how that switch could work mechanistically，
    right？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是调度程序将在它们之间切换。我们刚刚花了很多时间讨论这个切换是如何机械地工作的，对吧？
- en: How you save registers here and do that。 But the key thing to get from here
    is the fact that the scheduler could run A for a little。 bit than B， then C and
    it could run A for longer and then B or it could run A to completion。 You don't
    know what the scheduler is going to do。 So any code you write that's multi-threaded
    better work no matter what the scheduler does。 Okay。 This is by the way， Kubi's
    malicious scheduler rule number one， assume the scheduler will。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何保存寄存器并执行这些操作。但这里需要理解的关键点是，调度程序可能先运行A一段时间，再运行B，然后是C，或者它可能运行A更长时间，然后是B，或者它可能让A执行到底。你不知道调度程序会做什么。因此，任何你写的多线程代码都必须能在调度程序做任何事情的情况下都能正常工作。好吧。顺便说一下，这是Kubi的恶意调度器规则第一条，假设调度程序会。
- en: find the bug in your code and exploit it in the worst possible way and it will
    have to。 be at 335 in the morning。 Okay。 I have other versions of that rule which
    are a little bit less restrictive on to what。 time it is， but you get the idea。
    So keep this slide in mind。 anytime you're designing parallel threaded code， you've
    got。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 找到你代码中的bug，并以最坏的方式利用它，它必须出现在早上3:35。好吧。我还有其他版本的规则，时间限制没有那么严格，但你明白了。设计并行线程代码时，始终记住这张幻灯片。
- en: to realize that it better work no matter what the scheduling is。 Okay。 So let's
    go to a particularly simple example。 Here's a bank server。 These funny symbols
    I've got here represent ATM machines。 Okay。 You can give me a little bit of benefit
    of it out there。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要意识到，不管调度方式是什么，这段代码都必须能够正常工作。好吧。我们来看一个特别简单的例子。这里是一个银行服务器。这些我在这里画的有趣符号代表ATM机。好吧，你可以在外面稍微享受一下这个小小的好处。
- en: We've got some mainframes at the central bank。 And the idea is that lots of
    people can be withdrawing money and you know there's all。 these requests to go
    to the central bank and back。 Okay。 So there's lots of parallelism possibilities。
    Now suppose you want to build the server and so what you might have something
    like this。 there's a big loop while true。 You receive a request information in
    the process the request。 Okay。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在中央银行有一些主机。这个概念是，很多人可以同时取款，你知道有许多请求需要往返于中央银行。好吧，所以这里有很多并行处理的可能性。现在假设你要构建这个服务器，那么你可能会有类似这样的代码：一个大的循环，`while
    true`。你接收请求信息并处理请求。好吧。
- en: And so what does process request mean？ Well depending on if the op is a deposit。
    it does the deposit function， otherwise that， it up。 And the deposit function
    does something like well get the account from the ID and then。 take the account
    balance and add some amount to it and then store the result back into， the account。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，处理请求是什么意思呢？好吧，根据操作是否是存款，它就执行存款功能，否则就执行其他操作。而存款功能的实现大致是这样的，首先从ID获取账户，然后取出账户余额，加上存入的金额，然后将结果存回账户。
- en: And first of all， you could clearly code like this。 I guess。 Okay。 And I've
    left out all the details about you know， what does it mean to be storing money。
    and you know， how do you interact with the fed and all of those things， but we'll
    assume。 that those are not relevant。 What's wrong with this code？ One at a time。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以像这样清晰地编写代码。我猜是这样的。好吧。我省略了关于如何存储资金、如何与联邦储备互动以及其他那些细节，但我们假设这些内容不相关。那么这段代码有什么问题呢？我们一个一个来看。
- en: We got a lot of pissed off customers， right？ Because only one of them gets to
    get money at a time。 And so how do we speed this up？ Well we want to have more
    than one request going on at once。 Now I want to point out something here。 I've
    got these red may use disk IO things here。 And if you notice， these are things
    that could take arbitrarily long because it's got。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多愤怒的客户，对吧？因为只有一个客户能一次性取钱。那么我们该如何加速呢？我们希望能有多个请求同时进行。现在我想指出一点。我这里有这些标红的可能使用磁盘I/O的地方。如果你注意到，这些可能会花费非常长的时间，因为它涉及到。
- en: to go to a mechanical device。 And so if we wanted to speed things up and we
    only had one CPU。 it might be that we want， to make sure that whatever we do，
    we don't have users held up by disk IO。 Okay。 So when one user hits disk IO， the
    other one can make some progress and vice versa。 Okay。 And so we could do this。
    We could build an event driven thing。 Suppose we only have one CPU。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 去操作一个机械设备。所以如果我们想要加快速度，而只有一个 CPU，可能我们希望确保无论做什么，都不会让用户被磁盘 IO 阻塞。好的。所以当一个用户遇到磁盘
    IO 时，另一个用户可以继续执行，反之亦然。好的。所以我们可以这样做。我们可以构建一个事件驱动的系统。假设我们只有一个 CPU。
- en: We want to overlap IO。 And we have no threads。 And so what could we do？ Well。
    we could build the bank server like this， still while true。 We get the next event。
    But now an event is a part of something。 So a deposit has multiple events。 We
    look at deposit here。 We might have the get account event， the increment， the
    balance event， the store account， event。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要重叠 IO。而且我们没有线程。那么我们能做什么呢？嗯，我们可以像这样构建银行服务器，仍然是 `while true`。我们获取下一个事件。但是现在一个事件是一个过程的组成部分。所以一个存款有多个事件。我们看存款时，可能会有获取账户事件、增加余额事件、存储账户事件。
- en: whatever。 A bunch of sub pieces。 And at minimum， we need to make sure that we
    have a separate piece for kind of each slow。 thing。 Right。 So that while you're
    waiting for a slow thing to happen。 somebody else can be partially working， their
    way through the deposit。 Okay。 And this is called event driven。 And so it might
    look like this。 Great。 Get the next event。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，许多子部分。至少我们需要确保我们为每个慢速部分都有单独的处理。对吧？这样当你在等待某个慢速过程时，其他人可以部分地处理他们的存款。好的。这就是事件驱动。它可能看起来像这样。很好，获取下一个事件。
- en: If the event is a brand new request， then you start things。 Otherwise if the
    event is an account available event， you continue it。 And if it's a stored event。
    you finish it。 And each of these things do part of a whole deposit process。 Okay。
    And this is a very common thing for graphical programming。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件是一个全新的请求，那就启动它。否则，如果事件是账户可用事件，那就继续处理。如果是存储事件，那就完成它。每一个事件都完成存款过程的一部分。好的。这在图形编程中是一个非常常见的方式。
- en: So if any of you ever program games or whatever， you're going to build event
    loops like this。 where the event is wait for the next mouse click or wait for
    things to be drawn， whatever。 Okay。 And the complication here is the only way
    we get performance out of this is if we're very。 careful to always identify every
    slow piece so that when there's a slow piece， what happens。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你们中间有任何人做过游戏编程之类的，你们就会构建像这样的事件循环，其中事件是等待下一个鼠标点击或者等待某些东西被绘制出来，等等。好的。这里的复杂性在于，只有当我们非常小心地识别出每一个慢速部分时，我们才能从中获得性能，以便当出现慢速部分时，我们知道会发生什么。
- en: like this， where the way when we start the request， that's going to fetch something
    from， disk。 And so what we want to be able to do is have that start on request，
    start fetching， and。 then the event that comes back from that when it's finally
    back from the disk will be an。 account available event。 Okay。 And we can go through
    this and we can build it this way。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，当我们启动请求时，它将从磁盘获取某些东西。所以我们想要做的是，当请求启动时，开始获取数据，然后当从磁盘返回时，事件将会是一个账户可用事件。好的。我们可以通过这种方式来构建它。
- en: But if we miss one of these blocking steps， then things will still block and
    the whole。 system will grind to a halt。 But with careful analysis， you could do
    this。 Okay。 This is challenging for very complicated code， because if you notice
    what I've got here with。 the deposit， this is like really simple。 But imagine
    something complicated。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们错过了其中的某个阻塞步骤，那么系统仍然会被阻塞，整个系统会停滞不前。但通过仔细分析，你可以做到这一点。好的。这对于非常复杂的代码是一个挑战，因为如果你注意到我这里的存款，这其实非常简单。但想象一下，如果是复杂的情况。
- en: You got to split it in lots of little pieces。 This is probably not going to
    be your preferred way of programming complicated code。 Unless you're a really
    crazy game constructor and you want to make it fast， you might do。 it that way。
    Okay。 So let's do it using threads。 Okay。 One thread for request。 So now you've
    got 20 people standing at ATMs。 Each one gets a thread。 Okay。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须把它拆分成很多小块。这可能不是你编写复杂代码时的首选方式。除非你是一个非常疯狂的游戏开发者，并且想要让它运行得更快，你可能会这样做。好的。那么我们用线程来做吧。好的。每个请求一个线程。所以现在你有
    20 个人站在自动取款机前，每个人都获得一个线程。好的。
- en: And this is why threads are useful。 So the request proceeds to completion blocking
    is required。 So here we've got each thread does the get account， add to the balance
    store account。 Okay。 And now if that thread blocks or goes to sleep， somebody
    else will take over。 Okay。 So now without a lot of work， we've just decided to
    assign a thread to each user and it just， works。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么线程很有用。所以请求将继续执行，阻塞是必需的。所以在这里，我们每个线程执行获取账户、添加到余额、存储账户。好的。如果这个线程被阻塞或进入休眠，其他线程会接管。好的。所以现在我们不需要做太多工作，就可以为每个用户分配一个线程，它就能正常工作。
- en: Okay。 Except that does it work。 No， unfortunately it doesn't。 So for instance。
    what does it actually happen here when we get the account update the balance，
    and so on？ Well。 just look at this middle step。 How do we add the amount to the
    account while we grab the account balance into a register。 we add the amount to
    the register， we store the amount back。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。除了它是否有效。没有，不幸的是，它不起作用。那么，实际上发生了什么呢，当我们获取账户更新余额等等？好吧，看看这个中间步骤。我们如何在获取账户余额到寄存器时添加金额？我们将金额加到寄存器，然后将金额存回去。
- en: And if somebody else happens to be accessing that same account at the same time
    and the。 threads get interleaved， now I'll have it goes loose。 Okay。 And let me
    give you an example here。 which is you're going to put 10 bucks into your account。
    Your parents are putting 500 bucks。 Except your $10 thing here。 Overwrites the
    $500 your parents put into your account and by the time you're done your account。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恰好有其他人在同一时间访问那个账户，并且线程发生了交错，现在我就会遇到问题。好的。让我给你一个例子，就是你准备把10美元存入你的账户，而你的父母把500美元存入你的账户。结果是，你的10美元存款覆盖了你父母存入的500美元，到你完成时，你的账户...
- en: balance doesn't have $510 in it。 It's got 10。 Okay。 Now I don't know about you
    guys。 but this is probably bad。 Okay。 That's a lot of lattes that you lost out
    on。 Everybody with me on this？ So the problem here is there are these things that
    need to be atomic。 which is that the， combination of load add store can't be interruptible。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 余额里没有$510。它有10。好的。我不知道你们怎么样，但这可能很糟糕。好的。那可是你失去的很多拿铁钱。大家理解吗？所以这里的问题是，有一些操作需要是原子性的。也就是说，加载、加法、存储的组合不能被打断。
- en: It's got to be treated as an atomic section。 And that's the fundamental problem
    here is that we don't have our atomic sections figured。 out properly and we don't
    even have a way to express an atomic section yet。 So and if you remember。 Cooby's
    scheduler， malicious scheduler rule， the scheduler will。 find the best schedule
    of two threads to lose you 500 bucks。 Okay。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须被当作一个原子操作处理。而这里的根本问题是我们还没有妥善处理我们的原子操作，也还没有方法来表达原子操作。所以，如果你记得Cooby的调度程序，恶意调度程序规则，调度程序会找到两个线程的最佳调度方案让你损失500美元。好的。
- en: That scheduler will do it and it'll do it at 335。 Right。 That's what I said。
    So what are we going to do？ The problem is at the lowest level。 So the time threads
    are working on separate data。 The scheduling doesn't matter。 So here。 if thread
    A says x equal one and thread B says y equals two。 Doesn't matter what order they're
    in。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该调度程序会执行这个操作，并且会在335时执行。对吧。就是我说的。那我们该怎么办呢？问题出在最低层次。所以时间线程在处理不同的数据。调度不重要。所以在这里，如果线程A说x等于1，线程B说y等于2。无论它们的顺序如何，都不重要。
- en: right？ Here， suppose y is 12 and now we have A and B interleaving。 What's x
    when you're done？ Well。 let's see。 If thread A runs the completion first， then
    x will be 13， right？ X equal one plus one。 Or if thread A and B are interleaved，
    then perhaps we get y equal two in which case x。 ends up at three or y equals
    four in which case x ends up at five。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？这里，假设y是12，现在我们有A和B交错执行。当执行结束时，x会是多少？好吧，我们来看看。如果线程A先执行完成，那么x将是13，对吧？x等于1加1。或者如果线程A和B交错执行，那么可能我们会得到y等于2，在这种情况下x最终是3，或者y等于4，那么x最终是5。
- en: So the possibilities of what happens when these two threads are interleaved
    are completely。 non-deterministic and depending on that malicious scheduler。 Okay，
    which will get you。 Okay。 The one thing that we want you to be paranoid about
    in this class， nothing else。 Just the scheduler。 Okay。 Now， what happens here？
    So， today says x equal one， thread B says x equal two。 Well。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这两个线程交错执行时可能发生的情况是完全不可预测的，并且依赖于那个恶意调度程序。好的，它会让你。好的。我们希望你在这门课中对一件事保持警惕，其他的都不需要。就只有调度程序。好的。现在，发生了什么呢？所以，今天线程A说x等于1，线程B说x等于2。好吧。
- en: here you know in most real machines that either x is one or x equals two。 Now。
    you could imagine some sort of weird serial processor where the bits are interleaved。
    and you got the zero one from the one guy and the one zero from the other and
    they get。 interleaved and you get three。 Okay， but I'm here to put your mind at
    rest。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数真实机器中，你会知道x是1或者x等于2。现在。你可以想象某种奇怪的串行处理器，位被交错排列，你得到了一个人提供的零一和另一个人提供的一个零，它们交错在一起，你得到了三。好吧，但我在这里是为了让你放心。
- en: That probably isn't going to happen。 Okay， because most processors， loads and
    stores are atomic。 which means the actual load or， store either entirely completes
    or not。 Okay。 So。 we need to understand the concurrent program。 We need to know
    what the underlying indivisible operations are。 And so we need this idea of an
    atomic operation， which is an operation that always runs the。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不会发生。好吧，因为大多数处理器，加载和存储是原子的。意味着实际的加载或存储操作，要么完全完成，要么根本不完成。好吧。所以，我们需要理解并发程序。我们需要知道底层不可分割的操作是什么。所以我们需要原子操作的概念，原子操作是指那些始终完整执行的操作。
- en: completion or not at all。 It's indivisible， can't be stopped in the middle and
    can't be modified by somebody else。 in the middle and therefore can become a fundamental
    building block。 And on most machines。 memory references and assignments are atomic
    so that weird case， of three doesn't happen。 Now it turns out that there are a
    lot of non atomic instructions and 32 bit processors。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是否完成，或者根本没有完成。它是不可分割的，不能在中途停止，也不能被其他人修改。因此，它可以成为基本构建块。在大多数机器上，内存引用和赋值是原子的，因此奇怪的情况（如三次操作）不会发生。现在事实证明，在32位处理器中有很多非原子指令。
- en: with double floating points that's 64 bits。 Those are not always atomic。 But
    don't worry about that for now。 Okay。 If we've got atomic loads and stores。 the
    question might be can we even make something， like that banking example work at
    all？ Okay。 because it clearly didn't work the way I started it out。 Right？ It
    was broken。 So。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双精度浮点数，大小为64位。这些操作并不总是原子的。但现在不用担心这些。好吧。如果我们有原子加载和存储，问题可能是我们是否能让某些东西，比如那个银行示例，正常工作？好吧，因为它显然不像我开始时设想的那样工作。对吧？它是坏的。所以。
- en: here's another example。 So， you have two threads A and B and they're competing
    with each other。 One of them sets i to zero counts up and says A wins。 The other
    one sets i equals zero counts down and says B wins。 So， what happens？
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子。所以，你有两个线程A和B，它们在互相竞争。一个设置i为零，递增并说A赢了。另一个设置i等于零，递减并说B赢了。那么，发生了什么？
- en: These are two threads in the same process。 What happens？ Well， I don't know。
    So memory loads and stores are atomic， but incrementing and decrementing is not。
    So who wins？ Well。 it could be either or neither。 They're guaranteed that somebody
    wins no because if they're interleaved in the wrong。 way， they keep erasing each
    other。 Okay， and they never get to winning。 Okay。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同一个进程中的两个线程。会发生什么呢？嗯，我不知道。所以内存的加载和存储是原子的，但递增和递减不是。那么谁赢了？嗯。可能是任何一个，或者都不是。它们被保证某一方会赢吗？不，因为如果它们的执行顺序错误，它们会不断相互覆盖。好吧，它们永远不能赢。好。
- en: And what if they both have their same CPU running at the same speed？
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们都在同一速度下运行的同一CPU呢？
- en: Is it guaranteed to go on forever？ No。 There's going to be non-determinism because
    of caches and all that other stuff and so。 even if they're running at the same
    speed， it probably will be that one finishes。 Okay。 So again。 this malicious scheduler
    hits the fan here， right？ So， here you go。 The interloop looks like this。 Thread
    A does a load。 Thread B does a load。 Thread A adds。 Thread B subtracts。 Thread
    A stores。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它会永远继续下去吗？不。由于缓存和其他原因，会有非确定性。所以，即使它们以相同的速度运行，最终一个线程可能会完成。好吧。所以再次强调，这个恶意调度器在这里发挥作用，对吧？所以，事情是这样的。循环看起来像这样：线程A执行加载，线程B执行加载，线程A加法，线程B减法，线程A执行存储。
- en: Thread B stores over it。 You know， when you do this and we're off， A gets up
    to an early start。 B says better go fast and tries really hard。 A goes ahead and
    writes a one。 B goes ahead and writes a minus one and A says， huh？ Okay。 Could
    this happen on a uniprocessor with the kind of scheduling we did at the beginning。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 线程B在上面存储。你知道，当你这样做时，A会抢先一步，B则表示最好加速并努力尝试。A继续写入1，B继续写入-1，A说，嗯？好吧，这种情况会发生在单处理器上吗，使用我们开始时的调度方式？
- en: of the lecture？ Probably not because the quantum we're talking about for switching。
    Does anybody remember what a good number for how frequently you switch might be？
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 讲座的结论是什么？可能不是，因为我们讨论的切换量。有没有人记得切换的合适频率是多少？
- en: So we don't want more than 10% of the time wasted， but how much time between
    switches？
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们不希望浪费超过 10% 的时间，但在切换之间需要多少时间呢？
- en: Everybody remember I gave you a couple of numbers。 Was that？ So 100 milliseconds
    is a good number。 Okay。 10 or 100 milliseconds。 Yeah。 So going forward trying
    to fix this。 our definition might be well synchronization is using atomic。 operations
    to ensure cooperation between threads。 And for now loads and stores are atomic。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大家还记得我给过你们几个数字吗？是吗？100 毫秒是一个不错的数值。好的，10 毫秒或 100 毫秒。是的。所以，往前看，试图解决这个问题时，我们的定义可能是，同步是使用原子操作确保线程间的合作。现在，加载和存储操作是原子的。
- en: Mutual exclusion says ensuring that only one thread does a particular thing
    at once。 And a critical section is a piece of code that only one thread can execute
    at a time。 Okay。 And you get a critical section because of mutual exclusion。 Okay。
    And so we need some way to have mutual exclusion。 And I want to give you an idea。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥性意味着确保每次只有一个线程执行某个特定的操作。临界区是一段代码，只有一个线程能在某一时刻执行。好了，你能得到临界区是因为互斥性。好了，所以我们需要某种方式来实现互斥性。我想给你们一个概念。
- en: The idea is a lock。 Okay， which I'm sure you got in 61C probably or B maybe。
    But now we're going to learn a lot about locks。 Okay。 And a lock prevents somebody
    from doing something。 And so the idea is you're going to do a lock before entering
    a critical section。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念是锁。好了，我相信你们在 61C 课程中可能已经学到过，或者也许是在 B 课程中学到的。但现在我们将深入学习锁的相关知识。好了，锁的作用是防止某人做某事。所以这个概念是，在进入临界区之前，你要先进行加锁。
- en: And then you're going to do an unlock afterwards。 And the trick here is if somebody
    already has it locked and you try to lock it。 you're， going to be forced to wait
    until they unlock it。 Then you get to go forward。 And so the essential idea to
    get out of today's lecture is that synchronization problems are。 all fixed by
    waiting。 If you make sure that people wait or threads wait in the right time。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会在之后进行解锁。这里的技巧是，如果有人已经锁定了它，而你试图锁定它，你将被迫等待直到他们解锁它。然后你才能继续。所以今天讲座的核心思想是，同步问题都可以通过等待来解决。如果你确保线程在合适的时机等待。
- en: then you can fix problems。 Okay。 So locks will need to be initialized。 Okay。
    So there's ways of initializing by constructing a lock or a lock init。 And typically
    acquiring。 you say acquire and you give a pointer to the lock or release， and
    you give a pointer to the lock。 So there can be many locks in a program。 Okay。
    So let's look to fix the banking problem。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以解决问题。好了，锁需要初始化。好的，初始化有两种方式，一种是构造锁，另一种是使用锁初始化（lock init）。通常，获取锁时，你会调用 acquire，并传递锁的指针；释放锁时，你会调用
    release，并传递锁的指针。所以程序中可以有多个锁。好了，让我们看看如何解决银行问题。
- en: Notice what I did here is I put in acquire and a release around that critical
    section。 This is the critical section。 It's the piece that we don't want to have
    broken into because that's will screw everything。 up。 Okay。 So if we have that
    lock acquire and release。 what we see here is basically that if we have， acquire
    and release around our critical section。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在临界区周围加了 acquire 和 release。这就是临界区。它是我们不希望被打断的部分，因为如果打断它，一切都会乱套。所以如果我们在临界区周围有加锁和解锁，我们看到的情况是，如果我们在临界区周围有加锁和解锁，就能确保一切正常。
- en: notice what happens。 Thread ABC， they all show up， but only one of them gets
    the lock。 Okay。 So for instance， a may acquire and all the rest of them are forced
    to wait。 And so now a does its thing。 And after it exits， now be gets to go。 And
    after it exits。 now see gets to go。 Okay。 Everybody with me？ And there we've just
    fixed the banking problem。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 看看发生了什么。线程 ABC，它们都出现了，但只有其中一个获得了锁。好的，举个例子，a 可能会先获取锁，其他线程则被迫等待。所以现在 a 完成了它的工作，接下来
    b 可以去做，b 完成后，接着是 c。好的，大家跟得上吗？就这样，我们解决了银行问题。
- en: but only if we make sure that we use the same， lock across all the deposit。
    withdraw all of the things where we have to make sure there's， only one thread
    in there at once。 which is messing with the state of the bank。 Okay。 I'm going
    to pause for a second。 Okay。 Okay。 So if you're interested in p threads， we mentioned
    p threads packages well back， they have locks。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是只有当我们确保在所有存款中使用相同的锁时，才可以这样做。撤销所有必须确保每次只有一个线程在其中的操作。这是在处理银行状态。好了，我暂停一下。好了。那么，如果你对
    p 线程感兴趣，我们之前提到过 p 线程包，它们有锁。
- en: called mutexes。 Okay。 So most languages give you a way to do some sort of locking。
    but we're going to explore， what that really means in a moment because really。
    if I just did loads and stores so far， I haven't shown you anything about how
    to make a lot。 Okay。 But usually if I've got multi threaded code and I'm writing
    multi threaded code， the first。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做互斥锁。好的，大多数语言都提供了一种锁定机制。但我们接下来会深入探讨，这意味着什么。因为实际上，如果我只是做了加载和存储操作，到目前为止，我还没有向你展示如何执行很多操作。好的，但通常来说，如果我在写多线程代码，第一件事。
- en: thing I do is I find out what are my synchronization operations of which locks
    are one。 All right。 Part of the process。 Okay。 So， so correctness requirements
    basically are that threaded programs must work for that。 malicious scheduler。
    So all inner leavings of thread instruction sequences and cooperating threads
    are using。 the same data by almost definition because they're cooperating。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一步是找出我的同步操作，其中锁是一个。好的，这是过程的一部分。好了，**正确性要求**基本上是，线程程序必须能够应对恶意调度器。因此，几乎所有线程指令序列的交错执行，以及协作线程使用相同数据的情况，几乎是定义上的，因为它们是在协作。
- en: And so therefore it's non deterministic。 And it's going to be very hard to debug
    unless you do really careful design of your code。 to start with。 Okay。 So if not
    a design aversion， run it a bunch of times declare it's fine and go home。 you're，
    guaranteed that the malicious scheduler is going to get you。 Okay。 So part of
    what we're going to do over the next several couple of lectures is we're going。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它是非确定性的。如果你不小心设计代码，要调试起来会非常困难，除非你从一开始就做了非常仔细的设计。好的，如果没有做设计规避，那么就运行几次，声明它没问题，然后回家。你将**确保**恶意调度器会搞砸一切。好的，接下来几节课中，我们将讨论一些内容。
- en: to try to understand what's involved in properly building code that works under
    all sorts of。 thread scheduling。 Okay。 So an example is the there are 25。 which
    actually has reading from last time。 I didn't put it up。 but this was a machine
    that did radiation therapy for people with， cancer。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试理解在各种线程调度下，如何正确构建能够正常工作的代码。好的，举个例子，这里有25个案例。其实上次的阅读材料我没有上传，但是这是一个为癌症患者提供辐射治疗的机器。
- en: And there was a software control of the electron acceleration and the electron
    beam production。 to get x-rays as well。 And software control of the dosage。 And
    so the idea is you put the patient on a table。 And if you wanted to give them
    certain x-ray therapy， you'd send electrons at a target。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该机器通过软件控制电子加速和电子束的产生，以获取X射线。同时，软件还控制剂量。因此，基本思路是把病人放到治疗台上。如果你想为他们提供X射线治疗，你会将电子射向一个靶标。
- en: which would produce the x-rays and you'd do it for so long to give them the
    right dose。 And you know， this is an important kind of way of treating cancer。
    The problem was there were concurrency bugs in this machine。 And it killed a bunch
    of patients。 Okay。 And what was really bad about the concurrency bugs were there
    are a bunch of race conditions。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器产生X射线，并且你会持续这么做，直到给病人提供足够的剂量。你知道，这是治疗癌症的一种重要方式。问题是，这台机器中存在并发错误，导致了多名病人死亡。好了，关于并发错误的一个真正糟糕的地方是，它们是由多个竞态条件引起的。
- en: where somebody hadn't properly thought this through。 And it was very poor software
    design。 And here's the quote that's most crazy。 There's a report up there on the
    reading from last time that you can look at。 Quote， "They determined that the
    data entry speed during editing was the key factor in。 producing the error condition。
    If the prescription data was edited at a fast pace。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人没有好好思考这个问题。这是一个非常糟糕的软件设计。这里有一个最疯狂的引用。上面有一份上次阅读的报告，你可以查看一下。引用：“他们确定在编辑过程中，数据输入速度是导致错误条件的关键因素。如果处方数据以很快的速度被编辑。”
- en: the overdose occurred。"， Let me translate that for you。 You've got a really
    good operator。 They know things well。 They're typing things in too quickly。 That
    was when you ended up killing people。 Okay。 Now hopefully none of you will be
    in that position。 But I will point out that concurrency is really something you
    got a design for correctness。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了过量。“让我为你翻译一下。你有一个非常优秀的操作员，他们非常了解这些操作，但他们输入数据太快。这就是你最终导致杀人的原因。好了，希望你们都不会陷入这种情境。但我要指出的是，**并发性**真的需要你设计时保证正确性。
- en: from the beginning。 Okay。 So that's the whole point。 Now I'm running a little
    bit behind what I normally do here， but we have a midterm week。 from Thursday。
    I'm sure you're all excited。 No class that day。 Okay。 I'll try to have some extra
    office hours during class period in my office if people。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始。好了。这就是重点。现在我稍微有点落后于我平时的进度，不过我们这周有期中考试。从星期四开始。我敢肯定你们都很兴奋。那天没有课。好的。如果有人需要，我会尽量在上课期间增加一些办公时间。
- en: want to come by。 We'll give you a lot more details about that。 But it's all
    the topics up to that day。 All right。 Excuse me。 Up to the Tuesday before。 but
    not a heavy emphasis on that Tuesday lecture。 Okay。 Project one。 design documents
    due next Friday。 So you know that。 And that means design reviews are coming up。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想来找我，我们会提供更多细节。但所有的主题都会涵盖到那一天。好了。抱歉。直到星期二之前，但星期二的讲座不会有太重的重点。好的。项目一的设计文档下周五截止。所以你们都知道了。这意味着设计评审即将到来。
- en: And we will have the TAs will be scheduling you to come in and give a design
    review on。 what your plans are for the project。 Think of the design document as
    a high level discussion of what you plan to do。 Don't do it first and then dump
    all the code into your design document。 All right。 The point here is a discussion
    of your design。 Okay。 And if you need to have some code。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会让助教安排你们来进行设计评审。你们将讨论你们的项目计划。把设计文档当作你计划做的事情的高层讨论。不要先做完，再把所有的代码扔到设计文档里。好了。这里的重点是讨论你的设计。好的。如果需要一些代码。
- en: put in pseudo code。 Okay。 That's the kind of code I put in class where it's
    not a huge amount of syntax。 It's given the general idea。 Okay。 Because you want
    them to help you。 You're going to under make them understand what you're planning
    to do。 And then they can have some suggestions for that。 Okay。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 放入伪代码中。好的。这就是我在课堂上展示的代码，它没有大量的语法，给出的是一般的思路。好的。因为你希望他们帮助你。你要让他们理解你打算做什么。然后他们可以为此提供一些建议。好的。
- en: And you and make sure you have a good testing methodology。 How are you going
    to test it to make sure it works？
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 并且确保你有一个良好的测试方法。你将如何测试它，以确保它能正常工作？
- en: And the other thing I just want to mention and we did a bunch of this the first
    couple， of lectures。 In these projects， do your own work in your group。 Don't
    be tempted to collaborate。 Don't have a big project writing party。 Okay。 That's
    a bad idea。 You can have a project writing party within your group。 Okay。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另外我想提到的一点是，我们在前几次讲座中做了很多这方面的内容。在这些项目中，记得在你们的小组内做自己的工作。不要去勾结合作。不要搞一个大型的项目写作聚会。好的。那是个坏主意。你可以在你的团队内举行一个项目写作聚会。好的。
- en: And four people is about the right amount for， you know， a nice two slices of
    pizza and whatever。 else。 But don't， uh， don't be sharing things back and forth
    because our tools that we use to check。 for that will flag you。 And we really
    don't want that。 Okay。 Now， project one， project two。 project three， they're all
    looking inside Pintos。 So you're hopefully you started looking at the code。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 四个人差不多是一个合理的团队人数，你知道的，适合两片披萨和其他什么的。但不要，呃，不要来回交换东西，因为我们用来检查的工具会标记你们。我们真的不希望那样。好的。现在，项目一、项目二、项目三，它们都涉及到Pintos。所以希望你们已经开始查看代码了。
- en: Okay。 And some of the things I showed you today， if you go back to my slides，
    you can see some。 some different files that are referenced there。 If you want
    to sort of see some of those details。 Okay。 All right。 Questions。 Okay。 Yes。 You
    know， you can start coding a little bit。 but I would go through the design review
    before， you get to， uh。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。今天我展示的一些内容，如果你回去看我的幻灯片，你可以看到一些提到的不同文件。如果你想看一些细节。好的。好了。有问题吗？好的。是的。你知道，你可以开始写一些代码了。但是我会建议你在开始编码前先通过设计评审。
- en: enamored with a particular approach。 Okay。 But， but you know what， I would。
    I would push as far as you can so you have a very good idea， what you're going
    to do。 Okay。 Just。 I would say don't go that last step of writing it all up， but
    I would keep working。 hard on figuring out what you're doing。 And if you write
    some preliminary code。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对某种方法特别感兴趣。好的。但是，你知道吗，我会。尽可能推得远一点，这样你就能很清楚地知道你要做什么。好的。只是。我会说不要走到最后一步，写完整的代码，但我会继续努力，弄清楚你在做什么。如果你写了一些初步代码。
- en: just so you understand what it's going to look， like， that's probably a good
    thing to do。 Getting ahead in this class is never a liability。 Let me say that
    again。 getting ahead in this class is never a liability。 Always a good idea。 All
    right。 So。 I want to motivate an example here to start understanding block construction。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了让你明白它将是什么样子，做到这一点可能是一个好主意。在这门课上超前从来不会是负担。再说一遍，在这门课上超前从来不会是负担。总是个好主意。好了。那么，我想先举个例子，开始理解区块构造。
- en: So we call this too much milk。 Okay。 And the good thing about OS is is analogies
    between real life and the operating system。 uh， are all over the place。 And sometimes
    this helps。 Okay。 But you got to assume when you're coming up with an analogy
    that computers are much， super。 super than people。 I hope especially you guys
    here at Berkeley。 Um， and so we got to be careful。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们称之为牛奶过多。好吧。操作系统的一个优点是，现实生活和操作系统之间的类比无处不在。呃，有时候这很有帮助。好吧。但你必须假设，当你提出一个类比时，计算机远比人类更强大。我希望，尤其是你们在伯克利的同学们，能理解这一点。嗯，所以我们要小心。
- en: So here's the problem。 You live in a house with somebody and you have a rule
    about milk。 If you use it up， get some more。 Okay。 And so what happens is person
    A gets back from section at three o'clock looks in the。 fridge， you're out of
    milk。 So we've already violated something。 but they're going to go get something，
    right？ So they leave for the store and they're arriving at the store at three
    10。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是问题。你和别人一起住在一间屋子里，你们有个关于牛奶的规则。如果用完了就去买一些。好吧。然后发生了什么呢？A人三点钟从外面回到家，打开冰箱，发现牛奶没了。所以我们已经违反了某些规则。但他们要去买牛奶，对吧？于是他们出发去商店，三点十分到达商店。
- en: But meanwhile， the next partner looks in the fridge， you're out of milk。 They
    start leaving for the store， they go in the other direction to a different store，
    right？ Um。 person A buys the milk， they arrive home， they put the milk away。 The，
    uh， goes to the store。 buys milk， you arrive home。 And now we've got altogether
    now too much milk。 Okay。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，另一个人查看冰箱，发现牛奶没了。他们开始出发去商店，去另一家商店，对吧？嗯。A人买了牛奶，回到家，把牛奶放好。然后，呃，B人去商店，买了牛奶，回到家。现在我们就有了“牛奶过多”的情况。好吧。
- en: So how do we fix this problem？ Right？ So could we put a lock to use？
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该如何解决这个问题呢？对吧？我们可以使用锁吗？
- en: Now we don't have to build a lock yet， but all synchronization involves waiting，
    right？
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还不需要构建一个锁，但所有的同步操作都涉及等待，对吧？
- en: That was what you learned today。 So example is you fix the milk problem。 you
    put a big padlock on the fridge when you're， going to the store and you take the
    key with you and you get home and now your。 uh， your， roommate is just pissed。
    Okay。 Because they really only want an orange juice or ice cream or something。
    Okay。 So maybe we need to do something other than that。 Okay。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是今天学到的内容。举个例子，你解决了牛奶的问题。你在冰箱上挂上了一个大挂锁，当你去商店时带上了钥匙，回到家时，呃，你的室友非常生气。好吧。因为他们其实只是想喝橙汁或冰淇淋之类的东西。好吧。那么也许我们需要做点其他的事情。好吧。
- en: So let's see if we can be a little more sophisticated。 So first of all。 what
    are the correctness properties here？ So one is we got to be very careful about
    correctness of concurrent programs since it's。 a non deterministic issue。 Okay。
    And so the impulse is to code first， ask questions later。 Don't do that。 Think
    first code。 Then ask question。 Okay。 No。 So instead think first。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们来看看能不能稍微复杂一点。首先，这里的正确性属性是什么？一个是我们必须非常小心并发程序的正确性，因为它是一个非确定性问题。好吧。所以本能的反应是先编写代码，之后再提问题。不要这样做。先思考，再编码。然后再提问题。好吧。不是的。所以，首先要先思考。
- en: then code and always write your behavior down that you're expecting。 especially
    with synchronization problems。 Okay， there you are。 your instincts as a EECS or
    an LNSCS person are to write first ask， questions later。 You got to resist。 Understand
    first。 Okay。 So what are the correctness properties？
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编写代码，并始终写下你预期的行为，特别是对于同步问题。好吧，你在这里。作为一名EECS（电气工程与计算机科学）或LNSCS（计算机科学与数学）专业的学生，你的本能是先写代码，后提问题。你得抵制这种冲动。先理解。好吧。那么，正确性属性是什么？
- en: So never more than one person buys somebody buys if needed。 Those are two very
    important constraints。 Okay。 And the first attempt is we're going to restrict
    ourselves to use only atomic load in store。 and that means we're going to use
    notes。 So here's the idea。 You use a note to avoid buying too much milk。 So you
    leave a note before buying like a lock and then when you're done。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不会有超过一个人买牛奶。只要有需要的人就会买。这是两个非常重要的约束条件。好吧。第一步尝试是我们将限制自己仅使用原子加载和存储。这意味着我们会使用便条。所以这里的想法是，你使用便条来避免买太多牛奶。你在买牛奶之前留下一个便条，就像一个锁，然后当你完成时。
- en: you remove， the note and you don't buy if there's a note。 Okay。 Seems reasonable。
    The problem is we're talking about computers not people here。 So notice our code。
    which we want to try to get a critical section out of might be like， this。 If
    no milk， okay。 If no note， leave a note， buy milk， remove note。 Okay。 So what
    happens？ Anybody see？ Yeah。 Uh huh。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你移除便条，如果有便条就不买。好吧，看起来合理。问题是，我们在谈论的是计算机而不是人类。所以注意我们的代码。我们想从中获取一个临界区，可能是这样的。如果没有牛奶，好吧。如果没有便条，留下便条，买牛奶，移除便条。好吧。那么会发生什么？有人看到了吗？是的，嗯。
- en: Good。 Now， it's， notice the problem here， right？ So thread A says， if no milk
    and thread B says。 if no milk， thread B says， if no note， thread， A says， no note，
    leave note， goes to buy milk。 And the other one does the same thing。 So an interleaving
    there is actually going to give you too much milk again。 right？ But notice that
    this is too much milk， but only occasionally too much milk because we're。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在注意到这里的问题了吧？所以线程A说，如果没有牛奶，线程B说，如果没有牛奶，线程B说，如果没有便条，线程A说，如果没有便条，留下便条，去买牛奶。另一个线程做的也是同样的事情。所以这里的交错执行实际上又会让你买太多牛奶，对吧？但是注意，这只是偶尔会买太多牛奶，因为我们。
- en: basically， you have to hit spot on that interleaving or everything will work
    properly。 So this is like worse， right？ Because this happens intermittently and
    the scheduler will pick up that 335 in the morning。 problem， right？ Okay。 So the
    result is still too much milk， but only occasionally。 Okay。 So everybody with
    me on that？ That doesn't work。 Okay。 So， uh。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你必须精准地处理交错执行，否则一切都不会正常工作。所以这其实更糟，对吧？因为这会间歇性发生，调度程序会在早上3:35抓到这个问题，对吧？好吧。所以结果还是会有太多牛奶，但只是偶尔。好吧，大家跟得上吗？这行不通。好吧。那么，呃。
- en: so the solution basically makes the problem worse since it fails intermittently，
    and you know。 you do not want that。 And by the way， there are lots of bugs， not
    exactly like this。 but intermittent failure， bugs in the early days of Unix。 And
    it was recommended that you had to reboot every now and then because there were
    some。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个解决方案基本上让问题更糟，因为它间歇性地失败，你知道的。你不希望这样。顺便说一下，早期的Unix中有很多错误，虽然不完全像这个，但也是间歇性的失败问题。当时建议你得时不时重启，因为有一些。
- en: weird bugs in the kernel。 Okay。 And there are some operating systems that we
    won't name that have that same property。 So actually， I heard the other day that
    Tesla is now recommending with their big screen to。 reboot it regularly because
    it gets blocked up。 So anyway， I don't know。 I don't know if I like that where
    that's going。 So the clearly the notes not blocking enough。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中的奇怪错误。好吧。确实有一些操作系统（我们不提名字）也有这种特性。其实，我前几天听说，特斯拉现在建议他们的大屏幕要定期重启，因为它会被阻塞。所以总之，我不知道，我不确定我喜欢这个方向。显然，便条没有足够地阻止。
- en: So let's try to fix this by placing the note first。 So you leave the note and
    then you say if no milk， if no milk， so what's wrong with this？
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们试着通过先留下便条来修复这个问题。首先留下便条，然后你说，如果没有牛奶，如果没有牛奶，那么这有什么问题？
- en: There's a note there。 Okay。 Well， with a human probably nothing bad， but with
    a computer。 no one ever buys milk。 Okay。 So let's try something different。 Let's
    label the notes。 So A leaves note A and B leads note B。 Okay。 And so A says leave
    note A if no note B if no milk by milk remove note A and vice versa。 Okay。 Does
    this work？ Why not？ Okay。 And then what？
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有一个便条。好吧，对于人类来说，可能没什么大问题，但对于计算机来说。没有人会买牛奶。好吧。那么我们试试不同的做法。我们给便条加标签。所以A留下便条A，B留下便条B。好吧。然后A说，如果没有便条B，就留下便条A；如果没有牛奶，就去买牛奶；拿掉便条A，反之亦然。好吧。这行得通吗？为什么不行？好吧，然后呢？
- en: So they both leave the note and they don't buy milk。 All right。 So it's possible
    for neither thread to buy milk。 So it's context switch at exactly the wrong time。
    Remember that malicious scheduler？ Okay。 This is the this is extremely unlikely
    that this would happen。 but this is where there， was a lot of possible bugs like
    this。 Okay。 Very unlikely。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们两个都离开了便条，但是都没有买牛奶。好吧。所以，可能两个线程都不会买牛奶。这个是发生在完全错误的时机的上下文切换。记得那个恶意调度器吗？好吧。这是极不可能发生的情况。但是，这也是出现过很多类似
    bug 的地方。好吧，非常不可能。
- en: but hard to debug because you have to somehow get it to occur in exactly the。
    right way to find the bug。 Okay。 This is this is not sleeping for days kind of
    bugging debugging。 Right。 This is the I'm not getting milk。 You're getting milk。
    Okay。 And this kind of a lock up is often called starvation， which kind of works
    here， right？
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但很难调试，因为你必须以一种正确的方式去触发它，才能找到 bug。好吧。这不是那种几天都不能睡觉的调试。对吧。这是那种“我没有买到牛奶，你买到了牛奶”的情况。好吧。这种死锁通常叫做“饥饿”，在这里算是发生了，对吧？
- en: Because there's no milk。 So， so let's try another option。 I'm going to call
    this number three。 So here， thread A leaves the note and then says， well， there's
    a note for B。 Don't do anything spinning。 And then if there's no milk， buy milk。
    remove note and be leaves its note。 And it says， if there's no note A， then if
    there's no milk。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有牛奶。所以，我们再试试另外一种选择。我要称之为第三种情况。这里，线程 A 离开便条，然后说，“嗯，有便条给 B，不做任何事，继续旋转”。然后如果没有牛奶，就买牛奶，移除便条，而
    B 也会离开它的便条，并且说，“如果没有便条 A”，那如果没有牛奶……
- en: buy milk， remove note。 So first thing to notice is these two threads are different。
    Everybody catch that？ Does this work？ Who thought they'd find milk was so complicated？
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 买牛奶，移除便条。所以首先要注意的是这两个线程是不同的。大家都注意到了吗？这个有效吗？谁觉得找到牛奶这么复杂？
- en: How many people think this works？ How many people think it doesn't work？
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少人认为这个有效？有多少人认为它无效？
- en: How many people have absolutely no idea？ Okay， at least you're honest。 So turns
    out it does work。 It's both can guarantee that it's either it's safe to buy or
    somebody else will buy。 Okay。 And it's okay to quit。 So if you notice， think about
    this。 It doesn't matter。 Suppose they both leave the note at the same time， then
    what A is going to do is A is going。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少人完全不知道？好吧，至少你很诚实。所以结果是它确实有效。它可以保证不管怎么样，要么买牛奶是安全的，要么其他人会去买。好吧。退出也是可以的。所以如果你注意到，想想这个。没关系。假设他们同时都离开了便条，那么
    A 要做的就是 A 会去做。
- en: to spin waiting for B to remove the note and now B can happily look at to see
    if there's， no note A。 then it'll go ahead and buy the milk。 But if it finds out
    there was a note A。 it's not going to do anything。 Why is that okay？ Well， because
    A will then check for no milk。 Okay。 so this， you know， at X if no note B is safe
    for A to buy， otherwise wait， so。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了等待，A 旋转等待 B 移除便条，现在 B 可以高兴地看是否没有便条 A。如果没有便条 A，它就会继续买牛奶。但如果发现有便条 A，它什么也不会做。为什么这样没问题？因为
    A 会检查是否没有牛奶。好吧，所以，在 X 处如果没有便条 B，A 可以安全购买，否则就等待。
- en: find out what's going to happen。 If A， Y if there's no note A， safe for B to
    buy。 otherwise A is either buying or waiting， for B to quit。 Wow。 Okay。 And so
    you can kind of see here。 you know， leave note A happens before if no note A，
    then， we sit here and spin waiting。 And then eventually when we remove the note，
    we go ahead and do this and that works。 Okay。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 找出会发生什么。如果 A，Y 如果没有便条 A，对 B 来说是安全购买。否则，A 要么正在购买，要么在等待 B 退出。哇。好吧。所以你可以在这里看到。你知道，便条
    A 的离开发生在如果没有便条 A 之前，然后我们就停下来旋转等待。然后最终，当我们移除便条时，我们继续做这件事，并且它有效。好吧。
- en: Case number two is that we leave note B and we execute the if no note A before
    we leave， note A。 And so what happens here is he's going to leave potentially
    leaves note A， sees note。 B is set so they're going to wait a little bit。 And
    at that point。 this guy is going to go all the way through and buy milk。 This
    one's still spinning。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是我们先离开便条 B，然后在离开便条 A 之前执行“如果没有便条 A”的判断。那么发生的情况是，它可能会离开便条 A，看到便条 B 被设置，所以它们会稍微等待一下。然后这个线程会继续执行并购买牛奶，而另一个线程还在旋转等待。
- en: So by the time we get here， there's milk。 Okay。 Now， wow， it works。 I can guarantee
    you that if you had to write code like this all the time， you would never。 get
    it right。 I would never get it right。 And can anybody answer this question？
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所以等到我们到这里时，有牛奶。好吧。现在，哇，它有效了。我可以保证，如果你必须一直这样写代码，你永远不会。写对。我永远不会写对。有人能回答这个问题吗？
- en: What if I had a third thread？ What if I have C？ Say again， it paint or paint？
    Uh huh， paint。 Yes。 Paint exists。 So it turns out that this generalizes Dan threads。
    You can look up this paper。 but this seems bad， right？ I mean， it works， but it
    just doesn't seem desirable。 So what did we learn just now？ If we only have loads
    and stores， yes， we can synchronize。 Okay。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有第三个线程呢？如果我有C呢？再说一遍，是画还是涂？嗯，涂。是的，涂是存在的。所以事实证明，这个可以推广到多个线程。你可以查一下这篇论文，但这看起来不太好，对吧？我的意思是，它能工作，但看起来并不理想。那么我们现在学到了什么？如果我们只有加载和存储，是的，我们可以同步。好的。
- en: In fact， this is the critical section we're synchronizing。 All that other stuff
    on the outside is to make sure that only one thread ever says if。 no milk by milk。
    So we actually came up with locking scenario here to give us a critical section
    in solution。 number three works， but it's terribly unsatisfactory and it's really
    complex。 Okay。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这就是我们在同步的临界区。外面那些其他的东西是为了确保只有一个线程会执行“如果没有牛奶，就买牛奶”。所以我们实际上想出了一个锁定场景，给我们提供了一个临界区的解决方案。方案三能工作，但它非常不令人满意，而且非常复杂。好的。
- en: And A's code is different from B's code。 And worse， as you'll learn。 is that
    A actually spins waiting for B。 So it's possible that B goes to the store。 goes
    to the library， goes and gets dinner。 And then comes home to put the milk in there
    and meanwhile A has been spinning the whole。 time。 Okay。 That's bad。 And so if
    you come up with a synchronization solution where cycles are just being wasted。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: A的代码和B的代码不同。而更糟的是，正如你们会学到的，A实际上是在等待B时旋转。所以有可能B去商店、去图书馆、去吃晚餐，然后回家把牛奶放进去，而此时A一直在不停地旋转。好的，这很糟糕。所以如果你提出一个同步解决方案，其中处理器周期被浪费，那就是不好的。
- en: it's not good。 Okay。 And we'll actually knock points off if you have an explicit
    busy wait that can last for。 a long period of time。 So I will tell you for a fact。
    this is not going to be a recommended solution。 Okay。 Got to be a better way。
    And so the better way is going to be we need something other than loads or stores。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样不行。好的。如果你有一个显式的忙等待，而且它可能持续很长时间，我们实际上会扣分。所以我可以告诉你，实际上这不是推荐的解决方案。好的，必须有更好的方法。所以更好的方法是我们需要其他的东西，而不是加载或存储。
- en: We're going to need some hardware to help us。 Okay。 And too much solution number
    four is really we want this acquire。 Lock release lock。 And if somebody else already
    acquired the lock， you go to sleep on a weight cue so that you're。 not using any
    cycles。 That's a desirable solution。 Okay。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些硬件来帮助我们。好的，方案四基本上是我们想要这个获取锁和释放锁。如果其他人已经获取了锁，你就去睡觉，等待队列，这样你就不会浪费任何处理器周期。这是一个理想的解决方案。好的。
- en: The roommate who's waiting for B gets to go up and take a nap and they'll get
    woken up。 when B comes back。 Okay。 That would be not busy waiting。 Okay。 And somehow
    these things that fire and release have to be atomic operations。 If two threads
    are waiting for the lock and both set it free， only one gets to grab it。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那个在等待B的室友可以去小睡一会儿，他们会在B回来时被叫醒。好的，这就不是忙等待。好的，而且这些触发和释放的操作必须是原子操作。如果两个线程都在等待锁并且都释放它，那么只有一个能够抢到它。
- en: So if you remember that example I showed you with the bank， there were three
    threads， they。 all kind of waited at the entry。 And what one of them got in first
    and then when he exited。 only one of the two remaining， ones got to go through。
    So it has to be atomic。 Otherwise it's not a good lock。 Okay。 And then here's
    our problem。 Okay。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你还记得我之前给你们展示的银行的例子，那里有三个线程，它们都在入口处等。然后其中一个先进入，退出时，剩下的两个线程只有一个能够继续执行。所以它必须是原子的。否则这就不是一个好的锁。好的，接下来是我们的问题。好的。
- en: And this works for a sorority now。 Okay。 So many people as you want or fraternity。
    it doesn't matter。 You can have a choir if no milk by milk release and it'll just
    work for 20 threads or 100。 threads。 Okay。 So that's where we're going with this。
    We want the code to be the same。 Okay。 And so where are we going？ We're talking
    about load in store for synchronization。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于姐妹会现在有效。好的，无论你需要多少人，或者兄弟会都可以，没关系。你可以在没有牛奶时释放牛奶，它就能工作，无论是20个线程还是100个线程。好的，这就是我们要走的方向。我们希望代码是一样的。好的，那我们接下来要去哪里？我们在讨论加载和存储的同步。
- en: We're going to start moving into some other types of hardware operations other
    than load， or store。 We get a little bit before we leave today。 And everything
    is going to be kind of painful down at this level if we only have operations。
    but it's going to get a lot better if we can disable interrupts， et cetera。 But
    ultimately。 we're going to build locks and semaphores and monitors and so on out，
    of those lower primitives。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始涉及一些其他类型的硬件操作，而不仅仅是加载或存储。在今天结束前我们还会涉及一点。所有的操作如果只有基本操作，那么在这个层面上会有些痛苦，但如果我们能够禁用中断等操作，情况会好很多。但最终，我们将基于这些低级原语来构建锁、信号量、监视器等等。
- en: And so by the time we get to semaphores and monitors， things are going to be
    much easier。 to build correct code easily。 Okay。 And then we're going to build
    shared programs and all that。 Okay。 Now， how do you implement a lock？ So remember
    a lock prevents somebody from doing something。 You lock before entering the critical
    section。 You unlock after you wait if locked。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以等到我们涉及到信号量和监视器时，构建正确代码将变得容易得多。好的。然后我们将构建共享程序等等。好的。现在，如何实现一个锁呢？记住，锁的作用是防止其他人做某些事情。你在进入临界区之前锁定，在等待时解锁。
- en: And we're going to say to avoid busy waiting that you should sleep if you can't
    get the， lock。 So now I kept， I keep using this term sleep and I just want to
    make sure it's clear what， I mean。 Sleep means your thread is unloaded， the TCB's
    got its registers and it's sitting on some。 queue somewhere。 That's a sleeping
    thread。 Everybody with me？
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会说，为了避免忙等待，如果你无法获取锁，应该让线程休眠。所以我一直使用“休眠”这个术语，我只是想确保大家明白我指的是什么意思。休眠意味着你的线程被卸载，TCB（线程控制块）保存了寄存器的状态，并且它正坐在某个队列中。那就是一个休眠线程。大家明白吗？
- en: So what we want is our lock to work such that if multiple threads try to acquire，
    only one。 gets through and the rest of them are put on a wait queue， usually associated
    with the， lock。 Okay。 Question。 Yes。 So so far， all we've given you the ability
    to do here is that they will go to sleep。 So if multiple threads enter the acquire
    phase， only one of them goes through， the rest of。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们希望锁的工作方式是，如果多个线程尝试获取锁，只有一个线程能够通过，其他线程则被放入一个通常与锁关联的等待队列中。好的。问题。是的。所以到目前为止，我们给你们提供的功能就是它们会进入休眠状态。如果多个线程进入获取阶段，只有其中一个能够成功，其他线程则...
- en: them are put asleep on a wait queue。 Okay。 And for now。 also assume that that
    wait queue is associated explicitly with that lock。 Okay。 So there'll be as many
    wait queues as there are lots。 Okay。 Good。 question。 Yeah。 。 (silence)。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被放置在等待队列中。好的。那么现在假设这个等待队列是与锁显式关联的。好的。所以将会有与锁的数量相同的等待队列。好的。好，问题。是的。 (沉默)。
- en: '![](img/53a0bbd96bce73194524f58499453c5d_3.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53a0bbd96bce73194524f58499453c5d_3.png)'
