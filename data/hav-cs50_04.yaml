- en: Lecture 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座 2
- en: 原文：[https://cs50.harvard.edu/x/notes/2/](https://cs50.harvard.edu/x/notes/2/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/x/notes/2/](https://cs50.harvard.edu/x/notes/2/)
- en: '[Welcome!](#welcome)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欢迎光临！](#welcome)'
- en: '[Reading Levels](#reading-levels)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阅读级别](#reading-levels)'
- en: '[Compiling](#compiling)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译](#compiling)'
- en: '[Debugging](#debugging)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[调试](#debugging)'
- en: '[Arrays](#arrays)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数组](#arrays)'
- en: '[Strings](#strings)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串](#strings)'
- en: '[String Length](#string-length)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串长度](#string-length)'
- en: '[Command-Line Arguments](#command-line-arguments)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令行参数](#command-line-arguments)'
- en: '[Exit Status](#exit-status)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[退出状态](#exit-status)'
- en: '[Cryptography](#cryptography)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[密码学](#cryptography)'
- en: '[Summing Up](#summing-up)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Welcome!
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎光临！
- en: In our previous session, we learned about C, a text-based programming language.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们之前的会话中，我们学习了 C，一种基于文本的编程语言。
- en: This week, we are going to take a deeper look at additional building blocks
    that will support our goals of learning more about programming from the bottom
    up.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这周，我们将更深入地研究额外的构建块，这将支持我们从底层学习更多关于编程的目标。
- en: Fundamentally, in addition to the essentials of programming, this course is
    about problem-solving. Accordingly, we will also focus further on how to approach
    computer science problems.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上，除了编程的基本要素外，本课程还关于问题解决。因此，我们还将进一步关注如何解决计算机科学问题。
- en: By the end of the course, you will learn how to use these aforementioned building
    blocks to solve a whole host of computer science problems.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到课程结束时，您将学习如何使用上述构建块来解决一系列计算机科学问题。
- en: Reading Levels
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读级别
- en: One of the real-world problems we will solve in this course is understanding
    reading levels.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本课程中将解决的现实世界问题之一是理解阅读级别。
- en: With the help of some of your peers, we presented readings at various reading
    levels.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些同伴的帮助下，我们以不同的阅读级别进行了阅读。
- en: We will be quantifying reading levels this week as one of your many programming
    challenges.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这周，我们将量化阅读级别，作为您众多编程挑战之一。
- en: Compiling
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: '*Encryption* is the act of hiding plain text from prying eyes. *Decrypting*,
    then, is the act of taking an encrypted piece of text and returning it to a human-readable
    form.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密* 是将明文隐藏起来不被窥视的行为。因此，*解密* 就是将加密的文本片段转换回人类可读形式的行为。'
- en: 'An encrypted piece of text may look like the following:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密的文本片段可能看起来像以下这样：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Recall that last week, you learned about a *compiler*, a specialized computer
    program that converts *source code* into *machine code* that can be understood
    by a computer.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，上周您学习了 *编译器*，这是一种专门计算机程序，它将 *源代码* 转换为计算机可以理解的 *机器代码*。
- en: 'For example, you might have a computer program that looks like this:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，您可能有一个看起来像这样的计算机程序：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A compiler will take the above code and turn it into the following machine
    code:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器将上述代码转换为以下机器代码：
- en: '![machine code](../Images/cc82b27c280e13363cd34bf8bff290eb.png "machine code")'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![机器代码](../Images/cc82b27c280e13363cd34bf8bff290eb.png "机器代码")'
- en: '*VS Code*, the programming environment provided to you as a CS50 student, utilizes
    a compiler called `clang` or *c language*.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VS Code*，作为 CS50 学生提供的编程环境，使用了一个名为 `clang` 或 *C 语言* 的编译器。'
- en: 'You can enter the following into the terminal window to compile your code:
    `clang -o hello hello.c`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将以下内容输入到终端窗口以编译您的代码：`clang -o hello hello.c`。
- en: '*Command-line arguments* are provided at the command line to `clang` as `-o
    hello hello.c`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令行参数* 以 `-o hello hello.c` 的形式在命令行中提供给 `clang`。'
- en: Running `./hello` in the terminal window, your program runs as intended.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中运行 `./hello`，您的程序将按预期运行。
- en: 'Consider the following code from last week:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下上周的代码：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To compile this code, you can type `clang -o hello hello.c -lcs50`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编译此代码，您可以输入 `clang -o hello hello.c -lcs50`。
- en: If you were to type `make hello`, it runs a command that executes clang to create
    an output file that you can run as a user.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您输入 `make hello`，它将运行一个命令，执行 clang 创建一个您可以运行的输出文件。
- en: VS Code has been pre-programmed such that `make` will run numerous command line
    arguments along with clang for your convenience as a user.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 已经预先编程，以便 `make` 可以运行多个命令行参数，并配合 clang 为您作为用户带来便利。
- en: While the above is offered as an illustration, such that you can understand
    more deeply the process and concept of compiling code, using `make` in CS50 is
    perfectly fine and the expectation!
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然上述内容提供了一种说明，以便您更深入地理解编译代码的过程和概念，但在 CS50 中使用 `make` 是完全正常且符合预期的！
- en: 'Compiling involves four major steps, including the following:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译涉及以下四个主要步骤：
- en: 'First, *preprocessing* is where the header files in your code, designated by
    a `#` (such as `#include <cs50.h>`) are effectively copied and pasted into your
    file. During this step, the code from `cs50.h` is copied into your program. Similarly,
    just as your code contains `#include <stdio.h>`, code contained within `stdio.h`
    somewhere on your computer is copied to your program. This step can be visualized
    as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，*预处理*是将你的代码中的头文件（由`#`指定，例如`#include <cs50.h>`）有效地复制并粘贴到你的文件中。在这一步中，`cs50.h`中的代码被复制到你的程序中。同样，就像你的代码包含`#include
    <stdio.h>`一样，计算机上某个地方的`stdio.h`中的代码也被复制到你的程序中。这一步可以可视化如下：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Second, *compiling* is where your program is converted into assembly code.
    This step can be visualized as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，*编译*是将你的程序转换为汇编代码。这一步可以可视化如下：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Third, *assembling* involves the compiler converting your assembly code into
    machine code. This step can be visualized as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，*汇编*涉及编译器将你的汇编代码转换为机器代码。这一步可以可视化如下：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, during the *linking* step, code from your included libraries is converted
    also into machine code and combined with your code. The final executable file
    is then outputted.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在*链接*步骤中，你的包含库中的代码也被转换为机器代码，并与你的代码结合。然后输出最终的可执行文件。
- en: '![linking](../Images/9925463abb3fadc794f1f9aeaa44997c.png "linking")'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![链接](../Images/9925463abb3fadc794f1f9aeaa44997c.png "链接")'
- en: Debugging
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: Everyone will make mistakes while coding.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个人在编码时都会犯错误。
- en: '*Debugging* is the process of locating and removing bugs from your code.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试*是定位和移除代码中错误的过程。'
- en: One of the debugging techniques you will use during this course to debug your
    code is called *rubber duck debugging*, where you can talk to an inanimate object
    (or yourself) to help think through your code and why it is not working as intended.
    When you are having challenges with your code, consider how speaking out loud
    to, quite literally, a rubber duck about the code problem. If you’d rather not
    talk to a small plastic duck, you are welcome to speak to a human near you!
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本课程中，你将使用的一种调试代码的技术被称为*橡皮鸭调试*，其中你可以与一个非生命物体（或你自己）交谈，以帮助你思考代码以及为什么它没有按预期工作。当你遇到代码挑战时，考虑一下大声地向一个橡皮鸭说出代码问题。如果你不想和一个塑料小鸭说话，你也可以和附近的人交谈！
- en: We have created the CS50 Duck and [CS50.ai](https://cs50.ai) as tools that can
    help you debug your code.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了CS50 Duck和[CS50.ai](https://cs50.ai)作为可以帮助你调试代码的工具。
- en: 'Consider the following image from last week:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑上周的以下图片：
- en: '![mario](../Images/d38c3a8d91af5f35e1a17f3fed702497.png "mario")'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![马里奥](../Images/d38c3a8d91af5f35e1a17f3fed702497.png "马里奥")'
- en: 'Consider the following code that has a bug purposely inserted within it:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下故意在其内部插入错误的代码：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that this code prints four blocks instead of three.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码打印了四个方块而不是三个。
- en: Type `code buggy0.c` into the terminal window and write the above code.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中输入`code buggy0.c`并写下上述代码。
- en: Running this code, four bricks appear instead of the intended three.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这段代码，会出现四个砖块而不是预期的三个。
- en: '`printf` is a very useful way of debugging your code. You could modify your
    code as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printf`是一种非常有用的调试代码的方法。你可以按照以下方式修改你的代码：'
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how this code outputs the value of `i` during each iteration of the loop
    such that we can debug our code.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码在循环的每次迭代中都输出了`i`的值，这样我们就可以调试我们的代码。
- en: 'Running this code, you will see numerous statements, including `i is 0`, `i
    is 1`, `i is 2`, and `i is 3`. Seeing this, you might realize that further code
    needs to be corrected as follows:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这段代码，你会看到许多语句，包括`i is 0`、`i is 1`、`i is 2`和`i is 3`。看到这些，你可能会意识到需要进一步修正以下代码：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the `<=` has been replaced with `<`.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`<=`已被替换为`<`。
- en: 'This code can be further improved as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码可以进一步改进如下：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that compiling and running this code still results in a bug.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，编译和运行这段代码仍然会导致错误。
- en: To address this bug, we will use a new tool.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用一个新的工具。
- en: A second tool in debugging is called a *debugger*, a software tool created by
    programmers to help track down bugs in code.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试的第二个工具被称为*调试器*，这是一种由程序员创建的软件工具，用于帮助追踪代码中的错误。
- en: In VS Code, a preconfigured debugger has been provided to you.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VS Code中，已经为你提供了一个预配置的调试器。
- en: To utilize this debugger, first set a *breakpoint* by clicking to the left of
    a line of your code, just to the left of the line number. When you click there,
    you will see a red dot appearing. Imagine this as a stop sign, asking the compiler
    to pause so that you can consider what’s happening in this part of your code.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用这个调试器，首先通过点击代码左侧，位于行号左侧的行来设置一个*断点*。当你点击那里时，你会看到一个红色的小点出现。想象一下这是一个停车标志，要求编译器暂停，这样你就可以考虑这段代码中发生的事情。
- en: '![breakpoint](../Images/0ba1700ceafc9cd8ccd7e324b2972885.png "breakpoint")'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![断点](../Images/0ba1700ceafc9cd8ccd7e324b2972885.png "断点")'
- en: Second, run `debug50 ./buggy0`. You will notice that after the debugger comes
    to life and a line of your code will illuminate in a gold-like color. Quite literally,
    the code has *paused* at this line of code. Notice in the top left corner how
    all local variables are being displayed, including `h`, which currently does not
    have a value. At the top of your window, you can click the `step over` button,
    and it will keep moving through your code. Notice how the value of `h` increases.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，运行`debug50 ./buggy0`。你会注意到，当调试器启动后，你的一行代码将以金色般的颜色点亮。字面上说，代码就在这一行代码处*暂停*了。注意左上角显示了所有局部变量，包括当前没有值的`h`。在你的窗口顶部，你可以点击`step
    over`按钮，它会继续移动通过你的代码。注意`h`的值是如何增加的。
- en: While this tool will not show you where your bug is, it will help you slow down
    and see how your code is running step by step. You can use `step into` as a way
    to look further into the details of your buggy code.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这个工具不会显示你的错误在哪里，但它会帮助你放慢速度，逐步查看你的代码是如何运行的。你可以使用`step into`来进一步查看有问题的代码的细节。
- en: Arrays
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: In Week 0, we talked about *data types* such as `bool`, `int`, `char`, `string`,
    etc.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第0周，我们讨论了诸如`bool`、`int`、`char`、`string`等的数据类型。
- en: 'Each data type requires a certain amount of system resources:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种数据类型都需要一定数量的系统资源：
- en: '`bool` 1 byte'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool` 1 字节'
- en: '`int` 4 bytes'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 4 字节'
- en: '`long` 8 bytes'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 8 字节'
- en: '`float` 4 bytes'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 4 字节'
- en: '`double` 8 bytes'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` 8 字节'
- en: '`char` 1 byte'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 1 字节'
- en: '`string` ? bytes'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` ? 字节'
- en: Inside of your computer, you have a finite amount of memory available.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的计算机内部，你有有限的内存可用。
- en: '![memory](../Images/5dcb11ea45c81d06f96b5b5928d31850.png "memory")'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![内存](../Images/5dcb11ea45c81d06f96b5b5928d31850.png "内存")'
- en: 'Physically, on the memory of your computer, you can imagine how specific types
    of data are stored on your computer. You might imagine that a `char`, which only
    requires 1 byte of memory, may look as follows:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理上，在你的计算机内存中，你可以想象特定类型的数据是如何存储在你的计算机上的。你可能想象一个`char`，它只需要1个字节的内存，可能看起来如下所示：
- en: '![1 byte](../Images/f81b2b67fcc10f85c09c4bc7e8e85a14.png "1 byte")'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![1 字节](../Images/f81b2b67fcc10f85c09c4bc7e8e85a14.png "1 字节")'
- en: 'Similarly, an `int`, which requires 4 bytes, might look as follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，一个需要4个字节的`int`可能看起来如下所示：
- en: '![4 bytes](../Images/c3cf2e5397c77f78ea306dfe9f347b8e.png "4 bytes")'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![4 字节](../Images/c3cf2e5397c77f78ea306dfe9f347b8e.png "4 字节")'
- en: 'We can create a program that explores these concepts. Inside your terminal,
    type `code scores.c` and write code as follows:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个探索这些概念的程序。在你的终端中，输入`code scores.c`并编写以下代码：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the number on the right is a floating point value of `3.0`, so that
    the calculation is rendered as a floating point value in the end.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意右边的数字是一个`3.0`的浮点值，所以计算最终呈现为浮点值。
- en: Running `make scores`, the program runs.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`make scores`，程序运行。
- en: 'You can imagine how these variables are stored in memory:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象这些变量是如何存储在内存中的：
- en: '![scores in memory](../Images/0b670fb61beb0c8c43a0cae99fc33c63.png "scores
    in memory")'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![内存中的分数](../Images/0b670fb61beb0c8c43a0cae99fc33c63.png "内存中的分数")'
- en: '*Arrays* are a sequence of values that are stored back-to-back in memory.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组* 是在内存中连续存储的值序列。'
- en: '`int scores[3]` is a way of telling the compiler to provide you three back-to-back
    places in memory of size `int` to store three `scores`. Considering our program,
    you can revise your code as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int scores[3]`是告诉编译器为你提供三个连续的内存位置，大小为`int`，以存储三个`scores`。考虑到我们的程序，你可以按照以下方式修改你的代码：'
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `score[0]` examines the value at this location of memory by `indexing
    into` the array called `scores` at location `0` to see what value is stored there.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`score[0]`通过`indexing into`名为`scores`的数组在位置`0`的内存位置来检查这个位置的值，以查看存储了什么值。
- en: 'You can see how, while the above code works, there is still an opportunity
    for improving our code. Revise your code as follows:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到，虽然上面的代码可以工作，但仍然有机会改进我们的代码。按照以下方式修改你的代码：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how we index into `scores` by using `scores[i]` where `i` is supplied
    by the `for` loop.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何通过使用 `scores[i]` 来索引 `scores`，其中 `i` 由 `for` 循环提供。
- en: 'We can simplify or *abstract away* the calculation of the average. Modify your
    code as follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以简化或抽象出平均值的计算。按照以下方式修改你的代码：
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that a new function called `average` is declared. Further, notice that
    a `const` or constant value of `N` is declared. Most importantly, notice how the
    `average` function takes `int array[]`, which means that the compiler passes an
    array to this function.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意声明了一个新函数 `average`。此外，注意声明了一个 `const` 或常量值 `N`。最重要的是，注意 `average` 函数接受 `int
    array[]`，这意味着编译器将数组传递给这个函数。
- en: 'Not only can arrays be containers: They can be passed between functions.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅数组可以作为容器：它们可以在函数之间传递。
- en: Strings
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A `string` is simply an array of variables of type `char`: an array of characters.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `string` 简单地是一个类型为 `char` 的变量数组：一个字符数组。
- en: 'To explore `char` and `string`, type `code hi.c` in the terminal window and
    write code as follows:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要探索 `char` 和 `string`，在终端窗口中输入 `code hi.c` 并按照以下方式编写代码：
- en: '[PRE14]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that this will output a string of characters.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这将输出一个字符字符串。
- en: 'Similarly, make the following modification to your code:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，对你的代码进行以下修改：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that that ASCII codes are printed by replacing `%c` with `%i`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意通过将 `%c` 替换为 `%i` 来打印 ASCII 码。
- en: 'Considering the following image, you can see how a string is an array of characters
    that begins with the first character and ends with a special character called
    a `NUL character`:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下图像，你可以看到字符串是一个以第一个字符开始并以一个称为 `NUL 字符` 的特殊字符结束的字符数组：
- en: '![hi with terminator](../Images/6e1de3086852834f9ad7198e55664750.png "hi with
    terminator")'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![hi with terminator](../Images/6e1de3086852834f9ad7198e55664750.png "hi with
    terminator")'
- en: 'Imagining this in decimal, your array would look like the following:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下以十进制表示，你的数组看起来如下所示：
- en: '![hi with decimal](../Images/e056e45da52fe9e90950b423d7201f08.png "hi with
    decimal")'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![hi with decimal](../Images/e056e45da52fe9e90950b423d7201f08.png "hi with
    decimal")'
- en: 'To further understand how a `string` works, revise your code as follows:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进一步理解 `string` 的工作方式，按照以下方式修改你的代码：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how the `printf` statement presents three values from our array called
    `s`.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `printf` 语句如何从我们的数组 `s` 中呈现三个值。
- en: 'As before, we can replace `%c` with `%i` as follows:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将 `%c` 替换为 `%i`，如下所示：
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that this prints the string’s ASCII codes, including NUL.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这会打印出字符串的 ASCII 码，包括 NUL。
- en: 'Let’s imagine we want to say both `HI!` and `BYE!`. Modify your code as follows:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们想象我们想要说 `HI!` 和 `BYE!`。按照以下方式修改你的代码：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that two strings are declared and used in this example.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在这个例子中声明并使用了两个字符串。
- en: 'You can visualize this as follows:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以这样可视化：
- en: '![hi and bye](../Images/9e6c2f2d06a45b8429cc827816d1bc3d.png "hi and bye")'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![hi and bye](../Images/9e6c2f2d06a45b8429cc827816d1bc3d.png "hi and bye")'
- en: 'We can further improve this code. Modify your code as follows:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以进一步改进这段代码。按照以下方式修改你的代码：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that both strings are stored within a single array of type `string`.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这两个字符串都存储在单个类型为 `string` 的数组中。
- en: We can consolidate our two strings into an array of strings.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将两个字符串合并到一个字符串数组中。
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that an array of `words` is created. It is an array of strings. Each
    word is stored in `words`.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意创建了一个 `words` 的数组。它是一个字符串数组。每个单词都存储在 `words` 中。
- en: String Length
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串长度
- en: 'A common problem within programming, and perhaps C more specifically, is to
    discover the length of an array. How could we implement this in code? Type `code
    length.c` in the terminal window and code as follows:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程中一个常见的问题，也许在 C 语言中更为具体，是发现数组的长度。我们如何在代码中实现这一点？在终端窗口中输入 `code length.c` 并按照以下方式编写代码：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that this code loops until the NUL character is found.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这段代码会一直循环，直到找到 NUL 字符。
- en: 'This code can be improved by abstracting away the counting into a function
    as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将计数抽象到函数中来改进这段代码，如下所示：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that a new function called `string_length` counts characters until NUL
    is located.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到有一个新函数 `string_length` 被调用，它计算字符直到找到 NUL。
- en: 'Since this is such a common problem within programming, other programmers have
    created code in the `string.h` library to find the length of a string. You can
    find the length of a string by modifying your code as follows:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是编程中一个如此常见的问题，其他程序员已经在 `string.h` 库中创建了代码来查找字符串的长度。你可以通过修改以下方式来查找字符串的长度：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that this code uses the `string.h` library, declared at the top of the
    file. Further, it uses a function from that library called `strlen`, which calculates
    the length of the string passed to it.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码使用了在文件顶部声明的`string.h`库。此外，它使用该库中的一个函数`strlen`，该函数计算传递给它的字符串的长度。
- en: Our code can stand on the shoulders of programmers who came before and use libraries
    they created.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码可以站在前人的肩膀上，并使用他们创建的库。
- en: '`ctype.h` is another library that is quite useful. Imagine we wanted to create
    a program that converted all lowercase characters to uppercase ones. In the terminal
    window, type `code uppercase.c` and write code as follows:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctype.h`是另一个非常有用的库。想象一下，如果我们想要创建一个将所有小写字母转换为大写字母的程序。在终端窗口中，输入`code uppercase.c`并编写以下代码：'
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that this code *iterates* through each value in the string. The program
    looks at each character. If the character is lowercase, it subtracts the value
    32 from it to convert it to uppercase.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码会*遍历*字符串中的每个值。程序会查看每个字符。如果字符是小写的，它会从该字符中减去`32`的值以将其转换为大写。
- en: 'Recalling our previous work from last week, you might remember this ASCII values
    chart:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾上周我们之前的工作，你可能还记得这个ASCII值表：
- en: '| 0 | NUL | 16 | DLE | 32 | SP | 48 | 0 | 64 | @ | 80 | P | 96 | ` | 112 |
    p |   |'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | NUL | 16 | DLE | 32 | SP | 48 | 0 | 64 | @ | 80 | P | 96 | ` | 112 |
    p |   |'
- en: '| 1 | SOH | 17 | DC1 | 33 | ! | 49 | 1 | 65 | A | 81 | Q | 97 | a | 113 | q
    |   |'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | SOH | 17 | DC1 | 33 | ! | 49 | 1 | 65 | A | 81 | Q | 97 | a | 113 | q
    |   |'
- en: '| 2 | STX | 18 | DC2 | 34 | ” | 50 | 2 | 66 | B | 82 | R | 98 | b | 114 | r
    |   |'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | STX | 18 | DC2 | 34 | ” | 50 | 2 | 66 | B | 82 | R | 98 | b | 114 | r
    |   |'
- en: '| 3 | ETX | 19 | DC3 | 35 | # | 51 | 3 | 67 | C | 83 | S | 99 | c | 115 | s
    |   |'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | ETX | 19 | DC3 | 35 | # | 51 | 3 | 67 | C | 83 | S | 99 | c | 115 | s
    |   |'
- en: '| 4 | EOT | 20 | DC4 | 36 | $ | 52 | 4 | 68 | D | 84 | T | 100 | d | 116 |
    t |   |'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | EOT | 20 | DC4 | 36 | $ | 52 | 4 | 68 | D | 84 | T | 100 | d | 116 |
    t |   |'
- en: '| 5 | ENQ | 21 | NAK | 37 | % | 53 | 5 | 69 | E | 85 | U | 101 | e | 117 |
    u |   |'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 5 | ENQ | 21 | NAK | 37 | % | 53 | 5 | 69 | E | 85 | U | 101 | e | 117 |
    u |   |'
- en: '| 6 | ACK | 22 | SYN | 38 | & | 54 | 6 | 70 | F | 86 | V | 102 | f | 118 |
    v |   |'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 6 | ACK | 22 | SYN | 38 | & | 54 | 6 | 70 | F | 86 | V | 102 | f | 118 |
    v |   |'
- en: '| 7 | BEL | 23 | ETB | 39 | ’ | 55 | 7 | 71 | G | 87 | W | 103 | g | 119 |
    w |   |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 7 | BEL | 23 | ETB | 39 | ’ | 55 | 7 | 71 | G | 87 | W | 103 | g | 119 |
    w |   |'
- en: '| 8 | BS | 24 | CAN | 40 | ( | 56 | 8 | 72 | H | 88 | X | 104 | h | 120 | x
    |   |'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 8 | BS | 24 | CAN | 40 | ( | 56 | 8 | 72 | H | 88 | X | 104 | h | 120 | x
    |   |'
- en: '| 9 | HT | 25 | EM | 41 | ) | 57 | 9 | 73 | I | 89 | Y | 105 | i | 121 | y
    |   |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 9 | HT | 25 | EM | 41 | ) | 57 | 9 | 73 | I | 89 | Y | 105 | i | 121 | y
    |   |'
- en: '| 10 | LF | 26 | SUB | 42 | * | 58 | : | 74 | J | 90 | Z | 106 | j | 122 |
    z |   |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 10 | LF | 26 | SUB | 42 | * | 58 | : | 74 | J | 90 | Z | 106 | j | 122 |
    z |   |'
- en: '| 11 | VT | 27 | ESC | 43 | + | 59 | ; | 75 | K | 91 | [ | 107 | k | 123 |
    { |   |'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11 | VT | 27 | ESC | 43 | + | 59 | ; | 75 | K | 91 | [ | 107 | k | 123 |
    { |   |'
- en: '| 12 | FF | 28 | FS | 44 | , | 60 | < | 76 | L | 92 | \ | 108 | l | 124 |  
    |   |'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 12 | FF | 28 | FS | 44 | , | 60 | < | 76 | L | 92 | \ | 108 | l | 124 |   |   |'
- en: '| 13 | CR | 29 | GS | 45 | - | 61 | = | 77 | M | 93 | ] | 109 | m | 125 | }
    |   |'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 13 | CR | 29 | GS | 45 | - | 61 | = | 77 | M | 93 | ] | 109 | m | 125 | }
    |   |'
- en: '| 14 | SO | 30 | RS | 46 | . | 62 | > | 78 | N | 94 | ^ | 110 | n | 126 | ~
    |   |'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 14 | SO | 30 | RS | 46 | . | 62 | > | 78 | N | 94 | ^ | 110 | n | 126 | ~
    |   |'
- en: '| 15 | SI | 31 | US | 47 | / | 63 | ? | 79 | O | 95 | _ | 111 | o | 127 | DEL
    |   |'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 15 | SI | 31 | US | 47 | / | 63 | ? | 79 | O | 95 | _ | 111 | o | 127 | DEL
    |   |'
- en: When a lowercase character has `32` subtracted from it, it results in an uppercase
    version of that same character.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从一个小写字母中减去`32`时，它将得到该字符的大写版本。
- en: 'While the program does what we want, there is an easier way using the `ctype.h`
    library. Modify your program as follows:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然程序完成了我们想要的功能，但使用`ctype.h`库有一个更简单的方法。按照以下方式修改你的程序：
- en: '[PRE25]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the program iterates through each character of the string. The `toupper`
    function is passed `s[i]`. Each character (if lowercase) is converted to uppercase.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，程序会遍历字符串中的每个字符。`toupper`函数传递了`s[i]`。每个字符（如果为小写）都会被转换为大写。
- en: 'It’s worth mentioning that `toupper` automatically knows to uppercase only
    lowercase characters. Hence, your code can be simplified as follows:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，`toupper`函数会自动识别并只将小写字母转换为大写。因此，你可以将代码简化如下：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that this code uppercases a string using the `ctype` library.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码使用`ctype`库将字符串转换为大写。
- en: You can read about all the capabilities of the `ctype` library on the [Manual
    Pages](https://manual.cs50.io/#ctype.h).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[手册页面](https://manual.cs50.io/#ctype.h)上阅读有关`ctype`库所有功能的说明。
- en: Command-Line Arguments
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行参数
- en: '`Command-line arguments` are those arguments that are passed to your program
    at the command line. For example, all those statements you typed after `clang`
    are considered command line arguments. You can use these arguments in your own
    programs!'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命令行参数` 是那些在命令行传递给程序的参数。例如，所有你在 `clang` 后面输入的语句都被认为是命令行参数。你可以在自己的程序中使用这些参数！'
- en: 'In your terminal window, type `code greet.c` and write code as follows:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，输入 `code greet.c` 并编写如下代码：
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that this says `hello` to the user.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个程序对用户说“hello”。
- en: 'Still, would it not be nice to be able to take arguments before the program
    even runs? Modify your code as follows:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，如果在程序运行之前就能接受参数不是很好吗？按照以下方式修改你的代码：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that this program knows both `argc`, the number of command line arguments,
    and `argv`, which is an array of the characters passed as arguments at the command
    line.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个程序知道 `argc`，即命令行参数的数量，以及 `argv`，它是一个包含在命令行中传递的字符的数组。
- en: Therefore, using the syntax of this program, executing `./greet David` would
    result in the program saying `hello, David`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，使用本程序的语法，执行 `./greet David` 将导致程序输出 `hello, David`。
- en: 'You can print each of the command-line arguments with the following:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下方式打印每个命令行参数：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exit Status
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出状态
- en: When a program ends, a special exit code is provided to the computer.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序结束时，提供给计算机一个特殊的退出码。
- en: When a program exits without error, a status code of `0` is provided to the
    computer. Often, when an error occurs that results in the program ending, a status
    of `1` is provided by the computer.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序无错误退出时，提供给计算机的状态码为 `0`。通常，当发生导致程序结束的错误时，计算机提供的状态为 `1`。
- en: 'You could write a program as follows that illustrates this by typing `code
    status.c` and writing code as follows:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以编写一个程序如下，通过输入 `code status.c` 并编写如下代码来展示这一点：
- en: '[PRE30]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that if you fail to provide `./status David`, you will get an exit status
    of `1`. However, if you do provide `./status David`, you will get an exit status
    of `0`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果你没有提供 `./status David`，你将得到退出状态 `1`。然而，如果你确实提供了 `./status David`，你将得到退出状态
    `0`。
- en: You can type `echo $?` in the terminal to see the exit status of the last run
    command.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在终端中输入 `echo $?` 来查看上一个运行命令的退出状态。
- en: You can imagine how you might use portions of the above program to check if
    a user provided the correct number of command-line arguments.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象如何使用上述程序的部分来检查用户是否提供了正确的命令行参数数量。
- en: Cryptography
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学
- en: Cryptography is the art of ciphering and deciphering a message.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学是加密和解密消息的艺术。
- en: Now, with the building block of arrays, chars, and strings, you can cipher and
    decipher a message.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，有了数组、字符和字符串的构建块，你可以加密和解密一条消息。
- en: '`plaintext` and a `key` are provided to a `cipher`, resulting in ciphered text.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plaintext` 和一个 `key` 被提供给一个 `cipher`，从而生成加密文本。'
- en: '![cryptography](../Images/dc6e0484aa11808fb2b21072abf29b7f.png "cryptography")'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![密码学](../Images/dc6e0484aa11808fb2b21072abf29b7f.png "密码学")'
- en: The key is a special argument passed to the cipher along with the plaintext.
    The cipher uses the key to make decisions about how to implement its cipher algorithm.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥是一个特殊的参数，与明文一起传递给加密器。加密器使用密钥来做出关于如何实现其加密算法的决定。
- en: This week, you will undertake programming challenges similar to the above.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这周，你将进行与上述类似的编程挑战。
- en: Summing Up
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, you learned more details about compiling and how data is stored
    within a computer. Specifically, you learned…
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了更多关于编译和计算机内部数据存储的细节。具体来说，你学习了…
- en: Generally, how a compiler works.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，编译器是如何工作的。
- en: How to debug your code using four methods.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用四种方法调试你的代码。
- en: How to utilize arrays within your code.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在你的代码中利用数组。
- en: How arrays store data in back-to-back portions of memory.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组如何在内存的连续部分存储数据。
- en: How strings are simply arrays of characters.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是如何简单地成为字符数组。
- en: How to interact with arrays in your code.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在你的代码中与数组交互。
- en: How command-line arguments can be passed to your programs.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将命令行参数传递给你的程序。
- en: The basic building blocks of cryptography.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学的基本构建块。
- en: See you next time!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎下次再来！
