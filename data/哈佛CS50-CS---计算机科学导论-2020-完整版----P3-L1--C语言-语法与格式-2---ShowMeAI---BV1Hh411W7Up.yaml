- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P3：L1- C语言（语法与格式）2 - ShowMeAI - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛 CS50-CS ｜ 计算机科学导论（2020·完整版） - P3：L1-C语言（语法与格式）2 - ShowMeAI - BV1Hh411W7Up
- en: but more on that next time all right，so we've seen only strings thus far but。it
    turns out in c and in a lot of，languages there's other things known as。types or
    data types that is to say you，can have variables and values。that aren't just strings
    of text but，two three four，or maybe floating point values like，3。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 但更多内容在下次讨论，好吧，到目前为止我们只见过字符串，但。事实证明在 C 语言和许多其他语言中，还有其他被称为。类型或数据类型的东西，也就是说你，可以拥有变量和数值。它们不仅仅是文本字符串，而是两个、三个、四个，或者像
    3 这样的浮点值。
- en: 14159 or other such values，you can have boolean values which are，only true，chars。which
    are single characters this is to，say within a language。like c there's actually
    a whole bunch of，data types that are available to you。string is only one of them
    and there's，even more than are on this list here。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 14159 或其他此类值，你可以拥有布尔值，这仅为真，`chars`。它是单个字符，这意味着在像 C 这样的语言中，实际上有许多可用的数据类型。`string`
    只是其中之一，甚至比这个列表上的更多。
- en: but this is just a list of some of the，most common ones that we'll see today。and
    will use this coming week in the，first problem set，that allow you to tell the
    computer not。only to store a value in a variable，but what type of value to store
    in a，variable moreover。we have in the cs50 library a whole，bunch more functions
    we've seen，getstring already。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是一些我们今天将看到的最常见的类型的列表。并且将在本周第一组问题集中使用，允许你告诉计算机不仅存储一个变量中的值，而是存储在变量中的值的类型。此外，我们在
    CS50 库中有更多函数，我们已经看到了 `getstring`。
- en: but similarly have we created functions，and beyond，that allow you to get a single
    character。by a getchar，that can allow you to get an integer via，getint that can
    allow you to get a。floating point value which is a fancy，way of describing a real
    number with a，decimal point。using get float but it turns out that，each of these
    data types，like int and float only have a finite。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但同样，我们创建了函数，超越，允许你通过 `getchar` 获取单个字符，允许你通过 `getint` 获取整数，允许你通过 `get float`
    获取浮点值，这是一种描述带有小数点的真实数字的 fancy 方式。但事实证明，这些数据类型，例如 `int` 和 `float` 只有有限的。
- en: number of bits，and recall from last week that we played，around with light bulbs
    and we played。around with bits and zeros and ones more，generally it turns out
    that，double。uh float int long string and so forth，all use a specific number of
    bits and it，turns out，use。32 bits and that's great until such time，as you want
    to count higher than roughly。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 位数，并回想一下上周我们玩弄了灯泡，我们玩弄了位和零和一。更一般地说，事实证明，`double`、`float`、`int`、`long`、`string`
    等等，均使用特定数量的位，结果是，使用 32 位，这很好，直到你想计数超过大约。
- en: 4 billion at which point you can't we'll，see later today that，if you're only
    using a specific number。of bits you can only count so high and，so there exist
    other data types for，instance a long。a long is another type of number in c，that
    just uses sixty-four bits so it gives you。way more expressiveness way more，higher，similarly
    a double is like a floating。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 40 亿，此时你无法再继续。我们今天稍后将看到，如果你只使用特定数量的位，你只能计数到这么高，因此存在其他数据类型，例如 `long`。`long` 是
    C 语言中的另一种数字类型，仅使用 64 位，因此它提供了。更高的表现力，类似地，`double` 就像一个浮点数。
- en: point value a real number with a decimal，point and some number of digits after
    it，digits。after it then a float would so we'll see，and use some of these data
    types。in just a bit printf similarly has the，we saw，but also using different format
    codes。other data types as well these are a，little more cryptic and it's fine to，you'll。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值是一个带有小数点的真实数字，后面有一些数字，后面的数字，然后一个浮点值会是这样，所以我们稍后将看到并使用一些这些数据类型。`printf` 同样具有，我们看到的，但也使用不同的格式代码。其他数据类型也是如此，这些类型更为晦涩，但没关系，你会。
- en: eventually ingrain them for common use，cases，percent c is going to be the placeholder。for
    printing a single character percent，c for a char，so to speak percent f is going
    to be for。a floating point value so if you want to，print out a real number with
    a decimal。point you're going to use percent f，if you want to print an integer
    using，integer。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最终将它们 ingrained 用于常见的用途，`cases`，`percent c` 将是占位符。打印单个字符 `percent c`，可以说 `percent
    f` 将用于。浮点值，所以如果你想打印一个带有小数点的真实数字。你将使用 `percent f`，如果你想打印一个整数使用，`integer`。
- en: if you want to print a string we've，already seen percent s and if you want，to
    print a long。integer aka long you're going to use，percent li，and there's even
    others but these are。perhaps some of the most common and it，just means that again，c
    really needs you the programmer to be。precise you can't just say print this，you
    have to tell printf how to print the，variable or the value。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想打印一个字符串，我们已经见过百分号s，如果你想打印一个长整型，即长整数，你将使用百分号li，还有其他一些，但这些可能是最常见的，它意味着c确实需要你这个程序员要非常精确，你不能只说打印这个，你必须告诉printf如何打印你传递的变量或值。
- en: that you're passing into it and then，lastly it turns out that in c。there's a
    whole bunch of operators，certainly mathematical ones and bunches。of others as
    well just like scratch had，a whole toolkit，of operators and suffice it to say
    for。now that c，also supports addition subtraction，multiplication division。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你传入的变量，然后最后发现，在c中有一堆运算符，当然有数学运算符，还有其他许多运算符，就像scratch有一整套运算符，暂且说c也支持加法、减法、乘法和除法。
- en: and even the remainder operator which a，little cryptically is represented with
    a，percent sign。![](img/cebeed9e0b28f665c194a66b2d3ef30a_1.png)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有余数运算符，略显神秘地用百分号表示。![](img/cebeed9e0b28f665c194a66b2d3ef30a_1.png)
- en: not to be confused with printf's format，codes but this is to say that some of。the
    earliest uses of computers of course，were all mathematically oriented in。spreadsheet
    programs programs like visit，calc and the like，back before there was excel in
    google。spreadsheets and they certainly，computers are very good，at supporting math
    and so these are just。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与printf的格式混淆，代码是说一些。计算机的最早用途当然都是与数学相关的，在电子表格程序中，比如在谷歌电子表格之前的visit、calc等程序，计算机在支持数学方面非常出色，所以这些只是。
- en: some of the operators that we'll now see，are available to us so let me go ah**d。and
    do this let me go back to，my ide after cleaning things up。and starting fresh with
    just nothing in，my terminal window and no tabs open。and let me go ah**d and write
    my next，these functions。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到的一些运算符，所以让我继续做这件事，让我回到我的IDE，在清理完一切后，重新开始，在终端窗口中没有任何内容，也没有打开的标签。让我继续写我的下一个，这些函数。
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_3.png)'
- en: i'm going to go ah**d and create a file，up here called，edition。c so edition。c
    but i could call。this anything i want but it's important，to add the dot c。![](img/cebeed9e0b28f665c194a66b2d3ef30a_5.png)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续创建一个名为edition.c的文件，虽然我可以把它叫做其他任何名字，但重要的是要添加.c的后缀。![](img/cebeed9e0b28f665c194a66b2d3ef30a_5.png)
- en: otherwise the computer will not know，that it's actual source code as opposed，to
    machine code。and let me go ah**d and make use of the，cs50 library so let me include
    cs50。h。let me include standardio。h so that i，can use things like，getint and printf
    and then again for。today's purposes i'm just going to do in，main intmane void
    and then the。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 否则计算机将不知道这实际上是源代码，而不是机器代码。让我继续利用cs50库，包括cs50.h。让我包括stdio.h，这样我就可以使用像getint和printf这样的东西，然后再次出于今天的目的，我只是会写在main
    intmane void中，然后。
- en: curly braces and again for today just，take on faith this is necessary but。we'll
    explain within a week or two，exactly why we keep writing int main。void but for
    now it's like the when，green flag clicked，puzzle piece let me go ah**d now and
    get。an integer from the user suppose my goal，now is not to write a program that
    gets。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号，再次为今天，只是相信这是必要的，但我们将在一两周内解释为什么我们一直写int main void，但现在就像绿色旗帜被点击的拼图一样，让我继续从用户那里获取一个整数，假设我现在的目标不是写一个获取。
- en: a string of text and prints out hello，brian or hello david，let me go ah**d and
    write a program that。maybe asks for two integers two numbers，and then just adds
    them together so let。me make the simplest of calculators，using code，variable，called
    x just like a mathematician would。and i'm gonna assign it the value，something
    like，x colon i could say anything i want what。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一串文本打印出hello，brian或hello david，让我继续写一个程序，可能会要求输入两个整数，两个数字，然后将它们相加，所以让我用代码制作最简单的计算器，使用一个叫做x的变量，就像数学家一样。我将赋值给它，类似于x冒号，我可以随便说任何我想要的。
- en: is x question mark but i'm going to keep，it simple and just say x colon。semicolon
    to end my thought so again，string before，but now i'm using get int to get a。number
    or an integer from the user，the quoted parameter here or argument。is the input
    to print to getint which is，sees，the equal sign recall is the assignment。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是 x 问号，但我会保持简单，只说 x 冒号。用分号结束我的思路，因此在这里我用 get int 从用户那里获取一个数字或整数，引用的参数是输入，打印到
    getint 的输出，等号是赋值。
- en: operator which says，copy the return value on the right，the integer that the
    human hopefully。will type in over to the left，and the left says give me a variable，called
    x。and let me store integers in it，so before we used string on the left and，difference
    now is。int on the left because i want a number，and get int on the right。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符表示，复制右侧的返回值，即人类希望输入的整数到左侧，左侧表示给我一个变量，叫 x。让我在其中存储整数，因此之前我们在左侧使用了字符串，现在的不同在于左侧是
    int，因为我想要一个数字，右侧是 get int。
- en: then let me go ah**d and do this again，and get another number，get int and i'll
    just say y colon but。again i could say what is y，question mark or anything in
    english but。the last line is going to be the，interesting one，now i'm going to
    go ah**d and print out。for instance the sum of these two，numbers，tells it，what
    to print out exactly so i can't。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我再做一次，获取另一个数字，获取 int，我只是说 y 冒号，但是我可以问 y 是什么，问号或任何英文，但最后一行将是有趣的，现在我将打印出来。例如，这两个数字的和，告诉它要精确打印出什么，所以我不能。
- en: really type a number here yet because i，type in，so i'm going to put a placeholder
    i'm。going to put percent i，which says put a number here i just，don't know yet
    what it is。and then just to keep things clean i'm，going to do backslash n which
    just says。give me a new line also that's just an，aesthetic detail to move the
    cursor to。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还没真正输入一个数字，因为我输入了，所以我将放置一个占位符，我将放置百分比 i，表示这里放一个数字，我只是还不知道是什么。然后，为了保持整洁，我将使用换行符，它只是说，给我一个新行，这也是一个美观的细节，移动光标。
- en: the next line just to keep things，clean but now printf is going to take a，second
    argument。and whether you've programmed or not。![](img/cebeed9e0b28f665c194a66b2d3ef30a_7.png)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行只是为了保持整洁，但现在 printf 将接受第二个参数。无论你是否编程过。![](img/cebeed9e0b28f665c194a66b2d3ef30a_7.png)
- en: before brian let's go to someone in the，audience if we could，what should i type
    after the comma if。the purpose of this program is quite，simply，to add two numbers
    together even if。you've never programmed before，based on the operators that exist
    and。some of the syntax we've seen thus far，what would your instincts have you
    type。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在布莱恩之前，让我们去观众中找人，如果可以的话，如果这个程序的目的是很简单地将两个数字相加，即使你从未编程过，基于现有的运算符和到目前为止我们看到的一些语法，你的直觉会让你输入什么？
- en: here even if you've never，done this before santiago what do you。um i would say
    to just write x plus y，yeah it is as simple and as。straightforward as that x plus
    y is the，right intuition i'm going to add a。semicolon at the very end just to
    finish，my thought but indeed computers。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从未这样做过，santiago，你该怎么做？嗯，我会说只需写 x 加 y，是的，就这么简单直接，x 加 y 是正确的直觉，我将最后加一个分号来结束我的想法，但确实计算机。
- en: and c in this case absolutely understand，*****，*****，i'm going to go ah**d now
    and save the。file and go down below and i'm not going，type，make addition because
    that is the name。of my file implicitly，edition。c i want to compile into a，program
    called edition。hopefully this is where i cross my，fingers i didn't make any mistakes。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，c 完全理解，*****，*****，我现在要保存文件，然后往下走，我不会去，输入，添加，因为那是我的文件名，隐含地，edition。c
    我想编译成一个名为 edition 的程序。希望这是我交叉手指的地方，我没有犯任何错误。
- en: and i'm going to go ah**d and run make，addition，all is well no error messages
    if i had。![](img/cebeed9e0b28f665c194a66b2d3ef30a_9.png)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续运行 make，addition，一切顺利，没有错误信息，如果我有的话。![](img/cebeed9e0b28f665c194a66b2d3ef30a_9.png)
- en: compile，help 50 might have been my next instinct。![](img/cebeed9e0b28f665c194a66b2d3ef30a_11.png)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译，help 50 可能是我接下来的本能。![](img/cebeed9e0b28f665c194a66b2d3ef30a_11.png)
- en: slash edition，and notice i'm first prompted for x i'm，going to go ah**d and
    do one。i'm next prompted for y i'm going to go，ahead and do one again。and voila
    santiago proposed i indeed see，on the screen，x plus y or the value 2。and i didn't。hard
    code 2，i substitute it in using percent i，whatever the result of。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: slash edition，注意我首先被提示输入 x，我将继续做一个。我接下来被提示输入 y，我会再做一个。瞧，santiago 提议我确实在屏幕上看到，x
    加 y 或者值 2，而我没有硬编码 2，我使用百分比 i 代入，无论结果是什么。
- en: x plus y actually is now notice，some of the features of the get in。function
    for you suppose that you're not，being very cooperative and you type in。cat for
    x notice that get in just，ignores you and prompts you again，prompts me，again if
    i type in 1。23 it ignores me，and prompts me again because it wants an，integer
    in this case a number like one。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: x加y实际上现在注意到，`getint`函数的一些特性，假设你不是很配合，输入`cat`作为x，注意到`getint`只是，忽略了你并再次提示，提示我，再次，如果我输入1.23，它忽略我，提示我再次，因为它想要一个整数，在这种情况下是像1这样的数字。
- en: four or zero，or anything above or below so fine i'll，cooperate now and give
    it the number one。same for y it's going to ignore any，non-integer input so if
    i give it a。number like 2 this time i'll hopefully，get the answer of，3。all right
    so we have a basic。calculator in c，we're using some basic building blocks，as before
    we've got these header files。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 四或零，或任何高于或低于的值，所以好吧，我现在会合作，给它数字一。y也是如此，它会忽略任何非整数输入，所以如果我给它一个数字，比如这次是2，我希望能得到，3的答案。好的，所以我们有一个基本的。计算器在c中，我们使用一些基本构建块，和以前一样，我们有这些头文件。
- en: which just give me access，to getint and printf respectively but，suppose now
    i want to count up even。higher you know what let me try，something like this let
    me run this，program once more。and let me get a little greedy how about，four zero
    zero zero。zero zero zero zero zero zero so roughly，four well exactly，four billion
    uh that's the number i want。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是让我访问，分别使用`getint`和`printf`，但是，假设现在我想要更高的计数，你知道吗，让我尝试一下，像这样的程序让我再运行一次。让我贪心一点，怎么样，四零零零。零零零零零零，所以大约是，四，确切地说，四十亿，呃，这就是我想要的数字。
- en: to type in，notice that x does not like that so get，in does not accept four billion
    well let。uh-huh didn't like that how about 2，billion。![](img/cebeed9e0b28f665c194a66b2d3ef30a_13.png)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到x不喜欢这个，所以`getint`不接受四十亿。那么，呃，没错，这样可以，怎么样，两个亿。![](img/cebeed9e0b28f665c194a66b2d3ef30a_13.png)
- en: okay that one worked let me pause here，what's going on perhaps now again we。the
    staff wrote get in so we are the，ones that are rejecting，cats and rejecting dogs
    and rejecting 4。billion and even 3 billion，but in this case it's a little less。clear
    why did we reject 4 billion in 3，billion do you think，based on some of the definitions
    thus。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那次成功了，我在这里暂停，发生了什么？也许现在再次我们，工作人员编写了`getint`，所以我们是，拒绝，猫和狗以及四十亿，甚至三十亿的原因，但在这种情况下不太清楚，为什么我们拒绝四十亿和三十亿，你认为基于一些定义。
- en: far today，why might this be nathaniel what do you，hi um i just got unmuted uh
    there's like。a cap on like the size of the number，since um it would take too many
    bits and。bytes uh after the size of two billion，perfect so integers again are，ants。ants
    only use it turns out 32 bits total，and you you would only know that by。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 今天远远不够，为什么会这样，纳撒尼尔，你好，嗯，我刚刚解除静音，呃，数字的大小有限制，因而在两个亿之后，完美，所以整数再次是，蚂蚁。蚂蚁总共只使用32位，而你只有通过输入才能知道这一点。
- en: having been taught it or looked it up，for a particular computer system。but they
    on cs50 ide and most modern，systems an integer。![](img/cebeed9e0b28f665c194a66b2d3ef30a_15.png)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 被教授过或查过，针对特定计算机系统。但他们在cs50 ide和大多数现代系统中，整数。![](img/cebeed9e0b28f665c194a66b2d3ef30a_15.png)
- en: is only 32 bits and that then invites，the question well if you've got 32 bits。or
    light bulbs how high can you count，well it turns out with 32 light bulbs or，bits
    you can count。roughly as high as 4 billion you can，absolutely count as high as
    3 billion。and yet get into still rejecting it but，that's because the get in function，includes
    not only，numbers。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只有32位，这就引出了问题，如果你有32位，或者灯泡，你能计数到多高，事实证明，有32个灯泡或位，你大约可以计数到四十亿，你绝对可以计数到三十亿。然而，`getint`仍然拒绝它，但这是因为`getint`函数，包含的不仅仅是数字。
- en: and zero and the catch is that if you，want to support both positive numbers，and
    negative numbers。you can represent four billion or so，total possible values，but
    if you want to go as far to the left。and as far to the right on the number，line
    that i'm describing。you can only really count as high as 2，billion in the positive
    direction。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 而且要注意的是，如果你想支持正数和负数，你可以表示四十亿左右，总共有可能的值，但是如果你想尽量向左走，尽量向右走在我描述的数字线上，你只能在正方向上计数到两个亿。
- en: and negative 2 billion in the negative，direction because that still gives you
    a，total of 4 billion。but not nearly as high as 3 billion or 4，be，well i recall
    earlier noting that。there's other data types not just ins，and strings but also，longs
    which literally are longer。integers namely sixty-four bits so let me go，ahead
    and try this。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 负20亿是在负方向，因为这仍然给你一个总共4亿。但远没有3亿或4亿那么高，我记得早些时候提到过，还有其他数据类型，不仅仅是整数和字符串，还有长整型，实际上是更长的整数，即64位，所以让我继续试试。
- en: let me go ah**d and change get in to get，long this get in，long，and this into
    a long so same program。same calculator but i'm now using a，different data type，that's
    just going to use more bits to。store values let me run，make addition again to
    recompile my，program and oh。damn it i screwed up so let's see if we，can't glean
    what's wrong here。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续并将get改为get long，把这个改为long，所以同样的程序，同样的计算器，但我现在使用的是不同的数据类型，这将使用更多的位数来存储值。让我再次运行加法，重新编译我的程序，哦，天哪，我搞砸了，让我们看看能否找出哪里出了错。
- en: let me scroll up and i can't emphasize，this enough sometimes i got lucky here。and
    i only have one mistake，apparently in the error messages it is，not going to be，errors。in
    like two lines of code this is，in your code，the compiler sometimes just gets。confused
    and if it gets sufficiently，confused it starts thinking。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向上滚动，我不能强调这一点，有时候我在这里运气很好，显然只有一个错误，在错误信息中，并不会出现两行代码的错误。在你的代码中，编译器有时会感到困惑，如果它感到足够困惑，它会开始思考。
- en: everything is an error in your actual，code so the most important takeaway is，to
    have。always scroll up to the top of the，output and address the first error first。so
    that's why i scrolled up in my window，to look immediately below what i typed。make
    addition and here's the first error，edition。c on line 10。 all right i can't。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际代码中的一切都是错误，所以最重要的收获是，总是向上滚动到输出的顶部，首先解决第一个错误。这就是我在窗口中向上滚动的原因，以便立即查看我输入的内容下面的内容。做加法，这就是第一个错误，位于第10行。
- en: see line 10 so let me scroll my code up，and it saying something about format，specifies
    type int。but the argument has type long we，haven't seen this error before but
    i。think i can infer from this it's not，super cryptic even though it's，that。percent
    i recall was for integers i，think what i need，is a different format code for long。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看第10行，所以让我把代码向上滚动，它提到格式指定类型为int，但参数的类型是long，我们之前没见过这个错误，但我想我可以从中推断出，这并不是超级神秘，尽管那是百分比，我记得是用于整数，我想我需要一个不同的长整型格式代码。
- en: integers which is going to be，l i instead and that was from my little，cheat
    sheet earlier。so let me go ah**d and try this again，li，whoops typo，now let me
    do dot slash addition and now。i'll type in four，zero zero zero zero zero zero
    zero zero，zero four billion，such a long。integer because it has enough bits，all
    right questions on types，int，yeah uh when i typed uh。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 整数将会是l i，而这是我之前的小备忘单。所以让我继续再试一次，li，哎呀，拼写错误，现在让我做点斜杠加法，现在我会输入四个零，四十亿，真是个长整型，因为它有足够的位数。好的，关于类型int的问题，当我输入的时候。
- en: two billion and both were integers uh，wrong answer，some negative number is that
    because of。the bits and bytes indeed it's the same，answer so i didn't demonstrate
    that but。if you inputted both 2 billion for x，and 2 billion for y and then you
    tried，to add those together。that would require that would give you，mathematically
    4 billion but again，billion。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两亿和两个都是整数，错误的答案，一些负数是因为位和字节确实是相同的答案，所以我没有演示这一点。但如果你为x输入两个2亿，为y输入两个2亿，然后试图将它们相加，这在数学上会给你4亿，但再说一次，亿。
- en: if we want to also be able to represent，seeing，is that you can't fit the result。in
    the data type allowed and we'll see，in a moment uh in a little bit today。actually
    what the ramifications of that，exactly that，you tried to cram too big of a number。into
    finitely many bits，32 you can avoid that problem though of，course by switching
    over。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还希望能够表示的，那就是你无法将结果放入允许的数据类型中，我们稍后会看到，实际上这有什么后果。你试图把一个太大的数字塞进有限的位数中，32位，但你可以通过切换来避免这个问题。
- en: to long let me try one other thing，that's a bit curious let me go ah**d and。write
    a slightly different program now，and i'm going to describe this as，truncation。c
    fancy term but we'll see，what this means in just a moment，i'm going to give myself
    at the top，cs50。h and i'm going to give myself，standardio。h，and it's certainly
    fine once you get。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再试一个别的，稍微有点意思，让我去**写**一个稍微不同的程序，现在，我将把这个称为**截断**。这是个华丽的术语，但我们很快就会看到这意味着什么，我将在顶部引入`cs50.h`，并引入`stdio.h`，这样做当然没问题。
- en: started with the first lab or problem，set if it takes you much longer to type。some
    of these things out，i'm just doing it for muscle memory int，main void。and now
    we're good to go with a new，program in a file called truncation。c。i'm going to
    go ah**d and prompt the，user for an int again so。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个实验室或问题集开始，如果你打这些东西花了更长的时间，我只是为了肌肉记忆而这样做`int main(void)`。现在我们可以开始一个新程序，文件名叫`truncation.c`。我接下来要**提示**用户再输入一个整型。
- en: just like before i'm going to prompt the，user for another int，go ah**d and。do
    this i want to do division this time，so not just addition that was a little。too
    easy let me do division so，equals，x divided by y and let me pause here for。a moment
    and just ask the question，z，this line of code is not yet correct。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我会再提示用户输入一个整型，继续**进行**这个操作，我想这次进行除法，不仅仅是加法，这有点太简单了。让我做除法，所以`z`等于`x`除以`y`，我在这里暂停一下，问一下，这行代码还不正确。
- en: because recall that anytime you create a，new variable，on the left here i'm going
    to need to。put something，to the left of that variable's name so，that c knows what
    type of variable i。want and thus far we've seen string and，and long so would you
    propose we use one。what should the data type be for z would，data type for z how
    about jack what do。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为回想一下，每次你在左边创建一个新变量时，我需要在该变量名称的左侧放置一些内容，以便`c`知道我想要什么类型的变量，迄今为止我们看到了字符串和长整型，那么你提议我们用什么呢？z的数据类型应该是什么？jack，你觉得呢？
- en: uh would it be a float yeah so float so，value，which is the programmer's way
    of。describing a real number let me go ah**d，and do that a float and。uh i'm guessing
    uh your instincts for，float were that well if you。add in type in one number for
    x and，another for y and the result is a，fraction of some sort。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它应该是浮点数吗？是的，所以是浮点数，所以`value`，这是程序员描述实数的方式。让我接下来做一个浮点数，嗯，我猜你的直觉是，如果你输入一个x的数字和一个y的数字，而结果是某种分数。
- en: so something with a decimal point we，need to store it in a float so that we，can
    actually。uh store whatever the numbers are after，do this，percent f，backslash n
    because i'm printing a float。print out，the value of z and you know what just，for
    good measure let me start practicing。good style here too，so get a number from
    user let me give，myself another comment get。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有小数点的东西，我们需要将其存储为浮点数，以便我们实际上可以，嗯，存储所有数字，做这个，`%f`，`\n`，因为我正在打印一个浮点数。打印出z的值，顺便说一句，为了好衡量，让我开始练习良好的风格，所以从用户那里获取一个数字，让我再给自己加一个注释。
- en: another number from user or you know，what this seems a little silly。i can combine
    these lines and why don't，i just say get for instance numbers from，your code，x。by
    y but even this is getting a little，pedantic because you can kind of read。that
    from the code so at some point we，might not even need a comment for that。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户那里再获取一个数字，或者说，这看起来有点傻。我可以合并这些行，为什么不直接说，从你的代码中获取，比如x乘以y，但即使这样也有点过于挑剔，因为从代码中你可以大致看出来，所以到某个时候，我们可能甚至不需要对此进行注释。
- en: so let's just simplify as such let's go，ahead now and compile this，make come
    on make truncation。all right it compiles okay and i like，how we used a float here
    that does feel。correct so let me run truncation，and let me go ah**d and type in
    for，instance 4 for x。and 2 for y okay i like that it's 2。000，so that's the correct
    math，x is 1，y is 2 and it's 0。0000。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们就这样简化一下，接下来我们编译这个程序，`make`，来吧，`make truncation`。好的，它编译成功，我喜欢我们在这里使用浮点数，这感觉正确。让我运行`truncation`，然后我去**输入**，比如说x输入4，y输入2，好的，我喜欢这个结果是2.000，所以数学是正确的，x是1，y是2，结果是0.0000。
- en: all right well maybe that was just a，about，uh how about two thirds two divided
    by。three huh that's not right，either all right how about four thirds，for the x
    so。![](img/cebeed9e0b28f665c194a66b2d3ef30a_17.png)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许这只是个小问题，嗯，二分之三，怎么说呢，这不对，怎么会是四分之三，给x呢。![](img/cebeed9e0b28f665c194a66b2d3ef30a_17.png)
- en: four thirds okay it's closer，of a，it's fine，but this is a logical bug like i've。somehow
    used c code improperly so what，might be going on，here y is one divided by two
    and two。![](img/cebeed9e0b28f665c194a66b2d3ef30a_19.png)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 四分之三，好吧，接近，没问题，但这是一个逻辑错误，就像我不知怎么地不当使用了C代码。那么这里可能发生了什么呢，y是1除以2和2。![](img/cebeed9e0b28f665c194a66b2d3ef30a_19.png)
- en: divided by three both apparently，zero followed by zero six zeroes after。the
    decimal point and even four，thirds gives me 1。00000，instead of 1。33333。because
    with and they don't like，recognize like decimals so，like so fourth four thirds
    question。three only goes into four one，use like，a double，if you want like the
    actual decimal yeah。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除以三的结果显然是零，后面跟着零，后面有六个小数位，甚至四分之三给我的是1.00000，而不是1.33333。因为在这种情况下，它们不喜欢像小数这样的东西，所以像四分之三的问题，三只能整除四一次，想要实际小数就用双精度。
- en: exactly this one's more subtle than the，mistakes i've made before but。c like
    most programming languages is，going to take you literally。![](img/cebeed9e0b28f665c194a66b2d3ef30a_21.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确切地说，这个比我之前犯过的错误更微妙，但C语言像大多数编程语言会字面上处理你输入的内容。![](img/cebeed9e0b28f665c194a66b2d3ef30a_21.png)
- en: so if on the right hand side of this，expression on line 11。![](img/cebeed9e0b28f665c194a66b2d3ef30a_23.png)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果在右侧的这个表达式上，行11。![](img/cebeed9e0b28f665c194a66b2d3ef30a_23.png)
- en: i am literally doing x divided by y，you first have to ask yourself well what，is
    the type of x，ants。going to get back，an integer as your answer so if you do 1，divided
    by 2，yes mathematically that's 0。5，an，works，is it truncates everything after the，correctly，but
    because you cannot fit floating，points。and numbers thereafter in an integer you，get
    you lose，all of those digits after the decimal。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上是在做x除以y，你首先要问自己，x的类型是什么。答案将返回一个整数，因此如果你做1除以2，数学上是0.5，确实可以，但它会截断所有小数点后的部分。然而，因为你无法将浮点数和之后的数字放入整数中，所以你会失去小数点后的所有数字。
- en: point because you can only fit，integer，it's not relevant that i'm saving the，that's
    too late。the math has already been done on the，right hand side and so yes i'm
    storing。an integer in a float so i can print it，as a float but it's too late everything，thrown。away
    so what are the implications of，this or how could i fix well。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你只能适配整数，所以我保存的这个没关系，太晚了。数学运算已经在右侧完成了，所以是的，我在一个浮点数中存储了一个整数，因此我可以将其打印为浮点数，但一切都太晚了，所有数据都被丢弃了。那么这有什么影响，或者我该如何修复呢？
- en: i could go through and just change all，of this right like well if the problem。is
    that x and y are ints well let me，just change them to floats and change，this up
    here，and so forth。that would fix the problem but that's，kind of a heavy-handed
    solution to this，your code。you can instead be a little more clever，and you can
    convince，float。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以逐一更改所有这一切，比如说，如果问题是x和y是整数，那么我就把它们改成浮点数，像这样更改，这样就可以了。这会解决问题，但这是一个过于粗暴的解决方案。你可以更加聪明一点，可以说服浮点数。
- en: by something known as casting so i can，actually go in here，and using a new syntax
    i can say float y。and i can even for good measure but it's，not strictly necessary
    also do it to x。you can and c cast or type，cast one data type to another by，literally
    in parentheses just putting。the new data type that you want，and if it makes mathematical
    sense for，one to be converted。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一种称为强制转换的方式，所以我实际上可以在这里，使用一种新的语法，我可以说float y。我甚至可以为了保险起见，但这并不是严格必要的，也对x这样做。你可以在C语言中通过在括号中放入你想要的新数据类型，强制转换或类型转换一种数据类型到另一种，如果这样转换在数学上是合理的。
- en: into the other the computer will do it，for you so in this way。i'm telling the
    computer convert x to a，float convert，y to a float then do the math and so。before
    when i typed in 1，and 2 respectively for x and y now it's，kind of like i typed
    in 1。0，and 2。0 and 1。0 divided by 2。0，is going to be mathematically 0。5，but because
    x and y now were converted。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机会为你完成其他操作，所以通过这种方式。我是在告诉计算机将x转换为a，float将y转换为一个float，然后进行数学运算。在之前，当我分别输入1和2作为x和y时，现在就像我输入了1.0和2.0，而1.0除以2.0，数学上是0.5，但因为x和y现在被转换了。
- en: in advanced to floats，the answer is going to remain a float，0。5。and that's what's
    going to get stored in，z and ultimately printed。so if i rerun truncation having
    now，fixed this problem，let me do dot slash truncation type in 1。type in 2。i don't
    have to type the，point 0 myself the computer is doing，that for me but via these。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换为浮点数之后，答案将保持为浮点数0.5。这将存储在z中，并最终被打印出来。所以如果我重新运行截断，已经修复了这个问题，让我输入`./truncation`，输入1，输入2。我不必自己输入小数点0，计算机为我做了这一切。
- en: casts in parentheses now i see that the，answer is indeed。![](img/cebeed9e0b28f665c194a66b2d3ef30a_25.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的类型转换，现在我看到答案确实是。![](img/cebeed9e0b28f665c194a66b2d3ef30a_25.png)
- en: 0。5 all right，so we seem to have now some very basic，low-level control。over
    what you can do with the program，let's now add back all of the fancy。features
    that we had from scratch last，week so we can start making。more interesting programs
    so variables，sugar，is also amongst these features here so。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们似乎现在对程序有了一些非常基本的低级控制。让我们现在重新添加上周从头开始的所有高级特性，这样我们就可以开始编写更有趣的程序。因此，变量糖也是这些特性之一。
- en: recall from last week，when we wanted to have a variable called，counter set equal
    to zero。we can go ah**d and define it like this，in c starting today，we're going
    to instead say something。like counter equals zero，but we additionally need to
    specify the，data type of that variable。and we need to end our thought with a，semicolon
    so whereas we said set counter。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上周，当我们想要创建一个名为`counter`的变量并将其设置为零时。我们可以这样定义它，在C语言中，从今天开始，我们要说的是，`counter`等于零，但我们还需要指定该变量的数据类型。并且我们需要用分号结束我们的语句，因此我们所说的设置`counter`。
- en: to zero like this last week，now it's going to translate quite simply，to this
    on the right hand side。well what comes after that well if we，wanted to increment
    a counter variable，last week by one。adding one to it we used quite simply，this
    puzzle piece this week we need to，be a little more。explicit and say something
    like this，counter equals counter plus one。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 像上周那样设置为零，现在这将在右侧简单地转换为这个。那么接下来会发生什么呢？如果我们想要将上周的计数器变量增加1，加1，我们很简单地使用了这个拼图块。本周我们需要更明确一点，并说类似于`counter`等于`counter`加1。
- en: and semicolon to finish the thought now，this might seem very，counter，doesn't。work
    logically but that's not the equal，sign in this case，in c as with other languages
    we'll。encounter the equal sign is the，assignment operator from right，plus 1，the
    left，result。in counter thereafter effectively，increasing its total by one，now
    this is a very common operation in。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 并用分号来结束这个语句，现在这可能看起来很奇怪，`counter`并不在逻辑上工作，但在这种情况下，这不是等号。在C语言中，与其他语言一样，我们会遇到等号，它是赋值运算符，从右侧赋值给左侧，结果将`counter`增加1，因此有效地增加其总数。现在这是一个非常常见的操作。
- en: programs we'll see over the term where，you just want to add something up。because
    you want to keep track，of the count of something so it turns，out there's some
    syntactic。sugar which means there's a different，way of doing this syntactically，that
    doesn't give you any new。capabilities that you didn't already，have in c，it just
    makes it marginally more。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在本学期会看到你只想加一些东西，因为你想跟踪某种计数，因此发现有一些语法糖，这意味着有一种不同的语法方式来做这件事，它并没有给你在C语言中没有的任何新功能，只是稍微让输入更愉快或更快。
- en: pleasant or quicker to type，so this line of code in c is identical，to saying
    this，one。semicolon means take the variable on the，left and just add one to it。and
    it's slightly more succinct and it，just makes your code a little more，readable
    because it's just。fewer things for us humans to have to，further，additional syntactic
    sugar exists。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这行代码在C语言中与这样说是相同的。一个分号意味着取左侧的变量并加1。它稍微简洁一点，并且让你的代码更具可读性，因为人类需要处理的东西更少。还有更多额外的语法糖存在。
- en: whereby you don't even need to type this，you can instead just do counter plus。plus
    counter plus plus is the shortest，hand notation in c，for just adding one to a
    variable。all right besides variables what else do，we have in our toolkit as of
    last week，week。the notion of course of conditions a，condition was like a fork
    in the road。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要键入这个，你可以直接使用`counter++`。`counter++`是在C语言中为给变量加1的最简写法。好的，除了变量之外，上周我们还有什么工具呢？当然是条件的概念，条件就像是道路上的分叉。
- en: that could allow you to do this thing，altogether，in scratch for instance if
    we wanted。last week to compare two variables，x and y for inequality is x less
    than y。and if so say x is less than y how can，we translate this to c，well the
    syntax is going to be quite。simply this a little new，some new stuff some more
    parentheses，some more curly braces。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以让你在Scratch中做这件事。例如，如果我们想要比较上周的两个变量`x`和`y`是否不相等，`x`小于`y`。如果是这样的话，`x`就小于`y`，我们如何将其翻译为C语言呢？那么语法将会非常简单，这里有一些新的内容，一些新的括号，一些新的花括号。
- en: but it kind of visually looks the same，albeit in text form，i literally say if
    a space then in。expression，recall those from last week x less than，y is my boolean
    expression。then notice i use an open curly brace，just leaving a blank，like i might
    have。last week and in fact let's put the，equivalent line of code here。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但在视觉上看起来有点相同，尽管以文本形式，我字面上说，如果是空格，那么在表达式中，回想一下上周`x`小于`y`是我的布尔表达式。然后注意我使用一个开放的花括号，留一个空白，就像我可能在上周做的那样，事实上让我们在这里放入等效的代码行。
- en: print out using printf x is less than y，backslash n so we've already done that，translation
    before。say is just like printf just like if now，is like if，strictly speaking especially
    if you've。programmed before you do not need，these two curly braces if you only
    have，one line of code。inside of the condition however，stylistically for cs50，and
    for style 50 sake always include。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`printf`打印出`x`小于`y`，换行符，所以我们之前已经完成了那个翻译。说就像`printf`，就像`if`，现在就像`if`，严格来说，特别是如果你之前编程过，你在条件内部只需一行代码时，并不需要这两个花括号。然而，从风格上讲，为了CS50和风格50的缘故，始终包含。
- en: these curly braces nonetheless，and on their own lines all right what，can do
    if。else and we can go either one way in the，fork or the other way。in the fork
    in c the corresponding code，is going to look like this so it's，almost the same
    as before。i've just added else and then another，curly brace and a closed curly
    brace。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些花括号，尽管它们在自己的行上，好的，如果我们可以这样做`if...else`，我们可以在分叉的一个方向走，也可以在分叉的另一个方向走。在C中，相应的代码看起来像这样，所以几乎和之前一样。我只是添加了`else`，然后是另一个花括号和一个关闭的花括号。
- en: and let me just add in the printfs and，you can see that in c this is really，version
    of。what was very graphical last week but，the idea is the same you just got to。start
    to recognize where the parentheses，go where the curly braces go the，semicolons
    and all that。sort of visual stuff all right let's，make one more，scratch and uh
    comparison here was one。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我添加一些`printf`，你可以看到在C中这实际上是上周非常图形化的版本，但理念是一样的，你只需开始识别括号放在哪里，花括号放在哪里，分号和所有那种视觉元素。好了，让我们再做一个`Scratch`和比较，这就是一个。
- en: where i said if x is less than y，say x is less than y else if x is，greater than
    y，y，scratch and c。diverge because scratch is meant to be，very user friendly and
    not require long。explanations of assignment operators，for，assignment c uses the
    equals on，uh no sorry rewind mit，c。uses the equal sign for assignment from，left
    to right but this means equality，difference here。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我说`if x`小于`y`时，`say x is less than y else if x is greater than y，y`，Scratch和C的分歧，因为Scratch旨在非常用户友好，不需要对赋值操作符进行长时间的解释。C使用等号进行赋值，呃，不，抱歉，回到麻省理工学院，C使用等号从左到右进行赋值，但这意味着相等性之间的差异。
- en: everything is a line-by-line translation，although we can put elsif on the same。line
    and else if on the same line，except here's kind of a stupid work。around right
    in some sense humans，point，we've already used the equal sign for。assignment what
    do we use now for，equality，well mit ignored that problem and just。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都是逐行翻译，虽然我们可以将`elsif`放在同一行，而`else if`也可以放在同一行，除了这里有点愚蠢的变通方法，从某种意义上说人类，我们已经使用等号进行赋值，我们现在用什么来表示相等呢，嗯，麻省理工学院忽略了这个问题，只是。
- en: used a single equal sign for equality，computer scientists inventing c and，subsequent
    languages。when comparing two values on the left，and right for equality，use two
    equal signs just because one。left，two equal signs is equality comparisons，are
    these two values equal。but you know what this is not，necessarily well designed，it
    is correct logically both my scratch。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个等号表示相等，计算机科学家在发明C语言及其后续语言时。当比较左边和右边两个值的相等性时，使用两个等号，仅仅因为一个。左边，两个等号是相等性比较，这两个值是否相等。但是你知道，这不一定设计得很好，从逻辑上讲这是正确的，我的Scratch。
- en: code and my c code is correct，but can anyone make an observation as to，why。the
    code is not necessarily well，designed i'm doing，a little more work than i need
    to i。could tighten this code up a little bit，i could type slightly fewer characters。and
    accomplish the same，correct decision making，is not，perfectly designed uh great。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和我的C代码是正确的，但有没有人能观察到，为什么。代码不一定设计得很好，我做的工作比我需要的多一点。我可以稍微简化一下这段代码，我可以输入稍微少一些字符。并且达到相同的效果，正确的决策并不完美设计，呃，非常好。
- en: yes so you used elsif，two times you could have used else in，the end。without
    the condition really good，observation i'm using elsif twice which。logically is
    fine this code is correct，questions，but consider this if x is less than y is，the
    road。else if x greater than y is the second，what's the only other possibility。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你使用了`elsif`两次，实际上可以在最后用`else`而不加条件。很好的观察，我用`elsif`两次在逻辑上是正确的，但请考虑，如果`x`小于`y`，那是什么路？如果`x`大于`y`呢？唯一的其他可能是什么？
- en: logically in the world of math，equal to，there's no reason to belabor the point。and
    ask that third question，explicitly let's simplify the code and，marginally better
    design it as。propose。![](img/cebeed9e0b28f665c194a66b2d3ef30a_27.png)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学的世界中，逻辑上`equal to`没有必要过于详细地强调这一点。显然让我们简化代码，稍微设计得更好，作为提议。![](img/cebeed9e0b28f665c194a66b2d3ef30a_27.png)
- en: which isn't that much cleaner isn't that，much shorter but it does avoid asking
    an。additional question so instead，of maybe three questions being asked now。there's
    only two and frankly if you're，writing a lot of code or doing this，again and again
    and again。that kind of difference might very well，add up and indeed give us，the
    ability to。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有更清晰，也没有更短，但确实避免了问一个额外的问题。因此，现在可能问三个问题的情况变成了两个。坦率地说，如果你编写大量代码或者一次又一次地执行这个，那种差异可能会累积，确实能给我们带来能力。
- en: use these conditions let's actually try，converting this into a program let me
    go，in advance。let me go ah**d and copy a file that i，came with today，called conditions。c
    and this is one of。the files available on the course's，website let me just open
    this if only，because it's kind of an。uh literal translation translation of，the
    scratch code to see，top here。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些条件，我们实际上来尝试将其转换为程序，让我提前进行。让我先**复制**一个我今天带来的文件，名为`conditions.c`，这是课程网站上提供的文件之一，让我打开这个文件，看看这是否算是对`scratch`代码的字面翻译。
- en: i've and now let me show you what i've，actually done over here。so i've opened
    up a file that i wrote in，advance called conditions。c。and i have at the top of
    the file my two，includes as usual，and then down here i have pretty much。what we
    just saw on the slide plus，two calls or uses of get ins。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在来展示我在这里做了什么。我打开了一个我提前写的文件，名为`conditions.c`，在文件的顶部我有我通常的两个**包含**，然后在这里我几乎有我们在幻灯片上看到的内容，加上两次`get
    ins`的调用。
- en: and then i'm just asking this question，down here if x less than y。![](img/cebeed9e0b28f665c194a66b2d3ef30a_29.png)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我在这里问这个问题，如果`x`小于`y`。![](img/cebeed9e0b28f665c194a66b2d3ef30a_29.png)
- en: else if x greater than y else go ah**d，and do the following，the scratch。translation
    let me go ah**d and make，conditions which again conditions。c is，the name of the
    file。no apparent mistakes so let me go ah**d，and run dot slash conditions。enter
    and x will be 1 y is 2 and indeed，x is less than y if i go ah**d and run。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if x`大于`y`，否则去**做**以下的`scratch`翻译。让我先**制作**条件，`conditions.c`是文件名。没有明显的错误，所以让我去**运行**`./conditions`，输入`x`将是`1`，`y`是`2`，确实`x`小于`y`，如果我去**运行**。'
- en: this this time for instance with，how about 10 and 5 x is greater than y。and
    then lastly if i go ah**d and run，this with 4 and 4。![](img/cebeed9e0b28f665c194a66b2d3ef30a_31.png)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，例如`10`和`5`，`x`大于`y`，然后最后如果我去**运行**这个`4`和`4`。![](img/cebeed9e0b28f665c194a66b2d3ef30a_31.png)
- en: x is equal to y so i now have a c，program that is actually adding，conditions
    for me。which is uh adding conditions for me，make，decisions and print out one thing，potentially。or
    the other but let me do something，slightly fancier，let me go ah**d and open up
    another pro。![](img/cebeed9e0b28f665c194a66b2d3ef30a_33.png)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`等于`y`，所以我现在有一个`c`程序，实际上为我添加了条件，这实际上是为我添加条件，做出决策，并可能打印出一个东西，或另一个。但让我做一些稍微复杂的事情，让我先**打开**另一个程序。![](img/cebeed9e0b28f665c194a66b2d3ef30a_33.png)'
- en: scratch，suppose i want to write a program called，agree。c，that simulates the
    idea of like these。when signing into，when using a piece of software for the，first
    time or the like or even when i。deleted a file before i had to type in，yes or
    why，in order to proceed let me go ah**d and。include cs50。h at the top，let me go
    ah**d and include standardio。h。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: scratch，假设我想写一个名为`agree.c`的程序，模拟这些想法。当登录时，或者使用软件的第一次，或者在我之前删除文件时，我必须输入`yes`或`why`才能继续，让我先**包含**`cs50.h`在顶部，让我先**包含**`stdio.h`。
- en: at the top and then my int main void，which is copy paste from before。and now
    let me do this let me go ah**d，and get not an int from the user and not。even a
    word let's keep it simple and，just ask the user for，y or n for yes or no let me
    go ah**d and。give myself a char，and i'll call it c but i could call it，anything
    like answer。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，然后我的int main void，这是从之前复制粘贴过来的。现在让我这样做，让我去ah**d，并且不从用户那里获取一个整数，甚至不是一个单词，让我们简单点，只问用户y或n表示是或否，让我去ah**d并给自己一个字符，我叫它c，但我可以叫它任何东西，比如answer。
- en: but c seems reasonable if i only have，function，getchar and let me just ask do
    you agree。question mark and then let me go ah**d，and compare this so if c，equals
    y then。let me go ah**d and print out agreed，backslash n，else if c equals n，instance。not
    agreed now unfortunately i've made a，couple of mistakes here that one at。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我只有getchar函数，c看起来是合理的，让我问你同意吗？问号，然后让我去ah**d，比较一下。如果c等于y，那么让我去ah**d并打印出同意，\n，否则如果c等于n，表示不同意。现在不幸的是，我在这里犯了几个错误，其中至少一个可能比其他的更明显，可能引入了。
- en: least one of which might be a little，more obvious than the other，might have
    introduced。anyone at all yeah how about uh olivia，the，for the boolean you did
    you used a。single equal sign instead of the double，for both good so i use the
    single equal，that。and this is because c，data types，all this time i've been using
    double。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以，嗯，如何处理Olivia，布尔值你使用了单个等号而不是双等号，因此都很好，所以我使用了单个等号。这是因为c数据类型，我一直在使用双等号。
- en: quotes for strings but it turns out，in c you have to use single quotes when。you're
    comparing individual characters，so i'm going to go in here。and change only the
    quotes around why，and n to be single quotes why。because i'm now dealing with the
    world，of chars chars are，when you are。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的引号，但事实证明，在C语言中，当你比较单个字符时，你必须使用单引号。所以我会在这里修改，将y和n周围的引号改为单引号。为什么？因为我现在正在处理字符的世界。字符是在你。
- en: talking about characters you need to，quote them literally like this。the variable
    name c doesn't need to be，quoted but y and n do need to be quoted。but i don't
    need to change any of my，other quotes in the file。because those are still strings
    of text，that is actual phrases or。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论字符时，你需要像这样逐字引用它们。变量名c不需要引用，但y和n需要引用。但我不需要改变文件中其他的引用，因为那些仍然是文本字符串，实际的短语或。
- en: sentences so let me go ah**d and try，running make agree，it compiles okay let
    me go ah**d and run。dot slash agree，do i agree let me go ah**d and type in y，agreed
    i like that so let me try。n no not agreed oh and i left off，a backslash n so let
    me fix that real，quick just for consistency。let me recompile my program and pretend，that
    never happened but let me very，reasonably now do this。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我去ah**d试着运行make agree，它编译得很好。让我去ah**d运行./agree，我是否同意？让我去ah**d输入y，同意，我喜欢这样，所以让我试试n，不同意，哦，我忘了一个\n，所以让我快速修复一下，只是为了保持一致性。让我重新编译我的程序，假装这一切从未发生过，但让我现在非常合理地这样做。
- en: dot slash agree i want to agree and yes，capital y，huh nothing happened what
    about n，capital n。nothing happened but the program still，works if i do lower case
    it works。and if i do lower case there it works so，what's going on well again the
    computer。is only going to take you literally and，even though we humans might be
    oh it's。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ./agree我想要同意，是的，大写Y，呃，没发生什么，那n呢，大写N。没发生什么，但程序仍然正常运行，如果我使用小写字母也能工作。如果我在这里使用小写字母也能工作，那到底发生了什么呢？好吧，计算机只会逐字理解你，即使我们人类可能会觉得。
- en: fine it's uppercase or a lowercase，ask，two questions as follows we could do，something
    like else if c。equals equals capital y in single quotes，you could imagine again
    saying agreed，like this。but just like last week when i started，copying and pasting
    scratch blocks like。that's probably not very good design，similarly this block
    of code lines 11。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是大写还是小写，问两个问题如下：我们可以做一些类似的else if c等于大写Y并用单引号括起来，你可以想象再次说同意，就像这样。但就像上周我开始复制和粘贴Scratch块一样，这可能不是很好的设计，类似地，这段代码的第11行。
- en: through 14 is almost identical，one of them，and let's see if we can't combine
    these。thoughts let me express if c，equals equals y or c equals equals，capital
    y。and indeed you can use this vertical bar，operator，which is the logical or operator
    and，actually say。two questions at once it turns out you，can do this with the notion
    of and。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 14行几乎是相同的，我们来看看是否能结合这些想法。让我表达一下，如果c等于y或c等于大写Y。实际上你可以使用这个竖线运算符，它是逻辑或运算符，并且实际上可以一次问两个问题。结果证明，你可以使用与的概念来实现这个。
- en: a logical and by using ampersand，ampersand more on those another time。but two
    vertical bars is the equivalent，of just saying if this。on the left or this on
    the right and now，if i save and recompile。the program with make agree and do dot，slash
    agree，you'll see that i can type in y in，lowercase。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“&&”逻辑与，更多的将在另一次讨论。但两个竖线是相当于说“如果左侧这个或右侧这个”，现在如果我保存并重新编译程序，运行`make agree`，然后执行`./agree`，你会看到我可以输入小写的y。
- en: or y in uppercase and now it works，so again it would have been correct to，if
    but again。not necessary because i can combine，these thoughts and make my program。better
    designed and notice too all this，time i've been very，religiously indenting every
    time i'm。inside of curly braces，indenting every time i have an if，condition or
    an elf。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者用大写Y，这样它就能工作。因此，如果我可以结合这些思路并让我的程序更好设计，注意到这一点，我一直在每次进入花括号时，严格缩进，每次有if条件或else时也如此。
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_35.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_35.png)'
- en: style，aesthetics as well all right well now，let's consider，that we have the
    ability not only to。express conditions but how about also，these things called
    loops well turns out。in scratch we had very straightforward，loops do the following
    forever。c is a little clunkier there's no，forever keyword in c，but we can mimic
    this idea as follows，c。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 风格和美学好吧，现在让我们考虑，不仅有能力表达条件，还有这些称为循环的东西。结果，在Scratch中我们有非常简单的“永远做以下事情”循环。C语言则有点笨重，C中没有“永远”关键字，但我们可以如下模拟这个概念。
- en: is actually to say while which kind of，has the right semantics in english like。while
    something is the case do this，but you have to be even more explicit，you can't
    just say while。out in c that，while similar to a condition is，constantly asking
    a question to decide。whether or not to continue very similar，again to a condition
    with its own，boolean expression。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是说“当...时”，在英语中具有正确语义，像是“当某事成立时就做这个”。但你必须更加明确，不能仅仅说“当”。在C中，“当”类似于一个条件，它不断地询问一个问题来决定是否继续，这与它自己的布尔表达式非常相似。
- en: so with while in c you have to have，parentheses after the word while。and you
    have to ask a question in those，like，like，but this is a bit of a corner case in。the
    sense that if you want to do，something forever who cares what the。question is
    you just want the answer，always to be yes or in computer terms。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，使用while时，你必须在“while”之后有括号，并且必须在括号内询问一个问题。这是一个小的边缘案例，因为如果你想做某事永远，谁在乎问题是什么，你只想要答案始终为“是”，或者在计算机术语中。
- en: always to be true and the most blunt way，to express，word true。so even though
    this looks a little weird，this in c is how you deliberately induce。what we'll
    call an infinite loop that，never stops，true，you don't even have to ask a more。complicated
    question you could put a，the like，but if you just want something to happen。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 始终为真，最简单的方式来表达“真”。虽然这看起来有点奇怪，但在C中，这就是你故意引发一个永不停止的无限循环的方式，你甚至不需要问一个更复杂的问题，你可以简单地让某事发生。
- en: forever this is the most canonical way，to express something forever well what。if
    you want to do something，finitely many times well we can do that，in c as well。using
    what's going to be called a for，loop uh or a，while loop well let's consider both
    of。these uh in turn，the most like，mechanical manual way i can think of is。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: “永远”是表达某事永恒的最经典方式。如果你想做有限次数的事情，我们也可以在C中做到。使用我们将称之为for循环或while循环的方法，我们逐一考虑这两者，最机械的手动方式我能想到的是。
- en: like just count on my fingers right like，somehow or 10，minimally on my or maximally
    on my hands。so how can i do something finitely many，times in c，well i have at
    my disposal variable so，counter。initialize it to zero semicolon and the，data type
    will be int because i just。need to count much like on my fingers，but you know
    what counter is a little。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我用手指头计数一样，最少在我的手上计数十次。那么我该如何在C中做有限次数的事情呢？我可以使用变量来做计数器，将其初始化为零，数据类型为int，因为我只需要像在手指上计数那样。
- en: verbose programmers whenever they're，counting frequently，just counting up from
    zero on up they'll。often just use i，string，you don't want to do that always in
    your，code it's sometimes better for your。variables to be more descriptively named，but
    for a stupid variable that's just。going to count from 0 on up let's just，keep
    it simple and call it i，i have to ask。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 冗长的程序员在频繁计数时，通常会从零开始计数。他们往往会直接使用 i，字符串，你并不总是想在代码中这样做，有时让你的变量名称更具描述性更好。但对于一个只会从
    0 开始计数的简单变量，我们不妨简单点，称它为 i，我得问。
- en: a question because i don't want this，running forever i want it running 50。times
    what question could i ask，well why don't i just check well i is，less than 50。so
    it's like counting up on 50 fingers，through，than 50，do the following what do i
    want to do i。want to keep printing out hello world，hello world hello world，iteration。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有个问题，因为我不想让这个无限运行，我希望它运行 50 次。我可以问什么问题呢？好吧，为什么我不检查一下 i 是否小于 50。就像在 50 根手指上计数，直到
    50，然后执行以下操作，我想做什么呢？我想不断打印“你好，世界”，你好，世界，你好，世界，迭代。
- en: of this loop on every cycle of this loop，i need to do one more thing。mathematically
    i need to add another，finger add another finger。or in other words i need to add
    one to i，so let me go ah**d and set i。equal to whatever it is now plus one but，again
    we have some syntactic sugar just，tighter。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环的每个周期，我需要做一件事。从数学上来说，我需要再加一个手指，换句话说，我需要给 i 加一。所以让我去把 i 设为当前值加一，但我们又有一些语法糖，让它更简洁。
- en: i could do i plus equals one or even，more succinctly，i plus plus so even though
    this is way。more annoying to implement than in，you want，in c we have all of the
    building blocks。now with variables，notion，of repeating some finite number of times。but
    there's another way to do this，and as you might have discovered with。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用 i 加上等于一，甚至更简洁地用 i 加一，所以尽管这在实现上比在 C 中要烦人得多，但我们现在有了所有的构建模块。现在有了变量，重复某个有限次数的概念。但是还有另一种方法可以做到这一点，正如你可能已经发现的那样。
- en: problems at zero there's different ways，to achieve the same，do this。i could
    just start counting at one and，count up through，50。so there's no greater than
    or equal。sign key on your keyboard most likely or，less than or equal to so in
    c。as with other languages you just use two，characters you do less than sign。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始有不同的方法来实现同样的功能。我可以从一开始计数，一直计数到 50。所以你的键盘上大概没有大于或等于符号，或者小于或等于符号。因此在 C 中，像其他语言一样，你只需使用两个字符，使用小于符号。
- en: followed by the equal sign and that，expresses less than or equal to。so this
    is also correct if i start，counting at one i need to count，through 50。you can
    do this don't do，this this is unconventional，and like programmers will conventionally。per
    last week when we started always，bulbs off，they'll instead start at zero and count，up
    250。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 后面跟上等于号，这表示小于或等于。所以如果我从一开始计数，到 50 也是正确的。你可以这样做，但不要这样做，这不符合常规，程序员通常会在上周开始时总是把灯泡关闭，他们会从零开始计数，到
    250。
- en: which gives you 0 through 49 implicitly，so do this，not that but this does speak
    to the fact。that you can solve problems in so many，different ways there's another
    way，counting，being。we have to do i minus minus instead of i，plus plus so again
    that's three。different ways to solve the same problem，and again you'll start to
    have the right。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这隐含给你 0 到 49，所以做这个，而不是那个，但这确实说明了你可以用许多不同的方法解决问题，还有另一种计数的方法。我们必须用 i 减一，而不是 i
    加一。所以这又是三种解决同一个问题的方法，而且你会开始拥有正确的。
- en: instincts and muscle memory and you'll，also start to see，common patterns in
    lecture code your tf。or teaching assistance code，books and references online there
    just，tend to be the ways to do things。all right，one more approach to loops here
    it turns，out there's another loop construct。that's a little more cryptic and it's，called
    a for loop，and it allows you to automate or rather。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉和肌肉记忆，你还会开始看到讲座代码中常见的模式，你的助教代码，书籍和在线参考资料，往往是做事的方式。好吧，这里还有一种循环的方法，结果发现还有另一种循环结构，这种结构更隐晦，称为
    for 循环，它允许你自动化或说得更准确些。
- en: a little more，concisely so for printf，hello world is going to get us one step。closer
    to printing hello world 50 times，but the for statement just like the。while statement
    comes with necessary，parentheses after it，but this time you can put more stuff
    in。the parentheses it's not just a boolean，expression，first the first thing in
    the parentheses。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再简洁一点，对于 printf，打印“你好，世界”将使我们更接近于打印 50 次“你好，世界”，但 for 语句就像 while 语句一样，后面必须有必要的括号，但这次你可以在括号中放更多内容，它不仅仅是一个布尔表达式，括号中的第一件事。
- en: is you can initialize，any variable you want to some value i，might say in counter
    equals zero or more。succinctly int，i equals zero semicolon but the way the，for
    loop looks it's a little funky you。can do multiple things on one line，the second
    thing inside of the，parentheses to a for loop。is a condition that you want to
    check，thing，in the parentheses of a for loop is an。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何变量初始化为某个值，我可能会说counter等于零，或者更简洁地，int i等于零分号，但for循环的样子有点奇怪。你可以在一行上做多件事，for循环括号内的第二件事是你想检查的条件，for循环括号内的事情是。
- en: update or an incrementation or，decrementation，or rather，let's just do i plus
    equals one or even。more succinctly，i plus plus this is perhaps the most，conventional
    way。in c and in other programming languages，to do something，50 times or a finite
    number of times。it's different looking from the things，we've seen thus far there's
    semicolons，in weirder places。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更新或递增或递减，或者说，让我们就用i加等于1，甚至更简洁地，i加加，这可能是C语言和其他编程语言中最常见的做某事的方法，50次或有限次数。这看起来与我们迄今为止所见的有所不同，分号出现在奇怪的地方。
- en: there's more stuff in parentheses so，overall。![](img/cebeed9e0b28f665c194a66b2d3ef30a_37.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中还有更多的东西，所以总体来说。![](img/cebeed9e0b28f665c194a66b2d3ef30a_37.png)
- en: but for now just realize this says，initialize i to zero，check the condition
    and if i is less。than 50 print hello world，then update i then check the condition，then，then。if
    it's less than print hello world so，the initialization of the variable，happens
    once。everything else happens again and again，and again until you've done this。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在只需意识到，这表示将i初始化为零，检查条件，如果i小于50，则打印“hello world”，然后更新i，然后检查条件，然后。如果它小于，打印“hello
    world”，所以变量的初始化只发生一次。其他一切都一次又一次地发生，直到你完成这个。
- en: some 50 times all right so with those，building blocks that's kind of it for。our
    translation of scratch into c，let's now start to build up some more。interesting
    programs and practice for，instance abstraction，so abstraction recall was this。problem-solving
    principle，whereby you can simplify otherwise more，complicated。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一共50次，好吧，因此有了这些构建块，我们的Scratch到C的翻译就差不多了，现在让我们开始构建一些更有趣的程序，并进行实例抽象，因此抽象回想一下是这个。问题解决原则，你可以简化否则更复杂的问题。
- en: details an abstraction is a，simplification on top of，more complicated details
    or，might say。so for instance let me go ah**d and，write a program here called meow。similar
    to last week but this time in c，and in order to，make a cat meow textually let
    me give。myself standard io。h at the top，in int main void down here，again i'm in
    a file called meow。c and。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 细节是抽象，这是一种在更复杂的细节之上的简化，或者可以说。所以例如，让我继续写一个名为meow的程序。类似于上周，但这次用C语言，为了让猫以文本形式“喵”，让我在顶部给自己添加standard
    io.h，在int main void这里，再次我在一个名为meow.c的文件中。
- en: i've included standardio。h，and int main void and now i'm going to。go ah**d and
    just do something like this，printf quote unquote meow backslash n，three times。let
    me save that file make meow，all right now dot slash meow and meow。meow meow all
    in text so not nearly as，last week，but it's it's correct but it's not very。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了standard io.h和int main void，现在我要继续做类似这样的事情，printf“喵”换行三次。让我保存那个文件，生成meow，好吧，现在点斜杠meow，喵喵喵，全是文本，所以没有上周那样神秘，但它是正确的，但并不是很。
- en: well designed，right because i'm repeating myself i，are bad，instincts but now
    we have the ability to。do things with loops，so let me actually delete this part
    of，the function and let me try to remember。from the example before if i want to
    do，something three times i could use a，lines of code。let me do this int i equals
    zero i，less than three i plus plus。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好，因为我在重复自己，这是坏的本能，但现在我们有能力使用循环，所以让我实际上删除这个函数的部分，试着回想一下之前的例子，如果我想做某事三次，我可以使用几行代码。让我这样做：int
    i等于零，i小于三，i加加。
- en: so cryptic but this again is sort of the，de facto way。![](img/cebeed9e0b28f665c194a66b2d3ef30a_39.png)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样说有点晦涩，但这又是事实上的方式。![](img/cebeed9e0b28f665c194a66b2d3ef30a_39.png)
- en: of doing something a finite number of，times initialize some variable，keep。incrementing
    your variable again and，again so that it executes a total of，that many times。![](img/cebeed9e0b28f665c194a66b2d3ef30a_41.png)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 做某事有限次数，初始化某个变量，保持。不断递增你的变量，使其总共执行那么多次。![](img/cebeed9e0b28f665c194a66b2d3ef30a_41.png)
- en: melo，recompile，meow by make meow let me do dot slash，meow and voila。now the
    program is arguably better，designed but let me take this one step。further recall
    that the trajectory last，week was to not only implement meow。more uh with better
    design without，repeating yourself thereby using a loop。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: melo，重新编译，meow 通过让我执行 dot slash，meow，然后 voila。现在这个程序可以说设计得更好了，但让我进一步说明。这一周的轨迹不仅是实现
    meow，更是以更好的设计来完成，而不必重复自己，因此使用循环。
- en: but remember we introduced the，abstraction that was a custom puzzle，piece called
    meow，make our own。functions as well and the syntax is，going to take a little getting
    used to。but let me go ah**d and do this let me，get rid of my printf here。and at
    the bottom of my file actually at，the top of my file，void，meow void which is very
    cryptic for。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请记住，我们引入了一个抽象概念，那是一个名为 meow 的自定义拼图块，我们也可以创建自己的函数，语法会需要一点时间来适应。但让我去 ah**d 这样做，让我去掉这里的
    printf。在我文件的底部，实际上在我文件的顶部，void，meow void，这对于。
- en: today but again this is fine to be，boilerplate copy pasted for now。let me go
    ah**d and just print f meow，here even though we haven't explained。![](img/cebeed9e0b28f665c194a66b2d3ef30a_43.png)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 今天但这对于现在来说，复制粘贴是没问题的。让我去 ah**d 这里打印 f meow，即使我们还没有解释。![](img/cebeed9e0b28f665c194a66b2d3ef30a_43.png)
- en: and won't explain today，what this keyword void means what i've，done in lines
    three through six is。create my own custom function，c does not come with a function
    called。meow cs50 is library does not come with，a function called meow，but now
    thanks to me there exists a。in life，is just to print out meow but what's。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 今天不会解释这个关键字 void 的含义，我在第三到第六行中做的是创建我自己的自定义函数，C 语言并没有提供一个名为 meow 的函数，CS50 的库也没有提供一个名为
    meow 的函数，但现在多亏了我，这个函数存在于生活中，只是打印出 meow，但是什么呢？
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_45.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_45.png)'
- en: cool about this now，is that down here just like with scratch，last week i can
    now。call a function called meow and my，rather，says what it does by just by way
    of the，function's name。and let me go ah**d now and compile this，make meow，so far
    so good dot slash meow and it。seems to work okay，but i don't love the fact that
    i've，implemented meow at the top of the file。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很酷的是，就像上周的 scratch 一样，我现在可以调用一个名为 meow 的函数，而我的，相当于说它的功能，只是通过函数名。让我去 ah**d
    编译这个，make meow，到目前为止一切顺利，dot slash meow，似乎工作得还不错，但我不喜欢我把 meow 实现在文件顶部这个事实。
- en: it's not a big deal，functions，at the bottom of the file why only，a teaching
    fellow。wants to understand your code from top，to bottom it's just human convention
    to，put the main program。the main function rather at the top of，your file，the problem
    is when i do this i'm going。to have created a problem for myself，when i run make
    meow，now darn it two errors generated。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么大不了，函数位于文件底部，为什么只有教学助理想从上到下理解你的代码？这只是人类的惯例，将主程序，主函数放在文件的顶部。问题是当我这样做时，我会为自己创造一个问题，当我运行
    make meow，现在出现了两个错误。
- en: and so there's a couple of bugs to be，solved but first brian，a question from
    the group there was a。question that came in from the chat，about，why it is that
    on like line five for。example right here you don't have a，semicolon at the end
    of the for loop and。on line 11 you don't have a semicolon at，the end of the function
    name。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有几个错误需要解决，但首先，布莱恩，来自小组的一个问题，聊天中有一个问题，关于为什么在第五行这里，你的 for 循环末尾没有分号，而在第十一行你没有在函数名末尾加分号。
- en: so why do some lines need semicolons at，the end of them but other lines don't。really
    good question why do some of，these lines not have semicolons but，others do。the
    short answer not to be glib is，honestly just because，the way the language was
    designed was。that you should generally，finish your thoughts when expressing，verbs
    or actions or functions。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么有些行需要在末尾加分号，而其他行则不需要？这是个好问题，为什么有些行没有分号而其他行有。简短的回答，虽然不是为了让人感到轻率，老实说，只是因为语言的设计方式是，你通常应该在表达动词、动作或函数时结束你的思想。
- en: with semicolons and we've seen that，after printf for instance we've just，seen
    that after meow。however when you're using other，programming constructs like，loops
    or like custom functions you don't。have semicolons there，why some humans years
    ago just decided，that we don't need semicolons in those。places and this is one
    of those things，that it will take a while to develop the。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分号，我们已经看到，例如在 printf 之后，我们刚刚看到在 meow 之后。然而，当你使用其他编程结构时，比如循环或自定义函数时，你就不需要分号了。为什么几年前一些人类决定在这些地方不需要分号？这就是一个需要时间来发展的事情。
- en: muscle memory and the，sort of mental model for recognizing，where those things
    go and don't。but thus far the only places we've seen，semicolons are at the ends
    of functions。like meow and printf here and now，parentheses，problem said，one and
    the first lab and so forth。you'll often want to refer back to，examples like these
    and the slides and。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 肌肉记忆和识别这些东西去哪里以及不去哪里的心理模型。但是到目前为止，我们看到分号的唯一地方是在函数末尾，比如`meow`和`printf`，现在是括号，问题是一个和第一次实验等等。您通常希望回顾像这样的例子和幻灯片。
- en: the references in your section，so that you can wrap your mind around，these patterns。so
    let me go ah**d now and solve the two，problems i seem to have created here。it's
    a little non-obvious but it's，reminiscent of what we've seen before。implicit declaration
    of function meow is，invalid in c99，c，the language we're using but it's just。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您部分中的引用，以便您能理清思路，这些模式。所以让我现在继续解决我似乎在这里创建的两个问题。虽然有点不明显，但它让人想起我们以前看到的内容。函数`meow`的隐式声明在C99中是无效的，C是我们正在使用的语言，但这仅仅是。
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_47.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_47.png)'
- en: getting confused，c is right now well why is that well let，me scroll up here。and
    let me make the point that frankly c，and in turn my compiler。they're not that
    bright like they're，explicitly，and the problem at the moment is that。when the
    compiler reads my code from，top to bottom left to right it is not，until line。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 变得困惑，C现在很好。那么为什么呢？让我向上滚动一下。坦率地说，C及其编译器并不聪明，它们显式地，当前的问题是，当编译器从上到下、从左到右读取我的代码时，直到第行。
- en: 11 that the meow function even exists，moment，frankly，just doesn't know what
    meow is because。it hasn't gotten to meow later and the，compiler is not smart enough。or
    not user friendly enough to read，everything first and then decide if。there's a
    problem it's only going to，read it once through top to bottom。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 11，`meow`函数甚至存在的那一刻，坦率地说，编译器并不知道`meow`是什么，因为它还没有处理`meow`，而编译器不够聪明，或者不够用户友好，不能先读取所有内容，然后决定是否有问题，它只会从上到下读取一次。
- en: and it's going to yell at you the moment，it encounters the problem so the。solution
    to this is quite simply，move the function to the top of your。file but again that
    just gets annoying，eventually because then you have to go。fishing for your main
    function which，file，or there's another way and we'll explain。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在遇到问题时立即对您大喊，所以解决这个问题的方法很简单，就是将函数移动到文件的顶部，但这最终会变得烦人，因为那样您就得去寻找主函数，或者还有另一种方法，我们会解释。
- en: this in due time too but you can also，copy the very first line only of your，custom
    function，main。and then to brian's question and that，with a semicolon so this is
    weird。this is what's generally known as a，prototype which is a hint，only it's
    sort of a clever way of。telling the compiler，there will exist a function called
    meow，but just not yet。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会在适当的时候完成，但您也可以只复制自定义函数`main`的第一行。然后回答布莱恩的问题，并且要加上分号，所以这很奇怪。这通常被称为原型，这是一个提示，只有它算是一种聪明的方式来告诉编译器，将会存在一个名为`meow`的函数，但现在还不存在。
- en: but know that it will and it's just kind，of a work around a common work around。for
    that particular problem all right so，let me go ah**d and make one more change。one
    more change here，suppose that i want to really finish off。this meowing example
    just like we did in，scratch whereby we，also allow meow to take some number。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但要知道它会的，这只是一个常见问题的变通办法。好吧，所以让我继续进行一个更改。再进行一次更改，假设我真的想完成这个`meow`示例，就像我们在Scratch中那样，我们还允许`meow`接受一些数字。
- en: of meows as input so i don't want to，function。![](img/cebeed9e0b28f665c194a66b2d3ef30a_49.png)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是`meow`，所以我不想要这个函数。![](img/cebeed9e0b28f665c194a66b2d3ef30a_49.png)
- en: meow，3 inside of my main function 3 there by，being the input to the meow function。i
    now need to change my custom function。![](img/cebeed9e0b28f665c194a66b2d3ef30a_51.png)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`meow`，在我的主函数中是3，成为`meow`函数的输入。现在我需要更改我的自定义函数。![](img/cebeed9e0b28f665c194a66b2d3ef30a_51.png)'
- en: just like i did last week，as follows it turns out and more on this，in the weeks
    to come，11。this function，long story short my custom meow function，today has no。return
    value it doesn't output anything，per se it instead only has a side effect。of printing
    visually on the screen but，it does have an input，input or。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我上周做的那样，结果证明更多内容将在接下来的几周中出现，11。简而言之，我的自定义`meow`函数今天没有返回值，它不会输出任何内容，实际上它只是有一个副作用，就是在屏幕上可视化打印，但它确实有一个输入。
- en: arguments you can literally do something，like the name of the type you want。and
    the name of the variable that you，want so suppose i want meow to take as。input
    some number we'll call it n，and i want to use that number in a loop。i could then
    do something like this，for int i gets 0 i is less than，printf。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以字面上做一些，比如你想要的类型的名称和你想要的变量名称，所以假设我想让 meow 作为输入一些数字，我们称之为 n，我想在循环中使用这个数字。我可以这样做，for
    int i 从 0 开始 i 小于 printf。
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_53.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_53.png)'
- en: with curly braces and now notice just，like last week with my final，implementation
    of now。![](img/cebeed9e0b28f665c194a66b2d3ef30a_55.png)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大括号，现在注意，就像上周我最终的实现一样。![](img/cebeed9e0b28f665c194a66b2d3ef30a_55.png)
- en: my custom function can take input as，denoted by the parentheses。it doesn't have
    output per se that's why，i'm leaving void here but again we'll，explain void more。in
    detail down the road but now i'm，using that input，this is a new。implementation
    in c i'm using the same，building blocks i'm using a for loop。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我自定义的函数可以像括号所示那样接受输入。它没有输出，因此我将这里留空，但我们稍后会更详细地解释 void，但现在我正在使用那个输入。这是在 C 中的新实现，我使用相同的构建块，使用一个
    for 循环。
- en: i've like before but instead of hard，coding three or 50 like i did earlier。now
    i'm actually going to go ah**d and，just plug in that variable。just like scratch
    allowed me to do as，well，what if i want to do something even。fancier you know
    what let me go ah**d，and do this suppose that we want to get，input from the user。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我像之前一样，但不是硬编码 3 或 50，就像我之前做的那样。现在我实际上会继续，将那个变量插入。就像 Scratch 让我做的那样，假设我想做一些更花哨的事情，你知道的，让我继续这样做，假设我们想从用户那里获取输入。
- en: but we really want them to provide a，specific type of input，let me go ah**d
    and introduce one other。type of loop and this one i'm going to，go ah**d and grab
    for my archives the，code that i brought。with me today and i'm going to go ah**d，and
    copy over a file。![](img/cebeed9e0b28f665c194a66b2d3ef30a_57.png)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们确实希望他们提供一种特定类型的输入，让我先去介绍另一种类型的循环，我将从我的档案中获取我今天带来的代码，并复制一个文件。![](img/cebeed9e0b28f665c194a66b2d3ef30a_57.png)
- en: called positive。c which is going to，value，so this too is on the course's website。let
    me just walk us through code that i，already wrote，here at the top of my file i'm
    including。some now familiar header files，and down here i'm including a prototype，that
    is a hint。for a function that's going to be called，quite simply get positive int。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会有一个值，因此这也在课程网站上。让我带你走过我已经写的代码，在我文件的顶部，我包含了一些现在熟悉的头文件，在这里我包含一个原型，作为将要被调用的函数的提示，简单地说就是获取正整数。
- en: so this is a function that's only going，to get a positive integer then in my，main
    function。notice i'm going to use this i'm going，to get a variable called i，on
    line 10 and i'm going to get a。positive in from the user，and then i'm just going
    to print it out，but what's interesting now is。i have this additional abstraction
    the，cs50 library does not come with a。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只获取正整数的函数，在我的主函数中。注意我将使用这个，我将在第10行获取一个名为 i 的变量，并从用户那里获取一个正整数，然后我将把它打印出来，但现在有趣的是。我有这个额外的抽象，cs50
    库并不包含一个名为 positive.c 的。
- en: function called getpositiveint，but it does come with a function called。getint
    and notice what i've done down，here between lines 15 and 24。down here i've declared
    a function，called getpositiveint，and notice that's my own custom function。name
    it doesn't take any inputs it just，gets a positive integer from the human，but
    now notice。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数叫做 getpositiveint，但它确实有一个名为 getint 的函数，注意我在第 15 行到第 24 行之间做了什么。在这里我声明了一个名为
    getpositiveint 的函数，注意这是我自己的自定义函数。它不接受任何输入，只是从用户那里获取一个正整数，但现在注意。
- en: it does have a return value previously i，used the word void to say the absence
    of。input or the absence of output here i'm，using it still to say。no inputs it
    just always gets a positive，end but i'm saying，int on the left hand side of this
    custom。does have，output what is the output going to be，well notice here on line。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有一个返回值，之前我使用 void 这个词来表示没有输入或没有输出，在这里我仍然使用它来表示。没有输入，它总是获取一个正整数，但我在这个自定义函数的左侧说
    int。确实有输出，输出将是什么呢，注意这里在第。
- en: 17 i give myself a variable and i call，it n then i have one final new feature，of
    c today this loop。which is called not a while loop but a，do while loop，while loop，first。before
    checking a condition so notice，here i'm going to do the following。call getint
    with this prompt positive，integer and then store the return value。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 17 我给自己一个变量，称为 n，然后我今天有 c 的一个最终新特性，这个循环。这个循环不是 while 循环，而是 do while 循环，while
    循环首先在检查条件之前。因此注意，这里我将执行以下操作。使用这个提示正整数调用 getint，然后存储返回值。
- en: into the variable called n then down，here notice i'm saying，while n less than
    one so this is kind of。a weird syntax，but if mathematically i want the user to，give
    me a positive integer。that's technically the same thing as，wanting the user to
    give me an integer。and just make sure that it is not，less than one because if
    it's less than。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值给变量 n，然后在这里注意，我说，当 n 小于 1 时，这种语法有点奇怪，但如果从数学上讲，我想让用户给我一个正整数，这实际上与我想让用户给我一个整数是同一回事。只需确保它不小于
    1，因为如果小于。
- en: one it's zero or negative one or，negative two that's obviously not a，this in
    code。the only new thing at the moment now is，the fact that there exists this thing，do
    while，and then。check a condition a while loop checks，the condition first，and then
    does something instead this is。what i want in this case though i want，to do this，get
    a positive get an integer from the，integer。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个是零或负一或负二，这显然不是代码中的。这时唯一的新东西是，存在这个东西，do while，然后。检查一个条件，while 循环首先检查条件，然后做一些事情，而这正是我想要的，我想做到这一点，从整数中获取一个正数。
- en: then while n is less than one，so if the human typed in zero or，wanna do。the
    same thing again and again and again，so it reads rather grammatically。do the following
    while n is less than，one，and then lastly and the only other new，line here is return。n
    this is the way that a program can，actually return，some value to you it can hand
    you back a。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当 n 小于 1 时，如果人类输入零或，想要重复。一直这样做，所以它在语法上是合理的。在 n 小于 1 时执行以下操作，最后唯一的新行是返回。n，这是一种程序实际上可以返回某个值的方式，它可以把你交还一个。
- en: value not by printing it on the screen，not by saying it audibly or visually，from
    a cat's mouth。it returns it in the sense that what's，being returned here is n，which
    is an integer that matches the。output of this function，why is this useful well
    let's scroll，back up let's now take for granted。that the get positive in function
    exists，and now notice，how we can use it in main i call get。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在屏幕上打印它，或者从猫的嘴里听到声音来返回值。它以某种意义返回，返回的是 n，这是一个匹配该函数输出的整数。为什么这有用呢？好吧，让我们向上滚动，现在假设
    get positive 函数存在，现在注意，我们如何在 main 中使用它，我调用 get。
- en: positive int on the right，type integer，i'm storing that return value on the。left
    in this variable called i，and then i'm printing out i and just，scratch。now that
    i have implemented get positive，in it's sort of out of sight out of mind。i know
    that it can be done and i can，abstract away，just，weird thing。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正数整数，右侧类型为整数，我将返回值存储在左侧名为 i 的变量中，然后我打印 i，刚刚开始。现在我已经实现了 get positive，它在某种程度上已经被抛到脑后。我知道可以做到这一点，我可以抽象出，只是一些奇怪的东西。
- en: i do want to point out about these，implementation details，why did i declare
    n out here。every other time i've created a variable，i've done this，does anyone
    want to conjecture why。this approach where i declare n on line，27 to be an int，would
    actually not work correctly。why might this not be correct this is，subtle，and if
    you have programmed before you。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实想指出这些实现细节，为什么我在这里声明 n。每次我创建变量时，我都是这样做的，有人想猜测为什么吗？我在第 27 行将 n 声明为 int 的这种方法实际上是不会正确工作的。为什么这可能不正确，这很微妙，如果你之前编程过，你会明白。
- en: might have the instincts for this or，if you haven't perhaps just a bit of。why
    might this not work as is，abigail why does this not work are we，um。i'm not certain
    i think we've already，assigned that，it is an integer a good good thinking。not
    the correct answer in this case，it's not going to work for a more subtle，reason
    here。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你对这个有直觉，或者如果没有，也许只是稍微有点。为什么这可能无法正常工作，abigail，为什么这不起作用，我们，嗯。我不确定，我想我们已经，赋值过了，它是一个整数，思路很好。在这种情况下不是正确答案，出于更微妙的原因，这不会起作用。
- en: and that actually in some sense has to，do with these curly braces it turns out。we've
    been getting lucky this whole time，and any time i've declared variables。![](img/cebeed9e0b28f665c194a66b2d3ef30a_59.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其实在某种意义上，这与这些大括号有关。我们一直很幸运，每次我声明变量时。![](img/cebeed9e0b28f665c194a66b2d3ef30a_59.png)
- en: they've technically been in between，curly braces the curly braces belonging，to
    the main function。or my other functions that i've written，thus far，but in this
    case the problem is when you。declare a variable，inside of curly braces you run
    into what。![](img/cebeed9e0b28f665c194a66b2d3ef30a_61.png)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它们技术上处于花括号之间，花括号属于主函数或我迄今为止编写的其他函数，但在这种情况下问题在于，当你在花括号内声明一个变量时，会遇到什么。
- en: we'll call an issue of scope，the scope of a variable is the lines of，code in
    which it exists。the scope of a variable are the lines of，code where you can use，today。is
    that if you declare a variable inside，of curly braces like those here on line。26
    and 28 which you must do，for a do while loop that variable n only。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称之为作用域问题，变量的作用域是它存在的代码行。变量的作用域是你可以使用的代码行。今天的情况是，如果你在像第26和28行的花括号内声明一个变量，出于do
    while循环的需要，那么变量n仅仅存在于那些花括号内。
- en: exists inside of those curly braces，against，one in line 29 which means you cannot，return
    it。in line 30 it just no longer exists so，you're doing all of this work getting，the
    variable n and then。boom it's gone once you exit，top to bottom these curly braces
    so the，work around for that。stupid though it is frankly is that you，can declare
    an initially on its own line，25。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 变量n只存在于花括号内，而在第29行中不存在，这意味着你无法在第30行返回它，它在那时就不再存在了，所以你做了所有这些工作获取变量n，然后一旦退出这些花括号，它就消失了。因此解决办法，尽管这很愚蠢，实际上是你可以在第25行单独声明它。
- en: you don't need to assign it a value even，because you're going to assign it a，value
    eventually。but again to create a variable as i keep，saying is to declare a variable。you
    don't need to define it as having a，value necessarily，right away so this is a
    way to work。around what's otherwise known as，an issue of scope all right with
    all of。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要给它赋值，因为你最终会给它赋值。但再次强调，创建一个变量就像我一直说的那样，是声明一个变量。你不需要立即将其定义为有值，所以这是解决作用域问题的一种方法。
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_63.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_63.png)'
- en: speak，let me go ah**d and propose that we。![](img/cebeed9e0b28f665c194a66b2d3ef30a_65.png)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我去提议一下。
- en: solve something a little more graphical，so you'll recall of course。super mario
    brothers is we uh one of the，first problem sets that we alluded to。last week and
    within this game there's a，whole bunch of visuals。for instance there's this visual
    early，the sky，and these question marks if you jump up。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一些更图形化的东西，你当然会记得《超级马里奥兄弟》是我们上周提到的第一个问题集，在这个游戏中有很多视觉效果。例如，这里有早期的天空和这些问号，如果你跳起来。
- en: and underneath them give you coins for，that and let me ask，well how could i
    write a program in c。that just prints out for question marks，well let me go ah**d
    and do this let me。go ah**d and write a program called，mario。c，let me go ah**d
    and include uh，standardio。h。in a file called mario。c give myself a，main function
    in main void i'm going to，keep this simple。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们下面给你金币，对此让我问，嗯，我怎么能在C语言中写一个程序，打印出问号呢？好吧，让我去做这个，让我去写一个叫做mario.c的程序，接着让我去包含标准库，standardio.h。在一个叫mario.c的文件里，给自己一个main函数，main
    void，我要把这个保持简单。
- en: printf1234 backslash n semicolon this is，not nearly as cool or pretty as the。old
    school game but if i run make mario，and then do dot slash mario voila i get，a
    very。uh poor approximation of these，or，really what is called ascii art but i。can
    do a little better than that，recall that now we have the ability to，use loop so
    i could say for。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: printf1234反斜杠n分号，这远没有老式游戏那么酷或好看，但如果我运行make mario，然后执行dot slash mario，瞧，我得到了一个非常糟糕的近似，或者说真正的ASCII艺术，但我可以做得更好，回想一下，现在我们有能力使用循环，所以我可以说for。
- en: int i gets 0 i is less than 4，out，one question mark at a time and then at，out
    a new line。just to move the cursor at the very last，moment i don't want to do
    that。every question mark because then it，at the end，now，same exact result but
    a little better in。the sense that it，is um now uh more dynam，now it's uh using
    a loop instead of a，hard-coded value。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: int i等于0，i小于4，输出一个问号，然后输出一个换行符。只是为了在最后一刻移动光标，我不想为每个问号都这样做，因为那样最后的结果是相同的，但在某种意义上稍微好一点，因为现在更动态，现在使用循环而不是硬编码的值。
- en: but let me be a little more clever now，and let me do this instead。let me borrow
    the logic of that positive，integer example and do something like，called。n for
    a number and let me do the，following just like before，let me get an integer from
    the user and。ask the user for the width，of the bricks that i want to print so，it's
    not always four maybe it's a。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我现在聪明一点，做点别的。让我借用那个正整数示例的逻辑，做一些类似的事情，叫做n，表示一个数字。让我像之前那样，先从用户那里获取一个整数，并询问用户我想打印的砖块的宽度，所以它不总是四，也许是。
- en: variable number，and then let me go ah**d and do this，while n is less than one
    so identical。to my logic before and then you know，what once i have a value of。n
    so let me go ah**d up here and give，myself a comment，get positive integer from
    user that。rather says what all of these lines of，single line，you can comment every
    few if it makes。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可变数量的砖块。然后让我继续，当`n`小于1时，与我之前的逻辑相同。你知道吗，一旦我有了一个值`n`，让我在这里加上一个注释，从用户那里获取正整数。也就是说，所有这些单行注释每隔几行就可以注释一下，如果有必要。
- en: logical sense to do so，let me go ah**d now and print out that，many，int。i gets
    0 i is less than n this time i，plus plus and now i can print out a。single question
    mark without a new line，and then at the very end of my program i。can print out
    a single new line，semicolon let me go ah**d now and。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上这样做是有意义的，让我继续打印出那么多的int。`i`初始化为0，`i`小于`n`时，`i`加1，现在我可以打印出一个问号而不换行，然后在程序的最后，我可以打印出一个换行符，分号。让我继续。
- en: increase the size of my terminal window，let me do make mario and now oh，get
    int。here's where help50 might be my friend，so let me go ah**d and run help50 make，mario。it's
    going to ask for help ah you seem，to have an error in mario。c。on line 9 by implicit
    declaration of，function getint clang means which is the，next week。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 增加我的终端窗口的大小，让我做`make mario`，现在哦，`get int`。这里的`help50`可能是我的朋友，所以让我继续，运行`help50
    make mario`。它会询问帮助，啊，你似乎在`mario.c`的第9行有一个错误，隐式声明了函数`getint`，clang意思是下周。
- en: means that it doesn't recognize getint，did you forget to include cs50。h。in which
    inkgetint is declared i type，this，so include cs50。h，save the file recompile with
    make mario。and now let me go ah**d and may and do，dot slash mario，and i'll give
    myself a width of four。it's the same let me give myself，a width of 40。 now i get
    that dynamism。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它不认识`getint`，你是否忘记包含`cs50.h`？在这里声明了`getint`。我输入这个，所以包括`cs50.h`，保存文件，然后用`make
    mario`重新编译。现在让我继续，运行`./mario`，我给自己一个宽度四。还是一样，让我给自己一个宽度40。现在我得到了这种动态性。
- en: let me give myself a width of 50，and so forth so now we have a program，that's
    much more dynamic。but you know what let's go ah**d and，enhance this a little further。later
    on in super mario brothers there's，like a lot of this underworld here where。you
    see these grids of bricks and let me，draw our attention to this。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给自己一个宽度50，等等，所以现在我们有了一个更加动态的程序。但你知道吗，让我们进一步增强一下。稍后在超级马里奥兄弟中，有很多这种地下世界，你可以看到这些砖块的网格，注意到这一点。
- en: this looks like multiple bricks both，horizontally and，vertically so there's
    like a width and a。height so how can i go about printing，out maybe maybe that's
    three by three。three bricks across by three bricks down，let me actually go into
    my program here。and get rid of all the question mark，stuff from before，and consider
    how i could print out a。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是多行砖块，横向和纵向都有，所以有宽度和高度。我该如何打印出，可能是三乘三的砖块呢？让我实际上进入我的程序，去掉之前所有的问号内容，考虑一下如何打印出一个。
- en: three by three grid well，my code，then maybe，three more whoops maybe three more
    and，then three more。but of course this copy paste is not，going to fly long term
    but that's fine。let me do make mario dot slash mario，all right i kinda sort of
    have a grid。that looks like this thing here it's not，exactly but at least it's
    the right idea。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 三乘三的网格。那么，我的代码可能是，三更多的哎呀，也许再加三，然后再三。但是当然，这样的复制粘贴从长远来看是行不通的，但没关系。让我做一下`./mario`，好吧，我有点像是一个网格。看起来像这个东西，虽然不完全一样，但至少是对的想法。
- en: but this is not necessarily the best way，to do this i really want to go，turns
    out。using c we can actually express that，as well let me go ah**d and do this let。me
    go ah**d and print out for instance，the following let me go ah**d and print，out
    not just。hash again and again and again let me go，ahead and do this，for int。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不一定是最好的方法。我真的想去，结果发现。使用C语言，我们实际上也可以这样表达，让我继续这样做。让我打印出以下内容，不只是一次又一次的井号，让我继续为int做这件事。
- en: i gets 0 i less than 3 i plus plus，i don't know what i'm about to do yet，times。what
    do i want to do three times well i，want three rows and on every row i want。three
    hashes so you know what you can do，you can nest loops let me do four int j，gets
    zero。j is less than three and j plus plus i，don't know what i'm going to do yet
    but。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置`i`为0，`i`小于3，`i`加1，我还不知道我接下来要做什么。我要做三次，那么我想要三行，每行上我想要三条井号。所以你知道，你可以嵌套循环，让我设置`int
    j`为0，`j`小于3，`j`加1，我还不知道我将要做什么，但。
- en: i do know i'm going to do this，three times and you can perhaps see。where this
    is going three things three，bricks，so long as inside of this inner loop。so to
    speak this nested loop i print one，of those hashes，new line。over here so to be
    clear even if it's，on，we already know that this is the type of，syntax you use。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实知道我要做这件事三次，你也许可以看到这是什么方向，三件事，三块砖，只要在这个内部循环里，可以说这个嵌套循环中，我打印其中一条井号，然后换行。在这里，为了明确，即使它已经开启，我们也知道这就是你所使用的语法类型。
- en: for doing something finitely many times，three this is the same syntax but i'm。using
    a different variable name so i can，keep track of two different values。essentially
    rows and columns，and then i'm just printing a single，brick each time but after
    i'm done。printing a whole row，new line，so let me try this let me go ah**d and，do
    make mario on my code。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 进行有限次数的操作，三次，这就是相同的语法，但我使用了不同的变量名，以便跟踪两个不同的值，基本上是行和列，然后每次我只打印一个砖块，但在我打印完一整行后，换行。因此让我试试这个，让我去`ah**d`并在我的代码中制作马里奥。
- en: dot slash mario and voila now i'm using，a nested loop to print out bricks like。this
    and i can change this if i want to，do a 10 by 10，all i have to do is change that
    in one。place or if i really wanted to be fancy，i could go use get int again。i
    could get the width and the height，from the user and do it completely。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`./mario`，瞧，现在我使用嵌套循环像这样打印砖块，如果我想做一个10乘10，我所需要做的就是在一个地方更改它，或者如果我真的想变得花哨，我可以再次使用`get
    int`。我可以从用户那里获取宽度和高度，并完全做到这一点。'
- en: dynamically but now if i do 10 by 10，for instance i can at least see an even。bigger
    grid so if you wonder how things，like super mario bros or frankly any，game nowadays
    on a pc。or console or phone or made it's with，this kind of generation of maps
    maybe。back in the day they were hard-coded，maybe they were generated，using code
    you can absolutely imagine。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 动态地，但如果我做10乘10，比如说，我至少可以看到一个更大的网格。所以如果你想知道像超级马里奥兄弟，或者坦率地说，现在在PC、控制台或手机上任何游戏是如何制作的，就是这种地图生成方式。也许在过去，它们是硬编码的，也许是使用代码生成的，你可以完全想象得到。
- en: like that，so that ultimately your game even your，world is partly dynamically
    generated。and we already have the building blocks，haven't，really spoken to the
    limitations of what。computers can do，and in our final minutes we thought we'd，set
    the stage for things that computers。aren't very good at and in fact problems，that
    are exist，that are latent in pretty much。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样，因此最终你的游戏甚至你的世界都是部分动态生成的。我们已经有了基本构件，但并没有真正讨论计算机能做的限制，而在最后的时刻，我们想为计算机不太擅长的事情设定一个舞台，实际上存在的问题，几乎是潜在的。
- en: everything we've done today but i've，over，this picture here is a picture of
    a。typical computer's memory or ram，random access memory it's just one of，in your
    phone。your desktop your laptop these days and，it's where programs are stored。when
    they're running so on a mac or pc，if you double click a program。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们所做的一切，但我已经超出，这幅图是典型计算机内存或RAM（随机存取内存）的图片，它只是你手机、桌面或笔记本电脑中的一个。在程序运行时，它存储着程序。所以在Mac或PC上，如果你双击一个程序。
- en: it's ultimately stored in a piece of，do，dot slash mario and hit enter in a。program
    like this you're using cs50，ide's ram，but same idea albeit somewhere else in，the
    cloud。so it turns out though that if you only，have a finite amount of memory like
    this。you can only do so much with it you，can't solve all of the world's problems，memory。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终存储在一个文件中，执行`./mario`并按回车。在这样的程序中，你正在使用cs50的IDE的RAM，但相同的想法也适用于云中的其他地方。然而，事实证明，如果你只有有限的内存，就像这样，你能做到的事情是有限的，你无法解决世界上所有的问题。
- en: and what do i mean by that well let me，go ah**d and create，another program here
    called，imprecision。c。and we'll see why i've named it that in，include，standardio。h
    again in in main void just。to give myself some setup here，and then let me go ah**d
    and very。reasonably very simply ask the user for，a variable called x as a type
    float let，me ask for the。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我所指的是什么意思呢？让我继续创建另一个程序，叫做 imprecision.c。我们将看到我为什么这样命名，在 include，standardio.h
    中，再次在主函数中只是为了给自己一些设置，然后让我继续非常合理地非常简单地询问用户一个叫 x 的浮点型变量。
- en: value just like before let me ask for，another one in the form of y，and。let me
    go ah**d and print out with，percent f，the value of x divided by y so i'm，division。with
    values this time i'm using floats，but let's go ah**d and just run this，implicit。keep
    doing it implicit declaration of，function get flow，i didn't practice what i've
    been。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 值就像之前一样，让我请求另一个变量 y，然后让我继续打印出使用 percent f 的值，x 除以 y，所以我在这次使用浮点数进行除法，但让我们继续运行这个隐式声明函数
    get flow，我没有练习过我。
- en: preaching i also need to include，defined，now let me recompile now it works now。let
    me go ah**d and run imprecision，10th，okay so 1 10th it turns out according to。my
    very simple calculator here，but i'm getting a little curious now it，turns out
    that printf。is even more powerful than we've seen，and you can actually print out
    more than，just single digits。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要包含定义，现在让我重新编译，现在它工作了。让我继续运行 imprecision，十分之一，好吧，所以 1/10，看来根据我非常简单的计算器，但我现在有点好奇，它看来
    printf 的功能比我们看到的还要强大，实际上你可以打印出超过单个数字。
- en: suppose i want to print out not six，significant digits but maybe 10。it's a。little
    funky the syntax but instead of，saying percent f，dot，the number of digits you
    want to see and。then the f，so let me go ah**d and recompile this，make imprecision。now
    let me do dot slash imprecision and，one tenth，ha ha well that's a little curious。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想输出的不仅仅是六个有效数字，而是十个。语法有点奇怪，但不再是说 percent f，点，然后是你想要看到的数字位数，最后是 f，所以让我继续编译这个，make
    imprecision。现在让我执行点斜杠 imprecision，和十分之一，哈哈，这有点奇怪。
- en: i don't recall knowing that there's a，one five at the end of one tenth。well
    let's get a little more curious，let's print out 50 decimal points to。really dig
    into what's going on here，let me recompile my code and let me。rerun dot slash
    imprecision and do 1，divided by 10 and oh my god like i am。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我不记得知道十分之一的末尾有一个 1.5。好吧，让我们更深入一点，打印出 50 个小数点，真的深入挖掘一下这里发生了什么，让我重新编译我的代码，并重新运行点斜杠
    imprecision，进行 1 除以 10，哦我的天，就像我。
- en: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_67.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebeed9e0b28f665c194a66b2d3ef30a_67.png)'
- en: quite sure in grade school when we all，learned 1 divided by，10 the teacher did
    tell us 1 10 or 0。1。and they never mentioned the fact that，it's 0。1000001490116，and
    so forth so what is going on well it。and is，as sophisticated as all of the syntax，we've
    been looking at today is。my god a computer you can't even，calculate one-tenth，correctly
    and so we're bumping up。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常确定在小学时，当我们都学会 1 除以 10 时，老师告诉我们是 1/10 或 0.1。他们从未提到它实际上是 0.1000001490116，等等。那么发生了什么呢？就像我们今天看到的所有语法一样复杂。我的天，电脑连十分之一都无法正确计算，所以我们正遇到问题。
- en: against a fundamental limitation here，which is that if computers are，so much。ram
    so much hardware so many bits well，it stands to reason that if you only are。using
    a finite number of bits，32 for instance or sixty-four yes you can count。pretty
    high or pretty precisely you，cannot count，infinitely high or infinitely precisely。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 面对一个基本限制，如果计算机有那么多的 RAM，那么多的硬件，那么多的位，那很合理，如果你只使用有限数量的位，例如 32 或 64，是的，你可以数得相当高或相当精确，但你无法无限制地高或无限制地精确地数。
- en: at some point，you have to start to approximate values，doing，32。via which to
    represent a float there's a，infinite number of floating point。real numbers in
    the world unfortunately，if you have a finite number of bits you。got to start cutting
    some corners and，that's what the computer is doing。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你必须开始通过使用 32 来逼近值，表示浮点数，世界上有无限数量的浮点实数。不幸的是，如果你有有限的位数，你必须开始削减一些角落，而这正是计算机正在做的。
- en: it's representing one tenth as closely，as it can，and this is what you then see
    when you，for most。problems that's probably not a big deal，but it could very well
    be a big deal if。you're doing math you're dealing with，finance，or monetary values
    or military。operations where a lot of small numbers，uh scientifically really start
    to add up。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它尽可能接近地表示十分之一，这就是你随后在大多数。问题中看到的，这可能不是大问题，但如果。你在进行数学、处理金融、货币价值或军事操作时，那可能真的是一个大问题，其中许多小数字，呃，科学上确实开始累加。
- en: and indeed there have been many examples，happen，and there's another。issue that
    computers run into not only，this floating point in precision。even integers have
    their limitations，recall that integers of course。can be represented in decimal
    or in，binary and if we have three light bulbs。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有许多例子发生，还有另一个问题，计算机不仅仅面临这种浮点精度。即使是整数也有它们的局限性，回想一下，整数当然可以在十进制或，二进制中表示，如果我们有三个灯泡。
- en: or three bits let's consider how we，might count in binary，zero zero zero is
    where we began last。week zero zero one，zero one zero zero one one one zero zero，and
    now。this recall from last week is the number，we know is seven in decimal，just。carry
    the one so to speak but if i only，bits，carry，disappears and so there's this problem。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者三位比特，让我们考虑一下如何，使用二进制进行计数，零零零是我们上周开始的地方，零零一，零一零零一一一零零，现在。这从上周回想起来是我们知道的七，在十进制中，只需。进位而已，但如果我只有，位数，进位，就消失了，因此存在这个问题。
- en: with integers too，and someone noted it earlier when we，tried to do two billion
    or when you。tried to do two billion plus two billion，it couldn't fit in the result
    that's，because integers two。if they're only 32 bits or a long in c，if it's only
    sixty-four bits those are big。numbers but they're not，infinitely large and we
    humans have，tripped over this again and again。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 也是整数，有人早些时候提到过，当我们。尝试做20亿或当你。尝试做20亿加20亿时，它无法适应结果，这是因为整数。如果它们只有32位或在C中是长整型，如果它只有64位，那些是大数字，但并不是，
    无限大，我们人类已经，屡屡绊倒在这上面。
- en: you might recall hearing about if not，living through the y2k problem。where a
    lot of stuff in the world broke，or was worried to be broken，made the。reasonable
    but not very long-sighted，decision to store，years using just two digits so 1995。would
    be represented as 9。5，96 97 98 99 then，around the change of the year from 1999，to
    2000。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得听说过，甚至经历过Y2K问题。世界上许多东西崩溃了，或者担心会崩溃，做出了合理但不够长远的决策，仅用两个数字来存储年份，因此1995年。将被表示为95，96、97、98、99，然后，到了1999年到2000年的年末。
- en: any computer program or system that was，still using two digits。would of course
    add one at the stroke of，third digit，available it disappears and the entire。world
    confuses the year 2000，assumed，as being the prefix and if you can。believe it we
    humans are about to do，this again，in the year 2038 which is not that far，off from
    now。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 任何仍在使用两个数字的计算机程序或系统，当然会在第三位数字。可用时加一，它就消失了，整个世界将年份2000混淆，认为，作为前缀，如果你能相信，我们人类即将在2038年再次做到这一点，这离现在并不远。
- en: we are going to run out of bits，by which to keep track of time because，the time。they
    are going to use 32 bits to，represent numbers，up，date，january 1st 1970。so that's
    when time。began computing wise in some sense and，since，unfortunately with 32 bits
    you can only。count as high as 4 billion give or take，and unfortunately we are
    going to hit。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将耗尽比特，用于跟踪时间，因为，时间。他们将使用32位来，表示数字，更新，1970年1月1日。所以那是时间的开始。从某种意义上讲，计算-wise，而不幸的是，使用32位你只能。计数到大约40亿，而不幸的是，我们将会达到。
- en: the 4 billionth second on，january 19th in the year 2038 so unless。all of us
    upgrade our macs and pcs and，worse embedded systems and satellites，and any hardware。baked
    into various devices that we now，use we're about to run into this problem。again
    where all of a sudden it's going，to be like january 1st，problem。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在2038年1月19日，达到第40亿秒，所以除非。我们所有人都升级我们的Mac和PC，还有更糟糕的嵌入式系统和卫星，以及任何硬件。嵌入在我们现在使用的各种设备中，否则我们即将再次遇到这个问题。突然之间，这将像是1月1日的问题。
- en: so with all the power we've seen and see，in c，and in scratch there are still
    these。fundamental limitations so when it comes，to solving your own problems in。c
    and in turn cs50 it's going to be ever，so important to be mindful of these。constraints
    and to ultimately find，now，we'll adjourn here and leave you for。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们在C和Scratch中看到的所有强大功能，仍然存在这些。基本的限制，因此在解决你自己的问题时。在C和CS50中，关注这些。约束将变得极为重要，并且最终找到，现在，我们将在这里结束，留给你。
- en: your first problem set in c。![](img/cebeed9e0b28f665c194a66b2d3ef30a_69.png)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你在C语言中的第一个问题集。![](img/cebeed9e0b28f665c194a66b2d3ef30a_69.png)
