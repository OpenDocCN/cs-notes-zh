- en: P17：Lecture 16 Network System Calls - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P17：第16讲 网络系统调用 - ___main___ - BV1ED4y1R7RJ
- en: Screen and cast people you missed about 30 seconds。 Okay， so the question was，
    "Hey。 can we use multi-processing from threading？"。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕和转播，你错过了大约30秒。好的，问题是：“嘿，我们可以在线程中使用多处理吗？”
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_1.png)'
- en: The answer is you kind of have to be careful。 The best I could find was the
    sacroful answer。 which basically said， "Look， you can use fork in a multi-threaded
    program。"。 And then what does that actually mean？ It means that both copies of
    when you've forked。 now both processes， have threads associated with them。 So
    something's got to be， you know。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，你必须小心一点。我能找到的最好答案是那个几乎可以算作神圣的答案，它基本上说，“看，你可以在多线程程序中使用fork。”那么这到底是什么意思呢？这意味着，当你使用fork时，两个副本会被创建，两个进程都有与之关联的线程。所以，你得小心点，知道吗？
- en: you've got to have some way of dealing with that。 But in the sense of being
    able to do it。 the biggest thing is， after you do fork and before you do exec
    BP， don't do any mallet-free。 new or delete。 And that was the best I could find。
    You can do it。 Just don't do anything that's going to mess with memory in such
    a way that it will end up。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你得有办法处理这个问题。但从能够做到这一点的角度来看，最重要的是，在你进行fork之后，执行exec BP之前，不要做任何内存分配、new或delete操作。这是我找到的最好的答案。你可以做到这一点，只是不要做任何会以某种方式破坏内存的操作，导致问题发生。
- en: messing with the schedulers and things。 And that was the best I could find。
    So the answer is， yes。 if you want to use multi-processing from within multi-threading，
    you can。 You just have to be a little careful about it。 And obviously。 testing
    is always going to be something important to do。 Okay， so good question。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 摆弄调度器之类的东西。这是我找到的最好的答案。所以答案是，如果你想在多线程中使用多处理，你是可以的。你只需要小心一点。显然，测试总是非常重要的。好的，这是个好问题。
- en: And there's the kind of answer that I could find。 Feel free to do some more
    digging on your own。 But it is possible。 It's just you've got to be careful。 Okay，
    so let's move on to。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我找到的答案。如果你有兴趣，可以自己再深入研究一下。但是是可以的，只是得小心。好了，接下来我们继续。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_3.png)'
- en: Network system calls， library functions， et cetera。 Now， as I said a couple
    minutes ago。 this is where I think it's kind of a flashback to CS107。 because
    some of the walkiness associated with C propagates to these functions。 that are
    about getting host names and resolving them and using these low-level functions。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络系统调用、库函数等等。就像我几分钟前说的那样，我觉得这有点像是CS107的回顾，因为与C语言相关的一些不规范操作会传播到这些函数中，这些函数用于获取主机名、解析它们以及使用这些底层函数。
- en: to do so in a way such that you can support IP version 4 and IP version 6 and
    any other。 version that you want。 It turns out that socket programming， which
    is what we're talking。 about here， where two computers talk to each other through
    a socket or basically a port。 A socket is， as it turns out， just a file descriptor，
    but it's a very special file descriptor。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种方式来做，使得你可以支持IP版本4、IP版本6以及任何你想要的其他版本。结果证明，套接字编程——我们在这里讨论的，就是通过套接字或者基本上是端口，两个计算机相互通信的方式。套接字，实际上就是一个文件描述符，但它是一个非常特殊的文件描述符。
- en: It still gets an entry in the open file table。 Believe it or not。 it still gets
    an entry in the file descriptors for a particular process。 but it allows you to
    have a double-ended communication between two processes or two computers over
    a network。 Okay， so it's just like a file descriptor， but there's a little more
    to it。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然会在打开的文件表中有一个条目。信不信由你，它仍然会在特定进程的文件描述符中有一个条目，但它允许你在两个进程或两台计算机之间通过网络进行双向通信。明白了吗？所以它就像一个文件描述符，但它还有更多的内容。
- en: And you don't necessarily need to know what else there is to it， except for
    the fact that。 even though it's a file descriptor， you actually can't say。 you
    don't say read and write in the same way that you normally do。 Okay？
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要知道它的其他细节，除了一个事实，即尽管它是一个文件描述符，实际上你不能像平常那样进行读写操作。明白了吗？
- en: You use things like accept and you use other functions that。 I guess you can
    use write on the file descriptors。 But you can't。 but there's some other nuances
    that you can't just say， oh， it's just like every other file。 Somewhat like that
    a bit of a file， but not exactly。 So， let's talk about the specifics。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用像`accept`这样的函数，还会使用其他函数。我猜你可以在文件描述符上使用`write`，但不能。还有一些其他的细微差别，你不能只是说，哦，它就像每一个其他的文件。它有点像文件，但并不完全是。好了，让我们来谈谈具体的细节。
- en: Because we are people， we like to use things like www。facebook。com， versus 31。13。75。17，
    right？
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们是人类，我们喜欢使用像`www.facebook.com`这样的东西，而不是`31.13.75.17`，对吧？
- en: You don't want to memorize numbers。 We've talked about that in a number of the
    ways this class。 And so， there are functions that will get the number from the
    name。 So， if you know the name www。facebook。com， which you can remember easily，
    you can use a function called gethostbyname。 And you can also use one gethostbyaddress，
    which they're both technically deprecated。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想记住数字。我们在本课程的很多地方都谈过这一点。所以，有一些函数可以根据名称获取数字。如果你知道像`www.facebook.com`这样的名称，它是很容易记住的，你可以使用一个名为`gethostbyname`的函数。你也可以使用另一个`gethostbyaddress`，它们两个从技术上来说已经不推荐使用了。
- en: In other words， there's other things you should probably use instead。 However。
    your book talks about these ones and they're still used enough that you should
    be used to using them。 In particular， I'm not exactly sure what the actual new
    one is。 I don't say。 see these ones more than I see that and I forget what the
    actual。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，应该有其他你应该使用的东西。不过，你的书中谈到这些函数，它们仍然被足够多地使用，以至于你应该习惯使用它们。特别是，我不太确定实际的新函数是什么。我并不说。比起看到这些，我更常看到那个，我也忘了实际的新函数是什么。
- en: the one that you should use these days is。 So， anyway， we're going to talk about
    these two。 And what they take are a gethostbyname。 It takes a name like www。facebook。com。
    And it returns this struct called host， a struct hostint。 which is a particular
    struct we'll see in a second。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该使用的是这个。所以，反正我们将会讨论这两个。它们所接收的参数是`gethostbyname`。它接受一个像`www.facebook.com`这样的名称。并返回一个名为`host`的结构体，一个叫做`hostint`的结构体。我们稍后会看到这个特别的结构体。
- en: And it populates it with the information you're going to need about what the
    IP address is and so forth。 You can also pass in an address here。 As it turns
    out， I don't believe that's actually a char star。 Although it looks like a char
    star。 You have to actually cast it to believe it or not a like an int in this
    case。 And the reason for that is because you need to， actually this one may be
    not。 This one。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它会用你需要的关于IP地址等的信息来填充它。你也可以在这里传入一个地址。事实证明，我不认为这实际上是一个`char*`。虽然它看起来像一个`char*`。你必须把它转换成一个`int`，相信我，或者在这个情况下是其他类型。之所以这么做，是因为你需要，实际上这个可能不是。这个。
- en: I don't even think we use this one or an example。 This one may be not。 There
    are ones where you have to do that。 And again。 it's because of the longiness of
    C and some of this stuff we've done in 1977 and there weren't even void star pointers
    then。 So， everything became a char star pointer and it， you can do that。 In this
    case。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至不认为我们会在例子中使用这个。这个可能不是。也有些是你必须这么做的。再说一次。这是因为C语言的历史悠久，还有一些我们在1977年做的事情，那时候甚至没有`void*`指针。所以，一切都变成了`char*`指针，尽管你可以这么做。在这种情况下。
- en: I guess in this case， yeah， this is actually going to be， I believe， a number。
    a pointer to a number。 And you're going to say how many bytes it is and then another
    variable it talks about the type of connection。 whether it's an IP for before
    or six or so forth。 Okay。 so there's lots of details about that that you have
    to know when you're using that function。 Okay。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜在这种情况下，嗯，这实际上应该是，我认为，是一个数字。一个指向数字的指针。然后你将会说它是多少字节，接着还有另一个变量，它描述了连接的类型，是否是一个IP地址，或者是IPv6等等。好的，所以有很多关于这方面的细节是你在使用这个函数时需要了解的。好的。
- en: a struct host int has the following， well， we'll get to what it is。 Let's see，
    get host name。 Yes。 here we go。 This one is a struct i-n-a-d-d-r， which happens
    to be an int。 It's the weirdest struct I've ever seen。 It's got one value in it，
    which is an int。 So。 we'll see a little bit more about that in a second。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`struct hostint`包含以下内容，嗯，我们会稍后看看它是什么。让我们来看看，`gethostname`。是的，来了。这个是一个名为`i-n-a-d-d-r`的结构体，它恰好是一个`int`。这是我见过最奇怪的结构体了。它只有一个值，就是一个`int`。好吧。我们稍后会更多地了解它。
- en: But the one we're going to focus mostly on is get host by name。 So， it turns
    out。 Okay， all right。 so what is this？ What is this？ Oops。 Oh， no， that's not
    what I want to do。 Hang on。 I don't have my tablet set up quite correctly now，
    so hang on。 Let me go back here and we will use cursor。 Okay。 All right。 So。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们主要关注的是get host by name。所以，事实证明。好的，明白。那么，这是什么？这是什么？哎呀，哦，不，这不是我想做的。等一下。我现在没有正确设置我的平板，等一下。我回到这里，我们使用光标。好了。明白了。所以。
- en: here's what the struct host int looks like。 First of all， it takes inside of
    it， I will use the pen。 It takes a struct called struct i-n-a-d_ad-dr， which is，
    in this case， an unsigned int s-a-d-d-r。 which is， like I said， the strange is
    struct because it's only got one value in it。 You normally don't bother with a
    struct that has one value， and it wants the point。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结构体host int的样子。首先，它内部包含了一个名为struct i-n-a-d_ad-dr的结构体，在这个例子中是一个无符号整数s-a-d-d-r。正如我所说，这是一个奇怪的结构体，因为它只包含一个值。你通常不会去管只有一个值的结构体，它想要的是指针。
- en: Maybe this is for， hey， they thought maybe it would be used some other way。
    and they might have some other， they probably were forward thinking enough， and
    it never was。 And it never has changed。 So， that's all that is in there。 Okay。
    This is an unsigned int。 And then the struct host int has a regular old charge
    star， finally， a regular old charge star。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这是为了，嘿，他们当时想，也许会以其他方式使用它。而他们可能有一些其他的想法，他们也许有足够的前瞻性，但它从未实现过。而且它也从未改变过。所以，这就是里面的全部内容。好的。这是一个无符号整数。然后，结构体host
    int有一个普通的旧指针星号，最后是一个普通的旧指针星号。
- en: which is the name。 Okay。 That's the official name。 Turns out， I'll show you
    an example。 the official name might be different than what you actually type in。
    A lot of times they end up going to the same IP address。 but the name could be
    a little bit different。 Then you have a bunch of aliases。 Okay。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是名称。好的。那是正式的名称。事实证明，我会给你看一个例子。正式名称可能与实际输入的名称不同。很多时候，它们最终会指向同一个IP地址，但名称可能稍微不同。然后你会看到一堆别名。好的。
- en: And the aliases are other strings that also refer to the same IP address。 Okay。
    So there's like an official one， and there's other ones that do that。 You rarely
    see the aliases one filled in at all。 I guess maybe it doesn't really。 nobody
    really cares that much about it。 But you rarely see that in。 But it is a charge
    star star。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是其他字符串，也指向相同的IP地址。好的。所以有一个官方的名称，还有其他指向相同地址的别名。你很少看到别名字段被填充。我猜也许真的没有人那么关心它。但你很少会看到它被填充。但它确实是一个指针星号星号。
- en: meaning that it's basically just like every other charge star we normally use。
    It's a。 as it turns out， no terminated list of our pointer to strings。 So string，
    string， string， string。 string， and then the final ones， no， you know， you've
    reached the end。 That's what that one is。 Okay。 The age address type is going
    to be different depending on which type of IP address you care about。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它基本上就像我们通常使用的其他指针星号。它是一个。事实证明，是一个没有终止符的指向字符串的指针列表。所以字符串，字符串，字符串，字符串，字符串，然后最后一个是，没错，你知道你已经到了末尾。这就是那个。好的。地址类型将根据你关心的IP地址类型有所不同。
- en: So in this case， we'll probably stick mostly with AFI net。 which means the Internet
    for IPV for addresses。 Okay。 And this is actually somewhat important。 We'll see
    why when we get into the details of some of the strange polymorphism that they've
    jammed into C。 as we see。 Okay。 And then here's a charge star star， each address
    list。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这个例子中，我们可能主要使用AFI net，这意味着Internet中的IPV4地址。好的。这个其实是挺重要的。我们会看到为什么，当我们进入一些奇怪的多态性细节时，它们被硬塞进了C语言中。正如我们所见。好的。然后这里是一个指针星号星号，每个地址列表。
- en: which is another not charge star star。 It's basically a void star star。 That
    should be a void star star。 But when they built this function。 they either didn't
    have void star star， they didn't want to use it for whatever reason。 But when
    you use this， you should cast it to the appropriate thing that it is。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这其实是另一个非指针星号星号。它基本上是一个void指针星号星号。应该是void指针星号星号。但当他们构建这个函数时，要么他们当时没有void指针星号星号，要么由于某些原因不想使用它。但是当你使用它时，应该将其转换为适当的类型。
- en: which you will know based on analyzing this。 We'll see how that works again。
    It's like really low level 107 kind of stuff。 Question， are these things supposed
    to make a durant？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过分析这个来了解。我们再看一下它是如何工作的。这就像是非常低级的107类的东西。问题是，这些东西应该是为了做一个durant（译注：durant可能是个打字错误或专有名词）吗？
- en: Are these things that make a durant？ Probably， yeah。 Probably the same people。
    Yeah。 There you go。 Yeah。 It's， look， when you're designing something in the 1970s。
    it's a little bit different than the way you might design it today。 Maybe。 But
    yes。 it's probably the same people who did that。 Or somebody who's thinking along
    the same lines。 Okay。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西是杜兰特做的吗？可能吧。应该是同一批人。对，你看。当你在1970年代设计某个东西时，它跟今天的设计方式有点不同。也许吧。但没错，可能是同一批人做的。或者是有相同思维方式的人。好吧。
- en: Anyway， we'll see why this becomes interesting in a few minutes。 Okay。 All right。
    The S-A-D-D-R field is what we call a dotted quad。 Okay。 Basically， it's four
    bytes。 One， two。 three， four。 Okay。 Four bytes。 And this is what you hopefully
    have seen IP addresses that look like this in the path。 You have it。 Well， that's
    what an IP address looks like。 An IP version four address looks like。 171。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，过一会我们就会知道为什么这会变得有趣。好吧。好的。S-A-D-D-R 字段就是我们所说的点四表示法。好吧。基本上，它是四个字节。一个，二，三，四。好吧，四个字节。这就是你们希望曾经见过的那种类似的IP地址形式。你有它。嗯，这就是IP地址的样子。一个IP版本4地址就长这样。171。
- en: 64。 64。136。 And those IP addresses， they break them into fours because it's
    a little easier than memorizing that big long number。 number one。 And number two，
    each little byte means something different。 171。 I believe that Stanford's mean
    like the first byte and all Stanford addresses once everyone I believe。 And then
    the other ones kind of slowly get it down to the actual machine or router that
    you're actually looking at。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 64，64，136。然后这些IP地址会被分成四段，因为比记住那个长长的数字要容易一些。首先，数字一。然后第二，每个小字节表示不同的意义。171。我相信斯坦福的意思是第一个字节，所有斯坦福地址都是这样。然后，其他的字节逐渐指向你正在查看的实际机器或路由器。
- en: So that's how that works。 Meaning that because these are just bytes， the IP
    version four addresses。 four bytes long or 32 bits， and it's 171， 64， 64， 136。
    Now。 what order are those bytes going to be in？ In other words， when you have。
    this is the 107 stuff I was talking about too。 When you have a number and a four
    byte number on your system。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它是这么工作的。意思是，因为这些只是字节，IP版本4地址就是四个字节，或者32位，它是171，64，64，136。那么，这些字节的顺序会是什么？换句话说，当你有……这也是我刚才提到的107的部分。当你有一个四字节的数字时。
- en: there's two different orderings we can use。 Remember what they were？ Little
    Indian and big Indian。 right？ And our machines are generally little Indian machines。
    Meaning that the little end of the number actually comes first in memory。 So 136
    would actually be the first one in memory and then 64 and then another 64。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种不同的字节顺序。记得它们是什么吗？小端字节序和大端字节序，对吧？我们的机器通常是小端字节序的机器。意思是数字的低位字节实际上会先存储在内存中。因此，136
    实际上会是内存中第一个字节，然后是64，接着是另一个64。
- en: And then 171 would be last in memory。 We could have done it in exactly the opposite
    order。 You could have done it in big Indian。 And for those of you who took CS，
    let's see， 107E。 I believe the Raspberry Pi's are in general big Indian。 Although
    maybe they。 I think I can actually switch it back and forth as it turns out。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 171 将是最后存储的内容。我们本来可以按完全相反的顺序来做。你可以用大端字节序来做。对于那些学习了计算机科学的同学们，嗯，107E。我相信树莓派一般使用的是大端字节序。虽然也许它们……我觉得我实际上可以在两者之间切换，结果是这样。
- en: But the point is that in that case it would be in a different order。 Well。 because
    of standardization， your computer， which is the little Indian。 you need to talk
    to some computer on the other side of the world， which may be big Indian。 You
    have to make a decision on which direction to put the bytes when you actually
    send them over the wire。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但重点是，在那种情况下它会是不同的顺序。嗯，由于标准化，你的计算机使用的是小端字节序，你需要与另一台可能使用大端字节序的计算机通信。当你实际上通过网络发送数据时，你必须决定字节的顺序。
- en: Okay？ So the reason we have to do that is so that everybody can talk together。
    And therefore。 if you have the wrong type on your computer， you'd better do a
    translation when you're about to send it。 We will see that in action。 I'm just
    setting you up for it， thinking about it right now。 And I'm going to show you
    the details in a second。 Okay？ Let's see。 Yeah。 So we。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？所以我们必须这么做的原因是为了让每个人都能一起交流。因此，如果你的计算机上的字节序不正确，在你准备发送数据时，最好进行转换。我们稍后会看到实际操作。我现在只是为你们做个铺垫，思考一下。稍后我会展示给你们看。好吧？我们来看看。对，接着。
- en: for non-IP version 4 ones， we can also， let's see， hang on， see this one。 See
    this one。 For non-IP v4 ones， we have different information in all that thing。
    It's got other information in there。 H-atter type is going to be a different actual
    number。 Length is going to be different if you have 128 bits。 You're going to
    need to report that。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非IP版本4的情况，我们也可以，嗯，让我看看，稍等，看看这个。看看这个。对于非IP v4的情况，我们有不同的信息在所有这些内容中。它包含了其他信息。H-atter类型将会是一个不同的实际数字。如果你有128位，长度也会不同。你需要报告这个。
- en: And the list can have different types of information too。 So you've got to be
    a little bit。 a little bit careful with that as well。 Okay？ All right。 Now。 why
    is it not letting me do this again？ There we go。 Okay。 Any questions on that so
    far？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中也可以包含不同类型的信息。所以你得小心一点，稍微小心一点。好吧？好了。那么，为什么它不让我再做一次呢？好了。好了。目前为止，关于这个有什么问题吗？
- en: We're getting the， getting to the actual code here。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近实际的代码部分。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_5.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_5.png)'
- en: In fact， let's actually write some code and then I'll show you this as we go
    along。 That is way too small。 All right。 So， there we go。 All right。 So。 we're
    going to go ahead and take a look at the code。 And then we're going to go ahead
    and take a look at the code。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，让我们实际写些代码，然后我会在过程中向你展示。这个字体太小了。好吧。那么，我们开始。好吧。那么。我们将继续查看代码。然后我们将继续查看代码。
- en: And then we're going to go ahead and take a look at the code。 And then we're
    going to go ahead and take a look at the code。 And then we're going to go ahead
    and take a look at the code。 And then we're going to go ahead and take a look
    at the code。 And then we're going to go ahead and take a look at the code。 And
    then we're going to go ahead and take a look at the code。 Okay。 So。 we have to
    start out and we declare a struct host end。 This is a statically built variable
    that is kept by the operating system。 So。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将继续查看代码。然后我们将继续查看代码。然后我们将继续查看代码。然后我们将继续查看代码。然后我们将继续查看代码。然后我们将继续查看代码。好了。所以，我们必须先声明一个`struct
    host end`。这是一个由操作系统维护的静态构建变量。
- en: if you're going to use this multiple times in your code， you'd better make a，
    if you want。 to keep track of different like things。 Keep a copy of it because
    it's not， it's not like it's。 it's not thread safe and it's other， things because
    you are just getting the actual pointer to the data that's living inside the。
    function that you're calling。 Okay。 Not the best way to do it。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中多次使用这个，最好创建一个副本，如果你想跟踪不同的内容。保持一份副本，因为它不是线程安全的，或者其他的原因，因为你只是获取了指向数据的实际指针，而这个数据存活在你调用的函数内部。好了。这不是最好的做法。
- en: but that's the way static variables work and that's how this， works。 Get host
    by name is a C function。 So we need to convert， if we have a C plus plus string。
    we just convert to C string。 Okay。 And then calling the get host by name will
    populate this。 Okay。 So， no， it means we couldn't resolve the name。 That could
    be for a number of reasons as it turns out。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就是静态变量的工作方式，也就是它是如何工作的。`get host by name`是一个C函数。所以我们需要转换，如果我们有一个C++字符串，我们只需将其转换为C字符串。好了。然后调用`get
    host by name`会填充这个。好了。所以，不，意味着我们无法解析这个名称。结果证明，这可能是多种原因造成的。
- en: It could be that your DNS server is down and that's on your computer or the
    network or。 the router and so forth where you're connecting to or it could be
    some other reason。 So if you type one and it happens to be not there， it doesn't
    necessarily mean that it。 doesn't exist， but it doesn't， it means that your program
    couldn't resolve it。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是你的DNS服务器出现故障，可能是在你的电脑、网络、路由器或你连接的其他地方，或者可能是其他原因。所以如果你输入了一个，恰好它不存在，这并不一定意味着它**不存在**，而是意味着你的程序无法解析它。
- en: This is the problem with networks。 Sometimes other things that you can't rely
    on go down and nothing you can do about it。 Okay。 Then H E the H name is the name
    we talked about and then all of those IP addresses， we just。 go through them one
    at a time by first saying， okay， let's cast the H address list to what。 it really
    is and we know that really is a IN address double pointer。 Why？ Because we're
    no。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网络的问题。有时候，其他你无法依赖的东西会出现故障，而你对此无能为力。好了。然后，H E是我们之前谈到的那个名称，接着所有这些IP地址，我们会逐一处理，首先说，好的，让我们将H地址列表转换成它真正的样子，我们知道它实际上是一个IN地址双指针。为什么？因为我们知道。
- en: we're asking for the IP version for address。 In other words， we call get host
    by name。 meaning we were expecting an IPV4。 If you want an IPV6， there's a different
    function you call。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在请求IP版本四地址。换句话说，我们调用`get host by name`，意味着我们期待的是IPV4。如果你想要IPV6，有一个不同的函数可以调用。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_7.png)'
- en: Okay。 I'll show you that in a minute。 But anyway， then you get the IP address
    by the IP addresses by looping through until you。 get no。 Okay。 And how do we
    actually get out the actual IP address？ Well。 remember it's just a number right
    now and it's just a four byte number。 And so what we do is we call another function
    called， I met network to printable is basically。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我一会儿给你看。不过，反正，你通过循环直到得到IP地址。得到后就不再继续。好的。那我们实际上是如何获取IP地址的呢？嗯，记住，它现在只是一个数字，仅仅是一个四字节的数字。所以我们做的是调用另一个叫做`I
    met network to printable`的函数，本质上就是。
- en: what the NTOP stands for， which means it takes， it says， hey， what type of IP
    address。 are you using in this case， IP version for？ Okay。 It says。 give me the
    actual pointer to the address itself。 Okay。 And then give me a string to populate
    it with。 And that's what we've done up here。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NTOP代表什么，它的意思是它会说，嘿，你在使用哪种类型的IP地址？在这种情况下，是IP版本四？好。它说，给我实际指向地址本身的指针。好。然后给我一个字符串来填充它。这就是我们在上面所做的。
- en: And we know that I met underscore ADDR， Sterling is the maximum length of a
    IP address that。 turns out。 So we know that's okay。 And then how long it is is
    also passed in so that it won't。 right over the buffer。 Once you do that， it takes
    that number and it forms it into a nice 172 dot whatever。 whatever， whatever。
    Okay。 Any questions on that？ Yeah。 Yes。 A of I net is IP version four。 Yes。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`I met underscore ADDR`，Sterling是IP地址的最大长度。事实证明是这样。所以我们知道那是可以的。然后，它的长度也是传入的，以避免溢出缓冲区。一旦你做到这一点，它就会把那个数字转换成一个漂亮的172点什么，什么，什么。好啦，关于这个有什么问题吗？嗯。是的。`A
    of I net`是IP版本四。是的。
- en: A of I net is IP version four。 Let's look real quickly。 Resolve host name six，
    C C。 Yeah。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`A of I net`是IP版本四。我们快速看一下。`Resolve host name six， C C`。是的。'
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_9.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_9.png)'
- en: There's the one for IP version six。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于IP版本六的那个。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_11.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_11.png)'
- en: A of I net six， et cetera。 And we also would call a different function called
    get host by name two。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`A of I net six`，等等。我们还会调用一个不同的函数，叫做`get host by name two`。'
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_13.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_13.png)'
- en: They weren't very clever when they named these， I guess。 You think it would
    be。 you think it would be someone like get host by name six or something。 But
    it's a。 you can pass into this one。 This one you pass in the actual type。 So I
    believe we could have used this one for the IP V or version six as well。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在命名这些时并不是特别聪明，我猜。你认为它会是……你觉得它会是像`get host by name six`之类的名字。但其实是……你可以传入这个。这个你传入的是实际的类型。所以我相信我们本来也可以使用这个来处理IPV6版本。
- en: And it would have worked just fine as well。 Because we would have passed in
    the IP version， sorry。 the IP version four。 Did they also write two two？ Did they
    also write two two？
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它也会正常工作。因为我们本来会传入IP版本，抱歉，是IP版本四。它们也写了两个两个吗？它们也写了两个两个吗？
- en: They probably also wrote two two。 Yes。 Yes。 If you ever build a big system。
    you will quickly realize that there are decisions you have。 to make that you hate
    at the core in your core。 But you have to make those decisions because it just
    happens at the way。 Now， if they have to do it this way， probably not。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可能也写了两个两个。是的。是的。如果你曾经构建过一个大型系统，你会很快意识到，你有些必须做出的决定，你从心底讨厌这些决定。但你必须做这些决定，因为这就是事情的进行方式。现在，如果他们必须这样做，可能不会。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_15.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_15.png)'
- en: But they may be， there's some committee that probably decided that and that's
    the way it， goes。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但他们可能是某个委员会决定了这些，事情就是这样发展的。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_17.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_17.png)'
- en: Anyway， let's see this program in action。 Okay。 I think it's already made。 Let's
    see。 Resolve host name。 Yes。 Okay。 So if we type a host name， let's try， let's
    try， www。stanfer。edu。 Okay。 So it says that that's the actual host name， the official
    one。 Now it's a good thing we don't have to type that every time you want to go
    to Stanford。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们看看这个程序如何运行。好的。我觉得它已经做好了。让我们看一下。`Resolve host name`。是的。好的。如果我们输入一个主机名，试试，试试`www.stanfer.edu`。好吧。所以它显示了那是实际的主机名，就是官方的主机名。现在，幸好我们不需要每次都输入这个才能访问斯坦福。
- en: or to Stanford or to you。 Why is it that big long？ Well。 it tells you that actually
    Stanford relies on Amazon AWS services for their， well。 if you think about it，
    it's actually not a terrible call。 Why do it all in house if you don't have to，
    right？
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是给Stanford，或者给你。为什么它会那么长？嗯。它实际上告诉你，Stanford依赖于亚马逊的AWS服务，嗯。如果你想想，其实这也不是个糟糕的选择。如果不必要，为什么要全都自己做呢，对吧？
- en: Just rely on some giant company that has billions of servers out there。 It's
    probably going to stay up relatively often and so forth。 I believe if we just
    type Stanford。edu， we get， there we go， we get the official name， is just Stanford。edu
    and it happens to go to a slightly different web address。 My guess is that if
    you type www。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只依赖一个拥有数十亿台服务器的巨头公司。它应该会保持较高的在线频率等等。我相信如果我们只输入Stanford.edu，我们就能看到，没错，看到的是官方名称，就是Stanford.edu，它恰好指向了一个稍微不同的网页地址。我的猜测是，如果你输入www。
- en: stanfer。edu， your browser may actually， let's try this。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: stanford.edu，你的浏览器可能，试试这个。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_19.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_19.png)'
- en: I'm going to try something。 Ping。 Stanford。edu， okay， it says 171， 67， 215，
    200。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我要试试别的。Ping。Stanford.edu，好吧，它显示171，67，215，200。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_21.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_21.png)'
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_22.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_22.png)'
- en: Okay， so that's that。 If we ping www， let's see what happens here。 No。 it's
    giving you the other one。 So they're slightly different。 They probably end up
    pointing to the same place somewhere along the line。 But yeah， there's the。 they
    do end up with different， www actually makes a slight difference， in that case。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，就是这样。如果我们ping一下www，看看会发生什么。没有。它给了你另一个。所以它们略有不同。它们最终可能会指向同一个地方，但没错，确实有些不同，www实际上在这种情况下稍微有些差别。
- en: If you type both， you'll end up with the same place。 Somewhere along the line。
    they re-routed to the same web page。 Let's try a couple more。 Let's try google。com。
    Google。com has an IP address that I believe is actually based on your location。
    Like it kind of knows who you， who's asking and then it returns the IP address
    about like， where。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入这两个，你会最终到达同一个地方。某个地方，它们会重新路由到同一个网页。让我们再试几个。试试google.com。Google.com有一个IP地址，我相信它实际上是基于你的位置的。它好像知道谁在请求，然后返回一个基于你位置的IP地址。
- en: like locally， more local to you。 As it turns out， let's see， facebook。com。 Yeah，
    same thing。 There you go。 Oh， some of the other ones， let's see， www。facebook。com。
    There you go。 The， the www。stampford1， actually I think it had two， there it is。
    It did have two different IP addresses associated with it。 Those are Amazon addresses
    I think。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 比如本地的，更接近你的位置。结果是，看看，facebook.com。嗯，还是一样的。给你。哦，其他一些，看看，www.facebook.com。给你。那个，www.stanford1，实际上我认为它有两个，那里有。它确实有两个不同的IP地址关联。我想那些是亚马逊的地址。
- en: And then there's another one that Jerry likes to use。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有一个Jerry喜欢使用的。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_24.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_24.png)'
- en: Okay， Cupid。com。 I don't know that Jerry likes to use that， but Jerry actually
    showed me this。 That it， that it has lots。 I'm not sure why。 And it's not because
    like billions and billions of people are using it and like Google has。 a few people
    here and there。 So I don't know why。 There's some。 something going on where their
    host server says， hey， these are all your IP。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Cupid.com。我不知道Jerry是否喜欢用那个，但Jerry确实给我看过。它有很多。我不确定为什么。并不是因为像数十亿人使用它，而Google只有一些人偶尔使用。所以我不知道为什么。这里有一些。似乎有些问题，导致它们的主机服务器说，“嘿，这些都是你的IP”。
- en: addresses and it shows up in this list and it's， it's a little bit black magic
    after that。 Now。 github。com， let me try it。 github。com。 There's just one for that。
    I don't know if I could try www。github。com。 Same。 So it's the same。 That one happened
    to be the。 the official name is the same one that went to the same one。 So yeah。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 地址出现后它会显示在这个列表中，然后，它有点像黑魔法。现在。github.com，让我试试。github.com。只有一个。我要不要试试www.github.com？一样。所以它是一样的。那个正好是。官方名称是同一个，指向的是同一个。所以，没错。
- en: there's definitely some black magic going on there。 I know， you know。 I don't
    know all the details about that。 So let's do one other thing。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里绝对有一些黑魔法在发生。我知道，你知道。我不清楚所有的细节。所以让我们做一件事。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_26.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_26.png)'
- en: I want to show you just one other thing here。 gdb。 I told you it's not feel
    like 107。 gdb。 Resolve。 Host name。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你展示一件事。gdb。我告诉你它不像107。gdb。解析。主机名。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_28.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_28.png)'
- en: Okay。 Break on publish。 IP address info。 I think there we go。 All right。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。发布时中断。IP 地址信息。我想现在可以了。好了。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_30.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_30.png)'
- en: Let's run it again。 Let's do Stanford。edu。 Actually， let's do it。 Let's do it。
    Let's do it。 All right。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再运行一次。我们做 Stanford.edu。其实，我们做吧。我们做吧。我们做吧。好了。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_32.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_32.png)'
- en: Let's do the， let's do the， okay， keep one just to see。 Okay， qubit。com。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做这个，做这个，好，保留一个只是看看。好了，qubit.com。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_34.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_34.png)'
- en: Okay。 So if we go into the code and we get the host name， okay， if we print
    out HE， it's just。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以如果我们进入代码并获取主机名，好，如果我们打印出 HE，它就是。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_36.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_36.png)'
- en: a pointer。 All right。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指针。好了。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_38.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_38.png)'
- en: If we print out host HE like that， it tells you all the details there。 Okay。
    So it tells there in this case the name， that's just a pointer to the name。 And
    then the aliases are in， there's no， it turns out there's no aliases。 I believe
    if we do。 let's see how we're going to do this。 We're going to do a star。 HE，
    let's do the star。 HE， arrow。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像那样打印出主机 HE，它会告诉你所有的详细信息。好了。所以它在这种情况下告诉你名字，那只是指向名字的指针。然后别名在里面，结果显示没有别名。我相信如果我们做。我们看看怎么做。我们要做一个星号。HE，我们做星号。HE，箭头。
- en: HE， alias is。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HE，别名是。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_40.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_40.png)'
- en: See if that works。 Yeah。 So the first there are no aliases turns out。 And then
    let's see。 The H address type happens to be two。 In that case， that one means
    the IP version four。 And then the length is four bytes。 So we know how long the
    address is。 And then the address list is。 remember we said it was a char star。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 看看是否有效。是的。所以第一个那里没有别名，结果显示没有。然后我们看看。H 地址类型恰好是二。在这种情况下，那意味着 IP 版本四。然后长度是四个字节。所以我们知道地址的长度。然后地址列表是。记得我们说它是一个
    char star。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_42.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_42.png)'
- en: But if we just said， try to do this， ADDR list like that， it's going to be kind
    of garbage-y， right？
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们只是说，尝试像这样做这个，ADDR 列表，那会有点乱吧，对吧？
- en: Because we don't really know what it is。 I think you're going to have to actually
    do something like this。 See if this works。 Let's see if we can do this。 We're
    going to have to cast it。 I know。 It gets ugly， right？ We have to cast it to a--，
    what is it here？ It is a struct， i-n-a-d-d-r。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们并不真正知道它是什么。我想你可能得像这样做。看看这是否有效。让我们看看我们是否能做到这一点。我们将不得不进行强制类型转换。我知道。它变得很丑，对吧？我们得把它强制转换成一个——它是什么？是一个
    struct，i-n-a-d-d-r。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_44.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_44.png)'
- en: Struct， i-n-a-d-d-r star， maybe？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Struct，i-n-a-d-d-r star，也许？
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_46.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_46.png)'
- en: Nope。 [INAUDIBLE]， It's going to be--， nope， oh no。 Let's see。 I did this earlier。
    I figured this out earlier。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不行。[听不清]，它会是——不行，哦不。我们看看。我早些时候做过这个。我之前弄明白了。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_48.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_48.png)'
- en: OK。 That's that。 Maybe we need to do--。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。就是那个。也许我们需要做——。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_50.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_50.png)'
- en: let's see。 Let's just go--， [INAUDIBLE]， Hang on。 This the only-- like this
    one？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看看。我们直接去——[听不清]，等一下。只有这个——像这个吗？
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_52.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_52.png)'
- en: It's going to be that well。 It's going to be the same thing if I do--。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我做了——那将会是一样的事情。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_54.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_54.png)'
- en: if I--， if I did--， hang on。 OK。 So that's that one。 And then if we want to
    then--。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我——如果我做了——等一下。好了。所以是那个。然后如果我们想要再——。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_56.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_56.png)'
- en: let's see。 So let's print out what each one of those is。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看看。所以让我们打印出每一个那是什么。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_58.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_58.png)'
- en: P0x84--， 132。 Was that one of the OK， keep it once？
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: P0x84——132。那是其中之一吗？好了，保持一次吗？
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_60.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_60.png)'
- en: It is。 132。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它是。132。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_62.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_62.png)'
- en: And then let's see。 84d0--。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们看看。84d0——。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_64.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_64.png)'
- en: 208。 Yeah。 What are the other ones？ It's 41 and 198。 So we should get 41 should
    be 29。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 208。对了。其他的呢？是41和198。所以我们应该得到41应该是29。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_66.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_66.png)'
- en: And then C6 should be 198。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后C6应该是198。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_68.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_68.png)'
- en: OK。 Notice the order it's in。 It's in the wrong order。 It's backwards。 Well。
    the function that we called earlier that i net， underscore ntop function actually。
    knows that it's in the wrong--， no， there's in the little endian format。 And then
    gives us the correct string back。 OK。 But we haven't yet actually converted--。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。注意它的顺序。它的顺序是错的。是反过来的。好吧。我们之前调用的那个i net，_ntop函数实际上知道它的顺序是错的——不，实际上是小端格式。然后给我们返回正确的字符串。好的。但我们还没有真正转换过来——。
- en: like send anything over the network yet。 Yeah。 [INAUDIBLE]， Yeah。 It knows that
    by the time it gets into that number， it's whatever the computer's representation
    is。 So in this case， little nd。 When we actually send it across the network。 we
    have to turn it into a big nd number。 You have to do that so that everybody knows
    how to--。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还没有把数据发送到网络上。对。[听不清]，是的。它知道一旦它到达那个数字，它就会变成计算机的表示形式。所以在这个情况下是小端。当我们实际将它发送到网络上时，我们必须将它转变为大端数值。你必须这么做，大家才能知道如何处理——。
- en: '[INAUDIBLE]， Why big and not little？ Somebody made that decision。 I mean。 so
    do you know where the little ending and big， ending comes from？ You guys need
    to take more。 See。 this is so supposedly Stanford is a liberal arts， university。
    That''s what I understand。 But it comes from Gulliver''s Travels。 So in Gulliver''s
    Travels， there were。'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，为什么是大端而不是小端？有人做了这个决定。我是说。你们知道小端和大端的来历吗？你们需要了解更多。看。这 supposedly 是斯坦福大学的一个文理学院大学。这是我所理解的。但它来源于《格列佛游记》。所以在《格列佛游记》里，有...'
- en: the little Indians and the big Indians who cracked their eggs， either on the
    big end。 to open them up， or like their hard-well or soft-well， of eggs or whatever，
    or the little endian。 And they got a big fight over it。 And so somebody who ever
    is creating this said， oh。 it looks like the little end is there。 Oh， I remember
    this。 Oh。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 小端和大端的故事，关于他们是如何打破鸡蛋的，无论是从大端还是从小端打破，或者是硬煮蛋或软煮蛋，还是小端。而他们为此大打出手。所以无论是谁创造了这个，都会说，哦，看起来小端在那里。哦，我记得这个。哦。
- en: and this is also going to cause a big fight。 And that's why we get questions
    like， why？
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会引起一场大争论。这就是为什么我们会问问题，比如，为什么？
- en: What does it matter， and so forth。 So it was actually a perfect analogy， which
    turns out。 That's where it comes from as turns out。 OK， so while we're at it，
    let's look at the hostname 6。cc。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么关系，等等。所以这实际上是一个完美的类比，事实证明它的确来源于此。好的，既然我们在这儿，我们来看一下主机名6。cc。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_70.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_70.png)'
- en: which is the-- oops--。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是——哎呀——。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_72.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_72.png)'
- en: then resolve hostname 6。cc。 Let's look at this。 When we kind of look at this
    one already a little bit。 if we want to do IP version 6 addresses， we can actually
    look at them。 We have to actually use a get hostname。 We got hostname 2 and tell
    it。 We're looking for an I and a 6 address。 And then we have to check and make
    sure。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后解析主机名6。cc。我们来看一下这个。当我们稍微看一下这个时。如果我们想要处理IP版本6地址，我们实际上可以查看它们。我们必须实际使用一个获取主机名的命令。我们得到了主机名2并告诉它。我们在找I和6地址。然后我们需要检查并确保。
- en: that's an I and a 6 address， an IP version 6 address。 And then same sort of
    thing here。 We can use this function。 It knows how to convert IP version 6s。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那是I和6地址，即IP版本6地址。然后这里是同样的事情。我们可以使用这个函数。它知道如何转换IP版本6。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_74.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_74.png)'
- en: Let's see that one as we run it。 Let's actually do it on DDB just to see the
    difference。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行它时。我们实际在DDB上做一下，看看有什么不同。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_76.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_76.png)'
- en: Resolve hostname 6。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解析主机名6。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_78.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_78.png)'
- en: Let's first run it and see hostname， google。com。 There's google。com's address。
    Now。 there's 128 bits here。 This is a pretty big。 128 divided by 8 is 16。 That
    would mean 16。 There's not 16 here。 There's one， two， three， four， five， six，
    seven， basically seven， eight。 because it takes about 9， 10。 And there's a little
    extra double colons in there。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行它，看看主机名，[google.com](https://google.com)。这是[google.com](https://google.com)的地址。现在，这里有128位。这是一个相当大的数，128除以8是16。那就意味着16。这里不是16，有一个，两个，三个，四个，五个，六个，七个，基本上是七，八，因为它大约需要9、10位。而且里面还有一些额外的双冒号。
- en: This is a decision they made to try to make the IP version 6， number smaller。
    If there's a bunch of zeros in a row， you can actually put two colons and just
    look。 all the rest of the zeros in there。 I still think it's almost impossible
    for a human。 to figure out exactly what all that means。 It's not impossible， but
    it's just like。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他们做出的一个决定，试图让IP版本6的数字变得更小。如果有一串零，你其实可以放两个冒号，然后就看着剩下的所有零。我还是觉得人类几乎不可能搞明白所有这些意味着什么。虽然不是不可能，但就是像这样。
- en: you got a rock your brain about， where's the zeros， and how do they fit in？
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你得动动脑筋，想一想零在哪里，它们是如何适配的？
- en: And it was probably an uninspired decision， as far as I'm concerned。 But some
    places， actually。 when they remember an IP version， 6 address， there's 128 bits
    available， which。 is 2 to the 128 different addresses。 Actually， let me go to
    here。 Got the number in here。 There it is。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这可能是一个没有灵感的决定。但是实际上有些地方，记住一个IP版本6地址时，会有128位可用，也就是说，有2的128次方个不同的地址。实际上，让我去这里看看。我把数字找到了。就在这儿。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_80.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_80.png)'
- en: There are this many different IP addresses， that you can now have。 That number
    is bigger than the number of protons or atoms， in the universe， I believe。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以拥有这么多不同的IP地址。这个数字比宇宙中的质子或原子还要大，我相信。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_82.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_82.png)'
- en: So you will be able to assign every atom in the universe， an IP version 6 if
    you'd like。 So I doubt we'll run out of them， at least in our lifetimes。 But you
    never know， I suppose。 But they look at it。 So if you're a big enough company
    and you have enough cloud。 you can actually ask for a particular IP version 6。
    And why would you care about that？ Facebook。com。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你愿意，你就能为宇宙中的每一个原子分配一个IP版本6地址。我怀疑我们至少在我们的有生之年是不会用完这些地址的。但谁知道呢，我想。反正他们是这么看的。如果你是一个足够大的公司，并且你有足够的云计算资源，你实际上可以申请一个特定的IP版本6地址。那你为什么关心这个呢？[Facebook.com](https://facebook.com)。
- en: Take a look at Facebook's IP version 6 address。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看看Facebook的IP版本6地址。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_84.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_84.png)'
- en: It actually says Facebook in it， which is like， oh， how clever， how nice is
    that。 And again。 I don't even know why they didn't put just， two double colons。
    Again。 I don't understand how these things are。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它里面确实写了Facebook，这就像，哦，真聪明，真棒。而且我还不明白为什么他们不直接写两个双冒号。我依然不理解这些东西是如何工作的。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_86.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_86.png)'
- en: How these things are figured out。 But maybe someday they'll just have vanity
    IP addresses。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西是怎么被算出来的。但也许有一天他们会直接使用花哨的IP地址。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_88.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_88.png)'
- en: and you can get one for your phone or whatever。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的手机或其他设备获取一个地址。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_90.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_90.png)'
- en: Not that you actually care， but people of Facebook， I guess， care about these
    things。 Let's just run it。 Let's break on the same function as before。 Publish
    IP address info。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不在乎，但我猜，[Facebook](https://facebook.com)的人会在乎这些事。让我们继续运行它。我们照以前一样在相同的函数里中断。发布IP地址信息。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_92.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_92.png)'
- en: And then-- oh， no。 Is it not there？ Hang on。 Then。 Then。 Then resolve host name
    6。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后——哦，不。它不在那儿吗？等一下。然后。然后。然后解析主机名6。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_94.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_94.png)'
- en: They say it is called-- let's see。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说这被称作——让我们看看。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_96.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_96.png)'
- en: Publish-- oh， of course。 Publish IPV6。 Info。 Let me do that。 All right。 Break
    on that。 and then run it。 And yes， we're going to start it， and let's try Google
    again。 Notice I didn't do Stanford。 Wait， let me show you Stanford。 Yes。 Stanford。edu。
    Continue。 I don't know if it has it yet。 Just kind of too bad。 But anyway， that's
    the way that goes。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 发布——哦，当然。发布 IPV6。信息。让我来做一下。好了，打断这个，然后运行它。是的，我们要启动它，再试试 Google。注意，我没有做 Stanford。等一下，让我给你看一下
    Stanford。是的。Stanford.edu。继续。我不知道它是否已经有了。真是太遗憾了。不过，反正就是这么回事。
- en: Let's see。 Host name。 We'll try it again。 Google。com。 OK。 Google。com。 OK。 So
    you do the get host name， and then there， and then there。 And then we have to--
    again， we have。 to cast it to the struct i and address 6。 And that we have to
    actually do it。 So if we just type again--， let's see， pi_print_out_he。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再看看。主机名。我们再试一次。Google.com。好吧。Google.com。好。然后你执行获取主机名，然后是这里，然后是这里。然后我们必须——再说一遍，我们得把它转换为结构体
    i 和地址 6。然后我们必须真正执行它。所以如果我们再输入一次——让我们看看，pi_print_out_he。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_98.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_98.png)'
- en: It will give us the fact that it， has got a length of 16 for the number of bytes。
    and the actual address list， and so forth。 So there are some differences that
    you go into that。 Yeah， it has to。 When you do cast it as the struct i， and 6
    address star star。 it's because you're able to do， just address list。 Well， that's
    correct。 Right。 Good question。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它会告诉我们，它的字节数长度为 16，实际的地址列表等等。所以这里有一些不同的地方，你得了解。是的，它必须这样。当你把它转换为结构体 i 和 6 地址指针指针时，是因为你能操作地址列表。嗯，那是对的。没错。好问题。
- en: Take a look at the struct--。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个结构体——。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_100.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_100.png)'
- en: where did it go？ There it is。 OK。 So this is cast to a char star star。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它去哪了？在那里。好吧。所以这是强制转换为 char 指针指针。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_102.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_102.png)'
- en: It's not cast to what it really is。 Why is it cast to really-- why is it cast
    to really what。 it really is？ Because we want this to be generic enough。 to work
    with both IP version 4 and IP version 6， and any other one that you want。 There's
    actually another one that's IP。 I think it's just got a--， I think it's i-- what
    is it here？
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有强制转换为它真正的类型。为什么要强制转换为它真正的类型？因为我们希望它足够通用，能兼容 IP 版本 4、IP 版本 6，甚至你想要的其他任何版本。实际上还有另一个
    IP。我想它只是有一个——我想是 i——这里是什么？
- en: It's not i and address。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是 i 和地址。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_104.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_104.png)'
- en: It's i and addr_unix。 And it's its own type， meaning that you。 can use sockets
    like internal to a computer。 And it's another way of doing that。 So again。 this
    server thing is pretty robust。 But it's robust enough that there's。 some weird
    details in here that you kind of have to get to know。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 i 和 addr_unix。它是它自己的类型，意味着你可以像内部使用计算机的套接字一样使用它。这是另一种做法。所以再说一遍，这个服务器功能很强大。但它足够强大，里面有些奇怪的细节，你得去了解。
- en: But does that make sense about that？ Why you'd have to do that？ Mr。--， [INAUDIBLE]。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这让你明白了吗？为什么你必须这么做？先生——，[无法听清]。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_106.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_106.png)'
- en: How come you were going to do address list plus plus？ Yeah。 You can do address
    list plus plus because it knows now， that it's this type of strong。 Right？
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你要做地址列表加加？是的，你可以做地址列表加加，因为现在它知道是这种强类型，对吧？
- en: Once you do that， if you didn't do that， it would try to do one character at
    a time。 and it would get all screwed up。 Again， 107 stuff。 Yeah。 [INAUDIBLE]。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做了，如果你没有这么做，它会尝试一次处理一个字符，然后就会乱掉。再次提到 107 的内容。是的。[无法听清]。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_108.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_108.png)'
- en: I don't know what happened to version 5。 I mean， that's a good question。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道发生了什么，版本 5 怎么了。嗯，这是个好问题。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_110.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_110.png)'
- en: This could be deadly。 But what happened happened to the IPV5？ IP-- why is there
    no IP？
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是致命的。但是，IPV5 怎么了？IP——为什么没有 IP？
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_112.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_112.png)'
- en: Yeah， it might be like Windows 9。 Let's see。 Doesn't exist， so there is no IP
    version 5。 Let's see。 It was intentionally skipped to avoid confusion。 There was
    an experimental protocol called the internet。 stream protocol defined in 1190。
    And therefore， it was assigned IP version 5。 And we don't use that anymore。 So
    they said， oh， let's skip it。 Use 6。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这可能就像 Windows 9。让我们看看。不存在，所以没有 IP 版本 5。让我们看看。它是故意跳过的，以避免混淆。曾经有一个实验性协议叫做互联网流协议，在
    1190 中定义。因此，它被分配了 IP 版本 5。但我们现在不再使用它。所以他们说，哦，让我们跳过它，使用 6。
- en: Has nothing to do with those four bytes or six bytes or anything。 like that
    if that was one thing you were thinking。 So that's it。 OK。 That works。 All right。
    I know this stuff is definitely a bit crazy。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 跟那四个字节或六个字节什么的没有关系。如果你曾经这么想过，那就不对了。就这样。好的，行。知道这些东西确实有点疯狂。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_114.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_114.png)'
- en: So anyway， we've run a bunch of these here。 Now， let's talk about the sockets
    themselves。 When you are creating a socket-- remember we did？ We had the accept
    command and we had the create socket。 and so forth。 We are going to look at those
    in a little bit of detail。 to see how they're actually built。 We're going to look
    at the create client socket。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经运行了很多这样的操作。现在，让我们来谈谈插座本身。当你创建一个插座时——记得我们做过吗？我们有 `accept` 命令，也有创建插座的命令等等。我们将稍微详细地查看它们，看看它们到底是如何构建的。我们将查看创建客户端插座。
- en: and create server socket。 Now remember， they are two very different things。
    When you are creating a client socket， what you are trying to do is you're。 trying
    to reach out to some other computer， and connect to that computer's IP address
    and port。 So you're trying to actually go， let， me make a connection with some
    other computer。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以及创建服务器插座。记住，它们是两件完全不同的事情。当你创建客户端插座时，你要做的事情是，你要去连接到另一台计算机，连接到那台计算机的 IP 地址和端口。所以你实际上是要去连接另一台计算机。
- en: That's when you're creating the client socket。 You're trying to create the client
    socket。 When you are a host， if you're trying， to do the create server socket，
    all you need to do。 is get your local port number and try to assign it， to yourself。
    We call that binding it。 We'll see how that works。 So you don't actually reach
    out and get anybody。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那时你就是在创建客户端插座。你在创建客户端插座时。如果你是主机，如果你要做的是创建服务器插座，你所需要做的就是获取你本地的端口号，并试着分配给自己。我们叫这个绑定。我们将看到它是如何工作的。所以你实际上并不去连接任何人。
- en: when you're doing a server。 So you're basically saying， hey， I'm here。 Please。
    I'm listening for people to connect to me。 Or other computers to connect to me。
    That's the big difference there。 Now， of course， we have different types of sockets
    here。 This is also， again， where it gets a little bit pokey。 We have a generic
    socket。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在做服务器时。你基本上是在说，嘿，我在这里。请连接我，或者其他计算机连接我。这是一个很大的区别。现在，当然，我们这里有不同类型的插座。这里又是它变得有点复杂的地方。我们有一个通用插座。
- en: The generic socket is struct-socket-dress。 And it has its first element--。 its
    first member is this unsigned short called SA family。 It's a two-byte value called
    SA family。 which， is going to be the--， this is going to say what protocol it
    is。 Then we have a really bizarre SA data 14 bytes worth。 But that's it。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通用插座是 `struct-socket-dress`。它的第一个元素——它的第一个成员是一个无符号短整型，叫做 SA family。它是一个两字节的值，叫做
    SA family。它会告诉我们——这将表示它是什么协议。然后我们有一个非常奇怪的 `SA data`，是 14 字节。但就这些了。
- en: It doesn't say anything else about that， except that it says there's 14 bytes
    there。 And you say。 oh， all right， maybe that 14 bytes， is going to be useful
    for something。 I don't really see。 Then we have struct-socket-dress-in for internet。
    This is the IP version for version。 And it also has as its first two bytes， the
    family， the internet socket internet family。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有再说明其他内容，除了说那里有 14 字节。然后你可能会想，哦，好的，也许这 14 字节将来会有用。我其实看不出它有什么用处。接下来是 `struct-socket-dress-in`，用于互联网。这是
    IP 版本的表示方式。它的前两个字节是家庭，互联网插座的互联网家庭。
- en: And then it then has a port number associated with it。 And then it has one of
    these struct-i and addresses， which we saw earlier， sine ADDR， which。 says the
    actual four-byte internet address in it。 Remember， it says weird。 It's four bytes
    and not-- it's actually a struct， which is weird。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它有一个与之关联的端口号。接着它有一个我们之前看到的 `struct-i` 地址，叫做 `ADDR`，表示实际的四字节互联网地址。记住，它是奇怪的。它是四字节而不是——它实际上是一个结构体，这挺奇怪的。
- en: And then it has eight bytes worth of zeros。 And they're defined to be zeros。
    And it turns out they're completely ignored， although most people actually just
    do set them to zero。 because it says zero in the name。 And so they figure out
    I should probably just set it to zero。 It actually probably doesn't matter one
    bit。 They're completely ignored。 So what is that？ Well。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它有八个字节的零值。这些零值被定义为零。事实证明，它们完全被忽略，尽管大多数人实际上会将它们设置为零，因为名字里有零。所以他们认为应该把它设为零。实际上，这可能完全不重要。它们完全被忽略。那么这是什么？
- en: I don't know。 We'll see。 Let's count the bytes， first of all。 Let's see if this
    actually does anything。 How many bytes is a short？ Two。 Short's another two。 There's
    four。 How many bytes is an unsigned in， which is the INRS？ Four。 So that's eight
    total。 And then there's eight more。 So that's 16。 And then up here， we add two
    there and 14 there。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道。我们拭目以待。首先，先数一下字节数。看看这是否真的有作用。一个短整型占多少字节？两个。另一个短整型再占两个。总共四个字节。无符号整数（INRS）占多少字节？四个。所以总共有八个字节。然后还有八个字节。那就是十六个字节。接着在这里，我们加上两个字节，再加上十四个字节。
- en: So that's 16。 OK， that sounds like it might make sense。 Let's look at the internet
    version。 sixth version。 Well， it also has the first two bytes as the family。 Then
    it's got the first two bytes as the port。 Remember， ports are only two bytes。
    either whether you're， using IP version 6 or 4。 And then it's got a struct IN6
    address。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那是 16。好了，听起来好像有些道理。我们来看一下互联网版本。第六版。它同样也将前两个字节作为家庭类型。然后它的前两个字节是端口。记住，端口只有两个字节。不管你是使用
    IPv6 还是 IPv4。接着它包含一个 IN6 地址结构。
- en: And that's going to be sign a sin 6 address。 How big is 128 bytes？ And how big
    is 128 bits in bytes。 rather？ 16。 16 plus 4 is 20 plus 2 is 22 plus 2 is 24。 Plus
    another 4 is 28 for this one。 Is that 16？ No。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那将会是签名的 sin 6 地址。128 字节有多大？128 位转换成字节是多少？16个字节。16 加 4 等于 20，再加 2 等于 22，再加 2
    等于 24。再加上另外 4 个字节是 28。这个是 16 吗？不是。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_116.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_116.png)'
- en: I have no idea why this is the case。 It turns out that it really doesn't matter。
    that there's this 14 byte one there。 I think there has to be something there。
    to make the compilation work right。 That's about all I can figure out。 The various
    resources I've looked at said， and it just kind of doesn't matter。 So whatever。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么会是这样。事实证明，这其实并不重要。就算有一个 14 字节的部分在那里，似乎也没关系。我认为必须有些东西在那里，以使编译能够正常工作。这是我能理解的全部了。我查阅的各种资料也说，这似乎并不重要。所以无所谓。
- en: '[INAUDIBLE]， What''s what？ [INAUDIBLE]， Oh， sorry。 Flow info and scope ID。
    I''m not even sure what those are。 Those are specific things to IP version 6。
    The nice thing about this part of this thing， is that it is generic enough so
    you can have this that。 has extra stuff in it。 Flow info might have something
    to do with the actual back。'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，什么？[听不清]，哦，对不起。流信息和范围 ID。我甚至不确定它们是什么。它们是专门针对 IPv6 的一些东西。这部分的好处在于它足够通用，所以你可以在其中添加额外的内容。流信息可能与实际的后端有关。'
- en: and forth between the server and client。 Maybe it's more efficient than something
    else。 And they wanted to add it in there。 Scope ID might be something else too。
    I just don't know。 But it's beyond a scope of this class。 No pun intended。 But
    it's just extra information that goes along with it there。 OK。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端之间来回交换。也许它比其他某些方式更高效。于是他们想把它加进去。范围 ID 可能是其他的东西。我只是不知道。但是这超出了本课程的范围。没有恶意的意思。只是一些与之相关的附加信息。好了。
- en: So that's what a SOC address looks like。 We've got this generic one， which。
    doesn't seem to do much for us， except that it has， this family in there。 And
    then we've got these other ones， that have the family as well as the first two
    bytes。 and then extra stuff in them。 That's the important stuff。 In fact， there's
    not just two。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个 SOC 地址的样子。我们有这个通用的，似乎对我们没有太大帮助的地址，除了它包含了这个家庭类型。然后我们还有这些其他的地址，包含了家庭类型以及前两个字节，接着还有额外的信息。这才是关键的部分。实际上，不止两个字节。
- en: There's this other Unix one and there's other ones as well。 Socket is a very
    generic type of structure。 OK。 So that's that。 Anyway， as I said， the version
    6。1 has some other stuff in it。 You will rarely ever declare variables that are
    of this type。 OK。 This is kind of like an abstract class or something， in Java
    or those sorts of things。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的 Unix 类型，以及其他的类型。Socket 是一种非常通用的结构类型。好了，就是这些。不管怎样，正如我所说，版本 6.1 中包含了其他一些内容。你很少会声明这种类型的变量。好吧，这有点像
    Java 中的抽象类或者类似的东西。
- en: where you've got this， definition that you will never actually use。 It's just
    there so that other things that are--， that kind of inherent from it can be used。
    OK。 So you will rarely ever do an actual SOC ADDR。 You'll do the one you want
    for the particular socket。 you're trying to create。 OK。 And Linux actually does
    kind of one set for both。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个定义，你实际上永远不会使用它。它只是存在，为了让其他从中继承的东西可以被使用。好的。所以你几乎不会实际做一个SOC ADDR。你会做你想要的那个，针对特定插槽你正试图创建的。好的。实际上
    Linux 会为两者做一种设置。
- en: because they want to make it generic。 OK。 What you're going to have to do--
    and we'll see this。 when we actually write the code--， is you are going to have
    to do some casting associated。 with these to get the right value out。 Now， if
    you remember from CS107， all。 of that casting you would have had to do， when you
    did generic functions。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为他们想要使其通用。好的。你必须做的事情——我们在实际写代码时会看到——是你必须进行一些与这些相关的类型转换，才能获取正确的值。现在，如果你还记得 CS107
    中的内容，你就会知道，你必须做这些类型转换，特别是在编写通用函数时。
- en: There are times when you are， say， writing a function that， has two void star
    pointers。 where you don't really know--， you know when you're writing it， but
    the compiler has no idea。 what type it is， because it expects void star pointers。
    You know。 because you're the one writing the function， that， oh， really， these
    are char star star pointers。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，比如你正在写一个函数，它有两个 `void*` 指针。在写函数时你知道类型，但编译器没有任何概念，因为它期望的是 `void*` 指针。你知道的，因为你是编写函数的人，哦，实际上这些是
    `char**` 指针。
- en: or something like that， inside the function， you will actually cast them。 It's
    going to be very similar when we go and figure out， what these are。 when we actually
    write these two functions， we're about to write。 All right。 We are going to write
    two functions。 The one is create client socket。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或类似的东西，在函数内部，你实际上会进行类型转换。当我们实际编写这两个函数时，它们将会非常相似。好的。我们将写两个函数，一个是创建客户端插槽。
- en: The other is create server socket。 The client socket is a little bit easier。
    even though it seems like there's more to do。 You're actually trying to reach
    out to this other computer。 and connect to it。 But there's not that much really
    to do。 You know that you're going to know the port number， and the address。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是创建服务器插槽。客户端插槽稍微简单一点，尽管看起来似乎有更多的事情要做。实际上你是试图联系另一台计算机，并与其连接。但实际上并没有那么多事情需要做。你知道你需要知道端口号和地址。
- en: And then you have to set up the socket to do it。 And that's what we're going
    to do。 What we're going to do is we are going to confirm， that we can actually
    talk to the IP address。 Well， confirm that the IP address exists for that host。
    We're going to try to go to some host and we're going to go up。 We need the IP
    address。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你必须设置插槽来执行它。这就是我们要做的事情。我们要确认，我们实际上能够与 IP 地址进行通信。嗯，确认该主机的 IP 地址存在。我们将尝试连接某个主机，我们需要这个
    IP 地址。
- en: Let's see if it exists。 Then we are going to allocate a new descriptor。 This
    is exactly like except very different from a regular descriptor， file descriptor。
    It's just like the file descriptor in that it lives in the file。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是否存在。然后我们将分配一个新的描述符。这与常规的文件描述符非常相似，但又非常不同。它就像文件描述符一样，存在于文件中。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_118.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_118.png)'
- en: descriptor table and it has an open file descriptor and so forth。 But you don't
    use it in the same way。 It's a double。 It's a two-way communications instead of
    a one-way， which most of our other descriptors were。 You use this system call
    called socket， to actually configure a socket descriptor。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符表，它有一个打开的文件描述符等等。但你并不是用它的方式与其他描述符一样使用它。它是双向的。它是一种双向通信，而我们其他大多数描述符是单向的。你会使用一个叫做
    socket 的系统调用，来实际配置一个插槽描述符。
- en: When you use socket， it doesn't actually， talk to any other computer yet。 It
    just sets up the socket so that you can， populate it with the right details。 And
    then use it。 Then we have to create an instance of socket address， underscore
    IN if we're doing IPv4。 And then that packages up the host and port number。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 socket 时，它实际上并不会与其他计算机通信。它只是设置插槽，以便你可以用正确的细节填充它。然后使用它。接着，如果我们在做 IPv4，我们必须创建一个
    socket 地址实例，命名为 `IN`，然后它将主机和端口号打包起来。
- en: That packages all the details that we're going to connect to。 We'll do that。
    And then now you've got this socket that you've set up。 Now you can actually go
    and connect it to the other computer。 That's what we're going to do。 And then
    if all goes well， you return that socket to whatever。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它打包了所有我们要连接的细节。我们会做这个。然后现在你已经设置好了这个套接字。现在你可以真正去连接另一个计算机了。我们将要做的就是这个。如果一切顺利，你就将那个套接字返回给任何需要的人。
- en: program or whatever function requested it。 OK？ Question。 Is that it？ Conceptually。
    how is this different from just setting up， a server in a client like we did？
    Yeah， good question。 The question is conceptually， how is this different than
    setting， up？
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 程序或者其他请求它的功能。明白吗？问题是。这就结束了吗？从概念上讲，这和我们之前设置服务器和客户端的方式有何不同？是的，这是个好问题。问题是，从概念上讲，这和设置服务器和客户端有何不同？
- en: Now we're doing the details of setting it up。 So we actually called these functions
    before。 Now we're actually going to go and dig in and go， what do I look like？
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在设置的细节。所以我们之前实际上已经调用了这些函数。现在我们真正要做的是深入挖掘，看看我应该怎么做？
- en: And that's where all this other stuff that we had to get to， is involved。 Good
    question。 So the socket descriptor， the thousand of the files。 A socket descriptor
    lives in the file of the descriptor table。 The type is a socket。 So it's not a
    read file， write only file， et cetera。 It's a socket。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要获取的所有其他内容所在的地方。好问题。所以套接字描述符，文件的千分之一。套接字描述符位于文件描述符表中。它的类型是套接字。所以它不是一个只读文件、只写文件等等。它是一个套接字。
- en: And it's got more details associated with it because it。 needs to be too way
    and potentially connect other， computers and so forth。 But because pretty much
    everything in Unix is a file， they still made it a file。 even though you can't
    use it， quite like you would in your local file descriptor。 All right。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它有更多的细节，因为它需要双向连接并可能连接其他计算机等等。但由于几乎所有的Unix系统中都将一切都视为文件，它们仍然把它当作一个文件，尽管你不能像在本地文件描述符中那样使用它。好吧。
- en: let's actually do this。 OK。 Let's go and do this one now。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际操作一下。好的，现在我们来做这个。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_120.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_120.png)'
- en: Let's see。 We want to do client sockets。cc。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。我们想做客户端套接字。cc。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_122.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_122.png)'
- en: OK。 This one is here。 You've also got this code so you can follow one as we
    do this。 We are going to do struct host and hv equals get host by name。 And then
    the name that we passed in。 host。cster， like that。 Which is exactly what we did。
    We've talked about for 10 minutes earlier。 Because we're trying to just figure
    out if it's there。 All right。 If he is no。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这个是这里。你还有这段代码，这样你就能跟着我们一起操作了。我们将做 `struct host` 和 `hv = get host by name`。然后是我们传入的名称，`host.cster`，就像这样。这正是我们之前谈了10分钟的内容。因为我们只是在试图搞清楚它是否存在。好吧。如果它不存在。
- en: we're just going to return negative one， which， said， look， we didn't get it。
    We don't know what address you're talking about。 And then hopefully whoever's
    calling create client circuit。 is paying attention to the return value and then
    knows， oops。 I didn't get the socket that I requested。 And then we do in s equals。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是返回-1，这表示，看看，我们没有获得它。我们不知道你说的是哪个地址。然后希望调用 `create client circuit` 的人注意到返回值，然后知道，哎呀，我没有获得我请求的套接字。接着我们会做
    `in s =`。
- en: And this is where we call the socket function to set up the， socket。 In this
    case。 we're doing afinet。 And then we're doing SOC stream。 And then let me talk
    about that in a second。 SOC stream is basically telling the operating system，
    please， please。 please handle this the way the regular old， internet works。 And
    you might say， well。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们调用套接字函数来设置套接字的地方。在这种情况下，我们使用的是afinet。然后我们使用的是SOC stream。接下来我会稍微讲一下。SOC
    stream 基本上是在告诉操作系统，拜托，拜托，拜托，按照传统的互联网方式来处理这个。你可能会说，好吧。
- en: how does a regular， internet work？ Well， I'm going to tell you。 When you send
    data between two computers， you don't send one long stream of data like all at
    once。 until you're done。 I mean， you kind of do。 But what happens in the way they've
    set it up is it's sent。 in packets。 A packet can be very sizes。 I think most--。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的互联网是怎么工作的？嗯，我来告诉你。当你在两台计算机之间发送数据时，你并不是一次性发送一大串数据直到发送完毕。我的意思是，你有时确实会这样做。但是他们的设置方式是，它会分包发送。一个包的大小可以非常不同。我想大多数——。
- en: I'm not exactly sure how big a packet is right now。 It might be something like
    128 bytes or something like that。 It's relatively small。 but it made it 512。 But
    it has information about the data。 It has a packet number。 And it has information
    about the data itself。 And then it has some of that data。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不太确定一个包裹有多大。可能像128字节之类的东西。它相对较小，但可能有512字节。但它包含了数据的信息。它有一个包裹号。还有关于数据本身的信息。然后，它会有一些数据。
- en: And you send a whole bunch of these packets off to some， computer。 And they
    all take different paths around the internet。 Many of them go on the same path。
    because it happens to be， the shortest path。 But it might not。 And some of your
    packets may go down one path。 Some might go down another path。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你把这些包裹发送到某台计算机，而它们可能走不同的网络路径。很多包裹会走相同的路径，因为恰好是最短的路径。但也可能不是。有些包裹可能会走一条路径，而有些可能走另一条路径。
- en: And they all meet up at the computer where they're trying。 to be heard in the
    one you're sending them to。 And they may end up in the wrong order。 If they end
    up in the wrong order， it actually doesn't， matter， because the other computer
    is going。 OK， I'm， going to listen for all these packets。 And if I get packet
    two first。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最终都会在计算机那里汇聚，那里是你要把它们发送到的地方。而且它们可能会以错误的顺序到达。如果它们的顺序错了，实际上也没关系，因为另一台计算机会说：“好吧，我要等所有这些包裹。如果我先收到包裹二。”
- en: I'm just going to hold it， aside until I get packet one。 And then I'm going
    to know that I got packets one and two。 And I'm going to order them all when I
    get them。 And sometimes packets get dropped。 In fact。 packets get dropped all
    the time。 Some computer goes down， or there's a glitch somewhere。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我就先把它搁在一边，直到我收到包裹一。然后我就知道我收到了包裹一和包裹二。等我把它们都收到以后，我会把它们排序。有时候包裹会丢失。事实上，包裹经常丢失。有些计算机宕机了，或者某个地方出了故障。
- en: or whatever。 If a packet gets lost， there's a time out associated with that。
    On both ends。 as it turns out。 When a receiving computer gets a packet， it sends
    an， acknowledgment packet back。 It says， I got your packet number three。 And then
    the sending computer goes， OK， packet three got。 three。 And it checks it off the
    list。 If the receiving computer doesn't get packet three， it。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者其他的。如果一个包裹丢失了，双方都有一个超时的机制。结果是，接收计算机收到一个包裹后，会发回一个确认包裹。它会说：“我收到了你的包裹三。”然后发送计算机就会说：“好的，包裹三收到了。”然后它会把它勾掉。如果接收计算机没有收到包裹三，它就……
- en: waits a little bit of time。 And then sends a-- actually， it just waits。 I believe。
    It just sits there and waits。 It's the sending computer that says， oh， I never
    got an。 acknowledgment。 I better send another packet。 And it keeps sending them
    until it gets through。 And that's sometimes why I can take your file。 That's sometimes
    why your file is buffers and so forth。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一小段时间。然后发送——实际上，它只是等待。我相信。它只是静静地坐着等。是发送计算机说：“哦，我没有收到确认信号。我得再发送一个包裹。”它会一直发送，直到发送成功。这有时候就是为什么我能接收你的文件，这也是为什么你的文件会有缓存等问题。
- en: Question。 But is it-- what is the accepting packet that's lost？ Yeah， a good
    question。 That's such a good question。 What if the acknowledgment packet gets
    lost？
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 问题来了。但是，接受包裹丢失了怎么办？是的，这是个好问题。真是个好问题。如果确认包裹丢失了怎么办？
- en: It's exactly the same thing。 The sending computer says， oh， they never got my
    thing。 They send another one。 And then the receiving computer， if it gets two
    packet， three。 it ignores one of them。 It ignores the second one。 It's because
    I already got it。 So it's robust in that sense。 There is a problem called the--。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是一样的。发送计算机说：“哦，他们没有收到我的东西。”然后再发送一个。接收计算机如果收到了两个包裹，三个，它就会忽略其中一个。它忽略第二个包裹，因为我已经收到了。所以从这个意义上来说，它是健壮的。不过，也有一个问题，叫做——。
- en: it's called-- why am I blanking on it？ The-- let me think about this for a second。
    Say again？
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它叫——为什么我现在想不起来了？让我想一想。再说一遍？
- en: Is this forward？ No， no， no。 The Byzantine Emperor's problem。 That's what it
    is。 You know。 Byzantine generals problem。 Again， liberal arts education。 The Byzantine
    generals problem is。 what happens if there's two generals on two hills， and they
    both want to， and they want。 to coordinate attacking a valley。 And they have to
    agree on the time。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前进的问题吗？不，不，不。是拜占庭皇帝问题。就是这个。你知道，拜占庭将军问题。再一次，文科教育。拜占庭将军问题是，如果有两个将军站在两个山头上，他们都想——他们想协调攻击一个山谷。并且他们必须就攻击时间达成一致。
- en: They have to attack the valley。 And let's say one general sends a message to
    the other general。 and says， we're going to attack at 7 a。m。 And the other one
    sends a message back that says， OK。 we know we're going to attack at 7。 But what
    if then you never get those like acknowledgments？
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 他们必须攻击那个山谷。假设一个将军给另一个将军发送消息，说我们将在早上7点发动攻击。另一个将军回信说，好的，我们知道我们将在7点攻击。但是如果你从未收到那些确认消息呢？
- en: And even if you do， how does the one who sent the acknowledgment。 know that
    the other one got the acknowledgment？ And then like-- so you can never quite exactly
    coordinate。 So there's always-- there's a little bit of an issue there。 But generally，
    you send how many total。 bites you want at the beginning， and hopefully that gets
    through。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你做到了，发送确认的人怎么知道另一个人收到了确认呢？然后就像——所以你永远不能完全精确地协调。所以总是会有一点小问题在那里。但通常情况下，你在开始时发送你需要的总字节数，希望它能够传送成功。
- en: and you get an acknowledgment on that， and whatever。 It turns out it works out
    OK， as it turns out。 But that's how it works。 So basically， you send a bunch of
    these packets on。 Here's what Sockstream does。 Sockstream says to the operating
    system。 please take care of all of the details of that packet back， and forth
    for me。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你收到一个确认消息，什么的。结果证明它运行得还不错，正如它的工作原理一样。所以基本上，你会发送一堆这样的数据包。Sockstream做的事情是，Sockstream告诉操作系统，"请为我处理这些数据包来回的所有细节"。
- en: If you don't want them to the operating system to do that。 let's say instead
    you wanted to handle it all yourself。 You just want to send the packet and let
    them go in the order， they're in and go and do that。 There's more work for you
    to do， especially if you want， to keep everything。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让操作系统来处理这些事，假设你想自己处理所有的事情。你只想发送数据包，让它们按顺序发送并去做。那样你就需要做更多的工作，特别是如果你想要确保一切都保持一致。
- en: like make sure that the other end got， the packet。 You have to do all that。
    And you may want to do that。 Let's say you're sending video data or something。
    and you don't care about every bite or every packet。 Maybe you want to do that。
    You want to send it that way。 You can say， hey， I'll take care of it。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 比如确保另一端收到了数据包。你必须做所有这些。你可能会想这么做。假设你正在发送视频数据或者其他什么，而你不在乎每个字节或每个数据包。也许你想这么做。你可以说，"嘿，我来处理这些事情"。
- en: because it doesn't matter that ever a few bites of the video， gets a little
    blurry for a second。 Who cares， at least it continues， instead， of having to be
    slowed down by this acknowledgment business。 and all that。 So there are reasons
    to do that。 We will only stick to SOC string， in this case。 All right？ OK， so
    that's that if S is less than 0。 Again， that means we had a problem。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为即便视频的几帧变得模糊一秒钟，也没关系。谁在乎呢，至少它继续播放，而不是因为确认的问题被迫减速。所以这样做是有原因的。在这种情况下，我们只会坚持使用SOC字符串。好吧？好的，那就是如果S小于0的情况。再次说明，这意味着我们遇到了问题。
- en: Return negative 1。 Now we have to do struct SOC address， and address。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 返回负1。现在我们必须做struct SOC address，以及地址。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_124.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_124.png)'
- en: And we need to populate this address we're creating here。 because we're actually
    going to use it to do the connection。 So we are going to do this。 Now。 the first
    thing we're going to do， is memset and percent address 0 size of struct SOC address。
    And like that-- actually， I guess we can just do--， I have that in private， but
    you also just。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要填充我们在这里创建的这个地址，因为我们实际上会用它来进行连接。所以我们将这样做。现在，首先我们要做的是使用memset并填充地址为0，大小为struct
    SOC address。就像这样——实际上，我想我们可以直接做——我已经在私有部分写好了，但你也可以直接做。
- en: do size of address。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 做地址的大小。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_126.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_126.png)'
- en: I think both would work。 We're doing that just in 0 out of memory。 Again。 it
    probably doesn't matter， as it turns out。 But we just do it because it says， hey。
    these things should be 0。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为两者都可以。我们这么做只是为了清除内存。再次说明，这可能并不重要，结果可能没差，但我们这么做是因为它要求这些内容应该为0。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_128.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_128.png)'
- en: It's not actually a matter。 I think we fill in all the bytes anyway， because
    it turns out。 OK。 Then we're going to do address。internet， basically， socket internet
    family equals affinet。 And then we are going to do address。sonport equals。 Now。
    here's where we need to make it into a network number。 When we're going to set
    up the socket。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这其实没什么关系。我觉得我们反正会填充所有字节，因为事实证明。好的。那么接下来我们要做的是，地址。internet，基本上，套接字互联网族等于affinet。然后我们要做的是，地址。sonport等于。现在。就在这里我们需要将它转变为网络号码。当我们设置套接字时。
- en: we have to make sure that it's correct for the network order。 I'm not sure why
    they couldn't just make the connect thing do this。 But you need to actually do
    the following。 You need to just say， htonsport。 And that stands for-- it stands
    for--， let's see， h-- forget now。 The host-- yeah。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保它符合网络顺序。我不确定为什么他们不能直接让连接函数来做这个。但是你需要实际执行以下操作。你需要直接说，htonsport。它代表--它代表--，让我看看，h--现在忘记了。主机--是的。
- en: host to network short。 It's going to convert the port to the correct address。
    Going to flip those two bytes， as it turns out。 If you were building this on a
    big M in machine。 that would be a no operation function。 It would actually do
    nothing。 because it's already in that order。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 主机到网络短。它将把端口转换为正确的地址。实际上会翻转这两个字节。如果你在一个大端机器上构建这个，那将是一个无操作的函数。它实际上什么也不做。因为它已经是那个顺序了。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_130.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_130.png)'
- en: That's the way it goes。 OK。 So we have to do that。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么回事。好的。所以我们必须这么做。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_132.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_132.png)'
- en: All right。 So then we're going to do the address equals。 OK。 Ready for this？
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们接下来要做的是地址等于。好了，准备好了吗？
- en: We have to now cast it appropriately。 Two， we have to cast it to a struct， internet，
    a， d， d， r。 like that， h， e， h， e， r。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须适当地进行转换。第二，我们必须将其转换为一个结构体，internet，a，d，d，r。像这样，h，e，h，e，r。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_134.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_134.png)'
- en: Why are we doing-- oops， what do I do here？ Hang on。 A sign， a， d， d， r， equals。
    There。 did I forget the number of-- yes， I did。 I must have forgotten on there，
    but we won't yet。 So now we are casting that 4 by int we got to an actual struct。
    to make sure it goes into the struct correctly。 Why？ Because it's a struct and
    not actually an int。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要这么做--哎呀，我在这里做了什么？等一下。一个，a，d，d，r，等于。好了。难道我忘了那个数字了吗--是的，我忘了。我一定在这里忘记了，但是我们现在不管它。所以现在我们要将那个4字节整数转换为一个实际的结构体。确保它正确地进入结构体。为什么？因为它是一个结构体，而不是一个整数。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_136.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_136.png)'
- en: So it goes。 So we do that。 And then we call this connect function。 If， connect。
    We are passing in the socket that we don't--， it has nothing associated with it
    yet。 We are about to do that。 We have another cast we have to do here， struct，
    sock， address， star。 This is basically down casting it。 It's losing information
    in the big picture。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它是这样的。然后我们调用这个连接函数。如果，连接。我们传入的是那个我们还没有--与之关联的套接字。我们马上就要做那个。我们在这里还有一个转换需要做，结构体，sock，address，star。这基本上是向下转换。它在大图中丢失了信息。
- en: It's losing information when you do this in the sense。 that the compiler is
    going to be looking for a sock address， instead of a sock address i n。 And you
    say， well， how do you ever get that information back？ Well。 let's talk about that
    after you do this line， size of address， and equals equals 0。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这么做时，它会丢失信息。因为编译器将会查找一个套接字地址，而不是一个套接字地址i n。你可能会问，嗯，如何把这些信息找回来呢？嗯。我们在你执行这一行之后再讨论这个问题，地址的大小，等于0。
- en: That's the actual connect line。 How does the socket-- or sorry， the connect
    function。 know that we are doing internet version 4？ That's the question。 How
    does it know？
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实际的连接行。那这个套接字--或者说，连接函数。怎么知道我们在使用互联网版本4？这是问题。它怎么知道？
- en: What did we say was the same about every one of these？ The first two bytes is
    always the address。 family。 So if we know that the first two bytes are always，
    in address， I mean。 we know that structs always， have to be in the order of the
    members。 We can actually look at that first member， and say that member must be
    the type。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，每个这些的相同之处是什么？前两个字节总是地址。族。所以如果我们知道前两个字节总是地址，我是说。我们知道结构体的成员总是必须按顺序排列。我们实际上可以查看第一个成员，并说这个成员必须是该类型。
- en: And then inside the connect function， as well if the type is internet address
    4。 let's handle it this way。 If it's 6， we'll handle it this way。 If it's units，
    we'll end up this way。 et cetera。 So it tells that by knowing what it is。 All
    right。 OK， if that's a return 0。 meaning that we--， or sorry， return s， meaning
    that we actually， got the correct socket for now。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `connect` 函数内部，如果类型是互联网地址4，我们就按这种方式处理。如果是6，我们就按这种方式处理。如果是单位，我们就按这种方式处理，等等。所以它通过知道是什么来决定的。好了，好的，如果返回值是0，意味着我们——或者说，返回值是
    `s`，意味着我们实际上获得了正确的套接字。
- en: '[INAUDIBLE]， Yeah。 OK， how does it know？ We are creating this up here。 Now。
    it''s one of the types of internet address family， set up like structs， right？'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[不清楚]，对。那么，它怎么知道的？我们在这里创建它。现在，它是互联网地址族的一种类型，像结构体一样设置，对吧？'
- en: The first two bytes have to be。 In fact， we set them here。 The first two bytes
    are the family。 So any time you get one of these generic socket， address ones，
    if you look at the first two bytes。 it will be a family。 And then you can say，
    oh， I know what the various families are。 Therefore。 it must be of this type，
    socket address i n。 And therefore， they treat it that way。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字节必须是这样的。实际上，我们在这里设置了它们。前两个字节表示的是族。因此，每当你遇到这些通用的套接字地址时，如果你查看前两个字节，它会是一个族。然后你就可以说，哦，我知道有哪些不同的族。因此，它必须是这种类型，套接字地址
    `in`。所以他们就会以这种方式处理它。
- en: So the connect function needs to know the different types。 And it looks at the
    first two bytes。 says， oh， that one's 2， or that one's 4， that one's 8， or whatever，
    and the number is。 And then it decides internally， oh， I know what this is。 That's
    how it does it。 Now。 you can't do that in C because you can't overload， function
    declaration types。 So therefore。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 `connect` 函数需要知道不同的类型。它会查看前两个字节，然后说，哦，那个是2，或者那个是4，那个是8，或者其他什么的，然后根据这个数字，它会在内部决定，哦，我知道这是什么。这就是它的工作方式。现在，你不能在
    C 语言中这么做，因为你不能重载函数声明类型。所以因此。
- en: you have to do it this wonky way。 CS107， yay。 That's what that all comes back
    to。 All right， now。 if for some reason you don't get a connection--， let's say
    the connection actually is broken or something--。 you have to close that socket
    that we created， because we opened--。 or that descriptor because we actually，
    opened a descriptor using socket。 And so therefore。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须以这种不太规范的方式来做。CS107，耶。这就是所有这些的根源。好了，现在，如果出于某种原因你没有连接——比如说连接实际上被断开了——你必须关闭我们创建的那个套接字，因为我们打开了——或者那个描述符，因为我们实际上通过套接字打开了一个描述符。因此。
- en: you have to close it。 So if you don't-- if you get to this line。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须关闭它。所以如果你没有——如果你到达这一行。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_138.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_138.png)'
- en: it means something's bad， and you need to close it， and then you return negative
    line like that。 Question。 So I noticed before deciding the SI and address the
    old--， [INAUDIBLE]， Yeah。 Just the court you take。 I was hoping nobody would ask
    that question。 The question is。 in a very good point。 In this case， you don't
    have to do the Indian-ness。 I think because--。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着某些地方出了问题，你需要关闭它，然后返回一个负数，比如这样。问题。之前我注意到在决定 SI 和地址之前，那个旧的——[不清楚]，对。只是你选择的路径。我本来希望没人问这个问题。这个问题是，非常好的观点。在这种情况下，你不需要做字节序的问题。我觉得因为——。
- en: let me think about this。 Yeah， I'm not exactly sure。 There's the reason why--
    I don't know why。 Why you have to do it up here， and you don't， have to do it
    down here。 I'm not 100% sure why。 Yeah。 I'm not sure。 I'll look it up。 I'll try
    to look at it and see。 This works。 Well， we can try it。 I mean， it's worked for
    every example we've used so far in class， so I assume it works in that case。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我想想。嗯，我不太确定。就是为什么——我不知道为什么——你必须在这里做，而在这里却不需要做。我不完全确定为什么。嗯，我不确定。我会查一下的。我会尽量看一下，看看。这个是有效的。我们可以尝试一下。我的意思是，它在我们课堂上使用的每个例子中都有效，所以我假设它在这个例子中也能工作。
- en: OK， so what do we have？
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那我们得到了什么？
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_140.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_140.png)'
- en: So that's the client connect function。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是客户端连接函数。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_142.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_142.png)'
- en: All right， let's actually make it and see。 Did anybody see any client socket？
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们实际创建并看看。有人看到客户端套接字了吗？
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_144.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_144.png)'
- en: See if that works。 A client socket。 OK， oh no。 Oh， I know why， because it's
    not-- it just。 needs to make it into a--， if we just type make in this case， it
    would work。 It's actually a library function that， doesn't need a main function。
    We don't have main in that。 OK。 any other questions on that？ Yes。 [INAUDIBLE]，
    Why do we close it？ [INAUDIBLE]。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这是否有效。一个客户端套接字。好的，哦不，哦，我知道为什么，因为它没有——它只是需要把它变成一个——如果我们在这种情况下输入make，它就能工作。实际上这是一个库函数，不需要一个main函数。我们没有main函数。好的，还有其他问题吗？是的。[听不清]，为什么我们要关闭它？[听不清]。
- en: If the call succeeds， we pass it back。 The user needs to close it。 Because you're
    setting up the socket， right？ So down here， you're saying。 let's actually connect
    to that， computer and get-- now the socket is an open file。 For-- it's an open
    file descriptor。 Or rather， it's a connected file descriptor， I should say。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们把它传回。用户需要关闭它。因为你在设置套接字，对吧？所以在这里，你说让我们实际连接到那台计算机并获取——现在套接字是一个打开的文件。对于——它是一个打开的文件描述符。或者更准确地说，它是一个已连接的文件描述符。
- en: And then you pass it back to the user who uses it。 [INAUDIBLE]， Yeah， yeah，
    the question is。 is that kind of like how sub-process， passes back and open file
    descriptor。 so the user has to close it。 Exactly。 Notice that we do close our
    descriptors when we're using them。 It turns out the screen， the socket stream，
    does the closing for us。 But it closes it。 Yeah。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将它传回给使用它的用户。[听不清]，是的，是的，问题是，是否有点像子进程传回一个打开的文件描述符，所以用户必须关闭它。没错。注意我们在使用描述符时会关闭它们。结果是，屏幕，套接字流会为我们关闭它。但它会关闭它。是的。
- en: good point。 The using function needs to actually close it。 Because that's the
    only one that knows when it's done。 OK。 So let's now look quickly at the server
    socket file。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，重点是使用的函数需要实际关闭它。因为只有它知道何时完成。好了，接下来我们快速看一下服务器套接字文件。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_146.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_146.png)'
- en: OK。 This one's going to be somewhat similar。 But we've got a couple extra little
    details to do to work on here。 OK。 So in the Create Server socket， we're， going
    to do basically the same thing。 And by the way。 we're only doing internet IPV4，
    in this case。 AF， iNet， OK。 Sockstream， 0。 So we don't need to get any IP address
    in this case。 Because the IP address is our IP address。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这个会稍微相似一些。但是我们有一些额外的细节需要处理。好的，在创建服务器套接字时，我们将基本上做相同的事情。顺便说一下，我们这里只有使用互联网 IPV4。AF，iNet，OK。Sockstream，0。所以在这种情况下，我们不需要获取任何IP地址。因为IP地址就是我们的IP地址。
- en: We're trying to set up a server on our computer。 So it actually turns out that
    it doesn't matter。 We could use one of our IP addresses。 And I say one of our
    IP addresses。 Because your computer often has net more than one IP address。 If
    you've got Bluetooth。 if you've got Wi-Fi， if you've got a cable， ethernet cable
    plugged in your computer。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在尝试在计算机上设置一个服务器。所以实际上结果是，没关系。我们可以使用我们其中一个IP地址。我说“其中一个IP地址”，是因为你的计算机通常会有多个IP地址。如果你有蓝牙，如果你有Wi-Fi，如果你有网线以太网线插入电脑。
- en: you are going to have multiple IP addresses。 So you can actually say， can that
    only。 allow connections on this Wi-Fi or whatever？ Or as it turns out， you can
    say any。 which we'll see in a second。 OK。 All right。 If that doesn't work。 we
    are going to return negative one。 It didn't even open yet， so we don't need to
    actually close it。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会有多个IP地址。所以你实际上可以说，能不能只允许在这个Wi-Fi上连接，或者如你所见，你可以说任何地址。我们马上就会看到。好的。好了，如果这不起作用，我们将返回负一。它甚至还没有打开，所以我们不需要实际关闭它。
- en: But if it did open， then we can go on。 We can go OK， struct。 And same things
    before， SOC， address。 high， and address。 This is going to look relatively familiar。
    And then we're going to M。 set address， 0， size of address。 OK。 And then we are
    going to set the sign for the family。 And this is， again， how the socket function
    is going to--， or in this case， the bind function。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果它确实打开了，我们就可以继续。我们可以继续，结构体，和之前一样，SOC，地址。高地址和地址。这个看起来应该相对熟悉。然后我们将调用M，设置地址，0，地址的大小。好的。接下来我们将设置家庭的标志。再一次，这是套接字函数将如何——或者在这种情况下是bind函数。
- en: is going to know how to interpret our downcasted address， or downcasted SOC
    address。 OK。 So we're going to do that。 And SOC family equals a， f， i net。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 它将知道如何解释我们下转的地址，或者下转的SOC地址。好的。我们将做到这一点。SOC family = a，f，i net。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_148.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_148.png)'
- en: OK。 And then we need to address。son address。address。address。 OK。 In this case。
    now we do need to do this。 So I'm wondering if we didn't need to do it before。
    No。 I don't think we did， because it always worked before。 I'll have to look at
    it。 See why this is OK。 So what we're doing now， we are doing HTML， meaning。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们需要设置地址。son 地址。地址。地址。好的。在这种情况下，我们确实需要做这个。所以我在想之前是否不需要做这个。没有，我觉得之前不需要，因为它一直都能工作。我得看看，为什么现在需要这么做。所以我们现在正在做的，是
    HTML。
- en: we are going to now convert the IP address that we are doing， into host to network
    form。 in this case。 So now， on an ADDR， any。 We could have put our own IP address，
    but we don't want to。 because we want to， just in this case， allow it to connect
    on any of the available ports。 You don't have to do that if you don't want to。
    And then address。son。port equals hto_n short port。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要将我们正在处理的 IP 地址转换成主机到网络的格式。这个情况下，所以现在，使用 ADDR，任意地址。我们本来可以使用我们自己的 IP 地址，但我们不想这么做。因为我们希望，至少在这种情况下，允许它连接到任何可用的端口。如果你不想这么做，你也可以不这么做。然后是地址。son。端口等于
    hto_n 短端口。
- en: like that。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那样。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_150.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_150.png)'
- en: And then now we need to make it so that we are connected， to that port for the
    operating system。 And we need to make it so that we're listening to that port。
    We have to do two things。 We have to do what we call bind。 We bind the socket
    to the address。 And again。 you have to downcast it。 Follows， socket， address。
    And then same thing。 If that， if bind equals 0。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后现在我们需要确保我们已经连接到操作系统的那个端口。我们还需要确保我们在监听那个端口。我们必须做两件事。我们需要做的就是所谓的 bind。我们将套接字绑定到地址。再次地，你需要进行类型转换。套接字，地址。然后同样的，如果绑定成功，bind
    等于 0。
- en: and let's do another thing called， listen。 The listen system call says， OK。
    now you've got this port， that you bound to。 Now you actually say， oh， whenever
    I get somebody。 trying to connect， forward that along to my program。 And you do
    that with a listen。 And then backlog。 Did we type backlog there？ Did we have backlog
    in there at all？ Oh。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做另一件事，叫做 listen。listen 系统调用表示，好，现在你已经绑定了这个端口。现在你实际上说，当有连接尝试时，把它转发给我的程序。你可以通过
    listen 来做到这一点。然后是 backlog。我们在这里输入了 backlog 吗？我们有 backlog 吗？哦。
- en: it's passed in。 Yeah， I'm not sure what that-- oh， I。 think that normally we
    pass it in as zero or no， or whatever。 It doesn't actually matter。 I'm not sure
    what the backlog one actually does。 Return S。 OK。 So in other words。 if you can't
    bind to the socket， or if you can bind to it， and you can listen to it。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它是传入的。是的，我不确定那是什么——哦，我想通常我们会传入零或没有，或者其他的。其实这没什么关系。我不确定 backlog 这个参数到底做什么。返回
    S。好的。换句话说，如果你不能绑定到套接字，或者你可以绑定并监听它。
- en: return that socket we now correctly set up， to be a server socket。 Otherwise。
    we close the socket because we had a problem。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 返回我们现在已经正确设置的套接字，作为服务器套接字。否则，我们关闭套接字，因为遇到了问题。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_152.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_152.png)'
- en: and we return negative line。 And that's how that works， yeah， we're not。 What
    is line 22？
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们返回负值。就这样运作，是的，我们不。第 22 行是什么？
- en: What is line 22 do？ OK， that sets up the address that we are-- it basically。
    tells the-- in this case， it tells the bind and listen。 function you can listen
    on any of my IP addresses。 That's what it means。 It is different than any of its
    ports， because your computer has an IP address through the Wi-Fi。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第 22 行是做什么的？好的，它设置了我们正在使用的地址——基本上，它告诉绑定和监听函数你可以在我所有的 IP 地址上进行监听。这就是它的意思。它与端口不同，因为你的电脑通过
    Wi-Fi 也有一个 IP 地址。
- en: Your computer also， believe it or not， has an IP address through Bluetooth。
    And it also has one if you connect an ethernet port in。 So there's different IP
    addresses， which。 are associated with the connection in this case。 As it turns
    out， I believe， I believe。 I and ADDR any actually is zero。 So you probably didn't
    need to do this at all。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电脑，信不信由你，也有一个通过蓝牙的 IP 地址。如果你连接了一个以太网端口，它也有一个 IP 地址。所以在这种情况下，不同的 IP 地址与连接相关联。事实证明，我相信，ADDR
    任意地址实际上是零。所以你可能根本不需要做这个。
- en: But that wasn't the case in the other one。 So again， I'll look that up and let
    the other miss。 And now we have set it up to start listening。 One other question。
    Yes？ [INAUDIBLE]， OK。 so let's see about your question。 Question is， what's stopping
    the client from connecting？
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 但在另一个地方情况并非如此。所以我会再查一下，解决其他的遗漏问题。现在我们已经设置好了开始监听。还有一个问题。是的？[听不清]，好的。那么我们来看看你的问题。问题是，是什么阻止客户端连接？
- en: And then reassigning things or whatever。 So remember， the client just--。 it's
    a very opaque procedure。 The client is a different computer。 that's trying to
    request something from the server。 And it just says， hey。 I want to talk to port
    1234。 And then if your server is listening to it。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新分配或者其他什么的。所以记住，客户端只是——它是一个非常不透明的过程。客户端是另一台计算机，它尝试向服务器请求某些东西。它只是说，“嘿，我想连接到端口1234”。然后，如果你的服务器在监听这个端口。
- en: it just sets up a connection that says， OK， start giving me data for it。 It
    doesn't do anything else locally on the other server， computer。 You can't reach
    over the server computer， and change any of the ports over there。 [INAUDIBLE]，
    Oh。 it can try to communicate with other ports。 [INAUDIBLE]， Well， it can try
    to-- well， OK。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 它就建立一个连接，表示，“好的，开始给我数据”。它不会在其他服务器计算机上做任何本地操作。你不能跨越服务器计算机，去更改那里的任何端口。[无法听清]，哦，它可以尝试与其他端口通信。[无法听清]，嗯，它可以尝试——好的。
- en: So let's say you send a message， a random message， to a web server on port 80。
    And you're trying to get it from-- it's only going to talk web。 Again， it's not
    going to try it。 It's not going to be able to get any other information from it。
    You can take that and then pass that information， to pass that to other programs
    and whatever。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你发送了一条消息，一条随机的消息，给一个位于80端口的Web服务器。你正在尝试从它那里获取信息——它只会处理Web请求。再一次，它不会尝试其他的，它也无法获取其他的信息。你可以把这个信息传递给其他程序，或者做其他操作。
- en: And then they can talk to the web server。 It doesn't really matter in the sense
    that it's not going to--。 what you do on your computer with that socket is irrelevant。
    If it's all you talk web HTTP。 then it'll be fine。 And maybe multiple programs
    can talk。 Sure。 But it doesn't-- maybe I'm misunderstanding your question。 [INAUDIBLE]，
    [INAUDIBLE]。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它们就能与Web服务器通信。其实这没什么大不了的，因为它不会——你在电脑上做的事情，跟那个套接字无关。如果它只是Web HTTP通信，那就没问题。也许多个程序可以同时通信，当然。但是它并不——也许我误解了你的问题。[无法听清]，[无法听清]。
- en: Can a server be given a socket that hasn't been requested directly？ [INAUDIBLE]，
    No。 I can't。 I mean， it's local to the machine。 A socket is local to a machine。
    It happens to be maybe connecting to another machine。 on a particular IP address
    on the other machine。 But that's it。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以被分配一个没有直接请求的套接字吗？[无法听清]，不。我不能。我的意思是，套接字是本地的。套接字是本地于机器的。它可能是连接到另一台机器，连接到另一台机器的特定IP地址。但就是这样。
- en: If there's no other-- you can't request a socket。 You can't request a port that's
    not listening。 first of all。 And you can't request anything that's--， stop by
    ready for class。 We'll check。 Come on back。 We're ready for class。 But anyway，
    any other questions on this？ Sorry， but not good。 Yeah。 [INAUDIBLE]， Yeah， I'm
    not exactly-- I'm not 100% sure what the backlog does。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他的——你不能请求一个没有监听的套接字。首先，你不能请求一个没有在监听的端口。而且你不能请求任何——，停下来准备上课了。我们检查一下。回来吧，我们准备好上课了。不过，其他问题呢？抱歉，情况不太好。对，[无法听清]，嗯，我不完全清楚回溯参数的作用。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_154.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_154.png)'
- en: Let's look it up。 Bind。 And bind。 Let's see。 Bind to a socket。 Let's see。 Bind
    or-- is that the-- was it bind？ Hang on。 It was-- oh， it's listening。 Sorry。 Listen。
    Listen for an action。 I'm sorry。 Backlog。 OK。 The backlog argument defines the
    maximum length。 to which the queue of pending connections may grow。 So basically，
    if a connection requests， arise。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来查一下。绑定。然后绑定。我们来看一下。绑定到一个套接字。我们来看一下。绑定或者——这是那个——是绑定吗？等等。哦，它在监听。抱歉，监听。监听一个操作。对不起，回溯。好的。回溯参数定义了队列中待处理连接的最大长度。基本上，如果有连接请求产生。
- en: the queue is full of clientry。 OK。 Yeah。 So this is saying how many different
    connections。 you're going to allow。 And I think the maximum is 128， actually。
    I don't think you're allowed to say do more。 But it's going to make it so that
    your program can take a little bit。 of time to set up a connection。 And then the
    operating system will。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 队列已满，客户端排队。好的。是的。这是说你会允许多少个不同的连接。我想最大值是128，实际上。我不认为你能指定更高的数量。但它会让你的程序稍微花点时间来建立连接。然后操作系统会。
- en: keep a backlog of the other connections， and then forward them to you one at
    a time。 Believe that's what it is。 Yeah。 [INAUDIBLE]， Yeah， good question。 OK。
    So the question is。 I'm getting confused about support， socket， and IP address。
    OK。 An IP address-- let's start with the reverse order。 An IP address is your
    computer's address。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 保持其他连接的积压，然后将它们一个接一个地转发给你。我相信就是这样。是的。[听不清]，是的，好问题。好的。问题是，我对支持、套接字和IP地址有些困惑。好的。IP地址——我们从反向顺序开始。IP地址是你电脑的地址。
- en: that the rest of the world knows about。 OK。 My IP address on this machine on
    Myth 64， rather。 is IP address。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是全世界都知道的。好的，我在这台机器上的IP地址是Myth 64，具体来说，是IP地址。
- en: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_156.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1175ce1bb2aa4c74fdf727bbf8d79962_156.png)'
- en: IF config gives you the IP address。 And it's right here。 The IP before address
    is 171641529。 The IP version 6 address is this big long one here。 And the scope--
    ooh， the scope。 There's where the scope comes in。 It's a link， for some reason。
    So that's where your IP address is。 It's the address the rest of the world talks
    on。 When somebody from the rest of the world wants to talk to you。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: IF config会给你IP地址。它就在这里。IP前地址是171641529。IPv6地址是这里的这个长长的地址。然后是范围——哦，范围。范围就是这样。它是一个链接，出于某种原因。所以，这就是你的IP地址。它是与全世界通信的地址。当外部世界的某人想要与您通信时。
- en: they can ask for a particular port of yours。 One of your programs is listening
    on it。 So maybe we want to SSH into Myth。 That's port 22。 So we go look at IP
    address。 and then we look at port 22， and that gives us an SSH connection。 If
    we look for port 80。 that gives us a web connection。 If we look for port 443，
    that's a mail connection。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以请求你某个特定的端口。你的一个程序正在监听该端口。所以也许我们想要SSH连接到Myth。那是22端口。所以我们查看IP地址，然后查看22端口，这样就能建立SSH连接。如果我们查看80端口，那就是网页连接。如果查看443端口，那就是邮件连接。
- en: or something like that。 So that's what the port is。 It's defined as on your
    computer。 what port are you listening to for various types of things。 Now， a socket
    is the file descriptor。 that is associated with a connection， either to another，
    computer or one you're listening on。 The socket itself is the file descriptor，
    that you can read and write from， and you can do both。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 或类似的东西。这就是端口的定义。它指的是你电脑上用于监听各种事情的端口。现在，套接字是与连接相关联的文件描述符，无论是连接到另一个电脑，还是你正在监听的端口。套接字本身就是文件描述符，你可以从中读取和写入，并且可以同时进行两者。
- en: as it turns out。 Does that help answer your question？ Yeah。 Good。 Yes， sir。
    So we can have multiple。 like， we can do other computers around what， are connected
    to a server like other words。 and they'd be like， it would be like， what are the
    multiple， multiple， different sockets。 And then the socket。 Ah， good question。
    So yeah， this is a very good question。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示是这样。那有帮助回答你的问题吗？是的。好的，先生。所以我们可以有多个。比如，我们可以连接到其他电脑，像其他计算机那样，它们会连接到一个服务器，然后它们会像什么一样，是什么不同的多个套接字？然后套接字呢？啊，好问题。所以是的，这是个非常好的问题。
- en: I haven't really talked about this yet。 The question is， wait， so we've got--。
    if multiple computers are trying to talk to you， on a particular port， because
    that。 means they all have different sockets， here's what really happens。 And this。
    we kind of glossed over this。 Once you've set up a connection to another computer。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没谈到这个问题。问题是，等等，假如多个计算机试图与你在特定端口上通信，因为这意味着它们都有不同的套接字，实际上发生了什么。这点我们之前略过了。一旦你与另一台计算机建立了连接。
- en: you actually do it on a completely different port。 The only thing you do on
    the original port。 is listen for connections。 Then you set up another port to
    go and connect。 to the client through another port， that you can listen on and
    do the connection on。 So once you set up on that initial port， then you actually
    hand over the connection。
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上是在完全不同的端口上操作。你在原始端口上做的唯一事情就是监听连接。然后你设置另一个端口，通过另一个端口与客户端连接，你可以在该端口上监听并建立连接。所以，一旦你在初始端口上设置好了，你就会实际交接连接。
- en: to a different port to have that connection。 So let's say you have 1。000 different
    computers connected， to you， you will then have 1，000 other ports。 that they're
    connecting on and talking back and forth， and you're still listening to port 80。
    for the next connection to come in。 That's what happens there。 Good question。
    Yeah。 [INAUDIBLE]。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到不同的端口来建立连接。假设你有1000台不同的计算机连接到你，你将会有1000个其他端口，它们在这些端口上连接并相互通信，而你仍然在监听80端口，等待下一个连接到来。这就是发生的事情。好问题。是的。[听不清]。
- en: When you want to listen to various ports， you have to do-- well， you have to
    do processes。 not really。 I mean， you can listen to multiple ports， in a particular
    process。 Just like you can have multiple files open。 [INAUDIBLE]， Oh， do threads
    share sockets？
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想监听多个端口时，你必须做——嗯，你必须做一些进程。其实也不完全是。我的意思是，你可以在一个特定的进程中监听多个端口。就像你可以打开多个文件一样。[听不清]，哦，线程会共享套接字吗？
- en: I believe they do。 Yes， I believe threads share sockets。 Now， it's not really
    going to， again。 like in your thread pool for networking， for instance， when we
    do that， we set up a new connection。 that's a different port when we do all this--，
    when we do the setup。 the connection back to the client。 It's a different port
    altogether。 OK， any other questions？
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信它们会共享。是的，我相信线程会共享套接字。现在，这其实并不会，像在你的网络线程池中，比如说，当我们做这个时，我们会建立一个新的连接。那是一个不同的端口，当我们做所有这些——当我们进行设置时。连接回客户端时。那是完全不同的端口。好的，还有其他问题吗？
- en: All right， we'll see you all Wednesday。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们周三见。
