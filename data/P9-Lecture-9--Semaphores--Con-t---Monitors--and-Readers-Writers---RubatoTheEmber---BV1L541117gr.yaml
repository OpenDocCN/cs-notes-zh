- en: P9：Lecture 9： Semaphores (Con't), Monitors, and Readers Writers - RubatoTheEmber
    - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P9：第9讲：信号量（续）、监视器和读写者 - RubatoTheEmber - BV1L541117gr
- en: All right。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_1.png)'
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_2.png)'
- en: Welcome everybody。 Today is the last synchronization lecture and we want to
    make sure we get through some good material so you're ready for the exam。 So this
    is going to be a lot of the same material in that extra lecture that I updated
    but put up there on Thursday but it's going to be。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎大家。今天是最后一堂同步讲座，我们希望确保讲解一些重要的内容，帮助你们为考试做好准备。所以，今天的内容将是上次更新的额外讲座的很多相同内容，那个讲座我已经在周四发布了，但今天会有一些不同。
- en: live and in person， so you'll like that。 So if you remember from last time we've
    been talking about synchronization。 And one of the things that we did was we introduced
    this idea of atomic instruction sequences。 And this is really what's going to
    make synchronization work well for user mode because otherwise the best we have
    is interrupt disable and enable or loads and stores and neither of those are terribly
    great solutions that we saw right so we have test and set is one of the atomic
    instruction。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 亲临现场，你会喜欢的。所以，如果你还记得上次我们讨论的是同步问题。我们做的一件事是介绍了原子指令序列的概念。实际上，这就是能使同步在用户模式下运行得很好的原因，因为如果没有这一点，最好的方法只是禁用和启用中断，或者加载和存储，而这两者都不是我们之前看到的理想方案。所以我们有了“测试与设置”（test
    and set）这种原子指令。
- en: sequences that you should become very comfortable with because that shows up
    on pretty much any architecture these days。 Some other more interesting ones are
    things like swap。 Where swap basically takes a register and a memory location
    and swap some chess and set。 Takes a memory location put the one there right。
    And then when swap takes two registers checks and sees whether the first register
    matches what's in memory and if it does then it stores the second register into
    memory。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列应该是你非常熟悉的，因为它们几乎出现在如今的任何架构上。一些更有趣的指令比如交换（swap）。交换基本上是将寄存器和内存位置交换，而“设置与测试”（test
    and set）则是将一个内存位置置为1。然后，交换指令会把两个寄存器中的值进行检查，看第一个寄存器的值是否和内存中的值相同，如果相同，就将第二个寄存器的值存入内存。
- en: Okay， and then this link load link store conditional is another more risk RIC
    style of atomic instruction sequence that that I talked about briefly but we're
    going to hold off on talking more about that later。 So， what are the options on
    these atomic sequences。 Yes。 Yeah。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，然后这个链接加载和链接存储条件指令（link load link store conditional）是另一种更具风险的RISC风格的原子指令序列，我稍微提到过，但我们会稍后再详细讨论。所以，这些原子序列有哪些选择呢？是的。对的。
- en: so there's a swap instruction and then there's the wrapping of swap。 So that
    you can use it in code or whatever so the swap the simple instruction just takes
    a register and memory and swaps them。 And when you're done there's something in
    a register in C code that's not terribly helpful because you don't have visibility
    into registers。 So oftentimes a swap macro or whatever returns the value in the
    register。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有一个交换（swap）指令，然后是对交换的封装。这样你就可以在代码中使用它，或者其他地方使用。交换这个简单的指令就是把寄存器和内存中的内容交换。当你完成时，寄存器中有一些东西，在C代码中这并不十分有用，因为你看不到寄存器的内容。所以通常交换宏或其他方式会把寄存器中的值返回。
- en: And that's why that's kind of why I show it here。 Actually。 I don't show a return
    here but the idea is if you return the value in the register then it would be。
    you know， when you do swap you get back to thing that wasn't memory。 And you can
    use it。 And I'll show you that slide you're thinking of it just a second。 Okay。
    Yeah。 So。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是我在这里展示它的原因。实际上，我并没有在这里展示返回值，但这个想法是，如果你将值返回到寄存器中，那么它就会是……你知道，当你进行交换时，你会得到一个不在内存中的东西。然后你可以使用它。稍等一下，我会给你展示你现在想到的幻灯片。好吧。是的。所以。
- en: all of these things are atomic。 Okay， so in this particular compare and swap
    is in x86 it's also in the 68。000。 But what it means to be atomic is all the things
    I said and that I show here all happen in a way that can't be interleaved or interrupted
    by any other threat。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些东西都是原子的。好吧，在这个特殊的比较与交换指令（compare and swap）中，它在x86架构中有，在68.000架构中也有。但是原子性意味着我刚才说的所有这些内容和我在这里展示的所有操作，都以一种不能被其他线程交错或中断的方式发生。
- en: So it's a single instruction。 So in the case of the compare and swap。 which
    again is on x86 to registers a memory location check the first register against
    the memory if they match you store the second register into memory。 And what term
    comes back is a successor failure so in the case of compare and swap。 If you did
    do that store you get success if you didn't do the store because the first didn't
    match then you get a failure。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它是一个单一的指令。所以在比较和交换（compare and swap）的情况下，这个指令在 x86 上通过两个寄存器和一个内存位置进行操作，检查第一个寄存器与内存中的值是否匹配，如果匹配，就将第二个寄存器的值存入内存。返回的结果是一个成功或失败的标志。所以在比较和交换的情况下，如果你进行了存储操作，就返回成功；如果没有进行存储操作，因为第一个值不匹配，那么返回失败。
- en: Okay。 Yep， each of these first three are single assembly instruction。 Yes。 Okay。
    Good。 And the reason these are helpful to us to build all sorts of complex synchronization
    is we need the ability to do both a store and a load in order to really synchronize
    and so that's kind of why we need to tie them together in some way。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。是的，这前三个都是单一的汇编指令。对。好的。很好。这些指令对我们构建各种复杂的同步非常有帮助，因为我们需要能够同时进行存储和加载，才能真正实现同步，因此我们需要以某种方式将它们结合起来。
- en: Okay。 So， and then we started building better lock so here's an example of using
    test and set。 Where the test and set stores a one in memory gets back what was
    in memory before and returns it in this case in C。 So then I can say something
    like well test and set。 Well。 so then we looked at using test and set as a native
    synchronizing operation decided that was a little too complicated so this was
    our better lock。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们开始构建更好的锁，这是使用测试和设置（test and set）的一个例子。测试和设置将一个 1 存储到内存中，然后返回存储之前的值，并在这里用
    C 语言实现。所以我可以这样说：好，测试和设置。嗯，接着我们查看了将测试和设置作为本地同步操作来使用，最后决定这有点复杂，于是我们有了更好的锁。
- en: which we spent a lot of time talking about where we actually have both a guard
    and a series of locks in memory。 And the idea here is you quickly check the guard。
    And if the guard is free。 then you go ahead and do your lock otherwise go to sleep。
    And if it was for you get it in return and so we're using the guard kind of like
    interrupt disabled and enable。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间讨论过这个，其中实际上我们在内存中既有一个保护（guard），又有一系列的锁。其思想是快速检查保护区。如果保护区是空闲的，那么就可以继续执行锁操作，否则就进入休眠。如果是空闲的，就获取锁并返回。因此我们将保护区像禁用和启用中断一样使用。
- en: And so we talked a bunch about that。 We also talked a bit about few texts。 So
    few texts is a hidden lib C or the hidden system call that helps you do synchronizing。
    Okay。 and it's the libraries that you've been using like the p thread new texts
    and so on use few texts。 And so the basic you text system call takes a memory
    location of value in an operation。 And it。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了很多关于这一点的内容。我们还稍微谈了一下 Few texts。所以 Few texts 是一个隐藏的 lib C 或者隐藏的系统调用，帮助你进行同步操作。好的，使用的库，比如
    p thread new texts 等，都使用了 Few texts。所以基本的 utext 系统调用接受一个内存位置、一个值和一个操作。然后它。
- en: it basically， depending on what the operation is either goes and wake somebody
    up。 or says that if the what's in the memory location doesn't match。 And so if
    you're not going to do that， but if you're not going to do that， you can't do
    that。 And so if you're not going to do that， you can't do that。 And so if you're
    not going to do that。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上根据操作的不同，要么唤醒某个线程，要么表示如果内存位置的值不匹配，执行操作。所以如果你不打算这样做，但如果你不打算这样做，你就不能这样做。如果你不打算这样做，你就不能这样做。如果你不打算这样做。
- en: you can't do that。 And so if you're not going to do that， you can't do that。
    And so if you're not going to do that， you can't do that。 And so if you're not
    going to do that。 you can't do that。 Yeah， you got a disabled interrupts， got
    a mess with the scheduler queue。 So going to sleep is not a user level operation。
    So you have to do something like going to the kernel to do that。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能这样做。所以如果你不打算这样做，你就不能这样做。如果你不打算这样做，你就不能这样做。如果你不打算这样做，你就不能这样做。对，你得禁用中断，得弄乱调度队列。所以进入休眠并不是用户级操作。所以你必须像进入内核那样去做。
- en: Few texts is an interface that cleanly lets you go into the kernel without having
    to do that all the time。 Okay， and in fact， there was this， which we're not going
    to talk about further。 I did talk about last time， where this was what was being
    done。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Few texts 是一种接口，它可以让你干净地进入内核，而不需要一直这么做。好的，实际上，曾经有这样一个东西，虽然我们不打算进一步讨论。我上次有提到过，这就是当时所做的事情。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_4.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_4.png)'
- en: This was what was being referenced earlier， but the key aspects of this is at
    user level。 It quickly grabs the lock if it's available and releases the lock。
    And if there's no contention。 so you're the only thread grabbing and releasing
    this particular implementation has a really nice property that you never go into
    the kernel。 So if you do a quick grab of a lock， do something， release a lock，
    and you're the only thread。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前提到的内容，但关键在于它是在用户级别。当锁可用时，它会迅速获取锁并释放锁。如果没有竞争，也就是你是唯一获取并释放这个锁的线程，那么这个实现有一个非常好的特性，就是你永远不会进入内核。所以如果你快速获取锁，做某些事情，然后释放锁，而你是唯一的线程。
- en: This implementation will never go into the kernel。 So this is a really nice
    one for users。 It also doesn't spin away。 Okay。 And so that's， that's basically
    what you get when you get the p thread kind of synchronizing operation。 Okay，
    so I don't want to get up on this one because I want to get back to talking about
    more powerful synchronizing than locks。 Okay， so， oh， go ahead question。 Nope。
    All right。 So， um， go ahead， you can ask your question。 Yeah。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现永远不会进入内核。所以这是一个对用户来说非常好的实现，也不会导致忙等待。好了。这基本上是你在使用 p 线程同步操作时得到的效果。好了，我不想在这个话题上停留太久，因为我想回到讨论比锁更强大的同步方式。好了，继续提问。没有问题。好吧。那么，继续，你可以问你的问题。是的。
- en: so what， what happens when you do atomic operations。 but you run run them from
    C is typically you make it look like a。 Make it look like a function call and
    contested is a value。 but that gets put into a register and my lock is a location
    and then when you do a swap contested was in the register gets put in memory。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么，当你执行原子操作时。通常情况下，你会让它看起来像一个函数调用，而被竞争的值会被放入一个寄存器中，而我的锁是一个位置，然后当你执行交换时，竞争中的值从寄存器中被放入内存中。
- en: So that's kind of what this， this syntax means and it compiles out to some assembly
    of instructions。 And those of you who are really looking in your code might have
    actually seen some assembly instructions embedded in C。 Okay， so the G， the GCC
    compiler， etc， has a clean way of taking something which interacts with registers
    and memory and wrapping what looks like a function call around it so that's what's
    going on here。 All right， good。 Now。 So we were looking at the Coke machine example
    so that's this bounded buffer。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是这种语法的含义，它会编译成一些指令的汇编代码。对于那些真正深入研究代码的人来说，可能会看到一些汇编指令嵌入在 C 代码中。好吧，G，GCC
    编译器等有一种清晰的方式来处理与寄存器和内存交互的内容，并将其包装成看起来像是一个函数调用的形式，这就是这里发生的事情。好了，明白了。接下来。所以我们在看可乐机的例子，这就是这个有界缓冲区。
- en: where the buffer has a finite size， and you have in consumers that are drinking
    the Coke and end producers that are producing the coffee。 And that doesn't matter
    how many so you could have M and N whatever， but there are many。 and the buffer
    is fixed size and we want to have really clean semantics so that if there's no
    space left in the buffer。 And a producer comes along and the producer tries to
    put something in the buffer goes to sleep。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，缓冲区有一个有限的大小，消费者在喝可乐，生产者在生产咖啡。无论有多少生产者和消费者，无论是 M 和 N，反正就是很多。而缓冲区是固定大小的，我们希望有一个非常干净的语义，这样如果缓冲区没有剩余空间，而一个生产者来了，尝试往缓冲区放东西时，就会进入睡眠状态。
- en: And then it'll get woken up later when there's space and the same for consumer
    if a consumer tries to grab something out of the buffer。 And if there's nothing
    in there， then the consumer will go to sleep until somebody produces。 Okay。 And
    the analogy here was with the Coke machine， which is really well。 you can only
    put so many cans in a Coke machine so when the delivery guy comes by and the Coke
    machine's full。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当有空间时，它会在稍后被唤醒，消费者也是一样，如果消费者尝试从缓冲区中获取某些东西，如果里面没有东西，那么消费者会睡眠，直到有人生产。好吧。这个类比就像可乐机一样，真的很好。你只能在可乐机里放这么多罐子，所以当送货员来时，如果可乐机已经满了。
- en: He falls asleep。 Okay， so maybe the analogy is a little bit strained but， and
    furthermore。 when you're desperate for that caffeine fix and you go to the machine
    and it's empty。 And if I fall asleep， that one seems more realistic。 The guy comes
    by puts cans in their wakes up you get your can and go on。 Okay。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它就会进入睡眠状态。好吧，也许这个类比有点勉强，但可以这样理解。当你急需一罐咖啡因的时候，你去到机器旁，它是空的。如果我进入睡眠状态，这个似乎更符合现实。然后送货员过来，放上罐子，机器醒了，你拿到你的罐子然后继续。好了。
- en: so the Coke machine here is the bounded buffer。 All right。 Okay。 And there was
    a question previously in the chat about what atomic means atomic again means uninterruptible
    sequence that can't be interrupted。 So， we don't want the producer or consumer
    to have to work in lockstep so we want this to be a synchronous in the sense that
    producers can come at any time consumers can come at any time。 And we want the
    right waiting conditions。 And I gave example like the GCC compiler with pipes。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里的可乐机就是一个有界缓冲区。好的。好的。之前在聊天中有人问到什么是原子操作，原子操作意味着不可中断的操作序列。所以，我们不希望生产者或消费者必须步调一致地工作，我们希望它们是异步的，意味着生产者和消费者可以在任何时候进行操作。我们希望有正确的等待条件。我举了一个例子，比如使用管道的GCC编译器。
- en: of which you guys are now very comfortable with is， you know。 see the C pre
    processor goes to standard out something that then is pulled in the standard in
    by the first phase。 of the C compiler， second phase decompiler assembler loader。
    That pipe is a bounded buffer。 Okay。 so that's exactly what we're talking about。
    And then the Coke machine example and then web servers and routers and all of
    them have these bounded buffers so this is a extremely useful kind of idea here。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你们现在都很熟悉的就是，C语言的预处理器将信息输出到标准输出，然后第一阶段的C编译器会将其从标准输入中提取出来，第二阶段是反汇编、汇编和加载器。这个管道就是一个有界缓冲区。好的，这正是我们在谈论的内容。然后是可乐机的例子，接着是web服务器和路由器，它们都有这些有界缓冲区，所以这是一个非常有用的概念。
- en: And now when we start thinking about what to do， we have to start by thinking
    about the data structures underneath so 61 B。 you learned all sorts of cool data
    structures。 Okay， this is the most boring of them。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们开始思考该做什么时，我们必须从下面的数据结构开始思考。所以，在61 B中，你学习了各种很酷的数据结构。好的，这是其中最无聊的。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_6.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_6.png)'
- en: One， I'm sure that you learned about this is a circular buffer of finite size。
    There's a head and a tail pointer or a right pointer and a read pointer。 And the
    idea is that when you go off one end you wrap around and depending on the relationship
    between the right and the read pointer。 there's either nothing in there or it's
    full， etc。 Okay， and that's all 61 B kind of material。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你们一定学过的其中一个是有限大小的循环缓冲区。它有一个头指针和尾指针，或者一个写指针和读指针。其想法是，当你到达一端时，你会回绕，根据写指针和读指针之间的关系，可能是空的，也可能是满的，等等。好的，这些都是61
    B的内容。
- en: But what you can see here is that in order to either insert or remove something
    from this buffer。 we actually have to look at the right index and the read index
    compared to each other。 And if two threads are doing that simultaneously for one
    of them is a right， for instance。 we're going to get screwed up。 Okay， so that's
    a synchronization problem。 Okay。 So。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以看到的是，为了从这个缓冲区中插入或移除某些东西，我们实际上需要比较正确的写入索引和读取索引。如果两个线程同时在执行这一操作，其中一个是写入操作，举个例子，我们就会出现问题。好的，这就是一个同步问题。好的。
- en: we can very easily ask ourselves questions like， what needs to be atomic here。
    So what does need to be atomic and making this work properly。 Anybody。 Yeah， incrementing
    an index。 but that can't be the whole deal。 It's not just the incrementing right
    it's also got to be the comparing of the index with the other one before we increment
    so that's got to be atomic as a sequence。 Because if you do a comparison， and
    you get ready to increment but somebody else feels something out from under you
    and then you increment now the queue is all screwed up right so there are groups
    of instructions that have to be together atomic。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地问自己这样的问题：这里需要原子性吗？那么，什么需要是原子的，并且能让这个过程正常运作？任何人？是的，增加一个索引。但这不能是全部。问题不仅仅是增加索引，还要在增加之前将当前索引与另一个索引进行比较，因此这必须作为一个序列是原子的。因为如果你进行比较，准备增加索引，但有人在你之前把东西取走了，然后你再增加索引，那么队列就会出错，对吧？所以，必须有一组指令要作为原子操作一起执行。
- en: So everybody with me on that it can't be just one thing。 And by the way。 incrementing
    is itself a problem because you got to read from memory。 add something or back
    so that clearly needs to be made atomic but also the comparisons do it well。 So
    that's the first thing to be thinking about when you're trying to synchronize。
    Okay。 And。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以大家理解了吗？它不能只是单独一个操作。顺便说一句，增加索引本身就是一个问题，因为你需要从内存中读取，增加某个值或做减法，这显然需要做成原子操作，另外，比较操作也需要做到这一点。所以，这是你在尝试同步时首先要考虑的事情。好的。
- en: you know， so here might be our first cut， because we need to do synchronizing。
    And across and between users， we might say let's put a lock。 Okay。 and so to produce
    something the producer grabs the lock on the on the queue。 and then it in queues
    an item and releases the lock。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，这可能是我们第一次的尝试，因为我们需要做同步操作。我们可能会说，让我们加个锁。好的，那么为了生产某样东西，生产者会先获取队列上的锁，然后将物品放入队列并释放锁。
- en: So from the standpoint of not screwing up the queue。 This seems pretty good。
    Okay， because if two。 two producers or producer in a consumer come along。 and
    they both want to mess with the queue only one of them gets the lock。 So we want
    to be careful about that so for instance the consumer side again we acquire and
    release the lock。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从不让队列出错的角度来看，这个方案看起来还不错。好的，因为如果有两个生产者或者一个生产者和一个消费者来操作队列，只有一个能够获取锁。所以我们需要小心这一点，例如消费者端，我们获取并释放锁。
- en: Okay， what's wrong with this code。 Yeah。 So this is really buggy code。 Okay。
    This as soon as you hit one of the conditions you're basically going to lock up
    and white let's figure that out we acquire the lock。 We check the buffer condition。
    And we say， oops the buffer is full。 Okay。 so I'm the delivery guy I got a fallen
    sleep in front of the coke machine。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这段代码有什么问题呢？对，这是非常有问题的代码。好的，一旦触发其中一个条件，你基本上就会锁死。让我们弄明白这一点，我们获取锁，检查缓冲区状态，然后说，哎呀，缓冲区满了。好的，作为送货员，我只能在可乐机前睡着。
- en: And then I'm going to wait until somebody empties the coke machine。 And then
    you have the lock。 So who can empty。 Well here's you guys right here are the students
    going after the coke。 They try to acquire the lock before they grab one but they
    acquire the lock they go to sleep。 because the lock is taken。 Okay， so the producers
    got the lock the producer is permanently spinning the consumer tries to grab the
    lock the consumer goes to sleep。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我会等待有人清空可乐机。然后你有了锁。那么谁能清空呢？好，这里就是你们，这些学生们去拿可乐。他们在拿之前尝试获取锁，但锁已经被占用了，他们只好睡觉。好的，生产者已经拿到锁，生产者一直在不停地旋转，而消费者则尝试获取锁但只能睡觉。
- en: And then you have a bunch of delivery， one or more delivery people just one
    actually standing in front of the machine and a bunch of sleeping students。 and
    no coke can pass anywhere。 Okay， so this seems like a bad solution。 And I want
    to make sure everybody's clear on why this is bad。 Okay， are there any questions
    on this。 As long as you never fill the machine or empty the machine this works
    fine。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会有一些送货员，实际上只有一个站在机器前面，而一群学生正在睡觉，任何可乐都无法传递出去。好的，这看起来是个糟糕的解决方案。我希望大家清楚为什么这是不行的。好的，这里有问题吗？只要你从不填满机器或清空机器，这个方案其实是没问题的。
- en: But that's not the point。 Right， we got it we're trying to make a bounded buffer。
    We wanted to have an infinite buffer， where I guess you could walk away with an
    empty coke。 and maybe it would be okay to remove these wild， loops but that's
    not our goal right now。 Okay。 Questions before we move on。 So the root of the
    problem here is we're actually combining multiple things。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题不在这里。对，我们明白了，我们正在尝试创建一个有界缓冲区。我们想要一个无限缓冲区，在那个情况下，我猜你可以走开拿到一瓶空的可乐。而也许去掉这些死循环是可以的，但这不是我们当前的目标。好的，继续之前有问题吗？问题的根源在于我们实际上在合并多个操作。
- en: kind of in a single lock， which is really what's causing us trouble here。 We're
    combining atomic operations on the queue in a way that the queue doesn't get screwed
    up if more than one producer or consumer is there。 At the same time we're trying
    to check resource conditions on whether the queue is fully full or empty。 And
    those two are being combined together in a single lock and that's really what's
    going to cause us the trouble。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是一个单一的锁，这实际上是我们遇到麻烦的根本原因。我们正在以一种方式组合队列上的原子操作，确保队列在有多个生产者或消费者的情况下不会出错。同时，我们还在检查队列是否已满或为空。这两者都被组合在一个锁中，这正是会给我们带来麻烦的原因。
- en: Okay， and we can not gracefully we could do this。 All right， so this is not
    graceful code。 It's okay code so it won't lock up but notice the thing I did that's
    different。 It's right here in the while loop I say well while the buffers fall。
    Release the lock acquired again， etc over and over again and I spin release release
    acquire release acquire release acquire over and over again。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们不能优雅地做这个。我们可以这么做。好的，这不是优雅的代码。它是可以工作的代码，因此不会死锁，但请注意我所做的不同之处。就在这里，在while循环中，我说，只要缓冲区已满，就释放锁，再次获取锁，等等，一直重复，释放、获取、释放、获取、释放、获取，一直循环。
- en: And why does that prevent me from locking up。 You guys think that through in
    your brain yeah。 If you release you don't go to sleep。 But imagine that situation。
    So the the coke man shows up。 The buffer is full。 Meanwhile a student comes by
    and they try to acquire the lock but the lock is taken so they go to sleep so
    the consumer is sitting here sleeping。 And the producer has the lock but we release
    it。 Okay。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样可以防止死锁？你们自己想一想。是的，如果你释放了锁，你不会进入休眠。但想象一下这个情境。可乐商人出现了，缓冲区已满。与此同时，另一个学生来了，他们尝试获取锁，但是锁被占用了，所以他们进入了休眠状态，消费者就坐在那里睡觉。而生产者持有锁，但我们释放了它。好的。
- en: and when we release it it's not that we go to sleep。 It's that the other student
    the student there gets woken up。 So now we have two things。 Two threads that are
    both on the ready queue and can run。 And that means that we let you know we can
    let the student grab a coke。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们释放锁时，并不是我们进入了休眠，而是另外一个线程（学生）被唤醒。所以现在有两个线程，两个都在就绪队列中，并且都可以运行。这意味着我们可以让学生去拿可乐。
- en: And then the and then the producer will acquire the lock again find that the
    buffer is not full and be able to do an item。 But this is this is not great for
    many reasons。 The first one is it's busy waiting。 Okay。 so this busy wait is problematic。
    We've talked about that before but if you look at any either the producer or the
    consumer they're busy spinning over and over again。 Okay release the choir release
    the choir release the choir。 And so that's wasting instruction time。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生产者会重新获取锁，发现缓冲区没有满，并能够执行一个项目。但是，这种方式有很多问题。第一个问题是它是繁忙等待。好吧，这种繁忙等待是有问题的。我们之前谈过这个问题，但如果你看看生产者或消费者，它们一直在不停地忙碌地旋转。好吧，释放锁，获取锁，释放锁，获取锁，一直重复。所以这浪费了指令时间。
- en: And the second thing is there's really no guarantee that if you release this
    lock and have both a consumer and a producer ready to run that you don't grab
    the lock again right away。 Okay， and then the consumer gets to run and check if
    something's empty whatever and then they go back to sleep immediately so there
    isn't any ordering on this either。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，如果你释放了这个锁，并且生产者和消费者都准备好运行，实际上没有保证你不会立刻再次获取锁。好的，然后消费者就能运行，检查是否有空的项，然后立刻重新进入休眠状态，所以在这个过程中也没有任何顺序。
- en: So this is just， you know， they'll run and eventually it'll make progress but
    it's not a great solution。 Okay。 Yeah。 Okay。 So， it can。 So the question was so
    when we have led everybody on the ready queue。 Can it the ordering is there a
    live lock situation where they still don't make progress potentially。 Okay。 Now，
    there is a question in the chat saying， well。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是，你知道的，它们会运行，最终会取得进展，但这不是一个好的解决方案。好的。是的。好的。那么，问题是，当我们把所有人都放到就绪队列时。是否可能存在一个死锁的情况，它们仍然无法取得进展？好的。现在，聊天中有个问题说，嗯。
- en: so this is not as bad of a busy wait as we have in the prior solution well the
    prior solution was just straight up locked up。 Anyway， that's just broken。 This
    one is not great。 Probably will make progress。 Okay。 but this is still not this
    is not good code right if you wrote this in anything other than PowerPoint slides
    for this class we might question it more than once。 Okay， so let's do something
    else。 And that is the pick the right abstraction。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这比我们之前的解决方案中的繁忙等待要好一些，之前的解决方案完全是死锁。无论如何，那就是坏掉了。这个方案不好，可能会有进展。好的，但这仍然不是好代码，如果你在这门课之外的地方写了这个，我们可能会多次质疑它。好吧，接下来我们做点别的事情，也就是选对抽象。
- en: So the real problem here is that we're restricting ourselves to using locks。
    which are really very primitive。 I mean they're， they're better than not having
    locks。 but we would like a higher level primitive that lets us express the。 parallelism
    we're expecting in a way that's more natural。 Okay， and that's going to be our
    goal。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的真正问题是，我们限制自己只使用锁，锁其实是非常原始的。我是说，它们比没有锁要好，但我们希望有一个更高级的原语，它能以一种更自然的方式来表达我们期望的并行性。好的，这将是我们的目标。
- en: And so good primitives and practices are very important。 So， the execution。
    I hope by now this point in the class you realize it's not really sequential all
    the time because we have threads around here and then they run here and they run
    here and they run here there's currency they're in early。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，好的原语和实践非常重要。那么，执行方面。我希望到现在你已经意识到，程序并不是一直顺序执行的，因为我们有线程，它们在这里运行，然后在这里运行，接着在这里运行，它们之间是有并发的。
- en: et cetera。 And so it's really hard to find bugs when you have non determinism
    going on。 And so really。 The thing that we want by picking the right synchronization
    primitive is we want to make sure that we're likely to write code that's correct。
    Okay， and we do that by picking a good synchronization primitive。 Right。 and so
    locks are going to be in the back of your pocket now。 But let's see if we can
    do better。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。所以，当你面临非确定性时，真的很难找到错误。因此，实际上，我们通过选择正确的同步原语来做的是：确保我们写出的代码是正确的。好的，我们通过选择一个好的同步原语来做到这一点。对了，锁现在已经在你口袋里了。但让我们看看是否能做得更好。
- en: And I pointed out before that you in Unix is pretty stable now but boy in the
    80s。 And there were all sorts of weird synchronization bugs that people didn't
    really understand。 So synchronization is a way of coordinating multiple activities
    using shared state。 Okay。 so let's talk about semaphores now semaphores are a
    step up from locks。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，Unix现在已经相当稳定了，但在80年代的时候，可就不一样了。当时有各种各样奇怪的同步错误，大家并不完全理解这些问题。所以同步是一种使用共享状态来协调多个活动的方法。好的，接下来我们来讨论信号量，信号量比锁更进一步。
- en: And they're kind of like a generalized lock and they were first defined by dyke
    string in the 60s so they've been around a long time。 And then the main synchronization
    primitive and a lot of versions of Unix。 Okay。 and so what is a semaphore so a
    semaphore is a non negative integer with two operations down or P and upper V。
    Okay， and the P operation is an atomic operation that takes weights for the semaphore
    to become positive and decrements it by one。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有点像一种通用的锁，并且最早是由Dyke String在60年代定义的，因此它们已经存在很长时间了。然后，在很多版本的Unix中，它们是主要的同步原语。好的。那么，什么是信号量呢？信号量是一个非负整数，有两个操作：down或P和up或V。好的，P操作是一个原子操作，它会等待信号量变为正数，并将其减少1。
- en: And the V operation increments by one and if there's somebody sleeping at that
    time。 they'll wake them up。 Okay， and so let's think about this a second。 It's
    a non negative integer。 You get it at the beginning and once you've said it， that's
    it。 It's initialized you can never read it again so the interface doesn't even
    allow you to look at the value。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: V操作会将信号量递增1，如果此时有线程在休眠，它们将被唤醒。好的，那么让我们再思考一下。它是一个非负整数，你一开始得到它，一旦你设置了它，它就完成了初始化，你再也无法读取它了，所以接口甚至不允许你查看它的值。
- en: but you only have P and V。 Okay， and so， P says， decrement。 unless it's going
    to zero or lower and then put me to sleep。 And then it says increment and if you're
    going kind of from zero to one and somebody's sleep and you wake them up。 Okay，
    so it's it's a， it's an interesting type of integer。 Okay， now I showed you this。
    So。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你只有P和V。好的，所以，P表示递减，除非它已经为零或更低，否则就让它休眠。然后它会递增，如果你从零变成一，而有线程在休眠，那么你会把它们唤醒。好的，所以它是一个有趣的整数类型。好了，我给你们展示过这个。
- en: I'm not going to do fun with animation。 So semaphores are like integers except
    no negative values。 The only operations allowed our P and V。 And by the way， you
    know， P and V were the original。 So names came from Dutch down and up or sem semi
    down and semi up。 These are all options here for the name for this， you'll have
    to have a little flexibility。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会玩动画的。信号量就像整数，只是没有负值。唯一允许的操作是P和V。顺便说一句，你知道吗，P和V是最初的名字，来自荷兰语的down和up，或是semi
    down和semi up。对于这个名字你可以有一些灵活性。
- en: but we'll make sure that you know， which one to use。 So， if it matters。 but
    let's talk about P and V for now we're going to be traditional。 but the only operations
    are P and V。 So you can't read or write the value and the operations have to be
    atomic。 So why is that important that says that if， if the semaphore is zero and
    somebody's trying to execute a P on it。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们会确保你知道该使用哪个。所以，如果它很重要，我们稍后会讨论P和V操作。我们将采用传统的方法，但唯一的操作是P和V。所以你不能读取或写入值，这些操作必须是原子性的。那么为什么这很重要呢？这表示，如果信号量为零，并且某个线程正在尝试执行P操作，
- en: it will notice that it's zero and put themselves to sleep simultaneously。 So。
    if you're going to make operation V is also atomic。 If you're going to go from
    zero to one。 You look at the very time you go from zero to one you look and you
    see is there somebody wake up you wake them up atomically。 So it's important that
    those kind of two things are bound together atomically otherwise we don't get
    synchronization behavior once again if there's any interleaving we're going to
    be in trouble。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它会注意到值为零并自己进入睡眠状态。因此，如果你要执行操作V，它也是原子性的。如果你要从零变成一，你需要在变为一的那一瞬间检查，看看有没有线程需要被唤醒，并且要原子地唤醒它们。所以，确保这两件事原子地绑定在一起是非常重要的，否则我们就得不到同步行为。如果有任何交错执行的情况，我们就会遇到麻烦。
- en: Because we don't want a spread that executes a P and starts going to sleep。
    And another thread executes V to somehow end up with a situation where you've
    decremented the semaphore to zero and V is incremented it to one but somehow this
    original thread is sleeping。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望某个线程执行P操作后开始睡觉，另一个线程执行V操作，结果让信号量从零递增到1，而原本在睡眠中的线程未被唤醒。
- en: Okay， that would be a failure with atomicity so we never want to have that happen。
    Okay。 and so POSIX adds the ability by the way to read the value but technically
    not legal。 And the semaphore comes from a railway analogy which I showed you so
    here's a semaphore lighting system。 We initialize the value to two。 And now when
    trains come by they're going to try to execute the P operation on that value。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这会是一个具有原子性的失败，因此我们永远不希望发生这种情况。好的。所以，POSIX通过增加一种读取值的能力，虽然技术上不合法。信号量来自铁路的类比，我之前展示过，这里是一个信号灯系统。我们将初始值设置为2。现在当火车经过时，它们将尝试对该值执行P操作。
- en: It doesn't go below zero they'll be okay。 Okay， so here notice the train came
    through it executed the P or the down operation value went to one the train got
    through。 Second one value went to zero the train got through。 So now what happens
    when the third train comes by。 It's going to go to sleep because it's going to
    execute a P operation and it's going to notice well I can't do that because it
    would take value below zero。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会降到零以下，这样就没问题了。好的，所以在这里，注意到火车经过，它执行了P操作，或者说下行操作，值降到1，火车通过。第二辆火车，值降到0，火车通过。那么第三辆火车经过时会发生什么？它将进入睡眠状态，因为它将执行P操作，注意到它不能执行，因为这会使值低于零。
- en: And therefore I'm going to sleep so this train is sleeping。 These trains are
    I don't know that thinking or whatever。 And now when the train leaves will increment
    will execute a V operation。 And so。 atomically this train is going to exit execute
    a V operation which will increment the value to one and wake up this thread to
    redo its P operation and notice。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将进入睡眠状态，所以这列火车正在睡觉。这些火车在那边不管是思考还是做其他什么。现在，当火车离开时，它将执行一个V操作，值将增加到1，并唤醒这个线程重新执行它的P操作，注意。
- en: Did you see how value went to one and then back down to zero again。 And so that's
    that's the basic notion of this atomicity。 Okay， question。 Yeah， go ahead。 Oh，
    yeah。 go ahead。 I'm on the aisle。 Sure。 So， good question。 So I set my initial
    value to two。 Does that mean that only two will ever be able to be in there。 Okay。
    No。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到值从1再回到0了吗？所以这就是原子性的基本概念。好的，有问题吗？是的，继续。哦，好的，继续。我在过道这边。好的，问题很好。假设我将初始值设置为2，这意味着只有两个线程能进入吗？好的，不是。
- en: What it means is that if I execute a bunch of V operations。 I could get the
    value way up and then a bunch of P operations could come through。 So really that
    initial value has more to do with how you're intending to use this。 So if I said
    V to one。 What do I have。 A lock。 Because if I said it to one。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我执行了一系列V操作，我可以将值增加很多，然后一堆P操作可能会接踵而来。所以，实际上初始值更与你打算如何使用这个信号量有关。如果我把V设置为1，那么我得到的是什么？一个锁。因为如果我把它设置为1，
- en: the first P operation that happens takes it to zero。 The second one puts it
    to sleep or the third or the fourth or the fifth one all go to sleep。 As soon
    as the person who's got the lock increments it with a V。 One of those sleeping
    ones will wake up and execute their P operation and keep going。 Yes。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个P操作将其设置为0。第二个操作使其进入休眠，第三个、第四个或第五个操作都将进入休眠。当持有锁的线程通过V操作将信号量递增时，其中一个正在休眠的线程会醒来并执行P操作，继续进行。是的。
- en: How does it choose which one to wake up。 Well， that's one of the big mysteries
    of the universe。 Undefined。 Okay， so unless your semaphore says will wake people
    up in FIFO order。 It won't wake them up in FIFO order。 Okay， in fact there's guaranteed
    it'll do whatever will break your algorithm。 Right。 That's the。 That's Cooby's
    bad scheduler， malicious scheduler rule number。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何选择唤醒哪个线程？嗯，这是宇宙中的一个大谜题。未定义。好的，除非你的信号量指定将按FIFO顺序唤醒线程，否则它不会按FIFO顺序唤醒。好的，事实上，它会保证做任何可能破坏你算法的事情。对，这是Cooby的坏调度器，恶意调度器规则编号。
- en: whatever number I gave to it in a previous lecture。 Okay。 Now there's another
    question。 Go ahead。 Oh， okay。 So if I said it to one， I basically get a lock。
    If I set it to zero， what do I get？ Yeah。 Yeah， you get a wait for somebody else。
    Very good。 So， if I said it to zero。 the first thing comes along。 If I set it
    to zero， I get a something I can wake up somebody else with。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我在之前的讲座中给它设置了什么数字。好的。现在有另一个问题。继续。哦，好的。如果我将它设置为1，我基本上得到一个锁。如果我将它设置为0，我会得到什么？是的。是的，你会得到一个等待其他人的信号。非常好。所以，如果我将它设置为0，第一个到达的人将会得到一个可以唤醒其他人的信号。
- en: What if I set it to two？ Well， you can see that we can start getting constraints
    on numbers of things。 Okay。 And I hope you're all thinking ahead。 Well， obviously
    this is got something to do with the Coke machine。 Right。 You can imagine that
    we have constraints on sort of number of cans of Coke and number of empty slots。
    Okay。 So， if we re to this now。 Again， we have a couple of uses the semaphoreth
    one's mutual exclusion。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将它设置为二呢？好吧，你可以看到，我们可以开始对事物的数量施加约束。好的。我希望你们都在提前思考。显然，这和可口可乐自动售货机有关系，对吧？你可以想象我们对可口可乐罐的数量和空槽的数量有约束。好的。那么，如果我们现在回到这个问题。我们再次使用信号量中的互斥性。
- en: That's often called a binary semaphore or a mutex。 Okay。 and that gives us something
    like a lock because we pair up a semi P with a semiv or scheduling constraint。
    Okay， here we allow one thread to wait for a signal from thread to that would
    be setting it to zero。 Here's a way of doing thread join right so if you ask the
    join。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被称为二进制信号量或互斥量。好的。这为我们提供了类似锁的东西，因为我们将一个信号量P操作和一个信号量V操作配对作为调度约束。好的，在这里我们允许一个线程等待来自线程2的信号，那就是将其设置为0。这是执行线程连接的一种方式，所以如果你请求连接。
- en: you execute a semaphore on a semaphore started to zero and the thread you're
    waiting to finish executes the V and now you both get to go forward。 Now， let's
    revisit the bounded bounded buffer so I could practice constraints are threefold。
    So one the consumer has to wait so that there's a full buffer one buffer， right
    entry。 And so if the if the buffer is completely empty the consumer needs to sleep。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你在一个初始化为0的信号量上执行操作，而你等待的线程执行V操作，现在你们两个都可以继续前进。现在，让我们回顾一下有界缓冲区，因此我们可以实践约束条件，约束是三重的。首先，消费者必须等待，直到缓冲区满，缓冲区只有一个对吧，进入。然后，如果缓冲区完全为空，消费者需要休眠。
- en: The producer has to wait for there to be some empty slots。 So if the if the
    bounded buffer is completely full， the producer has to go to sleep。 And the thing
    that we started all this mess with， we still need to do atomicity on the queue
    operation。 So we want to make sure that multiple threads don't mess with the queue
    at the same time and screw it up。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者必须等待，直到有空槽。如果有界缓冲区完全满了，生产者必须休眠。而我们最初引入这一切的原因，我们仍然需要对队列操作进行原子性处理。所以我们要确保多个线程不会同时操作队列并破坏它。
- en: So this actually leads us to wanting three semaphores to do a proper bounded
    buffer。 Okay。 one for the full condition one for the empty condition and one to
    serve as a lock essentially to make sure that the queue itself is not screwed
    up。 Okay。 And so why do we need the mutual exclusion， because computers basically
    are stupid and don't figure things out。 And of course in real life the delivery
    person probably figures it out when there's a student sleeping in front of the
    machine probably figures out that they probably want to buy a coat or something
    right。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这实际上让我们想到了需要三个信号量来实现一个正确的有界缓冲区。好的，一个用于满槽条件，一个用于空槽条件，另一个则充当锁，以确保队列本身不会出问题。好的。那么为什么我们需要互斥呢？因为计算机基本上很愚蠢，不能自己解决问题。当然，在现实生活中，送货员可能会在机器前看到有学生睡着，然后意识到他们可能想买一件外套之类的。
- en: So the general rule of thumb for semaphores is use a separate semaphore for
    each constraint。 And here we have a full buffer empty buffer and mutex constraint，
    we have three buffers here。 And so the full solution of the bounded buffer looks
    like this semaphore full slots。 We started zero， said there's no coke empty slots
    we said at the buffer size and mutex we said it won so this mutex is going to
    be a lock for us。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于信号量的一般规则是，每个约束条件使用一个独立的信号量。在这里我们有满缓冲区、空缓冲区和互斥锁约束，我们有三个缓冲区。因此，有界缓冲区的完整解决方案是这样的：信号量满槽，我们初始化为零，表示没有可乐；空槽我们设置为缓冲区大小，互斥锁设置为1，所以这个互斥锁将充当我们的锁。
- en: The other two are going to be constraints on the consumers and the producers。
    Okay。 Now。 here's what our producer looks like。 It does a semaphore on the empty
    slot so it basically says。 If there are zero empty slots， then we need to put
    the producer to sleep。 And notice that they do that before they grab the mutex
    on the queue。 Okay， so we check first。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个将作为消费者和生产者的约束条件。好的，现在，让我们看看我们的生产者是什么样的。它在空槽上使用了一个信号量，基本上就是在说，如果空槽数为零，那么我们需要让生产者休眠。注意他们在获取队列的互斥锁之前就做了这个检查。好的，所以我们首先检查。
- en: Is there some place for the coke。 Or we actually enter any operations on the
    queue。 that makes sense everybody。 And then， assuming that this works so we don't
    go to sleep here or we get woken up one of the two。 We then grab the mutex and
    cue our coke release the mutex。 And then at the as a parting shot。 We increment
    the number of full slots because we put a Coke can in there。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么可乐放在哪里呢？或者我们实际上在队列上进行任何操作吗？大家明白了吗？然后，假设这有效，那么我们不会在这里休眠，或者我们会被唤醒，二者其一。然后我们获取互斥锁并把可乐放入，释放互斥锁。然后，作为结束操作，我们增加满槽的数量，因为我们放入了一罐可乐。
- en: And the consumer is kind of like a mirror image of this right so the consumer
    first checks and set it sees if full slots is empty。 If there's if this is zero
    then there's no coke in the machine。 But if it's not zero I get through。 I grab
    the mutex I do my DQ。 I add the mutex or add back to unlock the mutex and then
    I as a parting shot。 Sort of tell the producer we might need more。 By incrementing
    the number of empty slots。 Okay。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者实际上就像这个的镜像对吧？所以消费者首先检查并设置，看看满槽是否为空。如果满槽数为零，那么机器里没有可乐。但如果不为零，我就能进入。我获取互斥锁，进行出队操作，释放互斥锁，然后作为结束操作，通过增加空槽数量来告诉生产者可能需要更多。好的。
- en: and so really。 The mutex is giving this these red critical sections on the queue
    to make sure that。 Multiple threads don't screw up the queue。 Okay， the other
    things。 The full slot here semaphore is signaling the consumer that there's a
    new coke in the coke machine。 And the empty slot is signaling the producer that
    there's a place for coke。 Question yes。 Okay。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，实际上，互斥锁给了这些红色的关键部分，以确保多个线程不会搞乱队列。好的，其他部分，满槽的信号量是在通知消费者机器里有新的可乐，空槽则是在通知生产者有空位可以放可乐。问题？是的。
- en: Good question so the question here says what if there are two producers one
    gets through fills up the whole machine。 So if you look at this。 That's not the
    way this code is written this code is the producer has to go through this for
    each item they're at it。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题，那么问题是，如果有两个生产者，其中一个填满了整个机器会怎样？如果你看这个，这不是代码的写法，这段代码是生产者需要对每个项进行处理。
- en: So what happens with two producers is they each have a coke they're trying to
    put in the machine。 And the only way both of them would get past this semaphore
    is if that semaphore was at least two。 they both decremented it to zero。 They've
    sort of grabbed a slot each。 And now it doesn't matter what order they get the
    lock one of them gets the lock first as their coach in the machine the other one
    gets the lock next。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么两位生产者会发生什么呢？他们每个人都有一瓶可乐，试图把它放入机器中。只有当那个信号量至少为2时，他们两个才有可能都通过这个信号量。两个人都将其减到零，他们每个人都抓住了一个插槽。现在不管他们获取锁的顺序如何，一个先获得锁，把可乐放进机器，另一个接着获得锁。
- en: As their coke the machine and on exit they both kind of increment the number
    of full slots by one。 And because these are atomic operation。 Those increments。
    Don't get screwed up。 There's no interleaving。 So the one of them does the V first
    and then the other one or vice versa doesn't matter。 But when we're done the full
    slots have gone up by two。 And furthermore。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像他们的可乐机器一样，退出时，他们都会把满的插槽数增加一。因为这些是原子操作，所以这些增量操作不会出错。没有交错操作。所以无论是其中一个先执行V操作，另一个后执行，还是反过来都没关系。但当我们完成时，满的插槽数已经增加了两个。而且，除此之外。
- en: if there are two students that happen to be sleeping。 they both get woken up
    because the first V goes from zero to one wakes up the student。 The next V wakes
    up the next student。 Okay。 Yes。 So because we have a double sided constraint can't
    go below zero and we can't go above the max we need to semaphores because semaphores
    are one sided things。 Right， they only go from zero up。 And so really one semaphore
    is going counting the number of coke cans from zero up but the other ones counting
    the number of full slots from zero or empty slots from zero down up whatever to
    the full amount。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个学生正好在睡觉，他们都会被唤醒，因为第一次V操作将信号量从零变为一，唤醒第一个学生。接下来的V操作唤醒第二个学生。好的，是的。所以因为我们有双向的约束，不能低于零，也不能高于最大值，我们需要信号量，因为信号量是单向的。对吧，它们只能从零开始往上计数。所以实际上一个信号量在计数可乐罐的数量，从零开始往上计数，而另一个信号量则计数满的插槽数，从零或者空插槽数从零到最大值。
- en: So we need to semaphores there for constraints。 Okay。 How many people think
    this is kind of a cool solution。 Okay。 Good。 We won't judge your coolness or lack
    of coolness。 How many people think this might be a little complicated。 Okay， it's
    maybe it's not terribly complicated because I've just described it to you but
    imagine that this code's been around for。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要信号量来做约束。好吧，多少人认为这是个很酷的解决方案？好的，没关系，我们不会评价你的酷或不酷。多少人觉得这可能有点复杂？好的，可能它并不算非常复杂，因为我刚才已经给你描述过了，但想象一下，这段代码已经存在了。
- en: you know， five years and you go look at it now you got to figure out what's
    going on with the semaphore constraints right。 So it's powerful， which is， it's
    a uniform。 Excuse me。 a unified solution to all sorts of synchronization that's
    why semaphores are popular in Unix。 Because you can use them for locks you can
    use them for constraints。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，五年后，你现在回头看，得弄明白信号量约束的问题。它很强大，统一的。抱歉，统一的解决方案可以用于各种同步，这就是信号量在Unix中受欢迎的原因。因为你可以用它们来做锁，也可以用它们来做约束。
- en: I don't think you can use them to solve the whole thing problem but， you know，
    pretty much， you can。 you do all sorts of synchronization with them so they're
    very powerful。 And so somebody who wanted to implement one synchronization primitive
    probably would implement semaphores。 at least in the original way of thinking，
    because you can do lots of stuff with them。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认为你可以用它们来解决整个问题，但你知道，基本上，你可以。你可以用它们进行各种同步，所以它们非常强大。因此，想要实现一个同步原语的人可能会实现信号量。至少在最初的思维方式下，因为你可以用它们做很多事情。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_8.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_8.png)'
- en: But let's look at this for a second。 So why is there an asymmetry here well
    the producer does some of P on the empty buffer and some of the on full bus buffer
    and the consumer does the opposite。 And really that's because producers produce
    and consumers consume and we're doing the opposite to the two things okay so maybe
    that isn't too surprising。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们来看一下这一点。那么为什么这里会有不对称性呢？因为生产者对空缓冲区执行了一些P操作，对满缓冲区执行了相应的操作，而消费者则做相反的。其实这就是因为生产者生产，消费者消费，我们正在做这两者的相反操作，所以也许这并不让人太惊讶。
- en: What's kind of interesting is does the order of the P's matter here so what
    if we swap like this on the producer。 What happens。 Yes。 It's bad。 Okay， we don't
    do that。 Doctor it hurts when I swap my semaphore P operation don't do that。 Okay。
    because this will this will lock it for exactly the same reason before we got
    into semaphores right because you lock the。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有意思的是，P 操作的顺序在这里重要吗？如果我们像这样交换生产者的操作，会发生什么呢？是的，很糟糕。好的，我们不要这样做。医生，啊，我交换了信号量的 P
    操作，别那样做。因为这样做会导致与我们进入信号量之前一样的锁定问题，正因为你锁住了它。
- en: you lock the queue。 And then you check the condition and go to sleep and now
    you got the lock on the queue and nobody can alter the queue so this is just bad。
    What if I swap the V operations what happens。 Yeah， it's it'll work。 It might
    alter the scheduling efficiency because it might wake up one thread over the other
    and so on but really it's not going to deadlock anything。 Okay， because all we're
    doing is incrementing。 And that's a。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你锁住队列。然后你检查条件，进入睡眠状态，现在你已经获得了队列的锁，没人能更改队列，所以这种方式就是不好的。如果我交换 V 操作，会发生什么呢？是的，它仍然能工作。它可能会改变调度效率，因为它可能会唤醒一个线程而不是另一个，但实际上并不会导致死锁。好的，因为我们所做的只是递增操作。
- en: you know you can swap increments without too much trouble。 So。 what if we have
    two producers and two consumers or five producers and a hundred consumers。 Does
    this code work。 Yes。 Okay， this code works perfectly well with many producers
    and many consumers。 Okay。 So， semaphores are good， but monitors which we're next
    going to talk about are even better。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，交换递增操作并不会带来太多麻烦。那么，如果我们有两个生产者和两个消费者，或者五个生产者和一百个消费者，代码是否能正常工作呢？是的，好的，这段代码在有多个生产者和多个消费者的情况下能够正常工作。好的，信号量很好，但接下来我们要讲的监视器更好。
- en: The semaphores are a huge step up。 Just think of trying to do the bounded buffer
    with only loads and stores。 Remember our got milk lecture。 A couple of a couple
    of lectures ago。 Imagine trying to do the bounded buffer with the got milk solution
    number three。 Okay。 that would have been just right out that's evil might have
    been something that we'd give you on a test。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是一个巨大的进步。试想一下，仅仅通过加载和存储来实现有界缓冲区。记得我们之前的《牛奶讲座》吗？几节课前的事情。想象一下，尝试用《牛奶讲座》中的解决方案三来实现有界缓冲区。好的，这将完全无法工作，这样做简直是邪恶的，可能是我们在考试中给出的一个题目。
- en: No， I'm just kidding。 We wouldn't do that to you。 So the problem here is really
    that semaphores are dual purpose。 They're actually both being used for mutex or
    mutex or locking and scheduling constraints and it depends on what you initialize
    them to and how you use them as to what happens。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我在开玩笑。我们不会那样对待你。所以这里的问题实际上是信号量具有双重用途。它们实际上既用于互斥锁（mutex）或锁定，也用于调度约束，具体取决于你初始化它们的方式以及你如何使用它们，结果也就不同。
- en: So it's great right now because you're sitting there you look at the code I've
    been explaining it to you。 But again， if you looked at your code five years from
    now， you'd have to re extract what's going on。 Right。 And it's sort of from a
    long term readability solution is probably not great。 Okay。 So much cleaner idea
    is let's go back to locks for mutual exclusion because that's what locks do。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很好，因为你坐在那里看着代码，我一直在给你解释。但是，再一次，如果你五年后再看你的代码，你就得重新提取出它的含义。对吧？从长期可读性的角度来看，这种方式可能不是很好。好吧。所以一个更干净的想法是回到用于互斥的锁，因为那是锁的作用。
- en: And let's pick something else for scheduling constraints and that's called a
    condition variable。 And the thing is that a monitor is a programming paradigm
    which has one lock and zero or more usually one or more condition variables。 Okay，
    and that's going to be what we're going to program with and some languages like
    Java actually provide this natively。 Most others use locks and condition variables
    kind of together。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择其他东西来进行调度约束，那就是条件变量。关键是，监视器是一种编程范式，它有一个锁和零个或多个（通常是一个或多个）条件变量。好的，这就是我们要用来编程的东西，一些语言，如
    Java，实际上原生支持这个功能。大多数其他语言则是将锁和条件变量一起使用。
- en: And they actually give you the idea of a monitor but they're all kind of programmed
    in the same idea。 And if we get there toward the end of the lecture I'll actually
    show you how monitors kind of show up in some languages will give you some code
    examples。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它们实际上给你提供了监视器的概念，但它们都基于相同的编程思路。如果我们在讲座的最后提到这个问题，我实际上会给你们展示监视器在某些语言中的实现，并给你一些代码示例。
- en: Okay。 But what I want to do first is let's talk a little bit of Benestryvia。
    So。 hopefully not a big surprise。 And then we'll be on Thursday that's two days
    from now。 We will be announcing kind of what rooms to go through because there's
    two because there's three rooms。 And we have to make sure that all is well on
    that front。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。但我首先想做的是，我们先谈谈一些背景知识。希望这不会让你们感到太惊讶。然后我们将在星期四，也就是两天后，宣布应该进入哪个房间，因为有两个房间，三个房间的选择。我们需要确保一切顺利进行。
- en: And there's two rooms and a bunch of others。 Okay。 If you're sick， let us know。
    Don't come to the test to the test if you have a positive COVID test。 Okay， just
    just say no。 Okay。 talk to us。 I'm not going to be in the office for office hours
    today but I will be there during class time on Thursday for office hours as well
    as tomorrow's normal office hours at one。 Okay， so， come by。 I also， except for
    this morning。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有两个房间和其他几个房间。好的。如果你生病了，告诉我们。不要带病参加考试。如果你有COVID阳性检测结果，好的，请不要硬来。好的，和我们说一声。我今天不会在办公室办公，但星期四上课时间我会在办公室进行办公，明天正常的办公时间是1点。好的，过来找我。除了今天早上以外，我都会在。
- en: Have been trying to answer lecture questions on Piazza as well。 So。 there's
    another venue there for asking questions。 Okay。 So。 let's ask ourselves what is
    a condition variable。 Okay， and。 So， how do we change， for instance。 the consumer
    routine to wait until something's on the queue。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我也一直在尽力回答Piazza上的讲座问题。所以，那里还有一个提问的渠道。好的，那么，让我们问自己一个问题，什么是条件变量？好的，那么，我们怎么改变，例如，消费者例程，直到队列中有东西为止。
- en: And we've already shown you how to do this by keeping counter the number of
    things with a semaphore but this is really pretty error prone。 So instead we're
    going to use this idea of a condition variable。 which at first blush is a little
    weird。 Okay， and let me tell you why it's weird。 That's weird is you grab a lock，
    you check a condition and the condition is not right。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向你展示了如何通过使用信号量来保持事物计数，但这其实很容易出错。所以我们将改用条件变量的概念，这最初看起来有点奇怪。好的，让我告诉你为什么它看起来奇怪。之所以奇怪，是因为你获取锁，检查条件，但如果条件不满足的话。
- en: You go to sleep with the lock。 Okay， how many people think that that sounds
    bad。 Okay， yeah， good。 Sounds bad。 It turns out it's okay。 Only this one instance。
    That's what condition variables are for。 They're made in a way that you go to
    sleep with the lock。 If the right conditions aren't present。 Okay， and under the
    covers， it'll take care of unlocking locks whether people can get in。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你和锁一起休息。好吧，有多少人认为这听起来很糟糕？好吧，嗯，没错，听起来确实不好。结果证明其实没关系。只有这一种情况是这样的，这就是条件变量的用途。它们是以一种方式设计的，让你在条件不满足的情况下与锁一起休息。好的，而在后台，它会处理解锁锁的操作，让其他人能进入。
- en: but the paradigm， which I'm going to want to get you warp your brains。 That's
    my job， by the way。 warping brains is what I do is to understand the pattern this
    paradigm programming where you lock things。 check conditions， and go to sleep
    with them。 And the operations are some form of a weight operation where you give
    it the lock。 Okay， so wait says go to sleep。 But here's the lock， by the way，
    which I currently have locked。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个范式，我希望能让你们的大脑转变一下思维方式。这是我的工作，顺便说一句。扭曲大脑是我的职责，就是理解这种范式编程的模式，其中你锁定某些事物，检查条件，并且与它们一起“睡觉”。这些操作是一种权重操作，你给它锁。好吧，"wait"
    就是让它去休息。但顺便说一句，这是我当前锁定的那个锁。
- en: so you can imagine why this doesn't deadlock everything right。 And then you
    can see a signal which says wake up one waiter。 And broadcast which wakes up all
    the waiters。 Now。 if you look at this from a object oriented standpoint， you think
    of them this way。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以想象为什么这不会导致所有操作都死锁。然后你会看到一个信号，表示叫醒一个等待者。广播信号会唤醒所有等待者。现在，如果你从面向对象的角度来看，你应该这样理解它们。
- en: So that's what Java gives you。 If you're talking in C with P threads。 you're
    going to also have another pointer to the condition variable because obviously
    these operations are on the condition variable。 Okay。 You always have to hold
    the lock when you do any of these three things。 Holding the lock means you acquire
    it。 Okay。 So， so monitor with condition variables is really has a lock。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是Java为你提供的。如果你在使用C语言和P线程，那么你还会有一个指向条件变量的指针，因为显然这些操作是作用于条件变量上的。好的。在做这些操作时，你始终需要持有锁。持有锁意味着你获取了它。好的，所以带有条件变量的监视器确实需要一个锁。
- en: which provides mutual exclusion。 You always acquire it kind of before accessing
    shared data structures。 so you might have a lot of people trying to get into the
    monitor。 So you can have many condition variables in your program and they all
    represent weight cues that you can sleep on。 So what we're really doing is we're
    taking that thing that the kernel can do so easily like have weight cues that
    you put yourself to sleep on。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了互斥机制。在访问共享数据结构之前，你总是需要先获取它。所以你可能会有很多人尝试进入监视器。你可以在程序中有许多条件变量，它们都代表着可以让你休眠的等待队列。所以我们真正做的是，我们正在利用内核能够轻松处理的那些功能，比如有等待队列，可以让你自己进入休眠状态。
- en: And we're exporting it up at the user level so you the user programmer can use
    it。 And that's kind of why this is such a cool idea。 And in contrast to semaphores。
    where you can't grab a lock and go to sleep。 So remember when we swap the P operations
    we deadlocked our coke machine。 And heaven forbid it's four in the morning and
    never want to deadlock your coke machine。 Okay。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在用户级别导出了这个功能，这样你作为用户程序员就可以使用它。这也正是为什么这个想法如此酷的原因。与信号量相比，信号量无法在获取锁后让线程进入睡眠状态。记得我们交换P操作时导致了我们的可乐机死锁。天哪，要是凌晨四点时发生死锁，那可真糟糕了。好吧。
- en: With with condition variables。 And that's not going to happen。 Okay。 And so
    I want to give you an example of a buffer。 Okay。 this is an infinite synchronized
    queue so we can put an arbitrary number of things on here。 I'm only doing it one
    sided to show you。 But for instance， we have a lock。 That's the buffer lock。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件变量后，这种情况不会发生。好吧。接下来，我想给你一个缓冲区的例子。好吧，这是一个无限同步队列，我们可以在这里放入任意数量的元素。我这里只展示了单向的情况。比如，我们有一个锁，那就是缓冲区锁。
- en: We have a condition variable and a queue。 Now that queue is an object with link
    lists or whatever。 Maybe it's using your list operation。 And that's a big bond
    of these days from from pit tops right。 So the producer。 What is the producer
    has to do the producer。 Basically， since it's an infinite。 We're not worried about
    filling it up， but we are making sure that when we put something on that cue。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个条件变量和一个队列。现在，这个队列是一个包含链表之类的对象。也许它使用的是你的列表操作。这些天来，这可是个大热点，特别是在笔记本电脑上。所以生产者呢，生产者必须做的事情。基本上，因为这是一个无限队列，我们不需要担心填满它，但我们确保在往队列中放入东西时。
- en: We don't screw the queue up。 And if anybody sleeping in front of the coke machine
    waiting for a coke we wake them up。 Okay， and that the way that looks is very
    simple we acquired the lock。 Hold on。 Let me just get my。 my magic laser pointer。
    So we acquire the lock here。 And then because we have the lock。 we can in queue
    an item on the queue without worrying about somebody getting screwed up。 Okay。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会弄乱队列。如果有任何人在可乐机前面等着，我们会把他们叫醒。好吧，操作过程非常简单。我们首先获取锁。稍等一下，让我拿一下我的魔法激光指示器。我们在这里获取锁，然后，因为我们已经有了锁，我们可以安全地将一个元素加入队列，而不用担心有人会因此出问题。
- en: And then we do a signal to on that condition variable to wake up somebody waiting
    for the queue。 And then we release the lock and we're good to go。 And then we're
    going to get the producer here on this one sided cue is pretty simple。 It's just
    has to be able to wake up people that are sleeping。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在该条件变量上发出信号，唤醒正在等待队列的某个线程。接着，我们释放锁，一切就绪。接下来，我们来看看生产者在这个单向队列中的操作，实际上非常简单。它只需要能够唤醒那些正在睡觉的人。
- en: The interesting thing here is in the consumer， because the consumer。 when it
    goes to get an item off the queue needs to be put to sleep。 If there's nothing
    there。 Okay。 because if you go to DQ from a queue and there's nothing there you
    get back。 No， it's messy。 And then we have you wait until something shows up。
    And so here's the pattern。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的地方在于消费者，因为消费者在从队列中取出项目时，如果队列中没有数据，它需要进入休眠状态。好吧，因为如果你从一个空队列中进行出队操作，你会得到一个空值，结果很混乱。然后我们让它等待直到有东西出现。所以，这里就是操作模式。
- en: We acquire the lock like we always do。 So now we're in the monitor。 And now
    we say while the queue is empty。 While the cubing empty is bad for us because
    we need something will do a weight。 Where we give it the condition variable in
    the lock。 That's we're doing C like syntax here。 And notice that we put this in
    a while loop。 If you're empty， go to sleep。 When you wake up。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样获取锁。现在我们进入了监视器，然后我们说，如果队列为空，那么就一直等待。因为队列为空对我们来说很糟糕，我们需要等到有东西进来。于是我们在条件变量和锁上进行等待。这里我们使用的是类似C语言的语法。注意我们把这个放在了一个while循环里。如果队列为空，就去睡觉。当你醒来时。
- en: check again if the queue is empty。 If it's not empty anymore。 We pass through
    the while we deque the item。 We release the lock。 And we return the item。 And
    because we have checked to make sure the queue wasn't empty before we deque。 We
    know that this item that we're returning is non no。 This looks straightforward。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查队列是否为空。如果不再为空，我们通过了 while 循环，执行出队操作。然后释放锁。最后返回该项。因为我们在执行出队操作之前已经检查过队列是否为空。所以我们知道返回的这个项不是空的。看起来很简单。
- en: But there's some really interesting things embedded in here that I want to talk
    about。 So one。 Yeah。 go ahead。 Ah。 So， because just use that as a rule。 you always
    are inside the lock whenever you do wait signal or broadcast。 Okay， call that
    a rule。 Yeah， call it a rule。 Go ahead。 Good。 So。 Question is when it wakes up
    from condition wait。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一些非常有趣的东西，我想讨论一下。首先。是的，继续。啊。所以，因为只要按照这个规则来。每当你进行等待信号或广播时，你总是处于锁的内部。好的，称它为规则。是的，称它为规则。继续。好的。那么，问题是，当它从条件等待中醒来时。
- en: does it have the lock acquired。 So here's what you need to do。 Remember brain
    warp。 Okay。 What do you see for this code？ I acquire a lock。 I do a bunch of stuff。
    I released the lock。 That's what I see looking at this code， right？ Don't think
    hard。 Don't think too hard。 I acquire the lock。 I release the lock。 Well， I'm
    in here。 This is all about the lock。 Okay。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否获得了锁呢？那么，你需要做的是。记住脑部扭曲。好的。你从这段代码中看到什么？我获取了锁，做了一堆事情，最后释放了锁。这就是我看到的代码，是吧？不要想得太复杂。不要想得太深。我获取了锁，释放了锁。好了，我就在这里。这一切都与锁有关。好的。
- en: don't get yourself hung up on the fact that you waited and， you know。 went to
    sleep and really to read this code at face value you grabbed the lock。 You do
    much of stuff。 You release it。 And then that's so powerful to think that way that
    all of this has a lock is I can say while empty。 And when I decide that this isn't
    empty anymore， I can go down here and DQ and I know for a fact that no other thread
    got in there and grabbed it out from under me because I have the lock。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不要纠结于你等待了，并且你知道，去睡觉，实际上从字面上理解这段代码，你获得了锁。做了很多事情。然后你释放它。然后这种思维方式是非常强大的，认为所有这些都有一个锁的原因是，我可以说当队列为空时。我决定队列不再为空时，我可以下去进行出队操作，并且我知道没有其他线程进入并从我手中取走它，因为我有锁。
- en: I mean， look， see， I grabbed the lock up here。 I released the lock down here。
    Okay。 So we can talk about how to build this。 Maybe if you slide， but for now，
    if you think about this。 as I acquired the lock， I do all this stuff with the
    lock and then I release the lock。 It's a lot easier to understand what's going
    the code。 Okay。 So that because of that。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，看，你看，我在这里获取了锁。我在这里释放了锁。好的。那么我们可以讨论一下如何构建这个。也许你可以滑动，但现在，如果你想一想。我获取了锁，做了所有与锁相关的事情，然后释放了锁。这样就更容易理解代码在做什么了。好的。所以，正是因为这样。
- en: you can say if I check that condition here and discover that it's not empty。
    I can go ahead and DQ and I know for absolute fact that nobody stole an item out
    from under me because of concurrency because I have the lock。 And they had to
    grab the lock before they could do anything。 So therefore。 I am all powerful there
    for that little segment。 Yes。 So this is an infinite queue。 That's okay。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，如果我在这里检查到条件并发现它不为空，我可以继续进行出队操作，并且我可以绝对确定没有任何人因并发问题而从我手中偷走一个项，因为我有锁。他们必须在做任何事情之前获取锁。因此，在那段小代码中，我是无敌的。是的。所以这是一个无限队列。没问题。
- en: I did double sided earlier。 Hopefully you can see how to make double sided really
    easily here。 but I wanted to start with a simple thing。 So there's no overflowing
    this queue just goes forever。 Yes。 Say again。 So this good question is this busy
    waiting。 No。 this is not busy waiting because I'm going to sleep most of the time。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前做了双面打印。希望你能看到这里如何轻松实现双面打印。但我想先从一个简单的事情开始。所以这个队列不会溢出，它会一直继续下去。是的。再说一遍。这个问题很好，这是忙等待吗？不是。因为我大部分时间都在睡觉，所以这不是忙等待。
- en: So I do a loop and I sleep until somebody signals。 So this is not wasting cycles。
    This is really literally waiting for a signal condition。 So good question。 Question。
    Yes。 Very good。 So， very good。 So you're determined to do implementation， which
    is a very admirable thing。 So how does this have to work， right？ This has to work
    that when I wait under the covers。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我做一个循环，直到有人发送信号。我就一直等着，这样就不会浪费 CPU 周期。实际上这就是在等待一个信号条件。问题很好。问题。是的。非常好。那么，很好。你决定去实现这个，这是非常值得钦佩的事情。那么，如何让它工作呢，对吧？它必须在我等待的条件下才能工作。
- en: The monitor condition variable runtime system， whatever that is。 puts me on
    a weight queue and releases the lock。 And it actually gives it to somebody else
    but releases the lock。 Automically， and before I wake up and come out of the way
    before I return from weight。 it real acquires the lock for me。 So as far as this
    code is concerned， I've always got the lock。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器条件变量运行时系统，不管那是什么，把我放在一个等待队列里并释放了锁。实际上，它把锁交给了其他人，但自动释放锁。在我醒来并离开等待状态之前，锁会重新获取到我手里。所以就这个代码而言，我始终持有锁。
- en: And the only time I don't have the lock is sort of when I'm sleeping and don't，
    I'm not aware。 Good question。 Yes。 Yes。 Why do we have the wild loop？ Anybody
    want to take a stab？ Well。 you could say the producer， the producer is only woken
    up one because we do signal instead of broadcast。 Okay， but you're on it。 You're
    on a good path there。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 而我唯一没有持有锁的时候，就是当我在睡觉，且不知情的时候。好问题。是的。是的。为什么我们要有这个死循环？有谁想尝试一下吗？嗯，你可以说生产者，生产者只会被唤醒一次，因为我们发出的是信号而不是广播。好的，你说对了。你走在正确的道路上。
- en: Just follow somebody else who else could steal this。 Yeah。 Yeah。 Remember we
    have multiple consumers， maybe one of them was sleeping。 But the producer wakes
    them up。 but the other one comes zooming in at just the wrong time and grabs the
    item out of the queue。 And so then we have to always check our condition double
    check our condition before we decide we've got the item。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就是跟随别人，谁还能偷走它。对。对。记住我们有多个消费者，可能其中一个在睡觉。但生产者把他们叫醒了。但是另一个消费者在错误的时间冲进来，从队列中抢走了项目。所以我们必须总是检查我们的条件，在决定我们拿到项目之前，双重检查我们的条件。
- en: And in fact， that's a perfect intro into the next two slides。 So there are two
    types of scheduling that you see in condition variables and monitors。 One's called
    Mesa scheduling the other's called horror scheduling。 And notice that we're looking
    at this loop， which says， you know。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这恰好是进入接下来的两张幻灯片的完美开场。条件变量和监视器有两种调度类型。一种叫做Mesa调度，另一种叫做Horror调度。注意我们正在看这个循环，它说的是……
- en: we keep checking the condition and if it's not right yet going to sleep。 And
    then when we wake out of the condition we check it again。 And this is clearly
    what you were thinking when you ask your question。 Why don't we just say， well。
    if the queue is not。 If the queue is basically empty， then we go to sleep。 Otherwise。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断检查条件，如果条件还不对，就去睡觉。然后当我们从条件中醒来时，我们再检查一次。这显然是你在问问题时想到的。为什么我们不直接说，好吧。如果队列为空，我们就去睡觉。否则……
- en: we just fall through， right。 And the issue here is that it depends on what happens
    when you signal。 Because the simplest thing you could imagine， which is what's
    called Mesa scheduling is yeah you signal somebody and they just get put on the。
    the ready queue and the scheduler is just doing its thing。 And if somebody else
    happens to get in there first， then they might steal it out from under you。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就只是直接掉下去，对吧。这里的问题在于它取决于信号发出时发生了什么。因为你能想象到的最简单的情况，也就是所谓的Mesa调度，是的，你发出信号给某人，然后他们就被放入准备队列，调度器继续执行它的任务。如果其他人先进入队列，那么他们可能会从你下面抢走它。
- en: Okay， but you can imagine so horror was actually a mathematician。 And he came
    up with a different way to look at this and I'll show you that on the next slide。
    So this current weight while loop is kind of the simple thing which is called
    Mesa scheduling after the Xerox park Mesa operating system。 The other is named
    after a British logician。 And if you look at what his notion of a monitor is。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但你可以想象，Horror实际上是一个数学家。他提出了另一种看待这个问题的方法，我将在下一张幻灯片中展示给你。所以这个当前的等待死循环是一个简单的例子，叫做Mesa调度，得名于施乐帕克的Mesa操作系统。另一个则以一位英国逻辑学家的名字命名。如果你看看他对监视器的定义……
- en: is when you do signal。 You actually hand the lock to the sleeper。 And wake them
    up and let them run and then they'll eventually get back to you。 And thereby you
    guarantee that if I'm going to signal somebody they actually run right away and
    get the thing I signal them about。 Okay， so you can see why this might appeal
    to a logician right because it's nice and clean。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就是当你发出信号时，你实际上把锁交给了那个正在睡觉的人。然后把他们唤醒，让他们运行，最终他们会回到你这里。通过这种方式，你可以保证如果我发信号给某人，他们会立刻运行并得到我发给他们的信号内容。好的，所以你可以理解为什么这对逻辑学家来说可能很有吸引力，因为它既简洁又干净。
- en: So if we look at this sequence， where we have the signal or producer on the
    left。 and the consumer on the right， what we see here is that the producer grabs
    the lock。 because you always have the lock signals the consumer。 And immediately
    what happens is that thread gives the lock and the CPU over to the other thread。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们看一下这个序列，我们有左边的信号发出者或生产者，以及右边的消费者，我们看到的是生产者获取了锁，因为你总是有锁，信号发出给消费者。然后，紧接着发生的事情是该线程将锁和CPU交给了另一个线程。
- en: And let's it run condition weight， which then goes through release。 And presumably
    in the middle here is where we grab an item off the queue。 So we know for a fact
    that when we signal we are the ones that run。 And we are the champion。 we grab
    the guy off the queue。 And then it's when we release in our code is the point
    at which we say well atomicity is no longer required here let anybody run。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让它运行条件等待，接着会释放。假设中间是我们从队列中取出一个项目。所以我们知道，当我们发出信号时，我们就是那个运行的人。我们是冠军，我们从队列中取出了那个人。然后，当我们在代码中释放时，就是我们说“好吧，这里不再需要原子性，任何人都可以运行”的时刻。
- en: And then what happens with the with the horse scheduling is we get the lock
    in the CPU back to the original guy。 And he gets to finish up what he's doing。
    So on first grant plants this actually seems like really nice semantics because
    when you signal the person you're signaling gets what you asked them to。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，关于马匹调度发生的事情是，我们将锁返回到原来的线程，他可以完成他正在做的事情。所以在第一次授予时，这实际上看起来像是非常好的语义，因为当你向某人发信号时，你发信号的人会得到你要求他们做的事情。
- en: Okay， seems good。 Okay， but it turns out。 And most textbooks talk about this
    most operating systems do the other thing and can anybody tell me why you want
    to do the other thing。 Yes。 Well， you can give a lock， right， you just have to
    say okay you got the lock。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，听起来不错。好了，但事实证明，大多数教科书都谈到这一点，大多数操作系统做的是另一种方式，有人能告诉我为什么要做另一种方式吗？是的，你可以给出一个锁，对吧，你只需要说，好，你得到了锁。
- en: And you know it's about it's about who comes out of a choir or condition weight
    in the right thing so handing a lock is not really a hard thing under the covers。
    Okay。 Yes。 Good。 See， so all of you here are starting to get sophisticated enough
    that you can start asking questions about overheads。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你知道，关键在于谁在条件等待时出来，因此在内部交出锁并不是一件难事。好，明白了。看得出，你们在座的每个人都开始变得足够复杂，能够开始询问关于开销的问题。
- en: Right。 And if I go from this thread to this thread to this thread back again。
    I've got context switching。 I got cash misses。 I've got all sorts of overheads
    in here。 And that may not actually be even necessary because we just put a while
    loop right in and it's not necessary。 And instead what most systems do is they
    just do the signal which all it does is takes this thread wakes it up puts it
    on the red。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对的。如果我从这个线程切换到这个线程，再切换到这个线程，然后再回到这个线程。我就有了上下文切换，我有缓存缺失，所有这些开销可能完全没有必要，因为我们只是放入一个while循环而已，这其实并不需要。相反，大多数系统做的是，它们只是发出信号，实际上只是唤醒这个线程，并将其放到红队中。
- en: And then it just keeps going。 And that's the Mesa version。 So the signal just
    keeps the lock in the processor waiters placed on the red red acute no special
    priority。 And so on the same scenario signal。 Put the waiting thread on the red
    cue。 And we just keep going。 And we release and we run for a little while and
    sometime later the scheduler decides to put us to sleep and wake the other one
    up。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它继续进行。这就是Mesa版本。所以信号会一直保持锁在处理器中，等待者会被放到红队队列中，没有特殊优先级。所以，在同样的场景下，信号会把等待线程放入红队队列中。然后我们继续进行，释放并运行一段时间，过一段时间调度器决定让我们休眠并唤醒另一个线程。
- en: And then that's not a conditional weight needs to check the condition again
    because it's been a little while since signal。 And if everything's good finishes。
    Okay。 So that's called Mesa Scheduling and practically you need to check the condition
    again after weight。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这不是一个条件等待，需要重新检查条件，因为自从发信号以来已经过了一段时间。如果一切正常，就完成了。好了。这就是所谓的Mesa调度，实际上你需要在等待后再次检查条件。
- en: Okay。 Yeah。 Yep。 So， great question。 What we're worried about exiting the while
    loop and getting a contact switch in here and somebody gets in there and grabs
    it。 That's your worry。 Okay。 Anybody want to tell me why that won't happen that
    way。 Yes。 Yes。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。是的。嗯，很好的问题。我们担心的是退出while循环时发生上下文切换，结果有人进入并抓住了锁。这就是你的担忧。好，有人想告诉我为什么这种情况不会发生吗？是的。是的。
- en: we have the lock。 Okay。 Remember， we're thinking about this as we've got the
    lock。 And so。 as long as we don't release the lock。 We have the lock。 And so no
    thread can get in there that's supposed to touch this cue because they all have
    to acquire that lock first。 And we've got the lock。 Great question though。 You
    see how that works。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取锁。好的。记住，我们要把这个当作我们已经获取了锁来思考。所以，只要我们不释放锁，我们就拥有锁。没有线程能够进入这个区域来接触这个队列，因为它们都必须先获取锁。而我们已经拥有锁。这个问题问得很好。你看到了它是怎么运作的吗？
- en: We got the lock we do our stuff we release the lock。 Now we can switch a bunch
    of threads。 You know threads xyzq can all run as long as they're not trying to
    touch this stuff。 But if they were they would have to grab that lock and then
    they'd be put asleep。 Yes， by all means。 So the， because the producer hasn't released
    the lock。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取锁，执行我们的任务，然后释放锁。现在我们可以切换很多线程。你知道，线程xyzq都可以运行，只要它们不试图接触这些内容。但如果它们要接触这些，它们就必须先获取锁，然后会被挂起。是的，当然。所以，因为生产者还没有释放锁。
- en: There's no way for this guy to come out of condition weight。 And the reason
    for that is condition weight re acquires the lock first。 but it'll wait until
    the lock's free。 So， to the extent that I can encourage warping of brains。 Right。
    You think about grabbing and releasing the lock and all that code in there really
    the lock is there and so no thread can get into your code。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人可以从条件等待中出来。这是因为条件等待首先会重新获取锁，但它会等待直到锁释放。所以，在我尽可能鼓励大家“让大脑转弯”的时候，想一想获取和释放锁以及里面所有的代码，实际上锁在那里，所以没有线程可以进入你的代码。
- en: Okay。 Good。 Yes。 I'm sorry， can you speak up a little bit。 So there are you
    asking。 can they be done as single instruction type of atomic operations。 They're
    not really single instruction because they put people to sleep and so on。 So they
    interact with the schedule。 But what you can know the atomicity you crave comes
    from the fact that we have the lock。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。很好。是的。抱歉，你能再大声一点说吗？所以，你是在问它们能否作为单条指令类型的原子操作来完成吗？它们并不是真正的单条指令，因为它们会让线程休眠等等。所以它们与调度程序有交互。但是你可以知道，你所期望的原子性来自于我们拥有锁的事实。
- en: And so whatever condition weight and signal do they have to respect that。 So
    that if I ever come out of the condition weight。 And then I'm going to talk again
    because I'm respecting the notion that the programmer thinks of the lock there。
    Good。 All right。 Once you kind of get this， once you wrap your brain around it
    this is incredibly powerful。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以无论条件权重和信号有什么，它们都必须遵循这个规则。这样，如果我从条件权重中出来，我就会再次进行处理，因为我尊重程序员认为在这里存在锁的概念。好的。没问题。一旦你理解了这一点，一旦你把脑袋绕过来，这将是极其强大的。
- en: Okay， and I'm going to show you readers writers。 Okay。 And most real operating
    systems， by the way。 do this because it's much easier just to signal somebody
    and take them off the way you and put them on the ready queue than it is to do
    this past the lock and all that stuff。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我将展示读者写者模型。好了，顺便说一下，大多数真实的操作系统都会这么做，因为直接通过信号通知某人并让他们从等待队列中移除，然后将其放入准备队列，比起通过锁之类的操作要简单得多。
- en: So， any other questions here。 Are we doing we started getting it。 It's weird。
    Yeah。 question the back。 No， just stretching。 Okay， sorry。 So， here is the circular
    buffer version three。 where it's， it's similar to what we did earlier， but you'll
    notice it's a little different。 We acquire the lock。 And now we say， well， as
    long as the buffer is full to a weight。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里有其他问题吗？我们是否开始理解了？有点奇怪，是吧？后面有问题吗？不，只是在伸展一下。好的，抱歉。那么，这是环形缓冲区的第三版。它与我们之前做的类似，但你会注意到它有一些不同。我们获取锁。现在我们说，只要缓冲区满了，就等待。
- en: And we'll just keep looping。 And， but this isn't a busy weight because we go
    to sleep。 And the only way we'll get woken up is by somebody signaling。 All right。
    And then once we wake up the buffer is not full anymore because we have the lock。
    We go ahead and cue the item。 We signal the consumer and we release the lock and
    then the consumer acquires the lock says。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一直循环。但这不是忙碌等待，因为我们会去睡觉。我们唯一会被唤醒的方式是通过某个信号通知。好了。然后，一旦我们醒来，缓冲区就不再满了，因为我们已经获取了锁。我们继续将项放入队列。我们给消费者发送信号，然后释放锁，消费者就会获取锁并继续执行。
- en: well， well， the buffer is empty。 Sleep， wait， right， go to sleep。 And when we
    get come out of that。 since we have the lock， by the way， I noticed that I'm missing
    an address here。 Sorry about that。 We deque the item。 We signal the producer to
    wake up。 We release the buffer lock。 We return。 So now I've got a double sided
    buffer that we did really complex was a really complicated。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，好吧，缓冲区是空的。休眠，等待，对吧，去休眠。当我们从中出来时，顺便提一下，我注意到我这里漏了一个地址。抱歉。我们出队一个项目。我们发信号给生产者让它醒来。我们释放缓冲区锁。我们返回。所以现在我有一个双向缓冲区，我们做得非常复杂，是一个非常复杂的过程。
- en: Semaphore thing that now I'm doing really simply with monitors because this
    condition can be as complicated as I like。 Okay， all it really says is while I
    can't proceed， go to sleep。 The signaler will signal me when I might be able to
    proceed and I can check that condition again and continue。 Yes。 So， if we do condition
    weight， it's absolutely possible that another consumer could get in there。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的东西，现在我通过监视器非常简单地实现，因为这个条件可以复杂到我喜欢的程度。好的，实际上它所说的就是，在我无法继续的情况下，去休眠。信号者会在我可以继续时发信号给我，我可以再次检查这个条件并继续。是的。所以，如果我们执行条件等待，完全有可能另一个消费者会进入那里。
- en: Yes。 And if you think about it， but， but it's never the case that we come out
    of condition weight and we're running and somebody can get in there at that point。
    The only time that we can get rearrangement is when we're sleeping。 Okay。 Sure。
    Well。 the moment I go to sleep， I no longer have the lock because I'm sleeping。
    And so the producer can absolutely get in there。 No problem。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。如果你想一想，但实际上，永远不会有这种情况：我们从条件等待中出来并开始运行，这时其他线程能够进入。唯一可能发生重排序的时刻是当我们休眠时。好的，明白了。当我一旦去休眠，我就不再持有锁，因为我在休眠。所以生产者完全可以进入。没问题。
- en: It's just that there are multiple consumers floating around， which of those
    consumers。 both the one sleeping and the ones that are floating around still running。
    get the item from the producer that's undefined。 It's sort of， it's not five four
    or anything。 Okay。 you guys ready to do some more powerful complex thing here
    now。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只是有多个消费者在周围漂浮，哪些消费者能够得到生产者的项目是未定义的。既包括那些休眠的，也包括那些仍然在运行的。这种情况是没有固定顺序的。好的，大家准备好做一些更强大、更复杂的事情了吗？
- en: we might as well we got 15 minutes right。 So yeah， go ahead。 Not guaranteed
    to be。 If you want。 if you either have to get a special implementation that tells
    you it's。 but then it wouldn't even help you because there could be other consumers
    that weren't sleeping。 Right， so the， they could come in at any time。 So even
    if the。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也许可以，反正我们有15分钟，对吧？所以，继续吧。没有保证。如果你想的话。如果你必须得到一个特殊的实现来告诉你，但那也没用，因为可能还有其他没有休眠的消费者对吧？所以他们随时可能进来。所以即使是……
- en: the condition variable were fully FIFO， you still might not for sure have an
    ordering there。 And in exams。 You know， if ordering might matter， we'll tell you
    what ordering to assume。 but you can in principle make a weight variable that's
    FIFO。 Even though that wouldn't help you with other folks that come in around
    the sleeping ones。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 即使条件变量完全遵循先进先出（FIFO）顺序，你也不能完全确定是否会有一个明确的顺序。而在考试中，如果顺序可能很重要，我们会告诉你假设哪种顺序。但是，原则上，你可以创建一个先进先出的等待变量。尽管这样做对其他那些在休眠的消费者来说并没有帮助。
- en: but we'll tell you if you need to know。 All right。 And， and you got to look
    at the spec。 the spec doesn't say there's any special ordering on the weight variable
    assume there's no ordering on the weight。 Okay。 All right， let's look at why the
    while loop again， Mesa semantics。 Most operating systems。 Mesa semantics， when
    you signal it simply puts the thread on the ready queue。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你需要知道，我们会告诉你。好的，另外，你必须查看规格说明。规格说明没有说权重变量上有任何特殊的顺序，假设权重没有顺序。好的，明白了。现在让我们再看看为什么是while循环，Mesa语义。大多数操作系统遵循Mesa语义，当你发出信号时，它只是把线程放入就绪队列。
- en: It may or may not require the lock immediately， but you know for a fact that
    when the code comes out of condition weight and it's running in the users code。
    the lock is acquired。 Okay。 And is this busy waiting。 No， because we're sleeping，
    we only， you know。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能不需要立即获取锁，但你知道当代码从条件等待中出来并运行在用户代码中时，锁已经被获取。好的。那么这是忙等吗？不是的，因为我们在休眠，我们只是……你知道。
- en: when we wake up and check a while condition that's actual computation that's
    helpful。 And we'll be waiting。 All right。 So let's look at the readers writers
    problem。 So the motivation here is a shared database。 Two classes of users readers
    and writers and readers never modify the database and the writers do。 They both
    read and modify。 And so we need to make sure that when a writer is writing the
    database。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们醒来并检查一个条件时，那是实际的计算，对我们是有帮助的。然后我们会等待。好了，让我们来看看读者写者问题。这里的动机是一个共享数据库。两类用户：读者和写者，读者永远不修改数据库，而写者会修改。它们都可以读取和修改数据库。因此，我们需要确保，当一个写者正在写入数据库时。
- en: No other readers are looking because the writers going to do weird stuff， you
    know。 may modify a bunch of things inconsistently until they release and say they're
    done。 So we can never let readers look at the database。 Well。 the writers writing
    and we don't even want two writers to go at the same time in the simplest case。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为写者要做一些奇怪的事情，可能会修改很多不一致的内容，直到它释放锁并表示完成。所以我们绝不能让读者在写者写入时查看数据库。而且，在最简单的情况下，我们甚至不希望两个写者同时进行。
- en: Okay。 So really， we could have many readers at once or one writer。 but never
    a reader and writer shall meet。 Okay。 Except in the database at different times。
    We good。 So that's going to be what we try to do。 And remember， this is like a
    quick mnemonic here。 This is our typical structure of a monitor program。 The，
    you grab a lock。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，实际上，我们可以有多个读者同时存在，也可以有一个写者，但读者和写者绝不能同时存在。除非在数据库中，且在不同的时间。我们明白了吗？所以这将是我们要尝试做的事情。记住，这就像是一个快速的记忆法。这里是我们典型的监视器程序结构。首先，你获取一个锁。
- en: You check and see whether your conditions are good。 And if not。 you wait and
    you potentially check again and then when you're ready， you unlock。 And now。 what
    I've done in this loop is I've done something to reserve。 What I need。 Okay。 And
    then I can go ahead and do something without needing to wait because I've reserved
    or check conditions up here。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你检查并查看你的条件是否满足。如果不满足，你就等待，并可能会再次检查。当你准备好时，你解锁。现在，在这个循环中，我做了“预定”我需要的东西。好了，然后我可以继续做其他事情，因为我已经预定好了，或者在上面检查了条件。
- en: And then when I'm done， I lock and I might signal somebody and unlock。 So this
    is going to be like a pattern for us。 Okay。 and if you think about what I mean
    by reserve in the case of the queue。 I check here and maybe I get you an item。
    Right before I release the lock。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我完成时，我会锁定，可能会发送信号给某人，并解锁。所以这将是我们的一种模式。好了，如果你考虑一下，在队列的情况下，我所说的“预定”是什么意思。我在这里检查，可能会给你一个项目。在我释放锁之前。
- en: but now I have that item and I can do whatever I want on the item because the
    item is mine。 Okay。 and it's going to be the database is going to be what we fit
    in here。 So we're going to check our readers writers conditions on the entry。
    Then do the database。 assuming that we have， you know， only readers or one writer。
    And then when we're done。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，我已经拥有了这个项目，我可以对其进行任何操作，因为它是我的了。好了，数据库将是我们在这里操作的内容。所以我们将检查读者和写者的条件，然后再进行数据库操作。假设我们现在只有读者或者一个写者。完成后我们就可以结束。
- en: we'll do some signaling in case people need to wake up。 Okay。 so that's going
    to be our basic pattern here。 And it's going to start out seeming complex。 but
    it's what's cool about what I'm going to show you is。 A， it's not really that
    complex， but B。 it'll show you that you can do so much more with monitors and
    you could ever conceive of doing with semaphores。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会进行一些信号传递，以防有人需要醒来。好了，这将是我们基本的模式。它一开始看起来可能很复杂，但我将展示给你看的有趣之处在于，A，它其实并没有那么复杂，B，它会向你展示，你可以用监视器做比你想象的更多事情，远超过信号量能做到的。
- en: Okay， because you can do something like what I'm about to show you with monitors。
    but I'll leave it as an exercise to the reader to figure out how to do this with
    semaphores。 Okay。 so what do we have correct this constraint。 So readers can access
    the database as long as there's no writers writers can access the database when
    there's no readers or writers because we only want one writer at the time。 And
    only one thread can manipulate these state variables that are keeping track of
    the current state of the world at a time and we're going to do that with our monitor
    lock。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为你可以像我即将展示的那样使用监视器做一些事情，但我会把如何使用信号量来做这个作为练习留给读者。好了，那么我们正确地处理了这个约束条件。读者可以在没有写者的情况下访问数据库，写者可以在没有读者或其他写者的情况下访问数据库，因为我们只希望在任何时刻只有一个写者。并且，只有一个线程可以操作这些用于追踪当前世界状态的变量，我们将通过我们的监视器锁来实现这一点。
- en: So the basic structure looks like this a reader waits until there's no writers
    accesses the database and then wakes up a waiting writer。 if there are any。 Okay，
    and then a writer will wait until there are no readers or writers。 they'll access
    the database， and then at the end， they'll see well， I'm done。 but is there a
    waiting writer or readers that I need to wake up and they'll potentially wake
    them up at that point。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本的结构是这样的：一个读者会等待，直到没有写者，然后访问数据库，并且唤醒一个等待的写者（如果有的话）。好的，然后一个写者会等待，直到没有读者或写者，然后他们访问数据库，最后他们会检查：我完成了，是否有等待的写者或读者需要我唤醒？如果有，他们会在那个时刻唤醒他们。
- en: Okay， and we're going to do that with a bunch of state variables。 Okay， so this
    is exciting。 So we got four state variables and two condition variables。 Okay。
    so the state variables are for integers。 They have an A that number of active
    readers so AR。 the number of waiting readers， WR， the number of active writers。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们将通过一些状态变量来实现这一点。好的，这真令人兴奋。所以我们有四个状态变量和两个条件变量。好的。状态变量是四个整数。它们分别是活跃读者的数量（AR），等待读者的数量（WR），以及活跃写者的数量。
- en: a W and the number of waiting writers， W。 So what is an active reader is somebody
    who has gone through that entry code and is now reading from the database。 searching，
    whatever they're going to do as a reader。 A waiting reader is somebody who's actually
    asleep on the read condition variable because something was not going to allow
    them to go forward like there was a writer。 Okay， and so the difference between
    the A and the W here is active readers are accessing the database。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: W和等待写者的数量W。那什么是活跃读者呢？活跃读者是指已经通过了入口代码，现在正在从数据库中读取，进行搜索，或者作为读者正在做任何事情的人。等待读者是指那些实际上正在等待读取条件变量的读者，因为某些东西阻止他们前进，比如有写者正在写。好的，因此A和W之间的区别在于，活跃读者正在访问数据库。
- en: waiting readers are waiting for access to the database and the difference in
    active writers are accessing the database and waiting writers are waiting。 Can
    somebody tell me right off the bat， what's the biggest value that a W can ever
    be。 One， right。 good。 Okay， why is that because we'd only want one writer at a
    time。 Okay， and if a W is one。 What can you tell me for sure a R is。 Zero， right？
    Okay。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 等待读者正在等待访问数据库，活跃写者正在访问数据库，等待写者也在等待。有人能立刻告诉我，W的最大值是多少吗？是1，对吧？很好。好的，为什么是1？因为我们每次只想有一个写者。好的，如果W是1，你能告诉我AR是多少吗？是0，对吧？好的。
- en: you can start to see how our constraints here fits in。 Okay。 So if you look。
    here's what a reader looks like so the reader first checks themselves into the
    monitor so they acquire the lock。 And now they do this while loop。 And notice
    what it says here while there's either an active writer or a waiting writer。 So
    I add them together I get bigger than zero。 I can't run and so I increment waiting
    readers and I wait。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始看到我们这里的约束是如何适用的。好吧。如果你看一下，这就是一个读者的样子，读者首先将自己检查到监视器中，这样他们就获得了锁。然后他们执行这个`while`循环。注意这里说的内容：只要有一个活跃的写者或者一个等待的写者，我就会加在一起，得到大于零的值。我不能执行，因此我增加等待的读者数量，并且我会等待。
- en: And then when I come out of weight I'm no longer waiting so I decrement waiting
    readers and I go back and check my condition again。 And I'll just keep looping。
    Until I know for a fact that the number of active writers and the number of waiting
    writers are both zero because the atom together you get zero。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当我退出等待时，我不再处于等待状态，因此我会减少等待的读者数量，并再次检查我的条件。我会继续循环，直到我确定活跃写者和等待写者的数量都是零，因为它们加在一起是零。
- en: And only then do I exit。 This while loop。 And at that point I become an active
    reader so I increment it by one。 I release the lock。 And now， don't do them。 I
    read the database。 So the only way I get to read is if I've already made sure
    there are no writers either waiting or active in the system。 And I have incremented
    AR to say that I'm an active reader so that no writers will surprise me by showing
    up。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在这时，我才会退出这个`while`循环。此时我成为一个活跃读者，所以我将其增加1。我释放锁。然后，我不做其他的。我开始读取数据库。所以，我能读取的唯一方式是，如果我已经确保系统中没有写者，无论是等待的还是活跃的写者。我已经增加了AR，表示我是一个活跃的读者，这样就不会有写者突然出现来打扰我。
- en: And now I can access the database and then when I'm done。 I will check out of
    the system so I have to acquire the lock again。 I decrement number of active readers
    because I'm no longer an active reader。 And now I say， hey。 if there are no active
    readers。 And there happens to be a waiting writer。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以访问数据库，完成后。我会再次获取锁来退出系统。我减少活动读者的数量，因为我不再是一个活动读者。然后我说，嘿。如果没有活动的读者，恰好有一个等待的写入者。
- en: Go ahead and signal one writer to wake up because there's no longer any active
    readers and signal it and then release the lock。 Okay， and notice I never look
    at those integers。 A R W R A W W unless I have the lock。 I'm in a critical section。
    So when I'm looking at those variables。 I know for a fact that nobody's going
    to get in there and sort of screw them up on me。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并通知一个写入者醒来，因为现在没有活动的读者，通知它并释放锁。好的，注意到我从不查看那些整数。A R W R A W W，除非我已经获得锁。我在一个临界区。所以当我查看那些变量时，我知道没有人会闯进来并搞乱它们。
- en: I can just look at them。 Okay， and that's why， by the way， this thing I did
    here， W R plus plus。 You guys are all big fans of plus plus now I bet， right。
    But that's really read， add one store。 which is three instructions。 Okay， and
    so if I don't have the lock。 that would be really bad because that's not an atomic
    sequence and different threads could really mess me up right we started this whole
    thing three lectures ago that way。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以直接查看它们。好的，顺便说一下，为什么我这里做了 W R 加一操作。你们现在都是加一操作的大粉丝吧，对吧？但那实际上是读取并加一存储，也就是三个指令。好的，所以如果没有锁，那将非常糟糕，因为那不是一个原子操作，不同的线程可能会把我搞砸，记得我们三节课前就是这么开始的吗？
- en: Okay， so notice how every time I look at these variables I have the lock now。
    The why release the lock here well that so that other threads can come into the
    entry section and classify themselves。 And I have to do that by releasing the
    law。 Okay， now the code for the writer， I acquire the lock。 And now I say well
    there's as long as there's an active writer or an active reader。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以注意到每次我查看这些变量时，我现在已经获得了锁。为什么要在这里释放锁呢？那是为了让其他线程可以进入临界区并自我分类。而我必须通过释放锁来做到这一点。好的，现在是写入者的代码，我获取锁。然后我说，只要有活动的写入者或活动的读者。
- en: I go to sleep as a waiting writer。 And then when I wake up I decrement waiting
    writer。 I exit this condition I now become an active writer。 Release the lock。
    I'm now writing the database。 And I know for a fact if I get to read。 There aren't
    any right any writers in there already or any readers that are going to surprise
    me。 Okay， and now I check out of the system when I'm done by acquiring the lock
    I'm no longer an active writer。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我作为一个等待的写入者进入休眠。当我醒来时，我减少等待的写入者数。我退出这个条件，现在变成了一个活动的写入者。释放锁。现在我正在写入数据库。我确定如果我要读取，里面就没有写入者，或者没有读者会给我制造麻烦。好的，现在我完成后，通过获取锁来退出系统，我不再是一个活动的写入者。
- en: And I say hey if there's a waiting writer signal them to wake up。 Otherwise
    if there's a waiting reader。 Then we know that WR。 Without W W means that there
    are no writers there may be more than one reader and so I broadcast and wake them
    all up。 Because in principle， all of them if their readers could run。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我说，如果有等待的写入者，通知他们醒来。否则，如果有等待的读者。那么我们知道 WR。没有 W，W 意味着没有写入者，可能会有多个读者，所以我广播并唤醒所有人。因为原则上，所有的读者都可以运行。
- en: And so they all wake up and if you think about what's happening under the covers
    is after they wake up。 One at a time their condition wait gets the lock wakes
    up and。 Finds out there aren't any writers and does a plus plus and starts running。
    And then it's released a lot and the next one goes on the next one so if there
    were 20 readers sleeping。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们都会醒来，如果你想一下发生的事情，在他们醒来后。一个接一个地，它们的条件等待获得锁，醒来并发现没有写入者，进行加一操作并开始运行。然后释放锁，下一个继续，依此类推，如果有
    20 个读者正在休眠。
- en: They'll go boing boing boing boing boing boing boing boing boing boing boing。
    And now we'll have 20 readers in the database。 Yes question。 Okay， let's。 So there
    are a lot of cases where you could wake them up because you always check the condition。
    So let's let's see in a moment。 The thing we want to do though is we want to make
    sure that if there's a writer that we okay that we wake them up。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它们会接二连三地响起来“嗡嗡嗡嗡嗡嗡嗡嗡嗡嗡嗡”。然后我们会有 20 个读者在数据库中。是的，问题。好的，接下来。其实有很多情况，你可以唤醒它们，因为你总是检查条件。所以稍等，我们想做的是，确保如果有写入者，我们可以唤醒他们。
- en: Okay， and so you'll see if you look at this code very carefully that it biases
    writers over readers。 Okay， kind of the idea there would be well right rights
    represent keeping the database up to date so we're going to make sure that writers
    get to go forward。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你会发现，如果你仔细查看这段代码，它偏向写者而非读者。好吧，这背后的想法是：写入操作意味着保持数据库的最新状态，所以我们确保写者能够继续执行。
- en: Yes。 No， when a signal when a writer is sleeping。 If you look at the writer
    here。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。没有，写者休眠时会收到信号。如果你看写者的状态。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_10.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_10.png)'
- en: If the writer decided there was a reader it was conflicting with。 It goes to
    sleep so there it's not looking at anything。 So it's sleeping on that okay to
    write condition variable not doing anything and so unless somebody signals them
    they won't wake up they'll just stay there forever。 And so really if we had a
    writer that went to sleep on condition weight。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果写者决定与某个读者发生冲突，它会进入休眠状态，不再看任何事情。所以它在“可以写入”的条件变量上休眠，什么也不做，除非有人给它发送信号，否则它永远不会醒来，只会一直待在那里。所以实际上，如果我们有一个写者在条件等待上休眠的话。
- en: the way they get woken up is right here， they get signals to wake up or here
    they get signals。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被唤醒的方式就是这里，它们会收到唤醒信号，或者这里它们会收到信号。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_12.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_12.png)'
- en: Okay。 Now let me go through a simulation here just briefly so you guys can see。
    And we're going to have this sequence a reader a reader a writer a reader。 and
    initially of course everything starts out at a are equal zero w r zero a w zero
    w zero。 And if you look， our one comes along the room acquires the lock。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在让我简单演示一下，以便你们可以看到。我们的顺序是：一个读者，一个读者，一个写者，一个读者。最初，当然，一切从`a=0`、`w=0`开始。如果你看一下，我们的`r1`来了，房间获得了锁。
- en: So we know that no other thread is messing with these variables and the question
    is is。 is a w plus w w greater than zero。 Right， just look at these variables
    it's not。 So we increment a r plus plus you see how it's a one we release the
    lock。 And now the reason we released the lock is so that other threads that come
    in。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道没有其他线程在干扰这些变量，问题是：`a_w + w_w`是否大于零？对吧，只要看这些变量就知道它们不大于零。所以我们增加了`a_r++`，你看它变成了1，然后释放了锁。现在我们释放锁是为了让其他线程进来。
- en: get a chance to classify themselves and put themselves to sleep on the right
    cues if necessary。 Okay， so we're accessing the database。 Meanwhile。 Back later。
    we acquired the another thread are two comes along acquires the lock。 checks the
    while still no writers in increments releases the lock and accesses the database
    so now we've got two readers in the database。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让自己有机会进行分类，并在需要时根据正确的提示进入休眠状态。好了，现在我们正在访问数据库。与此同时，稍后回来，我们获取了另一个线程，`r2`来了，获取了锁。检查时，仍然没有写者，增加了计数器，释放了锁并访问数据库。所以现在数据库里有两个读者。
- en: which is fine。 Okay， similarly。 Now， soon the readers are busy taking a very
    long time。 W one's coming along。 It acquires the lock。 Now is a w plus a r greater
    than zero。 Yes。 because there's a their active readers。 Right。 And so， as a writer。
    we can't conflict with active readers。 So， we go to sleep。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题。好吧，类似地。现在，读者们正在忙于长时间的操作。`w1`过来了，它获得了锁。现在`a_w + a_r`是否大于零？是的，因为有正在活跃的读者。对吧。所以，作为写者，我们不能与活跃的读者冲突。所以，我们进入休眠状态。
- en: And notice how we incremented w w because we're now awaiting writer。 All right。
    Meanwhile。 our three comes along。 Now notice that this is where our policy comes
    into play because our three enters。 And now the question is， is a w plus w w greater
    than zero。 Yes。 So that third reader is considered after the writer。 So we're
    going to put them to sleep。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何增加了`w_w`，因为我们现在正在等待写者。好吧。与此同时，`r3`过来了。请注意，这时我们的策略开始发挥作用，因为`r3`进入了。现在问题是，`a_w
    + w_w`是否大于零？是的。所以第三个读者会被视作在写者之后。我们将让它进入休眠状态。
- en: So we give the writer a chance to write policy decision。 Okay。 And so we're
    going to go to sleep as a waiting reader。 Hey， our three can't start。 And so notice
    the status at this point is our one and our two are reading w one and our three
    are sleeping。 Okay。 And now some time later。 Two weeks later， our two finishes
    exits the database acquires the lock。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们给写者一个写入机会，这是一个策略决策。好吧，接下来我们将作为一个等待的读者进入休眠状态。嘿，`r3`不能开始了。所以请注意此时的状态：`r1`和`r2`在读，`w1`和`r3`在休眠。好吧，稍后一点时间。两周后，`r2`完成了，退出了数据库，获取了锁。
- en: Decimates AR so now they're going down to one。 And then it says， is a are zero。
    No。 Okay。 so we can't really allow a writer to go forward because， you know， our
    friend。 our one is still reading。 So we'll just exit。 Meanwhile， back at the fort。
    our one finishes does something similar but now notice that they are zero。 And
    at that point。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 减少活跃读者（AR），所以它们现在降到1。然后它检查，活跃读者是否为0？不是。好的。所以我们不能让写者继续前进，因为你知道，我们的朋友（一号）还在阅读。所以我们就退出。与此同时，在前线，一号完成了，做了类似的事情，但现在注意到活跃读者为0。到那个时候。
- en: we say， there are no active readers and there isn't a waiting writer。 So we're
    going to wake up。 W one。 Okay， so now we're in the writer code。 And in that case
    we wake up the writer code。 And it's decrements waiting writer。 And it's going
    to come around。 It's going to look again in the。 the conditions are right for
    it to go。 And it adds one active writer。 Here we go。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，没有活跃的读者，也没有等待的写者。所以我们将唤醒W一个。好的，现在我们进入写者代码。在这种情况下，我们唤醒写者代码。然后它减少等待写者的数量。它会再次检查。条件合适时，它将继续进行。然后它增加一个活跃写者。开始了。
- en: We have one active writer and one waiting reader。 And then we acquire the lock
    when we're done。 We decrement active writer is there another waiting writer。 No。
    Is there one or more rating readers。 Yes。 So we broadcast。 So if there were 12
    waiting readers at that point， we'd wake them all up。 Meanwhile， back at the fort
    that one reader are three wakes up。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个活跃写者和一个等待读者。然后我们获取锁，完成后。我们减少活跃写者，看看是否还有等待的写者。没有。是否有一个或多个等待的读者？有。所以我们广播。如果当时有12个等待的读者，我们会把它们都唤醒。与此同时，在前线，那个读者（三号）醒了。
- en: So they're no longer waiting checks its conditional decrement， you know， does
    what it's doing。 And increments active reader that's in the database。 And it finishes，
    acquires the lock releases。 And at this point， we're all done。 The database is
    idle and we've properly got the readers writers action on the database。 Okay。
    Now the question here again that I see in the chat。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们不再等待，检查其条件递减，知道自己在做什么。然后增加数据库中的活跃读者。完成后，它获取锁并释放。此时，我们已经完成了。数据库处于空闲状态，我们已经正确地处理了数据库中的读者写者操作。好的。现在，我看到聊天中的问题。
- en: which I want to make sure to emphasize is why the while loop again。 because
    it seems like we have the lock。 Why do we have to check the condition again and
    the answer is when we wake up。 we might be sitting on the ready queue a while
    and some other threads could come in and mess up our condition。 So we always want
    to check the condition。 All right， so we'll finish up for here。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调的是为什么又是使用while循环。因为看起来我们已经有了锁。为什么还需要重新检查条件？答案是，当我们醒来时，我们可能会在就绪队列中等待一段时间，而其他线程可能会进入并破坏我们的条件。所以我们总是要检查条件。好吧，那么我们在这里就结束。
- en: semaphores we talked about today， they're like integers with a restricted interface。
    They're very powerful for what they do。 There's two operations P which weights
    of zero and decrements when becoming non zero V increments and wakes up a sleeping
    task。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们谈到的信号量，它们像是具有受限接口的整数。它们在完成任务时非常强大。信号量有两个操作：P操作，等待零并递减，直到不为零；V操作，递增并唤醒一个睡眠中的任务。
- en: You can initialize any value， value monitors or lock plus zero or one or more
    condition variables。 depending on when we look at it， wait signal broadcaster
    or options。 and monitors really represent the logic of the program。 And you saw
    hopefully that we can do a really complicated thing。 Fairly easily， right。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以初始化任何值，值监视器或锁加上零、一个或多个条件变量。根据我们查看的时机，等待、信号、广播者或选项。监视器实际上代表了程序的逻辑。希望你已经看到了，我们能够做一个非常复杂的事情。相对容易，对吧？
- en: we got a very interesting policy in there about readers that come after a writer
    go last and all of that was easy to do with monitors and I challenge you to try
    to do that with semaphores。 Okay， but do it when you're sleep deprived or something
    and maybe it'll help you go to sleep。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在里面有一个非常有趣的政策，关于读者在写者之后才能进入，所有这些在使用监视器时都很容易实现，我挑战你尝试用信号量来实现这个。好了，但试试看在你睡眠不足的时候，也许它能帮助你入睡。
- en: All right， you guys good luck on the exam。 No class on Thursday， but I'll be
    having office hours。 (buzzing)。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，祝你们考试好运。周四没有课，但我会有办公时间。（嗡嗡声）。
- en: '![](img/1641ab5f908ca769eaeff2b6ac73408a_14.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1641ab5f908ca769eaeff2b6ac73408a_14.png)'
- en: '[Silence from the audience]。'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[观众沉默]。'
