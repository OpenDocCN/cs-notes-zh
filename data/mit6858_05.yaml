- en: Native Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地客户端
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 这些讲座笔记略有修改，来自2014年6.858 [课程网站](http://css.csail.mit.edu/6.858/2014/schedule.html)。'
- en: What's the goal of this paper?
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本文的目标是什么？
- en: At the time, browsers allowed any web page to run only JS (+Flash) code.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当时，浏览器只允许任何网页运行JS（+Flash）代码。
- en: Want to allow web apps to run native (e.g., x86) code on user's machine.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望允许Web应用程序在用户的计算机上运行本机（例如，x86）代码。
- en: Don't want to run complex code on server.
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不想在服务器上运行复杂代码。
- en: Requires lots of server resources, incurs high latency for users.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要大量服务器资源，为用户带来高延迟。
- en: Why is this useful?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这有什么用？
- en: Performance.
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能。
- en: Languages other than JS.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除JS外的其他语言。
- en: Legacy apps.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统应用程序。
- en: Actually being used in the real world.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上正在现实世界中使用。
- en: 'Ships as part of Google Chrome: the NaCl runtime is a browser extension.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Google Chrome的一部分发布：NaCl运行时是浏览器扩展。
- en: Web page can run a NaCl program much like a Flash program.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页可以像Flash程序一样运行NaCl程序。
- en: Javascript can interact with the NaCl program by passing messages.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Javascript可以通过传递消息与NaCl程序交互。
- en: NaCl also provides strong sandboxing for some other use cases.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaCl还为一些其他用例提供了强大的沙盒功能。
- en: 'Core problem: sandboxing x86 code.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心问题：沙盒化x86代码。
- en: 'Using Native Client:'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用本地客户端：
- en: https://developers.google.com/native-client/
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://developers.google.com/native-client/
- en: Install browser plug in
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装浏览器插件
- en: Use Nacl tool change to compile C or C++ program
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nacl工具更改以编译C或C++程序。
- en: There are restrictions on what system calls you can use
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可以使用的系统调用有限制。
- en: 'Example app: games (don''t need much systems support)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例应用程序：游戏（不需要太多系统支持）
- en: Special interface to talk to browser (in release called Pepper)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与浏览器交流的特殊接口（在发布中称为Pepper）
- en: 'Make a web page that includes Nacl module:'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个包含Nacl模块的网页：
- en: '`<embed name="nacl_module" id="hello_world" width=0 height=0 src="hello_world.nmf"
    type="application/x-nacl" />`'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<embed name="nacl_module" id="hello_world" width=0 height=0 src="hello_world.nmf"
    type="application/x-nacl" />`'
- en: Module is "controled" x86 code.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是“受控”的x86代码。
- en: 'Quick demo:'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速演示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What are some options for safely running x86 code?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有哪些安全运行x86代码的选项？
- en: '**Approach 0:** trust the code developer.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法0：** 信任代码开发者。'
- en: ActiveX, browser plug-ins, Java, etc.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveX，浏览器插件，Java等。
- en: Developer signs code with private key.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者用私钥签署代码。
- en: Asks user to decide whether to trust code from some developer.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求用户决定是否信任某些开发者的代码。
- en: Users are bad at making such decisions (e.g., with ActiveX code).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户很难做出这样的决定（例如，使用ActiveX代码）。
- en: Works for known developers (e.g., Windows Update code, signed by MS).
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于已知开发者（例如，由MS签名的Windows更新代码）。
- en: Unclear how to answer for unknown web applications (other than "no").
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不清楚如何回答未知的Web应用程序（除了“否”）。
- en: Native Client's goal is to enforce safety, avoid asking the user.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地客户端的目标是强制执行安全性，避免询问用户。
- en: '**Approach 1:** hardware protection / OS sandboxing.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法1：** 硬件保护/操作系统沙盒。'
- en: 'Similar plan to some ideas we''ve already read: OKWS, Capsicum, VMs, ..'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们已经阅读过的一些想法类似的计划：OKWS，Capsicum，VMs，..
- en: Run untrusted code as a regular user-space program or a separate VM.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不受信任的代码作为常规用户空间程序或单独的VM运行。
- en: Need to control what system calls the untrusted code can invoke.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要控制不受信任的代码可以调用的系统调用。
- en: 'Linux: seccomp.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux：seccomp。
- en: 'FreeBSD: Capsicum.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD：Capsicum。
- en: 'MacOSX: Seatbelt.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MacOSX：Seatbelt。
- en: 'Windows: unclear what options exist.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：不清楚存在哪些选项。
- en: Native client uses these techniques, but only as a backup plan.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地客户端使用这些技术，但仅作为备用计划。
- en: Why not rely on OS sandboxing directly?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么不直接依赖操作系统的沙盒功能？
- en: Each OS may impose different, sometimes incompatible requirements.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作系统可能会施加不同的，有时是不兼容的要求。
- en: System calls to allocate memory, create threads, etc.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用以分配内存，创建线程等。
- en: Virtual memory layout (fixed-address shared libraries in Windows?).
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟内存布局（Windows中的固定地址共享库？）。
- en: OS kernel vulnerabilities are reasonably common.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统内核漏洞相当常见。
- en: Allows untrusted code to escape sandbox.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许不受信任的代码逃离沙盒。
- en: Not every OS might have a sufficient sandboxing mechanism.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非每个操作系统都可能具有足够的沙盒机制。
- en: E.g., unclear what to do on Windows, without a special kernel module.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，在Windows上，没有特殊的内核模块，不清楚该怎么做。
- en: 'Some sandboxing mechanisms require root: don''t want to run Chrome as root.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些沙盒机制需要root权限：不想以root身份运行Chrome。
- en: Hardware might have vulnerabilities (!).
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件可能存在漏洞（！）。
- en: Authors claim some instructions happen to hang the hardware.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者声称某些指令恰好会使硬件挂起。
- en: Would be unfortunate if visiting a web site could hang your computer.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果访问网站可能导致计算机挂起，那将是不幸的。
- en: '**Approach 2:** software fault isolation (Native Client''s primary sandboxing
    plan).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法2：**软件故障隔离（本地客户端的主要沙箱计划）。'
- en: Given an x86 binary to run in Native Client, verify that it's safe.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个要在本地客户端中运行的x86二进制文件，请验证其安全性。
- en: Verification involves checking each instruction in the binary.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证涉及检查二进制文件中的每条指令。
- en: 'Some instructions might be always safe: allow.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指令可能总是安全的：允许。
- en: Some instructions might be sometimes safe.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指令可能有时是安全的。
- en: Software fault isolation's approach is to require a check before these.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件故障隔离的方法是在这些指令之前要求进行检查。
- en: Must ensure the check is present at verification time.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须确保检查在验证时存在。
- en: 'Another option: insert the check through binary rewriting.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选项：通过二进制重写插入检查。
- en: Hard to do with x86, but might be more doable with higher-level lang.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在x86上很难做到，但在更高级别的语言中可能更容易。
- en: 'Some instructions might be not worth making safe: prohibit.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指令可能不值得安全化：禁止。
- en: After verifying, can safely run it in same process as other trusted code.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证后，可以安全地在与其他受信任代码相同的进程中运行它。
- en: Allow the sandbox to call into trusted "service runtime" code.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许沙箱调用受信任的“服务运行时”代码。
- en: Figure 2 from paper
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文中的图2
- en: What does safety mean for a Native Client module?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于本地客户端模块，安全性意味着什么？
- en: '**Goal #1:** does not execute any disallowed instructions (e.g., syscall, int).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标＃1：**不执行任何不允许的指令（例如，syscall，int）。'
- en: Ensures module does not perform any system calls.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保模块不执行任何系统调用。
- en: '**Goal #2:** does not access memory or execute code outside of module boundary.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标＃2：**不访问模块边界之外的内存或执行代码。'
- en: Ensures module does not corrupt service runtime data structures.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保模块不会破坏服务运行时数据结构。
- en: Ensures module does not jump into service runtime code, ala return-to-libc.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保模块不会跳转到服务运行时代码，如返回到libc。
- en: As described in paper, module code+data live within [0..256MB) virt addrs.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如论文所述，模块代码+数据位于[0..256MB)虚拟地址内。
- en: Need not populate entire 256MB of virtual address space.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要填充整个256MB的虚拟地址空间。
- en: Everything else should be protected from access by the NaCl module.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他所有内容应受到NaCl模块的保护。
- en: How to check if the module can execute a disallowed instruction?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何检查模块是否可以执行不允许的指令？
- en: 'Strawman: scan the executable, look for "int" or "syscall" opcodes.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 草案：扫描可执行文件，查找“int”或“syscall”操作码。
- en: If check passes, can start running code.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检查通过，可以开始运行代码。
- en: Of course, need to also mark all code as read-only.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，还需要将所有代码标记为只读。
- en: And all writable memory as non-executable.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并将所有可写内存标记为不可执行。
- en: '*Complication:* x86 has variable-length instructions.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂性：*x86具有可变长度指令。'
- en: '"int" and "syscall" instructions are 2 bytes long.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “int”和“syscall”指令长度为2字节。
- en: Other instructions could be anywhere from 1 to 15 bytes.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他指令可能在1到15个字节之间。
- en: 'Suppose program''s code contains the following bytes:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设程序的代码包含以下字节：
- en: '`25 CD 80 00 00`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25 CD 80 00 00`'
- en: 'If interpreted as an instruction starting from 25, it is a 5-byte instr:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从25开始解释为指令，它是一个5字节指令：
- en: '`AND %eax, $0x000080cd`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND %eax, $0x000080cd`'
- en: 'But if interpreted starting from CD, it''s a 2-byte instr:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但如果从CD开始解释，它是一个2字节指令：
- en: '`INT $0x80 # Linux syscall`'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INT $0x80 # Linux系统调用`'
- en: Could try looking for disallowed instructions at every offset..
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以尝试在每个偏移处查找不允许的指令。
- en: Likely will generate too many false alarms.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会产生太多误报。
- en: Real instructions may accidentally have some "disallowed" bytes.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实指令可能会意外包含一些“不允许”的字节。
- en: Reliable disassembly
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠的反汇编
- en: '**Plan:** ensure code executes only instructions that verifier knows about.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划：**确保代码只执行验证器知道的指令。'
- en: How can we guarantee this? Table 1 and Figure 3 in paper.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何保证这一点？请参考论文中的表1和图3。
- en: Scan forward through all instructions, starting at the beginning.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开头开始向前扫描所有指令。
- en: If we see a jump instruction, make sure it's jumping to address we saw.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们看到跳转指令，请确保它跳转到我们看到的地址。
- en: Easy to ensure for static jumps (constant addr).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态跳转（常量地址）很容易确保。
- en: Cannot ensure statically for **computed jumps** (jump to addr from register).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法静态确保**计算跳转**（从寄存器跳转到地址）。
- en: Computed jumps
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算跳转
- en: 'Idea is to rely on runtime instrumentation: added checks before the jump.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思路是依赖于运行时插装：在跳转之前添加检查。
- en: 'For computed jump to %eax, NaCl requires the following code:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算跳转到%eax，NaCl需要以下代码：
- en: '`AND $0xffffffe0, %eax # Clear last 4 bits (=> only jump to 32-byte boundary)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AND $0xffffffe0, %eax # 清除最后4位（=>只跳转到32字节边界）'
- en: JMP *%eax`
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JMP *%eax`
- en: This will ensure jumps go to multiples of 32 bytes. Why 32-byte?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将确保跳转到32字节的倍数。为什么是32字节？
- en: longer than the max. instruction length
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度超过最大指令长度
- en: power of 2
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2的幂
- en: need to fit trampoline (see below later) code
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要适应跳板（稍后见下文）代码
- en: not bigger because we don't want to waste space for single instruction jump
    targets
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会更大，因为我们不想为单个指令的跳转目标浪费空间。
- en: NaCl also requires that no instructions span a 32-byte boundary.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaCl还要求没有指令跨越32字节边界。
- en: Compiler's job is to ensure both of these rules.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器的工作是确保这两条规则。
- en: Replace every computed jump with the two-instruction sequence above.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用上述的两条指令序列替换每个计算跳转。
- en: Add NOP instructions if some other instruction might span 32-byte boundary.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其他指令可能跨越32字节边界，添加NOP指令。
- en: Add NOPs to pad to 32-byte multiple if next instr is a computed jump target.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一条指令是计算跳转目标，添加NOP以填充到32字节的倍数。
- en: Always possible because NOP instruction is just one byte.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是可能的，因为NOP指令只有一个字节。
- en: Verifier's job is to check these rules.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证器的工作是检查这些规则。
- en: During disassembly, make sure no instruction spans a 32-byte boundary.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在反汇编过程中，确保没有指令跨越32字节边界。
- en: For computed jumps, ensure it's in a two-instruction sequence as above.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算跳转，确保它在上述的两条指令序列中。
- en: What will this guarantee?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将保证什么？
- en: Verifier checked all instructions starting at 32-byte-multiple addresses.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证器检查了所有从32字节倍数地址开始的指令。
- en: Computed jumps can only go to 32-byte-multiple addresses.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算跳转只能到达32字节的倍数地址。
- en: What prevents the module from jumping past the AND, directly to the JMP?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是什么阻止模块跳过AND，直接到JMP？
- en: 'Pseudo-instruction: the NaCl jump instruction will never be compiled so that
    the `AND` part and the `JMP` part are *split* by a 32-byte boundary. Thus, you
    could never jump straight to the `JMP` part.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪指令：NaCl跳转指令永远不会被编译，以便`AND`部分和`JMP`部分被32字节边界*分隔*。因此，你永远无法直接跳转到`JMP`部分。
- en: How does NaCl deal with `RET` instructions?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaCl如何处理`RET`指令？
- en: Prohibited -- effectively a computed jump, with address stored on stack.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止 -- 实际上是一个计算跳转，地址存储在堆栈上。
- en: 'This is due to an **inherent race condition**: the `ret` instruction pops the
    return address off the stack and then jumps to it. NaCl could check the address
    on the stack before its popped, but there''s TOCTOU problem here: the address
    could be modified immediately after the check by another thread. This can happen
    because the return address is in memory, not in a register.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是由于一个**固有的竞争条件**：`ret`指令从堆栈中弹出返回地址，然后跳转到它。 NaCl可以在弹出之前检查堆栈上的地址，但这里存在TOCTOU问题：地址可能会在检查后立即被另一个线程修改。这可能发生是因为返回地址在内存中，而不在寄存器中。
- en: Instead, compiler must generate explicit POP + computed jump code.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，编译器必须生成显式的POP + 计算跳转代码。
- en: Why are the rules from Table 1 in the paper necessary?
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表1中的规则在论文中为什么是必要的？
- en: 'C1: executable code in memory is not writable.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C1：内存中的可执行代码不可写。
- en: 'C2: binary is statically linked at zero, code starts at 64K.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C2：二进制在零处静态链接，代码从64K开始。
- en: 'C3: all computed jumps use the two-instruction sequence above.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C3：所有计算跳转使用上述的两条指令序列。
- en: 'C4: binary is padded to a page boundary with one or more HLT instruction.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C4：二进制被填充到页面边界，其中包含一个或多个HLT指令。
- en: 'C5: no instructions, or our special two-instruction pair, can span 32 bytes.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C5：没有指令，或者我们特殊的两条指令对，可以跨越32字节。
- en: 'C6/C7: all jump targets reachable by fall-through disassembly from start.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C6/C7：从起始位置通过顺序反汇编可到达的所有跳转目标。
- en: '**Homework question:** what happens if verifier gets some instruction length
    wrong?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**作业问题：** 如果验证器得到了一些指令长度错误，会发生什么？'
- en: '**Answer:** Depending on where you offset into a seamingly innocent x86 instruction
    stream, you can get unexpectedly useful instructions out (In the BROP paper, we
    got a "pop rsi; ret;" from offsetting at 0x7 into the BROP gadget).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：** 取决于在x86指令流中的偏移位置，你可以得到意外有用的指令（在BROP论文中，我们从BROP小工具的0x7偏移处得到了一个"pop rsi;
    ret;"）。'
- en: If the checker incorrectly computes the length of an x86 instruction, then the
    attacker can exploit this. Suppose the checker computes `bad_len(i)` as the length
    of a certain instruction `i` at address `a`. The attacker, knowledgeable about
    x86, could write assembly code at address `a + bad_len(i)` that passes all the
    checks and seems harmless. This assembly code is what the NaCl checker would "see",
    given the instruction length bug. However, when the code is executed, the next
    instruction after instruction `i` would be at address `a + real_len(i)`. And,
    the attacker carefully crafted his code such that the instructions at and after
    `a + real_len(i)` do something useful. Like jumping outside the sandbox, or a
    syscall.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查器错误地计算 x86 指令的长度，那么攻击者可以利用这一点。假设检查器将 `bad_len(i)` 计算为地址 `a` 处某个指令 `i` 的长度。了解
    x86 的攻击者可以在地址 `a + bad_len(i)` 处编写汇编代码，通过所有检查并看似无害。这段汇编代码就是 NaCl 检查器会“看到”的内容，考虑到指令长度错误。然而，当代码执行时，指令
    `i` 之后的下一条指令将位于地址 `a + real_len(i)`。而且，攻击者精心设计了他的代码，使得在地址 `a + real_len(i)` 及之后的指令执行了一些有用的操作。比如跳出沙箱，或者进行系统调用。
- en: How to prevent NaCl module from jumping to 32-byte multiple outside its code?
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何防止 NaCl 模块在其代码之外跳转到 32 字节的倍数？
- en: Could use additional checks in the computed-jump sequence.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在计算跳转序列中使用额外的检查。
- en: '`AND $0x0fffffe0, %eax'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AND $0x0fffffe0, %eax`'
- en: JMP *%eax`
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JMP *%eax`'
- en: Why don't they use this approach?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么他们不使用这种方法？
- en: Longer instruction sequence for computed jumps.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算跳转的更长指令序列。
- en: Their sequence is `3+2=5` bytes, above sequence is `5+2=7` bytes.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的序列是 `3+2=5` 字节，上述序列是 `5+2=7` 字节。
- en: 'An alternative solution is pretty easy: segmentation.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种解决方案非常简单：分段。
- en: Segmentation
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分段
- en: x86 hardware provides "segments".
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86 硬件提供“段”。
- en: Each memory access is with respect to some "segment".
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次内存访问都是相对于某个“段”。
- en: Segment specifies base + size.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段指定基址 + 大小。
- en: 'Segments are specified by a segment selector: ptr into a segment table.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段由段选择器指定：指向段表的指针。
- en: '`%cs, %ds, %ss, %es, %fs, %gs`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%cs, %ds, %ss, %es, %fs, %gs`'
- en: Each instruction can specify what segment to use for accessing memory.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条指令都可以指定用于访问内存的段。
- en: Code always fetched using the `%cs` segment.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码始终使用 `%cs` 段获取。
- en: 'Address translation: (segment selector, addr) -> (segbase + addr % segsize).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址转换：（段选择器，地址）->（segbase + addr % segsize）。
- en: Typically, all segments have `base=0, size=max`, so segmentation is a no-op.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，所有段都具有 `base=0, size=max`，因此分段是一个无操作。
- en: 'Can change segments: in Linux, `modify_ldt()` system call.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以更改段：在 Linux 中，使用 `modify_ldt()` 系统调用。
- en: 'Can change segment selectors: just `MOV %ds`, etc.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以更改段选择器：只需 `MOV %ds` 等。
- en: 'Limiting code/data to module''s size:'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码/数据限制为模块的大小：
- en: Add a new segment with `offset=0, size=256MB.`
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的段，`offset=0, size=256MB`。
- en: Set all segment selectors to that segment.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有段选择器设置为该段。
- en: Modify verifier to reject any instructions that change segment selectors.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改验证器以拒绝任何更改段选择器的指令。
- en: Ensures all code and data accesses will be within [0..256MB).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有代码和数据访问都在 [0..256MB) 范围内。
- en: (NaCl actually seems to limit the code segment to the text section size.)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （实际上，NaCl 似乎将代码段限制为文本部分大小。）
- en: What would be required to run Native Client on a system without segmentation?
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在没有分段的系统上运行 Native Client 需要什么条件？
- en: For example, AMD/Intel decided to drop segment limits in their 64-bit CPUs.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，AMD/Intel 决定在它们的 64 位 CPU 中取消段限制。
- en: 'One practical possibility: run in 32-bit mode.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实际的可能性：在 32 位模式下运行。
- en: AMD/Intel CPUs still support segment limits in 32-bit mode.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD/Intel CPU 在 32 位模式下仍支持段限制。
- en: Can run in 32-bit mode even on a 64-bit OS.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在 64 位操作系统上也可以在 32 位模式下运行。
- en: Would have to change the computed-jump code to limit target to 256MB.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不得不更改计算跳转代码以将目标限制为 256MB。
- en: Would have to add runtime instrumentation to each memory read/write.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不得不对每个内存读/写添加运行时检测。
- en: See the paper in additional references below for more details.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅下面的附加参考文献中的论文。
- en: Why doesn't Native Client support exceptions for modules?
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么 Native Client 不支持模块的异常？
- en: 'What if module triggers hardware exception: null ptr, divide-by-zero, etc.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模块触发硬件异常：空指针，除零等。
- en: OS kernel needs to deliver exception (as a signal) to process.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统内核需要将异常（作为信号）传递给进程。
- en: But Native Client runs with an unusual stack pointer/segment selector `%ss`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但 Native Client 使用不寻常的堆栈指针/段选择器 `%ss` 运行。
- en: So if the OS tried to deliver the exception, it would terminate the program
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，如果操作系统尝试传递异常，它将终止程序。
- en: Some OS kernels refuse to deliver signals in this situation.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些操作系统内核在这种情况下拒绝传递信号。
- en: NaCl's solution is to prohibit hardware exceptions altogether.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaCl的解决方案是完全禁止硬件异常。
- en: 'Language-level exceptions (e.g., C++) do not involve hardware: no problem.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言级别的异常（例如，C++）不涉及硬件：没有问题。
- en: What would happen if a NaCl module had a buffer overflow?
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果NaCl模块发生缓冲区溢出会发生什么？
- en: Any computed call (function pointer, return address) has to use 2-instr jump.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何计算调用（函数指针，返回地址）必须使用2指令跳转。
- en: As a result, can only jump to validated code in the module's region.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，只能跳转到模块区域中经过验证的代码。
- en: Buffer overflows might allow attacker to take over module.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区溢出可能允许攻击者接管模块。
- en: However, can't escape NaCl's sandbox.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，无法逃脱NaCl的沙箱。
- en: Limitations of the original NaCl design?
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始NaCl设计的局限性？
- en: 'Static code: no JIT, no shared libraries.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码：无JIT，无共享库。
- en: Dynamic code supported in recent versions (see additional refs at the end).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近期版本支持动态代码（请参考结尾的附加参考资料）。
- en: Invoking trusted code from sandbox
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从沙箱调用受信任的代码
- en: Short code sequences that transition to/from sandbox located in [4KB..64KB).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短代码序列，过渡到/从位于[4KB..64KB)的沙箱中。
- en: '**Trampoline** undoes the sandbox, enters trusted code.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳板**取消沙箱，进入受信任的代码。'
- en: Starts at a 32-byte multiple boundary.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从32字节的倍数边界开始。
- en: Loads unlimited segment into `%cs, %ds` segment selectors.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将无限段加载到`%cs, %ds`段选择器中。
- en: Jumps to trusted code that lives above 256MB.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转到位于256MB以上的受信任代码。
- en: '*Slightly tricky:* must ensure trampoline fits in 32 bytes.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*稍微棘手：*必须确保跳板适合32字节。'
- en: (Otherwise, module could jump into middle of trampoline code..)
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （否则，模块可能会跳转到跳板代码的中间..）
- en: 'Trusted code first switches to a different stack: why?'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受信任的代码首先切换到不同的堆栈：为什么？
- en: the NaCl module stack is incapable of receiving exceptions, and the library
    code called by the trampoline could get exceptions
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaCl模块堆栈无法接收异常，并且由跳板调用的库代码可能会出现异常。
- en: also, in the paper they mention this new stack, which is per-thread will reside
    outside the untrusted address space, so as to protect it from **attacks by other
    NaCl module threads**!
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，在论文中提到这个新堆栈，它是每个线程的，将驻留在不受信任的地址空间之外，以保护它免受其他NaCl模块线程的**攻击**！
- en: Subsequently, trusted code has to re-load other segment selectors.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后，受信任的代码必须重新加载其他段选择器。
- en: '**Springboard** (re-)enters the sandbox on return or initial start.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹簧板**（重新）在返回或初始启动时重新进入沙箱。'
- en: Springboard slots (32-byte multiples) start with `HLT` (halt) instruction.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹簧板槽（32字节的倍数）以`HLT`（停止）指令开始。
- en: Prevents computed jumps into springboard by module code.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止模块代码跳转到弹簧板。
- en: Re-set segment selectors, jump to a particular address in NaCl module.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新设置段选择器，在NaCl模块中跳转到特定地址。
- en: What's provided by the service runtime? (NaCl's "system call" equivalent)
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务运行时提供了什么？（NaCl的“系统调用”等效）
- en: 'Memory allocation: sbrk/mmap.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配：sbrk/mmap。
- en: 'Thread operations: create, etc.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程操作：创建等。
- en: 'IPC: initially with Javascript code on page that started this NaCl program.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC：最初与启动此NaCl程序的页面上的Javascript代码。
- en: 'Browser interface via NPAPI: DOM access, open URLs, user input, ..'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器接口通过NPAPI：DOM访问，打开URL，用户输入，..
- en: 'No networking: can use Javascript to access network according to SOP.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有网络：可以使用Javascript根据SOP访问网络。
- en: How secure is Native Client?
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Native Client有多安全？
- en: 'List of attack surfaces: start of section 2.3.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击面列表：开始于第2.3节的开头。
- en: 'Inner sandbox: validator has to be correct (had some tricky bugs!).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部沙箱：验证器必须正确（有一些棘手的错误！）。
- en: 'Outer sandbox: OS-dependent plan.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部沙箱：依赖于操作系统的计划。
- en: On Linux, probably seccomp.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上，可能是seccomp。
- en: On FreeBSD (if NaCl supported it), Capsicum would make sense.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FreeBSD上（如果NaCl支持），Capsicum会很有意义。
- en: Why the outer sandbox?
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么外部沙箱？
- en: Possible bugs in the inner sandbox.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部沙箱可能存在漏洞。
- en: What could an adversary do if they compromise the inner sandbox?
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对内部沙箱进行了妥协，对手会做什么？
- en: Exploit CPU bugs.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用CPU漏洞。
- en: Exploit OS kernel bugs.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用OS内核漏洞。
- en: Exploit bugs in other processes communicating with the sandbox proc.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用其他进程中的漏洞与沙箱进程通信。
- en: 'Service runtime: initial loader, runtime trampoline interfaces.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务运行时：初始加载程序，运行时跳板接口。
- en: 'Inter-module communication (IMC) interface + NPAPI: complex code, can (and
    did) have bugs.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块间通信（IMC）接口 + NPAPI：复杂的代码，可能（并且确实）存在错误。
- en: How well does it perform?
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它的性能如何？
- en: CPU overhead seems to be dominated by NaCl's code alignment requirements.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU开销似乎主要受NaCl的代码对齐要求的影响。
- en: Larger instruction cache footprint.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大的指令缓存占用。
- en: But for some applications, NaCl's alignment works better than gcc's.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但对于某些应用程序，NaCl的对齐方式比gcc更好。
- en: Minimal overhead for added checks on computed jumps.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算跳转的附加检查，开销最小。
- en: Call-into-service-runtime performance seems comparable to Linux syscalls.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用服务运行时的性能似乎与Linux系统调用相当。
- en: How hard is it to port code to NaCl?
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码移植到NaCl有多难？
- en: 'For computational things, seems straightforward: 20 LoC change for H.264.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算性的事物，似乎很简单：H.264只需改动20行代码。
- en: For code that interacts with system (syscalls, etc), need to change them.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于与系统交互的代码（系统调用等），需要进行更改。
- en: E.g., Bullet physics simulator (section 4.4).
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，Bullet物理模拟器（第4.4节）。
- en: Additional references
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他参考资料
- en: '[Native Client for 64-bit x86 and for ARM.](http://static.usenix.org/events/sec10/tech/full_papers/Sehr.pdf)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[本地客户端适用于64位x86和ARM。](http://static.usenix.org/events/sec10/tech/full_papers/Sehr.pdf)'
- en: '[Native Client for runtime-generated code (JIT).](http://research.google.com/pubs/archive/37204.pdf)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[本地客户端用于运行时生成的代码（JIT）。](http://research.google.com/pubs/archive/37204.pdf)'
- en: '[Native Client without hardware dependence.](http://css.csail.mit.edu/6.858/2012/readings/pnacl.pdf)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无硬件依赖的本地客户端。](http://css.csail.mit.edu/6.858/2012/readings/pnacl.pdf)'
- en: 'Other software fault isolation systems w/ fine-grained memory access control:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他具有细粒度内存访问控制的软件故障隔离系统：
- en: '[XFI](http://css.csail.mit.edu/6.858/2012/readings/xfi.pdf)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[XFI](http://css.csail.mit.edu/6.858/2012/readings/xfi.pdf)'
- en: '[BGI](http://research.microsoft.com/pubs/101332/bgi-sosp.pdf)'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[BGI](http://research.microsoft.com/pubs/101332/bgi-sosp.pdf)'
- en: '[Formally verifying the validator.](http://www.cse.lehigh.edu/~gtan/paper/rocksalt.pdf)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正式验证验证器。](http://www.cse.lehigh.edu/~gtan/paper/rocksalt.pdf)'
