- en: P30：Midterm Exam Solutions - 哈库那玛塔塔i - BV1R4411u7dt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P30：期中考试解答 - 哈库那玛塔塔i - BV1R4411u7dt
- en: Hello students。 This is the video where I'm going to run through all the problems
    in the midterm exam and go through just the quick solutions for each of them。
    Okay， so first on question one， we have this dtd on city info。 And so just really
    quickly in an XML document that conforms to this dtd。 What are the minimum and
    maximum possible number of mayor elements。 Okay， so we look through here。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 同学们好，这是我将演示期中考试所有问题并快速解答每个问题的视频。好的，第一个问题，我们有这个关于城市信息的DTD。所以非常快速地，在一个符合这个DTD的XML文档中，市长元素的最小和最大可能数量是多少？好的，我们来看一下。
- en: we see that we have our route elements city info which has one instance of government。
    And then each government has one instance of mayor。 And so we see that in this
    case we will have exactly one one mayor because mayor is never an optional。 An
    optional element nor is it possible to have more than one mayor。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们有我们的路由元素，城市信息，其中有一个政府实例。然后每个政府都有一个市长实例。所以我们看到在这种情况下，我们将有恰好一个市长，因为市长从来不是可选的元素，也不可能有多个市长。
- en: So the correct answer here is minimum number is one and maximum number is one。
    Okay。 moving on to the second question。 What are the minimum and maximum possible
    number of library elements。 Okay， so we look through， we see that library is from
    neighborhood。 And we see that we have in city info neighborhood plus which means
    that we will have one or two。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的正确答案是最小值为1，最大值为1。好的，继续下一个问题。图书馆元素的最小和最大可能数量是多少？好的，我们看一下，我们看到图书馆是来自社区的。我们看到在城市信息中，社区是可选的，这意味着我们会有1个或2个。
- en: We have one or more neighborhoods。 And we see here that each neighborhood optionally
    has either a library or a book shop。 So in this case， since libraries are optional
    as we can tell by this question mark。 that means we could have zero libraries。
    But since we can have any number of neighborhoods since we have neighborhood plus
    each one of those neighborhoods could have a library so we could also have any
    number of libraries。 So the correct answer here is we could have at minimum zero
    libraries and at maximum any number of libraries。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个或多个社区。我们看到每个社区可选择性地有一个图书馆或书店。所以在这种情况下，由于图书馆是可选的，正如我们从这个问号中可以看出，这意味着我们可以有零个图书馆。但是由于我们可以有任意数量的社区，而每个社区都可以有一个图书馆，因此我们也可以有任意数量的图书馆。所以正确答案是，最少可以有零个图书馆，最多可以有任意数量的图书馆。
- en: Okay， let's move on to the second set of questions。 So here we have an XML schema。
    And this is just on passenger info， I guess for a plane or a train。 In an XML
    document that conforms to this XML schema。 What are the minimum and maximum possible
    number of name elements。 Okay。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续下一个问题集。所以这里我们有一个XML模式。这只是关于乘客信息，我猜是飞机或火车的。对于一个符合这个XML模式的XML文档，名字元素的最小和最大可能数量是多少？好的。
- en: so we see that we have our sequence of elements here。 And the name element is
    right here。 And so this is not inside of a choice。 And we don't specify like a
    minimum number of occurrences。 So this element has to appear。 But we are specified
    a maximum number of occurrences at two。 So it has to appear at least once and
    it can appear at most twice。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们看到这里有一个元素序列。名字元素就在这里。所以这不在选择内。我们没有指定最小出现次数。所以这个元素必须至少出现一次。但我们指定了最大出现次数是二。所以它必须至少出现一次，最多可以出现两次。
- en: So the correct answer is this third one， minimum one， maximum two。 Okay。 and
    now in an XML document that conforms to this schema。 what are the minimum and
    maximum possible number of snack elements。 Okay。 so we see that snack occurs inside
    of this excess choice where we will have either meal or snack because that's what
    choice does。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以正确答案是第三个，最小值是1，最大值是2。好的，现在在一个符合这个模式的XML文档中，零食元素的最小和最大可能数量是多少？好的，我们看到零食出现在这个选择集内部，在这里我们会有餐点或零食，因为选择集就是这样工作的。
- en: So it's possible that we have no snacks。 So the minimum is zero。 But we are
    also given a maximum occurrences of two on snack。 So we could have up to two snacks。
    So that makes the minimum zero and the maximum two。 Alright。 and now we can move
    on to the next set of questions， which is on some relational algebra。 Okay。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以可能我们没有零食。最小值是零。但我们也被给定了零食的最大出现次数是两个。所以我们最多可以有两个零食。所以最小值是零，最大值是两个。好的，现在我们可以继续下一个问题集，这是关于一些关系代数的。好的。
- en: so consider the following three relations where we have cars with a model year
    serial number。 which is the key and the color。 Makes relation with the maker and
    model model being the key and owns where owner and serial together specify a key。
    Okay， so consider the following relational algebra expression。 We have projecting
    owner out of owns natural join with select color equals red of car natural join
    select maker equals Toyota makes。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，考虑以下三个关系，其中有一个汽车表，包含车型年份、序列号（作为主键）和颜色；一个制造商表，包含制造商和型号（其中型号是主键）；还有一个拥有关系，其中车主和序列号共同作为主键。好吧，所以，考虑下面的关系代数表达式。我们有投影车主从
    owns，自然连接选择颜色为红色的汽车，自然连接选择制造商为丰田的制造商。
- en: Okay， so which of the following phrases describes what this expression computes。
    Okay。 so doing this natural join with owns car and makes and projecting out owner
    will give you the names of all owners of cars and then these selections will specify
    what type of car that is。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，下面哪个选项描述了这个表达式计算的结果？好的。所以，进行这个与拥有表、汽车表和制造商表的自然连接，并投影出车主，将会给出所有车主的姓名，然后这些选择条件会指定该车的类型。
- en: So selecting color is red means that we will only have owners of red cars and
    selecting maker is Toyota will mean that we only have cars made by Toyota。 So
    this computes all owners of red car made by Toyota。 And so that is option A。 And
    then we move on to the next question， which asks about this relational algebra
    expression。 Okay。 so projecting owner out of selecting owner equals own O two
    and serial is not S two of the cross product of owns with itself with some attributes
    renamed。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，选择颜色为红色意味着我们只会得到红色车主，而选择制造商为丰田则意味着我们只会得到丰田制造的汽车。这样，我们就得到了所有拥有丰田红色汽车的车主。这个就是选项
    A。然后我们继续看下一个问题，问的是关于这个关系代数表达式的问题。好吧。所以，投影出所有车主，选择车主等于 own O2，且序列号不等于 S2，跨乘 owns
    自身，并且对某些属性进行重命名。
- en: Okay， so this is a self join condition where we are doing this Cartesian product
    of owns with itself and checking that the owners are the same。 So that's going
    to give you all all pairings of cars that an owner owns。 And we're also checking
    that serial the serial numbers don't match。 So that's going to give you all pairings
    of cars that have the same owner， but are a different car。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个自连接条件，我们正在执行 owns 自身的笛卡尔积，并检查车主是否相同。这样就能得到所有同一车主拥有的汽车配对。同时我们还在检查序列号是否不同。因此，这将给出所有同一车主拥有但不同的汽车配对。
- en: And we're projecting out owner。 So that computes then is just all people who
    own at least two cars。 And so we see， okay， so all owners of more than one car。
    That's the third option。 And that's that's the correct option。 So， great moving
    on。 which of the following relational algebra expressions computes all companies
    that made at least one car in the year 2010。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在投影出车主。所以，计算的结果就是所有至少拥有两辆车的人。因此，我们可以看到，所有拥有超过一辆车的车主。这是第三个选项。这就是正确的选项。所以，太好了，继续下一个问题。下面哪个关系代数表达式计算了在
    2010 年至少制造一辆车的所有公司？
- en: Okay， so what we need to be doing here is doing。 Let's see。 we need to have
    the maker field and the year field。 So we need a natural join from car and makes
    in order to get this so that will get us all all maker model year serial color
    pairs for every car。 And from that， we will just need to select that the year
    is 2010 and then pull out the maker。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们需要做的就是。让我们看看。我们需要获取制造商字段和年份字段。因此，我们需要对汽车表和制造商表进行自然连接，以便得到这些数据，这样就能得到每辆车的制造商、型号、年份、序列号和颜色组合。然后，从中，我们只需选择年份为
    2010 的记录，并投影出制造商。
- en: So this should be pretty straightforward。 Hopefully one of these options does
    that directly。 Indeed。 it's this one where we are selecting that the year is 2010
    from car。 So that will get us all cars made in the year 2010 and then doing a
    natural join with makes will get us the maker of that car and then we project
    out the maker。 And so that is option B。 So that's good。 And then we have this
    one last question。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应该很简单。希望这些选项中有一个直接实现了这一点。确实是这个选项，我们从汽车表中选择年份为 2010 的记录。这样我们就能得到所有2010年制造的汽车，然后通过与制造商表进行自然连接，我们就能得到这些车的制造商，最后我们投影出制造商。这个就是选项
    B。所以，这个很好。然后我们有最后一个问题。
- en: which of the following relational algebra expressions computes the latest year
    of any car in the database。 Okay， so what we're doing here is basically just finding
    the max year and if we remember correctly year is in in the cars relation。 So
    we just want to find the maximum year across all tuples in the database。 And I've
    gone over this in office hours before， but the way that you find maximum in relational
    algebra is you find everything that is less than something else。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个关系代数表达式计算数据库中任何一辆车的最新年份？好吧，我们要做的基本上就是找到最大的年份，如果我们没记错的话，年份是存在于 cars 关系中的。所以我们只需要找到数据库中所有元组的最大年份。之前我在办公时间讲过这个问题，关系代数中找到最大值的方法是找出所有小于某个值的内容。
- en: And then you take the set of everything and subtract out everything that's less
    than something else。 So hopefully that makes sense， but it turns out that the
    query that does this is this one is the last option where we are doing this cross
    product of car with itself and picking out all cars or the set of all years that
    are less than some other year。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你取出所有的集合，并从中减去所有小于某个值的内容。所以希望这能让大家理解，结果表明执行此操作的查询是最后一个选项，其中我们对 car 进行自乘积并挑选出所有小于其他年份的所有汽车或所有年份的集合。
- en: And then when we subtract that from the set of all years， we get the maximum
    year。 And so that is the correct option。 All right， moving on to the next set
    of questions。 This set of questions is about SQL computations。 So first question。
    So we need to decide if two queries are equivalent。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们从所有年份的集合中减去这些结果时，我们就得到了最大年份。所以这是正确的选项。好的，接下来进入下一组问题。这组问题是关于 SQL 计算的。第一个问题，我们需要判断两个查询是否等价。
- en: meaning that they are guaranteed to produce the same answer on all possible
    sticks of the database。 And the database is that we have non empty relations are
    an S with attributes A and B。 Now。 no null values。 A is a key for both relations
    and B is an attribute。 but not a key for both relations。 All right。 And so first
    set of queries here is select a from R and select R dot A from R from the join
    of R and S where the theta join of R and S where。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着它们保证在数据库的所有可能实例上返回相同的结果。而我们有的数据库包含两个非空的关系 R 和 S，具有属性 A 和 B。现在，没有空值。A 是两个关系的主键，而
    B 是一个属性，但不是两个关系的主键。好的。接下来是第一组查询，选择 R 中的 A，和选择 R dot A 从 R 和 S 的连接中，连接条件是 R 和 S
    的 theta 连接。
- en: R A equals S A。 Okay， so I hope it's pretty obvious here that these queries
    are not equivalent。 And just as a quick example database to demonstrate that just
    think about this where we have a relation of the other。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: R A 等于 S A。好吧，所以我希望现在大家能够明显看出这些查询是不等价的。作为一个快速的例子，假设我们有另一个关系来演示这一点。
- en: '![](img/e81549c43c3763b9bb711297a6190492_1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e81549c43c3763b9bb711297a6190492_1.png)'
- en: And so in this case， selecting a from R will give us one and selecting R dot
    A from R joined with S on the A attribute will give us an empty result。 So hopefully
    that makes sense。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，选择 R 中的 A 会给我们一个结果，而选择 R 中的 R dot A 与 S 在 A 属性上连接后的结果则会返回一个空结果。所以希望这能让大家理解。
- en: '![](img/e81549c43c3763b9bb711297a6190492_3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e81549c43c3763b9bb711297a6190492_3.png)'
- en: So these queries are not equivalent。 Now question two。 We have select max of
    A from R and select A from R where A is greater than or equal to all select A
    from R。 Okay， so hopefully it's obvious here that these are equivalent。 So this
    will return us a single number， the highest A value in R。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些查询是不等价的。现在第二个问题。我们有 select max of A from R 和 select A from R where A 大于或等于所有
    select A from R。好的，希望这里显而易见的是这些查询是等价的。所以这将返回一个数字，即 R 中最大的 A 值。
- en: And this will return us an A value any time that A is greater than or equal
    to all other A values in R。 And so in a different database， this could possibly
    return us more than one number。 whereas this would only return us one number。
    But since A is a key on the relation R。 that means that each A value occurs only
    once。 And so in this case。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个 A 值，每当 A 大于或等于 R 中所有其他 A 值时。所以在另一个数据库中，这可能返回多个数字，而这个查询只会返回一个数字。但由于 A
    是关系 R 的主键，这意味着每个 A 值仅出现一次。因此，在这种情况下。
- en: it's impossible to have any duplicates from query to。 So indeed。 they will return
    exactly the same result。 So these two are equivalent。 All right。 now moving on
    to this third set of queries。 Select B from R and select B from R group by B。
    Okay。 so these queries are not equivalent。 And the reason for that is we won't
    get like the same B values from both of these。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查询二是不可能有任何重复项的。所以确实，它们会返回完全相同的结果。所以这两个查询是等效的。好了，现在继续看第三组查询。选择B从R，和选择B从R并按B分组。好吧，这些查询是不等效的。原因是我们不会从这两个查询中获得相同的B值。
- en: But this one will group by the B values and so they will have every B value
    that's the same together in the result next to each other。 Whereas the first query
    which just selects B from R will give us all the B values。 but they could be in
    any sort of order。 So these two queries are not equivalent。 All right。 and just
    one more of these SQL problems。 Decide if the two queries are equivalent where
    we have select a from R where exists select star from S where S equals R dot A。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个会按B值分组，因此它们会将所有相同的B值聚集在结果中，紧挨在一起。而第一个查询，只是从R中选择B，它会给我们所有的B值，但它们的顺序可能是任意的。所以这两个查询是不同的。好了，再来看一个SQL问题。判断这两个查询是否等效，查询为选择a从R，其中存在选择星号从S，其中S等于R.A。
- en: And select a from R intersect select a from S。 All right。 so what this first
    query is doing is getting any a value from R where that a value appears as。 An
    a value in S because the exists just checks is that does this select statement
    give us any values。 And so that's all A's from R where that A also appears in
    S。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择来自R的a，交集选择来自S的a。好了，首先这个查询的作用是从R中获取任何a值，其中这个a值也出现在S中，因为`exists`只是检查这个选择语句是否给我们提供了任何值。所以这就是从R中选择所有的a值，其中a也出现在S中。
- en: And then select a from R where select a from R intersect select a from S。 That
    gives us the exact same thing that will give us all a values from R that also
    appear in S。 And since a is a key， this first operation doesn't have any duplicates。
    And since this is an intersect operation intersect is by default and SQL done
    as a set operation。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择a从R，其中选择a从R交集选择a从S。这会给我们完全相同的结果，它会返回所有来自R且也出现在S中的a值。由于a是主键，第一个操作不会有任何重复项。由于这是一个交集操作，交集在SQL中默认作为集合操作执行。
- en: So that won't have any duplicates。 So indeed these queries are equivalent。 All
    right。 so moving along。 To this question five。 So the database class portal uses
    relational database management system to manage student assignment scores where
    each assignment submission is recorded in the scores table where we have the student
    ID。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个查询不会有任何重复项。确实，这些查询是等效的。好了，继续进行下一个问题。到问题五。数据库类门户使用关系数据库管理系统来管理学生作业成绩，其中每次作业提交都会记录在scores表中，其中包含学生ID。
- en: the assignment ID， a timestamp and the score。 And so the only minimal key here
    is the student ID assignment ID and timestamp altogether。 And that's because students
    as we know are allowed to submit assignments multiple times。 And so which of the
    following SQL statements returns the student IDs of all the students who have
    submitted some assignment more than 10 times。 Okay， so let's just look at these
    queries one by one。 Okay。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作业ID、时间戳和分数。因此，这里的最小关键字是学生ID、作业ID和时间戳三者合在一起。因为我们知道，学生允许多次提交作业。所以，以下哪个SQL语句会返回所有提交某个作业超过10次的学生ID？好了，让我们一个一个地看这些查询。
- en: so select distinct SID from scores where count stars greater than 10。 So this
    is incorrect because we typically don't have count star in our where clause that's
    not correct。 Let's see。 This is similarly wrong。 This last one is because we have
    the count in the where。 And actually also this one has the count in the where
    so let's let's hope that this third statement is correct。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以选择不同的SID来自scores，其中count stars大于10。这个是错误的，因为通常我们在where子句中不会有count star，这样是不对的。再看一下，这个也是错的。最后一个是因为我们在where中有count。实际上这个查询也在where中有count，所以让我们希望第三个语句是正确的。
- en: And I think it is it's select distinct student ID from scores group by SID。
    AID having count star greater than 10。 Yeah， that's indeed correct。 What this
    will do is count up every time that at each student ID assignment ID pairing occurs
    in the scores table and filter out all of them if if they occur fewer than 10
    times。 And so that is correct。 That's exactly what we want。 So cool。 That's good。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为它是`select distinct student ID from scores group by SID，AID having count star
    greater than 10`。是的，这确实是正确的。这样做会统计每次在`score`表中出现的学生ID和作业ID的配对，并且如果它们出现的次数少于10次，就会过滤掉它们。所以这是正确的。这正是我们想要的。真棒。很好。
- en: And moving on to question six。 We have this relation R with attributes A， B，
    C， D， and E。 And there are three functional dependencies that A functionally determines
    D。 C functionally determines A， B， and D， B functionally determines E。 Okay。 so
    which of the following functional dependencies is also guaranteed to be satisfied
    by R？ Okay。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第六个问题。我们有这个关系R，具有属性A，B，C，D和E。并且有三个函数依赖，A决定D，C决定A，B和D，B决定E。好吧，接下来，以下哪个函数依赖也一定会被R满足？好吧。
- en: so let's look at these one by one。 So C functionally determines E。 Let's see
    if that's true。 So we have that C gives us A， B， and so from C we get A and from
    A we get D。 So C gives us A， B。 and D since we have both B and D from C that also
    gives us E。 So this first one is correct。 So we're actually done with that question。
    All right。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们逐一查看这些。那么C函数决定E。我们来看这是否成立。我们有C给我们A，B，所以从C我们得到A，然后从A我们得到D。于是C给我们A，B，D，因为我们从C得到了B和D，这也给了我们E。所以这个第一个是正确的。这样我们就完成了这个问题。好吧。
- en: Now we have the same relation but with different functional dependencies。 We
    have A implies B， B。 C implies E， and D implies A。 Which one of the following
    is the key for R？ Well。 let's look at these one by one again。 So with AC from
    A we will get B and then we'll have B， C。 which will give us E。 But then we have
    no way to get D because D never appears on the right side of one of these functional
    dependencies。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有相同的关系，但是有不同的函数依赖。我们有A决定B，B，C决定E，D决定A。以下哪个是R的键？好吧，让我们再次逐一检查这些。那么有了AC，从A我们将得到B，然后我们有B，C，这将给我们E。但接下来我们没有办法得到D，因为D从未出现在这些函数依赖的右侧。
- en: So we know that we're going to need D in our key。 So AD。 well that's somewhat
    promising since it has D but， okay， so from A we get D。 And then we don't have
    C so we can't get E。 So that's a problem。 BC。 well we know that we need D in the
    key since D never appears on the right hand side。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道我们需要D在我们的键中。那么AD，嗯，这有点希望，因为它有D，但是，好的，从A我们得到D。然后我们没有C，所以无法得到E。这是个问题。BC。好吧，我们知道我们需要D在键中，因为D从未出现在右侧。
- en: So we know that's not going to be right。 So this CD should be correct。 If we
    have CD then we get from D we get A and so we have， and then from A we get B。
    So we have C， D。 A， and B and then we have B and C since C is in the key and we
    get E。 So that gets us all attributes。 So this last one is correct。 All right。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道那是不对的。那么这个CD应该是正确的。如果我们有CD，那么从D我们可以得到A，然后我们就有了，接着从A我们可以得到B。所以我们有C，D，A和B，然后我们有B和C，因为C在键中，我们可以得到E。这样我们得到了所有属性。因此，最后一个是正确的。好吧。
- en: Now here's an instance of a relation， R， A， B， C。 Just one of the following
    MBDs is satisfied by this instance of R on which one。 All right。 So MBDs are one
    of the， one of the trickiest concepts in this entire class。 So we'll step through
    this looking at one answer at a time。 So C multi-determined B。 Let's see if that's
    correct。 So recall that what the definition of multi-valued dependency means is
    that any time the。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里有一个关系实例，R，A，B，C。以下哪个MBD由这个R实例满足？哪个是？好的，MBD是这个课程中最棘手的概念之一。所以我们将逐个查看答案。C多值决定B。我们来看这是否正确。所以回想一下，多值依赖的定义是，每次。
- en: all of the attributes in the left hand side agree then， there is a tuple that
    has the， the， the。 the same attributes for every pair of tuples where the attributes
    in the left hand side agree。 There's a third tuple， guaranteed to be a third tuple
    that has the attributes on the left hand side from the first tuple。 the attributes
    on the right hand side from the first tuple and the attributes from everything
    that's neither the left side nor the right side from the second tuple。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左边的所有属性一致，那么就有一个元组，它具有左边每对元组的相同属性。在这些元组的左边属性一致的每一对中，都有一个第三个元组，保证存在一个第三个元组，它有第一个元组的左边属性，第一个元组的右边属性，以及第二个元组中既不属于左边也不属于右边的所有属性。
- en: And so let's just look through and decide。 So with C multi-determined B we have
    these one one tuples and those look good since whenever we only have these two
    where we have a one as。 as the C and we have two's in the B attribute for both
    of those。 So those are going to be fine where we might run into problems is here
    with these C equals three tuples。 So since we have three as the C value for both
    of these tuples。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们就看看并决定。对于C多重确定B，我们有这些一、一的元组，看起来没问题，因为当我们只有这两个元组时，它们的C值是1，而B属性的值都是2。所以这些元组是正确的，而我们可能遇到问题的是这些C值为三的元组。因为我们有这两个元组的C值都是三。
- en: what we need is we need to have a tuple that has three， two， five and three，
    one， five。 So we're good with those two， but if we look at this last tuple， we
    need to have。 if we compare this four， two， three， tuple with this five， one，
    three， tuple。 What C multi-determined B would mean would mean that we have a three，
    one， a three， one， four tuple。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个包含三、二、五和三、一、五的元组。所以这两个元组是正确的，但如果我们看看最后一个元组，我们需要比较这个四、二、三元组和这个五、一、三元组。C多重确定B的意思是我们需要有一个三、一、三、一、四的元组。
- en: which does not occur in this relation。 So this answer is incorrect。 Now let's
    look at B multi-determined C。 Okay， so if that were true， then actually this may
    be true。 So what that says is whenever we have B values that are equal。 so we
    have B equals two in several places here。 That means that we need to have a two，
    one。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关系中没有发生的情况。所以这个答案是错误的。现在我们来看B多重确定C。好的，如果这是真的，那么实际上这个也可能是真的。所以这意味着每当我们有相等的B值时。我们在这里的几个地方都有B值为二。这就意味着我们需要有一个二、一的元组。
- en: five tuple， which we have here two， one and five， and we also need to have a
    two， three， four。 which we have down here two， three， four。 All right， so that's
    good。 Indeed。 it looks like we have all of the permutations here。 So B multi-determined
    C indeed is the correct answer。 This is satisfied by this relation。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 五元组，我们在这里有两个、一和五，我们也需要一个二、三、四元组。我们在下面也有这个二、三、四元组。好吧，这很好。确实，似乎我们已经涵盖了所有排列。因此，B多重确定C确实是正确答案。这个关系满足这个条件。
- en: And you can just step through all of the possible permutations to convince yourself
    of that。 What I will do is go through these other two and explain why they're
    not correct。 So C multi-determined A。 That doesn't work because we would need
    to have a -- okay， so three --。 Since we have this five， one， three， tuple and
    this four， two， three， tuple。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遍历所有可能的排列，确保自己相信这个结论。我接下来会解释其他两个为什么不正确。首先是C多重确定A。这个不成立，因为我们需要有一个——好吧，三——。因为我们有这个五、一、三的元组和这个四、二、三的元组。
- en: we have their C values equal。 So that means we need to have a three， five， two，
    tuple。 which we actually have。 And also a three， four， a three， four， one， tuple，
    which we don't have。 So that three， four， one does not exist。 And so that's why
    this answer is incorrect。 Okay。 and then with A multi-determines B， we have this
    pair of tuples。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有它们的C值相等。所以这意味着我们需要一个三元组、五元组、二元组的组合。实际上我们有这些。但同时也需要一个三元组、四元组、三元组、四元组、一元组的组合，而我们没有这个。因此，三元组、四元组、一元组并不存在。所以这就是为什么这个答案是错误的。好的，然后我们来看A多重确定B，我们有这一对元组。
- en: which implies that we need to have a five， one， one， tuple。 Five， one， one would
    need to happen。 And that doesn't happen anywhere。 And so that's why this answer
    is incorrect。 Okay， so again。 the answer to this question is B multi-determines
    C。 And you can step through and convince yourself completely of that if you're
    not already convinced。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要有一个五、一、一的元组。五、一、一必须存在。但在任何地方都没有出现。因此这就是为什么这个答案是错误的。好的，再次强调，这个问题的答案是B多重确定C。如果你还没有确信，你可以一步一步地验证，直到完全相信。
- en: All right， and moving on to question nine。 So consider relation R， A， B， C，
    D。 with functional dependencies A implies B and B implies C。 Just one of the following
    decompositions could result from the voice card normal form decomposition algorithm
    as presented in class。 Which one？ Okay， so the trickiest part about this question
    is that since A functionally determines B。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们继续来看第九题。考虑关系R，A，B，C，D。具有功能依赖A推导出B和B推导出C。在课堂上展示的“声卡规范形式分解算法”中，下面的哪种分解可能是结果？好吧，这个问题最棘手的部分是，因为A功能性地确定了B。
- en: I'm sorry if I confused those two terms。 If， since A functionally determines
    B and B functionally determined C by the transitive rule。 A functionally determined
    C。 So you need to consider that as you're decomposing。 Okay。 so we can break apart
    our A， B， C， D。 First using violating functional dependency are A， B。 So I'm just
    going to type this out really quick。 Bring up my notepad from before。 So we have。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我混淆了这两个术语，我感到抱歉。如果，因A函数性地决定了B，而B又通过传递规则函数性地决定了C，那么A就函数性地决定了C。所以在分解时，你需要考虑这一点。好的，所以我们可以拆分A，B，C，D。首先，使用违反函数依赖的是A，B。所以我会很快把它打出来。打开之前的记事本。所以我们有。
- en: '![](img/e81549c43c3763b9bb711297a6190492_5.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e81549c43c3763b9bb711297a6190492_5.png)'
- en: We've discussed we have a functionally determines B。 B functionally determines
    C and therefore a functionally determines C。 And so we have our A， B。 C and D。
    So we can break apart with A functionally determines B。 So we would break that
    into two relations are A， B。 We'll call that R1， A， B and R2 with A， C and D。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过了，我们有A函数性决定B，B函数性决定C，因此A函数性决定C。所以我们得到了A，B，C和D。我们可以用A函数性决定B来拆分。所以我们将它分解成两个关系，A，B。我们称之为R1，A，B和R2，A，C和D。
- en: And so we look at these。 Okay， so now the only functional dependency that we
    have here has A on the left hand side。 And so A is a key for this relation。 So
    that is fully decomposed。 And we have this A， C。 D relation where we still have
    a violating functional dependency with A and C。 And so we need to break that down
    further into our three into A and C and R4 with A and D。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们看一下这些。好的，现在唯一的函数依赖是A在左边。所以A是这个关系的一个关键。这个关系已经完全分解。然后我们得到了一个A，C，D的关系，但我们依然有A和C之间违反的函数依赖。所以我们需要进一步将它分解成我们的三个关系，A和C，以及A和D的R4。
- en: And so now we are done。 We have no more violating functional dependencies。 So
    the final set we have A， B in one relation， A， C in one relation and A， D in one
    relation。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们完成了。我们没有更多的违反函数依赖。所以我们最终得到了三个关系：A，B在一个关系中，A，C在一个关系中，A，D在一个关系中。
- en: '![](img/e81549c43c3763b9bb711297a6190492_7.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e81549c43c3763b9bb711297a6190492_7.png)'
- en: And so voila， that is the final option here。 So that is the answer to question
    nine。 which I know a lot of people had some trouble with。 And finally， let's look
    at question 10。 Consider relation R， A， B， C with functional dependency A， B，
    implies C and M， B， C。 multi determines B。 We are interested in whether R is in
    BCNF and or fourth normal form。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，瞧，这就是最后的选项。这就是第九题的答案，我知道很多人对此有些困惑。最后，让我们看看第十题。考虑关系R，A，B，C，具有函数依赖A，B→C和M，B，C。多值决定B。我们要确定R是否在BCNF或第四范式中。
- en: Choose one of the following。 Okay。 So our ABC， we have AB implies C as our only
    functional dependency。 And so what that means in this case is that AB is a key
    for the relation R。 And so functional dependencies aren't violating if the left
    hand side is a key。 So indeed we are in BCNF here。 So we can eliminate this option
    and we can eliminate this option。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择下面的一个。好的。我们有A，B→C作为唯一的函数依赖。所以在这种情况下，A，B是关系R的一个键。因此，当左侧是键时，函数依赖就不会违反。所以我们确实处于BCNF状态。因此，我们可以排除这个选项，也可以排除这个选项。
- en: So we know that it's either this one or this one。 Okay。 And we also have multi
    valued dependency C implies C C multi determines B。 So MVDs are violating if the
    left hand side is not a key。 And the MVD is non trivial。 And so in this case，
    C is not a key for the relation。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道它要么是这个，要么是那个。好的。我们还要处理多值依赖C→C，C多值决定B。多值依赖是违反的，当且仅当左侧不是键，并且这个多值依赖是非平凡的。所以在这种情况下，C不是这个关系的键。
- en: So that part indicates that it's a violating MVD。 And it's also the case that
    this is a non trivial MVD。 Because we don't have B as a subset of C and C and
    B together are not all attributes。 So this is indeed a violating MVD。 So we have
    that this is in BCNF but not in fourth normal form since we have a violating MVD。
    Alright， so that concludes me going over the solutions to the midterm exam。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那部分表示它是一个违反的多值依赖（MVD）。而且，这也是一个非平凡的多值依赖。因为我们没有B是C的子集，并且C和B一起并不包含所有的属性。所以这确实是一个违反的多值依赖。所以我们知道这个关系是BCNF，但不是第四范式，因为我们有一个违反的多值依赖。好的，这就结束了我讲解期中考试解答的部分。
- en: I hope that this was instructive and useful and gives you some good preparation
    for the final exam。 Thank you and have a great weekend。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这对你们有所帮助，也能为期末考试做一些有效的准备。谢谢，祝你们周末愉快。
- en: '![](img/e81549c43c3763b9bb711297a6190492_9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e81549c43c3763b9bb711297a6190492_9.png)'
