- en: 4.4   Shortest Paths
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4   最短路径
- en: 原文：[https://algs4.cs.princeton.edu/44sp](https://algs4.cs.princeton.edu/44sp)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/44sp](https://algs4.cs.princeton.edu/44sp)
- en: Shortest paths.
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最短路径。
- en: An edge-weighted digraph is a digraph where we associate weights or costs with
    each edge. A *shortest path* from vertex s to vertex t is a directed path from
    s to t with the property that no other such path has a lower weight.![Shortest
    path](../Images/db83588d47a16840571ea82eb7a5826a.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 加权有向图是一个有向图，其中我们为每条边关联权重或成本。从顶点s到顶点t的*最短路径*是从s到t的有向路径，具有没有更低权重的其他路径的属性。![最短路径](../Images/db83588d47a16840571ea82eb7a5826a.png)
- en: Properties.
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性。
- en: We summarize several important properties and assumptions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结了几个重要的属性和假设。
- en: '*Paths are directed.* A shortest path must respect the direction of its edges.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路径是有方向的。* 最短路径必须遵守其边的方向。'
- en: '*The weights are not necessarily distances.* Geometric intuition can be helpful,
    but the edge weights weights might represent time or cost.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*权重不一定是距离。* 几何直觉可能有所帮助，但边的权重可能代表时间或成本。'
- en: '*Not all vertices need be reachable.* If t is not reachable from s, there is
    no path at all, and therefore there is no shortest path from s to t.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并非所有顶点都需要可达。* 如果t从s不可达，则根本没有路径，因此从s到t的最短路径也不存在。'
- en: '*Negative weights introduce complications.* For the moment, we assume that
    edge weights are positive (or zero).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*负权重引入了复杂性。* 目前，我们假设边的权重是正数（或零）。'
- en: '*Shortest paths are normally simple.* Our algorithms ignore zero-weight edges
    that form cycles, so that the shortest paths they find have no cycles.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最短路径通常是简单的。* 我们的算法忽略形成循环的零权重边，因此它们找到的最短路径没有循环。'
- en: '*Shortest paths are not necessarily unique.* There may be multiple paths of
    the lowest weight from one vertex to another; we are content to find any one of
    them.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最短路径不一定是唯一的。* 从一个顶点到另一个顶点可能有多条最低权重的路径；我们满足于找到其中任何一条。'
- en: '*Parallel edges and self-loops may be present.* In the text, we assume that
    parallel edges are not present and use the notation v->w to refer to the edge
    from v to w, but our code handles them without difficulty.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行边和自环可能存在。* 在文本中，我们假设不存在并行边，并使用符号v->w来表示从v到w的边，但我们的代码可以轻松处理它们。'
- en: Edge-weighted digraph data type.
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加权有向图数据类型。
- en: We represent the weighted edges using the following API:![API for a weighted
    directed edge](../Images/441e4691ecf4079c88407d73c33143a7.png)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下API表示加权边：![加权有向边的API](../Images/441e4691ecf4079c88407d73c33143a7.png)
- en: The `from()` and `to()` methods are useful for accessing the edge's vertices.
    [DirectedEdge.java](DirectedEdge.java.html) implements this API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`from()`和`to()`方法对于访问边的顶点很有用。[DirectedEdge.java](DirectedEdge.java.html) 实现了这个API。'
- en: 'We represent edge-weighted digraphs using the following API:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下API表示加权有向图：
- en: '![API for an'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![用于'
- en: edge-weighted graph](../Images/5183e9f715f7f519078e707833344725.png)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图](../Images/5183e9f715f7f519078e707833344725.png)
- en: '[EdgeWeightedDigraph.java](EdgeWeightedDigraph.java.html) implements the API
    using the adjacency-lists representation.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[EdgeWeightedDigraph.java](EdgeWeightedDigraph.java.html) 使用邻接表表示实现了该API。'
- en: '![edge-weighted digraph representation](../Images/1f9ed2ec26658559312f493e7eded192.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![加权有向图表示](../Images/1f9ed2ec26658559312f493e7eded192.png)'
- en: Shortest paths API.
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最短路径API。
- en: We use the following API for computing the shortest paths of an edge-weighted
    digraph:![API for SP implementations](../Images/9548d3f320bf2ad1ece9806c44fdb571.png)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下API计算加权有向图的最短路径：![SP实现的API](../Images/9548d3f320bf2ad1ece9806c44fdb571.png)
- en: 'We prepare some test data:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了一些测试数据：
- en: '[tinyEWD.txt](tinyEWD.txt) contains 8 vertices and 15 edges'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[tinyEWD.txt](tinyEWD.txt) 包含8个顶点和15条边'
- en: '[mediumEWD.txt](mediumEWD.txt) contains 250 vertices and 2,546 edges'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mediumEWD.txt](mediumEWD.txt) 包含250个顶点和2,546条边'
- en: '[1000EWG.txt](1000EWD.txt) contains 1,000 vertices and 16,866 edges'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1000EWG.txt](1000EWD.txt) 包含1,000个顶点和16,866条边'
- en: '[10000EWG.txt](10000EWD.txt) contains 10,000 vertices and 123,462 edges'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10000EWG.txt](10000EWD.txt) 包含10,000个顶点和123,462条边'
- en: '[largeEWG.txt](largeEWD.txt) contains one million vertices and 15,172,126 edges.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[largeEWG.txt](largeEWD.txt) 包含一百万个顶点和15,172,126条边。'
- en: Data structures for single-source shortest paths.
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单源最短路径的数据结构。
- en: Given an edge-weighted digraph and a designated vertex s, a *shortest-paths
    tree* (SPT) is a subgraph containing s and all the vertices reachable from s that
    forms a directed tree rooted at s such that every tree path is a shortest path
    in the digraph.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个加权有向图和一个指定的顶点s，*最短路径树*（SPT）是一个子图，包含s和所有从s可达的顶点，形成以s为根的有向树，使得每条树路径都是图中的最短路径。
- en: 'We represent the shortest paths with two vertex-indexed arrays:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两个顶点索引数组表示最短路径：
- en: '*Edges on the shortest-paths tree*: `edgeTo[v]` is the the last edge on a shortest
    path from s to v.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最短路径树上的边*：`edgeTo[v]`是从s到v的最短路径上的最后一条边。'
- en: '*Distance to the source*: `distTo[v]` is the length of the shortest path from
    s to v.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*到源的距离*：`distTo[v]`是从s到v的最短路径的长度。'
- en: '![Shortest paths tree](../Images/1bf0dc42e46d1d94fc775e9c7babfff6.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![最短路径树](../Images/1bf0dc42e46d1d94fc775e9c7babfff6.png)'
- en: Relaxation.
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松弛。
- en: Our shortest-paths implementations are based on an operation known as *relaxation*.
    We initialize `distTo[s]` to 0 and `distTo[v]` to infinity for all other vertices
    v.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最短路径实现基于一种称为*松弛*的操作。我们将`distTo[s]`初始化为0，对于所有其他顶点v，将`distTo[v]`初始化为无穷大。
- en: '*Edge relaxation.* To relax an edge v->w means to test whether the best known
    way from s to w is to go from s to v, then take the edge from v to w, and, if
    so, update our data structures.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边松弛。* 对边v->w进行松弛意味着测试从s到w的已知最佳路径是否是从s到v，然后沿着从v到w的边，如果是，则更新我们的数据结构。'
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![edge relaxation](../Images/1304176f7960122f8093d36491508332.png)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![边松弛](../Images/1304176f7960122f8093d36491508332.png)'
- en: '*Vertex relaxation.* All of our implementations actually relax all the edges
    pointing from a given vertex.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顶点松弛。* 我们所有的实现实际上都会松弛从给定顶点指向的所有边。'
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Dijkstra's algorithm.
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迪杰斯特拉算法。
- en: Dijkstra's algorithm initializing `dist[s]` to 0 and all other `distTo[]` entries
    to positive infinity. Then, it repeatedly relaxes and adds to the tree a non-tree
    vertex with the lowest `distTo[]` value, continuing until all vertices are on
    the tree or no non-tree vertex has a finite `distTo[]` value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 戴克斯特拉算法将`dist[s]`初始化为0，将所有其他`distTo[]`条目初始化为正无穷。然后，它重复地放松并将具有最低`distTo[]`值的非树顶点添加到树中，继续直到所有顶点都在树上或没有非树顶点具有有限的`distTo[]`值。
- en: '[DijkstraSP.java](DijkstraSP.java.html) is an efficient implementation of Dijkstra''s
    algorithm. It uses [IndexMinPQ.java](IndexMinPQ.java.html) for the priority queue.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[DijkstraSP.java](DijkstraSP.java.html)是戴克斯特拉算法的高效实现。它使用[IndexMinPQ.java](IndexMinPQ.java.html)作为优先队列。'
- en: Proposition.
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命题。
- en: Dijkstra's algorithm solves the single-source shortest-paths problem in edge-weighted
    digraphs with nonnegative weights using extra space proportional to V and time
    proportional to E log V (in the worst case).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 戴克斯特拉算法使用额外空间与V成正比，时间与E log V成正比（在最坏情况下）解决了带非负权重的带权有向图中的单源最短路径问题。
- en: Acyclic edge-weighted digraphs.
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无环带权有向图。
- en: We use the term *edge-weighted DAG* to refer to an acyclic edge-weighted digraph.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语*带权有向无环图*来指代无环带权有向图。
- en: '*Single-source shortest paths problem in edge-weighted DAGs.* We now consider
    an algorithm for finding shortest paths that is simpler and faster than Dijkstra''s
    algorithm for edge-weighted DAGs.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带权有向无环图中的单源最短路径问题*。我们现在考虑一种用于查找最短路径的算法，对于带权有向无环图而言，它比戴克斯特拉算法更简单且更快。'
- en: It solves the single-source problem in linear time.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在线性时间内解决了单源问题。
- en: It handles negative edge weights.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理负边权重。
- en: It solves related problems, such as finding longest paths.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解决了相关问题，如查找最长路径。
- en: The algorithm combines vertex relaxation with topological sorting. We initialize
    `distTo[s]` to 0 and all other `distTo[]` values to infinity, then relax the vertices,
    one by one, taking the vertices in *topological order*. [AcyclicSP.java](AcyclicSP.java.html)
    is an implementation of this approach. It relies on this version of [Topological.java](Topological.java.html),
    extended to support edge-weighted digraphs.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该算法将顶点放松与拓扑排序结合起来。我们将`distTo[s]`初始化为0，将所有其他`distTo[]`值初始化为无穷大，然后按照*拓扑顺序*放松顶点。[AcyclicSP.java](AcyclicSP.java.html)是这种方法的实现。它依赖于这个版本的[Topological.java](Topological.java.html)，扩展以支持带权有向图。
- en: '*Single-source longest paths problem in edge-weighted DAGs.* We can solve the
    single-source longest paths problems in edge-weighted DAGs by initializing the
    `distTo[]` values to negative infinity and switching the sense of the inequality
    in `relax()`. [AcyclicLP.java](AcyclicLP.java.html) implements this approach.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带权有向无环图中的单源最长路径问题*。我���可以通过将`distTo[]`值初始化为负无穷大并在`relax()`中改变不等式的意义来解决带权有向无环图中的单源最长路径问题。[AcyclicLP.java](AcyclicLP.java.html)实现了这种方法。'
- en: '*Critical path method.* We consider the parallel precedence-constrained job
    scheduling problem: Given a set of jobs of specified duration to be completed,
    with precedence constraints that specify that certain jobs have to be completed
    before certain other jobs are begun, how can we schedule the jobs on identical
    processors (as many as needed) such that they are all completed in the minimum
    amount of time while still respecting the constraints?![Job-scheduling problem](../Images/4cabc116e51702f1647e3efa2753e4f8.png)![Job-scheduling
    solution](../Images/c9100c506da13cec56164c9f91510fac.png)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关键路径法*。我们考虑并行的有前置约束的作业调度问题：给定一组指定持续时间的作业，其中有前置约束规定某些作业必须在某些其他作业开始之前完成，我们如何在相同数量的处理器上安排这些作业，以便它们在最短的时间内完成，同时仍然遵守约束条件？![作业调度问题](../Images/4cabc116e51702f1647e3efa2753e4f8.png)![作业调度解决方案](../Images/c9100c506da13cec56164c9f91510fac.png)'
- en: 'This problem can be solved by formulating it as a longest paths problem in
    an edge-weighted DAG: Create an edge-weighted DAG with a source s, a sink t, and
    two vertices for each job (a start vertex and an end vertex). For each job, add
    an edge from its start vertex to its end vertex with weight equal to its duration.
    For each precedence constraint v->w, add a zero-weight edge from the end vertex
    corresponding to v to the beginning vertex corresponding to w. Also add zero-weight
    edges from the source to each job''s start vertex and from each job''s end vertex
    to the sink.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将问题制定为带权有向无环图中的最长路径问题，可以解决此问题：创建一个带权有向无环图，其中包含一个源s，一个汇t，以及每个作业的两个顶点（一个起始顶点和一个结束顶点）。对于每个作业，从其起始顶点到其结束顶点添加一条权重等于其持续时间的边。对于每个前置约束v->w，从对应于v的结束顶点到对应于w的开始顶点添加一条零权重边。还从源到每个作业的起始顶点和从每个作业的结束顶点到汇添加零权重边。
- en: '![Job-scheduling problem reduction to longest paths](../Images/c07307c1747961f6c4c068fed76e3000.png)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![作业调度问题简化为最长路径](../Images/c07307c1747961f6c4c068fed76e3000.png)'
- en: Now, schedule each job at the time given by the length of its longest path from
    the source.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，根据从源到达的最长路径的长度安排每个作业的时间。
- en: '![Job-scheduling problem critical path](../Images/9d882d2d8076624c71430c25e4f19b33.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![作业调度问题关键路径](../Images/9d882d2d8076624c71430c25e4f19b33.png)'
- en: '[CPM.java](CPM.java.html) is an implementation of the critical path method.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[CPM.java](CPM.java.html)是关键路径法的实现。'
- en: Proposition.
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命题。
- en: By relaxing vertices in topological order, we can solve the single-source shortest-paths
    and longest-paths problems for edge-weighted DAGs in time proportional to E +
    V.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按拓扑顺序放松顶点，我们可以在时间复杂度为E + V的情况下解决带权有向无环图的单源最短路径和最长路径问题。
- en: Shortest paths in general edge-weighted digraphs.
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般带权有向图中的最短路径。
- en: We can solve shortest path problems if (i) all weights are nonnegative or (ii)
    there are no cycles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(i)所有权重为非负或(ii)没有循环，则可以解决最短路径问题。
- en: '*Negative cycles.* A *negative cycle* is a directed cycle whose total weight
    (sum of the weights of its edges) is negative. The concept of a shortest path
    is meaningless if there is a negative cycle.![an edge-weighted digraph with a
    negative cycle](../Images/77cb49d7a1684da2f5ce229fa97a38e8.png)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*负循环*。*负循环*是一个总权重为负的有向循环。如果存在负循环，则最短路径的概念是没有意义的。![带有负循环的加权有向图](../Images/77cb49d7a1684da2f5ce229fa97a38e8.png)'
- en: Accordingly, we consider edge-weighted digraphs with no negative cycles.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们考虑没有负循环的加权有向图。
- en: '*Bellman-Ford algorithm.* Initialize `distTo[s]` to 0 and all other `distTo[]`
    values to infinity. Then, considering the digraph''s edges in any order, and relax
    all edges. Make V such passes.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*贝尔曼-福特算法*。将`distTo[s]`初始化为0，将所有其他`distTo[]`值初始化为无穷大。然后，以任意顺序考虑有向图的边，并放松所有边。进行V次这样的遍历。'
- en: '[PRE2]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We do not consider this version in detail because it *always* relaxes V E edges.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不详细考虑这个版本，因为它*总是*放松V E条边。
- en: '*Queue-based Bellman-Ford algorithm.* The only edges that could lead to a change
    in `distTo[]` are those leaving a vertex whose `distTo[]` value changed in the
    previous pass. To keep track of such vertices, we use a FIFO queue. [BellmanFordSP.java](BellmanFordSP.java.html)
    implements this approach by maintaining two additional data structures:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于队列的贝尔曼-福特算法*。可能导致`distTo[]`变化的唯一边是那些离开上一轮中`distTo[]`值发生变化的顶点的边。为了跟踪这样的顶点，我们使用一个FIFO队列。[BellmanFordSP.java](BellmanFordSP.java.html)通过维护两个额外的数据结构来实现这种方法：'
- en: A queue of vertices to be relaxed
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个要放松的顶点队列
- en: A vertex-index boolean array `onQ[]` that indicates which vertices are on the
    queue, to avoid duplicates
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个顶点索引的布尔数组`onQ[]`，指示哪些顶点在队列上，以避免重复
- en: '*Negative cycle detection.* In many applications, our goal is to check for
    and to check for and extract negative cycles. Accordingly, we add the following
    methods to the API:![API for negative cycle detection](../Images/c86c2af288a5d75a3fcf9e63f4db2144.png)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*负循环检测*。在许多应用中，我们的目标是检查并提取负循环。因此，我们向API添加以下方法：![负循环检测的API](../Images/c86c2af288a5d75a3fcf9e63f4db2144.png)'
- en: There is a negative cycle reachable from the source if and only if the queue
    is nonempty after the Vth pass through all the edges. Moreover, the subgraph of
    edges in our `edgeTo[]` array must contain a negative cycle. Accordingly, to implement
    `negativeCycle()` [BellmanFordSP.java](BellmanFordSP.java.html) builds an edge-weighted
    digraph from the edges in `edgeTo[]` and looks for a cycle in that digraph. To
    find the cycle, it uses [EdgeWeightedDirectedCycle.java](EdgeWeightedDirectedCycle.java.html),
    a version of [DirectedCycle.java](../42directed/DirectedCycle.java.html) from
    Section 4.3, adapted to work for edge-weighted digraphs. We amortize the cost
    of this check by performing this check only after every Vth edge relaxation.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当且仅当在所有边的第V次遍历后队列非空时，从源可达负循环。此外，我们`edgeTo[]`数组中的边子图必须包含一个负循环。因此，为了实现`negativeCycle()`，[BellmanFordSP.java](BellmanFordSP.java.html)从`edgeTo[]`中的边构建一个加权有向图，并在该图中查找循环。为了找到循环，它使用[EdgeWeightedDirectedCycle.java](EdgeWeightedDirectedCycle.java.html)，这是第4.3节中[DirectedCycle.java](../42directed/DirectedCycle.java.html)的一个版本，适用于加权有向图。我们通过仅在每次第V次边放松后执行此检查来分摊此检查的成本。
- en: '*Arbitrage detection.* Consider a market for financial transactions that is
    based on trading commodities. The table in [rates.txt](rates.txt) shows conversion
    rates among currencies. The first line in the file is the number V of currencies;
    then the file has one line per currency, giving its name followed by the conversion
    rates to the other currencies. An *arbitrage opportunity* is a directed cycle
    such that the product of the exchange rates is greater than one. For example,
    our table says that 1,000 U.S. dollars will buy 1,000.00 × .741 = 741 euros, then
    we can buy 741 × 1.366 = 1,012.206 Canadian dollars with our euros, and finally,
    1,012.206 × .995 = 1,007.14497 U.S. dollars with our Canadian dollars, a 7.14497-dollar
    profit!'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*套汇检测*。考虑一个基于商品交易的金融交易市场。[rates.txt](rates.txt)中的表显示了货币之间的转换率。文件的第一行是货币V的数量；然后文件每行给出货币的名称，然后是转换为其他货币的汇率。*套汇机会*是一个有向循环，使得交换率的乘积大于1。例如，我们的表格显示，1000美元可以购买1000.00
    × .741 = 741欧元，然后我们可以用我们的欧元购买741 × 1.366 = 1,012.206加拿大元，最后，我们可以用我们的加拿大元购买1,012.206
    × .995 = 1,007.14497美元，获得7.14497美元的利润！'
- en: '| ![Exchange rates](../Images/94c6ddabeeebe712eb0d0a178d29e9c0.png) |      
          | ![Arbitrage opportunity](../Images/8995a58b650884497d2518894a88a00d.png)
    |'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![汇率](../Images/94c6ddabeeebe712eb0d0a178d29e9c0.png) |             | ![套汇机会](../Images/8995a58b650884497d2518894a88a00d.png)
    |'
- en: To formulate the arbitrage problem as a negative-cycle detection problem, replace
    each weight by its *logarithm*, negated. With this change, computing path weights
    by multiplying edge weights in the original problem corresponds to adding them
    in the transformed problem. [Arbitrage.java](Arbitrage.java.html) identifies arbitrage
    opportunities in a currency-exchange network by solving the corresponding negative
    cycle detection problem.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了将套汇问题制定为负循环检测问题，将每个权重替换为其*对数*的负值。通过这种改变，在原问题中通过乘以边权重来计算路径权重对应于在转换后的问题中将它们相加。[Arbitrage.java](Arbitrage.java.html)通过解决相应的负循环检测问题来识别货币兑换网络中的套汇机会。
- en: Proposition.
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题。
- en: There exists a shortest path from s to v in an edge-weighted digraph if and
    only if there exists at least one directed path from s to v and no vertex on any
    directed path from s to v is on a negative cycle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权有向图中，从s到v存在最短路径当且仅当从s到v存在至少一条有向路径，并且从s到v的任何有向路径上的顶点都不在负循环上。
- en: Proposition.
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题。
- en: The Bellman-Ford algorithm solves the single-source shortest-paths problem from
    a given source s (or finds a negative cycle reachable from s) for any edge-weighted
    digraph with V vertices and E edges, in time proportional to E V and extra space
    proportional to V, in the worst case.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔曼-福特算法解决了给定源s的单源最短路径问题（或找到从s可达的负循环）对于具有V个顶点和E条边的任意加权有向图，在最坏情况下，时间复杂度为E V，额外空间复杂度为V。
- en: Q + A
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** Does Dijkstra''s algorithm work with negative weights?'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Dijkstra算法能处理负权重吗？'
- en: '**A.** Yes and no. There are two shortest paths algorithms known as *Dijkstra''s
    algorithm*, depending on whether a vertex can be enqueued on the priority queue
    more than once. When the weights are nonnegative, the two versions coincide (as
    no vertex will be enqueued more than once). The version implemented in [DijkstraSP.java](DijkstraSP.java.html)
    (which allows a vertex to be enqueued more than once) is correct in the presence
    of negative edge weights (but no negative cycles) but its running time is exponential
    in the worst case. (We note that [DijkstraSP.java](DijkstraSP.java.html) throws
    an exception if the edge-weighted digraph has an edge with a negative weight,
    so that a programmer is not surprised by this exponential behavior.) If we modify
    [DijkstraSP.java](DijkstraSP.java.html) so that a vertex cannot be enqueued more
    than once (e.g., using a `marked[]` array to mark those vertices that have been
    relaxed), then the algorithm is guaranteed to run in *E* log *V* time but it may
    yield incorrect results when there are edges with negative weights.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是和否。有两种已知的最短路径算法称为*Dijkstra算法*，取决于一个顶点是否可以多次入队到优先队列。当权重为非负时，这两个版本是相同的（因为没有顶点会多次入队）。[DijkstraSP.java](DijkstraSP.java.html)中实现的版本（允许一个顶点多次入队）在存在负边权（但没有负环）时是正确的，但其最坏情况下的运行时间是指数级的。（我们注意到[DijkstraSP.java](DijkstraSP.java.html)如果边权重为负数，则会抛出异常，以便程序员不会对这种指数级行为感到惊讶。）如果我们修改[DijkstraSP.java](DijkstraSP.java.html)以使一个顶点不能多次入队（例如，使用`marked[]`数组标记那些已经被松弛的顶点），那么算法保证在*E*
    log *V*时间内运行，但当存在负权边时可能产生错误结果。'
- en: Exercises
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: True or false. Adding a constant to every edge weight does not change the solution
    to the single-source shortest-paths problem.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假。将每个边权重增加一个常数不会改变单源最短路径问题的解决方案。
- en: '*Solution.* False.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 假。'
- en: Provide an implementation of `toString()` for [EdgeWeightedDigraph.java](EdgeWeightedDigraph.java.html).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[EdgeWeightedDigraph.java](EdgeWeightedDigraph.java.html)提供`toString()`的实现。
- en: Use the memory-cost model of Section 1.4 to determine the amount of memory used
    by [EdgeWeightedDigraph.java](EdgeWeightedDigraph.java.html) to represent a graph
    with *V* vertices and *E* edges.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第1.4节的内存成本模型确定[EdgeWeightedDigraph.java](EdgeWeightedDigraph.java.html)用于表示具有*V*个顶点和*E*条边的图所使用的内存量。
- en: '*Solution.* 56 + 40V + 72E. [MemoryOfEdgeWeightedDigraph.java](MemoryOfEdgeWeightedDigraph.java.html)
    computes it empirically assuming that no `Integer` values are cached—Java typically
    caches the integers -128 to 127.'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 56 + 40V + 72E。[MemoryOfEdgeWeightedDigraph.java](MemoryOfEdgeWeightedDigraph.java.html)根据经验计算，假设没有缓存`Integer`值
    - Java通常缓存-128到127的整数。'
- en: Adapt the `DirectedCycle` and `Topological` classes from Section 4.2 to use
    the `EdgeweightedDigraph` and `DirectedEdge` APIs of this section, thus implementing
    [EdgeWeightedDirectedCycle.java](EdgeWeightedDirectedCycle.java.html) and [Topological.java](Topological.java.html).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第4.2节中的`DirectedCycle`和`Topological`类中使用本节的`EdgeweightedDigraph`和`DirectedEdge`API，从而实现[EdgeWeightedDirectedCycle.java](EdgeWeightedDirectedCycle.java.html)和[Topological.java](Topological.java.html)。
- en: Suppose that we convert an `EdgeWeightedGraph` into an `EdgeWeightedDigraph`
    by creating two `DirectedEdge` objects in the `EdgeWeightedDigraph` (one in each
    direction) for each `Edge` in the `EdgeWeightedGraph` and then use the Bellman-Ford
    algorithm. Explain why this approach fails spectacularly.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们通过为`EdgeWeightedGraph`中的每个`Edge`创建两个`DirectedEdge`对象（分别在每个方向上）来将`EdgeWeightedGraph`转换为`EdgeWeightedDigraph`，然后使用贝尔曼-福特算法。解释为什么这种方法会失败得惊人。
- en: '*Solution:* This can introduce negative cost cycles even if the edge-weighted
    graph does not contain them.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* 即使带权图不包含负权重环，这可能会引入负成本循环。'
- en: What happens if you allow a vertex to be enqueued more than once in the same
    pass in the Bellman-Ford algorithm?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在贝尔曼-福特算法的同一遍历中允许一个顶点被多次入队会发生什么？
- en: '*Answer*: The running time of the algorithm can go exponential. For example,
    consider what happens for the complete edge-weighted digraph whose edge weights
    are all -1.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案：* 算法的运行时间可能呈指数增长。例如，考虑所有边权重均为-1的完全带权有向图会发生什么。'
- en: Creative Problems
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意问题
- en: '**Longest paths in DAGs.** Develop an implementation [AcyclicLP.java](AcyclicLP.java.html)
    that can solve the longest-paths problem in edge-weighted DAGs.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向无环图中的最长路径。** 开发一个实现[AcyclicLP.java](AcyclicLP.java.html)的程序，可以解决带权有向无环图中的最长路径问题。'
- en: '**All-pairs shortest paths on a line.** Given a weighted line-graph (undirected
    connected graph, all vertices of degree 2, except two endpoints which have degree
    1), devise an algorithm that preprocesses the graph in linear time and can return
    the distance of the shortest path between any two vertices in constant time.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**线上的所有对最短路径。** 给定一个加权线图（无向连通图，所有顶点的度为2，除了两个端点的度为1），设计一个算法，在线性时间内预处理图，并能在常数时间内返回任意两个顶点之间最短路径的距离。'
- en: '*Partial solution.* Find a vertex s of degree 1 and run breadth-first (or depth-first)
    search to find the order in which the remaining vertices appear. Then, compute
    the length of the shortest path from s to v for each vertex v, say `dist[v]`.
    The shortest path between v and w is |`dist[v] - dist[w]`|.'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案。* 找到一个度为1的顶点s，并运行广度优先（或深度优先）搜索以找到其余顶点出现的顺序。然后，计算从s到每个顶点v的最短路径长度，称为`dist[v]`。顶点v和w之间的最短路径是|`dist[v]
    - dist[w]`|。'
- en: '**Monotonic shortest path.** Given an edge-weighted digraph, find a *monotonic*
    shortest path from s to every other vertex. A path is monotonic if the weight
    of every edge on the path is either strictly increasing or strictly decreasing.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单调最短路径。** 给定一个带权有向图，找到从s到每个其他顶点的*单调*最短路径。如果路径上每条边的权重要么严格递增要么严格递减，则路径是单调的。'
- en: '*Partial solution*: relax edges in ascending order and find a best path; then
    relax edges in descending order and find a best path.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案：* 按升序松弛边并找到最佳路径；然后按降序松弛边并找到最佳路径。'
- en: '**Lazy implementation of Dijkstra''s algorithm.** Develop an implementation
    [LazyDijkstraSP.java](LazyDijkstraSP.java.html) of the lazy version of Dijkstra''s
    algorithm that is described in the text.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Dijkstra算法的懒惰实现。** 开发一个实现[LazyDijkstraSP.java](LazyDijkstraSP.java.html)的Dijkstra算法的懒惰版本，该版本在文本中有描述。'
- en: '**Bellman-Ford queue never empties.** Show that if there is a negative cycle
    reachable from the source in the queue-based implementation of the Bellman-Ford
    algorithm, then the queue never empties.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bellman-Ford队列永不为空。** 证明如果在基于队列的Bellman-Ford算法中从源可达到一个负循环，那么队列永远不会为空。'
- en: '*Solution*: Consider a negative cycle and suppose that `distTo[w] <= distTo[v]
    + length(v, w)` for all edges on cycle W. Summing up this inequality for all edges
    on the cycle implies that the length of the cycle is nonnegative.'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：考虑一个负循环，并假设对于循环W上的所有边，`distTo[w] <= distTo[v] + length(v, w)`。对循环上的所有边进行这个不等式求和意味着循环的长度是非负的。'
- en: '**Bellman-Ford negative cycle detection.** Show that if any edge is relaxed
    during the Vth pass of the generic Bellman-Ford algorithm, then the `edgeTo[]`
    array has a directed cycle and any such cycle is a negative cycle.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bellman-Ford负循环检测。** 证明如果在通用Bellman-Ford算法的第V次遍历中有任何边被松弛，那么`edgeTo[]`数组中就有一个有向循环，并且任何这样的循环都是负循环。'
- en: '*Solution*: todo.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：待定。'
- en: Web Exercises
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: '**Optimal substructure property.** Prove that every subpath on a shortest path
    from v to w is also a shortest path between the two endpoints.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最优子结构性质。** 证明从v到w的最短路径上的每个子路径也是两个端点之间的最短路径。'
- en: '**Unique shortest path tree.** Suppose that there is a unique shortest path
    from s to every other vertex. Prove that the SPT is unique.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**唯一最短路径树。** 假设从s到每个其他顶点都有唯一的最短路径。证明SPT是唯一的。'
- en: '**No negative cycles.** Prove that if the generic algorithm terminates, then
    there are no negative cycles reachable from s. Hint: upon termination, all edges
    reachable from s satisfy distTo[w] <= distTo[v] + e.weight(). Add up this inequality
    for all edges along a cycle.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**没有负循环。** 证明如果通用算法终止，则从s可达的地方没有负循环。提示：在终止时，从s可达的所有边都满足`distTo[w] <= distTo[v]
    + e.weight()`。将这个不等式对沿循环的所有边相加。'
- en: '**Predecessor graph.** True or false. During execution of Bellman-Ford in an
    edge-weighted digraph with no negative cycles, following the `edgeTo[]` array
    always yields a path back to s. Repeat the question for Dijkstra''s algorithm.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前驱图。** 真或假。在没有负循环的边权重有向图中执行Bellman-Ford时，遵循`edgeTo[]`数组总是会回到s的路径。对Dijkstra算法重复这个问题。'
- en: '**Yen''s improvement to Bellman-Ford.** [[reference](http://11011110.livejournal.com/215330.html)]
    Partition the edges into two DAGs A and B: A consists of edges that go from a
    lower indexed vertex to a higher indexed vertex; B consists of edges that go from
    a higher indexed vertex to a lower indexed vertex. When iterating through all
    of the edges in a phase of Bellman-Ford, first iterate through the edges in A
    in ascending order of vertex number (a topological order of A), then iterate through
    the edges in B in descending order of vertex number (a topological order of B).
    When iterating through the edges in A, any path in the SPT that starts at a vertex
    with the correct `distTo[]` value and uses only edges in A results in the correct
    `distTo[]` value; similarly for B. The number of passes needed is the maximum
    number of A-B alternations on a path, which is at most (V+1)/2\. Thus, the number
    of passes is at most (V+1)/2 instead of V.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Yen对Bellman-Ford的改进。** [[参考](http://11011110.livejournal.com/215330.html)]
    将边分为两个DAGs A和B：A由从较低索引顶点到较高索引顶点的边组成；B由从较高索引顶点到较低索引顶点的边组��。在Bellman-Ford的一个阶段中遍历所有边时，首先按顶点编号的升序（A的拓扑顺序）遍历A中的边，然后按顶点编号的降序（B的拓扑顺序）遍历B中的边。在遍历A中的边时，SPT中从具有正确`distTo[]`值的顶点开始并且仅使用A中的边的任何路径都会得到正确的`distTo[]`值；B也是如此。所需的遍历次数是路径上A-B交替的最大次数，最多为(V+1)/2。因此，所需的遍历次数最多为(V+1)/2，而不是V。'
- en: '**Replacement paths.** Given an edge-weighted digraph with nonnegative weights
    and source s and sink t, design an algorithm to find the shortest path from s
    to t that does not use edge e for every edge e. The order of growth of your algorithm
    should be E V log V.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**替换路径。** 给定具有非负权重和源s以及汇t的边权重有向图，设计一个算法，找到从s到t的最短路径，该路径不使用每条边e。你的算法的增长顺序应为E
    V log V。'
- en: '**Road network data sets.**'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**道路网络数据集。**'
- en: From the [DIMACS challenge](http://www.dis.uniroma1.it/~challenge9/download.shtml).
    Here are [all the roads in each state](http://www.dis.uniroma1.it/~challenge9/data/tiger/).
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[DIMACS挑战](http://www.dis.uniroma1.it/~challenge9/download.shtml)。这里是[每个州的所有道路](http://www.dis.uniroma1.it/~challenge9/data/tiger/)。
- en: '[rome99.txt](rome99.txt) is a large portion of the directed road network of
    Rome from the [DIMACS challenge](http://www.dis.uniroma1.it/~challenge9/download.shtml).
    The graph contains 3353 vertices and 8870 edges. Vertices correspond to intersections
    between roads and edges correspond to roads or road segments. The edge weights
    are distances in meters.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[rome99.txt](rome99.txt) 是罗马的有向道路网络的大部分数据，来自[DIMACS挑战](http://www.dis.uniroma1.it/~challenge9/download.shtml)。该图包含3353个顶点和8870条边。顶点对应道路交叉口，边对应道路或道路段。边的权重是以米为单位的距离。'
- en: '[NYC.txt](NYC.txt) is the undirected road network of New York City. The graph
    contains 264346 vertices and 733846 edges. It is connected, contains parallel
    edges, but no self-loops. The edge weights are travel times and are strictly positive.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NYC.txt](NYC.txt) 是纽约市的无向道路网络。该图包含264346个顶点和733846条边。它是连通的，包含平行边，但没有自环。边的权重是旅行时间，且严格为正。'
- en: '**Internet routing.** [OSPF (Open Shortest Path First)](http://en.wikipedia.org/wiki/Open_shortest_path_first)
    is a widely used protocol for Internet routing that uses Dijkstra''s algorithm.
    [RIP (Routing Information Protocol)](http://en.wikipedia.org/wiki/Routing_Information_Protocol)
    is another routing protocol based on the Bellman-Ford algorithm.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**互联网路由。** [OSPF（开放最短路径优先）](http://en.wikipedia.org/wiki/Open_shortest_path_first)是互联网路由中广泛使用的协议，使用了迪杰斯特拉算法。[RIP（路由信息协议）](http://en.wikipedia.org/wiki/Routing_Information_Protocol)是另一种基于贝尔曼-福特算法的路由协议。'
- en: '**Shortest path with the ability to skip one edge.** Given an edge-weighted
    digraph with nonnegative weights, Design an E log V algorithm for finding the
    shortest path from s to t where you have the option to change the weight of any
    one edge to 0.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有跳过一条边的最短路径。** 给定具有非负权重的边权重有向图，设计一个E log V算法，用于找到从s到t的最短路径，其中您可以将任意一条边的权重更改为0。'
- en: '*Solution.* Compute the shortest path from s to every other vertex; compute
    the shortest path from every vertex to t. For each edge e = (v, w), compute the
    sum of the length of the shortest path from s to v and the length of the shortest
    path from w to t. The smallest such sum provides the shortest such path.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 计算从s到每个其他顶点的最短路径；计算从每个顶点到t的最短路径。对于每条边e = (v, w)，计算从s到v的最短路径长度和从w到t的最短路径长度的和。最小的这样的和提供了最短的这样的路径。'
- en: '**Shortest paths in undirected graphs.** Write a program [DijkstraUndirectedSP.java](DijkstraUndirectedSP.java.html)
    that solves the single-source shortest paths problems in undirected graphs with
    nonnegative weights using Dijkstra''s algorithm.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无向图中的最短路径。** 编写一个程序[DijkstraUndirectedSP.java](DijkstraUndirectedSP.java.html)，使用迪杰斯特拉算法解决非负权重的无向图中的单源最短路径问题。'
- en: '**Floyd-Warshall algorithm.** [FloydWarshall.java](FloydWarshall.java.html)
    implements the Floyd-Warshall algorithm for the all-pairs shortest path problem.
    It takes time proportional to V^3 and space proportional to V^2. It uses [AdjMatrixEdgeWeightedDigraph.java](AdjMatrixEdgeWeightedDigraph.java.html).'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**弗洛伊德-沃舍尔算法。** [FloydWarshall.java](FloydWarshall.java.html) 实现了弗洛伊德-沃舍尔算法，用于全对最短路径问题。其时间复杂度与V^3成正比，空间复杂度与V^2成正比。它使用了[AdjMatrixEdgeWeightedDigraph.java](AdjMatrixEdgeWeightedDigraph.java.html)。'
- en: '**Randomized Bellman-Ford.** [[reference](http://11011110.livejournal.com/215330.html)]
    Suppose that we choose the vertex order in Yen''s algorithm uniformly at randomly
    (where A contains all the edges that go from a lower vertex in the permutation
    to a higher vertex). Prove that the expected number of passes is at most (V+1)/3.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机贝尔曼-福特算法。** [[参考资料](http://11011110.livejournal.com/215330.html)] 假设我们在Yen算法中均匀随机选择顶点顺序（其中A包含所有从排列中较低顶点到较高顶点的边）。证明预期的通过次数最多为(V+1)/3。'
- en: '**Suurballe''s algorithm.** Given a digraph with non-negative edge weights
    and two distinguished vertices s and t, find two edge-disjoint paths from s to
    t such that the sum of the weights of the two paths is minimized.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**苏尔巴勒算法。** 给定具有非负边权重和两个特殊顶点s和t的有向图，找到从s到t的两条边不相交的路径，使得这两条路径的权重之和最小。'
- en: '*Solution.* This can be done with a clever application of Dijkstra''s algorithm,
    known as [Suurballe''s algorithm](https://en.wikipedia.org/wiki/Suurballe%27s_algorithm).'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 这可以通过巧妙地应用迪杰斯特拉算法来实现，即[苏尔巴勒算法](https://en.wikipedia.org/wiki/Suurballe%27s_algorithm)。'
