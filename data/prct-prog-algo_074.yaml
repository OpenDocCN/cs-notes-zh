- en: 3.3 Designing Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 设计数据类型
- en: 原文：[https://introcs.cs.princeton.edu/python/33design](https://introcs.cs.princeton.edu/python/33design)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 译文：[https://introcs.cs.princeton.edu/python/33design](https://introcs.cs.princeton.edu/python/33design)
- en: In this section we focus on developing APIs as a critical step in the development
    of any program. We need to consider various alternatives, understand their impact
    on both client programs and implementations, and refine the design to strike an
    appropriate balance between the needs of clients and the possible implementation
    strategies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点放在开发API作为任何程序开发的关键步骤上。我们需要考虑各种替代方案，了解它们对客户端程序和实现的影响，并完善设计以在客户端需求和可能的实现策略之间取得适当平衡。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Designing APIs
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计API
- en: In Section 3.1, we composed client programs that use APIs; in Section 3.2, we
    implemented APIs. Now we consider the challenge of designing APIs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3.1节中，我们编写了使用API的客户端程序；在第3.2节中，我们实现了API。现在我们考虑设计API的挑战。
- en: Standards.
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准。
- en: It is easy to understand why conforming to an API is so important by considering
    other domains. From railroad tracks, to threaded nuts and bolts, to MP3s and DVDs,
    to radio frequencies, to Internet standards, we know that using a common standard
    interface enables the broadest usage of a technology. By using APIs to separate
    clients from implementations, we reap the benefits of standard interfaces for
    every program that we compose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑其他领域，很容易理解遵循API的重要性。从铁路轨道，到螺纹螺母，到MP3和DVD，到无线电频率，到互联网标准，我们知道使用共同的标准接口能够实现技术的最广泛使用。通过使用API将客户端与实现分离，我们为我们组合的每个程序获得标准接口的好处。
- en: Specification problem.
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范问题。
- en: Our APIs for data types are sets of methods, along with brief English-language
    descriptions of what the methods are supposed to do. Ideally, an API would clearly
    articulate behavior for all possible arguments, including side effects, and then
    we would have software to check that implementations meet the specification. Unfortunately,
    a fundamental result from theoretical computer science, known as the *specification
    problem*, says that this goal is actually impossible to achieve. Therefore, we
    resort to informal descriptions with examples, such as those in the text surrounding
    our APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们针对数据类型的API是一组方法，以及简短的英语描述这些方法应该做什么。理想情况下，一个API应该清晰地表达所有可能参数的行为，包括副作用，然后我们会有软件来检查实现是否符合规范。不幸的是，来自理论计算机科学的一个基本结果，即*规范问题*，表明这个目标实际上是不可能实现的。因此，我们转而采用带有示例的非正式描述，比如围绕我们的API的文本。
- en: Wide interfaces.
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宽接口。
- en: A *wide interface* is one that has an excessive number of methods. An important
    principle to follow in designing an API is to avoid wide interfaces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽接口*是具有过多方法的接口。在设计API时要遵循的一个重要原则是避免宽接口。'
- en: Start with client code.
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从客户端代码开始。
- en: One of the primary purposes of developing a data type is to simplify client
    code. Therefore, it makes sense to pay attention to client code from the start
    when designing an API. Composing two clients is even better. Starting with client
    code is one way of ensuring that developing an implementation will be worth the
    effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发数据类型的主要目的之一是简化客户端代码。因此，在设计API时，从一开始就关注客户端代码是有意义的。甚至更好的是组合两个客户端。从客户端代码开始是确保开发实现值得的一种方式。
- en: Avoid dependence on representation.
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免对表示的依赖。
- en: Usually when developing an API, we have a representation in mind. After all,
    a data type is a set of values and a set of operations defined on those values,
    and it does not make much sense to talk about the operations without knowing the
    values. But that is different from knowing the representation of the values. One
    purpose of the data type is to simplify client code by allowing it to avoid details
    of and dependence on a particular representation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在开发API时，我们心中有一个表示。毕竟，数据类型是一组值和在这些值上定义的一组操作，并且在不了解值的情况下谈论操作并没有太多意义。但这与了解值的表示是不同的。数据类型的一个目的是通过允许客户端避免对特定表示的细节和依赖来简化客户端代码。
- en: Pitfalls in API design.
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API设计中的陷阱。
- en: 'An API may be too hard to implement, implying implementations that are difficult
    or impossible to develop, or too hard to use, creating client code that is more
    complicated than without the API. An API might be too narrow, omitting methods
    that clients need, or too wide, including a large number of methods not needed
    by any client. An API may be too general, providing no useful abstractions, or
    too specific, providing abstractions so detailed or so diffuse as to be useless.
    These considerations are sometimes summarized in the motto: *provide to clients
    the methods they need and no others*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API可能太难实现，意味着难以开发或不可能开发的实现，或者太难使用，导致客户端代码比没有API更复杂。一个API可能太窄，省略了客户端需要的方法，或者太宽，包含大量任何客户端都不需要的方法。一个API可能太一般化，提供没有用的抽象，或者太具体，提供过于详细或过于分散的抽象。这些考虑有时总结为座右铭：*为客户端提供他们需要的方法，而不提供其他方法*。
- en: '* * *'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Encapsulation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: The process of separating clients from implementations by hiding information
    is known as *encapsulation*. Details of the implementation are kept hidden from
    clients, and implementations have no way of knowing details of client code, which
    may even be created in the future. We use encapsulation to enable modular programming,
    facilitate debugging, and clarify program code. These reasons are tied together
    (well-designed modular code is easier to debug and understand than code based
    entirely on built-in types).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隐藏信息将客户端与实现分离的过程被称为*封装*。实现的细节对客户端保持隐藏，实现没有办法知道客户端代码的细节，甚至可能是未来创建的。我们使用封装来实现模块化编程，促进调试，并澄清程序代码。这些原因是相互联系的（设计良好的模块化代码比完全基于内置类型的代码更容易调试和理解）。
- en: Modular programming.
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化编程。
- en: The key to success in modular programming is to maintain independence among
    modules. We do so by insisting on the API being the only point of dependence between
    client and implementation — data-type implementation code can assume that the
    client knows nothing but the API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程成功的关键在于保持模块之间的独立性。我们通过坚持API是客户端和实现之间唯一的依赖点来实现这一点——数据类型实现代码可以假定客户端除了API之外一无所知。
- en: Changing an API.
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改API。
- en: We often reap the benefits of encapsulation when we use standard modules. New
    versions of Python often, for example, may include new implementations of various
    data types or modules that define functions. There is a strong and constant motivation
    to improve data-type implementations because all clients can potentially benefit
    from an improved implementation. However, Python APIs rarely change. When changes
    do occur, they are costly throughout the Python community — everyone has to update
    their clients. So once a significant number of clients are using a module, try
    not to change its API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用标准模块时，我们经常会获得封装的好处。例如，Python的新版本通常可能包括各种数据类型或定义函数的模块的新实现。改进数据类型实现的动机非常强烈且持续，因为所有客户端都有可能从改进的实现中受益。然而，Python的API很少改变。当发生更改时，整个Python社区都会付出代价——每个人都必须更新他们的客户端。因此，一旦有大量客户端使用一个模块，就尽量不要更改其API。
- en: Changing an implementation. ![Polar representation](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改实现。 ![极坐标表示](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)
- en: Consider the class `Complex`, defined in [complexpolar.py](complexpolar.py.html).
    It has the same name and API as the class `Complex` defined in [complex.py](../32class/complex.py.html)
    (from Section 3.2), but uses a different representation for the complex numbers.
    The `Complex` class defined in [complex.py](../32class/complex.py.html) uses the
    Cartesian representation, where instance variables `_re` and `_im` represent a
    complex number as *x* + *yi*. The `Complex` class defined in [complexpolar.py](complexpolar.py.html)
    uses the polar representation, where instance variables `_r` and `_theta` represent
    complex numbers as *r*(cos θ + *i* sin θ). In this representation, we refer to
    *r* as the *magnitude* and θ as the *polar angle*. The polar representation is
    of interest because certain operations on complex numbers are easier to perform
    in the polar representation. Addition and subtraction are easier in the Cartesian
    representation; multiplication and division are easier in the polar representation.
    The idea of encapsulation is that we can substitute one of these programs for
    the other (for whatever reason) without changing client code, except to change
    the `import` statement to use `complexpolar` instead of `complex`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[complexpolar.py](complexpolar.py.html)中定义的`Complex`类。它与[complex.py](../32class/complex.py.html)（来自第3.2节）中定义的`Complex`类具有相同的名称和API，但使用不同的复数表示。[complex.py](../32class/complex.py.html)中定义的`Complex`类使用笛卡尔表示，其中实例变量`_re`和`_im`表示复数为*x*
    + *yi*。[complexpolar.py](complexpolar.py.html)中定义的`Complex`类使用极坐标表示，其中实例变量`_r`和`_theta`表示复数为*r*(cos
    θ + *i* sin θ)。在这种表示中，我们将*r*称为*幅值*，θ称为*极角*。极坐标表示是有趣的，因为在极坐标表示中，对复数的某些操作更容易执行。加法和减法在笛卡尔表示中更容易；乘法和除法在极坐标表示中更容易。封装的思想是我们可以在不改变客户端代码的情况下将其中一个程序替换为另一个程序（无论出于何种原因），只需将`import`语句更改为使用`complexpolar`而不是`complex`。
- en: Private.
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有。
- en: 'Many programming languages provide support for enforcing encapsulation. For
    example, Java provides the `private` visibility modifier. When you declare an
    instance variable (or method) to be private, you are making it impossible for
    any client (code in another module) to directly access the instance variable (or
    method) that is the subject of the modifier. Python does not offer a `private`
    visibility modifier, which means that clients can directly access all instance
    variables, methods, and functions. However the Python programming community espouses
    a pertinent convention: if an instance variable, method, or function has a name
    that begins with an underscore, then clients should consider that instance variable,
    method, or function to be private. Through this naming convention, clients are
    informed that they should not directly access the instance variable, method, or
    function thus named.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言提供支持以强制实现封装。例如，Java提供了`private`可见性修饰���。当您将实例变量（或方法）声明为私有时，您使得任何客户端（另一个模块中的代码）无法直接访问修饰符所涉及的实例变量（或方法）。Python没有提供`private`可见性修饰符，这意味着客户端可以直接访问所有实例变量、方法和函数。然而，Python编程社区提倡一个相关的约定：如果一个实例变量、方法或函数的名称以下划线开头，那么客户端应该将该实例变量、方法或函数视为私有。通过这种命名约定，客户端被告知不应直接访问以这种方式命名的实例变量、方法或函数。
- en: In this booksite we always make all instance variables private in our classes.
    We strongly recommend that you do the same — there is no good reason to access
    an instance variable directly from a client.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个书站中，我们总是在我们的类中将所有实例变量设为私有的。我们强烈建议您也这样做——没有理由从客户端直接访问实例变量。
- en: Limiting the potential for error.
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制错误的可能性。
- en: 'Encapsulation also helps programmers ensure that their code operates as intended.
    For example, in the 2000 presidential election, Al Gore received *negative* 16,022
    votes on an electronic voting machine in Volusia County, Florida. The counter
    variable was not properly encapsulated in the voting machine software! To understand
    the problem, consider [counter.py](counter.py.html), which defines a simple `Counter`
    class according to this API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 封装还帮助程序员确保他们的代码按预期运行。例如，在2000年总统选举中，阿尔·戈尔在佛罗里达州沃卢西亚县的一台电子投票机上收到了负16,022票。计数器变量在投票机软件中没有被正确封装！要理解问题，请考虑[counter.py](counter.py.html)，它根据这个API定义了一个简单的`Counter`类：
- en: '![Counter API](../Images/4a991ecbac09acb9cb2f39b1e403f3e8.png)'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![计数器API](../Images/4a991ecbac09acb9cb2f39b1e403f3e8.png)'
- en: This abstraction is useful in many contexts, including, for example, an electronic
    voting machine. It encapsulates a single integer and ensures that the only operation
    that can be performed on the integer is increment by one. Therefore, it can never
    go negative. Proper encapsulation is far from a complete solution to the voting
    security problem, but it is a good start.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象在许多情况下都很有用，比如电子投票机。它封装了一个单一的整数，并确保唯一可以对该整数执行的操作是加一。因此，它永远不会变为负数。适当的封装远非是解决投票安全问题的完整解决方案，但却是一个很好的开始。
- en: Code clarity.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码清晰度。
- en: Precisely specifying a data type improves design because it leads to client
    code that can more clearly express its computation. You have seen many examples
    of such client code in Sections 3.1 and 3.2, from charged particles to pictures
    to complex numbers. One key to good design is to observe that code composed with
    the proper abstractions can be nearly self-documenting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 精确指定数据类型可以改善设计，因为它导致客户端代码可以更清晰地表达其计算。在第3.1节和第3.2节中，你已经看到了许多这样的客户端代码示例，从带电粒子到图片再到复数。良好设计的关键之一是观察到使用适当的抽象组合的代码几乎可以自我说明。
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Immutability
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: An object from a data type is *immutable* if its data-type value cannot change
    once created. An immutable data type, such as a Python string, is one in which
    all objects of that type are immutable. By contrast, a *mutable* data type, such
    as a Python list/array, is one in which objects of that type have values that
    are designed to change. Of the data types considered in this chapter, `Charge`,
    `Color`, and `Complex` are all immutable, and `Picture`, `Histogram`, `Turtle`,
    `StockAccount`, and `Counter` are all mutable. Whether to make a data type immutable
    is a fundamental design decision and depends on the application at hand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据类型的对象一旦创建就无法更改其数据类型值，则该数据类型的对象是*不可变*的。不可变数据类型，比如Python字符串，是所有该类型对象都是不可变的。相比之下，*可变*数据类型，比如Python列表/数组，是其对象的值被设计为可以改变的。在本章考虑的数据类型中，`Charge`、`Color`和`Complex`都是不可变的，而`Picture`、`Histogram`、`Turtle`、`StockAccount`和`Counter`都是可变的。是否使数据类型不可变是一个基本的设计决策，取决于手头的应用。
- en: Immutable data types.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变数据类型。
- en: The purpose of many data types is to encapsulate values that do not change.
    For example, a programmer implementing a `Complex` client might reasonably expect
    to compose the code `z = z0`, thus setting two variables to reference the same
    `Complex` object, in the same way as for floats or integers. But if `Complex`
    were mutable and the object referenced by `z` were to change after the assignment
    `z = z0`, then the object referenced by `z0` would also change (they are aliases,
    or both references to the same object). Conceptually, changing the value of `z`
    would change the value of `z0`! This unexpected result, known as an *aliasing
    bug*, comes as a surprise to many newcomers to object-oriented programming.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据类型的目的是封装不会改变的值。例如，一个程序员实现一个`Complex`客户端可能合理地期望组合代码`z = z0`，从而设置两个变量引用相同的`Complex`对象，就像对浮点数或整数一样。但是，如果`Complex`是可变的，并且在赋值`z
    = z0`之后被引用的对象发生变化，那么被`z0`引用的对象也会发生变化（它们是别名，或者都是对同一对象的引用）。从概念上讲，改变`z`的值将改变`z0`的值！这种意外的结果，称为*别名错误*，对许多初学者来说是一个惊喜，这是面向对象编程的一个重要概念。
- en: Mutable data types.
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变数据类型。
- en: For many other data types, the very purpose of the abstraction is to encapsulate
    values as they change. The `Turtle` class defined in [turtle.py](../32class/turtle.py.html)
    (from Section 3.2) is a prime example. Similarly, `Picture`, `Histogram`, `StockAccount`,
    `Counter`, and Python lists/arrays are all types where we expect values to change.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多其他数据类型，抽象的目的就是封装值随着变化而变化。在[turtle.py](../32class/turtle.py.html)（来自第3.2节）中定义的`Turtle`类就是一个典型例子。同样，`Picture`、`Histogram`、`StockAccount`、`Counter`和Python列表/数组都是我们期望值会改变的类型。
- en: Arrays and strings.
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和字符串。
- en: You have already encountered this distinction as a client programmer, when using
    Python lists/arrays (mutable) and Python strings (immutable). When you pass a
    string to a method/function, you do not need to worry about that method/function
    changing the sequence of characters in the string. In contrast, when you pass
    an array to a method/function, the method/function is free to change the elements
    of the array. Python strings are immutable because we generally do not want `str`
    values to change; Python arrays are mutable because we often do want array elements
    to change.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为客户端程序员，当使用Python列表/数组（可变）和Python字符串（不可变）时，你已经遇到了这种区别。当你将一个字符串传递给一个方法/函数时，你不��要担心该方法/函数改变字符串中的字符序列。相反，当你将一个数组传递给一个方法/函数时，该方法/函数可以自由地改变数组的元素。Python字符串是不可变的，因为我们通常不希望`str`值发生变化；Python数组是可变的，因为我们经常希望数组元素发生变化。
- en: Advantages of immutability.
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性的优势。
- en: Generally, immutable data types are easier to use and harder to misuse because
    the scope of code that can change object values is far smaller than for mutable
    types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不可变数据类型更容易使用，更难被误用，因为能够改变对象值的代码范围远比可变类型小得多。
- en: Cost of immutability.
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性的代价。
- en: The downside of immutability is that you must create a new object for every
    value. For example, when you are using the `Complex` data type, the expression
    `z = z*z + z0` involves creating a third object (to hold the value `z*z`), then
    using that object with the `+` operator (without saving an explicit reference
    to it) and creating a fourth object to hold the value `z*z + z0`, and assigning
    that object to `z` (thereby orphaning the original reference to `z`). A program
    such as [mandelbrot.py](../32class/mandelbrot.py.html) (from Section 3.2) creates
    a huge number of such intermediate objects. However, this expense is normally
    manageable because Python's memory management is typically optimized for such
    situations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的缺点是你必须为每个值创建一个新对象。例如，当你使用`Complex`数据类型时，表达式`z = z*z + z0`涉及创建第三个对象（用于保存值`z*z`），然后使用该对象与`+`运算符（不保存显式引用）并创建第四个对象来保存值`z*z
    + z0`，并将该对象分配给`z`（从而使原始引用`z`变为孤立）。一个程序，比如[mandelbrot.py](../32class/mandelbrot.py.html)（来自第3.2节），会创建大量这样的中间对象。然而，这种开销通常是可以接受的，因为
    Python 的内存管理通常针对这种情况进行了优化。
- en: Defensive copies.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防御性复制。
- en: 'Suppose that we wish to develop an immutable data type named `Vector`, whose
    constructor takes an array of floats as an argument to initialize an instance
    variable. Consider this attempt:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望开发一个名为`Vector`的不可变数据类型，其构造函数接受一个浮点数数组作为参数来初始化一个实例变量。考虑以下尝试：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code makes `Vector` a mutable data type. A client program could create
    a `Vector` object by specifying the elements in an array, and then (bypassing
    the API) change the elements of the Vector after creation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使`Vector`成为一个可变数据类型。客户程序可以通过指定数组中的元素来创建一个`Vector`对象，然后（绕过 API）在创建后更改 Vector
    的元素：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To ensure immutability of a data type that includes an instance variable of
    a mutable type, the implementation needs to make a local copy, known as a *defensive
    copy*. Recall from Section 1.4 that the expression `a[:]` creates a copy of array
    `a[]`. As a consequence, this code creates a defensive copy:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保包含可变类型实例变量的数据类型的不可变性，实现需要进行本地复制，称为*防御性复制*。回想一下第1.4节中，表达式`a[:]`创建了数组`a[]`的一个副本。因此，这段代码创建了一个防御性复制：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we consider a full implementation of such a data type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑这种数据类型的完整实现。
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Spatial vectors'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：空间向���
- en: '![A spatial vector](../Images/7bcd03654bc1ff810fadf378383d7517.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![一个空间向量](../Images/7bcd03654bc1ff810fadf378383d7517.png)'
- en: 'A *spatial vector* is an abstract entity that has a magnitude and a direction.
    Spatial vectors provide a natural way to describe properties of the physical world,
    such as force, velocity, momentum, or acceleration. One standard way to specify
    a vector is as an arrow from the origin to a point in a Cartesian coordinate system:
    the direction is the ray from the origin to the point and the magnitude is the
    length of the arrow (distance from the origin to the point). To specify the vector,
    it suffices to specify the point.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*空间向量* 是一个具有大小和方向的抽象实体。空间向量提供了一种自然的方式来描述物理世界的属性，如力、速度、动量或加速度。一种标准的指定向量的方式是作为从原点到笛卡尔坐标系中一点的箭头：方向是从原点到点的射线，大小是箭头的长度（从原点到点的距离）。为了指定向量，只需指定点即可。'
- en: 'This concept extends to any number of dimensions: an ordered list of *n* real
    numbers (the coordinates of an *n*-dimensional point) suffices to specify a vector
    in *n*-dimensional space. By convention, we use a boldface letter to refer to
    a vector and numbers or indexed variable names (the same letter in italics) separated
    by commas within parentheses to denote its value. For example, we might use **x**
    to denote the vector (*x*[0], *x*[1], ..., *x*[*n*-1]) and **y** to denote the
    vector (*y*[0], *y*[1], ..., *y*[*n*-1]).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以扩展到任意维度：一个包含*n*个实数的有序列表（一个*n*维点的坐标）足以指定*n*维空间中的一个向量。按照惯例，我们使用粗体字母来表示一个向量，用逗号分隔的数字或带下标的变量名（斜体字母相同）在括号内表示其值。例如，我们可以用**x**表示向量(*x*[0],
    *x*[1], ..., *x*[*n*-1])，用**y**表示向量(*y*[0], *y*[1], ..., *y*[*n*-1])。
- en: API.
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API。
- en: 'The basic operations on vectors are to add two vectors, multiply a vector by
    a scalar (a real number), compute the dot product of two vectors, and compute
    the magnitude and direction, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的基本操作是将两个向量相加，将一个向量乘以一个标量（一个实数），计算两个向量的点积，以及计算大小和方向，如下所示：
- en: '*Addition*: **x** + **y** = (*x*[0] + *y*[0], *x*[1] + *y*[1], ..., *x*[*n*-1]
    + *y*[*n*-1])'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法*：**x** + **y** = (*x*[0] + *y*[0], *x*[1] + *y*[1], ..., *x*[*n*-1] + *y*[*n*-1])'
- en: '*Scalar product*: α**x** = (α*x*[0], α*x*[1], ..., α*x*[*n*-1])'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标量乘积*：α**x** = (α*x*[0], α*x*[1], ..., α*x*[*n*-1])'
- en: '*Dot product*: **x** · **y** = *x*[0]*y*[0] + *x*[1]*y*[1] + ... + *x*[*n*-1]*y*[*n*-1]'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*点积*：**x** · **y** = *x*[0]*y*[0] + *x*[1]*y*[1] + ... + *x*[*n*-1]*y*[*n*-1]'
- en: '*Magnitude*: |**x**| = (*x*[0]² + *x*[1]² + ... + *x*[*n*-1]²)^(1/2)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大小*：|**x**| = (*x*[0]² + *x*[1]² + ... + *x*[*n*-1]²)^(1/2)'
- en: '*Direction*: **x** / |**x**| = (*x*[0] / |**x**|, *x*[1] / |**x**|, ..., *x*[*n*-1]
    / |**x**|)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方向*：**x** / |**x**| = (*x*[0] / |**x**|, *x*[1] / |**x**|, ..., *x*[*n*-1]
    / |**x**|)'
- en: 'Those definitions lead to this API:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义导致了以下 API：
- en: '![Vector API](../Images/b5292127553bed9ace9654f9cf0b4a08.png)'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![向量 API](../Images/b5292127553bed9ace9654f9cf0b4a08.png)'
- en: As with `Complex`, this API does not explicitly specify that the data type is
    immutable, but we know that client programmers (who are likely to be thinking
    in terms of the mathematical abstraction) will certainly expect that convention,
    and perhaps we would rather not explain to them that we are trying to protect
    them from aliasing bugs!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Complex`一样，这个 API 并没有明确指定数据类型是不可变的，但我们知道客户程序员（可能会以数学抽象的方式思考）肯定会期望这种约定，也许我们宁愿不向他们解释我们试图保护他们免受别名错误的影响！
- en: Representation.
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示。
- en: Our first choice in developing an implementation is to choose a representation
    for the data. Using an array to hold the Cartesian coordinates provided in the
    constructor is a clear choice, but not the only reasonable choice. If warranted,
    the implementation can change the coordinate system without affecting client code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发实现时，我们的第一选择是为数据选择一个表示。使用数组保存构造函数中提供的笛卡尔坐标是一个明显的选择，但不是唯一合理的选择。如果有必要，实现可以更改坐标系而不影响客户端代码。
- en: Implementation.
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现。
- en: Given the representation, the code that implements all of these operations is
    straightforward, as you can see in the `Vector` class defined in [vector.py](vector.py.html).
    The constructor makes a defensive copy of the client array and none of the methods
    assigns a value to the copy, so that `Vector` objects are immutable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 给定表示，实现所有这些操作的代码是直接的，你可以在[vector.py](vector.py.html)中定义的`Vector`类中看到。构造函数对客户端数组进行了防御性拷贝，而且没有任何方法给拷贝赋值，因此`Vector`对象是不可变的。
- en: 'How can we ensure immutability when it seems that the client is free to compose
    code like `x[i] = 2.0`? The answer to this question lies in a special method that
    we do not implement in an immutable data type: in such a case, Python calls the
    special method `__setitem__()` instead of `__getitem__()`. Since `Vector` does
    not implement that method, such client code would raise an `AttributeError` at
    run time.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端可以自由组合代码如`x[i] = 2.0`时，我们如何确保不可变性？这个问题的答案在于一个特殊的方法，我们在不可变数据类型中不实现：在这种情况下，Python调用特殊方法`__setitem__()`而不是`__getitem__()`。由于`Vector`没有实现该方法，这样的客户端代码会在运行时引发`AttributeError`。
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Tuples
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'Python''s built-in `tuple` data type represents an *immutable* sequence of
    objects. It is similar to the built-in `list` data type (which we use for arrays),
    except that once you create a tuple, you cannot change its items. You can manipulate
    tuples using familiar array notation, as documented in this API:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置`tuple`数据类型表示一个*不可变*对象序列。它类似于内置的`list`数据类型（我们用于数组），不同之处在于一旦创建了元组，就不能更改其项。你可以使用熟悉的数组表示法来操作元组，如本API中所述：
- en: '![Tuple API (partial)](../Images/352e5b621c171f38278840c25ae5d5ed.png)'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![元组 API（部分）](../Images/352e5b621c171f38278840c25ae5d5ed.png)'
- en: You can create tuples either using the built-in function tuple() or by listing
    a sequence of expressions, separated by commas, and (optionally) enclosed in matching
    parentheses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置函数`tuple()`创建元组，也可以通过列出一系列用逗号分隔的表达式，并（可选）用匹配的括号括起来。
- en: Using tuples can improve the design of a program. For example, if we replace
    the first statement in the constructor of [vector.py](vector.py.html) with
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组可以改善程序的设计。例如，如果我们用以下语句替换[vector.py](vector.py.html)构造函数中的第一条语句
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: then any attempt to change a vector coordinate within the Vector class raises
    a `TypeError` at run time, helping to enforce immutability of `Vector` objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么任何尝试在Vector类内部更改向量坐标的操作都会在运行时引发`TypeError`，有助于强制执行`Vector`对象的不可变性。
- en: 'Python also provides a powerful tuple assignment feature known as *tuple packing*
    and *tuple unpacking* that lets you assign a tuple of expressions on the right-hand
    side of an assignment operator to a tuple of variables on the left-hand side (provided
    the number of variables on the left matches the number of expressions on the right).
    You can use this feature to assign multiple variables simultaneously. For example,
    the following statement exchanges the object references in variable `x` and `y`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了一个强大的元组赋值功能，称为*元组打包*和*元组解包*，它允许你将右侧赋值运算符上的表达式元组分配给左侧的变量元组（前提是左侧的变量数量与右侧的表达式数量相匹配）。你可以使用这个功能同时赋值多个变量。例如，以下语句交换了变量`x`和`y`中的对象引用：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also use tuple packing and unpacking to return multiple values from
    a function (see an exercise at the end of this section).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用元组打包和解包从函数中返回多个值（请参见本节末尾的一个练习）。
- en: '* * *'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Polymorphism
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: Often, when we compose methods (or functions), we intend for them to work only
    with objects of specific types. Sometimes, we want them to work with objects of
    different types. A method (or function) that can take arguments with different
    types is said to be *polymorphic*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们组合方法（或函数）时，我们打算它们只能与特定类型的对象一起使用。有时，我们希望它们能够与不同类型的对象一起使用。一个可以接受不同类型参数的方法（或函数）被称为*多态的*。
- en: 'The best kind of polymorphism is the unexpected kind: when you apply an existing
    method/function to a new data type (for which you never planned) and discover
    that the method/function has exactly the behavior that you wanted. The worst kind
    of polymorphism is also the unexpected kind: when you apply an existing method/function
    to a new data type and it returns the wrong answer! Finding a bug of this sort
    can be an extraordinary challenge.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的多态是意想不到的：当你将一个现有的方法/函数应用于一个新的数据类型（你从未计划过的）时，发现该方法/函数恰好具有你想要的行为。最糟糕的多态也是意想不到的：当你将一个现有的方法/函数应用于一个新的数据类型时，它返回错误的答案！发现这种错误可能是一个非凡的挑战。
- en: Duck typing.
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型。
- en: Duck typing is a programming style in which the language does not formally specify
    the requirements for a function's arguments; instead, it just tries to call the
    function if a compatible one is defined (and raises a run-time error otherwise).
    The name comes from an old quote attributed to the poet J. W. Riley:*When I see
    a bird that
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型是一种编程风格，语言不正式指定函数参数的要求；相反，它只是尝试调用定义了兼容函数的函数（否则会引发运行时错误）。这个名字来自一句被归因于诗人J.W.莱利的古老引语：*当我看到一只鸟
- en: walks like a duck and swims like a duck and quacks like a duck
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 走起来像鸭子，游泳像鸭子，嘎嘎叫像鸭子
- en: I call that bird a duck*
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我称那只鸟为鸭子*
- en: In Python, if an object walks like a duck, swims like a duck, and quacks like
    a duck, you can treat that object as a duck; you don't need to explicitly declare
    it to be a duck. In many languages (such as Java or C++), you do need to explicitly
    declare the types of variables, but not in Python — Python uses duck typing for
    all operations (function calls, method calls, and operators). It raises a `TypeError`
    at run time if an operation cannot be applied to an object because it is of an
    inappropriate type. This approach leads to simpler and more flexible client code
    and puts the focus on operations that are actually used rather than the type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，如果一个对象像鸭子一样走路，游泳，嘎嘎叫，你可以将该对象视为鸭子；你不需要明确声明它是鸭子。在许多语言（如Java或C++）中，您需要明确声明变量的类型，但在Python中不需要
    — Python对所有操作（函数调用，方法调用和运算符）使用鸭子类型。如果由于不适当的类型而无法将操作应用于对象，则它会在运行时引发`TypeError`。这种方法导致客户端代码更简单、更灵活，并将重点放在实际使用的操作上，而不是类型上。
- en: Disadvantages of duck typing.
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型的缺点。
- en: The primary disadvantage of duck typing is that it is difficult to know precisely
    what the contract is between the client and the implementation, especially when
    a required method is needed only indirectly. The API simply does not carry this
    kind of information. This lack of information can lead to run-time errors. Worse,
    the end result can be semantically incorrect, with no error raised at all. Next,
    we consider a simple example of this situation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型的主要缺点是很难准确知道客户端和实现之间的契约是什么，特别是当需要的方法只间接需要时。API简单地不携带这种信息。这种信息的缺乏可能导致运行时错误。更糟糕的是，最终结果可能在语义上不正确，而根本没有引发错误。接下来，我们考虑这种情况的一个简单示例。
- en: A case in point.
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个案例。
- en: We designed our `Vector` data type under the implicit assumption that the vector
    components would be floats and that the client would create a new vector by passing
    an array of `float` objects to the constructor. If the client creates two vectors
    `x` and `y` in this way, then both `x[i]` and `x.dot(y)` return floats and both
    `x + y` and `x - y` return vectors with float components, as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计我们的`Vector`数据类型时，隐含地假设向量分量��是浮点数，并且客户端将通过将`float`对象数组传递给构造函数来创建一个新向量。如果客户端以这种方式创建两个向量`x`和`y`，那么`x[i]`和`x.dot(y)`都返回浮点数，`x
    + y`和`x - y`都返回具有浮点分量的向量，如预期的那样。
- en: Suppose, instead, that a client creates a `Vector` with integer components by
    passing an array of `int` objects to the constructor. If the client creates two
    vectors `x` and `y` in this manner, then both `x[i]` and `x.dot(y)` return integers
    and both `x + y` and `x - y` return vectors with integer components, as desired.
    Of course, `abs(x)` returns a `float` and `x.direction()` returns a vector with
    `float` components. This is the best kind of polymorphism, where duck typing works
    serendipitously.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，相反地，一个客户通过将`int`对象数组传递给构造函数来创建具有整数分量的`Vector`。如果客户以这种方式创建两个向量`x`和`y`，那么`x[i]`和`x.dot(y)`都返回整数，`x
    + y`和`x - y`都返回具有整数分量的向量，如所需。当然，`abs(x)`返回一个`float`，而`x.direction()`返回一个具有`float`分量的向量。这是最好的多态性，其中鸭子类型恰好起作用。
- en: 'Now, suppose that a client creates a `Vector` with complex components by passing
    an array of `complex` objects to the constructor. There is no problem with vector
    addition or scalar multiplication, but the implementation of the dot product operation
    (along with the implementations of magnitude and direction, which depend on the
    dot product) fails spectacularly. Here is an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个客户通过将`complex`对象数组传递给构造函数来创建具有复数分量的`Vector`。向量加法或标量乘法没有问题，但点积操作的实现（以及依赖于点积的幅度和方向的实现）却失败得惊人。这里是一个例子：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code results in a `TypeError` at run time, with `math.sqrt()` trying to
    take the square root of a complex number. The problem is that the dot product
    of two complex-valued vectors **x** and **y** requires taking the *complex conjugate*
    of the elements in the second vector. The textbook describes the problem and its
    solution in detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在运行时导致`TypeError`，因为`math.sqrt()`试图对一个复数取平方根。问题在于两个复值向量**x**和**y**的点积需要取第二个向量中元素的*复共轭*。教科书详细描述了问题及其解决方案。
- en: In this case, duck typing is the worst kind of polymorphism. It is certainly
    reasonable for a client to expect the implementation of `Vector` to work properly
    when vector components are complex numbers. How can an implementation anticipate
    and prepare for all potential uses of a data type? This situation presents a design
    challenge that is impossible to meet. All we can do is caution you to check, if
    possible, that any data type that you use can handle the types of data that you
    intend to use with it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，鸭子类型是最糟糕的多态性。当向量分量是复数时，客户端期望`Vector`的实现能够正常工作是完全合理的。一个实现如何能够预期并准备好处理数据类型的所有潜在用途呢？这种情况提出了一个不可能满足的设计挑战。我们所能做的就是警告您，尽可能检查您使用的任何数据类型是否能够处理您打算与之一起使用的数据类型。
- en: '* * *'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Overloading
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载
- en: The ability to define a data type that provides its own definitions of operators
    is a form of polymorphism known as *operator overloading*. In Python, you can
    overload almost every operator, including operators for arithmetic, comparisons,
    indexing, and slicing. You can also overload built-in functions, including absolute
    value, length, hashing, and type conversion. Overloading operators and built-in
    functions makes user-defined types behave more like built-in types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义提供其自己的运算符定义的数据类型的能力是一种称为*运算符重载*的多态性形式。在Python中，您几乎可以重载每个运算符，包括算术、比较、索引和切片运算符。您还可以重载内置函数，包括绝对值、长度、哈希和类型转换。重载运算符和内置函数使用户定义的类型更像内置类型。
- en: To perform an operation, Python internally converts the expression into a call
    on the corresponding special method; to call a built-in function, Python internally
    calls the corresponding special method instead. To overload an operator or built-in
    function, you include an implementation of the corresponding special method with
    your own code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为执行操作，Python内部将表达式转换为对应特殊方法的调用；要调用内置函数，Python内部调用相应的特殊方法。要重载运算符或内置函数，您需要在自己的代码中包含相应特殊方法的实现。
- en: Arithmetic operators.
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符。
- en: Python associates a special method with each of its arithmetic operators, so
    you can overload any arithmetic operation by implementing the corresponding special
    method, as detailed in this table.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python为其每个算术运算符关联一个特殊方法，因此您可以通过实现相应的特殊方法来重载任何算术操作，详细��息请参见此表。
- en: '![Special methods for arithmetic operations](../Images/c23633d9f15ef3a334e80edd9533430d.png)'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![算术运算的特殊方法](../Images/c23633d9f15ef3a334e80edd9533430d.png)'
- en: Equality.
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等性。
- en: '![Three variables refering to two Charge objects](../Images/68c932f776df7152fe535677777e13c0.png)
    The `==` and `!=` operators for testing equality require special attention. For
    example, consider the code in the diagram at right, which creates two `Charge`
    objects, referenced by three variables `c1`, `c2`, and `c3`. As illustrated in
    the diagram, `c1` and `c3` both reference the same object, which is different
    from the one referenced by `c2`. Clearly, `c1 == c3` is `True`, but what about
    `c1 == c2`? The answer to this question is unclear because there are two ways
    to think about equality in Python:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![三个变量引用两个Charge对象](../Images/68c932f776df7152fe535677777e13c0.png) 用于测试相等性的`==`和`!=`运算符需要特别注意。例如，考虑右侧图中的代码，它创建了两个由三个变量`c1`、`c2`和`c3`引用的`Charge`对象。正如图中所示，`c1`和`c3`都引用相同的对象，这与`c2`引用的对象不同。显然，`c1
    == c3`为`True`，但`c1 == c2`呢？对于这个问题的答案不明确，因为在Python中有两种思考相等性的方式：'
- en: '*Reference equality* (*identity equality*). Reference equality holds when two
    references are equal — they refer to the same object. The built in function `id()`
    gives the identity of an object (its memory address); the `is` and `is not` operators
    test whether two variables refer to the same object. That is, the implementation
    of `c1 is c2` tests whether `id(c1)` and `id(c2)` are the same. In our example,
    `c1 is c3` is `True` as expected, but `c1 is c2` is `False` because `c1` and `c2`
    reside at different memory addresses.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用相等性*（*标识相等性*）。当两个引用相等时，它们指向同一个对象。内置函数`id()`给出对象的标识（其内存地址）；`is`和`is not`运算符测试两个变量是否引用同一个对象。也就是说，`c1
    is c2`的实现测试`id(c1)`和`id(c2)`是否相同。在我们的例子中，`c1 is c3`如预期的那样是`True`，但`c1 is c2`是`False`，因为`c1`和`c2`位于不同的内存地址。'
- en: '*Object equality* (*value equality*). Object equality holds when two objects
    are equal — they have the same data-type value. You should use the `==` and `!=`
    operators, defined using the special methods `__eq__()` and `__ne__()`, to test
    for object equality. If you do not define an `__eq__()` method, then Python substitutes
    the `is` operator. That is, by default `==` implements reference equality. So,
    in our earlier example, `c1 == c2` is `False` even though `c1` and `c2` have the
    same position and charge value. If we want two charges with identical position
    and charge value to be considered equal, we can ensure this outcome by including
    the following code in [charge.py](../32class/charge.py.html) (from Section 3.2):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象相等性*（*值相等性*）。当两个对象相等时，它们具有相同的数据类型值。您应该使用`==`和`!=`运算符，这些运算符是使用特殊方法`__eq__()`和`__ne__()`定义的，用于测试对象的相等性。如果您没有定义`__eq__()`方法，那么Python会使用`is`运算符。也就是说，默认情况下，`==`实现引用相等性。因此，在我们之前的例子中，即使`c1`和`c2`具有相同的位置和电荷值，`c1
    == c2`也是`False`。如果我们希望将具有相同位置和电荷值的两个电荷视为相等，则可以通过在[charge.py](../32class/charge.py.html)（来自第3.2节）中包含以下代码来确保这一结果：'
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code in place, `c1 == c2` is now True in our example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们的例子中现在`c1 == c2`为True。
- en: Hashing.
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希。
- en: 'We now consider a fundamental operation related to equality testing, known
    as *hashing*, that maps an object to an integer, known as a *hash code*. This
    operation is so important that it is handled by Python''s special method `__hash__()`
    in support of the built-in `hash()` function. We refer to an object as `hashable`
    if it satisfies the following three properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑与相等性测试相关的基本操作，称为*哈希*，它将对象映射到一个整数，称为*哈希码*。这个操作非常重要，Python通过支持内置的`hash()`函数的特殊方法`__hash__()`来处理它。如果对象满足以下三个属性，则我们将对象称为`可哈希`：
- en: The object can be compared for equality with other objects via the == operator.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`==`运算符，可以将对象与其他对象进行相等性比较。
- en: Whenever two objects compare as equal, they have the same hash code.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当两个对象比较相等时，它们具有相同的哈希码。
- en: The object's hash code does not change during its lifetime.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的哈希码在其生命周期中不会更改。
- en: In typical applications, we use the hash code to map an object `x` to an integer
    in a small range, say between 0 and `m`-1, using the hash function
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型应用中，我们使用哈希码将对象`x`映射到一个小范围内的整数，例如在0和`m`-1之间，使用哈希函数
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, we can use the hash function value as an integer index into an array of
    length `m` (see the [sketch.py](sketch.py.html) program described later in this
    section and the [hashst.py](../44st/hashst.py.html) program described in Section
    4.4). All of Python's immutable data types (including `int`, `float`, `str`, and
    `tuple`) are hashable and engineered to distribute the objects in a reasonable
    manner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用哈希函数值作为整数索引到长度为`m`的数组中（请参阅本节后面描述的[sketch.py](sketch.py.html)程序和第4.4节中描述的[hashst.py](../44st/hashst.py.html)程序）。Python的所有不可变数据类型（包括`int`、`float`、`str`和`tuple`）都是可哈希的，并且被设计为以合理的方式分布对象。
- en: 'You can make a user-defined data type hashable by implementing the two special
    methods `__hash__()` and `__eq__()`. Crafting a good hash function requires a
    deft combination of science and engineering, and is beyond the scope of this booksite.
    Instead, we describe a simple recipe for doing so in Python that is effective
    in a wide variety of situations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现两个特殊方法`__hash__()`和`__eq__()`，你可以使用户定义的数据类型可哈希。设计一个良好的哈希函数需要科学和工程的巧妙结合，这超出了本书的范围。��反，我们在Python中描述了一个简单的方法，该方法在各种情况下都很有效：
- en: Ensure that the data type is immutable.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据类型是不可变的。
- en: Implement `__eq__()` by comparing all significant instance variables.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过比较所有重要的实例变量来实现`__eq__()`。
- en: Implement `__hash__()` by putting the same instance variables into a tuple and
    calling the built-in `hash()` function on the tuple.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将相同的实例变量放入元组并在元组上调用内置的`hash()`函数来实现`__hash__()`。
- en: 'For example, following is a `__hash__()` implementation for the `Charge` data
    type (defined in [charge.py](../32class/charge.py.html) from Section 3.2) to accompany
    the `__eq__()` implementation that we just considered:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是`Charge`数据类型（在[charge.py](../32class/charge.py.html)中定义，来自第3.2节）的`__hash__()`实现，以配合我们刚刚考虑的`__eq__()`实现：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comparison operators.
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符。
- en: 'Similarly, comparisons like `x < y` and `x >= y` are not just for integers,
    floats, and strings in Python. Again, Python associates a special method with
    each of its comparison operators, so you can overload any comparison operator
    by implementing the corresponding special method, as detailed in this table:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Python中，像`x < y`和`x >= y`这样的比较不仅适用于整数、浮点数和字符串。再次，Python为每个比较运算符关联了一个特殊方法，因此你可以通过实现相应的特殊方法来重载任何比较运算符，详细信息请参考下表：
- en: '![Special methods for comparison operations](../Images/2117176e80623b85b4db52e451bae6e8.png)'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![比较操作的特殊方法](../Images/2117176e80623b85b4db52e451bae6e8.png)'
- en: 'As a matter of style, if you define any one of the comparison methods, then
    you should define all of them, and in a consistent manner. You can make a user-defined
    type *comparable* by implementing the six special methods, as we do here for the
    `Counter` class defined in [counter.py](counter.py.html):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种风格，如果你定义了任何一个比较方法，那么你应该以一致的方式定义所有这些方法。你可以通过实现六个特殊方法使用户定义的类型*可比较*，就像我们在[counter.py](counter.py.html)中为`Counter`类所做的那样：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other operators.
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他运算符。
- en: Almost every operator in Python can be overloaded. If you want to overload an
    operator, you can track down the corresponding special method in the [official
    Python documentation](https://docs.python.org/3/reference/datamodel.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python中几乎每个运算符都可以被重载。如果你想重载一个运算符，你可以在[官方Python文档](https://docs.python.org/3/reference/datamodel.html)中找到相应的特殊方法。
- en: Built-in functions.
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置函数。
- en: We have been overloading the built-in function `str()` in every class we develop,
    and there are several other built-in functions that we can overload in the same
    way. The ones that we use in this book are summarized in the table below. We have
    already used all of these functions, except for `iter()`, which we defer until
    Section 4.4.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在每个我们开发的类中重载内置函数`str()`，还有其他几个内置函数可以以相同的方式重载。我们在本书中使用的这些函数已总结在下表中。我们已经使用了所有这些函数，除了`iter()`，我们将在第4.4节中推迟使用。
- en: '![Special methods for built-in functions](../Images/0e4d725442ea235e5433c2e3af4a5f24.png)'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![内置函数的特殊方法](../Images/0e4d725442ea235e5433c2e3af4a5f24.png)'
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Functions are Objects
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是对象
- en: In Python, *everything* is an object, including functions. This means that you
    can use functions as arguments to functions and return them as results. Defining
    so-called *higher-order functions* that manipulate other functions is common both
    in mathematics and in scientific computing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*一切*都是对象，包括函数。这意味着你可以将函数用作函数的参数并将它们作为结果返回。定义所谓的*高阶函数*，用于操作其他函数，在数学和科学计算中都很常见。
- en: '![Approximating an integral](../Images/e8da3e02b82c92bb77b3cc50c8fbc541.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![近似积分](../Images/e8da3e02b82c92bb77b3cc50c8fbc541.png)'
- en: 'As an example, consider the problem of estimating the *Riemann integral* (that
    is, the area under the curve) of a positive real-valued function *f*. Perhaps
    the simplest approach is known as the *rectangle rule*, where we approximate the
    value of the integral by computing the total area of *n* equal-width rectangles
    under the curve. The `integrate()` function defined below evaluates the integral
    of a real-valued function *f*() in the interval (*a*, *b*), using the rectangle
    rule with *n* rectangles:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑估计正实值函数*f*的*黎曼积分*（即曲线下的面积）的问题。也许最简单的方法是称为*矩形法*，在这种方法中，我们通过计算曲线下*n*个等宽矩形的总面积来近似积分的值。下面定义的`integrate()`函数评估了在区间(*a*,
    *b*)中实值函数*f*()的积分，使用*n*个矩形的矩形法：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '* * *'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Inheritance
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Python provides language support for defining relationships among classes, known
    as *inheritance*. Software developers use inheritance widely, so you will study
    it in detail if you take a course in software engineering. Effective use of inheritance
    is beyond the scope of this booksite, but we briefly describe it here because
    there are a few situations where you may encounter it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了定义类之间关系的语言支持，称为*继承*。软件开发人员广泛使用继承，因此如果你学习软件工程课程，你将详细学习它。有效使用继承超出了本书的范围，但我们在这里简要描述它，因为有一些情况下你可能会遇到它。
- en: When used properly, inheritance enables a form of code reuse known as *subclassing*.
    The idea is to define a new class (*subclass*, or *derived class*) that inherits
    instance variables and methods from another class (*superclass*, or *base class*).
    The subclass contains more methods than the superclass. Systems programmers use
    subclassing to build so-called *extensible* modules. The idea is that one programmer
    (even you) can add methods to a class built by another programmer (or, perhaps,
    a team of systems programmers), effectively reusing the code in a potentially
    huge module. This approach is widely used, particularly in the development of
    user interfaces, so that the large amount of code required to provide all the
    facilities that users expect (drop-down menus, cut-and-paste, access to files,
    and so forth) can be reused.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，继承使得一种称为*子类化*的代码重用成为可能。其思想是定义一个继承自另一个类（*超类*或*基类*）的新���（*子类*或*派生类），该子类继承自实例变量和方法。子类包含的方法比超类更多。系统程序员使用子类化来构建所谓的*可扩展*模块。其思想是一个程序员（甚至是您）可以向另一个程序员（或者可能是一组系统程序员）构建的类添加方法，有效地重用潜在庞大模块中的代码。这种方法被广泛使用，特别是在用户界面的开发中，以便可以重用提供用户所期望的所有功能所需的大量代码（下拉菜单、剪切和粘贴、访问文件等）。
- en: Despite its advantages, the use of subclassing is controversial, even among
    systems programmers. We do not use it in this booksite because it generally works
    against encapsulation. Subclassing makes modular programming more difficult for
    two reasons. First, any change in the superclass affects all subclasses. The subclass
    cannot be developed independently of the superclass; indeed, it is completely
    dependent on the superclass. This problem is known as the *fragile base class
    problem*. Second, the subclass code, having access to instance variables, can
    subvert the intention of the superclass code. For example, the designer of a class
    such as `Vector` may have taken great care to make the `Vector` immutable, but
    a subclass, with full access to the instance variables, can just change them,
    wreaking havoc for any client assuming the class to be immutable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它有优点，但子类化的使用在系统程序员中是有争议的。我们在这个书站上没有使用它，因为它通常违反了封装。子类化使得模块化编程变得更加困难，原因有两个。首先，超类的任何更改都会影响所有子类。子类无法独立于超类开发；事实上，它完全依赖于超类。这个问题被称为*脆弱基类问题*。其次，子类代码可以破坏超类代码的意图，因为它可以访问实例变量。例如，类似`Vector`的类的设计者可能非常小心地使`Vector`不可变，但是子类可以访问实例变量，可以随意更改它们，给任何假设该类是不可变的客户端带来混乱。
- en: '* * *'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Application: Data Mining'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用：数据挖掘
- en: To illustrate some of the concepts discussed in this section in the context
    of an application, we next consider a software technology that is proving important
    in addressing the daunting challenges of *data mining* — that is, the process
    of searching through massive amounts of information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序的背景下说明本节讨论的一些概念，我们接下来考虑一个在解决*数据挖掘*中令人生畏的挑战方面变得重要的软件技术，即搜索大量信息的过程。
- en: 'For simplicity, we will restrict our attention to text documents (though the
    approach we will consider applies to pictures, music, and all sorts of other files
    as well). Even with this restriction, there is remarkable diversity in the types
    of documents. For reference, you can find these documents on the booksite:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将限制注意力在文本文档上（尽管我们将考虑的方法也适用于图片、音乐和各种其他文件）。即使有了这个限制，文档类型的多样性仍然显著。您可以在书站上找到这些文档的参考：
- en: '![Some text documents](../Images/5631eebfd66ce4d49fe4dc7cb1e09df3.png)'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![一些文本文档](../Images/5631eebfd66ce4d49fe4dc7cb1e09df3.png)'
- en: 'Our interest is in finding efficient ways to search through the files using
    their content to characterize documents. One fruitful approach to this problem
    is to associate with each document a vector known as a *sketch*, which is an ultra-compact
    representation of its content. The basic idea is that the sketch should capture
    salient statistical features of the document, so that documents that are different
    have sketches that are "different" and documents that are similar have sketches
    that are "similar." These considerations lead to this API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的兴趣在于找到使用文件内容搜索的高效方法来表征文档。解决这个问题的一个富有成果的方法是为每个文档关联一个称为*草图*的向量，它是文档内容的超紧凑表示。基本思想是草图应该捕捉文档的显著统计特征，以便不同的文档具有“不同”的草图，相似的文档具有“相似”的草图。这些考虑导致了这个API：
- en: '![Sketch API](../Images/34024d9cc055209284bd15cb0d2e90c8.png)'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![草图API](../Images/34024d9cc055209284bd15cb0d2e90c8.png)'
- en: The arguments of the constructor are a string and two integers that control
    the quality of the sketch. Clients can use `similarTo()` to determine the extent
    of similarity between two sketches on a scale of 0 (not similar) to 1 (similar).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的参数是一个字符串和两个控制草图质量的整数。客户端可以使用`similarTo()`来确定两个草图之间相似程度的范围，从0（不相似）到1（相似）。
- en: Computing sketches.
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算草图。
- en: 'Computing a sketch of a document is the first challenge. Our first choice is
    to use a `Vector` to represent a document''s sketch. Our implementation [sketch.py](sketch.py.html)
    uses a simple frequency count approach. In addition to the string, the constructor
    has two arguments, an integer *k* and a vector dimension *d*. It scans the document
    and examines all of the *k*-grams in the document — that is, the substrings of
    length *k* starting at each position. In its simplest form, the sketch is a vector
    that gives the relative frequency of occurrence of the *k*-grams in the string:
    an element for each possible *k*-gram giving the number of *k*-grams in the document
    that have that value.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 计算文档的草图是第一个挑战。我们的第一个选择是使用`Vector`来表示文档的草图。我们的实现[sketch.py](sketch.py.html)使用了简单的频率计数方法。除了字符串外，构造函数还有两个参数，一个整数*k*和一个向量维度*d*。它扫描文档并检查文档中的所有*k*-gram
    — 即，从每个位置开始的长度为*k*的子字符串。在其最简单的形式中，草图是一个向量，给出了字符串中*k*-gram出现的相对频率：为每个可能的*k*-gram给出具有该值的文档中*k*-gram的数量。
- en: Hashing.
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希。
- en: On many systems there are 128 different possible values for each character,
    so there are 128*k* possible *k*-grams, and the dimension *d* would have to be
    128*k* for the simple scheme just described. This number is prohibitively large
    even for moderately large *k*. To ameliorate this problem, we use hashing, a fundamental
    operation that we considered earlier in this section to map an object to an integer.
    For any string `s`, `hash(s) % d` is an integer between 0 and `d`-1 that we can
    use as an index into an array to compute frequencies. The sketch that we use is
    the direction of the vector defined by frequencies of these values for all *k*-grams
    in the document (the unit vector with the same direction). The test client in
    [sketch.py](sketch.py.html) accepts `k` and `d` as command-line arguments, and
    computes and writes a sketch of the document that it reads from standard input.
    Try running it with standard input redirected to the file [genome20.txt](genome20.txt).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统上，每个字符有128个不同的可能值，因此每个字符有128*k*个可能的*k*-gram，简单方案中维度*d*将不得不是128*k*。即使对于中等大小的*k*，这个数字也是不可接受的大。为了缓解这个问题，我们使用哈希，这是我们在本节前面考虑过的将对象映射到整数的基本操作。对于任何字符串`s`，`hash(s)
    % d`是一个介于0和`d`-1之间的整数，我们可以将其用作数组的索引来计算频率。我们使用的草图是文档中所有*k*-gram的��些值的频率定义的向量的方向（具有相同方向的单位向量）。[sketch.py](sketch.py.html)中的测试客户端接受`k`和`d`作为命令行参数，并计算并写入从标准输入读取的文档的草图。尝试将标准输入重定向到文件[genome20.txt](genome20.txt)。
- en: Comparing sketches.
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较草图。
- en: The second challenge is to compute a similarity measure between two sketches.
    One widely used similarity measure is known as the *cosine similarity measure*.
    Since our sketches are unit vectors with nonnegative coordinates, their dot product
    is a number between 0 and 1\. The more similar the documents, the closer we expect
    this measure to be to 1\. The `similarTo()` method in [sketch.py](sketch.py.html)
    uses that approach.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个挑战是计算两个草图之间的相似度。一个广泛使用的相似度度量称为*余弦相似度度量*。由于我们的草图是具有非负坐标的单位向量，它们的点积是介于0和1之间的数字。文件越相似，我们期望这个度量值越接近1。[sketch.py](sketch.py.html)中的`similarTo()`方法使用了这种方法。
- en: Comparing all pairs.
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较所有配对。
- en: 'The program [comparedocuments.py](comparedocuments.py.html) is a simple and
    useful `Sketch` client that provides the information needed to solve the following
    problem: given a set of documents, find the two that are most similar. Since this
    specification is a bit subjective, the program writes the cosine similarity measure
    for all pairs of documents. The program accepts command-line arguments `k` and
    `d`, reads from standard input a list of file names, and writes a table showing
    the similarity measures of the files with those names. Try running it with standard
    input redirected to [documents.txt](documents.txt), which contains the names of
    the files [constitution.txt](constitution.txt), [tomsawyer.txt](tomsawyer.txt),
    [huckfinn.txt](huckfinn.txt), [prejudice.txt](prejudice.txt), [djia.csv](djia.csv),
    [amazon.html](amazon.html), and [actg.txt](actg.txt).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[comparedocuments.py](comparedocuments.py.html)是一个简单而有用的`Sketch`客户端，提供解决以下问题所需的信息：给定一组文档，找到最相似的两个文档。由于这个规范有点主观，程序会为所有文档对写入余弦相似度度量。程序接受命令行参数`k`和`d`，从标准输入读取文件名列表，并写入显示文件之间相似度度量的表格。尝试将标准输入重定向到[documents.txt](documents.txt)，其中包含文件[constitution.txt](constitution.txt)、[tomsawyer.txt](tomsawyer.txt)、[huckfinn.txt](huckfinn.txt)、[prejudice.txt](prejudice.txt)、[djia.csv](djia.csv)、[amazon.html](amazon.html)和[actg.txt](actg.txt)的名称。
- en: '* * *'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Design-by-Contract
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 契约式设计
- en: To conclude, we briefly discuss Python language mechanisms that enable you to
    verify assumptions about your program while it is running.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要讨论了Python语言机制，使您能够在程序运行时验证对程序的假设。
- en: Exceptions.
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常。
- en: 'An *exception* is a disruptive event that occurs while a program is running,
    often to signal an error. The action taken is known as *raising an exception*
    (or *error*). We have already encountered exceptions raised by Python''s standard
    modules in the course of learning to program: `IndexError` and `ZeroDivisionError`
    are typical examples. You can also raise your own exceptions. The simplest kind
    is an `Exception` that disrupts execution of the program and writes an error message:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*是程序运行时发生的中断性事件，通常用于表示错误。所采取的行动称为*引发异常*（或*错误*）。在学习编程过程中，我们已经遇到了Python标准模块引发的异常：`IndexError`和`ZeroDivisionError`是典型例子。您也可以引发自己的异常。最简单的一种是中断程序执行并写入错误消息的`Exception`：'
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is good practice to use exceptions when they can be helpful to the client.
    For example, in [vector.py](vector.py.html), we should raise an exception in `__add__()`
    if the two `Vector`s to be added have different dimensions. To do so, we insert
    the following statement at the beginning of `__add__()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常对客户端有帮助时，使用异常是一个好的实践。例如，在[vector.py](vector.py.html)中，如果要相加的两个`Vector`具有不同的维度，我们应该在`__add__()`中引发异常。为此，我们在`__add__()`的开头插入以下语句：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Assertions.
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言。
- en: 'An *assertion* is a boolean expression that you are affirming is `True` at
    that point in the program. If the expression is `False`, the program will raise
    an `AssertionError` at run time. Programmers uses assertions to detect bugs and
    gain confidence in the correctness of their programs. Assertions also serve to
    document the programmer''s intent. For example, in [counter.py](counter.py.html),
    we might check that the counter is never negative by adding the following assertion
    as the last statement in `increment()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*断言*是一个布尔表达式，你在程序中断言在那一点是`True`。如果表达式是`False`，程序将在运行时引发`AssertionError`。程序员使用断言来检测错误并增加对程序正确性的信心。断言还用于记录程序员的意图。例如，在[counter.py](counter.py.html)中，我们可以通过在`increment()`的最后一条语句中添加以下断言来检查计数器永远不会为负：'
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This statement would call attention to a negative count. You can also add an
    optional detail message, such as
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明会引起负计数的注意。您还可以添加一个可选的详细消息，例如
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: to help identify the bug.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以帮助识别错误。
- en: By default, assertions are enabled, but you can disable them from the command
    line by using the `-O` (that's a minus sign followed by an uppercase "oh") flag
    with the python command. (The `O` stands for "optimize.") Assertions are for debugging
    only; your program should not rely on assertions for normal operation since they
    may be disabled.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，断言是启用的，但你可以通过在命令行中使用带有python命令的`-O`（减号后跟一个大写字母“oh”）标志来禁用它们。（`O`代表“优化”）。断言仅用于调试；你的程序不应依赖断言进行正常操作，因为它们可能被禁用。
- en: When using the *design-by-contract* model, the designer of a data type expresses
    a *precondition* (the condition that the client promises to satisfy when calling
    a method), a *postcondition* (the condition that the implementation promises to
    achieve when returning from a method), *invariants* (any condition that the implementation
    promises to satisfy while the method is executing), and *side effects* (any other
    change in state that the method could cause). During development, these conditions
    can be tested with assertions. Many programmers use assertions liberally to aid
    in debugging.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用*设计契约*模型时，数据类型的设计者表达了*前置条件*（客户在调用方法时承诺满足的条件）、*后置条件*（实现在从方法返回时承诺实现的条件）、*不变量*（实现在执行方法时承诺满足的任何条件）和*副作用*（方法可能引起的状态变化）。在开发过程中，这些条件可以通过断言进行测试。许多程序员在调试时会大量使用断言。
- en: '* * *'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q & A
- en: '**Q.** Why is the underscore convention not part of (and enforced by) Python?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么下划线约定不是Python的一部��（并受到强制执行）？'
- en: '**A.** Good question.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 很好的问题。'
- en: '**Q.** Why all the leading underscores?'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么要使用前导下划线？'
- en: '**A.** This is just one of many examples where a programming-language designer
    goes with a personal preference and we live with the result. Fortunately, most
    Python programs that you compose will be client programs, which do not directly
    call special methods or refer to private instance variables, so they will not
    need many leading underscores. The relatively few Python programmers who implement
    their own data types (that''s you, now) need to follow the underscore conventions,
    but even those programmers are likely to be composing more client code than class
    implementations, so the underscores may not be so onerous in the long run.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这只是许多例子之一，其中编程语言设计者遵循个人偏好，我们只能接受结果。幸运的是，你编写的大多数Python程序将是客户程序，不直接调用特殊方法或引用私有实例变量，因此它们不需要许多前导下划线。相对较少的Python程序员实现自己的数据类型（现在就是你），需要遵循下划线约定，但即使这些程序员可能会编写更多的客户端代码而不是类实现，所以从长远来看，下划线可能并不那么繁琐。'
- en: '**Q.** The `__mul__()` method in [complexpolar.py](complexpolar.py.html) is
    awkward because it create a `Complex` object (representing 0 + 0*i*) and then
    immediately changes its instance variables to the desired polar coordinates. Wouldn''t
    the design be better if I could add a second constructor that takes the polar
    coordinates as arguments?'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** [complexpolar.py](complexpolar.py.html)中的`__mul__()`方法很笨拙，因为它创建了一个表示0
    + 0*i*的`Complex`对象，然后立即将其实例变量更改为所需的极坐标。如果我可以添加一个以极坐标为参数的第二个构造函数，设计会不会更好？'
- en: '**A.** Yes, but we already have a constructor that takes the rectangular coordinates
    as arguments. A better design might be to have two ordinary functions (not methods)
    `createRect(x, y)` and `createPolar(r, theta)` in the API that create and return
    new objects. This design is perhaps better because it would provide the client
    with the capability to switch to polar coordinates. This example demonstrates
    that it is a good idea to think about more than one implementation when developing
    a data type. Of course, making such a change necessitates enhancing all existing
    implementations and clients of the API, so this thinking should happen as early
    in the design process as possible.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但我们已经有一个以矩形坐标为参数的构造函数。一个更好的设计可能是在API中有两个普通函数（而不是方法）`createRect(x,
    y)`和`createPolar(r, theta)`，它们创建并返回新对象。这种设计可能更好，因为它将为客户端提供切换到极坐标的能力。这个例子表明，在开发数据类型时考虑多种实现是一个好主意。当然，进行这样的更改需要增强所有现有实现和API的客户端，因此这种思考应尽早在设计过程中发生。'
- en: '**Q.** How do I specify a tuple consisting of zero items or one item?'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如何指定由零个项目或一个项目组成的元组？'
- en: '**A.** You can use `()` and `(1,)`, respectively. Without the comma in the
    second expression, Python would treat it as an arithmetic expression enclosed
    in parentheses.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 你可以分别使用`()`和`(1,)`。在第二个表达式中没有逗号，Python会将其视为括号括起来的算术表达式。'
- en: '**Q.** Do I really need to overload all six comparison methods if I want to
    make my data type comparable?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我想使我的数据类型可比较，是否真的需要重载所有六个比较方法？'
- en: '**A.** Yes. This is an example where the convention is to provide maximum flexibility
    to clients at the expense of extra code in implementations. Often, you can use
    symmetries to cut down on the actual amount of implementation code. Also, Python
    3 supplies a few shortcuts. For example, if you define an `__eq__()` method for
    a data type but do not define an `__ne__()` method, then Python automatically
    provides an implementation that calls `__eq__()` and negates the result. However,
    Python 2 does not provide these shortcuts, so it is best not to rely upon them
    in your code.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。这是一个例子，其中约定为在实现中提供最大的灵活性，以换取额外的代码。通常，你可以利用对称性来减少实际的实现代码量。此外，Python
    3提供了一些快捷方式。例如，如果为数据类型定义了`__eq__()`方法，但没有定义`__ne__()`方法，那么Python会自动提供一个调用`__eq__()`并否定结果的实现。然而，Python
    2不提供这些快捷方式，因此最好不要在代码中依赖它们。'
- en: '**Q.** What is the range of integer values returned by the built-in `hash()`
    function?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 内置的`hash()`函数返回的整数值范围是多少？'
- en: '**A.** Typically, Python uses a 64-bit integer, so the range is between -2^(63)
    and 2^(63)-1\. For cryptographic applications, you should use Python''s `hashlib`
    module, which supports "secure" hash functions that support much larger ranges.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 通常，Python 使用 64 位整数，因此范围在 -2^(63) 和 2^(63)-1 之间。对于加密应用，应使用 Python 的
    `hashlib` 模块，该模块支持支持更大范围的“安全”哈希函数。'
- en: '**Q.** Which Python operators cannot be overloaded?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 哪些 Python 运算符不能被重载？'
- en: '**A.** In Python, you cannot overload'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在 Python 中，你不能重载'
- en: The boolean operators `and`, `or`, and `not`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔运算符 `and`、`or` 和 `not`。
- en: The `is` and `is not` operators, which test for object identity.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is` 和 `is not` 运算符，用于测试对象标识。'
- en: The string format operator `%`, which can be applied only to strings.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化运算符 `%`，仅适用于字符串。
- en: The assignment operator `=`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符 `=`.
- en: '* * *'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Create a data type `Location` for dealing with locations on Earth using spherical
    coordinates (latitude/longitude). Include methods to generate a random location
    on the surface of the Earth, parse a location "25.344 N, 63.5532 W", and compute
    the great circle distance between two locations.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于处理地球上位置的数据类型 `Location`，使用球面坐标（纬度/经度）。包括生成地球表面上的随机位置、解析位置“25.344 N, 63.5532
    W”和计算两个位置之间的大圆距离的方法。
- en: Create a data type for a three-dimensional particle with position (*r*[*x*],
    *r*[*y*], *r*[*z*]), mass *m*, and velocity `(*v*[*x*], *v*[*y*], *v*[*z*])`.
    Include a method to return its kinetic energy, which equals 1/2 *m* (*v*[*x*]²
    + *v*[*y*]² + *v*[*z*]²). Use the `Vector` data type, as defined in [vector.py](vector.py.html).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个三维粒子的数据类型，具有位置（*r*[*x*]、*r*[*y*]、*r*[*z*]）、质量 *m* 和速度 `(*v*[*x*]、*v*[*y*]、*v*[*z*])`。包括一个返回其动能的方法，等于
    1/2 *m* (*v*[*x*]² + *v*[*y*]² + *v*[*z*]²)。使用在 [vector.py](vector.py.html) 中定义的
    `Vector` 数据类型。
- en: If you know your physics, develop an alternate implementation of the data type
    of the previous exercise based on using the *momentum* (*p*[*x*], *p*[*y*], *p*[*z*])
    as an instance variable.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你了解物理学，请基于使用 *动量* (*p*[*x*]、*p*[*y*]、*p*[*z*]) 作为实例变量的上一个练习中的数据类型开发一个替代实现。
- en: Develop an implementation of the `Histogram` class, as defined in [histogram.py](../32class/histogram.py.html)
    (from Section 3.2), that uses `Counter`, as defined in [counter.py](counter.py.html).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个 `Histogram` 类的实现，如第 3.2 节中定义的 [histogram.py](../32class/histogram.py.html)，使用
    [counter.py](counter.py.html) 中定义的 `Counter`。
- en: Compose an implementation of `__sub__()` for `Vector` (as defined in [vector.py](vector.py.html)
    that subtracts two vectors.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Vector`（如 [vector.py](vector.py.html) 中定义）实现一个 `__sub__()` 方法，用于计算两个向量的差。
- en: '*Solution*:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE15]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that `__sub__()` calls `__add__()` and `__mul__()`. The advantage of such
    implementations is that they limit the amount of detailed code to check; the disadvantage
    is that they can be inefficient. In this case, `__add__()` and `__mul__()` both
    create new `Vector` objects, so copying the code for `__add__()` and replacing
    the minus sign with a plus sign is probably a better implementation.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`__sub__()` 调用 `__add__()` 和 `__mul__()`。这种实现的优点是限制了需要检查的详细代码量；缺点是可能效率低下。在这种情况下，`__add__()`
    和 `__mul__()` 都会创建新的 `Vector` 对象，因此复制 `__add__()` 的代码并将减号替换为加号可能是更好的实现。
- en: Implement a data type `Vector2D` for two-dimensional vectors that has the same
    API as `Vector` (as defined in [vector.py](vector.py.html), except that the constructor
    takes two floats as arguments. Use two floats (instead of an array) for instance
    variables.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为二维向量实现一个数据类型 `Vector2D`，其 API 与 `Vector` 相同（如 [vector.py](vector.py.html) 中定义），只是构造函数接受两个浮点数作为参数。使用两个浮点数（而不是数组）作为实例变量。
- en: Implement the `Vector2D` data type of the previous exercise using one `Complex`
    object as the only instance variable.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用��个 `Complex` 对象作为唯一实例变量，实现上一个练习中的 `Vector2D` 数据类型。
- en: Prove that the dot product of two two-dimensional unit-vectors is the cosine
    of the angle between them.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明两个二维单位向量的点积是它们之间角度的余弦。
- en: 'Implement a data type `Vector3D` for three-dimensional vectors that has the
    same API as `Vector`, except that the constructor takes three floats as arguments.
    Also, add a *cross product* method: the cross product of two vectors is another
    vector, defined by the equation'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三维向量实现一个数据类型 `Vector3D`，其 API 与 `Vector` 相同，只是构造函数接受三个浮点数作为参数。此外，添加一个 *叉积*
    方法：两个向量的叉积是另一个向量，由以下方程定义
- en: '| **a** × **b** = **c** &#124;**a**&#124; &#124;**b**&#124; sin θ |'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| **a** × **b** = **c** &#124;**a**&#124; &#124;**b**&#124; sin θ |'
- en: 'where **c** is the unit normal vector perpendicular to both **a** and **b**,
    and θ is the angle between **a** and **b**. In Cartesian coordinates, the following
    equation defines the cross product:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 **c** 是垂直于 **a** 和 **b** 的单位法向量，θ 是 **a** 和 **b** 之间的角度。在笛卡尔坐标中，以下方程定义了叉积：
- en: '| (*a*[0], *a*[1], *a*[2]) × (*b*[0], *b*[1], *b*[2]) = (*a*[1] *b*[2] - *a*[2]
    *b*[1], *a*[2] *b*[0] - *a*[0] *b*[2], *a*[0] *b*[1] - *a*[1] *b*[0]) |'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (*a*[0]、*a*[1]、*a*[2]) × (*b*[0]、*b*[1]、*b*[2]) = (*a*[1] *b*[2] - *a*[2]
    *b*[1]、*a*[2] *b*[0] - *a*[0] *b*[2]、*a*[0] *b*[1] - *a*[1] *b*[0]) |'
- en: The cross product arises in the definition of torque, angular momentum, and
    vector operator curl. Also, |**a** × **b**| is the area of the parallelogram with
    sides **a** and **b**.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 叉积出现在力矩、角动量和矢量算符旋度的定义中。此外，|**a** × **b**| 是以 **a** 和 **b** 为边的平行四边形的面积。
- en: Which modifications (if any) would you need to make `Vector` (see [vector.py](vector.py.html))
    work with `Complex` components (see [complex.py](../32class/complex.py.html) from
    Section 3.2) or `Rational` components (see the "rational numbers" exercise in
    Section 3.2)?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要对 `Vector`（参见 [vector.py](vector.py.html)）进行哪些修改（如果有的话）才能使其与 `Complex` 组件（参见
    [complex.py](../32class/complex.py.html) 第 3.2 节）或 `Rational` 组件（参见第 3.2 节中的“有理数”练习）一起工作？
- en: Add code to [charge.py](../32class/charge.py.html) (from Section 3.2) to make
    `Charge` objects comparable using the value of the charge to determine the order.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [charge.py](../32class/charge.py.html)（第 3.2 节）中添加代码，使得 `Charge` 对象可通过电荷值确定顺序。
- en: Compose a function `fibonacci()` that takes an integer argument `n` and computes
    the `n`th Fibonacci number. Use tuple packing and unpacking.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`fibonacci()`，接受一个整数参数`n`并计算第`n`个斐波那契数。使用元组打包和解包。
- en: 'Revise the `gcd()` function in [euclid.py](../23recursion/euclid.py.html) (from
    Section 2.3) so that it takes two nonnegative integer arguments `p` and `q` and
    returns a tuple of integers (`d`, `a`, `b`) such that `d` is the greatest common
    divisor of `p` and `q`, and the coefficients `a` and `b` satisfy Bezout''s identity:
    `d = a*p + b*q`. Use tuple packing and unpacking.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 [euclid.py](../23recursion/euclid.py.html)（来自第2.3节）中的`gcd()`函数，使其接受两个非负整数参数`p`和`q`，并返回一个整数元组（`d`、`a`、`b`），其中`d`是`p`和`q`的最大公约数，系数`a`和`b`满足贝祖等式：`d
    = a*p + b*q`。使用元组打包和解包。
- en: '*Solution*: This algorithm is known as *extended Euclid''s algorithm*:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：这个算法被称为*扩展欧几里得算法*：'
- en: '[PRE16]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discuss the advantages and disadvantages of Python's design in making the built-in
    type `bool` be a subclass of the built-in type `int`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 讨论 Python 设计中将内置类型 `bool` 设计为内置类型 `int` 的子类的优缺点。
- en: Add code to `Counter` (as defined in [counter.py](counter.py.html) to raise
    a `ValueError` at run time if the client tries to create a `Counter` object using
    a negative value for `maxCount`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Counter`（如[counter.py](counter.py.html)中定义）中添加代码，如果客户端尝试使用负值为`maxCount`创建`Counter`对象，则在运行时引发`ValueError`。
- en: Use exceptions to develop an implementation of `Rational` (see the "rational
    numbers" exercise in Section 3.2) that raises a `ValueException` at run time if
    the denominator is zero.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用异常开发`Rational`的实现（请参阅第3.2节中的“有理数”练习），如果分母为零，则在运行时引发`ValueException`。
- en: '* * *'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Data-Type Design Exercises
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类型设计练习
- en: '*This group of exercises is intended to give you experience in developing data
    types. For each problem, design one or more APIs with API implementations, testing
    your design decisions by implementing typical client code. Some of the exercises
    require either knowledge of a particular domain or a search for information about
    it on the web.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*这组练习旨在让您有机会开发数据类型。对于每个问题，设计一个或多个 API，并通过实现典型客户端代码来测试您的设计决策。一些练习要求对特定领域的知识或在网络上搜索信息。*'
- en: '**Statistics**. Develop a data type for maintaining statistics of a set of
    floats. Provide a method to add data points and methods that return the number
    of points, the mean, the standard deviation, and the variance. Develop two implementations:
    one whose instance values are the number of points, the sum of the values, and
    the sum of the squares of the values, and another that keeps an array containing
    all the points. For simplicity, you may take the maximum number of points in the
    constructor. Your first implementation is likely to be faster and use substantially
    less space, but is also likely to be susceptible to roundoff error.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**统计**。开发一个用于维护一组浮点数统计信息的数据类型。提供一个添加数据点的方法和返回点数、均值、标准差和方差的方法。开发两种实现：一种实例值为点数、值的总和和值的平方和，另一种保留包含所有点的数组。为简单起见，您可以在构造函数中使用最大点数。您的第一个实现可能更快，占用的空间也更少，但也可能容易受到舍入误差的影响。'
- en: '**Genome**. Develop a data type to store the genome of an organism. Biologists
    often abstract the genome to a sequence of nucleotides (A, C, G, or T). The data
    type should support the methods `addCodon(c)` and `baseAt(i)`, as well as `isPotentialGene()`
    (see [potentialgene.py](../31datatype/potentialgene.py.html) from Section 3.1).
    Develop three implementations.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基因组**。开发一个用于存储生物体基因组的数据类型。生物学家通常将基因组抽象为核苷酸序列（A、C、G或T）。数据类型应支持`addCodon(c)`和`baseAt(i)`方法，以及`isPotentialGene()`（请参阅第3.1节中的[potentialgene.py](../31datatype/potentialgene.py.html)）。开发三种实现。'
- en: Use a string as the only instance variable; implement `addCodon()` with string
    concatenation.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串作为唯一实例变量；使用字符串连接实现`addCodon()`。
- en: Use an array of single-character strings as the only instance variable; implement
    `addCodon()` with the `+=` operator.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个字符字符串数组作为唯一实例变量；使用`+=`运算符实现`addCodon()`。
- en: Use a boolean array, encoding each base with two bits.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔数组，用两位编码每个碱基。
- en: '**Time**. Develop a data type for the time of day. Provide client methods that
    return the current hour, minute, and second, as well as a `__str__()` method.
    Develop two implementations: one that keeps the time as a single `int` value (number
    of seconds since midnight) and another that keeps three `int` values, one each
    for seconds, minutes, and hours.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**时间**。开发一个表示一天时间的数据类型。提供返回当前小时、分钟和秒的客户端方法，以及一个`__str__()`方法。开发两种实现：一种将时间保留为单个`int`值（从午夜开始的秒数），另一种保留三个`int`值，分别为秒、分钟和小时。'
- en: '**Vector fields**. Develop a data type for force vectors in two dimensions.
    Provide a constructor, a method to add two vectors, and an interesting test client.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向量场**。开发一个表示二维力向量的数据类型。提供一个构造函数，一个用于添加两个向量的方法，以及一个有趣的测试客户端。'
- en: '**Dates**. Develop an API for dates (year, month, day). Include methods for
    comparing two dates chronologically, computing the number of days between two
    dates, determining the day of the week of a given date, and any other operations
    that you think a client might want. After you have designed your API, look at
    the Python''s `datetime.date` data type.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日期**。为日期（年、月、日）开发一个 API。包括比较两个日期的时间顺序、计算两个日期之间的天数、确定给定日期的星期几，以及客户端可能需要的任何其他操作。设计完
    API 后，查看 Python 的`datetime.date`数据类型。'
- en: '**Polynomials**. Develop a data type for univariate polynomials with integer
    coefficients, such as *x*³ + 5*x*² + 3*x* + 7\. Include methods for standard operations
    on polynomials such as addition, subtraction, multiplication, degree, evaluation,
    composition, differentiation, definite integration, and testing equality.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式**。开发一个具有整数系数的一元多项式数据类型，例如*x*³ + 5*x*² + 3*x* + 7。包括多项式的标准操作方法，如加法、减法、乘法、次数、求值、组合、微分、定积分和测试相等性。'
- en: '**Rational polynomials**. Repeat the previous exercise, ensuring that the polynomial
    data type behaves correctly when provided coefficients of type `int`, `float`,
    `complex`, and `Fraction` (see the "rational numbers" exercise in Section 3.2).'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有理多项式**。重复上一个练习，确保当提供`int`、`float`、`complex`和`Fraction`类型的系数时，多项式数据类型的行为是正确的（请参见第3.2节中的“有理数”练习）。'
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Calendar**. Develop `Appointment` and `Calendar` APIs that can be used to
    keep track of appointments (by day) in a calendar year. Your goal is to enable
    clients to schedule appointments that do not conflict and to report current appointments
    to clients. Use Python''s `datetime` module.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日历**。开发`Appointment`和`Calendar` API，可用于在日历年中跟踪约会（按天）。您的目标是使客户能够安排不冲突的约会，并向客户报告当前约会。使用Python的`datetime`模块。'
- en: '**Vector field**. A vector field associates a vector with every point in a
    Euclidean space. Compose a version of [potential.py](../31datatype/potential.py.html)
    (from Section 3.1) that takes as input a grid size *n*, computes the `Vector`
    value of the potential due to the point charges at each point in an *n*-by-*n*
    grid of equally spaced points, and draws the unit vector in the direction of the
    accumulated field at each point.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**矢量场**。矢量场将一个向量与欧几里得空间中的每一点相关联。编写一个版本的[potential.py](../31datatype/potential.py.html)（来自第3.1节），它以网格大小*n*作为输入，计算在*n*乘*n*的等间距点网格中每个点处由点电荷引起的势的`Vector`值，并在每个点处绘制指向累积场的单位矢量。'
- en: '**Sketching**. Pick an interesting set of documents from the booksite (or use
    a collection of your own) and run [comparedocuments.py](comparedocuments.py.html)
    with various command-line arguments, to learn about their effect on the computation.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**素描**。从书站选择一组有趣的文档（或使用您自己的集合），并使用各种命令行参数运行[comparedocuments.py](comparedocuments.py.html)，以了解它们对计算的影响。'
- en: '**Multimedia search**. Develop sketching strategies for sound and pictures,
    and use them to discover interesting similarities among songs in the music library
    and photos in the photo album on your computer.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多媒体搜索**。开发声音和图片的素描策略，并使用它们在计算机的音乐库中的歌曲和照片相册中发现有趣的相似之处。'
- en: '**Data mining**. Compose a recursive program that surfs the web, starting at
    a page given as the first command-line argument, and looks for pages that are
    similar to the page given as the second command-line argument, as follows. To
    process a name, open an input stream, do a `readAll()`, sketch it, and write the
    name if its distance to the target page is greater than the threshold value given
    as the third command-line argument. Then scan the page for all strings that contain
    the substring `http://` and (recursively) process pages with those names. *Note*:
    This program might read a very large number of pages!'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据挖掘**。编写一个递归程序，从给定为第一个命令行参数的页面开始浏览网页，并查找与给定为第二个命令行参数的页面相似的页面，方法如下。要处理一个名称，打开一个输入流，执行`readAll()`，进行素描，并在距离目标页面的距离大于作为第三个命令行参数给定的阈值时写入名称。然后扫描页面以查找所有包含子字符串`http://`的字符串，并（递归地）处理具有这些名称的页面。*注意*：此程序可能会读取大量页面！'
