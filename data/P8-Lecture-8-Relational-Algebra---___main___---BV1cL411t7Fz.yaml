- en: P8：Lecture 8 Relational Algebra - ___main___ - BV1cL411t7Fz
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P8：第8讲 关系代数 - ___main___ - BV1cL411t7Fz
- en: I should。 OK， so will there be sort of a dry run for this thing？ Yes。 there
    will be a dry run in fact。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该。好，那么这个东西会有预演吗？**是的**，实际上会有预演。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_1.png)'
- en: and you will get a bonus point if you participate in the dry run， so it's actually
    really。 It'd be good if you participated in the dry run， so and so yeah。 we'll
    be around to make sure that your setup makes sense and we'll comment on that。
    So I just wanted to start by giving a little bit of background around this sort
    of exam proctoring thing。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参加预演，你会获得额外的加分。所以实际上参加预演是很好的。我们会在场，确保你的设置是合理的，并对其做出评论。所以我只是想先简要介绍一下这次考试监考的背景。
- en: So the post is long， right？ There's a lot of details we really want you to spend
    the time to actually read through all of these details and it took us a long time
    to arrive at this。 So we've been trying to work on this for the last three weeks
    and you can't imagine the number of messages that Jerry and sort of and Alan and
    and and and Ethan and a bunch of others also sort of basically exchange just to
    try to figure out what is the best approach for this。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇帖子很长，对吧？有很多细节，我们真的希望你能花时间仔细阅读所有这些细节，因为我们花了很长时间才得出这个方案。我们过去三周一直在努力处理这个问题，你无法想象Jerry、Alan、Ethan以及其他很多人为了找出最好的做法而交换了多少信息。
- en: And in some sense you're trying to optimize three axes， right， so the first
    axis is fairness。 We wanted to be fair， right， and we want those who are doing
    the exam diligently to get rewarded。 We want to minimize privacy， so we don't
    want to sort of be invasive as much as we can。 And the third is we want to minimize
    the overhead， right。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，你们要优化三个维度，对吧？第一个维度是公平。我们想要公平，我们希望那些认真参加考试的人能够得到奖励。我们想尽量减少隐私泄露，因此我们尽量避免侵犯隐私。第三，我们想要尽量减少开销。
- en: so we want to make it as little owners as less owners for us possible。 And optimizing
    these three objectives is a pain and it took us a while to arrive at this。 Hopefully
    this is something that adds a little bit of discomfort while providing the benefits
    of privacy and fairness as well。 So we hope you'll bear with us as we try out
    this experiment。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们想让它尽可能少给我们带来负担。优化这三个目标真的很痛苦，我们花了很长时间才得出这个方案。希望这是一个能够带来一些不适感，但同时提供隐私和公平性好处的方案。所以希望你们能耐心配合我们，一起试验这个。
- en: We again be sort of sought feedback from a bunch of other classes and trying
    to figure out what's the best way to do this。 And we think you've come up with
    something decent。 It's not going to be perfect， but it's decent。 So， but if there's
    anything that you want to suggest that you feel like it's it's not working for
    your setting。 We can try to figure out exceptions， right， so just let us know
    if it's not working with your setup for whatever reason。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从其他班级收集了反馈，试图找出最好的做法。我们认为你们已经提出了一个不错的方案。虽然不能做到完美，但还是不错的。所以，如果你有任何建议，觉得某些地方不适合你的设置，请告诉我们，我们可以尝试找出例外情况。
- en: Let us know and we'll try our best to accommodate。 And one of the even though
    the formulation is pretty complex。 there is going to be a dry run and we hope
    you'll participate because you'll get points for it。 And we will evaluate your
    setup and say， yeah， whatever， and we can go from there。 Okay。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们，我们会尽力满足你的需求。尽管这个公式非常复杂，**但是**，我们将进行一次预演，希望你能参加，因为你将因此获得积分。我们还会评估你的设置，并说，嗯，随便，然后我们可以从那里开始。好的。
- en: So if you have any questions about exams， feel free to ask them now。 So， each
    one asks。 will we have to scan anything to submit or is the exam online the exam
    is going to be online so you don't need to print anything you don't need to scan
    anything so it's going to be online。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对考试有任何问题，随时可以提问。那么，每个人问：我们需要扫描什么内容来提交吗？还是考试是在线的？考试是在线的，所以你不需要打印任何东西，也不需要扫描任何东西。所以考试将会在线进行。
- en: And we also thought of sort of fail safe if you have whatever problems with
    Wi-Fi and all of that all of that is in the instructions as well。 Okay。 All right，
    so other announcements。 As always， look at the weekly post rather than。 Okay。
    I can ask， I can have pen and paper and pencil to help me work through problems
    but no I patch correct。 You can have whatever you want in terms of sort of like
    writing material。 As long as it's not。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考虑了防故障的措施，如果你有Wi-Fi等问题，所有这些内容也在说明中。好的，其他公告。和往常一样，查看每周的帖子而不是......好的。我可以拿着笔和纸帮助自己解决问题，但没有平板电脑，对吧。你可以带任何你需要的书写材料，只要它不是...
- en: it's not electronic and it's not textbooks， right。 So we will。 we do have cheat
    sheets but we don't allow textbooks。 Okay。 so look at the weekly post for more
    announcements。 One thing that we sort of are doing to try to ensure that the TAs
    can help students at a more steady clip is to sort of insist that the。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是电子书，也不是教材，对吧。所以我们确实有备忘单，但不允许使用教材。好的，查看每周的帖子了解更多公告。我们正在做的一件事是，尝试确保助教能更稳定地帮助学生，方法是坚持要求学生提供...
- en: office are ticket descriptions are meeting some bad minimum requirements， right。
    So basically。 we want you to specify the support that you're looking at the questions
    that you're looking at the description of your problem or bug what issue are you
    having with and stuff that you've tried out as well as。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 办公时间的工单描述符合最低要求，对吧。所以基本上，我们希望你能够明确指出你需要的支持，所提问题的描述，遇到的具体问题或错误，你遇到的困难，以及你已经尝试过的解决方法等。
- en: the link to the GitHub repo， right。 So we're gonna insist start insisting that
    you provide a little bit more information so that the TAs can effectively help
    effectively help you during these office hours。 because the issue is that if，
    if you show up with an issue that doesn't have all of these details fleshed out
    and the course staff member is helping you out and it's taking a really long time
    to work out these issues。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GitHub仓库的链接，对吧。我们会坚持要求你提供更多信息，以便助教在办公时间内有效地帮助你。因为问题是，如果你带着没有完整信息的问题出现，而课程工作人员正在帮你解决，这会花费很长时间来处理这些问题。
- en: They may not be able to get to the next person in life。 Right。 so this is overall
    to increase the efficiency of the system and make sure that everyone gets a fair
    shake in terms of getting that issue started out。 Okay， more details on this in
    post number 19。 Last， but not least。 I encourage you to turn on your video if
    you can， of course， no pressure， but we love seeing you。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可能无法在生活中与下一个人建立联系。对。所以这总体上是为了提高系统的效率，并确保每个人在启动问题时都能得到公平的机会。好的，更多细节请参见第19篇帖子。最后，但同样重要的是，我鼓励你们如果可以的话打开视频，当然没有压力，但我们很喜欢看到你们。
- en: We love seeing your reactions。 Okay， and if something's confusing。 it'll show
    on your face and I can hopefully try to rectify。 Yeah。 otherwise we were looking
    at like a bunch of alphabet so then that's not fun。 Yeah。 otherwise I have no
    clue whether any of this is getting through to you。 Right， so， okay。 All right。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢看到你们的反应。好的，如果有什么让你困惑的，它会显示在你脸上，我可以尽量尝试纠正。是的，否则我们就看着一堆字母，这样可不有趣。是的，反之，我根本不知道这些内容是否能够传达给你。对吧，好，好的。
- en: cool。 So we were talking about relational algebra operations， right。 The relational
    algebra is like one of my favorite topics in database systems。 And so it always
    gives me great joy to present it。 So。 we're talking about relational algebra operations
    is like it should remind you of sort of arithmetic and linear algebra in that
    it's basically allows you to compose larger operations by sort of using these
    operations in sequence。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒。所以我们在讨论关系代数操作，对吧。关系代数是数据库系统中我最喜欢的话题之一。所以每次讲解这个都让我感到非常开心。所以，我们在讨论关系代数操作时，它应该让你联想到算术和线性代数，因为它基本上允许你通过按顺序使用这些操作来组合更大的操作。
- en: Right， so， so we talked about various basic operations， or at least at a high
    level。 The projection selection renaming union set difference cross product and
    I will get into each of these more detailed ways。 And we talked about the fact
    that there are two compound operations in the intersections and joints。 Okay，
    revising projections we covered this last time but just a quick overview。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对，我们讨论了各种基本操作，至少在高层次上。投影、选择、重命名、并集、差集、笛卡尔积，我将以更详细的方式讲解每一项操作。我们还讨论了有两个复合操作，即交集和连接。好的，回顾投影，我们上次已经讲过这个，但只是快速回顾一下。
- en: So projection is represented using the pie symbol。 Okay， and the way it's used
    is you say pie。 and then you list the attributes that you want， to obtain in the
    output。 and then you give the input relation as the， as the operand。 This is what
    the operation。 the pie is operating on。 Okay。 And so from this input relation
    instance。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，投影是用π符号表示的。好的，使用方法是你说π，然后列出你想在输出中获得的属性，再给出输入关系作为操作数。这个操作，π就是作用于这个输入关系实例的。好的。所以，从这个输入关系实例来看。
- en: s to this pie operation is basically only retaining S name and H。 Okay。 so it's
    getting rid of rating， it's getting rid of s ID。 Okay。 so that's what you end
    up getting in this example。 So this projection operation corresponds to the select
    list in sequence basically the list of attributes that you list in your selects
    the select clause in sequel。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个π操作基本上只保留了S姓名和年龄。好的。所以它去掉了评分，去掉了S ID。好的，这就是你在这个例子中最终得到的结果。所以，这个投影操作对应于SQL中的select列表，基本上就是你在select子句中列出的属性列表。
- en: The schema of the output schema of the projection operation is determined by
    the schema of the attribute list。 So you basically have these two attributes listed
    and therefore that is your output schema。 And the names and types again correspond
    to the input attribute。 So this S name is basically the same as this S name， and
    this age is the same as this age。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 投影操作的输出模式由属性列表的模式决定。基本上你列出了这两个属性，因此那就是你的输出模式。名称和类型再次对应于输入属性。所以，这个S姓名基本上和这个S姓名是一样的，这个年龄和这个年龄是一样的。
- en: and therefore the names and types derived from the input attributes。 So projection
    basically selects a subset of columns so now in a vertical slice。 So it's doing
    vertical slicing。 Okay， so what happens if there are duplicates so this is where
    things get a little tricky。 So if， for example， you did a projection onto age。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，衍生自输入属性的名称和类型。投影基本上是选择一部分列，现在是在进行垂直切片。它就是在做垂直切片。好，那么如果有重复项会发生什么呢？这就是事情变得有些棘手的地方。所以，如果你举个例子，你对年龄进行投影。
- en: you projected away the other columns s ID S name and rating。 You're left with
    a single attribute relation output， which is just age。 Right。 Now if you notice。
    there are a few duplicates， right。 So there's 35 repeated three times。 Recall
    that in relational algebra， you obey set semantics。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你去掉了其他列，如ID、姓名和评分。剩下的只有一个属性关系输出，就是年龄。对吧？现在如果你注意到，有一些重复项，对吧？比如35重复了三次。记住，在关系代数中，你遵循集合语义。
- en: So what you're going to end up doing is to throw away the duplicates and you
    are only left with two output tools。 Okay， so set semantics means that you often
    end up with few rows if you have duplicates during as a result of projection。
    Real systems， as we've seen， don't automatically remove duplicates right so sequel
    doesn't enforce a duplicate removal。 And this is because of semantics are consistent
    semantics across operations。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你最终要做的是去掉重复项，最终只剩下两个输出工具。好的，所以集合语义意味着，如果在投影过程中有重复项，你最终会得到较少的行。正如我们所见，真实系统并不会自动去除重复项，因此SQL并不强制去除重复项。这是因为在操作中一致的语义。
- en: as well as for performance reasons doing duplicate removal is expensive。 Right。
    So one possible approach should do it would be to sort and sort is expensive or
    hash or whatever。 Each of these operations is expensive。 Okay， so moving on the
    next operation that I want to talk about another unity operation is sigma selection。
    So in this case， I am applying a sigma a selection of rating is greater than eight
    on this input relation as to。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以及出于性能考虑，去重是非常昂贵的。对吧？所以，一种可能的方法是进行排序，而排序是昂贵的，或者使用哈希等操作，每一个这样的操作都是昂贵的。好的，接下来我要讲的下一个操作是另一个统一操作，就是σ选择。在这种情况下，我应用了σ操作，即选择评分大于8的输入关系S2。
- en: Okay， so basically， I'm enforcing that this particular attribute is greater
    than it。 So what that means is this to pull and this to pull gets eliminated from
    the output and the output that you have is just these two to。 So selection is
    sort of the transpose of projection， right。 it's basically selecting a subset
    of rows in a horizontal basically doing horizontal slicing。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，基本上，我强制要求这个特定的属性大于它。这意味着这个拉取和这个拉取会从输出中被消除，你得到的输出只有这两个。所以，选择操作可以看作是投影的转置，对吧？它基本上是在水平切片，选择行的子集。
- en: Selection corresponds to the well clause in sequel。 So this is where you list
    some predicates that's essentially what you can do as a subscript to this to the
    selection operation。 The output schema for a selection is basically the same as
    input。 You're not throwing away any attributes basically the inheritive from the
    input。 For selection。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择操作对应于SQL中的**WHERE**子句。所以在这里，你列出一些谓词，这基本上是你可以在选择操作中作为下标进行操作的内容。选择操作的输出模式基本上与输入相同。你并没有丢弃任何属性，基本上继承了输入的属性。选择操作的情况。
- en: if the input is a set， then you don't need to do duplicate elimination after
    the selection operation because the output is also going to have no duplicates。
    Okay， so it's not necessarily。 It's not necessary to do duplicate elimination
    for selection。 unlike in the projection case in the projection case because you
    are throwing away some columns。 the remaining columns when taken together could
    have duplicates。 The selection case。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是一个集合，那么在选择操作之后你不需要进行去重，因为输出也将没有重复项。好吧，所以并不一定需要在选择操作中进行去重。与投影操作不同，在投影的情况下，因为你丢弃了一些列，剩下的列结合在一起可能会有重复项。选择操作的情况。
- en: you don't need to do it。 You basically get that for free。 Here's an example
    of composing selection and projection into a more complicated expression。 Remember，
    I mentioned how algebra allows you to take basic units of relation instances and
    then compose large。 large expressions using these operations composed on top of
    each other。 In this particular case。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要做这件事，你基本上可以免费得到它。这里有一个例子，展示了如何将选择和投影组合成一个更复杂的表达式。记得我提到过，关系代数允许你将关系实例的基本单元组合在一起，然后用这些操作按顺序组合成更大的表达式。在这个特定的例子中。
- en: I have s2， then I'm applying a selection on top of that。 and then I'm applying
    a projection on top of that。 So what this has given me is I'm throwing away the
    sailors with the rating greater than eight。 or rather I'm keeping the sailors
    with the rating greater than eight。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我有s2，然后我在其上应用选择操作，再在其上应用投影操作。那么这样做的结果是，我丢弃了评分大于8的水手，或者说，我保留了评分大于8的水手。
- en: And then I'm throwing away all other columns except for S name。 So in this instance。
    I would do the selection operation first。 So rating is greater than eight。 So
    I've thrown away this tuple and this tuple。 And then I would throw away the remaining
    attributes that I don't want。 which is rating age and side。 So what about this
    other expression。 Okay。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我丢弃了除了S name之外的所有其他列。所以在这个例子中，我首先会执行选择操作。评分大于8。所以我丢弃了这个元组和那个元组。然后我会丢弃剩下的不需要的属性，包括评分、年龄和边界。那这个其他的表达式呢？好的。
- en: so let's say I am doing a projection on S name first followed by rating is greater
    than eight。 Does this make sense， and if not， why not。 Warren。 within this not
    make sense since you're selecting as same sort of what you know， right in power。
    Yeah， exactly right。 So since after you've projected out the other columns and
    you're left with only S name。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我首先对S name做投影，接着是评分大于8。这样理解对吗？如果不对，为什么呢？沃伦。在这种情况下不对，因为你选择的结果和你知道的那种很相似，对吧，完全正确。所以在你已经将其他列投影出去后，只剩下了S
    name。
- en: you can't really apply this predicate reading is greater than eight。 So this
    is an ill formed or malformed relation algebra expression that is incorrect。 Okay。
    so you can't， this is this doesn't quite work。 And it's because it's an in it
    has invalid types。 So the input to this selection operation does not contain rating。
    So that's not a binary operations。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能真正应用这个谓词“评分大于8”。所以这是一个格式不正确或错误的关系代数表达式，不是正确的。好的。所以你不能这样做，这并不适用，因为它包含无效的类型。这个选择操作的输入不包含评分列。所以这不是一个二元操作。
- en: Okay， so union operation denoted as this you are a cop。 What does a union operation
    look like so the union operation basically takes a set union of two sets of tuples。
    Right。 So you have s one as one relation instance。 as to as another relation instance
    and each of these。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么并集操作表示为这个符号，你是一个警察。并集操作是什么样子的呢？并集操作基本上是对两个元组集合进行集合并集操作。对吧。所以你有s1作为一个关系实例，s2作为另一个关系实例，而这些。
- en: Like elements within this within this set is a two book。 as one union is basically
    all of the two books combined。 So this is I'm using set notation or a band diagram
    here。 So to do this correctly。 the two input relations need to be compatible。
    Okay， so this。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素，属于这个集合，它们是两个集合。s1并集实际上是所有这两个集合的组合。所以我在这里使用的是集合表示法或文氏图。为了正确地做这件事，两个输入关系需要是兼容的。好的，这是。
- en: it must have the same sequence of attributes and the attributes must have the
    same types。 Otherwise it doesn't really make sense to take a union of those two
    relations right because what you'll end up with will have a weird schema。 So if
    one relation had three attributes， another relation had four attributes can't
    really take a union of those two。 because those two would result a union of those
    two would result in a relation that has neither three attributes。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它们必须有相同的属性顺序，并且属性必须有相同的类型。否则，合并这两个关系就没有意义，因为最终结果会有一个奇怪的模式。所以如果一个关系有三个属性，另一个关系有四个属性，那么不能合并这两个关系，因为这两个关系的合并将导致一个没有三个属性的关系。
- en: no or no for attributes。 Right， somewhere in the middle。 So it's basically。
    and we basically insist that the two relations must be compatible。 They have the
    same set of attributes and types。 So the SQL expression that we've seen for this
    is union。 Right。 And so in terms of duplicate elimination in union under state
    semantics。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不，或者说对于属性来说。对，差不多就在中间。所以基本上，我们坚持要求两个关系必须是兼容的。它们必须有相同的属性集和类型。所以我们看到的SQL表达式是并集。对。所以在并集下的重复消除问题，在状态语义下是这样的。
- en: We would do duplicate elimination right because there could be multiple copies
    of the same two。 So in this particular example， I have s one and s two and I'm
    doing s one union s two by a relation algebra。 This expression has five output
    tuples， while the two inputs had three plus four。 seven total seven total input
    tuples。 Right。 This is because we had this tuple being repeated and this tuple
    being repeated。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会进行重复消除，因为可能会有多个相同的元组。所以在这个例子中，我有s one和s two，我正在通过关系代数做s one并集s two。这个表达式有五个输出元组，而两个输入分别是三和四，总共七个输入元组。对，这就是因为这个元组和那个元组被重复了。
- en: Right。 So you ended up getting rid of one of those copies of each of those two。
    So the SQL expression， as we've seen is either union or union all union gets rid
    of duplicates union all keeps the duplicates。 Okay。 Any questions so far？ Okay。
    All right。 So， the question about like。 can you repeat why union produces more
    rules。 So， um， union doesn't in fact。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以你最终去掉了每个重复元组中的一个副本。我们看到的SQL表达式是并集或并集所有，`union`会去除重复项，`union all`保留重复项。好吧，到目前为止有什么问题吗？好吧。那么，关于并集为什么会产生更多的规则的问题。嗯，并集实际上并不会。
- en: so if you took a union of this relation and this relation， you should ideally
    have seven tuples。 but then you threw out duplicates so you're left with five
    tuples。 Is that answer your question。 Mature。 Okay。 All right， so set difference
    another， another binary operation is。 is like union in that both it's also set
    oriented operation both input relations must be compatible。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你对这个关系和那个关系做并集，理想情况下你应该得到七个元组。但然后你去掉了重复项，所以剩下五个元组。这回答了你的问题吗？成熟了。好吧。那么集合差，另一个二元操作，类似于并集，在于它们都是集合导向的操作，两个输入关系必须兼容。
- en: Right。 So it must have the same schema。 And so basically that means same set
    of attributes and same types。 So what does it look like in my Venn diagram？ Well。
    if you have s one and s two s one minus s two is keeping this crescent as an output。
    Okay。 so that's what s one minus s two evaluates as so sequel expression that
    we've seen for this is except。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以它必须有相同的模式。所以基本上，这意味着相同的属性集和相同的类型。那么在我的维恩图中它看起来是什么样子呢？嗯，如果你有s one和s two，s
    one减去s two就是保留这个弯月形区域作为输出。好了，这就是s one减去s two的计算方式。我们看到的SQL表达式是`except`。
- en: So let's work， work through an example。 In this case。 my relation instance is
    s one and s two and I'm trying to s one minus s two。 So I retain all of the tuples
    in s one that are not found in s two。 So going through this list 22 is certainly
    not found in s two 31 is found in s two。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们通过一个例子来进行演示。在这个例子中，我的关系实例是s one和s two，我正在计算s one减去s two。所以我保留所有在s one中但不在s
    two中的元组。所以遍历这个列表，22显然不在s two中，31在s two中。
- en: So that's not going to be part of the output 58 is part of s two as well。 So
    I'm going to get rid of that。 So overall， I'm left with one output to which is
    22 right the one corresponding to 22。 And you can try this yourself at home s
    two minus s one has two output to this。 So far set difference。 Do we need to eliminate
    duplicates like we did for unions in relation algebra。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这不会成为输出的一部分，58也在s two中。所以我要去掉它。所以总体来说，我剩下一个输出元组，就是22，对应于22的那个元组。你可以自己在家试试，s
    two减去s one有两个输出元组。这就是到目前为止的集合差。我们需要像在关系代数中做并集时那样去除重复吗？
- en: This is a question for you folks。 Right， so most I see a few answers in the
    chat， basically， no。 right， the answer is no。 And this is because all we are doing
    is taking s one and then throwing out some of the stuff from s one。 Right， since
    s one does not contain any duplicates。 I don't need to further eliminate duplicates
    from the result。 Right， so s one。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是给你们的问题。对吧，我在聊天中看到了一些答案，基本上是没有的。对，答案是没有。这是因为我们所做的只是从集合s1中取出一些内容，然后将其删除。对吧？由于s1中不包含重复项，我不需要进一步从结果中删除重复项。对，所以是s1。
- en: I started with s one and then I threw out some stuff s one doesn't have any
    duplicates。 And therefore， after throwing out some stuff， I'm still not going
    to have any duplicates。 Okay。 Okay， so， so this is not required。 We talked about
    the SQL expressions for this。 except we discussed earlier。 There's also accept
    all this is the same semantics as union or union all in except in SQL duplicates
    are eliminated if they exist in relation algebra。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我从s1开始，然后删除了一些内容，s1中没有重复项。因此，在删除一些内容之后，我仍然不会有重复项。好的。好的，这不是必需的。我们之前讨论过SQL表达式，除了我们早些时候讨论过的内容，还有“except”和“all”操作，这与SQL中的并集或并集所有操作语义相同，在关系代数中，如果存在重复项，它们将被删除。
- en: Of course， they don't exist in the input relations。 Right。 So there are no duplicates
    in the input relations。 That's why we didn't require to do this after having computed
    the result。 Okay。 so we're getting into more interesting operations。 So let's
    look at cross product。 Okay。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它们在输入关系中并不存在。对吧？所以输入关系中没有重复项。这就是为什么我们在计算结果后不需要进行去重操作。好的，现在我们进入一些更有趣的操作。让我们来看看笛卡尔积。好的。
- en: so the cross product of two relations are one and s one means that every row
    in our one is paired with every row in s one。 So if I have these two relations，
    then I basically take the bipartite graph of these two relations and I compute
    all pairs。 Right。 So I have six output to books。 So that's a cross product。 So
    how many rows do I have in the results。 So let's say the size of our one。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，两个关系的笛卡尔积，即r1和s1，意味着r1中的每一行都与s1中的每一行配对。所以如果我有这两个关系，我基本上就是计算这两个关系的二分图，并计算所有配对。对吧？所以我有六个输出结果。这就是笛卡尔积。那么我结果中有多少行？假设r1的大小是这个。
- en: which is usually denoted this way is this。 And the size of our s one is this。
    how many rows do I have in my result。 Yeah， our one into our two or our one times
    as one， right。 It's basically the product of the size of the two relations because
    every relation every to pull in one relation。 spared with every two pull in the
    other relation。 Do we need to worry about schema compatibility in this case。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这样表示的是这个。我们s1的大小是这个。我的结果中有多少行？是的，s1与s2的笛卡尔积，或者说s1乘以s2，基本上是这两个关系大小的乘积，因为每个关系中的每一行都会与另一个关系中的每一行配对。我们需要担心模式兼容性吗？
- en: Not really right these two relations can have arbitrary schemas and so we don't
    really need to worry if they are compatible in any way。 Do we need to do duplicate
    elimination。 Well， again。 this is not necessary because the two inputs don't have
    duplicates。 And therefore。 you can hopefully convince yourself that even in the
    output you're not going to have any duplicates。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种关系并不完全正确，它们可以有任意的模式，因此我们不需要担心它们是否以某种方式兼容。我们需要做去重操作吗？嗯，再次强调，这并不是必要的，因为这两个输入没有重复项。因此，您应该能够说服自己，即使在输出中也不会有重复项。
- en: Okay。 Any questions so far。 Okay， okay。 All right， so here's another interesting
    operation。 This is the renaming operation， which is denoted as this P looking
    symbol Greek symbol。 also known as the role。 Okay， this is how it's pronounced。
    Okay， great。 So， need us。 How do names work when the cross product happens that's
    precisely what I'm going to be talking about now。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止有问题吗？好的，好的。好的，那么这是另一个有趣的操作。这是重命名操作，通常表示为这个P形状的希腊符号，也被称为角色。好的，这就是它的发音。好的，很好。那么，重命名如何工作呢？当笛卡尔积发生时，正是我现在要讲解的内容。
- en: Tommy says， I probably missed something but why doesn't our one have duplicates。
    Well。 the inputs don't have our sex， right in relation algebra。 These relations
    are sets。 And therefore。 we are under set semantics。 So the inputs don't have
    duplicates。 In this particular case。 after you've done the cross product， you
    won't have any duplicates either。 Okay。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Tommy说，我可能漏掉了什么，但为什么我们的关系中没有重复项呢？嗯，输入没有重复项，对吧？在关系代数中，这些关系是集合。因此，我们遵循集合语义。所以输入中没有重复项。在这个特定情况下，在执行笛卡尔积之后，你也不会有重复项。好的。
- en: so renaming allows you to rename relations and their attributes。 And this is
    convenient to avoid confusion when two relations overlap in their attribute set。
    Okay。 we can omit the output name if we don't want to remove the output。 Okay，
    so sorry。 if we don't want to rename the output。 So let's say our one is looks
    like this。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以重命名允许你重命名关系及其属性。这对于避免当两个关系在属性集上重叠时的混淆很方便。好的。如果我们不想重命名输出，可以省略输出名称。好的，抱歉。如果我们不想重命名输出。假设R一个看起来是这样的。
- en: So I have sid bid and day。 These are my three attributes。 I can rename it into
    our with sid to the ID to and day using this syntax。 So you can see that this
    is the output relation name。 And these are the three attributes。 And basically
    I'm listing them here in the order in which they are listed within our one。 Okay。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我有sid，bid和day。这是我的三个属性。我可以使用这种语法将它们重命名为sid，ID和day。你可以看到这是输出关系的名称。这是这三个属性。基本上，我在这里按R一个中列出的顺序列出了它们。好的。
- en: so sid is getting renamed to sid to be ID is getting named to be to and day
    is getting renamed to day。 Okay， so here I did not change day kept it as is。 I
    can be since day is not getting renamed。 I can use a shorthand here。 It's not
    really all that shorter in this particular instance and certain other instances。
    It could be shorter， where I say， well， the sid the input is getting transformed
    to sid to in the output and。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以sid被重命名为sid，ID被重命名为to，day被重命名为day。好的，所以这里我没有改变day，保持不变。因为day没有被重命名，我可以在这里使用简写。虽然在这个具体实例中并没有真的变得更短，在某些其他情况下它可能会更短，我说，嗯，输入的sid被转换为输出中的sid。
- en: I use this arrow sign to indicate that。 Okay， so these are two separate notations
    that essentially mean the same thing。 If I didn't want to rename the relation，
    I can drop this R and that would also work。 Okay。 that's if I didn't want to rename
    the relation， so it'll retain the same name R one。 There is one more sort of way
    for renaming another shorthand for renaming。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这个箭头符号来表示这一点。好的，这两种表示法基本上是一样的。如果我不想重命名关系，可以省略这个R，这样也可以。好的。那就是如果我不想重命名关系，它将保留相同的名称R一个。还有一种重命名的方法，另一种简写方式。
- en: This is using the list position。 So this is going after needs question。 So if
    I did。 A cross product， and for example， some of the attribute names are common
    in the two input relations。 This gives me a shorthand for referring to those attribute
    names and then renaming them。 So here I did cross product of R one and S one。
    I have one attribute in our one called sid。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用列表位置。所以这是在需要的情况下的问题。如果我做了一个叉积，例如，其中一些属性名称在两个输入关系中是相同的。这样我就能用简写来引用这些属性名称，然后重命名它们。所以这里我做了R一个和S一个的叉积。我在R一个中有一个叫做sid的属性。
- en: I have one attribute in S one called sid。 And I don't really want a relation
    that ends up having the two attributes with the same name。 That's that's not desirable。
    I don't know how to refer to those two attributes separately。 So one way to do
    this would be to rename the output if I wanted。 I could call this temp one。 And
    then I point at the first attribute。 And I'm renaming that as sid one and the
    fourth attribute and renaming that as sid two。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我在S一个中有一个叫做sid的属性。我不想得到一个包含两个相同名称属性的关系。那样是不理想的，我不知道怎么分别引用这两个属性。所以解决这个问题的一种方法是，如果我想的话，可以重命名输出。我可以称之为temp一个，然后指向第一个属性，并将其重命名为sid一个，第四个属性并将其重命名为sid两个。
- en: So this cross product， the convention is that the attribute of R one are listed
    first and then the attribute of S one are listed after that。 Okay， so here the
    output after renaming is going to have this name temp one。 sid one as the renamed
    version of sid and the first sid and sid two as the renamed version of the second
    sid。 Okay。 So once again， I can omit the output name if I don't want to rename
    the output。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个叉积，约定是先列出R一个的属性，然后再列出S一个的属性。好的，所以这里在重命名之后，输出将有这个名字temp一个。sid一个作为sid的重命名版本，sid一个和sid两个作为第二个sid的重命名版本。好的。所以再说一次，如果我不想重命名输出，可以省略输出名称。
- en: And for this particular case， another alternative is to not wait until you've
    done the cross product to do the renaming。 but to rename the input relations itself。
    So if I wanted to treat the attributes and the two input relations separately
    and I wanted to distinguish between them。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的情况，另一种选择是，在完成叉积之前就进行重命名，而不是等到做完叉积之后再重命名，而是重命名输入关系本身。所以如果我想将这两个输入关系中的属性区分开来，我可以重命名它们。
- en: I can give them sort of different names at source， right。 just change the names
    at source and then do the cross product。 So some look something like this。 right，
    so I could， for example， do renaming of s one。 And then do the cross product after
    that。 That's also fine。 Right。 It's always good to add parentheses to display
    your order in which you want the operations to be performed。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在源头上给它们不同的名称，对吧。只需在源头上更改名称，然后做交叉积。这样看起来像这样。对吧，所以我可以，例如，先重命名 S1，然后做交叉积。那也是可以的。对吧。总是最好加上括号，以显示你希望操作执行的顺序。
- en: We'll talk about that in a little bit。 Okay， so these are the basic operations。
    Okay。 now we'll talk about compound operations that can be expressed using the
    basic operations。 So let's start with the intersection first。 So for intersection
    like union or like set difference。 the input relations must be compatible， which
    means they have the same schema。 So same attributes。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论这个问题。好了，这些是基本操作。好了，现在我们将讨论可以使用基本操作表达的复合操作。所以我们先从交集开始。交集就像并集或集合差异一样，输入关系必须是兼容的，也就是说它们必须具有相同的模式。也就是相同的属性。
- en: same types。 The SQL expression for intersection was intercept， right， and in
    set notation。 what we're trying to compute is this part in the middle that these
    two overlapping。 So。 what's the story with duplicates， right。 So here， since the
    two input relations don't have duplicates。 When you do the intersection， you won't
    have any duplicates either。 Right。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的类型。交集的 SQL 表达式是 intercept，对吧，在集合表示法中，我们试图计算的是这两者重叠的部分。所以，重复项的问题是什么，对吧？在这里，由于两个输入关系没有重复项，当你做交集时，结果也不会有重复项。对吧。
- en: So if the inputs are sets， duplicates don't need to be eliminated。 So you don't
    need to worry about duplicates for intersection under set semantics for relational
    algebra。 Okay， so we already know that intersection with this upside down you。
    Also in later you would call this a cap。 This is a compound operator。 So how would
    you。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果输入是集合，就不需要去除重复项。所以在关系代数的集合语义下，交集不需要担心重复项。好了，我们已经知道，交集用倒立的 U 表示。以后你们会称之为
    cap。这是一个复合操作符。那么，你该怎么做呢？
- en: how do you express this using the other operations that we've described so far。
    Any thoughts。 So。 just say that again， just just guessing cross minus union。 So
    the cross product minus the union。 The cross product unfortunately is going to
    end up changing the schema。 Right。 So you don't want that to happen。 As soon as
    you change the schema。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何使用我们迄今为止描述的其他操作来表达这个呢？有什么想法吗？那么。再说一遍，猜测交叉减去并集。所以交叉积减去并集。不幸的是，交叉积最终会改变模式。对吧。所以你不希望那样发生。一旦你改变了模式。
- en: you can no longer apply set oriented operations。 The set oriented operations
    all have to preserve schema。 right。 You have to， you have to。 Okay， so I see some
    complex expressions。 Nicholas。 Wait。 I just thought of something and then I forgot。
    Okay。 All right。 Don't worry about it。 Okay。 so let's walk through this and see
    if， okay， Chris， I think has the solution。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能再应用集合导向的操作了。集合导向的操作必须保持模式不变。对吧。你必须，你必须。好了，我看到一些复杂的表达式。尼古拉斯。等等，我刚刚想到了什么，但又忘了。好了。别担心。好了，让我们走一遍这个过程，看看，好的，克里斯，我想他有解决方案。
- en: So let's walk through this。 And see if this makes sense to everyone。 Okay。 So
    let's start by talking about this portion， right。 the overlap portion and see
    how we might get it。 Right。 So one way to get it is to start with S one and then
    drop the present part。 Actually。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们走一遍这个过程，看看这个对大家有没有意义。好了，让我们从讨论这个部分开始，对吧。重叠的部分，看看我们如何得到它。对吧。得到它的一种方法是从 S1
    开始，然后去掉现有部分。其实。
- en: you can do this the other way as well。 Right。 You can start with S two and then
    drop the corresponding present part on S two。 but see how we just deciding to
    start from S one and then drop the caressant part from as well。 Right。 So you
    have this full circle and you want to drop the present part。 You're left with
    this gray part。 Have you seen this present part before？ Well， yes， we have， right。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以反过来做。对吧。你可以从 S2 开始，然后去掉 S2 中对应的现有部分。但看看我们为什么决定从 S1 开始，然后去掉相应的部分。对吧。所以你有这个完整的圆圈，你想去掉现有部分。剩下的是这个灰色的部分。你见过这个现有部分吗？嗯，是的，我们见过，对吧。
- en: So we know how to compute this present part。 This present part， which is this
    part。 Sorry。 this part is basically just S one minus S two。 Right。 So overall。
    what I have is S one minus the present part， which is itself S one minus S two。
    Okay。 So this is a pretty simple expression。 Likewise， I could do S two minus
    S two minus S one and you can hopefully convince yourself that that works as well。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道如何计算这个当前部分。这个当前部分，就是这部分。抱歉，这部分基本上就是S1减去S2。对吧。所以总体上，我有的是S1减去当前部分，而当前部分本身就是S1减去S2。好的。这个是一个相当简单的表达式。同样地，我可以做S2减去S2减去S1，且你可以希望自己也能证明这是可行的。
- en: Okay。 Moving on to joints。 Okay。 So joints are compound operations， just like
    intersection。 And generally， joints look like this， you sort of have a cross product
    and then you have some selection。 We might end up renaming something in that。
    Okay， so let's work through some alternatives and then see when renaming might
    be needed。 So joints have increasing degrees of specialization。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来讲连接。好的，连接是复合操作，就像交集一样。通常，连接是这样的，你有一个笛卡尔积，然后做一些选择。我们可能会在这个过程中重命名一些东西。好的，让我们来研究一些替代方案，然后看看何时需要重命名。所以连接有越来越高的专门化程度。
- en: So the easiest or rather the most powerful form of join is a theater join。 A
    theater join is basically has a sub has a subscript theta and it's on the。 it's
    a join on the logical expression theta and this symbol。 which is a bow tie is
    is the universal symbol for a join。 Okay。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以最简单或者更准确地说，最强大的连接形式是θ连接。θ连接基本上有一个下标θ，它基于逻辑表达式θ进行连接，这个符号——蝴蝶结符号就是连接的通用符号。好的。
- en: An equally join is basically a theta join where theta is a conjunction of a
    qualities。 And even more special version of join is a natural join and we've seen
    this before in the sequel lectures。 a natural join has no subscript。 It's just
    the bow tie。 This natural join is an equa join on all matching column names。 Okay。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 等值连接基本上是一个θ连接，其中θ是等式的合取。还有一个更特殊版本的连接是自然连接，我们在SQL讲座中见过这个。自然连接没有下标。它只有蝴蝶结符号。这个自然连接是对所有匹配列名的等值连接。好的。
- en: and the guarantee that you get it for free is that only one copy of each of
    these matching column names will be preserved in the article。 So let's work through
    examples of these next。 Okay。 So before that I wanted to say that joins are a
    super crucial。 And the cross product which I derived from are super crucial primitive
    in in database systems。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你能免费获得的保证是，只有一个匹配列名的副本会保留在结果中。好的，让我们接下来通过这些例子来学习。好的，在此之前我想说的是，连接是非常关键的。笛卡尔积是我从中推导出的数据库系统中的超级关键原语。
- en: They're really， really important in relating information across different tables。
    And we'll spend a ton of time worrying about how to efficiently execute joins。
    Okay。 so a lot of the subsequent lectures are going to be focused on how to be
    efficiently execute joins。 especially if you're joining many， many tables at a
    time。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在不同表之间关联信息时非常重要。我们将花很多时间关注如何高效地执行连接。好的，所以接下来的许多讲座将重点讨论如何高效执行连接，特别是当你同时连接很多表时。
- en: And the thing that we certainly want to avoid is to do cross product cross products
    are just blowing up the output unnecessarily and if we can。 unless the user explicitly
    requested we are going to try to avoid it we can。 we're going to try to find ways
    around it。 So these。 like I said we're going to spend a ton of time spending on
    on how to design efficient join algorithms。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定想要避免的事情是执行笛卡尔积，笛卡尔积会不必要地膨胀输出。如果可能的话，除非用户明确请求，我们会尽量避免它。我们会尽量找出绕过它的方法。所以，正如我所说，我们将花大量时间研究如何设计高效的连接算法。
- en: Okay， so starting from the first join variant， theta join， here's a semantics
    of theta join， right。 here's how it would express theta join using the other operations。
    So theta join is simple。 It's basically our cross product with s。 And then you
    do a sigma， a selection using theta。 So apply cross product and then filter out
    two pills that don't match the condition theta。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，从第一个连接变体——θ连接开始，下面是θ连接的语义。对吧？这是如何使用其他操作表达θ连接的方法。所以θ连接很简单。它基本上就是我们的笛卡尔积与S相乘。然后你做一个σ，即使用θ的选择。也就是说，先应用笛卡尔积，然后筛选出不满足θ条件的两列。
- en: So if theta only contains equality conditions with an and a clause between them。
    This is called an equity joint。 Okay， so it's a special case of theta。 theta join
    where theta only contains predicates that are equalities。 So here's an example
    of a theta join。 So let's say I want to find boats that people have reserved。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果theta只包含带有and子句的相等条件，这就叫做等值连接。好吧，这是一种特殊的theta连接，theta只包含相等的谓词。这里是一个theta连接的例子。假设我想找出人们预定的船只。
- en: Okay， I have my input relation R one， I have my input relation S one。 and I
    wanted to do a theta join between them。 And I say， hey， you know what。 I'll go
    with s ID equals s ID。 Right。 And this is what I want my output to look like。
    Right。 I want to relate the corresponding two pills in the two relations。 Right。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我有我的输入关系R1，我有我的输入关系S1。我想在它们之间做一个theta连接。我说，嘿，知道吗？我会选择sID等于sID。对吧？这是我希望输出的样子。我想将两个关系中相应的记录关联起来。对吧？
- en: And so these two two pills are part of the output。 So this is an issue， right。
    I can't really interpret this clause， because I don't know which s ID I'm referring
    to for each of these because each of all one and S one has one side。 Right。 So
    this particular expression is hard to interpret。 So how do we fix this expression。
    any thoughts using the operation that we discussed previously。 Rename them。 Right。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这两个记录就是输出的一部分。那么，这就是问题所在，对吧？我无法真正解读这个子句，因为我不知道每个sID指的是哪个，因为s1和S1中每个都只有一边。对吧？所以这个表达式很难解读。那么，我们该如何解决这个问题呢？有没有想法，使用我们之前讨论过的操作？重命名它们。对。
- en: So you might want to rename one of the two relations。 So how might we rename。
    Well。 one option is to rename S one or R one。 Let's say I decided to rename。 So
    I say， hey。 I'm going to take s ID。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能想重命名其中一个关系。那么，怎么重命名呢？嗯，一个选择是重命名S1或R1。假设我决定重命名。假设我说，嘿，我要取sID。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_3.png)'
- en: '![](img/025522cdd402d8e827702d5842b49a5a_4.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_4.png)'
- en: Okay。 All right。 I'm going to try again。 I'm going to take s ID and then I'm
    going to map it to s ID one。 Okay。 I'm going to do this to all one。 So it's basically
    now all one with s ID being transformed into s ID one。 I can then do a theta join
    on s ID one is equal to s ID with s one。 Okay。 Now I know where each of these
    attributes is coming from s ID one is coming from this s ID is coming from this。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题，我再试一次。我将sID取出来，然后映射到sID1。好的，我对所有的1都做了这个操作。所以现在，所有的1都将sID转换为sID1。然后，我可以对sID1和sID做theta连接。好的，现在我知道每个属性是从哪里来的，sID1来自这里，sID来自那里。
- en: Okay。 So this is no longer an issue。 All right。 So this was my read， I think
    to fix this issue。 Right。 So I basically renamed one of the two input relations。
    And that's precisely what I did here。 So let's try another example。 This is an
    example of a self join。 So I have my sealers table。 I'm calling it s one and I
    want to find for every sailor。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，问题已经解决了。好了，这是我之前的理解，我认为解决这个问题就是这样。对，我基本上是重命名了两个输入关系中的一个。这正是我在这里所做的。我们再试一个例子。这是一个自连接的例子。我有一个水手表格，我称之为s1，我想为每个水手找出符合条件的数据。
- en: I want to find other sailors who are more senior than that sailor。 Right。 So
    how might we do this。 This is actually how the output looks like。 So the output
    is basically or rather the query looks like this。 I'm basically taking one copy
    of s one and then renaming it。 The reason I'm renaming it is because I don't want
    the attributes of this。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我想找出比那个水手资历更高的其他水手。对吧。那么我们怎么做呢？这实际上是输出的样子。查询大致是这样的。我基本上是取了一个s1的副本，然后重命名它。重命名的原因是因为我不希望这个副本的属性和原来的重复。
- en: And then I'm doing a relation and the other relation to clash。 Right。 So I took
    one copy of s one and then I renamed all of its attributes。 I have yet another
    copy of s one。 And then I'm doing a theta join where I'm using the condition age
    one is less than age。 right， which is what I want to enforce。 I want to find for
    every sailor。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我做了一个关系连接，另一个关系发生了冲突。对吧。我拿了一个s1的副本，然后重命名了它的所有属性。我又有了另一个s1的副本。然后我做了一个theta连接，条件是age1小于age，对吧，这就是我要强制执行的条件。我想为每个水手找出符合条件的记录。
- en: I want to find other sailors were more senior。 So this sort of adding in renames
    to sort of change the name change the names of intermediate relations is pretty
    common in relation algebra。 So get used to doing that to ensure that the conditions
    that you're enforcing， for example。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我想找到那些更资深的水手。因此，添加重命名操作以改变中间关系的字段名在关系代数中是非常常见的。所以，确保你在执行条件时对中间关系进行重命名，这一点要习惯。
- en: for joints or selection subsequently are not ambiguous。 Right。 In this case。
    it's it's clear what age one and age mean because there's a single copy coming
    from each of the input relations。 So in this particular example， the before the
    condition is enforced before age one is less than ages and force。 This is what
    the result is going to look like。 This is just a cross product off the renamed
    copy of s one and s one。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于联接或选择操作，随后的操作没有歧义。对吧？在这种情况下，age1和age的含义很明确，因为它们分别来自输入关系中的单一副本。所以在这个特定的例子中，在age1小于age的条件强制执行之前，结果将如下所示。这实际上是s1和s1的重命名副本的笛卡尔积。
- en: So I have s I D one as name one rating one age one as coming from the left hand
    side and then s I D as name rating and age coming from the right hand side。 And
    then now I'm using the condition to throw away some tuples so I can throw away
    this to pull this to pull this to pull and so on。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我有sid、name、rating、age这些列分别来自左边的表和右边的表。接下来，我使用条件丢弃一些元组，因此我可以丢弃这些元组，依此类推。
- en: And so eventually I'm left with these three tuples。 Okay。 Any questions about
    this。 So moving on to natural joints。 So this is a special case of an equijoin
    where equality's are specified for all fields that match between the two relations
    and duplicate fields are projected away。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我只剩下这三个元组。好的，关于这个有任何问题吗？接下来是自然联接。自然联接是等值联接的一个特殊情况，要求两个关系之间匹配的所有字段都必须相等，并且重复的字段会被去除。
- en: Right。 So you only have a single copy of each feed。 So conceptually kind of
    looks like this you compute our cross product with s you select the rows where
    feels appearing in both the relations have equal values。 and then project onto
    the set of unique fields。 So that's really the conceptual flow for a natural joint。
    So here's an example of a natural joint here again I'm doing a joint between reserves
    and and sailors。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以你只有每个字段的单一副本。从概念上讲，流程大致如下：你计算R和S的笛卡尔积，选择在两个关系中出现且值相等的行，然后投影到唯一字段的集合上。这就是自然联接的概念流程。下面是一个自然联接的例子，这里我正在做一个reserves和sailors之间的联接。
- en: I start by doing a cross product。 So basically relating every tuple here with
    every two pull here。 So I have six tuples right in this intermediate result。 Then
    I look at the attributes that are in common that the only attribute that is in
    common is SID and I try to keep only the tuples where SID is the same for these
    two for these two columns。 Right。 So it's basically the same value in these two
    columns。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我从做笛卡尔积开始。基本上就是将这里的每个元组与这里的每个元组关联。因此，我在这个中间结果中得到了六个元组。然后我查看共同的属性，唯一共同的属性是SID，我尝试保留SID相同的元组。对吧？所以这两个列中的值基本上是相同的。
- en: So I throw out some of the tuples because they don't match the condition。 Now
    I'm left with the two result tuples， but I want to ensure that the column names
    are unique。 So I throw away one of the copies of this sid。 So eventually I'm left
    with a single copy of sid bid day。 both coming from our one and then S name rating
    age coming from S one。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我丢弃了一些元组，因为它们不符合条件。现在我只剩下两个结果元组，但我想确保列名是唯一的。所以我丢弃了其中一个副本的sid。最终我只剩下sid、bid、day这些列，所有这些都来自我们的第一个表，然后是S表中的name、rating、age。
- en: So this is a very common commonly used primitive， especially for foreign key
    joints。 So here I have a foreign key from our one to S one right on sid。 And so
    this is a fairly common use case for for a natural joint。 So now one question
    is。 we know that john and not all variants of joints are compound operators。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常用的操作，尤其是在外键联接中。这里我有一个从R1到S1的外键，正好是在sid字段上。所以这是自然联接的一个常见用例。现在有一个问题是，我们知道联接并不是所有的联接变体都是复合操作符。
- en: How do we express our one natural join with S one using the other operators。
    So again。 what we might end up doing here is to do a renaming right to ensure
    that we can have distinguishable copies of our two columns。 And then we might
    end up doing a cross product followed by a projecting out of the common attributes。
    And that's going to be our recipe here。 So， so we'll start with s one。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用其他运算符表达一个自然连接与S1的操作？再一次，我们可能最终做的是重命名操作，以确保我们可以区分两列的副本。然后，我们可能会做一个交叉乘积，接着投影出公共属性。这将是我们的操作步骤。所以，我们将从S1开始。
- en: we'll rename the common attribute sid to sid one， we'll do a cross product。
    And then we'll do a selection。 And then we will project out attributes until we
    are left with a single copy of each attribute。 And hopefully this makes sense。
    And another way to read this which is not pertinent to this example but in general
    is you take s one and then you rename the fields that you're going to match equality
    on。 You do the cross product， and then you match the fields by quality that are
    common across the two inputs。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重命名公共属性sid为sid1，进行交叉乘积。然后我们会做选择操作。接着，我们将投影出属性，直到我们只剩下每个属性的一份副本。希望这能让你明白。另一种读取方式是，虽然这与当前示例无关，但一般来说，你首先处理S1，然后重命名你要匹配相等性的字段。你做交叉乘积，然后匹配两个输入中共同的字段。
- en: And then you keep one copy of each field as part of the output。 So we've talked
    about these three joint variants that are also the other joint variants that we
    covered in the sequel lectures the left out a giant right out a giant and full
    out a giant。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会保留每个字段的一份副本作为输出的一部分。所以我们已经讨论了这三种连接变体，还有我们在后续讲座中介绍的其他连接变体，比如左外连接、右外连接和全外连接。
- en: This is how these symbols look like so it's small variants of the bow tie。 So，
    for example。 you're indicating that even two posts on the left hand side that
    don't match anything on the right hand side are still added to the output with
    a nulls being padded。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些符号的样子就是这样，它们是蝴蝶结的小变体。例如，你表示即使左侧的两个帖子与右侧的任何内容都不匹配，它们仍然会被添加到输出中，并且会填充空值。
- en: So， you indicate that where these two projections that that sort of stick out
    of this photo。 Now we've talked about relational algebra the basic operations
    right so we've talked about the basic ones as well as the compound ones is about
    eight operations in total。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你表示这些投影就是那种从照片中突出出来的部分。现在我们已经讨论了关系代数中的基本操作，已经涵盖了基础操作和复合操作，总共有大约八个操作。
- en: Now let's talk about how to compose more complicated expressions。 So。 algebra
    in general linear algebra relation algebra elementary algebra allow you to express
    sequences of operations in a natural way and compose。 So in elementary algebra
    arithmetic algebra you can do it like this for example right so you're multiplying
    two separate operations which are two separate operands。 which are themselves
    the result of other operations for example， plus or minus。 Right。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈如何组合更复杂的表达式。一般来说，代数、线性代数、关系代数和初等代数都允许你以自然的方式表达操作序列并进行组合。因此，在初等代数中，你可以像这样做，例如：你正在乘以两个独立的操作，它们是两个独立的操作数，这些操作数本身是其他操作的结果，比如加法或减法。
- en: Relational algebra allows you to do the same。 There are three different ways
    that you can express this one is a sequence of assignment statements。 Another
    is an expression with several operations operators like this one。 And you can
    also express them as expression trees and we'll see examples of each of these。
    So sequences of assignments are convenient if you have a very complex looking
    relational algebra expression。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关系代数允许你做同样的事情。你可以通过三种不同的方式来表示这个操作：一种是赋值语句的序列，另一种是带有多个运算符的表达式，还有一种是表达式树的形式，我们将看到这些每种方式的例子。所以，当你有一个非常复杂的关系代数表达式时，赋值序列是很方便的。
- en: So you basically end up creating temporary relation names。 So you take intermediate
    results and then give it a name。 Right。 So。 the naming both of the relation as
    well as the attribute names can be done in situ at the time you are doing an assignment
    by giving a list of attributes。 So you can take our one and then say， you know
    what I'm going to rename the attributes of our one to X and Y via this syntax
    and also rename our one itself to our three。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你基本上会创建临时的关系名称。也就是说，你拿到中间结果然后给它起个名字。对吧。所以，关系和属性名称的命名可以在你做赋值时通过列出属性名来完成。你可以拿到我们的关系
    R1，然后说，知道吗，我要把 R1 的属性重命名为 X 和 Y，通过这种语法，R1 自身也重命名为 R3。
- en: So if I wanted to do a theta join between our one and our two。 So theta with
    the condition C being replacing theta。 I can express this in two steps I can say
    our four is our one across product with our two and then our three is the result
    of applying a selection。 Theta of theta is equal to C to our four。 Okay， so we've
    seen some expressions with multiple operations。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在 R1 和 R2 之间做一个 θ 连接，假设 θ 的条件是 C。我可以分两步来表示这个操作。我可以说，R4 是 R1 和 R2 的笛卡尔积，接着
    R3 是应用选择操作，θ(θ = C) 到 R4 的结果。好的，我们已经看过一些包含多个操作的表达式。
- en: If you have an expression with multiple operations operators within them。 you
    need to talk about precedence。 Okay， so the first sort of rule of thumb here is。
    don't worry about these precedence rules just use parentheses。 That's my recommendation
    just use parentheses。 It's it's the most straightforward way to express precedence
    express your intent in how the relational algebra expression should be read。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含多个操作符的表达式，你需要讨论优先级。好的，所以这里的第一个经验法则是：不用担心这些优先级规则，只需要使用括号。这是我的建议，直接使用括号。这是最直接表达优先级、表达你如何阅读关系代数表达式的方式。
- en: But if you wanted to be lazy about adding parentheses。 This is how I would read
    a relational algebra expression。 I would start with the unary operation。 So select
    project and rename。 They have the highest residence。 Then are the sort of the
    product and the joints across products in the joints。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你想懒得加括号，这是我解读关系代数表达式的方式。我会从单目运算开始。比如选择、投影和重命名，它们具有最高的优先级。接着是乘积和连接，跨乘积和连接。
- en: And then finally you have the set operations。 Okay。 so this is a convention
    that is typical for more complex relational algebra expressions。 but I would recommend
    instead using parentheses to force whichever order you choose。 Okay。 so let's
    talk about expression trees。 So this is a third representation。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后是集合操作。好的，这是一个常见的约定，通常用于更复杂的关系代数表达式。但我建议还是使用括号来强制规定你选择的顺序。好了，我们来谈谈表达式树。这是第三种表示方法。
- en: and this might come in useful as we are discussing how to do sort of query planning
    and optimization as well。 So in expression trees， the leaves are the operand。
    So these are the relations in our context。 and the inner nodes are the operators。
    And they are applied to their one child if it's unary or children if it's binary。
    So if I have， let's say two relations are an S reserves and sailors once again。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们讨论如何进行查询规划和优化时可能会派上用场。所以在表达式树中，叶子节点是操作数。也就是说，在我们的语境中是关系，而内部节点是运算符。它们会应用到自己的一个子节点（如果是单目运算符）或多个子节点（如果是双目运算符）。所以如果我有两个关系，假设是
    S reserves 和 sailors。
- en: And I wanted to find the sids of all the sailors who is rating is greater than
    five or have reserved 100。 Okay， how might I do this？ Well， I'll break this up
    into two parts。 Right。 I want to find the sid of all sailors who's rating is greater
    than five or have reserved 100。 I recognize that this rating information is in
    S， while the boat information is in our。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 而我想要找到所有评级大于 5 或者预定了 100 的水手的 sid。好的，我该怎么做呢？我将这个分成两部分。对吧。我想要找到所有评级大于 5 或者预定了
    100 的水手的 sid。我意识到评级信息在 S 中，而船只信息在 R 中。
- en: so I'm going to have to combine the information across these two relations。
    So let's say I start with this part first。 Okay， as I do of all the sailors who's
    rating is greater than five。 I'll start with S。 And then I could， for example，
    do a sigma， and then say。 I want those with rating greater than five。 And then
    I project out everything else and keep just the sid。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我需要将这两个关系之间的信息结合起来。假设我先从这一部分开始。好吧，我做的是所有评级大于 5 的水手。我从 S 开始，然后我可以举个例子，做一个选择操作（σ），然后说，我想要那些评级大于
    5 的水手。接着我把其他信息投影出去，只保留 sid。
- en: Okay， so I've computed one part of my result。 The second part of the result
    is from those who have reserved boat 100。 So for this， I'm going to start with
    our。 I'm going to then have a selection condition just like I did with S and say。
    BID is equal to 100。 And once again， I'm going to have my projection with sid。
    Okay。 retain sid because that's all that I want in the output。 And finally。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我已经计算出了结果的一部分。结果的第二部分来自那些预定了100号船的人。所以对于这个，我将从r开始。然后我会有一个选择条件，就像我在S中做的那样，表示BID等于100。再次，我会有一个投影操作，只保留sid。好的，保留sid，因为这是我在输出中需要的内容。最后。
- en: I can do a union to get the results from both sides。 Okay， so this is basically
    the result。 Okay。 Any questions on this？ All right， so this was the same thing
    that I drew。 So stepping back a little bit， I want to sort of revisit why we studied
    relational algebra and why we spent a lot of time discussing these relational
    algebra expressions。 So relational algebra expressions， just like in high school，
    algebra， linear algebra。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以做一个联合操作，将两边的结果合并。好的，这基本上就是结果。好的，这有问题吗？好吧，这和我之前画的东西是一样的。所以稍微回顾一下，我想重新审视一下我们为什么要学习关系代数，以及我们为什么要花很多时间讨论这些关系代数表达式。关系代数表达式，就像在高中学代数、线性代数一样。
- en: these are really easy for a， for a database system to manipulate。 And the number
    of operators is also really small， so it's easy to work with so it's actually
    easy to manipulate it。 simplify it， sort of rewrite it。 And to figure out how
    to rewrite and simplify linear sort of relational algebra expressions。 the database
    system uses various heuristics for these rewrites。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对数据库系统来说很容易操作。而且操作符的数量也很少，所以很容易处理、简化、重写。为了弄清楚如何重写和简化线性类型的关系代数表达式，数据库系统使用了各种启发式方法来进行这些重写。
- en: as well as various cost functions to pick between various rewrites。 Okay。 I
    want to give you some examples of the types of rewrites that the database system
    may consider。 we'll dwell on these rewrites and which of them might make more
    sense later on in the class later on in the course。 Okay， so here is one simple
    rewriting。 Right， so this simple rewriting says， hey。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以及各种成本函数，用来在不同的重写方式之间做选择。好的，我想给你们一些数据库系统可能考虑的重写方式的例子。我们将在课程后面深入讨论这些重写方式，以及哪些更有意义。好的，这里是一个简单的重写。对，这个简单的重写表示，嘿。
- en: I have to conditions， expression one and expression two， and I'm applying both
    of them to are。 I can certainly split these up。 By having expression one this
    condition being applied to the result of the selection on expression to apply
    to our likewise I can have this condition expression to being applied after expression
    one。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我有两个条件，表达式一和表达式二，我正在将它们同时应用于某个操作。我当然可以把它们分开处理。通过将表达式一这个条件应用于表达式二的选择结果，我同样可以在表达式一之后应用表达式二这个条件。
- en: and none of these actually， change the result， okay， apologies for the two quality
    signs。 Okay。 so all of these are the same， these are all equivalent rewrites。
    Another example。 really powerful example is changing the order in which the joints
    are evaluated。 Instead of joining r and s and then doing the joint with T。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这些实际上并不会改变结果，好的，为两个质量符号道歉。好的，这些都是一样的，它们都是等价的重写。另一个例子。一个非常强大的例子是改变连接运算的顺序。我们可以先连接r和s，然后再与T做连接。
- en: I can instead join s and t and then do the joint with our。 Okay。 Oh。 I see a
    lot of questions with the and here， this is just a shorthand for a and D。 Okay。
    Any other questions。 Okay。 Okay， here's another example of a really cool rewrite。
    Okay。 so this is called predicate push down super important might as well learn
    it now but you'll also learn it again later。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以先连接s和t，再与r做连接。好的，哦，我看到很多关于"和"的疑问，这只是"和"与"D"的简写形式。好的，还有其他问题吗？好的，好的，这里是另一个非常酷的重写例子。好的，这个叫做谓词下推，非常重要，现在学了将来还会再学一次。
- en: So let's say I want to find reservations for sailors was ages greater than 40。
    and I have these two relations are an s， are one and s one。 I can do this via
    this expression。 right， so here， I basically want to do a natural join of these
    two relations。 then I want to throw out all of the sailors ages greater than 40。
    Basically do it like this。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想查找年龄大于40岁的水手的预订信息，并且我有这两个关系，r和s，r1和s1。我可以通过这个表达式来实现。对，所以这里我基本上是想对这两个关系做一个自然连接。然后我想去掉所有年龄大于40岁的水手。基本上是这样做的。
- en: I do a natural joint and then do a sigma。 Okay。 Another way to rewrite this。
    And I'll give you the answer as an asking you is to do the sigma on s one first。
    and then do the natural job。 And the reason why this is okay is because this condition
    ages greater than 40 is only applicable to s one。 Okay， ages greater than 40 is
    only applicable to s one。 And therefore。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我做自然连接，再做sigma。好的。另一种重写方法，我会给你答案，而不是问你，就是先在s1上做sigma，然后再做自然连接。之所以这样可以，是因为这个条件“年龄大于40”仅适用于s1。好的，“年龄大于40”仅适用于s1。因此。
- en: you can do this first before you do the natural join。 Now this up this rewriting
    of taking a sigma a selection and then pushing it down is called a predicate push
    push down。 This is really important， because it basically reduces the size of
    intermediate results。 Right。 if for example， the result after having done this
    selection on s one is really really small。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先这样做，再做自然连接。这个重写操作，首先进行sigma选择操作然后再推到下方，叫做谓词下推。这非常重要，因为它基本上减少了中间结果的大小。对吧。如果比如说，经过这个选择操作后，s1中的结果非常非常小。
- en: So you're started with one million tuples in s one and you're left with 10 tuples。
    That's a substantial reduction。 Right， so going into the join。 you have a lot
    less input tuples that you have to work with。 And joins and cross products are
    super expensive， right。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你从一百万个元组开始，在s1中剩下了10个元组。那是一个显著的减少。对吧，因此进入连接时，你需要处理的输入元组少了很多。连接和笛卡尔积非常昂贵，对吧。
- en: because you effectively doing a quadratic sort of increase in the。 in the awkward
    because every tuple in the left hand side is matched with every tuple in the right
    hand side。 So it's great to try to reduce the size of intermediate results。 And
    so here by pushing sigma down the selection down。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你实际上是在进行二次排序的增加。这样很尴尬，因为左侧的每个元组都与右侧的每个元组匹配。所以，尽量减少中间结果的大小是很有意义的。因此，通过将选择操作推到下方来实现这一点。
- en: you get to reduce the size of the intermediate result。 So this is a rewriting
    that's put is actually quite powerful that the database system often uses。 Here's
    another example of a rewrite， and this is in eliminating a keyword that we've
    already seen in a sequel。 Right， so we saw this not in keyword that was really
    powerful in allowing us to express fairly complicated needs。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以减少中间结果的大小。所以这个重写是非常强大的，数据库系统通常会使用。这里是另一个重写的例子，消除我们在SQL中已经看到的一个关键词。对吧，所以我们看到的not
    in关键词，它在允许我们表达相对复杂的需求时非常强大。
- en: Right， so here I want to find the sailors who not reserved a certain board。
    And the most convenient way to say this was to say， select blah， blah， blah。 where
    s id not in some set， where in I'm looking at the s IDs from this reserves stable
    corresponding to boat ID 103。 Okay， so how do we express this in relation algebra。
    Right。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以在这里，我想找出那些没有预定某个船只的水手。说出这个的最方便的方法是说，选择blah，blah，blah。条件是s_id不在某个集合中，我在查看这个预定表中与船ID
    103相对应的s_ID。好吧，那么我们如何用关系代数来表示这个呢？对吧。
- en: so one approach to express this in relation algebra is this， right。 so you take
    the sailors from the。 Actually， this should be s not r。 Right， yes， it should
    be s。 Okay， take the sailors project out everything else apart from their s id。
    And then throw away those that have reserved boat ID 103。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表达这个的关系代数方法是这样的，对吧。所以你从水手表中取出……实际上，这里应该是s，而不是r。对，应该是s。好的，取出水手，将除了s_id之外的所有内容都投影出去。然后扔掉那些已经预定了船ID
    103的水手。
- en: And how do I find those that have reserved boat ID 103。 Well。 I take the two
    points corresponding to boat ID 103。 I do a natural join with s。 and this is basically
    all of the joined tuples between boat ID 103 reservations and sailor IDs。 And
    then I throw， I project out everything else apart from sailor id。 Actually。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到那些已经预定了船ID 103的水手呢？嗯，我取出与船ID 103相对应的两个点。我与s做自然连接。这基本上就是所有与船ID 103的预定和水手ID相连接的元组。然后我去掉除了水手ID之外的所有内容。其实。
- en: I know that there's a way to simplify this even further。 Any thoughts on how
    I might be able to simplify this even further。 Janelle。 Sorry。 I thought there
    was a question。 Okay， let me press the button。 Oh， okay， no worries。 So one way
    to simplify this even further， which I should have realized is to simply do pie
    s id of sigma b id is equal to 103 of power。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道有一种方法可以进一步简化这个。你有什么想法吗？Janelle。抱歉，我以为有问题。好吧，让我按一下按钮。哦，好吧，没关系。所以，进一步简化的一种方法，我本应该意识到，就是简单地做出选择，条件是sigma
    b_id等于103的幂。
- en: I don't even need to do a natural join with this。 That's even simpler。 Okay。
    Any other thoughts。 So。 Nathaniel says， why don't I take the pie outside。 Is that
    actually okay。 Can I do that？
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至不需要做自然连接。那样更简单。好吧，还有其他想法吗？所以，内森（Nathaniel）说，为什么不把派去外面？那样可以吗？我能做吗？
- en: So let's try that。 Right。 So I wanted to do s id s minus sigma b id is equal
    to 103 of R。 Can I do this。 No， right。 I can't do this because this schema of
    this is not the same as the schema of this。 Right。 And so， I can't do this。 So
    this is okay。 This is not okay。 This is also okay。 but this is involved in unnecessary
    join that I didn't realize。 Okay， Nate。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们就试试吧。对吧？所以我想做 s id 和 s 减去 sigma b id 等于 103 的 R。我可以这样做吗？不行，对吧？我不能这样做，因为这个模式与这个模式不相同。对吧？所以我不能这样做。所以这个可以，这个不行，这个也可以，但这涉及到一个不必要的连接，我没有意识到。好了，内特。
- en: do you want to describe your question。 I were looking for the names of the sailors。
    So it seems like we would need to get the name after finding the s id's。 Okay。
    I incorrectly assume that it should be s id's。 Okay。 So if it were the name。 then
    I would need to do a join。 Okay， so。 Correct。 So if I wanted to get the names。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你想描述一下你的问题吗？我在找水手的名字。所以似乎我们需要在找到 s id 后再获取名字。好的，我错误地假设应该是 s id。好的，那么如果是名字的话，我就需要做一个连接。好的，没错。如果我要获取名字的话。
- en: it would be pie s name of s minus pie s name of sigma b id is equal to 103 of
    R。 Natural join with us。 That makes sense。 Okay。 Okay。 so these two work for s
    id's this work for s name。 So the Felix's question is。 so is the surface level
    of query optimization during operations on things before joins and cross products。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是派 s 名称（s name）减去派 s 名称（s name）的 sigma b id 等于 103 的 R，与 us 做自然连接。这样有道理吗？好的。好的，这两个适用于
    s id，而这个适用于 s name。那么 Felix 的问题是，查询优化的表面层是在连接和交叉产品之前的操作上进行的吗？
- en: Yes， and no， I think that is one of many optimizations。 It's also a crucial
    step is to determine the order of the joins。 There are others as well。 but it's
    not just， it's not just trying to reduce the intermediate results。 That is an
    important consideration， but that's not just the， that's not the only consideration。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，亦是如此，我认为这是许多优化之一。确定连接顺序也是一个关键步骤。还有其他优化方法，但不仅仅是，仅仅减少中间结果。这是一个重要的考虑因素，但这不是唯一的考虑因素。
- en: Okay， so one slide on extended relation algebra beyond the simple operations
    and the derived operations。 We also have a group by operation， which is， which
    is gamma for G。 And so you can say。 I want to compute the ages and the average
    ratings per age group for sailors。 Right。 So here。 since I'm not computing any
    applying any aggregation function on age。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来是关于扩展关系代数的幻灯片，超出了简单操作和派生操作的范围。我们还可以进行分组操作，符号是 G 的伽马（gamma）。因此，你可以说，我想计算水手的年龄和按年龄组计算的平均评分。对吧？所以这里，由于我没有对年龄进行任何聚合函数运算。
- en: This is ends up being the group by column。 I can also add a having clause so
    I can say group by age。 compute the average rating and I want count greater than
    two。 And this is implicitly combining basically group by having as well as selection
    condition。 Right。 As in years， you are， you are sub selecting the fact that your
    output should have each and average rating。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终成为了分组列。我也可以添加一个 having 子句，所以我可以说，按年龄分组，计算平均评分，且想要计数大于二。这隐式地将“分组”和“having”结合起来，基本上也是选择条件的结合。对吧？就像在
    years 中，你实际上是子选择了输出中的每个平均评分。
- en: So that's where the select clause comes from。 The having clauses basically this。
    Okay。 So here's a summary for what we've covered today。 So relation algebra basically
    says。 here's a small set of operations that you can mix and match in various ways
    that map relations to relations so inputs are relations。 outputs are relations。
    And these are operational in the sense that you specify the explicit order in
    which the operations are performed。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是为什么需要使用选择（select）子句。having 子句基本上就是这个。好了，下面是我们今天所涵盖内容的总结。关系代数基本上是说，这里有一小组操作，你可以通过多种方式组合它们，这些操作将关系映射到关系，所以输入是关系，输出也是关系。这些操作是“操作性的”的，因为你需要明确指定操作执行的顺序。
- en: The close set of operators， which means that whatever you compute as a result
    is still a relation。 It's very easy to manipulate rewrite and simplified expressions
    in relation algebra and expressions in relation algebra are pretty powerful。 right。
    These small number of operations can encapsulate a lot of SQL functionality。 So
    like we saw the not in clause， you can actually get rid of that by simply doing
    a rewrite。 Okay。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符是闭合的，这意味着你计算出的结果仍然是一个关系。关系代数中的表达式非常容易操作、重写和简化，而关系代数中的表达式也非常强大，对吧？这些少数几种操作就可以封装很多SQL的功能。所以，就像我们看到的not
    in子句，你实际上可以通过简单的重写来去掉它。好。
- en: And we covered six basic operations of five basic， we covered six。 Okay。 there
    should be a row covered six basic operations as well as some compound operations。
    like the intersection and the bow tie。 And then we have to join any questions
    on this stuff。 Okay。 I'll run you want to go。 Can I go back a page。 Yes。 What's
    that the question。 I， the answer is yes。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了六个基本操作，五个基本操作，我们已经覆盖了六个。好的。应该有一行覆盖了六个基本操作，以及一些复合操作，比如交集和蝴蝶结。然后我们要做连接，关于这些有问题吗？好的，我会……你想去吗？我可以回去一页吗？好的。问题是什么？我，答案是肯定的。
- en: Are we asking a question after you go back to the page I think。 I already went
    back。 Do I need to go back even more。 Okay， I guess that was the question。 All
    right。 Cool。 All right。 I think I did。 Yeah， I think like the sum of the slides
    were not on the public website yet。 I printed the current version in the in the
    in the drive to put it there but then if you make any changes。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是在问问题吗？我回去了一页，应该是。我已经回去了。还需要再回去吗？好的，我猜那就是问题了。好吧。酷。好的。我想我做对了。是的，我觉得某些幻灯片还没有上传到公开网站。我已经打印了当前版本，并上传到云端，但如果你做了任何更改……
- en: feel free to just update that。 Okay。 I thought I added the most recent version
    but I'm。 I'm not the last few slides were not there for some， for some reason。
    I don't know why。 Okay。 what did it just truncated some point and then there was
    nothing after that。 Okay。 I think it stopped right before the nesting slice。 Okay。
    So I just。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随时更新它。好的。我以为我已经添加了最新版本，但是……不知为什么，最后几张幻灯片没有显示。我不知道为什么。好的，是什么时候突然中断了，然后后面什么都没有。好的，我认为它在嵌套切片之前停止了。好的。所以我就……
- en: so that's why I thought you might have another version， another version that
    you put out。 Okay。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是为什么我认为你可能有另一个版本，另一个你发布的版本。好的。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_6.png)'
- en: Okay。 Okay。 Okay。 Okay。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好的。好的。好的。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_8.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_8.png)'
- en: Wait。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_10.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_10.png)'
- en: Okay。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_12.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_12.png)'
- en: Okay， great。 Are they any other questions about relational algebra？ Okay， we
    have 15 minutes。 So。 um， well， I mean， if not， I have a kind of trivia question，
    right？
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太好了。关于关系代数还有其他问题吗？好的，我们还有15分钟。所以，嗯，如果没有，我有一个小问答题，对吧？
- en: So I think last time some people heard about that already。 As you remember。
    we have a kind of mnemonic system， right， for remembering all these different
    relational algebra operators。 So， for instance， this was selection， right。 So
    do people remember why like we chose sigma。 we didn't choose it， right？ So there
    was like in the original paper。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我觉得上次有些人已经听说过这个了。正如你们记得的，我们有一个助记系统，对吧，用来记住这些不同的关系代数运算符。所以，比如说，这是选择运算符，对吧。那么，大家还记得我们为什么选择了希腊字母sigma吗？我们并不是随便选的，对吧？在最初的论文中有解释。
- en: So why was sigma chosen to be selection。 Okay。 So， so that's why we chose this
    for a， let me guess。 I'm giving a wrong guess， obviously。 But because we're doing
    algebra and algebra emanated from the Greeks。 you should use Greek symbols。 Spencer，
    right？ Okay。 Let's keep that keep that keep that way。 Okay。 Fine。 Right。 So we'll
    do a second month for selection。 We'll do。 Pi is what projection， right？
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么选择sigma作为选择运算符？好的。所以，这就是我们选择它的原因，让我猜猜看。我显然猜错了。但因为我们做的是代数，而代数起源于希腊人。你应该使用希腊字母。斯宾塞，对吧？好的。就这么定了。好的，没问题。对。所以我们用sigma来表示选择运算符。我们用pi表示投影，对吧？
- en: So I think people are seeing the pattern here。 Okay。 So here， here comes a problem，
    right。 So I don't think we cover that by weight， we also cover this right so gamma
    was group by right。 Grouping basically， right。 So there's one operator that we
    didn't cover in this class right and that is tau and that stands for sorting。
    So for instance， if you do like your order by right， you'll see tau basically
    showing up。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我觉得大家已经看到这个模式了，对吧？好的，那么这里就有一个问题，对吧？所以我认为我们没有按权重来覆盖这个内容，我们也覆盖了这个，对吧？所以gamma是按分组来做的，对吧？基本上就是分组，对吧？所以有一个操作符我们在这堂课中没有涉及，那就是tau，它代表排序。比如，如果你使用`order
    by`，你会看到tau基本上就会出现。
- en: So we have a pattern right。 So we have s we have P we have g right so why don't
    what's going on with tau。 Right。 Second constant is simple yeah right I mean so
    because s is already taken as you saw right so we can't use s。 So what else right
    I mean let's just pick something that comes right after s and then that turns
    out to be t so that's that's why like we end up with tau。 Yeah， so you might also
    think about like what was up with that right。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个模式，对吧？我们有s，我们有P，我们有g，对吧，那么tau怎么回事？第二个常量很简单，是吧？因为s已经被占用了，你看到过了，对吧？所以我们不能使用s。那么还剩下什么呢？我们就选择一个紧跟在s后面的字母，结果发现是t，所以这就是为什么我们最终会用tau。所以，你们也许会想，关于这个还有什么疑问吗？
- en: So we call this join right but then like you know this is not a Greek letter
    as far as I know。 So what's going on that。 Yeah， it should be a J right but then
    anyone in the audience actually know Greek。 Is there J in Greek。 There's no there's
    no there's no the letter J does not that's not existing Greek right so that's
    why they had to come up with something else and then like you know that's what
    they chose I mean I don't know why。 So， yeah。 Okay so that's the end of the trivia
    question。 Okay。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们称这个为连接（join），对吧？但是，至于我所知道的，这不是一个希腊字母。那么怎么回事呢？对，应该是J，但在场有没有人懂希腊语？希腊字母里有J吗？没有，希腊字母里没有J。所以他们不得不想出其他的方式，然后他们选择了这个，我也不知道为什么。所以，是的，好的，今天的趣味问答就到这里。
- en: so I hope you guys enjoy a kind of a laugh。 Okay great so the。 No answer yeah
    because there's no J in Greek supposedly so that's why like you know that was
    the that was a problem。 So， yeah， not it's so。 So the， the， the， the， the one
    explanation that I've heard for the bow tie is that it kind of looks like a bipartite
    graph。 So you have two pulls from one side to pulse on the other side and edges
    across them that kind of looks like that sort of。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我希望你们能享受一下这个笑话。好的，太好了，没错，因为希腊字母中没有J，这就是为什么会出现那个问题。所以，是的，不是的。然后，我听过的关于蝴蝶结的一个解释是，它看起来像一个二分图。所以你有两端从一边到另一边的两个点，之间有边连接，它有点像那样。
- en: But I haven't heard a better explanation beyond that you mean like this。 Yeah。
    exactly but it's like。 Yeah， okay well you guys have better imagination that not
    so you know you guys come up with better answers。 Okay so let's talk about sorting
    and hashing so why are we talking about this right first of all。 So here's the
    kind of big picture， big picture that we've been talking about for this part of
    the class。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但我还没有听到比这更好的解释，你是说像这样吗？对，没错，但它就像是。对，好吧，你们的想象力比我强，所以你们能想到更好的答案。好的，接下来我们来谈谈排序和哈希，那么为什么我们要讨论这个呢？首先，首先是这个大概的框架，这是我们在这部分课程中讨论的大图景。
- en: So we have actually completed a lot of these different components inside the
    DBMS believe it or not。 So now we're actually talking about really we just finished
    talking about relational operators。 And then the next phase we want to go into
    create parsing and optimization。 So before we can talk about parsing and we've
    what we can talk about optimization we first have to talk about how each of these
    relational operators that you saw from the last lecture was actually implemented。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以实际上，我们已经完成了DBMS中很多不同的组件，不管你信不信。现在，我们其实在讨论的就是我们刚刚完成了关系操作符的部分。接下来我们要进入的阶段是创建解析和优化。在我们谈论解析和优化之前，我们首先必须讨论一下你们从上一讲看到的每个关系操作符到底是怎么实现的。
- en: The one reason why relational algebra we talked about in this class is because
    each one of these operators kind of corresponds very nicely to let's say a function
    that you implement as part of project three。 Right， so you can imagine selection
    being a function called that you pass in a relation and predicate and then you
    return another relation。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这门课上讨论关系代数的一个原因是，因为这些操作符几乎都可以很好地映射到我们在第三个项目中实现的函数。你可以想象，选择操作就像一个函数，你传入一个关系和一个谓词，然后返回另一个关系。
- en: So on so forth right。 So but then in order to understand optimize how to do
    create optimization we first have to learn about like how to actually implement
    each of these operators that we have seen on in the previous lecture。 So that's
    why we want to talk about sorting and hashing。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推，对吧？但为了理解如何优化，我们首先必须学习如何实际实现我们在上节课中看到的每一个操作符。这就是为什么我们要讨论排序和哈希的原因。
- en: And I think about like what is sorting and what is like hashing has to do with
    query optimization or like implementation of relational algebra operators。 We
    didn't talk about explicitly a sort operator and there's definitely not a hash
    operator right。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我在想排序和哈希是如何与查询优化，或者说与关系代数运算符的实现有关的。我们并没有明确讨论排序操作符，而且显然也没有哈希操作符，对吧？
- en: So why we're talking about these two things。 Well so turns out that these two
    operations are coming enough that actually they have they show up in a lot of
    different relational algebra operations。 So first one is sorting。 So sometimes
    we some this is used very frequently in something called like random operations。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么要讨论这两个问题呢？事实证明，这两个操作非常常见，它们在许多不同的关系代数操作中都会出现。第一个就是排序。有时候这个操作在一些称为“随机操作”的操作中使用得非常频繁。
- en: So for instance when we try to eliminate duplicates as in distinct right。 We
    are basically bringing into a post from multiple relations together。 and then
    getting rid of those that are duplicates。 Right， so if we can somehow sort them。
    then we can implement this， this duplicate elimination pretty easily。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们尝试去除重复项（比如 distinct）时，实际上是将多个关系合并在一起，然后去除那些重复项。如果我们能以某种方式对它们进行排序，就能很容易实现去重操作。
- en: We just saw them we go through them from the beginning and then every time when
    we see a duplicate that is right next to each other right consecutively。 then
    we just get rid of it。 And then obviously also for grouping as well right so this
    is the gamma operation that we're talking about just now。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就这样排序，从头开始遍历，然后每次看到相邻的重复项时，就将其删除。显然，分组操作也是如此，这就是我们刚才讨论的伽玛操作。
- en: So in order to form groups， we need to be able to first figure out like what
    are the groups right in the in the relation itself。 And then in order to do that，
    why don't we just saw it。 If we can sort it。 then we can recognize where the groups
    are right by just marching down the the rows。 And then also later on something
    that we'll talk about in the after this lecture。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了形成分组，我们首先需要能够确定在关系本身中，什么是分组。然后为了做到这一点，为什么不直接排序呢？如果我们能对它进行排序，那么我们就能通过逐行遍历来识别出分组的位置。接下来我们将在这节课后讨论一些内容。
- en: which is like you know implementing join using a specific algorithm called sort
    merge as the name suggests。 we need to do sorting as part of this algorithm。 So
    that's why we're also talking about sorting here。 Sometimes they also explicitly
    requested so as I said in the relational in extended relational algebra。 there
    is this thing called ordering， which implements order by so that definitely requires
    sorting。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，使用一种叫做排序合并的特定算法来实现连接，正如其名所示，排序合并算法需要在这个过程中进行排序。所以我们也在这里讨论排序。有时在扩展的关系代数中，排序也是显式要求的，就像我之前提到的，关系代数中有一个称为“排序”的操作，它实现了
    `ORDER BY`，这就需要排序。
- en: And you know， this year talk about bulk loading of indexes in the beginning
    and then we also talk about sorting there too。 The problem that we were addressing
    this class right however。 is how to sort huge amounts of data when we have finite
    amount of memory。 So you have already learned about different ways to do sorting
    right。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 今年我们一开始讲了索引的批量加载，后来也讲了排序。我们这节课解决的问题是如何在有限的内存下对大量数据进行排序。所以你们已经学习了不同的排序方法。
- en: I hope that brings some bells from 61， you know things like merge sort things
    like quick sort things like bubble sort so we've already learned about all that
    stuff。 So yes， we're not repeating ourselves for that kind of algorithm but we
    have a distinct problem where we have tons of data on the disk。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这能唤起你们在61课上学到的内容，比如归并排序、快速排序、冒泡排序，我们已经学过了这些内容。所以，是的，我们不会重复讲解这些算法，但我们面临一个不同的问题，就是磁盘上有大量的数据。
- en: but we have very little memory in comparison let's say right so how do we do
    sorting that way。 So if you have taken 162 you might recognize there's this thing
    called virtual memory right so we can just load everything using virtual memory
    into we can load all the records from the disk into virtual memory and then we
    can just apply our favorite sort algorithm in memory。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 而且相比之下，内存非常有限。那么我们该如何进行这种方式的排序呢？如果你们修过162课程，你们可能会认识到有一种叫做虚拟内存的技术，没错，我们可以通过虚拟内存加载所有的记录到内存中，然后在内存中应用我们最喜欢的排序算法。
- en: So why doesn't that work， or would that work。 Yeah Nicholas is saying commence
    this thrashing right。 So remember in virtual memory right so the the abstraction
    is basically that we will basically trade off。 We'll hide away right this loading
    of data from the disk with just the same interface right as if everything is already
    a memory。 but underline the covers， the operating systems actually doing all the
    random I was that we can imagine right in order to bring everything into the disk。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么那样行不通，或者说它行得通吗？是的，尼古拉斯说这是会引起抖动的，对吧？所以记住在虚拟内存中，抽象的基本概念是，我们会进行折衷。我们通过相同的接口隐藏了从磁盘加载数据的过程，仿佛一切都已经在内存中。但实际上，在后台，操作系统正在进行所有随机I/O操作，以便将所有内容加载到内存中。
- en: sorry into the memory。 So therefore this is actually going to be a very costly
    operation if this is how we're going to implement sort。 And I challenge you to
    actually try implementing it like you know using your 162 pintos assignment and
    you'll see what I mean if you try to actually do it that way。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，加载到内存。所以，如果我们采用这种方式实现排序，这实际上会是一种非常昂贵的操作。我挑战你们尝试实现它，就像你们在162的Pintos作业中做的那样，如果你们真的这样做，你们就会明白我的意思。
- en: So in order to address this problem right so we talk about in this class what
    is known as our core algorithms。 So it's called out of core because main memory
    or RAM used to be called outside of the core memory。 So it's like so main memory
    or RAM used to be called core memory or main memory。 which is still used these
    days。 So since we are talking about sorting data that currently resides on the
    disk and not already brought into memory。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了正确地解决这个问题，我们在这节课上讨论了所谓的核心算法。它被称为“核心外”，因为主内存或RAM曾经被称为核心内存。就像以前主内存或RAM曾被称为核心内存或主内存一样，这个名称至今仍在使用。所以，既然我们在讨论的是排序数据，这些数据目前存在于磁盘上，而不是已经加载到内存中。
- en: So therefore they are called out of the core。 So that's why you sometimes hear
    this name is kind of archaic。 Sometimes you will also call this as refer to this
    as external algorithms external in the sense of external to main memory。 So again
    we're referring to the disk。 The themes that we will talk about for this。 for
    these set of algorithms。 The first one is that we will you often see a pattern
    where we'll basically be single pass streaming data from the disk into RAM。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们被称为“核心外”。这就是为什么你有时会听到这个名字，它有点过时。有时你也会称之为外部算法，外部指的是外部于主内存。所以，我们再次提到的是磁盘。我们将讨论的这些算法的主题，第一个是，你会经常看到一种模式，我们基本上是单次传输数据，从磁盘流到RAM。
- en: So read a page of data from the disk， go through it inside of the RAM or inside
    main memory and then write it back to the disk。 So that's some pattern that is
    one pattern that you keep seeing in this class。 And then you also see an application
    of divide and conquer which you guys learned about in 61 after we have brought
    things into memory。 Might be kind of curious about like how it's just divine conquer
    right so we'll see it's actually pretty cool。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从磁盘读取一页数据，在RAM或主内存中处理它，然后再写回磁盘。这是一种模式，在这节课中你会反复看到它。然后你还会看到分治法的应用，你们在61课程中学到的分治法，在我们将数据加载到内存之后。可能你会对它如何运作感到好奇，为什么它就是分治法，我们会看到它实际上非常酷。
- en: So let's first talk about single pass streaming。 So as I said right the goal
    is to basically try to bring in memory sorry bring in data from the disk one page
    at a time into memory。 process it， and then write it back to the disk。 So let's
    say I want to implement map， right。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们先谈谈单次流式处理。正如我所说，目标是基本上尝试从磁盘中一页一页地读取数据到内存中，处理它们，然后再写回磁盘。所以假设我想实现映射操作，对吧？
- en: the function map。 So pre I basically have a function here F that I'm trying
    to apply to each of the records on the disk。 And then the challenge here right
    as I said is we have to minimize the amount of RAM that we use because we don't
    have enough RAM that will hold all the records in main memory。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 函数映射。所以实际上我有一个函数F，我正试图应用到磁盘上的每一条记录上。然后这里的挑战是，正如我所说的，我们必须最小化我们使用的RAM量，因为我们没有足够的RAM来存储所有主内存中的记录。
- en: So the way that we're going to solve this is by reading off chunks of data from
    the disk。 So this is the disk here right so I'm just using this cartoonish representation。
    We're reading off pages of data from the disk into main memory here that you see
    in this。 I'm representing this as this rectangle here。 I read them in like one
    page at a time right into this input buffer。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们解决这个问题的方法是从磁盘上读取数据块。这里是磁盘，我只是用这种卡通式的表现方式。我们从磁盘上读取数据页到主内存中，你看到的是这个矩形。我一次读取一页数据，对吧？到这个输入缓冲区。
- en: Apply this function F effects and then write it back to the disk right so for
    instance。 First time I read from the disk I might read like you know three of
    these rectangles right thing of them as records。 I apply each of them to the function
    F right and then I produce these pentagons。 And then I read another page again
    right and produce more pentagons。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这个函数F效果，然后把结果写回磁盘，对吧？例如。第一次从磁盘读取时，我可能会读取三张矩形，想象它们是记录。我将每一个应用到函数F上，然后生成这些五边形。然后我再读入下一页，继续生成更多的五边形。
- en: So notice that the sizes right of the pentagons and the rectangles are different。
    So the rectangles feel three in the input buffer but then like you know the pentagons
    are somehow smaller I'm able to actually fit them more fit fit more of them on
    the in the output buffer。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请注意，五边形和矩形右边的大小是不同的。因此，矩形在输入缓冲区中占据了三个位置，但五边形看起来比较小，我实际上能够把它们放得更多，更多地放入输出缓冲区中。
- en: Right in this way for instance。 So I just repeat this process until the output
    buffer fails and then I'm just going to write them all back onto the desk。 Right。
    So why am I holding that off right so why not just write each one of those pentagons
    to the disk immediately when I receive a new output。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对，这种方式比如说。比如我一直重复这个过程，直到输出缓冲区满了，然后我将所有数据写回磁盘。对吧？那么，为什么我要拖延这个过程呢？为什么不在收到新的输出时立即把每个五边形写入磁盘呢？
- en: What is the advantage of delaying this right process here。 Yeah。 reduce IO right
    why I mean because as you remember sequential IO is good right random IO is bad
    right so if I write the entire thing one at a time that's going to incur a lot
    of IO right and then they might actually also。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟这个过程的优势是什么？是的。减少IO，对吧？为什么呢？因为如你所记得的那样，顺序IO是好的，对吧？随机IO是坏的，对吧？所以如果我把所有内容一个个写入，那将会产生大量的IO，对吧？而且它们可能还会。
- en: be random but then if I write out the entire page that is sequential IO right
    so if we are using a magnetic spinning disc for example that will be great。 So
    this is a kind of pattern that you would set will keep seeing right so we basically
    fill out the output page and then like you know again right and then we just repeat
    the entire process until we're done with all the other pages up from the disk。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是随机的，但如果我把整页写出来，那就是顺序IO了，对吧？所以如果我们使用的是磁性旋转盘，例如，这将是很好的。所以这是一种你会不断看到的模式，对吧？所以我们基本上填满输出页面，然后再像你知道的那样，再写一次，然后我们就重复整个过程，直到从磁盘上处理完所有其他页面。
- en: So if we're smart about it right we can actually try to run what is known as
    double buffering。 So instead of having just one input buffer we can actually have
    to。 Why。 because we can actually afford to start a second threat right whose responsibility
    is only to either read from the disk or write a full page onto the disk afterwards。
    And we can paralyze that right with the map threat that is currently executing
    running this F function over every single record。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们聪明一点，我们其实可以尝试运行被称为双缓冲的技术。这样我们就不仅仅有一个输入缓冲区，我们可以有两个。为什么呢？因为我们可以启动一个第二个线程，它的责任仅仅是从磁盘读取或者将一个完整的页面写回磁盘。而且我们可以将它与当前执行映射函数的线程并行执行。
- en: So this parallelism is available because like you know it takes time to read
    from the disk and also takes time to write to the disk。 And if we have multiple
    threats that are supported by the operating system for instance that we can just
    spin up spin up like you know two threats right and then we have one threat running
    the map function。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种并行性是可行的，因为你知道，从磁盘读取需要时间，写入磁盘也需要时间。如果操作系统支持多个线程，那么我们就可以启动两个线程，同时有一个线程在运行映射函数。
- en: And we have one threat that is dedicated to do is I oh。 So that's like a very
    common pattern that you see in this class。 And what happens when you when either
    one of these buffer is full right so maybe like you know the empty the reap the
    reap buffer is full or maybe when the right buffer is full。 then we just switch。
    We switched the two threats so those are so the threat that was。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门的线程来处理 I/O。这个模式在这个类中是非常常见的。当任一缓冲区已满时会发生什么呢？比如空缓冲区已满，或者写缓冲区已满，那么我们就交换这两个缓冲区，切换两个线程。
- en: that was using that was computing the map function now do the IO right because
    like you know we have a full page that we can either right back to the disk or
    we now have an empty page that we can read from the disk。 And then we just switch
    the other threat to be doing the actual computation。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计算映射函数时，这个线程就会处理 I/O。因为你知道，我们有一个完整的页面，可以将它写回磁盘，或者我们有一个空页面，可以从磁盘读取。然后我们只需切换另一个线程来执行实际的计算任务。
- en: So this is going to be very useful and subsequent discussion。 and we're just
    going to assume that like you know you have extra rampages that you can spare
    to do this double buffering。 So in fact this is such a common pattern that like
    you're just not going to bring this up again we're just going to assume that that
    is just going to happen in the background。 Does this make sense。 Any questions
    so far。 Okay， so we just went gone through this pattern of like you're doing streaming
    right across the across the disk using a dedicated IO threat and then doing double
    buffering。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这将非常有用，接下来的讨论也会围绕这个展开。我们假设你有额外的资源可以用来进行双缓冲。所以实际上这是一个如此常见的模式，以至于我们以后不再提及它，假设它会在后台自动发生。这有意义吗？到目前为止有什么问题吗？好的，我们刚刚已经讨论了这个模式：你通过一个专门的
    I/O 线程进行流式处理。
- en: So， now let's go back and revisit this problem of sorting and hashing right
    so what are we trying to do here。 So let's be formal form about this so here here
    is the foremost spec with regard to sorting。 So our goal is to prove is to output
    a single file F of S。 That stores the contents of the relation are that we're
    interested。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在让我们回过头来重新审视这个排序和哈希的问题，我们到底在这里试图做什么呢？我们来正式地定义一下，这里是关于排序的最初规格。我们的目标是生成并输出一个单一的文件
    F_of_S，存储我们关心的关系 R 的内容。
- en: And then all the records has to be ordered in whatever sorting criterion that
    we are given。 And actually what we are trying to do。 What about hashing。 So hashing
    again we are trying to produce an output file right F of H here。 And it's also
    storing the same contents of our as in the input so we're not dropping anything
    here。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有记录必须按照我们给定的排序标准进行排序。实际上我们要做的是，什么是哈希？哈希，实际上是我们试图生成一个输出文件，F_of_H。在此文件中，它保存了与输入中相同的内容，所以我们并没有丢弃任何数据。
- en: except that we have the requirement that no two records that have the same hash
    value can be separated by another record。 And if two records have the same hash
    value they should reside consecutively on the disk in this output file that we
    will produce F sub H。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们有一个要求：任何两个具有相同哈希值的记录不能被另一个记录分隔。如果两条记录的哈希值相同，它们应该在磁盘上的输出文件中连续存放，这个文件我们将称之为
    F_sub_H。
- en: Again think back about what why we're trying to do hashing right because we're
    trying to let's say use hashing to implement duplicate elimination。 So in order
    to do that we want to be able to somehow place all the same records the duplicates
    in particular next to each other in the file。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回想一下我们为什么要做哈希处理。因为我们想用哈希来实现去重。所以为了做到这一点，我们需要将所有相同的记录，特别是重复的记录，尽可能放置在文件中的相邻位置。
- en: If we can do that then we can just implement duplicate elimination using sequential
    IO which is great。 So that is the goal here we are trying to produce this file
    where same records that hash the same value has to reside consecutively on the
    disk。 What are we given on the other hand， we are given an input file F that contains
    a multi set of records are。 And then we are assuming that this file F picks up
    and blocks or end pages of storage on the disk。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够做到这一点，那么我们就可以使用顺序IO来实现去重，这是非常有效的。所以我们的目标是，生成一个文件，其中所有哈希值相同的记录必须连续存储在磁盘上。另一方面，我们得到的是一个输入文件F，它包含了多个记录的多重集。我们假设这个文件F以块或磁盘上的页面形式存储。
- en: We assume that we have a lot， lot more pages that are blocks on the free storage
    that we can use on the disk compared to the amount of main memory that we have。
    And in fact like you know we're just going to reduce the notation that we have
    been using before we're just going to say that we have the blocks of RAM that
    are available that we can bring data in from the disk。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们有大量的页面和磁盘上可以使用的空闲存储块，比我们所拥有的主内存还要多。事实上，如你所知，我们将简化之前的表示法，只说我们有足够的RAM块可以从磁盘中读取数据。
- en: Does that make sense。 So in the last one minute let me just go through a very
    simple way to implement sorting。 So here's one simple way to implement sorting
    when we have limited number of RAM but we have a lot of data we will try to sort。
    So I'm going to do this in two steps。 The first step is we are going to read a
    page from the from the main memory。 and then we're going to sort it and then we're
    going to write it backwards。 How is it work。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样说清楚了吗？那么在过去的一分钟里，让我简单介绍一下如何实现排序。这里有一种简单的方法，当我们只有有限的RAM但数据量很大时，我们尝试进行排序。我会分两步来做。第一步是我们从主内存中读取一个页面，然后进行排序，最后将其写回。这是如何工作的呢？
- en: We read off each page from the disk one at a time。 And then we're going to start
    it in place inside main memory。 you can use your favorite sorting algorithm at
    that point right since everything is already a main memory。 So let's say quick
    start。 And then we are just going to write it back directly back to the disk。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一次从磁盘读取每个页面。然后我们会将它们放入主内存中进行排序。此时，你可以使用你喜欢的排序算法，因为一切数据已经在主内存中了。所以我们假设使用快速排序。然后我们会将数据直接写回磁盘。
- en: So far so good but so far we have only started each of these individual pages
    separately right but our goal is to produce one single gigantic file where everything
    is sorted。 So right now this doesn't work right because at the end of the day
    here we have only sorted the individual page right in the individual pages not
    the entire file。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都还不错，但到目前为止我们仅仅是分别对每个单独的页面进行了排序，对吧？但我们的目标是生成一个包含所有内容的单一巨大文件，其中一切都已经排好序。因此，现在这种方法并不起作用，因为最终我们只是对单独的页面进行了排序，并没有对整个文件进行排序。
- en: So how do we do that afterwards right。 Well think about think back when you
    learn about merge sorts。 Right this is what we can do also in this case right。
    So we basically read back these sorted individual pages into the into into main
    memory。 So in this case now we require three buffer pages because we're going
    to read two pages at a time from the desk。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么接下来我们该怎么做呢？想一想你学过的归并排序。对吧？这就是我们在这种情况下可以做的事情。我们基本上是将这些已经排序的页面重新读入主内存中。此时，我们需要三个缓冲区页面，因为我们要一次从磁盘读取两个页面。
- en: Now these guys are sorted right。 So these pages have been sorted and then we
    are going to merge them into the output buffer。 One page at a time。 Right， so
    this is the same thing as merge sort algorithm right we just start reading off
    from the two pages。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些页面已经排序了。然后我们将它们合并到输出缓冲区中，每次合并一页。对吧？这和归并排序算法是一样的，我们只是从两个页面开始读取数据。
- en: And then we basically figure out which one should go first right depending on
    the sort order and then we're going to put that into the output buffer。 And then
    when the output buffer is full， we're just going to write that back to the to
    the desk。 Right， so that's what we're doing here。 So this is a streaming algorithm
    as you as you see right so just like on the previous slide so we're basically
    streaming every two pull from the input disk。 and then processing it processing
    and somehow and then send it over to the output。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们基本上根据排序顺序决定哪个应该先排，接着将其放入输出缓冲区。然后，当输出缓冲区满时，我们会将其写回磁盘。对，就是这样。所以这就是我们在做的事情。这是一个流式算法，正如你在前一张幻灯片上看到的，我们基本上是每次从输入磁盘中流式拉取两个数据块，然后以某种方式处理它们，再将其发送到输出。
- en: except that in this case we are doing this in two passes right。 So we're first
    sorting out the individual pages first。 and then we're basically applying merge
    sort afterwards by reading back everything into into main memory and then writing
    them out onto the disk。 And then at the end of the day we'll have one gigantic
    file that is completely sorted at the end。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种情况，我们是通过两次处理来完成的。首先，我们先对各个页面进行排序，然后我们基本上通过将所有内容读回主内存并写回磁盘来应用归并排序。最终，我们将得到一个完全排序的巨大文件。
- en: But not yet right because at this point we only we have only merged two of the
    two of the pages we have to add we actually have to merge more right we have to
    basically merge all the pages until we get one single file。 So that's where we
    will pick up next time。 Have you have any questions please stay otherwise we'll
    see you on Thursday。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在还没结束，因为到这个时候我们只合并了两个页面，我们还需要合并更多的页面。我们必须继续合并所有页面，直到得到一个单一的文件。所以接下来我们会继续讨论这个问题。如果有任何问题，请留下，否则我们星期四见。
- en: We use the clear-favities drop-in symbol here。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了清晰的“favities”插入符号。
- en: '![](img/025522cdd402d8e827702d5842b49a5a_14.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025522cdd402d8e827702d5842b49a5a_14.png)'
