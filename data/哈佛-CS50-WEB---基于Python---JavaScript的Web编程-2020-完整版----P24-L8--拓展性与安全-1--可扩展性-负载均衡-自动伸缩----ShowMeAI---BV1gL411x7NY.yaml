- en: 哈佛 CS50-WEB ｜ 基于Python ／ JavaScript的Web编程(2020·完整版) - P24：L8- 拓展性与安全 1 (可扩展性，负载均衡，自动伸缩)
    - ShowMeAI - BV1gL411x7NY
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛 CS50-WEB ｜ 基于Python ／ JavaScript的Web编程(2020·完整版) - P24：L8- 拓展性与安全 1 (可扩展性，负载均衡，自动伸缩)
    - ShowMeAI - BV1gL411x7NY
- en: '![](img/9e1a5fe55e2bc95a425be60a3f404bd4_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e1a5fe55e2bc95a425be60a3f404bd4_0.png)'
- en: '[Music]，all right welcome back everyone to web，programming with Python and
    JavaScript。and for our final topic we''re going to，explore scalability and security
    so so。far in the class we''ve been building web，applications and we''ve been building
    web。applications that work on our own，computer but if we want to take those。'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[音乐]，欢迎大家回来，继续学习Python和JavaScript的Web编程。对于我们的最后一个主题，我们将探索可扩展性和安全性。到目前为止，在课堂上我们一直在构建Web应用程序，这些应用程序在我们自己的计算机上运行，但如果我们想把这些。'
- en: web applications and deploy them to the，world so people all across the internet。can
    begin to use them then we're going，to need to host our web application on。some
    sort of web server some dedicated，piece of hardware that is listening for。web
    requests and responding to them with，the response that we would like for our。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序部署到全世界，让互联网上的人们都可以使用它们，那么我们需要在某种Web服务器上托管我们的Web应用程序，这是一种专用的硬件，能够监听Web请求并用我们想要的响应来回应它们。
- en: web application to deliver and when we，do so this introduces a whole bunch of。interesting
    issues surrounding，scalability and security so we'll take a。look at these issues
    today beginning，with problems concerning scalability。what those problems are and
    how we might，go about addressing them so when we。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序需要提供服务，当我们这样做时，这会引入一系列有趣的可扩展性和安全性问题，因此今天我们将讨论这些问题，首先从可扩展性相关的问题开始。这些问题是什么，我们该如何解决它们。
- en: deploy our web applications we deploy，them by putting them onto a web server。that
    I'm here just representing with，this rectangle but all the server is is。some dedicated
    computer some piece of，hardware that is listening for incoming。requests so we'll
    draw this line to，represent an incoming web request from a。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将Web应用程序部署到Web服务器上来部署它们。我这里用这个矩形代表这个服务器，但服务器只是一些专用计算机，是一块监听传入请求的硬件，因此我们将画一条线来表示来自一个。
- en: user the server takes that request and，responds to it but ultimately our web。application
    isn't just going to be，servicing one user if it becomes popular。it might have
    many users that are all。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_2.png)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收该请求并做出响应，但最终我们的Web应用程序不仅仅会服务于一个用户，如果它变得受欢迎，可能会有许多用户同时使用它们。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_2.png)
- en: trying to connect to that server at the，same time and as multiple people start。to
    connect to that server at the same，time here's where we start to deal with。issues
    of scalability a single computer，a single server can only service so many。users
    at any given time and so therefore，we need to think in advance about how。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试同时连接到该服务器的用户。随着多个用户开始同时连接到该服务器，我们就开始处理可扩展性的问题，一台计算机，一台服务器在任何给定时间只能为有限的用户提供服务，因此我们需要提前考虑如何。
- en: we're going to deal with those issues of，scale but the first question before
    we。even get there is where these servers，actually exist and nowadays there are。two
    main options for where these servers。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_4.png)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决这些规模问题，但在此之前，首先的问题是这些服务器实际上存在于何处。如今，这些服务器主要有两种选择。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_4.png)
- en: can exist these services can be on the，cloud or they can be on-premise and。on-premise
    servers you might imagine as，if a company is running their own web。application
    on-premise servers or，servers that are inside of the company's。walls the company
    owns the physical，servers maybe on some server racks。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务可以存在于云中，也可以是本地服务器。本地服务器可以想象成公司在其内部墙内运行自己的Web应用程序，或公司拥有的物理服务器，可能在一些服务器机架上。
- en: inside of a room and therefore they have，very direct control over all of the。servers
    exactly what kind of servers，they are exactly what software is。running on them
    they can go and，physically look at the servers and debug。them if need be in order
    to make sure，that any issues are dealt with but。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务器位于一个房间内，因此它们对所有服务器都有非常直接的控制，确切知道这些服务器是什么类型，正在运行什么软件。他们可以物理上查看服务器并进行调试，如果有需要，以确保解决任何问题。
- en: increasingly we're starting to move into，a world where cloud computing is。becoming
    increasingly popular，we're in cloud computing rather than，have dedicated servers
    that are。on-premise we have servers that are，somewhere in the cloud where cloud。computing
    companies like Amazon or，Google or Microsoft are able to run。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正逐渐进入一个云计算日益普及的世界，我们在云计算中，而不是拥有专用的本地服务器，我们拥有一些在云端的服务器，那里的云计算公司，如亚马逊、谷歌或微软，能够运行。
- en: their own servers and we simply use，those servers that are provided by those。third-party
    smooth let's Amazon or，Google or Microsoft or someone else and。there are trade-offs
    here with cloud，computing we no longer have an as direct。control over the machines
    themselves，because they're not on premise we can't。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用那些由第三方提供的服务器，比如亚马逊、谷歌或微软等，这里在云计算中存在一些权衡，我们对机器本身的控制不再那么直接，因为它们不在本地，我们无法。
- en: physically manipulate those computers，but we have the advantage of not having。to
    worry about dealing with physical，objects that are inside of the premise。of the
    company whose servers we'd like，to run code for the when it's on the。cloud everything
    is managed externally，by some other company and we can simply。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在物理上操作那些计算机，但我们有一个优势，那就是不需要担心处理公司内部的物理对象，这些公司是我们想要在云端运行代码的服务器。当它在云端时，一切都由其他公司外部管理，我们可以简单地。
- en: use the servers that we need to and，we'll see that this lends itself to。other
    benefits as well as we might need，more servers as we start to get more。sophisticated
    web applications that need，more users these cloud computing。companies can allow
    us to create web，applications that are able to scale。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用那些服务器，随着我们开始获得更多复杂的网络应用程序，这些应用程序需要更多的用户，这些云计算公司可以让我们创建能够扩展的网络应用程序。
- en: across multiple different servers as we，start to get more and more users but。we'll
    discuss those issues of scale as。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_6.png)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用户的增多，我们将跨越多个不同的服务器，但我们将在适当的时候讨论这些规模问题。 ![](img/9e1a5fe55e2bc95a425be60a3f404bd4_6.png)
- en: we get to them the question we need to，ask after we have these servers whether。they're
    servers that are on-premise or，servers that are operating somewhere in。the cloud
    is how many can those use，users，can the server actually service at any。given time
    and that's going to vary it's，going to vary based on the size of the。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要问的问题是，在我们拥有这些服务器后，无论它们是本地服务器还是在云端运行的服务器，用户可以使用多少，服务器在任何给定时间实际上可以服务多少用户，这将因资源的大小而异。
- en: server the computing power of the server，and it's going to be dependent upon
    how。different how long it takes to process，any particular users request if user。requests
    are quite expensive it might，mean that there are fewer users that can。be serviced
    at any given time and it's，for that reason that a helpful tool is。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的计算能力将取决于处理特定用户请求所需的时间，如果用户请求非常复杂，可能意味着在任何给定时间可以服务的用户会更少，因此有一个有用的工具是。
- en: to do some kind of benchmarking some，process of trying to do some analysis on。how
    many users a server can actually be，handling at any particular time and。there
    are numerous different tools that，allow us to do this kind of benchmarking。appache
    by bench or otherwise known as，a/b is a popular tool for doing this。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行某种基准测试，分析服务器在特定时间可以处理多少用户，有许多不同的工具可以让我们进行这种基准测试，Apache Bench（也称为A/B）是一个流行的工具。
- en: kind of thing but benchmarking is going，to be useful so that we know how many。users
    one particular server can handle，maybe it can handle 50 users maybe a can。handle
    100 users maybe it can handle，more at any given time but ultimately。it's going
    to be some finite limit every，computer just has some finite amount of。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这种基准测试是非常有用的，这样我们就知道一个特定的服务器可以处理多少用户，可能它可以处理50个用户，也可能处理100个用户，甚至更多，但最终会有一个有限的上限，每台计算机都有其有限的。
- en: resources and servers are no exception，there's going to be some number of users，after。which
    the server's not going to be able，to handle it so what do we do in that。situation
    what do we do if our server，can only handle 100 users at any given。time but 101
    users are trying to use our，web application at the same time。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 资源和服务器也不例外，会有一些用户的数量，超过这个数量，服务器就无法处理。那么在这种情况下我们该怎么办呢？如果我们的服务器在任何给定时间只能处理100个用户，但有101个用户同时尝试使用我们的网络应用程序。
- en: something needs to change we need to，deal with some sort of scaling to make。sure
    that our web application can scale，and there are a couple of different。types of
    scaling that we can try one，approach is to do what's called vertical。scaling which
    might be the simplest way，you could imagine scaling if this server。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行一些改变，我们需要处理某种扩展，以确保我们的网络应用程序可以扩展。我们可以尝试几种不同类型的扩展。一种方法是垂直扩展，这可能是想象中最简单的扩展方式，如果这台服务器。
- en: is not good enough for handling the，number of users that we needed to handle。we'll
    then just get a bigger serve in，vertical scaling we just take the server。and get
    a bigger server a more powerful，server a server that can handle more。users than
    any given time it's going to，cost more but if we need it to handle。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于处理我们需要处理的用户数量来说还不够好。我们可以选择垂直扩展，直接使用更大更强大的服务器，这样就能处理更多用户。尽管这会增加成本，但如果我们需要处理更多用户，就得这样做。
- en: more users we can just get a bigger，problem，this approach is fairly simple it
    just。involves swapping out one server for，another one that can handle more users。concurrently
    but it also has drawbacks，right there's some limit to how big the。server can be
    to how many users any，physical one server is going to be able。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更多用户会带来更大的问题，这种方法相对简单，只需将一台服务器替换为另一台可以同时处理更多用户的服务器。但这也有缺点，毕竟物理服务器的大小是有限制的，能够服务的用户数量也会受到限制。
- en: to handle because there's a physical，limitation and on what is the biggest。fastest
    most powerful server we could，possibly get so when vertical scaling。ends up not
    being enough an alternative，as you might imagine is what's known as。horizontal
    scaling and the idea behind，horizontal scaling is that when one。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的能力受到物理限制，无法获得更大、更快或更强大的服务器，因此当垂直扩展不足时，另一种替代方案就是水平扩展。水平扩展的理念在于，当一台服务器无法满足需求时。
- en: server isn't enough to be able to，service all of the users that might be。trying
    to use a web application at the，same time well then we can take the。approach of
    saying well rather than just，using one server let's go ahead and。split it up into
    two different servers，we now have two servers that are both。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单台服务器无法服务所有可能同时使用网络应用程序的用户，因此我们可以采取另一种方法，而不是仅仅使用一台服务器。我们可以将其拆分为两台不同的服务器，现在我们有两台服务器。
- en: running the web application and now，effectively we've been able to double。the
    number of users that this web，application can handle rather than just。a single
    server that can serve us 100，users if we have two of them now we can。service 200
    users at any given time if，you imagine 100 of them using server a。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个网络应用程序时，我们有效地将这个应用程序能处理的用户数量翻倍。原本单台服务器只能服务100个用户，现在如果我们有两台服务器，就能同时服务200个用户。如果你想象一下，100个用户在使用A服务器。
- en: over here and 100 of them using server B，over there but this then lends itself
    to。some other questions that we have to，answer which is how do these servers get。their
    users in the first place like when，a user requests a webpage how does that。user
    get directed either to server a or，to server B it seems that they need some，decide。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有100个用户在使用B服务器，但这也引发了一些我们必须回答的其他问题，那就是这些服务器是如何获得用户的。例如，当用户请求一个网页时，用户是如何被引导到A服务器还是B服务器的，似乎他们需要某种决定。
- en: whether to go one direction or another，and it's for that reason that we might。introduce
    another piece of hardware into，this picture and that additional piece。of hardware
    is what we might call a load，balancer and a load balancer is just。another piece
    of hardware that is going，to sit in front of these servers so to。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是选择一个方向还是另一个方向，这就是我们可能引入另一块硬件的原因，而这块额外的硬件就是我们所称的负载均衡器。负载均衡器只是另一块硬件，它将位于这些服务器的前面。
- en: speak in other words when a user makes a，request to a web page rather than。immediately
    getting that request to one，of these web servers the request is。first going to
    go through this load，balancer where the request first comes。into the load balancer
    and the load，balancer then decides whether to send。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当用户请求一个网页时，而不是立即将请求发送给这些网页服务器中的一台，请求会首先通过负载均衡器。在负载均衡器中，请求首先进入，然后负载均衡器决定是否发送。
- en: that request to server a or to send that，request to server B and this process
    is。likely less expensive than actually，dealing with and processing that request。so
    the load balancer is effectively just，acting as a dispatcher it waits for。those
    requests to come in and when the，requests do come in the load balancer。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将该请求发送到服务器A或发送到服务器B，这个过程可能比实际处理该请求的成本要低。因此，负载均衡器实际上只是充当调度员，它等待请求的到来，当请求到来时，负载均衡器。
- en: directs those requests either to go to，one server or to another and you might。imagine
    the story where we have more，than just two servers maybe we have many。servers
    and the load balancer is just，going to balance between all of those。different
    servers and this process of，deciding which server to send a request。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些请求导向某台服务器或另一台服务器，你可能会想象一个场景，我们有的不止两台服务器，也许有很多台，负载均衡器将平衡所有这些不同的服务器，而决定将请求发送到哪台服务器的过程。
- en: to is known as load balancing which is，what the load balancer is ultimately。doing
    and there are various different，methods that you might use in order to。perform
    this load balancing so you might，imagine thinking about this intuitively。how would
    the load balancer decide given，some request should we send the request。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为负载均衡，而负载均衡器最终就是在执行这个操作。你可能会使用各种不同的方法来执行负载均衡，因此可以直观地想象，负载均衡器如何决定在某个请求到来时，是否应该将请求发送给。
- en: to this router to the server or should，we send the request to some other server。instead
    and there are many different，approaches that our load balancer might。take and
    here are just a couple random，choice might be the simplest of options。given a
    user that shows up and tries to，make a request to our web server the。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到这台路由器或服务器，还是应该将请求发送到其他服务器？我们的负载均衡器可能采取许多不同的方式，这里只是几个随机选择可能是最简单的选项。假设有一个用户出现并试图向我们的web服务器发起请求。
- en: load balancer first takes a look at the，user and just randomly assigns them
    to。one of the various different servers，that might be processing that request
    if。they're 10 different servers it randomly，chooses among those 10 servers to
    decide。which of them is going to be servicing，that request this has the advantage
    of。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器首先查看用户，并随机将他们分配到处理该请求的不同服务器之一。如果有10台不同的服务器，它会在这10台服务器中随机选择一台，决定哪一台将处理该请求，这有一个优点。
- en: being very simple it's just a quick，calculation the computers can pretty。readily
    generate random numbers and，based on that random number the computer。can dispatch
    the user to one server or，to another server but it might not be。the best option
    because if we happen to，get unlucky we might end up with many。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常简单，计算机可以快速生成随机数，基于这个随机数，计算机可以将用户分派到一台或另一台服务器，但这可能不是最佳选择，因为如果我们运气不好，可能会导致许多。
- en: more users on one server than another or，in such，might end up with servers that
    are。entirely unused if it just so happens，that we don't end up randomly selecting。that
    server now in practice with many，users that are all using this load。balance that
    are all being dispatched，odds are high that eventually all of。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台服务器上的用户比另一台多，或者可能会导致某些服务器完全未被使用，如果刚好我们没有随机选择到那台服务器。在实际情况中，许多用户都在使用这种负载均衡，概率很高，最终所有的。
- en: them will be used but it might not be a，totally even distribution and so for。that
    reason another approach you might，take is a round-robin approach where the。approach
    is instead for the very first，user go ahead and assign that user to。server number
    one for the next user to，assign them the server number two and。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务器将被使用，但分配可能不是完全均匀的，因此，另一个你可以采取的方法是轮询方法，在这种方法中，第一位用户会被分配到服务器一，接下来的用户则被分配到服务器二。
- en: maybe if there are five servers you say，the third user goes to server three
    user。four goes to server for user five goes，to server five and then user six goes。back
    to server number one you basically，rotate going one through five and then。once
    you've assigned some one to each of，the servers you go back to the beginning。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，如果有五台服务器，你可以说第三个用户去服务器三，第四个用户去服务器四，第五个用户去服务器五，然后第六个用户又回到服务器一，基本上是循环选择1到5的服务器，一旦你为每台服务器分配了一个用户，就会回到起点。
- en: and this is also a relatively easy thing，to implement because you can simply
    just。keep count some were in the load，balancer saying what was the most recent。server
    that I assigned a user to and the，next time a request comes in go ahead。and assign
    it to the next server and the，next server after that effectively is。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个相对容易实现的事情，因为你可以在负载均衡器中简单地进行计数，记录我最近分配给用户的服务器是什么，下次请求到来时就将其分配给下一个服务器，然后是下一个服务器。
- en: doing a round-robin style approach where，you go through all the servers once。before
    going through those servers again，now this might seem better than random。choice
    in the sense that it's going to，more equitably decide whether to assign。any particular
    request to any particular，server but it also suffers from certain。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 采用循环方式的方法，在这种方法中，你会遍历所有服务器一次，然后再遍历这些服务器。现在，这可能看起来比随机选择更好，因为它更公平地决定是否将任何特定请求分配给任何特定服务器，但它也存在某些缺陷。
- en: problems that round-robin might be great，but if some requests take longer than。other
    requests we might also get unlucky，and the requests that are taking longer。might
    end up all going to one of the，servers as opposed to another server so。there are
    other approaches that we might，want to go to as well for example。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，轮询可能很好，但如果某些请求比其他请求耗时更长，我们可能也会遇到不幸的情况，耗时更长的请求可能会全部转到某一台服务器，而不是其他服务器，因此我们可能还想尝试其他方法，例如。
- en: something like fewest connections where，the approach there is to say go ahead。and
    when a user makes a request the load，balancer should pick which of the。servers
    currently has the fewest，connections the fewest active。connections from other
    users and other，requests that are currently connected to。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说连接数最少的情况，这种方法是，当用户发出请求时，负载均衡器应该选择当前连接数最少的服务器，即其他用户和请求中与之连接的活动连接数最少的服务器。
- en: those servers instead and by choosing，the server that happens to have the。fewest
    connections you're probably going，to do a better job of trying to balance。out
    between all of the various different，requests that might be happening inside。of
    your web application and while this，might do a better job there are。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择连接数最少的服务器，你可能更好地平衡各种可能在你的网络应用中发生的请求。虽然这可能在某种程度上表现得更好，但仍然存在一些问题。
- en: trade-offs here as well but it might be，more expensive for example to compute。which
    of the servers happens to have the，fewest number of connections whereas。it's much
    easier just to say choose a，server at random，or to do the round-robin style approach。of
    just one two three four five one two，three four five again and again and。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也有权衡，但计算哪个服务器连接数最少可能会更昂贵，而仅仅说随机选择一台服务器或采用轮询方法，即一二三四五，一二三四五，重复进行，这要简单得多。
- en: again but all of these approaches，naively have yet another problem which。has
    to do with sessions and you'll，recall that sessions we used whenever we。wanted
    to store information about the，users current interaction with the web。application
    when you log into a website，like you log into your email or you log。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些方法天真地还有另一个问题，与会话有关。你会记得，我们在想要存储有关用户当前与网络应用互动的信息时使用会话。当你登录一个网站，比如登录你的电子邮件或。
- en: into Amazon for example and then you，come back to that website or visit。another
    page on that website making，another request for example it's not the。case that
    you have to sign in yet again，that the web browser is totally。forgotten who you
    are when I go back to，my mail account or when I go back to。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如进入亚马逊，然后返回到那个网站或访问该网站上的另一个页面，发出另一个请求。例如，情况并非你必须再次登录，而是当我回到我的邮件账户或再次访问亚马逊时，网页浏览器并没有完全忘记你是谁。
- en: Amazon for a second time my mail account，or Amazon remembers me from the last。time
    that I visited I have some sort of，session where it's keeping track of who。is
    logged in maybe information about，what I've been doing on the page and。allows
    me to continue interacting with，the web application even if I'm making。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次访问亚马逊时，我的邮件账户或亚马逊记住了我上次访问的记录，我有某种会话在跟踪谁登录了，也许还有我在页面上所做的事情的信息，并允许我继续与网络应用互动，即使我正在进行。
- en: multiple requests and this you might，imagine could be a problem for this type。of
    load balancing but if I have multiple，different servers imagine if I try to。log
    in to a website and the first time I，make a request，I'm directed to server number
    one and。I'm now logged in on server number one，but then I make another request。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多次请求，你可以想象这对这种类型的负载均衡可能会造成问题，但如果我有多台不同的服务器，想象一下如果我尝试登录一个网站，第一次请求时我被指向第一台服务器，我现在在第一台服务器上登录，但随后我又发出另一个请求。
- en: I'm directed back to the load balancer，and maybe the load balancer this time。decides
    to send me to server number two，but if the session is stored in server。number
    one somewhere server number one，remembers Who I am and what I'm doing。then server
    number two is not going to，Know Who I am，and therefore it's not going to remember。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我被重新指向负载均衡器，也许这次负载均衡器决定把我发送到第二台服务器，但如果会话存储在第一台服务器上，第一台服务器会记得我是谁以及我在做什么，那么第二台服务器就不知道我是谁，因此也不会记住我。
- en: that I've already logged into this web，application and as a result I might be。prompted
    to log in again and if I we go，make another request and I end up on yet。another
    server I might be logged out，again and have to login for a third time。so the problem
    comes about when our load，balancing happens but we're not doing so。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经登录了这个网络应用，结果可能会提示我再次登录，如果我们再发出另一个请求，我可能会进入另一台服务器，这样我可能会再次被注销，并需要第三次登录。因此，当我们的负载均衡发生但我们没有这样做时，问题就出现了。
- en: in a session aware way that our load，balancer isn't caring about when a user。visits
    a page and then visits another，page on the same web application again。because
    we want to remember information，from the previous time that the user was。here
    so how can we solve this problem，how can we make sure that when we do。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器并不关心用户在访问同一网络应用的某一页面后又访问另一页面的情况，因为我们希望记住用户上次在这里时的信息。那么我们如何解决这个问题呢？我们如何确保在下一次请求时能够记住我上次被发送到哪个服务器，并再次将我发送到那里？
- en: this load balancing across multiple，different servers that we do so in a。session
    and we're way well there are，multiple different approaches to session，aware。load-balancing
    one approach is this，general idea known as sticky sessions。where the idea is that
    when I come back，to the load balancer the load balancer。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在多台不同服务器之间的负载均衡我们是在会话中进行的，而这里有多种不同的会话感知负载均衡的方法，其中一种方法是这种被称为粘性会话的一般理念。其想法是，当我再次回到负载均衡器时，负载均衡器会记住我是谁，不会让我再次登录同一个网站。
- en: will remember what server I was sent to，last time and send me there yet again
    so。for example if I log into a website once，and I'm directed to server number
    two。for example then the next time I visit，this web application even if I should
    be。directed to server 3 or 4 according to，random choice or according to fewest。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我登录到一个网站一次，并被指向第二台服务器，那么下次我访问这个网络应用时，即使我应该根据随机选择或最少负载被指向第三或第四台服务器。
- en: connections or any of these other load，balancing methods the load balancer。should
    remember that last time I came to，this site I got directed to server。number 2
    and so this time the load，balancer is going to direct me to server。number 2 yet
    again that way server，number 2 which contains information，again。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些其他负载均衡方法时，负载均衡器应该记住上次我访问这个网站时被指向了第二台服务器，因此这次负载均衡器将再次把我指向第二台服务器，这样第二台服务器就会再次包含信息。
- en: and remember who it is that I am and，it's not gonna make me log in again into。the
    exact same website for a second time，for example and so sticky sessions are。one
    way of dealing with this problem but，again with all of these approaches and。this
    will be a recurring theme as we，talk about scalability and security and。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，粘性会话是解决这个问题的一种方式，但与所有这些方法一样，这将是我们在谈论可扩展性和安全性时反复出现的主题。
- en: there are trade-offs here that are，trade-off to the sticky sessions is that。it's
    possible that one of these servers，is going to end up getting far more load。than
    another if one server happens to，have a lot of users that keep coming。back to
    the website and keep requesting，additional pages but other pages other。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里存在权衡，粘性会话的权衡是，其中一台服务器可能会比另一台承受更多的负载。如果某台服务器恰好有很多用户不断返回该网站并请求额外页面，而其他页面则以会话感知的方式进行处理。
- en: servers might have had users that，decided not to come back for example and。so
    there's a difference in utilization，where some of our servers might be more。heavily
    utilized than other servers and，we're not doing a very good job of。balancing between
    them and so one，approach is to store sessions inside of。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能有一些用户决定不再回来。例如，因此在利用率上存在差异，我们的一些服务器可能比其他服务器更繁忙，而我们在它们之间的平衡做得不太好。因此，一种方法是将会话存储在。
- en: the database rather than store，information about sessions inside of the。server
    themselves so that if I get，directed to another server that other。server doesn't
    remember Who I am doesn't，remember information about my。interaction with this
    website if we，instead choose to store sessions inside。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库而不是在服务器内部存储关于会话的信息，这样如果我被指向另一台服务器，那台服务器就不会记得我是谁，也不会记得我与这个网站的互动信息。如果我们选择在。
- en: of a database in a particular inside of，a database that all of the servers have。the
    ability to access well then it，doesn't matter which of the servers I。get directed
    to and which server the，load balancer decides to send me to。because regardless
    of which server I end，up getting sent to the session。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定内部的数据库中，所有服务器都有能力良好地访问该数据库。那么，无论我被指向哪个服务器，以及负载均衡器决定将我发送到哪个服务器都没有关系。因为无论我最终被发送到哪个服务器，session。
- en: information is in the database and each，of the servers can connect to the。database
    to find out who I am to find，out whether I've logged into the site，recognize。and
    so that might be one approach as，well another approach is to store，sessions on
    the client side。we've talked a little bit about this，idea of cookies which can
    be stored。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中存储信息，每台服务器可以连接到数据库以查找我是谁，找出我是否已登录该网站，进行识别。因此，这可能是一种方法，另一种方法是将会话存储在客户端。我们稍微谈到了这个关于可以存储的cookie的想法。
- en: where the web browser can set a cookie，so that your web browser is able to。present
    that cookie the next time that，makes a request to the same web。application and
    inside this cookie you，can store a whole bunch of information。including information
    about the session，you might inside of a cookie store。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网页浏览器可以设置一个cookie，以便在下一次向同一网页应用程序发出请求时，您的网页浏览器能够呈现该cookie。在这个cookie中，您可以存储大量信息，包括关于会话的信息，您可能在cookie中存储。
- en: information about what user is currently，logged in for example or other session。related
    information but here to their，drawbacks if you're not careful。someone could manipulate
    that cookie and，maybe pretend to be something else and。so for that reason you
    might want to do，some encryption or some kind of sign-in。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当前登录的用户信息，例如或其他与会话相关的信息，但如果不小心，这里会有缺陷。有人可能会操纵这个cookie，假装成其他身份。因此，出于这个原因，您可能想要进行某种加密或某种形式的签到。
- en: to make sure that you can't fake a，you're not，but another concern is that as
    you start。to store more and more information，inside of these cookies these cookies。keep
    get sending back and forth between，the server and the client every time a。request
    is made that can start to get，expensive to more and more information。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您无法伪造一件事，您不是，但另一个关注点是，随着您开始在这些cookie中存储越来越多的信息，这些cookie在每次请求时都会在服务器和客户端之间来回发送，这可能会变得越来越昂贵。
- en: passing back and forth between the，client and between the server so lots of。possible
    approaches no one approach that，is necessarily the right approach or the。best
    approach to use in any cases but，things to be aware of things to think。about as
    we begin to deal with these，issues of scale of making sure we have。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间来回传递，因此有很多可能的方法，没有一种方法在任何情况下都是唯一正确或最佳的，但有一些事情需要注意和思考，因为我们开始处理这些规模问题，以确保我们有。
- en: multiple servers that are available for，usage in case we do need it but also。making
    sure that when we do so we don't，break the user experience we don't。result in
    a situation where a user is，logged in but then suddenly isn't logged。in at all
    and so horizontal scaling，gives us this kind of capacity the。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个可供使用的服务器，以防我们需要它，但同时确保在这样做时不破坏用户体验，不会导致用户登录后突然无法登录。因此，水平扩展给我们提供了这种容量。
- en: ability to have multiple different，servers all of which can be dealing with。user
    requests and responding to those，user requests as well but a reasonable。question
    asked is how many of those，servers do we need now we can use。benchmarking to try
    to estimate this if，we have an estimate of how many users。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多台不同的服务器，这些服务器都可以处理用户请求并作出响应，但合理的问题是，我们现在需要多少台服务器。我们可以使用基准测试来尝试估计这一点，如果我们估计有多少用户。
- en: are going to be on our website at any，given time we can benchmark and see how。many
    users there can be handled by a，single server and extrapolate based on。that information
    to infer how many，servers we might need in our web。application to be able to service
    all of，these different users but it might be。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基准测试并查看在任何给定时间，单台服务器可以处理多少用户，并根据这些信息推断出我们可能需要多少台服务器来服务所有这些不同的用户，但这可能是。
- en: the case that our web application，doesn't always have the same number of。users
    maybe sometimes they're going to，be far more users than another time you。might
    imagine for example that in a news，organizations web site like the。application
    for a newspaper when there's，breaking news some big story there's。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的web应用程序并不总是有相同数量的用户，有时用户可能会比其他时候多得多。例如，你可以想象在新闻机构的网站上，例如报纸应用程序，在发生突发新闻或重大事件时，会有更多用户。
- en: going to be a lot more people that are，all trying to access the website at the。same
    time than in other times so one，approach might be like consider the。maximum what
    is the most number of users，that ever might be trying to use our web。application
    at any given time and choose，a number of servers based on that。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，试图同时访问网站的人数会比其他时候多得多，因此一种方法可能是考虑最大值，最大用户数量是多少，可能会在任何给定时刻尝试使用我们的web应用程序，并根据此选择服务器数量。
- en: maximum so that no matter how high the，number of users get we will have enough。servers
    to be able to service all of，those users but that's probably not a。great economical
    choice if in the vast，majority of cases there will be far。fewer users in that
    case you're gonna，have a lot of suberin servers that are。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无论用户数量如何，我们都会有足够的服务器来服务所有这些用户，但如果在绝大多数情况下，用户数量要少得多，这可能不是一个经济实惠的选择，在这种情况下，你会有很多闲置的服务器。
- en: underutilized where you don't need that，many servers but you're still paying
    for。the electricity for keeping all of them，running which might not be an ideal。choice
    either so one solution to this，quite popular especially in this world。of cloud
    computing is the idea of auto，scaling or you can have an auto scaler。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要那么多服务器的情况下，你却仍在支付所有这些服务器的电费，这可能不是一个理想的选择。因此，一个相当流行的解决方案，特别是在云计算的世界中，就是自动扩展的概念，或者你可以使用自动扩展器。
- en: to say that you know what let's start，with for example two servers but if。there's
    enough traffic to the website if，enough people are making requests to the。website
    maybe it's a peak time where，people are using the website go ahead。and scale up
    go ahead and add a third，server where now our load balancer can。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，我们从两个服务器开始，但如果网站的流量足够，如果有足够的人向网站发起请求，也许在高峰期，人们正在使用网站，那么可以扩展，添加第三台服务器，负载均衡器可以处理。
- en: balance between all three of those，servers and if even more traffic ends up。coming
    to the website more users are，trying to use this application all at。the same time
    well then we can go ahead，and add a fourth server as well and we。can continue
    to do that most Auto，scalars will let you configure for。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三台服务器之间进行负载平衡，如果更多的流量进入网站，更多用户试图同时使用此应用程序，那么我们可以继续添加第四台服务器，并且我们可以继续这样做，大多数自动扩展器将允许你进行配置。
- en: example a minimum number of servers and，a maximum number of servers and。dependent
    on how many users happen to be，using your web application at any given。time the
    autoscaler can scale up or，scale down adding new servers as more。users come to
    the website removing，servers as fewer users or using the。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最少和最多的服务器数量取决于在任何给定时间使用你的web应用程序的用户数量，自动扩展器可以根据用户的增减来扩展或缩减，添加新服务器，或者在用户减少时移除服务器。
- en: website as well and so this can be a，nice solution to this problem of scale。where
    you don't have to worry about how，many servers there are it just Auto。scales entirely
    on its own now there are，trade-offs here to that this auto。scaling process might
    take time and if a，lot of users all come into your website。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以为扩展问题提供一个不错的解决方案，你不必担心有多少服务器，它会自动完全扩展。不过，这个自动扩展过程可能需要时间，如果大量用户同时访问你的网站。
- en: all of the exact same time well it's，gonna take some time to be able to add。all
    these additional servers to start，them up and so there might be some。trade-offs
    there to where you might not，be able to service all of those users。immediately
    and another problem we're，thinking about，as you add more and more of these。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同时添加所有这些额外服务器需要时间，因此可能会出现一些权衡，可能无法立即服务所有用户，另一个需要考虑的问题是，随着你添加越来越多的这些服务器。
- en: servers you introduce opportunities for，failure now it's better than having
    a。single server where if that single，server fails now suddenly the entire web。application
    doesn't work at all that's，what we generally call a single point of。failure a
    single place where if it fails，the entire system is going to be broken。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 引入多个服务器就带来了失败的机会，但这总比只有一台服务器好。如果那台服务器失败，那么整个web应用就会完全失效，这就是我们通常所说的单点故障，若此处失败，整个系统就会崩溃。
- en: one advantage of having multiple servers，is that we no longer have a single。server
    that acts as a point of failure，if one of the servers goes down then。ideally our
    load balancer should be able，to know based on that information to no。longer send
    requests to that particular，server to instead balance the load。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个服务器的一个优势是，我们不再有一台作为故障点的服务器，如果其中一台服务器宕机，理想情况下，负载均衡器应该能够根据这些信息知道不再向该特定服务器发送请求，而是平衡负载。
- en: across the remaining three servers，instead now if there's an interesting。question
    there as well which is how does，the load balancer know that this server。is no
    longer responding that for some，reasons have some sort of error that。it's not
    able to process requests，appropriately well there are multiple。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在其余三台服务器之间，现在有一个有趣的问题，即负载均衡器如何知道该服务器不再响应，可能因为某种原因发生了错误，无法适当地处理请求，确实存在多种情况。
- en: ways you can do this but one of the most，common is what simply known as a。heartbeat
    where effectively every so，often every some number of seconds the。load balancer
    pings all the server's，just sends a quick request to all the。servers and all the
    servers are supposed，to respond back and using that。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式实现这一点，但最常见的一种是简单称为**心跳**，有效地说，每隔一段时间，负载均衡器就会对所有服务器进行ping操作，快速发送请求到所有服务器，并且所有服务器应该能够响应。
- en: information the load balancer knows a，little bit about the latency of each of。the
    servers how long it took for the，server to respond to the request but。also it
    can get information about，whether or not the server is functioning。properly that
    if one of the server's，doesn't respond to the ping well then。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，负载均衡器对每个服务器的延迟有了一定了解，即服务器响应请求所需的时间。此外，它还可以获取有关服务器是否正常工作的信息，如果其中一个服务器未能响应ping，那么。
- en: the load balancer knows that there's，probably something wrong with the server。that
    we probably shouldn't be directing，more users to that server at all and so。this
    can solve for the problem of a，single point of failure by allowing。ourselves multiple
    servers where if any，one of the server's fails the load。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器知道服务器可能出现了问题，因此我们可能根本不应该将更多用户指向该服务器。这样可以通过允许多个服务器来解决单点故障的问题，如果其中任何一个服务器失败，负载均衡器可以重新分配负载。
- en: balancer learns about that via heartbeat，and then based on that information
    can。begin to redirect traffic to the other，servers instead now one thing you might。notice
    is that even in this picture now，the load balancer appears to be like a。single
    point of failure where if the，load balancer happens to fail well now。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器通过心跳了解情况，然后根据这些信息开始将流量重定向到其他服务器。你可能注意到，即使在这个图中，负载均衡器似乎也是一个单点故障，如果负载均衡器发生故障，那么。
- en: nothing is going to work because a load，balancer is the one responsible for。directing
    traffic to all of these，various different servers and so even。there there's no
    single server that has，a point of failure this load balancer。also appears to be
    a single point of，failure and that's definitely true and。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么会正常工作，因为负载均衡器负责将流量引导到所有这些不同的服务器，因此即使没有单个服务器存在故障点，这个负载均衡器也似乎是一个单点故障，这绝对是正确的。
- en: you might imagine instead of having，multiple load balancers where if one，load
    balancer goes down。another load balancer can swoop in，acting as a hot spare where
    it picks up。all the traffic that was originally，going to the first load balancer
    and if。it ever goes down a second one is ready，to take its place and it might
    also be。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，如果有多个负载均衡器，而如果一个负载均衡器宕机，另一个负载均衡器可以迅速介入，充当热备份，接管所有原本指向第一个负载均衡器的流量；如果它宕机，第二个负载均衡器就准备好接替它。
- en: doing this kind of heartbeat process，checking up on the first load balancer。and
    if all as well the second load，balancer doesn't have to do anything but。if the
    first load balancer ever were to，fail will then the second load balancer。can step
    in and begin servicing those，requests directing them to all of these。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这种心跳过程，检查第一个负载均衡器，如果一切正常，第二个负载均衡器就不需要做任何事情，但如果第一个负载均衡器出现故障，那么第二个负载均衡器可以介入并开始处理那些请求，将它们引导到所有这些。
- en: individual servers as well and so there，- another opportunity to think about。where
    the single points of failure are，and thinking about how we might address。those
    single points of failure in order，to make sure that our web applications。are scalable
    so that then deals with，issues about how we might go about。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单个服务器也是如此，因此，- 这是一个思考单点故障在哪里的另一个机会，并思考我们如何解决这些单点故障，以确保我们的网络应用程序是可扩展的，这样就能处理关于我们可能如何进行的各种问题。
- en: scaling up these servers but ultimately，the servers are not the entirety of
    the。story that inside of our applications we，mostly been have writing web。applications
    that interact and deal with，data in some way and there are multiple。different
    databases that we've talked，about sequel light has been the default。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展这些服务器，但最终服务器并不是整个故事，实际上在我们的应用程序中，我们大多在编写与数据以某种方式交互和处理的网络应用程序，我们讨论过的多个不同数据库，其中
    SQLite 一直是默认选择。
- en: one that Django provides to us which，just stores data inside of a file but as。we
    begin to grow our applications as we，want to begin to scale them it's quite。popular
    in quite common to put databases，entirely some more separate have a。separate database
    server running，somewhere else where the servers are all。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供给我们的一个解决方案，它仅将数据存储在文件中，但当我们开始扩展我们的应用程序时，通常会将数据库完全分开，拥有一个单独的数据库服务器在其他地方运行，所有服务器都与之相连。
- en: communicating with that database whether，it's running my sequel or Postgres
    of。some other database system instead and，all of the servers that have access
    to。that database and so they're - are our，considerations that we need to take
    into。account issues of how it is that we go，about scaling up these databases that
    in。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与那个数据库通信，无论是运行 MySQL 还是 Postgres 或其他数据库系统，以及所有有权访问那个数据库的服务器，因此我们需要考虑的问题是如何扩展这些数据库。
- en: this picture for example you might，imagine a load balancer that is。communicating
    with two servers but both，of those servers for example need to be。communicating
    with this database and，much like any server can only handle。some number of requests
    some number of，users at any given time databases - can。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片举个例子，你可以想象一个负载均衡器正在与两个服务器通信，但这两个服务器例如都需要与这个数据库进行通信，而任何服务器在任何给定时间只能处理一定数量的请求和用户，数据库也是如此。
- en: only handle some number of requests some，concurrent number of connections at
    any。given time and so we need to begin to，think about issues of how it is that
    we。scale these databases as well in order，to be able to handle more and more users。now
    one approach the first thing we，might try to do is something called。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可能只处理一定数量的请求和同时连接，因此我们需要开始考虑如何扩展这些数据库的问题，以能够处理越来越多的用户。现在，一个方法是我们可能会尝试的第一件事被称为。
- en: database partitioning effectively，splitting up what is a big data set into。multiple
    different parts to that data，set and we've already seen some examples。of database
    partitioning，we've seen one example where for example。when we talked about sequel
    we looked at，a table of flights where each flight had。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分区，实际上是将大型数据集拆分成多个不同的部分，我们已经看到了数据库分区的一些示例，例如，当我们谈论 SQL 时，我们查看了一张航班表，每个航班都有。
- en: an Origin City the Origin city's airport，code the destination city the。destination
    Cities Airport code and some。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_8.png)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个出发城市、出发城市的机场代码、目的城市、目的城市的机场代码以及一些。![](img/9e1a5fe55e2bc95a425be60a3f404bd4_8.png)
- en: number of minutes the duration for that，particular flight and we decided that。storing
    all of this data in a single，table probably wasn't the best idea and。instead we
    wanted to split that data up，in a type of partitioning where instead。we said alright
    let's just have one，table that will have all of the airports。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表示该航班的持续时间的分钟数，我们决定将所有这些数据存储在一个单一表中可能不是最佳主意，因此我们想要将数据拆分成一种分区类型，我们说，好吧，我们只需有一个表，包含所有的机场。
- en: and so each Airport gets its own row，inside of this airport's table and we。also
    had another table which was just，the flights table which rather than。storing all
    of those columns just mapped，two airports to each other that with any。given flight
    it has an Origin ID meaning，which object which row in the origin of。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个机场在这个机场表中都有自己的行，我们还有另一个仅包含航班的表，它不存储所有这些列，而是将两个机场相互映射，对于任何给定的航班，它有一个来源 ID，意味着哪个对象、哪个行在来源中。
- en: airports table is represented by the，flight and then which row in the。airport's
    table is going to represent，the destination for that flight so we。took one table
    and effectively split it，up into multiple tables each of which。ultimately had
    fewer columns and this，might be something we call it the。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: airports 表由航班表示，而机场表的哪一行将代表该航班的目的地，因此我们将一个表有效地拆分成多个表，每个表的列数更少，这可能是我们所称的。
- en: vertical partitioning of a database，where instead of just having single big。long
    tables we split them up into，multiple tables each of which have fewer。columns
    that are able to represent data，in a more relational way and that's。something
    we've seen before too but in，addition to vertical partitioning we can。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的垂直分区，其中我们不仅仅有单一的大长表，而是将它们拆分成多个列数较少的表，这样可以以更关系化的方式表示数据，这也是我们以前见过的，但除了垂直分区外，我们还可以。
- en: also do horizontal partitioning where，the idea there is that we take a table。and
    just split it up into multiple，tables that are all storing effectively。the same
    data but split up into，different data sets so the same type of。data but just in
    different tables where，we might have originally had a flights。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以进行水平分区，理念是我们将一个表拆分成多个存储同样数据的表，因此相同类型的数据但在不同的表中，我们可能原本有一个航班表。
- en: table and instead we split it up into a，domestic flights table and an。international
    flights table each of，these tables still has the exact same。columns they still
    have a destination，column they still have an Origin column。they still have a duration
    column for，example but we've just now taken the。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其拆分为国内航班表和国际航班表，这些表仍然具有完全相同的列，它们仍然有目的地列、出发列，它们仍然有持续时间列，例如，但我们现在只是将。
- en: data that used to be in one table and，split up that data into two or more。multiple
    different tables instead one，for all the domestic flights one for all。the international
    flights and the，advantage there is that we no longer。need to search through the
    entirety of，the data set if we're just looking for。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 原本在一个表中的数据拆分到两个或更多不同的表中，一个用于所有国内航班，一个用于所有国际航班，其优势在于，如果我们只在寻找一个国内航班，我们无需在整个数据集中搜索。
- en: one domestic flight for example if you，know the flight you're looking for is
    a，domestic flight。well then it can be more efficient to，just search the flights
    domestic table。and not bother searching through the，flights international table
    and so for。intelligent about how we choose to take，a table and split it up into
    multiple。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你知道你在找的航班是国内航班，那么搜索国内航班表可能更高效，而不必去搜索国际航班表，因此在选择将一个表拆分成多个表时，我们要聪明一点。
- en: different tables the effect of that is，that we can often improve the efficiency。of
    our searches the efficiency of our，operations because we're dealing with。multiple
    smaller tables where these，operations can come faster one drawback。though is that
    as we begin to split data，across multiple different tables it。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的表，这样的效果是我们可以经常提高搜索的效率，我们的操作效率，因为我们处理的是多个较小的表，这些操作可以更快。一个缺点是，随着我们开始将数据分散到多个不同的表中。
- en: becomes more expensive if ever we need，to join this data back together and。connect
    all the domestic and，international flights running separate。queries on each and
    so in that case，we'll want to think about trying to。separate our data in such
    a way that，generally we're only going to need to。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将这些数据重新连接在一起，并连接所有国内和国际航班，运行单独的查询，这样就变得更加昂贵，因此在这种情况下，我们需要考虑尝试以这样的方式分离数据，以便通常我们只需要。
- en: deal with one table or the other at any，given time and so domestic and。international
    might be a reasonable way，to split up our flights table。because maybe most of
    the time our，Airport just cares about searching。domestic flights if we're know
    we're，looking for one kind of flight or just。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间，只处理一个表，因此国内和国际可能是拆分航班表的合理方式，因为我们的大部分时间机场只关心搜索国内航班，如果我们知道我们在寻找某种航班或仅仅是。
- en: cares about searching for international，flights if there are different people
    or。different computers that are gonna，handle each of those different types of。systems
    and so partitioning our database，can sometimes help with issues of scale。by making
    it faster to search through，large amounts of data and being able to。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有不同的人或不同的计算机处理这些不同类型的系统，那么对搜索国际航班的关心就很重要，因此分区数据库有时可以帮助解决规模问题，使搜索大量数据变得更快，并能够。
- en: represent data a little bit more cleanly，but it still seems to represent a single。point
    of failure that we have multiple，servers now that are all connected to。the same
    database and there again is a，single point of failure if the database。fails for
    some reason well now suddenly，none of our web application is going to。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更清晰地表示数据，但这仍然似乎表示了一个单点故障，因为现在我们有多个服务器都连接到同一个数据库，如果数据库因某种原因失败，那么我们的网络应用将无法。
- en: work because all of those servers are，all connected to that exact same。database
    and so it's for that reason，that we might just as we tried to add。more servers
    in order to solve the，problem of a single point of failure。with our servers we
    might also try，database replication that rather than。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 工作是因为所有这些服务器都连接到同一个**数据库**，因此我们可能会尝试增加更多服务器，以解决单点故障的问题，同时我们也可以尝试数据库复制，而不是。
- en: just have a single database in our web，application in order to guard against。potential
    failure we might replicate our，database has multiple different。databases and therefore
    reduce the，likelihood that our application entirely。fails and there are a couple
    of，approaches we can use for database。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络应用中只需一个单一的数据库，以防潜在的故障，我们可能会将我们的数据库复制成多个不同的数据库，从而降低我们的应用完全失败的可能性，关于数据库我们可以使用几种方法。
- en: replication two of the most common are，what are known as single primary。replication
    and multi primary，replication and in single primary。database replication we have
    multiple，different databases but。one of those databases is considered to，be the
    primary database and what we mean。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最常见的复制方法是称为单主复制和多主复制，在单主数据库复制中，我们有多个不同的数据库，但其中一个数据库被认为是主数据库，这就是我们所指的。
- en: by a primary database is a database to，which we can both read data meaning like。select
    rows from the table but also，write data meaning insert rows or update。rows or
    delete rows to any of those，tables so in single primary replication。we have a
    single database where we can，both read and write and we have some。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库是一个我们可以读取数据的数据库，这意味着可以从表中选择行，同时也可以写入数据，这意味着插入行或更新行或删除这些表中的行，因此在单主复制中，我们有一个单一的数据库可以进行读写操作。
- en: number of other databases in this case，two other databases from which we can。only
    read data so we can get data from，those databases but we can't update or。insert
    or delete from those databases，and now we need some mechanism to make。sure that
    all of these databases are，kept in sync and ultimately what that。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他多个数据库，在这种情况下，有两个其他数据库，我们只能从中读取数据，因此我们可以从这些数据库获取数据，但不能更新、插入或删除这些数据库中的数据。现在我们需要一些机制来确保所有这些数据库保持同步，最终。
- en: means is that anytime the database，changes all of the databases are。informed
    now the only database that can，change is our primary one this is the。only one
    that can be written to the only，one that allows for the data to change。the others
    are read-only so anytime this，primary database updates or changes in。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当数据库发生变化时，所有数据库都会被通知。现在唯一能够改变的是我们的主数据库，这是唯一一个可以写入的数据库，也是唯一允许数据发生变化的数据库。其他数据库是只读的，因此每当这个主数据库更新或发生变化时。
- en: some way it needs to inform the other，databases of that update and so it。informs
    the other databases of that，update and now all of the databases are。kept in sync
    where if you try and run a，query on any of these databases to。select and get some
    information you'll，get the same results from all of these。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方式，它需要通知其他数据库该更新，因此它会通知其他数据库该更新，现在所有数据库都保持同步，如果你尝试在这些数据库中运行查询以选择和获取一些信息，你会从所有这些数据库中获得相同的结果。
- en: various different databases now the，single primary approach has some。drawbacks
    it has the drawback of only，one of these databases can be written to。so if you
    have a lot of users that are，all trying to write data to the database。at the exact
    same time well there might，be some issues here where this one。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 各种不同的数据库，现在单一主数据库的方法有一些缺点，它的缺点是只有其中一个数据库可以进行写入，因此如果有很多用户同时尝试向数据库写入数据，可能会出现一些问题。
- en: database is going to be carrying all of，that load for all of the people that。might
    be trying to update and change，that database and it also has a slightly。smaller
    version of the same problem of a，single point of failure there's no。longer a single
    point of failure for，reading from that data that if you want。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据库将承担所有可能尝试更新和更改该数据库的人的负载，它还存在稍小版本的相同问题，即单点故障的问题。对于从数据中读取而言，不再存在单点故障，如果你想要。
- en: to read from the data and one of the，databases goes out you can read data。from
    any of the other databases and，they'll work just fine but it does have。the drawback
    that if this database fails，if our primary database fails well then。we're no longer
    able to write data that，if we want to update data inside of our。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据中读取时，如果其中一个数据库出现故障，你可以从其他任何数据库读取数据，它们工作得很好，但它确实有一个缺点，如果这个数据库失败，如果我们的主数据库失败，那么我们将不再能够写入数据，如果我们想要更新数据。
- en: database this one database is no longer，going to be operational and none of
    the。other databases are going to allow us to，write new changes so there are a
    couple。of approaches we can use to try to solve，this problem，one approach though
    is instead of having。a single primary database a single，database to which we can
    read and write。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库这个数据库不再可用，其他数据库也不允许我们进行新的更改，因此我们可以尝试几种方法来解决这个问题。不过一种方法是，不再拥有一个单一的主数据库，也就是一个可以读写的单一数据库。
- en: to use a multi primary approach and in，the multi primary approach we have。multiple
    databases all of which we can，read and write to we can select rows。from all the
    databases and we can insert，an update and delete rows to all of。these databases
    as well but now the，synchronization process becomes a little。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 采用多主数据库的方法，在多主数据库的方法中，我们有多个数据库，所有数据库都可以进行读写，我们可以从所有数据库中选择行，也可以向所有这些数据库插入、更新和删除行，但现在同步过程变得有些复杂。
- en: bit trickier and here now is the trade，off and now we've replicated the number。of
    reads and writes we can do by having，many databases to which we can read data。and
    write data but anytime any of these，databases changes every database needs。to
    inform all of the other databases of，those updates and that's certainly going。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是权衡，现在我们通过拥有多个可以读取和写入数据的数据库，复制了可以进行的读取和写入的数量，但每当这些数据库中的任何一个发生变化时，每个数据库都需要通知其他所有数据库这些更新，这肯定会。
- en: to take some amount of time it，introduces some complexity into our，system as
    well。and it also introduces the possibility，for conflicts that you might imagine。situations
    where if two people are，editing similar data at the same time。that you might run
    into a number of，different types of conflicts so one type。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要花费一定时间，它为我们的系统引入了一些复杂性。同时，它也引入了可能的冲突，想象一下，如果两个人同时编辑相似的数据，可能会遇到多种不同类型的冲突。
- en: of conflict for example would be an，update conflict if I try to edit one row。in
    one database and someone else tries，to edit the same row in another database。when
    they sync up with each other via，this update process our database system。needs
    some way to decide how it's going，to resolve those various different。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突的一个例子是更新冲突，如果我在一个数据库中尝试编辑一行，而另一个人在另一个数据库中也尝试编辑同一行。当它们通过此更新过程进行同步时，我们的数据库系统需要某种方式来决定如何解决这些不同的冲突。
- en: updates another conflict might be a，uniqueness conflict we've seen in the。case
    of databases in sequel that when，we're designing our tables I can specify。that
    this particular field should be a，unique field common one being the ID。field for
    example where every single Row，is going to have its own unique ID well。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个冲突可能是唯一性冲突，我们在设计数据库表时看到的情况。我可以指定这个特定字段应该是一个唯一字段，常见的例子是ID字段，其中每一行都会有自己的唯一ID。
- en: what happens if two people try to insert，data at the same time into two different。databases
    they're each given a unique ID，but it's the same ID on both of the。databases because
    neither database knows，that the other database is added a new。row yet so when
    they sync back up we，might run into uniqueness conflict where。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个人同时尝试将数据插入到两个不同的数据库中会发生什么？他们各自会被分配一个唯一的ID，但在两个数据库中ID是相同的，因为没有一个数据库知道另一个数据库已经添加了新行。因此，当它们重新同步时，我们可能会遇到唯一性冲突。
- en: two different databases have assigned，the same exact ID to multiple different。entries
    and so we need some way to be，able to resolve those conflicts as well。and there
    are many other conflicts you，might imagine trying to deal with one。example being
    for instance delete，conflicts where one person tries to。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不同的数据库为多个不同的条目分配了完全相同的ID，因此我们需要某种方式来解决这些冲突。此外，还有许多其他冲突，比如删除冲突，一个人尝试删除数据时。
- en: delete a row and another person tries to，update that row well which should take。precedence
    should we update the rows，should we delete the row we need some。way to be able
    to make those decisions，because，there is some latency between when a。change is
    made to a database and when，that database is able to communicate。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个人删除一行，另一个人尝试更新那一行，那么哪个应该优先？我们应该更新行，还是删除行？我们需要某种方式来做出这些决策，因为在对数据库进行更改和该数据库能够进行通信之间存在一些延迟。
- en: with another database so these issues of，scale these issues of the。synchronization
    are always going to come，up as we start to deal with programs。that are interacting
    with more and more，of this kind of data and as a result we。need to design more
    and more，sophisticated systems that are able to。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始处理与越来越多此类数据交互的程序，这些规模问题和同步问题总是会出现。因此，我们需要设计越来越复杂的系统，能够应对这些情况。
- en: deal with those issues of scale now，ultimately we'd ideally like to reduce。the
    number of different of these，database servers that we have that every。additional
    database server is going to，cost time it's gonna cost resources that。cost money
    in terms of keeping all of，these servers running and so ideally。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在处理这些规模的问题，最终我们理想的目标是减少不同的数据库服务器数量，因为每增加一个数据库服务器都会消耗时间、资源和资金来维持所有这些服务器的运行，因此理想情况下。
- en: we'd like not to have to talk to this，database if we don't need to so you。might
    imagine for example a news，organizations website something like the。front page
    of the New York Times if you，go to the home page of the New York。Times website
    it displays all of the，day's headlines with images and with。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要与这个数据库进行交互，我们希望不必与其通信。你可以想象，例如新闻组织的网站，类似于《纽约时报》的首页。如果你访问《纽约时报》网站的主页，它会显示当天的所有头条新闻及其图片。
- en: information about what each of the，stories are about for example and you。might
    imagine that the way they're doing，something like this is that they have。some
    kind of database that's storing all，of these news articles and when you。visit
    the front page of the New York，Times it's going to do some kind of。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关每个故事的具体信息，例如，你可能会想象，他们的做法是，他们有某种数据库，存储所有这些新闻文章，当你访问《纽约时报》的首页时，它会进行某种。
- en: database query selecting all of the，recent top headlines for example and。rendering
    all of that information in an，HTML page that you can see and that。would certainly
    work but if a lot of，people are all requesting the front page。at the same time
    well it probably，doesn't make all that much sense if the。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询，选择所有最近的头条新闻，并将所有这些信息呈现在你可以看到的HTML页面上，这当然可行，但如果很多人同时请求首页，那可能。
- en: web application every time is making a，database query getting the latest。article
    ISM and then displaying that，information to all the users because the。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每次网络应用都在进行数据库查询以获取最新文章并将这些信息展示给所有用户，这样做似乎没有太大意义，因为。
