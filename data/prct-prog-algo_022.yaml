- en: 4.3   Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3   栈和队列
- en: 原文：[https://introcs.cs.princeton.edu/java/43stack](https://introcs.cs.princeton.edu/java/43stack)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/43stack](https://introcs.cs.princeton.edu/java/43stack)
- en: 'In this section, we introduce two closely-related data types for manipulating
    arbitrarily large collections of objects: the *stack* and the *queue*. Stacks
    and queues are special cases of the idea of a *collection*. Each is characterized
    by four operations: *create* the collection, *insert* an item, *remove* an item,
    and test whether the collection is *empty*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两种密切相关的数据类型，用于操作任意大的对象集合：*栈*和*队列*。栈和队列是*集合*概念的特殊情况。每个都由四个操作特征化：*创建*集合，*插入*项目，*移除*项目，以及测试集合是否*为空*。
- en: Stacks.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈。
- en: 'A *stack* is a collection that is based on the last-in-first-out (LIFO) policy.
    By tradition, we name the stack *insert* method `push()` and the stack *remove*
    operation `pop()`. We also include a method to test whether the stack is empty,
    as indicated in the following API:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*是基于后进先出（LIFO）策略的集合。按照传统，我们将栈的*插入*方法命名为`push()`，将栈的*移除*操作命名为`pop()`。我们还包括一个方法来测试栈是否为空，如下所示的API：'
- en: '![API for a stack](../Images/194130150b3ca240c171bc3145609d1d.png)'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![栈的API](../Images/194130150b3ca240c171bc3145609d1d.png)'
- en: Array implementations of stacks.
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈的数组实现。
- en: Representing stacks with arrays is a natural idea. In particular, we maintain
    an instance variable `n` that stores the number of items in the stack and an array
    `items[]` that stores the `n` items, with the most recently inserted item in `items[n-1]`
    and the least recently inserted item in `items[0]`. This policy allows us to add
    and remove items at the end without moving any of the other items in the stack.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组表示栈是一个自然的想法。特别是，我们维护一个实例变量`n`，用于存储栈中的项目数量，以及一个数组`items[]`，用于存储`n`个项目，其中最近插入的项目在`items[n-1]`中，最早插入的项目在`items[0]`中。这种策略允许我们在末尾添加和移除项目而无需移动栈中的其他项目。
- en: '*Fixed-length array implementation of a stack of strings.* [ArrayStackOfStrings.java](ArrayStackOfStrings.java.html)
    implements this approach for a stack of strings whose maximum capacity is specified
    by the argument to the constructor. To remove an item, we decrement `n` and then
    return `a[n]`; to insert a new item, we set `a[n]` equal to the new item and then
    increment `n`.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*固定长度数组实现的字符串栈。*[ArrayStackOfStrings.java](ArrayStackOfStrings.java.html)实现了这种方法，用于指定构造函数参数的字符串栈的最大容量。要移除一个项目，我们减少`n`然后返回`a[n]`；要插入一个新项目，我们将`a[n]`设置为新项目，然后增加`n`。'
- en: '![Trace of ArrayStackOfStrings test client](../Images/37c521fcee96430581cb743dfe035492.png)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![ArrayStackOfStrings测试客户端的跟踪](../Images/37c521fcee96430581cb743dfe035492.png)'
- en: '*Resizing array implementation of a stack of strings.* [ResizingArrayStackOfStrings.java](ResizingArrayStackOfStrings.java.html)
    is a version of [ArrayStackOfStrings.java](ArrayStackOfStrings.java.html) that
    dynamically adjusts the length of the array `items[]` so that it is sufficiently
    large to hold all of the items and but not so large as to waste an excessive amount
    of space. First, in `push()`, we check whether there is room for the new item;
    if not, we create a new array of *double* the length of the old array and copy
    the items from the old array to the new array. Similarly, in `pop()`, we check
    whether the array is too large, and we *halve* its length if that is the case.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整大小的字符串栈数组实现。*[ResizingArrayStackOfStrings.java](ResizingArrayStackOfStrings.java.html)是[ArrayStackOfStrings.java](ArrayStackOfStrings.java.html)的一个版本，它动态调整数组`items[]`的长度，以便足够大以容纳所有项目，但不会浪费过多空间。首先，在`push()`中，我们检查是否有空间放置新项目；如果没有，我们创建一个新数组，其长度是旧数组的*两倍*，并将项目从旧数组复制到新数组。类似地，在`pop()`中，我们检查数组是否过大，如果是，则*减半*其长度。'
- en: '![trace of a stack implementation using array doubling](../Images/5a50c3d06c9806b457680a35432eafce.png)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用数组加倍实现栈的跟踪](../Images/5a50c3d06c9806b457680a35432eafce.png)'
- en: This doubling-and-halving strategy guarantees that that the stack never overflows
    and never becomes less than one-quarter full.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种加倍和减半的策略确保栈永远不会溢出，也永远不会少于四分之一满。
- en: '*Resizing array implementation of a generic stack.* [ResizingArrayStack.java](ResizingArrayStack.java.html)
    implements a generic stack using a resizing array. For technical reasons, a cast
    is needed when allocating the array of generics.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整大小的通用栈数组实现。*[ResizingArrayStack.java](ResizingArrayStack.java.html)使用调整大小的数组实现了一个通用栈。出于技术原因，在为泛型分配数组时需要进行强制转换。'
- en: Linked lists.
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表。
- en: 'A *singly linked list* comprises a sequence of *nodes*, with each node containing
    a reference (or *link*) to its successor. By convention, the link in the last
    node is *null*, to indicate that it terminates the list. With object-oriented
    programming, implementing linked lists is not difficult. We define a class for
    the node abstraction that is *recursive* in nature:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*单链表*由一系列*节点*组成，每个节点包含对其后继节点的引用（或*链接*）。按照惯例，最后一个节点中的链接为*null*，表示终止列表。通过面向对象编程，实现链表并不困难。我们定义了一个递归性质的节点抽象类：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Anatomy of a singly linked list](../Images/0380b723a5f74baf569d2119916db056.png)
    A `Node` object has two instance variables: a `String` and a `Node`. The `String`
    is a placeholder in this example for any data that we might want to structure
    with a linked list (we can use any set of instance variables); the instance variable
    of type `Node` characterizes the linked nature of the data structure.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![单链表的解剖结构](../Images/0380b723a5f74baf569d2119916db056.png) 一个`Node`对象有两个实例变量：一个`String`和一个`Node`。在这个例子中，`String`是任何我们想要用链表结构化的数据的占位符（我们可以使用任何一组实例变量）；类型为`Node`的实例变量表征了数据结构的链式特性。'
- en: '*Linking together a linked list.* For example, to build a linked list that
    contains the items `"to"`, `"be"`, and `"or"`, we create a `Node` for each item:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接在一起的链表。*例如，要构建一个包含项目`"to"`、`"be"`和`"or"`的链表，我们为每个项目创建一个`Node`：'
- en: '![linking together a linked list](../Images/fcf86c6ef35035ddb311f20358dded87.png)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![链接在一起的链表](../Images/fcf86c6ef35035ddb311f20358dded87.png)'
- en: '*Insert.* Suppose that you want to insert a new node into a linked list. The
    easiest place to do so is at the beginning of the list. For example, to insert
    the string `not` at the beginning of a given linked list whose first node is `first`,
    we save `first` in a temporary variable `oldFirst`, assign to `first` a new `Node`,
    and assign its `item` field to `not` and its `next` field to `oldFirst`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入。*假设您想要将新节点插入到链表中。最容易这样做的地方是在列表的开头。例如，要在给定链表的开头插入字符串`not`，其第一个节点为`first`，我们将`first`保存在临时变量`oldFirst`中，为`first`分配一个新的`Node`，将其`item`字段分配给`not`，将其`next`字段分配给`oldFirst`。'
- en: '![inserting an item into a linked list](../Images/66fc4d991bb824ac0d30fac938cda31e.png)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![将项目插入到链表中](../Images/66fc4d991bb824ac0d30fac938cda31e.png)'
- en: '*Remove.* Suppose that you want to remove the first node from a list. This
    operation is even easier: simply assign to `first` the value `first.next`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除。*���设您想要从列表中移除第一个节点。这个操作甚至更容易：只需将`first`赋值为`first.next`。'
- en: '![removing an item from a linked list](../Images/0f10b48fc34dfbc81af6a7c0a0f0e712.png)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![从链表中移除项目](../Images/0f10b48fc34dfbc81af6a7c0a0f0e712.png)'
- en: '*Traversal.* To examine every item in a linked list, we initialize a loop index
    variable `x` that references the the first `Node` of the linked list. Then, we
    find the value of the item associated with `x` by accessing `x.item`, and then
    update `x` to refer to the next `Node` in the linked list, assigning to it the
    value of `x.next` and repeating this process until `x` is `null` (which indicates
    that we have reached the end of the linked list). This process is known as *traversing*
    the list, and is succinctly expressed in this code fragment:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遍历。*为了检查链表中的每个项目，我们初始化一个循环索引变量`x`，它引用链表的第一个`Node`。然后，我们通过访问`x.item`找到与`x`关联的项目的值，然后更新`x`以引用链表中的下一个`Node`，将其赋值为`x.next`的值，并重复此过程，直到`x`为`null`（表示我们已经到达链表的末尾）。这个过程被称为*遍历*列表，并在这段代码片段中简洁地表达：'
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Traversing a singly linked list](../Images/84a60495cfd56f8fe968ac30b4816f18.png)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![遍历单链表](../Images/84a60495cfd56f8fe968ac30b4816f18.png)'
- en: Implementing stacks with linked lists.
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表实现栈。
- en: Representing stacks with linked lists is a natural idea. In particular, we maintain
    an instance variable `first` that stores a reference to the most recently inserted
    item. This policy allows us to add and remove items at the beginning of the linked
    list without accessing the links of any other items in the linked list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表表示栈是一个自然的想法。特别是，我们维护一个实例变量`first`，它存储对最近插入的项目的引用。这个策略允许我们在链表的开头添加和移除项目，而无需访问链表中任何其他项目的链接。
- en: '*Linked-list implementation of a stack of strings.* [LinkedStackOfStrings.java](LinkedStackOfStrings.java.html)
    uses a linked list to implement a stack of strings. The implementation is based
    on a *nested class* `Node` like the one we have been using. Java allows us to
    define and use other classes within class implementations in this natural way.
    We designate the nested class as `private` because clients do not need to know
    any of the details of the linked lists.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串栈的链表实现。*[LinkedStackOfStrings.java](LinkedStackOfStrings.java.html)使用链表来实现字符串栈。该实现基于我们一直在使用的*嵌套类*`Node`。Java允许我们以这种自然的方式在类实现中定义和使用其他类。我们将嵌套类指定为`private`，因为客户端不需要知道链表的任何细节。'
- en: '![trace of stack implementation using a linked list of strings](../Images/432e41e577542b4522b28adc62f4aed1.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用字符串链表实现堆栈的跟踪](../Images/432e41e577542b4522b28adc62f4aed1.png)'
- en: '*Linked-list implementation of a generic stack.* [Stack.java](Stack.java.html)
    implements a generic stack using a singly linked list.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泛型栈的链表实现。*[Stack.java](Stack.java.html)使用单链表实现了一个泛型栈。'
- en: Queue.
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列。
- en: 'A *queue* supports the insert and remove operations using a first-in first-out
    (FIFO) discipline. By convention, we name the queue insert operation *enqueue*
    and the remove operation *dequeue*, as indicated in the following API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*支持使用先进先出（FIFO）原则的插入和移除操作。按照惯例，我们将队列的插入操作命名为*enqueue*，移除操作命名为*dequeue*，如下所示的API：'
- en: '![API for a LIFO queue](../Images/deb436b95a1c3f7baa0c6178909e687e.png)'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![LIFO队列的API](../Images/deb436b95a1c3f7baa0c6178909e687e.png)'
- en: '*Linked-list implementation of a queue.* [Queue.java](Queue.java.html) implements
    a FIFO queue of strings using a linked list. Like `Stack`, we maintain a reference
    `first` to the least-recently added `Node` on the queue. For efficiency, we also
    maintain a reference `last` to the most-recently added `Node` on the queue.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用链表实现队列。*[Queue.java](Queue.java.html)使用链表实现了一个字符串的FIFO队列。与`Stack`类似，我们维护对队列中最近添加的`Node`的引用`first`。为了效率，我们还维护对队列中最近添加的`Node`的引用`last`。'
- en: '![inserting into a queue](../Images/afec8f063e5b39b1d277dbca363ed66f.png)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![插入到队列中](../Images/afec8f063e5b39b1d277dbca363ed66f.png)'
- en: '*Resizing array implementation of a queue.* [ResizingArrayQueue.java](ResizingArrayQueue.java.html)
    implements a queue using a resizing array. It is similar to [ResizingArrayStack.java](ResizingArrayStack.java.html),
    but trickier since we need to add and remove items from opposite ends of the array.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整大小的数组实现队列。*[ResizingArrayQueue.java](ResizingArrayQueue.java.html)使用调整大小的数组实现了一个队列。它类似于[ResizingArrayStack.java](ResizingArrayStack.java.html)，但更棘手，因为我们需要从数组的两端添加和移除项目。'
- en: '![trace of a queue implementation using an array](../Images/dcc09c7d5667a8076b7bc7a025f64885.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用数组实现队列的跟踪](../Images/dcc09c7d5667a8076b7bc7a025f64885.png)'
- en: Generics.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型。
- en: We have developed stack implementations that allows us to build a stack of one
    particular type, such as `String`. A specific mechanism in Java known as *generic
    types* enables us to build collections of objects of a type to be specified by
    client code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了允许我们构建特定类型的堆栈的堆栈实现，比如`String`。Java中的一种特定机制，称为*泛型类型*，使我们能够构建由客户端代码指定类型的对象集合。
- en: '*Implementing a generic collection.* To implement a generic collection, we
    specify a *type parameter*, such as `Item`, in angle brackets and use that type
    parameter in our implementation instead of a specific type. For example, [Stack.java](Stack.java.html)
    is generic version of [LinkedStackOfStrings.java](LinkedStackOfStrings.java.html)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现一个通用集合。* 要实现一个通用集合，我们在尖括号中指定一个*类型参数*，比如`Item`，并在我们的实现中使用该类型参数而不是特定类型。例如，[Stack.java](Stack.java.html)
    是[LinkedStackOfStrings.java](LinkedStackOfStrings.java.html)的通用版本。'
- en: '*Using a generic collection.* To use a generic collection, the client must
    specify the *type argument* when the stack is created:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用通用集合。* 要使用通用集合，客户端必须在创建栈时指定*类型参数*：'
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Autoboxing.
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动装箱。
- en: 'We have designed our stacks to be *generic*, so that they objects of any type.
    The Java language features known as *autoboxing* and *unboxing* enable us to reuse
    *generic* code with primitive types as well. Java supplies built-in object types
    known as *wrapper types*, one for each of the primitive types: [Boolean](https://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html),
    [Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html), [Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html),
    [Character](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html),
    and so forth. Java automatically converts between these reference types and the
    corresponding primitive types so that we can write code like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计我们的栈是*通用*的，因此它们可以存���任何类型的对象。Java语言提供的*自动装箱*和*拆箱*功能使我们能够重用*通用*代码与原始类型。Java提供了称为*包装类型*的内置对象类型，每个原始类型对应一个：[Boolean](https://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html)、[Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)、[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)、[Character](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html)等。Java自动在这些引用类型和相应的原始类型之间进行转换，以便我们可以编写如下代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Iteration.
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代。
- en: Sometimes the client needs to access all of the items of a collection, one at
    a time, without deleting them. To maintain encapsulation, we do not want to reveal
    the internal representation of the queue (array or linked list) to the client.
    To accommodate this design pattern, Java provides the *foreach* statement. You
    should interpret the following `for` statement in the following code fragment
    as *for each string s in the collection, print s*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时客户端需要逐个访问集合中的所有项目，而不删除它们。为了保持封装性，我们不希望向客户端透露队列（数组或链表）的内部表示。为了适应这种设计模式，Java提供了*foreach*语句。您应该将以下代码片段中的`for`语句解释为*对于集合中的每个字符串s，打印s*。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing a collection that supports iteration in this way requires implementing
    Java's [java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)
    and [java.util.Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)
    interfaces. See the textbook for details.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式支持迭代的集合的实现需要实现Java的[java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)和[java.util.Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)接口。有关详细信息，请参阅教科书。
- en: Stack and queue applications.
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和队列应用。
- en: Stacks and queues have numerous useful applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和队列有许多有用的应用。
- en: '*Arithmetic expression evaluation.* An important application of stacks is in
    *parsing*. For example, a compiler must parse arithmetic expressions written using
    *infix notation*. For example the following infix expression evaluates to 212.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算术表达式求值。* 栈的一个重要应用是在*解析*中。例如，编译器必须解析使用*中缀表示法*编写的算术表达式。例如，以下中缀表达式求值为212。'
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Evaluate.java](Evaluate.java.html) evaluates a fully parenthesized arithmetic
    expression.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Evaluate.java](Evaluate.java.html)评估一个完全括号化的算术表达式。'
- en: '*Function-call abstraction.* Most programs use stacks implicitly because they
    support a natural way to implement function calls, as follows: at any point during
    the execution of a function, define its *state* to be the values of all of its
    variables *and* a pointer to the next instruction to be executed. The natural
    way to implement the function-call abstraction is to use a stack. To call a function,
    push the state on a stack. To return from a function call, pop the state from
    the stack to restore all variables to their values before the function call and
    resume execution at the next instruction to be executed.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数调用抽象。* 大多数程序隐式使用栈，因为它们支持实现函数调用的一种自然方式，如下所示：在函数执行的任何时候，将其*状态*定义为所有变量的值*和*指向下一个要执行的指令的指针。实现函数调用抽象的自然方式是使用栈。要调用函数，将状态推送到栈上。要从函数调用返回，从栈中弹出状态以将所有变量恢复为函数调用前的值，并在下一个要执行的指令处恢复执行。'
- en: '*M/M/1 queue.* One of the most important queueing models is known as an *M*/*M*/1
    queue, which has been shown to accurately model many real-world situations. It
    is characterized by three properties:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*M/M/1队列。* 最重要的排队模型之一被称为*M*/*M*/1队列，已被证明可以准确地模拟许多现实情况。它具有三个特性：'
- en: There is one server—a FIFO queue.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个服务器—一个FIFO队列。
- en: Interarrival times to the queue obey an exponential distribution with rate λ
    per minute.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到达队列的间隔时间服从每分钟率为λ的指数分布。
- en: Service times from a nonempty queue obey an exponential distribution with rate
    μ per minute.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非空队列的服务时间服从每分钟率为μ的指数分布。
- en: '[MM1Queue.java](MM1Queue.java.html) simulates an *M*/*M*/1 queue and plots
    a histogram of waiting times to standard drawing.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[MM1Queue.java](MM1Queue.java.html)模拟一个*M*/*M*/1队列，并绘制等待时间的直方图。'
- en: '*Load balancing.* [LoadBalance.java](LoadBalance.java.html) simulate the process
    of assigning *n* items to a set of *m* servers. For each item, it chooses a sample
    of *s* servers and assigns the item to the server that has the fewest current
    items.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*负载平衡。*[LoadBalance.java](LoadBalance.java.html)模拟将*n*个项目分配给一组*m*个服务器的过程。对于每个项目，它选择*s*个服务器的样本，并将项目分配给当前项目最少的服务器。'
- en: Exercises
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Add a method `isFull()` to [ArrayStackOfStrings.java](ArrayStackOfStrings.java.html).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[ArrayStackOfStrings.java](ArrayStackOfStrings.java.html)中添加一个`isFull()`方法。
- en: Write a filter [Reverse.java](Reverse.java.html) that reads strings one at a
    time from standard input and prints them to standard output in reverse order.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器[Reverse.java](Reverse.java.html)，从标准输入逐个读取字符串，并以相反顺序打印到标准输出。
- en: Write a stack client [Parentheses.java](Parentheses.java.html) that reads a
    string of parentheses, square brackets, and curly braces from standard input and
    uses a stack to determine whether they are properly balanced. For example, your
    program should print `true` for `[()]{}{[()()]()}` and false for `[(])`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个栈客户端[Parentheses.java](Parentheses.java.html)，从标准输入中读取一串括号、方括号和大括号，使用栈确定它们是否平衡。例如，你的程序应该对`[()]{}{[()()]()}`打印`true`，对`[(])`打印`false`。
- en: What does the following code fragment print when `n` is 50? Give a high-level
    description of what the code fragment does when presented with a positive integer
    *n*.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`n`为50时，以下代码片段会打印什么？给出当给定正整数*n*时，代码片段的高级描述。
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Solution*: prints the binary representation of `n` (`110010` when n is 50).'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：打印`n`的二进制表示（当n为50时为`110010`）。'
- en: What does the following code fragment do to the queue `queue`?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段对队列`queue`做了什么？
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Solution*: reverses the order of the strings in the queue.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：颠倒队列中字符串的顺序。'
- en: Add a method `peek()` to [Stack.java](Stack.java.html) that returns the most
    recently inserted element on the stack (without removing it).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[Stack.java](Stack.java.html)添加一个名为`peek()`的方法，该方法返回栈中最近插入的元素（不移除）。
- en: Add a method `size()` to both [Queue.java](Queue.java.html) and [Stack.java](Stack.java.html)
    that returns the number of items in the collection.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[Queue.java](Queue.java.html)和[Stack.java](Stack.java.html)都添加一个名为`size()`的方法，该方法返回集合中的项目数。
- en: Write a filter [InfixToPostfix.java](InfixToPostfix.java.html) that converts
    an arithmetic expression from infix to postfix.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器[InfixToPostfix.java](InfixToPostfix.java.html)，将中缀算术表达式转换为后缀表达式。
- en: Write a program [EvaluatePostfix.java](EvaluatePostfix.java.html) that takes
    a postfix expression from standard input, evaluates it, and prints the value.
    (Piping the output of your program from the previous exercise to this program
    gives equivalent behavior to [Evaluate.java](Evaluate.java.html).)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[EvaluatePostfix.java](EvaluatePostfix.java.html)，从标准输入中获取后缀表达式，对其进行评估，并打印值。（将上一个练习的程序输出导入到此程序中，可实现与[Evaluate.java](Evaluate.java.html)相同的行为。）
- en: Develop a data type [ResizingArrayQueueOfStrings.java](ResizingArrayQueueOfStrings.java.html)
    that implements a queue wit ha fixed-length array in such a way that all operations
    take constant time.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个数据类型[ResizingArrayQueueOfStrings.java](ResizingArrayQueueOfStrings.java.html)，以固定长度数组实现一个队列，使得所有操作都需要常数时间。
- en: Modify [MM1Queue.java](MM1Queue.java.html) to make a program [MD1Queue.java](MD1Queue.java.html)
    that simulates a queue for which the service times are fixed (deterministic) at
    rate μ. Verify Little's law for this model.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[MM1Queue.java](MM1Queue.java.html)以创建一个程序[MD1Queue.java](MD1Queue.java.html)，模拟一个服务时间固定（确定性）为速率μ的队列。验证该模型的Little定律。
- en: Develop a class [StackOfInts.java](StackOfInts.java.html) that uses a linked-list
    representation (but no generics) to implement a stack of integers. Write a client
    that compares the performance of your implementation with`Stack<Integer>` to determine
    the performance penalty from autoboxing and unboxing on your system.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个类[StackOfInts.java](StackOfInts.java.html)，使用链表表示（但没有泛型）来实现一个整数栈。编写一个客户端，比较你的实现与`Stack<Integer>`的性能，以确定在你的系统上由于自动装箱和拆箱而产生的性能损失���
- en: Linked-List Exercises
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链表练习
- en: Suppose `x` is a linked-list node. What is the effect of the following code
    fragment?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`x`是一个链表节点。以下代码片段的效果是什么？
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Solution*: Deletes from the list the node immediately following `x`.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：从列表中删除紧随`x`之后的节点。'
- en: Write a method `delete()` that takes the first node in a linked list and an
    `int` argument `k` and deletes the `k`th node in the linked list, if it exists.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`delete()`的方法，接受链表中的第一个节点和一个`int`参数`k`，如果存在，则删除链表中的第`k`个节点。
- en: '*Solution*:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Suppose that `x` is a linked-list node. What is the effect of the following
    code fragment?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`x`是一个链表节点。以下代码片段的效果是什么？
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Solution*: Inserts node `t` immediately after node `x`.'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：在节点`x`之后立即插入节点`t`。'
- en: Why does the following code fragment not have the same effect as in the previous
    question?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下代码片段的效果与前一个问题不同？
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Solution*: When it comes time to update `t.next`, `x.next` is no longer the
    original node following `x`, but is instead `t` itself!'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：当需要更新`t.next`时，`x.next`不再是原始紧随`x`的节点，而是`t`本身！'
- en: Creative Exercises
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Josephus problem.** In the Josephus problem from antiquity, *n* people are
    in dire straits and agree to the following strategy to reduce the population.
    They arrange themselves in a circle (at positions numbered from 0 to *n*−1) and
    proceed around the circle, eliminating every mth person until only one person
    is left. Legend has it that Josephus figured out where to sit to avoid being eliminated.
    Write a `Queue` client [Josephus.java](Josephus.java.html) that takes two integer
    command-line arguments *m* and *n* and prints the order in which people are eliminated
    (and thus would show Josephus where to sit in the circle).'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**约瑟夫问题。** 在古代的约瑟夫问题中，*n*个人处于困境，并同意采取以下策略来减少人口。他们排成一个圆圈（位置编号从0到*n*−1），沿着圆圈前进，每隔m个人淘汰一个，直到只剩下一个人。传说中，约瑟夫找到了一个位置可以避免被淘汰。编写一个`Queue`客户端[Josephus.java](Josephus.java.html)，接受两个整数命令行参数*m*和*n*，并打印人们被淘汰的顺序（从而向约瑟夫展示在圆圈中应该坐在哪里）。'
- en: '**Topological sort.** You have to sequence the order of n jobs that are numbered
    0 to n-1 on a server. Some of the jobs must complete before others can begin.
    Write a program [TopologicalSorter.java](TopologicalSorter.java.html) that takes
    a command-line argument n and a sequence on standard input of ordered pairs of
    jobs (i, j), and then prints a sequence of integers such that for each pair (i,
    j) in the input, job i appears before job j. First, from the input, build, for
    each job (1) a queue of jobs that must follow it and (2) its *indegree* (the number
    of jobs that must come before it). Then, build a queue of all nodes whose indegree
    is 0 and repeatedly delete any job with a 0 indegree, maintaining all the data
    This process has many applications. For example, you can use it to model course
    prerequisites for your major so that you can find a sequence of courses to take
    so that you can graduate.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拓扑排序。** 您需要对服务器上编号为0到n-1的n个作业的顺序进行排序。有些作业必须在其他作业开始之前完成。编写一个程序[TopologicalSorter.java](TopologicalSorter.java.html)，它接受一个命令行参数n和一个有序对作业（i，j）的标准输入序列，然后打印一个整数序列，以便对于输入中的每对（i，j），作业i出现在作业j之前。首先，从输入中为每个作业构建（1）必须跟随它的作业队列和（2）其*入度*（必须在其之前的作业数）。然后，构建一个所有入度为0的节点的队列，并重复删除任何入度为0的作业，保持所有数据。这个过程有许多应用。例如，您可以用它来模拟专业课程的先修课程，以便找到一系列要修的课程，以便毕业。'
- en: '**Copy constructor for a stack.** Create a new constructor for the linked -list
    implementation of `Stack.java` so that `Stack<String> t = new Stack<String>(s)`
    makes `t` reference a new and independent copy of the stack `s`. You should be
    able to push and pop from either `s` or `t` without influencing the other.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆栈的复制构造函数。** 为`Stack.java`的链表实现创建一个新的构造函数，使得`Stack<String> t = new Stack<String>(s)`使`t`引用`Stack
    s`的一个新的独立副本。您应该能够从`s`或`t`中推送和弹出，而不会影响另一个。'
- en: '*Recursive solution*: create a copy constructor for a `Node` and use this to
    create the new stack.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*递归解决方案*: 为`Node`创建一个复制构造函数，并使用它来创建新的堆栈。'
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Non-recursive solution* (untested):'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*非递归解决方案*（未经测试）：'
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Quote.** Develop a data type [Quote.java](Quote.java.html) that implements
    the following API:![Quote API](../Images/9cab1281db9b9c77fa47205ef3834f15.png)To
    do so, define a nested class `Card` that holds one word of the quotation and a
    link to the next word in the quotation:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**引用。** 开发一个实现以下API的数据类型[Quote.java](Quote.java.html)：![引用API](../Images/9cab1281db9b9c77fa47205ef3834f15.png)为此，定义一个嵌套类`Card`，它保存引语的一个单词，并链接到引语中的下一个单词：'
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Circular quote.** Repeated the previous exercise, but use a *circular linked
    list*. In a circular linked list, each node points to its successor, and the last
    node in the list points to the first node (instead of null, as in a standard null-terminated
    linked list).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**循环引用。** 重复上一个练习，但使用*循环链表*。在循环链表中，每个节点指向其后继节点，而列表中的最后一个节点指向第一个节点（而不是null，如标准的以null结尾的链表）。'
- en: '*Solution*: [CircularQuote.java](CircularQuote.java.html)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: [CircularQuote.java](CircularQuote.java.html)'
- en: '**Reverse a linked list (iteratively).** Write a nonrecursive function that
    takes the first `Node` in a linked list as an argument, and reverses the list,
    returning the first `Node` in the result.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆转链表（迭代）。** 编写一个非递归函数，以链表中的第一个`Node`作为参数，并逆转链表，返回结果中的第一个`Node`。'
- en: '*Solution*: To accomplish this, we maintain references to three consecutive
    nodes in the linked list, `reverse`, `first`, and `second`. At each iteration
    we extract the node `first` from the original linked list and insert it at the
    beginning of the reversed list. We maintain the invariant that `first` is the
    first node of what''s left of the original list, `second` is the second node of
    what''s left of the original list, and `reverse` is the first node of the resulting
    reversed list.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 为了实现这一点，我们在链表中保持对三个连续节点的引用，`reverse`、`first`和`second`。在每次迭代中，我们从原始链表中提取节点`first`，并将其插入到逆转后的列表的开头。我们保持`first`是原始列表剩余部分的第一个节点，`second`是原始列表剩余部分的第二个节点，`reverse`是结果逆转列表的第一个节点。'
- en: '![Reverse a linked list](../Images/ac417471b9391ae85ab6fb36a55af701.png)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![逆转链表](../Images/ac417471b9391ae85ab6fb36a55af701.png)'
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Reverse a linked list (recursively).** Write a recursive function that takes
    the first `Node` in a linked list as an argument and reverses the list, returning
    the first `Node` in the result.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆转链表（递归）。** 编写一个递归函数，以链表中的第一个`Node`作为参数，并逆转链表，返回结果中的第一个`Node`。'
- en: '*Solution*: Assuming the linked list has n elements, we recursively reverse
    the last n-1 elements, then append the first element to the end.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 假设链表有n个元素，我们递归地颠倒最后n-1个元素，然后将第一个元素附加到末尾。'
- en: '[PRE16]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Listing files.** A folder is a list of files an folders. Write a program
    [Directory.java](Directory.java.html) that takes the name of a folder as a command
    line argument and prints all of the files contained in that folder, with the contents
    of each folder recursively listed (indented) under that folder''s name.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列出文件。** 一个文件夹是文件和文件夹的列表。编写一个程序[Directory.java](Directory.java.html)，它以文件夹的名称作为命令行参数，并打印该文件夹中包含的所有文件，每个文件夹的内容递归列出（缩进）在该文件夹的名称下面。'
- en: Web Exercises
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: 'Write a recursive function that takes as input a queue, and rearranges it so
    that it is in reverse order. Hint: `dequeue()` the first element, recursively
    reverse the queue, and the enqueue the first element.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归函数，以队列作为输入，并重新排列队列，使其顺序颠倒。提示：`dequeue()`第一个元素，递归地颠倒队列，然后将第一个元素入队。
- en: Add a method `Item[] multiPop(int k)` to `Stack` that pops k elements from the
    stack and returns them as an array of objects.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Stack`添加一个方法`Item[] multiPop(int k)`，从堆栈中弹出k个元素，并将它们作为对象数组返回。
- en: Add a method `Item[] toArray()` to `Queue` that returns all N elements on the
    queue as an array of length N.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Queue`添加一个方法`Item[] toArray()`，将队列中的所有N个元素作为长度为N的数组返回。
- en: What does the following code fragment do?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段做什么？
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Fibonacci*'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*斐波那契*'
- en: What data type would you choose to implement an "Undo" feature in a word processor?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文字处理器中，您会选择哪种数据类型来实现“撤销”功能？
- en: Suppose you have a single array of size N and want to implement two stacks so
    that you won't get overflow until the total number of elements on both stacks
    is N+1\. How would you proceed?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您有一个大小为N的单个数组，并希望实现两个堆栈，以便在两个堆栈上的元素总数为N+1之前不会溢出。您将如何操作？
- en: Suppose that you implemented `push` in the linked list implementation of `StackList`
    with the following code. What is the mistake?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您在`StackList`的链表实现中使用以下代码实现了`push`。错误在哪里？
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Solution*: By redeclaring `first`, you are create a new local variable named
    `first`, which is different from the instance variable named `first`.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* 通过重新声明`first`，您创建了一个名为`first`的新局部变量，它与名为`first`的实例变量不同。'
- en: '**Stack with one queue.** Show how to implement a stack using one queue. *Hint:*
    to delete an item, get all of the elements on the queue one at a time, and put
    them at the end, except for the last one which you should delete and return.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用一个队列实现堆栈。** 展示如何使用一个队列实现堆栈。*提示:* 要删除一个项目，逐个获取队列中的所有元素，并将它们放在末尾，除了最后一个应删除并返回。'
- en: '**Listing files with a stack.** Write a program that takes the name of a directory
    as a command line argument, and prints out all of the files contained in this
    directory and any subdirectories. Also prints out the file size (in bytes) of
    each file. Use a stack instead of a queue. Repeat using recursion and name your
    program [DirectoryR.java](DirectoryR.java.html). Modify [DirectoryR.java](DirectoryR.java.html)
    so that it prints out each subdirectory and its total size. The size of a directory
    is equal to the sum of all of the files it contains or that its subdirectories
    contain.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用堆栈列出文件。** 编写一个程序，将一个目录的名称作为命令行参数，并打印出该目录及其子目录中包含的所有文件。同时打印出每个文件的文件大小（以字节为单位）。使用堆栈而不是队列。使用递归重复，并将程序命名为[DirectoryR.java](DirectoryR.java.html)。修改[DirectoryR.java](DirectoryR.java.html)，以便打印出每个子目录及其总大小。目录的大小等于其包含的所有文件或其子目录包含的所有文件的总和。'
- en: '**Stack + max.** Create a data structure that efficiently supports the stack
    operations (pop and push) and also return the maximum element. Assume the elements
    are integers or reals so that you can compare them. *Hint:* use two stacks, one
    to store all of the elements and a second stack to store the maximums.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆栈 + 最大值。** 创建一个数据结构，有效支持堆栈操作（弹出和推入），并返回最大元素。假设元素是整数或实数，以便您可以比较它们。*提示:* 使用两个堆栈，一个用于存储所有元素，另一个用于存储最大值。'
- en: '**Tag systems.** Write a program that reads in a binary string from the command
    line and applies the following (00, 1101) tag-system: if the first bit is 0, delete
    the first three bits and append 00; if the first bit is 1, delete the first three
    bits and append 1101\. Repeat as long as the string has at least 3 bits. Try to
    determine whether the following inputs will halt or go into an infinite loop:
    10010, 100100100100100100\. Use a queue.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标签系统。** 编写一个程序，从命令行读取一个二进制字符串，并应用以下（00, 1101）标签系统：如果第一个位为0，则删除前三位并追加00；如果第一个位为1，则删除前三位并追加1101。只要字符串至少有3位，就重复此过程。尝试确定以下输入是否会停止或进入无限循环：10010、100100100100100100。使用队列。'
- en: '**Set of integers.** Create a data type that represents a set of integers (no
    duplicates) between 0 and n-1\. Support add(i), exists(i), remove(i), size(),
    intersect, difference, symmetricDifference, union, isSubset, isSuperSet, and isDisjointFrom.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整数集合。** 创建一个表示0到n-1之间的整数集合（无重复项）的数据类型。支持add(i)、exists(i)、remove(i)、size()、intersect、difference、symmetricDifference、union、isSubset、isSuperSet和isDisjointFrom。'
- en: '**Indexing a book.** Write a program that reads in a text file from standard
    input and compiles an alphabetical index of which words appear on which lines,
    as in the following input. Ignore case and punctuation. Similar to FrequencyCount,
    but for each word maintain a list of location on which it appears.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为书编制索引。** 编写一个程序，从标准输入读取文本文件，并编制一个按字母顺序排列的索引，显示哪些单词出现在哪些行，如以下输入所示。忽略大小写和标点符号。类似于FrequencyCount，但对于每个单词，维护一个出现位置的列表。'
- en: '**Copy constructor for a resizing array implementation of a stack.** Add a
    copy constructor to [ArrayStackOfStrings.java](ArrayStackOfStrings.java.html)'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整大小数组实现堆栈的复制构造函数。** 在[ArrayStackOfStrings.java](ArrayStackOfStrings.java.html)中添加一个复制构造函数'
- en: '**Reorder linked list.** Given a singly linked list x1 -> x2 -> ... -> x_2n
    containing 2n nodes, rearrnage the nodes to be x1 -> x2n -> x2 -> x_2n-1 -> x3
    -> .... *Hint*: break the linked list in half; reverse the order of the nodes
    in the second linked list; merge the two lists together.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重新排序链表。** 给定包含2n个节点的单链表x1 -> x2 -> ... -> x_2n，重新排列节点为x1 -> x2n -> x2 ->
    x_2n-1 -> x3 -> .... *提示:* 将链表分成两半；颠倒第二个链表中节点的顺序；将两个列表合并在一起。'
