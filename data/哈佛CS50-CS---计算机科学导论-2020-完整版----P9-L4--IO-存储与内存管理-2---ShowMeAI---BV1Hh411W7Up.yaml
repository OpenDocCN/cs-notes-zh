- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P9：L4- IO、存储与内存管理 2 - ShowMeAI - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P9：L4- IO、存储与内存管理 2 - ShowMeAI - BV1Hh411W7Up
- en: hardware，recall so when you're done with memory，it should be your best practice。to
    free it afterward as well，and the opposite of malloc is just a，function called
    free。which takes as its input whatever the，output of malloc was and recall that
    the，malloc。is just the address of the first byte of，memory that it is allocated
    for you so。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件，记住，当你完成内存的使用时，最好的做法是，随后释放它，对应于malloc的相反操作是一个叫做free的函数。它的输入是malloc的输出，记住malloc就是分配给你的内存的第一个字节的地址。
- en: if it you ask it for four bytes like i，did a few lines ago with malloc。you're
    going to get back the address of，the first of those bytes。and it's up to you to
    remember how many，bytes you asked for，in the case of free all you have to do。is
    tell free，malloc，gave you so if you stored that address，as i did in this variable
    called t。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我几行前用malloc请求四个字节，那么你会得到这些字节的第一个地址。你需要记住你请求了多少字节，在free的情况下，你只需告诉free，malloc给了你什么，因此如果你像我一样将那个地址存储在变量t中。
- en: it suffices when you're done with that，memory just called free。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_1.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成那段内存的使用时，只需调用free。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_1.png)
- en: t and the computer will go about，freeing up that memory for you and you。might
    very well get it back later on，but at least your computer won't run out，of memory
    as quickly。because it can now reuse that space for，something else all right let
    me go ah**d。then and propose that we draw a picture，of this now new programs in
    memory。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: t和计算机会为你释放那段内存，你也许会在之后再得到它，但至少你的计算机不会那么快用完内存，因为它现在可以将那段空间重用于其他用途。好吧，让我继续并提议我们现在绘制一幅图，展示这个新的内存中的程序。
- en: where we copied things so recall this is，where we left off before when comparing。two
    strings if this was，s and s was pointing to h i up，exclamation point in lower
    case。this new version of my code in copy。c，notice still gives me another pointer，hasn't
    changed。but i call malloc now and malloc is，going to return to me some new chunk
    of，is。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们复制的内容是在这里，这是我们之前比较时的停留点。两个字符串如果这是，s，而s指向h i，小写的感叹号。这是我在复制中的新版本代码。
- en: but malloc's return value is going to be，the address of，the first byte of that
    memory so for。instance ox456 or whatever it is，and the subsequent bytes are going
    to be，increasing by one。byte at a time ox457 ox458 ox4，so what is ultimately stored
    in t when i。assign it the return value of malloc，it's whatever that address is
    again i。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但malloc的返回值将是那段内存的第一个字节的地址，例如ox456或其他，后续的字节会一个接一个地递增。ox457 ox458 ox4，所以当我将malloc的返回值赋给t时，最终存储在t中的就是那个地址。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_3.png)'
- en: but again，we're kind of past that like that's very，30 minutes ago let's now
    focus on just。the abstraction that is a pointer，pointer is just an arrow pointing
    from，the variable。to the actual location in memory so now，if i go about copying
    s into，my for loop。what happens well i'm copying the h over，from s into t，i'm
    copying the i over from s into t the。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们再回过头来看，这已经是30分钟前的事了，现在我们关注的只是指针的抽象，指针就是一个指向变量的箭头，指向内存中的实际位置。所以现在，如果我开始在我的for循环中复制s，会发生什么呢？我将h从s复制到t，将i从s复制到t。
- en: exclamation point，from s into t and then lastly the，terminating null character。from
    s into t so the picture is now，fundamentally different，t is not pointing at the
    same thing it's。pointing at its own chunk of memory，that has now one step at a
    time，been uh duplicating whatever was。and i，as humans would consider presumably
    to，be a proper，copy of the program any questions then。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号，从s复制到t，最后是终止的空字符。从s复制到t，所以现在的图在根本上是不同的，t不再指向相同的东西，它指向自己的那一块内存，现在通过一步一步的方式，复制了所有内容，而我，作为人类，会认为这显然是一个合适的程序副本，有什么问题吗？
- en: on what we've just done by introducing，malloc and free，the first of which allocates
    memory and。gives you the address of the first，byte of memory that you can now
    use the。latter of which hands it back，to your operating system and says i'm，done
    with this。it can now be reused for something else，some other variable，maybe down
    the road if our program were。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们刚刚做的事情，介绍了malloc和free，前者分配内存并给你可以使用的第一字节的地址，后者将其交还给操作系统并说我完成了它。现在可以被重用于其他变量，也许在我们的程序后续中。
- en: longer brian any questions or confusion，someone asked even if you're using stir。someone
    asked even if you're using stir，copy to copy the string。instead of copying the
    characters one at，a time yourself do you still need to，free the memory。good question
    even if you're using stir，copy you do need to still use free。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更长的布莱恩，任何问题或困惑，有人问即使你在使用`strcpy`。有人问即使你在使用`strcpy`来复制字符串。代替自己逐个字符复制，是否仍然需要，释放内存。好问题，即使你在使用`strcpy`，你仍然需要使用`free`。
- en: yes any time you use malloc henceforth，you must use free any time you use，malloc
    you must use。free in order to free up that memory，stir copy is copying the contents
    of one。chunk of memory to the other，it is not allocating or managing that。memory
    for you it is just implementing，essentially，that for loop and it's perhaps time
    to。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，每次使用`malloc`后，你必须使用`free`，每次使用`malloc`时，你必须使用。`free`来释放内存，`strcpy`是将一块。内存的内容复制到另一块，它并不为你分配或管理那。块内存，它只是基本上实现，那个循环，也许是时候。
- en: where i can take off another training，wheel verbally it turns out that。getstring
    all this time is kind of，magical like one of the things that。getstring does from
    the cs50 library，after all，when we the staff wrote getstring years。are going to
    be，this year we have no idea what sentences，you're going to type。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在另外的训练中卸下另一只辅助轮，口头上结果表明。`getstring`一直以来都是一种，有点神奇的东西，因为`getstring`来自`cs50`库，毕竟，当我们工作人员多年前编写`getstring`时。我们没有想到你将输入什么句子。
- en: what text you're going to analyze for a，program like readability。so we had to
    implement getstring in such，a way that you can type as few or as，want。and we will
    make sure there's enough，memory for that string，so getstring underneath the hood
    if you。look at the code we the staff，malloc，and we call malloc uh in order to
    get。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你打算分析什么文本，以便用于像`readability`这样的程序。因此，我们必须以这样的方式实现`getstring`，让你可以输入尽可能少的字符，或根据需要。我们将确保有足够的内存来存储那个字符串，因此，如果你。查看代码，我们的工作人员，调用`malloc`，我们调用`malloc`以获得。
- en: enough memory to fit that string，and then what the cs50 library is also。secretly
    doing is it is also calling，free for you，there's essentially a fancy way where。you
    can write a program that as soon as，maine is about to quit。or return to your blinking
    prompt some，special code we wrote，of the memory that，don't。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确保有足够的内存来适应那个字符串，然后`cs50`库还在。暗中为你调用`free`，实际上有一种花哨的方式，你可以编写一个程序，一旦`main`即将退出。或返回到你的闪烁提示，一些我们写的特殊代码，处理不再使用的内存。
- en: uh run out of memory uh because of us，but you all when using malloc will have，to
    call free。because the library is no not gonna do，today，and next week and beyond
    is to stop。using the cs50 library ultimately，all together so that you manage things，yourselves。any
    other questions here，any other questions here，no all right well let's it would
    be。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 呃，耗尽了内存，呃，因为我们，但你们在使用`malloc`时都必须调用`free`。因为这个库不会做到，今天、下周及以后要停止。使用`cs50`库，最终，完全停止，以便你自己管理。还有其他问题吗？还有其他问题吗？没有，好吧，让我们。
- en: unfair i think if we introduce all these，fancy new techniques but don't。necessarily
    provide you with any sort of，tools with which to，fancy code。or solve problems
    now that are related，to memory and thankfully，there are programs by which you
    can。in addition to，printf that function and help 50 and，generally。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为不公平，如果我们引入所有这些花哨的新技术却不。必要地提供任何工具来处理，花哨的代码。或者解决现在与内存相关的问题，值得庆幸的是，有程序可以。除了`printf`之外，帮助你完成函数和50，以及一般来说。
- en: this program and it's really the last of，see，is called valgrind and this is
    a program。that exists in cs50 ide but it exists on，macs and pcs and，linux computers
    anywhere where you can。run it on your own code to detect，if you're doing anything
    wrong with。memory what might you do wrong with，memory well previously remember
    i。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序，它实际上是最后一个，你看到的，是叫做`valgrind`的程序。这个程序存在于`cs50 ide`中，但它也存在于，Mac和PC以及，Linux计算机上，任何地方你可以。运行你自己的代码来检测，是否在内存方面做错了什么。你可能会在内存方面做错什么？好吧，之前我记得我。
- en: triggered that segmentation fault i，touched memory that i should not。valgrind
    is a tool that can help you，figure out where，did you touch memory that you shouldn't。have
    so is to focus your own human，might be buggy，valgrand can also detect if you forget。to
    call free，if you call malloc one or more times but，of times，valgrind is a program
    that can notice。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 触发了那个分段错误，我触碰了不该触碰的内存。`valgrind`是一个可以帮助你，找出你触碰了不该触碰的内存的位置的工具。因此，专注于你自己的人，可能有漏洞，`valgrind`还可以检测你是否忘记。调用`free`，如果你调用了`malloc`一次或多次，但是，`valgrind`是一个可以察觉的程序。
- en: that and tell you that you have what's，called a memory leak and indeed this
    is。germane to our own macs and pcs again if，you've been using your mac or pc or。sometimes
    even your phone，for a long long time and maybe running，of tab。browser tabs open
    lots of different，programs open at once，your mac or pc might very well have。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样告诉你你有什么，称为内存泄漏，实际上这与我们自己的mac和pc相关。如果你长时间使用你的mac或pc，或者有时候甚至你的手机，打开了很多浏览器标签，很多不同的程序同时打开，你的mac或pc可能确实已经。
- en: begun to slow to a crawl like it might，be annoying if not impossible to use。because
    everything is so darn slow that，may very well be，because one or more of the programs。you're
    using has some bug in it，memory，and never got around to calling free，they。didn't
    expect you to have so many，windows open but valgrind can detect。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开始慢得令人抓狂，可能使用起来很烦人，甚至不可能，因为一切都如此缓慢，可能是因为你正在使用的一个或多个程序在内存中有一些错误，从未调用释放。它们没有预料到你会打开这么多窗口，但valgrind可以检测到。
- en: errors like that and honestly some of，you if you're like me you probably you，might
    very well have。10 20 50 different tab browser tabs open，at once thinking like
    oh i'm going to。come back to that someday even though we，never do，each of those
    tabs takes up memory。literally anytime you open a browser tab，think of it really
    as。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的错误，老实说，如果你像我一样，可能你，可能会有10、20、50个不同的浏览器标签页同时打开，想着哦，我总有一天会回来查看，尽管我们从未这样做。每个标签页占用内存，实际上每当你打开一个浏览器标签时，想想它真的是。
- en: chrome or or edge or firefox or whatever，you're using，underneath the hood they're
    probably。calling a function on mac os or windows，like malloc，to give you more
    memory to contain the。contents of that web page temporarily，and if you keep opening
    more and more。browser tabs it's like calling malloc，malloc malloc，eventually you're
    going to run out and。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你使用的是chrome、edge、firefox还是其他的，在后台，它们可能正在调用mac os或windows上的一个函数，比如malloc，给你更多内存来临时容纳那个网页的内容，如果你继续打开越来越多的浏览器标签，就像调用malloc，malloc，malloc，最终你会耗尽内存。
- en: can kind of，temporarily remove things from memory to，memory，but eventually something's
    going to。break and it might very well be your，user experience when things get
    so slow。that you literally have to quit the，program or maybe even reboot your。computer
    so how do we use valgrind well，program，that doesn't do anything useful but。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以暂时从内存中移除一些东西到内存，但最终某些东西会崩溃，可能会影响你的用户体验，当事情变得如此缓慢，以至于你真的不得不退出程序，或者甚至重启你的电脑。那么我们如何使用valgrind呢？好吧，程序，什么也不做的有用的东西，但。
- en: demonstrates multiple memory related，mistakes i'll call this file memory。c。i'm
    going to go ah**d and open up the，file memory。c and include at the top，io。h and
    then i'm going to also，preemptively include standard lib。h，which recall is where
    malloc is。int main void and i'm going to keep this，one simple i'm going to go
    ah**d and，just give myself。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了多个与内存相关的错误，我将这个文件命名为memory.c。我将去**d并打开文件memory.c，在顶部包含io.h，然后我还会提前包含标准库lib.h，记住malloc就在这里。int
    main void，我将保持这个简单，我会去**d，给自己。
- en: a whole bunch of integer so this is，actually kind of cool it turns out。that
    uh well let's go ah**d yeah i can，do this let's go ah**d and do this。char star
    s gets malloc and let me go，ahead and give myself，ahead and，actually let's。going
    to go ah**d and say，s bracket 0 equals 72，s bracket 1 actually i'll just do this。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一大堆整数，这其实有点酷，结果是，嗯，我们继续，好的，我可以这样做，让我们继续。char star s获取malloc，让我先给自己，好的，实际上，让我们去**d并说，s括号0等于72，s括号1，实际上我就这样做。
- en: manually let's do，h let's do i，let's do our usual exclamation point and，then
    just for good measure s。bracket three gets quote unquote，backslash zero like this
    is the，very manual way of actually。this is the very manual way of actually，building
    up a string but let me，introduce a mistake，bytes。even though i clearly need a
    fourth for，that terminating null character and。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 手动让我们做，h让我们做i，让我们做我们习惯的感叹号，然后为了保险起见加上s。括号三个引用，反斜杠零就像这样，实际上这是非常手动的方式。这实际上是非常手动的方式，构建一个字符串，但让我引入一个错误，字节。尽管我显然需要一个第四个来结束空字符。
- en: notice too the absence of free，calling free，now i'm going to go ah**d and compile。this
    program uh make memory，okay it compiles okay so that's good dot，slash memory。okay
    nothing happens but that kind of，makes sense because i didn't tell it to。do anything
    just for kicks let's print，out that string，recompile。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意没有释放，调用释放，现在我要去**d并编译。这个程序，嗯，内存，好吧它编译成功了，所以这很好，点，斜杠内存。好吧，什么也没发生，但这似乎是合理的，因为我没有告诉它去做任何事情。为了好玩，让我们打印出那个字符串，重新编译。
- en: memory still compiles let me run dot，slash memory，okay it seems to work so at
    first glance。you might be really proud of yourself，you've written another correct
    program。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_5.png)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内存仍然可以编译，让我运行 `dot slash memory`，好吧，似乎可以工作，所以乍一看。你可能会非常自豪，你又写了一个正确的程序。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_5.png)
- en: seems to pass check 50 you submit you go，about your day and you're very，disappointed
    some days later。when you realize damn it uh i did not，get full credit on this
    because there's，actually a latent。in your code，that you don't necessarily see
    visually，you don't necessarily experience when。running it yourself，but eventually
    there might be an error，when running it enough times。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎通过了检查 50，你提交了，然后继续你的日子，但几天后你非常失望。因为你意识到该死，我在这上没有得到满分，因为实际上你的代码中有一个潜在的问题，你不一定能在视觉上看到，也不一定在运行时体验到，但最终在足够多次运行时可能会出现错误。
- en: eventually a computer might notice that，you're doing something wrong and。thankfully
    tools exist like valgrind，that can allow you to detect that so let。me go ah**d
    and just increase the size，of my terminal window here。and let me go ah**d and
    run valgrind，on dot slash memory so it's just like，debug 50。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，计算机可能会注意到你做错了什么。幸运的是，像 valgrind 这样的工具可以让你检测到这一点，所以让我继续，**增加我的终端窗口大小**。让我继续并在
    `dot slash memory` 上运行 valgrind，就像 debug 50 一样。
- en: instead of running debug 50 and then dot，slash whatever the program is。you run
    valgrind dot slash memory this，one unfortunately is only a command line。interface
    there's no graphical user，interface like debug 50，and honestly it's a hideous
    sequence of。output like this should，overwhelm you at first glance there's，crazy
    crypticness here。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是运行 debug 50 然后 `dot slash` 无论程序是什么。你运行 valgrind `dot slash memory`，不幸的是这个只有命令行界面，没有像
    debug 50 那样的图形用户界面，老实说，这是一串可怕的输出，乍一看可能会让你感到不知所措。
- en: it's not the best design program it，really was meant for the most，comfortable
    people。but it there are some useful tidbits we，can take away from it as always
    let me。scroll all the way to the top，to the very first line of output and。i'll
    draw your attention to a couple of，things that will start to jump out to。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最好的设计程序，真的只是为了最舒适的人。虽然如此，我们仍然可以从中提取一些有用的东西，像往常一样让我滚动到输出的最顶部，指引你注意几个开始跳出来的事情。
- en: you and help 50 can help you with this，if you're confused by valgrind's output。rerun
    it but put help 50 at the，beginning and just like i will do now，verbally so can
    help。help you notice the important things in，this crazy mess of output，this line
    here，line 10，of memory。c so we'll look at that in a，moment，if i scroll down further
    invalid read of，size 1。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 valgrind 的输出感到困惑，**帮助 50** 可以帮助你。重新运行它，但在开头放上帮助 50，就像我现在要做的那样，口头上可以帮助你。帮助你注意到这个混乱输出中的重要内容，这一行，这里是第
    10 行内存。我们稍后会看一下，如果我继续向下滚动，发现大小为 1 的无效读取。
- en: and that also seems to be on here it，looks like on line 11 of memory。c。and then
    if i keep scrolling keep，scrolling keep scrolling，blocks，whatever that is but。three
    bytes in one block one blocks are，definitely lost，and then down here leak summary。definitely
    lost three bytes in one，blocks，incidentally one blocks obviously not。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这似乎也在这里，看起来在内存的第 11 行。如果我继续滚动，继续滚动，继续滚动，块，无论那是什么，但。在一个块中有三字节，显然有一个块是丢失的，然后在这里泄漏总结。显然丢失了一个块中的三字节。
- en: correct grammar this is what happens，when your program doesn't have an if，condition
    that checks。if the number is one or positive or zero，you could fix this grammatically。honestly
    with a simple if condition，they did not when writing this program，years ago so
    there's。two or three mistakes here one is some，kind of invalid read or write。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的语法，这就是当你的程序没有一个检查条件的 if 时发生的。如果数字是 1、正数或 0，你可以用一个简单的 if 条件修复这个问题。老实说，他们在几年前编写这个程序时并没有这样做，所以这里有两三个错误，一个是某种无效的读取或写入。
- en: and another is this leak well what is a，value，a read just refers to reading
    or using。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_7.png)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是这个泄漏，好吧，值是什么，读取只是指读取或使用。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_7.png)
- en: line 10。if i scroll back down to my code and，look on line 10，this was an invalid
    right invalid right。well why is it invalid，well per today's definition if you
    are，allocating three，bite。the second bite and the third bite but，you have no business
    touching the fourth。bite if you've only asked for three，this is like a small scale
    version of。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第10行。如果我向下滚动回我的代码，查看第10行，这个是无效的右边无效。好吧，为什么它无效呢？根据今天的定义，如果你分配了三个字节，第二个字节和第三个字节，但你没有理由去接触第四个字节，如果你只要求三个，这就像一个小规模的版本。
- en: the a very adventurous and inappropriate，like 10，000 bytes away even looking
    one byte。away is a potential bug and can cause a，program to crash，meanwhile line
    11 is also problematic。which is an invalid read because now，you're saying go print
    out。this string but that string contains a，memory address that you should not
    have。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 非常冒险和不当，像是10,000字节远，即使是看起来一字节远也是潜在的bug，并且可能导致程序崩溃。同时，第11行也是有问题的，这是一个无效的读取，因为现在你说去打印这个字符串，但那个字符串包含了你不应该有的内存地址。
- en: touched in the first place，and the memory leak the third problem，stems from
    the fact。that i didn't free that memory so again，it'll take some practice and
    experience。some mistakes of your own to sort of，me fix，the first two like this
    let me just give。myself four bytes，and let me fix the second one or the，third
    one really。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先触碰的，以及内存泄漏，第三个问题源于我没有释放那块内存。因此，它需要一些练习和经验，以及你自己的错误来修正。让我先给自己四个字节，让我修复第二个或第三个问题。
- en: by freeing s at the very end because，again any time you use malloc。you must
    use free let me go ah**d and，recompile memory。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_9.png)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在最后释放s，因为再次，每当你使用malloc时，你必须使用free，让我去重新编译memory。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_9.png)
- en: seems to compile let me rerun it still，works the same visually。but now let's
    rerun valgrind on it and，valgrind，dot slash memory enter the output's。still going
    to look pretty cryptic，but notice all heap blocks were freed。whatever that means
    no leaks are，possible it doesn't really get more。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎可以编译，让我重新运行，它在视觉上仍然是相同的。但现在让我们在它上面重新运行valgrind，valgrind，点斜杠memory，输出仍然看起来非常神秘，但注意所有堆块都被释放。无论那意味着什么，没有泄漏是可能的，它确实没有更。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_11.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_11.png)'
- en: explicit than that that's a good thing，and if i scroll up i see no mention of。those
    invalid reads or writes，so starting with this week's problem set，and next week's
    in c。not only you're going to want to use，50 and，check 50 but even if you think
    your。code's right the output looks right，you might have a latent bug and even。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，这是好事，如果我向上滚动，我没有看到任何无效读取或写入的提及。所以从本周的问题集开始，以及下周的C语言问题集，你不仅希望使用50并检查50，即使你认为你的代码是正确的，输出看起来正确，你可能还有一个潜在的错误。
- en: when your programs are small they might，not crash the computer they might not。cause
    that segmentation fault，eventually they will and you do want to。use tools like
    this to chase down，can happen，and what might happen well let me go，ahead and reveal。an
    example here that presents some code，that's a little dangerous。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序很小的时候，它们可能不会崩溃计算机，它们可能不会导致那种分段故障，最终它们会，而你确实希望使用这样的工具来追查可能发生的事情。让我去揭示一个示例，这里有一些代码是有点危险的。
- en: so here for instance is an example where，i'm declaring at the top of the function。uh
    int star x and in star y so what does，just means，give me a pointer to an integer
    called x。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_13.png)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个示例，我在函数顶部声明，uh int star x和int star y。那么这仅仅意味着，给我一个指向名为x的整数的指针。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_13.png)
- en: put another way，give me a variable called x that i can，store the address of
    an。int in give me a variable called y that，i can store the address of another
    int。in but notice what i am not doing on，these first two lines i'm not actually，assigning
    them a value。until line three on line three even，though this is weird this is
    not how，before。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，给我一个名为x的变量，我可以存储一个int的地址；给我一个名为y的变量，我可以存储另一个int的地址。但注意，在前两行我实际上并没有给它们赋值，直到第三行，尽管这很奇怪，这并不是之前的方式。
- en: there's no reason that you can't use，malloc，size of，an integer size of is new
    it's just an。operator in c，that tells you the size of a data type，like a size
    of an int。so maybe you forgot that an int is four，and indeed an inch is usually
    four but。not always four in all systems，so sizeofint just makes sure that it。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由你不能使用**malloc**、**sizeof**，**sizeof**是新的，它只是C语言中的一个运算符，告诉你数据类型的大小，比如**int**的大小。所以也许你忘了**int**是**四个字节**，而实际上**int**通常是**四个字节**，但并不总是每个系统都是四个字节，所以**sizeof
    int**只是确保它。
- en: will always give you the right answer，whether you're using a modern computer，or
    an old one。so this just means really allocate four，bytes to me on a modern system。and
    it stores the address of the first，byte in x，would someone mind translating to
    sort。of layman's terms，what is star x equal 42 doing，star again is the dereference
    operator。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是在使用现代计算机，还是旧计算机，它总会给你正确的答案。因此，这只是意味着在现代系统上为我分配**四个字节**，并存储**x**中第一个字节的地址。有人能翻译成普通话吗，**star
    x = 42**是在做什么，**star**是解除引用操作符。
- en: it means go to the address，a verbal，comment what star x equals 42，is doing brian
    would you mind。how would you describe what that line is，how would you describe
    what that line is，doing。yeah so sophia suggested that at that，address we are going
    to place 42。perfect at that address put 42，equivalently go to that address in
    x。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着去到地址，一个口头评论**star x = 42**在做什么，布赖恩你介意吗？你会如何描述那一行在做什么？是的，索非亚建议在那个地址我们将放置**42**。完美，在那个地址放**42**，同样去那个地址**x**。
- en: and put the number 42 there it's like，going to brian's mailbox and putting the，42
    in his mailbox。instead of what we previously had there，which was the number 50。how
    about this next fifth line star y，equals 13。brian could you uh verbalize someone。else
    what does star y，equals 13 do for us and it's not an，accident that 13。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 把**42**放在那里就像去布赖恩的邮箱，把**42**放进他的邮箱，而不是我们之前放的数字**50**。接下来的第五行**star y = 13**，布赖恩，你能为我们口头解释一下吗？**star
    y = 13**对我们有什么作用，**13**不是一个意外。
- en: tends to be unlucky peter says put 13，at the address y good put 13 at the。address
    in y or put another way，go to the address in y and put 13 there。but there's a
    logical problem here，what is in y if i rewind，don't initially。and i don't eventually
    at least with x，even though i didn't give it a value。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得说倾向于不幸，将**13**放在地址**y**，在地址**y**放**13**，或者换句话说，去地址**y**并把**13**放在那里。但是这里有一个逻辑问题，如果我倒回去，**y**里是什么，如果我最初不这样做。即便我没有给**x**赋值，我最终还是没有赋值。
- en: when declaring it up here as a variable，i eventually got around to storing in
    it。the actual address now just to be really，program，check for null just in case
    anything，problem。it is a more damning problem that i，haven't even given，y a value
    and here's where we can reveal。one other detail about a computer，thus far we've
    been taking for granted。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当在这里声明它作为一个变量时，我最终开始存储实际的地址。现在只是为了确保程序在检查**null**以防有什么问题。更严重的问题是我甚至没有给**y**赋值，这里我们可以揭示关于计算机的一个其他细节，到目前为止我们一直在理所当然地认为。
- en: that you and i almost always initialize，a char，an int a string we literally
    type it out。into the program itself so that it's，there when we want it，but if
    we consider this picture here。which is now just a physical incarnation，of some
    of the contents of your，computer's memory。playfully labeled with a lot of oscar，the
    grouches，this is because you should never trust。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你和我几乎总是初始化一个**char**、一个**int**和一个**string**，我们字面上在程序中输入它，以便在需要时它就在那儿。但是如果我们考虑这里的这个图像，它现在只是你计算机内存某些内容的物理体现，幽默地贴上了很多**奥斯卡·怪兽**的标签，这是因为你永远不应该信任。
- en: the contents of your computer's memory，there，there's a term of art in programming。called
    garbage values，if you yourself have not put a value，somewhere in memory you should
    assume to。be safe that it is a quote-unquote，garbage value，two an a，and b a c
    you just don't know what it is。because if your program is running，over time and
    you're calling functions，calling other。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存中的内容，有一个编程术语叫做**垃圾值**，如果你自己没有放入一个值，内存中的某个地方你应该安全地假设它是一个所谓的**垃圾值**，**a**、**b**和**c**你根本不知道它是什么。因为如果你的程序在运行，随着时间的推移，你在调用函数，调用其他。
- en: functions and functions are returning，these values in your computer's memory。are
    constantly changing and your memory，gets reused，when you free memory that doesn't
    erase。it or set it all back to zeros or set it，all back to once it just leaves
    it alone。so that you can reuse it which means，over time your computer contains。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和函数返回的值在计算机内存中不断变化，当你释放内存时，内存会被重用，这并不会清除它，也不会将其全部重置为零或将其全部重置为一。它只是保持不变，以便你可以重用，这意味着随着时间的推移，你的计算机包含。
- en: remnants of all of the variables you've，ever used in your program。over here
    over here over there and so in，a program like this，where you have not explicitly。initialized
    y to anything，you should assume that oscar the grouch。so to speak is at that location
    it is a，garbage value，that looks like an address but is not a。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你程序中所有变量的残余。在这里，在那里，所以在这样的程序中，如果你没有明确地初始化 `y`，你应该假设“奥斯卡”大概在那个位置，那是一个看似地址但并不是真正地址的垃圾值。
- en: valid address，and so when you say star y equals 13，that means go to that address
    but really。go to that bogus address and put，something there，and odds are your
    program is going to。crash you are going to get a，segmentation fall，because by
    going to some arbitrary。garbage value address，it would be like picking up a random，piece
    of paper with a number on it and。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地址，因此当你说 `*y = 13` 时，这意味着去那个地址，但实际上是去那个虚假的地址并在那里放置一些东西，结果你的程序很可能会崩溃，你会遇到段错误，因为访问了某个任意的垃圾值地址，就像拿起一张随机的纸，上面写着一个数字一样。
- en: then going to that mailbox like why it，doesn't belong to you，if you try to de-reference
    an。uninitialized variable，your program may very well crash and，this is perhaps
    no better presented than。by some of our friends，nick parlante a professor at stanford，university
    who has breathed life into a。character in claymation known as binky，we have just
    a two minute clip from this。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后去那个邮箱，像是为什么它不属于你，如果你尝试解除引用一个未初始化的变量，你的程序很可能会崩溃，而这可能在我们的朋友中表现得最好，尼克·帕兰特是斯坦福大学的教授，他赋予了一个粘土动画角色“宾基”生命，我们有一段两分钟的剪辑。
- en: that paints the picture of bad things，indeed happening，when you touch memory
    that you shouldn't。so hopefully a helpful reminder as to，what to do and not to
    do。hey binky wake up it's time for pointer，hey binky wake up it's time for pointer，fun。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_15.png)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实描绘了当你接触不该接触的内存时会发生的坏事情，所以希望这是一个有用的提醒，告诉你该做什么和不该做什么。嘿，宾基，醒醒，时间到了，进行指针的乐趣！![](img/6fac50ad528c92cf9095b8bd7a26a8b0_15.png)
- en: what's that learn about pointers oh，goody well to get started i guess we're。gonna
    need a couple pointers，okay this code allocates two pointers，which can point to
    integers。okay well i see the two pointers but，anything，that's right initially
    pointers don't。point to anything the things they point，to are called pointees
    and setting them，up's a separate step。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 指针学习是什么，哦，好吧，开始吧，我想我们需要几个指针，好的，这段代码分配了两个指针，它们可以指向整数。好的，我看到了这两个指针，但一开始，它们确实不指向任何东西，它们指向的东西叫做被指对象，设置它们是一个单独的步骤。
- en: oh right right i knew that the pointees，are separate，so how do you allocate
    a point e okay。well this code allocates a new integer，point e and this part sets
    x to point to，it。hey that looks better so make it do，something okay，i'll dereference
    the pointer x to store。the number 42，into its point e for this trick i'll，need
    my magic wand of dereferencing。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对对，我知道被指对象是分开的，那么如何分配一个被指对象呢？好的，这段代码分配了一个新的整数被指对象，这部分将 `x` 设置为指向它。嘿，这看起来好一些，那就让它做点什么吧，好的，我会解除引用指针
    `x` 将数字 42 存储到它的被指对象中，为这个技巧我需要解除引用的魔杖。
- en: your magic wand of dereferencing，looks like，i'll just set up the number and。hey
    look there it goes so doing a d，reference on x follows the arrow to，access its
    point e。in this case the store 42 in there hey，try using it to store the number
    13，through the other pointer。why okay i'll just go over here to y，and get the
    number 13 set up and then。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解除引用魔杖看起来像，我会先设置这个数字。嘿，看看它开始工作了，所以对 `x` 进行解除引用会跟随箭头访问它的被指对象。在这种情况下，存储 42 到那里，嘿，试着用另一个指针存储数字
    13。为什么？好的，我就去 `y` 那里设置数字 13，然后。
- en: take the wand of dereferencing，and just oh hey，that didn't work say uh binky
    i don't，because。uh you know setting up the point e is a，separate step and i don't
    think we ever，did it。good point yeah we we allocated the，pointer y but we never
    set it to point，to a point d。hm very observant hey you're looking，good there binky，can
    you fix it so that y points to the。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 拿起解除引用的魔杖，哦，嘿，这不行，说呃，宾基，我不知道，因为，呃，设置被指对象是一个单独的步骤，而我认为我们从未做到过。好点子，是的，我们分配了指针
    `y`，但从未将其设置为指向一个被指对象。嗯，很有观察力，嘿，宾基，你看起来不错，能不能修复一下，让 `y` 指向那个。
- en: same pointy as x，sure i'll use my magic wand of pointer，assignment。is that going
    to be a problem like，pointees，it just changes one pointer to point to。the same
    thing as another，oh i see now y points to the same place，as x。so so wait now y
    is fixed it has a point，e so you can try the wand of d。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 和 x 一样尖锐，当然我会用我的指针魔法棒和赋值。这样会有问题吗，比如，指向的对象，它只是将一个指针改变为指向。和另一个相同的东西，哦我现在明白了，y
    指向与 x 相同的地方。所以等等，现在 y 是固定的，它有一个点，e，所以你可以试试 d 的魔法棒。
- en: referencing again to send the 13 over，uh okay here it goes，hey look at that
    now dereferencing works。sharing that one point，whatever，so are we gonna switch
    places now oh，look we're out of time。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_17.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次引用，发送 13，呃，好吧，来了，嘿看看这个，现在解除引用有效。共享那一个点，无论如何，所以我们现在要交换位置吗，哦，看，我们没时间了。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_17.png)
- en: but all right so we are not quite out of，time but let's go ah**d and take our。second
    five-minute break here and when，oscar，all right so i claim that there's all。all
    right so i claim that there's all，these garbage values in your computer's，memory
    but how can you。see them uh what binky did was of course，try to de-reference，a
    garbage value when bad things happen。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们还没有完全超出时间，但让我们继续 ah**d，进行我们的第二个五分钟休息，当奥斯卡，好的，我声称你计算机的内存中有所有这些垃圾值，但你怎么能。看见它们呢，呃，Binky
    做的当然是尝试解除引用，一个垃圾值，当坏事发生时。
- en: but we can actually see this with code，of our own so let me go ah**d quickly。and
    whip up a little program here，just like something we did in week one。bar week
    two but without doing it very，well let me go ah**d and include，standardio。h as
    usual。int main void and then let me go ah**d，and give myself an array of scores
    how。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上可以用自己的代码看到这一点，所以让我快速去 ah**d，编写一个小程序，就像我们在第一周做的。或第二周，但没有做得很好，让我去 ah**d，像往常一样包含
    standardio.h。int main void，然后让我去 ah**d，给自己一个 scores 数组，如何。
- en: about an array of three scores and we've，done this before where we collected，scores
    from a user。but this time i'm going to deliberately，make the mistake of not actually。initializing
    those scores or even asking，the human for those scores。i'm just going to blindly
    go about，iterating from i equals zero。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个三项的 scores 数组，我们之前做过，我们从用户那里收集了分数。可是这次我会故意犯错，不实际。初始化那些分数，甚至不询问人类这些分数。我只是盲目地从
    i 等于零开始迭代。
- en: on up to three and on each iteration i'm，just going to presumptuously。print
    whatever is at that location in，scores bracket i，so logically my code is correct
    in what。and scores，but notice that i have deliberately not，initialized any of
    the one two three。scores in that array so who knows what's，going to be there indeed
    it should be。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代到三，每次迭代我只是冒昧地。打印出位于 scores[i] 的位置上的任何东西，所以逻辑上我的代码在 scores 中是正确的。但注意我故意没有初始化那个数组中的一、二、三的任何
    scores，所以谁知道那里会有什么，确实应该是这样。
- en: garbage values of some sort，that we couldn't necessarily predict in。advance
    so let me go ah**d and make，garbage uh since this program is in a，file called
    garbage。c。compile's okay but when i now run，garbage we should see，three scores
    which are cryptically。negative eight three three o six o eight，*****，thousand
    seven hundred sixty five and。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 某种垃圾值，我们无法提前预测，所以让我去 ah**d 制造垃圾，呃，因为这个程序在一个名为 garbage.c 的文件中。编译没问题，但当我现在运行 garbage
    时，我们应该看到，三个 cryptically。负值 - 八三三零六零八，*****，七百六十五和。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_19.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_19.png)'
- en: the third just happens to be zero，so there are those garbage values。because
    again the computer is not going，to initialize，any of those values for you now
    there。are exceptions，we have on occasion used like a global，variable a constant
    that is。outside the context of main and all of，my other functions，global variables
    if you do not set them。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个恰好是零，所以有这些垃圾值。因为计算机不会为你初始化。那些值，现在有例外，我们偶尔使用像全局变量这样的常量，它在 main 的上下文之外，和我其他的所有函数，如果你不设置它们。
- en: are conventionally initialized to，zero or null for you but you should。generally
    not rely on that kind of，behavior your instinct should be to。always initialize
    values before thinking，of touching or reading them as via。printf or some other
    mechanism，all right well let's see how this，understanding now of memory。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常初始化为零或 null，但你应该。一般来说不要依赖这种行为，你的本能应该是。总是在考虑接触或读取它们之前，先初始化值，比如通过。printf 或其他机制，好吧，让我们看看这对内存的理解。
- en: can lead us to solve problems but also，encounter new types of problems but，problems
    that we can now。hopefully understand i'm going to go，ahead and create a new program
    here。and recall from last week that it was。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_21.png)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以引导我们解决问题，但也可能遇到新的问题，但这些问题我们现在希望能够理解。我要继续**做**并创建一个新程序，并回忆起上周的内容。 ![](img/6fac50ad528c92cf9095b8bd7a26a8b0_21.png)
- en: very common for us to want to swap，values when brian was doing our sorts。for
    us whether it was selection sort or，bubble sore there was a lot of swapping。going
    on and yet we didn't really write，any code for those algorithms and that's。fine
    but let's consider that very simple，primitive of just swapping two values。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常希望交换值。当布莱恩为我们排序时，无论是选择排序还是冒泡排序，都有很多交换发生。然而，我们并没有为这些算法写任何代码，这没关系，但让我们考虑一下这个非常简单的基本操作：交换两个值。
- en: for instance swapping two integers let，me go ah**d and give myself the start
    of。a program in swap dot c here，int main，void and inside of main i'm going to。give
    myself two integers let's just give，myself an ink called x and assign it one。and
    in called y and assign it to and，then let me go ah**d and just print out，what
    those values are。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 比如交换两个整数，让我继续**做**，在 swap.c 中开始一个程序，int main void。在 main 中，我将给自己两个整数，让我给自己一个叫
    x 的变量并赋值为 1，然后给一个叫 y 的变量赋值为 2。接着让我继续**做**并打印出这些值。
- en: i'll just say literally x is percent i，comma y is percent i backslash n。and
    then i'm going to go ah**d and print，out x comma y respectively，function。called
    swap that swaps x and y but let's，doesn't，because what i then want to do right，thing。x
    is now percent i y is percent i，x and y，will be swapped so how might i swap。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想说，字面上 x 是百分之一，y 也是百分之一。然后我将继续**做**并分别打印出 x 和 y。这个函数叫做 swap，用于交换 x 和 y，但让我们先不这样做，因为我接下来想做的事情是，x
    现在是百分之一，y 也是百分之一，x 和 y 将被交换，那么我该如何交换呢？
- en: these two values well let me go ah**d，and implement my own function，i don't
    think it needs to return。return，type i'll call it swap it's going to，take two
    arguments，as input we'll call it a and b both。want but a and b，seems reasonable
    and now i want to go，ahead and swap two values now brian was。kind of doing this
    with his two hands，last week and that's，fine but we should probably consider。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值，好吧，让我继续**做**，并实现我自己的函数，我认为它不需要返回类型。我会叫它 swap，它将接收两个参数作为输入，我们称之为 a 和 b，似乎合理，现在我想继续交换这两个值。布莱恩上周用他的双手做了这个，没问题，但我们应该考虑一下。
- en: this a little more closely in fact brian，instead of numbers let's do something
    a。little more real world i think you have，a couple of beverages in front of you。yeah
    so right here i have a a red glass，and a blue glass which i guess we can。use to
    represent like two variables，yeah no i let me suppose i wish i told。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细地看看，事实上，布莱恩用数字的方式不如用现实世界中的东西。我想你面前有几杯饮料。是的，我这里有一个红色玻璃杯和一个蓝色玻璃杯，我想我们可以用来代表两个变量。是的，我让我们假设我希望我说。
- en: you in advance i'd actually prefer，that like the red liquid being the blue。glass
    and the blue liquid be，in the red glass so do you mind swapping。those two values
    just like you swapped，numbers last week yeah sure so i can。just take the two glasses
    and i can，switch okay wait but that's okay that's，not exactly okay。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提前告诉你，我其实更希望红色液体在蓝色玻璃杯中，蓝色液体在红色玻璃杯中。你介意交换这两个值吗，就像你上周交换数字那样？当然可以，我可以把两个杯子拿过来，交换一下。等一下，但这没问题，这并不完全对。
- en: i you took me too literally i think here，if we think of the glasses now as。specific
    locations in memory，you can't just like physically move the。chips of memory inside
    of your computer，need you，to move the blue liquid into the red，glass。so that it's
    more like a computer's，memory okay，i can try to do that i'm a little。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对我太过字面理解，我认为这里，如果我们现在把眼镜看作记忆中的特定位置，你不能像物理上移动电脑里的内存芯片那样，实际上需要把蓝色液体移到红色玻璃杯中。这样更像是电脑的内存，好的，我可以试试，不过我有点紧张。
- en: nervous though because i feel like i，can't just pour the blue liquid into the，already
    in there。yeah so this probably doesn't end well，right if he's got to do some kind
    of。switcheroo between the two glasses so，any thoughts here like，weird but，contents。of
    these two locations just like brian，was swapping the contents of two memory，locations
    last week。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但我有点紧张，因为我觉得我不能把蓝色液体倒入已经在里面的那杯。是的，所以这可能不会有好结果，如果他必须在两个杯子之间做某种交换，你有什么想法吗？就像布莱恩上周在交换两个内存位置的内容一样，内容有点奇怪。
- en: um brian if you have your eye on the，chat in parallel might anyone have ideas，on
    how we could swap。these two liquids yeah a couple of，glass，all right well brian
    do you happen to。have a third glass with you back there，behind backstage uh in
    fact i think i do。so i have a third glass here that just，so happens to be empty，okay
    and and go how would you now go。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，布莱恩，如果你在关注聊天的话，是否有人有什么想法，关于我们如何交换这两种液体？是的，几杯。好吧，布莱恩，你那边是否恰好有第三个玻璃杯在后台？事实上，我想我有。所以我这儿有一个第三个玻璃杯，恰好是空的，好的，那你现在该怎么做呢？
- en: about swapping these two things，all right so i want to put the blue，liquid inside
    the red glass。so the first thing i need to do i think，is just to like empty out
    the red glass。to make space for the blue liquid，so i'm going to take the red liquid
    and。i'm just going to pour it into this，extra glass，temporarily though right temporarily。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于交换这两种液体，我想我需要做的第一件事就是清空红色玻璃杯，以便为蓝色液体腾出空间。所以我会把红色液体倒入这个额外的玻璃杯中，暂时这样做。
- en: just just to keep it to store it there，and now i think i can just pour the blue。liquid
    into the original，red glass because now i'm free to do so。and i think the last
    thing i need to do，and i think the last thing i need to do。now is now this blue
    this glass that，originally held the blue，blue liquid is now empty so the red。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了暂时存储它，现在我想我可以将蓝色液体倒入原来的红色玻璃杯中，因为现在我可以这么做了。我认为我需要做的最后一件事是，这个原本装有蓝色液体的杯子现在是空的，所以红色的。
- en: liquid which was inside of this，temporary glass over here，i can take the red
    liquid and just pour。it into，this glass here and now i didn't swap，the positions
    of the glasses but the。liquids have actually switched places，now the blue liquid
    is on the left。and the red liquid is on the right，awesome yeah i think that is
    a more。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以把这个临时杯子里的液体，红色液体倒入这个杯子里。现在我并没有交换杯子的位子，但液体实际上已经交换了位置，现在蓝色液体在左边，红色液体在右边，太棒了，我想这就是一个更好的结果。
- en: literal implementation of what you were，doing and taking for granted last week，locations
    so。it seems pretty straightforward i just，need a little more space like i need
    a。temporary variable in code if you will，and it seems i need like three steps
    i。need to pour one out pour the other one，out pour the other one back in so i。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你上周所做的事情的逐字实现，所以看起来相当简单。我只需要一些空间，就像我需要一个临时变量一样，似乎我需要三步。我需要倒出一种液体，再倒出另一种液体，最后将另一种液体倒回去。
- en: think i can translate that，into code here let me go ah**d and give。myself a
    temporary variable like a glass，like brian did and i'll call it temp。tmp which
    is pretty conventional when，you want to swap two things in code。and i'm going
    to assign it temporarily，the value of a i'm going to then。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我可以将这个翻译成代码，给自己一个临时变量，就像**布莱恩**那样，我会称它为`temp`。这个名字在交换两个变量时是相当传统的。我将暂时将它赋值为`a`。
- en: change the contents of a to equal，whatever the contents of b。are and then i'm
    going to change b to be，whatever the contents of tempwor。so this feels pretty
    reasonable and，pretty correct because it's just a。literal translation into code
    now of，what brian did in the real world and i i，there，okay oh。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将`a`的内容改为`b`的内容，然后将`b`的内容改为`temp`的内容。这听起来相当合理，也很正确，因为这实际上就是对布莱恩在现实世界中所做的事情的逐字翻译，我觉得可以。
- en: previous implicit declaration oh so many，errors my god，implicit declaration
    of function swap。wait a minute i've seen that before i've，made this mistake before
    you might have。as well anytime you see this recall it's，just that you're missing
    your prototype。remember that the compiler is going to，take you literally and if
    it doesn't，it。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前隐式声明的错误，哦天哪，错误太多了，我的天，函数`swap`的隐式声明。等一下，我以前见过这个，我也犯过这个错误。任何时候你看到这个，记住这只是因为你缺少原型。记住编译器会字面理解你所写的，如果没有。
- en: it's not going to compile successfully，so we need to include my prototype at，the
    top of my file。that compiles，let me go ah**d now and run swap and，recall that
    in main。what i did was initialize x to 1 y to 2，i then print out what x is and
    what y is，i call swap。and then i print out what x is and y is，again so i should
    see，1 two and then two one so let's hit。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它将无法成功编译，所以我们需要在文件顶部包含我的原型。让我现在去运行`swap`，回想一下在主函数中，我初始化了`x`为1，`y`为2，然后打印出`x`和`y`的值，接着调用`swap`，然后再次打印出`x`和`y`，我应该能看到1和2，然后是2和1，所以让我们看看。
- en: enter，huh it does not seem to be，case，me add some，printf is my friend let me
    go ah**d and，say a is。percent i b is percent i backslash n，a b so let's print
    that out and let's。print that out twice so this would be a，reasonable debugging
    technique if you，the hood。add some print f's let me go ah**d and，make swap，that
    compiles dot slash swap and let's，see。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 进入，嗯，似乎不是这样的，给我加一些，printf是我的朋友，让我去啊**d说a是。百分之一b是百分之一换行，a b所以我们打印出来，让我们。打印两次，这将是一个合理的调试技术，如果你，底下。添加一些print
    f的，让我去啊**d，执行swap，编译了点斜杠swap，让我们看看。
- en: a is 1 b is 2 a is 2，i feel like，my logic is right it's switching a and b。but
    it's not actually switching，x and y and i could confirm as much，debug this。would
    be to run debug 50 set a break，point for instance at line 17，step through my code
    step by step。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_23.png)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: a是1 b是2 a是2，我觉得，逻辑是对的，它在交换a和b。但它实际上并没有交换，x和y，我可以确认，调试这个。将是运行调试50设置一个断点，例如在第17行，逐步执行我的代码。
- en: stepping into the swap function，works but，main isn't really seeing those results，consider
    this。real world incarnation of what my memory，is so i can actually move things
    around。and this is all thanks to our，friends in the theater's prop shop in，back
    if we think of this as my。computer's memory initially it's all，garbage values，but
    i can use this as a canvas to start。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 步入swap函数，工作是的，但main并没有真正看到那些结果，考虑这个。我的内存的现实世界体现，所以我可以实际移动东西。所有这一切都要感谢我们的，朋友们在剧院的道具店，如果我们把这看作是我的。计算机的内存，最初它都是，垃圾值，但我可以把它作为一个画布开始。
- en: laying things out in memory but，calling functions is something we've。taken for
    granted thus far and it turns，out when you call functions。the computer by default
    uses this memory，in kind of a standard way。in fact let me go ah**d and draw a
    more，a pictorial picture，let me draw a more a literal picture。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中布局东西，但调用函数是我们迄今为止视为理所当然的，而事实证明，当你调用函数时。计算机默认以一种标准的方式使用这块内存。实际上，让我去啊**d画一个更，形象化的图，让我画一个更字面的图。
- en: here if you will of the computer's，memory again so if this is the。computer's
    memory and we zoom in on one，of the chips and we think of the chip as。having a
    whole bunch of bytes like this，let's abstract away the actual hardware。and think
    of it as we have been it's，just this big rectangular region of，grouches。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果你愿意的话，计算机的内存，再次如此，如果这是计算机的内存，我们放大其中一个芯片，想象这个芯片。拥有很多字节，就像这样，让我们抽象出实际的硬件。把它看作我们一直在看的，它只是这个大矩形区域的，堆积。
- en: a moment ago but by convention your，computer does not just plop things in，random
    locations in memory。it has certain rules of thumb that it，adheres to，in particular
    it treats different。portions of your computer's memory，in different ways it uses
    it in a，random。for instance when you run a program by，doing dot slash something
    on cs50 ide。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才提到的，但按照惯例，你的计算机并不会随意地在内存中放置东西。它遵循某些经验法则，特别是它以不同的方式处理计算机内存的不同部分。随机使用它。例如，当你通过在cs50
    IDE上执行点斜杠某个程序时。
- en: or on linux more generally or you double，click an icon on mac os，computer's，your
    hard drive。to be loaded up here to what we'll call，and ones，so if you think again
    metaphorically as。your memory is this rectangular region，then the machine code
    the zeros and ones，program。are loaded into the top part of memory，and again top
    bottom left right it has。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Linux上更一般地，或者在macOS上双击图标，计算机的硬盘被加载到这里，我们称之为，和零一，所以如果你再比喻一下。你的内存是这个矩形区域，那么机器码的零和一，程序。被加载到内存的顶部，再次顶部底部左右都有。
- en: no fundamental technical meaning it's，just an artist's rendition。but it does
    go into a standard location，variables，or your constants that you put outside。of
    your functions those are going to end，at the top，of your computer's memory below
    that is。what's called the heap，and this is a technical term and it，refers to a
    big chunk of memory，memory。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 没有基本的技术含义，只是一个艺术家的表现。但它确实进入了一个标准位置，变量，或者你放在外面的常量。你的函数那些将在你计算机内存的顶部结束，下面是。所谓的堆，这是一个技术术语，指的是一大块内存。
- en: the return，the address of some chunk of memory up，in this region below the machine
    code。below your global variables，and it's kind of a big zone but the，catch is
    that。other parts of your memory are used，differently in fact，uh whereas the heap
    is considered to be。here on down，somewhat worrisomely the stack is，considered
    to be here。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回，某个内存块的地址，在机器码下方的这个区域。位于你的全局变量下方，这算是一个大区域，但关键是。内存的其他部分被不同地使用，实际上，嗯，而堆被认为是。这里往下，有些令人担忧的是栈，被认为在这里。
- en: on up this is to say when you call，malloc and ask for memory，that gets allocated
    up here。when you call a function though those，functions，heap space，swap。or stirling
    or string compare or any of，the functions you've used，thus far your computer will。automatically，parameters，from
    those functions down here now this，is not necessarily the best design。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是说，当你调用 malloc 并请求内存时，内存会在这里分配。当你调用一个函数时，那些函数，堆空间，swap，或者 stirling 或 string
    compare，或者你到目前为止使用的任何函数，你的计算机会自动将参数从这些函数传递到这里，这并不一定是最好的设计。
- en: because you can see the two arrows，pointing at one another is like two。trains
    barreling down the tracks at one，another bad things can eventually happen。thankfully
    we typically have enough，collide but，more on that in just a bit so again when。you
    call functions，memory down here is used when you use，malloc memory up here is
    used now for my。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以看到两条箭头互相指向，就像两列火车在轨道上相向而行，坏事最终可能会发生。幸运的是，我们通常有足够的防止碰撞，但稍后再谈，所以再次，当你调用函数时，下面的内存被使用，当你使用
    malloc 时，上面的内存被使用。现在对于我的 swap 函数，我不使用 malloc，所以我认为我不必担心堆。
- en: swap function i'm not using malloc so i，don't think i have to worry about heap。and
    i don't have any global variables，and i don't really care about my machine。code
    i just need to know that it's，stored somewhere，but let's consider then what the
    stack。sort of dynamic，place where memory keeps getting used，main，is run。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 而且我没有任何全局变量，我也不在乎我的机器代码，我只需要知道它存储在某个地方，但我们来考虑一下栈，这是一种动态的地方，内存不断被使用，main 在运行。
- en: main uses a sliver of memory at the，bottom of this picture，if you will so the
    local variables in。main like x and y，end up at this bottom portion of memory，when
    you call swap。swap uses a chunk of memory just above，main pictorially，b，swap，returns
    and is done executing that。sliver of memory essentially goes away，now it doesn't
    disappear like obviously。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: main 在这张图片的底部使用了一小块内存，如果你愿意的话，main 中的局部变量像 x 和 y 最终位于这块底部内存，当你调用 swap 时，swap
    使用了一块内存，正好在 main 上方，b，swap 返回并完成执行后，这块内存基本上就消失了，现在它并不会明显地消失。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_25.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_25.png)'
- en: there's still physical memory there，but that's when we get into the。discussion
    of garbage values again，they're still like oscar the grouches。all over the place
    you just don't know，are，but there are values there and that's。why a moment ago
    when i printed out that，uninitialized scores array i did see。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有物理内存在那里，但这时我们又进入了垃圾值的讨论，它们像 oscar the grouches 一样到处都是，你只是不知道，确实存在一些值，这就是为什么我刚刚打印出的未初始化的分数数组，我看到了。
- en: some bogus values because there's still，going to be zeros and ones there。that
    are left over from before the，problem though is this let me go over to，this。physical
    incarnation of our memory and，growing on，up and in fact if i want to have two。local
    variables like i do，x and y let's go ah**d and think of this。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些虚假的值因为仍然会有之前留下的零和一，问题是让我去看看这个。我们内存的物理体现，并且在增长，实际上如果我想有两个局部变量，就像我做的，x 和 y，让我们去想一想。
- en: row of memory here as being main for，instance here，and i'm going to go ah**d
    and replace。all these garbage values with an actual，value that i care about，and
    the actual variables that i care。about we're going to call x and y，happens to
    be one，byte but an int is four bytes so。thankfully from our friends in the prop，blocks，and
    i'm going to go ah**d and slide this。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的内存行被视作 main 例如在这里，我将继续并替换掉所有这些垃圾值，用我在乎的实际值，和我在乎的实际变量，我们将称之为 x 和 y，恰好是一个字节，但一个
    int 是四个字节，所以幸运的是我们在 prop blocks 的帮助下，我将继续滑动这个。
- en: in here and we're going to think of this，in a moment as x，and indeed i'm going
    to go ah**d and。call this x with a marker，and then i'm going to go ah**d and give，myself
    another integer of size 4。and put it down here and we're going to，think of this
    as y，and recall what do i initialize these。values to well the value one，initially
    and the value two but then i。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把这个视作 x，实际上我将继续并给这个标记，然后我将继续再给自己一个大小为 4 的整数，并把它放在这里，我们将把它视作 y，并回想一下，我将这些值初始化为多少呢，初始值为一和二，但随后我。
- en: called the swap function and the swap，function has two arguments a，and b and
    those by design become。comma y，and i defined swap as taking a comma b，so i think
    what i need to do。physically here is now think of this，second row of memory，as
    now belonging to the swap function。not to main，and inside of this second row of
    memory，i'll think of this as belonging to。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调用swap函数，而swap，函数有两个参数a，和b，设计上这两个变成了。x和y，我定义swap为接受a和b，所以我认为我需要做的。物理上是现在把这，第二行内存视为现在属于swap函数。不是main，而在这第二行内存内，我将把它视为属于。
- en: swap and within the swap row，i'm going to have another integer of。size 4 and
    we're going to call this one，a as down there whoops a。and then i'm going to have
    another uh，this，b and again because those are just the。arguments x comma y，1，and
    two into those values but swap has a，third variable brian proposed a。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在swap的行中，我会再有一个大小为4的整数，我们叫这个为，a，哎呀，a。然后我会再有一个uh，b，和之前一样，因为那些只是参数x，y，1，和2，但swap有第三个变量，brian提出的一个。
- en: temporary variable so i'm going to go，ahead and give myself，four more bytes
    thereby getting rid of。whatever the garbage value is there and，actually setting
    it，to an integer called temp so i'm going。to go ah**d and call this thing，temp
    tmp，and what did i do first i set temp，is 1。temp is 1 then what did i do i then
    did，a is two as well and then，a is two as well and then。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 临时变量，所以我会继续给自己，四个字节，从而去掉。无论那里是什么垃圾值，实际上把它设置为一个叫做temp的整数，所以我会叫这个东西，temp tmp，我首先做了什么，我把temp设为1。temp是1，然后我做了什么，我把a也设为2，然后，a也设为2，然后。
- en: lastly what did i do i did b gets，temp so i have to go ah**d and change。this
    to be whatever the value of temp，can see that，swap is correct insofar as it is。swapping
    the values of a，and b but the moment swap returns，these return to being thought
    of as。garbage values，main is still in the middle of running，swap is no longer
    running but these。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我做了什么，我把b设为temp，所以我必须继续，改变这个，使它成为temp的值，可以看到，swap是正确的，只要它在。交换a和b的值，但一旦swap返回，这些就回到被视为。垃圾值，main仍在运行中，swap不再运行，但这些。
- en: values stay there so those are garbage，values we happen to know what they are。but
    they're no longer valid because when，time，what are x and y they're still the same，write
    code。that takes arguments and you pass，arguments from one function to another。those
    arguments are copied from one，function to another and indeed。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 值保持在那里，所以那些是垃圾，值我们恰好知道它们是什么，但它们不再有效，因为当时，x和y是什么，它们仍然是一样的，写代码。接受参数，你把参数从一个函数传递到另一个函数。这些参数是从一个函数复制到另一个函数的，确实。
- en: x and y are copied into a and b so your，code may very well，look correct in that
    it's swapping。correctly but it's only swapping，correctly in the context of，swap
    not touching the original values。so what i think we need to do，fundamentally is
    re-implement，swap in such a way that we actually。change the values of one of x，and
    y but how can we do this brian if we，could call in someone here。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: x和y被复制到a和b，所以你的，代码可能看起来非常，正确，因为它在正确地交换。确实交换，但它仅在swap的上下文中交换，而不触及原始值。所以我认为我们需要，从根本上重新实现，swap，以这样的方式真正。改变x和y的一个值，但我们该怎么做，brian如果我们，可以叫一个人来这里。
- en: implementation of，swap so that it somehow empowers me to，change x and y not
    change。copies of x and y like what could i pass，igor is suggesting that we use
    pointers。igor is suggesting that we use pointers，instead yeah so perhaps a leading，seem
    to give us。a solution right if pointers are，essentially like a treasure map to
    a，memory。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: swap的实现，这样它可以让我，改变x和y，而不是改变。x和y的副本，我可以传递什么，igor建议我们使用指针。igor建议我们使用指针，是的，所以或许是一个解决方案。如果指针本质上就像一张指向内存的藏宝图。
- en: what i should really do to pat from main，to swap is pass in not。x and y literally
    but why don't i pass，in the address of x and the address of y，addresses。and actually
    do the sort of swap that，brian enacted in person，so give the function a sort of
    map to。those values pointers to those values，and then go to those values so how
    might。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我真正应该做的是，从main传递到swap的不是。x和y字面上，但为什么我不传递，x和y的地址，地址。并实际上进行brian亲自实施的那种交换，所以给函数一种映射，指向那些值，然后去那些值。那么我们该怎么做。
- en: i do this well the code has to be a，little different now when i call swap。this
    time what i really need to do is，pass in the addresses，of these two variables
    so i don't。necessarily know what those addresses，are but for the sake of the story。we
    can just assume that this address for，instance is like ox，one two three and then
    four bytes away。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做时，代码必须稍微不同。当我调用 swap 时，这次我真正需要做的是传入这两个变量的地址，所以我不一定知道这些地址是什么，但为了叙述的需要，我们可以假设这个地址例如是
    ox123，然后四个字节远。
- en: from that might be ox，one two seven for instance but again it，doesn't really
    matter what it is but。they do have addresses，x and y so a pointer recall tends
    to be，pretty big so we needed to get out a。bigger piece of wood eight bytes that，represents
    a pointer，and i actually need to use a bit more。memory and swap now，if i now declare
    a to be not an integer，but a pointer to an int that is a int。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里可能是 ox127，例如，但再次强调，这并不真的重要。但它们确实有地址，x 和 y，因此一个指针的大小通常比较大，所以我们需要得到一块更大的内存，八个字节，表示一个指针，实际上我需要使用更多的内存，而
    swap 现在，如果我声明 a 不再是一个整数，而是一个指向整数的指针。
- en: now，and i could store in it the address of x，like ox123，be，integer。that is another
    inch star which happens，to be eight bytes，i'm going to use a little more memory。for
    this thing but that's okay，and its name is going to be b now and，it's going to
    contain。ox127 i still need a temporary variable，i still need a temporary variable
    but。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以在其中存储 x 的地址，像 ox123，这是一个整型。那是另一个 inch star，恰好是八个字节，我将为这个东西使用稍多一点的内存，但没关系，它的名字将是
    b，现在它将包含 ox127。我仍然需要一个临时变量，我仍然需要一个临时变量，但。
- en: that's fine i just need，four bytes for that because the variable，itself just
    needs to store an int。like brian temporarily stored in the，glass so i just need
    an additional four。bytes like before for that，here's main，and swap is now using
    these three two，fine。it's growing upward as i proposed x is，at address ox123，y
    is that address ox127 therefore，proposed。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题，我只需要四个字节，因为变量本身只需要存储一个整型。就像布莱恩临时存储在杯子里一样，所以我只需要额外的四个字节，就像之前一样。这里是 main，swap
    现在使用这三个变量，两个就可以了。它向上增长，正如我所提议的，x 在地址 ox123，y 在地址 ox127，因此，提议。
- en: store the addresses of a x and y，respectively，and now my code i think needs
    to say，this go。and store in the variable temp whatever，is at the address a，so
    you can kind of think of this as。being an arrow down here follow the，arrow okay
    what is that address，temp。just like before then what do we do well，now i'm going
    to go ah**d and change。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 存储 x 和 y 的地址，分别，现在我的代码我认为需要说，这个去。并将变量 temp 中的内容存储在地址 a 所指向的地方，所以你可以把这看作是一个箭头，指向这里，好的，那地址
    temp 是什么？就像之前一样，那我们该怎么做呢，现在我将去 ah**d 并进行更改。
- en: not the value of a but i'm going to，change what is，at the location in a to be
    whatever is。at the location in b，here，now，recall，where b，points to which happens
    to be y and。change that to be the value of，temp which of course is up here and
    at。this point in the story it's still just，three lines of code there are different。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不是 a 的值，但我将改变 a 所在位置的内容，让它变成 b 所在位置的内容，这里。现在，回想一下 b 指向的位置，恰好是 y，并将其改为 temp 的值，当然这在这里，并且在这个故事的这一点上，它仍然只是三行代码，情况是不同的。
- en: types of lines of code，it's three lines of code but when swap，is done executing
    no。notice what we've done we have，successfully swapped x and，y by letting swap
    go to those addresses。as opposed to just naively getting，copies of the values
    they're in。now even though this code is going to，look a little cryptic，it's frankly
    just an application of the。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码，但当 swap 执行完毕时，注意我们所做的，我们成功地交换了 x 和 y，让 swap 去访问那些地址，而不是简单地获取它们的值的副本。尽管这段代码看起来有点神秘，实际上它只是。
- en: logic we've seen thus far i'm going to，version，and i'm going to change the definition。of
    swap to say that it doesn't take，two integers a and b but two pointers to，integers
    a and b。and the way you declare a pointer recall，is the type of variable you point
    at。followed by a star and then the name of，it and we haven't seen it admittedly
    in。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的逻辑，我将进行版本更改，并将 swap 的定义改为不接受两个整数 a 和 b，而是两个指向整数的指针 a 和 b。声明指针的方式是指向的变量类型，后面跟着一个星号，然后是它的名称，坦率地说，我们在代码中还没有看到。
- en: the context of a function，taking parameters yet but it's quite，simply that i
    added the stars。down here i need to say store in temp，a，to，there，how do i say
    go to b and store。whatever's at temp i add one star there，so temp is just a simple
    integer like。it's just an empty glass like brian had，there's nothing fancy there
    so we don't。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的上下文，接收参数但实际上很简单，我加了星号。这里我需要说存储在临时变量temp中，去那里，我该如何说去b并存储。无论temp中的内容，我都会加一个星号，所以temp只是一个简单的整数。它就像布莱恩的空玻璃，没有什么花哨的东西，所以我们不需要。
- en: need stars around temp，but i do now need to change how i'm，using a and b。because
    now they are addresses that i，actually want to go to there's no need。for the address
    of operator，in this context but up here i'm going to，need to make a change。i do
    need to change the prototype to，match so that's just a copy paste，but i bet you
    can imagine。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在temp周围加星号，但我现在需要更改使用a和b的方式。因为现在它们是我实际想要去的地址，在这个上下文中没有必要使用地址运算符，但在这里我需要进行更改。我确实需要更改原型以匹配，所以这只是复制粘贴，但我敢打赌你能想象得到。
- en: what lastly needs to change when calling，swap i don't want to pass in naively
    x，copied。i want to pass in the address of x and，the address of y，so that swap
    now has sort of special。access to the contents of those，locations in memory，so
    that it actually can make some。changes therein，and that indeed if i now recompile
    this，program make swap。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在调用时需要更改的是，swap我不想简单地传递x。我想传递x和y的地址，这样swap就可以特殊访问这些内存位置的内容，从而实际上可以对其进行一些更改。如果我现在重新编译这个程序，生成swap。
- en: and i do dot swap and cross my fingers，voila。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_27.png)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实进行了交换，交叉手指，瞧。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_27.png)
- en: code，so last week if you were wondering，to do swap，we could have and we didn't
    need a。special function you don't necessarily，main，but i'm trying to introduce
    an。abstraction this function that does swap，just like brian swapped those glasses，for
    us。and to pass values from one function to，another you do need to understand what's。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码，上周如果你在想，要进行交换，我们本可以，而不需要一个特殊的函数，你不一定需要，main，但我想引入一个抽象，这个函数进行交换，就像布莱恩为我们交换那些玻璃一样。要从一个函数传值到另一个函数，你需要理解。
- en: going on in your computer's memory，so you can actually pass in little。breadcrumbs
    again treasure maps to，those locations and memories again，thanks to these things
    called。pointers are any questions，on that it will undoubtedly take some，stars
    in。ampersand and so forth but any questions，certainly for now on the。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你计算机的内存中发生的事情，所以你实际上可以传入小的“面包屑”作为指向那些内存位置的藏宝图，再次感谢这些称为指针的东西。有什么问题吗？这无疑会涉及一些星号和符号，但现在肯定有问题。
- en: concepts or capabilities brian anything，coming up on your end，none that i'm
    seeing in the chat right。emphasize then，that this design of the heap being up
    at，the top where malloc uses memory。and the stack being at the bottom where，is
    a problem，clearly waiting to happen and those，you。who have programmed before might
    know，some of these terms either heap。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 概念或能力布莱恩那边有什么，要强调的是，这个堆的设计在顶部，malloc使用内存，而栈在底部，这是一个显然等待发生的问题，那些之前编程过的人可能知道这些术语中的一些，比如堆。
- en: overflow or stack overflow and in fact，many of you might know stackoverflow。com，is
    just a website。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_29.png)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出或栈溢出，事实上，很多人可能知道stackoverflow.com，那个只是一个网站。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_29.png)
- en: while there is an origin story to its，process，of calling a function so many
    times that，it overflows。the heap that is every time you call a，function like i
    did here，of memory。and if you call so many functions again，and again eventually
    you may very well，and at that point。your program will crash like there is no，fundamental
    solution。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个起源故事，关于调用函数如此多次以至于溢出。每次你像我在这里那样调用函数的时候，都会消耗内存。如果你一次又一次地调用如此多的函数，最终可能会崩溃，此时你的程序将崩溃，根本没有解决方案。
- en: to that problem other than don't do that，like don't use too much memory but
    that。can be hard to do and indeed that's one，of the dangers of programming today。and
    we can actually induce this a little，bit deliberately，ourselves and in fact i
    thought we could。revisit for instance where，we left off with mario last time which，was
    this picture here recall that。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那个问题，除了不这样做，比如不要使用太多内存，但这可能很难做到，实际上这是今天编程的一大危险。我们实际上可以故意诱导这一点，实际上我认为我们可以回顾一下上次我们和马里奥讨论到的地方，就是这张图片。
- en: this was a a pyramid of course simpler，than the one you might have played with。for
    problem set zero but it's a，recursive pyramid in that you can define，a pyramid
    of height four。in terms of a pyramid of height three in，terms of a pyramid of
    height two and。height 1 and indeed i built that last，week using，these very blocks
    well you can implement。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个比你可能在问题集零中玩过的简单得多的金字塔，但这是一个递归金字塔，因为你可以将高度为四的金字塔定义为高度为三的金字塔，继而是高度为二的金字塔和高度为一的金字塔，确实我上周使用这些非常的块构建了这个，你可以实现。
- en: mario's pyramid like this in a couple of，style，iteration using a loop and in
    fact let。me go ah**d and whip up a quick solution，that does exactly that let me
    go ah**d，and call this mario。c，and i'm going to go ah**d and include，functions，i'm
    going to use standardio。h and i'm。going to do int main void，and all i want to
    do is print out this。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用几种样式迭代马里奥的金字塔，事实上让我去，啊**继续**快速做出一个确切的解决方案，让我去，啊**继续**称之为马里奥。c，我要去，啊**继续**包含，函数，我将使用标准io。h，我要做int
    main void，所有我想做的就是打印出这个。
- en: this pyramid but i want to ask the user，height，equals get int and we'll ask
    the user。for the height just like you，it did for problem set one and then i'm。going
    to go ah**d and draw a pyramid，of that height now draw doesn't exist，and draw
    this now。implement draw myself it doesn't need to，return a value because i'm just
    printing。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个金字塔，但我想问用户，height等于get int，我们会询问用户高度，就像你在问题集一中做的那样，然后我要去，啊**继续**画出这个高度的金字塔，现在绘制不存在，绘制这个现在。自己实现绘制，它不需要返回值，因为我只是打印。
- en: stuff on the screen，function's called draw and it's going to，take an input called
    h。for instance h for height but i could，call its argument anything i want。and
    then i'm just going to do this 4 int，i gets 1，i less than or equal to h i plus。plus
    and then inside of this this is，where you might recall from problems，that one
    have。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的内容，函数称为绘制，它将接受一个名为h的输入。例如，h表示高度，但我可以随意命名它的参数。然后我只是要做这个4 int，i等于1，i小于或等于h，i加一。然后在这个里面，这是你可能从某些问题中回忆起来的地方。
- en: found a nested loop to be useful let me，do in j gets one，uh j less than or equal
    to i j plus。plus this will be similar but not，identical to，either the less comfortable
    or more。comfortable version of mario from the，past because this pyramid。is shaped
    in a different direction let，me print up here a hash there。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 发现嵌套循环很有用，让我做一个j等于1，嗯j小于或等于i，j加一。这将类似但不完全相同于过去的马里奥的舒适或不舒适版本，因为这个金字塔。是朝不同方向形状的，让我在这里打印一个哈希。
- en: and then let me go ah**d and print a new，line here so i did this super quickly。but
    logically what i'm doing is，iterating over，uh every row so from one through h。so
    row one two three four for instance，and then on each row i'm deliberately，iterating
    from one。through i so i print one then two then，three then four and again i could
    zero，context。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我继续，啊**继续**在这里打印一行新内容，所以我快速做了这个。但从逻辑上讲，我正在遍历每一行，从一到h。所以第一行、第二行、第三行、第四行，例如，然后在每一行我故意从一开始遍历，所以我打印一，接着是二、三、四，当然我可以设置为零上下文。
- en: more user-friendly more intelligible to，me to index from one，totally reasonable
    if you think there's。a compelling design argument so let me，go ah**d and make
    mario。ah darn it uh oh i missed my prototype，so notice it's not understanding
    draw so，the fix for that。is to either move the whole function or，as we've preached
    instead。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更用户友好，更容易理解，从一开始索引我觉得是完全合理的，如果你认为有一个令人信服的设计论点，所以让我去，啊**继续**做马里奥。啊，真糟糕，我错过了我的原型，所以请注意，它不理解绘制。所以解决方法是要么移动整个函数，要么如我们所宣传的那样。
- en: to just put your prototype up top let me，recompile mario，okay now successful
    mario let's do a。height of four and voila now i have a，relatively simple though
    i certainly did，practice。implementation of mario's pyramid but，here's where things
    get kind of cool。if let me stipulate that that is a，correct iterative solution
    even if it。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将你的原型放在顶部，让我重新编译马里奥，好的，现在成功的马里奥，我们设置高度为四，瞧，现在我有一个相对简单的，尽管我确实进行了实践的马里奥金字塔实现，但事情变得相当酷。如果让我规定这是一种正确的迭代解决方案，即使它。
- en: might take you some number of steps or，iterative，loop-based code correct let
    me change。this now to be recursive and recall a，recursive function，is one that
    calls itself how do you。print a pyramid of height h，height h，minus 1 and then
    you proceed to print。one more row of blocks so let me take，that literally for
    int i，gets 0 i is less than h i plus plus。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要你一些步骤或者，基于迭代循环的代码，正确，让我把这现在改为递归，回想一下，递归函数是一个调用自身的函数，如何打印高度为h的金字塔，高度为h，减去1，然后你继续打印。多一行块，所以让我字面理解，int
    i，等于0，i小于h，i加1。
- en: let me go ah**d and just print that，extra row of bricks like this。followed by
    a new line so now i did this，kind of fast but what am i doing here，well if the
    height。one time，if the height equals two i want it to，iterate two times three
    and so forth。so i think using my zero indexing，technique here this will work too。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我去**继续**并打印那额外的一行砖块，就这样。后面跟着一个换行，所以现在我做得有点快，但我在这里做什么，嗯，如果高度。一次，如果高度等于二，我希望它迭代两次，三次等等。所以我想使用我的零索引，技术，这也会有效。
- en: but if you prefer i could certainly just，change this to a one and change this
    to。but i'm going to go ah**d and actually，no in this case i want to leave it as。as
    such zero index just like we，typically do，all right let me go ah**d and compile，this
    make mario。okay oops interesting all paths through，this function will call itself。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你愿意，我当然可以把这个改为一个，把这个改为。可是我想去**继续**，实际上，在这种情况下我想保持为。像我们通常做的那样，从零开始。好吧，让我去**继续**编译，这样让马里奥。好的，哎呀，有趣的是，所有路径通过，这个函数将自我调用。
- en: so clang is being kind of smart here，whereby it's noticing that。in my draw function
    i'm calling my draw，changes，in fact let me see if i can override。that let me use
    clang manually，and compile a program called maro using，mario。c。and let me go ah**d
    and link in cs50 so，i'm using our old school syntax from，week two。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以clang在这里表现得相当聪明，因为它注意到。在我的绘制函数中，我在调用我的绘制，实际上让我看看我是否可以覆盖。让我手动使用clang，编译一个名为maro的程序，使用mario.c。让我去**继续**并链接cs50，所以，我使用的是我们第二周的老式语法。
- en: okay that compiled and why did that，compile well make，is again a program that
    uses your。compiler clang，and we've configured make to be a little，protective of
    you。by turning on special features where we，detect problems like that，by using
    clang directly now i'm。disabling those special checks and watch，what happens when
    i run mario now，crashed。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，编译成功了，为什么那能编译好呢？make，又是一个使用你的。编译器clang的程序，我们已经配置make，让它对你稍微保护。通过开启特殊功能，我们检测到像那样的问题，直接使用clang时，我现在禁用那些特殊检查，看看我现在运行马里奥时发生了什么，崩溃了。
- en: it didn't even print anything it crashed，pretty quickly and again a segmentation，shouldn't。so
    what's going on well if you think of，this memory as representing。main still but
    then draw draw draw，draw draw draw if every one of your。calls to draw just calls
    draw again why，would it ever stop it wouldn't seem to，stop here necessarily。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至什么都没打印就崩溃了，迅速崩溃，再次出现了段错误，应该不会。所以发生了什么呢？如果你把这块内存看作表示。主程序，但接着是绘制，绘制，绘制，绘制，绘制，如果你的每一个。绘制调用只是再次调用绘制，为什么它会停止呢？这里似乎不会停止。
- en: so it seems that i'm missing a key，detail in my recursive version。you know what
    if there's nothing to draw，if height equals equals zero。let me go ah**d then and
    just return，immediately otherwise i'll go ah**d and。draw part of the pyramid，and
    then add the new row so you need，this so-called base case which you。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以看起来我在递归版本中缺少一个关键细节。你知道吗，如果没有什么可以绘制的，如果高度等于零。让我去**继续**然后立即返回，否则我将去**继续**绘制金字塔的一部分，然后添加新行，所以你需要这个所谓的基础情况，你。
- en: literally choose to equal some simple，value like height of zero height of one。any
    hard-coded value so that eventually，draw does not call itself so let me go。ahead
    and recompile this，with clang or make let me rerun it，height of four。and voila
    it's still working just like，the iterative version but it's now using。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 字面意思上选择等于某个简单的值，比如高度为零，高度为一。任何硬编码的值，这样最终，绘制不会自我调用，所以让我去。继续使用clang重新编译，或者使用make让我重新运行，高度为四。瞧，它仍然像迭代版本一样工作，但现在使用的是。
- en: recursion so here's a，sort of design question is iteration，better than recursion
    it depends。iteration will always work，when using the iterate version i will，never
    overflow。the stack and hit the heap why because，i'm not calling functions again
    and。again there's only main and one，invocation of draw but with the，recursive
    version，things like ah。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 递归，所以这是一个设计问题，迭代是否优于递归，这取决于。使用迭代版本时，迭代总是会工作，我不会溢出。堆栈并触及堆，为什么，因为我不在一次又一次地调用函数，只有主程序和一个绘制调用，但使用递归版本时，事情会像哎。
- en: i can draw you a pyramid of height h let，me just have you draw me a pyramid
    of，row。it's kind of this clever uh cyclical，argument that does work，very elegantly
    but there's a danger and。in fact even though this base case，could go on，so long
    maybe let's try ten thousand，invocations。so that worked okay it's a little slow，control
    c，is your friend let me try this once more。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以画一个高度为h的金字塔，让我让你画一个行的金字塔。这是一个巧妙的循环论证，它确实工作得很优雅，但存在危险。事实上，尽管这个基本情况，可以持续那么长时间，也许让我们尝试一万次调用。所以那样可以，好的，它有点慢，控制C是你的朋友，让我再试一次。
- en: let me go ah**d and do something like 2。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_31.png)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续做一些像2这样的事情。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_31.png)
- en: billion and see if that works boom，so even that doesn't work so there's。this
    inherent danger with recursion，whereby even though it empowered us last。week to
    solve a problem even more，efficiently with merge sort。we kind of got lucky in
    that we weren't，trying to sort crazy big things on，brian's shelf。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 亿，看看这是否有效，砰，所以即使那也不起作用，因此递归有这种固有的危险，尽管上周它使我们能够更有效地解决一个问题，通过归并排序。我们算是走运，因为我们没有尝试在布莱恩的架子上对超大数据进行排序。
- en: because it would seem if you use，recursion and call yourself again and，many
    times，shouldn't and。what's the solution here unfortunately，it's don't do that，design
    your algorithms choose your。inputs in such a way that there just，isn't that risk
    and we'll use recursion，at more。sophisticated data structures but again，there's
    always this trade-off just。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果你使用递归并多次调用自己，似乎是不应该的。那么这里的解决方案是什么，不幸的是，就是不要这样做，设计你的算法，选择你的输入，使其没有这样的风险，我们将在更复杂的数据结构中使用递归，但再次强调，总是有这种权衡。
- en: because you can design something a，little more elegantly，doesn't necessarily
    mean that it's。always going to work for you，but more commonly are you likely to
    run，something called a。buffer overflow and this you will surely，overflow，is when
    you allocate an array and go too。far past the end of it or you use，malloc and
    you nonetheless go farther。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以设计一些更优雅的东西，并不一定意味着它总是对你有用，但更常见的是你可能会遇到一种叫做的。缓冲区溢出，而这种情况你肯定会溢出，是当你分配一个数组并超出其末尾时，或者你使用malloc，但你仍然超出。
- en: than the end of the chunk of memory that，you allocated a buffer。is just a chunk
    of memory so to speak，that you can use as you see fit。buffer overflow means going
    beyond the，boundaries，of that array uh you might use uh you。you're using right
    now video，you might know the phrase buffering from。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 比你分配的内存块的末尾更远，缓冲区。可以说只是你可以根据需要使用的一块内存。缓冲区溢出意味着超出该数组的边界，你可能正在使用，现在视频，你可能知道缓冲这个短语。
- en: videos like sort of buffering and，annoying you on netflix because there's，a
    spinning icon or whatnot。well that means exactly this a buffer in，the context
    of youtube or。zoom or netflix means some chunk of，memory，that was retrieved by
    a malloc or some。similar tool that gets，filled with bytes comprising your video，and
    it's finite which is why you can。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 视频像是在Netflix上缓冲，令人烦恼，因为有一个旋转的图标或其他什么。这意味着在YouTube或Zoom或Netflix的上下文中，缓冲区确实是一些通过malloc或其他类似工具检索到的，内存块，填充了包含你视频的字节，并且它是有限的，这就是为什么你可以。
- en: of video，before eventually if you're offline you，run out of video content to
    watch and。the stupid icon comes up and you can，watch no more because a buffer。is
    just a chunk of memory an array of，memory and if，netflix or google or others were
    to。implement their code on，unsafely they might very well go too far，past that
    boundary as well。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 视频，最终如果你离线，你会用完可以观看的视频内容，然后那个愚蠢的图标会出现，你将无法观看更多，因为一个缓冲区。只是内存的一块，一个内存数组，如果Netflix或谷歌或其他公司不安全地实施他们的代码，他们很可能会越过那个边界。
- en: so with all this said let's consider，just what，we've else we've been getting
    from these，take them。mostly off for you so the cs50 library，not only provides
    you with this，abstraction of a string。type which again doesn't give you any，new
    functionality strings in c。exist just not by that name they're，known more properly
    as char。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以说到这里，让我们考虑一下，除了我们从中得到的，主要是为你去掉的，cs50库不仅提供了这个，字符串类型的抽象。再次强调，它并没有给你任何，新的功能，C语言中的字符串确实存在，只是它们的名称更为恰当，称为char。
- en: stars but all of these functions in the，cs50 library，can be implemented with
    other actual c。using one，called scanf but you're going to see。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_33.png)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 星星，但这些功能在cs50库中，都可以用其他实际的C实现。使用一个，叫做scanf，但你会看到。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_33.png)
- en: immediately some of the dangers of using，something like scanf which is an。old-school
    function it was not designed，to be self-defensive like cs50s library。and so it's
    very easy to make mistakes，let me go ah**d for instance and create，a file，called
    scanf。c just to demonstrate this，library，just standardio。h and i'm going to give。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 立即就能看到使用像 `scanf` 这样的旧式函数的危险，它并不是设计得像 cs50 的库那样具有自我防护能力。因此，很容易出错。让我继续创建一个文件，叫做
    `scanf.c`，仅仅是为了演示这个库，标准输入输出头文件 `stdio.h`，我将会给。
- en: and i'm going to go ah**d and give，myself a variable x and i'm going to go，ahead
    and print out。quote unquote x colon just like cs50's，getint function does，and
    then i'm going to call scanf and i'm。going to go ah**d and say，scan from the user's
    keyboard in integer，and store it。in the location of x then i'm going to，go ah**d
    and print out，again x and a colon and a backslash。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我要继续给自己一个变量 x，然后我会打印出 “x:” 就像 cs50 的 `getint` 函数那样，然后我要调用 `scanf`，告诉它从用户的键盘输入一个整数，并存储在
    x 的位置。接着我会再次打印出 x 和一个冒号，后面跟一个换行符。
- en: percent i backslash n and i'm going to，print x so what's going on here。in line
    five i'm declaring a variable，called x just like in week one。line six just using
    printf like in week，one the interesting stuff seems to be。in line seven scanf
    is a function that，takes input from the user。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`%i\n`，然后我要打印 x，那么这里发生了什么呢？在第五行，我声明了一个变量 x，就像第一周一样。第六行像第一周那样使用 `printf`，有趣的事情似乎在第七行，`scanf`
    是一个从用户获取输入的函数。'
- en: just like get in getstring getflow and，so forth but it does it，only by you having
    to understand。example，if you want to have a function change，the contents of a
    variable。as we did with a and b and x and y，you have to pass in the address of
    the。variable whose value you want to change，you can't just pass in x itself so
    if we。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `get`、`getstring`、`getfloat` 等一样，但这仅仅是你需要理解。举个例子，如果你想让一个函数改变一个变量的内容，正如我们处理
    a、b、x 和 y 时那样，你必须传入你想要改变值的变量的地址，你不能仅仅传入 x 本身。
- en: didn't use the cs50 library in week one，you would have been writing code like。this
    just to get an int from the user，and you would have had to understand。pointers
    and you would have understand，ampersand and stars and so forth。it's just too much
    when all we care，about in the first weeks are like loops。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第一周没有使用 cs50 库，你会写这样的代码来获取用户输入的整数，你必须理解指针，还得理解符号和星号等等。在我们第一周所关心的只是循环时，这实在太复杂了。
- en: and variables and conditions and sort of，the fundamentals，but here we now have
    the ability to call。scanf tell it to scan from the user's，keyboard so to speak
    an，integer or percent f would give us a。float or other such codes，and pass in
    the address of x so that。scanf can go to that address and put the，integer from
    the user's keyboard there。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有变量和条件等基础知识，但现在我们可以调用 `scanf`，告诉它从用户的键盘输入一个整数，或者用 `%f` 来获取一个浮点数，或者其他类似的代码，并传入
    x 的地址，这样 `scanf` 就可以去那个地址，将用户键盘输入的整数放在那里。
- en: line eight is like week one stuff i'm，just printing out the value。and this is
    pretty safe i'm gonna go，ahead and make scanf，it compiles okay i'm gonna go ah**d
    and。run it i'm going to type in 50 and voila，weirdness，because if you type if
    you run this。program too and type in cat，well then x is zero and there's no error，glimpse
    that。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第八行是第一周的内容，我只是打印出值。这是相当安全的，我要继续使用 `scanf`，它能编译通过。我要运行它，输入 50，瞧，奇怪的事情发生了，因为如果你运行这个程序并输入猫，x
    就是零，并且没有错误，来看看这个。
- en: one of the features of the cs50 library，recall is that we keep prompting the，user
    again and again。if they're not cooperating and giving，you an int so that's one
    feature you get，from the library。but it turns out that getstring is even，more
    powerful，because if i go and change this program。now not to get an int but something，fancier
    like a string or wait。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: cs50 库的一个特点是，我们会不断地提示用户。如果他们不合作，没给你一个整数，这就是你从库中得到的一个特性。但是，实际上 `getstring` 更加强大，因为如果我去改变这个程序，不再获取一个整数，而是获取一些更复杂的东西，比如字符串，等等。
- en: we're calling it char star now i'm going，to go ah**d and do something very。similar
    i'm going to prompt the user for，a string s，and i'm going to use scanf and i'm
    going。to use percent s just like printf uses，percent s and i'm going to，to do，that
    s。is fundamentally an address so it，suffices just to pass in the address，that
    you already have。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在称其为 `char*`，我要继续做一些非常相似的事情，我会提示用户输入一个字符串 s，并使用 `scanf`，用 `%s`，就像 `printf`
    使用 `%s` 一样，我会做这个。s 从根本上是一个地址，因此只需传入你已经拥有的地址。
- en: now i'm going to go ah**d and print out，s colon，percent s backslash n and print
    out s。but when i compile this make scanf，it doesn't like it when i compile。variable
    s is uninitialized when used，be，sort of adventurous i can override makes。protections
    and i can just compile this，manually myself，worked。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我要继续打印，`s`冒号`%s`换行符并打印`s`。但是当我用`make`编译这个`scanf`时，它不喜欢这个。当使用时，变量`s`未初始化，有点冒险，我可以覆盖`make`的保护，我可以自己手动编译，这样是可行的。
- en: dot slash scanf let me go ah**d and type，in for instance，hi and you see weirdness
    null。well fortunately make an intern clang，were kind of，helping us help ourselves
    there it was。pointing out that you declared，pointer，but there's nothing there
    it's a garbage。value and so there's nowhere to put this，being smart enough，by
    not just blindly going there and。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 点斜杠`scanf`让我继续输入，比如说，嗨，你会看到奇怪的空值。幸运的是，创建一个内部`clang`，在某种程度上帮助我们帮助自己，它指出你声明了一个指针，但那里没有东西，那是一个垃圾值。因此没有地方可以放置这个，聪明的是不盲目地去那里。
- en: plopping h i，exclamation point in a null character，they're just leaving it alone
    and this，feature。saying you screwed up if you see null，you've done something wrong，it's
    just being generous and not。crashing on you if i actually want to，than this，and
    i need to either ma allocate myself。four bytes as we've done earlier today，or
    i could go back to week two stuff and。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将`h`、`i`、感叹号和空字符随意放置，他们只是将其留空，这个特性。如果你看到空值，你就搞砸了，表现得很慷慨，不会崩溃。如果我真的想要这个，我需要自己分配四个字节，正如我们今天早些时候所做的，或者我可以回到第二周的内容。
- en: say something like give me four bytes，this though gives me four bytes on the。stack
    somewhere down here in maine's，frame so to speak these rows are called，frames。if
    i use malloc instead it comes from，the so-called heap，which not pictured is sort
    of up here。and the only difference，is that if i'm using malloc i have to，use free
    if i'm using the stack。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 说点什么，比如给我四个字节，不过这在堆栈的某个地方给我四个字节，姑且称之为`main`的框架，这些行被称为框架。如果我使用`malloc`，它来自所谓的堆，虽然没有画出，但大致在上方。唯一的区别是，如果我使用`malloc`，我必须使用`free`，如果我使用堆栈。
- en: as i did in week two i don't have to use，so frankly，there's so much new stuff
    today i like。the idea of sticking with，the old school arrays so now though if
    i，go ah**d and make scanf。now it compiles with make if i then run，scanf and type
    in high，voila it seems to work but that's。because i was smart and anticipated
    that，four bytes，there，david how are you clearly more than four。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在第二周所做的那样，我不必使用，坦率地说，今天有太多新内容，我喜欢坚持使用老式数组。但现在如果我继续使用`scanf`，它在`make`时编译。如果我然后运行`scanf`并输入`hi`，哇，它似乎工作了，但那是因为我聪明，预见到了那四个字节。大卫，你明显超出了四个字节。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_35.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_35.png)'
- en: bytes and i hit enter now，something weird there happened like the，rest is just
    lost。and this would really be annoying and，very frustrating if you trying to get，class
    like。getstring avoids this for you getstring，calls malloc for you and it calls
    it。for as big a chunk of memory as the，short，we sort of watch what they're typing。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 字节和我按下回车键，现在发生了一些奇怪的事情，其他的就完全丢失了。如果你试图获取类，这会非常令人恼火和沮丧。`getstring`可以为你避免这个问题，`getstring`会为你调用`malloc`，并为你分配一块尽可能大的内存。我们有点在关注他们的输入。
- en: character by character by character，and we make sure to allocate or，reallocate
    just enough memory。typed in，so scanf is essentially how a function，like the cs50
    library works underneath，the hood but。it is doing all of this for you and as，soon
    as you take away，training wheels like that or frankly。libraries like that which
    it really is，at the end of the day it's not just a。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符接一个字符，我们确保分配或重新分配足够的内存。`scanf`本质上就是一个像`cs50`库这样的函数在底层工作的方式。但它为你完成了所有这些事情，一旦你去掉像这样的训练轮，或者坦率地说，这样的库，这确实是，归根结底，它不仅仅是。
- en: teaching tool it's a useful library，you have to start implementing more of。this
    low-level stuff yourself so again，there is a trade-off if you don't want，that's
    fine。now the onus is on you to avoid all of，these possible，error conditions all
    right。with that said we have one final feature，to give you in order to motivate
    this，week's problems。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 教学工具，这是一个有用的库，你必须开始自己实现更多的低级内容。所以，再次说，如果你不想这样，那没关系。现在的责任在于你避免所有这些可能的错误条件。好了，话虽如此，我们还有一个最后的特性，要为你提供，以激励本周的问题。
- en: wherein you'll actually explore and，manipulate and write code to change。files
    and for that we need one final，topic of file io，file io is the term of art that，describes。taking
    input and output from files，pretty much every program we've written，thus far just
    uses memory。like this here whereby you can put stuff，ends，boom it's gone the contents
    of memory。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你将实际探索和操作并编写代码以更改文件，为此我们需要文件输入输出的最后一个主题，文件I/O是描述从文件中获取输入和输出的术语。到目前为止，我们编写的每个程序几乎只使用内存。
- en: are gone files of course are where you，and i in the computing world。save our
    essays and documents and，resumes and all of that permanently。on your computer
    in c you have the，ability certainly to write code yourself。that saves files long
    term so for，instance let me go ah**d and write my。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样，你可以放东西，结束，内容就消失了，内存的内容就没了。当然，文件是你我在计算机世界中保存我们的论文、文档、简历等所有东西的地方，永久保存于你的计算机上。在C中，你当然有能力自己编写代码来长期保存文件，所以例如让我继续编写我的。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_37.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_37.png)'
- en: own program here a phone book program，numbers，in a file i'm going to go ah**d
    and。include just for convenience the cs50，library again because i don't want to，deal
    with scanf。i'm going to go ah**d and save this，incidentally as phonebook。c。i'm
    going to go ah**d and include not，just the cs50 library but standard io，and include。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里编写一个电话簿程序，将号码存储在文件中，我将继续包含**cs50**库，因为我不想处理`scanf`。我将把这个文件保存为phonebook.c。
- en: string dot h as well and i'm going to go，ahead in my main function and i'm going。to
    use a few new functions that we'll，see only briefly here，but in the next problems
    that will you。explore these in more detail，i'm going to give myself a pointer
    to a，file it turns out。weirdly that in all caps f-i-l-e this is，a new data type
    that does come with c。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 也包含string.h，我将在我的主函数中继续使用一些新函数，虽然我们在这里只会简要看到，但在接下来的问题中，你将更详细地探索这些。我将给自己一个文件指针，结果奇怪的是，用大写的F-I-L-E，这是C语言中的一种新数据类型。
- en: that represents a file so i'm going to，go ah**d and give myself a pointer to
    a，file。the address of a file and i'm going to，call the variable file i could call
    it f。i could call it x i'm going to call it，lowercase file，just to be clear and
    i'm going to use a。file open，and file open takes two arguments it，takes the first
    argument which is the。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的表示方法是，我将为一个文件给自己一个指针。我可以将其命名为file，也可以叫f，或者叫x，我决定称之为小写的file，以便明确。我将使用`file
    open`，它需要两个参数，第一个参数是。
- en: name of a file you want to open，i'm going to open a file called，phonebook。csv
    and then i'm going to go，ahead and open it specifically in append，in different
    ways。to read them that is just look at their，contents to write them which is to。change
    their contents entirely，add，row by row to them so to keep tacking on。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你想打开的文件名，我将打开一个名为phonebook.csv的文件，然后我将以不同的方式打开它，具体来说是以附加模式来读取它们，即查看其内容；写入则是完全更改其内容，逐行添加，以便不断增加。
- en: more information to them i'm going to go，ahead and just to be safe i'm going
    to，say if。file equals equals null because recall，that null signifies something
    went wrong。let's just return now maybe i mistyped，the name of the file maybe it
    doesn't。exist something went wrong potentially，i'm going to check for that by
    saying if。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向他们提供更多信息，我将继续并安全起见，我将说如果file等于null，因为回想一下，null表示出现了问题。我们就返回，可能我输入错误了文件名，可能它不存在，潜在地发生了什么问题，我将通过说如果来检查。
- en: file equals equals null，just quit out of the program now but，a string。but we
    can call that char star now，called name and i'm going to ask the，user for a name。and
    we've done this before i'm going to，go ah**d and ask them for a number。phone number
    and we've done this before，the only difference now is i'm calling，string char
    star。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果file等于null，就退出程序。我们可以称之为字符指针，现在叫name，我将询问用户的名字。我们之前做过，我将继续询问他们的电话号码，我们之前也做过，唯一的区别是我将调用字符串字符指针。
- en: and now here's the cool part it turns，out if i want to save this name and，csv。if
    unfamiliar popular in the consulting，world the analytics world，it's just a spreadsheet
    a comma。in excel，or numbers or google spreadsheet i'm，going to go ah**d and not
    print。f but fprintf to that file，a string，name，and the number and then down here
    i'm，going to close。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这很酷，如果我想将这个名称保存为 `csv`。如果不熟悉的话，这在咨询界和分析界很流行，它只是一个电子表格，一个用逗号分隔的表格。在 Excel、Numbers
    或 Google 电子表格中，我要去**做**，而不是打印 `f`，而是将字符串名称和数字 `fprintf` 到那个文件中，然后在这里我要关闭。
- en: the file so this is new fprintf is not，printf which prints to your screen。fprintf
    prints to a file so you have to，which is the，pointer to the file that you want
    to。send these new strings to，then you still provide a format string。which says
    hey fprintf this is the kind，of data i want to print，to the file and then you
    plug in the。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是新的，`fprintf` 不是 `printf`，后者是输出到你的屏幕。`fprintf` 是输出到一个文件，所以你需要一个指向你想要的文件的指针。然后你将这些新的字符串发送给它，你仍然需要提供一个格式字符串。这个字符串告诉
    `fprintf`，这是我想要输出到文件的数据类型，然后你就可以插入。
- en: with printf，and then lastly we close the file so in，short this program would
    seem to prompt。a human for a name and number，and then it's going to go ah**d and，file。so
    let me go ah**d and make phone book，okay no mistake so far，dot slash phone book
    david 949。468-2750，okay let me run it once more even though，nothing seems to happen。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `printf`，最后我们关闭文件，所以简而言之，这个程序似乎会提示人类输入姓名和号码，然后它将去**做**，文件。因此让我去**做**，制作电话簿，好吧到目前为止没有错误，点斜杠电话簿大卫
    949。468-2750，好吧让我再运行一次，尽管看起来没有发生任何事情。
- en: brian how about 617 495 1000，enter let me check my file browser here。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_39.png)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱恩，怎么样 617 495 1000，按回车让我检查一下我的文件浏览器。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_39.png)
- en: notice all of the files we've created，today including if i zoom in。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_41.png)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们今天创建的所有文件，包括如果我放大。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_41.png)
- en: not just phonebook。c but phonebook。csv，and if i double-click that notice what's，inside
    of this。of our numbers，and even cooler than that let me go，ahead and close this
    let me go ah**d and。download this file。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_43.png)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是 `phonebook.c`，还有 `phonebook.csv`，如果我双击那个，注意里面有什么。我们的数字，甚至比这更酷，让我去**做**，关闭这个，让我去**做**，下载这个文件。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_43.png)
- en: using the ide and that's going to put it，into my downloads folder let me go
    ah**d。and click on it and it's going to open。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_45.png)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 IDE，它会将文件放入我的下载文件夹，让我去**做**，点击它，它会打开。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_45.png)
- en: excel or numbers or whatever you happen，to have on your mac or pc。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_47.png)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Excel、Numbers 或你在 Mac 或 PC 上拥有的任何其他软件。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_47.png)
- en: i'm going to go ah**d and just proceed，formatting here，but i've opened up a
    spreadsheet that i。myself generated using，f open fprintf and f close，so already
    now that we have pointers at。our disposal can we actually manipulate，things like，files
    which is quite cool but we're。but with actual，recall，this kind of thinking here
    if you glance。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我要去**做**，继续在这里格式化，但我打开了一个电子表格，是我自己使用 `f open`、`fprintf` 和 `f close` 生成的。因此，现在我们有指针可以操作文件，这非常酷，但我们要记住，这种思维方式，如果你稍微瞥一眼。
- en: at this it's probably pretty cryptic it，looks like machine code，but it's not
    this is perhaps the。simplest representation，of a smiley face inside of a file
    if you，have a bitmap。file a map of bits a grid of bits those，bits quite simply
    could literally be。zeros and ones and if you assign the，color black to zero，and
    the color white to one you could。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很神秘，它看起来像机器代码，但并不是。这或许是文件中微笑表情最简单的表示形式。如果你有位图文件，一张比特图，多个比特的网格，这些比特很简单，可以是零和一。如果你将黑色分配给零，白色分配给一，你可以。
- en: actually think of this same grid of。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_49.png)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上想想这个相同的网格。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_49.png)
- en: zeros and ones as representing indeed a，smiley face in other words。here are
    some pixels we talked about，pixels in week zero pixels are just the，dots that
    compose。a graphic file on your computer and，pixels are everywhere all of us now。tuning
    in live via zoom or youtube or，the like we're watching streams of，multiple images，at
    like。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 零和一确实代表了一个微笑的表情。换句话说，这里有一些像素，我们在零周讨论过像素。像素就是组成计算机上图形文件的点，而像素无处不在。现在所有人都通过 Zoom
    或 YouTube 等平台实时收看，我们正在观看多幅图像的流。
- en: 20 something or 30 frames per second，images per second，now of course there's
    only so much。fidelity in these kinds of images，and it's quite common the case
    like on，tv and in movies like。if there's some bad guy that's been，picked up with
    some surveillance footage。or the like like invariably the folks on，kind of，enhance
    the video and zoom in and see，that reveals。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '每秒20到30帧，当然这些图像的清晰度是有限的，通常在电视和电影中都是如此。如果有一个坏人被监控视频拍到，通常人们会，增强视频并放大，看看那揭示了什么。 '
- en: who who committed some crime well that's，all kind of nonsense and it derives
    from，week。zero in fact just to poke fun at this，let me go ah**d and hit play on
    a few。seconds of this tv show here in the u。s，called csi，just to give you a sense
    of just how。commonplace this kind of。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '谁犯了一些罪，嗯，那都是些胡说八道，这源于，第一周。实际上只是为了嘲弄这个，让我来，**继续播放**这部美国的电视节目，叫做《CSI》，只是为了让你感受一下这种。 '
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_51.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_51.png)'
- en: logic is we know。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_53.png)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是我们知道的。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_53.png)
- en: that at 9 15 ray santoya was at the atm，so the question is what was he doing
    at。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_55.png)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在9 15，雷·圣托亚在ATM前，所以问题是他在那儿做什么。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_55.png)
- en: 9 16，shooting the nine millimeter at。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_57.png)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 9 16，使用九毫米手枪射击。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_57.png)
- en: something maybe he saw the sniper，or was working with it wait。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_59.png)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 也许他看到的是狙击手，或者在和它一起工作等等。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_59.png)
- en: bring his face up full screen，his glasses there's a reflection。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_61.png)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将他的脸放大到全屏，他的眼镜上有一个反射。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_61.png)
- en: that's baseball team that's their logo。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_63.png)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 那是棒球队，那是他们的标志。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_63.png)
- en: that's baseball team that's their logo，and he's talking to whoever's wearing
    a，jacket。we may have a witness to both shootings。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_65.png)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那是棒球队，那是他们的标志，他在和穿着夹克的人交谈。我们可能有目击者，目击了两起枪击事件。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_65.png)
- en: so unfortunately today will rather ruin，a lot of tv and movie for you because。you
    can't just zoom in infinitely and，see more information if that information。is
    not there at the end of the day，there's only a finite number of bits and，brian。and
    you might see that oh there's a，glint in his eye let's see。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '所以不幸的是，今天将会毁掉你对很多电视和电影的期待，因为你不能无限放大，看到更多的信息，如果那信息根本不存在，最终只存在有限数量的位和，布莱恩。你可能会看到，哦，他眼中有一丝光芒，让我们看看。 '
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_67.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_67.png)'
- en: what was being reflected in his eye，there and so if we zoom in on this image，here
    of brian。and maybe we zoom in a little further，like that's all that's actually
    there。like you can't just click the enhance，button and see more，because at the
    end of the day these are。just pixels and pixels per week zero are，just zeros and
    ones and finitely many so。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '他眼中反射的是什么，如果我们在这张布莱恩的图片上放大，或许我们再放大一点，实际上就只有这些。你不能只点击增强按钮看到更多，因为归根结底，这些只是像素，而像素在第一周就是，只有零和一，并且是有限的。 '
- en: so what you see is what you get now with，of this too，here let me just play one
    other short。clip from futurama which kind of hammers，home this point as well。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_69.png)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你所看到的就是你所得到的，现在，这里让我播放另外一个短片，来自《未来兄弟》，它也很好地强调了这一点。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_69.png)
- en: but more playfully so magnify that death，sphere。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_71.png)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是更加调皮地放大那个死亡球体。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_71.png)
- en: why is it still blurry that's all the，resolution we have，making it bigger doesn't
    make it clearer。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_73.png)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么仍然模糊，那就是我们所拥有的所有分辨率，放大并不会让它更清晰。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_73.png)
- en: it does on csi miami，so there we have two clips talking，rather to one another
    but i have to。update things for 2020，right you can't really pick up the the，internet
    these days or。magazine these days if you even would，that doesn't somehow mention
    machine。learning and artificial intelligence and，fancy algorithms by，which you
    can do things that previously。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '它在《CSI：迈阿密》中也有，所以我们有两个片段在互相谈论，但我必须为2020年更新一些内容，对吧？你如今在互联网上或杂志上，根本无法找到任何一篇不提到机器学习和人工智能，以及那些你能做以前无法做到的事情的复杂算法的内容。 '
- en: weren't quite possible and that's，actually kind of sort of the case you，might
    recall from week zero。that we found this beautiful um，watercolor painting in the
    harvard。archives that's only about like 11，inches tall total，and yet somehow it's
    13 feet tall here。behind me now normally if you were to，just enhance this watercolor
    painting。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 是不太可能的，这实际上是你可能还记得的情况，从零周开始。我们在哈佛档案馆发现了一幅美丽的水彩画，总共大约只有11英寸高，而现在却在我身后达到了13英尺的高度。通常，如果你只是增强这幅水彩画。
- en: it would start to look pretty stupid，pretty quickly with lots and lots of，camera。as
    the archives do to capture the，original image but we wanted to blow it。up to 13
    feet tall so that it would，whole time，some sense so，using long story short fancier，use。artificial
    intelligence machine learning，to actually analyze data。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不加限制地进行，它看起来会很快变得非常愚蠢，伴随着许多许多的相机。就像档案馆所做的那样，捕捉原始图像，但我们想把它放大到13英尺高，这样它会一直存在，在某种意义上，所以长话短说，使用更高级的人工智能机器学习，来实际分析数据。
- en: and find patterns where there weren't，that aren't necessarily visible to the，original
    here。and start to zoom in it looks pretty，good at this resolution but it's pretty，that
    this was。paint on an actual canvas so this was，just zooming in on photoshop but
    when，through fancy。machine learning based software，improve it，and actually see
    not just this window。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 并寻找那些并不一定在原始图像中可见的模式。开始放大，这个分辨率看起来相当不错，但实际上这是。涂在真实画布上的，这只是使用Photoshop放大，但当通过复杂的基于机器学习的软件时，改进它，实际上不仅仅是看到这个窗口。
- en: from the top of one of the buildings，photoshop，you can start to see more detail
    so this，in photoshop。this is after actually applying fancy，artificial intelligence
    algorithms that。notice wait a minute there's a little，discoloration there wait
    there's a，little discoloration there。and nowadays enhance is increasingly，becoming
    a thing，it's still inferring it's not。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从其中一栋建筑物的顶部，Photoshop，你可以开始看到更多细节，所以在Photoshop中。这是在实际应用了复杂的人工智能算法后，这些算法注意到，等一下，那儿有一点变色，等一下，那儿有一点变色。而如今，增强功能正变得越来越普遍，它仍在推断，并不是。
- en: resurrecting information that was，guess really，algorithmically to reconstruct
    what the，further。you can perhaps see that this is really，starting to get blurry
    if you just use。photoshop and keep zooming in，but if you run it through fancy
    enough。algorithms and start to notice slight，to the human eye，we can enhance that
    even further and you。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 复原信息实际上是通过算法来重构的，进一步说，你可能会看到这真的开始模糊了，如果你只是使用。Photoshop并不断放大，但如果你通过足够复杂的算法处理它，并开始注意到人眼看起来微小的差异，我们甚至可以进一步增强。
- en: can't do it infinitely so，and in some sense we're creating，information where
    there isn't。necessarily that information there so，whether or not these kinds of
    things。hold up in court is another question，but it can improve the fidelity of，us。to
    zoom in from 11 inches to 13 feet，instead so when it comes to manipulating，images
    ultimately。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是无限的，所以在某种意义上，我们在创造并不一定存在的信息。因此，这些东西是否在法庭上能够成立是另一个问题，但它可以提高我们的忠实度。从11英寸放大到13英尺，因此在操纵图像时，最终。
- en: we do have some programmatic，capabilities including this file pointer，like we
    just saw。and also a few other functions as well，and our final examples here will
    lay the，coming week。which is manipulate your very own，graphical files with a newfound。understanding
    of pointers and addresses，instance，i'm going to go ah**d and open up a，program
    here。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有一些程序能力，包括这个文件指针，就像我们刚刚看到的。还有一些其他功能，我们在这里的最终示例将在接下来的一周中展示。也就是用新获得的指针和地址理解，操作你自己的图形文件，实例，我要去啊**d打开一个程序。
- en: called give me just one second i'm going，to open up a program here，called jpeg。c。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_75.png)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做等我一下，我要打开一个程序，叫做jpeg.c。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_75.png)
- en: and this program jpeg。c which i wrote in，advance which is on the course's website，type。called
    byte it turns out in c there's no，common definition of what a byte is a。byte as
    we know it is eight bits，and it turns out the simplest way to。create a byte is
    to define our own just，like we've defined a string。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序jpeg.c是我提前写好的，已在课程网站上发布，类型。叫做字节，事实证明在C语言中，没有对字节的共同定义。我们所知道的字节是八位，而创建字节的最简单方法就是自己定义，就像我们定义字符串一样。
- en: just like we've defined other types too，like a student，in order or a person
    rather in order to。code just，declares a data type called byte using，another more
    arcane data type called u。and a underscore t，but more on that in the problem set
    this，just did events something called byte。notice in this program i'm resurrecting，the
    idea from week two of command line，the user。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们定义其他类型一样，像学生，为了或一个人，实际上是为了。代码只是声明一个称为字节的数据类型，使用另一种更晦涩的数据类型，称为u。和一个下划线t，但在问题集中会更详细，这只是做了一个称为字节的事件。注意在这个程序中，我复活了第二周命令行中的概念，用户。
- en: notice that i'm checking if the user，returning one，immediately to signify error
    in line 17。i'm using my new technique i'm opening a，file，using the name of the
    file that the。human typed at the command line，and this time i'm opening it to
    read it，with quote unquote r，so if。bang file that is if exclamation point，file
    or if file equals equals no those，mean the same thing。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我在检查用户，立即返回1以表示第17行中的错误。我在使用我的新技术，打开一个文件，使用人类在命令行中输入的文件名，这次我打开它以读取，带引号的“r”，所以如果，bang文件，即如果感叹号，文件或如果文件等于不，那些意味着同样的事情。
- en: i can go ah**d and return one signifying，an error，down here i'm doing something
    a little。clever it turns out，that with very high probability you can，determine
    if any file is a jpeg。by looking only at its first three bytes，a lot of file formats
    have what are，called magic numbers。at the beginning of their files and，these are
    industry standard。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以去ah**d并返回1，表示一个错误，在这里我做一些小聪明，结果是，以非常高的概率你可以，仅通过查看文件的前三个字节，确定任何文件是否为jpeg。许多文件格式在其文件开头有称为魔法数字的东西，而这些是行业标准。
- en: numbers one or two or three or more of，them that is just commonly expected to。be
    at the beginning of a file so that a，program can quickly check is this a jpeg。is
    this a gif is this a word document is，this excel file，they tend to have these
    numbers at the。beginning of them and jpegs，have a sequence of bytes that we're。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一或二或三或更多的数字，通常被期望在文件的开头，以便程序可以快速检查这是否是jpeg。这是gif，是否是word文档，是否是excel文件，它们在开头往往有这些数字，而jpeg有一个字节序列，我们。
- en: about to see this line of code 24 here，as you'll see in the next problem set。is
    how you might give yourself a buffer，of bytes specifically an array。of three bytes
    this next line of code as，you'll see this coming week is called。f read f read
    as the name suggests reads，a file，and it's a little fancy to use but。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关于看到这行代码24，在接下来的问题集中，你将看到这如何给自己提供一个字节的缓冲区，特别是一个三字节的数组。接下来的这行代码，你将在本周看到，称为f read，f
    read顾名思义是读取一个文件，使用起来有点复杂，但。
- en: you'll get more comfortable with this，over time，it reads into this buffer its
    first。argument the size of，this data type the size of a byte and it，reads in this
    many。of those data types from this file，so again it's four arguments which is。kind
    of a lot from what we've seen，but it reads from this file three。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你会对此感到更舒适，它读取到这个缓冲区的第一个。参数是这个数据类型的大小，即字节的大小，并且它从这个文件中读取这么多。这是四个参数，从我们看到的来看，这有点多，但它从这个文件中读取三个。
- en: bytes into this array aka buffer，called bytes so this is just how you，file。but
    read it from it and then here notice，circle，if bytes bracket 0 equals equals oxf。and
    bytes bracket 1 equals ox d8 and，bytes bracket 2 equals ox。ff this definitely
    looks cryptic to you，but that's just because i looked up in，the manual for jpegs。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 字节进入这个数组，也就是缓冲区，称为字节，所以这就是你，文件的方式。但从中读取它，然后注意这里，圆圈，如果字节的括号0等于oxf，且字节的括号1等于ox
    d8，且字节的括号2等于ox。ff 这对你来说确实显得神秘，但这只是因为我在手册中查找了jpeg。
- en: and it turns out that almost any j any，jpeg rather，must start with oxf oxd8
    oxf。those are the first three bytes of any，jpeg on your mac your pc on the internet。there
    are always those three bytes it，turns out the fourth byte。further decides whether
    or not a file is，actually a jpeg but the algorithm for，simple。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 结果几乎任何jpeg，必须以oxf oxd8 oxf开头。这是你在Mac、PC或互联网上的任何jpeg的前三个字节。总是有这三个字节，结果第四个字节进一步决定一个文件是否，实际上是jpeg，但算法很简单。
- en: if the first three bytes of a file are，those maybe you have a jpeg。but if you
    don't have exactly those，jpeg，and so what i can do here is as follows，in today's
    code。let me go ah**d and grab two other files，that i brought with me。and one happens
    to be a photograph again，uh give me one second i brought with me。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件的前三个字节是这些，或许你有一个jpeg。但如果你没有完全是这些jpeg，我可以在今天的代码中这样做。让我去ah**d并抓取两个我带来的其他文件，其中一个恰好是一张照片，呃给我一秒，我带来了。
- en: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_77.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fac50ad528c92cf9095b8bd7a26a8b0_77.png)'
- en: a few files，one of which is called brian。jpg which。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_79.png)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件，其中一个叫做brian.jpg。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_79.png)
- en: is the same photo of brian，and then i have a gif which of course is，not a jpeg。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_81.png)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是brian的同一张照片，然后我有一个gif，当然不是jpeg。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_81.png)
- en: that is this cat typing here and what i，effectively have in front of me now
    is a。program that if i do make jpeg，because this profile is jpeg。c and i run，dot
    slash jpeg。i can type in something like cat dot gif，at the command line as an
    argument hit。enter and i should see no，the command line，as an argument i see maybe
    and again。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一只猫在打字，而我面前实际上有一个程序，如果我生成jpeg，因为这个配置文件是jpeg.c，我运行`./jpeg`，可以在命令行输入类似cat.gif的内容作为参数，按下回车，我应该看到没有，作为参数的命令行，我也许会再看到一次。
- en: maybe only because the algorithm for，actually adjudicating whether something，than
    that。but indeed i can now access the，individual bytes and therefore，pixels it
    would seem of a fo of a。this，let me go ah**d and show you one last，program that
    we wrote deliberately in。advance just to give you a taste of，what's coming with
    the next problem set。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 也许只有因为实际上判定某事的算法，而不是那样。但确实我现在可以访问，单独的字节，因此，像素似乎是的fo的。这，让我去啊**d并给你展示一个我们故意提前写的，程序，只是为了让你尝试一下，接下来问题集的内容。
- en: this program is a re-implementation，of the program you've probably used one，or
    more times called cp。recall that cp is a program in the ide，and in linux more
    generally that allows。you to copy a file you do cp，name，how does this work i now
    have all of the。building blocks with which to copy，byte up here，i'm defining main
    as taking command line。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是你可能使用过一次或多次的程序cp的重新实现。回想一下cp是一个程序，在ide和更一般的linux中，允许你复制文件，你执行`cp filename`，这怎么工作，我现在拥有所有的构建块来复制，字节在这里，我将`main`定义为接受命令行参数。
- en: arguments here and notice one change，i'm not using the cs50 library so even，what
    was previously。string in week two，is now char star even here for argv，i'm making
    sure that the human types in。three words the program's name and the，source file
    and the destination。file i'm using f open again i'm opening，the source file，here
    from arg v1 i'm making sure it's。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数，注意一个变化，我没有使用cs50库，因此即使是之前的字符串在第二周，现在也是`char *`，即使在这里对于argv，我确保人类输入三句话，程序的名称，源文件和目标文件。我再次使用`fopen`，打开源文件，这里来自`argv[1]`，我确保它是。
- en: not null and then i'm quitting if it is，i'm then here's something new opening。the
    destination file here，also with f open but i'm using quote，unquote w i'm opening
    one file with r。one file for w because i want to read，from one and right to the
    other，and then down here this loop。another，i'm giving myself a buffer of one byte，so
    just a temporary variable just like。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 不是空的，然后我如果是空的就退出，接着这里有些新的东西，打开目标文件，这里也是使用`fopen`，但我使用的是“w”，我打开一个文件为“r”，一个文件为“w”，因为我想从一个读取并写入到另一个，然后在这里这个循环，另一个，我给自己一个一字节的缓冲区，所以只是一个临时变量，就像。
- en: brian's temp or empty glass，and i'm using this function f read i'm，reading into
    that buffer。via its address the size of a byte，specifically one byte，same loop。i'm
    writing from that buffer the size of，a byte specifically one byte。to the destination
    so literally the cp，program you might have seen me use or。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: brian的临时或空玻璃，我使用这个函数`fread`，我正在通过它的地址将一个字节的大小读入那个缓冲区，具体来说是一个字节，使用相同的循环。我正在将这个缓冲区的字节大小，具体来说是一个字节，写入目标，所以字面上讲，你可能看到我使用的cp程序。
- en: you yourself have used to copy files，is literally doing this it's opening one。file
    iterating over all of its bytes and，and then lastly，it's closing the file and
    these last two。examples deliberately fast because this，whole week will be spent，diving
    into file i o and images。uh thereof but all that you uh，all the all that we've
    done is use this，f read f open and f right。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己已经用来复制文件，实际上是在做这个，它打开一个文件，遍历它的所有字节，然后最后，关闭文件，这最后两个例子故意快速，因为这一整周将花费时间深入文件输入输出和图像。呃，但我们所做的就是使用这个，`fread`、`fopen`和`fwrite`。
- en: and f close to manipulate those very，files so for instance if i now do this。let
    me do make cp okay seems to compile，dot slash cp。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_83.png)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 和`fclose`来操作那些文件，所以例如如果我现在这样做。让我做`make cp`，好像编译通过了，`./cp`。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_83.png)
- en: brian。jpg how about brian2。jpg，and hit enter nothing seems to happen，but if
    i go in here。we have a second。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_85.png)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: brian.jpg，如何关于brian2.jpg，按下回车似乎没有发生什么，但如果我进去这里，我们有第二个。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_85.png)
- en: copy of brian's actual file so this，multiple，file formats for images the first
    is。jpegs and we will give you a so-called，forensic image，of a whole bunch of photographs
    from a。digital memory card，in fact it's very common these days，certainly in law
    enforcement to take。forensic copies of hard drives of media，sticks of phones and
    other devices。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: brian的实际文件副本，因此，这有多种图像文件格式，第一个是jpegs，我们将给你一个所谓的法医图像，来自数码记忆卡的一堆照片，事实上，今天这非常普遍，尤其是在执法中，获取硬盘、媒体棒、手机和其他设备的法医副本。
- en: and then analyze them for data that's，been lost or corrupted or deleted。we'll
    do exactly that whereby you'll，write a program that recovers jpegs that。have been
    accidentally deleted，from like a digital memory card and will。give you all copies
    of that memory card，by making a forensic image of it that is，camera。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后分析它们，以找回丢失、损坏或删除的数据。我们将确切地这样做，你将编写一个程序来恢复意外删除的jpegs，就像从数码记忆卡中删除的，并将给你那张记忆卡的所有副本，通过制作一个法医图像，也就是相机。
- en: and giving them to you in a file that，you can f read，and then f right from we'll
    also。introduce you to bitmap files bmps，uh popularized by the windows operating。system
    for wallpapers and the like，but we'll use them to implement using，pointers and
    using file io。your very own instagram like filter so，we'll take this picture here
    of the，week's footbridge。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它们放在一个文件中，你可以读取，然后从中进行操作，我们还会介绍位图文件bmps，它们在Windows操作系统中被普及，用于墙纸等，但我们将利用它们来实现你自己的类似Instagram的滤镜，所以我们将以本周的步行桥这张图片为例。
- en: here in cambridge massachusetts by，harvard and we'll have you implement a。number
    of filters taking this original，image for instance and，desaturating it making
    it black and。white by iterating over all of the，pixels top to bottom left to right。and
    recognizing any colors like red or，green or blue or anything in between。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在麻省剑桥的哈佛大学，我们将让你实现多个滤镜，举例来说，从这个原始图像开始，并通过自上而下、自左而右迭代所有像素，将其去饱和，使其变成黑白，识别任何颜色，如红色、绿色或蓝色，或介于两者之间的颜色。
- en: and changing them to some shade of gray，doing a sepia filter making things look。old
    school like this photo was taken，many years ago，by similarly applying a heuristic
    that。alters the colors，of all of the pixels in this picture，we'll have you flip
    it around。so you have to put this pixel over here，and this pixel over there。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它们更改为某种灰色阴影，做一个棕褐色滤镜，使事情看起来。老派，就像这张照片是多年前拍摄的一样，通过类似应用的启发式方法，改变这张图片中所有像素的颜色，我们会让你翻转它。因此你必须把这个像素放在这里，把那个像素放在那儿。
- en: and you'll appreciate exactly how files，are implemented，you'll，which。no uh accident
    makes it harder to see，what's going on here，because you're starting to now average。other
    to kind of，make it harder to，see here and so even if you so choose。have you implement
    edge detection of，feeling more comfortable where you find。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你会确切地理解文件是如何实现的，实际上。这并不是意外，使得这里的情况更难以看清，因为你开始在平均值之间来，变得更难以看清，所以即使你选择实现边缘检测，你会感觉更舒适。
- en: the sort of edges of all of the physical，objects in these pictures。in order
    to actually detect them in code，and create visual art like this now this。was a
    lot and i know pointers are，generally considered to be among the。more challenging
    features of c and，certainly programming in general so if，you're feeling like。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图片中所有物理对象的边缘。为了在代码中实际检测它们，并创造出这样的视觉艺术，现在这确实是很多内容，我知道指针通常被认为是C语言中更具挑战性的特性，当然在编程中也是如此，因此如果你感觉。
- en: it's been quite a bit it was but you do，now have the ability。either today or
    in the very near term to，understand even xkcd comics like this，there has seen。so
    our final look for you today is on，this joke here，you，moments，a very。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_87.png)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 已经过去了一段时间，但你现在有能力。无论是今天还是在不久的将来，甚至可以理解像这样的xkcd漫画，所以我们今天的最后一幕是关于这个笑话，你，时刻，一个非常。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_87.png)
- en: geeky laughter and i see some smiles at，least which is reassuring。this was then
    cs50 we'll see you next。![](img/6fac50ad528c92cf9095b8bd7a26a8b0_89.png)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 狂 geeky 的笑声，我看到至少有一些微笑，这让人感到安慰。这就是cs50，我们下次见！[](img/6fac50ad528c92cf9095b8bd7a26a8b0_89.png)
