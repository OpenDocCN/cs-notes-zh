- en: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P11：L5- 数据结构 2（数组、链表、树、哈希表、字典树、堆、栈、队列） - ShowMeAI
    - BV1Hh411W7Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈佛CS50-CS ｜ 计算机科学导论(2020·完整版) - P11：L5- 数据结构 2（数组、链表、树、哈希表、字典树、堆、栈、队列） - ShowMeAI
    - BV1Hh411W7Up
- en: all right we are back and recall that we，began today，by revisiting arrays and
    pointing out。that searching is great in arrays if you，log，n that we liked back
    from week zero but。as soon as you want to start dynamically，modifying an array
    it gets very，expensive quickly。it might take you a big o of n steps to，into a
    new，bigger array and honestly over time，lots of data。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们回来了，回想一下我们今天开始时，重新审视数组并指出，如果你做对了，数组搜索是很好的，但一旦你想动态修改数组，它的成本迅速变得非常高。可能需要你大约n步进入一个新的、更大的数组，老实说，随着时间的推移，数据量很大。
- en: even big o of n is expensive like you，don't want to be constantly copying and。copying
    and copying all of your data，avoid that，by using pointers and in turn stitching。together
    these structured called，linked list albeit at a price of，spending more memory。but
    with that additional memory that，additional cost comes dynamism so that。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是大O的n也是昂贵的，你不想不断地复制你的所有数据，避免这种情况的方法是使用指针，反过来将这些结构称为链表拼接在一起，尽管这会增加内存消耗。但有了额外的内存和成本，带来了动态性。
- en: if we want we can even achieve constant，time when it comes to inserting。but
    of course then we have to sacrifice，things like sortability so。this theme of trade-offs
    we've just seen，a few examples of actual c。programs that implement first the，old-school
    array per week zero where we，unfortunately。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，插入时甚至可以实现常数时间，但当然我们必须牺牲像可排序性这样的东西。所以我们刚刚看到的这个权衡主题有几个实际的C程序示例，首先是旧式的数组，正如第零周所示。
- en: we painted ourselves into a corner using，the bracket notation alone。so we deployed
    instead malloc which is，more versatile tool that lets us get as。much memory as
    we want，and we use that to recreate the idea of，a list implemented as arrays。but
    even then we saw that i had to copy，using a for loop or we had a copy using，again。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅使用括号表示法将自己困在了一个角落。所以我们改为使用malloc，这是一个更灵活的工具，可以让我们获取我们想要的内存，并用它来重新创建作为数组实现的列表的概念。但即便如此，我们也看到我必须使用for循环进行复制，或者再次进行复制。
- en: for these small programs you don't even，like that，but for large real-world software
    all of。up quickly，so it's best if we can try to avoid it，all together and achieve
    dynamism。so the code by which you can，add to linked lists dynamically is，actually
    part of the challenge for。problem set five this coming week but，let's see some
    of the building blocks，allocate。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些小程序你甚至不喜欢这样，但对于大型真实世界的软件，所有这些都迅速累积，因此最好尽量避免这一切，达到动态性。所以你可以动态添加到链表的代码实际上是下周问题集五的挑战的一部分，但让我们看看一些构建块，分配。
- en: nodes and stitch them together when we，know in advance，how many we want which
    is not going to，now。is indeed the case because i only want，three of these things
    so i'm going to go。back to my program from before and i'm，inside of main，and i'm
    going to go ah**d and declare。myself a type，called struct node initially with
    a，number inside of it，inside of that。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 节点并将它们连接在一起，当我们提前知道我们想要多少个时，这并不是现在的情况，因为我只想要这三样东西，所以我将返回之前的程序，在main内部，我要去声明一个类型，称为结构节点，最初里面有一个数字。
- en: and i'm going to call this whole thing，quite simply node so that's quite。similar
    to what we did with a person but，now it's a little fancier in that i'm。giving
    the structure itself a temporary，name struck node，i'm referring to that temporary
    name。inside of the structure so that i can，have a pointer there too，now node。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将称这个整体为节点，这很简单，和我们之前处理的一个人类似，但现在更复杂一些，因为我给结构本身起了个临时名字“节点”，我在结构内部提到这个临时名字，这样我也可以在这里有一个指针，现在是节点。
- en: now let's go ah**d and actually use this，thing inside of main，so let me go ah**d
    and create an empty。linked list，the simplest way to translate the simple，block
    with which we began today。is just doing new node star list，semicolon，unfortunately
    anytime you declare in a。variable that does not have an assigned，value it's garbage，and
    garbage is bad in the world of。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续，实际上在main中使用这个东西，让我先创建一个空的链表，最简单的方式是用新节点指针创建列表，不幸的是，每当你声明一个没有赋值的变量，它就是垃圾，而垃圾在编程世界中是坏的。
- en: pointers again to be clear，and you do not，explicitly initialize its value。to
    be something like null pointing at，the ground but instead leave it as a。garbage
    value it's the sort of，pointing this way，this way this other way that is to say。you
    might accidentally in your own code，follow this arrow to a completely bogus，have。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 指针再次明确，你不需要显式地初始化它的值。不要像null指向地面那样，而是保持为垃圾值，指向这个方向，这个方向，那种方向，也就是说，你可能在自己的代码中意外地跟随这个箭头指向一个完全虚假的地方。
- en: what are called segmentation faults as，some of you might have experienced。already
    with problem set four，when you touch memory that you shouldn't。so garbage values
    are bad ever more so，reason，so you rarely want to do this you almost。always want
    to initialize the pointer，to some known value in the absence of an，actual address。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 什么叫做段错误，有些人可能已经在问题集四中体验过。当你触碰不该触碰的内存时，会发生这种情况。因此，垃圾值是坏的，更不用说原因了，所以你很少想这样做，你几乎总是希望将指针初始化为某个已知值，而不是实际地址的缺失。
- en: we're going to use null to indicate that，there's nothing there，but that's deliberate
    on our part now。suppose i want to insert just as i did，physically by lugging the
    block number，one onto stage before。let me go ah**d and allocate a node，we'll call
    it n temporarily。using malloc this time asking for the，size of a node，so the story
    is now changing i'm not，individual。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用null来表示那里没有东西，但这是我们故意为之的。假设我想插入，就像我之前通过搬运块编号1上台那样。让我继续分配一个节点，我们暂时称之为n。使用malloc，这次请求一个节点的大小，所以故事现在在变化，我不再是个体。
- en: nodes inside of which is enough room，node，and this size of operator figures
    out。![](img/048b7fb31d80a37bbdc5116c8b723aaf_1.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 节点内部有足够的空间，节点，这个操作符的大小会算出。![](img/048b7fb31d80a37bbdc5116c8b723aaf_1.png)
- en: from the definition of this structure，needed to store an。![](img/048b7fb31d80a37bbdc5116c8b723aaf_3.png)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个结构的定义，需要存储一个。![](img/048b7fb31d80a37bbdc5116c8b723aaf_3.png)
- en: integer and a pointer to a struct node，so as always now i'm always going to，check
    if n。equals equals null i'm going to get out，of this program immediately and just。return
    one because something went wrong，and there's just not enough memory。but if all
    went well i'm going to go，ahead now and go into that node。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 整数和一个指向结构节点的指针，因此我将总是检查n是否等于null。如果是，我将立即退出这个程序，只返回1，因为发生了错误，并且没有足够的内存。但是如果一切顺利，我将继续进入那个节点。
- en: n i'm going to go into its number field，and assign it to value 1。and i'm going
    to go into that node n and，go into its next field and for now，assign it the value
    null。so this is as though i've just allocated，the wooden block with a 1 in it，to
    null。now i'm going to go ah**d and update the，list itself to point，called list。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将进入它的数字字段，并将其赋值为1。接着，我将进入那个节点n，并进入它的下一个字段，暂时将其赋值为null。这就好像我刚刚将带有1的木块分配给null。现在，我将继续更新列表本身，使其指向名为list。
- en: is the variable by which i'm，representing the whole list，and now that i have
    an actual node to。point to i'm setting，list which again is a pointer to a node。equal
    to whatever n is the address of an，actual node，so at this point in the story i
    have the。small wooden block connected to the，larger block containing one let's。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我表示整个列表的变量，现在我有一个实际的节点可以指向，我将list设置为n的地址，它指向一个实际的节点，因此在故事的这一点上，我有一个小木块连接到包含1的较大块上。
- en: suppose for the sake of discussion i now，want to add the number two to this
    list，an integer。i'm going to go ah**d and allocate n，using malloc，giving myself
    the size of another node。i'm going to again just going to check，ahead and，free
    the list so i don't leak memory。then let me go ah**d and return one so，sure i
    free，any memory i've already allocated before。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了讨论，我现在想将数字2添加到这个列表，一个整数。我将继续使用malloc分配n，给自己一个新的节点的大小。我将再次检查，并释放列表，以便不泄漏内存。然后让我继续返回1，以确保我释放了之前已分配的任何内存。
- en: but if all goes well，and that's what i'm hoping for i'm going，to go ah**d and
    go into this node n。and store in its number field literally，the number two，and
    then now because this thing also。inserted in sorted order for now，next，as null
    and if i indeed want to put。this number two node after the number，list，i can go
    to the next node and inside of。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果一切顺利，我希望如此，我将继续进入这个节点n。并在它的数字字段中字面地存储数字2，然后因为这个东西也是以有序方式插入的，所以现在下一个是null。如果我确实想把这个数字2的节点放在数字列表后面，我可以去下一个节点，并在内部。
- en: its value i can say n，so this line of code here starts at the，little block。follows
    the arrow and then updates the，next pointer of that first node，address。of this
    new node n and then lastly let's，do one more of these so n gets。malloc sizeof
    node one last time，let me go ah**d and do my sanity check。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其值我可以说是n，所以这里的这行代码从小块开始，跟随箭头，然后更新第一个节点的下一个指针，指向这个新节点n的地址。最后，让我们再做一次，所以n最后一次调用`malloc
    sizeof node`，让我先做个健全性检查。
- en: one more time if n equals equals null，something bad happened，so now i'm going
    to go ah**d and don't。worry about the syntax just yet but i'm，going to go ah**d
    and free。list next and i'm going to go ah**d and，free list and then i'm going
    to go ah**d，time。that's just in the corner case where，something bad happened but
    if nothing。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果n等于null，那就发生了坏事，所以现在我将继续，不必担心语法，只需继续调用`free list next`，然后继续调用`free list`，接着我将继续，处理时间。这只是一个角落案例，在那里发生了一些坏事，但如果没有发生坏事。
- en: bad happened i'm going to update the，number field to be three。i'm going to update
    the next field to be，null and now i'm going to update the，list，one。n and then
    here after this i can proceed，to print all of these things if i want，this。with
    a loop the loop is going to look a，case，but it turns out we can use for loops。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生了错误，我将把数字字段更新为三。我将把下一个字段更新为null，现在我要更新列表，n。在这里，之后我可以继续打印这些内容，如果我愿意的话，可以用循环，循环的样子很简单，但事实证明我们可以使用for循环。
- en: pretty powerfully here too but at this，point in the story，my list pointer is
    pointing at the one。node which is pointing at the two node，which is pointing at
    the three node and。again as someone observed earlier，it's not common to use this
    double arrow，notation in this case。i bet i could actually use an in a loop，to
    iterate over these things one at a。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里也相当强大，但在故事的这个节点上，我的列表指针指向一个节点，这个节点指向第二个节点，第二个节点又指向第三个节点。正如之前有人观察到的，这种双箭头符号在这种情况下并不常见。我敢打赌，我实际上可以在循环中使用它，逐一迭代这些东西。
- en: time and we can see this here，when it's time to print let me go ah**d，and do
    this。four and instead of using i because，there really aren't any numbers in。question
    this is no longer an array，so i can't use squ*re bracket notation。or pointer arithmetic
    i need to use，pointers，so this might feel a little weird at。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 时候，我们可以在打印时看到这一点，让我继续做这个。四，而不是使用i，因为实际上没有数字在问题中，这不再是一个数组，所以我不能使用方括号符号或指针算术，我需要使用指针，因此这可能感觉有点奇怪。
- en: first but there's nothing stopping me，with a for loop from doing this。give me
    a temporary pointer to a node，called temp，and initialize it to be whatever is
    at。the beginning of the list，keep doing the following so long as temp，does not
    equal null。and on each iteration of this loop don't，do something like i plus plus
    which。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，但没有什么能阻止我用for循环来做到这一点。给我一个临时指针，叫做temp，并将其初始化为列表开头的内容，只要temp不等于null，继续执行以下操作。在每次循环迭代中，不要像i++那样做。
- en: again is not relevant now，but go ah**d and update my temporary，pointer。to be
    whatever the value of the，temporary pointer's next field is。so this looks crazy
    cryptic most likely，especially if you're new to pointers。as of last week as most
    of you are but，it's the same idea as a typical for loop。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再说一次，现在不相关，但继续更新我的临时指针，让它等于临时指针的下一个字段的值。因此，这看起来可能非常晦涩，尤其是如果你对指针是新手的话。就像上周一样，因为你们大多数人都是，但它和典型的for循环是同一个思路。
- en: you initialize some variable before the，semicolon，you check some condition after
    the first。semicolon and you perform an，update of that variable after the second。semicolon
    in this case they're not，integers though，instead i'm saying give myself a。temporary
    pointer to the beginning of，the list like my finger pointing at or。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第一个分号之前初始化某个变量，在第一个分号之后检查某个条件，并在第二个分号之后更新该变量。在这种情况下，它们不是整数，而是我说给自己一个指向列表开头的临时指针，就像我的手指指向的那样。
- en: if you prefer the foam finger pointing，at some node，in the list go ah**d and
    call that。temporary variable，temp，is not null that is so long as it's，block。what
    do i want to do let me go ah**d and，print out，using printf and percent i as always。whatever
    value，is in the number field of that，node there and that's it with this，simple
    for loop。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢指向列表中某个节点的泡沫手指，就去叫那个临时变量temp，只要它不为null。那是只要它是块的。我想做什么，让我继续，使用printf和%li打印出那个节点的数字字段中的值，就这样，使用这个简单的for循环。
- en: relatively simple for loop i can，essentially point at the very first node，in
    my list。and keep updating it to the next field，updating it to the next field updating，this。until
    my finger sort of walks off the，end of the list of wooden blocks，thereby pointing
    it null ox0。at which point the loop stops and，there's nothing more to print so
    in。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相对简单的`for`循环，我可以本质上指向我列表中的第一个节点。并不断更新到下一个字段，更新到下一个字段，直到我的手指在木块列表的末尾走出，从而指向`null`。在这一点上，循环停止，没有更多的内容可打印。
- en: answer to that question earlier，do we need to use this double arrow，notation
    short answer no。this is kind of the secret ingredient，here this syntax inside
    of the for loop。takes whatever you're pointing at，follows one arrow，and then updates
    the temporary variable。now to point at that structure instead，so this is kind
    of the equivalent in the，doing i。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前那个问题的回答，我们是否需要使用这个双箭头符号，简短的回答是：不需要。这是这里的秘密成分，这段语法在循环内部。它指向你所指向的对象，跟随一个箭头，然后更新临时变量。现在改为指向那个结构，这在做`i`时是等效的。
- en: plus plus but it's not as simple as i，plus plus you can't just look one byte。to
    the right or to the left，follow an arrow，but by reassigning this temporary。variable
    to wherever you just followed，it's a way of following each of these，orange arrows
    as we did。![](img/048b7fb31d80a37bbdc5116c8b723aaf_5.png)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不像我`++`那么简单，你不能仅仅看一个字节。向右或向左，跟随一个箭头，但通过重新分配这个临时变量到你刚刚跟随的地方，这是一种跟随每一个这些橙色箭头的方法，就像我们做的那样。![](img/048b7fb31d80a37bbdc5116c8b723aaf_5.png)
- en: physically a moment ago after this，i should for good measure go ah**d and。free
    the whole list and let me just，linked list，i can actually do something like this。while
    list not equals null，so while the whole list itself does not。equal null go ah**d
    and get a temporary，pointer like this，to the next field so i remember what。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才这一刻，在此之后，为了好好检查，我应该去`ah**d`并释放整个列表，让我只是链表，我实际上可以做这样的事情。当列表不等于`null`时，所以当整个列表本身不等于`null`时，继续`ah**d`并像这样获取一个临时指针，指向下一个字段，这样我就能记住。
- en: comes after the current，head of the list free the list node，itself and then。![](img/048b7fb31d80a37bbdc5116c8b723aaf_7.png)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前列表头之后，释放列表节点本身。然后。![](img/048b7fb31d80a37bbdc5116c8b723aaf_7.png)
- en: update list to be temp so again this，probably looks crazy，cryptic and certainly
    in the coming days。especially with problem set 5，you'll work through this kind
    of logic a。little more logically a little more。![](img/048b7fb31d80a37bbdc5116c8b723aaf_9.png)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更新列表为临时变量，所以这看起来可能很疯狂，很难理解，尤其是在接下来的几天，特别是针对问题集5，你会以更逻辑的方式更好地理解这种逻辑。![](img/048b7fb31d80a37bbdc5116c8b723aaf_9.png)
- en: pictorially perhaps，but what am i doing here first i'm going。to do the following
    so long as my linked，list is not null and if i've got three。nodes in it by definition
    it's not null，free，all of the memory i've allocated from。left to right so to speak，so
    how do i do that well if i've got two。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像上来看，我在这里做什么，首先，只要我的链表不是`null`，我就会做以下操作。如果我有三个节点，根据定义它就不是`null`，释放我从左到右分配的所有内存。那么我该如何做到呢？如果我有两个。
- en: wooden block if i've got a wooden block，in front of me，yet，because that wooden
    block recall。contains the pointer to the next，node so if i free this memory，prematurely。i've
    then stranded all subsequent nodes，because they are no longer accessible。once
    i've told the computer，you can take back this chunk of memory，for the first node
    so。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 木块，如果我面前有一个木块，因为那个木块包含指向下一个节点的指针，所以如果我提前释放这个内存，我就把所有后续节点困在了那，因为一旦我告诉计算机，你可以回收这个内存块，对于第一个节点。
- en: this line of code here on line 52 is，just saying temporarily give me a，variable
    called temp。first node，point at the next node so it's like，using my right hand
    to point at the，the next node。so that i can then on line 53 free the，list itself
    which，is should not be taken literally list。represents the first，node in the linked
    list not the whole，thing so when you say free list。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第52行的代码只是说暂时给我一个名为`temp`的变量。第一个节点，指向下一个节点，这就像用我的右手指向下一个节点。这样我就可以在第53行释放列表本身，这不应被字面理解，列表表示链表中的第一个节点，而不是整体。所以当你说释放列表。
- en: that's like freeing just the current，node but that's okay even now。this memory
    has been given back i still，have my left hand pointing at every。subsequent node
    by way of the next one，so now i can update list to equal that，temporary variable。and
    just continue this loop so it's a。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像释放当前节点，但即便如此，这也是可以的。这个内存已经被归还，我的左手仍然指向每一个后续节点，通过下一个节点来实现，所以现在我可以将列表更新为等于那个临时变量。并继续这个循环，所以这是一个。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_11.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_11.png)'
- en: way of sort of pac-man style like，left to right，by freeing the first node the
    second。node the third node and then you're done，but by using a temporary variable
    to。look one step ahead to make sure you，don't chomp，the free the memory too soon
    and。therefore lose access to，all of those subsequent nodes all right。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 像是吃豆人风格那样，从左到右，通过释放第一个节点，第二个节点，第三个节点，然后就完成了，但通过使用一个临时变量提前查看，确保你不会过早地释放内存，从而失去对所有后续节点的访问，好吧。
- en: that was a big program but it was meant，to be in succession starting with。an
    array transitioning into a，dynamically allocated array，followed by finally an
    implementation。using linked list albeit hard coded to，support only three nodes，but
    in that example do you see some。sample syntax by which you can，manipulate，these
    kinds of nodes questions or，confusion that i can。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个大程序，但它是按顺序进行的，从数组开始，过渡到动态分配的数组，最后是一个实现。使用链表，虽然是硬编码的，只支持三个节点，但在这个例子中，你看到了一些可以操作这些节点的样本语法吗？有问题或困惑吗？
- en: help address anything on your end brian，yeah someone asked similar to one of
    the。examples you did before why could we not，have just done malloc，three times
    sizeof node to get three。nodes and do it that way，really good question could i
    not just，use malloc and allocate all three at。once absolutely yes that is completely，your
    prerogative i did it a little more。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助解决你那边的任何问题，布赖恩，是的，有人问了类似你之前做的一个例子，为什么我们不能仅仅使用`malloc`三次`sizeof node`来获取三个节点，以那种方式来做，真是个好问题，难道我不能就这样使用`malloc`一次性分配三个节点吗？当然可以，这完全是你的选择，我做得更。
- en: pedantically one at a time，but you could absolutely do it all three，at once。you
    would then need to use some pointer，arithmetic though，or you would need to use
    squ*re bracket。memory，as essentially an array of nodes and，then stitch them together
    so。i am assuming for demonstration purposes，that even though we have these little，syntax。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 严谨地说，一次一个，但你绝对可以一次性处理所有三个。那样的话，你就需要使用一些指针算术，或者你需要使用方括号。内存，作为节点的一个数组，然后将它们拼接在一起。因此我假设出于演示目的，尽管我们有这些小的语法。
- en: in a real world system you're not going，to be inserting one，then two then three
    odds are you're。going to be inserting one，sometime passes then you want to insert。two
    so you allocate more memory then，some more time passes，then you want to insert
    three and so。there's gaps in between these，these chunks of code in the real world，other
    questions or confusion。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实世界系统中，你不会一个一个地插入，一般是先插入一个，然后经过一段时间，你想插入两个，所以你分配更多内存，然后再过一段时间，你想插入三个，因此在这些代码块之间有间隔。在现实世界中，还有其他问题或困惑吗？
- en: yeah another question came in why would，malloc ever fail to allocate memory。why
    would malik ever fail it's rarely，of memory，so essentially if you're writing such
    a。memory hungry program with so many，of data，you may very well run out of memory。maybe
    that's two gigabytes maybe it's，four gigabytes or more，but malloc may very well
    return null to。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，还有另一个问题，为什么`malloc`会失败分配内存？`malloc`为何会失败？这很少见，如果你在编写这样一个。内存消耗大的程序时，有那么多数据，你可能会耗尽内存。也许是两千兆，也许是四千兆或更多，但`malloc`很可能会返回null。
- en: you and so you should，always check for it in fact i dare say，on macs and pcs。one
    of the most common reasons to this，day for programs to freeze。to crash for your
    whole computer to，reboot is truly because someone did。something stupid like i've
    done multiple，times now already today and last week。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该总是检查，事实上，我敢说，在Mac和PC上。这至今仍然是程序冻结的最常见原因之一。导致你整个计算机重启的，确实是因为有人做了愚蠢的事情，就像我今天和上周已经做过的多次那样。
- en: by touching memory that you shouldn't，have so in problem set four and now five。anytime
    you experience one of those，segmentation faults whereby your program，just crashes。that
    is the uh the problem set，version of like your whole mac or pc，crashing because
    someone more。experienced than you made that same，mistake in their code，let's take
    a quick。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过触碰不该触碰的内存，所以在问题集四和现在的五中。每当你遇到那些段错误时，你的程序就崩溃了。这就像是你整台Mac或PC崩溃，因为比你更有经验的人在他们的代码中犯了同样的错误，让我们快速。
- en: final example involving linked lists，which again are this very。one-dimensional
    structure left to right，and then we'll add a second dimension。and see what that
    buys us but we've，still have our list，but it's first pointing at the number。pointing
    to some，other chunk of memory that's been，the number four。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的例子涉及链表，这实际上是这种一维结构，从左到右，然后我们会添加第二个维度，看看这能给我们带来什么，但我们仍然有我们的列表，它首先指向数字，指向另一个内存块，那里是数字四。
- en: and this then is the number five so we，have a linked list of size three。but
    i've deliberately spread the numbers，out this time two four five because。suppose
    that we do want to insert more，numbers into this list。but in sorted order it turns
    out that we，have to think a little bit differently。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数字五，所以我们有一个大小为三的链表。但我故意将数字分散开来，二、四、五，因为假设我们确实想将更多数字插入这个列表。但按排序顺序进行，结果是我们需要换一种思维。
- en: when we're adding nodes not to the end，and not to the beginning。but in the middle
    like when we want to，allocate more nodes in the middle。there's a bit more work
    that actually，has to happen，so how might we go about doing this。suppose that we
    want to allocate for，instance the number，one and we want to add the number one。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在中间添加节点时，不是在末尾，也不是在开头。比如说，我们想在中间分配更多的节点，这实际上需要更多的工作，那么我们应该如何去做呢？假设我们想分配数字一，并且我们想添加数字一。
- en: well we could use code like this this is，the same code as we used before。we
    allocate the size of a node we check，whether it equals null we。initialize it with
    the value we care，to null，and pictorially it might look like this。it's kind of
    floating somewhere in the，variable n。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这样的代码，这与我们之前使用的代码相同。我们分配一个节点的大小，检查它是否等于 null，然后用我们关心的值初始化它为 null，图示上可能看起来像这样。它有点漂浮在变量
    n 中。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_13.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_13.png)'
- en: no longer pictured that i'm just，pointing at when i allocate the number。one
    so what does this look like this is，like having the number one，put it in place
    we。got lucky and there's a chunk of memory，right there so what do i want to now
    do。well i want to go ah**d and connect this，so what i could do，just intuitively
    if i one should go。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不再显示的节点，我只是指向我分配的数字一。那么这看起来是什么样子呢？就像将数字一放到位，我们运气不错，那里正好有一块内存。那么我现在想要做什么呢？我想去啊**d并连接这个，所以我可以直观地去做。
- en: before two i can unplug this，and i can plug this into here which，makes sense。but
    there's already a problem if i have，done nothing else up until this point。i have
    just orphaned three nodes，two four and five to orphan a node means。to forget where
    it is and if i don't，have another variable in my code or if，pointing at。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我可以拔掉这个，然后将这个插入这里，这很合理。但如果我在此之前没有做任何其他事情，那么已经存在一个问题。我已经孤立了三个节点，二、四和五。孤立一个节点意味着忘记它在哪里，如果我在代码中没有另一个变量，或者指向。
- en: the original beginning of the list i，have literally orphans the rest of the，list
    and the technical。implication of that per last week is，that now i have a massive
    memory leak，nodes in memory。that you can literally never get back，until you reboot
    the computer for，instance or the program。![](img/048b7fb31d80a37bbdc5116c8b723aaf_15.png)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的最初部分，我字面上孤立了剩余的列表，上周的技术含义是，现在我有一个巨大的内存泄漏，内存中的节点，直到你重启计算机或程序，你实际上再也无法找回。![](img/048b7fb31d80a37bbdc5116c8b723aaf_15.png)
- en: quits and the operating system cleans，things up for you so you don't want to。do
    this like order of operations，actually matters so what i should，probably do，first。i
    should probably recognize that well，list，so what i should really do is point this，sort
    of。do it a little sloppily like that but，let me stipulate those are both pointing，at
    the same node。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 退出时，操作系统会为你清理，因此你不想这样做。运算顺序实际上很重要，所以我应该首先，可能应该意识到这一点，列表，所以我真正应该做的是指向这个，大致上这样做，但让我规定这两个都指向同一个节点。
- en: now that my new node aka n in the code i，showed is pointing at this thing。now
    i can do kind of a switcheroo，because i'm already pointing at。the final destination
    there and now i，my list，this is n therefore i have variables，insert。that correctly
    so long story short order，of operations matters so。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的新节点，也就是代码中显示的 n，指向这个东西。现在我可以进行某种交换，因为我已经指向了最终目的地，现在我的列表是 n，因此我有插入的变量，这样是正确的，长话短说，运算顺序很重要。
- en: graphically if i were to do this as，before just by saying，list equals n if this
    is n，first。bad things are going to happen indeed we，end up orphaning，2 4 and 5
    thereby leaking a significant。amount of memory potentially and leaking，any memory
    typically is bad。so i don't want to do that so let's look，at the correct code
    the correct code is。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我像之前一样从图形上处理这个，简单说列表等于n，如果这是n，坏事就会发生。的确，我们最终会使2、4和5孤立，从而泄漏大量内存，通常泄漏任何内存都是坏事。所以我不想那样做，来看看正确的代码，正确的代码是。
- en: going to be to start at n，here，to point at the same thing as the list，was originally
    pointing at。and then go ah**d and update the list，such that both of them are currently，pointing
    in duplicate。![](img/048b7fb31d80a37bbdc5116c8b723aaf_17.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我要从n开始，指向与列表最初指向的相同的东西。然后去更新列表，使得它们两个当前都指向重复的内容。![](img/048b7fb31d80a37bbdc5116c8b723aaf_17.png)
- en: then update the list to point to the new，node so again，the code's a little different
    this time。from before because before we kept，adding it to the end or i，proposed
    verbally that we just added to。the beginning here we're adding it。![](img/048b7fb31d80a37bbdc5116c8b723aaf_19.png)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新列表以指向新的节点，所以这次代码与之前有些不同，因为之前我们一直把它加到末尾，或者我口头提议我们把它加到开头，这里我们在添加它。![](img/048b7fb31d80a37bbdc5116c8b723aaf_19.png)
- en: indeed at the beginning and so the，actual steps the actual code。are a little
    bit different well let's do，one final example if we want to allocate。three well
    i gotta malloc another node，the number three，suppose that ends up somewhere in
    the。computer's memory，here，so now three is in place how do i now。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在开始时，实际的步骤和代码有点不同。让我们做一个最后的例子，如果我们想分配三个，那我得再malloc一个节点，数字三，假设它最后在计算机的内存中某个地方，这样三就到位了，我现在该怎么做。
- en: insert this thing well similar to before，i'm not going to want to update this。pointer
    and go like this，and then plug this guy in over here，because now i've orphaned
    those two。nodes so that again is the wrong step，when you're in beside the middle
    of a，insert into the middle。if you care about inserting in sorted，order this should
    be updated first。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样好好插入这个东西，我不想更新它。指针这样移动，然后把这个插头插到这里，因为现在我把这两个孤立了。所以这又是错误的步骤，当你在中间插入时。如果你关心以有序方式插入，这应该先更新。
- en: and odds are i should kind of cheat and，there's only，one physical plug at the
    moment so we'll。just pretend that this is working，safely say that，n and the previous
    note are already，it's safe。for me to unplug this one and go ah**d，and update this
    final arrow，to point at the new node。in the correct location so let's see，that
    in code again if i go here。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该有点作弊，现在只有一个物理插头，所以我们就假装这在正常工作，安全地说n和之前的节点已经安全。我可以拔掉这个，然后去更新最后一个箭头，指向新节点的正确位置。让我们再看看代码，如果我去这里。
- en: i've got graphically the number the node，three kind of floating in space，also
    at the four。point to the three，the goal being again to avoid any，leaking of memory
    or。orphaning of nodes all right，we are about to leave linked lists。behind because
    as multiple of you have，noted or probably，thought they're good but maybe not great。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图形上看到节点数字三漂浮在空间中，同时也在四处指向三，目标再次是避免任何内存泄漏或节点孤立。好了，我们即将抛弃链表，因为正如你们中的多位所注意到或可能想到的那样，它们是好的，但可能不是很出色。
- en: they're good in that they are dynamic，and i can add to them as by inserting
    at，the beginning。if i really want and don't care about，sorted order but there's
    still a good，amount of work to do。if i want to keep them in sorted order，and i
    insert them in the middle or the。end because that's like big o of n，if i keep
    traversing all of these darn。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的优点在于它们是动态的，我可以通过在开头插入来添加它们。如果我真的想这样做，而不关心有序，但如果我想保持有序，在中间或末尾插入就还有很多工作要做，因为那是O(n)，如果我一直遍历这些东西的话。
- en: arrows so we get the dynamism but we，increase，but we fundamentally have opened
    up a。whole new world to ourselves we can now，memory，using pointers as our thread
    if you will。we can just use memory as a canvas，painting on it any values we want
    and we，values are，dimensional。left to right what if we give ourselves，a second
    dimension，what if we start thinking sort of not。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头使我们获得了动态性，但我们增加了，我们从根本上为自己打开了一个全新的世界，我们现在可以使用指针作为线索来使用内存。我们可以把内存当作画布，随意绘制任何我们想要的值，而我们的值是二维的。左右的维度，如果我们给自己一个第二维度，假设我们开始思考一些不同的东西。
- en: left right but also left right，up down so again this is meaningless to。the computer
    the computer just thinks of，memory as being bite0123。but we humans can kind of
    think of these，data structures a little more abstractly，about them。in a way familiar
    perhaps to us in the，real world trees not the ones so much。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 左右，但同时也上下，所以对计算机来说这没有意义，计算机只是将内存视为字节0123。但我们人类可以更抽象地思考这些数据结构，以一种对我们现实世界熟悉的方式，树木而不是那么多。
- en: that grow from the ground，but if you're familiar with family trees。where you
    might have a matriarch or，patriarch and then sort of descendants。hanging off of
    them graphically on a，piece of paper something you might have。made in grade school
    for instance，we can leverage this idea of a tree，structure that has a root。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从地面生长而来，但如果你熟悉家谱，你可能会有一个家长或祖先，然后有后代在纸上的图形上挂着，比如你在小学时可能制作过的那样。我们可以利用这种树结构的想法，它有一个根。
- en: that kind of branches and branches and，branches and grows，top to bottom so again
    more like a。family tree than an actual tree，in the soil so with trees it turns
    out。this idea of a tree we can take some of，the lessons learned from。linked lists
    but we can gain back some，of the features of arrays。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分支和生长，从上到下，实际上更像是一个家谱，而不是土壤中的真正树。因此，树的这个概念，我们可以从链表中吸取一些教训，但我们也可以重新获得数组的一些特性。
- en: and we can do that as follows consider，gonna，we're about to call a binary search
    tree，from the first。new，one week two，whenever and it's of size seven and，recall
    that if it's sorted we can apply。binary search to this array and that's，value，we
    can start looking in the middle then。we can go either left or right，halfway between
    each and then we can，similarly go left。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式进行，考虑一下，我们即将调用一个从第一个新节点开始的二叉搜索树，它的大小为七，回想一下，如果它是有序的，我们可以对这个数组应用二分搜索，并从中间开始查找。然后我们可以左右分半，接着类似地向左移动。
- en: or right so binary search on a，was big o of，having him having。the problem again
    and again uh define it，tearing the phone book in half。again and again and again
    but the，problem with binary search is that it，requires that you use，you。have to
    be able to index into the array，in constant time，using simple arithmetic like
    bracket。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以二分搜索的复杂度是大 O，反复地把电话簿对折。问题是二分搜索要求你能够以常数时间通过简单的算术（如括号）索引数组。
- en: zero bracket n minus one，bracket n minus one divided by two to，get the halfway
    point you have to be。able to do arithmetic，on the data structure and we've just，proposed
    getting rid of。that random access by you more，transitioning to a dynamic data，an
    array。but what if we do this what if you and i，start thinking not on one dimension。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始到 n 减一，再到 n 减一除以二，得到中间点。你必须能够对数据结构进行算术运算，我们刚才提议摆脱随机访问，而是更多地过渡到动态数据数组。但如果我们这样做，如果你和我开始思考，不再局限于一个维度。
- en: but on two dimensions and what if we，alter our thinking to be like this。so think
    of an array perhaps as being a，two-dimensional structure that has not，only width
    or length。but also height and so we maintain its，seams visually this relationship
    between。all of these values but you know what we，can stitch，all of these values
    together using what。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但在两个维度上，如果我们改变思维方式，想象一下。可以将数组视为一个二维结构，不仅有宽度和长度，还有高度，因此我们在视觉上保持它的缝合，所有这些值之间的关系，但你知道我们可以用什么将所有这些值缝合在一起。
- en: well pointers pointers are this new，together，things in memory if the things
    in memory。are numbers that's fine they're integers，but if we throw a little more
    memory at。them if we use a node and we kind of，wrap the integer in a node。such
    that that node contains not only，numbers but pointers，we could probably draw a
    picture like。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是将内存中的事物结合在一起的新东西。如果内存中的事物是数字，那很好，它们是整数，但如果我们为它们投入更多内存，使用一个节点，将整数包装在节点中，使得该节点不仅包含数字，还包含指针，我们可能可以画出一幅图。
- en: this not unlike，a family tree where there's a root node，at the very top in this
    case and then。children so to speak left child and，right child，and that definition
    repeats again and。again and it turns out that computer，scientists do use this
    data structure，linked。list where you can add more more nodes，to the tree，by just
    adding more and more squ*res。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就像家谱一样，根节点在最上面，然后是孩子，左孩子和右孩子，这一定义重复出现。事实证明，计算机科学家确实使用这种数据结构，链表，你可以通过添加更多的节点来向树中添加更多的元素。
- en: even lower than the one the three the，five and the seven and just use more。pointers
    to kind of stitch them together，to sort of grow the tree，but。a good computer scientist
    would，recognize that you shouldn't just put。these numbers in random locations，your
    time，you should use some algorithm and notice。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至低于1、3、5和7，只需使用更多指针将它们拼接在一起，以便成长这棵树。但一个好的计算机科学家会认识到，你不应该随便把这些数字放在随机位置，你的时间应该使用某种算法并注意。
- en: does anyone notice the pattern，to this tree can anyone verbalize or，textualize
    in the chat，nodes。in this tree they're not randomly，ordered they're very deliberately。ordered
    left to right top to bottom in a，certain way can anyone put their finger，on。what
    the definition of this thing is，what is the most important，characteristic besides
    it just being。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有人注意到这棵树的模式吗？谁能在聊天中用语言或文本来表达一下这些节点？在这棵树中，它们并不是随机排列的，而是非常有意图地从左到右、从上到下，以某种方式排列的。谁能指出这个东西的定义是什么，除了它只是被绘制出来。
- en: drawn like，you have put in the middle of them，on top of them you have put the
    middle。you have put two，between 5 and 7 you have put 6，so on top of them you have
    put the，middle number。exactly there's this pattern to all of，the numbers between
    1 and 3 is 2 between，5 and 7 is 6。have to be the，middle number per se i can generalize
    it，pick，any node in this tree so to speak its。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 像你在它们中间放置的那样，在它们的上面你放置了中间的数字。在5和7之间你放置了6，所以在它们的上面你放置了中间数字。确切地说，这个模式适用于所有的数字，在1和3之间是2，在5和7之间是6。必须是中间数字，换句话说，我可以概括它，选择这个树中的任何节点。
- en: left child will be less than its value，and its right child will be greater than，again。so
    here's four it's left child is two，that's less than here's four it's right。child
    to six that's greater than we can，do this again let's go to two。its left child
    is one which is less its，right child is three which is more。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它的左子节点将小于它的值，而它的右子节点将大于它。比如4，它的左子节点是2，小于4；它的右子节点是6，大于4。我们可以再做一次，去看2。它的左子节点是1，较小；它的右子节点是3，较大。
- en: six its left child is five which is less，six it's right child to seven。which
    is more and so this is actually if，you don't mind the，uh revisiting recursion
    from last week。recursive，data structure so it's not only，recursive，by calling
    themselves a data structure。can also be recursive after all，what is this thing
    this is a tree yes，i'll stipulate，trees。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于6，它的左子节点是5，较小；它的右子节点是7，较大。因此，这实际上是一个递归数据结构，如果你不介意上周回顾递归的话。递归不仅是通过调用自身的数据结构，它在某种程度上也是递归的。毕竟，这是什么东西？这是树，是的，我会承认，树。
- en: right this node here number four，technically has two children and each of，those
    children。is itself a tree it's a smaller tree but，it's the same exact definition
    again，data structure。it's actually going to be an opportunity，to use recursive
    code which we'll take a。look at in just a moment but for now，notice what we've
    achieved again the。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的节点4，从技术上讲有两个子节点，而每个子节点本身就是一棵树，它是一棵更小的树，但其定义是完全相同的，再次是数据结构。这实际上将是一个使用递归代码的机会，我们很快会看到，但现在注意我们又取得了什么成就。
- en: dynamism of using pointers so that we，can if we want，add more nodes to this
    tree as by。stringing them along the bottom in the，correct order and yet we've
    preserved an，important order。this data structure，binary search tree by making
    sure that，left child is always less。right child is always more because now，we
    can go about searching this thing。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针的动态性，这样我们如果想的话，可以通过在底部按正确的顺序串联更多节点来添加更多节点，同时我们也保留了一个重要的顺序。这个数据结构是二叉搜索树，确保左子节点总是较小，右子节点总是较大，因为现在我们可以开始搜索这个东西。
- en: more efficiently how well if i want to，search for the number three what do i
    do。well i start at the beginning of the，tree just like with an um，a linked list
    you start at the end of。list，so with the tree you start with the root，search for
    three，well what do i do well three is。obviously less than four，so just like in
    week zero where i tore，of this as like。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更有效率。那么，如果我想搜索数字3，我该怎么办呢？我从树的开头开始，就像在链表中，你从列表的末尾开始。因此，在树中，你从根节点开始，搜索3。那么我该怎么办呢？3显然小于4，就像在第零周时我拆解它一样。
- en: chopping down half of the tree because，definitely，not going to be anywhere over
    here so we。the number two，this is another tree it's just a smaller，sub tree if
    you will how do i find the。number three well i look to the right，because it's
    greater than，and boom i found it but by contrast。eight，i would start here i would
    look here i，would look here and then conclude no。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 削减树的一半，因为显然不会在这里，所以我们。数字二，这是另一棵树，只是一个更小的子树。我要如何找到数字三呢？我看右边，因为它更大，砰，我找到了。但相反的，八，我会从这里开始，我会在这里看，我会在这里看，然后得出结论：没有。
- en: it's not there but again every time i，search for that eight，i'm ignoring this
    half of the tree this。half of the sub tree，and so forth so you're going to achieve。it
    would seem the same kind of power the，same kind of performance as we saw from。week
    zero so how do we translate this，idea now into code，we have all the building blocks
    already。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它不在那里，但每次我搜索八时，我都在忽略这棵树的一半，这个子树的一半，等等，所以看起来你会实现与我们在零周时看到的相同类型的能力和性能。那么我们如何将这个想法转化为代码呢？我们已经有了所有的构建块。
- en: let me go ah**d and propose that instead，of the node we used before。for a linked
    list which looked like this，with a number and one pointer called。next but again
    we could have called，those things anything，let's go ah**d and make room for not。just
    a number，left，one that i'll call right both of those，is still a pointer to a struct
    node。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我继续提议，使用之前的节点，而不是我们之前使用的。对于一个链表，它看起来像这样，有一个数字和一个称为`next`的指针，但我们可以把这些东西称为任何名字。让我们继续并为不仅仅是一个数字留出空间，左边的一个，我称之为右边的两个，仍然是指向一个结构体节点的指针。
- en: so same terminology as before but now i，have two pointers instead of one。so
    that one can conceptually point to，tree，one can point to the right and point to，a
    larger sub-tree。so how do we go about implementing，something like binary search
    well let's，recursion。really gets kind of cool we kind of，forced it when building
    morrow's pyramid。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以用之前的术语，但现在我有两个指针，而不是一个。这样一个可以概念上指向树，另一个可以指向右边，并指向一个更大的子树。我们如何实现类似二分搜索的东西呢？好吧，让我们来讨论递归。构建摩罗金字塔时，我们强迫它变得相当酷。
- en: with recursion like yeah you can do it，but like and yes the pyramid was i，claimed
    a recursive。physical structure or virtual structure，pointers，now recursion really
    starts to shine so。let's consider this，if i declare a function in c whose，a number。it's
    going to by definition search from，the root on down，how do we implement this well
    my。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归，没错，你可以这样做，但金字塔确实是我所称的递归。物理结构或虚拟结构，指针，现在递归真正开始闪耀。那么，让我们考虑一下，如果我在C中声明一个函数，它是一个数字。它将根据定义从根节点向下搜索，我们如何实现这一点呢？我会。
- en: function i'll propose is going to return，a bool true or false。the number is
    in the tree yes or no it's，going to take two arguments，a pointer to a node aka
    tree。i could call it root or anything else，and it's going to take a number which
    is。the number i care about whether it's，four or six or eight or anything else
    so。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提出的函数将返回一个布尔值，true或false。这个数字是否在树中，是或否，它将接受两个参数，一个指向节点的指针，也就是树。我可以称它为根节点或其他任何名称，它将接受一个数字，就是我关心的数字，无论是四、六、八还是其他任何数字。
- en: what's going to be my first，chunk of code well let me do the best，practice that
    i keep preaching。anytime you're dealing with pointers，check for null so that your
    program。doesn't freeze or crash or bad thing，happens because who knows maybe you。will
    accidentally or maybe intentionally，pass this function a null pointer，screw up。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一段代码将是什么呢？让我来做我一直在宣扬的最佳实践。每当你处理指针时，要检查是否为null，这样你的程序就不会冻结、崩溃或发生其他坏事。因为谁知道，也许你会不小心或者故意地把一个null指针传递给这个函数，搞砸了。
- en: and that's okay so long as your code is，for null，if so if the tree is null that
    is。there's no tree there，obviously the number's not present so，you just return
    false。so that's one of our base cases so to，speak else，than，the tree's own number
    so again this。arrow notation means，take tree which is a node star so take，this
    pointer，its own。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这没关系，只要你的代码针对null，如果树是null的话。显然那里没有树，所以数字不在那儿，你就返回false。这是我们的一个基本情况，除了树本身的数字。再次强调，这个箭头符号表示，获取树，这是一个节点指针，所以获取这个指针，它自己。
- en: number field if the number you're，looking for from the argument。is less than
    the number in the tree's，own number field，well that means that you want to go
    left。and whereas in the phone book i went to，the left of the phone book here we're。going
    to go to the left，sub-tree but how do i search a sub-tree，here's where it's important
    that a。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字字段中，如果你要查找的数字来自参数，并且小于树自身的数字字段，那么这意味着你想要向左移动。而在电话簿中我会去电话簿的左边，这里我们要去左子树，但我该如何搜索子树呢，这里重要的是一个。
- en: tree is a tree is a recursive data，structure a tree，before，so i already have
    code by which i can。search a smaller tree，subtree，as expressed here which means
    start at，the current node and。go to the left child and pass in the，same number
    the number's not changing。but the tree is getting smaller i've，effectively in
    code，chopped the tree in half and i'm。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 树就是树，这是一种递归数据结构，树在之前已经存在，所以我已经有了可以用来搜索较小树的代码，子树，如此表达意味着从当前节点开始，走向左子节点，并传入相同的数字，数字没有变化，但树在缩小，我已经在代码中有效地将树一分为二。
- en: ignoring the right half and i'm，returning whatever that answer is。otherwise
    if the number i care about is，greater than the number in the current。node do the
    opposite search，number，so again just like with the phone book。it kept getting
    smaller and smaller，here i keep searching a smaller and，smaller sub tree。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略右半边，我将返回那个答案。否则，如果我关心的数字大于当前节点中的数字，就进行相反的搜索。因此，就像在电话簿中一样，它不断变小，这里我一直在搜索更小的子树。
- en: because i keep chopping off branches，left or right as i go from top to bottom。there's
    one final case and let me toss，this out up to the，toss this out to the group there's
    a。fourth case，verbally or textually what else should i，be checking for and doing
    here。a few people are suggesting if the tree，itself is the number，if the tree
    itself contains the number。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在从上到下的过程中不断削减分支，左或右。还有一种最终情况，让我把这个抛出来，抛给大家，第四种情况，口头或文本上还有什么我应该检查和做的。一些人建议，如果树本身就是这个数字，如果树本身包含这个数字。
- en: yeah so if，the number in the tree equals equals the，number i'm looking for，true。and
    this is where the code again gets，kind of recursion rather。gets a little mind
    bending i only have，false up here，true here but not in either of these，middle
    two。branches no pun intended if you will but，that's okay，because my code is designed
    in such a。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，所以如果树中的数字等于我正在查找的数字，那就为真。这时代码又变得有些令人困惑，只有上面是假的，下面是对的，但在这两个中间分支中没有，毫无讽刺之意，但没关系，因为我的代码设计成这样。
- en: way that if i search the left subtree，i'm at the，leaf of the tree so to speak
    then it's。going to return false so that's fine，that's like if i search for the
    number。eight it's not even in the tree，i'm only going to realize that once i。fall
    off the end of the tree and see，oops null，i'll just return false but if i ever
    see。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我搜索左子树，换句话说，我在树的叶子上，那么它将返回假，因此没关系，如果我搜索数字八，它甚至不在树中，我只会在掉出树的末端，看到，哎呀，空值，我将返回假，但如果我看到。
- en: the number along the way，calls，to search these two recursive calls to，buck。instead
    of answering true or false，themselves they're returning whatever。the answer to
    a smaller question is，by searching the left or right tree，instead respectively。so
    again this is where recursion starts，to get not really forced or。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，调用了这两个递归调用来搜索，而不是自己回答真或假，而是返回较小问题的答案，通过分别搜索左树或右树。所以再一次，这就是递归开始变得不是强制性的或。
- en: even necessarily as really as forced，but really as appropriate when your data。is
    itself recursive then recursion in as，a coding technique，really rather shines
    so if ultimately。we have oh and minor optimization as we，scratch，we of course
    don't need to explicitly。check if the number is equal we can get，assume，that if
    it's not null and it's not to。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至并不一定是强制的，但确实是适当的，当你的数据本身是递归的，那么递归作为一种编码技术，确实发光了。所以如果最终我们有哦，还有小的优化，我们当然不需要明确检查数字是否相等，我们可以假设，如果它不为零且不是。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_21.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_21.png)'
- en: must be，standing right on top of it and so we，just returned true there。well
    let me re-summarize the picture，here this is now a two-dimensional data。structure
    and it's sort of，better than a linked list in that now。it's two dimensions i gain
    back binary，search which is amazing so long as i。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 必须正好站在它上面，所以我们刚返回了 true。那么让我重新总结一下，这现在是一个二维数据结构，它比链表要好，因为现在是二维的，我重新获得了二分搜索，这真是太棒了，只要我。
- en: keep my data in sorted order per this，binary search tree definition。but i've
    surely paid a price right，nothing，is absolutely better than anything else。in our
    story thus far so what is the，downside of a tree，what price have i secretly or
    not so。secretly paid here while preaching，and again the answer is often in this，context
    sort of space。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个二叉搜索树的定义保持我的数据有序，但我肯定是付出了代价，对吧，没什么东西是绝对比其他任何东西更好的。在我们迄今为止的故事中，树的缺点是什么？我在这里秘密或不那么秘密地付出了什么代价？
- en: or time or developer time or money or，some resource personal or，physical or
    real world。any thoughts yeah how about over to uh，um yeah so i think that inserting
    is。no longer constant time and i guess you，need more memory you need memory。to
    sort two pointers instead of one this，longer，constant time because if i need to。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者时间，或者开发者时间，或者金钱，或其他一些资源，无论是个人的，还是物理的，或真实世界的。有什么想法？嗯，我认为插入不再是常量时间，我想你需要更多的内存。你需要内存来排序两个指针而不是一个，这样时间就会更长，因为如果我需要。
- en: preserve sorted order，i can't just put it at the top i can't，just keep pushing
    everything else down。because things might get out of order in，that case it would
    seem。or rather even if i maintain the order，it might kind of get very long and，stringy
    if i add。for instance uh another number another，number and i keep jamming it at
    the top。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 保持排序的顺序，我不能仅仅把它放在顶部，我不能只把其他所有东西往下推。因为那样东西可能会乱，这种情况下似乎不太可行。即使我保持顺序，如果我添加，例如另一个数字，再添加一个数字，我持续把它塞在顶部，它可能会变得非常冗长。
- en: i probably need to kind of keep things，balanced if you will，and yeah the bigger
    point too is that。pointers，so now my node is sort of getting even，bigger than
    these things。i now have room for not only a number，and a pointer but another pointer。which
    is of course going to cost me more，space again so a trade-off there and。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能需要保持事物的平衡，如果你愿意，更大的要点是指针，所以现在我的节点变得比这些东西还要大。我现在有空间不仅仅存储一个数字和一个指针，还有另一个指针，这当然会再次占用更多的空间，因此需要权衡。
- en: let's go ah**d and ask the group，here when it comes to insertion why。don't we
    consider for a moment what the，running time of insertion might be。when inserting
    into a binary search tree，if you'd like to pull up the url as。always let me go
    ah**d and，present this one what's the running time。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，啊**先问问小组，当涉及到插入时，为什么我们不考虑一下插入的运行时间可能是什么。当插入到二叉搜索树中时，如果你想像往常一样打开网址，让我继续，啊**提出这个问题，运行时间是什么。
- en: of inserting into a binary search tree，so if you want to insert the number zero。into
    that tree if you want to insert the，number，eight or anything in between。or bigger
    or smaller what are the，victory，for the tallest bar about 60 percent of。![](img/048b7fb31d80a37bbdc5116c8b723aaf_23.png)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 插入到二叉搜索树中，如果你想把数字零插入到那棵树中，或者想插入数字八或介于两者之间的任何数字，或者更大或更小，关于最高柱子的胜利率大约是60%！[](img/048b7fb31d80a37bbdc5116c8b723aaf_23.png)
- en: you think log n and the good instincts，there frankly are so that is going to
    be。the right answer and that's the kind of，the right instinct anytime you have。binary
    search odds are you're talking，something logarithmic，but we've also seen divide
    and conquer。in merge sort with n log n so not，unreasonable that about ten percent
    of，you think that too。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为对数 n 和良好的直觉，坦率地说，这将是正确的答案，这种直觉在任何时候都是正确的。当你谈论二分搜索时，几乎可以说是某种对数的，但我们也看到了分而治之。在归并排序中有
    n log n，因此认为约十个百分点也是合理的。
- en: and squ*red would actually be bad so n，squ*red is like the worst of the。times
    we've seen thus far and that would，suggest that，a tree is even worse than a link
    list is。even worse than an array and thankfully，we're not at that point，assumptions。so
    why is that so if we consider the，graph here from a moment ago。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而 n*平方实际上是糟糕的，所以 n*平方就像我们迄今为止看到的最糟糕的情况，这表明一棵树比链表还要糟糕，甚至比数组还要糟糕，值得庆幸的是，我们还没有到达那个假设的点。那么为什么呢？如果我们考虑一下刚才的图。
- en: if we consider the sorry if we consider，the tree from a moment ago。it looked
    a little something like this，and what is involved in inserting。into a linked into
    a tree well suppose i，want to insert the number eight。well i start here and it
    obviously，belongs to the right because 8 is bigger。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑刚才的树，它看起来大致是这样的，插入到一个树中涉及什么呢？假设我想插入数字8。那么我从这里开始，显然它属于右侧，因为8更大。
- en: i go here belongs to the right because 8，is bigger i go here it belongs to the。right
    because 8 is bigger，and so a new node is going to be created。somewhere down here
    and even though it，doesn't fit on the screen i could。absolutely call malloc i
    could update a，couple of pointers and boom。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我去这里属于右侧，因为8更大，我去这里它属于右侧，因为8更大，因此将会创建一个新节点。在这里的某个地方，即使它不适合屏幕，我绝对可以调用`malloc`，我可以更新几个指针，然后就搞定了。
- en: we've added an eighth node to the tree，so if it took me that many steps。starting
    at the root one two three，how do i generalize this into big o，notation well。a
    binary search tree if you lay it out，nice and prettily like this。nice and balanced
    if you will the height，of that binary search tree。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给树添加了第八个节点，所以如果我从根开始，走了一些步骤，1、2、3，我如何将其概括为大O符号呢？如果你把一个二叉搜索树整理得漂漂亮亮，像这样，平衡的话，那个二叉搜索树的高度。
- en: it turns out is going to be log of n if，now，in the story then log base 2 of
    n is。going to be the height of the tree，so if you take n nodes n numbers and you。kind
    of balance them in this nice，sorted way the total height is going to，be log n
    so。what is the running time of insert well，equivalent to，how many steps does it
    take you to find。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，如果现在在这个故事中，n的对数，那么n的底数为2的对数将是树的高度，所以如果你把n个节点、n个数字以这种漂亮的排序方式平衡，整体高度将是log
    n。那么插入的运行时间是多少呢？这相当于找到新的数字属于哪个位置要多少步。
- en: the location，into which the new number belongs well，that's one two three。and
    as it turns out log base two of，eight is indeed three so the math，case。sometimes
    there might be a little，rounding error but in general it's going，to indeed be。big
    o of log n，but what if we get a little sloppy what，if we get a little sloppy and
    we start。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位置是1、2、3。而事实证明，8的底数为2的对数确实是3，所以数学上有时可能会有一点舍入误差，但一般来说，它确实是大O(log n)。但是如果我们稍微马虎一下，如果我们稍微马虎，开始。
- en: inserting nodes，that are giving us a bit of bad luck if，you will so for instance
    suppose that。i go ah**d and let me do something on，the fly here，suppose that i
    go ah**d and insert。the number one the number two and the，number three，such that
    this is what logically happens。this adheres to the definition of a，binary search
    tree if this is the root。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 插入节点，如果你愿意，可以给我们带来一些坏运气。例如，假设我去**d，让我在这里随便做点什么，假设我去**d，插入数字1、2和3，使得这就是逻辑上发生的事情。如果这是根，它符合二叉搜索树的定义。
- en: it's one it has no left subtree and，that's not strictly a problem。because there's
    nothing violating the，definition of a search tree here there's，just nothing there。two
    is in the right place three is in，the right place so this too。technically is a
    binary search tree but，it's a bit of a corner case a perverse，case if you will。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它是没有左子树的，这并不是严格的问题。因为这里没有违反搜索树定义的东西，只是没有东西。两个在正确的位置，三个在正确的位置，因此这也是严格来说是一个二叉搜索树，但它有点边缘案例，或者说是一个扭曲的案例。
- en: where the way you inserted things ended，up in the binary search tree。actually
    resembling more of a what would，chat，and brian if you might want to relay。a binary
    people are saying it looks like，a linked list yeah so even though i've。drawn it
    sort of top down，so in the sort of second dimension。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你插入东西的方式最终在二叉搜索树中，实际上更像是什么，如果你想传达给聊天和布莱恩的话。人们说它看起来像一个链表，是的，即使我把它画成从上到下的样子，在某种二维的感觉中。
- en: that's really just an artist's rendition，this tree is a binary search tree。but
    it's kind of sort of also a linked，list and so even the，given，some bad design。could
    devolve into a different data，structure just by chance，even。with these values
    when i insert 1 2，3 i could allow for this perverse。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这其实只是艺术家的表现，这棵树是一个二叉搜索树。但它也有点像一个链表，所以即使给定一些糟糕的设计，也可能偶然退化成不同的数据结构。即使在插入1、2、3时，我也可能允许这种扭曲。
- en: situation where it just gets long and，stringy at which point everything is big。o
    of n it's just a linked list it just，happens to be drawn diagonally instead，of
    left right。intuitively not，in terms of code no formal language but，there is a
    solution here。to make sure that this tree with one two，three does not get long，and
    stringy in the first place what。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况会变得冗长而复杂，此时一切都是O(n)，这就只是一个链表，只是刚好是对角线而不是左右延伸。从直觉上讲，不是从代码的角度，没有正式的语言，但这里有一个解决方案。确保这个包含一、二、三的树不会在一开始就变得冗长而复杂。
- en: a few people in the chat are suggesting，the top of the tree，so if i instead
    make two the new root。node let me go ah**d and，mock this up real quickly and in
    a，moment i'll reveal what i think you've。just verbalized what if instead i make，sure
    that when inserting these nodes i。don't naively just keep going to the，right to
    the right to the right。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天中有几个人建议，把树的顶部作为新的根节点，所以如果我将两个节点作为新的根节点。让我快速模拟一下，过一会儿我会揭示我认为你刚才表达的内容。如果我确保在插入这些节点时，不会天真地一直向右延伸。
- en: i exercise some judgment and if i notice，maybe that my data structure my tree
    is。getting kind of long and stringy，maybe i should kind of like rotate it，real。so
    that i change what the root is and we，won't go through the code for doing this。but
    it turns out this is the solution，like that is exactly the right intuition。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我在行使一些判断时，如果我注意到我的数据结构、我的树变得有些冗长而复杂，也许我应该进行旋转，实际上改变根节点的定义。我们不会讨论实现这一点的代码，但结果是，这正是正确的直觉。
- en: if you take a higher level class on，data structures and algorithms。specifically
    in computer science you'll，study trees like avl，trees or red black trees which
    are。different types of tree data structures，they kind of have built into them
    the。algorithms for kind of like shifting，things as needed to make sure that as。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上更高一级的数据结构和算法课程，尤其是在计算机科学领域，你将学习像AVL树或红黑树这样的树，它们是不同类型的树数据结构，它们内部嵌入了算法，以便在需要时进行调整，确保。
- en: you insert or maybe as you delete，you constantly rebalance the tree and，long
    story short。doing so might cost you a little extra，time but if you've got a lot
    of data。keeping that thing balanced and，logarithmic in height so to speak。and
    not long and stringy and linear in，height is probably，depending on your application
    going to。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在插入时，或者在删除时不断重平衡树，长话短说，这可能会花费你额外的时间，但如果你有大量数据，保持树的平衡、对数高度是不冗长而复杂的，从某种意义上说，可能是根据你的应用而定的。
- en: save you quite a bit of time，overall so we might say that insert，indeed。big
    o of login but that is conditional，on you making sure that you keep it。balanced
    and that's going to be more，code than we'll go into today。but indeed a possible
    design decision，all right any questions then on now，trees。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 整体上可以节省你不少时间，所以我们可以说插入操作确实是O(log n)，但这依赖于你确保保持它的平衡，而这将涉及比我们今天讨论的更多的代码。不过，这确实是一个可能的设计决策。那么，关于树还有什么问题吗？
- en: and binary search trees in particular we，started with arrays a few weeks ago。we've
    now got linked lists which are，good better but not great trees which。seem maybe
    to be great but again，it's always a trade-off they're costing，us more space。but
    i bet we can continue to stitch some，of these ideas together，for other structures
    still brian。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是二叉搜索树，我们几周前开始讲数组。现在我们有了链表，这很好，但不是很好，树似乎可能很好，但总是有权衡，它们消耗我们更多的空间。但我敢打赌，我们可以继续将这些想法结合起来，构建其他数据结构。
- en: anything outstanding，yeah one question came in as to why it's，a problem if you
    have like the one and。the two and the three all in just one，sequence on the right
    side。yeah really good question why is it a，problem maybe it isn't like if you
    don't。have a very large data set，and you don't have many values in the。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么特别的情况吗？是的，有一个问题问，为什么如果像一、二、三都在右侧的一个序列中会成为问题。是的，真是个好问题，为什么这是一个问题？也许并不是，如果你的数据集不大，且值不多。
- en: structure honestly who cares like if，it's three elements，definitely don't care
    if it's ten。elements if it's a thousand heck if your，computer is fast enough it
    might be a。million elements and it's not a big deal，but if it's two million elements
    or a，again on。what is what is the business you're，building what is the application
    you're。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，谁在乎呢？如果只有三个元素，绝对不在乎。如果是十个元素，如果是一千个元素，天哪，如果你的计算机足够快，那可能有一百万个元素也没关系，但如果是两百万个元素，或者再大一点，那么问题就来了。你正在构建的是什么业务？你的应用是什么？
- en: writing how big is your data how fast or，how slow is your computer。it might
    very well matter ultimately and，indeed when we've seen some of our，compared。linear
    when we compared uh bubble sort，and selection sort and merge sort even。though
    those were in a different，category of running times，n log n and n squ*red just
    recall the。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 写下你的数据有多大，你的计算机有多快或多慢，这在最终可能非常重要，确实，当我们对比一些算法时，线性查找的表现。比如，比较冒泡排序、选择排序和归并排序，尽管这些属于不同的运行时间类别，O(n
    log n)和O(n²)，请记住这一点。
- en: appreciable difference，and log of n in the context of searching，is way better。than
    n so if your data structure is，stringy，recall that's like searching a phone。book
    a thousand total pages，but binary search and not letting it get，long and stringy。gives
    you like 10 steps instead of a，thousand steps in order to search those，same pages
    so again。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显著的差异，O(log n)在搜索的上下文中比O(n)要好得多，所以如果你的数据结构是字符串型，想象一下就像在查找一本有千页的电话簿，但二分查找却让它不那么冗长，给你10步，而不是1000步来搜索同样的页面。
- en: even in week zero we saw the appreciable，difference between these different。categories
    of running times，all right well let's see if we can't，maybe take some of the best
    of both。we've seen，linked lists we've seen trees what if we，kind of get a little
    frankenstein here。and mash things together and take sort，of the best，features
    of these things and build up。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在第零周，我们也看到了这些不同运行时间类别之间的显著差异。那么，让我们看看能否取两者的优点。我们见过链表，也见过树，如果我们把它们结合在一起，提取这些结构的最佳特性进行构建。
- en: something grander in fact i feel like，the holy grail of a data structure。would
    be something for which cert and，insertion aren't，n big o of n aren't big o of
    log n but。wouldn't it be amazing if there's a data，structure out there where the
    running。time is like constant time big o，of one like that's the holy grail if
    you，memory。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我觉得一种更宏大的数据结构就像是数据结构的**圣杯**，其插入和查找的时间复杂度既不是O(n)，也不是O(log n)。但如果有一种数据结构，其运行时间是常量时间O(1)，那简直是**圣杯**，如果你有内存的话。
- en: in such a way that if you want to search，for insert a value boom you're done。boom
    you're done and none of this linear，or logarithmic running time。so let's see if
    we can't pursue that，goal let me propose that we introduce。this topic called hash
    tables hash table，is another data structure that's，essentially an。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，如果你想搜索或插入一个值，啪，你就完成了。啪，你就完成了，而不需要线性或对数的运行时间。所以让我们看看能否追求这个目标，我提议引入一个主题叫做哈希表，哈希表是另一种数据结构。
- en: array of linked lists so again it's this，combined，arrays ultimately with linked
    lists。let's see how this is done let me，array，of size 26 and i'm going to start。drawing
    my arrays vertically just，because it sort of works out better。pictorially but
    again these are all，artists renditions anyway even though we。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的数组，最终是将数组和链表结合起来。让我们看看这是如何实现的，我将创建一个大小为26的数组，并开始将我的数组垂直绘制，因为这样在视觉上更好，但这些仍然是艺术家的表现。
- en: always draw arrays left to right that's，start for now，drawing my array top to
    bottom and，about now。is going to be even more interesting，than numbers suppose
    i want to store。things like names like dictionaries，or names like contacts in
    your phone if。you want to keep track of all the people，you know it would be great
    if it doesn't，find people。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常从左到右绘制数组，但现在开始从上到下绘制。接下来会更有趣，比如我想存储像字典那样的名字，或者像你的手机中的联系人一样的名字。如果你想跟踪你认识的所有人，那就太好了，不要找人。
- en: even better，and i，propose that deliberately in english，there's 26 letters a
    through z。so let's consider location 0 is a，location 25 is z，and if i now go and
    start inserting all。of my friends into my new phone，into the contacts application
    where，and do this。let me go ah**d and think of each of，these elements is again
    0 through 25。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我提议在英语中故意使用26个字母，从a到z。所以我们假设位置0是a，位置25是z，现在我开始将所有朋友插入我的新手机，进入联系人应用程序。
- en: or really a through z and let me upon，inserting a new friend or。contact into
    my phone let me put them，into a location that has some。relationship with the name
    itself，let's not just start putting them at the。very beginning let's not necessarily
    put，them alphabetically per se，location。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者实际上是从a到z，当我插入一个新朋友或联系人的时候，让我把他们放入一个与名字本身有某种关系的位置，让我们不要从头开始，也不一定要按字母顺序放置。
- en: in this array not just top to bottom but，at a specific，entry so suppose the
    first person i want。to add to my contacts is albus，well i'm going to propose that
    because，albus starts with an a。he is going to go into the a location so，the very
    first，entry in this array suppose i next want。to add zacharias，well his name starts
    with z so he's，again，i'm jumping around i went to from 0 to。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数组中，不仅是从上到下，而是在一个特定的条目中。假设我想添加到我的联系人中的第一个人是阿尔布斯，那么我会提出，因为阿尔布斯以 a 开头，他将放入
    a 的位置，所以在这个数组中的第一个条目。假设我下一个想添加的是扎卡里亚斯，他的名字以 z 开头，所以他，又一次，我跳来跳去，我从 0 跳到。
- en: 25 but it's an array，and i can do that in constant time you，squ*re brackets。so
    this is both constant time i don't，have to just put him right after albus i。can
    put him wherever i want，suppose the third person is hermione。well i'm going to
    put her at location，h why because i can do the math and i。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 25 但这是一个数组，我可以在常数时间内做到这一点，你，方括号。所以这是常数时间，我不需要把他放在阿尔布斯之后，我可以把他放在任何我想要的地方，假设第三个人是赫敏。那么我会把她放在位置
    h，为什么呢？因为我可以做这个数学计算，我。
- en: can figure out h okay i can just jump，immediately to that letter of the。alphabet
    and in turn thanks to ascii and，doing a bit of arithmetic。i convert that to a
    number as well so，five，six seven because h uh ends up mapping。to the eighth character
    or location，these other people，end up in my address book and so they're。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以搞清楚 h，好吧，我可以直接跳到字母表的那个字母，并且感谢 ASCII 和进行一点算术，我也可以把它转换成一个数字，所以，五、六、七，因为 h 最终映射到第八个字符或位置，这些其他人，最终也在我的地址簿中，所以他们。
- en: all spread out i don't have as many as，data there，but i fit everyone here but
    there might。this coming，thus far i've kind of gotten lucky and，i've only know
    people whose names are。uniquely start with a letter but as soon，as i meet someone
    at。uh you know school and i add them to my，contacts well now harry，for instance
    has to go in the same。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有那么多数据，但我把每个人都放在这里，但可能会有。这到目前为止，我有点走运，我只认识那些名字独特以某个字母开头的人，但当我在学校认识某人并把他们添加到我的联系人时，嗯，比如哈利，必须放在同一个。
- en: location now this is a problem，if i want to store both hermione and，with h。but
    again if it's an array it's，absolutely a deal breaker at that point，all things
    break down。because i could yes grow the array but，if i grow the array then it's
    size。27 and then it's like how do i know what，number is what letter at that point
    it。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 位置。这是个问题，如果我想存储赫敏和以 h 开头的人。但是如果这是一个数组，那绝对是个致命问题，所有事情都崩溃了。因为我可以是的，扩大数组，但如果我扩大数组，它的大小就是
    27，那么此时我如何知道哪个数字对应哪个字母。
- en: just devolves into a complete mess，but if i borrow the idea of a linked，list
    what if i make my。array an array of linked lists so yes，even though there's this
    collision where。both hermione and harry，that's fine，in the event this happens
    i'm just going。to kind of stitch them together into a，linked list from left to
    right。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只是变成一团糟，但如果我借用链表的概念，如果我把我的数组变成一个链表的数组，所以是的，尽管出现了赫敏和哈利的冲突，这没问题。如果发生这种情况，我只是会把他们串联在一起，从左到右放在一个链表中。
- en: so it's not ideal because now it takes，me two steps to get to harry instead
    of，bracket notation。but heck at least i can still fit him in，my address book so
    a bit of a trade-off。but feels reasonable，well someone else hagrid all right it's，not
    ideal that now it takes me three。steps to get to hagrid in my address，book but
    three，there at all。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这并不理想，因为现在我需要两步才能到达哈利，而不是用方括号表示。但至少我仍然可以把他放进我的地址簿，所以这是一个权衡，感觉还算合理。好吧，另一个人海格，好的，现在我需要三步才能到达我的地址簿中的海格，但三步总比没有好。
- en: so again we see a manifestation of a，problem，and a hash table is indeed exactly
    this。data structure it，is an array of linked lists at least it，can be implemented
    as such。and it is predicated on introducing the，notion of a hash function。this
    is actually something we'll see in，function，is going to allow us to map not only。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们再次看到一个问题的表现，哈希表确实就是这样的数据结构，它是一个链表的数组，至少可以这样实现。它的基础是引入哈希函数的概念。这实际上是我们将在函数中看到的，它将允许我们不仅映射所有。
- en: hermione harry and hagrid but also ron，and remus severus and sirius，to their
    respective locations。deterministically，that is there's no randomness involved，here
    every time i look at these people's。names i'm going to，figure out the location
    at which they，belong and that location is never going。to change，so how do i do
    this well it turns out，that even uh，back to，problem solving itself and what。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 赫敏、哈利和海格，还有罗恩、卢平、斯内普和小天狼星，分别到达他们的目的地。是确定性的，也就是说这里没有随机性，每次我看到这些人的名字时，我都会确定他们所属的位置，而这个位置永远不会改变。那么我该如何做到这一点呢？实际上，这与问题解决本身有关系。
- en: functions are so this is problem solving，as we've defined it this is also。the
    function a function in any language，function，is going to be sort of the secret
    sauce。inside of this black box for now，and so what is a hash function well hash。function
    is literally a function，either mathematically or in programming，that takes as
    input。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 函数就是这样，这就是我们所定义的问题解决，这也是任何语言中的函数，函数在这个黑箱中将是某种秘密成分。那么哈希函数是什么呢？哈希函数实际上是一个函数，无论是数学上的还是编程中的，它将作为输入。
- en: or harry，and it returns some output and the，output of a hash function is usually。a
    number in this case the number i want，is going to be between 0，notion of a hash。table
    not just pictorially on the screen，but in actual code，i'm literally going to have
    to write a c。function that takes a string or if you，will char star，as input and
    returns an int between 0。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 或者说哈利，它返回一些输出，而哈希函数的输出通常是一个数字，在这种情况下，我想要的数字是在0之间，哈希表的概念不仅仅是屏幕上的图像，而在实际代码中，我实际上需要编写一个C语言函数，它以字符串，或者说字符指针作为输入，返回一个在0到25之间的整数。
- en: and 25 so that i know，hagrid，to the number 7 in this case so what，does this
    hash function do。it takes as input something like albus，and it outputs 0。it takes
    someone like。zacharias and it outputs 25。and you can，probably see the pattern
    here。the code i would write in order to，implement something like this is。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 和25，所以我知道海格对应的数字是7，那么这个哈希函数到底做了什么？它以像阿尔巴斯这样的输入，并输出0。它以像扎卡里亚斯的人作为输入，并输出25。你可能会看到这里的模式。我将为实现这样的功能编写的代码是。
- en: probably going to look at the user's，input that char star，and it's going to
    look at the first。character which is，a or z respectively for these two and，it's
    then going to do a little bit of。math and subtract off like 65 or，or whatnot and
    it's going to get me a，number between 0。and 25 just like with caesar or some of，our
    past manipulations，of strings so from here。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能会查看用户输入的字符指针，它会查看第一个字符，对于这两个字符分别是a或z，然后它会进行一些数学运算，减去65或其他的，这样我会得到一个在0到25之间的数字，就像凯撒密码或我们过去对字符串的一些操作一样，因此从这里开始。
- en: we can now take this building block，though and perhaps solve our problems a。little
    more effectively like i don't，love the fact，that even though yes i've made room
    for。harry and hermione and hagrid and now，luna and lily and lucious and lavender。these
    some of these linked lists are，getting a little long and there's，kind of like。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我们现在可以利用这个构建模块，或许能更有效地解决我们的问题。我并不喜欢，尽管我为哈利、赫敏、海格以及现在的露娜、莉莉、卢修斯和薇薇安腾出了空间，但这些链表有些过长，而且有点儿像。
- en: chains if you will because they look，like chain-link fences or little links，in
    a chain。this is these are chains or linked lists，long，and it's a little stupid
    that i'm trying。to achieve constant time big o of one，but technically even though
    some of the。names literally take one step，some of them are taking two or three
    or。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 链接，如果你愿意，因为它们看起来像链环围栏或链中的小链接。这是这些链或链表，它们很长，而我试图实现常数时间O(1)的做法有些愚蠢，但实际上，尽管有些名字确实只需一步，有些却需要两三步。
- en: four steps so it's starting to devolve，so what would be an optimization here
    if。you start to get uncomfortable because，you're so popular and you've got so
    many。names in your contacts，l's，is taking more time than the others，what could
    we do to improve the。situation and still use a hash table，maybe the，logical solution
    be when you have too，many collisions。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 四个步骤，所以开始变得复杂，那么这里的优化是什么？如果你开始感到不适，因为你太受欢迎，联系人太多，L的处理时间比其他人多，我们可以做些什么来改善这种情况，同时仍然使用哈希表，或许逻辑解决方案是在碰撞太多的时候。
- en: you have too many names colliding with，one another，how could we improve our
    performance and。get at locations，again closer to one step not two not，three not
    four so。literally one step because that's our，holy grail here，a few people have
    suggested you should。look at more than just the first letter，for example，yeah
    nice so if looking at one letter of。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你有太多名字互相碰撞，我们如何能改善我们的性能，并接近位置，还是一步而不是两步、三步、四步，所以真的一步，因为这就是我们的**终极目标**。有些人建议你应该关注的不仅仅是第一个字母，例如，是的，听起来不错，所以如果看一个字母。
- en: the person's name is obviously，insufficient because all of，a whole bunch of
    us have names that。start with h or or a，or z or the like well why don't we look，at
    two letters and therefore decrease。the probability，that we're going to have these，collisions
    so let me go ah**d and。restructure this and focusing on the，hermione harry and
    hagrid problem。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人的名字显然不够，因为我们中有很多人的名字以**h**、**a**或**z**等开头，为什么我们不看两个字母，从而降低我们发生这些碰撞的概率呢？所以让我继续，重组并专注于**赫敏、哈利和哈格里德**的问题。
- en: why don't we go ah**d and take our array，here，and let's think of it as maybe
    not just。being h at that location，but what if we think of that location，specifically
    as being h a。and then h b h c h d h e h f，all the way down to h z and then i，enumerate。all
    possible pairs of letters，from a a to z z but this would seem to，hermione。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不继续并取我们的数组，想象一下它可能不仅仅是在那个位置为**h**，而是具体想象那个位置，作为**h a**，然后**h b h c h d
    h e h f**，一直到**h z**，再到**i**，列举出所有可能的字母对，从**a a**到**z z**，但这似乎对**赫敏**来说。
- en: goes in the h e location in the array，now harry goes in the ha and now hag。oh
    damn it like hagrid still goes in the，same location，so what would maybe be a better
    fix。again this isn't，horrible like two steps is not a big，deal especially on fast
    computers。but again with large enough data sets，and if we're no longer talking
    about。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**赫里**在数组中的**h e**位置，而**哈利**则在**h a**，现在是**h ag**。哦，天哪，像**哈格里德**仍然在同一个位置，那么可能更好的解决方案是什么？再说，这并不是太糟糕，像两步并不是大问题，尤其是在快速计算机上。但对于足够大的数据集，如果我们不再讨论。'
- en: people in your contacts but maybe all，the people in the world who are。uh who
    have google accounts or twitter，accounts and the like where you want to。search
    this information quickly you're，names start with，h and a nz and everything else
    it would。be nice to spread them out further，so what could we do well instead of，using
    the first two letters。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你通讯录中的人，但也许是全世界所有拥有**谷歌**账户或**推特**账户的人，你想快速搜索这些信息，名字以**h**开头，**a n z**和其他所有名字，最好能更分散一些。那么我们该怎么办呢？好吧，和前两个字母相比。
- en: frankly i think the logical extension of，this is to use the first。three letters
    so maybe this is the h-a-a。![](img/048b7fb31d80a37bbdc5116c8b723aaf_25.png)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，我认为这个逻辑延伸是使用前三个字母，所以也许这是**h-a-a**。![](img/048b7fb31d80a37bbdc5116c8b723aaf_25.png)
- en: bucket this is the h-a-b，a e dot h-a-c-h-a-d-h-a-e dot all the，way down to h
    z z。and then i a a but now when we，hash our three friends hermione goes in，the
    h e r。bucket so to speak the element of the，array harry h，a r goes in that bucket
    and hagrid now。gets his own bucket h-a-g，as would everyone else so it seems to。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个桶是**h-a-b**，**a e**点**h-a-c-h-a-d-h-a-e**一直到**h z z**。然后是**i a a**，但现在当我们对三个朋友进行哈希时，**赫敏**进入了**h
    e r**。可以说这个数组的元素**哈利**，**h a r**进入那个桶，**哈格里德**现在有自己的桶**h-a-g**，其他人也是，所以似乎。
- en: have solved this specific problem you，could still imagine and i have to think，there's
    other。harry potter names that start with hag，or h-a-r or，h-e-r to find another
    collision because。you could imagine using，four letters instead but what price
    are，we paying。like i'm solving this problem again and，again and i'm getting myself，it's
    giving me。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个特定问题后，你仍然可以想象，我必须考虑，还有其他以**hag**或**h-a-r**或**h-e-r**开头的**哈利·波特**名字来寻找其他碰撞。因为你可以想象使用四个字母，但我们付出了什么代价？像我一次又一次地解决这个问题，给我带来了。
- en: one step i can mathematically figure out，by just doing a bit of ascii math。what
    the number of the index is that i，should jump to in this bigger and bigger。array
    but what price am i paying，brian any thoughts you'd like to relay。yeah a few people
    are saying it's going，to take a lot of memory。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一步我可以通过简单的**ASCII**数学来计算我应该跳到这个越来越大的数组中的哪个索引，但我付出了什么代价，**布莱恩**，你有什么想法想分享吗？是的，有些人说这会消耗很多内存。
- en: yeah my god like this is taking a huge，amount of memory now，previously how much
    memory did it take。well let me pull up a little uh，*****，*****，26 buckets so to
    speak elements in the。array that of course isn't that bad that，feels pretty reasonable
    26 slots。but the downside was that the chains，might get kind of long three names
    four，names maybe even more。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我的天，这占用了大量内存，那么之前占用了多少内存呢？让我稍微查一下，*****，*****，可以说是26个桶，数组中的元素，当然这并不算太糟，感觉相当合理，26个插槽。但缺点是链可能会变得有点长，三个名字、四个名字，甚至更多。
- en: but if we have a a through z z，instead of a through z that's 26 times，26 that's
    676 buckets。doesn't sound like a huge deal though，that's bigger than most things
    we've，done in memory thus far。not a huge deal but if we have 3 that's，26 possibilities
    times 26 times 26 for，aaa through zzzz。now we have 17 576，buckets in my array
    and the problem，isn't so much that we're using that。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一个从a到z的组合，而不是从a到z，那就是26乘以26，总共676个桶。听起来并不是特别大的问题，但这比我们迄今为止在内存中处理的大多数东西都要大。并不算大，但如果我们有3，那就是26种可能性乘以26再乘以26，从aaa到zzzz。现在我的数组中有17576个桶，问题并不是我们在使用它。
- en: memory because honestly if you need the，memory use it that's fine。just throw
    hardware at the problem buy，and upgrade more memory。but the problem is that i
    probably don't，know that many people，whose names start with hzz or。a z z or any
    number of these，combinations of letters of the alphabet。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 内存，因为老实说如果你需要内存，就用吧，这没问题。只是把硬件投入这个问题，买入并升级更多内存。但问题是，我可能不知道多少人，名字以hzz或azz开头，或者字母表的任何这些字母组合。
- en: a lot of those buckets are going to be，empty，if you want an array and you want
    random。access they have to be present so that，your arithmetic，works out per week
    too where you just。use squ*re bracket notation and jump to，care about，so finding
    that trade-off or finding the。inflection point with those trade-offs，is kind of
    an art and or a science。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多桶将是空的，如果你想要一个数组并希望随机访问，它们必须存在，以便你的算术每周都能顺利进行，你只需使用方括号表示法跳转到你关心的地方，所以找到这种权衡或找到这些权衡的拐点，某种程度上是一种艺术，也是一种科学。
- en: figuring out for your particular data，your particular application。which is more
    important time or space or，some happy medium，in between the two and with problem
    set。five as you'll see you'll actually have，to figure out this balance in part
    by。trying to minimize ultimately your own，use of memory，and your own use of computers
    time but。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你特定的数据、你特定的应用，弄清楚时间、空间哪个更重要，或者两者之间的某个平衡，而在问题集五中，你将看到你实际上必须通过努力最小化自己最终的内存使用和计算机的时间使用来找到这种平衡，但。
- en: let me point something out actually，this notion of hash table which up until。now
    definitely the most sophisticated，data structure that we've looked at，already
    like。these are probably larger than the，playing cards you have at home but if，and，you've。at
    some point needed to sort them for，one game or another sometimes you need。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我指出一点，实际上，这个哈希表的概念，到目前为止肯定是我们所看过的最复杂的数据结构。这些可能比你家里的扑克牌还要大，但如果在某个时候你需要为某个游戏排序，有时你需要。
- en: to shuffle them entirely，if you want to be a little neat you，might sort them
    not just by number but。also by suits so hearts and spades and，clubs and diamonds
    into separate。categories so honestly i have this，literally here just for the sake
    of the。metaphor we have four buckets here，and we've gone ahead uh and labeled
    them。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想把它们完全洗牌，为了整洁，你可能会不仅按数字排序，还按花色分类，将红心、黑桃、梅花和方块分到不同的类别，所以说实话，我只是为了隐喻而把这四个桶放在这里，并且已经给它们贴上标签。
- en: in advance with spade there so that's，one bucket，here we have a diamond shape
    here。and here we have uh，here we have hearts here，and then clovers here so if
    you've ever，haven't really。thought about this very hard because，it's not that
    interesting you probably。mindlessly start laying them out and，sorting them by，by
    suit and then maybe by number but if。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 提前准备好黑桃，那是一个桶，这里有一个方块的形状。然后我们这里有红心，然后是四叶草，所以如果你曾经没有认真思考过这个，因为它不是特别有趣，你可能会无意识地开始把它们摆放和按花色排序，然后也许按数字，但如果。
- en: you've done that，you have hashed values before if you，see that oh。it's the dime
    it's the ace of diamonds，you know yes you might care ultimately。that it's a diamond
    but that it's an ace，but for now i'm just going to put it for，instance into the。ace
    into the diamond bucket here's the，two of diamonds here，i'm going to put that
    into the diamond。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了这一步，如果你看到哦，那是红心10，那是红桃A，你知道，是的，最终你可能关心的是它是红桃，但现在我只是将它放入红桃桶中。这里是红桃2，我将把它放入红桃桶。
- en: going to put that，over here and you can just progressively，hash one。card after
    the other and indeed hashing，really just means to look at some input。and produce
    in this case some numeric，one，two or three based on some，characteristic of that
    input。whether it's actually the suit on the，card like i'm doing here or maybe
    it's。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个放在这里，你可以逐渐地对每一张卡进行哈希，哈希实际上只是查看一些输入，并在这种情况下基于输入的一些特征生成一些数字，比如一、二或三。无论是卡片的花色，就像我现在做的，还是其他的。
- en: based on the letter of the alphabet here，and why am i doing this right i'm not。going
    to do the whole thing because like，52 steps is going to take a while and。get boring
    quickly if not already，but why am i doing this because odds are，drama of like。actual
    buckets you probably just kind of，laid them out in front of you but why，have you
    done that。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于字母表的，那么我为什么这样做呢？我不会做完整的，因为52步会花费很长时间，而且很快会变得无聊，但我为什么这么做，因为实际上，你可能已经将这些桶摆在你面前，但你为什么这样做呢？
- en: there's a possibility that we could，actually get to things faster like if we，know
    what bucket it is。we might be able to even search things，for like oh one or less。yeah
    something like that yeah you start，to gain these optimizations right like。at least
    as a human honestly，like i can just i can process four。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们知道它是哪个桶，我们可能会更快地找到东西，甚至可以做到一两步，没错，差不多是这样，你开始获得这些优化，至少作为人类，老实说，我处理四个较小问题比解决13个卡片问题要容易得多。 '
- en: smaller problems just much easier than，solve，for 13 card problems a little faster。especially
    if i'm looking for a，particular card now i can find it among，13 cards instead
    of 52。so there's just kind of an optimization，cards，hash them into a particular
    bucket and。then proceed to solve the smaller，problem now that's not what a hash
    table。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是如果我在找特定的卡片，现在我可以在13张卡中找到，而不是52张。所以这就是一种优化，将卡片哈希到特定的桶中，然后继续解决较小的问题，这不是哈希表的本质。
- en: itself is all about a hash table is，about storing information。but storing information
    so as to get to，it more quickly so to sophia's point if。indeed she just wants
    to find like，the uh ace of uh ace of uh diamonds，through a 13。size problem a linked
    list of size 13 if，list，bucketize，your inputs if you will colloquially and。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的核心是存储信息，但以更快的方式获取信息。因此，回到索非亚的问题，如果她只想找像红桃A这样的卡片，解决一个大小为13的链表问题，如果你将输入分组，那么就可以更快速地访问数据。
- en: get access to data more quickly not，necessarily，in time one in one step it might
    be two。might be four might be 13 steps，but it's generally more fewer steps than，if
    you were doing something。purely linearly or even logarithmically，ideally you're
    trying to pick your hash。function in such a way that you minimize，the number of
    elements that collide by。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据的速度可能不一定是一步到位，可能是两步、四步，甚至是13步，但通常来说，比起线性或对数时间，所需的步骤会少一些。理想情况下，你要选择哈希函数，以尽量减少碰撞元素的数量。
- en: using not a through z but a a through zz，and so forth so let me go ah**d here
    and，ask a question。what then is the running time when it，comes to this data structure，and
    search，in there。once all of my contacts are there how，many steps does your phone
    have to take。given n contacts in your phone to find，hermione or hagrid。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的不是从a到z，而是从aa到zz等等。那么让我来问一个问题，关于这个数据结构的运行时间，当我的所有联系人都在那里的时候，手机需要多少步骤才能找到赫敏或哈利·波特。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_27.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_27.png)'
- en: or anyone else，so i see again eighty percent of you are，saying constant time
    big o of one and。again constant time might mean one step，two steps four steps
    but some fixed。number not dependent on n eighteen，percent of you or so are saying。linear
    time and i have to admit the，twenty percent of you or so that said，linear time。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 或其他人，所以我再一次看到你们中有80%的人说常数时间O(1)。再次说明，常数时间可能意味着一步、两步、四步，但是一些固定的数字，不依赖于n，约有18%的人说线性时间，我必须承认，约20%的人说线性时间。
- en: are technically asymptotically，mathematically，a distinction，between like the
    real world and academia。so the academic here，or rather uh the real world，here
    the real world programmer would say。just like sophia did，it is strictly，better
    than one bigger bucket with 52。cards like that is just faster it's，literally four
    times as fast。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在渐进和数学上，真实世界与学术界之间存在区别。因此，在这里，或者更确切地说，真实世界的程序员会说，正如索菲亚所说的，确实比一个有52张牌的大桶要好，速度就是快，确实快四倍。
- en: to find or to fill us flip through those，13 cards instead of 52 like that is，objectively
    faster。but the academic would say yes but，asymptotically and asymptotically is，really
    large。the sort of wave of the hand that i keep，describing asymptotically，taking
    13 steps is technically。cards here，it's technically n divided by 4。 like，yes it's
    13 but if there's n。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 找到或填补这13张牌而不是52张，客观上来说是更快的。但学术界会说，是的，但渐进地，渐进是相当大的。我不断描述的那种渐进，走13步在技术上是13张牌，这在技术上是n除以4。是的，确实是13，但如果是n的话。
- en: cards total technically the size of this，bucket is going to end up being n，divided
    by 4。and what did we talk about，when we talked about big o and omega，well you
    throw away the lower order。terms you get rid of the constants like，the divide
    by four，or the the the plus something else so we。get rid of that and it's technically，a
    hash table searching it is still in，big o of n。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个桶的大小最终会是n除以4。当我们讨论大O和Ω时，我们会扔掉低阶项，去掉常数，比如除以四，或加上其他东西，所以我们去掉这些，技术上它仍然是O(n)的哈希表搜索。
- en: but here again we see a contrast between，like the real world，and the theoretical
    world like yes if。you want to get into an academic debate，linked list，or an array
    at which point you might as。well just search the thing left to right，linked list，but
    come on like if you actually hash。these values in advance，buckets，it comes to，wall
    clock time so when you literally。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里我们再次看到现实世界与理论世界之间的对比，确实，如果你想进入学术辩论，链表或数组，在那时你不如从左到右搜索链表，但如果你提前对这些值进行哈希，桶，它最终关系到实际时间，所以当你实际上。
- en: look at the clock on the wall，less time will pass taking sophia's，approach than
    taking an array。or linked list approach so here the，ant those of you who said
    big o of n are。correct but when it comes to the real，world programming honestly，that
    may。very well be a net positive and so，practice，and less sometimes on the theory
    of。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 看着墙上的时钟，使用索菲亚的方法比用数组或链表的方法所花的时间更少。因此，提到的大O表示法中，大家认为是O(n)的说法是正确的，但在现实编程中，这可能会是一个净收益，因此多练习，减少对理论的关注。
- en: these things and indeed that's going to，be the challenge the problems that five。to
    which i keep alluding，is going to challenge you to implement，table。with a hundred
    thousand plus english，words we're going to in a nutshell give，you a big text file。containing
    one english word per line and，among your goals is going to be to load。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情，确实这是一个挑战，这个问题五，我一直提到的，将挑战你实现一个表，包含十万多个英语单词，我们将简要给你一个包含每行一个英语单词的大文本文件，你的目标之一将是加载。
- en: all of those hundred and forty thousand，plus words，table，now if you are simplistic
    about it and。you use a hash table，with 26 buckets a through z you're going，140。000
    plus english words there's a lot of，words in there that start with a。or b or z
    or anything in between if you，maybe then go with a，a through zz maybe that's better
    or aaa。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有那140,000多个单词的表，现在如果你简单地使用一个有26个桶的哈希表，从A到Z，你会有140,000多个英语单词，其中有很多单词以A、B、Z或任何其他字母开头，如果你可能选择A到ZZ，可能更好，或者AAA。
- en: through zzz maybe that's better but at，some point you're going to start to use。too
    much memory for your own good，and one of the challenges optionally of。problem
    set five is going to be to，playfully challenge your classmates。whereby if you
    opt into this you can run，a command that will put you on the big。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 经过zzz也许会更好，但在某个时刻，你会开始使用过多的内存，这对你来说并不好。问题集五的一个挑战是愉快地挑战你的同学，如果你选择参与，你可以运行一个命令，这将把你放在大名单上。
- en: board which will show，on the course's website exactly how much，or how little
    ram。or memory you're using and how little or，how much time，your code is taking
    to run and so we。just sort of put aside the sort of，academic hand waves of the
    hand saying，but a big。uh but n divided by four sophia's，approach is way better
    in practice。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 课程网站上会显示你使用了多少或多么少的RAM或内存，以及你的代码运行所需的时间。因此，我们只是把那些学术性的说辞暂时搁置一旁。尽管n除以四（n divided
    by four）的方法在实践中效果要好得多。
- en: than n itself and we'll begin to tease，apart the dichotomy between theory here。and
    practice but these aren't the only，ways to lay things out in memory and we，ideas。that
    come out now that we have all of，these building blocks，one of which is a data
    structure that。we're going to call a try the tri，is actually short for the word
    retrieval。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是在内存中布局的唯一方式。现在我们有了所有这些构建模块，其中一个数据结构将被称为尝试（try），而try实际上是检索（retrieval）一词的缩写。
- en: even though it's not quite pronounced，tree，and it's a different type of tree
    that。is typically used to store，words or other more sophisticated pieces，of data
    instead of just。numbers alone so a try is，actually a tree made up of a raise，so
    you can kind of see a pattern here。lists，an，array so at some point computer，scientists
    started getting a little。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它的发音并不明显，树（tree）是一种通常用于存储单词或其他更复杂数据而不仅仅是数字的树形结构。因此，尝试（try）实际上是由节点（node）构成的一种树形结构，你可以在这里看到一种模式。列表（lists）和数组（array）在某个时刻，计算机科学家们开始变得有些创造性。
- en: creative and started just like literally，smashing together different data，up
    with it seems。and so a try begins to look like this，better than，here is，sense
    that this would be like a。rectangle or a squ*re，but inside of that node is literally
    an，array of size 26，or，z。and what we're going to do is anytime we，insert a word，like
    a name like harry or hagrid or。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 他们字面上开始将不同的数据结合在一起，因此一个尝试（try）看起来像这样，比这里更好，这就像一个矩形（rectangle）或正方形（square），但在这个节点（node）内部实际上是一个大小为26或z的数组。我们要做的是，每当我们插入一个单词，比如名字“哈利”（harry）或“海格”（hagrid）时。
- en: hermione or anyone else，we are going to walk through the letters，of their name
    like h a。g r id and we are going to，follow a series of pointers，from one node
    to another as follows so。for instance if this is a through z or，zero through 25，here
    is location h so if the goal at the。moment is to insert the first，of our contacts
    for instance harry。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是赫敏（hermione）还是其他人，我们将逐个字母地走过他们的名字，比如h a g r i d，我们将从一个节点到另一个节点遵循一系列指针。例如，如果这是从a到z或从0到25，这里是字母h的位置，所以如果此刻的目标是插入我们的第一个联系人，例如哈利（harry）。
- en: i'm going to start by looking at the，first node the root of the tree。looking
    up the h location and i'm going，to kind of make mental note that harry。starts
    there the h in harry starts there，then if i want to insert the a in harry。i'm
    going to go ah**d，letters，but i'm going to sort of keep track of，the fact that
    okay a is here。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从树的根节点（root）开始，查看字母h的位置，并在心中记下哈利（harry）的h是从这里开始的，然后如果我想在哈利（harry）中插入字母a，我将去找字母a的位置。
- en: so now i'm going to have another pointer，oh i'm sorry not harry hagrid first，uh
    h a g r i。d so what have i just done a try again，is a tree each of whose nodes。is
    an array and each of those arrays，is an array of pointers to other nodes。so again
    we're really just mashing up，everything together here but it's the。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将有另一个指针，哦，对不起，不是哈利（harry），是海格（hagrid），首先是h a g r i d。那么我刚刚做了什么？尝试（try）仍然是一棵树，每个节点都是一个数组，而每个数组都是指向其他节点的指针数组。因此，我们实际上是在这里将所有东西混合在一起。
- en: same building blocks as before，each node in this tree top to bottom is，an array
    of pointers，check。if hagrid is in my contacts i literally，start at the first node。and
    i follow the h pointer i then follow，the a pointer i then follow the g。pointer
    the r pointer the i pointer and，then i check at the d。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的构建模块一样，这棵树中的每个节点（node）从上到下都是一个指针数组（array of pointers）。检查哈格里德（hagrid）是否在我的联系人中，我实际上从第一个节点开始，跟随h指针，然后跟随a指针，再跟随g指针，接着是r指针、i指针，最后检查d。
- en: pointer is there a boolean value inside，time，perhaps that just says yes or no
    there。is someone named h-a-g-r-i-d，in my contacts notice there's no other。letters
    noted at the moment and there's，no other green boxes，green just denotes a boolean
    value for。our purposes now so that means there's，no one whose name is h-a-g-r-i-a，h-a-r-h-a-g-r-i-d。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 指针里是否有一个布尔值，可能只是表示是或否，这里有一个叫h-a-g-r-i-d的人。请注意此时没有其他字母标注，也没有其他绿色框，绿色只是为我们的目的表示一个布尔值，这意味着没有任何人名叫h-a-g-r-i-a，h-a-r-h-a-g-r-i-d。
- en: that exists in my contacts but notice，what happens next now if i go ah**d and，insert
    harry。notice that harry and hagrid share the h，the a and then this third node
    but then，pointer。to store the r and the y and notice the，green there it's sort
    of a check mark in。the data structure a boolean value，that's saying yes i have
    someone in my，context name h-a-r-r-y。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我在联系人中存在这个，但请注意，如果我继续往下走，插入哈利会发生什么。注意哈利和海格共享h、a，然后这个第三个节点，但接下来，指针。用来存储r和y，注意那里的绿色，数据结构中的一种检查标记，一个布尔值，表示我在我的上下文中有一个名叫h-a-r-r-y的人。
- en: and then if we add hermione she shares，the h，and then also the second node but。hermione
    requires some new nodes。![](img/048b7fb31d80a37bbdc5116c8b723aaf_29.png)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果我们添加赫敏，她共享h，然后也共享第二个节点，但赫敏需要一些新的节点。![](img/048b7fb31d80a37bbdc5116c8b723aaf_29.png)
- en: property，the reason for this sort of complexity，because this is probably the
    weirdest。structure we've seen thus far，is that even if i have a billion names，in
    my phone book。how many steps literally does it take me，to find hagrid，someone
    feel free to chime in in the。text the chat window if you'd like，even if i have
    a billion names in my。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 特性，这种复杂性的原因，因为这可能是我们到目前为止见过的最奇怪的结构，即使我在电话本中有十亿个名字。我找到海格究竟需要多少步骤，随时欢迎在聊天窗口中插入你的意见。如果我在数据结构中有十亿个名字，其他名字的数量并不影响找到赫敏或其他人的步骤，仅仅取决于她们名字的长度。
- en: contacts how many steps does it take for，me to look up and check if hagrid is，among
    them。people are saying six six h a g，r i d if i have two billion names four，take，time。constant
    time at least in the length of，these uh the humans names in the book。in the book
    in the in the data structure，so what does this mean，try。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人中，我需要多少步骤来查找并检查海格是否在其中。人们说六个，六个h a g r i d，如果我有二十亿个名字，四个需要，至少在这些人名的长度上是常量时间。数据结构中的书籍，那么这意味着什么，尝试。
- en: data structure the number of other names，does not impact how many steps it takes，hermione。or
    anyone else it is only dependent on，the length of their name and here's。where
    we can get a little academic if，you assume that there's a finite number。of characters
    in any human，real or imaginary's name maybe it's 20。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以稍微学术化的地方，如果你假设任何人类的名字，无论真实还是虚构，字符的数量是有限的，也许是20个。
- en: or 100 or whatever it's more than six，but it's probably fewer than hundreds。then
    you can assume that that's constant，so it might be big o of like 200，name。but
    that's constant and so technically a，try gives you that holy grail of lookup。times
    and insertion times of big o of 1，because it is not dependent on n which。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者100或者其他什么，总之超过六个，但可能少于几百。然后你可以假设这是常量，所以它可能是大O，比如200，名字。但这就是常量，因此技术上来说，尝试给你提供了查找时间和插入时间的大O为1，因为它不依赖于n。
- en: is the number of other names，in the data structure it is dependent，inputting。and
    if you assume that all names in the，world are reasonably length less than，some
    finite value like。6 or 200 or whatever it is then you can，call that and it technically
    is。big o of 1 that is constant time，so here is that the goal of this whole。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 是数据结构中其他名字的数量，它取决于输入。如果你假设世界上所有的名字都合理长度小于某个有限值，比如6或200或者其他什么，那么你可以称之为技术上是。大O为1，即常量时间，所以这里是整个目标。
- en: day like trying to get to constant time，would seem，linear time or logarithmic
    time or。anything else we've seen but but but，price，have we just paid if you see
    it。why are tries not necessarily，all that there's still a catch，um yeah so actually。like
    for example if let's say you wanted，you had two people in your contact list。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，像是尝试达到常量时间，似乎是线性时间或对数时间或我们见过的其他任何东西，但，代价，我们刚刚付出了什么。如果你看到，为什么尝试不一定，还是有一些问题，嗯，实际上。比如说，如果假设你在联系人列表中有两个人。
- en: one person was named daniel，and one person was named danielle and。and you know
    that daniel is in your list，so the l would have this like。boolean operator of
    like true but then，how would you get to danielle。if your l was an operator and
    it didn't，point to another l for danielle。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个人叫丹尼尔，另一个人叫丹妮尔，你知道丹尼尔在你的列表中，所以l会有一个类似于真的布尔运算符，但那么，如果你的l是一个运算符而不指向丹妮尔的另一个l，你该怎么到达丹妮尔呢？
- en: really good question a corner case if，you will what if someone's name，so daniel。daniel
    d-a-n-i-e-l and i think you're，saying danielle d-a-n-i-e-l-l-e。so the second name
    is a little longer，let me stipulate that we can solve that，i have not shown。code
    that represents each of the nodes，in this tree let me propose that we，could continue
    having。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好问题，算是一个边缘案例，如果有人的名字，比如丹尼尔，d-a-n-i-e-l，而我想你说的是丹妮尔，d-a-n-i-e-l-l-e。那么第二个名字稍微长一点，让我说明我们可以解决这个，我没有展示代表树中每个节点的代码，让我建议我们可以继续拥有。
- en: arrows even below so if we were to have，daniel in this tree，we could also have
    danielle by just。having a couple of more nodes below，daniel and just having another
    green。check mark so it is solvable in code，even though it's not obvious from the。graphical
    representation but absolutely，solvable。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在下面，如果我们在这棵树中有丹尼尔，我们也可以通过在丹尼尔下方再增加几个节点来拥有丹妮尔，只需再添加一个绿色勾选，所以在代码中是可以解决的，尽管从图形表示上并不明显，但绝对是可解决的。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_31.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_31.png)'
- en: in tries what might another downside be，though of a try，like you do get big
    o of one time you。can solve the daniel danielle problem，any thoughts yeah how
    about over to uh。oh still muted uh there we go，oh there we go uh yeah i'm eating
    um i，lot of。uh memory to house all of that and that，could take a lot of time a
    lot of um。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前缀树中，可能还有另一个缺点，尽管你能以O(1)的时间解决丹尼尔问题，有什么想法吗？对了，还是静音状态，哦，来了，哦，好的，我需要，花费大量的，呃，内存来容纳这一切，这可能需要很多时间，很多，呃。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_33.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_33.png)'
- en: could slow down the system exactly yeah，you can kind of see it from my picture。alone
    we only added three names to this，data structure but my god like，pointers。pictured
    here even though they might all，be null right if the absence of an arrow。here
    suggests that they're null，o x zero but even storing null ox0，is eight zero bits
    so this is not。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会减慢系统的速度，没错，你可以从我这幅图中看出，虽然我们只向这个数据结构添加了三个名字，但我的天，像这里所示的指针，尽管它们可能都是null，对吧，如果没有箭头就暗示它们是null，0x0，但即使存储null
    0x0，也是8个零位，所以这并不。
- en: lacking for，actual memory usage we're just not using，it very efficiently we
    have spent a huge。number of bits，or bytes or however you want to measure，it because
    look even with the h's。i'm using one pointer out of 26 25，pointers are probably
    initialized to。null which means i'm wasting 25 pointers，and you can imagine the
    lower and lower。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的内存使用却缺乏效率，我们并没有高效地使用它，我们花费了大量的位、字节，或者无论你想如何衡量，因为即使考虑到h，我只使用了26个指针中的一个，25个指针可能初始化为null，这意味着我浪费了25个指针，你可以想象得越来越少。
- en: you get in this tree the less，likely there is to be a name that even，starts
    with h-a-g-r-i-d。daniel came up with a good example with，danielle but that's not
    going to。often happen certainly the lower you get，in this tree so as e10 says。you're
    wasting a huge amount of memory，so yes you're gaining，price。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这棵树中，名字以h-a-g-r-i-d开头的可能性越小。丹尼尔提供了一个不错的例子，而丹妮尔并不会经常发生，当然在这棵树中你得到的越低，正如e10所说，你浪费了大量的内存，因此是的，你获得了，价格。
- en: you might be using megabytes gigabytes，of storage space because again the most。important
    property of an array，is that it's all contiguous and，you have to have。every node
    containing an array of size，26 or anything else，the memory。over and over again
    so there too is a，trade-off while this might be，theoretically ideal。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在使用兆字节、千兆字节的存储空间，因为最重要的数组属性是它们都是连续的，你必须让每个节点包含一个大小为26的数组，或者其他任何东西，内存会反复使用，所以在这方面也是一种权衡，尽管理论上可能是理想的。
- en: theory does not necessarily mean，something that is，textbook less efficient might
    actually。be more efficient in the real world and，in problem set five in your own。uh
    spell checker uh when you build up，this dictionary that we then use to。spell check
    very large corpuses of text，will you begin to experience some of。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 理论并不一定意味着，有些教科书上效率较低的东西在现实世界中可能更有效率，并且，在你的第五个问题集中，呃，拼写检查器，呃，当你建立这个字典时，我们随后用它来对非常大的文本语料库进行拼写检查，你将开始体验到一些。
- en: those real world trade-offs yourself，well we wanted to end today with a look。at
    what else you can do with these kinds，of data structures just to give you a。taste
    of where else you can go with this，and what other kinds of problems you can。solve
    again thus far we've looked at，arrays which are really the simplest of。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些现实世界的权衡你自己，嗯，我们今天想结束的是看一下。你可以用这些种类的数据结构做些什么，只是为了让你尝试一下你还能去哪里，能解决什么其他类型的问题，再次到目前为止我们已经看过，数组，它们实际上是最简单的。
- en: data structures and they're not even，structures per se it's just contiguous，blocks
    of memory。course where you have this，one-dimensional，data structure that allows
    you to stitch。together nodes in memory giving you，de-allocation，inserting and
    deleting nodes if you want。then we had，trees which kind of gives us the best of，both
    worlds arrays。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构而且它们甚至不是，结构本身，它只是连续的，内存块。课程中你有这种，一维数据结构，它允许你连接。内存中的节点，让你能够，去分配内存、插入和删除节点，如果你想的话。然后我们有，树，这在某种程度上给了我们最好的，数组的两全其美。
- en: and linked lists but we have to spend，more space and use more pointers。then
    of course hash tables kind of merge，together two of those ideas arrays。and linked
    lists and that starts to work，well and indeed that's what you'll，checker。but then
    of course there's tries which，at first glance seem better。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还有链表，但我们必须花费，更多空间并使用更多指针。然后当然哈希表将这两种想法，数组和链表合并在一起，这开始运作，确实这就是你所，检查的。但随后当然还有字典树，乍一看似乎更好。
- en: but not at great not without great cost，as e10 says，so it turns out with all
    of those。building blocks at your disposal，you can actually use them as lower level，implementation
    details。to solve higher level problems and this，is what are known as abstract
    data。structures or abstract data types an，abstract data structure，is kind of a
    mental structure that you。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是并不是没有巨大代价，正如e10所说，所以结果是，所有这些构建块在你手边，实际上你可以将它们作为低层，实施细节。来解决更高层的问题，这就是所谓的抽象数据。结构或抽象数据类型，抽象数据结构是一种你。
- en: can imagine implementing some real world，problem typically，that's implemented
    with some other data。at this level，but you're thinking about what you've，built
    ultimately at this level and。that's abstraction，taking lower level implementation，details
    simplifying them。for the sake of discussion or problem，solving higher up，so what's
    one such data structure a。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象实现一些现实世界的，问题，通常这会与一些其他数据一起实现。在这个层面上，但你在思考你所，最终构建的内容。那就是抽象，将低层实现，细节简化。为了讨论或解决更高层的问题，那么这样的数据结构是什么呢。
- en: queue is a very common，abstract data structure what is a queue。well those of
    you who grew up and say in，queue，and that's indeed where it gets its name。a queue
    is a data structure that has，certain properties so if you're standing。outside
    of a store or a restaurant in，healthier times waiting to get in。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个非常常见的，抽象数据结构，什么是队列。好吧，那些在，队列中长大的人，确实是它名字的来源。队列是一个具有，特定属性的数据结构，所以如果你站在。商店或餐厅外，在，健康的时光里等待入内。
- en: you're generally in a queue but there's，an important property of a cue at least。if
    you live in a fair society，you'd like to think that if you are the，first one in
    line，first in。first out it would be kind of obnoxious，if you're first in line
    and then they。start letting people in who are behind，you in that queue，so a queue
    if it's implemented correctly。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常在队列中，但队列有一个重要属性，至少。如果你生活在一个公平的社会，你会想，如果你是，第一位排队的，先进先出。如果你是第一位排队，然后他们开始让在你后面的人进入，那会显得有些令人不悦，因此，如果队列实现正确。
- en: has a property known as，fifo first in first out and we humans，property。and a
    queue generally has two operations，associated with it at least。![](img/048b7fb31d80a37bbdc5116c8b723aaf_35.png)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个称为，FIFO（先进先出）的属性，而我们人类，具备这一属性。队列通常有两个操作，至少与之相关联。![](img/048b7fb31d80a37bbdc5116c8b723aaf_35.png)
- en: nq and dq those are just conventions you，could call it add and remove or insert，delete
    whatever。but nq and dq are sort of the more，common ones to say，so enqueuing means
    you walk up to the。have to wait，dq means they're ready to serve you or，that's
    dq，that describes。a key property of that which is that，it's first in first，out
    so how could you implement。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: nq 和 dq 只是约定，你可以称其为添加和删除或插入，删除等。不管怎样，nq 和 dq 是比较，常见的说法，所以入队意味着你走到。不得不等待，出队意味着他们准备好服务你或，那是出队，描述了。一个关键属性就是，它是先进先出，所以你如何实现。
- en: a queue then well what's interesting，about that data structure is that it's，than
    an。actual thing in code you want to，implement some kind of fair。queuing system
    and so you think of it as，a queue but frankly。if we're going to translate that
    example，array，of persons that could implement a cue。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有关该数据结构有趣的是，它比代码中的实际事物更重要，你想实现某种公平的排队系统，因此你将其视为队列，但坦率地说，如果我们要将这个例子翻译成数组，人员数组可以实现一个队列。
- en: you could use a linked list of persons，work，underneath the hood is the lower
    level。implementation details，but what would be a problem if we，translate this
    real world。analogy like queuing up outside of a，store to get in，into code and
    you used an array what。would a downside be，of using an array to represent a q，in
    general even though we're making a。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个人的链表，底层工作是在较低级别的实现细节，但如果我们将这种现实世界的类比翻译成代码，将排队在商店外面进入，使用数组的话，使用数组表示队列的缺点是什么，即使我们正在做。
- en: bit of a leap from like real world to，code suddenly but there's probably a，downside。what
    might a downside be of using an，oh still muted if you're，if you're using an array
    you can't。really just，take out the existing values you would，still have a bunch
    of。because if you're thinking about doing，this in a line you would have to take，person。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从现实世界到代码的转变有点大，但可能会有一些缺点。使用数组的缺点可能是什么，如果你正在考虑在一条线中做这件事，你必须把一个人拿出来。
- en: but you can't really dynamically sort of。![](img/048b7fb31d80a37bbdc5116c8b723aaf_37.png)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但你无法真正动态排序。![](img/048b7fb31d80a37bbdc5116c8b723aaf_37.png)
- en: change the memory after that，yeah yeah that's a really good point。think about
    a line suppose that there's，like a line，that can fit 10 people outside the apple。now
    during，the health crisis of letting people in，only so many at a time so suppose
    they。have room for 10 people six feet apart，that's actually a pretty apt analogy，this
    year more than ever。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后更改记忆，是的，是个很好的观点。想象一下有一条线，假设有一条线可以容纳10个人在苹果店外。现在在健康危机期间，让人们进入的限制是一次只能容纳那么多人，所以假设他们有空间容纳10个人，间隔六英尺，这实际上是一个非常贴切的类比，今年比以往任何时候都更明显。
- en: but as ryan says if you want to take，someone if you want to dq someone。then
    the first person in line is going，to go into the store and then the second，into
    the store。the problem with an array it would seem，is that now you have essentially
    empty。spaces at the beginning of the line but，you still don't have room at the
    end of。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如瑞安所说，如果你想让某人，如果你想从队列中删除某人，那么排在第一位的人将进入商店，第二位也将进入商店。使用数组的问题似乎是，现在你基本上在队列的开头有空位，但在队列的末尾仍然没有空间。
- en: the line for new people now there's an，obvious real world solution there you。just
    say hey everyone would you mind，taking a few steps forward。but that's inefficient
    like not so much，the store，but in code that's copying of values you。have to move
    like eight values，two places over if two people were just，let into the store。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新来的人来说，现在有一个明显的现实世界解决方案，你只需说：“嘿，大家能否向前走几步。”但这效率不高，不仅仅是商店的问题，而是在代码中，这涉及到值的复制，如果有两个人刚被允许进入商店，你必须移动八个值，两个位置。
- en: so now your dq operation is big o of n，and that doesn't feel quite ideal and
    we。can do better than that if we're a，and such，but that would be one challenge
    of a，queue certainly。using，an array so you might imagine too and，array is limited
    too because it would。kind of be obnoxious if you get to the，apple store there's
    already 10 people。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你的双端队列操作是O(n)，这感觉并不理想，如果我们是这样的话，但这无疑是队列的一个挑战。使用数组也有限制，因为如果你到达苹果店时，已经有10个人在排队。
- en: online and they don't let，you get in line they say sorry we're all，not。because
    eventually there'll be more room，in the queue a linked list would allow。you to
    keep appending more and more，people and even if the line outside the，store gets
    crazy long。at least the linked list allows you to，service all of the customers。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 线上，他们不让你进入，他们会说对不起，我们已经满了。因为最终队列中会有更多的空间，链表将允许你不断添加更多的人，即使商店外的队伍变得非常长，至少链表可以让你服务所有客户。
- en: who are showing up over time an array of，fixed size，would make that harder and
    again you。could allocate a bigger array but then，you're going to have to ask all
    the，here。no go back over there i mean you're，constantly moving humans or。values
    and memory back and forth so that，is only to say that to implement this。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移出现的数组，固定大小会使这变得更加困难，你可以分配一个更大的数组，但你得询问所有人。这里不，回去那里，我的意思是你不断在内存中移动人或值，所以这只是说，要实现这一点。
- en: real world notion of a cue which is very，commonly used even in the computer
    world。to represent certain ideas uh for，instance，printer queue when you send something
    to，a company。there's a queue and ideally the first，person who printed is the first
    one who。gets their printouts thereafter，queues are also used in software but，there。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中有一种队列的概念，在计算机世界中也很常用，以表示某些概念，比如打印队列。当你向公司发送文件时，会有一个队列，理想情况下，第一个打印的人是第一个收到打印件的人，之后队列也在软件中被使用，但。
- en: besides cues one of them is called a，stack so a stack，is a data structure that
    can also be。implemented underneath the hood，using arrays or linked lists or heck，maybe
    something else，it's last。in first out last in first，out so if you think about
    the trays in a。cafeteria in healthier times when，everyone is on campus using trays
    from a，cafeteria。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提示，还有一个叫做栈的数据结构，它也可以通过数组、链表或其他方式在底层实现，采用后进先出（LIFO）原则。如果你想象一下自助餐厅的托盘，在大家都在校园里使用托盘的健康时光。
- en: you'll recall of course that trays tend，to get stacked like this and the，uh
    last uh the last tray。to go on top of the stack is the first，one to come out，if
    you go to a clothing store or your。own closet if you don't hang things on，hangers
    or put them in drawers but kind。of stack them like here，like all of these sweaters
    this is a，sweater i want。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得托盘通常像这样堆叠，最后放上去的托盘是第一个被取出的。如果你去服装店或自己的衣橱，如果你不把东西挂在衣架上或放进抽屉，而是像这样堆放所有的毛衣，这就是我想要的毛衣。
- en: well the easiest way to do it is with，last in first，out so i constantly take
    the black。sweater the black sweater but if i've，stored all of my sweaters in this
    stack，you may never get to。the sort of lower level ones like the，red or the blue
    sweater。because again of this data structure so，lifo last in，first out is in fact
    the property used。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方式是使用后进先出，因此我不断取出黑色毛衣，如果我把所有的毛衣都存储在这个栈中，你可能永远也得不到下面的红色或蓝色毛衣。这就是数据结构的原因，所以后进先出实际上是使用的属性。
- en: to characterize，stacks and stacks are useful，or not useful depending on the
    real，computing。we'll see applications over time where，stacks indeed come into
    play and those。two operations that those things support，are generally called push
    and pop it's。the same thing as add or remove or，insert or delete but the terms
    of art。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 来描述栈，栈的有用与否取决于实际计算。随着时间的推移，我们会看到栈确实发挥作用，那两种操作通常被称为推入（push）和弹出（pop），这与添加、删除或插入是同一回事，但术语有所不同。
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_39.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_39.png)'
- en: are generally push，off of the stack，this is me pushing a value onto the，stack
    but again，as lifo。and then there's this other data，world，uh analog known as a
    dictionary a。dictionary is an abstract data type，which means you can implement
    it with。arrays or linked lists or hash tables or，tries or whatever else。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会从栈中推出，这就是我把一个值推入栈中，但这也是后进先出。然后还有另外一种数据结构，称为字典。字典是一种抽象数据类型，这意味着你可以用数组、链表、哈希表、字典树或其他方法来实现它。
- en: an abstract data type that allows you to，associate keys with values。and the
    best analog here is indeed in，the real world what is a dictionary like。an old
    school dictionary that's actually。![](img/048b7fb31d80a37bbdc5116c8b723aaf_41.png)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一种抽象数据类型，允许你将键与值关联。这里最好的类比确实是在现实世界中，像一本老式字典那样的字典。![](img/048b7fb31d80a37bbdc5116c8b723aaf_41.png)
- en: printed on paper in book form，what is that what is inside that book a。whole
    bunch of keys a whole bunch of，bold-faced words，like apple and banana and so forth
    each。of which have，definitions otherwise known as values，and they're often alphabetized
    to make。it easier for you to find things so that，you can look things up more quickly。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 书本形式的纸质印刷品，书里面有什么呢？一堆关键字，一堆加粗的词，比如苹果、香蕉等等，每个词都有定义，也就是所谓的值，它们通常按字母顺序排列，以便于你更快地查找。
- en: but a dictionary is an abstract data，type that associates，keys with values and
    you look up the。values by way of their keys just like，you look up a word's definition，by
    way of the word itself and。dictionaries，are actually kind of all around us too，you
    don't think of them in these terms。probably but if you've ever been to，sweet green
    for instance，um in new haven or in cambridge or。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些朋友在另一所机构中区分了栈和队列的概念。字典是一种抽象数据类型，将键与值关联，通过键查找值，就像你通过单词本身查找词义一样。字典实际上随处可见，你可能并不这样认为。如果你曾经去过甜绿，例如，在纽黑文或剑桥。
- en: elsewhere this is a salad place，where nowadays especially you can order。in advance
    online or on an app and then，go into the store，and pick up your food from a shelf
    but。cambridge，and in other cities is they actually，have letters of the alphabet
    on the，shelves a b。c d e f all the way through z the idea，being that if i go in
    to pick up my。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个沙拉店，如今尤其可以提前在网上或应用上订购，然后进入店里，从货架上取食物。但在剑桥和其他城市，他们实际上在货架上贴有字母a到z，想法是如果我去取我的。
- en: salad it's probably on the d，section if brian goes in to pick up his，it's in
    the b section。and so forth now here too you can，imagine perverse，corner cases
    where this data structure。this dictionary whereby letters of the，salad，is not
    necessarily fail proof like can。you think of a perverse，corner case where sweet
    green's very，wonderful methodical system。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 沙拉可能在d区，如果布莱恩去取的话，它就在b区。如此类推，你可以想象一些反常的边缘情况，这种数据结构，这个字典，其中沙拉的字母并不一定是万无一失的。你可以想到一个反常的边缘情况，甜绿非常出色的系统。
- en: actually breaks down can you think of a，limitation here，even if you've never
    been to sweet green。or never eaten salad like what，could break down with this
    system if。going into a store and picking something，up based on，your name any thoughts
    a few people say。there might be a problem if two people，have the same name，yeah
    if two people have the same names。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到这里的限制吗？即使你从未去过甜绿或从未吃过沙拉，这个系统如果以你的名字进入商店并取物品，可能会出现什么问题？有些人说如果两个人有同样的名字，可能会有问题，是的，如果两个人有相同的名字。
- en: you start to sort of stack things up so，literally sweet green will start。stacking
    one solid on top of the other，so there is actually an interesting。incarnation
    of one data type being built，on top of yet another data type so again。all of these
    are sort of like custom，scratch pieces if you will that we're。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始将东西堆叠起来，甜绿实际上会开始将一个沙拉叠在另一个沙拉上，这实际上是一个有趣的数据类型在另一个数据类型之上的实例。因此，这些都是像我们正在不断重组的自定义拼贴。
- en: constantly sort of reassembling into，more interesting and powerful ideas。but
    at some point if there's a lot of b，alphabet，i surely see a finite height to this。shelf
    so it's kind of as though sweet，using，stacks with arrays because arrays are。fixed
    size so there's surely only，so many inches of space here vertically。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不断将它们重新组装成更有趣、更强大的想法。但如果有很多b字母，我肯定会看到这个货架的有限高度。因此，甜绿在使用数组时就像使用栈，因为数组是固定大小的，所以这里垂直空间也只有这么多。
- en: so you can see a real world limitation，so what does sweep green do if that，cheat。and
    put the b's in the c section or the，d's and the e section like who really。cares
    in the real world your eyes are，probably going to skim left and right。but algorithmically
    that is slowing，things down and in the worst case if，salad。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一个现实世界的限制，那么甜绿如果出现这种情况怎么办？把b放在c区或者d和e区，谁在乎呢？在现实中，你的眼睛可能会左右扫视。但在算法上，这会减慢速度，在最坏的情况下，如果沙拉。
- en: or sweet green is really popular and，shelf，your name might be albus but your
    salad，section。if they're just out of room and so that，too is a valid，algorithmic
    decision to just make room。somewhere else but again，trade-offs between time and
    space and so，some。friends of ours at another institution，distinguish，these notions
    of stacks versus queues a。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甜绿真的很受欢迎，你的名字可能是阿尔巴斯，但你的沙拉区。如果他们的空间不够，这也是一个有效的算法决策，只是在其他地方腾出空间。但再次强调时间和空间之间的权衡，还有一些。
- en: stack and again a queue or these，abstract data types that can be。implemented
    in different ways they have，different properties，each of them respectively fifo
    or lifo。and here for instance is a final look in，our final moments together here
    today。about how these ideas manifest，unlike，[Music]。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '堆栈和队列，这些抽象数据类型可以以不同方式实现，它们有不同的属性，各自分别是fifo或lifo。这里是一个最终的回顾，在我们今天最后的时刻，关于这些想法如何表现，*不同于*，[音乐]。 '
- en: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_43.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7fb31d80a37bbdc5116c8b723aaf_43.png)'
- en: once upon a time there was a guy named，jack when it came to making friends。![](img/048b7fb31d80a37bbdc5116c8b723aaf_45.png)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从前有个叫杰克的人，他在交朋友方面很困难。![](img/048b7fb31d80a37bbdc5116c8b723aaf_45.png)
- en: jack did not have the knack so jack went，to talk to the most popular guy he
    knew。he went up to blue and asked what do i，distressed。![](img/048b7fb31d80a37bbdc5116c8b723aaf_47.png)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 杰克没有这项本领，所以他去找他认识的最受欢迎的人。他走向蓝色，问我该怎么做，感到沮丧。![](img/048b7fb31d80a37bbdc5116c8b723aaf_47.png)
- en: well lou began just look how you're，a，different look yes said jack i sure do。come
    to my house and i'll show them to。![](img/048b7fb31d80a37bbdc5116c8b723aaf_49.png)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，路开始说，看看你是多么不同，确实，杰克，我确实这样做。来我家，我会给你看它们。![](img/048b7fb31d80a37bbdc5116c8b723aaf_49.png)
- en: you so they went off the jacks and jack，showed lou the box，where he kept all
    his shirts and his。![](img/048b7fb31d80a37bbdc5116c8b723aaf_51.png)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所以他们去找杰克，杰克给路展示了盒子，里面放着他所有的衬衫和他的。![](img/048b7fb31d80a37bbdc5116c8b723aaf_51.png)
- en: pants and his socks，luce said i see you have all your，clothes in a pile why
    don't you wear。![](img/048b7fb31d80a37bbdc5116c8b723aaf_53.png)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 裤子和袜子，路说我看到你把所有的衣服都堆在一起，为什么不穿。![](img/048b7fb31d80a37bbdc5116c8b723aaf_53.png)
- en: some others once in a while，socks。![](img/048b7fb31d80a37bbdc5116c8b723aaf_55.png)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有时还有其他的，袜子。![](img/048b7fb31d80a37bbdc5116c8b723aaf_55.png)
- en: i wash them and put them away in the box，then comes the next morning and up。![](img/048b7fb31d80a37bbdc5116c8b723aaf_57.png)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它们洗净并放入盒子，然后第二天早上来。![](img/048b7fb31d80a37bbdc5116c8b723aaf_57.png)
- en: i hop i go to the box and get my clothes，off the top，lou quickly realized the
    problem with。![](img/048b7fb31d80a37bbdc5116c8b723aaf_59.png)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳起来，去盒子里取我的衣服，从顶部拿下来，路迅速意识到问题所在。![](img/048b7fb31d80a37bbdc5116c8b723aaf_59.png)
- en: stack，when he reached for something to read or，to wear he chose a top book。or
    underwear then when he was done he。![](img/048b7fb31d80a37bbdc5116c8b723aaf_61.png)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 堆放，当他伸手去拿东西阅读或穿着时，他选择了一本顶书或内衣，然后完成后他。![](img/048b7fb31d80a37bbdc5116c8b723aaf_61.png)
- en: would put it right back，back it would go on top of the stack i。![](img/048b7fb31d80a37bbdc5116c8b723aaf_63.png)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 会把它放回去，回去时它会放在堆的顶部我。![](img/048b7fb31d80a37bbdc5116c8b723aaf_63.png)
- en: know the solution said a triumphant lou，you need to learn to start using a queue。![](img/048b7fb31d80a37bbdc5116c8b723aaf_65.png)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 知道解决方案的路说，得意洋洋地说，你需要学会开始使用队列。![](img/048b7fb31d80a37bbdc5116c8b723aaf_65.png)
- en: a closet，and when he had emptied the box you just，tossed it then he said now
    jack。![](img/048b7fb31d80a37bbdc5116c8b723aaf_67.png)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一个衣柜，当他把盒子倒空后，你刚好把它扔掉，然后他说，现在杰克。![](img/048b7fb31d80a37bbdc5116c8b723aaf_67.png)
- en: at the end of the day put your clothes，on a left when you put them away。![](img/048b7fb31d80a37bbdc5116c8b723aaf_69.png)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在一天结束时，把你的衣服放在左边，当你把它们收起来时。![](img/048b7fb31d80a37bbdc5116c8b723aaf_69.png)
- en: then tomorrow morning when you see the，sunshine get your clothes from the right。![](img/048b7fb31d80a37bbdc5116c8b723aaf_71.png)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后明天早上，当你看到阳光时，去右边取你的衣服。![](img/048b7fb31d80a37bbdc5116c8b723aaf_71.png)
- en: from the end of the line don't you see，said lou it will be so nice。you'll wear
    everything once before you。![](img/048b7fb31d80a37bbdc5116c8b723aaf_73.png)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从队伍的末端你难道没看到吗，路说，这样会很好。你会在穿之前穿过每一件。![](img/048b7fb31d80a37bbdc5116c8b723aaf_73.png)
- en: wear something twice，and with everything in queues in his，closet and shelf。jack
    started to feel quite sure of，himself all thanks to lou。![](img/048b7fb31d80a37bbdc5116c8b723aaf_75.png)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 穿东西两次，所有的东西都排队放在他的衣柜和架子上。杰克开始对自己感到相当自信，都是因为路。![](img/048b7fb31d80a37bbdc5116c8b723aaf_75.png)
- en: and his wonderful cue，alright that's it for cs50 we will see。![](img/048b7fb31d80a37bbdc5116c8b723aaf_77.png)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 还有他美妙的提示，好吧，这就是cs50的全部，我们会再见。![](img/048b7fb31d80a37bbdc5116c8b723aaf_77.png)
