- en: P3：Lecture 3： Processes, System Calls, and Fork - RubatoTheEmber - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P3：第三讲：进程、系统调用和Fork - RubatoTheEmber - BV1L541117gr
- en: Welcome back everybody to lecture number three of CS162 and we're going to pick
    up where we left off。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎大家回到CS162的第三讲，我们将从上次的内容继续。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_1.png)'
- en: And if you remember last time we talked about four fundamental OS concepts that
    help get us right away into sort of the meat of what operating systems do with
    respect to scheduling。 One was the idea of a thread， which was an execution context
    like a virtual CPU or processor。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们上次谈到的四个操作系统的基本概念，这些概念帮助我们直接进入操作系统在调度方面的核心内容。一个是线程的概念，它是一个执行上下文，像是一个虚拟CPU或处理器。
- en: which fully describes the program state， it's got a program counter registers，
    execution flag stack。 etc。 We talked about address spaces， both with and without
    translation。 And that's basically the set of memory addresses that are accessible
    to a program。 and they may be distinct from the memory space of the physical machine
    so in principle。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完整描述程序状态的内容包括程序计数器、寄存器、执行标志、堆栈等。我们讨论了地址空间，包括有翻译和没有翻译的情况。基本上，地址空间就是程序可以访问的内存地址集合，它们可能与物理机器的内存空间不同，因此从原则上来说。
- en: every address space can be a little different in terms of what happens when
    you go to the addresses。 but they'll all have the same kind of set of addresses
    typically。 A process combines those together to give an instance of a running
    program。 and it's really a protected address space and one or more threads and
    so we're going to work on that theme a little bit more today to give some more
    details and we also had some pretty good discussion on Piazza。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个地址空间在访问地址时可能会有所不同，但它们通常都有相同的地址集合。一个进程将这些地址集合起来，形成一个正在运行的程序实例。它实际上是一个受保护的地址空间，并且包含一个或多个线程，今天我们将更详细地探讨这个主题，也在Piazza上进行了很多很好的讨论。
- en: that you can take a look at from lecture two， and I'm sure that will continue
    for lecture three。 And then the final thing that we talked about which is kind
    of an essential hardware component that helps tie this all together is really
    dual mode operation。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从第二讲中查看这些内容，我相信它们会继续出现在第三讲中。最后我们谈到的一个非常重要的硬件组件，实际上就是帮助将这一切串联起来的双模式操作。
- en: where there's at least two modes system and user， mode， where one of the modes。
    namely the system mode has more access than the other， which is the user mode。
    and unless you have something like this， then it's very hard to actually put any
    sort of protection into the picture。 And so that dual mode operation is going
    to be very important as well。 Okay。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在至少有两种模式的系统和用户模式下，其中一种模式，即系统模式，拥有比另一种模式更高的权限，这种模式是用户模式。除非你有类似的设置，否则很难在系统中加入任何形式的保护措施。因此，这种双模式操作也会非常重要。好的。
- en: so the bottom line as we mentioned last time is really OS is run programs。 And
    remember a program is like， like a proto process or it's ready to run but not
    running yet。 And what you do is you take that program you typically generate it
    via some program source like in the C language or pick your favorite language。
    It gets compiled and linked into that executable。 And then it can get loaded and
    become a process and that process is an executing program。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们上次提到的，操作系统的核心功能实际上是运行程序。记住，程序就像是一个原始进程，它准备好运行但还未执行。你做的事情是，通常通过某种程序源，比如C语言或你喜欢的其他语言，生成程序。它经过编译和链接后，变成可执行文件。然后它可以被加载并变成一个进程，而这个进程就是一个正在执行的程序。
- en: Okay。 All right， and this is this whole path here from writing the source。 compiling
    it and running it is something that you're going to get to do a lot of in this
    term as as we go on with the projects and homeworks。 And notice also that not
    only are we going to be able to play with user programs but we're going to be
    modifying the operating system as well。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题，接下来这一整条路径，从编写源代码、编译到运行，是你在这个学期会经常做的事情，随着项目和作业的推进，你会不断接触到这些内容。还要注意，不仅仅是用户程序我们会涉及，操作系统本身也会被我们修改。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_3.png)'
- en: And the other thing that we're going to just remove refresh your memory a little
    bit was this notion of a protected address space。 which is really something fairly
    simple。 It's the idea that the processor has a set of addresses。 which we're going
    to call virtual addresses that come out。 They go through some sort of translator。
    And they become physical addresses and that's what's actually used to address
    the physical memory。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们想要提醒你的是保护地址空间的概念。其实这是一个相当简单的概念。它的意思是，处理器有一组地址，我们称之为虚拟地址，这些地址通过某种翻译器，变成物理地址，最终用来寻址物理内存。
- en: And this general idea of a translator is one that will show you a number of
    instances as the term goes on。 But just keep in mind that there's kind of the
    addresses the processor uses and the addresses that actually are physical and
    go to DRAM or some other storage media。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为翻译器的这个概念，在整个学期中会给你展示一些实例。但请记住，处理器使用的地址和实际的物理地址（指向 DRAM 或其他存储介质）是不同的。
- en: Those are different。 Okay。 Another thing we had last time。 just to remember
    where we were going was basically a picture like this that's kind of putting it
    all together and showing you what the process is。 And we can have more than one
    thread in a process。 So the simplest thing here is really a single threaded process。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是不同的。好的，另一个我们上次讨论的内容，只是为了帮助你回忆一下我们走到哪里了，那就是一个类似这样的图，试图把一切整合起来，展示进程的概念。我们可以在一个进程中拥有多个线程。所以这里最简单的情况其实是单线程进程。
- en: And we can put more threads in as we wish。 Okay。 And the PCB is basically the
    process control block and we'll talk about that in more detail。 But if you notice
    here， just taking a single threaded process。 we can see that the thread kind of
    encapsulates the concurrency portion or the part that's actually running。 And
    the address space is kind of the storage or protection environment。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要添加更多线程。好的，PCB（进程控制块）基本上就是进程控制块，我们将详细讨论它。但如果你注意到这里，单线程进程的情况，我们可以看到线程封装了并发部分，即实际运行的部分，而地址空间则是存储或保护环境的部分。
- en: And every thread typically has registers and stack that are potentially stored
    in memory for when it's not running。 And if you look at this multi threaded case
    we actually have a bunch of for each thread we have registers and stack associated
    with that。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程通常都有寄存器和栈，可能会存储在内存中，以便在不运行时使用。如果你看这个多线程的例子，我们实际上为每个线程都有与之相关的寄存器和栈。
- en: Okay。 And there were a lot of good questions about multi threading kind of on
    on Piazza as well。 And notice that this protection environment encapsulates all
    of the threads in a multi threaded environment。 So we have， here we have three
    threads， they share the same protection domain。 So that means they can override
    each other by accident。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。关于多线程的问题在 Piazza 上也有很多很好的提问。请注意，这个保护环境封装了多线程环境中的所有线程。所以在这里，我们有三个线程，它们共享相同的保护域。这意味着它们可能会互相覆盖，造成意外情况。
- en: But the reason we want them in the same protection domain is it's much easier
    for them to share information。 And if we really were worried about maliciousness
    or overwriting we would create a separate process with its own threads。 So within
    a process the threads all share the same memory between processes they're protected
    from one another。 Okay。 And it's that protection which we're going to talk more
    about how to get today。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们希望它们处于相同的保护域，因为这样它们共享信息会更容易。如果我们真的担心恶意行为或数据覆盖，我们会创建一个独立的进程，并为它分配自己的线程。所以在一个进程内，所有线程共享相同的内存，而进程之间则是相互隔离的，互相保护。好的，关于如何实现这种保护，我们将在今天的课程中深入讨论。
- en: So there's another good question so these threads and say the multi threaded
    one are they all part of the same application。 Yes。 They're all part they were
    all generated by the same writer or they were linked together， etc。 And so different
    processes can be different applications。 We're also going to talk at the end of
    this lecture about how to have more than one process for application。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以又有一个好问题，这些线程，比如说多线程的那些，都是同一个应用程序的一部分吗？是的，它们都是同一个应用程序的一部分，都是由同一个写入者生成的，或者它们被链接在一起，等等。因此，不同的进程可以是不同的应用程序。我们还将在这节课的最后讨论如何为一个应用程序创建多个进程。
- en: But you never have more than one application per process。 Okay。 Because that's
    the protection domain。 Now， if you remember。 we started this whole process of
    understanding address spaces and translation with this very simple thing I call
    base and bound translation。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但你每个进程中永远不会有多个应用程序。好的，因为那是保护域。现在，如果你还记得，我们开始理解地址空间和翻译的整个过程时，用的是我称之为基址和边界翻译的这个非常简单的例子。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_5.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_5.png)'
- en: And the idea here is that on disk or the image of the program kind of has code
    and data and is going to need room for heap and stack。 And we can think of it
    as starting at address zero as it's linked。 And when we start running it。 we can
    have our physical memory may have many instances of the same program or may have
    different programs。 And they're all going to have different chunks within the
    memory that sort of store their data。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，磁盘上的程序镜像包含代码和数据，并且需要为堆和栈留出空间。我们可以把它当作从零地址开始的链接。当我们开始运行时，物理内存可能会有多个相同程序的实例，或者可能有不同的程序。它们都会在内存中有不同的区域来存储它们的数据。
- en: And notice I put in gray here this is also the kernel， or the operating system
    has its own。 Okay。 And the， in this particular instance， what we notice here is
    that because we put this yellow portion or the program that becomes a process
    here。 starting at one zero zero and memory。 It will no longer be capable of running
    from zero unless we do something and that's where this translation comes into
    play。 So even when the processor talks about an address like zero zero one zero。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里用灰色标出了，这也是内核，或者操作系统有自己的区域。好的。在这个特定的实例中，我们注意到，由于我们将这个黄色部分或者程序（即进程）放到了从一零零开始的内存位置，它将不再能够从零开始运行，除非我们做些什么，而这就是翻译发挥作用的地方。因此，即使处理器提到像零零一零这样的地址，
- en: which would make sense over here， because we have a base and bound base red
    address and bound。 we actually add the base to what the processor does。 And the
    net result is a translated。 a translated address， which is appropriate for where
    it is physically so if you look here the CPU says。 zero zero one zero， which is
    somewhere in the static data。 The data adder。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样在这里就有意义了，因为我们有一个基址和边界的基址红色地址和边界。我们实际上是将基址加到处理器所做的操作上。最终结果就是一个翻译后的地址，它在物理上是适用的，所以如果你看看这里，CPU说的是零零一零，这个地址在静态数据区域内。数据地址。
- en: which is in hardware adds the base address and as a result that addresses make
    sense also in physical memory。 Now there's a question here， several questions
    that are kind of interesting one yeah gray is the operating system。 So two is
    can there be protection without translation and the。 and yeah absolutely yes so
    we the first version of base and bound that we showed you last last。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中添加了基地址，因此这些地址在物理内存中也变得有意义。现在有一个问题，这里有几个有趣的问题，一个是操作系统是什么？第二个问题是，是否可以在没有翻译的情况下进行保护？答案是，当然可以，完全可以。所以我们展示的第一个基址和边界版本，就是上次我们提到的。
- en: week on Thursday was one without the little plus here and all it did was just
    made sure that the addresses that the program had were between base and no farther
    above base than bound。 And that means that when you took stuff out of disk you
    had to actually do the translation with a dynamic linker before it got put into
    memory。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 星期四的那一周没有这个小加号，所有它做的就是确保程序中的地址位于基址和不超过边界的范围内。这意味着当你从磁盘中取数据时，必须通过动态链接器进行翻译，才能将其放入内存。
- en: Once we put this dynamic translation into the picture then the CPU can continue
    using the addresses it thinks are there。 which are relative to the image and the
    hardware translates it for you。 Okay。 now the question of the base and bounds
    always use a constant offset the answer is no。 the operating system loads this
    yellow thing in there and then it sets the base address for where it loaded it
    it sets the bound address for how big it is。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把动态翻译引入进来，CPU就可以继续使用它认为存在的地址，这些地址是相对于镜像的，硬件会为你进行翻译。好的，现在关于基址和边界是否总是使用一个常量偏移的问题，答案是否定的。操作系统将这个黄色部分加载进去后，设置它的基地址以及它的边界地址，表示它的大小。
- en: And we could， you know we could put another copy of the yellow thing here in
    a different part of memory and when it's running we put a different base and bound。
    Okay， all right， now we will get back。 There's a good question here about the
    OS preventing a denial of service attack from malicious process that spawns many
    threads。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以，嗯，我们可以在内存的不同部分放置另一个副本的黄色区域，并且当它运行时，我们设置一个不同的基址和界限。好吧，明白了，现在我们回到刚才的话题。这里有一个很好的问题，关于操作系统如何防止恶意进程通过生成许多线程来发起拒绝服务攻击。
- en: So that's an interesting question， but it's perhaps thinking in the wrong way
    here so all of the threads in a process are part of that。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的问题，但可能是从错误的角度来思考，所以一个过程中的所有线程都是其中的一部分。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_7.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_7.png)'
- en: application and they're written by one person so if you're launching too many
    threads you're basically executing denial of service against yourself and that's
    called a bug。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是由一个人编写的，因此，如果你启动了太多线程，实际上就是在对自己发起拒绝服务攻击，这叫做一个 bug。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_9.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_9.png)'
- en: Okay， now， notice also that because of this base and bound。 the program running
    or the CPU excuse me has no way to address anything below so it can address gray
    or above so it can't go below because that would be a negative address which the
    CPU doesn't do。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在注意到由于这个基址和界限，程序正在运行，或者说 CPU 抱歉，没有办法寻址到低于该位置的任何内容，它只能寻址到灰色区域或以上，所以它不能低于这个位置，因为那将是一个负地址，而
    CPU 是不支持负地址的。
- en: and it can't be above because if the CPU tries to use an address that would
    exceed the bound。 then it's faulted and so this what we've shown you here basically
    protects against this program touching anything that's outside of its bounds。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它不能超出上限，因为如果 CPU 尝试使用一个超出界限的地址，就会触发故障。所以我们在这里展示的内容基本上可以保护程序不去触及超出其界限的任何内容。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_11.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_11.png)'
- en: Okay， now let's take a look briefly。 I started down this path at the very end
    of the lecture last time and I wanted to finish up what we were talking about
    just to go through it。 So if you notice， for instance， here we have the yellow
    program， which is now a process running。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们简要地回顾一下。我在上次讲座的最后开始讲这个话题，我想结束我们讨论的内容。比如你注意到，这里有一个黄色程序，它现在是一个正在运行的进程。
- en: We have another one which is idle is green。 We have the kernel which is idle
    which is gray so right now let's assume again I said last time that there's only
    one core in the whole system or one CPU。 And in that instance when we're running
    in this user code we're not running anywhere else。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个状态是“空闲”是绿色的。我们有一个空闲的内核，它是灰色的。所以现在假设我上次说过，整个系统只有一个核心或一个 CPU。在这种情况下，当我们运行用户代码时，我们没有在其他地方运行。
- en: And so these registers here， which represent registers on the CPU notice that
    the program counter is pointing somewhere in the code。 And the stack pointer is
    pointing somewhere on the stack。 and we have basin bound set up here for starting
    at one zero zero and and then the maximum kind of bound as well。 And as a result
    this program is happily running away in that yellow area。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些寄存器，表示 CPU 上的寄存器，注意到程序计数器指向代码中的某个位置。栈指针指向栈中的某个位置。我们在这里设置了基址和界限，从 100 开始，然后是最大界限。结果是这个程序在黄色区域中愉快地运行。
- en: And notice that we have a system mode bit here which is zero saying that we're
    not in system mode and so we're at user mode。 And so this current execution environment
    is one in which if the code were buggy and it tried to address below or above
    where it's supposed to。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并且注意到我们这里有一个系统模式位，它的值为零，表示我们不在系统模式下，而是在用户模式下。因此，这个当前的执行环境是这样的：如果代码有缺陷，并且它试图寻址到应该不在的区域。
- en: There would be a fault and the operating system would take over。 Okay。 So。 of
    course as you might imagine， if we can't ever get out of yellow then we can't
    run the operating system we can't ever run any other process so clearly there's
    got to be a way to get out of yellow and into the kernel and we'll talk a lot
    more about。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生故障，操作系统会接管。好的。所以，当然，正如你可能想象的那样，如果我们永远无法离开黄色区域，那么我们就无法运行操作系统，也无法运行任何其他进程，所以显然必须有一种方法可以从黄色区域跳到内核区域，我们会进一步讨论这个问题。
- en: either voluntarily yielding or timer interrupts etc as we go on。 but really
    the question is assuming one of those events happens how do we go from this environment
    to one say where the kernel is running。 And you can imagine what needs to happen
    so one we're going to have a system mode go to one。 which is going to mean that
    the basin bound get ignored and now the kernel is going to have control of everything。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是自愿让步还是定时器中断等，随着我们继续进行，问题的核心是，假设其中一个事件发生，我们如何从这种环境转移到另一个，比如说内核正在运行的环境。你可以想象发生了什么事情，所以首先我们要进入系统模式，这意味着基址绑定被忽略，现在内核将控制一切。
- en: So that's one thing。 And the second is going to be that we're going to need
    to save aside the PC and the stack pointer and other registers that are currently
    being used by the user program we need to save that so that we can restore it
    later。 Okay。 And notice also that we're all we're going to have to save them aside
    but then simultaneously go and start running in the kernel。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方面。第二个方面是，我们需要保存当前用户程序正在使用的PC、栈指针以及其他寄存器，我们需要保存这些，以便以后能够恢复它们。好的。并且注意到我们不仅需要保存它们，还要同时开始在内核中运行。
- en: And so here we go so we're going to assume for instance and interrupt just happened
    and take a look at what's a little different here so the basin bound。 which represent
    this yellow thing are not in use because we're in system mode one and so it basically
    is allowing the full set of addresses to be touched。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们假设例如发生了一个中断，看看这里有什么不同之处。基址绑定（代表黄色部分的那个）没有使用，因为我们处于系统模式1，因此它基本上允许访问所有地址范围。
- en: The other thing is that the PC that was running is stored now in the user PC
    register so this is like a register set aside for right after an interrupt to
    keep track of where we came from。 Okay， and we have the new interrupt code which
    is going to be an interrupt vector is going to take us to the operating system。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正在运行的程序计数器（PC）现在被存储在用户PC寄存器中，这就像一个寄存器，用于在中断发生后跟踪我们从哪里来。好的，我们现在有了新的中断代码，它将是一个中断向量，带我们进入操作系统。
- en: And assuming we do all this cleanly at this point now the operating system can
    kind of save all the other registers for the yellow and then maybe allow the green
    to run。 Okay。 Now， there's questions here about you know if virtual memory space
    has everything in it then how can you ever have a segmentation fault。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们所有操作都很干净，此时操作系统可以保存黄色进程的所有其他寄存器，然后可能允许绿色进程运行。好的。现在，这里有个问题：如果虚拟内存空间包含了所有内容，那么如何可能会发生段错误呢？
- en: And basically we'll talk more about that as we go but here's an instance where
    there's a segment we're running in。 which is a restricted size and so if you try
    to go outside of that you get a segmentation fault but it means to have the illusion
    of infinite memory is the operating system could choose to make the segment bigger。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，随着我们继续讲解，我们会更多地谈到这一点，但这里有一个例子，说明我们正在运行的段是一个有限的大小，如果你试图访问超出该范围的地方，就会发生段错误（segmentation
    fault）。但这意味着操作系统可以选择增大段的大小，从而创造出无限内存的幻觉。
- en: Okay。 Now this interrupt vector is actually not storing any state what it is
    is it's storing the pointer to whatever interrupt occurred so that could be a
    disk has data that came back and so the part of the interrupt happening is that
    we're going to start running in a special part of the。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在这个中断向量实际上并没有存储任何状态，它存储的是发生了什么中断的指针，这可能是磁盘有数据返回，所以中断发生的一部分是，我们将开始在操作系统的一个特殊部分运行。
- en: kernel to handle that interrupt。 Okay。 Now， how do we save the registers and
    set up the system stack for running well first of all we take all the registers
    we save them off in memory somewhere。 Okay。 And this the kernel can do that because
    it has we're in system mode and so it has access to all the registers and be。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内核处理这个中断。好的。那么，我们如何保存寄存器并设置系统堆栈以便运行呢？首先，我们把所有的寄存器保存到内存中的某个地方。好的，内核可以这样做，因为我们处于系统模式，所以它有权限访问所有寄存器。
- en: you know， we have access to all the memory and so we can then take and load
    pre-systems。 And load preload the green process and get it ready to go so notice
    that what I've done is I found so this is the process control block we mentioned
    earlier for yellow we find the process control block for green。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，我们可以访问所有的内存，然后我们可以加载预系统。并预加载绿色进程并使其准备好运行。所以请注意，我所做的是找到了早些时候提到的黄色进程的进程控制块，我们找到了绿色进程的进程控制块。
- en: We load it up。 We put the base in bound for green we put the user PC we set
    up the stack and then what we're going to do is we're going to do that return
    to user mode and notice by the way that the。 C。V。 is actually stored in the static
    data of the kernel we'll talk more about that as we go。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载它。我们为绿色设置基址和界限，设置用户PC，准备好栈，然后我们要做的是执行返回用户模式的操作，顺便说一下，C.V. 实际上存储在内核的静态数据中，稍后我们会详细讨论这个问题。
- en: And when we do a return to user poof all of a sudden we're in system mode zero。
    the program counter got a transfer from the user PC into the program counter and
    we're now running in the users code。 the base in bound are active and the stack
    is active and now this process gets to run。 as if it has exclusive control of
    the machine。 Okay。 Now。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们返回用户模式时，突然之间我们进入了系统模式0。程序计数器从用户PC转移到程序计数器，我们现在在运行用户代码。基址和界限是活动的，栈也处于活动状态，现在这个进程开始运行，就好像它拥有机器的独占控制权一样。好了，现在。
- en: basically the question here where do you save the PC value of interrupts from
    different processes。 So let's not get too confused here so right now when it interrupt
    occurs it's going to take a kernel stack and start running on it。 And it can be
    the kernel stack associated with the current user process etc。 We'll get there。
    Okay。 so just suspend that understand or that question for a little bit and ask
    me in maybe a lecture or so。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，问题在于你在哪里保存来自不同进程的中断的程序计数器（PC）值。我们现在不要太混淆，所以当中断发生时，它会使用内核栈并开始在上面运行。它可能是与当前用户进程相关的内核栈，等等。我们稍后会讨论。好了，暂时搁置这个问题，稍后在讲座中再提问吧。
- en: Okay。 But for now just this understanding here that we took if you look back
    here right after the interrupt occurred。 say it's a timer interrupt， we have the
    users PC which the kernel can now save out to the PCV can load the PCV for green
    and we're good to go。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。但现在先理解这一点：如果你回看中断发生后的情况。假设这是一个定时器中断，我们有用户的PC，内核现在可以将它保存到PCV中，并为绿色进程加载PCV，我们就可以继续了。
- en: Okay。 Now， so here we now have resumed and we're now running green。 So。 are
    there any questions any more questions on this。 So what I've just shown you here
    is this simple idea we were running yellow and interrupt occurs。 We run the scheduling
    code to now run save yellow run green and we're going to go back and forth with
    that and that's going to basically give us the illusion that these two yellow
    and green are running at the same time。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，我们已经恢复并正在运行绿色进程。那么，是否还有其他问题呢？我刚才向你展示的这个简单的概念是这样的：我们正在运行黄色进程时发生了中断。我们运行调度代码，保存黄色进程，运行绿色进程，然后我们会在两者之间来回切换，这样基本上就会给我们一种黄色和绿色进程同时运行的假象。
- en: Okay。 Right， and that's good。 Maybe I misunderstood that yes every process has
    its own PCB。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没错，也许我误解了，是的，每个进程都有自己的PCB。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_13.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_13.png)'
- en: Now， so how do we run many programs well we have the basic mechanism now to
    switch between user processes in the kernel we just showed you go from yellow
    to green and then same thing would work from green to yellow。 And the kernel can
    switch among user processes and protect the operating system from user processes
    and processes from each other。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何运行多个程序呢？现在我们已经有了基本机制，可以在内核中切换用户进程。刚才我们展示了从黄色切换到绿色，接下来同样的机制也适用于从绿色切换回黄色。内核可以在用户进程之间切换，并保护操作系统免受用户进程的影响，同时也可以保护进程不互相干扰。
- en: That's that protection domain I showed you with branch and bound right the basic
    mechanism of branch and bound really protects。 All of the user processes from
    each other and from and from messing up the kernel。 The kernel is in charge of
    everything and so the kernel。 If you break into the kernel in this basic model
    here you can。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我向你展示的带有分支限界的保护域，分支限界的基本机制真的起到了保护作用。它将所有的用户进程相互隔离，并防止它们干扰内核。内核负责一切，所以内核。如果你在这个基本模型中突破了内核，你就可以。
- en: you can trash everything but we're going to assume for a moment that the， kernel
    is not broken into。 Okay。 So we have a lot of questions here one of which I will
    answer right away which is what if they don't fit in memory。 That's a great question。
    Right now this model is not great if if the yellow or the green try to grow too
    big。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以丢掉所有东西，但我们暂时假设内核没有被突破。好了，我们有很多问题，其中一个我会立即回答，那就是如果它们不适合内存怎么办。这是一个好问题。现在，这个模型在黄色或绿色进程如果尝试增长得过大时就不太适用了。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_15.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_15.png)'
- en: So we're going to run into issues here。 Okay， and because we're requiring the
    whole program to fit in one contiguous bit of memory so that's why we're going
    to very quickly discard branch and bound as or base and bound excuse me as our
    desired mechanism here。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们会遇到一些问题。 好的，因为我们要求整个程序必须适应在一块连续的内存区域内，所以我们很快就会放弃分支和界限（branch and bound）或基址和界限（base
    and bound）作为我们期望的机制。
- en: Okay。 The thing that switches between user and kernel mode is the hardware。
    That's what the processor does when it receives an interrupt。 It is the thing
    that does that switching。 Okay， and it's the thing that's doing that dual mode
    switching from user mode to system mode。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。 在用户模式和内核模式之间切换的是硬件。 当处理器接收到中断时，它会执行这个操作。 它就是执行这种切换的组件。 好的，它就是进行用户模式到系统模式的双重模式切换的那个东西。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_17.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_17.png)'
- en: How do we represent user processes in the OS we mentioned everyone's got a PCB。
    How do we decide which user process to run。 Well that's a good question that's
    called scheduling and we're going to actually have a whole unit on scheduling
    coming up。 But just because we can switch between green and yellow and yellow
    and green。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在操作系统中表示用户进程？ 我们提到过，每个进程都有一个 PCB。 我们如何决定运行哪个用户进程？ 这是一个好问题，这就是调度（scheduling），我们接下来会有一个关于调度的完整单元。
    但是，仅仅因为我们能够在绿色和黄色之间切换，以及在黄色和绿色之间切换，并不意味着一切都已经解决。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_19.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_19.png)'
- en: Doesn't tell us anything about when we switch or how much time we give each
    of them。 That's a。 that's a whole another discussion that's actually pretty interesting
    because there's many reasons you might have for giving one more time than the
    other or interrupting it immediately or whatever。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它并没有告诉我们切换的时机或为每个进程分配多少时间。 那是一个完全不同的话题，实际上相当有趣，因为有很多原因可能导致你给某个进程更多的时间，或者立即中断它，等等。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_21.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_21.png)'
- en: We're going to talk about that a lot。 Coming up later。 How do we pack up the
    process and set it aside well we just showed you we basically unloaded its registers
    into its PCB。 How do we get a stack and heat for the kernel well that's interesting
    we'll have to talk about some of that。 Memory allocation。 Doesn't look like we're
    wasting a lot of memory by forcing kind of all of the user programs to be loaded
    at once。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会详细讨论这个问题。 接下来，我们如何打包进程并将其搁置？ 我们刚才已经展示了，基本上是将它的寄存器卸载到进程控制块中。 如何为内核设置堆栈和堆？
    这个问题很有趣，我们需要谈论其中的一些内容。 内存分配。 看起来通过强制加载所有用户程序到内存中并不会浪费很多内存。
- en: Certainly。 So we're going to have to start talking about swapping and then ultimately
    we're going to talk about paging which is even cleaner。 But so the process control
    block is an essential piece and you know they're different for every operating
    system as to exactly what the format of them are but you get the idea what's in
    there。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然。 所以我们将不得不开始讨论交换（swapping），最终我们还会讨论分页（paging），这是更为简洁的方法。 但是进程控制块是一个关键部分，你知道不同的操作系统会有不同的格式，但你可以大致了解它包含了什么。
- en: It's got some state of the process。 It's got， you know。 a number for the process
    ID and maybe knows what the counter is and some of the other registers。 Memory
    limits， etc。 All of that's in the process control block and the kernel uses that
    to track the processes because especially in the next couple of weeks where we're
    mostly talking about one core or one CPU for the whole machine。 Most of the processes
    are idle and in stored in process control blocks。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含进程的某些状态。 它包含进程 ID 的编号，可能还知道计数器的值以及一些其他寄存器。 内存限制等。 所有这些内容都在进程控制块中，内核使用它来跟踪进程，尤其是在接下来的几周里，我们主要讨论的是单核或单
    CPU 的机器。 大多数进程是空闲的，存储在进程控制块中。
- en: There's only one of them that can be running at any given time。 Okay。 Now。 the
    kernel scheduler is this thing that we're going to talk more about for basically
    deciding which gets swapped in。 And we can give non CPU resources， memory， IO，
    etc。 Also by a scheduler。 And I would say。 as we've said a couple of times now
    the process control block there's one per process so everyone has。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时刻，只有一个可以在运行。 好的。 现在，内核调度器是我们接下来要讨论的内容，基本上负责决定哪个进程被调度进来。 我们还可以通过调度器分配非
    CPU 资源，如内存、I/O 等。 我会说，正如我们之前提到的，进程控制块（PCB）是每个进程都有一个的，所以每个进程都有。
- en: Every process has a separate process control block and they're stored in the
    kernel memory。 Okay。 Now， let's not worry about maliciousness for now。 The user
    to kernel mode switches are under control of the kernel and we'll talk a lot more
    about maliciousness when we go much later in the term。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个单独的进程控制块，并且它们存储在内核内存中。OK。现在，暂时不用担心恶意行为。用户态到内核态的切换是由内核控制的，关于恶意行为我们会在学期后期更详细地讨论。
- en: But let's assume that where the right things are happening so far。 So what we
    just shown you here is pretty simple。 So this is two processes one core。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设到目前为止，一切都在正常发生。那么我们刚才展示的其实是相当简单的。这是两个进程，一个核心。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_23.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_23.png)'
- en: It sounds like sounds like an ad campaign right two processes one core。 We start
    with process zero。 which is a user mode thing。 Okay。 And it starts executing。
    And if you notice right at about the end of this blue arrow， there's something
    like an interrupt。 Okay。 And at that point， we're going to save enough state of
    the process and we're going to enter system mode。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是一个广告活动吧——两个进程，一个核心。我们从进程零开始，它是一个用户态的进程。OK。它开始执行。如果你注意到，在这个蓝色箭头的末尾，似乎发生了一个中断。OK。到那个时候，我们会保存足够的进程状态，并进入系统模式。
- en: And the system mode is really running kernel code and that's the point at which
    we save a bunch of stuff。 And we load we save a bunch of stuff into PCB for zero
    and we load it back from PCB for one。 And then we're going to start running process
    one， which is also going to be running in user mode。 Okay。 And， and notice， so
    the question about who hands out non CPU resources。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 系统模式实际上是在运行内核代码，这时我们会保存大量信息。我们将这些信息保存到进程控制块（PCB）中的进程零，并从PCB加载进程一的状态。然后我们会开始运行进程一，它同样是在用户模式下运行。OK。注意，关于谁负责分配非CPU资源的问题。
- en: So that's going to be a combination of the scheduler in some instances and other
    parts of the kernel。 So we'll definitely get to other resources later。 But let's
    stick with things simple things for now。 Okay。 And so if you look what you see
    here is process zero runs for a while。 There's an interrupt。 We saved state we
    really reload state。 We start process zero back in user mode。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是调度程序在某些实例中的组合，以及内核的其他部分。所以我们以后肯定会讨论其他资源。但现在我们先保持事情简单。OK。所以，如果你看这里，你会看到进程零运行了一段时间，发生了一个中断。我们保存状态，重新加载状态，然后在用户模式下重新启动进程零。
- en: We run for a little while we come back， save state for process one。 And then
    we sort of rinse and repeat based on scheduling。 And if you notice these little
    places that I have yellow circles actually represent a user to kernel or kernel
    to user transitions。 So these are the points at which we actually have the change
    in the system mode。 Okay。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行一段时间后，回到进程一，保存状态。然后我们根据调度再次进行操作。如果你注意到这些黄色圆圈，其实代表的是用户态到内核态或内核态到用户态的转换。这些是系统模式发生变化的地方。OK。
- en: And the other thing to note is what's in red here in this particular diagram
    is 100% overhead。 Right。 So there was a question earlier about what， what about
    the overhead is switching。 Well。 here's overhead。 Okay。 And that's basically the
    time to handle the interrupt and save and restore registers and then make scheduling
    decisions。 That's all overhead。 And so one thing that you can start thinking early
    in the game。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是，在这个特定的图示中，红色部分表示的是100%的开销。对吧。所以之前有个问题是，切换时的开销是什么？好吧，这就是开销。OK。这基本上是处理中断、保存和恢复寄存器的时间，然后做出调度决策。全部都是开销。所以，你可以在早期就开始思考这个问题。
- en: Is that if we switch back and forth too frequently。 we're going to actually
    end up where we do more switching than we do a computing and that seems like a
    bad idea。 Right。 So there's a minimum amount of time that I'm going to throw out
    a number there。 But oftentimes if it's bigger than 10% people will say you're
    thrashing。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，如果我们切换得太频繁，实际上会导致切换的次数比计算的次数还要多，这似乎是个不好的主意。对吧。所以有一个最小的时间限制，我会给出一个数字，但通常如果时间大于10%，人们会认为你正在进行过度切换（thrashing）。
- en: Don't worry about those exact numbers， but if you're wasting more than 10% of
    your CPU cycles in the switching process it's probably bad。 Okay。 And when I said
    kernel memory I meant the great part earlier。 Okay。 So what's running in here
    in between the save and reload。 Well。 there's a decision about what to run next
    and that's a scheduler。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心那些具体的数字，但是如果你在切换过程中浪费超过10%的CPU周期，可能就不好了。好了。当我说内核内存时，我指的是之前提到的那部分。好了。那么，在保存和重新加载之间运行的是什么？其实，这是一个关于下一步运行什么的决策问题，这就是一个调度器。
- en: which I'm not going to go into great detail today。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我不打算详细讨论这个话题。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_25.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_25.png)'
- en: But think of this as a continuous loop where it says， well， I'm going to schedule。
    So if there's a ready process pick one， run it for a while， and then loop back
    and do it again。 Okay， and this arc is going to be triggered by something like
    a timer or a yield or I/O。 And we'll talk a lot about that next time。 Okay。 But
    scheduling。 What about scheduling？
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是把这个看作一个连续的循环，它说的是，如果有一个就绪进程，就选一个，运行一段时间，然后再返回来继续做。好了，这个循环将由类似计时器、让步或I/O之类的东西触发。我们下次会详细讨论这个话题。好了。那么调度呢？调度又是怎么回事？
- en: It's this select process thing is a mechanism for deciding which get to run
    next which processes are threads and lots of different scheduling policies。 So
    we'll have ones that give you fairness。 We'll have ones that give you real time
    guarantees like might be in your Tesla when you slam on the brakes。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择进程的机制是决定哪个进程或线程下一个可以运行的方式，它涉及许多不同的调度策略。所以我们有一些策略可以确保公平性。我们也有一些策略可以提供实时保障，就像你在特斯拉上踩刹车时的情形。
- en: You know， there's some real time guarantees that better come into play or it
    runs into something right。 Maybe there are some optimizations for latency。 These
    are all interesting scheduling policies。 And so you'll be many different ways。
    Okay， to think about it。 There's a good question kind of in the chat about how
    the OS knows which registers to save and restore。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，必须有一些实时保障才行，否则它会撞到什么东西，对吧？也许还有一些优化措施来降低延迟。这些都是有趣的调度策略。所以你会看到很多不同的方式。好了，关于如何理解这个，有个不错的问题是在聊天中提到的，关于操作系统是如何知道哪些寄存器需要保存和恢复的。
- en: And that's going to be that's going to depend on kind of which registers are
    active。 And so。 mostly it's a decision to just save them all unless there's more
    information。 You're going to potentially get the potential you're going to find
    out in project one that if there's。 for instance， an FPU running， then you have
    to save and restore the FPU registers。 Okay。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于哪些寄存器是活跃的。所以，通常的做法是保存所有的寄存器，除非有更多的信息。你可能会在项目一中发现，如果有FPU在运行，那么你必须保存并恢复FPU寄存器。好了。
- en: And we want to again just reiterate that we don't want to be spending a bunch
    of time saving and restoring or scheduling。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想再次强调，我们不希望花太多时间在保存、恢复或调度上。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_27.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_27.png)'
- en: And so we do not want to be going back and forth too often and again keep that
    10% number in mind。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们不想频繁来回切换，再次记住那个10%的数字。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_29.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_29.png)'
- en: Okay， so I， there was discussion about this in Piazza and I thought I'd bring
    this up。 There is this notion of simultaneous multi threading or hyper threading。
    This leave it to Intel to take something that people knew already。 which is simultaneous
    multi threading and give it a different name， which is hyper threading。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以在Piazza上有过关于这个话题的讨论，我想我应该提一下。这里有一个叫做“同时多线程”或“超线程”的概念。把这些交给Intel来处理，他们把人们已经知道的同时多线程技术起了个新名字，叫做超线程。
- en: But the idea is that the hardware， it's a hardware scheduling technique that
    basically allows super scalar processors。 which are processors that can run more
    than one operation at a time。 To have two simultaneous threads or three threads
    or fourth threads running at the same time in the same pipeline。 And we're not
    going to spend a lot of time talking about this because that's for 152。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是核心思想是，硬件是一种调度技术，它基本上允许超标量处理器（可以同时执行多个操作的处理器）同时运行两个、三个或者四个线程，这些线程都在同一流水线中运行。我们不会花太多时间讨论这个，因为这是152课程的内容。
- en: But if you look， here's a single CPU where each think about time going down
    here and solid blocks as opposed to gray represent cycles where actual executions
    happening。 So here， notice that in with only one thread we're wasting all of this
    gray time in the pipeline。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你看一下，这里是一个单独的CPU，想象时间在这里向下流动，实心块与灰色区域相比，表示实际执行发生的周期。这里请注意，只有一个线程时，我们浪费了管道中的所有灰色时间。
- en: But if we put two threads in the same pipeline， then we can fill things in。
    And you could say， well。 here's two pipelines。 Here's actually hyper threading。
    So this would be two cores。 This would be one core with two hyper threads。 The
    two hyper threads fill out and better utilize the pipeline。 The difference between
    two hyper threaded cores and two cores is small from an operating system standpoint。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们把两个线程放入同一个管道中，那么就能填补这些空白。你可以说，嗯，这是两个管道。实际上这是超线程。所以这将是两个核心。这将是一个核心和两个超线程。两个超线程填补并更好地利用管道。从操作系统的角度看，两个超线程核心和两个核心之间的差异很小。
- en: It's much bigger from an architecture standpoint。 And we're still only talking
    for the next couple of weeks about one CPU。 one hardware thread。 But you'll be
    able to see when we start having more cores that more cores and hyper threads
    are pretty close to the same thing for you。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构角度看，这个问题要大得多。我们现在仍然只是在讨论接下来的几周内的一个CPU，一个硬件线程。但当我们开始使用更多的核心时，你会发现更多的核心和超线程对你来说是非常相似的。
- en: And this scheduling that I talked about in software earlier is actually happening
    in hardware。 And it's happening potentially on a per cycle basis。 So you can have
    two different threads on the same cycle。 Now， also remember， and again。 not for
    the next couple of lectures， but remember the world is parallel。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前在软件中提到的调度实际上是在硬件中发生的。它可能是在每个周期的基础上进行的。所以你可以在同一个周期内有两个不同的线程。现在也要记住，再重复一次，不是接下来的几节课要讲的内容，但要记住，世界是并行的。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_31.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_31.png)'
- en: So even at the single core level， you can have something like this Skylake from
    2007。 and then there's a more recent version three of the Xeon processors from
    Intel。 Lots of cores。 lots of hyper threads。 There's two 28 cores， 56 threads
    is one example of Skylake。 Lots of parallelism。 Okay， so even though we're talking
    about how to deal with one core。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在单核级别，你也可以看到像2007年的Skylake这样的处理器，然后是英特尔Xeon处理器的更新版3。很多核心，很多超线程。一个Skylake的例子是28个核心，56个线程。很多并行性。所以即使我们现在讨论的是如何处理一个核心。
- en: once we figure that out， then it'll actually be pretty clear。 hopefully to everybody
    how to do multiple cores。 It's not going to be a big deal。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们搞清楚了这一点，那么实际上每个人都能很清楚地理解如何处理多个核心。这不会是个大问题。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_33.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_33.png)'
- en: Okay。 Yes， and we can， you guys can talk to me offline about policies in hardware
    in hyper threads。 but there's all sorts of policies about who gets to go when
    there's not enough resources。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。是的，您们可以在离线时和我讨论超线程中的硬件策略。但关于资源不足时，谁能去执行是有各种策略的。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_35.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_35.png)'
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_36.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_36.png)'
- en: Okay， so is the base in bound。 I said branch in bound there。 Sorry。 A good enough
    protection mechanism。 It's base in bound。 And the answer is no。 it's really too
    simplistic for real systems。 Okay。 And it's inflexible or wasteful。 You have to
    dedicate physical memory for potential future use。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以是基本的边界保护。我说的是分支边界，抱歉。一个足够好的保护机制是基本的边界保护。答案是否定的，它对于实际系统来说实在是过于简单了。好的，而且它不灵活或浪费。你必须为潜在的未来使用分配物理内存。
- en: So if you want to have enough space where the stack can grow。 then you got to
    allocate a huge big chunk just for that。 Okay。 So it's also got fragmentation。
    So if you have processes with a bunch of different sizes， and you want to have，
    you know。 them exit and then bring in new ones， you're going to very rapidly get
    fragmentation。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你想要足够的空间让堆栈能够增长，那么你就得为此分配一大块内存。好的。所以它也会有碎片化问题。如果你有多个大小不同的进程，并且希望它们退出后再引入新的进程，你很快就会遇到碎片化问题。
- en: And you're going to have to start moving things around in physical memory just
    to make just to find space to fit。 Okay。 And so this idea of the base in bound
    is really not great as a sole mechanism for translation or protection。 It's even
    worse when you think about sharing。 So picture your mind back to that yellow and
    green block。 If those two processes want to directly share memory。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将不得不开始在物理内存中移动东西，仅仅是为了找到空间来适应。好的。所以，作为单一的转换或保护机制，基址和界限这个想法其实并不太好。当你考虑到共享时，它甚至更糟。想象一下那块黄色和绿色的块。如果这两个进程想要直接共享内存。
- en: there's no mechanism in the current base in bound that I shown you for that
    to happen。 Okay。 So yes。 the OS can resize the bound to give more memory， but
    there's no way for yellow to talk to green and green talk to yellow because by
    design。 they don't， they can't overlap each other。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示的当前基址和界限机制中，并没有办法让它们发生这种共享。好的。所以，是的，操作系统可以调整界限以提供更多的内存，但没有办法让黄色进程和绿色进程相互通信，因为设计上，它们不能重叠。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_38.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_38.png)'
- en: Okay。 And so what's one clear thing that we're going to do when we get into
    virtual memory and greater detail is we're going to start talking about a generalization
    of base in bound。 which is the segment idea。 And here， for instance， in the x86，
    which is the processor。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，关于虚拟内存的一个清晰要点是，我们将开始讨论基址和界限的通用化——也就是段的概念。例如，在 x86 架构中，处理器就是这样工作的。
- en: you're going to become very familiar with in this class。 There are multiple
    segments like a code segment and a stack segment。 And each of those segments has
    a base and a bound。 Okay。 and we can have multiple segments and two segments from
    different processes could actually overlap in physical memory if that was our
    choice。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本课程中非常熟悉这一点。这里有多个段，如代码段和栈段。每个段都有一个基址和界限。好的，我们可以有多个段，来自不同进程的两个段实际上可以在物理内存中重叠，如果这是我们的选择的话。
- en: And now we've got a way to have them communicate through memory。 Okay。 Now。
    this is one thing we could do， but even better is actually paging which we talked
    about last time we started talking about it and you heard about this in 61 C as
    well。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一种通过内存让它们通信的方法。好的。现在，这是我们可以做的一种方式，但更好的方法其实是分页，我们上次开始讨论过它，你在 61 C 课程中也听说过这个概念。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_40.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_40.png)'
- en: And then the idea is that you take the code data heap and stack of each process。
    And everyone in the addresses goes through a generalized translation unit。 and
    can be pointed at in pieces to all sorts of pages in the physical memory。 And
    then we can get a translation on page size where all the pages are fixed。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，想法是你将每个进程的代码、数据、堆和栈组合起来。每个地址都会通过一个通用的转换单元进行转换，并且可以指向物理内存中各种页面的不同部分。然后我们可以得到一个页大小的转换，其中所有的页面大小是固定的。
- en: And that fixed size like 4K or 16 K is going to prevent fragmentation because
    every page is the same。 And we can get more stack or heat just by adding a few
    more pages to the translation map。 And that's where paging comes into play。 And
    modern virtual memory is almost exclusively page based。 And there's a lot more
    about that in greater detail。 Okay。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 像 4K 或 16K 这样固定大小的页面将防止碎片化，因为每个页面的大小是相同的。我们只需要通过向翻译映射中添加几个页面，就可以获得更多的栈或堆。这就是分页的作用。现代虚拟内存几乎完全基于分页。关于这一点有很多更详细的内容。好的。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_42.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_42.png)'
- en: All right。 So， time to get really started with the class。 If you haven't gotten
    started。 I will tell you that homework zero is due tomorrow。 Okay。 And so。 I'll
    put up some other office hours。 I apologize。 But homework zeros do tomorrow。 Okay。
    And so you got to get familiar with 162 tools configure your VM submit the get
    all of these things。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么，现在是时候真正开始上课了。如果你还没有开始的话，我告诉你作业零的截止日期是明天。好的。所以，我会安排一些额外的办公时间。我感到抱歉，但作业零明天到期。好的，你必须熟悉
    162 工具，配置你的虚拟机，提交这些所有的东西。
- en: And then we have homework zero do quickly is to get you guys all on board because
    these are all things that you need to know how to do right off the bat。 Okay。
    And you should be going to some section now。 It doesn't really matter which one。
    because there's sort of crucial other information we want you to get a whole of
    in terms of understanding。 you know， C language and so on。 And I hope that everybody
    who everybody got a chance to go to the sea review that we had on Saturday。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要尽快完成作业零，确保你们都能跟上进度，因为这些都是你们需要立刻掌握的内容。好的。现在你应该去参加某个小节了，哪个小节不重要，因为我们希望你能获取一些至关重要的其他信息，帮助你理解C语言等内容。我希望每个人都能有机会参加我们周六举行的C语言复习课。
- en: I believe that if you didn't go there's videos of it， you should all review
    that because again。 just like I was mentioning with homework zero there's a bunch
    of things we assume。 that you're going to know and be ready to go with。 Okay。
    And those are kind of like baseline before we really plow in。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为如果你们没去的话，可以看视频，大家应该都要复习一下，因为就像我之前提到的作业零一样，有很多事情我们假设你们已经知道，并且准备好迎接。好的。这些内容就像是基础，准备好之后我们才能深入学习。
- en: And don't don't get too worried about this in the sense of how can I possibly
    do this。 We understand that 61 C left you with a very basic understanding of C。
    but that's why we give you these resources in the first two weeks so that you
    can really get up and running。 Okay。 And so take that as a challenge to get good
    enough for C that you can start doing the class。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太担心这一点，觉得自己怎么可能做到。我们理解61 C课程只给你们提供了C语言的基础知识，但这也是我们在前两周提供这些资源的原因，目的是让你们能尽快上手。好的。所以把它当作一个挑战，让自己足够好，能够开始跟上这门课的进度。
- en: Okay。 And I'll put up， I'll put up better office hours I realized I had these
    earlier today and I realized it's not going to work so I'll have better office
    hours for you。 The other thing that's really important is this。 Friday is the
    drop deadline。 Okay。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我会安排更好的办公时间。我意识到今天早些时候我已经安排了这些时间，但我意识到那样行不通，所以我会为你们安排更好的办公时间。还有一件非常重要的事是，星期五是退课的最后期限。好的。
- en: so that means that you have to make a decision to drop otherwise it gets tricky
    because you start using up your。 you know， once a career kind of drops or whatever。
    It's available。 And if you know you're going to drop you should do that now because
    that way we can bring more people in from the wait list。 And the other reason
    we have an early drop deadline is because when we form our groups next week。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须做出退课的决定，否则情况会变得复杂，因为你会开始浪费你的一些学分。如果你知道自己会退课，现在就做出决定，这样我们可以从等候名单中让更多的人加入进来。我们设定早期退课的最后期限，另一个原因是因为我们下周要分小组。
- en: we want to make sure that we have groups of people that are going to stick together
    and so we don't have orphan groups where there's a couple of people are all that's
    left。 Okay， and so really do a careful thinking about do you believe that you
    want to keep up with the class。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想确保每个小组的人会一直坚持下去，这样我们就不会有那种剩下几个人的“孤儿小组”。好的，所以请仔细思考，你是否真的想跟上课程的进度。
- en: then please do because we want to have you here。 In fact。 I think as of right
    now we may have led everybody in off the wait list so that could come to the class。
    But if you're not going to make it， please make a decision to drop Friday。 Okay。
    And if you know of any friends of yours that have stopped coming and haven't dropped。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是的话，请务必留下来，因为我们希望你能继续参加。事实上，我认为目前为止，我们已经让所有在等候名单上的人都加入了课程。但如果你决定不继续，麻烦在星期五做出退课的决定。好的。如果你知道有任何朋友已经不再来上课，但还没有退课的话。
- en: let them know that they need to drop because they will get put into the class。
    And then I have this every semester I have somebody who doesn't realize they're
    still in the class until the very end of the term。 And it just， it's a mess。 So，
    I'm sure all I'm glad to know that all the people that are。 that are here are
    excited about the class。 And I know somebody who might still be on our on our
    class list and it's actually planning to drop and might be in danger for getting。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉他们需要退课，因为他们将会被自动加入到课程中。每个学期我都会遇到有些人不知道自己还在课程里，直到学期结束。这样一来，情况就会变得很混乱。所以，我很高兴知道这里的每一个人都对这门课充满了兴趣。我知道有一个可能还在我们的班级名单上，但实际上打算退课，并且可能面临退课的风险。
- en: Please make sure that they don't do that。 So the group registration form stuff's
    going to come out over the weekend and or next Monday so really it's next week
    that we start really getting our groups together。 And that's going to be the an
    autograter form or something of that nature and groups are for in a group。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保他们不要这样做。所以小组注册表单将在周末或下周一发布，真正开始组建小组是在下周。那将是一个自动评分表单或类似的东西，小组是四人一组。
- en: Okay， you know， that will not have three in your group or add another to make
    five so make sure that you start looking at four people。 And find a group。 All
    right， and we'll help you if it turns out you can't but it's it's often much better
    to have folks that you know in the group。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你知道，如果你的小组成员不满三人，或者想要增加到五人，请确保你开始找四个人的小组。我们会帮你，如果你最终找不到小组，但通常来说，和你认识的人在一起组队会更好。
- en: Okay。 If you only have a group of two， you might post on Piazza。 There's lots
    of lots of people up there we have a special kind of thread about people looking
    for group members。 So try to find somebody yourself。 I mean we'll help you a bit
    but might not hurt to try。 try yourself first。 Okay。 And you're going to want
    to put down a section。 And then suggestions。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果你只有两个小组成员，你可以在Piazza上发布。那里有很多人，我们有一个特别的讨论线程，专门为寻找小组成员的人设置。所以尽量自己找一个人。我们会帮你一点忙，但可能不妨先自己试试。好的，你需要选择一个时间段。然后填写建议。
- en: Okay， we'll have the ability for you to ask for a couple of sections。 but you
    want to try to make sure that all of you in your group can attend either the same
    section。 which is ideal or at least the same TA。 So we have some 20 hour TAs that
    have two sections。 All right。 The midterm， the day and times are fixed now for
    midterms one， two and three。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们将允许你选择几个时间段。但你要尽量确保你的小组成员可以参加同一个时间段。理想情况下，是同一个时间段，或者至少是同一个助教。我们有一些20小时的助教，他们有两个时间段。好的。期中考试的日期和时间已经确定，期中一、期中二和期中三的考试时间已经固定。
- en: I believe they're all the seven to nine PM and we'll make sure that everything's
    updated。 And there is， there's going to be a conflict form to figure out how to
    deal with conflicts。 Okay。 Now I'm going to say this again about discussion sections
    if you look about the first bullet here。 We don't have discussion sections permanent
    ones until you get your group because your group all has to be in the same section。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信它们都是七到九点的时间段，我们会确保所有信息都得到更新。会有一个冲突表单，用于处理冲突。好的，现在我要再次说明一下讨论课的安排，如果你查看上面第一个要点。我们在你们组成小组之前是没有固定的讨论课的，因为你的小组必须在同一时间段。
- en: All right。 So for this last week and this week you can attend any section。 but
    starting next week you need to pick a set of sections that we'll choose from in
    which your group can all attend the same section。 And it works in worst case you
    and your group are in this with the same TA in different sections。 Okay。 We， I
    think I've answered all of those questions。 Are there any others？ Okay。 Yeah。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以在上周和这周，你可以参加任何一个时间段。但从下周开始，你需要选择一个时间段，这样你的小组就能一起参加同一个时间段。最坏的情况下，你和你的团队可能会在不同的时间段，但会有同一个助教。好的，我想我已经回答了所有这些问题。还有其他问题吗？好的。是的。
- en: you know this class get started pretty quickly。 But part of the reason we started
    so quickly is because there are some things where we want to make sure you're
    really rare and to go and ready to dive in and be productive。 Yeah， so please，
    as Anthony just said in the chat。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，这门课启动得很快。但我们开始得这么快的原因之一是，我们希望确保你们能充分准备好，能够深入学习并高效地工作。是的，就像安东尼在聊天里刚刚说的那样。
- en: please try to find your own group rather than us randomly assigning。 Now there
    was a one question in chat that I noticed that I wanted to talk about briefly
    and it was a good one。 So the question was， can why don't you page。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请尽量自己找到小组，而不是我们随机分配。现在我注意到聊天里有一个问题，我想简要谈一下，这是个不错的问题。问题是，为什么你们不分页？
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_44.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_44.png)'
- en: Why don't you combine paging with segments。 And the answer is the way we've
    described segments right now it isn't a paging scenario because it's got a base
    and a bound。 Okay， and so that unless you made every segment exactly the same
    size it wouldn't be good toward paging。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不把分页和分段结合起来？答案是，目前我们描述的分段方式并不是分页场景，因为它有一个基值和一个上限。所以除非你把每个分段都做成相同的大小，否则分页不会有很好的效果。
- en: Right， however， as we'll show you is you can easily combine segmentation and
    paging and in fact the x86 actually does that。 But that's that's for a lecture
    in a few weeks。 Okay。 but for now basic segments that we've described to you don't
    have paging potential because they're variable length。 Okay。 Now。 So if you remember，
    move and light along。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对，然而，正如我们将向你展示的，你可以轻松地将分段和分页结合起来，事实上，x86架构就是这么做的。但那是几周后讲解的内容。好的，但目前为止，我们描述的基本段并没有分页的潜力，因为它们是可变长度的。好的，现在。记住，继续前进。
- en: We talked last time at the very end about there being three ways to get from
    the user into the kernel。 Okay， there are three types of kernel mode transfer。
    And I want to I want to explore that a little bit more so one is a system call。
    And a system call is going to be the basic way in which user code can ask the
    kernel for facilities or services like file systems or communication across the
    network。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我们在最后提到过，有三种方式可以从用户模式进入内核模式。好的，有三种类型的内核模式转移。我想更深入地探讨一下这个问题，第一种是系统调用。系统调用将是用户代码请求内核提供文件系统或网络通信等服务的基本方式。
- en: Okay， and so this is an example where a process requests the system service。
    It's kind of like a function call but that function calls actually going to go
    from user mode into the kernel and then back out again so it's a function call。
    but it actually goes through different modes。 And you're going to get in project
    one you're going to actually get a chance to write some system call code。 Okay，
    so you'll be familiar with this as you go forward。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个例子，展示了一个进程请求系统服务。这有点像一个函数调用，但这个函数调用实际上会从用户模式进入内核模式，然后再返回，所以它是一个函数调用，但它实际上会穿越不同的模式。在项目一中，你将有机会编写一些系统调用代码。好的，随着你深入，你会熟悉这些内容。
- en: This is going to also be some similar to what we're going to call a remote procedure
    call later。 because you're going to take a bunch of things that were part of the
    function call and they're going to get packaged up in a way the kernel can accept
    them。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将与我们稍后将要讨论的远程过程调用（RPC）有些相似。因为你将把函数调用中的一些内容打包起来，以便内核能够接受它们。
- en: And then they'll get returned back later。 Okay。 Now， many system calls。 Okay。
    we're going to show you a bunch of them。 As we go over time， there's a question
    here can you know。 can a process ask for more processing time well certainly in
    some schedulers there's a way to ask for more time。 There's certainly ways for
    a process to say hey I'm done for now。 You can let somebody else run。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它们会在稍后被返回。好的，现在，很多系统调用。好的，我们会向你展示其中的一些。随着时间的推移，有一个问题是，进程是否可以请求更多的处理时间？当然，在一些调度程序中，确实有办法请求更多的时间。进程也可以有方法说“我现在完成了，可以让别人运行了”。
- en: There are many， many system calls okay and I think in the latest versions of
    Linux there's thousands of system calls。 At some point that API gets to be a little
    excessive。 Another way other than a system call which is a voluntary request from
    a user into the kernel。 We also have this idea of interrupts and interrupts are
    external asynchronous events that force the system to go from user mode into the
    kernel to handle an event。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多很多的系统调用，好的，我认为在最新版本的Linux中，有成千上万的系统调用。在某些时候，这些API会显得有些过多。除了系统调用——即用户主动请求进入内核的方式——我们还有中断的概念，中断是外部的异步事件，它强制系统从用户模式进入内核来处理某个事件。
- en: And it's totally independent of whatever the user was doing。 So the user is
    busy computing pie to the last digit and interrupt might come along it's going
    to suspend and go into the kernel。 handle the interrupt and then go back to where
    it left off computing pie。 And why do we have interrupts well interrupts are for
    things that are unpredictable or unknown like when is a packet going to come in
    from the network or when is the disk going to have its data back for you。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它完全独立于用户正在做的事情。所以用户可能正在忙着计算圆周率到最后一位，突然有一个中断到来，这时系统会暂停并进入内核处理这个中断，然后再返回继续计算圆周率。那为什么我们需要中断呢？中断用于处理一些不可预测或未知的事情，比如什么时候网络包会到达，或者磁盘什么时候会返回数据。
- en: And a very important interrupt which is going to be very important next time
    when we talk more about scheduling is going to be a timer interrupt。 which is
    how the kernel can be sure that it can steal time back away from the user。 So
    if we were switching between the yellow and the green and the yellow and the green。
    The way we make sure that the kernel can always do that is a timer interrupt goes
    off。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的中断，接下来我们在讲解调度时会深入探讨，就是定时器中断。这是内核确保能够从用户那里抢回时间的方式。所以如果我们在黄色和绿色之间切换，黄色和绿色之间切换。我们确保内核始终能做到这一点的方式就是定时器中断触发。
- en: And if yellow is running， we go into the kernel the kernel will change things
    around and then let green run and then a timer will come off and then it'll let
    yellow run。 And so timers are going to be kind of one of our key mechanisms for
    ensuring fairness of execution between different processes。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果黄色在运行，我们进入内核，内核会调整一些内容，然后让绿色运行，然后一个定时器会触发，然后它会让黄色运行。因此，定时器将成为我们确保不同进程之间执行公平性的关键机制之一。
- en: And then another one is a synchronous exception or trap。 And these are examples
    in which something that's tied to what the user is doing can't go forward。 The
    simplest example is an easy one divide by zero so the users run in some code they
    try to divide by zero。 The answer is big， right， very big。 So that's an exception
    that can't continue。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是同步异常或陷阱。这些是一些例子，其中与用户正在做的事情相关的内容无法继续进行。最简单的例子是除零错误，用户运行某段代码时尝试除以零。答案是很大的，对吧，非常大。所以这是一个无法继续的异常。
- en: We enter the kernel with an exception。 Another good one that you're going to
    see a lot of a little later in the term is a page fault。 So the user tries to
    use a part of the address space that doesn't have any physical memory backing
    in。 Well， we'll get a page fault exception that'll be in the kernel and the kernel
    will then make a decision about how to handle that or whether to boot the process
    out of the picture there and kill it。 Okay。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们因异常进入内核。另一个你会在接下来学到的常见情况是页错误。用户尝试使用没有物理内存支持的地址空间的一部分。那么，我们会得到一个页错误异常，这将在内核中处理，内核随后会决定如何处理，或者是否要将进程从系统中移除并终止它。好的。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_46.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_46.png)'
- en: Now if you remember， I showed you kind of this new last time to kind of the
    circles where we had the hardware was the brick underneath and then we had kernel
    mode which was things that handled hardware directly and then user mode which
    kind of floated on top of everything。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我上次给你展示了这种新的方式，类似于这些圆圈，其中硬件是下面的砖块，然后我们有内核模式，它处理硬件直接操作的内容，再往上是用户模式，它浮在一切之上。
- en: And so at some point we have an exec call where the kernel has been asked to
    start a brand new program running that exec call transfers into user mode。 And
    now we're running a program as a process。 And during the course of the execution
    will maybe make service calls of the kernel but eventually we'll have an exit
    which will take us back to the kernel and this is the life of a process from point
    A to point B。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在某个时刻，我们会有一个exec调用，内核被要求启动一个全新的程序运行，这个exec调用会转入用户模式。现在我们正在以进程的形式运行一个程序。在执行过程中，可能会进行内核服务调用，但最终我们会有一个退出操作，将我们带回内核，这就是一个进程从A点到B点的生命周期。
- en: Okay， and we're definitely going to cover scheduling in a much greater detail
    in later lectures。 But for now let's look at the mechanism of getting things running
    and what happens when they're running。 And so when you're running， for one thing
    a user program might make a system call like it needs to read from disk。 So in
    that case that system call is in the kernel it might actually return right away。
    Or。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们肯定会在以后的讲座中更详细地讲解调度。但现在我们先来看一下如何让事情运行的机制，以及它们运行时会发生什么。当你在运行时，首先，用户程序可能会发出一个系统调用，比如需要从磁盘读取数据。那么在这种情况下，系统调用会进入内核，它可能会立即返回。或者。
- en: and after it's returned it might actually have the kernel start something in
    the hardware。 Okay。 and in that instance later we might have an interrupt that
    will pull us from user mode into kernel mode。 And that interrupt may cause the
    kernel to go mess with the hardware to read something out of the hardware like
    some network packet。 The result might come back， might do multiple reads eventually
    we're done。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在返回之后，它实际上可能让内核在硬件上启动一些操作。好的，在这种情况下，稍后可能会有一个中断把我们从用户模式拉到内核模式。这个中断可能会导致内核去操作硬件，从硬件中读取一些信息，比如一些网络数据包。结果可能会返回，可能会做多次读取，最终完成。
- en: We restore the user's state returned from interrupt and poof we're now running
    user code again。 And so notice that all of these transitions out of user mode
    into the kernel mode are done in a way that are going to make sure that the user
    mode can continue running where it was without interruption or without it's state
    being destroyed。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们恢复从中断返回的用户状态，啪，我们又开始运行用户代码了。所以注意到所有这些从用户模式到内核模式的过渡，都是以一种确保用户模式可以继续执行且不被中断或其状态不被破坏的方式完成的。
- en: And so it can continue as if the kernel never took over。 Okay。 and that's part
    of that saving and restoring of registers which we're going to have to make sure
    we understand there。 Okay。 Now， the question here， can we assume that libc functions
    are usually going to trigger a context which not necessarily okay there's a lot
    of things if you look at this system call。 There are a lot of cases where a system
    call goes in the kernel and asks for information and comes immediately out without
    any context switch。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它可以继续运行，就像内核从未接管过一样。好的，这就是保存和恢复寄存器的部分，我们必须确保理解这一点。好的。现在，问题来了，我们能否假设 libc 函数通常会触发上下文切换？不一定。好的，如果你看一下这个系统调用，会发现有很多情况下，系统调用进入内核请求信息后，立即退出，没有任何上下文切换。
- en: And so， and then libc is often a shield over the system call so when you're
    calling these library functions it may make system call it doesn't necessarily
    mean that there'll be a context which。 Okay。 Here's an example where that user
    mode might divide by zero in which case we enter the kernel and the process is
    done。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，libc 通常充当系统调用的一个屏障，当你调用这些库函数时，它可能会触发系统调用，但这不一定意味着会发生上下文切换。好的。这里有一个例子，用户模式可能会发生除零错误，在这种情况下我们进入内核，进程就终止了。
- en: But other than that we can go back and forth for multiple system calls interrupts
    etc。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们可以在多个系统调用、硬件中断等之间来回切换。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_48.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_48.png)'
- en: And then eventually we exit。 Now， how do we make this safe。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最终我们退出。现在，我们如何确保这是安全的？
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_50.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_50.png)'
- en: What do I mean by safe。 What I mean by safe is the user code's running。 And，
    you know。 we go to the kernel to do services and stuff but we want to come back
    to the user mode in a way that the user program can continue properly so that's
    one part of safe。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的“安全”是什么意思？我所说的“安全”是用户代码正在运行，然后，我们去内核执行一些服务和任务，但我们希望能以一种方式回到用户模式，使得用户程序能够继续正常运行，这是安全的一部分。
- en: And the other part is really going to be that there's nothing the user code
    can do to screw up the kernel。 Okay， so there's a lot of different uses of safe
    here。 But for instance。 you know it shouldn't be possible for the user code to
    make a system call with bad arguments that will cause the kernel to crash。 Okay，
    or whatever there should be no way for the user mode to screw up the kernel mode。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一方面，实际上是确保用户代码无法破坏内核。好的，这里有很多关于“安全”的不同含义。例如，用户代码不应该能够使用错误的参数进行系统调用，从而导致内核崩溃。好的，或者说应该没有任何方式让用户模式破坏内核模式。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_52.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_52.png)'
- en: So there's a couple different notions of safe here。 And in going from user code
    to kernel mode。 We have to make sure that all transfers into the kernel are controlled。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有几种不同的“安全”概念。在从用户代码切换到内核模式时，我们必须确保所有进入内核的转移都是可控的。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_54.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_54.png)'
- en: Okay， and what is controlled mean controlled means that no matter how screwed
    up the request is from the user。 it shouldn't be possible for the user to pop
    into bad part of code or anything like that。 It should be controlled as to exactly
    what part of the kernel code runs that you always start at the beginning of kernel
    functions。 etc。 All of that needs to happen。 Otherwise malicious user code could
    actually screw up the kernel。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么“控制”是什么意思？控制意味着无论用户的请求有多糟糕，都不应该让用户进入代码中的坏部分或者发生类似的情况。应该精确控制执行哪些内核代码，始终从内核函数的起始处开始，等等。所有这些都需要发生。否则，恶意的用户代码可能会破坏内核。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_56.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_56.png)'
- en: And that's going to be part of what we talk about here。 But among other things。
    there needs to be a separate kernel stack to make sure that whatever the kernel
    tries to do isn't impacted by how the user has screwed up their own stack。 Now
    a stack is a concept that you've got from 61 C and we're actually going to remind
    you a lot more about it next time。 But if you remember， it's that thing that makes
    sure that we can have recursive routines where the local variables are stored
    on the stack and we can push down the stack and pull it up。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们接下来要讨论的内容的一部分。此外，还有其他问题。需要一个单独的内核栈，以确保内核执行的任务不会受到用户破坏自己栈的影响。现在，栈是你们在《61C》课程中接触过的概念，实际上我们将在下次提醒你更多有关栈的内容。如果你记得，它是用来确保我们能够使用递归例程的那个结构，其中局部变量存储在栈中，我们可以将数据压入栈中，也可以从栈中弹出数据。
- en: So， and in addition to a separate kernel stack， we have to make sure that the
    kernel code is careful to pack up everything the user is in the user's request
    and kind of validate it and make sure that it's correct for one thing and pack
    up all the users registers and so on so it can be restored。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了单独的内核栈外，我们还必须确保内核代码谨慎处理用户的请求，验证它是否正确，并确保一切无误，同时保存用户的寄存器等信息，以便恢复。
- en: And it should really be impossible like I said for a buggy or malicious user
    program to cause the kernel to corrupt itself。 So this idea that the user is asking
    the kernel to do things is a nice notion because the kernel has got control of
    everything。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，应该不可能出现一个有缺陷或恶意的用户程序导致内核损坏自身的情况。所以，用户要求内核执行任务的这一想法非常好，因为内核控制着所有事情。
- en: but the kernel has got to be careful and do it and allow that in a way that
    the user can't screw it up。 Okay， and we're going to this is going to be a theme。
    this idea of security and protection against malicious things it's going to be
    a theme that we're going to work on as the term goes on。 Okay。 Now， let's talk
    about hardware support here we brought that up earlier like what who has the the
    actual system mode bit and who does those transitions that we talked about earlier。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，内核必须小心谨慎，确保以用户无法破坏的方式处理这些事务。好的，这将是一个主题。这种**安全性和防护恶意操作**的理念，将是我们在接下来的课程中讨论的核心。好的，现在，让我们讨论一下硬件支持。我们之前提到过，谁拥有实际的系统模式位，谁负责进行之前提到的转换。
- en: And so that's the hardware， this idea that an interrupt like a timer interrupt
    can always take control back from a user program is in a similar P in a similar
    vein is about interrupt control。 And so interrupt processing as we mentioned earlier
    is not actually visible to the user process for one thing。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是硬件的概念，类似地，**定时器中断**可以随时从用户程序中夺回控制权，这和中断控制是一个类似的概念。所以，正如我们之前提到的，中断处理其实对用户进程是不可见的，这也是其中的一个原因。
- en: And it's always can always be guaranteed to happen。 Okay。 so that you could
    kind of think from the user standpoint that the interrupt happened between two
    instructions。 instruction a was happening the interrupt occurs bunch stuff happens。
    So。 what is the state instruction B happens from the user's code。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 并且始终可以保证这一点。好的，换句话说，从用户的角度来看，假设中断发生在两条指令之间。指令A正在执行时，发生了中断，接下来有一堆事情发生。那么，**指令B**会从用户的代码中执行。
- en: they don't notice the difference except for what so what what one thing can
    the user notice to know that interrupts have happened anybody figured that out。
    Exactly。 Okay， lag time exactly so that's going to be an interesting thing because
    in theory we're virtualizing the execution but there are these periods where time
    goes away。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 他们没有注意到区别，除了那到底什么能让用户意识到中断发生了呢？有人解决这个问题了吗？准确地说。好的，**延迟时间**，这将是一个有趣的点，因为从理论上讲，我们在虚拟化执行，但会有一些时间消失的时段。
- en: And that's going to be a theme a little bit later。 So the interrupt handler。
    what's a handler a handler is the thing that is invoked inside the kernel on behalf
    of of that interrupt and so if it's a timer interrupt。 We make sure that that
    timer interrupt is the right place in the kernel and that interrupts are disabled
    so we don't have this permanent interrupt interrupt interrupt interrupt until
    the timer interrupt can actually take over and execute long enough to clear the
    interrupt field。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个稍后会成为一个主题。所以中断处理程序，什么是处理程序？处理程序是在内核中代表该中断被调用的部分。如果是定时器中断，我们确保该定时器中断在内核中的正确位置，并且会禁用中断，这样我们就不会陷入永久的中断循环，直到定时器中断能够接管并执行足够长的时间以清除中断标志。
- en: Okay， now the question here about no context which is there's no context switch
    in the case of this interrupt happening in the what a context which is means to
    us and is going to mean a lot more to you next time is really a context which
    is when one user process gets switched out for another one。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好，现在这里有个问题是关于没有上下文切换的，也就是说在发生中断的情况下没有上下文切换，什么是上下文切换，对我们来说是什么意思，等到下次你会理解更多，实际上上下文切换是指一个用户进程被换出去，换成另一个进程。
- en: or one thread gets switched out for another one。 So that's the that's the thing
    that's getting switched。 Okay， and basically what that interrupt handler is going
    to do is pack up any thing that can't be handled immediately into an OS thread
    for later work。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是一个线程被切换出去，换成另一个线程。所以这就是被切换的部分。好，基本上中断处理程序会做的是将任何无法立即处理的事情打包进操作系统线程，以便稍后处理。
- en: Okay。 And a good question about what happens to interrupts when interrupts are
    disabled is they typically just sit around until they get re enabled and then
    they take over。 Okay。 And if we have OS threads then potentially the scheduler
    is indeed going to schedule OS threads。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好。关于中断被禁用时会发生什么的一个好问题是，它们通常只是静静地等待，直到中断被重新启用，然后它们才会接管。好。如果我们有操作系统线程，那么调度程序确实会调度操作系统线程。
- en: Okay。 So think of OS threads as a， if they're like user threads but they don't
    have a user aspect to them。 We'll get more of that next time。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好。可以把操作系统线程想象成类似用户线程的东西，但它没有用户相关的部分。我们下次会更详细地讲解这个内容。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_58.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_58.png)'
- en: So one of the things just to give you a little flavor for what interrupts are
    and don't worry about this too much but every machine has typically what's called
    an interrupt controller。 So it's not a CPU or our core and there's typically an
    interrupt disabled bit。 Okay。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以其中一个要点是给你一个关于中断的基本概念，不用太担心这个，每台机器通常都有一个被称为中断控制器的东西。所以它不是 CPU 或我们的核心，并且通常会有一个禁用中断的标志位。好。
- en: And then the interrupt controller basically is a place a chip piece of hardware
    where all the interrupt lines that are external including the timer interrupt。
    Go through a mask which decides which of them are going to be enabled and which
    aren't。 And a priority encoder to decide if multiple of them are on and enabled
    which one's important。 And if anyone is enabled and its priorities been chosen
    then the interrupt number gets sent to the CPU。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后中断控制器基本上是一个硬件芯片，其中所有外部中断线路，包括定时器中断，都会通过一个掩码，决定哪些中断被启用，哪些不被启用。还有一个优先级编码器，决定如果有多个中断被启用，哪个是重要的。如果有任何中断被启用并且它的优先级已经被选定，那么中断编号就会发送到
    CPU。
- en: And at that point it's going to take an interrupt save the state and continue。
    Okay。 And so interrupts are invoked with interrupt lines typically from devices
    and interrupt controller basically chooses the interrupt request to honor based
    on how it set the mask and priority。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，它会进行中断保存状态并继续。好。所以中断是通过设备的中断线路来触发的，中断控制器基本上会根据它设置的掩码和优先级来选择哪个中断请求需要被处理。
- en: And the CPU is basically going to go ahead and start running that interrupt
    controller。 And most again we'll talk a much more detail when we get into scheduling。
    But most interrupt situations are such that as soon as the interrupt occurs this
    disable every interrupt bit is set long enough for the CPU to do things with the
    mask and so on to avoid that infinite recursion of interrupts。 And then once it's
    sort of fixed that it can turn interrupts back on to allow others to occur。 Okay。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 而 CPU 基本上会开始运行中断控制器。大多数情况下，我们将在调度部分详细讨论，但大多数中断情况是，在中断发生时，禁用所有中断的标志位会被设置，足够长的时间让
    CPU 处理掩码等操作，以避免中断的无限递归。然后一旦处理好，它就会重新启用中断，以允许其他中断发生。好。
- en: And the CPU can disable all of them with this interrupt flag。 Right。 And that's
    a topic for a little more detail。 But I wanted to give you a flavor for the hardware
    context here。 There's basically these actual physical lines that say hi I'm a
    network there's a packet ready。 And that physical line causes an interrupt to
    occur which will take us out of user mode and into an interrupt handler。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 并且CPU可以使用这个中断标志禁用所有这些中断。对吧？这是一个稍微详细的话题，但我想让你们了解这里的硬件上下文。基本上，这些物理线路表示“嗨，我是一个网络，有一个数据包准备好了。”这个物理线路会引发一个中断，使我们从用户模式切换到中断处理程序。
- en: Okay。 Now the question about non blocking on the chat there is basically running
    to completion。 Okay。 We'll be much more detailed about that as we go forward。
    And there's also this non maskable interrupt idea which is an interrupt that can't
    be turned off under any circumstances。 And often is for things like， well your
    power is failing and I've got a couple of seconds worth of capacitance to hold
    me up better do something it's an emergency。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。关于聊天中的非阻塞问题，基本上是“运行到完成”。好的，我们将随着课程深入详细讨论这个问题。还有这个不可屏蔽中断的概念，它是指在任何情况下都无法关闭的中断。通常用于像是“你的电源即将失败，我有几秒钟的电容器来保持电力，最好做点什么，这是紧急情况”这样的情况。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_60.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_60.png)'
- en: Okay。 So let's look at this idea here that let's suppose that the network is
    causing an interrupt and it's interrupt number five。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么让我们看看这个概念，假设网络引起了一个中断，并且它是中断号五。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_62.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_62.png)'
- en: What happens？ Well that number five gets into the CPU。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生什么呢？嗯，数字五进入了CPU。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_64.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_64.png)'
- en: And then that number five is used to look up in an interrupt vector which is
    a chunk of memory in that's accessible in the kernel only to the kernel。 And number
    five one two three four five has a slot in it that points to the interrupt handler
    for interrupt five。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，数字五会用来在中断向量中查找，这个向量是内核中唯一可访问的内存块。数字五、六、七、八、九等都有相应的槽位，指向中断五的中断处理程序。
- en: Okay。 And so notice what's interesting this is a very good example what I mean
    by controlled entry into the kernel。 We use a number five and a table to make
    sure that we go exactly to the right interrupt handler and to the beginning of
    it not somewhere in the middle。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。值得注意的是，这是一个很好的例子，说明我所说的“受控进入内核”是什么意思。我们使用数字五和表格来确保我们准确地跳到正确的中断处理程序，并从它的开始处进入，而不是从中间某个位置。
- en: Okay。 So the fact that we use an interrupt vector and a table means the kernel
    can have very carefully controlled code that's been compiled and looked at millions
    of times that will be invoked whenever say a network interrupt occurs。 Okay。 And
    that's part of the key of making sure that the kernel it's running with really
    high priority can actually run only that piece of the code that has been vetted
    to properly handle say a network interrupt。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们使用中断向量和表格的事实意味着内核可以有经过精心控制的代码，这些代码已经经过编译并经过千万次检查，每当比如网络中断发生时，就会调用这些代码。好的，这是确保内核能够以非常高的优先级运行，并且实际上只运行那些已经经过审查，能够正确处理例如网络中断的代码的关键之一。
- en: Okay。 And we're going to see the same idea with a system call。 Okay。 And I'll
    say it here just briefly we'll talk about system calls in a second。 But when a
    user makes a system call， like I want to read a file that system call the way
    it goes from user to kernel is with a system call number。 And that number will
    look up in a vector table and it simultaneously with going from user mode to system
    mode。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们将看到一个与系统调用相同的概念。好的，我在这里简要地提一下，稍后我们会讨论系统调用。当用户进行系统调用时，比如我要读取一个文件，这个系统调用通过一个系统调用编号从用户模式传递到内核。这个编号会在向量表中查找，并且会同时发生从用户模式到系统模式的切换。
- en: It will also make a decision about which of these vectors to run。 And so the
    user can't just say yeah put it in kernel mode and start running at this address。
    because if they did that that would be a security violation instead they have
    to say， hey。 I want you to run system， call 12 for me。 And in hardware it will
    simultaneously save the user's PC transform into system mode and start running
    the vector 12。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会决定运行这些向量中的哪个。因此，用户不能只是说“把它放到内核模式并从这个地址开始运行”。因为如果他们这样做，会构成安全漏洞，相反，他们必须说：“嘿，我想让你为我运行系统调用12。”
    在硬件中，它会同时保存用户的PC，转换到系统模式，并开始运行向量12。
- en: And by doing that atomically we get our nice controlled entry。 Okay。 All right。
    The question about is there some redundancy here where different handlers might。
    The same handler might be in different slots I think was the question yes under
    some circumstances that will happen。 Depends because there is a way typically
    of reading the idea of what interrupt number you've got as well。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以原子方式执行这一操作，我们得到了一个受控的入口。好的。好吧，关于是否存在冗余的问题，也就是不同的处理程序可能会在不同的槽中运行，是否是同一个处理程序，我想这个问题的回答是，在某些情况下，确实会发生。取决于，因为通常有办法读取当前中断号的概念。
- en: And so there are many different ways to structure this and we'll look at at
    least one of them in Pintos。 All right。 Now， where do you see this this dispatch
    pattern well it's in system calls it's in exceptions。 etc。 And we take interrupts
    safely well we just talked about the interrupt vector so it's a limited number
    of entry points。 There's the kernel stack， which means when the interrupt happens
    we just set aside everything the user is doing。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有很多种方式来结构化这个问题，我们至少会在Pintos中查看其中的一种。好的，那么你们在哪里看到这种调度模式呢？它出现在系统调用中，异常中等等。我们安全地处理中断，好，我们刚才谈到过中断向量，它是有限的入口点。这里是内核栈，这意味着当中断发生时，我们会把用户正在做的事情都放到一边。
- en: And we reload the processor with a kernel stack that's known to be good。 All
    right。 so that no matter what the user was doing， excuse me， the kernel is in
    a good state。 Potentially with interrupts we got to turn that interrupt that just
    occurred off so that we don't get an infinite recursion。 And then we have this
    atomic transfer of control。 Which in a single non interruptable chain we get we
    get a new program counter a new stack pointer。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用一个已知良好的内核栈重新加载处理器。好的，这样无论用户在做什么，抱歉，内核都是处于良好的状态。可能在有中断的情况下，我们需要关闭刚发生的那个中断，以免出现无限递归。接下来我们有这个原子性的控制转移。在一个不可中断的链中，我们得到新的程序计数器和新的栈指针。
- en: We set the memory production protection properly and we make a user kernel mode
    switch and we do that atomically so that we go from the user to the kernel in
    a very controlled way。 All right， and that's how we're going to be able to make
    sure that the kernel gets entered cleanly。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正确设置内存保护，并进行用户到内核的模式切换，我们以原子方式执行这一操作，确保我们以一种非常受控的方式从用户模式切换到内核模式。好的，这就是我们能够确保干净地进入内核的方式。
- en: Okay， and then of course we want to make sure that this is transparent to the
    user and restartable。 And so， even as we make an atomic transfer into the kernel
    we need to save everything that the user was doing。 In a way that allows us to
    restore it so that we can come back from the interrupt and the user can pick up
    where they left off with their computation kind of unscathed in that。 Okay， and
    so this idea of a separate kernel stack is just I wanted to say a little bit more
    and then next time and the time after we'll show you in even more detail because
    you're going to get deep into the kernel in a bit。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来，当然我们需要确保这一切对用户是透明的，并且是可重启的。因此，即使我们进行原子性的内核转移，我们也需要保存用户正在做的所有事情。以一种方式让我们能够恢复这些内容，这样我们就可以从中断中恢复过来，用户可以在中断后从上次停止的地方继续他们的计算，几乎不受影响。好的，所以这个关于单独内核栈的想法，我只是想多说一点，接下来几次我们会更详细地展示，因为你们稍后会深入了解内核。
- en: But we can't use the user's stack。 Can anybody figure out why we wouldn't want
    to use the users。 the memory that the user's stack point register is pointing
    it。 Yeah。 I like that safety and cap security and lowercase I don't know if there's
    a difference between those two。 But for instance the simplest thing is they could
    have a bad address in their stack pointer。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不能使用用户的栈。有没有人能想出为什么我们不想使用用户的栈呢？也就是用户的栈指针寄存器所指向的内存。对了，我喜欢那个“安全性”和“能力安全”还有小写的“i”，我不知道这两者之间是否有区别。不过，最简单的情况是，他们的栈指针可能指向一个错误的地址。
- en: And if we use it the whole machine could crash right so really we have everything
    for the first month or more of the class is going to have this two stack model
    which we're going to talk in great detail so don't worry about it too much。 But
    every user program or process that's running has a kernel stack associated with
    it explicitly。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用它，整个机器可能会崩溃，所以实际上，我们在课程的前一个月或者更多时间里，将使用这个两栈模型，我们会详细讨论它，所以不要太担心。但每个正在运行的用户程序或进程都有一个与之明确关联的内核栈。
- en: And when we're running the program itself。 We were up in the user code and it's
    got its own stack that it's running。 And if the process is suspended and sleeping，
    because say green is running so yellow is asleep。 If you look at yellow's resources，
    there's going to be the yellow's user stack but even the yellow's kernel stack
    is going to have the saved state on it。 And going to be suspended while the green
    is running。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序本身时，我们处在用户代码中，并且它有自己的栈在运行。如果进程被挂起并进入休眠状态，比如说绿色在运行，而黄色在休眠。若查看黄色的资源，将会看到黄色的用户栈，甚至黄色的内核栈上也会保存有状态。而且当绿色在运行时，黄色将会被挂起。
- en: And then if we look at what happens when we're we've done a system call into
    the kernel。 notice that every time we make this transfer from user to system we
    get a new kernel stack。 And then potentially if the system call requires a bunch
    of stuff to be done in the kernel。 we use the kernel stack to do that stuff。 Okay，
    and so we have a nice clean guaranteed stack it's small。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下当我们执行系统调用进入内核时会发生什么，注意每次从用户空间转到系统空间时，我们都会获得一个新的内核栈。然后，如果系统调用需要在内核中执行一堆操作，我们会使用内核栈来完成这些操作。好的，因此我们有一个干净且保证的小栈。
- en: Okay， Pintas is going to be 4k and we'll talk more about that。 But it's enough
    to run what we need down here and then when we're ready to return from interrupt
    in particular case。 we return all of the stuff that the system call itself was
    doing。 And then we restore the user state which is going to include restoring
    the user's stack and then we return to user and the user picks up where they left
    off。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Pintas 将是 4k，我们稍后会详细讨论这个。但它足够支持我们在这里需要运行的内容，尤其是当我们准备从中断中返回时，我们会恢复系统调用本身执行的所有内容。然后我们恢复用户状态，其中包括恢复用户的栈，接着我们返回到用户空间，用户就能从中断之前的地方继续执行。
- en: Okay。 And so yes I did say there's a separate kernel stack for every user process。
    And there is a good comment in the in the chat does all of this security stuff
    rely on there being no bugs in the kernel。 Yes。 So if there are bugs in the kernel，
    all bets are off。 Some bugs are worse than others。 But you can imagine。 Okay。
    Where is the kernel stack that's a great question can be many places in Pintas
    it turns out that the kernel stack actually is a single page and has the PCB in
    it。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以是的，我确实说过每个用户进程都有一个独立的内核栈。聊天室中有个很好的评论：所有这些安全措施是否都依赖于内核没有漏洞？是的。如果内核有漏洞，那么一切都不再可靠。一些漏洞比其他漏洞更严重，但你可以想象一下。好的，内核栈在哪里？这是一个很好的问题，实际上可以有多个位置。Pintas
    中的内核栈实际上是一个单页，并且包含 PCB。
- en: Okay， not specifically in the part that's called a stack but it's all in one
    page。 Okay。 and we'll look。 And we'll look at that in more detail。 Why do we know
    the user can't can't touch the kernel stack because it'll be in a part of memory
    that's inaccessible because of the translation protection of the of the address。
    base think back to base and bound from earlier。 These are in the gray part。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，虽然这部分不直接被称为栈，但它都位于同一页面上。好的，我们会更详细地研究这个。我们怎么知道用户无法触碰内核栈呢？因为它位于一块因地址翻译保护而不可访问的内存区域。回想一下之前提到的基址和界限，它们位于灰色区域。
- en: And as a result when we're running up here in green or yellow， they can't access
    gray。 Okay。 hopefully that helps。 And so we'll make sure that our protection is
    such that the user can't mess up the gray。 So for instance， in the case of the
    x86， you can see here that when we're running at the user level。 we have the the
    users stack。 We have the users code PC and what I'm showing you here is the stack
    segment。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当我们在绿色或黄色中运行时，它们无法访问灰色区域。好的，希望这个解释能帮到你。所以我们会确保我们的保护措施使得用户无法干扰到灰色区域。举例来说，在
    x86 架构中，当我们在用户级别运行时，我们有用户的栈，我们有用户的代码 PC，我在这里展示的是栈段。
- en: And the ESP is a stack pointer here we have the code segment and the EIP。 And
    then after we're during， excuse me the interrupt system call。 we have switched
    atomically over to the kernel stack so notice how the stack pointer is on the
    exception or。 the back and the instruction pointer is pointing into kernel code。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 ESP 是栈指针，我们有代码段和 EIP。然后在执行中断系统调用时，我们会原子切换到内核栈，因此注意栈指针指向异常，而指令指针则指向内核代码。
- en: This transfer from here to here actually happens as part of the hardware transfer
    in the x86 and we'll get a lot more detail about that but that's。 that's kind
    of how we set it up so that when the interrupt happens we go poof over the other
    side and we automatically switch to a new stack。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个从这里到这里的转移实际上是在x86硬件传输的一部分，我们将会详细了解这个过程，但这就是我们如何设置它，当中断发生时，我们会“砰”的一声切换到另一端，并自动切换到新的堆栈。
- en: So that helps to keep the integrity of the kernel up there。 Okay。 Now， if you
    remember。 I gave you this picture last time but maybe we can understand a little
    bit more about it now so the application itself。 the user code is kind of up here
    at some， you know。 interesting program that is computing the last digit of pie
    or whatever。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这有助于保持内核的完整性。好了，现在，如果你还记得，我上次给过你这张图，但也许现在我们可以稍微更好地理解它，所以应用程序本身，用户代码大致在这里，可能是某个有趣的程序，比如计算圆周率的最后一位数字之类的。
- en: And then we'll be linked with some standard libraries like libc that was mentioned
    in the chat earlier。 And then those libraries will potentially make system calls
    into a part of the kernel that is running part of the kernel code which is going
    to be running。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们会链接一些标准库，比如先前聊天中提到的libc。然后这些库可能会通过系统调用访问运行内核代码的内核部分。
- en: in the system mode。 And in the case of a monolithic kernel like this one。 we'll
    talk more about non monolithic ones much later。 All of that code is inside a special
    part of the memory that has been linked just for the kernel and set up to run
    in kernel mode and it has things like the file system and the scheduler and all
    sorts of things。 Okay， and we're going to talk about many different pieces of
    this as the term goes on。 And。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统模式下。对于像这样的单体内核，我们稍后会讨论更多关于非单体内核的内容。所有这些代码都位于内存的一个特殊部分，这部分是专门为内核链接的，已设置为在内核模式下运行，包含像文件系统、调度程序以及各种其他内容。好的，我们将在学期中讨论这些不同的部分。
- en: and this question in the， in the chat about why the registers are saved in the
    exception stack。 Think of the exception stack and the kernel stack are the same
    thing。 Okay， there， you know。 when you take an exception， the kernel stack is
    handling the exception。 So that's an exception stack at that point。 Okay， sorry
    for the confusion there。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于聊天中提到的为什么在异常堆栈中保存寄存器的问题。可以把异常堆栈和内核堆栈看作是同一个东西。好了，知道吗？当你发生异常时，内核堆栈在处理这个异常。所以那时它就成了一个异常堆栈。好的，抱歉造成了混乱。
- en: But exception stack and kernel stack are the same for your purposes right now。
    And so this system call interface is the one that we're going to spend a little
    bit more time on as we end this lecture and probably a little bit into the next
    lecture。 But I wanted to show you this right so all of the services that we think
    of as being provided securely by the kernel are things that run in kernel mode
    and are inside the kernels memory。 Now， there's a good question here is the hardware
    built with the OS in mind or is the OS built purely on top of the existing hardware。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于你的当前目的来说，异常堆栈和内核堆栈是相同的。所以，这个系统调用接口就是我们将在结束这节课时，可能还会延续到下节课讨论的内容。但我想给你展示一下这一点，所有我们认为由内核安全提供的服务，都是在内核模式下运行的，且都在内核的内存中。现在，这里有一个很好的问题：硬件是以操作系统为设计前提构建的，还是操作系统完全建立在现有硬件之上？
- en: So that's philosophy 436 that's a different class than this one。 I would say，
    you know。 originally there were no nothing that we would recognize as an OS but
    the OS idea has been around since almost the beginning of time and so basically。
    Pretty much all hardware is built with an OS in mind。 It's just a question of
    how sophisticated an OS can run on given hardware and we'll hopefully understand
    a little bit more about that。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那是哲学436，这是一个不同于这个课的课程。我会说，最初并没有我们现在能识别的操作系统的概念，但操作系统的想法几乎从一开始就存在了，因此，基本上，几乎所有的硬件都是以操作系统为设计前提来构建的。关键问题是，如何在给定的硬件上运行一个足够复杂的操作系统，我们希望能更好地理解这一点。
- en: And then I love the chicken and egg comment in there。 The other reason there
    is a chicken and egg thing here is that as people have become more sophisticated
    in their requirements from the operating system。 hardware has adapted。 And the
    great example of that which we will talk about later in the term more is the idea
    of virtual machines。 There's been adaptation pretty significantly over the last
    20 years of the way the CPU is designed to make it easier for running virtual
    machines。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我喜欢那里的“鸡与蛋”评论。这里存在鸡与蛋的另一个原因是，随着人们对操作系统需求的日益复杂，硬件也在不断适应。而我们稍后会讨论的一个很好的例子，就是虚拟机的概念。在过去20年里，CPU的设计已经发生了显著变化，以便更方便地运行虚拟机。
- en: Okay。 And the registers are the same registers。 So keep in mind， I'm going to
    say this。 The question here， do we have separated registers for the OS。 Usually
    no except for special processors。 For now， just remember。 we are thinking about
    one core or one CPU to rule them all。 Okay。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，而寄存器是相同的寄存器。所以记住，我要说这个问题：操作系统有分离的寄存器吗？通常没有，除非是特殊的处理器。现在，只需记住，我们是在考虑一颗核心或者一颗CPU，统治所有的方式。好了。
- en: and it runs both the kernel code and the user code and we got to make sure the
    right thing happens with saving and restoring the registers when we're transitioning
    back and forth。 Okay， so think about a single， a single set of registers to rule
    them all is the way to think。 Okay。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它同时运行内核代码和用户代码，我们必须确保在来回切换时，保存和恢复寄存器的操作是正确的。好了，想象一下，这是一组寄存器，统治所有寄存器，这就是思考的方式。好了。
- en: so there's this narrow waste， which is really the system call interface and
    we're going to be exploring this more in detail。 but you could think of the space
    of applications is large。 the space of services and hardware is large， and it's
    the system call interface the。 controlled entry to the kernel that really gives
    us the power to make this work in a controlled way。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有一个狭窄的浪费，实际上就是系统调用接口，我们将更详细地探索这一部分。但你可以认为应用程序的空间很大，服务和硬件的空间也很大，而正是系统调用接口，即进入内核的受控入口，赋予我们以受控的方式使其工作的能力。
- en: So what about that system call handler？ It's roughly similar to what interrupts。
    but it's for calling services。 And so once again， we're going to vector through
    a standard。 well-defined system call entry points。 We're going to locate arguments
    and registers are on the stack or wherever when to get into the kernel。 We're
    going to copy the arguments because and make sure that they're validated and saying
    because we can't trust the user to either give us arguments that are in a reasonable
    part of memory or that are reasonable。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 那系统调用处理程序呢？它大致类似于中断，但它是用于调用服务的。因此，我们将通过标准的、定义明确的系统调用入口点进行跳转。我们会定位参数，查看寄存器是否在栈上或其他地方，当要进入内核时，我们会复制这些参数，并确保它们是有效的，因为我们不能信任用户提供的参数，它们可能不在合理的内存区域，或者可能不合理。
- en: We're going to validate them and then we're going to copy the results back into
    user memory when we're done。 And so it's basically the kernel will trust， but
    verify in the sense that everything gets verified。 Maybe trust nothing， I guess。
    But go into a system call， check everything， check it twice。 make sure all the
    addresses are good。 Do what you were asked to。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将验证它们，然后在完成后将结果复制回用户内存。所以，基本上，内核会信任，但会验证，意味着所有的内容都会被验证。也许不信任任何东西吧，我猜。但进入系统调用时，检查一切，检查两遍，确保所有地址都是正确的。按照要求做事。
- en: copy the results out of the kernel back into user space。 So the user is never
    given access to the kernel and it can't corrupt the kernel。 Now the question about
    does the， so I think the， let's hold off on the question of does the OS have its
    own registers or not。 I think keep in mind that most of the registers for execution
    are all the same。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果从内核复制回用户空间。因此，用户永远不会直接访问内核，也无法破坏内核。关于操作系统是否有自己的寄存器的问题，我想我们可以暂时不讨论。我认为，记住大部分执行时使用的寄存器其实都是一样的。
- en: There are some special ones for things like the base table of virtual memory
    and stuff。 but that's not kind of what I thought the question was about。 So， okay。
    so let's put it all together。 Here's a web server， you know， you make a request
    to the web server。 you make a reply。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的情况，比如虚拟内存的基表等。但那并不是我认为问题的关键所在。那么，好吧，接下来我们把所有内容合在一起。这里有一个网页服务器，你知道，你向网页服务器发送请求，然后得到回复。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_66.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_66.png)'
- en: Question might be what is it that the web server does。 And so you can imagine
    on the web server itself is a process that is the web server。 Okay。 and on that
    web server， there's hardware with networking and disk。 There's the kernel and
    then there's the server process， which is that Apache web server。 All right。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可能是，网页服务器做了什么？你可以想象，网页服务器本身是一个进程，就是这个网页服务器。好的，服务器上有网络和磁盘硬件。还有内核，接着是服务器进程，也就是那个Apache网页服务器。好的。
- en: and you know that web server when it starts up， it's a process。 It's running
    in user mode。 And the network， basically the server starts by saying read for
    the。 read the network socket that has been set up and ask it， are there more requests
    in。 And usually what will happen is that system called a read is going to wait
    by going to sleep if there's no requests。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，网页服务器启动时，它是一个进程。它在用户模式下运行。网络基本上是通过读取已经设置好的网络套接字来启动服务器，并询问是否有更多请求。通常发生的情况是，如果没有请求，系统调用读取会通过睡眠等待。
- en: And now in this situation， the server is sleeping because it's waiting for something。
    Okay。 and meanwhile， the request， or sometime later the request will come in。
    It'll generate an interrupt saying， hey， there's a request， which will wake up
    the server process。 return the request， and now the server process。 And now the
    server process has the request in a buffer。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这种情况下，服务器正在等待，因为它在等待某些东西。好的。与此同时，请求，或者稍后会有请求进入。它会生成一个中断，表示有请求，这将唤醒服务器进程。返回请求，现在服务器进程就有了请求的缓冲区。
- en: So notice there was a read system call that came back with data， but in print。
    what happened in timing is the read system call slept for a while until the interrupt
    came in。 And then we got our data。 And now that data is what it's a request for
    a web page。 So we figure out what that means。 It's HTTP and HTML。 And we're going
    to figure that out。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请注意，读取系统调用已经返回了数据，但在打印时，发生的时间是读取系统调用睡了一会儿，直到中断到来。然后我们得到了数据。现在这些数据是什么呢？它是网页请求。所以我们弄清楚它的含义。是HTTP和HTML。我们会弄清楚的。
- en: And now we know what file to read。 So we'll do a read system call。 Notice this
    read system call is going after the disk。 This read system call went after the
    network。 You're going to learn very soon that Unix makes everything that's I/O
    look pretty similar。 Reads and writes are going to be similar across the board。
    But here we ask for a read。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道要读取哪个文件了。所以我们会执行一个读取系统调用。注意这个读取系统调用是去访问磁盘。这个读取系统调用是去访问网络。你很快就会学到，Unix将所有I/O操作看作相似的。读取和写入操作在各方面都很相似。但在这里我们请求读取。
- en: That's going to have to wait because potentially the kernel may actually have
    to go to the disk。 And that's going to take time。 The disk will interrupt with
    a result。 The result will come back from the read。 Now we have a reply buffer。
    We'll format the reply。 We'll send it back to the outgoing socket via another
    system call。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不得不等待，因为内核可能实际上需要访问磁盘。这将需要时间。磁盘会以中断的方式返回结果。结果会从读取操作中返回。现在我们有了一个回复缓冲区。我们会格式化回复，通过另一个系统调用发送到出去的套接字。
- en: And the reply goes back and we end up with looking at a web page。 Okay。 And
    the difference between an interrupt and a system call here is the system call
    is a。 synchronous query from the process into the kernel that's like a function
    call that's。 going to give a result back。 Whereas the interrupt is an asynchronous
    thing that comes in from the outside world。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回复返回，我们最终看到一个网页。好的。中断和系统调用之间的区别在于，系统调用是一个从进程到内核的**同步查询**，就像一个函数调用，它会返回一个结果。而中断是来自外部世界的**异步事件**。
- en: Okay。 All right。 And this step two and step seven， those are interrupts。 Okay。
    And they're going to invoke that interrupt mechanism I showed you earlier。 Okay。
    And the white box is here。 Uh， represent queuing。 And so we're， you know。 I'm
    being very high level here right now， but there's a bunch of， queues。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，好的。步骤二和步骤七是中断。好的。它们将触发我之前展示的中断机制。好的。白框代表排队。所以，我们现在在高层次上讲，实际上这里有很多队列。
- en: And so typically if there were a bunch of packets that came in before we did
    our read， then。 they'd be queued and the read would grab the first one and so
    on。 So typical sockets or buffers have many， uh， many， um， queues。 Now this question
    about， um。 does the interrupt happen without the kernel making a， request？ And
    the answer is going to be that。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通常，如果在我们进行读取之前有一堆数据包到达，那么它们会被排队，读取操作将会获取第一个数据包，依此类推。因此，典型的套接字或缓冲区有很多队列。现在关于这个问题，嗯，中断是否在内核没有发出请求时发生？答案是。
- en: um， yes， but there's some setup where we've set the， socket up in advance。 And
    once it's set up。 then there's a channel and somebody who's trying to make， uh，
    um。 get a web page will actually send a request in to a， to this queue that's
    been set up in， advance。 And so we're going to be able to make sure that we're
    not going to be able to make， the request。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的，但有一些设置，我们已经提前设置好了套接字。一旦设置完成，就会有一个通道，有人试图获取网页时，会将请求发送到这个提前设置好的队列中。因此我们将能够确保我们不会无法发出请求。
- en: And so we're going to be able to make sure that we're not going to be able to
    make， the request。 And so we're going to be able to make sure that we're not going
    to be able to make， the request。 And so we're going to be able to make sure that
    we're not going to be able to make， the request。 And so we're going to be able
    to make sure that we're not going to be able to make， the request。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将能够确保我们不会无法发出请求。因此我们将能够确保我们不会无法发出请求。因此我们将能够确保我们不会无法发出请求。因此我们将能够确保我们不会无法发出请求。
- en: And so we're going to be able to make sure that we're not going to be able to
    make， the request。 That's why， you know， we've got to make sure that when the
    interrupt happens， really。 this interrupt is actually interrupting something else
    that's running。 Probably not the service process because the service process is
    sleeping， but the。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将能够确保我们不会无法发出请求。这就是为什么，你知道，我们必须确保当中断发生时，确实，这个中断正在中断其他正在运行的程序。可能不是服务进程，因为服务进程处于休眠状态，但。
- en: interrupting something else that's happening， saving and restoring its registers，
    doing。 handling the interrupt and then restoring to that thing。 And then eventually
    we run the server process。 Okay。 And so there's a lot of simultaneous things going
    on here that are going to be things we。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 中断其他正在进行的操作，保存并恢复寄存器，处理这个中断，然后恢复到那个操作。最后我们运行服务器进程。好的。因此这里有很多同时进行的操作，我们需要处理。
- en: have to sort out， but I am quite confident that within the next couple of weeks
    you'll。 have a much clean handle， a much better handle on how this all works together。
    because there's a fairly simple set of mechanisms。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 需要整理一下，但我相当有信心，在接下来的几周内，你将会对这一切如何协同工作有一个更加清晰的把握。因为这里有一套相当简单的机制。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_68.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_68.png)'
- en: All right。 So if you recall and we don't have a time to go through this entirely，
    actually。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果你记得的话，我们没有时间完全讲解这一点，实际上。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_70.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_70.png)'
- en: let me stop and see if there's one more question on this。 Anybody else have
    any other questions？ Ah。 good question。 What happens if an interrupt comes while
    another interrupt is being handled？
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我停下来看看是否还有其他问题。还有其他人有问题吗？啊，好的问题。如果在另一个中断被处理时发生中断会怎样？
- en: So remember that interrupt controller。 So the interrupt controller。 when the
    first interrupt comes in， okay， both， I'm assuming for the sake of argument。 you're
    asking what happens if two， interrupts come in from the network at the same time
    or roughly the same time。 The first one will enter the interrupt handler and that
    interrupt handler will。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所以记住中断控制器。当第一个中断到达时，好的，假设为了讨论的方便，你问的是如果两个中断几乎同时从网络到达会发生什么。第一个中断将进入中断处理程序，这个中断处理程序会。
- en: disable the network interrupt while it's processing interrupt number one， taking。
    that first packet in。 And then when it returns from interrupt， it'll re-enable
    and at that point。 the second interrupt will come and go forward。 Okay。 So basically
    the way we control the interrupts to make sure that we don't have。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第一个中断时，禁用网络中断，接收第一个数据包。然后当它从中断返回时，它将重新启用，此时第二个中断将到来并继续处理。好的。所以基本上，我们控制中断的方式是确保不会发生。
- en: chaos because the outside world is messy， right？ There's the philosophy 405
    for you today that the outside world is messy。 We make sure that we never let，
    we never re-enable interrupts to happen if。 we're doing something to the core
    state of some thing inside the kernel that would。 get messed up if the second
    one came along。 And so that's how we're going to enable and disable interrupts
    properly。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱是因为外部世界是混乱的，对吧？今天给你讲的哲学 405 就是，外部世界是混乱的。我们确保在处理内核内某些核心状态的操作时，永远不重新启用中断，以免第二个操作出现并破坏核心状态。所以这就是我们如何正确启用和禁用中断。
- en: Okay。 Good。 All right。 So if you remember， we talked about processes today，
    but one thing。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，明白了。那么，如果你记得，我们今天讨论的是进程，但有一点……
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_72.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_72.png)'
- en: So how do we manage the process state？ You know， obviously you see we got stacks
    and registers and code and data。 We're going to have to figure out how to initialize
    all that stuff。 So we're going to get there and we're going to need to worry about
    creating， and exiting processes。 Okay。 And if you remember， everything outside
    of the kernel runs in a process。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何管理进程状态呢？你知道的，显然我们有堆栈、寄存器、代码和数据。我们必须弄清楚如何初始化这些东西。所以我们会到达那个阶段，并且需要关注如何创建和退出进程。好的。如果你记得，内核外部的一切都在一个进程中运行。
- en: So it's not like processes are special things in the sense that they only， happen
    occasionally。 Processes are major functionality。 Okay。 And so even more interesting
    is the fact that processes are created and。 managed by other processes。 So we
    have a bootstrapping problem here。 So processes are created by other processes。
    You know， this is the ultimate chicken and the egg。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所以进程并不是特殊的东西，它们不是偶尔才会发生的事情。进程是主要的功能。好的。而更有趣的是，进程是由其他进程创建和管理的。所以我们这里有一个引导问题。进程是由其他进程创建的。你知道的，这是经典的“鸡和蛋”问题。
- en: How does the first process start？ And the answer is the very first process gets
    started at the time of the。 kernels booted。 And it's typically called the init
    process。 And once that init process starts。 it will then start a shell potentially，
    or start a set of other processes。 So once we have the first process， it will
    then be able to do something， called fork， which will。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个进程是如何启动的？答案是，第一个进程是在内核启动时启动的，通常被称为 init 进程。一旦这个 init 进程启动，它可能会启动一个 shell，或者启动一组其他进程。所以一旦我们有了第一个进程，它就可以做一些被称为
    fork 的事情。
- en: if you'll bear with me for a moment， I'll at least， give you an idea what it
    is。 And then we'll talk a lot more about it next time， which allows more。 processes
    to be created with that first one as the parent。 Okay。 And so we have a process
    management API exit fork， exact wait， kill， sig action。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微耐心一点，我至少会给你一个概念，然后我们下次会更详细地讨论它，这样更多的进程可以由第一个进程作为父进程创建。好的。所以我们有一个进程管理的 API，包括
    exit、fork、exec、wait、kill、sig action。
- en: And in your project number one， you're going to get to play with this， pretty
    intimately。 You'll get to learn this part of the API。 And for instance， what does
    exit do？ Well， exit。 as you can imagine， is a system call that takes us from running。
    a user process to exiting the user process and basically destroying， its state。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的一号项目中，你将会非常亲密地接触到这一部分。你将学习这个 API 的这一部分。例如，exit 做什么？嗯，exit，顾名思义，是一个系统调用，它将我们从运行一个用户进程转到退出该进程，基本上销毁它的状态。
- en: And if you remember that little semi-circle picture I had where there。 was red
    in the middle and there was the blue user process， the thing at the， far right
    was exit。 So that's how a process is killed off。 And if you look here， you're
    going to learn a lot about main。 That's going to be your favorite procedure in
    C because that's the。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我之前展示过的那个小半圆形图片，上面中间是红色，右侧有蓝色的用户进程，最右侧的是退出。那就是一个进程是如何被终止的。如果你看这里，你将学到很多关于主函数的内容。那将是你在
    C 语言中的最喜欢的过程，因为那是典型进程的起始点。
- en: starting point for a typical process。 And we run a bunch of stuff here。 In this
    case。 we're running get PID， which is a libc function that， then makes a get PID
    system call。 So it asks the kernel， "Hey， what is my process？ ID？"， And we'll
    print it out with a printf。 And then we exit with a zero argument that typically
    means no errors。 So zero is a good exit。 Okay。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里运行了一些东西。在这个例子中，我们运行的是 get PID，这是一个 libc 函数，它随后会发出一个 get PID 系统调用。所以它会问内核，“嘿，我的进程
    ID 是多少？”然后我们用 printf 打印出来。然后我们用一个零参数退出，通常意味着没有错误。所以零是一个好的退出码。好的。
- en: And the question might be， "What if we forgot that？"， And we just let main exit。
    Well。 it turns out that main is not the real first thing that runs。 There's other
    stuff。 And so if we forget exit and we just let main and then exit gets。 called
    automatically for us by the OS library。 Okay。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可能是，“如果我们忘记了那个呢？”然后我们就直接让主函数退出。好吧，结果证明，主函数并不是第一个运行的东西。还有其他的东西。所以如果我们忘记了退出，我们只是让主函数执行，然后退出会由操作系统库自动为我们调用。好吧。
- en: So there's kind of an implicit exit zero at the end。 All right。 Okay。 Now you'll
    see this in。 you know， project zero and it。c。 You get to actually see kind of
    part of what happens at the。 beginning of wrapped around main there。 Okay。 Now
    let's look at fork。 So fork is one of the stranger routines that you'll get to
    run。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在最后会有一个隐式的退出零。好了。现在你将在项目零和它的.c文件中看到这一点。你将看到主函数开始时的一部分内容。好吧，现在我们来看一下fork。fork是你将要运行的最奇怪的例程之一。
- en: into part of its kind of a legacy thing from original Unix。 But it's actually
    a pretty useful routine。 So the idea is copy the current process and get a new
    process ID。 and create a brand new address space and a brand new security。 context
    and start running with a single thread。 Okay。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始Unix中的遗留部分，但它实际上是一个非常有用的例程。它的基本思路是复制当前进程，获取一个新的进程ID，创建一个全新的地址空间，一个全新的安全上下文，并开始运行一个单线程。好吧。
- en: And that single thread is going to kind of pick up where the other one left，
    off。 So fork is the weirdest function call that you're going to get。 And that's
    the first function call that you're ever going to run。 into because if you think
    about it before you execute fork。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单线程将会在另一个线程停止的地方继续执行。所以fork是你将遇到的最奇怪的函数调用。这也是你第一次会遇到的函数调用，因为如果你想想看，在执行fork之前。
- en: there's one process after you execute fork， there's two。 processes which are
    duplicates of each other。 So if you were to look inside。 what happens is the first
    process， executes fork and then it returns from fork。 And the second one also
    returns from fork in the exact same place。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完fork之后，会有两个进程，它们是彼此的副本。所以如果你看看内部发生了什么，第一个进程执行fork，然后从fork返回。第二个进程也在完全相同的位置从fork返回。
- en: in the code except that the original one， which is the parent， process。 returns
    something non-zero from fork。 It's an integer and that non-zero number is actually
    the process。 ID of the child。 Okay。 And in the child process， it's going to return
    zero telling that。 guy that it's child。 And if there's something less than zero，
    that's going to be an error。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中唯一的不同是，原始进程，即父进程，从fork返回一个非零值。这个值是一个整数，实际上是子进程的进程ID。好吧，在子进程中，它将返回零，告诉操作系统它是子进程。如果返回的值小于零，那就是一个错误。
- en: And that's only going to occur inside the parent。 Okay。 And the state of the
    original process is duplicated in both， the parent and the child。 Okay。 There's
    going to be duplicate address spaces。 So the address space is going to be fully
    copied into the child。 All of the file descriptors are going to be copied。 Everything
    is going to be copied。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况只会发生在父进程内部。好吧。原始进程的状态在父进程和子进程中都会被复制。好吧。将会有重复的地址空间。所以地址空间会完全复制到子进程中。所有的文件描述符也会被复制。所有的一切都会被复制。
- en: And you'll have two things that are running and are essentially， identical for
    each other。 But one of them gets a non-zero back from fork and the other gets
    a， zero。 Okay。 Now the use case is going to be something you're going to run，
    into very quickly。 which is how a shell works。 It uses fork among other things。
    Okay。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会有两个正在运行的进程，它们本质上是彼此相同的。但其中一个从fork返回非零值，另一个则返回零。好吧。现在用例是你很快就会遇到的情况，比如shell是如何工作的。它使用了fork，当然还有其他东西。好吧。
- en: And the child is able to find out who its parent is and what its。 parent ID
    is by a separate system call。 So you'll learn about those。 But the other thing
    to think about a use case for fork is suppose。 that you have somebody running
    and you fork off a child process。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程能够通过一个单独的系统调用来找到它的父进程是谁，以及它的父进程ID是什么。所以你会学到这些。但另外一个需要考虑的fork的用例是，假设你有一个进程正在运行，你然后fork出一个子进程。
- en: and it's going to have exactly the same environment as a parent。 So it'll be
    easy for you to figure out how to make it。 And at that point。 the child will be
    in that environment you've， already set up and you can have the parent wait until
    it's done。 Okay。 And if you look， I'm going to give you one quick example here。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它将拥有与父进程完全相同的环境。所以你很容易就能弄清楚如何去构建它。此时，子进程将处于你已经设置好的环境中，你可以让父进程等待，直到子进程完成。好了，如果你看，我将在这里给你一个快速示例。
- en: How does it decide greater than zero versus zero？ Well， that's just an if clause。
    So here you say。 you know， result equal fork and then if result， greater than
    zero， otherwise if result zero。 And those of you who can bear with me for another
    couple of minutes。 I want to just show you an example。 So here's a good example。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何判断大于零还是零呢？这其实就是一个 `if` 语句。所以这里你会看到，首先执行 `result = fork`，然后判断 `if result >
    0`，否则 `if result == 0`。对于那些能耐心再等我几分钟的朋友，我想给大家展示一个例子。这是一个很好的例子。
- en: So here's a fork usage where we have the main。 Okay。 And it sort of gets its
    own PID and it says。 oh， parent PID is this。 All right。 And now at this point，
    we call fork and we set the CPID to equal。 the return from fork。 Okay。 And notice
    what we do right after。 We say if CPID greater than zero。 then we know that the
    parent is， going to run in this part of the if else if CPID is zero。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `fork` 的一个用法例子，在这里我们有主进程。它获取了自己的 PID，并表示“哦，父进程 PID 是这个”。好了，现在我们调用 `fork`
    并将 CPID 设置为 `fork` 的返回值。注意我们接下来的操作：我们判断 `if CPID > 0`，如果成立，就说明父进程将在这个 `if` 语句中执行，否则如果
    `CPID == 0`。
- en: the child is going to run in this part of fork。 Otherwise we're going to cause
    an error or declare an error and say。 the fork failed。 Okay。 Yes。 This is messed
    up。 Maybe。 Well， it's a good thing to learn。 Okay。 Now notice that first and foremost，
    after you get past fork。 there are two things that are essentially identical where
    the only。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程将在 `fork` 的这一部分运行。否则我们将导致错误，或者声明错误，表示 `fork` 失败。好了，是的，这有点混乱。也许吧，但这是个值得学习的好事。好了，现在请注意，首先，最重要的是，经过
    `fork` 后，你会有两个几乎完全相同的进程，它们唯一的区别就是……
- en: difference is one of the processes CPID is greater than zero and the。 other
    process CPID is equal to zero。 And the question of what do you。 what if you call
    a function inside， either of these if statements？ Well。 that function will now
    run only in the given process。 So up to this point， we had only one process。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于一个进程的 CPID 大于零，而另一个进程的 CPID 等于零。那如果在这些 `if` 语句中调用一个函数呢？嗯，那时该函数只会在特定的进程中运行。到目前为止，我们只有一个进程。
- en: After this point， we have two。 If you run something in this arm of the if， it'll
    only run in the。 parent process。 If you run something in this arm of the if， it'll
    only run in the， child process。 So for instance， here I've got two arrows。 So
    I've got C and P。 You can imagine C stands for parent and P stands， for child。
    Oh wait， are you paying attention？
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这一步，我们有两个进程。如果你在 `if` 语句的这个分支中运行某些代码，它将只在父进程中运行。如果你在另一个分支中运行某些代码，它将只在子进程中运行。例如，这里我有两个箭头，分别表示
    C 和 P。你可以理解 C 代表父进程，P 代表子进程。等等，你们在认真听吗？
- en: C stands for child and P stands for parent。 And notice that right after fork。
    we have two things and they'll， start executing。 And in that case。 the parent
    will run here and the child will run， here。 Okay。 When does fork return one and
    when does it return the other？ It always returns。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: C 代表子进程，P 代表父进程。注意，`fork` 调用后，我们有两个进程，它们将开始执行。在这种情况下，父进程将在这里运行，子进程将在这里运行。好了，什么时候
    `fork` 返回 1，什么时候返回 0 呢？它总是返回……
- en: unless there's a failure， it returns greater than。 zero in one process and zero
    in the other process。 So this is why I'm leaving you guys to mull over this over
    dinner， to think about this。 After we call fork， there are now two where there
    were just one。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除非出现故障，否则它会在一个进程中返回大于零，在另一个进程中返回零。所以这就是为什么我让你们在晚餐时思考这个问题，仔细考虑一下。调用 `fork` 后，现在有两个进程，而原本只有一个。
- en: Those two processes are both running。 One of them， the return from fork was
    greater than zero。 The other one， the return from fork was zero。 Okay。 Now the
    question of what's the PID of the child。 So every process has a process ID。 Here
    we know what the child's PID was just by looking at CPID。 Here the child has to
    ask， you know， get PID to get its own PID。 Okay。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个进程都在运行。其中一个进程，`fork` 的返回值大于零；另一个进程，`fork` 的返回值为零。好了，现在问题是子进程的 PID 是多少。每个进程都有一个进程
    ID。通过查看 CPID，我们知道子进程的 PID。这里子进程必须调用 `getpid` 来获取它自己的 PID。明白了吗？
- en: Now there's lots of questions here。 One of them， why do we have to explicitly
    call fork？ Well。 because fork is a style of parallelism。 So fork is one way to
    do it。 We'll talk about other styles of parallelism as we go。 But fork is the
    principle way that you have for creating a brand new， protection environment。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多问题。比如，为什么我们必须显式调用fork？嗯，因为什么，fork是一种并行方式。所以fork是实现并行的一种方式。我们会在后续讨论其他的并行方式。但fork是创建全新保护环境的主要方式。
- en: namely a process。 Okay。 We'll talk about new threads。 So this new process that
    we've just created。 the child process has， exactly one thread running。 We'll talk
    about how to get more。 Okay。 And the child process can yes call fork。 So in here，
    the child process could go ahead and call fork。 And now we've got a parent， a
    child and a grandchild。 Okay。 Or the child could call fork and a loop。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，进程。好的，我们会讨论新的线程。所以我们刚刚创建的这个新进程，子进程运行着，恰好只有一个线程。我们会讨论如何创建更多线程。好的，子进程可以调用fork。所以在这里，子进程可以继续调用fork。现在我们有了父进程、子进程和孙子进程。好的，或者子进程可以调用fork并进入循环。
- en: And now you have a parent， a child and a bunch of grandchildren。 Okay。 So there
    are many ways to making， uh， yeah， while one fork。 Okay。 So that's a guaranteed
    crash of your machine。 Okay。 Um。 actually what will happen at some point is you'll
    probably exceed some， uh。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了父进程、子进程和一堆孙子进程。好的。所以有很多方式可以创建，嗯，是的，一个fork。好的。所以这将是你的机器的保证性崩溃。好的，嗯，实际上，到某个时候，可能会超出某些，嗯。
- en: number of processes that you're allowed。 Okay。 All right。 Um， and there is a
    limit。 Uh， okay。 So。 um， we're gonna， we're gonna end there， but I just wanted
    you to see。 So fork。 think of this as one way to get parallelism。 Okay。 And we'll
    talk a lot more about fork， uh。 next time and keep in mind that， there'll be many
    other ways to create parallelism。 All right。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你被允许创建的进程数量。好的，好的。嗯，是的，这里有一个限制。嗯，好吧。所以，我们要结束这部分内容了，但我只是想让你看到。想想fork，认为它是实现并行的一个方式。好的，我们下次会详细讨论fork，嗯。记住，将会有许多其他方式来创建并行。好的。
- en: So in conclusion， we talked a lot about processes this time。 Okay。 Address based
    with one or more threads is a process。 Uh， it owns the process owns its address
    space。 Inside that address space， what happens when you read or write the address
    12，468 could。 vary from every process。 Okay。 We'll get to that later。 The process
    owns its own file descriptors。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结一下，这次我们讨论了很多关于进程的内容。好的，基于地址并且有一个或多个线程的就是一个进程。嗯，它拥有自己的地址空间。在这个地址空间内，当你读取或写入地址12,468时，可能会因每个进程而异。好的，我们稍后会详细讨论。进程拥有自己的文件描述符。
- en: file system context and has one or more， threads。 We talked about how interrupts
    are hardware mechanism for gaining control from。 outside to run in the kernel。
    And it's a notification that events have happened where the big one is going to。
    be timers for us， but also IO like network and， and kernel or a network and disk。
    And we also talked， started talking about native control of processes。 We talked
    about fork， uh。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统上下文，并且有一个或多个线程。我们讨论了中断如何作为硬件机制从外部获取控制并进入内核。它是一个通知，表示事件已经发生，其中对我们来说重要的事件将是计时器，当然还有像网络和内核、网络和磁盘的IO。我们还讨论了，开始讨论了如何控制进程。我们谈到了fork，嗯。
- en: and we talked about exit and we'll get into exact and so on。 Uh， next time。
    so I'm going to leave you go because we're way over time， but I hope， you， uh。
    guys have a great evening and we'll see you later。 Bye。 Yeah。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了exit，并且我们会继续深入讨论exit等等。嗯，下次再说。所以我就让你们先走吧，因为时间已经超出了，但我希望你们，嗯，大家有一个愉快的晚上，我们下次见。再见。好的。
- en: '![](img/888f4959ddbb2f061b653e72a9b8e495_74.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f4959ddbb2f061b653e72a9b8e495_74.png)'
- en: '[BLANK_AUDIO]。'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[BLANK_AUDIO]。'
