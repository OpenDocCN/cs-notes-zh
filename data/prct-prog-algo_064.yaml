- en: 1.5 Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 输入和输出
- en: 原文：[https://introcs.cs.princeton.edu/python/15inout](https://introcs.cs.princeton.edu/python/15inout)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/15inout](https://introcs.cs.princeton.edu/python/15inout)
- en: In this section we extend the set of simple abstractions (command-line input
    and standard output) that we have been using as the interface between our Python
    programs and the outside world to include *standard input*, *standard draw*, and
    *standard audio*. Standard input makes it convenient for us to compose programs
    that process arbitrary amounts of input and to interact with our programs; standard
    draw makes it possible for us to work with graphics; and standard audio adds sound.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们扩展了我们一直在使用的简单抽象集合（命令行输入和标准输出），作为我们的 Python 程序与外部世界之间接口的一部分，包括*标准输入*、*标准绘图*和*标准音频*。标准输入使我们能够方便地组合处理任意数量的输入的程序，并与我们的程序进行交互；标准绘图使我们能够处理图形；标准音频添加了声音。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Bird's-Eye View
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸟瞰
- en: '![Bird''s eye view](../Images/dd46b13eb4b28374035e202c88fb90fa.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![鸟瞰](../Images/dd46b13eb4b28374035e202c88fb90fa.png)'
- en: The Python programs that we've seen so far take input values from the command
    line and write a string of characters as output. By default, both command-line
    input and the output written by the programs are associated with the application
    running on your computer that accepts commands (that is, the application in which
    you have been typing `python` commands). We use the generic term *terminal window*
    to refer to that application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的 Python 程序从命令行获取输入值，并将一串字符作为输出。默认情况下，命令行输入和程序写入的输出都与在您的计算机上运行的接受命令的应用程序相关联（也就是说，您一直在其中输入
    `python` 命令的应用程序）。我们使用通用术语*终端窗口*来指代该应用程序。
- en: 'So far the Python programs that we''ve seen have used:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的 Python 程序已经使用了：
- en: '*Command-line input.* Any Python program can access an array of strings referenced
    by `sys.argv`. That array contains the sequence of command-line arguments that
    we type, provided to Python by the operating system. By convention, both Python
    and the operating system process the arguments as strings, so if we intend for
    a command-line argument to be a number, we use a conversion function such as `int()`
    or `float()` to convert it from a string to the appropriate type.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令行输入。* 任何 Python 程序都可以访问由 `sys.argv` 引用的字符串数组。该数组包含我们键入的命令行参数序列，由操���系统提供给
    Python。按照惯例，Python 和操作系统都将参数作为字符串处理，因此如果我们打算将命令行参数作为数字处理，我们使用转换函数如 `int()` 或 `float()`
    将其从字符串转换为适当的类型。'
- en: '*Standard output.* To write output values, we have been using the functions
    `stdio.write()` and `stdio.writeln()`. When a program calls those functions, Python
    puts the results in the form of an abstract stream of characters known as *standard
    output*. By default, the operating system connects standard output to the terminal
    window. All of the output in our programs so far has appeared in the terminal
    window.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准输出。* 为了写入输出值，我们一直在使用函数 `stdio.write()` 和 `stdio.writeln()`。当程序调用这些函数时，Python
    将结果以一种称为*标准输出*的抽象字符流的形式放置。默认情况下，操作系统将标准输出连接到终端窗口。到目前为止，我们程序中的所有输出都出现在终端窗口中。'
- en: The program [randomseq.py](randomseq.py.html) uses this model. It takes an integer
    command-line argument `n` and writes to standard output a sequence of `n` random
    numbers between 0 and 1, possibly including 0.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 [randomseq.py](randomseq.py.html) 使用了这个模型。它接受一个整数命令行参数 `n`，并向标准输出写入一个介于 0
    和 1 之间的 `n` 个随机数序列，可能包括 0。
- en: 'To complete our programming model, we add the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的编程模型，我们添加以下内容：
- en: '*Standard input.* The booksite `stdio.py` module defines several functions
    in addition to `write()` and `writeln()`. Those additional functions implement
    a standard input abstraction to complement the standard output abstraction. That
    is, the `stdio` module contains functions that allow your programs to *read* from
    standard input. Just as a program can write to standard output at any time, a
    program can read from standard input at any time.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准输入。* 书站 `stdio.py` 模块定义了除了 `write()` 和 `writeln()` 之外的几个函数。这些额外的函数实现了一个标准输入抽象，以补充标准输出抽象。也就是说，`stdio`
    模块包含了允许你的程序从标准输入中*读取*的函数。就像一个程序可以随时写入标准输出一样，一个程序也可以随时从标准输入中读取。'
- en: '*Standard draw.* The booksite `stddraw` module allows your programs to create
    and write drawings. It implements a simple graphics model that allows your programs
    to create and write points, lines, and geometric shapes in a window on your computer.
    `stddraw` also implements features for animation.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准绘图。* 书站 `stddraw` 模块允许你的程序创建和绘制图形。它实现了一个简单的图形模型，允许你的程序在计算机窗口中创建和绘制点、线条和几何形状。`stddraw`
    还实现了动画功能。'
- en: '*Standard audio.* The booksite `stdaudio` module allows your programs to create
    and play sound. It uses a standard format to convert arrays of floats into sound.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准音频。* 书站 `stdaudio` 模块允许你的程序创建和播放声音。它使用标准格式将浮点数组转换为声音。'
- en: '* * *'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Output
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输出
- en: 'This is the API of the part of the `stdio.py` module that is relevant to standard
    output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与标准输出相关的 `stdio.py` 模块部分的 API：
- en: '![API for booksite functions related to standard output](../Images/4d3cc1fd9d6b3d4a79a15ca6b7bcb80b.png)'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![与标准输出相关的书站功能的API](../Images/4d3cc1fd9d6b3d4a79a15ca6b7bcb80b.png)'
- en: The `stdio.writeln()` and `stdio.write()` functions are the ones that you have
    been using. The `stdio.writef()` function gives you more control over the appearance
    of the output, and deserves some explanation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writeln()` 和 `stdio.write()` 函数是你一直在使用的。`stdio.writef()` 函数让你对输出的外观有更多控制，并值得一些解释。'
- en: Formatted writing basics.
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化写入基础知识。
- en: 'The simplest kind of call of `stdio.writef()` passes only one argument; that
    argument should be a string. In that case `stdio.writef()` simply writes the string
    to standard output, and so is equivalent to `stdio.write()`. A more common call
    of `stdio.writef()` passes two arguments. In that context the first argument is
    called the *format string*. It contains a *conversion specification* that that
    describes how the second argument is to be converted to a string for output. A
    conversion specification has the form `%w.pc`, where:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 的最简单的调用只传递一个参数；该参数应为字符串。在这种情况下，`stdio.writef()` 简单地将字符串写入标准输出，因此等同于
    `stdio.write()`。`stdio.writef()` 的更常见的调用传递两个参数。在这种情况下，第一个参数称为*格式字符串*。它包含一个*转换说明*，描述了第二个参数如何转换为输出的字符串。转换说明的形式为
    `%w.pc`，其中：'
- en: '![Anatomy of a formatted write statement](../Images/55ee8ae35a4c1bdab5424e78e67fe836.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![格式化写语句的解剖](../Images/55ee8ae35a4c1bdab5424e78e67fe836.png)'
- en: '`w` is the *field width*. The field width is the number of characters that
    should be written. A negative field width indicates that the output should be
    padded with spaces on the right.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` 是*字段宽度*。字段宽度是应该写入的字符数。负的字段宽度表示输出应在右侧填充空格。'
- en: '`p` is the *precision*. For floats, the precision is the number of digits that
    should be written after the decimal point. For strings, the precision is the number
    of characters of the string that should be written.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` 是*精度*。对于浮点数，精度是小数点后应写入的数字位数。对于字符串，精度是应写入的字符串的字符数。'
- en: '`c` is the *conversion code*. The conversion code should be `d` when writing
    an integer, `f` or `e` when writing a float, and `s` when writing a string.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` 是*转换代码*。当写入整数时，转换代码应为 `d`，当写入浮点数时，应为 `f` 或 `e`，当写入字符串时，应为 `s`。'
- en: '![Writef format conventions](../Images/e3a6862062f278cd1a856a2dbb47c9c9.png)'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Writef 格式约定](../Images/e3a6862062f278cd1a856a2dbb47c9c9.png)'
- en: The `stdio.writef()` function can take more than two arguments. In that case,
    the format string will have a format specifier for each argument, perhaps separated
    by other characters to pass through to the output.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 函数可以接受多于两个参数。在这种情况下，格式字符串将为每个参数都有一个格式说明符，可能由其他字符分隔以传递到输出。'
- en: Any part of the format string that is not a conversion specification is simply
    passed through to the output. For example, the statement
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串中任何不是转换说明的部分都会简单地传递到输出。例如，语句
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: writes the line
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 写入行
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Multiple arguments.
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个参数。
- en: The `stdio.writef()` function can take more than two arguments. In this case,
    the format string will have a conversion specification for each argument, perhaps
    separated by other characters to pass through to the output.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 函数可以接受多于两个参数。在这种情况下，格式字符串将为每个参数都有一个转换说明，可能由其他字符分隔以传递到输出。'
- en: Formatted writing implementation.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化写入的实现。
- en: Internally the `stdio.writef()` function uses the `%` operator. Specifically,
    a function call of the form `stdio.writef(*formatString*, *value*)` internally
    is implemented using an expression of the form `*formatString* % *value*`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 函数内部使用了 `%` 运算符。具体来说，形如 `stdio.writef(*formatString*, *value*)`
    的函数调用在内部使用了形如 `*formatString* % *value*` 的表达式。'
- en: As you know, the `%` operator in an expression of the form `*integer* % *integer*`
    means "compute the remainder". A `%` operator in an expresson of the form `*formatString*
    % *value*` means convert `*value*` to a string as directed by `*formatString*`.
    The [Python documentation for string formatting operations](http://docs.python.org/library/stdtypes.html#string-formatting)
    describes the `%` operator thoroughly. Thereby, indirectly, it describes the `stdio.writef()`
    function thoroughly as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，表达式 `*integer* % *integer*` 中的 `%` 运算符表示“计算余数”。表达式 `*formatString* % *value*`
    中的 `%` 运算符表示根据 `*formatString*` 的指示将 `*value*` 转换为字符串。[Python 字符串格式化操作的文档](http://docs.python.org/library/stdtypes.html#string-formatting)详细描述了
    `%` 运算符。因此，间接地，它也详细描述了 `stdio.writef()` 函数。
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Input
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输入
- en: 'Our `stdio.py` module supports standard input, an abstract data stream that
    may be empty or can contain a sequence of values separated by white space. Each
    value is a string or a value of one of Python''s primitive types. One of the key
    features of the standard input stream is that your program *consumes* values when
    it reads them. Once your program has read a value, it cannot back up and read
    it again. This is the part of the `stdio` module that is relevant to standard
    input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `stdio.py` 模块支持标准输入，这是一个可能为空或包含一系列由空格分隔的值的抽象数据流。每个值都是一个字符串或 Python 的原始类型之一。标准输入流的一个关键特点是，当程序读取值时，程序会*消耗*这些值。一旦程序读取了一个值，它就不能回退并再次读取。这是与标准输入相关的
    `stdio` 模块的一部分：
- en: '![API for booksite functions related to standard input](../Images/f2bceb0ae2f3601dbc989095dedf2117.png)'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![与标准输入相关的 booksite 函数的 API](../Images/f2bceb0ae2f3601dbc989095dedf2117.png)'
- en: 'These functions fall into one of three categories: those for reading individual
    tokens, one at a time, and converting each to an integer, float, boolean or string;
    those for reading lines from standard input, one at a time; and those for reading
    a sequence of values of the same type (returning the values in an array). Generally,
    it is best not to mix functions from the different categories in the same program.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数分为三类：逐个读取单个标记并将每个标记转换为整数、浮点数、布尔值或字符串的函数；逐行从标准输入读取行的函数；以及读取相同类型值序列的函数（将值返回为数组）。通常最好不要在同一个程序中混合来自不同类别的函数。
- en: We now consider a few example programs that illustrate how to use standard input.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑一些示例程序，演示如何使用标准输入。
- en: '![Anatomy of a command](../Images/bd03485a2948affc7ed29326a1e79038.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![命令的解剖](../Images/bd03485a2948affc7ed29326a1e79038.png)'
- en: Typing input.
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入输入。
- en: The program [addints.py](addints.py.html) accepts a command-line argument `n`.
    Then it reads `n` numbers from standard input, computes their sum, and writes
    the sum to standard output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[addints.py](addints.py.html)接受一个命令行参数 `n`。然后它从标准输入读取 `n` 个数字，计算它们的总和，并将总和写入标准输出。
- en: 'When you use the `python` command to run a Python program from the command
    line, you actually are doing three things: (i) issuing a command to start executing
    your program, (ii) specifying the values of the command-line arguments, and (iii)
    beginning to define the standard input stream. The string of characters that you
    type in the terminal window after the command line is the standard input stream.
    When you type characters, you are interacting with your program. The program *waits*
    for you to create the standard input stream.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`python`命令从命令行运行Python程序时，实际上您正在做三件事：（i）发出命令开始执行您的程序，（ii）指定命令行参数的值，以及（iii）开始定义标准输入流。在命令行之后在终端窗口中键入的字符序列是标准输入流。当您输入字符时，您正在与您的程序交互。程序*等待*您创建标准输入流。
- en: 'When you type `python addints.py`, after accepting the command-line argument
    the program calls `stdio.readInt()` and waits for you to type an integer. Suppose
    that you want `144` to be the first input: as you type `1`, then `4`, and then
    `4`, nothing happens, because `stdio` does not know that you are done typing the
    integer, but when you then type `<return>` to signify the end of your integer,
    `stdio.readInt()` immediately returns the value 144\. After you have typed four
    numbers in this way, the program expects no more input and writes the sum to standard
    output, as desired.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入`python addints.py`时，在接受命令行参数后，程序调用`stdio.readInt()`并等待您输入一个整数。假设您希望`144`是第一个输入���当您输入`1`，然后`4`，然后`4`时，什么也不会发生，因为`stdio`不知道您何时完成输入整数，但当您输入`<return>`表示您的整数结束时，`stdio.readInt()`立即返回值144。在这种方式输入四个数字后，程序不再期望更多输入，并将总和写入标准输出，如所需。
- en: If you type `abc` or `12.2` or `True` when `stdio.readInt()` is expecting an
    integer, then it will respond with a `ValueError`. The format for each type is
    the same as you have been using for literal values within Python programs. `stdio`
    treats strings of consecutive whitespace characters as identical to one space
    and allows you to delimit your numbers with such strings. It doesn't matter how
    many spaces you put between numbers, whether you enter numbers on one line or
    separate them with tab characters or spread them out over several lines, (except
    that your terminal application processes standard input one line at a time, so
    it will wait until you type `<return>` before sending all of the numbers on that
    line to standard input). You can mix values of different types in an input stream,
    but each time that the program expects a value of a particular type, there needs
    to be a value of that type in the input stream.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`stdio.readInt()`期望整数时输入`abc`、`12.2`或`True`，那么它将返回`ValueError`。每种类型的格式与您在Python程序中使用的文字值的格式相同。`stdio`将连续的空白字符字符串视为一个空格，并允许您用这些字符串来分隔数字。无论您在数字之间放置多少空格，无论您是在一行上输入数字还是用制表符分隔它们或者将它们分散在几行上（除了您的终端应用程序一次处理标准输入一行，因此它将等到您输入`<return>`后才将该行上的所有数字发送到标准输入）。您可以在输入流中混合不同类型的值，但每次程序期望特定类型的值时，输入流中都需要有该类型的值。
- en: Interactive user input.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式用户输入。
- en: The program [twentyquestions.py](twentyquestions.py.html) plays a simple guessing
    game. You type numbers, each of which is an implicit question (*Is this the number?*)
    and the program tells you whether your guess is too high or too low.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[twentyquestions.py](twentyquestions.py.html)玩一个简单的猜谜游戏。您输入数字，每个数字都是一个隐式问题（*这是数字吗？*），程序会告诉您您的猜测是太高还是太低。
- en: That program illustrates interactive user input. That is, it illustrates that
    a program can interleave writing to standard output and reading from standard
    input, thereby interacting with the user during program execution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序说明了交互式用户输入。也就是说，它说明了程序可以交替写入标准输出和从标准输入读取，从而在程序执行期间与用户交互。
- en: Processing an arbitrary-size input stream
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理任意大小的输入流
- en: The program [average.py](average.py.html) reads a sequence of floats from standard
    input and writes their average to standard output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[average.py](average.py.html)从标准输入读取一系列浮点数，并将它们的平均值写入标准输出。
- en: 'Typically, input streams are finite: your program marches through the input
    stream, consuming values until the stream is empty. But there is no restriction
    on the size of the input stream. That program illustrates a key property of using
    an input stream: the length of the stream is not known to the program. We type
    all the numbers that we have, then the program averages them. Before reading each
    number, the program calls `stdio.isEmpty()` to check whether there are any more
    numbers in standard input.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，输入流是有限的：您的程序遍历输入流，消耗值直到流为空。但是输入流的大小没有限制。该程序说明了使用输入流的一个关键特性：程序不知道流的长度。我们输入所有的数字，然后程序对它们求平均值。在读取每个数字之前，程序调用`stdio.isEmpty()`来检查标准输入中是否还有更多数字。
- en: How do you signal that we have no more data to type? By convention, we type
    a special sequence of characters known as the *end-of-file sequence*. It is `<ctrl-d>`
    on OS X and Linux, and it is `<ctrl-z>` on Windows. On some systems the end-of-file
    sequence must appear on its own line. Typing the end-of-file sequence indicates
    that standard input is empty.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有更多数据可输入时，如何发出信号？按照惯例，我们输入一系列特殊字符，称为*文件结尾序列*。在OS X和Linux上是`<ctrl-d>`，在Windows上是`<ctrl-z>`。在某些系统上，文件结尾序列必须单独出现在一行上。输入文件结尾序列表示标准输入为空。
- en: '* * *'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Redirection and Piping
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向和管道
- en: For many applications, typing input data as a standard input stream from the
    terminal window is untenable because doing so limits our program's processing
    power by the amount of data that we can type. Similarly, we often want to save
    the information printed on the standard output stream for later use. We can use
    operating system mechanisms to address both issues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，从终端窗口将输入数据作为标准输入流输入是不可行的，因为这样做会限制我们程序的处理能力，限制了我们可以输入的数据量。同样，我们经常希望保存标准输出流上打印的信息以供以后使用。我们可以使用操作系统机制来解决这两个问题。
- en: Redirecting standard output to a file.
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将标准输出重定向到文件。
- en: 'By adding a simple directive to the command that invokes a program, we can
    *redirect* its standard output to a file, for permanent storage or for input to
    some other program at a later time. For example, the command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向调用程序的命令添加一个简单的指令，我们可以*重定向*其标准输出到文件，以便永久存储或在以后的某个时间输入到其他程序中。例如，命令：
- en: '![Redirecting standard output to a file](../Images/f81ee3a0c1f7cb00a518882b6eb2129f.png)'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![将标准输出管道到文件](../Images/f81ee3a0c1f7cb00a518882b6eb2129f.png)'
- en: 'specifies that the standard output stream is not to be written in the terminal
    window, but instead is to be written to a text file named `data.txt`. Each call
    to `stdio.write()` or `stdio.writeln()` appends text at the end of that file.
    In this example, the end result is a file that contains 1,000 random values. No
    output appears in the terminal window: it goes directly into the file named after
    the `>` symbol. Thus, we can save away information for later retrieval.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了标准输出流不写入终端窗口，而是写入名为`data.txt`的文本文件。每次调用`stdio.write()`或`stdio.writeln()`都会将文本追加到该文件的末尾。在这个例子中，最终结果是一个包含1,000个随机值的文件。终端窗口中不会显示任何输出：它直接进入以`>`符号命名的文件中。因此，我们可以保存信息以供以后检索。
- en: Redirecting standard input from a file.
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件重定向标准输入。
- en: 'Similarly, we can redirect standard input so that a program reads data from
    a file instead of the terminal application. For example, the command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以重定向标准输入，使程序从文件而不是终端应用程序读取数据。例如，命令：
- en: '![Redirecting from a file to standard input](../Images/74a02d6b2dadb77d21cf7da32b14f8de.png)'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![从文件重定向到标准输入](../Images/74a02d6b2dadb77d21cf7da32b14f8de.png)'
- en: reads a sequence of numbers from the file `data.txt`, computes their average,
    and writes the average to standard output. Specifically, the `<` symbol is a directive
    to implement the standard input stream by reading from the file `data.txt` instead
    of by waiting for the user to type something into the terminal window. When the
    program calls `stdio.readFloat()`, the operating system reads the value from the
    file. This facility to redirect standard input from a file enables us to process
    huge amounts of data from any source with our programs, limited only by the size
    of the files that we can store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件`data.txt`读取一系列数字，计算它们的平均值，并将平均值写入标准输出。具体来说，`<`符号是一个指令，通过从文件`data.txt`而不是等待用户在终端窗口中键入来实现标准输入流。当程序调用`stdio.readFloat()`时，操作系统从文件中读取值。这种从文件重定向标准输入的功能使我们能够处理来自任何来源的大量数据，仅受我们可以存储的文件大小限制。
- en: Connecting two programs.
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接两个程序。
- en: 'The most flexible way to implement the standard input and standard output abstractions
    is to specify that they are implemented by our own programs! This mechanism is
    called *piping*. For example, the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实现标准输入和标准输出抽象的最灵活方式是指定它们由我们自己的程序实现！这种机制称为*piping*。例如，以下命令：
- en: '![Piping the output of one program to the input of another](../Images/f7463e2a5da03bcb35a2c2953764a00a.png)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![将一个程序的输出管道到另一个程序的输入](../Images/f7463e2a5da03bcb35a2c2953764a00a.png)'
- en: 'specifies that the standard output stream for [randomseq.py](randomseq.py.html)
    and the standard input stream for [average.py](average.py.html) are the *same*
    stream. That is, the result has the same effect as the following sequence of commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了[随机序列.py](randomseq.py.html)的标准输出流和[平均值.py](average.py.html)的标准输入流是*相同*的流。也就是说，结果与以下命令序列具有相同效果：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: but the file `data.txt` is not needed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但文件`data.txt`是不需要的。
- en: Filters.
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器。
- en: For many common tasks, it is convenient to think of each program as a filter
    that converts a standard input stream to a standard output stream in some way,
    with piping as the command mechanism to connect programs together. For example,
    [rangefilter.py](rangefilter.py.html) takes two command-line arguments and writes
    to standard output those numbers from standard input that fall within the specified
    range.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多常见任务，将每个程序视为以某种方式将标准输入流转换为标准输出流的过滤器，并使用管道作为连接程序的命令机制是方便的。例如，[范围过滤器.py](rangefilter.py.html)接受两个命令行参数，并将标准输入中落在指定范围内的数字写入标准输出。
- en: 'Several standard filters that were designed for Unix still survive (sometimes
    with different names) as commands in modern operating systems. For example, the
    `sort` filter reads the lines from standard input and writes them to standard
    output in sorted order:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些为Unix设计的标准过滤器仍然存在（有时使用不同的名称）作为现代操作系统中的命令。例如，`sort`过滤器从标准输入读取行并按排序顺序写入标准输出：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another useful filter is `more`, which reads data from standard input and displays
    it in your terminal window one screenful at a time. For example, if you type
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的过滤器是`more`，它从标准输入读取数据，并在您的终端窗口中一次显示一个屏幕。例如，如果您键入
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: you will see as many numbers as fit in your terminal window, but more will wait
    for you to hit the space bar before displaying each succeeding screenful.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端窗口中看到尽可能多的数字，但更多的数字将等待您按空格键，然后显示每个后续屏幕。
- en: '* * *'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Drawing
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准绘图
- en: 'Now we introduce an abstraction for producing drawings as output. We imagine
    an abstract drawing device capable of drawing lines and points on a two-dimensional
    "canvas" and then displaying that canvas on your screen in the standard drawing
    window. The device is capable of responding to the commands that our programs
    issue in the form of calls to functions in the `stddraw` module. The module''s
    API consists of two kinds of functions: drawing functions that cause the device
    to take an action (such as drawing a line or drawing a point) and control functions
    that control how the drawing is shown and set parameters such as the pen size
    or the coordinate scales.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍一个用于生成绘图输出的抽象。我们想象一个抽象的绘图设备，能够在二维“画布”上绘制线条和点，然后在标准绘图窗口中显示该画布在您的屏幕上。该设备能够响应我们程序发出的命令，形式为对`stddraw`模块中函数的调用。该模块的API由两种函数组成：绘图函数会导致设备执行动作（如绘制线条或绘制点），控制函数控制绘图的显示方式并设置参数，如笔的大小或坐标比例。
- en: Creating drawings.
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建绘图。
- en: 'The basic functions for drawing are described in this API:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图的基本函数在此 API 中描述：
- en: '![Stddraw drawing functions](../Images/be5a9d719c6cd328aed3a7d9cacd0406.png)'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw 绘图函数](../Images/be5a9d719c6cd328aed3a7d9cacd0406.png)'
- en: 'The drawing functions are nearly self-documenting: `stddraw.line()` draws a
    straight line segment connecting two points whose coordinates are given as arguments
    and `stddraw.point()` draws a dot centered at the given coordinates. The default
    coordinate scale is the unit square (all coordinates between 0 and 1). The point
    (0.0, 0.0) is at the lower left, and the point (1.0, 1.0) is at the upper right
    — thus corresponding to the first quadrant of the familiar Cartesian coordinate
    system. The default settings draw black lines and black points on a white background.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图函数几乎是自解释的：`stddraw.line()` 以给定参数作为坐标绘制连接两点的直线段，`stddraw.point()` 在给定坐标处绘制一个以该坐标为中心的点。默认坐标比例是单位正方形（所有坐标在
    0 到 1 之间）。点 (0.0, 0.0) 在左下角，点 (1.0, 1.0) 在右上角 — 因此对应于熟悉的笛卡尔坐标系的第一象限。默认设置在白色背景上绘制黑色线条和黑色点。
- en: The control function stddraw.show() needs a bit more explanation. When your
    program calls any drawing function such as `stddraw.line()` or `stddraw.point()`,
    `stddraw` uses an abstraction known as the *background canvas*. The background
    canvas is not displayed; it exists only in computer memory. All points, lines,
    and so forth are drawn on the background canvas, not directly in the standard
    drawing window. Only when you call `stddraw.show()` does your drawing get copied
    from the background canvas to the standard drawing window, where it is displayed
    until the user closes the standard drawing window — typically by clicking on the
    *Close* button in the window's title bar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 控制函数 `stddraw.show()` 需要更多解释。当您的程序调用任何绘图函数，如 `stddraw.line()` 或 `stddraw.point()`
    时，`stddraw` 使用一种称为*背景画布*的抽象。背景画布不会显示；它只存在于计算机内存中。所有点、线条等都是在背景画布上绘制的，而不是直接在标准绘图窗口中。只有当您调用
    `stddraw.show()` 时，您的绘图才会从背景画布复制到标准绘图窗口中，在那里显示，直到用户关闭标准绘图窗口 — 通常通过单击窗口标题栏中的 *关闭*
    按钮。
- en: Why does `stddraw` need to use a background canvas? The main reason is that
    use of two canvases instead of one makes the `stddraw` module more efficient.
    Incrementally displaying a complex drawing as it is being created can be intolerably
    inefficient on many computer systems. In computer graphics, this technique is
    known as *double buffering*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `stddraw` 需要使用背景画布？主要原因是使用两个画布而不是一个使 `stddraw` 模块更有效率。在许多计算机系统上，逐步显示正在创建的复杂图形可能效率低下。在计算机图形中，这种技术称为*双缓冲*。
- en: 'To summarize the information that you need to know, a typical program using
    the stddraw module has this structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结您需要了解的信息，使用 stddraw 模块的典型程序具有以下结构：
- en: Import the `stddraw` module.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 `stddraw` 模块。
- en: Call drawing functions such as `stddraw.line()` and `stddraw.point()` to create
    a drawing on the background canvas.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用诸如 `stddraw.line()` 和 `stddraw.point()` 等绘图函数在背景画布上创建绘图。
- en: Call `stddraw.show()` to show the background canvas in the standard drawing
    window and wait until the window is closed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `stddraw.show()` 来显示标准绘图窗口中的背景画布，并等待窗口关闭。
- en: Your first drawing.
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的第一个绘图。
- en: The "Hello, World" equivalent for graphics programming with `stddraw` is to
    draw a triangle with a point inside. To form the triangle, we draw three lines.
    The program [triangle.py](triangle.py.html) is the full program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `stddraw` 进行图形编程的“Hello, World”等价物是绘制一个带有内部点的三角形。为了形成三角形，我们绘制三条线。程序 [triangle.py](triangle.py.html)
    是完整的程序。
- en: Saving a drawing.
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存绘图。
- en: You can save the standard drawing window canvas to a file. To do so, right-click
    anywhere on the window canvas. After you do that, `stddraw` displays a file dialog
    box which allows you to specify a file name. Then, after you type a file name
    into the dialog box and click the *Save* button, `stddraw` saves the window canvas
    to a file with the specified name. The file name must end with either `.jpg` (to
    save the window canvas in JPEG format) or `.png` (to save the window canvas in
    "Portable Network Graphics" format). The drawings generated by the graphics programs
    shown in this chapter were saved to files using this mechanism.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将标准绘图窗口画布保存到文件中。要这样做，请在窗口画布的任何位置右键单击。这样做后，`stddraw` 将显示一个文件对话框，允许您指定文件名。然后，在对话框中输入文件名并单击
    *保存* 按钮后，`stddraw` 将窗口画布保存到指定名称的文件中。文件名必须以 `.jpg` 结尾（以 JPEG 格式保存窗口画布）或 `.png`
    结尾（以“便携式网络图形”格式保存窗口画布）。本章中显示的图形程序生成的图形是使用此机制保存到文件中的。
- en: Control commands.
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制命令。
- en: 'The default coordinate system for standard drawing is the unit square, but
    we often want to draw plots at different scales. Also, we often want to draw lines
    of different thickness and points of different size from the standard. To accommodate
    these needs, stddraw has these functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 标准绘图的默认坐标系是单位正方形，但我们经常希望以不同比例绘制图形。此外，我们经常希望绘制不同粗细的线条和不同大小的点。为了满足这些需求，stddraw
    提供了以下函数：
- en: '![Stddraw control functions](../Images/e5e583116f3a4614dd9b0fd91344160b.png)'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw 控制函数](../Images/e5e583116f3a4614dd9b0fd91344160b.png)'
- en: For example, when you call the function `stddraw.setXscale(0, n)`, you are telling
    the drawing device that you will be using x-coordinates between 0 and `n`. Note
    that the two-call sequence
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您调用函数 `stddraw.setXscale(0, n)` 时，您告诉绘图设备您将使用 0 到 `n` 之间的 x 坐标。请注意，两次调用序列
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: sets the drawing coordinates to be within a bounding box whose lower-left corner
    is at (`x0`, `y0`) and whose upper-right corner is at (`x1`, `y1`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将绘图坐标设置为一个边界框，其左下角在 (`x0`, `y0`) 处，右上角在 (`x1`, `y1`) 处。
- en: Filtering data to a standard drawing.
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据过滤到标准绘图。
- en: The program [plotfilter.py](plotfilter.py.html) reads a sequence of points defined
    by (*x*, *y*) coordinates and draws a spot at each point. It adopts the convention
    that the first four numbers read from standard input specify the bounding box,
    so that it can scale the plot. Try running it with its standard input redirected
    to [usa.txt](usa.txt).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[plotfilter.py](plotfilter.py.html)读取由(*x*, *y*)坐标定义的一系列点，并在每个点处绘制一个点。它采用的约定是从标准输入读取的前四个数字指定了边界框，以便它可以缩放绘图。尝试将其标准输入重定向到[usa.txt](usa.txt)运行。
- en: '![Plot Filter](../Images/caafbb4c33928ae3857b4b8320ac0ac2.png)'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![绘图滤镜](../Images/caafbb4c33928ae3857b4b8320ac0ac2.png)'
- en: Plotting a function graph.
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制函数图。
- en: The program functiongraph.py plots the function *y* = sin(4*x*) + sin(20*x*)
    in the interval (0, π). There are an infinite number of points in the interval,
    so we have to make do with evaluating the function at a finite number of points
    within the interval. We sample the function by choosing a set of *x* values, then
    computing *y* values by evaluating the function at each *x* value. Plotting the
    function by connecting successive points with lines produces what is known as
    a *piece-wise linear approximation*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 程序functiongraph.py在区间(0, π)中绘制函数*y* = sin(4*x*) + sin(20*x*)。在区间中有无限多个点，所以我们必须通过在区间内的有限数量的点评估函数来处理。我们通过选择一组*x*值来对函数进行采样，然后通过在每个*x*值处评估函数来计算*y*值。通过连接连续点以线条绘制函数产生了所谓的*分段线性逼近*。
- en: '![Function Graph](../Images/dd040dd9c16597b9b779dbf8a70f3e7c.png)'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![函数图](../Images/dd040dd9c16597b9b779dbf8a70f3e7c.png)'
- en: Outline and filled shapes.
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮廓和填充形状。
- en: 'The `stddraw` module also includes functions to draw circles, rectangles, and
    arbitrary polygons. Each shape defines an outline. When the function name is just
    the shape name, that outline is traced by the drawing pen. When the name begins
    with `filled`, the named shape is instead filled solid, not traced. As usual,
    we summarize the available functions in an API:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`stddraw`模块还包括用于绘制圆、矩形和任意多边形的函数。每个形状定义一个轮廓。当函数名只是形状名时，轮廓由绘图笔描绘。当名称以`filled`开头时，命名的形状实际上是填充的实心形状，而不是描绘的。通常情况下，我们在API中总结可用的函数：'
- en: '![Stddraw Shape Functions](../Images/be276ec307cada3f34b601e536cffd55.png)'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw形状函数](../Images/be276ec307cada3f34b601e536cffd55.png)'
- en: The arguments for `stddraw.circle()` define a circle of radius `r` centered
    at (`x`, `y`); the arguments for `stddraw.square()` define a square of side length
    2`r` centered at (`x`, `y`); and the arguments for `stddraw.polygon()` define
    a sequence of points that we connect by lines, including one from the last point
    to the first point.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`stddraw.circle()`的参数定义了以(`x`, `y`)为中心的半径为`r`的圆；`stddraw.square()`的参数定义了以(`x`,
    `y`)为中心的边长为2`r`的正方形；`stddraw.polygon()`的参数定义了我们通过线连接的一系列点，包括从最后一个点到第一个点的线。 '
- en: Text and color.
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本和颜色。
- en: To annotate or highlight various elements in your drawings, `stddraw` includes
    methods for drawing text, setting the font, and setting the the ink in the pen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注释或突出显示绘图中的各种元素，`stddraw`包括用于绘制文本、设置字体和设置笔墨水的方法。
- en: '![Stddraw Text and Color Functions](../Images/c545ee1ca12c634b0995ddaccf4c392f.png)'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw文本和颜色函数](../Images/c545ee1ca12c634b0995ddaccf4c392f.png)'
- en: In this code, color and fonts use types that you will learn about in Section
    3.1\. Until then, we leave the details to `stddraw`. The available pen colors
    are `BLACK`, `BLUE`, `CYAN`, `DARK_GRAY`, `GRAY`, `GREEN`, `LIGHT_GRAY`, `MAGENTA`,
    `ORANGE`, `PINK`, `RED`, `WHITE`, and `YELLOW`, defined as constants within `stddraw`.
    For example, the call `stddraw.setPenColor(stddraw.GRAY)` changes to gray ink.
    The default ink color is black; the default font is a 12-point plain Helvetica
    font.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，颜色和字体使用的类型将在第3.1节中学习。在那之前，我们将细节留给`stddraw`。可用的笔颜色是`BLACK`、`BLUE`、`CYAN`、`DARK_GRAY`、`GRAY`、`GREEN`、`LIGHT_GRAY`、`MAGENTA`、`ORANGE`、`PINK`、`RED`、`WHITE`和`YELLOW`，这些都是在`stddraw`中定义的常量。例如，调用`stddraw.setPenColor(stddraw.GRAY)`会更改为灰色墨水。默认墨水颜色是黑色；默认字体是12点普通Helvetica字体。
- en: 'These code fragments illustrate some stddraw functions for drawing shapes and
    text:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码片段展示了一些用于绘制形状和文本的stddraw函数：
- en: '![Stddraw Examples](../Images/333b2b1ca409cb9834444047a33e2e93.png)'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw示例](../Images/333b2b1ca409cb9834444047a33e2e93.png)'
- en: Animation
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画
- en: 'If we provide an argument to `stddraw.show()`, then that call need not be the
    last action of a program: it will copy the background canvas to the standard drawing
    window and then wait for the specified number of milliseconds. As you will soon
    see, we can use this capability (coupled with the ability to erase, or clear the
    background canvas) to produce the effect of motion in the `stddraw` window.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`stddraw.show()`提供参数，则该调用不需要是程序的最后一个动作：它将将背景画布复制到标准绘图窗口，然后等待指定的毫秒数。很快你会看到，我们可以利用这种能力（结合擦除或清除背景画布的能力）在`stddraw`窗口中产生运动效果。
- en: '![Stddraw Animation Functions](../Images/3ee86ef42aaba67179cd0e380b5338ef.png)'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw动画函数](../Images/3ee86ef42aaba67179cd0e380b5338ef.png)'
- en: 'The "Hello, World" program for animation is to produce a black ball that appears
    to move around on the canvas. Suppose that the ball is at position (*r[x]* , *r[y]*)
    and we want to create the impression of moving it to a new position nearby, such
    as, for example, (*r[x]* + 0.01, *r[y]* + 0.02). We do so in three steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的“Hello, World”程序是在画布上产生一个黑色球，看起来在画布上移动。假设球在位置(*r[x]*，*r[y]*)，我们想要给人一种将其移动到附近新位置的印象，例如，例如，(*r[x]*
    + 0.01, *r[y]* + 0.02)。我们分三步进行：
- en: Clear the background canvas.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除背景画布。
- en: Draw a black ball at the new position.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新位置绘制一个黑色球。
- en: Show the drawing and wait for a short while.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示绘图并等待片刻。
- en: To create the illusion of movement, we iterate these steps for a whole sequence
    of positions (one that will form a straight line, in this case). The argument
    to `stddraw.show()` quantifies "a short while" and controls the apparent speed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了营造运动的错觉，我们对一整个位置序列（在这种情况下将形成一条直线）进行迭代这些步骤。`stddraw.show()`的参数量化了“短暂的时间”，控制了视觉速度。
- en: 'The program [bouncingball.py](bouncingball.py.html) implements these steps
    to create the illusion of a ball moving in the 2-by-2 box centered at the origin.
    The current position of the ball is (*r[x]* , *r[y]*), and we compute the new
    position at each step by adding *v[x]* to *r[x]* and *v[y]* to *r[y]*. Since (*v[x]*
    , *v[y]*) is the fixed distance that the ball moves in each time unit, it represents
    the velocity. To keep the ball in the drawing, we simulate the effect of the ball
    bouncing off the walls according to the laws of elastic collision. This effect
    is easy to implement: when the ball hits a vertical wall, we just change the velocity
    in the *x*-direction from *v[x]* to -*v[x]*, and when the ball hits a horizontal
    wall, we change the velocity in the *y*-direction from *v[y]* to -*v[y]*. The
    images below, which show the track of the ball, are produced by a modified version
    of this code (see an exercise at the end of this section).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[bouncingball.py](bouncingball.py.html)实现了这些步骤，以创建一个球在以原点为中心的2x2盒子中移动的幻觉。球的当前位置是(*r[x]*
    , *r[y]*)，我们通过在每一步中将*v[x]*加到*r[x]*和*v[y]*加到*r[y]*来计算新位置。由于(*v[x]* , *v[y]*)是球在每个时间单位移动的固定距离，它代表速度。为了保持球在绘图中，我们模拟球按照弹性碰撞定律弹跳到墙壁的效果。这个效果很容易实现：当球撞到垂直墙壁时，我们只需将*x*方向上的速度从*v[x]*改变为-*v[x]*，当球撞到水平墙壁时，我们将*y*方向上的速度从*v[y]*改变为-*v[y]*。下面的图像显示了球的轨迹，这些图像是由这段代码的修改版本生成的（请参见本节末尾的一个练习）。
- en: '![Bouncing Ball](../Images/c550daeebfaec00d6fc0fb9079a558c9.png)'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![弹跳球](../Images/c550daeebfaec00d6fc0fb9079a558c9.png)'
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Audio
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准音频
- en: 'The stdaudio module can play, manipulate, and synthesize sound. It allows you
    to play `.wav` files, to compose programs to create and manipulate arrays of floats,
    and to read and write them as .wav files:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: stdaudio模块可以播放、操作和合成声音。它允许你播放`.wav`文件，编写程序来创建和操作浮点数组，并将它们读取和写入为.wav文件：
- en: '![The Stdaudio Module](../Images/2bfde5c07d2c0a04334d0973cd8e096c.png)'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stdaudio模块](../Images/2bfde5c07d2c0a04334d0973cd8e096c.png)'
- en: We first introduce some some basic concepts behind one of the oldest and most
    important areas of computer science and scientific computing, which is known as
    *digital signal processing*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍计算机科学和科学计算中最古老和最重要领域之一的一些基本概念，这个领域被称为*数字信号处理*。
- en: Concert A.
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协奏A。
- en: Sound is the perception of the vibration of molecules — in particular, the vibration
    of our eardrums. Therefore, oscillation is the key to understanding sound. Perhaps
    the simplest place to start is to consider the musical note A above middle C,
    which is known as *concert A*. This note is nothing more than a sine wave, scaled
    to oscillate at a frequency of 440 times per second. The function sin(*t*) repeats
    itself once every 2π units, so if we measure *t* in seconds and plot the function
    sin(2π*t* × 440), we get a curve that oscillates 440 times per second. We measure
    frequency in [hertz](https://en.wikipedia.org/wiki/Hertz) (cycles per second).
    When you double or halve the frequency, you move up or down one octave on the
    scale. For example, 880 hertz is one octave above concert A and 110 hertz is two
    octaves below concert A. For reference, the frequency range of human hearing is
    about 20 to 20,000 hertz. The amplitude (*y*-value) of a sound corresponds to
    the volume. We assume it is scaled to be betwen -1 and +1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是分子振动的感知，特别是我们耳膜的振动。因此，振荡是理解声音的关键。也许最简单的起点是考虑中央C上方的音符A，也称为*协奏A*。这个音符只不过是一个正弦波，按照每秒振荡440次的频率进行缩放。函数sin(*t*)每2π单位重复一次，因此如果我们以秒为单位测量*t*并绘制函数sin(2π*t*
    × 440)，我们得到一个每秒振荡440次的曲线。我们用[hertz](https://en.wikipedia.org/wiki/Hertz)（每秒循环次数）来衡量频率。当你将频率加倍或减半时，你在音阶上向上或向下移动一个八度。例如，880赫兹是协奏A的一个八度，110赫兹是协奏A的两个八度下方。作为参考，人类听觉的频率范围约为20至20,000赫兹。声音的振幅（*y*-值）对应于音量。我们假设它被缩放在-1到+1之间。
- en: Other notes.
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他注意事项。
- en: A simple mathematical formula characterizes the other notes on the chromatic
    scale. There are 12 notes on the chromatic scale, divided equally on a logarithmic
    (base 2) scale. We get the *i*th note above a given note by multiplying its frequency
    by the (*i*/12)th power of 2\. In other words, the frequency of each note in the
    chromatic scale is precisely the frequency of the previous note in the scale multiplied
    by the twelfth root of 2 (about 1.06). This information suffices to create music!
    For example, to play the tune *Frere Jacques*, we just need to play each of the
    notes A B C# A by producing sine waves of the appropriate frequency for about
    half a second and then repeat the pattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的数学公式描述了半音音阶上的其他音符。半音音阶上有12个音符，均匀分布在对数（以2为底）刻度上。我们通过将给定音符的频率乘以2的(*i*/12)次方来得到半音音阶上的第*i*个音符。换句话说，半音音阶上每个音符的频率恰好是音阶上前一个音符的频率乘以2的十二次方根（约为1.06）。这些信息足以创作音乐！例如，要演奏曲调*Frere
    Jacques*，我们只需要通过产生适当频率的正弦波来演奏A B C# A的每个音符约半秒钟，然后重复这个模式。
- en: '![Piano](../Images/0253880a42ad78551d58e4e5abeebb4b.png)'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![钢琴](../Images/0253880a42ad78551d58e4e5abeebb4b.png)'
- en: Sampling.
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采样。
- en: '![Sampling a Sine Wave](../Images/56ad6ea035a54e2c749c1374ca7f2df0.png)For
    digital sound, we represent a curve by sampling it at regular intervals, in precisely
    the same manner as when we plot function graphs. We sample sufficiently often
    that we have an accurate representation of the curve &mdot; a widely used sampling
    rate for digital sound is 44,100 samples per second. For concert A, that rate
    corresponds to plotting each cycle of the sine wave by sampling it at about 100
    points. Since we sample at regular intervals, we need to compute only the *y*
    coordinates of the sample points. It is that simple: we represent sound as an
    array of numbers (float values that are between -1 and +1). Our booksite sound
    module function `stdaudio.playSamples()` takes an array of floats as its argument
    and plays the sound represented by that array on your computer.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![采样正弦波](../Images/56ad6ea035a54e2c749c1374ca7f2df0.png)对于数字音频，我们通过在规则间隔上对其进行采样来表示曲线，这与绘制函数图形时的方式完全相同。我们采样得足够频繁，以便准确表示曲线
    — 数字音频的常用采样率为每秒 44,100 个样本。对于升降调 A，该速率对应于在大约 100 个点上对正弦波的每个周期进行采样。由于我们定期采样，我们只需要计算采样点的
    *y* 坐标。就是这么简单：我们将声音表示为一组数字（浮点值，介于 -1 和 +1 之间）。我们的 booksite 声音模块函数`stdaudio.playSamples()`以浮点数组作为其参数，并在您的计算机上播放由该数组表示的声音。'
- en: 'For example, suppose that you want to play concert A for 10 seconds. At 44,100
    samples per second, you need an array of 441,001 float values. To fill in the
    array, use a `for` loop that samples the function sin(2π*t* × 440) at *t* = 0/44100,
    1/44100, 2/44100, 3/44100, ..., 441000 / 44100\. Once we fill the array with these
    values, we are ready for `stdaudio.playSamples()`, as in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要播放升降调 A 音符 10 秒钟。以每秒 44,100 个样本的速度，你需要一个包含 441,001 个浮点值的数组。为了填充数组，使用一个`for`循环，在其中对函数
    sin(2π*t* × 440)在 *t* = 0/44100, 1/44100, 2/44100, 3/44100, ..., 441000 / 44100
    进行采样。一旦我们用这些值填充了数组，我们就可以准备好使用`stdaudio.playSamples()`，就像下面的代码一样：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is the "Hello, World" of digital audio. Once you use it to get your
    computer to play this note, you can compose code to play other notes and make
    music!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是数字音频的“Hello, World”。一旦你用它让你的计算机播放这个音符，你就可以编写代码来播放其他音符并制作音乐！
- en: Saving to a file.
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存到文件。
- en: Music can take up a lot of space on your computer. At 44,100 samples per second,
    a four-minute song corresponds to 4 × 60 × 44100 = 10,584,000 numbers. Therefore,
    it is common to represent the numbers corresponding to a song in a binary format
    that uses less space than the string-of-digits representation that we use for
    standard input and output. Many such formats have been developed in recent years
    — `stdaudio` uses the `.wav` format.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐可能会占用计算机上的大量空间。以每秒 44,100 个样本的速度，一首四分钟的歌曲对应于 4 × 60 × 44100 = 10,584,000 个数字。因此，通常会使用比我们用于标准输入和输出的数字串表示法占用更少空间的二进制格式来表示与歌曲对应的数字。近年来已经开发了许多这样的格式
    — `stdaudio`使用`.wav`格式。
- en: Playing tunes.
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放音乐。
- en: 'The program [playthattune.py](playthattune.py.html) is an example that shows
    how easily we can create music with `stdaudio`. It takes notes from standard input,
    indexed on the chromatic scale from concert A, and plays them on standard audio.
    Try running it repeatedly with its standard input redirected to each of these
    data files (created by various students): [elise.txt](elise.txt), [ascale.txt](ascale.txt),
    [stairwaytoheaven.txt](stairwaytoheaven.txt), [entertainer.txt](entertainer.txt),
    [firstcut.txt](firstcut.txt), [freebird.txt](freebird.txt), and [looney.txt](looney.txt).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[playthattune.py](playthattune.py.html)是一个示例，展示了我们如何使用`stdaudio`轻松创建音乐。它从标准输入中获取音符，以升降调音阶为索引，并在标准音频上播放它们。尝试将其标准输入重定向到以下这些数据文件中的每一个（由不同学生创建）来重复运行它：[elise.txt](elise.txt),
    [ascale.txt](ascale.txt), [stairwaytoheaven.txt](stairwaytoheaven.txt), [entertainer.txt](entertainer.txt),
    [firstcut.txt](firstcut.txt), [freebird.txt](freebird.txt), 和 [looney.txt](looney.txt)。
- en: '* * *'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q & A
- en: '**Q.** How can I make the booksite modules stdio, stddraw, and stdaudio available
    to Python?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如何使 Python 中的 booksite 模块 stdio、stddraw 和 stdaudio 可用？'
- en: '**A.** If you followed the step-by-step instructions on this booksite for installing
    Python, these modules should already be available to Python.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 如果你按照这个 booksite 上的逐步说明安装 Python，这些模块应该已经可以在 Python 中使用了。'
- en: '**Q.** Are there standard Python modules for handling standard output?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 是否有用于处理标准输出的标准 Python 模块？'
- en: '**A.** Actually, such features are built into Python. In Python 2, you can
    use the `print` statement to write data to standard output. In Python 3, there
    is no `print` statement; instead, there is a `print()` function, which is similar.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 实际上，这些功能已经内置在 Python 中。在 Python 2 中，你可以使用`print`语句将数据写入标准输出。在 Python
    3 中，没有`print`语句；取而代之的是类似的`print()`函数。'
- en: '**Q.** Why, then, are we using the booksite stdio module for writing to standard
    output instead of using the features already provided by Python?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 那么，为什么我们在写入标准输出时使用 booksite 的 stdio 模块，而不是使用 Python 已经提供的功能呢？'
- en: '**A.** Our intention is to compose code that works (as much as possible) with
    all versions of Python. For example, using the `print` statement in all our programs
    would mean they would work with Python 2, but not with Python 3\. Since we use
    `stdio` functions, we just need to make sure that we have the proper library.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 我们的意图是编写尽可能与所有 Python 版本兼容的代码。例如，在所有我们的程序中使用`print`语句将意味着它们将与 Python
    2 兼容，但与 Python 3 不兼容。由于我们使用`stdio`函数，我们只需要确保我们有正确的库。'
- en: '**Q.** How about standard input?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 关于标准输入呢？'
- en: '**A.** There are (different) capabilities in Python 2 and Python 3 that correspond
    to `stdio.readLine()`, but nothing corresponding to `stdio.readInt()` and similar
    functions. Again, by using `stdio`, we can compose programs that not just take
    advantage of these additional capabilities, but also work in both versions of
    Python.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在 Python 2 和 Python 3 中有与`stdio.readLine()`对应的功能，但没有与`stdio.readInt()`和类似函数对应的功能。再次强调，通过使用`stdio`，我们可以编写不仅利用这些额外功能的���序，而且在
    Python 的所有版本中都能正常工作。'
- en: '**Q.** How about drawing and sound?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 关于绘图和声音呢？'
- en: '**A.** Python does not come with an `audio` library. Python comes with a graphics
    library named `Tkinter` for producing drawings, but it is too slow for some of
    the graphics applications in the book. Our `stddraw` and `stdaudio` modules provide
    easy-to-use APIs, based on the `Pygame` library.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python没有附带`audio`库。Python附带一个名为`Tkinter`的图形库用于生成绘图，但对于本书中的一些图形应用来说速度太慢了。我们的`stddraw`和`stdaudio`模块提供了易于使用的API，基于`Pygame`库。'
- en: '**Q.** So, let me get this straight; if I use the format `%2.4f` with `stdio.writef()`
    to write a float, I get two digits before the decimal point and four digits after
    the decimal point, right?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 所以，让我弄清楚一点；如果我使用格式`%2.4f`与`stdio.writef()`一起写一个浮点数，我得到小数点前两位和小数点后四位数字，对吗？'
- en: '**A.** No, that specifies just four digits after the decimal point. The number
    preceding the decimal point is the width of the whole field. You want to use the
    format `%7.2f` to specify seven characters in total — four before the decimal
    point, the decimal point itself, and two digits after the decimal point.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不，这只指定小数点后的四位数字。小数点前面的数字是整个字段的宽度。你需要使用格式`%7.2f`来指定总共七个字符 — 小数点前四位，小数点本身，以及小数点后两位数字。'
- en: '**Q.** Which other conversion codes are there for `stdio.writef()`?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `stdio.writef()`还有哪些其他转换代码？'
- en: '**A.** For integer values, there are `o` for octal, `x` for hexadecimal; for
    floating point, you can use `e` or `g` to get scientific notation. There are also
    numerous formats for dates and times. The [Python documentation for string formatting
    operations](http://docs.python.org/library/stdtypes.html#string-formatting) provides
    a wealth of information.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 对于整数值，有`o`表示八进制，`x`表示十六进制；对于浮点数，你可以使用`e`或`g`来获得科学计数法。还有许多日期和时间的格式。[Python字符串格式化操作的文档](http://docs.python.org/library/stdtypes.html#string-formatting)提供了丰富的信息。'
- en: '**Q.** Can my program reread data from standard input?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我的程序可以从标准输入重新读取数据吗？'
- en: '**A.** No. You get only one shot at it, in the same way that you cannot undo
    a call of `stdio.writeln()`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不。你只有一次机会，就像你不能撤消`stdio.writeln()`的调用一样。'
- en: '**Q.** What happens if my program attempts to read data from standard input
    after it is exhausted?'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我的程序在耗尽后尝试从标准输入读取数据会发生什么？'
- en: '**A.** Python will raise an `EOFError` at run time. The functions `stdio.isEmpty()`
    and `stdio.hasNextLine()` allow you to avoid such an error by checking whether
    more input is available.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python会在运行时引发`EOFError`。函数`stdio.isEmpty()`和`stdio.hasNextLine()`允许你通过检查是否还有更多输入来避免这样的错误。'
- en: '**Q.** Why does `stddraw.square(x, y, r)` draw a square of width 2`r` instead
    of `r`?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么`stddraw.square(x, y, r)`画出的正方形宽度是 2`r` 而不是`r`？'
- en: '**A.** This makes it consistent with the function `stddraw.circle(x, y, r)`,
    where the third argument is the radius of the circle, not the diameter. In this
    context, `r` is the radius of the biggest circle that can fit inside the square.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这使得它与函数`stddraw.circle(x, y, r)`保持一致，其中第三个参数是圆的半径，而不是直径。在这个上下文中，`r`是可以容纳在正方形内的最大圆的半径。'
- en: '**Q.** What happens if my program calls `stddraw.show(0)`?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我的程序调用`stddraw.show(0)`会发生什么？'
- en: '**A.** That function call tells stddraw to copy the background canvas to the
    standard drawing window, and then wait 0 milliseconds (that is, do not wait at
    all) before proceeding. That function call is appropriate if, for example, you
    want to run an animation at the fastest rate supported by your computer.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这个函数调用告诉 stddraw 将背景画布复制到标准绘图窗口，然后等待 0 毫秒（也就是根本不等待）才继续。如果，例如，你想以计算机支持的最快速度运行动画，这个函数调用是合适的。'
- en: '**Q.** Can I draw curves other than circles with `stddraw`?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以用`stddraw`画除了圆以外的曲线吗？'
- en: '**A.** We had to draw the line somewhere (pun intended), so we support only
    the basic shapes discussed in the text. You can draw other shapes one point at
    a time, as explored in several exercises in the text, but filling them is not
    directly supported.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 我们不得不在某个地方划定界限（双关语），所以我们只支持文本中讨论的基本形状。你可以一次一个点地绘制其他形状，就像文本中的几个练习中探讨的那样，但不直接支持填充它们。'
- en: '**Q.** So I use negative integers to go below concert A when making input files
    for [playthattune.py](playthattune.py.html)?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 那么在为[playthattune.py](playthattune.py.html)制作输入文件时，我使用负整数来低于 A 音调吗？'
- en: '**A.** Right. Actually, our choice to put concert A at 0 is arbitrary. A popular
    standard, known as the *MIDI Tuning Standard*, starts numbering at the C five
    octaves below concert A. By that convention, concert A is 69 and you do not need
    to use negative numbers.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。实际上，我们选择将 A 音调放在 0 的位置是任意的。一种流行的标准，称为*MIDI调音标准*，从 A 音调下方五个八度的 C 开始编号。按照这个约定，A
    音调是 69，你不需要使用负数。'
- en: '**Q.** Why do I hear weird results from standard audio when I try to sonify
    a sine wave with a frequency of 30,000 hertz (or more)?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 当我尝试用频率为 30,000 赫兹（或更高）的正弦波进行声音化时，为什么我从标准音频听到奇怪的结果？'
- en: '**A.** The *Nyquist frequency*, defined as one-half the sampling frequency,
    represents the highest frequency that can be reproduced. For standard audio, the
    sampling frequency is 44,100, so the Nyquist frequency is 22,050.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** *奈奎斯特频率*，定义为采样频率的一半，代表可以重现的最高频率。对于标准音频，采样频率为 44,100，因此奈奎斯特频率为 22,050。'
- en: '**Q.** How do I enter the end-of-file sequence if I am redirecting standard
    input from a file?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我正在从文件重定向标准输入，我如何输入文件结束序列？'
- en: '**A.** When standard input is bound to your terminal application, you eventually
    must enter the end-of-file sequence to inform the program that no more data remains
    to be read from standard input. However when standard input is bound to a file,
    you need not enter the end-of-file sequence. Instead the operating system automatically
    informs your program when no more data remains to be read from the file.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 当标准输入绑定到你的终端应用程序时，最终你必须输入文件结束序列来通知程序标准输入没有更多数据可读取了。然而，当标准输入绑定到文件时，你不需要输入文件结束序列。相反，操作系统会在没有更多数据可从文件中读取时自动通知你的程序。'
- en: '**Q.** What other conversion codes are there for `stdio.writef()`?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `stdio.writef()`还有哪些其他转换代码？'
- en: '**Q.** How do I print the `%` character within `stdio.writef()`?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如何在`stdio.writef()`中打印`%`字符？'
- en: '**A.** Use `%%`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 使用`%%`。'
- en: '**Q.** What is the symbol for the end of a line?'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 什么是表示一行结束的符号？'
- en: '**A.** Different operating systems use different symbols. On Unix systems and
    Mac OS X, the newline character is `''\n''`. On Windows each line is terminated
    by a string of two characters `''\r\n''`. On Macs prior to OS X, each line is
    terminated by the string `''\n\r''`. When composing a program, you should avoid
    using operating system specific features or else it might not work as expected
    on other systems. Use `stdio.writeln()` to write a newline.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不同的操作系统使用不同的符号。在Unix系统和Mac OS X上，换行符是`''\n''`。在Windows上，每行由两个字符的字符串`''\r\n''`终止。在OS
    X之前的Mac上，每行由字符串`''\n\r''`终止。在编写程序时，应避免使用特定于操作系统的功能，否则可能在其他系统上无法正常工作。使用`stdio.writeln()`来写入换行符。'
- en: '**Q.** How do I create colors for use with the the `stddraw` module?'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如何为`stddraw`模块创建颜色？'
- en: '**A.** The stddraw module uses a class named `Color` that we defined specifically
    for this booksite. Chapter 3 of the booksite describes that class.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** stddraw模块使用了一个我们专门为本书站点定义的名为`Color`的类。本站点的第3章描述了该类。'
- en: '**Q.** What are the main differences of the PNG, JPEG, and PostScript graphics
    formats?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** PNG、JPEG和PostScript图形格式的主要区别是什么？'
- en: '**A.** The graphics on most web pages are in PNG, GIF, or JPEG format. All
    three formats are *raster-based* — they store the set of pixels and color gradations
    needed to represent a picture. PNG and GIF are ideal for displaying figures with
    straight lines and geometric figures, while JPEG is best suited for photographs.
    PostScript is a *vector-based* format. For example, it represents a circle as
    a geometric object instead of a collection of thousands of pixels. The quality
    does not degrade if you enlarge or shrink it. For this reason, most printers use
    PostScript to print documents and graphics.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 大多数网页上的图形都是以PNG、GIF或JPEG格式呈现的。这三种格式都是*基于栅格*的 —— 它们存储了表示图片所需的像素集和颜色渐变。PNG和GIF适合显示带有直线和几何图形的图形，而JPEG最适合于照片。PostScript是一种*基于矢量*的格式。例如，它将圆表示为几何对象，而不是成千上万个像素的集合。如果你放大或缩小它，质量不会降低。因此，大多数打印机使用PostScript来打印文档和图形。'
- en: '**Q.** What does the error message `NameError: name ''stdio'' is not defined`
    mean?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 错误消息`NameError: name ''stdio'' is not defined`是什么意思？'
- en: '**A.** You probably forgot to install the booksite modules. Of course the same
    applies to `stdarray.py`, `stddraw.py`, and `stdaudio.py`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 你可能忘记安装本站点模块了。当然，`stdarray.py`、`stddraw.py`和`stdaudio.py`也是一样。'
- en: '**Q.** How can I create an animated GIF?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如何创建一个动画GIF？'
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Compose a program that reads in integers (as many as the user enters) from standard
    input and writes the maximum and minimum values to standard output.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取整数（用户输入的数量不定），并将最大值和最小值写入标准输出。
- en: '*Solution*: See [maxmin.py](maxmin.py.html).'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请参阅[maxmin.py](maxmin.py.html)。'
- en: Modify your program from the previous exercise to insist that the integers must
    be positive (by prompting the user to enter positive integers whenever the value
    entered is not positive).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改上一个练习中的程序，要求整数必须是正数（提示用户输入正整数，如果输入的值不是正数）。
- en: Compose a program that accepts an integer *n* from the command line, reads *n*
    floats from standard input, and writes their mean (average value) and standard
    deviation (square root of the sum of the squares of their differences from the
    average, divided by *n*).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行接受一个整数*n*，从标准输入读取*n*个���点数，并写出它们的平均值和标准差（平均值的平方根，除以*n*的差值平方和）。
- en: '*Solution*: See [stats2.py](stats2.py.html).'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请参阅[stats2.py](stats2.py.html)。'
- en: Extend your program from the previous exercise to create a filter that writes
    all the values that are further than 1.5 standard deviations from the mean.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展上一个练习中的程序，创建一个过滤器，写出所有偏离平均值1.5个标准差以上的值。
- en: 'Compose a program that reads in a sequence of integers and writes both the
    integer that appears in a longest consecutive run and the length of the run. For
    example, if the input is `1 2 2 1 5 1 1 7 7 7 7 1 1`, then your program should
    write `Longest run: 4 consecutive 7s`.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，读取一系列整数，并写出出现在最长连续序列中的整数以及序列的长度。例如，如果输入是`1 2 2 1 5 1 1 7 7 7 7 1 1`，则你的程序应该写出`最长序列：4个连续的7`。
- en: '*Solution*: See [longestrun.py](longestrun.py.html).'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 请参阅[longestrun.py](longestrun.py.html)。'
- en: Compose a filter that reads in a sequence of integers and writes the integers,
    removing repeated values that appear consecutively. For example, if the input
    is `1 2 2 1 5 1 1 7 7 7 7 1 1 1 1 1 1 1 1 1`, your program should write `1 2 1
    5 1 7 1`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器，读取一系列整数，并写出这些整数，去除连续出现的重复值。例如，如果输入是`1 2 2 1 5 1 1 7 7 7 7 1 1 1 1 1
    1 1 1 1`，你的程序应该写出`1 2 1 5 1 7 1`。
- en: Compose a program that accepts a command-line argument `n`, reads from standard
    input `n-1` distinct integers between 1 and `n`, and determines the missing value.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个命令行参数`n`，从标准输入读取介于1和`n`之间的`n-1`个不同整数，并确定缺失的值。
- en: 'Compose a program that reads in positive real numbers from standard input and
    writes their geometric and harmonic means. The *geometric mean* of *n* positive
    numbers *x*[1], *x*[2], ..., *x*[*n*] is (*x*[1] × *x*[2] × ... × *x*[*n*])^(1/*n*).
    The *harmonic mean* is *n* / (1/*x*[1] + 1/*x*[2] + ... + 1/*x*[*n*]). *Hint*:
    For the geometric mean, consider taking logarithms to avoid overflow.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取正实数，并写出它们的几何平均数和调和平均数。*n*个正数*x*[1]、*x*[2]、...、*x*[*n*]的*几何平均数*是(*x*[1]
    × *x*[2] × ... × *x*[*n*])^(1/*n*)。*调和平均数*是*n* / (1/*x*[1] + 1/*x*[2] + ... +
    1/*x*[*n*])。*提示*：对于几何平均数，考虑取对数以避免溢出。
- en: Suppose that the file `input.txt` contains the two strings F and F. What does
    the following command do? See the exercises from Section 1.2 for more information
    on dragon curves. Here is the Python program [dragon3.py](dragon3.py.html).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设文件`input.txt`包含两个字符串F和F。以下命令做什么？更多关于龙曲线的信息，请参见第1.2节的练习。这是Python程序[dragon3.py](dragon3.py.html)。
- en: '[PRE7]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compose a filter `tenperline.py` that reads a sequence of integers between 0
    and 99 and writes 10 integers per line, with columns aligned. Then compose a program
    `randomintseq.py` that takes two command-line arguments `m` and `n` and writes
    `n` random integers between 0 and `m`-1\. Test your programs with the command
    `python randomintseq 100 200 | python tenperline.py`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`tenperline.py`的过滤器，该过滤器读取介于0和99之间的整数序列，并每行写入10个整数，列对齐。然后编写一个名为`randomintseq.py`的程序，该程序接受两个命令行参数`m`和`n`，并写入0到`m`-1之间的`n`个随机整数。使用命令`python
    randomintseq 100 200 | python tenperline.py`测试您的程序。
- en: Compose a program named `wordcount.py` that reads text from standard input and
    writes to standard output the number of words in the text. For the purpose of
    this exercise, a word is a sequence of non-whitespace characters that is surrounded
    by whitespace. For example, the command `python wordcount < tale.txt` should write
    139043.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`wordcount.py`的程序，从标准输入读取文本，并将文本中的单词数写入标准输出。对于本练习，单词是由空格包围的一系列非空白字符。例如，命令`python
    wordcount < tale.txt`应该写入139043。
- en: '*Solution*: See [wordcount.py](wordcount.py.html).'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[wordcount.py](wordcount.py.html)。'
- en: Compose a program that reads lines from standard input with each line containing
    a name and two integers, and then calls `stdio.writef()` to write to standard
    output a table with a column of the names, the integers, and the result of dividing
    the first by the second, accurate to three decimal places. You could use a program
    like this to tabulate batting averages for baseball players or grades for students.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取每行包含一个名称和两个整数的行，然后调用`stdio.writef()`将表格写入标准输出，其中包含名称的列、整数和将第一个整数除以第二个整数的结果，精确到三位小数。您可以使用这样的程序制表棒球运动员的击球率或学生的成绩。
- en: Which of the following *require* saving all the values from standard input (in
    an array, say), and which could be implemented as a filter using only a fixed
    number of variables? For each, the input comes from standard input and consists
    of *n* floats between 0 and 1.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些*需要*保存所有来自标准输入的值（例如保存在数组中），哪些可以仅使用固定数量的变量实现为过滤器？对于每个输入，来自标准输入的是0到1之间的*n*个浮点数。
- en: Write the maximum and minimum numbers.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出最大和最小的数字。
- en: Write the *k*th smallest value.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出第*k*小的值。
- en: Write the sum of the squares of the numbers.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出数字的平方和。
- en: Write the average of the numbers.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出数字的平均值。
- en: Write the percentage of numbers greater than the average.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出大于平均值的数字的百分比。
- en: Write the numbers in increasing order.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按升序写出数字。
- en: Write the numbers in random order.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按随机顺序写出数字。
- en: 'Compose a program that writes a table of the monthly payments, remaining principal,
    and interest paid for a loan, taking three numbers as command-line arguments:
    the number of years, the principal, and the interest rate. (See a related exercise
    in Section 1.2.)'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，为贷款编写一个每月付款、剩余本金和支付利息的表格，接受三个数字作为命令行参数：贷款年限、本金和利率。（请参见第1.2节中的相关练习。）
- en: Compose a program that takes three command-line arguments *x*, *y*, and *z*,
    reads from standard input a sequence of point coordinates (*x[i]*, *y[i]*, *z[i]*),
    and writes the coordinates of the point closest to (*x*, *y*, *z*). Recall that
    the square of the distance between (*x* , *y* , *z*) and (*x[i]* , *y[i]* , *z[i]*
    ) is (*x* - *x[i]*)² + (*y* - *y[i]*)² + (*z* - *z[i]*)2\. For efficiency, do
    not use either `math.sqrt()` or the `**` operator.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受三个命令行参数*x*、*y*和*z*，从标准输入读取一系列点坐标(*x[i]*, *y[i]*, *z[i]*)，并写出距离(*x*,
    *y*, *z*)最近的点的坐标。请记住，(*x* , *y* , *z*)和(*x[i]* , *y[i]* , *z[i]* )之间的距离的平方是(*x*
    - *x[i]*)² + (*y* - *y[i]*)² + (*z* - *z[i]*)2。为了效率，不要使用`math.sqrt()`或`**`运算符。
- en: '*Solution*: See [closest.py](closest.py.html).'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[closest.py](closest.py.html)。'
- en: Compose a program that, given the positions and masses of a sequence of objects,
    computes their center-of-mass, or *centroid*. The centroid is the average position
    of the *n* objects, weighted by mass. If the positions and masses are given by
    (*x[i]*, *y[i]*, *m[i]*), then the centroid (*x*, *y*, *m*) is given by
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，给定一系列对象的位置和质量，计算它们的质心，或*质心*。质心是按质量加权的*n*个对象的平均位置。如果位置和质量由(*x[i]*, *y[i]*,
    *m[i]*)给出，则质心(*x*, *y*, *m*)由以下公式给出
- en: '*m* = *m*[1] + *m*[2] + ... + *m[n]* *x* = (*m*[1]*x*[1] + ... + *m[n]x[n]*)
    / *m* *y* = (*m*[1]*y*[1] + ... + *m[n]y[n]*) / *m*'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*m* = *m*[1] + *m*[2] + ... + *m[n]* *x* = (*m*[1]*x*[1] + ... + *m[n]x[n]*)
    / *m* *y* = (*m*[1]*y*[1] + ... + *m[n]y[n]*) / *m*'
- en: Compose a program that reads in a sequence of floats between -1 and 1 and writes
    their average magnitude, average power, and the number of zero crossings. The
    *average magnitude* is the average of the absolute values of the data values.
    The *average power* is the average of the squares of the data values. The *number
    of zero crossings* is the number of times a data value transitions from a strictly
    negative number to a strictly positive number, or vice versa. These three statistics
    are widely used to analyze digital signals.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，读取-1到1之间的一系列浮点数，并写出它们的平均幅度、平均功率和零交叉数。*平均幅度*是数据值绝对值的平均值。*平均功率*是数据值的平方的平均值。*零交叉数*是数据值从严格负数转变为严格正数，或反之的次数。这三个统计量被广泛用于分析数字信号。
- en: Compose a program that takes an integer command-line argument `n` and plots
    an `n`-by-`n` checkerboard with red and black squares. Color the lower left square
    red.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个整数命令行参数`n`，并绘制一个由红色和黑色方块组成的`n`乘`n`棋盘。将左下角的方块涂成红色。
- en: '| ![5-by-5 checkerboard](../Images/dc915cd7e82e99149c9f979d7b7697c2.png) |
    ![8-by-8 checkerboard](../Images/3fc2385ef6145881761d8c3c8084166e.png) | ![25-by-25
    checkerboard](../Images/dd7fef0b179125bf302da039bd3ef0de.png) |'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![5x5棋盘](../Images/dc915cd7e82e99149c9f979d7b7697c2.png) | ![8x8棋盘](../Images/3fc2385ef6145881761d8c3c8084166e.png)
    | ![25x25棋盘](../Images/dd7fef0b179125bf302da039bd3ef0de.png) |'
- en: '*Solution*: See [checkerboard.py](checkerboard.py.html)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[checkerboard.py](checkerboard.py.html)'
- en: Compose a program that takes as command-line arguments an integer `n` and a
    float `p` (between 0 and 1), plots `n` equally spaced points of size on the circumference
    of a circle, and then, with probability `p` for each pair of points, draws a gray
    line connecting them.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行参数中接受一个整数`n`和一个介于0和1之间的浮点数`p`，在圆周上绘制`n`个等间距点，然后，对于每对点，以概率`p`，绘制连接它们的灰色线。
- en: '| ![erdos](../Images/023ea815e40c5c9c254daa2561dc9cd9.png) |'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![erdos](../Images/023ea815e40c5c9c254daa2561dc9cd9.png) |'
- en: Compose code to draw hearts, spades, clubs, and diamonds. To draw a heart, draw
    a diamond, then attach two semicircles to the upper left and upper right sides.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码来绘制红心、黑桃、梅花和方块。要绘制一个红心，先绘制一个方块，然后将两个半圆连接到左上角和右上角。
- en: Compose a program that takes an integer command-line argument `n` and plots
    a "flower" with `n` petals (if `n` is odd) or `2n` petals (if `n` is even) by
    plotting the polar coordinates (*r*, θ) of the function *r* = sin(*n* × θ) for
    θ ranging from 0 to `2π` radians. Below is the desired output for `n` = 4, 7,
    and 8.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个整数命令行参数`n`，并绘制一个具有`n`个花瓣（如果`n`为奇数）或`2n`个花瓣（如果`n`为偶数）的“花朵”，通过绘制极坐标(*r*,
    θ)函数*r* = sin(*n* × θ)，其中θ范围从0到`2π`弧度。下面是`n`为4、7和8时的期望输出。
- en: '| ![rose](../Images/2e84daf4180b13cde2c8a4d97a62afaa.png) |'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![玫瑰](../Images/2e84daf4180b13cde2c8a4d97a62afaa.png) |'
- en: '*Solution*: See [rose.py](rose.py.html).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[rose.py](rose.py.html)。'
- en: Compose a program that takes a string `s` from the command line and displays
    it in banner style on the screen, moving from left to right and wrapping back
    to the beginning of the string as the end is reached. Add a second command-line
    argument to control the speed.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从命令行接受一个字符串`s`，并以横幅样式在屏幕上显示它，从左向右移动，并在达到末尾时回到字符串的开头。添加第二个命令行参数以控制速度。
- en: '*Solution*: See [banner.py](banner.py.html).'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[banner.py](banner.py.html)。'
- en: Modify [playthattune.py](playthattune.py.html) to take additional command-line
    arguments that control the volume (multiply each sample value by the volume) and
    the tempo (multiply each note's duration by the tempo).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[playthattune.py](playthattune.py.html)以接受额外的命令行参数，控制音量（将每个采样值乘以音量）和节奏（将每个音符的持续时间乘以节奏）。
- en: Compose a program that takes the name of a `.wav` file and a playback rate *r*
    as command-line arguments and plays the file at the given rate. First, use `stdaudio.read()`
    to read the file into an array `a[]`. If *r* = 1, just play `a[]`; otherwise create
    a new array `b[]` of approximate size *r* times `len(a)`. If *r < 1*, populate
    `b[]` by *sampling* from the original; if *r > 1*, populate `b[]` by *interpolating*
    from the original. Then play `b[]`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个`.wav`文件的名称和一个播放速率*r*作为命令行参数，并以给定速率播放文件。首先，使用`stdaudio.read()`将文件读入数组`a[]`。如果*r*
    = 1，只需播放`a[]`；否则创建一个大约大小为*r*倍`len(a)`的新数组`b[]`。如果*r* < 1，通过从原始数组中进行*采样*来填充`b[]`；如果*r*
    > 1，通过*插值*从原始数组填充`b[]`。然后播放`b[]`。
- en: Compose programs that use `stddraw` to create each of these designs.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用`stddraw`创建这些设计的程序。
- en: '![geometric designs](../Images/a15b4d142defa47e917b278ba1440848.png)'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![几何设计](../Images/a15b4d142defa47e917b278ba1440848.png)'
- en: 'Compose a program that draws filled circles of random size at random positions
    in the unit square, producing images like those below. Your program should take
    four command-line arguments: the number of circles, the probability that each
    circle is black, the minimum radius, and the maximum radius.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，在单位正方形中的随机位置绘制随机大小的填充圆，生成类似下面的图像。您的程序应该接受四个命令行参数：圆的数量、每个圆为黑色的概率、最小半径和最大半径。
- en: '![random circles](../Images/acc9096db524d92edc6e8632eda8cec6.png)'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![随机圆](../Images/acc9096db524d92edc6e8632eda8cec6.png)'
- en: '* * *'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Visualizing audio.** Modify [playthattune.py](playthattune.py.html) to send
    the values played to standard drawing, so that you can watch the sound waves as
    they are played. You will have to experiment with plotting multiple curves in
    the drawing canvas to synchronize the sound and the picture.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可视化音频。** 修改[playthattune.py](playthattune.py.html)以将播放的值发送到标准绘图，这样您就可以观看播放时的声波。您将不得不尝试在绘图画布中绘制多条曲线，以同步声音和图片。'
- en: '**Statistical polling.** When collecting statistical data for certain political
    polls, it is very important to obtain an unbiased sample of registered voters.
    Assume that you have a file with *n* registered voters, one per line. Compose
    a filter that writes a random sample of size *m*. (See the [sample.py](../14array/sample.py.html)
    program from Section 1.4.)'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**统计调查。** 在为某些政治民意调查收集统计数据时，非常重要的是获得一个无偏的注册选民样本。假设您有一个文件，其中包含*n*个注册选民，每行一个。编写一个过滤器，写入大小为*m*的随机样本。（参见第1.4节的[sample.py](../14array/sample.py.html)程序。）'
- en: '**Terrain analysis.** Suppose that a terrain is represented by a two-dimensional
    grid of elevation values (in meters). A peak is a grid point whose four neighboring
    cells (left, right, up, and down) have strictly lower elevation values. Compose
    a program that reads a terrain from standard input and then computes and writes
    the number of peaks in the terrain.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**地形分析。** 假设地形由二维高程值网格表示（以米为单位）。山峰是一个网格点，其四个相邻单元格（左、右、上、下）的高程值严格较低。编写一个程序，从标准输入读取地形，然后计算并写入地形中山峰的数量。'
- en: '**Histogram.** Suppose that the standard input stream is a sequence of floats.
    Compose a program that takes an integer `n` and two floats `lo` and `hi` from
    the command line and uses `stddraw` to plot a histogram of the count of the numbers
    in the standard input stream that fall in each of the `n` intervals defined by
    dividing (`lo`, `hi`) into `n` equal-sized intervals.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**直方图。** 假设标准输入流是一系列浮点数。编写一个程序，从命令行接受一个整数`n`和两个浮点数`lo`和`hi`，并使用`stddraw`绘制一个直方图，显示标准输入流中落入(`lo`,
    `hi`)中的每个`n`个间隔中的数字的计数。'
- en: '**Spirographs.** Compose a program that accepts three command-line arguments
    *R*, *r*, and *a* and draws the resulting *spirograph*. A [spirograph](https://en.wikipedia.org/wiki/Spirograph)
    (technically, an epicycloid) is a curve formed by rolling a circle of radius *r*
    around a larger fixed circle or radius *R*. If the pen offset from the center
    of the rolling circle is (*r*+*a*), then the equation of the resulting curve at
    time *t* is given by'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**螺线图。** 编写一个程序，接受三个命令行参数*R*、*r*和*a*，并绘制结果的*螺线图*。一个[螺线图](https://en.wikipedia.org/wiki/Spirograph)（技术上，是一个外摆线）是通过围绕半径为*r*的圆在一个固定半径为*R*的大圆周围滚动形成的曲线。如果笔偏离滚动圆心(*r*+*a*)，那么在时间*t*时得到的曲线方程为'
- en: '[PRE8]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Such curves were popularized by a best-selling toy that contains discs with
    gear teeth on the edges and small holes that you could put a pen in to trace spirographs.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些曲线是由一种畅销玩具推广的，该玩具包含具有齿轮齿的圆盘和小孔，您可以在其中放入笔来追踪螺线图。
- en: '*Solution*: See [spirograph.py](spirograph.py.html).'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[spirograph.py](spirograph.py.html)。'
- en: '**Clock.** Compose a program that displays an animation of the second, minute,
    and hour hands of an analog clock. Use the call `stddraw.show(1000)` to update
    the display roughly once per second.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**时钟。** 编写一个程序，显示模拟时钟的秒、分和时针的动画。使用调用`stddraw.show(1000)`来大约每秒更新一次显示。'
- en: '*Hint*: this may be one of the rare times when you want to use the `%` operator
    with a float; it works the way you would expect.'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：这可能是您想要使用浮点数的`%`运算符的罕见时刻之一；它的工作方式与您期望的一样。'
- en: '*Solution*: See [clock.py](clock.py.html).'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[clock.py](clock.py.html)。'
- en: '**Oscilloscope.** Compose a program to simulate the output of an oscilloscope
    and produce Lissajous patterns. These patterns are named after the French physicist,
    Jules A. Lissajous, who studied the patterns that arise when two mutually perpendicular
    periodic disturbances occur simultaneously. Assume that the inputs are sinusoidal,
    so that the following parametric equations describe the curve:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**示波器。** 编写一个程序来模拟示波器的输出并产生利萨如图案。这些图案以法国物理学家朱尔斯·A·利萨如的名字命名，他研究了当两个相互垂直的周期性干扰同时发生时产生的图案。假设输入是正弦的，因此以下参数方程描述曲线：'
- en: '[PRE9]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Take the six parameters *A[x]* and *A[y]* (amplitudes); *w[x]* and *w[y]* (angular
    velocity); and θ*x* and θ*y* (phase factors) from the command line.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从命令行获取六个参数*A[x]*和*A[y]*（振幅）；*w[x]*和*w[y]*（角速度）；以及θ*x*和θ*y*（相位因子）。
- en: For example, the first image below has *A[x]* = *A[y]* = 1, *w[x]* = 2, *w[y]*
    = 3, θ*[x]* = 20 degrees, θ[*y*] = 45 degrees. The other has parameters (1, 1,
    5, 3, 30, 45)
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，下面的第一幅图像具有*A[x]* = *A[y]* = 1，*w[x]* = 2，*w[y]* = 3，θ*[x]* = 20度，θ[*y*] =
    45度。另一个具有参数(1, 1, 5, 3, 30, 45)
- en: '| ![Oscilloscope 2](../Images/685cbd764bcfabbf9e58f88aaec1b45f.png) | ![Oscilloscope
    3](../Images/61efeb8533a0ef43f16a3bc20564606b.png) |'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![示波器 2](../Images/685cbd764bcfabbf9e58f88aaec1b45f.png) | ![示波器 3](../Images/61efeb8533a0ef43f16a3bc20564606b.png)
    |'
- en: '*Solution*: See [oscilloscope.py](oscilloscope.py.html).'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：参见[oscilloscope.py](oscilloscope.py.html)。'
- en: '**Bouncing ball with tracks**. Modify [bouncingball.py](bouncingball.py.html)
    to produce images like the ones shown earlier in this page, which show the track
    of the ball on a gray background.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带轨道的弹跳球**。修改[bouncingball.py](bouncingball.py.html)以生成像本页早期显示的那样的图像，显示球在灰色背景上的轨迹。'
- en: '**Bouncing ball with gravity.** Modify [bouncingball.py](bouncingball.py.html)
    to incorporate gravity in the vertical direction. Add calls to `stdaudio.playFile()`
    to add one sound effect when the ball hits a wall and a different one when it
    hits the floor.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带重力的弹跳球。** 修改[bouncingball.py](bouncingball.py.html)以在垂直方向上加入重力。添加调用`stdaudio.playFile()`来在球撞到墙壁时添加一个声音效果，撞到地板时添加另一个声音效果。'
- en: '**Random tunes.** Compose a program that uses `stdaudio` to play random tunes.
    Experiment with keeping in key, assigning high probabilities to whole steps, repetition,
    and other rules to produce reasonable melodies.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机旋律。** 编写一个程序，使用`stdaudio`播放随机旋律。尝试保持在调内，给整音高概率，重复，以及其他规则来产生合理的旋律。'
- en: '**Tile patterns.** In a previous exercise you wrote programs to create tile-like
    designs. Using your solution that exercise, compose a program `tilepattern.py`
    that takes a command-line argument `n` and draws an `n`-by-`n` pattern, using
    the tile of your choice. Add a second command-line argument that adds a checkerboard
    option. Add a third command-line argument for color selection. Using the patterns
    below as a starting point, design a tile floor. Be creative!'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**瓷砖图案。** 在之前的练习中，您编写了创建类似瓷砖的设计的程序。使用您解决该练习的解决方案，编写一个名为`tilepattern.py`的程序，它接受一个命令行参数`n`，并绘制一个`n`乘`n`的图案，使用您选择的瓷砖。添加第二个命令行参数以添加棋盘选项。添加第三个命令行参数以选择颜色。使用下面的图案作为起点，设计一个瓷砖地板。发挥创意！'
- en: '![tiles](../Images/cd274a60c340f86e2780bc64dac44d33.png)'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![瓷砖](../Images/cd274a60c340f86e2780bc64dac44d33.png)'
- en: 'Note: These are all designs from antiquity that you can find in many ancient
    (and modern) buildings such as from from San Giovanni in Laterno (Basilica of
    St. John Latern) in Rome [ [1](images/IMG_0252.jpg) [2](images/IMG_0253.jpg) [3](images/IMG_0255.jpg)
    [4](images/IMG_0256.jpg) [5](images/IMG_0257.jpg) [6](images/IMG_0260.jpg) ] or
    from the Tile Museum in Lisbon [ [1](images/IMG_0480.jpg) [2](images/IMG_0481.jpg)
    [3](images/IMG_0482.jpg) [4](images/IMG_0483.jpg) [5](images/IMG_0484.jpg) [6](images/IMG_0485.jpg)
    [7](images/IMG_0486.jpg) [8](images/IMG_0487.jpg) [9](images/IMG_0498.jpg) [10](images/IMG_0500.jpg)
    ]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：这些都是古代的设计，您可以在许多古代（和现代）建筑中找到，例如罗马的圣若望大殿（圣约翰大殿）[ [1](images/IMG_0252.jpg)
    [2](images/IMG_0253.jpg) [3](images/IMG_0255.jpg) [4](images/IMG_0256.jpg) [5](images/IMG_0257.jpg)
    [6](images/IMG_0260.jpg) ]或里斯本的瓷砖博物馆[ [1](images/IMG_0480.jpg) [2](images/IMG_0481.jpg)
    [3](images/IMG_0482.jpg) [4](images/IMG_0483.jpg) [5](images/IMG_0484.jpg) [6](images/IMG_0485.jpg)
    [7](images/IMG_0486.jpg) [8](images/IMG_0487.jpg) [9](images/IMG_0498.jpg) [10](images/IMG_0500.jpg)
    ]
