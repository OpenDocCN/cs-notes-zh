- en: Lecture 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8讲
- en: 原文：[https://cs50.harvard.edu/web/notes/8/](https://cs50.harvard.edu/web/notes/8/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/web/notes/8/](https://cs50.harvard.edu/web/notes/8/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[Scalability](#scalability)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可扩展性](#scalability)'
- en: '[Scaling](#scaling)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[扩展](#scaling)'
- en: '[Load Balancing](#load-balancing)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[负载均衡](#load-balancing)'
- en: '[Autoscaling](#autoscaling)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自动扩展](#autoscaling)'
- en: '[Server Failure](#server-failure)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[服务器故障](#server-failure)'
- en: '[Scaling Databases](#scaling-databases)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[扩展数据库](#scaling-databases)'
- en: '[Database Replication](#database-replication)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库复制](#database-replication)'
- en: '[Caching](#caching)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缓存](#caching)'
- en: '[Security](#security)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安全](#security)'
- en: '[Git and GitHub](#git-and-github)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Git和GitHub](#git-and-github)'
- en: '[HTML](#html)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HTML](#html)'
- en: '[HTTPS](#https)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HTTPS](#https)'
- en: '[Secret-Key Cryptography](#secret-key-cryptography)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[密钥加密](#secret-key-cryptography)'
- en: '[Public-Key Cryptography](#public-key-cryptography)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[公钥加密](#public-key-cryptography)'
- en: '[Databases](#databases)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库](#databases)'
- en: '[APIs](#apis)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[APIs](#apis)'
- en: '[Environment Variables](#environment-variables)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[环境变量](#environment-variables)'
- en: '[JavaScript](#javascript)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript](#javascript)'
- en: '[Cross-Site Request Forgery](#cross-site-request-forgery)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跨站请求伪造](#cross-site-request-forgery)'
- en: '[What’s next?](#whats-next)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接下来是什么？](#whats-next)'
- en: Introduction
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we’ve discussed how to build simple web pages using HTML and CSS, and
    how to use Git and GitHub in order to keep track of changes to our code and collaborate
    with others. We also familiarized ourselves with the Python programming language,
    started using Django to create web applications, and learned how to use Django
    models to store information in our sites. We then introduced JavaScript and learned
    how to use it to make web pages more interactive, and talked about using animation
    and React to further improve our User Interfaces. We then talked about some best
    practices in software development and some technologies commonly used to achieve
    those best practces.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何使用HTML和CSS构建简单的网页，以及如何使用Git和GitHub来跟踪我们代码的变化并与他人协作。我们还熟悉了Python编程语言，开始使用Django创建Web应用程序，并学习了如何使用Django模型在我们的网站上存储信息。然后我们介绍了JavaScript，并学习了如何使用它使网页更加互动，并讨论了使用动画和React来进一步改进我们的用户界面。然后我们讨论了一些软件开发的最佳实践和一些常用于实现这些最佳实践的技术。
- en: Today, in our final lecture, we’ll discuss the issues of scaling up and securing
    our web applications.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，在我们的最后一讲中，我们将讨论扩展和确保我们的Web应用程序安全的问题。
- en: Scalability
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: 'So far in this course, we’ve built applications that are run only locally on
    our computers, but eventually, we’ll want to launch our sites so they canbe accessed
    by anyone on the internet. In order to do this, we run our sites on **servers**,
    which are physical pieces of hardware dedicated to running applications. Servers
    can either be on-premise (We own and maintain physical servers where our application
    is hosted) or on the cloud (servers are owned by a different company such as Amazon
    or Google, and we pay to rent server space where our application is hosted). There
    are benefits and drawbacks to both options:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本课程中，我们构建的应用程序仅在本地计算机上运行，但最终，我们希望发布我们的网站，以便任何互联网用户都可以访问。为了做到这一点，我们在**服务器**上运行我们的网站，这些服务器是专门用于运行应用程序的物理硬件。服务器可以是本地（我们拥有并维护物理服务器，我们的应用程序托管在其中）或云上（服务器由不同的公司拥有，如亚马逊或谷歌，我们支付租用服务器空间以托管我们的应用程序）。这两种选择都有其优点和缺点：
- en: '**Customization**: Hosting your own servers gives you the ability to decide
    exactly how they work, allowing for more flexibility than cloud-based hosting.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制**：托管自己的服务器让您能够决定它们如何工作，这比基于云的托管提供了更多的灵活性。'
- en: '**Expertise**: It is much simpler to host an application on the cloud than
    it is to maintain your own servers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专业知识**：在云上托管应用程序比维护自己的服务器要简单得多。'
- en: '**Cost**: Since server-hosting sites need to make a profit, they will charge
    you more than it costs them to maintain their on-premise servers, making cloud-based
    servers more expensive. However, the startup costs of running on-premise servers
    can be high, as you need to purchase physical servers and potentially hire someone
    with the expertise to set them up.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：由于服务器托管网站需要盈利，它们将向您收取比维护本地服务器成本更高的费用，这使得基于云的服务器更昂贵。然而，运行本地服务器的启动成本可能很高，因为您需要购买物理服务器，并可能需要聘请具有设置这些服务器所需专业知识的人。'
- en: '**Scalability**: Scaling is typically easier when hosting on the cloud. For
    example, if we host a site on premise that gets 500 visits per day, and then it
    starts getting 500,000 visits per day, we would have to order and setup more physical
    servers to handle the requests, and in the mean time many of our users will not
    be able to access the site. Most cloud hosting sites will allow you to rent server
    space flexibly, paying based on how much action your site sees.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性（Scalability**）: 当在云上托管时，扩展通常更容易。例如，如果我们托管一个每天有500次访问的本地网站，然后它开始每天有500,000次访问，我们就必须订购和设置更多的物理服务器来处理请求，同时许多用户将无法访问该网站。大多数云托管网站将允许你灵活地租用服务器空间，根据你的网站活动量来支付费用。'
- en: 'When a user sends an HTTP request to this server, the server should send back
    a response. However, in reality, most servers get far more than one request at
    a time, as depicted below:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向这个服务器发送HTTP请求时，服务器应该发送回一个响应。然而，在现实中，大多数服务器一次会接收到远超过一个请求，如下所示：
- en: '![server many inputs](../Images/59df0fc7f5b4d640f5c171fa4d9e2012.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![服务器多输入](../Images/59df0fc7f5b4d640f5c171fa4d9e2012.png)'
- en: This is where we run into the issue of scalability. A single server can handle
    only so many requests at once, forcing us to make plans about what to do when
    our one server is overworked. Whether we decide to host on premise or on the cloud,
    we have to determine how many requests a server can handle without crashing, which
    can be done using any number of **benchmarking** tools including Apache Bench.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们会遇到可扩展性问题的地方。单个服务器一次只能处理这么多请求，迫使我们制定计划，当我们的一个服务器过载时我们将如何处理。无论我们决定在本地还是云上托管，我们都必须确定服务器可以处理而不崩溃的请求数量，这可以使用任何数量的**基准测试**工具来完成，包括Apache
    Bench。
- en: Scaling
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Once we have some upper limit on how many requests our server can handling,
    we can begin thinking about how we want to handle the scaling of our application.
    Two different approaches to scaling include:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定我们的服务器可以处理多少请求的上限，我们就可以开始考虑我们想要如何处理应用程序的扩展。两种不同的扩展方法包括：
- en: '**Vertical Scaling**: In vertical scaling, when our server is overwhelmed we
    simply buy or build a larger server. This strategy is limited however, as there
    is an upper limit on how powerful a single server can be.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垂直扩展（Vertical Scaling**）: 在垂直扩展中，当我们的服务器过载时，我们只是购买或构建一个更大的服务器。然而，这种策略是有限的，因为单个服务器的强大程度有一个上限。'
- en: '**Horizontal Scaling**: In horizontal scaling, when our server is overwhelmed
    we buy or build more servers, and then split the requests among our multiple servers.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**水平扩展（Horizontal Scaling**）: 在水平扩展中，当我们的服务器过载时，我们购买或构建更多的服务器，然后将请求分配给我们的多个服务器。'
- en: Load Balancing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡
- en: 'When we use horizontal scaling, we are faced with the additional problem of
    how we decide which servers are assigned to which requests. We answer that question
    by employing a **load balancer**, which is another piece of hardware that intercepts
    incoming requests, and then assigns those requests to one of our servers. There
    are a number of different methods for deciding which server receives which request,
    but here are a few:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用水平扩展时，我们面临的一个额外问题是决定哪些服务器被分配给哪些请求。我们通过采用**负载均衡器**来回答这个问题，这是一种拦截传入请求并分配给我们的服务器的另一件硬件。有几种不同的方法来决定哪个服务器接收哪个请求，但这里有一些：
- en: '**Random**: In this simple method, the load balancer will decide randomly which
    server it should assign a request to.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机（Random**）: 在这个简单的方法中，负载均衡器将随机决定将请求分配给哪个服务器。'
- en: '**Round-Robin**: In this method, the load balancer will alternate which server
    receives an incoming request. If we have three servers, the first request might
    go to server A, the second to server B, the third to server C, and the fourth
    back to server A.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询（Round-Robin**）: 在这种方法中，负载均衡器将交替选择哪个服务器接收传入的请求。如果我们有三个服务器，第一个请求可能会发送到服务器A，第二个发送到服务器B，第三个发送到服务器C，第四个又回到服务器A。'
- en: '**Fewest Connections**: In this method, the load balancer looks for the server
    that is currently handling the fewest requests, and assigns the incoming request
    to that server. This allows us to make sure we’re not overworking one particular
    server, but it also takes longer for the load balancer to calculate the number
    of requests each server is currently handling than it dows for it to simply choose
    a random server.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最少连接（Fewest Connections**）: 在这种方法中，负载均衡器会寻找当前处理最少请求的服务器，并将传入的请求分配给该服务器。这确保了我们不会过度使用某个特定的服务器，但这也使得负载均衡器计算每个服务器当前处理的请求数量所需的时间比随机选择服务器要长。'
- en: 'There is no method of load balancing that is strictly better than all other
    methods, and there are many different methods used in practice. One problem that
    can arise when scaling horizontally is that we might have sessions that are stored
    on one server but not another, and we don’t want users to have to re-enter information
    just because the load balancer pushes their request to a new server. Like many
    problems of scalability, there are multiple approaches to solving the problem
    of sessions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种负载均衡方法在所有其他方法中绝对优于其他方法，实践中使用了许多不同的方法。在水平扩展时可能出现的一个问题是，我们可能会有存储在一个服务器上的会话，但不在另一个服务器上，我们不希望用户因为负载均衡器将他们的请求推送到新的服务器而不得不重新输入信息。像许多可扩展性问题一样，解决会话问题的方法有多种：
- en: '**Sticky Sessions**: Once a user visits a site, the load balancer remembers
    which server they were sent to first, and makes sure to send them to the same
    one. One big concern with this method is that we could end up having a large number
    of users sticking to one server, causing it to crash.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粘性会话**：一旦用户访问了一个网站，负载均衡器会记住他们最初被发送到哪个服务器，并确保将他们发送到同一个服务器。这种方法的一个主要担忧是，我们可能会让大量用户粘附在一个服务器上，导致该服务器崩溃。'
- en: '**Database Sessions**: All sessions are stored in a database that all servers
    have access to. This way, a user’s information will be available no matter which
    server they are assigned to. The drawback here is that it takes additional time
    and computing power to read from and write to a database.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库会话**：所有会话都存储在一个所有服务器都可以访问的数据库中。这样，无论用户被分配到哪个服务器，他们的信息都将可用。这里的缺点是，从数据库中读取和写入需要额外的时间和计算能力。'
- en: '**Client-Side Sessions**: Rather than storing information on our servers, we
    can choose to store them locally on the user’s web browser as cookies. The drawbacks
    to this method include the security concern of users creating false cookies that
    allow them to log in as another user, and the computational concern of sending
    cookie information back and forth with every request.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端会话**：而不是在我们的服务器上存储信息，我们可以选择将它们作为cookie存储在用户的网络浏览器中。这种方法的不利之处包括用户创建虚假cookie以允许他们以其他用户身份登录的安全问题，以及每次请求都要来回发送cookie信息的计算问题。'
- en: Like with load balancing, there is no best answer to the sessions problem, and
    the method you choose will often depend on your specific circumstances.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像负载均衡一样，对于会话问题没有最好的答案，你选择的方法通常会取决于你的具体情况。
- en: Autoscaling
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Another problem that we could run into is that many websites are visited much
    more frequently at certain times. For example, if we decide to launch our “Is
    it New Year’s?” app from earlier, we might expect it to get a lot more traffic
    in late December to early January than any other time of year. If we buy enough
    servers for the site to stay active during the winter, those servers would be
    sitting idle for the rest of the year, wasting space and energy. This scenario
    has brought about the idea of **autoscaling** which has become common in cloud
    computing, where the number of servers being used by your site can grow and shrink
    based on the number of requests it gets. Autoscaling is not a perfect solution
    though, as it takes time to determine that a new server is needed and to launch
    that server. Another potential problem is that the more servers you have running,
    the more opportunity there is for one to fail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到另一个问题是，许多网站在特定时间访问频率要高得多。例如，如果我们决定从早些时候启动我们的“是新年吗？”应用程序，我们可能会预计它在年底到一月初的流量会比一年中的任何其他时间都要多。如果我们为网站购买足够的服务器以保持冬季的活跃状态，那么这些服务器在其余的时间里将处于闲置状态，浪费空间和能源。这种场景催生了**自动扩展**的概念，这在云计算中已成为常见做法，即网站使用的服务器数量可以根据接收到的请求数量增长和缩小。尽管如此，自动扩展并不是一个完美的解决方案，因为它需要时间来确定需要新的服务器并启动该服务器。另一个潜在的问题是，你拥有的运行服务器越多，出现故障的机会就越多。
- en: Server Failure
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器故障
- en: Having multiple servers though, can help to avoid what is known as a **Single
    Point of Failure**, which is a piece of hardware that, after failing, will cause
    the entire site to crash. When scaling horizontally, the load balancer can detect
    which servers have crashed by sending periodic **heartbeat** requests to each
    server, and then stop assigning new requests to servers that have crashed. At
    this point, it seems we have simply moved our single point of failure from a server
    to the load balancer, but we can account for this by having backup load balancers
    available if our original happens to crash.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有多个服务器可以帮助避免所谓的**单点故障**，即一个硬件设备在故障后会导致整个网站崩溃。在水平扩展时，负载均衡器可以通过向每个服务器发送定期的**心跳**请求来检测哪些服务器已崩溃，然后停止将新请求分配给已崩溃的服务器。此时，似乎我们只是将单点故障从服务器转移到了负载均衡器，但我们可以通过备用负载均衡器的可用性来解决这个问题，以防原始负载均衡器意外崩溃。
- en: Scaling Databases
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库扩展
- en: 'In addition to scaling our servers that process requests, we’ll also want to
    think of ways to scale our Databases. In this course we use SQLite which stores
    data inside a file on the server, but as we store more and more data, it sometimes
    makes more sense to store data in a number of different files, and maybe even
    on a separate server. This brings up the problem then of what to do when our database
    server can no longer handle all of the requests coming in. Like in other issues
    of scalability, there are a number of methods we can use to mitigate this problem:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展处理请求的服务器外，我们还需要考虑如何扩展我们的数据库。在本课程中，我们使用SQLite，它将数据存储在服务器上的文件中，但随着我们存储的数据越来越多，有时将数据存储在多个不同的文件中，甚至可能是在单独的服务器上，可能更有意义。这引发了一个问题，即当我们的数据库服务器无法处理所有传入的请求时应该怎么办。与其他可扩展性问题一样，我们可以使用多种方法来减轻这个问题：
- en: '**Vertical Partitioning**: This is a method similar to the one we used when
    first discussing SQL, where we split our data into multiple different tables rather
    than having redundant information in one table. (Feel free to look back on lecture
    4 where we split the `flights` table into a `flights` table and an `airports`
    table).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直分区**：这是一种与我们最初讨论SQL时使用的方法类似的方法，其中我们将数据拆分到多个不同的表中，而不是在一个表中保留冗余信息。（请随时回顾第4讲，其中我们将`flights`表拆分为`flights`表和`airports`表）。'
- en: '**Horizontal Partitioning**: This method involves storing multiple tables with
    the same format, but different information. For example, we could split a `flights`
    table into a `domestic_flights` table and an `international_flights` table. This
    way, when we wish to search for a flight from JFK to LHR, we don’t have to waste
    time searching through a table full of domestic flights. One drawback to this
    method is that it can be expensive to join multiple tables once they have been
    split.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分区**：这种方法涉及存储具有相同格式但不同信息的多个表。例如，我们可以将`flights`表拆分为`domestic_flights`表和`international_flights`表。这样，当我们希望搜索从JFK到LHR的航班时，我们不必浪费时间搜索一个充满国内航班的表。这种方法的一个缺点是，一旦表被拆分，连接多个表可能会很昂贵。'
- en: Database Replication
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库复制
- en: 'Even after we’ve scaled a database, it seems we’re still left with a single
    point of failure. If our database server crashes, all of our data could be lost.
    Just as we added more servers to avoid a single point of failure, we can add copies
    of our database to make sure the failure of one database does not shut down our
    application. Also like before there are different methods of database replication,
    two of the most popular of which are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在数据库进行了扩展，似乎我们仍然面临一个单点故障的问题。如果我们的数据库服务器崩溃，我们所有的数据可能会丢失。正如我们添加更多服务器以避免单点故障一样，我们也可以添加数据库的副本来确保一个数据库的故障不会使我们的应用程序关闭。同样，之前也有不同的数据库复制方法，其中两种最受欢迎的是：
- en: '**Single-Primary Replication**: In this method there are multiple databases,
    but only one of them is considered to be the primary database, meaning you can
    read from and write to one of the databases, but only read from each of the others.
    When the primary database is updated, the other databases are then updated to
    match the primary one. One drawback of this method is that it still contains a
    single point of failure when it comes to writing to the database.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单主复制**：在这种方法中，有多个数据库，但只有一个被认为是主数据库，这意味着你可以从其中一个数据库中读取和写入，但只能从每个其他数据库中读取。当主数据库更新时，其他数据库随后更新以匹配主数据库。这种方法的一个缺点是，在写入数据库时仍然存在单点故障。'
- en: '![single primary visual](../Images/2de58ef1ae443e9d000a9a096d8ae4f8.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![单主视觉](../Images/2de58ef1ae443e9d000a9a096d8ae4f8.png)'
- en: '**Multi-Primary Replication**: In this method, all of the databases can be
    read from and written to. This solves the problem of a single point of failure,
    but it comes with a tradeoff: it is now much more difficult to keep all databases
    up to date because each database must be aware of changes to all other databases.
    This system also sets us up for the possibility of some conflicts:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多主复制**：在这种方法中，所有数据库都可以读取和写入。这解决了单点故障的问题，但代价是现在要使所有数据库保持最新状态变得更加困难，因为每个数据库都必须了解所有其他数据库的变化。这个系统也使我们面临一些冲突的可能性：'
- en: '**Update Conflict**: With multiple databases, one user may attempt to edit
    a row in one database while another user attempts to edit that same row in a different
    database, causing a problem when the databases sync up.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新冲突**：在多个数据库中，一个用户可能尝试在一个数据库中编辑一行，而另一个用户可能尝试在另一个数据库中编辑同一行，当数据库同步时，这会导致问题。'
- en: '**Uniqueness Conflict**: Every row in a SQL database must have a unique identifier,
    and we may run into the problem that we assign the same id to two different entries
    in two different databases.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一性冲突**：SQL数据库中的每一行都必须有一个唯一的标识符，我们可能会遇到在两个不同的数据库中为两个不同的条目分配相同ID的问题。'
- en: '**Delete Conflict**: One user may delete a row while another user attempts
    to update it.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除冲突**：一个用户可能删除一行，而另一个用户可能尝试更新它。'
- en: '![multi primary visual](../Images/fea10a724a670c4f2a4fc3fd1b607fb8.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![多主视觉](../Images/fea10a724a670c4f2a4fc3fd1b607fb8.png)'
- en: Caching
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Whenever we’re working with larger databases, it is important to recognize that
    every interaction we have with a database is costly. Therefore, we wish to minimize
    the number of calls to our database server. Let’s look, for example, at the [New
    York Times](https://www.nytimes.com/) website. The New York Times may have some
    database with all of their articles which is queried and some template that is
    rendered every time someone loads the home page, but this would be a waste of
    resources, as the articles displayed on the home page likely do not change much
    from second to second. One way we can deal with this problem is by using **Caching**,
    which is the idea of storing some information in a more accessible location if
    we anticipate needing it again in the near future.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们与大型数据库交互时，都应认识到每一次与数据库的交互都是昂贵的。因此，我们希望最小化对数据库服务器的调用次数。以[纽约时报](https://www.nytimes.com/)网站为例。纽约时报可能有一个包含所有文章的数据库，每次有人加载主页时都会查询该数据库，并渲染一些模板，但这样做会浪费资源，因为主页上显示的文章很可能每秒变化不大。我们可以通过使用**缓存**来解决这个问题，即如果我们预计在不久的将来需要再次使用某些信息，就将它们存储在更易于访问的位置。
- en: 'One way that caching can be implemented is by storing data on the user’s web
    browser, so that when a user loads certain pages, no request to the server even
    needs to be sent. One way to do this is by including this line in the header of
    an HTTP response:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的一种实现方式是将数据存储在用户的网络浏览器中，这样当用户加载某些页面时，甚至不需要向服务器发送请求。实现这一点的办法之一是在HTTP响应的头部包含以下这一行：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will tell the browser that when visiting a page, as long as I have visited
    that page within the last 86400 milliseconds, no request has to be made to the
    server. This method is used commonly by web browsers especially with files that
    are less likely to change over short periods such as a CSS file. To take more
    control over this process, we can also add an `ETag` to the HTTP response header,
    which is a unique sequence of characters that represents a specific version of
    a document. This is useful because future requests can include this tag and compare
    it to the tag of the latest document on the server, only returning an entire document
    when the two differ.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉浏览器，当访问页面时，只要我在过去86400毫秒内访问过该页面，就不需要向服务器发送请求。这种方法通常用于浏览器，特别是对于不太可能在短时间内更改的文件，如CSS文件。为了更多地控制这个过程，我们还可以在HTTP响应头中添加一个`ETag`，它是一串唯一的字符序列，代表文档的特定版本。这很有用，因为未来的请求可以包含这个标签，并将其与服务器上最新文档的标签进行比较，只有当两者不同时才返回整个文档。
- en: In addition to the client-side caching discussed above, it can often be helpful
    to include a cache on the server side. With this cache, our backend setup will
    look a bit like the one below, where all servers have access to a cache.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面讨论的客户端缓存外，通常在服务器端包含一个缓存也很有帮助。有了这个缓存，我们的后端设置将类似于下面的一个，其中所有服务器都可以访问缓存。
- en: '![server caching](../Images/1b27b2e8c166821f8cc3bd1d5718e565.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![服务器缓存](../Images/1b27b2e8c166821f8cc3bd1d5718e565.png)'
- en: 'Django provides its own [cache framework](https://docs.djangoproject.com/en/4.0/topics/cache/)
    which will allow us to incorporate caching in our projects. This framework offers
    several ways of implementing a cache:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个自己的[缓存框架](https://docs.djangoproject.com/en/4.0/topics/cache/)，这将允许我们在项目中实现缓存。这个框架提供了几种实现缓存的方法：
- en: '**Per-View Caching**: This allows us to decide that once a specific view has
    been loaded, that same view can be rendered without going through the function
    for the next specified amount of time.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图级缓存**：这允许我们决定一旦加载了特定的视图，该视图可以在不经过下一个指定时间内通过函数的情况下渲染。'
- en: '**Template-Fragment Caching**: This caches specific parts of a template so
    they do not have to be re-rendered. For example, we may have a navigation bar
    that rarely changes, meaning we could save time by not reloading it.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板片段缓存**：这种缓存可以缓存模板的特定部分，这样它们就不需要重新渲染。例如，我们可能有一个很少改变的导航栏，这意味着我们可以通过不重新加载它来节省时间。'
- en: '**Low-Level Cache API**: This allows you to do more flexible caching, essentially
    storing any information you would like to.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级缓存API**：这允许你进行更灵活的缓存，本质上可以存储你想要的任何信息。'
- en: We won’t go into the details here of how to implement caching in Django, but
    do take a look at the [documentation](https://docs.djangoproject.com/en/4.0/topics/cache/)
    if you’re interested!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细介绍如何在Django中实现缓存，但如果您感兴趣，请查看[文档](https://docs.djangoproject.com/en/4.0/topics/cache/)！
- en: Security
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全
- en: Now, we’ll begin to discuss how to make sure our web applications are secure,
    which will involve many different measures that span nearly every topic we’ve
    discussed in this course.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始讨论如何确保我们的Web应用程序安全，这将涉及许多不同的措施，几乎涵盖了我们在本课程中讨论的几乎所有主题。
- en: Git and GitHub
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git和GitHub
- en: One of the greatest strengths of Git and GitHub is how easy they make it to
    share and contribute to **open-source software**, which can be seen and contributed
    to by anyone on the internet. One drawback to this is that if at any point you
    commit a file that includes some private credentials like a password or API key,
    those credentials could be publicly available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Git和GitHub最大的优势之一是它们使共享和贡献**开源软件**变得非常容易，任何互联网用户都可以查看和贡献。这个缺点是，如果你在任何时候提交了一个包含一些私人凭证（如密码或API密钥）的文件，这些凭证可能会公开可用。
- en: HTML
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: 'There are many vulnerabilities that arise from using HTML. One common weakness
    is known as a **Phishing Attack**, which occurs when a user who thinks they are
    going to one page is actually taken to another. These are not necesarily things
    we can account for when designing a website, but we should definitely keep them
    in mind when interacting with the web ourselves. For example, a malicious user
    might write out this HTML:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML会引发许多漏洞。其中一种常见的弱点被称为**钓鱼攻击**，当用户认为他们将要访问一个页面时，实际上却被带到了另一个页面。这些并不是我们在设计网站时可以预见的，但我们在自己与网络互动时应该肯定要考虑到它们。例如，一个恶意用户可能会编写以下HTML代码：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Which acts like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它的作用如下：
- en: '![phishing attack](../Images/a1ea8aa40ec098db2b85eaeb75ee1234.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![钓鱼攻击](../Images/a1ea8aa40ec098db2b85eaeb75ee1234.png)'
- en: The fact that HTML is actually sent to a user as part of a request opens up
    more vulnerabilities, because everyone has access to the layout and style that
    allowed you to create your site. For example, a hacker could go to [bankofamerica.com](https://cs50.harvard.edu/),
    copy all of their HTML, and paste it in their own site, creating a site that looks
    exactly like Bank of America’s. The hacker could then redirect the login form
    on the page so all usernames and passwords are sent to them. (Also, here’s the
    [real Bank of America link](https://www.bankofamerica.com/)–just wanted to see
    if you were checking urls before clicking!)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HTML实际上作为请求的一部分发送给用户，这增加了更多的漏洞，因为每个人都可以访问到允许你创建网站的布局和样式。例如，黑客可以访问[bankofamerica.com](https://cs50.harvard.edu/)，复制他们的所有HTML，并将其粘贴到自己的网站上，创建一个看起来与美洲银行一模一样的网站。然后黑客可以重定向页面上的登录表单，使得所有用户名和密码都发送给他们。（此外，这里还有[真正的美洲银行链接](https://www.bankofamerica.com/)——只是想看看你在点击之前是否检查了URL！）
- en: HTTPS
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS
- en: As we discussed earlier in the course, most interactions that occur online follow
    HTTP protocol, although now more and more transactions use HTTPS, which is an
    encrypted version of HTTP. While using these protocols, information is transferred
    from one computer to another through a series of servers as pictured below.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在课程中讨论的那样，大多数在线交互都遵循HTTP协议，尽管现在越来越多的交易使用HTTPS，这是HTTP的加密版本。在使用这些协议时，信息通过一系列服务器以如图所示的方式从一个计算机传输到另一个计算机。
- en: '![transferring](../Images/a09a4a2b4b8a854214288b5f84d531bc.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![transferring](../Images/a09a4a2b4b8a854214288b5f84d531bc.png)'
- en: There is often no way to ensure that all of these transfers are secure, so it
    is important that all of this transferred information is **encrypted**, meaning
    that the characters of the message are altered so that the sender and receiver
    of the message can understand it, but no one else can.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常没有方法可以确保所有这些传输都是安全的，因此确保所有传输的信息都是**加密的**非常重要，这意味着消息的字符被改变，以便发送者和接收者可以理解它，但其他人不能。
- en: Secret-Key Cryptography
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 秘密密钥密码学
- en: One approach to this is known as **Secret-Key Cryptography**. In this approach,
    the sender and receiver both have access to a secret key that only they know.
    Then, the secret key is used by the sender to encrypt a message which is then
    sent to the recipient who uses the secret key to decrypt the message. This method
    is extremely secure, but it produces a big problem when it comes to practicality.
    In order for it to work, both the sender and the receiver must have access to
    the secret key, which means they must meet in person to exchange a key securely.
    With the number of different websites we interact with on a daily basis, it is
    clear that in-person meetups are not an option.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一种处理方式被称为**秘密密钥密码学**。在这种方法中，发送者和接收者都拥有一个只有他们知道的秘密密钥。然后，发送者使用这个秘密密钥来加密一条消息，并将其发送给接收者，接收者使用秘密密钥来解密这条消息。这种方法非常安全，但当它涉及到实际应用时会产生一个大问题。为了使其工作，发送者和接收者都必须能够访问秘密密钥，这意味着他们必须亲自会面来安全地交换密钥。考虑到我们每天与不同网站互动的数量，很明显，面对面会面不是一个可行的选择。
- en: Public-Key Cryptography
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公钥密码学
- en: 'An incredible advancement in cryptography that allows the internet to function
    as it does today is known as **Public-Key Cryptography**. In this method, there
    are two keys: one is public and can be shared, and the other must be kept private.
    Once these keys are established (there are several different mathematical methods
    for creating pairs of keys which could make up an entire course on their own,
    so we won’t discuss them here), a sender could look up the public key of a recipient
    and use it to encrypt a message, and then the recipient could use their private
    key to decrypt the message. When we use HTTPS rather than HTTP, we know that our
    request is being secured using public-key encryption.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一种在密码学中令人难以置信的进步，使得互联网能够像今天这样运行，被称为**公钥密码学**。在这种方法中，有两个密钥：一个是公开的，可以共享，另一个必须保密。一旦这些密钥被建立（有几种不同的数学方法可以创建密钥对，这本身可以构成一门完整的课程，所以我们在这里不会讨论它们），发送者可以查找接收者的公钥并使用它来加密一条消息，然后接收者可以使用他们的私钥来解密这条消息。当我们使用HTTPS而不是HTTP时，我们知道我们的请求正在使用公钥加密来得到保护。
- en: Databases
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: 'In addition to our requests and responses, we must also make sure that our
    databases are secure. One common thing we’ll need to store is user information,
    including usernames and passwords as in the table below:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的请求和响应之外，我们还必须确保我们的数据库是安全的。我们需要存储的一个常见信息是用户信息，包括用户名和密码，如下表所示：
- en: '![bad table](../Images/0eb7d78f32052cc7a000da51d6db8ac6.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![bad table](../Images/0eb7d78f32052cc7a000da51d6db8ac6.png)'
- en: 'However, you never actually want to store passwords in plaintext in case an
    unauthorized person gets access to your database. Instead, we’ll want to use a
    **hash function**, a function that takes in some text and outputs a seemingly
    random string, to create a hash of each password, as in the table below:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你绝对不希望以明文形式存储密码，以防未经授权的人访问你的数据库。相反，我们将想要使用一个**哈希函数**，这是一个接受一些文本并输出一个看似随机的字符串的函数，为每个密码创建一个哈希值，如下表所示：
- en: '![good table](../Images/7307dbd70cb8ed1d8f707a1a5a6219d1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![good table](../Images/7307dbd70cb8ed1d8f707a1a5a6219d1.png)'
- en: It is important to note that a hash function is **one-way**, meaning it can
    turn a password into a hash, but cannot turn a hash back into a password. This
    means that any company that stores user information this way does not actually
    know any of the users’ passwords, meaning each time a user attempts to sign in,
    the entered password will be hashed and compared to the existing hash. Thankfully,
    this process is already handled for us by Django. One implication of this storage
    technique is that when a user forgets their password, a company has no way of
    telling them what their old password now, meaning they would have to make a new
    one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，哈希函数是**单向的**，这意味着它可以将密码转换为哈希值，但不能将哈希值转换回密码。这意味着任何以这种方式存储用户信息的公司实际上并不知道任何用户的密码，这意味着每次用户尝试登录时，输入的密码将被哈希并与其现有的哈希值进行比较。幸运的是，这个过程已经被Django为我们处理了。这种存储技术的一个影响是，当用户忘记他们的密码时，公司无法告诉他们他们的旧密码是什么，这意味着他们必须创建一个新的密码。
- en: 'There are some cases where you’ll have to decide as a developer how much information
    you are willing to leak. For example, many sites have a page for forgotten passwords
    that looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，作为开发者，你必须决定你愿意泄露多少信息。例如，许多网站都有一个看起来像这样的忘记密码页面：
- en: '![forgotten password?](../Images/04cad4cb2f2a7bc1ccbc94f0a4490d0c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![忘记密码？](../Images/04cad4cb2f2a7bc1ccbc94f0a4490d0c.png)'
- en: 'As a developer, you may want to include either a success or error message after
    submission:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你可能在提交后想要包含成功或错误信息：
- en: '![success message](../Images/3ff2e0d3eac7b3b59381177221dd8de8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![成功消息](../Images/3ff2e0d3eac7b3b59381177221dd8de8.png)'
- en: '![error message](../Images/9c650618924f9903e438873d3246b50c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![错误消息](../Images/9c650618924f9903e438873d3246b50c.png)'
- en: But notice how by typing in emails, anyone could determine who has an email
    registered with that site. This could be totally fine in cases where whether or
    not a person uses the site is inconsequential (maybe Facebook), but extremely
    reckless if the fact that you are a member of a certain site could put you in
    danger (maybe an online support group for victims of abuse).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，通过输入电子邮件，任何人都可以确定谁在该网站上注册了电子邮件。在一个人是否使用该网站无关紧要的情况下（比如Facebook），这可能完全没问题，但如果你是某个网站的成员可能会让你处于危险之中（比如虐待受害者的在线支持小组），这就会非常鲁莽。
- en: Another way data could be leaked is in the time it takes for a response to come
    back. It probably takes less time to reject someone with an invalid email than
    a person with a correct email address and a wrong password.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能泄露的另一种方式是在响应返回所需的时间。拒绝一个电子邮件地址无效的人可能比拒绝一个电子邮件地址正确但密码错误的人更快。
- en: As we discussed earlier in the course, we must be ware of SQL Injection Attacks
    whenever we use straight SQL queries in our code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在课程中之前讨论过的，每次我们在代码中使用直接的SQL查询时，都必须警惕SQL注入攻击。
- en: APIs
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: APIs
- en: 'We often use JavaScript in conjunction with APIs to build single-page applications.
    In the case when we build our own API, there are a few methods we can use to keep
    our API secure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将JavaScript与API结合使用来构建单页应用程序。当我们自己构建API时，我们可以使用一些方法来保持我们的API安全：
- en: '**API Keys**: Only process requests from API clients who have a key you have
    provided to them.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API密钥**：只处理你提供给API客户端的密钥的请求。'
- en: '**Rate Limiting**: Limit the number of requests any one user can make in a
    given time frame. This helps protect against **Denial of Service (DOS) Attacks**,
    in which a malicious user makes so many calls to your API that it crashes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制**：限制任何用户在给定时间段内可以发出的请求数量。这有助于防止**拒绝服务（DoS）攻击**，恶意用户通过向你的API发出大量调用，使其崩溃。'
- en: '**Route Authentication**: There are many cases where we don’t want to give
    everyone access to all of our data, so we can use route authentication to make
    sure only specific users can see specific data.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由认证**：有许多情况下我们不希望让每个人都访问我们的所有数据，因此我们可以使用路由认证来确保只有特定的用户可以看到特定的数据。'
- en: Environment Variables
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: Just as we want to avoid storing passwords in plaintext, we’ll want to avoid
    including API keys in our source code. One common way of avoiding this is to use
    **environment variables**, or variables that are stored in your operating system
    or server’s environment. Then, rather than including a string of text in our source
    code, we can include a reference to an environment variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们想要避免以明文形式存储密码一样，我们也会想要避免在我们的源代码中包含API密钥。避免这种情况的一种常见方法就是使用**环境变量**，或者存储在你的操作系统或服务器环境中的变量。然后，而不是在我们的源代码中包含一串文本，我们可以包含对环境变量的引用。
- en: JavaScript
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'There are a few types of attacks that malicious users may attempt using JavaScript.
    One example is knwon as **Cross-Site Scripting**, which is when a user writes
    their own JavaScript code and runs it on your website. For example, let’s imagine
    we have a Django application with a single URL:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户可能会尝试使用JavaScript进行几种类型的攻击。一个例子是**跨站脚本攻击**，即用户在自己的网站上编写并运行自己的JavaScript代码。例如，让我们想象我们有一个Django应用程序，它有一个单一的URL：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'and a single view:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个单一视图：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This website essentially tells the user what URL they have navigated to:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站本质上告诉用户他们导航到的URL是什么：
- en: '![good path](../Images/52abe2a36b27c353c6f1f1c7f694b200.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![good path](../Images/52abe2a36b27c353c6f1f1c7f694b200.png)'
- en: 'But a user can now easily insert some Javascript into the page by typing it
    in the url:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但用户现在可以通过在URL中输入来轻松地将一些JavaScript插入页面：
- en: '![bad path](../Images/b820901a0e7edb57a9716be38cedbd57.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![bad path](../Images/b820901a0e7edb57a9716be38cedbd57.png)'
- en: While this `alert` example is fairly harmless, it wouldn’t be all that more
    difficult to include some JavaScript that manipulates the DOM or uses `fetch`
    to send a request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个`alert`示例相对无害，但要包含一些操纵DOM或使用`fetch`发送请求的JavaScript并不会更困难。
- en: Cross-Site Request Forgery
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: 'We already discussed how we can use Django to prevent CSRF attacks, but let’s
    take a look at what could happen without this protection. As an example, imagine
    a bank has a URL you could visit that transfers money out of your account. A person
    could easily create a link that would make this transfer:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用Django来防止CSRF攻击，但让我们看看没有这种保护会发生什么。作为一个例子，想象一家银行有一个你可以访问的URL，可以从你的账户中转账。一个人可以轻松地创建一个链接来执行这种转账：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This attack can be even more subtle than a link. If the URL is put in an image,
    then it will be accessed as your browser attempts to load the image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击甚至可能比链接更微妙。如果URL被放在图片中，那么它将在浏览器尝试加载图片时被访问：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because of this, whenever you are building an application that can accept some
    state change, it should be done using a POST request. Even if the bank requires
    a POST request, hidden form fields can still trick users into accidentally submitting
    a request. The following form doesn’t even wait for the user to click; it automatically
    submits!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，每次你构建一个可以接受某些状态变化的应用程序时，都应该使用POST请求。即使银行要求POST请求，隐藏表单字段仍然可以诱使用户意外提交请求。以下表单甚至不需要用户点击；它会自动提交！
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The above is an example of what **Cross-Site Request Forgery** might look like.
    We can stop attacks such as these by creating a CSRF token when loading a webpage,
    and then only accepting forms with a valid token.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了**跨站请求伪造**可能的样子。我们可以通过在加载网页时创建CSRF令牌来阻止此类攻击，并且只接受带有有效令牌的表单。
- en: What’s next?
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'We’ve discussed many web frameworks in this class such as Django and React,
    but there are more frameworks you might be interested in trying:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本课程中讨论了许多Web框架，如Django和React，但还有更多你可能感兴趣的框架：
- en: Server-Side
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端
- en: '[Express.js](https://expressjs.com/)'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Express.js](https://expressjs.com/)'
- en: '[Ruby on Rails](https://rubyonrails.org/)'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby on Rails](https://rubyonrails.org/)'
- en: '[Flask](https://flask.palletsprojects.com/en/1.1.x/)'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Flask](https://flask.palletsprojects.com/en/1.1.x/)'
- en: …
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: …
- en: Client-Side
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: '[Angular JS](https://angularjs.org/)'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Angular JS](https://angularjs.org/)'
- en: '[React](https://reactjs.org/)'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React](https://reactjs.org/)'
- en: '[Vue.js](https://vuejs.org/)'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vue.js](https://vuejs.org/)'
- en: '[React Native](https://reactnative.dev/)'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React Native](https://reactnative.dev/)'
- en: …
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: …
- en: 'In the future, you may also want to be able to deploy your site to the web,
    which you can do through a number of different services:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，你可能还希望能够通过多种不同的服务将你的网站部署到网络上：
- en: '[Amazon Web Services](https://aws.amazon.com/getting-started/hands-on/websites/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Amazon Web Services](https://aws.amazon.com/getting-started/hands-on/websites/)'
- en: '[GitHub](https://github.com/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub](https://github.com/)'
- en: '[Heroku](https://www.heroku.com/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Heroku](https://www.heroku.com/)'
- en: '[Netlify](https://app.netlify.com/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Netlify](https://app.netlify.com/)'
- en: '[Google Cloud](https://cloud.google.com/)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google Cloud](https://cloud.google.com/)'
- en: '[Microsoft Azure](https://azure.microsoft.com/en-gb/)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Microsoft Azure](https://azure.microsoft.com/en-gb/)'
- en: …
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …
- en: We’ve come a long way and covered a lot of material since the beginning of this
    course, but there’s still a lot to learn in the world of web programming. Although
    it can be overwhelming at times, one of the best ways to learn more is to jump
    into a project and see how far you can run with it. We believe that at this point
    you have a strong foundation in the concepts of web design, and that you have
    what it takes to turn an idea into your own working website!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自从这门课程开始以来已经走得很远了，覆盖了大量的材料，但在网络编程的世界里还有很多东西要学习。尽管有时可能会感到压倒性，但学习更多知识的最佳方法之一就是投身到一个项目中，看看你能将它推进多远。我们相信，在这个阶段，你在网络设计概念方面已经打下了坚实的基础，而且你已经拥有了将一个想法转化为你自己的工作网站所需的一切！
