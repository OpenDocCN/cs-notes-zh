- en: Lecture 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6讲
- en: 原文：[https://cs50.harvard.edu/python/notes/6/](https://cs50.harvard.edu/python/notes/6/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/python/notes/6/](https://cs50.harvard.edu/python/notes/6/)
- en: '[File I/O](#file-io)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文件输入/输出](#file-io)'
- en: '[`open`](#open)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`open`](#open)'
- en: '[`with`](#with)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with`](#with)'
- en: '[CSV](#csv)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CSV](#csv)'
- en: '[Binary Files and `PIL`](#binary-files-and-pil)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[二进制文件和 `PIL`](#binary-files-and-pil)'
- en: '[Summing Up](#summing-up)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: File I/O
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: Up until now, everything we’ve programmed has stored information in memory.
    That is, once the program is ended, all information gathered from the user or
    generated by the program is lost.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有程序都是在内存中存储信息。也就是说，一旦程序结束，从用户那里收集的所有信息或程序生成的所有信息都会丢失。
- en: File I/O is the ability of a program to take a file as input or create a file
    as output.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入/输出是程序将文件作为输入或创建文件作为输出的能力。
- en: 'To begin, in the terminal window type `code names.py` and code as follows:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在终端窗口中输入 `code names.py` 并编写以下代码：
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that running this code has the desired output. The user can input a name.
    The output is as expected.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，运行此代码会产生预期的输出。用户可以输入一个名字，输出结果符合预期。
- en: 'However, what if we wanted to allow multiple names to be inputted? How might
    we achieve this? Recall that a `list` is a data structure that allows us to store
    multiple values into a single variable. Code as follows:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果我们想允许输入多个名字呢？我们该如何实现？回想一下，`list` 是一种数据结构，允许我们将多个值存储到单个变量中。按照以下方式编写代码：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the user will be prompted three times for input. The `append` method
    is used to add the `name` to our `names` list.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，用户将被提示三次输入。使用 `append` 方法将 `name` 添加到我们的 `names` 列表中。
- en: 'This code could be simplified to the following:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码可以简化为以下形式：
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that this has the same result as the prior block of code.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这与之前的代码块有相同的结果。
- en: 'Now, let’s enable the ability to print the list of names as a sorted list.
    Code as follows:'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们启用打印名字列表为排序列表的功能。按照以下方式编写代码：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that once this program is executed, all information is lost. File I/O
    allows your program to store this information such that it can be used later.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，一旦程序执行完毕，所有信息都会丢失。文件输入/输出允许你的程序存储这些信息，以便以后使用。
- en: You can learn more in Python’s documentation of [sorted](https://docs.python.org/3/library/functions.html#sorted).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的 [sorted](https://docs.python.org/3/library/functions.html#sorted)
    文档中了解更多信息。
- en: '`open`'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`open`'
- en: '`open` is a functionality built into Python that allows you to open a file
    and utilize it in your program. The `open` function allows you to open a file
    such that you can read from it or write to it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open` 是 Python 内置的一个功能，允许你打开一个文件并在你的程序中使用它。`open` 函数允许你以读取或写入的方式打开一个文件。'
- en: 'To show you how to enable file I/O in your program, let’s rewind a bit and
    code as follows:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了向你展示如何在程序中启用文件输入/输出，让我们回顾一下并编写以下代码：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the `open` function opens a file called `names.txt` with writing
    enabled, as signified by the `w`. The code above assigns that opened file to a
    variable called `file`. The line `file.write(name)` writes the name to the text
    file. The line after that closes the file.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`open` 函数以写入模式打开了一个名为 `names.txt` 的文件，这由 `w` 表示。上面的代码将打开的文件分配给一个名为 `file`
    的变量。`file.write(name)` 这行代码将名字写入文本文件。之后的行关闭了文件。
- en: Testing out your code by typing `python names.py`, you can input a name and
    it saves to the text file. However, if you run your program multiple times using
    different names, you will notice that this program will entirely rewrite the `names.txt`
    file each time.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在终端中输入 `python names.py` 测试你的代码，你可以输入一个名字，并将其保存到文本文件中。然而，如果你使用不同的名字多次运行程序，你会注意到这个程序每次都会完全重写
    `names.txt` 文件。
- en: 'Ideally, we want to be able to append each of our names to the file. Remove
    the existing text file by typing `rm names.txt` in the terminal window. Then,
    modify your code as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望能够将我们的每个名字追加到文件中。在终端窗口中输入 `rm names.txt` 来删除现有的文本文件。然后，按照以下方式修改你的代码：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the only change to our code is that the `w` has been changed to
    `a` for “append”. Rerunning this program multiple times, you will notice that
    names will be added to the file. However, you will notice a new problem!
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们代码中唯一的改变是将 `w` 改为 `a` 以实现“追加”。多次重新运行此程序，你会注意到名字将被添加到文件中。然而，你也会发现一个新的问题！
- en: 'Examining your text file after running your program multiple times, you’ll
    notice that the names are running together. The names are being appended without
    any gaps between each of the names. You can fix this issue. Again, remove the
    existing text file by typing `rm names.txt` in the terminal window. Then, modify
    your code as follows:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行程序多次后检查您的文本文件，您会注意到名字是连在一起的。名字之间没有任何间隔。您可以修复这个问题。再次，通过在终端窗口中键入 `rm names.txt`
    来删除现有的文本文件。然后，按照以下方式修改您的代码：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the line with `file.write` has been modified to add a line break
    at the end of each name.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到带有 `file.write` 的行已经被修改，为每个名字添加了行尾换行符。
- en: This code is working quite well. However, there are ways to improve this program.
    It so happens that it’s quite easy to forget to close the file.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码工作得相当好。然而，有方法可以改进这个程序。它很容易忘记关闭文件。
- en: You can learn more in Python’s documentation of [open](https://docs.python.org/3/library/functions.html#open).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 Python 的 [open](https://docs.python.org/3/library/functions.html#open)
    文档中了解更多信息。
- en: '`with`'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`with`'
- en: The keyword `with` allows you to automate the closing of a file.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 `with` 允许您自动化文件的关闭。
- en: 'Modify your code as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式修改您的代码：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the line below `with` is indented.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `with` 下的行是缩进的。
- en: 'Up until this point, we have been exclusively writing to a file. What if we
    want to read from a file? To enable this functionality, modify your code as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是在向文件中写入。如果我们想从文件中读取呢？为了启用此功能，按照以下方式修改您的代码：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that `readlines` has a special ability to read all the lines of a file
    and store them in a list called `lines`. Running your program, you will notice
    that the output is quite ugly. There seem to be multiple line breaks where there
    should be only one.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `readlines` 具有读取文件中所有行并将它们存储在名为 `lines` 的列表中的特殊能力。运行您的程序，您会注意到输出相当难看。似乎在应该只有一个换行符的地方有多个换行符。
- en: 'There are many approaches to fix this issue. However, here is a simple way
    to fix this error in our code:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多方法可以解决这个问题。但是，这里有一个简单的方法可以修复我们代码中的这个错误：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that `rstrip` has the effect of removing the extraneous line break at
    the end of each line.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `rstrip` 具有移除每行末尾多余换行符的效果。
- en: 'Still, this code could be simplified even further:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，这段代码还可以进一步简化：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that running this code, it is correct. However, notice that we are not
    sorting the names.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到运行这段代码是正确的。然而，请注意我们没有对名字进行排序。
- en: 'This code could be further improved to allow for the sorting of the names:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码可以进一步改进，以允许对名字进行排序：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `names` is a blank list where we can collect the names. Each name
    is appended to the `names` list in memory. Then, each name in the sorted list
    in memory is printed. Running your code, you will see that the names are now properly
    sorted.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `names` 是一个空白列表，我们可以在这里收集名字。每个名字都会追加到内存中的 `names` 列表中。然后，内存中排序列表中的每个名字都会被打印出来。运行您的代码，您会看到名字现在已经被正确排序。
- en: What if we wanted the ability to store more than just the names of students?
    What if we wanted to store both the student’s name and their house as well?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要存储的不仅仅是学生的名字呢？如果我们想存储学生的名字和他们的宿舍呢？
- en: CSV
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV
- en: CSV stands for “comma separated values”.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV 代表“逗号分隔值”。
- en: 'In your terminal window, type `code students.csv`. Ensure your new CSV file
    looks like the following:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的终端窗口中，键入 `code students.csv`。确保您的新 CSV 文件看起来如下：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s create a new program by typing `code students.py` and code as follows:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键入 `code students.py` 创建一个新的程序，并按照以下方式编写代码：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that `rstrip` removes the end of each line in our CSV file. `split` tells
    the interpreter where to find the end of each of our values in our CSV file. `row[0]`
    is the first element in each line of our CSV file. `row[1]` is the second element
    in each line in our CSV file.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `rstrip` 移除了我们 CSV 文件中每行的末尾。`split` 告诉解释器在哪里找到我们 CSV 文件中每个值的末尾。`row[0]`
    是我们 CSV 文件每行中的第一个元素。`row[1]` 是我们 CSV 文件每行中的第二个元素。
- en: 'The above code is effective at dividing each line or “record” of our CSV file.
    However, it’s a bit cryptic to look at if you are unfamiliar with this type of
    syntax. Python has built-in ability that could further simplify this code. Modify
    your code as follows:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码有效地将我们的 CSV 文件中的每一行或“记录”分开。然而，如果您不熟悉这种语法，看起来可能有点晦涩。Python 有内置的能力可以进一步简化这段代码。按照以下方式修改您的代码：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the `split` function actually returns two values: The one before
    the comma and the one after the comma. Accordingly, we can rely upon that functionality
    to assign two variables at once instead of one!'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`split` 函数实际上返回两个值：逗号之前的一个和逗号之后的一个。因此，我们可以依赖这个功能一次分配两个变量而不是一个！
- en: 'Imagine that we would again like to provide this list as sorted output? You
    can modify your code as follows:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们再次希望提供这个列表作为排序后的输出？你可以按照以下方式修改你的代码：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we create a `list` called `students`. We `append` each string to
    this list. Then, we output a sorted version of our list.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个名为 `students` 的 `list`。我们将每个字符串 `append` 到这个列表中。然后，我们输出列表的排序版本。
- en: Recall that Python allows for `dictionaries` where a key can be associated with
    a value. This code could be further improved
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，Python 允许使用 `dictionaries`，其中键可以与值相关联。这段代码可以进一步改进
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we create an empty dictionary called `student`. We add the values
    for each student, including their name and house into the `student` dictionary.
    Then, we append that student to the `list` called `students`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个名为 `student` 的空字典。我们将每个学生的值添加到 `student` 字典中，包括他们的名字和学院。然后，我们将该学生添加到名为
    `students` 的 `list` 中。
- en: 'We can improve our code to illustrate this as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以改进我们的代码来展示这一点，如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that this produces the desired outcome, minus the sorting of students.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这样会产生期望的结果，但排除了学生的排序。
- en: Unfortunately, we cannot sort the students as we had prior because each student
    is now a dictionary inside of a list. It would be helpful if Python could sort
    the `students` list of `student` dictionaries that sorts this list of dictionaries
    by the student’s name.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法像以前那样对学生的列表进行排序，因为每个学生现在都是一个列表中的字典。如果 Python 能够按学生的名字对 `students` 列表中的
    `student` 字典进行排序，那将很有帮助。
- en: 'To implement this in our code, make the following changes:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在我们的代码中实现这一点，进行以下更改：
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that `sorted` needs to know how to get the key of each student. Python
    allows for a parameter called `key` where we can define on what “key” the list
    of students will be sorted. Therefore, the `get_name` function simply returns
    the key of `student["name"]`. Running this program, you will now see that the
    list is now sorted by name.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`sorted` 需要知道如何获取每个学生的键。Python 允许一个名为 `key` 的参数，我们可以定义学生列表将按什么“键”进行排序。因此，`get_name`
    函数简单地返回 `student["name"]` 的键。运行这个程序，你现在会看到列表已按名字排序。
- en: 'Still, our code can be further improved upon. It just so happens that if you
    are only going to use a function like `get_name` once, you can simplify your code
    in the manner presented below. Modify your code as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，我们的代码还可以进一步改进。恰好如果你只打算使用像 `get_name` 这样的函数一次，你可以按照以下方式简化你的代码。按照以下方式修改你的代码：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice how we use a `lambda` function, an anonymous function, that says “Hey
    Python, here is a function that has no name: Given a `student`, access their `name`
    and return that to the `key`.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何使用一个 `lambda` 函数，一个匿名函数，它说：“嘿 Python，这里有一个没有名字的函数：给定一个 `student`，访问他们的
    `name` 并将其作为 `key` 返回。”
- en: 'Unfortunately, our code is a bit fragile. Suppose that we changed our CSV file
    such that we indicated where each student grew up. What would be the impact of
    this upon our program? First, modify your `students.csv` file as follows:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，我们的代码有点脆弱。假设我们改变了我们的 CSV 文件，使得我们指明了每个学生的成长地。这对我们的程序会有什么影响？首先，按照以下方式修改你的
    `students.csv` 文件：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how running our program how will produce a number of errors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运行我们的程序会产生许多错误。
- en: 'Now that we’re dealing with homes instead of houses, modify your code as follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们处理的是家园（homes）而不是学院（houses），按照以下方式修改你的代码：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that running our program still does not work properly. Can you guess
    why?
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，运行我们的程序仍然不能正常工作。你能猜到为什么吗？
- en: 'The `ValueError: too many values to unpack` error produced by the interpreter
    is a result of the fact that we previously created this program expecting the
    CSV file is `split` using a `,` (comma). We could spend more time addressing this,
    but indeed someone else has already developed a way to “parse” (that is, to read)
    CSV files!'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '解释器产生的 `ValueError: too many values to unpack` 错误是由于我们之前创建这个程序时预期 CSV 文件是用逗号（`,`）分割的。我们可以花更多时间解决这个问题，但确实有人已经开发了一种“解析”（即读取）CSV
    文件的方法！'
- en: Python’s built-in `csv` library comes with an object called a `reader`. As the
    name suggests, we can use a `reader` to read our CSV file despite the extra comma
    in “Number Four, Privet Drive”. A `reader` works in a `for` loop, where each iteration
    the `reader` gives us another row from our CSV file. This row itself is a list,
    where each value in the list corresponds to an element in that row. `row[0]`,
    for example, is the first element of the given row, while `row[1]` is the second
    element.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的内置 `csv` 库包含一个名为 `reader` 的对象。正如其名所示，我们可以使用 `reader` 来读取我们的 CSV 文件，即使“四号，紫杉巷”中有多余的逗号。`reader`
    在 `for` 循环中工作，每次迭代时 `reader` 都会从我们的 CSV 文件中提供另一行。这一行本身是一个列表，其中列表中的每个值对应于该行中的一个元素。例如，`row[0]`
    是给定行的第一个元素，而 `row[1]` 是第二个元素。
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that our program now works as expected.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意现在我们的程序按预期工作。
- en: 'Up until this point, we have been relying upon our program to specifically
    decide what parts of our CSV file are the names and what parts are the homes.
    It’s better design, though, to bake this directly into our CSV file by editing
    it as follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖于我们的程序来具体决定 CSV 文件中的哪些部分是名字，哪些部分是家庭地址。然而，更好的设计是将这些直接嵌入到我们的 CSV 文件中，如下所示进行编辑：
- en: '[PRE23]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how we are explicitly saying in our CSV file that anything reading it
    should expect there to be a name value and a home value in each line.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在 CSV 文件中明确指出，任何读取它的人都应预期每行都有一个名字值和一个家庭值。
- en: 'We can modify our code to use a part of the `csv` library called a `DictReader`
    to treat our CSV file with even more flexibilty:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以修改我们的代码，使用 `csv` 库中的一个名为 `DictReader` 的部分，以获得更大的灵活性来处理我们的 CSV 文件：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we have replaced `reader` with `DictReader`, which returns one dictionary
    at a time. Also, notice that the interpreter will directly access the `row` dictionary,
    getting the `name` and `home` of each student. This is an example of coding defensively.
    As long as the person designing the CSV file has inputted the correct header information
    on the first line, we can access that information using our program.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们已经将 `reader` 替换为 `DictReader`，它每次返回一个字典。此外，注意解释器将直接访问 `row` 字典，获取每个学生的 `name`
    和 `home`。这是一个编码防御的例子。只要设计 CSV 文件的人已经在第一行输入了正确的标题信息，我们就可以使用我们的程序访问这些信息。
- en: Up until this point, we have been reading CSV files. What if we want to write
    to a CSV file?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在读取 CSV 文件。如果我们想写入 CSV 文件怎么办？
- en: To begin, let’s clean up our files a bit. First, delete the `students.csv` file
    by typing `rm students.csv` in the terminal window. This command will only work
    if you’re in the same folder as your `students.csv` file.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们清理一下我们的文件。首先，在终端窗口中输入 `rm students.csv` 删除 `students.csv` 文件。此命令仅在你位于
    `students.csv` 文件相同的文件夹中时有效。
- en: 'Then, in `students.py`, modify your code as follows:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在 `students.py` 文件中，按照以下方式修改你的代码：
- en: '[PRE25]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice how we are leveraging the built-in functionality of `DictWriter`, which
    takes two parameters: the `file` being written to and the `fieldnames` to write.
    Further, notice how the `writerow` function takes a dictionary as its parameter.
    Quite literally, we are telling the interpreter to write a row with two fields
    called `name` and `home`.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何利用 `DictWriter` 的内置功能，它接受两个参数：要写入的 `file` 和要写入的 `fieldnames`。此外，注意 `writerow`
    函数接受一个字典作为其参数。实际上，我们是在告诉解释器写入一个包含两个字段名为 `name` 和 `home` 的行。
- en: Note that there are many types of files that you can read from and write to.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，你可以从和写入许多类型的文件。
- en: You can learn more in Python’s documentation of [CSV](https://docs.python.org/3/library/csv.html).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的 [CSV](https://docs.python.org/3/library/csv.html) 文档中了解更多信息。
- en: Binary Files and `PIL`
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制文件和 `PIL`
- en: One more type of file that we will discuss today is a binary file. A binary
    file is simply a collection of ones and zeros. This type of file can store anything
    including, music and image data.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们今天还将讨论另一种类型的文件，即二进制文件。二进制文件简单来说就是由一串零和一组成的集合。这种类型的文件可以存储任何内容，包括音乐和图像数据。
- en: There is a popular Python library called `PIL` that works well with image files.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个流行的 Python 库叫做 `PIL`，它与图像文件配合得很好。
- en: Animated GIFs are a popular type of image file that has many image files within
    it that are played in sequence over and over again, creating a simplistic animation
    or video effect.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画 GIF 是一种流行的图像文件类型，其中包含多个图像文件，这些图像文件会按顺序反复播放，从而创建出简单的动画或视频效果。
- en: Imagine that we have a series of costumes, as illustrated below.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，我们有一系列服装，如下所示。
- en: Here is `costume1.gif`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是 `costume1.gif`。
- en: '![Cat number 1.](../Images/e2f07bf55ef30460a0974f8ebbcf973a.png "costume1.gif")'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![猫编号 1.](../Images/e2f07bf55ef30460a0974f8ebbcf973a.png "costume1.gif")'
- en: Here is another one called `costume2.gif`. Notice how the leg positions are
    slightly different.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这还有一个叫做 `costume2.gif` 的例子。注意腿部位置略有不同。
- en: '![Cat number 2.](../Images/d78e3160c6a18f8c59410c0c1e97ed29.png "costume2.gif")'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![猫编号 2.](../Images/d78e3160c6a18f8c59410c0c1e97ed29.png "costume2.gif")'
- en: Before proceeding, please make sure that you have downloaded the source code
    files from the course website. It will not be possible for you to code the following
    without having the two images above in your possession and stored in your IDE.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已从课程网站下载了源代码文件。如果没有上述两张图像，您将无法编写以下代码。
- en: 'In the terminal window type `code costumes.py` and code as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中输入 `code costumes.py` 并按照以下代码编写：
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that we import the `Image` functionality from `PIL`. Notice that the
    first `for` loop simply loops through the images provided as command-line arguments
    and stores theme into the `list` called `images`. The `1:` starts slicing `argv`
    at its second element. The last lines of code saves the first image and also appends
    a second image to it as well, creating an animated gif. Typing `python costumes.py
    costume1.gif costume2.gif` into the terminal. Now, type `code costumes.gif` into
    the terminal window, and you can now see an animated GIF.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是从 `PIL` 中导入 `Image` 功能。注意第一个 `for` 循环只是简单地遍历提供的命令行参数中的图像，并将它们存储到名为 `images`
    的列表中。`1:` 表示从 `argv` 的第二个元素开始切片。代码的最后几行保存了第一张图像，并将其与第二张图像一起附加，创建了一个动画 GIF。在终端中输入
    `python costumes.py costume1.gif costume2.gif`。现在，在终端窗口中输入 `code costumes.gif`，你现在可以看到一个动画
    GIF。
- en: You can learn more in Pillow’s documentation of [PIL](https://pillow.readthedocs.io/).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 Pillow 的 [PIL](https://pillow.readthedocs.io/) 文档中了解更多信息。
- en: Summing Up
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Now, we have not only seen that we can write and read files textually—we can
    also read and write files using ones and zeros. We can’t wait to see what you
    achieve with these new abilities next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅看到了我们可以以文本方式编写和读取文件——我们还可以使用一和零来读写文件。我们迫不及待地想看看你将如何利用这些新能力取得成就。
- en: File I/O
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: '`open`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`'
- en: '`with`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`'
- en: CSV
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV
- en: '`PIL`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PIL`'
