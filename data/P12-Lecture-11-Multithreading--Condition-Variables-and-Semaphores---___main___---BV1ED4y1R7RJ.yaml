- en: P12：Lecture 11 Multithreading, Condition Variables and Semaphores - ___main___
    - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P12：第11讲 多线程、条件变量和信号量 - ___main___ - BV1ED4y1R7RJ
- en: Alright， we might as well get going， but it seems a little odd。 I'll try not
    to blaster yours out。 Okay， so definitely the day before midterm。 We've got lots
    on your plate。 I can see why some people might not be showing up。 Wouldn't it
    be terrible if this was the day that the screencast failed？
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们还是开始吧，但感觉有点奇怪。我会尽量不把你的问题搞砸。好了，正好是期中前一天。你们有很多事情要做。我能理解为什么有人可能不来。如果今天是录屏失败的那天，那该有多糟糕？
- en: You guys all here would be happy， but everybody else wouldn't be I suppose。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你们这些人都在这里会开心，但我猜你们其他人可能不会吧。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_1.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_1.png)'
- en: A couple things。 First things， no labs this week。 They're instead。 we're just
    asking that you watch a little short video。 It's five minutes long。 Some of you
    have actually already seen it。 If you took CS106A maybe like last summer or two
    summers ago or something。 you might， have also seen it。 But anyway， it's a short
    little video。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几件事。首先，这一周没有实验。相反，我们要求你观看一个简短的视频。它只有五分钟长。有些人实际上已经看过了。如果你可能在去年夏天或者两年前上过 CS106A，或者类似的课程，你可能也看过。但无论如何，这只是一个简短的视频。
- en: literally five minutes and it's other graduates from， Stanford mostly who have。
    we're just going to talk about CS a little bit。 So give it a watch。 That's going
    to be your lab check-in for the week。 Otherwise。 you probably want the hour and
    20 minutes back to study， do work on them， Stanford， Shell， etc。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 字面意思上五分钟，其他的毕业生，主要是斯坦福的毕业生，他们有……我们就聊一点计算机科学。所以，去看看吧。那将是你本周的实验签到。否则，你可能希望用这一个小时二十分钟来学习，做些工作，斯坦福，Shell
    等等。
- en: Alright， so enjoy that and that's what we'll be instead of lab for this week。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，享受吧，这就是本周代替实验的内容。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_3.png)'
- en: The other day， what did I do？ I got confused。 So I teach another class。 Is Mark
    here？
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 前几天，我做了什么？我有点迷惑。嗯，我还教另一门课。Mark 在吗？
- en: I don't see him。 I teach another class and a couple people in this class are
    actually in that class as。 well。 I'm teaching computer science， an introductory
    computer science class。 Now you literally used the example from what happened
    in class the other day as I was talking。 about， hey， guess what？ Sometimes professors
    mess up and they。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我没看到他。我教另一门课，这门课里有几个学生也在这门课上。我教的是计算机科学，一门入门级的计算机科学课程。实际上，昨天我就用课堂上发生的例子作为讲解内容，跟大家说，“嘿，猜猜看？有时候教授也会犯错。”
- en: or they can't fix their live code or they can't， find the bugs and this is exactly
    what happened on Wednesday。 So I apologize about that。 But as promised， I did
    go back and figure out what was going on with that compiled bug。 It was a little
    bit subtle。 Not to say that was a good reason why I didn't figure it out but it
    was a little bit subtle。 as to why the error happened。 Here was the code again。
    This was the error。 We were focusing。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者他们无法修复实时代码，或者他们找不到 bug，这正是周三发生的情况。所以我为此道歉。但正如承诺的那样，我确实回去查找并弄清楚了编译 bug 的原因。问题有点微妙。并不是说这就是我没能解决问题的好理由，但确实有些微妙，关于错误发生的原因。以下是代码。这就是错误所在。我们当时正在专注于此。
- en: I was focusing in the lecture on this line right here。 Ticket age is line 62
    near the end of the line actually which is this line right here， near。 the end
    here。 So let's say right around here。 That turns out to be where the issue was。
    What are we doing here？ We are sending a reference to remaining tickets to a function。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我在讲座中专注于这一行。票证年龄是第 62 行，实际上是这行代码，在末尾附近。所以我们就假设大概在这里。结果证明问题就在这里。我们在这里做了什么？我们将剩余票证的引用传递给一个函数。
- en: to the thread function which， will repackage it and forward it on to the ticket
    agent function。 So that's kind of what's going on there。 There's a little bit
    of C++ black magic under there that happens at that point。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给线程函数，它将重新包装并将其转发到票务代理函数。所以这就是发生的情况。那时，下面有一些 C++ 的黑魔法。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_5.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_5.png)'
- en: But if you look up here， we've got ticket agent and so this is what's going
    on with the remaining。 tickets there。 Anybody notice what might be the issue at
    this point？
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你看这里，我们有票务代理，所以下面就是剩余票证的情况。有人注意到这个时候可能会是什么问题吗？
- en: It wasn't that I just passed it。 I did pass it correctly and it is a reference。
    The problem is that little error message just told me to look here。 It didn't
    say anything about up here and it also explicitly didn't say anything about， a
    type issue。 So what's the type of remaining tickets？ Size T。 What type did I tell
    this to look for？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不是我刚好跳过去了。我确实是正确通过了它，而且是一个引用。问题在于那个错误信息只是让我看这里。它并没有提到上面的部分，也没明确说是类型问题。那么剩余票的类型是什么？`size_t`。我告诉它找什么类型？
- en: Unsigned int which is kind of like a size T except an unsigned long is what
    a size T， is。 So the compiler went， "You're trying to do two different types here。
    Give me a break。"。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsigned int`有点像`size_t`，不过`unsigned long`是`size_t`的类型。所以编译器说：“你在尝试使用两种不同的类型。给我一个休息时间吧。”'
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_7.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_7.png)'
- en: Then gave me some terrible error message about that。 Anyway， that was the issue。
    Once I went back and fixed that made it size_t， ampersand then it worked just
    fine。 Yeah。 so bugs happen to everybody who was ever programmed so don't think
    you're on your。 own when you hit all those bugs。 They're tough to find and they're
    tricky。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后给了我一个可怕的错误信息。总之，那就是问题所在。一旦我回去修正了，把它改成了`size_t`，并且加了`&`，然后就正常工作了。对，程序员都会遇到bug，所以当你遇到那些bug时，不要觉得自己孤单。它们很难找，很棘手。
- en: I had somebody in Offsiers yesterday who had a bug that honestly the only reason
    I figured。 out what it was because I have 25， 30 years worth of program experience。
    It was such a subtle little bug that I thought， "Oh， that one's a hard one to
    find。"， So anyway。 it was a good thing that that person came into Offsiers。 But
    these are things that happen。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 昨天在办公室里遇到一个人，他有一个bug，说实话，只有我有25、30年的编程经验时才能够搞清楚是什么。那是一个非常微妙的小bug，我当时想：“哦，这个问题很难找到。”所以总之，很高兴那个人进了办公室。可是这些问题就是这样发生的。
- en: It's just， you know， bugs are hard， programming， challenging。 So anyway。 there's
    what happened the other day。 All right， so let's move on to a very cool problem
    that if you take a multi-threading。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只不过，像bug很难解决，编程充满挑战。所以，不管怎样，前几天发生了那样的事情。好了，接下来我们来看看一个非常酷的问题，如果你学习多线程的话。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_9.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_9.png)'
- en: or even a multi-processor type class like this one in particular， if you don't
    cover， this problem。 it's kind of like never ever reading a Shakespeare play in
    an English class， somewhere。 Like this is like the quintessential deadlock problem
    for multi-processing， multi-threading。 sort of situations。 It is called the Dining
    Philosophers。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这种多处理器类型的类，如果你没有覆盖这个问题，那就有点像从未在英语课上读过莎士比亚的戏剧。就像这是多处理、多线程这种情况中的典型死锁问题。它被称为“哲学家就餐问题”。
- en: It's actually got a fun name and it's Dining Philosophers。 Here's how it works。
    Let me see if I can get my whiteboard here going。 Here's how it works。 There is
    a table and in the table， okay， my drawings those are terrible by the way。 That's
    supposed to be a circle。 There's a table here。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的名字实际上很有趣，它被称为“哲学家就餐问题”。下面是它的工作原理。让我看看能不能启动我的白板。这个是它的工作方式。桌子上有一些东西，嗯，我画得真差。那个应该是一个圆圈。这里有一张桌子。
- en: There are five philosophers and philosophers have like big brains or whatever。
    There's one， two。 right？ Okay， three over here and then four sitting at this table
    here and then of course they're。 not， I guess there should be， they should be
    even there。 You can see why I was an art major when I did this。 Okay。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个哲学家，这些哲学家大脑非常聪明或者其他的什么。这里是一个，两个，对吧？好的，这里是三个，然后四个坐在这张桌子旁边，当然他们应该是对称的。你可以看出为什么我当时是学艺术的。好了。
- en: five philosophers sitting around the table。 They each have bowls of like spaghetti
    in front of them。 Okay， they each have bowls spaghetti and they want to do a few
    things。 They want to both think and then eat。 Okay， and this is what they do。
    They're going to actually go through this three times。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 五个哲学家坐在桌子旁。他们每个人面前都有一碗像意大利面一样的食物。好吧，他们每个人有碗意大利面，他们想做几件事。他们既想思考，又想吃饭。好吧，这就是他们的做法。他们将实际上重复做这三件事。
- en: They're going to think for a while and then they're going to eat and then they're
    going。 to think again， eat， think again and then eat three times。 And what the
    situation here is is that there are one， I'm going to just kind of draw them。
    like this。 Two， three， four， five forks。 Okay， those are my little forks。 Okay。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 他们会思考一会儿，然后吃一会儿，然后再继续思考，再吃，再思考，然后再吃三次。这里的情况是有一个，我就画给你们看。像这样。两个，三个，四个，五个叉子。好，这些就是我画的小叉子。好的。
- en: and here's how the dining philosophers eat。 If you are， if you are about to
    eat。 you grab the fork on your right and then you grab。 the fork on your left
    and for some reason you eat spaghetti like this， right， which is ridiculous。 This
    should have been， whoever did this should have just used chopsticks because that
    actually。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用餐哲学家的吃饭方式。如果你准备吃饭，你会先拿起右手边的叉子，然后再拿左边的叉子，然后你就会以某种方式吃意大利面，虽然这样很荒谬。其实，这本来就应该是做这个的人直接使用筷子，因为那样。
- en: makes sense and that's a legitimate like you need two chopsticks to eat， right？
    But anyway， well。 the original problem was forks because whoever did it had possibly，
    never heard of chopsticks。 I don't know。 But anyway， point is that it's forks
    in this case。 but they each need one and they're going， to eat for a little while
    and they are going to。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的，这也合情合理，你需要两根筷子才能吃饭，对吧？不过不管怎样，原始的问题是叉子，因为做这个的人可能从未听说过筷子。我也不知道。但无论如何，重点是，这里使用的是叉子，但每个人都需要一个，他们要吃一会儿，然后就会继续。
- en: when they're done eating， put the forks， down in the same order。 they pick them
    up in like right and then left and then， or I guess， in that。 here's the option
    or we'll see what the code does anyway。 But the point is that's what's happening。
    Now， in the end， this， if you do this， like how many people， how many philosophers
    can。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们吃完后，会把叉子放下，按照他们拿叉子的顺序，先是右手再是左手，或者我猜是按照这个顺序。这里有个选择，或者我们看看代码怎么做。但重点是，事情就是这样发生的。现在，最终如果你这样做了，嗯，多少人，多少哲学家可以。
- en: actually eat at the same time？ Two， right？ Like that's the maximum， right？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 两个人能同时吃饭吗？对吧？这就是最大的问题，对吗？
- en: Even though they all might be going for the forks。 Okay？ So that's the big issue。
    Like there's two people that but we want to make it so that they all kind of share
    this。 because we don't know when they're going to be thinking when they're going
    to be trying。 to eat and that's that。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使他们可能都在争抢叉子。好的？所以这是一个大问题。虽然有两个人，但是我们希望能让他们共享这些资源。因为我们不知道他们什么时候在思考，什么时候在尝试吃饭，这就是问题所在。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_11.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_11.png)'
- en: Okay？ So that's the setup for the problem and what we're going to do is we're
    going to just write。 a little code to try to test this out。 Okay？ And try to actually
    write this。 model this in the in-ceivos-phosome。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？这就是问题的设置，我们接下来会写一点代码，尝试测试这个问题。好的？然后尝试在这个模型中实际实现它，试试看。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_13.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_13.png)'
- en: In fact， let's just go straight to code and we will do this。 Dining philosophers
    with deadlock which means we're going to probably cause an issue here。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们直接进入代码，我们将这样做。死锁情况下的用餐哲学家，这意味着我们可能会在这里引发一个问题。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_15.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_15.png)'
- en: Okay？ So here's what's going to happen。 All right， let's start with how a philosopher
    thinks。 Okay？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？那么接下来会发生什么呢？好吧，让我们从一个哲学家是如何思考的开始。好的？
- en: A philosopher thinks by basically in our program basically just taking some
    time， some kind。 of random amount of time to actually go ahead and think。 So we're
    going to do something like this。 Remember we have， we're in threading mode。 This
    will be in a thread by the way。 Each philosopher will get its own thread and we're
    going to do the OS lock。 Okay？
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个哲学家思考的方式基本上是在我们的程序中，就是用一些时间，某种随机的时间来进行思考。所以我们会做类似这样的操作。记住，我们在使用线程模式。顺便提一下，这将会是在一个线程中。每个哲学家都会有自己的线程，然后我们会进行操作系统锁定。好的？
- en: And then we're going to say something like， let's see。 The ID。 Okay？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会说类似这样的东西，看一下。ID。好的？
- en: That's the philosophers ID that we're passing in here。 Zero through four because
    there's five dining philosophers。 Okay？ ID and then starts thinking。 Okay？
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们传入的哲学家ID。0到4，因为有五个用餐的哲学家。好的？ID，然后开始思考。好的？
- en: And when the philosopher is thinking then we have to spend some， we have to
    actually take。 some time to do this。 So we're going to do that and then。 and L
    and then we are going to do OS on lock like。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当哲学家在思考时，我们必须花一些时间来做这个。所以我们将进行这个操作，然后。然后L，然后我们要进行操作系统解锁。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_17.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_17.png)'
- en: that。 Okay？ And then， I don't know why it never， never， well anyway， it doesn't
    do the indentation。 for whatever reason sometimes。 Okay。 So anyway， we're going
    to， we're going to print that out。 Then we are going to do a sleep。 Now in a thread
    you call sleep four and then some number of like milliseconds。 generally， it's
    milliseconds。 So let's sleep for some amount of time。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？然后，我也不知道为什么它从来没有，嗯，好吧，不管怎么样，它有时不会做缩进。无论什么原因。好吧，反正我们要输出那个。然后我们要进行睡眠。在线程中，你调用`sleep`并指定一个类似毫秒的数字。通常是毫秒。所以我们让它睡一段时间。
- en: We have another function that's just going to kind of randomize it。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有另一个函数，它将做一些随机化。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_19.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_19.png)'
- en: It's not really important what it is， but we're going to just get think time
    like that。 Okay？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不重要它是什么，但我们将像这样得到思考时间。好吧？
- en: And then once it's done sleeping， we're going to say same thing， OS lock， ID，
    done， all。 done thinking。 Okay？ And L and OS on lock。 All right。 That's all the
    philosopher has to do to think。 Okay？ Pretty straightforward。 All right。 All right。
    And to eat。 we're going to use our mutex that we learned about last time。 Okay？
    Remember what a mutex is。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦它完成睡眠，我们将说同样的事情，操作系统锁，ID，完成，全部。完成思考。好吗？然后L和操作系统解锁。好吧。这就是哲学家思考时需要做的所有事情。好吗？非常直接。好了。好了。然后吃饭时，我们将使用上次学习的互斥锁。好吗？记得互斥锁是什么吧。
- en: A mutex is a data structure such that many different threads might be trying
    to grab。 control of that lock in the data structure。 The other ones， if they。
    if it's already locked when they try to grab control， they just wait。 around until
    it unlocks and then they try to grab it again。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁是一种数据结构，许多不同的线程可能会尝试获取该数据结构中的锁。其他线程如果在尝试获取控制时发现锁已经被占用，它们就会等待，直到锁被解开，然后它们会再次尝试获取它。
- en: And at that point you might have contention between the two。 So because we've
    got two forks。 we're going to have a left fork and a right fork。 And we are going
    to have the philosophers actually try to eat。 So what we're going to do， they're
    going to pick up the left one as it turns out first。 I think I might have said
    right before。 They are going to do the left lock。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，可能会发生两个哲学家之间的竞争。因为我们有两把叉子，我们将有一把左叉和一把右叉。哲学家们将尝试吃饭。所以我们将这样做，他们会首先拿起左叉。其实我之前可能说的是右叉。他们将进行左叉锁。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_21.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_21.png)'
- en: Okay？ And then right lock。 Okay？ And then we're going to say， okay， look。 At
    this point now they can start to sleep or they can start to eat， which is kind
    of sleeping。 in this case。 Okay？ So they're going to say， oops， ID starts eating。
    Okay。 Nom， nom， nom。 nom like that。 Okay。 And L and then OS on lock like that。
    Okay。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？然后右叉锁。好吧？然后我们会说，好吧，看。到这个时候，他们可以开始睡觉，或者开始吃饭，这在这个例子中相当于睡觉。好吧？他们会说，哎呀，ID开始吃饭。好，吃吃吃，像这样。好了。然后L，然后是操作系统解锁。好。
- en: And we're going to model this by again doing some sleep for thread wave sleeping
    for get， each time。 A slightly different one which just basically says some amount
    of time that is going to。 get in fact， I just realized I actually didn't call
    the function up here。 There we go。 Okay。 So we're going to do sleep free time。
    And then we're going to say， see out OS lock， ID。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过再次进行一些睡眠模拟线程波动来建模，每次都稍微不同，基本上是说某个时间段。实际上，我刚刚意识到我其实没有在这里调用函数。好了。好了。现在我们要做的是睡眠空闲时间。然后我们会说，看看操作系统锁，ID。
- en: all done eating。 And L and then OS on lock like that。 And then of course now
    we're done eating so we can put the forks back down。 We are going to do it in
    the same order。 We picked them up and as it turns out。 So left dot unlock and
    right dot unlock。 Okay。 Now we are going to have to pass the forks that are next
    to the dining philosophers in。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 吃完了。然后L，然后是操作系统解锁。然后当然，现在我们吃完了，可以把叉子放回去了。我们将按照我们捡起它们时的顺序放回去。事实证明，左叉解锁和右叉解锁。好了。现在我们得传递下一个餐桌旁边的哲学家的叉子。
- en: there。 Right？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里。对吧？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_23.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_23.png)'
- en: So if you looked at that circle again before， right， it's whichever one， whichever
    two forks。 were next to a particular philosopher here and here is the left for
    this one and the。 right for that。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你再看一看之前的那个圆圈，没错，就是那两个叉子。是哪个哲学家的旁边的那两个叉子，这里是这个哲学家的左边叉子，而那是右边叉子。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_25.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_25.png)'
- en: Okay。 All right。 So that's how that works。 And that's the， that is the eat function。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好了。就是这样工作的。那就是吃饭函数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_27.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_27.png)'
- en: Okay。 Let's go and look at what a philosopher actually does。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们去看看哲学家实际上是做什么的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_29.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_29.png)'
- en: Okay。 A philosopher does the following。 The philosopher is four size t i equals
    zero。 i is less than three， i plus plus。 Remember， they're going to do this three
    times in a row。 What are they going to do？ They are going to think and then they
    are going to eat and we have to pass in the left。 and be right。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。一个哲学家做如下操作。哲学家的大小为t的i等于0，i小于3，i加1。记住，他们会连续做三次。那他们要做什么呢？他们会先思考，然后吃饭，我们需要传入左边的和右边的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_31.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_31.png)'
- en: Okay。 So far so good on what's going on there。 Okay。 That's what's happening。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，事情进展得还不错。好的。就是这样发生的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_33.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_33.png)'
- en: That's a philosopher。 Now we have to do our main function here。 Okay。 And the
    main function。 we have to set up these mutexes for each fork。 Okay。 So let's do
    that。 Mutex forks will do five of them。 Okay。 And then we'll have philosophers。
    We'll have five of them。 Okay。 And then four size t i equals zero， i is less than
    five， i plus plus。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个哲学家。现在我们需要做的是主函数。好的。在主函数中，我们需要为每个叉子设置互斥锁。好的，那我们就来做吧。互斥锁叉子，我们会做五个。好的。然后我们会有哲学家。我们会有五个。好的，然后是四个大小为t的i等于0，i小于5，i加1。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_35.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_35.png)'
- en: Okay。 And in here we're going to actually launch each thread like we've done
    in the past before。 here。 Okay。 What we want to do though first is we need to
    set up which who gets what fork， right？
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。在这里我们将实际启动每个线程，就像我们以前做过的那样。这里。好的。不过我们想先做的是，我们需要设置好谁拿到哪个叉子，对吧？
- en: So we can do mutex left， oops， left equals forks i。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以做互斥锁左，哎呀，左等于叉子i。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_37.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_37.png)'
- en: Okay。 And then we can do， oops， maybe I need a semicolon there， mutex right
    equals forks i。 this way， i plus one， mod five。 Right？ That'll just give you the
    one around the corner。 the other side。 Okay。 The mod in there wraps around if
    necessary。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们可以做，哎呀，也许我需要一个分号，互斥锁右等于叉子i。这个时候，i加1，模5。对吧？那样就会给你角落那边的那个叉子。另一边。好的。里面的模运算会在必要时进行环绕。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_39.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_39.png)'
- en: Okay。 And then we actually have to do philosophers i equals threads。 And now
    we're calling thread that we are， or we're setting up a thread。 Philosopher was
    the name of the philosopher， I just believe， right？ The name of the function。
    And then we are passing in the id。 We are passing in a reference to the left。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然后我们实际上需要做的是哲学家的线程i等于线程。现在我们在调用线程，或者说我们正在设置一个线程。哲学家是哲学家的名字，我相信，没错吧？就是函数的名字。然后我们传入的是id。我们传入的是左边的引用。
- en: a reference to the right。 And we are passing in a ref permits。 Okay。 And then，
    oops， sorry。 Not permits wrong， wrong， looking at the wrong one here。 We're passing
    in just a reference to the right， reference to the right。 And that's it。 That's
    all we need。 Okay。 All right。 After you do all the threads， you need to join them
    all。 Okay。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的引用。然后我们传入的是一个许可的引用。好的。然后，哎呀，抱歉。不是许可，错了，错了，看错了。我们传入的只是右边的引用，右边的引用。就是这样。就是我们需要的全部。好的。好了，在你做完所有线程之后，你需要将它们全部连接起来。好的。
- en: So another for size t i equals zero， i is less than five， five plus plus。 And
    you can just do。 can we do it that way？ We'll do it the way we did before。 Like。
    the way we've been doing it in the past was just thread， ampersand t equals， thread，
    ampersand。 well， call p for philosophers， doesn't really matter。 Philosophers
    and then p。join like that。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以另一个大小为t的i等于0，i小于5，i加1。你可以这么做。我们能这么做吗？我们还是像以前那样做吧。像以前做过的那样就是线程，&t等于，线程，&。嗯，叫p代表哲学家，也没关系。哲学家然后p。就这样连接。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_41.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_41.png)'
- en: And then we can return。 Okay。 So that's our whole program。 And it's going to
    set it up so the world。 Let's see what happens when we run it。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以返回。好了，这就是我们的完整程序。它会设置好，所以世界上会发生什么呢？让我们看看运行它会发生什么。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_43.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_43.png)'
- en: Okay。 Make dining philosophers with deadlock。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们来做一个死锁的用餐哲学家问题。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_45.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_45.png)'
- en: Of course there's an error。 Of course there's an error。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然会出错。嗯，当然会出错。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_47.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_47.png)'
- en: Let's see。 [laughter]， [inaudible]， On 82 and 83 like that to me。 And that we
    are trying to， yes。 Thank you very much。 Although did that。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。[笑声]，[听不清楚]，在82和83那个时候是这样的。我们正在尝试，没错。非常感谢。尽管做了那个。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_49.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_49.png)'
- en: Oops。 Ah。 That make。 Ah。 Thank you very much。 Okay。 So anyway。 if we do dining
    philosophers with deadlock， if we do that， now you'll watch。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。啊。那就变得。啊。非常感谢。好了，总之，如果我们做死锁的用餐哲学家问题，如果我们这么做，你会看到。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_51.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_51.png)'
- en: And it actually seems to go all right。 Okay。 We go， oh， our program is correct。
    Right？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其实似乎还挺顺利的。好了，我们走吧，哦，我们的程序是正确的。对吧？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_53.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_53.png)'
- en: What happened was， let's look at exactly what happened here。 Okay。 Zero start。
    They all start thinking。 And then three happen to finish first as it turns out
    because of the timing or whatever。 And then it starts， and three start eating。
    So three grab the left fork and the right fork。 I should go back because you guys
    left them right。 And then did that。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么，咱们来看看究竟发生了什么。好了，零开始。大家都开始思考。然后三号恰好先完成，因为时间的原因或者其他什么原因。然后开始了，三号开始吃饭。于是三号抓起了左叉和右叉。我应该回去，因为你们把它们放对了。然后做了这个。
- en: And they all ended up working just fine。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 他们最终都能正常工作。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_55.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_55.png)'
- en: Okay。 And you might say， "Hey， this is great。 We're done。"。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。你可能会说，“嘿，这太棒了，我们完成了。”
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_57.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_57.png)'
- en: But what happens if we artificially put in a race condition that would like
    not be a。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果我们故意引入一个竞态条件，像是这样的话，那会怎么样呢？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_59.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_59.png)'
- en: very good， like it would make it so that they all try to start eating at the
    same time。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好，像是这样会让他们都试图在同一时间开始吃饭。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_61.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_61.png)'
- en: Okay。 What if we did the following？ Okay。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那如果我们做了以下的事情呢？好了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_63.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_63.png)'
- en: What if we put a little sleep for， let's say five seconds in there。 Five seconds。
    Right in there。 Basically saying all of them are going to do a little bit of waiting
    and they're all。 going to try to eat at the same time。 And then they're all going
    to grab their left forks at the same time。 Can you kind of see what's going to
    happen here？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在里面加一点延迟，假设五秒钟。五秒钟。就在这里。基本上就是说，他们都得稍微等一下，然后他们都将尝试同时吃饭。然后他们都会同时抓起左叉。你能大概看出会发生什么吗？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_65.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_65.png)'
- en: Make dining for us strong and that。 Okay。 Well， they all get to a point where
    they all think and someone will get done in various。 orders but then they're waiting
    around after they pick up their left fork until each one。 of them picks up a left
    fork。 Well， what's the next thing they're trying to do？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来强化用餐的条件。好了，他们都会有一个时间点，每个人都在思考，然后某些人会先做完，但是接着他们在拿起左叉后等待，直到每个人都拿起了左叉。那么，接下来他们尝试做的是什么呢？
- en: They're waiting for them。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在等待他们。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_67.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_67.png)'
- en: They're trying to pick up the right fork。 Right？ So if we go back to our diagram
    here， right。 we've got this one。 Let's go from the top here。 This one picks up
    their left fork which is this one and then this one picks up left and。 then left
    and then left and then left。 And then this one goes and tries to pick up the right
    fork at some point。 Well this one is not there because the other ones are all
    waiting to pick up their right。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 他们正在尝试拿右边的叉子。对吧？所以如果我们回到我们的图示，看看，从上面开始，这个人拿起了左边的叉子，也就是这个，接着这个人拿起左边的叉子，然后依次是左边、左边、左边。然后这个人去尝试拿右边的叉子。好吧，这个叉子没了，因为其他人都在等着拿他们的右叉子。
- en: forks as well。 They just pick them up。 This is deadlock。 Right？
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 叉子也是如此。它们只会拿起来。这就是死锁。对吧？
- en: It's deadlock specifically because everybody's waiting on everybody else to
    be done eating。 because you've only got those five forks and there's five people
    vying for them。 Okay？
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是死锁，特别是因为每个人都在等别人吃完。因为你只有那五把叉子，而五个人在争抢它们。明白了吗？
- en: So do you see what the issue is？ Right？ The deadlock actually ends up happening。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你明白问题出在哪了吗？对吧？死锁最终会发生。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_69.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_69.png)'
- en: Okay？ And what we want to do is we want to try to avoid that。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？我们要做的就是尽量避免这种情况。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_71.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_71.png)'
- en: Okay？ Because when you have these kind of race conditions that lead to something
    like this。 you're going。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？因为当你遇到这种竞态条件导致这样的情况时，你就会……
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_73.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_73.png)'
- en: to be in trouble。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到麻烦了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_75.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_75.png)'
- en: So we end up having to have to do quick that。 Okay？ All right。 So this is all
    the code that we just just went through。 And here's an important part by the way。
    We should be able to insert the sleep forecall pretty much anywhere in a thread
    and not have。 it matter to the rest of the program。 Like that's one of the ways
    to check for deadlocks and for other kind of race conditions。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们最终不得不快速处理它。好吧？好了，这就是我们刚刚讲过的所有代码。顺便提一下，这是一个重要的部分。我们应该能够在任何线程中几乎随便插入 sleep
    调用，并且不会影响程序的其他部分。这就是检测死锁和其他竞态条件的一种方法。
- en: You just say， look， let's artificially make it such that some weird condition
    happens where。 you could end up doing that。 Okay？ Questions？ [inaudible]， Yeah，
    the good question。 Did we get lucky that it worked before？ Yeah， you just kind
    of got lucky。 The odds are pretty good the way we set up the timing that it turns
    out that all five。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要说，看，我们就人为地让某些奇怪的条件发生，这样你就能最终做到。好吧？有问题吗？[听不清]，是的，问得好。之前它能正常工作是运气好吗？是的，你确实算是运气好。我们设定的时机相当好，结果是五个人都能成功拿到叉子。
- en: won't be trying to eat at exactly the same time until。 And even if one ever
    gets both forks。 well then they're going to be done eating and that， will open
    it up for others and so forth。 But there is that weird condition where they all
    go for the left fork at the same time。 Oops。 now you've got five forks and everybody's
    waiting for that other fork and nobody's eating。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不会在完全相同的时间尝试吃东西。即使某个人拿到了两把叉子，那么他们就会吃完，这也会让其他人有机会吃。可是有一个奇怪的情况，就是他们会同时去拿左边的叉子。哎呀，现在你有五把叉子，而每个人都在等另外一把叉子，结果谁也吃不成。
- en: and that's the issue。 Yeah。 Does lock ever return value？ Does lock ever return
    value？
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是问题所在。是的。lock 有没有返回值？lock 有没有返回值？
- en: I don't believe lock has a return value at all。 I just think it， I think it's
    void。 If it does。 we really never use it。 There's no way to feel like， oh。 the
    fork's taken and don't think of it before。 There's a drop over it。 Oh no。 can
    you check a lock before you do that？ In this case， it really wouldn't matter。
    I mean。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认为 lock 会有返回值。我觉得它是 void 类型。如果有，我们其实从来没有使用过它。没有办法感觉到，“哦，叉子被拿走了”，而不考虑它之前。它已经被丢弃了。哦不。你能在执行前检查
    lock 吗？在这种情况下，其实没有什么关系。我的意思是。
- en: because what are you going to do there？ I mean， I guess you could， I guess you，
    if you， yeah。 it's not a bad idea。 I hadn't thought about that。 If you like somehow
    check and see， wait。 are all them taken？ All of them taken。 If you keep track
    of them， yeah。 and that's kind of what we're going to do。 Like keep track of them
    in the bigger picture。 Yeah。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你打算怎么办呢？我的意思是，我猜你可以，如果你，嗯……这不是个坏主意。我之前没想到过。如果你以某种方式检查一下，等等。所有叉子都拿完了吗？如果你能追踪它们，嗯，是的。那就是我们要做的事。就像在更大的背景下追踪它们。是的。
- en: '[ Inaudible ]， Yes， the question is when you do sleep for 5，000， that''s saying
    by five seconds。 everyone''s， going to be done thinking trying to grab their left
    fork。 Okay。 And remember。 they only grab their left fork first， right？ And they
    already did that。 Sorry。 they already all grabbed the left fork or at least they''re
    trying to。'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清楚]，是的，问题是，当你睡五秒钟时，意味着大家在五秒内都会停下来，尝试抓住他们的左叉子。好的。记住，他们首先只会抓左叉子，对吧？而他们已经都抓住了左叉子，或者至少他们在尝试抓。'
- en: And then they're waiting around to grab the right one。 By that time。 everybody
    has grabbed the left fork and that's that。 Other questions？ Okay。 We get this
    idea though。 This is the classic， like you will at some point again here， dining
    philosophers and go， oh。 I know what that is。 Right？ I know all about that。 And
    that's where it happened。 So。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们就在等待抓住合适的叉子。到那个时候，大家都已经抓住了左叉子，问题就解决了。还有其他问题吗？好的，我们明白这个思路了。这就是经典的，你会在某个时候再次听到的“就餐哲学家”问题，哦，我知道那是什么了，对吧？我完全了解这个问题。就是这里发生的事情。所以。
- en: how are we going to actually fix it？ Well， new Texas are going to probably be
    one way to solve this。 We just need to have some more logic in there to make it
    so that it actually works。 Okay。 So。 what we kind of talked about， it's impossible
    for three philosophers to be eating at the， same time。 right？ You can only have
    two philosophers eating at the same time。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么解决这个问题呢？好吧，新技术可能是解决这个问题的一种方式。我们只需要在其中加入一些逻辑，让它能够正常工作。好的。那么，我们刚才讨论过，三个哲学家不可能同时吃饭，对吧？你只能有两个哲学家同时吃饭。
- en: But you could have four philosophers trying to eat at the same time。 But as
    long as there are all five trying to eat at the same time， somebody will be able。
    to get that other fork and start eating。 Does that make sense？
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可能会有四个哲学家同时尝试吃饭。但只要五个人都在尝试同时吃饭，总会有人能够拿到另一只叉子并开始吃饭。这个说得通吗？
- en: If you have four of them and the fifth one is just kind of waiting around not
    doing anything， yet。 at least one of those four will be able to eat。 It may not
    be two in that case。 but at least one of them will be able to eat。 Does that make
    sense？ There's some。 I'd see some people going， "Oh， it doesn't quite。 Think that
    one through it for a second。"， Right？
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有四个哲学家，而第五个哲学家只是站在一旁，什么也不做，那么至少有一个哲学家会吃到东西。虽然那时可能不会是两个人同时吃饭，但至少有一个人能吃东西。这个理解了吗？有些人可能会觉得，“哦，这个不太对，想一想再说。”对吧？
- en: The diagram might help a little bit more。 Right？ As long as one of them is not，
    you know。 say this one is not eating at all， not doing anything。 then this one
    will eventually be able to get its right fork。 Okay？ All right。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图可能会稍微帮到一点。对吧？只要其中一个人没有，比如说这个人根本没在吃东西，也没做任何事情，那么这个人最终就能拿到他的右叉子。好吗？好了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_77.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_77.png)'
- en: So， that's so we can do that。 Now， we could do this in a couple of different
    ways when we're going to actually solve this。 You could say， "Well， let's just
    make it so that only two can ever eat at the same time。"。 That's fine。 I mean，
    that would probably be relatively efficient。 but you could also make the argument
    that， "Well， we don't know how long any of them are going to be waiting。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以这样做。现在，当我们实际解决这个问题时，有几种不同的方法可以选择。你可以说，“好吧，我们就只允许两个哲学家同时吃。” 那样也可以。那样可能会相对高效，但你也可以辩称，“我们不知道他们中的任何一个人会等待多久。”
- en: so let's at least， make the maximum number possible be able to eat so that it
    kind of continues through。"， There's arguments on both sides。 We're going to go
    with the preference to say。 "Let's make a limited amount of bottleneck， and it
    will just make sure that we can't do deadlock。"。 And that would be， "Let four
    of them vie for it。 Just make the fifth one have to wait。"， Okay？
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，至少让最多的人能吃到东西，这样它才会继续进行下去。这个问题双方都有争议。我们会选择偏向说，“让我们制造一个有限的瓶颈，它只会确保我们避免死锁。”
    那样的话，“就让四个人争抢吧，让第五个人等着。” 好吗？
- en: That's what we're going to end up doing。 Okay。 So， how are we going to do this？
    Well。 we are going to introduce an idea of a permission slip。 Okay？
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们最终要做的事情。好的，那么我们该怎么做呢？嗯，我们将引入一个“许可条”的概念。好吗？
- en: And the permission slip is basically going to be basically saying， "Hey， there's
    going。 to be four permission slips。 The first four philosophers who get those
    permission slips are going to be able to try。 to eat。 They're going to be able
    to vie for those forks。"。 The fifth one just has to wait until one of the other
    ones is done eating。 Then we'll have that。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许可单基本上就是说，“嘿，将会有四个许可单。前四个获得这些许可单的哲学家将能尝试吃饭。他们将争夺这些叉子。”第五个哲学家则必须等到其他人吃完后才能吃饭。然后我们就会有这样的情况。
- en: Okay？ We're going to call it permits in this case， okay？ Permission slips。 And
    we're just going to use a counter to count them up and down。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？我们这次会把它叫做`permits`，好吧？许可单。我们将用一个计数器来对它们进行计数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_79.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_79.png)'
- en: Okay？ So let's actually look at this。 Dining philosophers with， we'll call it
    busy waiting。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？那么我们来看看这个问题。带有**忙等待**的餐厅哲学家问题。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_81.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_81.png)'
- en: Do we like busy waiting？ No。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢忙等待吗？不喜欢。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_83.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_83.png)'
- en: Well， we've got to get there。 We'll get to trying to fix that in a little bit。
    Okay？
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们必须解决这个问题。稍后我们会尝试解决它。好的？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_85.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_85.png)'
- en: But let's see how we might solve this first of all。 Okay？ Some of the things
    are the same。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是让我们看看我们如何解决这个问题。好的？有些事情是相同的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_87.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_87.png)'
- en: So I'm not like， "Think is exactly the same。 I haven't changed that at all。"。
    We're going to have a wait for permission and a grant permission。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我不是说，“它完全一样，我一点都没改。”我们会有一个等待许可和一个授予许可的过程。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_89.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_89.png)'
- en: But before we do that， let's actually set up main first。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们做这些之前，让我们先设置`main`函数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_91.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_91.png)'
- en: Most of main is going to be roughly the same。 Okay？
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的`main`部分将大致相同。好的？
- en: But some of main is going to be a little different。 We're still going to have
    five forts。 we're still going to have five philosophers and so， forth。 Okay？
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`main`部分会稍微有所不同。我们还是会有五个叉子，还是会有五个哲学家，依此类推。好的？
- en: But what we're going to do now is we're going to say size t permits equals four
    because。 we're saying we're going to start out and there's going to be four permits。
    And every time a philosopher grabs， like gets a permit， that number is going to
    go down。 And when it gets to zero， too bad， there's no more permits left。 Makes
    sense？ Okay。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们要做的是，我们要设定`size t permits`等于四，因为我们说我们要开始时会有四个许可。每当一个哲学家获得一个许可时，这个数字会减少。当它减少到零时，很遗憾，没有剩下的许可了。明白了吗？好。
- en: So that's what we're going to do there。 Okay？ We're still going to have the
    forks set up like this。 Okay？ We are also going to have another mutex for the
    permits lock。 Okay？ Well。 if we have a permit and if we have this permit variable
    and any of the threads are。 going to try to modify it， we better lock around that
    so that they don't both try to。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们会这么做。好的？我们还是会像这样设置叉子。好的？我们还将拥有另一个用于`permits`锁的互斥锁。好的？如果我们有一个许可，并且如果我们有这个许可变量，并且任何线程要修改它，我们最好在修改时加锁，以避免它们同时修改。
- en: modify it and we get a race condition there。 So that's another issue with race
    condition that we're going to have to fix that。 Okay？ Same thing， we're going
    to start all them， we're going to get the left and the right。 Nothing's going
    to change there。 What we are going to change now is we're going to do the same
    thing。 Philosopher i equals thread as before。 Okay？ We're still going to same
    function。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果修改它，我们就会遇到竞态条件。所以这是我们必须解决的另一个竞态条件。好的？同样的事情，我们将启动所有线程，获取左边和右边的叉子。那里不会有变化。我们现在要做的变化是做同样的事情。哲学家`i`等于线程，如之前一样。好的？我们仍然会使用相同的函数。
- en: We'll write those in a minute or finish those up in a minute。 Perfur and i and
    a ref for the left and a ref for the left and a ref for the right。 And we are
    also going to have to send a ref for the permits because we have the permits。
    and we're also going to have to send a ref for the permits lock as well。 Okay？
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们待会儿会写这些，或者稍后完成它们。`Perfur`和`i`，左边的引用和右边的引用。我们还需要传递一个`permits`的引用，因为我们有这些许可。同时，我们还需要传递一个`permits
    lock`的引用。好的？
- en: Because now we have to send more information so that they can actually use these
    permits。 effectively。 Okay？ And then we're still going to join them at the end。
    So is permits a sort of global variable for the permits？
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在我们必须传递更多信息，这样它们才能有效地使用这些许可证。好吗？然后我们最后还会将它们连接起来。那么，许可证是类似全局变量的东西吗？
- en: Is permits a global variable for the permits？ It's not a global variable but
    it is going to be passed to each philosopher so that each。 three is one。 Is it
    the same， it's the same actual variable for each one。 Remember threads can share
    variables in the same space。 So yes。 it's exactly the same one and that's how
    it's going to work because all the threads。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证是一个全局变量吗？它不是全局变量，但它会传递给每个哲学家，所以每个哲学家都有一个。它们是相同的变量。记住，线程可以共享同一空间中的变量。所以是的，它们完全是相同的，这就是它工作的方式，因为所有线程共享同一变量。
- en: are going to go， hey， are there any permits left？ Oh， I'm going to grab them。
    And it's going to use the other。 Say again？ When one philosopher takes the permit。
    the other sees a change。 Yes， you'll see how that works but exactly。 Okay？
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要走了，嘿，还有剩下的许可证吗？哦，我去拿它们。然后它会使用另一个。再说一遍？当一个哲学家拿到许可证时，另一个看到变化。是的，你会看到它是如何运作的，没错。好吗？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_93.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_93.png)'
- en: It's exactly what's going on there。 Okay。 So let's go change， modify some of
    these other ones here。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是正在发生的事情。好吗？那么让我们去修改一下其他的部分。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_95.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_95.png)'
- en: Let's go modify。 We've got think。 Eat is going to have to change a little bit。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改一下。我们得想想。吃饭的部分需要稍微改动一下。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_97.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_97.png)'
- en: Let's do that one right now。 Okay？ For eat， we're basically going to have to
    get permission。 So let's create a function and we'll do that in a minute。 We'll
    say wait for permission。 Wait for permission。 We're going to pass in permits to
    this function and then we're going to pass in permits lock。 as well。 Okay？ And
    then if we get a permission slip， then we can go and do our locking。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就来做这个。好吗？对于吃饭的部分，我们基本上需要获得许可。所以让我们创建一个函数，我们稍后再做。我们会说等待许可。等待许可。我们将传递许可证到这个函数中，然后我们也会传递许可证锁。好吗？然后如果我们拿到许可，我们就可以开始锁定了。
- en: That's actually going to work just fine。 Okay？ Then after we are done eating，
    we can say okay。 well let's give back like our permit。 So basically we can say
    grant。 We'll have a one called grant permission and this will be permits and it
    will be permits。 lock again， same sort of thing。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就能正常工作了。好吗？然后在我们吃完之后，我们可以说好吧，让我们归还许可证。所以基本上我们可以说授予。我们会有一个叫做授予许可的函数，这个函数会传递许可证，并且它会传递许可证锁，再次是相同的操作。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_99.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_99.png)'
- en: Okay？ And then after that is when we can do the unlocking lock。 Okay？
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？然后在那之后我们就可以进行解锁操作了。好吗？
- en: So it's going to wrap those in the get a permission slip and then give one back。
    Question。 I don't know if you have to unlock the permit after you go to sleep。
    Like isn't it deadlock about locking the force？ So could we unlock for a minute
    after you've locked our force？
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它会将这些包装在获取许可和归还许可的操作中。问题是，我不确定你在睡觉之后是否需要解锁许可证。就像是锁叉子时是不是会导致死锁？那么，我们可以在锁定叉子之后解锁一会儿吗？
- en: Good question。 So the question is can we， could we unlock it after we've locked
    the forks？ Well。 I guess you could but then you still might have a race condition
    in there。 You still might have a race condition where， let's see， in that， yeah，
    I think in that。 case you still could get to a point where you're all still trying
    to get the same one。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。那么问题是，我们可以在锁定叉子之后解锁它吗？嗯，我想你可以，但那样你还是可能会有竞争条件。你仍然可能会有竞争条件，比如说，在这种情况下，你还是可能会遇到所有人都想获得同一个叉子的情况。
- en: even though you have a permit。 Maybe not。 Maybe you could rewrite it that way。
    But in this case。 let's not worry about that。 Let's only get grant permission
    again。 Once we're done eating and once we're done with everything。 So there might
    be a way to do it。 But yeah， in this case I would say let's not do that yet。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你有一个许可证。也许不行。也许你可以那样重写它。但在这种情况下，我们不需要担心这个。我们只在吃完饭后，再次获取许可。所以可能有一种方法可以做到，但在这种情况下，我会说暂时不要做这个。
- en: We could probably analyze it a little bit more and see but not， not at this
    point。 Let's just say just direct permission once you're done eating。 You certainly
    could do it before you do all that eating and so forth but I don't know。 that
    I'd do it before you sleep。 In that case， right？
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以再分析一下，但现在不行。就说，一旦你吃完，就可以直接归还许可。当然，你也可以在吃之前就归还许可等等，不过我不确定。我不会在你休息之前就做这件事，对吧？
- en: It might not actually change the logic as it turns out but either way， somebody's
    going。 to be waiting around and they aren't going to get a permit until they aren't
    going to。 actually be able to eat until or do the locks until later。 Okay。 All
    right， so anyway， that's that。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这可能不会改变逻辑，但不管怎样，某个人会在等待，他们直到稍后才能获得许可，直到他们能进食或操作锁时才能继续。好，行吧，总之就是这样。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_101.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_101.png)'
- en: Let's go write these other functions up here。 Let's go write wait for permission。
    Actually。 let's write grant permission。 This is the easier one。 Grant permission
    is going to simply permits lock。lock because it has to， it's about to。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去编写上面其他的函数吧。先写 `wait for permission`。其实，让我们先写 `grant permission`。这是一个比较简单的操作。`grant
    permission` 就是简单地获取 `permits` 锁，锁定它，因为它马上就要操作了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_103.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_103.png)'
- en: like do something to the permit。 So it's got to be the only thread that's doing
    that changing the permits。 And then basically it does permits plus plus because
    we're going to give back the permit。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像是对许可做些处理。所以必须是唯一一个更改许可的线程。然后基本上，它会做 `permits++`，因为我们将要归还许可。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_105.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_105.png)'
- en: so you'll see that wait permission decrements it。 Give back permits and then
    permits block unlock like that。 That's all that's doing。 Okay。 It's just basically
    incrementing the permits。 Now。 wait for permission is a little bit more involved
    because it's got to actually do the。 actual waiting。 Well， what does it have to
    do？ All right。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你会看到 `wait permission` 会减少许可。归还许可，然后 `permits lock unlock` 就是这样。那就是它在做的事。好了，基本上就是增加许可。现在，`wait
    for permission` 要稍微复杂一些，因为它必须真正执行等待。好，那么它需要做什么呢？我们来看看。
- en: The wait for permission basically we're going to wrap it in a while true loop。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 等待许可的基本流程是，我们将它包裹在一个 `while true` 循环中。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_107.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_107.png)'
- en: Okay。 And it's going to check the permits。 Well， how do you check the permit？
    Well。 you'd better lock first。 Permits lock lock。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。它会检查许可。那么，如何检查许可呢？首先，你最好先锁住它。`permits lock lock`。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_109.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_109.png)'
- en: Okay。 And then if permits is greater than zero we're going to break。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果 `permits` 大于零，我们就跳出循环。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_111.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_111.png)'
- en: We're going to be done。 That means that there is a permit available。 Let's go
    get it。 Okay。 And then we are going to do permits lock unlock。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就要完成了。这意味着有一个许可可用。让我们去获取它吧。好了，然后我们将做 `permits lock unlock`。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_113.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_113.png)'
- en: Okay。 And then we are going to if we're still and then the reason we do this
    here by the way。 is we were not successful。 Like if permits was not greater than
    zero。 In other words。 permits was zero。 Well let somebody else try because we're
    not going to keep that lock for now。 We need because there needs to be people
    who can increment it。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么接下来我们要做的，如果我们还在这里，顺便提一下我们这么做的原因是因为我们没有成功。如果 `permits` 小于等于零，换句话说，`permits`
    为零。那就让别人试试看吧，因为我们现在不会继续持有这个锁。我们需要做的是，有些人可以去增加它。
- en: Anybody who's eating now has to be able to use that lock later and increment
    it。 Does that make sense about why we're doing there？ Okay。 And then after we
    do that， well。 if we just left this while loop as it was， this would， be a spinning
    loop that would be really bad。 It would really like hammer for every thread。 It
    would hammer a processor。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现在正在用餐的人都必须能够稍后使用这个锁并增加它。这样理解我们这么做的原因了吗？好。接下来，如果我们就这么保持这个 `while` 循环不变，这会变成一个空转循环，那将是非常糟糕的。它会让每个线程都很忙碌，简直是过度消耗处理器。
- en: So let's at least do something at least somewhat nice sleep for let's say 10
    milliseconds or。 something like that。 At least that throws it off the process
    for a second and does that。 Questions？
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们得做点事情，至少稍微好一点，睡个 10 毫秒之类的，或者其他什么的。至少这样可以让进程暂停一下，做一下这个操作。有问题吗？
- en: Any question？ Do we determine the term of the theory？ Not quite yet。 Okay。 We
    will do that after we check and make sure there's a permit available。 Oh。 that's
    not what this is doing。 It is。 But we haven't decremented that。 You'll see。 Okay。
    Well。 think about what's happening here。 The final loop is basically saying， okay，
    look。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有问题吗？我们确定理论的术语吗？还不完全是。好的，我们将在检查并确保有许可证可用后再做。哦，这不是它在做的事情。是的。但是我们还没有减少那个。你会看到的。好的。那么，想想这里发生了什么。最后的循环基本上是说，好，看看。
- en: grab the lock so nobody else can check， whether do anything with permits。 Is
    permits greater than zero？ If it's not， give back the lock。 sleep for a little
    bit and then try again。 That's what this loop is doing。 If the permits was greater
    than zero， then we go， great。 There's a permit available。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 获取锁，以便没有其他人能检查，是否能做任何事情，是否许可证大于零？如果没有，释放锁。稍微休眠一下，然后再试一次。这就是这个循环在做的事情。如果许可证大于零，那么我们就说，太好了，有许可证可用。
- en: Let's break out of this loop so then we can go and do the deck of it。 You certainly
    could。 you could do it。 You could do it in here and then break if you want。 It
    doesn't really matter。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳出这个循环，这样我们就可以去做剩下的部分。你当然可以。你可以在这里做，然后如果你想的话跳出循环。这没什么关系。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_115.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_115.png)'
- en: The point is that it's actually here that we're going to say permits minus minus。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，实际上在这里我们要说许可证减一。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_117.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_117.png)'
- en: And then because we broke before we unlocked here， we then have to do permits
    lock unlock。 Okay。 And that means that we're the ones who have taken the permit，
    decremented it and gone， with it。 Is that your question？ Yeah。 That's， it's a
    little tricky。 And by the way。 I'm about to show you something where this weirdness
    where you have to unlock。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后因为我们在解锁之前就中断了，所以我们必须执行许可证锁定和解锁。好的。那意味着我们是拿到许可证的人，减少它并带走它。这是你的问题吗？是的。这有点棘手。顺便说一下，我马上会展示给你看一个很奇怪的地方，你必须解锁。
- en: two places when you only lock once， we're going to get rid of that in a very，
    with a very。 cool class in a second。 Yeah。 So for the sleep for ten， if that's
    just。 what would happen if we could do that？ Good question。 If we left out the
    sleep for ten。 the only thing that would happen is that we'd really。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 两个地方，当你只锁一次时，我们将在稍后用一个非常酷的类来解决这个问题。是的。所以，对于休眠10秒，如果我们能做到这一点，会发生什么？好问题。如果我们省略了休眠10秒，唯一会发生的事情就是我们实际上会。
- en: be spinning like crazy and the processor would peg to 100% and it would， the
    fans would come。 on your computer and warm up and want to send the students wouldn't
    get their， their， their， their。 their， their， their， their computers done。 What's
    that？ It would behave differently。 It would behave differently。 No。 But this is，
    this is called busy waiting。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 会疯狂旋转，处理器会达到100%，风扇会启动，电脑会变热，学生们无法完成他们的作业，他们的， 他们的， 他们的， 他们的， 他们的， 他们的电脑做不完。那是什么？它会表现得不一样。它会表现得不一样。不是的。但这就是，
    这就是所谓的忙等待。
- en: not really spinning quite as much。 The reason it's busy waiting is because we
    are waking up every 10。 every 10 milliseconds， and going， is there a permit left？
    Oh， actually。 because there are permit left back to sleep。 And that's not the
    best way to do that。 In fact。 that's not really a good way of doing anything。
    We kind of want just like， to suspend for processes。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全像以前那样旋转。之所以叫忙等待，是因为我们每10毫秒就会醒来一次，检查是否还有许可证？哦，实际上。如果许可证还在，就继续休眠。这不是做事情的最佳方式。事实上，这根本不是一种好的方式。我们实际上希望像是暂停进程。
- en: we want the kernel to go or somebody， else。 In fact， not the kernel necessarily。
    Nobody else to say。 go ahead and check now。 I've， I've let， I've released this
    so that you can check。 So it just completely sleeps until it gets a message that
    says， oh， I， now I could go。 look and hopefully it'll be ready。 Okay。 Ah， there
    are five philosophers。 Good question。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望内核去做，或者是其他某个人。事实上，不一定是内核。任何其他人说，去检查吧，我已经释放了这个，你可以检查了。所以它完全休眠，直到收到一个消息，告诉它“哦，我现在可以去看了”，希望它已经准备好了。好的，啊，有五个哲学家。好问题。
- en: Who else is there？ There are five different philosophers all vying for the permit。
    Yes。 somebody else。 One of the other red。 You'll see。 Good question。 You'll see。
    No， I know。 What， what。 we'll see。 And then notice what's going on down here。
    We'll， we'll get to this later。 Okay。 Down。 down here， right？ We are unlocking
    there。 Isn't this a great opportunity to tell all the other threads that are waiting？
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 还有谁在那里？有五个不同的哲学家都在争取许可。是的，还有其他人。你会看到的。好问题，你会看到的。不，我知道。什么，什么？我们会看到的。然后注意这里发生了什么。我们稍后会处理这个。好了，在这里，对吧？我们正在解锁。这里难道不是一个很好的机会，告诉所有等待的线程吗？
- en: Guess what？ I just released one。 You can go grab a fork now。 All right。 So that's
    what we're going to end up doing。 We just have to figure out a way to do that。
    And you actually need a little more support from the operating system to do that
    as it， turns out。 Okay。 What questions you have about this so far before we test
    it？ No other questions？ Okay。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？我刚刚发布了一个。你现在可以去拿个叉子了。好了，这就是我们最终要做的。我们只需要找出一种方法来实现它。事实上，你还需要操作系统提供更多的支持，才行。好的，在我们测试之前，你们有什么问题吗？没有其他问题？好的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_119.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_119.png)'
- en: Let's test it。 Anybody seen any bugs？ Make， dining。 Now I'm all worried that
    I'm going to find a bug。 I can't fix again。 Oh well。 You can do it Chris。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。有人发现什么bug了吗？做得好。现在我有点担心我会发现一个bug，而我又修不好。唉，好吧。你能做到的，Chris。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_121.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_121.png)'
- en: Okay。 Make dining philosophers with busy waiting。 All right。 Oh， there we go。
    There it is。 Oh。 let's see。 I， oh， thank you for telling me now。 Which one？ In
    Maine。 All right。 Let's see。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。用忙等待实现餐哲学家问题。好了，来吧，成功了。哦，看看。哦，谢谢你现在告诉我。哪个？在 Main 中。好，来看一下。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_123.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_123.png)'
- en: Whoops。 Wait a minute。 You know what else we didn't do。 We actually didn't do
    philosophy yet because we have to do that。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，等一下。你知道我们还没做什么吗？我们实际上还没做哲学部分，因为我们得做这个。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_125.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_125.png)'
- en: I'm going to do it too。 So I'm glad it actually broke。 Which one did I spell
    wrong？ Yeah。 I did that earlier when I took the， hang on a new， mute text。 I did
    that earlier when I did this too。 I think because I'm used to typing text instead
    of there。 There。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我也要做这个。所以我很高兴它真的出了问题。我到底拼错了哪个？对，我早些时候就做过这个，当我拿到新的，静音文本时。我早些时候做这个时也是这样。我想是因为我习惯打文本，而不是打那里。那里。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_127.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_127.png)'
- en: Thank you。 Thank you。 Good catch。 All right。 Let's go on and actually try this。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。谢谢。好眼力。好了，接下来让我们来试一下这个。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_129.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_129.png)'
- en: It would have been really ugly if it didn't work at all。 We just kind of didn't
    do anything。 Let's actually do our philosophers， a philosopher here。 Okay。 We're
    still going to do a forlip。 We're still going to think。 Okay。 But now we just
    have to pass in the other details。 That's the only other difference here is left，
    right。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果完全没有作用，那会真难看。我们只是没有做任何事。好吧，让我们实际上做一个哲学家，一个哲学家。好的，我们还是要做一个 forlip。我们还是要思考。好的，但现在我们只需要传入其他细节。这是唯一的不同，就是左右。
- en: And then we have to do the permits and then permits lock like that。 Okay。 Why
    don't we have to wrap around this one？ Any ideas？
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得做许可，然后许可就像这样锁定。好的，为什么我们不需要包裹这个呢？有什么想法吗？
- en: I guess my bigger question is why haven't we ever used ref before until one
    day ago in。 any C++ class you've ever taken？
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我更大的问题是，为什么直到昨天我们才第一次使用 `ref`？你上过的任何一门 C++ 课程里有讲过吗？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_131.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_131.png)'
- en: They've always been what？ Yeah。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它们一直是什么？对吧。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_133.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_133.png)'
- en: They've always been in the right context。 Let's go look and see what EAT is
    expecting here。 EAT is expecting a permit reference， right？ So you don't need
    to say ref around it because it's actually already expecting it。 If you did wrap
    it around it， it actually wouldn't matter but you don't need to in this。 case
    because it's not like the thread class which has no idea what these parameters
    are。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它们总是处在正确的上下文中。让我们去看看 EAT 在这里期望什么。EAT 期望一个许可引用，对吧？所以你不需要再加上 `ref`，因为它已经在期待这个了。如果你加上了它，也不会有什么影响，但在这种情况下你不需要加，因为它不像线程类那样，不知道这些参数是什么。
- en: It's just going to take them and pass them along。 If you don't pass a ref that
    case。 it's just going to go， "I don't know which one you， want。"， And that's that。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 它只会获取它们并将它们传递下去。如果你没有传递引用，它就会说，“我不知道你想要哪个。”就是这样。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_135.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_135.png)'
- en: So in this case， we don't have to。 Just like we always haven't had to。 So that's
    that。 Okay。 I'll see if this works now。 Make dining philosophers。 There we go。
    Okay。 Dining philosophers with busy way。 This is not going to look any different。
    It's basically going to work them。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下，我们不需要这样做。就像我们之前一样，也不需要这样做。就是这样。好了，我看看这个现在能不能正常工作。运行“就餐哲学家”。好了。好了。带有忙碌方式的就餐哲学家。这看起来不会有什么不同。基本上它将正常运行。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_137.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_137.png)'
- en: And if we put those， if we put that sleep in there， which we put， where did
    we put that。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把那个睡眠加进来，那个睡眠放在哪里了呢？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_139.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_139.png)'
- en: in here？ We put it right after here， right？
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里？我们把它放在这里之后，对吧？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_141.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_141.png)'
- en: Sleep for 5，000。 Let's see what happens when we do this。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠 5,000 毫秒。让我们看看这样做时会发生什么。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_143.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_143.png)'
- en: And then now it's going， everybody's going to start thinking and sleeping。 And
    now we're all sleeping， it should wake back up again。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后现在开始了，每个人都会开始思考并进入睡眠状态。现在我们都在睡觉，它应该会重新唤醒。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_145.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_145.png)'
- en: There we go。 This can continue on because now we've got the right permits in
    there。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。现在可以继续了，因为我们已经将正确的许可放入其中。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_147.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_147.png)'
- en: Okay。 Now I just artificially put all these weights in there， but that's how
    that's how it will。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我只是人为地加入了所有这些延迟，但它就是这么工作的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_149.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_149.png)'
- en: go。 Okay。 All right。 What questions do you have about this going to continue
    for a little bit？
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好了。你对这部分内容有什么问题吗？我们会继续讲解一会儿。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_151.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_151.png)'
- en: What other questions do you have about that？ Anything else？ Yeah。 We could explain
    why we need a lot of permits that hold you for a minute。 Good question。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你对这个有其他问题吗？还有别的什么问题吗？是的。我们可以解释一下为什么我们需要这么多许可来等待片刻。好问题。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_153.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_153.png)'
- en: Why do we need to see if we can find it in here？ Why do we need to lock the
    permits before we decrement it or increment it here？
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要在这里检查它是否存在？为什么我们需要在递减或递增许可之前锁定它？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_155.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_155.png)'
- en: Yeah。 So let's say two threads end up stopping at exactly the same time， which
    would be possible。 and going and trying to release their permit， right？ Well，
    couldn't you end up with。 they both did permits plus plus。 You could end up with
    a situation where the assembly code。 one of them increments it and， the other
    one is reading it。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。那么假设两个线程恰好在相同的时刻停止，这种情况是可能的。然后它们都尝试释放它们的许可，对吧？好吧，难道不会出现这种情况吗？它们都执行了 `permits++`。你可能会遇到这样的情况：汇编代码中的一个线程执行了递增，另一个线程正在读取它。
- en: but gets the wrong value and then increments it and there might。 be two increments
    or there might only be one increment instead of two。 It's actually。 it's a race
    condition there。 So you always want to wrap around your data structures that multiple
    threads could be。 modifying。 Does that help or is it still？ Why？ Yes。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它读取到的是错误的值，然后递增了，可能会有两个递增，或者可能只会有一个递增，而不是两个。实际上，这是一个竞争条件。所以你总是希望将多个线程可能修改的数据结构进行封装。这样有帮助吗？还是说为什么？是的。
- en: If permits was zero and they both tried to increment it once， then you could
    end up with。 just permits being one instead of two because of that race conditioning，
    because of the。 assembly language like we talked the other day， it's not， plus
    plus is not an atomic operation。 In other words， you can't guarantee that inside
    there another one of the threads will。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果许可是零，而它们两个都试图一次递增，那么你可能会得到许可为 1，而不是 2，因为竞争条件的原因，因为正如我们前几天所说，`++` 不是原子操作。换句话说，你不能保证在其中另一个线程会。
- en: end up reading， both will read one will update and the other one will also，
    you know， it'll。 be a little bit different。 It won't necessarily be the exact
    be correct。 Question。 Question。 Why do you have to lock when you're looking at
    permits？ Good question。 What if someone else came in and decremented after you
    checked， then you would both decrement。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，两个都会读取，一个会更新，另一个也会，你知道，它会稍微有点不同。它不一定会完全正确。问题。问题。为什么你在查看许可时必须加锁？问得好。如果有人在你检查后进来并递减，那你们俩都会递减。
- en: and then you'd be negative one permits and then all of a sudden you'd be in
    a deadlock。 condition again as well。 Right？ So it's again， even if you're reading
    it。 Now。 there are times where you will be able to read from a data structure
    as long as you。 can guarantee no one else is writing to it。 That's fine。 Okay？
    This。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你就会变成负一许可，突然间你又会进入死锁状态。对吧？所以即使你在阅读它时也是如此。现在，有时候你可以从数据结构中读取数据，只要你能保证没有其他人在写它。这样是没问题的。好吗？这个。
- en: in things like maps and sets and things， you can read from some of those without
    worrying。 that someone else will be overstepping it。 It's a little more subtle
    than that。 but you'll get to some assignments where that's possible， but in this
    case it's not。 Okay。 Second question。 [inaudible]， Why do you have to say rats
    instead of like hamper sand？
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在像映射和集合这样的东西中，你可以读取其中的一些数据，而不必担心别人会修改它。比这要微妙一点，但你会遇到一些赋值情况，那时这是可能的，但在这个情况下不行。好的，第二个问题。[听不清]，为什么你必须说“rats”而不是像“hamper
    sand”之类的？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_157.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_157.png)'
- en: Right。 Good question。 Why do you have to say ref instead of ampersand？
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对。问得好。为什么你必须说“ref”而不是“ampersand”？
- en: And that's definitely bears repeating。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对值得重复。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_159.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_159.png)'
- en: We do that right here。 Remember the thread class has this interesting function
    signature where it says I will take。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就在这里做。记住，线程类有这样一个有趣的函数签名，它说：“我将接受。”
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_161.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_161.png)'
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_162.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_162.png)'
- en: as many parameters as you want to give me。 And what I will do is then I will
    take all of the parameters after the first one and pass。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递任意多个参数给我。我所做的是，将第一个参数之后的所有参数传递下去。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_164.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_164.png)'
- en: them into the first one as the parameters for that function when I start the
    thread。 That makes sense？ Okay， when that happens， the thread has no idea if this
    function philosopher is going。 to take a reference or is going to take a value。
    So when you pass the value into the thread。 it just goes， I don't know。 I suppose
    maybe you could go right a compiler that goes and looks at philosopher and goes。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我启动线程时，我把它们作为参数传递给第一个函数。这样说得通吗？好的，当发生这种情况时，线程根本不知道这个函数的哲学家是会接收一个引用，还是会接收一个值。所以当你将值传递给线程时，它只会说：“我不知道。”我猜也许你可以编写一个编译器，去查看哲学家，看看。
- en: oh， this one needs this， but it's not going to be， it's not necessarily going
    to work。 the way around。 So this is why I just say， look， make it a reference
    and there you go。 In fact。 I think if you didn't make it a reference， it would
    probably cause that same。 silhouette error we had the other day and you have to
    go fix it。 But then， you know。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这个需要这样做，但它不一定会按预期工作。所以这就是为什么我只是说，嗯，做成引用就好了。事实上，我认为如果你不将它做成引用，可能会导致我们前几天遇到的那个同样的“轮廓错误”，你必须去修复它。但之后，你知道的。
- en: the fix is to put that ref in there and say， look， it has to be a， reference。
    Okay， good question。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是把那个引用放进去，并说，看，它必须是一个引用。好的，问得好。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_166.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_166.png)'
- en: Yeah。 So I thought you'd problem with the incrementing that is that either increment
    to much or。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。所以我觉得你在递增时的问题是，要么递增太多，要么。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_168.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_168.png)'
- en: that prevents too much？ I mean， because they could happen to where they interpret
    what an increment together is。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这样防止过多了吗？我的意思是，它们可能会解释增量操作是什么。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_170.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_170.png)'
- en: one。 Yeah， so the question is， look， are you sure that the part of that， like
    I thought it was。 that the permits were you could either increment or decrement
    too much， but no， it's actually。 more likely that it's going to be too few。 Like
    they will both try to increment and you want it to increment。 Well， let's say
    two threads come in， they both increment， you could get two， right， which。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个。是的，问题是，看看，你确定那个部分吗，像我原本以为是的。那个权限是你可以增加或减少太多，但不，实际上。更可能的是它会增加得太少。就像它们都会尝试增加，而你希望它能增加。好吧，假设两个线程进入，它们都增加，你可能得到两个，对吧，那个。
- en: is what you want， but you could also just end up getting one increment because
    they both。 go back to last， go back to a Monday's lecture and take a look at the，
    take a look at the。 assembly code and see that， oh， look， if。 If this one reads
    the value before it updates。 then the other one reads the value and then， updates。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你想要的，但你也可能只会得到一个增量，因为它们都会。回到上一个，回到周一的讲座，看看，看看那个。汇编代码，并看到，哦，看看，如果。这个先读取值再更新。然后另一个先读取值再更新。
- en: This one will update to the same value and not one more than it should be。 Go
    back and look at that。 You'll， you'll figure that once you go through the assembly
    code。 And then the permits dot lock makes sure to nothing like only one thing
    is access and。 then it blocks the rest of the accessing through that line。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会更新为相同的值，而不是它应该有的更多。回去看看那个。你会明白的，一旦你看完汇编代码。然后权限点锁确保没有像只有一个访问的情况。然后它会阻止其他的访问，直到那条线被释放。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_172.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_172.png)'
- en: Yes。 And this， this also bears repeating。 And we say permits dot lock。 Think
    about what's happening。 Many threads are all going to be at that same line at
    the same time。 Okay。 They're all maybe。 Let's assume they all go and try to run
    that line at the same time。 Only one of them will actually get the hold of the
    lock。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这个也值得重复。我们说权限点锁。想想发生了什么。许多线程都会同时到达那一行。好吧。它们可能都会，假设它们都去尝试同时运行那一行。只有其中一个会真正获得锁的控制。
- en: The rest will have to wait until that lock gets released。 So that's what it
    does。 It doesn't like tell anything to anybody else。 It basically says if everybody's
    trying to access that variable。 that lock， only one， will win， all the rest will
    just wait until that one releases it with an unlock。 That's the difference there。
    Good question。 And that's critical to kind of get what lock is doing。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的必须等到那个锁被释放。所以这就是它的作用。它并不会告诉其他任何人。它基本上说，如果每个人都试图访问那个变量。那个锁，只有一个会成功，其它的都会等着直到那个释放它。那就是它的不同。好问题。这对于理解锁的作用至关重要。
- en: It's not like telling the colonel， hey， don't let anybody else touch this。 It's
    just。 it's much more simple than that as it turns out。 How is which？ How is the
    waiting implemented？ Oh。 how is the waiting implemented？ Yeah。 Good question。
    It's a， it's a nice sleep weight。 I mean。 it basically the， it's a， it's a， it's
    a nice sleep weight。 I mean， it basically the。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它不像是告诉指令，嘿，别让其他人碰这个。其实。它比这简单得多。那个是如何实现等待的？哦。如何实现等待？是的。好问题。它是一个很好的睡眠等待。我的意思是。基本上，它是，基本上它是。
- en: when lock unlocks， it will actually， it will actually set like。 a global variable
    more or less that everybody else reads。 And then one， and they do it atomically。
    There are other instructions underlying assembly code instructions that are atomic。
    And so the way it's built is on those instructions such that only one is successful
    as it comes。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当锁解锁时，它实际上会，实际上会设置像。一个全局变量，其他人也能读取。然后它们会以原子方式进行操作。底层的汇编代码指令中还有其他原子指令。所以它的构建方式是基于这些指令的，确保只有一个能成功。
- en: out。 But it is a， it does wait until it doesn't do anything like spinning or
    anything。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 出去了。但它是一个，直到它不做任何像旋转或者其他什么的等待。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_174.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_174.png)'
- en: Don't even worry about that。 Okay。 Now let's see a couple of different ways
    of doing this。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心那个。好了，现在让我们看看几种不同的做法。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_176.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_176.png)'
- en: This was one way of doing this。 Okay。 Except that we still have this busy wait。
    We still go to sleep for 10 milliseconds， wake up， go， hey， is there a permit
    available。 go back to sleep and so on。 And that's not really that great an idea。
    Okay。 It's not the end of the world， but it's not a particularly good strategy。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种做法。好的。只是我们仍然有忙等待。我们仍然会睡眠 10 毫秒，醒来后检查，嘿，是否有可用的许可证。然后继续睡觉，依此类推。其实这个主意并不是特别好。好的，这并不是世界末日，但也不是一种特别好的策略。
- en: In order to have this set up so that we can actually wait for the next， for
    the permits。 to become available， we have to use another language feature， which
    in this or another。 I guess another type of variable， which is going to be called
    a condition variable any。 Okay。 There's also just a condition variable。 You can
    use either。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个设置能够使我们真正等待许可证的下一个可用，我们必须使用另一个语言特性，即条件变量 any，或者说是另一种类型的变量，这种类型被称为条件变量 any。好的。你也可以使用普通的条件变量，两者都可以。
- en: We'll just use very condition variable any because it works with multiple different
    types， of locks。 But basically what it does is it allows you to say， okay， I'm
    about to wait for some lock。 to be ready。 Please put me to sleep until that happens。
    So it's very analogous to six to spend in that case。 It's very analogous to that。
    All right。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用非常条件变量 any，因为它与多种不同类型的锁兼容。但它的基本作用是允许你说，好的，我准备等待某个锁的准备状态。请让我睡眠直到那个时刻。所以它在这种情况下与锁是非常相似的。确实是那样。好吧。
- en: Here's how what it actually looks like。 A couple of details about it。 By the
    way。 this is not meant to scare you。 Jerry Kane thinks this is the hardest thing
    to understand in 110。 I'm not sure I agree。 Well， condition variable any take
    a little bit of like， oh。 and then you get it， right？ It took me a little while，
    but I'll try to do my best explaining it。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的实际样子。关于它的一些细节。顺便说一下，这并不是为了吓唬你。Jerry Kane 认为这是 110 中最难理解的内容，我不太同意。嗯，条件变量
    any 需要一点时间才能理解，不过很快就能明白，对吧？我花了一点时间，但我会尽力解释清楚。
- en: And then you'll have to test it and see what happens。 But here's what happens。
    You have a declare condition variable any and it has a weight function in it。
    Okay。 It actually has two weight functions。 We'll talk about the second one in
    a minute。 but it takes a weight and it takes a new text， variable as the parameter
    for weight。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要测试一下，看看会发生什么。但事情是这样的：你声明了一个条件变量 any，并且它有一个等待函数。好的，实际上它有两个等待函数。稍后我们会讨论第二个，但它需要一个等待参数，并且需要一个新的文本变量作为等待的参数。
- en: So you have some lock that you've locked。 Then you call this condition variable
    any weight function with that lock。 What it does is it puts the thread to sleep
    and then unlocks the lock until some other。 thread basically signals。 In fact，
    there's a notify to notify commands here。 The other threads notify the weight
    condition to wake up。 Okay。 So that's what's happening here。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你有一个已经加锁的锁。然后你调用这个条件变量 any 的等待函数，并且传入这个锁。它的作用是将线程休眠，然后解锁，直到其他线程基本上发送信号。实际上，这里有一个通知命令。其他线程会通知等待条件来唤醒它。好的，这就是这里发生的事情。
- en: There are actually two notifies。 Always use notify all as it turns out。 Notify
    one is a little wonky sometimes。 It doesn't matter。 Notify one would be if you
    know that there's only one thread waiting， you do notify one。 and that one thread
    is the only one that will get notification。 Or if you have multiple ones。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两个通知。最终还是建议总是使用 notify all。因为 notify one 有时候有些不稳定。没关系。如果你知道只有一个线程在等待，你可以使用
    notify one，这样只有那个线程会收到通知。或者如果有多个线程的话。
- en: it will only notify one of the multiple ones waiting。 It's just better to write
    your logic to use notify all as it turns out。 That's not particularly important。
    Just know that we're generally going to see notify all to say anybody waiting
    for this。 It's yours to try to get for the lock。 That's kind of what's going on。
    Okay。 So to reiterate。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它只会通知多个等待中的其中一个。实际上，最好是编写你的逻辑来使用 notify all。这个并不是特别重要。只要知道我们通常会看到 notify all
    来通知任何在等待的线程。它是用来获取锁的。这就是事情的运作方式。好了，重申一下。
- en: we have this condition variable， this condition variable any variable。 And you
    use it。 you declare the variable， everybody shares it by the way。 Okay。 Same thing
    like just like a mutex。 And then you pass in a lock that needs to be waited on。
    It unlocks that， waits on it。 and then when it gets a signal， it relocks the lock
    if it， gets the lock and then goes on。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个条件变量，这个条件变量是任何变量。而且你用它。你声明这个变量，顺便说一句，大家都会共享它。好了。就像是一个互斥锁一样。然后你传入一个需要等待的锁。它解锁那个锁，等待它。然后当它收到信号时，如果拿到锁，它就重新锁定，并继续执行。
- en: That's how it works。 Okay。 And you might be asking yourself， why is it unlocked？
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式。好了。你可能会问，为什么它是解锁的？
- en: We'll see why it has to unlock。 It doesn't unlock while it's waiting。 That things
    could happen。 It's just like why does SIGs suspend， unblock the signals when it's
    actually waiting because。 it kind of has to in order for the rest of the logic
    to work。 Okay。 All right。 So does that start to make sense about how that works？
    Yeah。 >> Is there a general question？
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到为什么它必须解锁。在等待时它不会解锁。因为可能会发生一些事情。这就像为什么 SIGs 暂停时，当它正在等待时，信号会被解锁一样。因为，它实际上必须解锁，才能使其余的逻辑正常工作。好了，明白了吗？嗯。>>
    有什么一般性的问题吗？
- en: Is there a conditional variable of any or C++？ They want something that can
    make the--。 >> Good question。 That's a very good question。 This conditional variable。
    any is a C++ standard class as it turns out。 We will see one in a few minutes
    that's actually could be。 but they never built it， so we'll， use a different one。
    You'll see。 I'll explain that in a minute。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有 C++ 中的条件变量 any？他们需要某种能够做到——。>> 好问题。非常好的问题。这个条件变量。any 实际上是 C++ 标准类。几分钟后我们会看到一个，实际上可能是的。但是他们从未构建它，所以我们将使用另一个。你会看到的。我一会儿会解释。
- en: But another thing。 But that's why it's your question。 Because yeah。 this one
    happens to be built for you。 And you do need it to be built for you because you
    need the kernel to help out with this。 waiting business。 Just like you did in
    SIGs suspend。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另外一件事。这就是你问的问题。因为是的，这个是为你构建的。你确实需要它为你构建，因为你需要内核来帮助处理这件事。就像你在 SIGs 暂停时所做的那样。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_178.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_178.png)'
- en: You're going to have a raised condition otherwise。 So that's that。 Okay。 Let's
    actually go and build this one。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 否则你会有一个提升的条件。就这样。好了。我们实际上来构建这个。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_180.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_180.png)'
- en: Then dining philosophers with CV， wait one。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是带有条件变量的哲学家问题，等待一个。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_182.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_182.png)'
- en: We will do two of these。 Oops。 That would be a CC。 Okay。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做两个这样的操作。哎呀。那应该是 CC。好了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_184.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_184.png)'
- en: And what we're going to do here is it's basically going to be the same sort
    of thing。 I'm waiting on-- there we go。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的其实就是类似的事情。我在等待——好了，开始了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_186.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_186.png)'
- en: The computer。 Basically the same idea as before。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机。基本上和之前的想法一样。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_188.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_188.png)'
- en: We have to do a wait for permission， grant permission， et cetera。 Let's start
    with Maine。 Some of these are going to stay the same by the way。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做一个等待许可、授予许可等操作。我们从主程序开始。顺便说一下，其中一些内容会保持不变。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_190.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_190.png)'
- en: We're not going to have to do any change-- make any change to eat or think。
    We'll probably make philosopher changes just because of some variables that we
    have to。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对吃或思考做任何修改——不会做任何修改。我们可能会做哲学上的修改，因为有些变量我们必须处理。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_192.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_192.png)'
- en: pass in。 But that's that。 Okay。 Well， we might have to change the parameters
    a little bit as well。 In fact， I've already got it in here。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 传入。但是就这样。好了，实际上我们可能还需要稍微改变一下参数。事实上，我已经把它加进去了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_194.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_194.png)'
- en: There's a condition variable any already in there。 I guess I left in。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 那里已经有一个条件变量 any 了。我想我把它留在了那里。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_196.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_196.png)'
- en: But here's what we're going to do。 For Maine， again， same idea。 We're still
    going to have the permits。 Okay。 We're still going to have the mutex-- the mutexes
    for the actual forks in there。 We're going to have another mutex。 Just kind of
    like what we did before。 We called it permits lock before。 We're just going to
    call it m。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们要做的是这样。对于 Main，仍然是同样的思路。我们仍然会有许可证。好的。我们仍然会有互斥锁——用于实际的叉子，我们会有另一个互斥锁。就像之前做的那样，我们称之为
    permits lock。我们现在就叫它 m。
- en: You will see this one a lot for mutex。 And we're just going to use that name
    for now。 And then we're going to have this condition variable any。 Condition variable
    any。 And we'll call that cv for condition variable。 Okay。 Same sort of thing here。
    We're going to have a philosopher。 We're going to walk through each philosopher
    and start the threads。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常看到这种用法用于互斥锁。我们现在暂时就用这个名字。接着我们会有一个条件变量 any。条件变量 any。我们把它称为 cv，表示条件变量。好的，类似的东西。我们将有一个哲学家。我们将遍历每个哲学家并启动线程。
- en: We have to do the-- we have to start them off again。 Philosophers i equals thread。
    In this case。 philosopher。 Philosophers the function， i ref， left， ref， right，
    ref permits again。 And in this case， we're going to have ref cv for the condition
    variable。 And we need that permits lock as well。 Because remember， wait takes
    a mutex itself that's。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重新启动它们。哲学家 i 等于线程。在这种情况下，哲学家。哲学家的函数，i 引用，左叉子，引用，右叉子，引用许可证，再次。并且在这种情况下，我们会引用
    cv 作为条件变量。我们还需要 permits lock。因为记住，等待操作本身也需要一个互斥锁。
- en: going to use to actually do the unlocking and locking。 So we have to do ref
    m as well。 Thank you。 I'm missing prints on ref， right。 All right。 There we go。
    Let's see。 Let's see if this one-- yes。 it looks right there。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将用来实际进行解锁和加锁。所以我们还必须引用 m。谢谢。对了，我忘了在引用时加上打印。好的，搞定了。让我们看看。看看这个——是的，看起来对了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_198.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_198.png)'
- en: Thank you。 Okay。 So that's that。 I don't believe there's anything else we have
    to do here。 We're still going to join same things before。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。那么就是这样。我相信这里没有什么别的需要做的了。我们还是要像之前一样加入相同的内容。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_200.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_200.png)'
- en: All right。 Let's go look at some of these other functions。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们来看一下其他一些函数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_202.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_202.png)'
- en: that we have to do。 Let's see。 Are we going to have to change-- oh。 I already
    changed each in this case。 So what we're going to do is we are going to do our
    wait for permission。 and our grab permission。 Now， this is where I'm going to
    show you a very cool new way。 to use a lock around a variable。 It is called a
    lock guard。 Here's how it's going to work。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的事情。让我们看看。我们是不是需要改变——哦，我已经在这种情况下改变了。所以我们要做的是执行等待许可和获取许可操作。现在，我要给你们展示一种非常酷的新方法，来用锁保护一个变量。它叫做锁守卫。它的工作方式如下。
- en: Lock guard-- it goes like this， mutex， because it takes a parameter like that。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 锁守卫——它是这样的，互斥锁，因为它接受这样的参数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_204.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_204.png)'
- en: Lock guard m。 And here's what this does。 This is why it's such a cool class。
    It's the easiest class in the world。 All it has is a constructor and a destructor。
    In the constructor， the only thing it does， is calls lock on that mutex。 When
    you create this-- so at this point， after this line， the mutex has been locked。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 锁守卫 m。这就是它的作用。这就是为什么它是一个非常酷的类。它是世界上最简单的类。它只有一个构造函数和一个析构函数。在构造函数中，它做的唯一事情就是调用该互斥锁的
    lock。创建它时——所以在这一行之后，互斥锁已经被锁定了。
- en: The only thing the destructor does is call m。unlock。 What's nice about classes
    like this-- and in C++， this is true--。 whenever a variable goes out of scope，
    what happens？ The destructor gets called。 So we don't need to worry about unlocking
    this。 As long as we want to unlock as we leave。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数做的唯一事情就是调用 m.unlock。像这样的类有什么好处——在 C++ 中，这是真的——每当一个变量超出作用域时，会发生什么？析构函数会被调用。所以我们不需要担心解锁这个变量。只要我们在离开时解锁它就行。
- en: we just say， well， it's out of scope， it's going to get unlocked。 It's the cleverest
    little class I've ever seen because of that。 Now。 what we're going to do here
    is we are going to do a while loop， permits equals 0。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是说，嗯，它超出了作用域，它会被解锁。这是我见过的最聪明的小类了。现在，我们要做的是进入一个 while 循环，许可证等于 0。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_206.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_206.png)'
- en: And then we're going to do cv。weight。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做的是 cv.weight。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_208.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_208.png)'
- en: And then we're going to wait on the lock that we already just locked。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将等待我们已经锁定的锁。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_210.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_210.png)'
- en: And then if at any time we get notified that the permits has， actually gone
    above 0。 as it turns out--， whenever we get notified， we will check again to see
    if it's still 0。 then we will do that。 But after the cv。weight， it unlocks so
    that it can go back。 and do the check again--， I'm sorry， relax。 So it can do
    the check again so that you。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们在任何时候收到通知，表明许可实际上已经超过了0。结果是——每当我们收到通知时，我们会再次检查，看它是否仍然是0。然后我们会这么做。但在cv.wait之后，它解锁了，以便可以返回。然后再做检查——抱歉，放松。这样它就可以再次检查，确保你。
- en: don't have two different threads trying to do that。 I'll go over that again。
    And then after here。 we know that at this point， we have gotten to a place where
    permits equals 0。 We have the lack still。 So we know that we can do permits。 Permits
    is not equal to 0 at this point。 I should say。 We could do permits minus， minus，
    like that。 OK。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让两个不同的线程尝试做这件事。我会再说一遍。然后在这里，我们知道此时我们已经到达了一个许可等于0的地方。我们仍然持有锁。所以我们知道我们可以执行许可。此时许可不等于0。我应该这么说。我们可以执行许可减1，像这样。好的。
- en: At what point does the lock unlock for reals when it after 62？ After we leave
    the function。 it's out of scope。 The destructor gets called。 The lock gets unlocked。
    OK。 So let's walk through it one more time。 This is definitely challenging。 We
    lock the lock using this lock guard so we know it's， going to get unlocked。 We
    now hold it。 Now。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 锁什么时候会真正解锁？是在62之后吗？在我们离开函数后。它超出了作用域，析构函数会被调用，锁会被解锁。好的，我们再过一遍这个过程。这确实有挑战性。我们使用锁守卫锁住锁，这样我们就知道它会被解锁。现在我们持有锁了。现在。
- en: many threads could be contending on this， but one of them is going to get it。
    So assume that our thread is the one that gets it。 Then we go down and we say，
    oh， if permits is 0。 then we'd， better wait because there are no permits available。
    What happens is we tell wait。 use my mutex variable to wait on， and unlock it
    after you push me off the processor。
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有多个线程争用这个锁，但其中一个会成功。假设我们的线程是那个获得锁的。然后我们继续往下走，说，如果许可是0，那我们最好等待，因为没有许可可用。发生的情况是我们告诉它等待，使用我的互斥量变量等待，并在你把我从处理器中移除后解锁它。
- en: It unlocks the mutex and then sits around waiting for， to be notified。 When
    it gets notified。 it reacquives that lock if it can， and then it goes and checks
    and then comes back up to the top。 of the while loop again and checks to see if
    permits is， 0 again。 At this point。 hopefully it is not。 In fact， it wouldn't
    be if we acquired the lock and we got， notified。
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 它解锁互斥量，然后等待通知。当它收到通知时，如果可以，它会重新获取锁，然后再去检查，接着回到while循环顶部，再次检查是否许可是0。如果此时它不是0，那就好了。实际上，如果我们已经获取了锁并且收到了通知，它就不会是0。
- en: then it wouldn't be。 And then it would get out of the while loop。 Deck my permits
    because we are now holding one。 Yes？
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它就不会再是0了。然后它将跳出while循环。因为我们现在持有一个许可，所以我就暂停了。对吧？
- en: So it's waiting to be told that it isn't checked again or it's。 waiting to be
    told that it's re-locked？ It's waiting for whatever who ever notifies it。 Now。
    let's see who notifies it。 Let's go on to the next thing you notice。 Somebody
    else had a question？
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它在等待被告知它没有被再次检查，或者它在等待被告知它重新加锁了吗？它在等待任何通知它的信号。现在，看看谁会通知它。接下来，让我们看看你注意到的其他事情。有人有问题吗？
- en: Yeah？ [INAUDIBLE]， Oh， yeah。 If you unlock it， good question。 If you unlock
    it。 it's not even guaranteed that the same， thread will get the lock again。 The
    CV wait tries to unlock。 If it can't unlock it， it just goes back to sleep until
    it， gets another notification。 Because it tried and it can't do it， so that's
    that。 It tries to-- sorry， it tries to re-lock。 Yes。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 是吗？[听不清]，哦，没错。如果你解锁它，问题很大。如果你解锁它，甚至无法保证同一个线程会再次获得锁。CV等待会尝试解锁。如果它无法解锁，它会再次进入休眠，直到收到另一个通知。因为它尝试过但做不到，所以就是这样。它尝试——抱歉，它会尝试重新加锁。没错。
- en: thank you。 It tries to re-lock。 If it can't， it just goes， oh， I'll wait around
    again。 I'll keep waiting until I get another notification。 Let's see who notifies
    it。 Well。 there's only one other thing that really could， notify it in this case。
    It's grant permission。 Let's see how that works。 Grant permission is also going
    to use a lock guard for a。
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。它尝试重新加锁。如果失败了，它就会说：“哦，我等会儿再试。”它会继续等待，直到收到另一个通知。让我们看看谁会通知它。嗯，实际上只有一个东西可以通知它，那就是授予权限。让我们看看那是怎么运作的。授予权限也会使用锁守卫。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_212.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_212.png)'
- en: mutax， LGM。 And now all lock guard-- remember all lock guard need， to do before
    was update permits。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: mutax，LGM。现在所有的锁守卫——记住，所有锁守卫之前需要做的就是更新许可。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_214.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_214.png)'
- en: Permits plus plus， because it's releasing the lock， or the， permit， that it
    just finished the。 philosopher just finished eating。 Therefore， it's going to
    release this， and we're good to， go。 Well， now， once it's released it， what does
    it need to do？ Well， it needs to tell everybody else。 hey， guess what？ There is
    a permit there。 Now， what is the only case where it would matter if we。
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 许可加一，因为它正在释放锁，或者说，正在释放许可，表示哲学家刚刚吃完。因此，它会释放这个许可，接下来就可以继续执行。那么，现在它释放后需要做什么？它需要告诉其他线程：“嘿，猜猜看？有一个许可。”现在，只有在什么情况下，如果我们……
- en: have four permits？ One。 One。 That's the only one that would matter， right？ So
    if permits equals one。 because we're the ones who just， made it go from 0 to 1，
    meaning there's going to be。 someone possibly waiting for that， then we might
    as well， notify--， oops， our CV。 I should say CV。notify。 And that will send a
    notification to the other。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个许可吗？一个。一个。那是唯一重要的，对吧？所以如果许可等于 1，因为我们是刚刚将它从 0 设置为 1，意味着可能有人在等待这个许可，那么我们不妨通知——哦，应该说是
    CV.notify。这样就会通知其他线程。
- en: threads that are waiting for them all to try to wake up and， re-acquire that
    lock。 And when they re-acquire that lock， then the one that does， gets the permit
    and moves on。 Question。 Is that only for clarity， or would something break if
    we， didn't actually keep it up？ Like， hey。 if we didn't make it， only a permit，
    couple is more。 Oh， is it only for clarity？ Like， you know。
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所有等待的线程都尝试唤醒并重新获取锁。当它们重新获取锁时，成功获取锁的线程会获得许可并继续执行。问题是，这只是为了清晰起见吗？如果我们没有继续这样做，会有什么问题吗？比如，如果我们不这么做，只有许可，一个许可以外的其他东西就没有了。哦，这只是为了清晰吗？你知道的。
- en: if you just said， CV notify after you do， that， it probably wouldn't matter，
    actually， because。 they're all checking for 0 anyway。 So if there's one available，
    then-- yeah， I don't think。 that would-- I think that would--， it's not necessarily
    just for clarity， it's just for--。 let's not send more notification than we need
    to， either。
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是说，在你执行之后，CV 通知，那可能也没关系，因为它们反正都会检查 0。所以如果有一个许可可用，那么——是的，我认为那不会——我认为那不会——它不一定只是为了清晰，而是为了——我们也不需要发送更多通知。
- en: There's definitely not going to be any worry if there's two， or more than one
    at that point。 I was already feel about this one at this point。
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时有两个或更多线程，就肯定不会有任何问题。我在这一点上已经感觉到了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_216.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_216.png)'
- en: Let's try it。 Anybody see any bugs？
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。有人看到什么 bug 吗？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_218.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_218.png)'
- en: Make dining philosophers with CV weight 1。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CV 权重为 1 来实现哲学家就餐问题。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_220.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_220.png)'
- en: All right， dining philosophers with CV weight 1， and there we， go， and it should，
    or there they go。 continue， continue， continue until they all do it。
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，使用 CV 权重为 1 的哲学家就餐问题，我们开始吧，它应该继续，或者说它们会继续，继续，继续，直到所有线程都完成。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_222.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_222.png)'
- en: So that's how that works。 Question。 How does it maybe a very helpful， how did
    you spread it。
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所以就是这样运作的。问题是，怎么样可能非常有帮助，你是如何传播的？
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_224.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_224.png)'
- en: there？ How does CV know how many threads are there？ It has no idea。 Does it
    need to？
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CV 如何知道有多少个线程？它根本不知道。它需要知道吗？
- en: It doesn't really need to。 Your logic is what kind of dictates when these things--。
    we do know that permits is what we're looking for。 We're looking for four permits。
    There's four permits available。 If four dining philosophers already have those
    permits。 we are not going to let another dining philosopher even， pick up for
    the first fork。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上不需要。你的逻辑决定了这些事情何时发生——我们知道我们在寻找许可证。我们正在寻找四个许可证。如果四个哲学家已经持有了这些许可证，我们就不允许其他哲学家去拿第一个叉子。
- en: That's what's happening there。 And we are using this idea that we。 are trying
    when we first go into lift up the left fork， we're going in and saying。 get us
    permission first。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是发生的事情。而我们正在使用这个思想：当我们第一次去拿左叉时，我们会先说，先给我们一个许可证。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_226.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_226.png)'
- en: And that's where the weight permissions comes into play。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是权重权限的作用。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_228.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_228.png)'
- en: which says， OK， everybody's going to do this first。 They are going to try to
    acquire the lock。 If they acquire it， they are going to check and see， if there
    are permits available。 If there are not permits available， then they are going
    to wait for a permit to be available。 When one becomes available， they're， going
    to try to reapply that lock。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 它说，好吧，每个人首先都会做这个。他们将尝试获取锁。如果成功获取，他们将检查是否有可用的许可证。如果没有许可证可用，他们将等待许可证变得可用。当许可证变得可用时，他们将尝试重新申请该锁。
- en: and then decrement permits such that they actually hold one。 One second。 So
    notify all。 How does it know？ Oh， notify all。 It's like some global variable that
    everybody's looking at。 basically。 I mean， I think the kernel has some role in
    this as well。 as a thread manager or whatever。 But it's built in such that when
    you say notify all。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后减少许可证的数量，使得他们实际上持有一个。等一秒钟。然后通知所有。它怎么知道呢？哦，通知所有。就像是某个所有线程都在关注的全局变量。基本上。我的意思是，我认为内核在这方面也有一定作用，作为线程管理器或其他什么的。但它被设计成，当你说通知所有时。
- en: anybody who happens to be waiting has， registered to get that notification when
    it happens。 Why didn't we use the lambda function one？ We will。 We're going to
    see a different one in a second。 Because this while loop is here。
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 任何正在等待的人，都会注册在事件发生时接收到通知。为什么我们不使用 lambda 函数呢？我们会的。我们将在稍后看到不同的实现。因为这里有一个 while
    循环。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_230.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_230.png)'
- en: this is a really common way of doing this。 You can't really say if permits equals
    equals zero。 because there is going to be some sort of a race condition。 in there
    to actually re-acquire that lack later。 So this while some condition is true，
    wait on it。 That's so common that they've built it， into the condition variable
    any。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常常见的做法。你不能简单地说如果许可证等于零。因为那样会出现某种竞争条件，导致后续重新获取锁时出现问题。所以，这个“当某个条件为真时，等待它”非常常见，以至于它已经被构建进条件变量中。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_232.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_232.png)'
- en: OK？ You didn't have to the while loop， that you used for about a week。 If you
    didn't have the while loop。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？你不需要再用你大约一周时间使用的那个 while 循环了。如果没有这个 while 循环。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_234.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_234.png)'
- en: you will。 Yeah， let's see what that lambda function。 that you're talking about
    looks like in a second。 So let's see。 We talked about all of this with the acquiring
    lock。 OK。 Like I said。 because this is such a common thing to do。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到的。是的，稍后我们来看你提到的那个 lambda 函数到底是什么样的。好，我们已经讨论了关于获取锁的所有内容。好吧。就像我说的那样，因为这是一个非常常见的操作。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_236.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_236.png)'
- en: we have it built in such that it looks like this。 It's actually a templated
    function。 which basically means that you don't know exactly what， the type is
    going to be， but that's OK。 Here's what you do。 Instead of doing a while loop，
    you。 let the wait statement kind of do that while loop for you， by passing in
    some other function that。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计是这样的。实际上，这是一个模板化函数。基本上意味着你不知道类型究竟是什么，但没关系。你应该这么做。与其使用一个 while 循环，你不如让等待语句通过传递其他函数来替代这个
    while 循环。
- en: makes the decision and returns true or false based， on that decision or based
    on that question。 So in this case， you would say-- and this is exactly what， it's
    doing in here--， is that while loop。 It's just doing it for you。 So what could
    this predicate be？ Well。 it could be a function that checks to see if permits
    is， zero or not。 That's what it is。
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 它做出决策并根据该决策或该问题返回true或false。所以在这种情况下，你会说——这正是它在这里做的——就是那个while循环。它为你做了这一切。那么这个谓词可能是什么呢？嗯。它可以是一个检查permits是否为零的函数。就是这个。
- en: You can't just pass in the value permits equals zero， because you need to check
    it every time。 and it could change。 So if you try to pass it in directly as that，
    you could。 So what do you do？
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接传递permits等于零的值，因为你需要每次检查它，而且它可能会改变。如果你尝试直接传递它，就可能会出问题。那么你该怎么做呢？
- en: You pass it in as a function or， since we're in C++， as a lambda function。 which
    is the way we can actually do this， here， let's think about what this is actually
    doing。 You would say-- and this is the same function we had before--， Cv， wait，
    there's your mutex lock。 which remember it's going to unlock and then， reacquire
    it later-- you are going to say。
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你将其作为函数传入，或者由于我们使用的是C++，作为lambda函数传入。这是我们能够实际完成这件事的方法，来想一想这实际上在做什么。你会说——这就是我们之前的相同函数——Cv，wait，这是你的互斥锁。记住它会解锁，然后稍后重新获取——你将会说。
- en: give me access， in here to the reference of the permits variable in that， function。
    And in that function， you are going to check and see if， permits is greater than
    zero。 and return true if it's greater， than zero。 That's basically the exact same
    check you were doing before。 It's the inverse of the check if it's equal equal
    zero。 Right there。 [INAUDIBLE]。
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数中，给我提供访问permits变量的引用。然后在那个函数里，你将检查permits是否大于零。如果大于零，则返回true。这基本上就是你之前所做的完全相同的检查。它是检查是否等于零的反向操作。就在这里。[听不清]。
- en: The lambda that you pass has to be a Boolean return。 Because it's asking-- it
    has to know when to get out of that。
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递的lambda必须是布尔值返回类型。因为它正在询问——它需要知道什么时候退出。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_238.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_238.png)'
- en: Remember， here's how it's built。 Right？ While that， which is true or false。
    So that's that。 It could return something that can be converted into a， true or
    false。 but that has to be true or false in that sense。 So that's how you use that。
    and then you don't need to。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是如何构建的，对吧？当那件事为真或假时。所以就是这样。它可以返回可以转换为真或假的东西，但它必须在那个意义上是对或错。所以这就是你如何使用它。然后你不需要。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_240.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_240.png)'
- en: worry about even the while loop。 OK， so this is why these CV variables are relatively
    common。 So we can go one step further。 This idea that maybe we're waiting for
    a whole bunch of， threads。 some concrete maximum number of them can do， something。
    we could use the CV with this permits variable。 Why not wrap it into another type
    of data structure or class。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至不用担心while循环。好了，这就是为什么这些CV变量相对常见的原因。所以我们可以再进一步。这个想法是，也许我们在等待一大堆线程，其中一些具有具体的最大数量可以做某些事情。我们可以将CV与这个permits变量结合使用。为什么不将它封装到另一种类型的数据结构或类中呢？
- en: that actually allows us to do this for any number of， various site permits，
    et cetera。
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上允许我们为任何数量的各种网站许可证等执行此操作。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_242.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_242.png)'
- en: This is what we call a semaphore， which is basically， this whole idea of I have
    x number of threads。 and I have， only some of those allowed to do something at
    a given time。 In our case。 it's pickup forks， which seems a little silly。 In a
    real life scenario。 one you're going to code up for， the next assignment， you're
    going to be querying the， internet。
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的信号量，基本上就是这个概念：我有x个线程，而在特定时间内，只有其中一些线程可以做某些事情。在我们的案例中，是获取叉子，虽然这看起来有点傻。在现实生活中的场景中，你需要编写代码处理下一个任务，你将会查询互联网。
- en: and you're going to be doing it in many threads。 And what we want to do is we
    want to limit the number of。 threads that are actually accessing a， particular
    web page。 I don't know if you know that--。 have you ever heard of a DDOS， a distributed
    denial of， service attack？
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你将使用多个线程来进行操作。我们想做的是限制实际上访问某个特定网页的线程数量。我不知道你是否知道——你听说过DDOS攻击（分布式拒绝服务攻击）吗？
- en: Basically means that you have a website and it's able to。 take a bunch of connections
    for people who want the web， pages。 And what happens is various nefarious people
    get lots of。 servers that try to hammer away at asking for requests from， that
    web server。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着你有一个网站，它能够接受一大堆想访问网页的连接。而发生的事情是，一些恶意的人利用大量的服务器，不断向该网站的服务器发送请求。
- en: and it can't field them all。 And so people who aren't nefarious are trying to
    access， it。 and it basically brings the website down， where it makes， it really
    hard to access it quickly。 You don't want to do that if you're nice。 So you want
    to limit the number of threads that can access a。 particular website at a given
    time。 We're going to do it somewhat artificially， but you want。
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 它无法处理所有请求。因此，那些并非恶意的人也在尝试访问它。结果就是它会导致网站崩溃，变得非常难以快速访问。如果你是个好人，是不希望发生这种情况的。所以，你希望限制每次能访问特定网站的线程数量。我们将通过一种人工的方式来实现，但你会想要这么做。
- en: to be able to do that。 So you want to be nice， and many times you want to limit
    the。 number of things that can happen at a particular time。 This is how you'll
    do it。 So you might have 100 threads ready to go to that website， asking for something，
    but you say， no。 no， let's only let， them do it at a time so that we're nice so
    other people can。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够做到这一点。所以你希望对别人友好，并且很多时候你希望限制特定时间内能发生的事情数量。以下就是你如何做到的。你可能会有100个线程准备访问那个网站，提出请求，但你可以说，不，不，我们只允许一个线程一次执行，以便对别人更友好。
- en: get in there and do that。 That's what's happening。 And this is a very common
    sort of idea。 And in this case， we are going to use a thing called a， semaphore
    to do this。 Your question came up earlier is， are condition variable， entities
    built into C++？ Yes。 they're a library。 The bigger question is， why isn't a semaphore
    built into， the library？ Who knows？
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 进去看看发生了什么。这就是正在发生的事情。这是一个非常常见的概念。在这种情况下，我们将使用一个叫做信号量的东西来实现。你早些时候问的那个问题是，条件变量是C++内置的实体吗？是的，它们是一个库。更大的问题是，为什么信号量没有内置到库中？谁知道呢？
- en: Turns out it's really easy to build one， because all we're。 doing is really
    wrapping around that variable that's the， number of kind of count we have。 Why
    didn't they just build it in there？ Who knows？
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，构建一个信号量非常简单，因为我们只是在包裹那个变量，那个变量是我们所拥有的计数的数量。那为什么他们不直接把它内置进去呢？谁知道呢？
- en: Maybe the next some other version of C++ will have that in， there， but they
    don't have it。 But let's actually see how it's built。
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 也许下一个版本的C++会包含这个功能，但目前它没有。让我们来看一下它是如何构建的。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_244.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_244.png)'
- en: The semaphore constructor， it says the semaphore， instructor is so short that
    it's in line。 Let me actually show you this。 C-D/user/class CS110。
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的构造函数，它的写法非常简短，以至于就写在一行中。让我实际展示给你看。C-D/user/class CS110。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_246.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_246.png)'
- en: Local include， I had to look up what this was。 And then semaphore。h， here we
    go。
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本地包含，我必须查找这是什么。然后是semaphore.h，来吧。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_248.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_248.png)'
- en: Here's the class itself。
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类本身。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_250.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_250.png)'
- en: There's the class definition right there。 And notice that constructor has an
    integer as the value。 and， it just either sets it to zero， or it sets it to whatever。
    value number you pass in in the constructor。 So if you say I want five dining
    philosophers。 you would， say semaphore parentheses five， and it just sets that，
    variable to five。
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是类的定义。注意，构造函数有一个整数作为值，它要么将其设置为零，要么将其设置为你在构造函数中传入的任何值。所以，如果你说我想要五个哲学家，你会说`semaphore(5)`，然后它就会把那个变量设置为5。
- en: Just like we did with permits equals， or I guess semaphore， equals four， let's
    say。 permits equals four。 It's exactly what that's doing here。
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们做的那样，`permits = 4`，或者说`semaphore = 4`，让我们假设，`permits = 4`。这正是它在这里做的事情。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_252.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_252.png)'
- en: That's all the semaphore needs to do for this case。
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是信号量在这个案例中需要做的全部工作。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_254.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_254.png)'
- en: All right。 And then there is a weight function as part of the semaphore。
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，然后作为信号量的一部分，有一个等待函数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_256.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_256.png)'
- en: It's very simple。 It's exactly what we've already kind of seen here。 It basically
    puts a lock around the mutex that it's got。 And then it calls the weight function
    to try to wait for it。 based on the value being greater than zero。 And the value
    being greater than zero is the number of。
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。它基本上就是我们之前所看到的那样。它实际上把锁放在它拥有的互斥量上。然后它调用等待函数，试图根据值大于零来等待。而值大于零就是。
- en: permits， if you will， that we have。 If that number is greater than zero， then
    it。 decrements it and ends up making it so that it can keep， track of those permits。
    So it's really a very simple wrapper around a condition。
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 许可，如果你愿意，就是我们拥有的。如果这个数值大于零，它就会减少这个数值，并最终使其能够继续追踪这些许可。因此，它实际上是对条件的一个非常简单的封装。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_258.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_258.png)'
- en: variable， any， that does all the stuff we wanted to do。 Again， it's because
    we do this so often。 That's how the mutex works， like that。 At the end when you
    are done with your permit， all you need。 to do is call signal。 You don't need
    to worry about whether or not the permits are。 greater than or equal to zero。
    It just does exactly that。
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 变量，任何，做了我们想做的所有事情。再说一次，这是因为我们这么常做。互斥量就是这样工作的。在你完成许可后，你所需要做的就是调用信号。你不需要担心许可是否大于或等于零。它只是完全照做。
- en: It does what we did before in the actual class。 It increments it。 We'll talk
    about another interesting use of this， by， the way。 as we'll see this kind of
    next week when we get on， there。 But in this case。 let's see how we might modify
    our dining。
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 它做的就是我们之前在实际课堂上做的事情。它增加了它的值。顺便说一句，我们会讨论这个的另一个有趣的用法。下周我们开始时就会看到这一点。但在这种情况下，让我们看看如何修改我们的就餐哲学。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_260.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_260.png)'
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_261.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_261.png)'
- en: philosophers in this case。 Well， we can say semaphore permits。 We can say semaphore
    permits of however many we want。
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的哲学家们。好吧，我们可以说信号量许可。我们可以说信号量许可，数量可以是我们想要的任何数。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_263.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_263.png)'
- en: No more need for a condition variable， any。 It's already built into the semaphore。
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要条件变量，任何。它已经内置在信号量中了。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_265.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_265.png)'
- en: Meaning that all we need to do now is pass in a reference， to that semaphore
    as the permits。
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在需要做的就是传递一个引用，作为信号量的许可。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_267.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_267.png)'
- en: And everything else stays the same， except now we don't need。
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的一切都保持不变，除了现在我们不需要。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_269.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_269.png)'
- en: to call a particular function on this。 We've got the semaphore， which is doing
    all of that like。 checking for us。 So we just say permits。wait。 What does that
    mean？
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个特定函数。我们有信号量，它做了所有这些像检查的事情。所以我们只需要说许可。等待。那是什么意思？
- en: It will wait until there are at least one permit available。 And that's where
    we're doing。 If you want to， when you're done with your permit， you call， permits。signal。
    So it's all that stuff。 We just talk about it， simplifies it。 And it says， oh，
    now we've got this thing called a semaphore。 which says you have x number of things
    that can do it at a， time。
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 它将等待直到至少有一个许可可用。这就是我们正在做的。如果你想，当你完成你的许可时，你调用许可。信号。所以就是这些。我们只是谈论它，简化了它。然后它说，哦，现在我们有了这个东西叫信号量。它表示你有
    x 个东西可以同时做这件事。
- en: and maybe x plus y number of things that want it。 Wait until there are at least
    one available to do that。 And we'll--， [INAUDIBLE]， When can't you use semaphore？
    When is it better to use that？
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是 x 加 y 个需要它的东西。等到至少有一个可用来做这件事的资源。然后我们会——，[INAUDIBLE]，什么时候不能使用信号量？什么时候使用它会更好？
- en: You will see a couple examples in lab next week。 No labs this week。 You'll see
    a couple examples in lab。 You can actually put the week after where you'll see
    this。 C of any of the-- oh， now I see why that might be important， to use that。
    But better generally。 we're going to almost always use--， you will probably need
    one for a future assignment where。
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下周你将在实验中看到一些例子。这个星期没有实验。你会在实验中看到一些例子。你实际上可以放在下下周，这时你会看到这个。C 类的任何——哦，现在我明白了，为什么使用它可能很重要。但通常来说，最好是，我们几乎总是会使用——你可能需要一个，在未来的某个任务中使用。
- en: you're not really waiting for a whole bunch of things。 And by the way。 a mutex
    is just a semaphore with a value of 1。 Because a mutex is going to lock or unlock
    for one thing。 That's really all it is。 So mutex is like a special version of
    semaphore for only， one thing。 But yeah， we'll see some more examples where you
    will， probably need a condition variable， any。
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你其实并不是在等待一大堆东西。顺便说一句，互斥锁（mutex）其实就是一个值为1的信号量。因为互斥锁是用来锁定或解锁一个东西的。就这么简单。所以互斥锁就像是信号量的一个特例，只不过它只适用于一个东西。嗯，我们会看到一些例子，你可能会需要条件变量。
- en: But in general， most of the time， you'll be able to use。
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 但总的来说，大多数时候，你将能够使用。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_271.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_271.png)'
- en: semaphore for this。 All right， I think we should probably stop there。 You guys
    have mid-term coming up。 You have other things。 And that's that。 Are there any
    last-minute questions？ I'm going to also go back from here， back to my office，
    for。 another hour and a half or so， for office hours， if you want， to come back。
    All right。
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 用于这个的信号量。 好的，我想我们应该到此为止了。你们有期中考试要准备，其他的事情也很多。就这样了。还有什么最后的问题吗？我稍后会回到我的办公室，再待一个半小时左右，进行办公时间，如果你们想来的话，可以回来。好的。
- en: we'll see you tomorrow for the midterm。
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明天见，期中考试时见。
- en: '![](img/048b7e540d7f0db4c80128b8a9481077_273.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/048b7e540d7f0db4c80128b8a9481077_273.png)'
