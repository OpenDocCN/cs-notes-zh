- en: P15：Lecture 15 Transactions & Concurrency II - ___main___ - BV1cL411t7Fz
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P15：第15讲 事务与并发 II - ___main___ - BV1cL411t7Fz
- en: OK， all right。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题。
- en: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_1.png)'
- en: Yeah。 It is very warm today。 I don't know if learning about transactions， is
    going to help。 But let's do it anyway。 So we've been talking about how to guarantee
    isolation。 When you have multiple transactions that are both， that are issued
    to a database system。 And we were talking about how do you， guarantee that these
    transactions don't interfere。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，今天非常暖和。我不知道学习事务处理是否有帮助，但我们还是继续做吧。我们一直在讨论如何保证隔离性。当你有多个事务同时发往一个数据库系统时，我们在讨论如何保证这些事务不相互干扰。
- en: with each other。 And we were talking about ensuring。 some notion of correctness
    as these transactions are executed。 So if you have multiple transactions that
    are being executed。 how do you interleave that operations in such a way， that
    you can sell guarantee that it's。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论如何确保这些事务执行时的一些正确性概念。如果你有多个事务同时执行，你如何交错这些操作，才能确保它们的正确性？
- en: doing something reasonable？ So just a bit of recap。 We talked about the notion
    of a schedule。 A schedule is basically a sequence of actions， on various bits
    of data from one or more transactions。 So it's basically encompasses big in a
    transaction， read and write various objects。 This could be pages， do-goes， what
    have you relations， and then commit or abort。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 做一些合理的事情？稍微回顾一下，我们讨论了调度的概念。调度基本上是一个或多个事务对不同数据位的操作序列。所以它基本上包含了事务的开始（begin）、读取和写入不同对象的操作。这些对象可能是页面、日志、关系等，最后是提交或回滚。
- en: Commit basically says that I want the effects of this transaction， to be persisted。
    Abort basically says， undo the effects of this transaction。 I no longer want this
    transaction。 to be reflected on the data。 And so there were two representations
    that we looked at。 One is a tabular representation where each column， corresponds
    to a separate transaction。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 提交（Commit）基本上是说我希望这个事务的效果被持久化。回滚（Abort）基本上是说，撤销这个事务的效果。我不再希望这个事务的变化反映到数据上。因此我们看了两种表示方式。一种是表格表示法，其中每一列对应一个独立的事务。
- en: And this string representation where you basically， list out the operations
    in sequence。 So here transaction 1 of read A， transaction 1， then wrote A， transaction
    1 wrote read B。 and wrote B， and so on。 And convention for the string representations。
    that we only include the committed transactions。 And we omit the big in and the
    commit。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种是字符串表示法，其中你基本上按顺序列出所有操作。所以在这里，事务1读取A，事务1写入A，事务1再读取B，并写入B，依此类推。字符串表示法的约定是，我们只包括已提交的事务，省略开始（begin）和提交（commit）。
- en: in this string representation。 So like I said， we need a starting point。 for
    defining what is correct in a schedule。 And so the natural starting point is serial
    schedules。 A serial schedule basically says you， are sequencing the transactions
    in such a way。 that each transaction runs from start， to finish without any intervening
    or interleaving。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字符串表示法中，正如我所说，我们需要一个起点来定义调度的正确性。因此，自然的起点是串行调度。串行调度基本上是说，你按顺序执行事务，每个事务从开始到结束，不会有任何干扰或交错。
- en: and actions from other transactions。 So this is basically complete isolation。
    So in this squiggles diagram here， all of the actions of transaction 1。 happen
    before the actions of transaction 2。 So this is a serial schedule。 And the second
    definition that we need， is a notion of equivalence。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 而且来自其他事务的操作。这样基本上就实现了完全隔离。在这个波形图中，事务1的所有操作都在事务2的操作之前完成。所以这是一个串行调度。我们需要的第二个定义是等价性的概念。
- en: And so two schedules are deemed to be equivalent， if they involve the same set
    of transactions。 And each transactions actions are ordered the same internally。
    So each transaction is doing the same thing。 And both of these schedules leave
    the database。 in the same final state。 So basically think about it in the following
    way。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果两个调度包含相同的事务集，并且每个事务内部的操作顺序相同，那么这两个调度被认为是等价的。也就是说，每个事务在做相同的事情，而且这两个调度将数据库的最终状态保持一致。所以，基本上你可以从以下的方式来理解。
- en: It's the same set of transactions。 It's the same set of stuff that's happening
    to the database。 Each of these transactions are obeys in the same way。 They have
    the same set of actions。 And then the final effect of these transactions is the
    same。 So that's the notion of equivalence。 A schedule is deemed to be serializable。
    So this is our first notion of correctness。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的事务集。它是作用于数据库的相同操作集。每个事务都以相同的方式执行。它们有相同的操作集。然后这些事务的最终效果是相同的。这就是等效性的概念。一个调度被认为是可串行化的。所以这是我们定义的第一个正确性概念。
- en: that we're talking about here。 A schedule is deemed to be serializable。 if it's
    equivalent to some serial schedule。 Recall that serial schedule means basically
    complete isolation。 D1 before T2 before T3 or some other permutation， of the transactions。
    But it's basically complete isolation。 So in this two transaction case， a schedule。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的一个调度被认为是可串行化的，如果它等价于某个串行调度。回想一下，串行调度意味着基本上是完全隔离的，D1在T2之前，T2在T3之前，或者这些事务的其他排列顺序。但基本上它是完全隔离的。所以在这个两个事务的例子中，一个调度。
- en: S is deemed to be serializable even though it has interleavings。 of operations
    across these transactions。 It's deemed to be serializable if it。 is equivalent
    to some serial schedule like T1 before T2， or T2 before T1。 So that is the notion
    of serializable， which， is one of the correctness notions that we want to define
    here。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使S调度有事务间操作交错，它仍被认为是可串行化的。如果它等价于某个串行调度，例如T1在T2之前，或T2在T1之前。那么这就是可串行化的概念，这是我们想要在这里定义的正确性概念之一。
- en: We will define other notions of correctness， which are a little easier to check
    afterwards。 OK。 so let's get some intuition for this notion， of serializability。
    So if you have this schedule， S1。 which is a serial schedule--， so all of actions
    of transaction one， happen before transaction two。 And in this particular case，
    T1 is transferring $100 from A， to B。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义其他正确性的概念，这些概念稍后会更容易检查。好了，接下来让我们对这个可串行化的概念有一些直观理解。所以，如果你有这个调度S1，它是一个串行调度——也就是说，事务1的所有操作都发生在事务2之前。在这个特殊情况下，T1正在将100美元从A转账到B。
- en: T2 is adding 10% interest to both A and B。 Then if you have a serial schedule
    in which T1 is followed。 by T2， the final outcome is A prime is 1。1 times A minus
    100， and B is something similar。 All right。 so that's one possible serial schedule。
    Here's another serial schedule in which T2 is followed by T1。 So in this particular
    case， T2's effects are first reflected， on your data。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: T2正在对A和B都加上10%的利息。那么如果你有一个串行调度，其中T1在T2之后执行，最终的结果是A' = 1.1 × A - 100，B也是类似的。好的，这就是一个可能的串行调度。这里还有另一个串行调度，其中T2在T1之后执行。所以在这个特殊的情况下，T2的效果首先反映在你的数据上。
- en: and then T1's effects are reflected。 So you have A multiplied by 1。1， B multiplied
    by 1。1。 and then the transfer happens between A and B。 So basically。 you subtract
    100 from A and you add 100 to B。 So this is a different schedule。 but it's still
    understandable。 It's still isolated。 It's still correct。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后T1的效果被反映出来。所以你有A乘以1.1，B乘以1.1，然后发生A和B之间的转账。所以基本上，你从A中减去100并加到B中。所以这是一个不同的调度，但它依然可以理解，依然是隔离的，依然是正确的。
- en: Let's talk about another schedule， which is not a serial schedule。 This is not
    a serial schedule。 Here in this schedule， you have T1 performing its actions on
    A， so reducing A by 100。 And then T2 performs its multiplication， on the values
    of A times 1。1。 T1 then reads and writes B。 So basically adds 100 to B， and T2
    multiplies B by 1。1。 Now， here， this is not a serial schedule。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下另一个不是串行调度的调度。这个不是串行调度。在这个调度中，T1在A上执行操作，将A减少100。然后T2对A值乘以1.1进行乘法操作。T1然后读取并写入B。所以基本上是把100加到B中，而T2把B乘以1.1。现在，在这里，这不是一个串行调度。
- en: but it's equivalent to the first schedule， where transaction T1's actions happen
    entirely。 before transaction T2's actions。 And hopefully， you can convince yourself。
    that it is equivalent to that， because in this case， A， you start with subtracting
    A minus 100。 and then multiply it by 1。1。 And B， you start by adding 100， and
    then you multiply it， by 1。1。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但它等同于第一个调度，其中事务T1的操作完全发生在事务T2的操作之前。希望你能说服自己，认为它与此等效，因为在这种情况下，A，你先从A中减去100，然后再乘以1.1。而B，你先加上100，然后再乘以1.1。
- en: So it's basically like T1's actions， happen before T2's actions。 So this is
    serializable。 Even though it's not serializable。 OK， so the challenge with this
    serializable notion。 is that it's tricky to check this property， that a schedule
    leaves the database in the same final state。 as some other schedule。 And so we
    need a simpler， easier equivalence test。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上就像是T1的操作发生在T2的操作之前。这样是可串行化的，尽管它本身并不可串行化。好吧，关于这个可串行化概念的挑战在于，它很难检查一个调度是否将数据库留下的最终状态与另一个调度的最终状态相同。所以我们需要一个更简单、更容易的等价性测试。
- en: And so what we're going to end up using， is a more conservative test。 So it
    has no false positives。 So it will not correct-- it will not incorrectly， deem
    something to be serializable even though it's not。 But it does have false negatives，
    which， means that it can sometimes say， hey。 this is not serializable， even though
    it is serializable。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们最终将使用一个更保守的测试。它没有假阳性。也就是说，它不会错误地判断某个调度是可串行化的，即使它实际上不可串行化。但是它有假阴性，意味着它有时会说，嘿，这个调度不可串行化，尽管它是可串行化的。
- en: So you are basically sacrificing some concurrency， for this easier correctness
    check。 You're still guaranteed correctness， but you are basically saying， hey。
    there are some schedules that I will not admit。 So it's basically being more conservative。
    So this test that we're going to use， is a different correctness notion。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你基本上是在牺牲一些并发性，换取更容易的正确性检查。你仍然保证正确性，但你基本上是在说，嘿，有一些调度我将不接受。所以这基本上是更保守的做法。所以我们将要使用的这个测试，是一种不同的正确性概念。
- en: Use the notion of conflicting operations。 So these are pairs of either read，
    write， or write， write。 or write， read operations。 And so two operations are set
    to conflict if they。 are by different transactions。 They're on the same object，
    and at least one of them is a write。 So basically， this conflict induces， a basic
    sequencing between these two transactions。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冲突操作的概念。所以这些是成对的操作，可以是读写、写写，或写读操作。所以如果两个操作满足以下条件，它们会被认为是冲突的：它们来自不同的事务，操作的是同一个对象，并且至少有一个是写操作。所以基本上，这种冲突会在这两个事务之间引入基本的排序。
- en: So if transaction two read something， the transaction one wrote， that's a conflict。
    If transaction one and transaction two both wrote the same thing。 transaction
    one's write happened before transaction two， that's a conflict， and so on。 So
    these are all conflicts。 And so the order of non-conflicting operations。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果事务二读取了事务一写入的内容，那就是一个冲突。如果事务一和事务二都写入了相同的内容，并且事务一的写操作发生在事务二之前，那就是一个冲突，依此类推。这些都是冲突。所以非冲突操作的顺序。
- en: has no effect on the final state of the database。 And the reason for this is
    if I was writing B。 and you were writing A， it doesn't matter。 But if both of
    us were writing to the same object A。 that becomes a problem。 Or if I was writing
    something and you were reading it immediately。 after that's a problem。 So our
    attention， as we focused on the order of conflicting， operations。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据库的最终状态没有影响。原因是，如果我在写B，你在写A，那就没关系。但如果我们都在写同一个对象A，那就成问题了。或者如果我在写某个东西，而你在我写完后立即读取，那也是个问题。所以我们的关注点，主要集中在冲突操作的顺序上。
- en: is supposed to non-conflicting operations， with the definition of conflict being
    like this。 So armed with this notion of a conflict， let's define the notion of
    conflict serializable。 So this is a variation of the serializable notion， that
    we defined earlier。 So two schedules are deemed to be conflict equivalent。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是非冲突操作，冲突的定义是这样的。所以我们有了冲突的概念之后，让我们定义冲突可串行化的概念。这是我们之前定义的可串行化概念的一种变体。所以如果两个调度是冲突等价的，那么它们就被认为是可串行化的。
- en: if they involve the same actions of the same transactions， in the same order--
    so basically。 same set of transactions， in the same actions within each transaction--。
    and every pair of conflicting actions， is ordered in the same way。 So every conflict
    is ordered in the same way。 So if there is a conflict where transaction one。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们涉及相同事务的相同行为，并且顺序相同——基本上，就是相同的一组事务，在每个事务内的相同行为——并且每一对冲突操作，都是按照相同的顺序排列的。所以每一个冲突都是按照相同的顺序排列的。所以如果事务一存在冲突的话。
- en: is writing something and transaction two is reading something。 and it's in one
    order in the first schedule， it has to be in the same order in the second schedule。
    And then using this notion of conflict equivalent。 we can define the notion of
    conflict serializable。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务一写了某个东西，而事务二读取了某个东西，并且在第一个调度中的顺序与第二个调度中的顺序相同，那么就必须保持一致。然后，利用这种冲突等价的概念，我们可以定义冲突可串行化的概念。
- en: So this is an extension of the serializable notion， that we defined earlier。
    A schedule S is deemed to be conflict serializable。 if it is conflict equivalent
    to some serial schedule。 And since conflict serializable is a more conservative
    property。 it means that S is also serializable。 So conflict serializable is more
    conservative than serializable。 So that means that S is also serializable。 So
    but this is not a complete set。 There are actually serializable schedules， that
    are not conflict serializable。 And so conflict serializable gives us false negatives。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们之前定义的可串行化概念的扩展。如果一个调度 S 与某个串行调度是冲突等价的，那么它被认为是冲突可串行化的。而由于冲突可串行化是一个更为保守的属性，这意味着
    S 也是可串行化的。所以冲突可串行化比可串行化更保守。这意味着 S 也是可串行化的。但这并不是一个完整的集合。实际上，有一些可串行化的调度是不可冲突串行化的。因此，冲突串行化会给我们带来假阴性。
- en: when we're using it as a test for serializable。 Like I said， so it's more conservative。
    And this is the cost of using a conservative test， that misses some serializable
    schedules。 even though they are serializable。 And this is a trade-off that we
    are willing to make。 because it's cheaper to enforce conflict serializability。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它作为一个可串行化的测试时。正如我所说，它更为保守。这就是使用保守测试的代价，它错过了一些可串行化的调度，即使它们是可串行化的。这是我们愿意做出的权衡，因为强制执行冲突串行化性更便宜。
- en: So there's an equivalent notion of conflict serializability， which is easier
    to work with。 at least for the example that I'm gonna describe。 And so that is
    this notion， which is a schedule S。 is deemed to be conflict serializable。 If
    you can transform S into a serial schedule。 by simply swapping consecutive non-conflicting
    operations， of different transactions。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个与冲突串行化等价的概念，这个概念更容易处理，至少对我将要描述的例子是这样。所以这是这个概念：一个调度 S 被认为是冲突可串行化的，如果你可以通过简单地交换不同事务之间连续的非冲突操作，将
    S 转换为一个串行调度。
- en: So consider any such swaps between non-conflicting operations， of different
    transactions。 If you can reach a serial schedule， then that also means that S
    is conflict serializable。 So to make this definition a little more， sort of concrete
    in your head， let's look at an example。 So this is my string sequence of operations，
    and this is transaction one， transaction two。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以考虑一下不同事务之间的非冲突操作的任何交换。如果你能得到一个串行调度，那么这也意味着 S 是冲突可串行化的。为了让这个定义在你脑海中更为具体一些，我们来看一个例子。这是我的操作顺序，这是事务一，事务二。
- en: So basically transaction one， red， a， road， a， and then transaction two， red，
    a， road， a。 and then transaction one， red， b， road， b， and so on。 So this is the
    example。 Now I'm gonna try doing swaps。 So I'm trying to swap consecutive non-conflicting
    operations。 to try to get this to a serial schedule。 So the first operation that
    I'm gonna swap is RB and WA。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，事务一，红色，a，路，a，然后事务二，红色，a，路，a。接着事务一，红色，b，路，b，依此类推。所以这就是这个例子。现在我将尝试进行交换。所以我尝试交换连续的非冲突操作，试图将其转换为串行调度。所以我要交换的第一个操作是
    RB 和 WA。
- en: So that was the operation that was a swap。 That's okay， I can swap these two。
    because these are on different objects， A and B。 So I can swap them。 So that's
    not a conflict。 Okay。 I can continue swapping。 So now I'm gonna swap WB and WA
    from these two transactions。 again on different objects， so I can swap them。 Then
    I can swap RB and RA again on different objects。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个交换操作。没问题，我可以交换这两个，因为它们位于不同的对象上，A 和 B。所以我可以交换它们，这不是一个冲突。好吧，我可以继续交换。现在我要交换这两个事务中的
    WB 和 WA，它们仍然位于不同的对象上，所以我可以交换它们。然后我可以再次交换 RB 和 RA，它们也在不同的对象上。
- en: and then I can swap WB and RA。 So now with all of these swaps。 I have basically
    transformed this schedule to this schedule。 So by basically swapping non-conflicting
    operations， I've managed to reach a serial schedule。 That means that this schedule
    is conflict equivalent， to this serial schedule。 Okay。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以交换 WB 和 RA。所以现在通过所有这些交换，我基本上把这个调度转换成了这个调度。所以通过交换非冲突的操作，我成功地得到了一个串行调度。这意味着这个调度与这个串行调度是冲突等价的。好的。
- en: and therefore it's conflict serializable。 Okay。 Now let's take another example。
    and talk about whether this is conflict serializable or not。 Okay， so I have two
    transactions。 T1 and T2。 Do we think this is conflict serializable or not？ (silence)，
    No， why not？
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此它是冲突可串行化的。好的，现在让我们再看一个例子，讨论它是否是冲突可串行化的。好的，我有两个事务，T1 和 T2。我们认为它是冲突可串行化的吗？（沉默）不，为什么不呢？
- en: Because A is the same。 Yeah， so all of the operations are happening， on the
    same object A。 So even though I can actually swap these two， I can swap RA and
    RA from these two transactions。 I can swap that， but then I have a block， right？
    I can't move this RA any further。 So even if I move this RA here， let's say RA，
    I can't move go any further。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为A是相同的。是的，所以所有操作都发生在同一个对象A上。所以即使我实际上可以交换这两个操作，我可以交换这两个事务中的RA，但是我交换后就会遇到阻碍，对吧？我不能再移动这个RA了。所以即使我把这个RA移动到这里，比如RA，我也无法再继续交换。
- en: because I can't swap the order of these two。 These two are a conflict。 I can't
    swap the order of these two， because these two are a conflict。 So basically I'm
    left with this schedule， that cannot be transformed into a serial schedule。 Okay。
    So Alvin makes an important point。 So he says his swapping is just an exercise。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我不能交换这两个操作的顺序。这两个操作是冲突的。我不能交换这两个操作的顺序，因为它们是冲突的。所以基本上我只能保留这个调度，不能将其转换为串行调度。好的。所以Alvin提出了一个重要观点。他说他的交换只是一个练习。
- en: to check if a schedule is conflict serializable， right？
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个调度是否是冲突可串行化的，对吧？
- en: So here we are trying to test whether something is equivalent， to a serial schedule
    or not。 Okay。 all right。 So this is not conflict serializable。 So you can only
    swap the order of the RA's。 but nothing more。 So how do we check this more generally，
    right？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里我们在尝试测试某个调度是否等价于串行调度。好的。明白了。所以这个不是冲突可串行化的。所以你只能交换RA的顺序，不能做更多的交换。那么我们如何更一般地检查这个问题呢？
- en: So you sort of individually doing these swaps， is a little painful。 So why。
    how do we check whether something is conflict serializable， or not？
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你是单独进行这些交换，这有点痛苦。那么，为什么呢？我们怎么检查某个事务是否是冲突可串行化的呢？
- en: So one way to do this is to use this conflict dependency graph， right？
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以做这个的一个方法是使用这个冲突依赖图，对吧？
- en: So you basically have one node per transaction。 So TI and TJ in this example。
    And there's an edge between from TI to TJ， if there's an operation OI within TI。
    that conflicts with an operation OJ in TJ， and OI appears earlier in the schedule
    than OJ。 Not Simpson， but OI appears earlier in the schedule， than OJ。 Okay。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你基本上每个事务对应一个节点。比如这个例子中的TI和TJ。如果TI中的操作OI与TJ中的操作OJ冲突，并且OI在调度中出现在OJ之前，则TI和TJ之间就有一条边。不是辛普森的，但OI确实在调度中出现在OJ之前。好的。
- en: so basically it says that this is a conflict， that I can't flip in the other
    direction， right？
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上它说的是这是一个冲突，我不能将其交换到另一方向，对吧？
- en: So basically saying that there is a dependency， in this direction。 Okay。 so
    the theorem now that we have， this graph is that a schedule is conflict serializable。
    if and only if this dependency graph is acyclic， right？ So this， this is。 I'll
    let you prove this at home， but the sketch here is that basically these edges
    indicate。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上说，这个方向上有一个依赖关系。好的。所以现在我们有了这个图的定理是：一个调度是冲突可串行化的，当且仅当这个依赖图是无环的，对吧？所以，这个，我让你们回家自己证明，但这里的框架是，这些边基本上表示。
- en: sort of a temporal relationship， between certain operations or a temporal relationship。
    between certain transactions。 That if you can't， if you have a cycle in this graph。
    that means that you can't find an ordering， of the transactions。 you can't determine
    a serial schedule， right？ If instead the graph is acyclic。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就是某些操作之间的时间关系，或者某些事务之间的时间关系。如果你有一个循环出现在这个图中，这意味着你不能找到一个事务的排序，也无法确定一个串行调度，对吧？如果图是无环的。
- en: basically that the edges， you by topologically sorting。 that graph that gives
    you that serial schedule， and that serial schedule is what you will get。 if you
    did these swaps individually， right？ There are many such schedules each。 from
    one possible topological sort， but these edges determine what you can。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你通过拓扑排序这些边。那张图会给你一个串行的调度，而那个串行调度就是你最终得到的结果。如果你单独进行这些交换，对吧？每一个从一个可能的拓扑排序得到许多这样的调度，但这些边决定了你能做什么。
- en: and can't do in terms of the swap。 So overall， the theorem basically says。 if
    this dependency graph is acyclic， then it's conflict serializable。 Okay。 and the
    proof basically says， that if you have conflicting operations。 they prevent us
    from swapping operations， into a serial schedule and a serial schedule。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 和不能做什么的交换操作。因此，总的来说，定理基本上说：如果这个依赖图是无环的，那么它就是冲突可串行化的。好的，证明基本上是说，如果你有冲突的操作，它们会阻止我们将操作交换到一个串行调度中。
- en: would be basically just a topological sort of this graph。 Okay。 so let's take
    an example to make this a little more clear。 So let's say I have these two operations
    in T1， R A and W A。 So I have not added any operations T2 yet， but let's say T2
    now has R A。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上只是对这个图进行拓扑排序。好的，下面我们通过一个例子来更清楚地说明。假设我在 T1 中有这两个操作，R A 和 W A。所以我还没有添加任何 T2
    中的操作，但假设 T2 现在有 R A。
- en: And since this operation R A and W A conflict， there is basically a temporal
    relationship。 that says that T2 has to happen after T1， and therefore you're encoding
    this via an edge。 Okay。 then let's say T2 has a bunch of other writes and reads。
    So it writes A reads B writes B。 And then let's say T1 reads B。 Okay， so this
    is the schedule。 And since you have RB at the end。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作 R A 和 W A 之间存在冲突，本质上有一个时间顺序关系。也就是说 T2 必须在 T1 之后执行，因此你通过一条边来表示这个关系。好的，然后假设
    T2 还有其他的写操作和读操作。比如它写 A 读 B 写 B，然后假设 T1 读 B。好的，这就是调度。由于你在最后有 RB，
- en: that means that there's a conflict between WB and RB， WB and T2 and RB and T1。
    That means that I need to add a back edge from T2 to T1 based on B。 Okay， so from
    this point， given。 so this graph obviously has a cycle。 So that means that this
    is not conflict serializable。 according to the definition that we gave earlier。
    And intuitively。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 WB 和 RB 之间有冲突，WB 和 T2 之间也有冲突，以及 RB 和 T1 之间也有冲突。这意味着我需要基于 B 从 T2 到 T1 添加一条回边。好的，从这个点开始，给定……所以这个图显然有一个环。所以根据我们之前给出的定义，这不是冲突可串行化的。从直观上讲，
- en: it's also very clear why you can't really perform， swaps in this particular
    example。 so that either T1 happens before T2 or T2 happens before T1。 Because
    these edges are these relationships。 Basically indicate a conflict that can't。
    you can't flip it。 The other things you can't flip。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这也非常清楚为什么在这个特定的例子中你不能真正进行交换。也就是说，要么 T1 在 T2 之前执行，要么 T2 在 T1 之前执行。因为这些边，这些关系，基本上表示一个无法交换的冲突。其他的事情你也不能交换。
- en: but these are blockages that prevent you from flipping the schedule。 so that
    you can get to a serial schedule。 Okay， any confusion about this notion of conflict
    serializable。 and why the graph is helpful in determining whether a schedule，
    is conflict serializable or not？
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这些是阻塞，阻止你翻转调度，从而使你能够得到一个串行调度。好的，对于冲突可串行化的这个概念，有没有什么困惑？以及为什么图在确定一个调度是否是冲突可串行化时很有帮助？
- en: Ian？ Oh， yes， just the clarify。 So essentially for each conflict in pair。 we're
    going to have one arrow， right？ Exactly。 Yeah。 so there will be multiple arrows
    between two transactions， in each direction。 You don't need to keep all of these
    edges around as long as you。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ian？哦，是的，只是为了澄清。所以本质上，对于每一对冲突，我们将有一条箭头，对吧？没错，没错。所以在两个事务之间会有多条箭头，指向不同的方向。只要你……
- en: preserve one arrow in each direction that's efficient。 I see。 Thank you。 Yeah。
    Was there another question from Warren？ Oh， yeah。 Is there anything else that
    we might want to check for other than。 cycles for this graph？ Not if you're trying
    to determine conflict serializability。 There are other forms of other variants
    wherein you might want。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方向上保留一条箭头是高效的。我明白了，谢谢。对了，Warren 还有其他问题吗？哦，是的，除了检查这个图是否有环，还有其他需要检查的吗？如果你试图确定冲突可串行化的话，那就没有了。还有其他形式的变体，你可能会想要……
- en: to use more relaxed notions or more stricter notions。 And I'll talk about one
    stricter notion of serializability， subsequently。 Any other questions？ Okay。 So
    this is the stricter notion of stricter， but it sort of has a less it's a less
    conservative notion of。 serializable。 So it has fewer false negatives。 So for
    this notion。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用更宽松的概念或更严格的概念。接下来我会讲解一个更严格的可串行化概念。还有其他问题吗？好的。这个是更严格的概念，但它的保守性较弱，属于一个较宽松的可串行化概念。所以它有更少的假阴性。对于这个概念，
- en: this notion is called view serializability。 The previous one was called conflict
    serializability。 So this is fewer false negatives。 So it's between in terms of
    conservativeness。 It's between conflict serializable and full serializable。 Right。
    So in this notion。 two schedules as one and S two are deemed to， be view equivalent。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念叫做视图可串行化（view serializability）。之前的概念叫做冲突可串行化（conflict serializability）。所以这会有更少的假阴性（false
    negatives）。从保守性角度来看，它介于冲突可串行化和完全可串行化之间。对的。所以在这个概念中，两个调度 S1 和 S2 被认为是视图等价的。
- en: If basically it has you sort of need to do a fine grain bookkeeping。 of what's
    happening with each transaction and each object。 Okay。 So the bookkeeping happens
    as follows。 It basically says two schedules as one and S two are equivalent。 If
    you're doing the same set of initial reads。 So if T one read the initial value
    of a in S one。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基本上它要求你进行非常细致的记录，记录每个事务和每个对象的操作。好吧。于是，记录方式如下。它基本上说明了两个调度S1和S2是等效的。如果你进行的是相同的一组初始读取操作。所以如果T一在S1中读取了A的初始值。
- en: then T， sorry， T I read the initial value of a in S one， then T I read the。
    initial value of a in S two as well。 Okay。 So they did the same initial reads
    and then it did the same。 dependent reads。 Okay。 So if T I read the value of a
    written by T J in S one， then T。 I also reads a value of a written by T J in S
    two。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后T，我在S1中读取了A的初始值，然后T我在S2中也读取了A的初始值。好吧。所以他们做了相同的初始读取操作，然后做了相同的依赖性读取。好吧。所以如果T我在S1中读取了T
    J写的A的值，那么T我也在S2中读取了T J写的A的值。
- en: So basically everything that was written and then read is also。 happening in
    the same way in the two schedules。 Finally。 what is left as a result of these
    operations is the same。 If T I writes a final value of a in S S one， then T I
    also writes， a final value of a in S two。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上所有写入并随后被读取的操作，在两个调度中发生的方式是相同的。最后，作为这些操作结果的是什么是相同的。如果T我在S1中写入了A的最终值，那么T我也在S2中写入了A的最终值。
- en: So this is kind of a fine grain bookkeeping of what is being read。 What is the
    start？
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常细致的记录方式，记录了哪些值被读取了，哪些是开始的？
- en: So who reads the values the start？ Then if something something is written who
    reads that and then。 finally who writes at the end。 Okay。 So how does this sort
    of fine grain notion of equivalence help？
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么谁读取了这些值，开始时？然后，如果某些东西被写入了，谁来读取这些？然后最后，谁在最后写入？好吧。这种细粒度的等效性概念如何发挥作用呢？
- en: So this notion allows all conflict serializable schedules。 So every conflict
    serializable schedule is also view serializable。 It also admits what are known
    as blind rights。 So it's less conservative than conflict serializable。 but because，
    it allows this notion of blind rights。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个概念允许所有的冲突可序列化调度。因此，每一个冲突可序列化的调度也是视图可序列化的。它还允许所谓的盲写操作。因此，它比冲突可序列化的要求更宽松，因为它允许盲写操作的存在。
- en: So let's take an example to understand what blind rights would mean。 So let's
    say I have these three trans three transactions T one， T two and T three。 Okay。
    So in T one you have R a and then W a and T two has just W a and T three has just，
    W a。 Okay。 And again， this is a string representation。 So you're reading this
    from left to right。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们举个例子来理解什么是盲写操作。假设我有这三个事务，T一，T二和T三。好吧。在T一中，你有读A（R a）然后写A（W a），T二只有写A（W a），T三也只有写A（W
    a）。好吧，再次强调，这只是一个字符串表示。你从左到右读取这个操作序列。
- en: Now we view see。 So firstly， notice that in this case in conflict serializable，
    there is a conflict。 between these two。 So I can't really swap these two operations。
    And we use the realizability these these two this schedule is equivalent view
    equivalent。 to this other schedule， which basically has all of T one's operations
    first。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看视图可序列化性。所以首先请注意，在冲突可序列化的情况下，这两者之间是有冲突的。因此，我不能交换这两个操作。我们使用可序列化性来说明，这两个调度是等效的，视图上等效的。与另一个调度等效，这个调度基本上把T一的所有操作都放在最前面。
- en: then T two's operations and T three's operations。 And the reason why we were
    able to swap these two operations in the view。 serializability notion is because
    these two options these two operations are。 basically writing values of a that
    nobody is reading。 Right。 They are writing values of a that nobody is reading
    and only the final value T three's。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是T二的操作和T三的操作。我们能够在视图可序列化的概念中交换这两个操作的原因是，这两个操作基本上是在写入一个A的值，而没有任何事务在读取它。对吧？它们是在写入一个A的值，而没有任何事务在读取它，最终只有T三的写入值才是有效的。
- en: value that is written。 It basically overrides the values written by T one and
    T two。 And so what T one and T two and what order they write a doesn't matter
    because both of them。 get superseded by the right by T three。 Okay。 So this final
    right is the one that wins。 So these blind rights is rights that are done by transactions
    that are not read by anyone is。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 被写入的值。它基本上覆盖了T一和T二写入的值。所以T一和T二的写入顺序并不重要，因为它们都会被T三的写入操作覆盖。好吧，所以最终的写入操作才是决定性的。这样，盲写操作就是那些事务写入了值但没有被任何人读取的操作。
- en: basically they can be flipped。 Okay。 So in this in this notion。 So that's a
    notion of you see the liability is basically less conservative compared to。 conflict
    serializable， but the downside of you see the liability is that it's。 difficult
    to enforce it's you need to do very fine grained bookkeeping about who read what
    first。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上它们可以被翻转。好吧。所以在这个概念中。这个可序列化性的概念基本上比冲突序列化要宽松，但你看，可序列化性的缺点是它。很难执行，你需要非常细致地记录是谁先读取了什么。
- en: and who is reading which version of each object that's very hard to do。 So but
    that said neither notion either you see the liability not conflict serializability。
    allow all schedule that actually serialize because you don't understand the meanings
    of the operations。 or the data。 Okay。 So serializability actually talks about
    the final state of the data and sort of encodes the。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 谁在阅读每个对象的哪个版本，这很难做到。所以，话虽如此，无论是哪个概念，你都会看到可序列化性不冲突。允许所有调度实际上是可序列化的，因为你不了解操作的意义。或者数据的意义。好吧。所以，可序列化性实际上谈论的是数据的最终状态，并在某种程度上对其进行编码。
- en: semantics of the operations need of you serializability nor conflict serializability
    actually require。 that you understand the meaning of the operations。 So conflict
    serializability is what gets used and Alvin is going to tell us how we get to
    use。 conflict serializability and that's because it can be enforced efficiently。
    Okay。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的语义对于可序列化性和冲突序列化性并不要求你理解操作的意义。所以冲突序列化性是我们实际使用的，而 Alvin 会告诉我们如何使用冲突序列化性，那是因为它可以高效地强制执行。好吧。
- en: Any questions on this？ Okay， look， Alvin。 Take it away。 Sure。 So actually before
    we do that and go into the next fragment of the next segment。 I think people were
    asking to。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么问题吗？好，看看，Alvin，接下来由你了。好的。所以在我们进入下一个片段之前，实际上在这之前，我觉得大家在问是不是。
- en: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_3.png)'
- en: possibility of taking a break。 So why we just want to take one minute break
    maybe a stretching break。 get something to drink and then we can come back to
    the next section。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以休息一下。所以我们想要休息一分钟，可能是拉伸一下，喝点东西，然后我们可以回到下一部分。
- en: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_5.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_5.png)'
- en: So we， Alvin is also soliciting center post to solicit tiktok videos so that
    we can play the break。 Yeah， so that was actually my whole point originally when
    I was sending that out。 So， I mean。 I don't actually have any announcements per
    se， so you guys can keep， you know。 stretching if you like besides like feeling
    the， midterm survey。 And then like， you know。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，嗯，Alvin 也在征求 TikTok 视频的投稿，这样我们就可以播放在休息时间。是的，这其实是我最初发那条消息时的意思。所以，嗯，我其实没有什么正式的公告，你们可以继续，像，你知道的，做一些拉伸，除非像填写期中调查问卷。然后像，你知道的。
- en: as a did you I was saying， right？ We're actually looking for videos。 So， like，
    you know。 before I checked before I went to like your lecture today， I was like。
    we haven't actually received a lot of these submissions。 So if you have not done
    so， like。 you feel free。 And you don't have to have make them yourself， right？
    You know。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的，对吧？我们实际上是在寻找视频。所以，你知道的，在我去你们今天的讲座之前，我就想。我们实际上并没有收到很多这样的提交。所以如果你还没有做的话，像。你可以随意。你不一定非得自己做，知道吧？你知道的。
- en: just send us something interesting。 If you like， if you don't mind sharing with
    the rest of your classmates。 you know， because if nobody submits anything， right？
    That definitely will win。 And they'll have nothing， right？ So， we'll be staring
    at a blank screen like you know， for like。 you know， two to three minutes， which
    will be awkward。 So， yeah， please， I mean。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只要给我们发一些有趣的东西。如果你愿意的话，当然，如果你不介意与其他同学分享的话。你知道的，如果没人提交任何内容，是吧？那肯定会赢的。而他们什么也没有，是吧？所以，我们会盯着一块空白的屏幕看，像你知道的那样，大概两到三分钟，这会很尴尬。所以，嗯，拜托，意思是。
- en: if you guys have anything， I mean， otherwise， like， you know， otherwise I can
    also play， you know。 my favorite， like， you know， cat videos， you know， unicorns
    or like， you know。 goldfish swimming in the ball。 I mean， like， you know， none
    of which might be interesting， right？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你们有任何东西，意思是，否则，像，你知道的，不然我也可以播放，像，我最喜欢的，像，猫咪视频，知道吧，独角兽，或者像，游泳的金鱼球。意思是，像，知道吧，这些可能都不有趣，是吧？
- en: Or we'll just end up staring at each other on the zoom window， which is weird。
    Right。 So， yeah。 I'm not going to tell you。 So， yeah， as I said， you don't want
    to know what my account is。 So don't worry about it。 If you want to share， I mean，
    go ahead， I mean， you know。 I welcome all of you to add me on Facebook or TikTok
    or you can find it。 I mean， you know。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们就会在Zoom窗口中互相盯着对方看，这很奇怪，对吧？所以，是的。我不会告诉你。所以，正如我所说，你不想知道我的账户是什么。别担心。如果你想分享，没关系，继续吧，我是说，你知道的。我欢迎你们都加我Facebook或TikTok，或者你可以找到它。我是说，你知道的。
- en: it's not a secret。 If you can， only if you know。 Go ahead。 No， you don't have
    to submit videos。 Come on， right？ I mean， like， you were just saying。 If you have
    anything that you want to share。 like， you know， otherwise next time I'll start
    playing the golfers swimming around and then。 you know， we'll， we'll have a very
    calm and peaceful break。 I can play someone doing yoga。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是秘密。如果你知道的话，没关系。继续吧。你不需要提交视频。来吧，对吧？我的意思是，你刚才说过，如果你有什么想分享的，像是，你知道，否则下次我就开始播放高尔夫球员在游泳的画面，然后，你知道，我们会有一个非常安静和平和的休息时间。我可以播放一些做瑜伽的人。
- en: I suppose。 Okay， Alan is going to put up something I don't want to click on
    it right now。 I don't know what it is。 I don't want to do the little transverse。
    No， I mean， I trust him。 He is one of our best teachers。 Yeah， anyway， so before
    we go on， right。 any like any questions about a DTS part of the lecture on transactions。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我想。好吧，艾伦将要展示一些我现在不想点击的东西。我不知道那是什么。我不想做那个小小的横向切换。不是，我的意思是，我信任他。他是我们最优秀的老师之一。是的，反正，在我们继续之前，有没有关于讲座中DTS部分的问题？
- en: So I'll go here in the next fragment， right， is to basically look at how to
    actually implement transactions and there will work。 I mean， otherwise known as
    project four， right。 So， as you can guess， I mean。 there are actually many different
    implementations available。 They tend to have like different performance characteristics。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以接下来我要讲的内容，就是如何实现事务及其工作原理。也就是我们所说的项目四。正如你们所猜测的那样，实际上有许多不同的实现可用。它们往往具有不同的性能特征。
- en: and they also target different types of workloads。 So for the purpose of our
    lecture， however。 we're going to focus on something called a lock based implementations。
    And before I go into this whole， like， you know， thing about what lock based implementations
    are about。 I'm just going to throw out the buzz words that you guys may hear if
    you go on to study different types of concurrency control mechanisms。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也面向不同类型的工作负载。然而，针对我们讲座的目的，我们将集中讨论一种叫做基于锁的实现。在我进入整个关于基于锁的实现的内容之前，我先抛出一些你们如果继续研究不同类型并发控制机制时可能会听到的流行术语。
- en: So for instance， you might hear people talking about something known as multiple
    versions concurrency control。 So the intuition there is to basically say that，
    okay。 we're just going to let everybody move forward as if they have a copy of
    their own database。 And then eventually， when they need to commit or when they
    need to abort。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你可能会听到有人谈论一种叫做多版本并发控制的方法。所以这里的直觉基本上是说，好的，我们就让每个人继续前进，好像他们都有自己的数据库副本一样。然后最终，当他们需要提交或需要中止时。
- en: then we'll check in terms of figuring out whether there's any conflict。 And
    you can already guess what conflict in that case mean， right。 There's like things
    about like。 you know， you write something that another person。 another transaction
    is also overriding at the same time so and so forth。 Yeah。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会检查是否存在冲突。你们大概已经猜到，在这种情况下冲突意味着什么了吧？就像是，你写了一些东西，另外一个人，另一个事务也在同时覆盖同样的内容，诸如此类。是的。
- en: so you can imagine basically doing that checking only when you try to commit
    a transaction。 So。 but otherwise you just let everybody move forward as if nothing。
    There's no check。 There's no locking for instance。 Some things that sometimes
    it can look up， for instance。 is something called optimistic concurrency control
    or OCC or time bank。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以想象基本上只有在你尝试提交事务时才进行检查。可是，除此之外，你就让每个人继续前进，好像什么都没发生。没有检查。没有锁定。例如，有时它会查找一些东西，比如叫做乐观并发控制（OCC）或时间银行的方法。
- en: time stamp based concurrency control as well。 So these are things that you can
    encounter if you go on to study different types of concurrency control mechanisms。
    But as I said， to keep things simple， we only go to focus on something known as
    lock based implementations。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间戳的并发控制也是如此。所以这些是你如果继续学习不同类型并发控制机制时可能会遇到的内容。但正如我所说，为了简化问题，我们只专注于基于锁的实现。
- en: So， yeah， so don't worry about it if you don't understand what I was just talking
    about。 So those were just for your interest。 So first， let's talk about like，
    you know。 what do I mean by lock， right。 So there are many notions of lock。 You
    know， so this is not 161。 right。 So we're not going to be talking about like，
    you know。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，嗯，如果你没明白我刚才说的内容，不用担心。那些只是为了引起你的兴趣。首先，我们来讨论一下，嗯，我所说的锁是什么意思。其实锁有很多种概念。你知道，这不是161课程。对吧。所以我们不会讨论像，嗯，类似的内容。
- en: things like security and there's no adversaries here， right。 So， you know。 don't
    don't worry about that。 If that's what you're thinking about， you're safe。 What
    we are talking about， however， is this notion of locks or exclusive。 We're just
    in my mind。 So like semaphores or like， you know， basically exclusive sections。
    Yeah。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比如安全性方面，这里没有对手存在，对吧。所以，嗯，别担心。如果你在担心这个问题，你是安全的。然而，我们所谈论的是锁的概念，或者是独占锁。就是我心中的那种。所以像信号量，或者说基本的独占区域。是的。
- en: exclusive segments of code that like your only one threat or one， like， you
    know， control one。 Yeah。 one threat of control can run at a time。 So this is something
    that you might encounter in 61 C。 Hopefully some， some， something that you might
    recall。 Basically， synchronization primitives， right。 So we basically put a lock
    around a piece of code that we want exclusive access to。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的独占段，只有一个线程，或者说一个控制流能在某一时刻执行。所以你可能会在61 C中遇到这些。希望这是你可能会记得的内容。基本上，这些都是同步原语。对吧。所以我们基本上会在我们希望独占访问的代码片段周围加锁。
- en: So those are the， those are the types of locks that we are talking about in
    this class。 So people are really familiar with this notion of locking or what
    we are talking about as synchronization primitives primitives in this class。 Hopefully
    that's going to recall like， you know， a pleasant memories right from 61 C。 And
    then immediately someone said I'm dead。 Okay， sorry。 Okay， right。 So。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些就是我们在本课程中讨论的锁的类型。大家都很熟悉锁这个概念，或者说我们在本课程中提到的同步原语。希望这能勾起你们一些愉快的记忆，回想起61 C课程的内容。然后马上就有人说，我死定了。好吧，对不起。好吧，继续。
- en: but then for the purpose of this class， right。 So you need to remember that
    just like in 61 C。 All these locking primitives actually is not free， right。 So
    we need to have like， you know。 run CPU， like， you know， they all cost you cycle。
    So these are not like， you know， free operations。 So just keep that in mind。 And
    in this class for a database class。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但就本课程而言，你需要记住，就像在61 C课程中一样，这些锁原语实际上并不是免费的。对吧。所以我们需要有，嗯，运行CPU，像这样，它们都会消耗你的一些周期。所以这些并不是像你想象的那样是免费的操作。所以请记住这一点。而在本课程中，对于数据库课程来说。
- en: we're just going to follow a very simple convention。 So this is all you need
    to know about locking。 for example。 So we assume that each data element has a
    lock， which is unique to that element。 Each transaction must first acquire that
    lock before being able to read or write to that particular element。 And then if
    a lock is already taken by another transaction， then like， you know， just have
    to wait。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循一个非常简单的约定。所以这就是你需要知道的关于锁的一切。例如。我们假设每个数据元素都有一个唯一的锁。每个事务必须首先获取该锁，才能读或写该特定元素。如果一个锁已经被其他事务占用，那么，嗯，你只能等待。
- en: And then after we're done， we always released the lock at some point in time。
    So that's the basic principle that will go by in this class。 And then you're here
    and we'll also discuss in this lecture different types of locking protocols or
    schemes。 Sometimes you hear， you hear people talk about that。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们完成操作后，我们总是在某个时刻释放锁。所以这是我们在本课程中遵循的基本原则。接下来，你们会在本讲座中看到不同类型的锁定协议或方案。有时候你会听到人们谈论这些。
- en: How they different is basically when to lock or unlock each of these data elements。
    What they're able to actually lock and what actually happened when someone is
    trying to wait for a lock。 So I've been trying to wait my hand in terms of like
    saying what is a data element in this case。 right。 So it turns out to be different
    across different vendors。 So for example。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的不同之处基本上是在什么时候锁定或解锁这些数据元素。它们能够实际锁定的内容以及当某个人在等待锁时发生了什么。我一直在努力解释在这种情况下数据元素是什么。所以，事实证明，它在不同的供应商之间有所不同。例如。
- en: you can consider the data element here is the entire database。 I mean。 you might
    think that is silly， right， because if you block the entire database， then sure，
    I mean。 you basically guarantee that nobody else can run any other transaction
    concurrently。 So that by definition guarantees serializability。 In fact， it's
    a serious schedule at that point。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以认为这里的数据元素是整个数据库。我的意思是，你可能会觉得这很傻，对吧？因为如果你锁定整个数据库，那么当然，你基本上就保证了没有其他事务能够并行运行。因此，从定义上讲，它保证了可串行化性。事实上，这时它变成了一个严肃的调度问题。
- en: right。 There's only one transaction that can go up that can go on at any single
    time。 And that transaction has to finish entirely before another transaction can
    go on。 So of course。 we preserve as it。 You might think this is a silly example
    that nobody's actually implement that。 Well， but believe it or not， SQL like has
    this notion of locking the entire database when you run transactions。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对的。在任何时刻，只能有一个事务正在进行。而这个事务必须完全结束，另一个事务才能开始。所以，当然，我们会像这样保持事务的完整性。你可能会觉得这个例子很傻，没人会真正实现这种方式。但信不信由你，像
    SQL 这样的系统在运行事务时有锁定整个数据库的概念。
- en: What does that mean？ That means if you care about concurrent transactions running
    for your app or your first startup。 for example， don't use SQL like because SQL
    like assumes that the entire database is locked every time when someone begins
    a transaction。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思呢？这意味着，如果你关心并发事务在你的应用程序或首次启动时的执行，举个例子，不要使用类似 SQL 的数据库，因为 SQL 假设每次当某个事务开始时，整个数据库都会被锁定。
- en: So， you know， good luck。 And then there are also other database implementations
    where they only lock individual records。 right。 So that's like way more reasonable，
    as you can imagine。 So all the commercial implementations does that。 We'll actually
    see the different trade-offs that we're talking about later on in terms of why
    one way and not the other。 And can we actually mix a match both of them， right，
    for example。 Okay。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，祝你好运。还有一些数据库实现，它们只锁定单独的记录。对吧？这就更合理了，正如你所想的那样。所有的商业实现都这么做。稍后我们将看到关于为何选择这种方式而非另一种方式的不同权衡。我们还可以探讨是否能将这两种方式结合使用，例如，好的。
- en: so for the purpose of this class， like， you know， as I said， right。 for each
    of these locks that we can acquire and release。 we're going to use this notation
    here for purposes。 So the underscore here， you know。 the subscript I basically
    refers to the transaction I， and then either L or you would。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在本课程中，正如我之前所说的，对于我们能够获取和释放的每一个锁，我们将使用这个符号表示。下划线部分，指的是事务 I，然后是 L 或者 U。
- en: So that's a face out in practice。 So first of all， here is a non-serializable
    schedule。 Why is this a non-serializable schedule？ So just to remind ourselves，
    right， so you know。 time goes downwards。 Okay， so here we have T one trying to
    read a you can think of a as either like a record。 Yeah， for a single tuple， for
    example， right， tries to read a and tries to write and then followed by some operations
    from T two and then followed by going back to T one。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，实际上就是这样。首先，这是一个非串行化的调度。为什么这是一个非串行化的调度呢？提醒一下自己，时间是向下流动的。好了，这里我们有 T1 尝试读取 A，你可以把
    A 想象成一个记录。比如说，一个单一的元组，然后它尝试读取 A 并进行写入，接着是 T2 的一些操作，最后再回到 T1。
- en: Right， so in this case， right， so we are writing to a and then， you know。 T
    two is basically going to read the value that was written by T one。 And then T
    two is going to write to be which is subsequently being read by T one， right。
    And in this case， I challenge you a way to swap the operation such that it becomes
    a serial schedule。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对的，在这种情况下，我们正在写入 A，然后 T2 基本上会读取由 T1 写入的值。接着，T2 会写入 B，而 B 随后会被 T1 读取。对此，我挑战你一种方法，可以交换操作顺序，使其变成串行调度。
- en: There isn't a way， right， because we're kind of in a in a in a in a cyclic in
    a cycle， right。 because I knew T one， T two depends on T one's value of A and
    T one depends on T two for the value of B。 So we're kind of stuck。 So this is
    a non serializable schedule。 Now。 if I want to make this a serializable serializable
    schedule， one way of doing it， is I said， right。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有办法，对吧，因为我们陷入了一个循环中，对吧。因为 T1 和 T2 依赖于 T1 对 A 的值，T1 又依赖于 T2 对 B 的值。所以我们有点卡住了。所以这是一个不可串行化的调度。现在，如果我想把这个调度改为可串行化的调度，一种做法是，我之前说过的，对吧。
- en: it's by introducing locks。 So in this case， I'm going to grab a lock。 I'm going
    to grab the lock on a before reading it。 And then I'm going to release it after
    I have read it。 and then subsequently I'm going to grab the lock on B right。 like
    your eye in this case meeting when you're T one by the first transaction。 So same
    thing。 same thing for T two。 So teachers go into first grab the lock on A before
    reading it。 so on and so forth。 And then when as it tries to grab the lock on
    B， it's going to be blocked。 right， because of the fact that T one currently holds
    the lock on B。 So T two has to wait。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入锁。所以在这种情况下，我会先获取锁。在读取 A 之前，我会先获取 A 的锁。然后在我读取之后释放它。接着，我会获取 B 的锁，对吧。就像你的案例一样，当你是
    T1 时，先进行第一个事务。所以同样的道理。同样适用于 T2。所以 T2 会首先获取 A 的锁，然后再读取它，以此类推。然后，当它试图获取 B 的锁时，它会被阻塞。对吧，因为
    T1 当前持有 B 的锁。所以 T2 必须等待。
- en: So since T two cannot make any progress， we can actually switch back to T one。
    So T one in this case is going to finish is operation on B， and then unlock it。
    After which T two can then grant， can then like you'll grab the lock and then
    carry on with this operation with B。 Kyle， do you have a question？ Yes， why does
    T one lock be。 Well。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 T2 无法继续执行，我们实际上可以切换回 T1。所以在这种情况下，T1 会完成它对 B 的操作，然后解锁。之后 T2 就可以获取锁并继续它对 B
    的操作。Kyle，你有问题吗？是的，为什么 T1 会锁定 B？嗯。
- en: because T one knows that it's going to write to be out later on， right。 So one
    way I can enforce this schedule to be serializable， I mean。 knowing that like
    this is what T one and T two is going to do is to basically insert these lock
    statements。 So in fact， the purpose of this life to basically show you that using
    locks， right。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 T1 知道它稍后会对 B 进行写操作，对吧。所以我可以强制这个调度变得可串行化，意思是知道 T1 和 T2 将要做的事，基本上就是插入这些锁语句。因此，实际上，这个过程的目的是向你展示，使用锁的方式，对吧。
- en: so we have now ensured a conflict serializable schedule。 I mean， you can do
    this afterwards， right。 because with this particular schedule， you can now do
    the swapping that I did。 was telling you guys earlier to make that to make this
    schedule to be a conflict serializable one。 I see。 Does that make sense？ Yeah，
    thank you。 Okay， great。 Any other questions？ So， yeah。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在已经确保了一个冲突可串行化的调度。我是说，你可以在之后做这件事，对吧。因为有了这个特定的调度，你现在可以进行我之前告诉你们的交换操作，使这个调度变成一个冲突可串行化的调度。我明白了。这样说有道理吗？是的，谢谢。好的，太好了。还有其他问题吗？所以，嗯。
- en: I have a question。 So T two tries to acquire a lock for B。 but it's blocked
    and then T one releases the lock。 Does it automatically receive the lock as soon
    as it's unlocked or does it have to recall the L to be。 Where's this granted？
    Do you have to read。 No， so， right， great， great。 So you can think about。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个问题。T2 试图获取 B 的锁，但被阻塞了，然后 T1 释放了锁。它会在解锁后自动获取锁吗？还是必须重新请求锁才能获得它？这会被授予吗？你需要读取吗？不，没错，没错。所以你可以这样理解。
- en: Yeah， no， it doesn't。 So basically you can think about T two， like what is what
    is happening？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，不，没错。所以基本上你可以把 T2 想象成，发生了什么呢？
- en: Why is it locked？ Right。 So you can think of it as basically just spinning around。
    So you can think of it as a call， maybe from 61 C， right。 So one way you can implement
    this mock is to basically have a while loop that keeps just doing nothing and
    checking。 but it's not as available before you can actually break out of it。 Okay，
    thank you。 And that case。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它被锁定了？对吧。所以你可以把它看作是基本上在不断旋转。所以你可以把它看作是一个来自 61C 的调用，对吧。你可以实现这个锁的一种方式是基本上有一个
    while 循环，不断地什么都不做，仅仅检查。然而，在你能够实际跳出它之前，它并不那么可用。好的，谢谢。那么在这种情况下呢？
- en: that in granted basically means like， you know， we're allowed to jump out of
    the loop because like。 you know， we're finally received a lot。 Okay。 Yeah。 So，
    so far， so good， right？ Yeah。 quick question about like when things were chosen
    to be locked and like how the schedules can split because like in this current
    setup。 like it does work with where， you know， L B is locked by transaction one。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着，我们可以跳出循环，因为我们终于获得了锁。好吧。是的，到目前为止，一切还好，对吧？嗯，关于选择什么时候锁定资源以及如何拆分调度有个问题，因为在当前的设置中，确实有效，像是L
    B被事务1锁定。
- en: But it almost seems like if there were， you know， like a T three that did stuff
    with the first。 it could start using B in the middle of like when T one is using
    a， I guess， like。 like it just seems kind of arbitrary where you're choosing to
    start the lock。 Yeah， exactly。 So like in this case， I actually decided that like
    you'll be able to grab the lock on B first。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但几乎看起来，如果有一个像T3那样的事务，它首先执行一些操作，可能在T1操作A的时候，它就开始使用B。我猜，像是。看起来你选择开始加锁的时机似乎有些随意。是的，完全正确。所以在这种情况下，我实际上决定让你首先抓取B的锁。
- en: right。 And in fact， that is an extremely good lead in to the next slide， right。
    So there we are。 there we have it。 So in this case， I mean， the， in terms of the
    lock and the unlocks， I mean。 I haven't changed anything。 So we're still grabbing
    the lock， for example， right。 So in this case。 notice that I'm grabbing the lock
    on B right after I'm locked A， right。 So in here。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对，实际上，这为下一张幻灯片做了一个非常好的引入，对吧？所以我们到了这儿。我们已经有了它。所以在这种情况下，我的意思是，关于锁和解锁的部分，我并没有改变任何内容。所以我们依然在抓取锁，例如，对吧？所以在这种情况下，注意到我在锁定A之后，紧接着抓取了B的锁，对吧？所以在这里。
- en: if you look at like， you know， the schedule for T one is exactly the same thing。
    Okay， I'm。 I'm grabbing the trying to grab the lock on B after I have unlocked
    A， right。 The only difference in this case is I am now allowing T two to first
    grab the lock on B other than T one。 Right。 So just like in 61 C right so we have
    no way of telling which transaction is going to grab the lock first。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下，像T1的调度是完全一样的。好吧，我在尝试在解锁A之后抓取B的锁，对吧？唯一的不同是，我现在允许T2先去抓取B的锁，而不是T1。对吧？就像在61C中一样，我们无法判断哪个事务会先抓到锁。
- en: And then just both of them are trying to grab it at the same time， then it's
    somewhat average。 which one is going to win。 So in the， on the previous slide，
    like， you know， okay。 on the previous slide， I said that， okay， fine。 So let T
    one win first and then let's see what happens。 And it turns out that like， you
    know， we now have a conference， theizable schedule。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果它们都在同时尝试抓取锁，那么就有些难以预测，哪个会先赢。所以下一张幻灯片中，我说，好的，让T1先赢，然后看看会发生什么。结果发现，我们现在有了一个可串行化的调度。
- en: The question then is if I let you to win， you know， the lock first on B is the
    same thing。 also going to happen。 That's actually a question。 Maybe a rhetorical。
    No， right。 because now we're back to step one， right， in this case， you know，
    we now。 once again have the dependency。 So T two is going to read the value that
    like you know that T one just wrote for an A。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是，如果我让你先拿到锁，你知道，B上的锁会发生什么呢？也是同样的事情。其实这是一个问题。可能是修辞性的。不是的，对吧？因为现在我们回到了第一步，在这种情况下，你知道，我们现在。再次有了依赖关系。所以T2将读取T1刚刚为A写入的值。
- en: And then it's going to write its own version of B that is going to be read by
    T one later on。 So once again， we're stuck with the cycle that we had from the
    beginning。 So basically it seems that like you're using locks that not enforce
    conflict serializability， right。 And of course， at this point， I knew the test
    those out。 So what now。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将写入自己版本的B，之后T1会读取它。所以我们再次陷入了最初的循环中。所以基本上看起来，你使用的锁并没有强制执行冲突可串行化的规则，对吧？当然，在这一点上，我知道该如何测试了。那么现在该怎么办呢？
- en: so basically that means using just locks themselves right it's not good enough。
    And exactly as what the wish I was talking about right so let's try to impose
    the first locking scheme or。 or protocol。 In this case， it's called the toothpaste
    locking scheme or the protocol otherwise known as two P L。 It's basically says
    that every transaction has to grab all the locking requests before actually trying
    to unlock anything。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着仅仅使用锁本身并不够。正如我之前所说的那样，我们来试着强制实施第一种锁定方案或协议。在这种情况下，它被称为牙膏锁定方案，或者称为两阶段锁定（2PL）协议。它基本上要求每个事务在试图解锁任何东西之前，必须抓取所有的锁定请求。
- en: Again， we're still using locks that's just like before right the only thing
    that we are playing around with is when to actually try to apply the locks and
    when to actually release it so that's why in the first line in this lecture I
    was saying like you know all these different locking protocols。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们仍然使用锁，就像之前一样，唯一不同的是，我们在玩弄的是什么时候应用锁，什么时候释放锁。这就是为什么在本讲座的第一行我会说，所有这些不同的锁定协议。
- en: slash teams， they only think that one of the things that they differ is just
    what locks to grab and when。 Right， and likewise with the releases of the lock。
    So let's see this in action。 So now I am enforcing both these transactions must
    have grabbed the locks first before they can release anything。 So notice in this
    case now I am grabbing both the locks on a and B。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 团队们，他们唯一不同的地方就是抓取哪些锁，以及抓取的时机。对吧，同样，释放锁的时机也如此。让我们看看这个操作。现在我强制要求这两个事务必须先获取锁，才能释放任何东西。所以请注意，在这种情况下，我现在已经抓取了A和B的两个锁。
- en: Before I can actually release anything later on。 Right。 So likewise with T two
    right so T two in this case I'm grabbing all these locks before I'm releasing
    them。 Later on。 Okay， so I'm following the discipline or the I'm following the
    program here right。 And now you can see that this schedule is now conflict serializable
    it's basically boils back down into the good case that we had earlier right。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我实际上释放任何东西之前。对。所以同样，对于T2来说，T2在这种情况下是在释放任何东西之前先获取所有的锁。好的，按部就班地进行，或者说按照程序执行。现在你可以看到，这个调度现在是冲突可串行化的，基本上回归到了我们之前提到的良好情况。
- en: And in this case I would claim that it doesn't matter like you know how a great
    ties when both transactions try to grab the same lock。 Right， look for example。
    T one in this case is good。 it's going to grab both locks as the first two statements。
    So it's only going to be able to proceed with the rest of the operations here
    with a if it actually received the lock for both a and B。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我认为无论你知道两个事务尝试获取相同的锁时，如何进行调整并不重要。对吧，举个例子来看。T1在这种情况下是好的。它将首先获取两个锁，作为前两个语句。因此，只有在它确实获得了A和B两个锁后，它才能继续执行接下来的操作。
- en: Right。 So in this case I will claim that there's no way that you to get into
    leave here before。 you know， within this right to actually make this schedule
    becomes non conflict serializable。 So I'm going to prove to you that like you're
    using this two pm mechanism is going to ensure conflict serializability always。
    How to we prove this， we're going to prove this by contradiction。 So let's assume
    that is does not。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以在这种情况下，我认为不可能在此之前让你进入并离开。你知道的，要使得这个调度成为无冲突可串行化的。因此，我将证明使用这种两阶段锁定机制将始终确保冲突可串行化。我们如何证明这一点呢？我们将通过反证法来证明。所以假设它没有实现。
- en: Okay， and it's just as you remember from a this year's lecture。 That basically
    means that we have a cycle in the dependence graph。 So what we call right this
    dependence graph there's an edge between two two transactions if there's a dependency
    in terms of this。 you know， read it right dependency or write right dependency
    between two transactions right。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，正如你从今年的讲座中记得的那样。这基本上意味着我们在依赖图中有一个循环。所以我们所说的依赖图是这样的：如果两个事务之间有依赖关系，依赖关系上会有一条边。你知道的，可能是读取-写入依赖或写入-写入依赖。
- en: So here's the cycle。 So， you know， you see the cycle here on the on the screen。
    And it。 and it for sure does not ensure conflict serializability。 Right。 So let's
    see how this is this cannot exist right because we're trying to prove this by
    contradiction。 So I'm going to prove to you that is that is not going to happen
    by showing you that there's a cycle there's there's a cycle in time。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个循环。你看，在屏幕上看到了这个循环。而且，它肯定不能确保冲突可串行化。对吧？我们来看看为什么这个情况不可能存在，我们试图通过矛盾证明这一点。所以我将通过向你展示时间中存在一个循环来证明这一点。
- en: If we follow this dependence graph。 So let's go through this step by step。 First
    one。 I'm going to claim that。 Transaction one is going to unlock a before transaction
    to is going to be able to grab the lock on a。 Why？ Because I have， you know， transaction
    one has to unlock it right before， you know。 transactions to any other transactions
    able to grab the lock on the same data elements。 Right。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跟随这个依赖图。让我们一步一步地进行分析。首先，我要声明，事务1将在事务2能够抓取A上的锁之前释放A上的锁。为什么？因为事务1必须在事务2或其他事务能够抓取该数据元素上的锁之前释放它。对吧？
- en: So that means in terms of time。 The unlock event right on a has to happen before
    the locking event on a for transaction to。 Agree。 Okay。 So that's fine。 And notice
    that why I'm picking a right because we have this dependence at here right so
    this dependence at basically means that there's a dependence between one and two。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从时间上来说，A上的解锁事件必须发生在事务2锁定A之前。明白了吗？好的，没问题。请注意，我选择A是因为我们在这里有这个依赖关系，这个依赖关系基本上意味着事务1和事务2之间有依赖。
- en: So in this case， I'm basically saying that there's a dependency on a。 So that
    means like you're out transaction to is not able to grab the lock on a before
    transaction one able to release it。 So let's follow that right。 So now I'm saying
    that for transaction to it has to grab the lock on a before is able to unlock
    is。 Is lock on B or release the lock on B。 Why is that the case？ I'll give you
    a hint here。 Anyone。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下，我基本上是在说A上存在一个依赖关系。这意味着事务2不能在事务1释放A上的锁之前抓取A上的锁。所以让我们继续跟踪这个过程。所以现在我说事务2必须在能够释放B上的锁之前抓取A上的锁。为什么会是这种情况呢？我给你个提示，大家可以想想。
- en: You got to ensure all locks come before your own locks。 Yeah。 So by 2PL right
    we have to wait by 2PL we cannot release any locks。 Before we have grabbed locks
    on everything right。 So a and be a different data elements that's fine。 But then
    in this case since like you know the lockings。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保所有的锁都在你自己锁之前释放。是的。所以根据2PL（两阶段锁协议），我们必须等待，按照2PL的规则，我们不能释放任何锁，直到我们已经抓取了所有锁。A和B是不同的数据元素，没问题。但在这种情况下，由于锁的操作...
- en: The locks have to proceed right applying of the locks have to proceed all the
    releases。 So in this case that's the only thing that I can do from one transaction
    right or single transaction for a view。 So therefore in time right so we have
    this relationship here。 So I can now go on and look at this edge here right。 So
    what is this edge sets。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 锁必须按顺序进行操作，锁的释放也必须按顺序进行。所以在这种情况下，这是我能从一个事务或视图中做的唯一事情。因此，随着时间的推移，我们在这里建立了这种关系。所以我现在可以继续查看这里的边缘。那么，这些边缘集是什么呢？
- en: What is this edge saying right you know same thing。 It's basically going to
    say that transaction to cannot release the lock on B。 It has to release the lock
    on B before transaction to be able to grab the lock on B。 For the same reason
    right I think we have to explain that before。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边缘在说什么呢？你知道，跟之前一样。它基本上会说事务2不能释放B上的锁。事务2必须在能够抓取B上的锁之前，先释放B上的锁。出于同样的原因，我认为我们之前已经解释过这个问题。
- en: So you can go on with the rest of the reasoning and believe it or not you basically
    ended up in a cycle。 So it ended up seeing that like you know transaction one
    has to unlock。 A before actually we are before actually like you know before actually
    releases the lock on A。 So which is a cycle in time。 So that basically means this
    is a contradiction because the same event cannot happen before itself。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以继续推理，不管你信不信，你最终会进入一个循环。结果发现，事务1必须在实际释放A上的锁之前解锁A。这就意味着时间上存在一个循环。所以这基本上是一个矛盾，因为同一个事件不能先于它自己发生。
- en: Pretty cool right。 So now we have proved this by contradiction so that that
    basically means that using 2PL can indeed ensures conflict serializability。 Questions
    so far。 Where is L1 a so I'm not drawing out the schedules here right for the
    individual or I'm not drawing out the individual operations inside the transaction
    here。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧。那么现在我们已经通过反证法证明了这一点，这基本上意味着使用2PL确实可以确保冲突可串行化。到目前为止有什么问题吗？L1在哪里，我并没有在这里画出调度图，也没有画出事务内部的各个操作。
- en: But you can imagine right since we have an edge between transaction one and
    transaction two on a in the dependence graph right。 So if you recall a DTS lecture
    that basically means T1 must be grabbing the lock on a at some point during its
    execution。 Oh。 Okay so we've done right obviously not right means we have to still
    have an hour to go。 So now we have another problem to deal with and this is a
    no problem known as a non recoverable schedule。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以想象，对吧，因为我们在依赖图中有一个从事务一到事务二的边。所以如果你回想一下DTS的讲座，这基本上意味着T1必须在执行过程中某个时刻获得对A的锁。哦，好吧，所以我们已经做完了，对吧，显然还没有完成，这意味着我们还得继续。现在我们有另一个问题需要解决，这个问题被称为不可恢复调度。
- en: What do I mean by that。 Well， so everything before like you know this fragment
    here。 Sorry。 Everything。 Before this line here is exactly the same as what we
    have from before。 The only thing the only difference between this schedule and
    the one from before is whether one decides to commit or roll back otherwise known
    as a board。 So this problem by the way is also known as cascading a boards。 Why
    is that a problem。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我什么意思呢？好吧，所有在这里这段代码之前的内容，抱歉，所有在这行之前的内容和之前的完全相同。唯一的区别是这个调度和之前的调度之间的差异是否有事务决定提交或者回滚，也就是所谓的“中止”。顺便说一下，这个问题也被称为级联中止。为什么这是个问题？
- en: Well turns out that transaction one decided to abort at the end。 So meaning
    that we somehow need to restore everything that transaction one did right in terms
    of writing to different elements。 So in this case notice that like you know transaction
    one tries basically wrote to both a and B。 So we somehow needs to undo its effect
    right on both a and B。 However。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明事务一最终决定中止。所以这意味着我们需要恢复事务一所做的一切，尤其是写入到不同元素的操作。所以在这种情况下，注意到事务一基本上写入了A和B两个元素。所以我们需要撤销它对A和B的影响。然而。
- en: like your transaction to actually decide to commit。 And the worst case in this
    the worst thing in this in this case is actually that like you know it unfortunately
    read the value of B that transaction one wrote to it wrote earlier。 So that sucks
    right because now like your transaction to actually read a dirty elements that
    is supposed to be wrote back。 And now it also decides to commit right。 So that's
    not good。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说你的事务二实际上决定提交。而在这种情况下，最糟糕的情况是，它不幸读取了事务一之前写入的B值。那很糟糕，对吧，因为现在事务二读取了一个脏数据，而这个数据本该被回滚。然后它也决定提交了，对吧。所以这不好。
- en: And now transaction two can no longer undo right we can no longer undo transaction
    one because you know the value that was written by transaction one has already
    been read by transaction two right so that's not good。 And again right the cash
    shows up。 Any questions about this so far。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事务二再也无法撤销了，因为事务一写入的值已经被事务二读取了，所以这不好。而且问题又出现了。到目前为止有问题吗？
- en: So this is called cascading a board right because we're basically trying to
    figure out how to roll back both T one and T two right so in this case we need
    to roll back both of the transactions because that's the only logical way that
    we can that we can keep the database state to be consistent。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为级联中止，因为我们基本上试图弄清楚如何同时回滚事务一和事务二。在这种情况下，我们需要回滚这两个事务，因为这是保持数据库状态一致性的唯一合理方式。
- en: Okay， because T one decides to roll back itself so therefore。 and T two has
    red T one's value so the only way that we can do this is to forbid T two from
    committing。 So one way to solve the problem is now we need to refine our two PL
    rule。 So not only do we have to do the same thing as before right meaning that
    we can only we have to acquire all the locks before we can release anything。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，因为T1决定回滚自己，所以T2已经读取了T1的值，因此我们唯一能做的事情就是禁止T2提交。所以解决这个问题的一种方法是，现在我们需要完善我们的2PL规则。所以不仅要像之前一样，只能在获得所有锁之后才能释放任何锁。
- en: We now also have to make sure that all the unlocks happen after we have decided
    to either commit or abort。 So we can't release anything before we decide to commit
    or board。 otherwise everything else is just the same as before。 And then I claim
    that was straight to be out we now get schedules that are both conflict serializable
    and also recoverable。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还必须确保所有的解锁操作发生在我们决定提交或中止之后。所以在我们决定提交或中止之前不能释放任何资源。否则，其他的一切都和之前一样。然后我声称，通过严格的调度，我们现在得到的调度既是冲突可串行化的，又是可恢复的。
- en: You can see this in action right。 So now you can see I am not releasing any
    of the locks until I have decided to roll back or commit。 So therefore now in
    this case， since we have already processed T one's abort right by the time we
    actually grant this lock to grant the lock on eight for to T two。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个操作了，对吧？所以现在你可以看到，在我决定回滚或提交之前，我不会释放任何锁。因此，现在在这种情况下，由于我们已经处理了 T1 的中止，当我们实际授予
    T2 对 a 的锁时，T1 的回滚已经完成。
- en: So therefore we are safe。 So T two is now not going to read the dirty value
    that T one has earlier。 I'll work into it。 Does that make sense。 So does this
    just ensure that all of one transaction occurs before the next。 When you buy off
    transaction like like so， since transaction one holds the locks for a and be all
    of transaction one finishes before transaction to。 Yeah。 Okay， that's a great
    question。 Yeah。 And also that's also what a concept on is asking。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这样我们就安全了。因此，T2 不会读取 T1 之前的脏数据。我会这么做。明白了吗？那么这是否确保了一个事务的所有操作在下一个事务之前完成？当你锁定一个事务时，就像这样，因为事务
    1 持有 a 和 b 的锁，所以事务 1 的所有操作都会在事务 2 之前完成。是的。好的，这是个好问题。是的。也是“概念 1”想问的问题。
- en: Exactly。 So now we're gradually reducing right the amount of concurrency that
    we can do because now it seems like this is actually just like a serial schedule
    at this point right。 Well things does not have to look this bad right so let's
    say if you have another transaction that actually touches neither of a and be
    I mean that one can just proceed as as as all as concurrent as anybody else。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正是如此。所以现在我们正在逐渐减少我们可以并发执行的数量，因为现在看来，这实际上就像是一个串行调度了。好吧，事情不必看起来这么糟糕。假设如果你有另一个事务，它既不触及
    a 也不触及 b，那它可以像其他任何并发事务一样继续执行。
- en: So we're not entirely killing all the all concurrency but we are kind of taking
    a step back right because of the fact that we want things to be recoverable。 Okay。
    Okay， so actually most lock based database systems just use strict to be out because
    they want to ensure things are done recoverable recoverable and also conflict
    serializable。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们并没有完全消除所有并发性，但由于我们希望事务是可恢复的，我们在某种程度上是退后了一步。好的。好的，实际上，大多数基于锁的数据库系统只使用严格的调度，因为它们希望确保事务是可恢复的，同时也是冲突可串行化的。
- en: And actually it's pretty easy to implement in the sense that we just insert
    all the locks statements before trying to read a single elements。 for example。
    And then we just want to make we just basically want to make sure that we don't
    release any of the locks before a transaction decides to commit or board。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 而且实际上它相当容易实现，方法是我们只需在尝试读取任何单一元素之前插入所有的锁定语句。例如，然后我们只需要确保在事务决定提交或中止之前，我们不会释放任何锁。
- en: And then doing that we're unsure both of these problems are solved。 And are
    we done yet right。 Of course the answers no right I mean we still have 25 minutes
    to go so there must be something else。 So yes， of course there's something else
    right。 I don't know if anyone told you I mean like transaction or concurrency
    control is always a story that is like you know written using blood and tears
    right or。 I don't know you know blood and sweat or any one of these bad things。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过这样做，我们可以确认这两个问题已经解决了。我们还完成了吗？当然，答案是否定的。我是说，我们还有 25 分钟，所以肯定还有其他问题。那么，是的，当然还有其他问题。我不知道是否有人告诉过你，我是说，事务或者并发控制总是一个需要用血与泪书写的故事，或者我不知道，可能是血与汗，或者其他任何这些糟糕的事。
- en: So it's a is a pretty pessimistic story unfortunately。 Oh， there we go。 What's
    the next problem。 So take a look at the schedule here so we have one transaction
    trying to read a and then write be right and then we have a second transaction
    here trying to read be a right a。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不幸的是，这个故事是相当悲观的。哦，好吧，接下来是什么问题？看一下这个调度表，我们有一个事务试图读取 a 然后写入 b，然后我们有第二个事务试图读取
    b 然后写入 a。
- en: Okay， so we're playing straight to PL so T one is going to grab the lock on
    a and it's going to wait for the lock on be。 for example， because it's trying
    to grab the lock on be。 And then T to the first try to grab a lock on be， and
    then now it has to wait because T one is holding on to the lock today。 Okay， this
    is known as a deadlock right。 So 61 see you guys probably already remember that
    yeah we need bread fun coloring and of course now the cat again shows up。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们直接讲到死锁问题，T1 会先获取 a 的锁，然后它会等待获取 b 的锁。例如，它正在尝试获取 b 的锁。然后 T2 会首先尝试获取 b 的锁，然后它现在必须等待，因为
    T1 持有着 a 的锁。好的，这就是所谓的死锁，对吧？所以你们可能都记得在 61C 课程中我们讨论过这个问题，嗯，我们需要避免死锁，当然，现在猫又出现了。
- en: You see a lot of cat in this lecture as you can see as I told you this is a
    very pessimistic picture。 Okay。 Now you recall if you're taking like 162 for example
    this is not a really new problem I mean even in operating systems the same thing
    happens to write in general。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你们在这节课上会看到很多猫，正如我告诉你们的，这是一个非常悲观的画面。好的，现在回想一下，如果你们正在上 162 这门课的话，这其实并不是一个新问题，甚至在操作系统中也会遇到同样的问题，基本上就是一样的。
- en: or concurrency control mechanisms。 So the standard technique in operating system
    right for example you take 162 is to do an ordering。 an imposed an ordering that
    says for example the screen always grab the lock first。 followed by like you know
    some other devices， for example。 the why is this a problem for transactions or
    databases in general。 Well。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是并发控制机制。操作系统中的标准技术，例如在 162 课程中，是进行排序。强制执行一个排序，规定比如屏幕总是先获取锁，其次是其他设备。例如，为什么这对事务或数据库来说是一个问题呢？嗯，
- en: what kind of order do we want to impose。 I mean we have two pools that we have
    tables right so it's not like they are unique devices so like you know how do
    we impose an order。 So I hope you guys remember right maybe from 61 see how like
    you're imposing an order with softness problem。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要强制什么样的顺序呢？我的意思是，我们有两个池，两个表，这并不是像唯一的设备一样存在，那么我们该如何强制顺序呢？希望你们还记得，比如在 61C 中，你们是如何在软性问题中强制顺序的。
- en: because if we have an order， then that means we always have a way to break ties
    right in case like you know to try to to resources try to get on to the same luck。
    So we somehow can impose such an order for transactions that we're good。 but it's
    hard to imagine what kind of order we want to impose right because people keep
    answering new tools and we cannot foresee what kind of tables people are trying
    to create。 So there are a couple of things that we can do right in terms of dealing
    with that box。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果我们有顺序，那就意味着我们总是能在发生冲突时解决优先级问题，对吧？例如，如果两个事务都尝试同时获取同一个锁，我们就可以通过顺序来打破平局。所以，如果我们能够强制为事务设定顺序，那就没有问题了。但很难想象我们要强制执行什么样的顺序，因为人们不断提出新的工具，而我们无法预见人们会尝试创建什么样的表。所以，在处理死锁时，我们可以采取几种方法。
- en: The first one is to just avoid them。 If we can avoid that locks to all together
    then you know we won't have this problem from the beginning。 If we cannot avoid
    them then the next order of business that we want to talk about is how to detect
    them。 And subsequently how to deal with them once they are detected right。 So
    that's why I'm going to talk about next。 So avoidance。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法就是避免死锁。如果我们能完全避免死锁，那我们就不会从一开始就遇到这个问题。如果我们不能避免，那么接下来我们要讨论的就是如何检测死锁。然后，如何在检测到死锁后进行处理，对吧？所以接下来我将讨论的就是避免死锁的问题。
- en: One way we can avoid like having that locks all together is to arbitrarily impose
    an order just like in the device case for for the operating system。 So I can impose
    an order based on something called an age of a transaction。 And I'm obviously
    finding what age in this case mean right basically means like you know how much
    time has the transaction spent in execution。 So take the time now and I'm going
    to subtract the time that it like you know the transaction first try to execute。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以避免锁的方式之一是完全避免锁的使用，就像在操作系统中的设备案例一样。所以我可以基于事务的“年龄”强制规定一个顺序。显然，我在这里说的“年龄”是什么意思，基本上就是说你知道事务执行了多长时间。所以现在拿时间，然后减去事务第一次尝试执行的时间。
- en: And then I'm just going to call that the age of the transaction。 So one way
    one policy or one scheme known as the weight by policy is to basically say that
    if I has a higher priority priority here based on age right。 Then like you know
    it's going to wait for the other transaction to finish。 Then it's just going to
    abort in a case that like you know I is actually having a lower priority than
    T then J。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我就把那个称作事务的“年龄”。一种策略，或称为“等待策略”，基本上就是说，如果我有更高的优先级，这里是基于年龄的对吧。那么它就会等另一个事务完成。然后如果我实际上拥有的优先级比T或者J低，它就会中止。
- en: Another policy known as one weight is to basically do it somewhat the other
    way around。 So if I has to hire priority then like you know the other transaction
    J is going to abort itself。 And then let I proceed。 Otherwise it's just going
    to wait。 So you might this might be a little bit abstract for you so you know
    let's use an example to illustrate this right and then I'm going to do something
    that is perhaps a little bit stinky。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略叫做“单一等待”，基本上是按另一种方式来做。如果我有更高的优先级，那么另一个事务J会自我中止，然后让I继续。否则，它就会等一下。所以你可能觉得这有点抽象，那么我们就用一个例子来说明一下，然后我会做一些可能有点臭的事情。
- en: We're used to the example of a parties。 So imagine we have two people here right
    so age right let's use human beings so so you have a senior person waiting for。
    Waiting to use the bathroom and we have like you know a younger person currently
    in the bathroom right。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯了使用派对的例子。假设我们有两个人对吧，年龄，让我们用人类来举例。你有一个年长者在等着使用卫生间，而另外一个年轻人正好在卫生间里。
- en: So now the first policy says right if the senior person is trying to use the
    bathroom while somebody else is actually in there right so we can either wait
    for it。 Right that's what that's what the first policy there says right wait wait
    die right。 So if the if I has a higher priority it's going to wait。 So that basically
    means a senior person is going to wait for the younger person。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在第一个策略说，如果年长者试图在其他人已经在卫生间时使用卫生间，对吧，那么我们可以等一下。对，这就是第一个策略的意思，等一下，死掉对吧。所以如果我有更高的优先级，它就会等一下。基本上这意味着年长者会等年轻者。
- en: And if not it's just going to kill itself right so that's the die part so that's
    what you see here like you're in the rest circle。 And then the other policy right
    so the one weight is basically going to say if I'm the senior person。 I'm going
    to basically kill off the younger one right and currently in the bathroom and
    then like you know so that I can take over。 That's the one part。 And then if it
    is the other way around then I'm just going to wait。 Okay。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有的话，它就会自杀，对吧，所以这就是“死”的部分，你看这里像是在等待环路中。然后是另外一种策略，对吧，所以一个权重基本上会说，如果我是年长者，我会基本上杀死年轻者，对吧，现在在卫生间里，然后你知道，我就可以接管。这就是其中一部分。如果是反过来的话，那我就等一下，好吗？
- en: So you might ask the question and you're why is this avoiding that box right
    why is this preventing that box from happening。 So to understand why like you
    asked the question what is it what what do the previous images have in common。
    So I'll put back on the on this side right on this slide right。 So notice that
    in the front on the first image here right。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能会问，为什么这是避免那个死锁的？为什么这是防止死锁发生？要理解为什么，你可以问一个问题，之前的图像有什么共同点。我会把它放回到这个侧面，对，这一页。所以注意到，在第一张图片的前面，对吧。
- en: So notice that the senior or the older older transaction is going to wait for
    the younger one。 but then not the other way around。 So that's how we avoid this
    like your situation right or otherwise known as you know the old person always
    wins okay。 So the young transaction is going to kill off itself as opposed to
    like you're waiting on the old transaction。 So we won't have a cycle waiting here
    because it's always only the case that the senior or the older transactions is
    going to wait。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所以注意到年长的事务会等年轻的事务，但反过来就不是。这样我们就避免了这种情况，或者说就是所谓的“年长者总是胜利”。所以年轻的事务会自杀，而不是像等待年长事务那样。所以我们这里不会发生死锁，因为永远只有年长的事务会等。
- en: not the other way around。 So we break ties right so therefore like you know
    it's not going to be a cycle。 So note that lock。 And then we follow to second
    discipline。 It's the other way around right it's always the younger transaction
    that is going to wait。 The senior transaction or the older transaction is not
    going to wait because it's going to immediately kill off the younger transaction
    by winning it。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不是相反的情况。所以我们打破了平局。因此，你知道的，这样就不会形成循环。请注意锁定。然后我们遵循第二个规则。情况是相反的，永远是较新的交易会等待。较老的交易不会等待，因为它会立即通过胜利终止较新的交易。
- en: So therefore we also avoid that box as well。 Does this make sense。 I mean in
    other words we are just going to be able to like you know impose an order on the
    transactions using this age mechanism and by doing so we avoid the cycle that
    we're trying to prevent。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以因此我们也要避免那个情况。这样说有道理吗？换句话说，我们只是会使用这个年龄机制对交易进行排序，通过这样做来避免我们想要防止的循环。
- en: So but it's important that we know if a transaction actually gets killed right
    by either one of these mechanism。 it has to get the original timestamp。 If not，
    then it's just it's not going to be fair right so if you look at like you're one
    of the previous schemes earlier right for example。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，重要的是我们要知道，如果一个交易被其中一个机制终止了，它必须获得原始的时间戳。如果没有，那么就不公平了。举个例子，你可以回顾一下之前的某个方案。
- en: Yeah， so we so let's say we use the first discipline first protocol and then
    if a transaction dies right and then it's just it's basically going to recue itself
    and trying to execute again。 If it gets a new timestamp that is still going to
    be waiting outside the bathroom and then waiting for a senior one to finish right。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，所以我们假设使用第一个规则的协议，然后如果一个交易失败，那么它基本上会重新排队并尝试再次执行。如果它获得了新的时间戳，那么它仍然会在外面等待，等待一个更老的交易完成，对吧。
- en: And then it's because of the fact that it's younger than the old transaction
    is going to kill off itself again。 So basically that means the new transaction
    is never going to be executed and that is bad。 Right。 so not only do we want to
    avoid that box we also want to make sure that that there is progress。 Right， which
    is something that you keep hearing these days and since we're in election phase
    right。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这就是因为它比旧交易年轻，最终会自己终止。所以基本上这意味着新的交易永远不会被执行，而这是不好的，对吧。所以我们不仅要避免那个情况，我们还要确保有进展，对吧，这是你现在经常听到的，尤其是在我们处于选举阶段的时候，对吧。
- en: So we want to make sure that this progress。 So we want to make sure that these
    transactions will eventually get executed。 So but then if we keep getting new
    timestamps then following the first discipline the new transactions never going
    to execute so that's bad。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们想要确保有进展。我们要确保这些交易最终会被执行。但是，如果我们一直得到新的时间戳，那么按照第一个规则，新交易永远不会执行，这样就不好了。
- en: So the only way of that is to basically make sure that we get the original timestamp。
    So therefore when the older transaction actually finishes eventually then like
    you know we will get to execute at that point。 And also notice that I'm just using
    this age right a time thing as one of the ways that you can use to impose an order
    that is not the only way right you can also use other mechanisms as well。 For
    example how much resources how much resources in terms of memory so and so forth
    it has already consumed how many locks it has already acquired so and so forth
    as another mechanism to do it。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以唯一的解决办法就是确保我们得到原始的时间戳。所以，当旧交易最终完成时，就像你知道的那样，我们会在那时执行它。同时请注意，我只是使用这个“年龄”机制作为强制排序的一种方式，这并不是唯一的方法，你也可以使用其他机制。例如，已经消耗了多少资源，比如内存，已经获取了多少锁等等，这些都可以作为实现排序的机制。
- en: I mean all that we're trying to do here is just to impose an arbitrary order
    on all these different transactions and make sure that this ordering there's no
    cycle within it。 such that we can use it to now break the debt block situation。
    Any questions about this so far。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，我们所要做的就是对所有这些不同的交易强加一个任意的顺序，并确保这个顺序中没有循环。这样我们就可以用它来打破死锁的情况。目前对此有任何问题吗？
- en: I apologize for the kind of stinky example but I think that's something that
    might make intuitive sense some of us。 Okay， if not I want to next talk about
    the detection。 Okay。 so if we cannot avoid that box to begin with or if you don't
    want to apply any of the mechanisms that we talked about before。 we can try to
    let everybody run and then like you know the attack that locks when it actually
    happens。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个有点臭的例子道歉，但我认为这可能是一些人容易理解的例子。好的，如果没有的话，我接下来想谈谈死锁检测。好的。所以，如果我们不能一开始就避免死锁，或者如果你不想应用我们之前讨论的任何机制。我们可以尝试让每个事务都执行，然后像你知道的那样，当死锁真的发生时去检测它。
- en: So how to do that。 Well， it turns out that we can create a wake for graph。 Similar
    to the pendent graph that did you I was talking about earlier。 and then we basically
    check this graph for cycles。 And if there's a cycle that basically means we have
    a deadlock。 How does this work。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，怎么做呢？结果我们可以创建一个等待图。类似于我之前提到的依赖图，然后我们基本上检查这个图中是否有循环。如果有循环，这基本上意味着我们遇到了死锁。这个是怎么工作的呢？
- en: So here for transactions。 And， you know， as the deal was saying earlier you
    know time goes sideways。 To the right。 So first transaction tries to read a。 and
    then it tries to read the these are different data elements。 So so far so good。
    We don't have anything we don't have any any any any any any deadlocks。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里涉及到事务。你知道的，正如之前提到的，时间是横向流动的。首先事务一尝试读取 A，然后它尝试读取这些不同的数据元素。到目前为止一切顺利。我们没有遇到任何死锁。
- en: And then transaction to now tries to write to be followed by transaction one
    trying to read it。 So just like in the dependence graph we're going to basically
    insert an ash between T one and T two。 second find that T one is now waiting for
    a lock that T two currently because it is writing to be。 Right。 And then let's
    go on right so now T three tries to read on D。 That's okay。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后事务二尝试写入 B，接着事务一尝试读取它。就像在依赖图中一样，我们基本上会在 T 一和 T 二之间插入一条箭头。接下来发现 T 一现在正在等待 T
    二的锁，因为 T 二正在写入 B。然后继续进行，现在 T 三尝试读取 D。这个是可以的。
- en: because like you know no one has written to be yet。 even though T one has read
    it earlier that that's not a problem。 And like you know no problem with C either，
    but now T two tries to write to see after T three has read it。 So at this point，
    we also insert with an insert an arrow right between T two and T three。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因为像你知道的，没有人曾经写入 B。即使 T 一早些时候读取过它，这也不是问题。而且，像你知道的，C 也没有问题，但现在 T 二在 T 三读取 C 后尝试写入
    C。所以在这一点上，我们也插入一条箭头，连接 T 二和 T 三。
- en: because T two is now waiting for the lock to be released by T three。 And then，
    you know。 going on T four now tries to write to be after T one has read it and
    T two has also written to it right。 So now T four also has an ash to T two because
    it's also waiting for the same lock that T two is currently holding on B before
    it can proceed。 And now finally if T three tries to write to A， we now have a
    cycle。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 T 二现在正在等待 T 三释放它所持有的锁。然后，你知道的，接下来 T 四试图在 T 一读取后以及 T 二也已写入的情况下写入 B。现在 T 四也有一个依赖关系到
    T 二，因为它也在等待 T 二当前持有的锁，只有等 T 二释放后才能继续。所以现在，如果 T 三尝试写入 A，我们就会遇到一个死锁循环。
- en: because T three is waiting for a lock that T one is currently trying to is currently
    holding on。 namely lock on A。 And then， transitively right you know T three T
    and then like you know T one is waiting for T two teachers wait for T three T
    three is also waiting on T one。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 T 三正在等待 T 一持有的锁，即 A 上的锁。然后，递归地，T 三等待 T 一，T 一等待 T 二，T 二等待 T 三，T 三也在等待 T 一。
- en: So because there's a cycle。 Now there is a bad lock。 Make sense。 Basically means
    that like none of them can make any progress right everybody holding on to any
    everybody else's lock。 No one can make any progress even though T three is still。
    is still crushing it right in T four as a T four is still going on。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所以因为存在一个循环，现在就有了死锁。明白吗？基本上意味着它们都无法继续进展，每个人都在持有其他人的锁。没有人能够取得进展，即使 T 三依然在进行，T
    四也仍然在执行。
- en: T four can still proceed as before right you know nothing really happened。 So
    now since we have a deadlock between T one to three。 we basically need to figure
    out how to how to how to break the lock right how to break the deadlock。 And the
    way to do that is to be is by basically run periodically this deadlock detection
    mechanism by detecting cycles。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: T4仍然可以像之前一样继续执行，对吧？没有什么实际的变化。那么现在，由于T1到T3之间发生了死锁，我们基本上需要弄清楚如何打破这个锁，如何打破死锁。解决这个问题的方法就是周期性地运行死锁检测机制，通过检测循环来识别死锁。
- en: And then when a cycle shows up just like you know choose one of the transactions
    to kill。 And you actually detect that。 Yeah。 So basically kill off one of the
    transactions in the cycle to break it。 And then we let everybody like you know
    we kill and try to execute again。 As a as an empirical fact most of these deadlocks
    tend to be small。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当检测到一个循环时，就像你知道的那样，选择其中一个事务来终止它。然后你实际上能检测到这一点。是的，所以基本上我们需要终止循环中的一个事务来打破它。然后我们让所有人继续执行，就像你知道的，我们终止并尝试重新执行。作为一个经验事实，大多数这些死锁通常是比较小的。
- en: So it doesn't involve like you know one million transactions usually tend to
    involve only few transactions。 And even if we were to shoot everything right meaning
    that we kill all the transaction involved。 it would have been that bad right because
    we're not going to add back tons of transactions back to the queue。 Any questions
    about this so far。 Great so we we have now talked about like you know avoiding
    deadlocks。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这并不像你知道的那样涉及到一百万个事务，通常只涉及到几个事务。而且即使我们所有的操作都做得很完美，意味着我们杀死所有相关的事务，情况也不会太糟，对吧？因为我们不会把大量事务重新添加回队列。到目前为止有关于这一点的任何问题吗？很好，所以我们现在已经讨论了如何避免死锁。
- en: And if we cannot avoid it for whatever reason we have now have a way to detect
    it。 And we also have a way to deal with it right if we actually detect that lock。
    So now you might ask the question I mean like you know there。 Can we do something
    better in terms of maybe we don't actually need to get into that lock situation
    for example。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法避免死锁，无论出于什么原因，我们现在有一种方法可以检测到它。而且我们也有方法来处理它，对吧？如果我们确实检测到死锁。现在你可能会问，是否能做得更好？比如说，我们是否可以避免进入死锁的情况呢？
- en: If everybody is just trying to read things then like you know even though it's
    a cycle it's okay。 Right even though everybody might be actually waiting for everybody's
    lock it's actually okay because when you're everyone is just trying to read not
    right right so you know supposedly it's not really a conflict in that case right。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个人都只是试图读取数据，那么即使它形成了一个循环也是可以的。对吧？即使每个人可能实际上都在等待其他人的锁，实际上也是可以的，因为当每个人只是试图读取数据时，并没有真正的冲突，对吧？
- en: So how do we actually do how to actually implement that mechanism is there a
    way to actually implement that intuition。 Turns out there is so we can use something
    known as different lock modes。 So so far we've been talking about a single lock
    right like you know either you grab it and then nobody else can get access to
    it right that's the principle that we learned in 61 C。 Well here's another way
    of implementing locks we still have this notion of like you know exclusive access
    to something you've been wanted。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何实际实现这个机制呢？有没有一种方法可以实现这个直觉呢？结果证明是有的，我们可以使用不同的锁模式。到目前为止，我们一直在讨论一个单一的锁，对吧？比如你要么获取它，然后没有其他人可以访问它，这是我们在61C中学到的原则。那么这里有另一种实现锁的方法，我们仍然有这种排他性访问的概念，你想要获取某个资源。
- en: but we have different levels。 We have a level where we can actually share a
    lot of multiple transactions to share。 For example if all they're doing is reading
    it if it's reading a data element。 But then we also have another level known as
    exclusive meaning that there's only one transaction that can hold on to that particular
    lock at any time。 Why do we want to do this。 Well we want to do this because we
    want to allow transactions only doing reading for example to proceed without needing
    to deal with all these you know that lock or like detection or like your wake
    diet and all these other business。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们有不同的级别。我们有一个级别可以让多个事务共享锁。例如，如果它们只是读取数据元素。那么我们还有另一个级别，叫做排他性锁，意味着在任何时候，只有一个事务可以持有该特定锁。为什么我们要这么做？嗯，我们这么做是因为我们希望允许那些只做读取操作的事务继续执行，而不需要处理所有这些死锁、检测或唤醒之类的问题。
- en: If everyone is just reading， then like you can still play like your strict to
    be out。 and we'll still get the concurrency right going through。 We won't need
    to kill off transactions because like we won't have that locks。 And that would
    be great because now we can still have concurrency control even with our we can
    still have things running concurrently and get the benefit。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个人都在读取，那么你仍然可以继续进行严格的“出局”操作，我们仍然能够正确地实现并发。我们不需要终止事务，因为我们不会遇到锁的问题。这会非常好，因为我们仍然可以在并发控制下运行，并获得并发带来的好处。
- en: even though we're still playing the strict to be out game。 But then now that
    we have different types of lock we need to make sure that we have a way to distinguish
    when can the transaction grab each type of lock。 So to do with that， people use
    what is known as a lock compatibility matrix。 So you can see one example here
    right so we have this matrix here。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们仍然在玩严格的“出局”游戏。但是现在因为我们有不同类型的锁，所以我们需要确保有一种方式来区分什么时候事务能够获取每种类型的锁。所以为此，人们使用了一个被称为“锁兼容性矩阵”的工具。你可以看到这里有一个例子，所以我们有这个矩阵。
- en: and then each of these entries here would basically either have a check mark
    or across。 The way to read it is to basically read off the two entries on the
    side and on the top。 So if both if transaction one is not having any lock on a
    particular data element。 then another transaction comes along and can proceed
    as normal。 Nothing happens right。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这里的每个条目基本上会有一个勾号或者叉号。阅读的方法是基本上查看左侧和顶部的两个条目。所以如果事务一没有在某个特定数据元素上持有任何锁，另一个事务出现并且可以照常继续进行。什么都不会发生。
- en: And now if a transaction has already gotten a shared lock on a particular data
    element。 And if a new transaction shows up and it's also trying to grab a share
    lock。 That's okay。 Because share market this case means just trying to read it
    right。 So that builds up on our intuition that we want the wreath to just proceed
    as always。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个事务已经在某个特定数据元素上获得了共享锁，且一个新的事务出现并且也试图获取共享锁，那是可以的。因为在这种情况下，共享锁意味着只是尝试读取对吧？因此，这符合我们的直觉，我们希望读取操作像以前一样继续进行。
- en: They can just proceed concurrently just like anything else just like everybody
    else right so no blocking。 No need to check for that lots of other stuff。 However。
    if a new transaction shows up and trying to actually write to the same data element
    that a previous transaction is currently reading。 then we won't allow that to
    happen。 In other words。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以像其他事务一样并行进行，就像其他事务一样，*没有阻塞*。不需要检查很多其他内容。然而，如果一个新的事务出现并试图写入一个正在被之前事务读取的数据元素，那么我们不会允许这种情况发生。换句话说。
- en: if a transaction is already holding onto a shared lock。 then if a new transaction
    shows up and tries to grab an exclusive lock on the same data elements。 they will
    not going to allow that to happen。 Right。 because otherwise then we broke our
    promise right off like you know off to the L and we ended up in one of these like
    you know terrible situations that we're trying to avoid earlier。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个事务已经持有一个共享锁，那么如果一个新的事务出现并尝试在同一个数据元素上获取一个独占锁，它们将不会被允许。对吧？因为否则我们就违反了我们之前的承诺，最终会进入我们之前尽力避免的那些糟糕情况。
- en: And you can reason about the rest right off course that also means like you
    know if a transaction already has an exclusive lock。 we cannot allow another transaction
    to have the same exclusive lock as well。 Okay。 so it's a question。 I think there's
    a question in the chat and we can someone repeat what it is I wasn't following
    it。 Yeah， essentially the question is why do we not have like reads always following
    before writes because like with b plus trees we had。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以推理出其他情况，当然，这也意味着如果一个事务已经拥有独占锁，我们不能允许另一个事务也拥有相同的独占锁。好的，所以这是一个问题。我想在聊天中有一个问题，能不能有人重复一下我没听明白？是的，基本上问题是为什么我们不总是让读取操作先于写入操作？因为像在B+树中我们曾经有过这种设计。
- en: we had to read on the page modifier and then write it back。 Yeah。 so can you
    always have read before writes right if you can order your transactions operations
    to be exactly that then that's great。 In fact， there are database systems that
    have that as a requirement that you cannot write anything。 You can only write
    to things after you have read everything that you need from the database。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须先读取页面的修改内容，然后再写回去。对。所以，你总是可以保证先读取再写入吗？如果你能将事务操作的顺序安排得恰如其分，那当然很好。事实上，有些数据库系统要求必须在读取完所需的所有数据之后，才能写入任何内容。
- en: but you can always guarantee that's the case right， for example。 I might need
    to read something first before I can decide what's it right and then after writing
    to it I might actually need to read something else that is derived from it right。
    So that's a I need to read like you know， total number of students and I'm going
    to write a right that says like you know here's the total number。 and then I might
    need to read that back right as something within the same transaction and also
    do something else with it。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但你总是可以保证这种情况对吧？例如，我可能需要先读取某些内容，然后才能决定写入什么内容。之后，在写入后，我可能需要再次读取从它派生出来的其他内容。所以这是一个，我需要先读取总学生人数，然后写入一个记录，表示总人数。然后，我可能还需要再读取它作为同一事务的一部分，并做其他事情。
- en: So you can always guarantee that is the case。 Would be nice if that's true but
    not always。 So Alvin I think there's also some confusion over read and writes
    and sort of the logical space of transactions and what reads and writes mean for
    pages at the level of the buffer manager。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你总是可以保证这种情况吗？如果这是事实，那当然很好，但并非总是如此。所以阿尔文，我觉得大家对于读取和写入的理解，以及事务在逻辑层面的作用，还有缓冲区管理器层面上读取和写入的含义，可能也存在一些混淆。
- en: Oh， okay great。 So， so remember what we're talking about this case as data elements
    right so I was purposely trying to be vague about that because later on you see
    we actually talk about different levels of logs。 So for now I think for the purpose
    of this part of the lecture you just think of like each of these locks actually
    is on a single football。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，明白了。所以，记住我们在讨论的这个例子是数据元素。所以我故意在这里保持模糊，因为稍后我们会谈到不同级别的日志。现在，作为本节讲座的目的，你可以将每个锁视为单个数据元素。
- en: So if there's a page that we have read into main memory and then it consists
    of like that's a hundred different。 suppose， then that basically means we have
    a hundred different locks。 each one individually for each of the two posts that
    involved。 Was that the question or the confusion。 I was more confused about。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一页我们已经读取到主存中，并且它包含了比如说100个不同的条目，那么这就意味着我们有100个不同的锁，每个锁分别用于两个相关的条目。这是问题还是困惑所在吗？我更困惑的是……
- en: I think it was a few slides back when you had like four transactions listed
    on the slide and then where like transaction one was reading D and B but transaction
    two was writing B before like writing another one before without having。 any reads
    on it。 I was just wondering if that's like if that's possible because I thought
    reading was how you access data and then writing was how to modify it。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我想应该是在几张幻灯片之前，当时你在幻灯片上列出了四个事务，其中事务一是读取D和B，但事务二在没有读取任何数据的情况下就写入了B，再写另一个。我只是想知道这样做是否可能，因为我原本以为读取是访问数据的方式，而写入是修改数据的方式。
- en: So， I wasn't sure if that's like that was something you just left out or if
    that's something that you can actually do what you can write without the data。
    Yeah， you can write before you can wait for example I want to。 I want to change
    everybody's names to be out of it。 Right。 we don't need to wait anything in that
    case， I mean just writing all the records right。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我不确定这是不是你故意没有提到的，或者是否实际上可以做到没有数据的情况下就写入。嗯，你可以在写入之前就进行操作。例如，我想把每个人的名字都改掉。对吧？在这种情况下，我们不需要等待什么，只要直接写入所有记录就行了。
- en: So that's okay。 Yeah， okay that's what Dave explained and then yeah okay I got
    it thank you。 Okay。 so now let's talk about like how does it actually work right
    inside database system so we're very tough。 We already talked about this concept
    of locks right。 So who actually manages all these locks right we need somebody
    to actually manage them。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，没问题。对，好的，这是戴夫解释的内容，然后是的，明白了，谢谢。好，现在让我们讨论一下数据库系统内部是如何实际工作的。我们已经提到过锁的概念，对吧？那么，谁来管理这些锁呢？我们需要有人来管理它们。
- en: So it turns out that there's something called a lock manager inside database
    system that does this。 And as you have guessed right is job is to basically handle
    all the locking。 Acquisition and releases。 Okay。 And internally it may maintain
    a hash table and then it just keep on the things that are being locked。 So if
    we are talking about Google level lock， then there's basically going to one entry
    for each lock for each level in this case right。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，在数据库系统中有一个叫做锁管理器的东西来处理这些问题。正如你所猜到的，它的工作基本上就是处理所有的锁获取和释放。好的，在内部，它可能会维护一个哈希表，然后持续跟踪正在被锁定的对象。所以，如果我们谈论的是Google级别的锁，那基本上每个锁在每个级别上都会有一个条目。
- en: And then it just keeps track of who currently has it。 It has a grant set which
    basically means who are the transaction that currently holding on to these lots。
    It has the lock mode in case there's multi levels as I talked about earlier。 And
    then it also has a line of different transactions that waiting on it。 So an example
    here。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会跟踪谁当前持有这些锁。它有一个授予集，基本上是指哪些事务当前持有这些锁。它还会记录锁模式，以防有多级锁的情况，就像我之前提到的那样。并且它还会维护一个等待队列，列出不同的事务正在等待该锁。这里是一个示例。
- en: So we have two different locks a and B。 So they can be a single a and B can
    be individual for example。 So we can see that T1 and T2 already has the lock on
    a because it's a shared lock。 And then we have a line of other transactions waiting
    for it right three and before。 And then they are trying to grab the exclusive
    lock on a。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有两个不同的锁，A和B。它们可以是单一的，也可以是独立的。例如，我们可以看到T1和T2已经对A加了锁，因为它是共享锁。然后我们有一条其他事务的队列在等待它，分别是T3和T4。它们正在尝试获取A的独占锁。
- en: So this is definitely just one single designer like you know different designs
    that you can imagine but the way that it works。 Is when a lock request arrives，
    then we're just basically going to look up this table and figure out whether we
    want to grant it or not。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定只是其中的一种设计方式，像你可以想象的不同设计方式一样。但它的工作原理是，当锁请求到达时，我们基本上会查阅这个表格，然后决定是否授予它。
- en: And that is basically based on the compatibility basic I was talking to you
    guys earlier。 So if we can actually grant that lock then we just put that transaction
    into the grants grants a set。 If not then we just basically put it up onto the
    into the queue。 And if a if a transaction site upgrade is not for example。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这取决于之前我跟你们讲的兼容性原则。所以如果我们可以授予这个锁，我们就会将这个事务加入到授予集。如果不能，我们就会把它放入队列中。如果一个事务尝试升级锁类型，例如：
- en: if it already has a shared lock and now decide to grab an exclusive lock because
    it's going to write to write to the same data elements。 Then we just use the same
    mechanism as well right to look up in this table。 figure out whether it can， it
    can actually grant that lock and then if so upgrade the mode to be exclusive。
    So I have two minutes left I just want to like you know talk very briefly about
    this notion of lock granularity and we'll continue about that next time。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它已经有了共享锁，现在决定获取独占锁，因为它将写入相同的数据元素。那么我们就会使用相同的机制，查阅这个表格，看看是否可以授予这个锁，如果可以，就把锁模式升级为独占锁。我的时间只剩两分钟了，我想简要谈一下锁粒度的概念，下次我们会继续讲这个内容。
- en: So early I was talking about this notion of like you know there are different
    locks for triple。 but you can imagine that's somewhat wasteful right so for example
    if I'm actually doing a two for that sorry if I'm running a query that says next
    stop。 And let's say I have a million people。 If I need to grab a lock on every
    single one million of those two posts。 That's going to be quite costly right。
    As I said， these lock these locking acquisition and releases is not going to come
    free。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候我提到过关于不同类型的锁，比如三重锁的概念。但是你可以想象，这样做有点浪费，对吧？比如说，如果我实际上在执行一个查询，查询内容是“下一个停靠点”。假设我有一百万个人。如果我需要为这其中的每一个人获取锁，那将会非常昂贵，对吧？正如我之前所说，这些锁的获取和释放并不是免费的。
- en: They are going to incur CPU costs。 So if I have to grab 1 million of these individual
    locks and then also subsequently release everything。 It's going to be quite costly。
    So is there actually a way to have locks as different levels。 Right。 So for example，
    if I can grab a lock on the entire table that would be nice if I'm actually reading
    everything right that's what I'm trying to do anyway。 So I already mentioned this
    earlier so one on the one hand we can have very fine brain locking at the triple
    level。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它们会产生 CPU 开销。所以如果我必须获取 100 万个独立的锁，然后再释放所有的锁，这将是非常昂贵的。那么，实际上有没有一种方法可以实现不同层级的锁呢？对吧？比如说，如果我能在整个表上加一个锁，那就很好，因为如果我实际上是在读取所有数据，正是我想要做的。所以我之前提到过这一点，一方面我们可以在三元组级别进行非常精细的锁定。
- en: That is good in the sense of allowing high concurrency right because now you
    know to two posts are actually reading。 Sorry two transactions are actually reading
    different people from the same table can now actually proceed。 And so they don't
    they're not doing the interview with each other they have different locks they
    can grab those different locks and then and then they just move on。 So that's
    good for concurrency， but it's a problem in terms of having high over that。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是允许高并发，因为现在你知道两个帖子实际上在读取，抱歉，是两个事务在读取，不同的人可以从同一张表中读取，现在实际上可以并行进行。所以它们之间不会互相干扰，它们有不同的锁，可以获取这些不同的锁，然后继续执行。所以这对并发性有好处，但在高开销方面会有问题。
- en: As I said imagine grabbing 1 million 1 million of these lock right just to read
    just to serve let's say like a select on query。 On the other hand， you know we
    can do the SQL white approach right in terms of having one single lock for the
    entire database。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，想象一下获取 100 万个这样的锁，仅仅是为了读取，假设是执行一个选择查询。另一方面，你知道我们可以采用 SQL 写锁的方式，即为整个数据库加一个单一的锁。
- en: That's good right because there's no overhead and it's one one lock。 but then
    we have basically killed up concurrency at that point。 Right， nobody else can
    proceed。 So what is the solution was a solution to basically have like different
    levels of locking。 and then so called as to wait。 As when as we go up as we decide
    what we actually needed to do。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为没有开销，只有一个锁。但是，到那时我们基本上已经杀死了并发性。对吧？没有其他人能够继续进行。那么解决方案是什么呢？解决方案是基本上拥有不同级别的锁定，然后根据需要进行等待。随着我们向上走，我们决定实际需要做什么。
- en: It is going to be similar to the different locking levels I mentioned earlier
    in terms of share and exclusive。 You can now imagine basically having lock at
    the table level at the table level。 and even at the database level。 Right， the
    question is， of course。 like you have to decide I mean which level to actually
    grab the lock。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它将类似于我之前提到的不同锁定级别，比如共享锁和独占锁。你现在可以想象在表级别甚至数据库级别加锁。问题当然是，你必须决定在哪个级别获取锁。
- en: Like you can grab a lock at the table level at the page level so on so forth。
    and what is the trade off here。 Right， because like you know we have a lock single
    lock for two pole that is great right as I said you can allow we can allow a lot
    of concurrency to happen。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你可以在表级、页级等不同层级获取锁。那么这里的权衡是什么呢？因为你知道我们可以为两个操作加一个单独的锁，这很好，正如我所说的，它可以允许我们有很高的并发。
- en: And we also this is also great but because small number of locks also means
    like managing them is also very simple。 So it makes the job of the lock manager
    easy。 The question then is of course like you know can we have both。 Right， because
    we want to have both level of locks simultaneously happening。 and people grab
    different transactions where they grab different types of locks right。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也知道，这样做很好，因为较少的锁意味着管理起来也更简单。因此，它使得锁管理者的工作变得轻松。那么问题是，当然，我们能同时拥有两者吗？对吧？因为我们希望在不同的事务中同时发生两种级别的锁，且它们获取不同类型的锁。
- en: And we somehow don't want them to interfere because it will be bad as like you
    know we ended up breaking concurrency control right by allowing two transactions
    to be let's say writing to the same tool for right。 So， I'm going to actually
    stop here and not tell you guys the answer and do next week。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不希望它们相互干扰，因为那样会很糟糕，就像你知道的，我们最终可能会打破并发控制，让两个事务，比如说，写入同一张表的不同地方。所以，我实际上会停在这里，不告诉大家答案，下周再讲。
- en: So if you're dying， you know you can try to scheme through the rest of the slides
    I tried to make the tax book。 but I'll leave you guys with this question I mean
    how can we actually and serve both of these types of locks actually exist within
    the same system。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你快要死了，你知道你可以尝试快速浏览剩下的幻灯片，我尽力做了税务书。但是我会留给你们这个问题，我是说，我们如何才能让这两种锁都能在同一个系统中共存呢？
- en: but still preserving， the kind of consistency that we want in the database。
    Well。 if you have any questions please stay and ask otherwise we'll see you on
    Tuesday and have a great weekend everyone。 [ Silence ]。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但仍然保持我们在数据库中所需要的一致性。好吧，如果你有任何问题，请留下来提问，否则我们周二见，祝大家周末愉快。[沉默]
- en: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_7.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eae5e6a7bf6abaacd589335a2e1dca71_7.png)'
