- en: P20：Lecture 19 Principles of System Design - ___main___ - BV1ED4y1R7RJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P20：第19讲 系统设计原则 - ___主讲___ - BV1ED4y1R7RJ
- en: So， CS140 is about operating systems。 In this class。 we used all these things
    that you will end up building in operating systems， right？
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，CS140是关于操作系统的。在这门课程中，我们使用了你最终将在操作系统中构建的所有这些内容，对吧？
- en: Like you build a file system。 You build like how you actually。 you kind of build
    a little bit of that for this class。 but you build like a little lower level file
    system and more robust and more of the parts。 for the files。 You don't have to
    just read and write files。 You build the actual file system in 140。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，你会构建一个文件系统。你会构建如何实际操作文件的系统。在这门课上，你会构建一个较低级的、更稳健的文件系统，并且更多地涉及文件的各个部分。你不仅仅是读取和写文件，你会在140课程中构建实际的文件系统。
- en: You build a threading library or a forking library and multi-processing library。
    And those are the kinds of things that we know how to use now and then you'll
    actually。 do them in 140 where you actually build them and understand what it
    takes to build a threading。 library。 So， it's a good thing you already know how
    to use these because then it's much easier。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会构建一个线程库、一个分叉库和一个多处理库。这些正是我们现在知道如何使用的东西，接下来你将在140课程中真正构建它们，并理解构建一个线程库所需的内容。所以，很高兴你已经知道如何使用这些库，因为那样做起来会容易得多。
- en: to understand how you're going to go and build them。 So， that's that。 And that's
    about the implementation part of it。 There's also CS 143 which is compiler construction。
    Compilers class， when I was in graduate school， it was one of my favorite classes。
    I didn't do particularly well， I'm sorry。 But it was a class that I enjoyed a
    lot because you really get a much more detailed feel for。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何去构建它们。所以，这就是关于实现部分的内容。还有CS 143，这是一门编译器构造课程。在我读研究生时，这是一门我最喜欢的课程。尽管我成绩不是特别好，非常抱歉，但我非常喜欢这门课程，因为你会更深入地了解编译器的工作原理。
- en: hey， how does your code end up as machine code？ Now。 you cover that a little
    bit in 107 but not really the part of like actually doing， the translation。 Like
    you see how， you see what the beginning and the end are but compiler is all about。
    translating and doing that。 And it's a great class。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，你的代码是如何最终变成机器码的？在107课程中你稍微涉及过这个话题，但并没有真正深入到如何进行翻译的部分。你会看到起始和结束的过程，但编译器的核心就是进行这些翻译。这是一门非常棒的课程。
- en: I also happen to think that a lot of employers when they see that you took a
    compiler's class。 actually perk up a little bit and go， oh， well this person went
    a little bit outside。 than normal because it's not like everybody takes compilers
    and they know it's a hard， class too。 So， for what that's worth。 I think it's
    an interesting class and you might want to take a look at that。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我还认为，很多雇主看到你上过编译器课程时，通常会稍微有点兴趣，觉得这个人敢于挑战常规，因为并不是每个人都会选修编译器课程，而且大家都知道这是一门很难的课程。所以，这门课很有趣，如果你有兴趣的话，可以去了解一下。
- en: If you like the networking things that we did recently， CS144 covers networking
    and this。 is in much more detail than what we did。 We just talked about server
    client and setting up a network and so forth。 This networking class digs into
    more of the details。 Like how do the bits actually get across the network efficiently？
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢我们最近做的网络相关的内容，CS144涵盖了更多细节的网络知识，比我们做的要详细得多。我们只是讨论了服务器与客户端，以及如何设置网络等等。这门网络课程会深入探讨更多细节。例如，数据是如何高效地通过网络传输的？
- en: We'll talk a little bit more about that today just in general terms。 But that's
    what the networking class covers and it's another good class especially if。 you're
    interested in this sort of stuff。 If you do go into security or things。 it's probably
    not a bad idea to take a peer networking。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们会更一般性地讨论这个话题。但这就是网络课程的内容，它是另一门非常好的课程，特别是如果你对这类东西感兴趣。如果你将来从事安全相关的工作，或者类似的领域，选修一门网络课程也许不是个坏主意。
- en: class as well because it's got a lot of the things that a lot of the exploits
    end up exploiting。 things that might be at the networking layers that you haven't
    necessarily seen in this class。 Okay？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这门课也非常重要，因为它涉及很多漏洞利用的内容，这些内容可能存在于你在这门课上还没有看到的网络层。明白吗？
- en: So， that's the three bigger ones that I think you could go on and take。 There's
    also 144 and 142 and other classes that are， sorry， 142 is another one that you。
    can take that dig into more systems details。 So there are a lot of systems classes
    and again。 I do recognize that many of you are like， I'm glad I'm done with systems
    forever and that's it。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我认为你可以继续深入学习的三个主要方面。还有144和142等其他课程，抱歉，142是另外一门可以让你深入学习系统细节的课程。所以有很多系统课程，再次声明，我理解很多人都想说，终于结束了，永远不想再学系统了。
- en: But for other people who want to do it， lots of other choices and feel free
    to chat with。 me about that if you want to know some of those other choices。 Okay。
    So here's the principles we want to talk about today。 So we want to talk about
    abstraction。 Now。 abstraction is what you've been doing。 You've seen abstraction
    at many。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于那些想要尝试的其他人，有很多其他选择，如果你想了解更多这些选择，随时可以和我聊。好了。那么今天我们要讨论的原则是这些。我们要讨论抽象。现在，抽象就是你一直在做的事情。你在许多场合中都看到了抽象。
- en: many different layers and we'll get to the details of what， abstraction is all
    about。 We need to talk about how that relates to CS110。 Modularity and layering
    is another one that we're going to look at。 Naming， remember all those things，
    you're doing file systems and like name resolution。 That's kind of a big principle
    that you have to deal with。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的层次，我们会深入讨论抽象到底是什么。我们需要讨论它与CS110的关系。模块化和分层是我们要看的另一个方面。命名，记住你在文件系统中做的所有事情，比如名称解析。这是你必须处理的一个重要原则。
- en: Many of these principles are all about doing things either more efficiently
    or doing them。 in such a way that makes a big system become less gigantic to wrap
    your head around。 That's what a lot of these things are。 Okay。 Or it's a matter
    of like name resolution is all about。 hey， humans are good at names， computers
    are good at numbers。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则大多数是关于更高效地做事情，或者以某种方式让一个庞大的系统变得不那么庞大，更容易理解。这就是这些原则的主要内容。好吧。或者说，像名称解析就是这样，嘿，人类擅长名称，计算机擅长数字。
- en: how do you mix those together so that it works most efficiently， for the computer。
    Virtualization。 we'll talk about two different types of virtualization and then
    concurrency。 which I would argue this class is more about concurrency than probably
    any other topic。 There's more of that kind of filtered in along the way。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何将两者结合起来，使其对计算机来说更加高效。虚拟化。我们将讨论两种不同类型的虚拟化，然后是并发。我认为这门课更多地涉及并发，可能比其他任何主题都要多。沿途会有更多这种内容。
- en: And then client server request and response is another one。 It's not just networks
    that deal with client server request and response。 Anytime you have two programs
    trying to communicate whether they're on the same computer or across。 a network
    or in some other sense， that's where you've got this client server request response。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户端-服务器请求和响应是另一个方面。并非只有网络涉及客户端-服务器的请求和响应。无论你是否在同一台计算机上，或者通过网络，或者在其他任何情况下，只要有两个程序试图进行通信，就涉及到客户端-服务器请求和响应。
- en: And understanding how that works is kind of is important。 Okay。 All right。 So
    those are the let's jump right in and of course， hang on。 Of course， this is not
    working again。 There we go。 Okay。 Maybe。 Okay。 We'll go about it。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而且理解它是如何工作的，这一点非常重要。好吧，没问题。那么这些是，我们直接跳进去，当然，等等。当然，这又不工作了。好了。也许。好的。我们继续进行。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_1.png)'
- en: There we go。 There we go。 There we go。 There we go。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 来了，来了。来了，来了。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_3.png)'
- en: Now it's back。 Okay。 So abstraction。 All right。 Abstraction is simply separating
    what the program is doing from the implementation。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回来了。好吧。抽象。好的。抽象就是简单地将程序所做的事情与实现分开。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_5.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_5.png)'
- en: Okay。 And this is something we've seen in lots of different scenarios。 But one
    example is just a sorting program。 Right。 A sorting program has an interface where
    you pass a bunch of words in and they come back。 to you sorted。 And that's the
    interface that you may have。 You have to put them in an array and you have to
    set where the beginning and the array。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。这是我们在许多不同场景中看到的内容。但其中一个例子就是排序程序。对吧，一个排序程序有一个接口，你传入一堆单词，然后它会把这些单词排序后返回给你。这就是你可能拥有的接口。你需要将它们放入数组，并设置数组的起始位置。
- en: is and so forth。 That would be the interface。 The actual behavior is they get
    sorted。 How that implementation happens is completely up to the program。 Now，
    of course， with sort。 you want to do it。 You don't， there are so many different
    types of sorts and you don't want to do the one。 that's going to be oh and you
    want to do the one that's going to be oh and log and or， whatever。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。那就是接口。实际的行为是它们被排序。实现是如何发生的完全取决于程序。当然，使用 sort 时，你希望使用最优的排序算法。你不想用那个最差的排序方法。你希望使用一个复杂度为
    O(n log n) 的排序，或者是其他什么的。
- en: But in terms of the implementation versus the or the interface versus the abstracted。
    this is how it goes， that's the big， big picture of abstraction。 Okay。 We've seen
    these in many。 many ways。 The big challenge a lot of times is to design a clean
    interface that makes some library。 you're designing easy to use。 Okay。 We've actually
    done a lot of the designing of the interface for you in this class。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但从实现与接口与抽象的角度来看，它是这样的，这就是抽象的大致框架。好吧。我们已经在许多方面看到了这些。很多时候，主要的挑战是设计一个干净的接口，使得你设计的某个库容易使用。好吧。我们在这门课上已经为你们做了很多接口的设计。
- en: Mainly because it would be really hard to say hey， here's the， it would be hard
    to test。 it first of all。 But second， without a clear interface， you can spend
    many。 many hours thinking about how， to design an interface for something and
    you kind of want to do it properly because it。 is challenging。 I would argue that
    the C++ language， the interfaces are not necessarily as clean as。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是因为如果你不清楚接口，设计和测试会非常困难，首先是很难测试。但其次，没有清晰的接口，你可能会花费很多时间思考如何设计某个东西的接口，而你会想要正确地做，因为它确实很有挑战性。我认为
    C++ 语言中的接口不一定像...
- en: you might hope for other languages。 They tend to be somewhat cleaner。 You know。
    when you do a find in a map and you come and give you back an iterator and there's。
    a first and a second and all that kind of business that's kind of painful to deal
    with。 All right。 That might not be quite as clean。 It's there for a reason， but
    it might not be particularly clean。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会希望其他语言更简洁一些。你知道，当你在 map 中查找时，它返回一个迭代器，并且有一个第一个元素和第二个元素，等等，这样的事情处理起来就有点麻烦。好吧。那可能没有那么简洁。它之所以存在是有原因的，但它可能并不是特别简洁。
- en: File systems。 So whenever， when you use file star and IO streams and we use
    many more IO streams in。 this class than we did file stars， that's an abstraction
    that is away from the read， the。 low level read and write， which is what we saw
    right at the beginning。 And why do we abstract those away？ Because again， it's
    easier。 With the read and the write。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统。所以每当你使用文件流和 IO 流时，我们在这门课中使用的 IO 流比文件流多得多，这是一个从低级读取和写入（我们最开始看到的那部分）中抽象出来的东西。为什么我们要将它们抽象化呢？因为，正如之前所说，这样做更容易。通过读取和写入。
- en: you have to worry about buffering yourself。 You have to worry about， oh。 what
    happens if I try to read 10 bytes and I only get 6， bytes back。 These are all
    abstract in a way。 Once you have a good file library like IO stream and file stars
    and so forth。 Okay。 Processes。 Well， processes。 Why is that an abstraction？ Well。
    Okay。 So it's basically。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须考虑如何为自己处理缓冲。你必须考虑，哦，假如我尝试读取 10 个字节，但只读取到 6 个字节，怎么办。这些从某种程度上来说都是抽象的。一旦你有了一个好的文件库，比如
    IO 流和文件流之类的，情况就不一样了。好吧。进程。那么，进程为什么是抽象的呢？嗯，好吧。所以本质上是这样的。
- en: you probably don't know how fork and exec VP work。 Right？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不知道 fork 和 execvp 是如何工作的，对吧？
- en: You'll learn that if you take CS 140 about how those actually work under the
    hood。 But there's an interface there。 When you say fork。 you know that it creates
    two processes and you don't really care how， it happens。 But you know that now
    you've got two processes and you've got a child and a parent and so， forth。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学了 CS 140，你会了解这些背后实际是如何工作的。但那是一个接口。当你调用 fork 时，你知道它会创建两个进程，你并不关心它是如何实现的。但你知道现在你有了两个进程，一个是子进程，一个是父进程，等等。
- en: And there's lots of other things happening to keep track of the child to be
    able to wait。 PID and so forth。 That's all in abstraction。 Signals is another
    one。 If you took CS 107E。 you may have， you definitely did interrupts which are
    basically signals and。 you know a little bit more about how those work。 But the
    idea that you've got a。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他事情在发生，用于跟踪子进程，以便能够等待，进程 ID（PID）等等。这一切都是抽象的。信号也是其中之一。如果你学了 CS 107E，你可能学过中断，它本质上就是信号，你对它的工作原理了解更多一些。但关键是你有一个。
- en: the kernel keeping track of a bunch of things that you， don't necessarily， you
    want them。 you want the kernel to keep track of it。 You don't really know how
    it's doing that。 You just know that when something happens， the kernel goes and
    tells your program calls。 a handler function or whatever。 That's basically a signal。
    So that's abstracted away too。 Your。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内核跟踪着一些你不一定需要知道的事情。你希望内核去跟踪它们。你并不真正知道它是如何做到的。你只知道，当某件事发生时，内核会去调用你的程序，触发一个处理函数或类似的东西。这基本上就是一个信号。所以这个也被抽象化了。你的。
- en: the abstraction there is， oh okay， I've got a signal handler that's going to
    get。 called when something happens and how does that actually， when we camp that，
    it's all。 abstracted away from you。 Okay。 If you go take the operating systems。
    you'll learn more about how that happens or maybe， some double E classes too or
    you deal with that。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的抽象是，哦，好吧，当某件事发生时，我有一个信号处理器会被调用，它是如何实现的呢？当我们封装它时，这一切都被抽象化了。如果你去学操作系统，你将了解更多关于它是如何工作的，或者也许某些电子工程课程也会涉及到这些内容。
- en: Threads， same sort of thing。 Remember threads and processes are similar。 Their
    threads are kind of lightweight processes but it's the same idea。 You've got these
    threads。 How does it work？ We don't really know。 We know how to use them and we
    know how to use them efficiently。 That's that。 HTTP。 So this is what your last
    assignment。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 线程，类似的东西。记住，线程和进程是相似的。线程是轻量级的进程，但基本概念是一样的。你有这些线程。它是如何工作的？我们并不完全知道。我们知道如何使用它们，并且知道如何高效使用它们。就这样。HTTP。这就是你上次作业的内容。
- en: the proxy was all about and you HTTP defines how things。 get sent across the
    network and the various messages that it gets and that's abstracted， away again。
    You can， you generally with your web browser don't need to worry about get and
    post and。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代理就是这么回事，HTTP定义了东西是如何通过网络传输的，以及它所接收到的各种信息，这一切都被再次抽象化了。通常情况下，你在使用网页浏览器时，不需要担心get和post等问题。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_7.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_7.png)'
- en: that sort of thing。 Okay。 So that's abstraction。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这类事情。好了，这就是抽象。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_9.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_9.png)'
- en: Okay。 Modularity and layering。 So when you talk about modularity。 we're basically
    saying subdivide a larger system into， a bunch of smaller systems。 This is decomposition。
    You've been doing this since day one of one or six A or one or six B and it's
    important。 One of my favorite examples of a large system that's complex is believe
    it or not a Xerox， machine。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。模块化和分层。所以当你谈论模块化时，基本上是在说将一个较大的系统细分成多个较小的系统。这就是分解。你从106A或106B的第一天就开始做这件事了，这一点很重要。我最喜欢的复杂大型系统的一个例子，信不信由你，是复印机。
- en: So how do people use， everybody's used a Xerox machine before， right？ Well we
    have some in our。 in the CS department that are able to copy like hundreds of
    exams。 for like CS106B and CS106A and whatever and these machines are super duper
    complicated。 Right？
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么人们是如何使用的呢，大家都用过复印机，对吧？我们计算机科学系有一些复印机，能够复印成百上千份考试卷，比如CS106B和CS106A之类的，这些机器超级复杂，对吧？
- en: If you go and you think about what has to happen to make copies of pages in
    a certain， form。 it's pretty intense。 So for instance， okay。 Right？ So copy machines
    are supposed to like copy paper。 That's the big picture， right？ Purple paper。
    There you go。 So it's a copy paper and that's what they do。 But what else do they
    do？ Well。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去想一下，为了将页面复印成某种格式，必须发生什么事情，其实是相当复杂的。举个例子，好吗？对吧？复印机的作用就是复印纸张。这是大致的情况，对吧？紫色的纸。就这样。所以它们就是复印纸，这就是它们的功能。但它们还做什么呢？嗯。
- en: they handle double sided。 Right？ What does that actually mean？ Right？
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以处理双面复印，对吧？那实际上是什么意思呢？对吧？
- en: It means you either have to have a way to write on both sides of the paper，
    which is not really。 what happens generally。 That would be kind of weird especially
    because gravity might come into play a little bit。 But you also have to， or you
    have to flip the paper over and that's a mechanical engineering。 challenge。 Right？
    So you've got that in there。 These things sometimes staple。 Right？
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须有一种方法在纸的两面都写字，这通常并不会发生。那样做会有些奇怪，尤其是因为重力可能会起作用。但你也可以选择将纸翻过来，这就涉及到机械工程的挑战了。对吧？所以它也有这些功能。这些机器有时还会订书，对吧？
- en: Stapling involves getting the paper exactly right the place。 I mean， oh， by
    the way。 it also has collating。 Right？ Which is where you have to have like all
    the different stacks of the right thing。 How does collating work？ Well， if you
    have a 20 page exam。 like the CS110 exam might not be 20 pages， but let's， say
    you have a 20 page exam， right？ Well。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 装订涉及到把纸张放置得准确无误。我的意思是，哦，顺便说一下，它还需要进行整理，对吧？这就是你得把所有不同的堆叠整理到合适的位置。整理是怎么做的呢？好吧，如果你有一份20页的考试卷，像CS110的考试可能不止20页，但假设你有一份20页的考试卷，对吧？那么……
- en: they better be enough memory in your system to hold all 20 pages or some of
    the。 older machines had to refeed the paper every time it wanted to do a 20 page
    thing because。 they didn't have enough memory for that。 So that's a big thing
    because there's memory in there。 Let's see。 It's got networking associated with
    it if you can， like I can send a print job to the。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 系统得有足够的内存才能存储这20页，或者说，一些旧款复印机每次处理20页文档时都必须重新送纸，因为它们没有足够的内存来一次性处理这些。这个问题很重要，因为机器里面有内存。我们再看看，它还有与网络相关的功能，如果你想，像我可以把打印任务发送到……
- en: Xerox copy or that's it。 That's I can do that。 What else does it have？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 复印，或者说就这样。我能做到。那还有什么？
- en: There's also the whole physical layer or the actual physics that goes into it。
    Like。 you guys know how copyers actually work， like physically how they do it？
    Okay。 so there's a piece of paper that's black and oh by the way， there's also
    lasers， right？
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有整个物理层，或者说它背后的实际物理原理。你们知道复印机到底是怎么运作的吗？物理上它是怎么做到的？好吧，所以有一张黑色的纸，哦，顺便说一下，还有激光，对吧？
- en: There's a laser that's inside your copy machine， right？ And that's kind of cool。
    And actually the laser charges up your paper。 Let's say it's a negative charge。
    I don't know which charge。 It charges up the various dots on your paper where
    there's going to be a toner。 And then the rest of the copy machine takes the toner
    which is that powdery black horrible。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你复印机里面有一束激光，对吧？这挺酷的。实际上，激光会给纸充电。假设它是负电荷。我不知道是什么电荷。它会给纸上的各种点充电，接下来会有碳粉覆盖上去。然后复印机的其他部分会取用那个碳粉，就是那种黑色的、粉状的糟糕东西。
- en: stuff and it charges at the opposite charge。 And then it dumps a bunch of toner
    on the paper believe it or not。 And then it where it charges are there it sticks
    to it。 And then it sweeps off to excess， all right？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它会充电到相反的电荷，然后在纸上喷上大量的碳粉，信不信由你。接着它会把那些有电荷的地方吸附住。然后，它会把多余的碳粉扫掉，好吧？
- en: Actually， I think first it fuses it and then it sweeps off or maybe the other
    way around。 But it basically does that and then it sort of says there's a heating
    business in there。 and that's why it always comes out in one。 And my point is
    that these things are so complex that no one person in fact no ten people know。
    enough about the entire machine to be able to like fix it or do it all by themselves。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我认为它是先把纸张加热，再把碳粉扫掉，或者也许是相反的顺序。但基本上是这样操作的，然后它会做一个加热过程，这就是为什么复印出来的纸总是非常干燥的。而我的意思是，这些东西是如此复杂，没有一个人，实际上甚至没有十个人，能知道足够多关于整个机器的知识，能够独立修理或完全操作它。
- en: Or even understand it to be able to tell you all about all the details， right？
    There's physicists。 there's engineers， there's oh by the way， there's all the
    software。 You know how many different menus are on that thing， right？ There's
    so much software on there。 right？ Like has to do it all and get everything right
    and then there's mechanical engineering that。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至理解它，能够告诉你所有的细节，对吧？这里有物理学家，有工程师，还有，顺便提一下，还有所有的软件。你知道手机上有多少不同的菜单，对吧？上面有很多软件，对吧？就得做这些，确保一切都正确，然后还有机械工程。
- en: goes into it。 I mean there's so many people that work on that。 It has to be
    subdivided。 It's just way too big。 You would never have one person creating a
    Xerox machine by herself， right？
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后有很多工作。我的意思是，参与其中的人非常多，它必须被细分开来。实在是太庞大了。你绝不会让一个人单独做出一台复印机，对吧？
- en: It's impossible because one person can't do that。 So that's that。 Another good
    example is the phone in your pocket， right？ If you took 107E with me。 you remember
    we talked about like all the different sensors， that are on your phone， right？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这不可能，因为一个人做不到。就这样吧。另一个很好的例子是你口袋里的手机，对吧？如果你和我一起上过107E课，你还记得我们讨论过手机上的各种传感器，对吧？
- en: There's probably 15 different sensors on here。 Do you know there's four radios
    in your phone？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器上可能有15个不同的传感器。你知道你手机里有四个无线电吗？
- en: There's four different radios in your phone。 There's the one for the regular
    phone calls which isn't even the regular thing you do anymore。 That's like the
    least used thing you use your phone for anymore。 There's the Wi-Fi one。 There's
    a Bluetooth one。 There's， let's see， there's another one that communicates with
    the。 when you do Apple Pay， or whatever。 So I mean there's all sorts of radios
    in your phone。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的手机里有四种不同的无线电。一个是用来接打常规电话的，实际上这已经不是你最常做的事情了。现在你用手机的最少的功能就是打电话了。还有 Wi-Fi。还有蓝牙。再来，嗯，还有一个是用来进行
    Apple Pay 或其他操作时通讯的。所以，你的手机里有各种各样的无线电。
- en: There's cameras。 There's at least three different cameras。 There's a camera
    on the front。 There's a camera on the back。 There's a camera underneath the fingerprint
    thing。 If you've got that。 that's how that works， right？ Some ones have cameras
    built into the screen now。 I mean that's not even to mention there's a temperature
    sensor。 There's a drop sensor。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有摄像头。至少有三种不同的摄像头。有前置摄像头。后置摄像头。指纹传感器下方的摄像头。如果你有的话，就是这样工作的，对吧？现在一些设备的屏幕里也集成了摄像头。更不用说还有温度传感器、跌落传感器。
- en: There's an accelerometer。 There's a gyroscope， right？ Who knows， understands
    all those things？
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有加速度计。有陀螺仪，对吧？谁能理解这些所有的东西呢？
- en: Nobody understands every little bit about that， right？
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人能理解每个细节，对吧？
- en: There's specific engineers whose job is to do the gyroscope part of the iPhone
    and that's。 how it works， right？ But it's all about subdivision of this large
    system。 So you have to understand how that works if you're going to be building
    bigger projects， right？
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有专门的工程师负责 iPhone 中陀螺仪部分的工作，这就是它如何工作的，对吧？但这完全是一个大系统的细分。所以，如果你打算构建更大的项目，你必须理解这些是如何运作的，对吧？
- en: Now at the same time you might go to Apple and work on the iPhone and be like，
    "Oh， I'm。 the person who's doing the fingerprint sensor and whatever。"， And you're
    not the only one。 But you might feel like you're doing a very small part of a
    much bigger thing。 You have to keep that in mind that， "Oh， there is a bigger
    project here that ends up， being there。"。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你可能会去 Apple 工作，负责 iPhone 的工作，并且想，“哦，我是负责指纹传感器的那个。” 但你不是唯一的那个。你可能会觉得自己只是在做一个很小的部分，但你必须记住，“哦，确实有一个更大的项目在这里，它最终是完整的。”
- en: But that's where you have to understand。 This class hopefully gave you assignments
    that were somewhat robust and there were lots。 of moving parts and that's why
    there's 20 different header files and whatever because。 you have to kind of try
    to understand that。 And we don't make it too complex that you can't as one person
    understand it but we need to。 push that limit to say， "Oh， we better break these
    into various subsystems otherwise it's。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就是你必须理解的地方。希望这门课程给你的作业是有一定复杂度的，里面有很多移动的部分，这就是为什么会有 20 个不同的头文件之类的原因。你必须尝试去理解这一点。我们并没有让它变得过于复杂到一个人无法理解，但我们需要推动这个极限，说明
    "哦，我们最好把这些拆分成不同的子系统，否则就会变得无法管理"。
- en: not going to happen。"， Final systems。 Here's a good example of layering here
    where you've got lots of not necessarily modulating。 but you've got layering which
    is putting one layer on top of the other so that you break。 it down into its various
    components。 Remember for your assignment two there was this symbolic link where
    you didn't have to。 use symbolic links but you could read about those and learn
    about those。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这不可能发生。"，最终系统。这里有一个很好的分层示例，你可以看到，虽然不一定是调制，但你有分层，意思是把一层放在另一层上面，从而将它分解成不同的组件。记得在你的第二个作业里，有一个符号链接，你不一定非要使用符号链接，但你可以阅读并了解它们。
- en: There's an absolute path name which is like slash user slash class etc。 There's
    a path name layer which actually takes the which can take things like dot dot
    slash。 dot dot slash whatever and then layers it onto an actual thing there。 There's
    the file name layer which actually does the files for human reading that's where。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个绝对路径名称，比如 slash user slash class 等等。还有一个路径名称层，可以处理像 dot dot slash dot dot
    slash 这样的路径，并将其层叠到实际的东西上。还有一个文件名层，实际上是处理人类可读的文件，这是那里。
- en: you've got that layer。 Then you've got the i-node layer。 Remember each file
    has an i-node。 Why because computers are better at numbers than trying to figure
    out a whole like path。 is much slower to do that。 And then there's the file layer
    which is where like the bits themselves what they consist。 of on the drive like
    your actual files and then there's the block layer which is like。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你有了那一层。接下来是 i-node 层。记住每个文件都有一个 i-node。为什么呢？因为计算机在处理数字方面比处理整个路径要更高效。处理路径会慢得多。然后是文件层，它存储文件的实际内容，例如硬盘上的位数据，最后是块层，它指示它们在磁盘上的位置。
- en: where on the disk they are。 All of those different layers come together to make
    a file system and you have to at least。 understand parts of those layers or at
    least how your layer if you're working on one particular。 layer interacts with
    the next layer down。 Hopefully not more than a couple layers down but that's you
    have to understand that when。 you're doing that。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的层次汇聚在一起构成文件系统，而你必须至少了解这些层次中的一部分，或者至少了解你正在处理的特定层如何与下一个层交互。希望不会涉及太多层次，但你在工作时必须理解这一点。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_11.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_11.png)'
- en: Alright what else do we have on modularity and layering。 So this is one that
    we don't really go into this much detail maybe you probably do in。 a compiler
    class but I'm about to show you some layering that happens in g plus plus。 You
    know how you have your program and it turns it into a binary。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们关于模块化和分层还有什么要讲的呢？这是我们不太深入探讨的内容，可能你在编译器课上会更详细地讲解。但我现在要给你们展示一下 G++ 中发生的分层。你知道你的程序如何被转换成二进制。
- en: Well there's lots of steps in there。 It's not just like it just goes through
    once and turns everything straight into binary。 There's lots of different parts
    and we're going to see some of those parts in particular。 so that you can actually
    see what the compiler actually has to do。 First we're going to look at is the
    preprocessor。 So the preprocessor is one of the ones that all the pound includes
    or pound defines or。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其实这里面有很多步骤。它并不是一次就把所有东西直接转成二进制。其实有很多不同的部分，我们将会特别看看其中的一些部分，这样你就能看到编译器究竟需要做什么。我们首先来看预处理器。预处理器是所有包含和宏定义的处理者。
- en: as you yarkshows call hash includes or hash defines。 The preprocessors what
    takes those and manipulates them and changes those into something else。 that the
    next layer down can do。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你们展示的那样，包含（include）和宏定义（define）。预处理器会处理这些并将它们转化成其他东西，供下一级层次使用。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_13.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_13.png)'
- en: Let me show you what I'm talking about。 What we're going to do is we're going
    to go over and we're going to do a little program。 called hello。cc and it's going
    to be very simple。 It's going to be like day one of one or six be here。 I-O stream
    using namespace STD。 And then let's do a pound define because we've got two pound
    things here。 They include and then the pound define。 I'll talk this K range start
    100。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你们展示我在说什么。我们要做的是编写一个小程序，叫做 hello.cc，内容非常简单。就像是第一天的作业，使用 I/O 流并命名空间 STD。然后我们做一个宏定义，因为这里有两个宏，include
    和宏定义。接下来我会讲解，K 范围起始值是 100。
- en: And then it's main in to our C in a char star RV。 And then let's do that for
    int i equals K range start。 I is less than K range start plus 10。 I plus plus。
    And then in here we'll do see out hello world and then we'll actually do the I
    as well like。 that and that's it。 So pretty straightforward program。 Anybody see
    any bugs？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 main 函数，C 输入一个 char 指针 RV。接下来让我们做一个循环，i 从 K 范围起始值开始，i 小于 K 范围起始值加 10，每次增加
    1。在这里我们会输出“hello world”，并将 i 一起输出。就这样。这个程序很简单。有人发现什么 bug 吗？
- en: '![](img/1b246eaaae452a61678a9e11303b691a_15.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_15.png)'
- en: Okay。 What I'm going to do I'm actually not doing this on myth。 I'm actually
    doing this on my computer because I'm going to use a slightly different compiler。
    I'm going to use a compiler called clang which allows you to break out some of
    the details。 here that G plus plus for some reason doesn't let you you might be
    able to I couldn't figure。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我接下来做的事情实际上不是在 Myth 上进行的。我是在我的电脑上做，因为我要使用一个稍微不同的编译器。我将使用一个叫做 clang 的编译器，它允许你拆解一些细节，这是
    G++ 由于某些原因无法做到的，你可能能做到，但我搞不清楚。
- en: out the way to put in clang you'll see it。 So if we do the following clang dash
    E hello。cc。 Okay。 So let's do this first clang hello。cc - oh hello。 Make sure
    it works and if everything works right。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过clang执行，你会看到它的效果。如果我们执行以下命令`clang -E hello.cc`，好了，首先尝试执行`clang hello.cc -o
    hello`，确保它能够正常工作，如果一切正常。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_17.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_17.png)'
- en: Oh no。 Maybe any of you maybe need to do clang plus plus。 There we go that works
    so I guess clang plus plus work。 So if we do hello in this case right it will
    do that and that that's makes sense。 Okay。 That's what I'm going to do。 If we
    do let's try clang this time clang dash E hello。cpp。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不，也许你们中的某些人需要使用`clang++`。好了，这样可以正常工作，所以看起来是`clang++`起作用了。所以如果我们在这种情况下执行`hello`，它会执行，并且那样是有意义的。好了，我就这么做。如果我们尝试执行`clang`，这次执行`clang
    -E hello.cpp`。
- en: This is saying run the pre processor that's one of the deals with the pound
    and close and。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示运行预处理器，这是处理`#`和结束符号的一部分。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_19.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_19.png)'
- en: pound of funds。 Okay。 And why is this not working？
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一磅资金。好的，为什么这个不工作呢？
- en: '![](img/1b246eaaae452a61678a9e11303b691a_21.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_21.png)'
- en: Oh， CC that's why there we go。 There we go。 Okay。 So let's go and buy。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，CC，原来是这样。好了，明白了。那么我们继续吧。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_23.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_23.png)'
- en: Here's what it's actually doing。 Okay。 So what it's doing is it's taking a bunch
    of the well first of all it's taking the pound。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它实际做的事情。好吧，它实际上是做了什么？首先，它获取了一个`#`符号。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_25.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_25.png)'
- en: include and including it。 And guess what that pound include header file probably
    also has includes and it needs。 to include all those and it just basically creates
    one more file that it's all the stuff。 that you're about to process in one file。
    Okay。 And it does that。 In fact let's see how big just the pre processor creates
    word count 41，000 lines。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件，并将其包括在内。猜猜看，那个`#include`头文件也可能包含其他的文件，它需要将这些文件也包含进去，最终它会将所有这些内容合并成一个文件，基本上是将你即将处理的所有内容放到一个文件里。好的，它就这么做了。实际上，让我们看看预处理器生成的文件大小，字数大约41,000行。
- en: Comes out of our one hello world program just from taking that pre processor
    in there。 But let's take a look at without。 Hello。cc。 Let's take a look at it
    without the see out in there and without the just just look at。 what happens to
    the K range start in here。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果就是我们的一行“Hello World”程序，完全是通过将预处理器加进去的。不过让我们来看看没有`Hello.cc`的情况。我们来看看没有`cout`的代码，以及没有`cout`的情况下`K
    range start`会变成什么。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_27.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_27.png)'
- en: All right。 If we do the same thing again I don't 18 lines so that's much better。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果我们再做一次，结果是18行，明显好多了。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_29.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_29.png)'
- en: Okay。 So what we did this stuff at the top here is just it's other information
    that's going。 to be used by other stages of the compiler so file amounts and so
    forth。 And notice what it did with our pound define。 It took that K range start
    and replaced it with the 100 and it replaced the 100 here。 and that's all it did。
    Took whatever you define and just went through the entire program found where
    it was defined。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以我们做的这部分内容，其实是一些其他信息，会被编译器的其他阶段使用，比如文件数量等等。请注意它对我们的`#define`做了什么。它将`K range
    start`替换成了100，并且在这里也替换了100。就这么简单。它取了你定义的内容，遍历了整个程序，找到了定义的位置并做了替换。
- en: used and then replaced it。 It's all it does。 It doesn't do anything else in
    this case。 It might do it might actually do a little bit of replacing a variables
    if you if you set。 it up that way。 But that's it。 So that's the pre processor
    does and that's the first stage。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并替换它，这就是预处理器的作用，它不会做其他的事情。在某些情况下，如果你做了适当的设置，它可能会替换一些变量，但就这么多。这就是预处理器的作用，也是它的第一阶段。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_31.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_31.png)'
- en: Okay。 The next stage is called the Lexer and the Lexer is what takes the translation
    of a stream。 of tokens。 Right。 It takes all those the program and turns it into
    individual tokens of what's happening。 in your program。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。下一阶段称为词法分析器（Lexer），它负责将一个令牌流的翻译结果提取出来。对了，它会将程序中的内容转换为一个个独立的令牌，表示程序中发生的事情。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_33.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_33.png)'
- en: Okay。 Let me show you what I mean by that。 Okay。 If we do the let's do let's
    go back and make it the original one again。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我来展示一下我的意思。如果我们重新回到最初的代码。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_35.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_35.png)'
- en: So we'll do that and we'll put this back just so we can see the original again。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们来做这个，然后把它放回去，这样我们就能再次看到原始内容。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_37.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_37.png)'
- en: Okay。 And let's do this。 If you dash clang dash X clang dash dump tokens and
    hello。cc。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们来做这个。如果你使用`dash clang dash X clang dash dump tokens`命令，然后加上`hello.cc`。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_39.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_39.png)'
- en: What it actually does is it actually puts the output for some reason standard
    error。 So I'm going to actually pipe or redirect standard error to standard out
    which you may。 or may not know that you can do it but you can't and this you should
    use the two angle。 bracket ampersand one。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上做的事情是，它出于某种原因将输出放到了标准错误流。所以我将实际上将标准错误流管道或重定向到标准输出流，你可能知道或不知道你可以这样做，但你可以，这时你应该使用两个尖括号`&1`。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_41.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_41.png)'
- en: There it is。 And then we're going to look at it and here's what comes out。 Okay。
    So what is it done here？ It is taken a type death called type death in this case
    and there's a type death in there。 that it actually created。 And let's see。 There
    was a char 16t in there that it created and more type deaths。 You know what？ This
    is actually now they look at it。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。然后我们要查看它，看看输出是什么。好的。那么这里做了什么？它采取了一个称为“类型死亡”的类型，在这种情况下，它里面有一个类型死亡。它实际上创建了它。让我们看看。里面有一个`char
    16t`，它创建了它，还有更多的类型死亡。你知道吗？实际上现在他们看它时是这样的。
- en: This is just the this is all the included file in here。 So let's get rid of
    that again and you'll see what it looks like with just the part of。 the program
    that we have and you'll see how it actually。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是所有包含的文件。所以我们再把它去掉，你将看到它只显示程序的一部分，看看它是如何实际工作的。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_43.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_43.png)'
- en: Let's see。 There we go。 Let's try this again。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。好了。我们再试一次。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_45.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_45.png)'
- en: There we go。 Okay。 Here we go。 So here's what it did。 It had to find our inch。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。好的。现在我们来看一下它做了什么。它必须找到我们的`inch`。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_47.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_47.png)'
- en: Remember we said that for loop in there。 What it did was it said if I was an
    int here and it found main and this is for the int return。 value for main and
    then it found main in here and it says that's an identifier main and。 the program
    is going to be look the compiler can be looking for main。 Oh， guess what？
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们说过那里的`for`循环吗？它做的是，如果我是`int`，然后它找到了`main`，这是`int`的返回值，然后它在这里找到了`main`，它说这是一个标识符`main`，并且程序——编译器正在寻找`main`。哦，猜猜看？
- en: It found a left parentheses。 This is the main。 Remember it's like int main parentheses。
    Well。 that's the parentheses there and it calls it a left parent and it's taking
    it down。 to that level where it found each individual token and does that。 There's
    another int in there。 There's an Rc variable。 There's a comma。 You probably never
    thought about oh。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它找到了一个左括号。这是主函数。记住，它就像`int main()`，对吧？那个括号就是这里，它把它称为“左括号”，并且将它分解到这个层次，找到了每一个独立的标记。就这样。里面还有另一个`int`。还有一个`Rc`变量。还有一个逗号。你可能从来没有想过，哦。
- en: we have to deal with all this。 If you're writing a programming language that
    comma means something。 That parenthesis means something。 Well， it's just another
    token that gets taken into the thing。 We have some left some brackets in here
    for charge to our RV。 Let's see what else we have。 Let's see if I can get some
    more there。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理这些。如果你在编写一种编程语言，逗号意味着某种东西，括号也意味着某种东西。那么，它就是一个被当作标记处理的符号。我们在这里有一些括号，表示对`RV`的调用。让我们看看还有什么。再看看能不能找出更多的。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_49.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_49.png)'
- en: Let's see。 Can we find any of the ones we had here？ Here's our identifier I
    that we put in there。 It has that in there。 There's the plus plus。 It actually
    calls it plus plus。 It does it。 So this is part of this by the way is so that
    it can do much more translation than some。 other compilers。 It breaks it down
    to this level。 But it does need to tokenize it。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看。我们能找到这里的任何一个吗？这是我们放进去的标识符`I`。它里面有这个。这里是`++`。它实际上称之为`++`。它做到了。所以这实际上是这个的一部分，顺便说一下，这样做是为了让它能够进行比一些其他编译器更多的翻译。它把它分解到这个层次。但它确实需要进行标记化处理。
- en: That's a layering sort of idea。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种分层的思路。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_51.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_51.png)'
- en: Then after we go through the Lexer which gets all those tokens， then it goes
    into a more。 interesting part。 So far this is like oh， that's just translation。
    That's not too bad。 Then it goes into this one called a parser。 A parser is now
    looking at syntax。 And parser says oh。 let's break these tokens into syntactically
    valid constructs。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们通过了词法分析器（Lexer），它获取了所有这些词法单元之后，它进入了一个更有趣的部分。到目前为止，这看起来像是翻译而已。并不算太难。接着进入了一个叫做解析器（parser）的部分。解析器现在正在查看语法。解析器说，哦，来吧，让我们把这些词法单元分解成语法上有效的结构。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_53.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_53.png)'
- en: Let's see what we do that。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是怎么做的。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_55.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_55.png)'
- en: This one is also exclaiming again。 This one is AST dump like this。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个也是在再次感叹。这个是AST转储，像这样。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_57.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_57.png)'
- en: AST dump like that。 And now it actually is creating a little tree。 We call this
    an abstract syntax tree that actually has all different parts in there。 So let's
    see if we can find something in here that we've done here。 Here we go。 So remember
    we have a four statement in there。 Well。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的AST转储。现在它实际上正在创建一颗小树。我们称之为抽象语法树（abstract syntax tree），它实际上包含了不同的部分。让我们看看是否可以在这里找到我们已经做过的部分。这里来看看。记得我们在这里有一个四个语句。嗯。
- en: the four statement is made up of a compound statement。 A compound statement
    up here let's say。 And then you've got a four statement and then a declarative
    statement in there which is like。 the individual parts of the four loop。 Let's
    see we've got an int。 And there's our 100 for our integer that we had the constant
    in there。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 四个语句由一个复合语句组成。假设这上面是一个复合语句。然后你有一个四个语句，再加上一个声明语句，类似于四个循环的各个部分。我们来看一下，我们有一个int类型的变量。然后我们有100作为我们整数的常量。
- en: We've got to have a bool because there's a less than calculation in there。 So
    there's a boolean value that's going on when we're doing that。 We've got another
    int in there for probably the next part of the four loop。 Let's see we've got
    the 10 in there for the plus。 We're going to have a plus in there which is our
    binary operator。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须有一个布尔值（bool），因为这里有一个小于运算（less than calculation）。所以在我们做这个运算时，就会有一个布尔值。我们还得有另一个整数类型（int），可能是四个循环的下一个部分。再看一下，我们在加法操作中用了10。所以这里将会有一个加号（plus），这是我们用的二元运算符。
- en: So all these things somebody to think about how does the C++ language turn into
    this abstract。 syntax tree。 And when you build computer languages you don't necessarily
    have to think about this。 on some level。 But there are tools that do a lot of
    this for you as well。 And then you can see there's the post fix again and plus
    plus and so forth。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些东西得有人考虑，C++语言是如何转变成这个抽象语法树的。在构建计算机语言时，你不一定非得考虑这些问题。某些程度上，你不必自己思考这个，但也有工具可以帮你做很多这种工作。然后你可以看到那是后缀操作符，再加上++等。
- en: So that's how you end up with the parsing part of it which is actually a very
    interesting。 part of computer programming language design。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是你最终得到的解析部分，它实际上是计算机编程语言设计中一个非常有趣的部分。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_59.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_59.png)'
- en: Okay。 Let's see。 There are a couple more parts here。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看一下。这儿还有几个部分。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_61.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_61.png)'
- en: There is the semantic analyzer。 Okay。 The semantic analyzer part is right here。
    That's the part that takes all those syntactically valid constructs and says does
    this actually。 work in C++？ Like so far it's taken it and saying okay this maps
    this little part of the tree and。 then it goes oh now I'm going to see if this
    works with a type system and if you can， so。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是语义分析器。好的，语义分析器部分就在这里。它是那个部分，它接受所有那些语法上有效的结构，检查这些在C++中是否有效。到目前为止，它已将这部分映射到语法树中，然后它会说，现在我要检查它是否符合类型系统，如果可以的话，继续进行。
- en: you're going to have to eventually put out assembly code so it needs to do that。
    Unfortunately。 Klein doesn't show you the semantic analyzer part so that's that。
    But finally there's a code gen part which is what you may have or what you would
    have。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终还是得输出汇编代码，所以它需要执行这个操作。不幸的是，Klein没有展示语义分析器部分，所以就到这里吧。但最终有一个代码生成部分，这就是你可能会有的，或者你会有的部分。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_63.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_63.png)'
- en: thought about in CS107 which hopefully isn't bringing back bad memories。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在CS107中考虑过的内容，希望这不会勾起不好的回忆。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_65.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_65.png)'
- en: But if we do the same sort of thing now instead of AST dump now we just want
    to do， I think。 it's dash S actually。 So if we do， let's not do the X claim to
    our clang。 I'll do plus plus again plus plus。 Hello， we'll do dash S。 Hello。cc。
    Let's see if there we go and then yeah there we go。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们现在做同样的事情，而不是做 AST 转储（dump），我们只需要做，我想是 dash S。实际上是 dash S。所以如果我们这样做，我们就不再做
    X 声明给 clang。我会再次做加号加号。你好，我们来做 dash S。Hello.cc。我们来看看，应该可以了，是的，可以了。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_67.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_67.png)'
- en: Hello。S。 Well here's all your assembly language that came out。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，S。那么这里是所有的汇编语言输出。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_69.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_69.png)'
- en: Right and that's the final part is generating a similar。 What's cool about clang
    is it actually tries to comment its code。 It's kind of neat。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对，这就是最后一个部分，就是生成一个相似的代码。clang 很酷的一点是，它实际上会尝试为代码添加注释。真是很棒。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_71.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_71.png)'
- en: You know it's nice for them to do this。 It talks about the interludes and so
    forth。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，他们做这些事情真不错。它谈到了插曲等内容。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_73.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_73.png)'
- en: Another interesting thing about this。 So let's look up， let's do this。 Let me
    recompile this using the big， by the way， let's see how long is this。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个，还有一个有趣的事情。我们来看看，做一下这个。让我重新编译一下这个，顺便说一下，我们来看看它有多长。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_75.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_75.png)'
- en: This one is 923 bytes。 If we put back in the two parts here just actually do
    the printing。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是 923 字节。如果我们把这里的两个部分放回去，实际上是做打印。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_77.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_77.png)'
- en: Let's see， there we go and now it is how big。 It's now 49 kilobytes。 Right so
    it changes a little bit when you have to all of a sudden print something out。
    Right there's a lot more going on here。 But let's look for the C out function
    for instance。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看，现在它有多大？现在是 49 千字节。对，当你突然需要输出某些内容时，文件大小会有点变化。对，这里发生了更多的事情。但让我们看看 C 输出函数，比如说。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_79.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_79.png)'
- en: There's our C out function。 Now notice something interesting about it。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 C 输出函数。现在注意到一些有趣的地方。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_81.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_81.png)'
- en: It's not a good color。 Notice something interesting about the C out function。
    It's got all this garbage around it。 Like underscore in record ZNST3。 You didn't
    see that when you saw your functions in C code for an assembly or whatever。 The
    reason is because C++ allows you to overload functions。 Right？ So you can't have
    just one C out。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它的颜色不好。注意到 C 输出函数的一些有趣的地方吗？它周围有很多垃圾字符，比如记录中的下划线 ZNST3。你在 C 代码的函数中或者汇编中是看不到这些的。原因是因为
    C++ 允许函数重载。对吧？所以你不能只有一个 C 输出函数。
- en: You can have 10 C outs that all have different parameters and things。 So what
    it needs to do is it needs to do what's called name mangling。 And it actually
    mangles the name and keeps track of it of course。 But it mangles the name so if
    you had two different or 10 different C outs it would know which。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有 10 个不同参数的 C 输出。所以它需要做的就是进行所谓的名称修饰（name mangling）。它实际上会修改名称并跟踪它。当然，它会修改名称，这样如果你有两个不同的，或者
    10 个不同的 C 输出，它就知道是哪一个。
- en: one you call and you can't do that in C。 It's one of the reasons we do 107 in
    C instead of C++ because it can't do that。 It doesn't do this and it's much easier
    to read this sort of code。 So that's one thing you can look at in there。 So there
    you go。 That's the different parts of the compiler。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用一次，在 C 语言中是做不到的。这也是我们在 C 中做 107 而不是在 C++ 中做的原因，因为它做不到这一点。它不做这个，而且这种代码更容易阅读。所以这是你可以在其中看到的一个方面。好了，编译器的不同部分就是这些。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_83.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_83.png)'
- en: Okay？ So you have all these different parts that happen and it's all about layering
    and it。 does one thing at a time and does multiple passes across the code that
    you can then use。 Okay？
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？所以你有这些不同的部分，这一切都涉及到层次化处理。它一次做一件事，并对代码进行多次遍历，最终你可以使用它。好吗？
- en: Then uses to actually build your assembly code。 It's kind of amazing to me that
    compilers go as fast as they do。 I mean your computer is already fast but making
    them go fast enough to compiler code。 just like that and when you think about
    all these different things that happen。 Oh and by the way that didn't even talk
    about compiling with -03 in there or some other one。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器使用它来构建你的汇编代码。对我来说，编译器能这么快实在是令人惊讶。我的意思是，你的计算机本身已经很快了，但要让它足够快去编译代码，就像那样。而当你想到所有这些不同的事情时。哦，顺便说一下，我还没有提到使用`-03`编译或其他某些选项。
- en: If we had taken out the C out statement again and did 03 you would have had
    like a 20 byte。 file because it would have optimized everything out because nothing
    actually got printed。 So all that optimization takes more time and so forth。 And
    if you take a compiler's class you'll learn this。 Compiling time is not really
    that important。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次去掉了`C out`语句并执行了03，你会得到一个大约20字节的文件，因为它会优化掉一切，因为实际上没有任何内容被打印出来。所以所有这些优化反而需要更多时间，等等。如果你参加编译器课程，你会学到这一点。编译时间其实并不是那么重要。
- en: It's your runtime that becomes more important。 So it does take more time to
    compile something that's actually okay。 Now you do have to worry about programmer
    efficiency and you can't take days to compile。 things or hours like it used to
    but it doesn't matter if it's a little longer to compile as。 long as it optimizes
    to make your program actually faster。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是你的运行时变得更重要了。所以确实需要更多时间来编译某些东西，这也没关系。现在你必须关注程序员的效率，不能像以前那样花几天或几小时编译。但如果编译时间稍长也没关系，只要它能优化并让你的程序更快。
- en: If you only have to compile once you run it a million times。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要编译一次，你就可以运行它一百万次。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_85.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_85.png)'
- en: So that's how that works。 Okay。 What else are we going to talk about？ Computer
    networks。 So that's a layers。 Right？ There's tons of layers in your computer networks
    here。 Okay？
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是它的工作原理。明白了吗？我们还要谈些什么？计算机网络。这里有许多层，对吧？在你的计算机网络中有很多层。明白了吗？
- en: There's the TCP/IP layer， right？ Which is the data of how packets get transmitted
    back and forth。 I talked about this the other day where it's the TCP layer that
    says， "Oh， here's your。 packets in a particular or in what order？ Like zero through
    a hundred packets。"。 And it's that layer that on the other side gets the packet
    and then says， "Oh， I've got， the packet。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有TCP/IP层，对吧？它是数据包来回传输的方式。我前几天讲过这个，TCP层会说：“哦，这里是你的数据包，按特定顺序传送，像是从零到一百个数据包。”就是这个层在另一端接收到数据包，然后说：“哦，我收到了数据包。”
- en: I've got packet seven。 I'm going to send an acknowledgement for packet seven
    back to the original calling。 the， computer that sent me the packet。"， And so
    forth。 So that's what the TCP layer does。 Okay？
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我有了第七个数据包。我要向原始调用的计算机发送一个对第七个数据包的确认信息，"计算机发送了给我这个数据包。"等等。所以这就是TCP层所做的工作。明白了吗？
- en: But there's all these other layers in here as well。 There's the application
    layer which is what you were you writing your application when。 using these sorts
    of things。 There's the transport layer which is where the TCP happens。 There's
    the network layer。 The network layer is the part where it says， "Okay。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里也有其他的层。比如应用层，这是你在编写应用程序时所用的那些层。还有传输层，这是TCP发生的地方。再就是网络层。网络层就是它说：“好吧。”
- en: I want to send my packet to a particular， computer。 but first it needs to go
    through the next closest router， like the one that's。 in the ceiling or whatever
    for your Wi-Fi packets and so forth。 Okay？ In fact。 let's take a look at how you
    might figure that out or how you might do a little。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我想把我的数据包发送到一台特定的计算机，但首先它需要经过下一个最接近的路由器，比如天花板上的那个，或者用于Wi-Fi数据包的路由器，等等。明白了吗？事实上，让我们看看你如何找出这一点，或者你如何做一些事情。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_87.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_87.png)'
- en: analysis there。 There is a command which is Traceroot。 Did I show you Traceroot
    before？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里进行分析。有一个命令叫做Traceroot。我之前给你们演示过Traceroot吗？
- en: I didn't even smart class。 Traceroot。 If you took 106B with me， you would have
    seen this。 Traceroot is a way to find out all the different paths that your or
    the different path， one。 particular path let's say that your packets might go
    through。 So I happen to find a engineering。new university of New South Wales in
    Australia， edu。au。 If we try to trace the packets here， "Oh no。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至没上过聪明的课。Traceroute。如果你和我一起上过 106B 课程，你就会见过这个。Traceroute 是一种方法，用来找出你的数据包可能经过的所有不同路径，或者说，特定路径。比如，我偶然发现了澳大利亚新南威尔士大学的工程网站
    edu.au。如果我们试图追踪这些数据包，“哦，不行。”
- en: it's not going to let me。"， This happened earlier when I tried this at my desk。
    Sometimes it fails and it won't let you。 So I think， let's see， there we go。 I
    did do it earlier just in case this would happen。 So let's pretend that didn't
    fail。 You have to be prepared。 So what it did was it actually， if it worked。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会让我连接。”我在我办公桌上试过这个时也发生过这种情况。有时它会失败，无法让你连接。所以我想，看看，行了。我之前确实做过这个，以防万一发生这种情况。所以我们假装它没失败。你必须做好准备。所以它实际上是这样做的，如果它成功的话。
- en: it would have shown you all these different， routes here， which basically says，
    "My computer。 which is 10。34。160。2， needs to go to， or I guess， that might be
    the router actually。 My computer might first go to the router。"， And then it goes
    to something at S soonet。 which is still on Stanford。 Then it goes to another
    171， which is still at Stanford。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它本应向你展示所有这些不同的路由，基本上是说，“我的电脑，IP 地址是 10.34.160.2，需要连接到，或者我猜，实际上应该是路由器。我的电脑可能首先会连接到路由器。”然后它会连接到
    S soonet，那仍然是在斯坦福大学。接着它会连接到另一个 171，仍然是在斯坦福大学。
- en: Then it goes to another soonet， which is still at Stanford。 It takes four hops
    just to get off the Stanford campus if it's trying to go to Australia。 Why？
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它连接到另一个 soonet，仍然是在斯坦福大学。仅仅要从斯坦福大学校园出去，它就需要四次跳跃，如果它要去澳大利亚。为什么？
- en: Because we have a lot of computers on here and a lot of different ways you need
    to go through。 a lot of steps just to get out of your local network。 Probably
    that is because we have not enough IP addresses to go around。 Then it goes to
    this thing called scenic， which is a， I believe that's something to do。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们这里有很多计算机，而且有很多不同的路径需要通过。仅仅要离开本地网络就需要经过很多步骤。可能是因为我们没有足够的 IP 地址可以使用。接着它会连接到一个叫做
    scenic 的东西，我相信它与某些事情有关。
- en: with the universities in the Bay Area and kind of the North， the Pacific， Northwest
    Pacific。 somewhere。 Then it has to get to Australia。 So it goes to this place
    called Pacific Wave。 which is a， which is a ISP or a router that， basically sends
    things across the ocean。 And you can actually see， if you go， let's see if I still
    have this up here， there we go。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与湾区的大学以及北太平洋、太平洋西北部的一些地方连接。然后它必须到达澳大利亚。于是它连接到一个叫做 Pacific Wave 的地方，这是一家 ISP
    或路由器，基本上是把信息传送到大洋彼岸。如果你去看，看看我是不是还打开了这个页面，来看看。
- en: You can actually see all the different submarine cables that are around。 You
    might ask， so wait。 why don't the， I always thought these like signals to go to
    Australia。 would go through like satellites and things， right？ Sometimes they
    do。 but it turns out it's much faster to go through the underwater， believe， it
    or not。 Any ideas why？
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以看到周围所有不同的海底电缆。你可能会问，那么等等，我一直以为这些信号去澳大利亚的应该通过卫星之类的东西，对吧？有时确实是这样的，但事实证明通过水下电缆要快得多，不管你信不信。你知道为什么吗？
- en: Actually， the radio waves are actually faster in the air than in underwater
    cables。 Any ideas why？
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，电波在空气中的传播速度比在水下电缆中快。你知道为什么吗？
- en: How far away are geosynchronous satellites？ Anybody have any idea？ How many？
    22，000 miles away。 It takes about an eighth of a second for light to go 22，000
    miles up to the satellite。 And then another eighth of a second to go 22，000 miles
    back。 That's a quarter of a second delay。 And if you've ever called anybody， let's
    say in Australia and did get on a satellite connection。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静止轨道卫星离得有多远？有人知道吗？大约 22,000 英里远。光从地面到卫星需要大约八分之一秒的时间。然后再花八分之一秒的时间返回地面。这样就会有四分之一秒的延迟。如果你曾经打过电话，假设是打到澳大利亚并通过卫星连接。
- en: there's a big delay there because it takes that much time to do it versus the
    8，000 miles。 one direction to get from like here to Australia or 10，000 miles。
    Much less time over the network。 But anyway， you can see， you can actually play
    around with this map and zoom in and zoom。 out and whatever and see all the different
    various connectors。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有很大的延迟，因为完成这项工作需要这么长时间，而从这里到澳大利亚单程是 8,000 英里，或 10,000 英里。通过网络传输要少得多的时间。但无论如何，你可以看到，实际上你可以玩弄这个地图，进行缩放，查看所有不同的连接器。
- en: Air water cables are kind of cool in that they spool the model。 These giant
    spools。 they just have a boat driving along， spooling out the cable。 And every
    so often。 then they have to splice the cables together and run out of the spool。
    And they do that for thousands of miles across the ocean and it just sinks to
    the bottom。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 空中水下电缆有点酷，它们会把模型卷成大卷。这些巨大的卷筒。它们只是让一艘船沿着电缆走，然后卷出电缆。每隔一段时间，它们就得把电缆接起来，然后继续从卷筒里放出。它们为此在海洋中铺设了成千上万英里的电缆，最后它们就沉入海底。
- en: Sharks really like these cables too。 They can actually sense the electricity
    kind of going through them。 So they bite them a lot。 They have to break。 They
    break a lot。 So they have to deal with that too and they make them think of whatever。
    Chase。 How do they retrieve the cables？ Yeah， when a shark bites it and like splits
    it。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 鲨鱼也很喜欢这些电缆。它们实际上可以感知电流通过电缆的情况。所以它们经常咬这些电缆。电缆必须断裂。它们经常断裂。所以它们也必须应对这个问题，它们会让它们去想办法。追逐。它们是怎么取回这些电缆的？是的，当鲨鱼咬住电缆并把它撕裂时。
- en: they have a big hook that they know where， it is basically with GPS's over。
    And they have a hook that they go along until they hook it and then they reel
    it up。 So yeah。 I don't know what it does to all the wildlife in the bottom。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有一个大钩子，通过 GPS 定位确定位置。然后它们沿着电缆走，直到勾住电缆，然后把电缆拉上来。所以是的。我不知道这对海底的所有野生动物有什么影响。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_89.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_89.png)'
- en: But it's a yeah。 I think the different colors just mean。 I don't actually know
    what the different colors mean。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是是的，我认为不同的颜色只是代表不同的意思。我其实不知道不同的颜色意味着什么。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_91.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_91.png)'
- en: Good question。 It might be different。 It might be different companies that run
    them。 It might be a little bit。 Well， they are specific cables。 but like there's
    a bunch of gray ones here and I don't know， what the gray ones are。 I don't know
    what they are。 Yeah， the military。 Yeah， maybe that's it。 But anyway。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。可能会有不同的情况。可能是不同的公司在管理这些电缆。可能会有一点不同。嗯，这些是专用电缆。但是这里有一堆灰色的电缆，我不清楚这些灰色的是什么。我不知道它们是什么。是的，可能是军用的。对，也许就是这样。但无论如何。
- en: there are lots of cables around the world that because there are lots of people。
    communicating and that's the way it goes。 But anyway， that's another layer。 You
    need to go through the network layer that sends these。 And this would then be
    the physical layer， by the way。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上有很多电缆，因为有很多人在进行通信，这就是它们的工作方式。但无论如何，那是另一个层。你需要经过网络层来发送这些电缆。顺便提一下，这将是物理层。
- en: That's another layer that these things go through。 So another layer that we
    talked about。 I guess you don't put the layer。 There's the link layer， which basically
    is， let's see。 the link layer I think is between， the， I guess the network layers
    between the computer and the next router。 The link layer might be either internal
    to the router or not a guy at the show。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是这些电缆所经过的一个层。所以这是我们刚才谈到的另一个层。我猜您并没有加这个层。链接层基本上就是，我想链接层是在计算机和下一个路由器之间。链接层可能位于路由器内部，或者不在展示中。
- en: I'll have to look that on that。 But you can look up more different types of
    layers there。 We generally use the application layer， right？ When you do socket
    and bind and all those things。 that's generally the application layer that， we
    need to deal with。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我得查一下这个。但你可以查看其他不同类型的层。我们通常使用应用层，对吧？当你进行套接字操作、绑定以及其他这些操作时，通常是需要处理的应用层。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_93.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_93.png)'
- en: Take a networking flash and go a couple more layers down。 Okay， 144。 What do
    you might want to do that？
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 进行一次网络闪存，继续往下走几层。好，144。你可能想做这个吗？
- en: '![](img/1b246eaaae452a61678a9e11303b691a_95.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_95.png)'
- en: Okay， what else？ The naming and name resolution。 Here's another one。 So we've
    already seen some of this about a file system， file system examples。 We've said，
    you know。 we've talked about absolute and relative path names and whether or not，
    humans like， Google。com and computers like 74， et cetera。 We've done that。 URLs
    are also human readable。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，还有什么呢？命名和名称解析。这里有另一个例子。我们已经看到了一些关于文件系统的内容，文件系统示例。我们说过，我们谈到了绝对路径和相对路径名，以及人类喜欢的像是
    Google.com 和计算机喜欢的像 74 等等。我们已经做了这些。URL 也是人类可读的。
- en: Remember URLs can map to IP addresses with a file path name as well。 Okay， so
    there's that in there。 File descriptors。 A file descriptor is just a number， right？
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，URL 也可以映射到 IP 地址以及文件路径名。好的，这里有这个。文件描述符。文件描述符就是一个数字，对吧？
- en: But that number goes to a file descriptor table， which has all the other details
    and that's， that。 There's two different places where you can see naming and name
    resolution that you will。 see as you build more bigger programs。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是那个数字会指向文件描述符表，里面包含了所有其他的细节，就是这样。有两个不同的地方，你会看到命名和名称解析，当你编写更大的程序时，你会遇到。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_97.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_97.png)'
- en: Let's see， caching。 So here's a topic that I was actually a little surprised。
    This topic wasn't covered in as much detail in 110。 I believe it's covered in
    more detail and correct me if I'm wrong， but people have taken， EEE 180。 Is anybody
    taking EEE 180？ Nobody has。 I think EEE 180 covers the caching in more detail。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看看缓存。这里有一个话题，实际上我有点惊讶这个话题在 110 课程中没有详细覆盖。我相信它在其他地方有更详细的讲解，如果我错了，请纠正我，但有些人已经选修了
    EEE 180。有人选修 EEE 180 吗？没有人选吗？我觉得 EEE 180 更详细地讲解了缓存。
- en: But I wanted to spend 10 or so minutes talking about caching。 This is what I
    would have covered if I was designing this course from scratch。 I would probably
    cover this in a little more detail。 Here's how memory works on your computer。
    You have main memory in your computer and it's a lot， right？
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但我想花大约 10 分钟时间来讲解缓存。如果我是从头设计这门课程，我会更详细地讲解这个内容。你计算机的内存是如何工作的呢？你计算机中的主内存是非常庞大的，对吧？
- en: It's normally like 8 gigabytes or sometimes 16 or 32 gigabytes of main memory。
    It's memory that is random access and goes away when you're computerized。 There's
    also， by the way。 the hard drive or SSD。 That doesn't go away。 It's super slow。
    It's also much， much bigger。 A terabyte or many， many hundreds of gigabytes。 But
    there's main memory， which is the RAM。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，主内存是 8GB，或者有时是 16GB 或 32GB。它是随机访问内存，计算机化后会消失。顺便说一下，还有硬盘或 SSD。那是不会消失的。它非常慢，但也大得多，可能有一个
    TB 或者几百 GB。但主内存是 RAM。
- en: Your computer also has these various caches。 So you might have a cache called
    an L2 cache。 You might have an L4 cache， an L3 cache， an L2 cache， and then an
    L1 cache， let's say。 And each one of these caches is smaller and smaller in amount
    of memory but also faster。 than the previous level。 What makes an L2 cache faster
    than main memory？ Number one。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机也有这些各种缓存。所以你可能有一个叫做 L2 缓存的缓存，你可能还有 L4 缓存、L3 缓存、L2 缓存，再到 L1 缓存，假设是这样。每一个缓存的内存量都越来越小，但也比前一级缓存更快。那是什么让
    L2 缓存比主内存更快？第一点。
- en: it's generally built right on the chip itself， like on the processor chip， itself。
    So it's close to end of wires or really close to each other and it doesn't need
    to go to。 some other bucks and so forth。 L1 is another one that's maybe built
    with also basically on the chip and also uses a。 different technology， maybe to
    make it even smaller or even faster but it takes up more。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常直接内建在芯片上，比如处理器芯片上。所以它很接近线缆末端，或者非常接近彼此，并且不需要去其他地方。L1 缓存是另一种可能直接内建在芯片上的，它可能采用不同的技术，甚至更小或者更快，但它占用的空间更多。
- en: space maybe or something like that。 And then finally you have the register file
    which you've done in 107 or 107E which is super。 super fast memory but you have
    32 registers or something like that。 In fact there's more on different processors
    but some very small amount。 You might have something like， I don't know， 8 kilobytes
    or maybe 128 kilobytes of L1 and。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是空间之类的。最后，你还有寄存器文件，这是你在 107 或 107E 课程中学过的，它是非常非常快的内存，但你只有大约 32 个寄存器，或者类似的数量。事实上，不同的处理器上可能有更多，但也只是非常少的数量。你可能会有
    8KB 或许 128KB 的 L1 缓存之类的。
- en: 256 kilobytes of L2 etc。 What these are therefore is when you're requesting
    data。 you generally request data often， the， same data sometimes many times。 If
    you have a variable I that you're looping over， right？ If you're looping over
    100。000 times you're going to access that variable 100，000 times。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 256千字节的L2缓存等。这些实际上是当你请求数据时的情况。通常你会频繁地请求数据，有时还会多次请求相同的数据。如果你有一个变量I，你在循环处理，明白吗？如果你循环了100,000次，你将访问这个变量100,000次。
- en: So you might want to keep it in a register or keep it in an L1 cache somewhere
    where it's。 going to be really fast to access because you don't want to have to
    go to main memory。 and go look for it。 Here's the difference between main memory
    and the registers。 There's a good analogy about this。 Main memory， let's do it
    this way。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能想将它保存在寄存器中，或者将它保存在L1缓存中，这样访问速度会非常快，因为你不想去主内存中找它。这里是主内存和寄存器之间的区别。有一个很好的类比。主内存，我们这样做。
- en: Let's say that registers is like if I had this pen and let's say this is a register。
    I have the pen sitting here and I want to write something。 Going to a register
    I have to pick up the pen and I have to write something and then I。 put the pen
    down。 Going to the L1 cache， it might be like the pen is way over here on the
    table。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设寄存器就像我拿着这支笔，假设这支笔是一个寄存器。我把笔放在这里，我想写东西。去寄存器时，我必须拿起笔，然后写下东西，再把笔放下。去L1缓存时，可能就像笔放在桌子上很远的地方。
- en: In order to go to the L1 cache I have to go over and hit the pen and then come
    back and。 have to write it down。 That's how much slower the L1 is。 L2 might be
    the pen isn't on the table。 it's over in gates or something。 I have to go back
    to my office。 I have to go to the pen and I have to come back。 That's how much
    the floor is for L2。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要去L1缓存，我必须走过去拿起笔，然后回来，写下内容。这就是L1缓存的速度慢的原因。L2缓存可能就像是笔不在桌子上，而是在某个地方。我得回到办公室，去拿笔，再回去。这就是L2缓存的速度慢的程度。
- en: Main memory would be like let's see the data is in San Francisco and I have
    to walk there。 to get the data。 That's how much slower is。 A million times slower
    like in some cases。 You have to go and walk down San Francisco and come back to
    the pen。 That's it。 Drive is like the data is in New York City and I have to walk
    to New York City and go， get it。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 主内存就像是数据在旧金山，我得走到那里去取数据。就是这么慢。在某些情况下慢一百万倍。你得走到旧金山，再走回来拿笔。就是这样。硬盘就像数据在纽约市，我必须去纽约市走一趟，去拿它。
- en: That's how much slower it is to get something off your hard drive or your solid
    state disk。 than it is from the register。 You think it's pretty important then
    to keep things as low in memory as possible if you're。 using that often。 What
    I wanted to do is I wanted to show you a little example of how a cache actually
    works。 Some of the numbers that might go into using a cache。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是从硬盘或固态硬盘获取数据的速度有多慢，而从寄存器中获取的速度要快得多。那么，显然如果经常使用，尽量将数据保存在内存中更低层次的地方是很重要的。我想给你展示一个缓存是如何工作的例子。展示一些可能用于缓存的数字。
- en: You do not need to know any of this for the final exam or whatever。 I just want
    to show it to you just to give you a feel for how caches actually what they。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要知道这些内容来参加期末考试或其他什么。我只是想给你展示一下，让你感受一下缓存的实际工作原理。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_99.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_99.png)'
- en: have to do to keep the data。 What we're going to do is we're going to do a thing
    called a direct mapped cache。 Here's what this is。 Let's say that you had 32 kilobytes
    of memory。 In order to do 32 kilobytes of memory we would need to have five bits
    of information。 One bit per byte as it turns out or one bit for two to the fifth
    number of kilobytes or， whatever。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的事情是保持数据。我们要做的是实现一种叫做直接映射缓存的东西。看，这是什么样的。假设你有32千字节的内存。为了处理32千字节的内存，我们需要5位信息。每个字节一个位，或者说是每32千字节对应的5位信息，具体取决于你。
- en: You need five bits of information there。 Like zero zero zero zero zero zero
    zero zero zero zero zero zero zero zero zero one all。 the way down to one one
    one one one。 Let's say that was your main memory。 What we're going to want to
    do is we're going to want to have a smaller amount of memory。 Sorry not 32 kilobytes
    32 addresses that would make more sense so you can do five bits here。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要5位信息，就像是0000000000000000000000000000000001，一直到111111111111111111111111111111111。这就是你的主内存。我们想要做的事情是将内存量缩小。抱歉，不是32千字节，而是32个地址，这样你就可以用5位信息了。
- en: 32 addresses but let's say that we have a cache that only has space for eight
    of those。 memory like sections。 Let's do it like this。 Let's say that you had
    eight bits in here one two three four five six seven seven one two。 three four
    five six seven eight eight。 How many bits do I need to represent eight different
    locations？
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 32个地址，但假设我们有一个缓存，只能存储其中八个内存段。我们可以这么做，假设你有八个比特位，这里是一二三四五六七八。我们需要多少比特来表示八个不同的位置？
- en: How many？ Three。 You need three bits right。 We're going to have this thing called
    a tag or an index rather an index which is going。 to be zero zero zero zero zero
    one and I'm actually sorry I'm going to do this。 Oh no。 I'm going to do it。 Hang
    on。 We're going to we're going to have the I put it in the wrong place here。 You're
    going to have a the index here or maybe I took it in the right place。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 多少位？三个。你需要三个比特，对吧？我们将有一个叫做标签或索引的东西，实际上是一个索引，它将是`000001`，对不起，我做错了。哦不，我要重新做一下。等一下。我们将这样做，把它放错地方了。你将会有一个索引，或者可能我放对了地方。
- en: Anyways the index here and the index is the part that tells us yes so zero zero
    zero zero。 zero zero one zero zero one one zero zero one zero one zero one zero
    one zero one zero， one one one。 There's our eight locations that we're going to
    be able to store some of those 32 addresses。 Zero is going to map to zero one
    is going to map to one two is going to map to zero one， zero etc。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，索引在这里，索引是告诉我们是不是的部分。所以，`000000001001010101010`，这是我们能存储其中部分32个地址的八个位置。零将映射到零，一将映射到一，二将映射到零一，零等等。
- en: Where do you think eight seven is going to go to one one one one where do you
    think eight。 is going to go back to zero right we need some modules here to actually
    do that thing。 we're basically going to store them based on the upper three bits
    of their address okay。 and so I'm sorry it's actually this is where I got confused
    it's the lower three bits of。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为`87`会存到哪里？`1111`，你认为`8`会存到哪里？回到零，对吧？我们需要一些模块来做这件事。我们基本上将根据它们地址的上三位来存储这些数据。抱歉，实际上是这个地方我搞错了，是根据它们地址的下三位来操作。
- en: their address that we're going to do。 So basically zero zero zero is going to
    go in zero zero zero zero zero zero one is going。 to go there etc。 Okay and remember
    what we're trying to do is we're trying to say every time you ask for。 some memory
    it's going to first look in this very fast cache and if it finds it it's going。
    to return it faster than if it had to look it up in main memory。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的地址我们将要做的。基本上，`000`将存入`000`，`001`将存入那里等等。好的，记住我们要做的事是每次你请求某些内存，它将首先在这个非常快速的缓存中查找，如果找到了，它将比从主内存中查找更快地返回结果。
- en: Okay at the beginning nothing is in your cache okay we are going to try to look
    up the following。 ten different values okay we are going to look up one zero one
    one zero then we're going。 to look up one one zero one zero and then one zero
    one one zero and then one one zero。 one zero and I got the rest of them here too
    we're going to look up one zero zero zero zero。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一开始缓存中什么都没有，好吗？我们将尝试查找以下十个不同的值。好，我们将查找`10110`，然后查找`11010`，接着是`10110`，再然后是`11010`，我这里也有剩下的值，我们还将查找`10000`。
- en: zero zero zero one one one two three four five six we need four more we're going
    to be one。 zero zero zero zero one zero zero one zero one zero zero zero zero
    zero what are you doing。 class day listen to Chris this talk much better and then
    one one zero one zero okay we're going。 to look up all those numbers look look
    up all those addresses and if you look it up and。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`00011123456`，我们还需要四个位，我们将是`100000101000000000`，你在干什么？班级，听Chris讲，那个讲得好多了。然后`11010`，好，我们将查找所有这些数字，查找所有这些地址，如果你查找它。'
- en: it's not in the cache it's called a cache miss and that's expensive we want
    to get cache。 hits which means that it's in the thing because this is direct address
    it actually turns out。 we can't we can't keep the values in there very long there's
    other kinds of caching which。 allows you to keep the data in there longer we're
    just going to see this example see how。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它不在缓存中，这叫做缓存未命中，这很昂贵。我们希望得到缓存命中，这意味着它已经在缓存中，因为这是直接寻址。实际上，结果证明我们不能将值存储在缓存中太长时间，还有其他种类的缓存可以让你将数据存储得更久，我们只是通过这个例子来看一下如何操作。
- en: it works here's what you do you go to let's see if you look up one zero one
    one zero we。 look at the one one zero and we go over here and we find the index
    and this is called the。 tag by the way and we look up we say is one one zero fill
    or not well one one zero is not。 filled so what we do is we say first of all we
    say that's a cache miss and we put the。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的呢？你要做的是，看看是否查找 1 0 1 1 0。我们查看 1 1 0，然后去找索引，这个叫做标签。我们查看时会问，1 1 0 是填充了吗？其实
    1 1 0 还没填充，所以我们做的第一件事是说这是一个缓存未命中，我们把。
- en: one zero well we put the let's do this we put the memory for one zero in here
    with the one。 four one zero one one zero the memory for that in there and then
    we're going to tag it with。 the one zero to differentiate it from the other things
    that might fit in that bucket okay so。 we looked up one zero one one zero we looked
    at the one one zero we did it in the wrong。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一 0 好，我们做这个，我们把 1 0 的内存放进去，用 1 4 1 0 1 1 0 的内存放进去，然后我们用 1 0 的标签来区分它，以免它与可能适合这个桶的其他内容混淆。好的，现在我们查找
    1 0 1 1 0，我们查看 1 1 0，但我们做错了。
- en: one didn't I guys got to catch me on this we did it in there did in the wrong
    one one。 one one zero and we looked at one zero and then we're getting the memory
    from one zero one。 one zero okay that's what we're putting we're putting that
    memory there so when next time。 we look that up we will get it quickly so let's
    look at the next one one one zero one zero。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有搞错吧？大家得提醒我，我们查的是错误的 1 1 0，而我们查的是 1 0，然后我们取出了 1 0 1 1 0 的内存，好的，我们把那个内存放进去，这样下次我们查找时就能快速找到它。现在让我们看看下一个，1
    1 0 1 0。
- en: we look at zero one zero and we go to zero one zero is it there no so we it's
    another。 miss and we do the same thing here we put we've got one one and then
    we have the memory from。 that location doesn't matter what that is right now okay
    and then now it's in the cache。 let's look up one zero one one zero again we go
    to one one zero it's there is one zero。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查找 0 1 0，然后我们去看 0 1 0，它不在，所以这又是一个未命中，然后我们做同样的事情，我们把 1 1 放进去，然后从那个位置取出内存，不管那是什么，现在好了，它已经在缓存中了。让我们再看看
    1 0 1 1 0，我们去找 1 1 0，它在那里，就是 1 0。
- en: the tag it's there we quickly return this value that is a cache hit and that's
    a good。 thing and that means that it's that it's we've got that value in there
    and you can think。 that if we're going to access that number many times well we'll
    always find it in the。 cache until it gets replaced by something else。 Let's look
    at the next one 11010 we。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 标签存在时，我们快速返回这个值，这是一个缓存命中，这是好事。这意味着我们已经把这个值存入缓存，你可以想象，如果我们多次访问这个数字，那么我们总是能在缓存中找到它，直到它被其他东西替换掉。让我们看下一个
    11010。
- en: look at the 010 0 0 10 1 1 it is also in there already so that's another hit。
    Okay let's look。 at 100 0 0 0 not there so we put the 1 0 there and we have the
    memory from that location that's。 a miss 0 0 0 1 1 0 0 0 1 1 it's a miss and we'll
    get to one that's interesting in a second。 1 1 the memory there and then 1 0 0
    0 0 okay 1 0 0 0 we've already seen we already seen。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 010 0 0 10 1 1，它也已经在里面了，这是另一个命中。好的，让我们看一下 100 0 0 0，它不在，所以我们把 1 0 放进去，并从那个位置获取内存，这是一个未命中。0
    0 0 1 1 0 0 0 1 1，它是一个未命中，我们稍后会看到一个有趣的情况。1 1 从那里的内存，然后 1 0 0 0 0，好吧，1 0 0 0 我们已经看过了。
- en: that one too yes we did that's a hit okay and then 1 0 0 1 0 okay we go to 0
    1 0 aha。 0 1 0 it's 1 1 but we're looking for 1 0 we now evict what's there in
    the cache what's。 they call cache eviction we send it out we put the 1 0 1 there
    we replace it with the。 memory from 1 0 0 1 0 okay and then let's do this one
    and that was a miss because it wasn't。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那个也放进去，是的，我们做到了，这是一个命中。好，接着是 1 0 0 1 0，我们去找 0 1 0，啊哈，0 1 0 是 1 1，但我们现在在找 1 0，于是我们将缓存中已有的内容逐出，这就叫做缓存驱逐。我们将
    1 0 1 放进去，替换掉了 1 0 0 1 0 的内存，好，接下来我们做这个，它是一个未命中，因为它不存在。
- en: what we're looking for 1 0 0 0 0 0 0 0 0 0 it's a hit again and then the final
    one 1 1 0 1。 0 well we've looked at this one a whole bunch of times but now 1
    1 0 1 0 we go back to 0 1。 0 we have to kick this one out again and that's another
    miss and now we put this one back。 in there this method is great because it's
    fast to look up it's not great if you happen。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找的是 1 0 0 0 0 0 0 0 0 0，又是一个命中，接下来是最后一个 1 1 0 1 0。我们已经查了这个好几次了，但现在 1 1 0
    1 0，我们又回到了 0 1 0，我们不得不将其踢出去，这又是一个未命中，现在我们把它放回缓存。这种方法很棒，因为查找很快，但如果你遇到。
- en: to get two pieces of data that are both mapped to the same bucket at the same
    time anyway。 that's how you do this mapping a lot of times this is supported with
    hardware so these things。 can be done in parallel a lot of this can be done in
    parallel and it's also there are。 ways to do it so that the values can go in any
    position in the cache and you have to determine。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要获取两条映射到同一个桶的数据，不管怎样，这就是如何进行映射。很多时候，这些映射是由硬件支持的，这样这些操作可以并行进行。很多操作可以并行完成，另外，也有办法让值可以存放在缓存中的任何位置，你需要确定这些位置。
- en: whether or not to kick something out of the cache based on how long it's been
    there if。 it's been there most recently then you don't kick it out it's been there
    a long time you。 kick it out or whatever and you have to go through that so I
    just wanted to show you that's。 a little of the math that you might have to go
    through if you take E。D。 180 and you work。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将某些内容从缓存中清除，取决于它在缓存中存在的时间。如果它最近被访问过，你就不清除它；如果它已经在缓存中很长时间了，你就把它清除，或者其他策略，你需要按照这些方法进行。我要展示给你们的是，如果你参加`E.D.
    180`课程，你可能需要经历的一些计算。
- en: on how do caches actually do their thing okay so that's that one okay questions
    on caching。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是如何工作的呢？好，这就是那个问题了，好，关于缓存有什么问题吗？
- en: '![](img/1b246eaaae452a61678a9e11303b691a_101.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_101.png)'
- en: '![](img/1b246eaaae452a61678a9e11303b691a_102.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_102.png)'
- en: yeah very good question the question was if you ask if you do malik where does
    it go。 to come from totally depends generally if you haven't if the if the computer
    hasn't used。 that memory location recently then it will have to go to main memory
    to request it if。 it has been used for maybe from other programs or whatever but
    it's not being used by other。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，很好的问题，问题是，如果你做了`malik`，数据从哪里来呢？完全取决于情况。通常情况下，如果计算机没有最近使用那个内存位置，它就需要从主内存中请求数据。如果它已经被其他程序使用过，或者其他情况，但没有被其他程序占用时，数据就可以从那里获取。
- en: program now it might still be in the cache but if you do malik it might get
    a bunch out。 of the in fact it won't actually need to read any information out
    it says hey here's。 your locations first time you try to read from the location
    it will populate in the cache。 the next time it will be there hopefully it will
    be much faster and by the way those。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在它可能仍然在缓存中，但如果你做了`malik`，它可能会把很多东西清除出去。事实上，它实际上不需要读取任何信息，它会说“嘿，这里是你的位置”，第一次尝试从这些位置读取时，数据会被加载到缓存中。下次再读时，它就会在那里，希望会更快一些，顺便提一下这些。
- en: four levels of caches or whatever it keeps bumping it down down down down down
    as far。 the more you do so your data will be in all the upper level caches but
    looks in the lower。 spot first doesn't find it looks in the next one doesn't find
    it and then eventually gets。 up to where it finds it yeah good question any other
    questions on this okay let's look。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 四级缓存或其他机制，它会不断地将数据向下、向下、向下推，直到最远处。你越是这样做，数据就会存在所有上层缓存中，但首先会查看较低层的缓存。如果没有找到，会查看下一个缓存，再没有的话，最终会到达找到它的地方。嗯，好问题，还有其他问题吗？好，接着看。
- en: at so or let's see what board there we go okay so that was caching virtualization
    yeah。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，或者让我们看一下，好的，缓存虚拟化就是这样。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_104.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_104.png)'
- en: '![](img/1b246eaaae452a61678a9e11303b691a_105.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_105.png)'
- en: yeah so the question is is your stack moved to your cache surely right I mean
    the cache。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，问题是，栈是不是已经移动到缓存中了？当然了，缓存就是这样工作的。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_107.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_107.png)'
- en: is separate from your program itself right the caches based on how often you
    use that。 data and if you use it it gets looked for in the cache it is not there
    it gets put in。 the cache once it finds it and so again there's various strategies
    for doing this what you're。 trying to do is you're trying to get about if you
    can ninety percent cache hits in your。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存与你的程序本身是分开的，它是根据你使用数据的频率来决定的。如果你使用了它，它会在缓存中查找，若没有找到，它会被放入缓存。一旦找到它，数据就会存入缓存。所以，这里有多种策略来实现这个目的，你的目标是尽量做到让缓存命中率达到90%。
- en: lower level caches so that's very fast and this really does speed things up
    and significantly。 yeah yeah so yeah the question is are these being virtually
    mapped in here and they are。 they are all being virtually mapped in the addresses
    that are stored or the memory addresses。 that are stored in the caches are actually
    physical addresses so a particular program。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 更低级别的缓存是非常快的，这确实能大大加快速度。是的，是的。所以问题是，这些是否是在这里进行虚拟映射的？它们是的。它们的所有映射都是虚拟的，存储在缓存中的地址实际上是物理地址，所以一个特定的程序。
- en: will have a physical address now another question that might come up is wait
    what happens when。 you do multi processing and you shift off the process do all
    the caches remain or do they。 go away generally to get cleared for a different
    process they might get saved and popularly。 populated but generally I think they
    just get cleared so every time you do a process switch。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 会有一个物理地址。现在，另一个可能出现的问题是，等一下，当你进行多进程处理并且切换进程时，所有的缓存会保留吗？还是它们会消失？通常它们会被清除，供不同的进程使用，但它们可能会被保存和重新填充，但一般来说我认为它们会被清除，因此每次切换进程时。
- en: your caches get cleared which slows things down significantly too they talk
    about you。 talk about caches as that being hot or cold a cold cache doesn't have
    any memory in it yet。 the hot cache has all the memory there it's really fast
    to access what other kinds of。 caches by the way we have you did a web browser
    cache or you did a web web cache web proxy。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的缓存被清除时，事情也会变得显著变慢。他们讨论缓存时，会提到缓存是热的还是冷的，冷缓存还没有任何数据，而热缓存已经存有所有数据，它的访问速度非常快。顺便问一下，你知道我们还有哪些类型的缓存吗？你曾经做过网页浏览器缓存或者做过网页缓存、网页代理吗？
- en: cache DNS caches is whenever you're trying to request a Google's address trust
    me your。 local cache has Google's address because you use it all the time so it's
    a need to go find。 it and then there let's see oh there's another one called them
    cached which is I don't know。 much about that but it's for web content that keeps
    the web content cached in a slightly。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存DNS缓存是你每次试图请求Google的地址时，相信我，你的本地缓存已经有了Google的地址，因为你一直在使用它，所以不需要再去查找。然后我们看看，哦，还有一个叫做“缓存”的东西，我不知道它具体是做什么的，但它是用于网页内容的，它会将网页内容缓存起来，稍微。
- en: different way so there's lots of different places where caching becomes important
    and。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以不同的方式，这里有很多地方，缓存变得非常重要。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_109.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_109.png)'
- en: it does significantly speed things all right what else can we do virtualization
    so we I。 mentioned virtualization a few times you've seen it in labs and so forth
    as well virtualization。 there are two types one is an abstraction that makes many
    resources look like one okay let。 Let me give you an example。 There is a hard
    drive system called RAID， r-a-i-d。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实大大加快了速度，那我们还能做什么呢？虚拟化，所以我们我提到过虚拟化几次，你们在实验室里也见过，等等，虚拟化。虚拟化有两种类型，一种是抽象，它让许多资源看起来像是一个。好吧，让我给你举个例子。有一个硬盘系统叫做RAID，r-a-i-d。
- en: And it basically says， let's say that you have a computer， and it has many hard
    drives。 Why would you have that？ A couple of reasons-- you might have four hard
    drives。 associated with one particular server。 One reason is that you can keep
    file one here。 part of file one here， and another part of file one here， and another
    part of file one here。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是说，假设你有一台计算机，并且它有多个硬盘。你为什么会有这些硬盘呢？有几个原因——你可能会有四个硬盘与某台特定服务器关联。一个原因是你可以把文件一的一部分保存在这里，文件一的另一部分保存在这里，文件一的另一部分保存在这里，文件一的另一部分保存在这里。
- en: And maybe throughout those four-distits， duplicated in such a way that if this，
    entire disk dies。 then you can recoup file one just， with the other three disks。
    It's very good for redundancy reasons。 But let's say that you--。 another reason
    you can do it is if you kept file one here， and file one here。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这些四个磁盘可能会以某种方式进行重复，这样如果整个磁盘损坏，你可以仅通过另外三个磁盘恢复文件一。这在冗余方面非常有用。但假设你——另一种做法是，如果你把文件一保存在这里，文件一保存在这里。
- en: remember reading from a hard drive is slow。 What if you can do it in parallel
    and have one process。 reading from this drive and the other process reading， from
    this drive to get part of the same file？
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，从硬盘读取数据很慢。如果你能并行处理，一个进程从这个硬盘读取数据，另一个进程从另一个硬盘读取同一文件的部分内容呢？
- en: You can actually do it almost twice as fast， because both disks will be running
    in parallel。 to giving your data。 So it's both for robustness and for safety，
    as far as robustness and for speed。 rather， so that you can get your data faster。
    But by the way， your file system。 when you access a file， it has no idea that
    there's four disks here。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以几乎快一倍，因为两个磁盘会并行运行，为你提供数据。所以，这既是为了稳健性，也是为了安全性，至少从稳健性和速度上来说，能让你更快地获得数据。顺便提一下，你的文件系统在访问文件时，并不知道这里有四个磁盘。
- en: It looks like just when you make one request， and it gives you the data back。
    Internally to the RAID system， it does all these special， oh， there's four disks。
    and I have to do that。 That's a virtualization。 Four disks look like one disk，
    but they。 are partitioning such a way that it， is either faster or more robust。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来就像你发出一个请求，然后它返回数据。在 RAID 系统内部，它做了所有这些特殊的操作，哦，有四个磁盘。我必须这么做。那就是虚拟化。四个磁盘看起来像一个磁盘，但它们的分区方式可以使其更快或更稳健。
- en: So that's one type of virtualization。 The Andrew file system， this is what。
    we use on the MIF machines。 If you ever noticed， if you've logged in a MIF。 or
    you log in to Cardinal or if you log in a MIF 52 or 58， or whatever， all the same
    file system。 the reason it's all the same file system， is that it's a file system
    that is spread across。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一种虚拟化类型。Andrew 文件系统，这就是我们在 MIF 机器上使用的。如果你曾经注意到过，登录到 MIF，或者登录到 Cardinal，或者登录到
    MIF 52 或 58，或者其他任何地方，文件系统都是一样的。之所以文件系统相同，是因为它是一个遍布各地的文件系统。
- en: all those computers。 In fact， Andrew file system is spread across the world。
    You can go to Carnegie Mellon's--， if you can do CD from your MIF to a machine
    in Carnegie Mellon。 now you don't have the permissions probably to do anything，
    but you can actually CD into it。 We always type slash user slash class。 Really，
    that's actually a link to slash AFS slash IR slash。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些计算机。实际上，Andrew 文件系统遍布全球。如果你能从你的 MIF 目录切换到卡内基梅隆的机器，你可以访问它。现在你可能没有权限做任何操作，但你实际上可以进入它。我们总是输入
    `/user/class`。实际上，这只是一个指向 `/AFS/IR/` 的链接。
- en: et cetera， et cetera。 And those are like AFS is the Andrew file system。 I think
    IR is Stanford's or whatever。 And so it's mapped to across the world。 But that's
    a virtualization。 It looks like there's one file system。 but really there's thousands
    and thousands， of computers connected to that one system。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，等等。这些就像 AFS（Andrew 文件系统）。我记得 IR 是斯坦福的，或者其他的。它被映射到全世界。但这就是虚拟化。它看起来像一个文件系统，但实际上有成千上万的计算机连接到这个系统。
- en: They share the file system。 Web server load balancer。 This is when you log in
    a MIF and we did a load balancer in class。 We log in a MIF and it comes up with--，
    sends you to MIF 52 because it's got the fewest number of people。 on it that are
    working。 Virtualization is also making one resource look like many。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它们共享文件系统。Web 服务器负载均衡器。这就是当你登录 MIF 时，我们在课堂上做了负载均衡器。我们登录到 MIF，然后它会将你转发到 MIF 52，因为那里的人最少。虚拟化也是让一个资源看起来像许多资源。
- en: So what does that mean？ Well， this would be like virtual to physical memory
    mappings。 So you know how we've said last time， that you have two processes and
    they both think。 they have all the memory in the entire system？ Well， they don't。
    They only have a little portion of memory， but it's making that one--。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 那这意味着什么呢？这就像虚拟到物理内存映射。你知道我们上次说过，你有两个进程，它们都认为自己拥有整个系统的所有内存吧？但其实并不是。它们只拥有一小部分内存，但它们让这一部分——
- en: it's making the one resource look like many resources， instead of the other
    way around。 Threads。 Well， it's thread has its own stack segment。 Well。 that's
    just the irregular stack broken into many pieces。 That's virtualization。 Virtual
    machines。 So who has used VMware before？
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它让一个资源看起来像多个资源，而不是反过来。线程。线程有自己的栈段。那只是将不规则的栈分割成多个部分。这就是虚拟化。虚拟机。那么谁以前使用过 VMware？
- en: '![](img/1b246eaaae452a61678a9e11303b691a_111.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_111.png)'
- en: I think I have VMware on here。 Here we go。 Here's VMware。 I can load-- if I
    load this up。 I can load a Linux machine。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这里有 VMware。好了，这是 VMware。我可以加载——如果我加载这个，我可以加载一个 Linux 机器。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_113.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_113.png)'
- en: on my neck that's really Linux。 And it really thinks it's talking to hardware
    directly。 And in fact。 it is， because Intel sets up things， to make it virtualization
    work right。 But now I have literally two operating systems running。 on a computer
    at once-- my Mac operating system， and a Linux operating system。 And by the way。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的脖子上，实际上是Linux。它确实认为自己是在直接与硬件通信。实际上，它确实是在这样做，因为英特尔设置了相关的机制，使得虚拟化能够正常工作。但现在，我的电脑上实际上运行着两个操作系统——我的Mac操作系统和一个Linux操作系统。顺便提一下。
- en: VMware was--， the company has started from Professor Mendel Rosenblum。 who's
    here and teaches this class， occasionally in some other systems classes。 He did
    pretty well creating VMware。 But anyway， now I've got-- see， now I'm just inside
    my Linux。 machine up here。 And I also can do-- you can do windows or other machines
    too。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: VMware是——这个公司由Mendel Rosenblum教授创办，他是这里的教授，并且偶尔在其他一些系统课程中教授。他创建VMware时做得非常成功。但无论如何，现在我——看，现在我就在我的Linux机器上。并且我也可以做——你也可以做Windows或其他机器。
- en: I don't even have a Windows PC， but I use Windows programs， occasionally。 And
    all I do is run it out of VMware and makes it easy。 So it's a little slower because
    there's。 some translation that has to happen。 But it's not too bad。 And it works
    pretty well。 Works pretty well。 That's how the ends work。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至没有一台Windows PC，但我偶尔会使用Windows程序。所有我做的就是通过VMware运行它，操作起来很方便。所以会稍微慢一些，因为需要进行一些翻译工作。但并不算太糟糕，工作得还不错。运作得相当好。就是这样运作的。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_115.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_115.png)'
- en: All right。 Concurrency。 We've talked a lot about concurrency in this class。
    Multiple processes。 multiple threads， multiple cores on your multi-processor computer。
    Wasn't until about 10。 12 years ago， you really couldn't buy a multi-processor
    computer。 for less than tens of thousands of dollars。 It was really expensive。
    In 2006。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。并发。我们在这门课上谈了很多并发。多个进程，多个线程，多个核心的多处理器计算机。直到大约10到12年前，你真的无法买到一台价格低于几万元的多处理器计算机。那时它真的非常昂贵。2006年。
- en: Intel started pushing out a dual core machine， which means now you've got a
    computer that can literally。 do two programs at the same time。 And that's concurrency。
    Signal interrupt handlers are all about concurrency。 Signals， your program is
    running along。 with an interrupt handler。 The kernel is doing its own thing。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔开始推出双核机器，这意味着现在你有一台可以真正同时运行两个程序的计算机。这就是并发。信号中断处理程序就是关于并发的。信号时，你的程序正在运行，并且有一个中断处理程序。内核在做它自己的事情。
- en: And then signals your handler to stop the rest of your program。 and handle whatever
    the child process handler， or whatever is happening there。 There are languages
    which are built specifically， to do concurrency。 There's a language called Erlang，
    which， is a great language but kind of hard。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后信号会通知你的处理程序停止剩余的程序部分，处理任何子进程处理程序或发生的任何事情。已经有一些专门为并发而设计的语言。有一种语言叫Erlang，它是一种很棒的语言，但有点难学。
- en: to get your head wrapped around。 But it basically doesn't allow race conditions。
    You can't make a race condition early， because of the way the languages built。
    Not bad if you're trying to do lots of concurrency。 Yeah？ So signals interrupt，
    but it's not。 because they can try and code that works， before they throw a problem。
    Good question。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让你理解起来有些复杂。但它基本上不允许竞态条件。你不能在一开始就产生竞态条件，因为语言的构建方式不允许。对于需要做大量并发的任务来说，这种方式不错。是吧？所以信号会中断，但并不会像它看起来的那样，因为它们会尝试并且编写有效的代码，然后再抛出问题。好问题。
- en: If signals interrupt handlers， just like everything else。 If signals interrupt
    handlers are concurrent， how did it work before multi-processing？
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号中断处理程序，就像其他任何事情一样。如果信号中断处理程序是并发的，那么在多处理之前它是如何工作的？
- en: When you have one processor， you can mimic multi-processing， by time slicing
    everything。 Right？
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只有一个处理器时，你可以通过时间切片来模拟多处理，是吧？
- en: So the kernel gets a little time， and you get a little time。 The kernel gets
    some time。 and you get some time， in your single manner， get some time， whatever。
    So that's how it works。 But anyway， Erlang， look it up。 It's an interesting language
    if you。 want to do very safe concurrent programs。 JavaScript is exactly the opposite。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所以内核有一点时间，你也有一点时间。内核得到一些时间，而你也得到一些时间，以你自己的方式得到一些时间，随便什么。就这样运作。但是无论如何，Erlang，查一下它。如果你想做非常安全的并发程序，它是一个有趣的语言。JavaScript恰恰相反。
- en: They said concurrency is too hard。 We're just going to have one thread。 And
    it's not quite as true these days。 But it made it very easy to program in JavaScript
    in some ways。 but also not very efficient because it has one thread。 It does everything。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说并发太难了，我们就只用一个线程。这在如今不完全是事实。但这在某些方面让在JavaScript中编程变得非常简单，但也有些效率低下，因为它只有一个线程，做所有的事情。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_117.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_117.png)'
- en: So that's that。 OK。 All right。 And then finally， we have client server response，
    which。 is a request and response。 This is what we've been doing for networked。
    This is exactly what your map reduce is doing， where your map reduce main program
    is talking。 to the reducers and the mappers back and forth， until it gets all
    the data back。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所以就这样。好的。然后最后，我们有客户端-服务器响应，这就是请求与响应。这是我们一直在做的网络相关内容。这正是你们的MapReduce程序所做的事情，MapReduce的主程序和reducer、mapper之间来回交互，直到获取所有数据。
- en: It's a client server request。 You see this all the time， not just in networking。
    You see it with multi-processing。 You see it with processors that have。 to basically
    talk between each other， and coordinate things that happens。 System calls are
    also another request and response， right？
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端-服务器请求。你在各种场合都会看到它，不仅仅是在网络中。你在多进程中也能看到它。在那些必须相互沟通并协调事情的处理器之间，你也能看到这种情况。系统调用也是一种请求与响应，对吧？
- en: Where you say a system call and the kernel， goes and handles it， you are basically。
    talking to the kernel that talks back to you， that gives you， back the answer。
    And there's that handshake that has， to happen via a system call in there。 All
    of the networking protocols， of course， are various examples of client requests
    and response。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你发出系统调用，内核去处理它，基本上就是你和内核在沟通，内核再把答案反馈给你。在系统调用中必须发生的就是这种握手。所有的网络协议，当然，都是客户端请求与响应的不同例子。
- en: And then the file systems that we just talked about。 are also client requests
    or a request and response。 Because you look for a file that might not。 be on the
    hard drive that the mitzv are using。 It's on the file system that the hard drive。
    is up some other building， which might be--， it might be if you're looking at
    Carnegie Mellon's。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们刚刚讨论过的文件系统，也是客户端请求或请求与响应。因为你查找一个文件，它可能不在你正在使用的硬盘上，而是在其他建筑物中的文件系统里，也许在--，也许它在你查看卡内基梅隆的文件系统中。
- en: it's on the hard drive over at Carnegie Mellon。 You have to do some requesting
    and it's kind of slow。 in that sense。 So those are the seven pieces that we covered
    this quarter。 And there's a lot there。 but you know some of the details， about
    that。 You still don't know some of the abstraction underneath the hood。 sort of
    details。 You'll get those in other classes。 But in here。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它在卡内基梅隆的硬盘上。你需要提交一些请求，而且过程有点慢，从这个角度来看。所以这些是我们这个学期所涉及的七个部分。内容非常多，但你知道，有一些细节，你还是不清楚其中的一些抽象层次，属于底层的细节。这些你将在其他课程中学到。但在这里。
- en: hopefully you can see how many of the things， that we've done relate to these
    ones。 What questions do you have at this point？ All right。 So I will then see
    you for last class on Wednesday。 It is on non-blocking file。io。 And then we have
    the final exam。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到我们做的许多事情如何与这些内容相关。到目前为止，你有什么问题吗？好的。那么我将在星期三的最后一堂课上见你。那一堂课是关于非阻塞文件I/O的。然后我们会有期末考试。
- en: '![](img/1b246eaaae452a61678a9e11303b691a_119.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b246eaaae452a61678a9e11303b691a_119.png)'
- en: No laps this week， there are no laps。 We'll see you then。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这周没有环节，没有环节。我们下次见。
