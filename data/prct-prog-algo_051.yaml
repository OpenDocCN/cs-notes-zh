- en: 9.2   Symbolic Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2   符号方法
- en: 原文：[https://introcs.cs.princeton.edu/java/92symbolic](https://introcs.cs.princeton.edu/java/92symbolic)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/92symbolic](https://introcs.cs.princeton.edu/java/92symbolic)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在进行重大改造。
- en: Symbolic integration.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号积分.
- en: In introductory calculus, we learn various rules for differentiating and integrating
    functions. Differentiating is a mechanical process with a half dozen or so general
    purpose rules.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在初级微积分中，我们学习了各种不同函数的求导和积分规则。求导是一个机械过程，有大约半打通用规则。
- en: '*Sum and difference rule.* (f(x) ± g(x))′ = f′(x) ± g′(x).'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*和差法则.* (f(x) ± g(x))′ = f′(x) ± g′(x).'
- en: '*Product rule.* (f(x) g(x))′ = f(x) g′(x) + g(x)f′(x).'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*乘积法则.* (f(x) g(x))′ = f(x) g′(x) + g(x)f′(x).'
- en: '*Quotient rule.* (f(x)/g(x))′ = (f′(x) g(x) - g′(x) f(x)) / g²(x).'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*商法则.* (f(x)/g(x))′ = (f′(x) g(x) - g′(x) f(x)) / g²(x).'
- en: '*Power rule.* (x^k)′ = kx^(k-1).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*幂法则.* (x^k)′ = kx^(k-1).'
- en: '*Chain rule.* (f(g(x))′ = f(g(x)) g′(x).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链式法则.* (f(g(x))′ = f(g(x)) g′(x).'
- en: There are also some rules for special functions that are typically derived once
    and then memorized, e.g., the derivative of sin(x) is cos(x); the derivative of
    exp(x) is exp(x); the derivative of ln(|x|) is 1/x; the derivative of sec(x) is
    sec(x) tan(x); the derivative of arcsin(x) is (1 - x²)^(-1/2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些特殊函数的规则通常是推导一次然后记忆的，例如，sin(x)的导数是cos(x)；exp(x)的导数是exp(x)；ln(|x|)的导数是1/x；sec(x)��导数是sec(x)
    tan(x)；arcsin(x)的导数是(1 - x²)^(-1/2)。
- en: On the other hand, we learn that indefinite integration is a much harder problem.
    Calculus students typically learn a set of ad hoc pattern matching rules for finding
    the antiderivative of a function of one variable. (Below, we assume constant term
    of antiderivative is zero.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们了解到不定积分是一个更难的问题。微积分学生通常学习一组特定的模式匹配规则，以找到一个变量函数的反导数。（以下，我们假设反导数的常数项为零。）
- en: '*Constant rule.* The antiderivative of cf(x) is the product of c and the antiderivative
    of f(x).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常数法则.* cf(x)的反导数是c乘以f(x)的反导数。'
- en: '*Sum rule.* The antiderivative of f(x) + g(x) is the sum of the antiderivatives
    of f(x) and g(x).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*求和法则.* f(x) + g(x)的反导数是f(x)和g(x)的反导数之和。'
- en: '*Polynomials.* The antiderivative of f(x) = x^b (for b &neq; 0 and b &neq;
    1) is x^(b-1) / (b-1). By combining this rule with the two previous ones, we can
    determine the antiderivative of any polynomial.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多项式.* f(x) = x^b（其中b ≠ 0且b ≠ 1）的反导数是x^(b-1) / (b-1)。通过将此规则与前两个规则结合，我们可以确定任何多项式的反导数。'
- en: '*Table lookup.* Memorize the antiderivatives of a variety of simple functions.
    Ex: sin(x), tan(x), arctan(x). Ex: Antiderivative of a^x is a^x / ln a.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查表法.* 记住各种简单函数的反导数。例如：sin(x)，tan(x)，arctan(x)。例如：a^x的反导数是a^x / ln a。'
- en: '*Substitution.* Often useful when f(x) = g(h(x)). Ex: f(x) = sin(√x) or f(x)
    1/(1 + x^2) then substitute x = tan t. It''s not always obvious what you should
    substitue. Often when you spot a term like sqrt(x² ± a²), then a trig substituion
    helps.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*替换法.* 当f(x) = g(h(x))时通常很有用。例如：f(x) = sin(√x)或f(x) 1/(1 + x^2)，然后替换x = tan
    t。并不总是明显应该替换什么。通常当你发现类似sqrt(x² ± a²)的项时，三角替换有所帮助。'
- en: '*Integration by parts.* Antiderivative of f(x)g′(x) equals f(x)g(x) minus the
    antiderivative of g(x)f′(x). Need to get lucky to have function break up into
    required terms. Also need to recognize the right pattern. Ex: anitderivative of
    x e^x or x² sin x. [Interesting example](http://en2.wikipedia.org/wiki/Integration_by_parts)
    that stresses ad hocness: f(x) = e^x cos x and f(x) = ln(x).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分部积分.* f(x)g′(x)的反导数等于f(x)g(x)减去g(x)f′(x)的反导数。需要运气使函数分解为所需的项。还需要识别正确的模式。例如：x
    e^x或x² sin x的反导数。[有趣的例子](http://en2.wikipedia.org/wiki/Integration_by_parts)强调了特定性：f(x)
    = e^x cos x和f(x) = ln(x)。'
- en: '*Logarithm rule.* If f(x) = g′(x) / g(x), then the antiderivative of f(x) is
    ln(|g(x)|). Ex: f(x) = tan(x) = sin(x) / cos(x) = -g''(x) / g(x), where g(x) =
    cos(x). Thus, the antiderivative of f(x) is ln|sec(x)|.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对数法则.* 如果f(x) = g′(x) / g(x)，那么f(x)的反导数是ln(|g(x)|)。例如：f(x) = tan(x) = sin(x)
    / cos(x) = -g''(x) / g(x)，其中g(x) = cos(x)。因此，f(x)的反导数是ln|sec(x)|。'
- en: '*Partial fraction decomposition.* Ex: f(x) = (x⁴ - x³) / (x² + 2)(x - 3). [Reference](http://www.shu.edu/projects/reals/integ/techniqs.html).
    Need to divide polynomials so that degree of denominator is not less than that
    of numerator. Need to factor and reduce polynomials to simplest form. (Generalization
    of Euclid''s algorithm.) Need to solve a system of linear equations. Multiple
    roots makes things more complicated. Method enables us to integrate all fractions
    of two polynomials.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分分式分解.* 例如：f(x) = (x⁴ - x³) / (x² + 2)(x - 3)。[参考链接](http://www.shu.edu/projects/reals/integ/techniqs.html)。需要将多项式除以多项式，使得分母的次数不小于分子的次数。需要因式分解并将多项式简化为最简形式。（欧几里得算法的泛化。）需要解一个线性方程组。多重根使事情变得更加复杂。该方法使我们能够积分两个多项式的所有分数。'
- en: '*More ad hoc rules.* These rules are not sufficient. Ex: f(x) = 1 / (x³ + x
    + 1).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更多特定规则.* 这些规则是不够的。例如：f(x) = 1 / (x³ + x + 1).'
- en: Writing a computer program to perform symbolic integration appears to be a daunting
    task. In the early 1960s, only humans could find the indefinite integral of a
    function, except in the most trivial of cases. One approach is to mimic the method
    taught in introductory calculus classes - build a huge table of known integrals
    and try to pattern match. In the 1800s Liouville sought an algorithm for integrating
    elementary functions. In the 19th centruy, Hermite discovered an algorithm for
    integrating *rational functions* - used partial fractions as basic primitive.
    An *elementary function* is one that can be obtained from rational-valued functions
    by a finite sequence of nested logarithm, exponential, and algebraic numbers or
    functions. Since √-1 is elementary, all of the "usual" trig and inverse trig functions
    (sin, cos, arctan) fall into this category since they can be re-expressed using
    exponentials and logarithms of imaginary numbers. Not all elementary functions
    have elementary indefinite integrals, e.g., f(x) = exp(-x²), f(x) = sin(x²), f(x)
    = x^x, f(x) = sqrt(1 + x³).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算机程序来执行符号积分似乎是一项艰巨的任务。在20世纪60年代初，只有人类才能找到函数的不定积分，除了最琐碎的情况。一种方法是模仿初级微积分课程中教授的方法
    - 建立一个巨大的已知积分表并尝试模式匹配。在19世纪，Liouville寻求了一个用于积分初等函数的算法。在19世纪，Hermite发现了一个用于积分*有理函数*的算法
    - 使用部分分数作为基本原始函数。*初等函数*是指可以通过有理值函数的有限嵌套对数、指数和代数数或函数序列获得的函数。由于√-1是初等的，所有“常见”的三角和反三角函数（sin、cos、arctan）都属于这一类，因为它们可以使用虚数的指数和对数重新表达。并非所有初等函数都有初等不定积分，例如，f(x)
    = exp(-x²)，f(x) = sin(x²)，f(x) = x^x，f(x) = sqrt(1 + x³)。
- en: Finding a finite method for integrating an elementary function (if it exists)
    was the central problem in symbolic integration for many decades. Hardy (1916)
    stated that "there is reason to suppose that no such method can be given", perhaps
    foreshadowing Turing's subsequent results on undecidability. In 1970, Robert Risch
    solved the problem, providing a provably correct and finite method for integrating
    any elementary function whose indefinite integral is elementary. (Actually, his
    method is not universally applicable. To apply it, you need to solve a hard differential
    equation. Lots of effort has gone into solving this differential equation for
    a variety of elementary functions.) Refinements of this method are commonplace
    in modern symbolic algebra systems like Maple and Mathematica. Work also extended
    to handle some "special functions." Relies on deep ideas from algebra and number
    theory. These techniques have enabled mathematicians to find new integrals that
    were previous not known or tabulated, and also to correct a mistakes in well-known
    collections of integrals! For exceptionally curious readers, here is a [symbol
    integration tutorial](../../papers/bronstein.pdf).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于积分初等函数（如果存在）找到一个有限的方法是符号积分的中心问题，持续了许多十年。Hardy（1916）指出“有理由认为不可能给出这样的方法”，也许预示了图灵关于不可判定性的后续结果。1970年，Robert
    Risch解决了这个问题，提供了一个可证明正确且有限的方法，用于积分任何不定积分是初等的初等函数。（实际上，他的方法并不是普遍适用的。要应用它，您需要解一个困难的微分方程。已经付出了大量努力来解决这个微分方程，以适用于各种初等函数。）这种方法的改进在现代符号代数系统（如Maple和Mathematica）中很常见。工作还扩展到处理一些“特殊函数”。依赖于代数和数论的深刻思想。这些技术使数学家能够找到以前不知道或未列入表格的新积分，还能纠正已知积分集合中的错误！对于特别好奇的读者，这里有一个[符号积分教程](../../papers/bronstein.pdf)。
- en: Polynomials.
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式。
- en: Polynomials are a very special type of elementary functions. Our goal is to
    be able to write programs that can manipulate polynomials and perform computations
    such as:![Polynomial](../Images/c2a78bb8e6607d46b006c998a8743820.png)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式是一种非常特殊的初等函数类型。我们的目标是能够编写能够操作多项式并执行计算的程序，例如：![多项式](../Images/c2a78bb8e6607d46b006c998a8743820.png)
- en: We also want to be able to evaluate the polynomial for a given value of x. For
    x = 0.5, both sides of this equation have the value 1.1328125\. The operations
    of multiplying, adding, and evaluating polynomials are at the heart of a great
    many mathematical calculations. Many applications for simple operations (add,
    multiply), and surprising applications for more complicated operations (division,
    gcd), e.g., [Sturm's algorithm](http://mathworld.wolfram.com/SturmFunction.html)
    for find the number of real roots of a polynomial in a given interval, solving
    systems of polynomial equations, Groebner bases. Widely used in systems and control
    theory since Laplace transform of common signals results in ratio of two polynomials.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够评估给定值x的多项式。对于x = 0.5，这个方程的两边的值都是1.1328125。乘法、加法和多项式求值是许多数学计算的核心。许多应用程序用于简单操作（加、乘），更复杂操作（除法、gcd）有一些令人惊讶的应用，例如，[Sturm算法](http://mathworld.wolfram.com/SturmFunction.html)用于找到给定区间内多项式的实根数，解多项式方程组，Groebner基础。在系统和控制理论中广泛使用，因为常见信号的拉普拉斯变换导致两个多项式的比值。
- en: '*Polynomial API.* The first step is to define the API for the polynomial ADT.
    We begin with polynomials whose coefficients and exponents are integers. For a
    well-understood mathematical abstraction such as a polynomial, the specification
    is so clear as to be unspoken: We want instances of the ADT to behave precisely
    in the same manner as the well-understood mathematical abstraction. Immutable.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*多项式API。* 第一步是为多项式ADT定义API。我们从系数和指数为整数的多项式开始。对于像多项式这样被充分理解的数学抽象，规范是如此清晰以至于无需言明：我们希望ADT的实例行为与充分理解的数学抽象完全相同。不可变。'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*A sample client.* Program [Binomial.java](Binomial.java.html) reads in an
    integer N from the command line and prints out the expansion of (1+x)^N.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个示例客户端。* 程序[Binomial.java](Binomial.java.html)从命令行读取一个整数N，并打印出(1+x)^N的展开式。'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Implementation.* Program [Polynomial.java](Polynomial.java.html) represents
    a univariate polynomial of degree `deg` using an integer array `coef[]` where
    `coef[i]` records the coefficient of *x^i*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现。* 程序[Polynomial.java](Polynomial.java.html)使用整数数组`coef[]`表示一个具有整数次数`deg`的一元多项式，其中`coef[i]`记录*x^i*的系数。'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We provide one constructor which takes two arguments `a` and `b` and creates
    the monomial ax^b. The helper method `degree()` computes the actual degree of
    the polynomial (zero if `a` is zero).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供一个构造函数，它接受两个参数`a`和`b`，并创建单项式ax^b。辅助方法`degree()`计算多项式的实际次数（如果`a`为零，则为零）。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To add two polynomials `a` and `b`, we loop through the two arrays and add their
    coefficients. The maximum degree of the resulting polynomial is `a.deg + b.deg`.
    We initialize `c` to be the polynomial of degree `N` with all zero coefficients.
    We are careful to maintain the invariant that `c.deg` is the actual degree of
    the polynomial (which might be different from `a.deg + b.deg` if the leading coefficients
    of the two summands cancel each other out).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加两个多项式`a`和`b`，我们循环遍历这两个数组并相加它们的系数。结果多项式的最大次数是`a.deg + b.deg`。我们将`c`初始化为次数为`N`且所有系数为零的多项式。我们要小心地保持不变式，即`c.deg`是多项式的实际次数（如果两个被加数的首项系数互相抵消，则可能与`a.deg
    + b.deg`不同）。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To multiply two polynomials, we use the elementary algorithm based on the distributive
    law. We multiply one polynomial by each term in the other, line up the results
    so that powers of x match, then add the terms to get the final result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个多项式相乘，我们使用基于分配律的基本算法。我们将一个多项式乘以另一个多项式中的每个项，使得x的幂匹配，然后将这些项相加以获得最终结果。
- en: To evaluate a polynomial at a particular point, say *x* = 3, we can multiply
    each coefficient by the appropriate power of *x*, and sum them all up. The implementation
    of the `evaluate` uses a direct optimal algorithm known as *Horner's method*,
    which is based on parenthesizations
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定点（比如*x* = 3）评估多项式，我们可以将每个系数乘以适当的*x*幂，然后将它们全部相加。`evaluate`的实现使用了一种称为*霍纳法则*的直接最优算法，该算法基于括号化。
- en: '![Horner''s method](../Images/df3cf3ae62e1ada042240d0ff134c6d5.png)'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![霍纳法则](../Images/df3cf3ae62e1ada042240d0ff134c6d5.png)'
- en: The following code fragment performs polynomial evaluation using Horner's method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用霍纳法则执行多项式评估。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rational arithmetic.
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有理数算术。
- en: Program [Rational.java](Rational.java.html) is an abstract data type for nonnegative
    rational numbers. It implements the following interface. To reduce fractions,
    we use Euclid's greatest common divisor algorithm as a subroutine to find the
    least common multiple (lcm) of two integers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[Rational.java](Rational.java.html)是一个非负有理数的抽象数据类型。它实现了以下接口��为了简化分数，我们使用欧几里得的最大公约数算法作为子程序来找到两个整数的最小公倍数（lcm）。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Arbitrary precision arithmetic.
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意精度算术。
- en: The `java.math` library provides two ADTs [BigInteger](http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html)
    and [BigDecimal](http://docs.oracle.com/javase/6/docs/api/java/math/BigDecimal.html)
    that provide support for arbitrary precision arithmetic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.math`库提供了两个ADT [BigInteger](http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html)
    和 [BigDecimal](http://docs.oracle.com/javase/6/docs/api/java/math/BigDecimal.html)，它们支持任意精度算术。'
- en: Maple.
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maple。
- en: Maple is a popular system for symbolic mathematical computation. It was developed
    by a research group at the University of Waterloo, and is available at many Universities.
    It can be used for calculus, linear algebra, abstract algebra, differential equations,
    plotting functions, and numerical calculations. It is also a general purpose programming
    language with conditionals, loops, arrays, and functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Maple是一个流行的符号数学计算系统。它由滑铁卢大学的一个研究小组开发，并在许多大学提供。它可用于微积分、线性代数、抽象代数、微分方程、绘制函数和数值计算。它还是一种带有条件、循环、数组和函数的通用编程语言。
- en: The following sessions illustrates basic arithmetic and built-in functions.
    Note the the answers given are exact, and no floating point approximations are
    made unless we explicitly convert to floating point. All statements end with a
    semicolon (in which case the result is printed to the screen) or a colon (in which
    case the result is suppressed).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下会展示基本算术和内置函数。请注意，给出的答案是精确的，除非我们明确转换为浮点数，否则不会进行浮点数近似。所有语句以分号结尾（在这种情况下结果会打印到屏幕上）或冒号结尾（在这种情况下结果会被抑制）。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One of the most powerful features of Maple is its support of symbolic variables.
    Maple uses `:=` for assignment statements since `=` is reserved for mathematical
    equality.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Maple最强大的功能之一是支持符号变量。Maple使用`:=`表示赋值语句，因为`=`保留用于数学相等。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Equation solving, arrays, conditionals, loops, functions, libraries, matrices,
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方程求解、数组、条件、循环、函数、库、矩阵，
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: garbage collection, variables are global so must be careful not to reuse - can
    reset with `x := 'x'`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收，变量是全局的，因此必须小心不要重复使用 - 可以使用`x := 'x'`重置。
- en: '*Integration in Maple.* When you integrate a function in Maple, it tries a
    number of different integration methods.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*Maple中的积分。* 当您在Maple中对一个函数进行积分时，它会尝试多种不同的积分方法。'
- en: Polynomials.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多项式。
- en: Table lookup.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查表。
- en: 'Heuristics: substitutions, integration by parts, partial fractions, special
    forms involving trig and polynomials'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启发式：替换、分部积分、部分分式、涉及三角函数和多项式的特殊形式
- en: 'Risch algorithm: Horowitz reduction, Lazard/Rioboo/Trager method'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Risch算法：Horowitz简化，Lazard/Rioboo/Trager方法
- en: To witness Maple in action,
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 见证Maple的实际操作，
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Using Maple.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Maple。*'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Q + A
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: Q. When I get an error in Maple, I don't get back to the Maple prompt.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 问：当我在Maple中遇到错误时，我无法返回到Maple提示符。
- en: A. Try typing a semicolon followed by return.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 答：尝试输入一个分号然后回车。
- en: Exercises
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the `toString()` method of `Rational` so that it suppresses the denominator
    if it is 1, e.g., `5` instead of `5/1`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Rational`的`toString()`方法，以便在分母为1时抑制它，例如，`5`而不是`5/1`。
- en: Add `isOdd()` and `isEven()` methods to the polynomial ADT to indicate if the
    polynomial is odd (all nonzero coefficients have odd exponents) or even (all nonzero
    coefficients have even exponents).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为多项式ADT添加`isOdd()`和`isEven()`方法，以指示多项式是奇数（所有非零系数具有奇数指数）还是偶数（所有非零系数具有偶数指数）。
- en: Add `equals()` and `compareTo()` methods to `Rational`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Rational`添加`equals()`和`compareTo()`方法。
- en: 'Modify the `toString()` method of `Polynomial` so that it suppresses the exponent
    in the x^1 term and the x^0 in the constant term. Some boundary cases to check:
    f(x) = 0, 1, and x.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Polynomial`的`toString()`方法，以便抑制x^1项中的指数和常数项中的x^0。一些边界情况要检查：f(x) = 0, 1和x。
- en: Add an `equals()` method to `Polynomial`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Polynomial`添加一个`equals()`方法。
- en: 'Stave off overflow in `Rational` using the following ideas: .... Check for
    overflow in `Rational` and throw an exception if the result will overflow.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法避免`Rational`中的溢出：.... 检查`Rational`中的溢出，并在结果将溢出时抛出异常。
- en: Add a method `minus()` to `Rational` and support for negative rational numbers.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Rational`添加一个`minus()`方法，并支持负有理数。
- en: Write a program [Taylor.java](Taylor.java.html) that creates a polynomial (of
    rational coefficients) containing the first 10 terms of the Taylor expansion of
    e^x, sin x and e^x sin x.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Taylor.java](Taylor.java.html)，创建一个包含e^x、sin x和e^x sin x的泰勒展开的前10项的多项式（有理系数）。
- en: Expand (1-x)(1-x^2)(1-x^3)(1-x^4)...(1-x^n). When n = 3, this is 1 -x - x^2
    + x^4 + x^5 - x^6. In the limit, all of the coefficients are 0, +1, or -1.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开(1-x)(1-x^2)(1-x^3)(1-x^4)...(1-x^n)。当n = 3时，这是1 -x - x^2 + x^4 + x^5 - x^6。在极限情况下，所有系数都是0、+1或-1。
- en: Creative Exercises
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Chebyshev polynomials.** The *Chebyshev polynomials* are defined by solutions
    to the equation'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**切比雪夫多项式。** *切比雪夫多项式*由以下方程的解定义'
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although the solution appears to be trigonometric, its solution is a polynomial
    in x. The first few such polynomials are given below. In general T(n) = 2x * T(n-1)
    - T(n-2).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管解看起来是三角函数的，但其解是x的多项式。以下是前几个这样的多项式。一般来说，T(n) = 2x * T(n-1) - T(n-2)。
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Chebyshev polynomials have many special arithmetic properties which makes
    them useful mathematical objects in interpolation theory, approximation theory,
    numerical integration, ergodic theory, number theory, signal processing, and computer
    music. They also arise from the differential equation:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 切比雪夫多项式在插值理论、逼近理论、数值积分、遍历理论、数论、信号处理和计算机音乐中具有许多特殊的算术性质，它们也源自微分方程：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Write a program [Chebyshev.java](Chebyshev.java.html) that takes a command-line
    parameter N and prints out the first N Chebyshev polynomials.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Chebyshev.java](Chebyshev.java.html)，接受一个命令行参数N，并打印出前N个切比雪夫多项式。
- en: '**Hermite polynomials.** Write a program [Hermite.java](Hermite.java.html)
    that takes an integer input N and prints out the first N Hermite polynomials.
    The first few Hermite polynomials are given below. In general H(n) = 2x * H(n-1)
    - 2(n-1) * H(n-2).'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**厄米特多项式。** 编写一个程序[Hermite.java](Hermite.java.html)，接受一个整数输入N，并打印出前N个厄米特多项式。以下是前几个厄米特多项式。一般来说，H(n)
    = 2x * H(n-1) - 2(n-1) * H(n-2)。'
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Fibonacci polynomials.** Write a program `Fibonacci.java` that takes an integer
    input N and prints out the first N Fibonacci polynomials. The first few Fibonacci
    polynomials are given below. In general F(n) = xF(n-1) + F(n-2).'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**斐波那契多项式。** 编写一个程序`Fibonacci.java`，接受一个整��输入N，并打印出前N个斐波那契多项式。以下是前几个斐波那契多项式。一般来说，F(n)
    = xF(n-1) + F(n-2)。'
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'How does the sequence relate to the Fibonacci sequence? *Hint*: evaluate the
    polynomials at x = 1.'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个序列与斐波那契序列有什么关系？*提示*：在x = 1处评估多项式。
- en: '**Composition.** Add method for composing two polynomials, e.g., `f.compose(g)`
    shoudl return the polynomial f(g(x)).'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合成。** 添加用于合成两个多项式的方法，例如，`f.compose(g)`应返回多项式f(g(x))。'
- en: '**Laguerre''s method.** Write a program to find a real or complex root of a
    polynomial using Laguerre''s method. Given a polynomial p(z) of degree N and a
    *complex* starting estimate z[0], apply the following update rule until convergence.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拉盖尔方法。** 编写一个程序，使用拉盖尔方法找到多项式的实根或复根。给定一个N次多项式p(z)和一个*复数*起始估计z[0]，应用以下更新规则直到收敛。'
- en: '![](../Images/dbcc41df46e9beb206e9f850fdcb0b0b.png)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/dbcc41df46e9beb206e9f850fdcb0b0b.png)'
- en: Choose the sign of the term in the denominator to minimize |z[k+1] - z[k]|.
    Laguerre's method has superior global convergence properties to Newton's method,
    and guarantees to converge to a root if the polynomial has only real roots.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择分母中项的符号以最小化|z[k+1] - z[k]|。拉盖尔方法具有比牛顿法更优越的全局收敛性质，并且如果多项式只有实根，则保证收敛到根。
- en: '**Farey sequence.** The [Farey sequence](http://mathworld.wolfram.com/FareySequence.html)
    of order N is the increasing sequence of all rational numbers (in lowest common
    form) between 0 and 1 whose numerator and denominator are integers between 0 and
    N.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**费雷序列。** 阶数为N的[Farey序列](http://mathworld.wolfram.com/FareySequence.html)是所有介于0和1之间的有理数（以最简分数形式表示），其分子和分母是介于0和N之间的整数的递增序列。'
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Write a program [Farey.java](Farey.java.html) that takes a command line parameter
    N and prints the Farey sequence of order N. Use the rational number data data
    type created above.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Farey.java](Farey.java.html)，接受一个命令行参数N，并打印出阶数为N的费雷序列。使用上面创建的有理数数据类型。
- en: 'To compute the Farey sequence, you can use the following amazing relationship:
    If m/n and m''/n'' are two consecutive elements in the Farey sequence of order
    N, then the next element is m''''/n'''' which can be computed as follows (where
    the division is integer division):'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要计算费雷序列，您可以使用以下惊人的关系：如果m/n和m'/n'是费雷序列中顺序的两个元素，其阶数为N，则下一个元素是m''/n''，可以按照以下方式计算（其中除法是整数除法）：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Best rational approximation.** Newscasters often try to simplify unwieldy
    ratios like 0.4286328721345 to a nearby rational number with small numerator and
    denominator like 4/7. What is the best way to do this? The answer depends on the
    size of the denominator that you''re willing to tolerate, so our goal is to list
    the best approximations and let the reporter choose the desired one. Here are
    the best few rational approximations to the mathematical constant e:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最佳有理逼近。** 新闻播音员经常试图将难以处理的比率（如0.4286328721345）简化为一个近似的有理数，如4/7，其分子和分母较小。如何做到这一点？答案取决于您愿意容忍的分母大小，因此我们的目标是列出最佳逼近值，让记者选择所需的一个。以下是数学常数e的最佳几个有理逼近值：'
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Although 27/10 is a decent approximation to e, it is excluded from the list
    since 19/7 provides a better approximation with an even smaller denominator. The
    [Stern-Brocot tree method](http://www.cut-the-knot.com/blue/Stern.shtml) gives
    an elegant mathematical solution. Here''s the algorithm for generating the best
    upper and lower rational approximations to a real number x:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管 27/10 是对 e 的一个不错的近似值，但它被排除在列表之外，因为 19/7 提供了一个更好的近似值，且分母更小。[Stern-Brocot 树方法](http://www.cut-the-knot.com/blue/Stern.shtml)
    提供了一个优雅的数学解决方案。以下是生成实数 x 的最佳上下有理近似值的算法：
- en: Set the left endpoint to 0/1 and the right endpoint to 1/0.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将左端点设置为 0/1，将右端点设置为 1/0。
- en: Compute the mediant of left and right endpoints. The *mediant* of two rationals
    a/b and c/d is (a+c)/(c+d).
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算左右端点的中值。两个有理数 a/b 和 c/d 的*中值*是 (a+c)/(c+d)。
- en: If the mediant is equal to x (up to machine precision) stop. Otherwise, if the
    mediant is less than x, set the right endpoint to the mediant. Otherwise, set
    the left endpoint to the mediant.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果中值等于 x（机器精度内），则停止。否则，如果中值小于 x，则将右端点设置为中值。否则，将左端点设置为中值。
- en: As you iterate the above procedure, print out each new term if it provides a
    better approximation. Write a program [RationalApprox.java](RationalApprox.java.html)
    to print out these best rational approximations.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你迭代上述过程时，如果它提供了更好的近似值，请打印出每个新项。编写一个程序 [RationalApprox.java](RationalApprox.java.html)
    来打印出这些最佳有理近似值。
- en: '![Stern Brocot tree](../Images/d1bebd823baca1ef35400f8c40e76523.png)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Stern Brocot tree](../Images/d1bebd823baca1ef35400f8c40e76523.png)'
- en: '[www.cut-the-knot.com](http://www.cut-the-knot.com)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[www.cut-the-knot.com](http://www.cut-the-knot.com)'
- en: '**Continued fraction.** A continued fraction is an expression of the form a0
    + 1 / (a1 + 1 / ( a2 + 1 /a3) where a[i] are integers.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连分数。** 连分数是形式为 a0 + 1 / (a1 + 1 / ( a2 + 1 /a3) 的表达式，其中 a[i] 是整数。'
- en: Given a continued fraction expansion a0, a1, ..., an, write a program to determine
    what rational number it corresponds to.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个连分数展开 a0, a1, ..., an，编写一个程序来确定它对应的有理数。
- en: Given a rational number, find its continued fraction expansion. For example
    159/46 = 3 + 21/46 = 3 + 1 / (46/21) = 3 + 1 / (2 + 4/21) = 3 + 1 / (2 + 1 / (21/4))
    = 3 + 1 / (2 + 1 / (5 + 1/4)).
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个有理数，找到它的连分数展开。例如，159/46 = 3 + 21/46 = 3 + 1 / (46/21) = 3 + 1 / (2 + 4/21)
    = 3 + 1 / (2 + 1 / (21/4)) = 3 + 1 / (2 + 1 / (5 + 1/4))。
- en: '**Arbitrary precision rational arithmetic.** Write an ADT [BigRational.java](BigRational.java.html)
    that imlplements arbitrary precision rational numbers. *Hint*: re-implement [Rational.java](Rational.java.html),
    but use `BigInteger` instead of `int` to represent the numerator and denominator.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任意精度有理数算术。** 编写一个 ADT [BigRational.java](BigRational.java.html)，实现任意精度有理数。*提示*：重新实现
    [Rational.java](Rational.java.html)，但使用 `BigInteger` 代替 `int` 来表示分子和分母。'
- en: '**Complex rational numbers.** Implement a data type [RationalComplex.java](RationalComplex.java.html)
    ComplexRational that supports complex numbers where the real and imaginary parts
    are rational numbers. Use it for deeply zoomed plots of the Mandelbrot set to
    avoid floating point precision. (Also check for cycles in the Mandelbrot sequence
    using the doubling trick.)'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复有理数。** 实现一个数据类型 [RationalComplex.java](RationalComplex.java.html) ComplexRational，支持实部和虚部为有理数的复数。在深度缩放
    Mandelbrot 集的绘图中使用它，以避免浮点精度问题。（还要使用加倍技巧检查 Mandelbrot 序列中的循环。）'
- en: '**Polynomial degree.** Add a method `degree()` that computes the degree of
    a polynomial. Warning: this may not equal the size of the array if we subtract
    off two polynomials that original had degree 10, we may end up with a polynomial
    of degree 4.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式次数。** 添加一个计算多项式次数的方法 `degree()`。警告：这可能不等于数组的大小，如果我们从两个原本次数为 10 的多项式中减去，我们可能得到一个次数为
    4 的多项式。'
- en: '**Rational polynomials.** Create an ADT [RationalPolynomial.java](RationalPolynomial.java.html)
    for rational polynomials using arbitrary precision rational coefficients. Include
    a method `integrate(int a, int b)` that that integrates the invoking polynomial
    from a to b and returns the resulting rational number.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有理多项式。** 创建一个 ADT [RationalPolynomial.java](RationalPolynomial.java.html)，使用任意精度有理系数表示有理多项式。包括一个方法
    `integrate(int a, int b)`，用于从 a 到 b 对调用多项式进行积分，并返回结果有理数。'
- en: '**Polynomial division.** Write methods `div()` and `rem()` for division of
    two polynomials with rational coefficients. Use the following grade school method
    to compute the quotient and remainder of dividing u(x) into v(x), assuming v(x)
    is not zero. The quotient q(x) and remainder r(x) are polynomials which satisfy
    u(x) = q(x) v(x) + r(x) and degree(r(x)) < degree(v(x)).'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式除法。** 为具有有理系数的两个多项式编写 `div()` 和 `rem()` 方法。使用以下小学方法计算将 u(x) 除以 v(x) 的商和余数，假设
    v(x) 不为零。商 q(x) 和余数 r(x) 是满�� u(x) = q(x) v(x) + r(x) 且 degree(r(x)) < degree(v(x))
    的多项式。'
- en: If degree(u(x)) < degree(v(x)) return a quotient of zero.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 degree(u(x)) < degree(v(x))，则返回零商。
- en: Multiply v(x) by ax^b such that u'(x) = u(x) - v(x)ax^b has degree less than
    degree(u(x)) and the highest degree terms cancel out
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 v(x) 乘以 ax^b，使得 u'(x) = u(x) - v(x)ax^b 的次数小于 degree(u(x))，并且最高次项抵消。
- en: Return a quotient of ax^b + u'(x) / v(x), where the division is computed recursively
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个商 ax^b + u'(x) / v(x)，其中除法是递归计算的。
- en: To compute the remainder, first compute the quotient q(x), then return the remainder
    r(x) = u(x) - q(x) v(x).
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要计算余数，首先计算商 q(x)，然后返回余数 r(x) = u(x) - q(x) v(x)。
- en: '**Sturm''s algorithm.** [Sturm''s algorithm](http://mathworld.wolfram.com/SturmFunction.html)
    is an elegant method to determine the number of real roots of a rational polynomial
    over a given interval. Given a polynomial p(x), we define the Sturm chain as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**斯图姆算法。** [斯图姆算法](http://mathworld.wolfram.com/SturmFunction.html) 是一种优雅的方法，用于确定给定区间上有理多项式的实根数量。给定一个多项式
    p(x)，我们定义斯图姆链如下：'
- en: f[0](x) = p(x)
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: f[0](x) = p(x)
- en: f[1](x) = p'(x)
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: f[1](x) = p'(x)
- en: f[n](x) = f[n-1](x) % f[n-2](x) where % is polynomial remainderThe chain is
    continued until f[n](x) is a constant. Sturm's theorem asserts that the number
    of real roots in the interval (a, b) is equal to the difference in the number
    of sign changes of the two Sturm chains with x = a and x = b. Using rational arithmetic,
    we get the exact answer; with floating point we would need to take great care
    to avoid roundoff error.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: f[n](x) = f[n-1](x) % f[n-2](x) 其中 % 是多项式余数。链条一直延续，直到 f[n](x) 成为一个常数。斯图姆定理断言在区间
    (a, b) 中的实根数等于两个斯图姆链在 x = a 和 x = b 处的符号变化数的差异。使用有理算术，我们可以得到精确答案；使用浮点数时，需要非常小心以避免舍入误差。
- en: '**Polynomial gcd.** Implement Euclid''s algorithm on rational polynomials to
    find the greatest common divisor of two polynomials. Use the division algorithm
    from the previous exercise. As with Euclid''s algorithm for integers, we can use
    the following recurrence gcd((u(x), v(x)) = gcd(v(x), r(x)) where r(x) is u(x)
    % v(x) as defined in the previous exercise. The base case is gcd(u(x), 0) = u(x).'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式最大公约数。** 在有理多项式上实现欧几里德算法，以找到两个多项式的最大公约数。使用前一个练习中的除法算法。与整数的欧几里德算法一样，我们可以使用以下递归
    gcd((u(x), v(x)) = gcd(v(x), r(x))，其中 r(x) 是 u(x) % v(x)，如前一个练习中定义。基本情况是 gcd(u(x),
    0) = u(x)。'
- en: '**Polynomial implementation.** Suppose you need fast access to the individual
    coefficients, but the polynomial is sparse. Use a symbol table to store the coefficients.
    Probably BST so that you can print coefficients in order or to get the max degree.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式实现。** 假设您需要快速访问各个系数，但多项式是稀疏的。使用符号表存储系数。可能是二叉搜索树，这样您可以按顺序打印系数或获取最大次数。'
- en: '**Aribtrary precision integer arithmetic.** Develop your own library `MyBigInteger`
    that implements aribitrary precision integer arithmetic, just as in the Java library
    [BigInteger](http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html).'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任意精度整数算术。** 开发自己的库 `MyBigInteger`，实现任意精度整数算术，就像 Java 库 [BigInteger](http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html)
    中一样。'
- en: '**Fibonacci numbers.** Write a program [Fibonacci.java](Fibonacci.java.html)
    to compute Fibonacci numbers using big integers. Use Dijkstra''s recurrence.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**斐波那契数。** 编写一个程序 [Fibonacci.java](Fibonacci.java.html) 以使用大整数计算斐波那契数。使用迪杰斯特拉的递归。'
- en: '**Transfer function.** A *transfer function* models how the output of a system
    changes according to the input. Transfer functions arise in all areas of engineering,
    and can model the speaker in cell phone, the lens of a camera, or a nuclear reactor.
    The transfer functions associated with seismometers (and many other mechanical
    and analog electronic systems) are ratios of two (frequency domain) polynomials
    with real coefficients p(s) / q(s). Such transfer functions arise frequently in
    systems and control theory since the Laplace transform of common signals results
    in ratio of two polynomials. Zeros are values where numerator is 0, poles are
    values where denominator is 0. Poles are zeros are of fundmanental importance
    in understanding the behavior of the underlying system. Poles govern stability.
    If a system is stable and the input is changed, the output will converge to a
    constant value; if it is unstable (e.g., nuclear reactor at Chernobyl) the output
    will grow or fall indefinitely. If system is stable, then the real parts of all
    poles are positive. Zeros affect design of feedback controller. Ex: (3z - 1) /
    (z - 1/3)(z^2 - 1), 30(z-6)/ z(z^2+4z+13), (s+1)(s^2 + s + 25)/ s^2(s+3)(s^2+s+36).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**传递函数。** *传递函数* 模拟系统的输出如何根据输入变化。传递函数在工程的所有领域中都有应用，可以模拟手机扬声器、相机镜头或核反应堆。与地震仪相关的传递函数（以及许多其他机械和模拟电子系统）是具有实系数
    p(s) / q(s) 的两个（频域）多项式的比率。这种传递函数在系统和控制理论中经常出现，因为常见信号的拉普拉斯变换结果是两个多项式的比率。零点是分子为
    0 的值，极点是分母为 0 的值。极点和零点对于理解基础系统的行为至关重要。极点决定稳定性。如果系统稳定且输入发生变化，则输出将收敛到一个恒定值；如果不稳定（例如切尔诺贝利的核反应堆），输出将无限增长或下降。如果系统稳定，则所有极点的实部都是正的。零点影响反馈控制器的设计。例如：(3z
    - 1) / (z - 1/3)(z^2 - 1), 30(z-6)/ z(z^2+4z+13), (s+1)(s^2 + s + 25)/ s^2(s+3)(s^2+s+36)。'
- en: '**Arbitrary precision square root.** Write a program [ArbitraryPrecisionSqrt.java](ArbitraryPrecisionSqrt.java.html)
    that takes two integer command-line arguments x and n, and prints the square root
    of x, with n digits of precision. Use Newton''s method and java.math.BigDecimal.
    Newton''s method converges quadratically: each Newton step doubles the number
    of digits of accuracy.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任意精度平方根。** 编写一个程序 [ArbitraryPrecisionSqrt.java](ArbitraryPrecisionSqrt.java.html)，接受两个整数命令行参数
    x 和 n，并打印 x 的平方根，精确到 n 位。使用牛顿法和 java.math.BigDecimal。牛顿法收敛二次：每个牛顿步骤将精度位数加倍。'
