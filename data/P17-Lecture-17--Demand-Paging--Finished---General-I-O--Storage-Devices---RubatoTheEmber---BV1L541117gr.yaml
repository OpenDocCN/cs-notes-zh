- en: P17：Lecture 17： Demand Paging (Finished), General I O, Storage Devices - RubatoTheEmber
    - BV1L541117gr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P17：第17讲：按需分页（已完成）、通用I/O、存储设备 - RubatoTheEmber - BV1L541117gr
- en: Okay。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_1.png)'
- en: Welcome back from spring break everybody。 I'm going to take over for a little
    while now。 Hope you all had a good spring break and actually got to relax a little
    bit rather than work the whole time。 I got to go to Yosemite for the first time
    so that's great if you guys ever get a chance so。 Anyway。 we're going to pick
    up where Anthony left off and。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎大家从春假回来。我将接管一段时间。希望大家度过了愉快的春假，实际上有一点放松，而不是一直工作。我第一次去了优胜美地，那真是太棒了，如果你们有机会去的话，一定要去。好了，我们将从安东尼那里接着讲。
- en: Something that I can actually advance the slides here hello great so if you
    remember we've been talking a lot about。 Virtual memory and。 One of the advantages
    of virtual memory of course is that you can have more apparent memory than real
    memory。 Memory lots of other options there for virtual memory as well but if you're
    doing this idea of treating virtual memory。 As a caching system where the physical
    memory is the cash on the disk。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情我可以继续推进幻灯片，这里很好，如果你还记得，我们已经讨论了很多关于虚拟内存的内容。而虚拟内存的一个优点，当然是你可以拥有比实际内存更多的表面内存。虚拟内存还有很多其他的优点，但如果你将虚拟内存视为一个缓存系统，其中物理内存作为磁盘的缓存。
- en: Then we can come up with something like this which surprisingly may have actually
    shown up on your midterm as well。 And so the idea here is that if part of the
    time we have to take a page miss and go off on a disk and pull something in。 Then
    we can start talking about an average access time。 And so I'm calling this the
    effective access time here。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以得出像这样的结果，令人惊讶的是，它可能也出现在了你的期中考试中。所以这里的想法是，如果有一部分时间我们必须执行页面未命中并去磁盘拉取数据。那么我们就可以开始讨论平均访问时间。所以我在这里称之为有效访问时间。
- en: Just for the heck of it and you know this is just like caching so for instance
    this particular lower version here。 Hold on a sec I forgot I got to pull this
    up so this laser pointers right there。 So this particular lower。 Hit time here
    I'm going to use the second equation。 So what's the hit time well the hit time
    is that it's actually in DRAM right the miss penalty is what happens if we have
    to go out to disk and pull it back in。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅为了好玩，你知道的，这就像缓存一样。例如，这个较低版本的例子。稍等一下，我忘记了，我得先把这个调出来，这里是激光指示器。所以下面这个较低的。命中时间，我将使用第二个方程。那么命中时间是什么呢？命中时间就是它实际上在
    DRAM 中，未命中的惩罚是指如果我们必须去磁盘获取数据并重新加载它时发生的情况。
- en: And so let's see if we can compute something that way and so for instance what
    if your memory access times 200 nanoseconds。 The time to go to disk is eight milliseconds
    and the probability of miss is P。 And one minus P is probability of hit then we
    can actually write down an equation。 So for instance 200 nanoseconds is the hit
    time plus P times eight milliseconds。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们看看是否能以这种方式计算出一些东西。例如，如果你的内存访问时间是 200 纳秒，去磁盘的时间是 8 毫秒，未命中的概率是 P，1-P 就是命中的概率，那么我们实际上可以写出一个方程。例如，200
    纳秒是命中时间，再加上 P 乘以 8 毫秒。
- en: But as you learned in high school chemistry I hope you never mix units。 So we
    got to go for milliseconds to nanoseconds for instance and we come up with an
    equation like this。 Which doesn't seem all that interesting until you actually
    try to plug some numbers in so for instance。 If one access out of a thousand causes
    a page fault and our average access time is 8。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但是正如你在高中化学课上学到的，我希望你永远不要混淆单位。所以我们必须将时间单位从毫秒转换为纳秒，例如，我们得到这样的一个方程。这个方程看起来并不那么有趣，直到你真正尝试代入一些数字。比如说，如果每千次访问中有一次导致页面错误，而我们的平均访问时间是8。
- en: 2 microseconds even though DRAM is 200 nanoseconds。 So what's the bottom line
    here you never ever ever ever ever want a page fault right。 That's a factor of
    40。 And so really you know then you can do this equation which surprisingly we
    actually asked you about on the on the midterm as well。 But what if we want our
    slow down to be less than 10% well 10 adding 10% to 200 nanoseconds is multiplying
    by 1。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2 微秒，尽管 DRAM 的访问时间是 200 纳秒。那么这里的关键是什么呢？你永远都不想遇到页面错误，对吧？这相当于一个 40 倍的因子。所以实际上，你知道，接下来你可以使用这个方程，令人惊讶的是，我们实际上也在期中考试中考过这个内容。那么如果我们想要将延迟减少到
    10% 以下呢？那么 10 加上 10% 就是将 200 纳秒乘以 1。
- en: 1 we can do the calculation and see that we need to get a page fault in less
    than 400，000。 Accesses in order to actually have a reasonable access time。 So
    again never ever ever ever page fault。 Okay。 What did that lead to well that led
    to a discussion last lecture about。 Replacement policy when we're going to throw
    a page out to disk we got to be really careful about which one we picked。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行计算，看到我们需要在不到400,000次访问中发生页面缺失，才能确保合理的访问时间。所以再次强调，绝对不要发生页面缺失。好的。那么这导致了什么呢？这导致了上一讲关于**替换策略**的讨论，当我们要把一个页换出去到磁盘时，我们必须非常小心地选择要换出的页面。
- en: Okay， because this is the this is the cost。 All right。 now we're there any questions
    on this very simple calculation。 The conclusion from this is basically that we
    want our replacement policy to be really good。 All right。 And so we talked about
    the clock algorithm if you remember。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为这是成本所在。好，关于这个非常简单的计算有问题吗？从这个计算的结论基本上是我们希望我们的替换策略非常好。好的。所以我们讨论过时钟算法，如果你记得的话。
- en: So the idea is you take all of the pages in the system you link them together
    into one circular clock and you have something called a clock hand。 which when
    there's a page fault。 The assumption here is that every one of those physical
    pages there are in use。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个思路是，你将系统中的所有页面链接成一个循环的时钟，并且有一个叫做时钟指针的东西。每当发生页面缺失时。假设每个物理页面都在使用中。
- en: And so when there's a page fault we advance the clock hand。 And we try to figure
    out what page to replace。 Now the other thing Anthony talked a lot about it you
    remember was that l are you is a little too expensive to do on every access and
    so。 rather than getting the oldest page what we want is an old page right that's
    the whole point of several of these approximation。 algorithms。 The clock is no
    different。 And so the simple idea was there's a hardware use bit handled by the
    hardware in the TLB that basically says or in the page table entry。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当发生页面缺失时，我们会前进时钟指针，尝试找出要替换的页面。另一个安东尼讲过的重点是，LRU在每次访问时做起来有点太昂贵了。所以我们想要替换的不是最旧的页面，而是一个旧的页面。这就是这些近似算法的全部要点。时钟算法也不例外。因此，简单的思路是，硬件通过TLB中的使用位来处理，基本上是通过页表项来实现。
- en: That basically says this has been used。 And what how do we work that well we
    set it to zero。 And if by the time we get all the way back around it's set to
    one again we know that it was touched and therefore it's not an old page。 It's
    a new page new error。 Okay。 I didn't want to go into this in great depth because
    Anthony did but were there any questions on the clock algorithm in general。 Are
    we good。 You studied this at great depth before the exam so you'll you'll know
    it really well right。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是说这个页已经被使用过了。那我们怎么处理呢？我们把它设为零。如果等我们转回来时它又被设为1，我们就知道它被访问过，因此它不是旧页面，而是新页面，是新错误。好的，我不想深入讨论这个，因为安东尼已经讲过了，但关于时钟算法一般有没有问题？大家都好吗？你们在考试前已经深入学习过这个，所以应该都能很好的掌握吧？
- en: Okay。 I'm moving on。 Were there any questions you had that you always wanted
    answered about the clock algorithm。 No， okay。 So the other thing I wanted to just
    splash up here just to make sure that we're clear is the memory management unit
    is a piece of hardware。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我继续前进。有任何关于时钟算法的问题吗？一直想得到解答的？没有，好。接下来我想再强调一下，确保我们都清楚的是，内存管理单元是一块硬件。
- en: That has a page table in typically physical memory。 That's structured in a certain
    way。 And what's what's in that page table it's going to be these page table entries。
    So each one of these page table entries this is the x86 version for instance for
    32 bits。 32 bit address space looks like this。 So when you go to translate a virtual
    address what you do is you split it apart in the ways that we're talked about
    in great depth。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 页表通常存储在物理内存中，并且以特定的方式结构化。那么，页表中有什么呢？它就是这些页表项。所以这些页表项，每个页表项，比如这是x86版本的，32位地址空间看起来像这样。当你要转换虚拟地址时，你会按照我们之前讨论过的方式将其分解。
- en: And ultimately after going through the page table you come up with this page
    table entry。 That describes the physical page that you would translate to。 And
    for instance there's a page frame number which is where it's in memory。 And then
    a bunch of other bits in these access bits mean something。 For instance。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在通过页表之后，你会得到这个页表项。它描述了你将要转换到的物理页。例如，其中有一个页框号，表示它在内存中的位置。还有一些其他的位，这些访问位有特定含义。例如。
- en: there's the presence bit。 Which if it's not set to one this page table this
    page frame is invalid and we get a page fault。 Okay， and then all the other ones
    are kind of how we do things like the clock algorithm， etc。 Or how we mark a page
    is read only rather than read right。 Okay。 Any questions on this。 Okay。 so we're
    going to go ahead。 Now， of course the question I might ask you is。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个存在位。如果它没有设置为1，那么这个页面表项对应的页面框架是无效的，我们会发生页面错误。好的，接下来其他的位是用来执行类似时钟算法等操作，或者用来标记一个页面为只读而不是读写。好的，关于这一点有问题吗？好的，那我们接着往下讲。现在，当然我可能会问你们一个问题。
- en: Are all page table entries the same across all architectures。 Probably not right
    that's the kind of question that you'd put false on the exam and you explain well。
    Clearly this doesn't work for a 64 bit address space because there's only 20 bits
    of physical page frame okay。 Now， the thing that you kind of finished up at the
    very end of the last lecture was this second chance algorithm。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的页面表项在不同架构中是一样的吗？可能不是，对吧？这就是你在考试时会选择错误并解释原因的类型问题。显然，这对64位地址空间来说行不通，因为物理页面框架只有20位。好的，现在你们可能还记得上一讲结束时提到的那个二次机会算法。
- en: I what's funny about the second chance algorithm was。 They wanted to do clock
    but they couldn't because the OS team told the hardware team that they didn't
    need。 A use bit。 Okay， so， oops。 Now you got the hardware what do you do they
    came up with the second chance algorithm okay and I know that there were questions
    on this。 And in the。 Yeah， it says well so I just want to go through it quickly。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得有趣的是，二次机会算法的背景是他们原本想做时钟算法，但因为操作系统团队告诉硬件团队不需要使用位，所以不能这么做。好的，结果硬件团队该怎么办呢？他们想出了二次机会算法，好的，我知道有同学在这方面有问题。在嗯，教程中也有提到，我想快速地回顾一下。
- en: So the idea here is there are pages that are marked green and those are mapped。
    So that what does it mean to be mapped it means that if we look at our page table
    entry。 They're marked as physical， right， able， probably that means it's mapped。
    So these guys in green。 The hardware just takes a virtual address and translates
    it to a physical address。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的思路是，标记为绿色的页面就是已经被映射的页面。那么，什么叫做“映射”？就是说，如果我们查看我们的页面表项，它们被标记为物理页，对吧，能够访问，可能这就意味着它已经被映射了。那么这些绿色的页面，硬件只需要取一个虚拟地址并将其转换成一个物理地址。
- en: There's no operating system involved there at all。 Okay， so those are the green
    lighted pages。 And the reason we managed them FIFO I know there was a question
    on Piazza about that is， well。 we don't know anything else to do because the OS
    can't keep any statistics that it would need to do L are you or anything the best
    we can do is FIFO。 Okay， and I want to make sure everybody kind of caught that
    piece that's the best we can do because we're mapping directly from processor
    through the Mm you to the hardware to the physical pages and there。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里根本没有涉及操作系统。好的，以上是那些标记为绿色的页面。至于我们为什么用FIFO来管理它们，我知道在Piazza上有相关问题，原因是我们没有其他办法，因为操作系统无法记录它需要做LRU或其他算法的任何统计信息，我们能做的最好的就是FIFO。好的，我想确保大家都理解这一点，这是我们能做的最好的方法，因为我们是直接从处理器通过MMU到硬件，再到物理页面进行映射的。
- en: there is no information。 All right。 So how do we get it to be sort of an old
    page in the state in the fashion of clock well。 we keep some of the pages in yellow
    here。 In an LRU list but mapped as inaccessible。 So they're in memory， but the
    page table entry is marked as not present。 Okay。 and as Anthony said multiple
    times， how do we make this work we have double books。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有相关信息。好的，那么我们怎么才能把它做成类似时钟算法那样的“旧页面”状态呢？嗯，我们把一些黄色页面放在LRU列表中，但将其映射为不可访问。因此它们仍在内存中，但页面表项被标记为不可用。好的，正如Anthony多次提到的，如何让这个方法起作用呢？我们有了双重账本。
- en: So we kind of have books keeping track of these yellow pages and where they're
    supposed to be mapped。 even though they're not。 And so the moment the processor
    tries to go after a yellow page。 Well。 you get a page fault because it's marked
    as invalid or not present。 And then you do something with it。 Okay， so things
    in the green are accessed at full speed。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有类似账本的东西来跟踪这些黄色页面，以及它们应该被映射到哪里，尽管它们还没有被映射。所以当处理器尝试访问一个黄色页面时，嗯，你会遇到页面错误，因为它被标记为无效或不可用。然后你会对其做某些处理。好的，绿色页面则可以全速访问。
- en: But if we page fault we could page fault either because it's a yellow page。
    It's in memory but it's marked invalid。 Or it's on disk。 Those are our two options。
    What do we do well if it's a yellow page， then what's great is we just kick a
    green page to the yellow list。 Pull the yellow page to the green list。 And why
    can we do that while we take this green page and we market now is not present。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果发生页面错误，我们可能会因为页面是黄色的而发生页面错误。它在内存中但被标记为无效，或者它在磁盘上。这是我们的两种选择。那么我们该怎么办呢？如果是黄色页面，那么好处就是我们只需将一个绿色页面移到黄色列表，将黄色页面移到绿色列表。为什么我们能这么做呢？我们把这个绿色页面标记为现在不再存在。
- en: We take this yellow page we market is present。 Okay， and voila。 we didn't actually
    do any disk activity。 All we did is we adjusted the page table entries。 Okay。
    and why is that sort of LRU。 Why does that give us kind of an approximation for
    LRU。 Anybody want to take a stab on that。 Yeah。 Great。 I like that。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把这个黄色页面标记为已存在。好了，瞧。我们实际上没有做任何磁盘操作。我们做的只是调整了页面表项。好了，为什么这样就能近似LRU呢？为什么这能给我们一种LRU的近似呢？有人想试试回答吗？是的，很好，我喜欢这个回答。
- en: So if you use a page it's either going to be in the green you didn't say that
    but that's true or it was on the yellow and you pulled it back to the green so
    all the recent pages kind of keep going back to the green。 And if it's not recent
    it stays in that yellow list。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你使用一个页面，它要么会在绿色列表中，你没说过这一点，但它是对的，要么它在黄色列表中，然后你把它拉回到绿色列表，所以所有最近的页面都会回到绿色列表。如果它不再是最近的，它会停留在黄色列表中。
- en: And as we do this process eventually it kind of gets pushed further and further
    to the oldest page in the yellow list so that gives us an approximation right。
    And in fact， there's the other option here which is where we paid fault and it's
    not even in the yellow group in which case we pull it in from disk to the green。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个过程时，它最终会被推向黄色列表中最老的页面，所以这给了我们一种近似。实际上，还有另一种情况，如果我们发生页面错误，但它甚至不在黄色列表中，那时我们就会从磁盘将它拉到绿色列表中。
- en: And that point we kicked the LRU victim out and that is the oldest page because
    nobody's touched it a long time。 Okay。 That's it。 All right， that's why second
    chance list kind of gives us an oldest page just like the clock algorithm it's
    a little different。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，我们将LRU的牺牲者踢出去，那就是最老的页面，因为很长时间没人触碰它。好了。就是这样。好了，这就是为什么第二次机会列表有点像时钟算法，它会给我们一个最老的页面，尽管有些不同。
- en: They're more page faults involved。 But it is an approximation。 I put that in
    quotes because that's important to LRU。 Okay。 All right。 any other questions on
    this before I leave this。 Yeah。 Great question question is if I can do LRU on
    the yellow list why can't I do it on the green list。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及更多的页面错误。但它仍然是近似的。我把"近似"放在引号里，因为这对LRU很重要。好了。好吧，在我离开之前，还有其他问题吗？是的。很好的问题，问题是，如果我能在黄色列表上做LRU，为什么我不能在绿色列表上做呢？
- en: Right。 That was your question。 Anybody want to answer that？ Yeah。 So the answer
    that's great。 As was said here that would be really expensive。 And the reason
    is。 remember what is real LRU mean it means that every time I do a loader store
    to a page I move it out of the middle of the list to the front。 So that means
    every load in store rearranges the list。 Really expensive right。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对。那是你的问题。有人想回答一下吗？是的。所以答案是非常好的。正如这里所说的，那样会非常昂贵。而原因是，记住什么是真正的LRU，它意味着每次我对一个页面执行加载或存储时，我将它从列表的中间移到前面。所以这意味着每次加载或存储都会重新排列列表。真的很昂贵，对吧？
- en: So every loader store is multiple loads or stores。 So by approximating we let
    to have have some number of these pages be really fast in the green。 And。 and
    then we sort of filter them out and do LRU in the yellow but we're not doing it
    that frequently so it's not that expensive。 So that's the answer。 Good。 That answer
    your question。 Great。 So。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每次加载或存储实际上是多个加载或存储。所以通过近似，我们允许一些页面在绿色列表中非常快速。然后，我们将它们过滤出来，并在黄色列表中做LRU，但我们不会做得太频繁，因此它不会那么昂贵。所以这就是答案。很好。回答了你的问题吗？太好了。所以。
- en: and we can do this lots of things right we can make the green list really small
    to get really good LRU but now it's expensive we can make the green list really
    large。 And a small yellow list in which case we kind of have FIFO mostly behavior。
    But it's faster and of course if we have too much FIFO we end up with glides anomaly
    right which is a little bit unfortunate。 So good。 And this is a real algorithm
    they use this in VMS so that was this works。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做很多事情，没错，我们可以让绿色列表非常小，这样就能实现非常好的LRU，但是这样代价高昂；我们也可以让绿色列表变得非常大，黄色列表变得非常小，这种情况下我们基本上会有FIFO行为。但这种方式更快，当然，如果我们有太多FIFO行为，最终会导致滑动异常，这有点不幸。所以很好，这就是一个真实的算法，VMS就使用了这个算法，它是有效的。
- en: And the key thing there I think the reason we like to talk about this is really
    it shows you that you can do interesting things with the page table entries that
    aren't just well if it's invalid it's on disk and if it's valid it's in memory
    I just did something more interesting right I said well。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是我认为我们喜欢讨论这个的原因，实际上它向你展示了，你可以通过页表项做一些有趣的事情，而不仅仅是说，如果它无效，就在磁盘上；如果它有效，就在内存中，我做了一些更有趣的事情，对吧，我说，“嗯”。
- en: It could be mapped in in memory or not mapped in in memory or on disk and I
    did that by manipulating the page table entries and basically having another book
    set of books that are off side that let me know what's going on。 Okay， and the
    question here is I thought we can't do LRU and the green at all given the OS is
    not involved that's correct we can't do LRU at all on green but the overall system
    has an LRU ish behavior。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以映射到内存中，也可以不映射到内存或磁盘上，我通过操作页表项来实现这一点，基本上拥有另一本书集，这些书是离线的，可以让我知道发生了什么。好了，问题是我原以为在操作系统没有介入的情况下，不能做LRU，而在绿色区域根本做不了LRU，没错，绿色区域确实不能做LRU，但是整个系统有一种类似LRU的行为。
- en: So it's an old page to throw out not the not the oldest page just like the clock
    algorithm。 Okay and again why do we do this implementation because we're missing
    a use bit。 Okay the hardware didn't have a use bit。 Okay， good。 Any other questions
    burning questions across your in spring break and you just had to think about
    the second chance algorithm because it's just that interesting。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个旧页面要丢弃，而不是最旧的页面，就像时钟算法一样。好了，为什么我们要这样实现？因为我们缺少一个使用位。硬件没有使用位。好的，有其他问题吗？有没有什么燃眉之急的问题，在春假时你就得考虑第二机会算法，因为它实在是太有趣了。
- en: No。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_3.png)'
- en: Okay。 Okay， so we can take what I just showed you there。 Why is by the way why
    is the yellow called second chance。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好了，所以我们可以利用我刚刚给你们展示的那个方法。那么，顺便问一下，为什么黄色被称为“第二机会”？
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_5.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_5.png)'
- en: Because we unmap it right and it's still in memory and it gets a second chance
    to come back and be used right。 So we can do the same idea， even if we have a
    clock hand。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们把它取消映射了，对吧，它仍然在内存中，并且有第二次机会回来使用。对吧？所以我们可以用相同的思路，即使我们有一个时钟指针。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_7.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_7.png)'
- en: So we could do the regular clock algorithm but rather than doing the clock algorithm
    for every page fault what we do is we do the clock algorithm algorithm periodically
    to put a bunch of pages in what we call a free list。 And that free list we're
    going to manage FIFO so that when we need a new page on a page fault there is
    a page right there to use。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以做常规的时钟算法，但不是针对每个页面错误都执行时钟算法，而是周期性地执行时钟算法，将一堆页面放入我们所说的空闲列表中。在这个空闲列表中，我们将管理FIFO，这样当我们需要一个新页面时，页面错误发生时，列表里就有一个页面可以使用。
- en: And why is that advantageous well， if we have dirty pages which are pages that
    have been written。 we can put them the clock algorithm could say well they're
    dirty but they haven't been used much so put it on the free list。 And then by
    since it's managed FIFO by the time it kind of gets to the head of that list。
    the page out can have happened and it's no longer dirty it's clean。 Okay， and
    so this is a way。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这样有利呢？嗯，如果我们有脏页，也就是已经写入的页面，我们可以让时钟算法说它们虽然脏，但使用频率不高，因此把它放到空闲列表中。然后，因为它是按FIFO管理的，等它到达列表头时，页面换出就已经完成，而且它不再脏，变干净了。好了，这就是一种方法。
- en: a different way to allow us to buffer up a set of free pages and allow us to
    do the dirty page cleaning kind of in the background so that by the time we really
    need a page it's ready。 Okay， and it's kind of like a second chance list because
    well if I ever actually try to access one of these pages and it's on the free
    list I just pull it back into the clock at that point because I don't have to
    go to disk。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是允许我们缓冲一组空闲页面，并允许我们在后台进行脏页面清理，这样当我们真正需要一个页面时，它已经准备好了。好的，它有点像一个**第二次机会列表**，因为如果我试图访问这些页面之一，而它正好在空闲列表上，我就把它重新拉回到时钟算法中，因为我不必访问磁盘。
- en: Okay， and what's great about this idea is we no longer have the clock algorithm
    in the critical path when we really need a page to do a page fault service。 We
    just grab a free page we start the disk and voila。 rather than having to run the
    clock algorithm right at that very moment。 All right， questions。 Good。 And by
    the way， there's lots of variations on all of these different things so we're
    giving you some ideas of kind of the idea of how things work but having a free
    list that buffers up the clock algorithm really helps get it out of the critical
    path。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于这个想法的优点是，当我们真正需要一个页面来处理页面错误时，**时钟算法**不再位于关键路径上。我们只需抓取一个空闲页面，启动磁盘，瞧，页面就可以了，而不是在那个时刻就必须运行时钟算法。好了，有问题吗？很好。顺便说一下，这些不同的事情有很多变种，所以我们给你们提供了一些关于这些事情如何运作的想法，但是拥有一个空闲页面列表来缓冲时钟算法，确实有助于将它从关键路径中移除。
- en: Okay。 Good。 So now。 There's some details。 Okay， so for instance， what do we
    do。 When our algorithm whatever it is clock second chance second clock with a
    free list whatever decides that we're going to kick a page out entirely。 What
    do we do。 Because when we evict a page frame we've decided to replace it。 It's
    possible that it's pointed at by a bunch of different page table entries。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。很好。那么现在有一些细节。比如说，我们该怎么做？当我们的算法，无论是时钟算法、第二次机会算法、第二时钟算法、空闲列表算法，决定要完全驱逐一个页面时，我们该怎么做？因为当我们驱逐一个页面帧时，说明我们已经决定要替换它。这个页面可能被多个不同的页面表条目所指向。
- en: Process a process B they're both sharing a physical page they both have the
    page in their page tables。 So now when we want to kick that page out we got a
    reverse map to every page table that happens to have a pointer to it so we can
    unmap them。 Okay， that's called reverse page mapping。 And you could。 Trace through
    every page table linearly to find it。 That's obviously a bad idea right。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 进程A和进程B共享一个物理页面，它们的页面表中都有该页面。那么现在，当我们想要将这个页面驱逐出去时，我们需要反向映射到每个页面表中指向该页面的条目，这样我们就可以取消映射它们。好了，这叫做**反向页面映射**。你可以通过每个页面表线性地查找它，显然这是个坏主意，对吧？
- en: Or you could have something which is often called a core map。 Which maps from
    a physical page to all of the places that it happens to reside all of the page
    tables so that when we want to kick it out of memory and unmap it at that point。
    we can use this reverse page table to look it up。 Okay。 And it's got to be really
    fast because you got to hunt down all the page tables pointing at a given page
    frame at the time you're freeing。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用一个通常叫做**核心映射**的结构。它将物理页面映射到所有包含它的页面表中，这样当我们想要把它从内存中驱逐并取消映射时，我们就可以使用这个反向页面表来查找它。好了，它必须非常快，因为你需要在释放页面时迅速找到所有指向该页面帧的页面表。
- en: Because again that could be in the critical path of a page fault。 Okay。 and
    there's lots of options so for every page descriptor。 You keep a list of page
    table entries that point to it so if you go and you look。 I don't know in the
    Linux kernel for instance， you would see that every physical page or range of
    pages potentially has a little structure that describes it。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这可能是页面错误的关键路径。好的，并且有很多选择，所以对于每个页面描述符，你都要保留一个指向它的页面表条目的列表，因此，如果你查看它们，我不知道，比如在Linux内核中，你会看到每个物理页面或页面范围可能都有一个描述它的小结构。
- en: And so what you're trying to do is。 Trace through all of those pages to find
    the ones。 And go from。 go from that entry to all of the page table entries that
    have it。 And that could be very expensive。 And so Linux kind of buffers up multiple
    of those by actually handing out ranges of pages at a time。 And we're not going
    to go in detail and that because if you think about it too much you see that that
    kind of goes against our no external fragmentation from paging thing that we started
    with paging because now we sort of give ranges of pages but。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你现在要做的是，跟踪所有这些页面，找到需要的那些页面。然后从那个入口出发，去找到所有包含它的页面表项。这可能非常昂贵。因此，Linux通过一次分配一段页面来缓冲多个这些操作。我们不会详细讨论这个问题，因为如果你仔细想一想，你会发现这实际上与我们最初进行分页时的目标——避免外部碎片——是相违背的，因为现在我们实际上是给出了页面的范围。
- en: all right。 Questions。 All right。 So now let's deal with one last topic here
    so what we've been doing so far is talking about replacement。 And that's really
    how do we decide which physical page to get rid of if we need a new physical page
    because of paging activity。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，问题？好的，那么现在让我们处理最后一个话题。到目前为止，我们讨论的都是页面替换。实际上，问题是当需要新的物理页面时，我们如何决定要淘汰哪个物理页面，尤其是因为分页操作的发生。
- en: So how do we actually allocate memory among different processes so really the
    way this clock algorithm was described was kind of like there's one process in
    the whole world。 And it's paging right that was kind of the way it was described
    we didn't bother talking about the complexities of multiple processes。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们到底是如何在不同进程之间分配内存的呢？实际上，这个时钟算法的描述方式有点像假设整个世界只有一个进程，它正在进行分页操作，这就是最初的描述方式，我们没有去讨论多个进程的复杂性。
- en: But if we have different ones。 What do we do like for instance we could say
    that every process gets the same fraction of memory or processes get different
    fractions of memory。 Or they all share one big pot of memory right there's lots
    of options here。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有不同的架构呢？我们该怎么办？比如，我们可以说每个进程得到相同份额的内存，或者进程得到不同份额的内存，或者它们都共享一个大的内存池。这里有很多选择。
- en: And maybe some processes need to be completely swapped out of memory。 Okay so
    we may have to think about that。 But each process certainly needs a minimum number
    of pages in order to make progress if it's running。 And I can give you a really
    simple example。 Basically you want to make sure that every process it's fully
    loaded into memory can make forward progress。 Here's a simple example。 Just so
    that I give you something that's a little a little complex enough to be interesting。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有些进程需要完全从内存中交换出去。好的，我们可能需要考虑这个问题。但每个进程肯定需要一个最小的页面数，才能继续运行。如果一个进程正在运行，我可以给你一个非常简单的例子。基本上，你需要确保每个进程在完全加载到内存后，能够继续向前执行。这里有个简单的例子，虽然稍微复杂一点，但足够有趣。
- en: So for instance of the IBM 370。 And it turns out that the string move instruction
    needs six pages minimum in memory to make progress。 Why is that， because the instruction
    is six bytes。 And it might span two pages。 You need two pages to handle the from
    and two pages to handle the two。 So in order to restart the process that's running
    an SS move instruction。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，IBM 370的情况。事实证明，字符串移动指令至少需要六页内存才能继续执行。为什么？因为指令是六个字节，可能会跨越两页。你需要两页来处理“from”，再需要两页来处理“to”。因此，为了重新启动正在执行SS移动指令的进程，必须有足够的页面。
- en: you actually have to make sure that all six of those pages are in memory so
    that it can run。 Okay so now risk processors like risk five that you're well familiar
    with are much simpler than that because there's like an instruction and the data
    is going to access that's like two pages。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上必须确保这六个页面都在内存中，才能使其运行。好的，所以像你非常熟悉的RISC架构（比如RISC-V）要比这个简单得多，因为它只有一条指令，数据将访问的页面通常只有两页。
- en: Okay， but certainly there's an issue of minimum that we have to worry about。
    So we can have some replacement scopes here for instance we could talk about global
    replacement。 So when a process needs a page because it just page faulted。 we can
    imagine that every page frame is in one huge clock and we just grabbed the next
    one off the。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但当然我们必须关注最小化的因素。因此我们可以在这里讨论一些替换策略，例如，我们可以讨论全局替换。当一个进程因为发生了页面错误而需要页面时，我们可以想象，每个页面框架都在一个巨大的时钟中，我们就从时钟中抓取下一个页面。
- en: block right that was kind of the way we've been talking about it。 But more control
    could be given by a local replacement policy where we say each process gets so
    many pages of the total fraction and we run each process has its own clock。 Okay，
    now why might we want to do this second one。 So go ahead。 Okay it's faster because
    you don't need to synchronize okay， although with the clock algorithm。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 块对吧，这就是我们之前讨论的方式。但如果采用本地替换策略，可以通过给每个进程分配一定比例的页面来实现更多控制，每个进程都有自己的时钟。好吧，现在我们为什么要做第二种方式呢？来吧。好，它更快，因为你不需要同步，尽管使用时钟算法时。
- en: you kind of bypass a lot of synchronization especially if you have a free list
    right so you're really just pulling something off of a free list。 So speed is
    a possibility here but there are other other reasons as well yeah。 More fair。
    What do you mean by that， of course we don't know what fair means in this class
    right we。 don't know what it is。 So I like that answer so what it is is it's more
    fair。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上绕过了很多同步机制，尤其是当你有一个空闲列表时，实际上你只是从空闲列表中取出东西。所以速度在这里是一个可能性，但也有其他原因。是的，公平性更高。你是什么意思？当然，我们在这门课上并不知道“公平”究竟意味着什么，对吧？我们并不知道它是什么。所以我喜欢这个回答，公平的意思就是更公平。
- en: where fair means that one process can't just take a bunch of memory away from
    another one。 Okay。 And if you think about real time tasks， we did a little bit
    of discussion about real time。 then we might say we need a minimum number of pages
    to make sure that a process makes the right forward progress。 So we're going to
    give it some pages that nobody can take away from it。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“公平”意味着一个进程不能从另一个进程那里抢走大量内存。好吧。如果你考虑到实时任务，我们稍微讨论了一下实时任务，那么我们可能会说，需要给进程分配最小数量的页面，以确保它能够正确地向前推进。所以我们会给它一些其他进程无法夺走的页面。
- en: And if we do global replacement， then we have this issue that we might actually
    be having one process disturbing another one。 Okay， great。 So， and if you think
    about this a little bit if you think about what we did with scheduling we started
    with kind of round Robin。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行全局替换，那么就会出现这样一个问题：可能会有一个进程干扰到另一个进程。好吧，太好了。所以，如果你稍微想一想，回想一下我们在调度方面做的事情，我们一开始使用了类似循环调度的方式。
- en: We eventually got to CFS right the completely fair scheduler。 where we were
    giving a fraction of the CPU to every process that was a lot kind of easier to
    think about fairness。 Overall because we're giving a flow rate of CPU cycles to
    each process。 This is a similar idea we're going to give a， you know。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们到了 CFS（完全公平调度器），我们为每个进程分配一定比例的 CPU 时间，这样就更容易理解公平性了。总的来说，因为我们给每个进程分配了 CPU
    周期的流速。这是一个类似的概念，我们会为每个进程分配一个明确的最小页面数。
- en: a well defined minimum number of pages to each process。 So。 in addition to global
    versus local we have some other options here for instance。 if we do local now
    what well we could give every process an equal amount of memory。 You know if there's
    a hundred total frames of memory five processes every gets everyone gets 20。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除了全局与本地的区别，我们还有其他一些选项，例如，如果我们采用本地策略，现在会怎么做呢？我们可以给每个进程分配相等的内存。例如，如果总共有 100
    个内存页面，5 个进程，那么每个进程分配 20 个页面。
- en: Okay， or we could give some sort of proportional allocation。 So bigger processes
    get more memory。 Okay， so all I'm showing here with this equation is you take
    the total size of the process。 What fraction of that is of all of the processes
    sizes that's the fraction of memory they get。 Okay。 that one not complex once
    you kind of figure out what it's doing。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，或者我们可以进行某种比例分配。更大的进程获得更多的内存。好吧，我在这里展示的这个方程是：你先计算进程的总大小，然后这个大小占所有进程总大小的比例，就是它应该获得的内存比例。好吧，一旦你弄明白它在做什么，这个就不复杂了。
- en: but it's actually subtly bad can anybody tell me why this is not a good one。
    It sounds good。 Yeah。 Yeah， so you could fill up your program with a bunch of
    libraries that aren't doing anything。 Okay。 and in fact you do that totally non
    maliciously every day when you link a big crypto library but you only use the
    ECC portion of that to sign things。 So that's not a huge part of your program。
    And if what I'm doing to decide how many physical pages I get is based just on
    the size of my program then that's just。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上这有一些微妙的缺点，谁能告诉我为什么这不好吗？听起来不错吧？对，没错，你可能会让程序中充满一些什么都不做的库。好吧，实际上，你每天都在完全没有恶意的情况下做这件事，比如你链接了一个大型加密库，但实际上只使用了其中的
    ECC 部分来做签名。所以它并不是你程序的核心部分。如果我决定分配多少物理页面是基于我的程序大小，那么这就变得很单薄了。
- en: it has nothing to do with what I need and more to do with the sort of default
    size of the code right。 Okay， so another is I could do this by priority。 So I
    could have a proportional scheme using priorities rather than size。 You know，
    and so the behavior might be a process PI generates a page fault。 You still you
    select a frame from a lower priority process。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我需要的内容无关，更多的是与代码的默认大小有关，对吧？好吧，另一个方法是我可以通过优先级来做。所以我可以使用基于优先级的比例方案，而不是基于大小。你知道的，所以行为可能是进程
    PI 产生了一个页面错误。你还是从低优先级进程中选择一个帧。
- en: And maybe that makes some sense if you want to do priorities， right。 So maybe
    we should do something adaptive。 But if we want to do something adaptive。 we have
    to have a way to figure out how much memory a process actually needs rather than
    kind of these static ideas here。 Anybody think of what we might do adaptively
    to decide how much memory a process needs。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想做优先级的话，可能这有点道理，对吧？所以也许我们应该做一些自适应的事情。但是如果我们想做一些自适应的事情，我们就得有办法来确定一个进程到底需要多少内存，而不是依赖这些静态的概念。有没有人能想到我们可以采取什么样的自适应方式来决定一个进程需要多少内存？
- en: Predict the working set。 I like that。 That's possible。 Yeah。 How else might
    we do that。 So working set is a page size right。 How would we predict the working
    set。 I guess we have to define what working set means first right。 So let's get
    there。 Let's let's look at this。 What if we want to reduce capacity minutes。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 预测工作集。我喜欢这个。这是有可能的。是的。我们还可以怎么做呢？工作集是一个页面大小，对吧？我们怎么预测工作集呢？我猜我们得先定义工作集意味着什么，对吧？所以让我们搞清楚这一点。我们来看一下。如果我们想减少容量时间。
- en: Misses by dynamically changing the number of pages。 So remember a capacity miss
    was one of those C's。 For cash misses and what it said was I'm getting page faults
    because I don't have enough memory allocated to me。 And so if I increase the amount
    of memory。 And I'm not using FIFO。 then I should be able to reduce the number
    of misses。 Right。 More memory less misses。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态改变页面数来减少未命中。所以记住，容量未命中是缓存未命中的一种。它所表达的是，我正在遇到页面错误，因为我没有分配足够的内存。所以如果我增加内存的数量，而且我没有使用
    FIFO，那么我应该能够减少未命中的数量，对吧？更多内存，减少未命中。
- en: Unless we have FIFO and then we get the ladies anomaly right。 So we could do
    this。 We could say look。 If we look at the number of frames we give each process。
    If we give them a small number。 There'll be a lot of page faults。 If we give it
    a large number there'll be a lower number of page faults。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们使用FIFO，否则我们就会遇到所谓的“女士异常”，对吧？所以我们可以这么做。我们可以说，看一下我们给每个进程分配的帧数。如果我们给它们一个小的数字，就会发生很多页面错误。如果我们给它们一个大的数字，就会发生较少的页面错误。
- en: We could imagine a threshold。 And what we really want to do is try to adjust。
    So that processes are kind of in some range。 And if they're you know if they're
    missing way too much then they don't have enough memory and if they're missing。
    Little at all then they probably have too much memory and we could try to adjust
    them on a page frames to try to get ourselves in that desirable range。 Okay and
    that'll kind of trade off nicely if you got a bunch of processes you kind of everybody
    gets into that page fault rate。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个阈值。我们真正想做的是尽量调整。这样进程就能处于某个范围内。如果它们的错误率太高，说明它们的内存不足；如果它们几乎不发生错误，那么它们可能内存过多，我们可以尝试通过调整页面帧数来把它们调整到这个理想的范围内。好吧，这样做会有一个很好的折衷，如果你有很多进程，每个进程都能进入这个页面错误率范围。
- en: Okay， not quite the working set yet but it's it gets there right it's kind of
    trying to reduce the cost here。 This is more like that effective access time equation
    we started with this lecture right。 Trying to reduce it。 Okay， so。 What if we
    just don't have enough memory。 Thrashing that's going to happen yes we'll talk
    about thrashing but let's talk about this from a high level what if we just don't
    have enough memory。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在还不是工作集，但它已经接近了，对吧？它是在试图降低成本。这更像是我们在本讲中开始讨论的有效访问时间公式，对吧？试图减少它。好了，假设我们没有足够的内存。抖动会发生，没错，我们会讨论抖动，但我们从高层次来看这个问题，假设我们真的没有足够的内存。
- en: We had a little bit of a at the end of the the whole discussion on scheduling
    we kind of said well what if you just don't have enough CPU cycles。 You buy a
    new machine right。 So the thing you should know is resource allocation policies
    are always trying to allocate a limited resource among a bunch of different consumers。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个调度讨论的最后，我们稍微提到过，如果你只是没有足够的 CPU 周期怎么办？你就买一台新机器，对吧。所以你应该知道的是，资源分配政策总是在试图在多个不同的消费者之间分配有限的资源。
- en: And at some point you just don't have enough resource and you got to go for
    something bigger。 Okay。 so there is that's I know it's funny for me to say that
    but you got to keep that in mind always right at some point。 Your resource allocation
    just can't do the trick because you just don't have enough。 Okay。 so we'll go
    back to assuming we have enough for a moment。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到某个时刻，你的资源就不够了，你必须找到更大的资源来解决问题。好吧，我知道我这么说很有趣，但你必须时刻记住这一点，对吧？到某个时候，你的资源分配根本无法解决问题，因为你就是没有足够的资源。好吧，我们先假设我们暂时有足够的资源。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_9.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_9.png)'
- en: But let's talk about thrashing so the interesting thing about thrashing is is
    this process it's something that happens when a process just doesn't have enough
    pages。 which leads actually to low CPU utilization。 And the operating system spending
    most of its time swapping to disk。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们来谈谈抖动吧，抖动的有趣之处在于，这种情况发生在一个进程没有足够的页面时，这实际上会导致 CPU 利用率低，而操作系统大部分时间都在进行磁盘交换。
- en: So here we have an example where what we're going to do is， for instance。 we
    might add more and more threads to try to get a lot of computation going。 And
    for a while more threads give us more parallelism and everything's good but then
    we don't have enough pages and we don't have enough CPU and actually we drop off
    as we try to do more。 We just don't have enough for。 Okay， and so that thrashing
    range is kind of the point at which adding more parallelism of any sort or trying
    to do more work or whatever just doesn't work because we just don't have enough
    resource。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，我们要做的事情是，例如，我们可能会增加更多的线程来尝试进行大量计算。一开始，更多的线程为我们提供了更多的并行性，一切看起来都很好，但是之后我们没有足够的页面，也没有足够的
    CPU，实际上，当我们尝试做更多的事情时，效果就开始下降了。我们根本没有足够的资源。好吧，抖动的范围大致就是在这种情况下，任何类型的并行性增加或者尝试做更多的工作都不起作用，因为我们没有足够的资源。
- en: And when you're in paging like we've been talking about。 Thrashing is that situation
    where you try to access something。 Or you pull it off of disk。 Meanwhile you try
    another process that process doesn't have enough so it pulls something in off
    of disk right and so you're always sleeping every process is sleeping waiting
    for something to come in off of disk。 It runs when the thing comes back， and then
    it immediately pages again。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处于分页状态时，就像我们之前讨论的那样，抖动就是那种情况：你尝试访问某些内容，或者把它从磁盘拉出来，同时你又尝试另一个进程，这个进程也没有足够的资源，所以它也从磁盘拉取内容，对吧？所以，你总是会看到每个进程都在等待从磁盘加载某些东西。它会在数据返回时运行，然后立刻再进行分页。
- en: It's a page fault and you go to the next one and so nobody's making any progress
    all the operating system is doing is paging in things and paging out things and
    there's no actual computation happening。 Okay， that's thrashing。 All right， and
    so how do you detect thrashing。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是页面错误，然后你跳到下一个进程，所以没有进展发生，操作系统只是在进行页面调入和调出，没有实际的计算发生。好吧，这就是抖动。好了，那么我们如何检测抖动呢？
- en: And how do you respond to thrashing so what's a good way to detect thrashing。
    Sure。 you could see how many programs are waiting for disweight if they're all
    doing it it's probably bad right。 I'd also point this picture right so if you're
    everybody's up in that。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何应对抖动（thrashing）呢？检测抖动的一个好方法是什么？当然，你可以看看有多少程序正在等待交换，如果它们都在等待，那么很可能是有问题的，对吧？我还会指出这张图，看看如果每个人都处在那种状态下。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_11.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_11.png)'
- en: High miss rate area then things are bad。 Right。 So， um。 thrashing is just not
    good so now what do we do。 So thrashing typically happens because you got too
    many processes that are all running simultaneously and trying to have a minimum
    amount of memory。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 高失误率区域，情况就不好了。对吧？所以，嗯，抖动就是不好的。那么我们该怎么办呢？抖动通常是因为有太多进程同时运行，且它们试图使用最少的内存。
- en: And so perhaps， uh， if there's nothing better to do。 maybe it would make the
    whole system run better if we put a process completely out to disk swap it completely
    out of memory。 run the other ones for a while， and then pull it completely back
    into memory。 It sounds drastic。 but in fact that can speed the whole system up
    relative to trying to keep them all in memory and make some minimum amount of
    progress。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，也许，如果没有更好的办法，完全将一个进程换出到磁盘，彻底将其从内存中交换出去，运行其他进程一段时间，然后再把它完全调回内存，可能会让整个系统运行得更好。这听起来很激烈，但实际上，与试图保持所有进程都在内存中并让它们做最少的工作相比，这反而能加速整个系统。
- en: Okay， so now we can talk a bit about。 This question of the。 the working set
    right so here I have a graph that has execution time along the x axis。 And the。
    the y axis is actually。 Address number okay and so each one of these little gray
    things represents an access of that address at a given time flat。 Okay， everybody
    with me。 So a time whatever this is right here， if we look straight up。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以稍微谈一下这个问题。关于工作集的问题，在这里我有一个图，横轴是执行时间，纵轴实际上是地址数，好吗？所以这些小灰色的点代表在某一时刻对该地址的访问。好，大家跟得上吗？所以在任何时刻，如果我们直接看上去。
- en: we see all of the addresses that are in use at that period of time。 And in fact。
    if we were to look at a window。 At any give like a chunk of time and we could
    look at all of the addresses being accessed。 Those are all the addresses that
    we really need to have in memory in order for the thing to make progress right。
    So we could think of this， so often it's going to be called the working set in
    a moment。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是，在那段时间内所有被使用的地址。事实上，如果我们查看一个窗口，在任何一段时间内，我们可以查看所有被访问的地址。这些都是我们需要在内存中保持的地址，以便系统能够继续前进，明白吗？所以我们可以把它想成，通常它会被称为工作集。
- en: But if we were to scan that window across the execution。 what we're seeing is
    at any given sort of range。 What is， what are the patterns that are in use。 or
    what are the addresses that are in use。 Okay， and so this is the working set。
    And it's kind of the minimum number of pages for the process to behave well。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们将窗口扫描到执行的过程中，我们看到的是，在任何给定的范围内，正在使用的模式是什么，或者说，正在使用的地址是什么。好，这就是工作集。它是一个最小的页面数，足以让进程正常运行。
- en: And not enough memory for the working set basically leads to thrashing。 And
    so if we have too many processes and you add up all of their working sets。 Then。
    And they don't fit in memory， you know you're going to get thrashing。 Okay。 and
    so here we can be a little more formal。 So here's a working set model。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，工作集所需的内存不足基本上会导致抖动。因此，如果我们有太多的进程，且所有工作集的总和超出了内存的容量，你就会遇到抖动的情况。好，在这里我们可以稍微正式一点。这里是一个工作集模型。
- en: If we look at the page references and by the way these are just think of these
    as addresses。 Two。 six， one， five， seven， seven， five， one， so on。 The working
    set。 Basically says for any given time。 There's some delta representing history。
    And if we look at all of the pages that were accessed in that delta that says
    that that's the working set so one。 two， five， six， seven here。 And in this case
    it's three and four。 Okay。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看页面引用，顺便说一下，可以把这些看作是地址。比如 2，6，1，5，7，7，5，1 等等。工作集基本上是说，在任何给定的时刻，有一个表示历史的增量。如果我们看所有在这个增量中被访问的页面，那么这些就是工作集，所以在这里是
    1，2，5，6，7，当然，这里是 3 和 4。好。
- en: and so the thing to notice about this is the working set does change over time。
    Okay。 because programs go through different phases。 And when it changes。 there
    are different numbers of pages even in some cases。 So here the working sets only
    two pages before the working set was five。 Okay。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以需要注意的是，工作集是会随时间变化的。好，程序会经历不同的阶段。当它变化时，可能会有不同数量的页面，甚至在某些情况下。所以这里的工作集只有两个页面，而之前的工作集是五个页面。好。
- en: And so this represents。 What's required to be in memory in order to make forward
    progress。 And so in this， at this timeframe here， this first delta。 If we had
    a lot of processes that all had a lot of pages， the atom all up。 That's this more
    than you got。 Whereas in this period of time it's possible that there's a lot
    of processes。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这表示的是，为了能够向前推进，必须保留在内存中的内容。因此，在这里，在这个时间框架内，第一个增量，如果我们有很多进程，每个进程都有很多页面，那么将它们加起来可能会超过内存容量。与此不同，在这段时间内，可能有很多进程。
- en: each of which only need a few pages， you might not be thrashing。 So the total
    number of processes that are running that might be causing thrashing actually
    varies with time to this is a purely dynamical system。 Okay， and so really。 You
    know， the working sets basically a total set of pages referenced in the most recent
    delta whatever that is。 If delta is too small， it doesn't encompass the actual
    locality。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程可能只需要几个页面，那么你可能不会发生抖动（thrashing）。所以实际上运行的进程总数可能随着时间变化，造成抖动的情况也会变化，这是一个纯粹的动态系统。好，实际上，工作集基本上是指最近的增量中被引用的所有页面，增量是无论是什么。如果增量太小，它就无法包含实际的局部性。
- en: So we want this to be big enough to kind of average out。 References that are
    happening。 If it's too large， you basically it's like the whole program and it's
    like， well， that's not useful。 It's just all the pages of program reference， but
    it doesn't really talk about any given period of time。 And clearly if delta goes
    toward infinity， then we're talking about every address accessed by the program。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们希望它足够大，以便对发生的引用进行平均化。如果它太大，基本上就是整个程序，就像“嗯，那不有用”。它只是程序的所有页面引用，但并没有真正谈到任何特定时间段的情况。而显然，如果增量趋近于无穷大，那我们就讨论了程序访问的每一个地址。
- en: But if that program's running over a week or even an hour。 that's not very useful
    because it doesn't tell us anything about the sort of the time。 Full page fault
    rate at a given sort of range of time。 Okay。 and then if we take whatever the
    working set is a given time and we add it up across all the processes。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果这个程序运行了一周，甚至一个小时，那就不太有用了，因为它并没有告诉我们某一特定时间段内的页面错误率。好的，然后如果我们取某一时刻的工作集，并把它加总到所有进程中。
- en: that's the total number of physical pages we need。 To come and not be thrashing。
    And the thrashing basically happens if D is greater than the amount of memory
    we've got。 Okay。 and I'm going to pause here for a second。 So this is not complicated
    math。 It's just。 We compute the working set for every process。 We add it all up。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的总物理页面数。来避免抖动。抖动基本上发生在D大于我们拥有的内存时。好的，我在这里暂停一下。这不是复杂的数学问题。只是我们为每个进程计算工作集，然后把它们加总起来。
- en: And if that total number of pages is bigger than the memory we've got。 we got
    problems and we're thrashing。 Okay， questions。 Good。 So this is really defining
    thrashing in some sense， right。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些页面的总数大于我们拥有的内存，那我们就会遇到问题，并且开始抖动。好的，有问题吗？很好。所以，从某种意义上说，这实际上是在定义抖动的现象，对吧？
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_13.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_13.png)'
- en: So， here's a。 So somebody's asking here so thrashing can still happen even if
    there's no context switch。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里有个问题。有人问，即使没有上下文切换，抖动是否仍然会发生。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_15.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_15.png)'
- en: Well， when thrashing's happening， all you're doing is context switching。 because
    what's happening is you， you have to go out to disk and while the page is being
    pulled on for disk。 you're switching to another process。 So， rather than what
    said here in the chat。 I would say thrashing is a situation where the only thing
    you're doing is context switching。 Okay。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当发生抖动时，你所做的就是上下文切换。因为发生的情况是，你必须访问磁盘，而在页面从磁盘加载的同时，你正在切换到另一个进程。所以，与聊天中所说的不同，我会说，抖动是一种你所做的唯一事情就是上下文切换的情况。好的。
- en: it's the opposite。 Now， what about compulsory misses。 So if you think about
    compulsory misses are misses that occur the first time the pages seen。 Pages that
    are touched for the first time， or if we swap the whole process out for thrashing
    reasons and we bring it back in those can also be called compulsory misses。 And
    it turns out there's a couple of ways that operating systems deal with those。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相反的。那么，强制缺失又是怎样的呢？如果你考虑强制缺失，它是指页面首次被访问时发生的缺失。第一次被触及的页面，或者如果我们由于抖动原因交换整个过程并重新加载这些页面，它们也可以被称为强制缺失。结果发现，操作系统有几种方式来处理这些情况。
- en: One is this idea of clustering， which is when you get a page fault on one page。
    You get multiple pages around that page。 Okay。 What do we call that in caching。
    Spatial locality。 very good。 So， and as we're going to learn next time when we
    talk about discs。 especially for spinning storage， the efficiency of the disc
    reads increases tremendously if you read a bunch of stuff at the same time that's
    in a row。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种是聚类的概念，即当你在一个页面上发生页面错误时，会同时读取该页面周围的多个页面。好，我们在缓存中怎么称呼这种现象呢？空间局部性。非常好。所以，正如我们下次在讨论磁盘时将要学到的那样，特别是在旋转存储中，如果你同时读取一串连续的数据，磁盘读取的效率会大幅提升。
- en: Okay， if we grab a bunch of pages off of a single track。 That's going to be
    much more efficient than grabbing one page at a time。 And so this idea of clustering，
    when we get one miss we grab a bunch of them is actually a really good way of
    both being efficient at your page in and handling compulsory misses assuming there's
    some spatial locality。 Okay。 Now， the other thing that's kind of interesting it
    was it's been done in a couple of operating systems is if you actually have something
    tracking the working set of a process。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果我们从单个轨道中抓取一堆页面，那比一次抓取一页要高效得多。所以，集群化的这个概念，当我们遇到一次未命中时就抓取一堆页面，实际上是一种非常有效的方式，既能提高页面调度效率，也能处理强制未命中的情况，前提是存在某种空间局部性。好的，接下来，另一个有趣的地方是，一些操作系统已经实现了，如果你实际上有某种机制来追踪进程的工作集。
- en: So there's some page structure that says well where this process is right now
    the working set has these pages。 Then whenever the process goes to sleep and comes
    back。 you can go ahead and prefetch the working set to make sure that it doesn't
    page fault right away。 Right。 So this is kind of an interesting predictor it's
    sort of if I looked at what was the。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有一些页面结构会指示当前这个进程的状态，工作集包含这些页面。然后，每当进程休眠并重新启动时，你可以提前预取工作集，确保它不会马上发生页面错误。对吧？这是一种有趣的预测方法，基本上如果我查看过去的情况会是怎样的。
- en: what was the working set just before I put it to sleep or swapped it out to
    disk。 The moment I bring it back， I make sure all of those pages get prefetched
    in and now I'm unlikely to page fault right away because I have the working set
    in memory。 Okay。 Questions。 All right。 Good。 I think we're going to mostly leave
    paging here。 I did want to say something about the the midterm。 We finished it
    before spring break。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我把它挂起或交换到磁盘之前，什么是工作集？一旦我把它拿回来，我会确保所有这些页面都被提前取回，这样我就不太可能马上遇到页面错误了，因为我已经把工作集加载到内存中了。好的，大家有问题吗？好了，好的。我想我们大部分时间会结束今天的分页内容了。我确实想谈谈期中考试的事。我们在春假前就做完了考试。
- en: I think if you have any questions about regrade requests they're due tomorrow
    so make sure you get them in。 There is a question stream on Piazza for the midterm。
    During spring break I was answering a bunch of questions there's a few that are
    adding up there and we'll get back to it。 But anyway， our mean was about the same
    as the last one so we didn't end up with a much easier exam。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我想如果你们对重评分请求有任何疑问，它们明天截止，所以确保及时提交。Piazza上有一个期中考试的问题讨论区。在春假期间，我回答了很多问题，那里有一些问题在积累，我们会继续处理。但总的来说，我们的平均成绩和上次差不多，所以这次考试没有变得更简单。
- en: I guess that fifth question ended up being a little long for people。 There's
    a very long so Sean。 Our head to basically put an answer on Piazza that took you
    through every。 Access of that fifth problem so if you want to look at it in long
    detail as to what you could do。 You can take a look at it。 Don't be don't be scared
    off by the amount of text。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜第五个问题对大家来说有点长。问题非常长，所以Sean我们的小组负责人在Piazza上发布了一个回答，详细解释了第五个问题的每个步骤，如果你们想看详细的内容，可以查看。别被那些文字吓到。
- en: He tried to sort of he was very verbose。 Try to make sure it was clear to everybody。
    Project two is too Saturday。 I'm sure you're aware of that so perhaps I won't
    belabor it。 Project three last project coming up April third。 So notice that neither
    of these are April first so these are not April Fool's jokes but they are due。
    It's hard to believe that we're two thirds of the way through the class already。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 他试图把话说得非常详细，尽量确保每个人都能理解。第二个项目是这个星期六，大家应该都知道吧，所以我就不再多说了。第三个项目是下一个项目，截止日期是4月3日。请注意，这两个项目都不是4月1日，所以它们不是愚人节的玩笑，尽管它们确实有截止日期。真难以相信我们已经走完了三分之二的课程了。
- en: I guess I'm not used to co teaching so I guess it seems like it's been a while
    since I've stood up here but。 Anyway。 Don't forget don't forget to do your reread
    requests。 So I did want to do something else though from a bit of trivia so。 You
    guys are the crema the creme de la creme of。 CS and need to know your units。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我不太习惯共同授课，所以感觉好像已经有一段时间没在这里讲课了。不过，不管怎样。别忘了提交你们的重评分请求。我还想再分享一点小知识。你们是计算机科学领域的精英，必须掌握你们的单位。
- en: Okay we assume that you know units。 So for instance。 There were some people
    that actually asked on asked on the midterm you know how many microseconds are
    in the millisecond or something。 We assume you know that。 Okay so if you don't
    know that it wouldn't hurt to look this through okay。 Because I expected basic
    engineering。 Folks will know these things okay so here are ones that would be
    particularly helpful millisecond microsecond nanosecond picosecond。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们假设你知道单位。例如。有些人实际上在期中考试时问过，知道多少微秒等于一毫秒之类的。我们假设你知道这个。好吧，如果你不知道，查看一下也不会有什么坏处。因为我期望基础工程学的人会知道这些东西。好吧，这里有一些特别有用的单位，毫秒、微秒、纳秒、皮秒。
- en: I will assume that you know that a minute is 60 seconds in an hour is 3600 seconds。
    But。 So these are good things to know。 There's some others that are good to know
    so。 And this is going to come up in the lectures we're going to talk about next
    time and on。 Typically a bit is a little be and a bite is a big be okay so keep
    that in mind。 And a W。 Is a。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你知道一分钟是 60 秒，一小时是 3600 秒。但是。这些是很好的知识。还有一些其他的也很好知道。所以。这些将在接下来的讲座中涉及到。通常情况下，bit
    是小写的 b，byte 是大写的 B。好吧，记住这一点。并且 W 是一个。
- en: Depends。 Okay so W stands for word。 And normally。 I would say that a word represents
    the number of bits for an integer that's native on a processor。 So 32 bit processor
    a word is 32 bits。 Unfortunately。 Took over the world。 And because of the 80 86
    where a W was 16 bits。 If you're specifically dealing with an Intel processor
    W is 16 bits and a double word。 Is actually 32 bits。 All right I do not endorse
    that craziness I'm just telling you。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于。好的，W 代表字（word）。通常情况下。我会说字代表处理器原生整数的位数。所以对于 32 位处理器，一个字是 32 位。不幸的是。它接管了世界。因为在
    8086 中，W 是 16 位。如果你专门处理英特尔处理器，W 就是 16 位，双字（double word）实际上是 32 位。好吧，我并不支持这种疯狂的方式，我只是告诉你们。
- en: Okay so what this really means is if somebody if there's a W involved。 Ask if
    we're not clear okay because。 And for x86 a W really is 16 bits I hate it because
    I always forget it every time。 You know as a computer architect over the years
    W always to me met the native integer size of a processor。 But Intel it isn't
    so。 All right。 Here's some other ones that are fun okay now this is a little tricky。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这实际上意味着如果有人提到 W，问一下是否不清楚。因为。对于 x86 来说，W 实际上是 16 位，我讨厌它，因为我每次都会忘记。你知道，作为一名计算机架构师，多年来
    W 对我来说总是表示处理器的原生整数大小。但是对于英特尔来说并非如此。所以，好的。这里有一些有趣的东西，现在有点棘手。
- en: Because。 If you're dealing with memory。 Then killo。 Actually means a thousand
    24 bytes。 Okay now I think in 61 B they call that a kibby。 Okay it sounds like
    something the feed your cat right a kibby bite。 But。 Unfortunately in the real
    world a kilobyte kby。 Is the same as a kibby bite if you're dealing with memory。
    Okay but anyway。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为。如果你在处理内存。那么 kilobyte（千字节）。实际上意味着 1024 字节。好吧，现在我想在 61 B 中他们称之为 kibby。听起来像是你喂猫的东西，对吧？一个
    kibby 咬。 但是。不幸的是，在现实世界中，千字节 kby。如果你在处理内存的话，它和 kibby 咬是一样的。好吧，不管怎样。
- en: So as you can see here like a megabyte or a maybe is a thousand 24 squared which
    is two to the 20th。 Okay etc。 Ones that are this so this part you may not have
    really realized so a kilobyte or a tibby is two to the 10th。 Megabyte or a maybe
    is two to the 20th a gigabyte or a gibi is two to the 30th etc。 My favorites are
    kind of on the higher end like a tibby is to the 40th petabyte is a two to the
    50th and a an exabyte is two to the 60th。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到这里，比如说一个兆字节（megabyte）或者兆（maybe）是 1024 的平方，也就是 2 的 20 次方。好吧，等等。这部分你可能没有意识到，所以一个千字节（kilobyte）或者
    tebibyte（tiB）是 2 的 10 次方，兆字节（megabyte）或者 mebibyte（MiB）是 2 的 20 次方，千兆字节（gigabyte）或者
    gibibyte（GiB）是 2 的 30 次方，等等。我的最爱是更高端的，比如说 tebibyte（TiB）是 2 的 40 次方，拍字节（petabyte）是
    2 的 50 次方，艾克字节（exabyte）是 2 的 60 次方。
- en: Okay is anybody know what's next。 It's a it's a yada。 Anyway。 these are if you
    know these guys this is good okay so。 When you're dealing with pretty much everything
    but other than memory。 We use the powers of 10 so these are powers of two these
    are powers of 10。 You see the difference。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有人知道接下来是什么吗？它是 yada。总之。如果你知道这些，这很好。好吧。所以，当你处理几乎所有其他的东西，除了内存之外。我们使用的是 10 的幂。这些是
    2 的幂，这些是 10 的幂。你看到了区别了吗？
- en: Okay so when we talk about disk bandwidth or network bandwidth we're going to
    be and we talk about a gigabyte。 It's going to be 10 to the ninth bites。 Not you
    know not two to the 30th bites。 All right again。 I didn't invent this craziness
    this is just the way it goes all right and actually disk manufacturers。 Like to
    say they give you you know 100 gigabytes of something。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，当我们谈论磁盘带宽或网络带宽时，当我们谈到一个千兆字节时，它将是10的九次方字节。不是你知道的，2的30次方字节。好了，再次声明，这种疯狂不是我发明的，这就是事情的运作方式，实际上磁盘制造商喜欢说他们给你100GB的东西。
- en: And it's going to be down in this it's going to be 10 to the ninth bites not。
    You know 1。1 times 10 to the nine so look at your specs。 Now none of it this is
    not too much of a difference but you should know and it certainly could come up
    in an exam to know。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它将是10的九次方字节，而不是你知道的1.1乘以10的九次方。所以查看你的规格。现在这些差异不大，但你应该知道，它肯定可能会出现在考试中。
- en: And really。 I try to be careful and maybe give you the kibby notation but I
    wanted to put this down。 Just so you know that this only shows up in pretty much
    61 B and maybe core or some of those other questions sites but not necessarily
    in the real world so。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量小心，也许会给你们解释一下KiB表示法，但我想把这个写下来。只不过是让你们知道，这种情况几乎只会出现在61B课程和一些其他问题网站上，但不一定出现在现实世界中。
- en: You just got a deal。 Say it again。 The world is a strange and wonderful place。
    You know the thing about DRAM is you know it's kind of explicitly power of two
    because the addresses are you know。 Bits and its powers of two pretty much everything
    else in the world is you know powers of 10 because we have 10 figures。 Why is
    it that memory is the only one that tends to be in the kibby's I don't know or
    the maybe or the gibby's。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须处理它。再说一遍，世界是一个奇怪而美妙的地方。你知道DRAM的特点就是它是显式的2的幂，因为地址是，位数，它们是2的幂，几乎世界上其他的东西都是10的幂，因为我们有10个数字。为什么内存是唯一一个倾向于使用KiB，我不知道，或者是MiB，或者是GiB。
- en: It's just the the rule of the world。 And some manufacturers actually even have
    tried to be。 And they're full so sometimes you actually see this。 G。I。B。 notation。
    Most of the time you don't but I thought I'd point this out to you one。 So that
    you know to look for it in exams maybe but to you actually if you're looking at
    specs for anything just look。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是世界的规则。有些制造商实际上甚至尝试过这样做。它们已经满了，所以有时候你实际上会看到这种G.I.B表示法。大多数时候你不会看到，但我想指出这一点。这样你可能在考试时知道要留意它，如果你实际上在查看任何东西的规格时，只需留意。
- en: And and sometimes people like to say that this because the disk manufacturers
    do these。 Powers of 10 instead of the powers of two they're cheating there。 You
    know the people that they're buying from them。 I don't know that that's true it's
    just this is good again it's the way the world is so just watch for it。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候人们喜欢说，磁盘制造商使用这些10的幂，而不是2的幂，这样他们是在作弊。你知道，他们购买的人他们的供应商可能是这样。我不知道这是否成立，只是，这样的规则就是如此，所以留意一下。
- en: But I do expect that you guys have some notion of most of these。 Okay you could
    put you could put some of the common ones on a cheat sheet or something if you
    need to。 All right。 Who units。 We don't talk about Bruno。 Oh wait we talked about
    units okay now。 I guess we don't talk about Bruno hasn't been a thing here at
    Berkeley。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但我确实期望你们对大多数这些概念有所了解。好的，你可以把一些常见的概念放在备忘单上，如果需要的话。好了，单位。我们不谈布鲁诺。哦，等一下，我们谈论的是单位。好了，现在，我想我们不谈布鲁诺，在伯克利这里已经不是问题了。
- en: Should all you should all see in console I guess I with my with my 10 year old
    I get to see a lot more animated stuff。 Okay。 Let's let's move on。 So I'd like
    to start moving in toward。 I hope and we'll talk about discs and file system so
    that's kind of the next major topic。 I did want to finish up one thing here though。
    So memory management and Unix excuse me Linux is a lot more complex than the examples
    we've been giving so far。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在控制台上你们都会看到，我猜与我的10岁孩子在一起，我能看到更多的动画内容。好了，我们继续。接下来我想开始谈论，我希望我们能深入讨论磁盘和文件系统，这是下一个主要话题。我确实想完成一件事。关于内存管理，Unix（抱歉）Linux比我们迄今为止给出的示例要复杂得多。
- en: So in Linux for instance there are a bunch of memory zones。 So there's the zone
    DMA。 Which is physical memory less than 16 megabytes。 There's the zone normal。
    Which is kind of between 16 megabytes and 896 megabytes and then there's the high
    memory which is everything else。 Where did this come from well everything comes
    from history。 And so historically。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在 Linux 中，例如，有很多内存区域。比如 DMA 区，它是小于16MB的物理内存。还有普通区域，它介于16MB到896MB之间，然后就是高内存，剩下的部分。这些是怎么来的？嗯，一切都源于历史。所以从历史上看。
- en: You had 32 bit processors or 16 bit processors。 And this was a lot of memory
    and so this normal zone was kind of what you had。 And now of course nobody buys
    a machine that has less than you know 4 8 terabytes of memory on it right so this
    this memory map is already way outdated but it's still functional。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你曾经有过32位处理器或16位处理器。这时内存非常大，所以这个普通区域基本上就是你能拥有的。现在，当然没人会购买内存少于4到8TB的机器，所以这个内存映射已经完全过时，但它仍然有效。
- en: Okay， and in particular in the old days if you did DMA and we'll talk more about
    that maybe at the end of the lecture if we get there but certainly next time。
    You could only do it cleanly if you're in the lower 16 megabytes of physical memory。
    And that was that was sort of a restriction for the old DMA engines。 Okay。 And
    so。 you know that was DMA able on the Iza box， believe it or not from the old
    IBM PC。 Okay。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，特别是以前，如果你进行 DMA，我们可能在讲座结束时再详细讨论这个，如果我们能讲到的话，但肯定会是下次。你只能在物理内存的前16MB内进行干净的
    DMA 操作。这对老旧的 DMA 引擎来说是个限制。好的。所以，你知道，那个时候在老旧的 IBM PC 上也可以做到 DMA。
- en: but we still have this these constants appear in Linux if you take a look for
    them。 So every zone has its own free list and to our you list which are kind of
    in a clock。 Okay。 the act in the inactive so you thought it was complicated to
    have。 One clock or multiple clocks well every zone has its own two clocks that
    get swapped。 Okay。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然在 Linux 中看到这些常量，如果你查找它们的话。所以每个区域都有自己的空闲列表和活动/非活动列表，它们有点像时钟。好的。活动和非活动的部分，你以为有一个时钟或多个时钟很复杂吗？其实每个区域都有自己的两个时钟，它们会交换。好的。
- en: Many different types of allocation in the kernel okay there's slab allocators
    which allocate big chunks of pages。 There are per page allocators。 There are the
    ability to do mapped and unmapped allocation lots of interesting things there
    many different types of allocated memory。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中有许多不同类型的分配。好的，有 slab 分配器，它分配大块页面。也有每页分配器。还有映射和非映射分配的能力，很多有趣的事情，有很多不同类型的分配内存。
- en: So when you do when you do allocation of memory， you can get what's called anonymous
    memory。 which is basically like keep and stack that's not necessarily backed by
    a file。 Or you can memory map files into memory and access the files like you're
    reading virtual memory will do we'll talk about that next time。 Okay。 So lots
    of different types of memory and we'll also talk about the slab allocated a little
    bit。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你进行内存分配时，你可以获得所谓的匿名内存，这基本上就像是堆栈并不一定是由文件支持的。或者你可以将文件映射到内存中，并像读取虚拟内存一样访问这些文件，我们下次会讨论这个。好的。所以有很多不同类型的内存，我们还会稍微讨论一下
    slab 分配。
- en: I think next time or one of the next times。 And then of course his allocation
    priorities and so on。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我想下次或下下次再做吧。然后，当然，他的分配优先级等等。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_17.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_17.png)'
- en: One thing that's kind of interesting is pre meltdown。 Okay。 This was the typical
    memory map and you've already seen this but I thought I would make this clear
    so I'm 32 bit virtual space。 Everything from zero up to zero X C was kind of user
    addresses。 And then zero X C up to FFFF was kind of kernel addresses。 And that's
    just the way it was allocated。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有件事挺有意思的，那就是在“熔断”之前。好的，这是典型的内存映射，你之前已经看过了，但我想澄清一下。所以我是32位虚拟空间。从零到0xC，基本上是用户地址。然后从0xC到FFFF，是内核地址。这就是它的分配方式。
- en: Okay。 And what does that need remember in our page table entry there's the little
    user bit。 And then it's just DTE。 And meant that any addresses up here。 Had that
    user bit equal to zero because they were for kernel only。 If you go to 32 or go
    from 32 to 64 bits。 Then it's much bigger。 Okay， 64 bits is just big。 Okay。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么这需要记住什么呢？在我们的页面表项中有一个小的用户位。然后它就是 DTE。这意味着在这里的任何地址，那个用户位都是零，因为它们仅供内核使用。如果你从32位切换到64位，那么它就大得多。好的，64位就是大。好的。
- en: and so really what the processors do is。 And then we're going to do this。 And
    then we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
    And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以实际上，处理器做的就是这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_19.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_19.png)'
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_21.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_21.png)'
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_23.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_23.png)'
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_25.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_25.png)'
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_27.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_27.png)'
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
    然后我们要做这个。 然后我们要做这个。 然后我们要做这个。 然后我们要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。然后我们将做这个。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_29.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_29.png)'
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: And then we're going to do this。 And then we're going to do this。 And then we're
    going to do this。 And then we're going to do this。 And then we're going to do
    this。 And then we're going to do this。 And then we're going to do this。 And then
    we're going to do this。 And then we're going to do this。 And then we're going
    to do this。 And then we're going to do this。 And then we're going to do this。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。然后我们将要做这个。
- en: Okay。 Let's very quickly get moving on IO now。 Sorry。 This is run a little long
    today。 but maybe we can just work through this。 And I'll give you a break。 I promise
    next time。 So if you were to look at the Hennissi Patterson book on computer，
    architecture。 it talks about the five components of a computer。 And there's a
    bunch of stuff inside the inside the processor。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们快速进入输入输出（IO）的部分。抱歉，今天讲得有点长，但也许我们可以继续讨论下去。下次我保证给你们休息时间。如果你查看Hennissi Patterson关于计算机架构的书，它讨论了计算机的五个组成部分，还有处理器内部的许多内容。
- en: You know， there's a data path and there's the pipeline and all of that stuff。
    Which is great and fun to do。 And I'm a computer architect myself。 So I think
    that's really fascinating。 But if you only have a processor with no IO。 you've
    got a disembodied， brain that really isn't interesting。 Okay。 It's a， it's a heating
    element。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，数据路径和流水线这些东西。它们很棒，做起来也很有趣。我自己是一个计算机架构师，我觉得这些东西非常吸引人。但是，如果你只有一个没有输入输出（IO）的处理器，那就像是一个没有身体的脑袋，根本没有趣味。好的，那只是一个加热元件。
- en: All right。 So really what's interesting about processors today is their IO。
    And so that's why we。 we have to have some interesting discussions。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，今天处理器最有趣的地方是它们的输入输出（IO）。所以这就是为什么我们必须进行一些有趣的讨论。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_31.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_31.png)'
- en: about how you do IO。 So how do you do IO？ Well， so far in 162 we've started
    all sorts of abstractions。 API is provided by OS applications。 We talked about
    synchronization and scheduling。 But we haven't talked about IO。 Okay。 And that
    was intentional。 But without IO computers are useless。 Okay。 So really。 The most
    interesting and intricate part of。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何进行输入输出（IO）。那么，如何做输入输出呢？到目前为止，在162课程中，我们已经介绍了各种抽象。操作系统应用程序提供的API。我们讨论了同步和调度，但我们还没有讨论输入输出（IO）。好的，这是有意的。但是没有输入输出（IO），计算机是没用的。好的，所以真正的，最有趣和最复杂的部分是。
- en: The most interesting part of the project is how do we do IO？
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目最有趣的部分是我们如何处理输入输出（IO）？
- en: And more complex is there's thousands and thousands of different。 types of devices
    and they're all operating at different speeds。 And the question is kind of how
    do you make it all work together？ You know。 how do we standardize interfaces？
    Devices are unreliable。 We get media failures。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的是，存在成千上万种不同类型的设备，它们都以不同的速度运行。问题是，如何让它们协同工作？你知道，如何标准化接口？设备是不可靠的，我们会遇到媒体故障。
- en: We get transmission errors。 How do we deal？ How do we make them reliable？
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了传输错误。我们该如何处理？我们如何使它们可靠？
- en: Devices are unpredictable or slow。 How can we manage them if we don't know what
    they'll do or when？
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 设备是不可靠的或者运行缓慢。如果我们不知道它们会做什么或何时发生，我们该如何管理它们？
- en: So what's interesting about this is if you remember at the beginning of class
    of the term。 we talked about kind of this virtual machine abstraction idea where
    what we were going to do was we were going to give a virtual abstraction to the
    programmer that made it look like they had all an infinite amount of memory that
    all the devices were perfect。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里有意思的地方是，如果你还记得学期开始时我们谈到的那个虚拟机抽象的想法，我们要做的就是给程序员一个虚拟抽象，使得他们看起来像是拥有无限的内存，所有设备都是完美的。
- en: And so therefore they didn't have to program worrying about all of those messy
    physical details。 Okay， that was kind of a that was a meme at the beginning， right？
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们不必编程去担心所有这些混乱的物理细节。好吧，那一开始的确是一个梗，对吧？
- en: And so here we're not coming back to that and saying， well， look at all of these
    devices out there。 They have all of these failings and limitations and what we
    need to do now is figure out how to come up with a very clean virtual API。 That's
    going to actually allow us to make it easy to program。 Okay， and that's going
    to be our goal。 How do we virtualize these systems in an interesting way。 And
    if you think about IO。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在回过头来看，看看这些设备的状况。它们都有这些缺点和局限性，我们现在需要做的就是弄清楚如何提出一个非常干净的虚拟API。这样我们就能让编程变得更简单。好的，这就是我们的目标。我们如何以一种有趣的方式虚拟化这些系统。如果你考虑输入输出（IO）。
- en: it's got a whole bunch of possibilities here right there's networking。 There's
    disk IO for storage。 There's SSDs。 There's keyboards。 There's mice。 There's speakers。
    There's all of this stuff。 And so obviously we can't cover all IO， but we're going
    to talk about how does an operating system give you a virtualized view of the
    IO。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它这里有很多可能性，对吧，网络通信，存储的磁盘 I/O，固态硬盘（SSD），键盘，鼠标，扬声器，还有所有这些东西。所以显然我们不能涵盖所有 I/O，但我们将讨论操作系统是如何给你一个虚拟化的
    I/O 视图。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_33.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_33.png)'
- en: Okay。 And so if you remember， when we had our IO basics here。 we sort of had
    this protection boundary， where all the IO was buried underneath that protection
    boundary。 And， for instance， starting something up， we have to pull data off of
    storage into memory。 We might do some IO and the processor is running code that
    has a virtual abstraction that somehow makes the storage and networking devices
    look ideal。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果你还记得，当我们讨论 I/O 基础知识时，我们有一个保护边界，所有的 I/O 都埋在这个保护边界下面。例如，在启动某些东西时，我们必须将数据从存储中拉取到内存中。我们可能会进行一些
    I/O，处理器在运行的代码有一个虚拟抽象，能够让存储和网络设备看起来像是理想的设备。
- en: Okay。 And so the OS here this red boundary provides common IO services in the
    form of IO。 And really we had this range of timing scales， which is appropriate
    given what we talked about earlier。 which is if you look at the time for a cash
    L one cash access might be point a half a nanosecond or smaller picoseconds now。
    Versus sending a packet from California to the Netherlands and back， you know。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以操作系统在这里，这个红色边界提供了以 I/O 形式的通用 I/O 服务。实际上，我们有这一系列的时间尺度，这是合适的，正如我们之前所讨论的那样。如果你看一下缓存
    L1 缓存访问的时间，可能是0.5纳秒，甚至更小，可能是皮秒级别。然后是从加利福尼亚发一个数据包到荷兰再回来，你知道。
- en: might be 150 milliseconds。 See how quickly I did that computation there， right。
    So， um。 we've got a deal with all of these scales in the same IO subsystem。 So，
    you know。 here's an example it's a very old one， but for instance the device transfer
    rates for the sun enterprise 6000。 I just put this up because I thought it was
    kind of interesting right。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是150毫秒。看看我做这次计算的速度，对吧。所以，嗯。我们要处理这些不同规模的所有 I/O 子系统。所以，你知道，这里有一个例子，虽然很老，但比如说，Sun
    Enterprise 6000的设备传输速率。我把这个放上来是因为我觉得它有点有趣，对吧。
- en: Basically the devices vary by 12 orders of magnitude in performance。 12 orders
    of magnitude。 So whatever subsystems we come up with， they got to deal with 12
    orders of magnitude difference in performance。 Okay。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这些设备的性能差异达到12个数量级。12个数量级。所以我们无论提出什么子系统，都必须处理性能差异达到12个数量级的情况。好的。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_35.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_35.png)'
- en: So， you know， another picture here is IO devices you recognize are supported
    by IO controllers。 Okay。 And so those IO controllers are going to control devices
    and the OS is going to talk to the IO controllers。 And so we're going to have
    to talk about how processes read and write。 And do access to the IO through IO
    controllers。 And the IO controllers are going to be the centralized thing that
    helps us build our interfaces here。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你知道，另一个图示是 I/O 设备，你能认出来的都是由 I/O 控制器支持的。好的。这些 I/O 控制器将控制设备，操作系统将与 I/O 控制器进行通信。所以我们必须讨论进程是如何通过
    I/O 控制器进行读写和访问 I/O 的。I/O 控制器将是帮助我们构建这些接口的中心化组件。
- en: Okay。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_37.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_37.png)'
- en: So， here's an example of kind of a modern system where there's a processor。
    And that's the thing with the big fan on it because it's hot。 but then it might
    have a bridge to PCI buses。 And there might be an IO card to SCSI buses that talk
    to discs。 There might be expansion buses to other things that might have parallel
    ports they might have serial ports。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里有一个现代系统的例子，系统里有一个处理器。那就是带有大风扇的东西，因为它很热。但它可能有一个桥接器连接到 PCI 总线，可能还有一个 I/O
    卡连接到 SCSI 总线，负责与磁盘通信。还可能有扩展总线连接到其他设备，可能有并行端口，也可能有串行端口。
- en: There's a network networking cards that are connected and do really high performance。
    And so。 you know， the graphics controllers all of these stuff is all connected
    via this web of buses and somehow has to be controlled by that one processor。
    So there's， there's a lot of interesting things here complex right。 How many of
    you have opened up one of your desktop or your laptop and looked inside。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有网络卡连接起来，做非常高效的工作。所以，你知道，图形控制器，所有这些东西都是通过总线网络连接的，并且必须由那个处理器来控制。所以这里有很多有趣的、复杂的东西。对吧？你们中有多少人打开过桌面电脑或者笔记本电脑，看看里面是什么样子？
- en: How many people have done that。 Any of you。 The processor is a big thing right
    but there's a lot of stuff。 Right。 The other stuff is all of this right and so
    we want to try to get a handle on that。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少人做过这个？你们中的任何人？处理器是一个大东西，但还有很多其他东西。对吧？其他的东西都是这样的，所以我们要尝试搞清楚这一点。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_39.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_39.png)'
- en: It's interesting。 Okay。 And by the way， this is， I still highly recommend 152
    great class。 That'll tell you what's inside the processor。 So I used to teach
    it as well。 So what's a bus。 So。 you know， here I have a bunch of things with
    buses on it the word bus。 So what is a bus。 So it's a common set of wires for
    communicating among devices with protocols attached。 Okay。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有意思。好的，顺便说一下，我还是强烈推荐152这门非常棒的课程，它会告诉你处理器内部的工作原理。我以前也教过这门课。那么，总线是什么呢？你知道，像这样，我有一堆带有“总线”字样的东西。那么，总线到底是什么呢？它是一个公共的电缆系统，用于在设备间进行通信，并且附带有协议。好的。
- en: so a bus typically has some lines for data。 It's got some lines for addresses。
    It's got some lines for control。 Okay， and the protocols involved things like
    well if there's a request or that says。 Hey， I need some data for a given address。
    It goes out over the bus。 There's a responder that says。 Hey， I'm good。 Here's
    your data and you get the data back。 Okay。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以总线通常有一些数据线，它有一些地址线，还有一些控制线。好的，协议内容包括，如果有请求，说明“嘿，我需要某个地址的数据”，它会通过总线发送出去。然后有一个响应方说，“嘿，我准备好了，这是你的数据”，然后你就拿到数据了。好的。
- en: so that's it's simple idea because you have a set of common wires and you plug
    a bunch of stuff into it and now they're all connected。 Okay。 And you get very
    high bandwidth close to processors and low bandwidth as you get further away from
    them。 Okay。 So why do you do a bus。 Well， buses let you connect all sorts of things
    together with a very simple set of wires。 So upside of a bus is it's extremely
    flexible。 Okay， because you order in squared communication。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它的简单理念是，你有一组公共的电缆，然后你将一堆东西插入其中，现在它们都连接在一起。好的。你会发现，离处理器越近，带宽越高，离它们越远，带宽就越低。好的。那么为什么要用总线呢？嗯，总线让你可以通过一组非常简单的电缆连接各种设备。所以总线的优点是它非常灵活。好的，因为你可以进行平方级别的通信。
- en: The downside is you can only do one thing on a bus at a time。 Can't imagine
    a big。 I don't imagine a zoom call with 100 people。 Okay。 you can have 100 squared
    conversations going on just not at once。 Right， so that's。 that's a downside and
    the other downside is physical， which is the more things you commit。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，总线一次只能做一件事。不能想象一下，有100人参加的Zoom会议。好的，你不能同时进行100场对话，只能一个接一个。对吧？所以，这是一个缺点，另一个缺点是物理上的，随着你连接的设备越来越多。
- en: you connect to the same set of wires。 The more capacitance there is and the
    slower everything runs。 So buses are by their very nature， they get slower as
    you add things to them just physically。 Okay。 so buses are great。 They look like
    this you've all seen the idea of you plug a big card in。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你连接到同一组电缆时，电容就越大，所有东西就会运行得更慢。所以从本质上讲，总线是随着你添加的设备越来越多而变慢的，这在物理上是无法避免的。好的。所以总线很好。它们长得像这样，你们都看过，你把一个大卡插进去。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_41.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_41.png)'
- en: Right， and there's what's happening on these boards underneath is all of you
    know this wires connected that one this is connected。 you know， they're parallel
    connections， and you get a lot of devices in there at once。 Okay。 great for flexibility
    not so good because the speed is bounded both by that capacitance and by the slowest
    device。 So if you have a very slow device to respond， even the fastest things
    that try to communicate have to wait for that slow one to say okay go ahead。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对，接下来在这些电路板下发生的事情是，你知道这些电缆是如何连接的，它们是并行连接的，你可以同时接入许多设备。好的。这对于灵活性来说很棒，但也有缺点，因为速度受限于电容和最慢设备的响应时间。所以如果你有一个响应非常慢的设备，即便是最快的设备也得等那个慢的设备先回应，才能继续。
- en: Okay， and so buses by themselves are not going to help us with our 12 orders
    of magnitude in communication。 Okay， so we need to do something else and there's
    a hint here I think。 We have buses that are close to the processor are really
    short， and here。 and then we have a bunch of gateways the longer buses and gateways
    the longer buses by building a hierarchy of communication we can push the slow
    stuff out。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，总线本身无法帮助我们解决通信中12个数量级的问题。好吧，我们需要做点别的事情，这里我想给出一个提示。我们有靠近处理器的总线，它们真的很短，然后我们有一堆网关，长的总线和网关，通过建立通信的层次结构，我们可以把慢速的部分推向外面。
- en: and the fast stuff close， and maybe we can handle that 12 orders of magnitude。
    Okay。 and so this is the this is what you're going to see as we start talking
    more about this so for instance。 PCI。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，靠近的快速部分，或许我们能处理那12个数量级的差距。好吧，这就是你们在我们开始讨论这个问题时会看到的内容，例如 PCI。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_43.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_43.png)'
- en: This is an old bus right this is not as old as the eyes of us but this one was
    around 2000 easily。 Okay。 Not fast enough， and instead what happened was things
    like the PCI express bus。 where it was no longer a parallel bus but instead it
    was really a collection of really fast serial channels。 So you might have 100
    things in each of them had a point to point connection to get really fast communication
    but there was no actual bus。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个旧的总线，对吧，这个总线并不像IDE总线那么旧，但它在2000年左右就已经存在了。好吧，不够快，因此发生的变化是，像PCI Express总线这样的技术出现了。它不再是一个并行总线，而是一个由非常快速的串行通道组成的集合。所以，你可能有100个通道，每个通道都有一个点对点的连接来实现非常快速的通信，但它没有实际的总线。
- en: Okay， and all the communication was serial。 And there was a way to basically
    decide how many of these serial channels you needed for bandwidth and slow devices
    don't have to get in the way of fast devices etc。 And one of the successes of
    the kind of abstraction we're going to talk about as we start getting into the
    IO subsystem for Linux was they could go from the parallel old school PCI bus
    to the PCI express bus by just changing some device drivers a little bit and it
    wasn't a big deal most of the operating system didn't have to know the difference。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所有的通信都是串行的。而且基本上有一种方法可以决定你需要多少串行通道来满足带宽需求，慢速设备不会妨碍快速设备，等等。我们将要讨论的这种抽象方式的成功之一，是当我们开始进入Linux的IO子系统时，他们可以通过稍微修改一些设备驱动程序，从并行的旧式PCI总线转到PCI
    Express总线，而且这并不是大问题，大多数操作系统不需要知道差异。
- en: Everything just got faster。 Okay， that's our goal。 Can we get abstraction and
    hierarchy in the system to give us a way of dealing with this 12 orders of magnitude
    of different speeds of devices。 Okay。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都变得更快了。好了，这就是我们的目标。我们能否在系统中实现抽象和层次结构，以便处理这12个数量级的不同设备速度呢？好的。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_45.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_45.png)'
- en: So here is an example of a typical PCI architecture this is a much more modern
    system。 You got a CPU with a host bridge to one PCI bus， which has host bridges
    to other PCI buses and eventually you get to USB which is the universal serial
    bus。 And it has a hierarchy of communication and then SATA is the typical disk
    controllers etc。 Okay。 Now， how does the processor talk to the device。 So I want
    to do a couple more things here before we end for the day。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的PCI架构的例子，这是一个更现代的系统。你有一个CPU，通过主桥连接到一个PCI总线，该总线通过主桥连接到其他PCI总线，最终连接到USB，即通用串行总线。它有一个通信层次结构，接着是SATA，这是典型的磁盘控制器，等等。好吧。那么，处理器是如何与设备通信的呢？在今天结束之前，我想做几个额外的事情。
- en: But let's give you an example of what I mean by communication because I think
    right now you're all saying well it makes sense I guess that the CPU talks to
    the disk but what does that really mean。 Okay， so let's get a little bit more
    down in the weeds just for a few minutes。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们举个例子来说明我所说的通信，因为我认为现在你们都在想，CPU与硬盘之间的通信是合理的，但这到底是什么意思呢？好了，让我们稍微深入一点，花几分钟时间探讨一下。
- en: So here's a CPU and there's a processor memory bus to talk to memory。 Now what
    that really means is think about memory what is memory memory is a big pot of
    storage。 You handed an address and it hands you back some data。 Right。 or if you're
    writing you say here's an address and here's some data put it in the memory。 So。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个CPU，旁边有一个处理器内存总线与内存进行通信。实际上，这意味着，想象一下内存，什么是内存？内存是一个大存储池。你提供一个地址，它会返回一些数据，对吧？或者如果你在写入数据，你会说“这是一个地址，给我一些数据，放入内存中”。所以。
- en: for us to go from CPU to memory typically has to have data paths and address
    paths。 Right。 And in order to avoid that problem I mentioned with capacitance
    earlier。 we want it to be very short and not to have too many devices on that
    bus。 Okay。 So what we typically do is that bus which is very fast access to memory
    has a bunch of adapters。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，从CPU到内存通常需要数据路径和地址路径。对吧？为了避免我之前提到的电容问题，我们希望这些路径非常短，并且不要有太多设备连接在总线上。好的。所以我们通常会这样做，那个非常快速访问内存的总线有一堆适配器。
- en: Which then go to other buses which connect to typical devices。 So the first
    thing we do here is we pull the devices away from the memory because the memory
    isn't the critical path of pretty much everything the processor does。 Okay， so
    the we have a small number of these bus adapters to communicate with devices and
    the devices typically look like this。 where there's a controller card。 It has
    an interface to some bus。 It can generate interrupts。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些适配器连接到其他总线，这些总线连接到典型的设备。所以我们在这里做的第一件事是把设备从内存中分离出来，因为内存并不是处理器所做的大部分工作中的关键路径。好的，所以我们有少量的这些总线适配器来与设备通信，设备通常看起来是这样的，里面有一个控制卡。它有一个与某些总线连接的接口，可以生成中断。
- en: It has a controller that takes commands that come across this interface。 And。
    and then if it's a display controller for instance it might do something like
    quick triangles up on the screen。 Right， so if this is a， you know， a display
    device that does really well with gaming。 Then there might be some hardware in
    here that takes a list of triangles and doesn't really fast rendering in 3D。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个控制器，接收通过这个接口传来的命令。如果这是一个显示控制器，它可能会做一些事情，比如在屏幕上快速绘制三角形。对吧？如果这是一个做得非常适合游戏的显示设备，那么它可能会有一些硬件，可以接收三角形列表，并进行快速的3D渲染。
- en: Okay， that kind of hardware could be inside the controller。 Okay。 but this interface
    from the CPU to it is typically very simple。 Okay， it's a chip。 It's a set of
    addresses。 That represent commands to that device。 Okay。 so the CPU is interacting
    with the controller， which has a set of registers。 I'm showing them here。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这种硬件可以在控制器内部。好的。但是从CPU到控制器的这个接口通常非常简单。好的，它是一个芯片，是一组地址，代表对该设备的命令。好的。所以CPU与控制器进行交互，控制器有一组寄存器。我在这里展示它们。
- en: And those registers you read and write them just like memory typically。 And
    when you read or write that memory you find out status of the device if you read
    it or if you write it you might say go ahead and draw those triangles。 Okay， so
    the control interface is between the CPU and a set of apparent registers。 That
    when you read and write them， pause control to happen。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那些寄存器你通常就像访问内存一样读取和写入。当你读取或写入这些内存时，你会了解设备的状态。如果你读取它，或者如果你写入它，你可能会说，继续绘制那些三角形。好的，所以控制接口是在CPU和一组明显的寄存器之间。当你读取和写入它们时，暂停控制就会发生。
- en: And there might be a whole bunch of memory that you can access just like it
    were memory。 So on the on the display itself， there might be a whole bunch of
    memory that represents the rendered picture。 And you can do reads and writes to
    that to kind of see what the pixels look like。 Okay。 And so next time we're going
    to talk in much more detail about how this all works。 So for instance。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一大堆内存，你可以像访问普通内存那样访问它。所以在显示器本身上，可能会有一大堆内存代表渲染的图像。你可以对它进行读写操作，以查看像素的显示效果。好的。接下来，我们会更详细地讨论这一切是如何工作的。举个例子。
- en: is at least two completely different ways for the CPU to talk to a device。 And
    we're going to talk about that more detail。 One is a very legacy way in which
    the CPU executes what are called port map。 I/O instructions， where you do in be
    and out be instructions to particular addresses that go to particular registers。
    Okay， and the second is much more common across a whole series of devices which
    is going to be called memory map。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种完全不同的方式让CPU与设备通信。我们会更详细地讨论这一点。一种是非常传统的方式，其中CPU执行所谓的端口映射I/O指令，你对特定地址进行in和out操作，访问特定的寄存器。好的，第二种方式是目前在一系列设备中更为常见的，它被称为内存映射。
- en: and there， it's literally if you imagine that address space I showed you earlier。
    Well。 flip over to the physical one， there'll be parts of the physical space that
    have devices in them。 And by reading and writing in the physical space I will
    actually cause things to happen on the device。 So for next time we're going to
    flesh out this interface in a lot more detail。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 就在那里，如果你想象一下我之前给你展示的地址空间。好了，翻到物理空间，物理空间中有一些部分包含设备。通过在物理空间中读写，我实际上会在设备上引发一些操作。所以，下次我们将更加详细地阐述这个接口。
- en: and then we're going to start talking about interesting devices we're going
    to talk about spending storage。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将开始讨论一些有趣的设备，特别是存储设备。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_47.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_47.png)'
- en: Talk about discs。 Okay， so in conclusion， we have been talking。 starting the
    discussion about I/O device top types here that there are many different speeds。
    Okay。 you know， tenths of a byte per second to gigabytes。 We're going to talk
    about lots of access patterns and timing。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈磁盘。好了，总结一下，我们一直在讨论，开始讨论关于I/O设备的类型，这里有很多不同的速度。好了，你知道，从每秒几分之一字节到几千兆字节。我们将讨论很多访问模式和时序。
- en: And we're going to get into I/O controllers in a lot more detail。 And obviously
    there's notification mechanisms like interrupts and polling， etc。 Okay。 and then
    we're also going to talk about how device drivers work。 So。 hope you have a really
    great rest of your Tuesday and we'll see you on Thursday。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更详细地讲解I/O控制器。显然，还有一些通知机制，比如中断和轮询等。好了，然后我们还将讨论设备驱动程序的工作原理。所以，希望你今天余下的时间过得愉快，周四见。
- en: Don't forget tomorrow is the deadline for a regret request。 So there is a question
    here about his addressable memory stored on the device it can be。 We'll talk more
    about that next time。 All right。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，明天是撤销请求的截止日期。所以这里有一个问题，关于他在设备上存储的可寻址内存。我们下次会详细讨论这个问题。好吧。
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_49.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_49.png)'
- en: '[BLANK_AUDIO]。'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[空白音频]。'
- en: '![](img/69f56b8db82e9345ac24f839eeec2786_51.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69f56b8db82e9345ac24f839eeec2786_51.png)'
