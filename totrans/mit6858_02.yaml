- en: Buffer overflows, baggy bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: Review of buffer overflow attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last lecture, we looked at the basics of performing a buffer overflow attack.
    That attack leveraged several observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Systems software is often written in C (operating systems, file systems, databases,
    compilers, network servers, command shells and console utilities)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C is essentially high-level assembly, so...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposes raw pointers to memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not perform bounds-checking on arrays (b/c the hardware doesn't do this,
    and C wants to get you as close to the hardware as possible)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attack also leveraged architectural knowledge about how x86 code works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The direction that the stack grows
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout of stack variables (esp. arrays and return addresses for functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_req.c:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the compiler generate in terms of memory layout? x86 stack looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How does the adversary take advantage of this code?
  prefs: []
  type: TYPE_NORMAL
- en: Supply long input, overwrite data on stack past buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key observation 1:** attacker can overwrite the *return address*, make the
    program jump to a place of the attacker''s choosing!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key observation 2:** attacker can set return address to the buffer itself,
    include some x86 code in there!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can the attackers do once they are executing code?
  prefs: []
  type: TYPE_NORMAL
- en: Use any privileges of the process! If the process is running as root or Administrator,
    it can do whatever it wants on the system. Even if the process is not running
    as root, it can send spam, read files, and interestingly, attack or subvert other
    machines behind the firewall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hmmm, but why didn't the OS notice that the buffer has been overrun?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As far as the OS is aware, nothing strange has happened! Remember that, to a
    first approximation, the OS only gets invoked by the web server when the server
    does IO or IPC. Other than that, the OS basically sits back and lets the program
    execute, relying on hardware page tables to prevent processes from tampering with
    each other's memory. However, page table protections don't prevent buffer overruns
    launched by a process "against itself," since the overflowed buffer and the return
    address and all of that stuff are inside the process's valid address space.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this lecture, we'll talk about things that the OS *can* do to make
    buffer overflows more difficult.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing buffer overflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Approach #1:** Avoid bugs in C code.'
  prefs: []
  type: TYPE_NORMAL
- en: Hard / impossible to achieve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmer should carefully check sizes of buffers, strings, arrays, etc. In
    particular, the programmer should use standard library functions that take buffer
    sizes into account (`strncpy()` instead of `strcpy()`, `fgets()` instead of `gets()`,
    etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern versions of `gcc` and Visual Studio warn you when a program uses unsafe
    functions like gets(). In general, **YOU SHOULD NOT IGNORE COMPILER WARNINGS.**
    Treat warnings like errors!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good:** Avoid problems in the first place!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad:** It''s hard to ensure that code is bug-free, particularly if the code
    base is large. Also, the application itself may define buffer manipulation functions
    which do not use `fgets()` or `strcpy()` as primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approach #2:** Build tools to help programmers find bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use static analysis to find problems in source code before
    it''s compiled. Imagine that you had a function like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo.c:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By statically analyzing the control flow, we can tell that offset is used without
    being initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if`-statement also puts bounds on offset that we may be able to propagate
    to bar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll talk about static analysis more in later lectures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"Fuzzers"* that supply random inputs can be effective for finding bugs. Note
    that fuzzing can be combined with static analysis to maximize code coverage!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad:** Difficult to prove the complete absence of bugs, esp. for unsafe code
    like C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good:** Even partial analysis is useful, since programs should become strictly
    less buggy. For example, baggy bounds checking cannot catch all memory errors,
    but it can detect many important kinds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approach #3:** Use a memory-safe language (JavaScript, C#, Python).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:** Prevents memory corruption errors by not exposing raw memory addresses
    to the programmer, and by automatically handling garbage collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad:** Low-level runtime code **does** use raw memory addresses. So, that
    runtime core still needs to be correct. For example, *heap spray attacks*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NOZZLE: A Defense Against Heap-spraying Code Injection Attacks](https://www.usenix.org/legacy/event/sec09/tech/full_papers/ratanaworabhan.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exploit writing tutorial part 11 : Heap Spraying Demystified](https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad:** Still have a lot of legacy code in unsafe languages (FORTRAN and COBOL
    oh noes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad:** Maybe you need access to low-level hardware features (e.g., you''re
    writing a device driver)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad:** Perf. is worse than a fine-tuned C application?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to be a bigger problem, but hardware and high-level languages are getting
    better.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JIT compilation FTW!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asm.js](http://asmjs.org/faq.html) is within 2x of native C++ performance!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use careful coding to avoid garbage collection jitter in critical path.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe you're a bad person / *language chauvinist* who doesn't know how to pick
    the right tool for the job. If your task is I/O-bound, raw compute speed is much
    less important. Also, don't be the chump who writes text manipulation programs
    in C.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All 3 above approaches are effective and widely used, but buffer overflows are
    still a problem in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Large/complicated legacy code written in C is very prevalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even newly written code in C/C++ can have memory errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we mitigate buffer overflows despite buggy code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things going on in a "traditional" buffer overflow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary gains control over execution (program counter).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary executes some malicious code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the difficulties to these two steps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires overwriting a code pointer (which is later invoked). Common target
    is a return address using a buffer on the stack. Any memory error could potentially
    work, in practice. Function pointers, C++ vtables, exception handlers, etc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Requires some interesting code in process''s memory. This is often easier than
    #1, because:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: it's easy to put code in a buffer, and
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the process already contains a lot of code that might be exploitable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: however, the attacker needs to put this code in a predictable location, so that
    the attacker can set the code pointer to point to the evil code!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mitigation approach 1: canaries (e.g., StackGuard, gcc''s SSP)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Idea: OK to overwrite code pointer, as long as we catch it before invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the earlier systems: StackGuard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place a canary on the stack upon entry, check canary value before return.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually requires source code; compiler inserts canary checks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Where is the canary on the stack diagram? **A:** Canary must go "in
    front of" return address on the stack, so that any overflow which rewrites return
    address will also rewrite canary.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stack layout:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Q:** Suppose that the compiler always made the canary 4 bytes of the `''a''`
    character. What''s wrong with this?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** Adversary can include the appropriate canary value in the buffer overflow!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the canary must be either hard to guess, or it can be easy to guess but
    still resilient against buffer overflows. Here are examples of these approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"Terminator canary"*: four bytes (0, CR, LF, -1)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Idea: Many C functions treat these characters as terminators(e.g., `gets()`,
    `sprintf()`). As a result, if the canary matches one of these terminators, then
    further writes won''t happen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Random canary generated at program init time: Much more common today (but,
    you need good randomness!).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What kinds of vulnerabilities will a stack canary not catch?
  prefs: []
  type: TYPE_NORMAL
- en: Overwrites of function pointer variables before the canary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacker can overwrite a data pointer, then leverage it to do arbitrary mem
    writes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data pointer example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Heap object overflows (function pointers, C++ vtables).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malloc`/`free` overflows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malloc example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Assume that the two blocks of memory belonging to `p` and `q` are adjacent/nearby
    in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assume that `malloc` and `free` represent memory blocks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malloc memory blocks:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, the buffer overrun in `p` will overwrite the size value in `q`'s memory
    block! Why is this a problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `free()` merges two adjacent free blocks, it needs to manipulate `bkwd`
    and `fwd` pointers...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '...and the pointer calculation uses size to determine where the free memory
    block structure lives!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free() internals:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The free memory block is represented as a C `struct`; by corrupting the size
    value, the attacker can force `free()` to operate on a fake `struct` that resides
    in attacker-controlled memory and has attacker-controlled values for the forward
    and backwards pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the attacker knows how `free()` updates the pointers, he can use that update
    code to write an arbitrary value to an arbitrary place. For example, the attacker
    can overwrite a return address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actual details are a bit more complicated; if you're interested in gory details,
    go [here](http://www.win.tue.nl/~aeb/linux/hh/hh-11.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The high-level point is that stack canaries won't prevent this attack, because
    the attacker is "skipping over" the canary and writing directly to the return
    address!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mitigation approach 2: bounds checking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Overall goal:** prevent pointer misuse by checking if pointers are in range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenge:** In C, it can be hard to differentiate between a valid pointer
    and an invalid pointer. For example, suppose that a program allocates an array
    of characters... `char x[1024];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... as well as a pointer to some place in that array, e.g., `char *y = &x[107];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it OK to increment `y` to access subsequent elements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x` represents a string buffer, maybe yes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x` represents a network message, maybe no.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Life is even more complicated if the program uses unions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`union example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**The problem** is that, in C, *a pointer does not encode information about
    the intended usage semantics for that pointer.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, a lot of tools don''t try to guess those semantics. Instead, the tools
    have a less lofty goal than "totally correct" pointer semantics: the tools just
    enforce the memory bounds on heap objects and stack objects. At a high level,
    here''s the goal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a pointer `p'` that's derived from `p`, `p'` should only be dereferenced
    to access the valid memory region that belongs to `p`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enforcing memory bounds* is a **weaker** goal than *enforcing "totally correct"
    pointer semantics*. Programs can still shoot themselves in the foot by trampling
    on their memory in nasty ways (e.g., in the union example, the application may
    write to pointer even though it''s not defined).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, bounds checking is still useful because it prevents *arbitrary* memory
    overwrites. The program can only trample its memory if that memory is actually
    allocated! *THIS IS CONSIDERED PROGRESS IN THE WORLD OF C.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A drawback of bounds checking is that it typically requires changes to the compiler,
    and programs must be recompiled with the new compiler. This is a problem if you
    only have access to binaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some approaches for implementing bounds checking?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Bounds checking approach #1: Electric fences**'
  prefs: []
  type: TYPE_NORMAL
- en: These are an old approach that had the virtue of being simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Idea:** Align each heap object with a guard page, and use page tables to
    ensure that accesses to the guard page cause a fault.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`electric fence:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a convenient debugging technique, since a heap overflow will immediately
    cause a crash, as opposed to silently corrupting the heap and causing a failure
    at some indeterminate time in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Big advantage: Works without source code: don''t need to change compilers or
    recompile programs!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You *do* need to relink them so that they use a new version of `malloc` which
    implements electric fences.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Big disadvantage: Huge overhead! There''s only one object per page, and you
    have the overhead of a dummy page which isn''t used for "real" data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summary: Electric fences can be useful as debugging technique, and they can
    prevent some buffer overflows for heap objects. However, electric fences can''t
    protect the stack, and the memory overhead is too high to use in production systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounds checking approach #2: Fat pointer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Idea:** Modify the pointer representation to include bounds information.
    Now, a pointer includes a memory address and bounds information about an object
    that lives in that memory region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You need to modify the compiler and recompile the programs to use the fat pointers.
    The compiler generates code to abort the program if it dereferences a pointer
    whose address is outside of its own `base ... end` range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Problem #1:** It can be expensive to check all pointer dereferences. The
    C community hates things that are expensive, because C is all about SPEED SPEED
    SPEED.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem #2:** Fat pointers are incompatible with a lot of existing software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't pass a fat pointer to an unmodified library.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't use fat pointers in fixed-size data structures. For example, `sizeof(that_struct)`
    will change!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updates to fat pointers are not atomic*, because they span multiple words.
    Some programs assume that pointer writes are atomic.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bounds checking approach #3: Shadown data structures'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Idea:** Use shadow data structures to keep track of bounds information ([Jones
    and Kelly](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.3156), [Baggy
    bounds](https://www.usenix.org/legacy/event/sec09/tech/full_papers/akritidis.pdf)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each allocated object, store how big the object is. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Record the value passed to malloc:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char *p = malloc(mem_size);`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For static variables, the values are determined by the compiler:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char p[256];`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each pointer, we need to interpose on two operations:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pointer arithmetic: `char *q = p + 256;`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'pointer dereferencing: `char ch = *q;`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Q:** Why do we need to interpose on dereference? Can''t we do just arithmetic?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** An invalid pointer isn''t always a bug! For example, a pointer to one
    element past the last item of an array might be used as a stopping test in a loop.
    Applications can also do goofy stuff like:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating 1-indexed arrays
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing p+(a-b) as (p+a)-b
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating OOB pointers that are later checked for validity
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the mere creation of invalid pointer shouldn't cause program to fail.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Why do we need to interpose on arithmetic? Can''t we do just dereference?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** Interposing on arithmetic is what allows us to track the provenance
    of pointers and set the OOB bit. Without the OOB, we won''t be able to tell when
    a derived pointer goes outside of the bounds of its base object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenge 1:** How do we find the bounds information for a regular pointer,
    i.e., a pointer that''s in-bounds?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Naive:* Use a hash table or interval tree to map addresses to bounds.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good: Space efficient (only store info for in-use pointers, not all possible
    addresses).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bad: Slow lookup (multiple memory accesses per look-up).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Naive:* Use an array to store bounds info for *every* memory address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good: Fast!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bad: Really high memory overhead.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenge 2:** How do we force out-of-bounds pointer dereferences to fail?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Naive:* Instrument every pointer dereference.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good: Uh, it works.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bad: Expensive. We have to execute extra code for every dereference!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The baggy bounds approach: 5 tricks'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Trick 1:** Round up each allocation to a power of 2, and align the start
    of the allocation to that power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trick 2:** Express each range limit as `log_2(alloc_size).`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For 32-bit pointers, only need 5 bits to express the possible ranges: we can
    only allocate objects of a set of 32 different sizes: `2^1 = 2 bytes, 2^2 = 4
    bytes ..., 2^31 bytes or 2^32 bytes`, and we store the log base 2 of the allocation
    size, which is a number between 1 and 32, so we only need 5 bits for it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trick 3:** Store limit info in a linear array: fast lookup with one byte
    per entry. Also, we can use virtual memory to allocate the array on-demand!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trick 4:** Allocate memory at slot granularity (e.g., 16 bytes): **fewer
    array entries.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That means **min. alloc. size** is 16 bytes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '...and, since pointers will be aligned to their allocation size boundary, it
    means the last 4 bits of the pointer are all zero'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Trick 4 (continued):**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, given a known good pointer `p`, and a derived pointer `p'`, we can test
    whether `p'` is valid by checking whether both pointers have the same prefix in
    their address bits, and they only differ in their `e` least significant bits,
    where `e` is equal to the logarithm of the *allocation size*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Trick 5:** Use virtual memory system to prevent out-of-bound derefs: set
    most significant bit in an OOB pointer, and then mark pages in the upper half
    of the address space as inaccessible. So, we don''t have to instrument pointer
    dereferences to prevent bad memory accesses!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example code** (assume that `slot_size=16`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For OOB pointers, the high bit is set (if OOB within half a slot). - Typically,
    OS kernel lives in upper half, protects itself via paging hardware. - **Q:** Why
    half a slot for out-of-bounds?
  prefs: []
  type: TYPE_NORMAL
- en: So what's the answer to the homework problem?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Baggy bounds paper errata
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some bugs in the baggy bounds paper:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3, explicit bounds check should generate the size like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size = 1 << table[p >> log_of_slot_size]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 3, optimized bounds check should be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(p^p'') >> table[p >> log_of_slot_size] == 0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figures 5 and 18, pointer arithmetic code should be either one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char *p = &buf[i];`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char *p = buf + i;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Baggy bounds (continued)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code:** (assume that `slot_size = 16`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For OOB pointers, the high bit is set (if OOB within half a slot).
  prefs: []
  type: TYPE_NORMAL
- en: Typically, OS kernel lives in upper half, protects itself via paging hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Why half a slot for out-of-bounds?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what's the answer to the homework problem?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Does baggy bounds checking have to instrument *every* memory address computation
    and access?
  prefs: []
  type: TYPE_NORMAL
- en: '*No*, static analysis can prove that some addresses are always safe to use.
    However, some address calculations are "unsafe" in the sense that there''s no
    way to statically determine bounds on their values. Such unsafe variables need
    checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling function call arguments is a bit tricky, because the x86 calling convention
    is fixed, i.e., the hardware expects certain things to be in certain places on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can copy unsafe arguments to a separate area, and make sure that
    the copied arguments are aligned and protected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Do we have to overwrite the original arguments with the copies values
    upon function return?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** No, because everything is pass-by-value in C!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does baggy bounds checking ensure binary compatibility with existing libraries?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In particular, how does baggy bounds code interact with pointers to memory that
    was allocated by uninstrumented code?
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Each entry in the bounds table is initialized to the value 31,
    meaning that the corresponding pointer has a memory bound of 2^31 (which is all
    of the addressable memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On memory allocation in *instrumented* code, bounds entries are set as previously
    discussed, and reset to 31 when the memory is deallocated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocated to uninstrumented code will never change bounds table entries
    from their default values of 31; so, when instrumented code interacts with those
    pointers, bound errors will never
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What does this all mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can't detect out-of-bounds pointers generated in uninstrumented code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can't detect when OOB pointer passed into library goes in-bounds again.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Why?'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** Because there is no pointer inspection in the uninstrumented code which
    could clear the high-order OOB bit!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Why do they instrument `strcpy()` and `memcpy()`?'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** Because otherwise, those functions are uninstrumented code, and suffer
    from the same problems that we just discussed. For example, off-the-shelf `strcpy()`
    does not ensure that dest has enough space to store src!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How can baggy bits leverage 64-bit address spaces?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can get rid of the table storing bounds information, and put it in the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to a fat pointer, but has the advantages that...
  prefs: []
  type: TYPE_NORMAL
- en: tagged pointers are the same size as regular pointers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: writes to them are atomic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '...so programmer expectations are not broken, and data layouts stay the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, using tagged pointers, we can now keep track of OOB pointers
    that go much further out-of-bounds. This is because now we can tag pointers with
    an offset indicating how far they are from their base pointer. In the 32-bit world,
    we couldn't track OOB offsets without having an additional data structure!
  prefs: []
  type: TYPE_NORMAL
- en: Can you still launch a buffer overflow attack in a baggy bounds system?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yes, *because the world is filled with sadness.*
  prefs: []
  type: TYPE_NORMAL
- en: Could exploit a vulnerability in uninstrumented libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could exploit temporal vulnerabilities (use-after-free).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed buffers and code pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that `*f` is not an allocated type, so there are no bounds checks associated
    with its dereference during invocation. Thus, if `s.buf` is overflowed (e.g.,
    by a bug in an uninstrumented library) and `s.f` is corrupted, the invocation
    of `f` will not cause a bounds error!
  prefs: []
  type: TYPE_NORMAL
- en: Would re-ordering f and buf help?
  prefs: []
  type: TYPE_NORMAL
- en: Might break applications that depend on struct layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Might not help if this is an array of (`struct my_type`)'s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, what are the costs of bounds checking?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Space overhead for bounds information (fat pointer or baggy bounds table).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Baggy bounds also has space overhead for extra padding memory used by buddy
    allocator (although some amount of overhead is intrinsic to all popular algorithms
    for dynamic memory allocation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU overheads for pointer arithmetic, dereferencing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: False alarms!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused out-of-bounds pointers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary out-of-bounds pointers by more than `slot_size/2`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion from pointer to integers and back.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing out-of-bounds pointer into unchecked code (the high address bit is set,
    so if the unchecked code does arithmetic using that pointer, insanity may ensue).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a significant amount of compiler support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, baggy bounds checking is an approach for mitigating buffer overflows in
    buggy code.
  prefs: []
  type: TYPE_NORMAL
- en: More approaches for implementing bounds checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Approach 4: non-executable memory (AMD''s NX bit, Windows DEP, W^X, ...)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern hardware allows specifying read, write, and execute perms for memory.
    (R, W permissions were there a long time ago; execute is recent.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can mark the stack non-executable, so that adversary cannot run their code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More generally, some systems enforce "W^X", meaning all memory is either writable,
    or executable, but not both. (Of course, it's OK to be neither.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advantage:** Potentially works without any application changes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advantage:** The hardware is watching you all of the time, unlike the OS.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantage:** Harder to dynamically generate code (esp. with W^X).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JITs like Java runtimes, Javascript engines, generate x86 on the fly.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can work around it, by first writing, then changing to executable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Approach 5: randomized memory addresses (ASLR, stack randomization, ...)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Observation: Many attacks use hardcoded addresses in shellcode! [The attacker
    grabs a binary and uses gdb to figure out where stuff lives.]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can make it difficult for the attacker to guess a valid code pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stack randomization: Move stack to random locations, and/or place padding between
    stack variables. This makes it more difficult for attackers to determine:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the return address for the current frame is located
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the attacker's shellcode buffer will be located
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Randomize entire address space (Address Space Layout Randomization): randomize
    the stack, the heap, location of DLLs, etc.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rely on the fact that a lot of code is relocatable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic loader can choose random address for each library, program.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary doesn't know address of system(), etc.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can this still be exploited?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary might guess randomness. Especially on 32-bit machines, there aren't
    many random bits (e.g., 1 bit belongs to kernel/user mode divide, 12 bits can't
    be randomized because memory-mapped pages need to be aligned with page boundaries,
    etc.).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, attacker could buffer overflow and try to overwrite the return
    address with the address of `usleep(16)`, and then seeing if the connection hangs
    for 16 seconds, or if it crashes (in which case the server forks a new ASLR process
    with the same ASLR offsets). `usleep()` could be in one of 2^16 or 2^28 places.
    [More details](https://cseweb.ucsd.edu/~hovav/dist/asrandom.pdf).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ASLR is more practical on 64-bit machines (easily 32 bits of randomness).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary might extract randomness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs might generate a stack trace or error message which contains a pointer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If adversaries can run some code, they might be able to extract real addresses
    (JIT'd code?).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cute address leak in Flash''s Dictionary (hash table):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get victim to visit your Flash-enabled page (e.g., buy an ad).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash table internally computes hash value of keys.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash value of integers is the integer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash value of object is its memory address.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over a hash table is done from lowest hash key to highest hash key.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the attacker creates a Dictionary, inserts a string object which has shellcode,
    and then inserts a bunch of numbers into the Dictionary.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By iterating through the Dictionary, the attacker can determine where the string
    object lives by seeing which integers the object reference falls between!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, overwrite a code pointer with the shellcode address and bypass ASLR!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary might not care exactly where to jump.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ex: "Heap spraying": fill memory w/ shellcode so that a random jump is OK!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary might exploit some code that's not randomized (if such code exists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some other interesting uses of randomization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System call randomization (each process has its own system call numbers).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instruction set randomization so that attacker cannot easily determine what
    "shellcode" looks like for a particular program instantiation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:* Imagine that the processor had a special register to hold a "decoding
    key." Each installation of a particular application is associated with a random
    key. Each machine instruction in the application is XOR''ed with this key. When
    the OS launches the process, it sets the decoding key register, and the processor
    uses this key to decode instructions before executing them.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Which buffer overflow defenses are used in practice?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: gcc and MSVC enable stack canaries by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux and Windows include ASLR and NX by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bounds checking is not as common, due to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance overheads
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to recompile programs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False alarms: Common theme in security tools: false alarms prevent adoption
    of tools! Often, zero false alarms with some misses better than zero misses but
    false alarms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return-oriented programming (ROP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASLR and DEP are very powerful defensive techniques.
  prefs: []
  type: TYPE_NORMAL
- en: DEP prevents the attacker from executing stack code of his or her choosing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASLR prevents the attacker from determining where shellcode or return addresses
    are located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, what if the attacker could find PREEXISTING CODE with KNOWN FUNCTIONALITY
    that was located at a KNOWN LOCATION? Then, the attacker could invoke that code
    to do evil.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the preexisting code isn't *intentionally* evil, since it is a normal
    part of the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the attacker can pass that code unexpected arguments, or jump to the
    middle of the code and only execute a desired piece of that code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These kinds of attacks are called *return-oriented programming*, or *ROP*. To
    understand how ROP works, let's examine a simple C program that has a security
    vulnerability. [Example adapted from here](http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's imagine that the system does not use ASLR or stack canaries, but it does
    use DEP. `process_msg()` has an obvious buffer overflow, but the attacker can't
    use this overflow to execute shellcode in `buf`, since DEP makes the stack non-executable.
    However, that `run_shell()` function looks tempting... how can the attacker execute
    it?
  prefs: []
  type: TYPE_NORMAL
- en: Attacker disassembles the program and figures out where the starting address
    of `run_shell()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attacker launches the buffer overflow, and overwrites the return address
    of `process_msg()` with the address of `run_shell()`. Boom! The attacker now has
    access to a shell which runs with the privileges of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's a straightforward extension of the buffer overflows that we've already
    looked at. But how can we pass arguments to the function that we're jumping to?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the argument that we want to pass to is already located in the
    program code. There's also a preexisting call to `system()`, but that call isn't
    passing the argument that we want.
  prefs: []
  type: TYPE_NORMAL
- en: We know that `system()` must be getting linked to our program. So, using our
    trusty friend gdb, we can find where the `system()` function is located, and where
    bash_path is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call `system()` with the `bash_path` argument, we have to set up the stack
    in the way that `system()` expects when we jump to it. Right after we jump to
    `system()`, `system()` expects this to be on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the buffer overflow needs to set up a stack that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In essence, what we've done is set up a fake calling frame for the `system()`
    call! In other words, we've simulated what the compiler would do if it actually
    wanted to setup a call to `system()`.
  prefs: []
  type: TYPE_NORMAL
- en: What if the string `"/bin/bash"` was not in the program?
  prefs: []
  type: TYPE_NORMAL
- en: We could include that string in the buffer overflow, and then have the argument
    to system() point to the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that, in these examples, I've been assuming that the attacker used a junk
    return address from `system()`. However, the attacker could set it to something
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, by setting it to something useful, the attacker can chain calls together!
  prefs: []
  type: TYPE_NORMAL
- en: '**Goal:** We want to call `system("/bin/bash")` multiple times. Assume that
    we''ve found three addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: The address of system()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The address of the string "/bin/bash"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The address of these x86 opcodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These opcodes are an example of a "gadget." Gadgets are preexisting instruction
    sequences that can be strung together to create an exploit. Note that there are
    [user-friendly tools](http://www.exploit-db.com/download_pdf/17049/) to help you
    extract gadgets from preexisting binaries (e.g., msfelfscan).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, how does this work? Remember that the return instruction pops the top of
    the stack and puts it into %eip.
  prefs: []
  type: TYPE_NORMAL
- en: The overflowed function terminates by issuing `ret`. `ret` pops off the top-of-the-stack
    (the address of `system()`) and sets `%eip` to it. `system()` starts executing,
    and `%esp` is now at (1), and points to the `pop/ret` gadget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system()` finishes execution and calls `ret`. `%esp` goes from (1)-->(2) as
    the `ret` instruction pops the top of the stack and assigns it to `%eip`. `%eip`
    is now the start of the `pop/ret` gadget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pop instruction in the `pop/ret` gadget discards the `bash_path` variable
    from the stack. `%esp` is now at (3). We are still in the `pop/ret` gadget!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ret` instruction in the `pop/ret` gadget pops the top-of-the-stack and
    puts it into `%eip`. Now we're in `system()` again, and `%esp` is at (4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we've created a new type of machine that is driven by the stack pointer
    instead of the regular instruction pointer! As the stack pointer moves down the
    stack, it executes gadgets whose code comes from preexisting program code, and
    whose data comes from stack data created by the buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: This attack evades DEP protections--we're not generating any new code, just
    invoking preexisting code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Stack reading: defeating canaries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The remote server has a buffer overflow vulnerability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server crashes and restarts if a canary value is set to an incorrect value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the server respawns, the canary is NOT re-randomized, and the ASLR is NOT
    re-randomized, e.g., because the server uses Linux's PIE mechanism, and `fork()`
    is used to make new workers and not `execve()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to determine an 8-byte canary value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At this point we have the canary, but remember that the attack assumes that
    the server uses the same canary after a crash.
  prefs: []
  type: TYPE_NORMAL
- en: Guessing the correct value for a byte takes 128 guesses on average, so on a
    32-bit system, we only need `4*128=512` guesses to determine the canary (on a
    64-bit system, we need `8*128=1024`).
  prefs: []
  type: TYPE_NORMAL
- en: Much faster than brute force attacks on the canary (`2^15` or `2^27` expected
    guesses on `32/64` bit systems with 16/28 bits of ASLR randomness).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute force attacks can use the `usleep(16)` probe that we discussed earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canary reading can be extended to reading arbitrary values that the buffer overflow
    can overwrite!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we've discussed how we can defeat randomized canaries if canaries are not
    changed when a server regenerates. We've also shown how to use gdb and gadgets
    to execute preexisting functions in the program using arguments that the attacker
    controls. But what if the server DOES use ASLR? This prevents you from using offline
    analysis to find where the preexisting functions are?
  prefs: []
  type: TYPE_NORMAL
- en: This is what the paper for today's lecture discussed. That paper assumed that
    we're using a 64-bit machine, so that's what we'll assume in this lecture from
    now on. For the purposes of this discussion, the main change is that function
    arguments are now passed in registers instead of on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Blind return-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Step 1: Find a stop gadget'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A stop gadget is a return address that points to code that will hang the program,
    but not crash it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the attacker can defeat canaries, he can overwrite the overflown function's
    return address and start guessing locations for a stop gadget. If the client network
    connection suddenly closes, the guessed address was not a stop gadget. If the
    connection stays open, the gadget is a stop gadget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 2: Find gadgets that pop stack entries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have a stop gadget, you can use it to find other gadgets that pop entries
    off of the stack and into registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three building blocks to locate stack popping gadgets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*probe:* Address of a potential stack popping gadget'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*stop:* Address of a stop gadget'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*crash:* Address of non-executable code (0x0)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:* Find a gadget that pops one thing off the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After you do this a bunch of times, you'll have a collection of gadgets that
    pop one thing from the stack and then return. However, you won't know which *register*
    those gadgets store the popped value in.
  prefs: []
  type: TYPE_NORMAL
- en: You need to know which registers are used to store data so that you can issue
    a system call. Each system call expects its arguments to be in a specific set
    of registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we also don't know the location of the `syscall()` library function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 3: Find syscall() and determine which registers the pop gadgets use'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pause()` is a system call that takes no arguments (and thus ignores everything
    in the registers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find `pause()`, the attacker chains all of the `"pop x; ret"` gadgets on
    the stack, pushing the system call number for `pause()` as the "argument" for
    each gadget. At the bottom of the chain, the attacker places the guessed address
    for `syscall()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, at the end of this chain, the pop gadgets have placed the syscall number
    for `pause()` in a bunch of registers, hopefully including `rax`, which is the
    one that `syscall()` looks in to find the syscall number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this mega-gadget induces a pause, we know that we''ve determined the location
    of `syscall()`. Now we need to determine which gadget pops the top-of-the stack
    into `rax`. The attacker can figure this out by process-of-elimination: iteratively
    try just one gadget and see if you can invoke `pause()`.'
  prefs: []
  type: TYPE_NORMAL
- en: To identify arbitrary `"pop x; ret"` gadgets, you can use tricks with other
    system calls that use the `x` register that you're trying to find.
  prefs: []
  type: TYPE_NORMAL
- en: So, the outcome of this phase is knowledge of `"pop x; ret"` gadgets, location
    of `syscall()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Invoke write()'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we want to invoke the write call on the network socket that the server
    has with the attacker''s client. We need the following gadgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have to guess the socket value, but that's fairly easy to do, since Linux
    restricts processes to 1024 simultaneously open file descriptors, and new file
    descriptors have to be the lowest one available (so guessing a small file descriptor
    works well in practice).
  prefs: []
  type: TYPE_NORMAL
- en: To test whether we've guessed the correct file descriptor, simply try the write
    and see if we receive anything!
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the socket number, we issue a write, and for the data to send,
    we send a pointer to the program's `.text` segment! This allows the attacker to
    read the program's code (which was randomized but now totally known to the attacker!).
    Now the attacker can find more powerful gadgets directly, and leverage those gadgets
    to open a shell.
  prefs: []
  type: TYPE_NORMAL
- en: Defenses against BROP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Re-randomize the canaries and the address space after each crash!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `exec()` instead of `fork()` to create processes, since `fork()` copies
    the address space of the parent to the child.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, Windows is not vulnerable to BROP because Windows has no `fork()`
    equivalent.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sleep-on-crash?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now a BROP attack is a denial-of-service!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounds-checking?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to 2x performance overhead...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More info on ROP and x86 calling conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[A brief introduction to x86 calling conventions](http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to return oriented programming](http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dive into ROP: A quick introduction to return oriented programming](http://www.slideshare.net/saumilshah/dive-into-rop-a-quick-introduction-to-return-oriented-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Return-Oriented Programming: Systems, Languages, and Applications](https://cseweb.ucsd.edu/~hovav/dist/rop.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
