- en: TCP/IP security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: Threat model for network security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adversary can intercept / modify network traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary can send packets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary has full control of their own machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary can participate in protocols (usually).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often not feasible to keep bad guys out of a large systems.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eavesdropping on packets.
  prefs: []
  type: TYPE_NORMAL
- en: Important to keep in mind, but relatively well understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any data sent over the network can be observed by an adversary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending / spoofing packets.
  prefs: []
  type: TYPE_NORMAL
- en: IP allows sender to construct an arbitrary packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, sender can fill in any source address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can pretend that a packet is coming from any address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can an adversary do with this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Look Back at "Security Problems in the TCP/IP Protocol Suite"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Paper here](http://css.csail.mit.edu/6.858/2014/readings/lookback-tcpip.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy target: trigger bugs in some implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author isn't so interested in this class of problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, want to look at **"protocol-level problems"**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a protocol-level problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A problem inherent in the design.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A correct implementation will have this problem.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is it so important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can fix implementation bugs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To fix protocol-level bugs, might need to change protocol!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Might be incompatible with existing systems.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (As we will see, sometimes possible to come up with compatible fixes.)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP sequence number attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard handshake (figure on the right side of page 2):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C: SRC=C, DST=S, SYN(SNc)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S: SRC=S, DST=C, SYN(SNs), ACK(SNc)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C: SRC=C, DST=S, ACK(SNs)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C: SRC=C, DST=S, data(SNc), ACK(SNs)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the adversary know the data is coming from the client?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the client should have been able to receive the second message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, **only the client should know SNs**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Third message is rejected, unless it has the right SNs value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose adversary A wants to simulate a connection to S from C. (Assume A knows
    C's IP address -- usually not a big deal in practice.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A: SRC=C, DST=S, SYN(SNc)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S: SRC=S, DST=C, SYN(SNs), ACK(SNc)` -- but this goes to C, not A'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A: SRC=C, DST=S, ACK(SNs)` -- but how to guess SNs?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A: SRC=C, DST=S, data(SNc)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where does the adversary get SNs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP specification suggested a specific way to choose them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In particular, increment at a ~constant rate: ~250,000 per second.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why so specific?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtle interactions with reused connections (src/dst port numbers).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to avoid old packets (from past conns) interfering with new conn.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: RFC 1185 appendix'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If adversary knows a recent sequence number, can guess the next one.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemention would actually bump ISN every second, making it easy to guess.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens to the real packet that S sends to C (second pkt)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C would assume the packet is from an old conn, send `RST` in response.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if that `RST` was sent, adversary could try to race before `RST` arrives.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, there was another curious bug; will get to it later.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But why do sequence number attacks turn into a security problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Spoof connections to applications that rely on IP addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'E.g., Berkeley remote access tools: rlogin, rsh, rcp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed login without a password, if connection came from a "trusted" system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required connection to come from a trusted source port (512-1023).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why this requirement?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted rlogin/rsh/rcp program sent the client's username.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If username was the same as the account on the server, no password needed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g.: "rsh athena.dialup.mit.edu ls".'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Made a bad assumption about what the TCP layer provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Assumed TCP conn from an IP address meant it really came from that host.*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If adversary can guess SNs, then can simulate connection from trusted host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue any command using rsh.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Could change the user's .rhosts file to allow login from attacker's host.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then connect directly without having to simulate a connection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Host-based authentication seems like a bad plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially relying on "trusted" vs "untrusted" ports on a machine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Still in some use today: e.g., SMTP for outgoing mail.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actually rlogin authentication was even worse: they authenticated by hostname.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where does hostname come from? Reverse DNS lookup.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g., 18.26.4.9: find the PTR record of 9.4.26.18.in-addr.arpa.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Owner of that domain can set PTR record to any hostname!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Can make a slight improvement: check if host resolves to same addr.)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar problems show up in log files: log resolved (untrusted) hostname.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '2\. Denial of service attack: connection reset'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we know SNc, can send a RST packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Worse yet: server will accept a RST packet for any SNc value within window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a large window (~32K=2^15), only need 2^32/2^15 = 2^17 guesses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How bad is a connection reset?
  prefs: []
  type: TYPE_NORMAL
- en: One target of such attacks were the TCP connections between BGP routers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causes routers to assume link failure, could affect traffic for minutes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solutions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TTL hack (255): make sure BGP nodes only talk to direct neighbors by setting
    `TTL = 1` in the TCP packets'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MD5 header authentication (very specialized for router-to-router links).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Hijack existing connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In similar vein, can also inject data into an existing connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All adversary needs to know is the current SNc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to mitigate this problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'Baseline: don''t rely on IP addresses for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use encryption / authentication at a higher level.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next lecture: Kerberos.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But still, want to fix the situation we're in, for TCP.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ISPs can filter packets sent by their customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often done today for small customers, but not consistently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not straightforward for customers with complex networks, multihoming, ..
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to patch up TCP?
  prefs: []
  type: TYPE_NORMAL
- en: Can't choose ISN's in a completely random way, without violating TCP spec.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Might break connection (port) reuse guarantees.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ISN is 32 bits, means after ~2^16 = 65,000 connections you could get a collision
    and reuse an ISN that matches an old connection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: old packets from that connection can be interpreted as being part of the new
    connection
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, it might be better if the ISNs *progress* incrementally with wrap-around,
    so as to make collisions much less probable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Random increments?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should preserve increment rate (~250k/second).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not a huge amount of randomness (say, low 8 bits per increment).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aside: must be careful about how we generate random numbers!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common PRNG: linear congruential generator: `R_k = A*R_{k-1}+B mod N`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not secure: given one pseudo-random value, can guess the next one!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of better cryptographically secure PRNGs are available.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, use your kernel's built-in PRNG (/dev/random, /dev/urandom)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: http://en.wikipedia.org/wiki/Fortuna_(PRNG), or any stream cipher like
    http://en.wikipedia.org/wiki/RC4'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: However, SN values for different src/dst pairs never interact!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, can choose the ISN using a random offset for each src/dst pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nice trick: `ISN = ISN_oldstyle + F(srcip, srcport, dstip, dstport, secret)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F` is some pseudo-random function; roughly, think SHA1.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires no extra state to keep track of per-connection ISNs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Are sequence number attacks still relevant?
  prefs: []
  type: TYPE_NORMAL
- en: Most operating systems implement the per-connection ISN workaround above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: Linux `secure_tcp_sequence_number` in `net/core/secure_seq.c`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But other protocols suffer from almost identical problems -- e.g., DNS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS runs over UDP, no seq numbers, just ports, and dst port fixed (53).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If adversary knows client is making a query, can fake a response.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Just need to guess src port, often predictable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem gained popularity in 2008, though well-understood by djb before.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: http://cr.yp.to/djbdns/forgery.html'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: http://unixwiz.net/techtips/iguide-kaminsky-dns-vuln.html'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: carefully take advantage of all possible randomness!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS queries contain 16-bit query ID, and can randomize ~16 bit src port.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: deploy DNSSEC (signed DNS records, including missing records).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One problem: key distribution (who is allowed to sign each domain?)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another problem: name enumeration (to sign "no such name" responses).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Partially mitigated by NSEC3: http://tools.ietf.org/html/rfc5155'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow adoption, not much incentive to upgrade, non-trivial costs.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs include both performance and administrative (key/cert management).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SYN flooding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that server must store some state when it receives a SYN packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to store the `SN_s` sequence number it sent to that client
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Called a half-open connection: replied with SYN-ACK, waiting for the ACK.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What if it receives SYN messages from many sources?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many implementations try to keep state for all half-open connections.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But eventually run out of memory, must reject connections!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Annoying problem: we don''t even know who we''re keeping state for!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary could have a single host, and generate SYNs from many src IPs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Denial-of-service attack: big asymmetry between client + server resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client spoofs a single packet (less than 1 millisecond).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server wastes memory until connection times out (minutes).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defense for SYN flooding: SYN cookies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Idea:** make the server stateless, until it receives that third packet (ACK).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is this tricky?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to ensure an adversary can't make up a conn from any src address.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, this was done by storing ISNs, and expecting it in the ACK.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a bit of cryptography to achieve similar goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode server-side state into sequence number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISNs = `MAC_k(src/dst addr+port, timestamp) || timestamp`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamp is coarse-grained (e.g., minutes).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server stores secret key `k`, not shared with anyone else.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detailed ref: http://cr.yp.to/syncookies.html'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server computes seq as above when sending SYN-ACK response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server can verify state is intact by verifying hash (MAC) on ACK's seq.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not quite ideal: need to think about replay attacks within timestamp.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another problem: if third packet lost, noone retransmits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only a problem for protocols where server speaks first.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because server does **NOT** keep the connection state anymore, so it does not
    know there's a *hanging connection*, so it will never retransmit its SYN message
    to the client after waiting too long for the client's ACK.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, the client will not know its ACK packet got lost (it's never ACK'd
    back, and since the client is waiting on the server to send the first message
    (assumption), the client will not send any other data either.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe not a big deal in case of a DoS attack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another DoS attack vector: bandwidth amplification.'
  prefs: []
  type: TYPE_NORMAL
- en: Send ICMP echo request (ping) packets to the broadcast address of a network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., 18.26.7.255.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to be that you'd get an ICMP echo reply from all machines on network.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What if you fake a packet from victim's address? Victim gets all replies.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Find a subnet with 100 machines on a fast network: 100x amplification!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: http://en.wikipedia.org/wiki/Smurf_attack'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we fix this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers now block "directed broadcast" (packets sent to broadcast address).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modern-day variant: DNS amplification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS is also a request-response service.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With a small query, server might send back a large response.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With DNSSEC, responses contain lots of signatures, so they're even larger!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since DNS runs over UDP, source address is completely unverified.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: http://blog.cloudflare.com/deep-inside-a-dns-amplification-ddos-attack'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we fix the DNS attack?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually quite hard! Root name servers must answer to queries from anyone.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we had a chance to re-design DNS from scratch?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One possible plan: query must be as big as response (require padding).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General technique: force client to expend at least as much work.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP congestion control.
  prefs: []
  type: TYPE_NORMAL
- en: Receiver can get the sender to speed up, by ACKing unreceived segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or send more ACKs (e.g., send ACK for each byte instead of every packet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Routing protocols: overly-trusting of participants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ARP: within a single Ethernet network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To send IP packet, need the Ethernet MAC address of router / next hop.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Address Resolution Protocol (ARP): broadcast a request for target''s MAC.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone can listen to broadcast, send a reply; no authentication.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary can impersonate router, intercept packets, even on switched net.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Potential solution: make the switch in charge of ARP.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not widely deployed: would require managing MAC/IP addresses carefully.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DHCP: again, within a single Ethernet network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client asks for IP address by sending a broadcast request.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server responds, no authentication (some specs exist but not widely used).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you just plugged into a network, might not know what to expect.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lots of fields: IP address, router address, DNS server, DNS domain list, ..'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adversary can impersonate DHCP server to new clients on the network.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can choose their DNS servers, DNS domains, router, etc.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, DoS attack on server: ask for lots of leases, from many MAC addrs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: make the switch in charge of DHCP (forward reqs to real server).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not widely deployed: would require careful switch configuration.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Even more complicated on a wireless network.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BGP: Internet-wide (similar to RIP attacks described in paper).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any BGP participant router can announce route to a prefix.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What if adversary has a router? Can announce any prefix or route.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is this problem still relevant?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spammers often exploit this: announce an unused address, and send spam.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gets around IP-level blacklisting of spam senders: choose almost any IP!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fix?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SBGP: cryptographic signing of route announcements.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must know who is allowed to announce every particular IP prefix.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires someone to distribute keys / certificates for every IP prefix.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping problem is tricky; some performance overheads too.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting some traction but still not widely deployed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other problems too.
  prefs: []
  type: TYPE_NORMAL
- en: 'ICMP messages like redirect: no authentication, basically unused now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exposing too much information (netstat, SNMP, finger): mostly fixed. identd
    ("Authentication Service"): bad design, no real authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Email: real problem but no practical solutions yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication vs authorization.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., PGP would not solve the spam problem.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passwords in protocols: supporting ONLY passwords isn''t so great.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll talk about alternatives in a few weeks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP data transfer protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server connects back to client to send a file to the client.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Client tells the server what IP address and port number to use.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Could be used for port-scanning from server's IP.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Could be used to send any traffic (embedded in file) from server's IP.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g., back to IP authentication problems: rlogin, spam, etc.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do adversaries know what software / protocol you are running?
  prefs: []
  type: TYPE_NORMAL
- en: 'Probing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if a system is listening on a well-known port.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols / systems often send an initial banner message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: nmap can guess OS by measuring various impl-specific details.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ref: http://nmap.org/book/man-os-detection.html'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use DNS to look up the hostname for an IP address; may give hints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Guessing: assume system is vulnerable, try to exploit bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do adversaries know the IP address of the system to attack?
  prefs: []
  type: TYPE_NORMAL
- en: traceroute to find routers along the way, for BGP attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can also just scan the entire Internet: only 2^32 addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Gbps (100 MB/s) network link, 64 byte minimum packets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ~1.5M packets per second.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2^32 = 4 Billion` packets in ~2500 seconds, or 45 minutes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[zmap](https://zmap.io/): implementation of this'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are things so insecure at the TCP/IP level?
  prefs: []
  type: TYPE_NORMAL
- en: Historically, designers did not worry as much about security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even Bellovin says: "The Internet in 1989 was a much friendlier place".'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Original Internet had a small number of relatively trustworthy users.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Design requirements changed over time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end argument in action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must provide security at the application level anyway.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Things are "good enough" at the transport level to let application work.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some fixes do get added, but only for the worst problems / easier solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to improve security?
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-compatible fixes to TCP implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewalls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial fix, but widely used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Issue: adversary may be within firewalled network.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Issue: hard to determine if packet is "malicious" or not.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Issue: even for fields that are present (src/dst), hard to authenticate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP/IP's design not a good match for firewall-like filtering techniques.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g., IP packet fragmentation: TCP ports in one packet, payload in another.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement security on top of TCP/IP: SSL/TLS, Kerberos, SSH, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beware: this paper isn''t clear on encryption vs. authentication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Will talk about this more in next lecture on Kerberos.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cryptography (encryption, signing, MACs, etc).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quite a hard problem: protocol design, key distribution, trust, etc.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some kinds of security hard to provide on top: DoS-resistance, routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deployment of replacement protocols: SBGP, DNSSEC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
