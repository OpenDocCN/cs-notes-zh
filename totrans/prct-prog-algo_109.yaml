- en: 5.3   Substring Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/53substring](https://algs4.cs.princeton.edu/53substring)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section under major construction. Searching in long strings - online.
  prefs: []
  type: TYPE_NORMAL
- en: '[This website](http://www-igm.univ-mlv.fr/~lecroq/string/) is a great resource
    for exact string searching algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: '[High-performance pattern matching in Java](http://johannburkard.de/software/stringsearch/)
    for general string searching, searching with wildcards, and searching with character
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Program [Brute.java](Brute.java.html) is brute force string search. Essentially
    equivalent to [SystemSearch.java](SystemSearch.java.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rabin-Karp.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Program [RabinKarp.java](RabinKarp.java.html) implements the Rabin-Karp randomized
    fingerprint algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth-Morris-Pratt.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Program [KMP.java](KMP.java.html) is Knuth-Morris-Pratt algorithm. [KMPplus.java](KMPplus.java.html)
    is an improved version that takes time and space proportional to M + N (independent
    of the alphabet size R).
  prefs: []
  type: TYPE_NORMAL
- en: Boyer-Moore.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Program [BoyerMoore.java](BoyerMoore.java.html) implements the bad-character
    rule part of the Boyer-Moore algorithm. It does not implement the strong good
    suffix rule.
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion detection systems.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Need very fast string searching since these are deployed at choke points of
    networks. Application
  prefs: []
  type: TYPE_NORMAL
- en: Q+A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design a brute-force substring search algorithm that scans the pattern from
    right to left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the trace of the brute-force algorithm in the style of figure XYZ for the
    following pattern and text strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AAAAAAAB; AAAAAAAAAAAAAAAAAAAAAAAAB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ABABABAB; ABABABABAABABABABAAAAAAAA
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the KMP DFA for the following pattern strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AAAAAAAB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AACAAAB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ABABABAB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ABAABAAABAAAB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ABAABCABAABCB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose that the pattern and text are random strings over an alphabet of size
    R >= 2\. Show that the expected number of character compares is (N - M + 1) (1
    - R^-M) / (1 - R^-1) <= 2 (N - M + 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct an example where the Boyer-Moore algorithm (with only the bad character
    rule) performls poorly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you modify Rabin-Karp to search for a given pattern with the additional
    proviso that the middle character is a "wildcard" (any text character at all can
    match it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you modify Rabin-Karp to determine whether any of a subset of k patterns
    (say, all of the same length) is in the text?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Compute the hashes of the k patterns and store the hashes in a
    SET.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How would you modify Rabin-Karp to search for an M-by-M pattern in an N-by-N
    text? Or some other irregularly-shaped pattern in an N-by-N text?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monte Carlo vs. Las Vegas Rabin Karp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Online palindrome detection.** Read in characters one at a time. Report at
    each instant if the current string is a palindrome. *Hint*: use Karp-Rabin hashing
    idea.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tandem repeats.** A tandem repeat of a base string b within a string s is
    a substring of s consisting of at least one consecutive copy of the base string
    b. Given b and s, design an algorithm to find a tandem repeat of b within s of
    maximum length. The running time should be proportional to M + N, where M is the
    length of b and N is the length of s.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* This problem is a generalization of substring search (is there
    at least one consecutive copy of b within s?) so we need an algorithm that generalize
    substring search. Create the Knuth-Morris-Pratt DFA for k concatenated copies
    of b, where k = n/m. Now, simulate DFA on input s and record the largest state
    that it reaches. From this, we can identify the longest tandem repeat.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Suffix-prefix match.** Design a linear-time algorithm to find the longest
    suffix of one string *a* that exactly matches a prefix of another string *b*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cyclic rotation.** Design a linear-time algorithm to determine whether one
    string is a cyclic rotation of another. A string *a* is a cyclic rotation of a
    string *b* if *a* and *b* have the same length and *a* consists of a suffix of
    *b* followed by a prefix of *b*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Substring of a circular string.** Design a linear-time algorithm to determine
    whether one string *a* is a substring of a cirular string *b*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest palindromic substring.** Given a string s, find the longest substring
    that is a palindrome (or a Watson-crick palindrome). *Solution*: can be solved
    in linear time using suffix trees or [Manacher''s algorithm](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html).
    Here''s a simpler solution that typically runs in linearthmic time. First, we
    describe how to find all palindromic substrings of length exactly L in linear
    time: use Karp-Rabin to iteratively form the hashes of each substring of length
    L (and its reverse), and compare. Since you don''t know L, repeatedly double your
    guess of L until you know the optimal length is between L and 2L. Then use binary
    search to find the exactly length.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* [Manacher.java](Manacher.java.html) is an implementation of Manacher''s
    algorithm.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Repeated substring.** [ [Mihai Patrascu](http://web.mit.edu/~mip/www/probs.html)]
    Given an integer K and a string of length N, find the longest substring which
    appears at least K times.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*One solution.* Assume you know the length L of the repeated string. Hash each
    substring of length L, and check if any hash occurs K or more times. If so, check
    to make sure you didn''t get unlucky. Since you don''t know L, repeatedly double
    your guess of L until you know the optimal length is between L and 2L. Then use
    binary search to find the right value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Longest common substring.** Given two (or three strings), find the longest
    substring that appears in all three. *Hint*: assume you know the length L of the
    longest common substring. Hash each substring of length L and check if any hash
    bucket contains (at least) one entry from each string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**All matches.** Modify KMP to find all matches in linear time (instead of
    leftmost match).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fibonacci string.** Interesting case for KMP. F(1) = B, F(2) = A, F(3) =
    AB, F(4) = ABA, F(5) = ABAAB, F(N) = F(N-1) F(N-2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that x and y are two strings. Design a linear-time algorithm to determine
    whether x^m = y^n for some integers m and n (where x^m means the concatenation
    of m copies of x).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Suffices to check where xy = yx (this fact is nontrivial - it follows
    from the Lyndon-Schutzenberger theorem).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Period of a string.** Let s be a nonempty string. An integer p such that
    s[i] = s[i+p] for all i = 0, 1, ..., N-p-1. is called a *period* of s The period
    of string s is the smallest integer p that is a period of s (can be N). For example,
    the period of ABCABCABCABCAB is 3. Design a linear-time algorithm to compute the
    period of a string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Border of a string.** Given a nonempty string s, we define string w to be
    a *border* of s if s = yw = wz for some strings y, z, and w with |y| = |z| = p,
    i.e., w is a proper substring of s that is both a prefix and a suffix of s. The
    border of a string is the longest proper border of s (can be empty). For example,
    the boder of ABCABCABCABCAB is w = ABCABCAB (with y = ABC, z = CAB, and p = 3).
    Design a linear-time algorithm to compute the border of a string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Anagram substring search.** Given a text string txt[] of length N and a pattern
    string pat[] of length M, determine whether pat[] or any of its anagrams (any
    of its M! permutations) appears in the text.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: maintain a histogram of the letter frequencies for a given substring
    of length M in the text.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
