- en: 6.6   Intractability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/66intractability](https://algs4.cs.princeton.edu/66intractability)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section under construction. The goal of complexity theory is to understand
    the nature of efficient computation. We have learned about analysis of algorithms,
    which enables us to classify *algorithms* according to the amount of resources
    they will consume. In this section, we will learn about a rich class of *problems*
    for which nobody has been able to devise an efficient algorithm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Computational complexity.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As digital computers were developed in the 1940s and 1950s, the Turing machine
    served as the theoretical model of computation. In the 1960s Hartmanis and Stearns
    proposed measuring the time and memory needed by a computer as a function of the
    input size. They defined complexity classes in terms of Turing machines and proved
    that some problems have "an inherent complexity that cannot be circumvented by
    clever programming." They also proved a formal version ([time hierarchy theorem](http://en.wikipedia.org/wiki/Time_hierarchy_theorem))
    of the intuitive idea that if given more time or space, Turing machines can compute
    more things. In other words, no matter how hard a problem is (time and space requirements),
    there are always harder problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Computational complexity is the art and science of determining resource requirements
    for different *problems*. Computational complexity deals with assertions about
    *any* conceivable algorithm for a problem. Making such statements is significantly
    more challenging than understanding the running time of one particular algorithm
    for the problem since we must reason about all possible algorithms (even those
    not yet discovered). This makes computational complexity an exciting, yet daunting,
    field of study. We will survey some of its most important ideas and practical
    outgrowths.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Polynomial time.
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have analyzed the running time of an algorithm as a function of its input
    size. When solving a given problem, we prefer an algorithm that takes 8 N log
    N steps to one that takes 3 N² steps, since when N is large, the first algorithm
    is significantly faster than the first. The second algorithm will ultimately solve
    the same problem (but it might take hours instead of seconds). In contrast, an
    exponential time algorithm has a different qualitative behavior. For example,
    a brute force algorithm for the TSP might take N! steps. Even if each electron
    in the universe (10^(79)) had the power of today's fastest supercomputer (10^(12)
    instructions per second), and each worked for the life of the universe (10^(17)
    seconds) on solving the problem, it would barely make a dent in solving a problem
    with N = 1,000 since 1000! >> 10^(1000) >> 10^(79) * 10^(12) * 10^(17). Exponential
    growth dwarfs technological change. We refer to any algorithm whose running time
    is bounded by a polynomial in the input size (e.g., N log N or N^2) as a *polynomial-time*
    algorithm. We say that a problem is *intractable* if there is no polynomial-time
    algorithm for the problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Create log-log scale plot of N, N³, N⁵, N^(10), 1.1^N, 2^N, N! as in Harel p.
    74.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: As programmers gained more experience with computation, it became evident that
    polynomial-time algorithms were useful and exponential-time algorithms were not.
    In a very [influential paper](../papers/edmonds.pdf), Jack Edmonds referred to
    polynomial algorithms as "good algorithms" and argued that polynomial time is
    a good surrogate for efficient computation. Kurt Godel wrote [a letter to von
    Neumann (p. 9)](http://www.cs.berkeley.edu/~luca/cs172/sipser92history.pdf) in
    1956 that contains the (implicit) notion that polynomiality is a desirable feature.
    Earlier (1953), von Neumann recognized the qualitative difference between polynomial
    and exponential algorithms. The idea of classifying problems according to polynomial
    and exponential time profoundly changed the way people thought about computational
    problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: NP.
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Informally we define a *search problem* as a computational problem where we
    are looking for a solution among a (potentially huge) number of possibilities,
    but such that when we find a solution, we can easily check that it solves our
    problem. Given an instance I of a *search problem* (some input data specifying
    the problem), our goal is to find a solution S (an entity that meets some pre-specified
    criterion) or report that no such solution exists. To be a search problem, we
    require that it be easy to *check* that S is indeed a solution. By easy, we mean
    polynomial-time in the size of the input I. The complexity class *NP* is the set
    of all search problems. Here are a few examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，我们将*搜索问题*定义为一个计算问题，我们在（可能巨大的）可能性中寻找解决方案，但是当我们找到解决方案时，我们可以轻松检查它是否解决了我们的问题。给定*搜索问题*的一个实例I（指定问题的一些输入数据），我们的目标是找到一个解决方案S（符合某些预先指定标准的实体）或报告不存在这样的解决方案。为了成为搜索问题，我们要求很容易*检查*
    S 是否确实是一个解决方案。在这里，我们指的是在输入I的大小上是多项式时间。复杂性类*NP*是所有搜索问题的集合。以下是一些例子。
- en: '*Linear systems of equations.* Given a system of linear equations Ax = b, find
    a solution x that satisfies the equations (if one exists). The problem is in NP
    because if we are given a purported solution x, we can check that Ax = b by plugging
    in x and verifying each equation.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性方程组。*给定线性方程系统Ax = b，找到满足方程的解x（如果存在）。这个问题属于NP，因为如果我们得到一个所谓的解x，我们可以通过将x代入并验证每个方程来检查Ax
    = b。'
- en: '*Linear programming.* Given a system of linear inequalities Ax ≤ b, find a
    solution x that satisfies the inequalities (if one exists). The problem is in
    NP because if we are given a purported solution x, we can check that Ax ≤ b by
    plugging in x and verifying each inequality.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性规划。*给定线性不等式系统Ax ≤ b，找到满足不等式的解x（如果存在）。这个问题属于NP，因为如果我们得到一个所谓的解x，我们可以通过将x代入并验证每个不等式来检查Ax
    ≤ b。'
- en: '*Integer linear programming.* Given a system of linear inequalities Ax ≤ b,
    find a binary (0/1) solution x that satisfies the inequalities (if one exists).
    The problem is in NP because if we are given a purported solution x, we can check
    that Ax ≤ b by plugging in x and verifying each inequality.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数线性规划。*给定线性不等式系统Ax ≤ b，找到满足不等式的二进制（0/1）解x（如果存在）。这个问题属于NP，因为如果我们得到一个所谓的解x，我们可以通过将x代入并验证每个不等式来检查Ax
    ≤ b。'
- en: While it is easy to check a proposed solution to all three problems, how difficult
    is it to *find* a solution from scratch?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查对这三个问题的提议解决方案很容易，但是从头开始找到解决方案有多困难？
- en: 'Remark: our definition of NP is slightly non-standard. Historically, complexity
    classes were defined in terms of decision problems (yes-no problems). For example,
    given a matrix *A* and a vector *b*, does there exist a solution *x* such that
    *Ax* = *b*?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：我们对NP的定义略有不同。在历史上，复杂性类别是根据决策问题（是-否问题）来定义的。例如，给定矩阵*A*和向量*b*，是否存在解*x*使得*Ax*
    = *b*？
- en: P.
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P。
- en: 'The complexity class P is the set of all search problems solvable in polynomial-time
    (on a deterministic Turing machine). As before, we define P in terms of search
    problems (instead of decision problems). It captures most of the problems that
    we can solve in practice on real machines. We list a few examples below:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性类P是所有可以在多项式时间内解决的搜索问题的集合（在确定性图灵机上）。与以前一样，我们根据搜索问题（而不是决策问题）来定义P。它涵盖了我们可以在实际机器上解决的大多数问题。以下列出了一些例子：
- en: '| Problem | Description | Algorithm | Instance | Solution |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 描述 | 算法 | 实例 | 解决方案 |'
- en: '| GCD | Find the greatest common divisor of two integers x and y. | Euclid''s
    algorithm (Euclid, 300 BCE) | 34, 51 | 17 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| GCD | 找到两个整数x和y的最大公约数。 | 欧几里得算法（欧几里得，公元前300年） | 34, 51 | 17 |'
- en: '| STCONN | Given a graph G and two vertices s and t, find a path from s to
    t. | BFS or DFS (Theseus) |  |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| STCONN | 给定图G和两个顶点s和t，找到从s到t的路径。 | BFS或DFS（Theseus） |  |  |'
- en: '| SORT | Find permutation that puts elements in ascending order. | Mergesort
    (von Neumann, 1945) | 2.3 8.5 1.2 9.1 2.2 0.3 | 5 2 4 0 1 3 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| SORT | 找到将元素按升序排列的排列。 | 归并排序（冯·诺伊曼，1945） | 2.3 8.5 1.2 9.1 2.2 0.3 | 5 2
    4 0 1 3 |'
- en: '| PLANARITY | Given a graph G, draw it in the plane so that no two edges cross.
    | (Hopcroft-Tarjan, 1974) |  |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| PLANARITY | 给定一个图G，在平面上画出它，使得没有两条边相交。 | （Hopcroft-Tarjan, 1974） |  |  |'
- en: '| LSOLVE | Given a matrix A and a vector b, find a vector x such Ax = b. |
    Gaussian elimination (Edmonds, 1967) | x+y=1 2x+4y=3 | x = 1/2 y = 1/2 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| LSOLVE | 给定矩阵A和向量b，找到一个向量x使得Ax = b。 | 高斯消元（Edmonds, 1967） | x+y=1 2x+4y=3
    | x = 1/2 y = 1/2 |'
- en: '| LP | Given a matrix A and a vector b, find a vector x such that Ax ≤ b? |
    Ellipsoid algorithm (Khachiyan, 1979) | x+y≤1 2x+4y≤3 | x = 0 y = 0 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| LP | 给定矩阵A和向量b，找到一个向量x使得Ax ≤ b？ | 椭球算法（Khachiyan, 1979） | x+y≤1 2x+4y≤3 |
    x = 0 y = 0 |'
- en: '| DIOPHANTINE | Given a (sparse) polynomial of one variable with integer coefficients,
    find an integral root? | (Smale et. al, 1999) | x⁵ - 32 | x = 2 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| DIOPHANTINE | 给定一个具有整数系数的（稀疏）一元多项式，找到一个整数根？ | （Smale等，1999） | x⁵ - 32 | x
    = 2 |'
- en: Extended Church-Turing Thesis.
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展的丘奇-图灵论断。
- en: 'In the mid 1960s Cobham and Edmonds independently observed that the set of
    problems solvable in a polynomial number of steps remains invariant over a very
    wide range of computational models, from deterministic Turing machines to RAM
    machines. The extended Church-Turing thesis asserts that the Turing machine is
    as efficient as any physical computing device. That is, P is the set of search
    problems solvable in polynomial-time *in this universe*. If some piece of hardware
    solves a problem of size N in time T(N), the extended Church-Turing thesis asserts
    that a deterministic Turing machine can do it in time T(N)^k for some fixed constant
    k, where k depends on the particular problem. Andy Yao expresses the broad implications
    of this thesis:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在1960年代中期，Cobham和Edmonds独立观察到，在一个广泛的计算模型范围内，可以在多项式步骤内解决的问题集保持不变，从确定性图灵机到RAM机。扩展的丘奇-图灵论题断言图灵机与任何物理计算设备一样高效。也就是说，P是在这个宇宙中可以在多项式时间内解决的搜索问题的集合。如果某个硬件解决了大小为N的问题，时间为T(N)，扩展的丘奇-图灵论题断言确定���图灵机可以在时间T(N)^k内解决它，其中k是某个固定常数，k取决于特定问题。Andy
    Yao表达了这个论题的广泛含义：
- en: They imply that at least in principle, to make future computers more efficient,
    one only needs to focus on improving the implementation technology of present-day
    computer designs.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们暗示，至少从原理上讲，要使未来的计算机更加高效，只需要专注于改进现代计算机设计的实现技术。
- en: In other words, any *reasonable* model of computation can be efficiently simulated
    on a (probabilistic) Turing machine. The extended Church-Turing thesis is true
    for all known physical general purpose computers. For random access machines (e.g.,
    your PC or Mac) the constant k = 2\. So, for example, if a random access machine
    can perform a computation in time N^(3/2), then a Turing machine can do the same
    computation in time N³.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何*合理*的计算模型都可以在（概率性）图灵机上高效模拟。对于所有已知的物理通用计算机，扩展的丘奇-图灵论题都是成立的。对于随机访问机器（例如您的PC或Mac），常数k
    = 2。因此，例如，如果随机访问机器可以在时间N^(3/2)内执行计算，则图灵机可以在时间N³内执行相同的计算。
- en: Does P = NP?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P = NP吗？
- en: One of the most profound scientific questions of our time is whether [P = NP](http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP).
    That is, can all search problems be solved in polynomial time? Clay Foundation
    offers a [1 million dollar millennium prize](http://www.claymath.org/millennium/)
    for solving it. Here are some speculations on [when the question will be resolved](http://www.cs.umd.edu/~gasarch/papers/poll.ps).
    The overwhelming consensus is that P != NP, but nobody has been able to prove
    it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个时代最深刻的科学问题之一是[P = NP](http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP)。也就是说，所有搜索问题是否都能在多项式时间内解决？Clay
    Foundation为解决这个问题提供了[100万美元的千禧奖](http://www.claymath.org/millennium/)。以下是一些关于[何时解决这个问题的猜测](http://www.cs.umd.edu/~gasarch/papers/poll.ps)。压倒性的共识是P
    != NP，但没有人能够证明。
- en: '[Video](http://youtube.com/watch?v=t_bO9LilNpE) of Homer Simpson pontificating
    over P = NP, with accompanying music Erased by Paradise Lost.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[视频](http://youtube.com/watch?v=t_bO9LilNpE)中荷马·辛普森对P = NP进行演讲，伴随着《失乐园》的音乐。'
- en: Godel's letter to von Neumann anticipated the P = NP question. He recognized
    that if P = NP (satisfiability is in P), it "would have consequences of the greatest
    importance" since then "the mental work of a mathematician concerning Yes-or-No
    questions could be completely replaced by a machine." He asked for which combinatorial
    problems was there a more efficient alternative to exhaustive search.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 哥德尔写给冯·诺伊曼的信预见了P = NP问题。他意识到如果P = NP（可满足性在P中），那么“将会有最重要的后果”，因为那时“数学家关于是或否问题的思维工作可以完全被机器取代”。他询问哪些组合问题存在更有效的替代方案以避免穷举搜索。
- en: NP-completeness.
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NP完全性。
- en: 'Informally, NP-complete problems are the "hardest" problems in NP; they are
    the ones most likely to not be in P. Define: a problem is *NP-complete* if (i)
    it is in NP and (ii) every problem in NP polynomial reduces to it. Defining the
    concept of NP-completeness does not mean that such problems exist. In fact, the
    existence of NP-complete problems is an amazing thing. We cannot prove a problem
    is NP-complete by presenting a reduction from each NP problem since there are
    infinitely many of them. In the 1960s, Cook and Levin proved that SAT is NP-complete.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，NP完全问题是NP中“最难”的问题；它们最有可能不在P中。定义：如果（i）它在NP中且（ii）每个NP问题都可以多项式归约到它，则问题是*NP完全*的。定义NP完全性的概念并不意味着这样的问题存在。事实上，NP完全问题的存在是一件令人惊奇的事情。我们无法通过从每个NP问题进行归约来证明问题是NP完全的，因为它们有无限多个。在1960年代，Cook和Levin证明了SAT是NP完全的。
- en: 'This is an example of universality: if we can solve any NP-complete, then we
    can solve any problem in NP. Unique scientific discovery giving common explanation
    to all sorts of problems. It is even more amazing that there exist "natural" problems
    that are NP-complete.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是普遍性的一个例子：如果我们可以解决任何NP完全问题，那么我们就可以解决NP中的任何问题。独特的科学发现为所有类型的问题提供了共同的解释。更令人惊讶的是，存在着“自然”的NP完全问题。
- en: The impact of NP-completeness on the natural sciences has been undeniable. One
    the first NP-complete problems were discovered, intractability "spread like a
    shockwave through the space of problems", first in computer science, and then
    to other scientific disciplines. Papadimitriou lists 20 diverse scientific disciplines
    that were coping with internal questions. Ultimately, scientists discovered their
    inherent complexity after realizing that their core problems were NP-complete.
    NP-completeness is mentioned as a keyword in 6,000 scientific papers per year.
    "Captures vast domains of computational, scientific, mathematical endeavors, and
    seems to roughly delimit what mathematicians and scientists had been aspiring
    to compute feasibly." [Papadimitriou] Few scientific theories have had such a
    breadth and depth of influence.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Some NP-complete problems.** Since the discovery that SAT is NP-complete,
    tens of thousands of problems have been identified as NP-complete. In 1972, Karp
    showed that 21 of the most infamous problem s in discrete mathematics were [NP-complete](http://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems),
    including `Tsp`, `Knapsack`, `3Color`, and `Clique`. The failure of scientists
    to find an efficient algorithm for these 21 problems, despite being unaware that
    they were NP-complete, was among the first evidence suggesting that P != NP. Below
    we list a sampling of some NP-complete problems. Here are some more [NP-complete
    problems](http://en.wikipedia.org/wiki/List_of_NP-complete_problems). This is
    only meant to illustrate their diversity and pervasiveness.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '*Bin Packing.* You have n items and m bins. Item i weighs w[i] pounds. Each
    bin can hold at most W pounds. Can you pack all n items into the m bins without
    violating the given weight limit?'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This problem has many industrial applications. For example, UPS may need to
    ship a large number of packages (items) from one distribution center to another.
    It wants to put them into trucks (bins), and use as few trucks as possible. Other
    NP-complete variants allow volume requirements: each 3-dimensional package takes
    up space and you also have to worry about arranging the packages within the truck.'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Knapsack*. You have a set of n items. Item i weighs w[i] pounds and has benefit
    b[i]. Can you select a subset of the items that have total weight less than or
    equal to W and total benefit greater than or equal to B? For example, when you
    go camping, you must select items to bring based on their weight and utility.
    Or, suppose you are burglarizing a home and can only carry W pounds of loot in
    your knapsack. Each item i weighs w[i] pounds has a street value of b[i] dollars.
    Which items should you steal?'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Subset Sum*. Given n integers does there exists a subset of them that sum
    exactly to B? For example, suppose the integers are {4, 5, 8, 13, 15, 24, 33}.
    If B = 36 then the answer is yes (and 4, 8, 24 is a certificate). If B = 14 the
    answer is no.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partition.* Given n integers, can you divide them into two subsets so that
    each subset sums to the same number? For example, suppose the integers are {4,
    5, 8, 13, 15, 24, 33}. Then the answer is `yes`, and {5, 13, 33} is a certificate.
    Load balancing for dual processors.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integer linear programming.* Given an integer matrix A and an integer vector
    b, does there exist an integer vector x such that Ax ≤ b? This is a central problem
    in operations research since many optimization problems can be formulated in this
    way. Note the contrast to the linear programming problem presented above where
    we are looking for a *rational* vector instead of an *integer* vector. The line
    between problems which are tractable and problems which are intractable can be
    very subtle.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SAT.* Given n Boolean variables x[1], x[2], ..., x[N] and a logical formula,
    is there an assignment of truth variables that makes the formula *satisfiable*,
    i.e., true? For example, suppose the formula is'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (x[1]' + x[2] + x[3]) (x[1] + x[2]' + x[3]) (x[2] + x[3]) (x[1]' + x[2]' + x[3]')
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (x[1]' + x[2] + x[3]) (x[1] + x[2]' + x[3]) (x[2] + x[3]) (x[1]' + x[2]' + x[3]')
- en: Then, the answer is yes and (x[1], x[2], x[3]) = (true, true, false) is a certificate.
    Many applications to electronic design automation (EDA), including testing and
    verification, logic synthesis, FPGA routing, and path delay analysis. Application
    to AI, including knowledge base deduction and automatic theorem proving.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，答案是yes，(x[1]，x[2]，x[3]) = (true，true，false)是一个证书。许多应用于电子设计自动化（EDA），包括测试和验证，逻辑综合，FPGA布线和路径延迟分析。应用于人工智能，包括知识库推理和自动定理证明。
- en: 'Exercise: given two circuits C1 and C2, design a new circuit C such that some
    setting of input values makes C output true if and only if C1 and C2 are equivalent.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：给定两个电路C1和C2，设计一个新电路C，使得一些输入值的设置使得C输出为真当且仅当C1和C2等价。
- en: '*3-SAT.* Given n Boolean variables x[1], x[2], ..., x[N] and a logical formula
    in conjunction normal form (product-of-sums) with exactly 3 distinct literals
    per clause, is there an assignment of truth variables that makes the formula satisfiable?'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3-SAT。* 给定n个布尔变量x[1]，x[2]，...，x[N]和一个逻辑公式（合取范式）的逻辑公式，每个子句恰好有3个不同的文字，是否存在一个真值变量的赋值使得公式可满足？'
- en: '*Clique*. Given n people and a list of pairwise friendships. Is there a group
    or *clique* of k people such that every possible pair of people within the group
    are friends? It is convenient to draw the *friendship graph*, where we include
    a node for each person and an edge connecting each pair of friends. In the following
    example with n = 11 and k = 4, the answer is `yes`, and {2, 4, 8, 9} is a certificate.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*团。* 给定n个人和一组成对友谊关系。是否存在一个由k个人组成的团或*团*，使得团内每对可能的人都是朋友？在绘制*友谊图*时很方便，其中我们为每个人包括一个节点，并连接每对朋友的边。在以下示例中，n
    = 11，k = 4，答案是`yes`，{2, 4, 8, 9}是一个证书。'
- en: '*Longest path*. Given a set of nodes and pairwise distances between nodes,
    does there exists a simple path of length at least L connecting some pair of nodes?'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最长路径。* 给定一组节点和节点之间的距离，是否存��一条长度至少为L的简单路径连接某对节点？'
- en: '*Machine Scheduling*. Your goal is to process n jobs on m machines. For simplicity,
    assume each machine can process any one job in 1 time unit. Also, there can be
    *precedence constraints*: perhaps job j must finish before job k can start. Can
    you schedule all of the jobs to finish in L time units?'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器调度。* 你的目标是在m台机器上处理n个作业。为简单起见，假设每台机器可以在1个时间单位内处理任何一个作业。此外，可能存在*优先约束*：也许作业j必须在作业k开始之前完成。你能安排所有作业在L个时间单位内完成吗？'
- en: 'Scheduling problems have a huge number of applications. Jobs and machines can
    be quite abstract: to graduate Princeton you need to take n different courses,
    but are unwilling to take more than m courses in any one semester. Also, many
    courses have prerequisites (you can''t take COS 226 or 217 before taking 126,
    but it is fine to take 226 and 217 at the same time). Can you graduate in L semesters?'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调度问题有大量的应用。工作和机器可能相当抽象：为了毕业普林斯顿，你需要修读n门不同的课程，但不愿意在任何一个学期修读超过m门课程。此外，许多课程有先修课程（在修读126之前不能修读COS
    226或217，但可以同时修读226和217）。你能在L个学期内毕业吗？
- en: '*Shortest Common Superstring*. Given the genetic alphabet { a, t, g, c } and
    N DNA fragments (e.g., ttt, atggtg, gatgg, tgat, atttg) is there a DNA sequence
    with K or fewer characters that contains every DNA fragment? Suppose K = 11 in
    the above example; then the answer is `yes` and `atttgatggtg` is a certificate.
    Applications to computational biology.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最短公共超字符串。* 给定基因字母表{ a，t，g，c }和N个DNA片段（例如，ttt，atggtg，gatgg，tgat，atttg），是否存在一个包含K个或更少字符的DNA序列，其中包含每个DNA片段？假设在上面的示例中K
    = 11；那么答案是`yes`，`atttgatggtg`是一个证书。应用于计算生物学。'
- en: '*Protein folding.* Proteins in organism *fold* in three dimensional dimensional
    space in a very specific way, to their *native state*. This geometric pattern
    determines the behavior and function of a protein. One of the most widely used
    folding models is the two dimensional hydrophilic-hydrophobic (H-P) model. In
    this model, a protein is a sequence of 0s and 1s, and the problem is to embed
    it into a 2-d lattice such that the number of pairs of adjacent 1s in the lattice,
    but not in the sequence (its energy), is minimized. For example, the sequence
    011001001110010 is embedded in the figure below in such a way that there are 5
    new adjacent pairs of 1s (denoted by asterisks).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蛋白质折叠。* 生物体内的蛋白质以非常特定的方式在三维空间中*折叠*到它们的*天然状态*。这种几何图案决定了蛋白质的行为和功能。最广泛使用的折叠模型之一是二维亲水-疏水（H-P）模型。在这个模型中，蛋白质是一个由0和1组成的序列，问题是将其嵌入到一个二维格子中，使得格子中相邻的1对数，但不在序列中（它的能量），被最小化。例如，序列011001001110010被嵌入到下图中，以便有5对新的相邻的1（用星号表示）。'
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Minimizing the H-P energy of a protein is NP-hard. (Papadimitriou, et al.) It
    is well accept by biologists that proteins fold to minimize their energies. A
    version of Levinthal's paradox asks how it is possible that proteins are able
    to efficiently solve apparently intractable problems.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小化蛋白质的H-P能量是NP难题。（Papadimitriou等）生物学家普遍认为蛋白质折叠是为了最小化它们的能量。Levinthal悖论的一个版本问如何可能蛋白质能够有效地解决表面上看起来棘手的问题。
- en: '*Integration.* Given integers a[1], a[2], ..., a[N], does the following integral
    equal 0?'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*积分。* 给定整数a[1]，a[2]，...，a[N]，以下积分是否等于0？'
- en: '![Integration](../Images/ec8837165bdfff7d34b3aa39202ebc65.png)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![积分](../Images/ec8837165bdfff7d34b3aa39202ebc65.png)'
- en: If you see this integral in your next Physics course, you should not expect
    to be able to solve it. This should not come as a big surprise because in Section
    7.4 we consider a version of integration that is undecidable.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在下一门物理课程中看到这个积分，你不应该期望能够解决它。这不应该让人感到惊讶，因为在第7.4节中，我们考虑了一个不可判定的积分版本。
- en: '*Crossword puzzle*. Given an integer N, and a list of valid words, is it possible
    to assign letters to the cells of an N-by-N grid so that all horizontal and vertical
    words are valid? No easier if some of the squares are black as in a crossword
    puzzle.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*填字游戏.* 给定一个整数N和一个有效单词列表，是否可以将字母分配给一个N×N的网格的单元格，以便所有水平和垂直单词都是有效的？如果一些方格是黑色的，像填字游戏一样，是否更容易？'
- en: '*Theorem.* Given a purported theorem (such as one for the Riemann Hypothesis),
    can you prove it is true using at most n symbols in some formal system such as
    Zermelo-Fraenkel set theory?'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定理.* 给定一个假设的定理（比如黎曼猜想），你能否在某种形式系统（如策梅洛-弗伦克尔集合论）中使用最多n个符号证明它是真的？'
- en: '*Tetris.*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*俄罗斯方块.*'
- en: '*Minesweeper.*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扫雷.*'
- en: '*Regular expressions.* Give two regular expressions over the unary alphabet
    { 1 }, do they represent different languages? Give two NFAs, do they represent
    different languages? It may not be apparent that either problem is even decidable
    since we don''t have an obvious bound on the size of the smallest string that
    is in one language but not the other. [Note that the corresponding inequivalence
    problem for DFAs is polynomial solvable.] The reason why we phrase the problem
    as inequivalence instead of equivalence is that it is easy to check that the two
    entities are non-equivalent by demonstrating a string s. In fact, if the two languages
    are different, then the smallest string is polynomial in the size of the input.
    Thus, we can use the efficient algorithms from Section 7.xyz to check whether
    s is recognized by an RE or accepted by an NFA. However, to argue that two REs
    are equivalent, we would need an argument that guarantees that all strings in
    one are in the other, and vice versa. [It is possible to devise an (exponential)
    algorithm to test whether two REs or NFAs are equivalent, although this should
    not be obvious.]'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式.* 给定两个在一元字母表{ 1 }上的正则表达式，它们表示不同的语言吗？给定两个NFA，它们表示不同的语言吗？也许很难确定这两个问题是否可判定，因为我们没有对一个语言中最小字符串的大小有明显的界限，而不在另一个语言中。[请注意，对于DFA的对应不等价问题是多项式可解的。]
    我们将问题表述为不等价而不是等价的原因是，通过展示一个字符串s，很容易检查这两个实体是否不等价。实际上，如果两个语言不同，那么最小字符串在输入大小的多项式中。因此，我们可以使用第7.xyz节中的高效算法来检查s是否被RE识别或被NFA接受。然而，要证明两个RE等价，我们需要一个保证所有字符串都在另一个中的论证，反之亦然。[可以设计一个（指数级）算法来测试两个RE或NFA是否等价，尽管这并不明显。]'
- en: '*Lemmings.* Is it possible to guide a tribe of green-haired lemming creatures
    to safety in a level of the game Lemmings?'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旅鼠.* 在游戏旅鼠的一个关卡中，是否可能引导一群绿发旅鼠生物安全到达目的地？'
- en: '*Multinomial minimization over unit hypercube.* Given a multinomial of N variables,
    is the minimum <= C, assuming all variables are bounded between 0 and 1. Classic
    calculus problem: min f(x) = ax^2 + bx + c over [0, 1]. Derivative at x = ?? is
    0, but minimum occurs at boundary.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单位超立方体上的多项式最小化.* 给定N个变量的多项式，是否最小值<= C，假设所有变量都在0和1之间。经典微积分问题：在[0, 1]上，min f(x)
    = ax^2 + bx + c。在x = ??处的导数为0，但最小值出现在边界处。'
- en: '*Quadratic Diophantine equations.* Given positive integers a, b, and c, are
    there positive integers x and y such that ax² + by = c?'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次丢番图方程.* 给定正整数a、b和c，是否存在正整数x和y，使得ax² + by = c？'
- en: '*Knot theory.* Which knots on a 3-dimensional manifold bound a surface of genus
    ≤ g?'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结实论.* 在三维��形上哪些结实限制了一个genus ≤ g的表面？'
- en: '*Bounded Post Correspondence Problem.* Given a post correspondence problem
    with N cards and an integer K &le N, is there a solution that uses at most K cards?
    Recall it is undecidable if there is no limit on K.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有界后对应问题.* 给定一个具有N张卡片的后对应问题和一个整数K &le N，是否存在一个使用最多K张卡片的解？请注意，如果K没有限制，那么这是不可判定的。'
- en: '*Nash equilibria.* Cooperative game theory. Given a 2-player game, find a Nash
    equilibrium that maximizes the payoff to player 1. Do more than one NE exist?
    Is there a NE that is Pareto optimal? NE that maximizes social welfare.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纳什均衡.* 合作博弈论。给定一个2人游戏，找到最大化玩家1收益的纳什均衡。是否存在多个NE？是否存在一个帕累托最优的NE？最大化社会福利的NE。'
- en: '*Quadratic congruence.* Given positive integers a, b, and c, is there a positive
    integer x < c such that x² = a (mod b)?'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次同余.* 给定正整数a、b和c，是否存在一个小于c的正整数x，使得x² = a (mod b)？'
- en: '*Ising model in 3d.* Simple mathematical model of phase transitions, e.g.,
    when water freezes or when cooling iron becomes magnetic. Computing lowest energy
    state is NP-hard. Solvable in polynomial time if graph is planar, but 3d lattice
    is nonplanar. Holy grail of statistical mechanics for 75 years before proved NP-hard.
    Establishing NP-completeness means that physicists won''t spend another 75 years
    attempting to solve the unsolvable.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3D中的伊辛模型.* 相变的简单数学模型，例如，当水结冰或冷却铁变成磁性时。计算最低能量状态是NP难的。如果图是平面的，则可以在多项式时间内解决，但3D晶格是非平面的。在被证明NP难之前，统计力学的圣杯已经存在了75年。建立NP完全性意味着物理学家不会再花75年时间试图解决不可解的问题。'
- en: '*Bandwidth minimization*. Given an N-by-N matrix A and an integer B, is it
    possible to permute the rows and columns of A such that A[ij] = 0 if |i - j| >
    B. Useful for numerical linear algebra.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带宽最小化.* 给定一个N×N矩阵A和一个整数B，是否可以重新排列A的行和列，使得A[ij] = 0，如果|i - j| > B。对数值线性代数很有用。'
- en: '*Voting and social choice.* NP-hard for an individual to manipulate a voting
    scheme known as [single transferable vote](http://www.isye.gatech.edu/~jjb/papers/stv.pdf).
    NP-hard to determine who has won an election in a scheme seriously proposed by
    Lewis Carroll (Charles Dodgson) in 1876. In Carroll''s scheme, the winner is the
    candidate who with the fewest pairwise adjacent changes in voters'' preference
    rankings becomes the Condercet winner (a candidate who would beat all other candidates
    in a pairwise election). Shapley-Shubik voting power. Computing the [Kemeny optimal
    aggregation](http://www10.org/cdrom/papers/577/).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coping with intractability.
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The theory of NP-completeness says that unless P = NP, there are some important
    problems for which we can''t create an algorithm that simultaneously achieves
    the following three properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Guarantee to solve the problem in polynomial-time.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guarantee to solve the problem to optimality.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guarantee to solve arbitrary instances of the problem.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we encounter an NP-complete problem, we must relax one of the three requirements.
    We will consider solutions to the TSP problem that relax one of the three goals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Complexity theory deals with worst-case behavior. This leaves open the possibility
    of designing algorithms that run quickly on some instances, but take a prohibitive
    amount of time on others. For example, [Chaff](http://www.princeton.edu/pr/pwb/01/0305/1b.shtml)
    is a program that can solve many real-world SAT instances with 10,000 variables.
    Remarkably, it was developed by two undergraduates at Princeton. The algorithm
    does not guarantee to run in polynomial time, but the instances we're interested
    in may be "easy."
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we may be willing to sacrifice the guarantee on finding the optimal
    solution. Many heuristic techniques (simulating annealing, genetic algorithms,
    Metropolis algorithm) have been designed to find "nearly optimal" solutions to
    the TSP problem. Sometimes it is even possible to prove how good the resulting
    solution will be. For example, Sanjeev Arora designed an *approximation algorithm*
    for the Euclidean TSP problem that guarantees to find a solution that costs at
    most, say 1%, above the optimum. Designing approximation algorithms is an active
    area of research. Unfortunately, there are also non-approximability results of
    the form: if you can find an approximation algorithm for problem X that guarantees
    to get within a factor of 2 of the optimum, then P = NP. Thus, designing approximation
    algorithms for some NP-complete problems is not possible.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: If we are trying to solve a special class of TSP problems, e.g., where the points
    lie on the boundary of a circle or the vertices of an M-by-N lattice, then we
    can design efficient (and trivial) algorithms to solve the problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploiting intractability.** Having intractability problems is occasionally
    a good thing. In Section XYZ, we will exploit intractable problems to design cryptographic
    systems.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Between P and NP-complete.** Most natural problems in NP are now known to
    be in P or NP-complete. If P != NP, then there are provably some NP problems that
    are neither in P or NP-complete. Like "dark matter we have not developed means
    of observing." A few notable unclassified problems in the netherworld: factoring,
    and subgraph isomorphism.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '*Factoring.* Best known algorithm is 2^O(n^1/3 polylog(n)) - number field sieve.
    Believed by experts not to be in P.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Precedence constrained 3-processor scheduling.* Given a set of unit length
    tasks, and a precedence order, find the shortest schedule on 3 parallel machines.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Turnpike problem.* Given N(N-1)/2 positive numbers (not necessarily distinct),
    does there exist a set of N points on the line such that these numbers are the
    pairwise distances of the N points. Intuition: points are exits on I-95\. Problem
    first arose in 1930s in the context of x-ray crystallography. Also known as the
    *partial digest problem* in molecular biology.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boolean formula dualization.* Given a monotone CNF formula and a monotone
    DNF formula, are they equivalent? (a + b)(c + d) = ac + ad + bc + bd. Naively
    applying De Morgan''s law leads to exponential algorithm because of redundancy.
    Best algorithm O(n^(log n / log log n)).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔公式对偶化。* 给定一个单调 CNF 公式和一个单调 DNF 公式，它们是否等价？(a + b)(c + d) = ac + ad + bc +
    bd。简单地应用德摩根定律会导致指数级算法，因为存在冗余。最佳算法为 O(n^(log n / log log n))。'
- en: '*Stochastic games.* White, Black and Nature alternate moving a token on the
    edges of a directed graph, starting at the start state s. White''s goal is to
    move the token to a goal state t. Black''s goal is to prevent the token from ever
    reaching t. Nature moves the tokens at random. Given a digraph, a start state
    s, and a goal state t,, does White have a strategy which will make the token reach
    t with probability ≥ 1/2? Problem is in NP intersect co-NP, but not known to be
    in P. Believed to be in P, we just haven''t found a polynomial-time algorithm.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机游戏。* 白色、黑色和自然轮流在有向图的边上移动一个令牌，从起始状态 s 开始。白色的目标是将令牌移动到目标状态 t。黑色的目标是阻止令牌到达
    t。自然以随机方式移动令牌。给定一个有向图、一个起始状态 s 和一个目标状态 t，白色是否有一种策略使得令牌到达 t 的概率 ≥ 1/2？该问题属于 NP
    交 co-NP，但尚不清楚是否属于 P。人们相信它属于 P，只是我们还没有找到一个多项式时间算法。'
- en: Other complexity classes.
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他复杂度类。
- en: The complexity classes P, NP, and NP-complete are the three most famous complexity
    classes. Scott Aaronson's website [The Complexity Zoo]( http://www.complexityzoo.com)
    contains a comprehensive list of other complexity classes that are useful in classifying
    problems according to their computational resources (time, space, parallelizability,
    use of randomness, quantum computing). We describe a few of the most important
    ones below.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度类 P、NP 和 NP-完全是三个最著名的复杂度类。Scott Aaronson 的网站[The Complexity Zoo](http://www.complexityzoo.com)包含了其他复杂度类的全面列表，这些类对问题根据其计算资源（时间、空间、可并行性、随机性使用、量子计算）进行分类。我们在下面描述了一些最重要的类。
- en: '*PSPACE.* The complexity class PSPACE = problems solvable by a Turing machine
    using polynomial space. PSPACE-complete = in PSPACE and every other problem in
    PSPACE can be reduced to it in polynomial time.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PSPACE.* 复杂度类 PSPACE = 可以使用多项式空间的图灵机解决的问题。PSPACE-完全 = 在 PSPACE 中，且可以在多项式时间内将所有其他问题归约为它。'
- en: Here is a complexity version of the halting problem. Given a Turing machine
    that is limited to n tape cells, does it halt in at most k steps? The problem
    is PSPACE-complete, where n is encoded in unary. This means that unless P = PSPACE,
    we are unlikely to be able to tell whether a given program, running on a computer
    with n units of memory, will terminate before k steps substantially faster than
    the trivial method of running it for k steps and seeing what happens.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是停机问题的一个复杂版本。给定一个被限制在 n 个磁带单元上的图灵机，在最多 k 步内是否会停机？该问题是 PSPACE-完全的，其中 n 以一元编码。这意味着除非
    P = PSPACE，否则我们不太可能能够判断一个给定程序在具有 n 个内存单元的计算机上运行是否会在 k 步之前终止，比简单地运行它 k 步并观察发生的情况要快得多。
- en: 'Bodlaender: given a graph with vertices 1, ..., N, two players alternate in
    labeling the vertices red, green, or blue. The first player to label a vertex
    the same color as one of its neighbors loses. Determining whether there is a winning
    strategy for the first player is PSPACE-complete.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bodlaender：给定一个具有顶点 1, ..., N 的图，两名玩家轮流标记顶点为红色、绿色或蓝色。第一个标记一个与其邻居相同颜色的顶点的玩家失败。确定第一个玩家是否有获胜策略是
    PSPACE-完全的。
- en: Versions of many conventional games are provably intractable; this partially
    explains their appeal. Also natural generalizations of Othello, Hex, Geography,
    Shanghai, Rush Hour, go-moku, Instant Insanity, and Sokoban are PSPACE-complete.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多传统游戏的变体被证明是棘手的；这在一定程度上解释了它们的吸引力。此外，黑白棋、六角、地理、上海、赛车、五子棋、瞬间疯狂和推箱子的自然推广都是 PSPACE-完全的。
- en: '[Eppstein''s list of hard games](http://www.ics.uci.edu/~eppstein/cgt/hard.html).'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Eppstein 的困难游戏列表](http://www.ics.uci.edu/~eppstein/cgt/hard.html)。'
- en: Is a given string a member of a context sensitive grammar?
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个给定的字符串是否是上下文敏感文法的成员？
- en: Do two regular expressions describe different languages? PSPACE-complete even
    over the binary alphabet and if one of the regular expressions is `.*`.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个正则表达式是否描述不同的语言？即使在二进制字母表上也是 PSPACE-完全的，如果其中一个正则表达式是`.*`。
- en: Another example that can be made rigorous is the problem of moving a complicated
    object (e.g., furniture) with attachments that can move and rotate through an
    irregularly shaped corridor.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个可以严格化的例子是移动一个复杂对象（例如家具），其附件可以通过不规则形状的走廊移动和旋转。
- en: Another example arises in parallel computing when the challenge is to determine
    whether a deadlock state is possible within a system of communicating processors.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个例子出现在并行计算中，当挑战是确定在一个通信处理器系统中是否可能存在死锁状态时。
- en: Note PSPACE = NPSPACE (Savitch's theorem).
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 PSPACE = NPSPACE（Savitch 定理）。
- en: '*EXPTIME.* The complexity class EXPTIME = all decision problem solvable in
    exponential time on deterministic Turing machine. Note P ⊆ NP ⊆ PSPACE ⊆ EXPTIME,
    and, by the time hierarchy theorem, at least one inclusion is strict, but unknown
    which one (or more). It is conjectured that all inclusions are strict.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EXPTIME.* 复杂度类 EXPTIME = 所有在确定性图灵机上以指数时间可解决的决策问题。注意 P ⊆ NP ⊆ PSPACE ⊆ EXPTIME，并且根据时间层次定理，至少有一个包含是严格的，但不知道是哪一个（或多个）。有人推测所有包含都是严格的。'
- en: Roadblock from Harel p. 85.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harel 的 Roadblock 第 85 页。
- en: 'Natural generalization of chess, checkers, Go (with Japanese style ko termination
    rule), and Shogi are EXPTIME-complete. Given a board position, can the first player
    force a win? Here N is the size of the board, and the running time is exponential
    in N. One reason that these problems are harder from a theoretical standpoint
    than Othello (and other PSPACE-complete games) is that they can take an exponential
    number of moves. Checkers (aka English draughts on an N-by-N board): player can
    have an exponential number of moves at a given turn because of jump sequences.
    [[pdf](../papers/checkers.pdf)] Note: depending on termination rules, checkers
    can either be PSPACE-complete or EXPTIME-complete. For EXPTIME-complete, we assume
    the "forced capture rule" where a player must make a jump (or sequence of jumps)
    if available.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a complexity version of the halting problem. Given a Turing machine,
    does it halt in at most k steps? Alternatively, given a fixed Java program and
    a fixed input, does it terminate in at most k steps? The problem is EXPTIME-complete.
    Here the running time is exponential in the binary representation of k. In fact,
    no turing machine can guarantee to solve it in, say, O(k / log k) steps. Thus,
    brute force simulation is essentially best possible: provably, the problem cannot
    be solved substantially faster than the trivial method of running the Turing machine
    for the first k steps and seeing what happens.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An EXPTIME-complete problem cannot be solved in polynomial-time on a deterministic
    Turing machine - it does not depend on the P ≠ NP conjecture.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*EXPSPACE.* EXPSPACE-complete: given two "extended" regular expressions, do
    they represent different languages? By extended, we allow a squaring operation
    (two copies of an expression). Stockmeyer and Meyer (1973). Or, more simply set
    intersection (Hunt, 1973). Word problem for Abelian groups (Cardoza, Lipton, Meyer,
    1976), Vector Addition Subsystem.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [Vector Addition Subsystem](http://rjlipton.wordpress.com/2009/04/08/an-expspace-lower-bound/)
    is EXPSAPCE-hard: given a nonnegative vector s and a set of arbitrary vectors,
    v1, v2, ..., vn, a vector x is reachable from s if it is either (i) the vector
    s or (ii) the vector y + vi where y is reachable. The VAS problem is to determine
    whether a given vector x is reachable.'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*DOUBLE-EXPTIME.* The class DOUBLE-EXPTIME is the set of all decision problems
    solvable in doubly exponential time. A remarkable example is determining whether
    a formula in [first order Presburger arithmetic](http://en.wikipedia.org/wiki/Presburger_arithmetic)
    is true. Presburger arithmetic consists of statements involving integers with
    + as the only operation (no multiplication or division). It can model statements
    like the following: if x and y are integer such that x &le y + 2, then y + 3 >
    x. In 1929 Presburger proved that his system is consistent (can''t prove a contradiction
    like 1 > 2) and complete (every statement can be proven true or false). In 1974,
    Fischer and Rabin proved that any algorithm that decides the truth of a Presburger
    formula requires at least 2^((2^(cN))) time for some constant c, where N is the
    length of the formula.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Non-elementary.* More than 2^2^2^...^2^N for any finite tower. Given two regular
    expressions that allow squaring and complementation, do they describe different
    languages?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other types of computational problems.
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We focus on search problems since this is a very rich and important class of
    problems for scientists and engineers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '*Search problems.* This is the version we have considered in detail. Technically,
    FP = polynomial-time function problems, FNP = polynomial-time function problems
    on nondeterministic Turing machine. FP problems can have any output that can be
    computed in polynomial time (e.g., multiplying two numbers or finding the solution
    to Ax = b).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decision problems.* Traditionally, complexity theory is defined in terms of
    yes/no problems, e.g., Does there exist a solution to Ax &le b? Definition of
    reduction is cleaner (no need to deal with output). Classes P and NP traditionally
    defined in terms of decision problems. Typically the search problem reduces to
    the decision problem (and this is known to be true for all NP-complete problems).
    Such search problems are referred to as *self-reducible*. The P = NP question
    is equivalent to the FP = FNP question.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Total functions.* Occasionally, a decision problem is easy, while the corresponding
    search problem is (believed to be) hard. For example, there may be a theorem asserting
    that a solution is guaranteed to exist, but the theorem does not provide any hint
    as to how to find one efficiently.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[subset sum example](http://theory.lcs.mit.edu/classes/6.042/spring04/handouts/numbers.shtml).
    Given N numbers, find two (disjoint) subsets of these N numbers that sum to exactly
    the same value. If N = 77 and all the numbers are at most twenty-one decimal digits
    long, then by the pigeonhole principle, at least two subsets must sum to the same
    value. This is because there are 2^77 subsets but at most 1 + 77 * 10^21 < 2^77
    possible sums. Or decision = composite, search = factor.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: John Nash proved that *Nash equilibria* always exist in a normal form game of
    two or more players with specified utilities. Proof was nonconstructive, so unclear
    how to find such an equilibria. Proved to be *PPAD-complete* - the analog of NP-complete
    for problems known to have solutions.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: General equilibrium theory is foundation of microeconomics. Given an economy
    with k commodities, each of N agents has an initial endowment of the commodities.
    Each agent also as a utility function for each commodity. The [Arrow-Debreu theorem](http://en.wikipedia.org/wiki/Arrow_Debreu)
    asserts that under suitable technical conditions (e.g., utility functions are
    continuous, monotonic, and strictly concave) there exist a (unique) set of *market
    prices* such that each agent sells all their goods and buys the optimal bundle
    using this money (i.e., supply equals demand for every commodity). But how does
    market compute it? The proof relies on a deep theorem from topology (Kakutani's
    fixed point theorem) and no efficient algorithm is currently known. Economists
    assume that the market finds the equilibrium prices; Adam Smith used the metaphor
    of [the invisible hand](http://en.wikipedia.org/wiki/Invisible_hand) to describe
    this social mechanism.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalization of 15-slider puzzle. Testing whether solution exists is in P,
    but finding shortest solution is intractable. [Ratner-Warmuth, 1990]
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Optimization problems.* Sometimes we have optimization problems, e.g., TSP.
    Given an NP problem and a cost function on solutions, the goal for a given instance
    is to find the *best* solution for it (e.g find the shortest TSP tour, the minimum
    energy configuration, etc.) Sometimes hard to formulate as a search problem (find
    the shortest TSP tour) since not clear how to efficiently check that you have
    optimal tour. Instead, we rephrase as: given a length L, find a tour of length
    at most L. Then binary search for optimal L.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Counting problems.* Given an NP problem, find the number of solutions for
    it. For example, given a CNF formula, how many satisfying assignments does it
    have? Includes many problems in statistical physics and combinatorics. Formally,
    the class of problems is known as [#P](http://en.wikipedia.org/wiki/Sharp-P).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Strategic problems.* Given a game, find an optimal strategy (or best move)
    for a player. Includes many problems in economics and board games (e.g., chess,
    go).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output polynomial time.
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some problems involve more output than a single bit of information. For example,
    outputting a solution to the Towers of Hanoi problem requires at least 2^N steps.
    This requirement is not because the solution is inherently hard to compute, but
    rather because there are 2^N symbols of output, and it takes one unit of time
    to write each output symbol. Perhaps a more natural way to measure efficiency
    is a function both of the input size and of the output size. A classic electrical
    engineering problem with DFAs is to build a DFA from a RE that uses the minimum
    number of states. We would like an algorithm that is polynomial in the size of
    the input RE (number of symbols) and also in the size of the output DFA (number
    of states). Unless P = NP, designing such an algorithm is impossible. In fact,
    it's not even possible to design a polynomial algorithm that gets the answer within
    a constant (or even polynomial) number of states! Without the theory of NP-completeness,
    researchers would waste time following unpromising research directions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Other lower bounds.
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Information theoretic.* In Section X.Y we saw that insertion uses at most
    N^2 compares to sort N items, and mergesort uses at most N log N compares. A natural
    question to ask is whether we can do better, perhaps one that uses at most 5N
    compares or even 1/2 N log N compares. To make the question more precise, we must
    explicitly state our computational model (decision tree). Here, we assume that
    we only access the data through the `less()` function. A remarkable theorem due
    to X says that no (comparison based) sorting algorithm can guarantee to sort every
    input of N distinct elements in fewer than ~ N log N compares. To see why, observe
    that each compare (call to `less`) provides one bit of information. In order to
    identify the correct permutation, you need log N! bits, and log N! ~ N log N.
    This tells us that mergesort is (asymptotically) the best possible sorting algorithm.
    No sorting algorithm in existence (or even one not yet imagined) will use substantially
    fewer compares.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*3-Sum hard.* Given a set of N integers, do any three of them sum to 0? Quadratic
    algorithm exists (see exercise xyz), but no subquadratic algorithm known. 3-SUM
    linear reduces to many problems in computational geometry. (find whether set of
    points in the plane have 3 that are collinear, decide whether a set of line segments
    in the plane can be split into two subsets by a line, determining whether a set
    of triangles cover the unit square, can you translate a polygon P to be completely
    inside another polygon Q, robot motion planning).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute force TSP takes N! steps. Using dynamic programming, can get it down to
    2^N. Best lower bound = N. Essence of computational complexity = trying to find
    matching upper and lower bounds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Circuit complexity.
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other ways to define and measure computational complexity. A Boolean
    circuit of n inputs can compute any Boolean function of n variables. We can associate
    the set of binary strings of size n for which the circuit outputs 1 as the set
    of strings in the language. We need one circuit for each input size n. Shannon
    (1949) proposed the size of the circuit as a measure of complexity. It is known
    that a language has *uniformly* polynomial circuits if and only if the language
    is in P.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Physical and analog computation.
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The P = NP question is a mathematical question regarding the capabilities of
    Turing machines and classical digital computers. We might also wonder whether
    the same is true for analog computers. By *analog*, we mean any "deterministic
    physical device that uses a fixed number of physical variables to represent each
    problem variable." Internal state represented by continuous variables instead
    of discrete. E.g., soap bubbles, protein folding, quantum computing, gears, time
    travel, black holes, etc.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[Vergis, Steiglitz, and Dickinson](../papers/vergis-steiglitz-dickinson.pdf)
    proposed an analog form of the Strong Church-Turing thesis:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Any finite analog computer can be simulated *efficiently* by a digital computer,
    in the sense that the time required by the digital computer to simulate the analog
    computer is bounded by a polynomial function of the resources used by the analog
    computer.
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The resources of the analog computer could be time, volume, mass, energy, torque,
    or angular momentum. Reference: [The Physics of Analog Computation](http://www.cs.princeton.edu/courses/archive/fall04/cos576/papers/vergis_steiglitz_dickinson86.pdf)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Any reasonable model of computation (e.g., not involving exponential parallelism)
    can be simulated in polynomial time by a Turing machine (supplemented by a hardware
    random number generator).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference: [Scott Aaronson](../papers/aaronson.pdf). Can yield new insights
    into physics. One day "the presumed intractability of NP-complete problems might
    be taken as a useful constraint in the search for new physical theories" just
    like the second law of thermodynamics. Still can be falsified by experiment, but
    don''t waste time looking...'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*Soap bubbles.* Folklore that you can solve Steiner tree problem. In reality,
    only finds a local minimum, and may take a while to do so.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quantum computing.* One speculative model of computation - quantum computers
    - might be capable of solving some problems in a polynomial time that a deterministic
    Turing machine cannot do. Peter Shor discovered an N^3 algorithm for factoring
    N-digit integers, but the best known algorithm on a classical computer takes time
    exponential in N. Same idea could lead to a comparable speedup in simulating quantum
    mechanical systems. This explains the recent excitement in quantum computation,
    as it could result in a paradigm shift for computing. However, quantum computers
    do not yet violate the extended Church-Turing thesis since we don''t yet know
    how to build them. (Difficult to harness because much of the quantum information
    seems to be easily destroyed by its interactions with the outside world, i.e.,
    decoherence.) Moreover, it is still possible that someone might discover a polynomial-time
    algorithm for factoring on a classical computer, although most experts suspect
    that this is not possible. Grover''s algorithm: search in sqrt(N) time instead
    of N.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Richard Feynman showed in 1982 that classical computers cannot simulate quantum
    mechanical systems without slowing down exponentially (crux of argument is that
    Turing machines have locality of reference whereas quantum mechanics includes
    "exploit spooky action at a distance"). A quantum computer might be able to get
    around this problem. Feynman quote with respect to building a computer to simulate
    physics...
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"The rule of simulation that I would like to have is that the number of computer
    elements required to simulate a large physical system is only to be proportional
    to the space-time volume of the physical system. I don''t want to have an explosion."'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rephrase in terms of modern complexity theory by replacing "proportional to"
    by "bounded by a polynomial function of".
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deutsch-Jozsa give algorithm that is provably exponentially faster on a quantum
    computer than on a deterministic Turing machine. (Though exponential gap does
    not exist if the Turing machine has access to a hardware random number generator
    and can be wrong with negligible probability. Quantum computers can generate true
    randomness. )
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PRIMES and COMPOSITE.
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to convince someone that a number is composite by producing a factor.
    Then, the person just has to check (by long division) that you did not lie to
    them. Marin Mersenne conjectured that numbers of the form 2^p - 1 are prime for
    p = 2, 3, 5, 7, 13, 17, 19, 31, 67, 127 and 257. His conjecture for p = 67 was
    disproved by F. N. Cole over two hundred and fifty years later in 1903. According
    to E. T. Bell''s book *Mathematics: Queen and Servant of Science*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the October meeting of the AMS, Cole announced a talk "On the Factorisation
    of Large Numbers". He walked up to the blackboard without saying a word, calculated
    by hand the value of 2^(67), carefully subtracted 1. Then he multiplied two numbers
    (which were 193707721 and 761838257287). Both results written on the blackboard
    were equal. Cole silently walked back to his seat, and this is said to be the
    first and only talk held during an AMS meeting where the audience applauded. There
    were no questions. It took Cole about 3 years, each Sunday, to find this factorization,
    according to what he said.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the record 2^(67) - 1 = 193707721 × 761838257287 = 147573952589676412927.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Q + A
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Are polynomial algorithms always useful?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No, algorithms that take N^(100) or 10^(100) N² steps are as useless
    in practice as exponential ones. The constants that arise in practice are usually
    sufficiently small that polynomial-time algorithms scale to huge problems, so
    polynomiality often serves as a surrogate for useful in practice.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why is the class of all search problems named NP?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The original definition of NP was in terms of *nondeterministic* Turing
    machines: NP is the set of all decision problems that can be solved in polynomial-time
    on a nondeterministic Turing machine. Roughly speaking, the difference between
    a deterministic and nondeterministic Turing machine is that the former operates
    like a conventional computer, performing each instruction in sequence, forming
    a computational path; a nondeterministic Turing machine can "branch off" where
    each branch can execute a different statement in parallel, forming a computational
    tree (If any path in the tree leads to a YES, then we accept; if all paths lead
    to NO, we reject.) This is where the N in NP comes from. It turns out the two
    definitions are equivalent, but the certificate one is now more widely used. (Also,
    Karp''s 1972 paper uses the polynomial-time verifiability definition.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What is the complexity class NP-hard?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Several competing definitions. We define a problem (decision, search,
    or optimization) problem to be NP-hard if solving it in polynomial time would
    imply P = NP. Definition implicitly uses Turing reduction (extended to search
    problems).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What''s so hard about factoring an integer N in polynomial time - can''t
    I just divide all potential factors less than N (or √N) into x and see if any
    have a remainder of zero?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The algorithm is correct, but remember it takes only lg N bits to represent
    the integer N. Thus, for an algorithm to be polynomial in the input size, it must
    be polynomial in lg N, and not N.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How is it possible that checking whether an integer is composite is
    solvable in polynomial time, yet finding its factors is not known (or believed)
    to be?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** There are ways to prove a number is composite without getting your hands
    on any of its factors. A famous theorem from number theory (Fermat''s little theorem)
    implies that if you have two integers a and p such that (i) a is not a multiple
    of p and (ii) a^(p-1) != 1 (mod p), then p is not prime.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Is there a decision problem that is polynomial solvable on a quantum
    computers, but *provably* not in P?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** This is an open research problem. FACTOR is a candidate, but there is
    no proof that FACTOR is not in P, although this is widely believed to be outside
    P.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Does NP = EXPTIME?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The experts believe no, but have been unable to prove it.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Suppose someone proves P = NP. What would be the practical consequences?'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** It depends on how the question is resolved. Obviously, it would be a
    remarkable theoretical breakthrough. In practice, it might have dramatic significance
    if the proof of P = NP established a fast algorithm for an important NP-complete
    problem. If the proof results in an 2^100 N^117 algorithm for the TSP (and the
    constant and exponent could not be reduced), it would not have little practical
    impact. It could also be that someone proves P = NP by indirect means, thereby
    yielding no algorithm at all!'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Suppose someone proves P != NP. What would be the practical consequences?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** It would be a remarkable theoretical breakthrough and solidify the foundation
    of much of computational complexity.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Suppose P = NP. Does that mean deterministic TM are the same as non-deterministic
    TM?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Not quite. For example, even if P = NP, a non-deterministic TM may be
    able to solve a problem in time proportional to N^2, where the best deterministic
    one would take N^3\. If P = NP, it just means that the two types of machines solve
    the same set of decision problems in polynomial time, but it says nothing about
    the degree of the polynomial.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Where can I learn more about NP-completeness?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The authoritative reference remains Garey and Johnson *Computers and
    Intractability: A Guide to the Theory of NP-completeness*. Many of the most important
    subsequent discoveries are documented in David Johnson''s [NP-completeness column](http://www.research.att.com/~dsj/columns/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose that X is NP-complete, X poly-time reduces to Y, and Y poly-time reduces
    to X. Is Y necessarily NP-complete?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: No, since Y may not be in NP. For example if X = CIRCUIT-SAT and
    Y = CO-CIRCUIT-SAT then X and Y satisfy the conditions, but it is unknown whether
    Y is in NP. Note that the answer depends on our definition of poly-time reduction
    (to be Turing reductions and not Karp reductions).'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explain why the optimization version of the vertex cover problem is not necessarily
    a search problem.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Answer*: There does not appear to be an efficient way to certify that a purported
    solution is the best possible (even though we could use binary search on the search
    version of the problem to find the best solution).'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Web Exercises
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Subset sum.** Given N positive integers and a target value V, determine if
    there is a subset whose sum is exactly V. Divide the integers into 4 equal groups.
    Enumerate and store all of the subset sums in each group by brute force. Let A,
    B, C, and D denote the subset sums of the four groups. The goal is to find integers
    a, b, c, and d such that a + b + c + d = V, where a is in A, b is in B, c is in
    C, and d is in D. Now, use a heap to enumerate the sums a + b where a is in A
    and b is in B. Simultaneously, use another heap to enumerate the sums c + d in
    decreasing order, where c is in C and d is in D.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sum of square roots.** What is the minimum nonzero difference between two
    [sums of square roots of integers](http://cs.smith.edu/~orourke/TOPP/P33.html)?
    Given n and k, find the minimum positive value of'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where ai and bi are between 0 and n. For example r(20, 2) = √10 + √11 - √5
    - √18 and r(20, 3) = √5 + √6 + √18 - √4 - √12 - √12. Hint: enumerate all 2^(n/2)
    sums of square roots of the first n/2 integers and let that set be A, enumerate
    all 2^(n/2) sums of square roots of the last n/2 integers and let that be B. Now
    enumerate sums of a + b in sorted order, where a is in A and b is in B. Look for
    sums whose difference is very tiny.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dividing diamonds.** Given N (around 36) class D diamonds, divide them into
    two groups so that they are as close in total weight to each other as possible.
    Assume the weights are real numbers (measured in carats).'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hamilton path in DAG.** Given a directed acyclic graph G, give an O(n+m)-time
    algorithm to test whether or not it is Hamiltonian. Hint: topological sort.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following can we infer from the fact that the traveling salesperson
    problem is NP-complete, if we assume that P is not equal to NP?
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There does not exist an algorithm that solves arbitrary instances of the TSP
    problem.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There does not exist an algorithm that efficiently solves arbitrary instances
    of the TSP problem.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There exists an algorithm that efficiently solves arbitrary instances of the
    TSP problem, but no one has been able to find it.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The TSP is not in P.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All algorithms that are guaranteed to solve the TSP run in polynomial time for
    some family of input points.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All algorithms that are guaranteed to solve the TSP run in exponential time
    for all families of input points.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: (b) and (d) only.'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following can we infer from the fact that PRIMALITY is in NP but
    not known to be NP-complete, if we assume that P is not equal to NP?
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There exists an algorithm that solves arbitrary instances of PRIMALITY.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There exists an algorithm that efficiently solves arbitrary instances of PRIMALITY.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If we found an efficient algorithm for PRIMALITY, we could immediately use it
    as a black box to solve TSP.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: We can infer only (a) since all problems in P are decidable. If P
    != NP, then there are problems in NP that are neither in P or NP-complete. PRIMALITY
    could be one of them (although this was recently disproved). Part (c) cannot be
    inferred since we don''t know if PRIMALITY is NP-complete.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following are NP-complete?
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The brute force TSP algorithm.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The quicksort algorithm for sorting.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The Halting problem.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hilbert's 10th problem.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: None. NP-completeness deals with *problems* not specific algorithm
    for problems. The Halting problem and Hilbert''s 10th problem are undecidable,
    so they are not in NP (and all NP-complete problems are in NP).'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let X and Y be two decision problems. Suppose we know that X reduces to Y. Which
    of the following can we infer?
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If Y is NP-complete then so is X.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If X is NP-complete then so is Y.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If Y is NP-complete and X is in NP then X is NP-complete.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If X is NP-complete and Y is in NP then Y is NP-complete.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: X and Y can't both be NP-complete.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If X is in P, then Y is in P.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If Y is in P, then X is in P.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer:* (d) and (g) only. X reduces to Y means that if you had a black box
    to solve Y efficiently, you could use it to solve X efficiently. X is no harder
    than Y.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Show that CIRCUIT-SAT reduces to CIRCUIT-DIFF. *Hint*: create a circuit with
    N inputs that always outputs 0.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Show that CIRCUIT-DIFF reduces to CIRCUIT-SAT.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Show that DETERMINANT is in NP: given an N-by-N integer matrix A, is det(A)
    = 0?'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution:* certificate is a nonzero vector x such that Ax = 0.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Show that FULL-RANK is in NP: given an N-by-N integer matrix A, is det(A) ≠
    0?'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution:* certificate is an N-by-N inverse matrix B such that AB = I.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Search problems vs. decision problems.** We can formulate a search problem
    using a corresponding decision problem. For example, the problem of finding the
    prime factorization of an integer N can be formulate using the decision problem:
    given two integers N and and L, does N have a nontrivial factor strictly less
    than L. The search problem is solvable in polynomial time if and only if the corresponding
    decision problem is. To see why, we can efficiently find the smallest factor p
    of N by using different values of L along with binary search. Once we have the
    factor p, we can repeat the process on N/p.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually we can show that the search problem and the decision problem are equivalent
    up to polynomial factors in running time. Papadimitriou (Example 10.8) gives an
    interesting counterexample to the rule. Given N positive integers such that their
    sum is less than 2^N - 1, find two subsets whose sum is equal. For example, the
    10 numbers below sum to 1014 < 1023.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 23 47 59 88 91 100 111 133 157 205
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since there are more subsets of N integers (2^N) than numbers between 1 and
    1014, there must be two different subsets with the same sum. But nobody know a
    polynomial time algorithm for *finding* such a subset. On the other hand, the
    natural decision problem is trivial solvable in constant time: are there two subsets
    of numbers that sum to the same value?'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pratt''s primality certificate.** Show that PRIMES is in NP. Use Lehmer''s
    theorem (Fermat''s Little Theorem Converse) which asserts that an integer p >
    1 is prime if and only if there exists an integer x such that x^(N-1) = 1 (mod
    p) and x^((p-1)/d) ≠ 1 (mod p) for all prime divisors d of p-1. For example, if
    N = 7919, then the prime factorization of p-1 = 7918 = 2 × 37 × 107. Now x = 7
    satisfies 7^(7918) = 1 (mod 7919), but 7^(7918/2) ≠ 1 (mod 7919), 7^(7918/37)
    ≠ 1 (mod 7919), 7^(7918/107) ≠ 1 (mod 7919). This proves that 7919 is prime (assuming
    that you recursively certify that 2, 37, and 107 are prime).'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pell''s equation.** Find all positive integer solutions to Pell''s equation:
    x^2 - 92y^2 = 1. *Solution*: (1151, 120), (2649601, 276240), etc. There are infinitely
    many solutions, but each successive one is about 2300 times the previous one.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pell''s equation.** In 1657, Pierre Fermat challenged his colleagues with
    the following problem: given a positive integer c, find a positive integer y such
    that cy² is a perfect square. Fermat used c = 109\. It turns out the smallest
    solution is (x, y) = (158,070,671,986,249, 15,140,424,455,100). Write a program
    [Pell.java](Pell.java.html) that reads in an integer c and finds the smallest
    solution to Pell''s equation: x² - c y² = 1. Try c = 61. The smallest solution
    is (1,766,319,049, 226,153,980). For c = 313, the smallest solution is ( 3,218,812,082,913,484,91,819,380,158,564,160).
    The problem is provably unsolvable in a polynomial number of steps (as a function
    of the number of bits in the input c) because the output may require exponentially
    many bits!'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3-COLOR reduced to 4-COLOR.** Show that 3-COLOR polynomial reduces to 4-COLOR.
    *Hint*: given an instance G of 3-COLOR, create an instance G'' of 4-COLOR by adding
    a special vertex x to G and connecting it to all of the vertices in G.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3-SAT is self-reducible.** Show that 3-SAT is self-reducible. That is, given
    an oracle that answers whether or not any 3-SAT formula is satisfiable, design
    an algorithm that can find a satisfying assignment to a 3-SAT formula (assuming
    it is satisfiable). Your algorithm should run in polynomial time plus a polynomial
    number of calls to the oracle.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3-COLOR is self-reducible.** Show that 3-COLOR is self-reducible. That is,
    given an oracle that answers whether or not any graph G is 3-colorable, design
    an algorithm that can 3-color a graph (assuming it is 3-colorable). Your algorithm
    should run in polynomial time plus a polynomial number of calls to the oracle.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
