- en: Lecture 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/python/notes/1/](https://cs50.harvard.edu/python/notes/1/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Conditionals](#conditionals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[if Statements](#if-statements)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Control Flow, elif, and else](#control-flow-elif-and-else)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[or](#or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[and](#and)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modulo](#modulo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating Our Own Parity Function](#creating-our-own-parity-function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pythonic](#pythonic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`match`](#match)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditionals allow you, the programmer, to allow your program to make decisions:
    As if your program has the choice between taking the left-hand road or the right-hand
    road based upon certain conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionals allow your program to make decisions, choosing one path over another
    depending on specified conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built within Python are a set of “operators” that are used to ask mathematical
    questions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` and `<` symbols are probably quite familiar to you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` denotes “greater than or equal to.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` denotes “less than or equal to.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`==` denotes “equals.” Note the double equal sign: a single equal sign assigns
    a value, whereas two equal signs compare values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` denotes “not equal to.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements compare a left-hand term to a right-hand term.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your terminal window, type `code compare.py`. This will create a brand new
    file called “compare.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, begin with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how your program takes the input of the user for both x and y, casting
    them as integers and saving them into their respective x and y variables. Then,
    the `if` statement compares x and y. If the condition of `x < y` is met, the `print`
    statement is executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`if` statements use `bool` (Boolean) values (`True` or `False`) to decide whether
    or not to execute code. If the comparison `x > y` is `True`, the interpreter runs
    the indented block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control Flow, elif, and else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further revise your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how you are providing a series of `if` statements. First, the first `if`
    statement is evaluated. Then, the second `if` statement runs its evaluation. Finally,
    the last `if` statement runs its evaluation. This flow of decisions is called
    “control flow.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our code can be represented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This program can be improved by not asking three consecutive questions. After
    all, not all three questions can have an outcome of `true`! Revise your program
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the use of `elif` allows the program to make fewer decisions. First,
    the `if` statement is evaluated. If this statement is found to be true, all the
    `elif` statements will not be run at all. However, if the `if` statement is evaluated
    and found to be false, the first `elif` will be evaluated. If this is true, it
    will not run the final evaluation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our code can be represented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While your computer may not notice a difference speed-wise between our first
    program and this revised program, consider how an online server running billions
    or trillions of these types of calculations each day could definitely be impacted
    by such a small coding decision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one final improvement we can make to our program. Notice how logically
    `elif x == y` is not a necessary evaluation to run. After all, if logically x
    is not less than y AND x is not greater than y, x MUST equal y. Therefore, we
    don’t have to run `elif x == y`. We can create a “catch-all,” default outcome
    using an `else` statement. We can revise as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the relative complexity of this program has decreased through our
    revision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our code can be represented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`or` allows your program to decide between one or more alternatives. For example,
    we could further edit our program as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the result of our program is the same, but the complexity is decreased.
    The efficiency of our code is increased.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, our code is pretty great. However, could the design be further
    improved? We could further edit our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we removed the `or` entirely and simply asked, “Is x not equal to
    y?” We ask one and only one question. Very efficient!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the purpose of illustration, we could also change our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `==` operator evaluates if what is on the left and right are
    equal to one another. The use of double equal signs is very important. If you
    use only one equal sign, an error will likely be thrown by the interpreter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our code can be illustrated as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to `or`, `and` can be used within conditional statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute in the terminal window `code grade.py`. Start your new program as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that by executing `python grade.py`, you will be able to input a score
    and get a grade. However, notice how there is potential for bugs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Typically, we do not want to ever trust our users to input the correct information.
    We could improve our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how Python allows you to chain together the operators and conditions
    in a way quite uncommon to other programming languages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Still, we can further improve our program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the program is improved by asking fewer questions. This makes our
    program easier to read and far more maintainable in the future.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation on [control flow](https://docs.python.org/3/tutorial/controlflow.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modulo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematics, parity refers to whether a number is either even or odd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modulo `%` operator in programming allows one to see if two numbers divide
    evenly or divide and have a remainder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, 4 % 2 would result in zero, because it evenly divides. However,
    3 % 2 does not divide evenly and would result in a number other than zero!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the terminal window, create a new program by typing `code parity.py`. In
    the text editor window, type your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how our users can type in any number 1 or greater to see if it is even
    or odd.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating Our Own Parity Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in Lecture 0, you will find it useful to create a function of your
    own!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create our own function to check whether a number is even or odd. Adjust
    your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that our `if` statement `is_even(x)` works even though there is no operator
    there. This is because our function returns a `bool` (Boolean), `True` or `False`,
    back to the main function. The `if` statement simply evaluates whether or not
    `is_even` of `x` is true or false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pythonic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the programming world, there are types of programming that are called “Pythonic”
    in nature. That is, there are ways to program that are sometimes only seen in
    Python programming. Consider the following revision to our program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this return statement in our code is almost like a sentence in English.
    This is a unique way of coding only seen in Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can further revise our code and make it more and more readable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the program will evaluate what is happening within the `n % 2 ==
    0` as either `True` or `False` and simply return that to the main function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`match`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to `if`, `elif`, and `else` statements, `match` statements can be used
    to conditionally run code that matches certain values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the first three conditional statements print the same response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can improve this code slightly with the use of the `or` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the number of `elif` statements has decreased, improving the readability
    of our code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, we can use `match` statements to map names to houses. Consider
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the use of the `_` symbol in the last case. This will match with any
    input, resulting in similar behavior as an `else` statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A match statement compares the value following the `match` keyword with each
    of the values following the `case` keywords. In the event a match is found, the
    respective indented code section is executed, and the program stops the matching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can improve the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice, the use of the single vertical bar `|`. Much like the `or` keyword,
    this allows us to check for multiple values in the same `case` statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have the power within Python to use conditional statements to ask questions
    and have your program take action accordingly. In this lecture, we discussed…
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` Statements;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow, `elif`, and `else`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modulo;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own function;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pythonic coding;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and `match`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
