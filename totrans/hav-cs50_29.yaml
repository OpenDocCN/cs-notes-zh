- en: Lecture 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1讲
- en: 原文：[https://cs50.harvard.edu/python/notes/1/](https://cs50.harvard.edu/python/notes/1/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/python/notes/1/](https://cs50.harvard.edu/python/notes/1/)
- en: '[Conditionals](#conditionals)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[条件语句](#conditionals)'
- en: '[if Statements](#if-statements)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[if 语句](#if-statements)'
- en: '[Control Flow, elif, and else](#control-flow-elif-and-else)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[控制流、elif 和 else](#control-flow-elif-and-else)'
- en: '[or](#or)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[或](#or)'
- en: '[and](#and)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[且](#and)'
- en: '[Modulo](#modulo)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[取模](#modulo)'
- en: '[Creating Our Own Parity Function](#creating-our-own-parity-function)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建我们自己的奇偶函数](#creating-our-own-parity-function)'
- en: '[Pythonic](#pythonic)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pythonic](#pythonic)'
- en: '[`match`](#match)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[match](#match)'
- en: '[Summing Up](#summing-up)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Conditionals
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals allow you, the programmer, to allow your program to make decisions:
    As if your program has the choice between taking the left-hand road or the right-hand
    road based upon certain conditions.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句允许你，作为程序员，让你的程序做出决定：就像你的程序根据某些条件在左边的路或右边的路之间做出选择。
- en: Conditionals allow your program to make decisions, choosing one path over another
    depending on specified conditions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句允许你的程序做出决定，根据指定的条件选择一条路径而不是另一条路径。
- en: Built within Python are a set of “operators” that are used to ask mathematical
    questions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 内置了一套“运算符”，用于提出数学问题。
- en: '`>` and `<` symbols are probably quite familiar to you.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 和 `<` 符号你可能很熟悉。'
- en: '`>=` denotes “greater than or equal to.”'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 表示“大于或等于”。'
- en: '`<=` denotes “less than or equal to.”'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 表示“小于或等于”。'
- en: '`==` denotes “equals.” Note the double equal sign: a single equal sign assigns
    a value, whereas two equal signs compare values.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 表示“等于”。注意双等号：单个等号用于赋值，而两个等号用于比较值。'
- en: '`!=` denotes “not equal to.”'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 表示“不等于”。'
- en: Conditional statements compare a left-hand term to a right-hand term.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句比较左边的项与右边的项。
- en: if Statements
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: In your terminal window, type `code compare.py`. This will create a brand new
    file called “compare.”
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，键入 `code compare.py`。这将创建一个名为“compare”的新文件。
- en: 'In the text editor window, begin with the following:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本编辑器窗口中，开始如下：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how your program takes the input of the user for both x and y, casting
    them as integers and saving them into their respective x and y variables. Then,
    the `if` statement compares x and y. If the condition of `x < y` is met, the `print`
    statement is executed.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意你的程序如何接受用户对 x 和 y 的输入，将它们作为整数转换并保存到各自的 x 和 y 变量中。然后，`if` 语句比较 x 和 y。如果满足 `x
    < y` 的条件，则执行 `print` 语句。
- en: '`if` statements use `bool` (Boolean) values (`True` or `False`) to decide whether
    or not to execute code. If the comparison `x > y` is `True`, the interpreter runs
    the indented block.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句使用 `bool`（布尔）值（`True` 或 `False`）来决定是否执行代码。如果比较 `x > y` 的结果是 `True`，解释器将运行缩进的代码块。'
- en: Control Flow, elif, and else
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流、elif 和 else
- en: 'Further revise your code as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步修改你的代码如下：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how you are providing a series of `if` statements. First, the first `if`
    statement is evaluated. Then, the second `if` statement runs its evaluation. Finally,
    the last `if` statement runs its evaluation. This flow of decisions is called
    “control flow.”
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意你提供了一系列 `if` 语句。首先，评估第一个 `if` 语句。然后，执行第二个 `if` 语句的评估。最后，执行最后一个 `if` 语句的评估。这种决策流程称为“控制流”。
- en: 'Our code can be represented as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码可以表示如下：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This program can be improved by not asking three consecutive questions. After
    all, not all three questions can have an outcome of `true`! Revise your program
    as follows:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个程序可以通过不连续问三个问题来改进。毕竟，不是所有三个问题都能得到 `true` 的结果！按照以下方式修改你的程序：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how the use of `elif` allows the program to make fewer decisions. First,
    the `if` statement is evaluated. If this statement is found to be true, all the
    `elif` statements will not be run at all. However, if the `if` statement is evaluated
    and found to be false, the first `elif` will be evaluated. If this is true, it
    will not run the final evaluation.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `elif` 的使用如何使程序做出更少的决策。首先，评估 `if` 语句。如果这个语句被评估为真，则不会运行所有的 `elif` 语句。然而，如果
    `if` 语句被评估并发现为假，则第一个 `elif` 将被评估。如果是真的，它将不会运行最终的评估。
- en: 'Our code can be represented as follows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码可以表示如下：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While your computer may not notice a difference speed-wise between our first
    program and this revised program, consider how an online server running billions
    or trillions of these types of calculations each day could definitely be impacted
    by such a small coding decision.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然你的电脑可能在速度上没有注意到我们的第一个程序和这个修订程序之间的差异，但考虑一下，一个每天运行数十亿或数万亿此类计算的在线服务器，这样的小代码决策肯定会有影响。
- en: 'There is one final improvement we can make to our program. Notice how logically
    `elif x == y` is not a necessary evaluation to run. After all, if logically x
    is not less than y AND x is not greater than y, x MUST equal y. Therefore, we
    don’t have to run `elif x == y`. We can create a “catch-all,” default outcome
    using an `else` statement. We can revise as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对我们的程序进行最后一次改进。注意 `elif x == y` 在逻辑上不是必须的评估。毕竟，如果逻辑上 x 不小于 y 且 x 不大于 y，那么
    x 一定等于 y。因此，我们不需要运行 `elif x == y`。我们可以使用 `else` 语句创建一个“通配符”，默认结果。我们可以这样修改：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how the relative complexity of this program has decreased through our
    revision.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到通过我们的修订，这个程序的相对复杂性已经降低。
- en: 'Our code can be represented as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码可以表示如下：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: or
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 或
- en: '`or` allows your program to decide between one or more alternatives. For example,
    we could further edit our program as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or` 允许程序在一种或多种选择之间做出决定。例如，我们可以进一步编辑我们的程序如下：'
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the result of our program is the same, but the complexity is decreased.
    The efficiency of our code is increased.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们的程序结果相同，但复杂性降低。代码的效率提高了。
- en: 'At this point, our code is pretty great. However, could the design be further
    improved? We could further edit our code as follows:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码相当不错。然而，设计是否可以进一步改进？我们可以进一步编辑我们的代码如下：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how we removed the `or` entirely and simply asked, “Is x not equal to
    y?” We ask one and only one question. Very efficient!
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们完全移除了 `or`，只是简单地问，“x 是否不等于 y？”我们只问一个问题。非常高效！
- en: 'For the purpose of illustration, we could also change our code as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了说明，我们也可以将代码修改如下：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the `==` operator evaluates if what is on the left and right are
    equal to one another. The use of double equal signs is very important. If you
    use only one equal sign, an error will likely be thrown by the interpreter.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `==` 操作符用于判断左边的值和右边的值是否相等。使用双等号非常重要。如果你只使用一个等号，解释器可能会抛出一个错误。
- en: 'Our code can be illustrated as follows:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将代码表示如下：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 和
- en: Similar to `or`, `and` can be used within conditional statements.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `or` 类似，`and` 也可以在条件语句中使用。
- en: 'Execute in the terminal window `code grade.py`. Start your new program as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中执行 `code grade.py`。启动你的新程序如下：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that by executing `python grade.py`, you will be able to input a score
    and get a grade. However, notice how there is potential for bugs.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到通过执行 `python grade.py`，你将能够输入一个分数并得到一个等级。然而，请注意这里存在潜在的错误。
- en: 'Typically, we do not want to ever trust our users to input the correct information.
    We could improve our code as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们不想让用户输入正确信息。我们可以这样改进我们的代码：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how Python allows you to chain together the operators and conditions
    in a way quite uncommon to other programming languages.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 Python 允许你以其他编程语言中相当不常见的方式链接着操作符和条件。
- en: 'Still, we can further improve our program:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，我们还可以进一步改进我们的程序：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the program is improved by asking fewer questions. This makes our
    program easier to read and far more maintainable in the future.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到通过减少问题数量，程序得到了改进。这使得我们的程序更容易阅读，并且在未来的维护中更加高效。
- en: You can learn more in Python’s documentation on [control flow](https://docs.python.org/3/tutorial/controlflow.html).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的文档中了解更多关于[控制流](https://docs.python.org/3/tutorial/controlflow.html)的信息。
- en: Modulo
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取模
- en: In mathematics, parity refers to whether a number is either even or odd.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数学中，奇偶性指的是一个数是偶数还是奇数。
- en: The modulo `%` operator in programming allows one to see if two numbers divide
    evenly or divide and have a remainder.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程中的取模 `%` 操作符允许你查看两个数是否能够整除，或者除后是否有余数。
- en: For example, 4 % 2 would result in zero, because it evenly divides. However,
    3 % 2 does not divide evenly and would result in a number other than zero!
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，4 % 2 的结果将是零，因为它可以整除。然而，3 % 2 不能整除，结果将是一个非零的数字！
- en: 'In the terminal window, create a new program by typing `code parity.py`. In
    the text editor window, type your code as follows:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中，通过输入 `code parity.py` 创建一个新的程序。在文本编辑器窗口中，输入以下代码：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how our users can type in any number 1 or greater to see if it is even
    or odd.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们的用户可以输入任何大于等于1的数字来查看它是否为偶数或奇数。
- en: Creating Our Own Parity Function
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的偶奇函数
- en: As discussed in Lecture 0, you will find it useful to create a function of your
    own!
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如在讲座0中讨论的，你会发现创建自己的函数很有用！
- en: 'We can create our own function to check whether a number is even or odd. Adjust
    your code as follows:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建自己的函数来检查一个数字是否为偶数或奇数。按照以下方式调整你的代码：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that our `if` statement `is_even(x)` works even though there is no operator
    there. This is because our function returns a `bool` (Boolean), `True` or `False`,
    back to the main function. The `if` statement simply evaluates whether or not
    `is_even` of `x` is true or false.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们的`if`语句`is_even(x)`即使没有操作符也能正常工作。这是因为我们的函数返回一个`bool`（布尔值），`True`或`False`，并将其返回给主函数。`if`语句只是简单地评估`x`的`is_even`是否为真或假。
- en: Pythonic
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pythonic
- en: 'In the programming world, there are types of programming that are called “Pythonic”
    in nature. That is, there are ways to program that are sometimes only seen in
    Python programming. Consider the following revision to our program:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编程世界中，有一些编程类型被称为“Pythonic”的编程。也就是说，有一些编程方式只在Python编程中看到。考虑以下程序的修订版：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that this return statement in our code is almost like a sentence in English.
    This is a unique way of coding only seen in Python.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们代码中的这个返回语句几乎就像一个英文句子。这是仅在Python中才能看到的独特编码方式。
- en: 'We can further revise our code and make it more and more readable:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以进一步修改代码，使其更加易读：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the program will evaluate what is happening within the `n % 2 ==
    0` as either `True` or `False` and simply return that to the main function.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意程序将评估`n % 2 == 0`的结果，将其视为`True`或`False`，并将其简单地返回给主函数。
- en: '`match`'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`match`'
- en: Similar to `if`, `elif`, and `else` statements, `match` statements can be used
    to conditionally run code that matches certain values.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`if`、`elif`和`else`语句类似，`match`语句可以用来有条件地运行与某些值匹配的代码。
- en: 'Consider the following program:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下程序：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the first three conditional statements print the same response.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意前三个条件语句打印了相同的响应。
- en: 'We can improve this code slightly with the use of the `or` keyword:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`or`关键字稍微改进这段代码：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the number of `elif` statements has decreased, improving the readability
    of our code.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`elif`语句的数量减少了，这提高了代码的可读性。
- en: 'Alternatively, we can use `match` statements to map names to houses. Consider
    the following code:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`match`语句将名称映射到房屋。考虑以下代码：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice the use of the `_` symbol in the last case. This will match with any
    input, resulting in similar behavior as an `else` statement.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到最后一个情况中使用了`_`符号。这将与任何输入匹配，产生类似于`else`语句的行为。
- en: A match statement compares the value following the `match` keyword with each
    of the values following the `case` keywords. In the event a match is found, the
    respective indented code section is executed, and the program stops the matching.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配语句将`match`关键字后面的值与`case`关键字后面的每个值进行比较。如果在事件中找到匹配项，则执行相应的缩进代码部分，程序停止匹配。
- en: 'We can improve the code:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以改进代码：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice, the use of the single vertical bar `|`. Much like the `or` keyword,
    this allows us to check for multiple values in the same `case` statement.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，使用了单个竖线`|`。与`or`关键字类似，这允许我们在同一个`case`语句中检查多个值。
- en: Summing Up
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You now have the power within Python to use conditional statements to ask questions
    and have your program take action accordingly. In this lecture, we discussed…
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在Python中使用条件语句来提问，并让程序相应地采取行动。在本讲座中，我们讨论了…
- en: Conditionals;
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句；
- en: '`if` Statements;'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句；'
- en: Control flow, `elif`, and `else`;
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流程，`elif`和`else`；
- en: '`or`;'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`；'
- en: '`and`;'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`；'
- en: Modulo;
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取模；
- en: Creating your own function;
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的函数；
- en: Pythonic coding;
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonic编码；
- en: and `match`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和`match`。
