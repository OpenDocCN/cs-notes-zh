- en: 2.5   Sorting Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5   排序应用
- en: 原文：[https://algs4.cs.princeton.edu/25applications](https://algs4.cs.princeton.edu/25applications)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/25applications](https://algs4.cs.princeton.edu/25applications)
- en: Sorting algorithms and priority queues are widely used in a broad variety of
    applications. Our purpose in this section is to briefly survey some of these applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法和优先队列在各种应用中被广泛使用。本节的目的是简要概述其中一些应用。
- en: Sorting various types of data.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对各种类型的数据进行排序。
- en: Our implementations sort arrays of `Comparable` objects. This Java convention
    allows us to use Java's *callback* mechanism to sort arrays of objects of any
    type that implements the `Comparable` interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现对`Comparable`对象的数组进行排序。这种Java约定允许我们使用Java的*回调*机制对实现了`Comparable`接口的任何类型的对象数组进行排序。
- en: '*Transaction example.* Program [Transaction.java](Transaction.java.html) implements
    the `Comparable` interface for a transaction data type based on when the transaction
    occurred.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事务示例。* 程序[Transaction.java](Transaction.java.html)基于事务发生时间实现了事务数据类型的`Comparable`接口。'
- en: '*Pointer sorting.* The approach we are using is known in the classical literature
    as *pointer sorting*, so called because we process references to keys and do not
    move the data itself.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指针排序。* 我们正在使用的方法在经典文献中被称为*指针排序*，因为我们处理的是对键的引用，而不是移动数据本身。'
- en: '*Keys are immutable.* It stands to reason that an array might not remain sorted
    if a client is allowed to change the values of keys after the sort. In Java, it
    is wise to ensure that key values do not change by using immutable keys.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*键是不可变的。* 如果允许客户在排序后更改键的值，那么数组可能不会保持排序。在Java中，通过使用不可变键来确保键值不变是明智的。'
- en: '*Exchanges are inexpensive.* Another advantage of using references is that
    we avoid the cost of moving full items. The reference approach makes the cost
    of an exchange roughly equal to the cost of a compare for general situations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交换成本低廉。* 使用引用的另一个优点是我们避免了移动完整项的成本。引用方法使得交换的成本在一般情况下大致等于比较的成本。'
- en: '*Alternate orderings.* There are many applications where we want to use two
    different orders for the objects that we are sorting, depending upon the situation.
    The Java `Comparator` interface has a single public method `compare()` that compares
    two objects. If we have a data type that implements this interface, we can pass
    a `Comparator` to `sort()` (which passes it to `less()`) as in [Insertion.java](Insertion.java.html).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*备用排序。* 有许多应用程序，我们希望根据情况使用两种不同的顺序对我们正在排序的对象。Java的`Comparator`接口有一个名为`compare()`的公共方法，用于比较两个对象。如果我们有一个实现了此接口的数据类型，我们可以将`Comparator`传递给`sort()`（它传递给`less()`）如[Insertion.java](Insertion.java.html)中所示。'
- en: '*Items with multiple keys.* In typical applications, items have multiple instance
    variables that might need to serve as sort keys. In our transaction example, one
    client may need to sort the transaction list by account number; another client
    might need to sort the list by place; and other clients might need to use other
    fields as sort keys. We can define multiple comparators, as in [Transaction.java](Transaction.java.html).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有多个键的项。* 在典型应用中，项具有多个可能需要用作排序键的实例变量。在我们的事务示例中，一个客户可能需要按帐号号码对事务列表进行排序；另一个客户可能需要按地点对列表进行排序；其他客户可能需要使用其他字段作为排序键。我们可以定义多个比较器，如[Transaction.java](Transaction.java.html)中所示。'
- en: '*Priority queues with comparators.* The same flexibility to use comparators
    is also useful for priority queues. [MaxPQ.java](MaxPQ.java.html) and [MinPQ.java](MinPQ.java.html)
    include a constructor that takes a `Comparator` as an argument.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有比较器的优先队列。* 使用比较器的灵活性对于优先队列也很有用。[MaxPQ.java](MaxPQ.java.html)和[MinPQ.java](MinPQ.java.html)包括一个以`Comparator`作为参数的构造函数。'
- en: '*Stability.* A sorting method is *stable* if it preserves the relative order
    of equal keys in the array. For example, suppose, in our internet commerce application,
    that we enter transactions into an array as they arrive, so they are in order
    of the time field in the array. Now suppose that the application requires that
    the transactions be separated out by location for further processing. One easy
    way to do so is to sort the array by location. If the sort is unstable, the transactions
    for each city may not necessarily be in order by time after the sort. Some of
    the sorting methods that we have considered in this chapter are stable (insertion
    sort and mergesort); many are not (selection sort, shellsort, quicksort, and heapsort).![Stability
    when sorting on a second key](../Images/c34c1ba7c34b51f3e69197648f9bf7dc.png)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*稳定性。* 如果排序方法在数组中保留相等键的相对顺序，则称其为*稳定*。例如，在我们的互联网商务应用中，我们按照事务到达的顺序将其输入到数组中，因此它们按照数组中的时间字段顺序排列。现在假设应用程序要求将事务按位置分开以进行进一步处理。一个简单的方法是按位置对数组进行排序。如果排序是不稳定的，那么每个城市的事务在排序后可能不一定按时间顺序排列。我们在本章中考虑的一些排序方法是稳定的（插入排序和归并排序）；许多排序方法则不是（选择排序、希尔排序、快速排序和堆排序）。![在第二个关键字上排序时的稳定性](../Images/c34c1ba7c34b51f3e69197648f9bf7dc.png)'
- en: Which sorting algorithm should I use?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该使用哪种排序算法？
- en: Knowing which algorithm is best possible depends heavily on details of the application
    and implementation, but we have studied some general-purpose methods that can
    be nearly as effective as the best possible for a wide variety of applications.
    The following table is a general guide that summarizes the important characteristics
    of the sort algorithms that we have studied in this chapter.![Performance characteristics
    of sorting algorithms](../Images/2e31ac7ee37cf8e5142eaa8216d8bedb.png)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确定哪种算法是最佳的取决于应用和实现的细节，但我们已经研究了一些通用方法，它们在各种应用中几乎与最佳方法一样有效。下表是一个概括我们在本章中研究的排序算法的重要特征的一般指南。![排序算法的性能特征](../Images/2e31ac7ee37cf8e5142eaa8216d8bedb.png)
- en: '**Property.** Quicksort is the fastest general-purpose sort.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**性质。** 快速排序是最快的通用排序方法。'
- en: In most practical situations, quicksort is the method of choice. If stability
    is important and space is available, mergesort might be best. In some performance-critical
    applications, the focus may be on just sorting numbers, so it is reasonable to
    avoid the costs of using references and sort primitive types instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际情况下，快速排序是首选方法。如果稳定性很重要且有空间可用，则归并排序可能是最佳选择。在一些性能关键的应用中，重点可能仅仅是对数字进行排序，因此可以避免使用引用的成本，而是对原始类型进行排序。
- en: '*Sorting primitive types.* We can develop more efficient versions of our sort
    codes for sorting primitive types by replacing `Comparable` with the primitive
    type name, and replacing calls to `less()` with code like `a[i] < a[j]`. However,
    some care is needed with floating-point types to deal with -0.0 and NaN.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序原始类型。* 我们可以通过将`Comparable`替换为原始类型名称，并将对`less()`的调用替换为类似`a[i] < a[j]`的代码，为原始类型开发更高效的排序代码。但是，对于浮点类型，需要注意处理-0.0和NaN。'
- en: '*Java system sort.* Java''s primary system sort method `Arrays.sort()` in the
    `java.util` library represents a collection of overloaded methods:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java系统排序。* Java的主要系统排序方法`Arrays.sort()`在`java.util`库中表示一组重载方法：'
- en: A different method for each primitive type.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种原始类型的不同方法。
- en: A method for data types that implement `Comparable`.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于实现`Comparable`的数据类型的方法。
- en: A method that uses a `Comparator`.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种使用`Comparator`的方法。
- en: Java's systems programmers have chosen to use quicksort (with 3-way partitioning)
    to implement the primitive-type methods, and mergesort for reference-type methods.
    The primary practical implications of these choices are to trade speed and memory
    usage (for primitive types) for stability and guaranteed performance (for reference
    types).
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java的系统程序员选择使用快速排序（带有3路分区）来实现原始类型方法，并使用归并排序来实现引用类型方法。这些选择的主要实际影响是在速度和内存使用（对于原始类型）与稳定性和性能保证（对于引用类型）之间进行权衡。
- en: Reductions.
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩减。
- en: The idea that we can use sorting algorithms to solve other problems is an example
    of a basic technique in algorithm design known as *reduction*. A reduction is
    a situation where an algorithm developed for one problem is used to solve another.
    We begin with a few elementary examples for sorting.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用排序算法来解决其他问题的想法是算法设计中一种基本技术的例子，称为*缩减*。缩减是一种情况，其中为一个问题开发的算法用于解决另一个问题。我们从一些排序的基本示例开始。
- en: '*Duplicates.* Are there any duplicate keys in an array of `Comparable` objects?
    How many distinct keys are there in an array? Which value appears most frequently?
    With sorting, you can answer these questions in linearithmic time: first sort
    the array, then make a pass through the sorted array, taking note of duplicate
    values that appear consecutively in the ordered array.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重复项。* 在一个包含`Comparable`对象的数组中是否有重复的键？数组中有多少个不同的键？哪个值出现最频繁？通过排序，您可以在线性对数时间内回答这些问题：首先对数组进行排序，然后通过排序后的数组进行一次遍历，注意在有序数组中连续出现的重复值。'
- en: '*Rankings.* A *permutation* (or *ranking*) is an array of N integers where
    each of the integers between 0 and N-1 appears exactly once. The *Kendall tau
    distance* between two rankings is the number of pairs that are in different order
    in the two rankings. For example the Kendall tau distance between `0 3 1 6 2 5
    4` and `1 0 3 6 4 2 5` is four because the pairs 0-1, 3-1, 2-4, 5-4 are in different
    order in the two rankings, but all other pairs are in the same order.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排名。* 一个*排列*（或*排名*）是一个包含N个整数的数组，其中0到N-1之间的每个整数恰好出现一次。两个排名之间的*Kendall tau距离*是在两个排名中顺序不同的对数。例如，`0
    3 1 6 2 5 4`和`1 0 3 6 4 2 5`之间的Kendall tau距离是四，因为在两个排名中，对0-1、3-1、2-4、5-4的顺序不同，但所有其他对的顺序相同。'
- en: '*Priority queue reductions.* In Section 2.4, we considered two examples of
    problems that reduce to a sequence of operations on priority queues. [TopM.java](../24pq/TopM.java.html)
    finds the M items in an input stream with the highest keys. [Multiway.java](../24pq/Multiway.java.html)
    merges together M sorted input streams to make a sorted output stream. Both of
    these problems are easily addressed with a priority queue of size M.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先队列缩减。* 在第2.4节中，我们考虑了两个问题的示例，这些问题可以简化为对优先队列的一系列操作。[TopM.java](../24pq/TopM.java.html)在输入流中找到具有最高键的M个项目。[Multiway.java](../24pq/Multiway.java.html)将M个排序的输入流合并在一起，以生成一个排序的输出流。这两个问题都可以通过大小为M的优先队列轻松解决。'
- en: '*Median and order statistics.* ![Partitioning to find the median](../Images/048d561d18d8861d48c8040878a051b0.png)
    An important application related to sorting is the operation of finding the *median*
    of a set of keys (the value with the property that half the keys are no larger
    and half the keys are no smaller). This operation is a common computation in statistics
    and in various other data-processing applications. Finding the median is a special
    case of *selection*: finding the kth smallest of a set of numbers. It is easy
    to solve the problem in linearithmic time by sorting. The method `select()`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中位数和顺序统计。* ![用于找到中位数的分区](../Images/048d561d18d8861d48c8040878a051b0.png) 与排序相关的一个重要应用是找到一组键的*中位数*（具有一半键不大于它，一半键不小于它的值）。这个操作在统计学和其他各种数据处理应用中是一个常见的计算。找到中位数是*选择*的一个特殊情况：找到一组数字中第k小的数字。通过排序，可以很容易在线性对数时间内解决这个问题。方法`select()`'
- en: 'We describe an approach that solves the problem in *linear* time: Maintain
    the variables `lo` and `hi` to delimit the subarray that contains the index `k`
    of the item to be selected and use use quicksort partitioning to shrink the size
    of the subarray, as follows:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们描述了一种在*线性*时间内解决问题的方法：维护变量`lo`和`hi`来限定包含要选择的项目的索引`k`的子数组，并使用快速排序分区来缩小子数组的大小，如下所示：
- en: If `k` is equal to `j`, then we are done.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`k`等于`j`，那么我们完成了。
- en: Otherwise, if `k < j`, then we need to continue working in the left subarray
    (by changing the value of `hi` to `j-1`)
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果`k < j`，那么我们需要继续在左子数组中工作（通过将`hi`的值更改为`j-1`）
- en: Otherwise, if `k > j`, then we need to continue working in the right subarray
    (by changing `lo` to `j+1`).
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果`k > j`，那么我们需要继续在右子数组中工作（通过将`lo`更改为`j+1`）。
- en: The interval shrinks until it consists just of `k`. Upon termination `a[k]`
    contains the (k+1)st smallest entry, `a[0]` through `a[k-1]` are all small than
    (ore equal to) `a[k]`, and `a[k+1]` through the end of the array are all larger
    than (or equal to) `a[k]`.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 区间收缩，直到只剩下`k`。终止时，`a[k]`包含第(k+1)小的条目，`a[0]`到`a[k-1]`都小于（或等于）`a[k]`，而`a[k+1]`到数组末尾都大于（或等于）`a[k]`。
- en: The `select()` method in [Quick.java](../23quicksort/Quick.java.html) implements
    this approach, but it requires a cast in the client. The `select()` method in
    [QuickPedantic.java](../23quicksort/QuickPedantic.java.html) is more pedantic
    code that obviates the need for a cast.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`select()` 方法在[Quick.java](../23quicksort/Quick.java.html)中实现了这种方法，但在客户端需要进行类型转换。[QuickPedantic.java](../23quicksort/QuickPedantic.java.html)中的`select()`方法是更加严谨的代码，避免了需要进行类型转换。'
- en: A brief survey of sorting applications.
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对排序应用的简要调查。
- en: '*Commercial computing.* Government organizations, financial institutions, and
    commercial enterprises organize much of this information by sorting it. Whether
    the information is accounts to be sorted by name or number, transactions to be
    sorted by time or place, mail to be sorted by postal code or address, files to
    be sorted by name or date, or whatever, processing such data is sure to involve
    a sorting algorithm somewhere along the way.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*商业计算。* 政府机构、金融机构和商业企业通过对信息进行排序来组织大部分信息。无论信息是按名称或编号排序的账户、按时间或地点排序的交易、按邮政编码或地址排序的邮件、按名称或日期排序的文件，还是其他任何信息，处理这些数据肯定会涉及到某种排序算法。'
- en: '*Search for information.* Keeping data in sorted order makes it possible to
    efficiently search through it using the classic *binary search* algorithm.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索信息。* 将数据保持有序可以通过经典的*二分搜索*算法高效地搜索数据。'
- en: '*Operations research.* Suppose that we have N jobs to complete, where job j
    requires t[j] seconds of processing time. We need to complete all of the jobs,
    but want to maximize customer satisfaction by minimizing the average completion
    time of the jobs. The *shortest processing time first* rule, where we schedule
    jobs in increasing order of processing time, is known to accomplish this goal.
    As another example, consider the *load-balancing problem*, where we have M identical
    processors and N jobs to complete, and our goal is to schedule all of the jobs
    on the processors so that the time when the last job completes is as early as
    possible. This specific problem is NP-hard (see Chapter 6) so we do not expect
    to find a practical way to compute an optimal schedule. One method that is known
    to produce a good schedule is the *longest processing time first* rule, where
    we consider the jobs in decreasing order of processing time, assigning each job
    to the processor that becomes available first.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运筹学。* 假设我们有N个工作要完成，其中第j个工作需要t[j]秒的处理时间。我们需要完成所有工作，但希望通过最小化工作的平均完成时间来最大化客户满意度。*最短处理时间优先*规则，即按处理时间递增顺序安排工作，已知可以实现这一目标。另一个例子是*负载平衡问题*，其中我们有M个相同的处理器和N个工作要完成，我们的目标是在处理器上安排所有工作，以便最后一个工作完成的时间尽可能早。这个具体问题是NP难题（参见第6章），因此我们不指望找到一个实际的方法来计算最佳的安排。已知一种能够产生良好安排的方法是*最长处理时间优先*规则，即按处理时间递减顺序考虑工作，将每个工作分配给最先可用的处理器。'
- en: '*Event-driven simulation.* Many scientific applications involve simulation,
    where the point of the computation is to model some aspect of the real world in
    order to be able to better understand it. Doing such simulations efficiently can
    require appropriate algorithms and data structures. We consider a particle-collision
    simulation in [Section 6.1](../61event/) that illustrates this point.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件驱动模拟。* 许多科学应用涉及模拟，计算的目的是模拟现实世界的某个方面，以便更好地理解它。进行这种模拟可能需要适当的算法和数据结构。我们在[第6.1节](../61event/)中考虑了一个粒子碰撞模拟，说明了这一点。'
- en: '*Numerical computations.* Scientific computing is often concerned with accuracy
    (how close are we to the true answer?). Accuracy is extremely important when we
    are performing millions of computations with estimated values such as the floating-point
    representation of real numbers that we commonly use on computers. Some numerical
    algorithms use priority queues and sorting to control accuracy in calculations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数值计算。* 科学计算通常关注准确性（我们距离真实答案有多接近？）。当我们进行数百万次计算时，准确性非常重要，特别是在使用计算机上常见的浮点数表示实数时。一些数值算法使用优先队列和排序来控制计算中的准确性。'
- en: '*Combinatorial search.* A classic paradigm in artificial intelligence is to
    define a set of *configurations* with well-defined moves from one configuration
    to the next and a priority associated with each move. Also defined is a *start*
    configuration and a *goal* configuration (which corresponds to having solved the
    problem. The *A* algorithm* is a problem-solving process where we put the start
    configuration on the priority queue, then do the following until reaching the
    goal: remove the highest-priority configuration and add to the queue all configurations
    that can be reached from that with one move (excluding the one just removed).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合搜索。* 人工智能中的一个经典范例是定义一组*配置*，其中每个配置都有从一个配置到下一个配置的明确定义的移动和与每个移动相关联的优先级。还定义了一个*起始*配置和一个*目标*配置（对应于已解决问题）。*A*算法*是一个问题解决过程，其中我们将起始配置放在优先队列中，然后执行以下操作直到达到目标：移除优先级最高的配置，并将可以通过一次移动到达的所有配置添加到队列中（不包括刚刚移除的配置）���'
- en: '*Prim''s algorithm and Dijkstra''s algorithm* are classical algorithms that
    process graphs. Priority queues play a fundamental role in organizing graph searches,
    enabling efficient algorithms.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*普里姆算法和迪杰斯特拉算法*是处理图的经典算法。优先队列在组织图搜索中起着基础性作用，实现高效的算法。'
- en: '*Kruskal''s algorithm* is another classic algorithm for graphs whose edges
    have weights that depends upon processing the edges in order of their weight.
    Its running time is dominated by the cost of the sort.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kruskal算法*是另一��经典的图算法，其边具有权重，取决于按权重顺序处理边。其运行时间由排序的成本主导。'
- en: '*Huffman compression* is a classic data compression algorithm that depends
    upon processing a set of items with integer weights by combining the two smallest
    to produce a new one whose weight is the sum of its two constituents. Implementing
    this operation is immediate, using a priority queue.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*赫夫曼压缩*是一种经典的数据压缩算法，它依赖于通过将具有整数权重的一组项目组合起来，以产生一个新的项目，其权重是其两个组成部分的和。使用优先队列立即实现此操作。'
- en: '*String processing* algorithms are often based on sorting. For example, we
    will discuss algorithms for finding the longest common prefix among a set of strings
    and the longest repeated substring in a given string that are based on first sorting
    suffixes the strings.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串处理*算法通常基于排序。例如，我们将讨论基于首先对字符串后缀进行排序的算法，用于查找一组字符串中的最长公共前缀以及给定字符串中的最长重复子字符串。'
- en: Exercises
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Consider the following implementation of the `compareTo()` method for `String`.
    How does the third line help with efficiency?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑`String`的`compareTo()`方法的以下实现。第三行如何提高效率？
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Solution*: it avoid directly comparing individual characters if `s` and `t`
    are references to the same string.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：如果`s`和`t`是对同一字符串的引用，则避免直接比较单个字符。'
- en: Criticize the following implementation of a class intended to represent customer
    account balances. Why is `compareTo()` a flawed implementation of the `Comparable`
    interface?
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批评下面的类实现，该类旨在表示客户账户余额。为什么`compareTo()`是`Comparable`接口的一个有缺陷的实现？
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Solution*: it violates the `Comparable` contract. It is possible that `a.compareTo(b)`
    and `b.compareTo(c)` are both 0, but `a.compareTo(c)` is positive (or negative).'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：它违反了`Comparable`合同。可能`a.compareTo(b)`和`b.compareTo(c)`都为0，但`a.compareTo(c)`为正（或负）。'
- en: Explain why selection sort is not stable.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么选择排序不稳定。
- en: '*Solution.* It exchanges nonadjacent elements. On the example below, the first
    B gets swapped to the right of the second B.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 它交换非相邻元素。在下面的示例中，第一个B被交换到第二个B的右侧。'
- en: '![Selection sort is unstable](../Images/786aba3c9128994e07376ffe02032e77.png)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![选择排序不稳定](../Images/786aba3c9128994e07376ffe02032e77.png)'
- en: Write a program [Frequency.java](Frequency.java.html) that reads strings from
    standard input and prints the number of times each string occurs, in descending
    order of frequency.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Frequency.java](Frequency.java.html)，从标准输入读取字符串，并按频率降序打印每个字符串出现的次数。
- en: Creative Problems
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创造性问题
- en: '**Scheduling.** Write a program [SPT.java](SPT.java.html) that reads job names
    and processing times from standard input and prints a schedule that minimizes
    average completion time, as described in the text.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调度。** 编写一个程序[SPT.java](SPT.java.html)，从标准输入读取作业名称和处理时间，并打印一个最小化平均完成时间的调度，如文本中所述。'
- en: '**Load balancing.** Write a program [LPT.java](LPT.java.html) that takes an
    integer M as a command-line argument, reads N job names and processing times from
    standard input and prints a scheduling assignment the jobs to M processors that
    approximately minimizes the time when the last job completes, as described in
    the text.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**负载平衡。** 编写一个程序[LPT.java](LPT.java.html)，将整数M作为命令行参数，从标准输入读取N个作业名称和处理时间，并打印一个调度分配作业给M个处理器，以近似最小化最后一个作业完成的时间，如文本中所述。'
- en: '*Remark.* The resulting solution is guaranteed to be within 33% of the best
    possible (actually 4/3 - 1/(3N)).'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*备注。* 结果解决方案保证在最佳解决方案的33%之内（实际上为4/3 - 1/(3N)）。'
- en: '**Sort by reverse domain.** Write a data type [Domain.java](Domain.java.html)
    that represents domain names, including an appropriate `compareTo()` method where
    the natural order is in order of the *reverse* domain name. For example, the reverse
    domain of `cs.princeton.edu` is `edu.princeton.cs`. This is useful for web log
    analysis. Write a client that reads domain names from standard input and prints
    the reverse domains in sorted order.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按反向域排序。** 编写一个数据类型[Domain.java](Domain.java.html)，表示域名，包括一个适当的`compareTo()`方法，其中自然顺序是*反向*域名顺序。例如，`cs.princeton.edu`的反向域是`edu.princeton.cs`。这对于Web日志分析很有用。编写一个客户端，从标准输入读取域名，并按排序顺序打印反向域。'
- en: '**Spam campaign.** To initiate an illegal spam campaign, you have a list of
    email addresses from various domains (the part of the email address that follows
    the @ symbol). To better forge the return addresses, you want to send the email
    from another user at the same domain. For example, you might want to forge an
    email from wayne@princeton.edu to rs@princeton.edu. How would you process the
    email list to make this an efficient task?'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垃圾邮件活动。** 要发起非法的垃圾邮件活动，您有一个来自各种域的电子邮件地址列表（即在@符号后面的电子邮件地址部分）。为了更好地伪造寄件人地址，您希望从同一域的另一个用户发送电子邮件。例如，您可能想要伪造从wayne@princeton.edu发送到rs@princeton.edu的电子邮件。您将如何处理电子邮件列表以使此成为一个高效的任务？'
- en: '*Solution.* First sort by reverse domain.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 首先按照反向域排序。'
- en: '**Unbiased election.** In order to thwart bias against candidates whose names
    appear toward the end of the alphabet, California sorted the candidates appearing
    on its 2003 gubernatorial ballot by using the following order:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**公正选举。** 为了防止对字母表末尾出现的候选人产生偏见，加利福尼亚州通过以下顺序对其2003年州长选票上出现的候选人进行排序：'
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a data type [California.java](California.java.html) where this is the
    natural order. Write a client that sorts strings according to this ordering. Assume
    that each string is comprised solely of uppercase letters.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个数据类型[California.java](California.java.html)，其中这是自然顺序。编写一个客户端，根据此顺序对字符串进行排序。假设每个字符串仅由大写字母组成。
- en: '**Kendall tau distance.** Write a program [KendallTau.java](KendallTau.java.html)
    that computes the Kendall tau distance between two permutations in linearithmic
    time.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**肯德尔距离。** 编写一个程序[KendallTau.java](KendallTau.java.html)，以线性对数时间计算两个排列之间的肯德尔距离。'
- en: '**Stable priority queue.** Develop a *stable* priority-queue implementation
    [StableMinPQ.java](StableMinPQ.java.html) (which returns duplicate keys in the
    same order in which they were inserted).'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稳定的优先队列。**开发一个*稳定的*优先队列实现[StableMinPQ.java](StableMinPQ.java.html)（返回以插入顺序返回重复键）。'
- en: '**Points in the plane.** Write three `static` static comparators for the [Point2D.java](Point2D.java.html)
    data type, one that compares points by their x coordinate, one that compares them
    by their y coordinate, and one that compares them by their distance from the origin.
    Write two non-static comparators for the Point2D data type, one that compares
    them by their distance to a specified point and one that compares them by their
    polar angle with respect to a specified point.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平面上的点。**为[Point2D.java](Point2D.java.html)数据类型编写三个`static`静态比较器，一个按照它们的x坐标比较点，一个按照它们的y坐标比较点，一个按照它们与原点的距离比较点。为Point2D数据类型编写两个非静态比较器，一个按照它们到指定点的距离比较，一个按照它们相对于指定点的极角比较。'
- en: '**Interval 1D data type.** Write three `static` comparators for [Interval1D.java](../12oop/Interval1D.java.html),
    one that compares intervals by their left endpoing, one that compares intervals
    by their right endpoint, and one that compares intervals by their length.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一维区间数据类型。**为[Interval1D.java](../12oop/Interval1D.java.html)编写三个`static`比较器，一个按照它们的左端点比较区间，一个按照它们的右端点比较区间，一个按照它们的长度比较区间。'
- en: '**Sort files by name.** Write a program [FileSorter.java](FileSorter.java.html)
    that takes the name of a directory as a command line input and prints out all
    of the files in the current directory, sorted by filename. *Hint*: use the [java.io.File](http://docs.oracle.com/javase/6/docs/api/java/io/File.html)
    data type.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按名称对文件进行排序。**编写一个程序[FileSorter.java](FileSorter.java.html)，该程序接受一个目录名称作为命令行输入，并按文件名打印出当前目录中的所有文件。*提示*：使用[java.io.File](http://docs.oracle.com/javase/6/docs/api/java/io/File.html)数据类型。'
- en: '**Boerner''s theorem.** True or false: If you sort each column of a matrix,
    then sort each row, the columns are still sorted. Justify your answer.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**博纳定理。**真或假：如果对矩阵的每一列进行排序，然后对每一行进行排序，那么列仍然是有序的。解释你的答案。'
- en: '*Answer.* True.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*。正确。'
- en: '**Distinct values.** Write a program [Distinct.java](Distinct.java.html) that
    takes integers M, N, and T as command-line arguments, then uses the code given
    in the text to perform T trials of the following experiment: Generate N random
    int values between 0 and M–1 and count the number of distinct values generated.
    Run your program for T = 10 and N = 10^3, 10^4, 10^5, and 10^6, with M = 1/2 N,
    N, and 2N. Probability theory says that the number of distinct values should be
    about M(1 – e^(-alpha)), where alpha = N/M— print a table to help your confirm
    that your experiments validate this formula.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不同值。**编写一个程序[Distinct.java](Distinct.java.html)，它接受整数M、N和T作为命令行参数，然后使用文本中给出的代码执行以下实验的T次试验：生成0到M-1之间的N个随机整数值，并计算生成的不同值的数量。将程序运行T
    = 10和N = 10^3、10^4、10^5和10^6，其中M = 1/2 N、N和2N。概率论表明，不同值的数量应该约为M(1 - e^(-alpha))，其中alpha
    = N/M—打印一个表格来帮助您确认您的实验验证了这个公式。'
- en: Web Exercises
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Web 练习
- en: '**Counter data type.** Modify [Counter.java](../12oop/Counter.java.html) so
    that it implements the `Comparable` interface, comparing counters by tally.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计数器数据类型。**修改[Counter.java](../12oop/Counter.java.html)，使其实现`Comparable`接口，通过计数比较计数器。'
- en: '**Grade data type.** Write a program [Grade.java](Grade.java.html) to represent
    a data type for grades (A, B+, etc.). It should implement the `Comparable` interface
    using the natural ordering on grades by GPA.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**成绩数据类型。**编写一个程序[Grade.java](Grade.java.html)来表示成绩的数据类型（A、B+等）。它应该使用GPA对成绩进行自然排序，实现`Comparable`接口。'
- en: '**Student data type.** Write an data type [Student.java](Student.java.html)
    that represents a student in a college course. Each student should have a login
    (String), a section number (integer), and a grade (Grade).'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**学生数据类型。**编写一个数据类型[Student.java](Student.java.html)，表示大学课程中的学生。每个学生应该有一个登录名（String）、一个部分号（整数）和一个成绩（Grade）。'
- en: '**Case insensitive order.** Write a code fragment to read in a sequence of
    strings and sort them in ascending order, ignoring case.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不区分大小写的顺序。**编写一个代码片段，读取一系列字符串并按升序排序，忽略大��写。'
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Case insensitive comparator.** Implement your own version of the comparator
    `String.CASE_INSENSITIVE_ORDER`.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不区分大小写的比较器。**实现自己版本的比较器`String.CASE_INSENSITIVE_ORDER`。'
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Descending order string comparator.** Implement a comparator that sorts string
    in descending order instead of ascending order.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**降序字符串比较器。**实现一个比较器，按降序而不是升序对字符串进行排序。'
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Alternatively, you can use `Collections.reverseOrder()`. It returns a `Comparator`
    that imposes the reverse of the natural ordering of objects that implement the
    `Comparable` interface.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用`Collections.reverseOrder()`。它返回一个`Comparator`，它施加实现`Comparable`接口的对象的自然顺序的反向排序。
- en: '**Sorting strings from non-English alphabets.** Write a program to sort strings
    according to non-English alphabets, for accents, umlauts, and pre-composed character
    like ch in Spanish.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按非英语字母表排序字符串。**编写一个程序，根据非英语字母表对字符串进行排序，包括重音符号、分音符号和像西班牙语中的ch这样的预组合字符。'
- en: '*Hint:* Use Java''s [java.text.Collator](http://docs.oracle.com/javase/6/docs/api/java/text/Collator.html)
    API. For example in UNICODE, `Rico` occurs lexicographically before `Réal`, but
    in French, `Réal` occurs first.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：使用Java的[java.text.Collator](http://docs.oracle.com/javase/6/docs/api/java/text/Collator.html)
    API。例如，在UNICODE中，`Rico`在`Réal`之前按字典顺序出现，但在法语中，`Réal`首先出现。'
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Smith''s rule.** The following problem arises in supply chain management.
    You have a bunch of jobs to schedule on a single machine. (Give example.) Job
    j requires p[j] units of processing time. Job j has a positive weight w[j] which
    represents its relative importance - think of it as the inventory cost of storing
    the raw materials for job j for 1 unit of time. If job j finishes being processed
    at time t, then it costs t * w[j] dollars. The goal is to sequence the jobs so
    as to minimize the sum of the weighted completion times of each job. Write a program
    `SmithsRule.java` that reads in a command line parameter N and a list of N jobs
    specified by their processing time p[j] and their weight w[j], and output an optimal
    sequence in which to process their jobs. *Hint:* Use *Smith''s rule*: schedule
    the jobs in order of their ratio of processing time to weight. This greedy rule
    turns out to be optimal.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**史密斯规则。** 在供应链管理中出现了以下问题。你有一堆工作要在一台机器上安排。（给出例子。）工作j需要p[j]单位的处理时间。工作j有一个正权重w[j]，表示其相对重要性
    - 将其视为存储原材料的库存成本为工作j存储1个时间单位。如果工作j在时间t完成处理，那么它的��本为t * w[j]美元。目标是安排工作的顺序，以最小化每个工作的加权完成时间之和。编写一个程序`SmithsRule.java`，它从命令行参数N和由它们的处理时间p[j]和权重w[j]指定的N个工作列表中读取，并输出一个最佳的处理工作顺序。*提示：*
    使用*史密斯规则*：按照处理时间与权重比率的顺序安排工作。这种贪婪规则事实证明是最优的。'
- en: '**Rhyming words.** For your poetry class, you would like to tabulate a list
    of rhyming words. A crude way to accomplish this task is as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**押韵的词。** 对于你的诗歌课程，你想要列出一张押韵词的列表。完成这个任务的一种简单方法如下：'
- en: Read in a dictionary of words into an array of strings.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个单词字典读入一个字符串数组中。
- en: Reverse the letters in each word, e.g., `confound` becomes `dnuofnoc`.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个单词的字母倒转，例如，`confound`变为`dnuofnoc`。
- en: Sort the resulting array of words.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对结果数组中的单词进行排序。
- en: Reverse the letters in each word back to their original state.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个单词的字母倒转回原始状态。
- en: Now the word `confound` will be next to words like `astound` and `compound`.
    Write a program [Rhymer.java](Rhymer.java.html) that reads in a sequence of words
    from standard input and prints them out in the order specified above.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在单词`confound`将会与`astound`和`compound`等单词相邻。编写一个程序[Rhymer.java](Rhymer.java.html)，从标准输入中读取一系列单词，并按照上述指定的顺序打印它们。
- en: Now repeat, but use a customized `Comparator` that sorts lexicographically from
    right-to-left.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在重复一遍，但使用一个自定义的`Comparator`，按从右到左的字典顺序排序。
- en: '**Mode.** Give an O(N log N) algorithm for computing the mode (value that occurs
    most frequently) of a sequence of N integers.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**众数。** 给出一个O(N log N)的算法，用于计算序列N个整数中出现最频繁的值。'
- en: '**Closest 1d pair.** Given a sequence of N real numbers, find the pair of integers
    that are closest in value. Give a O(N log N) algorithm.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最接近的1维对。** 给定一个包含N个实数的序列，找到值最接近的整数对。给出一个O(N log N)的算法。'
- en: '**Farthest 1d pair.** Given a sequence of N real numbers, find the pair of
    integers that are farthest apart in value. Give a O(N) algorithm.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最远的1维对。** 给定一个包含N个实数的序列，找到值最远的整数对。给出一个O(N)的算法。'
- en: '**Sorting with many duplicates.** Suppose you have a sequence of N elements,
    with at most log N distinct ones. Describe how to sort them in O(N log log N)
    time.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有许多重复项的排序。** 假设你有一个包含N个元素的序列，其中最多有log N个不同的元素。描述如何在O(N log log N)时间内对它们进行排序。'
- en: '**Nearly sorted.** Given an array of N elements, each which is at most k positions
    from its target position, devise an algorithm that sorts in O(N log k) time.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**几乎有序。** 给定一个包含N个元素的数组，每个元素最多离其目标位置k个位置，设计一个能在O(N log k)时间内排序的算法。'
- en: '**Sorting a linked list.** Given a singly linked list of N elements, how could
    you sort it in guaranteed O(N log N) time, stably, and with O(1) extra space?'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对链表进行排序。** 给定一个包含N个元素的单链表，如何在保证O(N log N)时间内、稳定地、且只使用O(1)额外空间的情况下对其进行排序？'
- en: '**Goofysort (Jim Huggins).** Argue that [Goofy.java](Goofy.java.html) sorts
    the array in ascending order. What is the best-case running time of as a function
    of the number of items to be sorted N? What is the worst-case running time of
    as a function of the number of items to be sorted N?'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Goofysort（Jim Huggins）。** 论证[Goofy.java](Goofy.java.html)按升序对数组进行排序。作为要排序的项目数量N的函数，最佳情况运行时间是多少？作为要排序的项目数量N的函数，最坏情况运行时间是多少？'
- en: '**Feel-good interval.** Given an array of N nonnegative integers (representing
    a person''s emotional value on each day), the happiness in an interval is the
    sum of the values in that interval multiplied by the smallest integer in that
    interval. Design an O(N log N) divide-and-conquer algorithm to find the happiest
    interval.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**令人愉悦的区间。** 给定一个包含N个非负整数的数组（代表一个人每天的情感值），一个区间的幸福度是该区间中值的总和乘以该区间中最小的整数。设计一个O(N
    log N)的分治算法来找到最幸福的区间。'
- en: '*Solution.* Here''s a mergesort style solution.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 这里是一个归并排序风格的解决方案。'
- en: 'Divide the elements in the middle: a[l..m-1], a[m], a[m+1..r]'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素分为中间部分：a[l..m-1]，a[m]，a[m+1..r]
- en: Recursively compute the optimal interval entirely in the left half
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地计算左半部分中的最佳区间
- en: Recursively compute the optimal interval entirely in the right half
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地计算右半部分中的最佳区间
- en: Compute the optimal interval containing a[m]
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算包含a[m]的最佳区间
- en: 'Return the best of the three intervalsThe key step for efficiency is computing
    the optimal interval containing `a[m]` in linear time. Here''s a greedy solution:
    If the optimal interval containing `a[m]` contains one element, it is simply `a[m]`.
    If it contains more than one element, it must contain the larger of `a[m-1]` and
    `a[m+1]`, so add this to the interval. Repeat, etc. Return the best interval of
    any size constructed by this process.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回三个区间中最佳的一个为了效率的关键步骤是在线性时间内计算包含`a[m]`的最佳区间。这里是一个贪婪的解决方案：如果包含`a[m]`的最佳区间只包含一个元素，那就是`a[m]`。如果包含多于一个元素，那么必须包含`a[m-1]`和`a[m+1]`中较大的一个，所以将其添加到区间中。重复这个过程，以此类推。返回通过这个过程构建的任何大小的最佳区间。
- en: '**Equality detector.** Suppose that you have N elements and you want to determine
    if at least N/2 are equal. Assume the only operation on the elements you can perform
    is equality testing. Design an algorithm that performs O(N log N) equality tests
    to find a representative element if it exists. *Hint*: divide-and-conquer. Note:
    can also do in O(N) tests.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Equality detector.** 假设你有 N 个元素，并且想确定至少有 N/2 个元素相等。假设你只能执行相等性测试操作。设计一个算法，在
    O(N log N) 次相等性测试中找到一个代表元素（如果存在的话）。*提示*：分治法。注意：也可以在 O(N) 次测试中完成。'
- en: '**Maxima.** Given a set of n points in the plane, point (xi, yi) dominates
    (xj, yj) if xi > xj and yi > yj. A maxima is a point that is not dominated by
    any other point in the set. Devise an O(n log n) algorithm to find all maxima.
    Application: on x-axis is space efficiency, on y-axis is time efficiency. Maxima
    are useful algorithms. Hint: sort in ascending order according to x-coordinate;
    scan from right to left, recording the highest y-value seen so far, and mark these
    as maxima.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Maxima.** 给定平面上的 n 个点集，点 (xi, yi) 支配点 (xj, yj) 如果 xi > xj 并且 yi > yj。极大值是一个不被集合中任何其他点支配的点。设计一个
    O(n log n) 的算法来找到所有极大值。应用：在 x ��上是空间效率，在 y 轴上是时间效率。极大值是有用的算法。提示：根据 x 坐标升序排序；从右到左扫描，记录迄今为止看到的最高
    y 值，并将其标记为极大值。'
- en: '**Min and max.** Given an array of N elements, find the min and max using as
    few compares as possible. Brute force: find the max (N-1 compares), then find
    the min of the remaining elements (N-2 compares).'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Min and max.** 给定一个包含 N 个元素的数组，尽可能少地比较找到最小值和最大值。暴力法：找到最大值（N-1 次比较），然后找到剩余元素的最小值（N-2
    次比较）。'
- en: '*Solution 1.* Divide and conquer: find min and max in each half (2T(N/2) compares),
    return min of 2 and max of 2 (2 compares). T(1) = 0, T(2) = 1, T(N) = 2T(N/2)
    + 2. Recurrence solution: T(N) = ceil(3N/2) - 2.'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Solution 1.* 分治法：在每一半中找到最小值和最大值（2T(N/2) 次比较），返回 2 的最小值和 2 的最大值（2 次比较）。T(1)
    = 0，T(2) = 1，T(N) = 2T(N/2) + 2。递归解：T(N) = ceil(3N/2) - 2。'
- en: '*Solution 2.* Divide the elements into pairs and compare two elements in each
    pair. Put the smallest elements in A and the largest in B. If n is odd, put element
    n in both A and B. This requires floor(n/2) comparisons. Now directly compute
    the minimum in A (ceil(n/2) - 1 comparisons) and the maximum in B (ceil(N/2) -
    1) comparisons. [In fact, this is best possible.]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Solution 2.* 将元素分成一对一对，并比较每对中的两个元素。将最小的元素放在 A 中，最大的元素放在 B 中。如果 n 是奇数，将元素 n
    放在 A 和 B 中。这需要 floor(n/2) 次比较。现在直接计算 A 中的最小值（ceil(n/2) - 1 次比较）和 B 中的最大值（ceil(N/2)
    - 1 次比较）。[事实上，这是最佳的解决方案。]'
- en: '**Sorting by reversals.** [ [Mihai Patrascu](http://people.csail.mit.edu/mip/probs.html)]
    Given an array a[1..n], sort using the following type operation: pick two indices
    i and j and reverse the elements in a[i..j]. This operation costs j-i+1\. Goal:
    O(n log^2 n).'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Sorting by reversals.** [ [Mihai Patrascu](http://people.csail.mit.edu/mip/probs.html)]
    给定一个数组 a[1..n]，使用以下类型的操作进行排序：选择两个索引 i 和 j，并反转 a[i..j] 中的元素。这个操作的成本为 j-i+1。目标：O(n
    log^2 n)。'
- en: '**L1 norm.** There are N circuit elements in the plane. You need to run a special
    wire (parallel to the x-axis) across the circuit. Each circuit element must be
    connected to the special wire. Where should you put the special wire? *Hint*:
    median minimizes L1 norm.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**L1 norm.** 平面上有 N 个电路元件。你需要沿电路运行一根特殊的导线（平行于 x 轴）。每个电路元件必须连接到特殊导线。你应该把特殊导线放在哪里？*提示*：中位数最小化
    L1 范数。'
- en: '**Median given two sorted arrays.** Given two sorted arrays of size N[1] and
    N[2], find the median of all elements in O(log N) time where N = N[1] + N[2].
    Or find the kth overall largest in O(log k).'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Median given two sorted arrays.** 给定大小为 N[1] 和 N[2] 的两个已排序数组，以 O(log N) 时间找到所有元素的中位数，其中
    N = N[1] + N[2]。或者在 O(log k) 时间内找到第 k 大的元素。'
- en: '**Three nearby numbers in an array.** Given a floating-point array `a[]`, design
    a linearithmic algorithm to find three distinct integers i, j, and k such that
    |a[i] - a[j]| + |a[j] - a[k]| + |a[k] - a[i]| is minimum.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Three nearby numbers in an array.** 给定一个浮点数数组 `a[]`，设计一个线性对数时间复杂度的算法，找到三个不同的整数
    i, j, 和 k，使得 |a[i] - a[j]| + |a[j] - a[k]| + |a[k] - a[i]| 最小。'
- en: '*Hint:* if a[i] <= a[j] <= a[k], then |a[i] - a[j]| + |a[j] - a[k]| + |a[k]
    - a[i]| = 2 (a[k] - a[i]).'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Hint:* 如果 a[i] <= a[j] <= a[k]，那么 |a[i] - a[j]| + |a[j] - a[k]| + |a[k] -
    a[i]| = 2 (a[k] - a[i])。'
- en: '**Three nearby numbers in three arrays.** Given three floating-point arrays
    `a[]`, `b[]`, and `c[]`, design a linearithmic algorithm to find three integers
    i, j, and k such that |a[i] - b[j]| + |b[j] - c[k]| + |c[k] - a[i]| is minimum.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Three nearby numbers in three arrays.** 给定三个浮点数数组 `a[]`, `b[]`, 和 `c[]`，设计一个线性对数时间复杂度的算法，找到三个整数
    i, j, 和 k，使得 |a[i] - b[j]| + |b[j] - c[k]| + |c[k] - a[i]| 最小。'
- en: '**Minimum dot product.** Given two vectors of the same length, find a permutation
    of the two vectors such that the dot product of the two vectors is as small as
    possible.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Minimum dot product.** 给定相同长度的两个向量，找到两个向量的点积尽可能小的排列。'
- en: '**Two-sum.** Given an array of N integers, design a linearithmic algorithm
    to find a pair of integers whose sum is closest to zero.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Two-sum.** 给定一个包含 N 个整数的数组，设计一个线性对数时间复杂度的算法，找到一对整数，使它们的和最接近零。'
- en: '*Solution*: sort by absolute value—the best pair is now adjacent.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Solution*: 按绝对值排序，最佳对现在是相邻的。'
- en: '**3-sum in quadratic time.** The 3-sum problem is to find, in an array of integers,
    the triple whose sum is closest to zero. Describe an algorithm for this problem
    that uses linear space and quadratic time.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-sum in quadratic time.** 3-sum 问题是在整数数组中找到和最接近零的三元组。描述一个使用线性空间和二次时间的解决方案。'
- en: '*Hint*: solve the following subproblem. Given a sorted list of N integers and
    a target integer x, determine in linear time the two whose sum is closest to x.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Hint*：解决以下子问题。给定 N 个整数的排序列表和目标整数 x，在线性时间内确定最接近 x 的两个整数。'
- en: '**Bandwidth.** Given intervals with bandwidth requirements, find the maximum
    bandwidth requirement (and the interval for which that maximum is required).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bandwidth.** 给定带宽要求的区间，找到最大带宽需求（以及需要该最大带宽的区间）。'
- en: '*Solution.* Sort the intervals by start time; insert the intervals into PQ
    in this order, but using the ending time as the key. Before inserting the next
    interval, compare its start time to ending time of the minimum interval on the
    PQ: if it is greater, delete the minimum interval on the PQ. Always keep track
    of the cumulative bandwidth on the PQ.'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 按开始时间对区间进行排序；按照这个顺序将区间插入PQ，但使用结束时间作为键。在插入下一个区间之前，比较其开始时间与PQ上最小区间的结束时间：如果大于，删除PQ上的最小区间。始终跟踪PQ上的累积带宽。'
- en: '**Time stamps.** Given N time stamps when file is requested from web server,
    find largest interval of time at which no file arrives. *Solution*: sort by time
    stamp. Scan sorted list to identify maximum gap. (Same as idle time.)'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**时间戳。** 给定N个时间戳，当文件从Web服务器请求时，找到没有文件到达的最长时间间隔。*解决方案*：按时间戳排序。扫描排序列表以识别最大间隙。
    （与空闲时间相同。）'
- en: '**Ticket ranges.** Given a list of ticket seats of the form A1, A2, A11, A10,
    B7, B9, B8, B3, find the largest non-empty block of adjacent seats, e.g., A3-A9\.
    (Same as idle time.)'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**票务范围。** 给定一个形式为A1、A2、A11、A10、B7、B9、B8、B3的票务座位列表，找到最大的非空相邻座位块，例如，A3-A9。 （与空闲时间相同。）'
- en: '**Decimal dominant.** Given an array with N comparable keys, design an algorithm
    to check if there is a value that appears more than N/10 times. Your algorithm
    should run in expected linear time.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**十进制主导。** 给定一个具有N个可比较键的数组，设计一个算法来检查是否有一个值出现的次数超过N/10次。你的算法应该在期望的线性时间内运行。'
- en: '*Solution.* Use quickselect to find the N/10th largest value; check if it is
    a dominant; if not, recur in the subarray with 9N/10 values.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 使用快速选择找到第N/10大的值；检查它是否是主导值；如果不是，在具有9N/10个值的子数组中递归。'
- en: Alternatively, use 9 counters.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用9个计数器。
- en: '**Local min and max.** Given N distinct comparable items, rearrange them so
    that each internal item is either greater than both items right before and after
    it or less than both items right before and after it.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**局部最小和最大。** 给定N个不同的可比较项，重新排列它们，使得每个内部项要么大于其前后两项，要么小于其前后两项。'
- en: '*Hint*: sort and interleave the first and second halves.'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：对前半部分和后半部分进行排序和交错。'
- en: '**h-index.** Given an array of N positive integers, its [h-index](http://en.wikipedia.org/wiki/H-index)
    is the largest integer *h* such that there are at least *h* entries in the array
    greater than or equal to *h*. Design an algorithm to compute the *h*-index of
    an array.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**h指数。** 给定一个由N个正整数组成的数组，它的[h指数](http://en.wikipedia.org/wiki/H-index)是最大的整数*h*，使得数组中至少有*h*个条目大于或等于*h*。设计一个算法来计算数组的*h*指数。'
- en: '*Hint*: median or quicksort-like partitioning and divide-and-conquer.'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：中位数或类似快速排序的分区和分治。'
- en: '**Software version number.** Define a comparator that compares two version
    numbers (such as 1.2.32 and 1.2.5) chronologically. Assume that the version number
    is a string composed of only decimal digits and . character. The . character separates
    fields; it is not a decimal point.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**软件版本号。** 定义一个比较器，比较两个版本号（例如1.2.32和1.2.5）的时间顺序。假设版本号是仅由十进制数字和.字符组成的字符串。.字符分隔字段；它不是小数点。'
- en: '**Stable selection sort.** What modifications do you need to do to make selection
    sort stable?'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稳定的选择排序。** 你需要做什么修改才能使选择排序稳定？'
- en: '*Solution*: first, when finding the minimum remaining key, always choose the
    leftmost entry; second, instead of moving the minimum key to the front with one
    exchange, move all elements to its left that are large one position to the right.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：首先，在找到最小剩余键时，始终选择最左边的条目；其次，不是用一次交换将最小键移动到最前面，而是将所有大于它的元素向右移动一个位置。'
- en: '**Largest number.** Given n positive integers, concatenate them so that they
    form the largest number. For example, if the numbers are 123, 12, 96, and 921,
    then the result should be 9692112312.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大数。** 给定n个正整数，将它们连接起来，使它们形成最大的数。例如，如果数字是123、12、96和921，则结果应该是9692112312。'
- en: '*Solution.* Define a comparator that compares two numbers by concatenating
    them together in either order (e.g., for 96 and 921, compare 96921 vs. 92196)
    and seeing which string is lexicographically largest.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 定义一个比较器，通过将两个数字连接在一起（例如，对于96和921，比较96921与92196），看哪个字符串在字典顺序上最大。'
- en: '**Largest number.** Given three arrays A, B, and C, each of length n, determine
    ther number of triples with a in A, b in B, and c in C are there such that a <
    b < c?'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大数。** 给定三个长度为n的数组A、B和C，确定有多少个三元组a在A中，b在B中，c在C中，使得a < b < c？'
