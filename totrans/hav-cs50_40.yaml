- en: Lecture 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/r/notes/2/](https://cs50.harvard.edu/r/notes/2/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Outliers](#outliers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Logical Expressions](#logical-expressions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Subsets with Logical Vectors](#subsets-with-logical-vectors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Subsets of Data Frames](#subsets-of-data-frames)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Menus](#menus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Escape Characters](#escape-characters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conditionals](#conditionals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Combining Data Sources](#combining-data-sources)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Welcome back to CS50’s Introduction to Programming with R!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn how to remove portions of data, find specific pieces of data,
    and how to take different data from different sources and combine them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outliers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In statistics, *outliers* are data that are outside an expected range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, statisticians and data scientists want to identify outliers for special
    consideration. Sometimes, outliers will want to be removed from a calculation.
    Other times, you might want to analyze with outliers included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate how we can work with outliers in R, you can create a new file
    in RStudio by typing `file.create("temps.R")` in the R console. Further, you will
    need to download a file called `temps.RData` into your working directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To load data, we can write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `load` function loads our data file called `temps.RData`. Next,
    `mean` will average this data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running this script, you can see the results of this calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, as stated before, there are outliers in this underlying data. Let’s
    discover those.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at temps overall, as illustrated in the lecture video, we want to be
    able to directly access these outlier temperatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recall during Week 1 how we *indexed into* data in a vector. Modify your code
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `temps[2]` will directly access one of the outlier temperatures.
    The final line of code takes a *subset* of the `temps` vector, which includes
    only the elements at the 2nd, 4th, and 7th indexes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a next step, we can remove the outlier data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the data is loaded. Then, `no_outliers` is a new vector which includes
    only the temperatures that are *not* outliers. The vector called `temps` *does*
    still include the outlier data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logical Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Logical expressions* are means by which to programmatically answer yes and
    no questions. Logical expressions make use of *logical operators*, which are used
    for comparing values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many logical operators you can use in R, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For example, you could ask whether 1 is equal to 2 by typing `1 == 2` in the
    R console. The result should be `FALSE` (or “no!”). However, `1 < 2` should be
    `TRUE` (or “yes!”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Logicals* are the response provided by a logical expression. Logicals can
    be `TRUE` or `FALSE`. These values can alternatively be expressed in a more abbreviated
    form as `T` or `F`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using logical operators within your code, you can modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how running this code will result in answers in terms of `TRUE` and `FALSE`
    in the R console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This code can be further improved as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how running this code will create a *logical vector* (i.e., a vector
    of logicals). Each value in the logical vector answers whether its corresponding
    value is less than 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To identify the indexes for which some logical expression is true, you can
    modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that now the *indexes* of the temperatures in the vector that are less
    than 0 are output to the R console. The function `which` takes a logical vector
    as input and returns the indexes of the values that are `TRUE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When working with outliers, a common desire is to show data that is below or
    above a threshold. You can accomplish this in your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the character `|` symbolizes *or* in the expression. This logical
    expression will be `TRUE` for any value in `temps` that is less than `0` *or*
    greater than `60`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition to the logical operators we discussed earlier, we now add two new
    ones to our vocabulary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the capability of expressing *or* and *and* are provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can further improve your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `any` and `all` take logical vectors as input. `any` answers the
    question, “are *any* of these logical values true?”. `all` answers the question
    “are *all* of these temperatures true?”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Subsets with Logical Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As illustrated before, we can create a new vector that removes the outliers
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a new subsetting vector called `filter` is created based on a logical
    expression. Thus, `filter` can now be provided to `temps` to request only those
    items in `temps` that evaluated as `TRUE` in the logical expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, the code can be modified to only filter those that are *not* outliers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the addition of the `!` means *does not equal* or simply *not*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This negation can be leveraged to remove outliers entirely from the data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how two files are now saved. One excludes the outliers. The other includes
    the outliers. These files are saved in the working directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Subsets of Data Frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we find a subset of data we are interested in from a dataset?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine a table of data that logs each chick (a baby chicken!), the feed each
    chick is fed, and the weight of each chick. You can download `chicks.csv` from
    the lecture source code to see this data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Closing our previous file in RStudio, let’s create a new file in the R console
    by typing `file.create("chicks.R")`. Ensure you have `chicks.csv` in your working
    directory, then select `chicks.R` and write your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `read.csv` reads the CSV file into a data frame called `chicks`.
    Then, `chicks` is viewed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Looking at the output of the above, notice that there are many `NA` values,
    representing data that is not available. Consider how this may impact a calculation
    of the average chick weight. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how running this code will result in an error, as some values are not
    available to be mathematically evaluated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Missing data is an expected problem within statistics. You, as the programmer,
    need to make a decision about how to treat missing data. You can calculate the
    average chick weight while removing `NA` values as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `na.rm = TRUE` will remove all `NA` values for the purpose of computing
    an average with `mean`. Per the documentation, `na.rm` can be set as `TRUE` or
    `FALSE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s figure out how the food each chick eats impacts their weight:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that a subset of the `chicks` data frame is created by explicitly specifying
    the appropriate indexes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is not an efficient way of programming, since we shouldn’t expect our data
    to never change. How can we modify our code so that it is more flexible? We can
    use logical expressions to dynamically subset a data frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the logical expression identifies whether each value in the feed
    column is equal to “casein.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can leverage this logical expression within our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As demonstrated earlier in the lecture, notice how a logical vector called `filter`
    is created. Then, only those rows that are `TRUE` in `filter` are brought into
    the data frame `casein_chicks`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have a subset of our data frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can accomplish the same result by using the function `subset`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This data frame, called `casein_chicks`, is created with the `subset` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, one may wish to filter out all `NA` values at the start. Consider the
    following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this code will use `is.na` to find `NA` values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Records can be entirely removed, leveraging `is.na` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this code creates a subset of `chicks` where `is.na(weight)` is equal
    to `FALSE`. That is, `chicks` only includes rows where `NA` is not present in
    the `weight` column. If you care about your data frame’s row names, though, be
    aware that—when you removed certain rows—you also removed those rows’ corresponding
    `rownames`. You can ensure the names of your rows still ascend sequentially by
    running `rownames(chicks) <- NULL`, which resets the names of all of your rows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In R, you can present users with options. For example, you can offer the user
    the type of feed they wish to filter for the chicks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this code uses `unique` to discover the individual unique feed options.
    Each of these feed options is then outputted with `cat`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code works in the sense that it shows the various options of feed, but
    it’s not very well formatted. How can we output the different options on their
    own line in the R console?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escape Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Escape characters* are characters whose output differs from the way you type
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, some commonly used escape characters are `\n`, which prints a
    new line, or `\t`, which prints a tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leveraging escape characters, we can modify our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this outputs all the options of feed on individual lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we have the right sort of menu being displayed, we can still improve
    our code from a design perspective. For example, why should we repeat all of these
    `cat` lines? Simplify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `formatted_options` includes all the individual feed options. Each
    element of this vector of `formatted_options` is printed and separated by a new
    line using `cat(formatted_options, sep = "\n")`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, as we indicated earlier, our intention is to create an interactive program.
    Thus, we can now prompt the user with options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the user is prompted with `Feed type:` , where a number can be converted
    to the text-based representation of the feed option. Then, the `feed_choice` they
    selected is assigned to `selected_feed`. Finally, the subset corresponding to
    the `selected_feed` is outputted to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, you can imagine how your user may not behave as expected. For example,
    if the user inputted `0`, which is not a potential choice, the output of our program
    will be strange. How can we ensure our user inputs the right text?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Conditionals* are ways to determine `if` a condition has been met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how `if (feed_choice < 1 || feed_choice > length(feed_options))` determines
    if the user’s input falls outside a range of values. If so, the program displays
    “Invalid choice.” However, there’s still a problem: the program will continue
    to run, even with that invalid choice.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`if` and `else` can be leveraged as follows to only run the final calculation
    if the user inputs a valid choice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice, that code which is wrapped in `if` runs only if there is an invalid
    choice. That code which is wrapped in `else` will run only if the previous condition
    in `if` was not met.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Combining Data Sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final matter of this lecture, let’s examine how to combine sources of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine a table that represents sales to customers, like Amazon might have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can imagine scenarios where that data is spread across many tables. How
    can these data be combined from many sources?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code called `sales.R`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how each quarter of financial data, such as `Q1` and `Q2`, is read into
    their own data frames.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s combine this data from these four data frames:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `rbind` is used to gather together the data from each of these data
    frames.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s worth mentioning that `rbind` is usable in this case because all four data
    frames are structured the same way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the previously run program is that `sales` includes each row from
    each data frame. Instead of showing `Q1`, `Q2`, etc. for each customer, it simply
    creates new rows for each line of data at the bottom of the file. Hence, the file
    becomes longer and longer as more and more data is combined into it. It’s entirely
    unclear in what quarter each sales value occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our code can be improved such that a column for the financial quarter is created
    for each record as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how each quarter is added to a specific `quarter` column. Thus, when
    `rbind` combines the data frames into `sales` with the sales organized by `quarter`
    columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a final flourish, let’s add a `value` column where high returns and regular
    returns are noted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the final line of code assigns “High Value” when the `sale_amount`
    is greater than `100`. Otherwise, the transaction is assigned “Regular.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, you learned how to transform data in R. Specifically, you learned…
  prefs: []
  type: TYPE_NORMAL
- en: Outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escape Characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Data Sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time when we discuss how to write functions of our own.
  prefs: []
  type: TYPE_NORMAL
