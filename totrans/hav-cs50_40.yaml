- en: Lecture 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座2
- en: 原文：[https://cs50.harvard.edu/r/notes/2/](https://cs50.harvard.edu/r/notes/2/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/r/notes/2/](https://cs50.harvard.edu/r/notes/2/)
- en: '[Welcome!](#welcome)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欢迎！](#welcome)'
- en: '[Outliers](#outliers)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异常值](#outliers)'
- en: '[Logical Expressions](#logical-expressions)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[逻辑表达式](#logical-expressions)'
- en: '[Subsets with Logical Vectors](#subsets-with-logical-vectors)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用逻辑向量的子集](#subsets-with-logical-vectors)'
- en: '[Subsets of Data Frames](#subsets-of-data-frames)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据框的子集](#subsets-of-data-frames)'
- en: '[Menus](#menus)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[菜单](#menus)'
- en: '[Escape Characters](#escape-characters)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[转义字符](#escape-characters)'
- en: '[Conditionals](#conditionals)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[条件语句](#conditionals)'
- en: '[Combining Data Sources](#combining-data-sources)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[合并数据源](#combining-data-sources)'
- en: '[Summing Up](#summing-up)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Welcome!
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎！
- en: Welcome back to CS50’s Introduction to Programming with R!
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎回到CS50的R语言编程入门课程！
- en: We will learn how to remove portions of data, find specific pieces of data,
    and how to take different data from different sources and combine them.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何删除数据的一部分，查找特定的数据，以及如何从不同的来源获取不同的数据并将它们合并。
- en: Outliers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常值
- en: In statistics, *outliers* are data that are outside an expected range.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在统计学中，*异常值*是指超出预期范围的数值。
- en: Typically, statisticians and data scientists want to identify outliers for special
    consideration. Sometimes, outliers will want to be removed from a calculation.
    Other times, you might want to analyze with outliers included.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，统计学家和数据科学家希望识别异常值以进行特殊处理。有时，可能需要从计算中移除异常值。其他时候，你可能希望包括异常值进行分析。
- en: To illustrate how we can work with outliers in R, you can create a new file
    in RStudio by typing `file.create("temps.R")` in the R console. Further, you will
    need to download a file called `temps.RData` into your working directory.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了说明如何在R中处理异常值，你可以在RStudio中通过在R控制台中输入`file.create("temps.R")`来创建一个新文件。进一步，你需要在你的工作目录中下载一个名为`temps.RData`的文件。
- en: 'To load data, we can write code as follows:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要加载数据，我们可以编写如下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how the `load` function loads our data file called `temps.RData`. Next,
    `mean` will average this data.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`load`函数如何加载名为`temps.RData`的数据文件。接下来，`mean`将计算这些数据的平均值。
- en: Running this script, you can see the results of this calculation.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行此脚本，你可以看到计算结果。
- en: However, as stated before, there are outliers in this underlying data. Let’s
    discover those.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，正如之前所述，这些基础数据中存在异常值。让我们来发现这些异常值。
- en: Looking at temps overall, as illustrated in the lecture video, we want to be
    able to directly access these outlier temperatures.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从整体上看温度，如图中讲座视频所示，我们希望能够直接访问这些异常温度。
- en: 'Recall during Week 1 how we *indexed into* data in a vector. Modify your code
    as follows:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想第1周我们如何在向量中*索引*数据。按照以下方式修改你的代码：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how `temps[2]` will directly access one of the outlier temperatures.
    The final line of code takes a *subset* of the `temps` vector, which includes
    only the elements at the 2nd, 4th, and 7th indexes.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`temps[2]`将直接访问一个异常温度。最后一行代码从`temps`向量中取一个*子集*，只包括第2、4和第7个索引的元素。
- en: 'As a next step, we can remove the outlier data:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为下一步，我们可以移除异常值数据：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the data is loaded. Then, `no_outliers` is a new vector which includes
    only the temperatures that are *not* outliers. The vector called `temps` *does*
    still include the outlier data.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意数据已加载。然后，`no_outliers`是一个只包含非异常温度的新向量。名为`temps`的向量*仍然*包含异常值数据。
- en: Logical Expressions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑表达式
- en: '*Logical expressions* are means by which to programmatically answer yes and
    no questions. Logical expressions make use of *logical operators*, which are used
    for comparing values.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑表达式*是通过编程回答是和否问题的手段。逻辑表达式利用*逻辑运算符*，这些运算符用于比较值。'
- en: 'There are many logical operators you can use in R, including:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在R中，你可以使用许多逻辑运算符，包括：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For example, you could ask whether 1 is equal to 2 by typing `1 == 2` in the
    R console. The result should be `FALSE` (or “no!”). However, `1 < 2` should be
    `TRUE` (or “yes!”).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，你可以在R控制台中输入`1 == 2`来询问1是否等于2。结果应该是`FALSE`（或“不！”）。然而，`1 < 2`应该是`TRUE`（或“是！”）。
- en: '*Logicals* are the response provided by a logical expression. Logicals can
    be `TRUE` or `FALSE`. These values can alternatively be expressed in a more abbreviated
    form as `T` or `F`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑值*是逻辑表达式提供的响应。逻辑值可以是`TRUE`或`FALSE`。这些值也可以用更简略的形式表示为`T`或`F`。'
- en: 'Using logical operators within your code, you can modify your code as follows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中使用逻辑运算符，你可以按照以下方式修改你的代码：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how running this code will result in answers in terms of `TRUE` and `FALSE`
    in the R console.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意运行此代码将在R控制台中产生以`TRUE`和`FALSE`表示的结果。
- en: 'This code can be further improved as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码可以进一步改进如下：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how running this code will create a *logical vector* (i.e., a vector
    of logicals). Each value in the logical vector answers whether its corresponding
    value is less than 0.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到运行此代码将创建一个 *逻辑向量*（即逻辑值的向量）。逻辑向量中的每个值都回答其对应值是否小于 0。
- en: 'To identify the indexes for which some logical expression is true, you can
    modify your code as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别某些逻辑表达式为真的索引，你可以按照以下方式修改你的代码：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that now the *indexes* of the temperatures in the vector that are less
    than 0 are output to the R console. The function `which` takes a logical vector
    as input and returns the indexes of the values that are `TRUE`.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意现在温度向量中小于 0 的 *索引* 将输出到 R 控制台。函数 `which` 接受一个逻辑向量作为输入，并返回值为 `TRUE` 的值的索引。
- en: 'When working with outliers, a common desire is to show data that is below or
    above a threshold. You can accomplish this in your code as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理异常值时，一个常见的愿望是显示低于或高于阈值的数值。你可以在代码中按以下方式实现：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the character `|` symbolizes *or* in the expression. This logical
    expression will be `TRUE` for any value in `temps` that is less than `0` *or*
    greater than `60`.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到字符 `|` 符号在表达式中表示 *或*。这个逻辑表达式对于 `temps` 中任何小于 `0` 或大于 `60` 的值都将返回 `TRUE`。
- en: 'In addition to the logical operators we discussed earlier, we now add two new
    ones to our vocabulary:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了我们之前讨论的逻辑运算符之外，我们现在添加了两个新的运算符到我们的词汇表中：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how the capability of expressing *or* and *and* are provided.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到表达 `or` 和 `and` 的能力是如何被提供的。
- en: 'You can further improve your code as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以进一步改进你的代码如下：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how `any` and `all` take logical vectors as input. `any` answers the
    question, “are *any* of these logical values true?”. `all` answers the question
    “are *all* of these temperatures true?”.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `any` 和 `all` 函数接受逻辑向量作为输入。`any` 回答的问题是，“这些逻辑值中是否有任何一个是真的？”`all` 回答的问题是，“所有这些温度值是否都是真的？”。
- en: Subsets with Logical Vectors
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑向量的子集
- en: 'As illustrated before, we can create a new vector that removes the outliers
    as follows:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，我们可以创建一个新的向量，如下删除异常值：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how a new subsetting vector called `filter` is created based on a logical
    expression. Thus, `filter` can now be provided to `temps` to request only those
    items in `temps` that evaluated as `TRUE` in the logical expression.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到如何根据逻辑表达式创建了一个新的子集向量 `filter`。因此，现在可以将 `filter` 提供给 `temps`，以请求 `temps` 中那些在逻辑表达式中评估为
    `TRUE` 的项。
- en: 'Similarly, the code can be modified to only filter those that are *not* outliers:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，代码可以被修改以仅过滤那些不是异常值的项：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the addition of the `!` means *does not equal* or simply *not*.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `!` 的添加意味着 *不等于* 或简单地 *不是*。
- en: 'This negation can be leveraged to remove outliers entirely from the data:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种否定可以用来完全从数据中删除异常值：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how two files are now saved. One excludes the outliers. The other includes
    the outliers. These files are saved in the working directory.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意现在有两个文件被保存。一个排除了异常值，另一个包含了异常值。这些文件保存在工作目录中。
- en: Subsets of Data Frames
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框的子集
- en: How can we find a subset of data we are interested in from a dataset?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何从一个数据集中找到我们感兴趣的数据子集？
- en: Imagine a table of data that logs each chick (a baby chicken!), the feed each
    chick is fed, and the weight of each chick. You can download `chicks.csv` from
    the lecture source code to see this data.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一个数据表，记录了每只小鸡（一只小鸡宝宝！）、每只小鸡所喂的饲料以及每只小鸡的重量。你可以从讲座源代码中下载 `chicks.csv` 来查看这些数据。
- en: 'Closing our previous file in RStudio, let’s create a new file in the R console
    by typing `file.create("chicks.R")`. Ensure you have `chicks.csv` in your working
    directory, then select `chicks.R` and write your code as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 RStudio 中关闭之前的文件，让我们在 R 控制台中创建一个新的文件，通过输入 `file.create("chicks.R")`。确保你有 `chicks.csv`
    在工作目录中，然后选择 `chicks.R` 并按照以下方式编写你的代码：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that `read.csv` reads the CSV file into a data frame called `chicks`.
    Then, `chicks` is viewed.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `read.csv` 将 CSV 文件读取到名为 `chicks` 的数据框中。然后，查看 `chicks`。
- en: 'Looking at the output of the above, notice that there are many `NA` values,
    representing data that is not available. Consider how this may impact a calculation
    of the average chick weight. Modify your code as follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看上述输出的结果，注意其中有很多 `NA` 值，代表不可用数据。考虑这可能会如何影响平均鸡重量的计算。按照以下方式修改你的代码：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how running this code will result in an error, as some values are not
    available to be mathematically evaluated.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到运行此代码将导致错误，因为某些值不可用于数学评估。
- en: 'Missing data is an expected problem within statistics. You, as the programmer,
    need to make a decision about how to treat missing data. You can calculate the
    average chick weight while removing `NA` values as follows:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失数据在统计学中是一个预期的问题。作为程序员，您需要决定如何处理缺失数据。您可以在移除 `NA` 值的情况下计算平均小鸡体重，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how `na.rm = TRUE` will remove all `NA` values for the purpose of computing
    an average with `mean`. Per the documentation, `na.rm` can be set as `TRUE` or
    `FALSE`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`na.rm = TRUE` 将在计算平均值时移除所有 `NA` 值。根据文档，`na.rm` 可以设置为 `TRUE` 或 `FALSE`。
- en: 'Now, let’s figure out how the food each chick eats impacts their weight:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们找出每只小鸡吃的食物如何影响它们的体重：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that a subset of the `chicks` data frame is created by explicitly specifying
    the appropriate indexes.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，通过明确指定适当的索引，创建了一个 `chicks` 数据框的子集。
- en: This is not an efficient way of programming, since we shouldn’t expect our data
    to never change. How can we modify our code so that it is more flexible? We can
    use logical expressions to dynamically subset a data frame.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不是一种高效的编程方式，因为我们不应该期望我们的数据永远不会改变。我们如何修改代码使其更加灵活？我们可以使用逻辑表达式来动态地子集化数据框。
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how the logical expression identifies whether each value in the feed
    column is equal to “casein.”
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，逻辑表达式识别饲料列中的每个值是否等于“casein”。
- en: 'We can leverage this logical expression within our code as follows:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在代码中利用这个逻辑表达式如下：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As demonstrated earlier in the lecture, notice how a logical vector called `filter`
    is created. Then, only those rows that are `TRUE` in `filter` are brought into
    the data frame `casein_chicks`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如讲座中先前所示，注意如何创建一个名为 `filter` 的逻辑向量。然后，只有 `filter` 中为 `TRUE` 的行被带入数据框 `casein_chicks`。
- en: We now have a subset of our data frame.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们有了数据框的一个子集。
- en: 'You can accomplish the same result by using the function `subset`:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `subset` 函数达到相同的结果：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This data frame, called `casein_chicks`, is created with the `subset` function.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个数据框，称为 `casein_chicks`，是通过 `subset` 函数创建的。
- en: 'Now, one may wish to filter out all `NA` values at the start. Consider the
    following code:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，有人可能希望在开始时过滤掉所有 `NA` 值。考虑以下代码：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how this code will use `is.na` to find `NA` values.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码将使用 `is.na` 来查找 `NA` 值。
- en: 'Records can be entirely removed, leveraging `is.na` as follows:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用 `is.na` 来完全删除记录，如下所示：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how this code creates a subset of `chicks` where `is.na(weight)` is equal
    to `FALSE`. That is, `chicks` only includes rows where `NA` is not present in
    the `weight` column. If you care about your data frame’s row names, though, be
    aware that—when you removed certain rows—you also removed those rows’ corresponding
    `rownames`. You can ensure the names of your rows still ascend sequentially by
    running `rownames(chicks) <- NULL`, which resets the names of all of your rows.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码创建了一个 `chicks` 的子集，其中 `is.na(weight)` 等于 `FALSE`。也就是说，`chicks` 只包括 `weight`
    列中没有 `NA` 的行。如果您关心数据框的行名，请注意，当您移除某些行时，您也移除了那些行的 `rownames`。您可以通过运行 `rownames(chicks)
    <- NULL` 来确保您的行名仍然按顺序递增，这将重置所有行的名称。
- en: Menus
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菜单
- en: In R, you can present users with options. For example, you can offer the user
    the type of feed they wish to filter for the chicks.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 R 中，您可以向用户提供选项。例如，您可以提供用户希望过滤的小鸡的饲料类型。
- en: 'Consider this code:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how this code uses `unique` to discover the individual unique feed options.
    Each of these feed options is then outputted with `cat`.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码使用 `unique` 来发现独特的饲料选项。然后，使用 `cat` 输出每个饲料选项。
- en: This code works in the sense that it shows the various options of feed, but
    it’s not very well formatted. How can we output the different options on their
    own line in the R console?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码在意义上是有效的，因为它显示了各种饲料选项，但它格式不是很好。我们如何在 R 控制台中使不同的选项各自占一行？
- en: Escape Characters
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义字符
- en: '*Escape characters* are characters whose output differs from the way you type
    them.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转义字符* 是输出方式与输入方式不同的字符。'
- en: For instance, some commonly used escape characters are `\n`, which prints a
    new line, or `\t`, which prints a tab.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一些常用的转义字符是 `\n`，它打印一个新行，或者 `\t`，它打印一个制表符。
- en: 'Leveraging escape characters, we can modify our code as follows:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用转义字符，我们可以修改代码如下：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how this outputs all the options of feed on individual lines.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码输出了所有饲料选项，每个选项都在单独的一行上。
- en: 'While we have the right sort of menu being displayed, we can still improve
    our code from a design perspective. For example, why should we repeat all of these
    `cat` lines? Simplify your code as follows:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们有正确的菜单显示时，我们仍然可以从设计角度改进我们的代码。例如，为什么我们应该重复所有这些`cat`行？如下简化你的代码：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how `formatted_options` includes all the individual feed options. Each
    element of this vector of `formatted_options` is printed and separated by a new
    line using `cat(formatted_options, sep = "\n")`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`formatted_options`包括所有单个饲料选项。`formatted_options`向量的每个元素都通过`cat(formatted_options,
    sep = "\n")`打印出来，并且每个元素之间用换行符分隔。
- en: 'Now, as we indicated earlier, our intention is to create an interactive program.
    Thus, we can now prompt the user with options:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经指出，我们的意图是创建一个交互式程序。因此，我们现在可以提示用户选择：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how the user is prompted with `Feed type:` , where a number can be converted
    to the text-based representation of the feed option. Then, the `feed_choice` they
    selected is assigned to `selected_feed`. Finally, the subset corresponding to
    the `selected_feed` is outputted to the user.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到用户被提示输入`Feed type:`，其中数字可以转换为基于文本的饲料选项表示。然后，用户选择的`feed_choice`被分配给`selected_feed`。最后，与`selected_feed`对应的子集被输出给用户。
- en: However, you can imagine how your user may not behave as expected. For example,
    if the user inputted `0`, which is not a potential choice, the output of our program
    will be strange. How can we ensure our user inputs the right text?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，你可以想象用户可能不会按预期行为。例如，如果用户输入了`0`，这不是一个潜在的选择，那么我们程序的输出将会奇怪。我们如何确保用户输入正确的文本？
- en: Conditionals
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: '*Conditionals* are ways to determine `if` a condition has been met.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件语句*是确定条件是否满足的方法。'
- en: 'Consider the following code:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice how `if (feed_choice < 1 || feed_choice > length(feed_options))` determines
    if the user’s input falls outside a range of values. If so, the program displays
    “Invalid choice.” However, there’s still a problem: the program will continue
    to run, even with that invalid choice.'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`if (feed_choice < 1 || feed_choice > length(feed_options))`是如何确定用户的输入是否超出值范围的。如果是这样，程序将显示“无效选择。”然而，仍然存在问题：即使有无效选择，程序也会继续运行。
- en: '`if` and `else` can be leveraged as follows to only run the final calculation
    if the user inputs a valid choice:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以如下利用`if`和`else`来仅当用户输入有效选择时才运行最终计算：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice, that code which is wrapped in `if` runs only if there is an invalid
    choice. That code which is wrapped in `else` will run only if the previous condition
    in `if` was not met.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，被`if`包裹的代码仅在存在无效选择时运行。被`else`包裹的代码仅在`if`中的先前条件未满足时运行。
- en: Combining Data Sources
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合数据来源
- en: As a final matter of this lecture, let’s examine how to combine sources of data.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为本讲座的最后一件事，让我们看看如何结合数据来源。
- en: Imagine a table that represents sales to customers, like Amazon might have.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一个表示销售给客户的表，比如亚马逊可能有的那种。
- en: You can imagine scenarios where that data is spread across many tables. How
    can these data be combined from many sources?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象数据分布在许多表中的场景。如何将这些数据从多个来源组合起来？
- en: 'Consider the following code called `sales.R`:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下名为`sales.R`的代码：
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how each quarter of financial data, such as `Q1` and `Q2`, is read into
    their own data frames.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到每个财务数据季度，例如`Q1`和`Q2`，都被读入它们自己的数据框中。
- en: 'Now, let’s combine this data from these four data frames:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们将这四个数据框中的数据结合起来：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that `rbind` is used to gather together the data from each of these data
    frames.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`rbind`被用来收集来自每个这些数据框的数据。
- en: It’s worth mentioning that `rbind` is usable in this case because all four data
    frames are structured the same way.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，`rbind`在这种情况下是可用的，因为所有四个数据框的结构都是相同的。
- en: The result of the previously run program is that `sales` includes each row from
    each data frame. Instead of showing `Q1`, `Q2`, etc. for each customer, it simply
    creates new rows for each line of data at the bottom of the file. Hence, the file
    becomes longer and longer as more and more data is combined into it. It’s entirely
    unclear in what quarter each sales value occurred.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个程序运行的结果是`sales`包括了每个数据框中的每一行。而不是为每个客户显示`Q1`、`Q2`等，它只是在文件的底部为每行数据创建新的行。因此，随着越来越多的数据被组合到文件中，文件变得越来越长。每个销售值发生的季度完全不清楚。
- en: 'Our code can be improved such that a column for the financial quarter is created
    for each record as follows:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码可以改进，为每条记录创建一个财务季度的列，如下所示：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how each quarter is added to a specific `quarter` column. Thus, when
    `rbind` combines the data frames into `sales` with the sales organized by `quarter`
    columns.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意每个季度是如何添加到特定的`季度`列中的。因此，当`rbind`将数据框组合到按`季度`列组织的`sales`中时。
- en: 'As a final flourish, let’s add a `value` column where high returns and regular
    returns are noted:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后的点缀，让我们添加一个`value`列，其中记录高回报和常规回报：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how the final line of code assigns “High Value” when the `sale_amount`
    is greater than `100`. Otherwise, the transaction is assigned “Regular.”
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意最后一行代码在`sale_amount`大于`100`时分配“高价值”。否则，交易被分配为“常规”。
- en: Summing Up
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, you learned how to transform data in R. Specifically, you learned…
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何在R中转换数据。具体来说，你学习了...
- en: Outliers
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常值
- en: Logical Expressions
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑表达式
- en: Subsets
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子集
- en: Menus
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单
- en: Escape Characters
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义字符
- en: Conditionals
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: Combining Data Sources
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并数据源
- en: See you next time when we discuss how to write functions of our own.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 次次见，当我们讨论如何编写我们自己的函数时。
