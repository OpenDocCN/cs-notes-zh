- en: Lecture 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座 3
- en: 原文：[https://cs50.harvard.edu/x/notes/3/](https://cs50.harvard.edu/x/notes/3/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/x/notes/3/](https://cs50.harvard.edu/x/notes/3/)
- en: '[Welcome!](#welcome)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欢迎光临！](#welcome)'
- en: '[Linear Search](#linear-search)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线性查找](#linear-search)'
- en: '[Binary Search](#binary-search)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[二分查找](#binary-search)'
- en: '[Running Time](#running-time)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[运行时间](#running-time)'
- en: '[search.c](#searchc)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[search.c](#searchc)'
- en: '[phonebook.c](#phonebookc)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[phonebook.c](#phonebookc)'
- en: '[Structs](#structs)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结构体](#structs)'
- en: '[Sorting](#sorting)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[排序](#sorting)'
- en: '[Bubble Sort](#bubble-sort)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[冒泡排序](#bubble-sort)'
- en: '[Recursion](#recursion)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归](#recursion)'
- en: '[Merge Sort](#merge-sort)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[归并排序](#merge-sort)'
- en: '[Summing Up](#summing-up)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Welcome!
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎光临！
- en: 'In week zero, we introduced the idea of an *algorithm*: a black box that may
    take an input and create an output.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第零周，我们介绍了算法的概念：一个可能接受输入并产生输出的黑盒。
- en: This week, we are going to expand upon our understanding of algorithms through
    pseudocode and into code itself.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本周，我们将通过伪代码和实际代码来扩展我们对算法的理解。
- en: Also, we are going to consider the efficiency of these algorithms. Indeed, we
    are going to be building upon our understanding of how to use some of the concepts
    we discussed last week in building algorithms.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还将考虑这些算法的效率。实际上，我们将基于我们对如何使用上周讨论的一些概念来构建算法的理解。
- en: 'Recall back to earlier in the course when we introduced the following graph:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下课程早期我们介绍过的以下图表：
- en: '![chart with: "size of problem" as x-axis; "time to solve" as y-axis; red,
    steep straight line from origin to top of graph close to yellow, less-steep straight
    line from origin to top of graph, both labeled "n"; green, curved line that gets
    less and less steep from origin to right of graph, labeled "log n"](../Images/91b187ab9ac5c9b5e418c259541bb522.png
    "complexity")'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图表：以“问题规模”为x轴；“解决问题所需时间”为y轴；红色，从原点到图表顶部的陡峭直线接近黄色，从原点到图表顶部的较平缓直线，两者均标记为“n”；绿色，从原点到图表右侧逐渐变平缓的曲线，标记为“log
    n”](../Images/91b187ab9ac5c9b5e418c259541bb522.png "complexity")'
- en: As we step into this week, you should consider how the way an algorithm works
    with a problem may determine the time it takes to solve a problem! Algorithms
    can be designed to be more and more efficient to a limit.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们步入本周，你应该考虑一个算法如何与问题协同工作可能会决定解决问题所需的时间！算法可以被设计得越来越高效，直至极限。
- en: Today, we will focus on the design of algorithms and how to measure their efficiency.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将关注算法的设计以及如何衡量它们的效率。
- en: Linear Search
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性查找
- en: 'Recall that last week, you were introduced to the idea of an *array*, blocks
    of memory that are consecutive: side-by-side with one another.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，上周你被介绍到数组的概念，即连续的内存块：彼此并排。
- en: 'You can metaphorically imagine an array like a series of seven red lockers
    as follows:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以比喻性地想象一个数组就像一系列七个红锁，如下所示：
- en: '![Seven red lockers side by side](../Images/815e525a92fff9f7a147a2afc5ed26dc.png
    "lockers")'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![七排并排的红锁](../Images/815e525a92fff9f7a147a2afc5ed26dc.png "lockers")'
- en: The far-left position is called *location 0* or *the beginning of the array*.
    The far-right position is *location 6* or *the end of the array*.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最左侧的位置称为*位置0*或*数组的开始*。最右侧的位置是*位置6*或*数组的结束*。
- en: We can imagine that we have an essential problem of wanting to know, “Is the
    number 50 inside an array?” A computer must look at each locker to be able to
    see if the number 50 is inside. We call this process of finding such a number,
    character, string, or other item *searching*.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以想象，我们有一个基本问题，即想知道，“数字50是否在数组中？”计算机必须查看每个锁，以便能够看到数字50是否在里面。我们将寻找此类数字、字符、字符串或其他项的过程称为*搜索*。
- en: We can potentially hand our array to an algorithm, wherein our algorithm will
    search through our lockers to see if the number 50 is behind one of the doors,
    returning the value `true` or `false`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将我们的数组交给一个算法，然后我们的算法将搜索我们的锁，看看数字50是否在某个门后面，返回值`true`或`false`。
- en: '![seven red lockers pointing to an empty box. Out of the empty box comes an
    output of bool](../Images/9a363a90741675f20dd179ba44d00afa.png "lockers as algorithm")'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![七个红锁指向一个空盒子。从空盒子中出来一个bool类型的输出](../Images/9a363a90741675f20dd179ba44d00afa.png
    "lockers as algorithm")'
- en: 'We can imagine various instructions we might provide our algorithm to undertake
    this task as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以想象我们可能提供给算法的各种指令以执行此任务，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that the above instructions are called *pseudocode*: A human-readable
    version of the instructions that we could provide the computer.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，上述指令被称为*伪代码*：我们可以提供给计算机的指令的人类可读版本。
- en: 'A computer scientist could translate that pseudocode as follows:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学家可以将伪代码翻译如下：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the above is still not code, but it is a pretty close approximation
    of what the final code might look like.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，上面的内容仍然不是代码，但它是对最终代码可能的样子一个非常接近的近似。
- en: Binary Search
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分搜索
- en: '*Binary search* is another *search algorithm* that could be employed in our
    task of finding the 50.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二分搜索*是另一种可以用于我们寻找50的任务中的*搜索算法*。'
- en: 'Assuming that the values within the lockers have been arranged from smallest
    to largest, the pseudocode for binary search would appear as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设锁内的值已经从小到大排列，二分搜索的伪代码如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using the nomenclature of code, we can further modify our algorithm as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码的命名法，我们可以进一步修改我们的算法如下：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that by looking at this approximation of code, you can nearly imagine
    what this might look like in actual code.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，通过查看这个代码的近似，你几乎可以想象出这在实际代码中可能的样子。
- en: Running Time
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时间
- en: You can consider how much time it takes an algorithm to solve a problem.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以考虑算法解决问题所需的时间。
- en: '*running time* involves an analysis using *big O* notation. Take a look at
    the following graph:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时间*涉及到使用*大O*符号的分析。看看下面的图表：'
- en: '![chart with: "size of problem" as x-axis; "time to solve" as y-axis; red,
    steep straight line from origin to top of graph close to yellow, less-steep straight
    line from origin to top of graph, both labeled "O(n)"; green, curved line that
    gets less and less steep from origin to right of graph, labeled "O(log n"](../Images/922ca8cfdf06b9b78ed08397d7241a90.png
    "big o graphed")'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图表：以“问题规模”为x轴；“解决问题所需时间”为y轴；红色，从原点到图表顶部的陡峭直线接近黄色，从原点到图表顶部的较平缓直线；绿色，从原点到图表右侧逐渐变平缓的曲线，均标注为“O(n)”；绿色，从原点到图表右侧逐渐变平缓的曲线，标注为“O(log
    n"](../Images/922ca8cfdf06b9b78ed08397d7241a90.png "大O图表")'
- en: Rather than being ultra-specific about the mathematical efficiency of an algorithm,
    computer scientists discuss efficiency in terms of *the order of* various running
    times.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学家在讨论算法的效率时，不是对算法的数学效率进行超具体分析，而是用各种运行时间的*顺序*来讨论效率。
- en: In the above graph, the first algorithm is \(O(n)\) or *in the order of n*.
    The second is in \(O(n)\) as well. The third is in \(O(\log n)\).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的图表中，第一个算法是 \(O(n)\) 或 *n的阶数*。第二个也是 \(O(n)\)。第三个是 \(O(\log n)\)。
- en: 'It’s the shape of the curve that shows the efficiency of an algorithm. Some
    common running times we may see are:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是曲线的形状，显示了算法的效率。我们可能会看到一些常见的运行时间：
- en: \(O(n^2)\)
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(O(n^2)\)
- en: \(O(n \log n)\)
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(O(n \log n)\)
- en: \(O(n)\)
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(O(n)\)
- en: \(O(\log n)\)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(O(\log n)\)
- en: \(O(1)\)
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(O(1)\)
- en: Of the running times above, \(O(n^2)\) is considered the slowest running time.
    \(O(1)\) is the fastest.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上述运行时间中，\(O(n^2)\)被认为是运行时间最慢的。\(O(1)\)是最快的。
- en: Linear search was of order \(O(n)\) because it could take *n* steps in the worst-case
    to run.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索的阶数为 \(O(n)\)，因为它在最坏情况下可能需要 *n* 步才能运行。
- en: Binary search was of order \(O(\log n)\) because it would take fewer and fewer
    steps to run, even in the worst-case.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索的阶数为 \(O(\log n)\)，因为它在运行时将越来越少，即使在最坏情况下也是如此。
- en: Programmers are interested in both the worst-case, or *upper bound*, and the
    best-case, or *lower bound*.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员对最坏情况，或*上界*，和最佳情况，或*下界*都感兴趣。
- en: The \(\Omega\) symbol is used to denote the best-case of an algorithm, such
    as \(\Omega(\log n)\).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\Omega\) 符号用来表示算法的最佳情况，例如 \(\Omega(\log n)\)。
- en: 'The \(\Theta\) symbol is used to denote where the upper bound and lower bound
    are the same: Where the best-case and the worst-case running times are the same.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\Theta\) 符号用来表示上界和下界相同的地方：最佳情况和最坏情况的运行时间相同的地方。
- en: '*Asymptotic notation* is the measure of how well algorithms perform as the
    input gets larger and larger.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渐近符号*是用来衡量算法在输入越来越大时表现如何的度量。'
- en: As you continue to develop your knowledge in computer science, you will explore
    these topics in more detail in future courses.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着你继续在计算机科学领域发展你的知识，你将在未来的课程中更详细地探索这些主题。
- en: search.c
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: search.c
- en: 'You can implement linear search by typing `code search.c` in your terminal
    window and by writing code as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在终端窗口中输入`code search.c`并编写如下代码来实现线性搜索：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the line beginning with `int numbers[]` allows us to define the
    values of each element of the array as we create it. Then, in the `for` loop,
    we have an implementation of linear search. `return 0` is used to indicate success
    and exit the program. `return 1` is used to exit the program with an error (failure).
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，以`int numbers[]`开头的行允许我们在创建数组时定义每个元素的值。然后，在`for`循环中，我们有线性搜索的实现。`return 0`用于指示成功并退出程序。`return
    1`用于带错误（失败）退出程序。
- en: We have now implemented linear search ourselves in C!
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在已经在C中自己实现了线性搜索！
- en: 'What if we wanted to search for a string within an array? Modify your code
    as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在数组中搜索一个字符串呢？修改你的代码如下：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that we cannot utilize `==` as in our previous iteration of this program.
    Instead, we use `strcmp`, which comes from the `string.h` library. `strcmp` will
    return `0` if the strings are the same. Also, notice that the string length of
    `6` is hard-coded, which is not good programming practice.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们无法像之前这个程序的迭代版本中那样使用`==`。相反，我们使用`strcmp`，它来自`string.h`库。如果字符串相同，`strcmp`将返回`0`。另外，请注意，字符串长度`6`是硬编码的，这不是好的编程实践。
- en: Indeed, running this code allows us to iterate over this array of strings to
    see if a certain string is within it. However, if you see a *segmentation fault*,
    where a part of memory was touched by your program that it should not have access
    to, do make sure you have `i < 6` noted above instead of `i < 7`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实上，运行这段代码允许我们遍历这个字符串数组，查看是否包含某个特定的字符串。然而，如果你看到*段错误*，即程序访问了它不应访问的内存部分，请确保你有`i
    < 6`而不是`i < 7`。
- en: You can learn more about `strcmp` at the [CS50 Manual Pages](https://manual.cs50.io/3/strcmp).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[CS50手册页面](https://manual.cs50.io/3/strcmp)上了解更多关于`strcmp`的信息。
- en: phonebook.c
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: phonebook.c
- en: 'We can combine these ideas of both numbers and strings into a single program.
    Type `code phonebook.c` into your terminal window and write code as follows:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将数字和字符串的这些想法结合到一个程序中。在终端窗口中输入`code phonebook.c`并编写如下代码：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that Yuliia’s number begins with `+1-617`, David’s phone number starts
    with `+1-617`, and John’s number starts with `+1-949`. Therefore, `names[0]` is
    Yuliia, and `numbers[0]` is Yuliia’s number. This code will allow us to search
    the phonebook for a person’s specific number.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，Yuliia的电话号码以`+1-617`开头，David的电话号码以`+1-617`开头，John的电话号码以`+1-949`开头。因此，`names[0]`是Yuliia，`numbers[0]`是Yuliia的电话号码。这段代码将允许我们在电话簿中搜索特定号码的人。
- en: While this code works, there are numerous inefficiencies. Indeed, there is a
    chance that names and phone numbers may not correspond to one another. Wouldn’t
    it be nice if we could create our own data type where we could associate a person
    with the phone number?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这段代码能工作，但存在许多低效之处。实际上，存在一种可能性，即姓名和电话号码可能不匹配。如果我们可以创建自己的数据类型，将一个人与电话号码关联起来，那岂不是很好？
- en: Structs
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: It turns out that C allows us to create our own data types via a `struct`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，C语言允许我们通过`struct`创建自己的数据类型。
- en: 'Would it not be useful to create our own data type called a `person` that has
    inside of it a `name` and `number`? Consider the following:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含`name`和`number`的名为`person`的自定义数据类型不是很有用吗？考虑以下内容：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how this represents our own datatype called a `person` that has a string
    called `name` and another string called `number`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这代表了我们自己的数据类型`person`，它有一个名为`name`的字符串和一个名为`number`的字符串。
- en: 'We can improve our prior code by modifying our phonebook program as follows:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过修改我们的电话簿程序来改进我们之前的代码：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the code begins with `typedef struct` where a new datatype called
    `person` is defined. Inside a `person` is a string called `name` and a `string`
    called number. In the `main` function, begin by creating an array called `people`
    that is of type `person` that is a size of 3\. Then, we update the names and phone
    numbers of the two people in our `people` array. Most importantly, notice how
    the *dot notation*, such as `people[0].name`, allows us to access the `person`
    at the 0th location and assign that individual a name.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，代码以`typedef struct`开始，其中定义了一个新的数据类型`person`。在`person`内部有一个名为`name`的字符串和一个名为`number`的字符串。在`main`函数中，首先创建一个名为`people`的数组，其类型为`person`，大小为3。然后，我们更新`people`数组中两个人的姓名和电话号码。最重要的是，注意如何使用*点表示法*，例如`people[0].name`，允许我们访问第0个位置的`person`并为其分配一个姓名。
- en: Sorting
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: '*Sorting* is the act of taking an unsorted list of values and transforming
    this list into a sorted one.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序*是将未排序的值列表转换为排序列表的行为。'
- en: When a list is sorted, searching that list is far less taxing on the computer.
    Recall that we can use binary search on a sorted list but not on an unsorted one.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个列表排序后，在该列表中搜索要远比在未排序的列表中搜索要耗费计算机更少的资源。回想一下，我们可以在有序列表上使用二分搜索，但不能在未排序的列表上使用。
- en: It turns out that there are many different types of sorting algorithms.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，有许多不同的排序算法。
- en: '*Selection sort* is one such sorting algorithm.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择排序* 是这样的排序算法之一。'
- en: 'We can represent an array as follows:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以这样表示一个数组：
- en: '![Seven red lockers side by side with the last labeled as n-1](../Images/06647a4b0f54933fc3052334bfd7dea6.png
    "red lockers")'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![七个并排的红锁，最后一个标记为n-1](../Images/06647a4b0f54933fc3052334bfd7dea6.png "red lockers")'
- en: 'The algorithm for selection sort in pseudocode is:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序的伪代码如下：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Summarizing those steps, the first time iterating through the list took `n
    - 1` steps. The second time, it took `n - 2` steps. Carrying this logic forward,
    the steps required could be represented as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结这些步骤，第一次遍历列表需要 `n - 1` 步。第二次，它需要 `n - 2` 步。继续这个逻辑，所需的步骤可以表示如下：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This could be simplified to n(n-1)/2 or, more simply, \(O(n^2)\). In the worst-case
    or upper-bound, selection sort is in the order of \(O(n^2)\). In the best-case,
    or lower-bound, selection sort is in the order of \(\Omega(n^2)\).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以简化为 n(n-1)/2 或更简单地说，\(O(n^2)\)。在最坏情况或上界，选择排序的顺序为 \(O(n^2)\)。在最好情况或下界，选择排序的顺序为
    \(\Omega(n^2)\)。
- en: Bubble Sort
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: '*Bubble sort* is another sorting algorithm that works by repeatedly swapping
    elements to “bubble” larger elements to the end.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冒泡排序* 是另一种排序算法，它通过重复交换元素来“冒泡”较大的元素到末尾。'
- en: 'The pseudocode for bubble sort is:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序的伪代码如下：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we further sort the array, we know more and more of it becomes sorted, so
    we only need to look at the pairs of numbers that haven’t been sorted yet.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们进一步排序数组，我们知道越来越多的部分变得有序，所以我们只需要查看尚未排序的数字对。
- en: 'Bubble sort can be analyzed as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序可以分析如下：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: or, more simply \(O(n^2)\).
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，更简单地说 \(O(n^2)\)。
- en: In the worst-case, or upper-bound, bubble sort is in the order of \(O(n^2)\).
    In the best-case, or lower-bound, bubble sort is in the order of \(\Omega(n)\).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最坏情况下，或上界，冒泡排序的顺序为 \(O(n^2)\)。在最好情况下，或下界，冒泡排序的顺序为 \(\Omega(n)\)。
- en: You can [visualize](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)
    a comparison of these algorithms.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以 [可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)
    这些算法的比较。
- en: Recursion
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: How could we improve our efficiency in our sorting?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何提高我们的排序效率？
- en: '*Recursion* is a concept within programming where a function calls itself.
    We saw this earlier when we saw…'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递归* 是编程中的一个概念，其中函数调用自身。我们之前在看到……时看到了这一点。'
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we are calling `search` on smaller and smaller iterations of this
    problem.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在对这个问题越来越小的迭代调用 `search`。
- en: 'Similarly, in our pseudocode for Week 0, you can see where recursion was implemented:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，在我们的第0周伪代码中，您可以看到递归是如何实现的：
- en: '[PRE14]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code could have been simplified to highlight its recursive properties
    as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码可以简化以突出其递归特性，如下所示：
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Consider how in Week 1 we wanted to create a pyramid structure as follows:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一下在第一周我们想要创建以下这样的金字塔结构：
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Type `code iteration.c` into your terminal window and write code as follows:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的终端窗口中输入 `code iteration.c` 并编写如下代码：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that this code builds the pyramid by looping.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，此代码通过循环构建金字塔。
- en: 'To implement this using recursion, type `code iteration.c` into your terminal
    window and write code as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用递归实现此功能，请在您的终端窗口中输入 `code iteration.c` 并编写如下代码：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the *base case* will ensure the code does not run forever. The line `if
    (n <= 0)` terminates the recursion because the problem has been solved. Every
    time, `draw` calls itself, it calls itself by `n-1`. At some point, `n-1` will
    equal `0`, resulting in the `draw` function returning, and the program will end.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 *基准情况* 将确保代码不会无限运行。当 `if (n <= 0)` 时终止递归，因为问题已经解决。每次 `draw` 函数调用自身时，它都会通过
    `n-1` 来调用自身。在某一点上，`n-1` 将等于 `0`，导致 `draw` 函数返回，程序结束。
- en: Merge Sort
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序
- en: We can now leverage recursion in our quest for a more efficient sort algorithm
    and implement what is called *merge sort*, a very efficient sort algorithm.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以利用递归来寻求更有效的排序算法，并实现所谓的 *归并排序*，这是一种非常有效的排序算法。
- en: 'The pseudocode for merge sort is quite short:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序的伪代码相当简短：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Consider the following list of the numbers:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下数字列表：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, merge sort asks, “is this one number?” The answer is “no,” so the algorithm
    continues.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，归并排序会问，“这是一个数字吗？”答案是“不是”，所以算法继续。
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Second, merge sort will now split the numbers down the middle (or as close as
    it can get) and sort the left half of numbers.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，归并排序现在将数字从中间分开（或者尽可能接近中间）并排序数字的左半部分。
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Third, merge sort would look at these numbers on the left and ask, “is this
    one number?” Since the answer is no, it would then split the numbers on the left
    down the middle.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，归并排序将查看左边的这些数字并询问，“这是一个数字吗？”由于答案是“不是”，然后它会将左边的数字从中间分开。
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Fourth, merge sort will again ask, “is this one number?” The answer is yes
    this time! Therefore, it will quit this task and return to the last task it was
    running at this point:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，归并排序将再次询问，“这是一个数字吗？”这次答案是肯定的！因此，它将退出这个任务，并返回到此时正在运行的最后任务：
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Fifth, merge sort will sort the numbers on the left.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五，归并排序将排序左边的数字。
- en: '[PRE25]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we return to where we left off in the pseudocode now that the left side
    has been sorted. A similar process of steps 3-5 will occur with the right-hand
    numbers. This will result in:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们回到伪代码中我们之前中断的地方，因为左边的数字已经排序了。步骤3-5的类似过程将发生在右边的数字上。这将导致：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Both halves are now sorted. Finally, the algorithm will merge both sides. It
    will look at the first number on the left and the first number on the right. It
    will put the smaller number first, then the second smallest. The algorithm will
    repeat this for all numbers, resulting in:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个半部分现在都已排序。最后，算法将合并两边。它会查看左边的第一个数字和右边的第一个数字。它会将较小的数字放在前面，然后是第二小的数字。算法将对所有数字重复此操作，结果如下：
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Merge sort is complete, and the program quits.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序已完成，程序退出。
- en: Merge sort is a very efficient sort algorithm with a worst-case of \(O(n \log
    n)\). The best-case is still \(\Omega(n \log n)\) because the algorithm still
    must visit each place in the list. Therefore, merge sort is also \(\Theta(n \log
    n)\) since the best-case and worst-case are the same.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序是一个非常高效的排序算法，最坏情况下的时间复杂度为 \(O(n \log n)\)。最佳情况仍然是 \(\Omega(n \log n)\)，因为算法仍然必须访问列表中的每个位置。因此，归并排序的时间复杂度也是
    \(\Theta(n \log n)\)，因为最佳情况和最坏情况是相同的。
- en: A final [visualization](https://www.youtube.com/watch?v=ZZuD6iUe3Pc) was shared.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[可视化](https://www.youtube.com/watch?v=ZZuD6iUe3Pc)被分享。
- en: Summing Up
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, you learned about algorithmic thinking and building your own
    data types. Specifically, you learned…
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了算法思维和构建自己的数据类型。具体来说，你学习了…
- en: Algorithms.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法。
- en: Big *O* notation.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O表示法。
- en: Binary search and linear search.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分查找和线性查找。
- en: Various sort algorithms, including bubble sort, selection sort, and merge sort.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种排序算法，包括冒泡排序、选择排序和归并排序。
- en: Recursion.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归。
- en: See you next time!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎下次再来！
