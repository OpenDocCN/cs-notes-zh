- en: Lecture 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/x/notes/3/](https://cs50.harvard.edu/x/notes/3/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linear Search](#linear-search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Binary Search](#binary-search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Running Time](#running-time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[search.c](#searchc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[phonebook.c](#phonebookc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Structs](#structs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sorting](#sorting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bubble Sort](#bubble-sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recursion](#recursion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Merge Sort](#merge-sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In week zero, we introduced the idea of an *algorithm*: a black box that may
    take an input and create an output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This week, we are going to expand upon our understanding of algorithms through
    pseudocode and into code itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we are going to consider the efficiency of these algorithms. Indeed, we
    are going to be building upon our understanding of how to use some of the concepts
    we discussed last week in building algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recall back to earlier in the course when we introduced the following graph:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![chart with: "size of problem" as x-axis; "time to solve" as y-axis; red,
    steep straight line from origin to top of graph close to yellow, less-steep straight
    line from origin to top of graph, both labeled "n"; green, curved line that gets
    less and less steep from origin to right of graph, labeled "log n"](../Images/91b187ab9ac5c9b5e418c259541bb522.png
    "complexity")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As we step into this week, you should consider how the way an algorithm works
    with a problem may determine the time it takes to solve a problem! Algorithms
    can be designed to be more and more efficient to a limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we will focus on the design of algorithms and how to measure their efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that last week, you were introduced to the idea of an *array*, blocks
    of memory that are consecutive: side-by-side with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can metaphorically imagine an array like a series of seven red lockers
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Seven red lockers side by side](../Images/815e525a92fff9f7a147a2afc5ed26dc.png
    "lockers")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The far-left position is called *location 0* or *the beginning of the array*.
    The far-right position is *location 6* or *the end of the array*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can imagine that we have an essential problem of wanting to know, “Is the
    number 50 inside an array?” A computer must look at each locker to be able to
    see if the number 50 is inside. We call this process of finding such a number,
    character, string, or other item *searching*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can potentially hand our array to an algorithm, wherein our algorithm will
    search through our lockers to see if the number 50 is behind one of the doors,
    returning the value `true` or `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![seven red lockers pointing to an empty box. Out of the empty box comes an
    output of bool](../Images/9a363a90741675f20dd179ba44d00afa.png "lockers as algorithm")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can imagine various instructions we might provide our algorithm to undertake
    this task as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the above instructions are called *pseudocode*: A human-readable
    version of the instructions that we could provide the computer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A computer scientist could translate that pseudocode as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the above is still not code, but it is a pretty close approximation
    of what the final code might look like.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Binary Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Binary search* is another *search algorithm* that could be employed in our
    task of finding the 50.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming that the values within the lockers have been arranged from smallest
    to largest, the pseudocode for binary search would appear as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the nomenclature of code, we can further modify our algorithm as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that by looking at this approximation of code, you can nearly imagine
    what this might look like in actual code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can consider how much time it takes an algorithm to solve a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*running time* involves an analysis using *big O* notation. Take a look at
    the following graph:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![chart with: "size of problem" as x-axis; "time to solve" as y-axis; red,
    steep straight line from origin to top of graph close to yellow, less-steep straight
    line from origin to top of graph, both labeled "O(n)"; green, curved line that
    gets less and less steep from origin to right of graph, labeled "O(log n"](../Images/922ca8cfdf06b9b78ed08397d7241a90.png
    "big o graphed")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Rather than being ultra-specific about the mathematical efficiency of an algorithm,
    computer scientists discuss efficiency in terms of *the order of* various running
    times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the above graph, the first algorithm is \(O(n)\) or *in the order of n*.
    The second is in \(O(n)\) as well. The third is in \(O(\log n)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s the shape of the curve that shows the efficiency of an algorithm. Some
    common running times we may see are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(O(n^2)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(O(n \log n)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(O(n)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(O(\log n)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(O(1)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the running times above, \(O(n^2)\) is considered the slowest running time.
    \(O(1)\) is the fastest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear search was of order \(O(n)\) because it could take *n* steps in the worst-case
    to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search was of order \(O(\log n)\) because it would take fewer and fewer
    steps to run, even in the worst-case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmers are interested in both the worst-case, or *upper bound*, and the
    best-case, or *lower bound*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The \(\Omega\) symbol is used to denote the best-case of an algorithm, such
    as \(\Omega(\log n)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The \(\Theta\) symbol is used to denote where the upper bound and lower bound
    are the same: Where the best-case and the worst-case running times are the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Asymptotic notation* is the measure of how well algorithms perform as the
    input gets larger and larger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you continue to develop your knowledge in computer science, you will explore
    these topics in more detail in future courses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: search.c
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can implement linear search by typing `code search.c` in your terminal
    window and by writing code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the line beginning with `int numbers[]` allows us to define the
    values of each element of the array as we create it. Then, in the `for` loop,
    we have an implementation of linear search. `return 0` is used to indicate success
    and exit the program. `return 1` is used to exit the program with an error (failure).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now implemented linear search ourselves in C!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if we wanted to search for a string within an array? Modify your code
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we cannot utilize `==` as in our previous iteration of this program.
    Instead, we use `strcmp`, which comes from the `string.h` library. `strcmp` will
    return `0` if the strings are the same. Also, notice that the string length of
    `6` is hard-coded, which is not good programming practice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indeed, running this code allows us to iterate over this array of strings to
    see if a certain string is within it. However, if you see a *segmentation fault*,
    where a part of memory was touched by your program that it should not have access
    to, do make sure you have `i < 6` noted above instead of `i < 7`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about `strcmp` at the [CS50 Manual Pages](https://manual.cs50.io/3/strcmp).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: phonebook.c
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can combine these ideas of both numbers and strings into a single program.
    Type `code phonebook.c` into your terminal window and write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that Yuliia’s number begins with `+1-617`, David’s phone number starts
    with `+1-617`, and John’s number starts with `+1-949`. Therefore, `names[0]` is
    Yuliia, and `numbers[0]` is Yuliia’s number. This code will allow us to search
    the phonebook for a person’s specific number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While this code works, there are numerous inefficiencies. Indeed, there is a
    chance that names and phone numbers may not correspond to one another. Wouldn’t
    it be nice if we could create our own data type where we could associate a person
    with the phone number?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that C allows us to create our own data types via a `struct`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Would it not be useful to create our own data type called a `person` that has
    inside of it a `name` and `number`? Consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this represents our own datatype called a `person` that has a string
    called `name` and another string called `number`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can improve our prior code by modifying our phonebook program as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the code begins with `typedef struct` where a new datatype called
    `person` is defined. Inside a `person` is a string called `name` and a `string`
    called number. In the `main` function, begin by creating an array called `people`
    that is of type `person` that is a size of 3\. Then, we update the names and phone
    numbers of the two people in our `people` array. Most importantly, notice how
    the *dot notation*, such as `people[0].name`, allows us to access the `person`
    at the 0th location and assign that individual a name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sorting* is the act of taking an unsorted list of values and transforming
    this list into a sorted one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a list is sorted, searching that list is far less taxing on the computer.
    Recall that we can use binary search on a sorted list but not on an unsorted one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It turns out that there are many different types of sorting algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Selection sort* is one such sorting algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can represent an array as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Seven red lockers side by side with the last labeled as n-1](../Images/06647a4b0f54933fc3052334bfd7dea6.png
    "red lockers")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The algorithm for selection sort in pseudocode is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Summarizing those steps, the first time iterating through the list took `n
    - 1` steps. The second time, it took `n - 2` steps. Carrying this logic forward,
    the steps required could be represented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This could be simplified to n(n-1)/2 or, more simply, \(O(n^2)\). In the worst-case
    or upper-bound, selection sort is in the order of \(O(n^2)\). In the best-case,
    or lower-bound, selection sort is in the order of \(\Omega(n^2)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bubble sort* is another sorting algorithm that works by repeatedly swapping
    elements to “bubble” larger elements to the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pseudocode for bubble sort is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we further sort the array, we know more and more of it becomes sorted, so
    we only need to look at the pairs of numbers that haven’t been sorted yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bubble sort can be analyzed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or, more simply \(O(n^2)\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the worst-case, or upper-bound, bubble sort is in the order of \(O(n^2)\).
    In the best-case, or lower-bound, bubble sort is in the order of \(\Omega(n)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can [visualize](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)
    a comparison of these algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How could we improve our efficiency in our sorting?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recursion* is a concept within programming where a function calls itself.
    We saw this earlier when we saw…'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are calling `search` on smaller and smaller iterations of this
    problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, in our pseudocode for Week 0, you can see where recursion was implemented:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code could have been simplified to highlight its recursive properties
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Consider how in Week 1 we wanted to create a pyramid structure as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type `code iteration.c` into your terminal window and write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code builds the pyramid by looping.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To implement this using recursion, type `code iteration.c` into your terminal
    window and write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the *base case* will ensure the code does not run forever. The line `if
    (n <= 0)` terminates the recursion because the problem has been solved. Every
    time, `draw` calls itself, it calls itself by `n-1`. At some point, `n-1` will
    equal `0`, resulting in the `draw` function returning, and the program will end.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now leverage recursion in our quest for a more efficient sort algorithm
    and implement what is called *merge sort*, a very efficient sort algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pseudocode for merge sort is quite short:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Consider the following list of the numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, merge sort asks, “is this one number?” The answer is “no,” so the algorithm
    continues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Second, merge sort will now split the numbers down the middle (or as close as
    it can get) and sort the left half of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Third, merge sort would look at these numbers on the left and ask, “is this
    one number?” Since the answer is no, it would then split the numbers on the left
    down the middle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fourth, merge sort will again ask, “is this one number?” The answer is yes
    this time! Therefore, it will quit this task and return to the last task it was
    running at this point:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fifth, merge sort will sort the numbers on the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we return to where we left off in the pseudocode now that the left side
    has been sorted. A similar process of steps 3-5 will occur with the right-hand
    numbers. This will result in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both halves are now sorted. Finally, the algorithm will merge both sides. It
    will look at the first number on the left and the first number on the right. It
    will put the smaller number first, then the second smallest. The algorithm will
    repeat this for all numbers, resulting in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Merge sort is complete, and the program quits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge sort is a very efficient sort algorithm with a worst-case of \(O(n \log
    n)\). The best-case is still \(\Omega(n \log n)\) because the algorithm still
    must visit each place in the list. Therefore, merge sort is also \(\Theta(n \log
    n)\) since the best-case and worst-case are the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A final [visualization](https://www.youtube.com/watch?v=ZZuD6iUe3Pc) was shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, you learned about algorithmic thinking and building your own
    data types. Specifically, you learned…
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big *O* notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search and linear search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various sort algorithms, including bubble sort, selection sort, and merge sort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time!
  prefs: []
  type: TYPE_NORMAL
