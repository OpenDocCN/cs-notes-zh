- en: Lecture 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座 1
- en: 原文：[https://cs50.harvard.edu/ai/notes/1/](https://cs50.harvard.edu/ai/notes/1/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/ai/notes/1/](https://cs50.harvard.edu/ai/notes/1/)
- en: Knowledge
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知识
- en: Humans reason based on existing knowledge and draw conclusions. The concept
    of representing knowledge and drawing conclusions from it is also used in AI,
    and in this lecture we will explore how we can achieve this behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人类基于现有知识进行推理并得出结论。从知识中表示和推理出结论的概念也用于人工智能，在本讲座中，我们将探讨我们如何实现这种行为。
- en: '**Knowledge-Based Agents**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于知识的智能体**'
- en: These are agents that reason by operating on internal representations of knowledge.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是通过操作知识内部表示来进行推理的智能体。
- en: What does “reasoning based on knowledge to draw a conclusion” mean?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “基于知识进行推理得出结论”是什么意思？
- en: 'Let’s start answering this with a Harry Potter example. Consider the following
    sentences:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从哈利·波特的例子开始回答这个问题。考虑以下句子：
- en: If it didn’t rain, Harry visited Hagrid today.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果今天没有下雨，哈利今天拜访了海格。
- en: Harry visited Hagrid or Dumbledore today, but not both.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈利今天拜访了海格或邓布利多，但不是两者都拜访了。
- en: Harry visited Dumbledore today.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈利今天拜访了邓布利多。
- en: 'Based on these three sentences, we can answer the question “did it rain today?”,
    even though none of the individual sentences tells us anything about whether it
    is raining today. Here is how we can go about it: looking at sentence 3, we know
    that Harry visited Dumbledore. Looking at sentence 2, we know that Harry visited
    either Dumbledore or Hagrid, and thus we can conclude'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这三句话，我们可以回答“今天是否下雨？”这个问题，尽管没有任何一个单独的句子告诉我们今天是否下雨。我们可以这样进行推理：查看第三句话，我们知道哈利拜访了邓布利多。查看第二句话，我们知道哈利拜访了邓布利多或海格，因此我们可以得出结论
- en: Harry did not visit Hagrid.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈利没有拜访海格。
- en: Now, looking at sentence 1, we understand that if it didn’t rain, Harry would
    have visited Hagrid. However, knowing sentence 4, we know that this is not the
    case. Therefore, we can conclude
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看第一句话，我们理解如果没有下雨，哈利会拜访海格。然而，知道第四句话，我们知道情况并非如此。因此，我们可以得出结论
- en: It rained today.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 今天下雨了。
- en: To come to this conclusion, we used logic, and today’s lecture explores how
    AI can use logic to reach to new conclusions based on existing information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得出这个结论，我们使用了逻辑，今天的讲座探讨了人工智能如何使用逻辑根据现有信息得出新的结论。
- en: '**Sentence**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**句子**'
- en: A sentence is an assertion about the world in a knowledge representation language.
    A sentence is how AI stores knowledge and uses it to infer new information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 句子是在知识表示语言中对世界的断言。句子是人工智能存储知识并使用它来推断新信息的方式。
- en: Propositional Logic
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质理逻辑
- en: Propositional logic is based on propositions, statements about the world that
    can be either true or false, as in sentences 1-5 above.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 质量逻辑基于命题，即关于世界的陈述，可以是真或假，如上面第 1-5 句所示。
- en: '**Propositional Symbols**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题符号**'
- en: Propositional symbols are most often letters (P, Q, R) that are used to represent
    a proposition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 质量符号通常是用字母（P, Q, R）表示的命题。
- en: '**Logical Connectives**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑连接词**'
- en: Logical connectives are logical symbols that connect propositional symbols in
    order to reason in a more complex way about the world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑连接词是连接命题符号的逻辑符号，以便以更复杂的方式对世界进行推理。
- en: '**Not (¬)** inverses the truth value of the proposition. So, for example, if
    P: “It is raining,” then ¬P: “It is not raining”.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非 (¬)** 反转命题的真值。例如，如果 P: “正在下雨”，那么 ¬P: “没有下雨”。'
- en: 'Truth tables are used to compare all possible truth assignments to propositions.
    This tool will help us better understand the truth values of propositions when
    connected with different logical connectives. For example, below is our first
    truth table:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真值表用于比较命题的所有可能的真值分配。这个工具将帮助我们更好地理解命题与不同的逻辑连接词连接时的真值。例如，下面是我们的第一个真值表：
- en: '| P | ¬P |'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| P | ¬P |'
- en: '| --- | --- |'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| false | true |'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | true |'
- en: '| true | false |'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | false |'
- en: '**And (∧)** connects two different propositions. When these two proposition,
    P and Q, are connected by ∧, the resulting proposition P ∧ Q is true only in the
    case that both P and Q are true.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与 (∧)** 连接两个不同的命题。当这两个命题 P 和 Q 通过 ∧ 连接时，结果命题 P ∧ Q 仅在 P 和 Q 都为真时才为真。'
- en: '| P | Q | P ∧ Q |'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| P | Q | P ∧ Q |'
- en: '| --- | --- | --- |'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| false | false | false |'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | false | false |'
- en: '| false | true | false |'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | true | false |'
- en: '| true | false | false |'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | false | false |'
- en: '| true | true | true |'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '**Or (∨)** is true as as long as either of its arguments is true. This means
    that for P ∨ Q to be true, at least one of P or Q has to be true.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**或（∨）**只要其论点中的任何一个为真就为真。这意味着，为了P ∨ Q为真，P或Q中的至少一个必须为真。'
- en: '| P | Q | P ∨ Q |'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| P | Q | P ∨ Q |'
- en: '| --- | --- | --- |'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| false | false | false |'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | false | false |'
- en: '| false | true | true |'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | true | true |'
- en: '| true | false | true |'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | false | true |'
- en: '| true | true | true |'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | true | true |'
- en: 'It is worthwhile to mention that there are two types of Or: an inclusive Or
    and an exclusive Or. In an exclusive Or, P ∨ Q is false if P ∧ Q is true. That
    is, an exclusive Or requires only one of its arguments to be true and not both.
    An inclusive Or is true if any of P, Q, or P ∧ Q is true. In the case of Or (∨),
    the intention is an inclusive Or.'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，有两种类型的“或”：包含“或”和排除“或”。在排除“或”中，如果P ∧ Q为真，则P ∨ Q为假。也就是说，排除“或”只需要其论点中的一个为真，而不是两个都为真。包含“或”在P、Q或P
    ∧ Q中的任何一个为真时为真。在“或”（∨）的情况下，意图是包含“或”。
- en: '**A couple of side notes not mentioned in lecture**:'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**一些在讲座中没有提到的旁注**：'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sometimes an example helps understand inclusive versus exclusive Or. Inclusive
    Or: “in order to eat dessert, you have to clean your room or mow the lawn.” In
    this case, if you do both chores, you will still get the cookies. Exclusive Or:
    “For dessert, you can have either cookies or ice cream.” In this case, you can’t
    have both.'
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时举一个例子有助于理解包含“或”与排除“或”。包含“或”：为了吃甜点，你必须打扫房间或修剪草坪。在这种情况下，如果你做了这两项家务，你仍然会得到饼干。排除“或”：为了甜点，你可以选择饼干或冰淇淋。在这种情况下，你不能两者都要。
- en: If you are curious, the exclusive Or is often shortened to XOR and a common
    symbol for it is ⊕).
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你好奇，排除“或”通常简称为XOR，其常见符号是⊕）。
- en: '**Implication (→)** represents a structure of “if P then Q.” For example, if
    P: “It is raining” and Q: “I’m indoors”, then P → Q means “If it is raining, then
    I’m indoors.” In the case of P implies Q (P → Q), P is called the **antecedent**
    and Q is called the *consequent*.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蕴含（→）**代表“如果P那么Q”的结构。例如，如果P：“下雨”和Q：“我待在室内”，那么P → Q意味着“如果下雨，那么我待在室内”。在P蕴含Q（P
    → Q）的情况下，P被称为**前件**，Q被称为**后件**。'
- en: 'When the **antecedent** is true, the whole implication is true in the case
    that the **consequent** is true (that makes sense: if it is raining and I’m indoors,
    then the sentence “if it is raining, then I’m indoors” is true). When the **antecedent**
    is true, the implication is false if the **consequent** is false (if I’m outside
    while it is raining, then the sentence “If it is raining, then I’m indoors” is
    false). However, when the **antecedent** is false, the implication is always true,
    regardless of the **consequent**. This can sometimes be a confusing concept. Logically,
    we can’t learn anything from an implication (P → Q) if the **antecedent** (P)
    is false. Looking at our example, if it is not raining, the implication doesn’t
    say anything about whether I’m indoors or not. I could be an indoors type and
    never walk outside, even when it is not raining, or I could be an outdoors type
    and be outside all the time when it is not raining. When the antecedent is false,
    we say that the implication is *trivially* true.'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当**前件**为真时，如果**后件**也为真，整个蕴含式就为真（这很有道理：如果下雨而我待在室内，那么句子“如果下雨，那么我待在室内”就是真的）。当**前件**为真时，如果**后件**为假，蕴含式就是假的（如果我下雨时在室外，那么句子“如果下雨，那么我待在室内”就是假的）。然而，当**前件**为假时，无论**后件**如何，蕴含式总是真的。这有时可能是一个令人困惑的概念。从逻辑上讲，如果**前件**（P）为假，我们就无法从蕴含式（P
    → Q）中得出任何东西。看看我们的例子，如果不下雨，蕴含式并没有说明我是否在室内。我可能是一个室内型的人，即使不下雨也从不外出，或者我可能是一个室外型的人，不下雨时总是外出。当前件为假时，我们说蕴含式是**显然**真的。
- en: '| P | Q | P → Q |'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| P | Q | P → Q |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| false | false | true |'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | false | true |'
- en: '| false | true | true |'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| false | true | true |'
- en: '| true | false | false |'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | false | false |'
- en: '| true | true | true |'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '**Biconditional (↔)** is an implication that goes both directions. You can
    read it as “if and only if.” P ↔ Q is the same as P → Q and Q → P taken together.
    For example, if P: “It is raining.” and Q: “I’m indoors,” then P ↔ Q means that
    “If it is raining, then I’m indoors,” and “if I’m indoors, then it is raining.”
    This means that we can infer more than we could with a simple implication. If
    P is false, then Q is also false; if it is not raining, we know that I’m also
    not indoors.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双条件 (↔)** 是一个双向的蕴涵。你可以将其读作“如果且仅如果”。P ↔ Q 与 P → Q 和 Q → P 同时成立。例如，如果 P: “正在下雨。”
    和 Q: “我在室内，”那么 P ↔ Q 意味着“如果下雨，那么我在室内，”以及“如果我在室内，那么下雨。”这意味着我们可以比简单蕴涵推断出更多内容。如果
    P 是假的，那么 Q 也是假的；如果不下雨，我们知道我也不在室内。'
- en: '| P | Q | P ↔ Q |'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| P | Q | P ↔ Q |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| false | false | true |'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 假 | 假 | 真 |'
- en: '| false | true | false |'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 假 | 真 | 假 |'
- en: '| true | false | false |'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 真 | 假 | 假 |'
- en: '| true | true | true |'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 真 | 真 | 真 |'
- en: '**Model**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**'
- en: The model is an assignment of a truth value to every proposition. To reiterate,
    propositions are statements about the world that can be either true or false.
    However, knowledge about the world is represented in the truth values of these
    propositions. The model is the truth-value assignment that provides information
    about the world.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是对每个命题的真值分配。再次强调，命题是关于世界的陈述，可以是真或假。然而，关于世界的知识是通过这些命题的真值来表示的。模型是提供关于世界信息的真值分配。
- en: 'For example, if P: “It is raining.” and Q: “It is Tuesday.”, a model could
    be the following truth-value assignment: {P = True, Q = False}. This model means
    that it is raining, but it is not Tuesday. However, there are more possible models
    in this situation (for example, {P = True, Q = True}, where it is both raining
    and a Tuesday). In fact, the number of possible models is 2 to the power of the
    number of propositions. In this case, we had 2 propositions, so 2²=4 possible
    models.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果 P: “正在下雨。” 和 Q: “今天是星期二。”，一个模型可以是以下真值分配：{P = 真, Q = 假}。这个模型意味着在下雨，但不是星期二。然而，在这种情况下还有更多可能的模型（例如，{P
    = 真, Q = 真}，即下雨且是星期二）。实际上，可能模型的数量是命题数量的 2 的幂。在这种情况下，我们有两个命题，所以 2²=4 个可能的模型。'
- en: '**Knowledge Base (KB)**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识库 (KB)**'
- en: The knowledge base is a set of sentences known by a knowledge-based agent. This
    is knowledge that the AI is provided about the world in the form of propositional
    logic sentences that can be used to make additional inferences about the world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 知识库是一组知识库代理所知道句子。这是 AI 以命题逻辑句子的形式提供关于世界的知识，可以用来对世界进行额外的推断。
- en: '**Entailment (⊨)**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**蕴涵 (⊨)**'
- en: If α ⊨ β (α entails β), then in any world where α is true, β is true, too.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 α ⊨ β (α 蕴涵 β)，那么在任何 α 为真的世界中，β 也是真的。
- en: 'For example, if α: “It is a Tuesday in January” and β: “It is January,” then
    we know that α ⊨ β. If it is true that it is a Tuesday in January, we also know
    that it is January. Entailment is different from implication. Implication is a
    logical connective between two propositions. Entailment, on the other hand, is
    a relation that means that if all the information in α is true, then all the information
    in β is true.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果 α: “一月份是星期二” 和 β: “是月份，”那么我们知道 α ⊨ β。如果一月份是星期二是真的，我们也知道是月份。蕴涵与蕴涵不同。蕴涵是两个命题之间的逻辑连接词。另一方面，蕴涵是一个关系，意味着如果
    α 中的所有信息都是真的，那么 β 中的所有信息也是真的。'
- en: Inference
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推理
- en: Inference is the process of deriving new sentences from old ones.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 推理是从旧句子推导出新句子的过程。
- en: For instance, in the Harry Potter example earlier, sentences 4 and 5 were inferred
    from sentences 1, 2, and 3.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的哈利·波特例子中，句子 4 和 5 是从句子 1、2 和 3 推导出来的。
- en: There are multiple ways to infer new knowledge based on existing knowledge.
    First, we will consider the **Model Checking** algorithm.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于现有知识推断新知识有多种方式。首先，我们将考虑 **模型检查** 算法。
- en: 'To determine if KB ⊨ α (in other words, answering the question: “can we conclude
    that α is true based on our knowledge base”)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确定 KB ⊨ α（换句话说，回答“基于我们的知识库，我们能否得出 α 是真的”）
- en: Enumerate all possible models.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举所有可能的模型。
- en: If in every model where KB is true, α is true as well, then KB entails α (KB
    ⊨ α).
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在 KB 为真的每个模型中 α 也是真的，那么 KB 蕴涵 α (KB ⊨ α)。
- en: 'Consider the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: 'P: It is a Tuesday. Q: It is raining. R: Harry will go for a run. KB: (P ∧
    ¬Q) → R (in words, P and not Q imply R) P (P is true) ¬Q (Q is false) Query: R
    (We want to know whether R is true or false; Does KB ⊨ R?)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: To answer the query using the Model Checking algorithm, we enumerate all possible
    models.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| false | false | false |   |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| false | false | true |   |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| false | true | false |   |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| false | true | true |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |   |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| true | true | false |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: Then, we go through every model and check whether it is true given our Knowledge
    Base.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: First, in our KB, we know that P is true. Thus, we can say that the KB is false
    in all models where P is not true.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | false |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | false |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | false |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| true | true | false |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |   |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: Next, similarly, in our KB, we know that Q is false. Thus, we can say that the
    KB is false in all models where Q is true.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | false |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | false |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | false |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |   |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |   |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| true | true | false | false |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| true | true | true | false |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: Finally, we are left with two models. In both, P is true and Q is false. In
    one model R is true and in the other R is false. Due to (P ∧ ¬Q) → R being in
    our KB, we know that in the case where P is true and Q is false, R must be true.
    Thus, we say that our KB is false for the model where R is false, and true for
    the model where R is true.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | false |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | false |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | false |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| true | false | false | false |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| true | false | true | true |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| true | true | false | false |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| true | true | true | false |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: Looking at this table, there is only one model where our knowledge base is true.
    In this model, we see that R is also true. By our definition of entailment, if
    R is true in all models where the KB is true, then KB ⊨ R.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how knowledge and logic can be represented as code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Model Checking algorithm, the following information is needed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge Base, which will be used to draw inferences
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A query, or the proposition that we are interested in whether it is entailed
    by the KB
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols, a list of all the symbols (or atomic propositions) used (in our case,
    these are `rain`, `hagrid`, and `dumbledore`)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model, an assignment of truth and false values to symbols
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The model checking algorithm looks as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we are interested only in the models where the KB is true. If the
    KB is false, then the conditions that we know to be true are not occurring in
    these models, making them irrelevant to our case.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只对KB为真的模型感兴趣。如果KB为假，那么我们知道为真的条件在这些模型中不会发生，使它们对我们案例无关紧要。
- en: '**An example from outside lecture**: Let P: Harry plays seeker, Q: Oliver plays
    keeper, R: Gryffindor wins. Our KB specifies that P Q (P ∧ Q) → R. In other words,
    we know that P is true, i.e. Harry plays seeker, and that Q is true, i.e. Oliver
    plays keeper, and that if both P and Q are true, then R is true, too, meaning
    that Gryffindor wins the match. Now imagine a model where Harry played beater
    instead of seeker (thus, Harry did not play seeker, ¬P). Well, in this case, we
    don’t care whether Gryffindor won (whether R is true or not), because we have
    the information in our KB that Harry played seeker and not beater. We are only
    interested in the models where, as in our case, P and Q are true.)'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**来自课堂外的一个例子**：设P：哈利玩寻找者，Q：奥利弗玩守门员，R：格兰芬多获胜。我们的知识库（KB）指定P Q (P ∧ Q) → R。换句话说，我们知道P为真，即哈利玩寻找者，Q为真，即奥利弗玩守门员，并且如果P和Q都为真，那么R也为真，这意味着格兰芬多赢得了比赛。现在想象一个模型，哈利扮演的是打击手而不是寻找者（因此，哈利没有玩寻找者，¬P）。在这种情况下，我们不在乎格兰芬多是否获胜（R是否为真），因为我们知道哈利扮演的是寻找者而不是打击手。我们只对P和Q都为真的模型感兴趣。）'
- en: Further, the way the `check_all` function works is recursive. That is, it picks
    one symbol, creates two models, in one of which the symbol is true and in the
    other the symbol is false, and then calls itself again, now with two models that
    differ by the truth assignment of this symbol. The function will keep doing so
    until all symbols will have been assigned truth-values in the models, leaving
    the list `symbols` empty. Once it is empty (as identified by the line `if not
    symbols`), in each instance of the function (wherein each instance holds a different
    model), the function checks whether the KB is true given the model. If the KB
    is true in this model, the function checks whether the query is true, as described
    earlier.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`check_all`函数的工作方式是递归的。也就是说，它选择一个符号，创建两个模型，其中一个模型中该符号为真，另一个模型中该符号为假，然后再次调用自身，现在有两个模型，它们的区别在于该符号的真值分配。函数将持续这样做，直到所有符号在模型中都被分配了真值，使`symbols`列表为空。一旦它为空（如`if
    not symbols`行所示），在函数的每个实例中（其中每个实例持有不同的模型），函数将检查给定模型的知识库（KB）是否为真。如果在这个模型中KB为真，则函数将检查查询是否为真，如前所述。
- en: Knowledge Engineering
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知识工程
- en: Knowledge engineering is the process of figuring out how to represent propositions
    and logic in AI.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 知识工程是确定如何在人工智能中表示命题和逻辑的过程。
- en: Let’s practice knowledge engineering using the game Clue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过游戏《神秘线索》来练习知识工程。
- en: In the game, a murder was committed by a *person*, using a *tool* in a *location*.
    People, tools, and locations are represented by cards. One card of each category
    is picked at random and put in an envelope, and it is up to the participants to
    uncover whodunnit. Participants do so by uncovering cards and deducing from these
    clues what must be in the envelope. We will use the Model Checking algorithm from
    before to uncover the mystery. In our model, we mark as `True` items that we know
    are related to the murder and `False` otherwise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，谋杀是由一个*人*在*地点*使用*工具*犯下的。人物、工具和地点由卡片表示。随机抽取每个类别的卡片放入信封中，参与者需要揭开信封，找出凶手。参与者通过揭开卡片并从这些线索中推断出信封中必须有什么来做到这一点。我们将使用之前的模型检查算法来揭开这个谜团。在我们的模型中，我们将与谋杀相关的事项标记为`True`，否则标记为`False`。
- en: 'For our purposes, suppose we have three people: Mustard, Plum, and Scarlet,
    three tools: knife, revolver, and wrench, and three locations: ballroom, kitchen,
    and library.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，假设我们有三个人：芥末、梅子和猩红，三个工具：刀、手枪和扳手，以及三个地点：舞厅、厨房和图书馆。
- en: 'We can start creating our knowledge base by adding the rules of the game. We
    know for certain that one person is the murderer, that one tool was used, and
    that the murder happened in one location. This can be represented in propositional
    logic the following way:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加游戏的规则来开始创建我们的知识库。我们确定一个人是凶手，一个工具被使用，谋杀发生在某个地点。这可以用命题逻辑以下方式表示：
- en: (Mustard ∨ Plum ∨ Scarlet)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (芥末 ∨ 梅子 ∨ 猩红)
- en: (knife ∨ revolver ∨ wrench)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (刀 ∨ 手枪 ∨ 扳手)
- en: (ballroom ∨ kitchen ∨ library)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: (舞厅 ∨ 厨房 ∨ 图书馆)
- en: The game starts with each player seeing one person, one tool, and one location,
    thus knowing that they are not related to the murder. Players do not share the
    information that they saw in these cards. Suppose our player gets the cards of
    Mustard, kitchen, and revolver. Thus, we know that these are not related to the
    murder and we can add to our KB
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，每个玩家看到一个人、一个工具和一个地点，因此知道他们与谋杀无关。玩家不会分享他们在这些卡片上看到的信息。假设我们的玩家得到了Mustard、厨房和手枪的卡片。因此，我们知道这些与谋杀无关，我们可以添加到我们的KB中
- en: ¬(Mustard)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ¬(Mustard)
- en: ¬(kitchen)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ¬(kitchen)
- en: ¬(revolver)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ¬(revolver)
- en: 'In other situations in the game, one can make a guess, suggesting one combination
    of person, tool and location. Suppose that the guess is that Scarlet used a wrench
    to commit the crime in the library. If this guess is wrong, then the following
    can be deduced and added to the KB:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的其他情况下，一个人可以做出猜测，提出一个人、工具和地点的组合。假设猜测是Scarlet在图书馆使用扳手犯罪。如果这个猜测是错误的，那么以下可以推导出来并添加到KB中：
- en: (¬Scarlet ∨ ¬library ∨ ¬wrench)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (¬Scarlet ∨ ¬library ∨ ¬wrench)
- en: Now, suppose someone shows us the Plum card. Thus, we can add
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设有人向我们展示了Plum的牌。因此，我们可以添加
- en: ¬(Plum)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ¬(Plum)
- en: to our KB.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到我们的KB中。
- en: At this point, we can conclude that the murderer is Scarlet, since it has to
    be one of Mustard, Plum, and Scarlet, and we have evidence that the first two
    are not it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以得出结论，凶手是Scarlet，因为凶手只能是Mustard、Plum和Scarlet中的一个，而我们已经有证据表明前两个人不是凶手。
- en: Adding just one more piece of knowledge, for example, that it is not the ballroom,
    can give us more information. First, we update our KB
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一点额外的知识，例如，比如它不是舞厅，就能给我们更多信息。首先，我们更新我们的知识库（KB）
- en: ¬(ballroom)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ¬(ballroom)
- en: And now, using multiple previous pieces of data, we can deduce that Scarlet
    committed the murder with a knife in the library. We can deduce that it’s the
    library because it has to be either the ballroom, the kitchen, or the library,
    and the first two were proven to not be the locations. However, when someone guessed
    Scarlet, library, wrench, the guess was false. Thus, at least one of the elements
    in this statement has to be false. Since we know both Scarlet and library to be
    true, we know that the wrench is the false part here. Since one of the three instruments
    has to be true, and it’s not the wrench nor the revolver, we can conclude that
    it is the knife.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用多个先前数据，我们可以推导出Scarlet在图书馆用刀犯罪。我们可以推导出是图书馆，因为地点只能是舞厅、厨房或图书馆，前两个已经被证明不是地点。然而，当有人猜测Scarlet、图书馆、扳手时，这个猜测是错误的。因此，这个陈述中的至少一个元素必须是错误的。因为我们知道Scarlet和图书馆是正确的，所以我们知道扳手是错误的。因为三个工具中必须有一个是正确的，而且不是扳手也不是手枪，我们可以得出结论，是刀。
- en: 'Here is how the information would be added to the knowledge base in Python:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将信息添加到Python中的知识库中的：
- en: '[PRE2]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can look at other logic puzzles as well. Consider the following example:
    four different people, Gilderoy, Pomona, Minerva, and Horace, are assigned to
    four different houses, Gryffindor, Hufflepuff, Ravenclaw, and Slytherin. There
    is exactly one person in each house. Representing the puzzle’s conditions in propositional
    logic is quite cumbersome. First, each of the possible assignments will have to
    be a proposition in itself: MinervaGryffindor, MinervaHufflepuff, MinervaRavenclaw,
    MinervaSlytherin, PomonaGryffindor… Second, to represent that each person belongs
    to a house, an Or statement is required with all the possible house assignments
    per person'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看看其他的逻辑谜题。考虑以下例子：有四个不同的人，Gilderoy、Pomona、Minerva和Horace，被分配到四个不同的学院，Gryffindor、Hufflepuff、Ravenclaw和Slytherin。每个学院恰好有一个人。用命题逻辑表示这个谜题的条件相当繁琐。首先，每个可能的分配都将本身成为一个命题：MinervaGryffindor、MinervaHufflepuff、MinervaRavenclaw、MinervaSlytherin、PomonaGryffindor……其次，为了表示每个人属于一个学院，需要一个表示所有可能学院分配的Or语句
- en: (MinervaGryffindor ∨ MinervaHufflepuff ∨ MinervaRavenclaw ∨ MinervaSlytherin),
    repeat for every person.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (MinervaGryffindor ∨ MinervaHufflepuff ∨ MinervaRavenclaw ∨ MinervaSlytherin)，对每个人重复。
- en: Then, to encode that if one person is assigned to one house, they are not assigned
    to the other houses, we will write
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了编码如果一个人被分配到一个学院，他们就不会被分配到其他学院，我们将写
- en: (MinervaGryffindor → ¬MinervaHufflepuff) ∧ (MinervaGryffindor → ¬MinervaRavenclaw)
    ∧ (MinervaGryffindor → ¬MinervaSlytherin) ∧ (MinervaHufflepuff → ¬MinervaGryffindor)…
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (MinervaGryffindor → ¬MinervaHufflepuff) ∧ (MinervaGryffindor → ¬MinervaRavenclaw)
    ∧ (MinervaGryffindor → ¬MinervaSlytherin) ∧ (MinervaHufflepuff → ¬MinervaGryffindor)……
- en: and so on for all houses and all people. A solution to this inefficiency is
    offered in the section on [first order logic](#first-order-logic). However, this
    type of riddle can still be solved with either type of logic, given enough cues.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推，对于所有房屋和所有人。在[一阶逻辑](#first-order-logic)部分中提供了解决这种低效的方法。然而，只要有足够的线索，这种类型的谜题仍然可以用任何一种逻辑来解决。
- en: 'Another type of puzzle that can be solved using propositional logic is a Mastermind
    game. In this game, player one arranges colors in a certain order, and then player
    two has to guess this order. Each turn, player two makes a guess, and player one
    gives back a number, indicating how many colors player two got right. Let’s simulate
    a game with four colors. Suppose player two suggests the following ordering:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以使用命题逻辑解决的谜题类型是Mastermind游戏。在这个游戏中，第一玩家以某种顺序排列颜色，然后第二玩家必须猜测这个顺序。在每一轮中，第二玩家做出一个猜测，第一玩家给出一个数字，表示第二玩家猜对了多少颜色。让我们模拟一个有四种颜色的游戏。假设第二玩家建议以下顺序：
- en: '![Mastermind1](../Images/1101768ac975208f794f42cbfa620662.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Mastermind1](../Images/1101768ac975208f794f42cbfa620662.png)'
- en: Player one answers “two.” Thus we know that some two of the colors are in the
    correct position, and the other two are in the wrong place. Based on this information,
    player two tries to switch the locations of two colors.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一玩家回答“两个”。因此我们知道有两个颜色在正确的位置，另外两个在错误的位置。基于这个信息，第二玩家尝试交换两个颜色的位置。
- en: '![Mastermind2](../Images/6d8d19f224d8c33dcdb7daf3a217225e.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Mastermind2](../Images/6d8d19f224d8c33dcdb7daf3a217225e.png)'
- en: Now player one answers “zero.” Thus, player two knows that the switched colors
    were in the right location initially, which means the untouched two colors were
    in the wrong location. Player two switches them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一玩家回答“零”。因此，第二玩家知道最初交换的颜色在正确的位置，这意味着未被触及的两个颜色在错误的位置。第二玩家将它们交换。
- en: '![Mastermind3](../Images/6b55de3a767ccad7cfbf399675846a34.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Mastermind3](../Images/6b55de3a767ccad7cfbf399675846a34.png)'
- en: Player one says “four” and the game is over.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一玩家说“四个”，游戏结束。
- en: Representing this in propositional logic would require us to have (number of
    colors)² atomic propositions. So, in the case of four colors, we would have the
    propositions red0, red1, red2, red3, blue0… standing for color and position. The
    next step would be representing the rules of the game in propositional logic (that
    there is only one color in each position and no colors repeat) and adding them
    to the KB. The final step would be adding all the cues that we have to the KB.
    In our case, we would add that, in the first guess, two positions were wrong and
    two were right, and in the second guess, none was right. Using this knowledge,
    a Model Checking algorithm can give us the solution to the puzzle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在命题逻辑中表达这一点需要我们拥有（颜色数量）²个原子命题。所以，在四种颜色的情况下，我们会拥有代表颜色和位置的命题，如red0、red1、red2、red3、blue0等。下一步是将游戏的规则在命题逻辑中表示（每个位置只有一个颜色且颜色不重复），并将它们添加到知识库中。最后一步是将我们拥有的所有线索添加到知识库中。在我们的情况下，我们会添加在第一次猜测中，有两个位置是错误的，有两个位置是正确的，在第二次猜测中，没有一个是正确的。使用这些知识，模型检查算法可以给我们提供谜题的解决方案。
- en: Inference Rules
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推理规则
- en: 'Model Checking is not an efficient algorithm because it has to consider every
    possible model before giving the answer (a reminder: a query R is true if under
    all the models (truth assignments) where the KB is true, R is true as well). Inference
    rules allow us to generate new information based on existing knowledge without
    considering every possible model.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 模型检查不是一个高效的算法，因为它必须在给出答案之前考虑所有可能模型（提醒：如果查询R在所有模型（真值赋值）中都是真的，那么R是真的）。推理规则允许我们基于现有知识生成新信息，而无需考虑所有可能的模型。
- en: Inference rules are usually represented using a horizontal bar that separates
    the top part, the premise, from the bottom part, the conclusion. The premise is
    whatever knowledge we have, and the conclusion is what knowledge can be generated
    based on the premise.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 推理规则通常使用一条水平线来表示，该线将上半部分（前提）与下半部分（结论）分开。前提是我们拥有的任何知识，而结论是基于前提可以生成的知识。
- en: '![Modus Ponens Example](../Images/fe8ee65e4952da401fb12186eac8c05a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Modus Ponens Example](../Images/fe8ee65e4952da401fb12186eac8c05a.png)'
- en: 'In this example, our premise consists of the following propositions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的前提由以下命题组成：
- en: If it is raining, then Harry is inside.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下雨，那么哈利就在室内。
- en: It is raining.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在下雨。
- en: Based on this, most reasonable humans can conclude that
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，大多数合理的人类可以得出结论：
- en: Harry is inside.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈利在室内。
- en: '**Modus Ponens**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**肯定前件**'
- en: The type of inference rule we use in this example is Modus Ponens, which is
    a fancy way of saying that if we know an implication and its antecedent to be
    true, then the consequent is true as well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的推理规则是肯定前件式，这是一种比较复杂的方式来表达，即如果我们知道一个蕴涵及其前件是真的，那么后件也是真的。
- en: '![Modus Ponens](../Images/4e52f2519822324c3b4548ac20cdd72c.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![肯定前件式](../Images/4e52f2519822324c3b4548ac20cdd72c.png)'
- en: '**And Elimination**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**合取消除**'
- en: If an And proposition is true, then any one atomic proposition within it is
    true as well. For example, if we know that Harry is friends with Ron and Hermione,
    we can conclude that Harry is friends with Hermione.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个合取命题是真的，那么其中任何一个原子命题也是真的。例如，如果我们知道哈利和罗恩以及赫敏是朋友，我们可以得出哈利和赫敏是朋友的结论。
- en: '![And Elimination](../Images/34f917b187a8f56d463a6f67ccf3b93a.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![合取消除](../Images/34f917b187a8f56d463a6f67ccf3b93a.png)'
- en: '**Double Negation Elimination**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**双重否定消除**'
- en: 'A proposition that is negated twice is true. For example, consider the proposition
    “It is not true that Harry did not pass the test”. We can parse it the following
    way: “It is not true that (Harry did not pass the test)”, or “¬(Harry did not
    pass the test)”, and, finally “¬(¬(Harry passed the test)).” The two negations
    cancel each other, marking the proposition “Harry passed the test” as true.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 被否定两次的命题是真的。例如，考虑命题“哈利没有通过考试的说法并不正确”。我们可以这样解析它：“哈利没有通过考试的说法并不正确”，或者“¬(哈利没有通过考试)”，最后“¬(¬(哈利通过了考试))”。两次否定相互抵消，将命题“哈利通过了考试”标记为真。
- en: '![Double Negation Elimination](../Images/8adcb265a969786e74d72f2698240b09.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![双重否定消除](../Images/8adcb265a969786e74d72f2698240b09.png)'
- en: '**Implication Elimination**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**蕴涵消除**'
- en: An implication is equivalent to an Or relation between the negated antecedent
    and the consequent. As an example, the proposition “If it is raining, Harry is
    inside” is equivalent to the proposition “(it is not raining) or (Harry is inside).”
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 蕴涵等价于否定前件和后件之间的或关系。例如，命题“如果下雨，哈利在室内”等价于命题“（不下雨）或（哈利在室内）。”
- en: '![Implication Elimination](../Images/9993e207952fa640926354ed772a972f.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![蕴涵消除](../Images/9993e207952fa640926354ed772a972f.png)'
- en: 'This one can be a little confusing. However, consider the following truth table:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点可能会有些令人困惑。然而，考虑以下真值表：
- en: '| P | Q | P → Q | ¬P ∨ Q |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| P | Q | P → Q | ¬P ∨ Q |'
- en: '| --- | --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| false | false | true | true |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 假 | 真 | 真 |'
- en: '| false | true | true | true |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 真 | 真 | 真 |'
- en: '| true | false | false | false |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 假 | 假 | 假 |'
- en: '| true | true | true | true |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 真 | 真 | 真 |'
- en: 'Since P → Q and ¬P ∨ Q have the same truth-value assignment, we know them to
    be equivalent logically. Another way to think about this is that an implication
    is true if either of two possible conditions is met: first, if the antecedent
    is false, the implication is trivially true (as discussed earlier, in the section
    on implication). This is represented by the negated antecedent P in ¬P ∨ Q, meaning
    that the proposition is always true if P is false. Second, the implication is
    true when the antecedent is true only when the consequent is true as well. That
    is, if P and Q are both true, then ¬P ∨ Q is true. However, if P is true and Q
    is not, then ¬P ∨ Q is false.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 P → Q 和 ¬P ∨ Q 具有相同的真值赋值，我们知道它们在逻辑上是等价的。另一种思考方式是，如果一个蕴涵在两种可能条件下成立：首先，如果前件是假的，蕴涵就显然是真的（如前所述，在蕴涵部分讨论过）。这由
    ¬P ∨ Q 中的否定前件 P 表示，意味着如果 P 是假的，那么命题总是真的。其次，当且仅当后件也是真的时，蕴涵才是真的。也就是说，如果 P 和 Q 都是真的，那么
    ¬P ∨ Q 是真的。然而，如果 P 是真的而 Q 不是，那么 ¬P ∨ Q 就是假的。
- en: '**Biconditional Elimination**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**双条件消除**'
- en: A biconditional proposition is equivalent to an implication and its inverse
    with an And connective. For example, “It is raining if and only if Harry is inside”
    is equivalent to (“If it is raining, Harry is inside” And “If Harry is inside,
    it is raining”).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个双条件命题等价于一个蕴涵及其逆命题，并且使用合取连接符。例如，“如果下雨，那么哈利在室内”等价于“如果下雨，哈利在室内”和“如果哈利在室内，那么下雨”。
- en: '![Biconditional Elimination](../Images/5047c6deaae81692d5972a79b8dc2737.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![双条件消除](../Images/5047c6deaae81692d5972a79b8dc2737.png)'
- en: '**De Morgan’s Law**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**德摩根定律**'
- en: 'It is possible to turn an And connective into an Or connective. Consider the
    following proposition: “It is not true that both Harry and Ron passed the test.”
    From this, it is possible to conclude that “It is not true that Harry passed the
    test” Or “It is not true that Ron passed the test.” That is, for the And proposition
    earlier to be true, at least one of the propositions in the Or propositions must
    be true.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将“与”连接词转换为“或”连接词是可能的。考虑以下命题：“哈利和罗恩都没有通过考试。”从这个命题中，我们可以得出结论：“哈利没有通过考试”或“罗恩没有通过考试。”也就是说，要使前面的“与”命题为真，至少有一个“或”命题中的命题必须为真。
- en: '![De Morgan''s 1](../Images/a7916b55ed5379f07f5fd9455329b96e.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![德摩根 1](../Images/a7916b55ed5379f07f5fd9455329b96e.png)'
- en: Similarly, it is possible to conclude the reverse. Consider the proposition
    “It is not true that Harry or Ron passed the test.” This can be rephrased as “Harry
    did not pass the test” And “Ron did not pass the test.”
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也可以得出相反的结论。考虑命题“哈利或罗恩没有通过考试。”这可以重新表述为“哈利没有通过考试”和“罗恩没有通过考试。”
- en: '![De Morgan''s 2](../Images/ce45caa14dcac2537d954e11d5b2a380.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![德摩根 2](../Images/ce45caa14dcac2537d954e11d5b2a380.png)'
- en: '**Distributive Property**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**分配律**'
- en: A proposition with two elements that are grouped with And or Or connectives
    can be distributed, or broken down into, smaller units consisting of And and Or.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由“与”或“或”连接词组合的两个元素的命题可以被分配，或分解成由“与”和“或”组成的小单元。
- en: '![Distributive 1](../Images/8509ae959fa70d9671c68560641ca47a.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![分配律 1](../Images/8509ae959fa70d9671c68560641ca47a.png)'
- en: '![Distributive 2](../Images/7671d62ba8fb17e3a38c60b8209d8ddf.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![分配律 2](../Images/7671d62ba8fb17e3a38c60b8209d8ddf.png)'
- en: '**Knowledge and Search Problems**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识和搜索问题**'
- en: 'Inference can be viewed as a search problem with the following properties:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 推理可以被视为一个具有以下特性的搜索问题：
- en: 'Initial state: starting knowledge base'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态：起始知识库
- en: 'Actions: inference rules'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：推理规则
- en: 'Transition model: new knowledge base after inference'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换模型：推理后的新知识库
- en: 'Goal test: checking whether the statement that we are trying to prove is in
    the KB'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标测试：检查我们试图证明的陈述是否在知识库（KB）中
- en: 'Path cost function: the number of steps in the proof'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径成本函数：证明中的步骤数
- en: This shows just how versatile search algorithms are, allowing us to derive new
    information based on existing knowledge using inference rules.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了搜索算法是多么的灵活，它允许我们使用推理规则根据现有知识推导出新的信息。
- en: Resolution
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归结
- en: 'Resolution is a powerful inference rule that states that if one of two atomic
    propositions in an Or proposition is false, the other has to be true. For example,
    given the proposition “Ron is in the Great Hall” Or “Hermione is in the library”,
    in addition to the proposition “Ron is not in the Great Hall,” we can conclude
    that “Hermione is in the library.” More formally, we can define resolution the
    following way:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 归结是一个强大的推理规则，它指出在一个“或”命题中的两个原子命题中，如果一个是假的，那么另一个必须是真的。例如，给定命题“罗恩在大厅”或“赫敏在图书馆”，除了命题“罗恩不在大厅”，我们还可以得出结论“赫敏在图书馆。”更正式地，我们可以这样定义归结：
- en: '![Resolution](../Images/90e60119059387583031e16cfb6c4810.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![归结](../Images/90e60119059387583031e16cfb6c4810.png)'
- en: Resolution relies on **Complementary Literals**, two of the same atomic propositions
    where one is negated and the other is not, such as P and ¬P.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 归结依赖于**互补文字**，即两个相同的原子命题，其中一个被否定，另一个没有被否定，例如 P 和 ¬P。
- en: 'Resolution can be further generalized. Suppose that in addition to the proposition
    “Ron is in the Great Hall” Or “Hermione is in the library”, we also know that
    “Ron is not in the Great Hall” Or “Harry is sleeping.” We can infer from this,
    using resolution, that “Hermione is in the library” Or “Harry is sleeping.” To
    put it in formal terms:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 归结可以进一步推广。假设除了命题“罗恩在大厅”或“赫敏在图书馆”，我们还知道“罗恩不在大厅”或“哈利在睡觉。”我们可以通过归结从这个命题中推断出“赫敏在图书馆”或“哈利在睡觉。”用正式的话来说：
- en: '![Resolution](../Images/ac0281217fcc2ee75792831f3c4fd0ac.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![归结](../Images/ac0281217fcc2ee75792831f3c4fd0ac.png)'
- en: Complementary literals allow us to generate new sentences through inferences
    by resolution. Thus, inference algorithms locate complementary literals to generate
    new knowledge.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 互补文字允许我们通过归结推理生成新的句子，从而生成新的知识。因此，推理算法定位互补文字以生成新的知识。
- en: 'A **Clause** is a disjunction of literals (a propositional symbol or a negation
    of a propositional symbol, such as P, ¬P). A **disjunction** consists of propositions
    that are connected with an Or logical connective (P ∨ Q ∨ R). A **conjunction**,
    on the other hand, consists of propositions that are connected with an And logical
    connective (P ∧ Q ∧ R). Clauses allow us to convert any logical statement into
    a **Conjunctive Normal Form** (CNF), which is a conjunction of clauses, for example:
    (A ∨ B ∨ C) ∧ (D ∨ ¬E) ∧ (F ∨ G).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**子句** 是文字的析取（一个命题符号或命题符号的否定，如 P，¬P）。**析取** 由命题通过或逻辑连接词连接（P ∨ Q ∨ R）。另一方面，**合取**
    由命题通过与逻辑连接词连接（P ∧ Q ∧ R）。子句允许我们将任何逻辑语句转换为 **合取范式** (CNF)，例如：(A ∨ B ∨ C) ∧ (D ∨
    ¬E) ∧ (F ∨ G)。'
- en: '**Steps in Conversion of Propositions to Conjunctive Normal Form**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**将命题转换为合取范式步骤**'
- en: Eliminate biconditionals
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消去双条件
- en: Turn (α ↔ β) into (α → β) ∧ (β → α).
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 (α ↔ β) 转换为 (α → β) ∧ (β → α)。
- en: Eliminate implications
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消去蕴涵
- en: Turn (α → β) into ¬α ∨ β.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 (α → β) 转换为 ¬α ∨ β。
- en: Move negation inwards until only literals are being negated (and not clauses),
    using De Morgan’s Laws.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用德摩根定律将否定内移，直到只有文字被否定（而不是子句）。
- en: Turn ¬(α ∧ β) into ¬α ∨ ¬β
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 ¬(α ∧ β) 转换为 ¬α ∨ ¬β
- en: 'Here’s an example of converting (P ∨ Q) → R to Conjunctive Normal Form:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个将 (P ∨ Q) → R 转换为合取范式的例子：
- en: (P ∨ Q) → R
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (P ∨ Q) → R
- en: ¬(P ∨ Q) ∨ R /Eliminate implication
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ¬(P ∨ Q) ∨ R / 消去蕴涵
- en: (¬P ∧ ¬Q) ∨ R /De Morgan’s Law
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (¬P ∧ ¬Q) ∨ R / 德摩根定律
- en: (¬P ∨ R) ∧ (¬Q ∨ R) /Distributive Law
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (¬P ∨ R) ∧ (¬Q ∨ R) / 分配律
- en: At this point, we can run an inference algorithm on the conjunctive normal form.
    Occasionally, through the process of inference by resolution, we might end up
    in cases where a clause contains the same literal twice. In these cases, a process
    called **factoring** is used, where the duplicate literal is removed. For example,
    (P ∨ Q ∨ S) ∧ (¬P ∨ R ∨ S) allow us to infer by resolution that (Q ∨ S ∨ R ∨ S).
    The duplicate S can be removed to give us (Q ∨ R ∨ S).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以在合取范式中运行推理算法。偶尔，通过解析推理的过程，我们可能会遇到一个子句包含相同的文字两次的情况。在这些情况下，使用称为 **因式分解**
    的过程，其中移除重复的文字。例如，(P ∨ Q ∨ S) ∧ (¬P ∨ R ∨ S) 允许我们通过解析推理得出 (Q ∨ S ∨ R ∨ S)。重复的 S
    可以被移除，得到 (Q ∨ R ∨ S)。
- en: Resolving a literal and its negation, i.e. ¬P and P, gives the **empty clause**
    (). The empty clause is always false, and this makes sense because it is impossible
    that both P and ¬P are true. This fact is used by the resolution algorithm.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 解析一个文字及其否定，即 ¬P 和 P，会得到 **空子句** (()). 空子句总是假的，这很有道理，因为 P 和 ¬P 同时为真是不可能的。这个事实被解析算法所使用。
- en: 'To determine if KB ⊨ α:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确定 KB ⊨ α：
- en: 'Check: is (KB ∧ ¬α) a contradiction?'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查：是否 (KB ∧ ¬α) 是一个矛盾？
- en: If so, then KB ⊨ α.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是这样，那么 KB ⊨ α。
- en: Otherwise, no entailment.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，没有蕴涵。
- en: 'Proof by contradiction is a tool used often in computer science. If our knowledge
    base is true, and it contradicts ¬α, it means that ¬α is false, and, therefore,
    α must be true. More technically, the algorithm would perform the following actions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 反证法是计算机科学中常用的一种工具。如果我们的知识库是真的，并且它与 ¬α 相矛盾，这意味着 ¬α 是假的，因此 α 必须是真的。更技术地说，算法会执行以下操作：
- en: 'To determine if KB ⊨ α:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确定 KB ⊨ α：
- en: Convert (KB ∧ ¬α) to Conjunctive Normal Form.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 (KB ∧ ¬α) 转换为合取范式。
- en: Keep checking to see if we can use resolution to produce a new clause.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续检查我们是否可以使用解析产生一个新的子句。
- en: If we ever produce the empty clause (equivalent to False), congratulations!
    We have arrived at a contradiction, thus proving that KB ⊨ α.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们产生了空子句（相当于 False），恭喜！我们已经达到了矛盾，从而证明了 KB ⊨ α。
- en: However, if contradiction is not achieved and no more clauses can be inferred,
    there is no entailment.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果没有达到矛盾并且无法再推导出更多子句，则不存在蕴涵。
- en: 'Here is an example that illustrates how this algorithm might work:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子说明这个算法可能如何工作：
- en: Does (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) entail A?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) 是否蕴涵 A？
- en: First, to prove by contradiction, we assume that A is false. Thus, we arrive
    at (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ∧ (¬A).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，为了进行反证法，我们假设 A 是假的。因此，我们到达 (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ∧ (¬A)。
- en: Now, we can start generating new information. Since we know that C is false
    (¬C), the only way (¬B ∨ C) can be true is if B is false, too. Thus, we can add
    (¬B) to our KB.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始生成新的信息。由于我们知道 C 是假的 (¬C)，(¬B ∨ C) 可以成立的唯一方式是 B 也是假的。因此，我们可以将 (¬B) 添加到我们的
    KB 中。
- en: Next, since we know (¬B), the only way (A ∨ B) can be true is if A is true.
    Thus, we can add (A) to our KB.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，由于我们知道 (¬B)，(A ∨ B) 可以成立的唯一方式是 A 为真。因此，我们可以将 (A) 添加到我们的 KB 中。
- en: Now our KB has two complementary literals, (A) and (¬A). We resolve them, arriving
    at the empty set, (). The empty set is false by definition, so we have arrived
    at a contradiction.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们的知识库有两个互补的命题，(A) 和 (¬A)。我们解决了它们，得到了空集，( )。空集根据定义是假的，所以我们已经得到了一个矛盾。
- en: First Order Logic
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**一阶逻辑**'
- en: 'First order logic is another type of logic that allows us to express more complex
    ideas more succinctly than propositional logic. First order logic uses two types
    of symbols: *Constant Symbols* and *Predicate Symbols*. Constant symbols represent
    objects, while predicate symbols are like relations or functions that take an
    argument and return a true or false value.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一阶逻辑是另一种逻辑类型，它允许我们比命题逻辑更简洁地表达更复杂的思想。一阶逻辑使用两种类型的符号：*常量符号*和*谓词符号*。常量符号代表对象，而谓词符号类似于接受参数并返回真或假值的关联或函数。
- en: For example, we return to the logic puzzle with different people and house assignments
    at Hogwarts. The constant symbols are people or houses, like Minerva, Pomona,
    Gryffindor, Hufflepuff, etc. The predicate symbols are properties that hold true
    or false of some constant symbols. For example, we can express the idea that Minerva
    is a person using the sentence Person(Minerva). Similarly, we can express the
    idea the Gryffindor is a house using the sentence House(Gryffindor). All the logical
    connectives work in first order logic the same way as before. For example, ¬House(Minerva)
    expresses the idea that Minerva is not a house. A predicate symbol can also take
    two or more arguments and express a relation between them. For example, BelongsTo
    expresses a relation between two arguments, the person and the house to which
    the person belongs. Thus, the idea that Minerva belongs to Gryffindor can be expressed
    as BelongsTo(Minerva, Gryffindor). First order logic allows having one symbol
    for each person and one symbol for each house. This is more succinct than propositional
    logic, where each person—house assignment would require a different symbol.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们回到霍格沃茨的逻辑谜题，不同的人和房子分配。常量符号是人或房子，如米涅瓦、波莫娜、格兰芬多、赫奇帕奇等。谓词符号是某些常量符号为真或假的属性。例如，我们可以用句子
    Person(Minerva) 表达米涅瓦是人这个想法。同样，我们可以用句子 House(Gryffindor) 表达格兰芬多是一个房子。所有的逻辑连接词在一阶逻辑中与之前一样工作。例如，¬House(Minerva)
    表达了米涅瓦不是一个房子的想法。谓词符号也可以接受两个或更多参数，并表达它们之间的关系。例如，BelongsTo 表达了两个人和房子之间的关系。因此，米涅瓦属于格兰芬多的想法可以表达为
    BelongsTo(Minerva, Gryffindor)。一阶逻辑允许为每个人和每个房子有一个符号。这比命题逻辑更简洁，在命题逻辑中，每个人—房子的分配都需要一个不同的符号。
- en: '**Universal Quantification**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**全称量化**'
- en: Quantification is a tool that can be used in first order logic to represent
    sentences without using a specific constant symbol. Universal quantification uses
    the symbol ∀ to express “for all.” So, for example, the sentence ∀x. BelongsTo(x,
    Gryffindor) → ¬BelongsTo(x, Hufflepuff) expresses the idea that it is true for
    every symbol that if this symbol belongs to Gryffindor, it does not belong to
    Hufflepuff.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 量化是一种可以在一阶逻辑中使用的工具，用于表示不使用特定常量符号的句子。全称量化使用符号 ∀ 来表达“对所有”。因此，例如，句子 ∀x. BelongsTo(x,
    Gryffindor) → ¬BelongsTo(x, Hufflepuff) 表达了对于每个符号，如果这个符号属于格兰芬多，它就不属于赫奇帕奇的想法。
- en: '**Existential Quantification**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**存在量化**'
- en: Existential quantification is an idea parallel to universal quantification.
    However, while universal quantification was used to create sentences that are
    true for all x, existential quantification is used to create sentences that are
    true for at least one x. It is expressed using the symbol ∃. For example, the
    sentence ∃x. House(x) ∧ BelongsTo(Minerva, x) means that there is at least one
    symbol that is both a house and that Minerva belongs to it. In other words, this
    expresses the idea that Minerva belongs to a house.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 存在量化是一个与全称量化平行的概念。然而，全称量化被用来创建对所有 x 都为真的句子，而存在量化被用来创建至少对一个 x 为真的句子。它使用符号 ∃ 来表示。例如，句子
    ∃x. House(x) ∧ BelongsTo(Minerva, x) 表示至少有一个符号既是房子，又属于米涅瓦。换句话说，这表达了米涅瓦属于一个房子的想法。
- en: Existential and universal quantification can be used in the same sentence. For
    example, the sentence ∀x. Person(x) → (∃y. House(y) ∧ BelongsTo(x, y)) expresses
    the idea that if x is a person, then there is at least one house, y, to which
    this person belongs. In other words, this sentence means that every person belongs
    to a house.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 存在量词和全称量词可以在同一个句子中使用。例如，句子 ∀x. Person(x) → (∃y. House(y) ∧ BelongsTo(x, y))
    表达了这样的想法：如果x是一个人，那么至少有一个房子y，这个人属于它。换句话说，这个句子的意思是每个人都属于一个房子。
- en: There are other types of logic as well, and the commonality between them is
    that they all exist in pursuit of representing information. These are the systems
    we use to represent knowledge in our AI.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有其他类型的逻辑，它们的共同点在于它们都存在于追求表示信息的过程中。这些是我们用来在我们的AI中表示知识的系统。
