- en: Lecture 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/ai/notes/1/](https://cs50.harvard.edu/ai/notes/1/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Humans reason based on existing knowledge and draw conclusions. The concept
    of representing knowledge and drawing conclusions from it is also used in AI,
    and in this lecture we will explore how we can achieve this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge-Based Agents**'
  prefs: []
  type: TYPE_NORMAL
- en: These are agents that reason by operating on internal representations of knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: What does “reasoning based on knowledge to draw a conclusion” mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start answering this with a Harry Potter example. Consider the following
    sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: If it didn’t rain, Harry visited Hagrid today.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Harry visited Hagrid or Dumbledore today, but not both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Harry visited Dumbledore today.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on these three sentences, we can answer the question “did it rain today?”,
    even though none of the individual sentences tells us anything about whether it
    is raining today. Here is how we can go about it: looking at sentence 3, we know
    that Harry visited Dumbledore. Looking at sentence 2, we know that Harry visited
    either Dumbledore or Hagrid, and thus we can conclude'
  prefs: []
  type: TYPE_NORMAL
- en: Harry did not visit Hagrid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, looking at sentence 1, we understand that if it didn’t rain, Harry would
    have visited Hagrid. However, knowing sentence 4, we know that this is not the
    case. Therefore, we can conclude
  prefs: []
  type: TYPE_NORMAL
- en: It rained today.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To come to this conclusion, we used logic, and today’s lecture explores how
    AI can use logic to reach to new conclusions based on existing information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sentence**'
  prefs: []
  type: TYPE_NORMAL
- en: A sentence is an assertion about the world in a knowledge representation language.
    A sentence is how AI stores knowledge and uses it to infer new information.
  prefs: []
  type: TYPE_NORMAL
- en: Propositional Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Propositional logic is based on propositions, statements about the world that
    can be either true or false, as in sentences 1-5 above.
  prefs: []
  type: TYPE_NORMAL
- en: '**Propositional Symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: Propositional symbols are most often letters (P, Q, R) that are used to represent
    a proposition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical Connectives**'
  prefs: []
  type: TYPE_NORMAL
- en: Logical connectives are logical symbols that connect propositional symbols in
    order to reason in a more complex way about the world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Not (¬)** inverses the truth value of the proposition. So, for example, if
    P: “It is raining,” then ¬P: “It is not raining”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Truth tables are used to compare all possible truth assignments to propositions.
    This tool will help us better understand the truth values of propositions when
    connected with different logical connectives. For example, below is our first
    truth table:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| P | ¬P |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**And (∧)** connects two different propositions. When these two proposition,
    P and Q, are connected by ∧, the resulting proposition P ∧ Q is true only in the
    case that both P and Q are true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| P | Q | P ∧ Q |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | false | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | true | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | false | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | true | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Or (∨)** is true as as long as either of its arguments is true. This means
    that for P ∨ Q to be true, at least one of P or Q has to be true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| P | Q | P ∨ Q |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | false | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | true | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | false | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | true | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'It is worthwhile to mention that there are two types of Or: an inclusive Or
    and an exclusive Or. In an exclusive Or, P ∨ Q is false if P ∧ Q is true. That
    is, an exclusive Or requires only one of its arguments to be true and not both.
    An inclusive Or is true if any of P, Q, or P ∧ Q is true. In the case of Or (∨),
    the intention is an inclusive Or.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A couple of side notes not mentioned in lecture**:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sometimes an example helps understand inclusive versus exclusive Or. Inclusive
    Or: “in order to eat dessert, you have to clean your room or mow the lawn.” In
    this case, if you do both chores, you will still get the cookies. Exclusive Or:
    “For dessert, you can have either cookies or ice cream.” In this case, you can’t
    have both.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are curious, the exclusive Or is often shortened to XOR and a common
    symbol for it is ⊕).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implication (→)** represents a structure of “if P then Q.” For example, if
    P: “It is raining” and Q: “I’m indoors”, then P → Q means “If it is raining, then
    I’m indoors.” In the case of P implies Q (P → Q), P is called the **antecedent**
    and Q is called the *consequent*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the **antecedent** is true, the whole implication is true in the case
    that the **consequent** is true (that makes sense: if it is raining and I’m indoors,
    then the sentence “if it is raining, then I’m indoors” is true). When the **antecedent**
    is true, the implication is false if the **consequent** is false (if I’m outside
    while it is raining, then the sentence “If it is raining, then I’m indoors” is
    false). However, when the **antecedent** is false, the implication is always true,
    regardless of the **consequent**. This can sometimes be a confusing concept. Logically,
    we can’t learn anything from an implication (P → Q) if the **antecedent** (P)
    is false. Looking at our example, if it is not raining, the implication doesn’t
    say anything about whether I’m indoors or not. I could be an indoors type and
    never walk outside, even when it is not raining, or I could be an outdoors type
    and be outside all the time when it is not raining. When the antecedent is false,
    we say that the implication is *trivially* true.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| P | Q | P → Q |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | false | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | true | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | false | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | true | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Biconditional (↔)** is an implication that goes both directions. You can
    read it as “if and only if.” P ↔ Q is the same as P → Q and Q → P taken together.
    For example, if P: “It is raining.” and Q: “I’m indoors,” then P ↔ Q means that
    “If it is raining, then I’m indoors,” and “if I’m indoors, then it is raining.”
    This means that we can infer more than we could with a simple implication. If
    P is false, then Q is also false; if it is not raining, we know that I’m also
    not indoors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| P | Q | P ↔ Q |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | false | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| false | true | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | false | false |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| true | true | true |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Model**'
  prefs: []
  type: TYPE_NORMAL
- en: The model is an assignment of a truth value to every proposition. To reiterate,
    propositions are statements about the world that can be either true or false.
    However, knowledge about the world is represented in the truth values of these
    propositions. The model is the truth-value assignment that provides information
    about the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if P: “It is raining.” and Q: “It is Tuesday.”, a model could
    be the following truth-value assignment: {P = True, Q = False}. This model means
    that it is raining, but it is not Tuesday. However, there are more possible models
    in this situation (for example, {P = True, Q = True}, where it is both raining
    and a Tuesday). In fact, the number of possible models is 2 to the power of the
    number of propositions. In this case, we had 2 propositions, so 2²=4 possible
    models.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge Base (KB)**'
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge base is a set of sentences known by a knowledge-based agent. This
    is knowledge that the AI is provided about the world in the form of propositional
    logic sentences that can be used to make additional inferences about the world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entailment (⊨)**'
  prefs: []
  type: TYPE_NORMAL
- en: If α ⊨ β (α entails β), then in any world where α is true, β is true, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if α: “It is a Tuesday in January” and β: “It is January,” then
    we know that α ⊨ β. If it is true that it is a Tuesday in January, we also know
    that it is January. Entailment is different from implication. Implication is a
    logical connective between two propositions. Entailment, on the other hand, is
    a relation that means that if all the information in α is true, then all the information
    in β is true.'
  prefs: []
  type: TYPE_NORMAL
- en: Inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inference is the process of deriving new sentences from old ones.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the Harry Potter example earlier, sentences 4 and 5 were inferred
    from sentences 1, 2, and 3.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to infer new knowledge based on existing knowledge.
    First, we will consider the **Model Checking** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if KB ⊨ α (in other words, answering the question: “can we conclude
    that α is true based on our knowledge base”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerate all possible models.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If in every model where KB is true, α is true as well, then KB entails α (KB
    ⊨ α).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'P: It is a Tuesday. Q: It is raining. R: Harry will go for a run. KB: (P ∧
    ¬Q) → R (in words, P and not Q imply R) P (P is true) ¬Q (Q is false) Query: R
    (We want to know whether R is true or false; Does KB ⊨ R?)'
  prefs: []
  type: TYPE_NORMAL
- en: To answer the query using the Model Checking algorithm, we enumerate all possible
    models.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |   |'
  prefs: []
  type: TYPE_TB
- en: Then, we go through every model and check whether it is true given our Knowledge
    Base.
  prefs: []
  type: TYPE_NORMAL
- en: First, in our KB, we know that P is true. Thus, we can say that the KB is false
    in all models where P is not true.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |   |'
  prefs: []
  type: TYPE_TB
- en: Next, similarly, in our KB, we know that Q is false. Thus, we can say that the
    KB is false in all models where Q is true.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true | false |'
  prefs: []
  type: TYPE_TB
- en: Finally, we are left with two models. In both, P is true and Q is false. In
    one model R is true and in the other R is false. Due to (P ∧ ¬Q) → R being in
    our KB, we know that in the case where P is true and Q is false, R must be true.
    Thus, we say that our KB is false for the model where R is false, and true for
    the model where R is true.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | R | KB |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true | false |'
  prefs: []
  type: TYPE_TB
- en: Looking at this table, there is only one model where our knowledge base is true.
    In this model, we see that R is also true. By our definition of entailment, if
    R is true in all models where the KB is true, then KB ⊨ R.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how knowledge and logic can be represented as code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the Model Checking algorithm, the following information is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge Base, which will be used to draw inferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A query, or the proposition that we are interested in whether it is entailed
    by the KB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols, a list of all the symbols (or atomic propositions) used (in our case,
    these are `rain`, `hagrid`, and `dumbledore`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model, an assignment of truth and false values to symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The model checking algorithm looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are interested only in the models where the KB is true. If the
    KB is false, then the conditions that we know to be true are not occurring in
    these models, making them irrelevant to our case.
  prefs: []
  type: TYPE_NORMAL
- en: '**An example from outside lecture**: Let P: Harry plays seeker, Q: Oliver plays
    keeper, R: Gryffindor wins. Our KB specifies that P Q (P ∧ Q) → R. In other words,
    we know that P is true, i.e. Harry plays seeker, and that Q is true, i.e. Oliver
    plays keeper, and that if both P and Q are true, then R is true, too, meaning
    that Gryffindor wins the match. Now imagine a model where Harry played beater
    instead of seeker (thus, Harry did not play seeker, ¬P). Well, in this case, we
    don’t care whether Gryffindor won (whether R is true or not), because we have
    the information in our KB that Harry played seeker and not beater. We are only
    interested in the models where, as in our case, P and Q are true.)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Further, the way the `check_all` function works is recursive. That is, it picks
    one symbol, creates two models, in one of which the symbol is true and in the
    other the symbol is false, and then calls itself again, now with two models that
    differ by the truth assignment of this symbol. The function will keep doing so
    until all symbols will have been assigned truth-values in the models, leaving
    the list `symbols` empty. Once it is empty (as identified by the line `if not
    symbols`), in each instance of the function (wherein each instance holds a different
    model), the function checks whether the KB is true given the model. If the KB
    is true in this model, the function checks whether the query is true, as described
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge Engineering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowledge engineering is the process of figuring out how to represent propositions
    and logic in AI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s practice knowledge engineering using the game Clue.
  prefs: []
  type: TYPE_NORMAL
- en: In the game, a murder was committed by a *person*, using a *tool* in a *location*.
    People, tools, and locations are represented by cards. One card of each category
    is picked at random and put in an envelope, and it is up to the participants to
    uncover whodunnit. Participants do so by uncovering cards and deducing from these
    clues what must be in the envelope. We will use the Model Checking algorithm from
    before to uncover the mystery. In our model, we mark as `True` items that we know
    are related to the murder and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, suppose we have three people: Mustard, Plum, and Scarlet,
    three tools: knife, revolver, and wrench, and three locations: ballroom, kitchen,
    and library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start creating our knowledge base by adding the rules of the game. We
    know for certain that one person is the murderer, that one tool was used, and
    that the murder happened in one location. This can be represented in propositional
    logic the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: (Mustard ∨ Plum ∨ Scarlet)
  prefs: []
  type: TYPE_NORMAL
- en: (knife ∨ revolver ∨ wrench)
  prefs: []
  type: TYPE_NORMAL
- en: (ballroom ∨ kitchen ∨ library)
  prefs: []
  type: TYPE_NORMAL
- en: The game starts with each player seeing one person, one tool, and one location,
    thus knowing that they are not related to the murder. Players do not share the
    information that they saw in these cards. Suppose our player gets the cards of
    Mustard, kitchen, and revolver. Thus, we know that these are not related to the
    murder and we can add to our KB
  prefs: []
  type: TYPE_NORMAL
- en: ¬(Mustard)
  prefs: []
  type: TYPE_NORMAL
- en: ¬(kitchen)
  prefs: []
  type: TYPE_NORMAL
- en: ¬(revolver)
  prefs: []
  type: TYPE_NORMAL
- en: 'In other situations in the game, one can make a guess, suggesting one combination
    of person, tool and location. Suppose that the guess is that Scarlet used a wrench
    to commit the crime in the library. If this guess is wrong, then the following
    can be deduced and added to the KB:'
  prefs: []
  type: TYPE_NORMAL
- en: (¬Scarlet ∨ ¬library ∨ ¬wrench)
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose someone shows us the Plum card. Thus, we can add
  prefs: []
  type: TYPE_NORMAL
- en: ¬(Plum)
  prefs: []
  type: TYPE_NORMAL
- en: to our KB.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can conclude that the murderer is Scarlet, since it has to
    be one of Mustard, Plum, and Scarlet, and we have evidence that the first two
    are not it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding just one more piece of knowledge, for example, that it is not the ballroom,
    can give us more information. First, we update our KB
  prefs: []
  type: TYPE_NORMAL
- en: ¬(ballroom)
  prefs: []
  type: TYPE_NORMAL
- en: And now, using multiple previous pieces of data, we can deduce that Scarlet
    committed the murder with a knife in the library. We can deduce that it’s the
    library because it has to be either the ballroom, the kitchen, or the library,
    and the first two were proven to not be the locations. However, when someone guessed
    Scarlet, library, wrench, the guess was false. Thus, at least one of the elements
    in this statement has to be false. Since we know both Scarlet and library to be
    true, we know that the wrench is the false part here. Since one of the three instruments
    has to be true, and it’s not the wrench nor the revolver, we can conclude that
    it is the knife.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the information would be added to the knowledge base in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look at other logic puzzles as well. Consider the following example:
    four different people, Gilderoy, Pomona, Minerva, and Horace, are assigned to
    four different houses, Gryffindor, Hufflepuff, Ravenclaw, and Slytherin. There
    is exactly one person in each house. Representing the puzzle’s conditions in propositional
    logic is quite cumbersome. First, each of the possible assignments will have to
    be a proposition in itself: MinervaGryffindor, MinervaHufflepuff, MinervaRavenclaw,
    MinervaSlytherin, PomonaGryffindor… Second, to represent that each person belongs
    to a house, an Or statement is required with all the possible house assignments
    per person'
  prefs: []
  type: TYPE_NORMAL
- en: (MinervaGryffindor ∨ MinervaHufflepuff ∨ MinervaRavenclaw ∨ MinervaSlytherin),
    repeat for every person.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to encode that if one person is assigned to one house, they are not assigned
    to the other houses, we will write
  prefs: []
  type: TYPE_NORMAL
- en: (MinervaGryffindor → ¬MinervaHufflepuff) ∧ (MinervaGryffindor → ¬MinervaRavenclaw)
    ∧ (MinervaGryffindor → ¬MinervaSlytherin) ∧ (MinervaHufflepuff → ¬MinervaGryffindor)…
  prefs: []
  type: TYPE_NORMAL
- en: and so on for all houses and all people. A solution to this inefficiency is
    offered in the section on [first order logic](#first-order-logic). However, this
    type of riddle can still be solved with either type of logic, given enough cues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of puzzle that can be solved using propositional logic is a Mastermind
    game. In this game, player one arranges colors in a certain order, and then player
    two has to guess this order. Each turn, player two makes a guess, and player one
    gives back a number, indicating how many colors player two got right. Let’s simulate
    a game with four colors. Suppose player two suggests the following ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mastermind1](../Images/1101768ac975208f794f42cbfa620662.png)'
  prefs: []
  type: TYPE_IMG
- en: Player one answers “two.” Thus we know that some two of the colors are in the
    correct position, and the other two are in the wrong place. Based on this information,
    player two tries to switch the locations of two colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mastermind2](../Images/6d8d19f224d8c33dcdb7daf3a217225e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now player one answers “zero.” Thus, player two knows that the switched colors
    were in the right location initially, which means the untouched two colors were
    in the wrong location. Player two switches them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mastermind3](../Images/6b55de3a767ccad7cfbf399675846a34.png)'
  prefs: []
  type: TYPE_IMG
- en: Player one says “four” and the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: Representing this in propositional logic would require us to have (number of
    colors)² atomic propositions. So, in the case of four colors, we would have the
    propositions red0, red1, red2, red3, blue0… standing for color and position. The
    next step would be representing the rules of the game in propositional logic (that
    there is only one color in each position and no colors repeat) and adding them
    to the KB. The final step would be adding all the cues that we have to the KB.
    In our case, we would add that, in the first guess, two positions were wrong and
    two were right, and in the second guess, none was right. Using this knowledge,
    a Model Checking algorithm can give us the solution to the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Inference Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Model Checking is not an efficient algorithm because it has to consider every
    possible model before giving the answer (a reminder: a query R is true if under
    all the models (truth assignments) where the KB is true, R is true as well). Inference
    rules allow us to generate new information based on existing knowledge without
    considering every possible model.'
  prefs: []
  type: TYPE_NORMAL
- en: Inference rules are usually represented using a horizontal bar that separates
    the top part, the premise, from the bottom part, the conclusion. The premise is
    whatever knowledge we have, and the conclusion is what knowledge can be generated
    based on the premise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modus Ponens Example](../Images/fe8ee65e4952da401fb12186eac8c05a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, our premise consists of the following propositions:'
  prefs: []
  type: TYPE_NORMAL
- en: If it is raining, then Harry is inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is raining.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, most reasonable humans can conclude that
  prefs: []
  type: TYPE_NORMAL
- en: Harry is inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modus Ponens**'
  prefs: []
  type: TYPE_NORMAL
- en: The type of inference rule we use in this example is Modus Ponens, which is
    a fancy way of saying that if we know an implication and its antecedent to be
    true, then the consequent is true as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modus Ponens](../Images/4e52f2519822324c3b4548ac20cdd72c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**And Elimination**'
  prefs: []
  type: TYPE_NORMAL
- en: If an And proposition is true, then any one atomic proposition within it is
    true as well. For example, if we know that Harry is friends with Ron and Hermione,
    we can conclude that Harry is friends with Hermione.
  prefs: []
  type: TYPE_NORMAL
- en: '![And Elimination](../Images/34f917b187a8f56d463a6f67ccf3b93a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Double Negation Elimination**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A proposition that is negated twice is true. For example, consider the proposition
    “It is not true that Harry did not pass the test”. We can parse it the following
    way: “It is not true that (Harry did not pass the test)”, or “¬(Harry did not
    pass the test)”, and, finally “¬(¬(Harry passed the test)).” The two negations
    cancel each other, marking the proposition “Harry passed the test” as true.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Double Negation Elimination](../Images/8adcb265a969786e74d72f2698240b09.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Implication Elimination**'
  prefs: []
  type: TYPE_NORMAL
- en: An implication is equivalent to an Or relation between the negated antecedent
    and the consequent. As an example, the proposition “If it is raining, Harry is
    inside” is equivalent to the proposition “(it is not raining) or (Harry is inside).”
  prefs: []
  type: TYPE_NORMAL
- en: '![Implication Elimination](../Images/9993e207952fa640926354ed772a972f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This one can be a little confusing. However, consider the following truth table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | P → Q | ¬P ∨ Q |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true | true |'
  prefs: []
  type: TYPE_TB
- en: 'Since P → Q and ¬P ∨ Q have the same truth-value assignment, we know them to
    be equivalent logically. Another way to think about this is that an implication
    is true if either of two possible conditions is met: first, if the antecedent
    is false, the implication is trivially true (as discussed earlier, in the section
    on implication). This is represented by the negated antecedent P in ¬P ∨ Q, meaning
    that the proposition is always true if P is false. Second, the implication is
    true when the antecedent is true only when the consequent is true as well. That
    is, if P and Q are both true, then ¬P ∨ Q is true. However, if P is true and Q
    is not, then ¬P ∨ Q is false.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Biconditional Elimination**'
  prefs: []
  type: TYPE_NORMAL
- en: A biconditional proposition is equivalent to an implication and its inverse
    with an And connective. For example, “It is raining if and only if Harry is inside”
    is equivalent to (“If it is raining, Harry is inside” And “If Harry is inside,
    it is raining”).
  prefs: []
  type: TYPE_NORMAL
- en: '![Biconditional Elimination](../Images/5047c6deaae81692d5972a79b8dc2737.png)'
  prefs: []
  type: TYPE_IMG
- en: '**De Morgan’s Law**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to turn an And connective into an Or connective. Consider the
    following proposition: “It is not true that both Harry and Ron passed the test.”
    From this, it is possible to conclude that “It is not true that Harry passed the
    test” Or “It is not true that Ron passed the test.” That is, for the And proposition
    earlier to be true, at least one of the propositions in the Or propositions must
    be true.'
  prefs: []
  type: TYPE_NORMAL
- en: '![De Morgan''s 1](../Images/a7916b55ed5379f07f5fd9455329b96e.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, it is possible to conclude the reverse. Consider the proposition
    “It is not true that Harry or Ron passed the test.” This can be rephrased as “Harry
    did not pass the test” And “Ron did not pass the test.”
  prefs: []
  type: TYPE_NORMAL
- en: '![De Morgan''s 2](../Images/ce45caa14dcac2537d954e11d5b2a380.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Distributive Property**'
  prefs: []
  type: TYPE_NORMAL
- en: A proposition with two elements that are grouped with And or Or connectives
    can be distributed, or broken down into, smaller units consisting of And and Or.
  prefs: []
  type: TYPE_NORMAL
- en: '![Distributive 1](../Images/8509ae959fa70d9671c68560641ca47a.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Distributive 2](../Images/7671d62ba8fb17e3a38c60b8209d8ddf.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Knowledge and Search Problems**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inference can be viewed as a search problem with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial state: starting knowledge base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actions: inference rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transition model: new knowledge base after inference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Goal test: checking whether the statement that we are trying to prove is in
    the KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Path cost function: the number of steps in the proof'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shows just how versatile search algorithms are, allowing us to derive new
    information based on existing knowledge using inference rules.
  prefs: []
  type: TYPE_NORMAL
- en: Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resolution is a powerful inference rule that states that if one of two atomic
    propositions in an Or proposition is false, the other has to be true. For example,
    given the proposition “Ron is in the Great Hall” Or “Hermione is in the library”,
    in addition to the proposition “Ron is not in the Great Hall,” we can conclude
    that “Hermione is in the library.” More formally, we can define resolution the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resolution](../Images/90e60119059387583031e16cfb6c4810.png)'
  prefs: []
  type: TYPE_IMG
- en: Resolution relies on **Complementary Literals**, two of the same atomic propositions
    where one is negated and the other is not, such as P and ¬P.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolution can be further generalized. Suppose that in addition to the proposition
    “Ron is in the Great Hall” Or “Hermione is in the library”, we also know that
    “Ron is not in the Great Hall” Or “Harry is sleeping.” We can infer from this,
    using resolution, that “Hermione is in the library” Or “Harry is sleeping.” To
    put it in formal terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resolution](../Images/ac0281217fcc2ee75792831f3c4fd0ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Complementary literals allow us to generate new sentences through inferences
    by resolution. Thus, inference algorithms locate complementary literals to generate
    new knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Clause** is a disjunction of literals (a propositional symbol or a negation
    of a propositional symbol, such as P, ¬P). A **disjunction** consists of propositions
    that are connected with an Or logical connective (P ∨ Q ∨ R). A **conjunction**,
    on the other hand, consists of propositions that are connected with an And logical
    connective (P ∧ Q ∧ R). Clauses allow us to convert any logical statement into
    a **Conjunctive Normal Form** (CNF), which is a conjunction of clauses, for example:
    (A ∨ B ∨ C) ∧ (D ∨ ¬E) ∧ (F ∨ G).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps in Conversion of Propositions to Conjunctive Normal Form**'
  prefs: []
  type: TYPE_NORMAL
- en: Eliminate biconditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn (α ↔ β) into (α → β) ∧ (β → α).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminate implications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn (α → β) into ¬α ∨ β.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Move negation inwards until only literals are being negated (and not clauses),
    using De Morgan’s Laws.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn ¬(α ∧ β) into ¬α ∨ ¬β
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of converting (P ∨ Q) → R to Conjunctive Normal Form:'
  prefs: []
  type: TYPE_NORMAL
- en: (P ∨ Q) → R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ¬(P ∨ Q) ∨ R /Eliminate implication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (¬P ∧ ¬Q) ∨ R /De Morgan’s Law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (¬P ∨ R) ∧ (¬Q ∨ R) /Distributive Law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we can run an inference algorithm on the conjunctive normal form.
    Occasionally, through the process of inference by resolution, we might end up
    in cases where a clause contains the same literal twice. In these cases, a process
    called **factoring** is used, where the duplicate literal is removed. For example,
    (P ∨ Q ∨ S) ∧ (¬P ∨ R ∨ S) allow us to infer by resolution that (Q ∨ S ∨ R ∨ S).
    The duplicate S can be removed to give us (Q ∨ R ∨ S).
  prefs: []
  type: TYPE_NORMAL
- en: Resolving a literal and its negation, i.e. ¬P and P, gives the **empty clause**
    (). The empty clause is always false, and this makes sense because it is impossible
    that both P and ¬P are true. This fact is used by the resolution algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if KB ⊨ α:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check: is (KB ∧ ¬α) a contradiction?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, then KB ⊨ α.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, no entailment.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Proof by contradiction is a tool used often in computer science. If our knowledge
    base is true, and it contradicts ¬α, it means that ¬α is false, and, therefore,
    α must be true. More technically, the algorithm would perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if KB ⊨ α:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert (KB ∧ ¬α) to Conjunctive Normal Form.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep checking to see if we can use resolution to produce a new clause.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we ever produce the empty clause (equivalent to False), congratulations!
    We have arrived at a contradiction, thus proving that KB ⊨ α.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if contradiction is not achieved and no more clauses can be inferred,
    there is no entailment.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that illustrates how this algorithm might work:'
  prefs: []
  type: TYPE_NORMAL
- en: Does (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) entail A?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, to prove by contradiction, we assume that A is false. Thus, we arrive
    at (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ∧ (¬A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can start generating new information. Since we know that C is false
    (¬C), the only way (¬B ∨ C) can be true is if B is false, too. Thus, we can add
    (¬B) to our KB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, since we know (¬B), the only way (A ∨ B) can be true is if A is true.
    Thus, we can add (A) to our KB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now our KB has two complementary literals, (A) and (¬A). We resolve them, arriving
    at the empty set, (). The empty set is false by definition, so we have arrived
    at a contradiction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First Order Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First order logic is another type of logic that allows us to express more complex
    ideas more succinctly than propositional logic. First order logic uses two types
    of symbols: *Constant Symbols* and *Predicate Symbols*. Constant symbols represent
    objects, while predicate symbols are like relations or functions that take an
    argument and return a true or false value.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we return to the logic puzzle with different people and house assignments
    at Hogwarts. The constant symbols are people or houses, like Minerva, Pomona,
    Gryffindor, Hufflepuff, etc. The predicate symbols are properties that hold true
    or false of some constant symbols. For example, we can express the idea that Minerva
    is a person using the sentence Person(Minerva). Similarly, we can express the
    idea the Gryffindor is a house using the sentence House(Gryffindor). All the logical
    connectives work in first order logic the same way as before. For example, ¬House(Minerva)
    expresses the idea that Minerva is not a house. A predicate symbol can also take
    two or more arguments and express a relation between them. For example, BelongsTo
    expresses a relation between two arguments, the person and the house to which
    the person belongs. Thus, the idea that Minerva belongs to Gryffindor can be expressed
    as BelongsTo(Minerva, Gryffindor). First order logic allows having one symbol
    for each person and one symbol for each house. This is more succinct than propositional
    logic, where each person—house assignment would require a different symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Quantification**'
  prefs: []
  type: TYPE_NORMAL
- en: Quantification is a tool that can be used in first order logic to represent
    sentences without using a specific constant symbol. Universal quantification uses
    the symbol ∀ to express “for all.” So, for example, the sentence ∀x. BelongsTo(x,
    Gryffindor) → ¬BelongsTo(x, Hufflepuff) expresses the idea that it is true for
    every symbol that if this symbol belongs to Gryffindor, it does not belong to
    Hufflepuff.
  prefs: []
  type: TYPE_NORMAL
- en: '**Existential Quantification**'
  prefs: []
  type: TYPE_NORMAL
- en: Existential quantification is an idea parallel to universal quantification.
    However, while universal quantification was used to create sentences that are
    true for all x, existential quantification is used to create sentences that are
    true for at least one x. It is expressed using the symbol ∃. For example, the
    sentence ∃x. House(x) ∧ BelongsTo(Minerva, x) means that there is at least one
    symbol that is both a house and that Minerva belongs to it. In other words, this
    expresses the idea that Minerva belongs to a house.
  prefs: []
  type: TYPE_NORMAL
- en: Existential and universal quantification can be used in the same sentence. For
    example, the sentence ∀x. Person(x) → (∃y. House(y) ∧ BelongsTo(x, y)) expresses
    the idea that if x is a person, then there is at least one house, y, to which
    this person belongs. In other words, this sentence means that every person belongs
    to a house.
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of logic as well, and the commonality between them is
    that they all exist in pursuit of representing information. These are the systems
    we use to represent knowledge in our AI.
  prefs: []
  type: TYPE_NORMAL
