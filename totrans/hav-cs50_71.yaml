- en: Lecture 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6讲
- en: 原文：[https://cs50.harvard.edu/web/notes/6/](https://cs50.harvard.edu/web/notes/6/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/web/notes/6/](https://cs50.harvard.edu/web/notes/6/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[User Interfaces](#user-interfaces)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用户界面](#user-interfaces)'
- en: '[Single Page Applications](#single-page-applications)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[单页应用程序](#single-page-applications)'
- en: '[Scroll](#scroll)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[滚动](#scroll)'
- en: '[Infinite Scroll](#infinite-scroll)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无限滚动](#infinite-scroll)'
- en: '[Animation](#animation)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[动画](#animation)'
- en: '[React](#react)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React](#react)'
- en: '[Addition](#addition)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加法](#addition)'
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we’ve discussed how to build simple web pages using HTML and CSS, and
    how to use Git and GitHub in order to keep track of changes to our code and collaborate
    with others. We also familiarized ourselves with the Python programming language,
    started using Django to create web applications, and learned how to use Django
    models to store information in our sites. We then introduced JavaScript and learned
    how to use it to make web pages more interactive.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何使用HTML和CSS构建简单的网页，以及如何使用Git和GitHub来跟踪我们代码的变化并与他人协作。我们还熟悉了Python编程语言，开始使用Django创建Web应用程序，并学习了如何使用Django模型在我们的网站上存储信息。然后我们介绍了JavaScript，并学习了如何使用它使网页更加互动。
- en: Today, we’ll discuss common paradigms in User Interface design, using JavaScript
    and CSS to make our sites even more user friendly.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将讨论用户界面设计中的常见范式，使用JavaScript和CSS使我们的网站更加用户友好。
- en: User Interfaces
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: A User Interface is how visitors to a web page interact with that page. Our
    goal as web developers is to make these interactions as pleasant as possible for
    the user, and there are many methods we can use to do this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面是网页访问者与该页面交互的方式。作为Web开发者，我们的目标是让这些交互尽可能愉快，我们可以使用许多方法来实现这一点。
- en: Single Page Applications
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: Previously, if we wanted a website with multiple pages, we would accomplish
    that using different routes in our Django application. Now, we have the ability
    to load just a single page and then use JavaScript to manipulate the DOM. One
    major advantage of doing this is that we only need to modify the part of the page
    that is actually changing. For example, if we have a Nav Bar that doesn’t change
    based on your current page, we wouldn’t want to have to re-render that Nav Bar
    every time we switch to a new part of the page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，如果我们想要一个包含多个页面的网站，我们会通过Django应用程序中的不同路由来实现这一点。现在，我们有能力只加载一个页面，然后使用JavaScript来操作DOM。这样做的一个主要优点是我们只需要修改实际改变的部分页面。例如，如果我们有一个不根据你的当前页面变化的导航栏（Nav
    Bar），我们就不想每次切换到页面的新部分时都要重新渲染那个导航栏。
- en: 'Let’s look at an example of how we could simulate page switching in JavaScript:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个如何在JavaScript中模拟页面切换的例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice in the HTML above that we have three buttons and three divs. At the moment,
    the divs contain only a small bit of text, but we could imagine each div containing
    the contents of one page on our site. Now, we’ll add some JavaScript that allows
    us to use the buttons to toggle between pages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在上述HTML中，我们有三个按钮和三个div。目前，div中只包含一小部分文本，但我们可以想象每个div包含我们网站上的一页内容。现在，我们将添加一些JavaScript，允许我们使用按钮在页面之间切换。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![single page 1](../Images/20a5fe233e55ac123b46f6c785276fa6.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![单页1](../Images/20a5fe233e55ac123b46f6c785276fa6.png)'
- en: 'In many cases, it will be inefficient to load the entire contents of every
    page when we first visit a site, so we will need to use a server to access new
    data. For example, when you visit a news site, it would take far too long for
    the site to load if it had to load every single article it has available when
    you first visit the page. We can avoid this problem using a strategy similar to
    the one we used while loading currency exchange rates in the previous lecture.
    This time, we’ll take a look at using Django to send and receive information from
    our single page application. To show how this works, let’s take a look at a simple
    Django application. It has two URL patterns in `urls.py`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，当我们首次访问一个网站时，加载每一页的全部内容将是不高效的，因此我们需要使用服务器来访问新数据。例如，当你访问一个新闻网站时，如果它在你首次访问页面时必须加载所有可用的文章，那么网站加载将花费非常长的时间。我们可以通过使用与我们在前一次讲座中加载货币汇率时使用的类似策略来避免这个问题。这次，我们将探讨如何使用Django从我们的单页应用程序发送和接收信息。为了展示这是如何工作的，让我们看看一个简单的Django应用程序。它在`urls.py`中有两个URL模式：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And two corresponding routes in `views.py`. Notice that the `section` route
    takes in an integer, and then returns a string of text based on that integer as
    an HTTP Response.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`views.py`中的两个相应路由。请注意，`section`路由接受一个整数，然后根据该整数返回一个基于HTTP响应的文本字符串。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, within our `index.html` file, we’ll take advantage of AJAX, which we learned
    about last lecture, to make a request to the server to gain the text of a particular
    section and display it on the screen:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`index.html`文件中，我们将利用我们上次讲座中了解到的AJAX，向服务器发送请求以获取特定部分的文本并在屏幕上显示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Single page 2](../Images/527d6bb1c81f6b1383773e891e61cdcf.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![单页2](../Images/527d6bb1c81f6b1383773e891e61cdcf.png)'
- en: Now, we’ve created a site where we can load new data from a server without reloading
    our entire HTML page!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个网站，我们可以从服务器加载新数据，而无需重新加载整个HTML页面！
- en: 'One disadvantage of our site though is that the URL is now less informative.
    You’ll notice in the video above that the URL remains the same even when we switch
    from section to section. We can solve this problem using the [JavaScript History
    API](https://developer.mozilla.org/en-US/docs/Web/API/History_API). This API allows
    us to push information to our browser history and update the URL manually. Let’s
    take a look at how we can use this API. Imagine we have a Django project identical
    to the previous one, but this time we wish to alter our script to be employ the
    history API:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们网站的缺点是URL现在信息量较少。您会注意到在上面的视频中，即使我们从一个部分切换到另一个部分，URL仍然保持不变。我们可以使用[JavaScript历史API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)来解决这个问题。此API允许我们将信息推送到浏览器历史记录并手动更新URL。让我们看看我们如何使用此API。想象我们有一个与上一个项目相同的Django项目，但这次我们希望修改我们的脚本以使用历史API：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `showSection` function above, we employ the `history.pushState` function.
    This function adds a new element to our browsing history based on three arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的`showSection`函数中，我们使用了`history.pushState`函数。此函数根据三个参数向我们的浏览历史添加一个新元素：
- en: Any data associated with the state.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与状态相关的任何数据。
- en: A title parameter ignored by most web browsers
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数网络浏览器忽略的标题参数
- en: What should be displayed in the URL
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该显示在URL中的内容
- en: 'The other change we make in the above JavaScript is in setting the `onpopstate`
    parameter, which specifies what we should do when the user clicks the back arrow.
    In this case, we want to show the previous section when the button is pressed.
    Now, the site looks a little more user-friendly:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的JavaScript中，我们做的另一个更改是在设置`onpopstate`参数，该参数指定了当用户点击后退箭头时应执行的操作。在这种情况下，我们希望在按钮按下时显示上一个部分。现在，网站看起来更加用户友好：
- en: '![single page with URL change](../Images/8e3e8fa58620335d4bb3d0d83df3f3f3.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![单页URL更改](../Images/8e3e8fa58620335d4bb3d0d83df3f3f3.png)'
- en: Scroll
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动
- en: 'In order to update and access the browser history, we used an important JavaScript
    object known as the [window](https://www.w3schools.com/js/js_window.asp). There
    are some other properties of the window that we can use to make our sites look
    nicer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新和访问浏览器历史记录，我们使用了名为[window](https://www.w3schools.com/js/js_window.asp)的重要JavaScript对象。窗口还有一些其他属性，我们可以使用它们来使我们的网站看起来更美观：
- en: '`window.innerWidth`: Width of window in pixels'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.innerWidth`：窗口的像素宽度'
- en: '`window.innerHeight`: Height of window in pixels'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.innerHeight`：窗口的像素高度'
- en: '![inner measures](../Images/c0dfbeb4f5985c265c222397cff6e676.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![内部尺寸](../Images/c0dfbeb4f5985c265c222397cff6e676.png)'
- en: 'While the window represents what is currently visible to the user, the [document](https://www.w3schools.com/js/js_htmldom_document.asp)
    refers to the entire web page, which is often much larger than the window, forcing
    the user to scroll up and down to see the page’s contents. To work with our scrolling,
    we have access to other variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的窗口代表用户当前可见的内容，而[document](https://www.w3schools.com/js/js_htmldom_document.asp)则指整个网页，通常比窗口大得多，迫使用户滚动上下才能看到页面内容。为了处理滚动，我们可以访问其他变量：
- en: '`window.scrollY`: How many pixels we have scrolled from the top of the page'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.scrollY`：我们从页面顶部滚动的像素数'
- en: '`document.body.offsetHeight`: The height in pixels of the entire document.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.body.offsetHeight`：整个文档的像素高度。'
- en: '![Scrolling measures](../Images/3729d8a5bf9c7a545824ef095f353cef.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![滚动尺寸](../Images/3729d8a5bf9c7a545824ef095f353cef.png)'
- en: 'We can use these measures to determine whether or not the user has scrolled
    to the end of a page using the comparison `window.scrollY + window.innerHeight
    >= document.body.offsetHeight`. The following page, for example, will change the
    backgroud color to green when we reach the bottom of a page:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些措施来确定用户是否已经滚动到页面的底部，使用比较 `window.scrollY + window.innerHeight >= document.body.offsetHeight`。例如，以下页面将在我们到达页面底部时将背景颜色更改为绿色：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![scroll green white](../Images/41e74504626e4be5f14a87e3bf3ed6b8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![滚动绿色白色](../Images/41e74504626e4be5f14a87e3bf3ed6b8.png)'
- en: Infinite Scroll
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限滚动
- en: Changing the background color at the end of the page probably isn’t all that
    useful, but we may want to detect that we’re at the end of the page if we want
    to implement **infinite scroll**. For example, if you’re on a social media site,
    you don’t want to have to load all posts at once, you might want to load the first
    ten, and then when the user reaches the bottom, load the next ten. Let’s take
    a look at a Django application that could do this. This app has two paths in `urls.py`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面底部更改背景颜色可能并不那么有用，但如果我们想实现 **无限滚动**，我们可能需要检测我们是否到达了页面的底部。例如，如果你在一个社交媒体网站上，你不想一次性加载所有帖子，你可能想先加载前十个，然后当用户到达底部时再加载下一个十个。让我们看看一个可以实现这一功能的
    Django 应用程序。这个应用程序在 `urls.py` 中有两个路径
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And two corresponding views in `views.py`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `views.py` 中的两个相应视图：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that the `posts` view requires two arguments: a `start` point and an
    `end` point. In this view, we’ve created our own **API**, which we can test out
    by visiting the url `localhost:8000/posts?start=10&end=15`, which returns the
    following JSON:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`posts` 视图需要两个参数：一个 `start` 点和一个 `end` 点。在这个视图中，我们创建了自己的 **API**，可以通过访问网址
    `localhost:8000/posts?start=10&end=15` 来测试，它返回以下 JSON：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, in the `index.html` template that the site loads, we start out with only
    an empty `div` in the body and some styling. Notice that we load our static files
    at the beginning, and then we reference a JavaScript file within our `static`
    folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在网站加载的 `index.html` 模板中，我们一开始在主体中只有一个空的 `div` 和一些样式。注意，我们在开始时加载了静态文件，然后在我们
    `static` 文件夹中引用了一个 JavaScript 文件。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now with JavaScript, we’ll wait until a user scrolls to the end of the page
    and then load more posts using our API:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 JavaScript，我们将等待用户滚动到页面底部，然后使用我们的 API 加载更多帖子：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we’ve created a site with infinite scroll!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个具有无限滚动的网站！
- en: '![infinite scroll](../Images/e2daba25c0aa3a59860804d1ea989160.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![无限滚动](../Images/e2daba25c0aa3a59860804d1ea989160.png)'
- en: Animation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: Another way we can make our sites a bit more interesting is by adding some animation
    to them. It turns out that in addition to providing styling, CSS makes it easy
    for us to animate HTML elements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过添加一些动画来使我们的网站更有趣。事实证明，除了提供样式外，CSS 还使我们能够轻松地动画化 HTML 元素。
- en: 'To create an animation in CSS, we use the format below, where the animation
    specifics can include starting and ending styles (`to` and `from`) or styles at
    different stages in the duration (anywhere from `0%` to `100%`). For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 CSS 中创建动画，我们使用以下格式，其中动画的具体内容可以包括起始和结束样式（`to` 和 `from`）或持续时间不同阶段的样式（从 `0%`
    到 `100%`）。例如：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'or:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, to apply an animation to an element, we include the `animation-name`,
    the `animation-duration` (in seconds), and the `animation-fill-mode` (typically
    `forwards`). For example, here’s a page where a title grows when we first enter
    the page:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了对一个元素应用动画，我们需要包含 `animation-name`、`animation-duration`（以秒为单位）和 `animation-fill-mode`（通常是
    `forwards`）。例如，以下是一个页面，当第一次进入页面时标题会变大：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Growing title](../Images/c6933917073c9bd6b89c6d8bd577a65e.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![增长标题](../Images/c6933917073c9bd6b89c6d8bd577a65e.png)'
- en: 'We can do more than just manipulate size: the below example shows how we can
    change the position of a heading just by changing a few lines:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以操纵大小：以下示例展示了我们如何通过更改几行来改变标题的位置：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Moving header](../Images/d40f9ac6e9e24b7be4f3fe8c43762f8f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![移动标题](../Images/d40f9ac6e9e24b7be4f3fe8c43762f8f.png)'
- en: Now, let’s look at setting some intermediate CSS properties as well. We can
    specify the style at any percentage of the way through an animation. In the below
    example we’ll move the title from left to right, and then back to left by altering
    only the animation from above
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看设置一些中间 CSS 属性。我们可以在动画的任何百分比处指定样式。在以下示例中，我们将标题从左到右移动，然后通过仅更改上面的动画将其移回左方
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![back and forth](../Images/264eb9573fdeff6c69a0dc3e89159919.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![前后滚动](../Images/264eb9573fdeff6c69a0dc3e89159919.png)'
- en: If we want to repeat an animation multiple times, we can change the `animation-iteration-count`
    to a number higher than one (or even `infinite` for endless animation). There
    are many [animation properties](https://www.w3schools.com/cssref/css3_pr_animation.asp)
    that we can set in order to change different aspects of our animation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重复动画多次，可以将`animation-iteration-count`属性更改为大于一的数字（甚至可以设置为`infinite`以实现无限动画）。我们可以设置许多[动画属性](https://www.w3schools.com/cssref/css3_pr_animation.asp)，以改变动画的不同方面。
- en: 'In addition to CSS, we can use JavaScript to further control our animations.
    Let’s use our moving header example (with infinite repetition) to show how we
    can create a button that starts and stops the animation. Assuming we already have
    an animation, button, and heading, we can add the following script to start and
    pause the animation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CSS之外，我们还可以使用JavaScript进一步控制动画。让我们使用我们的移动标题示例（具有无限重复）来展示我们如何创建一个开始和停止动画的按钮。假设我们已经有了一个动画、按钮和标题，我们可以添加以下脚本以开始和暂停动画：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![play/pause animation](../Images/dca0932bfcb81cfc849afdf63a13a776.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![播放/暂停动画](../Images/dca0932bfcb81cfc849afdf63a13a776.png)'
- en: 'Now, let’s look at how we can apply our new knowledge of animations to the
    posts page we made earlier. Specifically, let’s say we want the ability to hide
    posts once we’re done reading them. Let’s imagine a Django project identical to
    the one we just created, but with some slightly different HTML and JavaScript.
    The first change we’ll make is to the `add_post` function, this time also adding
    a button to the right side of the post:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将我们对动画的新知识应用到我们之前制作的帖子页面。具体来说，假设我们希望在阅读完帖子后能够隐藏帖子。让我们想象一个与刚刚创建的项目相同的Django项目，但有一些HTML和JavaScript的细微差别。我们将做的第一个更改是修改`add_post`函数，这次也在帖子的右侧添加了一个按钮：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we’ll work on hiding a post when the `hide` button is clicked. To do this,
    we’ll add an event listener that is triggered whenever a user clicks anywhere
    on the page. We then write a function that takes in the `event` as an argument,
    which is useful because we can use the `event.target` attribute to access what
    was clicked on. We can also use the `parentElement` class to find the parent of
    a given element in the DOM.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理在点击“隐藏”按钮时隐藏帖子。为此，我们将添加一个事件监听器，它在用户点击页面上的任何地方时被触发。然后我们编写一个函数，该函数接受`event`作为参数，这很有用，因为我们可以使用`event.target`属性来访问被点击的元素。我们还可以使用`parentElement`类在DOM中找到给定元素的父元素。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![naive hide](../Images/f1ded33c4614e12e0848d8166b281395.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![简单的隐藏](../Images/f1ded33c4614e12e0848d8166b281395.png)'
- en: We can now see that we’ve implemented the hide button, but it doesn’t look as
    nice as it possible could. Maybe we want to have the post fade away and shrink
    before we remove it. In order to do this, we’ll first create a CSS animation.
    The animation below will spend 75% of its time changing the `opacity` from 1 to
    0, which esentially makes the post fade out slowly. It then spends the rest of
    the time moving all of its `height`-related attributes to 0, effectively shrinking
    the post to nothing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到我们已经实现了隐藏按钮，但它看起来并没有可能那么漂亮。也许我们希望帖子在移除之前先淡出并缩小。为了做到这一点，我们首先创建一个CSS动画。下面的动画将花费75%的时间将`opacity`从1变为0，这本质上使得帖子缓慢淡出。然后，它将剩余的时间将所有与`height`相关的属性移动到0，有效地将帖子缩小到无。
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we would add this animation to our post’s CSS. Notice that we initially
    set the `animation-play-state` to `paused`, meaning the post will not be hidden
    by default.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加此动画到我们帖子的CSS中。注意，我们最初将`animation-play-state`设置为`paused`，这意味着帖子默认不会隐藏。
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we want to be able to start the animation once the `hide` button has
    been clicked, and then remove the post. We can do this by editing our JavaScript
    from above:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望在点击“隐藏”按钮后开始动画，然后移除帖子。我们可以通过编辑上面的JavaScript来实现这一点：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Pretty hide](../Images/05fdcdb490a4a2c8fafadbf8cbf4bd71.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![漂亮的隐藏](../Images/05fdcdb490a4a2c8fafadbf8cbf4bd71.png)'
- en: As you can see above, the hide functionality now looks a lot nicer!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，隐藏功能现在看起来好多了！
- en: React
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: At this point, you can imagine how much JavaScript code would have to go into
    a more complicated website. We can mitigate how much code we actually need to
    write by employing a JavaScript framework, just as we employed Bootstrap as a
    CSS framework to cut down on the amount of CSS we actually had to write. One of
    the most popular JavaScript frameworks is a library called [React](https://reactjs.org/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以想象在一个更复杂的网站上需要多少JavaScript代码。我们可以通过使用JavaScript框架来减轻我们实际上需要编写的代码量，就像我们使用Bootstrap作为CSS框架来减少我们实际上需要编写的CSS量一样。最受欢迎的JavaScript框架之一是一个名为[React](https://reactjs.org/)的库。
- en: 'So far in this course, we’ve been using **imperative programming** methods,
    where we give the computer a set of statements to execute. For example, to update
    the counter in an HTML page we might have have code that looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个课程中，我们一直在使用**命令式编程**方法，其中我们给计算机一组要执行的语句。例如，为了更新HTML页面中的计数器，我们可能有一段看起来像这样的代码：
- en: 'View:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看视图：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Logic:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'React allows us to use **declarative programming**, which will allow us to
    simply write code explaining *what* we wish to display and not worry about *how*
    we’re displaying it. In React, a counter might look a bit more like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: React允许我们使用**声明式编程**，这将使我们能够简单地编写代码来解释我们希望显示的内容，而不用担心**如何**显示它。在React中，计数器可能看起来更像是这样：
- en: 'View:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 查看视图：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Logic:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The React framework is built around the idea of components, each of which can
    have an underlying state. A component would be something you can see on a web
    page like a post or a navigation bar, and a state is a set of variables associated
    with that component. The beauty of React is that when the state changes, React
    will automatically change the DOM accordingly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: React框架围绕组件的概念构建，每个组件都可以有一个底层状态。组件可以是网页上可见的任何东西，比如帖子或导航栏，而状态是与该组件相关的一组变量。React的美丽之处在于，当状态发生变化时，React会自动相应地更改DOM。
- en: 'There are a number of ways to use React, (including the popular [create-react-app](https://reactjs.org/docs/create-a-new-react-app.html)
    command published by Facebook) but today we’ll focus on getting started directly
    in an HTML file. To do this, we’ll have to import three JavaScript Packages:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种使用React的方法（包括Facebook发布的流行[create-react-app](https://reactjs.org/docs/create-a-new-react-app.html)命令），但今天我们将专注于直接在HTML文件中开始。为此，我们必须导入三个JavaScript包：
- en: '`React`: Defines components and their behavior'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React`：定义组件及其行为'
- en: '`ReactDOM`: Takes React components and inserts them into the DOM'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReactDOM`：将React组件插入到DOM中'
- en: '`Babel`: Translates from [JSX](https://reactjs.org/docs/introducing-jsx.html),
    the language in which we’ll write in React, to plain JavaScript that our browsers
    can interpret. JSX is very similar to JavaScript, but with some additional features,
    including the ability to represent HTML inside of our code.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Babel`：将[JSX](https://reactjs.org/docs/introducing-jsx.html)，我们在React中使用的语言，转换为浏览器可以解释的纯JavaScript。JSX与JavaScript非常相似，但有一些额外的功能，包括在代码中表示HTML的能力。'
- en: Let’s dive in and create our first React application!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入其中，创建我们的第一个React应用！
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since this is our first React app, let’s take a detailed look at what each
    part of this code is doing:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一个React应用，让我们详细看看这段代码的每个部分都在做什么：
- en: In the three lines above the title, we import the latest versions of React,
    ReactDOM, and Babel.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标题上方三行中，我们导入React、ReactDOM和Babel的最新版本。
- en: In the body, we include a single `div` with an `id` of `app`. We almost always
    want to leave this empty, and fill it in our react code below.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主体中，我们包含一个具有`id`为`app`的单个`div`。我们几乎总是想留空，并在下面的React代码中填充。
- en: We include a script tag where we specify that `type="text/babel"`. This signals
    to the browser that the following script needs to be translated using Babel.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们包含一个脚本标签，指定`type="text/babel"`。这向浏览器发出信号，表示以下脚本需要使用Babel进行翻译。
- en: Next, we create a component called `App`. Components in React can be represented
    by JavaScript functions.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`App`的组件。React中的组件可以用JavaScript函数表示。
- en: Our component returns what we would like to render to the DOM. In this case,
    we simply return `<div>Hello!</div>`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的组件返回我们想要渲染到DOM中的内容。在这种情况下，我们简单地返回`<div>Hello!</div>`。
- en: 'The last line of our script employs the `ReactDOM.render` function, which takes
    two arguments:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们脚本中的最后一行使用了`ReactDOM.render`函数，它接受两个参数：
- en: A component to render
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个要渲染的组件
- en: An element in the DOM inside of which the component should be rendered
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM中的一个元素，其中应该渲染组件
- en: 'Now that we understand what the code is doing, we can take a look at the resulting
    webpage:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了代码的作用，我们可以看看生成的网页：
- en: '![welcome hello react](../Images/7979fd150f1abcf32b243cba0c57f3b6.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![欢迎hello react](../Images/7979fd150f1abcf32b243cba0c57f3b6.png)'
- en: 'One useful feature of React is the ability to render components within other
    components. To demonstrate this, let’s create another component called `Hello`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: React的一个有用特性是能够在其他组件内渲染组件。为了演示这一点，让我们创建另一个名为`Hello`的组件：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now, let’s render three `Hello` components inside of our `App` component:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`App`组件内部渲染三个`Hello`组件：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This gives us a page that looks like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个看起来像这样的页面：
- en: '![Three hellos](../Images/d3a029af49c9cf1b3d8c4847b3fdc5de.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![三个hello](../Images/d3a029af49c9cf1b3d8c4847b3fdc5de.png)'
- en: 'So far, the components haven’t been all that interesting, as they are all exactly
    the same. We can make these components more flexible by adding additional properties
    (**props** in React terms) to them. For example, let’s say we wish to say hello
    to three different people. We can provide those people’s names in a method that
    looks similar to HTML attributes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，组件并没有那么有趣，因为它们都是完全相同的。我们可以通过为它们添加额外的属性（在React术语中称为**props**）来使这些组件更加灵活。例如，假设我们希望向三个人打招呼。我们可以在一个类似于HTML属性的方法中提供这些人的名字：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can then access those props using `props.PROP_NAME`. We can then insert
    this into our JSX using curly braces:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`props.PROP_NAME`来访问这些props。然后我们可以使用花括号将其插入到我们的JSX中：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, our page displays the three names!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的页面显示了三个名字！
- en: '![Three names](../Images/a826990a001a69d5b3df7fcd9e1dfc23.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![三个名字](../Images/a826990a001a69d5b3df7fcd9e1dfc23.png)'
- en: Now, let’s see how we can use React to re-implement the counter page we built
    when first working with JavaScript. Our overall structure will remain the same,
    but inside of our `App` component, we’ll use React’s `useState` hook to add state
    to our component. The argument to `useState` is the initial value of the state,
    which we’ll set to `0`. The function returns both a variable representing the
    state and a function that allows us to update the state.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用React重新实现我们在首次使用JavaScript时构建的计数器页面。我们的整体结构将保持不变，但在我们的`App`组件内部，我们将使用React的`useState`钩子为我们的组件添加状态。`useState`的参数是状态的初始值，我们将将其设置为`0`。该函数返回表示状态的变量和一个允许我们更新状态的函数。
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can work on what the function will render, where we’ll specify a header
    and a button. We’ll also add an event listener for when the button is clicked,
    which React handles using the `onClick` attribute:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以工作于函数将渲染的内容，我们将指定一个标题和一个按钮。我们还将添加一个事件监听器，当按钮被点击时，React使用`onClick`属性来处理：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, let’s define the `updateCount` function. To do this, we’ll use the
    `setCount` function, which can take as argument a new value for the state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义`updateCount`函数。为此，我们将使用`setCount`函数，它可以接受作为状态的新值作为参数。
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we have a functioning counter site!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能齐全的计数器网站！
- en: '![counter](../Images/364745324207f901f3ccfc1dd6e97a62.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![计数器](../Images/364745324207f901f3ccfc1dd6e97a62.png)'
- en: Addition
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法
- en: 'Now that we have a feel for the React framework, let’s work on using what we’ve
    learned to build a game-like site where users will solve addition problems. We’ll
    begin by creating a new file with the same setup as our other React pages. To
    start building this application, let’s think about what we might want to keep
    track of in the state. We should include anything that we think might change while
    a user is on our page. Our state might include:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对React框架有了感觉，让我们利用所学知识来构建一个类似游戏的网站，用户将在网站上解决加法问题。我们将首先创建一个与我们的其他React页面设置相同的文件。为了开始构建这个应用程序，让我们思考我们可能想要在状态中跟踪的内容。我们应该包括任何我们认为用户在我们页面上可能会改变的内容。我们的状态可能包括：
- en: '`num1`: The first number to be added'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num1`：要相加的第一个数字'
- en: '`num2`: The second number to be added'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num2`：要相加的第二个数字'
- en: '`response`: What the user has typed in'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`：用户输入的内容'
- en: '`score`: How many questions the user has answered correctly.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`：用户回答正确的题目数量。'
- en: 'Now, our state can be a JavaScript object that includes all of this information:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的状态可以是一个包含所有这些信息的JavaScript对象：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, using the values in the state, we can render a basic user interface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用状态中的值，我们可以渲染一个基本的用户界面。
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, the basic layout of the site looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网站的基本布局看起来像这样：
- en: '![Addition layout](../Images/35aeee728670cbdcbba7c165643011be.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![加法布局](../Images/35aeee728670cbdcbba7c165643011be.png)'
- en: At this point, the user cannot type anything in the input box because its value
    is fixed as `state.response` which is currently the empty string. To fix this,
    let’s add an `onChange` attribute to the input element, and set it equal to a
    function called `updateResponse`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，用户无法在输入框中输入任何内容，因为它的值被固定为`state.response`，当前是空字符串。为了解决这个问题，让我们给输入元素添加一个`onChange`属性，并将其设置为名为`updateResponse`的函数。
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we’ll have to define the `updateResposne` function, which takes in the
    event that triggered the function, and sets the `response` to the current value
    of the input. This function allows the user to type, and stores whatever has been
    typed in the `state`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义`updateResposne`函数，它接受触发函数的事件，并将`response`设置为输入的当前值。这个函数允许用户输入，并将输入的内容存储在`state`中。
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let’s add the ability for a user to submit a problem. We’ll first add
    another event listener and link it to a function we’ll write next:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加用户提交问题的功能。我们首先添加另一个事件监听器，并将其链接到我们将要编写的函数：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we’ll define the `inputKeyPress` function. In this function, we’ll first
    check whether the `Enter` key was pressed, and then check to see if the answer
    is correct. When the user is correct, we want to increase the score by 1, choose
    random numbers for the next problem, and clear the response. If the answer is
    incorrect, we want to decrease the score by 1 and clear the response.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义`inputKeyPress`函数。在这个函数中，我们首先检查是否按下了`Enter`键，然后检查答案是否正确。当用户回答正确时，我们希望增加1分，为下一个问题选择随机数字，并清除响应。如果答案不正确，我们希望减少1分并清除响应。
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To put some finishing touches on the application, let’s add some style to the
    page. We’ll center everything in the app, and then make the problem larger by
    adding an `id` of `problem` to the div containing the problem, and then adding
    the following CSS to a style tag:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给应用程序添加一些收尾工作，让我们给页面添加一些样式。我们将使应用中的所有内容居中，然后通过给包含问题的div添加`id`为`problem`，并添加以下CSS到样式标签来使问题更大：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, let’s add the ability to win the game after gaining 10 points. To
    do this, we’ll add a condition to the `render` funciton, returning something completely
    different once we have 10 points:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加在获得10分后赢得游戏的能力。为此，我们将在`render`函数中添加一个条件，一旦我们获得10分，就返回完全不同的内容：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make the win more exciting, we’ll add some style to the alternative div
    as well:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使胜利更加激动人心，我们还将给替代div添加一些样式：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let’s take a look at our application!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的应用程序！
- en: '![finished](../Images/339011add8bbed54b725a008cc02d264.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![finished](../Images/339011add8bbed54b725a008cc02d264.png)'
- en: That’s all for lecture today! Next time, we’ll talk about some best practices
    for building larger web applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的内容就到这里！下次，我们将讨论构建大型Web应用程序的一些最佳实践。
