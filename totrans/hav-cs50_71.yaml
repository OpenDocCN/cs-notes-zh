- en: Lecture 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/web/notes/6/](https://cs50.harvard.edu/web/notes/6/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Introduction](#introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[User Interfaces](#user-interfaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Single Page Applications](#single-page-applications)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Scroll](#scroll)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Infinite Scroll](#infinite-scroll)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Animation](#animation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[React](#react)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Addition](#addition)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve discussed how to build simple web pages using HTML and CSS, and
    how to use Git and GitHub in order to keep track of changes to our code and collaborate
    with others. We also familiarized ourselves with the Python programming language,
    started using Django to create web applications, and learned how to use Django
    models to store information in our sites. We then introduced JavaScript and learned
    how to use it to make web pages more interactive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we’ll discuss common paradigms in User Interface design, using JavaScript
    and CSS to make our sites even more user friendly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A User Interface is how visitors to a web page interact with that page. Our
    goal as web developers is to make these interactions as pleasant as possible for
    the user, and there are many methods we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Single Page Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, if we wanted a website with multiple pages, we would accomplish
    that using different routes in our Django application. Now, we have the ability
    to load just a single page and then use JavaScript to manipulate the DOM. One
    major advantage of doing this is that we only need to modify the part of the page
    that is actually changing. For example, if we have a Nav Bar that doesn’t change
    based on your current page, we wouldn’t want to have to re-render that Nav Bar
    every time we switch to a new part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how we could simulate page switching in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the HTML above that we have three buttons and three divs. At the moment,
    the divs contain only a small bit of text, but we could imagine each div containing
    the contents of one page on our site. Now, we’ll add some JavaScript that allows
    us to use the buttons to toggle between pages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![single page 1](../Images/20a5fe233e55ac123b46f6c785276fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In many cases, it will be inefficient to load the entire contents of every
    page when we first visit a site, so we will need to use a server to access new
    data. For example, when you visit a news site, it would take far too long for
    the site to load if it had to load every single article it has available when
    you first visit the page. We can avoid this problem using a strategy similar to
    the one we used while loading currency exchange rates in the previous lecture.
    This time, we’ll take a look at using Django to send and receive information from
    our single page application. To show how this works, let’s take a look at a simple
    Django application. It has two URL patterns in `urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And two corresponding routes in `views.py`. Notice that the `section` route
    takes in an integer, and then returns a string of text based on that integer as
    an HTTP Response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within our `index.html` file, we’ll take advantage of AJAX, which we learned
    about last lecture, to make a request to the server to gain the text of a particular
    section and display it on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Single page 2](../Images/527d6bb1c81f6b1383773e891e61cdcf.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we’ve created a site where we can load new data from a server without reloading
    our entire HTML page!
  prefs: []
  type: TYPE_NORMAL
- en: 'One disadvantage of our site though is that the URL is now less informative.
    You’ll notice in the video above that the URL remains the same even when we switch
    from section to section. We can solve this problem using the [JavaScript History
    API](https://developer.mozilla.org/en-US/docs/Web/API/History_API). This API allows
    us to push information to our browser history and update the URL manually. Let’s
    take a look at how we can use this API. Imagine we have a Django project identical
    to the previous one, but this time we wish to alter our script to be employ the
    history API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `showSection` function above, we employ the `history.pushState` function.
    This function adds a new element to our browsing history based on three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Any data associated with the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A title parameter ignored by most web browsers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should be displayed in the URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other change we make in the above JavaScript is in setting the `onpopstate`
    parameter, which specifies what we should do when the user clicks the back arrow.
    In this case, we want to show the previous section when the button is pressed.
    Now, the site looks a little more user-friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![single page with URL change](../Images/8e3e8fa58620335d4bb3d0d83df3f3f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Scroll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to update and access the browser history, we used an important JavaScript
    object known as the [window](https://www.w3schools.com/js/js_window.asp). There
    are some other properties of the window that we can use to make our sites look
    nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`window.innerWidth`: Width of window in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.innerHeight`: Height of window in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![inner measures](../Images/c0dfbeb4f5985c265c222397cff6e676.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While the window represents what is currently visible to the user, the [document](https://www.w3schools.com/js/js_htmldom_document.asp)
    refers to the entire web page, which is often much larger than the window, forcing
    the user to scroll up and down to see the page’s contents. To work with our scrolling,
    we have access to other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`window.scrollY`: How many pixels we have scrolled from the top of the page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document.body.offsetHeight`: The height in pixels of the entire document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Scrolling measures](../Images/3729d8a5bf9c7a545824ef095f353cef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use these measures to determine whether or not the user has scrolled
    to the end of a page using the comparison `window.scrollY + window.innerHeight
    >= document.body.offsetHeight`. The following page, for example, will change the
    backgroud color to green when we reach the bottom of a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![scroll green white](../Images/41e74504626e4be5f14a87e3bf3ed6b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Infinite Scroll
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing the background color at the end of the page probably isn’t all that
    useful, but we may want to detect that we’re at the end of the page if we want
    to implement **infinite scroll**. For example, if you’re on a social media site,
    you don’t want to have to load all posts at once, you might want to load the first
    ten, and then when the user reaches the bottom, load the next ten. Let’s take
    a look at a Django application that could do this. This app has two paths in `urls.py`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And two corresponding views in `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `posts` view requires two arguments: a `start` point and an
    `end` point. In this view, we’ve created our own **API**, which we can test out
    by visiting the url `localhost:8000/posts?start=10&end=15`, which returns the
    following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `index.html` template that the site loads, we start out with only
    an empty `div` in the body and some styling. Notice that we load our static files
    at the beginning, and then we reference a JavaScript file within our `static`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with JavaScript, we’ll wait until a user scrolls to the end of the page
    and then load more posts using our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ve created a site with infinite scroll!
  prefs: []
  type: TYPE_NORMAL
- en: '![infinite scroll](../Images/e2daba25c0aa3a59860804d1ea989160.png)'
  prefs: []
  type: TYPE_IMG
- en: Animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way we can make our sites a bit more interesting is by adding some animation
    to them. It turns out that in addition to providing styling, CSS makes it easy
    for us to animate HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an animation in CSS, we use the format below, where the animation
    specifics can include starting and ending styles (`to` and `from`) or styles at
    different stages in the duration (anywhere from `0%` to `100%`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to apply an animation to an element, we include the `animation-name`,
    the `animation-duration` (in seconds), and the `animation-fill-mode` (typically
    `forwards`). For example, here’s a page where a title grows when we first enter
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Growing title](../Images/c6933917073c9bd6b89c6d8bd577a65e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can do more than just manipulate size: the below example shows how we can
    change the position of a heading just by changing a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Moving header](../Images/d40f9ac6e9e24b7be4f3fe8c43762f8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s look at setting some intermediate CSS properties as well. We can
    specify the style at any percentage of the way through an animation. In the below
    example we’ll move the title from left to right, and then back to left by altering
    only the animation from above
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![back and forth](../Images/264eb9573fdeff6c69a0dc3e89159919.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want to repeat an animation multiple times, we can change the `animation-iteration-count`
    to a number higher than one (or even `infinite` for endless animation). There
    are many [animation properties](https://www.w3schools.com/cssref/css3_pr_animation.asp)
    that we can set in order to change different aspects of our animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to CSS, we can use JavaScript to further control our animations.
    Let’s use our moving header example (with infinite repetition) to show how we
    can create a button that starts and stops the animation. Assuming we already have
    an animation, button, and heading, we can add the following script to start and
    pause the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![play/pause animation](../Images/dca0932bfcb81cfc849afdf63a13a776.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s look at how we can apply our new knowledge of animations to the
    posts page we made earlier. Specifically, let’s say we want the ability to hide
    posts once we’re done reading them. Let’s imagine a Django project identical to
    the one we just created, but with some slightly different HTML and JavaScript.
    The first change we’ll make is to the `add_post` function, this time also adding
    a button to the right side of the post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll work on hiding a post when the `hide` button is clicked. To do this,
    we’ll add an event listener that is triggered whenever a user clicks anywhere
    on the page. We then write a function that takes in the `event` as an argument,
    which is useful because we can use the `event.target` attribute to access what
    was clicked on. We can also use the `parentElement` class to find the parent of
    a given element in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![naive hide](../Images/f1ded33c4614e12e0848d8166b281395.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now see that we’ve implemented the hide button, but it doesn’t look as
    nice as it possible could. Maybe we want to have the post fade away and shrink
    before we remove it. In order to do this, we’ll first create a CSS animation.
    The animation below will spend 75% of its time changing the `opacity` from 1 to
    0, which esentially makes the post fade out slowly. It then spends the rest of
    the time moving all of its `height`-related attributes to 0, effectively shrinking
    the post to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we would add this animation to our post’s CSS. Notice that we initially
    set the `animation-play-state` to `paused`, meaning the post will not be hidden
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to be able to start the animation once the `hide` button has
    been clicked, and then remove the post. We can do this by editing our JavaScript
    from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Pretty hide](../Images/05fdcdb490a4a2c8fafadbf8cbf4bd71.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see above, the hide functionality now looks a lot nicer!
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you can imagine how much JavaScript code would have to go into
    a more complicated website. We can mitigate how much code we actually need to
    write by employing a JavaScript framework, just as we employed Bootstrap as a
    CSS framework to cut down on the amount of CSS we actually had to write. One of
    the most popular JavaScript frameworks is a library called [React](https://reactjs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far in this course, we’ve been using **imperative programming** methods,
    where we give the computer a set of statements to execute. For example, to update
    the counter in an HTML page we might have have code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'React allows us to use **declarative programming**, which will allow us to
    simply write code explaining *what* we wish to display and not worry about *how*
    we’re displaying it. In React, a counter might look a bit more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The React framework is built around the idea of components, each of which can
    have an underlying state. A component would be something you can see on a web
    page like a post or a navigation bar, and a state is a set of variables associated
    with that component. The beauty of React is that when the state changes, React
    will automatically change the DOM accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to use React, (including the popular [create-react-app](https://reactjs.org/docs/create-a-new-react-app.html)
    command published by Facebook) but today we’ll focus on getting started directly
    in an HTML file. To do this, we’ll have to import three JavaScript Packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`React`: Defines components and their behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReactDOM`: Takes React components and inserts them into the DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Babel`: Translates from [JSX](https://reactjs.org/docs/introducing-jsx.html),
    the language in which we’ll write in React, to plain JavaScript that our browsers
    can interpret. JSX is very similar to JavaScript, but with some additional features,
    including the ability to represent HTML inside of our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dive in and create our first React application!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is our first React app, let’s take a detailed look at what each
    part of this code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: In the three lines above the title, we import the latest versions of React,
    ReactDOM, and Babel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the body, we include a single `div` with an `id` of `app`. We almost always
    want to leave this empty, and fill it in our react code below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We include a script tag where we specify that `type="text/babel"`. This signals
    to the browser that the following script needs to be translated using Babel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create a component called `App`. Components in React can be represented
    by JavaScript functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our component returns what we would like to render to the DOM. In this case,
    we simply return `<div>Hello!</div>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last line of our script employs the `ReactDOM.render` function, which takes
    two arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component to render
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An element in the DOM inside of which the component should be rendered
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we understand what the code is doing, we can take a look at the resulting
    webpage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![welcome hello react](../Images/7979fd150f1abcf32b243cba0c57f3b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One useful feature of React is the ability to render components within other
    components. To demonstrate this, let’s create another component called `Hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let’s render three `Hello` components inside of our `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a page that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three hellos](../Images/d3a029af49c9cf1b3d8c4847b3fdc5de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, the components haven’t been all that interesting, as they are all exactly
    the same. We can make these components more flexible by adding additional properties
    (**props** in React terms) to them. For example, let’s say we wish to say hello
    to three different people. We can provide those people’s names in a method that
    looks similar to HTML attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access those props using `props.PROP_NAME`. We can then insert
    this into our JSX using curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, our page displays the three names!
  prefs: []
  type: TYPE_NORMAL
- en: '![Three names](../Images/a826990a001a69d5b3df7fcd9e1dfc23.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s see how we can use React to re-implement the counter page we built
    when first working with JavaScript. Our overall structure will remain the same,
    but inside of our `App` component, we’ll use React’s `useState` hook to add state
    to our component. The argument to `useState` is the initial value of the state,
    which we’ll set to `0`. The function returns both a variable representing the
    state and a function that allows us to update the state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can work on what the function will render, where we’ll specify a header
    and a button. We’ll also add an event listener for when the button is clicked,
    which React handles using the `onClick` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s define the `updateCount` function. To do this, we’ll use the
    `setCount` function, which can take as argument a new value for the state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a functioning counter site!
  prefs: []
  type: TYPE_NORMAL
- en: '![counter](../Images/364745324207f901f3ccfc1dd6e97a62.png)'
  prefs: []
  type: TYPE_IMG
- en: Addition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a feel for the React framework, let’s work on using what we’ve
    learned to build a game-like site where users will solve addition problems. We’ll
    begin by creating a new file with the same setup as our other React pages. To
    start building this application, let’s think about what we might want to keep
    track of in the state. We should include anything that we think might change while
    a user is on our page. Our state might include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`num1`: The first number to be added'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num2`: The second number to be added'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response`: What the user has typed in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`score`: How many questions the user has answered correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, our state can be a JavaScript object that includes all of this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the values in the state, we can render a basic user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the basic layout of the site looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Addition layout](../Images/35aeee728670cbdcbba7c165643011be.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the user cannot type anything in the input box because its value
    is fixed as `state.response` which is currently the empty string. To fix this,
    let’s add an `onChange` attribute to the input element, and set it equal to a
    function called `updateResponse`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll have to define the `updateResposne` function, which takes in the
    event that triggered the function, and sets the `response` to the current value
    of the input. This function allows the user to type, and stores whatever has been
    typed in the `state`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add the ability for a user to submit a problem. We’ll first add
    another event listener and link it to a function we’ll write next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll define the `inputKeyPress` function. In this function, we’ll first
    check whether the `Enter` key was pressed, and then check to see if the answer
    is correct. When the user is correct, we want to increase the score by 1, choose
    random numbers for the next problem, and clear the response. If the answer is
    incorrect, we want to decrease the score by 1 and clear the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To put some finishing touches on the application, let’s add some style to the
    page. We’ll center everything in the app, and then make the problem larger by
    adding an `id` of `problem` to the div containing the problem, and then adding
    the following CSS to a style tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s add the ability to win the game after gaining 10 points. To
    do this, we’ll add a condition to the `render` funciton, returning something completely
    different once we have 10 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the win more exciting, we’ll add some style to the alternative div
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s take a look at our application!
  prefs: []
  type: TYPE_NORMAL
- en: '![finished](../Images/339011add8bbed54b725a008cc02d264.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all for lecture today! Next time, we’ll talk about some best practices
    for building larger web applications.
  prefs: []
  type: TYPE_NORMAL
