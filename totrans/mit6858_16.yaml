- en: User authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core challenge:** How can human users prove their identity to a program?'
  prefs: []
  type: TYPE_NORMAL
- en: Is there any solution that totally dominates passwords?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first glance, passwords seem wretched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low entropy `-->` easy for attackers to guess them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Back-up security questions for passwords are low entropy too.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A user often employs a single password for multiple sites.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As the paper for today's class states, *"The continued domination of passwords
    over all other methods of end-user authentication is a major embarrassment to
    security researchers."*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But... is there actually an authentication scheme which totally dominates passwords?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plan for today''s lecture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how current password schemes work.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Talk about desirable properties for an authentication scheme.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: See how other authentication schemes compare to passwords.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A password is a secret that is shared between the user and a server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Naive implementation:** server has a table that maps usernames to plaintext
    passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem:** If attacker compromises the server, can recover all user/password
    pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved solution:** Server stores this table: `user_name --> hash(user_password)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User client supplies cleartext password to server, the server hashes the cleartext
    and does a table lookup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advantage:** Hash functions are difficult to invert, so it''s difficult for
    attacker to perform a brute force attack. However...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem:** Attacker doesn''t have to launch an inefficient brute force search
    over all possible passwords -- the set of strings that are actually used as passwords
    is quite small!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skewed distribution: top 5000 password values cover 20% of users.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yahoo password study: Rule-of-thumb passwords contain 10-20 bits of entropy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash functions are optimized performance; this helps attackers!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:* A laptop can calcuate SHA1s over small blocks at ~2M SHA1 ops/sec.
    Even if password has 20 bits of entropy, can crack one account/sec.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server can use a computationally expensive *key-derivation function* (e.g.,
    PBKDF2 or BCrypt).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions have adjustable costs, so they can be arbitrarily slow.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ex: can make hash cost be 1 second -- O(1M) times slower than SHA1.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, often performs repeated hashing using a slow hash.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem:** adversary can build "rainbow tables".'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Table of password-to-hash mappings.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Expensive to compute, but allows the attacker to efficiently invert hashes afterwards.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To maximize cost/benefit trade-off, the attacker only need to build a rainbow
    table for dictionary of common passwords.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Roughly: 1-second expensive hash `|-> 1M seconds = 10 days` to hash common
    passwords. After that, can very quickly crack common passwords in any password
    db.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better solution:** server can use *password salts*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input some additional randomness into the password hash: H(salt, pw).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where does the salt value come from? It's stored on the server in plaintext.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Why is this better if the adversary can compromise the salt too?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** The attacker cannot use a single rainbow table to check for hash matches
    -- the same password with different salts will have a different hash value!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices:**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a long random salt.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a fresh salt each time user changes password.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How should a client *transmit a password to a server?*
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad idea:** send the password in the clear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slightly better:** send password over an encrypted connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drawback:** Connection may be intercepted by an attacker who pretends to
    be the server (encryption doesn''t necessarily mean that the server has authenticated
    to the client!). MITM attacker can then use the stolen password to impersonate
    the user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** What if client sends the hash of the password instead of the raw password?'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** Doesn''t provide us with any extra power, since the hash can still be
    replayed by the attacker.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moral of the story:** Encryption and hashing do not automatically add security
    -- you need to think about what security properties you want to achieve, and specific
    ways that encryption and hashing can achieve those goals.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better idea:** Challenge/response protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring man-in-the-middle (MITM) attacks, the server is now confident that
    the user is Alice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If server is an attacker and didn't already know password, the attacker still
    doesn't know password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** How can we prevent server from brute-force guessing password based on
    `H()` value?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A1:** Expensive hash + salting.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A2:** Allow client to choose some randomness too: guard against rainbow tables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid storing the real password on the server, use a protocol like [SRP](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-level idea:** Given a security parameter `g`, the client computes `v
    = g^(hash(salt, password))` and sends `v` and the `salt` to the server. The client
    and the server can then establish an ephemeral key with their shared knowledge
    of `g` and `v` (protocol takes advantage of the fact that it''s difficult for
    the attacker to perform discrete logarithms modulo `N`; RSA also takes advantage
    of this observation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing challenge/response often means changing the client and the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To prevent brute force attacks, we can implement *anti-hammering defenses*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: Rate-limit the number of password guesses; implement time-out periods
    after too many incorrect guesses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's really important to throttle guess rate because passwords have so little
    entropy!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many sites impose requirements on passwords (e.g., length, the use of special
    chars like punctuation).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In reality, what matters is *entropy*! Format requirements rarely translate
    into higher entropy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A competent dictionary attacker can model password constraints and still generate
    rainbow tables; even with constraints, people will still pick passwords that adhere
    to a priori character distributions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Telepathwords:* [https://telepathwords.research.microsoft.com/](https://telepathwords.research.microsoft.com/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you type in a potential password letter, tries to guess the next letter using
    heuristics!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Common passwords (e.g., via leaks of password databases)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular phrases from web sites
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Common user biases in selecting characters (e.g., using adjacent keys for adjacent
    password characters)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kerberos v4, and v5 without preauth were vulnerable to offline guessing: [http://www.gnu.org/software/shishi/wu99realworld.pdf](http://www.gnu.org/software/shishi/wu99realworld.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone could ask the KDC for a ticket encrypted with the user's password, i.e.,
    the KDC did not authenticate requests (although the response would be encrypted
    with `K_c`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacker can try brute-force to guess the user's password -- this is easy to
    parallelize. Since the ticket-granting-ticket has a known format, the attacker
    can determine when a decryption is successful.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Kerberos v5, ticket requestor must include `{ timestamp }_{K_c}` along with
    request, to prove knowledge of `K_c`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password recovery** is extremely important, but often overlooked.'
  prefs: []
  type: TYPE_NORMAL
- en: People often focus on the entropy of passwords, but if recovery questions can
    be used to reset passwords, the strength of a password authentication scheme is
    `min(password_entropy, recovery_question_entropy)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovery questions are often easily guessable. In one famous example, somebody
    got access to Sarah Palin's Yahoo address by guessing answers to her security
    questions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrinsically low entropy (*"What's your favorite color?" "What's the name of
    your best friend?"*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers leaked via social media profiles (*"What's your favorite movie?"*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-generated questions are typically easy to answer (*"What is 5 + 5?"*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The quest to replace passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the reading for today, the authors propose a bunch of factors that can be
    used to evaluate authentication schemes (the goal is to determine whether passwords
    are as bad as they seem). The authors consider three high-level metrics: usability,
    deployability, and security.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Usability:** How easy is it for users to interact with the authentication
    scheme?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Easy-to-Learn:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Users who don''t know the scheme can figure it out and learn it without too
    much trouble."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a key reason why password schemes are so popular!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Infrequent errors:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"The task that users must perform to log in usually succeeds when performed
    by a legitimate and honest user."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an important reason why users pick easy-to-guess passwords.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scalable-for-Users:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Using the scheme for hundreds of accounts does not increase the burden on
    the user."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '... explains why people often reuse passwords or create a simple per-site uniquifying
    scheme for a base password.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Easy recovery from loss of the authentication token:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A win for passwords -- they're easy to reset.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nothing to carry*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another win for passwords.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployability:** How easy is it to incorporate the authentication method
    into real systems?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Server-Compatible:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"At the verifier''s end, the scheme is compatible with text-based passwords.
    Providers don''t have to change their existing authentication setup to support
    the scheme."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Browser-Compatible:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Users don''t have to change their client to support the scheme. Schemes fail
    to provide this benefit if they require the installation of plugins or any kind
    of software whose installation requires administrative privileges."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessible:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Users who can use passwords are not prevented from using the scheme by disabilities
    or other physical (not cognitive) conditions."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deployability is extremely difficult: it''s difficult to get users or servers
    to update en masse!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords do well in this category by default, since the authors define "deployability"
    as how well a system integrates with current password infrastructure. However,
    passwords don't do very well in the next category...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security:** What kinds of attacks can the authentication scheme prevent?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Physical-Observation:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"An attacker cannot impersonate a user after observing them authenticate one
    or more times. We grant Quasi-Resilient-to- Physical-Observation if the scheme
    could be broken only by repeating the observation more than, say, 10-20 times.
    Attacks include shoulder surfing, filming the keyboard, recording keystroke sounds,
    or thermal imaging of keypad."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords fail this test, since, e.g., they can be captured by filming the keyboard
    or recording keystroke sounds.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Targeted-Impersonation:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"It is not possible for an acquanitance (or skilled investigator) to impersonate
    a specific user by exploiting knowledge of personal details (birth date, names
    of relatives etc.). Personal knowledge questions are the canonical scheme that
    fails on this point."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The authors say that passwords are "quasi-resistant" b/c they couldn't find
    any studies saying that your friends or acquaintances can easily guess your password.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Throttled-Guessing:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"An attacker whose rate of guessing is constrained by the verifier cannot successfully
    guess the secrets of a significant fraction of users . . . Lack of this benefit
    is meant to penalize schemes in which it is frequent for user-chosen secrets to
    be selected from a small and well-known subset."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords fail because they have low entropy + skewed distributions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Unthrottled-Guessing:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"An attacker whose rate of guessing is constrained only by available computing
    resources cannot successfully guess the secrets of a significant fraction of users.
    We might for example grant this benefit if an attacker capable of attempting up
    to 2^40 or even 2^64 guesses per account could still only reach fewer than 1%
    of accounts. Lack of this benefit is meant to penalize schemes where the space
    of credentials is not large enough to withstand brute force search from a small
    and well-known subset."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords fail because they have low entropy + skewed distributions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Internal-Observation:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"An attacker cannot impersonate a user by intercepting the user''s input from
    inside the user''s device (e.g., by keylogging malware) or eavesdropping on the
    cleartext communication between prover and verifier (we assume that the attacker
    can also defeat TLS if it is used, perhaps through the CA) . . . This penalizes
    schemes that are not replay-resistant, whether because they send a static response
    or because their dynamic response countermeasure can be cracked with a few observations.
    This benefit assumes that general-purpose devices like software-updatable personal
    computers and mobile phones may contain malware, but that hardware devices dedicated
    exclusively to the scheme can be made malware-free."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passwords fail because they are static tokens: once you have one, you can use
    it until it expires or is revoked.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Phishing:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"An attacker who simulates a valid verifier (including by DNS manipulation)
    cannot collect credentials that can later be used to impersonate the user to the
    actual verifier. This penalizes schemes allowing phishers to get victims to authenticate
    to look-alike sites and later use the harvested credentials against the genuine
    sites."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passwords fail: phishing attacks are very common!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*No-Trusted-Third-Party:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"The scheme does not rely on a trusted third party (other than the prover and
    the verifier) who could, upon being attacked or otherwise becoming untrustworthy,
    compromise the prover''s security or privacy."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This property makes an important point: a lot of authentication problems would
    become easier if we could just trust one party to store passwords, run the password
    servers, etc. However, single points of failure are bad, since attackers can focus
    all of their energy on that point!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resilient-to-Leaks-from-Other-Verifiers:*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Nothing that a verifier could possibly leak can help an attacker impersonate
    the user to another verifier. This penalizes schemes where insider fraud at one
    provider, or a successful attack on one back-end, endangers the user''s accounts
    at other sites."'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This property is related to No-Trusted-Third-Party. To avoid a central point
    of failure, we''d like to introduced some notion of distributed authentication:
    however, does this mean that the system is only as strong as its weakest link?'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Think back to HTTPS, and how a bad certificate authority can convince a browser
    to accept fake certificates for arbitrary sites. Security depends on the strength
    of the least secure CA!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Authors say that passwords fail because people often reuse passwords across
    sites.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Biometrics:** Leverage the unique aspects of a person''s physical appearance
    or behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: How big is the keyspace?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fingerprints:* ~13.3 bits.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Iris scan:* ~19.9 bits.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Voice recognition:* ~11.7 bits.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, bits of entropy are roughly the same as passwords.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometrics vs. passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, final score is 8 vs 6.5\. Of course, one could assign non-unity weights
    to each category, but the point is that it's not obvious that biometrics are "better"
    than passwords!
  prefs: []
  type: TYPE_NORMAL
- en: Some sets of goals seem difficult to achieve at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Multi-factor authentication (MFA): defense using depth'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Requires users to authenticate themselves using two or more authentication mechanisms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mechanisms should involve different modalities!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you know (e.g., a password)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you possess (e.g., a cellphone, a hardware token)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you are (e.g., biometrics)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Idea is that an attacker must steal/subvert multiple authentication mechanisms
    to impersonate a user (e.g., attacker might guess a password, but lack access
    to a user's phone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Google''s two-factor authentication requires a password plus a cellphone
    which can receive authorization codes via text message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: AWS two-factor authentication requires a password and an "MFA device"
    (a smartphone running an authentication app, or a special-purpose security token
    or security card). [Amazon MFA](http://aws.amazon.com/iam/details/mfa/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MFA is a good idea, but empirical studies show that if users are given a second
    authentication factor in addition to passwords, users pick much weaker passwords!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homework Q
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are potential answers to the homework questions? What factors matter?
  prefs: []
  type: TYPE_NORMAL
- en: Logging into public Athena machine?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resilient-to-Internal-Observation: easy to install malware on machine.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient-to-Physical-Observation? + MIT IDs could be a good thing to leverage
    (use them as a smartcard).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometrics? Untrusted terminals, probably not a great plan.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Facebook from Internet cafe?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password managers not a good idea here.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How sensitive is the data?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Might be leveraged to authenticate to other sites! (Either "Login with Facebook"
    or by answering personal security questions to reset a password.)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Withdrawing cash from ATM?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security matters highly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient-to-Physical-Observation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient-to-Theft.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possibly trusted terminal: biometrics might be worth considering. (However,
    in practice, bank may not want to trust the terminals.)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You also might care about authenticating individual transactions!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent the adversary from using stolen credentials for different, attacker-chosen
    operations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ex: Maybe user can examine balance using just a password, but if she wants
    to withdraw money, she uses two-factor authentication using her phone.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conclusion of paper: There is no authentication scheme which clearly dominates
    passwords! For example, according to the authors, the CAP reader has perfect scores
    on security!'
  prefs: []
  type: TYPE_NORMAL
- en: The CAP reader was designed by Mastercard to protect online banking transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put your credit card into the CAP reader (which looks like a hand-held calculator).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter PIN (bypassing keyloggers!).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader talks to the card's embedded processor, outputs an 8-digit code which
    the user supplies to the web site.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Analysis:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, `passwords=8` and `CAP reader=10.5`. However, there are reasons why CAP
    readers haven't taken over the world (see the low usability and deployability
    scores).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, deployability and usability are often more important than security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration costs (coding+debugging effort, user training) make developers nervous!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The less usable a scheme is, the more that users will complain (and try to pick
    easier authentication tokens that are more vulnerable to attackers).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some situations may assign different weights to different evaluation metrics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example*: On a military base, the security benefits of a hardware-based token
    might outweigh the problems with usability and deployability.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
