- en: '2.4   Case Study: Percolation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/24percolation](https://introcs.cs.princeton.edu/java/24percolation)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We conclude our study of functions and modules by considering a case study of
    developing a program to solve an interesting scientific problem. as *Monte Carlo*
    simulation to study a natural model known as *percolation*.
  prefs: []
  type: TYPE_NORMAL
- en: Percolation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We model the system as an *n*-by-*n* grid of sites. Each site is either *blocked*
    or *open*; open sites are initially *empty*. A *full* site is an open site that
    can be connected to an open site in the top row via a chain of neighboring (left,
    right, up, down) open sites. If there is a full site in the bottom row, then we
    say that the system *percolates*.
  prefs: []
  type: TYPE_NORMAL
- en: '![percolates](../Images/e17956748601060a8bf9f91e96e1266b.png)           ![does
    not percolate](../Images/73ba2a5b775339f96789f6764521706a.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: If sites are independently set to be open with *vacancy probability* *p*, what
    is the probability that the system percolates? No mathematical solution to this
    problem has yet been derived. Our task is to write computer programs to help study
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Data representation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first step is to pick a representation of the data. We use one *boolean
    matrix* `isOpen[][]` to represent which sites are open and another boolean matrix
    `isFull[][]` that to represent which sites are full.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical percolation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a boolean matrix that represents the open sites, how do we figure out
    whether it represents a system that percolates? For the moment, we will consider
    a much simpler version of the problem that we call *vertical percolation*. The
    simplification is to restrict attention to vertical connection paths.
  prefs: []
  type: TYPE_NORMAL
- en: '![vertically percolates](../Images/e0bccc65f6f60330a21d0355a9d67d69.png)  
            ![does not vertically percolate](../Images/e3c73f401dd15daaae2483f2d47a902e.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '[VerticalPercolation.java](VerticalPercolation.java.html) determines the sites
    that are filled by some path that is connected vertically to the top using a simple
    calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![vertical percolation](../Images/eea921f291099608a38fb8ec214f69a4.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Data visualization.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PercolationVisualizer.java](PercolationVisualizer.java.html) is a test client
    that generates random boolean matrices and plots them using standard drawing.'
  prefs: []
  type: TYPE_NORMAL
- en: '![percolation visualization](../Images/bb90702c6e57cb053f5c38538af2e95b.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Estimating probabilities.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PercolationProbability.java](PercolationProbability.java.html) estimates the
    probability that a random *n*-by-*n* system with site vacancy probability *p*
    percolates. We refer to this quantity as the *percolation probability*. To estimate
    its value, we simply run a number of experiments.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive solution for percolation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we test whether a system percolates in the general case when *any* path
    starting at the top and ending at the bottom (not just a vertical one) will do
    the job? Remarkably, we can solve this problem with a compact program, based on
    a classic recursive scheme known as *depth-first search*. [Percolation.java](Percolation.java.html)
    takes this approach. See the textbook for details.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive plot.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PercolationPlot.java](PercolationPlot.java.html) plots the percolation probability
    as a function of the site vacancy probability *p* for an *n*-by-*n* system. It
    uses a recursive approach that produces a good-looking curve at relatively low
    cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '![adaptive plot for 20-by-20 percolation system](../Images/5acd85e3e12daf0a4fa23dd077a97f4b.png)
              ![adaptive plot for 100-by-100 percolation system](../Images/e46d4c28d8bc80261d4cc7061b9ec3a8.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'The curves support the hypothesis that there is a *threshold* value (about
    0.593): if *p* is greater than the threshold, then the system almost certainly
    percolates; if *p* is less than the threshold, then the system almost certainly
    does not percolate. As *n* increases, the curve approaches a step function that
    changes value from 0 to 1 at the threshold. This phenomenon, known as a *phase
    transition*, is found in many physical systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a program [PercolationDirected.java](PercolationDirected.java.html) that
    tests for *directed* percolation (by leaving off the last recursive call in the
    recursive `flow()` method in [Percolation.java](Percolation.java.html), as described
    in the text), then use [PercolationPlot.java](PercolationPlot.java.html) to draw
    a plot of the directed percolation probability as a function of the site vacancy
    probability *p*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Nonrecursive directed percolation.** Write a nonrecursive program [PercolationDirectedNonrecursive.java](PercolationDirectedNonrecursive.java.html)
    that tests for directed percolation by moving from top to bottom as in our vertical
    percolation code. Base your solution on the following computation: if any site
    in a contiguous subrow of open sites in the current row is connected to some full
    site on the previous row, then all of the sites in the subrow become full.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![directed percolation](../Images/5bffeebc94971d8b76c30a78ccb4d724.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**2-by-2 percolation.** Verify that the probability that a 2-by-2 system percolates
    is p^2 (2 - p^2), where p is the probability that a site is open.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cubic curves.** Use recursive subdivision algorithm to plot [cubic curves](http://www.ccs.neu.edu/jpt/fhs/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random walk.** Term coined by Hungarian mathematician George Polya in a 1921
    paper. Start at 0, go left with probability 1/2, go right with probability 1/2.
    Reflecting barrier at 0 - if particle hits 0, it must switch direction at next
    step and return to 1. Absorbing barrier at *n* - particle stops when it hits state
    *n*. Estimate number of steps as a function of n until the particle is absorbed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Analytic solution*: *n*².'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**3d random walk.** Take a random walk on a 3d lattice, starting from (0, 0,
    0). Write a program [Polya.java](Polya.java.html) to estimate the chance that
    you return to the origin after at most some number of steps, say 1,000\. (In 1d
    and 2d, you will surely return; in 3d, there is a less than 50% chance.) Repeat
    the exercise on a 4d lattice. *Solution*: the actual probability (without the
    artificial restriction on the number of steps) is known as [Polya''s random walk
    constant](http://mathworld.wolfram.com/PolyasRandomWalkConstants.html). It is
    slightly more than 1/3 for 3d and slightly less than 1/5 for 4d.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Self-avoiding random walk.** Simulate random walk on lattice until it intersects.
    Among all self-avoiding walks (SAW) of length *n*, what is average distance from
    origin? To save time in the simulation, exclude SAWs that ever take a step backwards.
    How long until at least one SAW of length *n* = 40, *n* = 80? What is half-life
    of a SAW? To save more time in the simulation, allow a SAW only to take a step
    into an unoccupied cell (and repeat until it gets trapped). Practically nothing
    is known rigorously about these questions, so simulation is the best recourse.
    Here''s an [article](../../papers/self-avoiding-walk.pdf) from the New Scientist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Famous 1949 problem of Nobel prize winning chemist, Flory. Conjecture: exponent
    of root mean square displacement is 3/4 in 2D and 3/5 in 3D.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Self-avoiding random walk.** Write a program [SelfAvoidingWalk.java](SelfAvoidingWalk.java.html)
    to simulate and animate a 2D self-avoiding random walk. Self-avoiding random walks
    arise in modeling physical processes like the folding of polymer molecules. Such
    walks are difficult to model using classical mathematics. so they are best studied
    by direct numerical simulation. See what fraction of such random walks end up
    more than R^2 (say 30) from the starting point.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Or keep a trail of length *n*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
