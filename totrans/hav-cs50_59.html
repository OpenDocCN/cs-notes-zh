<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lecture 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lecture 2</h1>
<blockquote>原文：<a href="https://cs50.harvard.edu/sql/notes/2/">https://cs50.harvard.edu/sql/notes/2/</a></blockquote>

                    

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#creating-a-database-schema" id="markdown-toc-creating-a-database-schema">Creating a Database Schema</a>    <ul>
      <li><a href="#normalizing" id="markdown-toc-normalizing">Normalizing</a></li>
      <li><a href="#relating" id="markdown-toc-relating">Relating</a></li>
      <li><a href="#questions" id="markdown-toc-questions">Questions</a></li>
    </ul>
  </li>
  <li><a href="#create-table" id="markdown-toc-create-table"><code class="language-plaintext highlighter-rouge">CREATE TABLE</code></a>    <ul>
      <li><a href="#questions-1" id="markdown-toc-questions-1">Questions</a></li>
    </ul>
  </li>
  <li><a href="#data-types-and-storage-classes" id="markdown-toc-data-types-and-storage-classes">Data Types and Storage Classes</a></li>
  <li><a href="#type-affinities" id="markdown-toc-type-affinities">Type Affinities</a></li>
  <li><a href="#adding-types-to-our-tables" id="markdown-toc-adding-types-to-our-tables">Adding Types to our Tables</a>    <ul>
      <li><a href="#questions-2" id="markdown-toc-questions-2">Questions</a></li>
    </ul>
  </li>
  <li><a href="#table-constraints" id="markdown-toc-table-constraints">Table Constraints</a>    <ul>
      <li><a href="#questions-3" id="markdown-toc-questions-3">Questions</a></li>
    </ul>
  </li>
  <li><a href="#column-constraints" id="markdown-toc-column-constraints">Column Constraints</a></li>
  <li><a href="#altering-tables" id="markdown-toc-altering-tables">Altering Tables</a>    <ul>
      <li><a href="#questions-4" id="markdown-toc-questions-4">Questions</a></li>
    </ul>
  </li>
  <li><a href="#fin" id="markdown-toc-fin">Fin</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<ul>
  <li data-marker="*">In this lecture, we will learn how to design our own database schemas.</li>
  <li data-marker="*">Thus far, we have primarily worked with a database of books that were longlisted for the International Booker Prize. Now, we will look underneath the hood and see what commands can be used to create such a database.</li>
  <li data-marker="*">First, let us open up the database <code class="language-plaintext highlighter-rouge">longlist.db</code> from Week 0 on our terminal. As a reminder, this database contained just one table, called <code class="language-plaintext highlighter-rouge">longlist</code>. To see a snapshot of the table, we can run
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"author"</span><span class="p">,</span> <span class="nv">"title"</span>
<span class="k">FROM</span> <span class="nv">"longlist"</span>
<span class="k">LIMIT</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>This gives us the authors and titles from the first 5 rows of the table <code class="language-plaintext highlighter-rouge">longlist</code>.</p>
  </li>
  <li data-marker="*">Here is a SQLite command (not an SQL keyword) that can shed more light on how this database was created.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="k">schema</span>
</code></pre></div>    </div>
    <p>On running this, we see the SQL statement used to create the table <code class="language-plaintext highlighter-rouge">longlist</code>. This shows us the columns inside <code class="language-plaintext highlighter-rouge">longlist</code> and the types of data that each column is able to store.</p>
  </li>
  <li data-marker="*">Next, let’s open up the same database from Week 1 on our terminal. This version of <code class="language-plaintext highlighter-rouge">longlist.db</code> contained different tables related to each other.</li>
  <li data-marker="*">On running <code class="language-plaintext highlighter-rouge">.schema</code> again, we see many commands — one for each table in the database. There is a way to see the schema for a specified table:
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="k">schema</span> <span class="n">books</span>
</code></pre></div>    </div>
    <p>Now we see the statement used to create the <code class="language-plaintext highlighter-rouge">books</code> table. We are also able to see the columns and data types for each column. For example, the <code class="language-plaintext highlighter-rouge">"title"</code> column takes text and the <code class="language-plaintext highlighter-rouge">"publisher_id"</code> column is an integer.</p>
  </li>
</ul>

<h2 id="creating-a-database-schema">Creating a Database Schema</h2>

<ul>
  <li data-marker="*">
    <p>Now that we have seen the schema for an existing database, let us create our own! We are tasked with representing the subway system of the city of Boston through a database schema. This includes the subway stations, the different train lines, and the people who take the trains.</p>

    <p class="w-50"><img src="../Images/aa88bf7ddc0b147d981c34b183ab1801.png" alt="&quot;Boston Subway Map&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/2/images/subwaymap.jpg"/></p>
  </li>
  <li data-marker="*">
    <p>To break down the question further, we need to decide…</p>
    <ul>
      <li data-marker="*">what kinds of tables we will have in our Boston Subway database,</li>
      <li data-marker="*">what columns each of the tables will have, and</li>
      <li data-marker="*">what types of data we should put in each of those columns.</li>
    </ul>
  </li>
</ul>

<h3 id="normalizing">Normalizing</h3>

<ul>
  <li data-marker="*">
    <p>Observe this initial attempt at creating a table to represent Boston Subway data. This table contains subway rider names, current stations the riders are at and the action performed at the station (like entering and exiting). It also records the fares paid and balance amounts on their subway cards. This table also contains an ID for each rider “transaction”, which serves as the primary key.</p>

    <p class="w-50"><img src="../Images/06fa3eab60c71d3c41d0ca02a316f783.png" alt="&quot;First attempt at table for Boston subway&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/2/images/table1.jpg"/></p>
  </li>
  <li data-marker="*">What redundancies exist in this table?
    <ul>
      <li data-marker="*">We may choose to separate out rider names into a table of its own, to avoid having to duplicate the names so many times. We would need to give each rider an ID that can be used to relate the new table to this one.</li>
      <li data-marker="*">We may similarly choose to move subway stations to a different table and give each subway station an ID to be used as a foreign key here.</li>
    </ul>
  </li>
  <li data-marker="*">The process of separating our data in this manner is called <strong>normalizing</strong>. When normalizing, we put each entity in its own table—as we did with riders and subway stations. Any information about a specific entity, for example a rider’s address, goes into the entity’s own table.</li>
</ul>

<h3 id="relating">Relating</h3>

<ul>
  <li data-marker="*">We now need to decide how our entities (riders and stations) are related. A rider will likely visit multiple stations, and a subway station is likely to have more than one rider. Given this, it will be a many-to-many relationship.</li>
  <li data-marker="*">
    <p>We can also use an ER diagram to represent this relationship.</p>

    <p class="w-50"><img src="../Images/8d98b6b3c2687fe82d6ec018ef4640a2.png" alt="&quot;Many-to-many relationship between riders and stations&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/2/images/erdriders.jpg"/></p>

    <p>Here, we see that every rider must visit at least one station to be considered a rider. A station, though, could have no riders visiting it, because perhaps it is out of order temporarily. However, it is likely that a station has multiple riders visiting it, indicated by the crow’s foot in the ER diagram.</p>
  </li>
</ul>

<h3 id="questions">Questions</h3>

<blockquote>
  <p>Does the relationship between riders and stations have to be exactly the way described here? For example, why is it okay for a station to have 0 riders?</p>
</blockquote>

<ul>
  <li data-marker="*">It is up to the person designing the database to make decisions about relationships between entities. It is possible to add a constraint that says a station must have at least one rider to be considered a station.</li>
</ul>

<h2 id="create-table"><code class="language-plaintext highlighter-rouge">CREATE TABLE</code></h2>

<ul>
  <li data-marker="*">Now that we have the schema for two of the tables, let’s go ahead and create the tables.</li>
  <li data-marker="*">Let us open up a new database called <code class="language-plaintext highlighter-rouge">mbta.db</code> — MBTA stands for Massachusetts Bay Transportation Authority and runs the Boston Subway.</li>
  <li data-marker="*">If we run <code class="language-plaintext highlighter-rouge">.schema</code>, we will see nothing because no table has been created in this database yet.</li>
  <li data-marker="*">In this database, we run the following command to create the first table for riders:
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">riders</span> <span class="p">(</span>
    <span class="nv">"id"</span><span class="p">,</span>
    <span class="nv">"name"</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>On running this, no results appear on the terminal. But if we run <code class="language-plaintext highlighter-rouge">.schema</code> again, we will now see the schema for the table <code class="language-plaintext highlighter-rouge">riders</code>, as defined by us!</p>
  </li>
  <li data-marker="*">Similarly, let us create a table for stations as well.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">stations</span> <span class="p">(</span>
    <span class="nv">"id"</span><span class="p">,</span>
    <span class="nv">"name"</span><span class="p">,</span>
    <span class="nv">"line"</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>Here, we add a column <code class="language-plaintext highlighter-rouge">"line"</code> to store the train line that the station is a part of.</p>
  </li>
  <li data-marker="*"><code class="language-plaintext highlighter-rouge">.schema</code> now shows us the schema for both <code class="language-plaintext highlighter-rouge">riders</code> and <code class="language-plaintext highlighter-rouge">stations</code>.</li>
  <li data-marker="*">Next, we will create a table to relate these two entities. These tables are often called junction tables, associative entities or join tables!
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">visits</span> <span class="p">(</span>
    <span class="nv">"rider_id"</span><span class="p">,</span>
    <span class="nv">"station_id"</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>Each row of this table tells us the station visited by a particular rider.</p>
  </li>
</ul>

<h3 id="questions-1">Questions</h3>
<blockquote>
  <p>Is it necessary to indent the lines within the <code class="language-plaintext highlighter-rouge">CREATE TABLE</code> parantheses?</p>
  <ul>
    <li data-marker="*">No, not strictly. However, we indent the column names to adhere to style conventions as always!</li>
  </ul>
</blockquote>

<h2 id="data-types-and-storage-classes">Data Types and Storage Classes</h2>
<ul>
  <li data-marker="*">SQLite has five storage classes:
    <ul>
      <li data-marker="*"><strong>Null</strong>: nothing, or empty value</li>
      <li data-marker="*"><strong>Integer</strong>: numbers without decimal points</li>
      <li data-marker="*"><strong>Real</strong>: decimal or floating point numbers</li>
      <li data-marker="*"><strong>Text</strong>: characters or strings</li>
      <li data-marker="*"><strong>Blob</strong>: Binary Large Object, for storing objects in binary (useful for images, audio etc.)</li>
    </ul>
  </li>
  <li data-marker="*">A storage class can hold several data types.</li>
  <li data-marker="*">
    <p>For example, these are the data types that fall under the umbrella of the Integer storage class.</p>

    <p class="w-50"><img src="../Images/46a87fcad9669187e92909b90079e0a0.png" alt="&quot;Integer Storage Class and Data Types&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/2/images/integer.jpg"/></p>

    <p>SQLite takes care of storing the input value under the right data type. In other words, we as programmers only need to choose a storage class and SQLite will do the rest!</p>
  </li>
  <li data-marker="*">Consider this question: what storage class would we use to store fares? Each choice comes with affordances and limitations.
    <ul>
      <li data-marker="*">Integers: We can store a 10 cent fare as the number 10, but that doesn’t make it very clear whether the fare is 10 cents or 10 dollars.</li>
      <li data-marker="*">Text: We can store the fare in text, like “$0.10”. However, now it will be hard to perform mathematical operations like adding up a rider’s fares.</li>
      <li data-marker="*">Real: We can store the fare using a floating point number, like 0.10, but it is not possible to store floating point numbers in binary precisely and—depending on how precise we need to be—doing so may lead to miscalculations down the line.</li>
    </ul>
  </li>
</ul>

<h2 id="type-affinities">Type Affinities</h2>

<ul>
  <li data-marker="*">It is possible to specify the data type of a column while creating a table.</li>
  <li data-marker="*">However, columns in SQLite don’t always store one particular data type. They are said to have <strong>type affinities</strong>, meaning that they try to convert an input value into the type they have an affinity for.</li>
  <li data-marker="*">The five type affinities in SQLite are: Text, Numeric (either integer or real values based on what the input value best converts to), Integer, Real and Blob.</li>
  <li data-marker="*">Consider a column with a type affinity for Integers. If we try to insert “25” (the number 25 but stored as text) into this column, it will be converted into an integer data type.</li>
  <li data-marker="*">Similarly, inserting an integer 25 into a column with a type affinity for text will convert the number to its text equivalent, “25”.</li>
</ul>

<h2 id="adding-types-to-our-tables">Adding Types to our Tables</h2>

<ul>
  <li data-marker="*">To create the tables in our database again, we will first need to drop (or delete) the existing tables.</li>
  <li data-marker="*">Let’s try the following commands
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="nv">"riders"</span><span class="p">;</span>
</code></pre></div>    </div>
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="nv">"stations"</span><span class="p">;</span>
</code></pre></div>    </div>
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="nv">"visits"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Running these statements gives no output, but <code class="language-plaintext highlighter-rouge">.schema</code> shows us that the tables have now been dropped.</p>
  </li>
  <li data-marker="*">Next, let us create a schema file that can be run to create the tables from scratch. This is an improvement over what we previously did—typing out the <code class="language-plaintext highlighter-rouge">CREATE TABLE</code> command for each table—because it allows us to edit and view the entire schema easily.</li>
  <li data-marker="*">Create a file <code class="language-plaintext highlighter-rouge">schema.sql</code>. Notice the extension <code class="language-plaintext highlighter-rouge">.sql</code> that enables syntax highlighting for SQL keywords in our editor.</li>
  <li data-marker="*">Inside the file, let’s type out the schemas again, but with the affinity types this time.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">riders</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">stations</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="nv">"line"</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">visits</span> <span class="p">(</span>
    <span class="nv">"rider_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"station_id"</span> <span class="nb">INTEGER</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>Now, we read this file within the database to actually create the tables. Here is an updated ER Diagram with the data types included.</p>

    <p class="w-50"><img src="../Images/5272df34a904d9ced917a6bf075c8383.png" alt="&quot;Updated ER Diagram with Data Types&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/2/images/erdtypes.jpg"/></p>
  </li>
</ul>

<h3 id="questions-2">Questions</h3>

<blockquote>
  <p>Previously, we were able to query the tables in our database and see the results in a table-like structure. How do we get the same kind of results to show up here?</p>
</blockquote>

<ul>
  <li data-marker="*">We haven’t yet added any data to the tables. In Lecture 3, we will see how to insert, update and delete rows in tables that we have created!</li>
</ul>

<blockquote>
  <p>Do we have a type affinity for Boolean?</p>
</blockquote>

<ul>
  <li data-marker="*">We don’t in SQLite, but other DBMS’s might have this option. A workaround could be to use 0 or 1 integer values to represent booleans.</li>
</ul>

<h2 id="table-constraints">Table Constraints</h2>

<ul>
  <li data-marker="*">We can use table constraints to impose restrictions on certain values in our tables.</li>
  <li data-marker="*">For example, a primary key column must have unique values. The table constraint we use for this is <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code>.</li>
  <li data-marker="*">Similarly, a constraint on a foreign key value is that it must be found in the primary key column of the related table! This table constraint is called, predictably, <code class="language-plaintext highlighter-rouge">FOREIGN KEY</code>.</li>
  <li data-marker="*">
    <p>Let’s add primary and foreign key constraints to our <code class="language-plaintext highlighter-rouge">schema.sql</code> file.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">riders</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">stations</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="nv">"line"</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">visits</span> <span class="p">(</span>
    <span class="nv">"rider_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"station_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"rider_id"</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="nv">"riders"</span><span class="p">(</span><span class="nv">"id"</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"station_id"</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="nv">"stations"</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>

    <p>Notice that we created two primary key columns, the ID for both <code class="language-plaintext highlighter-rouge">riders</code> and <code class="language-plaintext highlighter-rouge">stations</code> and then referenced these primary keys as foreign keys in the <code class="language-plaintext highlighter-rouge">visits</code> table.</p>
  </li>
  <li data-marker="*">In the <code class="language-plaintext highlighter-rouge">visits</code> table, there is no primary key. However, SQLite gives every table a primary key by default, known as the row ID. Even though the row ID is implicit, it can be queried!</li>
  <li data-marker="*">
    <p>It is also possible to create a primary key composed of two columns. For example, if we wanted to give <code class="language-plaintext highlighter-rouge">visits</code> a primary key composed of both the rider and stations IDs, we could use this syntax</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">visits</span> <span class="p">(</span>
    <span class="nv">"rider_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"station_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"rider_id"</span><span class="p">,</span> <span class="nv">"station_id"</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>

    <p>In this case, we probably want to allow a rider to visit a station more than once, so we would not move ahead with this approach.</p>
  </li>
</ul>

<h3 id="questions-3">Questions</h3>

<blockquote>
  <p>Is it possible to include our own primary key for the <code class="language-plaintext highlighter-rouge">visits</code> table?</p>
</blockquote>

<ul>
  <li data-marker="*">Yes! If, for some reason, an explicit primary key was required for the <code class="language-plaintext highlighter-rouge">visits</code> table, we could create an ID column and make it the primary key.</li>
</ul>

<h2 id="column-constraints">Column Constraints</h2>

<ul>
  <li data-marker="*">A column constraint is a type of constraint that applies to a specified column in the table.</li>
  <li data-marker="*">SQLite has four column constraints:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">CHECK</code>: allows checking for a condition, like all values in the column must be greater than 0</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">DEFAULT</code>: uses a default value if none is supplied for a row</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">NOT NULL</code>: dictates that a null or empty value cannot be inserted into the column</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">UNIQUE</code>: dictates that every value in this column must be unique</li>
    </ul>
  </li>
  <li data-marker="*">
    <p>An updated schema with these contraints would look like the following:</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">riders</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">stations</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">UNIQUE</span><span class="p">,</span>
    <span class="nv">"line"</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">visits</span> <span class="p">(</span>
    <span class="nv">"rider_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"station_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"rider_id"</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="nv">"riders"</span><span class="p">(</span><span class="nv">"id"</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"station_id"</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="nv">"stations"</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>

    <p>The <code class="language-plaintext highlighter-rouge">NOT NULL</code> constraint ensures that a station name and line are specified. On the other hand, riders are not mandated to share their names, because there is no constraint applied to rider names. Similarly, each station must have a unique name, as dictated by the <code class="language-plaintext highlighter-rouge">UNIQUE</code> constraint.</p>
  </li>
  <li data-marker="*">Primary key columns and by extension, foreign key columns must always have unique values, so there is no need to explicitly specify the <code class="language-plaintext highlighter-rouge">NOT NULL</code> or <code class="language-plaintext highlighter-rouge">UNIQUE</code> column constraints. The table constraint <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> includes these column constraints.</li>
</ul>

<h2 id="altering-tables">Altering Tables</h2>
<ul>
  <li data-marker="*">
    <p>Consider the following updated ER diagram, where the entity “Rider” has been swapped out with a new entity “Card” used to represent CharlieCards. CharlieCards, in the Boston Subway, can be loaded with money and are used to swipe into and sometimes out of stations.</p>

    <p class="w-50"><img src="../Images/a56f3a24753aa7c5909327e0c2d7ca0c.png" alt="&quot;Updated ER Diagram with CharlieCards and columns&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/2/images/updatederd.jpg"/></p>
  </li>
  <li data-marker="*">Notice that a card can be swiped many times in total, but only at one station at a given time.</li>
  <li data-marker="*">The “Card” entity has an ID, which is also its primary key.</li>
  <li data-marker="*">There is also now an entity “Swipe”, with an ID of its own and a type. “Swipe” also records the time at which a card was swiped and the amount that was subtracted (equivalent to the amount of money needed to ride the subway)!</li>
  <li data-marker="*">
    <p>Now, to implement these changes in our database, we need to first drop the <code class="language-plaintext highlighter-rouge">riders</code> table.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="nv">"riders"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">Running <code class="language-plaintext highlighter-rouge">.schema</code> shows us the updated schema without the <code class="language-plaintext highlighter-rouge">riders</code> table.</li>
  <li data-marker="*">
    <p>Next, we need a <code class="language-plaintext highlighter-rouge">swipes</code> table to represent the “Swipe” entity from our updated ER diagram. We could alter the <code class="language-plaintext highlighter-rouge">visits</code> table in the following way.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="nv">"visits"</span>
<span class="k">RENAME</span> <span class="k">TO</span> <span class="nv">"swipes"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>On running <code class="language-plaintext highlighter-rouge">.schema</code> we can see that the table <code class="language-plaintext highlighter-rouge">visits</code> was renamed to <code class="language-plaintext highlighter-rouge">swipes</code>. However, this is not the only change needed. We also need to add some columns, like the type of swipe.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="nv">"swipes"</span>
<span class="k">ADD</span> <span class="k">COLUMN</span> <span class="nv">"swipetype"</span> <span class="nb">TEXT</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Notice the type affinity <code class="language-plaintext highlighter-rouge">TEXT</code> is also mentioned while adding this column.</p>
  </li>
  <li data-marker="*">
    <p>We also have the ability to rename a column in an <code class="language-plaintext highlighter-rouge">ALTER TABLE</code> command. If we wanted to rename the column <code class="language-plaintext highlighter-rouge">"swipetype"</code> to make it less wordy, perhaps, we could try the following.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="nv">"swipes"</span>
<span class="k">RENAME</span> <span class="k">COLUMN</span> <span class="nv">"swipetype"</span> <span class="k">TO</span> <span class="nv">"type"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>Finally, we have the ability to drop (or remove) a column.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="nv">"swipes"</span>
<span class="k">DROP</span> <span class="k">COLUMN</span> <span class="nv">"type"</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>On running <code class="language-plaintext highlighter-rouge">.schema</code> again, we can confirm that the column <code class="language-plaintext highlighter-rouge">"type"</code> was dropped from the table.</p>
  </li>
  <li data-marker="*">
    <p>It is also possible to return to the schema file <code class="language-plaintext highlighter-rouge">schema.sql</code> that we had originally and simply make these changes there instead of altering tables. The following is an updated <code class="language-plaintext highlighter-rouge">schema.sql</code>.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">"cards"</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">"stations"</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"name"</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">UNIQUE</span><span class="p">,</span>
    <span class="nv">"line"</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">"swipes"</span> <span class="p">(</span>
    <span class="nv">"id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"card_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"station_id"</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="nv">"type"</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">CHECK</span><span class="p">(</span><span class="nv">"type"</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'enter'</span><span class="p">,</span> <span class="s1">'exit'</span><span class="p">,</span> <span class="s1">'deposit'</span><span class="p">)),</span>
    <span class="nv">"datetime"</span> <span class="nb">NUMERIC</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
    <span class="nv">"amount"</span> <span class="nb">NUMERIC</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">CHECK</span><span class="p">(</span><span class="nv">"amount"</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"id"</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"station_id"</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="nv">"stations"</span><span class="p">(</span><span class="nv">"id"</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="nv">"card_id"</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="nv">"cards"</span><span class="p">(</span><span class="nv">"id"</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">Let us take a couple of minutes to read through the updated schema and make a note of the things that seem to have changed!
    <ul>
      <li data-marker="*">The tables <code class="language-plaintext highlighter-rouge">cards</code> and <code class="language-plaintext highlighter-rouge">swipes</code> are added and the <code class="language-plaintext highlighter-rouge">NOT NULL</code> column constraint is used to require some values in <code class="language-plaintext highlighter-rouge">swipes</code>.</li>
      <li data-marker="*">The <code class="language-plaintext highlighter-rouge">"datetime"</code> column is given the type affinity numeric — this is because numeric types can store and display date values.</li>
      <li data-marker="*">The foreign key mapping is adjusted as needed, such that <code class="language-plaintext highlighter-rouge">"card_id"</code> is a foreign key referring to the ID of the <code class="language-plaintext highlighter-rouge">cards</code> table.</li>
      <li data-marker="*">A default value is assigned to the <code class="language-plaintext highlighter-rouge">"datetime"</code> column so that it automatically picks up the current timestamp if none is supplied. Notice the use of the <code class="language-plaintext highlighter-rouge">CURRENT_TIMESTAMP</code> — it returns the year, month, day, hour, minute and second combined into one value.</li>
      <li data-marker="*">There is a check in place to ensure the amount on a swipe is not 0. This is implemented through the column constraint <code class="language-plaintext highlighter-rouge">CHECK</code>, which is used with an expression <code class="language-plaintext highlighter-rouge">"amount" != 0</code> to ensure the value is not 0.</li>
      <li data-marker="*">Similarly, there is a check on <code class="language-plaintext highlighter-rouge">"type"</code> to ensure its value is one of ‘enter’, ‘exit’ and ‘deposit’. This is done because when a CharlieCard is swiped, it is usually for one of these three purposes, so it makes sense to have <code class="language-plaintext highlighter-rouge">"type"</code> assume these values only. Notice the use of the <code class="language-plaintext highlighter-rouge">IN</code> keyword to carry out this check! Is there a way to implement this check using the <code class="language-plaintext highlighter-rouge">OR</code> operator instead?</li>
    </ul>
  </li>
</ul>

<h3 id="questions-4">Questions</h3>

<blockquote>
  <p>On trying to drop the table <code class="language-plaintext highlighter-rouge">riders</code>, an error comes up because we’re using the ID of <code class="language-plaintext highlighter-rouge">riders</code> as a foreign key. How can the table be dropped in this case?</p>
</blockquote>

<ul>
  <li data-marker="*">Foreign key constraints within the database are checked when dropping a table. Before dropping <code class="language-plaintext highlighter-rouge">riders</code>, we would need to first drop the foreign key column <code class="language-plaintext highlighter-rouge">"rider_id"</code>.</li>
</ul>

<blockquote>
  <p>How different is the syntax for a different DBMS like MySQL or PostgreSQL?</p>
</blockquote>

<ul>
  <li data-marker="*">Most of the SQLite syntax definitely applies to other database management systems as well. However, if we tried porting our SQLite code, some minimal changes would be needed.</li>
</ul>

<blockquote>
  <p>If we don’t specify a type affinity of a column in SQLite, what happens?</p>
</blockquote>

<ul>
  <li data-marker="*">The default type affinity is numeric, so the column would get assigned the numeric type affinity.</li>
</ul>

<h2 id="fin">Fin</h2>

<ul>
  <li data-marker="*">This brings us to the conclusion of Lecture 2 about Designing in SQL! For an interesting story about the origin of the name CharlieCard, read <a href="http://www.celebrateboston.com/mbta/charlie-card-origin.htm">this</a> article from Celebrate Boston.</li>
</ul>


                    
</body>
</html>