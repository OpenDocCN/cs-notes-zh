<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lecture 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lecture 5</h1>
<blockquote>原文：<a href="https://cs50.harvard.edu/sql/notes/5/">https://cs50.harvard.edu/sql/notes/5/</a></blockquote>

                    

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#index" id="markdown-toc-index">Index</a>    <ul>
      <li><a href="#questions" id="markdown-toc-questions">Questions</a></li>
    </ul>
  </li>
  <li><a href="#index-across-multiple-tables" id="markdown-toc-index-across-multiple-tables">Index across Multiple Tables</a></li>
  <li><a href="#space-trade-off" id="markdown-toc-space-trade-off">Space Trade-off</a></li>
  <li><a href="#time-trade-off" id="markdown-toc-time-trade-off">Time Trade-off</a></li>
  <li><a href="#partial-index" id="markdown-toc-partial-index">Partial Index</a>    <ul>
      <li><a href="#questions-1" id="markdown-toc-questions-1">Questions</a></li>
    </ul>
  </li>
  <li><a href="#vacuum" id="markdown-toc-vacuum">Vacuum</a>    <ul>
      <li><a href="#questions-2" id="markdown-toc-questions-2">Questions</a></li>
    </ul>
  </li>
  <li><a href="#concurrency" id="markdown-toc-concurrency">Concurrency</a>    <ul>
      <li><a href="#transactions" id="markdown-toc-transactions">Transactions</a></li>
      <li><a href="#race-conditions" id="markdown-toc-race-conditions">Race Conditions</a></li>
      <li><a href="#questions-3" id="markdown-toc-questions-3">Questions</a></li>
    </ul>
  </li>
  <li><a href="#fin" id="markdown-toc-fin">Fin</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<ul>
  <li data-marker="*">This week, we will learn how to optimize our SQL queries, both for time and space. We will also learn how to run queries concurrently.</li>
  <li data-marker="*">We will do all of this in the context of a new database — the Internet Movies Database, or IMDb as it is more popularly known. Our SQLite database is compiled from the large online database of movies you may have seen before at <a href="imdb.com">imdb.com</a>.</li>
  <li data-marker="*">
    <p>Take a look at these statistics to get a sense of how big this database is! It has much more data than any of the other databases we have worked with so far.</p>

    <p class="w-50"><img src="../Images/2811d80304197c75e6c69bdda83c37eb.png" alt="&quot;Statistics about the IMDb database&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/5/images/3.jpg"/></p>
  </li>
  <li data-marker="*">
    <p>Here is the ER Diagram detailing the entities and their relationships.</p>

    <p class="w-50"><img src="../Images/66be213591789cad4852d87ac70a236c.png" alt="&quot;IMDb ER Diagram — people, movies, and ratings entities&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/5/images/4.jpg"/></p>
  </li>
</ul>

<h2 id="index">Index</h2>

<ul>
  <li data-marker="*">Let us open up this database called <code class="language-plaintext highlighter-rouge">movies.db</code> in SQLite.</li>
  <li data-marker="*"><code class="language-plaintext highlighter-rouge">.schema</code> shows us the tables created in this database. To implement the many-to-many relationship between the entities Person and Movie from the ER Diagram, we have a joint table here called <code class="language-plaintext highlighter-rouge">stars</code> that references the ID columns of both <code class="language-plaintext highlighter-rouge">people</code> and <code class="language-plaintext highlighter-rouge">movies</code> as foreign key columns!</li>
  <li data-marker="*">
    <p>To peek into the <code class="language-plaintext highlighter-rouge">movies</code> table, we can select from the table and limit results.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="nv">"movies"</span> <span class="k">LIMIT</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>To find the information pertaining to the movie Cars, we would run the following query.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="nv">"movies"</span>
<span class="k">WHERE</span> <span class="nv">"title"</span> <span class="o">=</span> <span class="s1">'Cars'</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li data-marker="*">Say we want to find how long it took for this query to run. SQLite has a command <code class="language-plaintext highlighter-rouge">.timer on</code> that enables us to time our queries.</li>
      <li data-marker="*">On running the above query to find Cars again, we can see three different time measurements displayed along with the results.</li>
      <li data-marker="*">“real” time indicates the stopwatch time, or the time between executing the query and obtaining the results. This is the measure of time we will focus on. The time taken to execute this query during lecture was roughly a tenth of a second!</li>
    </ul>
  </li>
  <li data-marker="*">Under the hood, when the query to find Cars was run, we triggered a <strong>scan</strong> of the table <code class="language-plaintext highlighter-rouge">movies</code> — that is, the table <code class="language-plaintext highlighter-rouge">movies</code> was scanned top to bottom, one row at a time, to find all the rows with the title Cars.</li>
  <li data-marker="*">We can optimize this query to be more efficient than a scan. In the same way that textbooks often have an index, databases tables can have an index as well. An index, in database terminology, is a structure used to speed up the retrieval of rows from a table.</li>
  <li data-marker="*">
    <p>We can use the following command to create an index for the <code class="language-plaintext highlighter-rouge">"title"</code> column in the <code class="language-plaintext highlighter-rouge">movies</code> table.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="nv">"title_index"</span> <span class="k">ON</span> <span class="nv">"movies"</span> <span class="p">(</span><span class="nv">"title"</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li data-marker="*">After creating this index, we run the query to find the movie titled Cars again. On this run, the time taken is significantly shorter (during lecture,almost eight times faster than the first run)!</li>
    </ul>
  </li>
  <li data-marker="*">In the previous example, once the index was created, we just assumed that SQL would use it to find a movie. However, we can also explicitly see this by using a SQLite command <code class="language-plaintext highlighter-rouge">EXPLAIN QUERY PLAN</code> before any query.</li>
  <li data-marker="*">
    <p>To remove the index we just created, run:</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">INDEX</span> <span class="nv">"title_index"</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li data-marker="*">After dropping the index, running <code class="language-plaintext highlighter-rouge">EXPLAIN QUERY PLAN</code> again with the <code class="language-plaintext highlighter-rouge">SELECT</code> query will demonstrate that the plan would revert to scanning the entire database.</li>
    </ul>
  </li>
</ul>

<h3 id="questions">Questions</h3>

<blockquote>
  <p>Do databases not have implicit algorithms to optimize searching?</p>
</blockquote>

<ul>
  <li data-marker="*">They do, for some columns. In SQLite and most other database management systems, if we specify that a column is a primary key, an index will automatically be created via which we can search for the primary key. However, for regular columns like <code class="language-plaintext highlighter-rouge">"title"</code>, there would be no automatic optimization.</li>
</ul>

<blockquote>
  <p>Would it be advisable to create a different index for every column in case we need it?</p>
</blockquote>

<ul>
  <li data-marker="*">While that seems useful, there are trade-offs with space and the time it takes to later insert data into tables with an index. We will see more on this shortly!</li>
</ul>

<h2 id="index-across-multiple-tables">Index across Multiple Tables</h2>

<ul>
  <li data-marker="*">
    <p>We would run the following query to find all the movies Tom Hanks starred in.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"title"</span> <span class="k">FROM</span> <span class="nv">"movies"</span>
<span class="k">WHERE</span> <span class="nv">"id"</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"movie_id"</span> <span class="k">FROM</span> <span class="nv">"stars"</span>
    <span class="k">WHERE</span> <span class="nv">"person_id"</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="nv">"id"</span> <span class="k">FROM</span> <span class="nv">"people"</span>
        <span class="k">WHERE</span> <span class="nv">"name"</span> <span class="o">=</span> <span class="s1">'Tom Hanks'</span>
    <span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">To understand what kind of index could help speed this query up, we can run <code class="language-plaintext highlighter-rouge">EXPLAIN QUERY PLAN</code> ahead of this query again. This shows us that the query requires two scans — of <code class="language-plaintext highlighter-rouge">people</code> and <code class="language-plaintext highlighter-rouge">stars</code>. The table <code class="language-plaintext highlighter-rouge">movies</code> is not scanned because we are searching <code class="language-plaintext highlighter-rouge">movies</code> by its ID, for which an index is automatically created by SQLite!</li>
  <li data-marker="*">
    <p>Let us create the two indexes to speed this query up.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="nv">"person_index"</span> <span class="k">ON</span> <span class="nv">"stars"</span> <span class="p">(</span><span class="nv">"person_id"</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="nv">"name_index"</span> <span class="k">ON</span> <span class="nv">"people"</span> <span class="p">(</span><span class="nv">"name"</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">Now, we run <code class="language-plaintext highlighter-rouge">EXPLAIN QUERY PLAN</code> with the same nested query. We can observe that
    <ul>
      <li data-marker="*">all the scans are now searches using indexes, which is great!</li>
      <li data-marker="*">the search on the table <code class="language-plaintext highlighter-rouge">people</code> uses something called a <code class="language-plaintext highlighter-rouge">COVERING INDEX</code></li>
    </ul>
  </li>
  <li data-marker="*">A covering index means that all the information needed for the query can be found within the index itself. Instead of two steps:
    <ol>
      <li>looking up relevant information in the index,</li>
      <li>using the index to then search the table, a covering index means that we do our search in one step (just the first one).</li>
    </ol>
  </li>
  <li data-marker="*">To have our search on the table <code class="language-plaintext highlighter-rouge">stars</code> also use a covering index, we can add <code class="language-plaintext highlighter-rouge">"movie_id"</code> to the index we created for <code class="language-plaintext highlighter-rouge">stars</code>. This will ensure that the information being looked up (movie ID) <em>and</em> the value being searched on (person ID) are both be in the index.</li>
  <li data-marker="*">
    <p>First, let us drop the existing implementation of our index on the <code class="language-plaintext highlighter-rouge">stars</code> table.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">INDEX</span> <span class="nv">"person_index"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>Next, we create the new index.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="nv">"person_index"</span> <span class="k">ON</span> <span class="nv">"stars"</span> <span class="p">(</span><span class="nv">"person_id"</span><span class="p">,</span> <span class="nv">"movie_id"</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>Running the following will demonstrate that we now have two covering indexes, which should result in a much faster search!</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="n">QUERY</span> <span class="n">PLAN</span>
<span class="k">SELECT</span> <span class="nv">"title"</span> <span class="k">FROM</span> <span class="nv">"movies"</span> <span class="k">WHERE</span> <span class="nv">"id"</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"movie_id"</span> <span class="k">FROM</span> <span class="nv">"stars"</span> <span class="k">WHERE</span> <span class="nv">"person_id"</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="nv">"id"</span> <span class="k">FROM</span> <span class="nv">"people"</span> <span class="k">WHERE</span> <span class="nv">"name"</span> <span class="o">=</span> <span class="s1">'Tom Hanks'</span>
    <span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">Making sure that we have run <code class="language-plaintext highlighter-rouge">.timer on</code> let us execute the above query to find all the movies Tom Hanks has starred in, and observe the time it takes to run. The query now runs a <em>lot</em> faster than it did without indexes (in lecture, an order of magnitude faster)!</li>
</ul>

<h2 id="space-trade-off">Space Trade-off</h2>

<ul>
  <li data-marker="*">Indexes seem incredibly helpful, but there are trade-offs associated — they occupy additional space in the database, so while we gain query speed, we do lose space.</li>
  <li data-marker="*">
    <p>An index is stored in a database as a data structure called a B-Tree, or balanced tree. A tree data structure looks something like:</p>

    <p class="w-50"><img src="../Images/013c41e6395b2e1f4864248d1183c072.png" alt="&quot;Tree data structure&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/5/images/20.jpg"/></p>

    <ul>
      <li data-marker="*">Notice that the tree has many <strong>nodes</strong>, each connected to a few others by arrows. The root node, or the node from which the tree originates, has three <strong>children</strong>. Some nodes at the edge of the tree do not point to any other nodes. These are called <strong>leaf</strong> nodes.</li>
    </ul>
  </li>
  <li data-marker="*">Let us consider how an index is created for the <code class="language-plaintext highlighter-rouge">"title"</code> column of the table <code class="language-plaintext highlighter-rouge">movies</code>. If the movie titles were sorted alphabetically, it would be a lot easier to find a particular movie by using <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>.</li>
  <li data-marker="*">
    <p>In this case, a copy is made of the <code class="language-plaintext highlighter-rouge">"titles"</code> column. This copy is sorted and then linked back to the original rows within the <code class="language-plaintext highlighter-rouge">movies</code> table by pointing to the movie IDs. This is visualized below.</p>

    <p class="w-50"><img src="../Images/22e180e91d89658e7b799617b266c1fa.png" alt="&quot;Index: Sorted copy of titles pointing to original movie IDs&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/5/images/40.jpg"/></p>
  </li>
  <li data-marker="*">While this helps us visualize the index for this column easily, in reality, the index is not a single column but is broken up into many nodes. This is because if the database has a lot of data, like our IMDb example, storing one column all together in memory might not be feasible.</li>
  <li data-marker="*">
    <p>If we have multiple nodes containing sections of the index, however, we also need nodes to navigate to the right sections. For example, consider the following nodes. The left-hand node directs us to the right section of the index based on whether the movie title comes before Frozen, between Frozen and Soul, or after Soul alphabetically!</p>

    <p class="w-50"><img src="../Images/a1b2e44432a54cacf44500335197cbf3.png" alt="&quot;Index nodes broken into sections&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/5/images/46.jpg"/></p>
  </li>
  <li data-marker="*">The above representation is a B-tree! This is how indexes are stored in SQLite.</li>
</ul>

<h2 id="time-trade-off">Time Trade-off</h2>

<ul>
  <li data-marker="*">Similar to the space trade-off we discussed earlier, it also takes longer to insert data into a column and then add it to an index. Each time a value is added to the index, the B-tree needs to be traversed to figure out where the value should be added!</li>
</ul>

<h2 id="partial-index">Partial Index</h2>

<ul>
  <li data-marker="*">This is an index that includes only a subset of rows from a table, allowing us to save some space that a full index would occupy.</li>
  <li data-marker="*">
    <p>This is especially useful when we know that users query only a subset of rows from the table. In the case of IMDb, it may be that the users are more likely to query a movie that was just released as opposed to a movie that is 15 years old. Let’s try to create a partial index that stores the titles of movies released in 2023.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="nv">"recents"</span> <span class="k">ON</span> <span class="nv">"movies"</span> <span class="p">(</span><span class="nv">"titles"</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="nv">"year"</span> <span class="o">=</span> <span class="mi">2023</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>We can check that searching for movies released in 2023 uses the new index.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="n">QUERY</span> <span class="n">PLAN</span>
<span class="k">SELECT</span> <span class="nv">"title"</span> <span class="k">FROM</span> <span class="nv">"movies"</span>
<span class="k">WHERE</span> <span class="nv">"year"</span> <span class="o">=</span> <span class="mi">2023</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>This shows us that the <code class="language-plaintext highlighter-rouge">movies</code> table is scanned using the partial index.</p>
  </li>
</ul>

<h3 id="questions-1">Questions</h3>

<blockquote>
  <p>Are indexes saved in the schema?</p>
</blockquote>

<ul>
  <li data-marker="*">Yes, in SQLite, they are! We can confirm this by running <code class="language-plaintext highlighter-rouge">.schema</code> and we will see the indexes created listed in the database schema.</li>
</ul>

<h2 id="vacuum">Vacuum</h2>

<ul>
  <li data-marker="*">There are ways to delete unused space in our database. SQLite allows us to “vacuum” data — this cleans up previously deleted data (that is actually not deleted, but just marked as space being available for the next <code class="language-plaintext highlighter-rouge">INSERT</code>).</li>
  <li data-marker="*">
    <p>To find the size of <code class="language-plaintext highlighter-rouge">movies.db</code> on the terminal, we can use a Unix command</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>du -b movies.db
</code></pre></div>    </div>
  </li>
  <li data-marker="*">In lecture, this command showed us that the size of the database is something like 158 million bytes, or 158 megabytes.</li>
  <li data-marker="*">
    <p>We can now connect to our database and drop an index we previously created.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">INDEX</span> <span class="nv">"person_index"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>Now, if we run the Unix command again, we see that the size of the database has not decreased! To actually clean up the deleted space, we need to vacuum it. We can run the following command in SQLite.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">VACUUM</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>This  might take a second or two to run. On running the Unix command to check the size of the database again, we can should see a smaller size. Once we drop all the indexes and vacuum again, the database will be considerably smaller than 158 MB (in lecture, around 100 MB).</p>
  </li>
</ul>

<h3 id="questions-2">Questions</h3>

<blockquote>
  <p>Is it possible to vacuum faster?</p>
</blockquote>

<ul>
  <li data-marker="*">Each vacuum can take a different amount of time, depending on the amount of space we are trying to vacuum and how easy it is to find the bits and bytes that need to be freed up!</li>
</ul>

<blockquote>
  <p>If a query to delete some rows doesn’t actually delete them, but only marks them as deleted, could we still retrieve these rows?</p>
</blockquote>

<ul>
  <li data-marker="*">People trained in forensics are able to find data we think is deleted but is actually still on our computers. In the case of SQLite, after performing a vacuum, it would not be possible to find deleted rows again.</li>
</ul>

<h2 id="concurrency">Concurrency</h2>

<ul>
  <li data-marker="*">Thus far, we have seen how to optimize single queries. Now, we will look at how to allow not just one query, but multiple at a time.</li>
  <li data-marker="*">Concurrency is the simultaneous handling of multiple queries or interactions by the database. Imagine a database for a website, or a financial service, that gets a lot of traffic at the same time. Concurrency is particularly important in these cases.</li>
  <li data-marker="*">
    <p>Some database transactions can be multi-part. For example, consider a bank’s database. The following is a view of the table <code class="language-plaintext highlighter-rouge">accounts</code> that stores account balances.</p>

    <p class="w-50"><img src="../Images/bb31b5c75facd37e6222fc7937101a9a.png" alt="&quot;Accounts table in a bank's database. Alice sends $10 to Bob.&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/5/images/66.jpg"/></p>

    <ul>
      <li data-marker="*">One transaction could be sending money from one account to the other. For example, Alice is trying to send $10 to Bob.</li>
      <li data-marker="*">To complete this transaction, we would need to add $10 to Bob’s account and also subtract $10 from Alice’s account. If someone sees the status of the <code class="language-plaintext highlighter-rouge">accounts</code> database after the first update to Bob’s account but before the second update to Alice’s account, they could get an incorrect understanding of the total amount of money held by the bank.</li>
    </ul>
  </li>
</ul>

<h3 id="transactions">Transactions</h3>

<ul>
  <li data-marker="*">To an outside observer, it should seem like the different parts of a transaction happen all at once. In database terminology, a transaction is an individual unit of work — something that cannot be broken down into smaller pieces.</li>
  <li data-marker="*">Transactions have some properties, which can be remembered using the acronym ACID:
    <ul>
      <li data-marker="*"><strong>atomicity</strong>: can’t be broken down into smaller pieces,</li>
      <li data-marker="*"><strong>consistency</strong>: should not violate a database constraint,</li>
      <li data-marker="*"><strong>isolation</strong>: if multiple users access a database, their transactions cannot interfere with each other,</li>
      <li data-marker="*"><strong>durability</strong>: in case of any failure within the database, all data changed by transactions will remain.</li>
    </ul>
  </li>
  <li data-marker="*">Let’s open up <code class="language-plaintext highlighter-rouge">bank.db</code> in our terminal so we can implement a transaction for transferring money from Alice to Bob!</li>
  <li data-marker="*">
    <p>First, we want to see the data already in the <code class="language-plaintext highlighter-rouge">accounts</code> table.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="nv">"accounts"</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>We note here that Bob’s ID is 2 and Alice’s ID is 1, which will be useful for our query.</p>
  </li>
  <li data-marker="*">
    <p>To move $10 from Alice’s account to Bob’s, we can write the following transaction.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="nv">"accounts"</span> <span class="k">SET</span> <span class="nv">"balance"</span> <span class="o">=</span> <span class="nv">"balance"</span> <span class="o">+</span> <span class="mi">10</span> <span class="k">WHERE</span> <span class="nv">"id"</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="nv">"accounts"</span> <span class="k">SET</span> <span class="nv">"balance"</span> <span class="o">=</span> <span class="nv">"balance"</span> <span class="o">-</span> <span class="mi">10</span> <span class="k">WHERE</span> <span class="nv">"id"</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">COMMIT</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Notice the <code class="language-plaintext highlighter-rouge">UPDATE</code> statements are written in between the commands to begin the transaction and to commit it. If we execute the query after writing the <code class="language-plaintext highlighter-rouge">UPDATE</code> statements, but without committing, neither of the two <code class="language-plaintext highlighter-rouge">UPDATE</code> statements will be run! This helps keep the transaction <strong>atomic</strong>. By updating our table in this way, we are unable to see the intermediate steps.</p>
  </li>
  <li data-marker="*">If we tried to run the above transaction again — Alice tries to pay Bob another $10 — it should fail to run because Alice’s account balance is at 0. (The <code class="language-plaintext highlighter-rouge">"balance"</code> column in <code class="language-plaintext highlighter-rouge">accounts</code> has a check constraint to ensure that it has a non-negative value. We can run <code class="language-plaintext highlighter-rouge">.schema</code> to check this.)</li>
  <li data-marker="*">
    <p>The way we implement reverting the transaction is using <code class="language-plaintext highlighter-rouge">ROLLBACK</code>. Once we begin a transaction and write some SQL statements, if any of them fail, we can end it with a <code class="language-plaintext highlighter-rouge">ROLLBACK</code> to revert all values to their pre-transaction state. This helps keep transactions <strong>consistent</strong>.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="nv">"accounts"</span> <span class="k">SET</span> <span class="nv">"balance"</span> <span class="o">=</span> <span class="nv">"balance"</span> <span class="o">+</span> <span class="mi">10</span> <span class="k">WHERE</span> <span class="nv">"id"</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="nv">"accounts"</span> <span class="k">SET</span> <span class="nv">"balance"</span> <span class="o">=</span> <span class="nv">"balance"</span> <span class="o">-</span> <span class="mi">10</span> <span class="k">WHERE</span> <span class="nv">"id"</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">-- Invokes constraint error</span>
<span class="k">ROLLBACK</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="race-conditions">Race Conditions</h3>

<ul>
  <li data-marker="*">Transactions can help guard against race conditions.</li>
  <li data-marker="*">A race condition occurs when multiple entities simultaneously access and make decisions based on a shared value, potentially causing inconsistencies in the database. Unresolved race conditions can be exploited by hackers to manipulate the database.</li>
  <li data-marker="*">In the lecture, an example of a race condition is discussed wherein two users working together can exploit momentary inconsistencies in the database to rob the bank.</li>
  <li data-marker="*">However, transactions are processed in <strong>isolation</strong> to avoid the inconsistencies in the first place. Each transaction dealing with similar data from our database will be processed sequentially. This helps prevent the inconsistencies that an adversarial attack can exploit.</li>
  <li data-marker="*">To make transactions sequential, SQLite and other database management systems use <strong>locks</strong> on databases. A table in a database could be in a few different states:
    <ul>
      <li data-marker="*"><strong>UNLOCKED</strong>: this is the default state when no user is accessing the database,</li>
      <li data-marker="*"><strong>SHARED</strong>: when a transaction is reading data from the database, it obtains shared lock that allows other transactions to read simultaneously from the database,</li>
      <li data-marker="*"><strong>EXCLUSIVE</strong>: if a transaction needs to write or update data, it obtains an exclusive lock on the database that does not allow other transactions to occur at the same time (not even a read)</li>
    </ul>
  </li>
</ul>

<h3 id="questions-3">Questions</h3>

<blockquote>
  <p>How do we decide when a transaction can get an exclusive lock? How do we prioritize different kinds of transactions?</p>
</blockquote>

<ul>
  <li data-marker="*">Different algorithms could be used to make these decisions. For example, we could always choose the transaction that came first. If an exclusive transaction is needed, no other transaction can run at the same time, which is a necessary downside to ensure consistency of the table.</li>
</ul>

<blockquote>
  <p>What is the granularity of locking? Do we lock a database, a table or a row of a table?</p>
</blockquote>

<ul>
  <li data-marker="*">
    <p>This depends on the DBMS. In SQLite, we can actually do this by running an exclusive transaction as below:</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="k">EXCLUSIVE</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>If we do not complete this transaction now, and try to connect to the database through a different terminal to read from the table, we will get an error that the database is locked! This, of course, is a very coarse way of locking because it locks the entire database. Because SQLite is coarse in this manner, it has a module for prioritizing transactions and making sure an exclusive lock is obtained only for the shortest necessary duration.</p>
  </li>
</ul>

<h2 id="fin">Fin</h2>

<ul>
  <li data-marker="*">This brings us to the conclusion of Lecture 5 about Optimizing in SQL!</li>
</ul>


                    
</body>
</html>