- en: 5.4   Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4   正则表达式
- en: 原文：[https://algs4.cs.princeton.edu/54regexp](https://algs4.cs.princeton.edu/54regexp)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/54regexp](https://algs4.cs.princeton.edu/54regexp)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在大力整理中。
- en: Regular expressions.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式。
- en: '[NFA.java](NFA.java.html), [DFS.java](DFS.java.html), [Digraph.java](Digraph.java.html),
    and [GREP.java](GREP.java.html).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[NFA.java](NFA.java.html), [DFS.java](DFS.java.html), [Digraph.java](Digraph.java.html),
    和 [GREP.java](GREP.java.html).'
- en: Running time.
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时间。
- en: M = length of expression, N = length of input. Regular expression matching algorithm
    can create NFA in O(M) time and simulate input in O(MN) time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: M = 表达式长度，N = 输入长度。正则表达式匹配算法可以在O(M)时间内创建NFA，并在O(MN)时间内模拟输入。
- en: Library implementations.
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库实现。
- en: '[Validate.java](Validate.java.html).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[Validate.java](Validate.java.html)。'
- en: Most library implementations of regular expressions use a *backtracking algorithm*
    that can take an exponential amount of time on some inputs. Such inputs can be
    surprisingly simple. For example, to determine whether a string of length N is
    matched by the regular expression `(a|aa)*b` can take an amount of time exponential
    in N if the string is chosen carefully. The table below illustrates just how spectacularly
    that the Java 1.4.2 regular expression can fail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数正则表达式库实现使用*回溯算法*，在某些输入上可能需要指数级的时间。这样的输入可能非常简单。例如，确定长度为N的字符串是否与正则表达式`(a|aa)*b`匹配，如果选择字符串得当，可能需要指数级的时间。下表展示了Java
    1.4.2正则表达式的失败情况。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The above examples are artificial, but they illustrate an alarming defect in
    most regular expression libraries. Bad inputs do occur in practice. According
    to [Crosby and Wallach](http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf),
    the following regular expression appears in a version of SpamAssassin, a powerful
    spam filtering program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是人为的，但它们展示了大多数正则表达式库中的一个令人担忧��缺陷。在实践中确实会出现不良输入。根据[Crosby和Wallach](http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf)的说法，以下正则表达式出现在SpamAssassin的一个版本中，这是一个功能强大的垃圾邮件过滤程序。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It attempts to match certain email addresses, but it takes an exponential time
    to match some strings in many regular expression libraries including Sun's Java
    1.4.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图匹配某些电子邮件地址，但在许多正则表达式库中，包括Sun的Java 1.4.2中，匹配某些字符串需要指数级的时间。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is especially significant because a spammer could use a pathological return
    email addresses to denial-of-service attack a mail server that has SpamAssassin
    running. This particular pattern is now fixed because Perl 5 regular expresssions
    use an internal cache to short-circuit repeated matches at the same location during
    backtracking.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其重要，因为垃圾邮件发送者可以使用一种病态的返回电子邮件地址来拒绝服务攻击一个运行SpamAssassin的邮件服务器。这个特定的模式现在已经修复，因为Perl
    5正则表达式使用内部缓存来在回溯过程中在相同位置短路重复匹配。
- en: These deficiencies are not limited to Java's implementation. For example, GNU
    regex-0.12 takes exponential time for matching strings of the form `aaaaaaaaaaaaaac`
    with the regular expression `(a*)*|b*`. Sun's Java 1.4.2 is equally susceptible
    to this one. Moreover, Java and Perl regular expressions support back references
    - the regular expression pattern matching problem for such extended regular expressions
    is [NP hard](http://perl.plover.com/NPC/), so this exponential blowup appears
    to be inherent on some inputs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺陷不仅限于Java的实现。例如，GNU regex-0.12对于匹配形式为`aaaaaaaaaaaaaac`的字符串与正则表达式`(a*)*|b*`需要指数级的时间。Sun的Java
    1.4.2同样容易受到这个问题的影响。此外，Java和Perl正则表达式支持反向引用 - 对于这些扩展正则表达式的正则表达式模式匹配问题是[NP难的](http://perl.plover.com/NPC/)，因此在某些输入上这种指数级的增长似乎是固有的。
- en: 'Here''s one I actually wrote to try to find the last word before the string
    `NYSE`: regexp = "([\\w\\s]+).*NYSE";'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我实际写的一个，用来找到字符串`NYSE`之前的最后一个单词：regexp = "([\\w\\s]+).*NYSE";
- en: 'Reference: [Regular Expression Matching Can Be Simple And Fast (but is slow
    in Java, Perl, PHP, Python, Ruby, ...)](http://swtch.com/~rsc/regexp/regexp1.html).
    Compares Thompson NFA with backtracking approach. Contains some performance optimizations
    for Thompson NFA. Also some historical notes and references.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[正则表达式匹配可以简单快速（但在Java、Perl、PHP、Python、Ruby等中很慢）](http://swtch.com/~rsc/regexp/regexp1.html)。比较了Thompson
    NFA和回溯方法。包含了一些针对Thompson NFA的性能优化。还有一些历史注释和参考资料。
- en: Q + A
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q + A
- en: '**Q.** Documentation on Java regular expression libraries?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Java正则表达式库的文档？'
- en: '**A.** Here is Oracle''s guide to [using regular expressions](http://docs.oracle.com/javase/tutorial/essential/regex/).
    It includes [many more operations](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html)
    that we will not explore. Also see the `String` methods `matches()`, `split()`,
    and `replaceAll()`. These are shorthands for using the `Pattern` and `Matcher`
    classes. Here''s some [common regular expression patterns](http://javaalmanac.com/cgi-bin/search/find.pl?words=regex).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这里是Oracle关于[使用正则表达式的指南](http://docs.oracle.com/javase/tutorial/essential/regex/)。它包括[更多操作](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html)，我们不会探索。还请参阅`String`方法`matches()`、`split()`和`replaceAll()`。这些是使用`Pattern`和`Matcher`类的简写。这里有一些[常见的正则表达式模式](http://javaalmanac.com/cgi-bin/search/find.pl?words=regex)。'
- en: '**Q.** Industrial grade regular expressions for email addresses, Java identifiers,
    integers, decimal, etc.?'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 用于电子邮件地址、Java标识符、整数、小数等的工业级别正则表达式？'
- en: '**A.** Here''s a [library of useful regular expressions](http://regexlib.com/)
    that offers industrial grade patterns for email addresses, URLs, numbers, dates,
    and times. Try this [regular expression tool](http://www.weitz.de/regex-coach/).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这里有一个[有用的正则表达式库](http://regexlib.com/)，提供了工业级别的模式，用于匹配电子邮件地址、URL、数字、日期和时间。试试这个[正则表达式工具](http://www.weitz.de/regex-coach/)。'
- en: '**Q.** I''m confused why does (a | b)* match all strings of a''s and b''s,
    instead of only string with all a''s or string with all b''s?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我困惑为什么`(a | b)*`匹配所有的a和b的字符串，而不仅仅是所有a的字符串或所有b的字符串？'
- en: '**A.** The * operator replicates the regular expression (and not a fixed string
    that matches the regular expression). So the above is equivalent to ε | (a|b)
    | (a|b)(a|b) | (a|b)(a|b)(a|b) | ....'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** History?'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** In the 1940s, Warren McCulloch and Walter Pitts modeled neurons as finite
    automata to describe the nervous system. In 1956, Steve Kleene invented a mathematical
    abstraction called *regular sets* to describe these models. *Representation of
    events in nerve nets and finite automata.* in Automata Studies, 3-42, Princeton
    University Press, Princeton, New Jersey 1956.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Any tools for visualizing regular expressions?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Try [Debuggerx](http://www.debuggex.com).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a regular expression for each of the following sets of binary strings.
    Use only the basic operations.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 or 11 or 101
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: only 0s
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answers*: 0 | 11 | 101, 0*'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a regular expression for each of the following sets of binary strings.
    Use only the basic operations.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: all binary strings
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: all binary strings except empty string
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: begins with 1, ends with 1
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ends with 00
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: contains at least three 1s
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answers*: (0|1)*, (0|1)(0|1)*, 1 | 1(0|1)*1, (0|1)*00, (0|1)*1(0|1)*1(0|1)*1(0|1)*
    or 0*10*10*1(0|1)*.'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a regular expression to describe inputs over the alphabet {a, b, c} that
    are in sorted order. *Answer*: a*b*c*.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a regular expression for each of the following sets of binary strings.
    Use only the basic operations.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: contains at least three consecutive 1s
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: contains the substring 110
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: contains the substring 1101100
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: doesn't contain the substring 110
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answers*: (0|1)*111(0|1)*, (0|1)*110(0|1)*, (0|1)*1101100(0|1)*, (0|10)*1*.
    The last one is by far the trickiest.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a regular expression for binary strings with at least two 0s but not consecutive
    0s.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a regular expression for each of the following sets of binary strings.
    Use only the basic operations.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: has at least 3 characters, and the third character is 0
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: number of 0s is a multiple of 3
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: starts and ends with the same character
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: odd length
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: starts with 0 and has odd length, or starts with 1 and has even length
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: length is at least 1 and at most 3
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answers*: (0|1)(0|1)0(0|1)*,   1* | (1*01*01*01*)*,   1(0|1)*1 | 0(0|1)*0
    | 0 | 1,   (0|1)((0|1)(0|1))*,   0((0|1)(0|1))* | 1(0|1)((0|1)(0|1))*,   (0|1)
    | (0|1)(0|1) | (0|1)(0|1)(0|1).'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For each of the following, indicate how many bit strings of length exactly
    1000 are matched by the regular expression: `0(0 | 1)*1`, `0*101*`, `(1 | 01)*`.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a regular expression that matches all strings over the alphabet {a, b,
    c} that contain:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: starts and ends with a
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: at most one a
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: at least two a's
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: an even number of a's
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: number of a's plus number of b's is even
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find long words whose letters are in alphabetical order, e.g., `almost` and
    `beefily`. *Answer*: use the regular expression ''^a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*$''.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Java regular expression to match phone numbers, with or without area
    codes. The area codes should be of the form (609) 555-1234 or 555-1234.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all English words that end with `nym`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Final all English words that contain the trigraph `bze`. *Answer*: subzero.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find all English words that start with g, contain the trigraph `pev` and end
    with e. *Answer*: grapevine.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all English words that contain the trigraph `spb` and have at least two
    r's.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the longest English word that can be written with the top row of a standard
    keyboard. *Answer*: proprietorier.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find all words that contain the four letters a, s, d, and f, not necessarily
    in that order. *Solution*: `cat words.txt | grep a | grep s | grep d | grep f`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a string of A, C, T, and G, and X, find a string where X matches any single
    character, e.g., CATGG is contained in ACTGGGXXAXGGTTT.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Java regular expression, for use with [Validate.java](Validate.java.html),
    that validates Social Security numbers of the form 123-45-6789. *Hint:* use `\d`
    to represent any digit. *Answer:* `[0-9]{3}-[0-9]{2}-[0-9]{4}`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the previous exercise to make the `-` optional, so that 123456789 is
    considered a legal input.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改上一个练习，使`-`成为可选项，这样123456789就被视为合法输入。
- en: Write a Java regular expression to match all strings that contain exactly five
    vowels and the vowels are in alphabetical order. *Answer:* `[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配包含恰好五个元音字母且元音字母按字母顺序排列的所有字符串。 *答案:* `[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*`
- en: Write a Java regular expression to match valid Windows XP file names. Such a
    file name consists of any sequence of characters other than
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配有效的Windows XP文件名。这样的文件名由除了冒号以外的任意字符序列组成。
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Additionally, it cannot begin with a space or period.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，它不能以空格或句号开头。
- en: Write a Java regular expression to match valid OS X file names. Such a file
    name consists of any sequence of characters other than a colon. Additionally,
    it cannot begin with a period.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，描述有效的OS X文件名。这样的文件名由除冒号以外的任意字符序列组成。此外，它不能以句点开头。
- en: Given a string `s` that represents the name of an IP address in *dotted quad*
    notation, break it up into its constituent pieces, e.g., 255.125.33.222. Make
    sure that the four fields are numeric.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个代表IP地址的名称为`s`的字符串，采用*dotted quad*表示法，将其分解为其组成部分，例如，255.125.33.222。确保四个字段都是数字。
- en: Write a Java regular expression to describe all dates of the form *Month DD,
    YYYY* where *Month* consists of any string of upper or lower case letters, the
    date is 1 or 2 digits, and the year is exactly 4 digits. The comma and spaces
    are required.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，描述形式为*Month DD, YYYY*的所有日期，其中*Month*由任意大写或小写字母字符串组成，日期是1或2位数字，年份正好是4位数字。逗号和空格是必需的。
- en: 'Write a Java regular expression to describe valid IP addresses of the form
    a.b.c.d where each letter can represent 1, 2, or 3 digits, and the periods are
    required. Yes: 196.26.155.241.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，描述形式为a.b.c.d的有效IP地址，其中每个字母可以表示1、2或3位数字，句点是必需的。是：196.26.155.241。
- en: Write a Java regular expression to match license plates that start with 4 digits
    and end with two uppercase letters.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配以4位数字开头并以两个大写字母结尾的车牌。
- en: Write a regular expression to extract the coding sequence from a DNA string.
    It starts with the ATG codon and ends with a stop codon (TAA, TAG, or TGA). [reference](http://bioportal.weizmann.ac.il/course/prog/regexps/5.html)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，从DNA字符串中提取编码序列。它以ATG密码子开头，以停止密码子（TAA、TAG或TGA）结尾。[参考](http://bioportal.weizmann.ac.il/course/prog/regexps/5.html)
- en: 'Write a regular expression to check for the sequence rGATCy: that is, does
    it start with A or G, then GATC, and then T or C.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式来检查序列rGATCy：即，它是否以A或G开头，然后是GATC，最后是T或C。
- en: Write a regular expression to check whether a sequence contains two or more
    repeats of the the GATA tetranucleotide.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式来检查一个序列是否包含两个或更多次重复的GATA四核苷酸。
- en: Modify [Validate.java](Validate.java.html) to make the searches case insensitive.
    *Hint:* use the `(?i)` embedded flag.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[Validate.java](Validate.java.html)使搜索不区分大小写。 *提示:* 使用`(?i)`嵌入式标志。
- en: 'Write a Java regular expression to match various spellings of Libyan dictator
    Moammar Gadhafi''s last name using the folling template: (i) starts with K, G,
    Q, (ii) optionally followed by H, (iii) followed by AD, (iv) optionally followed
    by D, (v) optionally followed by H, (vi) optionally followed by AF, (vii) optionally
    followed by F, (vii) ends with I.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配利比亚独裁者穆阿迈尔·卡扎菲姓氏的各种拼写，使用以下模板：(i)以K、G、Q开头，(ii)可选地跟随H，(iii)后跟AD，(iv)可选地跟随D，(v)可选地跟随H，(vi)可选地跟随AF，(vii)可选地跟随F，(vii)以I结尾。
- en: Write a Java program that reads in an expression like `(K|G|Q)[H]AD[D][H]AF[F]I`
    and prints out all matching strings. Here the notation `[x]` means 0 or 1 copy
    of the letter `x`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java程序，读取类似`(K|G|Q)[H]AD[D][H]AF[F]I`的表达式，并打印出所有匹配的字符串。这里的符号`[x]`表示字母`x`的0或1个副本。
- en: Why doesn't `s.replaceAll("A", "B");` replace all occurrences of the letter
    A with B in the string s?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`s.replaceAll("A", "B");`不会替换字符串`s`中所有出现的字母A为B？
- en: '*Answer*: Use `s = s.replaceAll("A", "B");` instead The method `replaceAll`
    returns the resulting string, but does not change `s` itself. Strings are immutable.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：使用`s = s.replaceAll("A", "B");`代替。`replaceAll`方法返回结果字符串，但不会改变`s`本身。字符串是不可变的。'
- en: Write a program [Clean.java](Clean.java.html) that reads in text from standard
    input and prints it back out, removing any trailing whitespace on a line and replacing
    all tabs with 4 spaces.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Clean.java](Clean.java.html)，从标准输入中读取文本并将其打印出来，在一行上去除任何尾随空格，并用4个空格替换所有制表符。
- en: '*Hint:* use `replaceAll()` and the regular expression `\s` for whitespace.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示:* 使用`replaceAll()`和正则表达式`\s`匹配空格。'
- en: 'Write a regular expression to match all of the text between the text `a href
    ="` and the next `"`. *Answer*: `href=\"(.*?)\"`. The `?` makes the `.*` reluctant
    instead of greedy. In Java, use `Pattern.compile("href=\\\"(.*?)\\\"", Pattern.CASE_INSENSITIVE)`
    to escape the backslash characters.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，匹配在文本`a href ="`和下一个`"`之间的所有文本。 *答案:* `href=\"(.*?)\"`。`?`使`.*`变得不贪婪而是懒惰。在Java中，使用`Pattern.compile("href=\\\"(.*?)\\\"",
    Pattern.CASE_INSENSITIVE)`来转义反斜杠字符。
- en: Use regular expressions to extract all of the text between the tags `<title>`
    and `<\title>`. The `(?i)` is another way to make the match case insensitive.
    The `$2` refers to the second captured subsequence, i.e., the stuff between the
    `title` tags.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则表达式提取在`<title>`和`<\title>`标签之间的所有文本。`(?i)`是另一种使匹配不区分大小写的方法。`$2`指的是第二个捕获的子序列，即`title`标签之间的内容。
- en: '[PRE5]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Write a regular expression to match all of the text between <TD ...> and </TD>
    tags. *Answer*: `<TD[^>]*>([^<]*)</TD>`'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式来匹配在<TD ...>和</TD>标签之间的所有文本。 *答案*：`<TD[^>]*>([^<]*)</TD>`
- en: Creative Exercises
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**FMR-1 triplet repeat region.** "The human FMR-1 gene sequence contains a
    triplet repeat region in which the sequence CGG or AGG is repeated a number of
    times. The number of triplets is highly variable between individuals, and increased
    copy number is associated with fragile X syndrome, a genetic disease that causes
    intellectual disability and other symptoms in one out of 2000 children." (Reference:
    Biological Sequence Analysis by Durbin et al). The pattern is bracket by GCG and
    CTG, so we get the regular expression GCG (CGG | AGG)* CTG.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**FMR-1三联重复区域。** “人类FMR-1基因序列包含一个三联重复区域，在该区域中序列CGG或AGG重复多次。三联体的数量在个体之间高度变化，增加的拷贝数与脆性X综合征相关，这是一种导致2000名儿童中的一名智力残疾和其他症状的遗传疾病。”（参考：Durbin等人的《生物序列分析》）。该模式由GCG和CTG括起来，因此我们得到正则表达式GCG
    (CGG | AGG)* CTG。'
- en: '**Ad blocking.** [Adblock](http://adblock.mozdev.org/) uses regular expressions
    to block banner adds under the Mozilla and Firebird browsers.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**广告拦截。** [Adblock](http://adblock.mozdev.org/) 使用正则表达式来阻止Mozilla和Firebird浏览器下的横幅广告。'
- en: '**Parsing text files.** A more advanced example where we want to extract specific
    pieces of the matching input. This program typifies the process of parsing scientific
    input data.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析文本文件。** 一个更高级的例子，我们想要提取匹配输入的特定部分。这个程序代表了解析科学输入数据的过程。'
- en: '**PROSITE to Java regular expression.** Write a program to read in a PROSITE
    pattern and print out the corresponding Java regular expression. PROSITE is the
    "first and most famous" database of protein families and domains. Its main use
    it to determine the function of uncharacterized proteins translated from genomic
    sequences. Biologists use [PROSITE](http://us.expasy.org/tools/scanprosite/scanprosite-doc.html)
    pattern syntax rules to search for patterns in biological data. Here is the raw
    data for [CBD FUNGAL](http://us.expasy.org/cgi-bin/get-prosite-raw.pl?PS00562)
    (accession code PS00562). Each line contains various information. Perhaps the
    most interesting line is the one that begins with PA - it contains the pattern
    that describes the protein motif. Such patterns are useful because they often
    correspond to functional or structural features.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PROSITE到Java正则表达式。** 编写一个程序，读取PROSITE模式并打印出相应的Java正则表达式。PROSITE是蛋白质家族和结构域的“第一个和最著名”的数据库。其主要用途是确定从基因组序列翻译而来的未知功能蛋白质的功能。生物学家使用[PROSITE](http://us.expasy.org/tools/scanprosite/scanprosite-doc.html)
    模式语法规则在生物数据中搜索模式。这是[CBD FUNGAL](http://us.expasy.org/cgi-bin/get-prosite-raw.pl?PS00562)（访问代码PS00562）的原始数据。每行包含各种信息。也许最有趣的一行是以PA开头的行
    - 它包含描述蛋白质基序的模式。这些模式很有用，因为它们通常对应于功能或结构特征。'
- en: '[PRE6]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each uppercase letter corresponds to one amino acid residue. The alphabet consists
    of uppercase letters corresponding to the 2x amino acids. The `-` character means
    concatenation. For example, the pattern above begins with CGG (Cys-Gly-Gly). The
    notation `x` plays the role of a wildcard - it matches any amino acid. This corresponds
    to `.` in our notation. Parentheses are used to specify repeats: `x(2)` means
    exactly two amino acids, and `x(4,7)` means between 4 and 7 amino acids. This
    corresponds to `.{2}` and `.{4,7}` in Java notation. Curly braces are used to
    specify forbidden residues: {CG} means any residue other than C or G. The asterisk
    has its usual meaning.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个大写字母对应一个氨基酸残基。字母表由对应于2x氨基酸的大写字母组成。连字符`-`表示连接。例如，上面的模式以CGG（Cys-Gly-Gly）开头。符号`x`扮演通配符的角色
    - 它匹配任何氨基酸。这对应于我们符号中的`.`。括号用于指定重复：`x(2)`表示恰好两个氨基酸，`x(4,7)`表示4到7个氨基酸。这对应于Java符号中的`.{2}`和`.{4,7}`。花括号用于指定禁止的残基：{CG}表示除C或G之外的任何残基。星号具有其通常的含义。
- en: '**Text to speech synthesis.** Original motivation for grep. "For example, how
    do you cope with the digraph ui, which is pronounced many different ways: fruit,
    guile, guilty, anguish, intuit, beguine?"'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文本转语音合成。** grep的原始动机。“例如，如何处理发音多种不同的二连音ui：fruit, guile, guilty, anguish,
    intuit, beguine？”'
- en: '**Challenging regular expressions.** Write a regular expression for each of
    the following sets of binary strings. Use only the basic operations.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有挑战性的正则表达式。** 为以下每组二进制字符串编写一个正则表达式。只使用基本操作。'
- en: any string except 11 or 111
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了11或111之外的任何字符串
- en: every odd symbol is a 1
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个奇数符号是1
- en: contains at least two 0s and at most one 1
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含至少两个0和最多一个1
- en: no consecutive 1s
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有连续的1s
- en: '**Binary divisibility.** Write a regular expression for each of the following
    sets of binary strings. Use only the basic operations.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二进制可被整除。** 为以下每组二进制字符串编写一个正则表达式。只使用基本操作。'
- en: bit string interpreted as binary number is divisible by 3
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以二进制数解释的比特串可被3整除
- en: bit string interpreted as binary number is divisible by 123
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以二进制数解释的比特串可被123整除
- en: '**Boston accent.** Write a program to replace all of the r''s with h''s to
    translate a sentence like "Park the car in Harvard yard" into the Bostonian version
    "Pahk the cah in Hahvahd yahd".'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波士顿口音。** 编写一个程序，将所有的r替换为h，将句子翻译成波士顿版本，例如将“Park the car in Harvard yard”翻译为波士顿版本的“Pahk
    the cah in Hahvahd yahd”。'
- en: '**File extension.** Write a program that takes the name of a file as a command
    line argument and prints out its file type extension. The *extension* is the sequence
    of characters following the last `.`. For example the file `sun.gif` has the extension
    `gif`. Hint: use `split("\\.")`; recall that `.` is a regular expression meta-character,
    so you need to escape it.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文件扩展名。** 编写一个程序，以文件名作为命令行参数，并打印出其文件类型扩展名。*扩展名*是跟在最后一个`.`后面的字符序列。例如，文件`sun.gif`的扩展名是`gif`。提示：使用`split("\\.")`；请记住`.`是一个正则表达式元字符，因此您需要转义它。'
- en: '**Reverse subdomains.** For web log analysis, it is convenient to organize
    web traffic based on subdomains like `wayne.faculty.cs.princeton.edu`. Write a
    program to read in a domain name and print it out in reverse order like `edu.princeton.cs.faculty.wayne`.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反向子域。** 为了进行网络日志分析，方便地根据子域（如`wayne.faculty.cs.princeton.edu`）组织网络流量。编写一个程序来读取域名并以反向顺序打印出来，如`edu.princeton.cs.faculty.wayne`。'
- en: '**Bank robbery.** You just witnessed a bank robbery and got a partial license
    plate of the getaway vehicle. It started with `ZD`, had a `3` somewhere in the
    middle and ended with `V`. Help the police officer write regular expression for
    this plate.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**银行抢劫。** 你刚刚目睹了一起银行抢劫案，并且得到了逃跑车辆的部分车牌号。它以`ZD`开头，中间有一个`3`，以`V`结尾。帮助警官写出这个车牌的正则表达式。'
- en: '**Regular expression for permutations.** Find the shortest regular expression
    (using only the basic operations) you can for the set of all permutations on N
    elements for N = 5 or 10. For example if N = 3, then the language is abc, acb,
    bac, bca, cab, cba. *Answer*: difficult. Solution has length exponential in N.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列的正则表达式。** 找到N个元素的所有排列集合的最短正则表达式（仅使用基本操作），其中N = 5或10。例如，如果N = 3，则语言是abc，acb，bac，bca，cab，cba。*答案：*困难。解决方案的长度与N呈指数关系。'
- en: '**Parsing quoted strings.** Read in a text file and print out all quote strings.
    Use a regular expression like `"[^"]*"`, but need to worry about escaping the
    quotation marks.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析带引号的字符串。** 读取一个文本文件并打印出所有带引号的字符串。使用类似`"[^"]*"`的正则表达式，但需要担心转义引号。'
- en: '**Parsing HTML.** A >, optionally followed by whitespace, followed by `a`,
    followed by whitespace, followed by `href`, optionally followed by whitespace,
    followed by `=`, optionally followed by whitespace, followed by `"http://`, followed
    by characters until `"`, optionally followed by whitespace, then a `<`.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析HTML。** 一个>，可选地跟随空格，后跟`a`，后跟空格，后跟`href`，可选地跟随空格，后跟`=，可选地跟随空格，后跟`"http://`，后跟字符直到`"，可选地跟随空格，然后是一个<。'
- en: '[PRE7]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Subsequence.** Given a string s, determine whether it is a subsequence of
    another string t. For example, abc is a subsequence of achfdbaabgabcaabg. Use
    a regular expression. Now repeat the process without using regular expressions.
    Answer: (a) a.*b.*c.*, (b) use a greedy algorithm.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子序列。** 给定一个字符串`s`，确定它是否是另一个字符串`t`的子序列。例如，abc是achfdbaabgabcaabg的一个子序列。使用正则表达式。现在不使用正则表达式重复这个过程。答案：(a)
    a.*b.*c.*，(b) 使用贪婪算法。'
- en: '**Huntington''s disease diagnostic.** The gene that causes Huntington''s disease
    is located on chromosome 4, and has a variable number of repeats of the CAG trinucleotide
    repeat. Write a program to determine the number of repeats and print `will not
    develop HD` If the number of repeats is less than 26, `offspring at risk` if the
    number is 37-35, `at risk` if the number is between 36 and 39, and `will develop
    HD` if the number is greater than or equal to 40. This is how Huntington''s disease
    is identified in genetic testing.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**亨廷顿病诊断。** 导致亨廷顿病的基因位于染色体4上，并且具有可变数量的CAG三核苷酸重复。编写一个程序来确定重复次数并打印`不会患HD`，如果重复次数少于26，则打印`后代有风险`，如果数字为37-35，则打印`有风险`，如果数字在36和39之间，则打印`将患HD`。这就是遗传测试中识别亨廷顿病的方式。'
- en: '**Gene finder.** A gene is a substring of a genome that starts with the start
    codon (ATG), end with a stop codon (TAG, TAA, TAG, or TGA) and consists of a sequence
    of codons (nucleotide triplets) other than the start or stop codons. The gene
    is the substring in between the start and stop codons.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基因查找器。** 基因是基因组的一个子字符串，以起始密码子（ATG）开始，以终止密码子（TAG，TAA，TAG或TGA）结束，并由除起始或终止密码子之外的密码子序列（核苷酸三联体）组成。基因是起始和终止密码子之间的子字符串。'
- en: '**Repeat finder.** Write a program `Repeat.java` that takes two command line
    arguments, and finds the maximum number of repeats of the first command line argument
    in the file specified by the second command line argument.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复查找器。** 编写一个程序`Repeat.java`，它接受两个命令行参数，并查找指定由第二个命令行参数指定的文件中第一个命令行参数的最大重复次数。'
- en: '**Character filter.** Given a string `t` of *bad characters*, e.g. `t = "!@#$%^&*()-_=+"`,
    write a function to read in another string `s` and return the result of removing
    all of the bad characters.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符过滤器。** 给定一个包含*坏字符*的字符串`t`，例如`t = "!@#$%^&*()-_=+"`，编写一个函数来读取另一个字符串`s`并返回删除所有坏字符后的结果。'
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Wildcard pattern matcher.** Without using Java''s built in regular expressions,
    write a program [Wildcard.java](Wildcard.java.html) to find all words in the dictionary
    matching a given pattern. The special symbol * matches any zero or more characters.
    So, for example the pattern "w*ard" matches the word "ward" and "wildcard". The
    special symbol . matches any one character. Your program should read the pattern
    as a command line parameter and the list of words (separated by whitespace) from
    standard input.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通配符模式匹配器。** 不使用Java内置的正则表达式，编写一个程序[Wildcard.java](Wildcard.java.html)来查找与给定模式匹配的字典中的所有单词。特殊符号*匹配任意零个或多个字符。因此，例如模式"w*ard"匹配单词"ward"和"wildcard"。特殊符号.匹配任何一个字符。您的程序应将模式作为命令行参数读取，并从标准输入读取单词列表（由空格分隔）。'
- en: '**Wildcard pattern matcher.** Repeat the previous exercise, but this time use
    Java''s built in regular expressions. *Warning:* in the context of wildcards,
    * has a different meaning than with regular expressions.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通配符模式匹配器。** 重复上一个练习，但这次使用Java内置的正则表达式。*警告：*在通配符的上下文中，*的含义与正则表达式不同。'
- en: '**Search and replace.** Word processors allow you to search for all occurrences
    of a given query string and replace each with another replacement string. Write
    a program [SearchAndReplace.java](SearchAndReplace.java.html) that takes two strings
    as command line inputs, reads in data from standard input, and replaces all occurrences
    of the first string with the second string, and sends the results to standard
    output. *Hint*: use the method `String.replaceAll`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索和替换。** 文字处理器允许您搜索给定查询字符串的所有出现并用另一个替换字符串替换每个出现。编写一个程序[SearchAndReplace.java](SearchAndReplace.java.html)，它接受两个字符串作为命令行输入，从标准输入读取数据，并用第一个字符串替换所有出现的第一个字符串，并将结果发送到标准输出。*提示：*使用方法`String.replaceAll`。'
- en: '**Password validator.** Suppose that for security reasons you require all passwords
    to have at least one of the following characters'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密码验证器。** 假设出于安全原因，您要求所有密码至少包含以下字符之一'
- en: '[PRE9]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Write a regular expression for use with `String.matches` that returns `true`
    if and only if the password contains one of the required characters. *Answer*:
    "^[^~!@#$%^&*|]+$"'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为`String.matches`编写一个正则表达式，如果密码包含所需字符之一，则返回`true`。*答案*："^[^~!@#$%^&*|]+$"
- en: '**Alphanumeric filter.** Write a program [Filter.java](Filter.java.html) to
    read in text from standard input and eliminate all characters that are not whitespace
    or alpha-numeric. *Answer* here''s the key line.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字母数字过滤器。** 编写一个程序[Filter.java](Filter.java.html)，从标准输入中读取文本，并消除所有不是空格或字母数字的字符。*答案*
    这是关键行。'
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Converting tabs to spaces.** Write a program to convert all tabs in a Java
    source file to 4 spaces.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将制表符转换为空格。** 编写一个程序，将Java源文件中的所有制表符转换为4个空格。'
- en: '**Parsing delimited text files.** A popular way to store a database is in a
    text file with one record per line, and each field separated by a special character
    called the delimiter.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析分隔文本文件。** 存储数据库的一种流行方式是将其存储在一个文本文件中，每行一个记录，每个字段由称为分隔符的特殊字符分隔。'
- en: '[PRE11]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Write a program [Tokenizer.java](Tokenizer.java.html) that reads in two command
    line parameters, a delimiter character and the name of the file, and creates an
    array of tokens.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Tokenizer.java](Tokenizer.java.html)，它读取两个命令行参数，一个是分隔符字符，另一个是文件名，并创建一个标记数组。
- en: '**Parsing delimited text files.** Repeat the previous exercise, but use the
    `String` library method `split()`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析分隔文本文件。** 重复上一个练习，但使用`String`库方法`split()`。'
- en: '**Checking a file format.**'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查文件格式。**'
- en: '**Misspellings.** Write a Java program to verify that this list of [common
    misspellings](misspellings.txt) adapted from [Wikipedia](http://en.wikipedia.org/wiki/Wikipedia:List_of_common_misspellings)
    contains only lines of the form'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拼写错误。** 编写一个Java程序，验证这个[常见拼写错误列表](misspellings.txt)中只包含形式为的行'
- en: '[PRE12]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where the first word is the misspelling and the string in parentheses is a possible
    replacement.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个单词是拼写错误，括号中的字符串是可能的替换。
- en: '[interesting English words](http://rec-puzzles.org/new/sol.pl/language/english/spelling/single.words)'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[有趣的英语单词](http://rec-puzzles.org/new/sol.pl/language/english/spelling/single.words)'
- en: '**Size of DFA is exponential in size of RE.** Give a RE for the set of all
    bitstrings whose kth to the last character equals 1. The size of the RE should
    be linear in k. Now, give a DFA for the same set of bitstrings. How many states
    does it use?'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DFA的大小与RE的大小呈指数关系。** 给出一个RE，用于表示所有最后一个字符为1的比特串集合。RE的大小应该与k成线性关系。现在，给出同一组比特串的DFA。它使用了多少个状态？'
- en: '*Hint*: every DFA for this set of bitstrings must have at least 2^k states.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：对于这组比特串，每个确定有限自动机（DFA）至少需要有2^k个状态。'
