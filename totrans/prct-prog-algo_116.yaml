- en: 6.4   Maximum Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/64maxflow](https://algs4.cs.princeton.edu/64maxflow)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section under major construction.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum flow and minimum s-t cut.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Program [FordFulkerson.java](FordFulkerson.java.html) computes the maximum flow
    and minimum s-t cut in an edge-weighted digraph in E^2 V time using the Edmonds-Karp
    shortest augment path heuristic (though, in practice, it usually runs substantially
    faster). It uses [FlowNetwork.java](FlowNetwork.java.html) and [FlowEdge.java](FlowEdge.java.html).
  prefs: []
  type: TYPE_NORMAL
- en: Percolation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Max flow in 2D (always choose leftmost path) and 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Applications to computer graphics.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Yuri Boykov](http://www.csd.uwo.ca/~yuri/) has papers on maxflow applications
    to segmentation in computer vision. [maxflow data](http://vision.csd.uwo.ca/maxflow-data).'
  prefs: []
  type: TYPE_NORMAL
- en: Bipartite matching.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Cycle containing two vertices.** Given an undirected graph G and two distinguished
    vertices s and t, find a cycle (not necessarily simple) containing s and t, or
    report that no such cycle exists. Your algorithm should run in linear time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*. The answer is yes if and only if the maximum flow from s to t is
    at least 2\. So, run two iterations of Ford-Fulkerson in the digraph with each
    edge replace by two antiparallel edges and unit capacity.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**k-connected.** Given an undirected graph, determine whether two vertices
    s and t are k-connected (or equivalently whether there are k edge-disjoint paths).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false. If true provide a short proof, if false give a counterexample.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In any max flow, there is no directed cycle on which every edge carries positive
    flow.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There exists a max flow for which there is no directed cycle on which every
    edge carries positive flow.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If all edge capacities are distinct, the max flow is unique.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If all edge capacities are distinct, the min cut is unique.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If all edge capacities are increased by an additive constant, the min cut remains
    unchanged.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If all edge capacities are multiplied by a positive integer, the min cut remains
    unchanged.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple cycle containing two vertices.** Given an undirected graph and two
    vertices s and t, find a simple cycle containing both s and t (or report that
    no such cycle exists).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: there is a directed cycle containing both s and t if and only if there
    are two (internally) vertex-disjoint paths between s and t.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Vertex disjoint paths in an digraphs.** Given a digraph G and two vertices
    s and t, find the maximum number of of vertex-disjoint paths from s and t.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: Replace each vertex v (other than s and t) with two vertices v1 and
    v2; add an edge of capacity 1 from v1 to v2; redirect all edges pointing to v
    to point to v1; redirect all edges pointing from v to point from v2\.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Vertex disjoint paths in an undirected graph.** Given an undirected graph
    G and two vertices s and t, find the maximum number of of vertex-disjoint paths
    between s and t.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: Replace each undirected edge v-w by two directed edges v->w and w->v.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Simple path containing three vertices.** Given an undirected graph and three
    vertices u, v, and w, find a simple path containing both u, v, and w (or report
    that no such path exists).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: there is a simple path between u and w that passes through v if and
    only if there are two (internally) vertex disjoint paths, one between v to u and
    one between v to w.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unique mincut.** Given an s-t flow network, determine whether the mincut
    is unique.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: solve s-t mincut problem in G and in G^R.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unmatchable edges in a bipartite graph.** Given a bipartite graph G, an edge
    is *unmatchable* if it does not appear in any perfect matching of G.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: if G has no perfect matching, then all edges are unmatchable. Otherwise,
    find a perfect matching; orient all of the edges in the perfect matching in one
    direction and all of the remaining edges in the opposite direction; the unmatchable
    edges are all of the edges not in the perfect matching that have endpoints in
    different strongly-connected components of the resulting digraph.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mincut with fewest edges.** Given a flow network, among all mincuts, find
    one that has the fewest number of edges.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: create a new flow network G'' that is equal to G, except that w''(e)
    = w(e) * n + 1.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
