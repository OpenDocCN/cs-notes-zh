- en: Lecture 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 讲
- en: 原文：[https://cs50.harvard.edu/sql/notes/2/](https://cs50.harvard.edu/sql/notes/2/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/sql/notes/2/](https://cs50.harvard.edu/sql/notes/2/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#introduction)'
- en: '[Creating a Database Schema](#creating-a-database-schema)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建数据库模式](#creating-a-database-schema)'
- en: '[Normalizing](#normalizing)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[规范化](#normalizing)'
- en: '[Relating](#relating)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关联](#relating)'
- en: '[Questions](#questions)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions)'
- en: '[`CREATE TABLE`](#create-table)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建表](#create-table)'
- en: '[Questions](#questions-1)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-1)'
- en: '[Data Types and Storage Classes](#data-types-and-storage-classes)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据类型和存储类](#data-types-and-storage-classes)'
- en: '[Type Affinities](#type-affinities)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型亲和力](#type-affinities)'
- en: '[Adding Types to our Tables](#adding-types-to-our-tables)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[向我们的表中添加类型](#adding-types-to-our-tables)'
- en: '[Questions](#questions-2)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-2)'
- en: '[Table Constraints](#table-constraints)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表约束](#table-constraints)'
- en: '[Questions](#questions-3)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-3)'
- en: '[Column Constraints](#column-constraints)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列约束](#column-constraints)'
- en: '[Altering Tables](#altering-tables)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[修改表](#altering-tables)'
- en: '[Questions](#questions-4)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-4)'
- en: '[Fin](#fin)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[鳍](#fin)'
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In this lecture, we will learn how to design our own database schemas.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这次讲座中，我们将学习如何设计我们自己的数据库模式。
- en: Thus far, we have primarily worked with a database of books that were longlisted
    for the International Booker Prize. Now, we will look underneath the hood and
    see what commands can be used to create such a database.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要使用的是国际布克奖长名单上的书籍数据库。现在，我们将深入内部，看看可以使用哪些命令来创建这样的数据库。
- en: First, let us open up the database `longlist.db` from Week 0 on our terminal.
    As a reminder, this database contained just one table, called `longlist`. To see
    a snapshot of the table, we can run
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的终端上打开第 0 周的数据库 `longlist.db`。作为提醒，这个数据库只包含一个名为 `longlist` 的表。要查看表的快照，我们可以运行
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives us the authors and titles from the first 5 rows of the table `longlist`.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为我们提供了来自表 `longlist` 的前 5 行的作者和标题。
- en: Here is a SQLite command (not an SQL keyword) that can shed more light on how
    this database was created.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个 SQLite 命令（不是一个 SQL 关键字），它可以进一步说明这个数据库是如何创建的。
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On running this, we see the SQL statement used to create the table `longlist`.
    This shows us the columns inside `longlist` and the types of data that each column
    is able to store.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此命令后，我们看到用于创建表 `longlist` 的 SQL 语句。这显示了 `longlist` 内部的列以及每个列可以存储的数据类型。
- en: Next, let’s open up the same database from Week 1 on our terminal. This version
    of `longlist.db` contained different tables related to each other.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的终端上打开第 1 周的相同数据库。这个版本的 `longlist.db` 包含了相互关联的不同表。
- en: 'On running `.schema` again, we see many commands — one for each table in the
    database. There is a way to see the schema for a specified table:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行 `.schema` 后，我们看到许多命令——每个数据库中的表都有一个。有一种方法可以查看指定表的模式：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we see the statement used to create the `books` table. We are also able
    to see the columns and data types for each column. For example, the `"title"`
    column takes text and the `"publisher_id"` column is an integer.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们看到用于创建 `books` 表的语句。我们还能看到每个列的列名和数据类型。例如，`"title"` 列存储文本，而 `"publisher_id"`
    列是整数。
- en: Creating a Database Schema
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库模式
- en: Now that we have seen the schema for an existing database, let us create our
    own! We are tasked with representing the subway system of the city of Boston through
    a database schema. This includes the subway stations, the different train lines,
    and the people who take the trains.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经看到了现有数据库的模式，让我们创建自己的！我们的任务是使用数据库模式来表示波士顿市的地铁系统。这包括地铁站点、不同的列车线路以及乘坐列车的人们。
- en: '!["Boston Subway Map"](../Images/aa88bf7ddc0b147d981c34b183ab1801.png)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![波士顿地铁图](../Images/aa88bf7ddc0b147d981c34b183ab1801.png)'
- en: To break down the question further, we need to decide…
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进一步分解这个问题，我们需要决定……
- en: what kinds of tables we will have in our Boston Subway database,
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在波士顿地铁数据库中有什么类型的表，
- en: what columns each of the tables will have, and
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表将有哪些列，以及
- en: what types of data we should put in each of those columns.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在每一列中放入哪些类型的数据。
- en: Normalizing
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范化
- en: Observe this initial attempt at creating a table to represent Boston Subway
    data. This table contains subway rider names, current stations the riders are
    at and the action performed at the station (like entering and exiting). It also
    records the fares paid and balance amounts on their subway cards. This table also
    contains an ID for each rider “transaction”, which serves as the primary key.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察这个创建表示波士顿地铁数据的表的初步尝试。这个表包含地铁乘客姓名、乘客当前所在的车站以及在该车站执行的操作（如进入和离开）。它还记录了乘客在地铁卡上的付费金额和余额。这个表还包含每个乘客“交易”的ID，作为主键。
- en: '!["First attempt at table for Boston subway"](../Images/06fa3eab60c71d3c41d0ca02a316f783.png)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![波士顿地铁表的第一尝试](../Images/06fa3eab60c71d3c41d0ca02a316f783.png)'
- en: What redundancies exist in this table?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个表中存在哪些冗余？
- en: We may choose to separate out rider names into a table of its own, to avoid
    having to duplicate the names so many times. We would need to give each rider
    an ID that can be used to relate the new table to this one.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择将乘客姓名分离到一个单独的表中，以避免多次重复名称。我们需要为每个乘客提供一个ID，以便将新表与这个表关联起来。
- en: We may similarly choose to move subway stations to a different table and give
    each subway station an ID to be used as a foreign key here.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择将地铁车站移动到不同的表，并为每个地铁车站分配一个ID，用作这里的外键。
- en: The process of separating our data in this manner is called **normalizing**.
    When normalizing, we put each entity in its own table—as we did with riders and
    subway stations. Any information about a specific entity, for example a rider’s
    address, goes into the entity’s own table.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式分离我们的数据的过程称为**规范化**。在规范化过程中，我们将每个实体放入自己的表中——就像我们对乘客和地铁车站所做的那样。关于特定实体的任何信息，例如乘客的地址，都放入实体的表中。
- en: Relating
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关联
- en: We now need to decide how our entities (riders and stations) are related. A
    rider will likely visit multiple stations, and a subway station is likely to have
    more than one rider. Given this, it will be a many-to-many relationship.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在需要决定我们的实体（乘客和车站）之间的关系。一个乘客可能会访问多个车站，一个地铁站可能有多于一个乘客。鉴于这一点，这将是一个多对多关系。
- en: We can also use an ER diagram to represent this relationship.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以使用ER图来表示这种关系。
- en: '!["Many-to-many relationship between riders and stations"](../Images/8d98b6b3c2687fe82d6ec018ef4640a2.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![乘客和车站之间的多对多关系](../Images/8d98b6b3c2687fe82d6ec018ef4640a2.png)'
- en: Here, we see that every rider must visit at least one station to be considered
    a rider. A station, though, could have no riders visiting it, because perhaps
    it is out of order temporarily. However, it is likely that a station has multiple
    riders visiting it, indicated by the crow’s foot in the ER diagram.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们看到每个乘客必须访问至少一个车站才能被认为是乘客。然而，一个车站可能没有乘客访问它，因为这可能是暂时出了故障。然而，一个车站可能有多个乘客访问它，这在ER图中用鸟脚符号表示。
- en: Questions
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Does the relationship between riders and stations have to be exactly the way
    described here? For example, why is it okay for a station to have 0 riders?
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乘客和车站之间的关系必须像这里描述的那样精确吗？例如，为什么车站可以有0个乘客？
- en: It is up to the person designing the database to make decisions about relationships
    between entities. It is possible to add a constraint that says a station must
    have at least one rider to be considered a station.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据库的人需要决定实体之间的关系。可以添加一个约束，说明一个车站必须至少有一个乘客才能被认为是车站。
- en: '`CREATE TABLE`'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`'
- en: Now that we have the schema for two of the tables, let’s go ahead and create
    the tables.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经有了两张表的架构，让我们继续创建这些表。
- en: Let us open up a new database called `mbta.db` — MBTA stands for Massachusetts
    Bay Transportation Authority and runs the Boston Subway.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们打开一个新的数据库，命名为 `mbta.db` —— MBTA代表马萨诸塞湾交通管理局，它运营波士顿地铁。
- en: If we run `.schema`, we will see nothing because no table has been created in
    this database yet.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们运行 `.schema`，我们将看不到任何内容，因为在这个数据库中还没有创建任何表。
- en: 'In this database, we run the following command to create the first table for
    riders:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个数据库中，我们运行以下命令来创建第一个乘客表：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On running this, no results appear on the terminal. But if we run `.schema`
    again, we will now see the schema for the table `riders`, as defined by us!
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此命令后，终端上不会显示任何结果。但如果我们再次运行 `.schema`，现在我们将看到我们定义的 `riders` 表的架构！
- en: Similarly, let us create a table for stations as well.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，让我们也创建一个车站的表。
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we add a column `"line"` to store the train line that the station is a
    part of.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为 `"line"` 的列来存储车站所属的列车线路。
- en: '`.schema` now shows us the schema for both `riders` and `stations`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.schema` 现在显示了我们 `riders` 和 `stations` 的模式。'
- en: Next, we will create a table to relate these two entities. These tables are
    often called junction tables, associative entities or join tables!
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个表格来关联这两个实体。这些表格通常被称为连接表、关联实体或连接表！
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each row of this table tells us the station visited by a particular rider.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表的每一行都告诉我们特定骑手访问过的站点。
- en: Questions
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Is it necessary to indent the lines within the `CREATE TABLE` parantheses?
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `CREATE TABLE` 括号内缩进行是必要的吗？
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No, not strictly. However, we indent the column names to adhere to style conventions
    as always!
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，不是严格意义上的。然而，我们总是缩进列名以遵守样式约定！
- en: Data Types and Storage Classes
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型和存储类
- en: 'SQLite has five storage classes:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite有五种存储类：
- en: '**Null**: nothing, or empty value'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空值（Null）**：无，或空值'
- en: '**Integer**: numbers without decimal points'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：没有小数点的数字'
- en: '**Real**: decimal or floating point numbers'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实数**：小数或浮点数'
- en: '**Text**: characters or strings'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：字符或字符串'
- en: '**Blob**: Binary Large Object, for storing objects in binary (useful for images,
    audio etc.)'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制大对象（Blob）**：用于存储二进制对象（适用于图像、音频等）'
- en: A storage class can hold several data types.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类可以容纳多种数据类型。
- en: For example, these are the data types that fall under the umbrella of the Integer
    storage class.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，这些是隶属于整数存储类的数据类型。
- en: '!["Integer Storage Class and Data Types"](../Images/46a87fcad9669187e92909b90079e0a0.png)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![整数存储类和数据类型](../Images/46a87fcad9669187e92909b90079e0a0.png)'
- en: SQLite takes care of storing the input value under the right data type. In other
    words, we as programmers only need to choose a storage class and SQLite will do
    the rest!
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQLite负责将输入值存储在正确的数据类型下。换句话说，我们作为程序员只需要选择一个存储类，SQLite就会完成剩下的工作！
- en: 'Consider this question: what storage class would we use to store fares? Each
    choice comes with affordances and limitations.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑这个问题：我们会使用哪种存储类来存储票价？每个选择都有其优势和局限性。
- en: 'Integers: We can store a 10 cent fare as the number 10, but that doesn’t make
    it very clear whether the fare is 10 cents or 10 dollars.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数：我们可以将10美分的票价存储为数字10，但这并不清楚地表明票价是10美分还是10美元。
- en: 'Text: We can store the fare in text, like “$0.10”. However, now it will be
    hard to perform mathematical operations like adding up a rider’s fares.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本：我们可以将票价存储为文本，如“$0.10”。然而，现在将很难执行像加起来一个骑手的票价这样的数学运算。
- en: 'Real: We can store the fare using a floating point number, like 0.10, but it
    is not possible to store floating point numbers in binary precisely and—depending
    on how precise we need to be—doing so may lead to miscalculations down the line.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实数：我们可以使用浮点数存储票价，如0.10，但无法精确地以二进制形式存储浮点数，并且——根据我们需要多精确——这样做可能会导致后续的计算错误。
- en: Type Affinities
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型亲和力
- en: It is possible to specify the data type of a column while creating a table.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建表时可以指定列的数据类型。
- en: However, columns in SQLite don’t always store one particular data type. They
    are said to have **type affinities**, meaning that they try to convert an input
    value into the type they have an affinity for.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，SQLite中的列并不总是存储特定的一种数据类型。它们据说有**类型亲和力**，这意味着它们试图将输入值转换为它们具有亲和力的类型。
- en: 'The five type affinities in SQLite are: Text, Numeric (either integer or real
    values based on what the input value best converts to), Integer, Real and Blob.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite中有五种类型亲和力：文本、数值（基于输入值最佳转换的整数或实数值）、整数、实数和二进制大对象。
- en: Consider a column with a type affinity for Integers. If we try to insert “25”
    (the number 25 but stored as text) into this column, it will be converted into
    an integer data type.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个对整数有类型亲和力的列。如果我们尝试将“25”（数字25但以文本形式存储）插入到这个列中，它将被转换为整数数据类型。
- en: Similarly, inserting an integer 25 into a column with a type affinity for text
    will convert the number to its text equivalent, “25”.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，将整数25插入到对文本有类型亲和力的列中，将数字转换为它的文本等价物，“25”。
- en: Adding Types to our Tables
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类型添加到我们的表中
- en: To create the tables in our database again, we will first need to drop (or delete)
    the existing tables.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要再次创建我们数据库中的表，我们首先需要删除（或删除）现有的表。
- en: Let’s try the following commands
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们尝试以下命令
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Running these statements gives no output, but `.schema` shows us that the tables
    have now been dropped.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行这些语句没有输出，但 `.schema` 显示表已经被删除。
- en: Next, let us create a schema file that can be run to create the tables from
    scratch. This is an improvement over what we previously did—typing out the `CREATE
    TABLE` command for each table—because it allows us to edit and view the entire
    schema easily.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个可以运行以从头创建表的架构文件。这比我们之前所做的好，因为我们之前是逐个表地输入`CREATE TABLE`命令，因为这允许我们轻松地编辑和查看整个架构。
- en: Create a file `schema.sql`. Notice the extension `.sql` that enables syntax
    highlighting for SQL keywords in our editor.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`schema.sql`的文件。注意，扩展名`.sql`使得我们的编辑器能够对SQL关键字进行语法高亮。
- en: Inside the file, let’s type out the schemas again, but with the affinity types
    this time.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中，让我们再次输入架构，但这次是带有亲和类型。
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we read this file within the database to actually create the tables. Here
    is an updated ER Diagram with the data types included.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们在数据库中读取此文件以实际创建表。这是一个包含数据类型的更新后的ER图。
- en: '!["Updated ER Diagram with Data Types"](../Images/5272df34a904d9ced917a6bf075c8383.png)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更新后的ER图，包含数据类型](../Images/5272df34a904d9ced917a6bf075c8383.png)'
- en: Questions
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Previously, we were able to query the tables in our database and see the results
    in a table-like structure. How do we get the same kind of results to show up here?
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 之前，我们能够查询数据库中的表，并在类似表格的结构中看到结果。我们如何让相同类型的结果显示在这里？
- en: We haven’t yet added any data to the tables. In Lecture 3, we will see how to
    insert, update and delete rows in tables that we have created!
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还没有向表中添加任何数据。在第三讲中，我们将看到如何在我们创建的表中插入、更新和删除行！
- en: Do we have a type affinity for Boolean?
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们对布尔类型有类型亲和力吗？
- en: We don’t in SQLite, but other DBMS’s might have this option. A workaround could
    be to use 0 or 1 integer values to represent booleans.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SQLite中我们不做这样的事情，但其他数据库管理系统可能提供这个选项。一种解决方案是使用0或1的整数值来表示布尔值。
- en: Table Constraints
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表约束
- en: We can use table constraints to impose restrictions on certain values in our
    tables.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用表约束来对表中某些值施加限制。
- en: For example, a primary key column must have unique values. The table constraint
    we use for this is `PRIMARY KEY`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，主键列必须具有唯一值。我们用于此的表约束是`PRIMARY KEY`。
- en: Similarly, a constraint on a foreign key value is that it must be found in the
    primary key column of the related table! This table constraint is called, predictably,
    `FOREIGN KEY`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，外键值的一个约束是它必须在相关表的**主键列**中找到！这种表约束，不出所料，被称为`FOREIGN KEY`。
- en: Let’s add primary and foreign key constraints to our `schema.sql` file.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在`schema.sql`文件中添加主键和外键约束。
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we created two primary key columns, the ID for both `riders` and
    `stations` and then referenced these primary keys as foreign keys in the `visits`
    table.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们创建了两个主键列，即`riders`和`stations`的ID，然后在`visits`表中将这些主键作为外键引用。
- en: In the `visits` table, there is no primary key. However, SQLite gives every
    table a primary key by default, known as the row ID. Even though the row ID is
    implicit, it can be queried!
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`visits`表中，没有主键。然而，SQLite默认为每个表提供一个主键，称为行ID。尽管行ID是隐式的，但它可以被查询！
- en: It is also possible to create a primary key composed of two columns. For example,
    if we wanted to give `visits` a primary key composed of both the rider and stations
    IDs, we could use this syntax
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以创建由两列组成的复合主键。例如，如果我们想给`visits`表创建一个由骑手和站点ID组成的复合主键，我们可以使用这种语法。
- en: '[PRE11]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, we probably want to allow a rider to visit a station more than
    once, so we would not move ahead with this approach.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能希望允许骑手访问站点多次，所以我们不会采用这种方法。
- en: Questions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Is it possible to include our own primary key for the `visits` table?
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能否为`visits`表包含自己的主键？
- en: Yes! If, for some reason, an explicit primary key was required for the `visits`
    table, we could create an ID column and make it the primary key.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的！如果出于某种原因，`visits`表需要显式的主键，我们可以创建一个ID列并将其设为主键。
- en: Column Constraints
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列约束
- en: A column constraint is a type of constraint that applies to a specified column
    in the table.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列约束是一种应用于表中指定列的约束类型。
- en: 'SQLite has four column constraints:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite有四种列约束：
- en: '`CHECK`: allows checking for a condition, like all values in the column must
    be greater than 0'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHECK`：允许检查条件，例如列中的所有值都必须大于0。'
- en: '`DEFAULT`: uses a default value if none is supplied for a row'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT`：如果为行未提供值，则使用默认值。'
- en: '`NOT NULL`: dictates that a null or empty value cannot be inserted into the
    column'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT NULL`：规定列中不能插入空或空值。'
- en: '`UNIQUE`: dictates that every value in this column must be unique'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNIQUE`：规定该列中的每个值都必须是唯一的。'
- en: 'An updated schema with these contraints would look like the following:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含这些约束的更新模式如下所示：
- en: '[PRE12]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `NOT NULL` constraint ensures that a station name and line are specified.
    On the other hand, riders are not mandated to share their names, because there
    is no constraint applied to rider names. Similarly, each station must have a unique
    name, as dictated by the `UNIQUE` constraint.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NOT NULL` 约束确保指定了车站名称和线路。另一方面，乘客不需要共享他们的名字，因为没有对乘客名字应用约束。同样，每个车站必须有一个唯一的名称，这是由
    `UNIQUE` 约束规定的。'
- en: Primary key columns and by extension, foreign key columns must always have unique
    values, so there is no need to explicitly specify the `NOT NULL` or `UNIQUE` column
    constraints. The table constraint `PRIMARY KEY` includes these column constraints.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键列以及由此派生的外键列必须始终具有唯一值，因此没有必要显式指定 `NOT NULL` 或 `UNIQUE` 列约束。表约束 `PRIMARY KEY`
    包含这些列约束。
- en: Altering Tables
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改表
- en: Consider the following updated ER diagram, where the entity “Rider” has been
    swapped out with a new entity “Card” used to represent CharlieCards. CharlieCards,
    in the Boston Subway, can be loaded with money and are used to swipe into and
    sometimes out of stations.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下更新的 ER 图，其中实体“Rider”已被新的实体“Card”所取代，用于表示 CharlieCards。在波士顿地铁中，CharlieCards
    可以充值并用于进出车站。
- en: '!["Updated ER Diagram with CharlieCards and columns"](../Images/a56f3a24753aa7c5909327e0c2d7ca0c.png)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更新后的 ER 图，包含 CharlieCards 和列](../Images/a56f3a24753aa7c5909327e0c2d7ca0c.png)'
- en: Notice that a card can be swiped many times in total, but only at one station
    at a given time.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，一张卡片可以被滑动多次，但每次只能在一个车站进行。
- en: The “Card” entity has an ID, which is also its primary key.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Card” 实体有一个 ID，它也是其主键。
- en: There is also now an entity “Swipe”, with an ID of its own and a type. “Swipe”
    also records the time at which a card was swiped and the amount that was subtracted
    (equivalent to the amount of money needed to ride the subway)!
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在还有一个名为“Swipe”的实体，它有自己的 ID 和类型。“Swipe”还记录了卡片被滑动的时间和扣除的金额（相当于乘坐地铁所需的金额）！
- en: Now, to implement these changes in our database, we need to first drop the `riders`
    table.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，为了在我们的数据库中实施这些更改，我们首先需要删除 `riders` 表。
- en: '[PRE13]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running `.schema` shows us the updated schema without the `riders` table.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `.schema` 命令会显示更新后的模式，其中不包括 `riders` 表。
- en: Next, we need a `swipes` table to represent the “Swipe” entity from our updated
    ER diagram. We could alter the `visits` table in the following way.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个 `swipes` 表来表示更新后的 ER 图中的“Swipe”实体。我们可以按以下方式修改 `visits` 表。
- en: '[PRE14]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On running `.schema` we can see that the table `visits` was renamed to `swipes`.
    However, this is not the only change needed. We also need to add some columns,
    like the type of swipe.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行 `.schema` 命令，我们可以看到表 `visits` 已被重命名为 `swipes`。然而，这并不是唯一需要的更改。我们还需要添加一些列，例如滑动类型。
- en: '[PRE15]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the type affinity `TEXT` is also mentioned while adding this column.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在添加此列时也提到了类型亲和力 `TEXT`。
- en: We also have the ability to rename a column in an `ALTER TABLE` command. If
    we wanted to rename the column `"swipetype"` to make it less wordy, perhaps, we
    could try the following.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以在 `ALTER TABLE` 命令中重命名一个列。如果我们想将列 `"swipetype"` 重命名为更简洁的名称，可以尝试以下操作。
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we have the ability to drop (or remove) a column.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有能力删除（或移除）一个列。
- en: '[PRE17]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On running `.schema` again, we can confirm that the column `"type"` was dropped
    from the table.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行 `.schema` 命令，我们可以确认表中的列 `"type"` 已被删除。
- en: It is also possible to return to the schema file `schema.sql` that we had originally
    and simply make these changes there instead of altering tables. The following
    is an updated `schema.sql`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以回到最初我们拥有的模式文件 `schema.sql`，并在那里直接进行这些更改，而不是修改表。以下是一个更新的 `schema.sql`。
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let us take a couple of minutes to read through the updated schema and make
    a note of the things that seem to have changed!
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间阅读更新后的模式，并记录下看起来有所变化的地方！
- en: The tables `cards` and `swipes` are added and the `NOT NULL` column constraint
    is used to require some values in `swipes`.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cards` 和 `swipes` 表被添加，并使用 `NOT NULL` 列约束来要求 `swipes` 中的某些值。'
- en: The `"datetime"` column is given the type affinity numeric — this is because
    numeric types can store and display date values.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “datetime”列被赋予类型亲和力数值型——这是因为数值类型可以存储和显示日期值。
- en: The foreign key mapping is adjusted as needed, such that `"card_id"` is a foreign
    key referring to the ID of the `cards` table.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要调整外键映射，使得 `"card_id"` 是一个外键，引用 `cards` 表的 ID。
- en: A default value is assigned to the `"datetime"` column so that it automatically
    picks up the current timestamp if none is supplied. Notice the use of the `CURRENT_TIMESTAMP`
    — it returns the year, month, day, hour, minute and second combined into one value.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"datetime"`列被分配了一个默认值，以便在没有提供的情况下自动获取当前的时间戳。注意使用了`CURRENT_TIMESTAMP`——它返回年、月、日、小时、分钟和秒合并成一个值。'
- en: There is a check in place to ensure the amount on a swipe is not 0\. This is
    implemented through the column constraint `CHECK`, which is used with an expression
    `"amount" != 0` to ensure the value is not 0.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个检查确保滑动支付金额不是0。这是通过列约束`CHECK`实现的，它与表达式`"amount" != 0`一起使用，以确保值不是0。
- en: Similarly, there is a check on `"type"` to ensure its value is one of ‘enter’,
    ‘exit’ and ‘deposit’. This is done because when a CharlieCard is swiped, it is
    usually for one of these three purposes, so it makes sense to have `"type"` assume
    these values only. Notice the use of the `IN` keyword to carry out this check!
    Is there a way to implement this check using the `OR` operator instead?
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，对`"type"`也有一个检查，以确保其值是‘enter’、‘exit’和‘deposit’之一。这样做是因为当CharlieCard被滑动时，通常是为了这三个目的之一，所以让`"type"`只假设这些值是有意义的。注意使用了`IN`关键字来执行这个检查！有没有办法使用`OR`运算符来实现这个检查？
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: On trying to drop the table `riders`, an error comes up because we’re using
    the ID of `riders` as a foreign key. How can the table be dropped in this case?
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在尝试删除`riders`表时，出现了一个错误，因为我们正在使用`riders`的ID作为外键。在这种情况下，如何删除该表呢？
- en: Foreign key constraints within the database are checked when dropping a table.
    Before dropping `riders`, we would need to first drop the foreign key column `"rider_id"`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中删除表时，会检查外键约束。在删除`riders`表之前，我们首先需要删除外键列`"rider_id"`。
- en: How different is the syntax for a different DBMS like MySQL or PostgreSQL?
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不同数据库管理系统（如MySQL或PostgreSQL）的语法有何不同？
- en: Most of the SQLite syntax definitely applies to other database management systems
    as well. However, if we tried porting our SQLite code, some minimal changes would
    be needed.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数SQLite语法肯定也适用于其他数据库管理系统。然而，如果我们尝试移植我们的SQLite代码，可能需要进行一些最小限度的修改。
- en: If we don’t specify a type affinity of a column in SQLite, what happens?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在SQLite中未指定列的类型亲和力，会发生什么？
- en: The default type affinity is numeric, so the column would get assigned the numeric
    type affinity.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的类型亲和力是数值型，因此该列将被分配数值型亲和力。
- en: Fin
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fin
- en: This brings us to the conclusion of Lecture 2 about Designing in SQL! For an
    interesting story about the origin of the name CharlieCard, read [this](http://www.celebrateboston.com/mbta/charlie-card-origin.htm)
    article from Celebrate Boston.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就带我们来到了关于SQL设计的第2讲的内容总结！关于CharlieCard名称起源的一个有趣故事，请阅读来自Celebrate Boston的[这篇文章](http://www.celebrateboston.com/mbta/charlie-card-origin.htm)。
