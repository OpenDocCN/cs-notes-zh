- en: 4.2   Directed Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/42digraph](https://algs4.cs.princeton.edu/42digraph)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Digraphs.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *directed graph* (or *digraph*) is a set of *vertices* and a collection of
    *directed edges* that each connects an ordered pair of vertices. We say that a
    directed edge *points from* the first vertex in the pair and *points to* the second
    vertex in the pair. We use the names 0 through V-1 for the vertices in a V-vertex
    graph.![Digraph](../Images/77ac51ba17c2c450465cdb4a4dabbfba.png)
  prefs: []
  type: TYPE_NORMAL
- en: Glossary.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some definitions that we use.
  prefs: []
  type: TYPE_NORMAL
- en: A *self-loop* is an edge that connects a vertex to itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two edges are *parallel* if they connect the same ordered pair of vertices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *outdegree* of a vertex is the number of edges pointing from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *indegree* of a vertex is the number of edges pointing to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *subgraph* is a subset of a digraph's edges (and associated vertices) that
    constitutes a digraph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *directed path* in a digraph is a sequence of vertices in which there is a
    (directed) edge pointing from each vertex in the sequence to its successor in
    the sequence, with no repeated edges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directed path is *simple* if it has no repeated vertices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *directed cycle* is a directed path (with at least one edge) whose first and
    last vertices are the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directed cycle is *simple* if it has no repeated vertices (other than the
    requisite repetition of the first and last vertices).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *length* of a path or a cycle is its number of edges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We say that a vertex `w` is *reachable from* a vertex `v` if there exists a
    directed path from `v` to `w`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We say that two vertices `v` and `w` are *strongly connected* if they are mutually
    reachable: there is a directed path from `v` to `w` and a directed path from `w`
    to `v`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digraph is *strongly connected* if there is a directed path from every vertex
    to every other vertex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digraph that is not strongly connected consists of a set of *strongly connected
    components*, which are maximal strongly connected subgraphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *directed acyclic graph* (or DAG) is a digraph with no directed cycles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Anatomy of a Graph](../Images/3cca0fcb9306a13466db6ce6aae60dcb.png)     ![A
    digraph and its strong components](../Images/623d69cb540c9b8d9c1294c2a56ff512.png)'
  prefs: []
  type: TYPE_IMG
- en: Digraph graph data type.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We implement the following digraph API.![Digraph API](../Images/131f03708c3003af70d023ce3dfd0d45.png)
  prefs: []
  type: TYPE_NORMAL
- en: The key method `adj()` allows client code to iterate through the vertices adjacent
    from a given vertex.
  prefs: []
  type: TYPE_NORMAL
- en: We prepare the test data [tinyDG.txt](tinyDG.txt) using the following input
    file format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Digraph input format](../Images/464c72561a8faee2e4bec420f9a20b5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph representation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the *adjacency-lists representation*, where we maintain a vertex-indexed
    array of lists of the vertices connected by an edge to each vertex.![Adjacency-lists
  prefs: []
  type: TYPE_NORMAL
- en: representation of an undirected graph](../Images/a03cd6de373b9fe9b46255254691e839.png)
  prefs: []
  type: TYPE_NORMAL
- en: '[Digraph.java](Digraph.java.html) implements the digraph API using the adjacency-lists
    representation. [AdjMatrixDigraph.java](AdjMatrixDigraph.java.html) implements
    the same API using the adjacency-matrix representation.'
  prefs: []
  type: TYPE_NORMAL
- en: Reachability in digraphs.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depth-first search and breadth-first search are fundamentally digraph-processing
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '*Single-source reachability:* Given a digraph and source `s`, is there a directed
    path from s to v? If so, find such a path. [DirectedDFS.java](DirectedDFS.java.html)
    uses depth-first search to solve this problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Multiple-source reachability:* Given a digraph and a *set* of source vertices,
    is there a directed path from *any* vertex in the set to v? [DirectedDFS.java](DirectedDFS.java.html)
    uses depth-first search to solve this problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Single-source directed paths:* given a digraph and source `s`, is there a
    directed path from s to v? If so, find such a path. [DepthFirstDirectedPaths.java](DepthFirstDirectedPaths.java.html)
    uses depth-first search to solve this problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Single-source shortest directed paths*: given a digraph and source `s`, is
    there a directed path from s to v? If so, find a shortest such path. [BreadthFirstDirectedPaths.java](BreadthFirstDirectedPaths.java.html)
    uses breadth-first search to solve this problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cycles and DAGs.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Directed cycles are of particular importance in applications that involve processing
    digraphs. The input file [tinyDAG.txt](tinyDAG.txt) corresponds to the following
    DAG:![DAG](../Images/319b0e4b032254129bb774c69e12c3bd.png)
  prefs: []
  type: TYPE_NORMAL
- en: '*Directed cycle detection*: does a given digraph have a directed cycle? If
    so, find such a cycle. [DirectedCycle.java](DirectedCycle.java.html) solves this
    problem using depth-first search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Depth-first orders*: Depth-first search search visits each vertex exactly
    once. Three vertex orderings are of interest in typical applications:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Preorder*: Put the vertex on a queue before the recursive calls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Postorder*: Put the vertex on a queue after the recursive calls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reverse postorder*: Put the vertex on a stack after the recursive calls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DepthFirstOrder.java](DepthFirstOrder.java.html) computes these orders.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Preorder, postorder, and reverse postorder](../Images/c5f7f2d5d9ef65c1092193e6899e669d.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Topological sort*: given a digraph, put the vertices in order such that all
    its directed edges point from a vertex earlier in the order to a vertex later
    in the order (or report that doing so is not possible). [Topological.java](Topological.java.html)
    solves this problem using depth-first search. Remarkably, a reverse postorder
    in a DAG provides a topological order.![Topologial sort](../Images/c635f715b88ef50bbced1dc6e0471f53.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A digraph has a topological order if and only if it is a DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reverse postorder in a DAG is a topological sort.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With depth-first search, we can topologically sort a DAG in time proportional
    to V + E.
  prefs: []
  type: TYPE_NORMAL
- en: Strong connectivity.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strong connectivity is an equivalence relation on the set of vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reflexive*: Every vertex v is strongly connected to itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Symmetric*: If v is strongly connected to w, then w is strongly connected
    to v.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transitive*: If v is strongly connected to w and w is strongly connected to
    x, then v is also strongly connected to x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong connectivity partitions the vertices into equivalence classes, which
    we refer to as *strong components* for short. We seek to implement the following
    API:![API for strong components](../Images/c658cc75e0401ef4bef45afbdbb5a49c.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Remarkably, [KosarajuSharirSCC.java](KosarajuSharirSCC.java.html) implements
    the API with just a few lines of code added to [CC.java](../41graph/CC.java.html),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a digraph G, use [DepthFirstOrder.java](DepthFirstOrder.java.html) to
    compute the reverse postorder of its reverse, G^R.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run standard DFS on G, but consider the unmarked vertices in the order just
    computed instead of the standard numerical order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All vertices reached on a call to the recursive `dfs()` from the constructor
    are in a strong component (!), so identify them as in CC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kosaraju-Sharir algorithm uses preprocessing time and space proportional
    to V + E to support constant-time strong connectivity queries in a digraph.
  prefs: []
  type: TYPE_NORMAL
- en: Transitive closure.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *transitive closure* of a digraph G is another digraph with the same set
    of vertices, but with an edge from v to w if and only if w is reachable from v
    in G.![Transitive closure](../Images/858b43c0cccc85dca19ebced1460c5c8.png)
  prefs: []
  type: TYPE_NORMAL
- en: '[TransitiveClosure.java](TransitiveClosure.java.html) computes the transitive
    closure of a digraph by running depth-first search from each vertex and storing
    the results. This solution is ideal for small or dense digraphs, but it is not
    a solution for the large digraphs we might encounter in practice because the constructor
    uses space proportional to V^2 and time proportional to V (V + E).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a copy constructor for Digraph that takes as input a digraph G and creates
    and initializes a new copy of the digraph. Any changes a client makes to G should
    not affect the newly created digraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many strong components are there in the digraph on p. 591?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: 10\. The input file is [mediumDG.txt](mediumDG.txt).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What are the strong components of a DAG?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: Each vertex is its own strong component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'True or false: The reverse postorder of a digraph''s reverse is the same as
    the postorder of the digraph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: False.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'True or false: If we modify the Kosaraju-Sharir algorithm to run the first
    depth-first search in the digraph G (instead of the reverse digraph G^R) and the
    second depth-first search in G^R (instead of G), then it will still find the strong
    components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* True, the strong components of a digraph are the same as the strong
    components of its reverse.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'True or false: If we modify the Kosaraju-Sharir algorithm to replace the second
    depth-first search with breadth-first search, then it will still find the strong
    components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* True.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute the memory usage of a `Digraph` with `V` vertices and `E` edges, under
    the memory cost model of Section 1.4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* 56 + 40V + 64E. [MemoryOfDigraph.java](MemoryOfDigraph.java.html)
    computes it empirically assuming that no `Integer` values are cached—Java typically
    caches the integers -128 to 127\.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creative Problems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Directed Eulerian cycle.** A directed Eulerian cycle is a directed cycle
    that contains each edge exactly once. Write a digraph client [DirectedEulerianCycle.java](DirectedEulerianCycle.java.html)
    that find a directed Eulerian cycle or reports that no such cycle exists.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: Prove that a digraph G has a directed Eulerian cycle if and only if
    vertex in G has its indegree equal to its outdegree and all vertices with nonzero
    degree belong to the same strong component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Strong component.** Describe a linear-time algorithm for computing the strong
    component containing a given vertex v. On the basis of that algorithm, describe
    a simple quadratic-time algorithm for computing the strong components of a digraph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Partial solution*: To compute the strong component containing s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find the set of vertices reachable from s
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the set of vertices that can reach s
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the intersection of the two setsUsing this as a subroutine, you can find
    all strong components in time proportional to t (E + V), where t is the number
    of strong components.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hamiltonian path in DAGs.** Given a DAG, design a linear-time algorithm to
    determine whether there is a directed path that visits each vertex exactly once.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: Compute a topological sort and check if there is an edge between
    each consecutive pair of vertices in the topological order.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unique topological ordering.** Design an algorithm to determine whether a
    digraph has a unique topological ordering.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: a digraph has a unique topological ordering if and only if there is
    a directed edge between each pair of consecutive vertices in the topological order
    (i.e., the digraph has a Hamiltonian path). If the digraph has multiple topological
    orderings, then a second topological order can be obtained by swapping a pair
    of consecutive vertices.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**2-satisfiability.** Given a boolean formula in conjunctive normal form with
    M clauses and N literals such that each clause has exactly two literals, find
    a satisfying assignment (if one exists).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution sketch*: Form the *implication digraph* with 2N vertices (one per
    literal and its negation). For each clause x + y, include edges from y'' to x
    and from x'' to y. Claim: The formula is satisfiable if and only if no variable
    x is in the same strong component as its negation x''. Moreover, a topological
    sort of the kernel DAG (contract each strong component to a single vertex) yields
    a satisfying assignment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Queue-based topological order algorithm.** Develop a nonrecursive topological
    sort implementation [TopologicalX.java](TopologicalX.java.html) that maintains
    a vertex-indexed array that keeps track of the indegree of each vertex. Initialize
    the array and a queue of sources in a single pass through all the edges, as in
    Exercise 4.2.7. Then, perform the following operations until the source queue
    is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove a source from the queue and label it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrement the entries in the indegree array corresponding to the destination
    vertex of each of the removed vertex's edges.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If decrementing any entry causes it to become 0, insert the corresponding vertex
    onto the source queue.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shortest directed cycle.** Given a digraph, design an algorithm to find a
    directed cycle with the minimum number of edges (or report that the graph is acyclic).
    The running time of your algorithm should be proportional to *E V* in the worst
    case.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Application:* give a set of patients in need of kidney transplants, where
    each patient has a family member willing to donate a kidney, but of the wrong
    type. Willing to donate to another person provided their family member gets a
    kidney. Then hospital performs a "domino surgery" where all transplants are done
    simultaneously.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: run BFS from each vertex s. The shortest cycle through s is an
    edge v->s, plus a shortest path from s to v. [ShortestDirectedCycle.java](ShortestDirectedCycle.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Odd-length directed cycle.** Design a linear-time algorithm to determine
    whether a digraph has an odd-length directed cycle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* We claim that a digraph G has an odd-length directed cycle if and
    only if one (or more) of its strong components is nonbipartite (when treated as
    an undirected graph).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the digraph G has an odd-length directed cycle, then this cycle will be entirely
    contained in one of the strong components. When the strong component is treated
    as an undirected graph, the odd-length directed cycle becomes an odd-length cycle.
    Recall that an undirected graph is bipartite if and only if it has no odd-length
    cycle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose a strong component of G is nonbipartite (when treated as an undirected
    graph). This means that there is an odd-length cycle C in the strong component,
    ignoring direction. If C is a directed cycle, then we are done. Otherwise, if
    an edge v->w is pointing in the "wrong" direction, we can replace it with an odd-length
    path that is pointing in the opposite direction (which preserves the parity of
    the number of edges in the cycle). To see how, note that there exists a directed
    path P from w to v because v and w are in the same strong component. If P has
    odd length, then we replace edge v->w by P; if P has even length, then this path
    P combined with v->w is an odd-length cycle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reachable vertex in a DAG.** Design a linear-time algorithm to determine
    whether a DAG has a vertex that is reachable from every other vertex.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Compute the outdegree of each vertex. If the DAG has exactly one
    vertex v with outdegree 0, then it is reachable from every other vertex.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Reachable vertex in a digraph.** Design a linear-time algorithm to determine
    whether a digraph has a vertex that is reachable from every other vertex.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Compute the strong components and kernel DAG. Apply Exercise 4.2.37
    to the kernel DAG.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Web crawler.** Write a program [WebCrawler.java](WebCrawler.java.html) that
    uses breadth-first search to crawl the web digraph, starting from a given web
    page. Do not explicitly build the web digraph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Symbol digraph.** Modify [SymbolGraph.java](../41graph/SymbolGraph.java.html)
    to create a program [SymbolDigraph.java](SymbolDigraph.java.html) that implements
    a symbol digraph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Combinational circuits.** Determining the truth value of a combinational
    circuit given its inputs is a graph reachability problem (on a directed acyclic
    graph).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Privilege escalation.** Include an array from user class A to user class
    B if A can gain the privileges of B. Find all users that can obtain Administrator
    access in Windows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unix program tsort.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Checkers.** Extend the rules of checkers to an N-by-N checkerboard. Show
    how to determine whether a checker can become in king in the current move. (Use
    BFS or DFS.) Show how to determine whether black has a winning move. (Find a directed
    Eulerian path.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Preferential attachment model.** Web has a scale-free property and obeys
    a power law. New pages tend to *preferentially attach* to popular pages. Start
    with a single page that points to itself. At each step a new page appears with
    outdegree 1. With probability p the page points to a random page; with probability
    (1-p) the page points to an existing page with probability proportional to the
    indegree of the page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subtype checking.** Given single inheritance relations (a tree), check if
    v is an ancestor of w. Hint: v is an ancestor of w if and only if pre[v] <= pre[w]
    and post[v] >= post[w].'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subtype checking.** Repeat previous question, but with a DAG instead of a
    tree.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LCA of a rooted tree.** Given a rooted tree and two vertices v and w, find
    the *lowest common ancestor* (lca) of v and w. The lca of v and w is the shared
    ancestor furthest from the root. Among most fundamental problem on rooted trees.
    Possible to solve in O(1) time per query with linear preprocessing time (Harel-Tarjan,
    [Bender-Coloton](http://www.ics.uci.edu/~eppstein/261/BenFar-LCA-00.pdf)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a DAG where the shortest ancestral path goes to a common ancestor x that
    is not an LCA.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Nine-letter word.** Find a nine-letter English word such that remains an
    English word after successively removing each of its letters (in an appropriate
    order). Build a digraph with words and vertices and an edge from one word to another
    if it can be formed by adding one letter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: one solution is startling -> starting -> staring -> string -> sting
    -> sing -> sin -> in -> i.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Spreadsheet recalculate.** Hopefully no cyclic dependencies. Use topological
    sort of formula cell graph to determine in which order to update the cells.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nesting boxes.** A d-dimensional box with dimensions (a1, a2, ..., ad) nests
    inside a box with dimensions (b1, b2, ..., bd) if the coordinates of the second
    box can be permuted so that a1 < b1, a2 < b2, ..., ad < bd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give an efficient algorithm for determining where one d-dimensional box nests
    inside another. Hint: sort.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Show that nesting is transitive: if box i nests inside box j and box j nests
    inside box k, then box i nests inside box k.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a set of n d-dimensional boxes, given an efficient algorithm to find the
    most boxes that can be simultaneously nested.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hint*: Create a digraph with an edge from box i to box j if box i nests inside
    box j. Then run topological sort.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Warshall''s transitive closure algorithm.** [WarshallTC.java](WarshallTC.java.html)
    algorithm is ideal for dense graphs. Relies on [AdjMatrixDigraph.java](AdjMatrixDigraph.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brute-force strong components algorithm.** [BruteSCC.java](BruteSCC.java.html)
    computes the strong components by first computing the transitive closure. It takes
    O(EV) time and O(V^2) space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tarjan''s strong components algorithm.** [TarjanSCC.java](TarjanSCC.java.html)
    implements Tarjan''s algorithm for computing strong components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gabow''s strong components algorithm.** [GabowSCC.java](GabowSCC.java.html)
    implements Gabow''s algorithm for computing strong components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Digraph generator.** [DigraphGenerator.java](DigraphGenerator.java.html)
    generated various digraphs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finite Markov chains.** Recurrent state: once started in state, Markov chain
    will return with probability 1. Transient state: some probability that it will
    never return (some node j for which i can reach j, but j can''t reach i). Irreducible
    Markov chain = all states recurrent. A Markov chain is irreducible if and only
    if it is strongly connected. The recurrent components are those with no leave
    edges in the kernel DAG. Communicating classes in Markov chain are the strong
    components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Theorem. If G is strongly connected, then there is a unique stationary distribution
    pi. Moreover pi(v) > 0 for all v.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Theorem. If the kernel DAG of G has a single supernode with no leaving edges,
    then there is a unique stationary distribution pi. Moreover pi(v) > 0 for all
    v recurrent and pi(v) = 0 for all v transient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Descendants lemma.** [R. E. Tarjan] Denote by pre[v] and post[v] as the preorder
    and postorder number of v, respectively, and by nd[v] the number of descendants
    of v (including v). Prove that the following four conditions are equivalent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vertex v is an ancestor of vertex w.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: pre[v] <= pre[w] < pre[v] + nd(v).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: post[v] - nd [v] < post[w] <= post[v]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: pre[v] <= pre[w] and post[v] >= post[w] (nesting lemma)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge lemma.** [R. E. Tarjan] Prove that an edge (v, w) is one of the following
    four kinds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'w is a child of v: (v, w) is a *tree edge*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'w is a descendant but not a child of v: (v, w) is a *forward edge*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'w is an ancestor of v: (v, w) is a *back edge*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'w and v are unrelated and pre[v] > pre[w]: (v, w) is a *cross edge*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path lemma.** [R. E. Tarjan] Prove that any path from v to w with pre[v]
    < pre[w] contains a common ancestor of v and w.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove that if (v, w) is an edge and pre[v] < pre[w], then v is an ancestor of
    w in the DFS tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Postorder lemma.** [R. E. Tarjan] Prove that if P is a path such that the
    last vertex x is highest in postorder, then every vertex on the path is a descendant
    of x (and hence has a path from x).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* The proof is by induction on the length of P (or by contradiction).
    Let (v, w) be an edge such that w is a descendant of x and post[v] < post[x].
    Since w is a descendant of x, we have pre[w] >= pre[x].'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If pre[v] >= pre[x], then v is a descendant of x (by the nesting lemma).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If pre[v] < pre[x], then pre[v] < pre[w], which implies (by the previous exercise)
    that v is an ancestor of w and hence related to x. But post[v] < post[x] implies
    v is a descendant of x.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-topological order.** Design a linear-time algorithm to find a *pre-topological
    order*: and ordering of the vertices such that if there is a path from v to w
    and w appears before v in the ordering, then there must also be a path from w
    to v.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: reverse postorder is a pre-topological order. This is the crux of the
    proof of correctness of the Kosaraju-Sharir algorithm.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Wordnet.** [Using WordNet to Measure Semantic Orientations of Adjectives](http://staff.science.uva.nl/~kamps/publications/2004/kamp:usin04.pdf).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Garbage collection.** Automatic memory management in languages like Java
    is a challenging problem. Allocating memory is easy, but discovering when a program
    is finished with memory (and reclaiming it) is more difficult. Reference counting:
    doesn''t work with circular linked structure. Mark-and-sweep algorithm. Root =
    local variables and static variables. Run DFS from roots, marking all variables
    references from roots, and so on. Then, make second pass: free all unmarked objects
    and unmark all marked objects. Or a copying garbage collector would then move
    all of the marked objects to a single memory area. Uses one extra bit per object.
    JVM must pause while garbage collection occurs. Fragments memory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Applications: C leak detector (leak = unreachable, unfreed memory).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Directed cycle detection applications.** Application: check for illegal inheritance
    loop, check for deadlocking. A directory is a list of files and other directories.
    A symbolic link is a reference to another directory. When listing all files in
    a directory, need to be careful to avoid following a cycle of symbolic links!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Topological sort applications.** Application: course prerequisites, order
    in which to compile components of a large computer program, causalities, class
    inheritance, deadlocking detection, temporal dependencies, pipeline of computing
    jobs, check for symbol link loop, evaluate formula in spreadsheet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Strong component applications.** Applications to CAD, Markov chains (irreducible),
    spider traps and web search, pointer analysis, garbage collection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**One-way street theorem.** Implement an algorithm to orient the edges in an
    undirected graph so that it is strongly connected. [Robbins theorem](http://en.wikipedia.org/wiki/Robbins_theorem)
    asserts that this is possible if and only if the undirected graph is two-edge
    connected (no bridges). In this case, a solution is to run DFS and oriented all
    edges in the DFS tree away from the root and all of the remaining edges toward
    the root.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Orient edges in mixed graph to make acyclic.** A mixed graph is a graph with
    some edges that are directed and others that are undirected. Design a linear-time
    algorithm to determine whether it is possible to orient the undirected edges so
    that the resulting digraph is acyclic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Application: old city with narrow roads wants to make every road one way but
    still allow every intersection in the city to be reachable from every other city.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Orient edges in mixed graph to make a directed cycle.** A mixed graph is
    a graph with some edges that are directed and others that are undirected. Design
    a linear-time algorithm to determine whether it is possible to orient the undirected
    edges so that the resulting digraph has a directed cycle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Application: determining whether a maximum flow is unique.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: [one algorithm](https://cstheory.stackexchange.com/questions/32332/reference-for-mixed-graph-acyclicity-testing-algorithm).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Postorder lemma variant.** Let S and T be two strong components in a digraph
    G. Prove that if there is an edge e from a vertex in S to a vertex in T, then
    the highest postorder number of a vertex in S is higher than the higher postorder
    number of a vertex in T.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Number of paths in a DAG.** Given a DAG and two distinguished vertices s
    and t, design a linear-time algorithm to compute the number of directed paths
    from s to t.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint:* topological sort.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Path of length L in a DAG.** Given a DAG and two distinguished vertices s
    and t, design an algorithm to determine if there exists a path from s to t containing
    exactly L edges.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Core vertices.** Given a digraph G, a vertex v is a *core* vertex if every
    vertex in G is reachable from v. Design a linear-time algorithm that finds all
    core vertices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: create the strong components of G and look at the kernel DAG.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Strong components and bipartite matching.** Given a bipartite graph G, an
    [unmatched edge](http://trueshelf.com/exercise/136/unmatchable-edges-of-bipartite-graphs)
    is one that does not appear in any perfect matching. Design an algorithm to find
    all unmatched edges.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: prove that the following algorithm does the job. Find a perfect matching
    in G; orient the edges in the matching from one side of the bipartition to the
    other side; orient the remaining edges in the opposite direction; among the edges
    not in the perfect matching, return those that have endpoints in different strongly
    connected components.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Transitive reduction of a digraph.** The [transitive reduction](http://en.wikipedia.org/wiki/Transitive_reduction)
    of a digraph is a digraph with the fewest number of edges that has the same transitive
    closure as the original digraph. Design an V (E + V) algorithm to compute the
    transitive reduction of a digraph. Note that the transitive reduction in a digraph
    is not necessarily unique and may not be a subgraph of the original digraph. (The
    transitive reduction in a DAG is unique and is a subgraph of the original digraph.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Odd-length path.** Given a digraph G and a source vertex s, design a linear-time
    algorithm to determine all vertices that are reachable from s via a path (not
    necessarily simple) with an *odd* number of edges.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Create a new digraph G'' with two vertices v and v'' for each vertex
    v in G. For each edge v->w in G, include two edges: v->w'' and w->v''. Now, any
    path from s to v'' in G'' corresponds to an odd-length path from s to v in G.
    Run either BFS or DFS to determine the vertices reachable from s.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find a topological order of a DAG that cannot be computed as the reverse postorder
    of a DFS, no matter in which order the DFS chooses starting vertices in the constructor.
    Show that every topological order of a DAG can be computed as the reverse postorder
    of a DFS, provided that the DFS can choose the order of the starting vertices
    in the constructor arbitrarily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nonrecursive DFS.** Write a program [NonrecursiveDirectedDFS.java](NonrecursiveDirectedDFS.java.html)
    that implements depth-first search using an explicit stack instead of recursion.
    Write a program [NonrecursiveDirectedCycle.java](NonrecursiveDirectedCycle.java.html)
    that find a directed cycle without using recursion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nonrecursive topological sort.** Extend the queue-based topological sort
    algorithm [TopologicalX.java](TopologicalX.java.html) from Exercise 4.2.39 to
    find a directed cycle if the digraph has a directed cycle. Name your program [DirectedCycle.java](DirectedCycleX.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cartalk puzzle.** Find the longest word in a dictionary that has the property
    that you can remove one letter at a time (from either end or the middle) and the
    resulting string is also a word in the dictionary. For example, STRING is a 6-letter
    word with this property (STRING -> STING -> SING -> SIN -> IN -> I).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reverse postorder vs. preorder.** True or false: The reverse postorder of
    a digraph is the same as the preorder of the digraph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reverse postorder vs. preorder in Kosaraju–Sharir.** Suppose that you use
    the preorder of the digraph instead of the reverse postorder in the Kosaraju–Sharir
    algorithm. Will it still produce the strong components?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: No, run [KosarajuSharirPreorderSCC.java](KosarajuSharirPreorderSCC.java.html)
    on `tinyDG.txt`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
