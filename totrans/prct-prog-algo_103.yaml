- en: 4.2   Directed Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2   有向图
- en: 原文：[https://algs4.cs.princeton.edu/42digraph](https://algs4.cs.princeton.edu/42digraph)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/42digraph](https://algs4.cs.princeton.edu/42digraph)
- en: Digraphs.
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向图。
- en: A *directed graph* (or *digraph*) is a set of *vertices* and a collection of
    *directed edges* that each connects an ordered pair of vertices. We say that a
    directed edge *points from* the first vertex in the pair and *points to* the second
    vertex in the pair. We use the names 0 through V-1 for the vertices in a V-vertex
    graph.![Digraph](../Images/77ac51ba17c2c450465cdb4a4dabbfba.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*有向图*（或*有向图*）是一组*顶点*和一组*有向边*，每条边连接一个有序对的顶点。我们说一条有向边*从*该对中的第一个顶点*指向*该对中的第二个顶点。对于
    V 个顶点的图，我们使用名称 0 到 V-1 来表示顶点。![有向图](../Images/77ac51ba17c2c450465cdb4a4dabbfba.png)
- en: Glossary.
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语表。
- en: Here are some definitions that we use.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们使用的一些定义。
- en: A *self-loop* is an edge that connects a vertex to itself.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自环* 是连接顶点到自身的边。'
- en: Two edges are *parallel* if they connect the same ordered pair of vertices.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两条边连接相同的顶点对，则它们是*平行*的。
- en: The *outdegree* of a vertex is the number of edges pointing from it.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个顶点的*outdegree*是指指向它的边的数量。
- en: The *indegree* of a vertex is the number of edges pointing to it.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个顶点的*indegree*是指指向它的边的数量。
- en: A *subgraph* is a subset of a digraph's edges (and associated vertices) that
    constitutes a digraph.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*子图*是构成有向图的一部分边（和相关顶点）的子集。'
- en: A *directed path* in a digraph is a sequence of vertices in which there is a
    (directed) edge pointing from each vertex in the sequence to its successor in
    the sequence, with no repeated edges.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有向图中，*有向路径*是一个顶点序列，其中每个顶点到其后继顶点有一条（有向）边，且没有重复的边。
- en: A directed path is *simple* if it has no repeated vertices.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有向路径是*简单*的，如果它没有重复的顶点。
- en: A *directed cycle* is a directed path (with at least one edge) whose first and
    last vertices are the same.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*有向循环*是一条有向路径（至少有一条边），其第一个和最后一个顶点相同。
- en: A directed cycle is *simple* if it has no repeated vertices (other than the
    requisite repetition of the first and last vertices).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个有向循环没有重复的顶点（除了第一个和最后一个顶点的必要重复），那么它是*简单*的。
- en: The *length* of a path or a cycle is its number of edges.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条路径或循环的*长度*是指它的边数。
- en: We say that a vertex `w` is *reachable from* a vertex `v` if there exists a
    directed path from `v` to `w`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们说一个顶点 `w` 是*从*顶点 `v` *可达*的，如果存在一条从 `v` 到 `w` 的有向路径。
- en: 'We say that two vertices `v` and `w` are *strongly connected* if they are mutually
    reachable: there is a directed path from `v` to `w` and a directed path from `w`
    to `v`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个顶点 `v` 和 `w` 是*强连通*的，那么它们是相互可达的：从 `v` 到 `w` 有一条有向路径，从 `w` 到 `v` 也有一条有向路径。
- en: A digraph is *strongly connected* if there is a directed path from every vertex
    to every other vertex.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每个顶点到每个其他顶点都有一条有向路径，那么有向图是*强连通*的。
- en: A digraph that is not strongly connected consists of a set of *strongly connected
    components*, which are maximal strongly connected subgraphs.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非强连通的有向图由一组*强连通分量*组成，这些分量是最大的强连通子图。
- en: A *directed acyclic graph* (or DAG) is a digraph with no directed cycles.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*有向无环图*（或 DAG）是一个没有有向循环的有向图。
- en: '![Anatomy of a Graph](../Images/3cca0fcb9306a13466db6ce6aae60dcb.png)     ![A
    digraph and its strong components](../Images/623d69cb540c9b8d9c1294c2a56ff512.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图的解剖](../Images/3cca0fcb9306a13466db6ce6aae60dcb.png)     ![有向图及其强连通分量](../Images/623d69cb540c9b8d9c1294c2a56ff512.png)'
- en: Digraph graph data type.
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向图数据类型。
- en: We implement the following digraph API.![Digraph API](../Images/131f03708c3003af70d023ce3dfd0d45.png)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了以下有向图 API。![有向图 API](../Images/131f03708c3003af70d023ce3dfd0d45.png)
- en: The key method `adj()` allows client code to iterate through the vertices adjacent
    from a given vertex.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关键方法 `adj()` 允许客户端代码遍历从给定顶点邻接的顶点。
- en: We prepare the test data [tinyDG.txt](tinyDG.txt) using the following input
    file format.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下输入文件格式准备测试数据 [tinyDG.txt](tinyDG.txt)。
- en: '![Digraph input format](../Images/464c72561a8faee2e4bec420f9a20b5f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![有向图输入格式](../Images/464c72561a8faee2e4bec420f9a20b5f.png)'
- en: Graph representation.
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的表示。
- en: We use the *adjacency-lists representation*, where we maintain a vertex-indexed
    array of lists of the vertices connected by an edge to each vertex.![Adjacency-lists
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*邻接表表示法*，其中我们维护一个以顶点为索引的列表数组，其中包含与每个顶点通过边连接的顶点。![邻接表
- en: representation of an undirected graph](../Images/a03cd6de373b9fe9b46255254691e839.png)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图的表示](../Images/a03cd6de373b9fe9b46255254691e839.png)
- en: '[Digraph.java](Digraph.java.html) implements the digraph API using the adjacency-lists
    representation. [AdjMatrixDigraph.java](AdjMatrixDigraph.java.html) implements
    the same API using the adjacency-matrix representation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[Digraph.java](Digraph.java.html) 使用邻接表表示法实现了有向图 API。[AdjMatrixDigraph.java](AdjMatrixDigraph.java.html)
    使用邻接矩阵表示法实现了相同的 API。'
- en: Reachability in digraphs.
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向图中的可达性。
- en: Depth-first search and breadth-first search are fundamentally digraph-processing
    algorithms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索和广度优先搜索是基本的有向图处理算法。
- en: '*Single-source reachability:* Given a digraph and source `s`, is there a directed
    path from s to v? If so, find such a path. [DirectedDFS.java](DirectedDFS.java.html)
    uses depth-first search to solve this problem.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单源可达性:* 给定一个有向图和源 `s`，是否存在一条从 s 到 v 的有向路径？如果是，找到这样的路径。[DirectedDFS.java](DirectedDFS.java.html)
    使用深度优先搜索来解决这个问题。'
- en: '*Multiple-source reachability:* Given a digraph and a *set* of source vertices,
    is there a directed path from *any* vertex in the set to v? [DirectedDFS.java](DirectedDFS.java.html)
    uses depth-first search to solve this problem.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多源可达性:* 给定一个有向图和一组源顶点，是否存在一条从集合中的*任意*顶点到 v 的有向路径？[DirectedDFS.java](DirectedDFS.java.html)
    使用深度优先搜索来解决这个问题。'
- en: '*Single-source directed paths:* given a digraph and source `s`, is there a
    directed path from s to v? If so, find such a path. [DepthFirstDirectedPaths.java](DepthFirstDirectedPaths.java.html)
    uses depth-first search to solve this problem.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单源有向路径:* 给定一个有向图和源 `s`，是否存在一条从 s 到 v 的有向路径？如果是，找到这样的路径。[DepthFirstDirectedPaths.java](DepthFirstDirectedPaths.java.html)
    使用深度优先搜索来解决这个问题。'
- en: '*Single-source shortest directed paths*: given a digraph and source `s`, is
    there a directed path from s to v? If so, find a shortest such path. [BreadthFirstDirectedPaths.java](BreadthFirstDirectedPaths.java.html)
    uses breadth-first search to solve this problem.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单源最短有向路径*：给定一个有向图和源点`s`，是否存在从 s 到 v 的有向路径？如果有，找到一条最短的这样的路径。[BreadthFirstDirectedPaths.java](BreadthFirstDirectedPaths.java.html)使用广度优先搜索来解决这个问题。'
- en: Cycles and DAGs.
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环和DAG。
- en: Directed cycles are of particular importance in applications that involve processing
    digraphs. The input file [tinyDAG.txt](tinyDAG.txt) corresponds to the following
    DAG:![DAG](../Images/319b0e4b032254129bb774c69e12c3bd.png)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及处理有向图的应用中，有向循环尤为重要。输入文件[tinyDAG.txt](tinyDAG.txt)对应于以下DAG：![DAG](../Images/319b0e4b032254129bb774c69e12c3bd.png)
- en: '*Directed cycle detection*: does a given digraph have a directed cycle? If
    so, find such a cycle. [DirectedCycle.java](DirectedCycle.java.html) solves this
    problem using depth-first search.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有向环检测*：给定一个有向图，是否存在有向环？如果有，找到这样的环。[DirectedCycle.java](DirectedCycle.java.html)使用深度优先搜索来解决这个问题。'
- en: '*Depth-first orders*: Depth-first search search visits each vertex exactly
    once. Three vertex orderings are of interest in typical applications:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度优先顺序*：深度优先搜索每个顶点恰好一次。在典型应用中，有三种顶点排序是感兴趣的：'
- en: '*Preorder*: Put the vertex on a queue before the recursive calls.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前序*：在递归调用之前将顶点放入队列。'
- en: '*Postorder*: Put the vertex on a queue after the recursive calls.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后序*：在递归调用后将顶点放入队列。'
- en: '*Reverse postorder*: Put the vertex on a stack after the recursive calls.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逆后序*：在递归调用后将顶点放入栈。'
- en: '[DepthFirstOrder.java](DepthFirstOrder.java.html) computes these orders.'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[DepthFirstOrder.java](DepthFirstOrder.java.html)计算这些顺序。'
- en: '![Preorder, postorder, and reverse postorder](../Images/c5f7f2d5d9ef65c1092193e6899e669d.png)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![前序、后序和逆后序](../Images/c5f7f2d5d9ef65c1092193e6899e669d.png)'
- en: '*Topological sort*: given a digraph, put the vertices in order such that all
    its directed edges point from a vertex earlier in the order to a vertex later
    in the order (or report that doing so is not possible). [Topological.java](Topological.java.html)
    solves this problem using depth-first search. Remarkably, a reverse postorder
    in a DAG provides a topological order.![Topologial sort](../Images/c635f715b88ef50bbced1dc6e0471f53.png)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拓扑排序*：给定一个有向图，按顶点顺序排列，使得所有的有向边都从顺序中较早的顶点指向顺序中较晚的顶点（或报告无法这样做）。[Topological.java](Topological.java.html)使用深度优先搜索来解决这个问题。值得注意的是，在DAG中的逆后序提供了一个拓扑顺序。![拓扑排序](../Images/c635f715b88ef50bbced1dc6e0471f53.png)'
- en: Proposition.
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题。
- en: A digraph has a topological order if and only if it is a DAG.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图具有拓扑顺序当且仅当它是DAG。
- en: Proposition.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题。
- en: Reverse postorder in a DAG is a topological sort.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: DAG中的逆后序是拓扑排序。
- en: Proposition.
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题。
- en: With depth-first search, we can topologically sort a DAG in time proportional
    to V + E.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用深度优先搜索，我们可以在时间上将DAG进行拓扑排序，时间复杂度为 V + E。
- en: Strong connectivity.
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强连通性。
- en: 'Strong connectivity is an equivalence relation on the set of vertices:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 强连通性是顶点集合上的等价关系：
- en: '*Reflexive*: Every vertex v is strongly connected to itself.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自反性*：每个顶点 v 与自身强连通。'
- en: '*Symmetric*: If v is strongly connected to w, then w is strongly connected
    to v.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对称性*：如果 v 与 w 强连通，则 w 也与 v 强连通。'
- en: '*Transitive*: If v is strongly connected to w and w is strongly connected to
    x, then v is also strongly connected to x.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传递性*：如果 v 与 w 强连通，且 w 与 x 强连通，则 v 也与 x 强连通。'
- en: Strong connectivity partitions the vertices into equivalence classes, which
    we refer to as *strong components* for short. We seek to implement the following
    API:![API for strong components](../Images/c658cc75e0401ef4bef45afbdbb5a49c.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 强连通性将顶点划分为等价类，我们简称为*强连通分量*。我们试图实现以下API：![强连通分量的API](../Images/c658cc75e0401ef4bef45afbdbb5a49c.png)
- en: 'Remarkably, [KosarajuSharirSCC.java](KosarajuSharirSCC.java.html) implements
    the API with just a few lines of code added to [CC.java](../41graph/CC.java.html),
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，[KosarajuSharirSCC.java](KosarajuSharirSCC.java.html)仅通过在[CC.java](../41graph/CC.java.html)中添加几行代码就实现了该API，如下所示：
- en: Given a digraph G, use [DepthFirstOrder.java](DepthFirstOrder.java.html) to
    compute the reverse postorder of its reverse, G^R.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个有向图 G，使用[DepthFirstOrder.java](DepthFirstOrder.java.html)来计算其反向图 G^R 的逆后序。
- en: Run standard DFS on G, but consider the unmarked vertices in the order just
    computed instead of the standard numerical order.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在G上运行标准DFS，但考虑刚刚计算的顺序中的未标记顶点，而不是标准的数字顺序。
- en: All vertices reached on a call to the recursive `dfs()` from the constructor
    are in a strong component (!), so identify them as in CC.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从构造函数中对递归`dfs()`的调用到达的所有顶点都在一个强连通分量中（！），因此像在CC中一样识别它们。
- en: Proposition.
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题。
- en: The Kosaraju-Sharir algorithm uses preprocessing time and space proportional
    to V + E to support constant-time strong connectivity queries in a digraph.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kosaraju-Sharir算法使用预处理时间和空间与 V + E 成比例，以支持有向图中的常数时间强连通性查询。
- en: Transitive closure.
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递闭包。
- en: The *transitive closure* of a digraph G is another digraph with the same set
    of vertices, but with an edge from v to w if and only if w is reachable from v
    in G.![Transitive closure](../Images/858b43c0cccc85dca19ebced1460c5c8.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图 G 的*传递闭包*是另一个有向图，具有相同的顶点集，但如果且仅当在 G 中从 v 到 w 可达时，有一条从 v 到 w 的边。![传递闭包](../Images/858b43c0cccc85dca19ebced1460c5c8.png)
- en: '[TransitiveClosure.java](TransitiveClosure.java.html) computes the transitive
    closure of a digraph by running depth-first search from each vertex and storing
    the results. This solution is ideal for small or dense digraphs, but it is not
    a solution for the large digraphs we might encounter in practice because the constructor
    uses space proportional to V^2 and time proportional to V (V + E).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[TransitiveClosure.java](TransitiveClosure.java.html)通过从每个顶点运行深度优先搜索并存储结果来计算有向图的传递闭包。这种解决方案非常适合小型或密集的有向图，但不适用于我们在实践中可能遇到的大型有向图，因为构造函数使用的空间与
    V^2 成比例，时间与 V (V + E) 成比例。'
- en: Exercises
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Create a copy constructor for Digraph that takes as input a digraph G and creates
    and initializes a new copy of the digraph. Any changes a client makes to G should
    not affect the newly created digraph.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Digraph创建一个复制构造函数，该函数以有向图G作为输入，并创建和初始化有向图的新副本。客户端对G所做的任何更改都不应影响新创建的有向图。
- en: How many strong components are there in the digraph on p. 591?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有向图在第591页上有多少个强连通分量？
- en: '*Solution*: 10\. The input file is [mediumDG.txt](mediumDG.txt).'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 10\. 输入文件是[mediumDG.txt](mediumDG.txt)。'
- en: What are the strong components of a DAG?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有向无环图（DAG）的强连通分量是什么？
- en: '*Solution*: Each vertex is its own strong component.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 每个顶点都是自己的强连通分量。'
- en: 'True or false: The reverse postorder of a digraph''s reverse is the same as
    the postorder of the digraph.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：有向图的反向的逆后序与有向图的逆后序相同。
- en: '*Solution*: False.'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 假。'
- en: 'True or false: If we modify the Kosaraju-Sharir algorithm to run the first
    depth-first search in the digraph G (instead of the reverse digraph G^R) and the
    second depth-first search in G^R (instead of G), then it will still find the strong
    components.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：如果我们修改Kosaraju-Sharir算法，在有向图G中运行第一个深度优先搜索（而不是反向有向图G^R），并在G^R中运行第二个深度优先搜索（而不是G），那么它仍然会找到强连通分量。
- en: '*Solution.* True, the strong components of a digraph are the same as the strong
    components of its reverse.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案.* 是的，有向图的强连通分量与其反向的强连通分量相同。'
- en: 'True or false: If we modify the Kosaraju-Sharir algorithm to replace the second
    depth-first search with breadth-first search, then it will still find the strong
    components.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：如果我们修改Kosaraju-Sharir算法，用广度优先搜索替换第二次深度优先搜索，那么它仍然会找到强连通分量。
- en: '*Solution.* True.'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案.* 真。'
- en: Compute the memory usage of a `Digraph` with `V` vertices and `E` edges, under
    the memory cost model of Section 1.4.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算具有V个顶点和E条边的`Digraph`的内存使用情况，根据第1.4节的内存成本模型。
- en: '*Solution.* 56 + 40V + 64E. [MemoryOfDigraph.java](MemoryOfDigraph.java.html)
    computes it empirically assuming that no `Integer` values are cached—Java typically
    caches the integers -128 to 127\.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案.* 56 + 40V + 64E。[MemoryOfDigraph.java](MemoryOfDigraph.java.html)根据经验计算，假设没有缓存`Integer`值—Java通常会缓存-128到127之间的整数。'
- en: Creative Problems
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创造性问题
- en: '**Directed Eulerian cycle.** A directed Eulerian cycle is a directed cycle
    that contains each edge exactly once. Write a digraph client [DirectedEulerianCycle.java](DirectedEulerianCycle.java.html)
    that find a directed Eulerian cycle or reports that no such cycle exists.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向欧拉回路。** 有向欧拉回路是一个包含每条边恰好一次的有向循环。编写一个有向图客户端[DirectedEulerianCycle.java](DirectedEulerianCycle.java.html)来查找有向欧拉回路或报告不存在这样的回路。'
- en: '*Hint*: Prove that a digraph G has a directed Eulerian cycle if and only if
    vertex in G has its indegree equal to its outdegree and all vertices with nonzero
    degree belong to the same strong component.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*: 证明一个有向图G有一个有向欧拉回路当且仅当G中的每个顶点的入度等于出度，并且所有具有非零度的顶点属于同一个强连通分量。'
- en: '**Strong component.** Describe a linear-time algorithm for computing the strong
    component containing a given vertex v. On the basis of that algorithm, describe
    a simple quadratic-time algorithm for computing the strong components of a digraph.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**强连通分量。** 描述一个计算包含给定顶点v的强连通分量的线性时间算法。基于该算法，描述一个简单的二次时间算法来计算有向图的强连通分量。'
- en: '*Partial solution*: To compute the strong component containing s'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案*: 计算包含s的强连通分量'
- en: Find the set of vertices reachable from s
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到从s可达的顶点集
- en: Find the set of vertices that can reach s
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到可以到达s的顶点集
- en: Take the intersection of the two setsUsing this as a subroutine, you can find
    all strong components in time proportional to t (E + V), where t is the number
    of strong components.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取两个集合的交集，使用这个作为子程序，你可以在时间比例为t（E + V）的情况下找到所有强连通分量，其中t是强连通分量的数量。
- en: '**Hamiltonian path in DAGs.** Given a DAG, design a linear-time algorithm to
    determine whether there is a directed path that visits each vertex exactly once.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DAG中的哈密顿路径。** 给定一个DAG，设计一个线性时间算法来确定是否存在一个访问每个顶点恰好一次的有向路径。'
- en: '*Solution*: Compute a topological sort and check if there is an edge between
    each consecutive pair of vertices in the topological order.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 计算一个拓扑排序，并检查拓扑顺序中每对连续顶点之间是否有边。'
- en: '**Unique topological ordering.** Design an algorithm to determine whether a
    digraph has a unique topological ordering.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**唯一拓扑排序。** 设计一个算法来确定一个有向图是否有唯一的拓扑排序。'
- en: '*Hint*: a digraph has a unique topological ordering if and only if there is
    a directed edge between each pair of consecutive vertices in the topological order
    (i.e., the digraph has a Hamiltonian path). If the digraph has multiple topological
    orderings, then a second topological order can be obtained by swapping a pair
    of consecutive vertices.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*: 一个有向图有一个唯一的拓扑排序当且仅当拓扑排序中每对连续顶点之间存在一个有向边（即，有向图有一个哈密顿路径）。如果有向图有多个拓扑排序，那么可以通过交换一对连续顶点来获得第二个拓扑排序。'
- en: '**2-satisfiability.** Given a boolean formula in conjunctive normal form with
    M clauses and N literals such that each clause has exactly two literals, find
    a satisfying assignment (if one exists).'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2-可满足性。** 给定一个布尔公式，其合取范式中有M个子句和N个文字，每个子句恰好有两个文字，找到一个满足的赋值（如果存在）。'
- en: '*Solution sketch*: Form the *implication digraph* with 2N vertices (one per
    literal and its negation). For each clause x + y, include edges from y'' to x
    and from x'' to y. Claim: The formula is satisfiable if and only if no variable
    x is in the same strong component as its negation x''. Moreover, a topological
    sort of the kernel DAG (contract each strong component to a single vertex) yields
    a satisfying assignment.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案草图*: 用2N个顶点（每个文字及其否定一个）形成*蕴含有向图*。对于每个子句x + y，从y''到x和从x''到y包括边缘。声明：如果没有变量x与其否定x''在同一个强连通分量中，则公式是可满足的。此外，核心DAG的拓扑排序（将每个强连通分量缩减为单个顶点）产生一个满足的赋值。'
- en: '**Queue-based topological order algorithm.** Develop a nonrecursive topological
    sort implementation [TopologicalX.java](TopologicalX.java.html) that maintains
    a vertex-indexed array that keeps track of the indegree of each vertex. Initialize
    the array and a queue of sources in a single pass through all the edges, as in
    Exercise 4.2.7. Then, perform the following operations until the source queue
    is empty:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于队列的拓扑排序算法。** 开发一个非递归的拓扑排序实现[TopologicalX.java](TopologicalX.java.html)，该实现维护一个顶点索引数组，用于跟踪每个顶点的入度。在一次遍历中初始化数组和源队列，就像练习4.2.7中那样。然后，执行以下操作，直到源队列为空：'
- en: Remove a source from the queue and label it.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列中移除一个源并标记它。
- en: Decrement the entries in the indegree array corresponding to the destination
    vertex of each of the removed vertex's edges.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少入度数组中与已移除顶点的边的目标顶点对应的条目。
- en: If decrementing any entry causes it to become 0, insert the corresponding vertex
    onto the source queue.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果减少任何条目使其变为0��则将相应的顶点插入源队列。
- en: '**Shortest directed cycle.** Given a digraph, design an algorithm to find a
    directed cycle with the minimum number of edges (or report that the graph is acyclic).
    The running time of your algorithm should be proportional to *E V* in the worst
    case.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最短有向循环。** 给定一个有向图，设计一个算法来找到具有最少边数的有向循环（或报告图是无环的）。你的算法在最坏情况下的运行时间应该与*E V*成正比。'
- en: '*Application:* give a set of patients in need of kidney transplants, where
    each patient has a family member willing to donate a kidney, but of the wrong
    type. Willing to donate to another person provided their family member gets a
    kidney. Then hospital performs a "domino surgery" where all transplants are done
    simultaneously.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*应用：* 给出一组需要肾移植的患者，每个患者都有一个愿意捐赠肾脏但类型不匹配的家庭成员。愿意捐赠给另一个人，前提是他们的家庭成员得到肾脏。然后医院进行“多米诺手术”，所有移植同时进行。'
- en: '*Solution*: run BFS from each vertex s. The shortest cycle through s is an
    edge v->s, plus a shortest path from s to v. [ShortestDirectedCycle.java](ShortestDirectedCycle.java.html).'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* 从每个顶点s运行BFS。通过s的最短循环是一条边v->s，再加上从s到v的最短路径。[ShortestDirectedCycle.java](ShortestDirectedCycle.java.html)。'
- en: '**Odd-length directed cycle.** Design a linear-time algorithm to determine
    whether a digraph has an odd-length directed cycle.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**奇数长度的有向循环。** 设计一个线性时间算法，以确定一个有向图是否有一个奇数长度的有向循环。'
- en: '*Solution.* We claim that a digraph G has an odd-length directed cycle if and
    only if one (or more) of its strong components is nonbipartite (when treated as
    an undirected graph).'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 我们声称，如果一个有向图G有一个奇数长度的有向循环，那么它的一个（或多个）强连通分量作为无向图时是非二分的。'
- en: If the digraph G has an odd-length directed cycle, then this cycle will be entirely
    contained in one of the strong components. When the strong component is treated
    as an undirected graph, the odd-length directed cycle becomes an odd-length cycle.
    Recall that an undirected graph is bipartite if and only if it has no odd-length
    cycle.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有向图G有一个奇数长度的有向循环，则此循环将完全包含在一个强连通分量中。当强连通分量被视为无向图时，奇数长度的有向循环变为奇数长度的循环。回想一下，无向图是二分的当且仅当它没有奇数长度的循环。
- en: Suppose a strong component of G is nonbipartite (when treated as an undirected
    graph). This means that there is an odd-length cycle C in the strong component,
    ignoring direction. If C is a directed cycle, then we are done. Otherwise, if
    an edge v->w is pointing in the "wrong" direction, we can replace it with an odd-length
    path that is pointing in the opposite direction (which preserves the parity of
    the number of edges in the cycle). To see how, note that there exists a directed
    path P from w to v because v and w are in the same strong component. If P has
    odd length, then we replace edge v->w by P; if P has even length, then this path
    P combined with v->w is an odd-length cycle.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设G的一个强连通分量是非二分图（当作无向图处理时）。这意味着在强连通分量中存在一个奇数长度的循环C，忽略方向。如果C是一个有向循环，那么我们完成了。否则，如果边v->w指向“错误”的方向，我们可以用指向相反方向的奇数长度路径替换它（这保留了循环中边数的奇偶性）。要了解如何做到这一点，请注意存在一条从w到v的有向路径P，因为v和w在同一个强连通分量中。如果P的长度为奇数，则我们用P替换边v->w；如果P的长度为偶数，则这条路径P与v->w组合在一起就是一个奇数长度的循环。
- en: '**Reachable vertex in a DAG.** Design a linear-time algorithm to determine
    whether a DAG has a vertex that is reachable from every other vertex.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DAG中可达的顶点。** 设计一个线性时间算法，以确定一个DAG是否有一个顶点可以从每个其他顶点到达。'
- en: '*Solution.* Compute the outdegree of each vertex. If the DAG has exactly one
    vertex v with outdegree 0, then it is reachable from every other vertex.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 计算每个顶点的出度。如果DAG有一个出度为0的顶点v，那么它可以从每个其他顶点到达。'
- en: '**Reachable vertex in a digraph.** Design a linear-time algorithm to determine
    whether a digraph has a vertex that is reachable from every other vertex.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向图中可达的顶点。** 设计一个线性时间算法，以确定有向图是否有一个顶点可以从每个其他顶点到达。'
- en: '*Solution.* Compute the strong components and kernel DAG. Apply Exercise 4.2.37
    to the kernel DAG.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 计算强连通分量和核DAG。将练习4.2.37应用于核DAG。'
- en: '**Web crawler.** Write a program [WebCrawler.java](WebCrawler.java.html) that
    uses breadth-first search to crawl the web digraph, starting from a given web
    page. Do not explicitly build the web digraph.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络爬虫。** 编写一个程序[WebCrawler.java](WebCrawler.java.html)，使用广度优先搜索来爬取网络有向图，从给定的网页开始。不要显式构建网络有向图。'
- en: Web Exercises
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: '**Symbol digraph.** Modify [SymbolGraph.java](../41graph/SymbolGraph.java.html)
    to create a program [SymbolDigraph.java](SymbolDigraph.java.html) that implements
    a symbol digraph.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**符号有向图。** 修改[SymbolGraph.java](../41graph/SymbolGraph.java.html)以创建一个实现符号有向图的程序[SymbolDigraph.java](SymbolDigraph.java.html)。'
- en: '**Combinational circuits.** Determining the truth value of a combinational
    circuit given its inputs is a graph reachability problem (on a directed acyclic
    graph).'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组合电路。** 给定输入，确定组合电路的真值是一个图可达性问题（在有向无环图上）。'
- en: '**Privilege escalation.** Include an array from user class A to user class
    B if A can gain the privileges of B. Find all users that can obtain Administrator
    access in Windows.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**权限提升。** 如果A可以获得B的权限，则在用户类A到用户类B之间包含一个数组。找出所有可以在Windows中获得管理员访问权限的用户。'
- en: '**Unix program tsort.**'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Unix程序tsort。**'
- en: '**Checkers.** Extend the rules of checkers to an N-by-N checkerboard. Show
    how to determine whether a checker can become in king in the current move. (Use
    BFS or DFS.) Show how to determine whether black has a winning move. (Find a directed
    Eulerian path.)'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**跳棋。** 将跳棋规则扩展到一个N×N的跳棋棋盘。展示如何确定一个跳棋在当前移动中是否可以变成国王。（使用BFS或DFS。）展示如何确定黑方是否有获胜的着法。（找到一个有向欧拉路径。）'
- en: '**Preferential attachment model.** Web has a scale-free property and obeys
    a power law. New pages tend to *preferentially attach* to popular pages. Start
    with a single page that points to itself. At each step a new page appears with
    outdegree 1. With probability p the page points to a random page; with probability
    (1-p) the page points to an existing page with probability proportional to the
    indegree of the page.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优先附着模型。** 网络具有无标度特性，并遵循幂律。新页面倾向于*优先附着*到受欢迎的页面上。从指向自身的单个页面开始。每一步中，一个新页面出现，出度为1。以概率p，页面指向一个随机页面；以概率(1-p)，页面指向一个现有页面，概率与页面的入度成比例。'
- en: '**Subtype checking.** Given single inheritance relations (a tree), check if
    v is an ancestor of w. Hint: v is an ancestor of w if and only if pre[v] <= pre[w]
    and post[v] >= post[w].'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子类型检查。** 给定单继承关系（一棵树），检查v是否是w的祖先。提示：v是w的祖先当且仅当pre[v] <= pre[w]且post[v] >=
    post[w]。'
- en: '**Subtype checking.** Repeat previous question, but with a DAG instead of a
    tree.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子类型检查。** 重复上一个问题，但使用有向无环图而不是树。'
- en: '**LCA of a rooted tree.** Given a rooted tree and two vertices v and w, find
    the *lowest common ancestor* (lca) of v and w. The lca of v and w is the shared
    ancestor furthest from the root. Among most fundamental problem on rooted trees.
    Possible to solve in O(1) time per query with linear preprocessing time (Harel-Tarjan,
    [Bender-Coloton](http://www.ics.uci.edu/~eppstein/261/BenFar-LCA-00.pdf)).'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有根树的LCA。** 给定一个有根树和两个顶点v和w，找到顶点v和w的*最低共同祖先*（lca）。顶点v和w的lca是离根最远的共同祖先。根树上最基本的问题之一。可以在O(1)的查询时间内解决，预处理时间为线性时间（Harel-Tarjan，[Bender-Coloton](http://www.ics.uci.edu/~eppstein/261/BenFar-LCA-00.pdf)）。'
- en: Find a DAG where the shortest ancestral path goes to a common ancestor x that
    is not an LCA.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 找到一个有向无环图，其中最短的祖先路径通向一个不是LCA的共同祖先x。
- en: '**Nine-letter word.** Find a nine-letter English word such that remains an
    English word after successively removing each of its letters (in an appropriate
    order). Build a digraph with words and vertices and an edge from one word to another
    if it can be formed by adding one letter.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**九个字母的单词。** 找到一个九个字母的英文单词，使得在适当的顺序中依次删除每个字母后仍然是一个英文单词。使用单词和顶点构建一个有向图，如果一个单词可以通过添加一个字母形成另一个单词，则在两个单词之间添加一条边。'
- en: '*Answer*: one solution is startling -> starting -> staring -> string -> sting
    -> sing -> sin -> in -> i.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：一个解决方案是startling -> starting -> staring -> string -> sting -> sing ->
    sin -> in -> i。'
- en: '**Spreadsheet recalculate.** Hopefully no cyclic dependencies. Use topological
    sort of formula cell graph to determine in which order to update the cells.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电子表格重新计算。** 希望没有循环依赖。使用公式单元格图的拓扑排序来确定更新单元格的顺序。'
- en: '**Nesting boxes.** A d-dimensional box with dimensions (a1, a2, ..., ad) nests
    inside a box with dimensions (b1, b2, ..., bd) if the coordinates of the second
    box can be permuted so that a1 < b1, a2 < b2, ..., ad < bd.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**嵌套箱子。** 一个维度为d的箱子，其尺寸为(a1, a2, ..., ad)，如果第二个箱子的坐标可以重新排列，使得a1 < b1, a2 <
    b2, ..., ad < bd，则该箱子嵌套在第二个箱子内。'
- en: 'Give an efficient algorithm for determining where one d-dimensional box nests
    inside another. Hint: sort.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给出一个有效的算法，用于确定一个d维箱子嵌套在另一个箱子内的位置。提示：排序。
- en: 'Show that nesting is transitive: if box i nests inside box j and box j nests
    inside box k, then box i nests inside box k.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明嵌套是传递的：如果箱子i嵌套在箱子j内部，箱子j又嵌套在箱子k内部，那么箱子i也嵌套在箱子k内部。
- en: Given a set of n d-dimensional boxes, given an efficient algorithm to find the
    most boxes that can be simultaneously nested.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一组n个d维箱子，给出一个有效的算法，找到可以同时嵌套最多箱子的方法。
- en: '*Hint*: Create a digraph with an edge from box i to box j if box i nests inside
    box j. Then run topological sort.'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：创建一个有向图，如果箱子i嵌套在箱子j内部，则从箱子i到箱子j添加一条边。然后运行拓扑排序。'
- en: '**Warshall''s transitive closure algorithm.** [WarshallTC.java](WarshallTC.java.html)
    algorithm is ideal for dense graphs. Relies on [AdjMatrixDigraph.java](AdjMatrixDigraph.java.html).'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Warshall的传递闭包算法。** [WarshallTC.java](WarshallTC.java.html) 算法适用于稠密图。依赖于[AdjMatrixDigraph.java](AdjMatrixDigraph.java.html)。'
- en: '**Brute-force strong components algorithm.** [BruteSCC.java](BruteSCC.java.html)
    computes the strong components by first computing the transitive closure. It takes
    O(EV) time and O(V^2) space.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**暴力强连通分量算法。** [BruteSCC.java](BruteSCC.java.html) 通过首先计算传递闭包来计算强连通分量。时间复杂度为O(EV)，空间复杂度为O(V^2)。'
- en: '**Tarjan''s strong components algorithm.** [TarjanSCC.java](TarjanSCC.java.html)
    implements Tarjan''s algorithm for computing strong components.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Tarjan的强连通分量算法。** [TarjanSCC.java](TarjanSCC.java.html) 实现了Tarjan算法来计算强连通分量。'
- en: '**Gabow''s strong components algorithm.** [GabowSCC.java](GabowSCC.java.html)
    implements Gabow''s algorithm for computing strong components.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Gabow的强连通分量算法。** [GabowSCC.java](GabowSCC.java.html) 实现了Gabow算法来计算强连通分量。'
- en: '**Digraph generator.** [DigraphGenerator.java](DigraphGenerator.java.html)
    generated various digraphs.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向图生成器。** [DigraphGenerator.java](DigraphGenerator.java.html) 生成各种有向图。'
- en: '**Finite Markov chains.** Recurrent state: once started in state, Markov chain
    will return with probability 1. Transient state: some probability that it will
    never return (some node j for which i can reach j, but j can''t reach i). Irreducible
    Markov chain = all states recurrent. A Markov chain is irreducible if and only
    if it is strongly connected. The recurrent components are those with no leave
    edges in the kernel DAG. Communicating classes in Markov chain are the strong
    components.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有限马尔可夫链.** 回归状态：一旦在状态开始，马尔可夫链将以概率1返回。瞬时状态：有些概率它永远不会返回（某个节点j，i可以到达j，但j无法到达i）。不可约马尔可夫链=所有状态都是回归的。马尔可夫链是不可约的当且仅当它是强连通的。回归组件是核DAG中没有离开边的组件。马尔可夫链中的通信类是强连通分量。'
- en: Theorem. If G is strongly connected, then there is a unique stationary distribution
    pi. Moreover pi(v) > 0 for all v.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理. 如果G是强连通的，则存在唯一的稳态分布pi。此外，对于所有v，pi(v) > 0。
- en: Theorem. If the kernel DAG of G has a single supernode with no leaving edges,
    then there is a unique stationary distribution pi. Moreover pi(v) > 0 for all
    v recurrent and pi(v) = 0 for all v transient.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理. 如果G的核DAG具有单个没有离开边的超节点，则存在唯一的稳态分布pi。此外，对于所有回归的v，pi(v) > 0且对于所有瞬时的v，pi(v)
    = 0。
- en: '**Descendants lemma.** [R. E. Tarjan] Denote by pre[v] and post[v] as the preorder
    and postorder number of v, respectively, and by nd[v] the number of descendants
    of v (including v). Prove that the following four conditions are equivalent.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**后代引理.** [R. E. Tarjan] 将pre[v]和post[v]分别表示为v的前序和后序编号，nd[v]表示v的后代数（包括v）。证明以下四个条件是等价的。'
- en: Vertex v is an ancestor of vertex w.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点v是顶点w的祖先。
- en: pre[v] <= pre[w] < pre[v] + nd(v).
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pre[v] <= pre[w] < pre[v] + nd(v).
- en: post[v] - nd [v] < post[w] <= post[v]
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: post[v] - nd [v] < post[w] <= post[v]
- en: pre[v] <= pre[w] and post[v] >= post[w] (nesting lemma)
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pre[v] <= pre[w]且post[v] >= post[w]（嵌套引理）
- en: '**Edge lemma.** [R. E. Tarjan] Prove that an edge (v, w) is one of the following
    four kinds:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边引理.** [R. E. Tarjan] 证明边(v, w)是以下四种之一：'
- en: 'w is a child of v: (v, w) is a *tree edge*.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: w是v的子节点：(v, w)是一条*树边*。
- en: 'w is a descendant but not a child of v: (v, w) is a *forward edge*.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: w是v的后代但不是子节点：(v, w)是一条*前向边*。
- en: 'w is an ancestor of v: (v, w) is a *back edge*'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: w是v的祖先：(v, w)是一条*后向边*
- en: 'w and v are unrelated and pre[v] > pre[w]: (v, w) is a *cross edge*.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: w和v无关且pre[v] > pre[w]：(v, w)是一条*交叉边*。
- en: '**Path lemma.** [R. E. Tarjan] Prove that any path from v to w with pre[v]
    < pre[w] contains a common ancestor of v and w.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路径引理.** [R. E. Tarjan] 证明从v到w的任何路径，其中pre[v] < pre[w]，都包含v和w的共同祖先。'
- en: Prove that if (v, w) is an edge and pre[v] < pre[w], then v is an ancestor of
    w in the DFS tree.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明如果(v, w)是一条边且pre[v] < pre[w]，则v是DFS树中w的祖先。
- en: '**Postorder lemma.** [R. E. Tarjan] Prove that if P is a path such that the
    last vertex x is highest in postorder, then every vertex on the path is a descendant
    of x (and hence has a path from x).'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**后序引理.** [R. E. Tarjan] 证明如果P是一条路径，最后一个顶点x在后序中最高，则路径上的每个顶点都是x的后代（因此与x有一条路径）。'
- en: '*Solution.* The proof is by induction on the length of P (or by contradiction).
    Let (v, w) be an edge such that w is a descendant of x and post[v] < post[x].
    Since w is a descendant of x, we have pre[w] >= pre[x].'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解.* 证明通过对P的长度进行归纳（或通过反证法）。设(v, w)是一条边，其中w是x的后代且post[v] < post[x]。由于w是x的后代，我们有pre[w]
    >= pre[x]。'
- en: If pre[v] >= pre[x], then v is a descendant of x (by the nesting lemma).
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果pre[v] >= pre[x]，那么v是x的后代（通过嵌套引理）。
- en: If pre[v] < pre[x], then pre[v] < pre[w], which implies (by the previous exercise)
    that v is an ancestor of w and hence related to x. But post[v] < post[x] implies
    v is a descendant of x.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果pre[v] < pre[x]，那么pre[v] < pre[w]，这意味着（通过前一个练习）v是w的祖先，因此与x有关。但是post[v] < post[x]意味着v是x的后代。
- en: '**Pre-topological order.** Design a linear-time algorithm to find a *pre-topological
    order*: and ordering of the vertices such that if there is a path from v to w
    and w appears before v in the ordering, then there must also be a path from w
    to v.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前拓扑排序.** 设计一个线性时间算法来找到一个*前拓扑排序*：一种顶点的排序，使得如果从v到w有一条路径且w在排序中出现在v之前，则从w到v也必须有一条路径。'
- en: '*Hint*: reverse postorder is a pre-topological order. This is the crux of the
    proof of correctness of the Kosaraju-Sharir algorithm.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：反向后序是一种前拓扑排序。这是Kosaraju-Sharir算法正确性证明的关键。'
- en: '**Wordnet.** [Using WordNet to Measure Semantic Orientations of Adjectives](http://staff.science.uva.nl/~kamps/publications/2004/kamp:usin04.pdf).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Wordnet.** [使用WordNet测量形容词的语义取向](http://staff.science.uva.nl/~kamps/publications/2004/kamp:usin04.pdf).'
- en: '**Garbage collection.** Automatic memory management in languages like Java
    is a challenging problem. Allocating memory is easy, but discovering when a program
    is finished with memory (and reclaiming it) is more difficult. Reference counting:
    doesn''t work with circular linked structure. Mark-and-sweep algorithm. Root =
    local variables and static variables. Run DFS from roots, marking all variables
    references from roots, and so on. Then, make second pass: free all unmarked objects
    and unmark all marked objects. Or a copying garbage collector would then move
    all of the marked objects to a single memory area. Uses one extra bit per object.
    JVM must pause while garbage collection occurs. Fragments memory.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垃圾收集.** 在像Java这样的语言中进行自动内存管理是一个具有挑战性的问题。分配内存很容易，但发现程序何时完成对内存的使用（并回收它）更加困难。引用计数：不适用于循环链接结构。标记-清除算法。根=局部变量和静态变量。从根运行DFS，标记所有从根引用的变量，依此类推。然后，进行第二遍：释放所有未标记的对象并取消标记所有标记的对象。或者复制垃圾收集器将所有标记的对象移动到单个内存区域。每个对象使用一个额外的位。JVM在进行垃圾收集时必须暂停。碎片化内存。'
- en: 'Applications: C leak detector (leak = unreachable, unfreed memory).'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用：C泄漏检测器（泄漏=不可达的，未释放的内存）。
- en: '**Directed cycle detection applications.** Application: check for illegal inheritance
    loop, check for deadlocking. A directory is a list of files and other directories.
    A symbolic link is a reference to another directory. When listing all files in
    a directory, need to be careful to avoid following a cycle of symbolic links!'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向循环检测应用。** 应用：检查非法继承循环，检查死锁。目录是文件和其他目录的列表。符号链接是对另一个目录的引用。在列出目录中的所有文件时，需要小心避免跟随符号链接的循环！'
- en: '**Topological sort applications.** Application: course prerequisites, order
    in which to compile components of a large computer program, causalities, class
    inheritance, deadlocking detection, temporal dependencies, pipeline of computing
    jobs, check for symbol link loop, evaluate formula in spreadsheet.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拓扑排序应用。** 应用：课程先修条件、大型计算机程序组件的编译顺序、因果关系、类继承、死锁检测、时间依赖性、计算作业的管道、检查符号链接循环、电子表格中的公式求值。'
- en: '**Strong component applications.** Applications to CAD, Markov chains (irreducible),
    spider traps and web search, pointer analysis, garbage collection.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**强连通分量应用。** 应用于 CAD、马尔可夫链（不可约）、蜘蛛陷阱和网络搜索、指针分析、垃圾回收。'
- en: '**One-way street theorem.** Implement an algorithm to orient the edges in an
    undirected graph so that it is strongly connected. [Robbins theorem](http://en.wikipedia.org/wiki/Robbins_theorem)
    asserts that this is possible if and only if the undirected graph is two-edge
    connected (no bridges). In this case, a solution is to run DFS and oriented all
    edges in the DFS tree away from the root and all of the remaining edges toward
    the root.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单向街定理。** 实现一个算法来定向无向图中的边，使其成为强连通图。[罗宾斯定理](http://en.wikipedia.org/wiki/Robbins_theorem)断言，当且仅当无向图是双边连通的（没有桥）时，这是可能的。在这种情况下，一种解决方案是运行深度优先搜索（DFS），并将
    DFS 树中的所有边定向远离根节点，将所有剩余的边定向朝向根节点。'
- en: '**Orient edges in mixed graph to make acyclic.** A mixed graph is a graph with
    some edges that are directed and others that are undirected. Design a linear-time
    algorithm to determine whether it is possible to orient the undirected edges so
    that the resulting digraph is acyclic.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定向混合图中的边以使其无环。** 混合图是具有一些有向边和一些无向边的图。设计一个线性时间算法来确定是否可以定向无向边，使得结果有向图是无环的。'
- en: 'Application: old city with narrow roads wants to make every road one way but
    still allow every intersection in the city to be reachable from every other city.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用：老城区的狭窄道路希望使每条道路单向通行，但仍允许城市中的每个交叉口可从其他城市到达。
- en: '**Orient edges in mixed graph to make a directed cycle.** A mixed graph is
    a graph with some edges that are directed and others that are undirected. Design
    a linear-time algorithm to determine whether it is possible to orient the undirected
    edges so that the resulting digraph has a directed cycle.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定向混合图中的边以形成有向循环。** 混合图是具有一些有向边和一些无向边的图。设计一个线性时间算法来确定是否可以定向无向边，使得结果有向图具有有向循环。'
- en: 'Application: determining whether a maximum flow is unique.'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用：确定最大流是否唯一。
- en: '*Solution*: [one algorithm](https://cstheory.stackexchange.com/questions/32332/reference-for-mixed-graph-acyclicity-testing-algorithm).'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[一个算法](https://cstheory.stackexchange.com/questions/32332/reference-for-mixed-graph-acyclicity-testing-algorithm)。'
- en: '**Postorder lemma variant.** Let S and T be two strong components in a digraph
    G. Prove that if there is an edge e from a vertex in S to a vertex in T, then
    the highest postorder number of a vertex in S is higher than the higher postorder
    number of a vertex in T.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**后序引理变种。** 设 S 和 T 是有向图 G 中的两个强连通分量。证明如果存在一条从 S 中的一个顶点到 T 中的一个顶点的边 e，则 S 中顶点的最高后序编号高于
    T 中顶点的最高后序编号。'
- en: '**Number of paths in a DAG.** Given a DAG and two distinguished vertices s
    and t, design a linear-time algorithm to compute the number of directed paths
    from s to t.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DAG 中路径的数量。** 给定一个有向无环图（DAG）和两个特定顶点 s 和 t，设计一个线性时间算法来计算从 s 到 t 的有向路径数量。'
- en: '*Hint:* topological sort.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：拓扑排序。'
- en: '**Path of length L in a DAG.** Given a DAG and two distinguished vertices s
    and t, design an algorithm to determine if there exists a path from s to t containing
    exactly L edges.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DAG 中长度为 L 的路径。** 给定一个有向无环图（DAG）和两个特定顶点 s 和 t，设计一个算法来确定是否存在一条从 s 到 t 的路径，其中恰好包含
    L 条边。'
- en: '**Core vertices.** Given a digraph G, a vertex v is a *core* vertex if every
    vertex in G is reachable from v. Design a linear-time algorithm that finds all
    core vertices.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**核心顶点。** 给定一个有向图 G，如果从顶点 v 可以到达 G 中的每个顶点，则顶点 v 是一个*核心*顶点。设计一个线性时间算法来找到所有核心顶点。'
- en: '*Hint*: create the strong components of G and look at the kernel DAG.'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：创建 G 的强连通分量并查看核心 DAG。'
- en: '**Strong components and bipartite matching.** Given a bipartite graph G, an
    [unmatched edge](http://trueshelf.com/exercise/136/unmatchable-edges-of-bipartite-graphs)
    is one that does not appear in any perfect matching. Design an algorithm to find
    all unmatched edges.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**强连通分量和二分图匹配。** 给定一个二分图 G，一个[未匹配边](http://trueshelf.com/exercise/136/unmatchable-edges-of-bipartite-graphs)是指不出现在任何完美匹配中的边。设计一个算法来找到所有未匹配边。'
- en: '*Hint*: prove that the following algorithm does the job. Find a perfect matching
    in G; orient the edges in the matching from one side of the bipartition to the
    other side; orient the remaining edges in the opposite direction; among the edges
    not in the perfect matching, return those that have endpoints in different strongly
    connected components.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：证明以下算法可以胜任。在 G 中找到一个完美匹配；将匹配中的边从双分区的一侧定向到另一侧；将剩余的边定向到相反方向；在不在完美匹配中的边中，返回那些端点在不同强连通分量中的边。'
- en: '**Transitive reduction of a digraph.** The [transitive reduction](http://en.wikipedia.org/wiki/Transitive_reduction)
    of a digraph is a digraph with the fewest number of edges that has the same transitive
    closure as the original digraph. Design an V (E + V) algorithm to compute the
    transitive reduction of a digraph. Note that the transitive reduction in a digraph
    is not necessarily unique and may not be a subgraph of the original digraph. (The
    transitive reduction in a DAG is unique and is a subgraph of the original digraph.)'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向图的传递闭包。** 有向图的[传递闭包](http://en.wikipedia.org/wiki/Transitive_reduction)是具有与原始有向图相同传递闭包的边数最少的有向图。设计一个V（E
    + V）算法来计算有向图的传递闭包。请注意，有向图中的传递闭包不一定是唯一的，也不一定是原始有向图的子图。（有向无环图中的传递闭包是唯一的且是原始有向图的子图。）'
- en: '**Odd-length path.** Given a digraph G and a source vertex s, design a linear-time
    algorithm to determine all vertices that are reachable from s via a path (not
    necessarily simple) with an *odd* number of edges.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**奇长度路径。** 给定一个有向图G和一个源顶点s，设计一个线性时间算法，确定通过具有*奇数*边数的路径（不一定简单）从s可达的所有顶点。'
- en: '*Solution.* Create a new digraph G'' with two vertices v and v'' for each vertex
    v in G. For each edge v->w in G, include two edges: v->w'' and w->v''. Now, any
    path from s to v'' in G'' corresponds to an odd-length path from s to v in G.
    Run either BFS or DFS to determine the vertices reachable from s.'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：为G中的每个顶点v创建一个新的有向图G''，其中包含两个顶点v和v''。对于G中的每条边v->w，包括两条边：v->w''和w->v''。现在，在G''中从s到v''的任何路径对应于G中从s到v的奇长度路径。运行BFS或DFS以确定从s可达的顶点。'
- en: Find a topological order of a DAG that cannot be computed as the reverse postorder
    of a DFS, no matter in which order the DFS chooses starting vertices in the constructor.
    Show that every topological order of a DAG can be computed as the reverse postorder
    of a DFS, provided that the DFS can choose the order of the starting vertices
    in the constructor arbitrarily.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个有向无环图（DAG）的拓扑排序，无论深度优先搜索（DFS）以何种顺序选择起始顶点，都无法计算为DFS的逆后序。展示出DAG的每一个拓扑排序都可以被计算为DFS的逆后序，只要DFS可以任意选择构造函数中起始顶点的顺序。
- en: '**Nonrecursive DFS.** Write a program [NonrecursiveDirectedDFS.java](NonrecursiveDirectedDFS.java.html)
    that implements depth-first search using an explicit stack instead of recursion.
    Write a program [NonrecursiveDirectedCycle.java](NonrecursiveDirectedCycle.java.html)
    that find a directed cycle without using recursion.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非递归DFS。** 编写一个��序[NonrecursiveDirectedDFS.java](NonrecursiveDirectedDFS.java.html)，使用显式栈而不是递归来实现深度优先搜索。编写一个程序[NonrecursiveDirectedCycle.java](NonrecursiveDirectedCycle.java.html)，在不使用递归的情况下找到一个有向环。'
- en: '**Nonrecursive topological sort.** Extend the queue-based topological sort
    algorithm [TopologicalX.java](TopologicalX.java.html) from Exercise 4.2.39 to
    find a directed cycle if the digraph has a directed cycle. Name your program [DirectedCycle.java](DirectedCycleX.java.html).'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非递归拓扑排序。** 将基于队列的拓扑排序算法[TopologicalX.java](TopologicalX.java.html)从练习4.2.39扩展到在有向图存在有向环时找到该有向环。将程序命名为[DirectedCycle.java](DirectedCycleX.java.html)。'
- en: '**Cartalk puzzle.** Find the longest word in a dictionary that has the property
    that you can remove one letter at a time (from either end or the middle) and the
    resulting string is also a word in the dictionary. For example, STRING is a 6-letter
    word with this property (STRING -> STING -> SING -> SIN -> IN -> I).'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Cartalk难题。** 在字典中找到一个具有以下特性的最长单词：您可以一次删除一个字母（从任一端或中间），结果字符串也是字典中的单词。例如，STRING是一个具有此特性的6字母单词（STRING
    -> STING -> SING -> SIN -> IN -> I）。'
- en: '**Reverse postorder vs. preorder.** True or false: The reverse postorder of
    a digraph is the same as the preorder of the digraph.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆后序与前序。** 真或假：有向图的逆后序与有向图的前序相同。'
- en: '**Reverse postorder vs. preorder in Kosaraju–Sharir.** Suppose that you use
    the preorder of the digraph instead of the reverse postorder in the Kosaraju–Sharir
    algorithm. Will it still produce the strong components?'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kosaraju–Sharir算法中的逆后序与前序。** 假设您在Kosaraju–Sharir算法中使用有向图的前序而不是逆后序。它是否仍会产生强连通分量？'
- en: '*Answer*: No, run [KosarajuSharirPreorderSCC.java](KosarajuSharirPreorderSCC.java.html)
    on `tinyDG.txt`.'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：不会，运行[KosarajuSharirPreorderSCC.java](KosarajuSharirPreorderSCC.java.html)在`tinyDG.txt`上。'
