- en: '1.5   Case Study: Union-Find'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/15uf](https://algs4.cs.princeton.edu/15uf)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Dynamic connectivity example](../Images/9d0f8a98d7c01cbf4802921df320f413.png)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic connectivity.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The input is a sequence of pairs of integers, where each integer represents
    an object of some type and we are to interpret the pair `p q` as meaning `p` is
    connected to `q`. We assume that "is connected to" is an *equivalence relation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symmetric*: If `p` is connected to `q`, then `q` is connected to `p`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*transitive*: If `p` is connected to `q` and `q` is connected to `r`, then
    `p` is connected to `r`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*reflexive*: `p` is connected to `p`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An equivalence relation partitions the objects into *equivalence classes* or
    *connected components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to write a program to filter out extraneous pairs from the sequence:
    When the program reads a pair `p q` from the input, it should write the pair to
    the output only if the pairs it has seen to that point do not imply that `p` is
    connected to `q`. If the previous pairs do imply that `p` is connected to `q`,
    then the program should ignore the pair `p q` and proceed to read in the next
    pair.'
  prefs: []
  type: TYPE_NORMAL
- en: Union-Find API.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following API encapsulates the basic operations that we need.![Union-find
    API](../Images/9d4ccf644520f57e2530ed69d1507b76.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the utility of the API, the `main()` in [UF.java](UF.java.html) solves
    the dynamic connectivity problem. We also prepare test data: the file [tinyUF.txt](tinyUF.txt)
    contains the 11 connections used in our small example, the file [mediumUF.txt](mediumUF.txt)
    contains 900 connections, and the file [largeUF.txt](largeUF.txt) is an example
    with millions of connections.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now consider several different implementations, all based on using a site-indexed
    array `id[]` to determine whether two sites are in the same component.
  prefs: []
  type: TYPE_NORMAL
- en: '*Quick-find.* [QuickFindUF.java](QuickFindUF.java.html) maintains the invariant
    that `p` and `q` are connected if and only if `id[p]` is equal to `id[q]`. In
    other words, all sites in a component must have the same value in `id[]`.![Quick
    find overview](../Images/13d51dde02277e9978185d3bd6033064.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quick-union.* [QuickUnionUF.java](QuickUnionUF.java.html) is based on the
    same data structure—the site-indexed `id[]` array—but it uses a different interpretation
    of the values that leads to more complicated structures. Specifically, the `id[]`
    entry for each site will be the name of another site in the same component (possibly
    itself). To implement `find()` we start at the given site, follow its link to
    another site, follow that sites link to yet another site, and so forth, following
    links until reaching a root, a site that has a link to itself. Two sites are in
    the same component if and only if this process leads them to the same root. To
    validate this process, we need `union()` to maintain this invariant, which is
    easily arranged: we follow links to find the roots associated with each of the
    given sites, then rename one of the components by linking one of these roots to
    the other.![Quick union overview](../Images/cec0967b1fbb85882e408060ae060f34.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Weighted quick-union.* Rather than arbitrarily connecting the second tree
    to the first for `union()` in the quick-union algorithm, we keep track of the
    size of each tree and always connect the smaller tree to the larger. Program [WeightedQuickUnionUF.java](WeightedQuickUnionUF.java.html)
    implements this approach.![Weighted quick union overview](../Images/bf7bb30e3008f9ca9cc7051bbfe2ad56.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Weighted quick-union with path compression.* There are a number of easy ways
    to improve the weighted quick-union algorithm further. Ideally, we would like
    every node to link directly to the root of its tree, but we do not want to pay
    the price of changing a large number of links. We can approach the ideal simply
    by making all the nodes that we do examine directly link to the root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union-find cost model.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When studying algorithms for union-find, we count the number of *array accesses*
    (number of times an array entry is accessed, for read or write).
  prefs: []
  type: TYPE_NORMAL
- en: Definitions.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *size* of a tree is its number of nodes. The *depth* of a node in a tree
    is the number of links on the path from it to the root. The *height* of a tree
    is the maximum depth among its nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The quick-find algorithm uses one array access for each call to `find()` and
    between *n* + 3 and 2*n* + 1 array accesses for each call to `union()` that combines
    two components.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of array accesses used by `find()` in quick-union is 1 plus twice
    the depth of the node corresponding to the given site. The number of array accesses
    used by `union()` and `connected()` is the cost of the two `find()` operations
    (plus 1 for `union()` if the given sites are in different trees).
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The depth of any node in a forest built by weighted quick-union for *n* sites
    is at most lg *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Corollary.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For weighted quick-union with *n* sites, the worst-case order of growth of the
    cost of `find()`, `connected()`, and `union()` is log *n*.![performance of union-find
    algorithms](../Images/75d0aa40de96d8e5e5fb942ea899aa99.png)
  prefs: []
  type: TYPE_NORMAL
- en: Q + A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Is there an efficient data structure that supports both insertion and
    deletion of edges?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes. However, the best-known *fully dynamic* data structure for graph
    connectivity is substantially more complicated than the *incremental* version
    we consider. Moreover, it''s not as efficient. See [Near-optimal fully-dynamic
    graph connectivity](http://www.cs.princeton.edu/courses/archive/spr10/cos423/handouts/NearOpt.pdf)
    by Mikkel Thorup.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Develop classes [QuickUnionUF.java](QuickUnionUF.java.html) and [QuickFindUF.java](QuickFindUF.java.html)
    that implement quick-union and quick-find, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give a counterexample that shows why this intuitive implementation of `union()`
    for quick-find is not correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer.* The value of `id[p]` changes to `id[q]` in the for loop. Thus, any
    object `r` > `p` with `id[r]` equal to `id[p]` will not be updated to equal `id[q]`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the weighted quick-union implementation, suppose we set `id[root(p)]` to
    `q` instead of `id[root(q)]`. Would the resulting algorithm be correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer.* Yes. However, it would be increase the tree height, so the performance
    guarantee would be invalid.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creative Problems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Quick-union with path compression.** Modify [QuickUnionUF.java](QuickUnionUF.java.html)
    to include *path compression*, by adding a loop to `find()` that links every sie
    on the path from p to the root. Give a sequence of input pairs that causes this
    method to produce a path of length 4\. *Note*: the amortized cost per operation
    for this algorithm is known to be logarithmic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* [QuickUnionPathCompressionUF.java](QuickUnionPathCompressionUF.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Weighted quick-union with path compression.** Modify [WeightedQuickUnionUF.java](WeightedQuickUnionUF.java.html)
    to implement path compression, as described in Exercise 1.5.12. Give a sequence
    of input pairs that causes this method to produce a tree of height 4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Note*: The amortized cost per operation for this algorithm is known to be
    bounded by a function known as the *inverse Ackermann function* and is less than
    5 for any conceivable value of *n* that arises in practice.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution.* [WeightedQuickUnionPathCompressionUF.java](WeightedQuickUnionPathCompressionUF.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Weighted quick-union by height.** Develop a implementation [WeightedQuickUnionByHeightUF.java](WeightedQuickUnionByHeightUF.java.html)
    that uses the same basic strategy as weighted quick-union but keeps track of tree
    height and always links the shorter tree to the taller one. Prove a logarithmic
    upper bound on the height of the trees for *n* sites with your algorithm.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* A union operation between elements in different trees either leaves
    the height unchanged (if the two tree have different heights) or increase the
    height by one (if the two tree are the same height). You can prove by induction
    that that the size of the tree is at least 2^height. Therefore, the height can
    increase at most lg *n* times.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Random connections.** Develop a `UF` client [ErdosRenyi.java](ErdosRenyi.java.html)
    that takes an integer command-line argument *n*, generates random pairs of integers
    between 0 and *n*, calling `connected()` to determine if they are connected and
    then `union()` if not (as in our development client), looping until all sites
    are connected, and printing the number of connections generated. Package your
    program as a static method `count()` that takes *n* as argument and returns the
    number of connections and a `main()` that takes *n* from the command line, calls
    `count()`, and prints the returned value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: True or false. In the quick union implementation, suppose we set `parent[p]`
    to `parent[root(q)]` instead of setting `parent[root(p)]` to `parent[root(q)]`.
    Would the resulting algorithm be correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer.* No.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Which of the following arrays could not possibly occur during the execution
    of weighted quick union with path compression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 1 2 3 4 5 6 7 8 9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 7 3 8 3 4 5 6 8 8 1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 3 8 0 4 5 6 9 8 1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 0 0 0 0 0 0 0 0 0
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 9 6 2 6 1 4 5 8 8 9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 9 8 7 6 5 4 3 2 1 0
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* B, C, E, and F.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Recursive path compression.** Implement path compression using recursion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Path halving.** Write a data type [QuickUnionPathHalvingUF.java](QuickUnionPathHalvingUF.java.html)
    that implements a simpler strategy known as *path halving*, which makes every
    other node on the find path link to its grandparent. *Remark*: the amortized cost
    per operation for this algorithm is known to be bounded by a function known as
    the *inverse Ackermann function*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Path splitting.** Write a data type [WeightedQuickUnionPathSplittingUF.java](QuickUnionPathSplittingUF.java.html)
    that implement an alternative strategy known as *path splitting*, which makes
    every node on the find path link to its grandparent. *Remark*: the amortized cost
    per operation for this algorithm is known to be bounded by a function known as
    the *inverse Ackermann function*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random quick union.** Implement the following version of quick union: Assign
    the integers 0 through n-1 uniformly at random to the n elements. When linking
    two roots, always link the root with the smaller label into the root with the
    larger label. Add in path compression. *Remark*: the expected cost per operation
    for the version without path compression is logarithmic; the expected amortized
    cost per operation for the version with path compression is bounded by a function
    known as the *inverse Ackermann function*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3D site percolation.** Repeat for 3D lattice. Threshold around 0.3117.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bond percolation.** Same as site percolation, but choose edges at random
    instead of sites. True threshold is exactly 0.5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a set of N elements, create a sequence of N union operations so that weighted
    quick union has height Theta(log N). Repeat for weighted quick union with path
    compression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hex.** The game of Hex is played on a trapezoidal grid of hexagons.... Describe
    how to detect when white or black has won the game. Use the union-find data structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hex.** Prove that the game cannot end in a tie. *Hint*: consider the set
    of cells reachable from the left side of the board.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hex.** Prove that the first player can guarantee a win with perfect play.
    *Hint*: if the second player had a winning strategy, you could choose a random
    cell initially, and then just copy the second player''s winning strategy. This
    is called *strategy stealing*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Labeling clusters on a grid.** Physicists refer to it as the [Hoshen–Kopelman
    algorithm](https://en.wikipedia.org/wiki/Hoshen–Kopelman_algorithm) although it
    is simply union–find on a grid graph with raster-scan order. Applications include
    modeling percolation and electrical conductance. Plot site occupancy probability
    vs. number of clusters (say 100-by-100, with p between 0 and 1, number of clusters
    between 0 and 1500) or distribution of clusters. (seems like DFS would suffice
    here) Matlab has a function `bwlabel` in the image processing toolbox that performs
    cluster labeling.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
