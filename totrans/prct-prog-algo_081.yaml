- en: '4.5 A Case Study: Small World Phenomenon'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 一个案例研究：小世界现象
- en: 原文：[https://introcs.cs.princeton.edu/python/45graph](https://introcs.cs.princeton.edu/python/45graph)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/45graph](https://introcs.cs.princeton.edu/python/45graph)
- en: '<title>A Case Study: Small World Phenomenon</title>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <title>一个案例研究：小世界现象</title>
- en: The mathematical model that we use for studying the nature of pairwise connections
    among entities is known as the *graph*. Graphs are important for studying the
    natural world and for helping us to better understand and refine the networks
    that we create.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于研究实体之间成对连接性质的数学模型称为*图*。图对于研究自然界很重要，也有助于我们更好地理解和完善我们创建的网络。
- en: Some graphs exhibit a specific property known as the *small-world phenomenon*.
    You may be familiar with this property, which is sometimes known as *six degrees
    of separation*. It is the basic idea that, even though each of us has relatively
    few acquaintances, there is a relatively short chain of acquaintances (the six
    degrees of separation) separating us from one another. Scientists are interested
    in small-world graphs because they model natural phenomena, and engineers are
    interested in building networks that take advantage of the natural properties
    of small-world graphs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图表展示了一种特定属性，被称为*小世界现象*。你可能熟悉这个属性，有时也被称为*六度分隔*。这基本上是一个想法，即尽管我们每个人的熟人相对较少，但我们之间存在着一个相对较短的熟人链（六度分隔）将我们彼此分开。科学家对小世界图表感兴趣，因为它们模拟了自然现象，工程师对构建利用小世界图表的自然属性的网络感兴趣。
- en: In this section, we address basic computational questions surrounding the study
    of small-world graphs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了围绕研究小世界图表的基本计算问题。
- en: '* * *'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Graph Data Type
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图数据类型
- en: '![Graph terminology](../Images/6fb5e190fc337940e45482b2c526557b.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图表术语](../Images/6fb5e190fc337940e45482b2c526557b.png)'
- en: We begin with some basic definitions. A *graph* is composed of a set of *vertices*
    and a set of *edges*. Each edge represents a connection between two vertices.
    Two vertices are *neighbors* if they are connected by an edge, and the *degree*
    of a vertex is its number of neighbors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些基本定义开始。*图*由一组*顶点*和一组*边*组成。每条边表示��个顶点之间的连接。如果两个顶点通过一条边连接，则它们是*邻居*，顶点的*度*是其邻居的数量。
- en: Graph-processing algorithms generally first build an internal representation
    of a graph by adding edges, then process it by iterating through the vertices
    and through the edges that are adjacent to a vertex. This API supports such processing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图处理算法通常首先通过添加边来构建图的内部表示，然后通过遍历顶点和与顶点相邻的边来处理它。这个API支持这样的处理。
- en: '![Graph API](../Images/ab07e66652d7a83b14189ec5e51c56b1.png)'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图表API](../Images/ab07e66652d7a83b14189ec5e51c56b1.png)'
- en: 'The program [graph.py](graph.py.html) implements this API. Its internal representation
    is a symbol table of sets: the keys are vertices and the values are the sets of
    neighbors — the vertices adjacent to the key. A small example is illustrated at
    right. To implement this representation, we use the two built-in data types `dict`
    and `set` that we introduced in Section 4.4.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[graph.py](graph.py.html)实现了这个API。它的内部表示是一个符号表的集合：键是顶点，值是邻居的集合——与键相邻的顶点。右侧展示了一个小例子。为了实现这种表示，我们使用了我们在第4.4节介绍的两种内置数据类型`dict`和`set`。
- en: '![Graph representation](../Images/7d6f044123681643fa76e2e0ee71af1f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图表表示](../Images/7d6f044123681643fa76e2e0ee71af1f.png)'
- en: A natural way to write a `Graph` is to put the vertices one per line, each followed
    by a list of its immediate neighbors. Accordingly, we support the built-in function
    `str()` by implementing `__str__()` as shown in [graph.py](graph.py.html). The
    resulting string includes two representations of each edge, one for the case in
    which we discover that `w` is a neighbor of `v` and one for the case in which
    we discover that `v` is a neighbor of `w`. Many graph algorithms are based on
    this basic paradigm of processing each edge in the graph (twice). This implementation
    is intended for use only for small graphs, as the running time is quadratic in
    the string length on some systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一种自然的写法是将`Graph`的顶点一个接一个地放在一行上，每个顶点后面跟着其直接邻居的列表。因此，我们通过实现`__str__()`来支持内置函数`str()`，如[graph.py](graph.py.html)所示。生成的字符串包括每条边的两种表示，一种是我们发现`w`是`v`的邻居的情况，另一种是我们发现`v`是`w`的邻居的情况。许多图算法都基于这种基本的处理每条边的范式（两次）。这种实现仅适用于小图，因为在某些系统上，运行时间与字符串长度的平方成正比。
- en: The output format for `str()` also defines a reasonable input file format. The
    `__init__()` method supports creating a graph from a file in this format (each
    line is a vertex name followed by the names of neighbors of that vertex, separated
    by whitespace). For flexibility, we allow for the use of delimiters besides whitespace
    (so that, for example, vertex names may contain spaces), as shown in [graph.py](graph.py.html).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`的输出格式还定义了一个合理的输入文件格式。`__init__()`方法支持从这种格式的文件创建图（每行是一个顶点名称，后面是该顶点的邻居的名称，用空格分隔）。为了灵活性，我们允许使用除空格之外的分隔符（例如，顶点名称可能包含空格），如[graph.py](graph.py.html)所示。'
- en: '* * *'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Graph Client Example
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表客户端示例
- en: As a first graph-processing client, we consider an example of social relationships
    — one that is certainly familiar to you and for which extensive data is readily
    available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个图处理客户端，我们考虑社会关系的一个例子——这对你来说肯定很熟悉，并且有大量数据可用。
- en: On this booksite you can find the file [movies.txt](movies.txt) which contains
    a list of movies and the performers who appeared in them. Each line gives the
    name of a movie followed by the cast (a list of the names of the performers who
    appeared in that movie). Since names have spaces and commas in them, we use the
    '/' character as a delimiter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个书站上，你可以找到文件[movies.txt](movies.txt)，其中包含一系列电影及出演其中的演员。每行给出一部电影的名称，后面是演员名单（出现在该电影中的演员的名称列表）。由于名字中有空格和逗号，我们使用“/”字符作为分隔符。
- en: Using `Graph`, we can compose a simple and convenient client for extracting
    information from [movies.txt](movies.txt). We begin by building a `Graph` to better
    structure the information. What should the vertices and edges model? We choose
    to have vertices for both the movies and the performers, with an edge connecting
    each movie to each performer in that movie. As you will see, programs that process
    this graph can answer a great variety of interesting questions for us.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Graph`，我们可以构建一个简单方便的客户端，从[movies.txt](movies.txt)中提取信息。我们首先构建一个`Graph`来更好地组织信息。顶点和边应该如何建模？我们选择为电影和表演者都有顶点，每部电影与其中的每个表演者连接一条边。正如你将看到的，处理这个图的程序可以回答我们许多有趣的问题。
- en: '![Movie-performer graph](../Images/5e4268fe655b3168e9b2e9bebb3647d6.png)'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![电影-表演者图](../Images/5e4268fe655b3168e9b2e9bebb3647d6.png)'
- en: The program [invert.py](invert.py.html) is a first example. It is a `Graph`
    client that takes a query, such as the name of a movie, and writes the list of
    performers who appear in that movie. A more interesting feature of [invert.py](invert.py.html)
    is that you can type the name of a performer and get the list of movies in which
    that performer has appeared. Why does this work? Even though the database seems
    to connect movies to performers and not the other way around, the edges in the
    graph are connections that also connect performers to movies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[invert.py](invert.py.html)是一个第一个例子。它是一个`Graph`客户端，接受查询，比如电影的名称，并写出出现在该电影中的表演者列表。[invert.py](invert.py.html)的一个更有趣的特点是，你可以输入表演者的名称，然后得到该表演者出现在哪些电影中的列表。为什么会这样？尽管数据库似乎将电影连接到表演者而不是反过来，但图中的边是连接，也将表演者连接到电影。
- en: A graph in which connections all connect one kind of vertex to another kind
    of vertex is known as a *bipartite* graph. As this example illustrates, bipartite
    graphs have many natural properties that we can often exploit in interesting ways.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连接一种顶点到另一种顶点的图被称为*二部图*。正如这个例子所示，二部图有许多自然属性，我们经常可以以有趣的方式利用这些属性。
- en: It is worth reflecting on the fact that building a bipartite graph provides
    a simple way to automatically invert any index! This inverted-index functionality
    is a direct benefit of the graph *data structure*. Next, we examine some of the
    added benefits to be derived from *algorithms* that process the data structure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得反思的是，构建一个二部图提供了一种简单的方式来自动反转任何索引！这种反转索引的功能是图*数据结构*的直接好处。接下来，我们将研究一些从处理数据结构的*算法*中获得的附加好处。
- en: '* * *'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Shortest Paths in Graphs
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图中的最短路径
- en: '![Examples of shortest paths in a graph](../Images/9517f32e70cf2bca43e0baf0f9bff86d.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图中最短路径的示例](../Images/9517f32e70cf2bca43e0baf0f9bff86d.png)'
- en: Given two vertices in a graph, a *path* is a sequence of vertices connected
    by edges. A *shortest path* is one with the minimal number of edges over all such
    paths (there may be multiple shortest paths). Finding a shortest path connecting
    two vertices in a graph is a fundamental problem in computer science.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中给定两个顶点，*路径*是由边连接的顶点序列。*最短路径*是所有这样的路径中边的最小数量（可能存在多个最短路径）。在图中找到连接两个顶点的最短路径是计算机科学中的一个基本问题。
- en: 'Depending on the application, clients have various needs with regard to shortest
    paths. Our choice is to start with the following API:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的不同，客户端对于最短路径有各种需求。我们的选择是从以下API开始：
- en: '![PathFinder Api](../Images/907430fafe2fc967e4334ecfee9f0f39.png)'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![PathFinder Api](../Images/907430fafe2fc967e4334ecfee9f0f39.png)'
- en: In huge graphs or for huge numbers of queries, we have to pay particular attention
    to API design because the cost of computing paths might prove to be prohibitive.
    With this design, clients can create a `PathFinder` object for a given graph and
    a given vertex, and then use that object either to find the length of the shortest
    path or to iterate over the vertices on a shortest path to any other vertex in
    the graph. An implementation of these methods is known as a *single-source shortest-path
    algorithm*. A classic algorithm known as *breadth-first search* provides a direct
    and elegant solution where the constructor takes linear time, `distanceTo()` takes
    constant time, and `pathTo()` takes time proportional to the length of the path.
    Before examining our implementation, we will consider some clients.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在庞大的图中或对于大量查询，我们必须特别关注API设计，因为计算路径的成本可能是禁止性的。通过这种设计，客户端可以为给定的图和给定的顶点创建一个`PathFinder`对象，然后使用该对象来查找最短路径的长度或迭代最短路径上的顶点到图中的任何其他顶点。这些方法的实现被称为*单源最短路径算法*。一个被称为*广度优先搜索*的经典算法提供了一个直接而优雅的解决方案，其中构造函数需要线性时间，`distanceTo()`需要常数时间，而`pathTo()`需要与路径长度成比例的时间。在检查我们的实现之前，我们将考虑一些客户端。
- en: Single-source client.
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单源客户端。
- en: Suppose that you have available to you the graph of vertices and connections
    for your no-frills airline's route map. Then, using your home city as a source,
    you can compose a client that writes your route anytime you want to go on a trip.
    The program [separation.py](separation.py.html) is a `PathFinder` client that
    provides this functionality for any graph. You are encouraged to explore the properties
    of shortest paths by running `PathFinder` on our sample input [routes.txt](routes.txt)
    or any input model that you choose.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有你的廉价航空公司航线图的顶点和连接的图。然后，使用你的家乡作为源，你可以编写一个客户端，在任何时候你想去旅行时写出你的路线。程序[separation.py](separation.py.html)是一个`PathFinder`客户端，为任何图提供这种功能。你被鼓励通过在我们的示例输入[routes.txt](routes.txt)上运行`PathFinder`或任何你选择的输入模型来探索最短路径的属性。
- en: Degrees of separation.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离度。
- en: 'One of the classic applications of shortest-paths algorithms is to find the
    degrees of separation of individuals in social networks. To fix ideas, we discuss
    this application in terms of a recently popularized pastime known as the *Kevin
    Bacon game*, which uses the movie-performer graph that we just considered. Kevin
    Bacon is a prolific actor who appeared in many movies. We assign every performer
    who has appeared in a movie a Bacon number: Bacon himself is 0, any performer
    who has been in the same cast as Bacon has a Kevin Bacon number of 1, any other
    performer (except Bacon) who has been in the same cast as a performer whose number
    is 1 has a Kevin Bacon number of 2, and so forth. For example, Meryl Streep has
    a Kevin Bacon number of 1 because she appeared in *The River Wild* with Kevin
    Bacon. Nicole Kidman''s number is 2: although she did not appear in any movie
    with Kevin Bacon, she was in *Cold Mountain* with Donald Sutherland, and Sutherland
    appeared in *Animal House* with Kevin Bacon. Given the name of a performer, the
    simplest version of the game is to find some alternating sequence of movies and
    performers that lead back to Kevin Bacon. Remarkably, [pathfinder.py](pathfinder.py.html)
    is precisely the program that you need to find a shortest path that establishes
    the Bacon number of any performer in [movies.txt](movies.txt): the Bacon number
    of any performer is precisely half the *distance* between Kevin Bacon and that
    performer.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径算法的一个经典应用是在社交网络中找到个人之间的分离度。为了明确概念，我们讨论这个应用，以最近流行的一种名为*凯文·贝肯游戏*的消遣为例，该游戏使用我们刚刚考虑的电影-表演者图。凯文·贝肯是一位多产的演员，出演了许多电影。我们为每个出演过电影的表演者分配一个贝肯数：贝肯本人是0，任何与贝肯同台演出过的表演者的贝肯数为1，任何其他表演者（除了贝肯）与贝肯数为1的表演者同台演出过的表演者的贝肯数为2，依此类推。例如��梅丽尔·斯特里普的贝肯数为1，因为她与凯文·贝肯在《狂野河流》中演出。妮可·基德曼的数为2：尽管她没有与凯文·贝肯一起出演过任何电影，但她与唐纳德·萨瑟兰在《冷山》中演出，而萨瑟兰与凯文·贝肯在《动物屋》中演出。给定一个表演者的名字，游戏的最简单版本是找到一些交替的电影和表演者序列，将其连接回凯文·贝肯。值得注意的是，[pathfinder.py](pathfinder.py.html)正是你需要找到建立任何表演者在[movies.txt](movies.txt)中的贝肯数的最短路径的程序：任何表演者的贝肯数恰好是凯文·贝肯与该表演者之间的*距离*的一半。
- en: Shortest-path distances.
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最短路径距离。
- en: 'We define the *distance* between two vertices to be the length of the shortest
    path between them. The first step in understanding breadth-first search is to
    consider the problem of computing distances between the source and each vertex
    (the implementation of `distanceTo()` in `PathFinder`). Our approach is to compute
    and store away all the distances in the constructor, and then just return the
    requested value when a client invokes `distanceTo()`. To associate an integer
    distance with each vertex name, we use a symbol table:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义两个顶点之间的*距离*为它们之间最短路径的长度。理解广度优先搜索的第一步是考虑计算源和每个顶点之间距离的问题（在PathFinder中实现distanceTo()）。我们的方法是在构造函数中计算并存储所有距离，然后当客户调用distanceTo()时，只需返回请求的值。为了将整数距离与每个顶点名称关联起来，我们使用一个符号表：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The purpose of this symbol table is to associate with each vertex the length
    of the shortest path (the distance) between that vertex and `s`. To do that we
    consider the vertices in order of their distance from `s`, ignoring vertices whose
    distance to `s` is already known. To organize the computation, we use a FIFO queue.
    Starting with `s` on the queue, we perform the following operations until the
    queue is empty:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个符号表的目的是将每个顶点与该顶点和`s`之间的最短路径长度（距离）关联起来。为了做到这一点，我们按照它们到`s`的距离的顺序考虑顶点，忽略那些到`s`的距离已知的顶点。为了组织计算，我们使用一个FIFO队列。从队列中的`s`开始，我们执行以下操作，直到队列为空：
- en: Dequeue a vertex v.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出队一个顶点v。
- en: Assign all of v's unknown neighbors a distance 1 greater than v's distance.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将v的所有未知邻居的距离设为比v的距离大1。
- en: Enqueue all of the unknown neighbors.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有未知邻居入队。
- en: This method dequeues the vertices in nondecreasing order of their distance from
    the source `s`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法按照它们到源`s`的距离的非递减顺序出队顶点。
- en: Shortest-paths tree.
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最短路径树。
- en: 'We need not only distances from the source, but also paths. To implement `pathTo()`,
    we use a subgraph known as the *shortest-paths tree*, defined as follows: ![Shortest-path
    tree](../Images/6a979f56247b1066bcc868cb6bb564ed.png)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅需要源到目的地的距离，还需要路径。为了实现pathTo()，我们使用一个称为*最短路径树*的子图，定义如下：![最短路径树](../Images/6a979f56247b1066bcc868cb6bb564ed.png)
- en: Put the source vertex s at the root of the tree.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源顶点s放在树的根上。
- en: Put vertex v's neighbors in the tree if they are added to the queue, with an
    edge connecting each to v.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果顶点v的邻居被添加到队列中，将它们放入树中，并用一条边将每个邻居连接到v。
- en: 'Since we enqueue each vertex only once, this structure is a proper tree: it
    consists of a root (the source) connected to one subtree for each neighbor of
    the source. Studying such a tree, you can see immediately that the distance from
    each vertex to the root in the tree is the same as the shortest-path distance
    to the source in the graph. More importantly, each path in the tree is a shortest
    path in the graph. This observation is important because it gives us an easy way
    to provide clients with the shortest paths themselves (implement pathTo() in PathFinder).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们每次只将每个顶点入队一次，这个结构是一棵正确的树：它由一个根（源）连接到源的每个邻居的一个子树。研究这样一棵树，你可以立即看到树中每个顶点到根的距离与图中到源的最短路径距离相同。更重要的是，树中的每条路径都是图中的最短路径。这一观察很重要，因为它为我们提供了一种向客户提供最短路径本身的简单方法（在PathFinder中实现pathTo()）。
- en: 'First, we maintain a symbol table associating each vertex with the vertex one
    step nearer to the source on the shortest path:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们维护一个符号表，将每个顶点与在最短路径上离源一步的顶点关联起来：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To each vertex `w`, we want to associate the previous stop on the shortest
    path from the source to `w`. Augmenting the shortest-distances method to also
    compute this information is easy: when we enqueue `w` because we first discover
    it as a neighbor of `v`, we do so precisely because `v` is the previous stop on
    the shortest path from the source to `w`, so we can assign `_edgeTo[w] = v`. The
    `_edgeTo` data structure is nothing more than a representation of the shortest-paths
    tree: it provides a link from each node to its parent in the tree. Then, to respond
    to a client request for the path from the source to `v` (a call to `pathTo(v)`
    in `PathFinder`), we follow these links up the tree from `v`, which traverses
    the path in reverse order. We collect the vertices in an array as we encounter
    them, then reverse the array, so the client gets the path from `s` to `v` when
    using the iterator returned from `pathTo()`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个顶点`w`，我们希望将最短路径从源点到`w`的前一个停靠点关联起来。将最短距离方法扩展到计算这些信息也很容易：当我们因为首次发现`w`是`v`的邻居而将其入队时，正是因为`v`是从源点到`w`的最短路径上的前一个停靠点，所以我们可以赋值`_edgeTo[w]
    = v`。`_edgeTo`数据结构实际上只是最短路径树的表示：它为树中的每个节点提供了到其父节点的链接。然后，为了响应客户端对从源点到`v`的路径的请求（在`PathFinder`中调用`pathTo(v)`），我们沿着树从`v`向上遍历这些链接，以相反的顺序遍历路径。当我们遇到顶点时，我们将它们收集到一个数组中，然后反转数组，这样客户端在使用从`pathTo()`返回的迭代器时就能得到从`s`到`v`的路径。
- en: Breadth-first search.
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广度优先搜索。
- en: This process is known as breadth-first search because it searches broadly in
    the graph. By contrast, another important graph-search method known as *depth-first
    search* is based on a recursive method like the one we used in [percolation.py](../24percolation/percolation.py.html)
    from Section 2.4 and searches deeply into the graph. Depth-first search tends
    to find long paths; breadth-first search is guaranteed to find shortest paths.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为广度优先搜索，因为它在图中广泛搜索。相比之下，另一种重要的图搜索方法称为*深度优先搜索*，它基于递归方法，就像我们在第2.4节的[percolation.py](../24percolation/percolation.py.html)中使用的方法一样，并且深入搜索图。深度优先搜索倾向于找到长路径；广度优先搜索保证找到最短路径。
- en: '* * *'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Small-World Graphs
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小世界图
- en: 'Scientists have identified a particularly interesting class of graphs that
    arise in numerous applications in the natural and social sciences. Small-world
    graphs are characterized by the following three properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家们已经确定了一类特别有趣的图，在自然科学和社会科学的许多应用中出现。小世界图具有以下三个特性：
- en: 'They are *sparse*: the number of vertices is much smaller than the number of
    edges.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是*稀疏*的：顶点数远小于边数。
- en: 'They have *short average path lengths*: if you pick two random vertices, the
    length of the shortest path between them is short.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有*短平均路径长度*：如果你随机选择两个顶点，它们之间的最短路径长度很短。
- en: 'They exhibit *local clustering*: if two vertices are neighbors of a third vertex,
    then the two vertices are likely to be neighbors of each other.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们表现出*局部聚类*：如果两个顶点是第三个顶点的邻居，则这两个顶点很可能也是彼此的邻居。
- en: We refer to graphs having these three properties collectively as exhibiting
    the *small-world phenomenon*. The term *small world* refers to the idea that the
    preponderance of vertices have both local clustering and short paths to other
    vertices. The modifier *phenomenon* refers to the unexpected fact that so many
    graphs that arise in practice are sparse, exhibit local clustering, and have short
    paths.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将具有这三个特性的图统称为表现出*小世界现象*。术语*小世界*指的是绝大多数顶点既具有局部聚类又与其他顶点之间存在短路径的想法。修饰语*现象*指的是这样一个意外的事实，即实践中出现的许多图都是稀疏的，具有局部聚类，并且具有短路径。
- en: 'A key question in such research is the following: Given a graph, how can we
    tell whether it is a small-world graph? To answer this question, we begin by imposing
    the conditions that the graph is not small (say, 1000 vertices or more) and that
    it is connected (there exists some path connecting each pair of vertices). Then,
    we need to settle on specific thresholds for each of the small-world properties:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的研究中一个关键问题是：给定一个图，我们如何判断它是否是一个小世界图？为了回答这个问题，我们首先要设定图不是小的（比如，有1000个或更多个顶点），并且它是连通的（存在一条连接每对顶点的路径）。然后，我们需要为每个小世界属性设定具体的阈值：
- en: By *sparse*, we mean the average vertex degree is less than 20 lg *V*.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*稀疏*，我们指的是平均顶点度数小于20 lg *V*。
- en: By *short average path length*, we mean the average length of the shortest path
    between two vertices is less than 10 lg *V*.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*短平均路径长度*，我们指的是两个顶点之间最短路径的平均长度小于10 lg *V*。
- en: By *locally clustered*, we mean that a certain quantity known as the *clustering
    coefficient* should be greater than 10%.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*局部聚类*，我们指的是一个称为*聚类系数*的特定数量应该大于10%。
- en: The definition of locally clustered is a bit more complicated than the definitions
    of sparsity and average path length. Intuitively, the clustering coefficient of
    a vertex represents the probability that if you pick two of its neighbors at random,
    they will also be connected by an edge. More precisely, if a vertex has *t* neighbors,
    then there are *t*(*t*-1)/2 possible edges that connect those neighbors; its local
    clustering coefficient is the fraction of those edges that are in the graph (or
    0 if the vertex has degree 0 or 1). The clustering coefficient of a graph is the
    average of the local clustering coefficients of its vertices. If that average
    is greater than 10%, we say that the graph is locally clustered. The diagram below
    calculates these three quantities for a tiny graph.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 局部聚类的定义比稀疏性和平均路径长度的定义要复杂一些。直观地说，一个顶点的聚类系数表示如果你随机选择它的两个邻居，它们之间也会通过一条边相连的概率。更准确地说，如果一个顶点有*t*个邻居，那么连接这些邻居的可能边数为*t*(*t*-1)/2；它的局部聚类系数是图中存在的这些边的比例（如果顶点的度为0或1，则为0）。图的聚类系数是其顶点的局部聚类系数的平均值。如果这个平均值大于10%，我们说这个图是局部聚类的。下面的图示计算了一个小图的这三个量。
- en: '![Calculating small-world graph characteristics](../Images/d36278ad1ef4d5ef9da671a33f6c9dc6.png)'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![计算小世界图特征](../Images/d36278ad1ef4d5ef9da671a33f6c9dc6.png)'
- en: To better familiarize you with these definitions, we next define some simple
    graph models, and consider whether they describe small-world graphs by checking
    whether they exhibit the three requisite properties.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地让你熟悉这些定义，接下来我们定义一些简单的图模型，并考虑它们是否描述了小世界图，通过检查它们是否具有三个必要属性。
- en: '![Three graph models](../Images/0bb8cd75ae960f8e0c3dce08fdfc6f1d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![三种图模型](../Images/0bb8cd75ae960f8e0c3dce08fdfc6f1d.png)'
- en: Complete graphs.
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全图。
- en: A complete graph with *V* vertices has *V* (*V*-1) / 2 edges, one connecting
    each pair of vertices. Complete graphs are not small-world graphs. They have short
    average path length (every shortest path has length is 1) and they exhibit local
    clustering (the cluster coefficient is 1), but they are not sparse (the average
    vertex degree is *V*-1, which is much greater than 20 lg *V* for large *V*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有*V*个顶点的完全图有*V*（*V*-1）/ 2条边，每对顶点之间都有一条边相连。完全图不是小世界图。它们具有短平均路径长度（每条最短路径的长度为1），并且表现出局部聚类（聚类系数为1），但它们不是稀疏的（平均顶点度为*V*-1，远远大于对于大*V*的20
    lg *V*）。
- en: Ring graphs.
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环图。
- en: A ring graph is a set of *V* vertices equally spaced on the circumference of
    a circle, with each vertex connected to its neighbor on either side. In a *k*-ring
    graph, each vertex is connected to its *k* nearest neighbors on either side. The
    diagram at right illustrates a 2-ring graph with 16 vertices. Ring graphs are
    also not small-world graphs. For example, 2-ring graphs are sparse (every vertex
    has degree 4) and exhibit local clustering (the cluster coefficient is 1/2), but
    their average path length is not short.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 环图是一组*V*个顶点均匀分布在圆周上，每个顶点与其两侧的邻居相连。在一个*k*-环图中，每个顶点与其两侧的*k*个最近邻相连。右侧的图示例展示了一个具有16个顶点的2-环图。环图也不是小世界图。例如，2-环图是稀疏的（每个顶点的度为4）并且表现出局部聚类（聚类系数为1/2），但它们的平均路径长度不短。
- en: Random graphs.
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机图。
- en: The Erdos-Renyi model is a well studied model for generating random graphs.
    In this model, we build a random graph on *V* vertices by including each possible
    edge with probability *p*. Random graphs with a sufficient number of edges are
    very likely to be connected and have short average path lengths but they are not
    small-world graphs, because they are not locally clustered.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Erdos-Renyi模型是一个用于生成随机图的研究充分的模型。在这个模型中，我们通过概率*p*包含每条可能的边来构建一个具有*V*个顶点的随机图。具有足够数量的边的随机图很可能是连通的并且具有短平均路径长度，但它们不是小世界图，因为它们没有局部聚类。
- en: These examples illustrate that developing a graph model that satisfies all three
    properties simultaneously is a puzzling challenge. Take a moment to try to design
    a graph model that you think might do so. After you have thought about this problem,
    you will realize that you are likely to need a program to help with calculations.
    Also, you may agree that it is quite surprising that they are found so often in
    practice. Indeed, you might be wondering if any graph is a small-world graph!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子说明，开发一个同时满足这三个属性的图模型是一个令人困惑的挑战。花点时间尝试设计一个你认为可能做到这一点的图模型。在思考了这个问题之后，你会意识到你可能需要一个程序来帮助计算。此外，你可能会同意它们在实践中经常被发现是相当令人惊讶的。实际上，你可能会想知道是否有任何图是小世界图！
- en: Choosing 10% for the clustering threshold instead of some other fixed percentage
    is somewhat arbitrary, as is the choice of 20 lg *V* for the sparsity threshold
    and 10 lg *V* for the short paths threshold, but we often do not come close to
    these borderline values. For example, consider the web graph, which has a vertex
    for each web page and an edge connecting two web pages if they are connected by
    a link. Scientists estimate that the number of clicks to get from one web page
    to another is rarely more than about 30\. Since there are billions of web pages,
    this estimate implies that the average length of a path between two vertices is
    very short, much lower than our 10 lg *V* threshold (which would be about 300
    for 1 billion vertices).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 选择将聚类阈值设为10%而不是其他固定百分比有些是任意的，就像选择20 lg *V*作为稀疏阈值和10 lg *V*作为短路径阈值一样，��我们通常不会接近这些边界值。例如，考虑网页图，其中每个网页都有一个顶点，如果两个网页通过链接相连，则它们之间有一条边。科学家估计从一个网页到另一个网页的点击次数很少会超过30次。由于有数十亿个网页，这个估计意味着两个顶点之间路径的平均长度非常短，远低于我们的10
    lg *V*阈值（对于10亿个顶点，这将约为300）。
- en: Having settled on the definitions, testing whether a graph is a small-world
    graph can still be a significant computational burden. As you probably have suspected,
    the graph-processing data types that we have been considering provide precisely
    the tools that we need. The program [smallworld.py](smallworld.py.html) is a `Graph`
    and `PathFinder` client that implements these tests. Without the efficient data
    structures and algorithms that we have been considering, the cost of this computation
    would be prohibitive. Even so, for large graphs (such as [movies.txt](movies.txt)),
    we must resort to statistical sampling to estimate the average path length and
    the cluster coefficient in a reasonable amount of time because the functions `averagePathLength()`
    and `clusteringCoefficient()` take quadratic time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了定义之后，测试一个图是否是小世界图仍然可能是一个重要的计算负担。正如你可能已经怀疑的那样，我们一直在考虑的图处理数据类型正好提供了我们需要的工具。程序[smallworld.py](smallworld.py.html)是一个`Graph`和`PathFinder`客户端，实现了这些测试。如果没有我们一直在考虑的高效数据结构和算法，这种计算的成本将是不可承受的。即便如此，对于大型图（例如[movies.txt](movies.txt)），我们必须借助统计抽样来估计平均路径长度和聚类系数，以在合理的时间内完成，因为函数`averagePathLength()`和`clusteringCoefficient()`需要二次时间。
- en: A classic small-world graph.
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个经典的小世界图。
- en: Our movie-performer graph is not a small-world graph, because it is bipartite
    and therefore has a clustering coefficient of 0\. Also, some pairs of performers
    are not connected to each other by any paths. However, the simpler performer-performer
    graph defined by connecting two performers by an edge if they appeared in the
    same movie is a classic example of a small-world graph (after discarding performers
    not connected to Kevin Bacon). The diagram below illustrates the movie-performer
    and performer-performer graphs associated with a tiny movie-cast file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电影-演员图不是一个小世界图，因为它是二部图，因此具有聚类系数为0。此外，一些演员对之间没有连接路径。然而，通过连接出现在同一部电影中的两个演员定义的更简单的演员-演员图是小世界图的经典示例（在丢弃未与凯文·贝肯相连的演员后）。下面的图示展示了与一个小电影演员文件相关联的电影演员和演员-演员图。
- en: '![Graph representations of a movie-cast file](../Images/45ebafdffa251cc6b643f9be5d74fdcd.png)'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![电影演员文件的图形表示](../Images/45ebafdffa251cc6b643f9be5d74fdcd.png)'
- en: The program [performer.py](performer.py.html) is a script that creates a performer-performer
    graph from a file in our movie-cast input format. Recall that each line in a movie-cast
    file consists of a movie followed by all of the performers who appeared in that
    movie, delimited by slashes. The script connects all pairs of performers in that
    movie by adding an edge connecting each pair. Doing so for each movie in the input
    produces a graph that connects the performers, as desired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[performer.py](performer.py.html)是一个脚本，从我们的电影-演员输入格式的文件中创建一个演员-演员图。回想一下，电影-演员文件中的每一行都包含一部电影，后面跟着出现在该电影中的所有演员，用斜杠分隔。该脚本通过添加连接每对演员的边来连接该电影中的所有演员。对输入中的每部电影执行此操作会产生一个连接演员的图。
- en: Since a performer-performer graph typically has many more edges than the corresponding
    movie-performer graph, we will work for the moment with the smaller performer-performer
    graph derived from the file [moviesg.txt](moviesg.txt), which contains 1261 G-rated
    movies and 19044 performers (all of which are connected to Kevin Bacon). Now,
    [performer.py](performer.py.html) tells us that the performer-performer graph
    associated with [moviesg.txt](moviesg.txt) has 19044 vertices and 1415808 edges,
    so the average vertex degree is 148.7 (about half of 20 lg *V* = 284.3), which
    means it is sparse; its average path length is 3.494 (much less than 10 lg *V*
    = 142.2), so it has short paths; and its clustering coefficient is 0.911, so it
    has local clustering. We have found a small-world graph! These calculations validate
    the hypothesis that social relationship graphs of this sort exhibit the small-world
    phenomenon.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于演员-演员图通常比相应的电影-演员图具有更多的边，我们暂时使用从文件[moviesg.txt](moviesg.txt)中导出的较小的演员-演员图，其中包含1261部G级电影和19044名演员（所有演员都与凯文·贝肯相连）。现在，[performer.py](performer.py.html)告诉我们，与[moviesg.txt](moviesg.txt)相关联的演员-演员图有19044个顶点和1415808条边，因此平均顶点度为148.7（约为
    20 lg *V* = 284.3 的一半），这意味着它是稀疏的；其平均路径长度为3.494（远小于 10 lg *V* = 142.2），因此具有短路径；其聚类系数为0.911，因此具有局部聚类。我们找到了一个小世界图！这些计算验证了这种类型的社交关系图表现出小世界现象的假设。
- en: This case study is an appropriate place to end the booksite because the programs
    that we have considered are a starting point, not a complete study. This booksite
    is a starting point, too, for your further study in science, mathematics, or engineering.
    The approach to programming and the tools that you have learned here should prepare
    you well for addressing any computational problem whatsoever.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例研究是书站的一个适当结束点，因为我们考虑的程序只是一个起点，而不是一个完整的研究。这个书站也是你在科学、数学或工程领域进一步学习的起点。你在这里学到的编程方法和工具应该能够很好地为你解决任何计算问题做好准备。
- en: '* * *'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: '**Q.** How many different graphs are there with *V* given vertices?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 有多少个具有给定顶点数 *V* 的不同图形？'
- en: '**A.** With no self-loops or parallel edges, there are *V*(*V*-1)/2 possible
    edges, each of which can be present or not present, so the grand total is 2^(*V*(*V*-1)/2).
    The number grows to be huge quite quickly, as shown in the following table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 没有自环或平行边，有 *V*(*V*-1)/2 条可能的边，每条边可以存在也可以不存在，因此总数为 2^(*V*(*V*-1)/2)。这个数字增长得非常快，如下表所示：'
- en: '| *V* | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| *V* | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| 2^(*V*(*V*-1)/2) | 1 | 2 | 8 | 64 | 1024 | 32768 | 2097152 | 268435456 |
    68719476736 |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 2^(*V*(*V*-1)/2) | 1 | 2 | 8 | 64 | 1024 | 32768 | 2097152 | 268435456 |
    68719476736 |'
- en: These huge numbers provide some insight into the complexities of social relationships.
    For example, if you just consider the next nine people that you see on the street,
    there are over 68 trillion mutual-acquaintance possibilities!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些巨大的数字为我们提供了一些关于社交关系复杂性的见解。例如，如果你只考虑在街上看到的下一个九个人，那么存在超过68万亿种相互熟识的可能性！
- en: '**Q.** Can a graph have a vertex that is not connected to any other vertex
    by an edge?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 一个图可以有一个顶点，它与任何其他顶点都没有边连接吗？'
- en: '**A.** Good question. Such vertices are known as *isolated vertices*. Our implementation
    disallows them. Another implementation might choose to allow isolated vertices
    by including an explicit `addVertex()` method for the add a vertex operation.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 很好的问题。这样的顶点被称为*孤立顶点*。我们的实现不允许它们。另一个实现可能选择通过包含一个显式的`addVertex()`方法来允许孤立顶点进行添加顶点操作。'
- en: '**Q.** Why do the `countV()` and `countE()` query methods need to have constant-time
    implementations? Won''t most clients would call such methods only once?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 为什么`countV()`和`countE()`查询方法需要具有常数时间的实现？大多数客户端只会调用这样的方法一次吗？'
- en: '**A.** It might seem so, but code like this'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 看起来是这样，但是像这样的代码'
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: would take quadratic time if you were to use a lazy implementation that counts
    the edges instead of maintaining an instance variable with the number of edges.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个懒惰的实现来计算边的数量而不是维护一个包含边数的实例变量，那么将需要二次时间。
- en: '**Q.** Why are `Graph` and `PathFinder` in separate classes? Wouldn''t it make
    more sense to include the `PathFinder` methods in the `Graph` API?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 为什么`Graph`和`PathFinder`在单独的类中？将`PathFinder`方法包含在`Graph`API中会更有意义吗？'
- en: '**A.** Finding shortest paths is just one of many graph-processing algorithms.
    It would be poor software design to include all of them in a single interface.
    Please reread the discussion of wide interfaces in Section 3.3.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 寻找最短路径只是众多图处理算法中的一个。在单个接口中包含所有这些算法将是糟糕的软件设计。请重新阅读第3.3节中有关宽接口的讨论。'
- en: '* * *'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Find the performer in [movies.txt](movies.txt) who has appeared in the most
    movies.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出在[movies.txt](movies.txt)中出现次数最多的表演者。
- en: 'Modify the `__str__()` method in `Graph` so that it returns the vertices in
    sorted order (assuming the vertices are comparable). *Hint*: Use the built-in
    `sorted()` function.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Graph`中的`__str__()`方法，使其按顶点的排序顺序返回顶点（假设顶点是可比较的）。*提示*：使用内置的`sorted()`函数。
- en: 'Modify the `__str__()` method in `Graph` so that it runs in time linear in
    the number of vertices and the number of edges in the worst case. *Hint*: Use
    the `join()` method in the str data type.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Graph`中的`__str__()`方法，使其在最坏情况下以顶点数和边数为线性时间运行。*提示*：使用str数据类型中的`join()`方法。
- en: Add to `Graph` a method `copy()` that creates and return a new, independent
    copy of the graph. Any future changes to the original graph should not affect
    the newly created graph (and vice versa!).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Graph`中添加一个名为`copy()`的方法，创建并返回图的一个新的、独立的副本。对原始图的任何未来更改不应影响新创建的图（反之亦然！）。
- en: Compose a version of `Graph` that supports explicit vertex creation and allows
    self-loops, parallel edges, and isolated vertices (vertices of degree 0).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个支持显式顶点创建并允许自环、平行边和孤立顶点（度为0的顶点）的`Graph`版本。
- en: Add to `Graph` a method `removeEdge()` that takes two string arguments and deletes
    the specified edge from the graph, if present.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Graph`中添加一个名为`removeEdge()`的方法，该方法接受两个字符串参数，并从图中删除指定的边（如果存在）。
- en: Add to `Graph` a method `subgraph()` that takes a set of strings as an argument
    and returns the *induced subgraph* (the graph consisting of only those vertices
    and only those edges from the original graph that connect any two of them).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Graph`中添加一个名为`subgraph()`的方法，该方法接受一个字符串集合作为参数，并返回*诱导子图*（仅由原始图中连接任意两个顶点的那些顶点和边组成的图）。
- en: Describe the advantages and disadvantages of using an array or a linked list
    to represent the neighbors of a vertex instead of using a set.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述使用数组或链表代表顶点的邻居而不是使用集合的优缺点。
- en: Compose a `Graph` client that reads a `Graph` from a file, then writes the edges
    in the graph, one per line.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Graph`客户端，从文件中读取一个`Graph`，然后将图中的边逐行写出。
- en: Modify `Graph` so that it supports vertices of any hashable type.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Graph`，使其支持任何可散列类型的顶点。
- en: 'Implement a `PathFinder` client `allshortestpaths.py` that takes the name of
    a graph file and a delimiter as command-line arguments, builds a `PathFinder`
    for each vertex, and then repeatedly takes from standard input the names of two
    vertices (on one line, separated by the delimiter) and writes the shortest path
    connecting them. Note: For [movies.txt](movies.txt), the vertex names may both
    be performers, both be movies, or be a performer and a movie.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`PathFinder`客户端`allshortestpaths.py`，���接受图文件的名称和分隔符作为命令行参数，为每个顶点构建一个`PathFinder`，然后重复从标准输入中获取两个顶点的名称（在一行上，由分隔符分隔），并写出连接它们的最短路径。注意：对于[movies.txt](movies.txt)，顶点名称可以都是表演者、都是电影，或者是表演者和电影。
- en: '*True or false*: At some point during breadth-first search, the queue can contain
    two vertices, one whose distance from the source is 7 and one whose distance from
    the source is 9.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*真或假*：在广度优先搜索的某个时刻，队列可以包含两个顶点，一个距离源点的距离为7，另一个距离源点的距离为9。'
- en: '*Solution*: False. The queue can contain vertices of at most two distinct distances
    *d* and *d*+1\. Breadth-first search examines the vertices in increasing order
    of distance from the source. When examining a vertex at distance *d*, only vertices
    of distance *d*+1 can be enqueued.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解答*：错误。队列最多可以包含两个不同距离*d*和*d*+1的顶点。广度优先搜索按照从源点距离递增的顺序检查顶点。在检查距离为*d*的顶点时，只有距离为*d*+1的顶点可以入队。'
- en: Prove by induction on the set of vertices visited that `PathFinder` finds the
    shortest-path distances from the source to each vertex.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对访问的顶点集合进行归纳，证明`PathFinder`能够找到从源点到每个顶点的最短路径距离。
- en: Suppose you use a stack instead of a queue for breadth-first search in `PathFinder`.
    Does it still find a path? Does it still correctly compute shortest paths? In
    each case, prove that it does or give a counterexample.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在`PathFinder`中使用栈而不是队列进行广度优先搜索。它仍然能找到一条路径吗？它仍然能正确计算最短路径吗？在每种情况下，证明它能够或者给出反例。
- en: Compose a program that plots average path length versus the number of random
    edges as random shortcuts are added to a 2-ring graph on 1000 vertices.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，绘制平均路径长度与随机添加到具有1000个顶点的2环图中的随机快捷方式数量之间的关系。
- en: Add an optional argument `k` to `clusterCoefficient()` in the module [smallworld.py](smallworld.py.html)
    so that it computes a local cluster coefficient for the graph based on the total
    edges present and the total edges possible among the set of vertices within distance
    `k` of each vertex. Use the default value `k`=1 so that your function produces
    results identical to the function with the same name in [smallworld.py](smallworld.py.html).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块[smallworld.py](smallworld.py.html)中的`clusterCoefficient()`中添加一个可选参数`k`，以便根据存在的总边和在每个顶点距离`k`内的顶点集合之间可能的总边来计算图的局部簇系数。使用默认值`k`=1，使得您的函数产生与[smallworld.py](smallworld.py.html)中同名函数相同的结果。
- en: Show that the cluster coefficient in a *k*-ring graph is (2*k*-2) / (2*k*-1).
    Derive a formula for the average path length in a *k*-ring graph on *V* vertices
    as a function of both *V* and *k*.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明*k*环图中的簇系数为(2*k*-2) / (2*k*-1)。推导出*k*环图在*V*个顶点上的平均路径长度的公式，作为*V*和*k*的函数。
- en: Show that the diameter in a 2-ring graph on *V* vertices is ~ *V*/4\. Show that
    if you add one edge connecting two antipodal vertices, then the diameter decreases
    to ~ *V*/8.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明在具有*V*个顶点的2环图中直径为~*V*/4。证明如果添加一条连接两个对脚顶点的边，则直径减小到~*V*/8。
- en: Perform computational experiments to verify that the average path length in
    a ring graph on V vertices is ~ 1/4 *V*. Repeat, but add one random edge to the
    ring graph and verify that the average path length decreases to ~ 3/16 *V*.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行计算实验，验证V个顶点的环图中的平均路径长度约为~ 1/4 *V*。重复此过程，但向环图添加一条随机边，并验证平均路径长度减少到约~ 3/16 *V*。
- en: Add to [smallworld.py](smallworld.py.html) a function `isSmallWorld()` that
    takes a graph as an argument and returns `True` if the graph exhibits the small-world
    phenomenon (as defined by the specific thresholds given in the text) and `False`
    otherwise.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[smallworld.py](smallworld.py.html)中添加一个名为`isSmallWorld()`的函数，该函数接受一个图作为参数，并在图符合特定阈值（文本中给出的定义）时返回`True`，否则返回`False`。
- en: Compose a [smallworld.py](smallworld.py.html) and `Graph` client that generates
    *k*-ring graphs and tests whether they exhibit the small-world phenomenon (first
    do the previous exercise).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个[smallworld.py](smallworld.py.html)和`Graph`客户端，生成*k*环图，并测试它们是否表现出小世界现象（首先完成前一个练习）。
- en: In a *grid graph*, vertices are arranged in an *n*-by-*n* grid, with edges connecting
    each vertex to its neighbors above, below, to the left, and to the right in the
    grid. Compose a [smallworld.py](smallworld.py.html) and `Graph` client that generates
    grid graphs and tests whether they exhibit the small-world phenomenon (first add
    an `isSmallWorld()` method to [smallworld.py](smallworld.py.html), as described
    in a previous exercise).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个*网格图*中，顶点按*n*乘*n*的网格排列，边连接每个顶点与网格中上、下、左、右的邻居。编写一个[smallworld.py](smallworld.py.html)和`Graph`客户端，生成网格图，并测试它们是否表现出小世界现象（首先在[smallworld.py](smallworld.py.html)中添加一个`isSmallWorld()`方法，如前一个练习中所述）。
- en: Extend your solutions to the previous two exercises to also take a command-line
    argument *m* and to add *m* random edges to the graph. Experiment with your programs
    for graphs with approximately 1000 vertices to find small-world graphs with relatively
    few edges.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你对前两个练习的解决方案扩展到还接受一个命令行参数*m*，并向图中添加*m*条随机边。通过实验，找出具有相对较少边的约1000个顶点的小世界图。
- en: Compose a `Graph` and `PathFinder` client that takes the name of a movie-cast
    file and a delimiter as arguments and writes a new movie-cast file, but with all
    movies not connected to Kevin Bacon removed.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Graph`和`PathFinder`客户端，接受电影演员表文件的名称和分隔符作为参数，并写出一个新的电影演员表文件，但删除所有与凯文·贝肯没有联系的电影。
- en: '* * *'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Large Bacon numbers.** Find the performers in [movies.txt](movies.txt) with
    the largest, but finite, Kevin Bacon number.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大的贝肯数。** 找出[movies.txt](movies.txt)中具有最大但有限的凯文·贝肯数的表演者。'
- en: '**Histogram.** Compose a program `baconhistorgram.py` that writes a histogram
    of Kevin Bacon numbers, indicating how many performers from [movies.txt](movies.txt)
    have a Bacon number of 0, 1, 2, 3, ... Include a category for those who have an
    infinite number (not connected at all to Kevin Bacon).'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**直方图。** 编写一个名为`baconhistorgram.py`的程序，写出凯文·贝肯数的直方图，指示来自[movies.txt](movies.txt)的表演者中有多少人的贝肯数为0、1、2、3，...
    包括那些贝肯数为无穷大的人（与凯文·贝肯完全没有联系）。'
- en: '**Performer-performer graph.** An alternative way to compute Kevin Bacon numbers
    is to build a graph where there is a vertex for each performer (but not for each
    movie), and where two performers are connected by an edge if they appear in a
    movie together. Calculate Kevin Bacon numbers by running breadth-first search
    on the performer-performer graph. Compare the running time with the running time
    on [movies.txt](movies.txt). Explain why this approach is so much slower. Also
    explain what you would need to do to include the movies along the path, as happens
    automatically with our implementation.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表演者-表演者图。** 计算凯文·贝肯数的另一种方法是构建一个图，其中每个表演者都有一个顶点（但不是每部电影），如果两个表演者在一部电影中一起出现，则它们通过一条边相连。通过在表演者-表演者图上运行广度优先搜索来计算凯文·贝肯数。将此方法的运行时间与[movies.txt](movies.txt)上的运行时间进行比较。解释为什么这种方法要慢得多。还解释一下如果要包含路径上的电影，就像我们的实现自动完成的那样，你需要做什么。'
- en: '**Connected components.** A *connected component* in an undirected graph is
    a maximal set of vertices that are mutually reachable. Compose a data type `ConnectedComponents`
    that computes the connected components of a graph. Include a constructor that
    takes a `Graph` as an argument and computes all of the connected components using
    breadth-first search. Include a method `areConnected(v, w)` that returns `True`
    if `v` and `w` are in the same connected component and `False` otherwise. Also
    add a method `components()` that returns the number of connected components.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连通分量。** 在无向图中，一个*连通分量*是一个互相可达的顶点的最大集合。编写一个数据类型`ConnectedComponents`，计算图的连通分量。包括一个以`Graph`为参数的构造函数，使用广度优先搜索计算所有连通分量。还包括一个方法`areConnected(v,
    w)`，如果`v`和`w`在同一个连通分量中则返回`True`，否则返回`False`。还添加一个方法`components()`，返回连通分量的数量。'
- en: '**Flood fill.** A `Picture` is a two-dimensional array of `Color` values (see
    Section 3.1) that represent pixels. A *blob* is a collection of neighboring pixels
    of the same color. Compose a `Graph` client whose constructor builds a grid graph
    (see a previous exercise in this section) from a given image and supports the
    *flood fill* operation. Given pixel coordinates `col` and `row` and a color `c`,
    change the color of that pixel and all the pixels in the same blob to `c`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**泛洪填充。** 一个`Picture`是一个代表像素的`Color`值的二维数组（参见第3.1节）。一个*blob*是相邻像素的集合，颜色相同。编写一个`Graph`客户端，其构造函数从给定图像构建一个网格图（参见本节中的一个先前练习），并支持*泛洪填充*操作。给定像素坐标`col`和`row`以及颜色`c`，将该像素及同一blob中的所有像素的颜色更改为`c`。'
- en: '**Word ladders.** Compose a program `wordladder.py` that takes two 5-letter
    strings from the command line, reads in a list of 5-letter words from standard
    input, and writes a shortest [word ladder](https://en.wikipedia.org/wiki/Word_ladder)
    using the words on standard input connecting the two strings (if it exists). Two
    words can be connected in a word ladder chain if they differ in exactly one letter.
    As an example, the following word ladder connects green and brown:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单词阶梯。** 编写一个程序`wordladder.py`，从命令行接受两个5个字母的字符串，从标准输入读取一个5个字母单词列表，并使用标准输入上的单词连接这两个字符串的最短[word
    ladder](https://en.wikipedia.org/wiki/Word_ladder)。如果存在的话，两个单词可以在单词阶梯链中连接，如果它们只有一个字母不同。例如，以下单词阶梯连接了green和brown：'
- en: '[PRE3]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compose a simple filter to get the 5-letter words from a system dictionary for
    standard input, or download [words5.txt](words5.txt). You can also try out your
    program on [words6.txt](words6.txt), a list of 6 letter words. (This game, originally
    known as *doublet*, was invented by Lewis Carroll.)
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个简单的过滤器，从系统字典中获取5个字母的单词作为标准输入，或下载[words5.txt](words5.txt)。你也可以尝试在[words6.txt](words6.txt)上运行你的程序，这是一个6个字母单词的列表。（这个游戏最初被称为*doublet*，是刘易斯·卡罗尔发明的。）
- en: '**All paths.** Compose a `Graph` client class `AllPaths` whose constructor
    takes a `Graph` as an argument and supports operations to count or write all simple
    paths between two given vertices `s` and `t` in the graph. A *simple* path does
    not revisit any vertex more than once. In two-dimensional grids, such paths are
    referred to as self-avoiding walks (see Section 1.4). It is a fundamental problem
    in statistical physics and theoretical chemistry, for example, to model the spatial
    arrangement of linear polymer molecules in a solution. *Warning*: There might
    be exponentially many paths.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有路径。** 编写一个`Graph`客户端类`AllPaths`，其构造函数接受一个`Graph`作为参数，并支持在图中两个给定顶点`s`和`t`之间计算或写入所有简单路径的操作。*简单*路径不会多次访问任何顶点。在二维网格中，这样的路径被称为避免自身的行走（参见第1.4节）。在统计物理学和理论化学中，这是一个基本问题，例如，用于模拟溶液中线性聚合物分子的空间排列。*警告*：可能存在指数多条路径。'
- en: '**Percolation threshold.** Develop a graph model for percolation, and compose
    a `Graph` client that performs the same computation as [percolation.py](../24percolation/percolation.py.html)
    (from Section 2.4). Estimate the percolation threshold for triangular, square,
    and hexagonal grids.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**渗透阈值。** 为渗透开发一个图模型，并编写一个执行与[percolation.py](../24percolation/percolation.py.html)（来自第2.4节）相同计算的`Graph`客户端。估计三角形、正方形和六边形网格的渗透阈值。'
- en: '**Subway graphs.** In the Tokyo subway system, routes are labeled by letters
    and stops by numbers, such as G-8 or A-3\. Stations allowing transfers are sets
    of stops. Find a Tokyo subway map on the web, develop a simple database format,
    and compose a `Graph` client that reads a file and can answer shortest-path queries
    for the Tokyo subway system. If you prefer, do the Paris subway system, where
    routes are sequences of names and transfers are possible when two stations have
    the same name.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**地铁图。** 在东京地铁系统中，路线用字母标记，车站用数字标记，例如 G-8 或 A-3。允许换乘的车站是一组车站。在网上找到东京地铁地图，开发一个简单的数据库格式，并编写一个`Graph`客户端，用于读取文件并可以回答东京地铁系统的最短路径查询。如果你愿意，也可以选择巴黎地铁系统，那里的路线是名称序列，当两个车站有相同名称时可以换乘。'
- en: '**Center of the Hollywood universe.** We can measure how good a center Kevin
    Bacon is by computing each performer''s *Hollywood number* or average path length.
    The Hollywood number of Kevin Bacon is the average Bacon number of all the performers
    (in its connected component). The Hollywood number of another performer is computed
    the same way, making that performer the source instead of Kevin Bacon. Compute
    Kevin Bacon''s Hollywood number and find a performer with a better Hollywood number
    than Kevin Bacon. Find the performers (in the same connected component as Kevin
    Bacon) with the best and worst Hollywood numbers.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**好莱坞宇宙的中心。** 我们可以通过计算每个表演者的*好莱坞数*或平均路径长度来衡量凯文·贝肯的中心性。凯文·贝肯的好莱坞数是所有表演者的平均贝肯数（在其连通分量中）。另一个表演者的好莱坞数计算方式相同，只是将该表演者作为源而不是凯文·贝肯。计算凯文·贝肯的好莱坞数，并找到一个比凯文·贝肯好的好莱坞数的表演者。找到（与凯文·贝肯在同一连通分量中的）好莱坞数最好和最差的表演者。'
- en: '**Diameter.** The *eccentricity* of a vertex is the greatest distance between
    it and any other vertex. The *diameter* of a graph is the greatest distance between
    any two vertices (the maximum eccentricity of any vertex). Compose a `Graph` client
    `diameter.py` that can compute the eccentricity of a vertex and the diameter of
    a graph. Use it to find the diameter of the graph represented by [movies.txt](movies.txt).'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**直径。** 一个顶点的*离心率*是它与任何其他顶点之间的最大距离。图的*直径*是任意两个顶点之间的最大距离（任何顶点的最大离心率）。编写一个`Graph`客户端`diameter.py`，可以计算顶点的离心率和图的直径。使用它来找到由[movies.txt](movies.txt)表示的图的直径。'
- en: '**Directed graphs.** Implement a `Digraph` data type that represents *directed*
    graphs, where the direction of edges is significant: `addEdge(v, w)` means to
    add an edge from `v` to `w` but not from `w` to `v`. Replace `adjacentTo()` with
    two methods: `adjacentFrom()`, to give the set of vertices having edges directed
    to them from the argument vertex, and `adjacentTo()`, to give the set of vertices
    having edges directed from them to the argument vertex. Explain how to modify
    `PathFinder` to find shortest paths in directed graphs.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有向图。** 实现一个表示*有向*图的`Digraph`数据类型，其中边的方向很重要：`addEdge(v, w)`表示从`v`到`w`添加一条边，但不是从`w`到`v`。用两种方法替换`adjacentTo()`：`adjacentFrom()`，给出具有从参数顶点指向它们的边的顶点集，以及`adjacentTo()`，给出具有从它们指向参数顶点的边的顶点集。解释如何修改`PathFinder`以在有向图中找到最短路径。'
- en: '**Random surfer.** Modify your `Digraph` class of the previous exercise to
    make a `MultiDigraph` class that allows parallel edges. For a test client, run
    a random surfer simulation that matches [randomsurfer.py](../16pagerank/randomsurfer.py.html)
    (from Section 1.6).'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机冲浪者。** 修改你之前练习中的`Digraph`类，制作一个允许平行边的`MultiDigraph`类。作为一个测试客户端，运行一个与[randomsurfer.py](../16pagerank/randomsurfer.py.html)（来自第1.6节）相匹配的随机冲浪者模拟。'
- en: '**Transitive closure**. Compose a `Digraph` client class `TransitiveClosure`
    whose constructor takes a `Digraph` as an argument and whose method `isReachable(v,
    w)` returns `True` if `w` is reachable from `v` along a directed path in the digraph
    and `False` otherwise. *Hint*: Run breadth-first search from each vertex, as in
    `allshortestpaths.py` (from a previous exercise).'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**传递闭包**。编写一个 `Digraph` 客户端类 `TransitiveClosure`，其构造函数接受一个 `Digraph` 作为参数，其方法
    `isReachable(v, w)` 如果在有向图中从 `v` 到 `w` 有一条路径，则返回 `True`，否则返回 `False`。*提示*: 从每个顶点运行广度优先搜索，就像在
    `allshortestpaths.py` 中一样（来自之前的练习）。'
- en: '**Statistical sampling.** Use statistical sampling to estimate the average
    path length and clustering coefficient of a graph. For example, to estimate the
    clustering coefficient, pick *t* random vertices and compute the average of the
    clustering coefficients of those vertices. The running time of your functions
    should be orders of magnitude faster than the corresponding functions from [smallworld.py](smallworld.py.html).'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**统计抽样。** ��用统计抽样来估计图的平均路径长度和聚类系数。例如，要估计聚类系数，选择 *t* 个随机顶点，并计算这些顶点的聚类系数的平均值。你的函数的运行时间应该比
    [smallworld.py](smallworld.py.html) 中相应函数的运行时间快几个数量级。'
- en: '**Cover time.** A *random walk* in a connected undirected graph moves from
    a vertex to one of its neighbors, each chosen with equal probability. (This process
    is the random surfer analog for undirected graphs.) Compose programs to run experiments
    that support the development of hypotheses on the number of steps used to visit
    every vertex in the graph. What is the cover time for a complete graph with *V*
    vertices? Can you find a family of graphs where the cover time grows proportionally
    to *V*³ or 2^(*V*)?'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**覆盖时间。** 在一个连通的无向图中，*随机游走* 从一个顶点移动到其邻居之一，每个邻居被等概率选择。（这个过程是无向图的随机冲浪者类比。）编写程序运行实验，支持对访问图中每个顶点所需步数的假设的发展。完全图的覆盖时间是多少？你能找到一个图族，其中覆盖时间与
    *V*³ 或 2^(*V*) 成比例增长吗？'
- en: '**Erdos-Renyi random graph model.** In the classical random graph model, we
    build a random graph on *V* vertices by including each possible edge with probability
    *p*, independently of the other edges. Compose a `Graph` client to verify the
    following properties:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Erdos-Renyi 随机图模型。** 在经典随机图模型中，我们通过以概率 *p* 独立地包含每条可能的边来构建具有 *V* 个顶点的随机图。编写一个
    `Graph` 客户端来验证以下属性:'
- en: '*Connectivity thresholds:* If *p* < 1/*V* and *V* is large, then most of the
    connected components are small, with the largest being logarithmic in size. If
    *p* > 1/*V*, then there is almost surely a giant component containing almost all
    vertices. If *p* < ln *V* / *V*, the graph is disconnected with high probability;
    if *p* > ln *V* / *V*, the graph is connected with high probability.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接阈值:* 如果 *p* < 1/*V* 且 *V* 很大，则大多数连接组件很小，最大的组件大小对数级别。如果 *p* > 1/*V*，则几乎肯定存在一个包含几乎所有顶点的巨型组件。如果
    *p* < ln *V* / *V*，则图几乎肯定是不连通的；如果 *p* > ln *V* / *V*，则图几乎肯定是连通的。'
- en: '*Distribution of degrees:* The distribution of degrees follows a binomial distribution,
    centered on the average, so most vertices have similar degrees. The probability
    that a vertex is connected to *k* other vertices decreases exponentially in *k*.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*度的分布:* 度的分布遵循二项分布，以平均值为中心，因此大多数顶点具有相似的度。顶点连接到 *k* 其他顶点的概率按 *k* 指数下降。'
- en: '*No hubs:* The maximum vertex degree when *p* is a constant is at most logarithmic
    in *V*.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无中心枢纽:* 当 *p* 是一个常数时，最大顶点度数至多对数级别。'
- en: '*No local clustering:* The cluster coefficient is close to 0 if the graph is
    sparse and connected. Random graphs are not small-world graphs.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无局部聚类:* 如果图稀疏且连通，则聚类系数接近于0。随机图不是小世界图。'
- en: '*Short path lengths:* If *p* > ln *V* / *V*, then the diameter of the graph
    (see the *Diameter* creative exercise earlier in this section) is logarithmic.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*短路径长度:* 如果 *p* > ln *V* / *V*，那么图的直径（请参见本节前面的 *直径* 创意练习）是对数的。'
- en: '**Power law of web links.** The indegrees and outdegrees of pages in the web
    obey a power law that can be modeled by a *preferred attachment* process. Suppose
    that each web page has exactly one outgoing link. Each page is created one at
    a time, starting with a single page that points to itself. With probability *p*
    < 1, it links to one of the existing pages, chosen uniformly at random. With probability
    1-*p*, it links to an existing page with probability proportional to the number
    of incoming links of that page. This rule reflects the common tendency for new
    web pages to point to popular pages. Compose a program to simulate this process
    and plot a histogram of the number of incoming links.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络链接的幂律。** 网页的入度和出度遵循幂律，可以通过 *优选附加* 过程来建模。假设每个网页只有一个外链。每个页面逐个创建，从指向自身的单个页面开始。以概率
    *p* < 1，它链接到现有页面之一，随机选择。以概率 1-*p*，它链接到现有页面的概率与该页面的入链数成正比。这一规则反映了新网页指向热门页面的普遍倾向。编写一个程序来模拟这个过程，并绘制入链数量的直方图。'
- en: '*Partial solution:* The fraction of pages with indegree *k* is proportional
    to *k*^(-1/(1-*p*)).'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解:* 入度为 *k* 的页面比例与 *k*^(-1/(1-*p*)) 成正比。'
- en: '**Global clustering coefficient.** Add a function to [smallworld.py](smallworld.py.html)
    that computes the global clustering coefficient of a graph. The *global clustering
    coefficient* is the conditional probability that two random vertices that are
    neighbors of a common vertex are neighbors of each other. Find graphs for which
    the local and global clustering coefficients are different.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全局聚类系数。** 在 [smallworld.py](smallworld.py.html) 中添加一个计算图的全局聚类系数的函数。*全局聚类系数*
    是两个共同顶点的随机顶点是彼此的邻居的条件概率。找到局部和全局聚类系数不同的图。'
- en: '**Watts-Strogatz graph model.** (See Exercises 4.5.24 and 4.5.25.) Watts and
    Strogatz proposed a hybrid model that contains typical links of vertices near
    each other (people know their geographic neighbors), plus some random long-range
    connection links. Plot the effect of adding random edges to an *n*-by-*n* grid
    graph (as described in previous exercises in this section) on the average path
    length and on the cluster coefficient, for *n* = 100\. Do the same for *k*-ring
    graphs on *V* vertices, for *V* = 10000 and various values of *k* up to 10 log
    *V*.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**瓦茨-斯特罗加茨图模型。**（见练习4.5.24和4.5.25。）瓦茨和斯特罗加茨提出了一个混合模型，其中包含了顶点之间相邻的典型链接（人们知道他们的地理邻居），以及一些随机的远程连接链接。在一个*n*×*n*的网格图上添加随机边的效果（如本节中先前练习中描述的），对于*n*
    = 100，对平均路径长度和聚类系数进行绘图。对于*V*个顶点的*k*环图，对于*V* = 10000和不同值的*k*，最多到10 log *V*。'
- en: '**Bollobas-Chung graph model.** Bollobas and Chung proposed a hybrid model
    that combines a 2-ring on *V* vertices (*V* is even), plus a *random matching*.
    A *matching* is a graph in which every vertex has degree 1\. To generate a random
    matching, shuffle the *V* vertices and add an edge between vertex *i* and vertex
    *i*+1 in the shuffled order. Determine the degree of each vertex for graphs in
    this model. Using [smallworld.py](smallworld.py.html), estimate the average path
    length and cluster coefficient for random graphs generated according to this model
    for *V* = 1000.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**博洛巴斯-钟图模型。** 博洛巴斯和钟提出了一个混合模型，结合了一个*V*个顶点的2环（*V*为偶数），加上一个*随机匹配*。一个*匹配*是一个每个顶点度为1的图。要生成一个随机匹配，打乱*V*个顶点并在打乱顺序中在顶点*i*和顶点*i*+1之间添加一条边。确定该模型中每个顶点的度。使用[smallworld.py](smallworld.py.html)，估计根据这个模型生成的随机图的平均路径长度和聚类系数，对于*V*
    = 1000。'
- en: '**Kleinberg graph model.** There is no way for participants in the Watts-Strogatz
    model to find short paths in a decentralized network. But Milgram''s experiment
    also had a striking algorithmic component — individuals can find short paths!
    Jon Kleinberg proposed making the distribution of shortcuts obey a power law,
    with probability proportional to the *d*th power of the distance (in *d* dimensions).
    Each vertex has one long-range neighbor. Compose a program to generate graphs
    according to this model, with a test client that uses [smallworld.py](smallworld.ph.html)
    to test whether they exhibit the small-world phenomenon. Plot histograms to show
    that the graphs are uniform over all distance scales (same number of links at
    distances 1-10 as at distances 10-100 or 100-1000). Compose a program to compute
    the average lengths of paths obtained by taking the edge that brings the path
    as close to the target as possible in terms of lattice distance, and test the
    hypothesis that this average is proportional to (log *V*)².'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**克莱因伯格图模型。** 在瓦茨-斯特罗加茨模型中，参与者无法在分散网络中找到短路径。但米尔格拉姆的实验也有一个引人注目的算法组成部分 — 个体可以找到短路径！乔恩·克莱因伯格建议使快捷方式的分布服从幂律，概率与距离（在*d*维度中）的*d*次幂成比例。每个顶点有一个远程邻居。编写一个程序根据这个模型生成图形，使用[smallworld.py](smallworld.ph.html)的测试客户端来测试它们是否表现出小世界现象。绘制直方图以显示图形在所有距离尺度上均匀（在距离1-10处具有相同数量的链接，如在距离10-100或100-1000处）。编写一个程序来计算通过取将路径尽可能接近目标的边缘（以格点距离为准）而获得的路径的平均长度，并测试这个平均值是否与(log
    *V*)²成比例的假设。'
