<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lecture 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lecture 5</h1>
<blockquote>原文：<a href="https://cs50.harvard.edu/x/notes/5/">https://cs50.harvard.edu/x/notes/5/</a></blockquote>

                    

<ul id="markdown-toc">
  <li><a href="#welcome" id="markdown-toc-welcome">Welcome!</a></li>
  <li><a href="#data-structures" id="markdown-toc-data-structures">Data Structures</a></li>
  <li><a href="#queues" id="markdown-toc-queues">Queues</a></li>
  <li><a href="#stacks" id="markdown-toc-stacks">Stacks</a></li>
  <li><a href="#jack-learns-the-facts" id="markdown-toc-jack-learns-the-facts">Jack Learns the Facts</a></li>
  <li><a href="#resizing-arrays" id="markdown-toc-resizing-arrays">Resizing Arrays</a></li>
  <li><a href="#arrays" id="markdown-toc-arrays">Arrays</a></li>
  <li><a href="#linked-lists" id="markdown-toc-linked-lists">Linked Lists</a></li>
  <li><a href="#trees" id="markdown-toc-trees">Trees</a></li>
  <li><a href="#dictionaries" id="markdown-toc-dictionaries">Dictionaries</a></li>
  <li><a href="#hashing-and-hash-tables" id="markdown-toc-hashing-and-hash-tables">Hashing and Hash Tables</a></li>
  <li><a href="#tries" id="markdown-toc-tries">Tries</a></li>
  <li><a href="#summing-up" id="markdown-toc-summing-up">Summing Up</a></li>
</ul>

<h2 id="welcome">Welcome!</h2>

<ul>
  <li data-marker="*">All the prior weeks have presented you with the fundamental building blocks of programming.</li>
  <li data-marker="*">All you have learned in C will enable you to implement these building blocks in higher-level programming languages such as Python.</li>
  <li data-marker="*">Each week, concepts have become more and more challenging, like a hill becoming more and more steep. This week, the challenge evens off as we explore data structures.</li>
  <li data-marker="*">To date, you have learned about how an array can organize data in memory.</li>
  <li data-marker="*">Today, we are going to talk about organizing data in memory and design possibilities that emerge from your growing knowledge.</li>
</ul>

<h2 id="data-structures">Data Structures</h2>

<ul>
  <li data-marker="*"><em>Data structures</em> essentially are forms of organization in memory.</li>
  <li data-marker="*">There are many ways to organize data in memory.</li>
  <li data-marker="*"><em>Abstract data types</em> are those that we can conceptually imagine. When learning about computer science, it’s often useful to begin with these conceptual data structures. Learning these will make it easier later to understand how to implement more concrete data structures.</li>
</ul>

<h2 id="queues">Queues</h2>

<ul>
  <li data-marker="*"><em>Queues</em> are one form of abstract data structure.</li>
  <li data-marker="*">Queues have specific properties. Namely, they are <em>FIFO</em> or “first in first out.” You can imagine yourself in a line for a ride at an amusement park. The first person in the line gets to go on the ride first. The last person gets to go on the ride last.</li>
  <li data-marker="*">Queues have specific actions associated with them. For example, an item can be <em>enqueued</em>; that is, the item can join the line or queue. Further, an item can be <em>dequeued</em> or leave the queue once it reaches the front of the line.</li>
  <li data-marker="*">
    <p>In code, you can imagine a queue as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">person</span> <span class="n">people</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">queue</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Notice that an array called people is of type <code class="language-plaintext highlighter-rouge">person</code>. The <code class="language-plaintext highlighter-rouge">CAPACITY</code> is how high the stack could be. The integer <code class="language-plaintext highlighter-rouge">size</code> is how full the queue actually is, regardless of how much it <em>can</em> hold.</p>
  </li>
</ul>

<h2 id="stacks">Stacks</h2>

<ul>
  <li data-marker="*">Queues contrast a <em>stack</em>. Fundamentally, the properties of a stack are different than those of a queue. Specifically, it is <em>LIFO</em> or “last in first out.” Just like stacking trays in a dining hall, a tray that is placed in a stack last is the first that may be picked up.</li>
  <li data-marker="*">Stacks have specific actions associated with them. For example, <em>push</em> places something on top of a stack. <em>Pop</em> is removing something from the top of the stack.</li>
  <li data-marker="*">
    <p>In code, you might imagine a stack as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">person</span> <span class="n">people</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">stack</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Notice that an array called people is of type <code class="language-plaintext highlighter-rouge">person</code>. The <code class="language-plaintext highlighter-rouge">CAPACITY</code> is how high the stack could be. The integer <code class="language-plaintext highlighter-rouge">size</code> is how full the stack actually is, regardless of how much it <em>could</em> hold. Notice that this code is the same as the code from the queue.</p>
  </li>
  <li data-marker="*">You might imagine that the above code has a limitation. Since the capacity of the array is always predetermined in this code. Therefore, the stack may always be oversized. You might imagine only using one place in the stack out of 5000.</li>
  <li data-marker="*">It would be nice for our stack to be dynamic – able to grow as items are added to it.</li>
</ul>

<h2 id="jack-learns-the-facts">Jack Learns the Facts</h2>

<ul>
  <li data-marker="*">We watched a video called <a href="https://www.youtube.com/watch?v=ItAG3s6KIEI">Jack Learns the Facts</a> by Professor Shannon Duvall of Elon University.</li>
</ul>

<h2 id="resizing-arrays">Resizing Arrays</h2>

<ul>
  <li data-marker="*">Rewinding to Week 2, we introduced you to your first data structure.</li>
  <li data-marker="*">An array is a block of contiguous memory.</li>
  <li data-marker="*">
    <p>You might imagine an array as follows:</p>

    <p><img src="../Images/d34bcecbdc52271932744b2f38e3e0f7.png" alt="three boxes with 1 2 3" title="array" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide019.png"/></p>
  </li>
  <li data-marker="*">
    <p>In memory, there are other values being stored by other programs, functions, and variables. Many of these may be unused garbage values that were utilized at one point but are available now for use.</p>

    <p><img src="../Images/04c9648958e03e6f1c3c581b0f374622.png" alt="three boxes with 1 2 3 among lots of other memory elements" title="array inside memory" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide022.png"/></p>
  </li>
  <li data-marker="*">
    <p>Imagine you wanted to store a fourth value <code class="language-plaintext highlighter-rouge">4</code> in our array. What would be needed is to allocate a new area of memory and move the old array to a new one? Initially, this new area of memory would be populated with garbage values.</p>

    <p><img src="../Images/761276944f2e9967835141ff0848123e.png" alt="Three boxes with 1 2 3 above four boxes with garbage values" title="two arrays with garbage values" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide025.png"/></p>
  </li>
  <li data-marker="*">
    <p>As values are added to this new area of memory, old garbage values would be overwritten.</p>

    <p><img src="../Images/548ba88fa2d99885a541c50521a62f70.png" alt="Three boxes with 1 2 3 above four boxes with 1 2 3 and a garbage value" title="two arrays with garbage value" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide026.png"/></p>
  </li>
  <li data-marker="*">
    <p>Eventually, all old garbage values would be overwritten with our new data.</p>

    <p><img src="../Images/ea2d1c42c57d7b834229dd9609b6cdab.png" alt="Three boxes with 1 2 3 above four boxes with 1 2 3 4" title="two arrays with garbage value" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide027.png"/></p>
  </li>
  <li data-marker="*">One of the drawbacks of this approach is that it’s bad design: Every time we add a number, we have to copy the array item by item.</li>
</ul>

<h2 id="arrays">Arrays</h2>

<ul>
  <li data-marker="*">Wouldn’t it be nice if we were able to put the <code class="language-plaintext highlighter-rouge">4</code> somewhere else in memory? By definition, this would no longer be an array because <code class="language-plaintext highlighter-rouge">4</code> would no longer be in contiguous memory. How could we connect different locations in memory?</li>
  <li data-marker="*">
    <p>In your terminal, type <code class="language-plaintext highlighter-rouge">code list.c</code> and write code as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implements a list of numbers with an array of fixed size</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// List of size 3</span>
    <span class="kt">int</span> <span class="n">list</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="c1">// Initialize list with numbers</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// Print list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice that the above is very much like what we learned earlier in this course. Memory is preallocated for three items.</p>
  </li>
  <li data-marker="*">
    <p>Building upon our knowledge obtained more recently, we can leverage our understanding of pointers to create a better design in this code. Modify your code as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implements a list of numbers with an array of dynamic size</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// List of size 3</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Initialize list of size 3 with numbers</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// List of size 4</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Copy list of size 3 into list of size 4</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// Add number to list of size 4</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="c1">// Free list of size 3</span>
    <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

    <span class="c1">// Remember list of size 4</span>
    <span class="n">list</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="c1">// Print list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// Free list</span>
    <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice that a list of size three integers is created. Then, three memory addresses can be assigned the values <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, and <code class="language-plaintext highlighter-rouge">3</code>. Then, a list of size four is created. Next, the list is copied from the first to the second. The value for the <code class="language-plaintext highlighter-rouge">4</code> is added to the <code class="language-plaintext highlighter-rouge">tmp</code> list. Since the block of memory that <code class="language-plaintext highlighter-rouge">list</code> points to is no longer used, it is freed using the command <code class="language-plaintext highlighter-rouge">free(list)</code>. Finally, the compiler is told to point <code class="language-plaintext highlighter-rouge">list</code> pointer now to the block of memory that <code class="language-plaintext highlighter-rouge">tmp</code> points to. The contents of <code class="language-plaintext highlighter-rouge">list</code> are printed and then freed. Further, notice the inclusion of <code class="language-plaintext highlighter-rouge">stdlib.h</code>.</p>
  </li>
  <li data-marker="*">It’s useful to think about <code class="language-plaintext highlighter-rouge">list</code> and <code class="language-plaintext highlighter-rouge">tmp</code> as both signs that point to a chunk of memory. As in the example above, <code class="language-plaintext highlighter-rouge">list</code> at one point <em>pointed</em> to an array of size 3. By the end, <code class="language-plaintext highlighter-rouge">list</code> was told to point to a chunk of memory of size 4. Technically, by the end of the above code, <code class="language-plaintext highlighter-rouge">tmp</code> and <code class="language-plaintext highlighter-rouge">list</code> both pointed to the same block of memory.</li>
  <li data-marker="*">
    <p>One way by which we can copy the array without a for loop is by using <code class="language-plaintext highlighter-rouge">realloc</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implements a list of numbers with an array of dynamic size using realloc</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// List of size 3</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Initialize list of size 3 with numbers</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// Resize list to be of size 4</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="c1">// Add number to list</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="c1">// Print list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// Free list</span>
    <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice that the list is reallocated to a new array via <code class="language-plaintext highlighter-rouge">realloc</code>.</p>
  </li>
  <li data-marker="*">One may be tempted to allocate way more memory than required for the list, such as 30 items instead of the required 3 or 4. However, this is bad design as it taxes system resources when they are not potentially needed. Further, there is little guarantee that memory for more than 30 items will be needed eventually.</li>
</ul>

<h2 id="linked-lists">Linked Lists</h2>

<ul>
  <li data-marker="*">In recent weeks, you have learned about three useful primitives. A <code class="language-plaintext highlighter-rouge">struct</code> is a data type that you can define yourself. A <code class="language-plaintext highlighter-rouge">.</code> in <em>dot notation</em> allows you to access variables inside that structure. The <code class="language-plaintext highlighter-rouge">*</code> operator is used to declare a pointer or dereference a variable.</li>
  <li data-marker="*">Today, you are introduced to the <code class="language-plaintext highlighter-rouge">-&gt;</code> operator. It is an arrow. This operator goes to an address and looks inside a structure.</li>
  <li data-marker="*">A <em>linked list</em> is one of the most powerful data structures within C. A linked list allows you to include values that are located in varying areas of memory. Further, they allow you to dynamically grow and shrink the list as you desire.</li>
  <li data-marker="*">
    <p>You might imagine three values stored in three different areas of memory as follows:</p>

    <p><img src="../Images/778e15e3a97408dde5c9183912b0a0a4.png" alt="Three boxes with 1 2 3 in separate areas of memory" title="three values in memory" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide036.png"/></p>
  </li>
  <li data-marker="*">How could one stitch together these values in a list?</li>
  <li data-marker="*">
    <p>We could imagine the data pictured above as follows:</p>

    <p><img src="../Images/b07c28da45ed734f9469681811b1a789.png" alt="Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached" title="three values in memory" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide037.png"/></p>
  </li>
  <li data-marker="*">
    <p>We could utilize more memory to keep track of where the next item using a pointer.</p>

    <p><img src="../Images/22dd31970ae9929d55e15d92de091c85.png" alt="Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached where memory addresses are in those attached boxes" title="three values in memory" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide041.png"/></p>

    <p>Notice that NULL is utilized to indicate that nothing else is <em>next</em> in the list.</p>
  </li>
  <li data-marker="*">
    <p>By convention, we would keep one more element in memory, a pointer, that keeps track of the first item in the list, called the <em>head</em> of the list.</p>

    <p><img src="../Images/5c91f35f98339346e7e797670973617c.png" alt="Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached where memory addresses are in those attached boxes now with a final box with the memory address of the first box" title="three values in memory with pointer" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide042.png"/></p>
  </li>
  <li data-marker="*">
    <p>Abstracting away the memory addresses, the list would appear as follows:</p>

    <p><img src="../Images/de5d348bca1d7fe280064c56108281f8.png" alt="Three boxes with in separate areas of memory with smaller boxes with a final box where the one box points to another and another until the end of the boxes" title="three values in memory with pointer" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide043.png"/></p>
  </li>
  <li data-marker="*">
    <p>These boxes are called <em>nodes</em>. A <em>node</em> contains both an <em>item</em> and a pointer called <em>next</em>. In code, you can imagine a node as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">node</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Notice that the item contained within this node is an integer called <code class="language-plaintext highlighter-rouge">number</code>. Second, a pointer to a node called <code class="language-plaintext highlighter-rouge">next</code> is included, which will point to another node somewhere in memory.</p>
  </li>
  <li data-marker="*">
    <p>We can recreate <code class="language-plaintext highlighter-rouge">list.c</code> to utilize a linked list:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Start to build a linked list by prepending nodes</span>

<span class="cp">#include</span> <span class="cpf">&lt;cs50.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">node</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Memory for numbers</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Build list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Allocate node for number</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// Prepend node to list</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>First, a <code class="language-plaintext highlighter-rouge">node</code> is defined as a <code class="language-plaintext highlighter-rouge">struct</code>. For each element of the list, memory for a <code class="language-plaintext highlighter-rouge">node</code> is allocated via <code class="language-plaintext highlighter-rouge">malloc</code> to the size of a node. <code class="language-plaintext highlighter-rouge">n-&gt;number</code> (or <code class="language-plaintext highlighter-rouge">n</code>’s number field) is assigned an integer. <code class="language-plaintext highlighter-rouge">n-&gt;next</code> (or <code class="language-plaintext highlighter-rouge">n</code>’s next field) is assigned <code class="language-plaintext highlighter-rouge">null</code>. Then, the node is placed at the start of the list at memory location <code class="language-plaintext highlighter-rouge">list</code>.</p>
  </li>
  <li data-marker="*">
    <p>Conceptually, we can imagine the process of creating a linked list. First, <code class="language-plaintext highlighter-rouge">node *list</code> is declared, but it is of a garbage value.</p>

    <p><img src="../Images/b6d39804d8ad476803c5424ab7a67ced.png" alt="One garbage value" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide055.png"/></p>
  </li>
  <li data-marker="*">
    <p>Next, a node called <code class="language-plaintext highlighter-rouge">n</code> is allocated in memory.</p>

    <p><img src="../Images/cc8488193d41cb930a2c7d468ad964e8.png" alt="One garbage value called n with another pointer called list" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide059.png"/></p>
  </li>
  <li data-marker="*">
    <p>Next, the <code class="language-plaintext highlighter-rouge">number</code> of node is assigned the value <code class="language-plaintext highlighter-rouge">1</code>.</p>

    <p><img src="../Images/d114de09528bf567bf1e0109531aabeb.png" alt="n pointing to a node with 1 as the number and garbage value as the next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide064.png"/></p>
  </li>
  <li data-marker="*">
    <p>Next, the node’s <code class="language-plaintext highlighter-rouge">next</code> field is assigned <code class="language-plaintext highlighter-rouge">NULL</code>.</p>

    <p><img src="../Images/5d8e17eee341c7731473bb6b1c0b1ffd.png" alt="n pointing to a node with 1 as the number and null as the value of next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide066.png"/></p>
  </li>
  <li data-marker="*">
    <p>Next, <code class="language-plaintext highlighter-rouge">list</code> is pointed at the memory location to where <code class="language-plaintext highlighter-rouge">n</code> points. <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">list</code> now point to the same place.</p>

    <p><img src="../Images/7fec0d8902e51dee56555a8198859bf7.png" alt="n and list both pointing to a node with 1 as the number and null as the value of next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide068.png"/></p>
  </li>
  <li data-marker="*">
    <p>A new node is then created. Both the <code class="language-plaintext highlighter-rouge">number</code> and <code class="language-plaintext highlighter-rouge">next</code> field are filled with garbage values.</p>

    <p><img src="../Images/1ca5619a4434079950fcb951de63523b.png" alt="list pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with garbage values" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide073.png"/></p>
  </li>
  <li data-marker="*">
    <p>The <code class="language-plaintext highlighter-rouge">number</code> value of <code class="language-plaintext highlighter-rouge">n</code>’s node (the new node) is updated to <code class="language-plaintext highlighter-rouge">2</code>.</p>

    <p><img src="../Images/68832f3dba6377d090d013ff705434ef.png" alt="list pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with 2 as the number and garbage as the next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide075.png"/></p>
  </li>
  <li data-marker="*">
    <p>Also, the <code class="language-plaintext highlighter-rouge">next</code> field is updated as well.</p>

    <p><img src="../Images/fb7f5bd791741fafeaa38e51b56cc9b9.png" alt="list pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with 2 as the number and null as the next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide077.png"/></p>
  </li>
  <li data-marker="*">
    <p>Most importantly, we do not want to lose our connection to any of these nodes lest they be lost forever. Accordingly, <code class="language-plaintext highlighter-rouge">n</code>’s <code class="language-plaintext highlighter-rouge">next</code> field is pointed to the same memory location as <code class="language-plaintext highlighter-rouge">list</code>.</p>

    <p><img src="../Images/0dc8276fd04b08b3e1265e55c003f870.png" alt="list pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with 2 as the number and null as the next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide084.png"/></p>
  </li>
  <li data-marker="*">
    <p>Finally, <code class="language-plaintext highlighter-rouge">list</code> is updated to point at <code class="language-plaintext highlighter-rouge">n</code>. We now have a linked list of two items.</p>

    <p><img src="../Images/68fba35035561d4d0a30b32d1b9af319.png" alt="list pointing to a node with 1 as the number and next pointing to a node with an n pointing the same place the node with one points to a node with 2 as the number and null as the next" title="linked list" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide086.png"/></p>
  </li>
  <li data-marker="*">Looking at our diagram of the list, we can see that the last number added is the first number that appears in the list. Accordingly, if we print the list in order, starting with the first node, the list will appear out of order.</li>
  <li data-marker="*">
    <p>We can print the list in the correct order as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Print nodes in a linked list with a while loop</span>

<span class="cp">#include</span> <span class="cpf">&lt;cs50.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">node</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Memory for numbers</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Build list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Allocate node for number</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// Prepend node to list</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Print numbers</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice that <code class="language-plaintext highlighter-rouge">node *ptr = list</code> creates a temporary variable that points at the same spot that <code class="language-plaintext highlighter-rouge">list</code> points to. The <code class="language-plaintext highlighter-rouge">while</code> prints what at the node <code class="language-plaintext highlighter-rouge">ptr</code> points to, and then updates <code class="language-plaintext highlighter-rouge">ptr</code> to point to the <code class="language-plaintext highlighter-rouge">next</code> node in the list.</p>
  </li>
  <li data-marker="*">In this example, inserting into the list is always in the order of \(O(1)\), as it only takes a very small number of steps to insert at the front of a list.</li>
  <li data-marker="*">Considering the amount of time required to search this list, it is in the order of \(O(n)\), because in the worst case the entire list must always be searched to find an item. The time complexity for adding a new element to the list will depend on where that element is added. This is illustrated in the examples below.</li>
  <li data-marker="*">Linked lists are not stored in a contiguous block of memory. They can grow as large as you wish, provided that enough system resources exist. The downside, however, is that more memory is required to keep track of the list instead of an array. For each element you must store not just the value of the element, but also a pointer to the next node. Further, linked lists cannot be indexed into like is possible in an array because we need to pass through the first \(n - 1\) elements to find the location of the \(n\)th element. Because of this, the list pictured above must be linearly searched. Binary search, therefore, is not possible in a list constructed as above.</li>
  <li data-marker="*">
    <p>Further, you could place numbers at the end of the list as illustrated in this code:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Appends numbers to a linked list</span>

<span class="cp">#include</span> <span class="cpf">&lt;cs50.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">node</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Memory for numbers</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Build list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Allocate node for number</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// If list is empty</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// This node is the whole list</span>
            <span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If list has numbers already</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Iterate over nodes in list</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// If at end of list</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// Append node</span>
                    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Print numbers</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Free memory</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice how this code <em>walks down</em> this list to find the end. When appending an element (adding to the end of the list) our code will run in \(O(n)\), as we have to go through our entire list before we can add the final element. Further, notice that a temporary variable called <code class="language-plaintext highlighter-rouge">next</code> is used to track <code class="language-plaintext highlighter-rouge">ptr-&gt;next</code>.</p>
  </li>
  <li data-marker="*">
    <p>Further, you could sort your list as items are added:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implements a sorted linked list of numbers</span>

<span class="cp">#include</span> <span class="cpf">&lt;cs50.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">node</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Memory for numbers</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Build list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Allocate node for number</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// If list is empty</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If number belongs at beginning of list</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
            <span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> 
        <span class="p">}</span>

        <span class="c1">// If number belongs later in list</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Iterate over nodes in list</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// If at end of list</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// Append node</span>
                    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// If in middle of list</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Print numbers</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Free memory</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice how this list is sorted as it is built. To insert an element in this specific order, our code will still run in \(O(n)\) for each insertion, as in the worst case we will have to look through all current elements.</p>
  </li>
  <li data-marker="*">This code may seem complicated. However, notice that with pointers and the syntax above, we can stitch data together in different places in memory.</li>
</ul>

<h2 id="trees">Trees</h2>

<ul>
  <li data-marker="*">Arrays offer contiguous memory that can be searched quickly. Arrays also offered the opportunity to engage in binary search.</li>
  <li data-marker="*">Could we combine the best of both arrays and linked lists?</li>
  <li data-marker="*"><em>Binary search trees</em> are another data structure that can be used to store data more efficiently so that it can be searched and retrieved.</li>
  <li data-marker="*">
    <p>You can imagine a sorted sequence of numbers.</p>

    <p><img src="../Images/4f4a50b0fa906dd640e7d1e2beda073d.png" alt="1 2 3 4 5 6 7 in boxes next to each other" title="tree" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide118.png"/></p>
  </li>
  <li data-marker="*">
    <p>Imagine then that the center value becomes the top of a tree. Those that are less than this value are placed to the left. Those values that are more than this value are to the right.</p>

    <p><img src="../Images/7ad7e3efe6b11ff81034b24b6f752802.png" alt="1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are below that and 1 2 6 7 are below those" title="tree" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide119.png"/></p>
  </li>
  <li data-marker="*">
    <p>Pointers can then be used to point to the correct location of each area of memory such that each of these nodes can be connected.</p>

    <p><img src="../Images/6879c95a0b436bd34b2f7c1748ca5ad8.png" alt="1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are below that and 1 2 6 7 are below those arrows connect them in a tree formation" title="tree" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide120.png"/></p>
  </li>
  <li data-marker="*">
    <p>In code, this can be implemented as follows.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implements a list of numbers as a binary search tree</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// Represents a node</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">node</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">free_tree</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Tree of size 0</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Add number to list</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// Add number to list</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// Add number to list</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// Print tree</span>
    <span class="n">print_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>

    <span class="c1">// Free tree</span>
    <span class="n">free_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_tree</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free_tree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">free_tree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">print_tree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
    <span class="n">print_tree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Notice this search function begins by going to the location of <code class="language-plaintext highlighter-rouge">tree</code>. Then, it uses recursion to search for <code class="language-plaintext highlighter-rouge">number</code>. The <code class="language-plaintext highlighter-rouge">free_tree</code> function recursively frees the tree. <code class="language-plaintext highlighter-rouge">print_tree</code> recursively prints the tree.</p>
  </li>
  <li data-marker="*">A tree like the above offers dynamism that an array does not offer. It can grow and shrink as we wish.</li>
  <li data-marker="*">Further, this structure offers a search time of \(O(log n)\) when the tree is balanced.</li>
</ul>

<h2 id="dictionaries">Dictionaries</h2>

<ul>
  <li data-marker="*"><em>Dictionaries</em> are another data structure.</li>
  <li data-marker="*">Dictionaries, like actual book-form dictionaries that have a word and a definition, have a <em>key</em> and a <em>value</em>.</li>
  <li data-marker="*">
    <p>The <em>holy grail</em> of algorithmic time complexity is \(O(1)\) or <em>constant time</em>. That is, the ultimate is for access to be instantaneous.</p>

    <p><img src="../Images/be842bae9176b8c123def3e311e235e9.png" alt="a graph of various time complexities where O of log n is second best and O of 1 is best" title="time complexity" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide151.png"/></p>
  </li>
  <li data-marker="*">Dictionaries can offer this speed of access through hashing.</li>
</ul>

<h2 id="hashing-and-hash-tables">Hashing and Hash Tables</h2>

<ul>
  <li data-marker="*"><em>Hashing</em> is the idea of taking a value and being able to output a value that becomes a shortcut to it later.</li>
  <li data-marker="*">For example, hashing <em>apple</em> may hash as a value of <code class="language-plaintext highlighter-rouge">1</code>, and <em>berry</em> may be hashed as <code class="language-plaintext highlighter-rouge">2</code>. Therefore, finding <em>apple</em> is as easy as asking the <em>hash</em> algorithm where <em>apple</em> is stored. While not ideal in terms of design, ultimately, putting all <em>a</em>’s in one bucket and <em>b</em>’s in another, this concept of <em>bucketizing</em> hashed values illustrates how you can use this concept: a hashed value can be used to shortcut finding such a value.</li>
  <li data-marker="*">A <em>hash function</em> is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.</li>
  <li data-marker="*">A <em>hash table</em> is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an <em>array</em> of <em>pointers</em> to <em>node</em>s.</li>
  <li data-marker="*">
    <p>A hash table could be imagined as follows:</p>

    <p><img src="../Images/fab363539963a53f25e01cb4eeb1b422.png" alt="a vertical column of 26 boxes one for each letter of the alphabet" title="alphabet" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide157.png"/></p>

    <p>Notice that this is an array that is assigned each value of the alphabet.</p>
  </li>
  <li data-marker="*">
    <p>Then, at each location of the array, a linked list is used to track each value being stored there:</p>

    <p><img src="../Images/3b7dd601e46bc05746e82d7ffc9b5b61.png" alt="a vertical column of 26 boxes one for each letter of the alphabet with various names from the mario universe emerging to the right luigi is with l and mario is with m" title="alphabet" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide169.png"/></p>
  </li>
  <li data-marker="*"><em>Collisions</em> are when you add values to the hash table, and something already exists at the hashed location. In the above, collisions are simply appended to the end of the list.</li>
  <li data-marker="*">
    <p>Collisions can be reduced by better programming your hash table and hash algorithm. You can imagine an improvement upon the above as follows:</p>

    <p><img src="../Images/e51a60f34aa7b92a1cc29b25c0a7f981.png" alt="a vertical column of various boxes arranged by L A K and L I N with Lakitu emerging from L A K and link emerging from L I N" title="alphabet" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide184.png"/></p>
  </li>
  <li data-marker="*">
    <p>Consider the following example of a hash algorithm:</p>

    <p><img src="../Images/0696a8d8e7d78370dcbaf5c00100a9d1.png" alt="luigi being given to a hash algorithm outputting 11" title="hashing" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide173.png"/></p>
  </li>
  <li data-marker="*">
    <p>This could be implemented in code as follows:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">toupper</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>    </div>
    <p>Notice how the hash function returns the value of <code class="language-plaintext highlighter-rouge">toupper(word[0]) - 'A'</code>.</p>
  </li>
  <li data-marker="*">You, as the programmer, have to make a decision about the advantages of using more memory to have a large hash table and potentially reducing search time or using less memory and potentially increasing search time.</li>
  <li data-marker="*">This structure offers a search time of \(O(n)\).</li>
</ul>

<h2 id="tries">Tries</h2>

<ul>
  <li data-marker="*"><em>Tries</em> are another form of data structure. Tries are trees of arrays.</li>
  <li data-marker="*"><em>Tries</em> are always searchable in constant time.</li>
  <li data-marker="*">One downside to <em>Tries</em> is that they tend to take up a large amount of memory. Notice that we need \(26 \times 4 = 104\) <code class="language-plaintext highlighter-rouge">node</code>s just to store <em>Toad</em>!</li>
  <li data-marker="*">
    <p><em>Toad</em> would be stored as follows:</p>

    <p><img src="../Images/dde5f80eef85bf6c2a0effa25843996d.png" alt="toad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on " title="tries" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide207.png"/></p>
  </li>
  <li data-marker="*">
    <p><em>Tom</em> would then be stored as follows:</p>

    <p><img src="../Images/d87c3fc3a156b4abe5e23b86af845b89.png" alt="toad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on and tom being spelled similarly where toad and tom share a two common letters T and O" title="tries" data-original-src="https://cs50.harvard.edu/x/notes/5/cs50Week5Slide209.png"/></p>
  </li>
  <li data-marker="*">This structure offers a search time of \(O(1)\).</li>
  <li data-marker="*">The downside of this structure is how many resources are required to use it.</li>
</ul>

<h2 id="summing-up">Summing Up</h2>
<p>In this lesson, you learned about using pointers to build new data structures. Specifically, we delved into…</p>

<ul>
  <li data-marker="*">Data structures</li>
  <li data-marker="*">Stacks and queues</li>
  <li data-marker="*">Resizing arrays</li>
  <li data-marker="*">Linked lists</li>
  <li data-marker="*">Dictionaries</li>
  <li data-marker="*">Tries</li>
</ul>

<p>See you next time!</p>


                    
</body>
</html>