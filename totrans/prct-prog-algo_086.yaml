- en: 1.3   Bags, Queues, and Stacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3   袋子、队列和栈
- en: 原文：[https://algs4.cs.princeton.edu/13stacks](https://algs4.cs.princeton.edu/13stacks)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/13stacks](https://algs4.cs.princeton.edu/13stacks)
- en: Several fundamental data types involve collections of objects. Specifically,
    the set of values is a collection of objects, and the operations revolve around
    adding, removing, or examining objects in the collection. In this section, we
    consider three such data types, known as the bag, the queue, and the stack. They
    differ in the specification of which object is to be removed or examined next.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几种基本数据类型涉及对象的集合。具体来说，值的集合是对象的集合，操作围绕向集合中添加、删除或检查对象展开。在本节中，我们考虑了三种这样的数据类型，称为袋子、队列和栈。它们在规定下一个要移除或检查的对象方面有所不同。
- en: APIs.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API。
- en: 'We define the APIs for bags, queues, and stacks. Beyond the basics, these APIs
    reflect two Java features: generics and iterable collections.![APIs for bag, queue,
    and stack](../Images/5460bd4efefb1f62d5c2069980397bbc.png)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为袋子、队列和栈定义了 API。除了基础知识外，这些 API 还反映了两个 Java 特性：泛型和可迭代集合。![袋子、队列和栈的 API](../Images/5460bd4efefb1f62d5c2069980397bbc.png)
- en: '*Generics.* An essential characteristic of collection ADTs is that we should
    be able to use them for any type of data. A specific Java mechanism known as *generics*
    enables this capability. The notation `<Item>` after the class name in each of
    our APIs defines the name `Item` as a *type parameter*, a symbolic placeholder
    for some concrete type to be used by the client. You can read `Stack<Item>` as
    "stack of items." For example, you can write code such as'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泛型.* 集合 ADT 的一个重要特征是我们应该能够将它们用于任何类型的数据。一种名为 *泛型* 的特定 Java 机制实现了这一功能。在我们的每个
    API 中类名后面的 `<Item>` 表示将 `Item` 命名为 *类型参数*，一个用于客户端的具体类型的符号占位符。你可以将 `Stack<Item>`
    理解为“项目的堆栈”。例如，你可以编写如下代码'
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: to use a stack for `String` objects.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于 `String` 对象的堆栈。
- en: '*Autoboxing.* Type parameters have to be instantiated as reference types, so
    Java automatically converts between a primitive type and its corresponding wrapper
    type in assignments, method arguments, and arithmetic/logic expressions. This
    conversion enables us to use generics with primitive types, as in the following
    code:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动装箱.* 类型参数必须实例化为引用类型，因此 Java 在赋值、方法参数和算术/逻辑表达式中自动在原始类型和其对应的包装类型之间转换。这种转换使我们能够在原始类型中使用泛型，就像以下代码中所示：'
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Automatically casting a primitive type to a wrapper type is known as *autoboxing*,
    and automatically casting a wrapper type to a primitive type is known as *unboxing*.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将基本类型自动转换为包装类型称为 *自动装箱*，将包装类型自动转换为基本类型称为 *拆箱*。
- en: '*Iterable collections.* For many applications, the client''s requirement is
    just to process each of the items in some way, or to *iterate* through the items
    in the collection. Java''s *foreach* statement supports this paradigm. For example,
    suppose that `collection` is a `Queue<Transaction>`. Then, if the collection is
    iterable, the client can print a transaction list with a single statement:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可迭代集合.* 对于许多应用程序，客户端的要求只是以某种方式处理每个项目，或者在集合中 *迭代*。Java 的 *foreach* 语句支持这种范例。例如，假设
    `collection` 是一个 `Queue<Transaction>`。那么，如果集合是可迭代的，客户端可以通过一条语句打印交易列表：'
- en: '[PRE2]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Bags.* A *bag* is a collection where removing items is not supported—its purpose
    is to provide clients with the ability to collect items and then to iterate through
    the collected items. [Stats.java](Stats.java.html) is a bag client that reads
    a sequence of real numbers from standard input and prints out their mean and standard
    deviation.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*袋子.* 一个 *袋子* 是一个不支持移除项目的集合——它的目的是为客户提供收集项目并遍历收集项目的能力。[Stats.java](Stats.java.html)
    是一个袋子客户端，从标准输入读取一系列实数，并打印出它们的平均值和标准差。'
- en: '*FIFO queues.* A *FIFO queue* is a collection that is based on the *first-in-first-out*
    (FIFO) policy. The policy of doing tasks in the same order that they arrive is
    one that we encounter frequently in everyday life: from people waiting in line
    at a theater, to cars waiting in line at a toll booth, to tasks waiting to be
    serviced by an application on your computer.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FIFO 队列.* 一个 *FIFO 队列* 是基于 *先进先出*（FIFO）策略的集合。按照任务到达的顺序执行任务的策略在我们日常生活中经常遇到：从在剧院排队等候的人们，到在收费站排队等候的汽车，再到等待计算机应用程序服务的任务。'
- en: '*Pushdown stack.* A *pushdown stack* is a collection that is based on the *last-in-first-out*
    (LIFO) policy. When you click a hyperlink, your browser displays the new page
    (and pushes onto a stack). You can keep clicking on hyperlinks to visit new pages,
    but you can always revisit the previous page by clicking the back button (popping
    it from the stack). [Reverse.java](Reverse.java.html) is a stack client that reads
    a sequence of integers from standard input and prints them in reverse order.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推入栈.* 一个 *推入栈* 是基于 *后进先出*（LIFO）策略的集合。当你点击超链接时，浏览器会显示新页面（并将其推入栈）。你可以继续点击超链接访问新页面，但总是可以通过点击返回按钮重新访问上一页（从栈中弹出）。[Reverse.java](Reverse.java.html)
    是一个堆栈客户端，从标准输入读取一系列整数，并以相反顺序打印它们。'
- en: '*Arithmetic expression evaluation.* [Evaluate.java](Evaluate.java.html) is
    a stack client that evaluates fully parenthesized arithmetic expressions. It uses
    Dijkstra''s 2-stack algorithm:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算术表达式求值.* [Evaluate.java](Evaluate.java.html) 是一个堆栈客户端，用于评估完全括号化的算术表达式。它使用
    Dijkstra 的 2 栈算法：'
- en: Push operands onto the operand stack.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作数推送到操作数栈上。
- en: Push operators onto the operator stack.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将运算符推送到运算符栈上。
- en: Ignore left parentheses.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略左括号。
- en: On encountering a right parenthesis, pop an operator, pop the requisite number
    of operands, and push onto the operand stack the result of applying that operator
    to those operands.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将将该运算符应用于这些操作数的结果推送到操作数栈上。
- en: This code is a simple example of an *interpreter*.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码是一个 *解释器* 的简单示例。
- en: Array and resizing array implementations of collections.
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和调整大小数组实现集合。
- en: '*Fixed-capacity stack of strings.* [FixedCapacityStackOfString.java](FixedCapacityStackOfStrings.java.html)
    implements a fixed-capacity stack of strings using an array.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*固定容量的字符串栈。*[FixedCapacityStackOfString.java](FixedCapacityStackOfStrings.java.html)
    使用数组实现了一个固定容量的字符串栈。'
- en: '*Fixed-capacity generic stack.* [FixedCapacityStack.java](FixedCapacityStack.java.html)
    implements a generic fixed-capacity stack.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*固定容量的通用栈。*[FixedCapacityStack.java](FixedCapacityStack.java.html) 实现了一个通用的固定容量栈。'
- en: '*Array resizing stack.* [ResizingArrayStack.java](ResizingArrayStack.java.html)
    implements a generic stack using a *resizing array*. With a resizing array, we
    dynamically adjust the size of the array so that it is both sufficiently large
    to hold all of the items and not so large as to waste an excessive amount of space.
    We *double* the size of the array in `push()` if it is full; we *halve* the size
    of the array in `pop()` if it is less than one-quarter full.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组调整大小栈。*[ResizingArrayStack.java](ResizingArrayStack.java.html) 使用*调整大小数组*实现了一个通用栈。使用调整大小数组，我们动态调整数组的大小，使其足够大以容纳所有项目，同时又不会浪费过多空间。如果数组已满，在`push()`中我们将数组大小*加倍*；如果数组少于四分之一满，在`pop()`中我们将数组大小*减半*。'
- en: '*Array resizing queue.* [ResizingArrayQueue.java](ResizingArrayQueue.java.html)
    implements the queue API with a resizing array.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组调整大小队列。*[调整大小数组队列.java](ResizingArrayQueue.java.html) 使用调整大小数组实现队列API。'
- en: Linked lists.
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表。
- en: A *linked list* is a recursive data structure that is either empty (*null*)
    or a reference to a *node* having a generic item and a reference to a linked list.
    To implement a linked list, we start with a *nested class* that defines the node
    abstraction
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*链表* 是一种递归数据结构，要么为空（*null*），要么是指向具有通用项和指向链表的节点的引用。要实现链表，我们从定义节点抽象的*嵌套类*开始。'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Building a linked list.* To build a linked list that contains the items `to`,
    `be`, and `or`, we create a `Node` for each item, set the item field in each of
    the nodes to the desired value, and set the `next` fields to build the linked
    list.![building a linked list](../Images/7a9bacafeccb1c97eed7cbc61bbaeab7.png)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建链表。* 要构建一个包含项目`to`、`be`和`or`的链表，我们为每个项目创建一个`Node`，将每个节点中的项目字段设置为所需值，并设置`next`字段以构建链表。![构建链表](../Images/7a9bacafeccb1c97eed7cbc61bbaeab7.png)'
- en: '*Insert at the beginning.* The easiest place to insert a new node in a linked
    list is at the beginning.![inserting a new node at the beginning of a linked list](../Images/72cf0f3491801c4b270d0c93c67ba0d0.png)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在开头插入。* 在链表中插入新节点的最简单位置是在开头。![在链表开头插入新节点](../Images/72cf0f3491801c4b270d0c93c67ba0d0.png)'
- en: '*Remove from the beginning.* Removing the first node in a linked list is also
    easy.![removing the first node in a linked list](../Images/1bd57fe595536664f5f220f60f4b892c.png)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从开头删除。* 删除链表中的第一个节点也很容易。![删除链表中的第一个节点](../Images/1bd57fe595536664f5f220f60f4b892c.png)'
- en: '*Insert at the end.* To insert a node at the end of a linked list, we maintain
    a link to the last node in the list.![inserting a node at the end of a linked
    list](../Images/a8eb4193b8059c1489ef1bc1f7c16e0a.png)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在末尾插入。* 要在链表的末尾插入一个节点，我们需要维护一个指向链表中最后一个节点的链接。![在链表末尾插入节点](../Images/a8eb4193b8059c1489ef1bc1f7c16e0a.png)'
- en: '*Traversal.* The following is the idiom for traversing the nodes in a linked
    list.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遍历。* 以下是遍历链表中节点的习惯用法。'
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Linked-list implementations of collections.
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的链表实现。
- en: '*Linked list implementation of a stack.* [Stack.java](Stack.java.html) implements
    a generic stack using a linked list. It maintains the stack as a linked list,
    with the top of the stack at the beginning, referenced by an instance variable
    `first`. To `push()` an item, we add it to the beginning of the list; to `pop()`
    an item, we remove it from the beginning of the list.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*栈的链表实现。*[Stack.java](Stack.java.html) 使用链表实现了一个通用栈。它将栈作为一个链表维护，栈的顶部在开头，由实例变量`first`引用。要`push()`一个项目，我们将其添加到列表的开头；要`pop()`一个项目，我们将其从列表的开头移除。'
- en: '*Linked list implementation of a queue.* Program [Queue.java](Queue.java.html)
    implements a generic FIFO queue using a linked list. It maintains the queue as
    a linked list in order from least recently to most recently added items, with
    the beginning of the queue referenced by an instance variable `first` and the
    end of the queue referenced by an instance variable `last`. To `enqueue()` an
    item, we add it to the end of the list; to `dequeue()` an item, we remove it from
    the beginning of the list.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*队列的链表实现。* 程序[Queue.java](Queue.java.html)使用链表实现了一个通用FIFO队列。它将队列作为一个链表维护，从最近添加的项目到最近添加的项目的顺序，队列的开始由实例变量`first`引用，队列的结束由实例变量`last`引用。要`enqueue()`一个项目，我们将其添加到列表的末尾；要`dequeue()`一个项目，我们将其从列表的开头移除。'
- en: '*Linked list implementation of a bag.* Program [Bag.java](Bag.java.html) implements
    a generic bag using a linked list. The implementation is the same as [Stack.java](Stack.java.html)
    except for changing the name of `push()` to `add()` and removing `pop()`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*背包的链表实现。* 程序[Bag.java](Bag.java.html)使用链表实现了一个通用背包。该实现与[Stack.java](Stack.java.html)相同，只是将`push()`的名称更改为`add()`并删除`pop()`。'
- en: Iteration.
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代。
- en: 'To consider the task of implementing iteration, we start with a snippet of
    client code that prints all of the items in a collection of strings, one per line:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑实现迭代的任务，我们从一个客户端代码片段开始，该代码打印字符串集合中的所有项目，每行一个：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This *foreach* statement is shorthand for the following `while` statement:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*foreach*语句是以下`while`语句的简写：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To implement iteration in a collection:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在集合中实现迭代：
- en: 'Include the following `import` statement so that our code can refer to Java''s
    [java.util.Iterator](http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html)
    interface:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含以下`import`语句，以便我们的代码可以引用Java的[java.util.Iterator](http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html)接口：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following to the class declaration, a promise to provide an `iterator()`
    method, as specified in the [java.lang.Iterable](http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html)
    interface:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下内容添加到类声明中，承诺提供一个`iterator()`方法，如[Java.lang.Iterable](http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html)接口中指定的：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement a method `iterator()` that returns an object from a class that implements
    the `Iterator` interface:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个返回实现`Iterator`接口的类的对象的方法`iterator()`：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement a nested class that implements the `Iterator` interface by including
    the methods `hasNext()`, `next()`, and `remove()`. We always use an empty method
    for the optional `remove()` method because interleaving iteration with operations
    that modify the data structure is best avoided.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个嵌套类，通过包含`hasNext()`、`next()`和`remove()`方法来实现`Iterator`接口。我们总是对可选的`remove()`方法使用空方法，因为最好避免在迭代中插入修改数据结构的操作。
- en: The nested class `LinkedIterator` in [Bag.java](Bag.java.html) illustrates how
    to implement a class that implements the `Iterator` interface when the underlying
    data structure is a linked list.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当底层数据结构是链表时，[Bag.java](Bag.java.html)中的嵌套类`LinkedIterator`说明了如何实现一个实现`Iterator`接口的类。
- en: The nested class `ArrayIterator` in [ResizingArrayBag.java](ResizingArrayBag.java.html)
    does the same when the underlying data structure is an array.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当底层数据结构是数组时，[ResizingArrayBag.java](ResizingArrayBag.java.html)中的嵌套类`ArrayIterator`也是如此。
- en: Autoboxing Q + A
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动装箱问题 + 回答
- en: '**Q.** How does autoboxing handle the following code fragment?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 自动装箱如何处理以下代码片段？'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**A.** It results in a run-time error. Primitive type can store every value
    of their corresponding wrapper type except `null`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这导致运行时错误。原始类型可以存储其对应包装类型的每个值，除了`null`。'
- en: '**Q.** Why does the first group of statements print `true`, but the second
    `false`?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么第一组语句打印`true`，但第二组打印`false`？'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**A.** The second prints `false` because `b1` and `b2` are references to different
    Integer objects. The first and third code fragments rely on autoboxing. Surprisingly
    the first prints true because values between -128 and 127 appear to refer to the
    same immutable Integer objects (Java''s implementation of `valueOf()` retrieves
    a cached values if the integer is between -128 and 127), while Java constructs
    new objects for each integer outside this range.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 第二个打印`false`，因为`b1`和`b2`是指向不同Integer对象的引用。第一个和第三个代码片段依赖于自动装箱。令人惊讶的是，第一个打印true，因为在-128和127之间的值似乎指向相同的不可变Integer对象（Java的`valueOf()`实现在整数在此范围内时检索缓存值），而Java为此范围外的每个整数构造��对象。'
- en: Here is another [Autoboxing.java](Autoboxing.java.html) anomaly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个[Autoboxing.java](Autoboxing.java.html)的异常。
- en: Generics Q + A
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 泛型问题 + 回答
- en: '**Q.** Are generics solely for auto-casting?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 泛型仅用于自动转换吗？'
- en: '**A.** No, but we will use them only for "concrete parameterized types", where
    each data type is parameterized by a single type. The primary benefit is to discover
    type-mismatch errors at compile time instead of run time. There are other more
    general (and more complicated) uses of generics, including wildcards. This generality
    is useful for handling subtypes and inheritance. For more information, see this
    [Generics FAQ](http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html)
    and this [Java generics tutorial](http://docs.oracle.com/javase/tutorial/java/generics).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不是，但我们只会用于“具体参数化类型”，其中每种数据类型都由单个类型参数化。主要好处是在编译时而不是运行时发现类型不匹配错误。泛型还有其他更一般（更复杂）的用途，包括通配符。这种一般性对于处理子类型和继承很有用。有关更多信息，请参阅这个[泛型常见问题解答](http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html)和这个[Java泛型教程](http://docs.oracle.com/javase/tutorial/java/generics)。'
- en: '**Q.** Can concrete parameterized types be used in the same way as normal types?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 具体参数化类型可以像普通类型一样使用吗？'
- en: '**A.** Yes, with a few exceptions (array creation, exception handling, with
    `instanceof`, and in a class literal).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，有几个例外情况（数组创建、异常处理、使用`instanceof`和在类文字中）。'
- en: '**Q.** Can I make the Node class static?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以将Node类设为静态吗？'
- en: '**A.** For [LinkedStackOfString.java](LinkedStackOfStrings.java.html), you
    can do so with no other changes and save 8 bytes (of inner class overhead) per
    node. However, the nested class `Node` in [LinkedStack.java](LinkedStack.java.html)
    uses the type information of `Item` from the outer class, so you would need to
    do a bit of extra work to make it static. [Stack.java](Stack.java.html) accomplishes
    this by making the nested class (and the nester iterator) generic: there are three
    separate generic type parameters, each of which is named `Item`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 对于[LinkedStackOfString.java](LinkedStackOfStrings.java.html)，你可以这样做而不需要其他更改，并节省每个节点的
    8 字节（内部类开销）。然而，在[LinkedStack.java](LinkedStack.java.html)中的嵌套类`Node`使用外部类的`Item`类型信息，因此你需要做一些额外的工作使其静态化。[Stack.java](Stack.java.html)通过使嵌套类（和嵌套迭代器）泛型化来实现这一点：有三个单独的泛型类型参数，每个都命名为`Item`。'
- en: '**Q.** Why do I get a "can''t create an array of generics" error when I try
    to create an array of generics?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 当我尝试创建泛型数组时为什么会出现“无法创建泛型数组”的错误？'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**A.** Unfortunately, creating arrays of generics is not possible in Java 1.5.
    The underlying cause is that arrays in Java are *covariant*, but generics are
    not. In other words, `String[]` is a subtype of `Object[]`, but `Stack<String>`
    is not a subtype of `Stack<Object>`. To get around this defect, you need to perform
    an unchecked cast as in [ResizingArrayStack.java](ResizingArrayStack.java.html).
    [ResizingArrayStackWithReflection.java](ResizingArrayStackWithReflection.java.html)
    is an (unwieldy) alternative that avoids the unchecked cast by using reflection.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不幸的是，在Java 1.5中无法创建泛型数组。根本原因是Java中的数组是*协变*的，但泛型不是。换句话说，`String[]`是`Object[]`的子类型，但`Stack<String>`不是`Stack<Object>`的子类型。为了解决这个缺陷，你需要执行一个未经检查的转换，就像在[ResizingArrayStack.java](ResizingArrayStack.java.html)中一样。[ResizingArrayStackWithReflection.java](ResizingArrayStackWithReflection.java.html)是一个（笨拙的）替代方案，通过使用反射来避免未经检查的转换。'
- en: '**Q.** So, why are arrays covariant?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 那么，为什么数组是协变的？'
- en: '**A.** Many programmers (and programming language theorists) consider covariant
    arrays to be a serious defect in Java''s type system: they incur unnecessary run-time
    performance overhead (for example, see [ArrayStoreException](http://download.oracle.com/javase/6/docs/api/java/lang/ArrayStoreException.html))
    and can lead to subtle bugs. Covariant arrays were introduced in Java to circumvent
    the problem that Java didn''t originally include generics in its design, e.g.,
    to implement `Arrays.sort(Comparable[])` and have it be callable with an input
    array of type `String[]`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 许多程序员（和编程语言理论家）认为Java类型系统中的协变数组是一个严重的缺陷：它们会产生不必要的运行时性能开销（例如，参见[ArrayStoreException](http://download.oracle.com/javase/6/docs/api/java/lang/ArrayStoreException.html)），并且可能导致微妙的错误。Java引入协变数组是为了解决Java最初设计中不包含泛型的问题，例如，实现`Arrays.sort(Comparable[])`并使其能够接受`String[]`类型的输入数组。'
- en: '**Q.** Can I create and return a new array of a parameterized type, e.g., to
    implement a `toArray()` method for a generic queue?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我可以创建并返回一个参数化类型的新数组吗，例如为泛型队列实现一个`toArray()`方法？'
- en: '**A.** Not easily. You can do it using reflection provided that the client
    passes an object of the desired concrete type to `toArray()` This is the (awkward)
    approach taken by Java''s Collection Framework. [GenericArrayFactory.java](GenericArrayFactory.java.html)
    provides an alternate solution in which the client passes a variable of type `Class`.
    See also Neal Gafter''s blog for a solution that uses [type tokens](http://gafter.blogspot.ru/2004/09/puzzling-through-erasure-answer.html).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不容易。你可以使用反射来实现，前提是客户端向`toArray()`传递所需具体类型的对象。这是Java集合框架采取的（笨拙的）方法。[GenericArrayFactory.java](GenericArrayFactory.java.html)提供了一个客户端传递`Class`类型变量的替代解决方案。另请参阅Neal
    Gafter的博客，了解使用[type tokens](http://gafter.blogspot.ru/2004/09/puzzling-through-erasure-answer.html)的解决方案。'
- en: Iterator Q + A
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代器问答
- en: '**Q.** Why is the construct called *foreach* if it uses the keyword `for`?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么这个结构被称为*foreach*，而它使用关键字`for`？'
- en: '**A.** Other languages use the keyword `foreach`, but the Java developers did
    not want to introduce a new keyword and break backward compatibility.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 其他语言使用关键字`foreach`，但Java开发人员不想引入新关键字并破坏向后兼容性。'
- en: '**Q.** Are `String`s iterable?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** `String`可迭代吗？'
- en: '**A.** No.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不。'
- en: '**Q.** Are arrays `Iterable`?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 数组是`Iterable`吗？'
- en: '**A.** No. You can use the foreach syntax with them. However, you can not pass
    an array to a method that expects an `Iterable` or return an array from a method
    which returns an `Iterable`. This would be convenient, but it doesn''t work that
    way.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不。你可以使用它们的foreach语法。但是，你不能将数组传递给期望`Iterable`的方法，也不能从返回`Iterable`的方法返回数组。这样会很方便，但实际上不起作用。'
- en: '**Q.** What''s wrong with the following code fragment?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 以下代码片段有什么问题？'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**A.** The enhanced for loop requires that the iterating variable be declared
    inside the loop.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 增强的for循环要求在循环内部声明迭代变量。'
- en: Exercises
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Add a method `isFull()` to [FixedCapacityStackOfStrings.java](FixedCapacityStackOfStrings.java.html).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[FixedCapacityStackOfStrings.java](FixedCapacityStackOfStrings.java.html)中添加一个`isFull()`方法。
- en: Give the output printed by `java Stack` for the input
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出`java Stack`对输入打印的输出
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Solution.* `was best times of the was the it (1 left on stack)`'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。`was best times of the was the it (1 left on stack)`'
- en: Suppose that an intermixed sequence of (stack) *push* and *pop* operations are
    performed. The pushes push the integers 0 through 9 in order; the pops print out
    the return value. Which of the following sequence(s) could not occur?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设执行了一系列交错的（栈）*push*和*pop*操作。push操作按顺序将整数0到9推入栈；pop操作打印返回值。以下哪种序列不可能发生？
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Answer*: (b), (f), and (g).'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：(b)、(f)和(g)。'
- en: Write a stack client [Parentheses.java](Parentheses.java.html) that reads in
    sequence of left and right parentheses, braces, and brackets from standard input
    and uses a stack to determine whether the sequence is properly balanced. For example,
    your program should print `true` for `[()]{}{[()()]()}` and `false` for `[(])`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个栈客户端[Parentheses.java](Parentheses.java.html)，从标准输入中读取一系列左右括号、大括号和方括号，并使用栈来确定序列是否平衡。例如，你的程序应该对`[()]{}{[()()]()}`打印`true`，对`[(])`打印`false`。
- en: What does the following code fragment print when `n` is 50? Give a high-level
    description of what it does when presented with a positive integer `n`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`n`为50时，以下代码片段打印什么？给出当给定正整数`n`时它的高级描述。
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Answer*: Prints the binary representation of `N` (`110010` when `n` is `50`).'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：打印`N`的二进制表示（当`n`为`50`时为`110010`）。'
- en: What does the following code fragment do to the queue `q`?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段对队列`q`做了什么？
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Answer*: Reverses the items on the queue.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：颠倒队列中的项目。'
- en: Add a method `peek` to [Stack.java](Stack.java.html) that returns the most recently
    inserted item on the stack (without popping it).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[Stack.java](Stack.java.html)中添加一个`peek`方法，返回栈中最近插入的项（不弹出）。
- en: Write a filter Program [InfixToPostfix.java](InfixToPostfix.java.html) that
    converts an arithmetic expression from infix to postfix.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器程序[InfixToPostfix.java](InfixToPostfix.java.html)，将中缀算术表达式转换为后缀表达式。
- en: Write a program [EvaluatePostfix.java](EvaluatePostfix.java.html) that that
    takes a postfix expression from standard input, evaluates it, and prints the value.
    (Piping the output of your program from the previous exercise to this program
    gives equivalent behavior to [Evaluate.java](Evaluate.java.html).)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[EvaluatePostfix.java](EvaluatePostfix.java.html)，从标准输入中获取后缀表达式，对其进行评估，并打印值。（将上一个练习的程序输出通过管道传递给这个程序，可以实现与[Evaluate.java](Evaluate.java.html)相同的行为。）
- en: Suppose that a client performs an intermixed sequence of (queue) *enqueue* and
    *dequeue* operations. The enqueue operations put the integers 0 through 9 in order
    onto the queue; the dequeue operations print out the return value. Which of the
    following sequence(s) could not occur?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设客户端执行了一系列交错的（队列）*enqueue*和*dequeue*操作。enqueue操作按顺序将整数0到9放入队列；dequeue操作打印返回值。以下哪种序列不可能发生？
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Answer*: (b), (c), and (d).'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：(b)、(c)和(d)。'
- en: Develop a class `ResizingArrayQueueOfStrings` that implements the queue abstraction
    with a fixed-size array, and then extend your implementation to use array resizing
    to remove the size restriction.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一��类 `ResizingArrayQueueOfStrings`，使用固定大小数组实现队列抽象，然后扩展您的实现以使用数组调整大小以消除大小限制。
- en: '*Solution*: [ResizingArrayQueue.java](ResizingArrayQueue.java.html)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: [ResizingArrayQueue.java](ResizingArrayQueue.java.html)'
- en: Linked-List Exercises
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链表练习
- en: Creative Problems
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意问题
- en: '**Josephus problem.** In the Josephus problem from antiquity, *N* people are
    in dire straits and agree to the following strategy to reduce the population.
    They arrange themselves in a circle (at positions numbered from 0 to N-1) and
    proceed around the circle, eliminating every Mth person until only one person
    is left. Legend has it that Josephus figured out where to sit to avoid being eliminated.
    Write a `Queue` client [Josephus.java](Josephus.java.html) that takes M and N
    from the command line and prints out the order in which people are eliminated
    (and thus would show Josephus where to sit in the circle).'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**约瑟夫问题。** 在古代的约瑟夫问题中，*N* 个人陷入困境，并同意采取以下策略来减少人口。 他们围成一个圆圈（位置从0到N-1编号），沿着圆圈进行，每隔M个人就淘汰一个，直到只剩下一个人。
    传说中约瑟夫找到了一个位置可以避免被淘汰。编写一个 `Queue` 客户端 [Josephus.java](Josephus.java.html)，从命令行获取M和N，并打印出人们被淘汰的顺序（从而向约瑟夫展示在圆圈中应该坐在哪里）。'
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Copy a stack.** Create a new constructor for the linked-list implementation
    of [Stack.java](Stack.java.html) so that `Stack t = new Stack(s)` makes `t` reference
    a new and independent copy of the stack `s`.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复制一个栈。** 为链表实现的 [Stack.java](Stack.java.html) 创建一个新的构造函数，使得 `Stack t = new
    Stack(s)` 使 `t` 引用栈 `s` 的一个新且独立的副本。'
- en: '*Recursive solution*: create a copy constructor for a linked list starting
    at a given `Node` and use this to create the new stack.'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*递归解决方案:* 为从给定 `Node` 开始的链表创建一个复制构造函数，并使用它来创建新的栈。'
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Nonrecursive solution*: create a copy constructor for a single `Node` object.'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*非递归解决方案:* 为单个 `Node` 对象创建一个复制构造函数。'
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Stack generability.** Suppose that we have a sequence of intermixed *push*
    and *pop* operations as with our test stack client, where the integers 0, 1, ...,
    N-1 in that order (*push* directives) are intermixed with *N* minus signs (*pop*
    directives). Devise an algorithm that determines whether the intermixed sequence
    causes the stack to underflow. (You may use only an amount of space independent
    of *N*—you cannot store the integers in a data structure.) Devise a linear-time
    algorithm that determines whether a given permutation can be generated as output
    by our test client (depending on where the *pop* operations occur).'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**栈的可生成性。** 假设我们有一个混合 *push* 和 *pop* 操作的序列，就像我们的测试栈客户端一样，其中按顺序 0、1、...、N-1（*push*
    指令）与 *N* 个减号（*pop* 指令）交错。设计一个算法，确定混合序列是否会导致栈下溢。 （您只能使用与 *N* 无关的空间量 - 不能将整数存储在数据结构中。）设计一个线性时间算法，确定给定排列是否可以由我们的测试客户端生成输出（取决于
    *pop* 操作发生的位置）。'
- en: '*Solution.* The stack does not underflow unless there exists an integer *k*
    such that the first *k* pop operations occur before the first *k* push operations.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 只有存在整数 *k*，使得前 *k* 个 pop 操作发生在前 *k* 个 push 操作之前，栈才会下溢。'
- en: 'If a given permutation can be generated, it is uniquely generated as follows:
    if the next integer in the permutation is in the top of the stack, pop it; otherwise,
    push the next integer in the input sequence onto the stack (or stop if N-1 has
    already been pushed). The permutation can be generated if and only if the stack
    is empty upon termination.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果可以生成给定的排列，那么它将唯一生成如下：如果排列中的下一个整数在栈的顶部，则弹出它；否则，将输入序列中的下一个整数推送到栈上（或者如果已经推送了N-1，则停止）。
    只有在终止时栈为空，排列才能生成。
- en: '**Forbidden triple for stack generability. (R. Tarjan)** Prove that a permutation
    can be generated by a stack (as in the previous question) if and only if it has
    no *forbidden triple (a, b, c)* such that a < b < c with c first, a second, and
    b third (possibly with other intervening integers between c and a and between
    a and b).'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**栈可生成的禁止三元组。 (R. Tarjan)** 证明排列可以由栈生成（如前一个问题中所述），当且仅当它没有 *禁止的三元组 (a, b, c)*，其中
    a < b < c，c 第一，a 第二，b 第三（可能在 c 和 a 之间以及 a 和 b 之间有其他插入的整数）。'
- en: '*Partial solution.* Suppose that there is a forbidden triple (a, b, c). Item
    c is popped before a and b, but a and b are pushed before c. Thus, when c is pushed,
    both a and b are on the stack. Therefore, a cannot be popped before b.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案。* 假设存在一个禁止的三元组（a，b，c）。 在 a 和 b 之前弹出项 c，但在 c 之前推入 a 和 b。 因此，当推入 c 时，a
    和 b 都在栈上。 因此，在弹出 b 之前，a 不能被弹出。'
- en: '**Catenable queues, stacks, or steques.** Add an extra operation *catenation*
    that (destructively) concatenates two queues, stacks, or steques. *Hint*: use
    a circular linked list, maintaining a pointer to the last item.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可连接的队列、栈或 steque。** 添加一个额外的 *连接* 操作，（破坏性地）连接两个队列、栈或 steques。 *提示*: 使用循环链表，保持指向最后一项的指针。'
- en: '**Fail-fast iterator.** Modify the iterator code in [Stack.java](Stack.java.html)
    to immediately throw a [java.util.ConcurrentModificationException](http://download.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html)
    if the client modifies the collection (via `push()` or `pop()`) during iteration.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**快速失败的迭代器。** 修改 [Stack.java](Stack.java.html) 中的迭代器代码，如果客户端在迭代期间修改集合（通过 `push()`
    或 `pop()`）则立即抛出 [java.util.ConcurrentModificationException](http://download.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html)。'
- en: '*Solution:* Maintain a counter that counts the number of `push()` and `pop()`
    operations. When creating an iterator, store this value as an iterator instance
    variable. Before each call to `hasNext()` and `next()`, check that this value
    has not changed since construction of the iterator; if it has, throw an exception.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案:* 维护一个计数器，计算 `push()` 和 `pop()` 操作的次数。 创建一个迭代器时，将此值存储为迭代器实例变量。 在每次调用
    `hasNext()` 和 `next()` 之前，检查该值是否自构造迭代器以来已更改；如果已更改，则抛出异常。'
- en: '**Expression evaluation with precedence.** Write a program [EvaluateDeluxe.java](EvaluateDeluxe.java.html)
    that extends [Evaluate.java](Evaluate.java.html) to handle expressions that are
    not fully parenthesized, using the standard precedence order for the operators
    +, -, *, and /.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带优先级的表达式求值。** 编写一个程序 [EvaluateDeluxe.java](EvaluateDeluxe.java.html)，扩展 [Evaluate.java](Evaluate.java.html)
    以处理未完全括号化的表达式，使用标准的运算符 +、-、* 和 / 的优先级顺序。'
- en: Web Exercises
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: '**Tail.** Write a program `Tail` so that `Tail k < file.txt` prints the last
    `k` lines of the file `file.txt`. Use `StdIn.readLine()`. Which data structure
    should you use?'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**尾部。** 编写一个程序 `Tail`，使得 `Tail k < file.txt` 打印文件 `file.txt` 的最后 `k` 行。使用 `StdIn.readLine()`。应该使用哪种数据结构？'
- en: '**Bounded stack.** A *bounded stack* is a stack that has a capacity of at most
    N. (Applications: undo or history with finite buffer.)'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有界栈。** 一个*有界栈*是一个最多容纳 N 个元素的栈。（应用：带有有限缓冲区的撤销或历史记录。）'
- en: '**Delete ith element.** Create a data type that supports the following operations:
    `isEmpty`, `insert`, and `remove(int i)`, where the deletion operation deletes
    and returns the ith least recently added object on the queue. Do it with an array,
    then do it with a linked list. What is the running time for each operation?'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除第 i 个元素。** 创建一个支持以下操作的数据类型：`isEmpty`、`insert` 和 `remove(int i)`，其中删除操作删除并返回队列中最近添加的第
    i 个对象。首先使用数组实现，然后使用链表实现。每个操作的运行时间是多少？'
- en: '**Dynamic shrinking.** With the array implementations of stack and queue, we
    doubled the size of the array when it wasn''t big enough to store the next element.
    If we perform a number of doubling operations, and then delete a lot of elements,
    we might end up with an array that is much bigger than necessary. Implement the
    following strategy: whenever the array is 1/4 full or less, shrink it to half
    the size. Explain why we don''t shrink it to half the size when it is 1/2 full
    or less.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态缩小。** 使用栈和队列的数组实现时，当数组不足以存储下一个元素时，我们会将数组大小加倍。如果我们执行了多次加倍操作，然后删除了很多元素，可能会得到一个比必要的大得多的数组。实现以下策略：每当数组的填充率低于
    1/4 时，将其缩小到一半大小。解释为什么当填充率低于 1/2 时我们不将其缩小到一半大小。'
- en: '**Stack + max.** Create a data structure that efficiently supports the stack
    operations (pop and push) and also return the maximum element. Assume the elements
    are integers or reals so that you can compare them.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**栈 + 最大值。** 创建一个数据结构，有效支持栈操作（弹出和推入），并返回最大元素。假设元素是整数或实数，以便可以比较它们。'
- en: '*Hint:* use two stacks, one to store all of the elements and a second stack
    to store the maximums.'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：使用两个堆栈，一个用于存储所有元素，另一个用于存储最大值。'
- en: '**PostScript.** *PostScript* is a stack-based language used by most printers.
    Implement a small subset of PostScript using a stack.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PostScript。** *PostScript* 是大多数打印机使用的基于堆栈的语言。使用一个堆栈实现 PostScript 的一个小子集。'
- en: '**Interview question.** Given a stack of an unknown number of strings, print
    out the 5th to the last one. It''s OK to destroy the stack in the process. *Hint*:
    use a queue of 5 elements.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**面试问题。** 给定一个未知数量的字符串的堆栈，打印出倒数第 5 个字符串。在此过程中破坏堆栈是可以的。*提示*：使用一个包含 5 个元素的队列。'
- en: '**Tag systems.** Write a program that reads in a binary string from the command
    line and applies the following (00, 1101) tag-system: if the first bit is 0, delete
    the first three bits and append 00; if the first bit is 1, delete the first three
    bits and append 1101\. Repeat as long as the string has at least 3 bits. Try to
    determine whether the following inputs will halt or go into an infinite loop:
    10010, 100100100100100100\. Use a queue.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标签系统。** 编写一个程序，从命令行读取一个二进制字符串，并应用以下（00, 1101���标签系统：如果第一个位是 0，则删除前三位并追加 00；如果第一个位是
    1，则删除前三位并追加 1101。只要字符串至少有 3 位，就重复此过程。尝试确定以下输入是否会停止或进入无限循环：10010, 100100100100100100。使用一个队列。'
- en: '**Turing tape.** Implement an *one-dimensional Turing tape*. The tape consists
    of a sequence of cells, each of which stores an integer (that is initialized to
    0). At any instant, there is a *tape head* which points to one of the cells. Support
    the following interface methods: `moveLeft` to move the tape head one cell to
    the left, `moveRight` to move the tape head one cell to the right, `look` to return
    the contents of the active cell, and `write(int a)` to change the contents of
    the active cell to `a`. *Hint*: use an `int` for the active cell, and two stacks
    for the left and right parts of the tape. Similar to text editor buffer.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图灵带。** 实现一个*一维图灵带*。带由一系列单元格组成，每个单元格存储一个整数（初始化为 0）。在任何时刻，都有一个*带头*指向其中一个单元格。支持以下接口方法：`moveLeft`
    将带头向左移动一个单元格，`moveRight` 将带头向右移动一个单元格，`look` 返回活动单元格的内容，`write(int a)` 将活动单元格的内容更改为
    `a`。*提示*：使用一个 `int` 表示活动单元格，使用两个堆栈表示带的左侧和右侧部分。类似于文本编辑器缓冲区。'
- en: '**Palindrome checker.** Write a program that reads in a sequence of strings
    and checks whether it constitutes a palindrome. Ignore punctuation and spaces
    and case. (A MAN, A PLAN, A CANAL - PANAMA). Use one stack and one queue.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回文检查器。** 编写一个程序，读取一系列字符串并检查它们是否构成回文。忽略标点、空格和大小写。（A MAN, A PLAN, A CANAL -
    PANAMA）。使用一个栈和一个队列。'
- en: '**Streaming algorithm.** Given a long sequence of items, design a data structure
    to store the k items most recently seen.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**流算法。** 给定一长序列的项目，设计一个数据结构来存储最近看到的 k 个项目。'
- en: '**2 M/M/1 queues.** Next customer is assigned to the smaller of the two queues.
    Use 2 FIFO queues. Perception that you always pick the longer line (or wrong lane)
    when approaching a toll plaza. Suppose two cars enter the toll plaza at the same
    time and pick different queues of the same length. Compute average length in time
    that one car will beat the other car by.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2 M/M/1 队列。** 下一个顾客被分配到两个队列中较小的一个。使用 2 个先进先出队列。当接近收费站时，总是选择较长的队列（或错误的车道）的感觉。假设两辆车同时进入收费站并选择相同长度的不同队列。计算一辆车领先另一辆车的平均时间长度。'
- en: '**M/M/k queue.** Compare k independent M/M/1 queues vs. M/M/k queue.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**M/M/k 队列。** 比较 k 个独立的 M/M/1 队列和 M/M/k 队列。'
- en: '**M/G/1 queue.** Analyze queueing model with a different service distribution
    (G = general).'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**M/G/1 队列。** 分析具有不同服务分布（G = 一般）的排队模型。'
- en: '**Infix to postfix with precedence order.** Write a program to convert an infix
    expression to postfix. Scan the infix expression from left to right.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中缀表达式转后缀表达式并考虑优先级顺序。** 编写一个程序将中缀表达式转换为后缀表达式。从左到右扫描中缀表达式。'
- en: 'Operand: output it.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数：输出它。
- en: 'Left parentheses: push onto stack.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左括号：推入栈中。
- en: 'Right parentheses: repeatedly pop elements from the stack and output them until
    a left parenthesis is encountered. Discard both parentheses.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右括号：重复弹出栈中的元素并输出，直到遇到左括号。丢弃两个括号。
- en: 'Operator with high precedence than top of stack: push onto stack.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级高于栈顶的运算符：推入栈中。
- en: 'Operator with lower or equal precedence than top of stack: repeatedly pop elements
    from the stack and output them until top of stack has higher precedence. Push
    the scanned operator onto the stack.Afterward, pop remaining elements off stack
    and output them.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级低于或等于栈顶的运算符：重复弹出栈中的元素并输出，直到栈顶的运算符具有更高的优先级。将扫描到的运算符推入栈中。之后，弹出栈中的剩余元素并输出。
- en: '**Check for duplicates.** Write a code fragment that determines if a bag contains
    any duplicate items. Use two nested iterators.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查重复。** 编写一个代码片段，确定一个袋子是否包含任何重复项目。使用两个嵌套迭代器。'
- en: '**Check for triplicates.** Write a code fragment that determines if a bag contains
    any item repeated at least three times. Use triply nested iterators.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查三重复。** 编写一个代码片段，确定一个袋子是否包含至少三次重复的项目。使用三重嵌套迭代器。'
- en: '**Equality.** Two queues are equal if they contain the same items in the same
    order. Two bags are equal if they contain the same items in any order.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**相等。** 如果两个队列按相同顺序包含相同项目，则它们相等。如果两个袋子包含相同项目但顺序不同，则它们相等。'
- en: '**Set of integers.** Create a data type that represents a set of integers (no
    duplicates) between 0 and N-1\. Support add(i), exists(i), remove(i), size(),
    intersect, difference, symmetricDifference, union, isSubset, isSuperSet, and isDisjointFrom.
    Include an iterator.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整数集合。** 创建一个表示0到N-1之间（无重复）整数集合的数据类型。支持`add(i)`，`exists(i)`，`remove(i)`，`size()`，`intersect`，`difference`，`symmetricDifference`，`union`，`isSubset`，`isSuperSet`和`isDisjointFrom`。包括一个迭代器。'
- en: '**Colon.** Experienced programmers know that it''s usually a bad idea to write
    a loop like'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**冒号。** 有经验的程序员知道，像下面这样写一个循环通常是一个坏主意'
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: since as a result of floating point precision, the loop will execute 10N times
    if N = xxx, and 10N + 1 times if N = yyy. Create an data type `Mesh` so that `x`
    ranges from `left` to `right` in increments of size `delta`. Assuming `right >=
    left`, the loop should execute *exactly* If `1 + floor((right - left) / delta)`
    times.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于浮点精度的结果，如果N = xxx，则循环将执行10N次，如果N = yyy，则执行10N + 1次。创建一个数据类型`Mesh`，使得`x`从`left`到`right`以`delta`的大小增量。假设`right
    >= left`，则循环应该*恰好*执行`1 + floor((right - left) / delta)`次。
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is how the colon operator works in MATLAB. You should also instrument your
    program so that it works even left > right and delta is negative.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是MATLAB中冒号运算符的工作原理。您还应该对程序进行调试，以确保即使`left > right`且`delta`为负数也能正常工作。
- en: '**List iterators.** We might also want to include methods `hasPrevious()` and
    `previous()` for going backwards in the list. To implement `previous()` we can
    use a doubly-linked list. Program [DoublyLinkedList.java](DoublyLinkedList.java.html)
    implements this strategy. It uses Java''s `java.util.ListIterator` interface to
    support moving forwards and backwards. We implement all optional methods, including
    `remove()`, `set()`, and `add()`. The method `remove()` deletes the last element
    returned by either `next()` or `previous()`. The method `set()` overwrites the
    value of the last element returned by either `next()` or `previous()`. The method
    `add()` inserts an element before the next element that would be returned by `next()`.
    It is legal to call `set()` and `remove()` only after a call either to `next()`
    or `previous()`, and with no intervening calls to either `remove()` or `add()`.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列表迭代器。** 我们可能还想包括用于在列表中向后移动的方法`hasPrevious()`和`previous()`。要实现`previous()`，我们可以使用双向链表。程序[DoublyLinkedList.java](DoublyLinkedList.java.html)实现了这种策略。它使用Java的`java.util.ListIterator`接口支持向前和向后移动。我们实现了所有可选方法，包括`remove()`，`set()`和`add()`。`remove()`方法删除`next()`或`previous()`返回的最后一个元素。`set()`方法覆盖`next()`或`previous()`返回的最后一个元素的值。`add()`方法在`next()`将返回的下一个元素之前插入一个元素。只有在调用`next()`或`previous()`之后，且没有调用`remove()`或`add()`之后，才能调用`set()`和`remove()`是合法的。'
- en: We use a dummy head and tail node to avoid extra cases. We also store an extra
    variable `lastAccessed` which stores the node accessed in the most recent call
    to `next()` or `previous()`. After removing an element, we reset `lastAccessed`
    to `null`; this designates that calling `remove()` is illegal (until after a subsequent
    call to either `next()` or `previous()`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用一个虚拟的头节点和尾节点来避免额外的情况。我们还存储一个额外的变量`lastAccessed`，它存储在最近一次调用`next()`或`previous()`时访问的节点。删除元素后，我们将`lastAccessed`重置为`null`；这表示调用`remove()`是非法的（直到随后调用`next()`或`previous()`为止）。
- en: '**TwoWayIterator.** Define an interface `TwoWayIterator` that supports four
    methods: `hasNext()`, `hasPrevious()`, `next()`, and `previous()`. Implement a
    list that supports a `TwoWayIterator`. *Hint*: implement the list using an array
    or doubly linked list.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双向迭代器。** 定义一个支持四种方法的接口`TwoWayIterator`：`hasNext()`，`hasPrevious()`，`next()`和`previous()`。实现一个支持`TwoWayIterator`的列表。*提示*：使用数组或双向链表实现列表。'
- en: '**Adding one bag to the end of another.** Write a method that adds the items
    of one bag b to the end of the invoking bag a. Assume both bags store items of
    the same type.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将一个袋子添加到另一个末尾。** 编写一个方法，将一个袋子b的项目添加到调用方的末尾。假设两个袋子存储相同类型的项目。'
- en: '*Hint*: iterate through the items of b using an iterator, and add each to the
    end of the invoking bag.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：使用迭代器遍历b的项目，并将每个项目添加到调用方的末尾。'
- en: '**Replace all.** Write a method that replaces all occurrences of an item `from`
    with the item `to` in a queue or stack.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**替换所有。** 编写一个方法，在队列或栈中用项目`from`替换所有出现的项目`to`。'
- en: '**Adding a list to itself.** What is the result of the following code fragment?'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将列表添加到自身。** 以下代码片段的结果是什么？'
- en: '[PRE24]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Answer*: stack overflow. The Java documents says that "while it is permissible
    for lists to contain themselves as elements, extreme caution is advised: the equals
    and hashCode methods are no longer well defined on a such a list."'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案：* 栈溢出。Java文档中说：“虽然列表可以包含自身作为元素，但极度谨慎是明智的：在这样的列表上，equals和hashCode方法不再被很好地定义。”'
- en: '**Song playlist.** Create an data type that supports the following operations:
    `enqueue` (add a new song to the end of the list), `play` (print the name of the
    next song), `skip` (skip the next song in the list, and do not prints its name)
    and `back` (go back one song). Use a list that supports an iterator with forward
    and backwards.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**歌曲播放列表。** 创建一个支持以下操作的数据类型：`enqueue`（将新歌曲添加到列表末尾）、`play`（打印下一首歌曲的名称）、`skip`（跳过列表中的下一首歌曲，不打印其名称）和`back`（返回上一首歌曲）。使用支持前向和后向迭代器的列表。'
- en: '**Josephus.** Program [Josephus.java](Josephus.java.html) computes Josephus
    number.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Josephus。** 程序[Josephus.java](Josephus.java.html)计算Josephus数。'
- en: Will the following print out the integers 0 through 9 (in ascending order)?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码会按升序打印出整数0到9吗？
- en: '[PRE25]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: No. It will print out 10 values, but with some duplicates and not in ascending
    order. The iterator does not save a copy of the original array - instead, it uses
    the mutated copy.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不会。它会打印出10个值，但会有一些重复项，并且不会按升序排列。迭代器不会保存原始数组的副本 - 相反，它使用已变异的副本。
- en: '**Queue with one access pointer.** Re-implement a queue, with all operations
    taking constant time, but only one instance variable (instead of two). *Hint*:
    use a circular linked list, maintaining a pointer to the last item.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用一个访问指针实现队列。** 重新实现一个队列，所有操作都需要恒定时间，但只有一个实例变量（而不是两个）。*提示：* 使用循环链表，保持指向最后一个项目的指针。'
- en: '**Steque.** A *stack-ended queue* or *steque* is a data type that supports
    push, pop, and enqueue. Knuth calls it an output-restricted deque. Implement it
    using a singly-linked list.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Steque。** *栈结束队列*或*steque*是一种支持push、pop和enqueue的数据类型。Knuth将其称为输出受限双端队列。使用单链表实现它。'
- en: '**Queue with two stacks.** Implement a queue with two stacks so that each queue
    operations takes a constant amortized number of stack operations. *Hint:* If you
    push elements onto a stack and then pop them all, they appear in reverse order.
    If you repeat this process, they''re now back in order.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用两个栈实现队列。** 实现一个使用两个栈的队列，使得每个队列操作都需要恒定的摊销栈操作次数。*提示：* 如果你将元素推入栈然后全部弹出，它们会以相反顺序出现。如果你重复这个过程，它们现在又会按顺序排列。'
- en: '*Solution:* [QueueWithTwoStacks.java](QueueWithTwoStacks.java.html).'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：*[QueueWithTwoStacks.java](QueueWithTwoStacks.java.html)。'
- en: '**Queue with a constant number of stacks.** Implement a queue with a constant
    number of stacks so that each queue operations takes a constant (worst-case) number
    of stack operations. *Warning:* Very high degree of difficulty.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用恒定数量的栈实现队列。** 实现一个使用恒定数量的栈的队列，使得每个队列操作都需要恒定（最坏情况）的栈操作次数。*警告：* 难度非常高。'
- en: '**Stack with a queue.** Implement a stack with a single queue so that each
    stack operations takes a linear number of queue operations. *Hint:* to delete
    an item, get all of the elements on the queue one at a time, and put them at the
    end, except for the last one which you should delete and return. (Admittedly very
    inefficient.)'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用队列实现栈。** 实现一个使用单个队列的栈，使得每个栈操作都需要线性数量的队列操作。*提示：* 要删除一个项目，逐个获取队列中的所有元素，并将它们放在末尾，除了最后一个应该删除并返回。（诚然非常低效。）'
- en: '**Two stacks with a deque.** Implement two stacks with a single deque so that
    each operation takes a constant number of deque operations.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Deque实现两个栈。** 使用单个Deque实现两个栈，使得每个操作都需要恒定数量的Deque操作。'
- en: '**Steque with two stacks. (R. Tarjan)** Implement a steque with two stacks
    so that each steque operation takes a constant amortized number of stack operations.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用两个栈实现Steque。（R. Tarjan）** 实现一个使用两个栈的Steque，使得每个Steque操作都需要恒定的摊销栈操作次数。'
- en: '**Deque with a stack and a steque. (R. Tarjan)** Implement a deque with a stack
    and a steque so that each deque operation takes a constant amortized number of
    stack and steque operations.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用栈和Steque实现Deque。（R. Tarjan）** 实现一个使用栈和Steque的Deque，使得每个Deque操作都需要恒定的摊销栈和Steque操作次数。'
- en: '**Deque with three stacks. (R. Tarjan)** Implement a deque with three stacks
    so that each deque operation takes a constant amortized number of stack operations.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用三个栈实现Deque。（R. Tarjan）** 实现一个使用三个栈的Deque，使得每个Deque操作都需要恒定的摊销栈操作次数。'
- en: '*Multi-word search.* Program [MultiwordSearch.java](MultiwordSearch.java.html)
    reads a sequence of query words q[1], ..., q[k] from the command line and a sequence
    of documents words d[1], ..., d[N] from standard input and finds the shortest
    interval in which the k words appear in the same order. (Here shortest means the
    number of words in the interval.) That is find indices i and j such that d[i1]
    = q[1], d[i2] = q[2], ..., d[ik] = q[k] and i1 < i2 < ... < ik.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*多词搜索。* 程序[MultiwordSearch.java](MultiwordSearch.java.html)从命令行读取查询词q[1]，...，q[k]的序列，从标准输入读取文档单词d[1]，...，d[N]的序列，并找到这些k个单词按相同顺序出现的最短间隔。（这里最短意味着间隔中的单词数。）即找到索引i和j，使得d[i1]
    = q[1]，d[i2] = q[2]，...，d[ik] = q[k]，且i1 < i2 < ... < ik。'
- en: '*Answer*: for each query word, create a sorted list of the indices where it
    appears in the document. Scan through lists 2 to k in that order, deleting indices
    at the front of each list until the the first elements of the resulting k lists
    are in ascending order.'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：对于每个查询词，创建一个在文档中出现的索引的排序列表。按照2到k的顺序扫描列表，删除每个列表前面的索引，直到生成的k个列表的第一个元素按升序排列。'
- en: '[PRE26]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The sequence of first elements on the lists forms the shortest interval containing
    the first element on list 1.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表1上的第一个元素序列形成包含列表1上第一个元素的最短间隔。
- en: Now delete the first element on list 1. Repeatedly delete elements from list
    2 until it agrees with list 1\. Repeat for list 3, and so on until the whole array
    is in ascending order. Check this sequence of first elements, etc.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在删除列表1上的第一个元素。重复删除列表2中的元素，直到它与列表1一致。对列表3重复此操作，直到整个数组按升序排列。检查这个序列的第一个元素等等。
- en: '*M/M/1 queue.* The [Markov/Markov/Single-Server model](https://en.wikipedia.org/wiki/M/M/1_queue)
    is a fundamental queueing model in operations research and probability theory.
    Tasks arrive according to a *Poisson process* at a certain rate λ. This means
    that λ customers arrive per hour. More specifically, the arrivals follow an exponential
    distribution with mean 1 / λ: the probability of k arrivals between time 0 and
    t is (λ t)^k e^(-λ t) / k!. Tasks are serviced in FIFO order according to a Poisson
    process with rate μ. The two M''s standard for Markov: it means that the system
    is *memoryless*: the time between arrivals is independent, and the time between
    departures is independent.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*M/M/1 队列.* [马尔可夫/马尔可夫/单服务器模型](https://en.wikipedia.org/wiki/M/M/1_queue) 是运筹学和概率论中的基本排队模型。任务以特定速率
    λ 按泊松过程到达。这意味着每小时到达 λ 个顾客。���具体地说，到达遵循均值为 1 / λ 的指数分布：在时间 0 和 t 之间到达 k 个的概率是 (λ
    t)^k e^(-λ t) / k!。任务按照率为 μ 的泊松过程按 FIFO 顺序服务。两个 M 代表马尔可夫：这意味着系统是*无记忆*的：到达之间的时间是独立的，离开之间的时间也是独立的。'
- en: Analysis of M/M/1 model. We are interested in understanding the queueing system.
    If &lambda > μ the queue size increases without limit. For simple models like
    M/M/1 we can analyze these quantities analytically using probability theory. Assuming
    μ > λ, the probability of exactly n customers in the system is (λ / μ)^n (1 -
    λ / &mu).
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: M/M/1 模型分析。我们感兴趣的是理解排队系统。如果 λ > μ，则队列大小会无限增加。对于像 M/M/1 这样的简单模型，我们可以使用概率论来分析这些数量。假设
    μ > λ，系统中恰好有 n 个顾客的概率是 (λ / μ)^n (1 - λ / μ)。
- en: L = average number of customers in the system = λ / (μ - λ).
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: L = 系统中平均顾客数量 = λ / (μ - λ).
- en: L[Q] = average number of customers in the queue = λ² / (μ (μ - λ)).
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: L[Q] = 队列中平均顾客数量 = λ² / (μ (μ - λ)).
- en: W = average time a customer spends in the system = 1 / (μ - λ).
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: W = 顾客在系统中的平均时间 = 1 / (μ - λ).
- en: W[Q] = average time a customer spends in the queue = W - 1 / μ.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: W[Q] = 顾客在队列中的平均时间 = W - 1 / μ.
- en: 'Program [MM1Queue.java](MM1Queue.java.html) For more complex models we need
    to resort to simulation like this. Variants: multiple queues, multiple servers,
    sequential multi-stage servers, using a finite queue and measuring number of customers
    that are turned away. Applications: customers in McDonalds, packets in an internet
    router,'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序 [MM1Queue.java](MM1Queue.java.html) 对于更复杂的模型，我们需要使用这样的模拟。变体：多个队列，多个服务器，顺序多级服务器，使用有限队列并测量被拒绝的顾客数量。应用：麦当劳的顾客，互联网路由器中的数据包，
- en: '*Listing files.* A Unix directory is a list of files and directories. Program
    [Directory.java](Directory.java.html) takes the name of a directory as a command-line
    argument and prints out all of the files contained in that directory (and any
    subdirectories) in level-order. It uses a queue.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*列出文件.* Unix 目录是文件和目录的列表。程序 [Directory.java](Directory.java.html) 接受目录名称作为命令行参数，并按级别顺序打印出该目录中包含的所有文件（以及任何子目录）。它使用一个队列。'
- en: '*Interrupt handling.* When programming a real-time system that can be interrupted
    (e.g., by a mouse click or wireless connection), it is necessary to attend to
    the interrupts immediately, before proceeding with the current activity. If the
    interrupts should be handles in the same order they arrive, then a FIFO queue
    is the appropriate data structure.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*中断处理.* 当编写可以被中断的实时系统（例如，通过鼠标点击或无线连接）时，有必要立即处理中断，然后再继续当前活动。如果中断应按照到达顺序处理，则
    FIFO 队列是适当的数据结构。'
- en: '*Library implementation.* Java has a built in library called `Stack`, but you
    should avoid using it. It has additional operations that are not normally associated
    with a stack, e.g., getting the ith element and adding an element to the bottom
    of the stack (instead of the top). Although having such extra operations may appear
    to be a bonus, it is actually a curse. We use ADTs not because they provide every
    available operation, but rather because they *limit* the types of operations we
    are allowed to perform! This prevents us from performing operations that we don''t
    actually want. If we need more than just LIFO access, we should use a different
    data type. We can still build a stack data type from the Java libraries, but we
    are careful to limit the types of operations. There is no Java queue implementation.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*库实现.* Java 有一个名为 `Stack` 的内置库，但您应该避免使用它。它具有不通常与堆栈相关联的附加操作，例如获取第 i 个元素和将元素添加到堆栈底部（而不是顶部）。尽管具有这些额外操作可能看起来是一个奖励，但实际上是一个诅咒。我们使用
    ADT 不是因为它们提供了每个可用的操作，而是因为它们*限制*了我们可以执行的操作类型！这可以防止我们执行我们实际上不想要的操作。如果我们需要的不仅仅是 LIFO
    访问，我们应该使用不同的数据类型。我们仍然可以从 Java 库构建一个堆栈数据类型，但我们要小心限制操作类型。没有 Java 队列实现。'
- en: '*Load balancing.* N users must choose among N identical servers in a network.
    Goal: balance users across resources. Checking each resource to find an empty
    one (or least busy one) is too expensive. Instead, choose a random server. At
    any step, you should be able to see which jobs are on each machine. Program [Server.java](Server.java.html)
    Plot distribution of loads. Theory: avg load = 1, max load = log N / log log N.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*负载平衡.* N 个用户必须在网络中的 N 个相同服务器中进行选择。目标：平衡用户在资源之间的分布。检查每个资源以找到一个空闲的（或最不忙的）资源太昂贵了。相反，选择一个随机服务器。在任何步骤中，您应该能够看到每台机器上的作业。程序
    [Server.java](Server.java.html) 绘制负载分布。理论：平均负载 = 1，最大负载 = log N / log log N。'
- en: '*Load balancing reloaded.* ([Azar, Broder, Karlin, and Upfal](http://epubs.siam.org/sam-bin/getfile/SICOMP/articles/28849.pdf))
    Choose two random resources. Insert on least busy of the two. Theory: avg load
    = 1, max load = log log N.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*负载平衡再加载.* ([Azar, Broder, Karlin, and Upfal](http://epubs.siam.org/sam-bin/getfile/SICOMP/articles/28849.pdf))
    选择两个随机资源。插入到两者中最不忙的资源上。理论：平均负载 = 1，最大负载 = log log N。'
- en: '*Gridding.* Given N Euclidean points in the unit box and a parameter d, find
    all pairs that are within distance d. Divide box into a G-by-G grid where G =
    ceil(1/d). Put all points in a list in given grid cell. Any neighbor within distance
    d must be in that cell or one of its 8 neighbors. Program [Grid.java](Grid.java.html)
    implements this strategy using the helper data type [Point2D.java](Point2D.java.html).'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网格化。*给定单位盒中的N个欧几里得点和参数d，找到所有距离d以内的点对。将盒子分成一个G×G的网格，其中G = ceil(1/d)。将所有点放入给定网格单元格中的列表。任何距离d以内的邻居必须在该单元格或其8个邻居之一中。程序[Grid.java](Grid.java.html)使用辅助数据类型[Point2D.java](Point2D.java.html)实现了这种策略。'
- en: '*Java library.* Java contains library classes `LinkedList` and `ArrayList`
    that implement a list. Has wider interface than our `Sequence` data type: access
    an element by its index, delete an element, search for an element. No urns.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Java库。*Java包含库类`LinkedList`和`ArrayList`，实现了一个列表。比我们的`Sequence`数据类型具有更广泛的接口：通过索引访问元素，删除元素，搜索元素。没有urns。'
- en: Add a method `dup()` to `Stack` that creates a second copy of the topmost element
    and pushes it onto the stack.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Stack`添加一个名为`dup()`的方法，用于创建顶部元素的副本并将其推入栈中。
- en: Add a method `exch()` to `Stack` that exchanges the top two elements on the
    stack.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Stack`添加一个名为`exch()`的方法，用于交换栈顶部的两个元素。
- en: Add a method `size()` to `Stack` that returns the number of elements on the
    stack.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Stack`添加一个名为`size()`的方法，返回栈中的元素数量。
- en: Add a method `Item[] multiPop(int k)` to `Stack` that pops k elements from the
    stack and returns them as an array of objects.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Stack`添加一个名为`Item[] multiPop(int k)`的方法，从栈中弹出k个元素并将它们作为对象数组返回。
- en: Add a method `Item[] toArray()` to `Queue` that returns all N elements on the
    queue as an array of length N.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Queue`添加一个名为`Item[] toArray()`的方法，将队列中的所有N个元素作为长度为N的数组返回。
- en: 'Write a recursive function that takes as input a queue, and rearranges it so
    that it is in reverse order. Hint: dequeue the first element, recursively reverse
    the queue, and the enqueue the first element.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归函数，该函数以队列作为输入，并重新排列队列，使其顺序相反。提示：出队第一个元素，递归反转队列，然后入队第一个元素。
- en: Given a queue, create two new queues q1 and q2 so that q1 contains the even
    elements of q and q2 contains the odd elements, e.g., as in dealing a deck of
    cards.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个队列，创建两个新队列q1和q2，使得q1包含q的偶数元素，q2包含奇数元素，例如，就像处理一副牌一样。
- en: What does the following code fragment do?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段做什么？
- en: '[PRE27]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What data type would you choose to implement an "Undo" feature in a word processor?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文字处理器中实现“撤销”功能，您会选择哪种数据类型来实现？
- en: Suppose you have a single array of size N and want to implement two stacks so
    that you won't get overflow until the total number of elements on both stacks
    is N+1\. How would you implement this?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您有一个大小为N的单个数组，并且希望实现两个栈，以便在两个栈上的元素总数为N+1之前不会溢出。您将如何实现这一点？
- en: Suppose that you implemented `push` in the linked list implementation of [Stack.java](Stack.java.html)
    with the following code. What is the mistake?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您在[Stack.java](Stack.java.html)的链表实现中使用以下代码实现`push`。错误在哪里？
- en: '[PRE28]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Answer*: By redeclaring `first`, you are create a new local variable named
    `first`, which is different from the instance variable named `first`.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：通过重新声明`first`，您创建了一个名为`first`的新局部变量，它与名为`first`的实例变量不同。'
- en: '**Minimum stack.** Design a data type that implements the following operations,
    all in constant time: push, pop, min. Assume that the items are `Comparable`.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小栈。**设计一个数据类型，实现以下操作，所有操作都在常数时间内完成：推送，弹出，最小值。假设项目是`Comparable`的。'
- en: '*Solution:*: maintain two stacks, one which contains all of the items and another
    which contains the minima. To push an item, push it on the first stack; if it
    is smaller than the topmost item on the second stack, push it on the second stack
    as well. To pop an item, pop it from the first stack; if it is the top item on
    the second stack, pop it from the second stack as well. To find the minimum, return
    the top item on the second stack.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：维护两个栈，一个包含所有项目，另一个包含最小值。要推送项目，请将其推送到第一个栈；如果它小于第二个栈的顶部项目，请将其也推送到第二个栈。要弹出项目，请从第一个栈弹出；如果它是第二个栈的顶部项目，请也从第二个栈弹出。要找到最小值，请返回第二个栈的顶部项目。'
- en: '**Doubling and halving.** What is the effect of replacing the halving test
    in [ResizingArrayStack.java](ResizingArrayStack.java.html) from `if (N > 0 &&
    N == a.length/4) resize(a.length/2);` to `if (N == a.length/4) resize(2*N);`?'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**翻倍和减半。**将[ResizingArrayStack.java](ResizingArrayStack.java.html)中的减半测试从`if
    (N > 0 && N == a.length/4) resize(a.length/2);`替换为`if (N == a.length/4) resize(2*N);`的效果是什么？'
- en: '**Shunting-yard algorithm.** Implement Dijkstra''s [shunting-yard algorithm](http://en.wikipedia.org/wiki/Shunting-yard_algorithm)
    to convert an infix expression into a postfix expression. Support operator precedence,
    including both left and right associative operators.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Shunting-yard算法。**实现Dijkstra的[shunting-yard算法](http://en.wikipedia.org/wiki/Shunting-yard_algorithm)将中缀表达式转换为后缀表达式。支持运算符优先级，包括左结合和右结合运算符。'
- en: '**FIFO queue with random deletion.** Implement a data type that suports *insert
    an item*, *delete the item added least recently*, and *delete a random item*.
    Each operation should take constant expected amortized time per operation and
    should use space (at most) proportional to the numer of items in the data structure.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**FIFO队列与随机删除。**实现一个数据类型，支持*插入一个项目*，*删除最近添加的项目*和*删除一个随机项目*。每个操作应该在每次操作中花费常数期望摊销时间，并且应该使用空间（最多）与数据结构中的项目数量成比例。'
- en: '**Stock prices.** Given an array of daily stock prices `prices[]`, create an
    array `days[]` so that `days[i]` tells you how many days you have to wait, starting
    at day `i`, until the stock price exceeds `prices[i]`.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**股票价格。**给定每日股票价格数组`prices[]`，创建一个数组`days[]`，使得`days[i]`告诉您从第`i`天开始，直到股票价格超过`prices[i]`需要等待多少天。'
- en: '*Hint*: your algorithm should take linear time and use a stack of array indices.'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：你的算法应该以线性时间运行，并使用一个数组索引的栈。'
