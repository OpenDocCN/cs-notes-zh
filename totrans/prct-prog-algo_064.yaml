- en: 1.5 Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/python/15inout](https://introcs.cs.princeton.edu/python/15inout)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section we extend the set of simple abstractions (command-line input
    and standard output) that we have been using as the interface between our Python
    programs and the outside world to include *standard input*, *standard draw*, and
    *standard audio*. Standard input makes it convenient for us to compose programs
    that process arbitrary amounts of input and to interact with our programs; standard
    draw makes it possible for us to work with graphics; and standard audio adds sound.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Bird's-Eye View
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Bird''s eye view](../Images/dd46b13eb4b28374035e202c88fb90fa.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: The Python programs that we've seen so far take input values from the command
    line and write a string of characters as output. By default, both command-line
    input and the output written by the programs are associated with the application
    running on your computer that accepts commands (that is, the application in which
    you have been typing `python` commands). We use the generic term *terminal window*
    to refer to that application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'So far the Python programs that we''ve seen have used:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '*Command-line input.* Any Python program can access an array of strings referenced
    by `sys.argv`. That array contains the sequence of command-line arguments that
    we type, provided to Python by the operating system. By convention, both Python
    and the operating system process the arguments as strings, so if we intend for
    a command-line argument to be a number, we use a conversion function such as `int()`
    or `float()` to convert it from a string to the appropriate type.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Standard output.* To write output values, we have been using the functions
    `stdio.write()` and `stdio.writeln()`. When a program calls those functions, Python
    puts the results in the form of an abstract stream of characters known as *standard
    output*. By default, the operating system connects standard output to the terminal
    window. All of the output in our programs so far has appeared in the terminal
    window.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program [randomseq.py](randomseq.py.html) uses this model. It takes an integer
    command-line argument `n` and writes to standard output a sequence of `n` random
    numbers between 0 and 1, possibly including 0.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our programming model, we add the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard input.* The booksite `stdio.py` module defines several functions
    in addition to `write()` and `writeln()`. Those additional functions implement
    a standard input abstraction to complement the standard output abstraction. That
    is, the `stdio` module contains functions that allow your programs to *read* from
    standard input. Just as a program can write to standard output at any time, a
    program can read from standard input at any time.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Standard draw.* The booksite `stddraw` module allows your programs to create
    and write drawings. It implements a simple graphics model that allows your programs
    to create and write points, lines, and geometric shapes in a window on your computer.
    `stddraw` also implements features for animation.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Standard audio.* The booksite `stdaudio` module allows your programs to create
    and play sound. It uses a standard format to convert arrays of floats into sound.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Standard Output
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the API of the part of the `stdio.py` module that is relevant to standard
    output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![API for booksite functions related to standard output](../Images/4d3cc1fd9d6b3d4a79a15ca6b7bcb80b.png)'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The `stdio.writeln()` and `stdio.write()` functions are the ones that you have
    been using. The `stdio.writef()` function gives you more control over the appearance
    of the output, and deserves some explanation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Formatted writing basics.
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest kind of call of `stdio.writef()` passes only one argument; that
    argument should be a string. In that case `stdio.writef()` simply writes the string
    to standard output, and so is equivalent to `stdio.write()`. A more common call
    of `stdio.writef()` passes two arguments. In that context the first argument is
    called the *format string*. It contains a *conversion specification* that that
    describes how the second argument is to be converted to a string for output. A
    conversion specification has the form `%w.pc`, where:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 的最简单的调用只传递一个参数；该参数应为字符串。在这种情况下，`stdio.writef()` 简单地将字符串写入标准输出，因此等同于
    `stdio.write()`。`stdio.writef()` 的更常见的调用传递两个参数。在这种情况下，第一个参数称为*格式字符串*。它包含一个*转换说明*，描述了第二个参数如何转换为输出的字符串。转换说明的形式为
    `%w.pc`，其中：'
- en: '![Anatomy of a formatted write statement](../Images/55ee8ae35a4c1bdab5424e78e67fe836.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![格式化写语句的解剖](../Images/55ee8ae35a4c1bdab5424e78e67fe836.png)'
- en: '`w` is the *field width*. The field width is the number of characters that
    should be written. A negative field width indicates that the output should be
    padded with spaces on the right.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` 是*字段宽度*。字段宽度是应该写入的字符数。负的字段宽度表示输出应在右侧填充空格。'
- en: '`p` is the *precision*. For floats, the precision is the number of digits that
    should be written after the decimal point. For strings, the precision is the number
    of characters of the string that should be written.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` 是*精度*。对于浮点数，精度是小数点后应写入的数字位数。对于字符串，精度是应写入的字符串的字符数。'
- en: '`c` is the *conversion code*. The conversion code should be `d` when writing
    an integer, `f` or `e` when writing a float, and `s` when writing a string.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` 是*转换代码*。当写入整数时，转换代码应为 `d`，当写入浮点数时，应为 `f` 或 `e`，当写入字符串时，应为 `s`。'
- en: '![Writef format conventions](../Images/e3a6862062f278cd1a856a2dbb47c9c9.png)'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Writef 格式约定](../Images/e3a6862062f278cd1a856a2dbb47c9c9.png)'
- en: The `stdio.writef()` function can take more than two arguments. In that case,
    the format string will have a format specifier for each argument, perhaps separated
    by other characters to pass through to the output.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 函数可以接受多于两个参数。在这种情况下，格式字符串将为每个参数都有一个格式说明符，可能由其他字符分隔以传递到输出。'
- en: Any part of the format string that is not a conversion specification is simply
    passed through to the output. For example, the statement
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串中任何不是转换说明的部分都会简单地传递到输出。例如，语句
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: writes the line
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 写入行
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Multiple arguments.
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个参数。
- en: The `stdio.writef()` function can take more than two arguments. In this case,
    the format string will have a conversion specification for each argument, perhaps
    separated by other characters to pass through to the output.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 函数可以接受多于两个参数。在这种情况下，格式字符串将为每个参数都有一个转换说明，可能由其他字符分隔以传递到输出。'
- en: Formatted writing implementation.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化写入的实现。
- en: Internally the `stdio.writef()` function uses the `%` operator. Specifically,
    a function call of the form `stdio.writef(*formatString*, *value*)` internally
    is implemented using an expression of the form `*formatString* % *value*`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio.writef()` 函数内部使用了 `%` 运算符。具体来说，形如 `stdio.writef(*formatString*, *value*)`
    的函数调用在内部使用了形如 `*formatString* % *value*` 的表达式。'
- en: As you know, the `%` operator in an expression of the form `*integer* % *integer*`
    means "compute the remainder". A `%` operator in an expresson of the form `*formatString*
    % *value*` means convert `*value*` to a string as directed by `*formatString*`.
    The [Python documentation for string formatting operations](http://docs.python.org/library/stdtypes.html#string-formatting)
    describes the `%` operator thoroughly. Thereby, indirectly, it describes the `stdio.writef()`
    function thoroughly as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，表达式 `*integer* % *integer*` 中的 `%` 运算符表示“计算余数”。表达式 `*formatString* % *value*`
    中的 `%` 运算符表示根据 `*formatString*` 的指示将 `*value*` 转换为字符串。[Python 字符串格式化操作的文档](http://docs.python.org/library/stdtypes.html#string-formatting)详细描述了
    `%` 运算符。因此，间接地，它也详细描述了 `stdio.writef()` 函数。
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Input
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输入
- en: 'Our `stdio.py` module supports standard input, an abstract data stream that
    may be empty or can contain a sequence of values separated by white space. Each
    value is a string or a value of one of Python''s primitive types. One of the key
    features of the standard input stream is that your program *consumes* values when
    it reads them. Once your program has read a value, it cannot back up and read
    it again. This is the part of the `stdio` module that is relevant to standard
    input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `stdio.py` 模块支持标准输入，这是一个可能为空或包含一系列由空格分隔的值的抽象数据流。每个值都是一个字符串或 Python 的原始类型之一。标准输入流的一个关键特点是，当程序读取值时，程序会*消耗*这些值。一旦程序读取了一个值，它就不能回退并再次读取。这是与标准输入相关的
    `stdio` 模块的一部分：
- en: '![API for booksite functions related to standard input](../Images/f2bceb0ae2f3601dbc989095dedf2117.png)'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![与标准输入相关的 booksite 函数的 API](../Images/f2bceb0ae2f3601dbc989095dedf2117.png)'
- en: 'These functions fall into one of three categories: those for reading individual
    tokens, one at a time, and converting each to an integer, float, boolean or string;
    those for reading lines from standard input, one at a time; and those for reading
    a sequence of values of the same type (returning the values in an array). Generally,
    it is best not to mix functions from the different categories in the same program.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数分为三类：逐个读取单个标记并将每个标记转换为整数、浮点数、布尔值或字符串的函数；逐行从标准输入读取行的函数；以及读取相同类型值序列的函数（将值返回为数组）。通常最好不要在同一个程序中混合来自不同类别的函数。
- en: We now consider a few example programs that illustrate how to use standard input.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑一些示例程序，演示如何使用标准输入。
- en: '![Anatomy of a command](../Images/bd03485a2948affc7ed29326a1e79038.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![命令的解剖](../Images/bd03485a2948affc7ed29326a1e79038.png)'
- en: Typing input.
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入输入。
- en: The program [addints.py](addints.py.html) accepts a command-line argument `n`.
    Then it reads `n` numbers from standard input, computes their sum, and writes
    the sum to standard output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[addints.py](addints.py.html)接受一个命令行参数 `n`。然后它从标准输入读取 `n` 个数字，计算它们的总和，并将总和写入标准输出。
- en: 'When you use the `python` command to run a Python program from the command
    line, you actually are doing three things: (i) issuing a command to start executing
    your program, (ii) specifying the values of the command-line arguments, and (iii)
    beginning to define the standard input stream. The string of characters that you
    type in the terminal window after the command line is the standard input stream.
    When you type characters, you are interacting with your program. The program *waits*
    for you to create the standard input stream.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`python`命令从命令行运行Python程序时，实际上您正在做三件事：（i）发出命令开始执行您的程序，（ii）指定命令行参数的值，以及（iii）开始定义标准输入流。在命令行之后在终端窗口中键入的字符序列是标准输入流。当您输入字符时，您正在与您的程序交互。程序*等待*您创建标准输入流。
- en: 'When you type `python addints.py`, after accepting the command-line argument
    the program calls `stdio.readInt()` and waits for you to type an integer. Suppose
    that you want `144` to be the first input: as you type `1`, then `4`, and then
    `4`, nothing happens, because `stdio` does not know that you are done typing the
    integer, but when you then type `<return>` to signify the end of your integer,
    `stdio.readInt()` immediately returns the value 144\. After you have typed four
    numbers in this way, the program expects no more input and writes the sum to standard
    output, as desired.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入`python addints.py`时，在接受命令行参数后，程序调用`stdio.readInt()`并等待您输入一个整数。假设您希望`144`是第一个输入���当您输入`1`，然后`4`，然后`4`时，什么也不会发生，因为`stdio`不知道您何时完成输入整数，但当您输入`<return>`表示您的整数结束时，`stdio.readInt()`立即返回值144。在这种方式输入四个数字后，程序不再期望更多输入，并将总和写入标准输出，如所需。
- en: If you type `abc` or `12.2` or `True` when `stdio.readInt()` is expecting an
    integer, then it will respond with a `ValueError`. The format for each type is
    the same as you have been using for literal values within Python programs. `stdio`
    treats strings of consecutive whitespace characters as identical to one space
    and allows you to delimit your numbers with such strings. It doesn't matter how
    many spaces you put between numbers, whether you enter numbers on one line or
    separate them with tab characters or spread them out over several lines, (except
    that your terminal application processes standard input one line at a time, so
    it will wait until you type `<return>` before sending all of the numbers on that
    line to standard input). You can mix values of different types in an input stream,
    but each time that the program expects a value of a particular type, there needs
    to be a value of that type in the input stream.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`stdio.readInt()`期望整数时输入`abc`、`12.2`或`True`，那么它将返回`ValueError`。每种类型的格式与您在Python程序中使用的文字值的格式相同。`stdio`将连续的空白字符字符串视为一个空格，并允许您用这些字符串来分隔数字。无论您在数字之间放置多少空格，无论您是在一行上输入数字还是用制表符分隔它们或者将它们分散在几行上（除了您的终端应用程序一次处理标准输入一行，因此它将等到您输入`<return>`后才将该行上的所有数字发送到标准输入）。您可以在输入流中混合不同类型的值，但每次程序期望特定类型的值时，输入流中都需要有该类型的值。
- en: Interactive user input.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式用户输入。
- en: The program [twentyquestions.py](twentyquestions.py.html) plays a simple guessing
    game. You type numbers, each of which is an implicit question (*Is this the number?*)
    and the program tells you whether your guess is too high or too low.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[twentyquestions.py](twentyquestions.py.html)玩一个简单的猜谜游戏。您输入数字，每个数字都是一个隐式问题（*这是数字吗？*），程序会告诉您您的猜测是太高还是太低。
- en: That program illustrates interactive user input. That is, it illustrates that
    a program can interleave writing to standard output and reading from standard
    input, thereby interacting with the user during program execution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序说明了交互式用户输入。也就是说，它说明了程序可以交替写入标准输出和从标准输入读取，从而在程序执行期间与用户交互。
- en: Processing an arbitrary-size input stream
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理任意大小的输入流
- en: The program [average.py](average.py.html) reads a sequence of floats from standard
    input and writes their average to standard output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[average.py](average.py.html)从标准输入读取一系列浮点数，并将它们的平均值写入标准输出。
- en: 'Typically, input streams are finite: your program marches through the input
    stream, consuming values until the stream is empty. But there is no restriction
    on the size of the input stream. That program illustrates a key property of using
    an input stream: the length of the stream is not known to the program. We type
    all the numbers that we have, then the program averages them. Before reading each
    number, the program calls `stdio.isEmpty()` to check whether there are any more
    numbers in standard input.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，输入流是有限的：您的程序遍历输入流，消耗值直到流为空。但是输入流的大小没有限制。该程序说明了使用输入流的一个关键特性：程序不知道流的长度。我们输入所有的数字，然后程序对它们求平均值。在读取每个数字之前，程序调用`stdio.isEmpty()`来检查标准输入中是否还有更多数字。
- en: How do you signal that we have no more data to type? By convention, we type
    a special sequence of characters known as the *end-of-file sequence*. It is `<ctrl-d>`
    on OS X and Linux, and it is `<ctrl-z>` on Windows. On some systems the end-of-file
    sequence must appear on its own line. Typing the end-of-file sequence indicates
    that standard input is empty.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有更多数据可输入时，如何发出信号？按照惯例，我们输入一系列特殊字符，称为*文件结尾序列*。在OS X和Linux上是`<ctrl-d>`，在Windows上是`<ctrl-z>`。在某些系统上，文件结尾序列必须单独出现在一行上。输入文件结尾序列表示标准输入为空。
- en: '* * *'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Redirection and Piping
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向和管道
- en: For many applications, typing input data as a standard input stream from the
    terminal window is untenable because doing so limits our program's processing
    power by the amount of data that we can type. Similarly, we often want to save
    the information printed on the standard output stream for later use. We can use
    operating system mechanisms to address both issues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，从终端窗口将输入数据作为标准输入流输入是不可行的，因为这样做会限制我们程序的处理能力，限制了我们可以输入的数据量。同样，我们经常希望保存标准输出流上打印的信息以供以后使用。我们可以使用操作系统机制来解决这两个问题。
- en: Redirecting standard output to a file.
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将标准输出重定向到文件。
- en: 'By adding a simple directive to the command that invokes a program, we can
    *redirect* its standard output to a file, for permanent storage or for input to
    some other program at a later time. For example, the command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向调用程序的命令添加一个简单的指令，我们可以*重定向*其标准输出到文件，以便永久存储或在以后的某个时间输入到其他程序中。例如，命令：
- en: '![Redirecting standard output to a file](../Images/f81ee3a0c1f7cb00a518882b6eb2129f.png)'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![将标准输出管道到文件](../Images/f81ee3a0c1f7cb00a518882b6eb2129f.png)'
- en: 'specifies that the standard output stream is not to be written in the terminal
    window, but instead is to be written to a text file named `data.txt`. Each call
    to `stdio.write()` or `stdio.writeln()` appends text at the end of that file.
    In this example, the end result is a file that contains 1,000 random values. No
    output appears in the terminal window: it goes directly into the file named after
    the `>` symbol. Thus, we can save away information for later retrieval.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了标准输出流不写入终端窗口，而是写入名为`data.txt`的文本文件。每次调用`stdio.write()`或`stdio.writeln()`都会将文本追加到该文件的末尾。在这个例子中，最终结果是一个包含1,000个随机值的文件。终端窗口中不会显示任何输出：它直接进入以`>`符号命名的文件中。因此，我们可以保存信息以供以后检索。
- en: Redirecting standard input from a file.
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件重定向标准输入。
- en: 'Similarly, we can redirect standard input so that a program reads data from
    a file instead of the terminal application. For example, the command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以重定向标准输入，使程序从文件而不是终端应用程序读取数据。例如，命令：
- en: '![Redirecting from a file to standard input](../Images/74a02d6b2dadb77d21cf7da32b14f8de.png)'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![从文件重定向到标准输入](../Images/74a02d6b2dadb77d21cf7da32b14f8de.png)'
- en: reads a sequence of numbers from the file `data.txt`, computes their average,
    and writes the average to standard output. Specifically, the `<` symbol is a directive
    to implement the standard input stream by reading from the file `data.txt` instead
    of by waiting for the user to type something into the terminal window. When the
    program calls `stdio.readFloat()`, the operating system reads the value from the
    file. This facility to redirect standard input from a file enables us to process
    huge amounts of data from any source with our programs, limited only by the size
    of the files that we can store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件`data.txt`读取一系列数字，计算它们的平均值，并将平均值写入标准输出。具体来说，`<`符号是一个指令，通过从文件`data.txt`而不是等待用户在终端窗口中键入来实现标准输入流。当程序调用`stdio.readFloat()`时，操作系统从文件中读取值。这种从文件重定向标准输入的功能使我们能够处理来自任何来源的大量数据，仅受我们可以存储的文件大小限制。
- en: Connecting two programs.
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接两个程序。
- en: 'The most flexible way to implement the standard input and standard output abstractions
    is to specify that they are implemented by our own programs! This mechanism is
    called *piping*. For example, the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实现标准输入和标准输出抽象的最灵活方式是指定它们由我们自己的程序实现！这种机制称为*piping*。例如，以下命令：
- en: '![Piping the output of one program to the input of another](../Images/f7463e2a5da03bcb35a2c2953764a00a.png)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![将一个程序的输出管道到另一个程序的输入](../Images/f7463e2a5da03bcb35a2c2953764a00a.png)'
- en: 'specifies that the standard output stream for [randomseq.py](randomseq.py.html)
    and the standard input stream for [average.py](average.py.html) are the *same*
    stream. That is, the result has the same effect as the following sequence of commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了[随机序列.py](randomseq.py.html)的标准输出流和[平均值.py](average.py.html)的标准输入流是*相同*的流。也就是说，结果与以下命令序列具有相同效果：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: but the file `data.txt` is not needed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但文件`data.txt`是不需要的。
- en: Filters.
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器。
- en: For many common tasks, it is convenient to think of each program as a filter
    that converts a standard input stream to a standard output stream in some way,
    with piping as the command mechanism to connect programs together. For example,
    [rangefilter.py](rangefilter.py.html) takes two command-line arguments and writes
    to standard output those numbers from standard input that fall within the specified
    range.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多常见任务，将每个程序视为以某种方式将标准输入流转换为标准输出流的过滤器，并使用管道作为连接程序的命令机制是方便的。例如，[范围过滤器.py](rangefilter.py.html)接受两个命令行参数，并将标准输入中落在指定范围内的数字写入标准输出。
- en: 'Several standard filters that were designed for Unix still survive (sometimes
    with different names) as commands in modern operating systems. For example, the
    `sort` filter reads the lines from standard input and writes them to standard
    output in sorted order:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些为Unix设计的标准过滤器仍然存在（有时使用不同的名称）作为现代操作系统中的命令。例如，`sort`过滤器从标准输入读取行并按排序顺序写入标准输出：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another useful filter is `more`, which reads data from standard input and displays
    it in your terminal window one screenful at a time. For example, if you type
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的过滤器是`more`，它从标准输入读取数据，并在您的终端窗口中一次显示一个屏幕。例如，如果您键入
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: you will see as many numbers as fit in your terminal window, but more will wait
    for you to hit the space bar before displaying each succeeding screenful.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端窗口中看到尽可能多的数字，但更多的数字将等待您按空格键，然后显示每个后续屏幕。
- en: '* * *'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Drawing
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准绘图
- en: 'Now we introduce an abstraction for producing drawings as output. We imagine
    an abstract drawing device capable of drawing lines and points on a two-dimensional
    "canvas" and then displaying that canvas on your screen in the standard drawing
    window. The device is capable of responding to the commands that our programs
    issue in the form of calls to functions in the `stddraw` module. The module''s
    API consists of two kinds of functions: drawing functions that cause the device
    to take an action (such as drawing a line or drawing a point) and control functions
    that control how the drawing is shown and set parameters such as the pen size
    or the coordinate scales.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍一个用于生成绘图输出的抽象。我们想象一个抽象的绘图设备，能够在二维“画布”上绘制线条和点，然后在标准绘图窗口中显示该画布在您的屏幕上。该设备能够响应我们程序发出的命令，形式为对`stddraw`模块中函数的调用。该模块的API由两种函数组成：绘图函数会导致设备执行动作（如绘制线条或绘制点），控制函数控制绘图的显示方式并设置参数，如笔的大小或坐标比例。
- en: Creating drawings.
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建绘图。
- en: 'The basic functions for drawing are described in this API:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图的基本函数在此 API 中描述：
- en: '![Stddraw drawing functions](../Images/be5a9d719c6cd328aed3a7d9cacd0406.png)'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw 绘图函数](../Images/be5a9d719c6cd328aed3a7d9cacd0406.png)'
- en: 'The drawing functions are nearly self-documenting: `stddraw.line()` draws a
    straight line segment connecting two points whose coordinates are given as arguments
    and `stddraw.point()` draws a dot centered at the given coordinates. The default
    coordinate scale is the unit square (all coordinates between 0 and 1). The point
    (0.0, 0.0) is at the lower left, and the point (1.0, 1.0) is at the upper right
    — thus corresponding to the first quadrant of the familiar Cartesian coordinate
    system. The default settings draw black lines and black points on a white background.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图函数几乎是自解释的：`stddraw.line()` 以给定参数作为坐标绘制连接两点的直线段，`stddraw.point()` 在给定坐标处绘制一个以该坐标为中心的点。默认坐标比例是单位正方形（所有坐标在
    0 到 1 之间）。点 (0.0, 0.0) 在左下角，点 (1.0, 1.0) 在右上角 — 因此对应于熟悉的笛卡尔坐标系的第一象限。默认设置在白色背景上绘制黑色线条和黑色点。
- en: The control function stddraw.show() needs a bit more explanation. When your
    program calls any drawing function such as `stddraw.line()` or `stddraw.point()`,
    `stddraw` uses an abstraction known as the *background canvas*. The background
    canvas is not displayed; it exists only in computer memory. All points, lines,
    and so forth are drawn on the background canvas, not directly in the standard
    drawing window. Only when you call `stddraw.show()` does your drawing get copied
    from the background canvas to the standard drawing window, where it is displayed
    until the user closes the standard drawing window — typically by clicking on the
    *Close* button in the window's title bar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 控制函数 `stddraw.show()` 需要更多解释。当您的程序调用任何绘图函数，如 `stddraw.line()` 或 `stddraw.point()`
    时，`stddraw` 使用一种称为*背景画布*的抽象。背景画布不会显示；它只存在于计算机内存中。所有点、线条等都是在背景画布上绘制的，而不是直接在标准绘图窗口中。只有当您调用
    `stddraw.show()` 时，您的绘图才会从背景画布复制到标准绘图窗口中，在那里显示，直到用户关闭标准绘图窗口 — 通常通过单击窗口标题栏中的 *关闭*
    按钮。
- en: Why does `stddraw` need to use a background canvas? The main reason is that
    use of two canvases instead of one makes the `stddraw` module more efficient.
    Incrementally displaying a complex drawing as it is being created can be intolerably
    inefficient on many computer systems. In computer graphics, this technique is
    known as *double buffering*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `stddraw` 需要使用背景画布？主要原因是使用两个画布而不是一个使 `stddraw` 模块更有效率。在许多计算机系统上，逐步显示正在创建的复杂图形可能效率低下。在计算机图形中，这种技术称为*双缓冲*。
- en: 'To summarize the information that you need to know, a typical program using
    the stddraw module has this structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结您需要了解的信息，使用 stddraw 模块的典型程序具有以下结构：
- en: Import the `stddraw` module.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 `stddraw` 模块。
- en: Call drawing functions such as `stddraw.line()` and `stddraw.point()` to create
    a drawing on the background canvas.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用诸如 `stddraw.line()` 和 `stddraw.point()` 等绘图函数在背景画布上创建绘图。
- en: Call `stddraw.show()` to show the background canvas in the standard drawing
    window and wait until the window is closed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `stddraw.show()` 来显示标准绘图窗口中的背景画布，并等待窗口关闭。
- en: Your first drawing.
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的第一个绘图。
- en: The "Hello, World" equivalent for graphics programming with `stddraw` is to
    draw a triangle with a point inside. To form the triangle, we draw three lines.
    The program [triangle.py](triangle.py.html) is the full program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `stddraw` 进行图形编程的“Hello, World”等价物是绘制一个带有内部点的三角形。为了形成三角形，我们绘制三条线。程序 [triangle.py](triangle.py.html)
    是完整的程序。
- en: Saving a drawing.
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存绘图。
- en: You can save the standard drawing window canvas to a file. To do so, right-click
    anywhere on the window canvas. After you do that, `stddraw` displays a file dialog
    box which allows you to specify a file name. Then, after you type a file name
    into the dialog box and click the *Save* button, `stddraw` saves the window canvas
    to a file with the specified name. The file name must end with either `.jpg` (to
    save the window canvas in JPEG format) or `.png` (to save the window canvas in
    "Portable Network Graphics" format). The drawings generated by the graphics programs
    shown in this chapter were saved to files using this mechanism.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将标准绘图窗口画布保存到文件中。要这样做，请在窗口画布的任何位置右键单击。这样做后，`stddraw` 将显示一个文件对话框，允许您指定文件名。然后，在对话框中输入文件名并单击
    *保存* 按钮后，`stddraw` 将窗口画布保存到指定名称的文件中。文件名必须以 `.jpg` 结尾（以 JPEG 格式保存窗口画布）或 `.png`
    结尾（以“便携式网络图形”格式保存窗口画布）。本章中显示的图形程序生成的图形是使用此机制保存到文件中的。
- en: Control commands.
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制命令。
- en: 'The default coordinate system for standard drawing is the unit square, but
    we often want to draw plots at different scales. Also, we often want to draw lines
    of different thickness and points of different size from the standard. To accommodate
    these needs, stddraw has these functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 标准绘图的默认坐标系是单位正方形，但我们经常希望以不同比例绘制图形。此外，我们经常希望绘制不同粗细的线条和不同大小的点。为了满足这些需求，stddraw
    提供了以下函数：
- en: '![Stddraw control functions](../Images/e5e583116f3a4614dd9b0fd91344160b.png)'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw 控制函数](../Images/e5e583116f3a4614dd9b0fd91344160b.png)'
- en: For example, when you call the function `stddraw.setXscale(0, n)`, you are telling
    the drawing device that you will be using x-coordinates between 0 and `n`. Note
    that the two-call sequence
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您调用函数 `stddraw.setXscale(0, n)` 时，您告诉绘图设备您将使用 0 到 `n` 之间的 x 坐标。请注意，两次调用序列
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: sets the drawing coordinates to be within a bounding box whose lower-left corner
    is at (`x0`, `y0`) and whose upper-right corner is at (`x1`, `y1`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将绘图坐标设置为一个边界框，其左下角在 (`x0`, `y0`) 处，右上角在 (`x1`, `y1`) 处。
- en: Filtering data to a standard drawing.
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据过滤到标准绘图。
- en: The program [plotfilter.py](plotfilter.py.html) reads a sequence of points defined
    by (*x*, *y*) coordinates and draws a spot at each point. It adopts the convention
    that the first four numbers read from standard input specify the bounding box,
    so that it can scale the plot. Try running it with its standard input redirected
    to [usa.txt](usa.txt).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[plotfilter.py](plotfilter.py.html)读取由(*x*, *y*)坐标定义的一系列点，并在每个点处绘制一个点。它采用的约定是从标准输入读取的前四个数字指定了边界框，以便它可以缩放绘图。尝试将其标准输入重定向到[usa.txt](usa.txt)运行。
- en: '![Plot Filter](../Images/caafbb4c33928ae3857b4b8320ac0ac2.png)'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![绘图滤镜](../Images/caafbb4c33928ae3857b4b8320ac0ac2.png)'
- en: Plotting a function graph.
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制函数图。
- en: The program functiongraph.py plots the function *y* = sin(4*x*) + sin(20*x*)
    in the interval (0, π). There are an infinite number of points in the interval,
    so we have to make do with evaluating the function at a finite number of points
    within the interval. We sample the function by choosing a set of *x* values, then
    computing *y* values by evaluating the function at each *x* value. Plotting the
    function by connecting successive points with lines produces what is known as
    a *piece-wise linear approximation*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 程序functiongraph.py在区间(0, π)中绘制函数*y* = sin(4*x*) + sin(20*x*)。在区间中有无限多个点，所以我们必须通过在区间内的有限数量的点评估函数来处理。我们通过选择一组*x*值来对函数进行采样，然后通过在每个*x*值处评估函数来计算*y*值。通过连接连续点以线条绘制函数产生了所谓的*分段线性逼近*。
- en: '![Function Graph](../Images/dd040dd9c16597b9b779dbf8a70f3e7c.png)'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![函数图](../Images/dd040dd9c16597b9b779dbf8a70f3e7c.png)'
- en: Outline and filled shapes.
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮廓和填充形状。
- en: 'The `stddraw` module also includes functions to draw circles, rectangles, and
    arbitrary polygons. Each shape defines an outline. When the function name is just
    the shape name, that outline is traced by the drawing pen. When the name begins
    with `filled`, the named shape is instead filled solid, not traced. As usual,
    we summarize the available functions in an API:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`stddraw`模块还包括用于绘制圆、矩形和任意多边形的函数。每个形状定义一个轮廓。当函数名只是形状名时，轮廓由绘图笔描绘。当名称以`filled`开头时，命名的形状实际上是填充的实心形状，而不是描绘的。通常情况下，我们在API中总结可用的函数：'
- en: '![Stddraw Shape Functions](../Images/be276ec307cada3f34b601e536cffd55.png)'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw形状函数](../Images/be276ec307cada3f34b601e536cffd55.png)'
- en: The arguments for `stddraw.circle()` define a circle of radius `r` centered
    at (`x`, `y`); the arguments for `stddraw.square()` define a square of side length
    2`r` centered at (`x`, `y`); and the arguments for `stddraw.polygon()` define
    a sequence of points that we connect by lines, including one from the last point
    to the first point.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`stddraw.circle()`的参数定义了以(`x`, `y`)为中心的半径为`r`的圆；`stddraw.square()`的参数定义了以(`x`,
    `y`)为中心的边长为2`r`的正方形；`stddraw.polygon()`的参数定义了我们通过线连接的一系列点，包括从最后一个点到第一个点的线。 '
- en: Text and color.
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本和颜色。
- en: To annotate or highlight various elements in your drawings, `stddraw` includes
    methods for drawing text, setting the font, and setting the the ink in the pen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注释或突出显示绘图中的各种元素，`stddraw`包括用于绘制文本、设置字体和设置笔墨水的方法。
- en: '![Stddraw Text and Color Functions](../Images/c545ee1ca12c634b0995ddaccf4c392f.png)'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw文本和颜色函数](../Images/c545ee1ca12c634b0995ddaccf4c392f.png)'
- en: In this code, color and fonts use types that you will learn about in Section
    3.1\. Until then, we leave the details to `stddraw`. The available pen colors
    are `BLACK`, `BLUE`, `CYAN`, `DARK_GRAY`, `GRAY`, `GREEN`, `LIGHT_GRAY`, `MAGENTA`,
    `ORANGE`, `PINK`, `RED`, `WHITE`, and `YELLOW`, defined as constants within `stddraw`.
    For example, the call `stddraw.setPenColor(stddraw.GRAY)` changes to gray ink.
    The default ink color is black; the default font is a 12-point plain Helvetica
    font.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，颜色和字体使用的类型将在第3.1节中学习。在那之前，我们将细节留给`stddraw`。可用的笔颜色是`BLACK`、`BLUE`、`CYAN`、`DARK_GRAY`、`GRAY`、`GREEN`、`LIGHT_GRAY`、`MAGENTA`、`ORANGE`、`PINK`、`RED`、`WHITE`和`YELLOW`，这些都是在`stddraw`中定义的常量。例如，调用`stddraw.setPenColor(stddraw.GRAY)`会更改为灰色墨水。默认墨水颜色是黑色；默认字体是12点普通Helvetica字体。
- en: 'These code fragments illustrate some stddraw functions for drawing shapes and
    text:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码片段展示了一些用于绘制形状和文本的stddraw函数：
- en: '![Stddraw Examples](../Images/333b2b1ca409cb9834444047a33e2e93.png)'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw示例](../Images/333b2b1ca409cb9834444047a33e2e93.png)'
- en: Animation
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画
- en: 'If we provide an argument to `stddraw.show()`, then that call need not be the
    last action of a program: it will copy the background canvas to the standard drawing
    window and then wait for the specified number of milliseconds. As you will soon
    see, we can use this capability (coupled with the ability to erase, or clear the
    background canvas) to produce the effect of motion in the `stddraw` window.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`stddraw.show()`提供参数，则该调用不需要是程序的最后一个动作：它将将背景画布复制到标准绘图窗口，然后等待指定的毫秒数。很快你会看到，我们可以利用这种能力（结合擦除或清除背景画布的能力）在`stddraw`窗口中产生运动效果。
- en: '![Stddraw Animation Functions](../Images/3ee86ef42aaba67179cd0e380b5338ef.png)'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stddraw动画函数](../Images/3ee86ef42aaba67179cd0e380b5338ef.png)'
- en: 'The "Hello, World" program for animation is to produce a black ball that appears
    to move around on the canvas. Suppose that the ball is at position (*r[x]* , *r[y]*)
    and we want to create the impression of moving it to a new position nearby, such
    as, for example, (*r[x]* + 0.01, *r[y]* + 0.02). We do so in three steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的“Hello, World”程序是在画布上产生一个黑色球，看起来在画布上移动。假设球在位置(*r[x]*，*r[y]*)，我们想要给人一种将其移动到附近新位置的印象，例如，例如，(*r[x]*
    + 0.01, *r[y]* + 0.02)。我们分三步进行：
- en: Clear the background canvas.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除背景画布。
- en: Draw a black ball at the new position.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新位置绘制一个黑色球。
- en: Show the drawing and wait for a short while.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示绘图并等待片刻。
- en: To create the illusion of movement, we iterate these steps for a whole sequence
    of positions (one that will form a straight line, in this case). The argument
    to `stddraw.show()` quantifies "a short while" and controls the apparent speed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了营造运动的错觉，我们对一整个位置序列（在这种情况下将形成一条直线）进行迭代这些步骤。`stddraw.show()`的参数量化了“短暂的时间”，控制了视觉速度。
- en: 'The program [bouncingball.py](bouncingball.py.html) implements these steps
    to create the illusion of a ball moving in the 2-by-2 box centered at the origin.
    The current position of the ball is (*r[x]* , *r[y]*), and we compute the new
    position at each step by adding *v[x]* to *r[x]* and *v[y]* to *r[y]*. Since (*v[x]*
    , *v[y]*) is the fixed distance that the ball moves in each time unit, it represents
    the velocity. To keep the ball in the drawing, we simulate the effect of the ball
    bouncing off the walls according to the laws of elastic collision. This effect
    is easy to implement: when the ball hits a vertical wall, we just change the velocity
    in the *x*-direction from *v[x]* to -*v[x]*, and when the ball hits a horizontal
    wall, we change the velocity in the *y*-direction from *v[y]* to -*v[y]*. The
    images below, which show the track of the ball, are produced by a modified version
    of this code (see an exercise at the end of this section).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[bouncingball.py](bouncingball.py.html)实现了这些步骤，以创建一个球在以原点为中心的2x2盒子中移动的幻觉。球的当前位置是(*r[x]*
    , *r[y]*)，我们通过在每一步中将*v[x]*加到*r[x]*和*v[y]*加到*r[y]*来计算新位置。由于(*v[x]* , *v[y]*)是球在每个时间单位移动的固定距离，它代表速度。为了保持球在绘图中，我们模拟球按照弹性碰撞定律弹跳到墙壁的效果。这个效果很容易实现：当球撞到垂直墙壁时，我们只需将*x*方向上的速度从*v[x]*改变为-*v[x]*，当球撞到水平墙壁时，我们将*y*方向上的速度从*v[y]*改变为-*v[y]*。下面的图像显示了球的轨迹，这些图像是由这段代码的修改版本生成的（请参见本节末尾的一个练习）。
- en: '![Bouncing Ball](../Images/c550daeebfaec00d6fc0fb9079a558c9.png)'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![弹跳球](../Images/c550daeebfaec00d6fc0fb9079a558c9.png)'
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Standard Audio
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准音频
- en: 'The stdaudio module can play, manipulate, and synthesize sound. It allows you
    to play `.wav` files, to compose programs to create and manipulate arrays of floats,
    and to read and write them as .wav files:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: stdaudio模块可以播放、操作和合成声音。它允许你播放`.wav`文件，编写程序来创建和操作浮点数组，并将它们读取和写入为.wav文件：
- en: '![The Stdaudio Module](../Images/2bfde5c07d2c0a04334d0973cd8e096c.png)'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Stdaudio模块](../Images/2bfde5c07d2c0a04334d0973cd8e096c.png)'
- en: We first introduce some some basic concepts behind one of the oldest and most
    important areas of computer science and scientific computing, which is known as
    *digital signal processing*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍计算机科学和科学计算中最古老和最重要领域之一的一些基本概念，这个领域被称为*数字信号处理*。
- en: Concert A.
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协奏A。
- en: Sound is the perception of the vibration of molecules — in particular, the vibration
    of our eardrums. Therefore, oscillation is the key to understanding sound. Perhaps
    the simplest place to start is to consider the musical note A above middle C,
    which is known as *concert A*. This note is nothing more than a sine wave, scaled
    to oscillate at a frequency of 440 times per second. The function sin(*t*) repeats
    itself once every 2π units, so if we measure *t* in seconds and plot the function
    sin(2π*t* × 440), we get a curve that oscillates 440 times per second. We measure
    frequency in [hertz](https://en.wikipedia.org/wiki/Hertz) (cycles per second).
    When you double or halve the frequency, you move up or down one octave on the
    scale. For example, 880 hertz is one octave above concert A and 110 hertz is two
    octaves below concert A. For reference, the frequency range of human hearing is
    about 20 to 20,000 hertz. The amplitude (*y*-value) of a sound corresponds to
    the volume. We assume it is scaled to be betwen -1 and +1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是分子振动的感知，特别是我们耳膜的振动。因此，振荡是理解声音的关键。也许最简单的起点是考虑中央C上方的音符A，也称为*协奏A*。这个音符只不过是一个正弦波，按照每秒振荡440次的频率进行缩放。函数sin(*t*)每2π单位重复一次，因此如果我们以秒为单位测量*t*并绘制函数sin(2π*t*
    × 440)，我们得到一个每秒振荡440次的曲线。我们用[hertz](https://en.wikipedia.org/wiki/Hertz)（每秒循环次数）来衡量频率。当你将频率加倍或减半时，你在音阶上向上或向下移动一个八度。例如，880赫兹是协奏A的一个八度，110赫兹是协奏A的两个八度下方。作为参考，人类听觉的频率范围约为20至20,000赫兹。声音的振幅（*y*-值）对应于音量。我们假设它被缩放在-1到+1之间。
- en: Other notes.
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他注意事项。
- en: A simple mathematical formula characterizes the other notes on the chromatic
    scale. There are 12 notes on the chromatic scale, divided equally on a logarithmic
    (base 2) scale. We get the *i*th note above a given note by multiplying its frequency
    by the (*i*/12)th power of 2\. In other words, the frequency of each note in the
    chromatic scale is precisely the frequency of the previous note in the scale multiplied
    by the twelfth root of 2 (about 1.06). This information suffices to create music!
    For example, to play the tune *Frere Jacques*, we just need to play each of the
    notes A B C# A by producing sine waves of the appropriate frequency for about
    half a second and then repeat the pattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的数学公式描述了半音音阶上的其他音符。半音音阶上有12个音符，均匀分布在对数（以2为底）刻度上。我们通过将给定音符的频率乘以2的(*i*/12)次方来得到半音音阶上的第*i*个音符。换句话说，半音音阶上每个音符的频率恰好是音阶上前一个音符的频率乘以2的十二次方根（约为1.06）。这些信息足以创作音乐！例如，要演奏曲调*Frere
    Jacques*，我们只需要通过产生适当频率的正弦波来演奏A B C# A的每个音符约半秒钟，然后重复这个模式。
- en: '![Piano](../Images/0253880a42ad78551d58e4e5abeebb4b.png)'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![钢琴](../Images/0253880a42ad78551d58e4e5abeebb4b.png)'
- en: Sampling.
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采样。
- en: '![Sampling a Sine Wave](../Images/56ad6ea035a54e2c749c1374ca7f2df0.png)For
    digital sound, we represent a curve by sampling it at regular intervals, in precisely
    the same manner as when we plot function graphs. We sample sufficiently often
    that we have an accurate representation of the curve &mdot; a widely used sampling
    rate for digital sound is 44,100 samples per second. For concert A, that rate
    corresponds to plotting each cycle of the sine wave by sampling it at about 100
    points. Since we sample at regular intervals, we need to compute only the *y*
    coordinates of the sample points. It is that simple: we represent sound as an
    array of numbers (float values that are between -1 and +1). Our booksite sound
    module function `stdaudio.playSamples()` takes an array of floats as its argument
    and plays the sound represented by that array on your computer.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that you want to play concert A for 10 seconds. At 44,100
    samples per second, you need an array of 441,001 float values. To fill in the
    array, use a `for` loop that samples the function sin(2π*t* × 440) at *t* = 0/44100,
    1/44100, 2/44100, 3/44100, ..., 441000 / 44100\. Once we fill the array with these
    values, we are ready for `stdaudio.playSamples()`, as in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is the "Hello, World" of digital audio. Once you use it to get your
    computer to play this note, you can compose code to play other notes and make
    music!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Saving to a file.
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Music can take up a lot of space on your computer. At 44,100 samples per second,
    a four-minute song corresponds to 4 × 60 × 44100 = 10,584,000 numbers. Therefore,
    it is common to represent the numbers corresponding to a song in a binary format
    that uses less space than the string-of-digits representation that we use for
    standard input and output. Many such formats have been developed in recent years
    — `stdaudio` uses the `.wav` format.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Playing tunes.
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The program [playthattune.py](playthattune.py.html) is an example that shows
    how easily we can create music with `stdaudio`. It takes notes from standard input,
    indexed on the chromatic scale from concert A, and plays them on standard audio.
    Try running it repeatedly with its standard input redirected to each of these
    data files (created by various students): [elise.txt](elise.txt), [ascale.txt](ascale.txt),
    [stairwaytoheaven.txt](stairwaytoheaven.txt), [entertainer.txt](entertainer.txt),
    [firstcut.txt](firstcut.txt), [freebird.txt](freebird.txt), and [looney.txt](looney.txt).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** How can I make the booksite modules stdio, stddraw, and stdaudio available
    to Python?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** If you followed the step-by-step instructions on this booksite for installing
    Python, these modules should already be available to Python.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Are there standard Python modules for handling standard output?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Actually, such features are built into Python. In Python 2, you can
    use the `print` statement to write data to standard output. In Python 3, there
    is no `print` statement; instead, there is a `print()` function, which is similar.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why, then, are we using the booksite stdio module for writing to standard
    output instead of using the features already provided by Python?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Our intention is to compose code that works (as much as possible) with
    all versions of Python. For example, using the `print` statement in all our programs
    would mean they would work with Python 2, but not with Python 3\. Since we use
    `stdio` functions, we just need to make sure that we have the proper library.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How about standard input?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** There are (different) capabilities in Python 2 and Python 3 that correspond
    to `stdio.readLine()`, but nothing corresponding to `stdio.readInt()` and similar
    functions. Again, by using `stdio`, we can compose programs that not just take
    advantage of these additional capabilities, but also work in both versions of
    Python.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How about drawing and sound?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Python does not come with an `audio` library. Python comes with a graphics
    library named `Tkinter` for producing drawings, but it is too slow for some of
    the graphics applications in the book. Our `stddraw` and `stdaudio` modules provide
    easy-to-use APIs, based on the `Pygame` library.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** So, let me get this straight; if I use the format `%2.4f` with `stdio.writef()`
    to write a float, I get two digits before the decimal point and four digits after
    the decimal point, right?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No, that specifies just four digits after the decimal point. The number
    preceding the decimal point is the width of the whole field. You want to use the
    format `%7.2f` to specify seven characters in total — four before the decimal
    point, the decimal point itself, and two digits after the decimal point.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Which other conversion codes are there for `stdio.writef()`?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** For integer values, there are `o` for octal, `x` for hexadecimal; for
    floating point, you can use `e` or `g` to get scientific notation. There are also
    numerous formats for dates and times. The [Python documentation for string formatting
    operations](http://docs.python.org/library/stdtypes.html#string-formatting) provides
    a wealth of information.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can my program reread data from standard input?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No. You get only one shot at it, in the same way that you cannot undo
    a call of `stdio.writeln()`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What happens if my program attempts to read data from standard input
    after it is exhausted?'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Python will raise an `EOFError` at run time. The functions `stdio.isEmpty()`
    and `stdio.hasNextLine()` allow you to avoid such an error by checking whether
    more input is available.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why does `stddraw.square(x, y, r)` draw a square of width 2`r` instead
    of `r`?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** This makes it consistent with the function `stddraw.circle(x, y, r)`,
    where the third argument is the radius of the circle, not the diameter. In this
    context, `r` is the radius of the biggest circle that can fit inside the square.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What happens if my program calls `stddraw.show(0)`?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** That function call tells stddraw to copy the background canvas to the
    standard drawing window, and then wait 0 milliseconds (that is, do not wait at
    all) before proceeding. That function call is appropriate if, for example, you
    want to run an animation at the fastest rate supported by your computer.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I draw curves other than circles with `stddraw`?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** We had to draw the line somewhere (pun intended), so we support only
    the basic shapes discussed in the text. You can draw other shapes one point at
    a time, as explored in several exercises in the text, but filling them is not
    directly supported.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** So I use negative integers to go below concert A when making input files
    for [playthattune.py](playthattune.py.html)?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Right. Actually, our choice to put concert A at 0 is arbitrary. A popular
    standard, known as the *MIDI Tuning Standard*, starts numbering at the C five
    octaves below concert A. By that convention, concert A is 69 and you do not need
    to use negative numbers.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why do I hear weird results from standard audio when I try to sonify
    a sine wave with a frequency of 30,000 hertz (or more)?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The *Nyquist frequency*, defined as one-half the sampling frequency,
    represents the highest frequency that can be reproduced. For standard audio, the
    sampling frequency is 44,100, so the Nyquist frequency is 22,050.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do I enter the end-of-file sequence if I am redirecting standard
    input from a file?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** When standard input is bound to your terminal application, you eventually
    must enter the end-of-file sequence to inform the program that no more data remains
    to be read from standard input. However when standard input is bound to a file,
    you need not enter the end-of-file sequence. Instead the operating system automatically
    informs your program when no more data remains to be read from the file.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What other conversion codes are there for `stdio.writef()`?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do I print the `%` character within `stdio.writef()`?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Use `%%`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What is the symbol for the end of a line?'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Different operating systems use different symbols. On Unix systems and
    Mac OS X, the newline character is `''\n''`. On Windows each line is terminated
    by a string of two characters `''\r\n''`. On Macs prior to OS X, each line is
    terminated by the string `''\n\r''`. When composing a program, you should avoid
    using operating system specific features or else it might not work as expected
    on other systems. Use `stdio.writeln()` to write a newline.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do I create colors for use with the the `stddraw` module?'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The stddraw module uses a class named `Color` that we defined specifically
    for this booksite. Chapter 3 of the booksite describes that class.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What are the main differences of the PNG, JPEG, and PostScript graphics
    formats?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The graphics on most web pages are in PNG, GIF, or JPEG format. All
    three formats are *raster-based* — they store the set of pixels and color gradations
    needed to represent a picture. PNG and GIF are ideal for displaying figures with
    straight lines and geometric figures, while JPEG is best suited for photographs.
    PostScript is a *vector-based* format. For example, it represents a circle as
    a geometric object instead of a collection of thousands of pixels. The quality
    does not degrade if you enlarge or shrink it. For this reason, most printers use
    PostScript to print documents and graphics.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What does the error message `NameError: name ''stdio'' is not defined`
    mean?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** You probably forgot to install the booksite modules. Of course the same
    applies to `stdarray.py`, `stddraw.py`, and `stdaudio.py`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How can I create an animated GIF?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compose a program that reads in integers (as many as the user enters) from standard
    input and writes the maximum and minimum values to standard output.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [maxmin.py](maxmin.py.html).'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify your program from the previous exercise to insist that the integers must
    be positive (by prompting the user to enter positive integers whenever the value
    entered is not positive).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that accepts an integer *n* from the command line, reads *n*
    floats from standard input, and writes their mean (average value) and standard
    deviation (square root of the sum of the squares of their differences from the
    average, divided by *n*).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [stats2.py](stats2.py.html).'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Extend your program from the previous exercise to create a filter that writes
    all the values that are further than 1.5 standard deviations from the mean.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a program that reads in a sequence of integers and writes both the
    integer that appears in a longest consecutive run and the length of the run. For
    example, if the input is `1 2 2 1 5 1 1 7 7 7 7 1 1`, then your program should
    write `Longest run: 4 consecutive 7s`.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [longestrun.py](longestrun.py.html).'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a filter that reads in a sequence of integers and writes the integers,
    removing repeated values that appear consecutively. For example, if the input
    is `1 2 2 1 5 1 1 7 7 7 7 1 1 1 1 1 1 1 1 1`, your program should write `1 2 1
    5 1 7 1`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that accepts a command-line argument `n`, reads from standard
    input `n-1` distinct integers between 1 and `n`, and determines the missing value.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a program that reads in positive real numbers from standard input and
    writes their geometric and harmonic means. The *geometric mean* of *n* positive
    numbers *x*[1], *x*[2], ..., *x*[*n*] is (*x*[1] × *x*[2] × ... × *x*[*n*])^(1/*n*).
    The *harmonic mean* is *n* / (1/*x*[1] + 1/*x*[2] + ... + 1/*x*[*n*]). *Hint*:
    For the geometric mean, consider taking logarithms to avoid overflow.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that the file `input.txt` contains the two strings F and F. What does
    the following command do? See the exercises from Section 1.2 for more information
    on dragon curves. Here is the Python program [dragon3.py](dragon3.py.html).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compose a filter `tenperline.py` that reads a sequence of integers between 0
    and 99 and writes 10 integers per line, with columns aligned. Then compose a program
    `randomintseq.py` that takes two command-line arguments `m` and `n` and writes
    `n` random integers between 0 and `m`-1\. Test your programs with the command
    `python randomintseq 100 200 | python tenperline.py`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program named `wordcount.py` that reads text from standard input and
    writes to standard output the number of words in the text. For the purpose of
    this exercise, a word is a sequence of non-whitespace characters that is surrounded
    by whitespace. For example, the command `python wordcount < tale.txt` should write
    139043.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [wordcount.py](wordcount.py.html).'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a program that reads lines from standard input with each line containing
    a name and two integers, and then calls `stdio.writef()` to write to standard
    output a table with a column of the names, the integers, and the result of dividing
    the first by the second, accurate to three decimal places. You could use a program
    like this to tabulate batting averages for baseball players or grades for students.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following *require* saving all the values from standard input (in
    an array, say), and which could be implemented as a filter using only a fixed
    number of variables? For each, the input comes from standard input and consists
    of *n* floats between 0 and 1.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the maximum and minimum numbers.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the *k*th smallest value.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the sum of the squares of the numbers.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the average of the numbers.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the percentage of numbers greater than the average.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the numbers in increasing order.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the numbers in random order.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compose a program that writes a table of the monthly payments, remaining principal,
    and interest paid for a loan, taking three numbers as command-line arguments:
    the number of years, the principal, and the interest rate. (See a related exercise
    in Section 1.2.)'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes three command-line arguments *x*, *y*, and *z*,
    reads from standard input a sequence of point coordinates (*x[i]*, *y[i]*, *z[i]*),
    and writes the coordinates of the point closest to (*x*, *y*, *z*). Recall that
    the square of the distance between (*x* , *y* , *z*) and (*x[i]* , *y[i]* , *z[i]*
    ) is (*x* - *x[i]*)² + (*y* - *y[i]*)² + (*z* - *z[i]*)2\. For efficiency, do
    not use either `math.sqrt()` or the `**` operator.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [closest.py](closest.py.html).'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a program that, given the positions and masses of a sequence of objects,
    computes their center-of-mass, or *centroid*. The centroid is the average position
    of the *n* objects, weighted by mass. If the positions and masses are given by
    (*x[i]*, *y[i]*, *m[i]*), then the centroid (*x*, *y*, *m*) is given by
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*m* = *m*[1] + *m*[2] + ... + *m[n]* *x* = (*m*[1]*x*[1] + ... + *m[n]x[n]*)
    / *m* *y* = (*m*[1]*y*[1] + ... + *m[n]y[n]*) / *m*'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compose a program that reads in a sequence of floats between -1 and 1 and writes
    their average magnitude, average power, and the number of zero crossings. The
    *average magnitude* is the average of the absolute values of the data values.
    The *average power* is the average of the squares of the data values. The *number
    of zero crossings* is the number of times a data value transitions from a strictly
    negative number to a strictly positive number, or vice versa. These three statistics
    are widely used to analyze digital signals.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes an integer command-line argument `n` and plots
    an `n`-by-`n` checkerboard with red and black squares. Color the lower left square
    red.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![5-by-5 checkerboard](../Images/dc915cd7e82e99149c9f979d7b7697c2.png) |
    ![8-by-8 checkerboard](../Images/3fc2385ef6145881761d8c3c8084166e.png) | ![25-by-25
    checkerboard](../Images/dd7fef0b179125bf302da039bd3ef0de.png) |'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '*Solution*: See [checkerboard.py](checkerboard.py.html)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a program that takes as command-line arguments an integer `n` and a
    float `p` (between 0 and 1), plots `n` equally spaced points of size on the circumference
    of a circle, and then, with probability `p` for each pair of points, draws a gray
    line connecting them.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![erdos](../Images/023ea815e40c5c9c254daa2561dc9cd9.png) |'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: Compose code to draw hearts, spades, clubs, and diamonds. To draw a heart, draw
    a diamond, then attach two semicircles to the upper left and upper right sides.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes an integer command-line argument `n` and plots
    a "flower" with `n` petals (if `n` is odd) or `2n` petals (if `n` is even) by
    plotting the polar coordinates (*r*, θ) of the function *r* = sin(*n* × θ) for
    θ ranging from 0 to `2π` radians. Below is the desired output for `n` = 4, 7,
    and 8.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![rose](../Images/2e84daf4180b13cde2c8a4d97a62afaa.png) |'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '*Solution*: See [rose.py](rose.py.html).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Compose a program that takes a string `s` from the command line and displays
    it in banner style on the screen, moving from left to right and wrapping back
    to the beginning of the string as the end is reached. Add a second command-line
    argument to control the speed.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [banner.py](banner.py.html).'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify [playthattune.py](playthattune.py.html) to take additional command-line
    arguments that control the volume (multiply each sample value by the volume) and
    the tempo (multiply each note's duration by the tempo).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes the name of a `.wav` file and a playback rate *r*
    as command-line arguments and plays the file at the given rate. First, use `stdaudio.read()`
    to read the file into an array `a[]`. If *r* = 1, just play `a[]`; otherwise create
    a new array `b[]` of approximate size *r* times `len(a)`. If *r < 1*, populate
    `b[]` by *sampling* from the original; if *r > 1*, populate `b[]` by *interpolating*
    from the original. Then play `b[]`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose programs that use `stddraw` to create each of these designs.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![geometric designs](../Images/a15b4d142defa47e917b278ba1440848.png)'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Compose a program that draws filled circles of random size at random positions
    in the unit square, producing images like those below. Your program should take
    four command-line arguments: the number of circles, the probability that each
    circle is black, the minimum radius, and the maximum radius.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![random circles](../Images/acc9096db524d92edc6e8632eda8cec6.png)'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '* * *'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Visualizing audio.** Modify [playthattune.py](playthattune.py.html) to send
    the values played to standard drawing, so that you can watch the sound waves as
    they are played. You will have to experiment with plotting multiple curves in
    the drawing canvas to synchronize the sound and the picture.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Statistical polling.** When collecting statistical data for certain political
    polls, it is very important to obtain an unbiased sample of registered voters.
    Assume that you have a file with *n* registered voters, one per line. Compose
    a filter that writes a random sample of size *m*. (See the [sample.py](../14array/sample.py.html)
    program from Section 1.4.)'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Terrain analysis.** Suppose that a terrain is represented by a two-dimensional
    grid of elevation values (in meters). A peak is a grid point whose four neighboring
    cells (left, right, up, and down) have strictly lower elevation values. Compose
    a program that reads a terrain from standard input and then computes and writes
    the number of peaks in the terrain.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Histogram.** Suppose that the standard input stream is a sequence of floats.
    Compose a program that takes an integer `n` and two floats `lo` and `hi` from
    the command line and uses `stddraw` to plot a histogram of the count of the numbers
    in the standard input stream that fall in each of the `n` intervals defined by
    dividing (`lo`, `hi`) into `n` equal-sized intervals.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spirographs.** Compose a program that accepts three command-line arguments
    *R*, *r*, and *a* and draws the resulting *spirograph*. A [spirograph](https://en.wikipedia.org/wiki/Spirograph)
    (technically, an epicycloid) is a curve formed by rolling a circle of radius *r*
    around a larger fixed circle or radius *R*. If the pen offset from the center
    of the rolling circle is (*r*+*a*), then the equation of the resulting curve at
    time *t* is given by'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Such curves were popularized by a best-selling toy that contains discs with
    gear teeth on the edges and small holes that you could put a pen in to trace spirographs.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [spirograph.py](spirograph.py.html).'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Clock.** Compose a program that displays an animation of the second, minute,
    and hour hands of an analog clock. Use the call `stddraw.show(1000)` to update
    the display roughly once per second.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: this may be one of the rare times when you want to use the `%` operator
    with a float; it works the way you would expect.'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [clock.py](clock.py.html).'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Oscilloscope.** Compose a program to simulate the output of an oscilloscope
    and produce Lissajous patterns. These patterns are named after the French physicist,
    Jules A. Lissajous, who studied the patterns that arise when two mutually perpendicular
    periodic disturbances occur simultaneously. Assume that the inputs are sinusoidal,
    so that the following parametric equations describe the curve:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Take the six parameters *A[x]* and *A[y]* (amplitudes); *w[x]* and *w[y]* (angular
    velocity); and θ*x* and θ*y* (phase factors) from the command line.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, the first image below has *A[x]* = *A[y]* = 1, *w[x]* = 2, *w[y]*
    = 3, θ*[x]* = 20 degrees, θ[*y*] = 45 degrees. The other has parameters (1, 1,
    5, 3, 30, 45)
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ![Oscilloscope 2](../Images/685cbd764bcfabbf9e58f88aaec1b45f.png) | ![Oscilloscope
    3](../Images/61efeb8533a0ef43f16a3bc20564606b.png) |'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '*Solution*: See [oscilloscope.py](oscilloscope.py.html).'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Bouncing ball with tracks**. Modify [bouncingball.py](bouncingball.py.html)
    to produce images like the ones shown earlier in this page, which show the track
    of the ball on a gray background.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bouncing ball with gravity.** Modify [bouncingball.py](bouncingball.py.html)
    to incorporate gravity in the vertical direction. Add calls to `stdaudio.playFile()`
    to add one sound effect when the ball hits a wall and a different one when it
    hits the floor.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random tunes.** Compose a program that uses `stdaudio` to play random tunes.
    Experiment with keeping in key, assigning high probabilities to whole steps, repetition,
    and other rules to produce reasonable melodies.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tile patterns.** In a previous exercise you wrote programs to create tile-like
    designs. Using your solution that exercise, compose a program `tilepattern.py`
    that takes a command-line argument `n` and draws an `n`-by-`n` pattern, using
    the tile of your choice. Add a second command-line argument that adds a checkerboard
    option. Add a third command-line argument for color selection. Using the patterns
    below as a starting point, design a tile floor. Be creative!'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![tiles](../Images/cd274a60c340f86e2780bc64dac44d33.png)'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Note: These are all designs from antiquity that you can find in many ancient
    (and modern) buildings such as from from San Giovanni in Laterno (Basilica of
    St. John Latern) in Rome [ [1](images/IMG_0252.jpg) [2](images/IMG_0253.jpg) [3](images/IMG_0255.jpg)
    [4](images/IMG_0256.jpg) [5](images/IMG_0257.jpg) [6](images/IMG_0260.jpg) ] or
    from the Tile Museum in Lisbon [ [1](images/IMG_0480.jpg) [2](images/IMG_0481.jpg)
    [3](images/IMG_0482.jpg) [4](images/IMG_0483.jpg) [5](images/IMG_0484.jpg) [6](images/IMG_0485.jpg)
    [7](images/IMG_0486.jpg) [8](images/IMG_0487.jpg) [9](images/IMG_0498.jpg) [10](images/IMG_0500.jpg)
    ]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
