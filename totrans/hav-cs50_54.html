<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Abstraction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Abstraction</h1>
<blockquote>原文：<a href="https://cs50.harvard.edu/scratch/notes/8/">https://cs50.harvard.edu/scratch/notes/8/</a></blockquote>

                    

<ul>
  <li data-marker="*">So far, we’ve seen many features of Scratch, with blocks that let us add loops, variables, and conditions to our projects.</li>
  <li data-marker="*">Now, let’s think about how we might be able to improve upon the way that we’ve designed the blocks inside of our Scratch projects.</li>
</ul>

<h2 id="dinosaur-game">Dinosaur Game</h2>

<ul>
  <li data-marker="*">Let’s start by adding a dinosaur sprite to start building our <a href="https://scratch.mit.edu/projects/507462509/">Dinosaur Game</a> example.</li>
  <li data-marker="*">We’ll add blocks so that it can move when the arrow keys are pressed:
    <pre><code class="language-scratch">  when [up arrow v] key pressed
  change y by (10)

  when [down arrow v] key pressed
  change y by (-10)

  when [right arrow v] key pressed
  change x by (10)

  when [left arrow v] key pressed
  change x by (-10)
</code></pre>
  </li>
  <li data-marker="*">We’ll add another sprite, the star, and we can say that we’ve won the game when our dinosaur touches the star.</li>
  <li data-marker="*">Let’s tell our dinosaur to check if it’s touching the star after we’ve moved up:
    <pre><code class="language-scratch">  when [up arrow v] key pressed
  change y by (10)
  if &lt;touching (Star v) ?&gt; then
  say (timer) for (2) seconds
</code></pre>
    <ul>
      <li data-marker="*">Recall that the “if” block is under the Control section of blocks, and “touching?” block is under the Sensing section.</li>
      <li data-marker="*">We’ll also add a “say” block along with the “timer” variable, so that our dinosaur can tell us how long it took to find the star.</li>
    </ul>
  </li>
  <li data-marker="*">But this doesn’t work if we reach the star after we pressed right to get to it.</li>
  <li data-marker="*">We want our dinosaur to check if we’ve reached the star no matter which key we used for it, so we need to right-click, or control-click, on the “if” block, and choose “Duplicate” to make a copy for each key:
    <pre><code class="language-scratch">  when [up arrow v] key pressed
  change y by (10)
  if &lt;touching (Star v) ?&gt; then
  say (timer) for (2) seconds

  when [down arrow v] key pressed
  change y by (-10)
  if &lt;touching (Star v) ?&gt; then
  say (timer) for (2) seconds

  when [right arrow v] key pressed
  change x by (10)
  if &lt;touching (Star v) ?&gt; then
  say (timer) for (2) seconds

  when [left arrow v] key pressed
  change x by (-10)
  if &lt;touching (Star v) ?&gt; then
  say (timer) for (2) seconds
</code></pre>
  </li>
  <li data-marker="*">We’ll also add some code to our star so it moves to a random position every time the program is started:
    <pre><code class="language-scratch">  when green flag clicked
  go to (random position v)
</code></pre>
  </li>
  <li data-marker="*">Now, we can use the arrow keys to move our dinosaur to the star, and every time it will tell us how long we took.</li>
  <li data-marker="*">It looks like the time is reported with decimals, like 9.70. So we can round this time to the nearest number of seconds, with the “round” block in the Operators section.</li>
  <li data-marker="*">But now, we’d have to drag the “round” block into the scripts for each of the four directions.</li>
  <li data-marker="*">When we’re copying a lot of code in our projects, it’s often the case that there’s a better solution.</li>
  <li data-marker="*">In this case, it turns out we can create a new block of our own, and refer back to it every time we need to.</li>
  <li data-marker="*">We’ll look in the section of blocks called “My Blocks”, and click “Make a Block” to make a new block. We’ll name this “check if won”, since that’s what we’re trying to do. Then, we’ll see this block appear:
    <pre><code class="language-scratch">  define check if won
</code></pre>
    <ul>
      <li data-marker="*">Now, we can add blocks underneath, that will run every time we use the “check if won” block.</li>
    </ul>
  </li>
  <li data-marker="*">So we’ll take the condition and the “say” block, and move them to it:
    <pre><code class="language-scratch">  define check if won
  if &lt;touching (Star v) ?&gt; then
  say (timer) for (2) seconds
</code></pre>
  </li>
  <li data-marker="*">And for our other scripts, we’ll drag out our own “check if won” block:
    <pre><code class="language-scratch">  when [up arrow v] key pressed
  change y by (10)
  check if won

  when [down arrow v] key pressed
  change y by (-10)
  check if won

  when [right arrow v] key pressed
  change x by (10)
  check if won

  when [left arrow v] key pressed
  change x by (-10)
  check if won
</code></pre>
    <ul>
      <li data-marker="*">Now, we’re using fewer blocks to achieve the same effect.</li>
    </ul>
  </li>
  <li data-marker="*">If we wanted to round the value of the timer, we can change it just one place now, instead of four:
    <pre><code class="language-scratch">  define check if won
  if &lt;touching (Star v) ?&gt; then
  say (round(timer)) for (2) seconds
</code></pre>
  </li>
  <li data-marker="*">The ability to create our own blocks will allow us to improve the overall design and readability of our projects.</li>
</ul>

<h2 id="balloon">Balloon</h2>

<ul>
  <li data-marker="*">Let’s add a balloon sprite for <a href="https://scratch.mit.edu/projects/507463302/">Balloon 1</a>, and add blocks for it to inflate and deflate itself:
    <pre><code class="language-scratch">  when green flag clicked
  set size to (50) %
  repeat (10)
  change size by (10)
  end
  wait (1) seconds
  repeat (10)
  change size by (-10)
  end
</code></pre>
    <ul>
      <li data-marker="*">Our balloon will start at a size of 50%, increase its size by 10 ten times, wait a second, and then decrease its size by 10 (changing it by negative 10) ten times.</li>
    </ul>
  </li>
  <li data-marker="*">But this code would require someone else to think about what the numbers and loops are doing, to understand what will happen. We can make our code easier to read by adding more blocks.</li>
  <li data-marker="*">We can make a new block called “inflate”, that will increase the size of our balloon by 10 ten times:
    <pre><code class="language-scratch">  define inflate
  repeat (10)
  change size by (10)
  end
</code></pre>
  </li>
  <li data-marker="*">And we’ll make another block called “deflate”, that will decrease the size of our balloon:
    <pre><code class="language-scratch">  define deflate
  repeat (10)
  change size by (-10)
  end
</code></pre>
  </li>
  <li data-marker="*">For the main script, we’ll use our new blocks:
    <pre><code class="language-scratch">  when green flag clicked
  set size to (50) %
  inflate
  wait (1) seconds
  deflate
</code></pre>
    <ul>
      <li data-marker="*">Note that our program does the exact same thing still, but the script under “when flag clicked” is easier to read.</li>
    </ul>
  </li>
  <li data-marker="*">We can call these custom blocks <strong>abstractions</strong>, or taking more complex ideas or actions, and giving them a name that we can refer to and use over and over.</li>
  <li data-marker="*">We can give ourselves even more control in <a href="https://scratch.mit.edu/projects/507463768/">Balloon 2</a>. Let’s right-click, or control-click, the “inflate” block we have, and choose “Edit”. Then, we’ll click “Add an input” to give this block the ability to accept some input, and we’ll call it “n”:<br/>
  <img src="../Images/a261caf502a91780bcb08d42851894a8.png" alt="Make a Block with inflate and n as input" width="717" data-original-src="https://cs50.harvard.edu/scratch/notes/8/block_input.png"/>
    <ul>
      <li data-marker="*">“n” will be the name of the input, and since it will be some number, we can use “n” by convention.</li>
    </ul>
  </li>
  <li data-marker="*">We’ll also click “Add a label”, and change that to say “times”, so our block will look like this:<br/>
  <img src="../Images/6abff0088368a76b984e9d703959a104.png" alt="block with inflate n times" width="272" data-original-src="https://cs50.harvard.edu/scratch/notes/8/inflate_n_times.png"/>
    <ul>
      <li data-marker="*">The label lets us add more words to describe what the block will do.</li>
    </ul>
  </li>
  <li data-marker="*">Notice that our “define” block for “inflate” will show an “n” in an oval that we can use in our block below, so we’ll drag it into the “repeat” block:
    <pre><code class="language-scratch">  define inflate (n) times
  repeat (n)
  change size by (10)
</code></pre>
    <ul>
      <li data-marker="*">Now, “inflate” will increase the balloon’s size by 10 for “n” times.</li>
    </ul>
  </li>
  <li data-marker="*">We’ll do this with deflate as well. Then, in our script for “when flag clicked”, we’ll need to type a number into each of our custom blocks:
    <pre><code class="language-scratch">  when green flag clicked
  set size to (50) %
  inflate () times
  wait (1) seconds
  deflate () times
</code></pre>
    <ul>
      <li data-marker="*">We can type in 10 so the balloon is inflated 10 times, or we can change that to 20, or any other value.</li>
    </ul>
  </li>
  <li data-marker="*">By giving our functions the ability to take inputs, we can make them more flexible.</li>
</ul>

<h2 id="walking-bear">Walking Bear</h2>

<ul>
  <li data-marker="*">Let’s take a look at a function that can take multiple inputs in <a href="https://scratch.mit.edu/projects/507464163/">Walking Bear</a>.</li>
  <li data-marker="*">We’ll add our bear sprite, and rename our costumes for the bear on four legs to “4”, and the costume for the bear on two legs “2”.</li>
  <li data-marker="*">Let’s make a new block called “walk”, and give it an input called “m”. We’ll add a label “steps on”, and then another input, “n”. Finally, we’ll add another label, “feet”:<br/>
  <img src="../Images/fa7376ce1913daf149db3bc9ba250dc7.png" alt="block labeled walk m steps on n feet" width="349" data-original-src="https://cs50.harvard.edu/scratch/notes/8/walk_m_steps.png"/>
    <ul>
      <li data-marker="*">We could call the inputs anything we’d like, but we’ll use “m” and “n”.</li>
    </ul>
  </li>
  <li data-marker="*">What we want this block to do is to make our bear walk “m” steps on “n” feet, so we’ll define it as:
    <pre><code class="language-scratch">  define walk (m) steps on (n) feet
  switch costume to (n)
  repeat (m)
  move (1) steps
</code></pre>
    <ul>
      <li data-marker="*">We’ll first switch our costume to “n”, and then move 1 step “m” times.</li>
    </ul>
  </li>
  <li data-marker="*">Now, in our main script, we can tell our bear to walk any number of steps, on two or four feet:
    <pre><code class="language-scratch">  when green flag clicked
  walk (30) steps on (4) feet
  walk (30) steps on (2) feet
</code></pre>
    <ul>
      <li data-marker="*">Notice that it’s easier to understand what our bear will do when the flag is clicked. And we’ve saved ourselves from having to repeat multiple blocks over and over again.</li>
    </ul>
  </li>
  <li data-marker="*">With our own custom blocks, we can define complex behaviors that we can reuse and keep our project better organized.</li>
</ul>


                    
</body>
</html>