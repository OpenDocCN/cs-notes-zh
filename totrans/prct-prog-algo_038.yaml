- en: 7.1   Boolean Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/71boolean](https://introcs.cs.princeton.edu/java/71boolean)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A *boolean function* is a mathematical function that maps arguments to a value,
    where the allowable values of range (the function arguments) and domain (the function
    value) are just one of two values— `*true*` and `*false*` (or `*0*` and `*1*`).
    The study of boolean functions is known as *Boolean logic*.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean functions.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To define any boolean function, we need only to specify its value for each possible
    value of its inputs. The *not* function is a boolean function of one variable.
  prefs: []
  type: TYPE_NORMAL
- en: $$ \quad\quad\quad\quad\quad\quad \begin{align} NOT(x) &\;=\; \begin{cases}
    1 & \text {if $x$ is $0$} \\[1ex] 0 & \text {if $x$ is $1$} \end{cases} \end{align}
    $$
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The *and*, *or*, and *exclusive or* functions are familiar boolean functions
    of two variables.
  prefs: []
  type: TYPE_NORMAL
- en: $$ \quad\quad\quad\quad\quad\quad \begin{align} AND(x, y) &\;=\; \begin{cases}
    1 & \text {if both $x$ and $y$ are $1$} \\[1ex] 0 & \text {otherwise} \end{cases}
    \\ \\ OR(x, y) &\;=\; \begin{cases} 1 & \text {if either $x$ or $y$ (or both)
    is $1$} \\[1ex] 0 & \text {otherwise} \end{cases} \\ \\ XOR(x, y) &\;=\; \begin{cases}
    1 & \text {if $x$ and $y$ are different} \\[1ex] 0 & \text {otherwise} \end{cases}
    \end{align} $$
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Notation.* There are many competing notations for elementary boolean functions.
    In this chapter, we primarily use the circuit-design notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![notations for boolean functions](../Images/967ba56bc1363b027cde00ed852c8fcd.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Truth tables.* One way to define a boolean function is to specify its value
    for each possible value of its arguments. We use a *truth table* to do so in an
    organized way. A truth table has one column for each variable, one row for each
    possible combination of variable values, and a column that specifies the value
    of the function for that combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![truth tables for elementary functions](../Images/b07d5165358cd09b5ad8704ba6b15df0.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: A truth table for a function of *n* variables has 2^(*n*) rows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Boolean algebra.* Boolean algebra refers to symbolic manipulation of expressions
    made up of boolean variables and boolean operators. The familiar *identity*, *commutative*,
    *distributive*, and *associative* axioms from algebra define the axioms of Boolean
    algebra, along with the two *complementary* axioms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![axioms of Boolean algebra](../Images/d4516234e6f9bf64f5a9766c352d74aa.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: In addition, you can derive many other laws from these axioms. For example,
    the last entry in the table gives two special identities known as *DeMorgan’s
    laws*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![identities and theorems of Boolean algebra](../Images/f1d5ea48a2e1330904a55fa239c15909.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Boolean algebra in Java.* You can incorporate Boolean algebra into your Java
    programs, in two different ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java’s boolean data type: In Section 1.2, we introduced boolean operations
    with the values `*true*` and `*false*` and the `*AND*`, `*OR*`, and `*NOT*` operations
    using the operators `&&`, `||`, and `!`, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitwise operations on integer values: In Section 6.1, we discussed Java’s bitwise
    operations, which use the `*AND*`, `*OR*`, `*NOT*`, and `*XOR*` operators on each
    bit in the binary representations of integer values, using the operators `&`,
    `|`, `~`, and `^`, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean functions of three or more variables.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the number of variables increases, the number of possible functions increases
    dramatically. There are 2⁸ different boolean functions of 3 variables, 2^(16)
    functions of 4 variables, 2^(32) functions of 5 variables, and so forth. Several
    such functions play a critical role in computation and in circuit design, so we
    will now consider them.
  prefs: []
  type: TYPE_NORMAL
- en: '*AND and OR functions.* The definitions of the `*AND*` and `*OR*` functions
    for multiple arguments generalize in a natural way from our two-argument definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$ \quad\quad\quad\quad\quad\quad \begin{align} AND(x_1, x_2, \ldots, x_n) &\;=\;
    \begin{cases} 1 & \text {if all arguments are $1$} \\[1ex] 0 & \text {otherwise}
    \end{cases} \\ \\ OR(x_1, x_2, \ldots, x_n) &\;=\; \begin{cases} 1 & \text {if
    any argument is $1$} \\[1ex] 0 & \text {otherwise} \end{cases} \\ \end{align}
    $$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Majority and odd-parity functions.* We consider two additional functions that
    arise in the design of digital circuits: the *majority* and *odd-parity* functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$ \quad\quad\quad\quad\quad\quad \begin{align} MAJ(x_1, x_2, \ldots, x_n) &\;=\;
    \begin{cases} 1 & \text {if strictly more arguments are $1$ than 0} \\[1ex] 0
    & \text {otherwise} \end{cases} \\ \\ ODD(x_1, x_2, \ldots, x_n) &\;=\; \begin{cases}
    1 & \text {if an odd number of arguments are $1$} \\[1ex] 0 & \text {otherwise}
    \end{cases} \\ \end{align} $$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Boolean expressions.* As with boolean functions of two variables, we can use
    a truth table to explicitly specify a boolean function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![truth tables for boolean functions of 3 variables](../Images/f1a6833624b9f5057fffe011937856ed.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'This representation is cumbersome and quickly fails for functions with larger
    numbers of variables, since the number of rows needed for *n* variables is 2^(*n*).
    Instead, we often prefer to use *boolean expressions* to define boolean functions.
    For example, it is not hard to verify these two identities:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $$ \quad\quad\quad\quad\quad\quad \begin{align} AND(x_1, x_2, \ldots, x_n) &\;=\;
    x_1 x_2 \ldots x_n \\ \\ OR(x_1, x_2, \ldots, x_n) &\;=\; x_1 + x_2 + \ldots +
    x_n \end{align} $$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sum-of-products representations.* One of the fundamental results of Boolean
    algebra is that every boolean function can be represented with an expression that
    uses `*AND*`, `*OR*`, and `*NOT*` operators and no others. For example, consider
    the following truth table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Truth-table proof of the sum-of-products representation of MAJ(x, y, z)](../Images/18a8739fd7021c86f5b52e0e5a466347.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Since their entries are equal for every value of the variables, the two columns
    highlighted in blue represent a proof of the following equation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $$\quad\quad\quad\quad\quad\quad MAJ(x, y, z) = x'yz + xy'z + xyz' + xyz$$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can derive such an expression for any boolean function from its truth table:
    For each of the rows in the truth table in which the function value is 1, we create
    a term that is 1 if the input variables have the values on that row and 0 otherwise.
    Each term is the product of each input variable (if its corresponding entry on
    the row in question is 1) or its negation (if the entry is 0). The sum of all
    of these terms gives back the function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The boolean expression that we construct is known as the *sum-of-products representation*
    or the *disjunctive normal form* of the function. As another example, here is
    the table for the odd parity function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Truth-table proof of the sum-of-products representation of ODD(x, y, z)](../Images/82d2f01ff284285c2eb8719757cdc0e9.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
