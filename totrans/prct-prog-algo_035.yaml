- en: 6.3   Machine-Language Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 机器语言编程
- en: 原文：[https://introcs.cs.princeton.edu/java/63programming](https://introcs.cs.princeton.edu/java/63programming)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/63programming](https://introcs.cs.princeton.edu/java/63programming)
- en: This section under construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在建设中。
- en: Although the TOY machine language contains only 16 different instruction types,
    it is possible to perform a variety of interesting computations. In fact, any
    computation that can be done in the Java programming language on your PC can also
    be done in TOY (provided you give TOY enough main memory and time). This may come
    as quite a surprising fact; we will justify it later in Chapter 8\. Below, we
    describe each of the instructions in the TOY language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TOY机器语言只包含16种不同的指令类型，但可以执行各种有趣的计算。事实上，任何可以在您的PC上用Java编程语言完成的计算也可以在TOY中完成（前提是给予TOY足够的主存储器和时间）。这可能是一个令人惊讶的事实；我们将在第8章中稍后证明它。下面，我们描述TOY语言中的每个指令。
- en: Memory-register transfer (opcodes 8 and 9).
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存-寄存器传输（操作码8和9）。
- en: To transfer data between registers and main memory, we use the *load* (opcode
    8) and *store* (opcode 9) instructions. These operations are convenient because
    it is not possible to perform arithmetic operations directly on the contents of
    main memory. Instead, the data must be first transferred to registers. There are
    also circumstances where it is not possible to maintain all of our program's variables
    simultaneously in registers, e.g., if we need to store more than 16 values. We
    overcome the 16 register limitation by storing variables in main memory, and transferring
    them back and forth to registers using the *load* and *store* instructions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在寄存器和主存储器之间传输数据，我们使用*load*（操作码8）和*store*（操作码9）指令。这些操作很方便，因为不可能直接对主存储器的内容进行算术运算。相反，数据必须首先转移到寄存器中。还有一些情况下，不可能同时在寄存器中维护程序的所有变量，例如，如果我们需要存储超过16个值。我们通过将变量存储在主存储器中，并使用*load*和*store*指令将它们来回传输到寄存器中，克服了16个寄存器的限制。
- en: Arithmetic operations (opcodes 1 and 2).
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算（操作码1和2）。
- en: The *add* (opcode 1) and *subtract* (opcode 2) perform the conventional arithmetic
    operations. In TOY, all arithmetic operations involve 16 bit two's complement
    integers, as described in Section 5.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*add*（操作码1）和*subtract*（操作码2）执行传统的算术运算。在TOY中，所有算术运算都涉及16位的二进制补码整数，如第5.1节所述。'
- en: '*Addition.* Program [add.toy](add.toy) treats memory addresses `00` and `01`
    as storing the input values for variables `RA` and `RB`. It then calculates the
    sum of the two values and puts the result temporarily in register C. Finally,
    it transfers the contents of register C back to memory, and stores it at memory
    address `02`. It is important to note that memory locations `00` through `02`
    never get executed in this program; they are treated as data.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法。* 程序[add.toy](add.toy)将内存地址`00`和`01`视为存储变量`RA`和`RB`的输入值。然后计算这两个值的和，并将结果暂时放在寄存器C中。最后，将寄存器C的内容传输回内存，并将其存储在内存地址`02`处。重要的是要注意，内存位置`00`到`02`在此程序中永远不会被执行；它们被视为数据。'
- en: '|'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Upon termination of this program, register C contains the value `000D`, the
    hexadecimal equivalent of the decimal integer 13. (If you computed the result
    `0013`, start getting adjusted to working with hexadecimal integers.)
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在程序终止时，寄存器C包含值`000D`，这是十进制整数13的十六进制等价值。（如果你计算出结果`0013`，开始适应使用十六进制整数。）
- en: What happens if the result of the arithmetic operations is too large to fit
    into a 16 bit register? Such overflow is handled by disregarding everything except
    the rightmost 4 hex digits. For example, the result of adding `EFFF` and `1005`
    is `0004`, since `EFFF + 1005 = 10004` in hex and we discard the leading digit.
    This is the way addition works in Java, except that there are 32 bits in an `int`
    instead of the 16 in a TOY word.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果算术运算的结果太大而无法适应16位寄存器怎么办？这种溢出通过忽略除最右边的4位十六进制数字外的所有内容来处理。例如，将`EFFF`和`1005`相加的结果是`0004`，因为`EFFF
    + 1005 = 10004`在十六进制中，我们丢弃了前导数字。这就是Java中加法的工作方式，只是`int`中有32位而不是TOY字中的16位。
- en: '*Subtraction.* Analogously, the program [subtract.toy](subtract.toy) computes
    `0005 - 0008 = FFFD`. The answer `FFFD` is the hexadecimal equivalent of decimal
    integer -3 using two''s complement integers. (Review Section 5.1 for a description
    of two''s complement notation.)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减法。* 类似地，程序[subtract.toy](subtract.toy)计算`0005 - 0008 = FFFD`。答案`FFFD`是使用二进制补码整数表示的十进制整数-3的十六进制等价值。（回顾第5.1节中对二进制补码表示法的描述。）'
- en: '|'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Standard input and standard output.
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输入和标准输出。
- en: 'The *load* and *store* instructions are also used to access *standard input*
    and *standard output*. The distinguished memory address `FF` is intercepted by
    a TOY hardware interrupt: instead of loading or storing information in memory
    location `FF`, the data is received from the keyboard or is sent to the screen.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*load*和*store*指令也用于访问*标准输入*和*标准输出*。TOY硬件中断拦截了特殊的内存地址`FF`：不是在内存位置`FF`加载或存储信息，而是从键盘接收数据或发送到屏幕。'
- en: '*Sum two integers.* Program [stdin.toy](stdin.toy) reads two integers from
    standard input, and writes their sum to standard output.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*求两个整数的和。* 程序[stdin.toy](stdin.toy)从标准输入读取两个整数，并将它们的和写入标准输出。'
- en: '|'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: When the program is executed, it pauses until the user types in two integers.
    As usual, the integers are specified as 4 hexadecimal digits. Then it computes
    their sum, and prints it to the screen.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当程序执行时，它会暂停，直到用户输入两个整数。通常情况下，整数被指定为4位十六进制数字。然后计算它们的和，并将结果打印到屏幕上。
- en: '*Fibonacci numbers.* Program [fibonacci.toy](fibonacci.toy) prints to standard
    output the sequence of Fibonacci numbers 0, 1, 1, 2, 3, 5, 8, D, etc.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*斐波那契数列。* 程序[fibonacci.toy](fibonacci.toy)将斐波那契数列0、1、1、2、3、5、8、D等打印到标准输出。'
- en: '*Sum of sequence of integers.* Program [sum.toy](sum.toy) reads in a sequence
    of integers from standard input and prints out their sum. It stops upon reading
    in the integer `0000`. It illustrates a program that can process more information
    than fits in TOY memory.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数序列的和。* 程序[sum.toy](sum.toy)从标准输入读取一个整数序列，并打印出它们的和。在读取整数`0000`时停止。它演示了一个可以处理超出TOY内存容量的信息的程序。'
- en: '*Implications of standard input and output.* The standard input and standard
    output facilities of TOY have a profound effect on what the TOY machine is capable
    of. An obvious feature is to get information in and out of the machine. This information
    can be data, but it can also be instructions! *Booting a computer* is copying
    a sequence of stored instructions (e.g., the operating system) into the machine.
    The TOY machine has only a limited memory (256 words plus a few registers). Nevertheless,
    it is possible to process more information than this. Another advantage of standard
    input is that it offers a crude form of user interaction.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准输入和输出的影响。* TOY的标准输入和标准输出功能对TOY机器的功能有深远影响。一个明显的特点是将信息输入和输出到机器中。这些信息可以是数据，也可以是指令！*引导计算机*是将一系列存储的指令（例如操作系统）复制到计算机中。TOY机器只有有限的内存（256个字加上几个寄存器）。尽管如此，仍然可以处理比这更多的信息。标准输入的另一个优点是它提供了一种粗糙的用户交互形式。'
- en: Flow control (opcodes C and D).
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程控制（操作码C和D）。
- en: So far, we have seen how to use TOY as a calculator. *Branch* statements enable
    us to harness the true power of TOY, much like `while` loops and `if-else` conditionals
    enabled us to harness the power of Java. The value of the program counter controls
    which statement the TOY machine will execute next. Typically, the program counter
    is incremented by one at each time step. This causes the instructions to be executed
    in order, one after the other. The *branch if zero* (opcode C) and *branch if
    positive* (opcode D) enable us to directly change the program counter, thereby
    altering the flow of control of our programs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何将TOY用作计算器。*分支*语句使我们能够发挥TOY的真正力量，就像`while`循环和`if-else`条件语句使我们能够发挥Java的力量一样。程序计数器的值控制着TOY机器将执行下一个语句。通常，程序计数器在每个时间步长增加一次。这导致指令按顺序执行，依次执行。*分支如果为零*（操作码C）和*分支如果为正*（操作码D）使我们能够直接更改程序计数器，从而改变程序的控制流。
- en: '*Powers of two.* Program [powers2.toy](powers2.toy) prints out the positive
    powers of 2, using a *branch if positive* statement.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二的幂。* 程序[powers2.toy](powers2.toy)使用*分支如果为正*语句打印出正的二的幂。'
- en: '|'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '*Infinite loop.* The ability to change the flow-of-control of a program introduces
    the possiblity for infinite loops, as in [infinite_loop.toy](infinite_loop.toy).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无限循环。* 改变程序流程控制的能力引入了无限循环的可能性，就像[infinite_loop.toy](infinite_loop.toy)中的情况一样。'
- en: '|'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '*Multiplication.* Conspicuously absent from the TOY instruction set is a multiply
    instruction. To achieve the same effect in software, we describe and implement
    an algorithm to multiply two integers. The brute force way to compute `c` = `a
    * b` is to set `c = 0`, and then add `a` to `c`, `b` times. This suggests having
    a loop that repeats `b` times. We accomplish this by making a counter variable
    `i` that we initialize to `b`, and then decrement it by one until it reaches 0\.
    We use the branch if positive instruction to detect this event. The program [multiply.toy](multiply.toy)
    loads two integers from memory locations `0A` and `0B` into registers A and B,
    multiplies them together and puts the result in register C, then writes the result
    back to memory location `0C`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*乘法。* TOY指令集中明显缺少乘法指令。为了在软件中实现相同的效果，我们描述并实现了一个算法来将两个整数相乘。计算`c` = `a * b`的蛮力方法是将`c
    = 0`，然后将`a`加到`c`，`b`次。这表明有一个重复`b`次的循环。我们通过创建一个计数器变量`i`，将其初始化为`b`，然后递减到达0来实现这一点。我们使用分支如果为正指令来检测此事件。程序[multiply.toy](multiply.toy)从内存位置`0A`和`0B`中加载两个整数到寄存器A和B中，将它们相乘并将结果放入寄存器C，然后将结果写回内存位置`0C`。'
- en: '|'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: The astute reader might notice that our algorithm suffers from a serious performance
    flaw. The brute force algorithm is inefficient if the values are large. The loop
    iterates `b` times, and since `b` is a 16-bit integer, it can be as large as 32,767\.
    This issue would be much more pronounced on a 64-bit machine where the loop might
    require a mind-boggling 9,223,372,036,854,775,807 iterations! Fortunately, we
    can incorporate better algorithmic ideas (as we do below) to rescue this otherwise
    hopeless task.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机智的读者可能会注意到我们的算法存在严重的性能缺陷。如果值很大，蛮力算法效率低下。循环迭代`b`次，由于`b`是一个16位整数，它可以达到32767。在64位机器上，这个问题会更加突出，循环可能需要令人难以置信的9,223,372,036,854,775,807次迭代！幸运的是，我们可以引入更好的算法思想（正如我们下面所做的那样）来拯救这个看似无望的任务。
- en: '**TOY idioms.** There are several common idioms or pseudo-instructions in TOY
    that can be used for common programming tasks. Many of these tricks rely on the
    fact that register 0 always stores the value `0000`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOY惯用法。** TOY中有几种常见的惯用法或伪指令，可用于常见的编程任务。这些技巧中的许多依赖于寄存器0始终存储值`0000`。'
- en: '*Register-to-register transfer.* Suppose you want to make register 2 have the
    same value as register 1. There is no built-in instruction to do this. Relying
    on the fact that register 0 always contains `0000`, we can use the addition instruction
    to sum up `R0` and `R1` and put the result in `R2`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寄存器之间的传输。* 假设您想要使寄存器2具有与寄存器1相同的值。没有内置指令可以做到这一点。依靠寄存器0始终包含`0000`这一事实，我们可以使用加法指令将`R0`和`R1`相加，并将结果放入`R2`中。'
- en: '|'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '*Swap.* As a more sophisticated example, suppose we want to swap the contents
    of two registers RA and RB....'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交换。* 作为一个更复杂的例子，假设我们想要交换两个寄存器RA和RB的内容....'
- en: '*No-op.* In a structured programming language like Java (with `for` and `while`
    loops), inserting extra code is easy. In an unstructured language like TOY (where
    there are line numbers and goto statements), you must be careful about inserting
    code. A branch statement hardwires in the memory address to jump to; if you insert
    code, the line numbers of your program may change. To avoid some of this awkwardness,
    machine language programmers often find it convenient to fill in the program with
    "useless" statements to act as placeholders. Such statements are called *no-ops*
    because they perform no operation. The instruction `1000` is ideal for this purpose
    since register 0 is always 0 anyway. (The instruction `10xy` would also be a no-op
    for any values of x and y because register 0 always contains 0, regardless of
    how you might try to change it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无操作*。在像Java这样的结构化编程语言中（具有`for`和`while`循环），插入额外代码很容易。在像TOY这样的非结构化语言中（其中有行号和goto语句），必须小心插入代码。分支语句将内存地址硬编码为要跳转的地址；如果插入代码，程序的行号可能会更改。为了避免一些尴尬，机器语言程序员通常发现填充程序中的“无用”语句以充当占位符很方便。这些语句称为*无操作*，因为它们不执行任何操作。指令`1000`非常适合这个目的，因为寄存器0始终为0。
    （指令`10xy`对于任何x和y的值也是无操作，因为寄存器0始终包含0，无论您如何尝试更改它。'
- en: '*Goto*. There is no instruction that directly changes the program counter to
    the `addr`. However, it is easy to use the branch if zero instruction with register
    0 to achieve the same effect. For example, the instruction `C0F0` changes the
    program counter to `F0` since register 0 is always 0.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳转*。没有直接将程序计数器更改为`addr`的指令。但是，可以使用零值分支指令与寄存器0来实现相同的效果。例如，指令`C0F0`将程序计数器更改为`F0`，因为寄存器0始终为0。'
- en: Bit-whacking operators (opcodes 3, 4, 5, and 6).
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位操作符（操作码3, 4, 5, 和 6）。
- en: The bit-whacking operations - *bitwise and* (opcode 3), *bitwise xor* (opcode
    4), *left shift* (opcode 5), and *right shift* (opcode 6) - work just like the
    analogous ones in Java, except using 16-bit two's complement integers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 位操作 - *按位与*（操作码3）、*按位异或*（操作码4）、*左移*（操作码5）和*右移*（操作码6） - 与Java中的类似操作一样，只是使用16位的二进制补码整数。
- en: '*Bitwise and and bitwise xor.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*按位与和按位异或*'
- en: '*Bitwise and*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*按位与*'
- en: '*bitwise xor*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*按位异或*'
- en: '`00B5`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`00B5`'
- en: '`00E3`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`00E3`'
- en: '`3312`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`3312`'
- en: '`00A1`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`00A1`'
- en: '*bitwise and*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*按位与*'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '*Left shift* (opcode 5) shifts the bits a certain number of places to the left,
    padding 0s on the right. For example, if register 2 has the value `00B5` and register
    3 has the value `0002`, then the instruction `5423` assigns the value `02D4` to
    register 4. To see why, look at the binary representation.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*左移*（操作码5）将位向左移动一定数量的位置，右侧填充0。例如，如果寄存器2的值为`00B5`，寄存器3的值为`0002`，那么指令`5423`将值`02D4`赋给寄存器4。要了解原因，请查看二进制表示。'
- en: '|'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Note that left shifting by one bit is equivalent to multiplication by 2; left
    shifting by *i* bits is equivalent to multiplying by 2^i.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，左移一位等同于乘以2；左移*i*位等同于乘以2^i。
- en: '*Right shift* (opcode 6) is similar, but the bits get shifted to the right.
    Leading 0s or 1s are padded on the left, according to the sign bit (the leftmost
    bit). For example, if register 2 has the value `00B5` and register 3 has the value
    `0002`, then the instruction `6423` assigns the value `002D` to register 4. To
    see why, look at the binary representation.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*右移*（操作码6）类似，但是位向右移动。根据符号位（最左边的位），左侧填充0或1。例如，如果寄存器2的值为`00B5`，寄存器3的值为`0002`，那么指令`6423`将值`002D`赋给寄存器4。要了解原因，请查看二进制表示。'
- en: '|'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: The value is register 2 is nonnegative so 0s are padded on the left. If, instead,
    register 2 has the value `FF4B`, then the result of the right shifting is `FFD3`.
    In this case the value in register 2 is negative so 1's are padded on the left.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 寄存器2中的值为非负数，因此左侧填充0。如果寄存器2的值为`FF4B`，那么右移的结果是`FFD3`。在这种情况下，寄存器2中的值为负数，因此左侧填充1。
- en: '|'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'Note that right shifting an integer by 1 bit is equivalent to dividing the
    integer by 2 and throwing away the remainder. This is true regardless of the sign
    of the original integer. In general, right shifting an integer by *i* bits is
    equivalent to dividing it by 2^i and rounding down. (Note that this does not exactly
    agree with integer division in Java by the corresponding power of two when the
    numerand is negative, e.g., -181/4 = -45.) This type of shifting is called an
    *arithmetic shift* or a *signed shift*: it preserves the sign for two''s complement
    integers.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，将整数右移1位等同于将整数除以2并丢弃余数。这对于原始整数的符号无关紧要。一般来说，将整数右移*i*位等同于将其除以2^i并向下取整。���请注意，当被除数为负数时，这与Java中对应的2的幂的整数除法并不完全一致，例如，-181/4
    = -45。）这种移位称为*算术移位*或*有符号移位*：它保留二进制补码整数的符号。
- en: '**Efficient multiplication.** Using the bitwise operators, we provide an efficient
    implementation of [multiply.toy](multiply.toy). To multiply two 16-bit integers
    *a* and *b*, we let *b[i]* denote the *i*th bit of *b*. That is,'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**高效的乘法。** 使用位操作符，我们提供了一个高效的实现[multiply.toy](multiply.toy)。要将两个16位整数*a*和*b*相乘，我们让*b[i]*表示*b*的第*i*位。也就是说，'
- en: '|           b = (b[15] × 2^(15)) + (b[14] × 2^(14)) + ... + (b[1] × 2¹) + (b[0]
    × 2⁰) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|           b = (b[15] × 2^(15)) + (b[14] × 2^(14)) + ... + (b[1] × 2¹) + (b[0]
    × 2⁰) |'
- en: 'By distributivity, we obtain:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分配率，我们得到：
- en: '|           a × b = (a × b[15] × 2^(15)) + ... + (a × b[1] × 2¹) + (a × b[0]
    × 2⁰) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|           a × b = (a × b[15] × 2^(15)) + ... + (a × b[1] × 2¹) + (a × b[0]
    × 2⁰) |'
- en: Thus, to compute *a × b*, it suffices to add the above 16 terms. Naively, this
    appears to reduce the problem of performing one multiplication to 32 multiplication,
    two for each of the 16 terms. Fortunately, each of these 32 multiplications are
    of a very special type. Recall that *a × 2^i* is the same as left shifting *a*
    by *i* bits. Second, note that *b[i]* is either 0 or 1; thus term *i* is either
    `a << i` or 0. Program [multiply-fast.toy](multiply-fast.toy) loops 16 times.
    In iteration *i* it computes the *i*th term and adds it to the running total stored
    in register C. To gain some perspective, recall the standard grade school algorithm
    for multiplying two decimal integers. The bitwise procedure we just described
    is really just the grade school algorithm applied to binary integers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要计算*a × b*，只需添加上述16个项即可。从表面上看，这似乎将执行一次乘法的问题减少到32次乘法，每个16个项需要两次。幸运的是，这32次乘法都是非常特殊的类型。回想一下*a
    × 2^i*等同于将*a*左移*i*位。其次，注意*b[i]*要么是0要么是1；因此第*i*项要么是`a << i`要么是0。程序[multiply-fast.toy](multiply-fast.toy)循环16次。在第*i*次迭代中，它计算第*i*项并将其添加到寄存器C中存储的运行总数中。为了获得一些视角，回想一下用于乘法两个十进制整数的标准小学算法。我们刚刚描述的按位过程实际上只是将小学算法应用于二进制整数。
- en: Load address (opcode 7).
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装载地址（操作码 7）。
- en: The load address instruction (opcode 7) is the most primitive type of assignment
    statement in the TOY language. The code fragment below initializes register A
    to `30`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 装载地址指令（操作码 7）是TOY语言中最原始的赋值语句类型。下面的代码片段将寄存器A初始化为`30`。
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: When using the *load address* instruction, we often think of the destination
    register as storing the memory address of some piece of data. This is especially
    useful when dealing with arrays. In the C programming language, this type of variable
    is known as a *pointer*. However, we can also use the *load address* instruction
    to store a small constant into a register, instead of using the *load* instruction.
    Note that *load address* only permits you to assign 8 bit integers (`00` through
    `FF`) to a register, even though registers are capable of storing 16 bit integers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*装载地址*指令时，我们经常将目标寄存器视为存储某些数据的内存地址。在处理数组时，这尤其有用。在C编程语言中，这种类型的变量被称为*指针*。然而，我们也可以使用*装载地址*指令将一个小常数存储到寄存器中，而不是使用*装载*指令。请注意，*装载地址*只允许您将8位整数（`00`到`FF`）分配给寄存器，即使寄存器能够存储16位整数。
- en: Arrays (opcodes A and B).
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组（操作码 A 和 B）。
- en: Arrays are not directly built into the TOY language, but it is possible to achieve
    the same functionality using the *load address* (opcode 7), *load indirect* (opcode
    A), and *store indirect* (opcode B) instructions. We illustrate this technique
    with two examples. First, we will consider a program that reads in a sequence
    of integers and prints them in reverse order. Then, we will consider a more sophisticated
    application of arrays that performs the classic insertion sort algorithm on a
    sequence of integers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数组并不直接内置在TOY语言中，但可以使用*装载地址*（操作码 7）、*装载间接*（操作码 A）和*存储间接*（操作码 B）指令来实现相同的功能。我们用两个示例说明这种技术。首先，我们将考虑一个程序，该程序读取一系列整数并以相反顺序打印它们。然后，我们将考虑一个更复杂的数组应用程序，该程序对一系列整数执行经典的插入排序算法。
- en: '*Reverse.* Program [reverse.toy](reverse.toy) reads a sequence of positive
    integers from standard input, and stops when it encounters the integer `0000`.
    It stores the integers in main memory, starting at address `30`. We use the load
    address instruction to store the address `30`. Then, it marches through the elements
    in reverse order, printing them out to standard input. We use register B to keep
    track of the number of elements read in. We arrange it so that register 6 contains
    the memory location of the array element that we are currently reading or writing.
    To write and read an array element, we use the opcodes A and B, respectively.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反转。*程序[reverse.toy](reverse.toy)从标准输入读取一系列正整数，并在遇到整数`0000`时停止。它从地址`30`开始将整数存储在主内存中。我们使用装载地址指令来存储地址`30`。然后，它以相反的顺序遍历元素，并将它们打印到标准输入。我们使用寄存器B来跟踪读入的元素数量。我们安排寄存器6包含当前正在读取或写入的数组元素的内存位置。为了写入和读取数组元素，我们分别使用操作码A和B。'
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Buffer overflow.* Program [reverse.toy](reverse.toy) suffers from one critical
    flaw. Since the TOY machine has only 256 memory locations, it is not possible
    to store or reverse a list that contains too many elements. In the example above,
    after the program fills up memory locations `30` through `FF`, it will wrap around
    and start writing into memory locations `00` through `0F`. Pretty soon, it will
    start overwriting the lines of the original program `10` through `20`. A devious
    user could exploit this *buffer overflow* and input integers in such a way that
    the integers from standard input get interpreted as instructions rather than data.
    Viruses are often spread by such buffer overflow attacks.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓冲区溢出。*程序[reverse.toy](reverse.toy)存在一个关键缺陷。由于TOY机器只有256个内存位置，因此不可能存储或反转包含太多元素的列表。在上面的示例中，当程序填满内存位置`30`到`FF`时，它将绕回并开始写入内存位置`00`到`0F`。很快，它将开始覆盖原始程序的行`10`到`20`。一个狡猾的用户可以利用这种*缓冲区溢出*，以这样的方式输入整数，使得标准输入的整数被解释为指令而不是数据。病毒经常通过这种缓冲区溢出攻击传播。'
- en: Program [crazy8.toy](crazy8.toy) is a version of `reverse.toy` that starts storing
    the array at memory address 00. Thus, after 16 integers are read in and stored,
    the program starts overwriting itself. The input below is especially malicious.
    Entering the 20 integers on standard input enables the user to take control of
    the machine and have it print out 8888 in an infinite loop.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序[crazy8.toy](crazy8.toy)是`reverse.toy`的一个版本，它从内存地址00开始存储数组。因此，在读取并存储16个整数后，程序开始覆盖自身。下面的输入特别恶意。在标准输入中输入20个整数可以让用户控制机器，并使其无限循环打印出8888。
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Functions (opcodes E and F).
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数（操作码 E 和 F）。
- en: In Java it is quite useful to divide a program up into smaller functions. We
    can do the same in TOY. Below is a TOY program that "calls" a multiply function
    with two arguments and computers their product. Since all of the variables (registers)
    are global, we need to agree upon a protocol for calling our function. We'll assume
    that we want to multiply the integers stored in registers `A` and `B`, and store
    their product in register `C`. Program [multiply-function.toy](multiply-function.toy)
    that calls the multiply function twice to compute *x* × *y* × *z*, once to compute
    *x* × *y*, then again to compute (*x* × *y*) × *z*. It uses the *jump and link*
    (opcode F) and *jump register* (opcode E) instructions that are especially designed
    for this purpose. Instructions `11` and `14` store the value of the program counter
    in register 3 before jumping to the function located at `F0`. This makes it possible
    to return back to the main program, without hardwiring in the address into the
    program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，将程序分解为较小的函数非常有用。我们可以在TOY中做同样的事情。下面是一个调用带有两个参数的乘法函数并计算它们乘积的TOY程序。由于所有变量（寄存器）都是全局的，我们需要就调用函数达成一致的协议。我们假设我们要将存储在寄存器`A`和`B`中的整数相乘，并将它们的乘积存储在��存器`C`中。程序[multiply-function.toy](multiply-function.toy)两次调用乘法函数来计算*x*
    × *y* × *z*，一次计算*x* × *y*，然后再次计算（*x* × *y*）× *z*。它使用了专门设计用于此目的的*跳转和链接*（操作码F）和*跳转寄存器*（操作码E）指令。指令`11`和`14`在跳转到位于`F0`的函数之前将程序计数器的值存储在寄存器3中。这使得可以返回到主程序，而不需要将地址硬编码到程序中。
- en: Every time the program counter is reset to `F0`, the old program counter is
    saved away in register F for future use. Instruction `F5` returns from the function
    by resetting the program counter to the value stored in register F. Note also,
    that the program counter is incremented *before* the instruction is executed.
    Thus, during the first function call register F is `16` and not `15`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序计数器重置为`F0`时，旧的程序计数器都会保存在寄存器F中以备将来使用。指令`F5`通过将程序计数器重置为寄存器F中存储的值来从函数中返回。还要注意，程序计数器在执行指令之前会先递增。因此，在第一次函数调用时，寄存器F为`16`而不是`15`。
- en: Be very careful about which variables you are using when writing machine language
    functions. There is no such thing as a "local variable." Had we continued to use
    register 2 as the loop counter in the multiplication function, this would have
    overwritten register 2 in the main program, which was being used to store the
    quantity `b`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写机器语言函数时一定要非常小心使用哪些变量。没有所谓的“局部变量”。如果我们继续在乘法函数中使用寄存器2作为循环计数器，这将覆盖主程序中正在用于存储量`b`的寄存器2。
- en: '**Horner''s method.** We can use the multiplication function to *evaluate polynomials*:
    given integer coefficients *a[n]*, ..., *a[2]*, *a[1]*, *a[0]* and an integer
    *x*, evaluate the polynomial *p(x) = a[n] x^n + ... + a[2] x² + a[1] x¹ + a[0]
    x⁰* at the integer *x*. Polynomial evaluation was one *raison d''etre* for early
    machines. It has many applications including studying ballistic motion and converting
    an integer from its decimal representation to hexadecimal.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**霍纳法**。我们可以使用乘法函数来*评估多项式*：给定整数系数*a[n]*，...，*a[2]*，*a[1]*，*a[0]*和整数*x*，在整数*x*处评估多项式*p(x)
    = a[n] x^n + ... + a[2] x² + a[1] x¹ + a[0] x⁰*。多项式评估是早期机器的一个*存在理由*。它有许多应用，包括研究弹道运动和将整数从十进制表示转换为十六进制表示。'
- en: 'The brute force algorithm for polynomial evaluation is to sum up the *n+1*
    terms, where term *i* is the product of *a[i]* and *x^i*. To compute *x^i* we
    could write a power function that multiplies *x* by itself *i-1* times. *Horner''s
    method* is a clever alternative that is more efficient and easier to code. The
    basic idea is to judiciously sequence the way in which terms are multiplied. We
    can rewrite an order 3 polynomial By distributivity, we obtain:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式评估的蛮力算法是将*n+1*项相加，其中第*i*项是*a[i]*和*x^i*的乘积。要计算*x^i*，我们可以编写一个将*x*乘以自身*i-1*次的幂函数。*霍纳法*是一个更高效且更易于编码的巧妙替代方法。基本思想是明智地安排项的乘法顺序。我们可以通过分配性重写一个三次多项式：
- en: '|           p(x) = a[3] x³ + a[2] x² + a[1] x + a[0]   =  (((a[3]) x + a[2])
    x + a[1]) x + a[0] |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|           p(x) = a[3] x³ + a[2] x² + a[1] x + a[0]   =  (((a[3]) x + a[2])
    x + a[1]) x + a[0] |'
- en: Similarly, we can rewrite an order 5 polynomial
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以重写一个五次多项式
- en: '|           p(x) = a[5] x⁵ + a[4] x⁴ + a[3] x³ + a[2] x² + a[1] x + a[0]  
    =  (((((a[5]) x + a[4]) x + a[3]) x + a[2]) x + a[1]) x + a[0] |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|           p(x) = a[5] x⁵ + a[4] x⁴ + a[3] x³ + a[2] x² + a[1] x + a[0]  
    =  (((((a[5]) x + a[4]) x + a[3]) x + a[2]) x + a[1]) x + a[0] |'
- en: Using Horner's method, only *n* multiplications are required to evaluate an
    order *n* polynomial. Moreover, we can translate the method directly into Java
    or TOY code. Program [horner.toy](horner.toy) is the TOY version. In the TOY version,
    we call our multiply function every time we want to multiply two integers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用霍纳法，只需要*n*次乘法即可评估一个*n*次多项式。此外，我们可以直接将该方法转换为Java或TOY代码。程序[horner.toy](horner.toy)是TOY版本。在TOY版本中，每次我们想要将两个整数相乘时，我们都调用我们的乘法函数。
- en: Horner's method was published in 19th century by British mathematician W. G.
    Horner, but the algorithm was used by Isaac Newton over a century earlier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 霍纳法是由英国数学家W. G. Horner于19世纪发表的，但该算法在一个多世纪前就被艾萨克·牛顿使用过。
- en: We can use [horner.toy](horner.toy) to convert a decimal integer to its hexadecimal
    representation. To convert 765[10] to hex, we set the input `x = A`, `n = 3`,
    `a[2] = 7`, `a[1] = 6`, and `a[0] = 5`. Since all arithmetic is performed in hex,
    the program computes the hexadecimal equivalent of 7 × 10² + 6 × 10 + 5 = `02FD`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[horner.toy](horner.toy)将十进制整数转换为其十六进制表示。要将765[10]转换为十六进制，我们设置输入`x = A`，`n
    = 3`，`a[2] = 7`，`a[1] = 6`和`a[0] = 5`。由于所有算术都是在十六进制中进行的，程序计算出7 × 10² + 6 × 10
    + 5的十六进制等价值为`02FD`。
- en: '**Insertion sort.** The program `insertion-sort.toy` reads in a sequence of
    positive integers from standard input and insertion sorts them. The program terminates
    upon reading in a nonpositive integer.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入排序**。程序`insertion-sort.toy`从标准输入中读取一系列正整数并对它们进行插入排序。在读取非正整数时程序终止。'
- en: Linked lists.
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表。
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This code will traverse the linked list starting at memory location `D0`, printing
    out the integer stored in each "node." It will print out `0001 0002 0003 0004`.
    Throughout the computation R1 is always 1. Indexed addressing is used in instructions
    `A304` and `A203` Register R2 is a *pointer* - it is the memory address of the
    next node. Register R3 is a pointer to the memory address immediately after R2.
    At each iteration of the loop we print the contents of the value in memory referenced
    by R2 and use the value in memory referenced by R3 to determine what memory address
    R2 will store in the next iteration. For the data given above, register R2 will
    have the values `D0`, `D6`, `DA`, `D4`, and `00` in that order. This process is
    repeated until R2 is `0000`, i.e., the end of the linked list. In Java, the keyword
    `null` plays the role of `0000` and is used to terminate linked lists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将遍历从内存位置 `D0` 开始的链表，打印出每个“节点”中存储的整数。它将打印出 `0001 0002 0003 0004`。在整个计算过程中，R1
    始终为 1。指令 `A304` 和 `A203` 中使用了索引寻址。寄存器 R2 是一个*指针* - 它是下一个节点的内存地址。寄存器 R3 是指向 R2
    立即后面的内存地址的指针。在每次循环迭代中，我们打印由 R2 引用的内存中的值，并使用由 R3 引用的内存中的值来确定下一次迭代中 R2 将存储的内存地址。对于上面给出的数据，寄存器
    R2 将按顺序具有值 `D0`、`D6`、`DA`、`D4` 和 `00`。这个过程重复，直到 R2 为 `0000`，即链表的末尾。在 Java 中，关键字
    `null` 扮演 `0000` 的角色，并用于终止链表。
- en: '**Recursion.** You can also do recursion in TOY, but this is rather tricky.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归。** 你也可以在 TOY 中进行递归，但这相当棘手。'
- en: Exercises
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program [powers2.toy](powers2.toy) that prints out all of the positive
    powers of 2 to standard output.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 [powers2.toy](powers2.toy)，将所有正的 2 的幂打印到标准输出。
- en: 'Given an integer x, its *Collatz sequence* is defined by replacing it with
    x/2 if x is even, and 3x + 1 is x is odd, and repeating until x is 1. Write a
    program `collatz.toy` thats reads an integer x from standard input and prints
    its Collatz sequence to standard output. *Hint*: use right shift to perform integer
    division by two.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定整数 x，其*Collatz 序列*定义为如果 x 是偶数，则用 x/2 替换它，如果 x 是奇数，则用 3x + 1 替换它，并重复直到 x 为
    1。编写一个程序 `collatz.toy`，从标准输入读取一个整数 x，并将其 Collatz 序列打印到标准输出。*提示*：使用右移运算符执行整数除法。
- en: Write a program [sum_1-n.toy](sum_1-n.toy) that reads in an integer N from standard
    input and prints out the sum 1 + 2 + 3 + ... + N.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 [sum_1-n.toy](sum_1-n.toy)，从标准输入读取一个整数 N，并打印出 1 + 2 + 3 + ... + N 的和。
- en: Write a program `min3.toy` that reads in three integers from standard input
    and print to standard output the smallest one.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 `min3.toy`，从标准输入读取三个整数，并打印出最小的一个。
- en: Write a program `max3.toy` that reads in three integers from standard input
    and print to standard output the largest one.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 `max3.toy`，从标准输入读取三个整数，并打印出最大的一个。
- en: Write a program `sort3.toy` that reads in three integers from standard input
    and print them out to standard output in ascending order.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 `sort3.toy`，从标准输入读取三个整数，并按升序打印到标准输出。
- en: Write a program [chop.toy](chop.toy) that reads in an integer N from standard
    input and prints it out as the sum of powers of 2\. For example if N = `012A`,
    then the program should print out
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 [chop.toy](chop.toy)，从标准输入读取一个整数 N，并将其打印为 2 的幂的和。例如，如果 N = `012A`，那么程序应该打印出
- en: '|'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: since `012A` = `0002` + `0008` + `0020` + `0100`.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为 `012A` = `0002` + `0008` + `0020` + `0100`。
- en: This question tests the difference between load address, load, and load indirect.
    For each of the following TOY programs, give the contents of registers 1, 2, and
    3 upon termination.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个问题测试加载地址、加载和间接加载之间的区别。对于以下每个 TOY 程序，在终止时给出寄存器 1、2 和 3 的内容。
- en: '|'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Consider the following TOY program. What is the value of register 3 upon termination?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下 TOY 程序。在终止时，寄存器 3 的值是多少？
- en: '|'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Write a program that reads in one integer a from standard input, and outputs
    a³.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取一个整数 a，并输出 a³。
- en: Write a program that reads in an integer a from standard input and prints `AAAA`
    to standard output if
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取一个整数 a，并在标准输出中打印 `AAAA`，如果
- en: a = 3
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a = 3
- en: a > 3
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a > 3
- en: a < 3
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a < 3
- en: a != 3
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a != 3
- en: a >= 3
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a >= 3
- en: a <= 3
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a <= 3
- en: Suppose that you load the following into locations 10-17 of TOY, set the PC
    to 10, and press RUN.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你将以下内容加载到 TOY 的 10-17 位置，将 PC 设置为 10，然后按运行。
- en: '|'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: What, if anything, is printed to standard output if the following data appear
    on standard input?
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果标准输入中出现以下数据，标准输出会打印什么？
- en: '|'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '*Answer*: The TOY programs reads two values from standard input. The first
    value is placed into memory location 15 where it is eventually *executed as code*.
    This inserts a second add instruction.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：TOY 程序从标准输入读取两个值。第一个值放入内存位置 15，最终被*执行为代码*。这插入了第二个加法指令。'
- en: Repeat the previous question, but now with the following data on standard input.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一个问题，但现在标准输入中有以下数据。
- en: '|'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Write a program that reads in three integers a, b, and c from standard input,
    and computes the discriminant d = b² - 4ac. Use the multiplication function described
    above.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取三个整数 a、b 和 c，并计算判别式 d = b² - 4ac。使用上面描述的乘法函数。
- en: Suppose that you load the following into locations 10-17 of TOY, set the PC
    to 10, and press RUN. The program reads in an integer from standard input and
    prints out a single integer to standard output. List all input values between
    `0123` and `3210` for which the program print `0000`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你将以下内容加载到 TOY 的 10-17 位置，将 PC 设置为 10，然后按运行。该程序从标准输入读取一个整数，并将一个整数打印到标准输出。列出所有输入值在
    `0123` 和 `3210` 之间，使得程序打印 `0000`。
- en: '|'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '*Answer*: `0200 0400 0800 1000 2000`. It returns 1 for all inputs that have
    at most one 1 in their binary representation, i.e, the hexadecimal integers 0000,
    0001, 0002, 0004, 0008, 0010, ..., 8000.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：`0200 0400 0800 1000 2000`。对于所有二进制表示中最多有一个 1 的输入，即十六进制整数 0000、0001、0002、0004、0008、0010、...、8000，它返回
    1。'
- en: Suppose that you load the following data into memory locations 30 through 37
    before pressing RUN.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你在按运行之前将以下数据加载到内存位置 30 到 37。
- en: '|'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: set the PC to 10, and press RUN. What will be the contents of memory locations
    30 through 37 after running the program?
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将PC设置为10，然后按运行。运行程序后，内存位置30到37的内容将是什么？
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Translate the above TOY program into Java code by filling in the ????.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述TOY程序翻译成Java代码，填写????。
- en: '[PRE24]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Suppose that you load the following into locations 10-1F of TOY, load the following
    data into locations 30-37, Suppose that you load the following data into memory
    locations 30 through 37 before pressing RUN.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你将以下内容加载到TOY的10-1F位置，将以下数据加载到30-37位置，假设你在按下运行之前将以下数据加载到内存位置30到37。
- en: '|'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: set the PC to 10, and press RUN. What will be the contents of memory locations
    30 through 37 after running the program?
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将PC设置为10，然后按运行。运行程序后，内存位置30到37的内容将是什么？
- en: Suppose that you load the following into locations 10-1B of TOY, set the PC
    to 10, and press RUN. Suppose also that the following data is entered from standard
    input. What value is printed?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你将以下内容加载到TOY的10-1B位置，将PC设置为10，然后按运行。还假设以下数据从标准输入输入。打印出什么值？
- en: '|'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Repeat the previous exercise, but with the following data on standard input.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一个练习，但使用以下数据作为标准输入。
- en: '|'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: The following table shows the contents for the TOY registers and a section of
    TOY memory. Suppose that you set the program counter to 30 and hit run. What,
    if anything, is printed to standard output? List the final contents of registers
    2 and 3 upon termination.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下表显示了TOY寄存器的内容和TOY内存的一部分。假设将程序计数器设置为30并运行。在标准输出中打印出什么，如果有的话，在终止时列出寄存器2和3的最终内容。
- en: '|'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'Suppose that the data for memory locations D0 through E0 is as follows. What
    is the result of running `linked.toy`? *Answer*: 1 2 3 4 5 6 7.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设内存位置D0到E0的数据如下。运行`linked.toy`的结果是什么？ *答案*：1 2 3 4 5 6 7。
- en: Change one word of memory in the previous exercise so that it prints out 1 2
    6 7 instead of 1 2 3 4 5 6 7\. (linked list deletion)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改上一个练习中的一个内存字，以便打印出1 2 6 7而不是1 2 3 4 5 6 7。 （链表删除）
- en: Change three words of memory (overwriting one, and using two more) so that it
    prints out 1 2 3 4 8 5 6 7\. (linked list insertion)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改三个内存字（覆盖一个，使用另外两个）以便打印出1 2 3 4 8 5 6 7。 （链表插入）
- en: Creative Exercises
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Maximum.** Write a program `max.toy` that reads in a sequence of nonnegative
    integers from standard input and prints out the maximum one. Stop reading in integers
    as soon as you encounter a negative integer.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大值。** 编写一个名为`max.toy`的程序，从标准输入读取一系列非负整数，并打印出最大值。一旦遇到负整数，停止读取整数。'
- en: '**Magic swap.** Write a TOY code fragment that swaps the contents of registers
    A and B, without writing to main memory or any other registers. Hint: use the
    XOR instruction.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**魔术交换。** 编写一个TOY代码片段，交换寄存器A和B的内容，而不写入主存储器或任何其他寄存器。提示：使用XOR指令。'
- en: '**32-bit integers.** Represent a 32-bit two''s complement integer in TOY with
    two consecutive words of memory or registers (big endian or little endian). Explain
    how to add two 32-bit integers.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**32位整数。** 用TOY表示32位二进制补码整数，使用内存或寄存器的两个连续字（大端或小端）。解释如何相加两个32位整数。'
- en: '**Gray codes.** Write a TOY program [graycode.toy](graycode.toy) that reads
    in an integer n (between 1 and 15) from standard input and then prints out `(i
    >> 1) ^ i` to standard output for i = 2^n - 1 through 0. The resulting sequence
    is called a [Gray code](http://mathworld.wolfram.com/GrayCode.html) of order n.
    See Exercise XYZ in Section 5.1.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**格雷码。** 编写一个TOY程序[graycode.toy](graycode.toy)，从标准输入读取一个整数n（介于1和15之间），然后打印出`(i
    >> 1) ^ i`到标准输出，其中i = 2^n - 1到0。生成的序列称为n阶[格雷码](http://mathworld.wolfram.com/GrayCode.html)。参见第5.1节中的练习XYZ。'
- en: The Visual X-TOY Simulator uses the LCD display to show standard output. It
    is instructive to watch the alternate standard output (the tape punch card) and
    see the individual bits (8 per row).
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可视化X-TOY模拟器使用LCD显示器显示标准输出。观看备���标准输出（打孔卡）并查看每行的单个位是很有启发性的。
- en: '**Greatest common divisor.** Write a program [gcd.toy](gcd.toy) that reads
    in two integers from standard input and prints their greatest common divisor to
    standard output. Write a function that assumes that registers A and B contain
    two input integers, output the value in register C, and returns to the address
    stored in register F. You may use the following (inefficient) algorithm:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大公约数。** 编写一个程序[gcd.toy](gcd.toy)，从标准输入读取两个整数，并将它们的最大公约数打印到标准输出。编写一个假设寄存器A和B包含两个输入整数的函数，将值输出到寄存器C，并返回到寄存器F中存储的地址。你可以使用以下（低效的）算法：'
- en: '|'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '**One-time pad.** Implement a one-time pad in TOY to encrypt and decrypt 256
    bit messages. Assume that the key is stored in memory location 30 - 3F and that
    the input consists of sixteen 16-bit integers.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一次性密码本。** 在TOY中实现一次性密码本，用于加密和解密256位消息。假设密钥存储在内存位置30-3F，并且输入由十六个16位整数组成。'
- en: '**Dot product.** Compute the dot product of two arrays, which start at locations
    RA and RB and have length RC.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**点积。** 计算两个数组的点积，这两个数组从RA和RB位置开始，长度为RC。'
- en: '**Axpy.** Given a scalar a, a vector x, and a vector b, compute the vector
    ax + b.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Axpy。** 给定标量a，向量x和向量b，计算向量ax + b。'
- en: '**Find the singleton number.** Suppose that a sequence 2N+1 16-bit integers
    appears on standard input such that N integers appear exactly twice and one integer
    appears only once. Write a TOY program to find the singelton integer.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找单身数字。** 假设一个包含2N+1个16位整数的序列出现在标准输入中，其中N个整数出现两次，一个整数只出现一次。编写一个TOY程序来找到单身整数。'
- en: '*Hint*: XOR all of the integers together.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：对所有整数执行异或操作。'
