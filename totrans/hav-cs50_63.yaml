- en: Lecture 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6讲
- en: 原文：[https://cs50.harvard.edu/sql/notes/6/](https://cs50.harvard.edu/sql/notes/6/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/sql/notes/6/](https://cs50.harvard.edu/sql/notes/6/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[MySQL](#mysql)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL](#mysql)'
- en: '[Creating the `cards` Table](#creating-the-cards-table)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建 `cards` 表](#creating-the-cards-table)'
- en: '[Questions](#questions)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions)'
- en: '[Creating the `stations` Table](#creating-the-stations-table)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建 `stations` 表](#creating-the-stations-table)'
- en: '[Questions](#questions-1)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-1)'
- en: '[Creating the `swipes` Table](#creating-the-swipes-table)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建 `swipes` 表](#creating-the-swipes-table)'
- en: '[Questions](#questions-2)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-2)'
- en: '[Altering Tables](#altering-tables)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[修改表](#altering-tables)'
- en: '[Stored Procedures](#stored-procedures)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[存储过程](#stored-procedures)'
- en: '[Questions](#questions-3)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-3)'
- en: '[Stored Procedures with Parameters](#stored-procedures-with-parameters)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[带有参数的存储过程](#stored-procedures-with-parameters)'
- en: '[PostgreSQL](#postgresql)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PostgreSQL](#postgresql)'
- en: '[Questions](#questions-4)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-4)'
- en: '[Creating PostgreSQL Tables](#creating-postgresql-tables)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建 PostgreSQL 表](#creating-postgresql-tables)'
- en: '[Scaling with MySQL](#scaling-with-mysql)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 MySQL 进行扩展](#scaling-with-mysql)'
- en: '[Access Controls](#access-controls)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[访问控制](#access-controls)'
- en: '[SQL Injection Attacks](#sql-injection-attacks)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQL 注入攻击](#sql-injection-attacks)'
- en: '[Questions](#questions-5)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-5)'
- en: '[Fin](#fin)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Fin](#fin)'
- en: Introduction
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Thus far in this course, we have learned how to design and create our own databases,
    read and write data and most recently, how to optimize our queries. Now, we will
    understand how to do all these things but at a larger scale.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，在本课程中，我们已经学习了如何设计和创建自己的数据库，读取和写入数据，以及最近如何优化我们的查询。现在，我们将了解如何以更大的规模来做这些事情。
- en: Scalability is the ability to increase or decrease the capacity of an application
    or database to meet demand.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性是增加或减少应用程序或数据库容量以满足需求的能力。
- en: Social media platforms and banking systems are examples of applications that
    might need to scale as they grow bigger and gain more users.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交媒体平台和银行系统是可能需要随着其规模扩大和用户增加而扩展的应用程序的例子。
- en: In this lecture, we will use different database management systems like MySQL
    and PostgreSQL which can be used to scale databases.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本讲中，我们将使用不同的数据库管理系统，如 MySQL 和 PostgreSQL，这些系统可以用于扩展数据库。
- en: SQLite is an embedded database, but MySQL and PostgreSQL are database servers
    — they often run on their own dedicated hardware that we can connect to over the
    internet to run our SQL queries. This confers them the advantage of being able
    to store their data on RAM, resulting in faster queries.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 是一个嵌入式数据库，但 MySQL 和 PostgreSQL 是数据库服务器——它们通常运行在它们自己的专用硬件上，我们可以通过互联网连接到它们来运行我们的
    SQL 查询。这使得它们能够将数据存储在 RAM 中，从而实现更快的查询。
- en: MySQL
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL
- en: We will use the MBTA database that we have worked with in previous lectures.
    The following is the ER Diagram showing the entities Card, Swipe and Station and
    the relationship between these entities.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用我们在之前的讲座中使用的 MBTA 数据库。以下是一个 ER 图，显示了实体 Card、Swipe 和 Station 以及这些实体之间的关系。
- en: '!["ER Diagram for MBTA database with Card, Swipe and Station entities"](../Images/4952a9ffdade6c2b6e5963788f93bf2f.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![MBTA 数据库的 ER 图，包含 Card、Swipe 和 Station 实体](../Images/4952a9ffdade6c2b6e5963788f93bf2f.png)'
- en: As a reminder, riders who use the subway have a CharlieCard they swipe at stations
    to gain entry. Riders can recharge their cards and in some cases, they need to
    swipe their cards to leave a station as well. The MBTA does not store information
    about riders, but only keeps track of the cards.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为提醒，使用地铁的乘客有一个 CharlieCard，在车站刷卡以获得进入权限。乘客可以充值卡片，在某些情况下，他们还需要刷卡才能离开车站。MBTA
    不存储有关乘客的信息，但只跟踪卡片。
- en: We want to create a database in MySQL with this schema! On the terminal, let’s
    connect to a MySQL server.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要使用这个模式在 MySQL 中创建一个数据库！在终端上，让我们连接到一个 MySQL 服务器。
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this terminal command, `-u` indicates the user. We provide the user we want
    to connect to the database as — `root` (synonymous with database admin, in this
    case).
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个终端命令中，`-u` 表示用户。我们提供我们想要连接到数据库的用户——`root`（在这种情况下与数据库管理员同义）。
- en: '`127.0.0.1` is the address of local host on the internet (our own computer).'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1` 是互联网上本地主机的地址（我们的电脑）。'
- en: '`3306` is the port we want to connect to, and this is the default port where
    MySQL is hosted. Think of the combination of host and port as the address of the
    database we are trying to connect to!'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3306` 是我们想要连接的端口，这是 MySQL 的默认端口。将主机和端口的组合视为我们试图连接的数据库的地址！'
- en: '`-p` at the end of the command indicates that we want to be prompted for a
    password when connecting.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令末尾的`-p`表示我们希望在连接时提示输入密码。
- en: Since this a full database server with potentially many databases inside it.
    To show all the existing ones, we use the following MySQL command.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是一个完整的数据库服务器，其中可能包含许多数据库。要显示所有现有的数据库，我们使用以下MySQL命令。
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This returns some default databases already in the server.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这返回了一些服务器中已经存在的默认数据库。
- en: We will perform some operations to set up the MBTA database. We have seen how
    to do these in SQLite already, so let’s focus on the syntax differences for MySQL!
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将执行一些操作来设置MBTA数据库。我们已经看到了如何在SQLite中完成这些操作，所以让我们专注于MySQL的语法差异！
- en: 'Creating a new database:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新数据库：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of quotation marks, we use backticks to identify the table name and
    other variables in our SQL statements.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用反引号而不是引号来标识SQL语句中的表名和其他变量。
- en: 'To change the current database to `mbta`:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将当前数据库更改为`mbta`：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating the `cards` Table
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`cards`表
- en: MySQL has more granularity with types than SQLite. For example, an integer could
    be `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT` or `BIGINT` based on the size of
    the number we want to store. The following table shows us the size and range of
    numbers we can store in each of the integer types.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL在类型上比SQLite有更多的粒度。例如，一个整数可以是`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`或`BIGINT`，这取决于我们想要存储的数字的大小。以下表格显示了我们可以存储在每个整数类型中的数字的大小和范围。
- en: '!["Table of integer types in MySQL"](../Images/02c1398f7505c6c0a0d26b4dbdcef9cd.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![MySQL中整数类型的表格](../Images/02c1398f7505c6c0a0d26b4dbdcef9cd.png)'
- en: These ranges assume that we want to use a signed integer. If we use unsigned
    integers, the maximum value we could store with each integer type would double.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些范围假设我们想要使用有符号整数。如果我们使用无符号整数，每个整数类型可以存储的最大值将翻倍。
- en: Let us now create the table `cards` using an `INT` data type for the ID column.
    Since an `INT` can store a number up to 4 billion, it should be big enough for
    our use case!
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们将使用`INT`数据类型为ID列创建表`cards`。由于`INT`可以存储高达40亿的数字，它应该足够大，可以满足我们的使用案例！
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we use the keyword `AUTO_INCREMENT` with the ID so that MySQL automatically
    inserts the next number as the ID for a new row.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用关键字`AUTO_INCREMENT`与ID一起使用，这样MySQL会自动插入下一个数字作为新行的ID。
- en: Questions
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Should the ID column not be an unsigned integer? How can we denote that?
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果ID列不是无符号整数怎么办？我们如何表示这一点？
- en: Yes, we could explicitly make the ID an unsigned integer by adding the keyword
    `UNSIGNED` while creating the integer.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，我们可以在创建整数时显式地将ID设置为无符号整数，通过添加关键字`UNSIGNED`。
- en: Creating the `stations` Table
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`stations`表
- en: 'After creating the table, we can see a list of the existing tables by running:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表后，我们可以通过运行以下命令来查看现有表的列表：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For further details about a table, we can use the `DESCRIBE` command.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取关于表的更多详细信息，我们可以使用`DESCRIBE`命令。
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To handle text, MySQL provides many types. Two commonly used ones are `CHAR`
    — a fixed width string, and `VARCHAR` — a string of variable length. MySQL also
    has a type `TEXT` but unlike in SQLite, this type is used for longer chunks of
    text like paragraphs, pages of books etc. Based on the length of the text, it
    could be one of: `TINYTEXT`, `TEXT`, `MEDIUMTEXT` and `LONGTEXT`. Additionally,
    we have the `BLOB` type to store binary strings.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理文本，MySQL提供了许多类型。两种常用的类型是`CHAR`——一个固定宽度的字符串，和`VARCHAR`——一个可变长度的字符串。MySQL还有一个`TEXT`类型，但与SQLite不同，这种类型用于更长的文本块，如段落、书籍的页面等。根据文本的长度，它可以是`TINYTEXT`、`TEXT`、`MEDIUMTEXT`和`LONGTEXT`之一。此外，我们还有`BLOB`类型来存储二进制字符串。
- en: 'MySQL also provides two other text types: `ENUM` and `SET`. Enum restricts
    a column to a single predefined option from a list of options we provide. For
    example, shirt sizes could be enumerated to M, L, XL and so on. A set allows for
    multiple options to be stored in a single cell, useful for scenarios like movie
    genres.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL还提供了两种其他文本类型：`ENUM`和`SET`。Enum将列限制为我们提供的选项列表中的单个预定义选项。例如，衬衫尺寸可以枚举为M、L、XL等。Set允许在单个单元格中存储多个选项，这在电影类型等场景中很有用。
- en: Now, let us create the `stations` table in MySQL.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们在MySQL中创建`stations`表。
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We choose a `VARCHAR` for the station name because names might be an unknown
    length. The line that a station is on, however, is one of the existing subway
    lines in Boston. Since we know the values this could take, we can use an `ENUM`
    type.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择`VARCHAR`作为站名，因为名字可能长度不一。然而，一个站点所在的线路是波士顿现有的地铁线路之一。由于我们知道这些值可能是什么，我们可以使用`ENUM`类型。
- en: We also use column constraints `UNIQUE` and `NOT NULL` in the same way as we
    did with SQLite.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也像在SQLite中一样，使用列约束`UNIQUE`和`NOT NULL`。
- en: On running the command to describe this table, we see a similar output that
    lists out each of the columns in the table. Under the `Key` field, the primary
    key is recognized by `PRI` and any column with unique values is recognized by
    `UNI`. The `NULL` field tells us which columns allow `NULL` values, which none
    of the columns do for the `stations` table.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行描述此表的命令后，我们看到一个类似的输出，列出了表中的每一列。在`Key`字段下，主键通过`PRI`被识别，任何具有唯一值的列通过`UNI`被识别。`NULL`字段告诉我们哪些列允许`NULL`值，对于`stations`表来说，没有列允许`NULL`值。
- en: Questions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Can we use a table as the input to `ENUM`?
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能否将表作为`ENUM`的输入？
- en: This might be possible using a nested `SELECT` statement but this might not
    be a good idea if the values within the table change over time. It may be best
    to explicitly state values as the options for `ENUM`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能可以通过嵌套`SELECT`语句来实现，但如果表中的值随时间变化，这可能不是一个好主意。最好明确地将值作为`ENUM`的选项。
- en: If we do not know how long a piece of text will be and use something like `VARCHAR(300)`
    to represent it, is that okay?
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们不知道一段文本的长度，并使用类似`VARCHAR(300)`来表示它，这是否可以？
- en: While this is okay, there is a trade-off here. We will lose 300 bytes of memory
    for every row of data inserted, which might not be worth it if we end up storing
    only very small strings. It might be better to start off with a smaller length
    and then alter the table to increase length if needed.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这是可以的，但这里有一个权衡。每插入一行数据，我们将失去300字节的内存，如果我们最终只存储非常小的字符串，这可能不值得。可能更好的是从较小的长度开始，然后在需要时更改表以增加长度。
- en: Creating the `swipes` Table
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`swipes`表
- en: MySQL provides us with some options for storing dates and times, while in SQLite
    they had to be stored using the numeric type.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL为我们提供了一些存储日期和时间的选项，而SQLite则必须使用数值类型来存储。
- en: We could use `DATE`, `YEAR`, `TIME`, `DATETIME` and `TIMESTAMP` (for more precise
    times) to store our date and time values. The last three allow an optional parameter
    to specify the precision with which we want to store the time.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`DATE`、`YEAR`、`TIME`、`DATETIME`和`TIMESTAMP`（用于更精确的时间）来存储我们的日期和时间值。最后三个允许可选参数来指定我们想要存储时间的精度。
- en: In SQLite, we had a `REAL` data type. Here, our options are `FLOAT` and `DOUBLE
    PRECISION` as shown in the table below.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SQLite中，我们有`REAL`数据类型。在这里，我们的选项是表下面的`FLOAT`和`DOUBLE PRECISION`。
- en: '!["Real Data types in MySQL"](../Images/67f815ec01975eb3e287c7bbea078e0a.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![MySQL中的实际数据类型](../Images/67f815ec01975eb3e287c7bbea078e0a.png)'
- en: The amount of precision needs to be specified with the number of bytes, because
    of floating point imprecision. This means that with a limited amount of memory,
    floating point numbers can be represented only up to a certain precision. The
    more the bytes, the more the precision with which the number is represented.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于浮点数的不精确性，需要指定字节数来确定精度。这意味着在有限的内存中，浮点数只能表示到一定的精度。字节越多，表示数字的精度就越高。
- en: There is also a way in MySQL to use a decimal (fixed precision) type. With this,
    we would specify the number of digits in the number to be represented, and the
    number of digits after the decimal point.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MySQL中，也有一种使用十进制（固定精度）类型的方法。使用这种方法，我们将指定要表示的数字中的位数以及小数点后的位数。
- en: Let us now create the `swipes` table.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们现在创建`swipes`表。
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the use of `DEFAULT CURRENT_TIMESTAMP` to indicate that the timestamp
    should be auto-filled to store the current time if no value is provided.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意到使用`DEFAULT CURRENT_TIMESTAMP`来指示如果未提供值，则应自动填充时间戳以存储当前时间。
- en: The precision we choose for the swipe amount is 2\. This is to ensure that cents
    get added or subtracted without any rounding.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为滑动金额选择的精度是2。这是为了确保在没有任何舍入的情况下，可以添加或减去分。
- en: The column constraints from when we created the table in SQLite remain, including
    the check to make sure the swipe amount is not negative.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在SQLite中创建表时使用的列约束仍然存在，包括确保滑动金额不是负数的检查。
- en: If we describe this table after creating it, we will see familiar output. The
    `Key` field has a new value, `MUL` (multiple) for the foreign key columns, indicating
    that they could have repeating values since they are foreign keys.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在创建表后描述它，我们将看到熟悉的输出。`Key`字段有一个新值，对于外键列，`MUL`（多个）表示它们可能有重复的值，因为它们是外键。
- en: Questions
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: When we add constraints to a column, is there a precedence with which they take
    effect?
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们向列添加约束时，它们是否有生效的优先级？
- en: No, the constraints work together in a combined manner. MySQL allows us to add
    constraints in any order while creating the table.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，约束以组合方式共同工作。MySQL 允许我们在创建表时以任何顺序添加约束。
- en: Does MySQL have type affinities?
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MySQL 有类型亲和力吗？
- en: Not exactly. MySQL does have data types, like `INT` and `VARCHAR` but unlike
    SQLite, it will not allow us to enter data of a different type and try to convert
    it.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不完全是这样。MySQL 确实有数据类型，如 `INT` 和 `VARCHAR`，但与 SQLite 不同，它不会允许我们输入不同类型的数据并尝试转换它。
- en: Altering Tables
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改表
- en: MySQL allows us to alter tables more fundamentally than SQLite did.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 允许我们比 SQLite 更根本地修改表。
- en: If we wanted to add a silver line to the possible lines a station could be on,
    we can do the following.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要向一个站点可能所在的线路中添加一条银色线路，我们可以这样做。
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This allows us to modify the `line` column and change its type, such that the
    `ENUM` now includes silver as an option.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许我们修改 `line` 列并更改其类型，使得 `ENUM` 现在包括银色作为选项。
- en: Note also that we use the keyword `MODIFY` in addition to the `ALTER TABLE`
    construct we are familiar with from SQLite.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还要注意，我们除了使用熟悉的 SQLite 中的 `ALTER TABLE` 构造外，还使用了 `MODIFY` 关键字。
- en: Stored Procedures
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储过程
- en: Stored procedures are a way to automate SQL statements and run them repeatedly.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储过程是一种自动化 SQL 语句并重复运行它们的方式。
- en: To demonstrate stored procedures, we will again use a database from previous
    lectures — the Boston MFA database.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了演示存储过程，我们再次使用之前讲座中提到的数据库——波士顿 MFA 数据库。
- en: Recall that we used views in SQLite to implement a soft-delete feature for `collections`
    in the MFA database. A view `current_collections` displayed all the collections
    not marked as deleted. We will now use a stored procedure in MySQL to do something
    similar.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，我们在 SQLite 中使用视图来实现 MFA 数据库中 `collections` 的软删除功能。一个名为 `current_collections`
    的视图显示了所有未被标记为已删除的集合。现在，我们将使用 MySQL 中的存储过程来完成类似的功能。
- en: Let’s navigate to the MFA database already created on our MySQL server.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们导航到已经在我们的 MySQL 服务器上创建的 MFA 数据库。
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On describing the `collections` table, we see that the `deleted` column is not
    present and needs to be added to the table.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在描述 `collections` 表时，我们看到 `deleted` 列不存在，需要添加到表中。
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Given that the `deleted` column only has values of 0 or 1, it is safe to use
    a `TINYINT`. We also assign the default as 0 because we want to keep all the collections
    already in the table.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `deleted` 列只有 0 或 1 的值，使用 `TINYINT` 是安全的。我们还将其默认值设置为 0，因为我们希望保留表中已有的所有集合。
- en: Before we create a stored procedure, we need to change the delimited from `;`
    to something else. Unlike SQLite, where we could type in multiple statements between
    a `BEGIN` and `END` (which we need for a stored procedure here) and end them with
    a `;`, MySQL prematurely ends the statement when it encounters a `;`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们创建存储过程之前，我们需要将分隔符从 `;` 改为其他东西。与 SQLite 不同，在 `BEGIN` 和 `END`（这里需要一个存储过程）之间我们可以输入多个语句，并以
    `;` 结尾，而 MySQL 在遇到 `;` 时会提前结束语句。
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we write the stored procedure.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们编写存储过程。
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how we use empty parantheses next to the name of the procedure, perhaps
    reminiscent of functions in other programming languages. Similar to functions,
    we can also call stored procedures to run them.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何在存储过程名称旁边使用空括号，这可能会让人联想到其他编程语言中的函数。与函数类似，我们也可以调用存储过程来运行它们。
- en: After creating this, we must reset the delimited to `;`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建此过程后，我们必须将分隔符重置为 `;`。
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let us try calling this procedure to see the current collections. At this point,
    the query should output all the rows in the `collections` table because we haven’t
    soft-deleted anything yet.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们尝试调用这个过程来看看当前的集合。在这个时候，查询应该输出 `collections` 表中的所有行，因为我们还没有进行软删除。
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we soft-delete “Farmers working at dawn” and call the procedure again, we
    will find that the deleted row is not included in the output.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们软删除“黎明时分工作的农民”并再次调用该过程，我们会发现已删除的行不包括在输出中。
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Questions
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Can we add parameters to stored procedures, ie, call them with some input?
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能否向存储过程添加参数，即用一些输入来调用它们？
- en: Yes, we can and we will see an example shortly!
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，我们可以，很快就会看到一个例子！
- en: Can we call one procedure from another, like with functions?
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能否像函数一样从一个存储过程调用另一个存储过程？
- en: Yes. You could put most any SQL statement you write in a procedure as well.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的。你可以在存储过程中放入你写的几乎所有 SQL 语句。
- en: Can you leave any notes or comments in tables in MySQL?
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能在 MySQL 的表中留下任何注释或备注吗？
- en: That definitely might be a useful feature! You could leave comments in a `schema.sql`
    file describing the intent behind different parts of the schema, but there may
    be ways to add comments in SQL tables as well.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这绝对可能是一个有用的功能！你可以在`schema.sql`文件中留下注释，描述模式不同部分的意图，但也许还有在SQL表中添加注释的方法。
- en: Stored Procedures with Parameters
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带参数的存储过程
- en: When we previously worked with the MFA database, we had a table called `transactions`
    to log artwork being bought or sold, which we can create here as well.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们之前与MFA数据库合作时，我们有一个名为`transactions`的表来记录购买的或出售的艺术品，我们也可以在这里创建它。
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, if a piece of artwork is deleted from `collections` because it is being
    sold, we would also like to update this in the `transactions` table. Usually,
    this would be two different queries but with a stored procedure, we can give this
    sequence one name.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，如果一件艺术品因为出售而从`collections`中被删除，我们也希望更新`transactions`表中的这一信息。通常，这将是两个不同的查询，但通过存储过程，我们可以给这个序列一个名称。
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The choice of the parameter for this procedure is the ID of the painting or
    artwork because it is a unique identifier.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个过程参数的选择是绘画或艺术品的ID，因为它是一个唯一的标识符。
- en: We can now call the procedure to sell a particular item. Suppose we want to
    sell “Imaginative landscape”.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以调用这个过程来出售特定的物品。假设我们想要出售“想象中的风景”。
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can display data from the `collections` and `transactions` tables to verify
    that the changes were made.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以显示`collections`和`transactions`表中的数据，以验证所做的更改。
- en: What happens if I call `sell` on the same ID more than once? There is a danger
    of it being added multiple times to the `transactions` table. Stored procedures
    can be considerably improved in logic and complexity by using some regular old
    programming constructs. The following list contains some popular constructs available
    in MySQL.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我多次调用`sell`同一个ID会发生什么？它可能会被多次添加到`transactions`表中。通过使用一些常规的编程结构，存储过程在逻辑和复杂性上可以得到相当大的改进。以下列表包含了一些在MySQL中可用的流行结构。
- en: '!["Programming constructs in MySQL"](../Images/170442d5d162d1ce2083e2f29322b651.png)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![MySQL中的编程结构](../Images/170442d5d162d1ce2083e2f29322b651.png)'
- en: PostgreSQL
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: So far in this lecture, we’ve seen how to use MySQL, which gives us some ability
    to scale over what SQLite can provide.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，在本讲座中，我们看到了如何使用MySQL，这让我们能够扩展SQLite所能提供的能力。
- en: We will now explore the affordances of PostgreSQL by following the same process
    as we did with MySQL. We will work with some existing SQLite databases and convert
    them into PostgreSQL.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在将通过与MySQL相同的流程来探索PostgreSQL的功能。我们将使用一些现有的SQLite数据库并将它们转换为PostgreSQL。
- en: Going back to the MBTA database which had a table `cards`, let’s see what data
    types are available to us in PostgreSQL.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到之前提到的MBTA数据库，它有一个名为`cards`的表，让我们看看PostgreSQL为我们提供了哪些数据类型。
- en: '**Integers**'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**'
- en: '!["Integer types in PostgreSQL"](../Images/94732bf9f8869d11f6f02ecc117f726b.png)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![PostgreSQL中的整数类型](../Images/94732bf9f8869d11f6f02ecc117f726b.png)'
- en: We can observe that there are fewer options here than MySQL. PostgreSQL also
    provides unsigned integers, similar to MySQL. That would mean double the maximum
    value shown here can be stored in each inteeger type when working with unsigned
    integers.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以观察到这里的选项比MySQL少。PostgreSQL也提供了无符号整数，类似于MySQL。这意味着在处理无符号整数时，每个整数类型可以存储的最大值是这里显示的两倍。
- en: '**Serial**'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**'
- en: Serials are also integers, but they are serial numbers, usually used for primary
    keys.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列也是整数，但它们是序列号，通常用于主键。
- en: Let us connect to the database server by opening PSQL — the command line interface
    for PostgreSQL.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们通过打开PSQL（PostgreSQL的命令行界面）来连接到数据库服务器。
- en: '[PRE20]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can log in as the default Postgres user or the admin.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以以默认的Postgres用户或管理员身份登录。
- en: To view all the databases, we can run `\l` and it pulls up a list.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看所有数据库，我们可以运行`\l`，它会弹出一个列表。
- en: 'To create the MBTA database, we can run:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建MBTA数据库，我们可以运行：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To connect to this specific database, we can run `\c "mbta"`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要连接到这个特定的数据库，我们可以运行`\c "mbta"`。
- en: To list out all the tables in the database, we can run `\dt`. Right now, though,
    we will see no tables within the database.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要列出数据库中的所有表，我们可以运行`\dt`。然而，目前数据库中还没有表。
- en: Finally, we can create the `cards` table, as proposed. We use a `SERIAL` data
    type for the ID column.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以按照提议创建`cards`表，我们为ID列使用`SERIAL`数据类型。
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To describe a table in PostgreSQL, we can use a command like `\d "cards"`. On
    running this, we see some information about this table but in a slightly different
    format from MySQL.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL 中描述一个表，我们可以使用像 `\d "cards"` 这样的命令。运行此命令后，我们会看到有关此表的一些信息，但格式与 MySQL
    略有不同。
- en: Questions
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: How do you know in PostgreSQL if your query is resulting in an error?
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何在 PostgreSQL 中知道你的查询是否导致错误？
- en: If you hit Enter and the database server does not say ptu, you will know there
    may be an error. It is also likely that PostgreSQL will give you some helpful
    error messages to point you in the right direction.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你按下回车键，而数据库服务器没有显示 ptu，你就知道可能存在错误。也可能 PostgreSQL 会给你一些有用的错误消息，以帮助你找到正确的方向。
- en: Creating PostgreSQL Tables
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 PostgreSQL 表
- en: The `stations` table is created in a similar manner to MySQL.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stations` 表以类似 MySQL 的方式创建。'
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can use `VARCHAR` in the same way as in MySQL. To keep things simple, we
    say that the `"line"` column id also of the `VARCHAR` type.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在 PostgreSQL 中像在 MySQL 中一样使用 `VARCHAR`。为了使事情简单，我们可以说 `"line"` 列也是 `VARCHAR`
    类型。
- en: We want to create the `swipes` table next. Recall that the swipe type can mark
    entry, exit or deposit of funds in the card. Similar to MySQL, we can use an `ENUM`
    to capture these options, but do not include it in the column definition. Instead,
    we create our own type.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接下来想要创建 `swipes` 表。回想一下，滑动类型可以标记卡的进入、退出或资金存入。类似于 MySQL，我们可以使用 `ENUM` 来捕获这些选项，但不要将其包含在列定义中。相反，我们创建自己的类型。
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: PostgreSQL has types `TIMESTAMP`, `DATE`, `TIME` and `INTERVAL` to represent
    date and time values. `INTERVAL` is used to capture how long something took, or
    the distance between times. Similar to MySQL, we can specify the precision with
    these types.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 有 `TIMESTAMP`、`DATE`、`TIME` 和 `INTERVAL` 类型来表示日期和时间值。`INTERVAL` 用于捕获某物持续了多长时间，或时间之间的距离。类似于
    MySQL，我们可以使用这些类型指定精度。
- en: A key difference with real number types in PostgreSQL is that the `DECIMAL`
    type is called `NUMERIC`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 PostgreSQL 中的实数类型相比，一个关键的区别是 `DECIMAL` 类型被称为 `NUMERIC`。
- en: We can now go ahead and create the `swipes` table as the following.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建 `swipes` 表，如下所示。
- en: '[PRE25]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For the default timestamp, we use a function provided to us by PostgreSQL called
    `now()` thst gives us the current timestamp!
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于默认的时间戳，我们使用 PostgreSQL 提供的函数 `now()`，它给我们当前的时戳！
- en: To exit PostgreSQL, we use the command `\q`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要退出 PostgreSQL，我们使用命令 `\q`。
- en: Scaling with MySQL
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MySQL 进行扩展
- en: Consider a database server for an application growing in demand. As the number
    of reads and writes coming in from the application begin to increase, the wait
    time for the queries to be processed by the server increases also.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个需求增长的应用程序数据库服务器。随着来自应用程序的读取和写入数量的增加，服务器处理查询的等待时间也会增加。
- en: One approach here is to scale the database vertically. Scaling vertically is
    increasing capacity by increasing the computing power of the database server.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的一种方法是通过垂直扩展数据库。垂直扩展是通过增加数据库服务器的计算能力来增加容量。
- en: Another approach is to scale horizontally. This means increasing capacity by
    distributing load across multiple servers. When we scale horizontally, we keep
    copies of our database on multiple servers (replication).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是水平扩展。这意味着通过在多个服务器之间分配负载来增加容量。当我们水平扩展时，我们在多个服务器上保留数据库的副本（复制）。
- en: 'There are three main models of replication: single-leader, multi-leader, and
    leaderless. Single-leader replication involves a single database server handling
    incoming writes and then copying those changes into other servers, while multi-leader
    replication involves multiple servers receiving updates, leading to increased
    complexity. Leaderless replication uses a different approach altogether that does
    not require leaders in this sense.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制主要有三种模式：单主模式、多主模式和领导者无模式。单主复制涉及单个数据库服务器处理传入的写入，然后将这些更改复制到其他服务器，而多主复制涉及多个服务器接收更新，导致复杂性增加。领导者无模式采用完全不同的方法，不要求有领导者。
- en: 'Here, we will focus on the **single-leader model of replication**. In this
    model, the follower database server is a read replica: a copy of the database
    from which data may only be read. The leader server is designated to process writes
    to the database.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们将重点关注 **单主复制模式**。在这个模式中，跟随数据库服务器是一个只读副本：一个只能从中读取数据的数据库副本。领导者服务器被指定处理对数据库的写入。
- en: Once the leader processes a write request, it could wait for the followers to
    replicate changes before doing anything else. This is called **synchronous replication**.
    While this ensures the database is always consistent, it may be too slow in responding
    to queries. In applications like finance or healthcare, where data consistency
    is extremely important, we might choose this kind of communication despite the
    disadvantages.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦领导者处理完写请求，它可以在做其他任何事情之前等待跟随者复制更改。这被称为**同步复制**。虽然这确保了数据库始终一致，但它可能对查询的响应速度太慢。在金融或医疗保健等数据一致性至关重要的应用程序中，我们可能会选择这种通信方式，尽管它有缺点。
- en: Another kind is **asynchronous replication**, wherein the leader communicates
    with follower databases asynchronously to ensure changes are replicated. This
    method could be used in social media applications, where speed of response is
    extremely important.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种类型是**异步复制**，其中领导者以异步方式与跟随者数据库通信，以确保更改被复制。这种方法可以用于社交媒体应用程序，其中响应速度至关重要。
- en: 'Another popular way of scaling is called **sharding**. This involves splitting
    the database into shards across multiple database servers. A word of caution with
    sharding: we want to avoid having a database hotspot, or a database server that
    becomes more frequently accessed than others. This could create an overload on
    that server.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种流行的扩展方式称为**分片**。这涉及到将数据库分割成多个数据库服务器上的碎片。关于分片的一个注意事项：我们希望避免出现数据库热点，或者一个比其他服务器更频繁被访问的数据库服务器。这可能会给该服务器造成过载。
- en: 'Another problem arises when we use sharding without replication. In this case,
    if one of the servers goes down, we will have an incomplete database. This creates
    a **single point of failure**: if one system goes down, our entire system is not
    usable.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不使用复制进行分片时，会出现另一个问题。在这种情况下，如果其中一个服务器宕机，我们将有一个不完整的数据库。这会创建一个**单点故障**：如果一个系统宕机，我们的整个系统将无法使用。
- en: Access Controls
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制
- en: Previously, we logged into MySQL using the root user. However, we can also create
    more users and give them some kind of access to the database.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前，我们使用root用户登录MySQL。然而，我们也可以创建更多用户并给他们一些数据库访问权限。
- en: Let’s create a new user called Carter (feel free to try with your own name here)!
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为Carter的新用户（在这里你可以尝试使用你自己的名字）！
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can log into MySQL now using the new user and password, in the same way we
    did with the root user previously.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以使用新用户和密码登录MySQL，就像之前使用root用户一样。
- en: When we create this new user, by default it has very few privileges. Try the
    following query.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们创建这个新用户时，默认情况下它只有很少的权限。尝试以下查询。
- en: '[PRE27]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This only displays some of the default databases in the server.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只显示了服务器中的一些默认数据库。
- en: If we log in again with the root user and run the above query, many more databases
    show up! This is because the root user has access to most everything in the server.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们再次以root用户登录并运行上述查询，会出现更多的数据库！这是因为root用户可以访问服务器上的几乎所有内容。
- en: Let us look at how we can grant access to users by discussing an example from
    previous weeks. We had a `rideshare` database with a `rides` table. In this table,
    we stored the names of riders, which is personally identifiable information (PII).
    We created a view called `analysis` which anonymized the names of the riders,
    intending to share only this view with an analyst or other user.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们通过讨论上周的一个例子来探讨如何通过用户授权来授予用户访问权限。我们有一个`rideshare`数据库和一个`rides`表。在这个表中，我们存储了乘客的名字，这是个人身份信息（PII）。我们创建了一个名为`analysis`的视图，匿名化了乘客的名字，目的是只与分析师或其他用户共享这个视图。
- en: If we wanted to share the `analysis` view with the user we just created, we
    would do the following while logged in as the root user.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想与刚刚创建的用户共享`analysis`视图，我们可以在以root用户登录时执行以下操作。
- en: '[PRE28]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, let’s log in as the new user and verify that we can access the view. We
    are now able to run
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们以新用户身份登录并验证我们是否可以访问视图。我们现在能够运行
- en: '[PRE29]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The only part of the database, however, that this user can access is the `analysis`
    view. We can now see the data in this view, but not from the original `rides`
    table! We just demonstrated the benefit of MySQL’s access control: we can have
    multiple users accessing the database but only allow some to access confidential
    data.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，这个用户可以访问的数据库部分只有`analysis`视图。我们现在可以看到这个视图中的数据，但不能从原始的`rides`表中看到！我们刚刚展示了MySQL访问控制的好处：我们可以让多个用户访问数据库，但只允许一些用户访问机密数据。
- en: SQL Injection Attacks
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入攻击
- en: One way to increase security of our database is to use access control and grant
    only the necessary privileges to each user. However, our applications that use
    an SQL database could also be exposed to attacks — one of them is an SQL injection
    attack.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高我们数据库安全性的方法之一是使用访问控制和仅向每个用户授予必要的权限。然而，使用SQL数据库的应用程序也可能受到攻击——其中之一就是SQL注入攻击。
- en: As the name indicates, this involves a malicious user injecting some SQL phrases
    to complete an existing query within our application in an undesirable way.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如其名所示，这涉及到一个恶意用户注入一些SQL短语，以在我们的应用程序中以不希望的方式完成现有查询。
- en: For example, a website that asks a user to log in with their username and password
    may be running a query like this on the database.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个要求用户使用用户名和密码登录的网站可能在数据库上运行如下查询。
- en: '[PRE30]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the above example, the user Carter entered their username and password as
    per usual. However, a malicious user could enter something different, like the
    string “password’ OR ‘1’ = 1” as their password. In this case, they are trying
    to gain access to the entire database of users and passwords.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的例子中，用户Carter像往常一样输入了他们的用户名和密码。然而，一个恶意用户可能会输入不同的内容，比如字符串“password’ OR ‘1’
    = 1”作为他们的密码。在这种情况下，他们试图获取用户和密码的整个数据库的访问权限。
- en: '[PRE31]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In MySQL, we can use prepared statements to prevent SQL injection attacks. Let’s
    connect to MySQL with the user we created previously and change to the `bank`
    database.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MySQL中，我们可以使用预编译语句来防止SQL注入攻击。让我们用之前创建的用户连接到MySQL并切换到`bank`数据库。
- en: An example of an SQL injection attack that can be run to display all user accounts
    from the `accounts` table is this.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以运行的SQL注入攻击示例，可以用来显示`accounts`表中的所有用户账户。
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A prepared statement is a statement in SQL that we can later insert values into.
    For the above query, we can write a prepared statement.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译语句是SQL中的一个语句，我们可以在稍后插入值。对于上面的查询，我们可以编写一个预编译语句。
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The question mark in the prepared statement acts as a safeguard against the
    unintended execution of SQL code.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预编译语句中的问号充当防止意外执行SQL代码的安全措施。
- en: To actually run this statement now and check someone’s balance, we accept user
    input as a variable and then plug it into the prepared statement.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实际运行这个语句并检查某人的余额，我们接受用户输入作为变量，然后将其插入到预编译语句中。
- en: '[PRE34]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the above code, imagine the `SET` statement to be procuring the user’s ID
    through the application! The `@` is a convention for variables in MySQL.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的代码中，想象一下`SET`语句是通过应用程序获取用户的ID！`@`是MySQL中变量的约定。
- en: The prepared statement cleans up input to ensure that no malicious SQL code
    is injected. Let’s try to run the same statements as above but with a malicious
    ID.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译语句清理输入以确保没有恶意SQL代码被注入。让我们尝试运行上面相同的语句，但使用一个恶意的ID。
- en: '[PRE35]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This also gives us the same results as the previous code — it shows us the balance
    of the user with ID 1 and nothing else! Thus, we have prevented a possible SQL
    injection attack.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也给出了与之前代码相同的结果——它显示了ID为1的用户的余额，没有其他内容！因此，我们已经防止了可能的SQL注入攻击。
- en: Questions
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: In this example of prepared statement, does it take into account only the first
    condition from the variable?
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个预编译语句的例子中，它是否只考虑了变量中的第一个条件？
- en: The prepared statement does something called escaping. It finds all the portions
    of the variable that could be malicious and escapes them so they don’t actually
    get executed.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译语句执行一种称为转义的操作。它找到变量中可能恶意的所有部分，并将它们转义，这样它们实际上就不会被执行。
- en: Is this similar to the reason we shouldn’t use formatted strings in Python to
    execute an SQL query?
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是否与我们在Python中执行SQL查询时不应该使用格式化字符串的原因相似？
- en: Yes, format strings in Python have the same pitfall where they are susceptible
    to SQL injection attacks.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，Python中的格式字符串也有同样的陷阱，它们容易受到SQL注入攻击。
- en: Fin
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束
- en: This brings us to the conclusion of Lecture 6 about Scaling in SQL and this
    course — CS50’s Introduction to Databases with SQL!
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这把我们带到了第6讲关于SQL缩放和这门课程——CS50的SQL数据库入门——的结论！
