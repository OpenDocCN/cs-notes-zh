- en: 3.1   Using Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1   使用数据类型
- en: 原文：[https://introcs.cs.princeton.edu/java/31datatype](https://introcs.cs.princeton.edu/java/31datatype)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/31datatype](https://introcs.cs.princeton.edu/java/31datatype)
- en: A *data type* is a set of values and a set of operations defined on those values.
    The primitive data types that you have been using are supplemented in Java by
    extensive libraries of *reference types* that are tailored for a large variety
    of applications. In this section, we consider reference types for string processing
    and image processing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型*是一组值和一组在这些值上定义的操作。���Java中，您一直在使用原始数据类型，这些数据类型由广泛的适用于各种应用程序的*引用类型*库补充。在本节中，我们考虑用于字符串处理和图像处理的引用类型。'
- en: Strings.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串。
- en: 'You have already been using a data type that is not primitive—the `String`
    data type, whose values are sequences of characters. We specify the behavior of
    a data type in an *application programming interface* (API). Here is a partial
    API for Java’s [String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)
    data type:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在使用一个不是原始的数据类型——`String`数据类型，其值是字符序列。我们在*应用程序编程接口*（API）中指定数据类型的行为。这是Java的[String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)数据类型的部分API：
- en: '![String API](../Images/09b67650293dc171af32e34b2ad85239.png)'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![字符串 API](../Images/09b67650293dc171af32e34b2ad85239.png)'
- en: The first entry, with the same name as the class and no return type, defines
    a special method known as a *constructor*. The other entries define *instance
    methods* that can take arguments and return values.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条目，与类名相同且没有返回类型，定义了一种特殊的方法，称为*构造函数*。其他条目定义了可以接受参数并返回值的*实例方法*。
- en: '![using a reference data type](../Images/bc429022eaeee8d06e298c061ec793c6.png)'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用引用数据类型](../Images/bc429022eaeee8d06e298c061ec793c6.png)'
- en: '*Declaring variables.* You declare variables of a reference type in precisely
    the same way that you declare variables of a primitive type. A declaration statement
    does not create anything; it just says that we will use the variable name `s`
    to refer to a `String` object.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明变量。* 您声明引用类型的变量的方式与声明原始类型的变量的方式完全相同。声明语句不会创建任何内容；它只是说我们将使用变量名`s`来引用一个`String`对象。'
- en: '*Creating objects.* Each data-type value is stored in an *object*. When a client
    invokes a constructor, the Java system creates (or *instantiates*) an individual
    object (or *instance*). To invoke a constructor, use the keyword `new`; followed
    by the class name; followed by the constructor’s arguments, enclosed in parentheses
    and separated by commas.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建对象。* 每个数据类型值都存储在一个*对象*中。当客户端调用构造函数时，Java系统会创建（或*实例化*）一个单独的对象（或*实例*）。要调用构造函数，请使用关键字`new`；后跟类名；后跟构造函数的参数，用括号括起来，用逗号分隔。'
- en: '*Invoking instance methods.* The most important difference between a variable
    of a reference type and a variable of a primitive type is that you can use reference-type
    variables to invoke the *instance methods* that implement data-type operations
    (in contrast to the built-in syntax involving operators such as `+`* that we used
    with primitive types).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用实例方法。* 引用类型变量和原始类型变量之间最重要的区别是，您可以使用引用类型变量来调用实现数据类型操作的*实例方法*（与我们在原始类型中使用的涉及运算符如`+`的内置语法相反）。'
- en: Now, we consider various string-processing examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们考虑各种字符串处理示例。
- en: '*Data-type operations.* The following examples illustrate various operations
    for the `String` data type.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据类型操作。* 以下示例说明了`String`数据类型的各种操作。'
- en: '![String operations](../Images/8f52a18880c32fe21d3553ecde86aeec.png)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![字符串操作](../Images/8f52a18880c32fe21d3553ecde86aeec.png)'
- en: '*Code fragments.* The following code fragments illustrate the use of various
    string-processing methods.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码片段。* 以下代码片段演示了各种字符串处理方法的使用。'
- en: '![String code fragments](../Images/d3ca62286f24d24eda553372739c3df0.png)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![字符串代码片段](../Images/d3ca62286f24d24eda553372739c3df0.png)'
- en: '*Genomics.* Biologists use a simple model to represent the building blocks
    of life, in which the letters A, C, G, and T represent the four bases in the DNA
    of living organisms. A *gene* is a substring that represents a functional unit
    of critical importance in understanding life processes. [PotentialGene.java](PotentialGene.java.html)
    takes a DNA string as an argument and determines whether it corresponds to a potential
    gene based on the following criteria:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基因组学。* 生物学家使用一个简单的模型来表示生命的基本组成部分，其中字母A、C、G和T代表生物体DNA中的四个碱基。*基因*是一个表示在理解生命过程中至关重要的功能单元的子字符串。[PotentialGene.java](PotentialGene.java.html)以DNA字符串作为参数，并根据以下标准确定它是否对应于潜在基因：'
- en: It begins with the *start codon* ATG.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以*起始密码子* ATG开头。
- en: Its length is a multiple of 3.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其长度是3的倍数。
- en: It ends with one of the *stop codons* TAG, TAA, or TGA.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以*终止密码子* TAG、TAA或TGA之一结束。
- en: It has no intervening stop codons.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有干扰的终止密码子。
- en: '## Color. ![Color values](../Images/3d5356fb426e14fd698262b8e4064c91.png) Java''s
    [Color](https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html) data type  represents
    color values using the [RGB color model](https://en.wikipedia.org/wiki/RGB_color_model)
    where a color is defined by three integers (each between 0 and 255) that represent
    the intensity of the red, green, and blue components of the color. Other color
    values are obtained by mixing the red, blue and green components.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '## 颜色。 ![颜色值](../Images/3d5356fb426e14fd698262b8e4064c91.png) Java的[Color](https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html)数据类型使用[RGB颜色模型](https://en.wikipedia.org/wiki/RGB_color_model)表示颜色值，其中颜色由三个整数（每个介于0和255之间）定义，表示颜色的红色、绿色和蓝色分量的强度。通过混合红色、蓝色和绿色分量获得其他颜色值。'
- en: The `Color` data type has a constructor that takes three integer arguments.
    For example, you can write
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`数据类型有一个接受三个整数参数的构造函数。例如，您可以编写'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'to create objects whose values represent pure red and the blue used to print
    this book. The following table summarizes the methods in the [Color](https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html)
    API that we use in this book:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建代表纯红色和用于打印本书的蓝色的对象。以下表总结了我们在本书中使用的[Color](https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html)
    API中的方法：
- en: '![Color API](../Images/129fd5fccf4dbda108d78d35d70f8ad9.png)'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![颜色 API](../Images/129fd5fccf4dbda108d78d35d70f8ad9.png)'
- en: Here are some example clients that use the `Color` data type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用 `Color` 数据类型的示例客户端。
- en: '*Albers squares.* [AlbersSquares.java](AlbersSquares.java.html) displays the
    two colors entered in RGB representation on the command line in the format developed
    in the 1960s by Josef Albers that revolutionized the way that people think about
    color.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Albers 方块.* [AlbersSquares.java](AlbersSquares.java.html) 在命令行上以 1960 年代约瑟夫·阿尔伯斯开发的格式显示以
    RGB 表示的两种颜色，这种格式彻底改变了人们对颜色的看法。'
- en: '![Albers squares](../Images/788fdd57a9242dbc96d9d88261e3c0f6.png)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Albers 方块](../Images/788fdd57a9242dbc96d9d88261e3c0f6.png)'
- en: '*Luminance.* The quality of the images on modern displays such as LCD monitors,
    plasma TVs, and cell-phone screens depends on an understanding of a color property
    known as *monochrome luminance*, or effective brightness. It is a linear combination
    of the three intensities: if a color''s red, green and blue values are *r*, *g*,
    and *b*, respectively then its luminance is defined by the equation'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*亮度.* 现代显示器（如液晶显示器、等离子电视和手机屏幕）上的图像质量取决于一种称为 *单色亮度* 或有效亮度的颜色属性的理解。 它是三种强度的线性组合：如果颜色的红色、绿色和蓝色值分别为
    *r*、*g* 和 *b*，则其亮度由以下方程定义'
- en: $$Y = 0.299r + 0.587g + 0.114b$$
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$Y = 0.299r + 0.587g + 0.114b$$
- en: '*Grayscale.* ![converting a color to grayscale](../Images/6d48c5de279e726e26c7962fc76ee185.png)
    The RGB color model has the property that when all three color intensities are
    the same, the resulting color is on a grayscale that ranges from black (all 0s)
    to white (all 255s).  A simple way to convert a color to grayscale is to replace
    the color with a new one whose red, green, and blue values equal its luminance.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灰度.* ![将颜色转换为灰度](../Images/6d48c5de279e726e26c7962fc76ee185.png) RGB颜色模型具有这样的特性，即当三种颜色强度相同时，结果颜色位于从黑色（全0）到白色（全255）的灰度范围内。
    将颜色转换为灰度的简单方法是用其亮度等于其红色、绿色和蓝色值的新颜色替换该颜色。'
- en: '*Color compatibility.* The luminance value is also crucial in determining whether
    two colors are compatible, in the sense that printing text in one of the colors
    on a background in the other color will be readable. A widely used rule of thumb
    is that the difference between the luminance of the foreground and background
    colors should be at least 128.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*颜色兼容性.* 亮度值在确定两种颜色是否兼容方面也至关重要，即在另一种颜色的背景上打印文本是否可读。 一个广泛使用的经验法则是前景色和背景色之间的亮度差应至少为
    128。'
- en: '![color compatibility](../Images/05d73c4b35e1f96b66018203cbeab030.png)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![颜色兼容性](../Images/05d73c4b35e1f96b66018203cbeab030.png)'
- en: '[Luminance.java](Luminance.java.html) is a static method library that we can
    use to convert to grayscale and test whether two colors are compatible. ## Image
    processing. ![anatomy of a digital image](../Images/8be79614dad0b3fdd34c5048cb4e2284.png)
    A *digital image* is a rectangular grid of *pixels* (picture elements), where
    the color of each pixel is individually defined. Digital images are sometimes
    referred to as *raster* or *bitmapped* images. In contrast, the types of images
    that we produce with `StdDraw` (which involved geometric objects) are referred
    to as *vector* images.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[Luminance.java](Luminance.java.html) 是一个静态方法库，我们可以用它来将颜色转换为灰度并测试两种颜色是否兼容。##
    图像处理。![数字图像的解剖](../Images/8be79614dad0b3fdd34c5048cb4e2284.png) *数字图像* 是一个由 *像素*（图像元素）组成的矩形网格，其中每个像素的颜色是单独定义的。
    数字图像有时被称为 *光栅* 或 *位图* 图像。 相比之下，我们使用 `StdDraw` 生成的图像（涉及几何对象）被称为 *矢量* 图像。'
- en: 'The [Picture](http://introcs.cs.princeton.edu/java/stdlib/javadoc/Picture.html)
    data type allows you to manipulate digital images. The set of values is a two-dimensional
    matrix of `Color` values, and the operations are what you might expect: create
    an image (either blank or from a file), set the value of a pixel to a given color,
    and extract the color of a given pixel. The following API summarizes the available
    operations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[Picture](http://introcs.cs.princeton.edu/java/stdlib/javadoc/Picture.html)
    数据类型允许您操作数字图像。 值集是一个二维矩阵，其中包含 `Color` 值，并且操作是您可能期望的：创建图像（空白或从文件），将像素的值设置为给定颜色，并提取给定像素的颜色。
    以下 API 总结了可用的操作：'
- en: '![Picture API](../Images/9afc4d0e8ecc80dece20adad0ef7cba8.png)'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片 API](../Images/9afc4d0e8ecc80dece20adad0ef7cba8.png)'
- en: Most image-processing programs are filters that scan through all of the pixels
    in a source image and then perform some computation to determine the color of
    each pixel in a target image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图像处理程序都是过滤器，通过扫描源图像中的所有像素，然后执行一些计算来确定目标图像中每个像素的颜色。
- en: '*Grayscale.* [Grayscale.java](Grayscale.java.html) converts an image from color
    to grayscale.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灰度.* [Grayscale.java](Grayscale.java.html) 将图像从彩色转换为灰度。'
- en: '| ![baboon](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![grayscale
    baboon](../Images/d929bca627edbc9b4dd973a2f779a942.png) |'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![狒狒](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![灰度狒狒](../Images/d929bca627edbc9b4dd973a2f779a942.png)
    |'
- en: '*Scale.* [Scale.java](Scale.java.html) takes the name of an image file and
    two integers (width *w* and height *h*) as command-line arguments, scales the
    picture to *w*-by-*h*, and displays both images.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缩放.* [Scale.java](Scale.java.html) 接受一个图像文件的名称和两个整数（宽度 *w* 和高度 *h*）作为命令行参数，将图片缩放到
    *w*-by-*h*，并显示两个图像。'
- en: '| ![grayscale baboon](../Images/f32d9f3edfbec865ea5ce64bd48a3fd7.png) *600-by-300*
    |      | ![200-by-400](../Images/db971affee53184e3223577e7c2bb36c.png) *200-by-400*
    |'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![灰度狒狒](../Images/f32d9f3edfbec865ea5ce64bd48a3fd7.png) *600-by-300* |     
    | ![200-by-400](../Images/db971affee53184e3223577e7c2bb36c.png) *200-by-400* |'
- en: '*Fade effect.* [Fade.java](Fade.java.html) takes an integer *n* and the names
    of the source and target images as command-line arguments and fades from the source
    image to the target image in *n* steps. It uses a *linear interpolation* strategy,
    where each pixel in image *i* is a weighted average of the corresponding pixels
    in the source and target images.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*淡入效果.* [Fade.java](Fade.java.html) 接受一个整数 *n* 和源图像和目标图像的名称作为命令行参数，并在 *n* 步内从源图像淡入到目标图像。
    它使用线性插值策略，其中图像 *i* 中的每个像素是源图像和目标图像中相应像素的加权平均值。'
- en: Input and output revisited.
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和输出重访。
- en: In [Section 1.5](../15inout) you learned how to read and write numbers and text
    using standard input, output, and drawing. These restrict us to working with just
    one input file, one output file, and one drawing for any given program. With object-oriented
    programming, we consider data types that allow us to work with multiple input
    streams, output streams, and drawings within one program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1.5节](../15inout)中，您学习了如何使用标准输入、输出和绘图读取和写入数字和文本。这些限制我们只能处理一个输入文件、一个输出文件和一个绘图文件。通过面向对象编程，我们考虑允许我们在一个程序中处理多个输入流、输出流和绘图的数据类型。
- en: '*Input stream data type.* [In](http://introcs.cs.princeton.edu/java/stdlib/javadoc/In.html)
    is an object-oriented version of [StdIn](http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdIn.html)
    that supports reading numbers and text from data from files and websites as well
    as the standard input stream.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入流数据类型。*[In](http://introcs.cs.princeton.edu/java/stdlib/javadoc/In.html)是支持从文件和网站以及标准输入流中读取数字和文本数据的[StdIn](http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdIn.html)的面向对象版本。'
- en: '![In API](../Images/596f8eb243ceb57c97fd392c85d04ebb.png)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![In API](../Images/596f8eb243ceb57c97fd392c85d04ebb.png)'
- en: '*Output stream data type.* [Out](http://introcs.cs.princeton.edu/java/stdlib/javadoc/Out.html)
    is an object-oriented version of [StdOut](http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdOut.html)
    that supports printing text to a variety of output streams, including files and
    standard output.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输出流数据类型。*[Out](http://introcs.cs.princeton.edu/java/stdlib/javadoc/Out.html)是支持将文本打印到各种输出流的[StdOut](http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdOut.html)的面向对象版本。'
- en: '![Out API](../Images/0610b815cb531c4a511258403147bd02.png)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Out API](../Images/0610b815cb531c4a511258403147bd02.png)'
- en: '*File concatenation.* [Cat.java](Cat.java.html) reads several files specified
    as command-line arguments, concatenates them, and prints the result to a file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件连接。*[Cat.java](Cat.java.html)读取指定为命令行参数的多个文件，将它们连接起来，并将结果打印到一个文件中。'
- en: '*Screen scraping.* [StockQuote.java](StockQuote.java.html) takes the the symbol
    of New York Stock Exchange stock as a command-line argument and prints its current
    trading price. It uses a technique known as *screen scraping*, in which the goal
    is to extract some information from a web page with a program. To report the current
    stock price of Google (NYSE symbol = GOOG), it reads the Web page `http://finance.yahoo.com/quote/GOOG`.
    Then, it identifies the relevant information using `indexOf()` and `substring()`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*屏幕抓取。*[StockQuote.java](StockQuote.java.html)以纽约证券交易所股票符号作为命令行参数，并打印其当前交易价格。它使用一种称为*屏幕抓取*的技术，其目标是使用程序从网页中提取一些信息。为了报告谷歌的当前股价（纽约证券交易所符号=GOOG），它读取Web页面`http://finance.yahoo.com/quote/GOOG`。然后，它使用`indexOf()`和`substring()`来识别相关信息。'
- en: '*Extracting data.* [Split.java](Split.java.html) uses multiple output streams
    to split a CSV file into separate files, one for each comma-delimited field.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提取数据。*[Split.java](Split.java.html)使用多个输出流将CSV文件拆分为单独的文件，每个文件包含一个逗号分隔的字段。'
- en: '*Drawing data type.* [Draw](http://introcs.cs.princeton.edu/java/stdlib/javadoc/Draw.html)
    is an object-oriented version of [StdDraw](http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdDraw.html)
    that supporting drawing to more than one canvas in the same program.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘图数据类型。*[Draw](http://introcs.cs.princeton.edu/java/stdlib/javadoc/Draw.html)是支持在同一个程序中绘制多个画布的[StdDraw](http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdDraw.html)的面向对象版本。'
- en: Properties of reference types.
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型的属性。
- en: We summarize some of the essential properties of reference types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结了一些引用类型的基本属性。
- en: '*Aliasing.* An assignment statement with a reference type creates a second
    copy of the reference. The assignment statement does not create a new object,
    just another reference to an existing object. This situation is known as *aliasing*:
    both variables refer to the same object. As an example, consider the following
    code fragment:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*别名。*具有引用类型的赋值语句会创建引用的第二个副本。赋值语句不会创建新对象，只是对现有对象的另一个引用。这种情况被称为*别名*：两个变量引用同一个对象。例如，考虑以下代码片段：'
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After the second assignment statement, variables `a` and `b` refer to the same
    `Picture` object.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二个赋值语句之后，变量`a`和`b`引用同一个`Picture`对象。
- en: '*Pass by value.* When you call a method with arguments, the effect in Java
    is as if each argument were to appear on the right-hand side of an assignment
    statement with the corresponding argument name on the left-hand side. That is,
    Java passes a *copy* of the argument value from the caller to the method. If the
    argument value is a primitive type, Java passes a copy of that value; if the argument
    value is an object reference, Java passes a copy of the object reference. This
    arrangement is known as *pass by value*.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按值传递。*当你调用一个带有参数的方法时，在Java中的效果就好像每个参数都出现在赋值语句的右侧，相应的参数名出现在左侧一样。也就是说，Java将调用者的参数值的*副本*传递给方法。如果参数值是原始类型，Java将传递该值的副本；如果参数值是对象引用，Java将传递对象引用的副本。这种安排被称为*按值传递*。'
- en: '*Arrays are objects.* In Java, arrays are objects. As with strings, special
    language support is provided for certain operations on arrays: declarations, initialization,
    and indexing. As with any other object, when we pass an array to a method or use
    an array variable on the right-hand side of an assignment statement, we are making
    a copy of the array reference, not a copy of the array.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组是对象。*在Java中，数组是对象。与字符串一样，对数组的某些操作提供了特殊的语言支持：声明、初始化和索引。与任何其他对象一样，当我们将一个数组传递给一个方法或在赋值语句的右侧使用一个数组变量时，我们实际上是在传递数组引用的副本，而不是数组的副本。'
- en: '*Arrays of objects.* When we create an array of objects, we do so in two steps:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象数组。*当我们创建一个对象数组时，我们需要分两步进行：'
- en: Create the array by using `new` and the square bracket syntax for array creation.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`和方括号语法创建数组。
- en: Create each object in the array, by using `new` to call a constructor.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`new`调用构造函数为数组中的每个对象创建对象。
- en: 'For example, the following code creates an array of two `Color` objects:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下代码创建了一个包含两个`Color`对象的数组：
- en: '[PRE2]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Safe pointers.* In Java, there is only one way to create a reference (with
    `new`) and only one way to manipulate that reference (with an assignment statement).
    Java references are known as *safe pointers*, because Java can guarantee that
    each reference points to an object of the specified type (and not to an arbitrary
    memory address).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全指针。* 在Java中，只有一种方式可以创建引用（使用`new`），也只有一种方式可以操作该引用（使用赋值语句）。Java引用被称为*安全指针*，因为Java可以保证每个引用指向指定类型的对象（而不是任意内存地址）。'
- en: '*Orphaned objects.* The ability to assign different objects to a reference
    variable creates the possibility that a program may have created an object that
    it can no longer reference. Such an object is said to be *orphaned*. As an example,
    consider the following code fragment:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*孤立对象。* 将不同对象分配给引用变量的能力会导致程序可能创建了一个无法再引用的对象。这样的对象被称为*孤立对象*。例如，考虑以下代码片段：'
- en: '[PRE3]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the final assignment statement, not only do `a` and `b` refer to the same
    `Color` object (sienna), but also there is no longer a reference to the `Color`
    object that was created and usedto initialize `b` (yellow).
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一个赋值语句之后，不仅`a`和`b`引用相同的`Color`对象（sienna），而且不再有引用指向用于初始化`b`的`Color`对象（yellow）。
- en: '*Garbage collection.* One of Java’s most significant features is its ability
    to automatically manage memory. The idea is to free the programmer from the responsibility
    of managing memory by keeping track of orphaned objects and returning the memory
    they use to a pool of free memory. Reclaiming memory in this way is known as *garbage
    collection*, and Java’s safe pointer policy enables it to do this efficiently.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*垃圾收集。* Java最重要的特性之一是其自动管理内存的能力。这个想法是通过跟踪孤立对象并将它们使��的内存返回到空闲内存池中，使程序员摆脱管理内存的责任。以这种方式回收内存被称为*垃圾收集*，而Java的安全指针策略使其能够高效地执行此操作。'
- en: Exercises
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Write a function `reverse()` that takes a string as an argument and returns
    a string that contains the same sequence of characters as the argument string
    but in reverse order.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`reverse()`，它接受一个字符串作为参数，并返回一个包含与参数字符串相同字符序列但顺序相反的字符串。
- en: '*Solution*: [ReverseString.java](ReverseString.java.html).'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[ReverseString.java](ReverseString.java.html)。'
- en: Write a program [FlipX.java](FlipX.java.html) that takes the name of an image
    file as a command-line argument and flips the image horizontally.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[FlipX.java](FlipX.java.html)，它接受图像文件的名称作为命令行参数，并水平翻转图像。
- en: '| ![peppers](../Images/424362da382564bd6db4dc56e6318268.png) |      | ![flip
    peppers](../Images/b7f3822bba203135088b95cf602d1d9f.png) |'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![peppers](../Images/424362da382564bd6db4dc56e6318268.png) |      | ![flip
    peppers](../Images/b7f3822bba203135088b95cf602d1d9f.png) |'
- en: Write a program [ColorSeparation.java](ColorSeparation.java.html) that takes
    the name of an image file as a command-line argument, and creates and shows three
    `Picture` objects, one that contains only the red components, one for green, and
    one for blue.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[ColorSeparation.java](ColorSeparation.java.html)，它接受图像文件的名称作为命令行参数，并创建并显示三个`Picture`对象，一个包含红色分量，一个包含绿色分量，一个包含蓝色分量。
- en: '| ![baboon red](../Images/7a1fb72b0feac7b53c3178cc2d99a52e.png) |      | ![baboon
    green](../Images/3b80f0af885b3df0c133aa7c2ce1d38b.png) |      | ![baboon blue](../Images/c8a3bf6d99a3f8b6af6288bdaf29baaa.png)
    |'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![baboon red](../Images/7a1fb72b0feac7b53c3178cc2d99a52e.png) |      | ![baboon
    green](../Images/3b80f0af885b3df0c133aa7c2ce1d38b.png) |      | ![baboon blue](../Images/c8a3bf6d99a3f8b6af6288bdaf29baaa.png)
    |'
- en: Write a static method `isValidDNA()` that takes a string as its argument and
    returns `true` if and only if it is composed entirely of the characters `A`, `T`,
    `C`, and `G`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`isValidDNA()`，它接受一个字符串作为参数，并仅在其完全由字符`A`、`T`、`C`和`G`组成时返回`true`。
- en: '*Solution*:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Write a function `complementWatsonCrick()` that takes a DNA string as its arguments
    and returns its *Watson–Crick complement*: replace `A` with `T`, `C` with `G`,
    and vice versa.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`complementWatsonCrick()`，它接受一个DNA字符串作为参数，并返回其*Watson-Crick互补*：用`T`替换`A`，用`G`替换`C`，反之亦然。
- en: '*Solution*:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What does the following code fragment print?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Solution*: `hello`.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：`hello`。'
- en: What does the following code fragment print?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Solution*: `Hello, World`. String objects are immutable.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：`Hello, World`。字符串对象是不可变的。'
- en: A string `s` is a *circular shift* of a string `t` if it matches when the characters
    of one string are circularly shifted by some number of positions. For example,
    `ACTGACG` is a circular shift of `TGACGAC`, and vice versa. Detecting this condition
    is important in the study of genomic sequences. Write a function `isCircularShift()`
    that checks whether two given strings `s` and `t` are circular shifts of one another.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个字符串`s`是字符串`t`的*循环移位*，则当一个字符串的字符被某个位置的循环移动时，它们匹配。例如，`ACTGACG`是`TGACGAC`的循环移位，反之亦然。检测这种条件在基因组序列研究中很重要。编写一个函数`isCircularShift()`，检查给定的两个字符串`s`和`t`是否彼此的循环移位。
- en: '*Solution*:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：'
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What does the following recursive function return?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下递归函数返回什么？
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Solution*: the reverse of its argument string.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：其参数字符串的反转。'
- en: Suppose that `a[]` and `b[]` are both integer arrays consisting of millions
    of integers. What does the follow code do, and how long does it take?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`a[]`和`b[]`都是由数百万个整数组成的整数数组。以下代码做了什么，需要多长时间？
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Solution*: It swaps the arrays, but it does so by copying object references,
    so that it is not necessary to copy millions of values.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：它交换了数组，但是通过复制对象引用来实现，因此不需要复制数百万个值。'
- en: Describe the effect of the following function.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述以下函数的效果。
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Solution*: It has no effect because Java passes object references by value.'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：它没有效果，因为Java通过值传递对象引用。'
- en: Creative Exercises
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Kamasutra cipher.** Write a filter [KamasutraCipher.java](KamasutraCipher.java.html)
    that takes two strings as command-line argument (the *key* strings), then reads
    strings (separated by whitespace) from standard input, substitutes for each letter
    as specified by the key strings, and prints the result to standard output. This
    operation is the basis for one of the earliest known cryptographic systems. The
    condition on the key strings is that they must be of equal length and that any
    letter in standard input must appear in exactly one of them. For example, if the
    two keys are `THEQUICKBROWN` and `FXJMPSVLAZYDG`, then we make the table'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**印度密宗密码.** 编写一个过滤器[KamasutraCipher.java](KamasutraCipher.java.html)，它将两个字符串作为命令行参数（*密钥*字符串），然后从标准输入读取字符串（以空格分隔），按照密钥字符串指定的方式替换每个字母，并将结果打印到标准输出。这个操作是已知的最早的密码系统之一的基础。密钥字符串的条件是��们必须具有相同的长度，并且标准输入中的任何字母必须只出现在其中一个中。例如，如果两个密钥是`THEQUICKBROWN`和`FXJMPSVLAZYDG`，那么我们制作表格'
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which tells us that we should substitute F for T, T for F, H for X, X for H,
    and so forth when filtering standard input to standard output. The message is
    encoded by replacing each letter with its pair. For example, the message `MEET
    AT ELEVEN` is encoded as `QJJF BF JKJCJG`. The person receiving the message can
    use the same keys to get the message back.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉我们，在将标准输入过滤到标准输出时，应该将F替换为T，T替换为F，H替换为X，X替换为H，依此类推。消息通过用其对应的字母替换每个字母来进行编码。例如，消息`MEET
    AT ELEVEN`被编码为`QJJF BF JKJCJG`。接收消息的人可以使用相同的密钥将消息还原。
- en: '**Color study.** Write a program [ColorStudy.java](ColorStudy.java.html) that
    displays the color study shown at right, which gives Albers squares corresponding
    to each of the 256 levels of blue (blue-to-white in row-major order) and gray
    (black-to-white in column-major order) that were used to print this book.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**色彩研究.** 编写一个程序[ColorStudy.java](ColorStudy.java.html)，显示右侧显示的色彩研究，其中给出了对应于本书中使用的256个蓝色级别（按行主序的蓝色到白色）和灰色级别（按列主序的黑色到白色）的Albers方块。'
- en: '![color study](../Images/db237fae8d0f0003d09e993f8e041b17.png)'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![色彩研究](../Images/db237fae8d0f0003d09e993f8e041b17.png)'
- en: '**Tile.** Write a program [Tile.java](Tile.java.html) that takes the name of
    an image file and two integers *m* and *n* as command-line arguments and creates
    an *m*-by-*n* tiling of the image.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标题.** 编写一个程序[Tile.java](Tile.java.html)，该程序接受一个图像文件的名称和两个整数*m*和*n*作为命令行参数，并创建一个*m*乘以*n*的图像平铺。'
- en: '| ![2-by-3 baboon](../Images/320c62720d82e790f962e422ad71ffbc.png) |'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![2乘3的狒狒](../Images/320c62720d82e790f962e422ad71ffbc.png) |'
- en: '**Rotation filter.** Write a program [Rotation.java](Rotation.java.html) that
    takes two command-line arguments (the name of an image file and a real number
    \(\theta\)) and rotates the image \(\theta\)) degrees counterclockwise. To rotate,
    copy the color of each pixel \((s_i, s_j)\) in the source image to a target pixel
    \((t_i, t_j)\) whose coordinates are given by the following formulas:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**旋转滤镜.** 编写一个程序[Rotation.java](Rotation.java.html)，该程序接受两个命令行参数（图像文件的名称和一个实数\(\theta\)），并将图像逆时针旋转\(\theta\)度。要进行旋转，将源图像中每个像素\((s_i,
    s_j)\)的颜色复制到由以下公式给出的目标像素\((t_i, t_j)\)中：'
- en: $$ \begin{align} t_i \;&=\; (s_i - c_j) \cos \theta - (s_j - c_j) \sin \theta
    + c_j \\[1ex] t_j \;&=\; (s_i - c_j) \sin \theta + (s_j - c_j) \cos \theta + c_j
    \end{align} $$
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \begin{align} t_i \;&=\; (s_i - c_j) \cos \theta - (s_j - c_j) \sin \theta
    + c_j \\[1ex] t_j \;&=\; (s_i - c_j) \sin \theta + (s_j - c_j) \cos \theta + c_j
    \end{align} $$
- en: where \((c_i, c_j)\) is the center of the image.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中\((c_i, c_j)\)是图像的中心。
- en: '| ![baboon](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![rotated
    baboon](../Images/e72ff459f8ff0fee17b525bf6dc2e3b0.png) |'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![狒狒](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![旋转狒狒](../Images/e72ff459f8ff0fee17b525bf6dc2e3b0.png)
    |'
- en: '**Swirl filter.** Creating a swirl effect is similar to rotation, except that
    the angle changes as a function of distance to the center of the image. Use the
    same formulas as in the previous exercise, but compute \(\theta\) as a function
    of \((s_i, s_j)\), specifically \(\pi/256\) times the distance to the center.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**涡旋滤镜.** 创建涡旋效果类似于旋转，只是角度随着到图像中心的距离的变化而变化。使用与前一个练习中相同的公式，但将\(\theta\)计算为\((s_i,
    s_j)\)的函数，具体来说是\(\pi/256\)乘以到中心的距离。'
- en: '| ![baboon](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![baboon
    swirl](../Images/f0561ded245230dfbe7bb16f080610cb.png) |'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![狒狒](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![涡旋狒狒](../Images/f0561ded245230dfbe7bb16f080610cb.png)
    |'
- en: '**Wave filter.** Write a filter [Wave.java](Wave.java.html) like those in the
    previous two exercises that creates a wave effect, by copying the color of each
    pixel \((s_i, s_j)\) in the source image to a target pixel \((t_i, t_j)\), where'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波浪滤镜.** 编写一个过滤器[Wave.java](Wave.java.html)，类似于前两个练习中的过滤器，创建波浪效果，通过将源图像中每个像素\((s_i,
    s_j)\)的颜色复制到目标像素\((t_i, t_j)\)中，其中'
- en: $$ \begin{align} t_i \;&=\; s_i \\[1ex] t_j \;&=\; s_j + 20 \sin(2 \pi s_j /
    64) \end{align} $$
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$ \begin{align} t_i \;&=\; s_i \\[1ex] t_j \;&=\; s_j + 20 \sin(2 \pi s_j /
    64) \end{align} $$
- en: Add code to take the amplitude (20 in the accompanying figure) and the frequency
    (64 in the accompanying figure) as command-line arguments.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加代码以将振幅（附图中的20）和频率（附图中的64）作为命令行参数。
- en: '| ![wavy baboon](../Images/1041215f25967cf479478fa52abffa6e.png) |      | ![wavy
    baboon](../Images/4504b12ddd232cd648b276711014dcd8.png) |'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![波浪狒狒](../Images/1041215f25967cf479478fa52abffa6e.png) |      | ![波浪狒狒](../Images/4504b12ddd232cd648b276711014dcd8.png)
    |'
- en: '**Glass filter.** Write a program [Glass.java](Glass.java.html) that takes
    the name of an image file as a command-line argument and applies a *glass filter*:
    set each pixel *p* to the color of a random neighboring pixel (whose pixel coordinates
    both differ from *p*’s coordinates by at most 5).'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**玻璃滤镜.** 编写一个程序[Glass.java](Glass.java.html)，该程序将图像文件的名称作为命令行参数，并应用*玻璃滤镜*：将每个像素*p*设置为随机相邻像素的颜色（其像素坐标与*p*的坐标最多相差5）。'
- en: '| ![baboon](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![baboon
    through glass](../Images/af4db0bf2e50e622a2265bc885125069.png) |'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![狒狒](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![透过玻璃的狒狒](../Images/af4db0bf2e50e622a2265bc885125069.png)
    |'
- en: '![digital zoom](../Images/ef00393817699bafdeef039168db920b.png)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![数字缩放](../Images/ef00393817699bafdeef039168db920b.png)'
- en: '**Digital zoom.** Write a program [Zoom.java](Zoom.java.html) that takes the
    name of an image file and three numbers *s*, *x*, and *y* as command-line arguments,
    and shows an output image that zooms in on a portion of the input image. The numbers
    are all between 0 and 1, with *s* to be interpreted as a scale factor and (*x*,
    *y*) as the relative coordinates of the point that is to be at the center of the
    output image. Use this program to zoom in on a relative or pet in some digital
    photo on your computer.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数字缩放。**编写一个程序[Zoom.java](Zoom.java.html)，接受图像文件的名称和三个数字*s*、*x*和*y*作为命令行参数，并显示一个放大输入图像部分的输出图像。这些数字都在0和1之间，*s*被解释为比例因子，(*x*,
    *y*)为输出图像中心点的相对坐标。使用此程序在计算机上的某个数字照片上放大一个相对或宠物。'
- en: Web Exercises (String Processing)
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习（字符串处理）
- en: Write a function that takes as input a string and returns the number of occurrences
    of the letter `e`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受一个字符串作为输入，并返回字母`e`出现的次数。
- en: 'Give a one line Java code fragment to replace all periods in a string with
    commas. *Answer*: `s = s.replace(''.'', '','')`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个一行Java代码片段，将字符串中所有句号替换为逗号。*答案*：`s = s.replace('.', ',')`。
- en: Don't use `s = s.replaceAll(".", ",")`. The `replaceAll()` method uses *regular
    expressions* where `"."`has a special meaning.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要使用`s = s.replaceAll(".", ",")`。`replaceAll()`方法使用*正则表达式*，其中`"."`具有特殊含义。
- en: 'Replace all tabs with four spaces. *Answer*: `s = s.replace("\t", "    ")`.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有制表符替换为四个空格。*答案*：`s = s.replace("\t", "    ")`。
- en: 'Write a program that takes a command line input string s, reads strings from
    standard input, and prints the number of times s appears. *Hint*: use don''t forget
    to use `equals` instead of `==` with references.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个命令行输入字符串s，从标准输入读取字符串，并打印出s出现的次数。*提示*：使用`equals`而不是`==`来比较引用。
- en: Write a program that reads in the name of a month (3 letter abbreviation) as
    a command-line argument and prints the number of days in that month in a non leap
    year.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，将一个月份的名称（3个字母缩写）作为命令行参数读入，并打印出非闰年中该月份的天数。
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Write a program [Squeeze.java](Squeeze.java.html) that takes as input a string
    and removes adjacent spaces, leaving at most one space in-a-row.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Squeeze.java](Squeeze.java.html)，接受一个字符串作为输入，并移除相邻的空格，最多保留一个空格。
- en: Which one or more of the following converts all of the strings in the array
    `a` to upper case?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个或哪些方法将数组`a`中的所有字符串转换为大写？
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Answer*: only the last one.'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：只有最后一个。'
- en: Describe the string that the following function returns, given a positive integer
    `n`?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述以下函数返回的字符串，给定一个正整数`n`？
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Solution* The string of length `n` consisting only of the character `x`.'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：长度为`n`且只包含字符`x`的字符串。'
- en: Write a function that takes a string `s` and an integer `n` and returns a new
    string `t` of length exactly `n` that consists of `s` (truncated if its length
    is greater than `n`) followed by a sequence of `'-'` characters (if the length
    of `s` is less than `n`).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受一个字符串`s`和一个整数`n`，并返回一个长度恰好为`n`的新字符串`t`，其中包含`s`（如果其长度大于`n`则截断）后跟一个序列的`'-'`字符（如果`s`的长度小于`n`）。
- en: What does the following recursive function return, given two strings `s` and
    `t` of the same length?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定两个长度相同的字符串`s`和`t`，以下递归函数返回什么？
- en: '[PRE16]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Solution*: Perfect shuffle of the characters of s and t.'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：s和t字符的完美洗牌。'
- en: 'Write a program that reads in a string and prints the first character that
    appears exactly once in the string. Ex: ABCDBADDAB -> C.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，读取一个字符串，并打印出字符串中第��次出现的仅出现一次的字符。例如：ABCDBADDAB -> C。
- en: 'Given a string, create a new string with all the consecutive duplicates removed.
    Ex: ABBCCCCCBBAB -> ABCBAB.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个字符串，创建一个新的字符串，其中移除所有连续重复的字符。例如：ABBCCCCCBBAB -> ABCBAB。
- en: Write a function that takes two string arguments s and t, and returns the index
    of the first character in s that appears in ts (or -1 if no character in s appears
    in t).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受两个字符串参数`s`和`t`，并返回`s`中第一个出现在`t`中的字符的索引（如果s中没有字符出现在t中，则返回-1）。
- en: Given a string `s`, determine whether it represents the name of a web page.
    Assume that any string starting with `http://` is a web page.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个字符串`s`，确定它是否表示一个网页的名称。假设任何以`http://`开头的字符串都是网页。
- en: '*Solution*: `if (s.startsWith("http://"))`.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：`if (s.startsWith("http://"))`。'
- en: Given a string `s` that represents the name of a web page, break it up into
    pieces, where each piece is separated by a period, e.g., `http://www.cs.princeton.edu`
    should be broken up into `www`, `cs`, `princeton`, and `edu`, with the `http://`
    part removed. Use either the `split()` or `indexOf()` methods.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个表示网页名称的字符串`s`，将其分割成多个部分，每个部分由句点分隔，例如，`http://www.cs.princeton.edu`应该分割为`www`、`cs`、`princeton`和`edu`，并移除`http://`部分。使用`split()`或`indexOf()`方法。
- en: Given a string `s` that represents the name of a file, write a code fragment
    to determine its file extension. The *file extension* is the substring following
    the last period. For example, the file type of `monalisa.jpg` is `jpg`, and the
    file type of `mona.lisa.png` is `png`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个表示文件名的字符串`s`，编写一个代码片段来确定其文件扩展名。*文件扩展名*是最后一个句点之后的子字符串。例如，`monalisa.jpg`的文件类型是`jpg`，`mona.lisa.png`的文件类型是`png`。
- en: '*Library solution*: this solution is used in `Picture.java` to save an image
    to the file of the appropriate type.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*库解决方案*：此解决方案用于在`Picture.java`中将图像保存到适当类型的文件中。'
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Given a string `s` that represents the name of a file, write a code fragment
    to determine its directory portion. This is the prefix that ends with the last
    `/` character (the directory delimiter); if there is no such `/`, then it is the
    empty string. For example, the directory portion of `/Users/wayne/monalisa.jpg`
    is `/Users/wayne/`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个表示文件名的字符串`s`，编写一个代码片段来确定其目录部分。这是以最后一个`/`字符（目录分隔符）结尾的前缀；如果没有这样的`/`，则为空字符串。例如，`/Users/wayne/monalisa.jpg`的目录部分是`/Users/wayne/`。
- en: Given a string `s` that represents the name of a file, write a code fragment
    to determine its base name (filename minus any directories). For `/Users/wayne/monalisa.jpg`,
    it is `monalisa.jpg`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个表示文件名的字符串`s`，编写一个代码片段来确定其基本名称（文件名减去任何目录）。对于`/Users/wayne/monalisa.jpg`，基本名称是`monalisa.jpg`。
- en: Write a program that reads in text from standard input and prints it back out,
    replacing all single quotation marks with double quotation marks.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取文本并将其打印回去，将所有单引号替换为双引号。
- en: Write a program `Paste.java` that takes an arbitrary number of command line
    inputs and concatenates the corresponding lines of each file, and writes the results
    to standard output. (Typically each line in given file has the same length.) Counterpart
    of the program `Cat.java`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序`Paste.java`，接受任意数量的命令行输入，并连接每个文件的相应行，并将结果写入标准输出。（通常给定文件中的每行长度相同。）`Cat.java`程序的对应程序。
- en: What does the program [LatinSquare.java](LatinSquare.java.html) print when N
    = 5?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当N = 5时，程序[LatinSquare.java](LatinSquare.java.html)会打印什么？
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A Latin square of order N is an N-by-N array consisting of N different symbols,
    such that each symbol appears exactly once in each row and column. Latin squares
    are useful in statistical design and cryptography.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阶数为N的拉丁方是一个由N个不同符号组成的N×N数组，使得每个符号在每行和每���中恰好出现一次。拉丁方在统计设计和密码学中很有用。
- en: What does the following code fragment print?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段会打印什么？
- en: '[PRE19]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Answer*: `Hello World`. The methods `toUpperCase` and `substring` return the
    resulting strings, but the program ignores these so `s` is never changed. To get
    it to print `WORLD`, use `s = s.toUpperCase()` and `s = s.substring(6, 11)`.'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*: `Hello World`。`toUpperCase`和`substring`方法返回结果字符串，但程序忽略了这些，所以`s`从未被改变。要打印出`WORLD`，使用`s
    = s.toUpperCase()`和`s = s.substring(6, 11)`。'
- en: What happens when you execute the following code fragment?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行以下代码片段时会发生什么？
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Answer*: you get a `NullPointerException` since `s` is `null` and you are
    attempting to dereference it.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：由于`s`为`null`且您试图对其进行解引用，因此会得到`NullPointerException`。'
- en: What are the values of x and y after the two assignment statements below?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的两个赋值语句之后，x和y的值是多少？
- en: '[PRE21]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What does the following statement do where `c` if of type `char`?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`c`是`char`类型时，以下语句会做什么？
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Answer: prints `true` if `c` is an uppercase or lowercase letter, and `false`
    otherwise.'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：如果`c`是大写或小写字母，则打印`true`，否则打印`false`。
- en: Write an expression that tests whether or not a character represents one of
    the digits `'0'` through `'9'` without using any library functions.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个表达式，测试一个字符是否代表数字`'0'`到`'9'`之间的数字，而不使用任何库函数。
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Write a program [WidthChecker.java](WidthChecker.java.html) that takes a command
    line parameter N, reads text from standard input, and prints to standard output
    all lines that are longer than N characters (including spaces).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，[WidthChecker.java](WidthChecker.java.html)，接受一个命令行参数N，从标准输入读取文本，并将长度超过N个字符（包括空格）的所有行打印到标准输出。
- en: Write a program [Hex2Decimal.java](Hex2Decimal.java.html) that converts from
    a hexadecimal string (using A-F for the digits 11-15) to decimal.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，[Hex2Decimal.java](Hex2Decimal.java.html)，将十六进制字符串（使用A-F表示数字11-15）转换为十进制。
- en: '**wget.** Write a program [Wget.java](Wget.java.html) that takes the name of
    a URL as a command-line argument and saves the referenced file using the same
    filename.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**wget**。编写一个程序[Get.java](Get.java.html)，将URL的名称作为命令行参数，并使用相同的文件名保存引用的文件。'
- en: '**Capitalize.** Write a program [Capitalize.java](Capitalize.java.html) that
    reads in text from standard input and capitalizes each word (make first letter
    uppercase and make the remaining letters lowercase).'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大写首字母**。编写一个程序，[Capitalize.java](Capitalize.java.html)，从标准输入读取文本，并将每个单词大写（首字母大写，其余字母小写）。'
- en: '**Shannon''s entropy experiment.** Recreate Shannon''s experiment on the entropy
    of the English language by listing a number of letters in a sentence and prompting
    the user for the next symbol. Shannon concluded that there is approximately 1.1
    bits of info per letter in the alphabet.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**香农的熵实验**。通过列出句子中的一些字母并提示用户输入下一个符号，重新创建香农对英语语言熵的实验。香农得出结论，字母表中每个字母大约有1.1位信息。'
- en: '**Scrambled text.** Some cognitive psychologists believe that people recognize
    words based on their shape.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**混淆的文本**。一些认知心理学家认为人们根据单词的形状来识别单词。'
- en: to a rscheearch at an Elingsh uinervtisy, it deosn't mttaer in waht oredr the
    ltteers in a wrod are, the olny iprmoetnt tihng is taht frist and lsat ltteer
    is at the rghit pclae. The rset can be a toatl mses and you can sitll raed it
    wouthit porbelm. Tihs is bcuseae we do not raed ervey lteter by itslef but the
    wrod as a wlohe.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据一项在英语大学进行的研究，一个单词中字母的顺序并不重要，重要的是第一个和最后一个字母在正确的位置。其余字母可以是一个混乱，但你仍然可以无障碍地阅读。这是因为我们不是逐个字母阅读，而是整个单词。
- en: Write a program that reads in text from standard input and prints the text back
    out, but shuffles the internal letters in each word. Write and use a function
    `scramble()` that takes as input a string and returns another string with the
    internal letters in random order. Use the shuffling algorithm in [Shuffle.java](../21function/Shuffle.java.html)
    for the shuffling part.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入读取文本并将文本打印回去，但是对每个单词中的内部字母进行混淆。编写并使用一个名为`scramble()`的函数，该函数接受一个字符串作为输入，并返回另一个内部字母顺序随机排列的字符串。使用[Shuffle.java](../21function/Shuffle.java.html)中的洗牌算法进行混洗部分。
- en: '**Date format conversion.** Write a program to read in a data of the form 2003-05-25
    and convert it to 5/25/03.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日期格式转换**。编写一个程序，读取形式为2003-05-25的日期，并将其转换为5/25/03。'
- en: '**Frequency analysis of English text.** Write a program `LetterFrequency.java`
    that reads in text from standard input (e.g., [Moby Dick](../data/mobydick.txt))
    and calculate the fraction of times each of the 26 lowercase letters appears.
    Ignore uppercase letters, punctuation, whitespace, etc. in your analysis. Use
    `CharStdIn.java` from Section 2.4 to read process the text file.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**英文文本的频率分析。** 编写一个名为`LetterFrequency.java`的程序，从标准输入中读取文本（例如，[白鲸](../data/mobydick.txt)），并计算每个26个小写字母出现的频率。在分析中忽略大写字母、标点符号、空白等。使用第2.4节中的`CharStdIn.java`来读取处理文本文件。'
- en: '**Print longest word(s).** Repeat the previous exercise, but print out all
    of the longest words if there is a tie, say up to a maximum of 10 words. Use an
    array of strings to store the current longest words.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打印最长单词。** 重复上一个练习，但如果存在并列情况，则打印出所有最长的单词，最多打印10个单词。使用一个字符串数组来存储当前最长的单词。'
- en: '**Test if two files are equal.** Write a program that takes the name of two
    text files as command line inputs and checks if their contents are identical.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试两个文件是否相等。** 编写一个程序，接受两个文本文件的名称作为命令行输入，并检查它��的内容是否相同。'
- en: '**Parsing command-line options.** Unix command line programs typically support
    *flags* which configure the behavior of a program to produce different output,
    e.g., "wc -c". Write a program that takes any number of flags from the command
    line and runs whichever options the user specifies. To check options, use something
    like `if (s.equals("-v"))`.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析命令行选项。** Unix命令行程序通常支持*标志*，这些标志配置程序的行为以产生不同的输出，例如，"wc -c"。编写一个程序，从命令行接受任意数量的标志，并运行用户指定的选项。要检查选项，使用类似`if
    (s.equals("-v"))`的语句。'
- en: '**Capitalization.** Write a program `Capitalizer.java` that reads in text strings
    from standard input and modifies each one so that the first letter in each word
    is uppercase and all other letters are lowercase.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大写。** 编写一个名为`Capitalizer.java`的程序，从标准输入中读取文本字符串，并修改每个字符串，使每个单词的第一个字母大写，其他字母小写。'
- en: '**Railfence transposition cipher.** Write a program `RailFenceEncoder.java`
    that reads in text from standard input and prints the characters in the odd positions,
    followed by the even positions. For example, if the original message is "Attack
    at Dawn", then you should print out "Atc tDwtaka an". This is a crude form of
    cryptography.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**栅栏置换密码。** 编写一个名为`RailFenceEncoder.java`的程序，从标准输入中读取文本，并打印出奇数位置的字符，然后是偶数位置的字符。例如，如果原始消息是"Attack
    at Dawn"，那么你应该打印出"Atc tDwtaka an"。这是一种粗糙的加密形式。'
- en: '**Railfence transposition cipher.** Write a program `RailFenceDecoder.java`
    that reads in a message encoded using the railfence transposition cipher and prints
    the original message by reversing the encryption process.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**栅栏置换密码。** 编写一个名为`RailFenceDecoder.java`的程序，该程序读取使用栅栏置换密码编码的消息，并通过反转加密过程来打印原始消息。'
- en: '**Scytale cipher.** The *scytale cipher* is one of the first cryptographic
    devices used for military purposes. (See The Code Book, p. 8 for a nice picture.)
    It was used by the Spartans in the fifth century BCE. To scramble the text, you
    print out every kth character starting at the beginning, then every kth character
    starting at the second character, and so forth. Write a pair of programs `ScytaleEncoder.java`
    and `ScytaleDecoder.java` that implement this encryption scheme.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**斯塞塔利密码。** *斯塞塔利密码*是用于军事目的的第一个密码设备之一。（参见《密码书》，第8页有一张漂亮的图片。）它是由公元前5世纪的斯巴达人使用的。为了混淆文本，你需要从开头开始打印每第k个字符，然后从第二个字符开始打印每第k个字符，依此类推。编写一对程序`ScytaleEncoder.java`和`ScytaleDecoder.java`来实现这种加密方案。'
- en: '**Print longest word.** Read a list of words from standard input, and print
    out the longest word. Use the `length` method.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打印最长单词。** 从标准输入读取一个单词列表，并打印出最长的单词。使用`length`方法。'
- en: '**Subsequence.** Given two strings `s` and `t`, write a program [Subsequence.java](Subsequence.java.html)
    that determines whether `s` is a subsequence of `t`. That is, the letters of `s`
    should appear in the same order in `t`, but not necessarily contiguously. For
    example `accag` is a subsequence of `taagcccaaccgg`.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子序列。** 给定两个字符串`s`和`t`，编写一个程序[Subsequence.java](Subsequence.java.html)，确定`s`是否是`t`的子序列。也就是说，`s`的字母应该按照相同的顺序出现在`t`中，但不一定是连续的。例如，`accag`是`taagcccaaccgg`的一个子序列。'
- en: '**Bible codes.** Some religious zealots believe that the Torah contains hidden
    phrases that appear by reading every kth letter, and that such pattern can be
    used to find the Ark of the Covenant, cure cancer, and predict the future. Results
    not based on scientific method and results have been [debunked](http://cs.anu.edu.au/~bdm/dilugim/torah.html)
    by mathematicians and attributed to illicit data manipulation. Using the same
    methodology one can find statistically similar patterns in a Hebrew translation
    of War and Peace.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**圣经密码。** 一些宗教狂热者相信《圣经》包含通过每第k个字母阅读出现的隐藏短语，并且这种模式可以用于寻找约柜、治愈癌症和预测未来。这些结果不基于科学方法，数学家已经[揭穿](http://cs.anu.edu.au/~bdm/dilugim/torah.html)了这些结果，并将其归因于非法数据操纵。使用相同的方法，可以在《战争与和平》的希伯来文翻译中找到统计上相似的模式。'
- en: '**Word chain checker.** Write a program that reads in a list of words from
    the command line and prints `true` if they form a *word chain* and `false` otherwise.
    In a word chain, adjacent words must differ in exactly one letter, e.g., HEAL,
    HEAD, DEAD, DEED, DEER, BEER.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单词链检查器。** 编写一个程序，从命令行读取一个单词列表，并在它们形成*单词链*时打印`true`，否则打印`false`。在单词链中，相邻单词必须在恰好一个字母上有所不同，例如，HEAL,
    HEAD, DEAD, DEED, DEER, BEER。'
- en: '**Haiku detector.** Write a program that reads in text from standard input
    and checks whether it forms a haiku. A haiku consists of three lines containing
    the correct number of syllables (5, 7, and 5, respectively). For the purpose of
    this problem, define a syllable to be any contiguous sequence of consecutive vowels
    (a, e, i, o, u, or y). According to this rule, *haiku* has two syllables and *purpose*
    has three syllables. Of course, the second example is wrong since the e in purpose
    is silent.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**俳句检测器。** 编写一个程序，从标准输入中读取文本，并检查它是否构成一个俳句。俳句由三行组成，分别包含正确数量的音节（5、7和5个）。根据此问题的定义，一个音节是任何连续的元音序列（a、e、i、o、u或y）。根据这个规则，*haiku*有两个音节，*purpose*有三个音节。当然，第二个例子是错误的，因为purpose中的e是不发音的。'
- en: '**ISBN numbers.** Write a program to check whether an ISBN number is valid.
    Recall check digit. An ISBN number can also have hyphens inserted at arbitrary
    places.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ISBN号码。** 编写一个程序来检查ISBN号码是否有效。回忆校验位。ISBN号码也可以在任意位置插入连字符。'
- en: '**Longest common prefix.** Write a function that takes two input string s and
    t, and returns the longest common prefix of both strings. For example, if s =
    ACCTGAACTCCCCCC and t = ACCTAGGACCCCCC, then the longest common prefix is ACCT.
    Be careful if s and t start with different letters, or if one is a prefix of the
    other.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长公共前缀。** 编写一个函数，接受两个输入字符串s和t，并返回这两个字符串的最长公共前缀。例如，如果s = ACCTGAACTCCCCCC，t
    = ACCTAGGACCCCCC，那么最长公共前缀是ACCT。注意，如果s和t以不同的字母开头，或者一个是另一个的前缀，要小心处理。'
- en: '**Longest complemented palindrome.** In DNA sequence analysis, a *complemented
    palindrome* is a string equal to its reverse complement. Adenine (A) and Thymine
    (T) are complements, as are Cytosine (C) and Guanine (G). For example, ACGGT is
    a complement palindrome. Such sequences act as transcription-binding sites and
    are associated with gene amplification and genetic instability. Given a text input
    of N characters, find the longest complemented palindrome that is a substring
    of the text. For example, if the text is `GACACGGTTTTA` then the longest complemented
    palindrome is `ACGGT`. *Hint*: consider each letter as the center of a possible
    palindrome of odd length, then consider each pair of letters as the center of
    a possible palindrome of even length.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长互补回文。** 在DNA序列分析中，*互补回文*是一个等于其反向互补的字符串。腺嘌呤（A）和胸腺嘧啶（T）是互补的，胞嘧啶（C）和鸟嘌呤（G）也是互补的。例如，ACGGT是一个互补回文。这样的序列作为转录结合位点，并与基因扩增和遗传不稳定性相关联。给定一个长度为N的文本输入，找到文本的最长互补回文子串。例如，如果文本是`GACACGGTTTTA`，那么最长互补回文是`ACGGT`。*提示*：将每个字母视为可能长度为奇数的回文的中心，然后将每对字母视为可能长度为偶数的回文的中心。'
- en: '**Highest density C+G region.** Given a DNA string s of A, C, T, G and a parameter
    L, find a substring of s that contains the highest ratio of C + G characters among
    all substrings that have at least L characters.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最高密度C+G区域。** 给定一个由A、C、T、G组成的DNA字符串`s`和一个参数`L`，找到一个包含最高比例的C + G字符的子串`s`，该子串至少包含`L`个字符。'
- en: '**Substring of a circular shifts.** Write a function that takes two strings
    `s` and `t`, and returns `true` if `s` is a substring of a circular string `t`,
    and `false` otherwise. For example `gactt` is a substring of the circular string
    `tgacgact`.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**循环位移的子字符串。** 编写一个函数，接受两个字符串`s`和`t`，如果`s`是循环字符串`t`的子字符串，则返回`true`，否则返回`false`。例如，`gactt`是循环字符串`tgacgact`的子字符串。'
- en: '**DNA to protein.** A protein is a large molecule (polymer) consisting of a
    sequence of amino acids (monomers). Some examples of proteins are: hemoglobin,
    hormones, antibodies, and ferritin. There are 20 different amino acids that occur
    in nature. Each amino acid is specified by three DNA base pairs (A, C, G, or T).
    Write a program to read in a protein (specified by its base pairs) and converts
    it into a sequence of amino acids. Use the following table. For example, the amino
    acid Isoleucine (I) is encode by ATA, ATC, or ATT.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DNA转蛋白质。** 蛋白质是由一系列氨基酸（单体）组成的大分子（聚合物）。一些蛋白质的例子包括：血红蛋白、激素、抗体和铁蛋白。自然界中存在20种不同的氨基酸。每种氨基酸由三个DNA碱基对（A、C、G或T）指定。编写一个程序，读取一个蛋白质（由其碱基对指定），并将其转换为一系列氨基酸。使用以下表格。例如，异亮氨酸（I）由ATA、ATC或ATT编码。'
- en: Rosetta stone of life.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生命的罗塞塔石。
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| Amino acid | Abbrev | Abbrev |   | Amino acid | Abbrev | Abbrev |'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 氨基酸 | 缩写 | 缩写 |   | 氨基酸 | 缩写 | 缩写 |'
- en: '| Alanine | ala | A |  | Lleucine | leu | L |'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 丙氨酸 | ala | A |  | 亮氨酸 | leu | L |'
- en: '| Arginine | arg | R |  | Lysine | lys | K |'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 精氨酸 | arg | R |  | 赖氨酸 | lys | K |'
- en: '| Asparagine | asn | N |  | Methionine | met | M |'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 天冬酰胺 | asn | N |  | 甲硫氨酸 | met | M |'
- en: '| Aspartic Acid | asp | D |  | Phenylalanine | phe | F |'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 天冬氨酸 | asp | D |  | 苯丙氨酸 | phe | F |'
- en: '| Cysteine | cys | C |  | Proline | pro | P |'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 半胱氨酸 | cys | C |  | 脯氨酸 | pro | P |'
- en: '| Glutamic Acid | glu | E |  | Serine | ser | S |'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 谷氨酸 | glu | E |  | 丝氨酸 | ser | S |'
- en: '| Glutamine | gln | Q |  | Threonine | thr | T |'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 谷氨酰胺 | gln | Q |  | 苏氨酸 | thr | T |'
- en: '| Glycine | gly | G |  | Tryptophan | trp | W |'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 甘氨酸 | gly | G |  | 色氨酸 | trp | W |'
- en: '| Histidine | his | H |  | Tyrosine | tyr | Y |'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 组氨酸 | his | H |  | 酪氨酸 | tyr | Y |'
- en: '| Isoleucine | ile | I |  | Valine | val | V |'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 异亮氨酸 | ile | I |  | 缬氨酸 | val | V |'
- en: '**Counter.** Write a program that reads in a decimal string from the command
    line (e.g., 56789) and starts counting from that number (e.g., 56790, 56791, 56792).
    Do not assume that the input is a 32 or 64 bit integer, but rather an arbitrary
    precision integer. Implement the integer using a `String` (not an array).'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计数器。** 编写一个程序，从命令行读取一个十进制字符串（例如，56789），并从该数字开始计数（例如，56790，56791，56792）。不要假设输入是32位或64位整数，而是一个任意精度整数。使用`String`来实现整数（而不是数组）。'
- en: '**Arbitrary precision integer arithmetic.** Write a program that takes two
    decimal strings as inputs, and prints their sum. Use a string to represent the
    integer.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任意精度整数运算。** 编写一个程序，接受两个十进制字符串作为输入，并打印它们的和。使用一个字符串表示整数。'
- en: '**Boggle.** The game of Boggle is played on a 4-by-4 grid of characters. There
    are 16 dice, each with 6 letters on the them. Create a 4-by-4 grid, where each
    die appears in one of the cells at random, and each die displays one of the 6
    characters at random.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Boggle。** Boggle 游戏在一个 4x4 的字符网格上进行。有 16 个骰子，每个骰子上有 6 个字母。创建一个 4x4 的网格，其中每个骰子以随机方式出现在一个单元格中，每个骰子随机显示其中的一个字母。'
- en: '[PRE25]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Generating cryptograms.** A *cryptogram* is obtained by scrambling English
    text by replacing each letter with another letter. Write a program to generate
    a random permutation of the 26 letters and use this to map letters. Give example:
    Don''t scramble punctuation or whitespace.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成密码。** *密码* 是通过将英文文本混淆而获得的，方法是用另一个字母替换每个字母。编写一个程序来生成 26 个字母的随机排列，并使用它来映射字母。给出示例：不要混淆标点符号或空格。'
- en: '**Scrabble.** Write a program to determine the longest legal Scrabble word
    that can be played? To be legal, the word must be in [The Official Tournament
    and Club Wordlist](../data/scrabble.txt) (TWL98), which consists of all 168,083
    words between 2 and 15 letters in TWL98. The number of tiles representing each
    letter are given in the table below. In addition, there are two *blanks* which
    can be used to represent any letter.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Scrabble。** 编写一个程序来确定可以玩的最长合法 Scrabble 单词是什么？要合法，单词必须在[官方锦标赛和俱乐部单词列表](../data/scrabble.txt)（TWL98）中，其中包含
    TWL98 中介于 2 到 15 个字母之间的所有 168,083 个单词。每个字母代表的瓷砖数量在下表中给出。此外，还有两个 *空白* 可以用来表示任何字母。'
- en: '[PRE26]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Soundex.** The [soundex algorithm](http://www.archives.gov/research_room/genealogy/census/soundex.html)
    is a method of encoding last names based on the way it sounds rather than the
    way it is spelled. Names that sound the same (e.g., SMITH and SMYTH) would have
    the same soundex encoding. The soundex algorithm was originally invented to simplify
    census taking. It is also used by genealogists to cope with names with alternate
    spellings and by airline receptionists to avoid embarrassment when later trying
    to pronounce a customer''s name.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Soundex。** [Soundex 算法](http://www.archives.gov/research_room/genealogy/census/soundex.html)
    是一种根据其发音而不是其拼写方式对姓氏进行编码的方法。发音相同的姓名（例如，SMITH 和 SMYTH）将具有相同的 Soundex 编码。Soundex
    算法最初是为了简化人口普查而发明的。它也被家谱学家用来处理具有替代拼写的姓名，并被航空公司接待员用来避免在稍后尝试发音客户姓名时尴尬。'
- en: 'Write a program [Soundex.java](Soundex.java.html) that reads in two lowercase
    strings as parameters, computes their soundex, and determines if they are equivalent.
    The algorithm works as follows:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序 [Soundex.java](Soundex.java.html)，它将两个小写字符串作为参数读入，计算它们的 Soundex，并确定它们是否等价。算法如下：
- en: Keep the first letter of the string, but remove all vowels and the letters 'h',
    'w', and 'y'.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留字符串的第一个字母，但删除所有元音字母以及字母 'h'，'w' 和 'y'。
- en: 'Assign digits to the remaining letter using the following rules:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下规则为剩余字母分配数字：
- en: '[PRE27]'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If two or more consecutive digits are the same, delete all of the duplicates.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个或更多连续的数字相同，则删除所有重复的数字。
- en: 'Convert the string to four characters: the first character is the first letter
    of the original string, the remaining three characters are the first three digits
    in the string. Pad the string with trailing 0''s if there are not enough digits;
    truncate it if there are too many digits.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串转换为四个字符：第一个字符是原始字符串的第一个字母，剩下的三个字符是字符串中的前三个数字。如果数字不够，用尾随的 0 填充；如果数字太多，则截断。
- en: '**Longest word.** Given a dictionary of words and a starting word s, find the
    longest word that can be formed, starting at s, and inserting one letter at a
    time such that each intermediate word is also in the dictionary. For example,
    if the starting word is `cal`, then the following is a sequence of valid words
    `coal`, `coral`, `choral`, `chorale`. [Reference](http://acm.pku.edu.cn/JudgeOnline/showproblem?problem_id=2138).'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长单词。** 给定一个单词字典和一个起始单词 s，找到可以从 s 开始形成的最长单词，每次插入一个字母，使得每个中间单词也在字典中。例如，如果起始单词是
    `cal`，那么以下是一系列有效单词 `coal`，`coral`，`choral`，`chorale`。[参考链接](http://acm.pku.edu.cn/JudgeOnline/showproblem?problem_id=2138)。'
- en: '**Phone words.** Write a program `PhoneWords.java` that takes a 7 digit string
    of digits as a command line input, reads in a list of words from standard input
    (e.g., the dictionary), and prints all 7-letter words (or 3-letter words followed
    by 4-letter words) in the dictionary that can be formed using the standard phone
    rules, e.g., 266-7883 corresponds to `compute`.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电话单词。** 编写一个程序 `PhoneWords.java`，它将一个 7 位数字字符串作为命令行输入，从标准输入中读取一个单词列表（例如，字典），并打印出所有可以使用标准电话规则形成的
    7 个字母单词（或后跟 4 个字母单词的 3 个���母单词），例如，266-7883 对应于 `compute`。'
- en: '[PRE28]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Rot13**. Rot13 is a very simple encryption scheme used on some Internet newsgroups
    to conceal potentially offensive postings. It works by cyclically shifting each
    lowercase or uppercase letter 13 positions. So, the letter ''a'' is replaced by
    ''n'' and the letter ''n'' is replaced by ''a''. For example, the string "Encryption"
    is encoded as "Rapelcgvba." Write a program [ROT13.java](Rot13.java.html) that
    reads in a String as a command line parameter and encodes it using Rot13.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Rot13**。Rot13 是一种非常简单的加密方案，用于隐藏一些可能具有冒犯性的帖子的互联网新闻组。它通过将每个小写或大写字母循环移位 13 个位置来工作。因此，字母
    ''a'' 被 ''n'' 替换，字母 ''n'' 被 ''a'' 替换。例如，字符串 "Encryption" 被编码为 "Rapelcgvba." 编写一个程序
    [ROT13.java](Rot13.java.html)，它读取一个字符串作为命令行参数，并使用 Rot13 对其进行编码。'
- en: '**Longest Rot13 word**. Write a program that reads in a dictionary of words
    into an array and determines the longest pair of words such that each is the Rot13
    of the other, e.g., bumpily and unfiber.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长 Rot13 单词。** 编写一个程序，将单词字典读入数组，并确定每个单词对中的最长单词，使得每个单词都是另一个单词的 Rot13，例如，bumpily
    和 unfiber。'
- en: '**Thue-Morse weave.** Recall the [Thue-Morse sequence](http://mathworld.wolfram.com/Thue-MorseSequence.html)
    from Exercises in Section 2.3. Write a program [ThueMorse.java](ThueMorse.java.html)
    that reads in a command line input N and plots the N-by-N Thue-Morse weave in
    turtle graphics. Plot cell (i, j) black if the ith and jth bits in the Thue-Morse
    string are different. Below are the Thue-Morse patterns for N = 4, 8, and 16.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Thue-Morse编织。** 回顾第2.3节练习中的[Thue-Morse序列](http://mathworld.wolfram.com/Thue-MorseSequence.html)。编写一个程序[ThueMorse.java](ThueMorse.java.html)，读取一个命令行输入N，并在乌龟图形中绘制N×N的Thue-Morse编织。如果Thue-Morse字符串中第i位和第j位的位不同，则将单元格(i,
    j)绘制为黑色。下面是N = 4、8和16的Thue-Morse模式。'
- en: '| ![4-by-4 Thue-Morse pattern](../Images/65b966e28151674410aec4ae3cb1a66f.png)
    | ![8-by-8 Thue-Morse pattern](../Images/cb26f95f01d4240b91bba774ab21ccb3.png)
    | ![16-by-16 Thue-Morse pattern](../Images/1ac2f6302876899b8d325a574aa30e6e.png)
    |'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![4x4 Thue-Morse模式](../Images/65b966e28151674410aec4ae3cb1a66f.png) | ![8x8
    Thue-Morse模式](../Images/cb26f95f01d4240b91bba774ab21ccb3.png) | ![16x16 Thue-Morse模式](../Images/1ac2f6302876899b8d325a574aa30e6e.png)
    |'
- en: Because of the mesmerizing non-regularity, for large N, your eyes may have a
    hard time staying focused.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于迷人的不规则性，对于较大的N，你的眼睛可能很难保持集中。
- en: '**Repetition words.** Write a program [Repetition.java](Repetition.java.html)
    to read in a list of dictionary words and print out all words for which each letter
    appears exactly twice, e.g., intestines, antiperspirantes, appeases, arraigning,
    hotshots, arraigning, teammate, and so forth.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复单词。** 编写一个程序[Repetition.java](Repetition.java.html)来读取一个单词字典列表，并打印出每个字母恰好出现两次的单词，例如，intestines，antiperspirantes，appeases，arraigning，hotshots，arraigning，teammate等。'
- en: '**Text twist.** Write a program [TextTwist.java](TextTwist.java.html) that
    reads in a word from the command line and a dictionary of words from standard
    input, and prints all words of at least four letters that can be formed by rearranging
    a subset of the letters in the input word. This forms the core of the game [Text
    Twist](http://www.wordplays.com/wordgames/text-twist). *Hint:* create a profile
    of the input word by counting the number of times each of the 26 letters appears.
    Then, for each dictionary word, create a similar profile and check if each letter
    appears at least as many times in the input word as in the dictionary word.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文字转换。** 编写一个程序[TextTwist.java](TextTwist.java.html)，从命令行读取一个单词和标准输入中的单词字典，并打印出由输入单词中的字母子集重新排列而成的至少四个字母的所有单词。这构成了游戏[Text
    Twist](http://www.wordplays.com/wordgames/text-twist)的核心。*提示:*通过计算26个字母出现的次数来创建输入单词的概要。然后，对于每个字典单词，创建一个类似的概要，并检查每个字母在输入单词中出现的次数是否至少与字典单词中的次数相同。'
- en: '**Word frequencies.** Write a program (or several programs and use piping)
    that reads in a text file and prints a list of the words in decreasing order of
    frequency. Consider breaking it up into 5 pieces and use piping: read in text
    and print the words one per line in lowercase, sort to bring identical words together,
    remove duplicates and print count, sort by count.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单词频率。** 编写一个程序（或多个程序并使用管道），读取一个文本文件，并按频率降序打印出单词列表。考虑将其分成5部分并使用管道：读取文本并以小写形式逐行打印单词，排序以将相同的单词放在一起，去除重复项并打印计数，按计数排序。'
- en: '**VIN numbers.** A [VIN number](http://www.mathnotes.com/aw_IDnumber.html)
    is a 17-character string that uniquely identifies a motor vehicle. It also encodes
    the manufacturer and attributes of the vehicle. To guard against accidentally
    entering an incorrect VIN number, the VIN number incorporates a check digit (the
    9th character). Each letter and number is assigned a value between 0 and 9\. The
    check digit is chosen so to be the weighted sum of the values mod 11, using the
    symbol `X` if the remainder is 10.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**VIN号码。** [VIN号码](http://www.mathnotes.com/aw_IDnumber.html)是一个用于唯一标识机动车辆的17个字符的字符串。它还编码了车辆的制造商和属性。为了防止意外输入错误的VIN号码，VIN号码包含一个检验位（第9个字符）。每个字母和数字被分配一个0到9之间的值。检验位被选择为值的加权和对11取模，如果余数为10，则使用符号`X`。'
- en: '[PRE29]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For example the check digit of the partial VIN number 1FA-CP45E-?-LF192944 is
    X because the weighted sum is 373 and 373 mod 11 is 10.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，部分VIN号码1FA-CP45E-?-LF192944的��验位为X，因为加权和为373，373 mod 11为10。
- en: '[PRE30]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Write a program [VIN.java](VIN.java.html) that takes a command line string and
    determines whether or not it is a valid VIN number. Allow the input to be entered
    with upper or lower case, and allow dashes to be inserted. Do thorough error checking,
    e.g., that the string is the right length, that no illegal characters are used
    (I, O, Q), etc.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[VIN.java](VIN.java.html)，接受一个命令行字符串，并确定它是否是一个有效的VIN号码。允许输入大小写字母，并允许插入破折号。进行彻底的错误检查，例如，字符串的长度是否正确，是否使用了非法字符（I，O，Q）等。
- en: '**Music CDs.** Screen-scrape [MusicBrainz](http://musicbrainz.org) to identify
    information about music CDs.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**音乐CD。** 屏幕抓取[MusicBrainz](http://musicbrainz.org)以识别有关音乐CD的信息。'
- en: '**Pig Latin.** Pig Latin is a fun secret language for young children. To convert
    a word to Pig Latin:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**猪拉丁文。** 猪拉丁文是一种供年幼儿童使用的有趣秘密语言。要将一个单词转换为猪拉丁文：'
- en: If it begins with a vowel, append "hay" to the end. At the beginning of a word,
    treat y as a vowel unless it is followed by a vowel.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果以元音字母开头，则在末尾附加“hay”。在单词开头，将y视为元音字母，除非后面跟着一个元音字母。
- en: If it begins with a sequence of consonants, move the consonants to the end,
    then append "ay". Treat a u following a q as a consonant.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果以一串辅音字母开头，将辅音字母移到末尾，然后附加“ay”。将跟在q后面的u视为辅音字母。
- en: For example, "input" becomes "input-hay", "standard" becomes "andard-stay",
    "quit" becomes "it-quay". Write a program `PigLatinCoder.java` that reads in a
    sequence of words from standard input and prints them to standard output in Pig
    Latin. Write a program `PigLatinDecoder.java` that reads in a sequence of words
    encoded in Pig Latin from standard input and prints the original words out in.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，“input”变为“input-hay”，“standard”变为“andard-stay”，“quit”变为“it-quay”。编写一个程序`PigLatinCoder.java`，从标准输入读取一系列单词，并以猪拉丁文形式将它们打印到标准输出。编写一个程序`PigLatinDecoder.java`，从标准输入读取以猪拉丁文编码的一系列单词，并将原始单词打印出来。
- en: '**Rotating drum problem.** Applications to pseudo-random number generators,
    computational biology, coding theory. Consider a rotating drum (draw picture of
    circle divided into 16 segments, each of one of two types - 0 and 1). We want
    that any sequence of 4 consecutive segments to uniquely identify the quadrant
    of the drum. That is, every 4 consecutive segments should represent one of the
    16 binary numbers from 0000 to 1111\. Is this possible? A *de Bruijn sequence*
    of order n is a shortest (circular) string such that every sequence of n bits
    appears as a substring at least once. For example, 0000111101100101 is a de Bruijn
    sequence of order 4, and all 2^4 possible 4-bit sequence (0000, 0001, ..., 1111)
    occur exactly once. Write a program [DeBruijn.java](DeBruijn.java.html) that reads
    in a command line parameter n and prints an order n de Bruijn sequence. Algorithm:
    start with n 0''s. Append a 1 if the n-tuple that would be formed has not already
    appeared in the sequence; append a 0 otherwise. *Hint:* use the methods `String.indexOf`
    and `String.substring`.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**旋转鼓问题。** 应用于伪随机数生成器、计算生物学、编码理论。考虑一个旋转鼓（画一个被分成16个段的圆的图片，每个段都是两种类型之一 - 0和1）。我们希望任何4个连续段的序列都能唯一标识鼓的象限。也就是说，每4个连续段应该代表从0000到1111的16个二进制数中的一个。*德布鲁因序列*是一个最短的（循环）字符串，使得每个n位比特序列至少出现一次。例如，0000111101100101是一个4阶德布鲁因序列，所有2^4个可能的4位序列（0000、0001、...、1111）都恰好出现一次。编写一个程序[DeBruijn.java](DeBruijn.java.html)，读取一个命令行参数n，并打印一个n阶德布鲁因序列。算法：从n个0开始。如果形成的n元组在序列中尚未出现，则附加一个1；否则附加一个0。*提示：*使用`String.indexOf`和`String.substring`方法。'
- en: '**Ehrenfecucht-Mycielski sequence.** The *Ehrenfecucht-Mycielski sequence*
    in a binary sequence that starts with "010". Given the first n bits b[0], b[1],
    ..., b[n-1], b[n] is determined by finding the longest suffix b[j], b[j+1], ...,
    b[n-1] that occurs previously in the sequence (if it occurs multiple times, take
    the last such occurrence). Then, b[n] is the opposite of the bit that followed
    the match. 0100110101110001000011110110010100100111010001100000101101111100. *Hint*:
    Use the `substring()` and `lastIndexOf()` methods.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**埃伦费库特-米切尔斯基序列。** *埃伦费库特-米切尔斯基序列*是以"010"开头的二进制序列。给定前n位b[0]、b[1]、...、b[n-1]，b[n]通过找到先前出现的最长后缀b[j]、b[j+1]、...、b[n-1]来确定（如果出现多次，则取最后一次出现）。然后，b[n]是跟在匹配项后面的位的相反值。0100110101110001000011110110010100100111010001100000101101111100。*提示：*使用`substring()`和`lastIndexOf()`方法。'
- en: Web Exercises (Image Processing)
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习（图像处理）
- en: '**Painter''s and printer''s color triangles.** Create the following two images.
    The primary hues of the painter''s triangle are red, green, and blue; the primary
    hues of the printer''s triangle are magenta, cyan, and yellow.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**画家和打印机的色彩三角形。** 创建以下两幅图像。画家三角形的主色调是红色、绿色和蓝色；打印机三角形的主色调是品红、青色和黄色。'
- en: '|                | ![Painter''s triangle](../Images/e41b95346b1b62a83b863d10b65d8344.png)
    |                | ![Printer''s triangle](../Images/740106f49889659dfb324ab2bbcbd7fb.png)
    |'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|                | ![Painter''s triangle](../Images/e41b95346b1b62a83b863d10b65d8344.png)
    |                | ![Printer''s triangle](../Images/740106f49889659dfb324ab2bbcbd7fb.png)
    |'
- en: '**Two-stroke apparent motion.** Create the optical illusion of [two-stroke
    apparent motion](http://www.georgemather.com/MotionDemos/TwostrokeMP4.html) or
    [four-stroke](http://www.georgemather.com/MotionMP4.html)'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两步视觉运动。** 创建[两步视觉运动](http://www.georgemather.com/MotionDemos/TwostrokeMP4.html)或[四步](http://www.georgemather.com/MotionMP4.html)的视觉错觉。'
- en: '**De Valois'' checkerboard.** Create the optical illusion of [De Valois'' checkerboard](http://www.shapirolab.net/Illusions/Checker%20Board.html)
    or one of the other optical illusions from the [Shapiro Perception Lab](http://www.shapirolab.net/).'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**德瓦洛伊斯的棋盘。** 创建[德瓦洛伊斯的棋盘](http://www.shapirolab.net/Illusions/Checker%20Board.html)或来自[夏皮罗感知实验室](http://www.shapirolab.net/)的其他视觉错觉之一。'
- en: '**Color spectrum.** Write a program [Spectrum.java](Spectrum.java.html) that
    draws all 2^24 possible colors, by drawing for each red value a 256-by-256 array
    of color chips (one for each green and blue value).'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**色谱。** 编写一个程序[Spectrum.java](Spectrum.java.html)，绘制所有2^24种可能的颜色，通过为每个红色值绘制一个256x256的颜色芯片数组（每个绿色和蓝色值一个）。'
- en: '**Vertical flip.** Write a program `FlipY.java` that reads in an image and
    flips it vertically.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垂直翻转。** 编写一��程序`FlipY.java`，读取一幅图像并进行垂直翻转。'
- en: '**Picture dimensions.** Write a program `Dimension.java` that take the name
    of an image file as a command line input and prints its dimension (width-by-height).'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图片尺寸。** 编写一个程序`Dimension.java`，接受一个图像文件名作为命令行输入，并打印其尺寸（宽×高）。'
- en: '**Anti-aliasing.** *Anti-aliasing* is a method of removing artifacts from representing
    a smooth curve with a discrete number of pixels. A very crude way of doing this
    (which also blurs the image) is to convert an N-by-N grid of pixels into an (N-1)-by-(N-1)
    by making each pixel be the average of four cells in the original image as below.
    Write a program `AntiAlias` that reads in an integer N, then an N-by-N array of
    integers, and prints the anti-aliased version. [Reference](http://acm2003.csc.lsu.edu/problems/prb.php?prob=2).'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抗锯齿。** *抗锯齿*是一种消除用有限数量的像素表示平滑曲线的伪影的方法。一个非常粗糙的方法（也会使图像模糊）是将一个N×N像素网格转换为一个(N-1)×(N-1)像素，方法是将原始图像中的每个像素设为四个单元格的平均值。编写一个程序`AntiAlias`，读取一个整数N，然后读取一个N×N的整数数组，并打印抗锯齿版本。[参考](http://acm2003.csc.lsu.edu/problems/prb.php?prob=2)。'
- en: '**Thresholding.** Write a program [Threshold.java](Threshold.java.html) that
    reads in a grayscale version of a black-and-white picture, creates and plots a
    histogram of 256 grayscale intensities, and determines the threshold value for
    which pixels are black, and which are white.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阈值处理。** 编写一个程序[Threshold.java](Threshold.java.html)，读取一幅黑白图片的灰度版本，创建并绘制256个灰度强度的直方图，并确定像素为黑色和白色的阈值。'
- en: '**Mirror image.** Read in a W-by-H picture and produce a 2W-by-H picture which
    concatenates the original W-by-H picture with the mirror image of the W-by-H picture.
    Repeat by mirror around the y-axis. Or create a W-by-H picture, but mirror around
    the center, deleting half the picture.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**镜像图像。** 读取一个WxH图片，并生成一个2WxH图片，其中包含原始WxH图片和WxH图片的镜像。围绕y轴重复镜像。或者创建一个WxH图片，但围绕中心镜像，删除图片的一半。'
- en: '**Linear filters.** A *box filter* or *mean filter* replaces the color of pixel
    (x, y) by the average of its 9 neighboring pixels (including itself). The matrix
    [1 1 1; 1 1 1; 1 1 1] / 9 is called the *convolution kernel*. The kernel is the
    set of pixels to be averaged together. Program [MeanFilter.java](MeanFilter.java.html)
    implements a mean filter using the `Picture` data type.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**线性滤波器。** *盒子滤波器*或*均值滤波器*通过其9个相邻像素（包括自身）的平均值来替换像素(x, y)的颜色。矩阵[1 1 1; 1 1 1;
    1 1 1] / 9被称为*卷积核*。卷积核是要一起平均的像素集。程序[MeanFilter.java](MeanFilter.java.html)使用`Picture`数据类型实现了一个均值滤波器。'
- en: '**Blur filter.** Use low-pass 3-by-3 uniform filter [1/13 1/13 1/13; 1/13 5/13
    1/13; 1/13, 1/13, 1/13].'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模糊滤波器。** 使用低通3x3均匀滤波器[1/13 1/13 1/13; 1/13 5/13 1/13; 1/13, 1/13, 1/13]。'
- en: '**Emboss filter.** Use prewitt masks [-1 0 1; -1 1 1; -1 0 1] (east) or [1
    0 -1; 2 0 -2; 1 0 -1], [-1 -1 0; -1 1 1; 0 1 1] (south-east),'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**浮雕滤波器。** 使用prewitt掩模[-1 0 1; -1 1 1; -1 0 1]（东）或[1 0 -1; 2 0 -2; 1 0 -1]，[-1
    -1 0; -1 1 1; 0 1 1]（东南），'
- en: '**Sharpen filter.** Psychophysical experiments suggest that a photograph with
    crisper edges is more aesthetically pleasing than exact photographic reproduction.
    Use a high-pass 3-by-3 filter. Light pixels near dark pixels are made lighter;
    dark pixels near light pixels are made darker. Laplace kernel. Attempts to capture
    region where second derivative is zero. [-1 -1 -1; -1 8 -1; -1 -1 -1]'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**锐化滤波器。** 心理物理实验表明，具有更清晰边缘的照片比精确的照片复制更具美感。使用高通3x3滤波器。使接近暗像素的亮像素变得更亮；使接近亮像素的暗像素变得更暗。拉普拉斯核。试图捕捉二阶导数为零的区域。[-1
    -1 -1; -1 8 -1; -1 -1 -1]'
- en: '**Oil painting filter.** Set pixel (i, j) to the color of the most frequent
    value among pixels with Manhattan distance W of (i, j) in the original image.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**油画滤波器。** 将像素(i, j)设置为原始图像中曼哈顿距离为W的像素中最频繁值的颜色。'
- en: '**Luminance and chrominance.** Decompose a picture using the YIQ color space:
    Y (luma) = 0.299 r + 0.587 g + 0.114 b, I (in-phase) = 0.596 r - 0.274 g - 0.322
    b, and Q (quadrature) = 0.211 r - 0.523 g + 0.312 b. Plot all 3 images. The YIQ
    color space is used by NTSC color TV system.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**亮度和色度。** 使用YIQ颜色空间分解图片：Y（亮度）= 0.299 r + 0.587 g + 0.114 b，I（相位）= 0.596 r
    - 0.274 g - 0.322 b，Q（象限）= 0.211 r - 0.523 g + 0.312 b。绘制所有3幅图像。YIQ颜色空间被NTSC彩色电视系统使用。'
- en: '**Brighten.** Write a program [Brighter.java](Brighter.java.html) that takes
    a command line argument which is the name of a JPG or PNG file, displays it in
    a window, and display a second version which is a brighter copy. Use the `Color`
    method `brighter()`, which return a brighter version of the invoking color.'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变亮。** 编写一个程序[Brighter.java](Brighter.java.html)，该程序接受一个命令行参数，即JPG或PNG文件的名称，将其显示在窗口中，并显示一个更亮的副本。使用`Color`方法`brighter()`，它返回调用颜色的更亮版本。'
- en: '| ![baboon](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![brighter
    baboon](../Images/af23bd6539193ef3aeeee376df211e9f.png) |'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![狒狒](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![更亮的狒狒](../Images/af23bd6539193ef3aeeee376df211e9f.png)
    |'
- en: '**Edge detection.** Goal: form mathematical model of some feature of the image.
    To accomplish this, we want to detect edges or lines. An *edge* is a area of a
    picture with a strong contrast in intensity from one pixel to the next. Edge detection
    is a fundamental problem in image processing and computer vision. The *Sobel method*
    is a popular edge detection technique. We assume that the image is grayscale.
    (If not, we can convert by taking the average of the red, green, and blue intensities.)
    For each pixel (i, j) we calculate the *edge strength* by computing two 3-by-3
    *convolution masks*. This involves taking the grayscale values of the nine pixels
    in the 3-by-3 neighborhood centered on (i, j), multiplying them by the corresponding
    weight in the 3-by-3 mask, and summing up the products.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边缘检测。** 目标：形成图像某些特征的数学模型。为了实现这一目标，我们希望检测边缘或线条。*边缘*是图片中一个像素到下一个像素之间强烈对比的区域。边缘检测是图像处理和计算机视觉中��一个基本问题。*Sobel方法*是一种流行的边缘检测技术。我们假设图像是灰度的。（如果不是，我们可以通过取红色、绿色和蓝色强度的平均值来转换。）对于每个像素(i,
    j)，我们通过计算两个3x3*卷积掩模*来计算*边缘强度*。这涉及计算以(i, j)为中心的3x3邻域中九个像素的灰度值，将它们乘以3x3掩模中的相应权重，并将乘积相加。  '
- en: '[PRE31]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This produces two values Gx and Gy. In the output picture, we color the pixel
    (i, j) according to the grayscale value 255 - Sqrt(Gx*Gx + Gy*Gy). There are various
    ways to handle the boundary. For simplicity, we ignore this special case and color
    the boundary pixels black. Program [EdgeDetector.java](EdgeDetector.java.html)
    takes the name of an image as a command line input and applies the Sobel edge
    detection algorithm to that image.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这产生两个值Gx和Gy。在输出图片中，我们根据灰度值255 - Sqrt(Gx*Gx + Gy*Gy)对像素(i, j)进行着色。处理边界的方法有很多种。为简单起见，我们忽略这种特殊情况，并将边界像素着色为黑色。程序[EdgeDetector.java](EdgeDetector.java.html)接受图像名称作为命令行输入，并对该图像应用Sobel边缘检测算法。
- en: '| ![baboon](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![Sobel
    baboon](../Images/7f16cb0420e016e4bc91b5c4e5648f51.png) |'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![狒狒](../Images/cf5710079eb12fddce40cbfb49066ef2.png) |      | ![Sobel狒狒](../Images/7f16cb0420e016e4bc91b5c4e5648f51.png)
    |'
