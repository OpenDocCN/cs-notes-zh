- en: 4.1 Analysis of Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 算法分析
- en: 原文：[https://introcs.cs.princeton.edu/python/41analysis](https://introcs.cs.princeton.edu/python/41analysis)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/41analysis](https://introcs.cs.princeton.edu/python/41analysis)
- en: <title>4.1 Analysis of Algorithms</title>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <title>4.1 算法分析</title>
- en: 'It is important to pay attention to the cost of the programs that we compose.
    To study the cost of running our programs, we study them via the *scientific method*,
    the commonly accepted body of techniques universally used by scientists to develop
    knowledge about the natural world. The following five-step approach briefly summarizes
    the scientific method:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的程序的成本是值得关注的。为了研究我们程序的运行成本，我们通过*科学方法*进行研究，这是科学家们普遍使用的一套技术，用于开发关于自然界的知识。以下五步方法简要总结了科学方法：
- en: '*Observe* some feature of the natural world.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*观察*自然界的某些特征。'
- en: '*Hypothesize* a model that is consistent with the observations.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出与观察一致的模型的*假设*。
- en: '*Predict* events using the hypothesis.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用假设*预测*事件。
- en: '*Verify* the predictions by making further observations.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过进一步观察*验证*预测。
- en: '*Validate* by repeating until the hypothesis and observations agree.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重复直到假设和观察一致来*验证*。
- en: 'We also apply *mathematical analysis* to derive concise models of the cost.
    In most situations, we are interested in one fundamental characteristic: time.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应用*数学分析*来推导成本的简洁模型。在大多数情况下，我们对一个基本特征感兴趣：时间。
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Observations
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察
- en: Our first challenge is to make quantitative measurements of the running time
    of our programs. There are a number of tools available to help us obtain approximations.
    Perhaps the simplest is a physical stopwatch or the `Stopwatch` data type defined
    in [stopwatch.py](../32class/stopwatch.py.html) (from Section 3.2). We can simply
    run a program on various inputs, measuring the amount of time to process each
    input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个挑战是对程序的运行时间进行定量测量。有许多工具可用于帮助我们获得近似值。也许最简单的是物理秒表或在[stopwatch.py](../32class/stopwatch.py.html)（来自第3.2节）中定义的`Stopwatch`数据类型。我们可以简单地在各种输入上运行程序，测量处理每个输入所需的时间。
- en: With most programs there is a problem size that characterizes the difficulty
    of the computational task. Normally, the problem size is either the size of the
    input or the value of a command-line argument. Intuitively, the running time should
    increase with the problem size, but the question of how much it increases naturally
    arises every time we develop and run a program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数程序，存在一个表征计算任务难度的问题大小。通常，问题大小要么是输入的大小，要么是命令行参数的值。直观地，运行时间应该随问题大小增加而增加，但每次我们开发和运行程序时，问题大小与[threesum.py](threesum.py.html)的运行时间之间的关系自然地引起了我们的注意。
- en: As a concrete example, we start with [threesum.py](threesum.py.html), which
    counts the number of triples that sum to 0 in an array of *n* numbers. Try running
    it on the files [8ints.txt](8ints.txt), [1kints.txt](1kints.txt), [2kints.txt](2kints.txt),
    [4kints.txt](4kints.txt), [8kints.txt](8kints.txt), [16kints.txt](16kints.txt),
    [32kints.txt](32kints.txt), [64kints.txt](64kints.txt), and [128kints.txt](128kints.txt)
    to get a sense of the running time of the program. What is the relationship between
    the problem size *n* and the running time for [threesum.py](threesum.py.html)?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，我们从[threesum.py](threesum.py.html)开始，它计算一个包含*n*个数字的数组中总和为0的三元组的数量。尝试在文件[8ints.txt](8ints.txt)、[1kints.txt](1kints.txt)、[2kints.txt](2kints.txt)、[4kints.txt](4kints.txt)、[8kints.txt](8kints.txt)、[16kints.txt](16kints.txt)、[32kints.txt](32kints.txt)、[64kints.txt](64kints.txt)和[128kints.txt](128kints.txt)上运行它，以了解程序的运行时间。问题大小*n*与[threesum.py](threesum.py.html)的运行时间之间的关系是什么？
- en: '* * *'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Hypotheses
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设
- en: Every programmer needs to know how to make back-of-the-envelope performance
    estimates. Fortunately, we can often acquire such knowledge by using a combination
    of empirical observations and a small set of mathematical tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员都需要知道如何进行快速性能估算。幸运的是，我们通常可以通过使用经验观察和一小组数学工具来获得这样的知识。
- en: Doubling hypotheses.
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加倍假设。
- en: 'For a great many programs, we can quickly formulate a hypothesis for the following
    question: What is the effect on the running time of doubling the size of the input?
    For clarity, we refer to this hypothesis as a *doubling hypothesis*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多程序，我们可以很快为以下问题制定一个假设：将输入大小加倍对运行时间的影响是什么？为了清晰起见，我们将这个假设称为*加倍假设*。
- en: Empirical analysis.
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验分析。
- en: Clearly, we can get a headstart on developing a doubling hypothesis by doubling
    the size of the input and observing the effect on the running time. For example,
    [doublingtest.py](doublingtest.py.html) generates a sequence of random input arrays
    for [threesum.py](threesum.py.html), doubling the array length at each step, and
    writes the ratio of running times of `threesum.countTriples()` for each input
    over the previous (which was one-half the size). `Stopwatch` measurements that
    the program writes lead immediately to the hypothesis that the running time increases
    by a factor of 8 when the input size doubles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们可以通过将输入大小加倍并观察运行时间的影响来提前发展一个加倍假设。例如，[doublingtest.py](doublingtest.py.html)为[threesum.py](threesum.py.html)生成一系列随机输入数组，每一步都将数组长度加倍，并写下`threesum.countTriples()`对于每个输入的运行时间与前一个输入（大小为前一个输入的一半）的比值。程序写入的`Stopwatch`测量立即导致一个假设：当输入大小加倍时，运行时间增加了8倍。
- en: Mathematical analysis.
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学分析。
- en: 'The total running time of a program is determined by two primary factors:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的总运行时间由两个主要因素决定：
- en: The cost of executing each statement
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个语句的执行成本
- en: The frequency of execution of each statement
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个语句的执行频率
- en: The former is a property of the system, and the latter is a property of the
    algorithm. If we know both for all instructions in the program, we can multiply
    them together and sum for all instructions in the program to get the running time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是系统的属性，后者是算法的属性。如果我们对程序中的所有指令都了解这两者，我们可以将它们相乘并对程序中的所有指令求和，以获得运行时间。
- en: The primary challenge is to determine the frequency of execution of the statements.
    Some statements are easy to analyze; for example, the statement that initializes
    `count` to 0 in `threesum.countTriples()` is executed only once. Others require
    higher-level reasoning; for example, the `if` statement in `threesum.countTriples()`
    is executed precisely *n*(*n*-1)(*n*-2)/6 times (that is precisely the number
    of ways to pick three different numbers from the input array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要挑战在于确定语句的执行频率。有些语句很容易分析；例如，在`threesum.countTriples()`中将`count`初始化为0的语句只执行一次。其他需要更高级推理的语句；例如，在`threesum.countTriples()`中的`if`语句精确地执行*n*(*n*-1)(*n*-2)/6次（这正是从输入数组中选择三个不同数字的方法的数量）。
- en: To substantially simplify matters in the mathematical analysis, we develop simpler
    approximate expressions in two ways. First, we work with the leading term of mathematical
    expressions by using a mathematical device known as the *tilde notation*. We write
    ~*f*(*n*) to represent any quantity that, when divided by *f*(*n*), approaches
    1 as *n* grows. We also write *g*(*n*) ~ *f*(*n*) to indicate that *g*(*n*)/*f*(*n*)
    approaches 1 as *n* grows. With this notation, we can ignore complicated parts
    of an expression that represent small values. For example, the `if` statement
    in `countTriples()` in [threesum.py](threesum.py.html) is executed ~*n*³/6 times
    because *n*(*n*-1)(*n*-2)/6 = *n*³/6 - *n*²/2 + *n*/3, which, when divided by
    *n*³/6, approaches 1 as *n* grows. This notation is useful when the terms after
    the leading term are relatively insignificant (for example, when *n* = 1,000,
    this assumption amounts to saying that -*n*²/2 + *n*/3 ≈ -499,667 is relatively
    insignificant by comparison with *n*³/6 ≈ 166,666,667, which it is). Second, we
    focus on the instructions that are executed most frequently, sometimes referred
    to as the *inner loop* of the program. In this program it is reasonable to assume
    that the time devoted to the instructions outside the inner loop is relatively
    insignificant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数学分析中大大简化问题，我们以两种方式开发了更简单的近似表达式。首先，我们通过使用一种称为*波浪符号*的数学工具来处理数学表达式的主导项。我们写成
    ~*f*(*n*) 来表示任何数量，当除以*f*(*n*)时，随着*n*的增长趋于1。我们还写成*g*(*n*) ~ *f*(*n*)来表示*g*(*n*)/*f*(*n*)随着*n*的增长趋于1。有了这个符号，我们可以忽略代表小值的表达式的复杂部分。例如，在[threesum.py](threesum.py.html)中的`countTriples()`中的`if`语句执行了~*n*³/6次，因为*n*(*n*-1)(*n*-2)/6
    = *n*³/6 - *n*²/2 + *n*/3，当除以*n*³/6时，随着*n*的增长趋于1。当主导项后的项相对不重要时，这种符号是有用的（例如，当*n*
    = 1,000时，这个假设相当于说-*n*²/2 + *n*/3 ≈ -499,667相对于*n*³/6 ≈ 166,666,667是相对不重要的）。其次，我们关注执行频率最高的指令，有时被称为程序的*内循环*。在这个程序中，合理地假设内循环之外的指令所花费的时间相对不重要。
- en: 'The key point in analyzing the running time of a program is this: for a great
    many programs, the running time satisfies the relationship'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分析程序的运行时间的关键点在于：对于许多程序，运行时间满足关系
- en: '| *T*(*n*) ~ *cf*(*n*) |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| *T*(*n*) ~ *cf*(*n*) |'
- en: 'where *c* is a constant and *f*(*n*) is a function known as the *order of growth*
    of the running time. For typical programs, *f*(*n*) is a function such as log
    *n*, *n*, *n* log *n*, *n*², or *n*³ (customarily, we express order-of-growth
    functions without any constant coefficient). When *f*(*n*) is a power of *n*,
    as is often the case, this assumption is equivalent to saying that the running
    time satisfies a power law. In the case of [threesum.py](threesum.py.html), it
    is a hypothesis already verified by our empirical observations: the order of growth
    of the running time of [threesum.py](threesum.py.html) is *n*³. The value of the
    constant *c* depends both on the cost of executing instructions and on details
    of the frequency analysis, but we normally do not need to work out the value.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*c*是一个常数，*f*(*n*)是一个称为运行时间*增长顺序*的函数。对于典型程序，*f*(*n*)是一个如log *n*、*n*、*n* log
    *n*、*n*²或*n*³的函数（通常，我们表达增长顺序函数时不带任何常数系数）。当*f*(*n*)是*n*的幂时，这种假设通常等同于说运行时间满足幂律。在[threesum.py](threesum.py.html)的情况下，这是我们的经验观察已经验证的假设：[threesum.py](threesum.py.html)的运行时间的增长顺序是*n*³。常数*c*的值取决于执行指令的成本和频率分析的细节，但我们通常不需要计算出这个值。
- en: The order of growth is a simple but powerful model of running time. For example,
    knowing the order of growth typically leads immediately to a doubling hypothesis.
    In the case of [threesum.py](threesum.py.html), knowing that the order of growth
    is *n*³ tells us to expect the running time to increase by a factor of 8 when
    we double the size of the problem because
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 增长顺序是一个简单但强大的运行时间模型。例如，知道增长顺序通常会立即导致加倍假设。在[threesum.py](threesum.py.html)的情况下，知道增长顺序是*n*³告诉我们，当我们将问题规模加倍时，预计运行时间将增加8倍，因为
- en: '| *T*(2*n*) / *T*(*n*) ~ *c*(2*n*)³ / (*cn*³) = 8 |'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| *T*(2*n*) / *T*(*n*) ~ *c*(2*n*)³ / (*cn*³) = 8 |'
- en: This matches the value resulting from the empirical analysis, thus validating
    both the model and the experiments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这与经验分析得出的值相匹配，从而验证了模型和实验。
- en: '* * *'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Order of Growth Classifications
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增长顺序分类
- en: '![Common growth functions](../Images/0869ec8ca415276cb01cb2bc4a11e49c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![常见增长函数](../Images/0869ec8ca415276cb01cb2bc4a11e49c.png)'
- en: We use just a few structural primitives (statements, conditionals, loops, and
    function calls) to build Python programs, so very often the order of growth of
    our programs is one of just a few functions of the problem size, summarized in
    the table at the right.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了一些结构原语（语句、条件、循环和函数调用）来构建Python程序，因此我们程序的增长顺序往往是问题规模的几个函数之一，总结在右侧的表中。
- en: Constant.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常数。
- en: 'A program whose running time''s order of growth is *constant* executes a fixed
    number of statements to finish its job; consequently, its running time does not
    depend on the problem size. Our first several programs in Chapter 1 — such as
    [helloworld.py](../11hello/helloworld.py.html) (from Section 1.1) and [leapyear.py](../12types/leapyear.py.html)
    (from Section 1.2) — fall into this category: they each execute several statements
    just once.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间增长阶数为*常数*的程序执行固定数量的语句来完成任务；因此，其运行时间不取决于问题规模。我们在第1章中的前几个程序——比如[hello.py](../11hello/helloworld.py.html)（来自第1.1节）和[leapyear.py](../12types/leapyear.py.html)（来自第1.2节）——属于这一类：它们每次只执行几个语句。
- en: All of Python's operations on standard numeric types take constant time. That
    is, applying an operation to a large number consumes no more time than does applying
    it to a small number. (One exception is that operations involving integers with
    a huge number of digits can consume more than constant time; see the Q & A at
    the end of this section for details.) The functions in Python's `math` module
    also take constant time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python对标准数值类型的所有操作都需要恒定时间。也就是说，将操作应用于大数值与将其应用于小数值消耗的时间相同。 （一个例外是涉及具有大量位数的整数的操作可能消耗超过常数时间；有关详细信息，请参阅本节末尾的问答。）Python的`math`模块中的函数也需要恒定时间。
- en: Logarithmic.
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对数。
- en: A program whose running time's order of growth is *logarithmic* is barely slower
    than a constant-time program. The classic example of a program whose running time
    is logarithmic in the problem size is looking for an element in a sorted array
    (see [binarysearch.py](../42sort/binarysearch.py.html) from Section 4.2). The
    base of the logarithm is not relevant with respect to the order of growth (since
    all logarithms with a constant base are related by a constant factor), so we usually
    use log *n* when referring to the order of growth.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间增长阶数为*对数*的程序几乎比常数时间程序慢。在问题规模上运行时间为对数的程序的经典示例是在排序数组中查找元素（见[二分查找.py](../42sort/binarysearch.py.html)第4.2节）。对数的底数与增长阶数无关（因为所有具有常数底数的对数都由一个常数因子相关），因此我们通常在提到增长阶数时使用log
    *n*。
- en: Linear.
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性。
- en: We use the term *linear* to decribe the order of growth of a program that spends
    a constant amount of time processing each piece of input data, or that is based
    on a single `for` loop. The running time of such a program is directly proportional
    to the problem size. The program [average.py](../15inout/average.py.html) (from
    Section 1.5), which computes the average of the numbers on standard input, is
    prototypical.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语*线性*来描述程序的增长阶数，该程序在处理每个输入数据片段时花费恒定的时间，或者基于单个`for`循环。这样的程序的运行时间与问题规模成正比。计算标准输入数字平均值的程序[average.py](../15inout/average.py.html)（来自第1.5节）是典型的例子。
- en: Linearithmic.
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性对数。
- en: We use the term *linearithmic* to describe programs whose running time for a
    problem of size *n* has order of growth *n* log *n*. Again, the base of the logarithm
    is not relevant. For example, [couponcollector.py](../14array/couponcollector.py.html)
    (from Section 1.4) is linearithmic. The prototypical example is mergesort, as
    implemented in [merge.py](../42sort/merge.py.html) (from Section 4.2).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语*线性对数*来描述对于规模为*n*的问题，其运行时间增长阶数为*n* log *n*的程序。同样，对数的底数不相关。例如，[couponcollector.py](../14array/couponcollector.py.html)（来自第1.4节）是线性对数的。典型示例是归并排序，如在[merge.py](../42sort/merge.py.html)（来自第4.2节）中实现的。
- en: Quadratic.
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二次方。
- en: A typical program whose running time has order of growth *n*² has two nested
    `for` loops, used for some calculation involving all pairs of *n* elements, is
    said to have *quadratic* order of growth. The force update double loop in [universe.py](../34nbody/universe.py.html)
    (from Section 3.4) is a prototype of the programs in this classification, as is
    the elementary sorting algorithm insertion sort, as defined in [insertion.py](../42sort/insertion.py.html)
    (see Section 4.2).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间增长阶数为*n*²的典型程序有两个嵌套的`for`循环，用于涉及所有*n*个元素对的某些计算，被称为*二次方*增长。在[universe.py](../34nbody/universe.py.html)（来自第3.4节）中的力更新双循环是这一类程序的原型，以及在[insertion.py](../42sort/insertion.py.html)（见第4.2节）中定义的基本排序算法插入排序。
- en: Cubic.
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 立方。
- en: Our example for this section, [threesum.py](threesum.py.html), is *cubic* —
    its running time has order of growth *n*³ — because it has three nested `for`
    loops, to process all triples of *n* elements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本节的示例[threesum.py](threesum.py.html)是*立方*的——其运行时间增长阶数为*n*³——因为它有三个嵌套的`for`循环，用于处理所有*n*个元素的三元组。
- en: Exponential.
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数。
- en: As discussed in Section 2.3, both [towersofhanoi.py](../23recursion/towersofhanoi.py.html)
    and [beckett.py](../23recursion//beckett.py.html) have running times proportional
    to 2^(*n*) because they process all subsets of *n* elements. Generally, we use
    the term *exponential* to refer to algorithms whose order of growth is *b^n* for
    any constant *b* > 1, even though different values of *b* lead to vastly different
    running times. Exponential algorithms are extremely slow — you should never run
    one of them for a large problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2.3节所讨论的，[hanoi塔.py](../23recursion/towersofhanoi.py.html)和[beckett.py](../23recursion//beckett.py.html)的运行时间与2^(*n*)成正比，因为它们处理所有*n*个元素的所有子集。通常，我们使用术语*指数*来指代增长阶数为*b^n*的算法，其中*b*
    > 1为任意常数，尽管不同的*b*值会导致截然不同的运行时间。指数算法非常慢——你不应该为大问题运行其中之一。
- en: '* * *'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Python Lists and Arrays
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python列表和数组
- en: 'Python''s built-in `list` data type represents a mutable sequence of objects.
    We have been using Python lists throughout the book — recall that we use Python
    lists as arrays because they support the four core array operations: creation,
    indexed access, indexed assignment, and iteration. However, Python lists are more
    general than arrays because you can also insert items into and delete items from
    Python lists. Even though Python programmers typically do not distinguish between
    lists and arrays, many other programmers do make such a distinction. For example,
    in many programming languages, arrays are of fixed length and do not support insertions
    or deletions. Indeed, all of the array-processing code that we have considered
    in this book so far could have been done using fixed-length arrays.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置的`list`数据类型表示可变对象序列。我们在整本书中一直在使用Python列表 —— 回想一下，我们将Python列表用作数组，因为它们支持四个核心数组操作：创建、索引访问、索引赋值和迭代。但是，Python列表比数组更通用，因为您还可以向Python列表中插入项目和删除项目。尽管Python程序员通常不区分列表和数组，但许多其他程序员确实会区分。例如，在许多编程语言中，数组长度固定，不支持插入或删除。事实上，到目前为止，我们在本书中考虑的所有数组处理代码都可以使用固定长度数组完成。
- en: The table below gives the most commonly used operations for Python lists.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了Python列表中最常用的操作。
- en: '![List API](../Images/aa9a6363a30a8caa5335226fe16810f7.png)'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![列表API](../Images/aa9a6363a30a8caa5335226fe16810f7.png)'
- en: 'We have deferred this API to this section because programmers who use Python
    lists without paying attention to the cost are in for trouble. For example, consider
    these two code snippets:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此API推迟到本节，因为不注意成本而使用Python列表的程序员将会遇到麻烦。例如，考虑以下两个代码片段：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The one on the left takes quadratic time; the one on the right takes linear
    time. To understand why Python list operations have the performance characteristics
    that they do, you need to learn more about Python's resizing array representation
    of lists, which we discuss next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的操作需要二次时间；右侧的操作需要线性时间。要理解为什么Python列表操作具有这样的性能特征，您需要了解更多关于Python列表的调整大小数组表示，我们将在下面讨论。
- en: Resizing arrays.
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整大小的数组。
- en: 'A resizing array is a data structure that stores a sequence of items (not necessarily
    fixed in length), which can be accessed by indexing. To implement a resizing array
    (at the machine level), Python uses a fixed-length array (allocated as one contiguous
    block of memory) to store the item references. The array is divided into two logical
    parts: the first part of the array contains the items in the sequence; the second
    part of the array is unused and reserved for subsequent insertions. Thus, we can
    append or remove items from the end in constant time, using the reserved space.
    We use the term *size* to refer to the number of items in the data structure and
    the term *capacity* to refer to the length of the underlying array.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调整大小的数组是一种数据结构，用于存储一个序列的项目（长度不一定固定），可以通过索引访问。为了在机器级别实现调整大小的数组，Python使用一个固定长度的数组（作为一块连续的内存块分配）来存储项目引用。数组被分为两个逻辑部分：数组的第一部分包含序列中的项目；数组的第二部分未使用，保留用于后续插入。因此，我们可以在常数时间内从末尾附加或删除项目，使用保留的空间。我们使用术语*size*来指代数据结构中项目的数量，术语*capacity*指代底层数组的长度。
- en: The main challenge is ensuring that the data structure has sufficient capacity
    to hold all of the items, but is not so large as to waste an excessive amount
    of memory. Achieving these two goals turns out to be remarkably easy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主要挑战在于确保数据结构具有足够的容量来容纳所有项目，但又不会过大以浪费过多内存。实现这两个目标事实上非常容易。
- en: First, if we want to append an item to the end of a resizing array, we check
    its capacity. If there is room, we simply insert the new item at the end. If not,
    we *double* its capacity by creating a new array of twice the length and copying
    the items from the old array into the new array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果��们想要将项目附加到调整大小的数组的末尾，我们会检查其容量。如果有空间，我们只需将新项目插入到末尾。如果没有，我们通过创建两倍长度的新数组并将项目从旧数组复制到新数组来*加倍*其容量。
- en: '![Resizing array data struture to represent a Python list](../Images/8149721b12cf28bea508dcc29ad91886.png)'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![调整大小的数组数据结构表示Python列表](../Images/8149721b12cf28bea508dcc29ad91886.png)'
- en: Similarly, if we want to remove an item from the end of the resizing array,
    we check its capacity. If it is excessively large, we *halve* its capacity by
    creating a new array of half the length and copying the items from the old array
    into the new array. An appropriate test is to check whether the size of the resizing
    array is less than one-fourth of its capacity. That way, after the capacity is
    halved, the resizing array is about half full and can accommodate a substantial
    number of insertions before we have to change its capacity again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们想要从调整大小的数组的末尾删除项目，我们会检查其容量。如果它过大，我们通过创建一半长度的新数组并将项目从旧数组复制到新数组来*减半*其容量。一个适当的测试是检查调整大小的数组的大小是否小于其容量的四分之一。这样，在容量减半后，调整大小的数组大约半满，并且可以容纳大量插入，然后我们必须再次更改其容量。
- en: The doubling-and-halving strategy guarantees that the resizing array remains
    between 25% and 100% full, so that space is linear in the number of items. The
    specific strategy is not sacrosanct. For example, typical Python implementations
    expand the capacity by a factor of 9/8 (instead of 2) when the resizing array
    is full. This wastes less space (but triggers more expansion and shrinking operations).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 加倍和减半策略保证调整大小的数组始终保持在25%到100%之间，因此空间与项目数量成线性关系。具体的策略并非神圣不可侵犯。例如，典型的Python实现在调整大小的数组已满时将容量扩大9/8倍（而不是2倍）。这样浪费的空间更少（但会触发更多的扩展和收缩操作）。
- en: Amortized analysis.
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摊销分析。
- en: We can prove that the cost of doubling and halving is always absorbed (to within
    a constant factor) in the cost of other Python list operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以证明加倍和减半的成本总是被其他Python列表操作的成本吸收（在一个常数因子内）。
- en: Starting from an empty Python list, any sequence of *n* operations labeled as
    "constant time" in the list API table shown above takes time linear in *n*. In
    other words, the total cost of any such sequence of Python list operations divided
    by the number of operations is bounded by a constant. This kind of analysis is
    known as *amortized analysis*. This guarantee is not as strong as saying that
    each operation is constant-time, but it has the same implications in many applications
    (for example, when our primary interest is in total running time).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从空Python列表开始，标记为列表API表中“常数时间”的*n*个操作序列需要与*n*���线性时间。换句话说，任何这种Python列表操作序列的总成本除以操作数都受到常数的限制。这种分析称为*摊销分析*。这种保证不像说每个操作都是常数时间那样强，但在许多应用中具有相同的含义（例如，当我们的主要兴趣是总运行时间时）。
- en: 'For the special case where we perform a sequence of *n* insertions into an
    empty resizing array, the idea is simple: each insertion takes constant time to
    add the item; each insertion that triggers a resizing (when the current size is
    a power of 2) takes additional time proportional to *n* to copy the elements from
    the old array of length *n* to a new array of length 2*n*. Thus, assuming *n*
    is a power of 2 for simplicity, the total cost is proportional to'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在空调整大小数组中执行*n*个插入的特殊情况，这个想法很简单：每次插入都需要恒定时间添加项目；每次触发调整大小的插入（当当前大小是2的幂时）需要额外的时间与*n*成比例，将长度为*n*的旧数组的元素复制到长度为2*n*的新数组中。因此，假设*n*是2的幂以简化，总成本与*n*成比例
- en: '| (1 + 1 + 1 + ... + 1) + (1 + 2 + 4 + 8 + ... + *n*) ~ 3*n* |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (1 + 1 + 1 + ... + 1) + (1 + 2 + 4 + 8 + ... + *n*) ~ 3*n* |'
- en: The first term (which sums to *n*) accounts for the *n* insertion operations;
    the second term (which sums to 2*n* - 1) accounts for the lg *n* resizing operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项（总和为*n*）代表*n*个插入操作；第二项（总和为2*n* - 1）代表lg *n*调整大小操作。
- en: Understanding resizing arrays is important in Python programming. For example,
    it explains why creating a Python list of *n* items by repeatedly appending items
    to the end takes time proportional to *n* (and why creating a list of *n* items
    by repeatedly prepending items to the front takes time proportional to *n*²).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python编程中理解调整大小的数组是很重要的。例如，它解释了为什么通过重复将项目附加到末尾来创建一个包含*n*个项目的Python列表需要与*n*成比例的时间（以及为什么通过重复将项目前置到前面来创建一个包含*n*个项目的列表需要与*n*²成比例的时间）。
- en: '* * *'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Strings
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Python''s string data type has some similarity to Python lists, with one very
    important exception: *strings are immutable*. For example, you might think that
    you could capitalize a string s having the value `''hello''` with `s[0] = ''H''`,
    but that will result in this run-time error:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python的字符串数据类型与Python列表有一些相似之处，但有一个非常重要的例外：*字符串是不可变的*。例如，你可能认为可以通过`s[0] = 'H'`来将值为`'hello'`的字符串`s`大写，但这将导致运行时错误：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want `'Hello'`, you need to create a completely new string. This difference
    reinforces the idea of immutability and has significant implications with regard
    to performance, which we now examine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要`'Hello'`，你需要创建一个全新的字符串。这种差异强调了不可变性的概念，并且对性能有重大影响，现在我们来详细研究。
- en: Internal representation.
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部表示。
- en: '![A Python string](../Images/f1eca1ab19e025c05e6330cb82be7cba.png) First, Python
    uses a much simpler internal right for strings than for lists/arrays, as detailed
    in the diagram at right. Specifically, a string object contains two pieces of
    information:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个Python字符串](../Images/f1eca1ab19e025c05e6330cb82be7cba.png) 首先，Python对字符串使用比对列表/数组更简单的内部表示，如右侧图表中详细说明的那样。具体来说，一个字符串对象包含两个信息：'
- en: A reference to a place in memory where the characters in the string are stored
    contiguously
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串中字符存储在内存中的连续位置的引用
- en: The length of the string
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的长度
- en: '![An array of one-character strings](../Images/0f682cbd1df37b4d1fa01bca13356b83.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![一个由单个字符字符串组成的数组](../Images/0f682cbd1df37b4d1fa01bca13356b83.png)'
- en: By contrast, consider the diagram at left, which is an array of one-character
    strings. We will consider a more detailed analysis later in this section, but
    you can see that the string representation is certainly significantly simpler.
    It uses much less space per character and provides faster access to each character.
    In many applications, these characteristics are very important because strings
    can be very long. So, it is important both that the memory usage be not much more
    than is required for the characters themselves and that characters can be quickly
    accessed by their index, as in an array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，考虑左侧的图表，这是一个由单个字符字符串组成的数组。我们将在本节稍后进行更详细的分析，但您可以看到字符串表示肯定更简单。它每个字符使用的空间要少得多，并且提供更快的访问速度。在许多应用中，这些特性非常重要，因为字符串可能非常长。因此，重要的是内存使用量不要比字符本身所需的多太多，并且可以通过索引快速访问每个字符，就像在数组中一样。
- en: Performance.
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能。
- en: '![String concatenation](../Images/3601a7d860fa519bd0c77ed5767435ac.png) As
    for arrays, indexed access and computing the length of strings are constant-time
    operations. It is clear from the API at the beginning of Section 3.1 that most
    other operations take linear time as a function of the length of the input string
    or strings, because they refer to a *copy* of the string. In particular, *concatenating
    a character to a string takes linear time* and *concatenating two strings takes
    time proportional to the length of the result*. An example is shown at right.
    With respect to performance, this is the most significant difference between strings
    and lists/arrays: Python does not have resizable strings, because strings are
    immutable.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![字符串连接](../Images/3601a7d860fa519bd0c77ed5767435ac.png) 对于数组，索引访问和计算字符串长度都是常数时间操作。从第3.1节开头的API可以清楚地看出，大多数其他操作都随着输入字符串的长度而线性增长，因为它们引用了字符串的*副本*。特别是，*将字符连接到字符串需要线性时间*，*将两个字符串连接需要与结果长度成比例的时间*。右侧显示了一个示例。就性能而言，这是字符串和列表/数组之间最重要的区别：Python没有可调整大小的字符串，因为字符串是不可变的。'
- en: Example.
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例。
- en: 'Not understanding the performance of string concatenation often leads to performance
    bugs. The most common performance bug is building up a long string one character
    at a time. For example, consider the following code fragment to create a new string
    whose characters are in reverse order of the characters in a string `s`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不理解字符串连接的性能常常会导致性能错误。最常见的性能错误是逐个字符构建一个长字符串。例如，考虑以下代码片段，用于创建一个新字符串，其字符顺序与字符串`s`中的字符相反：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: During iteration *i* of the `for` loop, the string concatenation operator produces
    a string of length *i*+1\. Thus, the overall running time is proportional to 1
    + 2 + ... + *n* ~ *n*² / 2\. That is, the code fragment takes *quadratic* time
    as a function of the string length *n*
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的第*i*次迭代中，字符串连接运算符产生长度为*i*+1的字符串。因此，整体运行时间与1 + 2 + ... + *n*成比例 ~ *n*²
    / 2。也就是说，代码片段随着字符串长度*n*的增加而花费*二次*时间。
- en: '* * *'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Memory
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: 'As with running time, a program''s memory usage connects directly to the physical
    world: a substantial amount of your computer''s circuitry enables your program
    to store values and later retrieve them. The more values you need to store at
    any given instant, the more circuitry you need. To pay attention to the cost,
    you need to be aware of memory usage.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行时间一样，程序的内存使用直接与物理世界相连：你计算机的大量电路使得程序能够存储值并稍后检索它们。你需要存储的值越多，你就需要更多的电路。要注意成本，你需要了解内存使用情况。
- en: Python does not define the sizes of the built-in data types that we have been
    using (`int`, `float`, `bool`, `str`, and `list`); the sizes of objects of those
    types differ from system to system. Accordingly, the sizes of data types that
    you create also will differ from system to system because they are based on these
    built-in data types. The function call `sys.getsizeof(x)` returns the number of
    bytes that a built-in object `x` consumes on your system. The numbers that we
    give in this section are observations gathered by using this function in interactive
    Python on one typical system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有定义我们一直在使用的内置数据类型（`int`、`float`、`bool`、`str`和`list`）的大小；这些类型的对象的大小因系统而异。因此，你创建的数据类型的大小也会因系统而异，因为它们基���这些内置数据类型。函数调用`sys.getsizeof(x)`返回在你的系统上内置对象`x`消耗的字节数。本节中给出的数字是通过在一个典型系统上使用这个函数进行观察得到的。
- en: Integers.
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数。
- en: To represent an `int` object whose value is in the range (-2^(63) to 2^(63)-1),
    Python uses 16 bytes for overhead and 8 bytes (that is, 64 bits) for the numeric
    value. Python switches to a different internal representation for integers outside
    this range, which consumes memory proportional to the number of digits in the
    integer, as in the case with strings (see below).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个值在(-2^(63)到2^(63)-1)范围内的`int`对象，Python使用16字节的开销和8字节（即64位）的数值。对于超出此范围的整数，Python会切换到不同的内部表示，这会消耗与整数中数字位数成比例的内存，就像字符串的情况一样（见下文）。
- en: Floats.
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数。
- en: To represent a `float` object, Python uses 16 bytes for overhead and 8 bytes
    for the numeric value (that is, the mantissa, exponent, and sign), no matter what
    value the object has. So a float object always consumes 24 bytes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个`float`对象，Python使用16字节的开销和8字节的数值（即尾数、指数和符号），无论对象的值是多少。因此，一个float对象总是占用24字节。
- en: Booleans.
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值。
- en: In principle, Python could represent a boolean value using a single bit of computer
    memory. In practice, Python represents boolean values as integers. Specifically,
    Python uses 24 bytes to represent the `bool` object `True` and 24 bytes to represent
    the `bool` object `False`. That is a factor of 192 higher than the minimum amount
    needed! However, this wastefulness is partially mitigated because Python "caches"
    the two boolean objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，Python可以使用一个计算机内存位来表示一个布尔值。实际上，Python将布尔值表示为整数。具体来说，Python使用24字节来表示`bool`对象`True`，使用24字节来表示`bool`对象`False`。这比最小所需量高出192倍！然而，这种浪费在一定程度上得到缓解，因为Python“缓存”这两个布尔对象。
- en: Caching.
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存。
- en: To save memory, Python creates only one copy of objects with certain values.
    For example, Python creates only one `bool` object with value true and only one
    with value false. That is, every boolean variables holds a reference to one of
    these two objects. This caching technique is possible because the `bool` data
    type is immutable. On typical systems, Python also caches small `int` values (between
    -5 and 256), as they are the ones that programmers use most often. Python does
    not typically cache `float` objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省内存，Python仅创建具有特定值的对象的一个副本。例如，Python只创建一个值为true的`bool`对象，只创建一个值为false的`bool`对象。也就是说，每个布尔变量都持有对这两个对象中的一个的引用。这种缓存技术是可能的，因为`bool`数据类型是不可变的。在典型系统上，Python还会缓存小的`int`值（-5到256之间），因为程序员经常使用它们。Python通常不会缓存`float`对象。
- en: Strings.
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串。
- en: To represent a `str` object, Python uses 40 bytes for overhead (including the
    string length), plus one byte for each character of the string. So, for example,
    Python represents the string `'abc'` using 40 + 3 = 43 bytes and represents the
    string `'abcdefghijklmnopqr'` using 40 + 18 = 58 bytes. Python typically caches
    only string literals and one-character strings. ![Memory usage for [0.3, 0.6,
    0.1]](../Images/9e88210747cb6b511bfad4975e154568.png)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个`str`对象，Python使用40字节的开销（包括字符串长度），加上每个字符的一个字节。因此，例如，Python使用40 + 3 = 43字节表示字符串`'abc'`，使用40
    + 18 = 58字节表示字符串`'abcdefghijklmnopqr'`。Python通常只缓存字符串字面值和单字符字符串。![内存使用情况为[0.3,
    0.6, 0.1]](../Images/9e88210747cb6b511bfad4975e154568.png)
- en: Arrays (Python lists).
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组（Python列表）。
- en: To represent an array, Python uses 72 bytes for overhead (including the array
    length) plus 8 bytes for each object reference (one for each element in the array).
    So, for example, the Python representation of the array [0.3, 0.6, 0.1] uses 72
    + 8*3 = 96 bytes. This does not include the memory for the objects that the array
    references, so the total memory consumption for the array [0.3, 0.6, 0.1] is 96
    + 3*24 = 168 bytes. In general, the memory consumption for an array of *n* integers
    or floats is 72 + 32*n* bytes. This total is likely to be an underestimate, because
    the resizing array data structure that Python uses to implement arrays may consume
    an additional *n* bytes in reserved space. ![Memory usage for a two-dimensional
    array](../Images/f32232ddca85808a7d5ca2b726d62a82.png)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python用于表示数组时，每个对象引用使用72字节的开销（包括数组长度）加上每个对象引用8字节（数组中的每个元素一个）。因此，例如，数组[0.3, 0.6,
    0.1]的Python表示使用72 + 8*3 = 96字节。这不包括数组引用的对象的内存，因此数组[0.3, 0.6, 0.1]的总内存消耗为96 + 3*24
    = 168字节。一般来说，包含*n*个整数或浮点数的数组的内存消耗为72 + 32*n*字节。这个总数可能是一个低估，因为Python用于实现数组的调整大小数组数据结构可能会消耗额外的*n*字节的保留空间。![二维数组的内存使用情况](../Images/f32232ddca85808a7d5ca2b726d62a82.png)
- en: Two-dimensional arrays and arrays of objects.
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二维数组和对象数组。
- en: 'A two-dimensional array is an array of arrays, so we can calculate the memory
    consumption of a two-dimensional array with *m* rows and *n* columns from the
    information in the previous paragraph. Each row is an array that consumes 72 +
    32*n* bytes, so the total is 72 (overhead) plus 8*m* (references to the rows)
    plus *m*(72 + 32*n*) (memory for the *m* rows) bytes, for a grand total of 72
    + 80*m* + 32*mn* bytes. The same logic works for an array of any type of object:
    if an object uses *x* bytes, an array of *m* such objects consumes a total of
    72 + *m*(*x*+8) bytes. Again, this is likely to be a slight underestimate because
    of the resizing array data structure Python uses to represent arrays. *Note*:
    Python''s `sys.getsizeof(x)` is not much help in these calculations because it
    does not calculate the memory for the objects themselves — it returns 72 + 8*m*
    for any array of length *m* (or any two-dimensional array with *m* rows). ![Memory
    usage for a Charge object](../Images/684b42a9d8a199de06851a9565cfdbcd.png)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组是数组的数组，因此我们可以根据上一段中的信息计算具有*m*行和*n*列的二维数组的内存消耗。每行是一个消耗72 + 32*n*字节的数组，因此总共是72（开销）加上8*m*（对行的引用）加上*m*(72
    + 32*n*)（对*m*行的内存）字节，总共是72 + 80*m* + 32*mn*字节。相同的逻辑适用于任何类型对象的数组：如果一个对象使用*x*字节，那么*m*个这样的对象的数组总共消耗72
    + *m*(*x*+8)字节。同样，这可能是一个轻微的低估，因为Python用于表示数组的调整大小数组数据结构。*注意*：Python的`sys.getsizeof(x)`在这些计算中并没有太大帮助，因为它不计算对象本身的内存——对于长度为*m*的任何数组（或具有*m*行的任何二维数组），它返回72
    + 8*m*。![Charge对象的内存使用情况](../Images/684b42a9d8a199de06851a9565cfdbcd.png)
- en: Objects.
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象。
- en: 'A key question for Python programming is the following: How much memory is
    required to represent a user-defined object? The answer to this question may surprise
    you, but is important to know: *hundreds of bytes, at least*. Specifically, Python
    uses 72 bytes of overhead *plus* 280 bytes for a dictionary that binds instance
    variables to objects (we will discuss dictionaries in Section 4.4) plus 24 bytes
    for a reference to each instance variable plus memory for the instance variables
    themselves. For example, to represent a `Charge` object, Python uses at least
    72 + 280 = 352 bytes for overhead, 8 * 3 = 24 bytes to store the object references
    for the three instance variables, 24 bytes to store the `float` object referenced
    by the `_rx` instance variable, 24 bytes to store the `float` object referenced
    by the `_ry` instance variable, and 24 bytes to store the `float` object referenced
    by the `_q` instance variable, for a grand total of (at least) 448 bytes. The
    total might be even higher on your system, because some implementations consume
    even more overhead.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python编程的一个关键问题是：表示用户定义对象需要多少内存？这个问题的答��可能会让您感到惊讶，但了解这一点很重要：*至少几百字节*。具体来说，Python使用72字节的开销*加上*280字节用于将实例变量绑定到对象的字典（我们将在第4.4节讨论字典）*加上*24字节用于每个实例变量的引用，再加上实例变量本身的内存。例如，为了表示一个`Charge`对象，Python至少使用72
    + 280 = 352字节的开销，8 * 3 = 24字节来存储三个实例变量的对象引用，24字节来存储由`_rx`实例变量引用的`float`对象，24字节来存储由`_ry`实例变量引用的`float`对象，以及24字节来存储由`_q`实例变量引用的`float`对象，总共（至少）448字节。在您的系统上，总数可能会更高，因为一些实现会消耗更多的开销。
- en: It is important for every Python programmer to understand that each object of
    a user-defined type is likely to consume a large amount of memory. So, a Python
    program that defines a large number of objects of a user-defined type can use
    much more space (and time) than you might expect. Numerous object-oriented languages
    have come and gone since the concept was introduced decades ago, and many of them
    eventually embraced *lightweight* objects for user-defined types. Python offers
    two advanced features for this purpose — *named tuples* and *slots* — but we will
    not take advantage of such memory optimizations in this booksite.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个Python程序员来说，理解用户定义类型的每个对象可能会消耗大量内存是很重要的。因此，一个定义大量用户定义类型对象的Python程序可能会使用比您预期的更多的空间（和时间）。自几十年前引入该概念以来，许多面向对象的语言已经出现并消失，其中许多最终采用了*轻量级*对象来表示用户定义类型。Python为此提供了两个高级功能——*命名元组*和*槽*——但我们在本书中不会利用这些内存优化。
- en: '* * *'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: '**Q.** The text notes that operations on very large integers can consume more
    than constant time. Can you be more precise?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 文本指出，对非常大的整数进行操作可能会消耗超过常数时间。您能更精确地说明吗？'
- en: '**A.** Not really. The definition of "very large" is system dependent. For
    most practical purposes, you can consider operations applied to 32- or 64-bit
    integers to work in constant time. Modern applications in cryptography involve
    huge numbers with hundreds or thousands of digits.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 并非如此。"非常大"的定义取决于系统。对于大多数实际目的，您可以认为应用于32位或64位整数的操作在常数时间内运行。现代密码学应用涉及具有数百或数千位数的巨大数字。'
- en: '**Q.** How do I find out how long it takes to add or multiply two floats on
    my computer?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何找出在我的计算机上将两个浮点数相加或相乘需要多长时间？'
- en: '**A.** Run some experiments! The program [timeops.py](timeops.py.html) uses
    `Stopwatch`, as defined in [stopwatch.py](../32class/stopwatch.py.html) from Section
    3.2, to test the execution time of various arithmetic operations on integers and
    floats. This technique measures the actual elapsed time as would be observed on
    a wall clock. If your system is not running many other applications, it can produce
    accurate results. Python also includes the `timeit` module for measuring the running
    time of small code fragments.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 进行一些实验！程序[timeops.py](timeops.py.html)使用`Stopwatch`，如在第3.2节中定义的[stopwatch.py](../32class/stopwatch.py.html)，来测试整数和浮点数的各种算术运算的执行时间。这种技术测量的是实际经过的时间，就像在挂钟上观察到的一样。如果您的系统没有运行许多其他应用程序，它可以产生准确的结果。Python还包括用于测量小代码片段运行时间的`timeit`模块。'
- en: '**Q.** Is there any way to measure processor time instead of wall clock time?'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 有没有办法测量处理器时间而不是挂钟时间？'
- en: '**A.** On some systems, the function call `time.clock()` returns the current
    processor time as a float, expressed in seconds. When available, you should substitute
    `time.time()` with `time.clock()` for benchmarking Python programs.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在某些系统上，函数调用`time.clock()`返回当前处理器时间作为浮点数，以秒为单位表示。如果可用，您应该用`time.clock()`替换`time.time()`来对Python程序进行基准测试。'
- en: '**Q.** How much time do functions such as `math.sqrt()`, `math.log()`, and
    `math.sin()` take?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 函数如`math.sqrt()`、`math.log()`和`math.sin()`��要多少时间？'
- en: '**A.** Run some experiments! Stopwatch, as defined in [stopwatch.py](../32class/stopwatch.py.html)
    makes it easy to compose programs such as [timeops.py](timeops.py.html) to answer
    questions of this sort for yourself. You will be able to use your computer much
    more effectively if you get in the habit of doing so.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 进行一些实验！如在[stopwatch.py](../32class/stopwatch.py.html)中定义的Stopwatch，使得很容易组合程序，比如[timeops.py](timeops.py.html)来自己回答这类问题。如果养成这样做的习惯，您将能够更有效地使用计算机。'
- en: '**Q.** Why does allocating an array (Python list) of size *n* take time proportional
    to *n*?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么分配大小为*n*的数组（Python列表）需要与*n*成正比的时间？'
- en: '**A.** Python initializes all array elements to whatever values the programmer
    specifies. That is, in Python there is no way to allocate memory for an array
    without also assigning an object reference to each element of the array. Assigning
    object references to each element of an array of size *n* takes time proportional
    to *n*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python将所有数组元素初始化为程序员指定的值。也就是说，在Python中，没有办法为数组分配内存而不为数组的每个元素分配对象引用。为大小为*n*的数组的每个元素分配对象引用需要与*n*成正比的时间。'
- en: '**Q.** How do I find out how much memory is available for my Python programs?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何找出我的Python程序可用的内存量？'
- en: '**A.** Since Python will raise a `MemoryError` when it runs out of memory,
    it is not difficult to run some experiments. For example, use [bigarray.py](bigarray.py.html).
    Run it like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 由于Python在内存耗尽时会引发`MemoryError`，因此运行一些实验并不困难。例如，使用[bigarray.py](bigarray.py.html)。像这样运行它：'
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: to show that you have room for 100 million integers. But if you type
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以显示您有100百万个整数的空间。但如果您键入
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Python will hang, crash, or raise a run-time error; you can conclude that you
    do not have room for an array of 1 billion integers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python将挂起、崩溃或引发运行时错误；您可以得出结论，您没有足够的空间来存储10亿个整数的数组。
- en: '**Q.** What does it mean when someone says that the worst-case running time
    of an algorithm is *O*(*n*²)?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 当有人说算法的最坏情况运行时间是*O*(*n*²)时，这意味着什么？'
- en: '**A.** That is an example of a notation known as *big-O* notation. We write
    *f*(*n*) is *O*(*g*(*n*)) if there exist constants *c* and *n*[0] such that *f*(*n*)
    ≤ *c* *g*(*n*) for all *n* > *n*[0]. In other words, the function *f*(*n*) is
    bounded above by *g*(*n*), up to constant factors and for sufficiently large values
    of *n*. For example, the function 30*n*² + 10*n* + 7 is *O*(*n*²).We say that
    the worst-case running time of an algorithm is *O*(*g*(*n*)) if the running time
    as a function of the input size *n* is *O*(*g*(*n*)) for all possible inputs.
    This notation is widely used by theoretical computer scientists to prove theorems
    about algorithms, so you are sure to see it if you take a course in algorithms
    and data structures. It provides a worst-case performance guarantee.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 那是一种称为*大O*表示法的记法示例。我们写*f*(*n*)是*O*(*g*(*n*))，如果存在常数*c*和*n*[0]，使得对于所有*n*
    > *n*[0]，*f*(*n*) ≤ *c* *g*(*n*)。换句话说，函数*f*(*n*)在常数因子和足够大的*n*值下被*g*(*n*)上界约束。例如，函数30*n*²
    + 10*n* + 7是*O*(*n*²)。我们说算法的最坏情况运行时间是*O*(*g*(*n*))，如果作为输入大小*n*的函数运行时间对于所有可能的输入都是*O*(*g*(*n*))。这种记法被理论计算机科学家广泛用于证明关于算法的定理，因此如果您学习算法和数据结构课程，您肯定会看到它。它提供了最坏情况性能保证。'
- en: '**Q.** So can I use the fact that the worst-case running time of an algorithm
    is *O*(*n*³) or *O*(*n*²) to predict performance?'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 那么我可以利用算法的最坏情况运行时间为*O*(*n*³)或*O*(*n*²)来预测性能吗？'
- en: '**A.** No, because the actual running time might be much less. For example,
    the function 30*n*² + 10*n* + 7 is *O*(*n*²), but it is also *O*(*n*³) and *O*(*n*^(10))
    because big-O notation provides only an upper bound on the worst-case running
    time. Moreover, even if there is some family of inputs for which the running time
    is proportional to the given function, perhaps these inputs are not encountered
    in practice. Consequently, you cannot use big-O notation to predict performance.
    The tilde notation and order-of-growth classifications that we use are more precise
    than big-O notation because they provide matching upper and lower bounds on the
    growth of the function. Many programmers incorrectly use big-O notation to indicate
    matching upper and lower bounds.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不，因为实际运行时间可能要少得多。例如，函数30*n*² + 10*n* + 7是*O*(*n*²)，但它也是*O*(*n*³)和*O*(*n*^(10))，因为大O符号只提供最坏情况下运行时间的上限。此外，即使有一些输入族，其运行时间与给定函数成正比，也许这些输入在实践中并不常见。因此，你不能使用大O符号来预测性能。我们使用的波浪符号和增长顺序分类比大O符号更精确，因为它们提供了函数增长的匹配上限和下限。许多程序员错误地使用大O符号来表示匹配的上限和下限。'
- en: '**Q.** How much memory does Python typically use to store a tuple of *n* items?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python通常使用多少内存来存储包含 *n* 个项目的元组？'
- en: '**A.** 56 + 8*n* bytes, plus whatever memory is needed for the objects themselves.
    This is a bit less than for arrays because Python can implement a tuple (at the
    machine level) using an array instead of a resizing array.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 56 + 8*n* 字节，再加上对象本身所需的内存。这比数组少一点，因为Python可以使用数组而不是调整大小的数组来实现元组（在机器级别）。'
- en: '**Q.** Why does Python use so much memory (280 bytes) to store a dictionary
    that maps an object''s instance variables to its values?'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么Python要使用这么多内存（280字节）来存储一个将对象的实例变量映射到其值的字典？'
- en: '**A.** In principle, different objects from the same data type can have different
    instance variables. In this case, Python would need some way to manage an arbitrary
    number of possible instance variables for each object. But most Python code does
    not call for this (and, as a matter of style, we never need it in this booksite).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 原则上，同一数据类型的不同对象可以有不同的实例变量。在这种情况下，Python需要一种方式来管理每个对象的可能实例变量的任意数量。但大多数Python代码不需要这样做（而且，作为一种风格，我们在这本书中从未需要过）。'
- en: '* * *'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Modify [threesum.py](threesum.py.html) to take a command-line argument `x` and
    find a triple of numbers on standard input whose sum is closest to `x`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[threesum.py](threesum.py.html)以接受一个名为 `x` 的命令行参数，并在标准输入中找到三个数字的组合，使它们的和最接近
    `x`。
- en: Compose a program `foursum.py` that takes an integer `n` from standard input,
    then reads `n` integers from standard input, and counts the number of 4-tuples
    that sum to zero. Use a quadruple loop. What is the order of growth of the running
    time of your program? Estimate the largest `n` that your program can handle in
    an hour. Then, run your program to validate your hypothesis.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序`foursum.py`，从标准输入中获取一个整数 `n`，然后从标准输入中读取 `n` 个整数，并计算总和为零的4元组的数量。使用四重循环。你的程序的运行时间增长的顺序是多少？估计你的程序在一个小时内能处理的最大
    `n` 是多少。然后，运行你的程序验证你的假设。
- en: Prove that 1 + 2 + ... + *n* = *n*(*n*+1)/2.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明1 + 2 + ... + *n* = *n*(*n*+1)/2。
- en: '*Solution*: We proved this by induction at the beginning of Section 2.3\. Here
    is the basis for another proof:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解答*：我们在第2.3节开始时通过归纳证明了这一点。以下是另一种证明的基础：'
- en: '[PRE5]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prove by induction that the number of distinct triples of integers between 0
    and *n*-1 is *n*(*n*-1)(*n*-2)/6.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过归纳证明，在0到 *n*-1 之间的不同三元组的数量是 *n*(*n*-1)(*n*-2)/6。
- en: '*Solution*: The formula is correct for *n* = 2\. For *n* > 2, count all the
    triples that do not include *n*-1, which is (*n*-1)(*n*-2)(*n*-3)/6 by the inductive
    hypothesis, and all the triples that do include *n*-1, which is (*n*-1)(*n*-2)/2,
    to get the total'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解答*：对于 *n* = 2，该公式是正确的。对于 *n* > 2，计算所有不包含 *n*-1 的三元组，根据归纳假设为(*n*-1)(*n*-2)(*n*-3)/6，以及包含
    *n*-1 的所有三元组，为(*n*-1)(*n*-2)/2，得到总数'
- en: '| (*n*-1)(*n*-2)(*n*-3)/6 + (*n*-1)(*n*-2)/2 = *n*(*n*-1)(*n*-2)/6 |'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (*n*-1)(*n*-2)(*n*-3)/6 + (*n*-1)(*n*-2)/2 = *n*(*n*-1)(*n*-2)/6 |'
- en: Show by approximating with integrals that the number of distinct triples of
    integers between 0 and *n*-1 is about *n*³/6.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用积分近似显示，在0到 *n*-1 之间的不同三元组的数量约为 *n*³/6。
- en: '![Integrals](../Images/5ed3101072467ee6e7356d1e76ab2b89.png)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![积分](../Images/5ed3101072467ee6e7356d1e76ab2b89.png)'
- en: What is the value of `x` (as a function of *n*) after running the following
    code fragment?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码片段后，`x` 的值（作为 *n* 的函数）是多少？
- en: '[PRE6]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Solution*: *n*(*n*-1)(*n*-2)/6.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解答*：*n*(*n*-1)(*n*-2)/6。'
- en: 'Use tilde notation to simplify each of the following formulas, and give the
    order of growth of each:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用波浪符号简化以下每个公式，并给出每个的增长顺序：
- en: '*n*(*n* - 1)(*n* - 2)(*n* - 3) / 24'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*(*n* - 1)(*n* - 2)(*n* - 3) / 24'
- en: (*n* - 2) (lg *n* - 2) (lg *n* + 2)
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*n* - 2) (lg *n* - 2) (lg *n* + 2)
- en: '*n*(*n* + 1) - *n*²'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*(*n* + 1) - *n*²'
- en: '*n*(*n* + 1)/2 + *n* lg *n*'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*(*n* + 1)/2 + *n* lg *n*'
- en: ln((*n* - 1)(*n* - 2) (*n* - 3))²
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ln((*n* - 1)(*n* - 2) (*n* - 3))²
- en: Is the following code fragment linear, quadratic, or cubic (as a function of
    *n*)?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段是线性的、二次的还是立方的（作为 *n* 的函数）？
- en: '[PRE7]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Suppose the running time of an algorithm on inputs of size 1000, 2000, 3000,
    and 4000 is 5 seconds, 20 seconds, 45 seconds, and 80 seconds, respectively. Estimate
    how long it will take to solve a problem of size 5000\. Is the algorithm linear,
    linearithmic, quadratic, cubic, or exponential?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设算法在大小为1000、2000、3000和4000的输入上的运行时间分别为5秒、20秒、45秒和80秒。估计解决大小为5000的问题需要多长时间。该算法是线性的、线性对数的、二次的、立方的还是指数的？
- en: 'Which would you prefer: a quadratic, linearithmic, or linear algorithm?'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你更喜欢哪种算法：二次的、线性对数的还是线性的？
- en: '*Solution*: While it is tempting to make a quick decision based on the order
    of growth, it is very easy to be misled by doing so. You need to have some idea
    of the problem size and of the relative value of the leading coefficients of the
    running time. For example, suppose that the running times are *n*² seconds, 100
    *n* log[2] *n* seconds, and 10,000 *n* seconds. The quadratic algorithm will be
    fastest for *n* up to about 1000, and the linear algorithm will never be faster
    than the linearithmic one (*n* would have to be greater than 2^(100), far too
    large to bother considering).'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：尽管根据增长顺序做出快速决定很诱人，但这样做很容易被误导。你需要对问题规模和运行时间的主导系数的相对值有一些了解。例如，假设运行时间为*n*²秒，100
    *n* log[2] *n*秒，和10,000 *n*秒。对于*n*最多约为1000时，二次算法将是最快的，而线性算法永远不会比线性对数算法更快（*n*必须大于2^(100)，远远太大了，不值得考虑）。'
- en: Apply the scientific method to develop and validate a hypothesis about order
    of growth of the running time of the following code fragment, as a function of
    the input argument `n`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运用科学方法来开发和验证关于以下代码片段的运行时间增长顺序的假设，作为输入参数`n`的函数。
- en: '[PRE8]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Apply the scientific method to develop and validate a hypothesis about order
    of growth of the running time of each of the following two code fragments as a
    function of `n`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运用科学方法来开发和验证关于以下两个代码片段的运行时间增长顺序的假��，作为`n`的函数。
- en: '[PRE9]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Solution*: On many systems, the first is linear; the second is quadratic.
    You have no way of knowing why: In the first case, Python detects that *s* is
    the only variable that refers to the string, so it appends each character to the
    string as it would with a list (in amortized constant time) even though the string
    is immutable! A safer alternative is to create a list containing the characters
    and concatenate them together with by calling the `join()` method.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：在许多系统上，第一个是线性的；第二个是二次的。你无法知道原因：在第一种情况下，Python检测到*s*是唯一引用字符串的变量，因此它会将每个字符附加到字符串上，就像对列表一样（在摊销常数时间内），即使字符串是不可变的！一个更安全的替代方法是创建一个包含字符的列表，并通过调用`join()`方法将它们连接在一起。'
- en: '[PRE11]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each of the four Python functions below returns a string of length `n` whose
    characters are all `x`. Determine the order of growth of the running time of each
    function. Recall that concatenating two strings in Python takes time proportional
    to the sum of their lengths.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的四个Python函数中的每个函数返回一个长度为`n`且所有字符都是`x`的字符串。确定每个函数的运行时间的增长顺序。回想一下，在Python中连接两个字符串的时间与它们长度的和成正比。
- en: '[PRE12]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following code fragment (adapted from a Java programming book) creates a
    random permutation of the integers from 0 to *n*-1\. Determine the order of growth
    of its running time as a function of *n*. Compare its order of growth with the
    shuffling code in Section 1.4.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段（改编自一本Java编程书籍）创建了从0到*n*-1的整数的随机排列。确定其运行时间的增长顺序作为*n*的函数。将其增长顺序与第1.4节中的洗牌代码进行比较。
- en: '[PRE17]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How many times does the following code fragment execute the first `if` statement
    in the triply nested loop?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段中的第一个`if`语句在三重嵌套循环中执行多少次？
- en: '[PRE18]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Use tilde notation to simply your answer.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用波浪符号表示简化你的答案。
- en: 'Apply the scientific method to develop and validate a hypothesis about order
    of growth of the running time of the `collect()` method in [coupon.py](../21function/coupon.py.html)
    (from Section 2.1), as a function of the argument `n`. *Note*: Doubling is not
    effective for distinguishing between the linear and linearithmic hypotheses —
    you might try squaring the size of the input.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运用科学方法来开发和验证关于[coupon.py](../21function/coupon.py.html)（来自第2.1节）中`collect()`方法运行时间增长顺序的假设，作为参数`n`的函数。*注意*：加倍对于区分线性和线性对数假设并不有效
    — 你可以尝试将输入大小的平方。
- en: Apply the scientific method to develop and validate a hypothesis about order
    of growth of the running time of [markov.py](../16pagerank/markov.py.html) (from
    Section 1.6), as a function of the arguments `moves` and `n`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运用科学方法来开发和验证关于[markov.py](../16pagerank/markov.py.html)（来自第1.6节）运行时间增长顺序的假设，作为`moves`和`n`参数的函数。
- en: Compose a program `mooreslaw.py` that takes a command-line argument *n* and
    writes the increase in processor speed over a decade if processor speed doubles
    every *n* months. How much will processor speed increase over the next decade
    if speeds double every *n* = 15 months? 24 months?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`mooreslaw.py`的程序，该程序接受一个命令行参数*n*，并在处理器速度每*n*个月翻倍时，写入处理器速度在十年内的增长量。如果速度每*n*
    = 15个月翻倍，处理器速度在接下来的十年内将增加多少？24个月呢？
- en: 'Using the memory model from the text, give the memory requirements for each
    object of the following data types from Chapter 3:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本中的内存模型，给出第3章中以下数据类型的每个对象的内存需求：
- en: '`Stopwatch`'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`秒表`'
- en: '`Turtle`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`乌龟`'
- en: '`Vector`'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`向量`'
- en: '`Body`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主体`'
- en: '`Universe`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`宇宙`'
- en: 'Estimate, as a function of the grid size *n*, the amount of space used by [visualizev.py](../24percolation/visualizev.py.html)
    (from Section 2.4) with the vertical percolation detection. *Extra credit*: Answer
    the same question for the case where the recursive percolation detection method
    in [percolation.py](../24percolation/percolation.py.html) is used.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计[visualizev.py](../24percolation/visualizev.py.html)（来自第2.4节）在垂直渗透检测下使用的空间量，作为网格大小*n*的函数。*额外学分*：回答当使用[percolation.py](../24percolation/percolation.py.html)中的递归渗透检测方法时相同的问题。
- en: Estimate the size of the largest *n*-by-*n* array of integers that your computer
    can hold, and then try to allocate such an array.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计你的计算机可以容纳的最大*n*乘以*n*的整数数组的大小，然后尝试分配这样的数组。
- en: Estimate, as a function of the number of documents *n* and the dimension *d*,
    the amount of space used by [comparedocuments.py](../33design/comparedocuments.py.html)
    (from Section 3.3).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计[comparedocuments.py](../33design/comparedocuments.py.html)（来自第3.3节）使用的空间量，作为文档数量*n*和维度*d*的函数。
- en: Compose a version of [primesieve.py](../14array/primesieve.py.html) (from Section
    1.4) that uses an array of integers instead of an array of booleans and uses 32
    bits in each integer, to raise the largest value of *n* that it can handle by
    a factor of 32.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following table gives running times for various programs for various values
    of *n*. Fill in the blanks with estimates that you think are reasonable on the
    basis of the information given.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| program | 1,000 | 10,000 | 100,000 | 1,000,000 |'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| A | 0.001 seconds | 0.012 seconds | 0.16 seconds | ? seconds |'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| B | 1 minute | 10 minutes | 1.7 hours | ? hours |'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| C | 1 second | 1.7 minutes | 2.8 hours | ? days |'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: Give hypotheses for the order of growth of the running time of each program.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Three-sum analysis**. Calculate the probability that no triple among *n*
    random 32-bit integers sums to 0, and give an approximate estimate for *n* equal
    to 1000, 2000, and 4000\. *Extra credit*: Give an approximate formula for the
    expected number of such triples (as a function of *n*), and run experiments to
    validate your estimate.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Closest pair**. Design a quadratic algorithm that finds the pair of integers
    that are closest to each other. (In the next section you will be asked to find
    a linearithmic algorithm.)'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Power law**. Show that a log-log plot of the function *cn^b* has slope *b*
    and *x*-intercept log *c*. What are the slope and *x*-intercept for 4 *n*³(log
    *n*)²?'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sum furthest from zero**. Design an algorithm that finds the pair of integers
    whose sum is furthest from zero. Can you discover a linear algorithm?'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The "beck" exploit**. A popular web server supports a function called `no2slash()`
    whose purpose is to collapse multiple `/` characters. For example, the string
    `/d1///d2////d3/test.html` becomes `/d1/d2/d3/test.html`. The original algorithm
    was to repeatedly search for a `/` and copy the remainder of the string:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, the running time of this code is quadratic in the number of `/`
    characters in the input. By sending multiple simultaneous requests with large
    numbers of `/` characters, a hacker can deluge a server and starve other processes
    for CPU time, thereby creating a denial-of-service attack. Develop a version of
    `no2slash()` that runs in linear time and does not allow for the this type of
    attack.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Young tableaux**. Suppose you have in memory an *n*-by-*n* grid of integers
    `a[][]` such that `a[i][j] < a[i+1][j]` and `a[i][j] < a[i][j+1]` for all `i`
    and `j`, like the table below.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Devise an algorithm whose order of growth is linear in *n* to determine whether
    a given integer *x* is in a given Young tableaux.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: Start at the upper-right corner. If the value is *x*, return `True`.
    Otherwise, go left if the value is greater than *x* and go down if the value is
    less than *x*. If you reach bottom left corner, then *x* is not in table. The
    algorithm is linear because you can go left at most *n* times and down at most
    *n* times.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Subset sum**. Compose a program `anysum.py` that takes an integer *n* from
    standard input, then reads *n* integers from standard input, and counts the number
    of subsets that sum to 0\. Give the order of growth of the running time of your
    program.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Array rotation**. Given an array of *n* elements, give a linear time algorithm
    to rotate the array *k* positions. That is, if the array contains *a*[0], *a*[1],
    ..., *a*[n-1], the rotated array is *a*[k], *a*[k+1], ..., *a*[*n*-1], *a*[0],
    ..., *a*[*k*-1]. Use at most a constant amount of extra space (array indices and
    array values). *Hint*: Reverse three subarrays.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finding a duplicated integer**. (a) Given an array of *n* integers from 1
    to *n* with one value repeated twice and one missing, give an algorithm that finds
    the missing integer, in linear time and constant extra space. (b) Given a read-only
    array of *n* integers, where each value from 1 to *n*-1 occurs once and one occurs
    twice, give an algorithm that finds the duplicated value, in linear time and constant
    extra space. (c) Given a read-only array of *n* integers with values between 1
    and *n*-1, give an algorithm that finds a duplicated value, in linear time and
    constant extra space.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找重复整数**。 (a) 给定一个从1到*n*的*n*个整数数组，其中一个值重复两次，一个缺失，给出一个在线性时间和常数额外空间内找到缺失整数的算法。
    (b) 给定一个只读的*n*个整数数组，其中每个值从1到*n*-1出现一次，一个出现两次，给出一个在线性时间和常数额外空间内找到重复值的算法。 (c) 给定一个只读的*n*个整数数组，值介于1和*n*-1之间，给出一个在线性时间和常数额外空间内找到重复值的算法。'
- en: '**Factorial**. Design a fast algorithm to compute *n*! for large values of
    *n*. Use your program to compute the longest run of consecutive 9s in 1000000!.
    Develop and validate a hypothesis for the order of growth of the running time
    of your algorithm.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阶乘**。设计一个快速算法来计算大值*n*!。使用你的程序计算1000000!中连续9的最长运行时间。为你的算法的运行时间增长顺序开发并验证一个假设。'
- en: '**Maximum sum**. Design a linear algorithm that finds a contiguous subsequence
    of at most *m* in a sequence of *n* integers that has the highest sum among all
    such subsequences. Implement your algorithm, and confirm that the order of growth
    of its running time is linear.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大和**。设计一个线性算法，在*n*个整数序列中找到最多*m*个元素的连续子序列，其和最大。实现你的算法，并确认其运行时间的增长顺序为线性。'
- en: '**Pattern matching**. Given an *n*-by-*n* array of black (1) and white (0)
    pixels, design a linear algorithm that finds the largest square subarray that
    consists of entirely black pixels. As an example, the following 8-by-8 array contains
    a 3-by-3 subarray entirely of black pixels.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式匹配**。给定一个由黑色（1）和白色（0）像素组成的*n*×*n*数组，设计一个线性算法，找到完全由黑色像素组成的最大正方形子数组。例如，以下8×8数组包含一个完全由黑色像素组成的3×3子数组。'
- en: '[PRE21]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement your algorithm and confirm that the order of growth of its running
    time is linear in the number of pixels. *Extra credit*: Design an algorithm to
    find the largest *rectangular* black subarray.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现你的算法，并确认其运行时间的增长顺序与像素数量成线性关系。*额外加分*：设计一个算法来找到最大的*矩形*黑色子数组。
- en: '**Maximum average**. Compose a program that finds a contiguous subarray of
    at most *m* elements in an array of *n* integers that has the highest average
    value among all such subarrays, by trying all subarrays. Use the scientific method
    to confirm that the order of growth of the running time of your program is *mn*².
    Next, compose a program that solves the problem by first computing `prefix[i]
    = a[0] + ... + a[i]` for each `i`, then computing the average in the interval
    from `a[i]` to `a[j]` with the expression `(prefix[j] - prefix[i]) / (j - i +
    1)`. Use the scientific method to confirm that this method reduces the order of
    growth by a factor of *n*.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大平均值**。编写一个程序，在*n*个整数数组中找到最多*m*个元素的连续子数组，其平均值最高，通过尝试所有子数组。使用科学方法确认你的程序的运行时间增长顺序为*mn*²。接下来，编写一个程序，通过首先计算`prefix[i]
    = a[0] + ... + a[i]`，然后使用表达式`(prefix[j] - prefix[i]) / (j - i + 1)`计算从`a[i]`到`a[j]`的区间的平均值。使用科学方法确认这种方法将运行时间的增长顺序减少了一个*n*的因子。'
- en: '**Sub-exponential function**. Find a function whose order-of-growth is slower
    than any polynomial function, but faster than any exponential function. *Extra
    credit*: Compose a program whose running time has that order of growth.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**次指数函数**。找到一个比任何多项式函数慢但比任何指数函数快的函数。*额外加分*：编写一个具有该增长顺序的运行时间的程序。'
- en: '**Resizing arrays**. For each of the following strategies, either show that
    each resizing array operation takes constant amortized time or find a sequence
    of *n* operations (starting from an empty data structure) that takes quadratic
    time.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整数组**。对于以下每种策略，要么证明每个调整数组操作的摊销时间为常数，要么找到一系列*n*个操作（从空数据结构开始），其时间为二次方。'
- en: Double the capacity of the resizing array when it is full and halve the capacity
    when it is half full.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调整数组满时，将容量加倍；当数组半满时，将容量减半。
- en: Double the capacity of the resizing array when it is full and halve the capacity
    when it is one-third full.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调整数组满时，将容量加倍；当数组三分之一满时，将容量减半。
- en: Increase the capacity of the resizing array by a factor of 9/8 when it is full
    and decrease it by a factor of 9/8 when it is 80% full.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调整数组满时，将容量增加9/8倍；当数组80%满时，将容量减少9/8倍。
