- en: 1.3 Conditionals and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/python/13flow](https://introcs.cs.princeton.edu/python/13flow)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We use the term *flow of control* to refer to the sequence of statements that
    are executed in a program. All of the programs that we have examined to this point
    have a simple flow of control: the statements are executed one after the other
    in the order given. Most programs have a more complicated structure where statements
    may or may not be executed depending on certain conditions (conditionals), or
    where groups of statements are executed multiple times (loops).'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` Statements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most computations require different actions for different inputs. Program [flip.py](flip.py.html)
    uses an `if-else` statement to write the results of a coin flip. The table below
    summarizes some typical situations where you might need to use an `if` or `if-else`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f51e4db5ceecc56fde8dcd25cf84c8b3.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'Note that in Python indentation is meaningful. For example, consider these
    two code fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If `x` is greater than or equal to 0, then both fragments write 'not negative'.
    If `x` is less than 0, then the code on the left writes 'negative' but the code
    on the right writes nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` Statements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many computations are inherently repetitive. The `while` statement enables us
    to perform a group of statements many times. This enables us to express lengthy
    computations without composing lots of code. The program [tenhellos.py](tenhellos.py.html)
    writes "Hello, World" ten times. The program [powersoftwo.py](powersoftwo.py.html)
    accepts a command-line argument `n` and writes all of the powers of 2 less than
    or equal to `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, in Python we can abbreviate an assignment statement of the form
    `i = i + 1` with the shorthand notation `i += 1`. The same notation works for
    other binary operators, including `-`, `*`, and `/`. For example, most programmers
    would use `power *= 2` instead of `power = 2 * power` in [powersoftwo.py](powersoftwo.py.html).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` Statements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many loops follow the same basic scheme: initialize an index variable to some
    value and then use a `while` loop to test an exit condition involving the index
    variable, using the last statement in the `while` loop to modify the index variable.
    Python''s `for` statement is a direct way to express such loops. For example,
    the following two lines of code are equivalent to the corresponding lines of code
    in [tenhellos.py](tenhellos.py.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If `range()` has only one argument, then the start value of the range value
    defaults to 0\. For example, the following `for` loop is an improvement over the
    `while` loop in [powersoftwo.py](powersoftwo.py.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The table below summarizes some typical situations where you might need to use
    a `while` or `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd8b2b031c978e54be6cfc496356b506.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can nest `if`, `while`, or `for` statements within other `if`, `while`, or
    `for` statements. As an example, [divisorpattern.py](divisorpattern.py.html) has
    a `for` loop whose nested statements are a `for` loop (whose nested statement
    is an `if` statement) and a `stdio.writeln()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a second example of nesting, consider a tax preparation program that contains
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Python allows an `if` statement to contain `elif` ("else if") clauses. Using
    `elif` clauses yields this more compact code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to program with conditionals and loops immediately opens up the
    world of computation to us.
  prefs: []
  type: TYPE_NORMAL
- en: '![Harmonic](../Images/c329a5897240fe0865ffe53495e7a07d.png)'
  prefs: []
  type: TYPE_IMG
- en: Finite sum.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The computational paradigm used by [powersoftwo.py](powersoftwo.py.html) is
    one that you will use frequently. It uses two variables — one as an index that
    controls a loop and the other to accumulate a computational result. The program
    [harmonic.py](harmonic.py.html) uses the same paradigm to evaluate the finite
    sum *H[n]* = 1 + 1/2 + 1/3 + ... + 1/*n*. These numbers are known as the *harmonic
    numbers*. ![Newton](../Images/3bc40f709ee47cd5d1e1ff59c1cc8f97.png)
  prefs: []
  type: TYPE_NORMAL
- en: Computing the square root.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How is the `math.sqrt()` function implemented? The program [sqrt.py](sqrt.py.html)
    illustrates one technique. It uses a special case of a general computational technique
    that was developed by Isaac Newton and Joseph Raphson and is widely known as *Newton's
    method*. To compute the square root of a positive number *t*, start with the estimate
    *t* = *c*. If *t* is equal to *c* / *t*, then *t* is equal to the square root
    of *c*, so the computation is complete. If not, refine the estimate by replacing
    *t* with the average of *t* and *c* / *t*. Each time we perform this update, we
    get closer to the desired answer.
  prefs: []
  type: TYPE_NORMAL
- en: Number conversion.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The program [binary.py](binary.py.html) writes the binary (base 2) representation
    of the decimal number typed as the command line argument. It is based on decomposing
    the number into a sum of powers of two. For example, the binary representation
    of 106 is 1101010, which is the same as saying that 106 = 64 + 32 + 8 + 2, or
    in binary, 1101010 = 1000000 + 100000 + 1000 + 10\. To compute the binary representation
    of *n*, we consider the powers of 2 less than or equal to *n* in decreasing order
    to determine which belong in the binary decomposition (and therefore correspond
    to a 1 bit in the binary representation). ![Gambler](../Images/22f356a25c42e820e30695409eb60d0a.png)
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo simulation.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next example is representative of a widely used class of programs, where
    we use computers to simulate what might happen in the real world, so that we can
    make informed decisions in all kinds of complicated situations. Suppose a gambler
    makes a series of fair $1 bets, starting with $50, and continue to play until
    she either goes broke or has $250\. What are the chances that she will go home
    with $250, and how many bets might she expect to make before winning or losing?
    Program [gambler.py](gambler.py.html) is a simulation that can help answer these
    questions. It accepts three command-line arguments, the initial stake ($50), the
    goal amount ($250), and the number of times we want to simulate the game.
  prefs: []
  type: TYPE_NORMAL
- en: Factoring.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *prime* is an integer greater than 1 whose only positive divisors are 1 and
    itself. The prime factorization of an integer is the multiset of primes whose
    product is the integer. For example, 3757208 = 2*2*2*7*13*13*397\. The [factors.py](factors.py.html)
    program computes the prime factorization of any given positive integer. We can
    stop looking for factors when `factor`*`factor` is greater than `n` because if
    an integer `n` has a factor, it has one less than or equal to the square root
    of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Loop and a Half
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want a loop that repeatedly does the following: execute some sequence
    of statements, exit the loop if some loop-termination condition is satisfied,
    and execute some other sequence of statements. That is, we want to position the
    loop-control condition in the middle of the loop, not at the beginning. This is
    known as a *loop and a half* because you must go partway through the loop before
    reaching the loop-termination test. Python provides the `break` statement for
    this purpose. When Python executes a `break` statement, it immediately exits the
    (innermost) loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Break](../Images/0834bd43d8f17c079a099c8dba4b6172.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, consider the problem of generating a point that is randomly distributed
    in the unit disk. Since we always want to generate at least one point, we compose
    a `while` loop whose loop-continuation condition is always satisfied, generate
    the random point (*x*, *y*) in the 2-by-2 square, and use a `break` statement
    to terminate the loop if (*x*, *y*) is in the unit disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** What is the difference between `=` and `==`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** We repeat this question here to remind you that you should not use `=`
    when you really mean `==` in a conditional expression. The statement `x = y` assigns
    `y` to `x`, whereas the expression `x == y` tests whether the two variables currently
    are equal. In some programming languages, this difference can wreak havoc in a
    program and be difficult to detect. In Python, assignment statements are not expressions.
    For example, if we were to make the mistake of typing `cash = goal` instead of
    `cash == goal` in [gambler.py](gambler.py.html), the compiler would find the bug
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Q.** What happens if I leave out the colon in an `if`, `while`, or `for`
    statement?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Python raises a `SyntaxError` at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What are the rules for indenting statement blocks?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Each statement in a block must have the same indentation; if it does
    not, Python will raise an `IndentationError` at compile time. Python programmers
    commonly use a four-space indentation scheme, which we follow throughout this
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Should I use tab characters to indent my code?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No, you should avoid placing tab characters in your `.py` files. Many
    editors, however, offer the option of automatically placing a sequence of spaces
    into your program when you type the <Tab> key; it''s appropriate to use that option
    when composing Python programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I spread a long statement over multiple lines?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but some care is needed because of the way Python treats indentation.
    If the expression that spans multiple lines is enclosed inside parentheses (or
    square brackets or curly braces), then there is no need to do anything special.
    For example, this is a single statement that is spread over three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, if there is no implied line continuation, you must use the backslash
    character at the end of each line to be continued.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Q.** Suppose I want to skip over some of code in a loop in some cases, or
    suppose that I want the body of a conditional statement to be empty, so that no
    statement is executed. Does Python have language support for such things?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, Python provides the `continue` and `pass` statements, respectively,
    for these conditions. However, situations in which they are really necessary are
    rare, and we do not use them in this booksite. Also, there is no `switch` statement
    in Python (for mutually exclusive alternatives), though one is commonly found
    in other languages, and no `goto` statement (for unstructured control flow).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I use a non-boolean expression in an `if` or `while` statement?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but this is probably not a good idea. Expressions that evaluate
    to zero or the empty string are considered `False`; all other numeric and string
    expressions are considered `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Are there cases where I must use a `for` statement but not a `while`
    statement, or vice versa?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** You can use a `while` statement to implement any kind of loop, but,
    as defined here, you can use a `for` statement only for the kind of loop that
    iterates over a finite sequence of integers. Later (Sections 1.4, 3.3, and 4.4),
    we will consider other ways to use the `for` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I use the built-in `range()` function to create a sequence of integers
    with a step size of some value other than 1?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, `range()` supports an optional third argument step, which defaults
    to 1\. That is, `range(start, stop, step)` produces the sequence of integers `start`,
    `start` + `step`, `start` + 2 * `step`, and so forth. If `step` is a positive
    integer, the sequence continues as long as `start` + i * `step` is less than `stop`;
    if `step` is a negative integer, the sequence continues as long as `start` + i
    * step is greater than `stop`. For example, `range(0, -100, -1)` returns the integer
    sequence 0, -1, -2, ..., -99.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I use floats as arguments to `range()`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No, all arguments must be integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I change the loop-index variable within a `for` loop?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but it will not affect the sequence of integers produced by `range()`.
    For example, the following loop writes the 100 integers from 0 to 99:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Q.** In a `for` loop, what is the value of the loop-control variable after
    the loop terminates?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** It is the last value of the loop-control variable during the loop. Upon
    termination of the for loop above, `i` refers to the integer 109\. Using the loop-control
    variable after the termination of a for loop is generally considered poor style,
    so we do not do so in any of our programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** My program is stuck in an infinite loop. How do I stop it?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Type `Ctrl-c`. That is, hold down the key labeled `Ctrl` or `control`
    and press the `c` key. For Windows Command Prompt type `Ctrl-z`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Is there an example for when the following `for` and `while` loops are
    not equivalent?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**A.** Yes. Hint: Use a `continue` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compose a program that takes three integer command-line arguments and writes
    `'equal'` if all three are equal, and `'not equal'` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a more general and robust version of [quadratic.py](../12types/quadratic.py.html)
    (from Section 1.2) that writes the roots of the polynomial *ax²*bx + *c*, writes
    an appropriate error message if the discriminant is negative, and behaves appropriately
    (avoiding division by zero) if *a* is zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a code fragment that takes two float command-line arguments, and writes
    `True` if both are strictly between 0 and 1 and `False` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improve your solution to the "wind chill" exercise from Section 1.2 by adding
    code to check that the values of the command-line arguments fall within the ranges
    of validity of the formula, and also adding code to write an error message if
    that is not the case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the value of `j` after each of the following code fragments is executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Redesign [tenhellos.py](tenhellos.py.html) to compose a program that accepts
    the number of lines to write as a command-line argument. You may assume that the
    argument is less than 1000\. *Hint*: consider using `i % 10` and `i % 100` to
    determine whether to use `st`, `nd`, `rd`, or `th` for writing the `i`th Hello.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a program that, using one `for` loop and one `if` statement, writes
    the integers from 1000 (inclusive) to 2000 (exclusive) with five integers per
    line. *Hint*: use the `%` operator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [fiveperline.py](fiveperline.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generalizing the "uniform random numbers" exercise from Section 1.2, compose
    a program that accepts an integer `n` as a command-line argument, uses `random.random()`
    to write `n` uniform random numbers between 0 and 1, and then writes their average
    value, their minimum value, and their maximum value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe what happens when you invoke [rulern.py](rulern.py.html) with an argument
    that is too large. For example, try executing the command `python rulern 100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that writes a table of the values of log *n*, *n*, *n* log
    *n*, *n*², and *n*³ for *n* = 2, 4, 8, 16, 32, 64, 128\. Use tabs (`'\t'` characters)
    to line up columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [functiongrowth.py](functiongrowth.py.html).'
  prefs: []
  type: TYPE_NORMAL
- en: What are `m` and `n` after the following code is executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: Run the program [digitreverser.py](digitreverser.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does this code write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: Run the program [fibonacci.py](fibonacci.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a program that takes a command-line argument `n` and writes all the
    positive powers of 2 less than or equal to `n`. Make sure that your program works
    properly for all values of `n`. (Your program should write nothing if `n` is negative
    or zero.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand your solution to the "Continuously compounded interest" exercise from
    Secction 1.2 to write a table giving the total amount paid and the remaining principal
    after each monthly payment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a version of divisorpattern.py that uses `while` loops instead of `for`
    loops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike the harmonic numbers, the sum 1/1² + 1/2² + ... + 1/*n*² does converge
    to a constant as *n* grows to infinity. (Indeed, the constant is π²/6, so this
    formula can be used to estimate the value of π.) Which of the following `for`
    loops computes this sum? Assume that `n` is the integer 1000000 and `total` is
    a float initialized to 0.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Show that [sqrt.py](sqrt.py.html) implements Newton''s method for finding the
    square root of *c*. *Hint*: Use the fact that the slope of the tangent to a (differentiable)
    function *f*(*x*) at *x* = *t* is *f*''(*t*) to find the equation of the tangent
    line and then use that equation to find the point where the tangent line intersects
    the *x*-axis to show that you can use Newton''s method to find a root of any function
    as follows: at each iteration, replace the estimate *t* by *t* - *f*(*t*) / *f''*(*t*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using Newton''s method, develop a program that takes integers n and k as command-line
    arguments and writes the kth root of n (*Hint*: See the previous exercise.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [binary.py](binary.py.html) to create a program that takes `i` and `k`
    as command-line arguments and converts `i` to base `k`. Assume that `k` is an
    integer between 2 and 16\. For bases greater than 10, use the letters `A` through
    `F` to represent the 11th through 16th digits, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program named that accepts a positive integer command-line argument
    `n`, places the binary representation of `n` into a string, and then writes the
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [binary2.py](binary2.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a version of [gambler.py](gambler.py.html) that uses two nested `while`
    loops or two nested `for` loops instead of a `while` loop inside a `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that traces a gambler's ruin simulation by writing a line after
    each bet that has one asterisk corresponding to each dollar held by the gambler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [gambler.py](gambler.py.html) to take an extra command-line argument
    that specifies the (fixed) probability that the gambler wins each bet. Use your
    program to try to learn how this probability affects the chance of winning and
    the expected number of bets. Try a value of *p* close to 0.5 (say, 0.48).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify [gambler.py](gambler.py.html) to take an extra command-line argument
    that specifies the number of bets the gambler is willing to make, so that there
    are three possible ways for the game to end: the gambler wins, loses, or runs
    out of time. Add to the output to give the expected amount of money the gambler
    will have when the game ends. *Extra credit*: Use your program to plan your next
    trip to Monte Carlo.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [factors.py](factors.py.html) to write just one copy of each of the prime
    divisors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run quick experiments to determine the impact of using the termination condition
    `factor <= n` instead of `factor*factor <= n` in [factors.py](factors.py.html).
    For each method, find the largest *n* such that when you type in an *n* digit
    number, the program is sure to finish within 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes one integer command-line argument `n` and writes
    a two dimensional `n`-by-`n` checker board pattern with alternating spaces and
    asterisks, like the following 4-by-4 pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: 'Compose a program that accepts two integers `x` and `y` from the command-line,
    and finds and writes the greatest common divisor (gcd) of `x` and `y` using *Euclid''s
    algorithm*, which is an iterative computation based on the following observation:
    if `x > y`, then if `y` divides `x`, the gcd of `x` and `y` is `y`; otherwise
    the gcd of `x` and `y` is the same as the gcd of `x % y` and `y`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes one command-line argument `n` and writes an `n`-by-`n`
    table such that there is an `*` in row `i` and column `j` if the gcd of `i` and
    `j` is 1 (`i` and `j` are relatively prime), and a space in that position otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that generates a point that is randomly distributed in the
    unit disk, but without using a `break` statement. Compare your solution to the
    one given at the end of this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a program that writes the coordinates of a random point (*a*, *b*,
    *c*) on the surface of a unit sphere. To generate such a point, use *Marsaglia''s
    method*: Start by picking a random point (*x*, *y*) in the unit disk using the
    method described at the end of this section. Then, set *a* to 2 x sqrt(1 - *x*²
    - *y*²), *b* to 2 y sqrt(1 - *x*² - *y*²), and *c* to 1 - 2 (*x*² + *y*²).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Ramanujan''s taxi.** S. Ramanujan was an Indian mathematician who became
    famous for his intuition for numbers. When the English mathematician G. H. Hardy
    came to visit him in the hospital one day, Hardy remarked that the number of his
    taxi was 1729, a rather dull number. To which Ramanujan replied, "No, Hardy! No,
    Hardy! It is a very interesting number. It is the smallest number expressible
    as the sum of two cubes in two different ways." Verify this claim by composing
    a program that takes a command line argument `n` and writes all integers less
    than or equal to `n` that can be expressed as the sum of two cubes in two different
    ways. In other words, find distinct positive integers *a*, *b*, *c*, and *d* such
    that *a*³ + *b*³ = *c*³ + *d*³. Use four nested `for` loops.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [ramanujanwhile.py](ramanujanwhile.py.html) and [ramanujanfor.py](ramanujanfor.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the license plate 87539319 seems like a rather dull number. Determine why
    it's not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Checksums.** The International Standard Book Number ([ISBN](http://mathworld.wolfram.com/ISBN.html))
    is a 10 digit code that uniquely specifies a book. The rightmost digit is a *checksum*
    digit which can be uniquely determined from the other 9 digits from the condition
    that 10*d*[10] + 9*d*[9] + ... + 2*d*[2] + *d*[1] must be a multiple of 11 (here
    *d[i]* denotes the *i*th digit from the right). The checksum digit *d*[1] can
    be any value from 0 to 10: the ISBN convention is to use the value ''X'' to denote
    10\. *Example*: the checksum digit corresponding to 020131452 is 5 since is the
    only value of *d*[1] between 0 and and 10 for which 10*0 + 9*2 + 8*0 + 7*1 + 6*3
    + 5*1 + 4*4 + 3*5 + 2*2 + *d*[1] is a multiple of 11\. Compose a program that
    takes a 9-digit integer as a command-line argument, computes the checksum, and
    writes the 10-digit ISBN number. It''s OK if the program doesn''t write any leading
    0''s.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [isbn.py](isbn.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Counting primes.** Compose a program that takes a command-line argument `n`
    and writes the number of primes less than `n`. Use it to write the number of primes
    less than 10 million. *Note:* if you are not careful to make your program efficient,
    it may not finish in a reasonable amount of time. Later in Section 1.4, you will
    learn about a more efficient way to perform this computation called the *Sieve
    of Eratosthenes*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**2D random walk.** A two dimensional [random walk](http://en.wikipedia.org/wiki/Random_walk)
    simulates the behavior of a particle moving in a grid of points. At each step,
    the random walker moves north, south, east, or west with probability 1/4, independently
    of previous moves. Compose a program that takes a command-line argument `n` and
    estimates how long it will take a random walker to hit the boundary of a 2`n`+1-by-2`n`+1
    square centered at the starting point.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Median-of-5.** Compose a program that takes five distinct integers from the
    command line and writes the median value (the value such that two of the other
    integers are smaller and two are larger). *Extra credit*: Solve the problem with
    a program that compares values fewer than seven times for any given input.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exponential function.** Assume that `x` is a float. Compose a code fragment
    that uses the Taylor series expansion to assign *e*^x = 1 + *x* + *x*²/2! + *x*³/3!
    + ... to `total`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: The purpose of this exercise is to get you to think about how a
    library function like `math.exp()` might be implemented in terms of elementary
    operators. Try solving it, then compare your solution with the one developed here.
    We start by considering the problem of computing one term. Suppose that `x` is
    a float and `n` is an integer. The following code assigns *x*^(*n*) / *n*! to
    `term` using the direct method of having one loop for the numerator and another
    loop for the denominator, then dividing the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A better approach is to use just a single for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Besides being more compact and elegant, the latter solution is preferable because
    it avoids inaccuracies caused by computing with huge numbers. For example, the
    two-loop approach breaks down for values like *x* = 10 and *n* = 100 because 100!
    is too large to represent accurately as a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute *e^x*, we nest this `for` loop within a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`while`'
  prefs: []
  type: TYPE_NORMAL
- en: '`total`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(term > 0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs: []
  type: TYPE_NORMAL
- en: '`while`'
  prefs: []
  type: TYPE_NORMAL
- en: '`while`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Experimental analysis.** Run experiments to determine the relative costs
    of `Math.exp()` and the following three methods from Exercise 2.3.36 for the problem
    of computing *e^x*: the direct method with nested loops, the improved method with
    a single loop, and the latter with the loop continuation condition `(term > 0)`.
    For each method, use trial-and-error with a command line argument to determine
    how many times your computer can perform the computation in 10 seconds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigometric functions.** Compose programs that compute sin *x* and cos *x*
    using the Taylor series expansions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sin *x* = *x* - *x*³/3! + *x*⁵/5! - *x*⁷/7! + ...
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: cos *x* = 1 - *x*²/2! + *x*⁴/4! - *x*⁶/6! + ...
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Partial solution*: See [sine.py](sine.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pepys''s problem.** In 1693 Samuel Pepys asked Isaac Newton which is more
    likely: getting 1 at least once when rolling a fair die six times or getting 1
    at least twice when rolling it 12 times. Compose a program that could have provided
    Newton with a quick answer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Game simulation.** In the 1970s game show *Let''s Make a Deal*, a contestant
    is presented with three doors. Behind one of them is a valuable prize. After the
    contestant chooses a door, the host opens one of the other two doors (never revealing
    the prize, of course). The contestant is then given the opportunity to switch
    to the other unopened door. Should the contestant do so? Intuitively, it might
    seem that the contestant''s initial choice door and the other unopened door are
    equally likely to contain the prize, so there would be no incentive to switch.
    Compose a program to test this intuition by simulation. Your program should take
    a command-line argument `n`, play the game `n` times using each of the two strategies
    (switch or do not switch), and write the chance of success for each of the two
    strategies. Or you can [play the game here](http://www.stat.sc.edu/~west/javahtml/LetsMakeaDeal.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [montehall.py](montehall.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Chaos.** Compose a program to study the following simple model for population
    growth, which might be applied to study fish in a pond, bacteria in a test tube,
    or any of a host of similar situations. We suppose that the population ranges
    from 0 (extinct) to 1 (maximum population that can be sustained). If the population
    at time *t* is *x*, then we suppose the population at time *t* + 1 to be *rx*(1-*x*),
    where the parameter *r*, known as the *fecundity parameter*, controls the rate
    of growth. Start with a small population — say, *x* = 0.01 — and study the result
    of iterating the model, for various values of *r*. For which values of *r* does
    the population stabilize at *x* = 1 - 1/*r* ? Can you say anything about the population
    when *r* is 3.5? 3.8? 5?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Biologists model population growth of fish in a pond using the [logistic equation](http://mathworld.wolfram.com/LogisticEquation.html).
    Investigate some of its chaotic behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Euler''s sum-of-powers conjecture**. In 1769 Leonhard Euler formulated a
    generalized version of Fermat''s Last Theorem, conjecturing that at least *n*
    *n*th powers of positive integers are needed to obtain a sum that is itself an
    *n*th power, for *n* > 2\. Compose a program to disprove Euler''s conjecture (which
    stood until 1967), using a quintuply nested loop to find four positive integers
    whose 5th powers sum to the 5th power of another positive integer. That is, find
    five integers *a*, *b*, *c*, *d*, and *e* such that *a*⁵ + *b*⁵ + *c*⁵ + *d*⁵
    = *e*⁵.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dragon curves.** This exercise is a generalization of the "dragon curves"
    exercise from Section 1.2\. Compose a program that takes an integer command-line
    argument `n` and writes the instructions for drawing a dragon curve of order `n`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [dragon2.py](dragon2.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
