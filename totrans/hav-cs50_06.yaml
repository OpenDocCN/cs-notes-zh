- en: Lecture 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/x/notes/4/](https://cs50.harvard.edu/x/notes/4/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pixel Art](#pixel-art)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hexadecimal](#hexadecimal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Memory](#memory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pointers](#pointers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Strings](#strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pointer Arithmetic](#pointer-arithmetic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[String Comparison](#string-comparison)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Copying and malloc](#copying-and-malloc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Valgrind](#valgrind)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Garbage Values](#garbage-values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pointer Fun with Binky](#pointer-fun-with-binky)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Swapping](#swapping)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overflow](#overflow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`scanf`](#scanf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[File I/O](#file-io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous weeks, we talked about images being made of smaller building blocks
    called pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we will go into further detail about the zeros and ones that make up
    these images. In particular, we will be going deeper into the fundamental building
    blocks that make up files, including images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we will discuss how to access the underlying data stored in computer
    memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we begin today, know that the concepts covered in this lecture may take some
    time to fully *click*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pixel Art
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pixels are squares, individual dots, of color that are arranged on an up-down,
    left-right grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can imagine an image as a map of bits, where zeros represent black and ones
    represent white.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Zeros and ones being converted to a black and white smiley](../Images/f057084f7f880f2232b58904e3baa906.png
    "smiley")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Hexadecimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*RGB*, or *red, green, blue*, are numbers that represent the amount of each
    of these colors. In Adobe Photoshop, you can see these settings as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A photoshop panel with RGB values and hexadecimal input](../Images/19913ea21e79de08a01f8182a6fedded.png
    "hex in photoshop")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice how the amount of red, blue, and green changes the color selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can see from the image above that color is not just represented by three
    values. At the bottom of the window, there is a special value made up of numbers
    and characters. `255` is represented as `FF`. Why might this be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hexadecimal* is a system of counting that has 16 counting values. They are
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `F` represents `15`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hexadecimal is also known as *base-16*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When counting in hexadecimal, each column is a power of 16.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `0` is represented as `00`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `1` is represented as `01`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `9` is represented by `09`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `10` is represented as `0A`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `15` is represented as `0F`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `16` is represented as `10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `255` is represented as `FF`, because 16 x 15 (or `F`) is 240\. Add
    15 more to make 255\. This is the highest number you can count using a two-digit
    hexadecimal system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexadecimal is useful because it can be represented using fewer digits. Hexadecimal
    allows us to represent information more succinctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In weeks past, you may recall our artist rendering of concurrent blocks of
    memory. Applying hexadecimal numbering to each of these blocks of memory, you
    can visualize these as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Blocks of memory numbered in hex](../Images/dc5b9fc550dd51fa9ba0c6cd6f1ef498.png
    "memory hex")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You can imagine how there may be confusion regarding whether the `10` block
    above may represent a location in memory or the value `10`. Accordingly, by convention,
    all hexadecimal numbers are often represented with the `0x` prefix as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![blocks of memory numbered in hex with 0x](../Images/d86587cf28e3a4a6da3611bfdac5087c.png
    "0x")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In your terminal window, type `code addresses.c` and write your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `n` is stored in memory with the value `50`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can visualize how this program stores this value as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![the value 50 stored in a memory location with hex](../Images/19305ae228aa9ae717c06b833be43320.png
    "hex")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C language has two powerful operators that relate to memory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can leverage this knowledge by modifying our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the `%p`, which allows us to view the address of a location in memory.
    `&n` can be literally translated as “the address of `n`.” Executing this code
    will return an address of memory beginning with `0x`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A *pointer* is a variable that stores the address of something. Most succinctly,
    a pointer is an address in your computer’s memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `p` is a pointer that contains the address of an integer `n`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code has the same effect as our previous code. We have simply
    leveraged our new knowledge of the `&` and `*` operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To illustrate the use of the `*` operator, consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `printf` line prints the integer at the location of `p`. `int
    *p` creates a pointer whose job is to store the memory address of an integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can visualize our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Same value of 50 in a memory location with a pointer value stored elsewhere](../Images/e4e35a1d8407d04af87bd12670b17b59.png
    "pointer")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice the pointer seems rather large. Indeed, a pointer is usually stored as
    an 8-byte value. `p` is storing the address of the `50`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can more accurately visualize a pointer as one address that points to another:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A pointer as an arrow, pointing from one location of memory to another](../Images/066c17edcfa4a065f34d4d1c54da36dd.png
    "pointer")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a mental model for pointers, we can peel back a level of simplification
    that was offered earlier in this course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that a string `s` is printed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recall that a string is simply an array of characters. For example, `string
    s = "HI!"` can be represented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The string HI with an exclamation point stored in memory](../Images/f4704464318b2965399a15b7958d7592.png
    "hi")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'However, what is `s` really? Where is the `s` stored in memory? As you can
    imagine, `s` needs to be stored somewhere. You can visualize the relationship
    of `s` to the string as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Same string HI with a pointer pointing to it](../Images/ce633d4820545eb569c481c76bea25cb.png
    "hi pointer")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice how a pointer called `s` tells the compiler where the first byte of the
    string exists in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the above prints the memory locations of each character in the string
    `s`. The `&` symbol is used to show the address of each element of the string.
    When running this code, notice that elements `0`, `1`, `2`, and `3` are next to
    one another in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Likewise, you can modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code will present the string that starts at the location of
    `s`. This code effectively removes the training wheels of the `string` data type
    offered by `cs50.h`. This is raw C code, without the scaffolding of the cs50 library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Taking off the training wheels, you can modify your code again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `cs50.h` is removed. A string is implemented as a `char *`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can imagine how a string, as a data type, is created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last week, we learned how to create your own data type as a struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cs50 library includes a struct as follows: `typedef char *string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This struct, when using the cs50 library, allows one to use a custom data type
    called `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pointer arithmetic is the ability to do math on locations of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can modify your code to print out each memory location in the string as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are printing each character at the location of `s`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Further, you can modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the first character at the location of `s` is printed. Then, the
    character at the location `s + 1` is printed, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Likewise, consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code prints the values stored at various memory locations starting
    with `s`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string of characters is simply an array of characters identified by the location
    of its first byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Earlier in the course, we considered the comparison of integers. We could represent
    this in code by typing `code compare.c` into the terminal window as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code takes two integers from the user and compares them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the case of strings, however, one cannot compare two strings using the `==`
    operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the `==` operator in an attempt to compare strings will attempt to
    compare the memory locations of the strings instead of the characters therein.
    Accordingly, we recommended the use of `strcmp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate this, modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Noticing that typing in `HI!` for both strings still results in the output of
    `Different`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Why are these strings seemingly different? You can use the following to visualize
    why:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![two strings stored separately in memory](../Images/757726f67e2fd90dee87875a3a01e9e1.png
    "two strings")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Therefore, the code for `compare.c` above is actually attempting to see if the
    memory addresses are different, not the strings themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `strcmp`, we can correct our code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `strcmp` can return `0` if the strings are the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To further illustrate how these two strings are living in two locations, modify
    your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we now have two separate strings stored, likely at two separate locations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see the locations of these two stored strings with a small modification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `%s` has been changed to `%p` in the print statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copying and malloc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common need in programming is to copy one string to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your terminal window, type `code copy.c` and write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `string t = s` copies the address of `s` to `t`. This does not accomplish
    what we are desiring. The string is not copied – only the address is. Further,
    notice the inclusion of `ctype.h`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can visualize the above code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![two pointers pointing at the same memory location with a string](../Images/5da43cb300cf307a4b80977679231415.png
    "two strings")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that `s` and `t` are still pointing at the same blocks of memory. This
    is not an authentic copy of a string. Instead, these are two pointers pointing
    at the same string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we address this challenge, it’s important to ensure that we don’t experience
    a *segmentation fault* through our code, where we attempt to copy `string s` to
    `string t`, where `string t` does not exist. We can employ the `strlen` function
    as follows to assist with that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `strlen` is used to make sure `string t` exists. If it does not,
    nothing will be copied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To be able to make an authentic copy of the string, we will need to introduce
    two new building blocks. First, `malloc` allows you, the programmer, to allocate
    a block of a specific size of memory. Second, `free` allows you to tell the compiler
    to *free up* that block of memory you previously allocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can modify our code to create an authentic copy of our string as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `malloc(strlen(s) + 1)` creates a block of memory that is the length
    of the string `s` plus one. This allows for the inclusion of the *null* `\0` character
    in our final copied string. Then, the `for` loop walks through the string `s`
    and assigns each value to that same location on the string `t`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It turns out that our code is inefficient. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `n = strlen(s)` is defined now in the left-hand side of the `for
    loop`. It’s best not to call unneeded functions in the middle condition of the
    `for` loop, as it will run over and over again. When moving `n = strlen(s)` to
    the left-hand side, the function `strlen` only runs once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `C` Language has a built-in function to copy strings called `strcpy`. It
    can be implemented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `strcpy` does the same work that our `for` loop previously did.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Both `get_string` and `malloc` return `NULL`, a special value in memory, in
    the event that something goes wrong. You can write code that can check for this
    `NULL` condition as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that if the string obtained is of length `0` or malloc fails, `NULL`
    is returned. Further, notice that `free` lets the computer know you are done with
    this block of memory you created via `malloc`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Valgrind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Valgrind* is a tool that can check to see if there are memory-related issues
    with your programs wherein you utilized `malloc`. Specifically, it checks to see
    if you `free` all the memory you allocated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code for `memory.c`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that running this program does not cause any errors. While `malloc` is
    used to allocate enough memory for an array, the code fails to `free` that allocated
    memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you type `make memory` followed by `valgrind ./memory`, you will get a report
    from valgrind that will report where memory has been lost as a result of your
    program. One error that valgrind reveals is that we attempted to assign the value
    of `33` at the 4th position of the array, where we only allocated an array of
    size `3`. Another error is that we never freed `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can modify your code to free the memory of `x` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that running valgrind again now results in no memory leaks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Garbage Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you ask the compiler for a block of memory, there is no guarantee that
    this memory will be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s very possible that the memory you allocated was previously utilized by
    the computer. Accordingly, you may see *junk* or *garbage values*. This is a result
    of you getting a block of memory but not initializing it. For example, consider
    the following code for `garbage.c`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that running this code will allocate `1024` locations in memory for your
    array, but the `for` loop will likely show that not all values therein are `0`.
    It’s always best practice to be aware of the potential for garbage values when
    you do not initialize blocks of memory to some other value like zero or otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pointer Fun with Binky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We watched a [video from Stanford University](https://www.youtube.com/watch?v=5VnDaHBi8dM)
    that helped us visualize and understand pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the real world, a common need in programming is to swap two values. Naturally,
    it’s hard to swap two variables without a temporary holding space. In practice,
    you can type `code swap.c` and write code as follows to see this in action:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that while this code runs, it does not work. The values, even after being
    sent to the `swap` function, do not swap. Why?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you pass values to a function, you are only providing copies. The *scope*
    of `x` and `y` is limited to the main function as the code is presently written.
    That is, the values of `x` and `y` created in the curly `{}` braces of the `main`
    function only have the scope of the `main` function. In our code above, `x` and
    `y` are being passed by *value*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a rectangle with machine code at top followed by globals heap and stack](../Images/88e5194e20fb1d514ee5ace6b61e6ea1.png
    "stack and heap")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that *global* variables, which we have not used in this course, live
    in one place in memory. Various functions are stored in the `stack` in another
    area of memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, consider the following image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a rectangle with main function at bottom and swap function directly above
    it](../Images/90b457bde2c5788b8738056395783f1c.png "frames")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that `main` and `swap` have two separate *frames* or areas of memory.
    Therefore, we cannot simply pass the values from one function to another to change
    them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that variables are not passed by *value* but by *reference*. That is,
    the addresses of `a` and `b` are provided to the function. Therefore, the `swap`
    function can know where to make changes to the actual `a` and `b` from the main
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can visualize this as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a and b stored in main function being passed by reference to the swap function](../Images/cdd5b602c963622f4e6b55baf6099d02.png
    "swap by reference")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *heap overflow* is when you overflow the heap, touching areas of memory you
    are not supposed to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *stack overflow* is when too many functions are called, overflowing the amount
    of memory available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these are considered *buffer overflows*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scanf`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In CS50, we have created functions like `get_int` to simplify the act of getting
    input from the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scanf` is a built-in function that can get user input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can reimplement `get_int` rather easily using `scanf` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the value of `n` is stored at the location of `n` in the line `scanf("%i",
    &n)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, attempting to reimplement `get_string` is not easy. Consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that no `&` is required because strings are special. Still, this program
    will not function correctly every time it is run. Nowhere in this program do we
    allocate the amount of memory required for our string. Indeed, we don’t know how
    long of a string may be inputted by the user! Further, we don’t know what garbage
    values may exist at the memory location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Further, your code could be modified as follows. However, we have to pre-allocate
    a certain amount of memory for a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that if a string that is four bytes is provided you *might* get an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Simplifying our code as follows, we can further understand this essential problem
    of pre-allocation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that if we pre-allocate an array of size `4`, we can type `cat` and the
    program functions. However, a string larger than this *could* create an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, the compiler or the system running it may allocate more memory than
    we indicate. Fundamentally, though, the above code is unsafe. We cannot trust
    that the user will input a string that fits into our pre-allocated memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read from and manipulate files. While this topic will be discussed
    further in a future week, consider the following code for `phonebook.c`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code uses pointers to access the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can create a file called `phonebook.csv` in advance of running the above
    code or download [phonebook.csv](https://cdn.cs50.net/2024/fall/lectures/4/src4/phonebook.csv?download).
    After running the above program and inputting a name and phone number, you will
    notice that this data persists in your CSV file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to ensure that `phonebook.csv` exists prior to running the program,
    we can modify our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this program protects against a `NULL` pointer by invoking `return
    1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can implement our own copy program by typing `code cp.c` and writing code
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this file creates our own data type called a BYTE , which is the
    size of a uint8_t. Then, the file reads a `BYTE` and writes it to a file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BMPs are also assortments of data that we can examine and manipulate. This week,
    you will be doing just that in your problem sets!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, you learned about pointers that provide you with the ability
    to access and manipulate data at specific memory locations. Specifically, we delved
    into…
  prefs: []
  type: TYPE_NORMAL
- en: Pixel art
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexadecimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer Arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String Comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: malloc and Valgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scanf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time!
  prefs: []
  type: TYPE_NORMAL
