- en: Lecture 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四讲
- en: 原文：[https://cs50.harvard.edu/x/notes/4/](https://cs50.harvard.edu/x/notes/4/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/x/notes/4/](https://cs50.harvard.edu/x/notes/4/)
- en: '[Welcome!](#welcome)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欢迎！](#welcome)'
- en: '[Pixel Art](#pixel-art)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[像素艺术](#pixel-art)'
- en: '[Hexadecimal](#hexadecimal)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[十六进制](#hexadecimal)'
- en: '[Memory](#memory)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存](#memory)'
- en: '[Pointers](#pointers)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指针](#pointers)'
- en: '[Strings](#strings)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串](#strings)'
- en: '[Pointer Arithmetic](#pointer-arithmetic)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指针算术](#pointer-arithmetic)'
- en: '[String Comparison](#string-comparison)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串比较](#string-comparison)'
- en: '[Copying and malloc](#copying-and-malloc)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[复制和malloc](#copying-and-malloc)'
- en: '[Valgrind](#valgrind)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Valgrind](#valgrind)'
- en: '[Garbage Values](#garbage-values)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[垃圾值](#garbage-values)'
- en: '[Pointer Fun with Binky](#pointer-fun-with-binky)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[与Binky一起玩指针](#pointer-fun-with-binky)'
- en: '[Swapping](#swapping)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[交换](#swapping)'
- en: '[Overflow](#overflow)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[溢出](#overflow)'
- en: '[`scanf`](#scanf)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`scanf`](#scanf)'
- en: '[File I/O](#file-io)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文件输入输出](#file-io)'
- en: '[Summing Up](#summing-up)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Welcome!
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎！
- en: In previous weeks, we talked about images being made of smaller building blocks
    called pixels.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前几周，我们讨论了图像是由称为像素的更小的构建块组成的。
- en: Today, we will go into further detail about the zeros and ones that make up
    these images. In particular, we will be going deeper into the fundamental building
    blocks that make up files, including images.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将更深入地探讨构成这些图像的零和一。特别是，我们将深入研究构成文件（包括图像）的基本构建块。
- en: Further, we will discuss how to access the underlying data stored in computer
    memory.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还将讨论如何访问存储在计算机内存中的底层数据。
- en: As we begin today, know that the concepts covered in this lecture may take some
    time to fully *click*.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在今天开始之前，要知道本讲座中涵盖的概念可能需要一些时间才能完全 *理解*。
- en: Pixel Art
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素艺术
- en: Pixels are squares, individual dots, of color that are arranged on an up-down,
    left-right grid.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素是方格，单个的点，颜色排列在上下的左右网格中。
- en: You can imagine an image as a map of bits, where zeros represent black and ones
    represent white.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象一个图像是一个位图，其中零代表黑色，一代表白色。
- en: '![Zeros and ones being converted to a black and white smiley](../Images/f057084f7f880f2232b58904e3baa906.png
    "smiley")'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![零和一转换为黑白笑脸](../Images/f057084f7f880f2232b58904e3baa906.png "smiley")'
- en: Hexadecimal
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十六进制
- en: '*RGB*, or *red, green, blue*, are numbers that represent the amount of each
    of these colors. In Adobe Photoshop, you can see these settings as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RGB*，或 *红色、绿色、蓝色*，是代表每种颜色数量的数字。在Adobe Photoshop中，你可以看到这些设置如下：'
- en: '![A photoshop panel with RGB values and hexadecimal input](../Images/19913ea21e79de08a01f8182a6fedded.png
    "hex in photoshop")'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![带有RGB值和十六进制输入的Photoshop面板](../Images/19913ea21e79de08a01f8182a6fedded.png
    "hex in photoshop")'
- en: Notice how the amount of red, blue, and green changes the color selected.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意红色、蓝色和绿色数量的变化如何改变所选颜色。
- en: You can see from the image above that color is not just represented by three
    values. At the bottom of the window, there is a special value made up of numbers
    and characters. `255` is represented as `FF`. Why might this be?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上面的图片中你可以看到，颜色不仅仅由三个值来表示。在窗口底部，有一个由数字和字符组成的特殊值。`255` 表示为 `FF`。这可能是为什么？
- en: '*Hexadecimal* is a system of counting that has 16 counting values. They are
    as follows:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*十六进制* 是一个有16个计数值的计数系统。它们如下：'
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that `F` represents `15`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `F` 代表 `15`。
- en: Hexadecimal is also known as *base-16*.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制也被称为 *十六进制*。
- en: When counting in hexadecimal, each column is a power of 16.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在十六进制计数时，每一列都是16的幂。
- en: The number `0` is represented as `00`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `0` 表示为 `00`。
- en: The number `1` is represented as `01`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `1` 表示为 `01`。
- en: The number `9` is represented by `09`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `9` 表示为 `09`。
- en: The number `10` is represented as `0A`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `10` 表示为 `0A`。
- en: The number `15` is represented as `0F`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `15` 表示为 `0F`。
- en: The number `16` is represented as `10`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `16` 表示为 `10`。
- en: The number `255` is represented as `FF`, because 16 x 15 (or `F`) is 240\. Add
    15 more to make 255\. This is the highest number you can count using a two-digit
    hexadecimal system.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `255` 表示为 `FF`，因为 16 x 15（或 `F`）等于 240。再加上 15 得到 255。这是使用两位十六进制系统可以计数的最大数字。
- en: Hexadecimal is useful because it can be represented using fewer digits. Hexadecimal
    allows us to represent information more succinctly.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制之所以有用，是因为它可以用更少的数字来表示。十六进制允许我们更简洁地表示信息。
- en: Memory
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: 'In weeks past, you may recall our artist rendering of concurrent blocks of
    memory. Applying hexadecimal numbering to each of these blocks of memory, you
    can visualize these as follows:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过去的几周里，你可能还记得我们关于并发内存块的艺术家渲染。将这些内存块应用十六进制编号，你可以这样可视化：
- en: '![Blocks of memory numbered in hex](../Images/dc5b9fc550dd51fa9ba0c6cd6f1ef498.png
    "memory hex")'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![以 0x 编号的内存块](../Images/dc5b9fc550dd51fa9ba0c6cd6f1ef498.png "memory hex")'
- en: 'You can imagine how there may be confusion regarding whether the `10` block
    above may represent a location in memory or the value `10`. Accordingly, by convention,
    all hexadecimal numbers are often represented with the `0x` prefix as follows:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象，关于上面的 `10` 块是否表示内存中的位置或值 `10` 可能会有混淆。因此，按照惯例，所有十六进制数通常都带有 `0x` 前缀，如下所示：
- en: '![blocks of memory numbered in hex with 0x](../Images/d86587cf28e3a4a6da3611bfdac5087c.png
    "0x")'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![以 0x 编号的内存块](../Images/d86587cf28e3a4a6da3611bfdac5087c.png "0x")'
- en: 'In your terminal window, type `code addresses.c` and write your code as follows:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，键入 `code addresses.c` 并按照以下方式编写你的代码：
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how `n` is stored in memory with the value `50`.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `n` 在内存中以值 `50` 存储的方式。
- en: 'You can visualize how this program stores this value as follows:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以这样可视化程序存储这个值的方式：
- en: '![the value 50 stored in a memory location with hex](../Images/19305ae228aa9ae717c06b833be43320.png
    "hex")'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![存储在内存位置中的值 50，以十六进制表示](../Images/19305ae228aa9ae717c06b833be43320.png "hex")'
- en: Pointers
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: 'The C language has two powerful operators that relate to memory:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 语言有两个与内存相关的强大运算符：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can leverage this knowledge by modifying our code as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式修改我们的代码来利用这一知识：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the `%p`, which allows us to view the address of a location in memory.
    `&n` can be literally translated as “the address of `n`.” Executing this code
    will return an address of memory beginning with `0x`.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `%p`，它允许我们查看内存位置的地址。`&n` 可以直译为“`n` 的地址。”执行此代码将返回以 `0x` 开头的内存地址。
- en: A *pointer* is a variable that stores the address of something. Most succinctly,
    a pointer is an address in your computer’s memory.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指针* 是一个存储某个地址的变量。最简洁地说，指针是计算机内存中的一个地址。'
- en: 'Consider the following code:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that `p` is a pointer that contains the address of an integer `n`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `p` 是一个指针，它包含一个整数 `n` 的地址。
- en: 'Modify your code as follows:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的代码：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that this code has the same effect as our previous code. We have simply
    leveraged our new knowledge of the `&` and `*` operators.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这段代码与我们的前一段代码具有相同的效果。我们只是利用了我们对 `&` 和 `*` 运算符的新知识。
- en: 'To illustrate the use of the `*` operator, consider the following:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了说明 `*` 运算符的使用，考虑以下：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the `printf` line prints the integer at the location of `p`. `int
    *p` creates a pointer whose job is to store the memory address of an integer.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `printf` 行打印了 `p` 位置的整数。`int *p` 创建了一个指针，其任务是存储一个整数的内存地址。
- en: 'You can visualize our code as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以这样可视化我们的代码：
- en: '![Same value of 50 in a memory location with a pointer value stored elsewhere](../Images/e4e35a1d8407d04af87bd12670b17b59.png
    "pointer")'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![具有指针值存储在其他地方的内存位置中的相同值 50](../Images/e4e35a1d8407d04af87bd12670b17b59.png
    "pointer")'
- en: Notice the pointer seems rather large. Indeed, a pointer is usually stored as
    an 8-byte value. `p` is storing the address of the `50`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到指针似乎相当大。事实上，指针通常存储为 8 字节值。`p` 存储的是 `50` 的地址。
- en: 'You can more accurately visualize a pointer as one address that points to another:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以更准确地将指针想象为一个指向另一个地址的地址：
- en: '![A pointer as an arrow, pointing from one location of memory to another](../Images/066c17edcfa4a065f34d4d1c54da36dd.png
    "pointer")'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![指针作为箭头，从一个内存位置指向另一个内存位置](../Images/066c17edcfa4a065f34d4d1c54da36dd.png "pointer")'
- en: Strings
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Now that we have a mental model for pointers, we can peel back a level of simplification
    that was offered earlier in this course.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经对指针有了心理模型，我们可以剥去之前在这门课程中提供的简化层次。
- en: 'Modify your code as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的代码：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that a string `s` is printed.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到打印了一个字符串 `s`。
- en: 'Recall that a string is simply an array of characters. For example, `string
    s = "HI!"` can be represented as follows:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，字符串只是一个字符数组。例如，`string s = "HI!"` 可以表示如下：
- en: '![The string HI with an exclamation point stored in memory](../Images/f4704464318b2965399a15b7958d7592.png
    "hi")'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![存储在内存中的带有感叹号的字符串 HI](../Images/f4704464318b2965399a15b7958d7592.png "hi")'
- en: 'However, what is `s` really? Where is the `s` stored in memory? As you can
    imagine, `s` needs to be stored somewhere. You can visualize the relationship
    of `s` to the string as follows:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，`s` 究竟是什么？`s` 在内存中的位置在哪里？正如你可以想象的那样，`s` 需要存储在某个地方。你可以这样可视化 `s` 与字符串的关系：
- en: '![Same string HI with a pointer pointing to it](../Images/ce633d4820545eb569c481c76bea25cb.png
    "hi pointer")'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![指向它的指针的相同字符串 HI](../Images/ce633d4820545eb569c481c76bea25cb.png "hi pointer")'
- en: Notice how a pointer called `s` tells the compiler where the first byte of the
    string exists in memory.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到名为`s`的指针告诉编译器字符串的第一个字节在内存中的位置。
- en: 'Modify your code as follows:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的代码：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the above prints the memory locations of each character in the string
    `s`. The `&` symbol is used to show the address of each element of the string.
    When running this code, notice that elements `0`, `1`, `2`, and `3` are next to
    one another in memory.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到上面的代码打印了字符串`s`中每个字符的内存位置。`&`符号用于显示字符串中每个元素的地址。当运行此代码时，注意元素`0`、`1`、`2`和`3`在内存中是相邻的。
- en: 'Likewise, you can modify your code as follows:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，你可以按如下方式修改你的代码：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that this code will present the string that starts at the location of
    `s`. This code effectively removes the training wheels of the `string` data type
    offered by `cs50.h`. This is raw C code, without the scaffolding of the cs50 library.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这段代码将展示从`s`位置开始的字符串。这段代码实际上移除了`cs50.h`提供的`string`数据类型的训练轮。这是原始的C代码，没有cs50库的框架。
- en: 'Taking off the training wheels, you can modify your code again:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取下训练轮，你可以再次修改你的代码：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that `cs50.h` is removed. A string is implemented as a `char *`.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`cs50.h`已被移除。字符串被实现为`char *`。
- en: You can imagine how a string, as a data type, is created.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象字符串作为数据类型是如何创建的。
- en: Last week, we learned how to create your own data type as a struct.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上周，我们学习了如何创建自己的数据类型作为结构体。
- en: 'The cs50 library includes a struct as follows: `typedef char *string`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cs50库包括以下结构体：`typedef char *string`
- en: This struct, when using the cs50 library, allows one to use a custom data type
    called `string`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用cs50库时，这个结构体允许使用一个自定义的数据类型，称为`string`。
- en: Pointer Arithmetic
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针算术
- en: Pointer arithmetic is the ability to do math on locations of memory.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针算术是进行内存位置数学运算的能力。
- en: 'You can modify your code to print out each memory location in the string as
    follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以修改你的代码以打印字符串中的每个内存位置，如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we are printing each character at the location of `s`.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们正在打印`s`位置处的每个字符。
- en: 'Further, you can modify your code as follows:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你可以按如下方式修改你的代码：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the first character at the location of `s` is printed. Then, the
    character at the location `s + 1` is printed, and so on.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`s`位置处的第一个字符被打印出来。然后，打印`s + 1`位置处的字符，以此类推。
- en: 'Likewise, consider the following:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，考虑以下内容：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that this code prints the values stored at various memory locations starting
    with `s`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这段代码从`s`开始打印存储在各个内存位置上的值。
- en: String Comparison
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串比较
- en: A string of characters is simply an array of characters identified by the location
    of its first byte.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串本质上是一个字符数组，通过其第一个字节的位置来标识。
- en: 'Earlier in the course, we considered the comparison of integers. We could represent
    this in code by typing `code compare.c` into the terminal window as follows:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在课程早期，我们考虑了整数的比较。我们可以在终端窗口中通过输入`code compare.c`来在代码中表示这一点，如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that this code takes two integers from the user and compares them.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这段代码从用户那里获取两个整数并比较它们。
- en: In the case of strings, however, one cannot compare two strings using the `==`
    operator.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，在字符串的情况下，不能使用`==`运算符来比较两个字符串。
- en: Utilizing the `==` operator in an attempt to compare strings will attempt to
    compare the memory locations of the strings instead of the characters therein.
    Accordingly, we recommended the use of `strcmp`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`==`运算符尝试比较字符串将尝试比较字符串的内存位置，而不是其中的字符。因此，我们建议使用`strcmp`。
- en: 'To illustrate this, modify your code as follows:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了说明这一点，按如下方式修改你的代码：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Noticing that typing in `HI!` for both strings still results in the output of
    `Different`.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到，对于两个字符串都输入`HI!`，仍然会输出`Different`。
- en: 'Why are these strings seemingly different? You can use the following to visualize
    why:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么这些字符串看起来是不同的？你可以使用以下内容来可视化原因：
- en: '![two strings stored separately in memory](../Images/757726f67e2fd90dee87875a3a01e9e1.png
    "two strings")'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![两个字符串分别存储在内存中](../Images/757726f67e2fd90dee87875a3a01e9e1.png "两个字符串")'
- en: Therefore, the code for `compare.c` above is actually attempting to see if the
    memory addresses are different, not the strings themselves.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，上面`compare.c`的代码实际上是在尝试查看内存地址是否不同，而不是字符串本身。
- en: 'Using `strcmp`, we can correct our code:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`strcmp`，我们可以修正我们的代码：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that `strcmp` can return `0` if the strings are the same.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`strcmp`可以在字符串相同的情况下返回`0`。
- en: 'To further illustrate how these two strings are living in two locations, modify
    your code as follows:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进一步说明这两个字符串是如何生活在两个位置上的，按如下方式修改你的代码：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we now have two separate strings stored, likely at two separate locations.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们现在有两个独立的字符串被存储，可能位于两个不同的位置。
- en: 'You can see the locations of these two stored strings with a small modification:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过以下小修改看到这两个存储的字符串的位置：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the `%s` has been changed to `%p` in the print statement.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在打印语句中 `%s` 已经被改为 `%p`。
- en: Copying and malloc
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制和 malloc
- en: A common need in programming is to copy one string to another.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程中一个常见的需求是将一个字符串复制到另一个字符串。
- en: 'In your terminal window, type `code copy.c` and write code as follows:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，键入 `code copy.c` 并编写以下代码：
- en: '[PRE19]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that `string t = s` copies the address of `s` to `t`. This does not accomplish
    what we are desiring. The string is not copied – only the address is. Further,
    notice the inclusion of `ctype.h`.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`string t = s` 将 `s` 的地址复制到 `t` 中。这并没有完成我们想要做的事情。字符串没有被复制——只有地址被复制了。此外，请注意
    `ctype.h` 的包含。
- en: 'You can visualize the above code as follows:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将上述代码可视化如下：
- en: '![two pointers pointing at the same memory location with a string](../Images/5da43cb300cf307a4b80977679231415.png
    "two strings")'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![两个指针指向同一内存位置并带有字符串](../Images/5da43cb300cf307a4b80977679231415.png "两个字符串")'
- en: Notice that `s` and `t` are still pointing at the same blocks of memory. This
    is not an authentic copy of a string. Instead, these are two pointers pointing
    at the same string.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `s` 和 `t` 仍然指向相同的内存块。这不是字符串的真正副本。相反，这两个指针指向同一个字符串。
- en: 'Before we address this challenge, it’s important to ensure that we don’t experience
    a *segmentation fault* through our code, where we attempt to copy `string s` to
    `string t`, where `string t` does not exist. We can employ the `strlen` function
    as follows to assist with that:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们解决这个挑战之前，确保我们的代码不会因为尝试将 `string s` 复制到不存在的 `string t` 而导致 *段错误* 是很重要的。我们可以使用
    `strlen` 函数如下来帮助实现这一点：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that `strlen` is used to make sure `string t` exists. If it does not,
    nothing will be copied.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `strlen` 用于确保 `string t` 存在。如果它不存在，则不会复制任何内容。
- en: To be able to make an authentic copy of the string, we will need to introduce
    two new building blocks. First, `malloc` allows you, the programmer, to allocate
    a block of a specific size of memory. Second, `free` allows you to tell the compiler
    to *free up* that block of memory you previously allocated.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够创建字符串的真正副本，我们需要引入两个新的构建块。首先，`malloc` 允许你，程序员，分配一块特定大小的内存。其次，`free` 允许你告诉编译器释放你之前分配的那块内存。
- en: 'We can modify our code to create an authentic copy of our string as follows:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以修改我们的代码来创建我们字符串的真正副本如下：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that `malloc(strlen(s) + 1)` creates a block of memory that is the length
    of the string `s` plus one. This allows for the inclusion of the *null* `\0` character
    in our final copied string. Then, the `for` loop walks through the string `s`
    and assigns each value to that same location on the string `t`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `malloc(strlen(s) + 1)` 创建了一个长度为字符串 `s` 加一的内存块。这允许在最终的复制字符串中包含 *空* `\0` 字符。然后，`for`
    循环遍历字符串 `s` 并将每个值赋给字符串 `t` 的相同位置。
- en: 'It turns out that our code is inefficient. Modify your code as follows:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，我们的代码效率不高。按照以下方式修改你的代码：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that `n = strlen(s)` is defined now in the left-hand side of the `for
    loop`. It’s best not to call unneeded functions in the middle condition of the
    `for` loop, as it will run over and over again. When moving `n = strlen(s)` to
    the left-hand side, the function `strlen` only runs once.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意现在 `n = strlen(s)` 在 `for` 循环的左侧被定义。在 `for` 循环的中间条件中最好不调用不必要的函数，因为它会反复运行。当将
    `n = strlen(s)` 移到左侧时，函数 `strlen` 只运行一次。
- en: 'The `C` Language has a built-in function to copy strings called `strcpy`. It
    can be implemented as follows:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C` 语言有一个内置的函数用于复制字符串，称为 `strcpy`。它可以如下实现：'
- en: '[PRE23]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that `strcpy` does the same work that our `for` loop previously did.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `strcpy` 做了之前我们的 `for` 循环所做的工作。
- en: 'Both `get_string` and `malloc` return `NULL`, a special value in memory, in
    the event that something goes wrong. You can write code that can check for this
    `NULL` condition as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，`get_string` 和 `malloc` 都会返回 `NULL`，这是内存中的一个特殊值。你可以编写代码来检查这个 `NULL`
    条件，如下所示：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that if the string obtained is of length `0` or malloc fails, `NULL`
    is returned. Further, notice that `free` lets the computer know you are done with
    this block of memory you created via `malloc`.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意如果获取的字符串长度为 `0` 或 `malloc` 失败，则返回 `NULL`。此外，注意 `free` 让计算机知道你已完成通过 `malloc`
    创建的这块内存。
- en: Valgrind
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Valgrind
- en: '*Valgrind* is a tool that can check to see if there are memory-related issues
    with your programs wherein you utilized `malloc`. Specifically, it checks to see
    if you `free` all the memory you allocated.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Valgrind* 是一个工具，可以检查你的程序中是否有与 `malloc` 相关的内存问题。具体来说，它检查你是否释放了所有分配的内存。'
- en: 'Consider the following code for `memory.c`:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下 `memory.c` 代码：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that running this program does not cause any errors. While `malloc` is
    used to allocate enough memory for an array, the code fails to `free` that allocated
    memory.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，运行此程序不会导致任何错误。虽然 `malloc` 用于分配足够内存的数组，但代码未能释放分配的内存。
- en: If you type `make memory` followed by `valgrind ./memory`, you will get a report
    from valgrind that will report where memory has been lost as a result of your
    program. One error that valgrind reveals is that we attempted to assign the value
    of `33` at the 4th position of the array, where we only allocated an array of
    size `3`. Another error is that we never freed `x`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你输入 `make memory` 然后跟 `valgrind ./memory`，你将得到一个 valgrind 报告，该报告将报告由于你的程序导致丢失的内存位置。valgrind
    揭示的一个错误是我们试图将 `33` 的值赋给数组的第 4 个位置，而我们只分配了一个大小为 `3` 的数组。另一个错误是我们从未释放 `x`。
- en: 'You can modify your code to free the memory of `x` as follows:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以修改你的代码来释放 `x` 的内存，如下所示：
- en: '[PRE26]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that running valgrind again now results in no memory leaks.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，现在再次运行 valgrind 不会出现内存泄漏。
- en: Garbage Values
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾值
- en: When you ask the compiler for a block of memory, there is no guarantee that
    this memory will be empty.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你向编译器请求一块内存时，没有保证这块内存是空的。
- en: 'It’s very possible that the memory you allocated was previously utilized by
    the computer. Accordingly, you may see *junk* or *garbage values*. This is a result
    of you getting a block of memory but not initializing it. For example, consider
    the following code for `garbage.c`:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能你分配的内存之前已被计算机使用。因此，你可能会看到 *垃圾* 或 *垃圾值*。这是由于你获得了一块内存但没有初始化它。例如，考虑以下 `garbage.c`
    代码：
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that running this code will allocate `1024` locations in memory for your
    array, but the `for` loop will likely show that not all values therein are `0`.
    It’s always best practice to be aware of the potential for garbage values when
    you do not initialize blocks of memory to some other value like zero or otherwise.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，运行此代码将在内存中为你的数组分配 `1024` 个位置，但 `for` 循环可能会显示其中并非所有值都是 `0`。始终注意，当你没有将内存块初始化为零或其他值时，垃圾值的可能性。
- en: Pointer Fun with Binky
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pointer Fun with Binky
- en: We watched a [video from Stanford University](https://www.youtube.com/watch?v=5VnDaHBi8dM)
    that helped us visualize and understand pointers.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们观看了一个来自斯坦福大学的 [视频](https://www.youtube.com/watch?v=5VnDaHBi8dM)，该视频帮助我们可视化和理解指针。
- en: Swapping
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换
- en: 'In the real world, a common need in programming is to swap two values. Naturally,
    it’s hard to swap two variables without a temporary holding space. In practice,
    you can type `code swap.c` and write code as follows to see this in action:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，编程中一个常见的需要是交换两个值。自然地，没有临时存储空间交换两个变量是困难的。在实践中，你可以输入 `code swap.c` 并编写如下代码来观察这一行为：
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that while this code runs, it does not work. The values, even after being
    sent to the `swap` function, do not swap. Why?
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，尽管这段代码正在运行，但它不起作用。值，甚至在发送到 `swap` 函数之后，都没有交换。为什么？
- en: When you pass values to a function, you are only providing copies. The *scope*
    of `x` and `y` is limited to the main function as the code is presently written.
    That is, the values of `x` and `y` created in the curly `{}` braces of the `main`
    function only have the scope of the `main` function. In our code above, `x` and
    `y` are being passed by *value*.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你向函数传递值时，你只提供了副本。`x` 和 `y` 的 *作用域* 限制在当前代码编写的主函数中。也就是说，在 `main` 函数的花括号 `{}`
    中创建的 `x` 和 `y` 的值只有 `main` 函数的作用域。在我们的上述代码中，`x` 和 `y` 是通过 *值* 传递的。
- en: 'Consider the following image:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下图像：
- en: '![a rectangle with machine code at top followed by globals heap and stack](../Images/88e5194e20fb1d514ee5ace6b61e6ea1.png
    "stack and heap")'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一个矩形，顶部是机器代码，然后是全局堆和栈](../Images/88e5194e20fb1d514ee5ace6b61e6ea1.png "栈和堆")'
- en: Notice that *global* variables, which we have not used in this course, live
    in one place in memory. Various functions are stored in the `stack` in another
    area of memory.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，*全局* 变量，我们在这个课程中没有使用，在内存中只有一个位置。各种函数存储在内存的另一个区域 `stack` 中。
- en: 'Now, consider the following image:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，考虑以下图像：
- en: '![a rectangle with main function at bottom and swap function directly above
    it](../Images/90b457bde2c5788b8738056395783f1c.png "frames")'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一个矩形，底部是主函数，上面直接是交换函数](../Images/90b457bde2c5788b8738056395783f1c.png "frames")'
- en: Notice that `main` and `swap` have two separate *frames* or areas of memory.
    Therefore, we cannot simply pass the values from one function to another to change
    them.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`main` 和 `swap` 有两个独立的*帧*或内存区域。因此，我们不能简单地从一个函数传递值到另一个函数来改变它们。
- en: 'Modify your code as follows:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下修改你的代码：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that variables are not passed by *value* but by *reference*. That is,
    the addresses of `a` and `b` are provided to the function. Therefore, the `swap`
    function can know where to make changes to the actual `a` and `b` from the main
    function.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，变量不是通过*值*传递，而是通过*引用*传递。也就是说，`a` 和 `b` 的地址被提供给函数。因此，`swap` 函数可以知道从主函数中如何对实际的
    `a` 和 `b` 进行更改。
- en: 'You can visualize this as follows:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以这样可视化：
- en: '![a and b stored in main function being passed by reference to the swap function](../Images/cdd5b602c963622f4e6b55baf6099d02.png
    "swap by reference")'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在主函数中存储的 a 和 b 通过引用传递给交换函数](../Images/cdd5b602c963622f4e6b55baf6099d02.png
    "swap by reference")'
- en: Overflow
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出
- en: A *heap overflow* is when you overflow the heap, touching areas of memory you
    are not supposed to.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆溢出* 是当你溢出堆，触及你不应该触及的内存区域时。'
- en: A *stack overflow* is when too many functions are called, overflowing the amount
    of memory available.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*栈溢出* 是当调用太多函数时，超出可用内存量。'
- en: Both of these are considered *buffer overflows*.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两种情况都被认为是*缓冲区溢出*。
- en: '`scanf`'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`scanf`'
- en: In CS50, we have created functions like `get_int` to simplify the act of getting
    input from the user.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CS50 中，我们创建了像 `get_int` 这样的函数来简化从用户获取输入的行为。
- en: '`scanf` is a built-in function that can get user input.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanf` 是一个内置函数，可以获取用户输入。'
- en: 'We can reimplement `get_int` rather easily using `scanf` as follows:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `scanf` 很容易地重新实现 `get_int`，如下所示：
- en: '[PRE30]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the value of `n` is stored at the location of `n` in the line `scanf("%i",
    &n)`.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`n` 的值存储在 `scanf("%i", &n)` 这一行中 `n` 的位置。
- en: 'However, attempting to reimplement `get_string` is not easy. Consider the following:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，尝试重新实现 `get_string` 并不容易。考虑以下：
- en: '[PRE31]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that no `&` is required because strings are special. Still, this program
    will not function correctly every time it is run. Nowhere in this program do we
    allocate the amount of memory required for our string. Indeed, we don’t know how
    long of a string may be inputted by the user! Further, we don’t know what garbage
    values may exist at the memory location.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于字符串是特殊的，不需要使用 `&`。然而，这个程序并不总是在每次运行时都能正确运行。在这个程序中，我们没有为我们的字符串分配所需的内存量。实际上，我们不知道用户可能输入多长的字符串！进一步地，我们也不知道内存位置可能存在的垃圾值。
- en: 'Further, your code could be modified as follows. However, we have to pre-allocate
    a certain amount of memory for a string:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你的代码可以修改如下。但是，我们必须为字符串预分配一定量的内存：
- en: '[PRE32]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that if a string that is four bytes is provided you *might* get an error.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果提供了一个四字节的字符串，你*可能*会得到一个错误。
- en: 'Simplifying our code as follows, we can further understand this essential problem
    of pre-allocation:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如下简化我们的代码，我们可以进一步理解这个预分配的基本问题：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that if we pre-allocate an array of size `4`, we can type `cat` and the
    program functions. However, a string larger than this *could* create an error.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果我们预先分配一个大小为 `4` 的数组，我们可以输入 `cat` 并使程序运行。然而，大于这个大小的字符串*可能*会创建一个错误。
- en: Sometimes, the compiler or the system running it may allocate more memory than
    we indicate. Fundamentally, though, the above code is unsafe. We cannot trust
    that the user will input a string that fits into our pre-allocated memory.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，编译器或运行它的系统可能会分配比我们指示的更多内存。然而，从根本上说，上面的代码是不安全的。我们不能相信用户会输入一个适合我们预分配内存的字符串。
- en: File I/O
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: 'You can read from and manipulate files. While this topic will be discussed
    further in a future week, consider the following code for `phonebook.c`:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以读取和操作文件。虽然这个主题将在未来的某个星期进一步讨论，但考虑以下 `phonebook.c` 的代码：
- en: '[PRE34]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that this code uses pointers to access the file.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码使用指针来访问文件。
- en: You can create a file called `phonebook.csv` in advance of running the above
    code or download [phonebook.csv](https://cdn.cs50.net/2024/fall/lectures/4/src4/phonebook.csv?download).
    After running the above program and inputting a name and phone number, you will
    notice that this data persists in your CSV file.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在运行上述代码之前创建一个名为`phonebook.csv`的文件，或者下载[phonebook.csv](https://cdn.cs50.net/2024/fall/lectures/4/src4/phonebook.csv?download)。运行上述程序并输入姓名和电话号码后，你会发现这些数据在你的CSV文件中持久保存。
- en: 'If we want to ensure that `phonebook.csv` exists prior to running the program,
    we can modify our code as follows:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在运行程序之前确保`phonebook.csv`文件存在，我们可以按照以下方式修改我们的代码：
- en: '[PRE35]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that this program protects against a `NULL` pointer by invoking `return
    1`.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个程序通过调用`return 1`来防止`NULL`指针。
- en: 'We can implement our own copy program by typing `code cp.c` and writing code
    as follows:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过输入`code cp.c`并编写如下代码来实现自己的复制程序：
- en: '[PRE36]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that this file creates our own data type called a BYTE , which is the
    size of a uint8_t. Then, the file reads a `BYTE` and writes it to a file.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个文件创建了我们自己的数据类型，称为BYTE，它的大小与uint8_t相同。然后，文件读取一个`BYTE`并将其写入文件。
- en: BMPs are also assortments of data that we can examine and manipulate. This week,
    you will be doing just that in your problem sets!
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BMPs也是我们可以检查和操作的数据集合。这周，你将在你的问题集中做这件事！
- en: Summing Up
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, you learned about pointers that provide you with the ability
    to access and manipulate data at specific memory locations. Specifically, we delved
    into…
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了指针，它使你能够访问和操作特定内存位置的数据。具体来说，我们深入探讨了……
- en: Pixel art
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素艺术
- en: Hexadecimal
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制
- en: Memory
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Pointers
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针
- en: Strings
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Pointer Arithmetic
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针算术
- en: String Comparison
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串比较
- en: Copying
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: malloc and Valgrind
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: malloc和Valgrind
- en: Garbage values
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾值
- en: Swapping
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换
- en: Overflow
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出
- en: '`scanf`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanf`'
- en: File I/O
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: See you next time!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎下次再来！
