- en: Native Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.858 [course website](http://css.csail.mit.edu/6.858/2014/schedule.html)
    from 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: What's the goal of this paper?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time, browsers allowed any web page to run only JS (+Flash) code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to allow web apps to run native (e.g., x86) code on user's machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't want to run complex code on server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires lots of server resources, incurs high latency for users.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is this useful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Languages other than JS.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy apps.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually being used in the real world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ships as part of Google Chrome: the NaCl runtime is a browser extension.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Web page can run a NaCl program much like a Flash program.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Javascript can interact with the NaCl program by passing messages.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NaCl also provides strong sandboxing for some other use cases.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Core problem: sandboxing x86 code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Native Client:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: https://developers.google.com/native-client/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install browser plug in
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Nacl tool change to compile C or C++ program
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are restrictions on what system calls you can use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example app: games (don''t need much systems support)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface to talk to browser (in release called Pepper)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make a web page that includes Nacl module:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<embed name="nacl_module" id="hello_world" width=0 height=0 src="hello_world.nmf"
    type="application/x-nacl" />`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Module is "controled" x86 code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quick demo:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What are some options for safely running x86 code?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Approach 0:** trust the code developer.'
  prefs: []
  type: TYPE_NORMAL
- en: ActiveX, browser plug-ins, Java, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer signs code with private key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asks user to decide whether to trust code from some developer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users are bad at making such decisions (e.g., with ActiveX code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works for known developers (e.g., Windows Update code, signed by MS).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unclear how to answer for unknown web applications (other than "no").
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Native Client's goal is to enforce safety, avoid asking the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approach 1:** hardware protection / OS sandboxing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar plan to some ideas we''ve already read: OKWS, Capsicum, VMs, ..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run untrusted code as a regular user-space program or a separate VM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to control what system calls the untrusted code can invoke.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: seccomp.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FreeBSD: Capsicum.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MacOSX: Seatbelt.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: unclear what options exist.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Native client uses these techniques, but only as a backup plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not rely on OS sandboxing directly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each OS may impose different, sometimes incompatible requirements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System calls to allocate memory, create threads, etc.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual memory layout (fixed-address shared libraries in Windows?).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OS kernel vulnerabilities are reasonably common.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows untrusted code to escape sandbox.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not every OS might have a sufficient sandboxing mechanism.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., unclear what to do on Windows, without a special kernel module.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some sandboxing mechanisms require root: don''t want to run Chrome as root.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware might have vulnerabilities (!).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Authors claim some instructions happen to hang the hardware.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Would be unfortunate if visiting a web site could hang your computer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approach 2:** software fault isolation (Native Client''s primary sandboxing
    plan).'
  prefs: []
  type: TYPE_NORMAL
- en: Given an x86 binary to run in Native Client, verify that it's safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verification involves checking each instruction in the binary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some instructions might be always safe: allow.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some instructions might be sometimes safe.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Software fault isolation's approach is to require a check before these.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must ensure the check is present at verification time.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another option: insert the check through binary rewriting.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard to do with x86, but might be more doable with higher-level lang.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some instructions might be not worth making safe: prohibit.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After verifying, can safely run it in same process as other trusted code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the sandbox to call into trusted "service runtime" code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2 from paper
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What does safety mean for a Native Client module?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Goal #1:** does not execute any disallowed instructions (e.g., syscall, int).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures module does not perform any system calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal #2:** does not access memory or execute code outside of module boundary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures module does not corrupt service runtime data structures.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures module does not jump into service runtime code, ala return-to-libc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As described in paper, module code+data live within [0..256MB) virt addrs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need not populate entire 256MB of virtual address space.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else should be protected from access by the NaCl module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to check if the module can execute a disallowed instruction?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strawman: scan the executable, look for "int" or "syscall" opcodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If check passes, can start running code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, need to also mark all code as read-only.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And all writable memory as non-executable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Complication:* x86 has variable-length instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"int" and "syscall" instructions are 2 bytes long.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other instructions could be anywhere from 1 to 15 bytes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose program''s code contains the following bytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`25 CD 80 00 00`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If interpreted as an instruction starting from 25, it is a 5-byte instr:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND %eax, $0x000080cd`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But if interpreted starting from CD, it''s a 2-byte instr:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INT $0x80 # Linux syscall`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Could try looking for disallowed instructions at every offset..
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Likely will generate too many false alarms.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Real instructions may accidentally have some "disallowed" bytes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliable disassembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Plan:** ensure code executes only instructions that verifier knows about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we guarantee this? Table 1 and Figure 3 in paper.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan forward through all instructions, starting at the beginning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we see a jump instruction, make sure it's jumping to address we saw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to ensure for static jumps (constant addr).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot ensure statically for **computed jumps** (jump to addr from register).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed jumps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Idea is to rely on runtime instrumentation: added checks before the jump.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For computed jump to %eax, NaCl requires the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND $0xffffffe0, %eax # Clear last 4 bits (=> only jump to 32-byte boundary)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JMP *%eax`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will ensure jumps go to multiples of 32 bytes. Why 32-byte?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: longer than the max. instruction length
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: power of 2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: need to fit trampoline (see below later) code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: not bigger because we don't want to waste space for single instruction jump
    targets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NaCl also requires that no instructions span a 32-byte boundary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler's job is to ensure both of these rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace every computed jump with the two-instruction sequence above.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add NOP instructions if some other instruction might span 32-byte boundary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add NOPs to pad to 32-byte multiple if next instr is a computed jump target.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Always possible because NOP instruction is just one byte.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifier's job is to check these rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During disassembly, make sure no instruction spans a 32-byte boundary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For computed jumps, ensure it's in a two-instruction sequence as above.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What will this guarantee?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifier checked all instructions starting at 32-byte-multiple addresses.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed jumps can only go to 32-byte-multiple addresses.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What prevents the module from jumping past the AND, directly to the JMP?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pseudo-instruction: the NaCl jump instruction will never be compiled so that
    the `AND` part and the `JMP` part are *split* by a 32-byte boundary. Thus, you
    could never jump straight to the `JMP` part.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How does NaCl deal with `RET` instructions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prohibited -- effectively a computed jump, with address stored on stack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is due to an **inherent race condition**: the `ret` instruction pops the
    return address off the stack and then jumps to it. NaCl could check the address
    on the stack before its popped, but there''s TOCTOU problem here: the address
    could be modified immediately after the check by another thread. This can happen
    because the return address is in memory, not in a register.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, compiler must generate explicit POP + computed jump code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are the rules from Table 1 in the paper necessary?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C1: executable code in memory is not writable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C2: binary is statically linked at zero, code starts at 64K.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C3: all computed jumps use the two-instruction sequence above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C4: binary is padded to a page boundary with one or more HLT instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C5: no instructions, or our special two-instruction pair, can span 32 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C6/C7: all jump targets reachable by fall-through disassembly from start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Homework question:** what happens if verifier gets some instruction length
    wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer:** Depending on where you offset into a seamingly innocent x86 instruction
    stream, you can get unexpectedly useful instructions out (In the BROP paper, we
    got a "pop rsi; ret;" from offsetting at 0x7 into the BROP gadget).'
  prefs: []
  type: TYPE_NORMAL
- en: If the checker incorrectly computes the length of an x86 instruction, then the
    attacker can exploit this. Suppose the checker computes `bad_len(i)` as the length
    of a certain instruction `i` at address `a`. The attacker, knowledgeable about
    x86, could write assembly code at address `a + bad_len(i)` that passes all the
    checks and seems harmless. This assembly code is what the NaCl checker would "see",
    given the instruction length bug. However, when the code is executed, the next
    instruction after instruction `i` would be at address `a + real_len(i)`. And,
    the attacker carefully crafted his code such that the instructions at and after
    `a + real_len(i)` do something useful. Like jumping outside the sandbox, or a
    syscall.
  prefs: []
  type: TYPE_NORMAL
- en: How to prevent NaCl module from jumping to 32-byte multiple outside its code?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Could use additional checks in the computed-jump sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND $0x0fffffe0, %eax'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JMP *%eax`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why don't they use this approach?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longer instruction sequence for computed jumps.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Their sequence is `3+2=5` bytes, above sequence is `5+2=7` bytes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative solution is pretty easy: segmentation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: x86 hardware provides "segments".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each memory access is with respect to some "segment".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segment specifies base + size.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Segments are specified by a segment selector: ptr into a segment table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%cs, %ds, %ss, %es, %fs, %gs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instruction can specify what segment to use for accessing memory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code always fetched using the `%cs` segment.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Address translation: (segment selector, addr) -> (segbase + addr % segsize).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, all segments have `base=0, size=max`, so segmentation is a no-op.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can change segments: in Linux, `modify_ldt()` system call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can change segment selectors: just `MOV %ds`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limiting code/data to module''s size:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add a new segment with `offset=0, size=256MB.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set all segment selectors to that segment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify verifier to reject any instructions that change segment selectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures all code and data accesses will be within [0..256MB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (NaCl actually seems to limit the code segment to the text section size.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would be required to run Native Client on a system without segmentation?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For example, AMD/Intel decided to drop segment limits in their 64-bit CPUs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One practical possibility: run in 32-bit mode.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD/Intel CPUs still support segment limits in 32-bit mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can run in 32-bit mode even on a 64-bit OS.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Would have to change the computed-jump code to limit target to 256MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would have to add runtime instrumentation to each memory read/write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the paper in additional references below for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why doesn't Native Client support exceptions for modules?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if module triggers hardware exception: null ptr, divide-by-zero, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS kernel needs to deliver exception (as a signal) to process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But Native Client runs with an unusual stack pointer/segment selector `%ss`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So if the OS tried to deliver the exception, it would terminate the program
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some OS kernels refuse to deliver signals in this situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NaCl's solution is to prohibit hardware exceptions altogether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language-level exceptions (e.g., C++) do not involve hardware: no problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would happen if a NaCl module had a buffer overflow?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any computed call (function pointer, return address) has to use 2-instr jump.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, can only jump to validated code in the module's region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer overflows might allow attacker to take over module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, can't escape NaCl's sandbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of the original NaCl design?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static code: no JIT, no shared libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic code supported in recent versions (see additional refs at the end).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking trusted code from sandbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Short code sequences that transition to/from sandbox located in [4KB..64KB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trampoline** undoes the sandbox, enters trusted code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts at a 32-byte multiple boundary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads unlimited segment into `%cs, %ds` segment selectors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumps to trusted code that lives above 256MB.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Slightly tricky:* must ensure trampoline fits in 32 bytes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (Otherwise, module could jump into middle of trampoline code..)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trusted code first switches to a different stack: why?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the NaCl module stack is incapable of receiving exceptions, and the library
    code called by the trampoline could get exceptions
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: also, in the paper they mention this new stack, which is per-thread will reside
    outside the untrusted address space, so as to protect it from **attacks by other
    NaCl module threads**!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsequently, trusted code has to re-load other segment selectors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Springboard** (re-)enters the sandbox on return or initial start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Springboard slots (32-byte multiples) start with `HLT` (halt) instruction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevents computed jumps into springboard by module code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-set segment selectors, jump to a particular address in NaCl module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What's provided by the service runtime? (NaCl's "system call" equivalent)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Memory allocation: sbrk/mmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thread operations: create, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPC: initially with Javascript code on page that started this NaCl program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Browser interface via NPAPI: DOM access, open URLs, user input, ..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No networking: can use Javascript to access network according to SOP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How secure is Native Client?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'List of attack surfaces: start of section 2.3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inner sandbox: validator has to be correct (had some tricky bugs!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Outer sandbox: OS-dependent plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux, probably seccomp.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On FreeBSD (if NaCl supported it), Capsicum would make sense.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why the outer sandbox?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible bugs in the inner sandbox.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What could an adversary do if they compromise the inner sandbox?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit CPU bugs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit OS kernel bugs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit bugs in other processes communicating with the sandbox proc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service runtime: initial loader, runtime trampoline interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inter-module communication (IMC) interface + NPAPI: complex code, can (and
    did) have bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well does it perform?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CPU overhead seems to be dominated by NaCl's code alignment requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Larger instruction cache footprint.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But for some applications, NaCl's alignment works better than gcc's.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal overhead for added checks on computed jumps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call-into-service-runtime performance seems comparable to Linux syscalls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How hard is it to port code to NaCl?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For computational things, seems straightforward: 20 LoC change for H.264.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For code that interacts with system (syscalls, etc), need to change them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., Bullet physics simulator (section 4.4).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Native Client for 64-bit x86 and for ARM.](http://static.usenix.org/events/sec10/tech/full_papers/Sehr.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Native Client for runtime-generated code (JIT).](http://research.google.com/pubs/archive/37204.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Native Client without hardware dependence.](http://css.csail.mit.edu/6.858/2012/readings/pnacl.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other software fault isolation systems w/ fine-grained memory access control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XFI](http://css.csail.mit.edu/6.858/2012/readings/xfi.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[BGI](http://research.microsoft.com/pubs/101332/bgi-sosp.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formally verifying the validator.](http://www.cse.lehigh.edu/~gtan/paper/rocksalt.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
