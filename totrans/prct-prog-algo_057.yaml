- en: 9.8   Monte Carlo Simulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 蒙特卡罗模拟
- en: 原文：[https://introcs.cs.princeton.edu/java/98simulation](https://introcs.cs.princeton.edu/java/98simulation)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/98simulation](https://introcs.cs.princeton.edu/java/98simulation)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在大规模施工中。
- en: In 1953 Enrico Fermi, John Pasta, and Stanslaw Ulam created the first "computer
    experiment" to study a vibrarting atomic lattice. Nonlinear system couldn't be
    analyzed by classical mathematics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1953年，恩里科·费米、约翰·帕斯塔和斯坦斯劳·乌拉姆创建了第一个“计算机实验”来研究振动的原子晶格。非线性系统无法通过经典数学进行分析。
- en: 'Simulation = analytic method that imitates a physical system. Monte Carlo simulation
    = use randomly generated values for uncertain variables. Named after famous casino
    in Monaco. At essentially each step in the evolution of the calculation, Repeat
    several times to generate range of possible scenarios, and average results. Widely
    applicable brute force solution. Computationally intensive, so use when other
    techniques fail. Typically, accuracy is proportional to square root of number
    of repetitions. Such techniques are widely applied in various domains including:
    designing nuclear reactors, predicting the evolution of stars, forecasting the
    stock market, etc.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟=模拟物理系统的分析方法。蒙特卡洛模拟=使用随机生成的值来处理不确定变量。以摩纳哥著名赌场命名。在计算的每个步骤中，重复多次以生成可能情景范围，并对结果进行平均。广泛适用的蛮力解决方案。计算密集型，因此在其他技术失败时使用。通常，准确性与重复次数的平方根成正比。这些技术广泛应用于各个领域，包括：设计核反应堆，预测恒星的演化，预测股市走势等。
- en: '**Generating random numbers.** The math library function `Math.random` generate
    a pseudo-random number greater than or equal to 0.0 and less than 1.0. If you
    want to generate random integers or booleans, the best way is to use the library
    `Random`. Program [RandomDemo.java](RandomDemo.java.html) illustrates how to use
    it.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成随机数。** 数学库函数`Math.random`生成大于或等于0.0且小于1.0的伪随机数。如果要生成随机整数或布尔值，最好的方法是使用库`Random`。程序[RandomDemo.java](RandomDemo.java.html)演示了如何使用它。'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you should only create a new `Random` object once per program. You
    will not get more "random" results by creating more than one. For debugging, you
    may wish to produce the same sequence of pseudo-random number each time your program
    executes. To do this, invoke the constructor with a `long` argument.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您应该在程序中只创建一个新的`Random`对象。通过创建多个对象，您不会获得更多“随机”的结果。对于调试，您可能希望每次程序执行时生成相同的伪随机数序列。要做到这一点，请使用带有`long`参数的构造函数。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The pseudo-random number generator will use 1234567 as the seed. Use `SecureRandom`
    for cryptographically secure pseudo-random numbers, e.g., for cryptography or
    slot machines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数生成器将使用1234567作为种子。对于需要密码安全的伪随机数，例如密码学或老虎机，使用`SecureRandom`。
- en: '**Linear congruential random number generator.** With integer types we must
    be cognizant of overflow. Consider a * b (mod m) as an example (either in context
    of a^b (mod m) or linear congruential random number generator: Given constants
    a, c, m, and a seed x[0], iterate: x = (a * x + c) mod m. Park and Miller suggest
    a = 16807, m = 2147483647, c = 0 for 32-bit signed integers. To avoid overflow,
    use Schrage''s method.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性同余随机数生成器。** 对于整数类型，我们必须注意溢出。考虑a * b (mod m)作为一个例子（无论是在a^b (mod m)的上下文中还是线性同余随机数生成器中：给定常数a、c、m和种子x[0]，迭代：x
    = (a * x + c) mod m。Park和Miller建议a = 16807，m = 2147483647，c = 0适用于32位有符号整数。为避免溢出，使用Schrage的方法。'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Exercise: compute cycle length.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：计算循环长度。
- en: '**Library of probability functions.** OR-Objects contains many classic [probability
    distributions and random number generators](http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html),
    including Normal, F, Chi Square, Gamma, Binomial, Poisson. You can download the
    [jar file](http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar) here. Program
    [ProbDemo.java](ProbDemo.java.html) illustrates how to use it. It generate one
    random value from the gamma distribution and 5 from the binomial distribution.
    Note that the method is called `getRandomScaler` and not `getRandomScalar`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**概率函数库。** OR-Objects包含许多经典的[概率分布和随机数生成器](http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html)，包括正态分布、F分布、卡方分布、伽玛分布、二项分布、泊松分布。您可以在这里下载[jar文件](http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar)。程序[ProbDemo.java](ProbDemo.java.html)演示了如何使用它。它从伽玛分布生成一个随机值和从二项分布生成5个随机值。请注意，该方法称为`getRandomScaler`而不是`getRandomScalar`。'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Queuing models.** M/M/1, etc. A manufacturing facility has M identical machines.
    Each machine fails after a time that is exponentially distributed with mean 1
    / μ. A single repair person is responsible for maintaining all the machines, and
    the time to fix a machine is exponentially distributed with mean 1 / λ. Simulate
    the fraction of time in which no machines are operational.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**排队模型。** M/M/1等。一个制造设施有M台相同的机器。每台机器在指数分布的平均时间1 / μ后发生故障。一个维修人员负责维护所有机器，修理一台机器的时间服从平均时间1
    / λ的指数分布。模拟没有机器运行的时间比例。'
- en: Diffusion-limited aggregation.
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩散限制聚集。
- en: Diffuse = undergo random walk. The physical process *diffusion-limited aggregation*
    (DLA) models the formation of an aggregate on a surface, including lichen growth,
    the generation of polymers out of solutions, carbon deposits on the walls of a
    cylinder of a Diesel engine, path of electric discharge, and urban settlement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 扩散=经历随机漫步。物理过程*扩散限制聚集*（DLA）模拟了表面上聚集物质的形成，包括地衣生长、溶液中聚合物的生成、柴油发动机气缸壁上的碳沉积、电放电路径和城市定居。
- en: 'The modeled aggregate forms when particles are released one at a time into
    a volume of space and, influenced by random thermal motion, they diffuse throughout
    the volume. There is a finite probability that the short-range attraction between
    particles will influence the motion. Two particles which come into contact with
    each other will stick together and form a larger unit. The probability of sticking
    increases as clusters of occupied sites form in the aggregate, stimulating further
    growth. Simulate this process in 2D using Monte Carlo methods: Create a 2D grid
    and introduce particles to the lattice through a launching zone one at a time.
    After a particle is launched, it wanders throughout with a random walk until it
    either sticks to the aggregate or wanders off the lattice into the *kill zone*.
    If a wandering particle enters an empty site next to an occupied site, then the
    particle''s current location automatically becomes part of the aggregate. Otherwise,
    the random walk continues. Repeat this process until the aggregate contains some
    pre-determined number of particles. *Reference:* Wong, Samuel, Computational Methods
    in Physics and Engineering, 1992.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当粒子一个接一个地释放到空间体积中时，受到随机热运动的影响，模拟的聚集形成。有限的概率使得粒子之间的短程吸引会影响运动。两个接触的粒子将粘在一起形成一个更大的单位。随着聚集中形成占用位置的簇，粘附的概率增加，刺激进一步生长。使用蒙特卡洛方法在2D中模拟这个过程：创建一个2D网格，并通过一个发射区域逐个向晶格引入粒子。粒子被释放后，它会进行随机漫步，直到它要么粘附到聚集上，要么漫步到晶格之外的*杀伤区*。如果漫步的粒子进入一个空位旁边的占用位置，那么粒子的当前位置自动成为聚集的一部分。否则，随机漫步继续。重复这个过程，直到聚集包含一定数量的粒子。*参考资料：*
    Wong, Samuel, Computational Methods in Physics and Engineering, 1992.
- en: Program [DLA.java](DLA.java.html) simulates the growth of a DLA with the following
    properties. It uses the helper data type [Picture.java](Picture.java.html). Set
    the initial aggregate to be the bottom row of the N-by-N lattice. Launch the particles
    from a random cell in top row. Assume that the particle goes up with probability
    0.15, down with probability 0.35, and left or right with probability 1/4 each.
    Continue until the particles stick to a neighboring cell (above, below, left,
    right, or one of the four diagonals) or leaves the N-by-N lattice. The preferred
    downward direction is analogous to the effect of a temperature gradient on Brownian
    motion, or like how when a crystal is formed, the bottom of the aggregate is cooled
    more than the top; or like the influence of a gravitational force. For effect,
    we color the particles in the order they are released according to the rainbow
    from red to violet. Below are three simulations with N = 176; here is an image
    with [N = 600](dla-big.png).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[DLA.java](DLA.java.html)模拟了DLA的生长过程，具有以下特性。它使用了辅助数据类型[Picture.java](Picture.java.html)。将初始聚集设置为N×N格子的底行。从顶行的随机单元中释放粒子。假设粒子向上的概率为0.15，向下的概率为0.35，向左或向右的概率各为1/4。持续进行，直到粒子粘附到相邻单元（上方、下方、左侧、右侧或四个对角线之一）或离开N×N格子。向下的首选方向类似于温度梯度对布朗运动的影响，或者类似于晶体形成时，聚集的底部比顶部冷却更多；或者类似于重力的影响。为了效果，我们按照从红色到紫色的彩虹顺序对粒子进行着色。下面是三个N
    = 176的模拟；这里是一个N = 600的图像[dla-big.png](dla-big.png)。
- en: '| ![Diffusion Limited Aggregation 1](../Images/9799a0a903aad52bdc7a142bfa358c04.png)
    | ![Diffusion Limited Aggregation 2](../Images/6ae1295c6e0c4eca32048911b98ea71d.png)
    | ![Diffusion Limited Aggregation 3](../Images/b3e8ab83eb8863a1dfd9bf76a62aab76.png)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| ![扩散限制凝聚1](../Images/9799a0a903aad52bdc7a142bfa358c04.png) | ![扩散限制凝聚2](../Images/6ae1295c6e0c4eca32048911b98ea71d.png)
    | ![扩散限制凝聚3](../Images/b3e8ab83eb8863a1dfd9bf76a62aab76.png) |'
- en: '**Brownian motion.** Brownian motion is a random process used to model a wide
    variety of physical phenomenon including the dispersion of ink flowing in water,
    and the behavior of atomic particles predicted by quantum physics. ([more applications](http://www.doc.ic.ac.uk/~nd/surprise_95/journal/vol4/ykl/report.html)).
    Fundamental random process in the universe. It is the limit of a discrete random
    walk and the stochastic analog of the Gaussian distribution. It is now widely
    used in computational finance, economics, queuing theory, engineering, robotics,
    medical imaging, biology, and flexible manufacturing systems. First studied by
    a Scottish botanist Robert Brown in 1828 and analyzed mathematically by Albert
    Einstein in 1905. Jean-Baptiste Perrin performed experiments to confirm Einstein''s
    predictions and won a Nobel Prize for his work. An [applet](http://www.phy.ntnu.edu.tw/java/gas2D/gas2D.html)
    to illustrate physical process that may govern cause of Brownian motion.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**布朗运动。** 布朗运动是一种随机过程，用于模拟各种物理现象，包括墨水在水中扩散以及量子物理学预测的原子粒子的行为。([更多应用](http://www.doc.ic.ac.uk/~nd/surprise_95/journal/vol4/ykl/report.html))。宇宙中的基本随机过程。它是离散随机漫步的极限，也是高斯分布的随机模拟。现在广泛应用于计算金融、经济学、排队理论、工程学、机器人技术、医学成像、生物学和柔性制造系统。1828年由苏格兰植物学家罗伯特·布朗首次研究，并在1905年由阿尔伯特·爱因斯坦进行数学分析。让-巴蒂斯特·佩兰进行实验证实了爱因斯坦的预测，并因此获得了诺贝尔奖。一个[小程序](http://www.phy.ntnu.edu.tw/java/gas2D/gas2D.html)来说明可能控制布朗运动原因的物理过程。'
- en: '**Simulating a Brownian motion.** Since Brownian motion is a continuous and
    stochastic process, we can only hope to plot one path on a finite interval, sampled
    at a finite number of points. We can interpolate linearly between these points
    (i.e., connect the dots). For simplicitly, we''ll assume the interval is from
    0 to 1 and the sample points t[0], t[1], ..., t[N] are equally spaced in this
    interval. To simulate a standard Brownian motion, repeatedly generate independent
    Gaussian random variables with mean 0 and standard deviation sqrt(1/N). The value
    of the Brownian motion at time i is the sum of the first i increments.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟布朗运动。** 由于布朗运动是一个连续和随机的过程，我们只能希望在有限区间上绘制一条路径，在有限数量的点上采样。我们可以在这些点之间进行线性插值（即连接这些点）。为简单起见，我们假设区间从0到1，采样点t[0]，t[1]，...，t[N]在这个区间内等间距。要模拟标准布朗运动，重复生成均值为0，标准差为sqrt(1/N)的独立高斯随机变量。在时间i处的布朗运动值是前i个增量的总和。'
- en: '| ![Brownian motion](../Images/19255e8477d833e9551cc7049e910365.png) | ![Brownian
    motion](../Images/4dde95b10de31ea808f249e23cd04e96.png) | ![Brownian motion](../Images/ff1d630341f8f15dd20a4778d1b821f1.png)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| ![布朗运动](../Images/19255e8477d833e9551cc7049e910365.png) | ![布朗运动](../Images/4dde95b10de31ea808f249e23cd04e96.png)
    | ![布朗运动](../Images/ff1d630341f8f15dd20a4778d1b821f1.png) |'
- en: '**Geometric Brownian motion.** A variant of Brownian motion is widely used
    to model stock prices, and the Nobel-prize winning Black-Scholes model is centered
    on this stochastic process. A geometric Brownian motion with drift μ and volatility
    σ is a stochastic process that can model the price of a stock. The parameter μ
    models the percentage drift. If μ = 0.10, then we expect the stock to increase
    by 10% each year. The parameter σ models the percentage volatility. If σ = 0.20,
    then the standard deviation of the stock price over one year is roughly 20% of
    the current stock price. To simulate a geometric Brownian motion from time t =
    0 to t = T, we follow the same procedure for standard Brownian motion, but multiply
    the increments, instead of adding them, and incorporate the drift and volatility
    parameters. Specifically, we multiply the current price by by (1 + μΔt + σsqrt(Δt)Z),
    where Z is a standard Gaussian and Δt = T/N Start with X(0) = 100, σ = 0.04.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**几何布朗运动。** 布朗运动的一个变体被广泛用于模拟股票价格，而诺贝尔奖获得者布莱克-斯科尔斯模型是基于这个随机过程的。具有漂移μ和波动率σ的几何布朗运动是一个可以模拟股票价格的随机过程。参数μ表示百分比漂移。如果μ
    = 0.10，则我们预期股票每年增长10%。参数σ表示百分比波动率。如果σ = 0.20，则一年内股价的标准差大约是当前股价的20%。要从时间t = 0模拟几何布朗运动到时间t
    = T，我们遵循标准布朗运动的相同过程，但是将增量相乘，而不是相加，并且结合漂移和波动率参数。具体来说，我们将当前价格乘以(1 + μΔt + σsqrt(Δt)Z)，其中Z是标准高斯，Δt
    = T/N，从X(0) = 100开始，σ = 0.04。'
- en: '[construction of BM](http://www.cse.ucsc.edu/~chang/203/bm.pdf).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[BM的构造](http://www.cse.ucsc.edu/~chang/203/bm.pdf)。'
- en: '*Black-Scholes formula.* Move to here?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*布莱克-斯科尔斯公式。* 移至此处？'
- en: '**Ising model.** The motions of electrons around a nucleus produce a magnetic
    field associated with the atom. These *atomic magnets* act much like conventional
    magnets. Typically, the magnets point in random directions, and all of the forces
    cancel out leaving no overall magnetic field in a macroscopic clump of matter.
    However, in some materials (e.g., iron), the magnets can line up producing a measurable
    magnetic field. A major achievement of 19th century physics was to describe and
    understand the equations governing atomic magnets. The probability that state
    S occurs is given by the Boltzmann probability density function P(S) = e^(-E(S)/kT)
    / Z, where Z is the normalizing constant (*partition function*) sum e^(-E(A)/kT)
    over all states A, k is Boltzmann''s constant, T is the absolute temperature (in
    degrees Kelvin), and E(S) is the energy of the system in state S.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ising 模型。** 电子围绕原子核的运动产生与原子相关的磁场。这些*原子磁铁*表现得很像传统磁铁。通常，磁铁指向随机方向，所有力相互抵消，在宏观物质块中没有整体磁场。然而，在一些材料中（例如铁），磁铁可以排列产生可测量的磁场。19世纪物理学的一个重大成就是描述和理解控制原子磁铁的方程。状态S发生的概率由玻尔兹曼概率密度函数给出，P(S)
    = e^(-E(S)/kT) / Z，其中Z是归一化常数（*分区函数*）对所有状态A求和 e^(-E(A)/kT)，k是玻尔兹曼常数，T是绝对温度（以开尔文度表示），E(S)是系统在状态S的能量。'
- en: 'Ising model proposed to describe magnetism in crystalline materials. Also models
    other naturally occurring phenomena including: freezing and evaporation of liquids,
    protein folding, and behavior of glassy substances.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ising 模型被提出来描述晶体材料中的磁性。还模拟其他自然现象，包括：液体的冻结和蒸发，蛋白质折叠，以及玻璃物质的行为。
- en: '*Ising model.* The Boltzmann probability function is an elegant model of magnetism.
    However, it is not practical to apply it for calculating the magnetic properties
    of a real iron magnet because any macroscopic chunk of iron contains an enormous
    number atoms and they interact in complicated ways. The [Ising model](http://oscar.cacr.caltech.edu/Hrothgar/Ising/)
    is a simplified model for magnets that captures many of their important properties,
    including phase transitions at a critical temperature. (Above this temperature,
    no macroscopic magnetism, below it, systems exhibits magnetism. For example, iron
    loses its magnetization around 770 degrees Celsius. Remarkable thing is that transition
    is sudden.) [reference](http://www.npac.syr.edu/users/gcf/cps713montecarlo/p_montecarlo.html)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ising 模型。* 玻尔兹曼概率函数是磁性的一个优雅模型。然而，将其应用于计算真实铁磁体的磁性属性并不实际，因为任何宏观铁块包含大量原子，并且它们以复杂的方式相互作用。[Ising
    模型](http://oscar.cacr.caltech.edu/Hrothgar/Ising/)是一个简化的磁铁模型，捕捉了许多重要特性，包括在临界温度下的相变。（在此温度以上，没有宏观磁性，在此以下，系统表���出磁性。例如，铁在大约770摄氏度左右失去磁化。值得注意的是，转变是突然的。）[参考链接](http://www.npac.syr.edu/users/gcf/cps713montecarlo/p_montecarlo.html)'
- en: 'First introduced by Lenz and Ising in the 1920s. In the Ising model, the iron
    magnet is divided into an N-by-N grid of cells. (Vertex = atom in crystal, edge
    = bond between adjacent atoms.) Each cell contains an abstract entity known as
    *spin*. The spin s[i] of cell i is in one of two states: pointing up (+1) or pointing
    down (-1). The interactions between cells is limited to *nearest neighbors*. The
    total magnetism of the system M = sum of s[i]. The total energy of the system
    E = sum of - J s[i] s[j], where the sum is taken over all nearest neighbors i
    and j. The constant J measures the strength of the spin-spin interactions (in
    units of energy, say ergs). [The model can be extended to allow interaction with
    an external magnetic field, in which case we add the term -B sum of s[k] over
    all sites k.] If J > 0, the energy is minimized when the spins are aligned (both
    +1 or both -1) - this models *ferromagnetism*. if J < 0, the energy is minimized
    when the spins are oppositely aligned - this models *antiferromagnetism*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪20年代由Lenz和Ising首次引入。在Ising模型中，铁磁体被分成一个N×N的单元格网格。（顶点=晶体中的原子，边=相邻原子之间的键。）每个单元格包含一个称为*自旋*的抽象实体。单元格i的自旋s[i]处于两种状态之一：指向上方（+1）或指向下方（-1）。单元格之间的相互作用仅限于*最近邻居*。系统的总磁性M
    = s[i]的总和。系统的总能量E = - J s[i] s[j]的总和，其中总和取自所有最近邻居i和j。常数J衡量自旋-自旋相互作用的强度（以能量单位，如ergs）。[该模型可以扩展以允许与外部磁场的相互作用，此时我们在所有站点k上添加项-B
    s[k]的总和。]如果J > 0，当自旋对齐时（都是+1或都是-1）能量最小化-这模拟了*铁磁性*。如果J < 0，当自旋相反对齐时能量最小化-这模拟了*反铁磁性*。
- en: Given this model, a classic problem in statistical mechanics is to compute the
    expected magenetism. A *state* is the specification of the spin for each of the
    N^2 lattice cells. The expected magnetism of the system E[M] = sum of M(S) P(S)
    over all states S, where M(S) is the magnetism of state S, and P(S) is the probability
    of state S occurring according to the Boltzmann probability function. Unfortunately,
    this equation is not amenable to a direct computational because the number of
    states S is 2^(N*N) for an N-by-N lattice. Straightforward Monte Carlo integration
    won't work because random points will not contribute much to sum. Need selective
    sampling, ideally sample points proportional to e^(-E/kT). (In 1925, Ising solved
    the problem in one dimension - no phase transition. In a 1944 tour de force, Onsager
    solved the 2D Ising problem exactly. His solution showed that it has a phase transition.
    Not likely to be solved in 3D - see intractability section.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个模型，在统计力学中的一个经典问题是计算期望的磁性。*状态*是指定N^2晶格单元格中每个自旋的规范。系统的期望磁性E[M] = 在所有状态S上的M(S)
    P(S)的总和，其中M(S)是状态S的磁性，P(S)是根据玻尔兹曼概率函数发生状态S的概率。不幸的是，这个方程不适合直接计算，因为对于N×N晶格，状态S的数量为2^(N*N)。直接的蒙特卡洛积分不起作用，因为随机点不会对总和有太大贡献。需要选择性采样，理想情况下按比例采样点e^(-E/kT)。
    （1925年，Ising解决了一维问题-没有相变。1944年，Onsager通过一次成功的解决了2D Ising问题。他的解决方案表明它具有相变。不太可能在3D中解决-请参见难以解决部分。）
- en: '*Metropolis algorithm.* Widespread usage of Monte Carlo methods began with
    Metropolis algorithm for calculation of rigid-sphere system. Published in 1953
    after dinner conversation between Metropolis, Rosenbluth, Rosenbluth, Teller,
    and Teller. Widely used to study equilibrium properties of a system of atoms.
    Sample using Markov chain using Metropolis'' rule: transition from A to B with
    probability 1 if Δ E <= 0, and with probability e^(-ΔE/kT) if Δ E > 0\. When applied
    to the Ising model, this Markov chain is ergodic (similar to Google PageRank requirement)
    so the theory underlying the Metropolis algorithm applies. Converges to stationary
    distribution.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Metropolis算法。*蒙特卡罗方法的广泛使用始于Metropolis算法，用于计算刚性球体系统。在Metropolis、Rosenbluth、Rosenbluth、Teller和Teller之间的晚餐交谈后于1953年发表。广���用于研究原子系统的平衡性质。使用马尔可夫链采样，使用Metropolis规则：如果ΔE
    <= 0，则从A转换到B的概率为1，如果ΔE > 0，则为e^(-ΔE/kT)的概率。当应用于Ising模型时，这个马尔可夫链是遍历的（类似于Google
    PageRank的要求），因此Metropolis算法的理论适用。收敛到稳态分布。'
- en: Program [Cell.java](Cell.java.html), [State.java](State.java.html), and [Metropolis.java](Metropolis.java.html)
    implements the Metropolis algorithm for a 2D lattice. [Ising.java](Ising.java.html)
    is a procedural programming version. "Doing physics by tossing dice." Simulate
    complicated physical system by a sequence of simple random steps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[Cell.java](Cell.java.html)、[State.java](State.java.html)和[Metropolis.java](Metropolis.java.html)实现了2D晶格的Metropolis算法。[Ising.java](Ising.java.html)是一种过程式编程版本。"通过掷骰子来做物理学。"通过一系列简单的随机步骤模拟复杂的物理系统。
- en: Measuring physical quantities. Measure magnetism, energy, specific heat when
    system has thermalized (the system has reached a thermal equilibrium with its
    surrounding environment at a common temperature T). Compute the average energy
    <e>and the average magenetization <m>over time. Also interesting to compute the
    variance of the energy or *specific heat* <c> = <E²> - <E>², and the variance
    of the magnetization or *susceptibility* <Χ> = <M²> - <M>². Determining when system
    has thermalized is a challenging problem - in practice, many scientists use ad
    hoc methods.</m></e>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测量物理量。当系统热化（系统已经达到与其周围环境的共同温度T的热平衡）时，测量磁性、能量、比热。随时间计算平均能量<e>和平均磁化<m>。还有计算能量的方差或*比热*<c>
    = <E²> - <E>²，以及磁化的方差或*磁化率*<Χ> = <M²> - <M>²。确定系统何时热化是一个具有挑战性的问题-在实践中，许多科学家使用专门的方法。</m></e>
- en: '*Phase transition.* Phase transition occurs when temperature T[c] is 2 / ln(1
    + sqrt(2)) = 2.26918). T[c] is known as the Curie temperature. Plot magnetization
    M (average of all spins) vs. temperature (kT = 1 to 4). Discontinuity of slope
    is signature of *second order phase transition*. Slope approaches infinity. Plot
    energy (average of all spin-spin interactions) vs. temperature (kT = 1 to 4).
    Smooth curve through phase transition. Compare against [exact solution](http://www.nyu.edu/classes/tuckerman/stat.mech/lectures/lecture_26/node2.html).
    Critical temperature for which algorithm dramatically slows down. Below are the
    5000th sample trajectory for J/kT = 0.4 (hot / disorder) and 0.47 (cold / order).
    The system becomes magnetic as temperature decreases; moreover, as temperature
    decreases the probability that neighboring sites have the same spin increasing
    (more clumping).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*相变。* 当温度T[c]为2 / ln(1 + sqrt(2)) = 2.26918时，相变发生。T[c]被称为居里温度。绘制磁化M（所有自旋的平均值）与温度（kT
    = 1至4）的关系。斜率的不连续是*二阶相变*的标志。斜率趋近于无穷大。绘制能量（所有自旋-自旋相互作用的平均值）与温度（kT = 1至4）的关系。通过相变的平滑曲线。与[精确解](http://www.nyu.edu/classes/tuckerman/stat.mech/lectures/lecture_26/node2.html)进行比较。算法明显减慢的临界温度。以下是J/kT
    = 0.4（热/无序）和0.47（冷/有序）的第5000个样本轨迹。随着温度的降低，系统变得磁性；此外，随着温度的降低，相邻位置具有相同自旋的概率增加（更多聚集）。'
- en: Experiments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实验。
- en: Start will above critical temperature. State converges to nearly uniform regardless
    of initial state (all up, all down, random) and fluctuates rapidly. Zero magnetization.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远高于临界温度开始。状态收敛到几乎均匀，不受初始状态（全部上、全部下、随机）的影响，并且波动迅速。零磁化。
- en: Start well below critical temperature. Start all spins with equal value (all
    up or all down). A few small clusters of opposite spin form.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远低于临界温度开始。所有自旋都具有相同的值（全部上或全部下）。形成一些小的相反自旋团簇。
- en: Start well below critical temperature. Start with random spins. Large clusters
    of each spin form; eventually simulation makes up its mind. Equally likely to
    have large clusters in up or down spin.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远低于临界温度开始。从随机自旋开始。每种自旋形成大团簇；最终模拟会做出决定。大团簇在上自旋或下自旋中同等可能。
- en: Start close to critical temperature. Large clusters form, but fluctuate very
    slowly.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从接近临界温度开始。大团簇形成，但波动非常缓慢。
- en: '| ![Ising with J/kT = 0.40](../Images/c7035f5715c0714de06dad48e84d6cab.png)
    |           | ![Ising with J/kT = 0.47](../Images/47a433a69030ff78d1513618c24d1f25.png)
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ![J/kT = 0.40的伊辛模型](../Images/c7035f5715c0714de06dad48e84d6cab.png) |     
         | ![J/kT = 0.47的伊辛模型](../Images/47a433a69030ff78d1513618c24d1f25.png) |'
- en: Exact solution for Ising model known for 1D and 2D; NP-hard for 3d and nonplanar
    graphs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 伊辛模型在1D和2D中的精确解已知；在3D和非平面图中是NP难的。
- en: Models phase changes in binary alloys and spin glasses. Also models neural networks,
    flocking birds, and beating heart cells. Over 10,000+ papers published using the
    Ising model.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟二元合金和自旋玻璃中的相变。还模拟神经网络、成群的鸟类和跳动的心脏细胞。已有超过10,000篇论文使用伊辛模型。
- en: Q + A
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: Exercises
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: '**Print a random word.** Read in a list of words (of unknown length) from standard
    input, and print out one of the N words uniformly at random. Do not store the
    word list. Instead, use Knuth''s method: when reading in the ith word, select
    it with probability 1/i to be the new champion. Print out the word that survives
    after reading in all of the data.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打印一个随机单词。** 从标准输入中读取一个未知长度的单词列表，并以均匀随机的方式打印其中的一个单词。不要存储单词列表。而是使用Knuth的方法：在读取第i个单词时，以1/i的概率选择它作为新的冠军。在读取所有数据后打印出幸存的单词。'
- en: '**Random subset of a linked list.** Given an array of N elements and an integer
    k ≤ N, construct a new array containing a random subset of k elements. *Hint*:
    traverse the array, either accepting each element with probability a/b, where
    a is the number of elements left to select, and b is the number of elements remaining.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链表的随机子集。** 给定一个包含N个元素的数组和一个整数k ≤ N，构造一个包含k个元素的随机子集的新数组。*提示*：遍历数组，以a/b的概率接受每个元素，其中a是剩余要选择的元素数，b是剩余的元素数。'
- en: Creative Exercises
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Random number generation.** Can the following for computing a pseudo-random
    integer between 0 and N-1 fail? `Math.random` is guaranteed to return a floating
    point number greater than or equal to 0.0 and strictly less than 1.0.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机数生成。** 计算介于0和N-1之间的伪随机整数时，以下方法会失败吗？`Math.random`保证返回大于或等于0.0且严格小于1.0的浮点数。'
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That is, can you find a real number `x` and an integer `N` for which r equals
    N?
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，你能找到一个实数`x`和一个整数`N`，使得r等于N吗？
- en: '*Solution:* No, it can''t happen in IEEE floating point arithmetic. The roundoff
    error will not cause the result to be N, even if `Math.random` returns 0.9999999999....
    However, this method does not produce integers *uniformly* at random because floating
    point numbers are not evenly distributed. Also, it involves casting and multiplying,
    which are excessive.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* 不，这在IEEE浮点算术中是不可能发生的。舍入误差不会导致结果为N，即使`Math.random`返回0.9999999999....
    然而，这种方法并不会均匀地产生整数，因为浮点数不是均匀分布的。此外，它涉及到强制转换和乘法，这是过度的。'
- en: '**Random number test.** Write a program to plot the outcome of a boolean pseudo-random
    number generator. For simplicity, use `(Math.random() < 0.5)` and plot in a 128-by-128
    grid like the following [pseudorandom applet](http://www.alife.co.uk/nonrandom/).
    Perhaps use LFSR or `Random.nextLong() % 2`.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机数测试。** 编写一个程序来绘制布尔伪随机数生成器的结果。为简单起见，使用`(Math.random() < 0.5)`并在一个128x128的网格中绘制，就像以下的[伪随机applet](http://www.alife.co.uk/nonrandom/)。也许使用LFSR或`Random.nextLong()
    % 2`。'
- en: '**Sampling from a discrete probability distribution.** Suppose that there are
    N events and event *i* occurs with probability p[i], where p[0] + p[1] + ... +
    p[N-1] = 1. Write a program `Sample.java` that prints out 1,000 sample events
    according to the probability distribution. *Hint*: choose a random number r between
    0 and 1 and iterate from i = 0 to N-1 until p[0] + p[1] + ... + p[i] > r. (Be
    careful about floating point precision.)'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从离散概率分布中抽样。** 假设有N个事件，事件*i*以概率p[i]发生，其中p[0] + p[1] + ... + p[N-1] = 1。 编写一个名为`Sample.java`的程序，根据概率分布打印出1,000个样本事件。
    *提示*：选择一个介于0和1之间的随机数r，并从i = 0迭代到N-1，直到p[0] + p[1] + ... + p[i] > r。 （要注意浮点精度。）'
- en: '**Sampling from a discrete probability distribution.** Improve the algorithm
    from the previous problem so that it takes time proportional to log N to generate
    a new sample. *Hint*: binary search on the cumulative sums. *Note*: see [this
    paper](http://citeseer.nj.nec.com/591481.html) for a very clever alternative that
    generates random samples in a constant amount of time. [Discrete.java](Discrete.java.html)
    is a Java version of Warren D. Smith''s WDSsampler.c program.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从离散概率分布中抽样。** 改进前一个问题的算法，使其生成新样本的时间与log N成正比。 *提示*：在累积和上进行二分查找。 *注意*：参见[这篇论文](http://citeseer.nj.nec.com/591481.html)，其中提供了一个非常巧妙的替代方案，可以在恒定的时间内生成随机样本。
    [Discrete.java](Discrete.java.html)是Warren D. Smith的WDSsampler.c程序的Java版本。'
- en: '**Sampling from a discrete probability distribution.** Repeat the previous
    question but make it dynamic. That is, after each sample, the probabilities of
    some events might change, or there may be new events. Used in *n-fold way algorithm*,
    which is method of choice for *kinetic Monte Carlo methods* where one wants to
    simulate the kinetic evolution process. Typical application: simulating gas reacting
    with surface of a substrate where chemical reaction occur at different rates.
    *Hint*: use a binary search tree.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从离散概率分布中抽样。** 重复上一个问题，但使其动态化。 也就是说，在每个样本之后，一些事件的概率可能会改变，或者可能会有新事件发生。 用于*n倍算法*，这是*动力学蒙特卡洛方法*的首选方法，其中希望模拟动力学演化过程。
    典型应用：模拟气体与基板表面反应，化学反应发生在不同速率的情况。 *提示*：使用二叉搜索树。'
- en: '**Zipf distribution.** Use the result of the previous exercise(s) to sample
    from the [Zipfian distribution](http://en.wikipedia.org/wiki/Zipf''s_law) with
    parameter s and N. The distribution can take on integer values from 1 to N, and
    takes on value k with probability 1/k^s / sum_(i = 1 to N) 1/i^s. Example: words
    in Shakespeare''s play Hamlet with s approximately equal to 1.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Zipf分布。** 利用前面练习的结果从具有参数s和N的[Zipf分布](http://en.wikipedia.org/wiki/Zipf''s_law)中抽样。
    该分布可以取1到N之间的整数值，并以概率1/k^s / sum_(i = 1 to N) 1/i^s取值k。 例如：莎士比亚戏剧《哈姆雷特》中的单词，其中s约等于1。'
- en: '**Simulating a Markov chain.** Write a program [MarkovChain.java](MarkovChain.java.html)
    that simulates a Markov chain. Hint: you will need to sample from a discrete distribution.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟马尔可夫链。** 编写一个程序[MarkovChain.java](MarkovChain.java.html)来模拟马尔可夫链。 提示：您需要从离散分布中抽样。'
- en: '**DLA with non-unity sticking probability** Modify [DLA.java](DLA.java.html)
    so that the initial aggregate consists of several randomly spaced cells along
    the bottom of the lattice. This simulates string-like bacterial growth.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非单位粘附概率的DLA** 修改[DLA.java](DLA.java.html)，使初始聚集由沿着晶格底部随机间隔的几个单元格组成。 这模拟了类似细菌生长的串状生长。'
- en: '**DLA with non-unity sticking probability** Modify [DLA.java](DLA.java.html)
    to allow a sticking probability less than one. That is, if a particle has a neighbor,
    then it sticks with probability p < 1.0; otherwise, it moves at random to a neighboring
    cell which is unoccupied. This results in a gives more clustered structure, simulating
    higher bond affinity between atoms.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非单位粘附概率的DLA** 修改[DLA.java](DLA.java.html)以允许小于1的粘附概率。 也就是说，如果一个粒子有邻居，则以概率p
    < 1.0粘附；否则，它会随机移动到一个未被占据的相邻单元格。 这会导致更多聚集结构，模拟原子之间更高的键合亲和力。'
- en: '**Symmetric DLA**. Initialize the aggregate to be a single particle in the
    center of the lattice. Launch particles uniformly from a circle centered at the
    initial particle. Increase the size of the launch circle as the size of the aggregate
    increases. Name your program [SymmetricDLA.java](SymmetricDLA.java.html). This
    simulates the growth of an aggregate where the particles wander in randomly from
    infinity. Here are some tricks for [speeding up the process](http://www.oche.de/~ecotopia/dla/improvements.html).'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对称DLA**。 将聚集初始化为晶格中心的单个粒子。 从初始粒子周围的圆形均匀发射粒子。 随着聚集大小的增加，增加发射圆的大小。 将您的程序命名为[SymmetricDLA.java](SymmetricDLA.java.html)。
    这模拟了粒子从无限远处随机漫步进入聚集的生长过程��� 这里有一些加速过程的技巧[速度](http://www.oche.de/~ecotopia/dla/improvements.html)。'
- en: '| ![Symmetric Diffusion Limited Aggregation 1](../Images/00b446dde7a35a682b28042be1119e43.png)
    | ![Symmetric Diffusion Limited Aggregation 2](../Images/d676516f8363e4a3965bf78743bd4f9e.png)
    | ![Symmetric Diffusion Limited Aggregation 3](../Images/9ae380831e54f2b0ea0000099577762b.png)
    |'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![对称扩散有限聚集1](../Images/00b446dde7a35a682b28042be1119e43.png) | ![对称扩散有限聚集2](../Images/d676516f8363e4a3965bf78743bd4f9e.png)
    | ![对称扩散有限聚集3](../Images/9ae380831e54f2b0ea0000099577762b.png) |'
- en: '**Variable sticking probability**. A wandering particle which enters an empty
    site next to an occupied site is assigned a random number, indicating a potential
    direction in which the particle can move (up, down, left or right). If an occupied
    site exists on the new site indicated by the random number, then the particle
    sticks to the aggregate by occupying its current lattice site. If not, it moves
    to that site and the random walk continues. This simulates snowflake growth.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可变粘附概率**。 一个漫步的粒子进入一个空位，旁边是一个占据的位置，被分配一个随机数，表示粒子可以移动的潜在方向（上、下、左或右）。 如果新位置上存在占据的位置，则粒子通过占据其当前晶格位置而粘附到聚集体上。
    如果没有，则移动到该位置，随机行走继续。 这模拟了雪花的生长。'
- en: '**Random walk solution of Laplace''s equation.** Numerically solve Laplace''s
    equation to determine the electric potential given the positions of the charges
    on the boundary. Laplace''s equation says that the gradient of the potential is
    the sum of the second partial derivatives with respect to x and y. *See Gould
    and Tobochnik, 10.2*. Your goal is to find the function V(x, y) that satisfies
    Laplace''s equation at specified boundary conditions. Assume the charge-free region
    is a square and that the potential is 10 along the vertical boundaries and 5 along
    the horizontal ones. To solve Laplace''s equation, divide the square up into an
    N-by-N grid of points. The potential V(x, y) of cell (x, y) is the average of
    the potentials at the four neighboring cells. To estimate V(x, y), simulate 1
    million random walkers starting at cell (x, y) and continuing until they reach
    the boundary. An estimate of V(x, y) is the average potential at the 1 million
    boundary cells reached. Write a program [Laplace.java](Laplace.java.html) that
    takes three command line parameters N, x, and y and estimates V(x, y) over an
    N-by-N grid of cells where the potential at column 0 and N is 10 and the potential
    at row 0 and N is 5.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拉普拉斯方程的随机漫步解。** 数值求解拉普拉斯方程以确定给定边界上电荷位置时的电势。拉普拉斯方程表明电势的梯度是相对于x和y的二阶偏导数之和。*参见Gould和Tobochnik，10.2*。您的目标是找到满足指定边界条件的函数V(x,
    y)。假设无电荷区域是一个正方形，且沿垂直边界的电势为10，沿水平边界为5。要解决拉普拉斯方程，将正方形分成一个N×N的点网格。单元格(x, y)的电势V(x,
    y)是四个相邻单元格的电势的平均值。要估计V(x, y)，模拟100万个从单元格(x, y)开始并持续到达边界的随机漫步者。V(x, y)的估计值是达到的100万个边界单元格的平均电势。编写一个程序[Laplace.java](Laplace.java.html)，它接受三个命令行参数N、x和y，并估计N×N单元格网格上的V(x,
    y)，其中第0列和N的电势为10，第0行和N的电势为5。'
- en: 'Remark: although the boundary value problem above can be solved analytically,
    numerical simulations like the one above are useful when the region has a more
    complicated shape or needs to be repeated for different boundary conditions.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注：尽管上述边界值问题可以通过解析方法解决，但像上面的数值模拟在区域具有更复杂形状或需要为不同的边界条件重复时非常有用。
- en: simulated annealing
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟退火
- en: '**Simulating a geometric random variable.** If some event occurs with probability
    p, a geometric random variable with parameter p models the number N of independent
    trials needed between occurrence of the event. To generate a variable with the
    geometric distribution, use the following formula'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟几何随机变量。** 如果某事件以概率p发生，则具有参数p的几何随机变量模拟事件发生之间所需的独立试验次数N。要生成具有几何分布的变量，请使用以下公式'
- en: N = ceil(ln U / ln (1 - p))
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: N = ceil(ln U / ln (1 - p))
- en: where U is a variable with the uniform distribution. Use the Math library methods
    `Math.ceil`, `Math.log`, and `Math.random`.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中U是具有均匀分布的变量。使用Math库方法`Math.ceil`、`Math.log`和`Math.random`。
- en: '**Simulating an exponential random variable.** The exponential distribution
    is widely used to model the the inter-arrival time between city buses, the time
    between failure of light bulbs, etc. The probability that an exponential random
    variable with parameter λ is less than *x* is *F(x) = 1 - e^(λ x)* for *x >= 0*.
    To generate a random deviate from the distribution, use the inverse function method:
    output -ln(U) / λ where U is a uniform random number between 0 and 1.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟指数随机变量。** 指数分布广泛用于模拟城市公交车之间的到达时间、灯泡故障之间的时间等。具有参数λ的指数随机变量小于*x*的概率是*x >=
    0*时的*F(x) = 1 - e^(λ x)*。要从分布中生成随机偏差，使用反函数方法：输出-ln(U) / λ，其中U是0到1之间的均匀随机数。'
- en: '**Poisson distribution.** The Poisson distribution is useful in describing
    the fluctuations in the number of nuclei that decay in any particular small time
    interval.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**泊松分布。** 泊松分布在描述任何特定小时间间隔内衰变的核数的波动方面非常有用。'
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Simulating a Pareto random variable.** The Pareto distribution is often used
    to model insurance claims damages, financial option holding times, and Internet
    traffic activity. The probability that a Pareto random variable with parameter
    *a* is less than *x* is *F(x) = 1 - (1 + x)^(-a)* for *x >= 0*. To generate a
    random deviate from the distribution, use the inverse function method: output
    (1-U)^(-1/a) - 1, where U is a uniform random number between 0 and 1.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟帕累托随机变量。** 帕累托分布通常用于模拟保险索赔损失、金融期权持有时间和互联网流量活动。带参数*a*的帕累托随机变量小于*x*的概率是*x
    >= 0*时的*F(x) = 1 - (1 + x)^(-a)*。要从分布中生成随机偏差，使用反函数方法：输出(1-U)^(-1/a) - 1，其中U是0到1之间的均匀随机数。'
- en: '**Simulating a Cauchy random variable.** The density function of a Cauchy random
    variable is f(x) = 1/(Π(1 + x²)). The probability that a Cauchy random variable
    is less than *x* is *F(x) = 1/Π (Π/2 + arctan(x))*. To generate a random deviate
    from the distribution, use the inverse function method: output tan(Π(U - 1/2)),
    where U is a uniform random number between 0 and 1.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟柯西随机变量。** 柯西随机变量的密度函数是f(x) = 1/(Π(1 + x²))。柯西随机变量小于*x*的概率是*x >= 0*时的*F(x)
    = 1/Π (Π/2 + arctan(x))*。要从分布中生成随机偏差，使用反函数方法：输出tan(Π(U - 1/2))，其中U是0到1之间的均匀随机数。'
- en: '**Generate random point inside unit disc.** Incorrect to choose set *r* uniformly
    between 0 and 1, θ uniformly between 0.0 and 2π, and use (x, y) = (r cosθ, r sinθ).
    If you do this, more points close to center of disc. Instead, set (x, y) = (√r
    cos&theta, √r sinθ) Alternatively, generate x and y uniformly between -1 and 1
    and accept if x² + y² ≤ 1. Plot a random sequence of points using both methods
    and see the bias.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成单位圆内随机点。** 在0和1之间均匀选择*r*，在0.0和2π之间均匀选择θ，并使用(x, y) = (r cosθ, r sinθ)是不正确的。如果这样做，会更多的点靠近圆盘的中心。相反，设置(x,
    y) = (√r cosθ, √r sinθ)。或者，在-1和1之间均匀生成x和y，并在x² + y² ≤ 1时接受。使用这两种方法绘制一系列随机点并查看偏差。'
- en: '**Flipping bits.** As part of a genetic algorithm, suppose you need to flip
    N bits independently, each with probability p, where p is some very small constant.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**翻转比特。** 作为遗传算法的一部分，假设您需要独立翻转N个比特，每个比特的概率为p，其中p是一个非常小的常数。'
- en: 'Method 1: loop through N bits, generate a Bernouilli(p) random variable for
    each one and flip accordingly. Takes time proportional to N.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 1：循环遍历 N 位，为每一位生成一个 Bernouilli(p) 随机变量并相应地翻转。时间复杂度与 N 成正比。
- en: 'Method 2: generate a Geometric(p) random variable X_0 and flip bit X_0; genereate
    another Geometric(p) random variable an flip bit X_0 + X_1, and so on. Takes time
    proportional to Np.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 2：生成一个几何分布(p) 随机变量 X_0 并翻转位 X_0；生成另一个几何分布(p) 随机变量并翻转位 X_0 + X_1，依此类推。时间复杂度与
    Np 成正比。
- en: 'Method 3: the number of bits to flip in Binomial(N, p). Determine how many
    bits to flip by approximating with a Gaussian(Np, sigma) random variable. Then
    flip Z bits, taking care not to avoid duplicates. Takes time proportional to Np,
    but less calls to transcendental functions.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 3：在二项分布(N, p) 中翻转的位数。通过用高斯分布(Np, sigma) 随机变量近似来确定要翻转的位数。然后翻转 Z 位，注意避免重复。时间复杂度与
    Np 成正比，但调用超越函数更少。
- en: '**Random point inside N-dimensional sphere.** Write a program `InsideSphere.java`
    that takes a command line parameter N and computes a random point inside an N-dimensional
    sphere with radius 1\. Generate N uniform random variables deviates x[1], ...,
    x[N] and use this point if'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**N 维球体内的随机点。** 编写一个程序`InsideSphere.java`，接受一个命令行参数 N，并计算一个半径为 1 的 N 维球体内的随机点。生成
    N 个均匀随机变量 x[1], ..., x[N]，并使用这个点如果'
- en: '|'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Otherwise repeat.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则重复。
- en: '**Random point on surface of an N-dimensional sphere.** Write a program [Sphere.java](Sphere.java.html)
    that takes a command line parameter N and computes a random point on the surface
    of an N-dimensional sphere with radius 1 using Brown''s method. Brown''s method
    is to compute N independent standard normal deviates x[1], x[N]. Then'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**N 维球面上的随机点。** 编写一个程序[Sphere.java](Sphere.java.html)，接受一个命令行参数 N，并使用布朗方法计算
    N 维球面上半径为 1 的随机点。布朗方法是计算 N 个独立的标准正态分布变量 x[1], x[N]，然后'
- en: '|'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: has the desired distribution. Use Exercise xyz from Section 3 to compute standard
    normal deviates.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有所需分布。使用第 3 节中的练习 xyz 来计算标准正态分布变量。
- en: '**Potts model.** The *Potts model* is a variant of the Ising model where each
    site has q possible directions. (q = 2 corresponds to Ising) The total energy
    of the system E = sum of - J sigma(s[i], s[j]) over all neighbors. The [Kronecker
    delta](http://en.wikipedia.org/wiki/Kronecker_delta) function δ(x, y) = 1 if x
    = y and 0 otherwise.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波茨模型。** *波茨模型* 是伊辛模型的一个变种，其中每个位置有 q 个可能的方向。（q = 2 对应于伊辛模型）系统的总能量 E = 所有邻居之间的
    - J sigma(s[i], s[j]) 的总和。[Kronecker delta](http://en.wikipedia.org/wiki/Kronecker_delta)
    函数 δ(x, y) = 如果 x = y 则为 1，否则为 0。'
- en: '**2D Brownian motion.** Simulate diffusion of particles in a fluid. Write a
    data type [BrownianParticle.java](BrownianParticle.java.html) that represents
    a particle undergoing a Brownian motion in two dimensions. To do this, simulate
    two indepedent Brownian motions X(t) and Y(t), and plot (X(t), Y(t)). Create a
    client program that takes a command line integer N, creates N particles at the
    origin, and simulates a Brownian motion for the N particles.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2D 布朗运动。** 模拟粒子在流体中的扩散。编写一个数据类型[BrownianParticle.java](BrownianParticle.java.html)，表示一个在二维空间中经历布朗运动的粒子。为此，模拟两个独立的布朗运动
    X(t) 和 Y(t)，并绘制 (X(t), Y(t))。创建一个客户端程序，接受一个命令行整数 N，将 N 个粒子放置在原点，并模拟 N 个粒子的布朗运动。'
- en: '**Brownian bridge.** A *Browian bridge* is a constratined Brownian motion,
    which is required to begin at the origin at time 0, and end at the origin at time
    T. If X(t) is a Brownian motion then Z(t) = X(t) - (t/T)X(T) is such a process.
    To plot, store the intermediate values X(t) and plot after you''ve computed X(T).'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布朗桥。** *布朗桥* 是一种受限制的布朗运动，要求在时间 0 从原点开始，并在时间 T 结束于原点。如果 X(t) 是一个布朗运动，那么 Z(t)
    = X(t) - (t/T)X(T) 就是这样一个过程。要绘制，存储中间值 X(t)，并在计算完 X(T) 后绘制。'
- en: '**Rainbow.** In 1637 Rene Descartes discovered the first scientific explanation
    for the formation of rainbows. His method involved tracing the internal reflections
    when a light ray is sent through a a spherical raindrop. Simulate the [generation
    of a rainbow](http://astro.temple.edu/~dhill001/MCRain/MCRain.html) according
    to model of large number of parallel rays hitting a spherical raindrop. When a
    light ray hit a raindrop, the ray is reflected and refracted. We use the HSB color
    format, and choose the hue h at random between 0 (red) and 1 (violet). We use
    1.33 + 0.06 * h for the refraction index of hue h. For each ray, we plot a single
    point of light, according to physical laws of refraction and reflection. Each
    point of light is then plotted in a random color that the observer will see, either
    in the primary or secondary rainbow. To perform the simulation, we choose one
    of the 7 colors uniformly at random. Then, we choose a point (x, y) in the unit
    circle, centered at (0, 0) and set the impact parameter r = sqrt(x² + y²). The
    angle of incidence θ[i] = arcsin(r) and, by Snell''s law, the angle of refraction
    θ[r] = arcsin (r / n), where *n* is the refraction index. If the light ray is
    totally reflected only once, it emerges at an angle of θ[p] = 4θ[r] - 2θ[i], contributing
    to the primary rainbow. If the light ray is totally reflected a second time, it
    emerges at an angle of θ[p] = 6θ[r] - 2θ[i] - π, contributing to the secondary
    rainbow. The intensities I[p] and I[s] of the primary and secondary rays are calculated
    according to the following transmission and reflection formulas for electromagnetic
    waves across the boundary of two media.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**彩虹。** 1637年，勒内·笛卡尔发现了对彩虹形成的第一个科学解释。他的方法涉及跟踪光线穿过球形雨滴时的内部反射。根据大量平行光线击中球形雨滴的模型，模拟[彩虹的生成](http://astro.temple.edu/~dhill001/MCRain/MCRain.html)。当光线击中雨滴时，光线会反射和折射。我们使用
    HSB 颜色格式，并随机选择色调 h 在 0（红色）和 1（紫色）之间。我们使用 1.33 + 0.06 * h 作为色调 h 的折射率。对于每条光线，我们根据折射和反射的物理定律绘制一个光点。然后，观察者将看到每个光点以随机颜色绘制，无论是在主彩虹还是次彩虹中。为了进行模拟，我们均匀随机选择
    7 种颜色中的一种。然后，我们选择单位圆中心为 (0, 0) 的点 (x, y)，并设置冲击参数 r = sqrt(x² + y²)。入射角 θ[i] =
    arcsin(r)，根据斯涅尔定律，折射角 θ[r] = arcsin (r / n)，其中 *n* 是折射率。如果光线完全反射一次，它以 θ[p] = 4θ[r]
    - 2θ[i] 的角度出射，贡献于主彩虹。如果光线完全反射第二次，它以 θ[p] = 6θ[r] - 2θ[i] - π 的角度出射，贡献于次彩虹。根据两个介质边界上的电磁波的传输和反射公式，计算主光线和次光线的强度
    I[p] 和 I[s]。'
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The color intensities I[p] and I[s] are used to determine the saturation in
    the HSB color format. Program [Rainbow.java](Rainbow.java.html) simulates this
    process.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 颜色强度 I[p] 和 I[s] 用于确定 HSB 颜色格式中的饱和度。程序 [Rainbow.java](Rainbow.java.html) 模拟了这个过程。
- en: '![Rainbow](../Images/f66c58ab1cdb1919c1a01bfda72059dc.png)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![彩虹](../Images/f66c58ab1cdb1919c1a01bfda72059dc.png)'
- en: '[Rainbow site](http://www.rebeccapaton.net/rainbows/index.htm).'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[彩虹网站](http://www.rebeccapaton.net/rainbows/index.htm)。'
