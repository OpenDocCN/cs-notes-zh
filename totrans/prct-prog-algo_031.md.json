["```\np = 11, q = 29\nn = 11 * 29 = 319\ne = 3\nd = 187\n\n```", "```\nm    = 100\nE(m) = 1003 (mod 319) \n     = 254\n\n```", "```\nc    = 254\nD(c) = 254187 (mod 319) = 100\n\n```", "```\n    REPEAT\n        x = random N-bit integer\n    UNTIL (x is prime)\n\n    ```", "```\n    private final static SecureRandom random = new SecureRandom();\n    BigInteger ONE = new BigInteger(\"1\");\n    BigInteger p   = BigInteger.probablePrime(N/2, random);\n    BigInteger q   = BigInteger.probablePrime(N/2, random);\n    BigInteger n   = p.multiply(q);\n    BigInteger phi = (p.subtract(ONE)).multiply(q.subtract(ONE));\n    BigInteger e   = new BigInteger(\"65537\");\n    BigInteger d   = e.modInverse(phi);\n\n    BigInteger rsa(BigInteger a, BigInteger b, BigInteger c) {\n        return a.modPow(b, n);\n    }\n\n    ```", "```\n    EXTENDED-EUCLID(p, q)\n       if q = 0\n          then return (p, 1, 0)\n       (d', a', b') return (d, x, y)\n\n    ```", "```\n    boolean isProbablyPrime(BigInteger n, int t) {\n       Compute r and s such that n-1 = 2sr and r is odd\n       Repeat from 1 to t {\n          Choose a random integer a such that 1 < a < n - 1 \n          Compute y = ar mod n by repeated squaring\n          If y \u2260 1 and y \u2260 n-1 {\n             j = 1 \n             while (j < s and y \u2260 n-1)\n                y = y2 mod n \n                if (y == 1) return false\n                j = j + 1\n             if y \u2260 n-1 return false\n       }\n       return true\n    }\n\n    ```", "```\n    xy = (a + 2Nb) (c + 2N d)\n       = ac + [(a+b)(c+d) - ac - bd] 2N + bd 22N\n\n    ```", "```\n    import java.security.MessageDigest;\n    ...\n    MessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n    sha1.update(s.getBytes());\n    Byte[] hash = sha1.digest();\n\n    ```", "```\n    // key generation\n    KeyPairGenerator keygen = KeyPairGenerator.getInstance(\"DSA\");\n    SecureRandom random     = new SecureRandom();\n    keygen.initialize(512, random);\n    KeyPair keys     = keygen.generateKeyPair();\n    PublicKey pubkey = keys.getPublic();\n    PrivateKey prikey = keys.getPrivate();\n\n    // digital signing\n    Signature signer = Signature.getInstance(\"DSA\");\n    signer.initSign(prikey); \n    signer.update(s.getBytes());\n    Byte[] signature = signer.sign();\n\n    // verifying\n    Signature verifier = Signature.getInstance(\"DSA\");\n    verifier.initVerify(pubkey); \n    verifier.update(t.getBytes());\n    Boolean check = verifier.verify(signature);\n\n    ```", "```\n    10 = 1    (10 = 1 = 1)\n    111 = 1 1    (31 = 3 = 1 1)\n    10110 = 01 10 01    (52 = 25 = 1 2 1)\n    10111 = 01 11 11 01    (53 = 125 = 1 3 3 1)\n    1001100 = 001 100 110 100 001  1 4 6 4 1  (94 = 6561 = 1 4 6 4 1)\n    10001101 = 0001 0101 1010 1010 0101 0001   (175 = 1419857)\n\n    ```"]