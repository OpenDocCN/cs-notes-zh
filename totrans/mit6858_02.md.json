["```\n void read_req() {\n      char buf[128];\n      int i;\n      gets(buf);\n      //. . . do stuff w/buf . . .\n    } \n```", "```\n %esp points to the last (bottom-most) valid thing on\n  the stack.\n\n  %ebp points to the caller's %esp value.\n\n                     +------------------+\n    entry %ebp ----> | .. prev frame .. |\n                     |                  |  |\n                     |                  |  | stack grows down\n                     +------------------+  |\n    entry %esp ----> |  return address  |  v\n                     +------------------+\n    new %ebp ------> |    saved %ebp    |\n                     +------------------+\n                     |     buf[127]     |\n                     |       ...        |\n                     |      buf[0]      |\n                     +------------------+\n    new %esp ------> |        i         |\n                     +------------------+ \n```", "```\n void foo(int *p) {\n        int offset;\n        int *z = p + offset;\n        if(offset > 7){\n            bar(offset);\n        }\n    } \n```", "```\n |                  |\n                     +------------------+\n    entry %esp ----> |  return address  |    ^\n                     +------------------+    |\n    new %ebp ------> |    saved %ebp    |    |\n                     +------------------+    |\n                     |     CANARY       |    | Overflow goes\n                     +------------------+    | this way.\n                     |     buf[127]     |    |\n                     |       ...        |    |\n                     |      buf[0]      |    |\n                     +------------------+\n                     |                  | \n```", "```\n int *ptr = ...;\n    char buf[128];\n    gets(buf);  // Buffer is overflowed, and overwrites ptr.\n    *ptr = 5;   // Writes to an attacker-controlled address!\n              // Canaries can't stop this kind of thing. \n```", "```\n int main(int argc, char **argv) {\n        char *p, *q;\n\n        p = malloc(1024);\n        q = malloc(1024);\n        if(argc >= 2)\n            strcpy(p, argv[1]);\n        free(q);\n        free(p);\n        return 0;\n    } \n```", "```\n +----------------+  \n        |                |     \n        |   App data     |     \n        |                |      Allocated memory block\n        +----------------+     \n        |   size         |     \n        +----------------+  \n\n        +----------------+\n        |   size         |\n        +----------------+\n        |  ...empty...   |\n        +----------------+  \n        |   bkwd ptr     |     \n        +----------------+          \n        |   fwd ptr      |      Free memory block\n        +----------------+     \n        |   size         |     \n        +----------------+ \n```", "```\n p = get_free_block_struct(size);\n    bck = p->bk;\n    fwd = p->fd;\n    fwd->bk = bck;  // Writes memory!\n    bck->fd = fwd;  // Writes memory! \n```", "```\n union u{\n        int i;\n        struct s{\n            int j;\n            int k;\n        };\n    };\n\n    int *ptr = &(u.s.k); // Does this point to valid data? \n```", "```\n +---------+\n    | Guard   |\n    |         |  ^\n    +---------+  | Overflows cause a page exception\n    |  Heap   |  |\n    |  obj    |  |\n    +---------+ \n```", "```\n Regular 32-bit pointer  \n     +-----------------+\n     | 4-byte address  |\n     +-----------------+\n\n    Fat pointer (96 bits)\n     +-----------------+----------------+---------------------+\n     | 4-byte obj_base | 4-byte obj_end | 4-byte curr_address |\n     +-----------------+----------------+---------------------+ \n```", "```\n int *ptr = malloc(sizeof(int) * 2);\n        while(1){\n            *ptr = 42;       <----------|\n            ptr++;                      |\n        }                               |\n          ______________________________|\n         |\n\n    This line checks the current address of the pointer and\n    ensures that it's in-bounds. Thus, this line will fail\n    during the third iteration of the loop. \n```", "```\n slot_size = 16\n\n    p = malloc(16);  -->  table[p/slot_size] = 4;\n    p = malloc(32);  -->  table[p/slot_size] = 5;\n                     \\->  table[(p/slot_size) + 1] = 5; \n```", "```\n C code\n    ------ \n    p' = p + i;\n\n    Bounds check\n    ------------\n    size = 1 << table[p >> log_of_slot_size];\n    base = p & ~(size - 1);\n    (p' >= base) && ((p' - base) < size)\n\n    Optimized bounds check\n    ----------------------\n    (p^p') >> table[p >> log_of_slot_size] == 0 \n```", "```\n char *p = malloc(44);     //Note that the nearest power of 2 (i.e.,\n                              //64 bytes) are allocated. So, there are\n                              //64/(slot_size) = 4 bounds table entries\n                              //that are set to log_2(64) = 6.\n\n    char *q = p + 60;         //This access is ok: It's past p's object\n                              //size of 44, but still within the baggy\n                              //bounds of 64.\n    char *r = q + 16;         //r is now at an offset of 60+16=76 from\n                              //p. This means that r is (76-64)=12 bytes\n                              //beyond the end of p. This is more than\n                              //half a slot away, so baggy bounds will\n                              //raise an error.\n\n    char *s = q + 8;          //s is now at an offset of 60+8=68 from p.\n                              //So, s is only 4 bytes beyond the baggy\n                              //bounds, which is les than half a slot\n                              //away. No error is raised, but the OOB\n                              //high-order bit is set in s, so that s\n                              //cannot be dereferenced.\n    char *t = s - 32;         //t is now back inside the bounds, so\n                              //the OOB bit is cleared. \n```", "```\n char *p = malloc(256);\n    char *q = p + 256;\n    char ch = *q;  // Does this raise an exception?\n                   // Hint: How big is the baggy bound for p? \n```", "```\n char *p = malloc(44); // Note that the nearest power of 2 (i.e.,\n                          // 64 bytes) are allocated. So, there are\n                          // 64/(slot_size) = 4 bounds table entries\n                          // that are set to log_2(64) = 6.\n    char *q = p + 60;     // This access is ok: It's past p's object\n                          // size of 44, but still within the baggy\n                          // bounds of 64.\n    char *r = q + 16;     // ERROR: r is now at an offset of 60+16=76\n                          // from p. This means that r is (76-64)=12\n                          // beyond the end of p. This is more than\n                          // half a slot away, so baggy bounds will\n                          // raise an error.\n    char *s = q + 8;      // s is now at an offset of 60+8=68 from p.\n                          // So, s is only 4 bytes beyond the baggy\n                          // bounds, which is less than half a slot\n                          // away. No error is raised, but the OOB\n                          // high-order bit is set in s, so that s\n                          // cannot be derefernced.\n    char *t = s - 32;     // t is now back inside the bounds, so\n                          // the OOB bit is cleared. \n```", "```\n char *p = malloc(255);\n    char *q = p + 256;\n    char ch = *q;  // Does this raise an exception?\n                   // Hint: How big is the baggy bound for p? \n```", "```\n Contiguous range of\n    memory used for the\n    heap\n\n    +-------------------+\n    |                   |\n    |                   |\n    | Heap allocated by |\n    |   uninstrumented  |---+\n    |       code        |    \\      Bounds table\n    |                   |     \\\n    +-------------------+      \\   +-----------+\n    |                   |       +->|           |\n    |                   |          | Always 31 |\n    | Heap allocated by |          |           |\n    | instrumented code |          +-----------+\n    |                   |          | Set using |\n    |                   |--------->| baggy bnds|\n    +-------------------+          +-----------+ \n```", "```\n Regular pointer       \n    +---------------+-------+------------------------+\n    |      zero     |  size |   supported addr space |\n    +---------------+-------+------------------------+\n            21          5             38\n\n  OOB pointer\n    +--------+------+-------+------------------------+\n    | offset | size |  zero |   supported addr space |\n    +--------+------+-------+------------------------+\n        13      5       8             38 \n```", "```\n struct {\n        char buf[256];\n        void (*f) (void);\n    } my_type; \n```", "```\n void run_shell(){\n        system(\"/bin/bash\");\n    }\n\n    void process_msg(){\n        char buf[128];\n        gets(buf);\n    } \n```", "```\n +------------------+\n    entry %ebp ----> | .. prev frame .. |\n                     |                  |  \n                     |                  |\n                     +------------------+\n    entry %esp ----> |  return address  | ^    <--Gets overwritten \n                     +------------------+ |       with address of\n    new %ebp ------> |    saved %ebp    | |       run_shell()\n                     +------------------+ |\n                     |     buf[127]     | |\n                     |       ...        | |\n                     |      buf[0]      | |\n    new %esp ------> +------------------+ \n```", "```\n char *bash_path = \"/bin/bash\";\n\n   void run_cmd(){\n       system(\"/something/boring\");\n   }\n\n   void process_msg(){\n       char buf[128];\n       gets(buf);\n   } \n```", "```\n |        ...       |\n                 +------------------+\n                 |     argument     |  The system() argument.\n                 +------------------+\n    %esp ---->   |    return addr   |  Where system() should \n                 +------------------+  ret after it has\n                                       finished. \n```", "```\n +------------------+\n    entry %ebp ----> | .. prev frame .. |\n                     |                  |\n                     |                  |\n                     | *  - - - - - - - | ^\n                     |                  | | Address of bash_path \n                     + *  - - - - - - - | |\n                     |                  | | Junk return addr for system()\n                     +------------------+ |\n    entry %esp ----> |  return address  | | Address of system()\n                     +------------------+ | \n    new %ebp ------> |    saved %ebp    | | Junk\n                     +------------------+ |\n                     |     buf[127]     | |\n                     |       ...        | | Junk\n                     |      buf[0]      | |\n    new %esp ------> +------------------+ | \n```", "```\n     |    h\\0           | ^\n                     | *  - - - - - - - | |\n                     |    /bas          | |\n                     | *  - - - - - - - | |\n                     |    /bin          | |  <--------------------+\n                     | *  - - - - - - - | |                       |\n                     |                  | | Address of bash_path--+\n                     + *  - - - - - - - | |\n                     |                  | | Junk return addr from system()\n                     +------------------+ |\n    entry %esp ----> |  return address  | | Address of system()\n                     +------------------+ | \n    new %ebp ------> |    saved %ebp    | | Junk\n                     +------------------+ |\n                     |     buf[127]     | |\n                     |       ...        | | Junk\n                     |      buf[0]      | |\n    new %esp ------> +------------------+ | \n    ```", "```\n     pop %eax    //Pops the top-of-stack and puts it in %eax\n      ret         //Pops the top-of-stack and puts it in %eip \n    ```", "```\n |                  | ^\n                     + *  - - - - - - - + |\n                     |                  | | Address of bash_path -+ Fake calling\n                     + *  - - - - - - - + |                       | frame for\n         (4)         |                  | | Address of pop/ret  * + system()\n                     + *  - - - - - - - + | \n         (3)         |                  | | Address of system()\n                     + *  - - - - - - - + |\n         (2)         |                  | | Address of bash_path -+ Fake calling\n                     + *  - - - - - - - + |                       | frame for\n         (1)         |                  | | Address of pop/ret  * + system()\n                     +------------------+ |\n    entry %esp ----> |  return address  | | Address of system()\n                     +------------------+ | \n    new %ebp ------> |    saved %ebp    | | Junk\n                     +------------------+ |\n                     |     buf[127]     | |\n                     |       ...        | | Junk\n    new %esp ------> |      buf[0]      | |\n                     +------------------+ | \n```", "```\n char canary[8];\n    for(int i = 1; i <= 8; i++){  //For each canary byte . . .\n        for(char c = 0; c < 256; c++){  //. . . guess the value.\n            canary[i-1] = c;\n            server_crashed = try_i_byte_overflow(i, canary);\n            if(!server_crashed){\n                //We've discovered i-th byte of the\n                //the canary!\n                break;\n            }\n        }\n    } \n```", "```\n sleep(10)\n                          ^       ^\n    +--- pop rax         /         \\\n    |    ret            /           \\\n    |     \\--->[stop]  0x5....     0x5....\n    |          [trap]  0x0         0x0    <-----------------+\n    +----------[probe] 0x4...8     0x4...c -->xor rax, rax  | Crash!\n                                              ret           |\n                                                 \\__________| \n```", "```\n     |                  | ^\n                     + *  - - - - - - - + |\n                     |                  | | Guessed addr of syscall() \n                     + *  - - - - - - - + | \n                     |                  | | ...\n                     + *  - - - - - - - + | \n                     |                  | | Sys call # for pause\n                     + *  - - - - - - - + |\n                     |                  | | Address of pop rsi; ret //Gadget 2\n                     + *  - - - - - - - + | \n                     |                  | | Sys call # for pause\n                     +------------------+ |\n    entry %esp ----> |  return address  | | Address of pop rdi; ret //Gadget 1\n                     +------------------+ | \n    new %ebp ------> |    saved %ebp    | | Junk\n                     +------------------+ |\n                     |     buf[127]     | |\n                     |       ...        | | Junk\n    new %esp ------> |      buf[0]      | |\n                     +------------------+ | \n    ```", "```\n pop rdi; ret (socket)\n    pop rsi; ret (buffer)\n    pop rdx; ret (length)\n    pop rax; ret (write syscall number)\n    syscall \n```"]