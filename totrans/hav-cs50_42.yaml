- en: Lecture 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/r/notes/4/](https://cs50.harvard.edu/r/notes/4/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[dplyr](#dplyr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`select`](#select)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`filter`](#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pipe Operator](#pipe-operator)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`arrange`](#arrange)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`distinct`](#distinct)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing Data](#writing-data)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`group_by`](#group_by)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`summarize`](#summarize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ungroup`](#ungroup)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[tidyr](#tidyr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tidy Data](#tidy-data)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Normalizing](#normalizing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pivoting](#pivoting)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[stringr](#stringr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Welcome back to CS50’s Introduction to Programming with R!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we will be learning about tidying data. Indeed, you can imagine many
    times when tables and data may not be in the shape one would hope!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Packages* are bits of code created by developers that we can install and load
    into our R programs. These packages can give one functionality within R that does
    not come natively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages are stored in R’s *library*. As such, you can load packages with the
    `library` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dplyr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[dplyr](https://dplyr.tidyverse.org/) is a package within the [tidyverse](https://www.tidyverse.org/)
    that includes functions to manipulate data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within dplyr, a data set called `storms` is included, which includes observations
    of storm data from [NOAA](https://www.noaa.gov/), the United States’ National
    Oceanic and Atmospheric Administration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After loading dplyr or the tidyverse, the `storms` data set can be loaded by
    simply typing `storms` in the R console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon typing `storms` notice that a *tibble* is displayed. A *tibble* is tidyverse’s
    “reimagining” of R’s data frame. Notice how rows, row numbers, and various columns
    are included and labeled. Further, notice the text color that is employed in the
    *tibble*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s locate the strongest storm in the data set. First, let’s remove the columns
    we don’t need. Consider the following program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how the `select` function within dplyr allows one to determine which
    columns will be included in a data frame or tibble. `select`’s first argument
    is the data frame (or tibble) to operate on: `storms`. `select`’s second argument
    is the vector of columns to be selected. In this case, however, a `!` is employed:
    a `!` indicates that the proceeding column names are instead to be excluded. Alternatively,
    a `-` has the same functionality. Running this code will simplify the tibble by
    removing the above columns.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Typing out all these columns is a bit cumbersome!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helper functions like `contains`, `starts_with`, or `ends_with` can help with
    this. Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `ends_with` is employed to exclude all columns that end with *diameter*.
    Less code is employed, but the result is the same as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`filter`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another helpful function is `filter`, which can be used to filter rows from
    the data frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the only rows included are those that include `hurricane` in the
    `status` column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice how the latest examples have dropped the `dplyr::` syntax in the first
    example. Turns out you don’t need to name the specific package in which a function
    is defined, unless two or more packages define a function with the same name.
    In that case, you’ll need to remove ambiguity by specifying which package’s function
    you want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R, the *pipe operator* is signified by `|>`, which allows one to “pipe”
    data into a specific function. For example, consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `storms` is piped to `select`, implicitly becoming `select`’s first
    argument. Then, notice how the return value of `select` is piped to `filter`,
    implicitly becoming `filter`’s first argument. When you use the pipe operator,
    you can avoid nesting function calls and write your code more sequentially.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`arrange`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s use the `arrange` function to sort our rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the return value of the `select` function is piped to `filter`, the
    return value of which is then piped to `arrange`. The rows in the resulting data
    frame are arranged in descending order by value of the `wind` column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`distinct`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may notice that this tibble includes many rows of the same storm. Because
    this data includes many observations of the same storms, this is not a surprise.
    However, would it not be nice to be able to find only *distinct* storms?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `distinct` function allows one to get back distinct items in our tibble.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinct returns distinct rows finding duplicate rows and returning the first
    row from the set of duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `distinct` will consider rows to be duplicate only if *all* values
    in a row match *all* values in another row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, you can tell `distinct` which values to consider when determining
    whether rows are duplicates. Consider the following code that leverages this ability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `distinct` is told to only look at the `name` and `year` of each
    storm to determine if it is a distinct item. `.keep_all = TRUE` tells `distinct`
    to still return all the columns for each row.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Writing Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s possible for us to save our data for later in a CSV file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the result of the first block of code is stored as `hurricanes`.
    To store `hurricanes` as a CSV file, `select` first chooses 3 particular columns
    (`year`, `name`, and `wind`) which are written to a file named `hurricanes.csv`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`group_by`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now find the most powerful hurricane in each year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `hurricanes.csv` is read into `hurricanes`. Then, the function `group_by`
    is employed to group together all hurricanes in each year. For each group, the
    group is arranged in descending order by `wind` using `arrange(desc(wind))`. Finally,
    `slice_head` is used to output the top row from each group. Thus, the strongest
    storm from each year is presented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`slice_max` selects the largest values within a variable. Consider how this
    can be employed in our code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `hurricanes` is grouped by `year`. Then, the highest value of `wind`
    is presented using `slice_max`. Doing so eliminates the need for `arrange(desc(wind))`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`summarize`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if we wanted to know the number of hurricanes each year? Consider the
    following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the function `summarize`, employing `n`, counts the number of rows
    in each group.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ungroup`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Looking at our `hurricanes` data frame, you will notice that there are groups
    present. Indeed, these groups are by `year`. There will be times in future activities
    where you may wish to ungroup items within your data. Accordingly, consider the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `ungroup` command is employed to remove the groups of the tibble.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tidyr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: dplyr is quite useful when data is already well organized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about situations where the data is not already well organized?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For that, the tidyr package can be useful!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tidy Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the philosophy of the tidyverse, there are three principles that
    guide what we would call *tidy data*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When evaluating data, best to look at the above three principles to see if they
    are observed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Normalizing* is the process of converting data such that they fulfill the
    aforementioned principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalizing can also refer to converting data such that they fulfill better
    design principles beyond the above guidelines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download the `students.csv` file from the course files and place it in your
    working directory. Create new code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code loads a CSV file called `students.csv` and stores these
    values in `students`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examining this data, you may see how they do not follow the principles we mentioned
    previously. Which principles do you observe not being followed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivoting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `students` data set, you might notice there are row values that should
    instead be column names: “major” and “GPA.” To be clear, this data set violates
    the second principle of tidy data: each way a student can vary is *not* a column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can *pivot* the data set to turn those variables into columns, thanks to
    `pivot_wider`! `pivot_wider` transforms a data set that is “longer” than it should
    be (i.e., one with variables as row values) and makes it “wider” (i.e., turns
    those variables into columns).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pivot_wider` will transform the `students` data set from the below:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![`students` before pivoting](../Images/b2abe2d0d26093da0fd1d68a9802293f.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'into the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![`students` after pivoting](../Images/7ba32632526b205660d8d18e34b724bf.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'But how? Consider the following usage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how `pivot_wider` takes several arguments, explained here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first is the data set to operate on, `students`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument, `id_cols`, specifies which column should ultimately be
    unique in the transformed data set. Notice how, before `pivot_wider`’s transformation,
    there are duplicate values in the `student` column. After `pivot_wider`’s transformation,
    there are unique values in the `student` column.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third argument, `names_from`, specifies which column contains values that
    should instead be variables (columns). Notice how the values in the `attribute`
    column become columns themselves after `pivot_wider`’s transformation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the fourth argument, `values_from`, specifies the column from which
    to populate the values of the new columns. Notice how the values in the `value`
    column are used to populate the new columns after `pivot_wider`’s transformation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because our data is so much more tidy, we can do so much more with the data!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this program leverages `pivot_wider` and tidyr to discover the average
    GPA of the students. `GPA` in `students` is converted to a numeric value. Then,
    pipe syntax is used to find the mean of the GPAs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stringr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process we described above works well when the values themselves are clean.
    However, what about when the values themselves aren’t tidy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringr` offers us a means by which to tidy strings. Download `shows.csv`
    from the course files and place this file in your working directory. Consider
    the following program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how shows are grouped by `show`. Then, the number of `votes` is computed.
    Finally, the `votes` are sorted in descending order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Looking at the result of this program, you can see that there are many versions
    of *Avatar: The Last Airbender*. We should probably address the whitespace issues
    first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `str_trim` is used to remove whitespace in the front or end of each
    record. `str_squish` is then used to remove extra whitespace *between* the characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While all this is very good, there are still some inconsistencies with capitalization.
    We can resolve as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `str_to_title` is used to force title casing on each string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can address spelling variants of *Avatar: The Last Airbender*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how `str_detect` is used to locate instances of `Avatar`. Each of these
    is converted to `Avatar: The Last Airbender`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While these tools can be quite helpful, consider cases where you may need to
    employ caution and not overwrite correct entries. For example, there are many
    movies called *Avatar*! How do we know whether voters didn’t mean to vote for
    those movies?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lesson, you learned how to tidy data in R. Specifically, you learned
    three new packages, which are each part of the tidyverse:'
  prefs: []
  type: TYPE_NORMAL
- en: dplyr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tidyr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stringr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time when we discuss how to visualize our data.
  prefs: []
  type: TYPE_NORMAL
