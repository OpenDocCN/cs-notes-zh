- en: Lecture 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/python/notes/5/](https://cs50.harvard.edu/python/notes/5/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Unit Tests](#unit-tests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`assert`](#assert)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`pytest`](#pytest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing Strings](#testing-strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Organizing Tests into Folders](#organizing-tests-into-folders)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, you have been likely testing your own code using `print` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you may have been relying upon CS50 to test your code for you!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s most common in industry to write code to test your own programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your console window, type `code calculator.py`. Note that you may have previously
    coded this file in a previous lecture. In the text editor, make sure that your
    code appears as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that you could plausibly test the above code on your own using some obvious
    numbers such as `2`. However, consider why you might want to create a test that
    ensures that the above code functions appropriately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Following convention, let’s create a new test program by typing `code test_calculator.py`
    and modify your code in the text editor as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are importing the `square` function from `calculator.py` on the
    first line of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the console window, type `python test_calculator.py`. You’ll notice that
    nothing is being outputted. It could be that everything is running fine! Alternatively,
    it could be that our test function did not discover one of the “corner cases”
    that could produce an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, our code tests two conditions. If we wanted to test many more conditions,
    our test code could easily become bloated. How could we expand our test capabilities
    without expanding our test code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python’s `assert` command allows us to tell the interpreter that something,
    some assertion, is true. We can apply this to our test code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are definitively asserting what `square(2)` and `square(3)` should
    equal. Our code is reduced from four test lines down to two.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can purposely break our calculator code by modifying it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have changed the `*` operator to a `+` in the square function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now running `python test_calculator.py` in the console window, you will notice
    that an `AssertionError` is raised by the interpreter. Essentially, this is the
    interpreter telling us that one of our conditions was not met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the challenges that we are now facing is that our code could become
    even more burdensome if we wanted to provide more descriptive error output to
    our users. Plausibly, we could code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that running this code will produce multiple errors. However, it’s not
    producing all the errors above. This is a good illustration that it’s worth testing
    multiple cases such that you might catch situations where there are coding mistakes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The above code illustrates a major challenge: How could we make it easier to
    test your code without dozens of lines of code like the above?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`assert`](https://docs.python.org/3/reference/simple_stmts.html#assert).
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pytest` is a third-party library that allows you to unit test your program.
    That is, you can test your functions within your program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To utilize `pytest` please type `pip install pytest` into your console window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before applying `pytest` to our own program, modify your `test_square` function
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the above code asserts all the conditions that we want to test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pytest` allows us to run our program directly through it, such that we can
    more easily view the results of our test conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the terminal window, type `pytest test_calculator.py`. You’ll immediately
    notice that output will be provided. Notice the red `F` near the top of the output,
    indicating that something in your code failed. Further, notice that the red `E`
    provides some hints about the errors in your `calculator.py` program. Based upon
    the output, you can imagine a scenario where `3 * 3` has outputted `6` instead
    of `9`. Based on the results of this test, we can go correct our `calculator.py`
    code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have changed the `+` operator to a `*` in the square function,
    returning it to a working state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Re-running `pytest test_calculator.py`, notice how no errors are produced. Congratulations!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the moment, it is not ideal that `pytest` will stop running after the first
    failed test. Again, let’s return our `calculator.py` code back to its broken state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have changed the `*` operator to a `+` in the square function,
    returning it to a broken state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To improve our test code, let’s modify `test_calculator.py` to divide the code
    into different groups of tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have divided the same five tests into three different functions.
    Testing frameworks like `pytest` will run each function, even if there was a failure
    in one of them. Re-running `pytest test_calculator.py`, you will notice that many
    more errors are being displayed. More error output allows you to further explore
    what might be producing the problems within your code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Having improved our test code, return your `calculator.py` code to fully working
    order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have changed the `+` operator to a `*` in the square function,
    returning it to a working state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Re-running `pytest test_calculator.py`, you will notice that no errors are found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we can test that our program handles exceptions. Let’s modify `test_calculator.py`
    to do just that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that instead of using `assert`, we are taking advantage of a function
    within the `pytest` library itself called `raises` which allows you to express
    that you expect an error to be raised. We need to go to the top of our program
    and add `import pytest` and then call `pytest.raises` with the type of error we
    are expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Again, re-running `pytest test_calculator.py`, you will notice that no errors
    are found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, it’s up to you as a coder to define as many test conditions as you
    see fit!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Pytest’s documentation of [`pytest`](https://docs.pytest.org/en/7.1.x/getting-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Testing Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going back in time, consider the following code `hello.py`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we may wish to test the result of the `hello` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider the following code for `test_hello.py`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Looking at this code, do you think that this approach to testing will work
    well? Why might this test not work well? Notice that the `hello` function in `hello.py`
    prints something: That is, it does not return a value!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can change our `hello` function within `hello.py` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we changed our `hello` function to return a string. This effectively
    means that we can now use `pytest` to test the `hello` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running `pytest test_hello.py`, our code will pass all tests!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with our previous test case in this lesson, we can break out our tests separately:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the above code separates our test into multiple functions such that
    they will all run, even if an error is produced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Organizing Tests into Folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing code using multiple tests is so common that you have the ability
    to run a whole folder of tests with a single command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, in the terminal window, execute `mkdir test` to create a folder called
    `test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, to create a test within that folder, type in the terminal window `code
    test/test_hello.py`. Notice that `test/` instructs the terminal to create `test_hello.py`
    in the folder called `test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, modify the file to include the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are creating a test just as we did before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pytest` will not allow us to run tests as a folder simply with this file (or
    a whole set of files) alone without a special `__init__` file. In your terminal
    window, create this file by typing `code test/__init__.py`. Note the `test/` as
    before, as well as the double underscores on either side of `init`. Even leaving
    this `__init__.py` file empty, `pytest` is informed that the whole folder containing
    `__init__.py` has tests that can be run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, typing `pytest test` in the terminal, you can run the entire `test` folder
    of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Pytest’s documentation of [import mechanisms](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.html?highlight=folder#pytest-import-mechanisms-and-sys-path-pythonpath).
  prefs: []
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing your code is a natural part of the programming process. Unit tests allow
    you to test specific aspects of your code. You can create your own programs that
    test your code. Alternatively, you can utilize frameworks like `pytest` to run
    your unit tests for you. In this lecture, you learned about…
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
