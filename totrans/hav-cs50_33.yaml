- en: Lecture 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5讲
- en: 原文：[https://cs50.harvard.edu/python/notes/5/](https://cs50.harvard.edu/python/notes/5/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/python/notes/5/](https://cs50.harvard.edu/python/notes/5/)
- en: '[Unit Tests](#unit-tests)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[单元测试](#unit-tests)'
- en: '[`assert`](#assert)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`assert`](#assert)'
- en: '[`pytest`](#pytest)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`pytest`](#pytest)'
- en: '[Testing Strings](#testing-strings)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试字符串](#testing-strings)'
- en: '[Organizing Tests into Folders](#organizing-tests-into-folders)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将测试组织到文件夹中](#organizing-tests-into-folders)'
- en: '[Summing Up](#summing-up)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Unit Tests
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Up until now, you have been likely testing your own code using `print` statements.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，你很可能一直在使用 `print` 语句测试自己的代码。
- en: Alternatively, you may have been relying upon CS50 to test your code for you!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可能一直依赖 CS50 来为你测试代码！
- en: It’s most common in industry to write code to test your own programs.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工业界，编写代码来测试自己的程序是最常见的。
- en: 'In your console window, type `code calculator.py`. Note that you may have previously
    coded this file in a previous lecture. In the text editor, make sure that your
    code appears as follows:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的控制台窗口中，输入 `code calculator.py`。注意，你可能在前面的讲座中已经编写了这个文件。在文本编辑器中，确保你的代码如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that you could plausibly test the above code on your own using some obvious
    numbers such as `2`. However, consider why you might want to create a test that
    ensures that the above code functions appropriately.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以使用一些明显的数字，例如 `2`，在你的机器上合理地测试上述代码。然而，考虑一下你为什么想要创建一个确保上述代码适当运行的测试。
- en: 'Following convention, let’s create a new test program by typing `code test_calculator.py`
    and modify your code in the text editor as follows:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例，让我们通过输入 `code test_calculator.py` 创建一个新的测试程序，并在文本编辑器中修改你的代码如下：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we are importing the `square` function from `calculator.py` on the
    first line of code.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在代码的第一行导入了 `square` 函数，来自 `calculator.py`。
- en: In the console window, type `python test_calculator.py`. You’ll notice that
    nothing is being outputted. It could be that everything is running fine! Alternatively,
    it could be that our test function did not discover one of the “corner cases”
    that could produce an error.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台窗口中，输入 `python test_calculator.py`。你会注意到没有任何输出。这可能意味着一切运行正常！或者，这也可能意味着我们的测试函数没有发现可能导致错误的“边缘情况”之一。
- en: Right now, our code tests two conditions. If we wanted to test many more conditions,
    our test code could easily become bloated. How could we expand our test capabilities
    without expanding our test code?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们的代码测试了两个条件。如果我们想要测试更多的条件，我们的测试代码可能会很容易变得臃肿。我们如何在不扩展测试代码的情况下扩展我们的测试能力？
- en: '`assert`'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assert`'
- en: 'Python’s `assert` command allows us to tell the interpreter that something,
    some assertion, is true. We can apply this to our test code as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `assert` 命令允许我们告诉解释器某个断言是真的。我们可以将此应用于我们的测试代码，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we are definitively asserting what `square(2)` and `square(3)` should
    equal. Our code is reduced from four test lines down to two.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们明确断言 `square(2)` 和 `square(3)` 应该等于什么。我们的代码从四行测试减少到两行。
- en: 'We can purposely break our calculator code by modifying it as follows:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式故意破坏计算器代码：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we have changed the `*` operator to a `+` in the square function.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在平方函数中将 `*` 运算符改为了 `+`。
- en: Now running `python test_calculator.py` in the console window, you will notice
    that an `AssertionError` is raised by the interpreter. Essentially, this is the
    interpreter telling us that one of our conditions was not met.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，在控制台窗口中运行 `python test_calculator.py`，你会注意到解释器抛出了一个 `AssertionError`。本质上，这是解释器告诉我们我们的某个条件没有满足。
- en: 'One of the challenges that we are now facing is that our code could become
    even more burdensome if we wanted to provide more descriptive error output to
    our users. Plausibly, we could code as follows:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在面临的一个挑战是，如果我们想要向用户提供更多描述性的错误输出，我们的代码可能会变得更加繁重。可能地，我们可以这样编写代码：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that running this code will produce multiple errors. However, it’s not
    producing all the errors above. This is a good illustration that it’s worth testing
    multiple cases such that you might catch situations where there are coding mistakes.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，运行此代码将产生多个错误。然而，它并没有产生上述所有错误。这是一个很好的说明，说明测试多个情况是有价值的，这样你可能会捕捉到存在编码错误的情况。
- en: 'The above code illustrates a major challenge: How could we make it easier to
    test your code without dozens of lines of code like the above?'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码说明了主要挑战：我们如何在不使用像上述那样数十行代码的情况下使测试代码更容易？
- en: You can learn more in Python’s documentation of [`assert`](https://docs.python.org/3/reference/simple_stmts.html#assert).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python 的文档中了解更多关于 `assert` 的信息：[assert](https://docs.python.org/3/reference/simple_stmts.html#assert)。
- en: '`pytest`'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pytest`'
- en: '`pytest` is a third-party library that allows you to unit test your program.
    That is, you can test your functions within your program.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 是一个第三方库，允许你对程序进行单元测试。也就是说，你可以在程序中测试你的函数。'
- en: To utilize `pytest` please type `pip install pytest` into your console window.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 `pytest`，请在控制台窗口中输入 `pip install pytest`。
- en: 'Before applying `pytest` to our own program, modify your `test_square` function
    as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将 `pytest` 应用于我们自己的程序之前，按照以下方式修改你的 `test_square` 函数：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how the above code asserts all the conditions that we want to test.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意上述代码断言了我们想要测试的所有条件。
- en: '`pytest` allows us to run our program directly through it, such that we can
    more easily view the results of our test conditions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 允许我们直接通过它运行程序，这样我们可以更容易地查看测试条件的输出结果。'
- en: 'In the terminal window, type `pytest test_calculator.py`. You’ll immediately
    notice that output will be provided. Notice the red `F` near the top of the output,
    indicating that something in your code failed. Further, notice that the red `E`
    provides some hints about the errors in your `calculator.py` program. Based upon
    the output, you can imagine a scenario where `3 * 3` has outputted `6` instead
    of `9`. Based on the results of this test, we can go correct our `calculator.py`
    code as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口中，输入 `pytest test_calculator.py`。你会立即注意到会提供输出。注意输出顶部附近的红色 `F`，表示你的代码中存在问题。此外，红色
    `E` 提供了一些关于 `calculator.py` 程序中错误的信息。根据输出，你可以想象一个场景，其中 `3 * 3` 输出了 `6` 而不是 `9`。根据这个测试的结果，我们可以按照以下方式更正
    `calculator.py` 代码：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that we have changed the `+` operator to a `*` in the square function,
    returning it to a working state.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在平方函数中将 `+` 运算符更改为 `*`，使其恢复到工作状态。
- en: Re-running `pytest test_calculator.py`, notice how no errors are produced. Congratulations!
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行 `pytest test_calculator.py`，注意没有错误产生。恭喜你！
- en: 'At the moment, it is not ideal that `pytest` will stop running after the first
    failed test. Again, let’s return our `calculator.py` code back to its broken state:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，`pytest` 在第一次测试失败后停止运行并不理想。再次，让我们将我们的 `calculator.py` 代码恢复到损坏状态：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we have changed the `*` operator to a `+` in the square function,
    returning it to a broken state.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在平方函数中将 `*` 运算符更改为 `+`，使其恢复到损坏状态。
- en: 'To improve our test code, let’s modify `test_calculator.py` to divide the code
    into different groups of tests:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了改进我们的测试代码，让我们将 `test_calculator.py` 中的代码分成不同的测试组：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we have divided the same five tests into three different functions.
    Testing frameworks like `pytest` will run each function, even if there was a failure
    in one of them. Re-running `pytest test_calculator.py`, you will notice that many
    more errors are being displayed. More error output allows you to further explore
    what might be producing the problems within your code.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们将相同的五个测试分成了三个不同的函数。像 `pytest` 这样的测试框架会运行每个函数，即使其中一个失败了。再次运行 `pytest test_calculator.py`，你会发现显示了许多更多的错误。更多的错误输出允许你进一步探索代码中可能产生问题的原因。
- en: 'Having improved our test code, return your `calculator.py` code to fully working
    order:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在改进了测试代码后，将你的 `calculator.py` 代码恢复到完全工作状态：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we have changed the `+` operator to a `*` in the square function,
    returning it to a working state.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在平方函数中将 `+` 运算符更改为 `*`，使其恢复到工作状态。
- en: Re-running `pytest test_calculator.py`, you will notice that no errors are found.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行 `pytest test_calculator.py`，你会发现没有错误发生。
- en: Finally, we can test that our program handles exceptions. Let’s modify `test_calculator.py`
    to do just that.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以测试我们的程序是否能够处理异常。让我们修改 `test_calculator.py` 来实现这一点。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that instead of using `assert`, we are taking advantage of a function
    within the `pytest` library itself called `raises` which allows you to express
    that you expect an error to be raised. We need to go to the top of our program
    and add `import pytest` and then call `pytest.raises` with the type of error we
    are expecting.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不再使用 `assert`，而是利用 `pytest` 库中的一个函数 `raises`，它允许你表达你期望抛出一个错误。我们需要将 `import
    pytest` 添加到程序顶部，然后使用 `pytest.raises` 并指定我们期望的错误类型。
- en: Again, re-running `pytest test_calculator.py`, you will notice that no errors
    are found.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行 `pytest test_calculator.py`，你会发现没有错误发生。
- en: In summary, it’s up to you as a coder to define as many test conditions as you
    see fit!
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结来说，作为程序员，定义多少测试条件取决于你自己的判断！
- en: You can learn more in Pytest’s documentation of [`pytest`](https://docs.pytest.org/en/7.1.x/getting-started.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Pytest的[pytest](https://docs.pytest.org/en/7.1.x/getting-started.html)文档中了解更多信息。
- en: Testing Strings
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试字符串
- en: 'Going back in time, consider the following code `hello.py`:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到过去，考虑以下`hello.py`的代码：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we may wish to test the result of the `hello` function.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们可能希望测试`hello`函数的结果。
- en: 'Consider the following code for `test_hello.py`:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下`test_hello.py`的代码：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Looking at this code, do you think that this approach to testing will work
    well? Why might this test not work well? Notice that the `hello` function in `hello.py`
    prints something: That is, it does not return a value!'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看到这段代码，你认为这种测试方法会有效吗？为什么这个测试可能不起作用？注意`hello.py`中的`hello`函数打印了一些内容：也就是说，它没有返回一个值！
- en: 'We can change our `hello` function within `hello.py` as follows:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在`hello.py`中更改我们的`hello`函数，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we changed our `hello` function to return a string. This effectively
    means that we can now use `pytest` to test the `hello` function.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们将`hello`函数更改为返回一个字符串。这意味着我们现在可以使用`pytest`来测试`hello`函数。
- en: Running `pytest test_hello.py`, our code will pass all tests!
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`pytest test_hello.py`，我们的代码将通过所有测试！
- en: 'As with our previous test case in this lesson, we can break out our tests separately:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像本课之前的测试案例一样，我们可以将测试分开进行：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the above code separates our test into multiple functions such that
    they will all run, even if an error is produced.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，上述代码将我们的测试分成多个函数，这样即使产生错误，它们也会全部运行。
- en: Organizing Tests into Folders
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将测试组织到文件夹中
- en: Unit testing code using multiple tests is so common that you have the ability
    to run a whole folder of tests with a single command.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个测试进行单元测试是如此常见，以至于你可以使用单个命令运行整个测试文件夹。
- en: First, in the terminal window, execute `mkdir test` to create a folder called
    `test`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在终端窗口中，执行`mkdir test`以创建一个名为`test`的文件夹。
- en: Then, to create a test within that folder, type in the terminal window `code
    test/test_hello.py`. Notice that `test/` instructs the terminal to create `test_hello.py`
    in the folder called `test`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在终端窗口中输入`code test/test_hello.py`以在该文件夹内创建一个测试。注意`test/`指示终端在名为`test`的文件夹中创建`test_hello.py`。
- en: 'In the text editor window, modify the file to include the following code:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本编辑窗口中，修改文件以包含以下代码：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we are creating a test just as we did before.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在创建一个测试，就像之前做的那样。
- en: '`pytest` will not allow us to run tests as a folder simply with this file (or
    a whole set of files) alone without a special `__init__` file. In your terminal
    window, create this file by typing `code test/__init__.py`. Note the `test/` as
    before, as well as the double underscores on either side of `init`. Even leaving
    this `__init__.py` file empty, `pytest` is informed that the whole folder containing
    `__init__.py` has tests that can be run.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`不会允许我们仅使用这个文件（或一组文件）作为文件夹来运行测试，而不需要一个特殊的`__init__`文件。在你的终端窗口中，通过输入`code
    test/__init__.py`创建这个文件。注意，就像之前一样，`test/`以及`init`两边的双下划线。即使这个`__init__.py`文件为空，`pytest`也会知道包含`__init__.py`的整个文件夹包含可以运行的测试。'
- en: Now, typing `pytest test` in the terminal, you can run the entire `test` folder
    of code.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，在终端中输入`pytest test`，你可以运行整个`test`文件夹中的代码。
- en: You can learn more in Pytest’s documentation of [import mechanisms](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.html?highlight=folder#pytest-import-mechanisms-and-sys-path-pythonpath).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Pytest的[导入机制](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.html?highlight=folder#pytest-import-mechanisms-and-sys-path-pythonpath)文档中了解更多信息。
- en: Summing Up
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Testing your code is a natural part of the programming process. Unit tests allow
    you to test specific aspects of your code. You can create your own programs that
    test your code. Alternatively, you can utilize frameworks like `pytest` to run
    your unit tests for you. In this lecture, you learned about…
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的代码是编程过程中的一个自然部分。单元测试允许你测试代码的特定方面。你可以创建自己的程序来测试你的代码。或者，你可以利用像`pytest`这样的框架来自动运行你的单元测试。在本讲中，你学习了关于……
- en: Unit tests
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: '`assert`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`'
- en: '`pytest`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`'
