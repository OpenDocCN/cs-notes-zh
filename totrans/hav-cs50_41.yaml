- en: Lecture 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/r/notes/3/](https://cs50.harvard.edu/r/notes/3/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining Functions](#defining-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Scope](#scope)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Checking Input](#checking-input)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Loops](#loops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Loops](#using-loops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Functions and Loops](#using-functions-and-loops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Applying Functions](#applying-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Welcome back to CS50’s Introduction to Programming with R!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we will be learning about applying functions. We will also learn how
    to write our own functions and apply loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall a program that we created during our last lecture called `count.R`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the lines repeat functionality to get input from the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Traditionally, any time in programming that we reuse code over and over again
    is regarded as an opportunity for improvement. Functions are one way by which
    we can reduce these redundancies by defining certain blocks of code we can reuse
    throughout our programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In R, functions are defined by the syntax `function()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following improved version of our program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that a new function called `get_votes` is created. The *body* of the
    function is denoted by opening and closing curly braces (`{` and `}`). Notice
    that within the body there are 2 lines of code, which will run each time this
    function is called. First, the `votes` are gathered from the user. Second, the
    `votes` are returned. `mario`, `peach` and `bowser` each receive the return value
    after `get_votes` is called. Finally, the sum of the values is provided and displayed
    to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Congratulations, this is your first function in R!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, running this function, we find that the function has lost some functionality
    that we had prior. Could there be a way we can provide a *parameter* to the function
    so we can more accurately prompt the user? Indeed, we can! Consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that a `prompt` is provided to the `get_votes` function. Thus, the user
    is prompted with the names of those they are voting for. Additionally, notice
    that the `return(votes)` statement has been removed. In R, functions automatically
    return the last computed value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Functions that have parameters may have default values assigned. Consider the
    following update to our program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a default value is offered in the first line of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can still override the default prompt as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how, for each function call, the given argument overrides the default
    argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at our environment pane in RStudio, notice that values are provided
    for `bowser` and others. However, no value for `votes` appears. Why might this
    be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turns out all objects are defined within certain “environments.” One such environment
    is the “global” environment. The global environment is home to objects you define
    in the R console or outside of a function body—objects like `mario`, `bowser`,
    and `peach`. By default, RStudio’s environment pane shows you objects defined
    in the global environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Visualization of global environment](../Images/4e21d01cbb22b2b2b5a55db2138468ee.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The `get_votes` function is also an object defined in the global environment.
    What’s unique, though, is that `get_votes` is also a kind of environment in itself!
    As you’ve seen, within the definition of `get_votes`, you can define other objects,
    like `votes` and `prompt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Visualization of `get_votes` environment](../Images/1b07a7392b73174e8a1ad91044068051.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The environment of `get_votes` is *not* the global environment. While writing
    code that operates in the global environment, objects in this environment are
    not accessible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment(s) in which an object is available is known as its “scope.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the challenges consistently facing programmers is the bad behavior of
    users. That is, we should expect, as programmers, that users will not always do
    what we want. For instance, what if a user provides a string of text instead of
    numbers for votes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can improve our program to catch incorrect values that are entered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `get_votes` will return a `0` if the value for `votes` is `NA`. Otherwise,
    `get_votes` will return the value provided by the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While this program works, it still provides warnings, which we may not want
    the user to see. We can suppress warnings as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how warnings are now suppressed when this code is run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This program can be further improved by using `ifelse`. Consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the first value of `ifelse` is a logical expression to be tested.
    The second value, `0`, is what will be returned if the first value `is.na(votes)`
    evaluates to `TRUE`. Finally, the third value, `votes`, is provided if the first
    value evaluates to `FALSE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now discovered our first fundamental ways of checking user input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we did prior, we can suppress warnings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how warnings are suppressed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One significant improvement we may desire for our program is the ability to
    repeatedly prompt the user when they make an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about loops, let’s enlist the help of the CS50 Duck Debugger!
    Quack!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this code will output quack three times. However, it’s quite inefficient!
    We are repeating the same line of code three times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We could attempt to improve this code using a *repeat loop* as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how our duck quacks multiple times, but forever. The duck is going to
    get very tired!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One of the ways we can implement a loop is by utilizing `break` and `next`.
    Such a loop will repeat a number of times by using a counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the value of `i` is set to `3`. Then each time a `quack!` occurs,
    `i` is reduced by a value of `1`. When `0` is reached, the loop will `break`.
    Otherwise (or `else`), this loop will continue with `next`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the end, `next` is not required. The loop will automatically continue without
    the `next` statement. We can remove this statement as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the loop will break when `i` is equal to `0`. However, `next` has
    been removed. The loop will still function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another type of loop at our disposal is called a *while loop*. Such a loop
    will continue as long as a certain condition has not been met. Consider the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this loop will run `while` the value of `i != 0` is true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another type of loop is called a *for loop* that allows us to repeat based
    upon a list or vector of values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a `for` loop starts the value of `i` at `1`, running the code inside
    of it. Then, it will set the value of `i` to two and run. Finally, it will set
    `i` to `3` and run. Thus, the code within the loop runs three times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can simplify our code by counting `1`, `2`, and `3` using the range `1:3`
    (one through three).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the code `i in 1:3` accomplishes the same task as the code presented
    in the prior example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use our newly-learned abilities in loops in our counting of votes for
    Mario and friends. Consider the following code that utilizes a repeat loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the user will be reprompted until the value provided is not `NA`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can further improve our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `return(votes)` clause is put in the place of `break`. The same
    functionality remains for this function, but the code is more brief.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, using our knowledge of `for` loops, we can improve our code that is repeated
    for Mario and friends:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how, instead of three separate lines to prompt the user for votes for
    each of the candidates, the `for` loop will run for the range of “Mario,” “Peach,”
    and “Bowser” to get the votes. The `paste0` statement adds the `:` character to
    each of the prompts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a final flourish, we can employ a loop to count the votes as we go:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `total` number of votes is updated in each iteration of the `for`
    loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reflecting upon the above, you can see the fundamental programming power that
    loops provide you as a programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Functions and Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s return to a case that we discussed in a previous lecture, summing up candidates’
    votes in a table like the below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Candidate votes table](../Images/8744023a53bd9ec9c3423505bd17def0.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s now use our new abilities in loops and functions to create a better program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perhaps our first goal should be to sum up the votes. Consider the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this `for` loop will iterate through each `candidate` presented in
    the `votes` data frame. Then the `sum` of the `votes` for the `candidate` will
    be stored in the `total_votes` vector. `total_votes <- c()` represents an empty
    vector that is later populated with data. `total_votes[candidate]` creates a new
    element within the vector `total_votes`, one for each candidate in each iteration
    of the loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A second goal could be to sum the `method` by which each candidate received
    votes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this `for` loop iterates through each `method` in the `colnames`
    (or column names).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Applying Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above program could be optimized further using a family of functions known
    as the `apply` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `apply` functions allow you to apply (i.e., run) a function across elements
    of a data structure. For example, the `apply` function can apply a function across
    all rows or columns in a table of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of the votes table, we can use `apply` as follows to get the `sum`
    of all the rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `sum` function is applied to all of the rows using `MARGIN =
    1`. Had we put `MARGIN = 2`, the `sum` function would have been applied to all
    of the columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can sum each column as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `MARGIN = 2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, you learned how to apply functions in R. Specifically, you learned…
  prefs: []
  type: TYPE_NORMAL
- en: Defining Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking Input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Functions and Loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time when we discuss how to clean up our data.
  prefs: []
  type: TYPE_NORMAL
