- en: 3.3 Designing Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 设计数据类型
- en: 原文：[https://introcs.cs.princeton.edu/python/33design](https://introcs.cs.princeton.edu/python/33design)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 译文：[https://introcs.cs.princeton.edu/python/33design](https://introcs.cs.princeton.edu/python/33design)
- en: In this section we focus on developing APIs as a critical step in the development
    of any program. We need to consider various alternatives, understand their impact
    on both client programs and implementations, and refine the design to strike an
    appropriate balance between the needs of clients and the possible implementation
    strategies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点放在开发API作为任何程序开发的关键步骤上。我们需要考虑各种替代方案，了解它们对客户端程序和实现的影响，并完善设计以在客户端需求和可能的实现策略之间取得适当平衡。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Designing APIs
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计API
- en: In Section 3.1, we composed client programs that use APIs; in Section 3.2, we
    implemented APIs. Now we consider the challenge of designing APIs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3.1节中，我们编写了使用API的客户端程序；在第3.2节中，我们实现了API。现在我们考虑设计API的挑战。
- en: Standards.
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准。
- en: It is easy to understand why conforming to an API is so important by considering
    other domains. From railroad tracks, to threaded nuts and bolts, to MP3s and DVDs,
    to radio frequencies, to Internet standards, we know that using a common standard
    interface enables the broadest usage of a technology. By using APIs to separate
    clients from implementations, we reap the benefits of standard interfaces for
    every program that we compose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑其他领域，很容易理解遵循API的重要性。从铁路轨道，到螺纹螺母，到MP3和DVD，到无线电频率，到互联网标准，我们知道使用共同的标准接口能够实现技术的最广泛使用。通过使用API将客户端与实现分离，我们为我们组合的每个程序获得标准接口的好处。
- en: Specification problem.
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范问题。
- en: Our APIs for data types are sets of methods, along with brief English-language
    descriptions of what the methods are supposed to do. Ideally, an API would clearly
    articulate behavior for all possible arguments, including side effects, and then
    we would have software to check that implementations meet the specification. Unfortunately,
    a fundamental result from theoretical computer science, known as the *specification
    problem*, says that this goal is actually impossible to achieve. Therefore, we
    resort to informal descriptions with examples, such as those in the text surrounding
    our APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们针对数据类型的API是一组方法，以及简短的英语描述这些方法应该做什么。理想情况下，一个API应该清晰地表达所有可能参数的行为，包括副作用，然后我们会有软件来检查实现是否符合规范。不幸的是，来自理论计算机科学的一个基本结果，即*规范问题*，表明这个目标实际上是不可能实现的。因此，我们转而采用带有示例的非正式描述，比如围绕我们的API的文本。
- en: Wide interfaces.
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宽接口。
- en: A *wide interface* is one that has an excessive number of methods. An important
    principle to follow in designing an API is to avoid wide interfaces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽接口*是具有过多方法的接口。在设计API时要遵循的一个重要原则是避免宽接口。'
- en: Start with client code.
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从客户端代码开始。
- en: One of the primary purposes of developing a data type is to simplify client
    code. Therefore, it makes sense to pay attention to client code from the start
    when designing an API. Composing two clients is even better. Starting with client
    code is one way of ensuring that developing an implementation will be worth the
    effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发数据类型的主要目的之一是简化客户端代码。因此，在设计API时，从一开始就关注客户端代码是有意义的。甚至更好的是组合两个客户端。从客户端代码开始是确保开发实现值得的一种方式。
- en: Avoid dependence on representation.
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免对表示的依赖。
- en: Usually when developing an API, we have a representation in mind. After all,
    a data type is a set of values and a set of operations defined on those values,
    and it does not make much sense to talk about the operations without knowing the
    values. But that is different from knowing the representation of the values. One
    purpose of the data type is to simplify client code by allowing it to avoid details
    of and dependence on a particular representation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在开发API时，我们心中有一个表示。毕竟，数据类型是一组值和在这些值上定义的一组操作，并且在不了解值的情况下谈论操作并没有太多意义。但这与了解值的表示是不同的。数据类型的一个目的是通过允许客户端避免对特定表示的细节和依赖来简化客户端代码。
- en: Pitfalls in API design.
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API设计中的陷阱。
- en: 'An API may be too hard to implement, implying implementations that are difficult
    or impossible to develop, or too hard to use, creating client code that is more
    complicated than without the API. An API might be too narrow, omitting methods
    that clients need, or too wide, including a large number of methods not needed
    by any client. An API may be too general, providing no useful abstractions, or
    too specific, providing abstractions so detailed or so diffuse as to be useless.
    These considerations are sometimes summarized in the motto: *provide to clients
    the methods they need and no others*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API可能太难实现，意味着难以开发或不可能开发的实现，或者太难使用，导致客户端代码比没有API更复杂。一个API可能太窄，省略了客户端需要的方法，或者太宽，包含大量任何客户端都不需要的方法。一个API可能太一般化，提供没有用的抽象，或者太具体，提供过于详细或过于分散的抽象。这些考虑有时总结为座右铭：*为客户端提供他们需要的方法，而不提供其他方法*。
- en: '* * *'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Encapsulation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: The process of separating clients from implementations by hiding information
    is known as *encapsulation*. Details of the implementation are kept hidden from
    clients, and implementations have no way of knowing details of client code, which
    may even be created in the future. We use encapsulation to enable modular programming,
    facilitate debugging, and clarify program code. These reasons are tied together
    (well-designed modular code is easier to debug and understand than code based
    entirely on built-in types).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隐藏信息将客户端与实现分离的过程被称为*封装*。实现的细节对客户端保持隐藏，实现没有办法知道客户端代码的细节，甚至可能是未来创建的。我们使用封装来实现模块化编程，促进调试，并澄清程序代码。这些原因是相互联系的（设计良好的模块化代码比完全基于内置类型的代码更容易调试和理解）。
- en: Modular programming.
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化编程。
- en: The key to success in modular programming is to maintain independence among
    modules. We do so by insisting on the API being the only point of dependence between
    client and implementation — data-type implementation code can assume that the
    client knows nothing but the API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程成功的关键在于保持模块之间的独立性。我们通过坚持API是客户端和实现之间唯一的依赖点来实现这一点——数据类型实现代码可以假定客户端除了API之外一无所知。
- en: Changing an API.
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改API。
- en: We often reap the benefits of encapsulation when we use standard modules. New
    versions of Python often, for example, may include new implementations of various
    data types or modules that define functions. There is a strong and constant motivation
    to improve data-type implementations because all clients can potentially benefit
    from an improved implementation. However, Python APIs rarely change. When changes
    do occur, they are costly throughout the Python community — everyone has to update
    their clients. So once a significant number of clients are using a module, try
    not to change its API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用标准模块时，我们经常会获得封装的好处。例如，Python的新版本通常可能包括各种数据类型或定义函数的模块的新实现。改进数据类型实现的动机非常强烈且持续，因为所有客户端都有可能从改进的实现中受益。然而，Python的API很少改变。当发生更改时，整个Python社区都会付出代价——每个人都必须更新他们的客户端。因此，一旦有大量客户端使用一个模块，就尽量不要更改其API。
- en: Changing an implementation. ![Polar representation](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改实现。 ![极坐标表示](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)
- en: Consider the class `Complex`, defined in [complexpolar.py](complexpolar.py.html).
    It has the same name and API as the class `Complex` defined in [complex.py](../32class/complex.py.html)
    (from Section 3.2), but uses a different representation for the complex numbers.
    The `Complex` class defined in [complex.py](../32class/complex.py.html) uses the
    Cartesian representation, where instance variables `_re` and `_im` represent a
    complex number as *x* + *yi*. The `Complex` class defined in [complexpolar.py](complexpolar.py.html)
    uses the polar representation, where instance variables `_r` and `_theta` represent
    complex numbers as *r*(cos θ + *i* sin θ). In this representation, we refer to
    *r* as the *magnitude* and θ as the *polar angle*. The polar representation is
    of interest because certain operations on complex numbers are easier to perform
    in the polar representation. Addition and subtraction are easier in the Cartesian
    representation; multiplication and division are easier in the polar representation.
    The idea of encapsulation is that we can substitute one of these programs for
    the other (for whatever reason) without changing client code, except to change
    the `import` statement to use `complexpolar` instead of `complex`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[complexpolar.py](complexpolar.py.html)中定义的`Complex`类。它与[complex.py](../32class/complex.py.html)（来自第3.2节）中定义的`Complex`类具有相同的名称和API，但使用不同的复数表示。[complex.py](../32class/complex.py.html)中定义的`Complex`类使用笛卡尔表示，其中实例变量`_re`和`_im`表示复数为*x*
    + *yi*。[complexpolar.py](complexpolar.py.html)中定义的`Complex`类使用极坐标表示，其中实例变量`_r`和`_theta`表示复数为*r*(cos
    θ + *i* sin θ)。在这种表示中，我们将*r*称为*幅值*，θ称为*极角*。极坐标表示是有趣的，因为在极坐标表示中，对复数的某些操作更容易执行。加法和减法在笛卡尔表示中更容易；乘法和除法在极坐标表示中更容易。封装的思想是我们可以在不改变客户端代码的情况下将其中一个程序替换为另一个程序（无论出于何种原因），只需将`import`语句更改为使用`complexpolar`而不是`complex`。
- en: Private.
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有。
- en: 'Many programming languages provide support for enforcing encapsulation. For
    example, Java provides the `private` visibility modifier. When you declare an
    instance variable (or method) to be private, you are making it impossible for
    any client (code in another module) to directly access the instance variable (or
    method) that is the subject of the modifier. Python does not offer a `private`
    visibility modifier, which means that clients can directly access all instance
    variables, methods, and functions. However the Python programming community espouses
    a pertinent convention: if an instance variable, method, or function has a name
    that begins with an underscore, then clients should consider that instance variable,
    method, or function to be private. Through this naming convention, clients are
    informed that they should not directly access the instance variable, method, or
    function thus named.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言提供支持以强制实现封装。例如，Java提供了`private`可见性修饰���。当您将实例变量（或方法）声明为私有时，您使得任何客户端（另一个模块中的代码）无法直接访问修饰符所涉及的实例变量（或方法）。Python没有提供`private`可见性修饰符，这意味着客户端可以直接访问所有实例变量、方法和函数。然而，Python编程社区提倡一个相关的约定：如果一个实例变量、方法或函数的名称以下划线开头，那么客户端应该将该实例变量、方法或函数视为私有。通过这种命名约定，客户端被告知不应直接访问以这种方式命名的实例变量、方法或函数。
- en: In this booksite we always make all instance variables private in our classes.
    We strongly recommend that you do the same — there is no good reason to access
    an instance variable directly from a client.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个书站中，我们总是在我们的类中将所有实例变量设为私有的。我们强烈建议您也这样做——没有理由从客户端直接访问实例变量。
- en: Limiting the potential for error.
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制错误的可能性。
- en: 'Encapsulation also helps programmers ensure that their code operates as intended.
    For example, in the 2000 presidential election, Al Gore received *negative* 16,022
    votes on an electronic voting machine in Volusia County, Florida. The counter
    variable was not properly encapsulated in the voting machine software! To understand
    the problem, consider [counter.py](counter.py.html), which defines a simple `Counter`
    class according to this API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 封装还帮助程序员确保他们的代码按预期运行。例如，在2000年总统选举中，阿尔·戈尔在佛罗里达州沃卢西亚县的一台电子投票机上收到了负16,022票。计数器变量在投票机软件中没有被正确封装！要理解问题，请考虑[counter.py](counter.py.html)，它根据这个API定义了一个简单的`Counter`类：
- en: '![Counter API](../Images/4a991ecbac09acb9cb2f39b1e403f3e8.png)'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![计数器API](../Images/4a991ecbac09acb9cb2f39b1e403f3e8.png)'
- en: This abstraction is useful in many contexts, including, for example, an electronic
    voting machine. It encapsulates a single integer and ensures that the only operation
    that can be performed on the integer is increment by one. Therefore, it can never
    go negative. Proper encapsulation is far from a complete solution to the voting
    security problem, but it is a good start.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象在许多情况下都很有用，比如电子投票机。它封装了一个单一的整数，并确保唯一可以对该整数执行的操作是加一。因此，它永远不会变为负数。适当的封装远非是解决投票安全问题的完整解决方案，但却是一个很好的开始。
- en: Code clarity.
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码清晰度。
- en: Precisely specifying a data type improves design because it leads to client
    code that can more clearly express its computation. You have seen many examples
    of such client code in Sections 3.1 and 3.2, from charged particles to pictures
    to complex numbers. One key to good design is to observe that code composed with
    the proper abstractions can be nearly self-documenting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 精确指定数据类型可以改善设计，因为它导致客户端代码可以更清晰地表达其计算。在第3.1节和第3.2节中，你已经看到了许多这样的客户端代码示例，从带电粒子到图片再到复数。良好设计的关键之一是观察到使用适当的抽象组合的代码几乎可以自我说明。
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Immutability
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: An object from a data type is *immutable* if its data-type value cannot change
    once created. An immutable data type, such as a Python string, is one in which
    all objects of that type are immutable. By contrast, a *mutable* data type, such
    as a Python list/array, is one in which objects of that type have values that
    are designed to change. Of the data types considered in this chapter, `Charge`,
    `Color`, and `Complex` are all immutable, and `Picture`, `Histogram`, `Turtle`,
    `StockAccount`, and `Counter` are all mutable. Whether to make a data type immutable
    is a fundamental design decision and depends on the application at hand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据类型的对象一旦创建就无法更改其数据类型值，则该数据类型的对象是*不可变*的。不可变数据类型，比如Python字符串，是所有该类型对象都是不可变的。相比之下，*可变*数据类型，比如Python列表/数组，是其对象的值被设计为可以改变的。在本章考虑的数据类型中，`Charge`、`Color`和`Complex`都是不可变的，而`Picture`、`Histogram`、`Turtle`、`StockAccount`和`Counter`都是可变的。是否使数据类型不可变是一个基本的设计决策，取决于手头的应用。
- en: Immutable data types.
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变数据类型。
- en: The purpose of many data types is to encapsulate values that do not change.
    For example, a programmer implementing a `Complex` client might reasonably expect
    to compose the code `z = z0`, thus setting two variables to reference the same
    `Complex` object, in the same way as for floats or integers. But if `Complex`
    were mutable and the object referenced by `z` were to change after the assignment
    `z = z0`, then the object referenced by `z0` would also change (they are aliases,
    or both references to the same object). Conceptually, changing the value of `z`
    would change the value of `z0`! This unexpected result, known as an *aliasing
    bug*, comes as a surprise to many newcomers to object-oriented programming.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据类型的目的是封装不会改变的值。例如，一个程序员实现一个`Complex`客户端可能合理地期望组合代码`z = z0`，从而设置两个变量引用相同的`Complex`对象，就像对浮点数或整数一样。但是，如果`Complex`是可变的，并且在赋值`z
    = z0`之后被引用的对象发生变化，那么被`z0`引用的对象也会发生变化（它们是别名，或者都是对同一对象的引用）。从概念上讲，改变`z`的值将改变`z0`的值！这种意外的结果，称为*别名错误*，对许多初学者来说是一个惊喜，这是面向对象编程的一个重要概念。
- en: Mutable data types.
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变数据类型。
- en: For many other data types, the very purpose of the abstraction is to encapsulate
    values as they change. The `Turtle` class defined in [turtle.py](../32class/turtle.py.html)
    (from Section 3.2) is a prime example. Similarly, `Picture`, `Histogram`, `StockAccount`,
    `Counter`, and Python lists/arrays are all types where we expect values to change.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多其他数据类型，抽象的目的就是封装值随着变化而变化。在[turtle.py](../32class/turtle.py.html)（来自第3.2节）中定义的`Turtle`类就是一个典型例子。同样，`Picture`、`Histogram`、`StockAccount`、`Counter`和Python列表/数组都是我们期望值会改变的类型。
- en: Arrays and strings.
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和字符串。
- en: You have already encountered this distinction as a client programmer, when using
    Python lists/arrays (mutable) and Python strings (immutable). When you pass a
    string to a method/function, you do not need to worry about that method/function
    changing the sequence of characters in the string. In contrast, when you pass
    an array to a method/function, the method/function is free to change the elements
    of the array. Python strings are immutable because we generally do not want `str`
    values to change; Python arrays are mutable because we often do want array elements
    to change.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为客户端程序员，当使用Python列表/数组（可变）和Python字符串（不可变）时，你已经遇到了这种区别。当你将一个字符串传递给一个方法/函数时，你不��要担心该方法/函数改变字符串中的字符序列。相反，当你将一个数组传递给一个方法/函数时，该方法/函数可以自由地改变数组的元素。Python字符串是不可变的，因为我们通常不希望`str`值发生变化；Python数组是可变的，因为我们经常希望数组元素发生变化。
- en: Advantages of immutability.
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性的优势。
- en: Generally, immutable data types are easier to use and harder to misuse because
    the scope of code that can change object values is far smaller than for mutable
    types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不可变数据类型更容易使用，更难被误用，因为能够改变对象值的代码范围远比可变类型小得多。
- en: Cost of immutability.
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性的代价。
- en: The downside of immutability is that you must create a new object for every
    value. For example, when you are using the `Complex` data type, the expression
    `z = z*z + z0` involves creating a third object (to hold the value `z*z`), then
    using that object with the `+` operator (without saving an explicit reference
    to it) and creating a fourth object to hold the value `z*z + z0`, and assigning
    that object to `z` (thereby orphaning the original reference to `z`). A program
    such as [mandelbrot.py](../32class/mandelbrot.py.html) (from Section 3.2) creates
    a huge number of such intermediate objects. However, this expense is normally
    manageable because Python's memory management is typically optimized for such
    situations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Defensive copies.
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that we wish to develop an immutable data type named `Vector`, whose
    constructor takes an array of floats as an argument to initialize an instance
    variable. Consider this attempt:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code makes `Vector` a mutable data type. A client program could create
    a `Vector` object by specifying the elements in an array, and then (bypassing
    the API) change the elements of the Vector after creation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To ensure immutability of a data type that includes an instance variable of
    a mutable type, the implementation needs to make a local copy, known as a *defensive
    copy*. Recall from Section 1.4 that the expression `a[:]` creates a copy of array
    `a[]`. As a consequence, this code creates a defensive copy:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we consider a full implementation of such a data type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Spatial vectors'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![A spatial vector](../Images/7bcd03654bc1ff810fadf378383d7517.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'A *spatial vector* is an abstract entity that has a magnitude and a direction.
    Spatial vectors provide a natural way to describe properties of the physical world,
    such as force, velocity, momentum, or acceleration. One standard way to specify
    a vector is as an arrow from the origin to a point in a Cartesian coordinate system:
    the direction is the ray from the origin to the point and the magnitude is the
    length of the arrow (distance from the origin to the point). To specify the vector,
    it suffices to specify the point.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept extends to any number of dimensions: an ordered list of *n* real
    numbers (the coordinates of an *n*-dimensional point) suffices to specify a vector
    in *n*-dimensional space. By convention, we use a boldface letter to refer to
    a vector and numbers or indexed variable names (the same letter in italics) separated
    by commas within parentheses to denote its value. For example, we might use **x**
    to denote the vector (*x*[0], *x*[1], ..., *x*[*n*-1]) and **y** to denote the
    vector (*y*[0], *y*[1], ..., *y*[*n*-1]).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: API.
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic operations on vectors are to add two vectors, multiply a vector by
    a scalar (a real number), compute the dot product of two vectors, and compute
    the magnitude and direction, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '*Addition*: **x** + **y** = (*x*[0] + *y*[0], *x*[1] + *y*[1], ..., *x*[*n*-1]
    + *y*[*n*-1])'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scalar product*: α**x** = (α*x*[0], α*x*[1], ..., α*x*[*n*-1])'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dot product*: **x** · **y** = *x*[0]*y*[0] + *x*[1]*y*[1] + ... + *x*[*n*-1]*y*[*n*-1]'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Magnitude*: |**x**| = (*x*[0]² + *x*[1]² + ... + *x*[*n*-1]²)^(1/2)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Direction*: **x** / |**x**| = (*x*[0] / |**x**|, *x*[1] / |**x**|, ..., *x*[*n*-1]
    / |**x**|)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those definitions lead to this API:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector API](../Images/b5292127553bed9ace9654f9cf0b4a08.png)'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: As with `Complex`, this API does not explicitly specify that the data type is
    immutable, but we know that client programmers (who are likely to be thinking
    in terms of the mathematical abstraction) will certainly expect that convention,
    and perhaps we would rather not explain to them that we are trying to protect
    them from aliasing bugs!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Representation.
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first choice in developing an implementation is to choose a representation
    for the data. Using an array to hold the Cartesian coordinates provided in the
    constructor is a clear choice, but not the only reasonable choice. If warranted,
    the implementation can change the coordinate system without affecting client code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Implementation.
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the representation, the code that implements all of these operations is
    straightforward, as you can see in the `Vector` class defined in [vector.py](vector.py.html).
    The constructor makes a defensive copy of the client array and none of the methods
    assigns a value to the copy, so that `Vector` objects are immutable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we ensure immutability when it seems that the client is free to compose
    code like `x[i] = 2.0`? The answer to this question lies in a special method that
    we do not implement in an immutable data type: in such a case, Python calls the
    special method `__setitem__()` instead of `__getitem__()`. Since `Vector` does
    not implement that method, such client code would raise an `AttributeError` at
    run time.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python''s built-in `tuple` data type represents an *immutable* sequence of
    objects. It is similar to the built-in `list` data type (which we use for arrays),
    except that once you create a tuple, you cannot change its items. You can manipulate
    tuples using familiar array notation, as documented in this API:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuple API (partial)](../Images/352e5b621c171f38278840c25ae5d5ed.png)'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: You can create tuples either using the built-in function tuple() or by listing
    a sequence of expressions, separated by commas, and (optionally) enclosed in matching
    parentheses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using tuples can improve the design of a program. For example, if we replace
    the first statement in the constructor of [vector.py](vector.py.html) with
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: then any attempt to change a vector coordinate within the Vector class raises
    a `TypeError` at run time, helping to enforce immutability of `Vector` objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also provides a powerful tuple assignment feature known as *tuple packing*
    and *tuple unpacking* that lets you assign a tuple of expressions on the right-hand
    side of an assignment operator to a tuple of variables on the left-hand side (provided
    the number of variables on the left matches the number of expressions on the right).
    You can use this feature to assign multiple variables simultaneously. For example,
    the following statement exchanges the object references in variable `x` and `y`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also use tuple packing and unpacking to return multiple values from
    a function (see an exercise at the end of this section).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, when we compose methods (or functions), we intend for them to work only
    with objects of specific types. Sometimes, we want them to work with objects of
    different types. A method (or function) that can take arguments with different
    types is said to be *polymorphic*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The best kind of polymorphism is the unexpected kind: when you apply an existing
    method/function to a new data type (for which you never planned) and discover
    that the method/function has exactly the behavior that you wanted. The worst kind
    of polymorphism is also the unexpected kind: when you apply an existing method/function
    to a new data type and it returns the wrong answer! Finding a bug of this sort
    can be an extraordinary challenge.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing.
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Duck typing is a programming style in which the language does not formally specify
    the requirements for a function's arguments; instead, it just tries to call the
    function if a compatible one is defined (and raises a run-time error otherwise).
    The name comes from an old quote attributed to the poet J. W. Riley:*When I see
    a bird that
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: walks like a duck and swims like a duck and quacks like a duck
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: I call that bird a duck*
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In Python, if an object walks like a duck, swims like a duck, and quacks like
    a duck, you can treat that object as a duck; you don't need to explicitly declare
    it to be a duck. In many languages (such as Java or C++), you do need to explicitly
    declare the types of variables, but not in Python — Python uses duck typing for
    all operations (function calls, method calls, and operators). It raises a `TypeError`
    at run time if an operation cannot be applied to an object because it is of an
    inappropriate type. This approach leads to simpler and more flexible client code
    and puts the focus on operations that are actually used rather than the type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，如果一个对象像鸭子一样走路，游泳，嘎嘎叫，你可以将该对象视为鸭子；你不需要明确声明它是鸭子。在许多语言（如Java或C++）中，您需要明确声明变量的类型，但在Python中不需要
    — Python对所有操作（函数调用，方法调用和运算符）使用鸭子类型。如果由于不适当的类型而无法将操作应用于对象，则它会在运行时引发`TypeError`。这种方法导致客户端代码更简单、更灵活，并将重点放在实际使用的操作上，而不是类型上。
- en: Disadvantages of duck typing.
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型的缺点。
- en: The primary disadvantage of duck typing is that it is difficult to know precisely
    what the contract is between the client and the implementation, especially when
    a required method is needed only indirectly. The API simply does not carry this
    kind of information. This lack of information can lead to run-time errors. Worse,
    the end result can be semantically incorrect, with no error raised at all. Next,
    we consider a simple example of this situation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型的主要缺点是很难准确知道客户端和实现之间的契约是什么，特别是当需要的方法只间接需要时。API简单地不携带这种信息。这种信息的缺乏可能导致运行时错误。更糟糕的是，最终结果可能在语义上不正确，而根本没有引发错误。接下来，我们考虑这种情况的一个简单示例。
- en: A case in point.
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个案例。
- en: We designed our `Vector` data type under the implicit assumption that the vector
    components would be floats and that the client would create a new vector by passing
    an array of `float` objects to the constructor. If the client creates two vectors
    `x` and `y` in this way, then both `x[i]` and `x.dot(y)` return floats and both
    `x + y` and `x - y` return vectors with float components, as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计我们的`Vector`数据类型时，隐含地假设向量分量��是浮点数，并且客户端将通过将`float`对象数组传递给构造函数来创建一个新向量。如果客户端以这种方式创建两个向量`x`和`y`，那么`x[i]`和`x.dot(y)`都返回浮点数，`x
    + y`和`x - y`都返回具有浮点分量的向量，如预期的那样。
- en: Suppose, instead, that a client creates a `Vector` with integer components by
    passing an array of `int` objects to the constructor. If the client creates two
    vectors `x` and `y` in this manner, then both `x[i]` and `x.dot(y)` return integers
    and both `x + y` and `x - y` return vectors with integer components, as desired.
    Of course, `abs(x)` returns a `float` and `x.direction()` returns a vector with
    `float` components. This is the best kind of polymorphism, where duck typing works
    serendipitously.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，相反地，一个客户通过将`int`对象数组传递给构造函数来创建具有整数分量的`Vector`。如果客户以这种方式创建两个向量`x`和`y`，那么`x[i]`和`x.dot(y)`都返回整数，`x
    + y`和`x - y`都返回具有整数分量的向量，如所需。当然，`abs(x)`返回一个`float`，而`x.direction()`返回一个具有`float`分量的向量。这是最好的多态性，其中鸭子类型恰好起作用。
- en: 'Now, suppose that a client creates a `Vector` with complex components by passing
    an array of `complex` objects to the constructor. There is no problem with vector
    addition or scalar multiplication, but the implementation of the dot product operation
    (along with the implementations of magnitude and direction, which depend on the
    dot product) fails spectacularly. Here is an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个客户通过将`complex`对象数组传递给构造函数来创建具有复数分量的`Vector`。向量加法或标量乘法没有问题，但点积操作的实现（以及依赖于点积的幅度和方向的实现）却失败得惊人。这里是一个例子：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code results in a `TypeError` at run time, with `math.sqrt()` trying to
    take the square root of a complex number. The problem is that the dot product
    of two complex-valued vectors **x** and **y** requires taking the *complex conjugate*
    of the elements in the second vector. The textbook describes the problem and its
    solution in detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在运行时导致`TypeError`，因为`math.sqrt()`试图对一个复数取平方根。问题在于两个复值向量**x**和**y**的点积需要取第二个向量中元素的*复共轭*。教科书详细描述了问题及其解决方案。
- en: In this case, duck typing is the worst kind of polymorphism. It is certainly
    reasonable for a client to expect the implementation of `Vector` to work properly
    when vector components are complex numbers. How can an implementation anticipate
    and prepare for all potential uses of a data type? This situation presents a design
    challenge that is impossible to meet. All we can do is caution you to check, if
    possible, that any data type that you use can handle the types of data that you
    intend to use with it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，鸭子类型是最糟糕的多态性。当向量分量是复数时，客户端期望`Vector`的实现能够正常工作是完全合理的。一个实现如何能够预期并准备好处理数据类型的所有潜在用途呢？这种情况提出了一个不可能满足的设计挑战。我们所能做的就是警告您，尽可能检查您使用的任何数据类型是否能够处理您打算与之一起使用的数据类型。
- en: '* * *'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Overloading
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载
- en: The ability to define a data type that provides its own definitions of operators
    is a form of polymorphism known as *operator overloading*. In Python, you can
    overload almost every operator, including operators for arithmetic, comparisons,
    indexing, and slicing. You can also overload built-in functions, including absolute
    value, length, hashing, and type conversion. Overloading operators and built-in
    functions makes user-defined types behave more like built-in types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义提供其自己的运算符定义的数据类型的能力是一种称为*运算符重载*的多态性形式。在Python中，您几乎可以重载每个运算符，包括算术、比较、索引和切片运算符。您还可以重载内置函数，包括绝对值、长度、哈希和类型转换。重载运算符和内置函数使用户定义的类型更像内置类型。
- en: To perform an operation, Python internally converts the expression into a call
    on the corresponding special method; to call a built-in function, Python internally
    calls the corresponding special method instead. To overload an operator or built-in
    function, you include an implementation of the corresponding special method with
    your own code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为执行操作，Python内部将表达式转换为对应特殊方法的调用；要调用内置函数，Python内部调用相应的特殊方法。要重载运算符或内置函数，您需要在自己的代码中包含相应特殊方法的实现。
- en: Arithmetic operators.
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符。
- en: Python associates a special method with each of its arithmetic operators, so
    you can overload any arithmetic operation by implementing the corresponding special
    method, as detailed in this table.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python为其每个算术运算符关联一个特殊方法，因此您可以通过实现相应的特殊方法来重载任何算术操作，详细��息请参见此表。
- en: '![Special methods for arithmetic operations](../Images/c23633d9f15ef3a334e80edd9533430d.png)'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![算术运算的特殊方法](../Images/c23633d9f15ef3a334e80edd9533430d.png)'
- en: Equality.
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等性。
- en: '![Three variables refering to two Charge objects](../Images/68c932f776df7152fe535677777e13c0.png)
    The `==` and `!=` operators for testing equality require special attention. For
    example, consider the code in the diagram at right, which creates two `Charge`
    objects, referenced by three variables `c1`, `c2`, and `c3`. As illustrated in
    the diagram, `c1` and `c3` both reference the same object, which is different
    from the one referenced by `c2`. Clearly, `c1 == c3` is `True`, but what about
    `c1 == c2`? The answer to this question is unclear because there are two ways
    to think about equality in Python:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![三个变量引用两个Charge对象](../Images/68c932f776df7152fe535677777e13c0.png) 用于测试相等性的`==`和`!=`运算符需要特别注意。例如，考虑右侧图中的代码，它创建了两个由三个变量`c1`、`c2`和`c3`引用的`Charge`对象。正如图中所示，`c1`和`c3`都引用相同的对象，这与`c2`引用的对象不同。显然，`c1
    == c3`为`True`，但`c1 == c2`呢？对于这个问题的答案不明确，因为在Python中有两种思考相等性的方式：'
- en: '*Reference equality* (*identity equality*). Reference equality holds when two
    references are equal — they refer to the same object. The built in function `id()`
    gives the identity of an object (its memory address); the `is` and `is not` operators
    test whether two variables refer to the same object. That is, the implementation
    of `c1 is c2` tests whether `id(c1)` and `id(c2)` are the same. In our example,
    `c1 is c3` is `True` as expected, but `c1 is c2` is `False` because `c1` and `c2`
    reside at different memory addresses.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用相等性*（*标识相等性*）。当两个引用相等时，它们指向同一个对象。内置函数`id()`给出对象的标识（其内存地址）；`is`和`is not`运算符测试两个变量是否引用同一个对象。也就是说，`c1
    is c2`的实现测试`id(c1)`和`id(c2)`是否相同。在我们的例子中，`c1 is c3`如预期的那样是`True`，但`c1 is c2`是`False`，因为`c1`和`c2`位于不同的内存地址。'
- en: '*Object equality* (*value equality*). Object equality holds when two objects
    are equal — they have the same data-type value. You should use the `==` and `!=`
    operators, defined using the special methods `__eq__()` and `__ne__()`, to test
    for object equality. If you do not define an `__eq__()` method, then Python substitutes
    the `is` operator. That is, by default `==` implements reference equality. So,
    in our earlier example, `c1 == c2` is `False` even though `c1` and `c2` have the
    same position and charge value. If we want two charges with identical position
    and charge value to be considered equal, we can ensure this outcome by including
    the following code in [charge.py](../32class/charge.py.html) (from Section 3.2):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象相等性*（*值相等性*）。当两个对象相等时，它们具有相同的数据类型值。您应该使用`==`和`!=`运算符，这些运算符是使用特殊方法`__eq__()`和`__ne__()`定义的，用于测试对象的相等性。如果您没有定义`__eq__()`方法，那么Python会使用`is`运算符。也就是说，默认情况下，`==`实现引用相等性。因此，在我们之前的例子中，即使`c1`和`c2`具有相同的位置和电荷值，`c1
    == c2`也是`False`。如果我们希望将具有相同位置和电荷值的两个电荷视为相等，则可以通过在[charge.py](../32class/charge.py.html)（来自第3.2节）中包含以下代码来确保这一结果：'
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code in place, `c1 == c2` is now True in our example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们的例子中现在`c1 == c2`为True。
- en: Hashing.
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希。
- en: 'We now consider a fundamental operation related to equality testing, known
    as *hashing*, that maps an object to an integer, known as a *hash code*. This
    operation is so important that it is handled by Python''s special method `__hash__()`
    in support of the built-in `hash()` function. We refer to an object as `hashable`
    if it satisfies the following three properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑与相等性测试相关的基本操作，称为*哈希*，它将对象映射到一个整数，称为*哈希码*。这个操作非常重要，Python通过支持内置的`hash()`函数的特殊方法`__hash__()`来处理它。如果对象满足以下三个属性，则我们将对象称为`可哈希`：
- en: The object can be compared for equality with other objects via the == operator.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`==`运算符，可以将对象与其他对象进行相等性比较。
- en: Whenever two objects compare as equal, they have the same hash code.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当两个对象比较相等时，它们具有相同的哈希码。
- en: The object's hash code does not change during its lifetime.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的哈希码在其生命周期中不会更改。
- en: In typical applications, we use the hash code to map an object `x` to an integer
    in a small range, say between 0 and `m`-1, using the hash function
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型应用中，我们使用哈希码将对象`x`映射到一个小范围内的整数，例如在0和`m`-1之间，使用哈希函数
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, we can use the hash function value as an integer index into an array of
    length `m` (see the [sketch.py](sketch.py.html) program described later in this
    section and the [hashst.py](../44st/hashst.py.html) program described in Section
    4.4). All of Python's immutable data types (including `int`, `float`, `str`, and
    `tuple`) are hashable and engineered to distribute the objects in a reasonable
    manner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用哈希函数值作为整数索引到长度为`m`的数组中（请参阅本节后面描述的[sketch.py](sketch.py.html)程序和第4.4节中描述的[hashst.py](../44st/hashst.py.html)程序）。Python的所有不可变数据类型（包括`int`、`float`、`str`和`tuple`）都是可哈希的，并且被设计为以合理的方式分布对象。
- en: 'You can make a user-defined data type hashable by implementing the two special
    methods `__hash__()` and `__eq__()`. Crafting a good hash function requires a
    deft combination of science and engineering, and is beyond the scope of this booksite.
    Instead, we describe a simple recipe for doing so in Python that is effective
    in a wide variety of situations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现两个特殊方法`__hash__()`和`__eq__()`，你可以使用户定义的数据类型可哈希。设计一个良好的哈希函数需要科学和工程的巧妙结合，这超出了本书的范围。��反，我们在Python中描述了一个简单的方法，该方法在各种情况下都很有效：
- en: Ensure that the data type is immutable.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据类型是不可变的。
- en: Implement `__eq__()` by comparing all significant instance variables.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过比较所有重要的实例变量来实现`__eq__()`。
- en: Implement `__hash__()` by putting the same instance variables into a tuple and
    calling the built-in `hash()` function on the tuple.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将相同的实例变量放入元组并在元组上调用内置的`hash()`函数来实现`__hash__()`。
- en: 'For example, following is a `__hash__()` implementation for the `Charge` data
    type (defined in [charge.py](../32class/charge.py.html) from Section 3.2) to accompany
    the `__eq__()` implementation that we just considered:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是`Charge`数据类型（在[charge.py](../32class/charge.py.html)中定义，来自第3.2节）的`__hash__()`实现，以配合我们刚刚考虑的`__eq__()`实现：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comparison operators.
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符。
- en: 'Similarly, comparisons like `x < y` and `x >= y` are not just for integers,
    floats, and strings in Python. Again, Python associates a special method with
    each of its comparison operators, so you can overload any comparison operator
    by implementing the corresponding special method, as detailed in this table:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Python中，像`x < y`和`x >= y`这样的比较不仅适用于整数、浮点数和字符串。再次，Python为每个比较运算符关联了一个特殊方法，因此你可以通过实现相应的特殊方法来重载任何比较运算符，详细信息请参考下表：
- en: '![Special methods for comparison operations](../Images/2117176e80623b85b4db52e451bae6e8.png)'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![比较操作的特殊方法](../Images/2117176e80623b85b4db52e451bae6e8.png)'
- en: 'As a matter of style, if you define any one of the comparison methods, then
    you should define all of them, and in a consistent manner. You can make a user-defined
    type *comparable* by implementing the six special methods, as we do here for the
    `Counter` class defined in [counter.py](counter.py.html):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种风格，如果你定义了任何一个比较方法，那么你应该以一致的方式定义所有这些方法。你可以通过实现六个特殊方法使用户定义的类型*可比较*，就像我们在[counter.py](counter.py.html)中为`Counter`类所做的那样：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other operators.
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他运算符。
- en: Almost every operator in Python can be overloaded. If you want to overload an
    operator, you can track down the corresponding special method in the [official
    Python documentation](https://docs.python.org/3/reference/datamodel.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python中几乎每个运算符都可以被重载。如果你想重载一个运算符，你可以在[官方Python文档](https://docs.python.org/3/reference/datamodel.html)中找到相应的特殊方法。
- en: Built-in functions.
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置函数。
- en: We have been overloading the built-in function `str()` in every class we develop,
    and there are several other built-in functions that we can overload in the same
    way. The ones that we use in this book are summarized in the table below. We have
    already used all of these functions, except for `iter()`, which we defer until
    Section 4.4.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在每个我们开发的类中重载内置函数`str()`，还有其他几个内置函数可以以相同的方式重载。我们在本书中使用的这些函数已总结在下表中。我们已经使用了所有这些函数，除了`iter()`，我们将在第4.4节中推迟使用。
- en: '![Special methods for built-in functions](../Images/0e4d725442ea235e5433c2e3af4a5f24.png)'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![内置函数的特殊方法](../Images/0e4d725442ea235e5433c2e3af4a5f24.png)'
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Functions are Objects
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是对象
- en: In Python, *everything* is an object, including functions. This means that you
    can use functions as arguments to functions and return them as results. Defining
    so-called *higher-order functions* that manipulate other functions is common both
    in mathematics and in scientific computing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*一切*都是对象，包括函数。这意味着你可以将函数用作函数的参数并将它们作为结果返回。定义所谓的*高阶函数*，用于操作其他函数，在数学和科学计算中都很常见。
- en: '![Approximating an integral](../Images/e8da3e02b82c92bb77b3cc50c8fbc541.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![近似积分](../Images/e8da3e02b82c92bb77b3cc50c8fbc541.png)'
- en: 'As an example, consider the problem of estimating the *Riemann integral* (that
    is, the area under the curve) of a positive real-valued function *f*. Perhaps
    the simplest approach is known as the *rectangle rule*, where we approximate the
    value of the integral by computing the total area of *n* equal-width rectangles
    under the curve. The `integrate()` function defined below evaluates the integral
    of a real-valued function *f*() in the interval (*a*, *b*), using the rectangle
    rule with *n* rectangles:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑估计正实值函数*f*的*黎曼积分*（即曲线下的面积）的问题。也许最简单的方法是称为*矩形法*，在这种方法中，我们通过计算曲线下*n*个等宽矩形的总面积来近似积分的值。下面定义的`integrate()`函数评估了在区间(*a*,
    *b*)中实值函数*f*()的积分，使用*n*个矩形的矩形法：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '* * *'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Inheritance
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Python provides language support for defining relationships among classes, known
    as *inheritance*. Software developers use inheritance widely, so you will study
    it in detail if you take a course in software engineering. Effective use of inheritance
    is beyond the scope of this booksite, but we briefly describe it here because
    there are a few situations where you may encounter it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了定义类之间关系的语言支持，称为*继承*。软件开发人员广泛使用继承，因此如果你学习软件工程课程，你将详细学习它。有效使用继承超出了本书的范围，但我们在这里简要描述它，因为有一些情况下你可能会遇到它。
- en: When used properly, inheritance enables a form of code reuse known as *subclassing*.
    The idea is to define a new class (*subclass*, or *derived class*) that inherits
    instance variables and methods from another class (*superclass*, or *base class*).
    The subclass contains more methods than the superclass. Systems programmers use
    subclassing to build so-called *extensible* modules. The idea is that one programmer
    (even you) can add methods to a class built by another programmer (or, perhaps,
    a team of systems programmers), effectively reusing the code in a potentially
    huge module. This approach is widely used, particularly in the development of
    user interfaces, so that the large amount of code required to provide all the
    facilities that users expect (drop-down menus, cut-and-paste, access to files,
    and so forth) can be reused.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Despite its advantages, the use of subclassing is controversial, even among
    systems programmers. We do not use it in this booksite because it generally works
    against encapsulation. Subclassing makes modular programming more difficult for
    two reasons. First, any change in the superclass affects all subclasses. The subclass
    cannot be developed independently of the superclass; indeed, it is completely
    dependent on the superclass. This problem is known as the *fragile base class
    problem*. Second, the subclass code, having access to instance variables, can
    subvert the intention of the superclass code. For example, the designer of a class
    such as `Vector` may have taken great care to make the `Vector` immutable, but
    a subclass, with full access to the instance variables, can just change them,
    wreaking havoc for any client assuming the class to be immutable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Application: Data Mining'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate some of the concepts discussed in this section in the context
    of an application, we next consider a software technology that is proving important
    in addressing the daunting challenges of *data mining* — that is, the process
    of searching through massive amounts of information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, we will restrict our attention to text documents (though the
    approach we will consider applies to pictures, music, and all sorts of other files
    as well). Even with this restriction, there is remarkable diversity in the types
    of documents. For reference, you can find these documents on the booksite:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Some text documents](../Images/5631eebfd66ce4d49fe4dc7cb1e09df3.png)'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'Our interest is in finding efficient ways to search through the files using
    their content to characterize documents. One fruitful approach to this problem
    is to associate with each document a vector known as a *sketch*, which is an ultra-compact
    representation of its content. The basic idea is that the sketch should capture
    salient statistical features of the document, so that documents that are different
    have sketches that are "different" and documents that are similar have sketches
    that are "similar." These considerations lead to this API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Sketch API](../Images/34024d9cc055209284bd15cb0d2e90c8.png)'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The arguments of the constructor are a string and two integers that control
    the quality of the sketch. Clients can use `similarTo()` to determine the extent
    of similarity between two sketches on a scale of 0 (not similar) to 1 (similar).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Computing sketches.
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Computing a sketch of a document is the first challenge. Our first choice is
    to use a `Vector` to represent a document''s sketch. Our implementation [sketch.py](sketch.py.html)
    uses a simple frequency count approach. In addition to the string, the constructor
    has two arguments, an integer *k* and a vector dimension *d*. It scans the document
    and examines all of the *k*-grams in the document — that is, the substrings of
    length *k* starting at each position. In its simplest form, the sketch is a vector
    that gives the relative frequency of occurrence of the *k*-grams in the string:
    an element for each possible *k*-gram giving the number of *k*-grams in the document
    that have that value.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Hashing.
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On many systems there are 128 different possible values for each character,
    so there are 128*k* possible *k*-grams, and the dimension *d* would have to be
    128*k* for the simple scheme just described. This number is prohibitively large
    even for moderately large *k*. To ameliorate this problem, we use hashing, a fundamental
    operation that we considered earlier in this section to map an object to an integer.
    For any string `s`, `hash(s) % d` is an integer between 0 and `d`-1 that we can
    use as an index into an array to compute frequencies. The sketch that we use is
    the direction of the vector defined by frequencies of these values for all *k*-grams
    in the document (the unit vector with the same direction). The test client in
    [sketch.py](sketch.py.html) accepts `k` and `d` as command-line arguments, and
    computes and writes a sketch of the document that it reads from standard input.
    Try running it with standard input redirected to the file [genome20.txt](genome20.txt).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Comparing sketches.
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second challenge is to compute a similarity measure between two sketches.
    One widely used similarity measure is known as the *cosine similarity measure*.
    Since our sketches are unit vectors with nonnegative coordinates, their dot product
    is a number between 0 and 1\. The more similar the documents, the closer we expect
    this measure to be to 1\. The `similarTo()` method in [sketch.py](sketch.py.html)
    uses that approach.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Comparing all pairs.
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The program [comparedocuments.py](comparedocuments.py.html) is a simple and
    useful `Sketch` client that provides the information needed to solve the following
    problem: given a set of documents, find the two that are most similar. Since this
    specification is a bit subjective, the program writes the cosine similarity measure
    for all pairs of documents. The program accepts command-line arguments `k` and
    `d`, reads from standard input a list of file names, and writes a table showing
    the similarity measures of the files with those names. Try running it with standard
    input redirected to [documents.txt](documents.txt), which contains the names of
    the files [constitution.txt](constitution.txt), [tomsawyer.txt](tomsawyer.txt),
    [huckfinn.txt](huckfinn.txt), [prejudice.txt](prejudice.txt), [djia.csv](djia.csv),
    [amazon.html](amazon.html), and [actg.txt](actg.txt).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Design-by-Contract
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude, we briefly discuss Python language mechanisms that enable you to
    verify assumptions about your program while it is running.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions.
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *exception* is a disruptive event that occurs while a program is running,
    often to signal an error. The action taken is known as *raising an exception*
    (or *error*). We have already encountered exceptions raised by Python''s standard
    modules in the course of learning to program: `IndexError` and `ZeroDivisionError`
    are typical examples. You can also raise your own exceptions. The simplest kind
    is an `Exception` that disrupts execution of the program and writes an error message:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is good practice to use exceptions when they can be helpful to the client.
    For example, in [vector.py](vector.py.html), we should raise an exception in `__add__()`
    if the two `Vector`s to be added have different dimensions. To do so, we insert
    the following statement at the beginning of `__add__()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Assertions.
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *assertion* is a boolean expression that you are affirming is `True` at
    that point in the program. If the expression is `False`, the program will raise
    an `AssertionError` at run time. Programmers uses assertions to detect bugs and
    gain confidence in the correctness of their programs. Assertions also serve to
    document the programmer''s intent. For example, in [counter.py](counter.py.html),
    we might check that the counter is never negative by adding the following assertion
    as the last statement in `increment()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This statement would call attention to a negative count. You can also add an
    optional detail message, such as
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: to help identify the bug.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: By default, assertions are enabled, but you can disable them from the command
    line by using the `-O` (that's a minus sign followed by an uppercase "oh") flag
    with the python command. (The `O` stands for "optimize.") Assertions are for debugging
    only; your program should not rely on assertions for normal operation since they
    may be disabled.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When using the *design-by-contract* model, the designer of a data type expresses
    a *precondition* (the condition that the client promises to satisfy when calling
    a method), a *postcondition* (the condition that the implementation promises to
    achieve when returning from a method), *invariants* (any condition that the implementation
    promises to satisfy while the method is executing), and *side effects* (any other
    change in state that the method could cause). During development, these conditions
    can be tested with assertions. Many programmers use assertions liberally to aid
    in debugging.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Why is the underscore convention not part of (and enforced by) Python?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Good question.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why all the leading underscores?'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** This is just one of many examples where a programming-language designer
    goes with a personal preference and we live with the result. Fortunately, most
    Python programs that you compose will be client programs, which do not directly
    call special methods or refer to private instance variables, so they will not
    need many leading underscores. The relatively few Python programmers who implement
    their own data types (that''s you, now) need to follow the underscore conventions,
    but even those programmers are likely to be composing more client code than class
    implementations, so the underscores may not be so onerous in the long run.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** The `__mul__()` method in [complexpolar.py](complexpolar.py.html) is
    awkward because it create a `Complex` object (representing 0 + 0*i*) and then
    immediately changes its instance variables to the desired polar coordinates. Wouldn''t
    the design be better if I could add a second constructor that takes the polar
    coordinates as arguments?'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but we already have a constructor that takes the rectangular coordinates
    as arguments. A better design might be to have two ordinary functions (not methods)
    `createRect(x, y)` and `createPolar(r, theta)` in the API that create and return
    new objects. This design is perhaps better because it would provide the client
    with the capability to switch to polar coordinates. This example demonstrates
    that it is a good idea to think about more than one implementation when developing
    a data type. Of course, making such a change necessitates enhancing all existing
    implementations and clients of the API, so this thinking should happen as early
    in the design process as possible.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do I specify a tuple consisting of zero items or one item?'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** You can use `()` and `(1,)`, respectively. Without the comma in the
    second expression, Python would treat it as an arithmetic expression enclosed
    in parentheses.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Do I really need to overload all six comparison methods if I want to
    make my data type comparable?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes. This is an example where the convention is to provide maximum flexibility
    to clients at the expense of extra code in implementations. Often, you can use
    symmetries to cut down on the actual amount of implementation code. Also, Python
    3 supplies a few shortcuts. For example, if you define an `__eq__()` method for
    a data type but do not define an `__ne__()` method, then Python automatically
    provides an implementation that calls `__eq__()` and negates the result. However,
    Python 2 does not provide these shortcuts, so it is best not to rely upon them
    in your code.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What is the range of integer values returned by the built-in `hash()`
    function?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Typically, Python uses a 64-bit integer, so the range is between -2^(63)
    and 2^(63)-1\. For cryptographic applications, you should use Python''s `hashlib`
    module, which supports "secure" hash functions that support much larger ranges.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Which Python operators cannot be overloaded?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** In Python, you cannot overload'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The boolean operators `and`, `or`, and `not`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `is` and `is not` operators, which test for object identity.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string format operator `%`, which can be applied only to strings.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assignment operator `=`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a data type `Location` for dealing with locations on Earth using spherical
    coordinates (latitude/longitude). Include methods to generate a random location
    on the surface of the Earth, parse a location "25.344 N, 63.5532 W", and compute
    the great circle distance between two locations.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a data type for a three-dimensional particle with position (*r*[*x*],
    *r*[*y*], *r*[*z*]), mass *m*, and velocity `(*v*[*x*], *v*[*y*], *v*[*z*])`.
    Include a method to return its kinetic energy, which equals 1/2 *m* (*v*[*x*]²
    + *v*[*y*]² + *v*[*z*]²). Use the `Vector` data type, as defined in [vector.py](vector.py.html).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you know your physics, develop an alternate implementation of the data type
    of the previous exercise based on using the *momentum* (*p*[*x*], *p*[*y*], *p*[*z*])
    as an instance variable.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop an implementation of the `Histogram` class, as defined in [histogram.py](../32class/histogram.py.html)
    (from Section 3.2), that uses `Counter`, as defined in [counter.py](counter.py.html).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose an implementation of `__sub__()` for `Vector` (as defined in [vector.py](vector.py.html)
    that subtracts two vectors.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that `__sub__()` calls `__add__()` and `__mul__()`. The advantage of such
    implementations is that they limit the amount of detailed code to check; the disadvantage
    is that they can be inefficient. In this case, `__add__()` and `__mul__()` both
    create new `Vector` objects, so copying the code for `__add__()` and replacing
    the minus sign with a plus sign is probably a better implementation.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement a data type `Vector2D` for two-dimensional vectors that has the same
    API as `Vector` (as defined in [vector.py](vector.py.html), except that the constructor
    takes two floats as arguments. Use two floats (instead of an array) for instance
    variables.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `Vector2D` data type of the previous exercise using one `Complex`
    object as the only instance variable.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove that the dot product of two two-dimensional unit-vectors is the cosine
    of the angle between them.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a data type `Vector3D` for three-dimensional vectors that has the
    same API as `Vector`, except that the constructor takes three floats as arguments.
    Also, add a *cross product* method: the cross product of two vectors is another
    vector, defined by the equation'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **a** × **b** = **c** &#124;**a**&#124; &#124;**b**&#124; sin θ |'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: 'where **c** is the unit normal vector perpendicular to both **a** and **b**,
    and θ is the angle between **a** and **b**. In Cartesian coordinates, the following
    equation defines the cross product:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (*a*[0], *a*[1], *a*[2]) × (*b*[0], *b*[1], *b*[2]) = (*a*[1] *b*[2] - *a*[2]
    *b*[1], *a*[2] *b*[0] - *a*[0] *b*[2], *a*[0] *b*[1] - *a*[1] *b*[0]) |'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: The cross product arises in the definition of torque, angular momentum, and
    vector operator curl. Also, |**a** × **b**| is the area of the parallelogram with
    sides **a** and **b**.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which modifications (if any) would you need to make `Vector` (see [vector.py](vector.py.html))
    work with `Complex` components (see [complex.py](../32class/complex.py.html) from
    Section 3.2) or `Rational` components (see the "rational numbers" exercise in
    Section 3.2)?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to [charge.py](../32class/charge.py.html) (from Section 3.2) to make
    `Charge` objects comparable using the value of the charge to determine the order.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a function `fibonacci()` that takes an integer argument `n` and computes
    the `n`th Fibonacci number. Use tuple packing and unpacking.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Revise the `gcd()` function in [euclid.py](../23recursion/euclid.py.html) (from
    Section 2.3) so that it takes two nonnegative integer arguments `p` and `q` and
    returns a tuple of integers (`d`, `a`, `b`) such that `d` is the greatest common
    divisor of `p` and `q`, and the coefficients `a` and `b` satisfy Bezout''s identity:
    `d = a*p + b*q`. Use tuple packing and unpacking.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: This algorithm is known as *extended Euclid''s algorithm*:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discuss the advantages and disadvantages of Python's design in making the built-in
    type `bool` be a subclass of the built-in type `int`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to `Counter` (as defined in [counter.py](counter.py.html) to raise
    a `ValueError` at run time if the client tries to create a `Counter` object using
    a negative value for `maxCount`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use exceptions to develop an implementation of `Rational` (see the "rational
    numbers" exercise in Section 3.2) that raises a `ValueException` at run time if
    the denominator is zero.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Data-Type Design Exercises
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*This group of exercises is intended to give you experience in developing data
    types. For each problem, design one or more APIs with API implementations, testing
    your design decisions by implementing typical client code. Some of the exercises
    require either knowledge of a particular domain or a search for information about
    it on the web.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Statistics**. Develop a data type for maintaining statistics of a set of
    floats. Provide a method to add data points and methods that return the number
    of points, the mean, the standard deviation, and the variance. Develop two implementations:
    one whose instance values are the number of points, the sum of the values, and
    the sum of the squares of the values, and another that keeps an array containing
    all the points. For simplicity, you may take the maximum number of points in the
    constructor. Your first implementation is likely to be faster and use substantially
    less space, but is also likely to be susceptible to roundoff error.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Genome**. Develop a data type to store the genome of an organism. Biologists
    often abstract the genome to a sequence of nucleotides (A, C, G, or T). The data
    type should support the methods `addCodon(c)` and `baseAt(i)`, as well as `isPotentialGene()`
    (see [potentialgene.py](../31datatype/potentialgene.py.html) from Section 3.1).
    Develop three implementations.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a string as the only instance variable; implement `addCodon()` with string
    concatenation.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an array of single-character strings as the only instance variable; implement
    `addCodon()` with the `+=` operator.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a boolean array, encoding each base with two bits.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time**. Develop a data type for the time of day. Provide client methods that
    return the current hour, minute, and second, as well as a `__str__()` method.
    Develop two implementations: one that keeps the time as a single `int` value (number
    of seconds since midnight) and another that keeps three `int` values, one each
    for seconds, minutes, and hours.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vector fields**. Develop a data type for force vectors in two dimensions.
    Provide a constructor, a method to add two vectors, and an interesting test client.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dates**. Develop an API for dates (year, month, day). Include methods for
    comparing two dates chronologically, computing the number of days between two
    dates, determining the day of the week of a given date, and any other operations
    that you think a client might want. After you have designed your API, look at
    the Python''s `datetime.date` data type.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Polynomials**. Develop a data type for univariate polynomials with integer
    coefficients, such as *x*³ + 5*x*² + 3*x* + 7\. Include methods for standard operations
    on polynomials such as addition, subtraction, multiplication, degree, evaluation,
    composition, differentiation, definite integration, and testing equality.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rational polynomials**. Repeat the previous exercise, ensuring that the polynomial
    data type behaves correctly when provided coefficients of type `int`, `float`,
    `complex`, and `Fraction` (see the "rational numbers" exercise in Section 3.2).'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Calendar**. Develop `Appointment` and `Calendar` APIs that can be used to
    keep track of appointments (by day) in a calendar year. Your goal is to enable
    clients to schedule appointments that do not conflict and to report current appointments
    to clients. Use Python''s `datetime` module.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vector field**. A vector field associates a vector with every point in a
    Euclidean space. Compose a version of [potential.py](../31datatype/potential.py.html)
    (from Section 3.1) that takes as input a grid size *n*, computes the `Vector`
    value of the potential due to the point charges at each point in an *n*-by-*n*
    grid of equally spaced points, and draws the unit vector in the direction of the
    accumulated field at each point.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sketching**. Pick an interesting set of documents from the booksite (or use
    a collection of your own) and run [comparedocuments.py](comparedocuments.py.html)
    with various command-line arguments, to learn about their effect on the computation.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Multimedia search**. Develop sketching strategies for sound and pictures,
    and use them to discover interesting similarities among songs in the music library
    and photos in the photo album on your computer.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data mining**. Compose a recursive program that surfs the web, starting at
    a page given as the first command-line argument, and looks for pages that are
    similar to the page given as the second command-line argument, as follows. To
    process a name, open an input stream, do a `readAll()`, sketch it, and write the
    name if its distance to the target page is greater than the threshold value given
    as the third command-line argument. Then scan the page for all strings that contain
    the substring `http://` and (recursively) process pages with those names. *Note*:
    This program might read a very large number of pages!'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
