- en: 2.3   Quicksort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/23quicksort](https://algs4.cs.princeton.edu/23quicksort)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Quicksort is popular because it is not difficult to implement, works well for
    a variety of different kinds of input data, and is substantially faster than any
    other sorting method in typical applications. It is in-place (uses only a small
    auxiliary stack), requires time proportional to N log N on the average to sort
    N items, and has an extremely short inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: The basic algorithm.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quicksort is a divide-and-conquer method for sorting. It works by *partitioning*
    an array into two parts, then sorting the parts independently.![Quicksort overview](../Images/7133ac8bc941198c386419eae49a6d6b.png)The
    crux of the method is the partitioning process, which rearranges the array to
    make the following three conditions hold:'
  prefs: []
  type: TYPE_NORMAL
- en: The entry `a[j]` is in its final place in the array, for some `j`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No entry in `a[lo]` through `a[j-1]` is greater than `a[j]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No entry in `a[j+1]` through `a[hi]` is less than `a[j]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We achieve a complete sort by partitioning, then recursively applying the method
    to the subarrays. It is a *randomized* algorithm, because it randomly shuffles
    the array before sorting it.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To complete the implementation, we need to implement the partitioning method.
    We use the following general strategy: First, we arbitrarily choose `a[lo]` to
    be the partitioning item—the one that will go into its final position. Next, we
    scan from the left end of the array until we find an entry that is greater than
    (or equal to) the partitioning item, and we scan from the right end of the array
    until we find an entry less than (or equal to) the partitioning item.![Quicksort
    partitioning overview](../Images/f51cf8a7d2f60693d39cb5ed98face62.png)The two
    items that stopped the scans are out of place in the final partitioned array,
    so we exchange them. When the scan indices cross, all that we need to do to complete
    the partitioning process is to exchange the partitioning item `a[lo]` with the
    rightmost entry of the left subarray (`a[j]`) and return its index `j`.![Quicksort
    partitioning](../Images/107bb0b25994e6502758b8e42f241f16.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Quick.java](Quick.java.html) is an implementation of quicksort, using the
    partitioning method described above.![Quicksort trace](../Images/4ed80061292b6891faf286d40c006a73.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation details.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several subtle issues with respect to implementing quicksort that
    are reflected in this code and worthy of mention.
  prefs: []
  type: TYPE_NORMAL
- en: '*Partitioning inplace.* If we use an extra array, partitioning is easy to implement,
    but not so much easier that it is worth the extra cost of copying the partitioned
    version back into the original.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Staying in bounds.* If the smallest item or the largest item in the array
    is the partitioning item, we have to take care that the pointers do not run off
    the left or right ends of the array, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Preserving randomness.* The random shuffle puts the array in random order.
    Since it treats all items in the subarrays uniformly, [Quick.java](Quick.java.html)
    has the property that its two subarrays are also in random order. This fact is
    crucial to the algorithm''s predictability. An alternate way to preserve randomness
    is to choose a random item for partitioning within `partition()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Terminating the loop.* Properly testing whether the pointers have crossed
    is a bit trickier than it might seem at first glance. A common error is to fail
    to take into account that the array might contain other keys with the same value
    as the partitioning item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling items with keys equal to the partitioning item''s key.* It is best
    to stop the left scan for items with keys greater than *or equal to* the partitioning
    item''s key and the right scan for items less than *or equal to* the partitioning
    item''s key. Even though this policy might seem to create unnecessary exchanges
    involving items with keys equal to the partitioning item''s key, it is crucial
    to avoiding quadratic running time in certain typical applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Terminating the recursion.* A common mistake in implementing quicksort involves
    not ensuring that one item is always put into position, then falling into an infinite
    recursive loop when the partitioning item happens to be the largest or smallest
    item in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quicksort uses ~2 N ln N compares (and one-sixth that many exchanges) on the
    average to sort an array of length N with distinct keys.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quicksort uses ~N²/2 compares in the worst case, but random shuffling protects
    against this case.
  prefs: []
  type: TYPE_NORMAL
- en: The standard deviation of the running time is about .65 N, so the running time
    tends to the average as N grows and is unlikely to be far from the average. The
    probability that quicksort will use a quadratic number of compares when sorting
    a large array on your computer is much less than the probability that your computer
    will be struck by lightning!
  prefs: []
  type: TYPE_NORMAL
- en: Improvements.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quicksort was invented in 1960 by C. A. R. Hoare, and it has been studied and
    refined by many people since that time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cutoff to insertion sort.* As with mergesort, it pays to switch to insertion
    sort for tiny arrays. The optimum value of the cutoff is system-dependent, but
    any value between 5 and 15 is likely to work well in most situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Median-of-three partitioning.* A second easy way to improve the performance
    of quicksort is to use the median of a small sample of items taken from the array
    as the partitioning item. Doing so will give a slightly better partition, but
    at the cost of computing the median. It turns out that most of the available improvement
    comes from choosing a sample of size 3 (and then partitioning on the middle item).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualization.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[QuickBars.java](QuickBars.java.html) visualizes quicksort with median-of-3
    partitioning and cutoff for small subarrays.![Quicksort visualization](../Images/97cd178e5a07aee6721b9297f1d037f0.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Entropy-optimal sorting.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays with large numbers of duplicate sort keys arise frequently in applications.
    In such applications, there is potential to reduce the time of the sort from linearithmic
    to linear.
  prefs: []
  type: TYPE_NORMAL
- en: One straightforward idea is to partition the array into three parts, one each
    for items with keys smaller than, equal to, and larger than the partitioning item's
    key. Accomplishing this partitioning was a classical programming exercise popularized
    by E. W. Dijkstra as the *Dutch National Flag problem*, because it is like sorting
    an array with three possible key values, which might correspond to the three colors
    on the flag.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's solution is based on a single left-to-right pass through the array
    that maintains a pointer `lt` such that `a[lo..lt-1]` is less than `v`, a pointer
    `gt` such that `a[gt+1..hi]` is greater than `v`, and a pointer `i` such that
    `a[lt..i-1]` are equal to v, and `a[i..gt]` are not yet examined.
  prefs: []
  type: TYPE_NORMAL
- en: '![Quicksort 3-way partitioning overview](../Images/953b02f78b8bbb545b40806c3a024bae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting with `i` equal to `lo` we process `a[i]` using the 3-way compare given
    us by the `Comparable` interface to handle the three possible cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a[i]` less than `v`: exchange `a[lt]` with `a[i]` and increment both `lt`
    and `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a[i]` greater than `v`: exchange `a[i]` with `a[gt]` and decrement `gt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a[i]` equal to `v`: increment `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Quicksort 3-way partitioning trace](../Images/eda2b31d5768752690b2413f6b2261c0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Quick3way.java](Quick3way.java.html) is an implementation of this method.'
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quicksort with 3-way partitioning is entropy-optimal.
  prefs: []
  type: TYPE_NORMAL
- en: Visualization.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Quick3wayBars.java](Quick3wayBars.java.html) visualizes quicksort with 3-way
    partitioning.![3-way quicksort visualization](../Images/7044e5f33bf05d01675262d99631ac27.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show, in the style of the trace given with `partition()`, how that method partitions
    the array `E A S Y Q U E S T I O N`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Partitioning trace](../Images/89d604462e59a0b4532827cb5ed0728d.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Show, in the style of the quicksort trace, how quicksort sorts the array `E
    A S Y Q U E S T I O N`. (For the purposes of this exercise, ignore the initial
    shuffle.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Quicksort trace](../Images/102a6d0a7dfbc2442b6e2c4a2350aa59.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Write a program [Sort2distinct.java](Sort2distinct.java.html) that sorts an
    array that is known to contain just two distinct key values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: About how many compares will `Quick.sort()` make when sorting an array of N
    items that are all equal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* ~ N lg N compares. Each partition will divide the array in half,
    plus or minus one.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Show, in the style of the trace given with the code, how the entropy-optimal
    sort first partitions the array `B A B A B A B A C A D A B R A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![3-way Partitioning trace](../Images/f0b435b8d2f94911800849fdbb99860a.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Creative Problems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Nuts and bolts.** (G. J. E. Rawlins). You have a mixed pile of N nuts and
    N bolts and need to quickly find the corresponding pairs of nuts and bolts. Each
    nut matches exactly one bolt, and each bolt matches exactly one nut. By fitting
    a nut and bolt together, you can see which is bigger. But it is not possible to
    directly compare two nuts or two bolts. Given an efficient method for solving
    the problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: customize quicksort to the problem. Side note: only a very complicated
    deterministic O(N log N) algorithm is known for this problem.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Best case.** Write a program [QuickBest.java](QuickBest.java.html) that produces
    a best-case array (with no duplicates) for `Quick.sort()`: an array of N distinct
    keys with the property that every partition will produce subarrays that differ
    in size by at most 1 (the same subarray sizes that would happen for an array of
    N equal keys). For the purposes of this exercise, ignore the initial shuffle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Best-case input for quicksort](../Images/de28bece22a68d5abe2a12deb6e17c87.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '**Fast three-way partitioning.** (J. Bentley and D. McIlroy). Implement an
    entropy-optimal sort [QuickBentleyMcIlroy.java](QuickBentleyMcIlroy.java.html)
    based on keeping equal keys at both the left and right ends of the subarray. Maintain
    indices p and q such that a[lo..p-1] that a[q+1..hi] are all equal to a[lo], an
    index i such that a[p..i-1] are all less than a[lo] and an index j such that a[j+1..q]
    are all greater than a[lo]. Add to the inner partitioning loop code to swap a[i]
    with a[p] (and increment p) if it is equal to v and to swap a[j] with a[q] (and
    decrement q) if it is equal to v before the usual comparisons of a[i] and a[j]
    with v.![Bentley-McIlroy 3-way partitioning overview](../Images/08d1fb2323dce430d0c67eea23260042.png)After
    the partitioning loop has terminated, add code to swap the equal keys into position.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[QuickKR.java](QuickKR.java.html) is one of the simplest quicksort implementations,
    and appears in K+R. Convince yourself that it is correct. How will it perform?
    All equal keys?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Randomized quicksort.** Modify `partition()` so that it always chooses the
    partitioning item uniformly at random from the array (instead of shuffling the
    array initially). Compare the performance against [Quick.java](Quick.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Antiquicksort.** The algorithm for sorting primitive types in Java 6 is a
    variant of 3-way quicksort developed by [Bentley and McIlroy](../references/papers/bentley-mcilroy.pdf).
    It is extremely efficient for most inputs that arise in practice, including inputs
    that are already sorted. However, using a clever technique described by M. D.
    McIlroy in [A Killer Adversary for Quicksort](../references/papers/mcilroy.pdf),
    it is possible to construct pathological inputs that make the system sort run
    in quadratic time. Even worse, it overflows the function call stack. To see the
    sorting library in Java 6 break, here are some killer inputs of varying sizes:
    [10,000](antiquicksort10K.txt), [20,000](antiquicksort20K.txt), [50,000](antiquicksort50K.txt),
    [100,000](antiquicksort100K.txt), [250,000](antiquicksort250K.txt), [500,000](antiquicksort500K.txt),
    and [1,000,000](antiquicksort1M.txt). You can test them out using the program
    [IntegerSort.java](IntegerSort.java.html) which takes a command line input N,
    reads in N integers from standard input, and sorts them using the system sort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bad partitioning.** How does not stopping on equal keys make quicksort go
    quadratic when all keys are equal?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Here is the result of partitioning AAAAAAAAAAAAAAA when we don''t
    stop on equal keys. It unevenly partitions the array into one subproblem of size
    0 and one of size 14.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Partitioning AAAAAAAAAAAAAAA when we don''t stop on equal keys](../Images/0038acc56487f1b7be11ec3d50f37e64.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Here is the result of partitioning AAAAAAAAAAAAAAA when we do stop on equal
    keys. It evenly partitions the array into two subproblems of size 7.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Partitioning AAAAAAAAAAAAAAA when we do stop on equal keys](../Images/330c426741c1ce20c7e877fb24d3308a.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '**Comparing an item against itself.** Show that our implementation of quicksort
    can compare an item against itself, i.e., calls `less(i, i)` for some index `i`.
    Modify our implementation so that it never compares an item against itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hoare''s original quicksort.** Implement a version of Hoare''s original quicksort
    algorithm. It''s similar to our two-way partitioning algorithm except that the
    pivot is not swapped into its final position. Instead, the pivot is left in one
    of the two subarrays, no element is fixed in its final position, and the two subarrays
    where the pointers cross are sorted recursively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* [HoareQuick.java](QuickHoare.java.html). We note that, while this
    verison is quite elegant, it does not preserve randomness in the subarrays. According
    to [Sedgewick''s PhD thesis](https://sedgewick.io/wp-content/themes/sedgewick/papers/1975Quicksort.pdf),
    "this bias not only makes analysis of the method virtually impossible, it also
    slows down the sorting process considerably."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dual-pivot quicksort.** Implement a version of Yaroslavskiy''s dual-pivot
    quicksort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* [QuickDualPivot.java](QuickDualPivot.java.html) is an implementation
    that is very similar to [Quick3way.java](Quick3way.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Three-pivot quicksort.** Implement a version of three-pivot quicksort ala
    [Kushagra-Ortiz-Qiao-Munro](http://epubs.siam.org/doi/abs/10.1137/1.9781611973198.6).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Number of compares.** Give a family of arrays of length n for which the standard
    quicksort partitioning algorithm makes (i) n + 1 compares, (ii) n compares, (iii)
    n - 1 compares, or argue that no such family of arrays exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: ascending order; descending order; none.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
