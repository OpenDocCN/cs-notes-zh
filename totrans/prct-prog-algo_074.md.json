["```\nclass Vector:\n    def __init__(self, a):\n        self._coords = a   # array of coordinates\n    ...\n\n```", "```\na = [3.0, 4.0]\nv = Vector(a)\na[0] = 17.0  # bypasses the public API\n\n```", "```\nclass Vector:\n    def __init__(self, a):\n        self._coords = a[:]   # array of coordinates\n    ...\n\n```", "```\nself._coords = tuple(a)\n\n```", "```\nx, y = y, x\n\n```", "```\na = [1 + 2j, 2 + 0j, 4 + 0j]\nx = Vector(a)\nb = abs(x)\n\n```", "```\n    def __eq__(self, other):\n        if self._rx != other._rx: return False\n        if self._ry != other._ry: return False\n        if self._q  != other._q:  return False\n        return True\n    def __ne__(self, other):\n       return not __eq__(self, other)\n\n```", "```\nhash(x) % m\n\n```", "```\ndef __hash__(self):\n    a = (self._rx, self._ry, self._q)\n    return hash(a)\n\n```", "```\ndef __lt__(self, other): return self._count <  other._count\ndef __le__(self, other): return self._count <= other._count\ndef __eq__(self, other): return self._count == other._count\ndef __ne__(self, other): return self._count != other._count\ndef __gt__(self, other): return self._count >  other._count\ndef __ge__(self, other): return self._count >= other._count\n\n```", "```\ndef square(x):\n    return x*x\n\ndef integrate(f, a, b, n=1000):\n    total = 0.0\n    dt = 1.0 * (b - a) / n\n    for i in range(n):\n        total += dt * f(a + (i + 0.5) * dt)\n    return total\n\n```", "```\nraise Exception('Error message here.')\n\n```", "```\nif len(self) != len(other):\n    raise Exception('vectors have different dimensions')\n\n```", "```\nassert self._count >= 0\n\n```", "```\nassert self._count >= 0, 'Negative count detected!'\n\n```", "```\n    def __sub__(self, other):\n        return self + (other * -1.0)\n\n    ```", "```\n    def gcd(p, q):\n        if q == 0: return (p, 1, 0)\n        (d, a, b) = gcd(q, p % q)\n        return (d, b, a - (p // q) * b)\n\n    ```"]