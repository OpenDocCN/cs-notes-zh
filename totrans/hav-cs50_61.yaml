- en: Lecture 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/sql/notes/4/](https://cs50.harvard.edu/sql/notes/4/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Introduction](#introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Views](#views)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Simplifying](#simplifying)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Aggregating](#aggregating)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-1)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Table Expression (CTE)](#common-table-expression-cte)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partitioning](#partitioning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-2)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Securing](#securing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Soft Deletions](#soft-deletions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fin](#fin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, we have learned about concepts that allow us to design complex databases
    and write data into them. Now, we will explore ways in which to obtain views from
    these databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go back to the database containing books longlisted for the International
    Booker Prize. Here is a snapshot of tables from this database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Tables containing books and authors with a many-to-many relationship"](../Images/37d0c83cc60cc470702cc3f30070fccc.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To find a book written by the author Han Kang, we would need to go each of through
    the three table above — first finding the author’s ID, then the corresponding
    book IDs and then the book titles. Instead, is there a way to put together related
    information from the three tables in a single view?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, we can use the `JOIN` command in SQL to combine rows from two or more tables
    based on a related column between them. Here is a visual representation of how
    these tables could be joined in order to line up authors and their books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Table joining books, authored and authors"](../Images/bd990bcb27da2bf534fd0af8eb8dcbf7.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This makes it simple to observe that Han Kang authored The White Book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One can also imagine removing the ID columns here, such that our view looks
    like the following.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Table joining books, authored and authors with the ID columns removed"](../Images/1f84dc8f7a24746024223d38fba5816f.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A view is a virtual table defined by a query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Say we wrote a query to join three tables, as in the previous example, and then
    select the relevant columns. The new table created by this query can be saved
    as a view, to be further queried later on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Views are useful for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**simplifying**: putting together data from different tables to be queried
    more simply,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**aggregating**: running aggregate functions, like finding the sum, and storing
    the results,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**partitioning**: dividing data into logical pieces,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**securing**: hiding columns that should be kept secure. While there are other
    ways in which views can be useful, in this lecture we will focus on the above
    four.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us open up `longlist.db` on SQLite and run the `.schema` command to verify
    that the three tables we saw in the previous example are created: `authors`, `authored`
    and `books`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To select the books written by Fernanda Melchor, we would write this nested
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above query is complex — there are three `SELECT` queries in the nested
    query. To simplify this, let us first use `JOIN` to create a view containing authors
    and their books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a new terminal, let us connect to `longlist.db` again, and run the following
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that it is important to specify how two tables are joined, or the columns
    they are joined *on*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tip: The primary key column of one table is usually joined to the corresponding
    foreign key column of the other table!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Running this will pull up a table containing all the author names next to the
    titles of the books they have authored.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To save the virtual table created in the previous step as a view, we need to
    change the query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The view created here is called `longlist`. This view can now be used exactly
    as we would use a table in SQL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let us write a query to see all the data within this view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using this view, we can considerably **simplify** the query needed to find the
    books written by Fernanda Melchor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A view, being a virtual table, does not consume much more disk space to create.
    The data within a view is still stored in the underlying tables, but still accessible
    through this simplfied view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can we manipulate views to be ordered, or displayed differently?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, we can order books in a view in much the same way as we can in a table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, let us display the data within the `longlist` view, ordered by
    the book titles.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We could also have the view itself be ordered. We can do this by including an
    `ORDER BY` clause in the query used to create the view.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `longlist.db` we have a table containing individual ratings given to each
    book. In previous weeks, we saw how to find the average rating of every book,
    rounded to 2 decimal places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The results of the above query can be made more useful by displaying the title
    of every book, and perhaps the year in which each book was longlisted. This information
    is present in the `books` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use a `JOIN` to combine information from the `ratings` and `books`
    tables, joining on the book ID column.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the order of operations in this query — in particular, the placement
    of the `GROUP BY` operation at the end of the query after the two tables are joined.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This **aggregated** data can be stored in a view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let us see the data in this view.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: On adding more data to the `ratings` table, to obtain an up-to-date aggregate,
    we need to simply requery the view using a `SELECT` command like the above!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time a view is created, it gets added to the schema. We can verify this
    by running `.schema` to observe that `longlist` and `average_book_ratings` are
    now part of this database’s schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create temporary views that are not stored in the database schema, we can
    use `CREATE TEMPORARY VIEW`. This command creates a view that exists only for
    the duration of our connection with the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find the average rating of books *per year*, we can use the view we already
    created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we select the `rating` column from `average_book_ratings`, which
    already contains the average ratings per book. Next, we group these by year and
    calculate the average ratings again, which gives us the average rating per year!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can store the results in a temporary view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can temporary views be used to test whether a query works or not?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, this is a great use case for temporary views! To generalize a little, temporary
    views are used when we want to organize data in some way without actually storing
    that organization long-term.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Table Expression (CTE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A regular view exists forever in our database schema. A temporary view exists
    for the duration of our connection with the database. A CTE is a view that exists
    for a single query alone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us recreate the view containing average book ratings per year using a CTE
    instead of a temporary view. First, we need to drop the existing temporary view
    so that we can reuse the name `average_book_ratings`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we create a CTE containing the average ratings *per book*. We then use
    the average ratings per book to calculate the average ratings *per year*, in much
    the same way as we did before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Partitioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views can be used to partition data, or to break it into smaller pieces that
    will be useful to us or an application. For example, the website for the International
    Booker Prize has a page of longlisted books for each year the prize was awarded.
    However, our database stores all the longlisted books in a single table. For the
    sake of creating the website, or a different purpose, it might be useful to have
    a different table (or view) of books for each year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us create a view to store books longlisted in 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also see the data in this view.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can views be updated?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No, because views do not have any data in the way that tables do. Views actually
    pull data from the underlying tables each time they are queried. This means that
    when an underlying table is updated, the next time the view is queried, it will
    display updated data from the table!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views can be used to enhance database security by limiting access to certain
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a rideshare company’s database with a table `rides` that looks like
    the following.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Rides table containing destination, origin and riders"](../Images/ceb3b27f1a3a1b8e16b6e2471df11958.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If we were to give this data to an analyst, whose job is to find the most popular
    ride routes, it would be irrelevant and indeed, not secure to give them the names
    of individual riders. Rider names are likely categorized as Personally Identifiable
    Information (PII) which companies are not allowed to share indiscriminately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views can be handy in this situation — we can share with the analyst a view
    containing the origin and destination of rides, but not the rider names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To try this out, let us open `rideshare.db` in our terminal. Running `.schema`
    should reveal one table called `rides` in this database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a view with the relevant columns, while omitting the `rider` column
    altogether. But we will go one step further here, and create a `rider` column
    to display an anonymous rider for each row in the table. This will indicate to
    the analyst that while we have rider names in the database, the names have been
    anonymized for security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can query this view to ensure that it is secure.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Although we can create a view that anonymizes data, SQLite does not allow access
    control. This means that our analyst could simply query the original `rides` table
    and see all the rider names we went to great lengths to omit in the `analysis`
    view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soft Deletions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in previous weeks, a soft deletion involves marking a row as deleted
    instead of removing it from the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a piece of art called “Farmers working at dawn” is marked as deleted
    from the `collections` table by changing the value in the `deleted` column from
    0 to 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Soft deletion of a row by changing the "deleted" value from 0 to 1"](../Images/3ce85ea046490ed360444ef231a1684e.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can imagine creating a view to display only the art that is not deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To try this, let us open `mfa.db` in our terminal. The `collections` table does
    not have a `deleted` column yet, so we need to add it. The default value here
    will be 0, to indicate that the row is not deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let us perform a soft delete on the artwork “Farmers working at dawn”,
    by updating it to have 1 in the `deleted` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can create a view to display information about the rows that are not deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can display the data in this view to verify that “Farmers working at dawn”
    is not present.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: On soft deletion of a row from the underlying table `collections`, it will be
    removed from the `current_collections` view on any further querying.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We already know that it is not possible to insert data into or delete data from
    a view. However, we can set up a trigger that inserts into or deletes from the
    underlying table! The `INSTEAD OF` trigger allows us to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time we try to delete rows from the view, this trigger will instead update
    the `deleted` column of the row in the underlying table `collections`, thus completing
    the soft deletion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the keyword `OLD` within our update clause to indicate that the ID of
    the row updated in `collections` should be the same as the ID of the row we are
    trying to delete from `current_collections`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can delete a row from the `current_collections` view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can verify that this worked by querying the view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, we can create a trigger that inserts data into the underlying table
    when we try to insert it into a view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two situations to consider here. We could be trying to insert into
    a view a row that already exists in the underlying table, but was soft deleted.
    We can write the following trigger to handle this situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WHEN` keyword is used to check if the accession number of the artwork already
    exists in the `collections` table. This works because an accession number, as
    we know from previous weeks, uniquely identifies every piece of art in this table.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the artwork does exist in the underlying table, we set its `deleted` value
    to 0, indicating a reversal of the soft deletion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second situation occurs when we are trying to insert a row that does not
    exist in the underlying table. The following trigger handles this situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the accession number of the inserted data is not already present within
    `collections`, it inserts the row into the table.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This brings us to the conclusion of Lecture 4 about Viewing in SQL!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
