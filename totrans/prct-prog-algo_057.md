# 9.8 蒙特卡罗模拟

> 原文：[`introcs.cs.princeton.edu/java/98simulation`](https://introcs.cs.princeton.edu/java/98simulation)

本节正在大规模施工中。

1953 年，恩里科·费米、约翰·帕斯塔和斯坦斯劳·乌拉姆创建了第一个“计算机实验”来研究振动的原子晶格。非线性系统无法通过经典数学进行分析。

模拟=模拟物理系统的分析方法。蒙特卡洛模拟=使用随机生成的值来处理不确定变量。以摩纳哥著名赌场命名。在计算的每个步骤中，重复多次以生成可能情景范围，并对结果进行平均。广泛适用的蛮力解决方案。计算密集型，因此在其他技术失败时使用。通常，准确性与重复次数的平方根成正比。这些技术广泛应用于各个领域，包括：设计核反应堆，预测恒星的演化，预测股市走势等。

**生成随机数。** 数学库函数`Math.random`生成大于或等于 0.0 且小于 1.0 的伪随机数。如果要生成随机整数或布尔值，最好的方法是使用库`Random`。程序 RandomDemo.java 演示了如何使用它。

```
Random random = new Random();
boolean a = random.nextBoolean();   // true or false
int     b = random.nextInt();       // between -2³¹ and 2³¹ - 1
int     c = random.nextInt(100);    // between 0 and 99
double  d = random.nextDouble();    // between 0.0 and 1.0
double  e = random.nextGaussian();  // Gaussian with mean 0 and stddev = 1

```

请注意，您应该在程序中只创建一个新的`Random`对象。通过创建多个对象，您不会获得更多“随机”的结果。对于调试，您可能希望每次程序执行时生成相同的伪随机数序列。要做到这一点，请使用带有`long`参数的构造函数。

```
Random random = new Random(1234567L);

```

伪随机数生成器将使用 1234567 作为种子。对于需要密码安全的伪随机数，例如密码学或老虎机，使用`SecureRandom`。

**线性同余随机数生成器。** 对于整数类型，我们必须注意溢出。考虑 a * b (mod m)作为一个例子（无论是在 a^b (mod m)的上下文中还是线性同余随机数生成器中：给定常数 a、c、m 和种子 x[0]，迭代：x = (a * x + c) mod m。Park 和 Miller 建议 a = 16807，m = 2147483647，c = 0 适用于 32 位有符号整数。为避免溢出，使用 Schrage 的方法。

```
Precompute:  q = m / a, r = m % a
Iterate:     x = a * (x - x/ q) * q) - r * (x / q)

```

练习：计算循环长度。

**概率函数库。** OR-Objects 包含许多经典的[概率分布和随机数生成器](http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html)，包括正态分布、F 分布、卡方分布、伽玛分布、二项分布、泊松分布。您可以在这里下载[jar 文件](http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar)。程序 ProbDemo.java 演示了如何使用它。它从伽玛分布生成一个随机值和从二项分布生成 5 个随机值。请注意，该方法称为`getRandomScaler`而不是`getRandomScalar`。

```
GammaDistribution x = new GammaDistribution(2, 3);
System.out.println(x.getRandomScaler());

BinomialDistribution y = new BinomialDistribution(0.1, 100);
System.out.println(y.getRandomVector(5));

```

**排队模型。** M/M/1 等。一个制造设施有 M 台相同的机器。每台机器在指数分布的平均时间 1 / μ后发生故障。一个维修人员负责维护所有机器，修理一台机器的时间服从平均时间 1 / λ的指数分布。模拟没有机器运行的时间比例。

## 扩散限制聚集。

扩散=经历随机漫步。物理过程*扩散限制聚集*（DLA）模拟了表面上聚集物质的形成，包括地衣生长、溶液中聚合物的生成、柴油发动机气缸壁上的碳沉积、电放电路径和城市定居。

当粒子一个接一个地释放到空间体积中时，受到随机热运动的影响，模拟的聚集形成。有限的概率使得粒子之间的短程吸引会影响运动。两个接触的粒子将粘在一起形成一个更大的单位。随着聚集中形成占用位置的簇，粘附的概率增加，刺激进一步生长。使用蒙特卡洛方法在 2D 中模拟这个过程：创建一个 2D 网格，并通过一个发射区域逐个向晶格引入粒子。粒子被释放后，它会进行随机漫步，直到它要么粘附到聚集上，要么漫步到晶格之外的*杀伤区*。如果漫步的粒子进入一个空位旁边的占用位置，那么粒子的当前位置自动成为聚集的一部分。否则，随机漫步继续。重复这个过程，直到聚集包含一定数量的粒子。*参考资料：* Wong, Samuel, Computational Methods in Physics and Engineering, 1992.

程序 DLA.java 模拟了 DLA 的生长过程，具有以下特性。它使用了辅助数据类型 Picture.java。将初始聚集设置为 N×N 格子的底行。从顶行的随机单元中释放粒子。假设粒子向上的概率为 0.15，向下的概率为 0.35，向左或向右的概率各为 1/4。持续进行，直到粒子粘附到相邻单元（上方、下方、左侧、右侧或四个对角线之一）或离开 N×N 格子。向下的首选方向类似于温度梯度对布朗运动的影响，或者类似于晶体形成时，聚集的底部比顶部冷却更多；或者类似于重力的影响。为了效果，我们按照从红色到紫色的彩虹顺序对粒子进行着色。下面是三个 N = 176 的模拟；这里是一个 N = 600 的图像 dla-big.png。

| ![扩散限制凝聚 1](img/9799a0a903aad52bdc7a142bfa358c04.png) | ![扩散限制凝聚 2](img/6ae1295c6e0c4eca32048911b98ea71d.png) | ![扩散限制凝聚 3](img/b3e8ab83eb8863a1dfd9bf76a62aab76.png) |
| --- | --- | --- |

**布朗运动。** 布朗运动是一种随机过程，用于模拟各种物理现象，包括墨水在水中扩散以及量子物理学预测的原子粒子的行为。([更多应用](http://www.doc.ic.ac.uk/~nd/surprise_95/journal/vol4/ykl/report.html))。宇宙中的基本随机过程。它是离散随机漫步的极限，也是高斯分布的随机模拟。现在广泛应用于计算金融、经济学、排队理论、工程学、机器人技术、医学成像、生物学和柔性制造系统。1828 年由苏格兰植物学家罗伯特·布朗首次研究，并在 1905 年由阿尔伯特·爱因斯坦进行数学分析。让-巴蒂斯特·佩兰进行实验证实了爱因斯坦的预测，并因此获得了诺贝尔奖。一个[小程序](http://www.phy.ntnu.edu.tw/java/gas2D/gas2D.html)来说明可能控制布朗运动原因的物理过程。

**模拟布朗运动。** 由于布朗运动是一个连续和随机的过程，我们只能希望在有限区间上绘制一条路径，在有限数量的点上采样。我们可以在这些点之间进行线性插值（即连接这些点）。为简单起见，我们假设区间从 0 到 1，采样点 t[0]，t[1]，...，t[N]在这个区间内等间距。要模拟标准布朗运动，重复生成均值为 0，标准差为 sqrt(1/N)的独立高斯随机变量。在时间 i 处的布朗运动值是前 i 个增量的总和。

| ![布朗运动](img/19255e8477d833e9551cc7049e910365.png) | ![布朗运动](img/4dde95b10de31ea808f249e23cd04e96.png) | ![布朗运动](img/ff1d630341f8f15dd20a4778d1b821f1.png) |
| --- | --- | --- |

**几何布朗运动。** 布朗运动的一个变体被广泛用于模拟股票价格，而诺贝尔奖获得者布莱克-斯科尔斯模型是基于这个随机过程的。具有漂移μ和波动率σ的几何布朗运动是一个可以模拟股票价格的随机过程。参数μ表示百分比漂移。如果μ = 0.10，则我们预期股票每年增长 10%。参数σ表示百分比波动率。如果σ = 0.20，则一年内股价的标准差大约是当前股价的 20%。要从时间 t = 0 模拟几何布朗运动到时间 t = T，我们遵循标准布朗运动的相同过程，但是将增量相乘，而不是相加，并且结合漂移和波动率参数。具体来说，我们将当前价格乘以(1 + μΔt + σsqrt(Δt)Z)，其中 Z 是标准高斯，Δt = T/N，从 X(0) = 100 开始，σ = 0.04。

[BM 的构造](http://www.cse.ucsc.edu/~chang/203/bm.pdf)。

*布莱克-斯科尔斯公式。* 移至此处？

**Ising 模型。** 电子围绕原子核的运动产生与原子相关的磁场。这些*原子磁铁*表现得很像传统磁铁。通常，磁铁指向随机方向，所有力相互抵消，在宏观物质块中没有整体磁场。然而，在一些材料中（例如铁），磁铁可以排列产生可测量的磁场。19 世纪物理学的一个重大成就是描述和理解控制原子磁铁的方程。状态 S 发生的概率由玻尔兹曼概率密度函数给出，P(S) = e^(-E(S)/kT) / Z，其中 Z 是归一化常数（*分区函数*）对所有状态 A 求和 e^(-E(A)/kT)，k 是玻尔兹曼常数，T 是绝对温度（以开尔文度表示），E(S)是系统在状态 S 的能量。

Ising 模型被提出来描述晶体材料中的磁性。还模拟其他自然现象，包括：液体的冻结和蒸发，蛋白质折叠，以及玻璃物质的行为。

*Ising 模型。* 玻尔兹曼概率函数是磁性的一个优雅模型。然而，将其应用于计算真实铁磁体的磁性属性并不实际，因为任何宏观铁块包含大量原子，并且它们以复杂的方式相互作用。[Ising 模型](http://oscar.cacr.caltech.edu/Hrothgar/Ising/)是一个简化的磁铁模型，捕捉了许多重要特性，包括在临界温度下的相变。（在此温度以上，没有宏观磁性，在此以下，系统表���出磁性。例如，铁在大约 770 摄氏度左右失去磁化。值得注意的是，转变是突然的。）[参考链接](http://www.npac.syr.edu/users/gcf/cps713montecarlo/p_montecarlo.html)

20 世纪 20 年代由 Lenz 和 Ising 首次引入。在 Ising 模型中，铁磁体被分成一个 N×N 的单元格网格。（顶点=晶体中的原子，边=相邻原子之间的键。）每个单元格包含一个称为*自旋*的抽象实体。单元格 i 的自旋 s[i]处于两种状态之一：指向上方（+1）或指向下方（-1）。单元格之间的相互作用仅限于*最近邻居*。系统的总磁性 M = s[i]的总和。系统的总能量 E = - J s[i] s[j]的总和，其中总和取自所有最近邻居 i 和 j。常数 J 衡量自旋-自旋相互作用的强度（以能量单位，如 ergs）。[该模型可以扩展以允许与外部磁场的相互作用，此时我们在所有站点 k 上添加项-B s[k]的总和。]如果 J > 0，当自旋对齐时（都是+1 或都是-1）能量最小化-这模拟了*铁磁性*。如果 J < 0，当自旋相反对齐时能量最小化-这模拟了*反铁磁性*。

鉴于这个模型，在统计力学中的一个经典问题是计算期望的磁性。*状态*是指定 N² 晶格单元格中每个自旋的规范。系统的期望磁性 E[M] = 在所有状态 S 上的 M(S) P(S)的总和，其中 M(S)是状态 S 的磁性，P(S)是根据玻尔兹曼概率函数发生状态 S 的概率。不幸的是，这个方程不适合直接计算，因为对于 N×N 晶格，状态 S 的数量为 2^(N*N)。直接的蒙特卡洛积分不起作用，因为随机点不会对总和有太大贡献。需要选择性采样，理想情况下按比例采样点 e^(-E/kT)。 （1925 年，Ising 解决了一维问题-没有相变。1944 年，Onsager 通过一次成功的解决了 2D Ising 问题。他的解决方案表明它具有相变。不太可能在 3D 中解决-请参见难以解决部分。）

*Metropolis 算法。*蒙特卡罗方法的广泛使用始于 Metropolis 算法，用于计算刚性球体系统。在 Metropolis、Rosenbluth、Rosenbluth、Teller 和 Teller 之间的晚餐交谈后于 1953 年发表。广���用于研究原子系统的平衡性质。使用马尔可夫链采样，使用 Metropolis 规则：如果ΔE <= 0，则从 A 转换到 B 的概率为 1，如果ΔE > 0，则为 e^(-ΔE/kT)的概率。当应用于 Ising 模型时，这个马尔可夫链是遍历的（类似于 Google PageRank 的要求），因此 Metropolis 算法的理论适用。收敛到稳态分布。

程序 Cell.java、State.java 和 Metropolis.java 实现了 2D 晶格的 Metropolis 算法。Ising.java 是一种过程式编程版本。"通过掷骰子来做物理学。"通过一系列简单的随机步骤模拟复杂的物理系统。

测量物理量。当系统热化（系统已经达到与其周围环境的共同温度 T 的热平衡）时，测量磁性、能量、比热。随时间计算平均能量<e>和平均磁化<m>。还有计算能量的方差或*比热*<c> = <E²> - <E>²，以及磁化的方差或*磁化率*<Χ> = <M²> - <M>²。确定系统何时热化是一个具有挑战性的问题-在实践中，许多科学家使用专门的方法。</m></e>

*相变。* 当温度 T[c]为 2 / ln(1 + sqrt(2)) = 2.26918 时，相变发生。T[c]被称为居里温度。绘制磁化 M（所有自旋的平均值）与温度（kT = 1 至 4）的关系。斜率的不连续是*二阶相变*的标志。斜率趋近于无穷大。绘制能量（所有自旋-自旋相互作用的平均值）与温度（kT = 1 至 4）的关系。通过相变的平滑曲线。与[精确解](http://www.nyu.edu/classes/tuckerman/stat.mech/lectures/lecture_26/node2.html)进行比较。算法明显减慢的临界温度。以下是 J/kT = 0.4（热/无序）和 0.47（冷/有序）的第 5000 个样本轨迹。随着温度的降低，系统变得磁性；此外，随着温度的降低，相邻位置具有相同自旋的概率增加（更多聚集）。

实验。

+   从远高于临界温度开始。状态收敛到几乎均匀，不受初始状态（全部上、全部下、随机）的影响，并且波动迅速。零磁化。

+   从远低于临界温度开始。所有自旋都具有相同的值（全部上或全部下）。形成一些小的相反自旋团簇。

+   从远低于临界温度开始。从随机自旋开始。每种自旋形成大团簇；最终模拟会做出决定。大团簇在上自旋或下自旋中同等可能。

+   从接近临界温度开始。大团簇形成，但波动非常缓慢。

| ![J/kT = 0.40 的伊辛模型](img/c7035f5715c0714de06dad48e84d6cab.png) |           | ![J/kT = 0.47 的伊辛模型](img/47a433a69030ff78d1513618c24d1f25.png) |
| --- | --- | --- |

伊辛模型在 1D 和 2D 中的精确解已知；在 3D 和非平面图中是 NP 难的。

模拟二元合金和自旋玻璃中的相变。还模拟神经网络、成群的鸟类和跳动的心脏细胞。已有超过 10,000 篇论文使用伊辛模型。

#### 问答

#### 练习

1.  **打印一个随机单词。** 从标准输入中读取一个未知长度的单词列表，并以均匀随机的方式打印其中的一个单词。不要存储单词列表。而是使用 Knuth 的方法：在读取第 i 个单词时，以 1/i 的概率选择它作为新的冠军。在读取所有数据后打印出幸存的单词。

1.  **链表的随机子集。** 给定一个包含 N 个元素的数组和一个整数 k ≤ N，构造一个包含 k 个元素的随机子集的新数组。*提示*：遍历数组，以 a/b 的概率接受每个元素，其中 a 是剩余要选择的元素数，b 是剩余的元素数。

#### 创意练习

1.  **随机数生成。** 计算介于 0 和 N-1 之间的伪随机整数时，以下方法会失败吗？`Math.random`保证返回大于或等于 0.0 且严格小于 1.0 的浮点数。

    ```
    double x = Math.random();
    int r = (int) (x * N);

    ```

    也就是说，你能找到一个实数`x`和一个整数`N`，使得 r 等于 N 吗？

    *解决方案：* 不，这在 IEEE 浮点算术中是不可能发生的。舍入误差不会导致结果为 N，即使`Math.random`返回 0.9999999999.... 然而，这种方法并不会均匀地产生整数，因为浮点数不是均匀分布的。此外，它涉及到强制转换和乘法，这是过度的。

1.  **随机数测试。** 编写一个程序来绘制布尔伪随机数生成器的结果。为简单起见，使用`(Math.random() < 0.5)`并在一个 128x128 的网格中绘制，就像以下的[伪随机 applet](http://www.alife.co.uk/nonrandom/)。也许使用 LFSR 或`Random.nextLong() % 2`。

1.  **从离散概率分布中抽样。** 假设有 N 个事件，事件*i*以概率 p[i]发生，其中 p[0] + p[1] + ... + p[N-1] = 1。 编写一个名为`Sample.java`的程序，根据概率分布打印出 1,000 个样本事件。 *提示*：选择一个介于 0 和 1 之间的随机数 r，并从 i = 0 迭代到 N-1，直到 p[0] + p[1] + ... + p[i] > r。 （要注意浮点精度。）

1.  **从离散概率分布中抽样。** 改进前一个问题的算法，使其生成新样本的时间与 log N 成正比。 *提示*：在累积和上进行二分查找。 *注意*：参见[这篇论文](http://citeseer.nj.nec.com/591481.html)，其中提供了一个非常巧妙的替代方案，可以在恒定的时间内生成随机样本。 Discrete.java 是 Warren D. Smith 的 WDSsampler.c 程序的 Java 版本。

1.  **从离散概率分布中抽样。** 重复上一个问题，但使其动态化。 也就是说，在每个样本之后，一些事件的概率可能会改变，或者可能会有新事件发生。 用于*n 倍算法*，这是*动力学蒙特卡洛方法*的首选方法，其中希望模拟动力学演化过程。 典型应用：模拟气体与基板表面反应，化学反应发生在不同速率的情况。 *提示*：使用二叉搜索树。

1.  **Zipf 分布。** 利用前面练习的结果从具有参数 s 和 N 的[Zipf 分布](http://en.wikipedia.org/wiki/Zipf's_law)中抽样。 该分布可以取 1 到 N 之间的整数值，并以概率 1/k^s / sum_(i = 1 to N) 1/i^s 取值 k。 例如：莎士比亚戏剧《哈姆雷特》中的单词，其中 s 约等于 1。

1.  **模拟马尔可夫链。** 编写一个程序 MarkovChain.java 来模拟马尔可夫链。 提示：您需要从离散分布中抽样。

1.  **非单位粘附概率的 DLA** 修改 DLA.java，使初始聚集由沿着晶格底部随机间隔的几个单元格组成。 这模拟了类似细菌生长的串状生长。

1.  **非单位粘附概率的 DLA** 修改 DLA.java 以允许小于 1 的粘附概率。 也就是说，如果一个粒子有邻居，则以概率 p < 1.0 粘附；否则，它会随机移动到一个未被占据的相邻单元格。 这会导致更多聚集结构，模拟原子之间更高的键合亲和力。

1.  **对称 DLA**。 将聚集初始化为晶格中心的单个粒子。 从初始粒子周围的圆形均匀发射粒子。 随着聚集大小的增加，增加发射圆的大小。 将您的程序命名为 SymmetricDLA.java。 这模拟了粒子从无限远处随机漫步进入聚集的生长过程��� 这里有一些加速过程的技巧[速度](http://www.oche.de/~ecotopia/dla/improvements.html)。

    | ![对称扩散有限聚集 1](img/00b446dde7a35a682b28042be1119e43.png) | ![对称扩散有限聚集 2](img/d676516f8363e4a3965bf78743bd4f9e.png) | ![对称扩散有限聚集 3](img/9ae380831e54f2b0ea0000099577762b.png) |
    | --- | --- | --- |

1.  **可变粘附概率**。 一个漫步的粒子进入一个空位，旁边是一个占据的位置，被分配一个随机数，表示粒子可以移动的潜在方向（上、下、左或右）。 如果新位置上存在占据的位置，则粒子通过占据其当前晶格位置而粘附到聚集体上。 如果没有，则移动到该位置，随机行走继续。 这模拟了雪花的生长。

1.  **拉普拉斯方程的随机漫步解。** 数值求解拉普拉斯方程以确定给定边界上电荷位置时的电势。拉普拉斯方程表明电势的梯度是相对于 x 和 y 的二阶偏导数之和。*参见 Gould 和 Tobochnik，10.2*。您的目标是找到满足指定边界条件的函数 V(x, y)。假设无电荷区域是一个正方形，且沿垂直边界的电势为 10，沿水平边界为 5。要解决拉普拉斯方程，将正方形分成一个 N×N 的点网格。单元格(x, y)的电势 V(x, y)是四个相邻单元格的电势的平均值。要估计 V(x, y)，模拟 100 万个从单元格(x, y)开始并持续到达边界的随机漫步者。V(x, y)的估计值是达到的 100 万个边界单元格的平均电势。编写一个程序 Laplace.java，它接受三个命令行参数 N、x 和 y，并估计 N×N 单元格网格上的 V(x, y)，其中第 0 列和 N 的电势为 10，第 0 行和 N 的电势为 5。

    备注：尽管上述边界值问题可以通过解析方法解决，但像上面的数值模拟在区域具有更复杂形状或需要为不同的边界条件重复时非常有用。

    模拟退火

1.  **模拟几何随机变量。** 如果某事件以概率 p 发生，则具有参数 p 的几何随机变量模拟事件发生之间所需的独立试验次数 N。要生成具有几何分布的变量，请使用以下公式

    > N = ceil(ln U / ln (1 - p))

    其中 U 是具有均匀分布的变量。使用 Math 库方法`Math.ceil`、`Math.log`和`Math.random`。

1.  **模拟指数随机变量。** 指数分布广泛用于模拟城市公交车之间的到达时间、灯泡故障之间的时间等。具有参数λ的指数随机变量小于*x*的概率是*x >= 0*时的*F(x) = 1 - e^(λ x)*。要从分布中生成随机偏差，使用反函数方法：输出-ln(U) / λ，其中 U 是 0 到 1 之间的均匀随机数。

1.  **泊松分布。** 泊松分布在描述任何特定小时间间隔内衰变的核数的波动方面非常有用。

    ```
    public static int poisson(double c) {
       double t = 0.0;
       for (int x = 0; true; x++) {
          t = t - Math.log(Math.random()) / c;  // sum exponential deviates
          if (t > 1.0) return x;
       }
    }

    ```

1.  **模拟帕累托随机变量。** 帕累托分布通常用于模拟保险索赔损失、金融期权持有时间和互联网流量活动。带参数*a*的帕累托随机变量小于*x*的概率是*x >= 0*时的*F(x) = 1 - (1 + x)^(-a)*。要从分布中生成随机偏差，使用反函数方法：输出(1-U)^(-1/a) - 1，其中 U 是 0 到 1 之间的均匀随机数。

1.  **模拟柯西随机变量。** 柯西随机变量的密度函数是 f(x) = 1/(Π(1 + x²))。柯西随机变量小于*x*的概率是*x >= 0*时的*F(x) = 1/Π (Π/2 + arctan(x))*。要从分布中生成随机偏差，使用反函数方法：输出 tan(Π(U - 1/2))，其中 U 是 0 到 1 之间的均匀随机数。

1.  **生成单位圆内随机点。** 在 0 和 1 之间均匀选择*r*，在 0.0 和 2π之间均匀选择θ，并使用(x, y) = (r cosθ, r sinθ)是不正确的。如果这样做，会更多的点靠近圆盘的中心。相反，设置(x, y) = (√r cosθ, √r sinθ)。或者，在-1 和 1 之间均匀生成 x 和 y，并在 x² + y² ≤ 1 时接受。使用这两种方法绘制一系列随机点并查看偏差。

1.  **翻转比特。** 作为遗传算法的一部分，假设您需要独立翻转 N 个比特，每个比特的概率为 p，其中 p 是一个非常小的常数。

    +   方法 1：循环遍历 N 位，为每一位生成一个 Bernouilli(p) 随机变量并相应地翻转。时间复杂度与 N 成正比。

    +   方法 2：生成一个几何分布(p) 随机变量 X_0 并翻转位 X_0；生成另一个几何分布(p) 随机变量并翻转位 X_0 + X_1，依此类推。时间复杂度与 Np 成正比。

    +   方法 3：在二项分布(N, p) 中翻转的位数。通过用高斯分布(Np, sigma) 随机变量近似来确定要翻转的位数。然后翻转 Z 位，注意避免重复。时间复杂度与 Np 成正比，但调用超越函数更少。

1.  **N 维球体内的随机点。** 编写一个程序`InsideSphere.java`，接受一个命令行参数 N，并计算一个半径为 1 的 N 维球体内的随机点。生成 N 个均匀随机变量 x[1], ..., x[N]，并使用这个点如果

    |

    ```
    (x1)2 + ... + (xN)2 ≤ 1

    ```

    |

    否则重复。

1.  **N 维球面上的随机点。** 编写一个程序 Sphere.java，接受一个命令行参数 N，并使用布朗方法计算 N 维球面上半径为 1 的随机点。布朗方法是计算 N 个独立的标准正态分布变量 x[1], x[N]，然后

    |

    ```
    ( x1/r, x2/r, ..., xN/r ), where r = sqrt((x1)2 + ... + (xN)2)

    ```

    |

    具有所需分布。使用第 3 节中的练习 xyz 来计算标准正态分布变量。

1.  **波茨模型。** *波茨模型* 是伊辛模型的一个变种，其中每个位置有 q 个可能的方向。（q = 2 对应于伊辛模型）系统的总能量 E = 所有邻居之间的 - J sigma(s[i], s[j]) 的总和。[Kronecker delta](http://en.wikipedia.org/wiki/Kronecker_delta) 函数 δ(x, y) = 如果 x = y 则为 1，否则为 0。

1.  **2D 布朗运动。** 模拟粒子在流体中的扩散。编写一个数据类型 BrownianParticle.java，表示一个在二维空间中经历布朗运动的粒子。为此，模拟两个独立的布朗运动 X(t) 和 Y(t)，并绘制 (X(t), Y(t))。创建一个客户端程序，接受一个命令行整数 N，将 N 个粒子放置在原点，并模拟 N 个粒子的布朗运动。

1.  **布朗桥。** *布朗桥* 是一种受限制的布朗运动，要求在时间 0 从原点开始，并在时间 T 结束于原点。如果 X(t) 是一个布朗运动，那么 Z(t) = X(t) - (t/T)X(T) 就是这样一个过程。要绘制，存储中间值 X(t)，并在计算完 X(T) 后绘制。

1.  **彩虹。** 1637 年，勒内·笛卡尔发现了对彩虹形成的第一个科学解释。他的方法涉及跟踪光线穿过球形雨滴时的内部反射。根据大量平行光线击中球形雨滴的模型，模拟[彩虹的生成](http://astro.temple.edu/~dhill001/MCRain/MCRain.html)。当光线击中雨滴时，光线会反射和折射。我们使用 HSB 颜色格式，并随机选择色调 h 在 0（红色）和 1（紫色）之间。我们使用 1.33 + 0.06 * h 作为色调 h 的折射率。对于每条光线，我们根据折射和反射的物理定律绘制一个光点。然后，观察者将看到每个光点以随机颜色绘制，无论是在主彩虹还是次彩虹中。为了进行模拟，我们均匀随机选择 7 种颜色中的一种。然后，我们选择单位圆中心为 (0, 0) 的点 (x, y)，并设置冲击参数 r = sqrt(x² + y²)。入射角 θ[i] = arcsin(r)，根据斯涅尔定律，折射角 θ[r] = arcsin (r / n)，其中 *n* 是折射率。如果光线完全反射一次，它以 θ[p] = 4θ[r] - 2θ[i] 的角度出射，贡献于主彩虹。如果光线完全反射第二次，它以 θ[p] = 6θ[r] - 2θ[i] - π 的角度出射，贡献于次彩虹。根据两个介质边界上的电磁波的传输和反射公式，计算主光线和次光线的强度 I[p] 和 I[s]。

    ```
    Ip = 1/2 (s(1-s)2 + p(1-p)2)
    Is = 1/2 (s2(1-s)2 + p2(1-p)2)
    p = (sin(θi-θr)/sin(θi+θr))2
    r = (tan(θi-θr)/tan(θi+θr))2

    ```

    颜色强度 I[p] 和 I[s] 用于确定 HSB 颜色格式中的饱和度。程序 Rainbow.java 模拟了这个过程。

    ![彩虹](img/f66c58ab1cdb1919c1a01bfda72059dc.png)

    [彩虹网站](http://www.rebeccapaton.net/rainbows/index.htm)。
