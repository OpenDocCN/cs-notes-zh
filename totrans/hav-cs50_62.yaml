- en: Lecture 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/sql/notes/5/](https://cs50.harvard.edu/sql/notes/5/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Introduction](#introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](#index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index across Multiple Tables](#index-across-multiple-tables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Space Trade-off](#space-trade-off)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Time Trade-off](#time-trade-off)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partial Index](#partial-index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-1)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vacuum](#vacuum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-2)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Concurrency](#concurrency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transactions](#transactions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Race Conditions](#race-conditions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fin](#fin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This week, we will learn how to optimize our SQL queries, both for time and
    space. We will also learn how to run queries concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will do all of this in the context of a new database — the Internet Movies
    Database, or IMDb as it is more popularly known. Our SQLite database is compiled
    from the large online database of movies you may have seen before at [imdb.com](imdb.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at these statistics to get a sense of how big this database is!
    It has much more data than any of the other databases we have worked with so far.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Statistics about the IMDb database"](../Images/2811d80304197c75e6c69bdda83c37eb.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Here is the ER Diagram detailing the entities and their relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["IMDb ER Diagram — people, movies, and ratings entities"](../Images/66be213591789cad4852d87ac70a236c.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us open up this database called `movies.db` in SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.schema` shows us the tables created in this database. To implement the many-to-many
    relationship between the entities Person and Movie from the ER Diagram, we have
    a joint table here called `stars` that references the ID columns of both `people`
    and `movies` as foreign key columns!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To peek into the `movies` table, we can select from the table and limit results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To find the information pertaining to the movie Cars, we would run the following
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Say we want to find how long it took for this query to run. SQLite has a command
    `.timer on` that enables us to time our queries.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On running the above query to find Cars again, we can see three different time
    measurements displayed along with the results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: “real” time indicates the stopwatch time, or the time between executing the
    query and obtaining the results. This is the measure of time we will focus on.
    The time taken to execute this query during lecture was roughly a tenth of a second!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, when the query to find Cars was run, we triggered a **scan**
    of the table `movies` — that is, the table `movies` was scanned top to bottom,
    one row at a time, to find all the rows with the title Cars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can optimize this query to be more efficient than a scan. In the same way
    that textbooks often have an index, databases tables can have an index as well.
    An index, in database terminology, is a structure used to speed up the retrieval
    of rows from a table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the following command to create an index for the `"title"` column
    in the `movies` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After creating this index, we run the query to find the movie titled Cars again.
    On this run, the time taken is significantly shorter (during lecture,almost eight
    times faster than the first run)!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, once the index was created, we just assumed that SQL
    would use it to find a movie. However, we can also explicitly see this by using
    a SQLite command `EXPLAIN QUERY PLAN` before any query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To remove the index we just created, run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After dropping the index, running `EXPLAIN QUERY PLAN` again with the `SELECT`
    query will demonstrate that the plan would revert to scanning the entire database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do databases not have implicit algorithms to optimize searching?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They do, for some columns. In SQLite and most other database management systems,
    if we specify that a column is a primary key, an index will automatically be created
    via which we can search for the primary key. However, for regular columns like
    `"title"`, there would be no automatic optimization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would it be advisable to create a different index for every column in case we
    need it?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While that seems useful, there are trade-offs with space and the time it takes
    to later insert data into tables with an index. We will see more on this shortly!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index across Multiple Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We would run the following query to find all the movies Tom Hanks starred in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To understand what kind of index could help speed this query up, we can run
    `EXPLAIN QUERY PLAN` ahead of this query again. This shows us that the query requires
    two scans — of `people` and `stars`. The table `movies` is not scanned because
    we are searching `movies` by its ID, for which an index is automatically created
    by SQLite!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us create the two indexes to speed this query up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we run `EXPLAIN QUERY PLAN` with the same nested query. We can observe
    that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: all the scans are now searches using indexes, which is great!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the search on the table `people` uses something called a `COVERING INDEX`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A covering index means that all the information needed for the query can be
    found within the index itself. Instead of two steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: looking up relevant information in the index,
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: using the index to then search the table, a covering index means that we do
    our search in one step (just the first one).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To have our search on the table `stars` also use a covering index, we can add
    `"movie_id"` to the index we created for `stars`. This will ensure that the information
    being looked up (movie ID) *and* the value being searched on (person ID) are both
    be in the index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let us drop the existing implementation of our index on the `stars` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we create the new index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the following will demonstrate that we now have two covering indexes,
    which should result in a much faster search!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Making sure that we have run `.timer on` let us execute the above query to find
    all the movies Tom Hanks has starred in, and observe the time it takes to run.
    The query now runs a *lot* faster than it did without indexes (in lecture, an
    order of magnitude faster)!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space Trade-off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexes seem incredibly helpful, but there are trade-offs associated — they
    occupy additional space in the database, so while we gain query speed, we do lose
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An index is stored in a database as a data structure called a B-Tree, or balanced
    tree. A tree data structure looks something like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Tree data structure"](../Images/013c41e6395b2e1f4864248d1183c072.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that the tree has many **nodes**, each connected to a few others by arrows.
    The root node, or the node from which the tree originates, has three **children**.
    Some nodes at the edge of the tree do not point to any other nodes. These are
    called **leaf** nodes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us consider how an index is created for the `"title"` column of the table
    `movies`. If the movie titles were sorted alphabetically, it would be a lot easier
    to find a particular movie by using [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, a copy is made of the `"titles"` column. This copy is sorted and
    then linked back to the original rows within the `movies` table by pointing to
    the movie IDs. This is visualized below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Index: Sorted copy of titles pointing to original movie IDs"](../Images/22e180e91d89658e7b799617b266c1fa.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: While this helps us visualize the index for this column easily, in reality,
    the index is not a single column but is broken up into many nodes. This is because
    if the database has a lot of data, like our IMDb example, storing one column all
    together in memory might not be feasible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have multiple nodes containing sections of the index, however, we also
    need nodes to navigate to the right sections. For example, consider the following
    nodes. The left-hand node directs us to the right section of the index based on
    whether the movie title comes before Frozen, between Frozen and Soul, or after
    Soul alphabetically!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Index nodes broken into sections"](../Images/a1b2e44432a54cacf44500335197cbf3.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The above representation is a B-tree! This is how indexes are stored in SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time Trade-off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the space trade-off we discussed earlier, it also takes longer to
    insert data into a column and then add it to an index. Each time a value is added
    to the index, the B-tree needs to be traversed to figure out where the value should
    be added!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an index that includes only a subset of rows from a table, allowing
    us to save some space that a full index would occupy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is especially useful when we know that users query only a subset of rows
    from the table. In the case of IMDb, it may be that the users are more likely
    to query a movie that was just released as opposed to a movie that is 15 years
    old. Let’s try to create a partial index that stores the titles of movies released
    in 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can check that searching for movies released in 2023 uses the new index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows us that the `movies` table is scanned using the partial index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are indexes saved in the schema?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, in SQLite, they are! We can confirm this by running `.schema` and we will
    see the indexes created listed in the database schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vacuum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are ways to delete unused space in our database. SQLite allows us to “vacuum”
    data — this cleans up previously deleted data (that is actually not deleted, but
    just marked as space being available for the next `INSERT`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find the size of `movies.db` on the terminal, we can use a Unix command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In lecture, this command showed us that the size of the database is something
    like 158 million bytes, or 158 megabytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now connect to our database and drop an index we previously created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if we run the Unix command again, we see that the size of the database
    has not decreased! To actually clean up the deleted space, we need to vacuum it.
    We can run the following command in SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This might take a second or two to run. On running the Unix command to check
    the size of the database again, we can should see a smaller size. Once we drop
    all the indexes and vacuum again, the database will be considerably smaller than
    158 MB (in lecture, around 100 MB).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is it possible to vacuum faster?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Each vacuum can take a different amount of time, depending on the amount of
    space we are trying to vacuum and how easy it is to find the bits and bytes that
    need to be freed up!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a query to delete some rows doesn’t actually delete them, but only marks
    them as deleted, could we still retrieve these rows?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: People trained in forensics are able to find data we think is deleted but is
    actually still on our computers. In the case of SQLite, after performing a vacuum,
    it would not be possible to find deleted rows again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, we have seen how to optimize single queries. Now, we will look at
    how to allow not just one query, but multiple at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency is the simultaneous handling of multiple queries or interactions
    by the database. Imagine a database for a website, or a financial service, that
    gets a lot of traffic at the same time. Concurrency is particularly important
    in these cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some database transactions can be multi-part. For example, consider a bank’s
    database. The following is a view of the table `accounts` that stores account
    balances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Accounts table in a bank''s database. Alice sends $10 to Bob."](../Images/bb31b5c75facd37e6222fc7937101a9a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: One transaction could be sending money from one account to the other. For example,
    Alice is trying to send $10 to Bob.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To complete this transaction, we would need to add $10 to Bob’s account and
    also subtract $10 from Alice’s account. If someone sees the status of the `accounts`
    database after the first update to Bob’s account but before the second update
    to Alice’s account, they could get an incorrect understanding of the total amount
    of money held by the bank.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To an outside observer, it should seem like the different parts of a transaction
    happen all at once. In database terminology, a transaction is an individual unit
    of work — something that cannot be broken down into smaller pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transactions have some properties, which can be remembered using the acronym
    ACID:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**atomicity**: can’t be broken down into smaller pieces,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**consistency**: should not violate a database constraint,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isolation**: if multiple users access a database, their transactions cannot
    interfere with each other,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**durability**: in case of any failure within the database, all data changed
    by transactions will remain.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s open up `bank.db` in our terminal so we can implement a transaction for
    transferring money from Alice to Bob!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we want to see the data already in the `accounts` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We note here that Bob’s ID is 2 and Alice’s ID is 1, which will be useful for
    our query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To move $10 from Alice’s account to Bob’s, we can write the following transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the `UPDATE` statements are written in between the commands to begin
    the transaction and to commit it. If we execute the query after writing the `UPDATE`
    statements, but without committing, neither of the two `UPDATE` statements will
    be run! This helps keep the transaction **atomic**. By updating our table in this
    way, we are unable to see the intermediate steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we tried to run the above transaction again — Alice tries to pay Bob another
    $10 — it should fail to run because Alice’s account balance is at 0\. (The `"balance"`
    column in `accounts` has a check constraint to ensure that it has a non-negative
    value. We can run `.schema` to check this.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way we implement reverting the transaction is using `ROLLBACK`. Once we
    begin a transaction and write some SQL statements, if any of them fail, we can
    end it with a `ROLLBACK` to revert all values to their pre-transaction state.
    This helps keep transactions **consistent**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Race Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transactions can help guard against race conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A race condition occurs when multiple entities simultaneously access and make
    decisions based on a shared value, potentially causing inconsistencies in the
    database. Unresolved race conditions can be exploited by hackers to manipulate
    the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the lecture, an example of a race condition is discussed wherein two users
    working together can exploit momentary inconsistencies in the database to rob
    the bank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, transactions are processed in **isolation** to avoid the inconsistencies
    in the first place. Each transaction dealing with similar data from our database
    will be processed sequentially. This helps prevent the inconsistencies that an
    adversarial attack can exploit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make transactions sequential, SQLite and other database management systems
    use **locks** on databases. A table in a database could be in a few different
    states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UNLOCKED**: this is the default state when no user is accessing the database,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SHARED**: when a transaction is reading data from the database, it obtains
    shared lock that allows other transactions to read simultaneously from the database,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXCLUSIVE**: if a transaction needs to write or update data, it obtains an
    exclusive lock on the database that does not allow other transactions to occur
    at the same time (not even a read)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do we decide when a transaction can get an exclusive lock? How do we prioritize
    different kinds of transactions?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Different algorithms could be used to make these decisions. For example, we
    could always choose the transaction that came first. If an exclusive transaction
    is needed, no other transaction can run at the same time, which is a necessary
    downside to ensure consistency of the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the granularity of locking? Do we lock a database, a table or a row
    of a table?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This depends on the DBMS. In SQLite, we can actually do this by running an
    exclusive transaction as below:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we do not complete this transaction now, and try to connect to the database
    through a different terminal to read from the table, we will get an error that
    the database is locked! This, of course, is a very coarse way of locking because
    it locks the entire database. Because SQLite is coarse in this manner, it has
    a module for prioritizing transactions and making sure an exclusive lock is obtained
    only for the shortest necessary duration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This brings us to the conclusion of Lecture 5 about Optimizing in SQL!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
