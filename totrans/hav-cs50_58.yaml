- en: Lecture 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/sql/notes/1/](https://cs50.harvard.edu/sql/notes/1/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Entity Relationship Diagrams](#entity-relationship-diagrams)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Keys](#keys)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Primary Keys](#primary-keys)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Foreign Keys](#foreign-keys)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-1)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Subqueries](#subqueries)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`IN`](#in)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-2)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JOIN`](#join)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-3)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sets](#sets)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-4)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Groups](#groups)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](#questions-5)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fin](#fin)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Databases can have multiple tables. Last class, we saw a database of books longlisted,
    or nominated, for the International Booker Prize. We will now see that database
    has many different tables inside it — for books, authors, publishers and so on.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, open up the database using SQLite in the terminal of your [Codespace](https://cs50.dev/).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the following SQLite command to see all the tables in our database:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command returns the names of the tables in `longlist.db` — 7 in all.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These tables have some relationships between them, and hence we call the database
    a **relational database**. Look at the list of tables in `longlist.db` and try
    to imagine relationships between them. Some examples are:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authors write books.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishers publish books.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Books are translated by translators.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider our first example. Here is a snapshot of the `authors` and `books`
    tables with the author name and book title columns!
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Author Name and Book Title columns from different tables"](../Images/1cc4671dfe321c360ec89b39f3258342.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Just looking at these two columns, how can we tell who wrote which book? Even
    if we assume that every book is lined up next to its author, just looking at the
    `authors` table would give us no information about the books written by that author.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some possible ways to organize books and authors are…
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**the honor system**: the first row in the `authors` table will always correspond
    to the first row in the `books` table. The problem with this system is that one
    may make a mistake (add a book but forget to add its corresponding author, or
    vice versa). Also, an author may have written more than one book or a book may
    be co-written by multiple authors.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**going back to a one-table approach**: This approach could result in redundancy
    (duplication of data) if one author writes multiple books or if a book is co-written
    by multiple authors. Below is a snapshot of the one-table approach with some redundant
    data.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["One-table approach: author with multiple books"](../Images/5c1d25299994e6ca97b5d2fa5dfbcfd3.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: After considering these ideas, it seems like having two different tables is
    the most efficient approach. Let us look at some different ways in which tables
    can be related to each other in relational databases.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider this case, where each author writes only one book and each book is
    written by one author. This is called a one-to-one relationship.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["One-to-one relationship"](../Images/38942739f06a26946bbf9c38f4667c45.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: On the other hand, if an author can write multiple books, the relationship is
    a one-to-many relationship.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["One-to-many relationship"](../Images/8c1f798a65fb766db6c9259d47ab9b8a.png)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Here, we see another situation where not only can one author write multiple
    books, but books can also be co-written by multiple authors. This is a many-to-many
    relationship.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Many-to-many relationship"](../Images/4b42eb30cd7e9c257d41fe3b804f3750.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Entity Relationship Diagrams
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just described one-to-one, one-to-many and many-to-many relationships between
    tables in a database. It is possible to visualize such relationships using an
    entity relationship (ER) diagram.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an ER diagram for the tables in `longlist.db`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each table is an entity in our database. The relationships between the tables,
    or entities, are represented by the *verbs* that mark the lines connecting entities.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each line is this diagram is in crow’s foot notation.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line with a circle looks like a 0 marked on the line. This line indicates
    that there are no relations.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line with a perpendicular line looks like a 1 marked on the line.
    An entity with this arrow has to have at least one row that relates to it in the
    other table.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line, which looks like a crow’s foot, has many branches. This line
    means that the entity is related to many rows from another table.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Lines in ER Diagrams"](../Images/001e48f4a406107479adcb3b3187eb8a.png)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'For example:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We read the notation left to right. An author writes one book (or, every author
    can have one book associated with them).
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["1-Relation Notation: an author writes one book"](../Images/f23bedec4064213ef494c004859702b5.png)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Now, not only does an author write one book but a book is also written by one
    author.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["1-Relation Notation: an author writes one book and one book is written by
    one author"](../Images/b9796610a33000a7b9ea9b784495fc36.png)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: With this addition, an author writes at least one book and a book is written
    by at least one author. To rephrase, an author could be associated with one or
    multiple books and a book can be written by one or multiple authors.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Adding multiple lines: an author writes at least one book and a book is
    written by at least one author"](../Images/6cf762d7f2830e8c88afced01c125181.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Let us revisit the ER diagram for our database.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On observing the lines connecting the Book and Translator entities, we can say
    that books don’t *need* to have a translator. They could have zero to many translators.
    However, a translator in the database translates at least one book, and possibly
    many.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we have some database, how do we know the relationships among the entities
    stored inside of it?
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The exact relationships between entities are really up to the designer of the
    database. For example, whether each author can write only one book or multiple
    books is a decision to be made while designing the database. An ER diagram can
    be thought of as a tool to communicate these decisions to someone who wants to
    understand the database and the relationships between its entities.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体之间的确切关系完全取决于数据库的设计者。例如，是否每位作者只能写一本书或多本书，这是在设计数据库时需要做出的决定。实体关系图（ER diagram）可以被视为一种工具，用于将这些决定传达给想要了解数据库及其实体之间关系的人。
- en: Once we know that a relationship exists between certain entities, how do we
    implement that in our database?
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦我们知道某些实体之间存在关系，我们如何在数据库中实现这种关系？
- en: We will shortly see how we can use **keys** in SQL to relate tables to one another.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何使用SQL中的**键**来关联表。
- en: Keys
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键
- en: Primary Keys
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主键
- en: In the case of books, every book has a unique identifier called an ISBN. In
    other words, if you search for a book by its ISBN, only one book will be found.
    In database terms, the ISBN is a primary key — an identifier that is unique for
    every item in a table.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在书籍的情况下，每本书都有一个唯一的标识符，称为ISBN。换句话说，如果你通过ISBN搜索一本书，只会找到一本书。在数据库术语中，ISBN是一个主键——它是表中每个项目的唯一标识符。
- en: '!["Table with ISBNs and book titles"](../Images/709b78a505de6de2e922ff22c8b86dea.png)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![包含ISBN和书名的表格](../Images/709b78a505de6de2e922ff22c8b86dea.png)'
- en: Inspired by this idea of an ISBN, we can imagine assigning unique IDs to our
    publishers, authors and translators! Each of these IDs would be the primary key
    of the table it belongs to.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受到ISBN这一想法的启发，我们可以想象为我们的出版社、作者和翻译分配唯一的ID！这些ID将是它们所属表的唯一主键。
- en: Foreign Keys
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外键
- en: Keys also help relate tables in SQL.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键也有助于在SQL中关联表。
- en: A foreign key is a primary key taken from a different table. By referencing
    the primary key of a different table, it helps relate the tables by forming a
    link between them.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键是从另一个表中取出的主键。通过引用另一个表的主键，它通过在它们之间形成链接来帮助关联表。
- en: '!["Relating the books and ratings tables using foreign key"](../Images/91a4de930ecc6ac95f9e54bd6011c225.png)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用外键关联书籍和评分表](../Images/91a4de930ecc6ac95f9e54bd6011c225.png)'
- en: Notice how the primary key of the `books` table is now a column in the `ratings`
    table. This helps form a one-to-many relationship between the two tables — a book
    with a title (found in the `books` table) can have multiple ratings (found in
    the `ratings` table).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`books`表的主键现在成为了`ratings`表中的一列。这有助于形成两个表之间的一对多关系——一本书（在`books`表中找到）可以有多个评分（在`ratings`表中找到）。
- en: The ISBN, as we can see, is a long identifier. If each character occupied a
    byte of memory, storing a single ISBN (including the dashes) would take 17 bytes
    of memory, which is a lot!
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们所见，ISBN是一个长的标识符。如果每个字符占用一个字节的内存，存储一个单独的ISBN（包括连字符）将需要17个字节的内存，这相当多！
- en: Thankfully, we don’t necessarily have to use the ISBN as a primary key. We can
    just construct our own using numbers like 1, 2, 3… and so on as long as each book
    has a unique number to identify it.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运的是，我们不一定非得使用ISBN作为主键。我们可以简单地使用数字1、2、3……等等来构建自己的主键，只要每本书都有一个唯一的数字来标识它。
- en: Previously, we saw how to implement the one-to-many relationship between the
    `books` and `ratings` entities. Here’s an example of a many-to-many relationship.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何实现`books`和`ratings`实体之间的一对多关系。这里有一个多对多关系的例子。
- en: '!["Relating the authors and books tables using a foreign key and another table"](../Images/8ca6cfda5f4b3f3a9cc43ac37ad31efc.png)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用外键和另一个表关联作者和书籍表](../Images/8ca6cfda5f4b3f3a9cc43ac37ad31efc.png)'
- en: There is now a table called `authored` that maps the primary key of `books`
    (`book_id`) to the primary key of `authors` (`author_id`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个名为`authored`的表，它将`books`表的主键（`book_id`）映射到`authors`表的主键（`author_id`）。
- en: Questions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Can the IDs of the author and the book be the same? For example, if `author_id`
    is 1 and `book_id` is also 1 in the `authored` table, will there be a mix-up?
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作者和书的ID可以相同吗？例如，如果`author_id`是1，而`authored`表中的`book_id`也是1，会发生混淆吗？
- en: Tables like `authored` are called “joint” or “junction” tables. In such tables,
    we usually know which primary key is referenced by which column. In this case,
    since we know that the first column contains the primary key of `authors` only
    and the second column similarly contains the primary key of `books` only, it would
    be okay even if the values matched!
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a lot of joint tables like this, wouldn’t that take up too much space?
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, there is a trade-off here. Tables like these occupy more space but they
    also enable us to have many-to-many relationships without redundancies, like we
    saw earlier.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On changing the ID of a book or author, does the ID get updated in the other
    tables as well?
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An updated ID still needs to be unique. Given that, IDs are often abstracted
    away and we rarely change them.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subqueries
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subquery is a query inside another query. These are also called nested queries.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider this example for a one-to-many relationship. In the `books` table,
    we have an ID to indicate the publisher, which is a foreign key taken from the
    `publishers` table. To find out the books published by Fitzcarraldo Editions,
    we would need two queries — one to find out the `publisher_id` of Fitzcarraldo
    Editions from the `publishers` table and the second, to use this `publisher_id`
    to find all the books published by Fitzcarraldo Editions. These two queries can
    be combined into one using the idea of a subquery.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The subquery is in parentheses. The query that is furthest inside parantheses
    will be run first, followed by outer queries.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The inner query is indented. This is done as per style conventions for subqueries,
    to increase readability.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To find all the ratings for the book In Memory of Memory
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To select just the average rating for this book
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next example is for many-to-many relationships. To find the author(s) who
    wrote the book Flights, three tables would need to be queried: `books`, `authors`
    and `authored`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first query that is run is the most deeply nested one — finding the ID of
    the book Flights. Then, the ID of the author(s) who wrote Flights is found. Last,
    this is used to retrieve the author name(s).
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`IN`'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This keyword is used to check whether the desired value is *in* a given list
    or set of values.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between authors and books is many-to-many. This means that
    it is possible a given author has written more than one book. To find the names
    of all books in the database written by Fernanda Melchor, we would use the `IN`
    keyword as follows.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the innermost query uses `=` and not the `IN` operator. This is because
    we expect to find just one author named Fernanda Melchor.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Questions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if the value of an inner query is not found?
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case, the inner query would return nothing, prompting the outer query
    to also return nothing. The outer query is thus dependent on the results of the
    inner query.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it necessary to use four spaces to indent a subquery?
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No. The number of spaces used to indent a subquery can vary, as can the length
    of each line in the query. But the central idea behind breaking up queries and
    indenting subqueries is to make them readable.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we implement a many-to-one relationship between tables?
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the situation wherein a book is co-written by multiple authors. We
    would have an `authored` table with multiple entries for the same book ID. Each
    of these entries would have a different author ID. It is worth noting that foreign
    key values can be repeated within a table, but primary key values are always unique.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JOIN`'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This keyword allows us to combine two or more tables together.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how `JOIN` works, consider a database of sea lions and their migration
    patterns. Here is a snapshot of the database.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Sea Lions database with tables: sea lions, migrations"](../Images/871d96677770fc511517b0f7c0c5d5a5.png)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To find out how far the sea lion Spot travelled, or answer similar questions
    about each sea lion, we could use nested queries. Alternately, we could join the
    tables `sea lions` and `migrations` together such that each sea lion also has
    its corresponding information as an extension of the same row.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can join the tables on the sea lion ID (the common factor between the two
    tables) to ensure that the correct rows are lined up against each other.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before testing this out, make sure to exit `longlist.db` using the `.quit` SQLite
    command. Then, open up `sea_lions.db`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To join the tables
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ON` keyword is used to specify which values match between the tables being
    joined. It is not possible to join tables without matching values.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are any IDs in one table not present in the other, this row will not
    be present in the joined table. This kind of join is called an `INNER JOIN`.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other ways of joining tables that allow us to retain certain unmatched
    IDs are `LEFT JOIN`, `RIGHT JOIN` and `FULL JOIN`. Each of these is a kind of
    `OUTER JOIN`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LEFT JOIN` prioritizes the data in the left (or first) table.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This query would retain all sea lion data from the `sea_lions` table — the left
    one. Some rows in the joined table could be partially blank. This would happen
    if the right table didn’t have data for a particular ID.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, a `RIGHT JOIN` retains all the rows from the right (or second) table.
    A `FULL JOIN` allows us to see the entirety of all tables.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can observe, an `OUTER JOIN` could lead to empty or `NULL` values in the
    joined table.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both tables in the sea lions database have the column `id`. Since the value
    on which we are joining the tables has the same column name in both tables, we
    can actually omit the `ON` section of the query while joining.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the result does not have a duplicate `id` column in this case. Also,
    this join works similarly to an `INNER JOIN`.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Questions
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the sea lions database, how are the IDs created? Do they come from the `sea_lions`
    table or the `migrations` table?
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The ID of each sea lion likely came from researchers tracking the migration
    patterns of these sea lions. That is to say, the IDs were not generated in either
    of the tables, but were assigned at the source of the data itself.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are trying to join three tables, how can we know which the left or right
    tables are?
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For each `JOIN` statement, the first table before the keyword is the left one.
    The one that is involved in the `JOIN` keyword is the right table.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we join tables, does the resulting joined table get saved? Can we reference
    it later without joining again?
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the way that we are using `JOIN`, the result is a temporary table or a result
    set. It can be used for the duration of the query.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s many different kinds of `JOIN`. Is there a default one we should use?
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The simplest kind — just `JOIN` — is actually an `INNER JOIN` and that’s the
    default for SQL.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into sets, we will need to exit the database of sea lions and
    switch to `longlist.db`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On running a query, the results we see are called a result set. This is a kind
    of set in SQL.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take another example. In our database of books, we have authors and translators.
    A person could be either an author or a translator. If the two sets have an intersection,
    it is also a possible that a person could be both an author and a translator of
    books. We can use the `INTERSECT` operator to find this set.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Intersection Set of Authors and Translators"](../Images/185f6a12c8577b77276b7f862db6f7ea.png)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If a person is either an author or a translator, or both, they belong to the
    union of the two sets. In other words, this set is formed by combining the author
    and translator sets.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Union Set of Authors and Translators"](../Images/ef4d181575995715654ee7725381dd1e.png)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that every author and every translator is included in this result set,
    but only once!
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A minor adjustment to the previous query gives us the profession of the person
    in the result set, based on whether they are an author or a translator.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Everyone who is an author and *only* an author is included in the following
    set. The `EXCEPT` keyword can be used to find such a set. In other words, the
    set of translators is subtracted from the set of authors to form this one.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["EXCEPT set including people who are only authors"](../Images/e7968694b86d0d8aa69073fa11996dc0.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can verify that no author-translator from the intersection set appears in
    this result set.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, it is possible to find a set of people who are only translators using
    `EXCEPT`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we find this set of people who are either authors or translators but
    not both?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!["Set — people who are either authors or translators but not both"](../Images/01c633b1019b5ccabc983b673cf3df2a.png)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: These operators could be useful to answer many different questions. For example,
    we can find the books that Sophie Hughes and Margaret Jull Costa have translated
    together.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each of the nested queries here finds the IDs of the books for one translator.
    The `INTERSECT` keyword is used to intersect the resulting sets and give us the
    books they have collaborated on.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里嵌套的每个查询都找到了一个翻译者的书籍ID。使用 `INTERSECT` 关键字来交集结果集，并给出他们合作过的书籍。
- en: Questions
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Could we use `INTERSECT`, `UNION` etc. to perform operations on 3-4 sets?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以使用 `INTERSECT`、`UNION` 等操作对3-4个集合进行操作吗？
- en: Yes, absolutely. To intersect 3 sets, we would have to use the `INTERSECT` operator
    twice. An important note — we have to make sure to have the same number and same
    types of columns in the sets to be combined using `INTERSECT`, `UNION` etc.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，绝对可以。要交集3个集合，我们必须使用 `INTERSECT` 操作符两次。一个重要的注意事项——我们必须确保要组合的集合中有相同数量和类型的列。
- en: Groups
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组
- en: Consider the `ratings` table. For each book, we want to find the average rating
    of the book. To do this, we would first need to group ratings together by book
    and then average the ratings out for each book (each group).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到 `ratings` 表。对于每本书，我们想要找到这本书的平均评分。为此，我们首先需要按书籍将评分分组，然后对每个书籍（每个组）的评分进行平均。
- en: '[PRE16]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this query, the `GROUP BY` keyword was used to create groups for each book
    and then collapse the ratings of the group into an average rating!
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个查询中，使用了 `GROUP BY` 关键字为每本书创建组，然后将组的评分合并成一个平均评分！
- en: Now, we only want to see the books that are well-rated, with an average rating
    of over 4.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们只想看到那些评分很高的书籍，平均评分超过4分。
- en: '[PRE17]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `HAVING` keyword is used here to specify a condition for the groups,
    instead of `WHERE` (which can only be used to specify conditions for individual
    rows).
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这里使用 `HAVING` 关键字来指定组条件，而不是 `WHERE`（只能用于指定单个行的条件）。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Is it possible to see the number of ratings given to each book?
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是否可以看到每本书的评分数量？
- en: Yes, this would require a slight modification with the use of the `COUNT` keyword.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，这需要使用 `COUNT` 关键字进行轻微的修改。
- en: '[PRE18]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Is it also possible to sort the data obtained here?
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是否也可以对这里获得的数据进行排序？
- en: Yes, it is. Say we wanted to find the average ratings per well-rated book, ordered
    in descending order.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，可以。比如说，我们想要找到每个评分很高的书籍的平均评分，并按降序排列。
- en: '[PRE19]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Fin
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束
- en: This brings us to the conclusion of Lecture 1 about relating!
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这把我们带到了关于关联的讲座1的结论。
