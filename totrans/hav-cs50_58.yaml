- en: Lecture 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座1
- en: 原文：[https://cs50.harvard.edu/sql/notes/1/](https://cs50.harvard.edu/sql/notes/1/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/sql/notes/1/](https://cs50.harvard.edu/sql/notes/1/)
- en: '[Introduction](#introduction)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[Entity Relationship Diagrams](#entity-relationship-diagrams)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实体关系图](#entity-relationship-diagrams)'
- en: '[Questions](#questions)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions)'
- en: '[Keys](#keys)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[键](#keys)'
- en: '[Primary Keys](#primary-keys)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[主键](#primary-keys)'
- en: '[Foreign Keys](#foreign-keys)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[外键](#foreign-keys)'
- en: '[Questions](#questions-1)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-1)'
- en: '[Subqueries](#subqueries)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[子查询](#subqueries)'
- en: '[`IN`](#in)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[IN](#in)'
- en: '[Questions](#questions-2)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-2)'
- en: '[`JOIN`](#join)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JOIN](#join)'
- en: '[Questions](#questions-3)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-3)'
- en: '[Sets](#sets)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[集合](#sets)'
- en: '[Questions](#questions-4)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-4)'
- en: '[Groups](#groups)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[组](#groups)'
- en: '[Questions](#questions-5)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](#questions-5)'
- en: '[Fin](#fin)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结束](#fin)'
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Databases can have multiple tables. Last class, we saw a database of books longlisted,
    or nominated, for the International Booker Prize. We will now see that database
    has many different tables inside it — for books, authors, publishers and so on.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库可以有多个表。在上一节课中，我们看到了一个列出国际布克奖提名书籍的数据库。现在我们将看到这个数据库内部有许多不同的表——包括书籍、作者、出版社等。
- en: First, open up the database using SQLite in the terminal of your [Codespace](https://cs50.dev/).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在您的[Codespace](https://cs50.dev/)终端中使用SQLite打开数据库。
- en: 'We can use the following SQLite command to see all the tables in our database:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用以下SQLite命令查看我们数据库中的所有表：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command returns the names of the tables in `longlist.db` — 7 in all.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令返回`longlist.db`中的表名——总共7个。
- en: 'These tables have some relationships between them, and hence we call the database
    a **relational database**. Look at the list of tables in `longlist.db` and try
    to imagine relationships between them. Some examples are:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些表之间有一些关系，因此我们称数据库为**关系数据库**。查看`longlist.db`中的表列表，并尝试想象它们之间的关系。以下是一些例子：
- en: Authors write books.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者写书。
- en: Publishers publish books.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出版社出版书籍。
- en: Books are translated by translators.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍由翻译者翻译。
- en: Consider our first example. Here is a snapshot of the `authors` and `books`
    tables with the author name and book title columns!
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑我们的第一个例子。以下是`authors`和`books`表的快照，包括作者姓名和书名列！
- en: '!["Author Name and Book Title columns from different tables"](../Images/1cc4671dfe321c360ec89b39f3258342.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![来自不同表的“作者姓名和书名列”](../Images/1cc4671dfe321c360ec89b39f3258342.png)'
- en: Just looking at these two columns, how can we tell who wrote which book? Even
    if we assume that every book is lined up next to its author, just looking at the
    `authors` table would give us no information about the books written by that author.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅从这两列来看，我们如何判断谁写了哪本书？即使我们假设每本书都紧挨着其作者，仅查看`authors`表也不会提供关于该作者所写书籍的信息。
- en: Some possible ways to organize books and authors are…
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织书籍和作者的一些可能方式是...
- en: '**the honor system**: the first row in the `authors` table will always correspond
    to the first row in the `books` table. The problem with this system is that one
    may make a mistake (add a book but forget to add its corresponding author, or
    vice versa). Also, an author may have written more than one book or a book may
    be co-written by multiple authors.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**荣誉制度**：`authors`表中的第一行将始终对应于`books`表中的第一行。这个系统的问题是一个人可能会犯错误（添加了一本书但忘记了添加相应的作者，或者反之）。此外，一个作者可能写过多本书，或者一本书可能由多个作者合著。'
- en: '**going back to a one-table approach**: This approach could result in redundancy
    (duplication of data) if one author writes multiple books or if a book is co-written
    by multiple authors. Below is a snapshot of the one-table approach with some redundant
    data.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回到单表方法**：如果一位作者写多本书或者一本书由多个作者合著，这种方法可能会导致冗余（数据重复）。以下是一个包含一些冗余数据的单表方法的快照。'
- en: '!["One-table approach: author with multiple books"](../Images/5c1d25299994e6ca97b5d2fa5dfbcfd3.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![单表方法：有多个书的作者](../Images/5c1d25299994e6ca97b5d2fa5dfbcfd3.png)'
- en: After considering these ideas, it seems like having two different tables is
    the most efficient approach. Let us look at some different ways in which tables
    can be related to each other in relational databases.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑了这些想法后，似乎有两个不同的表是最有效的方法。让我们看看关系数据库中表之间可以以哪些不同的方式相互关联。
- en: Consider this case, where each author writes only one book and each book is
    written by one author. This is called a one-to-one relationship.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑这种情况，每位作者只写一本书，每本书也只由一位作者撰写。这被称为一对一关系。
- en: '!["One-to-one relationship"](../Images/38942739f06a26946bbf9c38f4667c45.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一对一关系](../Images/38942739f06a26946bbf9c38f4667c45.png)'
- en: On the other hand, if an author can write multiple books, the relationship is
    a one-to-many relationship.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果一位作者可以写多本书，那么关系是一对多关系。
- en: '!["One-to-many relationship"](../Images/8c1f798a65fb766db6c9259d47ab9b8a.png)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一对多关系](../Images/8c1f798a65fb766db6c9259d47ab9b8a.png)'
- en: Here, we see another situation where not only can one author write multiple
    books, but books can also be co-written by multiple authors. This is a many-to-many
    relationship.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，我们看到另一种情况，不仅一位作者可以写多本书，而且多本书也可以由多位作者合著。这是一个多对多关系。
- en: '!["Many-to-many relationship"](../Images/4b42eb30cd7e9c257d41fe3b804f3750.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![多对多关系](../Images/4b42eb30cd7e9c257d41fe3b804f3750.png)'
- en: Entity Relationship Diagrams
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体关系图
- en: We just described one-to-one, one-to-many and many-to-many relationships between
    tables in a database. It is possible to visualize such relationships using an
    entity relationship (ER) diagram.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚刚描述了数据库表中一对一、一对多和多对多关系。可以使用实体关系（ER）图来可视化这些关系。
- en: Here is an ER diagram for the tables in `longlist.db`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是`longlist.db`中表的ER图。
- en: '[PRE1]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each table is an entity in our database. The relationships between the tables,
    or entities, are represented by the *verbs* that mark the lines connecting entities.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表都是我们数据库中的一个实体。表与表之间，或实体之间的关系，由标记实体之间线条的动词表示。
- en: Each line is this diagram is in crow’s foot notation.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的每条线都使用鸟爪符号表示。
- en: The first line with a circle looks like a 0 marked on the line. This line indicates
    that there are no relations.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行带有圆圈的线条看起来像线上标记的0。这一行表示没有关系。
- en: The second line with a perpendicular line looks like a 1 marked on the line.
    An entity with this arrow has to have at least one row that relates to it in the
    other table.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行带有垂直线的线条看起来像线上标记的1。具有此箭头的实体必须至少有一个与另一张表中的行相关联的行。
- en: The third line, which looks like a crow’s foot, has many branches. This line
    means that the entity is related to many rows from another table.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行看起来像一只鸟爪，有很多分支。这一行表示该实体与另一张表中的多行相关。
- en: '!["Lines in ER Diagrams"](../Images/001e48f4a406107479adcb3b3187eb8a.png)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![ER图中的线条](../Images/001e48f4a406107479adcb3b3187eb8a.png)'
- en: 'For example:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：
- en: We read the notation left to right. An author writes one book (or, every author
    can have one book associated with them).
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从左到右阅读这个符号。一位作者写一本书（或者，每位作者都可以有一本书与他们相关联）。
- en: '!["1-Relation Notation: an author writes one book"](../Images/f23bedec4064213ef494c004859702b5.png)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![1-关系符号：一位作者写一本书](../Images/f23bedec4064213ef494c004859702b5.png)'
- en: Now, not only does an author write one book but a book is also written by one
    author.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，不仅一位作者可以写一本书，一本书也可以由一位作者编写。
- en: '!["1-Relation Notation: an author writes one book and one book is written by
    one author"](../Images/b9796610a33000a7b9ea9b784495fc36.png)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![1-关系符号：一位作者写一本书，一本书由一位作者编写](../Images/b9796610a33000a7b9ea9b784495fc36.png)'
- en: With this addition, an author writes at least one book and a book is written
    by at least one author. To rephrase, an author could be associated with one or
    multiple books and a book can be written by one or multiple authors.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这个添加，一位作者至少写一本书，一本书至少由一位作者编写。换句话说，一位作者可以与一本或多本书相关联，一本书可以由一位或多位作者编写。
- en: '!["Adding multiple lines: an author writes at least one book and a book is
    written by at least one author"](../Images/6cf762d7f2830e8c88afced01c125181.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加多条线：一位作者至少写一本书，一本书至少由一位作者编写](../Images/6cf762d7f2830e8c88afced01c125181.png)'
- en: Let us revisit the ER diagram for our database.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们重新审视我们数据库的ER图。
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On observing the lines connecting the Book and Translator entities, we can say
    that books don’t *need* to have a translator. They could have zero to many translators.
    However, a translator in the database translates at least one book, and possibly
    many.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察连接书籍和翻译者实体的线条，我们可以说书籍不需要有翻译者。它们可以有零到多个翻译者。然而，数据库中的翻译者至少翻译一本书，可能还翻译多本书。
- en: Questions
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: If we have some database, how do we know the relationships among the entities
    stored inside of it?
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们有一个数据库，我们如何知道存储在其中的实体之间的关系？
- en: The exact relationships between entities are really up to the designer of the
    database. For example, whether each author can write only one book or multiple
    books is a decision to be made while designing the database. An ER diagram can
    be thought of as a tool to communicate these decisions to someone who wants to
    understand the database and the relationships between its entities.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体之间的确切关系完全取决于数据库的设计者。例如，是否每位作者只能写一本书或多本书，这是在设计数据库时需要做出的决定。实体关系图（ER diagram）可以被视为一种工具，用于将这些决定传达给想要了解数据库及其实体之间关系的人。
- en: Once we know that a relationship exists between certain entities, how do we
    implement that in our database?
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦我们知道某些实体之间存在关系，我们如何在数据库中实现这种关系？
- en: We will shortly see how we can use **keys** in SQL to relate tables to one another.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何使用SQL中的**键**来关联表。
- en: Keys
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键
- en: Primary Keys
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主键
- en: In the case of books, every book has a unique identifier called an ISBN. In
    other words, if you search for a book by its ISBN, only one book will be found.
    In database terms, the ISBN is a primary key — an identifier that is unique for
    every item in a table.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在书籍的情况下，每本书都有一个唯一的标识符，称为ISBN。换句话说，如果你通过ISBN搜索一本书，只会找到一本书。在数据库术语中，ISBN是一个主键——它是表中每个项目的唯一标识符。
- en: '!["Table with ISBNs and book titles"](../Images/709b78a505de6de2e922ff22c8b86dea.png)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![包含ISBN和书名的表格](../Images/709b78a505de6de2e922ff22c8b86dea.png)'
- en: Inspired by this idea of an ISBN, we can imagine assigning unique IDs to our
    publishers, authors and translators! Each of these IDs would be the primary key
    of the table it belongs to.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受到ISBN这一想法的启发，我们可以想象为我们的出版社、作者和翻译分配唯一的ID！这些ID将是它们所属表的唯一主键。
- en: Foreign Keys
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外键
- en: Keys also help relate tables in SQL.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键也有助于在SQL中关联表。
- en: A foreign key is a primary key taken from a different table. By referencing
    the primary key of a different table, it helps relate the tables by forming a
    link between them.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键是从另一个表中取出的主键。通过引用另一个表的主键，它通过在它们之间形成链接来帮助关联表。
- en: '!["Relating the books and ratings tables using foreign key"](../Images/91a4de930ecc6ac95f9e54bd6011c225.png)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用外键关联书籍和评分表](../Images/91a4de930ecc6ac95f9e54bd6011c225.png)'
- en: Notice how the primary key of the `books` table is now a column in the `ratings`
    table. This helps form a one-to-many relationship between the two tables — a book
    with a title (found in the `books` table) can have multiple ratings (found in
    the `ratings` table).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`books`表的主键现在成为了`ratings`表中的一列。这有助于形成两个表之间的一对多关系——一本书（在`books`表中找到）可以有多个评分（在`ratings`表中找到）。
- en: The ISBN, as we can see, is a long identifier. If each character occupied a
    byte of memory, storing a single ISBN (including the dashes) would take 17 bytes
    of memory, which is a lot!
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们所见，ISBN是一个长的标识符。如果每个字符占用一个字节的内存，存储一个单独的ISBN（包括连字符）将需要17个字节的内存，这相当多！
- en: Thankfully, we don’t necessarily have to use the ISBN as a primary key. We can
    just construct our own using numbers like 1, 2, 3… and so on as long as each book
    has a unique number to identify it.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运的是，我们不一定非得使用ISBN作为主键。我们可以简单地使用数字1、2、3……等等来构建自己的主键，只要每本书都有一个唯一的数字来标识它。
- en: Previously, we saw how to implement the one-to-many relationship between the
    `books` and `ratings` entities. Here’s an example of a many-to-many relationship.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何实现`books`和`ratings`实体之间的一对多关系。这里有一个多对多关系的例子。
- en: '!["Relating the authors and books tables using a foreign key and another table"](../Images/8ca6cfda5f4b3f3a9cc43ac37ad31efc.png)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用外键和另一个表关联作者和书籍表](../Images/8ca6cfda5f4b3f3a9cc43ac37ad31efc.png)'
- en: There is now a table called `authored` that maps the primary key of `books`
    (`book_id`) to the primary key of `authors` (`author_id`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个名为`authored`的表，它将`books`表的主键（`book_id`）映射到`authors`表的主键（`author_id`）。
- en: Questions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Can the IDs of the author and the book be the same? For example, if `author_id`
    is 1 and `book_id` is also 1 in the `authored` table, will there be a mix-up?
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作者和书的ID可以相同吗？例如，如果`author_id`是1，而`authored`表中的`book_id`也是1，会发生混淆吗？
- en: Tables like `authored` are called “joint” or “junction” tables. In such tables,
    we usually know which primary key is referenced by which column. In this case,
    since we know that the first column contains the primary key of `authors` only
    and the second column similarly contains the primary key of `books` only, it would
    be okay even if the values matched!
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`authored`这样的表被称为“联合”或“连接”表。在这样的表中，我们通常知道哪个主键被哪个列引用。在这种情况下，由于我们知道第一列只包含`authors`的主键，第二列也只包含`books`的主键，所以即使值匹配也是可以的！
- en: If we have a lot of joint tables like this, wouldn’t that take up too much space?
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们有很多这样的联合表，那不会占用太多空间吗？
- en: Yes, there is a trade-off here. Tables like these occupy more space but they
    also enable us to have many-to-many relationships without redundancies, like we
    saw earlier.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，这里有一个权衡。像这样的表占用更多空间，但它们也使我们能够拥有许多多对多关系，没有冗余，就像我们之前看到的。
- en: On changing the ID of a book or author, does the ID get updated in the other
    tables as well?
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在更改书籍或作者的ID时，ID是否也会在其他表中更新？
- en: An updated ID still needs to be unique. Given that, IDs are often abstracted
    away and we rarely change them.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新后的ID仍然需要是唯一的。鉴于这一点，ID通常被抽象化，我们很少更改它们。
- en: Subqueries
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子查询
- en: A subquery is a query inside another query. These are also called nested queries.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子查询是另一个查询中的查询。这些也被称为嵌套查询。
- en: Consider this example for a one-to-many relationship. In the `books` table,
    we have an ID to indicate the publisher, which is a foreign key taken from the
    `publishers` table. To find out the books published by Fitzcarraldo Editions,
    we would need two queries — one to find out the `publisher_id` of Fitzcarraldo
    Editions from the `publishers` table and the second, to use this `publisher_id`
    to find all the books published by Fitzcarraldo Editions. These two queries can
    be combined into one using the idea of a subquery.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑这个用于一对多关系的示例。在`books`表中，我们有一个ID来表示出版社，这是从`publishers`表中取的外键。要找出Fitzcarraldo
    Editions出版的书籍，我们需要两个查询——一个是从`publishers`表中找出Fitzcarraldo Editions的`publisher_id`，第二个是使用这个`publisher_id`来找出Fitzcarraldo
    Editions出版的所有书籍。这两个查询可以通过子查询的概念合并成一个。
- en: '[PRE3]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：
- en: The subquery is in parentheses. The query that is furthest inside parantheses
    will be run first, followed by outer queries.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子查询在括号中。括号中最里面的查询将首先运行，然后是外部查询。
- en: The inner query is indented. This is done as per style conventions for subqueries,
    to increase readability.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部查询被缩进。这是按照子查询的风格约定进行的，以提高可读性。
- en: To find all the ratings for the book In Memory of Memory
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出《记忆的纪念》的所有评分
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To select just the average rating for this book
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要选择这本书的平均评分
- en: '[PRE5]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next example is for many-to-many relationships. To find the author(s) who
    wrote the book Flights, three tables would need to be queried: `books`, `authors`
    and `authored`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例是用于多对多关系。要找出写了《航班》的作者（们），需要查询三个表：`books`、`authors`和`authored`。
- en: '[PRE6]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first query that is run is the most deeply nested one — finding the ID of
    the book Flights. Then, the ID of the author(s) who wrote Flights is found. Last,
    this is used to retrieve the author name(s).
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先运行的查询是最深层的查询——找到《航班》的ID。然后，找到写了《航班》的作者（们）的ID。最后，使用这个ID检索作者名称。
- en: '`IN`'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IN`'
- en: This keyword is used to check whether the desired value is *in* a given list
    or set of values.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个关键字用于检查所需值是否在给定的列表或值集中。
- en: The relationship between authors and books is many-to-many. This means that
    it is possible a given author has written more than one book. To find the names
    of all books in the database written by Fernanda Melchor, we would use the `IN`
    keyword as follows.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者和书籍之间的关系是多对多的。这意味着一个特定的作者可能写过多本书。要找出数据库中Fernanda Melchor所写的所有书籍的名称，我们可以使用以下`IN`关键字。
- en: '[PRE7]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the innermost query uses `=` and not the `IN` operator. This is because
    we expect to find just one author named Fernanda Melchor.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，最内层的查询使用`=`而不是`IN`运算符。这是因为我们期望找到名为Fernanda Melchor的唯一作者。
- en: Questions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: What if the value of an inner query is not found?
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果内部查询的值未找到怎么办？
- en: In this case, the inner query would return nothing, prompting the outer query
    to also return nothing. The outer query is thus dependent on the results of the
    inner query.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，内部查询将返回空结果，这会促使外部查询也返回空结果。因此，外部查询依赖于内部查询的结果。
- en: Is it necessary to use four spaces to indent a subquery?
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要使用四个空格来缩进子查询吗？
- en: No. The number of spaces used to indent a subquery can vary, as can the length
    of each line in the query. But the central idea behind breaking up queries and
    indenting subqueries is to make them readable.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不。用于缩进子查询的空格数量可以变化，查询中每行的长度也可以变化。但将查询拆分并缩进子查询的核心思想是使它们易于阅读。
- en: How can we implement a many-to-one relationship between tables?
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们如何实现表之间的多对一关系？
- en: Consider the situation wherein a book is co-written by multiple authors. We
    would have an `authored` table with multiple entries for the same book ID. Each
    of these entries would have a different author ID. It is worth noting that foreign
    key values can be repeated within a table, but primary key values are always unique.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑这种情况，一本书由多个作者共同撰写。我们会有一个 `authored` 表，对于相同的书 ID 有多个条目。这些条目中的每一个都会有不同的作者 ID。值得注意的是，外键值可以在表中重复，但主键值总是唯一的。
- en: '`JOIN`'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`JOIN`'
- en: This keyword allows us to combine two or more tables together.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此关键字允许我们将两个或多个表组合在一起。
- en: To understand how `JOIN` works, consider a database of sea lions and their migration
    patterns. Here is a snapshot of the database.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解 `JOIN` 的工作原理，请考虑海狮及其迁徙模式的数据库。以下是数据库的快照。
- en: '!["Sea Lions database with tables: sea lions, migrations"](../Images/871d96677770fc511517b0f7c0c5d5a5.png)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![海狮数据库中的表：海狮、迁徙](../Images/871d96677770fc511517b0f7c0c5d5a5.png)'
- en: To find out how far the sea lion Spot travelled, or answer similar questions
    about each sea lion, we could use nested queries. Alternately, we could join the
    tables `sea lions` and `migrations` together such that each sea lion also has
    its corresponding information as an extension of the same row.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出海狮 Spot 走了多远，或者回答有关每只海狮的类似问题，我们可以使用嵌套查询。或者，我们可以将 `sea lions` 和 `migrations`
    表连接起来，使得每只海狮也有其对应的信息，作为同一行的扩展。
- en: We can join the tables on the sea lion ID (the common factor between the two
    tables) to ensure that the correct rows are lined up against each other.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在海狮 ID（两张表之间的共同因素）上连接表，以确保正确的行相互对齐。
- en: Before testing this out, make sure to exit `longlist.db` using the `.quit` SQLite
    command. Then, open up `sea_lions.db`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试之前，请确保使用 `.quit` SQLite 命令退出 `longlist.db`。然后，打开 `sea_lions.db`。
- en: To join the tables
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要连接表
- en: '[PRE8]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：
- en: The `ON` keyword is used to specify which values match between the tables being
    joined. It is not possible to join tables without matching values.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON` 关键字用于指定在连接的表中哪些值匹配。如果没有匹配的值，则无法连接表。'
- en: If there are any IDs in one table not present in the other, this row will not
    be present in the joined table. This kind of join is called an `INNER JOIN`.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个表中有任何 ID 在另一个表中不存在，则该行将不会出现在连接表中。这种连接称为 `INNER JOIN`。
- en: Some other ways of joining tables that allow us to retain certain unmatched
    IDs are `LEFT JOIN`, `RIGHT JOIN` and `FULL JOIN`. Each of these is a kind of
    `OUTER JOIN`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他允许我们保留某些不匹配 ID 的连接表的方法是 `LEFT JOIN`、`RIGHT JOIN` 和 `FULL JOIN`。这些都是 `OUTER
    JOIN` 的一种。
- en: A `LEFT JOIN` prioritizes the data in the left (or first) table.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEFT JOIN` 优先考虑左表（或第一张表）中的数据。'
- en: '[PRE9]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This query would retain all sea lion data from the `sea_lions` table — the left
    one. Some rows in the joined table could be partially blank. This would happen
    if the right table didn’t have data for a particular ID.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此查询将保留 `sea_lions` 表中的所有海狮数据——左表。连接表中的某些行可能部分为空。如果右表没有特定 ID 的数据，就会发生这种情况。
- en: Similarly, a `RIGHT JOIN` retains all the rows from the right (or second) table.
    A `FULL JOIN` allows us to see the entirety of all tables.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，`RIGHT JOIN` 保留右表（或第二张表）的所有行。`FULL JOIN` 允许我们看到所有表的全部内容。
- en: As we can observe, an `OUTER JOIN` could lead to empty or `NULL` values in the
    joined table.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们所见，`OUTER JOIN` 可能会导致连接表中出现空或 `NULL` 值。
- en: Both tables in the sea lions database have the column `id`. Since the value
    on which we are joining the tables has the same column name in both tables, we
    can actually omit the `ON` section of the query while joining.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 海狮数据库中的两张表都有 `id` 列。由于我们连接表时使用的值在两张表中都有相同的列名，因此实际上在连接时我们可以省略查询的 `ON` 部分。
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the result does not have a duplicate `id` column in this case. Also,
    this join works similarly to an `INNER JOIN`.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这种情况下结果中没有重复的 `id` 列。此外，这种连接与 `INNER JOIN` 的工作方式类似。
- en: Questions
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: In the sea lions database, how are the IDs created? Do they come from the `sea_lions`
    table or the `migrations` table?
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在海狮数据库中，ID 是如何创建的？它们来自 `sea_lions` 表还是 `migrations` 表？
- en: The ID of each sea lion likely came from researchers tracking the migration
    patterns of these sea lions. That is to say, the IDs were not generated in either
    of the tables, but were assigned at the source of the data itself.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每只海狮的ID很可能是研究人员追踪这些海狮迁徙模式时分配的。也就是说，ID不是在任一表中生成的，而是在数据本身的源头分配的。
- en: If we are trying to join three tables, how can we know which the left or right
    tables are?
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们试图连接三个表，我们如何知道哪一个是左表或右表？
- en: For each `JOIN` statement, the first table before the keyword is the left one.
    The one that is involved in the `JOIN` keyword is the right table.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个`JOIN`语句，关键字之前的第一张表是左表。与`JOIN`关键字相关的是右表。
- en: When we join tables, does the resulting joined table get saved? Can we reference
    it later without joining again?
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们连接表时，结果连接表会被保存吗？我们可以在不再次连接的情况下稍后引用它吗？
- en: In the way that we are using `JOIN`, the result is a temporary table or a result
    set. It can be used for the duration of the query.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们使用`JOIN`的方式中，结果是临时表或结果集。它可以在查询期间使用。
- en: There’s many different kinds of `JOIN`. Is there a default one we should use?
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有许多不同的`JOIN`类型。我们应该使用默认的哪一个？
- en: The simplest kind — just `JOIN` — is actually an `INNER JOIN` and that’s the
    default for SQL.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的一种——就是`JOIN`——实际上是一个`INNER JOIN`，这也是SQL的默认设置。
- en: Sets
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Before diving into sets, we will need to exit the database of sea lions and
    switch to `longlist.db`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在深入研究集合之前，我们需要退出海狮数据库，切换到`longlist.db`。
- en: On running a query, the results we see are called a result set. This is a kind
    of set in SQL.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行查询时，我们看到的查询结果被称为结果集。这是一种SQL中的集合。
- en: Let’s take another example. In our database of books, we have authors and translators.
    A person could be either an author or a translator. If the two sets have an intersection,
    it is also a possible that a person could be both an author and a translator of
    books. We can use the `INTERSECT` operator to find this set.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。在我们的书籍数据库中，我们有作者和翻译者。一个人可以是作者或翻译者。如果这两个集合有交集，那么一个人也可能是书籍的作者和翻译者。我们可以使用`INTERSECT`运算符来找到这个集合。
- en: '!["Intersection Set of Authors and Translators"](../Images/185f6a12c8577b77276b7f862db6f7ea.png)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![作者和翻译者的交集集合](../Images/185f6a12c8577b77276b7f862db6f7ea.png)'
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If a person is either an author or a translator, or both, they belong to the
    union of the two sets. In other words, this set is formed by combining the author
    and translator sets.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个人是作者或翻译者，或者两者都是，那么他们属于两个集合的并集。换句话说，这个集合是通过合并作者和翻译者集合形成的。
- en: '!["Union Set of Authors and Translators"](../Images/ef4d181575995715654ee7725381dd1e.png)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![作者和翻译者的并集集合](../Images/ef4d181575995715654ee7725381dd1e.png)'
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that every author and every translator is included in this result set,
    but only once!
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，每个作者和每个翻译者都包含在这个结果集中，但只出现一次！
- en: A minor adjustment to the previous query gives us the profession of the person
    in the result set, based on whether they are an author or a translator.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对上一个查询进行轻微调整，我们可以根据一个人是作者还是翻译者，在结果集中得到他们的职业。
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Everyone who is an author and *only* an author is included in the following
    set. The `EXCEPT` keyword can be used to find such a set. In other words, the
    set of translators is subtracted from the set of authors to form this one.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下集合包括了所有既是作者又是**仅**是作者的人。`EXCEPT`关键字可以用来找到这样的集合。换句话说，从作者集合中减去翻译者集合，形成这个集合。
- en: '!["EXCEPT set including people who are only authors"](../Images/e7968694b86d0d8aa69073fa11996dc0.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![只包括作者的`EXCEPT`集合](../Images/e7968694b86d0d8aa69073fa11996dc0.png)'
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can verify that no author-translator from the intersection set appears in
    this result set.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以验证，交集集中的任何作者-翻译者都没有出现在这个结果集中。
- en: Similarly, it is possible to find a set of people who are only translators using
    `EXCEPT`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`EXCEPT`来找到只做翻译者的集合。
- en: How can we find this set of people who are either authors or translators but
    not both?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何找到这个集合，其中的人要么是作者或翻译者，但不能两者都是？
- en: '!["Set — people who are either authors or translators but not both"](../Images/01c633b1019b5ccabc983b673cf3df2a.png)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![作者和翻译者要么是作者要么是翻译者但不是两者的集合](../Images/01c633b1019b5ccabc983b673cf3df2a.png)'
- en: These operators could be useful to answer many different questions. For example,
    we can find the books that Sophie Hughes and Margaret Jull Costa have translated
    together.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些运算符可以用来回答许多不同的问题。例如，我们可以找到Sophie Hughes和Margaret Jull Costa共同翻译的书籍。
- en: '[PRE15]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each of the nested queries here finds the IDs of the books for one translator.
    The `INTERSECT` keyword is used to intersect the resulting sets and give us the
    books they have collaborated on.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里嵌套的每个查询都找到了一个翻译者的书籍ID。使用 `INTERSECT` 关键字来交集结果集，并给出他们合作过的书籍。
- en: Questions
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Could we use `INTERSECT`, `UNION` etc. to perform operations on 3-4 sets?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以使用 `INTERSECT`、`UNION` 等操作对3-4个集合进行操作吗？
- en: Yes, absolutely. To intersect 3 sets, we would have to use the `INTERSECT` operator
    twice. An important note — we have to make sure to have the same number and same
    types of columns in the sets to be combined using `INTERSECT`, `UNION` etc.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，绝对可以。要交集3个集合，我们必须使用 `INTERSECT` 操作符两次。一个重要的注意事项——我们必须确保要组合的集合中有相同数量和类型的列。
- en: Groups
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组
- en: Consider the `ratings` table. For each book, we want to find the average rating
    of the book. To do this, we would first need to group ratings together by book
    and then average the ratings out for each book (each group).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到 `ratings` 表。对于每本书，我们想要找到这本书的平均评分。为此，我们首先需要按书籍将评分分组，然后对每个书籍（每个组）的评分进行平均。
- en: '[PRE16]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this query, the `GROUP BY` keyword was used to create groups for each book
    and then collapse the ratings of the group into an average rating!
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个查询中，使用了 `GROUP BY` 关键字为每本书创建组，然后将组的评分合并成一个平均评分！
- en: Now, we only want to see the books that are well-rated, with an average rating
    of over 4.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们只想看到那些评分很高的书籍，平均评分超过4分。
- en: '[PRE17]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `HAVING` keyword is used here to specify a condition for the groups,
    instead of `WHERE` (which can only be used to specify conditions for individual
    rows).
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这里使用 `HAVING` 关键字来指定组条件，而不是 `WHERE`（只能用于指定单个行的条件）。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Is it possible to see the number of ratings given to each book?
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是否可以看到每本书的评分数量？
- en: Yes, this would require a slight modification with the use of the `COUNT` keyword.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，这需要使用 `COUNT` 关键字进行轻微的修改。
- en: '[PRE18]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Is it also possible to sort the data obtained here?
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是否也可以对这里获得的数据进行排序？
- en: Yes, it is. Say we wanted to find the average ratings per well-rated book, ordered
    in descending order.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，可以。比如说，我们想要找到每个评分很高的书籍的平均评分，并按降序排列。
- en: '[PRE19]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Fin
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束
- en: This brings us to the conclusion of Lecture 1 about relating!
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这把我们带到了关于关联的讲座1的结论。
