- en: 9.4   Numerical Solutions to Differential Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/94diffeq](https://introcs.cs.princeton.edu/java/94diffeq)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section under major construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving differential equations is a fundamental problem in science and engineering.
    A differential equation is ... For example: y'' = -2y, y(0) = 1 has an analytic
    solution y(x) = exp(-2x). Laplace''s equation d²φ/dx² + d²φ/dy² = 0 plus some
    boundary conditions. Sometimes we can find closed-form solutions using calculus.
    However, in general we must resort to numerical approximations. ODE = differential
    equation in which all dependent variables are a function of a single independent
    variable, as in the first example. PDE = differential equation in which all dependent
    variables are a function of several independent variables, as in the second example.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Euler method.** In the 18th century Leonhard Euler invented a simple scheme
    for numerically approximating the solution to an ODE. Given a first order ODE
    of the form dy/dx = f(x, y) subject to the initial boundary condition y(x[0])
    = y[0], we estimate the function y(x) over a regular sample of values x[n] = x[0]
    + hn. The parameter h is referred to as the *step length*. If y[n] is the approximation
    to y(x) at x[n], then we can approximate the gradient at x[n] by f(x[n], y[n]).
    We estimate y[n+1] by assuming the gradient remains constant in the interval between
    x[n] and x[n+1]. This leads to the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Euler''s method](../Images/d7826809141b34d9504f45818d99dba2.png)'
  prefs: []
  type: TYPE_IMG
- en: The smaller we make h, the more accurate the approximation. But this comes at
    the expense of more computation. The associated truncation error can be formalized
    by comparing the above estimate with the Taylor series approximation
  prefs: []
  type: TYPE_NORMAL
- en: '![Euler''s method error](../Images/e2e9e211585d5ba2c47e9bb07fa54c69.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the truncation error is approximately O(h²). If the errors are cumulative
    (conservative assumption), then the total error from x[0] = 0 to x[n] = 1 is O(h).
    Called a first-order method. To keep relative error below 1E-6, we must do 1 million
    steps. Note if the step size is too big, then Euler's method becomes unstable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lorenz attractor.* The Lorenz equations are the following system of differential
    equations'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lorenz equation](../Images/931a01cda6199db87e562771dafb7df5.png)'
  prefs: []
  type: TYPE_IMG
- en: Program [Butterfly.java](Butterfly.java.html) uses Euler method's to numerically
    solve Lorenz's equation and plots the trajectory (x, z).
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Lorenz equation](../Images/628bd590877d427da0afcfea9fa6cc52.png) |    
    | ![Lorenz equation](../Images/760d14c23f93ab1001cbed919806d85c.png) |'
  prefs: []
  type: TYPE_TB
- en: Program [Lorenz.java](Lorenz.java.html) plots two trajectories of Lorenz's equation
    with slightly different initial conditions. This perturbation eventually leads
    to significantly different behavior. This is the origin of the so-called butterfly
    effect. Here's a good [demonstration](http://www.cmp.caltech.edu/~mcc/chaos_new/Lorenz.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Runge-Kutta method.** Euler''s method not used in pratice because truncation
    error per step is relatively large compared with other methods. Also Euler''s
    method becomes unstable if step size is too large. Euler''s method only uses first
    derivative information at beginning of step. Runge-Kutta method samples derivative
    at several points in interval. Tradeoff between computing the function f(x, y)
    and increased accuracy. The 4th order Runge-Kutta method is a popular sweet spot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Runga-Kutta method](../Images/aa3ff6caf1a6e4f196df54fd31e05947.png)'
  prefs: []
  type: TYPE_IMG
- en: It's a fourth order method.
  prefs: []
  type: TYPE_NORMAL
- en: '**N-body simulation.** Sir Isaac Newton formulated the principles governing
    the the motion of two particles under the influence of their mutual gravitational
    attraction in his famous *Principia* in 1687. However, Newton was unable to solve
    the problem for three or more particles. Indeed, systems of three or more particles
    can only be solved numerically. We will describe a classic numerical solution
    that is widely used to study complex physical systems in cosmology, plasma physics,
    semiconductors, fluid dynamics and astrophysics. Scientists also apply the same
    techniques to other pairwise interactions including Coulombic, Biot-Savart, and
    van der Waals.'
  prefs: []
  type: TYPE_NORMAL
- en: We first review Newton's mathematical model describing the movement of the planets.
    Newton's law of universal gravitation asserts that the strength of the gravitational
    force between two particles is given by F = Gm[1]m[2] / R², where G is the universal
    gravitational constant, m[1] and m[2] are the masses of the two particles, and
    R is the distance between them. The force is vector quantity, and the pull of
    one particle towards another acts on the line between them. Newton's second law
    of motion F = ma relates the force to the acceleration. Let m[i] denote the mass
    of particle i and let r[i] denote its position vector (as a function of time t).
    Combining Newton's two laws, we obtain a system of differential equations which
    characterize the motion of the particles
  prefs: []
  type: TYPE_NORMAL
- en: '![N-body equation](../Images/939e851791254e1de7b6ccc9baf67ae0.png)'
  prefs: []
  type: TYPE_IMG
- en: Since a particle's acceleration only depends on the positions of other particles
    and not of their velocities (as might be the case of particles in an electromagnetic
    field), we can use a specialized numerical integration method known as the *leapfrog*
    finite difference approximation scheme. This is the basis for most astrophysical
    simulations of gravitational systems. In this scheme, we discretize time, and
    increment the time variable *t* in increments of the time quantum dt. We maintain
    the position and velocity of each particle, but they are half a time step out
    of phase (which explains the name leapfrog). The steps below illustrate how to
    evolve the positions and velocities of the particles. Here
  prefs: []
  type: TYPE_NORMAL
- en: '![Leapfrog method](../Images/def48cdad58815341fee6ef3e75ce899.png)'
  prefs: []
  type: TYPE_IMG
- en: James M. Stone, Astrophysics, Princeton University "Some of the most basic facts
    we have discovered about the Universe (for example, the temperature at the center
    of the Sun) are known only through the application of computational methods."
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic partial differential equations.** An *elliptical partial differential
    equations* involves second derivatives of space, but not time. One of big challenges
    in scientific computing is fast multipole methods for solving elliptic PDEs. One
    of the simplest and most important examples is [Laplace''s equation](http://en.wikipedia.org/wiki/Laplace''s_equation):
    d²φ/dx² + d²φ/dy² = 0. It arises in many scientific applications to model electric,
    gravitational, and fluid potentials. It describes the steady state of heat transport,
    steady state water table elevation in an unconfined aquifer, We only know values
    on the boundary, so no initial conditions, and Euler method doesn''t apply. To
    solve it numerically, we can use a finite-different method on a square grid.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laplace''s equation](../Images/b1572dff0660862ebfb82f4aca32a4df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Voltage at a point is the average of its nearest neighbors. Called the *relaxation
    algorithm* or *Gauss-Seidel*. Program [Laplace.java](Laplace.java.html) numerically
    solves Lapace''s equation in the plane with a fixed potential at its four boundary
    walls: left (30), right (70), upper (100), and bottom (0). At each step, we make
    each cell be the average of its four neighbors. We always use the most up-to-date
    value (not necessarily the same as the one from the previous step). We plot all
    points using an integer scale of 0 (blue) to 100 (red). We plot points with potentials
    equal to a multiple of 10 in white to highlight the equipotential lines. Note
    that because of averaging property, maximum and minimum are achieved at boundary
    points. The picture below illustrates the potential after 0, 500, 1,000, and 10,000
    iterations. Convergence is slow.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Laplace equation](../Images/0a26809336eb3ed16cd7f60e4dae2117.png) | ![Laplace
    equation](../Images/1f02fd07ca81ae6d8977ab267c334a5f.png) | ![Laplace equation](../Images/c0e49f3157394a371d160d5d23bf3cf2.png)  |
    ![Laplace equation](../Images/ad0f2ad61db57ee01deaa89ecb5b16f7.png) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Slow convergence. The bottleneck is drawing to the screen. To speed things up,
    we perform 100 updates before redrawing to the screen using Turtle graphics. The
    method can also be sped up by choosing better estimates for the initial potentials
    (instead of choosing an aribtrary value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other techniques: solve linear system of equations. Typically involve large
    but, sparse and banded matrices. In 1D the finite difference scheme for Laplace''s
    equation yields a tridiagonal system of linear equations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tridiagonal system from Laplace''s equation](../Images/d7184cdd7f645f0aa457a5e9ffc2d1ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Easily parallelized variants: Jacobi iteration, successive over relaxation,
    red-black ordering. In 2D use multigrid methods (discretized grids on several
    scales so that information propagates faster), conjugate gradient, or FFT if periodic
    boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: Q + A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Q. Why use the leapfrog method instead of Euler's method or Runge-Kutta?
  prefs: []
  type: TYPE_NORMAL
- en: A. The leapfrog method is more stable for integrating Hamiltonian systems. It
    is *symplectic*, which means it preserves properties specific to Hamiltonian systems
    (conservation of linear and angular momentum, time-reversibility, and conservation
    of energy of the discrete Hamiltonian). In contrast, ordinary numerical methods
    become dissipative and exhibit incorrect long-term behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Q. Any good sources on numerics in Java
  prefs: []
  type: TYPE_NORMAL
- en: A. Try [Java numerics](http://math.nist.gov/javanumerics/).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (example suggested by Tamara Broderick) Write a program [LaplaceSquare.java](LaplaceSquare.java.html)
    to solve Laplace's equation with a fixed potential of 0 on the boundary of the
    grid and an internal square (of 1/9 the area) in the center with fixed potential
    100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve Laplace's equation with an L-shaped internal boundary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Skydiver.** Suppose the descent of a skydiver is modeled with the following
    differential equation: d²x/dt² = 9.8 - 0.01 (dx/dt)², where x is the distance
    from the drop zone (meters). Initially x(0) = 0 and x''(0) = 0\. Estimate distance
    traveled after 3 seconds. Estimate terminal velocity. use dt = 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Poisson''s equation.** Poisson''s equation is: dφ/dx² + dφ/dy² = f(x, y).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SIR epidemiology model.** The [SIR model](http://www.esam.northwestern.edu/~chopp/ESAM252-3/lab6.pdf)
    measures the number of susceptible, infected, and recovered individuals in a host
    population. Given a fixed population, let S(t) be the fraction that is susceptible
    to an infectious, but not deadly, disease at time t; let I(t) be the fraction
    that is infected at time t; and let R(t) be the fraction that has recovered. Let
    β be the rate at which an infected person infects a susceptible person. Let γ
    be the rate at which infected people recover from the disease. The differential
    equations describing the fraction of the population susceptible, infected, and
    recovering people is![SIR model](../Images/a14f625c419ae3842e2ef87c4eaf98d3.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first equation models the rate of infection; the second says that the population
    is closed; the third models the rate of recovery. Epidemiologists use this simple
    model to track the infection rate of measles and ebola. [Hong Kong flu](http://www.math.duke.edu/education/ccp/materials/diffcalc/sir/sir2.html):
    initially 7.9 million people, 10 infected, 0 recovered. Thus S(0) = 1, I(0) =
    1.27E-6, R(0) = 0. Estiamte average period of infection as 3 days, so γ = 1/3
    and infection rate as one new person every days, so β = 1/2. Plot S(t), I(t),
    and R(t) in different colors for t = 0 to 200.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Small pox: 1/γ = 14 days, 1/μ = 27375 days, 1/β = 27389/20. Corn blight: 1/γ
    = 20 days, 1/μ = 60 days, 1/β = 80/5.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Logistic map.** Write a program [LogisticMap.java](LogisticMap.java.html)
    that plots the *bifurcation diagram* of the logistic map. The logistic equation
    is : y[n+1] = 4 r y[n] (1 - y[n]). For each value of r between 0.7 and 1.0, initialize
    y[0] = 0.5, perform 1,000 iterates and discard them, then plot the next 100 iterates
    on the y-axis.[![Logistic map](../Images/e19718e07f957d589812dca8b7304049.png)](images/logistic800.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ODE Initial value problem in chemical engineering.** [equations governing
    a fermentor](http://www.glue.umd.edu/~nsw/ench250/ode.htm).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Predator-prey dynamics.** In the Lotka-Volterra model, there is one populations
    of animals (predator) that feeds on another population of animals (prey). Here
    is some data that approximates the populations of [lynx and snowshoe hares](http://www-rohan.sdsu.edu/~jmahaffy/courses/f00/math122/labs/labj/q3v1.htm)
    observed by the Hudson Bay Company beginning in 1852. The x_t denote the number
    of snow hares (prey) and y_t be the number of lynxes (predator) living at time
    t. Snow hares are vegetarians and we assume the number of hares born is proportional
    (with birth rate α) to the number of hares alive at time t. The probability of
    a decisive encounter between a lynx and a hare is proportional (with kill rate
    β) to the product of the number of hares and the number of lynxes. We assume the
    lynxes have no natural enemies and the number of deaths is proportional (with
    birth rate γ). We also assume that the number of lynxes born is proportional to
    the number of hares'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Equilibrium: (0, 0) or (δ / γ, α / β). Not stable. α = 1, &beta = 0.01, γ =
    0.02, δ = 1.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x_0 = 20, y_0 = 20.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use Euler's method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use 4th order Runge Kutta method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
