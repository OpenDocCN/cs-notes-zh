- en: 1.4 Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/python/14array](https://introcs.cs.princeton.edu/python/14array)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A *data structure* is a way to organize data that we wish to process with a
    computer program. A *one-dimensional array* (or *array*) is a data structure that
    stores a sequence of (references to) objects. We refer to the objects within an
    array as its *elements*. The method that we use to refer to elements in an array
    is *numbering* and then *indexing* them. If we have *n* elements in the sequence,
    we think of them as being numbered from 0 to *n* - 1\. Then, we can unambiguously
    specify one of them by referring to the *i*th element for any integer *i* in this
    range.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *two-dimensional array* is an array of (references to) one-dimensional arrays.
    Whereas the elements of a one-dimensional array are indexed by a single integer,
    the elements of a two-dimensional array are indexed by a pair of integers: the
    first specifying a row, and the second specifying a column.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to create an array in Python is to place comma-separated literals
    between matching square brackets. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: creates an array `SUITS[]` with four strings, and creates arrays `x[]` and `y[]`,
    each with three floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given two vectors of the same length, their *dot product* is the sum of the
    products of their corresponding components. If we represent the two vectors as
    one-dimensional arrays `x[]` and `y[]` that are each of length n, their dot product
    is easy to compute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For example, following trace shows the computation of the dot product of two
    vectors of length 3\.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e114ab4627575c0526ed48dbadceb1b9.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '![Array Data Structure](../Images/200f6a897c59649a78a6e9fd1bfe9574.png)'
  prefs: []
  type: TYPE_IMG
- en: It is useful to think of references to the elements in an array as stored contiguously,
    one after the other, in your computer's memory, as shown in the diagram at the
    right for the `SUITS[]` array defined above.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-based indexing.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We always refer to the first element of an array a[] as a[0], the second as
    a[1], and so forth. It might seem more natural to refer to the first element as
    a[1], the second element as a[2], and so forth, but starting the indexing with
    0 has some advantages and has emerged as the convention used in most modern programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Array length.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can access the length of an array using Python''s built-in `len()` function:
    `len(a)` is the number of elements in `a[]`. In Python, we can use the `+=` operator
    to append elements to an array. For example, if `a[]` is the array `[1, 2, 3]`,
    then the statement `a += [4]` extends it to `[1, 2, 3, 4]`. More generally, we
    can make an array of `n` floats, with each element initialized to `0.0`, with
    the code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Bounds checking.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must be careful when programming with arrays. It is your responsibility
    to use legal indices when accessing an array element.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/13c3ece2115d0c03d8d81ee3bae3030c.png)An object is *mutable* if
    its value can change. Arrays are mutable objects because we can change their elements.
    For example, if we create an array with the code `x = [.30, .60, .10]`, then the
    assignment statement `x[1] = .99` changes it to the array `[.30, .99, .10]`. An
    object-level trace of this operation is shown at the right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code reverses the order of the elements in an array a[]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An informal trace ![](../Images/7281aa8c0eb3fe39c04e0d43de548f96.png)of this
    code for a seven-element array `[3, 1, 4, 1, 5, 9, 2]` is shown at the right.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code iterates over all elements of an array to compute the average
    of the floats that it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also supports iterating over the elements in an array without referring
    to the indices explicitly. To do so, put the array name after the `in` keyword
    in a `for` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Built-in functions.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has several built-in functions that can take arrays as arguments. We
    have already discussed the `len()` function. As another example, if the elements
    of `a[]` are numeric, then sum(a) computes their sum, so that we can compute their
    average with `float(sum(a)) / len(a)` instead of using either of the loops just
    described. Other useful built-in functions that can take arrays as arguments are
    `min()` for computing the minimum and `max()` for computing the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an array.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can write an array by passing it as an argument to `stdio.write()` or `stdio.writeln()`.
    Each object in the array is converted to a string.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Array Aliases and Copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before looking at programs that use arrays, it is worthwhile to examine two
    fundamental array-processing operations in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Aliasing an array](../Images/46ee1209f80c593e59c1b862423f3922.png)If `x[]`
    and `y[]` are arrays, the statement `x = y` causes `x` and `y` to reference the
    same array. This result has an effect that is perhaps unexpected, at first, because
    it is natural to think of `x` and `y` as references to two independent arrays.
    For example, after the assignment statements'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`y[1]` is also `.99`, even though the code does not refer directly to `y[1]`.
    This situation — whenever two variables refer to the same object — is known as
    *aliasing*, and is illustrated in the object-level trace at the right.'
  prefs: []
  type: TYPE_NORMAL
- en: Copying and slicing.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/4e1ce3311743e66750be1e765eac2cd0.png)So how do we make a copy
    `y[]` of a given array `x[]`? One answer to this question is to iterate through
    `x[]` to build `y[]`, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This situation is illustrated in the object-level trace at the right.
  prefs: []
  type: TYPE_NORMAL
- en: Copying an array is such a useful operation that Python provides language support
    for a more general operation known as *slicing*, The expression `a[i:j]` evaluates
    to a new array whose elements are `a[i], ..., a[j-1]`. Moreover, the default value
    for `i` is 0 and the default value for `j` is `len(a)`, so `y = x[:]` is equivalent
    to the code given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: System Support for Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python code for processing arrays can take many forms. We describe each briefly
    for context.
  prefs: []
  type: TYPE_NORMAL
- en: Python's built-in `list` data type.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In its most basic form, an array supports four core operations: creation, indexed
    access, indexed assignment, and iteration. In this booksite, we use Python''s
    built-in `list` data type for arrays because it supports these basic operations.
    We consider more elaborate operations supported by Python''s `list` data type
    in Chapter 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Python's `numpy` module.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python''s built-in `list` data type can have severe performance problems. For
    that reason, scientists and engineers often use a Python extension module called
    `numpy` for processing huge arrays of numbers, because that module uses a lower-level
    representation that avoids many of the inefficiencies in the standard Python representation.
    See Appendix: `numpy` for an overview of the `numpy` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `stdarray` module.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier we introduced the booksite `stdio` module. Now, we introduce another
    booksite module: the `stdarray` module. Its primary purpose is to define functions
    for processing arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A fundamental operation that is found in nearly every array-processing program
    is to create an array of *n* elements, each initialized to a given value. As we
    have seen, you can do this in Python with code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Such code is so common that Python even has a special shorthand notation for
    it: the code `a = [0.0]*n` is equivalent to the code just given. Rather than repeat
    such code throughout the book, we will use code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For consistency, `stdarray` also includes a `create2D()` function, which we
    will examine later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stdarray API](../Images/2cc2d66e674cfef0900458c157bd23f2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Sample Applications of Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we consider a number of applications that illustrate the utility of arrays
    and also are interesting in their own right.
  prefs: []
  type: TYPE_NORMAL
- en: Representing playing cards.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that we want to compose programs that process playing cards. We might
    start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we might use these two arrays to write a random card name, such
    as `Queen of Clubs`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A more typical situation is when we compute the values to be stored in an array.
    For example, we might use the following code to initialize an array of length
    52 that represents a deck of playing cards, using the two arrays just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Exchange.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Frequently, we wish to exchange two elements in an array. Continuing our example
    with playing cards, the following code exchanges the cards at indices `i` and
    `j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Shuffle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '. The following code shuffles our deck of cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Proceeding from left to right, we pick a random card from deck[i] through deck[n-1]
    (each card equally likely) and exchange it with deck[i].
  prefs: []
  type: TYPE_NORMAL
- en: Sampling without replacement.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many situations, we want to draw a random sample from a set such that each
    element in the set appears at most once in the sample. The program [sample.py](sample.py.html)
    takes command-line arguments `m` and `n` and creates a permutation of size `n`
    whose first `m` elements constitute a random sample.
  prefs: []
  type: TYPE_NORMAL
- en: Precomputed values.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another application of arrays is to save values that you have computed for
    later use. As an example, suppose that you are composing a program that performs
    calculations using small values of the harmonic numbers. An efficient approach
    is to save the values in an array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that we waste one slot in the array (element 0) to make harmonic[1] correspond
    to the first harmonic number 1.0 and harmonic[i] correspond to the ith harmonic
    number. This method is not effective if we need values for huge n, but it is very
    effective if we need values for small n many different times.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying repetitive code.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example of another simple application of arrays, consider the following
    code fragment, which writes the name of a month given its number (1 for January,
    2 for February, and so forth):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A more compact alternative is to use an array of strings holding the month
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This technique would be especially useful if you needed to access the name of
    a month by its number in several different places in your program. Note that we
    intentionally waste one slot in the array (element 0) to make `MONTHS[1]` correspond
    to January, as required.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bdc96ebdc3d0e502cb98eccdc7cbd430.png)'
  prefs: []
  type: TYPE_IMG
- en: Coupon collector.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that you have a deck of cards and you pick cards at random (with replacement)
    one by one. How many cards do you need to turn up before you have seen one of
    each suit? That is an example of the famous *coupon collector* problem. In general,
    suppose that a trading card company issues trading cards with n different possible
    cards: how many do you have to collect before you have all n possibilities, assuming
    that each possibility is equally likely for each card that you collect? The program
    [couponcollector.py](couponcollector.py.html) is an example program that simulates
    this process. See the textbook for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Sieve of Eratosthenes.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The prime counting function *π*(*n*) is the number of primes less than or equal
    to *n*. For example *π*(17) = 7 since the first seven primes are 2, 3, 5, 7, 11,
    13, and 17\. Program [primesieve.py](primesieve.py.html) takes a command line
    integer n and computes *π*(*n*) using the [Sieve of Eratosthenes](http://mathworld.wolfram.com/SieveofEratosthenes.html).
    See the textbook for details.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Two-Dimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c7dde38383471de0cf1aa29eec1f8ccb.png)'
  prefs: []
  type: TYPE_IMG
- en: In many applications, a convenient way to store information is to use a table
    of numbers organized in a rectangular table and refer to rows and columns in the
    table. The mathematical abstraction corresponding to such tables is a *matrix*;
    the corresponding data structure is a *two-dimensional array*.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to create a two-dimensional array is to place comma-separated
    one-dimensional arrays between matching square brackets. For example, this matrix
    of integers having two rows and three columns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'could be represented in Python using this array of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We call such an array a *2-by-3* array. More generally, Python represents an
    *m*-by-*n* array as an array that contains *m* objects, each of which is an array
    that contains *n* objects. For example, this Python code creates an *m*-by-*n*
    array `a[][]` of floats, with all elements initialized to 0.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As for one-dimensional arrays, we use the self-descriptive alternative `stdarray.create2D(m,
    n, 0.0)` from our booksite module `stdarray` throughout this booksite.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `a[][]` is a two-dimensional array, the syntax `a[i]` denotes a reference
    to its `i`th row. The syntax `a[i][j]` refers to the object at row `i` and column
    `j`. To access each of the elements in a two-dimensional array, we use two nested
    `for` loops. For example, this code writes each object of the *m*-by-*n* array
    `a[][]`, one row per line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code achieves the same effect without using indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/df81a47071dbd1e5ced8f4147b806b14.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix operations.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Typical applications in science and engineering involve representing matrices
    as two-dimensional arrays and then implementing various mathematical operations
    with matrix operands. For example, we can *add* two *n*-by-*n* matrices `a[][]`
    and `b[][]` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can *multiply* two matrices. Each element `c[i][j]` in the product
    of `a[][]` and `b[][]` is computed by taking the dot product of row `i` of `a[][]`
    with column `j` of `b[][]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Ragged arrays.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is actually no requirement that all rows in a two-dimensional array have
    the same length. An array with rows of nonuniform length is known as a *ragged
    array*. The possibility of ragged arrays creates the need for taking more care
    in crafting array-processing code. For example, this code writes the contents
    of a ragged array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the equivalent code that does not use indices works equally well
    with both rectangular and ragged arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional arrays.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same notation extends to allow us to compose code using arrays that have
    any number of dimensions. Using arrays of arrays of arrays..., we can create three-dimensional
    arrays, four-dimensional arrays, and so forth, and then refer to an individual
    element with code like `a[i][j][k]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: self-avoiding random walks.'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The program [selfavoid.py](selfavoid.py.html) is an application of two-dimensional
    arrays to chemistry. See the textbook for details.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Why do Python string and list indices start at 0 instead of 1?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** That convention originated with machine-language programming, where
    the address of an array element would be computed by adding the index to the address
    of the beginning of an array. Starting indices at 1 would entail either a waste
    of space at the beginning of the array or a waste of time to subtract the 1\.
    Here''s [Edsger Dijkstra''s explanation](http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What happens if I use a negative integer to index an array?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The answer may surprise you. Given an array `a[]`, you can use the index
    `-i` as shorthand for `len(a)-i`. For example, you can refer to the last element
    in the array with `a[-1]` or `a[len(a)-1]` and the first element with `a[-len(a)]`
    or `a[0]`. Python raises an `IndexError` at run time if you use an index outside
    of the range `-len(a)` through `len(a)-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why does the slice `a[i:j]` include `a[i]` but exclude `a[j]`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The notation is consistent with ranges defined with `range()`, which
    includes the left endpoint but excludes the right endpoint. It leads to some appealing
    properties: `j-i` is the length of the subarray (assuming no truncation); `a[0:len(a)]`
    is the entire array; `a[i:i]` is the empty array; and a`[i:j] + a[j:k]` is the
    subarray `a[i:k]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What happens when I compare two arrays `a[]` and `b[]` with `(a == b)`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** It depends. For arrays (or multidimensional arrays) of numbers, it works
    as you might expect: the arrays are equal if each has the same length and the
    corresponding elements are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What happens when a random walk does not avoid itself?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** This case is well understood. It is a two-dimensional version of the
    gambler''s ruin problem, as described in Section 1.3.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Which pitfalls should I watch out for when using arrays?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Remember that creating an array takes time proportional to the length
    of the array. You need to be particularly careful about creating arrays within
    loops.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compose a program that creates a one-dimensional array `a` containing exactly
    1000 integers, and then attempts to access `a[1000]`. What happens when you run
    the program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given two vectors of length `n` that are represented with one-dimensional arrays,
    compose a code fragment that computes the *Euclidean distance* between them (the
    square root of the sum of the squares of the differences between corresponding
    elements).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a code fragment that reverses the order of a one-dimensional array
    of floats. Do not create another array to hold the result. *Hint*: Use the code
    provided earlier in this web page for exchanging two elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution:*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: What is wrong with the following code fragment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: Initially `a` is the empty array. Subsequently no elements are
    appended to the array. Thus `a[0]`, `a[1]`, and so forth do not exist. The attempts
    to use them in an assignment statement will raise an `IndexError` at run time.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a code fragment that writes the contents of a two-dimensional array
    of bools, using `*` to represent `True` and a space to represent `False`. Include
    row and column numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code fragment write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is `a[]` afater executing the following code fragment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compose a program that takes an integer command-line argument `n` and writes
    `n` poker hands (five cards each) from a shuffled deck, separated by blank lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [deal.py](deal.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compose code fragments to create a two-dimensional array `b[][]` that is a
    copy of an existing two-dimensional array `a[][]`, under each of the following
    assumptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` is square.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` is rectangular.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` may be ragged.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Your solution to (b) should work for (a), and your solution to (c) should work
    for both (b) and (a).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compose a code fragment to write the *transposition* (rows and columns changed)
    of a two-dimensional array. For the example, when given this two-dimensional array
    of integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'your code should write this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compose a code fragment to transpose a square two-dimensional array `b[][]`
    in place without creating a second array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* See [transpose.py](transpose.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a code fragment to create a two-dimensional array `b[][]` that is the
    transpose of an existing *m*-by-*n* array `a[][]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that computes the product of two square matrices of boolean
    values, using the `or` operation instead of `+` and the `and` operation instead
    of `*`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that accepts an integer *n* from the command line and creates
    an *n*-by-*n* boolean array `a` such that `a[r][c]` is `True` if `r` and `c` are
    relatively prime (have no common factors other than 1), and `False` otherwise.
    Then write the array (see a previous exercise in this section of the booksite)
    using `*` to represent `True` and a space to represent `False`. Include row and
    column numbers. *Hint:* Use sieving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a code fragment to multiply two rectangular matrices of floats that
    are not necessarily square. *Note*: For the dot product to be well-defined, the
    number of columns in the first matrix must be equal to the number of rows in the
    second matrix. Write an error message if the dimensions do not satisfy this condition.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [selfavoid.py](selfavoid.py.html) to calculate and write the average
    length of the paths as well as the dead-end probability. Keep separate the average
    lengths of escape paths and dead-end paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [selfavoid.py](selfavoid.py.html) to calculate and write the average
    area of the smallest axis-oriented rectangle that encloses the path. Keep separate
    statistics for escape paths and dead-end paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Dice simulation.** The following code computes the exact probability distribution
    for the sum of two dice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: After this code completes, `probabilities[k]` is the probability that the dice
    sum to `k`. Run experiments to validate this calculation simulating *n* dice throws,
    keeping track of the frequencies of occurrence of each value when you compute
    the sum of two random integers between 1 and 6\. How large does *n* have to be
    before your empirical results match the exact results to three decimal places?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Longest plateau.** Given an array of integers, compose a program that finds
    the length and location of the longest contiguous sequence of equal values where
    the values of the elements just before and just after this sequence are smaller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Empirical shuffle check.** Run computational experiments to check that our
    shuffling code works as advertised. Compose a program that takes integer command-line
    arguments *m* and *n*, does *n* shuffles of an array of size *m* that is initialized
    with `a[i] = i` before each shuffle, and writes an *m*-by-*m* table such that
    row `i` gives the number of times `i` wound up in position `j` for all `j`. All
    entries in the array should be close to *n*/*m*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bad shuffling.** Suppose that you choose a random integer between 0 and *n*-1
    in our shuffling code instead of one between `i` and `n-1`. Show that the resulting
    order is not equally likely to be one of the *n*! possibilities. Run the test
    of the previous exercise for this version.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Partial solution:* When *n* = 3, all 3! = 6 outcomes are possible, but some
    are more likely:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ABC | ACB | BAC | BCA | CAB | CBA |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| 4/27 | 5/27 | 6/27 | 4/27 | 5/27 | 3/27 |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '**Music shuffling.** You set your music player to shuffle mode. It plays each
    of the *n* songs before repeating any. Compose a program to estimate the likelihood
    that you will not hear any sequential pair of songs (that is, song 3 does not
    follow song 2, song 10 does not follow song 9, and so on).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Minima in permutations.** Compose a program that takes an integer *n* from
    the command line, generates a random permutation, writes the permutation, and
    writes the number of left-to-right minima in the permutation (the number of times
    an element is the smallest seen so far). Then compose a program that takes integers
    *m* and *n* from the command line, generates *m* random permutations of size *n*,
    and writes the average number of left-to-right minima in the permutations generated.
    *Extra credit*: Formulate a hypothesis about the number of left-to-right minima
    in a permutation of size *n*, as a function of *n*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inverse permutation.** Compose a program that accepts a permutation of the
    integers 0 to *n*-1 from *n* command-line arguments and writes its inverse. (If
    the permutation is an array `a[]`, its inverse is the array `b[]` such that `a[b[i]]`
    = `b[a[i]]` = `i`.) Be sure to check that the input is a valid permutation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [inversepermutation.py](inversepermutation.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hadamard matrix.** The *n*-by-*n* Hadamard matrix *H[n]* matrix is a boolean
    matrix with the remarkable property that any two rows differ in exactly *n*/2
    elements. (This property makes it useful for designing *error-correcting codes*.)
    *H*[1] is a 1-by-1 matrix with the single element `True`, and for *n* > 1, *H*[2*n*]
    is obtained by aligning four copies of *H[n]* in a large square, and then inverting
    all of the elements in the lower right *n*-by-*n* copy, as shown in the following
    examples (with `T` representing `True` and `F` representing `False`, as usual).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compose a program that takes one command-line argument *n* and writes *H[n]*.
    Assume that *n* is a power of 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [hadamard.py](hadamard.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rumors.** Alice is throwing a party with n other guests, including Bob. Bob
    starts a rumor about Alice by telling it to one of the other guests. A person
    hearing this rumor for the first time will immediately tell it to one other guest,
    chosen at random from all the people at the party except Alice and the person
    from whom they heard it. If a person (including Bob) hears the rumor for a second
    time, he or she will not propagate it further. Compose a program to estimate the
    probability that everyone at the party (except Alice) will hear the rumor before
    it stops propagating. Also calculate an estimate of the expected number of people
    to hear the rumor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Find a duplicate.** Given an array of *n* elements with each element between
    1 and *n*, compose a code fragment to determine whether there are any duplicates.
    You do not need to preserve the contents of the given array, but do not use an
    extra array.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Minesweeper.** Compose a program that takes three command-line arguments
    *m*, *n*, and *p* and produces an *m*-by-*n* boolean array where each element
    is occupied with probability *p*. In the minesweeper game, occupied cells represent
    bombs and empty cells represent safe cells. Write the array using an asterisk
    for bombs and a period for safe cells. Then, replace each safe square with the
    number of neighboring bombs (above, below, left, right, or diagonal) and write
    the result, as in this example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try to express your code so that you have as few special cases as possible to
    deal with, by using an (*m*+2)-by-(*n*+2) boolean array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [minesweeper.py](minesweeper.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Self-avoiding walk length.** Suppose that there is no limit on the size of
    the grid. Run experiments to estimate the average walk length.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Three-dimensional self-avoiding walks.** Run experiments to verify that the
    dead-end probability is 0 for a three-dimensional self-avoiding walk and to compute
    the average walk length for various values of *n*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random walkers.** Suppose that `n` random walkers, starting in the center
    of an *n*-by-*n* grid, move one step at a time, choosing to go left, right, up,
    or down with equal probability at each step. Compose a program to help formulate
    and test a hypothesis about the number of steps taken before all cells are touched.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [randomwalkers.py](randomwalkers.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Bridge hands.** In the game of bridge, four players are dealt hands of 13
    cards each. An important statistic is the distribution of the number of cards
    in each suit in a hand. Which is the most likely, 5-3-3-2, 4-4-3-2, or 4-3-3-3?
    Compose a program to help you answer this question.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Birthday problem.** Suppose that people continue to enter an empty room until
    a pair of people share a birthday. On average, how many people will have to enter
    before there is a match? Run experiments to estimate the value of this quantity.
    Assume birthdays to be uniform random integers between 0 and 364.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [birthday.py](birthday.py.html) and [birthdays.py](birthdays.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Coupon collector.** Run experiments to validate the classical mathematical
    result that the expected number of coupons needed to collect *n* values is about
    *nH[n]*. For example, if you are observing the cards carefully at the blackjack
    table (and the dealer has enough decks randomly shuffled together), you will wait
    until about 235 cards are dealt, on average, before seeing every card value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Riffle shuffle.** Compose a program to rearrange a deck of *n* cards using
    the Gilbert-Shannon-Reeds model of a riffle shuffle. First, generate a random
    integer *r* according to a *binomial distribution*: flip a fair coin *n* times
    and let *r* be the number of heads. Now, divide the deck into two piles: the first
    *r* cards and the remaining *n* - *r* cards. To complete the shuffle, repeatedly
    take the top card from one of the two piles and put it on the bottom of a new
    pile. If there are *n*[1] cards remaining in the first pile and *n*[2] cards remaining
    in the second pile, choose the next card from the first pile with probability
    *n*[1] / (*n*[1] + *n*[2]) and from the second pile with probability *n*[2] /
    (*n*[1] + *n*[2]). Investigate how many riffle shuffles you need to apply to a
    deck of 52 cards to produce a (nearly) uniformly shuffled deck.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Binomial coefficients.** Compose a program that builds and writes a two-dimensional
    ragged array `a` such that `a[n][k]` contains the probability that you get exactly
    `k` heads when you toss a fair coin `n` times. Take a command-line argument to
    specify the maximum value of `n`. These numbers are known as the *binomial distribution*:
    if you multiply each element in row *k* by 2*^n*, you get the *binomial coefficients*
    (the coefficients of *x^k* in (*x*+1)*^n*) arranged in *Pascal''s triangle*. To
    compute them, start with `a[n][0] = 0.0` for all `n` and `a[1][1] = 1.0`, then
    compute values in successive rows, left to right, with `a[n][k] = (a[n-1][k] +
    a[n-1][k-1])/2.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
