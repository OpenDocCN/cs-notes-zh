- en: 2.3   Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/23recursion](https://introcs.cs.princeton.edu/java/23recursion)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The idea of calling one function from another immediately suggests the possibility
    of a function calling *itself*. The function-call mechanism in Java supports this
    possibility, which is known as *recursion*.
  prefs: []
  type: TYPE_NORMAL
- en: Your first recursive program.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "Hello, World" for recursion is the *factorial* function, which is defined
    for positive integers *n* by the equation
  prefs: []
  type: TYPE_NORMAL
- en: $$n! = n \times (n-1) \times (n-2) \times \; \ldots \; \times 2 \times 1$$
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The quantity *n*! is easy to compute with a `for` loop, but an even easier
    method in [Factorial.java](Factorial.java.html) is to use the following recursive
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can trace this computation in precisely the same way that we trace any sequence
    of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our `factorial()` implementation exhibits the two main components that are required
    for every recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: The *base case* returns a value without making any subsequent recursive calls.
    It does this for one or more special input values for which the function can be
    evaluated without recursion. For `factorial()`, the base case is *n* = 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *reduction step* is the central part of a recursive function. It relates
    the value of the function at one (or more) input values to the value of the function
    at one (or more) other input values. Furthermore, the sequence of input values
    values must *converge* to the base case. For `factorial()`, the value of *n* decreases
    by 1 for each call, so the sequence of input values converges to the base case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical induction.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursive programming is directly related to *mathematical induction*, a technique
    for proving facts about natural numbers. Proving that a statement involving an
    integer *n* is true for infinitely many values of *n* by mathematical induction
    involves the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *base case*: prove the statement true for some specific value or values
    of *n* (usually 0 or 1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *induction step*: assume that the statement to be true for all positive
    integers less than *n*, then use that fact to prove it true for *n*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a proof suffices to show that the statement is true for *infinitely* many
    values of *n*: we can start at the base case, and use our proof to establish that
    the statement is true for each larger value of *n*, one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: Euclid's algorithm.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *greatest common divisor* (gcd) of two positive integers is the largest
    integer that divides evenly into both of them. For example, the gcd(102, 68) =
    34.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can efficiently compute the gcd using the following property, which holds
    for positive integers *p* and *q*:'
  prefs: []
  type: TYPE_NORMAL
- en: If *p* > *q*, the gcd of *p* and *q* is the same as the gcd of *q* and *p* %
    *q*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The static method `gcd()` in [Euclid.java](Euclid.java.html) is a compact recursive
    function whose reduction step is based on this property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Towers of Hanoi.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![recursive solution to towers of Hanoi](../Images/cfd21be7f571fbaf9be2c807be2f5a42.png)
    In the *towers of Hanoi* problem, we have three poles and *n* discs that fit onto
    the poles. The discs differ in size and are initially stacked on one of the poles,
    in order from largest (disc *n*) at the bottom to smallest (disc 1) at the top.
    The task is to move all *n* discs to another pole, while obeying the following
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Move only one disc at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never place a larger disc on a smaller one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recursion provides just the plan that we need: First we move the top *n*−1
    discs to an empty pole, then we move the largest disc to the other empty pole,
    then complete the job by moving the *n*−1 discs onto the largest disc. [TowersOfHanoi.java](TowersOfHanoi.java.html)
    is a direct implementation of this strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: Exponential time.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![exponential growth](../Images/9a3e349ca4c3b79eb5c0be843fa36bbe.png)  Let
    T(*n*) be the number of move directives issued by [TowersOfHanoi.java](TowersOfHanoi.java.html)
    to move *n* discs from one peg to another. Then, T(*n*) must satisfy the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: $$T(n) = 2T(n-1) + 1 \text{ for } n > 1, \text{ with } T(1) = 1$$
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Such an equation is known in discrete mathematics as a *recurrence relation*.
    We can often use them to derive a closed-form expression for the quantity of interest.
    For example, T(1) = 1, T(2) = 3, T(3) = 7, and T(4) = 15. In general, T(*n*) =
    2^(*n*) − 1. Assuming the monks move discs at the rate of one per second, it would
    take them more 5.8 billion centuries to solve the 64-disc problem.
  prefs: []
  type: TYPE_NORMAL
- en: Gray code.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *n*-bit *Gray code* is a list of the 2^(*n*) different *n*-bit binary numbers
    such that each entry in the list differs in precisely one bit from its predecessor.
    The *n* bit binary reflected Gray code is defined recursively as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the *n*−1 bit code, with 0 prepended to each word, followed by
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the *n*−1 bit code in reverse order, with 1 prepended to each word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 0-bit code is defined to be null, so the 1-bit code is 0 followed by 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '|                | ![Gray code representations](../Images/3c1deb8434d454058bc18cb9902f75c7.png)
    |                | ![2-, 3-, and 4-bit Gray codes](../Images/47f120f9f06757e65cb89ad050cc63c9.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '[Beckett.java](Beckett.java.html) uses an *n*-bit Gray code to print stage
    directions for an *n*-character play in such a way that characters enter and exit
    one at a time so that each subset of characters on the stage appears exactly once.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive graphics.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple recursive drawing schemes can lead to pictures that are remarkably intricate.
    For example, an *H-tree of order n* is defined as follows: The base case is null
    for *n* = 0\. The reduction step is to draw, within the unit square three lines
    in the shape of the letter H four H-trees of order *n* − 1, one connected to each
    tip of the H with the additional provisos that the H-trees of order *n* − 1 are
    centered in the four quadrants of the square, halved in size.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![htree 1](../Images/abddc8550d2dd3f1ffb21f40d53ccdea.png) | ![htree 2](../Images/382562bcb3194374b999bcfec7559b78.png)
    | ![htree 3](../Images/a252015aa78d10438ecbd0e78bc58586.png) | ![htree 4](../Images/b42a26c1155077a1c093b8c4b6eb604a.png)
    | ![htree 5](../Images/85518097da4a973f47ae85df69cef073.png) |'
  prefs: []
  type: TYPE_TB
- en: '[Htree.java](Htree.java.html) takes a command-line argument *n*, and plots
    to standard drawing an H-tree of order *n*. An H-tree is a simple example of a
    *fractal*: a geometric shape that can be divided into parts, each of which is
    (approximately) a reduced size copy of the original.'
  prefs: []
  type: TYPE_NORMAL
- en: Brownian bridge.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Brownian.java](Brownian.java.html) produces a function graph that approximates
    a simple example of fractional Brownian motion known as *Brownian bridge*. You
    can think of this graph as a random walk that connects the two points (*x*[0],
    *y*[0]) and (*x*[1], *y*[1]), controlled by a few parameters. The implementation
    is based on the *midpoint displacement method*, which is a recursive plan for
    drawing the plot within the *x*-interval [*x*[0], *x*[1]]. The base case (when
    the size of the interval is smaller than a given tolerance) is to draw a straight
    line connecting the two endpoints. The reduction case is to divide the interval
    into two halves, proceeding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the midpoint (*x[m]*, *y[m]*) of the interval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add to the *y*-coordinate *y[m]* of the midpoint a random value δ, drawn from
    the Gaussian distribution with mean 0 and a given variance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recur on the subintervals, dividing the variance by a given scaling factor *s*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shape of the curve is controlled by two parameters: the *volatility* (initial
    value of the variance) controls the distance the graph strays from the straight
    line connecting the points, and the *Hurst exponent* controls the smoothness of
    the curve.'
  prefs: []
  type: TYPE_NORMAL
- en: '|       | ![Brownian bridge](../Images/703e09db2d0eed077c43d617d778936b.png)
    |       | ![Brownian with H = 0.5](../Images/2a37e7191a15e3ce6bcf03c3bdd8c142.png)
    |       | ![Brownian with H = 0.05](../Images/cdc3430903174f36959472db9acf4370.png)
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Pitfalls of recursion.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With recursion, you can write compact and elegant programs that fail spectacularly
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '*Missing base case.* The recursive function in [NoBaseCase.java](NoBaseCase.java.html)
    is supposed to compute harmonic numbers, but is missing a base case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you call this function, it will repeatedly call itself and never return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*No guarantee of convergence.* Another common problem is to include within
    a recursive function a recursive call to solve a subproblem that is not smaller
    than the original problem. For example, the recursive function in [NoConvergence.java](NoConvergence.java.html)
    goes into an infinite recursive loop for any value of its argument (except 1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Excessive memory requirements.* If a function calls itself recursively an
    excessive number of times before returning, the memory required by Java to keep
    track of the recursive calls may be prohibitive. The recursive function in [ExcessiveMemory.java](ExcessiveMemory.java.html)
    correctly computes the nth harmonic number. However, calling it with a huge value
    of `n` will lead to a `StackOverflowError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Excessive recomputation.* ![Wrong way to compute Fibonacci numbers](../Images/111e822a28258fd755ae5d63d1003bed.png)
    The temptation to write a simple recursive program to solve a problem must always
    be tempered by the understanding that a simple program might require exponential
    time (unnecessarily), due to excessive recomputation. For example, the Fibonacci
    sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: is defined by the formula
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $$F_n = F_{n-1} + F_{n-2} \text{ for } n \ge 2, \text{ with } F_0 = 0 \text{
    and } F_1 = 1$$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A novice programmer might implement this recursive function to compute numbers
    in the Fibonacci sequence, as in [Fibonacci.java](Fibonacci.java.html):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this program is spectacularly inefficient! To see why it is futile
    to do so, consider what the function does to compute `fibonacci(8) = 21`. It first
    computes `fibonacci(7) = 13` and `fibonacci(6) = 8`. To compute `fibonacci(7)`,
    it recursively computes `fibonacci(6) = 8` *again* and `fibonacci(5) = 5`. Things
    rapidly get worse. The number of times this program computes `fibonacci(1)` when
    computing `fibonacci(n)` is precisely *F*[*n*].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dynamic programming.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A general approach to implementing recursive programs, The basic idea of *dynamic
    programming* is to recursively divide a complex problem into a number of simpler
    subproblems; store the answer to each of these subproblems; and, ultimately, use
    the stored answers to solve the original problem. By solving each subproblem only
    once (instead of over and over), this technique avoids a potential exponential
    blow-up in the running time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Top-down dynamic programming.* In *top-down* dynamic programming, we store
    or *cache* the result of each subproblem that we solve, so that the next time
    we need to solve the same subproblem, we can use the cached values instead of
    solving the subproblem from scratch. [TopDownFibonacci.java](TopDownFibonacci.java.html)
    illustrates top-down dynamic programming for computing Fibonacci numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![top-down dynamic programming](../Images/d2f1a08b69aef188f5b217fd2f65428f.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Bottom-up dynamic programming.* In *bottom-up* dynamic programming, we compute
    solutions to all of the subproblems, starting with the “simplest” subproblems
    and gradually building up solutions to more and more complicated subproblems.
    [BottomUpFibonacci.java](BottomUpFibonacci.java.html) illustrates bottom-up dynamic
    programming for computing Fibonacci numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Longest common subsequence problem.* Given two strings *x* and *y*, we wish
    to compute their <em.longest common="" subsequence="">(LCS). If we delete some
    characters from *x* and some characters from *y*, and the resulting two strings
    are equal, we call the resulting string a *common subsequence*. The LCS problem
    is to find a common subsequence of two strings that is as long as possible. For
    example, the LCS of `GGCACCACG` and `ACGGCGGATACG` is `GGCAACG`, a string of length
    7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]</em.longest>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Longest common subsequence recurrence.* Now we describe a recursive formulation
    that enables us to find the LCS of two given strings `s` and `t`. Let `m` and
    `n` be the lengths of `s` and `t`, respectively. We use the notation `s[i..m)`
    to denote the *suffix* of `s` starting at index `i`, and `t[j..n)` to denote the
    suffix of `t` starting at index `j`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `s` and `t` begin with the same character, then the LCS of `s` and `t` contains
    that first character. Thus, our problem to reduces to finding the LCS of the suffixes
    `s[1..m)` and `t[1..n)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `s` and `t` begin with different characters, both characters cannot be part
    of a common subsequence, so can safely discard one or the other. In either case,
    the problem reduces to finding the LCS of two strings—either `s[0..m)` and `t[1..n)`
    or `s[1..m)` and `t[0..n)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, if we let `opt[i][j]` denote the length of the LCS of the suffixes
    `s[i..m)` and `t[j..n)`, then the following recurrence holds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Dynamic programming solution.* [LongestCommonSubsequence.java](LongestCommonSubsequence.java.html)
    begins with a bottom-up dynamic programming approach to solving this recurrence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![longest common subsequence](../Images/83212e1903cc0be5ecb7da3f7c2322a1.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'The final challenge is to recover the longest common subsequence itself, not
    just its length. The key idea is to retrace the steps of the dynamic programming
    algorithm *backward*, rediscovering the path of choices (highlighted in gray in
    the diagram) from `opt[0][0]` to `opt[m][n]`. To determine the choice that led
    to `opt[i][j]`, we consider the three possibilities:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`The character s[i]` matches `t[j]`. In this case, we must have `opt[i][j]`
    = `opt[i+1][j+1]` + 1, and the next character in the LCS is `s[i]`. We continue
    tracing back from `opt[i+1][j+1]`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The LCS does not contain `s[i]`. In this case, `opt[i][j]` = `opt[i+1][j]` and
    we continue tracing back from `opt[i+1][j]`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The LCS does not contain `t[j]`. In this case, `opt[i][j]` = `opt[i][j+1]` and
    we continue tracing back from `opt[i][j+1]`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given four positive integers `a`, `b`, `c`, and `d`, explain what value is computed
    by `gcd(gcd(a, b), gcd(c, d))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: the greatest common divisor of `a`, `b`, `c`, and `d`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explain in terms of integers and divisors the effect of the following Euclid-like
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: Returns whether `p` and `q` are relatively prime.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider the following recursive function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are the values of `mystery(2, 25)` and `mystery(3, 11)`? Given positive
    integers `a` and `b`, describe what value `mystery(a, b)` computes. Answer the
    same question, but replace `+` with `*` and replace `return 0` with `return 1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: 50 and 33\. It computes a*b. If you replace `+` with `*`, it computes
    a^b.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a program [AnimatedHtree.java](AnimatedHtree.java.html) that animates
    the drawing of the H-tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Animated H-tree](../Images/5e790e385991e808af1b9269d960aeef.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Next, rearrange the order of the recursive calls (and the base case), view the
    resulting animation, and explain each outcome.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Binary representation.** Write a program [IntegerToBinary.java](IntegerToBinary.java.html)
    that takes a positive integer *n* (in decimal) as a command-line argument and
    prints its binary representation. Recall, in [Binary.java](.../13loops/Binary.java.html),
    we used the method of subtracting out powers of 2\. Now, use the following simpler
    method: repeatedly divide 2 into *n* and read the remainders backwards. First,
    write a `while` loop to carry out this computation and print the bits in the wrong
    order. Then, use recursion to print the bits in the correct order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Permutations.** Write a program [Permutations.java](Permutations.java.html)
    that take an integer command-line argument *n* and prints all <m>n! permutations
    of the *n* letters starting at `a` (assume that *n* is no greater than 26). A
    *permutation* of *n* elements is one of the *n*! possible orderings of the elements.
    As an example, when *n* = 3 you should get the following output (but do not worry
    about the order in which you enumerate them):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]</m>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Permutations of size k.** Write a program [PermutationsK.java](PermutationsK.java.html)
    that two command-line arguments *n* and *k*, and prints out all \(P(n, k) = \frac{n!}{(n-k)!}\)
    permutations that contain exactly *k* of the *n* elements. Below is the desired
    output when *k* = 2 and *n* = 4 (again, do not worry about the order):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Combinations.** Write a program [Combinations.java](Combinations.java.html)
    that takes an integer command-line argument *n* and prints all 2^(*n*) *combinations*
    of any size. A *combination* is a subset of the *n* elements, independent of order.
    As an example, when *n* = 3, you should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that your program needs to print the empty string (subset of size 0).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Combinations of size k.** Write a program [CombinationsK.java](CombinationsK.java.html)
    that takes two command-line arguments *n* and *k*, and prints all \(C(n, k) =
    \frac{n!}{k! (n-k)!}\) combinations of size *k*. For example, when *n* = 5 and
    *k* = 3, you should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternate solution using arrays instead of strings: [Comb2.java](Comb2.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Recursive squares.** Write a program to produce each of the following recursive
    patterns. The ratio of the sizes of the squares is 2.2:1. To draw a shaded square,
    draw a filled gray square, then an unfilled black square.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![recursive squares](../Images/cbb67867af17c3b55d47068e21c99349.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '[RecursiveSquares.java](RecursiveSquares.java.html) gives a solution to the
    first pattern.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Gray code.** Modify [Beckett.java](Beckett.java.html) to print the Gray code
    (not just the sequence of bit positions that change).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: [GrayCode.java](GrayCode.java.html) uses Java''s string data type;
    [GrayCodeArray.java](GrayCodeArray.java.html) uses a boolean array.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Animated towers of Hanoi animation.** Write a program [AnimatedHanoi.java](AnimatedHanoi.java.html)
    that uses `StdDraw` to animate a solution to the towers of Hanoi problem, moving
    the discs at a rate of approximately 1 per second.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Collatz function.** Consider the following recursive function in [Collatz.java](Collatz.java.html),
    which is related to a famous unsolved problem in number theory, known as the [Collatz
    problem](http://mathworld.wolfram.com/CollatzProblem.html) or the *3n + 1 problem*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For example, a call to `collatz(7)` prints the sequence
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: 'as a consequence of 17 recursive calls. Write a program that takes a command-line
    argument `n` and returns the value of `i < n` for which the number of recursive
    calls for `collatz(i)` is maximized. Hint: use memoization. The unsolved problem
    is that no one knows whether the function terminates for all integers (mathematical
    induction is no help because one of the recursive calls is for a larger value
    of the argument).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Brownian island.** B. Mandelbrot asked the famous question *How long is the
    coast of Britain?* Modify [Brownian.java](Brownian.java.html) to get a program
    [BrownianIsland.java](BrownianIsland.java.html) that plots [Brownian islands](http://swiss.csail.mit.edu/~rauch/islands/),
    whose coastlines resemble that of Great Britain. The modifications are simple:
    first, change `curve()` to add a random Gaussian to the *x*-coordinate as well
    as to the *y*-coordinate; second, change `main()` to draw a curve from the point
    at the center of the canvas back to itself. Experiment with various values of
    the arguments to get your program to produce islands with a realistic look.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Brownian island](../Images/d8901e2a2634b519adef94f41361a3d1.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '**Plasma clouds.** Write a recursive program [PlasmaCloud.java](PlasmaCloud.java.html)
    to draw plasma clouds, using the method suggested in the text.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![plasma clouds](../Images/b411ee84a4611aa2aea64caee2644086.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '**A strange function.** Consider [McCarthy''s 91 function](McCarthy.java.html):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Determine the value of `mcCarthy(50)` without using a computer. Give the number
    of recursive calls used by `mcCarthy()` to compute this result. Prove that the
    base case is reached for all positive integers `n` or find a value of `n` for
    which this function goes into a recursive loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Recursive tree.** Write a program [Tree.java](Tree.java.html) that takes
    a command-line argument `n` and produces the following recursive patterns for
    `n` equal to 1, 2, 3, 4, and 8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![recursive tree](../Images/a9d0bc474f1b08921a027c060c4f8620.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Does [Euclid.java](Euclid.java.html) still work if the inputs can be negative?
    If not, fix it. *Hint*: Recall that % can return a negative integer if the first
    input is negative. When calling the function, take the absolute value of both
    inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a recursive program [GoldenRatio.java](GoldenRatio.java.html) that takes
    an integer input N and computes an approximation to the [golden ratio](http://en.wikipedia.org/wiki/Golden_ratio)
    using the following recursive formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Redo, but do not use recursion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Discover a connection between the [golden ratio](http://en.wikipedia.org/wiki/Golden_ratio)
    and Fibonacci numbers. *Hint*: consider the ratio of successive Fibonacci numbers:
    2/1, 3/2, 8/5, 13/8, 21/13, 34/21, 55/34, 89/55, 144/89, ...'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the following recursive function. What is `mystery(1, 7)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Will the function in the previous exercise terminate for every pair of integers
    a and b between between 0 and 100? Give a high level description of what `mystery(a,
    b)` returns, given integers a and b between 0 and 100.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Answer*: mystery(1, 7) = 1 + mystery(1, 6) = 1 + (1 + mystery(1, 5)) = ...
    7 + mystery(1, 0) = 7.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Answer*: Yes, the base case is b = 0\. Successive recursive calls reduce b
    by 1, driving it toward the base case. The function `mystery(a, b)` returns `a
    * b`. Mathematically inclined students can prove this fact via induction using
    the identity ab = a + a(b-1).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider the following function. What does `mystery(0, 8)` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: infinite loop.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider the following function. What does `mystery(0, 8)` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: stack overflow.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Repeat the previous exercise, but replace `if (a != b)` with `if (a <= b)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `mystery(0, 8)` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following function compute?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a program [Fibonacci2.java](Fibonacci2.java.html) that takes a command-line
    argument N and prints out the first N Fibonacci numbers using the following alternate
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the biggest Fibonacci number you can compute in under a minute using
    this definition? Compare this to [Fibonacci.java](Fibonacci.java.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a program that takes a command-line argument N and prints out the first
    N Fibonacci numbers using the [following method](http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF)
    proposed by Dijkstra:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Prove by mathematical induction that the alternate definitions of the Fibonacci
    function given in the previous two exercises are equivalent to the original definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a program `Pell.java` that takes a command-line argument N and prints
    out the first N *Pell numbers*: p[0] = 0, p[1] = 1, and for n >= 2, p[n] = 2 p[n-1]
    + p[n-2]. Print out the ratio of successive terms and compare to 1 + sqrt(2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following function from program [Recursion.java](Recursion.java.html):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What does `mystery(6)` print out? *Hint*: first figure out what `mystery(2)`,
    `mystery(3)`, and so forth print out.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What would happen in the previous exercise if the base case was replaced with
    the following statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Consider the following recursive functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the value of `square(5)`? `cube(5)`? `cube(123)`?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider the following pair of mutually recursive functions. What does `g(g(2))`
    evaluate to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write program to verify that (for small values of n) the sum of the cubes of
    the first n Fibonacci numbers F(0)^3 + F(1)^3 + ... + F(n)^3 equals (F(3n+4) +
    (-1)^n * 6 * f(n-1)) / 10, where F(0) = 1, F(1) = 1, F(2) = 2, and so forth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transformations by increment and unfolding.** Given two integers a ≤ b, write
    a program [Sequence.java](Sequence.java.html) that transforms a into b by a minimum
    sequence of increment (add 1) and unfolding (multiply by 2) operations. For example,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Hadamard matrix.** Write a recursive program [Hadamard.java](Hadamard.java.html)
    that takes a command-line argument n and plots an N-by-N Hadamard pattern where
    N = 2^n. Do *not* use an array. A 1-by-1 Hadamard pattern is a single black square.
    In general a 2N-by-2N Hadamard pattern is obtained by aligning 4 copies of the
    N-by-N pattern in the form of a 2-by-2 grid, and then inverting the colors of
    all the squares in the lower right N-by-N copy. The N-by-N Hadamard H(N) matrix
    is a boolean matrix with the remarkable property that any two rows differ in exactly
    N/2 bits. This property makes it useful for designing *error-correcting codes*.
    Here are the first few Hadamard matrices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![2-by-2 Hadamard plot](../Images/3fcca04e628395438f1368818224fcfb.png) |
    ![4-by-4 Hadamard plot](../Images/4188238d690602071d30541d08ef4597.png) | ![8-by-8
    Hadamard plot](../Images/3a556cb365ae1a8ac2f806d8eb3c324d.png) | ![16-by-16 Hadamard
    plot](../Images/283b5b4b908d053de67422d52ab78ca8.png) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '**8 queens problem.** In this exercise, you will solve the classic [8-queens
    problem](http://www.acm.org/classics/dec95): place 8 queens on an 8-by-8 chess
    board so that no two queens are in the same row, column, or diagonal. There are
    8! = 40,320 ways in which no two queens are placed in the same row or column.
    Any permutation p[] of the integers 0 to 7 gives such a placement: put queen i
    in row i, column p[i]. Your program [Queens.java](Queens.java.html) should take
    an integer command-line argument n and enumerate all solutions to the n-queens
    problem by drawing the location of the queens in ASCII like the two solutions
    below.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Hint*: to determine whether setting q[n] = i conflicts with q[0] through q[n-1]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if q[i] equals q[n]: two queens are placed in the same column'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'if q[i] - q[n] equals n - i: two queens are on same major diagonal'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'if q[n] - q[i] equals n - i: two queens are on same minor diagonal'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Another 8 queens solver.** Program [Queens2.java](Queens2.java.html) solves
    the 8 queens problem by implicitly enumeration all n! permutations (instead of
    the n^n placements). It is based on program [Permutations.java](Permutations.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Euclid''s algorithm and π.** The probability that two numbers chosen from
    a large random set of numbers have no common factors (other than 1) is 6 / π².
    Use this idea to estimate π. Robert Matthews use the same idea to estimate π by
    taken the set of numbers to be a function of the positions of stars in the sky.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Towers of Hanoi variant II.** (Knuth-Graham and Pathashnik) Solve the original
    Towers of Hanoi problem, but with the extra restriction that you are not allowed
    to directly transfer a disk from A to C. How many moves does it take to solve
    a problem with n disks? *Hint*: move n-1 smallest disks from A to C recursively
    (without any direct A to C moves), move disk n from A to B, move n-1 smallest
    disks from C to A (without any direct A to C moves), move disk N from B to C,
    and move n-1 smallest disks from A to C recursively (without any direct A to C
    moves).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Towers of Hanoi variant III.** Repeat the previous question but disallow
    both A to C and C to A moves. That is, each move must involve pole B.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Towers of Hanoi with 4 pegs.** Suppose that you have a fourth peg. What is
    the least number of moves needed to transfer a stack of 8 disks from the leftmost
    peg to the rightmost peg? [Answer](http://math.smsu.edu/~les/POW01_03.html). Finding
    the shortest such solution in general has remained an open problem for over a
    hundred years and is known as *Reve''s puzzle*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Another tricky recursive function.** Consider the following recursive function.
    What is `f(0)`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Checking if n is a Fibonacci number.** Write a function to check if n is
    a Fibonacci number. *Hint*: a positive integer is a Fibonacci number if and only
    if either (5*n*n + 4) or (5*n*n - 4) is a perfect square.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random infix expression generator.** Run [RandomExpression.java](RandomExpression.java.html)
    with different command-line argument p between 0 and 1. What do you observe?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**A tricky recurrence.** Define F(n) so that F(0) = 0 and F(n) = n - F(F(n-1)).
    What is F(100000000)?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: The [answer](http://www.ocf.berkeley.edu/~wwu/cgi-bin/yabb/YaBB.cgi?board=riddles_medium;action=display;num=1065363259)
    is related to the Fibonacci sequence and the [Zeckendorf representation](http://mathworld.wolfram.com/ZeckendorfRepresentation.html)
    of a number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**von Neumann ordinal.** The *von Neumann integer* i is defined as follows:
    for i = 0, it is the empty set; for i > 0, it is the set containing the von Neumann
    integers 0 to i-1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a program [Ordinal.java](Ordinal.java.html) with a recursive function
    `vonNeumann()` that takes a nonnegative integer `N` and returns a string representation
    of the von Neumann integer N. This is a method for defining ordinals in set theory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Subsequences of a string.** Write a program [Subsequence.java](Subsequence.java.html)
    that takes a string command-line argument `s` and an integer command-line argument
    `k` and prints out all subsequences of `s` of length `k`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Interleaving two strings.** Given two strings `s` and `t` of distinct characters,
    print out all (M+N)! / (M! N!) interleavings, where M and N are the number of
    characters in the two strings. For example, if'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Binary GCD.** Write a program [BinaryGCD.java](BinaryGCD.java.html) that
    finds the greatest common divisor of two positive integers using the [binary gcd
    algorithm](http://en.wikipedia.org/wiki/Binary_GCD_algorithm): gcd(p, q) ='
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: p if q = 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: q if p = 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 * gcd(p/2, q/2) if p and q are even
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcd(p/2, q) if p is even and q is odd
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcd(p, q/2) if p is odd and q is even
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcd((p-q)/2, q) if p and q are odd and p >= q
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcd(p, (q-p)/2) if p and q are odd and p < q
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer partitions.** Write a program [Partition.java](Partition.java.html)
    that takes a positive integer N as a command-line argument and prints out all
    partitions of N. A [partition](http://en.wikipedia.org/wiki/Integer_partition)
    of N is a way to write N as a sum of positive integers. Two sums are considered
    the same if they only differ in the order of their constituent summands. Partitions
    arise in symmetric polynomials and group representation theory in mathematics
    and physics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Johnson-Trotter permutations.** Write a program [JohnsonTrotter.java](JohnsonTrotter.java.html)
    that takes an integer command-line argument n and prints all n! permutations of
    the integer 0 through n-1 in such a way that consecutive permutations differ in
    only one adjacent transposition (similar to way Gray code iterates over combinations
    in such a way that consecutive combinations differ in only one bit).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Permutations in lexicographic order.** Write a program [PermutationsLex.java](PermutationsLex.java.html)
    that take a command-line argument N and prints out all N! permutations of the
    integer 0 through N-1 in lexicographic order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Derangements.** A [derangement](http://en.wikipedia.org/wiki/Derangement)
    is a permutation `p[]` of the integers from 0 to N-1 such that p[i] doesn''t equal
    i for any i. For example there are 9 derangements when N = 4: 1032, 1230, 1302,
    2031, 2301, 2310, 3012, 3201, 3210. Write a program to count the number of derangements
    of size N using the following recurrence: d[N] = (N-1) (d[N-1] + d[N-2]), where
    d[1] = 0, d[2] = 1. The first few terms are 0, 1, 2, 9, 44, 265, 1854, 14833,
    133496, and 1334961.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tribonacci numbers.** The *tribonacci numbers* are similar to the Fibonacci
    numbers, except that each term is the sum of the three previous terms in the sequence.
    The first few terms are 0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81. Write a program to
    compute tribonacci numbers. What is the ratio successive terms? *Answer*. Root
    of x^3 - x^2 - x - 1, which is approximately 1.83929.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sum of first n Fibonacci numbers.** Prove by induction that the sum of the
    first n Fibonacci numbers F(1) + F(2) + ... + F(N) is F(N+2) - 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Combinational Gray code.** Print out all combination of k of n items in such
    a way that consecutive combinations differ in exactly one element, e.g., if k
    = 3 and n = 5, 123, 134, 234, 124, 145, 245, 345, 135, 235, 125. *Hint*: use the
    Gray code, but only print out those integers with exactly k 1''s in their binary
    representation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Maze generation.** [Create a maze](http://en.wikipedia.org/wiki/Maze_generation_algorithm)
    using divide-and-conquer: Begin with a rectangular region with no walls. Choose
    a random gridpoint in the rectangle and construct two perpendicular walls, dividing
    the square into 4 subregions. Choose 3 of the four regions at random and open
    a one cell hole at a random point in each of the 3\. Recur until each subregion
    has width or height 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Plasma clouds.** Program [PlasmaCloud.java](PlasmaCloud.java.html) takes
    a command-line argument N and produces a random N-by-N plasma fractal using the
    midpoint displacement method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Plasma Cloud 1](../Images/ec1d546e528e91882794533f70b7ae03.png) | ![Plasma
    Cloud 2](../Images/2bc93da5c14dce015352a1ae8fdf9511.png) | ![Plasma Cloud 3](../Images/906454727d634ad047c3e5049058bc0b.png)
    |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: 'Here''s an [800-by-800 example](images/plasma-big.png). Here''s a [reference](http://www.gameprogrammer.com/fractal.html),
    including a simple 1D version. Note: some visual artifacts are noticeable parallel
    to the x and y axes. Doesn''t have all of the statistical properties of 2D fractional
    Brownian motion.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Fern fractal.** Write a recursive program to draw a fern or tree, as in this
    [fern fractal demo](http://www.krazydad.com/bestiary/bestiary_fern.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integer set partition.** Use memoization to develop a program that solves
    the set partition problem for positive integer values. You may use an array whose
    size is the sum of the input values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Voting power.** John F. Banzhaf III proposed a ranking system for each coalition
    in a block voting system. Suppose party i control w[i] votes. A strict majority
    of the votes is needed to accept or reject a proposal. The [voting power](http://acm.uva.es/p/v4/435.html)
    of party i is the number of minority coalitions it can join and turn it into a
    winning majority coalition. Write a program [VotingPower.java](VotingPower.java.html)
    that takes in a list of coalition weights as command-line argument and prints
    out the voting power of each coalition. *Hint*: use [Schedule.java](Schedule.java.html)
    as a starting point.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scheduling on two parallel machines.** Program [Schedule.java](Schedule.java.html)
    takes a command-line argument N, reads in N real number of standard input, and
    partitions them into two groups so that their difference is minimized.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hofstadter–Conway $10,000 sequence.** Consider the following recursive function.
    f(n) = f(f(n-1)) + f(n-f(n-1)) for n > 2 and f(1) = f(2) = 1. Compute f(3). Write
    a Java program to compute the first 50 values of f(n) in the [Hofstadter–Conway
    $10,000 sequence](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter–Conway_$10,000_sequence).
    Use dynamic programming. This sequence has many fascinating properties and connects
    with Pascal''s triangle, the Gaussian distribution, Fibonacci numbers, and Catalan
    numbers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Running time recurrences.** Use dynamic programming to compute a table of
    values T(N), where T(N) is the solution to the following divide-and-conquer recurrence.
    T(1) = 0, T(N) = N + T(N/2) + T(N - N/2) if N > 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gas station optimization.** You are driving from Princeton to San Francisco
    in a car that gets 25 miles per gallon and has a gas tank capacity of 15 gallons.
    Along the way, there are N gas stations where you can stop for gas. Gas station
    i is d[i] miles into the trip and sells gas for p[i] dollars per gallon. If you
    stop at station i for gas, you must completely fill up your tank. Assume that
    you start with a full tank and that the d[i] are integers. Use dynamic programming
    to find a minimum cost sequence of stops.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unix diff.** The Unix `diff` program compares two files line-by-line and
    prints out places where they differ. Write a program [Diff.java](Diff.java.html)
    that reads in two files specified at the command line one line at a time, computes
    the LCS on the sequence of constituent lines of each file, and prints out any
    lines corresponding to non-matches in the LCS.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest common subsequence of 3 strings.** Given 3 strings, find the longest
    common subsequence using dynamic programming. What is the running time and memory
    usage of your algorithm?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Making change.** Given A hundred dollar bills, B fifty dollar bills, C twenty
    dollar bills, D ten dollar bills, E five dollar bills, F one dollar bills, G half-dollars,
    H quarters, I dimes, J nickels, and K pennies, determine whether it is possible
    to make change for N cents. Hint: knapsack problem. (Greedy also works.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Making change.** Suppose that you are a cashier in a strange country where
    the currency denominations are: 1, 3, 8, 16, 22, 57, 103, and 526 cents (or more
    generally d[0], d[1], ..., d[N-1]. Describe a dynamic programming algorithm to
    make change for c cents using the fewest number of coins. *Hint*: the greedy algorithm
    won''t work since the best way to change 114 cents is 57 + 57 instead of 103 +
    8 + 3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest increasing sequence.** Given an array of N 64-bit integers, find
    the longest subsequence that is strictly increasing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint.* Compute the longest common subsequence between the original array and
    a sorted version of the array where duplicate copies of an integer are removed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Longest common increasing sequence.** Computational biology. Given two sequences
    of N 64-bit integers, find the longest increasing subsequence that is common to
    both sequences.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Activity selection with profits.** Job i has start time s_i, finish time
    f_i and profit p_i. Find best subset of jobs to schedule.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Diff.** Write a program that reads in two files and prints out their diff.
    Treat each line as a symbol and compute an LCS. Print out those lines in each
    file that aren''t in the LCS.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Knapsack problem.** [Knapsack.java](Knapsack.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text justification.** Write a program that takes a command line argument
    N, reads text from standard input, and prints out the text, formatted nicely with
    at most N characters per line. Use dynamic programming.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Viterbi algorithm.** Given a directed graph where each edge is labeled with
    a symbol from a finite alphabet. Is there a path from one distinguished vertex
    x that matches the characters in the string s? Dynamic programming. A(i, v) =
    0 or 1 if there is a path from x to v that consumes the first i characters of
    s. A(i, v) = max (A(i-1, u) : (u, v) in E labeled with s[i]).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Viterbi algorithm.** Speech recognition, handwriting analysis, computational
    biology, hidden Markov models. Suppose each edge leaving v has a probability p(v,
    w) of being traversed. Probability of a path is the product of the probability
    on that path. What is most probable path? Dynamic programming.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Smith–Waterman algorithm.** Local sequence alignment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Binomial coefficients (brute-force).** The [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient)
    C(n, k) is the number of ways of choosing a subset of k elements from a set of
    n elements. It arises in probability and statistics. One formula for computing
    binomial coefficients is C(n, k) = n! / (k! (n-k)!). This formula is not so amenable
    to direct computation because the intermediate results may overflow, even if the
    final answer does not. For example C(100, 15) = 253338471349988640 fits in a 64-bit
    `long`, but the binary representation of 100! is 525 bits long.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Pascal''s identity* expresses C(n, k) in terms of smaller binomial coefficients:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Pascal''s identity](../Images/eede25bdbac3b755a5e4cdaea2743275.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[SlowBinomial.java](SlowBinomial.java.html) fails spectacularly for medium
    n or k, not because of overflow, but rather because the same subproblems are solved
    repeatedly.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Binomial coefficients (dynamic programming).** Write a program [Binomial.java](Binomial.java.html)
    that takes two command-line arguments *n* and *k* and uses bottom-up dynamic programming
    to compute *C*(*n*, *k*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
