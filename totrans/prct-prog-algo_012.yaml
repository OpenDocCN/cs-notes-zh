- en: 2.3   Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3   递归
- en: 原文：[https://introcs.cs.princeton.edu/java/23recursion](https://introcs.cs.princeton.edu/java/23recursion)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/23recursion](https://introcs.cs.princeton.edu/java/23recursion)
- en: The idea of calling one function from another immediately suggests the possibility
    of a function calling *itself*. The function-call mechanism in Java supports this
    possibility, which is known as *recursion*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个函数调用一个函数的想法立即暗示了函数调用*自身*的可能性。Java中的函数调用机制支持这种可能性，这被称为*递归*。
- en: Your first recursive program.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的第一个递归程序。
- en: The "Hello, World" for recursion is the *factorial* function, which is defined
    for positive integers *n* by the equation
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的“Hello, World”是*阶乘*函数，它由正整数*n*的方程式定义
- en: $$n! = n \times (n-1) \times (n-2) \times \; \ldots \; \times 2 \times 1$$
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$n! = n \times (n-1) \times (n-2) \times \; \ldots \; \times 2 \times 1$$
- en: 'The quantity *n*! is easy to compute with a `for` loop, but an even easier
    method in [Factorial.java](Factorial.java.html) is to use the following recursive
    function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数量*n*!可以通过`for`循环轻松计算，但在[Factorial.java](Factorial.java.html)中更简单的方法是使用以下递归函数：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can trace this computation in precisely the same way that we trace any sequence
    of function calls.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与跟踪任何函数调用序列相同的方式跟踪此计算。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `factorial()` implementation exhibits the two main components that are required
    for every recursive function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`factorial()`实现展示了每个递归函数所需的两个主要组成部分。
- en: The *base case* returns a value without making any subsequent recursive calls.
    It does this for one or more special input values for which the function can be
    evaluated without recursion. For `factorial()`, the base case is *n* = 1.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况* 在不进行任何后续递归调用的情况下返回一个值。它为一个或多个特殊输入值提供了函数可以在没有递归的情况下进行评估的值。对于`factorial()`，基本情况是*n*
    = 1。'
- en: The *reduction step* is the central part of a recursive function. It relates
    the value of the function at one (or more) input values to the value of the function
    at one (or more) other input values. Furthermore, the sequence of input values
    values must *converge* to the base case. For `factorial()`, the value of *n* decreases
    by 1 for each call, so the sequence of input values converges to the base case.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少步骤* 是递归函数的核心部分。它将一个（或多个）输入值处函数的值与另一个（或多个）输入值处函数的值联系起来。此外，输入值序列必须*收敛*到基本情况。对于`factorial()`，*n*的值每次调用都减少1，因此输入值序列收敛到基本情况。'
- en: Mathematical induction.
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学归纳法。
- en: 'Recursive programming is directly related to *mathematical induction*, a technique
    for proving facts about natural numbers. Proving that a statement involving an
    integer *n* is true for infinitely many values of *n* by mathematical induction
    involves the following two steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 递归编程与*数学归纳法*直接相关，数学归纳法是一种证明关于自然数的事实的技术。通过数学归纳法证明涉及整数*n*的语句对于无限多个*n*值为真涉及以下两个步骤：
- en: 'The *base case*: prove the statement true for some specific value or values
    of *n* (usually 0 or 1).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况*：证明某些特定值或值的*n*（通常为0或1）为真。'
- en: 'The *induction step*: assume that the statement to be true for all positive
    integers less than *n*, then use that fact to prove it true for *n*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*归纳步骤*：假设对于所有小于*n*的正整数该语句为真，然后使用该事实证明对于*n*为真。'
- en: 'Such a proof suffices to show that the statement is true for *infinitely* many
    values of *n*: we can start at the base case, and use our proof to establish that
    the statement is true for each larger value of *n*, one by one.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的证明足以表明该语句对于*无限*多个*n*值为真：我们可以从基本情况开始，并使用我们的证明逐个为每个更大的*n*值证明该语句为真。
- en: Euclid's algorithm.
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧几里得算法。
- en: The *greatest common divisor* (gcd) of two positive integers is the largest
    integer that divides evenly into both of them. For example, the gcd(102, 68) =
    34.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 两个正整数的*最大公约数*（gcd）是能够均匀整除它们的最大整数。例如，gcd(102, 68) = 34。
- en: 'We can efficiently compute the gcd using the following property, which holds
    for positive integers *p* and *q*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下性质高效地计算最大公约数gcd，该性质对正整数*p*和*q*成立：
- en: If *p* > *q*, the gcd of *p* and *q* is the same as the gcd of *q* and *p* %
    *q*.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果*p* > *q*，则*p*和*q*的gcd与*q*和*p* % *q*的gcd相同。
- en: The static method `gcd()` in [Euclid.java](Euclid.java.html) is a compact recursive
    function whose reduction step is based on this property.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[Euclid.java](Euclid.java.html)中的静态方法`gcd()`是一个紧凑的递归函数，其减少步骤基于此性质。'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Towers of Hanoi.
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汉诺塔。
- en: '![recursive solution to towers of Hanoi](../Images/cfd21be7f571fbaf9be2c807be2f5a42.png)
    In the *towers of Hanoi* problem, we have three poles and *n* discs that fit onto
    the poles. The discs differ in size and are initially stacked on one of the poles,
    in order from largest (disc *n*) at the bottom to smallest (disc 1) at the top.
    The task is to move all *n* discs to another pole, while obeying the following
    rules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![汉诺塔的递归解法](../Images/cfd21be7f571fbaf9be2c807be2f5a42.png) 在*汉诺塔*问题中，我们有三根杆和*n*个可以放在杆上的圆盘。这些圆盘大小不同，最初堆叠在一根杆上，从最大的圆盘*n*（底部）到最小的圆盘1（顶部）。任务是将所有*n*个圆盘移动到另一根杆上，同时遵守以下规则：'
- en: Move only one disc at a time.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只移动一个圆盘。
- en: Never place a larger disc on a smaller one.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将一个较大的圆盘放在一个较小的圆盘上。
- en: 'Recursion provides just the plan that we need: First we move the top *n*−1
    discs to an empty pole, then we move the largest disc to the other empty pole,
    then complete the job by moving the *n*−1 discs onto the largest disc. [TowersOfHanoi.java](TowersOfHanoi.java.html)
    is a direct implementation of this strategy.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 递归提供了我们需要的计划：首先将顶部的*n*−1个圆盘移动到一个空柱子上，然后将最大的圆盘移动到另一个空柱子上，然后通过将*n*−1个圆盘移动到最大的圆盘上来完成工作。[TowersOfHanoi.java](TowersOfHanoi.java.html)是这种策略的直接实现。
- en: Exponential time.
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数时间。
- en: '![exponential growth](../Images/9a3e349ca4c3b79eb5c0be843fa36bbe.png)  Let
    T(*n*) be the number of move directives issued by [TowersOfHanoi.java](TowersOfHanoi.java.html)
    to move *n* discs from one peg to another. Then, T(*n*) must satisfy the following
    equation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![指数增长](../Images/9a3e349ca4c3b79eb5c0be843fa36bbe.png)  设T(*n*)是[TowersOfHanoi.java](TowersOfHanoi.java.html)发出的移动指令数量，用于将*n*个圆盘从一个柱子移动到另一个柱子。那么，T(*n*)必须满足以下方程：'
- en: $$T(n) = 2T(n-1) + 1 \text{ for } n > 1, \text{ with } T(1) = 1$$
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$T(n) = 2T(n-1) + 1 \text{ for } n > 1, \text{ with } T(1) = 1$$
- en: Such an equation is known in discrete mathematics as a *recurrence relation*.
    We can often use them to derive a closed-form expression for the quantity of interest.
    For example, T(1) = 1, T(2) = 3, T(3) = 7, and T(4) = 15. In general, T(*n*) =
    2^(*n*) − 1. Assuming the monks move discs at the rate of one per second, it would
    take them more 5.8 billion centuries to solve the 64-disc problem.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的方程在离散数学中被称为*递归关系*。我们经常可以使用它们来推导出所关注的数量的闭合形式表达式。例如，T(1) = 1, T(2) = 3, T(3)
    = 7, T(4) = 15。一般来说，T(*n*) = 2^(*n*) − 1。假设僧侣们每秒移动一个圆盘，他们需要超过58亿个世纪才能解决64个圆盘问题。
- en: Gray code.
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格雷码。
- en: 'An *n*-bit *Gray code* is a list of the 2^(*n*) different *n*-bit binary numbers
    such that each entry in the list differs in precisely one bit from its predecessor.
    The *n* bit binary reflected Gray code is defined recursively as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*位*格雷码*是2^(*n*)个不同的*n*位二进制数的列表，使得列表中的每个条目与其前一个条目在恰好一个位上不同。*n*位二进制反射格雷码的定义如下：'
- en: the *n*−1 bit code, with 0 prepended to each word, followed by
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*−1位编码，每个单词前面加0，然后是'
- en: the *n*−1 bit code in reverse order, with 1 prepended to each word.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*−1位编码按相反顺序排列，每个单词前面加1。'
- en: The 0-bit code is defined to be null, so the 1-bit code is 0 followed by 1\.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 0位编码被定义为空，因此1位编码是0后跟1\。
- en: '|                | ![Gray code representations](../Images/3c1deb8434d454058bc18cb9902f75c7.png)
    |                | ![2-, 3-, and 4-bit Gray codes](../Images/47f120f9f06757e65cb89ad050cc63c9.png)
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|                | ![格雷码表示](../Images/3c1deb8434d454058bc18cb9902f75c7.png)
    |                | ![2位、3位和4位格雷码](../Images/47f120f9f06757e65cb89ad050cc63c9.png)
    |'
- en: '[Beckett.java](Beckett.java.html) uses an *n*-bit Gray code to print stage
    directions for an *n*-character play in such a way that characters enter and exit
    one at a time so that each subset of characters on the stage appears exactly once.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[Beckett.java](Beckett.java.html)使用*n*位格雷码打印舞台指令，用于*n*个字符的戏剧，使得角色一个接一个地进入和退出，以便舞台上的每个角色子集恰好出现一次。'
- en: Recursive graphics.
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归图形。
- en: 'Simple recursive drawing schemes can lead to pictures that are remarkably intricate.
    For example, an *H-tree of order n* is defined as follows: The base case is null
    for *n* = 0\. The reduction step is to draw, within the unit square three lines
    in the shape of the letter H four H-trees of order *n* − 1, one connected to each
    tip of the H with the additional provisos that the H-trees of order *n* − 1 are
    centered in the four quadrants of the square, halved in size.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的递归绘图方案可能导致非常复杂的图片。例如，*n*阶*H树*的定义如下：当*n* = 0时，基本情况为空。减少步骤是在形状为字母H的单位正方形内绘制三条线，四个*n*
    − 1阶H树，每个H树与H的每个尖端连接，附加条件是*n* − 1阶H树位于正方形的四个象限中心，尺寸减半。
- en: '| ![htree 1](../Images/abddc8550d2dd3f1ffb21f40d53ccdea.png) | ![htree 2](../Images/382562bcb3194374b999bcfec7559b78.png)
    | ![htree 3](../Images/a252015aa78d10438ecbd0e78bc58586.png) | ![htree 4](../Images/b42a26c1155077a1c093b8c4b6eb604a.png)
    | ![htree 5](../Images/85518097da4a973f47ae85df69cef073.png) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ![htree 1](../Images/abddc8550d2dd3f1ffb21f40d53ccdea.png) | ![htree 2](../Images/382562bcb3194374b999bcfec7559b78.png)
    | ![htree 3](../Images/a252015aa78d10438ecbd0e78bc58586.png) | ![htree 4](../Images/b42a26c1155077a1c093b8c4b6eb604a.png)
    | ![htree 5](../Images/85518097da4a973f47ae85df69cef073.png) |'
- en: '[Htree.java](Htree.java.html) takes a command-line argument *n*, and plots
    to standard drawing an H-tree of order *n*. An H-tree is a simple example of a
    *fractal*: a geometric shape that can be divided into parts, each of which is
    (approximately) a reduced size copy of the original.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[Htree.java](Htree.java.html)接受一个命令行参数*n*，并绘制一个*n*阶H树到标准绘图。H树是*分形*的一个简单示例：一个几何形状，可以被分成部分，每个部分（大致）是原始形状的缩小副本。'
- en: Brownian bridge.
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布朗桥。
- en: '[Brownian.java](Brownian.java.html) produces a function graph that approximates
    a simple example of fractional Brownian motion known as *Brownian bridge*. You
    can think of this graph as a random walk that connects the two points (*x*[0],
    *y*[0]) and (*x*[1], *y*[1]), controlled by a few parameters. The implementation
    is based on the *midpoint displacement method*, which is a recursive plan for
    drawing the plot within the *x*-interval [*x*[0], *x*[1]]. The base case (when
    the size of the interval is smaller than a given tolerance) is to draw a straight
    line connecting the two endpoints. The reduction case is to divide the interval
    into two halves, proceeding as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[Brownian.java](Brownian.java.html)生成一个函数图，近似于称为*布朗桥*的分数布朗运动的简单示例。您可以将这个图形看作是连接两个点（*x*[0],
    *y*[0])和（*x*[1], *y*[1])的随机行走，由几个参数控制。该实现基于*中点位移法*，这是一个递归绘制绘图的计划，位于*x*区间[*x*[0],
    *x*[1]]内。基本情况（当间隔的大小小于给定的容差时）是绘制连接两个端点的直线。减少情况是将间隔分成两半，然后继续如下操作：'
- en: Compute the midpoint (*x[m]*, *y[m]*) of the interval.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算间隔的中点（*x[m]*，*y[m]*）。
- en: Add to the *y*-coordinate *y[m]* of the midpoint a random value δ, drawn from
    the Gaussian distribution with mean 0 and a given variance.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将中点的*y*坐标*y[m]*增加一个从均值为0且给定方差的高斯分布中抽取的随机值δ。
- en: Recur on the subintervals, dividing the variance by a given scaling factor *s*.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子间隔上进行递归，通过给定的缩放因子*s*来减少方差。
- en: 'The shape of the curve is controlled by two parameters: the *volatility* (initial
    value of the variance) controls the distance the graph strays from the straight
    line connecting the points, and the *Hurst exponent* controls the smoothness of
    the curve.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的形状由两个参数控制：*波动性*（方差的初始值）控制图形偏离连接点的直线的距离，*赫斯特指数*控制曲线的平滑度。
- en: '|       | ![Brownian bridge](../Images/703e09db2d0eed077c43d617d778936b.png)
    |       | ![Brownian with H = 0.5](../Images/2a37e7191a15e3ce6bcf03c3bdd8c142.png)
    |       | ![Brownian with H = 0.05](../Images/cdc3430903174f36959472db9acf4370.png)
    |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       | ![布朗桥](../Images/703e09db2d0eed077c43d617d778936b.png) |       |
    ![H = 0.5的布朗运动](../Images/2a37e7191a15e3ce6bcf03c3bdd8c142.png) |       | ![H
    = 0.05的布朗运动](../Images/cdc3430903174f36959472db9acf4370.png) |'
- en: Pitfalls of recursion.
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归的陷阱。
- en: With recursion, you can write compact and elegant programs that fail spectacularly
    at runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归，你可以编写简洁而优雅的程序，在运行时却失败得令人瞠目结舌。
- en: '*Missing base case.* The recursive function in [NoBaseCase.java](NoBaseCase.java.html)
    is supposed to compute harmonic numbers, but is missing a base case:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺少基本情况。* [NoBaseCase.java](NoBaseCase.java.html)中的递归函数应该计算调和数，但缺少一个基本情况：'
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you call this function, it will repeatedly call itself and never return.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果调用这个函数，它将不断调用自身而永远不会返回。
- en: '*No guarantee of convergence.* Another common problem is to include within
    a recursive function a recursive call to solve a subproblem that is not smaller
    than the original problem. For example, the recursive function in [NoConvergence.java](NoConvergence.java.html)
    goes into an infinite recursive loop for any value of its argument (except 1).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*��有收敛的保证。* 另一个常见问题是在递归函数中包含一个递归调用来解决一个不比原问题更小的子问题。例如，[NoConvergence.java](NoConvergence.java.html)中的递归函数对于其参数的任何值（除了1）都会进入无限递归循环。'
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Excessive memory requirements.* If a function calls itself recursively an
    excessive number of times before returning, the memory required by Java to keep
    track of the recursive calls may be prohibitive. The recursive function in [ExcessiveMemory.java](ExcessiveMemory.java.html)
    correctly computes the nth harmonic number. However, calling it with a huge value
    of `n` will lead to a `StackOverflowError`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过度内存需求。* 如果一个函数在返回之前递归调用自身过多次数，Java需要的内存来跟踪递归调用可能是不可接受的。[ExcessiveMemory.java](ExcessiveMemory.java.html)中的递归函数正确计算第n个调和数。然而，用一个巨大的`n`值调用它将导致`StackOverflowError`。'
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Excessive recomputation.* ![Wrong way to compute Fibonacci numbers](../Images/111e822a28258fd755ae5d63d1003bed.png)
    The temptation to write a simple recursive program to solve a problem must always
    be tempered by the understanding that a simple program might require exponential
    time (unnecessarily), due to excessive recomputation. For example, the Fibonacci
    sequence'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过度重复计算。* ![计算斐波那契数的错误方法](../Images/111e822a28258fd755ae5d63d1003bed.png) 写一个简单的递归程序解决问题的诱惑必须始终受到这样的理解的限制，即简单程序可能需要指数时间（不必要地），因为存在过度重复计算。例如，斐波那契数列'
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...
- en: is defined by the formula
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由公式定义
- en: $$F_n = F_{n-1} + F_{n-2} \text{ for } n \ge 2, \text{ with } F_0 = 0 \text{
    and } F_1 = 1$$
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$F_n = F_{n-1} + F_{n-2} \text{ for } n \ge 2, \text{ with } F_0 = 0 \text{
    and } F_1 = 1$$
- en: 'A novice programmer might implement this recursive function to compute numbers
    in the Fibonacci sequence, as in [Fibonacci.java](Fibonacci.java.html):'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个初学者程序员可能会实现这个递归函数来计算斐波那契数列中的数字，就像[Fibonacci.java](Fibonacci.java.html)中所示的那样：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, this program is spectacularly inefficient! To see why it is futile
    to do so, consider what the function does to compute `fibonacci(8) = 21`. It first
    computes `fibonacci(7) = 13` and `fibonacci(6) = 8`. To compute `fibonacci(7)`,
    it recursively computes `fibonacci(6) = 8` *again* and `fibonacci(5) = 5`. Things
    rapidly get worse. The number of times this program computes `fibonacci(1)` when
    computing `fibonacci(n)` is precisely *F*[*n*].
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这个程序效率极低！要看出为什么这样做是徒劳的，考虑一下这个函数如何计算`fibonacci(8) = 21`。它首先计算`fibonacci(7)
    = 13`和`fibonacci(6) = 8`。为了计算`fibonacci(7)`，它递归计算`fibonacci(6) = 8` *再次*和`fibonacci(5)
    = 5`。事情迅速变得更糟。这个程序在计算`fibonacci(n)`时计算`fibonacci(1)`的次数恰好是*F*[*n*]。
- en: Dynamic programming.
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态规划。
- en: A general approach to implementing recursive programs, The basic idea of *dynamic
    programming* is to recursively divide a complex problem into a number of simpler
    subproblems; store the answer to each of these subproblems; and, ultimately, use
    the stored answers to solve the original problem. By solving each subproblem only
    once (instead of over and over), this technique avoids a potential exponential
    blow-up in the running time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实现递归程序的一般方法，*动态规划*的基本思想是将一个复杂问题递归地分解为若干较简单的子问题；存储每个子问题的答案；最终使用存储的答案来解决原始问题。通过仅解决每个子问题一次（而不是一遍又一遍），这种技术避免了运行时间的潜在指数级增长。
- en: '*Top-down dynamic programming.* In *top-down* dynamic programming, we store
    or *cache* the result of each subproblem that we solve, so that the next time
    we need to solve the same subproblem, we can use the cached values instead of
    solving the subproblem from scratch. [TopDownFibonacci.java](TopDownFibonacci.java.html)
    illustrates top-down dynamic programming for computing Fibonacci numbers.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自顶向下动态规划。* 在*自顶向下*动态规划中，我们存储或*缓存*我们解决的每个子问题的结果，这样下次我们需要解决相同的子问题时，我们可以使用缓存的值而不是从头开始解决子问题。[TopDownFibonacci.java](TopDownFibonacci.java.html)演示了用于计算斐波那契数的自顶向下动态规划。'
- en: '![top-down dynamic programming](../Images/d2f1a08b69aef188f5b217fd2f65428f.png)'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![自顶向下动态规划](../Images/d2f1a08b69aef188f5b217fd2f65428f.png)'
- en: '*Bottom-up dynamic programming.* In *bottom-up* dynamic programming, we compute
    solutions to all of the subproblems, starting with the “simplest” subproblems
    and gradually building up solutions to more and more complicated subproblems.
    [BottomUpFibonacci.java](BottomUpFibonacci.java.html) illustrates bottom-up dynamic
    programming for computing Fibonacci numbers.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自底向上动态规划。* 在*自底向上*动态规划中，我们计算所有子问题的解，从“最简单”的子问题开始，逐渐构建更复杂子问题的解。[BottomUpFibonacci.java](BottomUpFibonacci.java.html)演示了用于计算斐波那契数的自底向上动态规划。'
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Longest common subsequence problem.* Given two strings *x* and *y*, we wish
    to compute their <em.longest common="" subsequence="">(LCS). If we delete some
    characters from *x* and some characters from *y*, and the resulting two strings
    are equal, we call the resulting string a *common subsequence*. The LCS problem
    is to find a common subsequence of two strings that is as long as possible. For
    example, the LCS of `GGCACCACG` and `ACGGCGGATACG` is `GGCAACG`, a string of length
    7.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最长公共子序列问题。* 给定两个字符串*x*和*y*，我们希望计算它们的<em.longest common="" subsequence="">(LCS)。如果我们从*x*中删除一些字符，从*y*中删除一些字符，得到的两个字符串相等，我们称结果字符串为*公共子序列*。LCS问题是找到两个字符串的一个尽可能长的公共子序列。例如，`GGCACCACG`和`ACGGCGGATACG`的LCS是`GGCAACG`，一个长度为7的字符串。'
- en: '[PRE8]</em.longest>'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE8]</em.longest>'
- en: '*Longest common subsequence recurrence.* Now we describe a recursive formulation
    that enables us to find the LCS of two given strings `s` and `t`. Let `m` and
    `n` be the lengths of `s` and `t`, respectively. We use the notation `s[i..m)`
    to denote the *suffix* of `s` starting at index `i`, and `t[j..n)` to denote the
    suffix of `t` starting at index `j`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最长公共子序列递归。* 现在我们描述一个递归公式，使我们能够找到给定字符串`s`和`t`的LCS。设`m`和`n`分别为`s`和`t`的长度。我们使用符号`s[i..m)`表示`s`从索引`i`开始的*后缀*，使用`t[j..n)`表示从索引`j`开始的`t`的后缀。'
- en: If `s` and `t` begin with the same character, then the LCS of `s` and `t` contains
    that first character. Thus, our problem to reduces to finding the LCS of the suffixes
    `s[1..m)` and `t[1..n)`.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`s`和`t`以相同字符开头，则`s`和`t`的LCS包含该第一个字符。因此，我们的问题简化为找到后缀`s[1..m)`和`t[1..n)`的LCS。
- en: If `s` and `t` begin with different characters, both characters cannot be part
    of a common subsequence, so can safely discard one or the other. In either case,
    the problem reduces to finding the LCS of two strings—either `s[0..m)` and `t[1..n)`
    or `s[1..m)` and `t[0..n)`.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`s`和`t`以不同字符开头，则两个字符都不能成为公共子序列的一部分，因此可以安全地丢弃其中一个。在任何一种情况下，问题都简化为找到两个字符串的LCS——要么`s[0..m)`和`t[1..n)`，要么`s[1..m)`和`t[0..n)`。
- en: 'In general, if we let `opt[i][j]` denote the length of the LCS of the suffixes
    `s[i..m)` and `t[j..n)`, then the following recurrence holds:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一般来说，如果我们让`opt[i][j]`表示后缀`s[i..m)`和`t[j..n)`的LCS的长度，则以下递归成立：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Dynamic programming solution.* [LongestCommonSubsequence.java](LongestCommonSubsequence.java.html)
    begins with a bottom-up dynamic programming approach to solving this recurrence.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态规划解决方案。*[LongestCommonSubsequence.java](LongestCommonSubsequence.java.html)从底向上的动态规划方法开始解决这个递归。'
- en: '![longest common subsequence](../Images/83212e1903cc0be5ecb7da3f7c2322a1.png)'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![最长公共子序列](../Images/83212e1903cc0be5ecb7da3f7c2322a1.png)'
- en: 'The final challenge is to recover the longest common subsequence itself, not
    just its length. The key idea is to retrace the steps of the dynamic programming
    algorithm *backward*, rediscovering the path of choices (highlighted in gray in
    the diagram) from `opt[0][0]` to `opt[m][n]`. To determine the choice that led
    to `opt[i][j]`, we consider the three possibilities:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终挑战是恢复最长公共子序列本身，而不仅仅是其长度。关键思想是*向后*重新跟踪动态规划算法的步骤，从`opt[0][0]`到`opt[m][n]`重新发现选择路径（在图中用灰色突出显示）。为了确定导致`opt[i][j]`的选择，我们考虑三种可能性：
- en: '`The character s[i]` matches `t[j]`. In this case, we must have `opt[i][j]`
    = `opt[i+1][j+1]` + 1, and the next character in the LCS is `s[i]`. We continue
    tracing back from `opt[i+1][j+1]`.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符s[i]`匹配`t[j]`。在这种情况下，我们必须有`opt[i][j]` = `opt[i+1][j+1]` + 1，并且LCS中的下一个字符是`s[i]`。我们继续从`opt[i+1][j+1]`回溯。'
- en: The LCS does not contain `s[i]`. In this case, `opt[i][j]` = `opt[i+1][j]` and
    we continue tracing back from `opt[i+1][j]`.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LCS 不包含`s[i]`。在这种情况下，`opt[i][j]` = `opt[i+1][j]`，我们继续从`opt[i+1][j]`回溯。
- en: The LCS does not contain `t[j]`. In this case, `opt[i][j]` = `opt[i][j+1]` and
    we continue tracing back from `opt[i][j+1]`.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LCS 不包含`t[j]`。在这种情况下，`opt[i][j]` = `opt[i][j+1]`，我们继续从`opt[i][j+1]`回溯。
- en: Exercises
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Given four positive integers `a`, `b`, `c`, and `d`, explain what value is computed
    by `gcd(gcd(a, b), gcd(c, d))`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定四个正整数`a`、`b`、`c`和`d`，解释`gcd(gcd(a, b), gcd(c, d))`计算的值是什么。
- en: '*Solution*: the greatest common divisor of `a`, `b`, `c`, and `d`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：`a`、`b`、`c`和`d`的最大公约数。'
- en: Explain in terms of integers and divisors the effect of the following Euclid-like
    function.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用整数和除数的术语解释以下类似于欧几里得函数的效果。
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Solution*: Returns whether `p` and `q` are relatively prime.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：返回`p`和`q`是否互质。'
- en: Consider the following recursive function.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下递归函数。
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What are the values of `mystery(2, 25)` and `mystery(3, 11)`? Given positive
    integers `a` and `b`, describe what value `mystery(a, b)` computes. Answer the
    same question, but replace `+` with `*` and replace `return 0` with `return 1`.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mystery(2, 25)`和`mystery(3, 11)`的值是多少？给定正整数`a`和`b`，描述`mystery(a, b)`计算的值。用`*`替换`+`，用`return
    1`替换`return 0`后，回答相同的问题。'
- en: '*Solution*: 50 and 33\. It computes a*b. If you replace `+` with `*`, it computes
    a^b.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：50和33。它计算a*b。如果你用`*`替换`+`，它计算a^b。'
- en: Write a program [AnimatedHtree.java](AnimatedHtree.java.html) that animates
    the drawing of the H-tree.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[AnimatedHtree.java](AnimatedHtree.java.html)，用于动画绘制H树。
- en: '![Animated H-tree](../Images/5e790e385991e808af1b9269d960aeef.png)'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![动画H树](../Images/5e790e385991e808af1b9269d960aeef.png)'
- en: Next, rearrange the order of the recursive calls (and the base case), view the
    resulting animation, and explain each outcome.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，重新排列递归调用的顺序（和基本情况），查看生成的动画，并解释每个结果。
- en: Creative Exercises
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Binary representation.** Write a program [IntegerToBinary.java](IntegerToBinary.java.html)
    that takes a positive integer *n* (in decimal) as a command-line argument and
    prints its binary representation. Recall, in [Binary.java](.../13loops/Binary.java.html),
    we used the method of subtracting out powers of 2\. Now, use the following simpler
    method: repeatedly divide 2 into *n* and read the remainders backwards. First,
    write a `while` loop to carry out this computation and print the bits in the wrong
    order. Then, use recursion to print the bits in the correct order.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二进制表示。** 编写一个程序[IntegerToBinary.java](IntegerToBinary.java.html)，以十进制正整数*n*作为命令行参数，并打印其二进制表示。回想一下，在[Binary.java](.../13loops/Binary.java.html)中，我们使用了减去2的幂的方法。现在，使用以下更简单的方法：重复地将2除以*n*，并倒序读取余数。首先，编写一个`while`循环来执行这个计算并以错误顺序打印位。然后，使用递归以正确顺序打印位。'
- en: '**Permutations.** Write a program [Permutations.java](Permutations.java.html)
    that take an integer command-line argument *n* and prints all <m>n! permutations
    of the *n* letters starting at `a` (assume that *n* is no greater than 26). A
    *permutation* of *n* elements is one of the *n*! possible orderings of the elements.
    As an example, when *n* = 3 you should get the following output (but do not worry
    about the order in which you enumerate them):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列。** 编写一个程序 [Permutations.java](Permutations.java.html)，接受一个整数命令行参数 *n*，并打印出以
    `a` 开头的 *n* 个字母的 *n*! 排列。*n* 元素的排列是元素的 *n*! 种可能排序之一。例如，当 *n* = 3 时，您应该得到以下输出（但不必担心枚举它们的顺序）：'
- en: '[PRE12]</m>'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE12]</m>'
- en: '**Permutations of size k.** Write a program [PermutationsK.java](PermutationsK.java.html)
    that two command-line arguments *n* and *k*, and prints out all \(P(n, k) = \frac{n!}{(n-k)!}\)
    permutations that contain exactly *k* of the *n* elements. Below is the desired
    output when *k* = 2 and *n* = 4 (again, do not worry about the order):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大小为 k 的排列。** 编写一个程序 [PermutationsK.java](PermutationsK.java.html)，接受两个命令行参数
    *n* 和 *k*，并打印出包含恰好 *k* 个 *n* 元素的排列的数量 \(P(n, k) = \frac{n!}{(n-k)!}\)。当 *k* =
    2 且 *n* = 4 时，以下是期望的输出（再次，不必担心顺序）：'
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Combinations.** Write a program [Combinations.java](Combinations.java.html)
    that takes an integer command-line argument *n* and prints all 2^(*n*) *combinations*
    of any size. A *combination* is a subset of the *n* elements, independent of order.
    As an example, when *n* = 3, you should get the following output:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组合。** 编写一个程序 [Combinations.java](Combinations.java.html)，接受一个整数命令行参数 *n*，并打印出任意大小的
    2^(*n*) *组合*。*组合* 是 *n* 元素的子集，与顺序无关。例如，当 *n* = 3 时，您应该得到以下输出：'
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that your program needs to print the empty string (subset of size 0).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，您的程序需要打印空字符串（大小为 0 的子集）。
- en: '**Combinations of size k.** Write a program [CombinationsK.java](CombinationsK.java.html)
    that takes two command-line arguments *n* and *k*, and prints all \(C(n, k) =
    \frac{n!}{k! (n-k)!}\) combinations of size *k*. For example, when *n* = 5 and
    *k* = 3, you should get the following output:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大小为 k 的组合。** 编写一个程序 [CombinationsK.java](CombinationsK.java.html)，接受两个命令行参数
    *n* 和 *k*，并打印出大小为 *k* 的组合的数量 \(C(n, k) = \frac{n!}{k! (n-k)!}\)。例如，当 *n* = 5 且
    *k* = 3 时，您应该得到以下输出：'
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternate solution using arrays instead of strings: [Comb2.java](Comb2.java.html).'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用数组而不是字符串的替代解决方案：[Comb2.java](Comb2.java.html)。
- en: '**Recursive squares.** Write a program to produce each of the following recursive
    patterns. The ratio of the sizes of the squares is 2.2:1. To draw a shaded square,
    draw a filled gray square, then an unfilled black square.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**递归方块。** 编写一个程序来生成以下递归图案。方块大小的比例为 2.2:1。要绘制阴影方块，请先绘制填充的灰色方块，然后是未填充的黑色方块。'
- en: '![recursive squares](../Images/cbb67867af17c3b55d47068e21c99349.png)'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![递归方块](../Images/cbb67867af17c3b55d47068e21c99349.png)'
- en: '[RecursiveSquares.java](RecursiveSquares.java.html) gives a solution to the
    first pattern.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[RecursiveSquares.java](RecursiveSquares.java.html) 提供了第一个模式的解决方案。'
- en: '**Gray code.** Modify [Beckett.java](Beckett.java.html) to print the Gray code
    (not just the sequence of bit positions that change).'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**格雷码。** 修改 [Beckett.java](Beckett.java.html) 以打印格雷码（而不仅仅是变化的位位置序列）。'
- en: '*Solution*: [GrayCode.java](GrayCode.java.html) uses Java''s string data type;
    [GrayCodeArray.java](GrayCodeArray.java.html) uses a boolean array.'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[GrayCode.java](GrayCode.java.html) 使用了 Java 的字符串数据类型；[GrayCodeArray.java](GrayCodeArray.java.html)
    使用了布尔数组。'
- en: '**Animated towers of Hanoi animation.** Write a program [AnimatedHanoi.java](AnimatedHanoi.java.html)
    that uses `StdDraw` to animate a solution to the towers of Hanoi problem, moving
    the discs at a rate of approximately 1 per second.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汉诺塔动画。** 编写一个程序 [AnimatedHanoi.java](AnimatedHanoi.java.html)，使用 `StdDraw`
    来动画显示解决汉诺塔问题的过程，每秒移动一个盘子。'
- en: '**Collatz function.** Consider the following recursive function in [Collatz.java](Collatz.java.html),
    which is related to a famous unsolved problem in number theory, known as the [Collatz
    problem](http://mathworld.wolfram.com/CollatzProblem.html) or the *3n + 1 problem*.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Collatz 函数。** 考虑以下递归函数 [Collatz.java](Collatz.java.html)，它与数论中一个著名的未解决问题相关，即
    [Collatz 问题](http://mathworld.wolfram.com/CollatzProblem.html) 或 *3n + 1 问题*。'
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For example, a call to `collatz(7)` prints the sequence
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，调用 `collatz(7)` 打印出序列
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'as a consequence of 17 recursive calls. Write a program that takes a command-line
    argument `n` and returns the value of `i < n` for which the number of recursive
    calls for `collatz(i)` is maximized. Hint: use memoization. The unsolved problem
    is that no one knows whether the function terminates for all integers (mathematical
    induction is no help because one of the recursive calls is for a larger value
    of the argument).'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 17 次递归调用的结果。编写一个程序，接受一个命令行参数 `n`，并返回使得 `collatz(i)` 的递归调用次数最大化的 `i < n` 的值。提示：使用记忆化。未解决的问题是没有人知道该函数对所有整数是否终止（数学归纳法无助，因为其中一个递归调用是针对参数的较大值）。
- en: '**Brownian island.** B. Mandelbrot asked the famous question *How long is the
    coast of Britain?* Modify [Brownian.java](Brownian.java.html) to get a program
    [BrownianIsland.java](BrownianIsland.java.html) that plots [Brownian islands](http://swiss.csail.mit.edu/~rauch/islands/),
    whose coastlines resemble that of Great Britain. The modifications are simple:
    first, change `curve()` to add a random Gaussian to the *x*-coordinate as well
    as to the *y*-coordinate; second, change `main()` to draw a curve from the point
    at the center of the canvas back to itself. Experiment with various values of
    the arguments to get your program to produce islands with a realistic look.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布朗岛。** B. 曼德布罗特提出了著名问题 *英国海岸有多长？* 修改 [Brownian.java](Brownian.java.html)
    以获得一个程序 [BrownianIsland.java](BrownianIsland.java.html)，绘制出类似于大不列颠岛的 [布朗岛](http://swiss.csail.mit.edu/~rauch/islands/)。修改很简单：首先，将
    `curve()` 更改为在 *x* 坐标和 *y* 坐标上添加随机高斯数；其次，将 `main()` 更改为从画布中心的点绘制一条曲线回到自身。尝试使用各种参数值，使您的程序产生外观逼真的岛屿。'
- en: '![Brownian island](../Images/d8901e2a2634b519adef94f41361a3d1.png)'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![布朗岛](../Images/d8901e2a2634b519adef94f41361a3d1.png)'
- en: '**Plasma clouds.** Write a recursive program [PlasmaCloud.java](PlasmaCloud.java.html)
    to draw plasma clouds, using the method suggested in the text.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等离子云。** 编写一个递归程序 [PlasmaCloud.java](PlasmaCloud.java.html) 来绘制等离子云，使用文本中建议的方法。'
- en: '![plasma clouds](../Images/b411ee84a4611aa2aea64caee2644086.png)'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![等离子云](../Images/b411ee84a4611aa2aea64caee2644086.png)'
- en: '**A strange function.** Consider [McCarthy''s 91 function](McCarthy.java.html):'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个奇怪的函数。** 考虑[麦卡锡的 91 函数](McCarthy.java.html)：'
- en: '[PRE18]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Determine the value of `mcCarthy(50)` without using a computer. Give the number
    of recursive calls used by `mcCarthy()` to compute this result. Prove that the
    base case is reached for all positive integers `n` or find a value of `n` for
    which this function goes into a recursive loop.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定 `mcCarthy(50)` 的值，不使用计算机。给出 `mcCarthy()` 用于计算此结果的递归调用次数。证明对于所有正整数 `n` 都会达到基本情况，或找到一个值
    `n`，使得此函数进入递归循环。
- en: '**Recursive tree.** Write a program [Tree.java](Tree.java.html) that takes
    a command-line argument `n` and produces the following recursive patterns for
    `n` equal to 1, 2, 3, 4, and 8.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**递归树。** 编写一个程序[Tree.java](Tree.java.html)，它接受一个命令行参数 `n`，并为 `n` 等于 1、2、3、4
    和 8 生成以下递归模式。'
- en: '![recursive tree](../Images/a9d0bc474f1b08921a027c060c4f8620.png)'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![递归树](../Images/a9d0bc474f1b08921a027c060c4f8620.png)'
- en: Web Exercises
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: 'Does [Euclid.java](Euclid.java.html) still work if the inputs can be negative?
    If not, fix it. *Hint*: Recall that % can return a negative integer if the first
    input is negative. When calling the function, take the absolute value of both
    inputs.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入可以是负数，[Euclid.java](Euclid.java.html) 仍然有效吗？如果不是，请修复它。*提示*：回想一下，如果第一个输入是负数，%
    可以返回一个负整数。在调用函数时，取两个输入的绝对值。
- en: 'Write a recursive program [GoldenRatio.java](GoldenRatio.java.html) that takes
    an integer input N and computes an approximation to the [golden ratio](http://en.wikipedia.org/wiki/Golden_ratio)
    using the following recursive formula:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归程序 [GoldenRatio.java](GoldenRatio.java.html)，它接受一个整数输入 N，并使用以下递归公式计算[黄金比例](http://en.wikipedia.org/wiki/Golden_ratio)的近似值：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Redo, but do not use recursion.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重新做，但不使用递归。
- en: 'Discover a connection between the [golden ratio](http://en.wikipedia.org/wiki/Golden_ratio)
    and Fibonacci numbers. *Hint*: consider the ratio of successive Fibonacci numbers:
    2/1, 3/2, 8/5, 13/8, 21/13, 34/21, 55/34, 89/55, 144/89, ...'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现[黄金比例](http://en.wikipedia.org/wiki/Golden_ratio)与斐波那契数之间的联系。*提示*：考虑连续斐波那契数的比率：2/1,
    3/2, 8/5, 13/8, 21/13, 34/21, 55/34, 89/55, 144/89, ...
- en: Consider the following recursive function. What is `mystery(1, 7)`?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下递归函数。`mystery(1, 7)` 是什么？
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Will the function in the previous exercise terminate for every pair of integers
    a and b between between 0 and 100? Give a high level description of what `mystery(a,
    b)` returns, given integers a and b between 0 and 100.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个练习中，对于 0 到 100 之间的每对整数 a 和 b，函数是否会终止？给出对于 0 到 100 之间的整数 a 和 b，`mystery(a,
    b)` 返回的高级描述。
- en: '*Answer*: mystery(1, 7) = 1 + mystery(1, 6) = 1 + (1 + mystery(1, 5)) = ...
    7 + mystery(1, 0) = 7.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：mystery(1, 7) = 1 + mystery(1, 6) = 1 + (1 + mystery(1, 5)) = ... 7 +
    mystery(1, 0) = 7。'
- en: '*Answer*: Yes, the base case is b = 0\. Successive recursive calls reduce b
    by 1, driving it toward the base case. The function `mystery(a, b)` returns `a
    * b`. Mathematically inclined students can prove this fact via induction using
    the identity ab = a + a(b-1).'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：是的，基本情况是 b = 0。连续的递归调用将 b 减少 1，将其推向基本情况。函数 `mystery(a, b)` 返回 `a * b`。数学倾向的学生可以使用恒等式
    ab = a + a(b-1) 通过归纳法证明这一事实。'
- en: Consider the following function. What does `mystery(0, 8)` do?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下函数。`mystery(0, 8)` 做什么？
- en: '[PRE21]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Answer*: infinite loop.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：无限循环。'
- en: Consider the following function. What does `mystery(0, 8)` do?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下函数。`mystery(0, 8)` 做什么？
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Answer*: stack overflow.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：堆栈溢出。'
- en: Repeat the previous exercise, but replace `if (a != b)` with `if (a <= b)`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一个练习，但将 `if (a != b)` 替换为 `if (a <= b)`。
- en: What does `mystery(0, 8)` do?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mystery(0, 8)` 做什么？'
- en: '[PRE23]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What does the following function compute?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数计算什么？
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write a program [Fibonacci2.java](Fibonacci2.java.html) that takes a command-line
    argument N and prints out the first N Fibonacci numbers using the following alternate
    definition:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Fibonacci2.java](Fibonacci2.java.html)，它接受一个命令行参数 N，并使用以下替代定义打印出前 N 个斐波那契数：
- en: '[PRE25]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What is the biggest Fibonacci number you can compute in under a minute using
    this definition? Compare this to [Fibonacci.java](Fibonacci.java.html).
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个定义，在一分钟内你能计算出的最大斐波那契数是多少？将其与[Fibonacci.java](Fibonacci.java.html)进行比较。
- en: 'Write a program that takes a command-line argument N and prints out the first
    N Fibonacci numbers using the [following method](http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF)
    proposed by Dijkstra:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，它接受一个命令行参数 N，并使用[Dijkstra提出的方法](http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF)打印出前
    N 个斐波那契数。
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Prove by mathematical induction that the alternate definitions of the Fibonacci
    function given in the previous two exercises are equivalent to the original definition.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过数学归纳法证明前两个练习中给出的斐波那契函数的替代定义与原始定义等价。
- en: 'Write a program `Pell.java` that takes a command-line argument N and prints
    out the first N *Pell numbers*: p[0] = 0, p[1] = 1, and for n >= 2, p[n] = 2 p[n-1]
    + p[n-2]. Print out the ratio of successive terms and compare to 1 + sqrt(2).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 `Pell.java`，它接受一个命令行参数 N，并打印出前 N 个 *Pell 数*：p[0] = 0，p[1] = 1，对于 n >=
    2，p[n] = 2 p[n-1] + p[n-2]。打印连续项的比率，并与 1 + sqrt(2) 进行比较。
- en: 'Consider the following function from program [Recursion.java](Recursion.java.html):'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑来自程序[Recursion.java](Recursion.java.html)的以下函数：
- en: '[PRE27]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What does `mystery(6)` print out? *Hint*: first figure out what `mystery(2)`,
    `mystery(3)`, and so forth print out.'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mystery(6)` 打印出什么？*提示*：首先弄清楚 `mystery(2)`，`mystery(3)` 等打印出什么。'
- en: What would happen in the previous exercise if the base case was replaced with
    the following statement?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果基本情况被替换为以下语句，上一个练习会发生什么？
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Consider the following recursive functions.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下递归函数。
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What is the value of `square(5)`? `cube(5)`? `cube(123)`?
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`square(5)` 的值是多少？`cube(5)`？`cube(123)`？'
- en: Consider the following pair of mutually recursive functions. What does `g(g(2))`
    evaluate to?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑下面一对相互递归的函数。`g(g(2))` 的求值结果是什么？
- en: '[PRE30]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Write program to verify that (for small values of n) the sum of the cubes of
    the first n Fibonacci numbers F(0)^3 + F(1)^3 + ... + F(n)^3 equals (F(3n+4) +
    (-1)^n * 6 * f(n-1)) / 10, where F(0) = 1, F(1) = 1, F(2) = 2, and so forth.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序验���（对于较小的 n 值），前 n 个斐波那契数的立方和 F(0)^3 + F(1)^3 + ... + F(n)^3 等于 (F(3n+4)
    + (-1)^n * 6 * f(n-1)) / 10，其中 F(0) = 1，F(1) = 1，F(2) = 2，依此类推。
- en: '**Transformations by increment and unfolding.** Given two integers a ≤ b, write
    a program [Sequence.java](Sequence.java.html) that transforms a into b by a minimum
    sequence of increment (add 1) and unfolding (multiply by 2) operations. For example,'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过递增和展开进行转换。** 给定两个整数 a ≤ b，编写一个程序 [Sequence.java](Sequence.java.html)，通过最小的递增（加
    1）和展开（乘以 2）操作将 a 转换为 b。例如，'
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Hadamard matrix.** Write a recursive program [Hadamard.java](Hadamard.java.html)
    that takes a command-line argument n and plots an N-by-N Hadamard pattern where
    N = 2^n. Do *not* use an array. A 1-by-1 Hadamard pattern is a single black square.
    In general a 2N-by-2N Hadamard pattern is obtained by aligning 4 copies of the
    N-by-N pattern in the form of a 2-by-2 grid, and then inverting the colors of
    all the squares in the lower right N-by-N copy. The N-by-N Hadamard H(N) matrix
    is a boolean matrix with the remarkable property that any two rows differ in exactly
    N/2 bits. This property makes it useful for designing *error-correcting codes*.
    Here are the first few Hadamard matrices.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哈达玛矩阵。** 编写一个递归程序 [Hadamard.java](Hadamard.java.html)，接受一个命令行参数 n，并绘制一个 N×N
    的哈达玛图案，其中 N = 2^n。不要使用数组。一个 1×1 的哈达玛图案是一个黑色的正方形。一般来说，一个 2N×2N 的哈达玛图案是通过将 N×N 图案的
    4 个副本对齐成一个 2×2 网格的形式获得的，然后反转右下角 N×N 图案中所有方块的颜色。N×N 哈达玛 H(N) 矩阵是一个布尔矩阵，具有任意两行恰好相差
    N/2 位的显著特性。这个特性使得它对设计*纠错码*非常有用。以下是前几个哈达玛矩阵。'
- en: '| ![2-by-2 Hadamard plot](../Images/3fcca04e628395438f1368818224fcfb.png) |
    ![4-by-4 Hadamard plot](../Images/4188238d690602071d30541d08ef4597.png) | ![8-by-8
    Hadamard plot](../Images/3a556cb365ae1a8ac2f806d8eb3c324d.png) | ![16-by-16 Hadamard
    plot](../Images/283b5b4b908d053de67422d52ab78ca8.png) |'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![2x2 哈达玛矩阵图](../Images/3fcca04e628395438f1368818224fcfb.png) | ![4x4 哈达玛矩阵图](../Images/4188238d690602071d30541d08ef4597.png)
    | ![8x8 哈达玛矩阵图](../Images/3a556cb365ae1a8ac2f806d8eb3c324d.png) | ![16x16 哈达玛矩阵图](../Images/283b5b4b908d053de67422d52ab78ca8.png)
    |'
- en: '**8 queens problem.** In this exercise, you will solve the classic [8-queens
    problem](http://www.acm.org/classics/dec95): place 8 queens on an 8-by-8 chess
    board so that no two queens are in the same row, column, or diagonal. There are
    8! = 40,320 ways in which no two queens are placed in the same row or column.
    Any permutation p[] of the integers 0 to 7 gives such a placement: put queen i
    in row i, column p[i]. Your program [Queens.java](Queens.java.html) should take
    an integer command-line argument n and enumerate all solutions to the n-queens
    problem by drawing the location of the queens in ASCII like the two solutions
    below.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**8 皇后问题。** 在这个练习中，您将解决经典的 [8 皇后问题](http://www.acm.org/classics/dec95)：在一个
    8x8 的棋盘上放置 8 个皇后，使得没有两个皇后在同一行、列或对角线上。没有两个皇后放在同一行或列的方式有 8! = 40,320 种。整数 0 到 7
    的任意排列 p[] 都可以给出这样的放置：将皇后 i 放在第 i 行，第 p[i] 列。您的程序 [Queens.java](Queens.java.html)
    应该接受一个整数命令行参数 n，并通过绘制皇后的位置来列举解决 n 皇后问题的所有解决方案，就像下面的两个解决方案一样。'
- en: '[PRE32]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Hint*: to determine whether setting q[n] = i conflicts with q[0] through q[n-1]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：确定设置 q[n] = i 是否与 q[0] 到 q[n-1] 冲突'
- en: 'if q[i] equals q[n]: two queens are placed in the same column'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 q[i] 等于 q[n]：两个皇后放在同一列
- en: 'if q[i] - q[n] equals n - i: two queens are on same major diagonal'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 q[i] - q[n] 等于 n - i：两个皇后在同一主对角线上
- en: 'if q[n] - q[i] equals n - i: two queens are on same minor diagonal'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 q[n] - q[i] 等于 n - i：两个皇后在同一副对角线上
- en: '**Another 8 queens solver.** Program [Queens2.java](Queens2.java.html) solves
    the 8 queens problem by implicitly enumeration all n! permutations (instead of
    the n^n placements). It is based on program [Permutations.java](Permutations.java.html).'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**另一个 8 皇后问题求解器。** 程序 [Queens2.java](Queens2.java.html) 通过隐式枚举所有 n! 排列（而不是
    n^n 放置）来解决 8 皇后问题。它基于程序 [Permutations.java](Permutations.java.html)。'
- en: '**Euclid''s algorithm and π.** The probability that two numbers chosen from
    a large random set of numbers have no common factors (other than 1) is 6 / π².
    Use this idea to estimate π. Robert Matthews use the same idea to estimate π by
    taken the set of numbers to be a function of the positions of stars in the sky.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欧几里得算法和 π。** 从一个大随机数集中选择两个数，它们没有公共因子（除了 1）的概率是 6 / π²。利用这个想法来估计 π。罗伯特·马修斯使用相同的想法，通过将星空中的星星位置作为一个函数来估计
    π。'
- en: '**Towers of Hanoi variant II.** (Knuth-Graham and Pathashnik) Solve the original
    Towers of Hanoi problem, but with the extra restriction that you are not allowed
    to directly transfer a disk from A to C. How many moves does it take to solve
    a problem with n disks? *Hint*: move n-1 smallest disks from A to C recursively
    (without any direct A to C moves), move disk n from A to B, move n-1 smallest
    disks from C to A (without any direct A to C moves), move disk N from B to C,
    and move n-1 smallest disks from A to C recursively (without any direct A to C
    moves).'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汉诺塔变种 II。**（Knuth-Graham 和 Pathashnik）解决原始汉诺塔问题，但额外限制您不能直接将一个盘子从 A 移动到 C。解决具有
    n 个盘子的问题需要多少步？*提示*：递归地将 A 到 C 的 n-1 个最小盘子移动（没有任何直接的 A 到 C 移动），将盘子 n 从 A 移动到 B，递归地将
    C 到 A 的 n-1 个最小盘子移动（没有任何直接的 A 到 C 移动），将盘子 n 从 B 移动到 C，并递归地将 A 到 C 的 n-1 个最小盘子移动（没有任何直接的
    A 到 C 移动）。'
- en: '**Towers of Hanoi variant III.** Repeat the previous question but disallow
    both A to C and C to A moves. That is, each move must involve pole B.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汉诺塔变种 III。** 重复上一个问题，但不允许 A 到 C 和 C 到 A 的移动。也就是说，每次移动必须涉及柱子 B。'
- en: '**Towers of Hanoi with 4 pegs.** Suppose that you have a fourth peg. What is
    the least number of moves needed to transfer a stack of 8 disks from the leftmost
    peg to the rightmost peg? [Answer](http://math.smsu.edu/~les/POW01_03.html). Finding
    the shortest such solution in general has remained an open problem for over a
    hundred years and is known as *Reve''s puzzle*.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四根柱子的汉诺塔。** 假设你有第四根柱子。从最左边的柱子转移一个由 8 个圆盘组成的堆到最右边的柱子需要的最少移动次数是多少？[答案](http://math.smsu.edu/~les/POW01_03.html)。在一百多年来，找到一般情况下最短的解决方案仍然是一个悬而未决的问题，被称为*雷夫谜题*。'
- en: '**Another tricky recursive function.** Consider the following recursive function.
    What is `f(0)`?'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**另一个棘手的递归函数。** 考虑以下递归函数。`f(0)`是多少？'
- en: '[PRE33]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Checking if n is a Fibonacci number.** Write a function to check if n is
    a Fibonacci number. *Hint*: a positive integer is a Fibonacci number if and only
    if either (5*n*n + 4) or (5*n*n - 4) is a perfect square.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查 n 是否为斐波那契数。** 编写一个函数来检查 n 是否为斐波那契数。*提示*：当且仅当 (5*n*n + 4) 或 (5*n*n - 4)
    是一个完全平方数时，正整数才是斐波那契数。'
- en: '**Random infix expression generator.** Run [RandomExpression.java](RandomExpression.java.html)
    with different command-line argument p between 0 and 1. What do you observe?'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机中缀表达式生成器。** 使用不同的命令行参数 p 在 0 和 1 之间运行[RandomExpression.java](RandomExpression.java.html)。你观察到了什么？'
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**A tricky recurrence.** Define F(n) so that F(0) = 0 and F(n) = n - F(F(n-1)).
    What is F(100000000)?'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个棘手的递归。** 定义 F(n) 使得 F(0) = 0 并且 F(n) = n - F(F(n-1))。F(100000000)是多少？'
- en: '*Solution*: The [answer](http://www.ocf.berkeley.edu/~wwu/cgi-bin/yabb/YaBB.cgi?board=riddles_medium;action=display;num=1065363259)
    is related to the Fibonacci sequence and the [Zeckendorf representation](http://mathworld.wolfram.com/ZeckendorfRepresentation.html)
    of a number.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[答案](http://www.ocf.berkeley.edu/~wwu/cgi-bin/yabb/YaBB.cgi?board=riddles_medium;action=display;num=1065363259)与斐波那契数列和一个数字的[泽肯多夫表示](http://mathworld.wolfram.com/ZeckendorfRepresentation.html)有关。'
- en: '**von Neumann ordinal.** The *von Neumann integer* i is defined as follows:
    for i = 0, it is the empty set; for i > 0, it is the set containing the von Neumann
    integers 0 to i-1.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**冯·诺伊曼序数。** *冯·诺伊曼整数* i 的定义如下：对于 i = 0，它是空集；对于 i > 0，它是包含冯·诺伊曼整数 0 到 i-1 的集合。'
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Write a program [Ordinal.java](Ordinal.java.html) with a recursive function
    `vonNeumann()` that takes a nonnegative integer `N` and returns a string representation
    of the von Neumann integer N. This is a method for defining ordinals in set theory.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Ordinal.java](Ordinal.java.html)，其中有一个递归函数 `vonNeumann()`，接受一个非负整数 `N`
    并返回冯·诺伊曼整数 N 的字符串表示。这是集合论中定义序数的一种方法。
- en: '**Subsequences of a string.** Write a program [Subsequence.java](Subsequence.java.html)
    that takes a string command-line argument `s` and an integer command-line argument
    `k` and prints out all subsequences of `s` of length `k`.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符串的子序列。** 编写一个程序[Subsequence.java](Subsequence.java.html)，接受一个字符串命令行参数 `s`
    和一个整数命令行参数 `k`���并打印出长度为 `k` 的 `s` 的所有子序列。'
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Interleaving two strings.** Given two strings `s` and `t` of distinct characters,
    print out all (M+N)! / (M! N!) interleavings, where M and N are the number of
    characters in the two strings. For example, if'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**交错两个字符串。** 给定两个不同字符的字符串 `s` 和 `t`，打印出所有 (M+N)! / (M! N!) 交错，其中 M 和 N 是两个字符串中字符的数量。例如，如果'
- en: '[PRE37]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Binary GCD.** Write a program [BinaryGCD.java](BinaryGCD.java.html) that
    finds the greatest common divisor of two positive integers using the [binary gcd
    algorithm](http://en.wikipedia.org/wiki/Binary_GCD_algorithm): gcd(p, q) ='
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二进制最大公约数。** 编写一个程序[BinaryGCD.java](BinaryGCD.java.html)，使用[二进制最大公约数算法](http://en.wikipedia.org/wiki/Binary_GCD_algorithm)找到两个正整数的最大公约数：gcd(p,
    q) ='
- en: p if q = 0
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 q = 0，则为 p
- en: q if p = 0
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 p = 0，则为 q
- en: 2 * gcd(p/2, q/2) if p and q are even
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 p 和 q 都是偶数，则为 2 * gcd(p/2, q/2)
- en: gcd(p/2, q) if p is even and q is odd
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 p 是偶数且 q 是奇数，则为 gcd(p/2, q)
- en: gcd(p, q/2) if p is odd and q is even
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 p 是奇数且 q 是偶数，则为 gcd(p, q/2)
- en: gcd((p-q)/2, q) if p and q are odd and p >= q
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 p 和 q 都是奇数且 p >= q，则为 gcd((p-q)/2, q)
- en: gcd(p, (q-p)/2) if p and q are odd and p < q
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 p 和 q 都是奇数且 p < q，则为 gcd(p, (q-p)/2)
- en: '**Integer partitions.** Write a program [Partition.java](Partition.java.html)
    that takes a positive integer N as a command-line argument and prints out all
    partitions of N. A [partition](http://en.wikipedia.org/wiki/Integer_partition)
    of N is a way to write N as a sum of positive integers. Two sums are considered
    the same if they only differ in the order of their constituent summands. Partitions
    arise in symmetric polynomials and group representation theory in mathematics
    and physics.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整数分区。** 编写一个程序[Partition.java](Partition.java.html)，将一个正整数 N 作为命令行参数，并打印出
    N 的所有分区。[分区](http://en.wikipedia.org/wiki/Integer_partition)是将 N 写成正整数之和的一种方式。如果两个和仅在其组成部分的顺序上有所不同，则认为它们是相同的。分区在数学和物理中的对称多项式和群表示理论中出现。'
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Johnson-Trotter permutations.** Write a program [JohnsonTrotter.java](JohnsonTrotter.java.html)
    that takes an integer command-line argument n and prints all n! permutations of
    the integer 0 through n-1 in such a way that consecutive permutations differ in
    only one adjacent transposition (similar to way Gray code iterates over combinations
    in such a way that consecutive combinations differ in only one bit).'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**约翰逊-特罗特排列。** 编写一个程序[JohnsonTrotter.java](JohnsonTrotter.java.html)，接受一个整数命令行参数
    n，并以一种方式打印出整数 0 到 n-1 的所有 n! 排列，使得连续的排列仅在一个相邻的转位中有所不同（类似于格雷码在组合中迭代的方式，使得连续的组合仅在一个位上有所不同）。'
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Permutations in lexicographic order.** Write a program [PermutationsLex.java](PermutationsLex.java.html)
    that take a command-line argument N and prints out all N! permutations of the
    integer 0 through N-1 in lexicographic order.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按字典顺序排列的排列。** 编写一个程序[PermutationsLex.java](PermutationsLex.java.html)，接受一个命令行参数
    N，并按字典顺序打印出整数 0 到 N-1 的所有 N! 排列。'
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Derangements.** A [derangement](http://en.wikipedia.org/wiki/Derangement)
    is a permutation `p[]` of the integers from 0 to N-1 such that p[i] doesn''t equal
    i for any i. For example there are 9 derangements when N = 4: 1032, 1230, 1302,
    2031, 2301, 2310, 3012, 3201, 3210. Write a program to count the number of derangements
    of size N using the following recurrence: d[N] = (N-1) (d[N-1] + d[N-2]), where
    d[1] = 0, d[2] = 1. The first few terms are 0, 1, 2, 9, 44, 265, 1854, 14833,
    133496, and 1334961.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错位排列。** [错位排列](http://en.wikipedia.org/wiki/Derangement)是一个整数从0到N-1的排列`p[]`，使得对于任何i，p[i]不等于i。例如，当N
    = 4时有9个错位排列：1032, 1230, 1302, 2031, 2301, 2310, 3012, 3201, 3210。编写一个程序来计算大小为N的错位排列的数量，使用以下递推关系：d[N]
    = (N-1) (d[N-1] + d[N-2])，其中d[1] = 0，d[2] = 1。前几项是0, 1, 2, 9, 44, 265, 1854, 14833,
    133496和1334961。'
- en: '**Tribonacci numbers.** The *tribonacci numbers* are similar to the Fibonacci
    numbers, except that each term is the sum of the three previous terms in the sequence.
    The first few terms are 0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81. Write a program to
    compute tribonacci numbers. What is the ratio successive terms? *Answer*. Root
    of x^3 - x^2 - x - 1, which is approximately 1.83929.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Tribonacci数。** *Tribonacci数*类似于斐波那契数列，不同之处在于序列中的每一项是前三项的和。前几项是0, 0, 1, 1,
    2, 4, 7, 13, 24, 44, 81。编写一个计算Tribonacci数的程序。连续项的比率是多少？*答案*。x^3 - x^2 - x - 1的根，约为1.83929。'
- en: '**Sum of first n Fibonacci numbers.** Prove by induction that the sum of the
    first n Fibonacci numbers F(1) + F(2) + ... + F(N) is F(N+2) - 1.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前n个斐波那契数的和。** 通过归纳证明，前n个斐波那契数F(1) + F(2) + ... + F(N)的和是F(N+2) - 1。'
- en: '**Combinational Gray code.** Print out all combination of k of n items in such
    a way that consecutive combinations differ in exactly one element, e.g., if k
    = 3 and n = 5, 123, 134, 234, 124, 145, 245, 345, 135, 235, 125. *Hint*: use the
    Gray code, but only print out those integers with exactly k 1''s in their binary
    representation.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组合格雷码。** 按照只有一个元素不同的方式打印出k个n项的所有组合，例如，如果k = 3且n = 5，123, 134, 234, 124, 145,
    245, 345, 135, 235, 125。*提示*：使用格雷码，但只打印出那些在其二进制表示中恰好有k个1的整数。'
- en: '**Maze generation.** [Create a maze](http://en.wikipedia.org/wiki/Maze_generation_algorithm)
    using divide-and-conquer: Begin with a rectangular region with no walls. Choose
    a random gridpoint in the rectangle and construct two perpendicular walls, dividing
    the square into 4 subregions. Choose 3 of the four regions at random and open
    a one cell hole at a random point in each of the 3\. Recur until each subregion
    has width or height 1.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迷宫生成。** 使用分而治之的方法[创建一个迷宫](http://en.wikipedia.org/wiki/Maze_generation_algorithm)：从一个没有墙壁的矩形区域开始。选择矩形中的一个随机网格点，并构建两条垂直墙壁，将正方形分成4个子区域。随机选择四个区域中的三个，并在每个区域中的一个随机点开一个单元的洞。递归直到每个子区域的宽度或高度为1。'
- en: '**Plasma clouds.** Program [PlasmaCloud.java](PlasmaCloud.java.html) takes
    a command-line argument N and produces a random N-by-N plasma fractal using the
    midpoint displacement method.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等离子云。** 程序[PlasmaCloud.java](PlasmaCloud.java.html)接受一个命令行参数N，并使用中点位移法生成一个随机的N×N等离子分形。'
- en: '| ![Plasma Cloud 1](../Images/ec1d546e528e91882794533f70b7ae03.png) | ![Plasma
    Cloud 2](../Images/2bc93da5c14dce015352a1ae8fdf9511.png) | ![Plasma Cloud 3](../Images/906454727d634ad047c3e5049058bc0b.png)
    |'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![等离子云1](../Images/ec1d546e528e91882794533f70b7ae03.png) | ![等离子云2](../Images/2bc93da5c14dce015352a1ae8fdf9511.png)
    | ![等离子云3](../Images/906454727d634ad047c3e5049058bc0b.png) |'
- en: 'Here''s an [800-by-800 example](images/plasma-big.png). Here''s a [reference](http://www.gameprogrammer.com/fractal.html),
    including a simple 1D version. Note: some visual artifacts are noticeable parallel
    to the x and y axes. Doesn''t have all of the statistical properties of 2D fractional
    Brownian motion.'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个[800×800的示例](images/plasma-big.png)。这里有一个[参考链接](http://www.gameprogrammer.com/fractal.html)，包括一个简单的一维版本。注意：在x和y轴平行方向上会有一些视觉伪影。不具备2D分数布朗运动的所有统计特性。
- en: '**Fern fractal.** Write a recursive program to draw a fern or tree, as in this
    [fern fractal demo](http://www.krazydad.com/bestiary/bestiary_fern.html).'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**蕨类分形。** 编写一个递归程序来绘制蕨类或树，就像这个[蕨类分形演示](http://www.krazydad.com/bestiary/bestiary_fern.html)中所示。'
- en: '**Integer set partition.** Use memoization to develop a program that solves
    the set partition problem for positive integer values. You may use an array whose
    size is the sum of the input values.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**��数集合划分。** 使用记忆化开发一个解决正整数值集合划分问题的程序。可以使用一个大小为输入值之和的数组。'
- en: '**Voting power.** John F. Banzhaf III proposed a ranking system for each coalition
    in a block voting system. Suppose party i control w[i] votes. A strict majority
    of the votes is needed to accept or reject a proposal. The [voting power](http://acm.uva.es/p/v4/435.html)
    of party i is the number of minority coalitions it can join and turn it into a
    winning majority coalition. Write a program [VotingPower.java](VotingPower.java.html)
    that takes in a list of coalition weights as command-line argument and prints
    out the voting power of each coalition. *Hint*: use [Schedule.java](Schedule.java.html)
    as a starting point.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**投票权力。** 约翰·F·班扎夫三世提出了一个在分块投票系统中为每个联盟排名的系统。假设第i党控制w[i]票。接受或拒绝提案需要严格多数的选票。第i党的[投票权力](http://acm.uva.es/p/v4/435.html)是它可以加入的少数派联盟数量，使其成为获胜多数联盟。编写一个程序[VotingPower.java](VotingPower.java.html)，接受一个联盟权重列表作为命令行参数，并打印出每个联盟的投票权力。*提示*：使用[Schedule.java](Schedule.java.html)作为起点。'
- en: '**Scheduling on two parallel machines.** Program [Schedule.java](Schedule.java.html)
    takes a command-line argument N, reads in N real number of standard input, and
    partitions them into two groups so that their difference is minimized.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两台并行机器上的调度。** 程序[Schedule.java](Schedule.java.html)接受一个命令行参数N，从标准输入读取N个实数，并将它们分成两组，使它们的差最小化。'
- en: '**Hofstadter–Conway $10,000 sequence.** Consider the following recursive function.
    f(n) = f(f(n-1)) + f(n-f(n-1)) for n > 2 and f(1) = f(2) = 1. Compute f(3). Write
    a Java program to compute the first 50 values of f(n) in the [Hofstadter–Conway
    $10,000 sequence](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter–Conway_$10,000_sequence).
    Use dynamic programming. This sequence has many fascinating properties and connects
    with Pascal''s triangle, the Gaussian distribution, Fibonacci numbers, and Catalan
    numbers.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**霍夫斯塔德-康威 $10,000 序列。** 考虑以下递归函数。f(n) = f(f(n-1)) + f(n-f(n-1))，对于 n > 2 且
    f(1) = f(2) = 1。计算 f(3)。编写一个 Java 程序来计算[Hofstadter–Conway $10,000 序列](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter–Conway_$10,000_sequence)中
    f(n) 的前 50 个值。使用动态规划。这个序列具有许多迷人的特性，并与帕斯卡三角形、高斯分布、斐波那契数和卡特兰数相关。'
- en: '**Running time recurrences.** Use dynamic programming to compute a table of
    values T(N), where T(N) is the solution to the following divide-and-conquer recurrence.
    T(1) = 0, T(N) = N + T(N/2) + T(N - N/2) if N > 1.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时间递归。** 使用动态规划计算值表 T(N)，其中 T(N) 是以下分治递归的解。T(1) = 0，如果 N > 1，则 T(N) = N
    + T(N/2) + T(N - N/2)。'
- en: '**Gas station optimization.** You are driving from Princeton to San Francisco
    in a car that gets 25 miles per gallon and has a gas tank capacity of 15 gallons.
    Along the way, there are N gas stations where you can stop for gas. Gas station
    i is d[i] miles into the trip and sells gas for p[i] dollars per gallon. If you
    stop at station i for gas, you must completely fill up your tank. Assume that
    you start with a full tank and that the d[i] are integers. Use dynamic programming
    to find a minimum cost sequence of stops.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加油站优化。** 你正在驾驶一辆每加仑行驶 25 英里，油箱容量为 15 加仑的汽车从普林斯顿到旧金山。沿途有 N 个加油站可以停下加油。加油站
    i 在旅程中的 d[i] 英里处，每加仑卖 p[i] 美元的汽油。如果你在加油站 i 停下加油，你必须完全加满油箱。假设你从满箱开始，d[i] 是整数。使用动态规划找到最少费���的停车顺序。'
- en: '**Unix diff.** The Unix `diff` program compares two files line-by-line and
    prints out places where they differ. Write a program [Diff.java](Diff.java.html)
    that reads in two files specified at the command line one line at a time, computes
    the LCS on the sequence of constituent lines of each file, and prints out any
    lines corresponding to non-matches in the LCS.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Unix diff。** Unix `diff` 程序逐行比较两个文件，并打印出它们不同的地方。编写一个程序 [Diff.java](Diff.java.html)，逐行读取命令行指定的两个文件，计算每个文件的组成行序列上的
    LCS，并打印出与 LCS 中的非匹配对应的任何行。'
- en: '**Longest common subsequence of 3 strings.** Given 3 strings, find the longest
    common subsequence using dynamic programming. What is the running time and memory
    usage of your algorithm?'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3 个字符串的最长公共子序列。** 给定 3 个字符串，使用动态规划找到最长的公共子序列。你的算法的运行时间和内存使用情况是多少？'
- en: '**Making change.** Given A hundred dollar bills, B fifty dollar bills, C twenty
    dollar bills, D ten dollar bills, E five dollar bills, F one dollar bills, G half-dollars,
    H quarters, I dimes, J nickels, and K pennies, determine whether it is possible
    to make change for N cents. Hint: knapsack problem. (Greedy also works.)'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找零。** 给定 A 张一百美元的钞票，B 张五十美元的钞票，C 张二十美元的钞票，D 张十美元的钞票，E 张五美元的钞票，F 张一美元的钞票，G
    个半美元，H 个四分之一美元，I 个一角，J 个五分，和 K 个便士，确定是否可能找零 N 分。提示：背包问题。（贪心算法也可行。）'
- en: '**Making change.** Suppose that you are a cashier in a strange country where
    the currency denominations are: 1, 3, 8, 16, 22, 57, 103, and 526 cents (or more
    generally d[0], d[1], ..., d[N-1]. Describe a dynamic programming algorithm to
    make change for c cents using the fewest number of coins. *Hint*: the greedy algorithm
    won''t work since the best way to change 114 cents is 57 + 57 instead of 103 +
    8 + 3.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找零。** 假设你是一个收银员，在一个货币面额为：1, 3, 8, 16, 22, 57, 103 和 526 分的奇怪国家。描述一个动态规划算法，使用最少数量的硬币找零
    c 分。*提示*：贪心算法不起作用，因为找零 114 分的最佳方式是 57 + 57 而不是 103 + 8 + 3。'
- en: '**Longest increasing sequence.** Given an array of N 64-bit integers, find
    the longest subsequence that is strictly increasing.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长递增序列。** 给定 N 个 64 位整数的数组，找到严格递增的最长子序列。'
- en: '*Hint.* Compute the longest common subsequence between the original array and
    a sorted version of the array where duplicate copies of an integer are removed.'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示。* 计算原始数组和去除整数重复副本的数组的排序版本之间的最长公共子序列。'
- en: '**Longest common increasing sequence.** Computational biology. Given two sequences
    of N 64-bit integers, find the longest increasing subsequence that is common to
    both sequences.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长公共递增序列。** 计算生物学。给定两个 N 个 64 位整数的序列，找到两个序列中都存在的最长递增子序列。'
- en: '**Activity selection with profits.** Job i has start time s_i, finish time
    f_i and profit p_i. Find best subset of jobs to schedule.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带利润的活动选择。** 工作 i 具有开始时间 s_i，结束时间 f_i 和利润 p_i。找到最佳的工作子集进行安排。'
- en: '**Diff.** Write a program that reads in two files and prints out their diff.
    Treat each line as a symbol and compute an LCS. Print out those lines in each
    file that aren''t in the LCS.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Diff。** 编写一个程序，读取两个文件并打印出它们的 diff。将每行视为一个符号，并计算一个 LCS。打印出那些不在 LCS 中的每个文件的行。'
- en: '**Knapsack problem.** [Knapsack.java](Knapsack.java.html).'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**背包问题。** [Knapsack.java](Knapsack.java.html)。'
- en: '**Text justification.** Write a program that takes a command line argument
    N, reads text from standard input, and prints out the text, formatted nicely with
    at most N characters per line. Use dynamic programming.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文本对齐。** 编写一个程序，接受一个命令行参数 N，从标准输入读取文本，并以每行最多 N 个字符的方式打印出文本。使用动态规划。'
- en: '**Viterbi algorithm.** Given a directed graph where each edge is labeled with
    a symbol from a finite alphabet. Is there a path from one distinguished vertex
    x that matches the characters in the string s? Dynamic programming. A(i, v) =
    0 or 1 if there is a path from x to v that consumes the first i characters of
    s. A(i, v) = max (A(i-1, u) : (u, v) in E labeled with s[i]).'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**维特比算法。** 给定一个有向图，其中每条边都标有来自有限字母表的符号。是否有一条从一个特定顶点 x 开始的路径，与字符串 s 中的字符匹配？动态规划。A(i,
    v) = 0 或 1，如果有一条从 x 到 v 的路径消耗了 s 的前 i 个字符。A(i, v) = max (A(i-1, u) : (u, v) 在用
    s[i] 标记的 E 中)。'
- en: '**Viterbi algorithm.** Speech recognition, handwriting analysis, computational
    biology, hidden Markov models. Suppose each edge leaving v has a probability p(v,
    w) of being traversed. Probability of a path is the product of the probability
    on that path. What is most probable path? Dynamic programming.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Viterbi 算法。** 语音识别，手写分析，计算生物学，隐马尔可夫模型。假设离开 v 的每条边都有概率 p(v, w) 被遍历。路径的概率是该路径上概率的乘积。什么是最有可能的路径？动态规划。'
- en: '**Smith–Waterman algorithm.** Local sequence alignment.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Smith–Waterman 算法。** 局部序列比对。'
- en: '**Binomial coefficients (brute-force).** The [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient)
    C(n, k) is the number of ways of choosing a subset of k elements from a set of
    n elements. It arises in probability and statistics. One formula for computing
    binomial coefficients is C(n, k) = n! / (k! (n-k)!). This formula is not so amenable
    to direct computation because the intermediate results may overflow, even if the
    final answer does not. For example C(100, 15) = 253338471349988640 fits in a 64-bit
    `long`, but the binary representation of 100! is 525 bits long.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二项式系数（暴力法）。** [二项式系数](https://en.wikipedia.org/wiki/Binomial_coefficient)
    C(n, k) 是从 n 个元素的集合中选择 k 个元素的方式数。它在概率和统计中出现。计算二项式系数的一个公式是 C(n, k) = n! / (k! (n-k)!).
    这个公式不太适合直接计算，因为中间结果可能会溢出，即使最终答案没有溢出。例如 C(100, 15) = 253338471349988640 可以适应 64
    位 `long`，但 100! 的二进制表示有 525 位长。'
- en: '*Pascal''s identity* expresses C(n, k) in terms of smaller binomial coefficients:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Pascal''s identity* 用较小的二项式系数表示 C(n, k)：'
- en: '![Pascal''s identity](../Images/eede25bdbac3b755a5e4cdaea2743275.png)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Pascal''s identity](../Images/eede25bdbac3b755a5e4cdaea2743275.png)'
- en: '[SlowBinomial.java](SlowBinomial.java.html) fails spectacularly for medium
    n or k, not because of overflow, but rather because the same subproblems are solved
    repeatedly.'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[SlowBinomial.java](SlowBinomial.java.html) 在中等规模的 n 或 k 下表现惨不忍睹，不是因为溢出，而是因为同样的子问题被重复解决。'
- en: '[PRE41]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Binomial coefficients (dynamic programming).** Write a program [Binomial.java](Binomial.java.html)
    that takes two command-line arguments *n* and *k* and uses bottom-up dynamic programming
    to compute *C*(*n*, *k*).'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二项式系数（动态规划）。** 编写一个程序 [Binomial.java](Binomial.java.html)，接受两个命令行参数 *n* 和
    *k*，并使用自底向上的动态规划计算 *C*(*n*, *k*)。'
