- en: 6.5   Reductions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/65reductions](https://algs4.cs.princeton.edu/65reductions)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter under construction.
  prefs: []
  type: TYPE_NORMAL
- en: Reduction.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reduction or simulation is a powerful idea in computer science.... Problem-solving
    framework that transforms a problem X into a simpler problem Y such that it is
    easy to deduce a solution to the original problem X based on the solution for
    Y.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eric Alander - "Reduction provides an abstraction. If A efficiently reduces
    to B and B efficiently reduces to A, then A and B are equivalent in a meaningful
    sense: they are two different ways to look at the same problem. Instead of infinitely
    many computational problems, we are left with a smaller number of classes of equivalent
    problems. Nothing had prepared the computing community for the shocking insight
    that there are really just a handful of fundamentally different computational
    problems that people want to solve." Partitions natural computational problems
    into meaningful groups based on resource bounds.'
  prefs: []
  type: TYPE_NORMAL
- en: Upper bounds.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3-COLLINEAR to sorting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convex hull to sorting (Graham scan).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MEDIAN to SORTING.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bipartite matching to maxflow. [BipartiteMatchingToMaxflow.java](BipartiteMatchingToMaxflow.java.html)
    computes a maximum cardinality matching in a bipartite graph by reducing the problem
    to max flow. The order of growth of the running time is E V in the worst case
    since each augmentation increases the cardinality of the matching by one. The
    Hopcroft-Karp algorithm improves the running time to E sqrt(V).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LP standard form: a standard form linear program is { max cx : Ax <= b, x ≥
    0 }. Show how to reduce a general linear program (with ≤, ≥, and = constraints)
    to standard form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum flow to linear programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment problem to linear programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PERT to topological sort in a DAG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USTCONN (s-t connectivity in undirected graphs) to STCONN (undirected s-t connectivity
    in directed graphs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortest paths on undirected graphs to shortest paths on directed graphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Euclidean MST to Delauney triangulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LP feasibility reduces to LP. (Use binary search. Need to bound value of a bounded
    LP.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-person zero-sum games to LP. [TwoPersonZeroSumGame.java](TwoPersonZeroSumGame.java.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LP reduces to two-person zero-sum games. (Exercise 26 in Bradley, Hax, and Magnanti)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower bounds.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Element distinctness to sorting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closest pair 2D to Euclidean MST 2D.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convex hull to Voronoi / Delauney triangulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3-SUM to 3-COLLINEAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: 3-SUM to 4-SUM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: 3-SUM to 3-SUMplus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: 3-COLLINEAR to 3-CONCURRENT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3-SAT to INDEPENDENT-SET.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INDEPENDENT-SET to ILP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Element distinctness.* Given N elements x[1], ..., x[n] from a totally ordered
    universe, is there a pair i ≠ j such that x[i] = x[j]? Theta(N log N) lower bound
    in comparison tree model and algebraic decision tree model. O(N log N) easy by
    sorting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Solution 1* (comparison tree model): Given N distinct values. Let ai be ith
    smallest element. In any comparison based algorithm for the problem, we must compare
    a[i] against a[i-1]; otherwise the algorithm could not distinguish between the
    case a[i-1] < a[i] and a[i-1] = a[i]. Consider two different permutations of the
    N elements. There is an element a[i] where a[i-1] precedes a[i] in the first permutation
    but a[i-1] precedes a[i] in the second. Since every comparison based algorithm
    must compare a[i] and a[i-1], the algorithm runs differently on the two permutations.
    Thus, there are at leats N! leaves. [reference](http://dimacs.rutgers.edu/~gkindler/ds02c/ex5_ans.ps)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution 2* (comparison tree model): suppose the elements are all distinct
    and a_1 < a_2 < ... < a_N. Any correct algorithm for element distinctness must
    compare a_i with a_i+1 for each i < N. If not, then the algorithm would produce
    the same output if we changed a_i+1 to a_i (but this would change the answer from
    no duplicates to has duplicates). The set of compares the algorithm uses forms
    a DAG. Find the total order (in linear time) and this gives the sorted order.
    Thus, the algorithm can be used for sorting distinct elements and the sorting
    lower bound applies.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Remark*: these arguments apply to comparision tree model of computation but
    not to linear decision tree or algebraic decision tree model of computation. Here''s
    a more general argument (courtesy of Jeff Erickson): Consider the space R^n of
    all possible inputs. The set of positive inputs has n! connected components, one
    for each permutation. On the other hand, the subset of inputs that can reach any
    leaf in a linear decision tree is convex, and therefore connected. Thus, any linear
    decision tree that determines uniqueness has at least n! leaves. The result for
    linear decision trees is [On the complexity of computations under varying sets
    of primitives.](http://dx.doi.org/10.1016/0022-0000(79)90054-0) by Dobkin and
    Lipton. The result for algebraic decision trees is [Lower bounds for algebraic
    computation trees.](http://doi.acm.org/10.1145/800061.808735) by Ben-Or. The result
    for the special case of integer inputs is more subtle: see *A lower bound for
    the integer element distinctness problem* by Lubiw and Racs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*3-SUM.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*3-SAT.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear programming.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generalization of system of linear equations to inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: '[lecture slides](http://www.cs.princeton.edu/~wayne/teaching/lp-simplex.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Simplex algorithm.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Invented by George Dantzig in 1948. According to Dongarra and Sullivan, the
    simplex algorithm is one of the top 10 algorithms with the greatest influence
    in science and engineering in the 20th century. Generalization of Gaussian elimination
    to handle inequalities. Program [LinearProgramming.java](LinearProgramming.java.html)
    is a bare bones implementation. It solves { max cx : Ax <= b, x >= 0 } assuming
    that b >= 0\. Hence x = 0 is a basic feasible solution (and we don''t need to
    worry about Phase I of simplex).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fundamental theorem of LP.* Every LP of form (P) has the following three properties:
    (i) if it has no optimal solution, it is either infeasible or unbounded (ii) if
    it has a feasible solution, it has a basic feasible solution (iii) if it has an
    optimal solution, it has a basic optimal solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Strong duality theorem.* Every LP of form (P) has a dual (D) { min by : y
    A >= c : y >= 0 }. p1 + p2 + ... + pM = 1 -> x1 + x2 + ... + xm = 1/V.'
  prefs: []
  type: TYPE_NORMAL
- en: If (P) is bounded and feasible, then (D) is bounded and feasible. Moreover,
    they have the same optimal value. Simplex algorithm solves both problems simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '*Remarkable property.* In practice, simplex algorithm typically terminates
    in at most 2(m+n) pivots. n = total variables (original + slack), m = equations.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pitfalls.* Degeneracy, cycling.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment problem.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Formulate as LP. Relies on the *Birchoff-von Neumann Theorem*: all extreme
    points of assignment problem LP are {0, 1}. [AssignmentProblemToLP.java](AssignmentProblemToLP.java.html)
    reduces the assignment problem (max weight perfect matching) to linear programming.
    [EasyAssignmentProblemToLP.java](EasyAssignmentProblemToLP.java.html) puts everything
    in main and doesn''t extract the dual solution. [Hungarian.java](Hungarian.java.html)
    implements the Hungarian algorithm; the order of growth of the running time in
    the worst case is N^4. --> [AssignmentProblem.java](AssignmentProblem.java.html)
    implements the successive shortest paths algorithm; the order of growth of the
    running time in the wrost case is N^3 log N. [AssignmentProblemDense.java](AssignmentProblemDense.java.html)
    implements the successive shortest paths algorithm; the order of growth of the
    running time in the wrost case is N^3.'
  prefs: []
  type: TYPE_NORMAL
- en: Two-person zero-sum games.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reduces to LP. Can assume payoff matrix is strictly positive (adding a constant
    to each entry increases the value of the game by M, but does not change the solutions).
    (P) min { x1 + ... + xm, : x >= 0, M^t x >= 1} and (D) max { y1 + ... + yn, :
    y >= 0, My <= 1}. Normalize the solution vectors x* and y* to get the row player''s
    (minimizing) and column player''s (maximizing) optimal strategies; the normalizing
    constant is the value of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Trick. Replace variables: xi = pi / V; max V -> min 1/V; [Game theory, p. 6-7](http://www.scribd.com/doc/30906572/Game-THeory)'
  prefs: []
  type: TYPE_NORMAL
- en: Program [ZeroSumGame.java](ZeroSumGame.java.html) implements this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: any LP can be put into this form by an appropriate change of variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The minimax theorem.** (von Neumann). For every finite two-person zero-sum
    game, there exists a value V and a mixed strategy for each player such that (i)
    given the row player''s strategy, the best possible payoff for the column player
    is V, and (ii) given the column player''s strategy, the best possible payoff for
    the row player is -V.'
  prefs: []
  type: TYPE_NORMAL
- en: Linear programming solvers.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[LinearProgramming.java](LinearProgramming.java.html) is a bare-bones version
    of the simplex algorithm. It assumes b >= 0, so that x = 0 is a starting basic
    feasible solution. [TwoPhaseSimplex.java](TwoPhaseSimplex.java.html) is a bare-bones
    version of the two-phase simplex algorithm, which removes the assumption b >=
    0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OR-Objects](http://opsresearch.com/OR-Objects/) contains a Java linear program
    solver. [LPDemo.java](LPDemo.java.html) demonstrates how to solve a linear program
    using [or124.jar](or124.jar).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[QSopt](http://www2.isye.gatech.edu/~wcook/qsopt/software/java.htm) is a Java
    linear program solver created by David Applegate, William Cook, Sanjeeb Dash,
    and Monika Mevenkamp. It can be used at no cost for research or education purposes.
    [QSoptSolver.java](QSoptSolver.java.html) solves a linear program in LP format,
    such as [beer.lp](beer.lp).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Matlab](http://www.mathworks.com/products/matlab/) contains a linear programming
    solver in the optimization toolbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[CPLEX](http://www-01.ibm.com/software/integration/optimization/cplex-optimizer/)
    is a high-performance mathematical programming solver for linear programming,
    mixed integer programming, and quadratic programming. It supports interfaces to
    C, C++, Java, Python, Matlab, and Microsoft Excel. It is also accessible via the
    modeling systems including AIMMS, AMPL, GAMS, and MPL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AMPL](http://www.ampl.com/) is a modeling language for mathematical programming.
    The files [beer.mod](beer.mod) and [beer.dat](beer.dat) specify the model and
    data for the brewery problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Microsoft Excel has a primitive solver add-in for Windows, but it is no longer
    available for Mac.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q + A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Undirected shortest paths with negative weights to directed shortest
    paths?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Need more clever reduction to avoid negative cycles (via nonbipartite
    matching).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*gcd and lcm.* Reduce lcm to gcd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Table k-sum.* Given a k-by-N table of integers, are there k that sum to 0,
    one from each of the k rows?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Coin distinctness.** Given N coins and a balance scale, determine if the
    coins all weigh different amounts. Prove that any algorithm that solves the problem
    has complexity at least N log N. *Hint*: you may use the fact that given N real
    numbers, element distinctness requires at least N log N comparisons in the linear
    decision tree model (where you can make comparisons between arbitrary linear combinations
    of the N elements, e.g, x1 + 2x2 < x3).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set equality.** Given two sets S and T, does S equal T? Give an O(N log N)
    algorithm and a matching lower bound.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set subset.** Given two sets S and T, is S a subset of T? Give an O(N log
    N) algorithm and a matching lower bound.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set disjointness.** Given two sets S and T, does S intersect T equal the
    empty set? Give an O(N log N) algorithm and a matching lower bound. (Since S and
    T are sets, there are no duplicated elements in either.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* To get the O(N log N) upper bound, sort the union of the elements
    in S and T and check for duplicates.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Set disjointness.** Given two sets S and T, each in ascending order, does
    S intersect T equal the empty set? Prove an Omega(N log N) lower bound or given
    an O(N) algorithm.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lower bound for merging two lists.** Show any comparison-based algorithm
    for merging two lists of size N requires at least 2N-1 comparisons in the worst
    case. *Solution*: lower bound holds even if all elements are distinct. If the
    ith and (i+1)st smallest elements are in different lists, then they must be compared.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lower bound for binary search.** log(N+1) comparisons required. *Solution*:
    lower bound holds even if all elements are distinct....'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Euclidean TSP and MST lower bounds.** Given an Omega(N log N) for the Euclidean
    TSP or Euclidean MST (requires algebraic decision trees to make sense since you
    want to allow a reasonable algorithm to compute distances). *Solution*: choose
    N points on a line. Optimal tour must visit the points in ascending order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lower bound for mode.** Theta(N log N) bound for mode. *Solution*: could
    solve element distinctness problem by finding mode and checking whether it is
    more than one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lower bound for closest pair.** Theta(N log N) bound for closest pair. *Solution*:
    could solve element distinctness problem in sub-lineararithmic time if had a sub-lineararithmic
    algorithm by finding closest pair and checking if they are equal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Smallest and second smallest.** Describe how to find both the smallest and
    second smallest element using at most N + log N comparisons. *Solution*: divide
    the elements into pairs and compare two elements in each pair. Recur with the
    N/2 winners from each pair. After N-1 comparisons, we have the minimum element.
    Note that each element is compared with at most log N other elements. In particular,
    the smallest element is compared with at most log N other elements, and one of
    these must be the second smallest. If you keep track of all the comparisons, you
    can remember the log N involving the smallest element and compare these.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Counting inversions.** Prove a Theta(N log N) lower bound. This is an open
    research question.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nuts and bolts.** Prove a Theta(N log N) lower bound for the nuts and bolts
    problem in the quicksort section. [A matching worst case upper bound of O(N log
    N) is known, but it is remarkably complicated.]'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Existence symbol table.** Suppose you had a comparison-based algorithm that
    supports insert and exists in O(1) comparisons per operation. Explain why this
    is impossible in this model of computation. *Solution*: to solve element distinctness
    in O(N) time, for each of the N elments, check whether it''s already in the data
    structure (if so, then this is a duplicate); if not, insert it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Model a constraint of the form x ≤ y using integer programming (Ax = b, x >=
    0, x integral).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Model a constraint of the form x = { 0 or 1 } using integer programming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Model a constraint of the form x = { 1 or 2 or 4 } using integer programming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tait coloring.** Model 3-edge coloring cubic graph using IP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign organ donors to patients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bipartite vertex cover.** Reduce to max flow.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transitive reduction and transitive closure.** Reduce [transitive reduction](http://en.wikipedia.org/wiki/Transitive_reduction)
    to transitive closure and vice versa (when running time is measured only as a
    function of the number of vertices V). Also reduces to Boolean matrix multiplication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3SUM''.** Given three sets of integers A, B, and C of total size n, are there
    a in A, b in B and c in C such that a + b = c? Prove that 3SUM linear-time reduces
    to 3SUM'' and vice versa.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* To show that 3SUM reduces to 3SUM'', set A = S, B = S, and C =
    -S.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To show that 3SUM' reduces to 3SUM, assume that all integers are positive (if
    not, add k to each element in A and B and 2K to each element in C). Set m = 2
    max(A, B, C). For each element a in A, put a + m in S. For each element b in B,
    put b in S. For each elemenet in C, put -c -m in S.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Inequalities satisfied with equality.** Given a system of linear inequalities
    *A* *x* ≤ *b*, design a linear program to determine which inequalities among *A*
    *x* ≤ *b* must be satisfied with equality in any feasible solution *x*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Equality constraint.** Model a linear programming equality constraint using
    two <= constraints.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unrestricted variables.** Model a linear programming unrestricted variable
    x using two nonnegative variables y and z.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unbounded LP.** If (P) is unbounded, then there exists a vector d >= 0 such
    that Ad <= 0 and cd > 0\. First explain why if such a vector d exists, then the
    problem is unbounded. Next, modify the simplex algorithm to report such a vector
    when the LP is unbounded. *Answer*: by assumption b >= 0 and x = 0 is feasible.
    Thus α d is feasible for any positive constant α and has objective value α cd.
    The vector d can be identified by checking if the min ratio rule fails. In this
    case, the entries in column q are nonpositive (Ad <= 0) and the objective function
    coefficient is positive (cd > 0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reduced costs.** Modify the simplex algorithm to report the reduced costs
    (shadow prices). Give economic interpretation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dantzig''s steepest edge rule.** Modify the simplex algorithm so that it
    always chooses the most positive objective function coefficient.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cycling.** Give a pathological linear programming input that causes the simplex
    algorithm (using the steepest edge rule) to cycle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bottneck assignment problem.** Given N men and N women. Each person has M
    attributes. Each person specifies a set of desirable attributes of people of the
    opposite gender. Find a perfect matching in which the most unlucky person is matched
    with a partner with the fewest number of specified attributes. Reduce this problem
    to the assignment problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Create an edge-weighted graph where the weight of an edge is the
    minimum number of desirable attributes satisfied by either person. The goal is
    the maximize the weight of the minimum-weigh edge in an assignment. One solution
    to this problem is to use binary search (eliminate all edges of weight less than
    a given threshold) and solve the resulting bipartite perfect matching problem.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Chinese postman problem.** Given a strongly connected digraph G, find a directed
    cycle of minimum length that that traverses each edge at least once. (It turns
    out that the best cycle will visited each edge at most twice.) The graph is Eulerian
    if each vertex is *balanced*: its degree equals its outdegree. Divide the unbalanced
    vertices into two sets: L = vertices with outdegree < indegree, R = vertices with
    outdegree > indegree. By adding a directed path from a vertex in L to one in R,
    we improve the balance. Form a weighted bipartite graph on (L, R) where the weight
    of an edge from v to w is the length of the shortest path from v to w in G. Find
    a min weight matching and add these edges to G to make it Eulerian. Then, find
    a cycle. This is known as the Edmonds-Johnson (1973) algorithm. (Similar algorithm
    works for undirected graphs, but need to find a min weight perfect matching in
    a nonbipartite graph.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
