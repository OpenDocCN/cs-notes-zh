<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lecture 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lecture 1</h1>
<blockquote>原文：<a href="https://cs50.harvard.edu/sql/notes/1/">https://cs50.harvard.edu/sql/notes/1/</a></blockquote>

                    

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#entity-relationship-diagrams" id="markdown-toc-entity-relationship-diagrams">Entity Relationship Diagrams</a>    <ul>
      <li><a href="#questions" id="markdown-toc-questions">Questions</a></li>
    </ul>
  </li>
  <li><a href="#keys" id="markdown-toc-keys">Keys</a>    <ul>
      <li><a href="#primary-keys" id="markdown-toc-primary-keys">Primary Keys</a></li>
      <li><a href="#foreign-keys" id="markdown-toc-foreign-keys">Foreign Keys</a></li>
      <li><a href="#questions-1" id="markdown-toc-questions-1">Questions</a></li>
    </ul>
  </li>
  <li><a href="#subqueries" id="markdown-toc-subqueries">Subqueries</a></li>
  <li><a href="#in" id="markdown-toc-in"><code class="language-plaintext highlighter-rouge">IN</code></a>    <ul>
      <li><a href="#questions-2" id="markdown-toc-questions-2">Questions</a></li>
    </ul>
  </li>
  <li><a href="#join" id="markdown-toc-join"><code class="language-plaintext highlighter-rouge">JOIN</code></a>    <ul>
      <li><a href="#questions-3" id="markdown-toc-questions-3">Questions</a></li>
    </ul>
  </li>
  <li><a href="#sets" id="markdown-toc-sets">Sets</a>    <ul>
      <li><a href="#questions-4" id="markdown-toc-questions-4">Questions</a></li>
    </ul>
  </li>
  <li><a href="#groups" id="markdown-toc-groups">Groups</a>    <ul>
      <li><a href="#questions-5" id="markdown-toc-questions-5">Questions</a></li>
    </ul>
  </li>
  <li><a href="#fin" id="markdown-toc-fin">Fin</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<ul>
  <li data-marker="*">Databases can have multiple tables. Last class, we saw a database of books longlisted, or nominated, for the International Booker Prize. We will now see that database has many different tables inside it — for books, authors, publishers and so on.</li>
  <li data-marker="*">First, open up the database using SQLite in the terminal of your <a href="https://cs50.dev/">Codespace</a>.</li>
  <li data-marker="*">We can use the following SQLite command to see all the tables in our database:
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">tables</span>
</code></pre></div>    </div>
    <p>This command returns the names of the tables in <code class="language-plaintext highlighter-rouge">longlist.db</code> — 7 in all.</p>
  </li>
  <li data-marker="*">These tables have some relationships between them, and hence we call the database a <strong>relational database</strong>. Look at the list of tables in <code class="language-plaintext highlighter-rouge">longlist.db</code> and try to imagine relationships between them. Some examples are:
    <ul>
      <li data-marker="*">Authors write books.</li>
      <li data-marker="*">Publishers publish books.</li>
      <li data-marker="*">Books are translated by translators.</li>
    </ul>
  </li>
  <li data-marker="*">
    <p>Consider our first example. Here is a snapshot of the <code class="language-plaintext highlighter-rouge">authors</code> and <code class="language-plaintext highlighter-rouge">books</code> tables with the author name and book title columns!</p>

    <p class="w-50"><img src="../Images/1cc4671dfe321c360ec89b39f3258342.png" alt="&quot;Author Name and Book Title columns from different tables&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p6.jpg"/></p>
  </li>
  <li data-marker="*">Just looking at these two columns, how can we tell who wrote which book? Even if we assume that every book is lined up next to its author, just looking at the <code class="language-plaintext highlighter-rouge">authors</code> table would give us no information about the books written by that author.</li>
  <li data-marker="*">Some possible ways to organize books and authors are…
    <ul>
      <li data-marker="*"><strong>the honor system</strong>: the first row in the <code class="language-plaintext highlighter-rouge">authors</code> table will always correspond to the first row in the <code class="language-plaintext highlighter-rouge">books</code> table. The problem with this system is that one may make a mistake (add a book but forget to add its corresponding author, or vice versa). Also, an author may have written more than one book or a book may be co-written by multiple authors.</li>
      <li data-marker="*">
        <p><strong>going back to a one-table approach</strong>: This approach could result in redundancy (duplication of data) if one author writes multiple books or if a book is co-written by multiple authors. Below is a snapshot of the one-table approach with some redundant data.</p>

        <p class="w-50"><img src="../Images/5c1d25299994e6ca97b5d2fa5dfbcfd3.png" alt="&quot;One-table approach: author with multiple books&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p8.jpg"/></p>
      </li>
    </ul>
  </li>
  <li data-marker="*">After considering these ideas, it seems like having two different tables is the most efficient approach. Let us look at some different ways in which tables can be related to each other in relational databases.</li>
  <li data-marker="*">
    <p>Consider this case, where each author writes only one book and each book is written by one author. This is called a one-to-one relationship.</p>

    <p class="w-50"><img src="../Images/38942739f06a26946bbf9c38f4667c45.png" alt="&quot;One-to-one relationship&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p10.jpg"/></p>
  </li>
  <li data-marker="*">
    <p>On the other hand, if an author can write multiple books, the relationship is a one-to-many relationship.</p>

    <p class="w-50"><img src="../Images/8c1f798a65fb766db6c9259d47ab9b8a.png" alt="&quot;One-to-many relationship&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p11.jpg"/></p>
  </li>
  <li data-marker="*">
    <p>Here, we see another situation where not only can one author write multiple books, but books can also be co-written by multiple authors. This is a many-to-many relationship.</p>

    <p class="w-50"><img src="../Images/4b42eb30cd7e9c257d41fe3b804f3750.png" alt="&quot;Many-to-many relationship&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p12.jpg"/></p>
  </li>
</ul>

<h2 id="entity-relationship-diagrams">Entity Relationship Diagrams</h2>

<ul>
  <li data-marker="*">We just described one-to-one, one-to-many and many-to-many relationships between tables in a database. It is possible to visualize such relationships using an entity relationship (ER) diagram.</li>
  <li data-marker="*">
    <p>Here is an ER diagram for the tables in <code class="language-plaintext highlighter-rouge">longlist.db</code>.</p>

    <pre><code class="language-mermaid">erDiagram
  "Author" }|--|{ "Book" : "wrote"
  "Publisher" ||--|{ "Book" : "published"
  "Translator" }o--|{ "Book" : "translated"
  "Book" ||--o{ "Rating" : "has"
</code></pre>
  </li>
  <li data-marker="*">Each table is an entity in our database. The relationships between the tables, or entities, are represented by the <em>verbs</em> that mark the lines connecting entities.</li>
  <li data-marker="*">Each line is this diagram is in crow’s foot notation.
    <ul>
      <li data-marker="*">The first line with a circle looks like a 0 marked on the line. This line indicates that there are no relations.</li>
      <li data-marker="*">The second line with a perpendicular line looks like a 1 marked on the line. An entity with this arrow has to have at least one row that relates to it in the other table.</li>
      <li data-marker="*">
        <p>The third line, which looks like a crow’s foot, has many branches. This line means that the entity is related to many rows from another table.</p>

        <p class="w-50"><img src="../Images/001e48f4a406107479adcb3b3187eb8a.png" alt="&quot;Lines in ER Diagrams&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p17.jpg"/></p>
      </li>
    </ul>
  </li>
  <li data-marker="*">For example:
    <ul>
      <li data-marker="*">
        <p>We read the notation left to right. An author writes one book (or, every author can have one book associated with them).</p>

        <p class="w-50"><img src="../Images/f23bedec4064213ef494c004859702b5.png" alt="&quot;1-Relation Notation: an author writes one book&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p18.jpg"/></p>
      </li>
      <li data-marker="*">
        <p>Now, not only does an author write one book but a book is also written by one author.</p>

        <p class="w-50"><img src="../Images/b9796610a33000a7b9ea9b784495fc36.png" alt="&quot;1-Relation Notation: an author writes one book and one book is written by one author&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p19.jpg"/></p>
      </li>
      <li data-marker="*">
        <p>With this addition, an author writes at least one book and a book is written by at least one author. To rephrase, an author could be associated with one or multiple books and a book can be written by one or multiple authors.</p>

        <p class="w-50"><img src="../Images/6cf762d7f2830e8c88afced01c125181.png" alt="&quot;Adding multiple lines: an author writes at least one book and a book is written by at least one author&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p20.jpg"/></p>
      </li>
    </ul>
  </li>
  <li data-marker="*">
    <p>Let us revisit the ER diagram for our database.</p>

    <pre><code class="language-mermaid">erDiagram
  "Author" }|--|{ "Book" : "wrote"
  "Publisher" ||--|{ "Book" : "published"
  "Translator" }o--|{ "Book" : "translated"
  "Book" ||--o{ "Rating" : "has"
</code></pre>
  </li>
  <li data-marker="*">On observing the lines connecting the Book and Translator entities, we can say that books don’t <em>need</em> to have a translator. They could have zero to many translators. However, a translator in the database translates at least one book, and possibly many.</li>
</ul>

<h3 id="questions">Questions</h3>

<blockquote>
  <p>If we have some database, how do we know the relationships among the entities stored inside of it?</p>
</blockquote>

<ul>
  <li data-marker="*">The exact relationships between entities are really up to the designer of the database. For example, whether each author can write only one book or multiple books is a decision to be made while designing the database. An ER diagram can be thought of as a tool to communicate these decisions to someone who wants to understand the database and the relationships between its entities.</li>
</ul>

<blockquote>
  <p>Once we know that a relationship exists between certain entities, how do we implement that in our database?</p>
</blockquote>

<ul>
  <li data-marker="*">We will shortly see how we can use <strong>keys</strong> in SQL to relate tables to one another.</li>
</ul>

<h2 id="keys">Keys</h2>

<h3 id="primary-keys">Primary Keys</h3>

<ul>
  <li data-marker="*">
    <p>In the case of books, every book has a unique identifier called an ISBN. In other words, if you search for a book by its ISBN, only one book will be found. In database terms, the ISBN is a primary key — an identifier that is unique for every item in a table.</p>

    <p class="w-50"><img src="../Images/709b78a505de6de2e922ff22c8b86dea.png" alt="&quot;Table with ISBNs and book titles&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p29.jpg"/></p>
  </li>
  <li data-marker="*">
    <p>Inspired by this idea of an ISBN, we can imagine assigning unique IDs to our publishers, authors and translators! Each of these IDs would be the primary key of the table it belongs to.</p>
  </li>
</ul>

<h3 id="foreign-keys">Foreign Keys</h3>

<ul>
  <li data-marker="*">Keys also help relate tables in SQL.</li>
  <li data-marker="*">
    <p>A foreign key is a primary key taken from a different table. By referencing the primary key of a different table, it helps relate the tables by forming a link between them.</p>

    <p class="w-50"><img src="../Images/91a4de930ecc6ac95f9e54bd6011c225.png" alt="&quot;Relating the books and ratings tables using foreign key&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p31.jpg"/></p>

    <p>Notice how the primary key of the <code class="language-plaintext highlighter-rouge">books</code> table is now a column in the <code class="language-plaintext highlighter-rouge">ratings</code> table. This helps form a one-to-many relationship between the two tables — a book with a title (found in the <code class="language-plaintext highlighter-rouge">books</code> table) can have multiple ratings (found in the <code class="language-plaintext highlighter-rouge">ratings</code> table).</p>
  </li>
  <li data-marker="*">The ISBN, as we can see, is a long identifier. If each character occupied a byte of memory, storing a single ISBN (including the dashes) would take 17 bytes of memory, which is a lot!</li>
  <li data-marker="*">Thankfully, we don’t necessarily have to use the ISBN as a primary key. We can just construct our own using numbers like 1, 2, 3… and so on as long as each book has a unique number to identify it.</li>
  <li data-marker="*">
    <p>Previously, we saw how to implement the one-to-many relationship between the <code class="language-plaintext highlighter-rouge">books</code> and <code class="language-plaintext highlighter-rouge">ratings</code> entities. Here’s an example of a many-to-many relationship.</p>

    <p class="w-50"><img src="../Images/8ca6cfda5f4b3f3a9cc43ac37ad31efc.png" alt="&quot;Relating the authors and books tables using a foreign key and another table&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p40.jpg"/></p>
  </li>
</ul>

<p>There is now a table called <code class="language-plaintext highlighter-rouge">authored</code> that maps the primary key of <code class="language-plaintext highlighter-rouge">books</code> (<code class="language-plaintext highlighter-rouge">book_id</code>) to the primary key of <code class="language-plaintext highlighter-rouge">authors</code> (<code class="language-plaintext highlighter-rouge">author_id</code>).</p>

<h3 id="questions-1">Questions</h3>

<blockquote>
  <p>Can the IDs of the author and the book be the same? For example, if <code class="language-plaintext highlighter-rouge">author_id</code> is 1 and <code class="language-plaintext highlighter-rouge">book_id</code> is also 1 in the <code class="language-plaintext highlighter-rouge">authored</code> table, will there be a mix-up?</p>
</blockquote>

<ul>
  <li data-marker="*">Tables like <code class="language-plaintext highlighter-rouge">authored</code> are called “joint” or “junction” tables. In such tables, we usually know which primary key is referenced by which column. In this case, since we know that the first column contains the primary key of <code class="language-plaintext highlighter-rouge">authors</code> only and the second column similarly contains the primary key of <code class="language-plaintext highlighter-rouge">books</code> only, it would be okay even if the values matched!</li>
</ul>

<blockquote>
  <p>If we have a lot of joint tables like this, wouldn’t that take up too much space?</p>
</blockquote>

<ul>
  <li data-marker="*">Yes, there is a trade-off here. Tables like these occupy more space but they also enable us to have many-to-many relationships without redundancies, like we saw earlier.</li>
</ul>

<blockquote>
  <p>On changing the ID of a book or author, does the ID get updated in the other tables as well?</p>
</blockquote>

<ul>
  <li data-marker="*">An updated ID still needs to be unique. Given that, IDs are often abstracted away and we rarely change them.</li>
</ul>

<h2 id="subqueries">Subqueries</h2>

<ul>
  <li data-marker="*">A subquery is a query inside another query. These are also called nested queries.</li>
  <li data-marker="*">Consider this example for a one-to-many relationship. In the <code class="language-plaintext highlighter-rouge">books</code> table, we have an ID to indicate the publisher, which is a foreign key taken from the <code class="language-plaintext highlighter-rouge">publishers</code> table. To find out the books published by Fitzcarraldo Editions, we would need two queries — one to find out the <code class="language-plaintext highlighter-rouge">publisher_id</code> of Fitzcarraldo Editions from the <code class="language-plaintext highlighter-rouge">publishers</code> table and the second, to use this <code class="language-plaintext highlighter-rouge">publisher_id</code> to find all the books published by Fitzcarraldo Editions. These two queries can be combined into one using the idea of a subquery.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"title"</span>
<span class="k">FROM</span> <span class="nv">"books"</span>
<span class="k">WHERE</span> <span class="nv">"publisher_id"</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"id"</span>
    <span class="k">FROM</span> <span class="nv">"publishers"</span>
    <span class="k">WHERE</span> <span class="nv">"publisher"</span> <span class="o">=</span> <span class="s1">'Fitzcarraldo Editions'</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>Notice that:</p>
    <ul>
      <li data-marker="*">The subquery is in parentheses. The query that is furthest inside parantheses will be run first, followed by outer queries.</li>
      <li data-marker="*">The inner query is indented. This is done as per style conventions for subqueries, to increase readability.</li>
    </ul>
  </li>
  <li data-marker="*">To find all the ratings for the book In Memory of Memory
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"rating"</span>
<span class="k">FROM</span> <span class="nv">"ratings"</span>
<span class="k">WHERE</span> <span class="nv">"book_id"</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"id"</span>
    <span class="k">FROM</span> <span class="nv">"books"</span>
    <span class="k">WHERE</span> <span class="nv">"title"</span> <span class="o">=</span> <span class="s1">'In Memory of Memory'</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">To select just the average rating for this book
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="nv">"rating"</span><span class="p">)</span>
<span class="k">FROM</span> <span class="nv">"ratings"</span>
<span class="k">WHERE</span> <span class="nv">"book_id"</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"id"</span>
    <span class="k">FROM</span> <span class="nv">"books"</span>
    <span class="k">WHERE</span> <span class="nv">"title"</span> <span class="o">=</span> <span class="s1">'In Memory of Memory'</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">The next example is for many-to-many relationships. To find the author(s) who wrote the book Flights, three tables would need to be queried: <code class="language-plaintext highlighter-rouge">books</code>, <code class="language-plaintext highlighter-rouge">authors</code> and <code class="language-plaintext highlighter-rouge">authored</code>.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"name"</span>
<span class="k">FROM</span> <span class="nv">"authors"</span>
<span class="k">WHERE</span> <span class="nv">"id"</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"author_id"</span>
    <span class="k">FROM</span> <span class="nv">"authored"</span>
    <span class="k">WHERE</span> <span class="nv">"book_id"</span> <span class="o">=</span> <span class="p">(</span>
      <span class="k">SELECT</span> <span class="nv">"id"</span>
      <span class="k">FROM</span> <span class="nv">"books"</span>
      <span class="k">WHERE</span> <span class="nv">"title"</span> <span class="o">=</span> <span class="s1">'Flights'</span>
    <span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>The first query that is run is the most deeply nested one — finding the ID of the book Flights. Then, the ID of the author(s) who wrote Flights is found. Last, this is used to retrieve the author name(s).</p>
  </li>
</ul>

<h2 id="in"><code class="language-plaintext highlighter-rouge">IN</code></h2>

<ul>
  <li data-marker="*">This keyword is used to check whether the desired value is <em>in</em> a given list or set of values.</li>
  <li data-marker="*">The relationship between authors and books is many-to-many. This means that it is possible a given author has written more than one book. To find the names of all books in the database written by Fernanda Melchor, we would use the <code class="language-plaintext highlighter-rouge">IN</code> keyword as follows.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"title"</span>
<span class="k">FROM</span> <span class="nv">"books"</span>
<span class="k">WHERE</span> <span class="nv">"id"</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"book_id"</span>
    <span class="k">FROM</span> <span class="nv">"authored"</span>
    <span class="k">WHERE</span> <span class="nv">"author_id"</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="nv">"id"</span>
        <span class="k">FROM</span> <span class="nv">"authors"</span>
        <span class="k">WHERE</span> <span class="nv">"name"</span> <span class="o">=</span> <span class="s1">'Fernanda Melchor'</span>
    <span class="p">)</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>Note that the innermost query uses <code class="language-plaintext highlighter-rouge">=</code> and not the <code class="language-plaintext highlighter-rouge">IN</code> operator. This is because we expect to find just one author named Fernanda Melchor.</p>
  </li>
</ul>

<h3 id="questions-2">Questions</h3>

<blockquote>
  <p>What if the value of an inner query is not found?</p>
</blockquote>

<ul>
  <li data-marker="*">In this case, the inner query would return nothing, prompting the outer query to also return nothing. The outer query is thus dependent on the results of the inner query.</li>
</ul>

<blockquote>
  <p>Is it necessary to use four spaces to indent a subquery?</p>
</blockquote>

<ul>
  <li data-marker="*">No. The number of spaces used to indent a subquery can vary, as can the length of each line in the query. But the central idea behind breaking up queries and indenting subqueries is to make them readable.</li>
</ul>

<blockquote>
  <p>How can we implement a many-to-one relationship between tables?</p>
</blockquote>

<ul>
  <li data-marker="*">Consider the situation wherein a book is co-written by multiple authors. We would have an <code class="language-plaintext highlighter-rouge">authored</code> table with multiple entries for the same book ID. Each of these entries would have a different author ID. It is worth noting that foreign key values can be repeated within a table, but primary key values are always unique.</li>
</ul>

<h2 id="join"><code class="language-plaintext highlighter-rouge">JOIN</code></h2>

<ul>
  <li data-marker="*">This keyword allows us to combine two or more tables together.</li>
  <li data-marker="*">
    <p>To understand how <code class="language-plaintext highlighter-rouge">JOIN</code> works, consider a database of sea lions and their migration patterns. Here is a snapshot of the database.</p>

    <p class="w-50"><img src="../Images/871d96677770fc511517b0f7c0c5d5a5.png" alt="&quot;Sea Lions database with tables: sea lions, migrations&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p69.jpg"/></p>
  </li>
  <li data-marker="*">To find out how far the sea lion Spot travelled, or answer similar questions about each sea lion, we could use nested queries. Alternately, we could join the tables <code class="language-plaintext highlighter-rouge">sea lions</code> and <code class="language-plaintext highlighter-rouge">migrations</code> together such that each sea lion also has its corresponding information as an extension of the same row.</li>
  <li data-marker="*">We can join the tables on the sea lion ID (the common factor between the two tables) to ensure that the correct rows are lined up against each other.</li>
  <li data-marker="*">Before testing this out, make sure to exit <code class="language-plaintext highlighter-rouge">longlist.db</code> using the <code class="language-plaintext highlighter-rouge">.quit</code> SQLite command. Then, open up <code class="language-plaintext highlighter-rouge">sea_lions.db</code>.</li>
  <li data-marker="*">To join the tables
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="nv">"sea_lions"</span>
<span class="k">JOIN</span> <span class="nv">"migrations"</span> <span class="k">ON</span> <span class="nv">"migrations"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="nv">"sea_lions"</span><span class="p">.</span><span class="nv">"id"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Notice that:</p>
    <ul>
      <li data-marker="*">The <code class="language-plaintext highlighter-rouge">ON</code> keyword is used to specify which values match between the tables being joined. It is not possible to join tables without matching values.</li>
      <li data-marker="*">If there are any IDs in one table not present in the other, this row will not be present in the joined table. This kind of join is called an <code class="language-plaintext highlighter-rouge">INNER JOIN</code>.</li>
    </ul>
  </li>
  <li data-marker="*">Some other ways of joining tables that allow us to retain certain unmatched IDs are <code class="language-plaintext highlighter-rouge">LEFT JOIN</code>, <code class="language-plaintext highlighter-rouge">RIGHT JOIN</code> and <code class="language-plaintext highlighter-rouge">FULL JOIN</code>. Each of these is a kind of <code class="language-plaintext highlighter-rouge">OUTER JOIN</code>.</li>
  <li data-marker="*">A <code class="language-plaintext highlighter-rouge">LEFT JOIN</code> prioritizes the data in the left (or first) table.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="nv">"sea_lions"</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">"migrations"</span> <span class="k">ON</span> <span class="nv">"migrations"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="nv">"sea_lions"</span><span class="p">.</span><span class="nv">"id"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>This query would retain all sea lion data from the <code class="language-plaintext highlighter-rouge">sea_lions</code> table — the left one. Some rows in the joined table could be partially blank. This would happen if the right table didn’t have data for a particular ID.</p>
  </li>
  <li data-marker="*">Similarly, a <code class="language-plaintext highlighter-rouge">RIGHT JOIN</code> retains all the rows from the right (or second) table. A <code class="language-plaintext highlighter-rouge">FULL JOIN</code> allows us to see the entirety of all tables.</li>
  <li data-marker="*">As we can observe, an <code class="language-plaintext highlighter-rouge">OUTER JOIN</code> could lead to empty or <code class="language-plaintext highlighter-rouge">NULL</code> values in the joined table.</li>
  <li data-marker="*">Both tables in the sea lions database have the column <code class="language-plaintext highlighter-rouge">id</code>. Since the value on which we are joining the tables has the same column name in both tables, we can actually omit the <code class="language-plaintext highlighter-rouge">ON</code> section of the query while joining.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="nv">"sea_lions"</span>
<span class="k">NATURAL</span> <span class="k">JOIN</span> <span class="nv">"migrations"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Notice that the result does not have a duplicate <code class="language-plaintext highlighter-rouge">id</code> column in this case. Also, this join works similarly to an <code class="language-plaintext highlighter-rouge">INNER JOIN</code>.</p>
  </li>
</ul>

<h3 id="questions-3">Questions</h3>

<blockquote>
  <p>In the sea lions database, how are the IDs created? Do they come from the <code class="language-plaintext highlighter-rouge">sea_lions</code> table or the <code class="language-plaintext highlighter-rouge">migrations</code> table?</p>
</blockquote>

<ul>
  <li data-marker="*">The ID of each sea lion likely came from researchers tracking the migration patterns of these sea lions. That is to say, the IDs were not generated in either of the tables, but were assigned at the source of the data itself.</li>
</ul>

<blockquote>
  <p>If we are trying to join three tables, how can we know which the left or right tables are?</p>
</blockquote>

<ul>
  <li data-marker="*">For each <code class="language-plaintext highlighter-rouge">JOIN</code> statement, the first table before the keyword is the left one. The one that is involved in the <code class="language-plaintext highlighter-rouge">JOIN</code> keyword is the right table.</li>
</ul>

<blockquote>
  <p>When we join tables, does the resulting joined table get saved? Can we reference it later without joining again?</p>
</blockquote>

<ul>
  <li data-marker="*">In the way that we are using <code class="language-plaintext highlighter-rouge">JOIN</code>, the result is a temporary table or a result set. It can be used for the duration of the query.</li>
</ul>

<blockquote>
  <p>There’s many different kinds of <code class="language-plaintext highlighter-rouge">JOIN</code>. Is there a default one we should use?</p>
</blockquote>

<ul>
  <li data-marker="*">The simplest kind — just <code class="language-plaintext highlighter-rouge">JOIN</code> — is actually an <code class="language-plaintext highlighter-rouge">INNER JOIN</code> and that’s the default for SQL.</li>
</ul>

<h2 id="sets">Sets</h2>

<ul>
  <li data-marker="*">Before diving into sets, we will need to exit the database of sea lions and switch to <code class="language-plaintext highlighter-rouge">longlist.db</code>.</li>
  <li data-marker="*">On running a query, the results we see are called a result set. This is a kind of set in SQL.</li>
  <li data-marker="*">
    <p>Let’s take another example. In our database of books, we have authors and translators. A person could be either an author or a translator. If the two sets have an intersection, it is also a possible that a person could be both an author and a translator of books. We can use the <code class="language-plaintext highlighter-rouge">INTERSECT</code> operator to find this set.</p>

    <p class="w-50"><img src="../Images/185f6a12c8577b77276b7f862db6f7ea.png" alt="&quot;Intersection Set of Authors and Translators&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p100.jpg"/></p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"name"</span> <span class="k">FROM</span> <span class="nv">"translators"</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="nv">"name"</span> <span class="k">FROM</span> <span class="nv">"authors"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>If a person is either an author or a translator, or both, they belong to the union of the two sets. In other words, this set is formed by combining the author and translator sets.</p>

    <p class="w-50"><img src="../Images/ef4d181575995715654ee7725381dd1e.png" alt="&quot;Union Set of Authors and Translators&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p102.jpg"/></p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"name"</span> <span class="k">FROM</span> <span class="nv">"translators"</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="nv">"name"</span> <span class="k">FROM</span> <span class="nv">"authors"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Notice that every author and every translator is included in this result set, but only once!</p>
  </li>
  <li data-marker="*">A minor adjustment to the previous query gives us the profession of the person in the result set, based on whether they are an author or a translator.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="s1">'author'</span> <span class="k">AS</span> <span class="nv">"profession"</span><span class="p">,</span> <span class="nv">"name"</span> 
<span class="k">FROM</span> <span class="nv">"authors"</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="s1">'translator'</span> <span class="k">AS</span> <span class="nv">"profession"</span><span class="p">,</span> <span class="nv">"name"</span> 
<span class="k">FROM</span> <span class="nv">"translators"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">
    <p>Everyone who is an author and <em>only</em> an author is included in the following set. The <code class="language-plaintext highlighter-rouge">EXCEPT</code> keyword can be used to find such a set. In other words, the set of translators is subtracted from the set of authors to form this one.</p>

    <p class="w-50"><img src="../Images/e7968694b86d0d8aa69073fa11996dc0.png" alt="&quot;EXCEPT set including people who are only authors&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p104.jpg"/></p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"name"</span> <span class="k">FROM</span> <span class="nv">"authors"</span>
<span class="k">EXCEPT</span>
<span class="k">SELECT</span> <span class="nv">"name"</span> <span class="k">FROM</span> <span class="nv">"translators"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>We can verify that no author-translator from the intersection set appears in this result set.</p>
  </li>
  <li data-marker="*">Similarly, it is possible to find a set of people who are only translators using <code class="language-plaintext highlighter-rouge">EXCEPT</code>.</li>
  <li data-marker="*">
    <p>How can we find this set of people who are either authors or translators but not both?</p>

    <p class="w-50"><img src="../Images/01c633b1019b5ccabc983b673cf3df2a.png" alt="&quot;Set — people who are either authors or translators but not both&quot;" data-original-src="https://cs50.harvard.edu/sql/notes/1/images/p107.jpg"/></p>
  </li>
  <li data-marker="*">These operators could be useful to answer many different questions. For example, we can find the books that Sophie Hughes and Margaret Jull Costa have translated together.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"book_id"</span> <span class="k">FROM</span> <span class="nv">"translated"</span>
<span class="k">WHERE</span> <span class="nv">"translator_id"</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"id"</span> <span class="k">from</span> <span class="nv">"translators"</span>
    <span class="k">WHERE</span> <span class="nv">"name"</span> <span class="o">=</span> <span class="s1">'Sophie Hughes'</span>
<span class="p">)</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="nv">"book_id"</span> <span class="k">FROM</span> <span class="nv">"translated"</span>
<span class="k">WHERE</span> <span class="nv">"translator_id"</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="nv">"id"</span> <span class="k">from</span> <span class="nv">"translators"</span>
    <span class="k">WHERE</span> <span class="nv">"name"</span> <span class="o">=</span> <span class="s1">'Margaret Jull Costa'</span>
<span class="p">);</span>
</code></pre></div>    </div>
    <p>Each of the nested queries here finds the IDs of the books for one translator. The <code class="language-plaintext highlighter-rouge">INTERSECT</code> keyword is used to intersect the resulting sets and give us the books they have collaborated on.</p>
  </li>
</ul>

<h3 id="questions-4">Questions</h3>

<blockquote>
  <p>Could we use <code class="language-plaintext highlighter-rouge">INTERSECT</code>, <code class="language-plaintext highlighter-rouge">UNION</code> etc. to perform operations on 3-4 sets?</p>
</blockquote>

<ul>
  <li data-marker="*">Yes, absolutely. To intersect 3 sets, we would have to use the <code class="language-plaintext highlighter-rouge">INTERSECT</code> operator twice. An important note — we have to make sure to have the same number and same types of columns in the sets to be combined using <code class="language-plaintext highlighter-rouge">INTERSECT</code>, <code class="language-plaintext highlighter-rouge">UNION</code> etc.</li>
</ul>

<h2 id="groups">Groups</h2>

<ul>
  <li data-marker="*">Consider the <code class="language-plaintext highlighter-rouge">ratings</code> table. For each book, we want to find the average rating of the book. To do this, we would first need to group ratings together by book and then average the ratings out for each book (each group).
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"book_id"</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="nv">"rating"</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">"average rating"</span>
<span class="k">FROM</span> <span class="nv">"ratings"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nv">"book_id"</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>In this query, the <code class="language-plaintext highlighter-rouge">GROUP BY</code> keyword was used to create groups for each book and then collapse the ratings of the group into an average rating!</p>
  </li>
  <li data-marker="*">Now, we only want to see the books that are well-rated, with an average rating of over 4.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"book_id"</span><span class="p">,</span> <span class="n">ROUND</span><span class="p">(</span><span class="k">AVG</span><span class="p">(</span><span class="nv">"rating"</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">"average rating"</span>
<span class="k">FROM</span> <span class="nv">"ratings"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nv">"book_id"</span>
<span class="k">HAVING</span> <span class="nv">"average rating"</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>Note that the <code class="language-plaintext highlighter-rouge">HAVING</code> keyword is used here to specify a condition for the groups, instead of <code class="language-plaintext highlighter-rouge">WHERE</code> (which can only be used to specify conditions for individual rows).</p>
  </li>
</ul>

<h3 id="questions-5">Questions</h3>

<blockquote>
  <p>Is it possible to see the number of ratings given to each book?</p>
</blockquote>

<ul>
  <li data-marker="*">Yes, this would require a slight modification with the use of the <code class="language-plaintext highlighter-rouge">COUNT</code> keyword.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"book_id"</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="nv">"rating"</span><span class="p">)</span>
<span class="k">FROM</span> <span class="nv">"ratings"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nv">"book_id"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p>Is it also possible to sort the data obtained here?</p>
</blockquote>

<ul>
  <li data-marker="*">
    <p>Yes, it is. Say we wanted to find the average ratings per well-rated book, ordered in descending order.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="nv">"book_id"</span><span class="p">,</span> <span class="n">ROUND</span><span class="p">(</span><span class="k">AVG</span><span class="p">(</span><span class="nv">"rating"</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">"average rating"</span>
<span class="k">FROM</span> <span class="nv">"ratings"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nv">"book_id"</span>
<span class="k">HAVING</span> <span class="nv">"average rating"</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="nv">"average rating"</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="fin">Fin</h2>

<ul>
  <li data-marker="*">This brings us to the conclusion of Lecture 1 about relating!</li>
</ul>


                    
</body>
</html>