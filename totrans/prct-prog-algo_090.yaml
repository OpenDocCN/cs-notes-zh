- en: 2.1   Elementary Sorts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/21elementary](https://algs4.cs.princeton.edu/21elementary)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section, we shall study two elementary sorting methods (selection sort
    and insertion sort) and a variation of one of them (shellsort).
  prefs: []
  type: TYPE_NORMAL
- en: Rules of the game.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our primary concern is algorithms for rearranging arrays of items where each
    item contains a *key*. The objective is to rearrange the items such that their
    keys are in ascending order. In Java, the abstract notion of a key is captured
    in a built-in mechanism—the `Comparable` interface. With but a few exceptions,
    our sort code refers to the data only through two operations: the method `less()`
    that compares objects and the method `exch()` that exchanges them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Sorting cost model.* When studying sorting algorithms, we count *compares*
    and *exchanges*. For algorithms that do not use exchanges, we count *array accesses*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extra memory.* The sorting algorithms we consider divide into two basic types:
    those that sort *in place* (no extra memory except perhaps for a small function-call
    stack or a constant number of instance variables), and those that need enough
    extra memory to hold another copy of the array to be sorted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Types of data.* Our sort code is effective for any type of data that implements
    Java''s [Comparable interface](http://download.oracle.com/javase/6/docs/api/java/lang/Comparable.html).
    This means that there is a method `compareTo()` for which `v.compareTo(w)` returns
    an integer that is negative, zero, or positive when v < w, v = w, or v > w, respectively.
    The method must implement a *total order*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reflexive:* for all v, v = v.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Antisymmetric:* for all v and w, if (v < w) then (w > v); and if (v = w) then
    (w = v).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transitive:* for all v, w, and x, if (v ≤ w) and (w ≤ x), then v ≤ x.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, `v.compareTo(w)` must throw an exception if `v` and `w` are of
    incompatible types or if either is `null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Date.java](Date.java.html) illustrates how to implement the `Comparable` interface
    for a user-defined type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Selection sort.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the simplest sorting algorithms works as follows: First, find the smallest
    item in the array, and exchange it with the first entry. Then, find the next smallest
    item and exchange it with the second entry. Continue in this way until the entire
    array is sorted. This method is called *selection sort* because it works by repeatedly
    selecting the smallest remaining item. [Selection.java](Selection.java.html) is
    an implementation of this method.![Selection sort](../Images/fd03f1830b21d56e7b13a560bca5ccac.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selection sort uses ~n²/2 compares and n exchanges to sort an array of length
    n.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm that people often use to sort bridge hands is to consider the
    cards one at a time, inserting each into its proper place among those already
    considered (keeping them sorted). In a computer implementation, we need to make
    space for the current item by moving larger items one position to the right, before
    inserting the current item into the vacated position. [Insertion.java](Insertion.java.html)
    is an implementation of this method, which is called *insertion sort*.![Selection
    sort](../Images/8c81be6793c070e4423b9dd21b9ae032.png)
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For randomly ordered arrays of length N with with distinct keys, insertion sort
    uses ~N²/4 compares and ~N²/4 exchanges on the average. The worst case is ~ N²/2
    compares and ~ N²/2 exchanges and the best case is N-1 compares and 0 exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insertion sort works well for certain types of nonrandom arrays that often
    arise in practice, even if they are huge. An *inversion* is a pair of keys that
    are out of order in the array. For instance, E X A M P L E has 11 inversions:
    E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E. If the number of inversions
    in an array is less than a constant multiple of the array size, we say that the
    array is *partially sorted*.'
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of exchanges used by insertion sort is equal to the number of inversions
    in the array, and the number of compares is at least equal to the number of inversions
    and at most equal to the number of inversions plus the array size.
  prefs: []
  type: TYPE_NORMAL
- en: Property.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For randomly ordered arrays of distinct values, the running times of insertion
    sort and selection sort are quadratic and within a small constant factor of one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: '[SortCompare.java](SortCompare.java.html) uses the `sort()` methods in the
    classes named as command-line arguments to perform the given number of experiments
    (sorting arrays of the given size) and prints the ratio of the observed running
    times of the algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing sorting algorithms.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use a simple visual representation to help describe the properties of sorting
    algorithms. We use vertical bars, to be sorted by their heights. [SelectionBars.java](SelectionBars.java.html)
    and [InsertionBars.java](InsertionBars.java.html) produce these visualizations.![Visualization
    of selection sort and insertion sort](../Images/a487876e041ee06ce4ee3dcdc3057482.png)
  prefs: []
  type: TYPE_NORMAL
- en: Shellsort.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shellsort is a simple extension of insertion sort that gains speed by allowing
    exchanges of entries that are far apart, to produce partially sorted arrays that
    can be efficiently sorted, eventually by insertion sort. The idea is to rearrange
    the array to give it the property that taking every *h*th entry (starting anywhere)
    yields a sorted sequence. Such an array is said to be *h-sorted*.![An h-sorted
    file in shellsort](../Images/85bc085c67a1f1ab4b906a56a924edfe.png)By h-sorting
    for some large values of h, we can move entries in the array long distances and
    thus make it easier to h-sort for smaller values of h. Using such a procedure
    for any increment sequence of values of h that ends in 1 will produce a sorted
    array: that is shellsort. [Shell.java](Shell.java.html) is an implementation of
    this method.![Shellsort](../Images/90c4382307c869b7e4469d79eb4b47b3.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ShellBars.java](ShellBars.java.html) produces a visualization of shellsort.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shellsort visualization](../Images/c07f7ba07dd237c438da57b76eb2d7b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Property.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of compares used by shellsort with the increments 1, 4, 13, 40, 121,
    364, ... is bounded by a small multiple of N times the number of increments used.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of compares used by shellsort with the increments 1, 4, 13, 40, 121,
    364, ... is O(N^(3/2)).
  prefs: []
  type: TYPE_NORMAL
- en: Q + A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** The compiler gives a warning when I compile [Insertion.java](Insertion.java.html).
    Is ther any way to avoid this?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**A.** Yes, if you use static generics, as in [InsertionPedantic.java](InsertionPedantic.java.html).
    It leads to awkward (but warning-free) code.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show in the style of the example trace with selection sort, how selection sort
    sorts the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Selection sort](../Images/90ee2c2bfcb9f094a1ef28718406d375.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: What is the maximum number of exchanges involving any particular item during
    selection sort? What is the average number of exchanges involving one specific
    item x?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* The average number of exchanges is exactly 2 because there are
    exactly n exchanges and n items (and each exchange involves two items). The maximum
    number of exchanges is n, as in the following example.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Selection sort](../Images/c2c99a075481c6ecfcfb4691ebb4267c.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Show in the style of the example trace with insertion sort, how insertion sort
    sorts the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Selection sort](../Images/a6fa9568323c9ff3ae0c8795bef1ea3b.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Which method runs fastest for an array with all keys identical, selection sort
    or insertion sort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Insertion sort runs in linear time when all keys are equal.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose that we use insertion sort on a randomly ordered array where items have
    only one of three key values. Is the running time linear, quadratic, or something
    in between?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Quadratic.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Show in the style of the example trace with shellsort, how shellsort sort sorts
    the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Shellsort trace](../Images/68cad3c6ad19eeeb0f31f0c8fdf1fae8.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Why not use selection sort for *h*-sorting in shellsort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Insertion sort is faster on inputs that are partially-sorted.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creative Problems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Expensive exchange.** A clerk at a shipping company is charged with the task
    of rearranging a number of large crates in order of the time they are to be shipped
    out. Thus, the cost of compares is very low (just look at the labels) relative
    to the cost of exchanges (move the crates). The warehouse is nearly full: there
    is extra space sufficient to hold any one of the crates, but not two. Which sorting
    method should the clerk use?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* Use selection sort because it minimizes the number of exchanges.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Visual trace.** Modify your solution to the previous exercise to make [Insertion.java](Insertion.java.html)
    and [Selection.java](Selection.java.html) produce visual traces such as those
    depicted in this section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* [TraceInsertion.java](TraceInsertion.java.html), [TraceSelection.java](TraceSelection.java.html),
    and [TraceShell.java](TraceShell.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Comparable transactions.** Expand your implementation of [Transaction.java](Transaction.java.html)
    so that it implements `Comparable`, such that transactions are kept in order by
    amount.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transaction sort test client.** Write a class [SortTransactions.java](SortTransactions.java.html)
    that consists of a static method `main()` that reads a sequence of transactions
    from standard input, sorts them, and prints the result on standard output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Insertion sort with sentinel.** Develop an implementation [InsertionX.java](InsertionX.java.html)
    of insertion sort that eliminates the j > 0 test in the inner loop by first putting
    the smallest item into position. Use [SortCompare.java](SortCompare.java.html)
    to evaluate the effectiveness of doing so. *Note*: it is often possible to avoid
    an index-out-of-bounds test in this way—the item that enables the test to be eliminated
    is known as a *sentinel*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Insertion sort without exchanges.** Develop an implementation [InsertionX.java](InsertionX.java.html)
    of insertion sort that moves larger items to the right one position rather than
    doing full exchanges. Use [SortCompare.java](SortCompare.java.html) to evaluate
    the effectiveness of doing so.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Sorting networks.** Write a program [Sort3.java](Sort3.java.html) with three
    `if` statements (and no loops) that reads in three integers *a*, *b*, and *c*
    from the command line and prints them out in ascending order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Oblivious sorting network.** Convince yourself that the following code fragment
    rearranges the integers stored in the variables A, B, C, and D so that A <= B
    <= C <= D.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Devise a sequence of statements that would sort 5 integers. How many `if` statements
    does your program use?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Optimal oblivious sorting networks.** Create a program that sorts four integers
    using only 5 `if` statements, and one that sorts five integers using only 9 `if`
    statements of the type above? Oblivious sorting networks are useful for implementing
    sorting algorithms in hardware. How can you check that your program works for
    all inputs?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer:* [Sort4.java](Sort4.java.html) sorts 4 items using 5 compare-exchanges.
    [Sort5.java](Sort5.java.html) sorts 5 items using 9 compare-exchanges.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [0-1 principle](http://en.wikipedia.org/wiki/Sorting_network) says that
    you can verify the correctness of a (deterministic) sorting network by checking
    whether it correctly sorts an input that is a sequence of 0s and 1s. Thus, to
    check that `Sort5.java` works, you only need to test it on the 2^5 = 32 possible
    inputs of 0s and 1s.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Optimal oblivious sorting (challenging).** Find an optimal sorting network
    for 6, 7, and 8 inputs, using 12, 16, and 19 `if` statements of the form in the
    previous problem, respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: [Sort6.java](Sort6.java.html) is the solution for sorting 6 items.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Optimal non-oblivious sorting.** Write a program that sorts 5 inputs using
    only 7 comparisons. *Hint*: First compare the first two numbers, the second two
    numbers, and the larger of the two groups, and label them so that a < b < d and
    c < d. Second, insert the remaining item e into its proper place in the chain
    a < b < d by first comparing against b, then either a or d depending on the outcome.
    Third, insert c into the proper place in the chain involving a, b, d, and e in
    the same manner that you inserted e (with the knowledge that c < d). This uses
    3 (first step) + 2 (second step) + 2 (third step) = 7 comparisons. This method
    was first discovered by H. B. Demuth in 1956.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stupidsort.** Analyze the running time (worst case and best case), correctness,
    and stability of the following sorting algorithm. Scan the array from left to
    right until you find two consecutive items that are out-of-place. Swap them, and
    start over from the beginning. Repeat until the scan reaches the end of the array.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Consider also the following recursive variant and analyze the worst case memory
    usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Stoogesort.** Analyze the running time and correctness of the following recursive
    sorting algorithm: if the leftmost item is larger than the rightmost item, swap
    them. If there are 2 or more items in the current subarray, (i) sort the initial
    two-thirds of the array recursively, (ii) sort the final two-thirds of the array,
    (iii) sort the initial two-thirds of the array again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Guess-sort.** Pick two indices i and j at random; if a[i] > a[j], then swap
    them. Repeat until the input is sorted. Analyze the expected running time of this
    algorithm. *Hint*: after each swap, the number of inversions strictly decreases.
    If there are m bad pairs, then the expected time to find a bad pair is Theta(n^2/m).
    Summing up from m =1 to n^2 yields O(N^2 log N) overall, ala coupon collector.
    This bound is tight: consider input 1 0 3 2 5 4 7 6 ...'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bogosort.** Bogosort is a randomized algorithm that works by throwing the
    N cards up in the air, collecting them, and checking whether they wound up in
    increasing order. If they didn''t, repeat until they do. Implement bogosort using
    the shuffling algorithm from Section 1.4\. Estimate the running time as a function
    of N.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Slow sort.** Consider the following sorting algorithm: choose two integer
    i and j at random. If i < j, but a[i] > a[j], swap them. Repeat until the array
    is in ascending order. Argue that the algorithm will eventually finish (with probability
    1). How long will it takes as a function of N? *Hint*: How many swaps will it
    make in the worst case?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Minimum number of moves to sort an array.** Given a list of N keys, a *move
    operation* consists of removing any one key from the list and appending it to
    the end of the list. No other operations are permitted. Design an algorithm that
    sorts a given list using the minimum number of moves.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Guess-Sort.** Consider the following exchanged-based sorting algorithm: pick
    two random indices; if a[i] and a[j] are an inversion, swap them; repeat. Show
    that the expected time to sort an array of size N is at most N^2 log N. See [this
    paper](http://www.sciencedirect.com/science/article/pii/S0166218X04001131?np=y)
    for an analysis and related sorting algorithm known as Fun-Sort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Swapping an inversion.** Given an array of N keys, let a[i] and a[j] be an
    inversion (i < j but a[i] > a[j]). Prove or disprove: swapping a[i] and a[j] strictly
    decreases the number of inversions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Binary insertion sort.** Develop an implementation [BinaryInsertion.java](BinaryInsertion.java.html)
    of insertion sort that uses binary search to find the insertion point j for entry
    a[i] and then shifts all of the entries a[j] to a[i-1] over one position to the
    right. The number of compares to sort an array of length n should be ~ n lg n
    in the worst case. Note that the number of array accesses will still be quadratic
    in the worst case. Use [SortCompare.java](SortCompare.java.html) to evaluate the
    effectiveness of doing so.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
