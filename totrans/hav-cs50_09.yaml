- en: Lecture 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/x/notes/7/](https://cs50.harvard.edu/x/notes/7/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Flat-File Database](#flat-file-database)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Relational Databases](#relational-databases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SELECT](#select)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[INSERT](#insert)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DELETE](#delete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UPDATE](#update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IMDb](#imdb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JOIN`s](#joins)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Indexes](#indexes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using SQL in Python](#using-sql-in-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Race Conditions](#race-conditions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Injection Attacks](#sql-injection-attacks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous weeks, we introduced you to Python, a high-level programming language
    that utilized the same building blocks we learned in C. However, we introduced
    this new language not for the purpose of learning “just another language.” Instead,
    we do so because some tools are better for some jobs and not so great for others!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This week, we will be continuing more syntax related to Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we will be integrating this knowledge with data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will be discussing *SQL* or *Structured Query Language*, a domain-specific
    way by which we can interact with and modify data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, one of the goals of this course is to learn to program generally –
    not simply how to program in the languages described in this course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat-File Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have likely seen before, data can often be described in patterns of columns
    and rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreadsheets like those created in Microsoft Excel and Google Sheets can be
    outputted to a `csv` or *comma-separated values* file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at a `csv` file, you’ll notice that the file is flat in that all
    of our data is stored in a single table represented by a text file. We call this
    form of data a *flat-file database*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All data is stored row by row. Each column is separated by a comma or another
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python comes with native support for `csv` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, download [favorites.csv](https://cdn.cs50.net/2023/fall/lectures/7/src7/favorites/favorites.csv)
    and upload it to your file explorer inside [cs50.dev](https://cs50.dev). Second,
    examining this data, notice that the first row is special in that it defines each
    column. Then, each record is stored row by row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your terminal window, type `code favorites.py` and write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `csv` library is imported. Further, we created a `reader` that
    will hold the result of `csv.reader(file)`. The `csv.reader` function reads each
    row from the file, and in our code, we store the results in `reader`. `print(row[1])`,
    therefore, will print the language from the `favorites.csv` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can improve your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `favorite` is stored and then printed. Also, notice that we use
    the `next` function to skip to the next line of our reader.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One of the disadvantages of the above approach is that we are trusting that
    `row[1]` is always the favorite. However, what would happen if the columns had
    been moved around?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can fix this potential issue. Python also allows you to index by the keys
    of a list. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this example directly utilizes the `language` key in the print statement.
    `favorite` indexes into the `reader` dictionary of `row["language"]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This could be further simplified to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To count the number of favorite languages expressed in the `csv` file, we can
    do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that each language is counted using `if` statements. Further, notice
    the double equal `==` signs in those `if` statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Python allows us to use a dictionary to count the `counts` of each language.
    Consider the following improvement upon our code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the value in `counts` with the key `favorite` is incremented when
    it exists already. If it does not exist, we define `counts[favorite]` and set
    it to 1\. Further, the formatted string has been improved to present the `counts[favorite]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Python also allows sorting `counts`. Improve your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the `sorted(counts)` at the bottom of the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you look at the parameters for the `sorted` function in the Python documentation,
    you will find it has many built-in parameters. You can leverage some of these
    built-in parameters as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the arguments passed to `sorted`. The `key` argument allows you to tell
    Python the method you wish to use to sort items. In this case `counts.get` is
    used to sort by the values. `reverse=True` tells `sorted` to sort from largest
    to smallest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Python has numerous libraries that we can utilize in our code. One of these
    libraries is `collections`, from which we can import `Counter`. `Counter` will
    allow you to access the counts of each language without the headaches of all the
    `if` statements seen in our previous code. You can implement as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `counts = Counter()` enables the use of this imported `Counter` class
    from `collections`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more about [sorted](https://docs.python.org/3/howto/sorting.html)
    in the [Python Documentation](https://docs.python.org/3/howto/sorting.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google, X, and Meta all use relational databases to store their information
    at scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases store data in rows and columns in structures called *tables*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL allows for four types of commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These four operations are affectionately called *CRUD*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a database with the SQL syntax `CREATE TABLE table (column type,
    ...);`. But where do you run this command?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3` is a type of SQL database that has the core features required for
    this course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a SQL database at the terminal by typing `sqlite3 favorites.db`.
    Upon being prompted, we will agree that we want to create `favorites.db` by pressing
    `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice a different prompt as we are now using a program called `sqlite`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can put `sqlite` into `csv` mode by typing `.mode csv`. Then, we can import
    our data from our `csv` file by typing `.import favorites.csv favorites`. It seems
    that nothing has happened!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can type `.schema` to see the structure of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read items from a table using the syntax `SELECT columns FROM table`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, you can type `SELECT * FROM favorites;` which will print every
    row in `favorites`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get a subset of the data using the command `SELECT language FROM favorites;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL supports many commands to access data, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For example, you can type `SELECT COUNT(*) FROM favorites;`. Further, you can
    type `SELECT DISTINCT language FROM favorites;` to get a list of the individual
    languages within the database. You could even type `SELECT COUNT(DISTINCT language)
    FROM favorites;` to get a count of those.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL offers additional commands we can utilize in our queries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we use `--` to write a comment in SQL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SELECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For example, we can execute `SELECT COUNT(*) FROM favorites WHERE language =
    'C';`. A count is presented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we could type `SELECT COUNT(*) FROM favorites WHERE language = 'C'
    AND problem = 'Hello, World';`. Notice how the `AND` is utilized to narrow our
    results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we could execute `SELECT language, COUNT(*) FROM favorites GROUP
    BY language;`. This would offer a temporary table that would show the language
    and count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could improve this by typing `SELECT language, COUNT(*) FROM favorites GROUP
    BY language ORDER BY COUNT(*);`. This will order the resulting table by the `count`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Likewise, we could execute `SELECT COUNT(*) FROM favorites WHERE language =
    'C' AND (problem = 'Hello, World' OR problem = 'Hello, It''s Me');`. Do notice
    that there are two `''` marks as to allow the use of single quotes in a way that
    does not confuse SQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we could execute `SELECT COUNT(*) FROM favorites WHERE language = 'C'
    AND problem LIKE 'Hello, %';` to find any problems that start with `Hello,` (including
    a space).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also group the values of each language by executing `SELECT language,
    COUNT(*) FROM favorites GROUP BY language;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can order the output as follows: `SELECT language, COUNT(*) FROM favorites
    GROUP BY language ORDER BY COUNT(*) DESC;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can even create aliases, like variables in our queries: `SELECT language,
    COUNT(*) AS n FROM favorites GROUP BY language ORDER BY n DESC;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can limit our output to 1 or more values: `SELECT language, COUNT(*)
    AS n FROM favorites GROUP BY language ORDER BY n DESC LIMIT 1;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also `INSERT` into a SQL database utilizing the form `INSERT INTO table
    (column...) VALUES(value, ...);`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can execute `INSERT INTO favorites (language, problem) VALUES ('SQL', 'Fiftyville');`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can verify the addition of this favorite by executing `SELECT * FROM favorites;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DELETE` allows you to delete parts of your data. For example, you could `DELETE
    FROM favorites WHERE Timestamp IS NULL;`. This deletes any record where the `Timestamp`
    is `NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UPDATE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also utilize the `UPDATE` command to update your data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, you can execute `UPDATE favorites SET language = 'SQL', problem
    = 'Fiftyville';`. This will result in overwriting all previous statements where
    C and Scratch were the favorite programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that these queries have immense power. Accordingly, in the real-world
    setting, you should consider who has permissions to execute certain commands and
    if you have backups available!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IMDb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can imagine a database that we might want to create to catalog various TV
    shows. We could create a spreadsheet with columns like `title`, `star`, `star`,
    `star`, `star`, and more stars. A problem with this approach is that it has a
    lot of wasted space. Some shows may have one star. Others may have dozens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could separate our database into multiple sheets. We could have a `shows`
    sheet, a `stars` sheet, and a `people` sheet. On the `people` sheet, each person
    could have a unique `id`. On the `shows` sheet, each show could have a unique
    `id` too. On a third sheet called `stars` we could relate how each show has people
    for each show by having a `show_id` and `person_id`. While this is an improvement,
    this is not an ideal database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IMDb offers a database of people, shows, writers, stars, genres, and ratings.
    Each of these tables is related to one another as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![six boxes that represent various sql tables arrows are drawn to each showing
    their many relationships with one another](../Images/db89fb0977f2fee293de5c9dd3427a4f.png
    "imdb relationships")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: After downloading [`shows.db`](https://cdn.cs50.net/2024/fall/lectures/7/src7/imdb/shows.db),
    you can execute `sqlite3 shows.db` in your terminal window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s zero in on the relationship between two tables within the database called
    `shows` and `ratings`. The relationship between these two tables can be illustrated
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![two boxes one called shows and the other called ratings](../Images/caeb1577c462d26137d75024dc7b974a.png
    "imdb shows and ratings")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To illustrate the relationship between these tables, we could execute the following
    command: `SELECT * FROM ratings LIMIT 10;`. Examining the output, we could execute
    `SELECT * FROM shows LIMIT 10;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examining `shows` and `rating`, we can see these have a one-to-one relationship:
    One show has one rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the database, upon executing `.schema` you will find not only
    each of the tables but the individual fields inside each of these fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More specifically, you could execute `.schema shows` to understand the fields
    inside `shows`. You can also execute `.schema ratings` to see the fields inside
    `ratings`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, `show_id` exists in all of the tables. In the `shows` table,
    it is simply called `id`. This common field between all the fields is called a
    *key*. Primary keys are used to identify a unique record in a table. *Foreign
    keys* are used to build relationships between tables by pointing to the primary
    key in another table. You can see in the schema of `ratings` that `show_id` is
    a foreign key that references `id` in `shows`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By storing data in a relational database, as above, data can be more efficiently
    stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *sqlite*, we have five data types, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, columns can be set to add special constraints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can further play with this data to understand these relationships. Execute
    `SELECT * FROM ratings;`. There are a lot of ratings!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can further limit this data down by executing `SELECT show_id FROM ratings
    WHERE rating >= 6.0 LIMIT 10;`. From this query, you can see that there are 10
    shows presented. However, we don’t know what show each `show_id` represents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can discover what shows these are by executing `SELECT * FROM shows WHERE
    id = 626124;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can further our query to be more efficient by executing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this query nests together two queries. An inner query is used by
    an outer query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`JOIN`s'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are pulling data from `shows` and `ratings`. Notice how both `shows` and
    `ratings` have an `id` in common.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How could we combine tables temporarily? Tables could be joined together using
    the `JOIN` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice this results in a wider table than we have previously seen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Where the previous queries have illustrated the *one-to-one* relationship between
    these keys, let’s examine some *one-to-many* relationships. Focusing on the `genres`
    table, execute the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this provides us a sense of the raw data. You might notice that one
    show has three values. This is a one-to-many relationship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can learn more about the `genres` table by typing `.schema genres`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute the following command to learn more about the various comedies in the
    database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this produces a list of comedies, including *Catweazle*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To learn more about Catweazle, by joining various tables through a join:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this results in a temporary table. It is fine to have a duplicate
    table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In contrast to one-to-one and one-to-many relationships, there may be *many-to-many*
    relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can learn more about the show *The Office* and the actors in that show by
    executing the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this results in a table that includes the names of various stars
    through nested queries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We find all the shows in which Steve Carell starred:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This results in a list of titles of shows wherein Steve Carell starred.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This could also be expressed in this way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The wildcard `%` operator can be used to find all people whose names start with
    `Steve C` one could employ the syntax `SELECT * FROM people WHERE name LIKE 'Steve
    C%';`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While relational databases have the ability to be faster and more robust than
    utilizing a `CSV` file, data can be optimized within a table using *indexes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes can be utilized to speed up our queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can track the speed of our queries by executing `.timer on` in `sqlite3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how indexes can speed up our queries, run the following: `SELECT
    * FROM shows WHERE title = ''The Office'';` Notice the time that displays after
    the query executes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we can create an index with the syntax `CREATE INDEX title_index ON shows
    (title);`. This tells `sqlite3` to create an index and perform some special under-the-hood
    optimization relating to this column `title`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will create a data structure called a *B Tree*, a data structure that looks
    similar to a binary tree. However, unlike a binary tree, there can be more than
    two child nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![one node at the top from which come four children and below that there are
    three children coming from one of the nodes and two from another two from another
    and three from another](../Images/598c84c68623b872e9ac7d6958e4e8d5.png "b tree")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Further, we can create indexes as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the query and you will notice that the query runs much more quickly!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unfortunately, indexing all columns would result in utilizing more storage space.
    Therefore, there is a tradeoff for enhanced speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SQL in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To assist in working with SQL in this course, the CS50 Library can be utilized
    as follows in your code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to previous uses of the CS50 Library, this library will assist with
    the complicated steps of utilizing SQL within your Python code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about the CS50 Library’s SQL functionality in the [documentation](https://cs50.readthedocs.io/libraries/cs50/python/#cs50.SQL).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using our new knowledge of SQL, we can now leverage Python alongside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modify your code for `favorites.py` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `db = SQL("sqlite:///favorites.db")` provides Python the location
    of the database file. Then, the line that begins with `rows` executes SQL commands
    utilizing `db.execute`. Indeed, this command passes the syntax within the quotation
    marks to the `db.execute` function. We can issue any SQL command using this syntax.
    Further, notice that `rows` is returned as a list of dictionaries. In this case,
    there is only one result, one row, returned to the rows list as a dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Race Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilization of SQL can sometimes result in some problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can imagine a case where multiple users could be accessing the same database
    and executing commands at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This could result in glitches where code is interrupted by other people’s actions.
    This could result in a loss of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in SQL features such as `BEGIN TRANSACTION`, `COMMIT`, and `ROLLBACK`
    help avoid some of these race condition problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Injection Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, still considering the code above, you might be wondering what the `?` question
    marks do above. One of the problems that can arise in real-world applications
    of SQL is what is called an *injection attack*. An injection attack is where a
    malicious actor could input malicious SQL code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, consider a login screen as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![harvard key login screen with username and password fields](../Images/00733a7c68233a83f89dbddf3dff3920.png
    "harvard key login screen")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Without the proper protections in our own code, a bad actor could run malicious
    code. Consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that because the `?` is in place, validation can be run on `favorite`
    before it is blindly accepted by the query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You never want to utilize formatted strings in queries as above or blindly trust
    the user’s input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the CS50 Library, the library will *sanitize* and remove any potentially
    malicious characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, you learned more syntax related to Python. Further, you learned
    how to integrate this knowledge with data in the form of flat-file and relational
    databases. Finally, you learned about *SQL*. Specifically, we discussed…
  prefs: []
  type: TYPE_NORMAL
- en: Flat-file databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL commands such as `SELECT`, `CREATE`, `INSERT`, `DELETE`, and `UPDATE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary and foreign keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JOIN`s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SQL in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time!
  prefs: []
  type: TYPE_NORMAL
