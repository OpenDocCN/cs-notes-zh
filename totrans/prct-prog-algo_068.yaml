- en: 2.2 Modules and Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/python/22module](https://introcs.cs.princeton.edu/python/22module)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each program that you have composed so far consists of Python code that resides
    in a single .py file. For large programs, keeping all the code in a single file
    is restrictive and unnecessary. Fortunately, it is easy in Python to call a function
    that is defined in another file. This ability has two important consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: It enables code reuse. One program can use code that is already written and
    debugged, not by copying the code, but just by calling it. By doing so, you essentially
    can extend Python — you can define and use your own set of operations on data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables modular programming. You can not only divide a program into functions,
    as just described in Section 2.1, but also keep them in different files, grouped
    together according to the needs of the application. Modular programming is important
    because it allows us to independently compose and debug parts of big programs
    one piece at a time, leaving each finished piece in its own file for later use
    without having to worry about its details again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Using Functions in Other Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To refer to a function in one Python program that is defined in another, we
    use the same mechanism that we have been using to call functions in our `std*`
    modules and Python''s `math` and `random` modules. In this section, we describe
    this basic Python language mechanism. To do so, we distinguish two types of Python
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: A *module* contains functions that are available for use by other programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *client* is a program that makes use of a function in a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are five (simple) steps that you need to take to create and use a module.
    We illustrate the complete process with the module [gaussian.py](gaussian.py.html),
    which is a modularized version of [gauss.py](../21function/gauss.py.html) (from
    Section 2.1) for computing the Gaussian distribution functions, and the client
    [gaussiantable.py](gaussiantable.py.html), which uses the module to compute and
    write a table of values. These are the five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the client: import the module.* The client [gaussiantable.py](gaussiantable.py.html)
    contains the statement `import gaussian`; now it can call any function defined
    in the module [gaussian.py](gaussian.py.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*In the client: qualify function calls to the module.* The client [gaussiantable.py](gaussiantable.py.html)
    uses the function call `gaussian.cdf(score, mu, sigma)` to call the `cdf()` function
    that is defined in the module [gaussian.py](gaussian.py.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*In the module: compose a test client.* The module [gaussian.py](gaussian.py.html)
    contains a `main()` function that takes three command-line arguments, calls the
    functions in the module, and writes the results to standard output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*In the module: eliminate arbitrary global code.* We cannot leave arbitrary
    global code in [gaussian.py](gaussian.py.html) because Python will execute it
    every time the module is imported. Instead, we put our test code in a `main()`
    function, as just described. Now, we can arrange for Python to call `main()` when
    we execute `gaussian.py` from the command line (and only then), using the following
    incantation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Make the module accessible to the client.* Python needs to be able to find
    the file [gaussian.py](gaussian.py.html) when it processes the `import gaussian`
    statement in [gaussiantable.py](gaussiantable.py.html). The simplest way for you
    to proceed is to place the [gaussian.py](gaussian.py.html) and [gaussiantable.py](gaussiantable.py.html).
    The Q & A at the end of this section describes an alternative approach.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, the functions in the module [gaussian.py](gaussian.py.html) are
    available for use by any other program via an `import gaussian` statement. In
    contrast, the client [gaussiantable.py](gaussiantable.py.html) contains arbitrary
    global code and is not intended for use by other programs. We use the term *script*
    to refer to such code.
  prefs: []
  type: TYPE_NORMAL
- en: This diagram summarizes the flow of control between the [gaussiantable.py](gaussiantable.py.html)
    client, the [gaussian.py](gaussian.py.html) module, and the standard `math` module.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bfb9c7ad81dd68ca2f4e06d4e93c827d.png) <alt of="" control="" in=""
    a="" modular="" program=""></alt>'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modular programming.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The potential effect of programming by defining multiple files, each an independent
    module with multiple functions, is another profound change in our programming
    style. Generally, we refer to this approach as *modular programming*. The key
    benefit of modular programming is that encourages us to break a computation up
    into smaller parts that can be individually debugged and tested. Generally, you
    should compose every program by identifying a reasonable way to divide the computation
    into separate parts of a manageable size and implement each part as if someone
    will want to use it later.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Modular Programming Abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we describe abstractions that serve as the basis of modular programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modular programming abstractions](../Images/1fa629df7e528ce82a666fa32670f053.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementations.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the generic term *implementation* to describe code that implements a
    set of functions that are intended for reuse. A Python module is an implementation:
    we refer to the set of functions collectively with a name module and keep them
    in a file module.py. The guiding principle in module design is to provide to clients
    the functions that they need and no others.'
  prefs: []
  type: TYPE_NORMAL
- en: Clients.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the generic term *client* to refer to a program that makes use of an
    implementation. We say that a Python program (a script or a module) that calls
    a function that is defined in a file named `*module*.py` is a client of `*module*`.
  prefs: []
  type: TYPE_NORMAL
- en: Application programming interfaces (APIs).
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Programmers normally think in terms of a contract between the client and the
    implementation that is a clear specification of what the implementation is to
    do. You have been able to compose programs that are clients of `math` and `random`
    and other standard Python modules because of an informal contract (an English-language
    description of what they are supposed to do) along with a precise specification
    of the signatures of the functions that are available for use. Collectively, this
    information is known as an *application programming interface (API)*. The same
    mechanism is effective for user-defined modules. The API allows any client to
    use the module without having to examine the code that defines the module. When
    we compose a new module, we always provide an API. For example, this is the API
    for our [gaussian.py](gaussian.py.html) module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gaussian API](../Images/cc4ab3763e405e2d547a9a4445c7e4c2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'How much information should an API contain? In this booksite, we stick to a
    principle that parallels our guiding design principle: provide to client programmers
    the information they need and no more.'
  prefs: []
  type: TYPE_NORMAL
- en: Private functions.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we wish to define in a module a helper function that is not intended
    to be called directly by clients. We refer to such a function as a *private function*.
    By convention, Python programmers use an underscore as the first character in
    the name of a private function. For example, the following is an alternative implementation
    of the `pdf()` function from gaussian.py that calls the private function _phi():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We do not include private functions in APIs because they are not part of the
    contract between clients and implementations. Indeed, a leading underscore in
    the name of a function signals clients not to call the function explicitly. (Regrettably,
    Python has no mechanism for enforcing this convention.)
  prefs: []
  type: TYPE_NORMAL
- en: Libraries.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *library* is a collection of related modules. For example, Python has a standard
    library (which includes the modules `random` and `math`) and many extension libraries
    (such as `NumPy` for scientific computing and `Pygame` for graphics and sound).
    Also, for this book, we provide a booksite library (which includes the modules
    `stdio` and `stddraw`).
  prefs: []
  type: TYPE_NORMAL
- en: Documentation.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The APIs of all standard, extension, and booksite modules are available through
    the built-in `help()` function in interactive Python. As illustrated below, all
    you need to do is type `python` (to enter interactive Python), then enter the
    statement `import module` (to load the module), then type `help(module)` to see
    the API for module. The APIs of the standard and extension Python modules also
    are available in another form through the [online Python documentation](https://docs.python.org/3/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing Python documentation](../Images/2297c8656ca799ae917cab9e0221d28c.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Next, we present the APIs for our `stdrandom` module (for generating random
    numbers), our `stdarray` module (for one- and two-dimensional arrays), and our
    `stdstats` module (for statistical calculations). We also describe some interesting
    clients of these modules.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Random Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdrandom.py` module is for generating random numbers from various distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stdrandom API](../Images/4c3208a64b0fcf1fc1e0213fa9e8b3b4.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: API design.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We make certain assumptions about the objects passed to each function in `stdrandom`.
    For example, we assume that clients will pass to `stdrandom.bernoulli()` a float
    between 0.0 and 1.0, and to `stdrandom.discrete()` an array of nonnegative numbers
    (not all of which are zero). Such assumptions are part of the contract between
    the client and the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We implement `stdrandom` without reference to any particular client, but it
    is good programming practice to include a basic test client `main()` that, at
    a minimum,
  prefs: []
  type: TYPE_NORMAL
- en: Exercises all the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides some assurance that the code is working.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Takes an argument from the command line to allow flexibility in testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it is not intended for clients, we use `main()` when debugging, testing,
    and improving the functions in a module. This practice is call *unit testing*.
    Proper unit testing can be a significant programming challenge in itself. In this
    particular case, it is appropriate to do more extensive testing in a separate
    client to check that the numbers have many of the same properties as truly random
    numbers drawn from the cited distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An extensively used module such as `stdrandom` should also be subject to stress
    testing, where we make sure that it does not fail unexpectedly, even when the
    client does not follow the contract or makes some assumption that is not explicitly
    covered. What should `stdrandom.discrete()` do if some array elements are negative?
    What if the argument is an array of length 0? What should `stdrandom.uniform()`
    do if the second argument is less than (or equal to) the first argument? Such
    cases are sometimes referred to as *corner cases*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Array-Processing API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Section 1.4 we saw the utility of functions that create one-dimensional arrays
    of a specified length and two-dimensional arrays with a specified number of rows
    and columns. Thus, we introduced the `stdarray` module from the booksite library,
    and specifically its functions for creating and initializing arrays `stdarray.create1D()`
    and `stdarray.create2D()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we have seen and will continue to see many examples where we wish
    to read values from standard input into an array and write values from an array
    to standard output. Accordingly, we have included in the `stdarray` module functions
    for reading arrays of integers, floats, and booleans from standard input and for
    writing them to standard output — thus complementing the `stdio` module. Here
    is the full API for `stdarray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stdarray API](../Images/2cc2d66e674cfef0900458c157bd23f2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: We have adopted the convention that arrays appearing on standard input include
    the dimension(s) and appear in the order indicated, as illustrated in the diagram
    below. The `read*()` functions expect this format, and the `write*()` functions
    produce output in this format.
  prefs: []
  type: TYPE_NORMAL
- en: '![File formats for arrays](../Images/ec8517423641aba7d140a97c37549d25.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: For arrays of booleans, our file format uses `0` and `1` values instead of `False`
    and `True`. This convention is much more economical for large arrays. More important,
    patterns in the data are much easier to spot with this file format.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Iterated Function Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An [iterated function system](http://www.cut-the-knot.org/ctk/ifs.shtml) (IFS)
    is a general way to produce fractals like the Sierpinski triangle and the Barnsley
    Fern. As a first example, consider the following simple process: start by plotting
    a point at one of the vertices of an equilateral triangle. Then pick one of the
    three vertices at random and plot a new point halfway between the point just plotted
    and that vertex. Continue performing the same operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A random process](../Images/c388dafdf422670b2fea8e7d0efa15b1.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The program [sierpinski.py](sierpinski.py.html) simulates this process. Below
    are snapshots after 1000, 10000, and 100000 steps. You might recognize the figure
    as the [Sierpinski triangle](http://mathworld.wolfram.com/SierpinskiSieve.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![A random process?](../Images/90c71f02780233666de958cbdd7c93f6.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'The program [ifs.py](ifs.py.html) is a data-driven version program that simulates
    a generalization of this process. See the textbook for details. You can run it
    on any of these input files: [barnsley.txt](barnsley.txt), [binary.txt](binary.txt),
    [coral.txt](coral.txt), [culcita.txt](culcita.txt), [cyclososus.txt](cyclosorus.txt),
    [dragon.txt](dragon.txt), [fishbone.txt](fishbone.txt), [floor.txt](floor.txt),
    [koch.txt](koch.txt), [sierpinski.txt](sierpinski.txt), [spiral.txt](spiral.txt),
    [swirl.txt](swirl.txt), [tree.txt](tree.txt), or [zigzag.txt](zigzag.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples of iterated function systems](../Images/8e79629e66ef4d4aa1c7ed709f6ee2e8.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'The ability to produce such realistic diagrams so easily suggests intriguing
    scientific questions: What does computation tell us about nature? What does nature
    tell us about computation?'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdstats.py` module is for statistical calculations and basic visualizations,
    as articulated in the following API. See the textbook for details.
  prefs: []
  type: TYPE_NORMAL
- en: '![The stdstats API](../Images/041a279d5fa1d406ff055b042e775d22.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Bernoulli trials.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Program [bernoulli.py](bernoulli.py.html) is an example `stdstats.py` client.
    It counts the number of heads found when a fair coin is flipped *n* times and
    compares the result with the predicted Gaussian distribution function. According
    to the [Central Limit Theorem](http://mathworld.wolfram.com/CentralLimitTheorem.html),
    the resulting histogram is extremely well approximated by the Gaussian distribution
    with mean *n*/2 and variance *n*/4\. This is the output of the command `python
    bernoulli.py 20 100000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stdstats API](../Images/7f47da26a86081c76846792863a71fc1.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Modular Programming Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The module implementations that we have developed illustrate modular programming.
    Instead of composing a new program that is self-contained in its own file to address
    a new problem, we break up each task into smaller, more manageable subtasks, then
    implement and independently debug code that addresses each subtask. The [ifs.py](ifs.py.html)
    and [bernoulli.py](bernoulli.py.html) programs exemplify modular programming because
    they are relatively sophisticated computations that are implemented with several
    relatively small modules.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency graph for the clients and modules in this section](../Images/24f881ba56010092d746348c476cd121.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'We emphasize modular programming throughout this booksite because it has many
    important benefits, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Programs of a reasonable size.* No large task is so complex that it cannot
    be divided into smaller subtasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging.* With modular programming and our guiding principle of keeping
    the scope of variables local to the extent possible, we severely restrict the
    number of possibilities that we have to consider when debugging. Equally important
    is the idea of a contract between client and implementation. Once we are satisfied
    that an implementation is meeting its end of the bargain, we can debug all its
    clients under that assumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code reuse.* Once we have implemented libraries such as StdStats and StdRandom,
    we do not have to worry about writing code to compute averages or standard deviations
    or to generate random numbers again — we can simply reuse the code that we have
    written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Maintenance.* Like a good piece of writing, a good program can always be improved.
    Supppose that while developing a new client, you find a bug in some module. With
    modular programming, fixing that bug amounts to fixing bugs in all of the module''s
    clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** How can I make a booksite module (such as `stdio` or `stdrandom`) available
    to my Python programs?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** If you followed the step-by-step instructions on the booksite for installing
    Python, all of our standard modules (including `stdio`, `stddraw`, `stdarray`,
    `stdrandom`, and `stdstats`) should already be available for use in your Python
    programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How can I make non-standard and non-booksite modules (such as `gaussian`)
    available to my Python programs?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Let''s be specific. Suppose you''ve composed a program named `myprogram.py`,
    and `myprogram.py` imports `gaussian`. The issue is how you can make the `gaussian`
    module available to `myprogram.py`. In other words, the issue is how you can tell
    Python where to find the `gaussian.py` file while it is executing `myprogram.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest approach is to place `gaussian.py` in the same directory as `myprogram.py`.
    However, using that approach you might end up with multiple copies of `gaussian.py`
    — one copy in each directory that contains a `gaussian.py` client. That approach
    would make the `gaussian.py` code difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to place a single copy of `gaussian.py` in some directory,
    and then *set the `PYTHONPATH` environment variable* to contain that directory.
    Subsequently, Python looks for files in that directory whenever it encounters
    an `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism for setting the `PYTHONPATH` environment variable depends upon
    the operating system that you''re using. Suppose your computer is running Mac
    OS X or Linux. Further suppose you place `gaussian.py` in the directory `/Users/yourusername/common`.
    Then these commands are appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `export` command sets the value of the `PYTHONPATH` variable to `/Users/yourusername/common`.
    So during the execution of the subsequent `python myprogram.py` command, Python
    looks in the `/Users/yourusername/common` directory when handling `import` statements,
    and so finds the `gaussian.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generalizing, on Mac OS X and Linux systems the value of the `PYTHONPATH` variable
    is a sequence of directories separated by colons. So after you issue this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Python looks in `*directory1*`, then `*directory2*`, and then `*directory3*`
    to find `.py` files when handling `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, suppose your computer is running Microsoft Windows. Further
    suppose you place `gaussian.py` in the directory `c:\Users\yourusername\common`.
    Then these commands are appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `set` command sets the value of the `PYTHONPATH` variable to `c:\Users\yourusername\common`.
    So during the execution of the subsequent `python myprogram.py` command, Python
    looks in the `c:\Users\yourusername\common` directory when handling `import` statements,
    and so finds the `gaussian.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generalizing, on Microsoft Windows systems the value of the `PYTHONPATH` variable
    is a sequence of directories separated by semicolons. So after you issue this
    command::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Python looks in `*directory1*`, then `*directory2*`, and then `*directory3*`
    to find `.py` files when handling `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** I tried to import the `gaussian` module, but got the following error
    message. What''s wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**A.** You did not make `gaussian` available to Python, as described above.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** I tried to call `gaussian.pdf()` but I got the following error. What''s
    wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**A.** You left out the `import gaussian` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Is there a keyword that identifies a `.py` file as a module (and not
    a script)?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No. Technically, the key point is to avoid arbitrary global code using
    the patterns described earlier in this section. If you avoid arbitrary global
    code in a `.py` file, so that the `.py` file can be imported into some other `.py`
    file, then we call it a module. Pragmatically, however, there is a bit of a conceptual
    leap in this viewpoint, because it is one thing to sit down to create a `.py`
    file that you will run (and perhaps run again sometime later with different data),
    but quite another thing to create a `.py` file that you will rely on much later
    in the future, and still another thing to create a `.py` file for someone else
    to use in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do I develop a new version of a module that I have been using for
    a while?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** With care. Any change to the API might break any client program, so
    it is best to work in a separate directory. Of course, with this approach you
    are working with a copy of the code. If you are changing a module that has a lot
    of clients, you can appreciate the problems faced by companies putting out new
    versions of their software. If you just want to add a few functions to a module,
    go ahead: that is usually not too dangerous.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do I know that an implementation behaves properly? Why not automatically
    check that it satisfies the API?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** We use informal specifications because composing a detailed specification
    is not much different from composing a program. Moreover, a fundamental tenet
    of theoretical computer science says that doing so does not even solve the basic
    problem because there is no way in general to check that two different programs
    perform the same computation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** I notice that files whose names are suffixed with `.pyc` are appearing
    when I run the programs from this section. For example, when I issue the command
    `python gaussiantable.py`, I notice that Python automatically creates a file named
    `gaussian.pyc`. What are these `.pyc` files?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** As noted in Section 1.1, whenever Python executes a program, it translates
    the program into an internal (not human-readable) form that is more amenable to
    execution. That internal form is called *bytecode*. When you import a module for
    the first time, Python compiles the code and stores the resulting bytecode in
    a `.pyc` file. This makes the module load faster because Python does not need
    to recompile it each time (but it does not make running the program any faster).'
  prefs: []
  type: TYPE_NORMAL
- en: When a program consists of only one file, Python discards the file's bytecode
    after execution is complete. However, when a program consists of multiple files
    — that is, when a program consists of a client file and modules — Python does
    not discard the bytecode that it generates for the modules. Instead it stores
    that bytecode in `.pyc` files.
  prefs: []
  type: TYPE_NORMAL
- en: For example, recall that [gaussiantable.py](gaussiantable.py.html) depends upon
    [gaussian.py](gaussian.py.html). So when you issue the command `python gaussiantable.py
    1019 209`, Python translates [gaussiantable.py](gaussiantable.py.html) into bytecode.
    It also translates [gaussian.py](gaussian.py.html) into bytecode. Eventually it
    discards the former; but it saves the latter in the file `gaussian.pyc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s rationale is this: Since [gaussian.py](gaussian.py.html) was used
    as a module in this program, it''s likely that it will be used in the future as
    a module in other programs. So Python saves the bytecode version of [gaussian.py](gaussian.py.html)
    in `gaussian.pyc` to avoid the translation overhead if the module indeed is reused.'
  prefs: []
  type: TYPE_NORMAL
- en: It's fine to delete `.pyc` files at any time; Python will regenerate them when
    appropriate. It also is fine *not* to delete `.pyc` files because if you edit
    a `.py` file after Python has generated the corresponding `.pyc` file, Python
    will regenerate the `.pyc` file automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compose a module that implements the hyperbolic trigonometric functions based
    on the definitions sinh(*x*) = (*e*^(*x*) - *e*^(-*x*))/2 and cosh(*x*) = (*e*^(*x*)
    + *e*^(-*x*))/2, with tanh(*x*), coth(*x*), sech(*x*), and csch(*x*) defined in
    a manner analogous to standard trigonometric functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a test client for both `stdstats` and `stdrandom` that checks that
    all of the methods in both modules operate as expected. Take a command-line argument
    `n`, generate `n` random numbers using each of the functions in `stdrandom`, and
    write their statistics. *Extra credit*: Defend the results that you get by comparing
    them to those that are to be expected from mathematical analysis.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop a client that does stress testing for `stdrandom`. Pay particular attention
    to `discrete()`. For example, are the probabilities nonnegative? Are they all
    zero?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a function that takes floats `ymin` and `ymax` (with `ymin` strictly
    less than `ymax`) and a `float` array `a[]` as arguments and linearly scales the
    elements in `a[]` so that they are all between `ymin` and `ymax`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a [gaussian.py](gaussian.py.html) and `stdstats.py` client that explores
    the effects of changing the mean and standard deviation on the Gaussian distribution
    curve. Create one plot with curves having a fixed mean and various standard deviations
    and another with curves having a fixed standard deviation and various means.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to `stdrandom.py` a function `maxwellBoltzmann()` that returns a random
    value drawn from a *Maxwell-Boltzmann distribution* with parameter σ. To produce
    such a value, return the square root of the sum of the squares of three Gaussian
    random variables with mean 0 and standard deviation σ. (The speeds of molecules
    in an ideal gas have a Maxwell-Boltzmann distribution.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [bernoulli.py](bernoulli.py.html) to animate the bar graph, replotting
    it after each experiment, so that you can watch it converge to the normal distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [bernoulli.py](bernoulli.py.html) to add a command-line argument *p*
    that specifies the probability that a biased coin comes up heads. Run experiments
    to get a feeling for the distribution corresponding to a biased coin. Be sure
    to try values of *p* that are close to 0 and close to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a module `matrix.py` that implements the following API for vectors
    and matrices (see Section 1.4):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Matrix API](../Images/db6060f1a8a89b0359bdd07f42523bdf.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Solution*: See [matrix.py](matrix.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compose a client of `matrix.py` (from the previous exercise) which uses the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That code performs the same calculation as [markov.py](../16pagerank/markov.py.html)
    (from section 1.6).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In practice, mathematicians and scientists use mature libraries such as `NumPy`
    (or special-purpose matrix-processing languages such as `Matlab`) for such tasks
    because they are likely to be more efficient, accurate, and robust than anything
    you could compose yourself. The [NumPy Appendix](../appendix_numpy/) describes
    how to use `NumPy`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a client of `matrix.py` (from the previous two exercises) named `markovsquaring.py`
    that implements the version of [markov.py](../16pagerank/markov.py.html) (from
    Section 1.6) but is based on squaring the matrix, instead of iterating the vector-matrix
    multiplication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redesign [randomsurfer.py](../16pagerank/randomsurfer.py.html) (from Section
    1.6) using the `stdarray` and `stdrandom` modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Partial solution:*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function `exp()` to `stdrandom.py` that takes an argument λ and returns
    a random number from the *exponential distribution* with rate λ. *Hint*: If *x*
    is a random number uniformly distributed between 0 and 1, then -ln *x* / λ is
    a random number from the exponential distribution with rate λ.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Sicherman dice.** Suppose that you have two six-sided dice, one with faces
    labeled 1, 3, 4, 5, 6, and 8 and the other with faces labeled 1, 2, 2, 3, 3, and
    4\. Compare the probabilities of occurrence of each of the values of the sum of
    the dice with those for a standard pair of dice. Use `stdrandom` and `stdstats`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: Dice with these properties are called [Sicherman dice](https://en.wikipedia.org/wiki/Sicherman_dice):
    they produce sums with the same frequency as regular dice (2 with probability
    1/36, 3 with probability 2/36, and so on).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Craps.** Here are the rules for a *pass bet* in the game of *craps*: Roll
    two 6-sided dice, and let *x* be their sum.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *x* is 7 or 11, you win.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If *x* is 2, 3, or 12, you lose.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, repeatedly roll two the dice until their sum is either *x* or 7.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If their sum is *x*, you win.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If their sum is 7, you lose.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose a modular program to estimate the probability of winning a pass bet.
    Modify your program to handle loaded dice, where the probability of a die landing
    on 1 is taken from the command line, the probability of landing on 6 is 1/6 minus
    that probability, and 2-5 are assumed equally likely. *Hint:* Use `stdrandom.discrete()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dynamic histogram.** Suppose that the standard input stream is a sequence
    of floats. Compose a program that takes an integer `n` and two floats `l` and
    `r` from the command line and uses `stdstats` to plot a histogram of the count
    of the numbers in the standard input stream that fall in each of the `n` intervals
    defined by dividing `(l, r)` into `n` equal-sized intervals. Use your program
    to add code to your solution to Exercise 2 (from earlier in this section) to plot
    a histogram of the distribution of the numbers produced by each function, taking
    `n` from the command line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tukey plot.** A *Tukey plot* is a data visualization that generalizes a histogram,
    and is appropriate for use when each integer in a given range is associated with
    a set of `y` values. For each integer *i* in the range, we compute the mean, standard
    deviation, 10th percentile, and 90th percentile of all the associated *y*-values;
    draw a vertical line with *x*-coordinate *i* running from the 10th percentile
    *y* value to the 90th percentile *y* value; and then draw a thin rectangle centered
    on the line that runs from one standard deviation below the mean to one standard
    deviation above the mean. Suppose that the standard input stream is a sequence
    of pairs of numbers where the first number in each pair is an int and the second
    a double value. Compose a `stdstats` and `stddraw` client that takes an integer
    `n` from the command line and, assuming that all the integers on the standard
    input stream are between 0 and `n-1`, uses `stddraw` to make a Tukey plot of the
    data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IFS.** Experiment with various inputs to [ifs.py](ifs.py.html) to create
    patterns of your own design like the Sierpinksi triangle, Barnsley fern, or other
    examples. You might begin by experimenting with minor modifications to the given
    inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IFS matrix implementation.** Compose a version of [ifs.py](ifs.py.html) that
    uses `matrix.multiply()` (as developed in a previous exercise in this section)
    instead of the equations that compute the new values of `x` and `y`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stress test.** Compose a client that does stress testing for `stdstats.py`.
    Work with a classmate, with one person composing code and the other testing it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gamblers ruin.** Compose a `stdrandom.py` client to study the gamblers ruin
    problem (see [gambler.py](../13flow/gambler.py.html) from Section 1.3, and the
    exercises at the end of that section). *Note*: Defining a function for the experiment
    is more difficult than for [bernoulli.py](bernoulli.py.html) because a function
    cannot return two values. But remember that a function can return a single array
    that contains two values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Module for properties of integers.** Compose a module based on the functions
    that we have considered in this book for computing properties of integers. Include
    functions for determining whether a given integer is prime; whether two integers
    are relatively prime; computing all the factors of a given integer; the greatest
    common divisor and least common multiple of two integers; Eulers totient function
    (see the *Euler''s Totient Function* exercise in Section 2.1); and any other functions
    that you think might be useful. Create an API, a client that performs stress testing,
    and clients that solve several of the exercises earlier in this book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Voting machines.** Compose a `stdrandom.py` client (with appropriate functions
    of its own) to study the following problem: Suppose that in a population of 100
    million voters, 51% vote for candidate A and 49% vote for candidate B. However,
    the voting machines are prone to make mistakes, and 5% of the time they produce
    the wrong answer. Assuming the errors are made independently and at random, is
    a 5% error rate enough to invalidate the results of a close election? What error
    rate can be tolerated?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Poker analysis.** Compose a `stdrandom.py` and `stdstats.py` client (with
    appropriate functions of its own) to estimate the probabilities of getting one
    pair, two pair, three of a kind, a full house, and a flush in a five-card poker
    hand via simulation. Divide your program into appropriate functions and defend
    your design decisions. *Extra credit*: Add straight and straight flush to the
    list of possibilities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Music module.** Develop a module based on the functions in [playthattunedeluxe.py](../21function/playthattunedeluxe.py.html)
    (from Section 2.1) that you can use to compose client programs to create and manipulate
    songs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Animated plots.** Compose a program that takes a command-line argument `m`
    and produces a bar graph of the `m` most recent floats on standard input. Use
    the same animation technique that we used for bouncingball.py (from Section 1.5):
    erase, redraw, show, and wait briefly. Each time your program reads a new number,
    it should redraw the whole graph. Since most of the picture does not change as
    it is redrawn slightly to the left, your program will produce the effect of a
    fixed-size window dynamically sliding over the input values. Use your program
    to plot a huge time-variant data file, such as stock prices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Array plot module.** Develop your own plot functions that improve upon those
    in `stdstats.py`. Be creative! Try to make a plotting module that you think you
    will use for some application in the future.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
