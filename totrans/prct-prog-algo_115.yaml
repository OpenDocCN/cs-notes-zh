- en: 6.3   Suffix Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://algs4.cs.princeton.edu/63suffix](https://algs4.cs.princeton.edu/63suffix)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter under major construction.
  prefs: []
  type: TYPE_NORMAL
- en: Important note.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Beginning with Oracle and OpenJDK Java 7, Update 6, the `substring()` method
    takes [linear time and space](http://java-performance.info/changes-to-string-java-1-7-0_06)
    in the size of the extracted substring (instead of constant time and space). The
    [String API](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html) provides
    no performance guarantees for any of its methods, including `substring()` and
    `charAt()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The programs in the textbook and booksite have been updated to avoid any dependency
    on a constant-time substring operation. However, if you are using the third printing
    of the textbook (or earlier), consider yourself warned.*
  prefs: []
  type: TYPE_NORMAL
- en: Suffix sorting and suffix arrays.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suffix sorting: given a string, sort the suffixes of that string in ascending
    order. Resulting sorted list is called a *suffix array*. Program [SuffixArray.java](SuffixArray.java.html)
    builds a sufix array data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Longest repeated substring.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application of sorting to computational biology and plagiarism detection.
    Program [LongestRepeatedSubstring.java](LongestRepeatedSubstring.java.html) solves
    the problem using a suffix array.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword in context (KWIC).
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the suffix array, easy to search for a string or sentence via binary search.
    Memory is linear. Search is O(K log N) where K is the length of the string you
    are searching for. (Can be done in K + log N by using the lcp array.) Sometimes
    referred to as KWIK (key word in context) and collocations. Used by linguists.
    Concordancer = program to make concordance. A concordance of the Dead Sea Scrolls
    was famously reverse-engineered and turned into a readable text by Martin Abegg.
    Program [KWIK.java](KWIK.java.html).
  prefs: []
  type: TYPE_NORMAL
- en: Manber's algorithm.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, the input size is N, so we might hope to exploit the overlapping nature
    of the substrings and do better. Program [Manber.java](Manber.java.html) sorts
    string suffixes using a version of Manber-Myers repeated doubling algorithm. [Larsson](http://www.larsson.dogma.net/tr204.pdf)
    gave an O(N log N) analysis when the internal sorting routine is replaced with
    an O(N log N) comparison based sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Kasai's algorithm.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a description of [Kasai's algorithm](https://www.geeksforgeeks.org/%C2%AD%C2%ADkasais-algorithm-for-construction-of-lcp-array-from-suffix-array/)
    for computing the lcp array from a suffix array.
  prefs: []
  type: TYPE_NORMAL
- en: Q+A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linear time suffix sorting.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Skewed divide-and-conquer](../references/papers/karkkainen-sanders.pdf). The
    simplest linear time suffix sorting solution. Recursively sort the suffixes whose
    indices are {0, 1, 2} mod 3, and then merge.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Give the suffix array for the string "abacadaba". Also, give a table of `lcp(i)`
    values for i = 1 to n-1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous question for the string "mississippi".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes are used to create a `SuffixArray` object with a string of length
    n?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's wrong with the following code fragment to compute all the suffixes for
    suffix sort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: quadratic time *and* quadratic space.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What's wrong with the following code fragment to compute all the cyclic suffixes
    for suffix sort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: quadratic time *and* quadratic space.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What's wrong with the following code fragment to compute all the cyclic suffixes
    for suffix sort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: quadratic time *and* quadratic space.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Longest common substring.** Write a program [LongestCommonSubstring.java](LongestCommonSubstring.java.html)
    that take two filenames as command-line arguments, reads the two text files, and
    find the longest substring that appears in both. *Hint*: create a suffix array
    for s#t where s and t are the two text strings and # is a character that does
    not appear in either.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 1970, D. Knuth conjectured that is was impossible to solve this problem in
    linear time. In fact, it is possible to do it in linear time (in the worst case)
    using suffix trees or suffix arrays.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Burrows-Wheeler transform.** The Burrows-Wheeler transform (BWT) is a transformation
    that is used in data compression algorithms, including bzip2 and in high-throughput
    sequencing in genomics. Given a text string of length N (terminated by a special
    end-of-file character $ that is smaller than any other character), Consider the
    N-by-N matrix in which each row contains a different cyclic rotation of the original
    text string. Sort the rows lexicographically. The Burrows-Wheeler transform is
    the rightmost column in the sorted matrix. For example, BWT (mississippi$) = ipssm$pissii.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Burrows-Wheeler inverse transform.** The Burrows-Wheeler inverse transform
    (BWI) inverts the BWT. Given the BWT of a text string, design a linear-time algorithm
    to recover the original text string. For example, BWI(ipssm$pissii) = mississippi$.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Circular string linearization.** Given a string s, find the rotation that
    is the smallest lexicographially. Problem arises in chemical databases for circular
    molecules. Each molecule is represented as a circular string. The canonical representation
    is the lexicographically smallest rotation. Devise an algorithm to compute this
    canonical representation of the circular string *Hint*: suffix sort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Alternate solutions*: Duval''s algorithm using a Lyndon decomposition and
    the surprisingly elegant [minimum expression algorithm](http://online-judge.uva.es/board/viewtopic.php?f=22&t=42601#p100062)
    by Zhou Yuan.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Accelerated rank.** Use the following idea to speed up the binary search
    in the `rank()` method. Let `lo` and `hi` denote the left and right endpoints
    of the current search interval. Let `lcpLo` denote the lcp of the query string
    and `suffixes[lo]` and let `lcpHi` denote the lcp of the query string and `suffixes[hi]`.
    Then, when comparing the query string to `suffixes[mid]`, only need to compare
    the characters starting at `lcp = min(lcpLo, lcpHi)` because all of the suffixes
    in the search interval have the same first `lcp` characters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Accelerated rank analysis.** Show that the the worst-case running time of
    the accelerated rank is still proportional to L log N, where L is the length of
    the query and N is the length of the text. However, Myers and Manber report that
    this speeds up the computation in practice. In theory, it can be improved to L
    + log N using non-adjacent lcp values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest 3-repeated substring.** Given a text string, find the longest substring
    that is repeated 3 or more times.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest k-repeated substring.** Given a text string and an integer k, find
    the longest substring that is repeated k or more times.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Long repeated substring.** Given a text string and an integer L, find all
    repeated substrings of length L or more.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest common substring among three strings.** Given three strings r, s,
    and t, find the longest substring that appears in all three.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longest common reverse-complemented substring.** Given two DNA strings, find
    the longest substring that appears in one, and whose reverse Watson-Crick complement
    appears in the other. Two strings s and t are reverse complements if t is the
    reverse of s except with the following substitutions AT, CG. For example ATTTCGG
    and CCGAAAT are reverse complements of each other. *Hint*: suffix sort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Suffix arrays with less memory.** Instead of using an array of substrings
    where `suffixes[i]` referes to the ith sorted suffix, maintain an array of integers
    so that index[i] referes to the offset of the ith sorted suffix. To compare the
    substrings represented by a = index[i] and b = index[j], compare the character
    `s.charAt(a)` against `s.charAt(b)`, `s.charAt(a+1)` against `s.charAt(b+1)`,
    and so forth. How much memory do you save? Is your program faster?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**k-gram frequency counts.** Given a text string, design a data structure to
    efficiently answers queries of the form: how many times does a given k-gram appear?
    Should take time proportional to k log N in the worst case, where k is the length
    of the k-gram and N is the length of the text string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Most frequent k-gram.** Given a text string and an integer k, find the k-gram
    that appears most frequently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shortest unique substring.** Given a text string, find a shortest substring
    that appears exactly once. The problem arises in bioinformatics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shortest non-substring.** Given a bitstring, find a shortest bistring that
    does not appear as a substring.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shortest unique substring.** Given a text string, preprocess it to answer
    shortest unique substring queries of the following form: given an index q into
    the text string, find a shortest substring that contains index q and does not
    appear as a substring anywhere else in the text.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
