- en: 6.1   Representing Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 表示信息
- en: 原文：[https://introcs.cs.princeton.edu/java/61data](https://introcs.cs.princeton.edu/java/61data)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/61data](https://introcs.cs.princeton.edu/java/61data)
- en: Everything suited for processing with digital computers is represented as a
    sequence of 0s and 1s, whether it be numeric data, text, executable files, images,
    audio, or video. The meaning of a given sequence of bits within a computer depends
    on the context. In this section we describe how to represent integers in binary,
    decimal, and hexadecimal and how to convert between different representations.
    We also describe how to represent negative integers and floating-point numbers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一切适合数字计算机处理的内容都表示为一系列0和1，无论是数字数据、文本、可执行文件、图像、音频还是视频。计算机中给定一系列比特的含义取决于上下文。在本节中，我们描述了如何以二进制、十进制和十六进制表示整数，以及如何在不同表示之间进行转换。我们还描述了如何表示负整数和浮点数。
- en: Binary and hexadecimal.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制和十六进制。
- en: Since Babylonian times, people have represented integers using *positional notation*
    with a fixed base. The most familiar of these systems is *decimal*, where the
    base is 10 and each positive integer is represented as a string of digits between
    0 and 9. Specifically, Specifically, \( d_n d_{n-1} \ldots d_2 d_1 d_0 \) represents
    the integer
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自巴比伦时代以来，人们一直使用具有固定基数的*位置表示法*来表示整数。其中最熟悉的系统之一是*十进制*，其中基数为10，每个正整数表示为介于0和9之间的数字字符串。具体来说，\(
    d_n d_{n-1} \ldots d_2 d_1 d_0 \)表示整数
- en: $$\quad\quad\quad\quad\quad\;\; d_n10^n + d_{n-1}10^{n-1} + \ldots + d_210^2
    + d_110^1 + d_010^0$$
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$\quad\quad\quad\quad\quad\;\; d_n10^n + d_{n-1}10^{n-1} + \ldots + d_210^2
    + d_110^1 + d_010^0$$
- en: For example, `10345` represents the integer 10,345 = 1·10⁴ + 0·10³ + 3·10² +
    4·10¹ + 5·10⁰.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`10345`表示整数10,345 = 1·10⁴ + 0·10³ + 3·10² + 4·10¹ + 5·10⁰。
- en: '*Binary.* When the base is 2, we represent an integer as a sequence of 0s and
    1s. In this case, we refer to each binary (base 2) digit—either 0 or 1—as a *bit*.
    Specifically, \(b_n b_{n-1} \ldots b_2 b_1 b_0\) represents the integer'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制*。当基数为2时，我们将整数表示为一系列0和1。在这种情况下，我们将每个二进制（基数2）数字——0或1——称为*比特*。具体来说，\(b_n
    b_{n-1} \ldots b_2 b_1 b_0\)表示整数'
- en: $$\quad\quad\quad\quad b_n 2^n + b_{n-1} 2^{n-1} + \ldots + b_2 2^2 + b_1 2^1
    + b_0 2^0$$
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$\quad\quad\quad\quad b_n 2^n + b_{n-1} 2^{n-1} + \ldots + b_2 2^2 + b_1 2^1
    + b_0 2^0$$
- en: For example, `1100011` represents the integer 99 = 1·2⁶ + 1·2⁵ + 0·2⁴ + 0·2³
    + 0·2² + 1·2¹ + 1·2⁰.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`1100011`表示整数99 = 1·2⁶ + 1·2⁵ + 0·2⁴ + 0·2³ + 0·2² + 1·2¹ + 1·2⁰。
- en: '*Hexadecimal.* ![hexadecimal digits](../Images/8f15cc32db92a0b8c27d1e0e64220bfa.png)
    In hexadecimal (or *hex*), the sequence of hex digits Specifically, \(h_n h_{n-1}
    \ldots h_2 h_1 h_0\) represents the integer'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*十六进制*。![十六进制数字](../Images/8f15cc32db92a0b8c27d1e0e64220bfa.png) 在十六进制（或*hex*）中，十六进制数字序列具体表示为\(h_n
    h_{n-1} \ldots h_2 h_1 h_0\)表示整数'
- en: $$\quad\quad\quad\quad\;\; h_n 16^n + h_{n-1} 16^{n-1} + \ldots + h_2 16^2 +
    h_1 16^1 + h_0 16^0$$
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $$\quad\quad\quad\quad\;\; h_n 16^n + h_{n-1} 16^{n-1} + \ldots + h_2 16^2 +
    h_1 16^1 + h_0 16^0$$
- en: We need to have one character to represent each digit, so we use `A` for 10,
    `B` for 11, `C` for 12, and so forth. For example, `FACE` represents the integer
    64,206 = 15·16³ + 10·16² + 12·16¹ + 14·16⁰.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要一个字符来表示每个数字，因此我们使用`A`表示10，`B`表示11，`C`表示12，依此类推。例如，`FACE`表示整数64,206 = 15·16³
    + 10·16² + 12·16¹ + 14·16⁰。
- en: Number conversion.
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字转换。
- en: You need to know how to convert from a number represented in one system to another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道如何将一个系统中表示的数字转换为另一个系统中的数字。
- en: '*Converting between hex and binary.* Given the hex representation of a number,
    finding the binary representation is easy, and vice versa, because 16 is a power
    of 2. To convert from hex to binary, replace each hex digit by the four binary
    bits corresponding to its value. Conversely, to convert from binary to hex, prepend
    leading 0s to make the number of bits a multiple of 4, then group the bits 4 at
    a time and convert each group to a single hex digit.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*十六进制和二进制之间的转换*。给定一个数字的十六进制表示，找到二进制表示很容易，反之亦然，因为16是2的幂。要从十六进制转换为二进制，将每个十六进制数字替换为对应值的四个二进制位。反之，要从二进制转换为十六进制，添加前导0使位数成为4的倍数，然后每4位分组并将每组转换为单个十六进制数字。'
- en: '![Hexadecimal to binary conversion](../Images/767bddd7bb383d475425d3678deb2d04.png)
           ![Binary to hexadecimal conversion](../Images/aa15177682b2e5de51d375aa4b5e07cd.png)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![十六进制到二进制的转换](../Images/767bddd7bb383d475425d3678deb2d04.png)         ![二进制到十六进制的转换](../Images/aa15177682b2e5de51d375aa4b5e07cd.png)'
- en: '*Converting from decimal to base b.* It is slightly more difficult to convert
    an integer represented in decimal to one in base *b* because we are accustomed
    to performing arithmetic in base 10. The easiest way to convert from decimal to
    base *b* by hand is to repeatedly divide by the base *b*, and read the remainder
    upwards. For example, the calculations below convert from the decimal integer
    366 to binary (101101110) and to hexadecimal (16E).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从十进制到基数b的转换*。将一个以十进制表示的整数转换为基数*b*的整数稍微困难一些，因为我们习惯于在十进制中进行算术运算。手动从十进制转换为基数*b*的最简单方法是反复除以基数*b*，并从上往下读取余数。例如，下面的计算将十进制整数366转换为二进制（101101110）和十六进制（16E）。'
- en: '![Converting from decimal to binary](../Images/c1db22af82dd7c689f6f8f1cb2e9d5c3.png)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![从十进制到二进制的转换](../Images/c1db22af82dd7c689f6f8f1cb2e9d5c3.png)'
- en: '*Parsing and string representation.* Converting a string of characters to an
    internal representation is called *parsing*. First, we consider a method `parseInt()`
    to parse integers written in any base. Next, we consider a `toString()` method
    to compute a string representation of an integer in any given base. [BinaryConverter.java](BinaryConverter.java.html)
    provides methods for converting from a string of bits to a Java `int` and vice
    versa. [Converter.java](Converter.java.html) is a more general version that handles
    strings of digits in any base between 2 and 36. These are simplified versions
    of Java''s two-argument [Integer.toString()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toString-int-int-)
    and [Integer.parseInt()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseInt-java.lang.String-int-)
    methods.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解析和字符串表示.* 将一串字符转换为内部表示称为*解析*。首先，我们考虑一个方法`parseInt()`来解析以任何进制编写的整数。接下来，我们考虑一个`toString()`方法来计算给定进制中整数的字符串表示。[BinaryConverter.java](BinaryConverter.java.html)提供了将一串位转换为Java
    `int`和反之的方法。[Converter.java](Converter.java.html)是一个更通用的版本，处理2到36之间任何进制的数字字符串。这些是Java的两参数[Integer.toString()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toString-int-int-)和[Integer.parseInt()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseInt-java.lang.String-int-)方法的简化版本。'
- en: The following table contains the decimal, 8-bit binary, and 2-digit hex representations
    of the integers from 0 to 255.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了从0到255的整数的十进制、8位二进制和2位十六进制表示。
- en: '![binary, decimal, and hex 00-7F](../Images/27915791b83f664d70dc7af63dedec68.png)
       ![binary, decimal, and hex 80-FF](../Images/77f22725230d28736b202ba3b3ad7c33.png)'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![二进制、十进制和十六进制00-7F](../Images/27915791b83f664d70dc7af63dedec68.png)    ![二进制、十进制和十六进制80-FF](../Images/77f22725230d28736b202ba3b3ad7c33.png)'
- en: Integer arithmetic.
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数算术。
- en: The first operations that we consider on integers are basic arithmetic operations
    like addition and multiplication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑的整数操作是基本算术运算，如加法和乘法。
- en: '*Addition.* In grade school you learned how to add two decimal integers: add
    the two least significant digits (rightmost digits); if the sum is more than 10,
    then carry a 1 and write down the sum modulo 10\. Repeat with the next digit,
    but this time include the carry bit in the addition. The same procedure generalizes
    to any base by replacing 10 with the desired base.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法.* 在小学时，你学会了如何加两个十进制整数：将两个最低有效位（最右边的位）相加；如果和大于10，则进位1并写下和模10的余数。重复下一个数字，但这次在加法中包括进位位。相同的过程可以通过用所需进制替换10来推广到任何进制。'
- en: '![integer addition (decimal)](../Images/df3664acdebedea152b0a47a434d7a50.png)
        ![integer addition (hex)](../Images/7afe51fec1973b2bf727e9b2f6ed76f2.png)
        ![integer addition (binary)](../Images/2f97b670d07e44b29c199d72be9c3ad3.png)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![整数加法（十进制）](../Images/df3664acdebedea152b0a47a434d7a50.png)     ![整数加法（十六进制）](../Images/7afe51fec1973b2bf727e9b2f6ed76f2.png)
        ![整数加法（二进制）](../Images/2f97b670d07e44b29c199d72be9c3ad3.png)'
- en: '*Unsigned integers.* We can represent only 2^(*n*) integers in an *n*-bit word.
    If we want just non-negative (or *unsigned*) integers, the natural choice is to
    use binary for the integers 0 through 2*n* − 1, with leading 0s. For example,
    with 16-bit words, we can represent the integers from 0 to 65,535.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无符号整数.* 在*n*位字中，我们只能表示2^(*n*)个整数。如果我们只想要非负（或*无符号的*)整数，自然的选择是使用二进制表示0到2*n*
    − 1的整数，带有前导0。例如，使用16位字，我们可以表示0到65,535的整数。'
- en: '*Overflow.* Wee need to pay attention to ensure that the value of the result
    of an arithmetic operation does not exceed the maximum possible value. This condition
    is called *overflow*. For addition of unsigned integers, overflow is easy to detect:
    if the last (leftmost) addition causes a carry, then the result is too large to
    represent.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*溢出.* 我们需要注意确保算术运算的结果值不超过最大可能值。这个条件称为*溢出*。对于无符号整数的加法，溢出很容易检测：如果最后（最左边）的加法导致进位，那么结果太大无法表示。'
- en: '![integer overflow](../Images/bd47a7e9a5a90ae574d1e06c8517fd2d.png)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![整数溢出](../Images/bd47a7e9a5a90ae574d1e06c8517fd2d.png)'
- en: '*Multiplication.* The grade-school algorithm for multiplication works perfectly
    well with any base.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*乘法.* 乘法的小学算法可以在任何进制下完美运行。'
- en: '![integer multiplication (decimal)](../Images/5acdf60ba2946556975d660872202e2f.png)
    ![integer multiplication (hex)](../Images/bcd86195013c7656480d03f4fdc1ca06.png)
    ![integer multiplication (binary)](../Images/3baf3f399cb32e994a8d64c8e16e59c0.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![整数乘法（十进制）](../Images/5acdf60ba2946556975d660872202e2f.png) ![整数乘法（十六进制）](../Images/bcd86195013c7656480d03f4fdc1ca06.png)
    ![整数乘法（二进制）](../Images/3baf3f399cb32e994a8d64c8e16e59c0.png)'
- en: Negative integers.
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负整数。
- en: It is not difficult to modify the integer data type to include negative numbers,
    using a representation known as *two’s complement*. In *n*-bit two’s complement,
    we represent positive numbers as before, but we represent each negative number
    –x with the (positive, unsigned) binary number 2^(*n*) – *x*. For example, the
    4-bit two's complement integer 0101 still represents +5 but 1011 represents –5,
    because 2⁴ – 5 = 11[10] = 1011[2].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 修改整数数据类型以包含负数并不困难，使用一种称为*二进制补码*的表示方法。在*n*位二进制补码中，我们像以前一样表示正数，但我们用（正的，无符号的）二进制数2^(*n*)
    – *x*来表示每个负数–x。例如，4位二进制补码整数0101仍代表+5，但1011代表–5，因为2⁴ – 5 = 11[10] = 1011[2]。
- en: '![4-bit two''s complement integers](../Images/4444e10bc81b2ea785758efd5b691ae3.png)
              ![16-bit two''s complement integers](../Images/82817c36715986dbdee4a736c8528caf.png)'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![4位二进制补码整数](../Images/4444e10bc81b2ea785758efd5b691ae3.png)           ![16位二进制补码整数](../Images/82817c36715986dbdee4a736c8528caf.png)'
- en: '*Addition.* Adding two *n*-bit two’s complement integers is easy: add them
    as if they were unsigned integers. Detecting overflow is a bit more complicated
    than for unsigned integers.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法.* 添加两个*n*位二进制补码整数很容易：将它们像无符号整数一样相加。检测溢出比对无符号整数更复杂一些。'
- en: '![two''s complement integer addition](../Images/fd283afd36f5b14c0cb530219373fa92.png)
              ![two''s complement integer addition](../Images/2f952473372612230c0f3024bddde4d0.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![二进制补码整数加法](../Images/fd283afd36f5b14c0cb530219373fa92.png)           ![二进制补码整数加法](../Images/2f952473372612230c0f3024bddde4d0.png)'
- en: '*Subtraction.* To compute x – y, we compute x + (– y). That is, we can still
    use standard binary addition, if we know how to compute –y. To negate a two''s
    complement integer, flip the bits and then add 1.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减法.* 要计算 x – y，我们计算 x + (– y)。也就是说，如果我们���道如何计算 –y，我们仍然可以使用标准二进制加法。要对二进制补码整数取反，翻转位然后加
    1。'
- en: '![two''s complement integer subtraction](../Images/236e017740152be1841a13716e2f3c6a.png)
              ![two''s complement integer subtraction](../Images/e4ebd4dd9e3ebaa4278b72a66b889d10.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![二进制补码整数减法](../Images/236e017740152be1841a13716e2f3c6a.png)           ![二进制补码整数减法](../Images/e4ebd4dd9e3ebaa4278b72a66b889d10.png)'
- en: '*Java.* Java''s `short`, `int`, and `long` data types are 16-, 32-, and 64-bit
    two’s complement integers, respectively. This explains the bounds on values of
    these types and explains the behavior on overflow in Java that we first observed
    in Section 1.2.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java.* Java 的 `short`、`int` 和 `long` 数据类型分别是 16 位、32 位和 64 位的二进制补码整数。这解释了这些类型值的边界，并解释了我们在第
    1.2 节中首次观察到的 Java 中溢出行为。'
- en: Real numbers.
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数。
- en: The [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_floating_point) defines
    the behavior of floating-point number of most computer systems. For simplicity,
    we illustrate with a 16-bit version known as *half-precision binary floating point*
    or `binary16` for short. The same essential ideas apply to the 32-bit and 64-bit
    versions used in Java, which we refer to as `binary32` and `binary64`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[IEEE 754 标准](https://en.wikipedia.org/wiki/IEEE_floating_point) 定义了大多数计算机系统中浮点数的行为。为简单起见，我们以
    16 位版本（称为 *半精度二进制浮点数* 或简称为 `binary16`）进行说明。相同的基本思想适用于 Java 中使用的 32 位和 64 位版本，我们称之为
    `binary32` 和 `binary64`。'
- en: '*Floating-point.* The real-number representation that is commonly used in computer
    systems is known as *floating point*. It is just like scientific notation, except
    that everything is represented in binary. Just as in scientific notation, a floating-point
    number consists of a *sign*, a *coefficient*, and an *exponent*.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浮点数.* 计算机系统中常用的实数表示称为 *浮点数*。它就像科学计数法一样，只是一切都用二进制表示。与科学计数法一样，浮点数由 *符号*、*系数*
    和 *指数* 组成。'
- en: '![anatomy of a floating-point number](../Images/3398f507992fbebd327dc39a3a8be008.png)
                   ![IEEE 754 half-precision format](../Images/344ae0e471c01c9ccdd2ef4aefd46d25.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![浮点数的结构](../Images/3398f507992fbebd327dc39a3a8be008.png)                ![IEEE
    754 半精度格式](../Images/344ae0e471c01c9ccdd2ef4aefd46d25.png)'
- en: '*Sign.* The first bit of a floating-point number is its *sign*. The sign bit
    is 0 is the number is positive (or zero) and 1 if it is negative.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*符号.* 浮点数的第一位是其 *符号*。如果符号位为 0，则数字为正（或零），如果为 1，则为负。'
- en: '*Exponent.* The next *t* = 5 bits of a floating-point number are devoted to
    its *exponent*. The exponent of a floating-point number is expressed in *offset
    binary*, where we take *R* = 2^(*t*−1) – 1 (15 for `binary16`) and represent any
    decimal number *x* between −*R* and *R* (–15 and 16 for `binary16`) with the binary
    representation of *x* + *R*. For example, 10101 represents the exponent 6 because
    6 + 15 = 21, and 10101[2] is the binary representation of 21.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指数.* 浮点数的接下来的 *t* = 5 位用于其 *指数*。浮点数的指数以 *偏移二进制* 表示，其中我们取 *R* = 2^(*t*−1) –
    1（`binary16` 为 15）并用 *x* 在 −*R* 和 *R*（`binary16` 为 –15 和 16）之间的任何十进制数表示为 *x* +
    *R* 的二进制表示。例如，10101 表示指数 6，因为 6 + 15 = 21，而 10101[2] 是 21 的二进制表示。'
- en: '*Fraction.* The remaining 10 bits are devoted to the *coefficient*. The normalization
    condition implies that the digit before the decimal place in the coefficient is
    always 1, so we need not include that digit in the representation. The bits are
    interpreted as a binary fraction, so 1.101 corresponds to 1 + 2^(−1) + 2^(−3)
    = 1.625.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分数.* 剩余的 10 位用于 *系数*。归一化条件意味着系数小数点前的数字始终为 1，因此我们不需要在表示中包含该数字。这些位被解释为二进制分数，因此
    1.101 对应于 1 + 2^(−1) + 2^(−3) = 1.625。'
- en: '*Encoding and decoding floating-point numbers.* Given these rules, the process
    of *decoding* a number encoded in IEEE 754 format is straightforward. The process
    of *encoding* a number is more complicated, due to the need to normalize and to
    extend binary conversion to include fractions.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编码和解码浮点数.* 遵循这些规则，解码以 IEEE 754 格式编码的数字的过程很简单。编码数字的过程更复杂，因为需要归一化并扩展二进制转换以包括分数。'
- en: '![floating point to decimal conversions](../Images/1b40fbc7744b8097760e765c494dafbb.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![浮点数到十进制的转换](../Images/1b40fbc7744b8097760e765c494dafbb.png)'
- en: '*Java.* Java uses `binary32` for type `float` (32 bits, with 8 bits for the
    exponent and 23 bits for the fraction) and `binary64` for type `double` (64 bits,
    with 11 bits for the exponent and 52 bits for the fraction). This explains the
    bounds on values of these types and explains various anomolous behavior with roundoff
    error that we first observed in Section 1.2.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java.* Java 使用 `binary32` 表示 `float` 类型（32 位，其中 8 位用于指数，23 位用于分数），使用 `binary64`
    表示 `double` 类型（64 位，其中 11 位用于指数，52 位用于分数）。这解释了这些类型值的边界，并解释了我们在第 1.2 节中首次观察到的舍入误差的各种异常行为。'
- en: Java code for manipulating bits.
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于操作位的 Java 代码。
- en: Java defines the `int` data type to be a 32-bit two's complement integer and
    support various operations to manipulate the bits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java 将 `int` 数据类型定义为 32 位二进制补码整数，并支持各种操作来操作位。
- en: '![bit manipulation operations in Java](../Images/761bcf79cd3178db52173070f9e20d0e.png)'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Java 中的位操作](../Images/761bcf79cd3178db52173070f9e20d0e.png)'
- en: Program [BitWhacking.java](BitWhacking.java.html) reads in two integers a and
    b from the command line, applies the bit-whacking operations, and prints the results.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 [BitWhacking.java](BitWhacking.java.html) 从命令行读取两个整数 a 和 b，应用位操作，并打印结果。
- en: '*Binary and hex literals.* You can specify integer literal values in binary
    (by prepending `0b`) and in hex (by prepending `0x`). You can use literals like
    this anywhere that you can use a decimal literal.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制和十六进制字面量.* 您可以在二进制（通过在前面加上 `0b`）和十六进制（通过在前面加上 `0x`）中指定整数字面值。您可以在任何可以使用十进制字面值的地方使用这些字面值。'
- en: '![binary, decimal, and hex literals](../Images/3048204958a4dd56e91d3f683347778b.png)'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![二进制、十进制和十六进制字面量](../Images/3048204958a4dd56e91d3f683347778b.png)'
- en: '*Shifting and bitwise operations.* Java supports a variety of operations to
    manipulate the bits of an integer:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移位和位操作。* Java支持各种操作来操作整数的位：'
- en: 'Complement the bits: change the 0s to 1s and the 1s to 0s.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补码：将0变为1，将1变为0。
- en: 'Bitwise logical operators: apply the *and*, *or*, and *exclusive or* function
    to the corresponding pair of bits.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位逻辑运算符：将对应的两个位应用*与*、*或*和*异或*函数。
- en: '![truth table for AND, OR, and XOR](../Images/6ed5b062f14bb74e0dc4c1d15e666e06.png)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![AND、OR和XOR的真值表](../Images/6ed5b062f14bb74e0dc4c1d15e666e06.png)'
- en: 'Shift left and right: shift the bits left or right a given number of positions.
    For shift right, there are two versions: a *logical shift* fills in the vacated
    positions at left with 0s; an *arithmetic shift* fills in the vacated positions
    at left with the sign bit.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左移和右移：将位左移或右移给定数量的位置。对于右移，有两个版本：*逻辑右移*在左侧填充空出的位置为0；*算术右移*在左侧用符号位填充空出的位置。
- en: 'Here are a few examples:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '![bit manipulation examples](../Images/4d561f15ade0072020d4d5c4e7445588.png)
          ![bit manipulation examples](../Images/76431b15bc7e476e55714271d12e8ea1.png)'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![位操作示例](../Images/4d561f15ade0072020d4d5c4e7445588.png)       ![位操作示例](../Images/76431b15bc7e476e55714271d12e8ea1.png)'
- en: '*Shifting and masking.* One of the primary uses of such operations is *shifting
    and masking*, where we isolate a contiguous group of bits from the others in the
    same word.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移位和掩码。* 这种操作的主要用途之一是*移位和掩码*，其中我们从同一字中隔离一组连续的位。'
- en: Use a *shift right* instruction to put the bits in the rightmost position.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*右移*指令将位放在最右边的位置。
- en: If we want *k* bits, create a literal mask whose bits are all 0 except its *k*
    rightmost bits, which are 1.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要*k*位，创建一个字面掩码，其位全为0，除了其*k*最右边的位为1。
- en: Use a *bitwise and* to isolate the bits. The 0s in the mask lead to zeros in
    the result; the 1s in the mask specify the bits of interest.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*位与*来隔离位。掩码中的0导致结果中的零；掩码中的1指定感兴趣的位。
- en: In the following example, we extract bits 9 through 12 from the 32-bit `int`.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们从32位`int`中提取第9到第12位。
- en: '![shifting and masking](../Images/333070f7a75b8d42bad60ed8151e9a8b.png)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![移位和掩码](../Images/333070f7a75b8d42bad60ed8151e9a8b.png)'
- en: '[ExtractFloat.java](ExtractFloat.java.html) illustrates the use of shifting
    and masking to extract the sign, exponent, and fraction from a floating-point
    number.'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[ExtractFloat.java](ExtractFloat.java.html)演示了使用移位和掩码从浮点数中提取符号、指数和尾数的方法。'
- en: Characters.
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符。
- en: 'To process text, we need a binary encoding for characters. The basic method
    is quite simple: a table defines the correspondence between characters and *n*-bit
    unsigned binary integers. ASCII and Unicode are the two most popular encoding
    schemes.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理文本，我们需要为字符提供二进制编码。基本方法非常简单：一个表定义了字符和*n*位无符号二进制整数之间的对应关系。ASCII和Unicode是两种最流行的编码方案。
- en: '*ASCII.* The [American Standard Code for Information Interchange](https://en.wikipedia.org/wiki/ASCII)
    (ASCII) code is a 7-bit code, though in modern computing it most often is used
    in 8-bit bytes, with the leading bit being ignored. The following table is a definition
    of ASCII that provides the correspondence that you need to convert from 8-bit
    binary (equivalently, 2-digit hex) to a character and back. For example, 4A encodes
    the letter J.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ASCII。* [美国信息交换标准代码](https://en.wikipedia.org/wiki/ASCII)（ASCII）是一个7位代码，尽管在现代计算中，它通常以8位字节的形式使用，忽略了前导位。以下表格是ASCII的定义，提供了您需要从8位二进制（等效地，2位十六进制）转换为字符和反向的对应关系。例如，4A编码了字母J。'
- en: '![hex to ASCII](../Images/cf0650830580b1b7de0597879b83aa8f.png)'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![十六进制转ASCII](../Images/cf0650830580b1b7de0597879b83aa8f.png)'
- en: '![ASCII to binary](../Images/72affb4f8ee08deca10f890dae777451.png)'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![ASCII转二进制](../Images/72affb4f8ee08deca10f890dae777451.png)'
- en: '*Unicode.* [Unicode](https://en.wikipedia.org/wiki/Unicode) is a 21-bit code
    that supports tens of thousands. The dominant implementation of Unicode is known
    as [UTF-8](https://en.wikipedia.org/wiki/UTF-8). UTF-8 is a variable-width character
    encoding that uses 8 bits for ASCII characters, 16 bits for most characters, and
    up to 32 bits for other characters. The encoding rules are complicated, but are
    now implemented in most modern systems (such as Java) so programmers generally
    need not worry much about the details.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unicode。* [Unicode](https://en.wikipedia.org/wiki/Unicode)是一个支持成千上万字符的21位代码。Unicode的主要实现被称为[UTF-8](https://en.wikipedia.org/wiki/UTF-8)。UTF-8是一种可变宽度字符编码，用于ASCII字符的8位，大多数字符的16位，其他字符的最多32位。编码规则很复杂，但现在在大多数现代系统（如Java）中已实现，因此程序员通常不需要过多担心细节。'
- en: Big Endian, little endian.
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大端序、小端序。
- en: Computers differ in the way in which they store multi-byte chunks of information,
    e.g., the 16-bit short integer 0111000011110010 = 70F2. This consists of the two
    bytes 70 and F2, where each byte encodes 8 bits. The two are two primary formats,
    and they differ only in the order or "[endianness](http://mindprod.com/jgloss/endian.html)"
    in which they store the bytes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在存储多字节信息的方式上有所不同，例如，16位短整数0111000011110010 = 70F2。这由两个字节70和F2组成，其中每个字节编码了8位。这两种是两种主要格式，它们只在存储字节的顺序或"[字节序](http://mindprod.com/jgloss/endian.html)"上有所不同。
- en: '*Big endian* systems store the most significant bytes first, e.g., they store
    the integer above in its natural order 70F2. Java uses this format, as does Apple
    Mac, IBM PowerPC G5, Cray, and Sun Sparc.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大端序*系统首先存储最重要的字节，例如，它们以自然顺序70F2存储上面的整数。Java使用这种格式，苹果Mac、IBM PowerPC G5、Cray和Sun
    Sparc也是如此。'
- en: '*Little endian* systems store the least significant bytes first, e.g., they
    store the integer above in reverse byte-order F270\. This format is more natural
    when manually performing arithmetic, e.g., since for addition you work from least
    significant byte to most significant byte. Intel 8086, Intel Pentium, Intel Xeon
    use this format.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小端序*系统首先存储最不重要的字节，例如，它们以反向字节顺序F270存储上面的整数。这种格式在手动执行算术运算时更自然，例如，对于加法，您从最不重要的字节到最重要的字节进行操作。Intel
    8086、Intel Pentium、Intel Xeon使用这种格式。'
- en: Exercises
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Convert the decimal number 92 to binary.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将十进制数92转换为二进制。
- en: '*Solution*: 1011100.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：1011100。'
- en: Convert the hexadecimal number `BB23A` to octal.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将十六进制数 `BB23A` 转换为八进制。
- en: '*Solution*: first convert to binary `1011 1011 0010 0011 1010`, then consider
    the bits three at a time `10 111 011 001 000 111 010`, and convert to octal `2731072`.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 首先转换为二进制 `1011 1011 0010 0011 1010`，然后每次考虑三位 `10 111 011 001 000 111
    010`，并转换为八进制 `2731072`。'
- en: 'Add the two hexadecimal numbers `23AC` and `4B80` and give the result in hexadecimal.
    *Solution*: 6F2C.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将两个十六进制数 `23AC` 和 `4B80` 相加，并以十六进制给出结果。*解决方案*: 6F2C。'
- en: 'Assume that *m* and *n* are positive integers. How many 1 bits are there in
    the binary representation of 2^(*m* + *n*)? *Solution*: 1.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '假设 *m* 和 *n* 是正整数。在 2^(*m* + *n*) 的二进制表示中有多少�� 1 位？*解决方案*: 1。'
- en: What is the only decimal integer whose hexadecimal representation has its digits
    reversed.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的十进制整数是其十六进制表示的数字被颠倒的整数。
- en: '*Solution*: 53 is 35 in hex.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*: 53 在十六进制中是 35。'
- en: Develop an implementation of the `toInt()` method for [Converter.java](Converer.java.html).
    that converts a character in the range `0-9` or `A-Z` into an `int` value between
    0 and 35.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 [Converter.java](Converer.java.html) 开发一个 `toInt()` 方法的实现，将范围在 `0-9` 或 `A-Z`
    的字符转换为介于 0 到 35 之间的 `int` 值。
- en: Develop an implementation of the `toChar()` method for [Converter.java](Converer.java.html).
    that converts an `int` value between 0 and 35 into a character in the range `0-9`
    or `A-Z`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 [Converter.java](Converer.java.html) 开发一个 `toChar()` 方法的实现，将介于 0 到 35 之间的
    `int` 值转换为范围在 `0-9` 或 `A-Z` 的字符。
- en: Creative Exercises
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**IP address.** Write a program [IP.java](IP.java.html) that takes a 32-bit
    string as a command-line argument, and prints the corresponding IP address using
    *dotted decimal* notation. That is, take the bits 8 at a time, convert each group
    to decimal, and separate each group with a dot. For example, the binary IP address
    01010000000100000000000000000001 should be converted to `80.16.0.1`.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IP 地址。** 编写一个程序 [IP.java](IP.java.html)，将一个 32 位字符串作为命令行参数，并使用 *点分十进制* 表示法打印相应的
    IP 地址。也就是说，每次取 8 位，将每组转换为十进制，并用点分隔每组。例如，二进制 IP 地址 01010000000100000000000000000001
    应转换为 `80.16.0.1`。'
- en: Web Exercises
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络练习
- en: '**Excel column numbering.** Write a function that takes a nonnegative integer
    and converts it into the corresponding Excel column name (0 = A, 1 = B, ..., 25
    = Z, 26 = AA, ..., 702 = AAA).'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Excel 列编号。** 编写一个函数，将非负整数转换为相应的 Excel 列名（0 = A，1 = B，...，25 = Z，26 = AA，...，702
    = AAA）。'
- en: '**Elias Gamma coding.** Write a function `elias` that takes as input an integer
    N and returns the Elias Gamma code as a string. The [Elias Gamma code](http://en.wikipedia.org/wiki/Elias_Gamma_coding)
    is a scheme to encode the positive integers. To generate the code for an integer
    N, write the integer N in binary, subtract 1 from the number of bits in the binary
    encoding, and prepend that many zeros. For example, the code for the first 10
    positive integers is given below.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Elias Gamma 编码。** 编写一个函数 `elias`，接受一个整数 N 作为输入，并将 Elias Gamma 编码作为字符串返回。[Elias
    Gamma 编码](http://en.wikipedia.org/wiki/Elias_Gamma_coding) 是一种编码正整数的方案。要为整数 N
    生成编码，将整数 N 用二进制表示，从二进制编码的位数中减去 1，并在前面添加相应数量的零。例如，前 10 个正整数的编码如下所示。'
- en: '[PRE0]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Bit reversal.** Write a function that takes an integer input, reverse its
    bits, and returns that integer. For example if n = 8, and the input is 13 (00001101),
    then its reversal is 176 (10110000).'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**位反转。** 编写一个函数，接受一个整数输入，反转其位，并返回该整数。例如，如果 n = 8，输入为 13（00001101），那么它的反转是 176（10110000）。'
- en: '[PRE1]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Bit-reversal sorting.** Use the previous algorithm to "sort" an array of
    N = 2^n elements into their bit-reversed order. Swap elements i and j if i and
    j are bit reversal of each other. Such permutations arise in the Fast Fourier
    Transform.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**位反转排序。** 使用先前的算法将由 N = 2^n 个元素组成的数组按其位反转顺序“排序”。如果 i 和 j 是彼此的位反转，则交换元素 i 和
    j。这种排列在快速傅立叶变换中出现。'
- en: '[PRE2]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Swap without temporary storage.** What do the following two code fragments
    do given integers a and b?'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无需临时存储交换。** 给定整数 a 和 b，以下两个代码片段分别做什么？'
- en: '[PRE3]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Answer: each 3-line fragment swaps a and b. It works provided a and b are not
    the same variables (in which case both variables are zeroed out).'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '答案: 每个 3 行片段交换 a 和 b。只要 a 和 b 不是相同的变量（在这种情况下，两个变量都将被清零）。'
- en: '**Find the unique integer.** Suppose you have an array of 2N + 1 integers,
    and you know that each of N integers appear exactly twice. Describe an elegant
    and efficient algorithm to identify the integer that appears only once. *Hint*:
    xor.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找到唯一的整数。** 假设你有一个由 2N + 1 个整数组成的数组，并且你知道每个 N 个整数都恰好出现两次。描述一个优雅且高效的算法来识别只出现一次的整数。*提示*:
    异或运算。'
- en: '**Bit-whacking version of Gray codes** Use bit-whacking operations and iteration
    instead of recursion to generate a gray code. Name your program [BitWhackingGrayCode.java](BitWhackingGrayCode.java.html).'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**位操作版本的格雷码** 使用位操作和迭代而不是递归来生成格雷码。将你的程序命名为 [BitWhackingGrayCode.java](BitWhackingGrayCode.java.html)。'
- en: '**Free the prisoners I.** A warden meets with 17 new prisoners when they arrive.
    The warden tells them that they may meet today and plan a strategy, but after
    the meeting, each prisoner will be in solitary confinement and will not be able
    to communicate with one another. The prison has a switch room with 17 switches
    that can be on or off, although the initial configuration is not revealed. There
    is one special setting of the 17 switches that if it is ever achieved will enable
    the prisoners to go free. Each hour the warden escorts one prisoner to the switch
    room, where the prisoner can flip at most one switch (from on to off or off to
    on). The warden can choose prisoners in arbitrary order, so one prisoner may be
    chosen four times in a row, or not at all. Design a strategy for the 17 prisoners
    so that they are guaranteed to be set free after some finite amount of time.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**释放囚犯I。** 当17名新囚犯到达时，看守与他们见面。看守告诉他们，他们今天可以见面并制定一个策略，但会议结束后，每个囚犯将被单独关押，无法互相交流。监狱有一个有17个开关的开关室，可以打开或关闭，尽管初始配置未透露。有一种特殊的17个开关设置，如果它被实现，囚犯们就可以自由了。每小时，看守会带一名囚犯到开关室，囚犯最多可以翻转一个开关（从开到关或从���到开）。看守可以任意选择囚犯的顺序，因此一个囚犯可能连续四次被选择，或者根本不被选择。设计一个策略，使17名囚犯保证在有限时间内被释放。'
- en: '**Free the prisoners II.** Same premise as above, except that the switch room
    has 2 switches (initially both off), and a prisoner must flip exactly one of the
    two switches upon entering the switch room. At any time, a prisoner may declare
    "all 17 of us have visited the control room." If it is true, all prisoners are
    freed; otherwise they are all executed. The warden can choose prisoners in arbitrary
    order, so one prisoner may be chosen four times in a row, but each prisoner will
    be chosen infinitely often (assuming they are never freed). Design a strategy
    for the 17 prisoners so that they are guaranteed to be set free after some finite
    amount of time. *Extra credit*: don''t assume the initial configuration is known.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**释放囚犯II。** 与上述相同的前提，只是开关室有2个开关（最初都关闭），囚犯进入开关室时必须翻转其中一个开关。任何时候，一个囚犯可以宣布“我们17个人都去过控制室了”。如果是真的，所有囚犯都将被释放；否则他们都将被处决。看守可以任意选择囚犯的顺序，因此一个囚犯可能连续四次被选择，但每个囚犯将被无限次选择（假设他们从未被释放）。设计一个策略，使17名囚犯保证在有限时间内被释放。*额外加分*：不要假设初始配置是已知的。'
- en: '**Count the number of 1 bits.** Write function that takes an integer input
    and returns the [number of 1''s in its binary representation](http://www-db.stanford.edu/~manku/bitcount/bitcount.html).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算1位的数量。** 编写一个函数，接受一个整数输入，并返回其二进制表示中的1的数量。'
- en: '*Answer*: here are an iterative and a recursive solution.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：这里有一个迭代和一个递归解决方案。'
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is how `Integer.bitCount()` is implemented by Java. See if you can figure
    out how it works.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是Java如何实现`Integer.bitCount()`的。看看你能否弄清楚它是如何工作的。
- en: '[PRE5]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Sparse bit-counting.** Explain why the following function (that often appears
    in job interviews for programmers) correctly counts the number of 1 bits in the
    binary representation of its input. If the input has k 1s, how many times does
    the while loop iterate?'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稀疏位计数。** 解释为什么以下函数（在程序员的面试中经常出现）正确计算其输入的二进制表示中1的位数。如果输入有k个1，while循环会迭代多少次？'
- en: '[PRE6]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Table lookup bit-counting.** Repeat the previous exercise, but pre-compute
    a table to speed up the computation.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查表位计数。** 重复前面的练习，但预先计算一个表以加快计算速度。'
- en: '*Answer*: this one assumes you have a precomputed table of size 256, with `bits[i]`
    storing the number of 1 bits in the binary representation of i. You can use the
    bit counting function from the previous exercise to initialize it. previous'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：这个假设你有一个大小为256的预先计算的表，其中`bits[i]`存储i的二进制表示中1的位数。你可以使用前面练习中的位计数函数来初始化它。'
- en: '[PRE7]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Increasing the table size to 2^(16) = 65,536 will make things faster assuming
    you have sufficient memory. A table of size 2^(32) is likely prohibitive.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将表大小增加到2^(16) = 65,536会使事情变得更快，假设你有足够的内存。大小为2^(32)的表可能是禁止的。
- en: '**Java library functions for bit-whacking.** Re-implement the following static
    methods that defined in the [Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)
    class.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java库函数用于位操作。** 重新实现[Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)类中定义的以下静态方法。'
- en: '| FUNCTION | RETURN VALUE |'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 函数 | 返回值 |'
- en: '| `Integer.bitCount(x)` | Number of one-bits in x |'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.bitCount(x)` | x中1的位数 |'
- en: '| `Integer.highestOneBit(x)` | Zero out all but the leftmost one bit of x.
    |'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.highestOneBit(x)` | 将x除最左边的1位外都置零。 |'
- en: '| `Integer.lowestOneBit(x)` | Zero out all but the rightmost one bit of x.
    |'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.lowestOneBit(x)` | 将x除最右边的1位外都置零。 |'
- en: '| `Integer.numberOfLeadingZeros(x)` | Number of zero bits preceding highest
    one bit. |'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.numberOfLeadingZeros(x)` | 最高位1前面的零位数。 |'
- en: '| `Integer.numberOfTrailingZeros(x)` | Number of zero bits following lowest
    one bit. |'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.numberOfTrailingZeros(x)` | 最低位1后面的零位数。 |'
- en: '| `Integer.rotateLeft(x, i)` | Rotate of x by circularly shifting i bits to
    the left. |'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.rotateLeft(x, i)` | 将x循环左移i位。 |'
- en: '| `Integer.rotateRight(x, i)` | Rotate x by circularly shifting i bits to the
    right. |'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.rotateRight(x, i)` | 将x循环右移i位。 |'
- en: '| `Integer.reverse(x)` | Reverse of the bits of x. |'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Integer.reverse(x)` | x的位的反转。 |'
- en: '**Dictionary attack.** One method that sleazy spammers use to auto-generate
    email addresses is by enumerating all possible email addresses at a give domain,
    e.g., hotmail.com. This annoying tactic is called a dictionary or Rumpelstiltskin
    attack and explains why you sometimes receive spam on a new email address to which
    you haven''t given to anybody. Use [Converter.java](Converter.java.html) to design
    such a program. Your program [Rumpelstiltskin.java](Rumpelstiltskin.java.html)
    should take a command line parameter N and print out all 36^N possible passwords
    of N or fewer characters involving numbers and uppercase letters.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字典攻��。**一种肮脏的垃圾邮件发送者使用的方法是通过枚举给定域名（例如hotmail.com）的所有可能的电子邮件地址来自动生成电子邮件地址。这种恼人的策略称为字典或Rumpelstiltskin攻击，解释了为什么有时候你会收到发送到你尚未告知任何人的新电子邮件地址的垃圾邮件。使用[Converter.java](Converter.java.html)设计这样一个程序。你的程序[Rumpelstiltskin.java](Rumpelstiltskin.java.html)应该接受一个命令行参数N，并打印出所有36^N个可能的密码，其中包括数字和大写字母。'
- en: '**Breaking a gold chain.** You have a gold chain with 14 links that you are
    going to use to pay an worker for 15 days at a fee of 1 gold link per day. It''s
    possible to split the chain into 15 pieces by cutting 14 times. Your goal is to
    pay the worker while only breaking the chain 3 times. The worker must receive
    exactly the right fraction of total payment after each day of work. *Hint:* break
    the chain so there are pieces of 1 section, 2 sections, 4 sections, and 8 sections.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断金链。**你有一条有14个环节的金链，你要用它来支付一个工人15天，每天1个金环节的费用。通过切割14次，可以将链子分成15段。你的目标是在只断开链子3次的情况下支付工人。工人必须在每天工作结束后准确收到总支付的一定比例。*提示：*将链子断开，使得有1段、2段、4段和8段的部分。'
- en: '**Hamming encoder.** Write a Java program [HammingEncoder.java](HammingEncoder.java.html)
    that reads in a sequence of 0s and 1s, 4 bits at a time, and encodes them using
    Hamming codes.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**海明编码器。**编写一个Java程序[HammingEncoder.java](HammingEncoder.java.html)，读取0和1序列，每次4位，使用海明码进行编码。'
- en: '**Hamming decoder.** Write a Java program [HammingDecoder.java](HammingDecoder.java.html)
    that reads in a sequence of 0s and 1s encoded using Hamming codes, 7 bits at a
    time, and decodes and correct them.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**海明译码器。**编写一个Java程序[HammingDecoder.java](HammingDecoder.java.html)，读取使用海明码编码的0和1序列，每次7位，解码并纠正错误。'
- en: '**Hamming codes.** Modify your solutions to the previous two exercises so that
    the input bits are packed 8 to the byte.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**海明码。**修改你之前两个练习的解决方案，使输入位每8位打包一次。'
- en: '**Absolute value.** The constant `Integer.MIN_VALUE` is the most negative 32-bit
    two''s complement integer. What is `Math.abs(Integer.MIN_VALUE)`?'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绝对值。**常量`Integer.MIN_VALUE`是最负的32位补码整数。`Math.abs(Integer.MIN_VALUE)`是多少？'
- en: Prove that a k-digit decimal number can be represented in binary with no more
    than 4k bits.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明一个k位的十进制数可以用不超过4k位的二进制表示。
- en: '**Sum of powers of 2.** Compute the sum of powers of 2. What value do you end
    up with on two''s complement machine?'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2的幂之和。**计算2的幂之和。在补码机器上，你最终得到什么值？'
- en: '**CD Database.** CDDB and [freedb](http://freedb.org) are databases that allow
    you to look up CD information on the Web and display the artist, title, and song
    name. Each CD has a (nearly) unique disc ID number which is used to query the
    database.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CD数据库。**CDDB和[freedb](http://freedb.org)是允许你在网络上查找CD信息并显示艺术家、标题和歌曲名称的数据库。每张CD都有一个（几乎）唯一的唱片ID号码，用于查询数据库。'
- en: Write a static method sumDigits() that takes an integer parameter and returns
    the sum of the decimal digits in the integer. For example, sumDigits(6324) returns
    15 since 6 + 3 + 2 + 4 = 15.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个静态方法`sumDigits()`，接受一个整数参数，并返回整数中十进制数字的和。例如，`sumDigits(6324)`返回15，因为6 +
    3 + 2 + 4 = 15。
- en: 'Write a program [CDDB.java](CDDB.java.html) that computes the disc ID from
    a list of lengths of the track lengths. The 32-bit (8 hex digit) ID number is
    computed from the length of the tracks on the CD and the number of tracks as follows:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[CDDB.java](CDDB.java.html)，从曲目长度列表计算出唱片ID。32位（8位十六进制数字）ID号码是根据CD上曲目的长度和曲目数计算的：
- en: '[PRE8]'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: True or false. If a xor b = c, then c xor a = b and c xor b = a.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假。如果a xor b = c，那么c xor a = b，c xor b = a是否成立？
- en: Explain why the following code fragment does not leave `ABCD` in variable `a`.
    How would you fix it?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么以下代码片段不会将`ABCD`留在变量`a`中。你会如何修复它？
- en: '[PRE9]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Answer*. In Java, `byte` is a signed 8-bit integer. The right-shift promotes
    `b0` to a (negative) integer. To fix the problem, use `c = ((b0 & 0xff) << 8)
    | (b1 & 0xff);`.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*。在Java中，`byte`是一个有符号的8位整数。右移会将`b0`提升为一个（负的）整数。要解决问题，使用`c = ((b0 & 0xff)
    << 8) | (b1 & 0xff);`。'
- en: '**Poisonous wine.** "You are the ruler of an empire and you are about to have
    celebration tomorrow. The celebration is the most important party you have ever
    hosted. You''ve got 1000 bottles of wine you were planning to open for the celebration,
    but you find out that one of them is poisoned. The actual poison exhibits no symptoms
    until somewhere around the 23rd hour, then results in sudden death. You have thousands
    of prisoners at your disposal. What is the smallest number of prisoners you must
    have to drink from the bottles to find the poisoned bottle?"'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有毒的酒。**“你是一个帝国的统治者，明天你将举办庆典。这次庆典是你举办过的最重要的派对。你有1000瓶酒打算在庆典上开启，但你发现其中一瓶被下毒了。实际的毒药在大约第23个小时左右才会出现症状，然后导致突然死亡。你手头有成千上万的囚犯。你必须让多少囚犯从瓶子中喝酒才能找到被下毒的瓶子？”'
- en: '*Hint*: you can represent the number 1,000 using 10 bits.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示：*你可以用10位表示数字1,000。'
- en: '**Unsigned 32-bit integers.** Describe how to simulate 32-bit unsigned integers
    in Java.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无符号32位整数。**描述如何在Java中模拟32位无符号整数。'
- en: '*Solution*: First, are you sure that you really need an unsigned type. Signed
    and unsigned integers behave identically on the bitwise operators (except >>),
    addition, subtraction, and multiplication. In many applications, these are sufficient,
    assuming you replace >> with >>>. Comparison operators are easy to simulate by
    checking the sign bit. Division and remainder are the trickiest: the easiest solution
    is to convert to type `long`.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：首先，您确定您真的需要无符号类型吗。有符号和无符号整数在位运算符（除了>>）、加法、减法和乘法上的行为是相同的。在许多应用程序中，这些已经足够了，假设您用>>>替换>>。比较运算符易于通过检查符号位来模拟。除法和余数是最棘手的：最简单的解决方案是转换为`long`类型。'
- en: '[PRE10]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Program [UnsignedDivision.java](UnsignedDivision.java.html) uses this trick,
    and also does it directly using 32-bit operations.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序[UnsignedDivision.java](UnsignedDivision.java.html)使用这个技巧，并且还直接使用32位操作。
- en: '**Unsigned 8-bit integers.** Describe how to simulate 8-bit unsigned integers
    in Java.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无符号8位整数。**描述如何在Java中模拟8位无符号整数。'
- en: '*Solution*: Same advice as previous question. One place where it''s nice to
    have unsigned integers is for a lookup table, indexed by the byte. With signed
    integers the index can be negative. Also, if `b` is a `byte`, then `b << 4` automatically
    casts `b` to an `int`. This could be undesirable since `b` is signed. In many
    applications you need to remove the signed extended bits via `(b << 4) & 0xff`.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：与前一个问题相同的建议。使用无符号整数很好的一个地方是用于查找表，由字节索引。使用有符号整数，索引可能为负。此外，如果`b`是`byte`，那么`b
    << 4`会自动将`b`转换为`int`。这可能是不希望的，因为`b`是有符号的。在许多应用程序中，您需要通过`(b << 4) & 0xff`来去除符号扩展位。'
- en: '**Adding two short integers.** Explain why the following code fragment fails.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加两个short整数。**解释为什么以下代码片段失败。'
- en: '[PRE11]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Solution*: Java automatically promotes the results of most integer operations
    to be of type `int`. To assign the result to a `short`, you need to explicitly
    cast it back `c = (short) (a + b)`. Yes, this is rather quirky. One exception
    to this rule is if you use `+=`, in which case the cast is performed automatically.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：Java自动将大多数整数操作的结果提升为`int`类型。要将结果分配给`short`，需要显式将其转换回`c = (short) (a
    + b)`。是的，这有点古怪。这个规则的一个例外是如果使用`+=`，那么转换会自动执行。'
- en: '**Masking with byte.** Explain why `(b << i)` give weird results when `b` is
    of type `byte`.'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**使用字节掩码。**解释当`b`是`byte`类型时，`(b << i)`会产生奇怪的结果的原因。'
- en: '*Solution*: In Java, `byte` is an 8-bit signed integer. Before the right shift,
    `b` is converted to an integer. You may want `((b & 0xff) << i)` instead.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：在Java中，`byte`是一个8位有符号整数。在右移之前，`b`被转换为整数。您可能想要使用`((b & 0xff) << i)`。'
- en: How many bits are in the binary representation of 2^2^2^2^17?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2^2^2^2^17的二进制表示中有多少位？
- en: What does the following code fragment from program [Overflow.java](Overflow.java.html)
    print?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序[Overflow.java](Overflow.java.html)中的以下代码片段打印什么？
- en: '[PRE12]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What does the following code fragment print?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE13]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'List all values `a` of type `int` for which `(a == (a >> 1))`. *Hint*: there
    is more than one.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有`int`类型的`a`值，使得`(a == (a >> 1))`。*提示*：不止一个。
- en: 'Suppose `a` is a variable of type `int`. Find two values of `a` for which `(a
    == -a)` is `true`. *Answer*: 0 and -2147483648.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`a`是`int`类型的变量。找到两个值的`a`，使得`(a == -a)`为`true`。*答案*：0和-2147483648。
- en: 'What is the result of `a = -1 * -2147483648`? *Answer*: 0.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a = -1 * -2147483648`的结果是什么？*答案*：0。'
- en: What does the following code fragment print out?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印出什么？
- en: '[PRE14]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Given two positive integers `a` and `b`, what result does the following Java
    code fragment leave in `c`?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定两个正整数`a`和`b`，以下Java代码片段将在`c`中留下什么结果？
- en: '[PRE15]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Answer*: a * b.'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：a * b。'
- en: What does the following code do to the integers stored in two different variables
    a and b?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码对存储在两个不同变量`a`和`b`中的整数做了什么？
- en: '[PRE16]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Repeat the previous question, but assume a and b are the same variable.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一个问题，但假设`a`和`b`是相同的变量。
- en: What does the following code do to the integers stored in two different variables
    a and b? Any problems with overflow?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码对存储在两个不同变量`a`和`b`中的整数做了什么？有溢出问题吗？
- en: '[PRE17]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What do each of the following statements do?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每个语句做什么？
- en: '[PRE18]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Increment x, decrement x*'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*增加x，减少x*'
- en: What does the following do?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码做什么？
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Answer: computes the parity of the number of 1 bits set in the binary representation
    of a using divide-and-conquer.'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：使用分治法计算二进制表示中设置的1位数的奇偶性。
- en: What is the value of `cnt` after the following loop?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下循环后，`cnt`的值是多少？
- en: '[PRE20]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Hint*: it''s not an infinite loop.'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：这不是一个无限循环。'
- en: Explain why the following Java code fragment correctly determines whether the
    integer n is a power of 2.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么以下Java代码片段正确确定整数`n`是否为2的幂。
- en: '[PRE21]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Counting in base -2.** Use the definition of the positional notation to define
    the base -2 number system. There are two digits 0 and 1\. Count from -7 to 7 in
    this system.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以-2为基数计数。**使用位置表示法的定义来定义基数为-2的数字系统。有两个数字0和1。在这个系统中从-7到7计数。'
- en: '[PRE22]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**RGBA color format.** Some of Java''s classes (BufferedImage, PixelGrabber)
    use a special encoding called RGBA to store the color of each pixel. The format
    consists of four integers, representing the red, green, and blue intensities from
    0 (not present) to 255 (fully used), and also the alpha transparency value from
    0 (transparent) to 255 (opaque). The four 8-bit integers are compacted into a
    single 32-bit integer. Write a code fragment to extract the four components from
    the RGBA integer, and to go the other way.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RGBA颜色格式。** Java的一些类（BufferedImage、PixelGrabber）使用一种称为RGBA的特殊编码来存储每个像素的颜色。该格式由四个整数组成，表示从0（不存在）到255（完全使用）的红、绿和蓝强度，以及从0（透明）到255（不透明）的alpha透明度值。这四个8位整数被压缩成一个32位整数。编写一个代码片段，从RGBA整数中提取四个分量，并反向操作。'
- en: '[PRE23]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Min and max.** One of the following computes min(a, b), the other computes
    max(a, b) without branching. Which is which? Explain how it works.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小值和最大值。** 以下哪个计算`min(a, b)`，另一个计算`max(a, b)`而不使用分支。哪个是哪个？解释它是如何工作的。'
- en: '[PRE24]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Find the missing value.** Suppose you have an array consisting of 2^(32)
    - 1 integers of type `int` such that no integer appears more than once. Since
    there are 2^(32) possible values, exactly one integer is missing. Write a code
    fragment to find the missing integer using as little extra storage as possible.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找到缺失的值。** 假设你有一个由`int`类型的2^(32) - 1个整数组成的数组，其中没有任何整数出现超过一次。由于有2^(32)个可能的值，恰好有一个整数缺失。编写一个代码片段，尽可能少地使用额外存储来找到缺失的整数。'
- en: '*Hint*: this is a popular interview question. It''s possible to do it using
    only one extra `int`. Use either properties of integer overflow on two''s complement
    integers or use the XOR function.'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：这是一个常见的面试问题。可以只使用一个额外的`int`来完成。可以利用整数溢出的性质或使用XOR函数来实现。'
- en: '**Cyclic redundancy check.** Write programs [CRC16.java](CRC16.java.html) and
    [CRC32.java](CRC32.java.html) that read in data from standard input and computes
    its 16 or 32-bit CRC. Write a program [CRC16CCITT.java"](CRC16CCITT.java.html)
    for 16-bit CRC in CCITT format.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**循环冗余校验。** 编写程序[CRC16.java](CRC16.java.html)和[CRC32.java](CRC32.java.html)从标准输入读取数据并计算其16位或32位CRC。编写一个程序[CRC16CCITT.java"](CRC16CCITT.java.html)用于CCITT格式的16位CRC。'
