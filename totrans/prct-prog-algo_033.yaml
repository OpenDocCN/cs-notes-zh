- en: 6.1   Representing Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/61data](https://introcs.cs.princeton.edu/java/61data)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Everything suited for processing with digital computers is represented as a
    sequence of 0s and 1s, whether it be numeric data, text, executable files, images,
    audio, or video. The meaning of a given sequence of bits within a computer depends
    on the context. In this section we describe how to represent integers in binary,
    decimal, and hexadecimal and how to convert between different representations.
    We also describe how to represent negative integers and floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Binary and hexadecimal.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Babylonian times, people have represented integers using *positional notation*
    with a fixed base. The most familiar of these systems is *decimal*, where the
    base is 10 and each positive integer is represented as a string of digits between
    0 and 9. Specifically, Specifically, \( d_n d_{n-1} \ldots d_2 d_1 d_0 \) represents
    the integer
  prefs: []
  type: TYPE_NORMAL
- en: $$\quad\quad\quad\quad\quad\;\; d_n10^n + d_{n-1}10^{n-1} + \ldots + d_210^2
    + d_110^1 + d_010^0$$
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, `10345` represents the integer 10,345 = 1·10⁴ + 0·10³ + 3·10² +
    4·10¹ + 5·10⁰.
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary.* When the base is 2, we represent an integer as a sequence of 0s and
    1s. In this case, we refer to each binary (base 2) digit—either 0 or 1—as a *bit*.
    Specifically, \(b_n b_{n-1} \ldots b_2 b_1 b_0\) represents the integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$\quad\quad\quad\quad b_n 2^n + b_{n-1} 2^{n-1} + \ldots + b_2 2^2 + b_1 2^1
    + b_0 2^0$$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, `1100011` represents the integer 99 = 1·2⁶ + 1·2⁵ + 0·2⁴ + 0·2³
    + 0·2² + 1·2¹ + 1·2⁰.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Hexadecimal.* ![hexadecimal digits](../Images/8f15cc32db92a0b8c27d1e0e64220bfa.png)
    In hexadecimal (or *hex*), the sequence of hex digits Specifically, \(h_n h_{n-1}
    \ldots h_2 h_1 h_0\) represents the integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$\quad\quad\quad\quad\;\; h_n 16^n + h_{n-1} 16^{n-1} + \ldots + h_2 16^2 +
    h_1 16^1 + h_0 16^0$$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: We need to have one character to represent each digit, so we use `A` for 10,
    `B` for 11, `C` for 12, and so forth. For example, `FACE` represents the integer
    64,206 = 15·16³ + 10·16² + 12·16¹ + 14·16⁰.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Number conversion.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know how to convert from a number represented in one system to another.
  prefs: []
  type: TYPE_NORMAL
- en: '*Converting between hex and binary.* Given the hex representation of a number,
    finding the binary representation is easy, and vice versa, because 16 is a power
    of 2. To convert from hex to binary, replace each hex digit by the four binary
    bits corresponding to its value. Conversely, to convert from binary to hex, prepend
    leading 0s to make the number of bits a multiple of 4, then group the bits 4 at
    a time and convert each group to a single hex digit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Hexadecimal to binary conversion](../Images/767bddd7bb383d475425d3678deb2d04.png)
           ![Binary to hexadecimal conversion](../Images/aa15177682b2e5de51d375aa4b5e07cd.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Converting from decimal to base b.* It is slightly more difficult to convert
    an integer represented in decimal to one in base *b* because we are accustomed
    to performing arithmetic in base 10. The easiest way to convert from decimal to
    base *b* by hand is to repeatedly divide by the base *b*, and read the remainder
    upwards. For example, the calculations below convert from the decimal integer
    366 to binary (101101110) and to hexadecimal (16E).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Converting from decimal to binary](../Images/c1db22af82dd7c689f6f8f1cb2e9d5c3.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Parsing and string representation.* Converting a string of characters to an
    internal representation is called *parsing*. First, we consider a method `parseInt()`
    to parse integers written in any base. Next, we consider a `toString()` method
    to compute a string representation of an integer in any given base. [BinaryConverter.java](BinaryConverter.java.html)
    provides methods for converting from a string of bits to a Java `int` and vice
    versa. [Converter.java](Converter.java.html) is a more general version that handles
    strings of digits in any base between 2 and 36. These are simplified versions
    of Java''s two-argument [Integer.toString()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toString-int-int-)
    and [Integer.parseInt()](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseInt-java.lang.String-int-)
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table contains the decimal, 8-bit binary, and 2-digit hex representations
    of the integers from 0 to 255.
  prefs: []
  type: TYPE_NORMAL
- en: '![binary, decimal, and hex 00-7F](../Images/27915791b83f664d70dc7af63dedec68.png)
       ![binary, decimal, and hex 80-FF](../Images/77f22725230d28736b202ba3b3ad7c33.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Integer arithmetic.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first operations that we consider on integers are basic arithmetic operations
    like addition and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '*Addition.* In grade school you learned how to add two decimal integers: add
    the two least significant digits (rightmost digits); if the sum is more than 10,
    then carry a 1 and write down the sum modulo 10\. Repeat with the next digit,
    but this time include the carry bit in the addition. The same procedure generalizes
    to any base by replacing 10 with the desired base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![integer addition (decimal)](../Images/df3664acdebedea152b0a47a434d7a50.png)
        ![integer addition (hex)](../Images/7afe51fec1973b2bf727e9b2f6ed76f2.png)
        ![integer addition (binary)](../Images/2f97b670d07e44b29c199d72be9c3ad3.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Unsigned integers.* We can represent only 2^(*n*) integers in an *n*-bit word.
    If we want just non-negative (or *unsigned*) integers, the natural choice is to
    use binary for the integers 0 through 2*n* − 1, with leading 0s. For example,
    with 16-bit words, we can represent the integers from 0 to 65,535.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overflow.* Wee need to pay attention to ensure that the value of the result
    of an arithmetic operation does not exceed the maximum possible value. This condition
    is called *overflow*. For addition of unsigned integers, overflow is easy to detect:
    if the last (leftmost) addition causes a carry, then the result is too large to
    represent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![integer overflow](../Images/bd47a7e9a5a90ae574d1e06c8517fd2d.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Multiplication.* The grade-school algorithm for multiplication works perfectly
    well with any base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![integer multiplication (decimal)](../Images/5acdf60ba2946556975d660872202e2f.png)
    ![integer multiplication (hex)](../Images/bcd86195013c7656480d03f4fdc1ca06.png)
    ![integer multiplication (binary)](../Images/3baf3f399cb32e994a8d64c8e16e59c0.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Negative integers.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not difficult to modify the integer data type to include negative numbers,
    using a representation known as *two’s complement*. In *n*-bit two’s complement,
    we represent positive numbers as before, but we represent each negative number
    –x with the (positive, unsigned) binary number 2^(*n*) – *x*. For example, the
    4-bit two's complement integer 0101 still represents +5 but 1011 represents –5,
    because 2⁴ – 5 = 11[10] = 1011[2].
  prefs: []
  type: TYPE_NORMAL
- en: '![4-bit two''s complement integers](../Images/4444e10bc81b2ea785758efd5b691ae3.png)
              ![16-bit two''s complement integers](../Images/82817c36715986dbdee4a736c8528caf.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '*Addition.* Adding two *n*-bit two’s complement integers is easy: add them
    as if they were unsigned integers. Detecting overflow is a bit more complicated
    than for unsigned integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![two''s complement integer addition](../Images/fd283afd36f5b14c0cb530219373fa92.png)
              ![two''s complement integer addition](../Images/2f952473372612230c0f3024bddde4d0.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Subtraction.* To compute x – y, we compute x + (– y). That is, we can still
    use standard binary addition, if we know how to compute –y. To negate a two''s
    complement integer, flip the bits and then add 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![two''s complement integer subtraction](../Images/236e017740152be1841a13716e2f3c6a.png)
              ![two''s complement integer subtraction](../Images/e4ebd4dd9e3ebaa4278b72a66b889d10.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Java.* Java''s `short`, `int`, and `long` data types are 16-, 32-, and 64-bit
    two’s complement integers, respectively. This explains the bounds on values of
    these types and explains the behavior on overflow in Java that we first observed
    in Section 1.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real numbers.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_floating_point) defines
    the behavior of floating-point number of most computer systems. For simplicity,
    we illustrate with a 16-bit version known as *half-precision binary floating point*
    or `binary16` for short. The same essential ideas apply to the 32-bit and 64-bit
    versions used in Java, which we refer to as `binary32` and `binary64`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating-point.* The real-number representation that is commonly used in computer
    systems is known as *floating point*. It is just like scientific notation, except
    that everything is represented in binary. Just as in scientific notation, a floating-point
    number consists of a *sign*, a *coefficient*, and an *exponent*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![anatomy of a floating-point number](../Images/3398f507992fbebd327dc39a3a8be008.png)
                   ![IEEE 754 half-precision format](../Images/344ae0e471c01c9ccdd2ef4aefd46d25.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Sign.* The first bit of a floating-point number is its *sign*. The sign bit
    is 0 is the number is positive (or zero) and 1 if it is negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exponent.* The next *t* = 5 bits of a floating-point number are devoted to
    its *exponent*. The exponent of a floating-point number is expressed in *offset
    binary*, where we take *R* = 2^(*t*−1) – 1 (15 for `binary16`) and represent any
    decimal number *x* between −*R* and *R* (–15 and 16 for `binary16`) with the binary
    representation of *x* + *R*. For example, 10101 represents the exponent 6 because
    6 + 15 = 21, and 10101[2] is the binary representation of 21.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fraction.* The remaining 10 bits are devoted to the *coefficient*. The normalization
    condition implies that the digit before the decimal place in the coefficient is
    always 1, so we need not include that digit in the representation. The bits are
    interpreted as a binary fraction, so 1.101 corresponds to 1 + 2^(−1) + 2^(−3)
    = 1.625.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Encoding and decoding floating-point numbers.* Given these rules, the process
    of *decoding* a number encoded in IEEE 754 format is straightforward. The process
    of *encoding* a number is more complicated, due to the need to normalize and to
    extend binary conversion to include fractions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![floating point to decimal conversions](../Images/1b40fbc7744b8097760e765c494dafbb.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Java.* Java uses `binary32` for type `float` (32 bits, with 8 bits for the
    exponent and 23 bits for the fraction) and `binary64` for type `double` (64 bits,
    with 11 bits for the exponent and 52 bits for the fraction). This explains the
    bounds on values of these types and explains various anomolous behavior with roundoff
    error that we first observed in Section 1.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java code for manipulating bits.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java defines the `int` data type to be a 32-bit two's complement integer and
    support various operations to manipulate the bits.
  prefs: []
  type: TYPE_NORMAL
- en: '![bit manipulation operations in Java](../Images/761bcf79cd3178db52173070f9e20d0e.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Program [BitWhacking.java](BitWhacking.java.html) reads in two integers a and
    b from the command line, applies the bit-whacking operations, and prints the results.
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary and hex literals.* You can specify integer literal values in binary
    (by prepending `0b`) and in hex (by prepending `0x`). You can use literals like
    this anywhere that you can use a decimal literal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![binary, decimal, and hex literals](../Images/3048204958a4dd56e91d3f683347778b.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Shifting and bitwise operations.* Java supports a variety of operations to
    manipulate the bits of an integer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complement the bits: change the 0s to 1s and the 1s to 0s.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitwise logical operators: apply the *and*, *or*, and *exclusive or* function
    to the corresponding pair of bits.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![truth table for AND, OR, and XOR](../Images/6ed5b062f14bb74e0dc4c1d15e666e06.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Shift left and right: shift the bits left or right a given number of positions.
    For shift right, there are two versions: a *logical shift* fills in the vacated
    positions at left with 0s; an *arithmetic shift* fills in the vacated positions
    at left with the sign bit.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![bit manipulation examples](../Images/4d561f15ade0072020d4d5c4e7445588.png)
          ![bit manipulation examples](../Images/76431b15bc7e476e55714271d12e8ea1.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Shifting and masking.* One of the primary uses of such operations is *shifting
    and masking*, where we isolate a contiguous group of bits from the others in the
    same word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a *shift right* instruction to put the bits in the rightmost position.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want *k* bits, create a literal mask whose bits are all 0 except its *k*
    rightmost bits, which are 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a *bitwise and* to isolate the bits. The 0s in the mask lead to zeros in
    the result; the 1s in the mask specify the bits of interest.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, we extract bits 9 through 12 from the 32-bit `int`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![shifting and masking](../Images/333070f7a75b8d42bad60ed8151e9a8b.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '[ExtractFloat.java](ExtractFloat.java.html) illustrates the use of shifting
    and masking to extract the sign, exponent, and fraction from a floating-point
    number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Characters.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To process text, we need a binary encoding for characters. The basic method
    is quite simple: a table defines the correspondence between characters and *n*-bit
    unsigned binary integers. ASCII and Unicode are the two most popular encoding
    schemes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*ASCII.* The [American Standard Code for Information Interchange](https://en.wikipedia.org/wiki/ASCII)
    (ASCII) code is a 7-bit code, though in modern computing it most often is used
    in 8-bit bytes, with the leading bit being ignored. The following table is a definition
    of ASCII that provides the correspondence that you need to convert from 8-bit
    binary (equivalently, 2-digit hex) to a character and back. For example, 4A encodes
    the letter J.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![hex to ASCII](../Images/cf0650830580b1b7de0597879b83aa8f.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '![ASCII to binary](../Images/72affb4f8ee08deca10f890dae777451.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Unicode.* [Unicode](https://en.wikipedia.org/wiki/Unicode) is a 21-bit code
    that supports tens of thousands. The dominant implementation of Unicode is known
    as [UTF-8](https://en.wikipedia.org/wiki/UTF-8). UTF-8 is a variable-width character
    encoding that uses 8 bits for ASCII characters, 16 bits for most characters, and
    up to 32 bits for other characters. The encoding rules are complicated, but are
    now implemented in most modern systems (such as Java) so programmers generally
    need not worry much about the details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big Endian, little endian.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computers differ in the way in which they store multi-byte chunks of information,
    e.g., the 16-bit short integer 0111000011110010 = 70F2. This consists of the two
    bytes 70 and F2, where each byte encodes 8 bits. The two are two primary formats,
    and they differ only in the order or "[endianness](http://mindprod.com/jgloss/endian.html)"
    in which they store the bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Big endian* systems store the most significant bytes first, e.g., they store
    the integer above in its natural order 70F2. Java uses this format, as does Apple
    Mac, IBM PowerPC G5, Cray, and Sun Sparc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Little endian* systems store the least significant bytes first, e.g., they
    store the integer above in reverse byte-order F270\. This format is more natural
    when manually performing arithmetic, e.g., since for addition you work from least
    significant byte to most significant byte. Intel 8086, Intel Pentium, Intel Xeon
    use this format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Convert the decimal number 92 to binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: 1011100.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Convert the hexadecimal number `BB23A` to octal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: first convert to binary `1011 1011 0010 0011 1010`, then consider
    the bits three at a time `10 111 011 001 000 111 010`, and convert to octal `2731072`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the two hexadecimal numbers `23AC` and `4B80` and give the result in hexadecimal.
    *Solution*: 6F2C.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assume that *m* and *n* are positive integers. How many 1 bits are there in
    the binary representation of 2^(*m* + *n*)? *Solution*: 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the only decimal integer whose hexadecimal representation has its digits
    reversed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: 53 is 35 in hex.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Develop an implementation of the `toInt()` method for [Converter.java](Converer.java.html).
    that converts a character in the range `0-9` or `A-Z` into an `int` value between
    0 and 35.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop an implementation of the `toChar()` method for [Converter.java](Converer.java.html).
    that converts an `int` value between 0 and 35 into a character in the range `0-9`
    or `A-Z`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**IP address.** Write a program [IP.java](IP.java.html) that takes a 32-bit
    string as a command-line argument, and prints the corresponding IP address using
    *dotted decimal* notation. That is, take the bits 8 at a time, convert each group
    to decimal, and separate each group with a dot. For example, the binary IP address
    01010000000100000000000000000001 should be converted to `80.16.0.1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Excel column numbering.** Write a function that takes a nonnegative integer
    and converts it into the corresponding Excel column name (0 = A, 1 = B, ..., 25
    = Z, 26 = AA, ..., 702 = AAA).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Elias Gamma coding.** Write a function `elias` that takes as input an integer
    N and returns the Elias Gamma code as a string. The [Elias Gamma code](http://en.wikipedia.org/wiki/Elias_Gamma_coding)
    is a scheme to encode the positive integers. To generate the code for an integer
    N, write the integer N in binary, subtract 1 from the number of bits in the binary
    encoding, and prepend that many zeros. For example, the code for the first 10
    positive integers is given below.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bit reversal.** Write a function that takes an integer input, reverse its
    bits, and returns that integer. For example if n = 8, and the input is 13 (00001101),
    then its reversal is 176 (10110000).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bit-reversal sorting.** Use the previous algorithm to "sort" an array of
    N = 2^n elements into their bit-reversed order. Swap elements i and j if i and
    j are bit reversal of each other. Such permutations arise in the Fast Fourier
    Transform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Swap without temporary storage.** What do the following two code fragments
    do given integers a and b?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Answer: each 3-line fragment swaps a and b. It works provided a and b are not
    the same variables (in which case both variables are zeroed out).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Find the unique integer.** Suppose you have an array of 2N + 1 integers,
    and you know that each of N integers appear exactly twice. Describe an elegant
    and efficient algorithm to identify the integer that appears only once. *Hint*:
    xor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bit-whacking version of Gray codes** Use bit-whacking operations and iteration
    instead of recursion to generate a gray code. Name your program [BitWhackingGrayCode.java](BitWhackingGrayCode.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Free the prisoners I.** A warden meets with 17 new prisoners when they arrive.
    The warden tells them that they may meet today and plan a strategy, but after
    the meeting, each prisoner will be in solitary confinement and will not be able
    to communicate with one another. The prison has a switch room with 17 switches
    that can be on or off, although the initial configuration is not revealed. There
    is one special setting of the 17 switches that if it is ever achieved will enable
    the prisoners to go free. Each hour the warden escorts one prisoner to the switch
    room, where the prisoner can flip at most one switch (from on to off or off to
    on). The warden can choose prisoners in arbitrary order, so one prisoner may be
    chosen four times in a row, or not at all. Design a strategy for the 17 prisoners
    so that they are guaranteed to be set free after some finite amount of time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Free the prisoners II.** Same premise as above, except that the switch room
    has 2 switches (initially both off), and a prisoner must flip exactly one of the
    two switches upon entering the switch room. At any time, a prisoner may declare
    "all 17 of us have visited the control room." If it is true, all prisoners are
    freed; otherwise they are all executed. The warden can choose prisoners in arbitrary
    order, so one prisoner may be chosen four times in a row, but each prisoner will
    be chosen infinitely often (assuming they are never freed). Design a strategy
    for the 17 prisoners so that they are guaranteed to be set free after some finite
    amount of time. *Extra credit*: don''t assume the initial configuration is known.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Count the number of 1 bits.** Write function that takes an integer input
    and returns the [number of 1''s in its binary representation](http://www-db.stanford.edu/~manku/bitcount/bitcount.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: here are an iterative and a recursive solution.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is how `Integer.bitCount()` is implemented by Java. See if you can figure
    out how it works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Sparse bit-counting.** Explain why the following function (that often appears
    in job interviews for programmers) correctly counts the number of 1 bits in the
    binary representation of its input. If the input has k 1s, how many times does
    the while loop iterate?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Table lookup bit-counting.** Repeat the previous exercise, but pre-compute
    a table to speed up the computation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: this one assumes you have a precomputed table of size 256, with `bits[i]`
    storing the number of 1 bits in the binary representation of i. You can use the
    bit counting function from the previous exercise to initialize it. previous'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Increasing the table size to 2^(16) = 65,536 will make things faster assuming
    you have sufficient memory. A table of size 2^(32) is likely prohibitive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Java library functions for bit-whacking.** Re-implement the following static
    methods that defined in the [Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)
    class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| FUNCTION | RETURN VALUE |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.bitCount(x)` | Number of one-bits in x |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.highestOneBit(x)` | Zero out all but the leftmost one bit of x.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.lowestOneBit(x)` | Zero out all but the rightmost one bit of x.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.numberOfLeadingZeros(x)` | Number of zero bits preceding highest
    one bit. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.numberOfTrailingZeros(x)` | Number of zero bits following lowest
    one bit. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.rotateLeft(x, i)` | Rotate of x by circularly shifting i bits to
    the left. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.rotateRight(x, i)` | Rotate x by circularly shifting i bits to the
    right. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Integer.reverse(x)` | Reverse of the bits of x. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Dictionary attack.** One method that sleazy spammers use to auto-generate
    email addresses is by enumerating all possible email addresses at a give domain,
    e.g., hotmail.com. This annoying tactic is called a dictionary or Rumpelstiltskin
    attack and explains why you sometimes receive spam on a new email address to which
    you haven''t given to anybody. Use [Converter.java](Converter.java.html) to design
    such a program. Your program [Rumpelstiltskin.java](Rumpelstiltskin.java.html)
    should take a command line parameter N and print out all 36^N possible passwords
    of N or fewer characters involving numbers and uppercase letters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Breaking a gold chain.** You have a gold chain with 14 links that you are
    going to use to pay an worker for 15 days at a fee of 1 gold link per day. It''s
    possible to split the chain into 15 pieces by cutting 14 times. Your goal is to
    pay the worker while only breaking the chain 3 times. The worker must receive
    exactly the right fraction of total payment after each day of work. *Hint:* break
    the chain so there are pieces of 1 section, 2 sections, 4 sections, and 8 sections.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hamming encoder.** Write a Java program [HammingEncoder.java](HammingEncoder.java.html)
    that reads in a sequence of 0s and 1s, 4 bits at a time, and encodes them using
    Hamming codes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hamming decoder.** Write a Java program [HammingDecoder.java](HammingDecoder.java.html)
    that reads in a sequence of 0s and 1s encoded using Hamming codes, 7 bits at a
    time, and decodes and correct them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hamming codes.** Modify your solutions to the previous two exercises so that
    the input bits are packed 8 to the byte.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Absolute value.** The constant `Integer.MIN_VALUE` is the most negative 32-bit
    two''s complement integer. What is `Math.abs(Integer.MIN_VALUE)`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove that a k-digit decimal number can be represented in binary with no more
    than 4k bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sum of powers of 2.** Compute the sum of powers of 2. What value do you end
    up with on two''s complement machine?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CD Database.** CDDB and [freedb](http://freedb.org) are databases that allow
    you to look up CD information on the Web and display the artist, title, and song
    name. Each CD has a (nearly) unique disc ID number which is used to query the
    database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a static method sumDigits() that takes an integer parameter and returns
    the sum of the decimal digits in the integer. For example, sumDigits(6324) returns
    15 since 6 + 3 + 2 + 4 = 15.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a program [CDDB.java](CDDB.java.html) that computes the disc ID from
    a list of lengths of the track lengths. The 32-bit (8 hex digit) ID number is
    computed from the length of the tracks on the CD and the number of tracks as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: True or false. If a xor b = c, then c xor a = b and c xor b = a.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain why the following code fragment does not leave `ABCD` in variable `a`.
    How would you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*. In Java, `byte` is a signed 8-bit integer. The right-shift promotes
    `b0` to a (negative) integer. To fix the problem, use `c = ((b0 & 0xff) << 8)
    | (b1 & 0xff);`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Poisonous wine.** "You are the ruler of an empire and you are about to have
    celebration tomorrow. The celebration is the most important party you have ever
    hosted. You''ve got 1000 bottles of wine you were planning to open for the celebration,
    but you find out that one of them is poisoned. The actual poison exhibits no symptoms
    until somewhere around the 23rd hour, then results in sudden death. You have thousands
    of prisoners at your disposal. What is the smallest number of prisoners you must
    have to drink from the bottles to find the poisoned bottle?"'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: you can represent the number 1,000 using 10 bits.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unsigned 32-bit integers.** Describe how to simulate 32-bit unsigned integers
    in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: First, are you sure that you really need an unsigned type. Signed
    and unsigned integers behave identically on the bitwise operators (except >>),
    addition, subtraction, and multiplication. In many applications, these are sufficient,
    assuming you replace >> with >>>. Comparison operators are easy to simulate by
    checking the sign bit. Division and remainder are the trickiest: the easiest solution
    is to convert to type `long`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Program [UnsignedDivision.java](UnsignedDivision.java.html) uses this trick,
    and also does it directly using 32-bit operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unsigned 8-bit integers.** Describe how to simulate 8-bit unsigned integers
    in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: Same advice as previous question. One place where it''s nice to
    have unsigned integers is for a lookup table, indexed by the byte. With signed
    integers the index can be negative. Also, if `b` is a `byte`, then `b << 4` automatically
    casts `b` to an `int`. This could be undesirable since `b` is signed. In many
    applications you need to remove the signed extended bits via `(b << 4) & 0xff`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Adding two short integers.** Explain why the following code fragment fails.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: Java automatically promotes the results of most integer operations
    to be of type `int`. To assign the result to a `short`, you need to explicitly
    cast it back `c = (short) (a + b)`. Yes, this is rather quirky. One exception
    to this rule is if you use `+=`, in which case the cast is performed automatically.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Masking with byte.** Explain why `(b << i)` give weird results when `b` is
    of type `byte`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: In Java, `byte` is an 8-bit signed integer. Before the right shift,
    `b` is converted to an integer. You may want `((b & 0xff) << i)` instead.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How many bits are in the binary representation of 2^2^2^2^17?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code fragment from program [Overflow.java](Overflow.java.html)
    print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following code fragment print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List all values `a` of type `int` for which `(a == (a >> 1))`. *Hint*: there
    is more than one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose `a` is a variable of type `int`. Find two values of `a` for which `(a
    == -a)` is `true`. *Answer*: 0 and -2147483648.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is the result of `a = -1 * -2147483648`? *Answer*: 0.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code fragment print out?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Given two positive integers `a` and `b`, what result does the following Java
    code fragment leave in `c`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: a * b.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does the following code do to the integers stored in two different variables
    a and b?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat the previous question, but assume a and b are the same variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code do to the integers stored in two different variables
    a and b? Any problems with overflow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What do each of the following statements do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Increment x, decrement x*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does the following do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Answer: computes the parity of the number of 1 bits set in the binary representation
    of a using divide-and-conquer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the value of `cnt` after the following loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Hint*: it''s not an infinite loop.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explain why the following Java code fragment correctly determines whether the
    integer n is a power of 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Counting in base -2.** Use the definition of the positional notation to define
    the base -2 number system. There are two digits 0 and 1\. Count from -7 to 7 in
    this system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**RGBA color format.** Some of Java''s classes (BufferedImage, PixelGrabber)
    use a special encoding called RGBA to store the color of each pixel. The format
    consists of four integers, representing the red, green, and blue intensities from
    0 (not present) to 255 (fully used), and also the alpha transparency value from
    0 (transparent) to 255 (opaque). The four 8-bit integers are compacted into a
    single 32-bit integer. Write a code fragment to extract the four components from
    the RGBA integer, and to go the other way.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Min and max.** One of the following computes min(a, b), the other computes
    max(a, b) without branching. Which is which? Explain how it works.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Find the missing value.** Suppose you have an array consisting of 2^(32)
    - 1 integers of type `int` such that no integer appears more than once. Since
    there are 2^(32) possible values, exactly one integer is missing. Write a code
    fragment to find the missing integer using as little extra storage as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: this is a popular interview question. It''s possible to do it using
    only one extra `int`. Use either properties of integer overflow on two''s complement
    integers or use the XOR function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cyclic redundancy check.** Write programs [CRC16.java](CRC16.java.html) and
    [CRC32.java](CRC32.java.html) that read in data from standard input and computes
    its 16 or 32-bit CRC. Write a program [CRC16CCITT.java"](CRC16CCITT.java.html)
    for 16-bit CRC in CCITT format.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
