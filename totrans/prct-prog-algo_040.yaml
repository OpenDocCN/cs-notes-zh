- en: 7.3 Combinational Circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/73combinational](https://introcs.cs.princeton.edu/java/73combinational)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter under major construction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Domino adder.** This [video](https://www.youtube.com/watch?v=lNuPy-r1GuQ)
    shows a 4-bit ripple-carry adder that was implemented using 10,000 dominoes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design a circuit to control a single light bulb by three switches. The circuit
    has three inputs (the switch settings *x*, *y*, and *z*) and one output (the light
    control). At any time, you should be able to turn the light off (if on) or on
    (if off) by changing the position of any one of the three switches. When all three
    switches are 0 (down position), the light control is 0 (light off).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following TOY machine components are not *combinational circuits*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Counter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Main memory
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Adder
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Sum-of-products.** Disjunctive normal form. Algebraic properties: sum and
    product are commutative and associative, distributive property, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Product-of-sums.** Conjunctive normal form. Include a term for each 0 in
    the truth table trow.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Consensus theorems.** Verify that (a+b)(a''+c)(b+c) = (a+b)(a''+c) and (ab)
    + (a''c) + (bc) = (ab) + (a''c).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Duality.** The dual of any boolean identity is obtained by exchanging OR
    with AND and 0 with 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DeMorgan laws.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**XOR using NAND.** Implement an XOR gate using only NAND gates. Assume you
    can have inputs that are 0 or 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**XOR using NAND.** Implement an XOR gate using only 4 NAND gates. Assume you
    can have inputs that are 0 or 1. *Answer*: XOR(a, b) = NAND(d, e), where c = NAND(a,
    b), d = NAND(a, c), and e = NAND(b, c).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OR and NAND using NOR.** Implement OR using NOR gates. Implement NAND using
    NOR gates. Don''t assume that you can use inputs that are 0 or 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Universality.** Prove that the following combinations of gates are universal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '{ AND, NOT }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ OR, NOT }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ NAND }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ NOR }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ XOR, AND }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-universality.** Prove that the following gates are not universal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '{ AND }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ OR }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ XOR }'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AND from XOR.** Prove that you can''t make an AND gate out of XOR gates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution.* As above { XOR, AND } is universal. So if you could make an AND
    gate out of XOR gaets, { XOR } would be univeral. But in the previous question,
    you proved that it was not universal.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The 2-NOTs problem.** Give three inputs a, b, and c, design a circuit that
    outputs a'', b'', and c''. You may use as many AND and OR gates as you like, but
    at most two NOT gates. *Warning*: high degree of difficulty.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Flat computer.** Show that, in principle, you can draw and circuit in the
    plane. Assume two input AND, OR, and NOT can be drawn in the plane. It suffices
    to draw a crossover circuit. [planar cross-over circuit](http://www.math.uwaterloo.ca/navigation/ideas/Zeno/zenocs.shtml#flatcomp).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Comparator circuit.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**At least k.** A n-way majority circuit takes n inputs and returns 1 if and
    only if at least strictly more of its inputs are 1 than 0. Given an n-way majority
    circuit, describe how to build an At-Least-k circuit that returns 1 if and only
    if at least k of its inputs are 1. *Answer*: consider a 2n-way majority circuit.
    Make n-k+1 of the inputs 1, k-1 of the inputs 0, and the original n inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exactly k circuit.** Describe how to build a circuit that outputs 1 if and
    only if exactly k of its inputs are 1. *Answer*: If k = n, use an n-way and gate.
    Otherwise build up an At-least-k circuit and an At-least-k+1 circuit as in the
    previous exercise. It has exactly k inputs that are 1 if the first circuit outputs
    1, but the second one outputs 0.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Odd parity from majority gates.** Describe how to build an n-way odd parity
    circuit using only majority gates. You may assume that you have 0s and 1s as inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Odd parity.** Describe how to build an N-way odd parity circuit using only
    AND, OR, NOT. Hint: build a tree of 3-way odd parity gates, using ceil(2.5(N-1))
    total gates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is the smallest such circuit you can build for N = 2 to 6? The 3-way XOR
    tree construction is optimal for N = 2 to 5: 3 gates, 5 gates, 8 gates, and 10
    gates respectively. The answer is unknown for N = 6 (but is known to be either
    12 or 13). (Ingo Wegener, 1991)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**XOR from AND.** Design an XOR circuit using only AND and NOT. Use as few
    AND gates as possible. Min = 3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**MAJ from AND.** Design a 3-way MAJ circuit using only AND and NOT. Use as
    few AND gates as possible. Min = 4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adder from majority gates.** Describe how to build an n-bit ripple-carry
    adder circuit using only majority gates. You may assume that you have 0s and 1s
    available as inputs. *Hint*: build up a 3-way odd parity circuit out of 3-way
    majority circuits. Note that MAJ(x, y) = AND(x, y) and MAJ(x, y, 1) = OR(x, y).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Boolean logic puzzle.** You must transport a wolf, a goat, and a cabbage
    to the other side of the river using a boat. Due to natural predator relationships,
    you cannot leave the goat and the wolf alone on the same side of the river at
    the same time. Nor can you leave the goat and the cabbage together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![logic puzzle](../Images/959fd6d98b63ca7efaf696e0f4e4a58d.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Overflow of two''s complement adder.** How to detect overflow of two''s complement
    adder? Subtractor? <en>Answer If the carry out of the leftmost bit is different
    from the carry in.</en>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Boolean functions and circuits.** Let f be a boolean function on n input
    bits. Prove that for most functions f, the number of AND, OR, and NOT gates needed
    to implement f is at least 2^(n/3). Hint: prove that the number of circuits with
    m gates is at most 2^m and compare this quantity to the number of boolean functions
    on n inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
